//  Arithmetic sequences are generated by these routines.
//  Last modified on 06/06/74 at 18:21:22 by R F Mabee.
//  First installed as Version 3.4 by R F Mabee.
//  Written in April 1973 to properly divide the work between Trans and CG.

//  Copyright (c) 1974 by Massachusetts Institute of Technology and Honeywell Information Systems, Inc.

//  General permission is granted to copy and use this program, but not to sell it, provided that the above
//  copyright statement is given.  Contact Information Processing Services, MIT, for further information.
//  Please contact R F Mabee at MIT for information on this program and versions for other machines.

get "bcpl_cg_head"
get "bcpl_opcodes"

let ApplyDiadicOperator (Op, Result) be
     $(	let Reg = valof switchon Op into
	     $(	case PLUS_S:
			if Optimize then if TryDiadicRAR (Result, Asa) resultis 0
			resultis ApplySymmetrical (Ada, AorQr)
	
		case PLUS_F:
			resultis ApplySymmetrical (Fad, EAQr)
	
		case MINUS_S:
			if Optimize do
			     $(	if TryDiadicRAR (Result, Ssa) resultis 0
				if InRegister (Rrand, AorQr) & not InRegister (Lrand, AorQr) do
				     $(	let r = ApplyRL (Sba, AorQr)
					resultis ApplyNegate (r)
				     $)
			     $)
			resultis ApplyLR (Sba, AorQr)
	
		case MINUS_F:
			if Optimize then if InRegister (Rrand, EAQr) do
				     $(	ApplyRL (Fsb, EAQr)
					resultis ApplyNegate (EAQr)
				     $)
			resultis ApplyLR (Fsb, EAQr)
	
		case MULT_S:
			if Optimize do
			     $(	let r = TryShift (Lrand, Rrand)
				if r ne 0 resultis r
				r := TryShift (Rrand, Lrand)
				if r ne 0 resultis r
				if (InRegister (Lrand, Ar) & not InRegister (Rrand, Qr))
				   | (InRegister (Rrand, Ar) & not InRegister (Lrand, Qr)) do SwapAandQ ()
			     $)
			GetRegister (Ar)		//  Overwritten by multiply hardware.
			resultis ApplySymmetrical (Mpy, Qr)
	
		case MULT_F:
			resultis ApplySymmetrical (Fmp, EAQr)
	
		case DIV_S:
			if Optimize then if InRegister (Lrand, Ar) do SwapAandQ ()
			GetRegister (Ar)		//  Overwritten by divide hardware.
			resultis ApplyLR (Div, Qr)
	
		case DIV_F:
			if Optimize then if InRegister (Rrand, EAQr) do
				resultis ApplyRL (Fdi, EAQr)
			resultis ApplyLR (Fdv, EAQr)
	
		case REM_S:
			if Optimize then if InRegister (Lrand, Ar) do SwapAandQ ()
			GetRegister (Ar)		//  Remainder appears in Ar but operands do not.
			ApplyLR (Div, Qr)
			resultis Ar
	
		case LOGOR_S:
			if Optimize then if TryDiadicRAR (Result, Orsa) resultis 0
			resultis ApplySymmetrical (Ora, AorQr)
	
		case LOGAND_S:
			if Optimize then if TryDiadicRAR (Result, Ansa) resultis 0
			resultis ApplySymmetrical (Ana, AorQr)
	
		case NEQV_S:
			if Optimize then if TryDiadicRAR (Result, Ersa) resultis 0
			resultis ApplySymmetrical (Era, AorQr)
	
		case EQV_S:    $(	let r = ApplySymmetrical (Era, AorQr)
				Literal (true, "true")
				Outop (FormOpcode (Era, r))
				resultis r
			     $)
	
		default:	CGreport (UnexpectedCase, Op, "ApplyDiadicOperator")
			resultis 0
	     $)
	DisclaimRegister (Lrand)
	DisclaimRegister (Rrand)
	ClaimRegister (Reg, Result)
     $)

and ApplyOffsetOperator (Op, Result, Offset) be
     $(	let Reg = valof switchon Op into
	     $(	case VECAP_S:
			if Result!0 = LV_TEMP goto RememberAddress
			let r = GetRegister (AorQr)
			CombineAddress (Lrand, Rrand, Offset)
			Outop (FormOpcode (Lda, r))
			IndicatorsSetBy := r
			resultis r
	
		case LVECAP_S:
			if Result!0 = LV_TEMP goto RememberAddress
			if Optimize then if IsSameLoc (Result, Lrand) do
			     $(	let r = nil
				test IsZero (Rrand)
				then $(	if Offset = 1 do
					     $(	SetupAddr (Result)
						Outop (Aos)
						IndicatorsSetBy := 0
						resultis 0
					     $)
					r := LoadNumber (Offset, AorQr)
				     $)
				or   $(	r := LoadRegister (Rrand, AorQr)
					unless Offset = 0 do
					     $(	Literal (Offset)
						Outop (FormOpcode (Ada, r))
					     $)
				     $)
				SetupAddr (Result)
				Outop (FormOpcode (Asa, r))
				IndicatorsSetBy := 0
				RegisterUsage!r := 0
				resultis 0
			     $)
			r := GetRegister (AnyPr)
			CombineAddress (Lrand, Rrand, Offset)
			Outop (FormOpcode (Eapap, r))
			resultis r
	
		RememberAddress:
			let h = MakeCgTemp (Result!1)
			h!1 := Op
			h!2, h!3, h!4 := Lrand!0, Lrand!1, Lrand!2
			h!5, h!6, h!7 := Rrand!0, Rrand!1, Rrand!2
			h!8 := Offset
			return

		case LSHIFT_S:
		case RSHIFT_S:
			     $(	let r = LoadRegister (Lrand, AorQr)
				let Xr = IsZero (Rrand) -> 0, LoadIndex (Rrand, AnyXr)
				Outop3 (FormOpcode (Op = LSHIFT_S -> Als, Arl, r), Offset, FormTag (Xr))
				IndicatorsSetBy := r
				resultis r
			     $)
	
		default:	CGreport (UnexpectedCase, Op, "ApplyAddressOperator")
			resultis 0
	     $)
	DisclaimRegister (Lrand)
	DisclaimRegister (Rrand)
	ClaimRegister (Reg, Result)
     $)

and ApplyMonadicOperator (Op, Result) be
     $(	let Reg = valof switchon Op into
	     $(	case POS_S:
		case POS_F:
		case ASSIGN_S:
			if Optimize then if Result!0 ne LV_TEMP do
			     $(	Store (Lrand, Result)
				resultis 0
			     $)
			resultis LoadAppropriateRegister (Lrand, 0)
	
		case NEG_S:
			if Optimize then if TryMonadicRAR (Result, Ssa, 0) resultis 0
			resultis LoadNegative (Lrand)
	
		case NEG_F:
			resultis ApplyNegate (LoadRegister (Lrand, EAQr))
	
		case NOT_S:
			if Optimize then if TryMonadicRAR (Result, Ersa, true) resultis 0
			let r = FindInRegister (Lrand, AorQr)
			test r = 0
			then $(	r := LoadNumber (true, AorQr, "true")
				Makeaddressable (Lrand)
			     $)
			or Literal (true, "true")
			Outop (FormOpcode (Era, r))
			IndicatorsSetBy := r
			resultis r

		default:	CGreport (UnexpectedCase, Op, "ApplyMonadicOperator")
			resultis 0
	     $)
	DisclaimRegister (Lrand)
	ClaimRegister (Reg, Result)
     $)
	
and ApplySymmetrical (Inst, Reg) = InRegister (Rrand, Reg) -> ApplyRL (Inst, Reg), ApplyLR (Inst, Reg)
and ApplyRL (Inst, Reg) = valof
     $(	let t, u = Lrand, Rrand
	Rrand, Lrand := t, u
	let r = ApplyLR (Inst, Reg)
	Lrand, Rrand := t, u
	resultis r
     $)
and ApplyLR (Inst, Reg) = valof
     $(	let r = LoadRegister (Lrand, Reg)
	Makeaddressable (Rrand)
	Outop (FormOpcode (Inst, r))
	IndicatorsSetBy := r
	resultis r
     $)
and ApplyNegate (r) = valof
  switchon r into
     $(	case Qr:	if RegisterTemps!Ar = 0 do
		     $(	Outop3 (Negl, 0, Dl)
			IndicatorsSetBy := 0
			resultis Qr
		     $)
		SwapAandQ ()
	case Ar:	Outop3 (Neg, 0, Dl)
		IndicatorsSetBy := Ar
		resultis Ar
	case EAQr:Outop3 (Fneg, 0, Dl)
		IndicatorsSetBy := EAQr
		resultis EAQr
	default:	CGreport (UnexpectedCase, r, "ApplyNegate")
		resultis r
     $)
and LoadNegative (t) = valof
     $(	let r = FindInRegister (t, AorQr)
	if r ne 0 resultis ApplyNegate (r)
	r := GetRegister (AorQr)
	Makeaddressable (t)
	Outop (FormOpcode (Lca, r))
	IndicatorsSetBy := r
	resultis r
     $)

and TryShift (Rand, Const) = valof
     $(	unless IsNumber (Const) resultis 0
	let n, i = EvalNumber (Const!0, Const!1), 0
	until n = (1 lshift i) do
	     $(	if i > 36 resultis 0
		i := i + 1
	     $)
	let r = LoadRegister (Rand, AorQr)
	Outop3 (FormOpcode (Als, r), i, 0)
	IndicatorsSetBy := r
	resultis r
     $)

and TryMonadicRAR (Result, Op, Const) = valof
     $(	unless IsSameLoc (Result, Lrand) resultis false
	let r = LoadNumber (Const, AorQr, 0)
	SetupAddr (Result)
	Outop (FormOpcode (Op, r))
	IndicatorsSetBy := 0
	RegisterUsage!r := 0
	resultis true
     $)
and TryDiadicRAR (Result, Op) = valof
     $(	let X = Rrand
	unless IsSameLoc (Result, Lrand) do
	     $(	X := Lrand
		unless IsSameLoc (Result, Rrand) resultis false
	     $)
	if Op = Asa & IsNumber (X) then if EvalNumber (X!0, X!1) = 1 do
	     $(	SetupAddr (Result)
		Outop (Aos)
		IndicatorsSetBy := 0
		resultis true
	     $)
	let r = nil
	test Op = Ssa & X = Rrand
	then r, Op := LoadNegative (X), Asa
	or r := LoadRegister (X, AorQr)
	SetupAddr (Result)
	Outop (FormOpcode (Op, r))
	IndicatorsSetBy := 0
	RegisterUsage!r := 0
	resultis true
     $)

and IsSameLoc (t, u) = valof
  switchon t!0 into
     $(	case LV_GLOBAL:
		resultis u!0 = GLOBAL_S & t!1 = u!1 -> true, false
	case LV_LOCAL:
		resultis u!0 = LOCAL_S & t!1 = u!1 -> true, false
	case LV_STATIC:
		resultis u!0 = STATIC_S & t!1 = u!1 -> true, false
	case TEMP_S:
		unless u!0 = TEMP_S resultis false
		let g, h = LookupTemp (t!1), LookupTemp (u!1)
		if g = 0 | h = 0 resultis false
		unless g!1 = LVECAP_S & h!1 = VECAP_S resultis false
		resultis g!2 = h!2 & g!3 = h!3 & g!5 = h!5 & g!6 = h!6 & g!8 = h!8 -> true, false
	default:	resultis false
     $)

and DiadicJumpcond (Op, L) be
     $(	let Reversed = valof switchon Op into
	     $(	case EQ_S: case NE_S: case LS_S: case GR_S: case LE_S: case GE_S:
			if IsZero (Rrand) do
			     $(	CompareToZero (Lrand)
				resultis false
			     $)
			if IsZero (Lrand) do
			     $(	CompareToZero (Rrand)
				resultis true
			     $)
			if InRegister (Rrand, AorQr) do
			     $(	ApplyRL (Cmpa, AorQr)
				IndicatorsSetBy := 0
				resultis true
			     $)
			ApplyLR (Cmpa, AorQr)
			IndicatorsSetBy := 0
			resultis false
	
		case EQ_F: case NE_F: case LS_F: case GR_F: case LE_F: case GE_F:
			if InRegister (Rrand, EAQr) do
			     $(	ApplyRL (Fcmp, EAQr)
				IndicatorsSetBy := 0
				resultis true
			     $)
			ApplyLR (Fcmp, EAQr)
			IndicatorsSetBy := 0
			resultis false

		default:	CGreport (UnexpectedCase, Op, "DiadicJumpcond")
			return
	     $)

	let t = valof switchon Op into
	     $(	case EQ_S: case EQ_F:	resultis Tze
		case NE_S: case NE_F:	resultis Tnz
		case LS_S: case LS_F:	resultis Reversed -> Tpnz, Tmi
		case GR_S: case GR_F:	resultis Reversed -> Tmi, Tpnz
		case LE_S: case LE_F:	resultis Reversed -> Tpl, Tmoz
		case GE_S: case GE_F:	resultis Reversed -> Tmoz, Tpl
	     $)

	if Machine = 645 test t = Tmoz
		then $(	Outop2 (Tmi, L)
			t := Tze
		     $)
		or if t = Tpnz do
		     $(	Outop3 (Tze, 2, Ic)
			t := Tpl
		     $)
	Outop2 (t, L)
	DisclaimRegister (Lrand)
	DisclaimRegister (Rrand)
     $)

and MonadicJumpcond (Op, L) be
     $(	CompareToZero (Lrand)
	Outop2 (Op = TRUE_S -> Tnz, Tze, L)
	DisclaimRegister (Lrand)
     $)
