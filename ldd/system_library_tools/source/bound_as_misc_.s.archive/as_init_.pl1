/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1990   *
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

/****^  HISTORY COMMENTS:
  1) change(86-05-13,GJohnson), approve(86-05-13,MCR7387),
     audit(86-05-13,Martinson), install(86-05-14,MR12.0-1055):
     Correct error message documentation.
  2) change(86-05-15,Gilcrease), approve(86-05-16,MCR7370),
     audit(86-06-25,Lippard), install(86-06-30,MR12.0-1082):
               Update UTE version to 3, for -truncate .absout SCP 6297.
  3) change(86-06-29,Swenson), approve(87-07-13,MCR7741),
     audit(87-07-30,Brunelle), install(87-08-04,MR12.1-1055):
      A) Modified to zero anstbl.login_server_present upon AS initialization.
      B) Also added code to allow testing of answering service.
  4) change(87-03-10,GDixon), approve(87-07-13,MCR7741),
     audit(87-07-30,Brunelle), install(87-08-04,MR12.1-1055):
      A) Also zeroed anstbl.(login_server_process_id
         login_server_event_channel) upon AS initialization.
      B) Removed initialization of ls_request_server_ from as_init_, since
         this facility is not B2 certified and is only needed at sites
         running DSA.
      C) Corrected coding errors and standard violations.
      D) Move initialization of ls_message_buffer back into as_init_.  It is
         needed for act_ctl_ and load_ctl_.
      E) Upgraded for change to answer_table.incl.pl1 and
         user_table_entry.incl.pl1
  5) change(87-05-06,GDixon), approve(87-07-13,MCR7741),
     audit(87-07-30,Brunelle), install(87-08-04,MR12.1-1055):
     Don't call mc_quiesce_ when running test Answering Service.
  6) change(87-06-22,GDixon), approve(87-07-13,MCR7741),
     audit(87-07-30,Brunelle), install(87-08-04,MR12.1-1055):
      A) Correctly set as_data_$rs_ptrs.  The do group index wasn't properly
         used, causing reference through unset variable.
  7) change(87-06-28,GDixon), approve(87-07-13,MCR7741),
     audit(87-07-30,Brunelle), install(87-08-04,MR12.1-1055):
      A) Correct error message printed for sub_error_ condition by ucs
         procedure.
  8) change(87-07-11,GDixon), approve(87-07-11,MCR7741),
     audit(87-07-30,Brunelle), install(87-08-04,MR12.1-1055):
      A) Set as_data_$rtdtp to null after the RTDT is terminated by as_init_.
  9) change(87-07-27,GDixon), approve(87-07-27,MCR7741),
     audit(87-07-30,Brunelle), install(87-08-04,MR12.1-1055):
      A) Removed call to network_accounting_gate_$test.  This is now done in
         ls_request_server_$init.
      B) Added descriptions for undoc'd operator messages.
      C) Convert to sys_log_$general for many calls.
 10) change(87-08-28,GDixon), approve(87-08-28,PBF7741),
     audit(87-08-28,Martinson), install(87-09-01,MR12.1-1095):
      A) Correct calls to Abort internal proc to ensure that they always pass
         a ioa_ control string.  Otherwise, sys_log_$general reports an
         error.
      B) Change $check_shut_ok to check for as_data_$ansp being null.  If so,
         then set return arg to indicate no users are logged in.
 11) change(87-09-24,GDixon), approve(88-01-06,MCR7786),
     audit(88-01-08,Parisek), install(88-01-12,MR12.2-1012):
      A) Change calls to Abort internal proc to pass a code of -1 rather than
         0.  Abort calls sys_log_$general which ignores the message in the
         call when the code is 0.  It special-cases code values of -1 by
         printing the ioa_ control string but excluding expansion of the
         error table code value. (as 562)
      B) Call condition_interpreter_ to further describe unexpected conditions
         occurring during as initialization. (as 394, phx18406)
 12) change(90-10-03,WAAnderson), approve(90-10-03,MCR8213),
     audit(90-10-10,Vu), install(90-10-14,MR12.4-1040):
     Removed extraneous '^a:' from log message.
                                                   END HISTORY COMMENTS */


/* format: style4 */
as_init_:
     proc (a_code);

/* Answering Service initization procedure

   Originally coded by J. F. Ossanna Jan 1969
   Recoded by Michael J. Spier and Robert C. Daley February 1969
   Revised by Michael D. Schroeder,  June 1969
   Recoded in PL/1 for new System/User Control by Michael J. Spier,  January 1970
   revised nov 70 THVV
   modified for new SAT format by Janice B. Phillipps, March 1972
   revised March 73 THVV
   Modified 750309 by PG to add request dispatcher
   Modified 750415 by PG to initialize initial_modes_table
   Modified July 1975 by: WSS, TAC, and LJS, for RCP, Priority Scheduler, and syserr logging, respectively.
   Modified Aug 75 by THVV for Channel Definition Table
   Modified April 1976 by T. Casey to be sure to print error messages if initialization fails
   Modified May 1976 by T. Casey to save and restore shift information in whotab header,
   .                and by P. Green to change initial modes for network lines.
   Modified 760618 by Roy P. Planalp to attach FTP channels
   Modified August 1976 by T. Casey to initialize for loading FNPs.
   Modified November 1976 by T. Casey to fix initialization of stopped FNP.
   Modified December, 1976, by D. M. Wells to validate ARPANET host number in
   installation_parms.
   Modified June, 1977, by Robert S. Coren to remove references to initial_modes_table.
   Modified August 1977 by T. Casey to call pdir_volume_manager_$init.
   .		and to complete channel deletions requested by CDT installations during last bootload.
   Modified 03/20/78 by C. D. Tavares for new rcp handling (RTDT).
   Modified May 1978 by T. Casey to add an argument to the load_ctl_$set_maxunits call.
   Modified Fall 1978 by Larry Johnson for ring-0 demultiplexing.
   Modified November 1978 by T. Casey for MR7.0 absentee control parameters and other new installation_parms.
   Modified April 1979 by T. Casey for Mr7.0a to put back feature to not do automatic abs start in a special session.
   Modified August 1979 by C. Hornig to only listen to non-MCS channels during initialization and for new PNT.
   Modified Feb 1980 by M. B. Armstrong to implement multiple rate structures. (UNCA)
   Modified March 1980 by Tom Casey to implement metering of answering service resource usage.
   Modified June 1981 by E. N. Kittlitz for UNCA rate-structures
   Modified June 1981 by T. Casey for MR9.0 to set event wait channel priority highest.
   Modified August 1981 by E. N. Kittlitz for ucs recursion counter.
   Modified November 1981, E. N. Kittlitz.  user_table_entry conversion.
   Modified December 1981, E. N. Kittlitz.  convert to whotab version 1.
   Modified December 1981, Benson I. Margulies. CDT tree initialization.
   Modified February 1982, E. N. Kittlitz  to fix ucs recursion counter.
   Modified April 1982, E. N. Kittlitz. beginnings of new AS initialization strategy.
   Modified October 1982, E. N. Kittlitz.  rename as_request_ to as_request_server_, add mc_quiesce_.
   Modified January 1982, E. N. Kittlitz.  turn_on_mc_ before doing anything else.
   Modified 83-11-21 BIM. turn quota checking on, having changed pds to start out with quota checking off.
   Modified 84-04-02 BIM. Remove support for cdte.dim. All channels are MCS.
   Modified 1984-09-13 BIM. Initialize anstbl.max_users, the answering
   service's idea of the number of APTE's, from the
   TCD card. This insures consistency with the hardcore.
   Modified:
   10/02/84 by R. Michael Tague: Changed the as_data_$acsdir from rcp to
   admin_acs.
   Modified 84-11-04 by E. A. Ranzenbach for whotab.session...
   Modified 1984-12, BIM: ssu_ system control and related changed.
   Modified 1985-01-15 by E. Swenson for anstbl.session_uid_counter.
   Modified 1985-02-18, BIM: call as_user_message_$system_init.
   Modified 1985-04-19, E. Swenson to correct any_other handler.
*/

/* Parameters */

dcl  a_code fixed bin (35) parameter;
dcl  a_n_users fixed bin (35) parameter;

/* External Static */

dcl  active_all_rings_data$system_id char (8) aligned ext;
dcl  error_table_$action_not_performed fixed bin (35) ext static;
dcl  error_table_$no_r_permission fixed bin (35) ext static;
dcl  error_table_$no_w_permission fixed bin (35) ext static;
dcl  error_table_$noentry fixed bin (35) ext static;
dcl  error_table_$unexpected_condition fixed bin (35) ext static;
dcl  error_table_$unimplemented_version fixed bin (35) ext static;
dcl  sys_info$max_seg_size fixed bin (35) ext static;

/* Entries */

dcl  absentee_user_manager_$abs_as_init entry;
dcl  absentee_user_manager_$term_aum entry;
dcl  act_ctl_$act_ctl_close entry;
dcl  act_ctl_$init entry;
dcl  admin_$down1 entry (fixed bin (71), char (*) aligned, fixed bin (71));
dcl  as_dump_$dont_use_mc entry (char (*));
dcl  as_meter_$asmt_init entry;
dcl  as_meter_$enter entry (fixed bin);
dcl  as_meter_$exit entry (fixed bin);
dcl  as_request_server_$init entry;
dcl  asu_$init entry;
dcl  as_user_message_$priv_system_init entry (fixed bin (35));
dcl  cdt_mgr_$thread entry (ptr, fixed bin (35));
dcl  condition_ entry (char (*), entry);
dcl  config_$find entry (character (4) aligned, pointer);
dcl  cu_$level_set entry (fixed bin (6));
dcl  daemon_user_manager_$init entry;
dcl  device_acct_$init entry;
dcl  dialup_$init entry;
dcl  get_group_id_ entry () returns (char (32));
dcl  get_group_id_$tag_star entry () returns (char (32));
dcl  get_process_id_ entry () returns (bit (36));
dcl  get_ring_ entry () returns (fixed bin (3));
dcl  get_system_free_area_ entry() returns(ptr);
dcl  hash_$search entry (ptr, char (*), bit (36) aligned, fixed bin (35));
dcl  hc_initlzr_auxl_init_$init entry;
dcl  hcs_$add_acl_entries entry (char (*), char (*), ptr, fixed bin, fixed bin (35));
dcl  hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
dcl  hcs_$replace_acl entry (char (*), char (*), ptr, fixed bin, bit (1), fixed bin (35));
dcl  hcs_$set_ring_brackets entry (char (*), char (*), (3) fixed bin (3), fixed bin (35));
dcl  hcs_$terminate_noname ext entry (pointer, fixed bin (35));
dcl  hcs_$truncate_seg entry (ptr, fixed bin, fixed bin (35));
dcl  hcs_$wakeup entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
dcl  hphcs_$restore_quota entry;
dcl  ipc_$set_wait_prior entry (fixed bin (35));
dcl  initiate_file_ entry (char (*), char (*), bit (*), ptr, fixed bin (24), fixed bin (35));
dcl  ioa_ entry () options (variable);
dcl  ioa_$rsnnl entry () options (variable);
dcl  lg_ctl_$init entry (bit (1) aligned);
dcl  load_ctl_$init entry;
dcl  load_ctl_$set_maxunits entry (fixed bin);
dcl  ls_request_server_$shutdown entry (fixed bin (35));
dcl  mail_table_priv_$test entry (char (*));
dcl  mc_quiesce_ entry;
dcl  multiplexer_mgr_$init entry (pointer, fixed bin (35));
dcl  multiplexer_mgr_$shut entry;
dcl  multiplexer_mgr_$system_go entry;
dcl  multiplexer_mgr_$system_init entry (fixed bin (35));
dcl  pathname_ entry (char (*), char (*)) returns (char (168));
dcl  pdir_volume_manager_$init entry;
dcl  phcs_$ring_0_message entry (char (*));
dcl  pnt_manager_$test entry (char (*));
dcl  rcp_sys_$initialize ext entry (1 aligned like rcp_init_flags, fixed bin (35));
dcl  reassign_work_classes_ entry (fixed bin (35));
dcl  sys_log_ entry options (variable);
dcl  syserr_log_man_$as_copy_init entry (char (*), fixed bin (9));
dcl  syserr_log_man_$as_copy_log entry;
dcl  timer_manager_$sleep entry (fixed bin (71), bit (2));
dcl  turn_on_mc_ entry;
dcl  up_sat_$make_sat_hash entry (ptr, fixed bin, ptr, char (*), fixed bin (35));
dcl  up_sysctl_$init entry;

/* builtins */

dcl  (addr, bin, bit, clock, divide, fixed, hbound, length, null, rel, rtrim, size, substr) builtin;

/* Internal Static */

dcl  (next_sd, next_sd_until) fixed bin (71) int static;
dcl  next_sd_msg char (124) aligned int static;

/* Constant */

dcl  FALSE bit (1) aligned initial ("0"b) internal static options (constant);
dcl  ME char (8) int static init ("as_init_") options (constant);
dcl  MINS_30 fixed bin (71) int static init (1800000000) options (constant);
dcl  NL char (1) aligned int static init ("
") options (constant);
dcl  TRUE bit (1) aligned initial ("1"b) internal static options (constant);

/* Automatic */

dcl  abort_label label automatic;
dcl  answer char (100);
dcl  autp ptr automatic;
dcl  cdt_scan_try_count fixed bin;
dcl  check fixed bin;
dcl  code fixed bin (35);
dcl  debug_flag bit (1) aligned automatic;
dcl  dutp ptr automatic;
dcl  error_message_entry entry variable options (variable);
dcl  i fixed bin;
dcl  ip ptr automatic;
dcl  last_sc fixed bin (71);
dcl  metering_enabled bit (1) aligned automatic;
dcl  n_acl fixed bin;
dcl  next_sc fixed bin (71);
dcl  normal_flag bit (1) aligned;
dcl  rbkt (3) fixed bin (3);
dcl  rs_name char (32) automatic;
dcl  rs_number fixed bin automatic;
dcl  sat_htp ptr automatic;
dcl  satp ptr automatic;
dcl  shift fixed bin;				/* to save shift info while truncating whotab */
dcl  system_area_ptr        ptr automatic;
dcl  system_control_dir char (168) automatic;
dcl  ucs_recursion fixed bin init (0);			/* level of signal recursion */
dcl  x fixed bin;
dcl  whoptr ptr automatic;

dcl  1 acla (5) aligned,				/* ACL structure */
       2 userid char (32),
       2 mode bit (36),
       2 rpad bit (36) init ((5) (36)"0"b),
       2 retcd fixed bin (35);

dcl  1 our_acl aligned like general_extended_acl_entry automatic;

/* Based */

dcl  system_area	        area based (system_area_ptr);

/* INCLUDE FILES are at the end, after all the code, but before the message documentation */

as_init:
     entry (a_code);

	normal_flag = "0"b;				/* Special session */
	go to initialize;

startup:
     entry (a_code);

	normal_flag = "1"b;				/* not special session */

initialize:

	metering_enabled = FALSE;
	code = 0;
	abort_label = INIT_RETURN;

	if sc_stat_$Multics then			/* reject re-initialization */
	     call Abort (error_table_$action_not_performed,
		"Multics already initialized.");

	if sc_stat_$test_mode then do;		/* are we debugging? */
	     as_data_$debug_flag = TRUE;
	     debug_flag = TRUE;
	end;
	else do;					/* not debugging */
	     as_data_$debug_flag = FALSE;
	     debug_flag = FALSE;
	end;

	system_control_dir = sc_stat_$sysdir;		/* copy system directory name into internal static */
	as_data_$sysdir = system_control_dir;
	as_data_$pdtdir = rtrim (system_control_dir) || ">pdt";
	as_data_$acsdir = rtrim (system_control_dir) || ">admin_acs";
	as_data_$rcpdir = rtrim (system_control_dir) || ">rcp";

	if ^debug_flag then
	     call condition_ ("any_other", ucs);	/* Set up ugh. */

	if ^debug_flag then
	     call hphcs_$restore_quota;		/* allow record_quota_overflow */
	call as_meter_$asmt_init;
	call as_meter_$enter (ASINIT_METER);
	metering_enabled = TRUE;

/* get the SAT. We need it now to set up the acl structure */

	call Initiate_Segment ("sat", satp);
	as_data_$satp = satp;

	if sat.version ^= SAT_version then		/* SAT must be correct flavor. */
	     call Abort (error_table_$unimplemented_version,
		"SAT version inconsistent with declarations used in this program.");


	rbkt (1) = as_data_$as_ring;			/* Set up ring brackets. */
	rbkt (2), rbkt (3) = as_data_$max_user_ring;
	acla.userid (1) = get_group_id_ ();		/* Set up useful ACL. */
	acla.userid (2) = "*.SysDaemon.*";		/* ... */
	n_acl = 3;				/* Continue with 3rd acla entry. */
	do i = 1 to 2 while (sat.system_admin (i) ^= ""); /* Generate ACL entries for the good guys */
	     acla.userid (n_acl) = rtrim (sat.system_admin (i)) || ".*"; /* Put administrators on ACL. */
	     n_acl = n_acl + 1;			/* ... */
	end;
	acla.userid (n_acl) = "*.*.*";		/* This ACL provides for everybody. */
	do i = 1 to n_acl;				/* More setup. */
	     acla.mode (i) = RW_ACCESS;		/* RW for all entries. */
	end;
	acla.mode (2) = R_ACCESS;			/* Daemons not to mess up */
	acla.mode (n_acl) = N_ACCESS;			/* Average user gets no access to system tables. */

	call ipc_$set_wait_prior (code);		/* Input on operator console has highest priority */
						/* See as_wakeup_priorities.incl.pl1 for more information */
	if code ^= 0 then
	     call Log_Error (code,
		"Could not set priority for IPC wait channels.");

/* set up the template pit */

	call hcs_$make_seg ("", "pit_temp_", "", 01011b, as_data_$pit_ptr, code); /* create pit template segment */
	if as_data_$pit_ptr = null then		/* what! our own process directory? */
	     call Abort (code, "Cannot create pit_temp_.");

/* get the SAT paraphernalia */

	call Create_Segment ("sat.ht", sat_htp);	/* by hook or by crook */

	if sat_htp -> htable.id ^= "ht01" & sat_htp -> htable.id ^= "ht02" then go to make_sat_hash; /* reasonable? */
	call hash_$search (sat_htp, "SysDaemon", (""b), code); /* give it a try */
	if code ^= 0 then do;
make_sat_hash: call Log_Error (-1, "Rebuilding SAT hash table.");
	     call up_sat_$make_sat_hash (satp, sat.n_projects, sat_htp, answer, code);
	     if code ^= 0 then
		call Abort (code, "Cannot create ^a>sat.ht. ^a.",
		     system_control_dir, answer);
	end;
	as_data_$sat_htp = sat_htp;

/* Setup the various user tables */

	call Create_Segment ("answer_table", ansp);
	as_data_$ansp = ansp;
	call Create_Segment ("absentee_user_table", autp);
	as_data_$autp = autp;
	call Create_Segment ("daemon_user_table", dutp);
	as_data_$dutp = dutp;

/* Get installation parameters and rate structures */

	call Initiate_Segment ("installation_parms", ip);
	as_data_$rs_ptrs (0) = ip;

	if installation_parms.version ^= installation_parms_version_2 then
	     call Abort (error_table_$unimplemented_version,
		"installation_parms version ^d",
		installation_parms.version);

	if installation_parms.nrates < 0 |
	     installation_parms.nrates > hbound (as_data_$rs_ptrs, 1) then
	     call Abort (-1,
		"installation_parms damaged. ^d rate structures defined; from ^d to ^d are allowed.",
		installation_parms.nrates, 0, hbound(as_data_$rs_ptrs,1));

	do rs_number = 1 to installation_parms.nrates;	/* other rates */
	     call ioa_$rsnnl ("rate_structure_^d", rs_name, (0), rs_number);
	     call Initiate_Segment (rs_name, as_data_$rs_ptrs (rs_number));
	end;

	if installation_parms.chn_wakeup_error_loop_count <= 0 then installation_parms.chn_wakeup_error_loop_count = 10;
	if installation_parms.chn_wakeup_error_loop_seconds <= 0 then
	     installation_parms.chn_wakeup_error_loop_seconds = 3;

/* The resource stuff */

	call Initiate_Segment ("rtdt", rtdtp);
	as_data_$rtdtp = rtdtp;

	RTDT_area_len = 0;				/* avoid PL/1 warning */
	if rtdt.installed_under_resource_mgt then
	     if installation_parms.rcp_init_flags.resource_mgmt_enabled = ""b then
		call Abort (-1, "Resource management is disabled; ^a>rtdt needs it enabled.",
		     system_control_dir);

	as_data_$rtdtp = null;
	call hcs_$terminate_noname (rtdtp, 0);

/* First shot at the multiplexers */

	call multiplexer_mgr_$init (cdtp, code);	/* Get cdt ptr */
	if code ^= 0 then
	     call Abort (code, "Calling multiplexer_mgr_$init.");
	as_data_$cdtp = cdtp;

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* Initialize the who table.  This is a public listing of logged-in users    */
/* Cannot use Create_Segment for this, since whotab must have nonnull	       */
/* reference name.						       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	call hcs_$make_seg (system_control_dir, "whotab", "whotab_", 1010b, whoptr, code);
	if whoptr = null then
	     call Abort (code, "Could not create ^a>whotab",
		system_control_dir);

	our_acl.access_name = get_group_id_$tag_star ();
	our_acl.mode = RW_ACCESS;
	our_acl.extended_mode = ""b;
	our_acl.status_code = 0;

	call hcs_$add_acl_entries (system_control_dir, "whotab", addr (our_acl), 1, code);
	if code ^= 0 then
	     call Abort (code, "Could not set RW access on ^a>whotab.",
		system_control_dir);

	as_data_$whoptr = whoptr;
	next_sd = whotab.nextsd;			/* Was previous shutdown? */
	next_sd_msg = whotab.why;			/* .. if so we save it */
	next_sd_until = whotab.until;
	shift = whotab.shift;			/* save shift info */
	next_sc = whotab.next_shift_change_time;
	last_sc = whotab.last_shift_change_time;
	call hcs_$truncate_seg (whoptr, 0, code);	/* Clear out all old junk. */

/* truncating whotab is too drastic. change it some time.
   NOTE: for MR10, a kludge was devised to allow expansion of the whotab
   header.  The header was 64 words long, user entries were 32 words.
   A number of the early user entries were appropriated, with the understanding
   the every 32 words from 100o up, there would be a word of 0s, corresponding
   to the user entry being empty.  This allows existing programs to run
   without recompilation, provided that they honour the entry 'active' flag.
   If truncation is eliminated, it must be ensured that this contract is kept.
   Throughout the Answering Service, the value whotab.as_laste is used to
   indicate the last used whotab index.  User programs use whotab.laste,
   which is the sum of whotab.as_laste and whotab.laste_adjust.
*/

	whotab.version = WHOTAB_VERSION_1;
	whotab.header_size = fixed (rel (addr (whotab.e (1))));
	whotab.entry_size = fixed (rel (addr (whotab.e (2)))) - fixed (rel (addr (whotab.e (1))));
	whotab.laste_adjust, whotab.laste =
	     divide (whotab.header_size - fixed (rel (addr (whotab.header_extension_mbz1))), whotab.entry_size, 17, 0);
	whotab.shift = shift;			/* put shift info back */
	whotab.next_shift_change_time = next_sc;
	whotab.last_shift_change_time = last_sc;
	whotab.n_rate_structures = installation_parms.nrates; /* number of R.S. at AS init */
	acla.mode (n_acl) = R_ACCESS;			/* whotab is public */
						/* Create_Segment resets this back to N_ACCESS */

	call hcs_$replace_acl (system_control_dir, "whotab", addr (acla), n_acl, "1"b, code);
	call hcs_$set_ring_brackets (system_control_dir, "whotab", rbkt, code);

/* now initialize various control variables */

	anstbl.header_version = ANSTBL_version_4;	/* setup version number of dcl */
	anstbl.entry_version = UTE_version_4;
	anstbl.user_table_type = PT_INTERACTIVE;
	anstbl.header_length = fixed (rel (addr (anstbl.entry (1))));
	anstbl.max_size = divide (sys_info$max_seg_size - anstbl.header_length, size (ute), 17, 0);
	anstbl.number_free,
	     anstbl.first_free,
	     anstbl.current_size,			/* Clear number of busy entries. */
	     anstbl.lock_count,			/* Clear update interlock. */
	     anstbl.nlin,				/* Reset number of lines attached. */
	     anstbl.n_units,			/* Clear load on system. */
	     anstbl.n_users = 0;			/* Clear number of users. */

	anstbl.update_pending = "1"b;			/* make sure to look in update directory */
/**** The following substring is necessary because anstbl.sysdir is only
      declared char (64). */
	anstbl.sysdir = substr (system_control_dir, 1, 64);
	anstbl.special_message = NL;			/* Nothing special in dialup buffer. */
	anstbl.message_lng = 0;			/* ... */
	anstbl.message_update_time = clock ();

	tcd_cardp = null ();
	call config_$find (TCD_CARD_WORD, tcd_cardp);
	if tcd_cardp = null ()
	then do;
	     call Log_Error (-1,
		"No ""tcd"" card in the config deck.  Assuming APT size of 1000.");
	     anstbl.max_users = 1000;
	end;
	else anstbl.max_users = tcd_card.no_apt;	/* avoid errors from hardcore when we reach APT limit */

	anstbl.max_units = sat.max_units;		/* ... */
	anstbl.n_sessions = anstbl.n_sessions + 1;	/* Number of boots. */
	anstbl.as_tty = sc_stat_$master_channel;	/* Copy in channel ID of initializer. */
	as_data_$as_procid, anstbl.as_procid = get_process_id_ (); /* Set up system process ID. */
	anstbl.processid_index = bin (substr (bit (bin (clock (), 52), 52), 9, 18), 18);
	anstbl.session_uid_counter = 0;		/* login attempts will increment */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* The following flag, zeroed at answering service initialization time, is   */
/* used by dial_ctl_ to determine whether to call uc_cleanup_network_dials_  */
/* or not.  The flag is turned on by ls_rq_server_wakeup_ when a login       */
/* server request comes in -- indicating that there is indeed at least one   */
/* login server and it is potentially necessary to clean up MNA dialed       */
/* connections.  The process_id and event_channel are cleared here since     */
/* they are used by ls_request_server_$init to determine if the	       */
/* ls_request_server_ mechanism is already on.			       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	anstbl.login_server_present = FALSE;
	anstbl.ls_request_server_process_id = ""b;
	anstbl.ls_request_server_event_channel = 0;

	if normal_flag then				/* Normal startup? */
	     anstbl.auto_maxu = 1;			/* Yes. Turn on config-dependent load setting. */
	else do;
	     anstbl.auto_maxu = 0;			/* Otherwise leave it off, since this is a special session */
	     call absentee_user_manager_$term_aum;	/* tell absentee not to start automatically */
	end;

	call cu_$level_set ((get_ring_ ()));		/* force validation level to current ring */

	whotab.sysid = active_all_rings_data$system_id;	/* Get supervisor version from system tape. */
	whotab.timeup = clock ();			/* Set bootload time. */
	whotab.mxunits = anstbl.max_units;		/* Publish maxunits. */
	whotab.mxusers = anstbl.max_users;		/* Also max users. */

/* Now let other Answering Service procedures initialize themselves */

	call turn_on_mc_;				/* turn on the message coordinator */
						/* NOTE: we must not use the CDT */

	call up_sysctl_$init;			/* Allow table updates. */

	if ^debug_flag then do;
	     call multiplexer_mgr_$system_init (code);	/* Initialize CDT and get FNPs started loading */
	     if code ^= 0 then
		call Abort (code, "Calling multiplexer_mgr_$system_init.");
	end;

	call dialup_$init;				/* Turn on interactive user manager. */

	call as_request_server_$init;

	call device_acct_$init;			/* Set up device accounting table. */

	if ^debug_flag then do;
	     call as_user_message_$priv_system_init (code); /* Start up message transmission system. */
	     if code ^= 0 then
		call Abort (code, "Calling as_user_message_$priv_system_init.");

	     call rcp_sys_$initialize (installation_parms.rcp_init_flags, code);
	     if code ^= 0 then
		call Abort (code, "Calling rcp_sys_$initialize.");

	     call hc_initlzr_auxl_init_$init;		/* MUST COME AFTER CALL TO rcp_sys_$initialize */
	end;

	call lg_ctl_$init (normal_flag);

	call load_ctl_$init;

	call asu_$init;

	call daemon_user_manager_$init;		/* must do before act_ctl_$init and after lg_ctl_$init */

	call absentee_user_manager_$abs_as_init;	/* clear autbl before act_ctl_$init and reassign_work_classes_ */

	call act_ctl_$init;

/**** This is, logically, a part of load_ctl_init, but it must be done after
      act_ctl_$init is called, which defines the shift. */

	call reassign_work_classes_ (code);		/* this is, logically, a part of load_ctl_init */
	if code ^= 0 then
	     call Abort (code, "Error while defining initial work classes.");

	if ^debug_flag then do;
	     call pdir_volume_manager_$init;

/**** Initialize copying of syserr log out of ring 0 */
	     call syserr_log_man_$as_copy_init ("perm_syserr_log", installation_parms.syserr_log_copy_threshold);
	end;

/**** If we are debugging the AS, use a special version of the PNT and
      MAIL_TABLE. */
	if debug_flag then do;
	     call pnt_manager_$test (system_control_dir);
	     call mail_table_priv_$test (system_control_dir);
	end;

	call Initialize_Login_Server_Message_Buffer ();

	call Log_Error (-1, "Multics ^a; Answering Service ^a",
	     whotab.sysid, as_data_$version);		/* Not really an */
						/* error.	       */

INIT_RETURN:
	if metering_enabled then
	     call as_meter_$exit (ASINIT_METER);
	a_code = 0;
	return;
%page;
/* ============================================================= */

go:
     entry (a_code);

          ansp = as_data_$ansp;
	code = 0;
	debug_flag = as_data_$debug_flag;
	cdtp = as_data_$cdtp;			/* get automatic storage back */
	metering_enabled = FALSE;
	abort_label = GO_RETURN;

	if sc_stat_$Go then				/* called already */
	     call Abort (error_table_$action_not_performed,
		"Cannot type go twice.");

	if ^sc_stat_$Multics then			/* multics not called yet */
	     call Abort (error_table_$action_not_performed,
		"Type multics first.");

	if ^debug_flag then
	     call condition_ ("any_other", ucs);	/* in case die during init */
	call as_meter_$enter (ASINIT_METER);

	if ^debug_flag then do;
	     call Check_CDT ();

	     call multiplexer_mgr_$system_go;		/* in case any FNPs came up before we said "go" */
	end;

	call load_ctl_$set_maxunits (anstbl.shift);	/* just returns if auto_maxu is zero */

/**** Should we set up an auto shudtown? */
	if next_sd > clock () + MINS_30 then do;	/* Should we set up an auto shudtown? */
	     call admin_$down1 (next_sd, next_sd_msg, next_sd_until);
	end;

	if anstbl.update_pending then do;		/* kick-off any installs */
	     whoptr = as_data_$whoptr;
	     call hcs_$wakeup (whotab.installation_request_pid, whotab.installation_request_channel, 0, (0));
	end;

GO_RETURN:
	if metering_enabled then
	     call as_meter_$exit (ASINIT_METER);
	a_code = 0;
	return;

%page;
/* ====================================================== */

check_shut_ok:
     entry (a_n_users);

	ansp = as_data_$ansp;
	if ansp = null then
	   a_n_users = 0;
	else
	   a_n_users = anstbl.n_users;
	return;
%page;
/* ====================================================== */

shutdown:
     entry ();					/* Small entry for shutting system down. */

	ansp = as_data_$ansp;
	whoptr = as_data_$whoptr;
	ip = as_data_$rs_ptrs (0);

	anstbl.session, whotab.session = "shutdown";	/* No more logins */
	whotab.nextsd = 0;				/* Prevent restoring */
	if installation_parms.syserr_log_copy_threshold ^= -1 then
						/* If automatic copying enabled... */
	     call syserr_log_man_$as_copy_log ();	/* ...then copy the last few messages out of ring 0 */

	call act_ctl_$act_ctl_close;			/* All engines stop */
	if ^as_data_$debug_flag then
	     call mc_quiesce_;			/* wait for messages to finish */
	call timer_manager_$sleep (2, "11"b);		/* and a bit more for good luck */

	if ^as_data_$debug_flag then
	     call multiplexer_mgr_$shut;		/* don't listen to them anymore */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* Although we didn't start up the ls_request_server_ during initialization, */
/* we will force it to stop running during AS shutdown.  It gets started by  */
/* the ls_request_server command.				       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	call ls_request_server_$shutdown (code);
	if code ^= 0 then
	     call Log_Error (code,
	     "Shutting down the login server request mechanism.");

	return;
%page;
Create_Segment:
     procedure (P_table_name, P_table_ptr);

dcl  P_table_name char (*) parameter;
dcl  P_table_ptr ptr parameter;

dcl  local_code fixed bin (35) automatic;

TRY_AGAIN:
	call initiate_file_ (system_control_dir, P_table_name, RW_ACCESS,
	     P_table_ptr, (0), local_code);
	if local_code = 0 then
	     return;
	else if local_code = error_table_$noentry then do;
	     call Log_Error (-1, "^a>^a missing.  Creating new one.",
		system_control_dir, P_table_name);
	     call hcs_$make_seg (system_control_dir, P_table_name, "",
		01010b, P_table_ptr, local_code);
	     if P_table_ptr = null () then
		call Abort (local_code, "Could not create ^a>^a.",
		     system_control_dir, P_table_name);
	     return;
	end;
	else if local_code ^= error_table_$no_r_permission &
	     local_code ^= error_table_$no_w_permission then
	     call Abort (local_code, "Could not initiate ^a>^a.",
		system_control_dir, P_table_name);
	else do;					/* no access */
	     call Log_Error (local_code, "^a>^a.  Forcing access.",
		system_control_dir, P_table_name);
	     acla.mode (n_acl) = N_ACCESS;		/* random user get null access */
	     call hcs_$replace_acl (system_control_dir, P_table_name,
		addr (acla), n_acl, "1"b, local_code);
	     if local_code ^= 0 then
		call Abort (local_code, "Could not force access on ^a>^a.",
		     system_control_dir, P_table_name);
	     else
		goto TRY_AGAIN;
	end;
	return;
     end Create_Segment;
%page;
ucs:
     proc (mcptr, cname, coptr, infoptr, contin);

dcl  mcptr ptr parameter;
dcl  cname char (*) parameter;
dcl  coptr ptr parameter;
dcl  infoptr ptr parameter;
dcl  contin bit (1) parameter;

dcl  cond_info char(cond_info_lng) based (cond_info_ptr);
dcl  cond_info_lng fixed bin;
dcl  cond_info_ptr ptr;

dcl  non_local_exit bit (1);

dcl  as_check_condition_ entry (char (*), bit (1), bit (1));
dcl  condition_interpreter_ entry (ptr, ptr, fixed bin, fixed bin, ptr, char(*), ptr, ptr);

dcl  cleanup condition;

dcl  LONG_MODE fixed bin init(3) int static options(constant);

	call as_check_condition_ (cname, contin, non_local_exit);
	if contin | non_local_exit then
	     return;

	code = error_table_$action_not_performed;

	ucs_recursion = ucs_recursion + 1;		/* recursion ok up to here */
	if ucs_recursion <= 1 then do;
	     if cname = "sub_error_" then do;
		sub_error_info_ptr = infoptr;
		if sub_error_info.default_restart & sub_error_info.quiet_restart then return;
		code = sub_error_info.status_code;
		call Log_Error (code,
		     "^[Initialization of ^a failed.^;^a signalled sub_error_; initialization continues.^]^[ ^a^]",
		     ^sub_error_info.default_restart, sub_error_info.name,
		     (length (sub_error_info.info_string) > 0), sub_error_info.info_string);
		if sub_error_info.default_restart then return;
	     end;
	     else do;
 		call Log_Error (-1,

		     "^a: Condition ^a signalled during startup.  Taking AS dump.", ME, cname);
	          system_area_ptr = get_system_free_area_();
		cond_info_ptr = null;
		on cleanup begin;
		     if cond_info_ptr ^= null then
			free cond_info in (system_area);
		end;
		call condition_interpreter_ (addr(system_area),
		     cond_info_ptr, cond_info_lng, LONG_MODE,
		     mcptr, cname, coptr, infoptr);
		if cond_info_ptr ^= null then do;
		     call Log_Error (-1, "^a", cond_info);
		     free cond_info in (system_area);
		end;
		call as_dump_$dont_use_mc ("as_init_: " || cname);
	     end;
	     call Abort (code, "");
	end;
	else do;
	     if ^debug_flag then
		error_message_entry = phcs_$ring_0_message;
	     else error_message_entry = ioa_;

	     call error_message_entry ("as_init_: Condition was signalled while processing another condition.  " || cname);
	     call error_message_entry ("as_init_: Answering Service initialization failed.");
	     call Abort (error_table_$unexpected_condition, "");
	end;

     end ucs;
%page;
Initialize_Login_Server_Message_Buffer:
     procedure ();

dcl  ls_message_buffer_max_lth fixed bin automatic;
dcl  ls_message_buffer_ptr  ptr automatic;

dcl  ls_message_buffer      char (ls_message_buffer_max_lth)
		        based (ls_message_buffer_ptr);

/**** Start out with a buffer 512 character-long buffer. */

          system_area_ptr = get_system_free_area_();
	ls_message_buffer_max_lth,
	     as_data_$ls_message_buffer_max_lth = 512;
	allocate ls_message_buffer in (system_area) set (ls_message_buffer_ptr);
	ls_message_buffer = "";			/* clear out buffer */
	as_data_$ls_message_buffer_cur_lth = 0;
	as_data_$ls_message_buffer_ptr = ls_message_buffer_ptr;
	return;
     end Initialize_Login_Server_Message_Buffer;
%page;
Initiate_Segment:
     procedure (P_table_name, P_table_ptr);

dcl  P_table_name char (*) parameter;
dcl  P_table_ptr ptr parameter;

	call initiate_file_ (system_control_dir, P_table_name, RW_ACCESS,
	     P_table_ptr, (0), code);
	if code ^= 0 then
	     call Abort (code, "Could not initiate ^a.",
		pathname_ (system_control_dir, P_table_name));
	return;
     end Initiate_Segment;
%page;
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* Abort:  Report errors via sys_log_$general, report that Answering	       */
/*	 Service initialization failed, then return to caller of as_init_  */
/*	 with nonzero error code.				       */
/*							       */
/* Syntax:  call Abort (code, ioa_ctl, args);			       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


Abort:
     procedure options (variable);

dcl  cu_$arg_list_ptr       entry returns (ptr);
dcl  sys_log_$general       entry (ptr);

	sl_info = sl_info_code_msg;
	sl_info.arg_list_ptr = cu_$arg_list_ptr ();
	sl_info.severity = SL_LOG;
	sl_info.caller = ME;
	call sys_log_$general (addr (sl_info));
	code = sl_info.code;
	if code ^= 0 then do;
	     call sys_log_ (SL_LOG_BEEP,
	        "^a: Answering Service initialization failed.", ME);
	     go to abort_label;
	end;

     end Abort;
%page;
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* Log_Error:  Report errors via sys_log_$general, continue initialization.  */
/*							       */
/* Syntax:  call Log_Error (code, ioa_ctl, args);			       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


Log_Error:
     procedure options (variable);

dcl  cu_$arg_list_ptr       entry returns (ptr);
dcl  sys_log_$general       entry (ptr);

	sl_info = sl_info_code_msg;
	sl_info.arg_list_ptr = cu_$arg_list_ptr ();
	sl_info.severity = SL_LOG;
	sl_info.caller = ME;
	call sys_log_$general (addr (sl_info));
	return;

     end Log_Error;
%page;
Check_CDT:
     procedure ();

/* Scan the CDT and find all non-MCS channels which should be attached to
   the Answering Service.  All such channels will be top level multiplexers
   other than FNP's */

	cdt_scan_try_count = 0;

RETRY_CDT_SCAN:
	check = 0;
	do x = cdt.threads.daughter repeat (cdt.cdt_entry (x).next_sister)
	     while (x ^= 0);
	     cdtep = addr (cdt.cdt_entry (x));
	     check = check + 1;
	     if check > cdt.threads.daughter_count | check > cdt.n_cdtes
		| cdte.threads.mother ^= 0
	     then goto CDT_DAMAGE;
	end;
	return;
%page;
CDT_DAMAGE:
	begin;					/* Inconsistency found while chasing cdt threads */

declare  sub_error_ condition;
declare  find_condition_info_ entry (ptr, ptr, fixed bin (35));
declare  1 auto_condition_info aligned like condition_info;

	     if cdt_scan_try_count > 0
	     then do;
		call multiplexer_mgr_$shut ();
		call Abort (error_table_$action_not_performed,
		     "Repeated CDT threading inconsistencies.");
	     end;

	     call Log_Error (-1,
		"CDT threading inconsistency found. Rethreading.");

	     on sub_error_ begin;
		call find_condition_info_ (null, addr (auto_condition_info), (0));
		sub_error_info_ptr = auto_condition_info.info_ptr;
		call Log_Error (sub_error_info.status_code,
		     "cdt_mgr_$thread: ^a", sub_error_info.info_string);
		if ^sub_error_info.default_restart
		then do;
		     call multiplexer_mgr_$shut;
		     call Abort (sub_error_info.status_code, "");
		end;
	     end;

	     call cdt_mgr_$thread (cdtp, (0));
	     call Log_Error (-1, "CDT rethreading complete.");
	     cdt_scan_try_count = 1;
	     goto RETRY_CDT_SCAN;
	end;
     end Check_CDT;

/* INCLUDE FILES, IN ALPHABETIC ORDER */

/* format: off */
%page; %include access_mode_values;
%page; %include acl_structures;
%page; %include answer_table;
%page; %include as_data_;
%page; %include as_meter_numbers;
%page; %include author_dcl;
%page; %include cdt;
%page; %include condition_info;
%include condition_info_header; 
%page; %include config_tcd_card;
%page; %include dialup_values;
%page; %include hashst;
dcl  htp ptr init (null);			/* needed by hashst */
%page; %include installation_parms;
%page; %include rtdt;
%page; %include sat;

dcl  satep ptr automatic init (null);			/* sat incl requires dcl of this pointer. */
%page; %include sc_stat_;
%page; %include sub_error_info;
%page; %include sys_log_constants;
%page; %include user_attributes;
%page; %include user_table_entry;
%page; %include user_table_header;
%page; %include whotab;
 

/* BEGIN MESSAGE DOCUMENTATION

   Message:
   as_init_: The requested action was not performed. Multics already initialized.

   S:	$as1

   T:	$init

   M:	The operator typed startup, multics, or go when Multics was already
   in operation.  No action was taken.

   A:	$ignore


   Message:
   as_init_: The requested action was not performed.  Cannot type go twice.

   S:	$as1

   T:	$init

   M:	The operator typed go when Multics was already in
   operation.  No action was taken.

   A:	$ignore


   Message:
   as_init_: ERROR_MESSAGE.  Cannot create pit_temp_

   S:	$as1

   T:	$init

   M:	The system could not create a temporary segment in the
   Answering Service process's process directory.  This is a fatal error
   that will cause answering service startup to fail.

   A:	$contact_sa


   Message:
   as_init_: Resource management is disabled; >sc1>rtdt needs it enabled.

   S:	$as1

   T:	$init

   M:	The copy of installation_parms encountered by system startup
   claims that RCP resource management is disabled.  This disagrees with
   information in the RTDT.  If startup were to continue, all information in
   resource registries would be lost.  Answering Service initialization fails.
   The system administrator must use ed_installation_parms from admin mode to
   repair the damage.  Then reboot the system.

   A:	$contact_sa


   Message:
   as_init_: SYSTEM_CONTROL_DIR>TABLE missing.  Creating new one.

   S:	$as1

   T:	$init

   M:	A new version of TABLE was created in SYSTEM_CONTROL_DIR as
   part of system initialization.

   A:	$ignore


   Message:
   as_init_: ERROR_MESSAGE.  SYSTEM_CONTROL_DIR>TABLE.  Forcing access.

   S:	$as1

   T:	$init

   M:	During system initialization, TABLE in SYSTEM_CONTROL_DIR was 
   found to have an incorrect ACL.  Access was set for Initializer.SysDaemon.

   A:	$ignore

        
   Message:
   as_init_: ERROR_MESSAGE.  Could not create SYSTEM_CONTROL_DIR>TABLE.

   S:	$as1

   T:	$init

   M:	The Initializer could not create a new segment TABLE in 
   SYSTEM_CONTROL_DIR.  Answering service initialization fails.
   The system administrator must enter admin mode, and type "create TABLE",
   where TABLE is the name given above.  Then reboot the system.

   A:	$contact_sa


   Message:
   as_init_: ERROR_MESSAGE.  Could not initiate SYSTEM_CONTROL_DIR>TABLE.

   S:	$as1

   T:	$init

   M:	The Initializer could not initiate the TABLE segment in 
   SYSTEM_CONTROL_DIR.  Answering service initialization fails.
   The system administrator must enter admin mode, and correct the problem.
   Then reboot the system.

   A:	$contact_sa


   Message:
   as_init_: ERROR_MESSAGE.  Could not force access on SYSTEM_CONTROL_DIR>TABLE.

   S:	$as1

   T:	$init

   M:	The Initializer could not change the ACL on the TABLE segment in 
   SYSTEM_CONTROL_DIR.  Answering service initialization fails.
   The system administrator must enter admin mode, and correct the problem.
   Then reboot the system.

   A:	$contact_sa


      Message:
   as_init_: ERROR_MESSAGE.  Could not set RW access on SYSTEM_CONTROL_DIR>TABLE.

   S:	$as1

   T:	$init

   M:	An error occurred attempting to add ACL entries to TABLE in 
   SYSTEM_CONTROL_DIR.  Answering Service initialization fails.  The
   system administrator must enter admin mode and correct the problem.
   Then reboot the system.

   A:	$contact_sa


   Message:
   as_init_: Multics SYSID; Answering Service VERSION

   S:	$as1

   T:	$init

   M:	Answering Service initialization is complete and users
   may now log in.  The current system version number, from the
   system tape, is SYSID.  The current Answering Service version number
   is VERSION.

   A:	Proceed with startup.


   Message:
   as_init_: ERROR_MESSAGE.  Initialization of MODULE failed.  {ADDED_INFO.}

   S:	$as1

   T:	$init

   M:	MODULE was being initialized when it detected a problem.  It
   called sub_err_ to report the error to as_init_.  ERROR_MESSAGE gives the 
   text associated with the error code MODULE returned to as_init_.  
   If present, ADDED_INFO gives further details about the problem.  Some steps
   of Answering Service initialization were not performed.  This may cause
   the system to operate incorrectly.

   A:	$contact


   Message:
   as_init_: ERROR_MESSAGE.  MODULE signalled sub_error_; 
   initialization continues.  {ADDED_INFO.}

   S:	$as1

   T:	$init

   M:	MODULE was being initialized when it detected a problem.  It
   called sub_err_ to report the error to as_init_.  ERROR_MESSAGE gives the 
   text associated with the error code MODULE returned to as_init_.  
   If present, ADDED_INFO gives further details about the problem.  
   Initialization of the module continues.

   A:	$contact.  


   Message:
   as_init_: Condition COND signalled during startup.  Taking AS dump. 
   CONDITION_INFO

   S.	$as1

   T:	$init

   M:	An unexpected condition COND occurred during system initialization.
   An answering service dump is taken.  The stack trace information in this
   dump further describes the error.    Some steps of Answering Service
   initialization were not performed.  This may cause the system to operate
   incorrectly.  CONDITION_INFO if optionally present if further information
   about the condition is available.

   A:	$contact


   Message:
   as_init_: The requested action was not performed.  Type multics first.

   S:	$as1

   T:	$init

   M:	The operator typed go without typing multics.  No
   action was taken.

   A:	Type multics first, or startup.


   Message:
   as_init_: ERROR_MESSAGE.  Error while defining initial work classes.

   S:	$as1

   T:	$init

   M:	$err
   Answering Service initialization fails.  The system administrator
   must enter admin mode and correct the problem.  Then reboot the system.

   A:	$contact_sa


   Message:
   as_init_: ERROR_MESSAGE.

   S:	$as1

   T:	$init

   M:	A fatal error occurred during Answering Service initialization.
   Previous messages describe the error in more detail.

   A:	$contact_sa


   Message:
   as_init_: Answering Service initialization failed.

   S:	$as2

   T:	$init

   M:	$err
   Answering Service initialization failed.  Normally, this message is
   preceded by a more specific indication of the reason for failure.

   A:	$contact
   Attempt to correct the problem and try startup again.


   Message:
   as_init_: This procedure does not implement the requested version.
   installation_parms version N.

   S:	$as1

   T:	$init

   M:	$err
   The installation_parms segment has been damaged or is not up-to-date.
   The system administrator must rectify the problem using 
   ed_installation_parms from admin mode, before the Answering Service
   will initialize.  It will be necessary to re-boot Multics to retry 
   Answering Serviceinitialization.

   A:	$contact_sa


   Message:
   as_init_: installation_parms damaged.  N rate structures defined;
   from I to J allowed.

   S:	$as1

   T:	$init

   M:	The installation_parms table claims to declare an unallowed number
   of rate structures.  This indicates that the table has been damaged.
   The system administrator must rectify the problem using 
   ed_installation_parms from admin mode, before the Answering Service
   will initialize.  It will be necessary to re-boot Multics to retry 
   Answering Service initialization.

   A:	$contact_sa


   Message:
   as_init_: Condition was signalled while processing another condition. CONDITION

   S:	$beep

   T:	$init

   M:	$err
   During Answering Service initialization, a CONDITION was raised while
   as_init_ was already processing some condition.  It may be that the error
   occured while making an as_dump for the first condition.  as_init_ will not
   attempt to make an as_dump, but will instead abort the initialization.

   A:	$contact


   Message:
   as_init_: SAT version inconsistent with declarations used in this program.

   S:	$as1

   T:	$init

   M:	The version number stored in the SAT does not match the
   expected version number, which is a constant in the Answering Service
   programs.  This may be because the SAT has been destroyed, or because
   an incorrect version of the Answering Service programs is being used.
   $crashes

   A:	$contact_sa
   The System Administrator must either generate a new SAT, or install the
   correct version of the Answering Service.  If the System Administrator is
   not available, enter admin mode and attempt to retrieve a
   recent copy of the SAT.  Then exit from admin mode and try startup
   again.


   Message:
   as_init_: rebuilding SAT hash table.

   S:	$as1

   T:	$init

   M:	The hash table for the SAT was corrupted. The hash table is
   regenerated.

   A:	$ignore


   Message:
   as_init_: ERROR_MESSAGE.  Cannot create sat.ht. REASON

   S:	$as1

   T:	$init

   M:	This message indicates that the sat is damaged or that a storage
   system error prevented the creation of a new hash table for the sat.
   Answering Service startup will fail.

   A:	$contact_sa


   Message:
   as_init_: No "tcd" card in the config deck. Assuming APT size of 1000.

   S:	$as1

   T:	$init

   M:	This message indicates that there is no TCD card in the config deck.
   The system will operate normally, but it is recommended that an explicit
   TCD card be added at the first convenience.

   A:	$contact_sa


   Message:
   as_init_: CDT threading inconsistency found.  Rethreading.

   S:	$as1

   T:	$init

   M:	An error was detected while tracing the threading of Channel 
   Definition Table (CDT) entries into a hierarchy of multiplexer and
   subchannel entries. $err  The entire channel hierarchy will be rethreaded.

   A:	$notify_sa


   Message:
   as_init_: CDT rethreading complete.

   S:	$as1

   T:	$init

   M:	Rethreading of Channel Definition Table (CDT) entries into a
   multiplexer/subchannel hierarchy completed successfully.  System 
   initialization continues.

   A:	$notify_sa


   Message:
   as_init_: ERROR_MESSAGE.  cdt_mgr_$thread: ADDED_INFO

   S:	$as1

   T:	$init

   M:	as_init_ called cdt_mgr_$thread to rethread the Channel Definition
   Table (CDT) entries into a multiplexer/subchannel hierarchy.  cdt_mgr_ 
   encountered an unexpected error.  ERROR_MESSAGE is the text associated with 
   the error code returned by cdt_mgr_.  ADDED_INFO further describes the 
   error and whether or not further rethreading is attempted.

   A:	$notify_sa


   Message:
   as_init_: ERROR_MESSAGE.  Repeated CDT threading inconsistencies.

   S:	$as1

   T:	$init

   M:	Channel Definition Table (CDT) entry threads were found to be
   damaged even after rethreading completed successfully.  $err

   A:	$contact_sa


   Message:
   as_init_: ERROR_MESSAGE.  Could not set priority for IPC wait channels.

   S:	$as1

   T:	$init

   M:	A call to ipc_$set_wait_prior failed.  $err

   A:	$notify_sa


   Message:
   as_init_: ERROR_MESSAGE.  Calling multiplexer_mgr_$ENTRYPOINT.

   S:	$as1

   T:	$init

   M:	The multiplexer_mgr_ failed when accessing the Channel Definition
   Table (CDT) in >sc1, initializing the CDT or loading the FNPs.
   ERROR_MESSAGE is the text associated with the error code returned by
   multiplexer_mgr_.  Answering service initialization fails.  The system
   administrator must enter admin mode and correct the problem.  Then reboot
   the system.

   A:	$contact_sa


   Message:
   as_init_: ERROR_MESSAGE.  Calling ROUTINE.

   S:	$as1

   T:	$init

   M:	An error occurred when calling ROUTINE during Answering Service
   initialization.  ERROR_MESSAGE is the text associated with the error code 
   returned by ROUTINE.  Answering service initialization fails.  The system
   administrator must enter admin mode and correct the problem.  Then reboot
   the system.

   A:	$contact_sa


   Message:
   as_init_: ERROR_MESSAGE.  Shutting down the login server request mechanism.

   S:	$as1

   T:	$shut

   M:	An error occurred while shutting down the login server request 
   mechanism.  The ERROR_MESSAGE gives the text associated with the error
   code returned from ls_request_server_$shutdown.

   A:	$ignore


   END MESSAGE DOCUMENTATION */

     end as_init_;
