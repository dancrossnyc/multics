/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1987 *
        *                                                         *
        *********************************************************** */

/****^  HISTORY COMMENTS:
  1) change(85-05-01,Coren), approve(87-07-08,MCR7681), audit(87-03-26,GDixon),
     install(87-08-04,MR12.1-1055):
     Initial coding.
  2) change(87-03-07,GDixon), approve(87-07-08,MCR7681),
     audit(87-07-22,Hartogs), install(87-08-04,MR12.1-1055):
      A) Correct coding standard violations.
      B) Correct cleanup strategy.
      C) Correct storing of service type in active_connection.service_type.
      D) Thread entry back to owner when $priv_remove_user is called to
         remove the connection from the user.
      E) Remove $delete_name and $delete_offset entrypoints, which aren't
         called by any gate and don't fit into the gate strategy.
      F) Change $init to ignore all but the first call during a given
         bootload.
      G) Remove references to connection_manager_data_.
      H) Add force_accounting_flush_entry parameter to $add entrypoint.  Return
         this entry in the active_connection_info structure.
  3) change(87-04-28,Brunelle), approve(87-07-08,MCR7681),
     audit(87-07-22,Hartogs), install(87-08-04,MR12.1-1055):
     Corrected Thread_user to correctly thread next_act_ptr entry back to this
     entry.
  4) change(87-05-06,GDixon), approve(87-07-08,MCR7681),
     audit(87-07-22,Hartogs), install(87-08-04,MR12.1-1055):
      A) Map error_table_$lock_wait_time_exceeded into
         error_table_$already_initialized.
      B) Use sys_info$system_control_dir to locate active_connection_list.
  5) change(87-05-13,Brunelle), approve(87-07-08,MCR7681),
     audit(87-07-22,Hartogs), install(87-08-04,MR12.1-1055):
     Add .owner_group_id field to structure and change code to use it.  Added
     check for the connection list not being initialized yet.  Pass back new
  6) change(87-06-22,GDixon), approve(87-07-08,MCR7681),
     audit(87-07-22,Hartogs), install(87-08-04,MR12.1-1055):
      A) Add back the delete_offset entrypoint.
  7) change(87-07-21,GDixon), approve(87-07-21,MCR7681),
     audit(87-07-22,Hartogs), install(87-08-04,MR12.1-1055):
      A) Sort parameter declarations.
      B) Correct comments.
                                                   END HISTORY COMMENTS */

/* format: style4,delnl,insnl,^ifthendo */

connection_list_manager_:
     procedure ();
	return;					/* main entry is never called */

/* This procedure contains a collection of entry points for managing the
   system-wide list of active network connections.  This list is used, for
   example, by the Answering Service when a user process terminates in order
   to clean up any connections that were assigned to the process.

   There is an entry for each established connection.  Each one has
   associated with it an "owner" process (frequently a login server) and a
   "user" process.

   The table is maintained in ring 1, since it is potentially accessible by
   all processes.

   Entries in this procedure are called through one of three gates:

   connection_list_:       process must be owner and user of connection
   priv_connection_list_:  process must be owner, but need not be user
   hpriv_connection_list_: process may manipulate connections of which it is
   neither owner nor user

   Further, some of the entries may be called by inner-ring network-management
   programs.
*/

/* NOTE: Someday there should be some code added to check that the list is
   consistent, and take some appropriate action if it isn't. */

/* DECLARATIONS */

/* PARAMETERS */

dcl  a_code fixed bin (35) parameter;
dcl  a_connection_handle fixed bin (35) parameter;
dcl  a_connection_info_ptr pointer parameter;
dcl  a_connection_name char (*) parameter;
dcl  a_force_accounting char (*) parameter;
dcl  a_force_disconnect char (*) parameter;
dcl  a_handle bit (72) aligned parameter;
dcl  a_offset bit (18) parameter;
dcl  a_owner_process_id bit (36) parameter;
dcl  a_service_type char (*) parameter;
dcl  a_terminate_event_channel fixed bin (71) parameter;
dcl  a_usage_type fixed bin parameter;
dcl  a_user_group_id char (*) parameter;
dcl  a_user_process_id bit (36) parameter;


/* AUTOMATIC */

dcl  act_dir_name char (168);
dcl  code fixed bin (35);
dcl  connection_handle fixed bin (35);
dcl  connection_name char (32);
dcl  force_acct_entry char (64);
dcl  force_disc_entry char (64);
dcl  hash_index fixed bin;
dcl  hash_size fixed bin;
dcl  hpriv_entry bit (1);
dcl  initializer_handle bit (72) aligned;
dcl  locked bit (1);
dcl  my_process_id bit (36);
dcl  name_entry bit (1);
dcl  next_act_ptr pointer;
dcl  next_offset bit (18);
dcl  offset bit (18);
dcl  orig_level fixed bin;
dcl  owner_process_id bit (36);
dcl  priv_entry bit (1);
dcl  service_type char (32);
dcl  sys_high_auth bit (72) aligned;
dcl  temp_lock_word bit (36) aligned;
dcl  term_event_channel fixed bin (71);
dcl  this_act_ptr pointer;
dcl  this_ring fixed bin;
dcl  usage_type fixed bin;
dcl  user_group_id char (32);
dcl  user_process_id bit (36);
dcl  words_used fixed bin;


/* AUTOMATIC STRUCTURES */

dcl  1 auto_area_info aligned like area_info;
dcl  1 auto_create_branch_info aligned like create_branch_info;


/* ENTRIES */

dcl  convert_authorization_$from_string entry (bit (72) aligned, char (*), fixed bin (35));
dcl  cu_$level_get entry (fixed bin);
dcl  cu_$level_set entry (fixed bin);
dcl  define_area_ entry (ptr, fixed bin (35));
dcl  get_group_id_ entry () returns (char (32));
dcl  get_process_id_ entry () returns (bit (36));
dcl  get_ring_ entry () returns (fixed bin (3));
dcl  hash_index_ entry (pointer, fixed bin (21), fixed bin, fixed bin) returns (fixed bin);
dcl  hcs_$create_branch_ entry (char (*), char (*), ptr, fixed bin (35));
dcl  initiate_file_ entry (char (*), char (*), bit (*), ptr, fixed bin (24), fixed bin (35));
dcl  set_lock_$lock entry (bit (36) aligned, fixed bin, fixed bin (35));
dcl  set_lock_$unlock entry (bit (36) aligned, fixed bin (35));
dcl  terminate_file_ entry (ptr, fixed bin (24), bit (*), fixed bin (35));


/* EXTERNAL STATIC */

dcl  (
     error_table_$already_initialized,
     error_table_$invalid_lock_reset,
     error_table_$lock_wait_time_exceeded,
     error_table_$locked_by_other_process,
     error_table_$locked_by_this_process,
     error_table_$namedup,
     error_table_$noentry,
     error_table_$not_initialized,
     error_table_$not_privileged,
     error_table_$unimplemented_version
     ) fixed bin (35) external static;

dcl  sys_info$max_seg_size fixed bin (18) external static;
dcl  sys_info$system_control_dir char (168) varying external static;


/* INTERNAL STATIC */

dcl  ACT_SEG_NAME char (32) internal static options (constant) init ("active_connection_list");
dcl  LOCK_WAIT_TIME fixed bin internal static options (constant) init (10);
dcl  static_connection_list_ptr pointer internal static init (null ());


/* BUILTINS AND CONDITIONS */

dcl  (addr, currentsize, length, mod, null, ptr, rel, string, unspec) builtin;
dcl  cleanup condition;


/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* add: entry to add a connection -- the caller is made both user and owner  */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

add:
     entry (a_connection_name, a_connection_handle, a_service_type, a_force_disconnect, a_force_accounting, a_usage_type,
	a_offset, a_code);

	active_connection_list_ptr = null;
	on cleanup call Unlock ();
	call Setup ();

	usage_type = a_usage_type;
	force_disc_entry = a_force_disconnect;
	force_acct_entry = a_force_accounting;
	connection_name = a_connection_name;
	connection_handle = a_connection_handle;
	service_type = a_service_type;

/* make sure we don't have one by this name already */

	call Find (connection_name, hash_index, offset, code);
	if code ^= 0
	then go to EXIT;				/* failure to find isn't an error */

	if offset ^= ""b
	then do;					/* in fact, in this case... */
	     code = error_table_$namedup;
	     go to EXIT;
	end;

/* now make a new entry */

	allocate active_connection in (active_connection_list.connection_area) set (act_ptr);

	unspec (active_connection) = ""b;		/* start clean */

	active_connection.version = ACT_VERSION_1;
	active_connection.connection_name = connection_name;
	active_connection.service_type = service_type;
	active_connection.owner_process_id, active_connection.user_process_id = get_process_id_ ();
	active_connection.owner_group_id, active_connection.user_group_id = get_group_id_ ();
	active_connection.force_disconnect_entry = force_disc_entry;
	active_connection.force_accounting_flush_entry = force_acct_entry;
	active_connection.connection_handle = connection_handle;
	active_connection.usage_type = usage_type;

	call Thread ();				/* threads to full list, hash list, and owner chain */

	call Thread_user ();

	a_offset = rel (act_ptr);

EXIT:
	if locked
	then call Unlock ();
	a_code = code;
	return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* (priv hpriv)_delete_(name offset), delete_offset:		       */
/* The following group of entry points are used to delete a connection from  */
/* the list.  This call may be privileged, or highly privileged; and the     */
/* connection may be identified by either its name or its offset in the list */
/* segment.						       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

priv_delete_name:
     entry (a_connection_name, a_code);

	priv_entry = "1"b;
	hpriv_entry = "0"b;
	name_entry = "1"b;
	go to DELETE_JOIN;


priv_delete_offset:
     entry (a_offset, a_code);

	priv_entry = "1"b;
	hpriv_entry = "0"b;
	name_entry = "0"b;
	go to DELETE_JOIN;

delete_offset:
     entry (a_offset, a_code);

	priv_entry = "0"b;
	hpriv_entry = "0"b;
	name_entry = "0"b;
	go to DELETE_JOIN;

hpriv_delete_name:
     entry (a_connection_name, a_code);

	priv_entry = "0"b;
	hpriv_entry = "1"b;
	name_entry = "1"b;
	go to DELETE_JOIN;


hpriv_delete_offset:
     entry (a_offset, a_code);

	priv_entry = "0"b;
	hpriv_entry = "1"b;
	name_entry = "0"b;

DELETE_JOIN:
	active_connection_list_ptr = null;
	on cleanup call Unlock ();
	call Setup ();

	my_process_id = get_process_id_ ();

	if name_entry
	then do;					/* given the name, must find it */
	     connection_name = a_connection_name;
	     call Find (connection_name, hash_index, offset, code);
	     if code ^= 0
	     then go to EXIT;
	     if offset = ""b
	     then do;
		code = error_table_$noentry;
		go to EXIT;
	     end;
	end;

	else offset = a_offset;

	act_ptr = ptr (active_connection_list_ptr, offset);

	call Delete_one_entry ();			/* do it */
	go to EXIT;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* XXX_delete_all_for_user:					       */
/* These two entry points delete all the connections of which a given	       */
/* process is the user; they may be invoked when the process in question     */
/* terminates.  The hpriv entry is called by a process other than the owner, */
/* in the event that the owner has also terminated or is otherwise	       */
/* unavailable.						       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

priv_delete_all_for_user:
     entry (a_user_process_id, a_code);

	priv_entry = "1"b;
	hpriv_entry = "0"b;
	go to DELETE_ALL_JOIN;


hpriv_delete_all_for_user:
     entry (a_user_process_id, a_code);

	priv_entry = "0"b;
	hpriv_entry = "1"b;

DELETE_ALL_JOIN:
	active_connection_list_ptr = null;
	on cleanup call Unlock ();
	call Setup ();

	user_process_id = a_user_process_id;

	next_act_ptr = Get_next_for_user (null (), user_process_id);
						/* get first one */

	do while (next_act_ptr ^= null ());
	     this_act_ptr = next_act_ptr;
	     next_act_ptr = Get_next_for_user (this_act_ptr, user_process_id);
						/* have to get next one before we delete this one */

	     act_ptr = this_act_ptr;			/* this little maneuver is required because */
						/*   Get_next_for_owner plays with act_ptr. */
	     call Delete_one_entry ();		/* to do the real work */
	end;

/* if Get_next_for_user returns null, there are no more */

	go to EXIT;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* priv_change_user:  this entry is called by the owner of a connection to   */
/* assign it to a user process.				       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

priv_change_user:
     entry (a_offset, a_user_process_id, a_user_group_id, a_usage_type, a_terminate_event_channel, a_handle, a_code);

	active_connection_list_ptr = null;
	on cleanup call Unlock ();
	call Setup ();

	offset = a_offset;
	user_process_id = a_user_process_id;
	user_group_id = a_user_group_id;
	usage_type = a_usage_type;
	term_event_channel = a_terminate_event_channel;
	initializer_handle = a_handle;
	my_process_id = get_process_id_ ();

	act_ptr = ptr (active_connection_list_ptr, offset);
	if active_connection.version ^= ACT_VERSION_1
	then do;					/* not really an entry */
	     code = error_table_$noentry;
	     go to EXIT;
	end;

	if active_connection.owner_process_id ^= my_process_id
	then do;
	     code = error_table_$not_privileged;	/* not one we control */
	     go to EXIT;
	end;

	if active_connection.user_process_id ^= user_process_id
						/* see if it already belongs to this user */
	then do;
	     if active_connection.user_process_id ^= ""b	/* does it belong to anyone? */
	     then call Unthread_user ();		/* yes, unthread it from them */

	     active_connection.user_process_id = user_process_id;
	     call Thread_user ();
	end;

	active_connection.user_group_id = user_group_id;
	active_connection.owner_terminate_event_channel = term_event_channel;
	active_connection.owner_initializer_id = initializer_handle;
	active_connection.usage_type = usage_type;
	active_connection.delegated = "1"b;

	go to EXIT;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* priv_remove_user:  this entry is called by the owner of a connection to   */
/* take it away from a user process without assigning it to a new one.       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

priv_remove_user:
     entry (a_offset, a_user_process_id, a_code);

	active_connection_list_ptr = null;
	on cleanup call Unlock ();
	call Setup ();

	offset = a_offset;
	user_process_id = a_user_process_id;
	my_process_id = get_process_id_ ();

	act_ptr = ptr (active_connection_list_ptr, offset);
	if active_connection.version ^= ACT_VERSION_1
	then do;					/* not really an entry */
	     code = error_table_$noentry;
	     go to EXIT;
	end;

	if active_connection.owner_process_id ^= my_process_id
	then do;
	     code = error_table_$not_privileged;	/* not one we control */
	     go to EXIT;
	end;
	if active_connection.user_process_id ^= user_process_id
						/* doesn't belong to who we thought it did */
	then do;
	     code = error_table_$noentry;
	     go to EXIT;
	end;

	call Unthread_user ();

	active_connection.user_process_id = active_connection.owner_process_id;
	active_connection.user_group_id = active_connection.owner_group_id;
	active_connection.delegated = ""b;

	call Thread_user ();

	go to EXIT;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* hpriv_get_next: This entry gets the next connection after the specified   */
/* one (or the first one if the offset given is ""b).  It is used at	       */
/* login_server initialization in order to find orphaned connections.	       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

hpriv_get_next:
     entry (a_offset, a_connection_info_ptr, a_code);

	active_connection_list_ptr = null;
	on cleanup call Unlock ();
	call Setup ();

	offset = a_offset;
	active_connection_info_ptr = a_connection_info_ptr;
	priv_entry = "0"b;
	hpriv_entry = "1"b;

	if offset = ""b
	then next_offset = active_connection_list.first_connection_offset;

	else do;
	     act_ptr = ptr (active_connection_list_ptr, offset);
	     next_offset = active_connection.next_connection;
	end;

	if next_offset = ""b
	then code = error_table_$noentry;

	else do;
	     act_ptr = ptr (active_connection_list_ptr, next_offset);
	     call Fill_info ();
	end;

	go to EXIT;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* XXX_get_name:						       */
/* These two entry points return information for the connection with the     */
/* specified name.						       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

priv_get_name:
     entry (a_connection_name, a_connection_info_ptr, a_code);

	priv_entry = "1"b;
	hpriv_entry = "0"b;
	go to GET_NAME_JOIN;


hpriv_get_name:
     entry (a_connection_name, a_connection_info_ptr, a_code);

	priv_entry = "0"b;
	hpriv_entry = "1"b;

GET_NAME_JOIN:
	active_connection_list_ptr = null;
	on cleanup call Unlock ();
	call Setup ();

	connection_name = a_connection_name;
	active_connection_info_ptr = a_connection_info_ptr;

	call Find (connection_name, hash_index, offset, code);
	if code ^= 0
	then go to EXIT;
	if offset = ""b
	then do;
	     code = error_table_$noentry;
	     go to EXIT;
	end;

	act_ptr = ptr (active_connection_list_ptr, offset);
	call Fill_info ();
	go to EXIT;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* XXX_get_next_user:					       */
/* The following entries return information about the next connection after  */
/* the one with the specified offset with the same user, or the first for    */
/* the given user if the offset is "0"b.			       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

priv_get_next_user:
     entry (a_user_process_id, a_offset, a_connection_info_ptr, a_code);

	priv_entry = "1"b;
	hpriv_entry = "0"b;
	go to GET_NEXT_USER_JOIN;


hpriv_get_next_user:
     entry (a_user_process_id, a_offset, a_connection_info_ptr, a_code);

	priv_entry = "0"b;
	hpriv_entry = "1"b;

GET_NEXT_USER_JOIN:
	active_connection_list_ptr = null;
	on cleanup call Unlock ();
	call Setup ();

	user_process_id = a_user_process_id;
	offset = a_offset;
	active_connection_info_ptr = a_connection_info_ptr;

	if offset = ""b
	then act_ptr = null ();
	else act_ptr = ptr (active_connection_list_ptr, offset);

	act_ptr = Get_next_for_user (act_ptr, user_process_id);
	if act_ptr ^= null ()
	then call Fill_info ();
	else code = error_table_$noentry;

	go to EXIT;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* XXX_get_next_owner:					       */
/* The following entries return information about the next connection for    */
/* which the calling process is the owner (or the first such if offset is    */
/* "0"b).							       */
/*							       */
/* The highly privileged entrypoint returns information about a specified    */
/* owner.							       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

priv_get_next_owner:
     entry (a_offset, a_connection_info_ptr, a_code);

	priv_entry = "1"b;
	hpriv_entry = "0"b;
	owner_process_id = get_process_id_ ();

	go to GET_NEXT_OWNER_JOIN;


hpriv_get_next_owner:
     entry (a_offset, a_owner_process_id, a_connection_info_ptr, a_code);

	priv_entry = "0"b;
	hpriv_entry = "1"b;
	owner_process_id = a_owner_process_id;

GET_NEXT_OWNER_JOIN:
	active_connection_list_ptr = null;
	on cleanup call Unlock ();
	call Setup ();

	offset = a_offset;
	active_connection_info_ptr = a_connection_info_ptr;

	if offset = ""b
	then act_ptr = null ();
	else do;
	     act_ptr = ptr (active_connection_list_ptr, offset);
	     if active_connection.owner_process_id ^= owner_process_id
						/* this isn't the right process to begin with */
	     then do;
		if hpriv_entry
		then code = error_table_$noentry;
		else code = error_table_$not_privileged;
		go to EXIT;
	     end;
	end;

	act_ptr = Get_next_for_owner (act_ptr, owner_process_id);

	if act_ptr ^= null ()
	then call Fill_info ();
	else code = error_table_$noentry;
	go to EXIT;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* init:							       */
/* This entry is called during system start up to create and initialize the  */
/* segment that contains the active connection table. The directory in which */
/* to create it is obtained from >sc1.  hash table size is a named constant  */
/* from the include file.					       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

init:
     entry (a_code);

	act_dir_name = sys_info$system_control_dir;
	hash_size = ACT_HASH_TABLE_SIZE;

	this_ring = get_ring_ ();
	call cu_$level_get (orig_level);

	on cleanup call cu_$level_set (orig_level);

	call cu_$level_set (this_ring);		/* need lower-ring validation level for initiation or creation */

	call initiate_file_ (act_dir_name, ACT_SEG_NAME, RW_ACCESS, active_connection_list_ptr, (0), code);

	if code = error_table_$noentry
	then do;					/* doesn't exist, we'll have to create it */

	     auto_create_branch_info.version = create_branch_version_2;
	     string (auto_create_branch_info.switches) = ""b;
	     auto_create_branch_info.mode = RW_ACCESS;
	     auto_create_branch_info.rings (*) = this_ring;
	     auto_create_branch_info.userid = "*.*.*";
	     auto_create_branch_info.bitcnt = 0;
	     auto_create_branch_info.quota = 0;

/* For debugging purposes, we will create the segment (in the user ring) at
   system low, but in real life it should be system_high.
*/
	     call convert_authorization_$from_string (sys_high_auth, "system_low" /* "system_high" */, code);
	     if code ^= 0
	     then go to INIT_EXIT;
	     auto_create_branch_info.access_class = sys_high_auth;
						/* make it multi-class */
	     auto_create_branch_info.dir_quota = 0;

	     call hcs_$create_branch_ (act_dir_name, ACT_SEG_NAME, addr (auto_create_branch_info), code);

	     if code = 0
	     then call initiate_file_ (act_dir_name, ACT_SEG_NAME, RW_ACCESS, active_connection_list_ptr, (0), code);
	end;

	call cu_$level_set (orig_level);		/* so's we don't forget */

	if code = 0
	then do;
	     call set_lock_$lock (active_connection_list.initializer_of_list, 0, code);
	     if code = error_table_$invalid_lock_reset
	     then code = 0;
	     else if code = error_table_$locked_by_other_process | code = error_table_$locked_by_this_process
		| code = error_table_$lock_wait_time_exceeded
	     then code = error_table_$already_initialized;
	end;

	if code = 0
	then do;					/* created or otherwise, we have it now */

/* initialize the contents */

	     active_connection_list.version = ACTL_VERSION_1;
	     active_connection_list.lock = ""b;
	     active_connection_list.no_of_connections = 0;
	     active_connection_list.first_connection_offset, active_connection_list.last_connection_offset = ""b;
	     active_connection_list.hash_table.size, actl_hash_table_size = hash_size;
	     active_connection_list.hash_table.entries (*) = ""b;

	     connection_area_size = 0;		/* so we can use currentsize */
	     words_used = currentsize (active_connection_list);
	     words_used = words_used + mod (words_used, 2);
						/* round up to even number */
	     call terminate_file_ (addr (active_connection_list), words_used * BITS_PER_WORD, TERM_FILE_TRUNC, code);

	     connection_area_size = sys_info$max_seg_size - words_used;
						/* rest of segment is available for area */

	     area_infop = addr (auto_area_info);

	     area_info.version = 1;
	     string (area_info.control) = ""b;
	     area_info.owner = get_group_id_ ();
	     area_info.size = connection_area_size;
	     area_info.areap = addr (active_connection_list.connection_area);
	     area_info.allocated_blocks, area_info.free_blocks, area_info.allocated_words, area_info.free_words = 0;

	     call define_area_ (area_infop, code);
	end;

INIT_EXIT:
	call cu_$level_set (orig_level);		/* in case we didn't do this before */

	a_code = code;
	return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* 		I N T E R N A L     P R O C E D U R E S		       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* Delete_one_entry: deletes the connection list entry pointed to by	       */
/* act_ptr.						       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

Delete_one_entry:
     procedure ();

	if active_connection.version ^= ACT_VERSION_1
	then do;
	     if name_entry
	     then code = error_table_$unimplemented_version;
	     else code = error_table_$noentry;
	     go to EXIT;
	end;

	if hpriv_entry
	then ;
	else if priv_entry
	then if active_connection.owner_process_id ^= my_process_id
	     then do;				/* we don't own this one */
		code = error_table_$not_privileged;
		go to EXIT;
	     end;
	     else ;

	else if active_connection.user_process_id ^= my_process_id
	then do;					/* no privileges, we should be user */
	     code = error_table_$not_privileged;
	     go to EXIT;
	end;

	call Unthread_user ();			/* take it out of user chain */
	call Unthread ();				/* and others */

	active_connection.version = "";		/* make sure it doesn't look like a good entry */
	active_connection.connection_name = "";

	free active_connection in (active_connection_list.connection_area);
						/* get the space back */

     end Delete_one_entry;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* Fill_info: fills in the active_connection_info structure for the current  */
/* entry.							       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

Fill_info:
     procedure ();

	if active_connection_info.version ^= ACT_INFO_VERSION_1
	then do;
	     code = error_table_$unimplemented_version;
	     return;
	end;

	active_connection_info.connection_name = active_connection.connection_name;
	active_connection_info.network_service_type = active_connection.service_type;
	active_connection_info.user_process_id = active_connection.user_process_id;
	active_connection_info.user_group_id = active_connection.user_group_id;
	active_connection_info.owner_process_id = active_connection.owner_process_id;
	active_connection_info.owner_group_id = active_connection.owner_group_id;
	active_connection_info.terminate_event_channel = active_connection.owner_terminate_event_channel;
	active_connection_info.owner_initializer_handle = active_connection.owner_initializer_id;
	active_connection_info.force_disconnect_entry = active_connection.force_disconnect_entry;
	active_connection_info.force_accounting_flush_entry = active_connection.force_accounting_flush_entry;
	active_connection_info.connection_handle = active_connection.connection_handle;
	active_connection_info.usage_type = active_connection.usage_type;
	active_connection_info.flags.delegated = active_connection.flags.delegated;
	active_connection_info.offset = rel (act_ptr);

	return;

     end Fill_info;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* Find:							       */
/* Searches the list (using the hash table) for a connection with the	       */
/* specified name, and returns its offset if one is found. Also returns the  */
/* index to which the name hashes, for later use in threading/unthreading.   */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

Find:
     procedure (a_connection_name, a_hash_index, a_offset, a_code);



dcl  a_connection_name char (32) parameter;
dcl  a_hash_index fixed bin parameter;
dcl  a_offset bit (18) parameter;
dcl  a_code fixed bin (35) parameter;

dcl  hash_value fixed bin;
dcl  connection_name char (32) aligned;
dcl  offset bit (18);
dcl  found bit (1);

	connection_name = a_connection_name;
	hash_value =
	     hash_index_ (addr (connection_name), length (connection_name), (0), active_connection_list.hash_table.size)
	     + 1;					/* our table is 1-based, but hash_index_'s result is 0-based */
	offset = active_connection_list.hash_table.entries (hash_value);

	if offset ^= ""b				/* if there are any names that hash to this value */
	then do;
	     found = "0"b;

	     do while ((^found) & (offset ^= ""b));	/* find the one that actually has the same name */
		act_ptr = ptr (active_connection_list_ptr, offset);
		if active_connection.connection_name = connection_name
		then found = "1"b;
		else offset = active_connection.next_hash;
						/* not this one, check next */
	     end;
	end;

	a_offset = offset;				/* = ""b if name not found */
	a_hash_index = hash_value;			/* valid in any case */
	a_code = 0;				/* always */
	return;

     end Find;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* Get_next_for_user:					       */
/* Returns a pointer to the next connection for the same user (and, if not   */
/* the hpriv entry, the same owner) after the one input; or the first one if */
/* a_act_ptr is null.					       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

Get_next_for_user:
     procedure (a_act_ptr, a_process_id) returns (pointer);

dcl  a_act_ptr pointer parameter;
dcl  a_process_id bit (36) parameter;

dcl  found bit (1);
dcl  my_process_id bit (36);
dcl  next_offset bit (18);
dcl  owner_process_id bit (36);
dcl  user_process_id bit (36);

	act_ptr = a_act_ptr;
	user_process_id = a_process_id;
	my_process_id = get_process_id_ ();

	if act_ptr ^= null ()			/* we were given one, find next */
	then do;
	     next_offset = active_connection.next_connection_for_user;
	     if next_offset = ""b			/* there isn't one */
	     then return (null ());
	     act_ptr = ptr (active_connection_list_ptr, next_offset);
						/* this is the one we will consider */
	end;

	else do;					/* given nul pointer, we'll have to find first one */
	     found = "0"b;
	     do next_offset = active_connection_list.first_connection_offset
		repeat (active_connection.next_connection) while ((next_offset ^= ""b) & (^found));
		act_ptr = ptr (active_connection_list_ptr, next_offset);
		if active_connection.user_process_id = user_process_id
		then found = "1"b;
	     end;

	     if ^found
	     then return (null ());			/* there weren't any */
	end;

/* if not privileged entry, make sure we're the owner */

	if ^hpriv_entry
	then do while (active_connection.owner_process_id ^= my_process_id);
	     next_offset = active_connection.next_connection_for_user;
	     if next_offset = ""b			/* we ran out */
	     then return (null ());
	     else act_ptr = ptr (active_connection_list_ptr, next_offset);
	end;

	return (act_ptr);				/* if we get to here, we've got the right one */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* Get_next_for_owner:					       */
/* Likewise, but returns a pointer to the next one for the given owner       */
/* process.						       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

Get_next_for_owner:
     entry (a_act_ptr, a_process_id) returns (pointer);

	act_ptr = a_act_ptr;
	owner_process_id = a_process_id;

	if act_ptr ^= null ()			/* we were given one, find next */
	then do;
	     next_offset = active_connection.next_connection_for_owner;
	     act_ptr = ptr (active_connection_list_ptr, next_offset);
						/* this is the one we will consider */
	     if next_offset = ""b			/* there isn't one */
	     then return (null ());
	     else return (act_ptr);
	end;

	else do;					/* have to find first one */
	     do next_offset = active_connection_list.first_connection_offset
		repeat (active_connection.next_connection) while (next_offset ^= ""b);
		act_ptr = ptr (active_connection_list_ptr, next_offset);
		if active_connection.owner_process_id = owner_process_id
		then return (act_ptr);		/* this is it */
	     end;

	     return (null ());			/* there weren't any */
	end;

     end Get_next_for_user;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* Lock:  lock the active connection table.			       */
/* Unlock: unlock it.					       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

Lock:
     procedure (a_code) returns (bit (1));

dcl  a_code fixed bin (35) parameter;

dcl  code fixed bin (35);

	call set_lock_$lock (active_connection_list.lock, LOCK_WAIT_TIME, code);

	if code = 0 | code = error_table_$invalid_lock_reset
	then do;
	     a_code = 0;
	     return ("1"b);
	end;

	else do;
	     a_code = code;
	     return ("0"b);
	end;

     end Lock;


Unlock:
     procedure ();

dcl  code fixed bin (35);

	if active_connection_list_ptr ^= null
	then call set_lock_$unlock (active_connection_list.lock, code);
	return;

     end Unlock;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* Setup:							       */
/* 1) Initialize code variable to 0.				       */
/* 2) Get pointer to active_connection_list segment if we don't already have */
/*    a static copy.					       */
/* 3) Lock the connection table.				       */
/* 4) Make sure the table has been initialized this bootload.  If not,       */
/*    return error back to caller.				       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

Setup:
     procedure ();

	act_dir_name = sys_info$system_control_dir;
	code = 0;
	locked = "0"b;
	if static_connection_list_ptr = null ()		/* first use in this process */
	then do;
	     call cu_$level_get (orig_level);

	     on cleanup call cu_$level_set (orig_level);

	     call cu_$level_set (get_ring_ ());		/* need lower-ring validation level for initiation or creation */
	     call initiate_file_ (act_dir_name, ACT_SEG_NAME, RW_ACCESS, static_connection_list_ptr, (0), code);
	     call cu_$level_set (orig_level);
	     if code ^= 0
	     then go to EXIT;
	end;

	active_connection_list_ptr = static_connection_list_ptr;

	locked = Lock (code);
	if code ^= 0
	then go to EXIT;

/* make sure database has been initialized this bootload */
	temp_lock_word = active_connection_list.initializer_of_list;
	call set_lock_$lock (temp_lock_word, 0, code);
	if code = error_table_$invalid_lock_reset
	then do;
	     code = error_table_$not_initialized;
	     go to EXIT;
	end;
	else if code = error_table_$locked_by_other_process | code = error_table_$locked_by_this_process
	     | code = error_table_$lock_wait_time_exceeded
	then code = 0;
	if code ^= 0
	then go to EXIT;
	return;

     end Setup;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* Thread: threads a connection into:				       */
/*  1) the list of all connections,				       */
/*  2) the threaded list by owner, and				       */
/*  3) the list sharing a hash index.				       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

Thread:
     procedure ();

dcl  found bit (1);
dcl  hash_value fixed bin;
dcl  last_hash bit (18);
dcl  next_act_ptr pointer;
dcl  next_hash bit (18);
dcl  next_offset bit (18);
dcl  offset bit (18);
dcl  prev_act_ptr pointer;
dcl  prev_hash bit (18);
dcl  prev_offset bit (18);
dcl  temp_act_ptr pointer;

	offset = rel (act_ptr);
	if active_connection_list.hash_table.entries (hash_index) = ""b
	then do;					/* this is the first one with this hash_index */
	     active_connection_list.hash_table.entries (hash_index) = offset;
	     active_connection.prev_hash = ""b;
	end;

	else do;					/* hash slot occupied, thread it to hash list */
	     do last_hash = active_connection_list.hash_table.entries (hash_index) repeat (next_hash)
		while (last_hash ^= ""b);
		temp_act_ptr = ptr (active_connection_list_ptr, last_hash);
		next_hash = temp_act_ptr -> active_connection.next_hash;
		prev_hash = last_hash;
	     end;

	     temp_act_ptr -> active_connection.next_hash = offset;
	     active_connection.prev_hash = prev_hash;
	end;

	active_connection.next_hash = ""b;		/* in any case */

/* now thread into owner list */

	found = "0"b;
	do prev_offset = active_connection_list.last_connection_offset
	     repeat (temp_act_ptr -> active_connection.prev_connection) while ((prev_offset ^= ""b) & (^found));
	     temp_act_ptr = ptr (active_connection_list_ptr, prev_offset);
	     if temp_act_ptr -> active_connection.owner_process_id = active_connection.owner_process_id
	     then found = "1"b;			/* we found the end of the list for this owner */
	end;

	if found
	then do;
	     active_connection.prev_connection_for_owner = rel (temp_act_ptr);
	     temp_act_ptr -> active_connection.next_connection_for_owner = offset;
	end;

	else active_connection.prev_connection_for_owner = ""b;
						/* there aren't any others yet */

	active_connection.next_connection_for_owner = ""b;/* in any case */

/* now thread it onto end of list of all connections */

	active_connection.prev_connection = active_connection_list.last_connection_offset;
	active_connection.next_connection = ""b;

	if active_connection_list.last_connection_offset = ""b
	then do;					/* this is the very first one */
	     active_connection_list.first_connection_offset, active_connection_list.last_connection_offset = offset;
	end;

	else do;
	     temp_act_ptr = ptr (active_connection_list_ptr, active_connection_list.last_connection_offset);
	     temp_act_ptr -> active_connection.next_connection = offset;
	     active_connection_list.last_connection_offset = offset;
	end;

	active_connection_list.no_of_connections = active_connection_list.no_of_connections + 1;
	return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* Thread_user:						       */
/* threads a connection into the list by user.  It finds the previous one    */
/* for the same user by chasing back the global connection threads.	       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

Thread_user:
     entry ();

	offset = rel (act_ptr);
	if active_connection.prev_connection = ""b
	then prev_act_ptr = null ();

	else do;
	     found = "0"b;
	     do prev_offset = active_connection.prev_connection
		repeat (prev_act_ptr -> active_connection.prev_connection) while ((prev_offset ^= ""b) & (^found));
		prev_act_ptr = ptr (active_connection_list_ptr, prev_offset);
		if prev_act_ptr -> active_connection.user_process_id = active_connection.user_process_id
		then found = "1"b;
	     end;

	     if ^found
	     then prev_act_ptr = null ();
	end;

	if prev_act_ptr ^= null ()
	then do;
	     next_offset = prev_act_ptr -> active_connection.next_connection_for_user;
	     if next_offset = ""b
	     then next_act_ptr = null ();
	     else next_act_ptr = ptr (active_connection_list_ptr, next_offset);
	end;

	else do;					/* none before it, find the first one after it */
	     if active_connection.next_connection = ""b
	     then next_act_ptr = null ();

	     else do;
		found = "0"b;
		do next_offset = active_connection.next_connection
		     repeat (next_act_ptr -> active_connection.next_connection)
		     while ((next_offset ^= ""b) & (^found));
		     next_act_ptr = ptr (active_connection_list_ptr, next_offset);
		     if next_act_ptr -> active_connection.user_process_id = active_connection.user_process_id
		     then found = "1"b;
		end;

		if ^found
		then next_act_ptr = null ();
	     end;
	end;

/* Having found next and/or previous, do the actual threading */

	if next_act_ptr = null ()
	then active_connection.next_connection_for_user = ""b;

	else do;
	     active_connection.next_connection_for_user = rel (next_act_ptr);
	     next_act_ptr -> active_connection.prev_connection_for_user = offset;
	end;

	if prev_act_ptr = null ()
	then active_connection.prev_connection_for_user = ""b;

	else do;
	     active_connection.prev_connection_for_user = rel (prev_act_ptr);
	     prev_act_ptr -> active_connection.next_connection_for_user = offset;
	end;

	return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* Unthread: removes a connection from:				       */
/*  1) the list of all connections,				       */
/*  2) the owner list, and					       */
/*  3) the list sharing a hash index.				       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

Unthread:
     entry ();

/* Owner list first */

	if active_connection.prev_connection_for_owner ^= ""b
	then do;
	     prev_act_ptr = ptr (active_connection_list_ptr, active_connection.prev_connection_for_owner);
	     prev_act_ptr -> active_connection.next_connection_for_owner = active_connection.next_connection_for_owner;
	end;

	if active_connection.next_connection_for_owner ^= ""b
	then do;
	     next_act_ptr = ptr (active_connection_list_ptr, active_connection.next_connection_for_owner);
	     next_act_ptr -> active_connection.prev_connection_for_owner = active_connection.prev_connection_for_owner;
	end;

/* now hash list */

	if active_connection.next_hash ^= ""b
	then do;
	     next_act_ptr = ptr (active_connection_list_ptr, active_connection.next_hash);
	     next_act_ptr -> active_connection.prev_hash = active_connection.prev_hash;
	end;

	if active_connection.prev_hash ^= ""b
	then do;
	     prev_act_ptr = ptr (active_connection_list_ptr, active_connection.prev_hash);
	     prev_act_ptr -> active_connection.next_hash = active_connection.next_hash;
	end;

	else do;					/* this was first one in hash list, update hash table entry */
	     hash_value =
		hash_index_ (addr (active_connection.connection_name), length (active_connection.connection_name),
		(0), active_connection_list.hash_table.size) + 1;
						/* because our table is 1-based */
	     active_connection_list.hash_table.entries (hash_value) = active_connection.next_hash;
	end;

	active_connection.prev_hash, active_connection.next_hash = ""b;

/* now unthread it from list of all connections */

	if active_connection.next_connection ^= ""b
	then do;
	     next_act_ptr = ptr (active_connection_list_ptr, active_connection.next_connection);
	     next_act_ptr -> active_connection.prev_connection = active_connection.prev_connection;
	end;

	else active_connection_list.last_connection_offset = active_connection.prev_connection;

	if active_connection.prev_connection ^= ""b
	then do;
	     prev_act_ptr = ptr (active_connection_list_ptr, active_connection.prev_connection);
	     prev_act_ptr -> active_connection.next_connection = active_connection.next_connection;
	end;

	else active_connection_list.first_connection_offset = active_connection.next_connection;

	active_connection.prev_connection, active_connection.next_connection = ""b;

	active_connection_list.no_of_connections = active_connection_list.no_of_connections - 1;
	return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* Unthread_user:						       */
/* removes a connection from the list threaded by user.		       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

Unthread_user:
     entry ();

	if active_connection.prev_connection_for_user ^= ""b
	then do;
	     prev_act_ptr = ptr (active_connection_list_ptr, active_connection.prev_connection_for_user);
	     prev_act_ptr -> active_connection.next_connection_for_user = active_connection.next_connection_for_user;
	end;

	if active_connection.next_connection_for_user ^= ""b
	then do;
	     next_act_ptr = ptr (active_connection_list_ptr, active_connection.next_connection_for_user);
	     next_act_ptr -> active_connection.prev_connection_for_user = active_connection.prev_connection_for_user;
	end;

	active_connection.prev_connection_for_user, active_connection.next_connection_for_user = ""b;

	return;

     end Thread;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
 %include access_mode_values;
 %include active_connection_list;
 %include active_connection_info;
 %include area_info;
 %include create_branch_info;
 %include system_constants;
 %include terminate_file;

     end connection_list_manager_;
