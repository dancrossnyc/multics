/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


/* MULTIPLEXER_MGR_ - Manages various multiplexers on behalf of the answering service */
/* Written July-August-September 1978 by Larry Johnson */
/* Modified April 1979 by Larry Johnson so that top level multiplexers need not be FNP's running MCS */
/* Modified July 1979 by C. Hornig so that they don't even need to be FNP's. */
/* Modified Dec. 1980 - Jan. 1981 by Robert Coren to separate start_mpx from listen */
/* Modified Jan. 1981 by Robert Coren to make dump_mpx while load is pending work */
/* Modified December 1981 by Benson I. Margulies for CDT tree. */
/* Modified May 1982 by E. N. Kittlitz for New AS initialization. */
/* Modified June 1982 By B. I. Margulies & E. N. Kittlitz. bug fixes. */
/* Modified June 1982 by E. N. Kittlitz. early stop_mpx bugfix. */
/* Modified August 1982 by Robert Coren to make it possible to prevent automatic reload when calling mpx_crashed. */
/* Modified November 1982 by E. N. Kittlitz. RADC ftp change. BIM fixes.
   don't report load failure to as_init_ on system_init call */
/* Modified January 1983 by E. N. Kittlitz. plotz load of mux with no daughters */
/* Modified August 1983 by Robert Coren. Retry load of non-hardwired mulitplexer if load fails. */
/* Modified August 1983 by Robert Coren. Keep shutdown entry from terminating amultiplexer that wasn't up to begin with. */
/* Modified 83-12-14 BIM. Add shutdown_command for a command interface.
   add count_mpx_users entry. no dump / reload on deconfigure crash. */
/* Modified 84-04-02 BIM. Removed reference to cdte.dim. */
/* Modified 1984-08-02 BIM for bad ref to mpxe.state in shutdown. */
/* Modified 1985-02-19, BIM: to initialize cdte.user_name to a known state */


/****^  HISTORY COMMENTS:
  1) change(86-03-25,MSharpe), approve(86-07-30,MCR7690),
     audit(87-06-25,Parisek), install(87-08-04,MR12.1-1055):
     install(86-10-09,MR12.0-1181):
  2) change(86-06-19,Kissel), approve(86-07-30,MCR7475), audit(86-08-04,Coren),
     install(86-10-09,MR12.0-1181):
     Changed to support the new tty event message format declared in
     net_event_message.incl.pl1 which replaces tty_event_message.incl.pl1.
                                                   END HISTORY COMMENTS */


/* format: style4,delnl,insnl,^ifthendo */
multiplexer_mgr_:
     procedure;

/* Arguments */

dcl  arg_mpx_name char (*);				/* Name of a multiplexer to load */
dcl  arg_check_sw bit (1) aligned;			/* Check load */
dcl  arg_count fixed bin;				/* for delete_fnp */
dcl  arg_go_sw bit (1) aligned;			/* Go after load */
dcl  arg_force_sw bit (1) aligned;			/* Force operation in spite of who is logged out */
dcl  arg_dump_sw bit (1) aligned;			/* Says whether or not to take a dump */
dcl  arg_reload_sw bit (1) aligned;			/* Says whether to reload after a crash */
dcl  arg_state fixed bin;				/* State of multiplexer */
dcl  arg_code fixed bin (35);				/* Automatic */
dcl  arg_cdtp ptr;					/* Pointer to base of cdt */

/* Automatic */

dcl  code fixed bin (35);
dcl  i fixed bin;
dcl  mpx_name char (32);
dcl  mpx_cdtep ptr;					/* Ptr to either cdte or fnpe for this mpx */
dcl  mpx_display_name char (64) var;			/* For error messages */
dcl  name char (64);				/* Name of entry called */
dcl  n_users fixed bin;				/* Count of users on multiplexer */
dcl  devx fixed bin;				/* Ring0 device-index of multiplexer */
dcl  new_mpx_type fixed bin;				/* Used if mpx_type is changing */
dcl  entvar entry variable options (variable);
dcl  parent_state fixed bin;				/* State of a multiplexers parent */
dcl  fnp_only bit (1) init ("0"b);			/* Used by stop_fnp in a special case which is limited to fnps */
dcl  p ptr;
dcl  shutdown_dump bit (1) aligned;
dcl  smlep ptr;
dcl  up_time fixed bin;
dcl  mpx_was_up bit (1);
dcl  thread_trouble_count fixed bin;
dcl  muxx fixed bin;
dcl  x fixed bin;
dcl  firstx fixed bin;
dcl  d_limit fixed bin;
dcl  BAD_THREADS_LABEL label variable internal;		/* Debuggers and other buggers can put versions of that in their search rules */

dcl  1 ev_msg aligned like event_call_info;
declare  1 auto_condition_info aligned like condition_info;

/* Based */

dcl  mpx_area area (sys_info$max_seg_size) based (mpx_areap);
dcl  1 stop_mpx_list_entry based (smlep) aligned,
       2 mpx_name char (32) unaligned,
       2 next ptr;

/* Static */

dcl  static_cdtp ptr int static init (null ());		/* CDT pointer saved at initialization */
dcl  mpx_areap ptr int static init (null ());		/* Remember pointer to my work area */
dcl  loud bit (1) int static init ("0"b);		/* If set, enables some extra messages */

dcl  stop_mpx_list_ptr_ ptr ext static init (null);	/* list of muxes stopped by early stop_mpx command */

/* Constants */

dcl  proc_name char (16) int static options (constant) init ("multiplexer_mgr_");

/* External */

dcl  asu_$asu_listen entry (ptr, fixed bin (35));
dcl  asu_$attach_channel entry (ptr, fixed bin (35));
dcl  asu_$channel_in_use entry (ptr) returns (bit (1) aligned);
dcl  cdt_mgr_$find_cdt_channel entry (pointer, character (32), fixed binary, bit (1) aligned, fixed binary (35));
dcl  cdt_mgr_$thread_out_cdt_channel entry (ptr, fixed bin);
dcl  dialup_$simulated_wakeup entry (ptr);
dcl  mc_tty_$simulated_wakeup entry (ptr);
dcl  find_condition_info_ entry (pointer, pointer, fixed binary (35));
dcl  get_system_free_area_ entry () returns (ptr);
dcl  get_process_id_ returns (bit (36));
dcl  hcs_$make_entry entry (ptr, char (*), char (*), entry, fixed bin (35));
dcl  phcs_$get_devx entry (char (*), fixed bin, fixed bin (35));
dcl  phcs_$tty_control entry (char (*), char (*), pointer, fixed bin (35));
dcl  hphcs_$init_channel entry (fixed bin, ptr, fixed bin (35));
dcl  hphcs_$init_multiplexer entry (fixed bin, fixed bin, ptr, fixed bin (35));
dcl  hphcs_$shutdown_multiplexer entry (fixed bin, fixed bin (35));
dcl  hphcs_$terminate_channel entry (fixed bin, fixed bin (35));
dcl  hphcs_$terminate_multiplexer entry (fixed bin, fixed bin (35));
dcl  hphcs_$start_multiplexer entry (fixed bin, fixed bin (35));
dcl  hphcs_$stop_multiplexer entry (fixed bin, fixed bin (35));
dcl  hphcs_$lct_init entry (fixed bin, fixed bin (35));
dcl  sub_err_ entry () options (variable);
dcl  sys_log_ entry options (variable);
dcl  sys_log_$error_log entry options (variable);
dcl  iox_$err_no_operation entry;
dcl  mc_commands_$listen_to_ttys entry (char (*));
dcl  mc_commands_$remove_tty entry (char (*), bit (1) aligned, fixed bin (35));

dcl  error_table_$action_not_performed ext fixed bin (35);
dcl  error_table_$null_info_ptr fixed bin (35) ext static;
dcl  error_table_$out_of_sequence fixed bin (35) ext static;
dcl  sys_info$max_seg_size ext fixed bin (19);

dcl  sub_error_ condition;

dcl  (addr, clock, collate, divide, unspec, hbound, index, null, rank, rtrim, substr) builtin;



test_update_mpx:
     entry (arg_mpx_name, arg_test_cdtp, arg_code);
declare  arg_test_cdtp pointer;

	call set_entry_name ("test_update_mpx");
	mpx_name = arg_mpx_name;
	cdtp = arg_test_cdtp;
	call validate_mpx_name (muxx);		/* grab this mux */
	if code ^= 0
	then do;
	     arg_code = code;
	     return;
	end;

	call update_cdt (muxx);
	return;

/* Entry to "load" a multiplexer */

load_mpx:
     entry (arg_mpx_name, arg_check_sw, arg_go_sw, arg_force_sw, arg_code);

	call set_entry_name ("load_mpx");
RE_LOAD_MPX:
	mpx_name = arg_mpx_name;
	cdtp = static_cdtp;
	if cdtp = null | ^cdt.mux_mgr_system_init
	then go to ERROR_EARLY_CALL;
	BAD_THREADS_LABEL = RE_LOAD_MPX;

	call validate_mpx_name (muxx);		/* grab this mux */
	if code ^= 0
	then do;
	     arg_code = code;
	     return;
	end;

	if loud
	then call sys_log_ (1, "^a: Loading ^a.^[ check^]^[ go^]^[ force^]", name, mpx_display_name, arg_check_sw,
		arg_go_sw, arg_force_sw);

	call check_parent_state (muxx);		/* Must check to see if my parent is well first */
	if code ^= 0
	then do;
	     call sys_log_ (1, "^a: ^a not loaded. Unable to determine the state of its parent.", name,
		mpx_display_name);
	     arg_code = error_table_$action_not_performed;
	     return;
	end;
	if parent_state ^= MPX_UP
	then do;
	     call sys_log_ (1, "^a: ^a cannot be loaded because its parent multiplexer is not running.", name,
		mpx_display_name);
	     arg_code = error_table_$action_not_performed;
	     return;
	end;

	if mpxe.state = MPX_BOOT
	then do;					/* Current bootload must finish first */
	     call sys_log_ (1, "^a: Initialization of ^a already in progress.", name, mpx_display_name);
	     arg_code = error_table_$action_not_performed;
	     return;
	end;

	if ^arg_force_sw
	then do;					/* Be sure no one is using any of these channels */
	     call count_mpx_users (muxx, n_users);
	     if n_users > 0
	     then do;
		call sys_log_ (1,
		     "^a: User^[s^] of ^d channel^[s^] would be hung up. ^a not loaded. Use -force if necessary.",
		     name, (n_users ^= 1), n_users, (n_users ^= 1), mpx_display_name);
		code = error_table_$action_not_performed;
		return;
	     end;
	end;

	if mpxe.state = MPX_UP
	then do;
	     call shutdown_mpx (mpx_name, "0"b, code);	/* Do a force shutdown of the multiplexer */
	     if code ^= 0
	     then do;
		arg_code = code;
		return;
	     end;
	end;

	call update_cdt (muxx);			/* Perform any pending channel deletions and additions */

	call find_subchannels (muxx, miip);		/* Locate all subchannels of this multiplexer */
	if miip = null
	then do;					/* this is nature's way of saying FOO! */
	     call sys_log_ (1, "^a: ^a has no subchannels.", name, mpx_display_name);
	     code = error_table_$action_not_performed;
	     go to load_mpx_return;
	end;

	mpxe.current_mpx_type = new_mpx_type;

	mpxe.current_service_type = ACTIVE;
	mpxe.flags.check = arg_check_sw;		/* save this info in case we retry the load */

	call phcs_$get_devx (mpx_name, devx, code);
	if code ^= 0
	then do;
	     call sys_log_$error_log (1, code, name, "Unable to get a devx for ^a", mpx_display_name);
	     go to load_mpx_return;
	end;

	call hphcs_$init_multiplexer (devx, mpxe.current_mpx_type, miip, code);
	if code ^= 0
	then do;
	     call sys_log_$error_log (1, code, name, "Unable to initialize ^a.", mpx_display_name);
	     code = error_table_$action_not_performed;
	     go to load_mpx_return;
	end;


/**** mux_init_info contains exactly those channels in the sister */
/**** chain, in the same order. */

	call thread_start (muxx, firstx, d_limit);

	i = 0;
	begin;
declare  1 cdt_list aligned,
	 2 ct fixed bin init (d_limit),
	 2 cdteps (d_limit) ptr unaligned;

	     do x = firstx repeat (cdt_entry (x).threads.next_sister) while (x ^= 0);
		i = i + 1;

		cdtep = addr (cdt.cdt_entry (x));
		if i > d_limit | i > cdt.n_cdtes | cdte.threads.mother ^= muxx
		then call CDT_THREAD_DAMAGE (i, muxx, x);

		cdt_list.cdteps (i) = cdtep;
		cdte.twx = mux_init_info.devx (i);
		if cdte.twx = 0
		then call sys_log_ (1, "^a: No devx assigned to ^a.", name, cdte.name);
		else if cdte.current_service_type ^= MPX_SERVICE
		then do;				/* Init non-multiplexers */
		     call hphcs_$init_channel (cdte.twx, null (), code);
		     if code ^= 0
		     then call sys_log_ (1, "^a: Unable to init channel ^a on ^a.", name, cdte.name, mpx_display_name)
			     ;
		end;
	     end;

	     if i < d_limit				/* ran out of daughters too soon */
	     then call CDT_THREAD_DAMAGE$$TOO_FEW_DAUGHTERS (i, muxx);

	     mpxe.flags.go = arg_go_sw;
	     mpxe.n_bootloads = mpxe.n_bootloads + 1;
	     mpxe.state = MPX_BOOT;
	     mpxe.time_load_start = clock ();
	     mpxe.flags.listening = "0"b;

	     call build_entvar ("load");
	     call entvar (mpx_name, cdtp, mpx_cdtep, addr (cdt_list), arg_check_sw, code);
	end;
	if code ^= 0
	then do;
	     mpxe.state = MPX_DOWN;
	     if loud
	     then call sys_log_$error_log (1, code, name, "Unable to load ^a.", mpx_display_name);

	     i = 0;
	     do x = firstx repeat (cdt_entry (x).threads.next_sister) while (x ^= 0);
		i = i + 1;			/* safety count */
		cdtep = addr (cdt.cdt_entry (x));
		if i > d_limit | i > cdt.n_cdtes | cdte.mother ^= muxx
		then call CDT_THREAD_DAMAGE (i, muxx, x);
		if cdte.twx ^= 0 & cdte.current_service_type ^= MPX_SERVICE
		then call hphcs_$terminate_channel (cdte.twx, code);
		cdte.twx = 0;
	     end;
	     if i < d_limit				/* ran out of daughters too soon */
	     then call CDT_THREAD_DAMAGE$$TOO_FEW_DAUGHTERS (i, muxx);

	     call hphcs_$terminate_multiplexer (devx, code);
	     code = error_table_$action_not_performed;
	     go to load_mpx_return;
	end;


	i = 0;
	do x = firstx repeat (cdt_entry (x).threads.next_sister) while (x ^= 0);
	     cdtep = addr (cdt.cdt_entry (x));
	     i = i + 1;
	     if i > d_limit | i > cdt.n_cdtes | cdte.mother ^= muxx
	     then call CDT_THREAD_DAMAGE (i, muxx, x);
	     if cdte.current_service_type = MPX_SERVICE
	     then cdte.twx = 0;
	end;
	if i < d_limit				/* ran out of daughters too soon */
	then call CDT_THREAD_DAMAGE$$TOO_FEW_DAUGHTERS (i, muxx);

	if mpxe.current_mpx_type ^= MCS_MPX		/* don't do this for FNPs */
	then mpxe.flags.retry_load = ^mpx_cdtep -> cdte.flags.hardwired;
						/* otherwise plan to reload a dialup multiplexer if load fails */

load_mpx_return:
	if miip ^= null ()
	then free mux_init_info;
	arg_code = code;
	return;

/* Entry to perform an orderly shutdown of a multiplexer */
/* NOT FOR EXTERNAL USE. USE COMMAND ENTRY */

shutdown_mpx:
     entry (arg_mpx_name, arg_dump_sw, arg_code);

	call set_entry_name ("shutdown_mpx");
RE_SHUTDOWN_MPX:
	mpx_name = arg_mpx_name;
	cdtp = static_cdtp;
	if cdtp = null | ^cdt.mux_mgr_system_init
	then go to ERROR_EARLY_CALL;
	BAD_THREADS_LABEL = RE_SHUTDOWN_MPX;

	call validate_mpx_name (muxx);
	if code ^= 0
	then do;
	     arg_code = code;
	     return;
	end;

	if loud
	then call sys_log_ (1, "^a: Shutting down ^a.^[ dump^]", name, mpx_display_name, arg_dump_sw);

	if (mpxe.state = MPX_UP) | (mpxe.state = MPX_BOOT)
	then do;
	     call phcs_$get_devx (mpx_name, devx, code);
	     if code ^= 0
	     then do;
		arg_code = code;
		return;
	     end;

	     mpxe.state = MPX_DOWN;			/* Tell dialup_ not to try to do anything useful with subchannels. */
	     call hphcs_$shutdown_multiplexer (devx, code);
	     if code ^= 0
	     then call sys_log_$error_log (1, code, name, "Shutting down ^a.", mpx_display_name);
	     mpx_was_up = "1"b;
	end;

	else mpx_was_up = "0"b;

	if arg_dump_sw
	then do;					/* Dump required */
	     call build_entvar ("dump");
	     call entvar (mpx_name, cdtp, mpx_cdtep, code);
	     if code ^= 0
	     then call sys_log_$error_log (1, code, name, "Unable to dump ^a.", mpx_display_name);
	end;

	call thread_start (muxx, firstx, d_limit);

	if mpx_was_up
	then do;
	     i = 0;
SHUTDOWN_MPX_LOOP:
	     do x = firstx repeat (cdt.cdt_entry (x).threads.next_sister) while (x ^= 0);
		cdtep = addr (cdt.cdt_entry (x));
		i = i + 1;
		if i > d_limit | i > cdt.n_cdtes | cdte.mother ^= muxx
		then call CDT_THREAD_DAMAGE (i, muxx, x);
		if cdte.current_service_type = MPX_SERVICE
		then do;
		     p = addr (cdte.initial_command);
		     if p -> mpxe.state = MPX_UP | p -> mpxe.state = MPX_BOOT
		     then call shutdown_mpx ((cdte.name), "0"b, code);
		end;
		else if cdte.twx ^= 0
		then do;
		     call hphcs_$terminate_channel (cdte.twx, code);
		     if code ^= 0
		     then call sys_log_$error_log (1, code, name, "Terminating ^a.", cdte.name);
		     if cdte.in_use > NOW_HUNG_UP
		     then do;
			unspec (net_event_message) = "0"b;
						/* Simulate hangup wakeup */
			net_event_message.version = NET_EVENT_MESSAGE_VERSION_1;
			net_event_message.network_type = MCS_NETWORK_TYPE;
			net_event_message.handle = cdte.twx;
			net_event_message.type = MCS_HANGUP_MSG;
			ev_msg.channel_id = cdte.event;
			unspec (ev_msg.message) = unspec (net_event_message);
			ev_msg.sender = get_process_id_ ();
			ev_msg.origin.dev_signal = "0"b;
			ev_msg.origin.ring = 0;
			ev_msg.data_ptr = cdtep;
			if cdte.wakeup_handler = "0"b
			then call dialup_$simulated_wakeup (addr (ev_msg));
			else call mc_tty_$simulated_wakeup (addr (ev_msg));
		     end;
		     cdte.twx = 0;
		end;

	     end SHUTDOWN_MPX_LOOP;

	     if i < d_limit				/* ran out of daughters too soon */
	     then call CDT_THREAD_DAMAGE$$TOO_FEW_DAUGHTERS (i, muxx);

	     call hphcs_$terminate_multiplexer (devx, code);
	     if code ^= 0
	     then call sys_log_$error_log (1, code, name, "Terminating ^a.", mpx_display_name);
	end;
	arg_code = code;

	return;

/* Entry to dump and shutdown a multiplexer */

shutdown_mpx_command:
     entry (arg_mpx_name, arg_force_sw, arg_code);

	call set_entry_name ("shutdown_mpx_command");
	shutdown_dump = "0"b;
	go to SHUTDOWN_DUMP_COMMON;

dump_mpx:
     entry (arg_mpx_name, arg_force_sw, arg_code);

	shutdown_dump = "1"b;
	call set_entry_name ("dump_mpx");
SHUTDOWN_DUMP_COMMON:
RE_DUMP_MPX:
	mpx_name = arg_mpx_name;
	cdtp = static_cdtp;
	if cdtp = null | ^cdt.mux_mgr_system_init
	then go to ERROR_EARLY_CALL;
	BAD_THREADS_LABEL = RE_DUMP_MPX;

	call validate_mpx_name (muxx);
	if code ^= 0
	then do;
	     arg_code = code;
	     return;
	end;

	if loud
	then call sys_log_ (1, "^a: Dumping ^a.^[ force^]", name, mpx_display_name, arg_force_sw);

	if ^arg_force_sw
	then do;					/* Be sure no one is using any of these channels */
	     call count_mpx_users (muxx, n_users);
	     if n_users > 0
	     then do;
		call sys_log_ (1,
		     "^a: User^[s^] of ^d channel^[s^] would be hung up. ^a not dumped. Use -force if necessarry.",
		     name, (n_users ^= 1), n_users, (n_users ^= 1), mpx_display_name);
		arg_code = error_table_$action_not_performed;
		return;
	     end;
	end;

	mpxe.flags.retry_load = "0"b;			/* if this results in "load failed", don't reload */

	call shutdown_mpx (mpx_name, shutdown_dump, code);
	arg_code = code;
	return;

/* Entry to start a multiplexer, once it is loaded */

start_mpx:
     entry (arg_mpx_name, arg_force_sw, arg_code);

	call set_entry_name ("start_mpx");
RE_START_MPX:
	mpx_name = arg_mpx_name;
	cdtp = static_cdtp;
	if cdtp = null | ^cdt.mux_mgr_system_init
	then go to ERROR_EARLY_CALL;
	BAD_THREADS_LABEL = RE_START_MPX;

	call validate_mpx_name (muxx);
	if code ^= 0
	then do;
	     arg_code = code;
	     return;
	end;

	if loud
	then call sys_log_ (1, "^a: Starting ^a.^[ force^]", name, mpx_display_name, arg_force_sw);

	if (mpxe.state ^= MPX_BOOT) & (mpxe.state ^= MPX_UP)
	then do;
	     call sys_log_ (1, "^a: ^a has not been loaded, so it cant be started.", name, mpx_display_name);
	     arg_code = error_table_$action_not_performed;
	     return;
	end;

	if (mpxe.state = MPX_UP) & mpxe.flags.go & (mpxe.current_service_type = ACTIVE) & ^arg_force_sw
	then do;
	     call sys_log_ (1, "^a: ^a is already started.", name, mpx_display_name);
	     arg_code = error_table_$action_not_performed;
	     return;
	end;

	mpxe.flags.go = "1"b;			/* In case started with nogo */
	mpxe.current_service_type = ACTIVE;

	if mpxe.state = MPX_BOOT
	then do;					/* Boot in progress, can't start yet */
	     call sys_log_ (1, "^a: ^a is currently loading. It will be started when load completes.", name,
		mpx_display_name);
	     arg_code = error_table_$action_not_performed;
	     return;
	end;

	call phcs_$get_devx (mpx_name, devx, code);
	if code ^= 0
	then do;
	     call sys_log_$error_log (1, code, name, "Can't get devx for ^a.", mpx_display_name);
	     arg_code = code;
	     return;
	end;

	call hphcs_$start_multiplexer (devx, code);
	if code ^= 0
	then do;
	     call sys_log_$error_log (1, code, name, "Starting ^a.", mpx_display_name);
	     arg_code = code;
	     return;
	end;

	arg_code = 0;
	return;

/* Entry to stop a multiplexer */

stop_mpx:
     entry (arg_mpx_name, arg_code);

	call set_entry_name ("stop_mpx");
RE_STOP_MPX:
	mpx_name = arg_mpx_name;
	cdtp = static_cdtp;
	BAD_THREADS_LABEL = RE_STOP_MPX;

	if cdtp = null				/* Early call */
	then do;
	     call get_cdt_ptr (arg_code);
	     if arg_code ^= 0
	     then return;
	end;
	if ^cdt.mux_mgr_system_init
	then fnp_only = "1"b;			/* Allow this only for FNP's */

	call validate_mpx_name (muxx);
	if code ^= 0
	then do;
	     arg_code = code;
	     return;
	end;

	if loud
	then call sys_log_ (1, "^a: Stopping ^a", name, mpx_display_name);

	mpxe.current_service_type = INACTIVE;
	mpxe.flags.go = "0"b;

	if mpxe.state = MPX_UP
	then do;
	     call phcs_$get_devx (mpx_name, devx, code);
	     if code ^= 0
	     then do;
		call sys_log_$error_log (1, code, name, "Can't get devx for ^a.", mpx_display_name);
		arg_code = code;
		return;
	     end;
	     call hphcs_$stop_multiplexer (devx, code);
	     if code ^= 0
	     then do;
		call sys_log_$error_log (1, code, name, "Unable to stop ^a.", mpx_display_name);
		arg_code = code;
		return;
	     end;
	     call sys_log_ (1, "^a: ^a is running but no longer accepting calls.", name, mpx_display_name);
	end;

	else if mpxe.state = MPX_BOOT
	then call sys_log_ (1, "^a: ^a is now loading, but will not be started", name, mpx_display_name);

	else do;					/* early stop_mpx */
	     call sys_log_ (1, "^a: ^a will not be loaded.", name, mpx_display_name);
	     smlep = stop_mpx_list_ptr_;
	     do while (smlep ^= null);
		if stop_mpx_list_entry.mpx_name = mpx_name
		then go to end_early_stop_mpx;
		else smlep = stop_mpx_list_entry.next;
	     end;
	     allocate stop_mpx_list_entry;
	     stop_mpx_list_entry.mpx_name = mpx_name;
	     stop_mpx_list_entry.next = stop_mpx_list_ptr_;
	     stop_mpx_list_ptr_ = smlep;
end_early_stop_mpx:
	end;
	arg_code = 0;
	return;

/* Initialize all sub-channels of a multiplexer */
/* This means list to all regular subchannels and initialize ("load") all sub-multiplexers */

listen_mpx:
     entry (arg_mpx_name, arg_code);

dcl  top_mpxep ptr;

	call set_entry_name ("listen_mpx");
RE_LISTEN_MPX:
	mpx_name = arg_mpx_name;
	cdtp = static_cdtp;
	BAD_THREADS_LABEL = RE_LISTEN_MPX;
	if cdtp = null | ^cdt.mux_mgr_system_init
	then go to ERROR_EARLY_CALL;

	call validate_mpx_name (muxx);
	if code ^= 0
	then do;
	     arg_code = code;
	     return;
	end;

	if loud
	then call sys_log_ (1, "^a: Listening to ^a.", name, mpx_display_name);

	if mpxe.state ^= MPX_UP
	then do;
	     call sys_log_ (1, "^a: ^a is not running. Unable to listen to channels.", name, mpx_display_name);
	     arg_code = error_table_$action_not_performed;
	     return;
	end;

	if mpxe.flags.listening			/* don't have to do this again */
	then do;
	     arg_code = 0;
	     return;
	end;

	top_mpxep = mpxep;				/* save this pointer  for listen switch */

	call thread_start (muxx, firstx, d_limit);
	i = 0;
	do x = firstx repeat (cdt.cdt_entry (x).threads.next_sister) while (x ^= 0);
	     cdtep = addr (cdt.cdt_entry (x));
	     i = i + 1;
	     if i > d_limit | i > cdt.n_cdtes | cdte.mother ^= muxx
	     then call CDT_THREAD_DAMAGE (i, muxx, x);
	     if cdte.in_use > NOW_FREE
	     then do;				/* Channel may have been added/deleted during boot */
		if cdte.current_service_type = ANS_SERVICE | cdte.current_service_type = SLAVE_SERVICE
		     | cdte.current_service_type = DIAL_OUT_SERVICE | cdte.current_service_type = FTP_SERVICE
		then do;
		     call asu_$attach_channel (cdtep, code);
		     if code ^= 0
		     then if loud
			then call sys_log_$error_log (1, code, name, "asu_$attach_channel failed ^a", cdte.name);
			else ;
		     else do;
			call asu_$asu_listen (cdtep, code);
			if code ^= 0
			then if code ^= error_table_$action_not_performed
			     then call sys_log_$error_log (1, code, name, "Channel ^a listen failed.", cdte.name);
			     else if loud
			     then call sys_log_ (1, "^a: asu_$listen_chanel failed for ^a.", cdte.name);
		     end;
		end;
		if cdte.current_service_type = MPX_SERVICE
		then do;
		     mpxep = addr (cdte.initial_command);
		     if mpxe.current_service_type = ACTIVE
		     then call load_mpx ((cdte.name), "0"b, "1"b, "1"b, code);
		end;
	     end;
	end;

	call mc_commands_$listen_to_ttys (mpx_name);
	top_mpxep -> mpxe.flags.listening = "1"b;
	arg_code = 0;
	return;

/* Entry to check the state of a multiplexer */

state_mpx:
     entry (arg_mpx_name, arg_state, arg_code);

	call set_entry_name ("state_mpx");
RE_STATE_MPX:
	mpx_name = arg_mpx_name;
	cdtp = static_cdtp;
	BAD_THREADS_LABEL = RE_STATE_MPX;
	if cdtp = null | ^cdt.mux_mgr_system_init
	then go to ERROR_EARLY_CALL;

	call validate_mpx_name (muxx);
	if code ^= 0
	then arg_state = MPX_UNKNOWN;
	else arg_state = mpxe.state;
	arg_code = code;
	return;

/* Procedure called by indivudal multiplexer handler to report that it is loaded */

mpx_loaded:
     entry (arg_mpx_name, arg_code);

	call set_entry_name ("mpx_loaded");
RE_MPX_LOADED:
	mpx_name = arg_mpx_name;
	cdtp = static_cdtp;
	BAD_THREADS_LABEL = RE_MPX_LOADED;
	call validate_mpx_name (muxx);
	if code ^= 0
	then do;
	     arg_code = code;
	     return;
	end;

	mpxe.state = MPX_UP;
	mpxe.time_last_load = clock ();
	if mpxe.time_initial_load = 0
	then mpxe.time_initial_load = mpxe.time_last_load;

	call phcs_$tty_control (mpx_name, "copy_meters", null (), (0));
						/* clear out the meters */

	if loud
	then call sys_log_ (1, "^a: Successful load reported for ^a.", name, mpx_display_name);

	if mpxe.flags.go
	then call start_mpx (mpx_name, "1"b, code);
	if code ^= 0
	then do;
	     arg_code = code;
	     return;
	end;

	if cdt.flags.go
	then call listen_mpx (mpx_name, code);
	arg_code = code;
	return;

/* Procedure called by individual multiplexer manager to report a unseccussfull load attempt */

mpx_load_failed:
     entry (arg_mpx_name, arg_code);

	call set_entry_name ("mpx_load_failed");
RE_MPX_LOAD_FAILED:
	mpx_name = arg_mpx_name;
	cdtp = static_cdtp;
	BAD_THREADS_LABEL = RE_MPX_LOAD_FAILED;
	call validate_mpx_name (muxx);
	if code ^= 0
	then do;
	     arg_code = code;
	     return;
	end;

	if mpxe.state ^= MPX_BOOT
	then do;					/* Not loading! */
	     call sys_log_ (1, "^a: Report load failure for ^a while not loading.", name, mpx_display_name);
	     arg_code = error_table_$action_not_performed;
	     return;
	end;


	if loud
	then call sys_log_ (1, "^a: Load of ^a failed.", name, mpx_display_name);
	call shutdown_mpx (mpx_name, "1"b, code);
	if code ^= 0
	then call sys_log_$error_log (1, code, name, "Trying to shutdown ^a.", mpx_display_name);

	mpxe.state = MPX_DOWN;

/* Now try the load again (if that's what we're supposed to do) */

	if mpxe.flags.retry_load & code = 0		/* as long as the shutdown was OK */
	then call load_mpx (mpx_name, (mpxe.flags.check), (mpxe.flags.go), "1"b, code);

	arg_code = 0;
	return;

/* Procedure called by individual multiplexer manager to report a crash */

mpx_crashed:
     entry (arg_mpx_name, arg_reload_sw, arg_code);

	call set_entry_name ("mpx_crashed");
RE_MPX_CRASHED:
	mpx_name = arg_mpx_name;
	cdtp = static_cdtp;
	BAD_THREADS_LABEL = RE_MPX_CRASHED;
	call validate_mpx_name (muxx);
	if code ^= 0
	then do;
	     arg_code = code;
	     return;
	end;

	mpxe.time_last_crash = clock ();
	if loud
	then call sys_log_ (1, "^a: Crash reported for ^a.", name, mpx_display_name);
	call shutdown_mpx (mpx_name, arg_reload_sw, code);/* since only FNP's have dumps, and FNPs set this to zero to mean "don't touch" */
	if code ^= 0
	then call sys_log_$error_log (1, code, name, "Shutting down ^a", mpx_display_name);

/* Here we must decide whether or not to reload the mpx */

	up_time = divide (mpxe.time_last_crash - mpxe.time_last_load, 60000000, 17, 0);
						/* Time it stayed up */
	code = 0;

	if arg_reload_sw
	then do;
	     if mpxe.current_service_type = INACTIVE
	     then					/* Stopped by operator */
		call sys_log_ (1, "^a: ^a is stopped and will not be reloaded.", name, mpx_display_name);

	     else if cdt.acceptable_fnp_tbf = 0
	     then					/* No auto reloading */
		call sys_log_ (1, "^a: Automatic reloading is disabled. ^a will not be reloaded.", name,
		     mpx_display_name);

	     else if (mpxe.n_bootloads >= 2) & (up_time < cdt.acceptable_fnp_tbf)
		& (mpxe.last_tbf < cdt.acceptable_fnp_tbf)
	     then call sys_log_ (1, "^a: ^a is in apparent crash loop and will not be reloaded", name, mpx_display_name)
		     ;

	     else call load_mpx (mpx_name, "0"b, "1"b, "0"b, code);
	end;
	mpxe.last_tbf = up_time;			/* Save for next crash */
	arg_code = code;
	return;

/* System initialization entry. Called once per bootload */
/* Its main function is to start the bootload of all configured level-1 multiplexers */

system_init:
     entry (arg_code);

	call set_entry_name ("system_init");
RE_SYSTEM_INIT:
	cdtp = static_cdtp;
	arg_code = 0;
	BAD_THREADS_LABEL = RE_SYSTEM_INIT;

	cdt.flags.go = "0"b;
	cdt.mux_mgr_system_init = "1"b;		/* we are here, lafayette! */

/* First the FNP's */

	do i = 1 to hbound (cdt.fnp_entry, 1);		/* Start bootload on each fnp */
	     fnpep = addr (cdt.fnp_entry (i));
	     mpxep = addr (fnpe.mpxe);
	     if mpxe.state = MPX_DOWN &		/* If its configured */
		mpxe.current_service_type = ACTIVE
	     then do;				/* And it is nornally booted */
		mpx_name = substr (collate (), rank ("a") + i, 1);
		call load_mpx (mpx_name, "0"b, "1"b, "0"b, code);
						/* don't bother as_init_ with load failure */
	     end;
	end;

	call thread_start (0 /* ROOT */, firstx, d_limit);
	i = 0;
	do x = firstx repeat (cdt.cdt_entry (x).next_sister) while (x ^= 0);
	     cdtep = addr (cdt.cdt_entry (x));
	     i = i + 1;
	     if i > d_limit | i > cdt.n_cdtes | cdte.mother ^= 0
	     then call CDT_THREAD_DAMAGE (i, 0, x);
	     mpxep = addr (cdte.initial_command);
	     if mpxe.current_service_type = ACTIVE & mpxe.state = MPX_DOWN
	     then do;
		call load_mpx ((cdte.name), "0"b, "1"b, "0"b, code);
						/* don't bother as_init_ with load failure */
	     end;
	end;
	if i < d_limit
	then call CDT_THREAD_DAMAGE$$TOO_FEW_DAUGHTERS (i, 0);
	return;


/* This entry is called by as_init_ once per multics bootload. It signifys that the system is
   now really starting and we can listen to real channels. If any FNP's have already booted,
   we listen to them now, otherwise we set a switch so they will be listened to as they boot */

system_go:
     entry;

	call set_entry_name ("system_go");
	cdtp = static_cdtp;

	cdt.flags.go = "1"b;
	do i = 1 to hbound (cdt.fnp_entry, 1);
	     fnpep = addr (cdt.fnp_entry (i));
	     mpxep = addr (fnpe.mpxe);
	     if mpxe.state = MPX_UP
	     then call listen_mpx (substr (collate (), rank ("a") + i, 1), code);
	     if fnpe.threads.daughter_count ^= 0
	     then call go_on_down (-i);
	end;
	call go_on_down (0);			/* top level nonfnps */
	return;

go_on_down:
     procedure (muxx);

declare  muxx fixed bin;
declare  d_limit fixed bin;
declare  firstx fixed bin;
declare  x fixed bin;
declare  check_count fixed bin;

	call thread_start (muxx, firstx, d_limit);
	if d_limit = 0
	then return;

	check_count = 0;
	do x = firstx repeat (cdt.cdt_entry (x).threads.next_sister) while (x ^= 0);
	     cdtep = addr (cdt.cdt_entry (x));
	     check_count = check_count + 1;
	     if check_count > d_limit | check_count > cdt.n_cdtes | cdte.mother ^= muxx
	     then call CDT_THREAD_DAMAGE (check_count, muxx, x);

	     if cdte.current_service_type = MPX_SERVICE
	     then do;
		mpxep = addr (cdte.initial_command);
		if mpxe.state = MPX_UP
		then call listen_mpx ((cdte.name), code);
	     end;
	     if cdte.daughter ^= 0
	     then call go_on_down ((cdte.daughter));	/* will invalidate cdtep */
	end;
	if check_count < d_limit
	then call CDT_THREAD_DAMAGE$$TOO_FEW_DAUGHTERS (i, muxx);
     end go_on_down;

/* System initialization of all cdte entries */

init_cdt:
     procedure (a_code);
dcl  a_code fixed bin (35);
dcl  nchan fixed bin;
dcl  i fixed bin;

	a_code = 0;
	cdt.mux_mgr_system_init, cdt.flags.go = "0"b;

	nchan = 0;
	do i = 1 to hbound (cdt.fnp_entry, 1);
	     fnpep = addr (cdt.fnp_entry (i));
	     mpxep = addr (fnpe.mpxe);
	     fnpe.boot_segp = null ();
	     fnpe.boot_ev_chan = 0;
	     if mpxe.state ^= MPX_FREE
	     then do;				/* Is configured */
		call mpxe_init (mpxep);
		if fnpe.mpx_type = 0
		then fnpe.mpx_type = MCS_MPX;
		mpxe.current_mpx_type = fnpe.mpx_type;
		mpxe.current_service_type = fnpe.service_type;
		nchan = nchan + 1;
	     end;
	end;

	on sub_err_ go to SKIP;
	do i = 1 to cdt.current_size;
	     cdtep = addr (cdt.cdt_entry (i));
	     if cdte.in_use = CHANNEL_DELETED
	     then do;
		call cdt_mgr_$thread_out_cdt_channel (cdtp, i);
SKIP:
		cdte.in_use = NOW_FREE;
	     end;
	     if cdte.in_use ^= NOW_FREE
	     then do;
		cdte.current_service_type = cdte.service_type;
		cdte.user_name = "";
		cdte.in_use = NOW_HUNG_UP;
		if cdte.current_service_type = MPX_SERVICE
		then do;
		     mpxep = addr (cdte.initial_command);
		     call mpxe_init (mpxep);
		     mpxe.current_mpx_type = cdte.mpx_type;
		     mpxe.current_service_type = cdte.mpx_service;
		end;
		nchan = nchan + 1;
	     end;
	     cdte.event = 0;
	     cdte.twx = 0;
	     cdte.process = null ();
	     cdte.dialed_to_procid = "0"b;
	     cdte.dial_ev_chn = 0;
	     cdte.recent_wakeup_time = 0;
	     cdte.recent_wakeup_count = 0;
	end;
	as_data_$lct_size = nchan + cdt.spare_channel_count;
	revert sub_err_;
	return;
     end init_cdt;

/* Initialize mpxe portion of cdte or fnpe */

mpxe_init:
     proc (p);

dcl  p ptr;

	p -> mpxe.state = MPX_DOWN;
	p -> mpxe.n_bootloads = 0;
	p -> mpxe.time_initial_load = 0;
	p -> mpxe.time_last_load = 0;
	p -> mpxe.time_last_crash = 0;
	p -> mpxe.time_load_start = 0;
	p -> mpxe.last_tbf = 0;
	p -> mpxe.current_mpx_type = 0;
	p -> mpxe.flags = "0"b;

	return;

     end mpxe_init;

/* Procedure to validate a multiplexer name and setup some variables and pointers describing it */

validate_mpx_name:
     procedure (tablex);

dcl  tablex fixed bin;				/* negative for fnp, as per cdt_mgr_ */
dcl  fnp_sw bit (1) aligned;
dcl  msg char (128) var;

	if cdtp = null ()
	then do;					/* To early in initialization */
	     call sys_log_ (1, "^a: Command used too early in answering service initialization. ^a", name, mpx_name);
	     code = error_table_$action_not_performed;
	     return;
	end;

	if mpx_areap = null ()
	then mpx_areap = get_system_free_area_ ();

	on sub_error_				/* cdt_mgr_ is upset */
	     begin;
	     call find_condition_info_ (null, addr (auto_condition_info), (0));
	     sub_error_info_ptr = auto_condition_info.info_ptr;
	     code = sub_error_info.status_code;
	     call sys_log_ (1, code, name, "cdt_mgr_$find_cdt_channel: ^a", sub_error_info.info_string);
	     call CDT_THREAD_DAMAGE$$BRIEF;
	end;

	call cdt_mgr_$find_cdt_channel (cdtp, mpx_name, tablex, fnp_sw, code);

	if code ^= 0				/* noentry is only defined problem */
	then do;
	     msg = "is not defined in the CDT.";
	     return;
	end;

	if fnp_sw
	then do;
	     fnpep = addr (cdt.fnp_entry (-tablex));
	     mpxep = addr (fnpe.mpxe);
	     msg = "is not a configured FNP";
	     if fnpe.state = MPX_FREE
	     then go to bad_mpx_name;
	     mpx_display_name = "FNP " || rtrim (mpx_name);
						/* For error messages */
	     mpx_cdtep = fnpep;
	     if mpxe.current_mpx_type = 0
	     then mpxe.current_mpx_type = fnpe.mpx_type;
	     new_mpx_type = fnpe.mpx_type;		/* This type never changes */
	end;
	else do;					/* Multiplexed channel */
	     msg = ". Command restricted to top-level multiplexers until AS initialization complete.";
	     if fnp_only & index (mpx_name, ".") > 0
	     then go to bad_mpx_name;

	     cdtep = addr (cdt.cdt_entry (tablex));
	     msg = "is not configured as a multiplexer.";
	     if cdte.current_service_type ^= MPX_SERVICE
	     then go to bad_mpx_name;
	     mpx_display_name = "multiplexer " || rtrim (mpx_name);
	     mpxep = addr (cdte.initial_command);
	     mpx_cdtep = cdtep;
	     if mpxe.current_mpx_type = 0
	     then					/* No current type */
		mpxe.current_mpx_type = cdte.mpx_type;
	     new_mpx_type = cdte.mpx_type;		/* This will be type at next load */
	end;

	fnpep, cdtep = null ();
	code = 0;
	return;
bad_mpx_name:
	call sys_log_ (1, "^a: Invalid multiplexer name: ""^a"" ^a", name, mpx_name, msg);
	code = error_table_$action_not_performed;
     end validate_mpx_name;


/* Procedure to compute one entry variable */

build_entvar:
     proc (action);

dcl  action char (*);

dcl  type_name char (32) var;
dcl  (segname, entname) char (32);

	entvar = iox_$err_no_operation;		/* The error default */
	if mpxe.current_mpx_type < 1 | mpxe.current_mpx_type > hbound (mpx_types, 1)
	then return;
	type_name = rtrim (mpx_types (mpxe.current_mpx_type));
	segname = "as_" || type_name || "_mpx_";	/* As_XXXXX_mpx_ */
	entname = type_name || "_" || action;		/* XXXXX_(load dump) */
	call hcs_$make_entry (null (), segname, entname, entvar, code);
	if code = 0
	then return;

     end build_entvar;

/* Save the name of the entry called */
/* and other misc setup */

set_entry_name:
     proc (e);

dcl  e char (*);

	miip = null;
	thread_trouble_count = 0;
	name = proc_name || "$" || e;
	return;

     end set_entry_name;

/* Get a list of all sub-channels on a multiplexor */
/* This is simply all channels that match the starname mpxname.* */

find_subchannels:
     proc (muxx, p);

dcl  muxx fixed bin;				/* stock cdtx -- fixed bin <0 for fnp, >0 for cdt */
dcl  firstx fixed bin;
dcl  d_limit fixed bin;
dcl  x fixed bin;
dcl  p ptr;
dcl  check_count fixed bin;

	call thread_start (muxx, firstx, d_limit);
	if d_limit = 0
	then return;

	mii_chan_count = d_limit;
	allocate mux_init_info in (mpx_area) set (p);

	check_count = 0;
	do x = firstx repeat (cdt.cdt_entry (x).next_sister) while (x ^= 0);
	     check_count = check_count + 1;
	     if check_count > d_limit | check_count > cdt.n_cdtes
						/** **/
		| cdt.cdt_entry (x).threads.mother ^= muxx
	     then do;
		free mux_init_info;
		call CDT_THREAD_DAMAGE (check_count, muxx, x);
	     end;
	     p -> mux_init_info.name (check_count) = cdt.cdt_entry (x).name;
	     p -> mux_init_info.devx (check_count) = 0;
	end;
	if check_count < d_limit
	then call CDT_THREAD_DAMAGE$$TOO_FEW_DAUGHTERS (check_count, muxx);

     end find_subchannels;

/* Count all the users of a multiplexer */

count_mpx_users:
     proc (muxx, n);

dcl  muxx fixed bin;
dcl  j fixed bin;
dcl  n fixed bin;
dcl  (firstx, d_limit, check_count) fixed bin;
dcl  x fixed bin;


	n = 0;
	call thread_start (muxx, firstx, d_limit);
	if d_limit = 0
	then return;

	check_count = 0;
	do x = firstx repeat (cdt.cdt_entry (x).threads.next_sister) while (x ^= 0);

	     check_count = check_count + 1;
	     if check_count > d_limit | check_count > cdt.n_cdtes | cdt.cdt_entry (x).mother ^= muxx
	     then call CDT_THREAD_DAMAGE (check_count, muxx, x);
	     if cdt.cdt_entry (x).current_service_type = MPX_SERVICE
	     then do;				/* Count users down the tree */
		call count_mpx_users (x, j);
		n = n + j;
	     end;
	     else if asu_$channel_in_use (addr (cdt.cdt_entry (x)))
	     then n = n + 1;
	end;
	if check_count < d_limit
	then call CDT_THREAD_DAMAGE$$TOO_FEW_DAUGHTERS (check_count, muxx);
     end count_mpx_users;

/* Procedure to get the state of a multiplexers parent */

check_parent_state:
     proc (muxx);

dcl  muxx fixed bin;
dcl  tp pointer;

	if muxx < 0
	then tp = addr (cdt.fnp_entry (-muxx).threads);
	else tp = addr (cdt.cdt_entry (muxx).threads);

	if tp -> channel_threads.mother = 0		/* top level mpx */
	then do;
	     parent_state = MPX_UP;
	     code = 0;
	     return;
	end;

	if tp -> channel_threads.mother < 0
	then call state_mpx (substr (collate (), rank ("a") - tp -> channel_threads.mother, 1), parent_state, code);
	else call state_mpx ((cdt.cdt_entry (tp -> channel_threads.mother).name), parent_state, code);

     end check_parent_state;

/* Procedure to perform pending channel additions and deletions before a multiplexer is loaded */

update_cdt:
     procedure (muxx);

declare  dx fixed bin;
declare  x fixed bin;
declare  muxx fixed bin;
declare  (firstx, d_limit, check_count) fixed bin;
declare  local_cdtep pointer;
declare  1 L_CDTE aligned like cdte based (local_cdtep);
declare  p pointer;

	call thread_start (muxx, firstx, d_limit);
	if d_limit = 0
	then return;

	check_count = 0;
	x = firstx;
CONSIDER_EACH:
	do while (x ^= 0);				/* repeat done by hand */
	     local_cdtep = addr (cdt.cdt_entry (x));
	     check_count = check_count + 1;
	     if check_count > d_limit | check_count > cdt.n_cdtes | L_CDTE.mother ^= muxx
	     then call CDT_THREAD_DAMAGE (check_count, muxx, x);


	     if L_CDTE.in_use = CHANNEL_DELETED | L_CDTE.in_use = NOW_FREE
						/* NOW_FREE really shouldn't happen, but ... */
	     then do;

		if L_CDTE.daughter_count > 0
		then call update_cdt (x);		/* get the whole family */
		L_CDTE.in_use = NOW_FREE;
		L_CDTE.twx = 0;
		L_CDTE.event = 0;

		dx = x;				/** protect against deletions */
		x = L_CDTE.threads.next_sister;

		call cdt_mgr_$thread_out_cdt_channel (cdtp, dx);

	     end;					/* deletion case */

	     else
NON_DELETED:
		do;
		if L_CDTE.in_use = NOT_CONFIGURED
		then do;
		     L_CDTE.in_use = NOW_HUNG_UP;
		     L_CDTE.current_service_type = L_CDTE.service_type;
		     L_CDTE.twx = 0;
		     L_CDTE.event = 0;
		     L_CDTE.process = null ();
		     L_CDTE.dialed_to_procid = ""b;
		end;
		else if L_CDTE.current_service_type = MC_SERVICE
		then do;
		     if L_CDTE.service_type ^= MC_SERVICE
		     then				/* And we are about to take it away */
			call mc_commands_$remove_tty ((L_CDTE.name), ""b, code);
						/* Co-operate */
		end;

		else if L_CDTE.current_service_type = MPX_SERVICE
		then do;
		     if L_CDTE.service_type ^= MPX_SERVICE
		     then L_CDTE.initial_command = "";
		end;

		L_CDTE.current_service_type = L_CDTE.service_type;
		if L_CDTE.current_service_type = MPX_SERVICE
		then do;				/* Get multiplexers ready */
		     p = addr (L_CDTE.initial_command);
		     call mpxe_init (p);
		     p -> mpxe.current_mpx_type = L_CDTE.mpx_type;
		end;
		if L_CDTE.daughter_count > 0
		then call update_cdt (x);
		x = L_CDTE.threads.next_sister;
	     end NON_DELETED;
	end CONSIDER_EACH;

     end update_cdt;


thread_start:
     procedure (muxx, firstx, d_limit);

declare  firstx fixed bin;				/* first cdte to examine */
declare  d_limit fixed bin;				/* number of daughters you should find */
declare  muxx fixed bin;

	if muxx < 0
	then do;
	     firstx = cdt.fnp_entry (-muxx).threads.daughter;
	     d_limit = cdt.fnp_entry (-muxx).threads.daughter_count;
	end;
	else if muxx > 0
	then do;
	     firstx = cdt.cdt_entry (muxx).threads.daughter;
	     d_limit = cdt.cdt_entry (muxx).threads.daughter_count;
	end;
	else if muxx = 0				/* not used yet, but not a bad idea */
	then do;
	     firstx = cdt.threads.daughter;
	     d_limit = cdt.threads.daughter_count;
	end;

	if (d_limit = 0) ^= (firstx = 0)
	then call CDT_THREAD_DAMAGE$$DAUGHTERS (muxx);
     end thread_start;

get_cdt_ptr:
     procedure (code);

declare  code fixed bin (35);
declare  cdt_mgr_$init entry (character (*), pointer, fixed binary (35));
declare  cdt_mgr_$thread entry (pointer, fixed binary (35));

	cdtp, static_cdtp = null;
	on sub_error_
	     begin;
	     call find_condition_info_ (null, addr (auto_condition_info), (0));
	     sub_error_info_ptr = auto_condition_info.info_ptr;
	     cdtp = sub_error_info.info_ptr;		/* message in a bottle */
	     call sys_log_$error_log (0, sub_error_info.status_code, name, "cdt_mgr_$init: ^a",
		sub_error_info.info_string);		/* for now we rethread and call it a live baby */

	     on sub_error_
		begin;
		call find_condition_info_ (null, addr (auto_condition_info), (0));
		sub_error_info_ptr = auto_condition_info.info_ptr;
		call sys_log_$error_log (1, sub_error_info.status_code, name, "cdt_mgr_$thread: ^a",
		     sub_error_info.info_string);
		if ^sub_error_info.default_restart	/* not warning */
		then do;
		     call sys_log_ (2, "^a: CDT rethreading failed.", name);
		     code = sub_error_info.status_code;
		     go to RETURN;
		end;
	     end;
	     if cdtp = null
	     then go to GIVE_UP;
	     call sys_log_ (0, "^a: Rethreading CDT.", name);
	     call cdt_mgr_$thread (cdtp, (0));		/* code uninteresting with handler */
	     call sys_log_ (0, "^a: Rethreading of CDT complete.", name);
	     static_cdtp = cdtp;
/**** * return to cdt_mgr_$init */
	end;

	call cdt_mgr_$init (sc_stat_$sysdir, cdtp, code);
	if code ^= 0
	then do;
GIVE_UP:
	     call sys_log_$error_log (1, code, name, "cdt_mgr_$init failed.");
	     return;
	end;

	call init_cdt (code);
	if code ^= 0
	then return;
	static_cdtp = cdtp;
RETURN:
	return;


     end get_cdt_ptr;


CDT_THREAD_DAMAGE:					/* Code comes here when something is WRONG */
     procedure (n_daughters, muxx, errorx);

declare  n_daughters fixed bin;
declare  muxx fixed bin;
declare  errorx fixed bin;

declare  cdt_mgr_$thread entry (pointer, fixed binary (35));
declare  as_error_table_$repeated_cdt_damage ext static fixed bin (35);
declare  as_error_table_$cdt_rethreading_error ext static fixed bin (35);


	if muxx > 0
	then call error_many (cdt.cdt_entry (muxx).name, muxx, cdt.cdt_entry (errorx).name, errorx,
		cdt.cdt_entry (muxx).daughter_count);
	else if muxx = 0
	then call error_many ("Top level muxes", 0, cdt.cdt_entry (errorx).name, errorx, cdt.threads.daughter_count);
	else call error_many ("FNP " || substr (collate (), rank ("a") - muxx, 1), muxx, cdt.cdt_entry (errorx).name,
		errorx, cdt.fnp_entry (-muxx).daughter_count);
	go to E_COMMON;

CDT_THREAD_DAMAGE$$TOO_FEW_DAUGHTERS:
     entry (n_daughters, muxx);

	if muxx > 0
	then call error_few (cdt.cdt_entry (muxx).name, muxx, cdt.cdt_entry (muxx).daughter_count);
	else if muxx = 0
	then call error_few ("Top level muxes", 0, cdt.threads.daughter_count);
	else call error_few ("FNP " || substr (collate (), rank ("a") - muxx, 1), muxx,
		cdt.fnp_entry (-muxx).daughter_count);
	go to E_COMMON;

CDT_THREAD_DAMAGE$$DAUGHTERS:
     entry (muxx);

	if muxx > 0
	then call error_none (cdt.cdt_entry (muxx).name, muxx, cdt.cdt_entry (muxx).daughter_count,
		cdt.cdt_entry (muxx).daughter);
	else if muxx = 0
	then call error_none ("Top level muxes", 0, cdt.threads.daughter_count, cdt.threads.daughter);
	else call error_none (substr (collate (), rank ("a") - muxx, 1), muxx, cdt.fnp_entry (-muxx).daughter_count,
		cdt.fnp_entry (-muxx).daughter);

CDT_THREAD_DAMAGE$$BRIEF:
     entry;

E_COMMON:
	if thread_trouble_count > 0			/* once is all you get */
	then do;
	     call sys_log_ (1, "^a: Repeated damage to CDT threads encountered.", name);
	     arg_code = as_error_table_$repeated_cdt_damage;
	     go to RETURN;
	end;
	call sys_log_ (1, "^a: Threading inconsistency detected in CDT. Rethreading.", name);
	thread_trouble_count = 1;
	on sub_error_
	     begin;
	     call find_condition_info_ (null, addr (auto_condition_info), (0));
	     sub_error_info_ptr = auto_condition_info.info_ptr;
	     call sys_log_$error_log (1, sub_error_info.status_code, name, "cdt_mgr_$thread: ^a",
		sub_error_info.info_string);
	     if ^sub_error_info.default_restart		/* not just warning */
	     then do;
		call sys_log_ (1, "^a: Error while rethreading CDT.", name);
		call sys_log_$error_log (3, sub_error_info.status_code, name, "cdt_mgr_$thread: ^a.",
		     sub_error_info.info_string);
		arg_code = as_error_table_$cdt_rethreading_error;
		go to RETURN;
	     end;
	end;

	call cdt_mgr_$thread (cdtp, (0));		/* code uninteresting */

/**** IF WE GOT HERE, IT SUCCEEDED ****/

	call sys_log_ (1, "^a: Rethreading complete.", name);
	if miip ^= null
	then free mux_init_info;
	go to BAD_THREADS_LABEL;

error_many:
	procedure (pname, px, ename, ex, dc);
declare  (pname, ename) character (32) aligned;
declare  dc fixed bin unaligned;
declare  (px, ex) fixed bin;

	     call sys_log_ (1, "^a: ^d daughters found for mux ^a(^d) at ^a(^d), but daughter count is ^d", name,
		n_daughters, pname, px, ename, ex, dc);
	     return;

error_few:
	entry (pname, px, dc);

	     call sys_log_ (1, "^a: ^d daughters found for mux ^a(^d), but daughter count is ^d.", name, n_daughters,
		pname, px, dc);
	     return;

error_none:
	entry (pname, px, dc, d);
declare  d fixed bin unaligned;

	     call sys_log_ (1, "^a: ^a(^d) has daughter count ^d, but first daughter ^d", name, pname, px, dc, d);
	     return;
	end error_many;

     end CDT_THREAD_DAMAGE;


ERROR_EARLY_CALL:
	begin;
	     call sys_log_ (1, "^a: multiplexers may not be manipulated before AS initialization.", name);
	     arg_code = error_table_$action_not_performed;
	     return;
	end;
RETURN:
	return;


init:
     entry (arg_cdtp, arg_code);
	if ^sc_stat_$Multics_typed | sc_stat_$Go_typed
	then call sub_err_ (error_table_$out_of_sequence, "multiplexer_mgr_$init", "s");
	call set_entry_name ("init");
	if static_cdtp ^= null			/* already done some initialization? */
	then do;
	     cdtp = static_cdtp;
	     if cdt.mux_mgr_system_init		/* really got going? */
	     then do;
		call sys_log_ (1, "^a: Shutting down initialized multiplexers prior to re-initialization.", name);
		call shut;			/* try to stop things */
	     end;
	end;					/* NOTE: shut will set static_cdtp = null */
	if static_cdtp = null			/* see if never initialized or just shut */
	then do;
	     call get_cdt_ptr (arg_code);
	     if arg_code ^= 0
	     then return;
	     smlep = stop_mpx_list_ptr_;		/* if this is a retry, then we must */
	     fnp_only = "1"b;			/* re-stop any muxes that were early stopped */
						/* list will be null if not retry */
	     do while (smlep ^= null);		/* for each early-stopped mux */
		mpx_name = stop_mpx_list_entry.mpx_name;
		BAD_THREADS_LABEL = INIT_RE_STOP_MPX;	/* where to go if error & good salvage */
INIT_RE_STOP_MPX:					/* not a million miles away */
		call validate_mpx_name (muxx);	/* is it still there? */
		if code ^= 0			/* qu'elle chomage */
		then call sys_log_$error_log (1, code, name, "Unable to perform requested stop_mpx of ^a.", mpx_name);
		else do;				/* ahhhhh */
		     mpxe.current_service_type = INACTIVE;
		     mpxe.flags.go = "0"b;
		end;
		smlep = stop_mpx_list_entry.next;
	     end;
	end;

	if ^as_data_$lct_initialized
	then do;
	     call hphcs_$lct_init (as_data_$lct_size, arg_code);
						/* Perform ring0 initialization */
	     if arg_code ^= 0
	     then call sys_log_$error_log (1, arg_code, "multiplexer_mgr_$init", "From hphcs_$lct_init");
	     else as_data_$lct_initialized = "1"b;
	end;
	arg_cdtp = static_cdtp;
	arg_code = 0;
	return;

shut:
     entry;
declare  cdt_mgr_$shut entry (pointer);
	if static_cdtp = null
	then return;

	cdtp = static_cdtp;

	call set_entry_name ("shut");
	BAD_THREADS_LABEL = RE_SHUT;			/* see below */

	if loud
	then call sys_log_ (1, "^a: Shutting down all multiplexers.", name);

/* First the FNP's */

	do i = 1 to hbound (cdt.fnp_entry, 1);		/* Start bootload on each fnp */
	     fnpep = addr (cdt.fnp_entry (i));
	     mpxep = addr (fnpe.mpxe);
	     if mpxe.state = MPX_UP | mpxe.state = MPX_BOOT
	     then do;				/* And it is nornally booted */
		mpx_name = substr (collate (), rank ("a") + i, 1);
		call shutdown_mpx (mpx_name, "0"b /* no dump */, code);
		if code ^= 0
		then if loud
		     then call sys_log_$error_log (1, code, name, "Could not shutdown FNP ^a.", mpx_name);
	     end;
	end;

	call thread_start (0 /* ROOT */, firstx, d_limit);
	i = 0;
	do x = firstx repeat (cdt.cdt_entry (x).next_sister) while (x ^= 0);
	     cdtep = addr (cdt.cdt_entry (x));
	     i = i + 1;
	     if i > d_limit | i > cdt.n_cdtes | cdte.mother ^= 0
	     then call CDT_THREAD_DAMAGE (i, 0, x);
	     mpxep = addr (cdte.initial_command);
	     if mpxe.current_service_type = ACTIVE & mpxe.state = MPX_DOWN
	     then do;
		call shutdown_mpx ((cdte.name), "0"b, code);
		if code ^= 0
		then if loud
		     then call sys_log_$error_log (1, code, name, "Could not shutdown ^a.", cdte.name);
	     end;
	end;
	if i < d_limit
	then call CDT_THREAD_DAMAGE$$TOO_FEW_DAUGHTERS (i, 0);


GIVE_UP_SHUT:
	cdt.mux_mgr_system_init = "0"b;


	call cdt_mgr_$shut (static_cdtp);
	static_cdtp = null;
	return;

RE_SHUT:
	BAD_THREADS_LABEL = GIVE_UP_SHUT;		/* only one try */
	thread_trouble_count = 0;			/* but go to give up rather than returning */


/* Entry to count users for reconfiguration */

count_mpx_users:
     entry (arg_mpx_name, arg_cdtp, arg_count, arg_code);

	call set_entry_name ("count_mpx_users");

	mpx_name = arg_mpx_name;
	arg_count = 0;
	if arg_cdtp ^= null ()
	then cdtp = arg_cdtp;
	else cdtp = static_cdtp;
	if cdtp = null | ^cdt.mux_mgr_system_init
	then do;
	     code = error_table_$null_info_ptr;
	     return;
	end;
	BAD_THREADS_LABEL = ABORT_COUNT;

	call validate_mpx_name (muxx);		/* grab this mux */
	if code ^= 0
	then do;
	     arg_code = code;
	     return;
	end;

	call count_mpx_users (muxx, arg_count);
	return;

ABORT_COUNT:
	arg_code = error_table_$action_not_performed;
	return;



set_loud:
     entry;

	loud = "1"b;
	return;

set_quiet:
     entry;

	loud = "0"b;
	return;
%page;
%include as_data_;
%page;
%include author_dcl;
%page;
%include cdt;
%page;
%include condition_info;
%page;
%include condition_info_header;
%page;
%include dialup_values;
%page;
%include event_call_info;
%page;
%include multiplexer_types;
%page;
%include mux_init_info;
%page;
%include net_event_message;
%page;
%include sc_stat_;
%page;
%include sub_error_info;
%page;
/* BEGIN MESSAGE DOCUMENTATION

   Message:
   multiplexer_mgr_$load_mpx: Loading MPX. ARGS

   S:     as (severity1)

   T:     $run

   M:     A load of the multiplexer named MPX has been started. ARGS,
   if present, lists the control arguments given to the load_mpx
   command (-check, -go, and/or -force).

   A:     $ignore

   Message:
   multiplexer_mgr_$load_mpx: MPX not loaded. Unable to determine the
   state of its parent.

   S:     as (severity1)

   T:     $run

   M:     An attempt to load the multiplexer named MPX failed because
   the system was unable to determine whether its parent multiplexer
   was loaded.

   A:     $inform
   If possible, attempt to load the parent multiplexer.

   Message:
   multiplexer_mgr_$load_mpx: MPX cannot be loaded because its parent
   multiplexer is not running.

   S:     as (severity1)

   T:     $run

   M:     An attempt to load the multiplexer named MPX failed because
   its parent multiplexer was not running.

   A:     Try to load the parent multiplexer before retrying the load
   of MPX.

   Message:
   multiplexer_mgr_$load_mpx: Initialization of MPX already in progress.

   S:     as (severity1)

   T:     $run

   M:     An attempt to load the multiplexer named MPX failed because
   a previous load of MPX has not completed.

   A:     Either allow the load currently in progress to complete, or
   use the dump_mpx command to abort before retrying the load.

   Message:
   multiplexer_mgr_$load_mpx: User(s) of N channel(s) would be hung
   up. MPX not loaded. Use -force if necessary.

   S:     as (severity1)

   T:     $run

   M:     The multiplexer named MPX has N subchannels with users
   logged in. It can only be loaded if the -force control argument is
   provided to the load_mpx command.

   A:     Either reenter the load_mpx command with the -force control
   argument, or wait for the users to be disconnected or logged out.

   Message:
   multiplexer_mgr_$load_mpx: MPX has no subchannels.

   S:     as (severity1)

   T:     $run

   M:     The multiplexer named MPX cannot be used because it has no
   subchannels specified in the CDT.

   A:     $inform_sa

   Message:
   multiplexer_mgr_$load_mpx: No devx assigned to MPX.CHAN.

   S:     as (severity1)

   T:     $run

   M:     The subchannel CHAN of multiplexer MPX was not assigned a
   device index ("devx") when MPX was initialized.

   A:     $inform

   Message:
   multiplexer_mgr_$load_mpx: Unable to init channel CHAN on MPX.

   S:     as (severity1)

   T:     $run

   M:     The subchannel CHAN of multiplexer MPX could not be
   initialized.

   A:     $inform

   Message:
   multiplexer_mgr_$shutdown_mpx: Shutting down MPX. [dump]

   S:     as (severity1)

   T:     $run

   M:     If tracing is on, this message appears when a multiplexer is
   shut down. The string "dump" appears at the end of the message if
   the the shutdown is in response to a dump_mpx command, rather than a
   shutdown_mpx command.

   A:     $ignore

   Message:
   multiplexer_mgr_$COMMAND: Dumping MPX. [force]

   S:     as (severity1)

   T:     $run

   M:     If tracing is on, this message appears when dumping a
   multiplexer in response to either a dump_mpx or shutdown_mpx
   command (as indicated by COMMAND). The string "force" appears if
   the -force control argument was specified.

   A:     $ignore

   Message:
   multiplexer_mgr_$COMMAND: User(s) of N channel(s) would be hung up.
   MPX not dumped. Use -force if necessary.

   S:     as (severity1)

   T:     $run

   M:     The multiplexer named MPX had logged-in users on N
   subchannels when a dump_mpx or shutdown_mpx command (as indicated by
   COMMAND) was given. The multiplexer cannot be dumped or shut down
   unless the -force control argument is used.

   A:     Retry the command with the -force control argument, or wait
   for the users to be disconnected or logged out.

   Message:
   multiplexer_mgr_$start_mpx: Starting MPX. [force]

   S:     as (severity1)

   T:     $run

   M:     If tracing is on, this message appears when the multiplexer
   named MPX is started, either automatically after loading, or in
   response to an explicit start_mpx command. The string "force"
   appears if the -force control argument was specified.

   A:     $ignore

   Message:
   multiplexer_mgr_$start_mpx: MPX has not been loaded, so it can't be
   started.

   S:     as (severity1)

   T:     $run

   M:     A start_mpx command was entered for the multiplexer named
   MPX, but it has not been loaded.

   A:     Load the multiplexer by using the load_mpx command.

   Message:
   multiplexer_mgr_$start_mpx: MPX is already started.

   S:     as (severity1)

   T:     $run

   M:     A start_mpx command was entered for the multiplexer named
   MPX, but it had already been started.

   A:     $ignore

   Message:
   multiplexer_mgr_$start_mpx: MPX is currently loading. It will be
   started when load completes.

   S:     as (severity1)

   T:     $run

   M:     A start_mpx command was entered for the multiplexer named
   MPX while loading of MPX was in progress. The start_mpx command
   will take effect after the load is completed.

   A:     $ignore

   Message:
   multiplexer_mgr_$stop_mpx: Stopping MPX

   S:     as (severity1)

   T:     $run

   M:     If tracing is on, this message appears in response to a
   stop_mpx command for the multiplexer named MPX.

   A:     $ignore

   Message:
   multiplexer_mgr_$stop_mpx: MPX is running but no longer accepting calls.

   S:     as (severity1)

   T:     $run

   M:     This message acknowledges that a stop_mpx command has been
   successfully executed on the running multiplexer named MPX.

   A:     $ignore

   Message:
   multiplexer_mgr_$stop_mpx: MPX is now loading, but will not be started

   S:     as (severity1)

   T:     $run

   M:     This message acknowledges a stop_mpx command for the
   multiplexer named MPX, which is currently being loaded.

   A:     $ignore

   Message:
   multiplexer_mgr_$stop_mpx: MPX will not be loaded.

   S:     as (severity1)

   T:     $run

   M:     This message acknowledges a stop_mpx command for the
   multiplexer named  MPX, which is currently not loaded.

   A:     $ignore

   Message:
   multiplexer_mgr_$listen_mpx: Listening to MPX.

   S:     as (severity1)

   T:     $run

   M:     If tracing is on, this message appears when starting to
   listen to the subchannels of the multiplexer named MPX after it has
   been loaded and started.

   A:     $ignore

   Message:
   multiplexer_mgr_$listen_mpx: MPX is not running. Unable to listen
   to channels.

   S:     as (severity1)

   T:     $run

   M:     An attempt was made to listen to the subchannels of the
   multiplexer named MPX, but the multiplexer was not running. This
   might occur if the multiplexer crashed very shortly after being
   loaded.

   A:     If there is a message indicating that the multiplexer
   crashed shortly after loading, try to reload it. Otherwise, contact
   the system programming staff.

   Message:
   multiplexer_mgr_$listen_mpx: asu_$listen_chanel failed for MPX.CHAN.

   S:     as (severity1)

   T:     $run

   M:     If tracing is on, this message appears if an attempt to
   listen to the subchannel named CHAN of the multiplexer named MPX
   returned a status code of error_table_$action_not_performed. An
   additional message from asu_$asu_listen should appear giving more
   information about the failure.

   A:     $inform

   Message:
   multiplexer_mgr_mpx_loaded: Successful load reported for MPX.

   S:     as (severity1)

   T:     $run

   M:     If tracing is on, this message appears when the answering
   service is notified that the multiplexer named MPX has been
   successfully loaded.

   A:     $ignore

   Message:
   multiplexer_mgr_$mpx_load_failed: Report load failure for MPX while
   not loading.

   S:     as (severity1)

   T:     $run

   M:     The answering service was notified that loading of the
   multiplexer named MPX had failed, but no load of that multiplexer
   was in progress at the time.

   A:     $inform

   Message:
   multiplexer_mgr_$mpx_load_failed: Load of MPX failed.

   S:     as (severity1)

   T:     $run

   M:     If tracing is on, this message appears if the answering
   service is notified that an attempt to load the multiplexer named
   MPX failed. A previous message should give more information about
   the failure.

   A:     $ignore

   Message:
   multiplexer_mgr_$mpx_crashed: Crash reported for MPX.

   S:     as (severity1)

   T:     $run

   M:     If tracing is on, this message appears when the answering
   service is notified that the multiplexer named MPX has crashed.

   A:     $ignore

   Message:
   multiplexer_mgr_$mpx_crashed: MPX is stopped and will not be reloaded.

   S:     as (severity1)

   T:     $run

   M:     The multiplexer named MPX has crashed and is not being
   reloaded because of a previous stop_mpx command.

   A:     $ignore

   Message:
   multiplexer_mgr_$mpx_crashed: Automatic reloading is disabled. MPX
   will not be reloaded.

   S:     as (severity1)

   T:     $run

   M:     The multiplexer named MPX, which has crashed, is not being
   reloaded because automatic reloading of multiplexers has been
   disabled (by setting the FNP_required_up_time field in the CMF to
   0).

   A:     If it is desired to reload the multiplexer, enter a load_mpx
   command.

   Message:
   multiplexer_mgr_$mpx_crashed: MPX is in apparent crash loop and
   will not be reloaded

   S:     as (severity1)

   T:     $run

   M:     The multiplexer named MPX has crashed more than twice in the
   interval specified by FNP_required_up_time, and will not be
   automatically reloaded.

   A:     $inform

   Message:
   multiplexer_mgr_$CMD: Command used too early in answering service
   initialization. MPX

   S:     as (severity1)

   T:     $run

   M:     An operator command (identified by CMD) has been entered for
   the multiplexer named MPX before the answering service has been
   initialized.

   A:     $ignore
   The command may have to be entered manually after answering service
   initialization is complete.

   Message:
   ERROR. cdt_mgr_$find_cdt_channel: INFO

   S:     as (severity1)

   T:     $run

   M:     An error (identified by the status code reported in ERROR)
   has occurred while trying to find a multiplexer name in the CDT.
   Further information about the error is given in INFO.

   A:     $inform

   Message:
   multiplexer_mgr_$validate_mpx_name: Invalid multiplexer name: MPX REASON

   S:     as (severity1)

   T:     $run

   M:     The multiplexer name MPX, which has been used in an operator
   command, is invalid, for the reason given by REASON.

   A:     If the name was mistyped, reenter the command. Otherwise,
   contact the system administrator.

   Message:
   multiplexer_mgr_$CMD: Rethreading CDT.

   S:     as (severity0)

   T:     $run

   M:     In the process of performing the action requested by CMD,
   the CDT was found to be damaged (as indicated by a separate
   message); an attempt will be made to repair the damage.

   A:     $ignore

   Message:
   multiplexer_mgr_$CMD: Rethreading of CDT complete.

   S:     as (severity0)

   T:     $run

   M:     Damage to the CDT discovered in the course of executing CMD,
   and reported in a previous message, has been successfully repaired.

   A:     $ignore

   Message:
   multiplexer_mgr_$CMD: CDT rethreading failed.

   S:     as (severity2)

   T:     $run

   M:     An attempt to repair damage to the CDT discovered while
   executing CMD (and reported in a previous message) has failed.

   A:     $inform

   Message:
   multiplexer_mgr_$CMD: Threading inconsistency detected in CDT.
   Rethreading.

   S:     as (severity1)

   T:     $run

   M:     An inconsistency in the CDT has been discovered in the CDT
   while executing CMD. An attempt will be made to repair the
   inconsistency.

   A:     $ignore

   Message:
   multiplexer_mgr_$CMD: Repeated damage to CDT threads encountered.

   S:     as (severity1)

   T:     $run

   M:     After an attempt to repair an inconsistency to the CDT
   discovered while executing CMD, the CDT was still inconsistent.

   A:     $inform

   Message:
   multiplexer_mgr_$CMD: Error while rethreading CDT.

   S:     as (severity1)

   T:     $run

   M:     An error (reported by a previous message) was encountered
   while attempting to repair an inconsistency in the CDT discovered
   while executing CMD.

   A:     $inform

   Message:
   multiplexer_mgr_$CMD: Rethreading complete.

   S:     as (severity1)

   T:     $run

   M:     An inconsistency discovered in the CDT while executing CMD
   (and reported in a previous message) has been successfully repaired.

   A:     $ignore

   Message:
   multiplexer_mgr_$CMD: N daughters found for mux MPX(X1)[ at
   CHAN(X2]), but daughter count is M

   S:     as (severity1)

   T:     $run

   M:     An inconsistency in the CDT was found while executing CMD.
   The CDT indicates that the multiplexer named MPX, occupying entry
   number X1, has M subchannels, but N subchannels are threaded to it.
   If N > M, the Nth subchannel is CHAN, occupying entry number X2.

   A:     $inform

   Message:
   multiplexer_mgr_$CMD: MPX(X1) has daughter count N, but first
   daughter X2

   S:     as (severity1)

   T:     $run

   M:     An inconsistency has been discovered in the CDT while
   executing CMD. The multiplexer named MPX, occupying CDT entry X1,
   is marked as having N subchannels, but the first subchannel entry
   number is X2, where either N or X2, but not both, is 0.

   A:     $inform

   Message:
   multiplexer_mgr_$CMD: multiplexers may not be manipulated before AS
   initialization.

   S:     as (severity1)

   T:     $run

   M:     An attempt was made to execute the command CMD before the
   answering service was initialized.

   A:     $ignore
   It may be necessary to reenter the command after answering service
   initialization is complete.

   Message:
   multiplexer_mgr_$init: Shutting down initialized multiplexers prior
   to re-initialization.

   S:     as (severity1)

   T:     $run

   M:     Multiplexer management is being reinitialized after some
   multiplexers had been loaded. Such multiplexers will be shut down
   prior to reinitialization.

   A:     $ignore

   Message:
   multiplexer_mgr_$shut: Shutting down all multiplexers.

   S:     as (severity1)

   T:     $run

   M:     If tracing is on, this message appears when multiplexers are
   being shut down as part of system shutdown or when an error was
   encountered during answering service initialization.

   A:     $ignore

   Message:
   multiplexer_mgr_$load_mpx: ERROR. Unable to get a devx for MPX

   S:     as (severity1)

   T:     $run

   M:     An error code (described by ERROR) has been returned from an
   attempt to find the device index ("devx") of the multiplexer named
   MPX.

   A:     $inform

   Message:
   multiplexer_mgr_$load_mpx: ERROR. Unable to initialize MPX.

   S:     as (severity1)

   T:     $run

   M:     An error code (described by ERROR) hs been returned from an
   attempt to initialize the multiplexer named MPX in ring 0.

   A:     $inform

   Message:
   multiplexer_mgr_$load_mpx: ERROR. Unable to load MPX.

   S:     as (severity1)

   T:     $run

   M:     An error (described by ERROR) has prevented the loading of
   the multiplexer named MPX.

   A:     $inform

   Message:
   multiplexer_mgr_$shutdown_mpx: ERROR. Shutting down MPX.

   S:     as (severity1)

   T:     $run

   M:     An error (described by ERROR) has occurred when attempting
   to shut down the multiplexer named MPX.

   A:     $inform

   Message:
   multiplexer_mgr_$shutdown_mpx: ERROR. Unable to dump MPX.

   S:     as (severity1)

   T:     $run

   M:     An error (described by ERROR) has occurred when attempting
   to dump the multiplexer named MPX.

   A:     $inform

   Message:
   multiplexer_mgr_$shutdown_mpx: ERROR. Terminating MPX.CHAN.

   S:     as (severity1)

   T:     $run

   M:     An error (described by ERROR) has occurred while terminating
   the subchannel CHAN of the multiplexer named MPX.

   A:     $inform

   Message:
   multiplexer_mgr_$shutdown_mpx: ERROR. Terminating MPX.

   S:     as (severity1)

   T:     $run

   M:     An error (described by ERROR) has occurred when attempting
   to terminate the multiplexer named MPX.

   A:     $inform

   Message:
   multiplexer_mgr_$start_mpx: ERROR. Can't get devx for MPX.

   S:     as (severity1)

   T:     $run

   M:     An error (described by ERROR) was returned from an attempt
   to get the device index ("devx") for the multiplexer named MPX.

   A:     $inform

   Message:
   multiplexer_mgr_$start_mpx: ERROR. Starting MPX.

   S:     as (severity1)

   T:     $run

   M:     An error (described by ERROR) occurred when attempting to
   start the multiplexer named MPX.

   A:     $inform

   Message:
   multiplexer_mgr_$stop_mpx: ERROR. Can't get devx for MPX.

   S:     as (severity1)

   T:     $run

   M:     An error (described by ERROR) was returned from an attempt
   to get the device index ("devx") for the multiplexer named MPX.

   A:     $inform

   Message:
   multiplexer_mgr_$stop_mpx: ERROR. Unable to stop MPX.

   S:     as (severity1)

   T:     $run

   M:     An error (described by ERROR) occurred when attempting to
   stop the multiplexer named MPX.

   A:     $inform

   Message:
   multiplexer_mgr_$listen_mpx: ERROR. asu_$attach_channel failed MPX.CHAN

   S:     as (severity1)

   T:     $run

   M:     An error was returned by asu_$attach_channel when attempting
   to attach the subchannel CHAN while listening to all subchannels of
   the multiplexer named MPX. This message only appears if tracing is
   on.

   A:     $inform

   Message:
   multiplexer_mgr_$listen_mpx: ERROR. Channel MPX.CHAN listen failed.

   S:     as (severity1)

   T:     $run

   M:     An attempt to listen to the subchannel CHAN of the
   multiplexer MPX encountered an error (described by ERROR).

   A:     $inform

   Message:
   multiplexer_mgr_$mpx_load_failed: ERROR. Trying to shutdown MPX.

   S:     as (severity1)

   T:     $run

   M:     An error (described by ERROR) occurred when attempting to
   shut down the multiplexer named MPX after it had failed to load.

   A:     $inform

   Message:
   multiplexer_mgr_$mpx_crashed: ERROR. Shutting down MPX

   S:     as (severity1)

   T:     $run

   M:     An error (described by ERROR) occurred when attempting to
   shut down the multiplexer named MPX after it had crashed.

   A:     $inform

   Message:
   multiplexer_mgr_$CMD: ERROR. cdt_mgr_$init: INFO

   S:     as (severity0)

   T:     $run

   M:     An error (described by ERROR, with additional information in
   INFO) occurred while trying to get a pointer to the CDT in order to
   execute the command named CMD.

   A:     $inform

   Message:
   multiplexer_mgr_$CMD: ERROR. cdt_mgr_$thread: INFO

   S:     as (severity1)

   T:     $run

   M:     An error (described by ERROR, with additional information in
   INFO) occurred while trying to repair damage to the CDT discovered
   while executing CMD.

   A:     $inform

   Message:
   multiplexer_mgr_$CMD: ERROR. cdt_mgr_$init failed.

   S:     as (severity1)

   T:     $run

   M:     An error (desribed by ERROR) occurred when trying to
   initialize the CDT in preparation for executing CMD.

   A:     $inform

   Message:
   multiplexer_mgr_$CMD: ERROR. cdt_mgr_$thread: INFO

   S:     as (severity3)

   T:     $run

   M:     An error (described by ERROR, with additional information in
   INFO) occurred while trying to repair damage to the CDT discovered
   while executing CMD; the attempt at repair will not be repeated.

   A:     $inform

   Message:
   multiplexer_mgr_$init: ERROR. Unable to perform requested stop_mpx of MPX.

   S:     as (severity1)

   T:     $run

   M:     An attempt to shut down the multiplexer named MPX, while
   reinitializing multiplexer management, encountered an error
   (described by ERROR).

   A:     $inform

   Message:
   multiplexer_mgr_$init: ERROR. From hphcs_$lct_init

   S:     as (severity1)

   T:     $run

   M:     An error (described by ERROR) was returned from
   hphcs_$lct_init while trying to initialize multiplexer management.

   A:     $inform

   Message:
   multiplexer_mgr_$shut: ERROR. Could not shutdown FNP X.

   S:     as (severity1)

   T:     $run

   M:     An error (described by ERROR) occurred when trying to shut
   down the FNP named X during system shutdown or after an error in
   answering service initialization.

   A:     $inform

   Message:
   multiplexer_mgr_$shut: ERROR. Could not shutdown MPX.

   S:     as (severity1)

   T:     $run

   M:     An error (described by ERROR) occurred when trying to shut
   down the multiplexer named MPX during system shutdown or after an
   error in answering service initialization.

   A:     $inform



   END MESSSAGE DOCUMENTATION */
     end multiplexer_mgr_;
