/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

/****^  HISTORY COMMENTS:
  1) change(85-08-07,Swenson), approve(87-07-13,MCR7741),
     audit(87-07-24,Brunelle), install(87-08-04,MR12.1-1055):
     to check for access on "tandd.acs" rather than just "tandd".  Also, to
     log errors received when issuing tandd_attach control order.
  2) change(86-05-13,GJohnson), approve(86-05-13,MCR7387),
     audit(86-05-13,Martinson), install(86-05-14,MR12.0-1055):
     Correct error message documentation.
  3) change(86-06-29,Swenson), approve(87-07-13,MCR7741),
     audit(87-07-24,Brunelle), install(87-08-04,MR12.1-1055):
     Modified to check anstbl.login_server_present before calling
     uc_cleanup_network_dials_ to ensure that the MNA RPQ code is only invoked
     if it is present.
  4) change(86-07-18,Swenson), approve(86-08-13,MCR7512),
     audit(86-08-13,EJSharpe), install(86-09-08,MR12.0-1150):
     Modified to not attempt to logout channels whose service type is not
     normally login-type.
     (Actual change date was 85-07-18)
  5) change(86-07-23,Swenson), approve(86-08-13,MCR7512),
     audit(86-08-13,EJSharpe), install(86-09-08,MR12.0-1150):
     Modified to increase the maximum length of "reason" so entire audit
     message can be displayed.
     (Actual change date was 85-07-23)
  6) change(86-07-23,Swenson), approve(86-08-13,MCR7512),
     audit(86-08-13,EJSharpe), install(86-09-08,MR12.0-1150):
     Modified to require RW access to ACS path before allowing access to
     channels.
     (Actual change date was 85-07-23)
  7) change(86-07-24,Swenson), approve(86-08-13,MCR7512),
     audit(86-08-13,EJSharpe), install(86-09-08,MR12.0-1150):
     Modified to check the dialok attribute for the terminate_dial_out request
     for consistency with all other requests.
     (Actual change date was 85-07-24)
  8) change(86-07-24,Swenson), approve(86-08-13,MCR7512),
     audit(86-08-13,EJSharpe), install(86-09-08,MR12.0-1150):
     Modified to send control messages for all granted requests.
     (Actual change date was 85-07-24)
  9) change(86-07-24,Swenson), approve(86-08-13,MCR7512),
     audit(86-08-13,EJSharpe), install(86-09-08,MR12.0-1150):
     Modified to ensure dial_out requests check the service type of the
     requested channel before attempting to see if it is in use.
     (Actual change date was 85-07-24)
 10) change(86-07-25,Swenson), approve(86-08-13,MCR7512),
     audit(86-08-13,EJSharpe), install(86-09-08,MR12.0-1150):
     Modified to fix various small bugs which prevented correct operation
     during functional testing.
     (Actual change date was 85-07-25)
 11) change(86-07-27,Swenson), approve(86-08-13,MCR7512),
     audit(86-08-13,EJSharpe), install(86-09-08,MR12.0-1150):
     Modified to ensure a channel's access class is correct before using it in
     access calculations.  Also to reset the access class when the channel
     hangs up.
     (Actual change date was 85-07-25)
 12) change(86-10-14,Lippard), approve(85-12-30,MCR7326),
     audit(86-10-27,GDixon), install(86-10-28,MR12.0-1200):
     Modified to use as_request_sender version 2.
 13) change(87-04-03,Parisek), approve(87-07-13,MCR7741),
     audit(87-07-24,Brunelle), install(87-08-04,MR12.1-1055):
     Test for variable size before assigning value to variable to prevent
     stringsize errors.
 14) change(87-04-27,GDixon), approve(87-07-13,MCR7741),
     audit(87-07-24,Brunelle), install(87-08-04,MR12.1-1055):
     Upgraded for change to answer_table.incl.pl1 and user_table_entry.incl.pl1
 15) change(87-06-01,GDixon), approve(87-07-13,MCR7741),
     audit(87-07-24,Brunelle), install(87-08-04,MR12.1-1055):
     Expand aliases in "dial DIAL_ID person.project".
 16) change(87-06-12,GDixon), approve(87-07-13,MCR7741),
     audit(87-07-24,Brunelle), install(87-08-04,MR12.1-1055):
      A) Change to audit all dial actions via as_access_audit_$channel,
         rather than doing some there and some by direct calls to sys_log_.
 17) change(87-06-23,GDixon), approve(87-07-13,MCR7741),
     audit(87-07-24,Brunelle), install(87-08-04,MR12.1-1055):
      A) Correct format of "dial system" audit messages.
      B) Avoid calling as_access_audit_ when no process is associated with
         the operation.
 18) change(88-11-28,Farley), approve(88-12-14,MCR8035),
     audit(89-05-15,Parisek), install(89-05-16,MR12.3-1045):
     Corrected look_for_channel procedure to check for a "no available device"
     error before checking for a "bad access" error.
                                                   END HISTORY COMMENTS */

/* format: style2,indcomtxt,^inddcls,^indattr */

dial_ctl_:
     procedure (P_cdtep, P_dial_qualifier, P_target_person_project, P_code);

/* DIAL_CTL_ - answering service module which handles "dial" preaccess
   commands, user requests to attach, release, dial_out, and tandd_attach
   communications channels. */

/*
   Modified 750117 by PG for dial_qualifiers.
   Modified 750307 by PG for dialing to absentee and daemon processes.
   Modified 750716 by PG to get privileged attach to work.
   Modified 750812 by PG & THVV for cdt.
   Modified 03/18/76 by David Jordan for Auto Call.
   Modified 07/20/76 by D. M. Wells to use new WAIT_DIAL_GRAB cdte state
   Modified 760819 by Roy Planalp to produce special messages for ftp users
   Modified Aug-Sept 1976 by M. Grady and T. Casey to properly dispose of a dialed channel whose master process terminated
   Modified by S.T. Kent Nov-Dec 1976 to add registered dial qualifier facility
   and facility to release a selected dialed channel.
   Modified by D. M. Wells, May, 1977, to fix bug wrt slave channels and to
   improve error messages.
   Modified by Robert Coren, June, 1977, to use new terminal type stuff.
   Modified November 1978 by Larry Johnson to pass devx's in dial messages
   because channel names became longer than 6 characters.
   Modified April 1979 by T. Casey for MR7.0a to eliminate "s" as a synonym for "system" in the dial command.
   Modified April 1979 by Larry Johnson for no_hangup feature of release_channel.
   Modified July 1979 by C. Hornig to properly recognize non-FNP MCS channels.
   Modified September 1979 by Larry Johnson to set terminal types on slave channels.
   Modified November 1980 by Art Beattie to only look for dial out channels on loaded multiplexers and correct
   error messages.
   Modified November 1980 by E.N. Kittlitz for new dialout requests, cleanup and bugfixes.
   Modified March 1981 by Robert Coren for T & D attachments.
   Modified April 1981 by Robert Coren to issue copy_meters order when assigning channel.
   Modified April 1981 by E. N. Kittlitz for cdte.dial_ev_chn.
   Modified November 1981, E. N. Kittlitz.  user_table_entry conversion.
   Modified April 1982, E. N. Kittlitz. New AS initialization.
   Modified July 1982, E. N. Kittlitz. Support MCS channel (un)masking.
   Modified November 1982, E. N. Kittlitz.  don't use masked dial-out channels.
   Modified January 1983, Keith Loepere for generic_destination and so
   priv_attach also scans for suitable channel.
   Modified May 1983, E. N. Kittlitz. required access class support for AIMish stys.
   Modified 831216, E. N. Kittlitz. fix required access class, dial_out, when mux is down.
   Modified 840211, Jeffrey I. Schiller fix required access class for "dial" command.
   Modified 84-04-05 BIM to finish channel AIM, recasting required access class.
   Modified 84-04-20 BIM to add tracing to debug above.
   Modified 1984-09-28 BIM to fix t&d attach, log release, change trace sv.
   Modified 1984-10-03 BIM to use fake_connect protocol for t&d failures.
   Modified 1984-10-04 BIM to use up_sysctl_$check_acs for tandd.acs
   Modified 1984-10-17 by E. Swenson to clean up error reporting and
   logging and, in doing so, audit some events that should be audited.
   Modified 1985-01-23 by E. Swenson for new A.S. auditing.
   Modified 1985-02-19 BIM to clear out user_name on release.
   Modified 1985-04-11 by E. Swenson to fix mangled log message.
*/

/* Parameters */

dcl     P_cdtep ptr parameter;			/* pointer to channel entry for console */
dcl     P_dial_qualifier char (*) parameter;		/* dial qualifier */
dcl     P_target_person_project char (*) parameter;	/* target Person.Project */
dcl     P_code fixed bin (35) parameter;

/* Automatic */

dcl     acs_name char (32);				/* for cheching .acs segs */
dcl     bf fixed bin (71) based;			/* overlay for event msg */
dcl     buffer char (200) aligned;
dcl     1 CAI structure aligned like channel_audit_info automatic;
dcl     cdtx fixed bin;				/* used by find_cdte */
dcl     chn fixed bin (71);				/* event channel */
dcl     code fixed bin (35);				/* error code */
dcl     date char (50);				/* for date_time_ */
dcl     desired_channel char (32);			/* from dsr.channel_name if allowing starnames */
dcl     dial_qualifier char (32);
dcl     dial_out_used_privilege bit (1) aligned;
dcl     1 DSI aligned like dial_server_info automatic;	/* for as_access_audit_ */
dcl     find_person_project bit (1) aligned;
dcl     format char (100) aligned;			/* for connected to system message */
dcl     i fixed bin;				/* counter */
dcl     junk char (8) aligned;
dcl     mcode fixed bin (35);				/* output message */
dcl     added_info char (128);			/* additional info for log messages */
dcl     mode bit (36) aligned;
dcl     phone_data char (32) varying;			/* from dsr.dial_out_destination */
dcl     process_id bit (36) aligned init (""b);
dcl     process_destroyed_flag bit (1) aligned automatic;
dcl     process_group_id char (32) init ("?");
dcl     process_ring fixed bin (3) init (7);
dcl     reason char (256);				/* error message component */
dcl     reason_code fixed bin (35);			/* error code associated with reason */
dcl     request_type fixed bin (17) initial (0);		/* type of request, if any */
dcl     requested_access_class bit (72) aligned;
dcl     retval fixed bin (71);			/* signal to user (see "rv") */
dcl     rq_person char (22);				/* for looking up user */
dcl     rq_project char (9);				/* for looking up user */
dcl     rvp ptr;					/* pointer to retval */
dcl     server_authorization char (100);
dcl     star_channel_name bit (1) aligned;		/* we have a starname channel specification */
dcl     suppress_listen bit (1);
dcl     target_person_project char (32);
dcl     used_privilege bit (1) aligned;
dcl     user_lth fixed bin;
dcl     user_string char (100);
dcl     word char (8) aligned;

dcl     1 term_info like terminal_info;

dcl     1 set_type_info like set_term_type_info;

/* Constant */

dcl     (
        JUST_DIALED bit (15) aligned initial ("77770"b3),
        JUST_HUNGUP bit (15) aligned initial ("77771"b3),
        REQUEST_GRANTED bit (15) aligned initial ("77772"b3),
        REQUEST_DENIED bit (15) aligned initial ("77773"b3)
        ) internal static options (constant);

dcl     ME char (9) init ("dial_ctl_") static options (constant);

declare (
        PRIV_ATTACH init (1),
        DIAL_OUT init (2),
        DIAL_IN init (3),
        T_AND_D init (4)
        ) fixed bin internal static options (constant);

dcl     ATTACHMENT_TYPES (1:4) char (12) internal static options (constant)
	   initial ("priv_attach", "dial_out", "dial_in", "t&d_attach");

dcl     (
        UNKNOWN_RQ initial (0),
        START_DIAL_ID_RQ initial (1),
        STOP_DIAL_ID_RQ initial (2),
        RELEASE_CHN_RQ initial (3),
        PRIV_ATTACH_CHN_RQ initial (4),
        TANDD_ATTACH_CHN_RQ initial (5),
        RELEASE_DIAL_ID_RQ initial (6),
        DIAL_OUT_RQ initial (7),
        TERMINATE_DIAL_OUT_RQ initial (8)
        ) fixed bin (17) internal static options (constant);

dcl     REQUEST_TYPES (0:8) char (20) internal static options (constant)
	   initial ("unknown", "start dial service", "stop dial service", "release channel", "priv attach",
	   "tandd attach", "release dial service", "dial out", "terminate dial out");

dcl     (
        TRUE initial ("1"b),
        FALSE initial ("0"b)
        ) bit (1) aligned internal static options (constant);

/* external static */

dcl     as_error_table_$dialagain fixed bin (35) external;
dcl     as_error_table_$dialup_error fixed bin (35) ext static;
dcl     as_error_table_$dial_connect_msg fixed bin (35) external;
dcl     as_error_table_$dialdied fixed bin (35) external;
dcl     as_error_table_$dialnoline fixed bin (35) external;
dcl     as_error_table_$dialnotup fixed bin (35) external;
dcl     as_error_table_$dial_sys_msg fixed bin (35) external;
dcl     error_table_$action_not_performed fixed bin (35) external static;
dcl     error_table_$ai_restricted fixed bin (35) ext static;
dcl     error_table_$ai_out_range fixed bin (35) static external;
dcl     error_table_$bad_name fixed bin (35) static external;
dcl     error_table_$badstar fixed bin (35) static external;
dcl     error_table_$dial_active fixed bin (35) static external;
dcl     error_table_$dial_id_busy fixed bin (35) static external;
dcl     error_table_$id_not_found fixed bin (35) static external;
dcl     error_table_$insufficient_access fixed bin (35) static external;
dcl     error_table_$invalid_resource_state fixed bin (35) static external;
dcl     error_table_$io_no_permission fixed bin (35) static external;
dcl     error_table_$name_not_found fixed bin (35) static external;
dcl     error_table_$noentry fixed bin (35) ext static;
dcl     error_table_$no_connection fixed bin (35) static external;
dcl     error_table_$no_dialok fixed bin (35) static external;
dcl     error_table_$order_error fixed bin (35) static external;
dcl     error_table_$request_not_recognized fixed bin (35) static external;
dcl     error_table_$request_pending fixed bin (35) external;
dcl     error_table_$resource_attached fixed bin (35) ext static;
dcl     error_table_$resource_not_free fixed bin (35) static external;
dcl     error_table_$resource_unavailable fixed bin (35) static external;
dcl     error_table_$resource_unknown fixed bin (35) static external;
dcl     error_table_$unable_to_check_access fixed bin (35) static external;
dcl     error_table_$undefined_order_request fixed bin (35) static external;
dcl     error_table_$unimplemented_version fixed bin (35) static external;

/* Builtin */

dcl     (addr, addrel, after, before, bit, fixed, float, hbound, lbound, length, low, null, rtrim, string, substr, unspec)
	   builtin;

/* Entries */

dcl     aim_check_$in_range entry (bit (72) aligned, (2) bit (72) aligned) returns (bit (1) aligned);
dcl     aim_check_$equal entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
dcl     aim_check_$greater_or_equal entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
dcl     aim_util_$get_access_class entry (bit (72) aligned) returns (bit (72) aligned);
dcl     as_access_audit_$channel entry (ptr, ptr, ptr, fixed bin, ptr, char (*));
dcl     as_access_audit_$dialid entry (ptr, fixed bin, ptr, char (*));
dcl     as_any_other_handler_ entry (char (*), entry, label, label);
dcl     astty_$tty_changemode entry (ptr, char (*), fixed bin (35));
dcl     astty_$tty_detach entry (ptr, fixed bin, fixed bin (35));
dcl     astty_$tty_force entry (ptr, ptr, fixed bin, fixed bin (35));
dcl     astty_$tty_new_proc entry (ptr, bit (36) aligned, fixed bin (35));
dcl     astty_$tty_order entry (ptr, char (*), ptr, fixed bin (35));
dcl     astty_$tty_state entry (ptr, fixed bin (35));
dcl     asu_$asu_listen entry (ptr, fixed bin (35));
dcl     asu_$find_process entry (bit (36) aligned, fixed bin, ptr);
dcl     asu_$format_ftp_msg entry (char (200) aligned, fixed bin, fixed bin, fixed bin) returns (char (200) aligned);
dcl     asu_$reset_access_class entry (pointer);
dcl     asu_$write_chn_message entry (ptr, fixed bin (35), char (8) aligned, fixed bin (35));
dcl     check_star_name_$entry entry (char (*), fixed bin (35));
dcl     convert_access_class_$to_string_short entry (bit (72) aligned, char (*), fixed bin (35));
dcl     convert_status_code_ entry (fixed bin (35), char (8) aligned, char (100) aligned);
dcl     date_time_$format entry (character (*), fixed binary (71), character (*), character (*))
	   returns (character (250) var);
dcl     display_access_class_ entry (bit (72) aligned) returns (character (32) aligned);
dcl     device_acct_$off entry (fixed bin, char (*) aligned, ptr);
dcl     device_acct_$on entry (fixed bin, char (*) aligned, ptr);
dcl     get_process_access_class_ entry () returns (bit (72) aligned);
dcl     hash_$search entry (ptr, char (*), fixed bin (35), fixed bin (35));
dcl     hcs_$get_user_access_modes
	   entry (char (*), char (*), char (*), fixed bin, bit (36) aligned, bit (36) aligned, fixed bin (35));
dcl     hcs_$wakeup entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
dcl     ioa_$rs entry options (variable);
dcl     ioa_$rsnnl entry options (variable);
dcl     ipc_$drain_chn entry (fixed bin (71), fixed bin (35));
dcl     lg_ctl_$logout_channel entry (ptr, char (*));
dcl     match_star_name_ entry (char (*), char (*), fixed bin (35));
dcl     pathname_ entry (character (*), character (*)) returns (character (168));
dcl     pnt_manager_$admin_get_entry entry (char (*), ptr, fixed bin (35));
dcl     sys_log_ entry options (variable);		/* type to operator */
dcl     sys_log_$error_log entry options (variable);	/* log error using error_table_ code */
dcl     ttt_info_$initial_string entry (char (*), char (*) varying, fixed bin (35));
dcl     ttt_info_$modes entry (char (*), char (*), fixed bin (35));
dcl     uc_cleanup_network_dials_ entry (bit (36) aligned, bit (1) aligned, fixed bin (35));
dcl     up_sysctl_$check_acs entry (char (*), char (*), fixed bin, bit (36) aligned, fixed bin (35));

/* Based */

dcl     1 rv based (rvp) aligned,			/* overlay, for return signal */
	2 chan char (6) unaligned,			/* name of tty dialing, or "contrl" */
	2 control unaligned,
	  3 devx_msg bit (1),			/* indicates rv.chan contains a devx, not a name */
	  3 error_msg bit (1),			/* indicates rv.chan contains an error code, not a name */
	  3 pad bit (1),
	  3 code bit (15);				/* what happened */

/* Static */

dcl     static_trace_sw bit (1) internal static init ("0"b);

/* Conditions */

dcl     any_other condition;
%page;
/* Program */

/* dial_ctl_: procedure (P_cdtep, P_dial_qualifier, P_target_person_project, P_code); */

/**** This entrypoint handles the "dial" preaccess command.  On entry,
      P_cdtep points to the cdte of the channel requesting the dial,
      P_dial_qualifier is the specified dial_id, P_target_person_project,
      if present, is the User_id.Project_id combination. */

	if as_data_$ansp = null
	then return;				/* if not initialized */
	ansp = as_data_$ansp;

	cdtep = P_cdtep;				/* Get pointer to channel giving request */
	dial_qualifier = P_dial_qualifier;		/* copy dial qualifier */
	target_person_project = P_target_person_project;

	utep = null ();				/* initialize so that we don't fault */
	reason_code = 0;
	reason = "";

	if dial_qualifier = ""
	then do;					/* didn't say who */
		call ABORT_DIALIN (as_error_table_$dialnoline, "");
		return;
	     end;

	if static_trace_sw
	then call trace ("(dial_ctl_) Channel ^a Qualifier ^a ^[user ^a^]", cdte.name, dial_qualifier,
		(target_person_project ^= ""), target_person_project);

/**** lg_ctl_ has already blessed this dial as far as the user giving
      the dial request and the channel AIM. cdte.current_access_class
      contains the access class of the dial, which must be consistent
      with that of the receiving process. */

/* Is this an attempt to dial the initializer? */

	if dial_qualifier = "system"
	then do;
/**** The current access class will only be invalid if the check_acs flag
      for dial_in is not on for this channel. */
		if cdte.current_access_class_valid
		then if ^aim_check_$equal (cdte.current_access_class (1), get_process_access_class_ ())
		     then do;
			     call ABORT_DIALIN (error_table_$ai_out_range, "Channel not system_low");
			     return;
			end;

		call convert_status_code_ (as_error_table_$dial_sys_msg, junk, format);
		call ioa_$rs (format, buffer, i,	/* Acknowledge connection. Disclose channel id. */
		     cdte.current_terminal_type, cdte.tty_id_code, cdte.name);
		if cdte.service_type = FTP_SERVICE
		then buffer = asu_$format_ftp_msg (buffer, i, i, 230);
						/* generate FTP msg */
		call astty_$tty_force (cdtep, addr (buffer), i, code);
		if cdte.state < TTY_DIALED
		then do;				/* channel hungup */
			call ABORT_DIALIN (0, "channel hungup");
			return;
		     end;
		P_code = 0;			/* Initializer always accepts dial. */
		dutp = as_data_$dutp;		/* Initializer   */
		utep = addr (dutbl.entry (1));	/* UTE	       */
		cdte.process = utep;
		cdte.in_use = NOW_LOGGED_IN;
		cdte.tra_vec = WAIT_DIAL_RELEASE;	/* Branch to right place if hangup */
		cdte.dialed_to_procid = anstbl.as_procid;
		cdte.dial_ev_chn = -1;		/* This value should never be used */
		cdte.current_service_type = MC_SERVICE; /* TDY Initializer */

/**** Notify operator */

		call sys_log_ (SL_LOG_BEEP, "^a: Channel ^a dialed to Initializer ^[(^a.^a)^]", ME, cdte.name,
		     cdte.flags.access_control.slave_dial, cdte.user_name.person, cdte.user_name.project);

		call DIALIN_OK ();
		return;
	     end;

	if target_person_project ^= ""		/* check for null person.project qualifier */
	then do;					/* resolve this dial by person-project search */
		rq_person = before (target_person_project, ".");
						/* break up person.project */
		rq_project = after (target_person_project, ".");
		if ^convert_aliases (rq_person, rq_project)
		then do;
			call ABORT_DIALIN (as_error_table_$dialnotup, "");
			return;
		     end;
		find_person_project = "1"b;
	     end;
	else find_person_project = "0"b;

	if ^cdte.current_access_class_valid & cdte.flags.access_control.slave_dial
						/* we need an access class, and never got it!? */
	then do;
		call ABORT_DIALIN (as_error_table_$dialup_error,
		     "cdte.current_access_class_valid = ""0""b for channel at dial request time.");
		return;
	     end;

	used_privilege = "0"b;			/* set by next call if comm priv used */

/**** Implicit parameters are find_person_project,
      rq_person, rq_project, dial_qualifier, cdte, ute. ****/

	utep = find_dialable_process ();

	if utep = null
	then do;					/* not found in any user table */
		call ABORT_DIALIN (as_error_table_$dialnotup, "");
		return;				/* User control will give us another chance */
	     end;

	mcode = as_error_table_$dial_connect_msg;	/* Make up nice msg */
	date = date_time_$format ("system_date_time", anstbl.current_time, "system_zone", "system_lang");
	call convert_status_code_ (mcode, junk, format);	/* .. */
	call convert_access_class_$to_string_short (ute.process_authorization, server_authorization, code);
	if server_authorization = ""
	then call ioa_$rsnnl ("^a (^a.^a)", user_string, user_lth, ute.dial_qualifier, ute.person, ute.project);
	else call ioa_$rsnnl ("^a (^a.^a) (^a)", user_string, user_lth, ute.dial_qualifier, ute.person, ute.project,
		server_authorization);
	call ioa_$rs (format, buffer, i, cdte.current_terminal_type, cdte.tty_id_code, user_string, date);
	if cdte.service_type ^= FTP_SERVICE		/* for FTP, server will print out message */
	then call astty_$tty_force (cdtep, addr (buffer), i, code);
						/* write it out */
	if cdte.state < TTY_DIALED
	then do;
		call ABORT_DIALIN (error_table_$io_no_permission, "channel hungup");
		return;
	     end;

	cdte.process = utep;			/* Remember Owner */
	cdte.dialed_to_procid = ute.proc_id;		/* .. */
	cdte.dial_ev_chn = ute.dial_ev_chn;		/* .. */
	ute.ndialed_consoles = ute.ndialed_consoles + 1;

	call DIALIN_OK ();				/* report success */
	call connect_channel_to_user (DIAL_IN, used_privilege);
	P_code = 0;				/* we made it */
	return;
%page;
dial_rq:
     entry (a_request_ptr, a_asr_sender_ptr);

/**** This entry is called to handle the system-wide event channel provided
      for processes that wish to sign on of off as dial servers, or who
      wish to attach or release communications channels. */

/* parameters */

dcl     (a_request_ptr, a_asr_sender_ptr) ptr parameter;
dcl     1 sender_authorization aligned like aim_template;

	on any_other call as_any_other_handler_ (ME, NULL_PROC, REQUEST_RETURNS, REQUEST_RETURNS);

	call SETUP_REQUEST (code);
	if code ^= 0
	then return;

	request_type = UNKNOWN_RQ;			/* we'll set this later */

	if static_trace_sw
	then call trace_request ("dial_rq");

	if dial_server_request.flags.start
	then call start_dial_id_request;
	else if dial_server_request.flags.stop
	then call stop_dial_id_request;
	else if dial_server_request.flags.release_channel
	then call release_channel_request;
	else if dial_server_request.flags.privileged_attach
	then call privileged_attach_request;
	else if dial_server_request.flags.release_dial_id
	then call release_dial_id_request;
	else /* Didn't specify what was to be done. */
	     do;
		call sys_log_ (SL_LOG_SILENT,
		     "^a: Rejected unknown request from ^a.^a.  No request flags set in dial_server_request.", ME,
		     ute.person, ute.project);
		call SEND_ERROR_MESSAGE_AND_REJECT (error_table_$request_not_recognized);
	     end;

	goto REQUEST_RETURNS;
%page;
dial_out_rq:
     entry (a_request_ptr, a_asr_sender_ptr);

/**** This entry is called in reponse to a user-initiated request to
      regarding an autocall (dial_out) channel.  It handles dial_out
      requests as well as release requests. */

	on any_other call as_any_other_handler_ (ME, NULL_PROC, REQUEST_RETURNS, REQUEST_RETURNS);

	call SETUP_REQUEST (code);
	if code ^= 0
	then return;

	if dial_server_request.flags.release_channel
	then request_type = TERMINATE_DIAL_OUT_RQ;
	else request_type = DIAL_OUT_RQ;

	if static_trace_sw
	then call trace_request ("dial_out_rq");

	CAI.valid = FALSE;
	CAI.valid.user_validation_level = TRUE;		/* for auditing */
	CAI.user_validation_level = process_ring;

	call set_desired_channel;			/* check for starname, etc. */
	if reason_code ^= 0
	then call REJECT_CHANNEL_REQUEST (reason_code, reason);

	if dial_server_request.flags.release_channel
	then call terminate_dial_out_request ();
	else call dial_out_request ();

	goto REQUEST_RETURNS;
%page;
dial_term:
     entry (P_cdtep);

/**** This entry is called by dialup_ whenever a dialed console hangs up. */

	if as_data_$ansp = null
	then return;				/* Not initialized */
	ansp = as_data_$ansp;

	cdtep = P_cdtep;
	reason_code = 0;

	if static_trace_sw
	then call trace ("(dial_term) Channel ^a", cdte.name);

	reason = cdte.name;

	chn = cdte.dial_ev_chn;			/* Nice local copies */
	process_id = cdte.dialed_to_procid;		/* ... */

	if process_id = anstbl.as_procid
	then do;					/* Slaved to initializer? */
		reason = "hangup";
		CAI.channel_name = cdte.name;
		CAI.valid = FALSE;
		CAI.valid.service_info = TRUE;
		CAI.service_info = SERVICE_TYPE (cdte.current_service_type);
		CAI.valid.access_class = TRUE;
		if cdte.dialup_flags.current_access_class_valid
		then CAI.access_class = cdte.current_access_class (1);
		else CAI.access_class = get_process_access_class_ ();
		CAI.valid.access_class_range = TRUE;
		CAI.access_class_range = cdte.access_class;
		utep = cdte.process;
		call as_access_audit_$channel (cdtep, null, utep, AS_AUDIT_CHANNEL_DETACH, addr (CAI), reason);
	     end;
	else do;
		utep = cdte.process;		/* Find owner */
		if utep ^= null
		then do;				/* Ignore if terminal did "slave" and then hung up. */
			if ute.proc_id ^= cdte.dialed_to_procid
			then /* Race condition in logout.. note */
			     call sys_log_ (SL_LOG_SILENT,
				"dial_ctl_: Channel ^a (^a, ^a) hung up on missing process ^w", cdte.name,
				SERVICE_TYPE (cdte.current_service_type),
				display_access_class_ (cdte.current_access_class (1)), cdte.dialed_to_procid);
			else do;
				call device_acct_$off ((cdte.charge_type), cdte.name, utep);
						/* Stop charging for device */

				call decrement_ndialed;
						/* reduce ate.ndialed_consoles */
				call SEND_CHANNEL_MESSAGE (JUST_HUNGUP);
				reason = "hangup";

				CAI.channel_name = cdte.name;
				CAI.valid = FALSE;
				CAI.valid.service_info = TRUE;
				CAI.service_info = SERVICE_TYPE (cdte.current_service_type);
				CAI.valid.access_class = TRUE;
				if cdte.dialup_flags.current_access_class_valid
				then CAI.access_class = cdte.current_access_class (1);
				else CAI.access_class = ute.process_authorization;
				CAI.valid.access_class_range = TRUE;
				CAI.access_class_range = cdte.access_class;
				CAI.valid.user_validation_level = TRUE;
				CAI.user_validation_level = process_ring;
				call as_access_audit_$channel (cdtep, null, utep, AS_AUDIT_CHANNEL_DETACH,
				     addr (CAI), reason);
			     end;
		     end;
	     end;

	call meter_dut;				/* metering dialed_up_time */

	if cdte.flags.access_control.slave_dial & cdte.service_type = ANS_SERVICE
	then /* authenticated */
	     call lg_ctl_$logout_channel (cdtep, "hangup");
						/* logout channel */
	cdte.current_service_type = cdte.service_type;	/* Make channel normal again. */
	cdte.dialed_to_procid = "0"b;
	cdte.dial_ev_chn = 0;
	cdte.process = null;

/* Ensure the channel's current access class is reset to the CDT-specified
   default (either a range or single class). */

	call asu_$reset_access_class (cdtep);

	if cdte.state ^= TTY_MASKED
	then call asu_$asu_listen (cdtep, code);
	else cdte.in_use = NOW_HUNG_UP;

	return;
%page;
dial_broom:
     entry (uptr, funct);

/**** This entry is called whenever the master process is destroyed. */

dcl     uptr ptr parameter,				/* Ptr to ate of master process dying */
        funct char (8) aligned parameter;		/* Reason why we are sweeping */

	utep = uptr;
	if as_data_$ansp = null
	then return;
	ansp = as_data_$ansp;

	reason_code = 0;
	reason = "";

	if static_trace_sw
	then call trace ("(dial_broom) User ^a.^a function ^a.", ute.person, ute.project, funct);

	if ute.dial_qualifier ^= ""
	then do;					/* report when a user stops serving */
		DSI.server_ring = ute.dial_server_ring;
		DSI.dial_qualifier = ute.dial_qualifier;
		DSI.privileged = ute.privileged_dial_server;
		DSI.registered = ute.registered_dial_server;
		added_info = funct;
		call as_access_audit_$dialid (utep, AS_AUDIT_DIALID_STOP, addr (DSI), added_info);
		ute.dial_qualifier = "";		/* don't let any more come thru */
	     end;

	ute.registered_dial_server = "0"b;		/* reset to default value */
	ute.privileged_dial_server = "0"b;
	ute.dial_server_ring = 7;

	if ute.ndialed_consoles = 0			/* dont waste time searching the table */
	then return;				/* if there aren't going to be any entries */

	if funct = "new_proc"
	then word = "dialgrab";
	else if substr (funct, 1, 4) = "term"
	then word = "dialgrab";
	else word = "dialhang";

	if word = "dialgrab"
	then mcode = as_error_table_$dialagain;
	else mcode = as_error_table_$dialdied;

	if funct = "stopdial"
	then do;
		reason = "dialid shut off";
		process_destroyed_flag = FALSE;	/* shutoff_dials request */
	     end;
	else do;
		reason = word;			/* for log message */
		process_destroyed_flag = TRUE;
	     end;

	do i = 1 to scdtp -> cdt.current_size;		/* was somebody */
	     cdtep = addr (scdtp -> cdt.cdt_entry (i));
	     if cdte.in_use > NOW_FREE
	     then if cdte.dialed_to_procid = ute.proc_id
		then call release_channel ("1"b, "0"b, (cdte.current_service_type = TANDD_SERVICE), reason);
	end;

	if anstbl.login_server_present
	then call uc_cleanup_network_dials_ (ute.proc_id, process_destroyed_flag, (0));
	ute.ndialed_consoles = 0;			/* we have done our job */
	return;
%page;

REQUEST_RETURNS:					/* return point for a dial_ctl_ request */
	return;

finish_priv_attach:
     entry (a_cdtep);

/**** This entry is called by dialup_ when the channel which has been
      priv_attach'ed finally dials up.  This will only be invoked when
      the channel was not dialed up when the priv_attach was initiated.

      /* parameters */

dcl     a_cdtep ptr parameter;

/* program */

	ansp = as_data_$ansp;
	request_type = PRIV_ATTACH_CHN_RQ;
	cdtep = a_cdtep;
	if static_trace_sw
	then call trace ("(fin_priv_attach) Channel ^a", cdte.name);
	utep = cdte.process;			/* Find Owner */
	reason_code = 0;
	reason = cdte.name;

	process_id = cdte.dialed_to_procid;		/* Initialize on off chance it's used */
	chn = cdte.dial_ev_chn;			/* ... */
	if utep = null
	then do;					/* can't happen unless bug */
woops1:
		call sys_log_ (SL_LOG_SILENT, "dial_ctl_: Can't find process ^12.3b", cdte.dialed_to_procid);
		return;
	     end;
	else if ute.proc_id ^= cdte.dialed_to_procid
	then go to woops1;

/**** Recheck the access. If the channel dialed up, and supplied
      an access class, it might be incompatable with the process. */

	if ^aim_check_process_and_channel (utep, (cdte.dial_ctl_ring), cdte.dial_rq_privileged, PRIV_ATTACH,
	     used_privilege)			/* use ring saved in cdte. */
	then do;
		added_info = "Access check failed after slave dialup";
		call fake_connect_channel_to_user (PRIV_ATTACH, added_info);
		call astty_$tty_order (cdtep, "hangup", null, (0));
		return;
	     end;

	if cdte.service_type ^= ANS_SERVICE
	then do;					/* no metering of login lines */
		cdte.dialup_time = anstbl.current_time;
		cdte.n_logins = cdte.n_logins + 1;
	     end;
	call set_terminal_type;
	call connect_channel_to_user (PRIV_ATTACH, used_privilege);
	return;

continue_tandd_attach:
     entry (a_cdtep);

/**** This entry is called by dialup_ when a channel which is being
      tandd_attach'd hangs up.  The attaching process has been waiting
      for the line to become hung up all this time. */

	request_type = TANDD_ATTACH_CHN_RQ;

	cdtep = a_cdtep;

	if static_trace_sw
	then call trace ("(continue_tandd_attach) Channel ^a", cdte.name);

	reason_code = 0;
	reason = cdte.name;

	call astty_$tty_order (cdtep, "tandd_attach", null, code);
	if code = -1
	then /* Translate silly error code */
	     code = error_table_$io_no_permission;

	if code ^= 0				/* we'd better try to tell him now */
	then do;
		added_info = "tandd_attach control order failed";
		call fake_connect_channel_to_user (T_AND_D, added_info);
		call astty_$tty_order (cdtep, "hangup", null (), (0));
	     end;

	else cdte.tra_vec = WAIT_FIN_TANDD_ATTACH;	/* channel should now signal dialup, */
	return;					/* at which point we will hand it to user */

finish_tandd_attach:
     entry (a_cdtep);

/**** This entry is called by dialup_ when a terminal which has been
      tandd_attach'd simulates a dialup. */

	request_type = TANDD_ATTACH_CHN_RQ;
	cdtep = a_cdtep;

	if static_trace_sw
	then call trace ("(finish_tandd_attach) Channel ^a", cdte.name);

	utep = cdte.process;			/* Find Owner */
	process_id = cdte.dialed_to_procid;		/* Initialize on off chance it's used */
	chn = cdte.dial_ev_chn;			/* ... */
	if utep = null
	then do;					/* can't happen unless bug */
tandd_error:
		call sys_log_ (SL_LOG_SILENT, "dial_ctl_: Can't find process ^12.3b", cdte.dialed_to_procid);
		return;
	     end;
	else if ute.proc_id ^= cdte.dialed_to_procid
	then go to tandd_error;
	call connect_channel_to_user (T_AND_D, "0"b);
	return;
%page;
finish_dial_out:
     entry (a_cdtep);

/**** This entry is called by dialup_ when a wakeup is received indicating
      completion (successful or otherwise) of a dial_out control order
      previously issued for the channel. */

	request_type = DIAL_OUT_RQ;

	ansp = as_data_$ansp;
	cdtep = a_cdtep;

	if static_trace_sw
	then call trace ("(finish_dial_out) Channel ^a", cdte.name);
	reason_code = 0;
	reason = cdte.name;

	utep = cdte.process;			/* get ate pointer */
	process_id = cdte.dialed_to_procid;		/* Initialize on off chance it's used */
	chn = cdte.dial_ev_chn;			/* ... */
	if utep = null ()
	then do;
whoops2:
		call sys_log_ (SL_LOG_SILENT, "dial_ctl_: Can't find process ^12.3b", cdte.dialed_to_procid);
		return;
	     end;
	else if ute.proc_id ^= cdte.dialed_to_procid
	then go to whoops2;

	call astty_$tty_order (cdtep, "dial_out_status", null (), code);
	if code ^= 0
	then call DIAL_OUT_CHANNEL_ERROR ();		/* Doesn't return */
	cdte.in_use = NOW_DIALED_OUT;			/* record that channel is dialed up */
	call set_terminal_type;
	term_info.version = terminal_info_version;
	call astty_$tty_order (cdtep, "terminal_info", addr (term_info), code);
	if code ^= 0
	then call DIAL_OUT_CHANNEL_ERROR ();		/* doesn't return */
	cdte.current_terminal_type = term_info.term_type; /* Store info in CDTE for this channel */
	cdte.tty_id_code = term_info.id;		/* .. */
	if cdte.flags.autobaud
	then /* if it can change, then save it */
	     cdte.baud_rate = term_info.baud_rate;

	cdte.n_logins = cdte.n_logins + 1;
	cdte.dialup_time = anstbl.current_time;
	call connect_channel_to_user (DIAL_OUT, dial_out_used_privilege);
	return;

trace_on:
     entry;

	static_trace_sw = "1"b;
	call sys_log_ (SL_LOG, "dial_ctl_: Tracing turned on.");
	return;

trace_off:
     entry;

	static_trace_sw = "0"b;
	call sys_log_ (SL_LOG, "dial_ctl_: Tracing turned off.");
	return;
%page;
start_dial_id_request:
     procedure ();

/**** Internal procedure to handle requests to sign on as dial servers */

	request_type = START_DIAL_ID_RQ;

/**** Set up info for auditing record */
	DSI.dial_qualifier = dial_server_request.dial_qualifier;
	DSI.server_ring = process_ring;
	DSI.privileged = dial_server_request.flags.privileged_server;
	DSI.registered = dial_server_request.flags.registered_server;

	if ^(ute.at.dialok)
	then call REJECT_DIALID_REQUEST (error_table_$no_dialok, "User lacks dialok attribute");

	if dial_server_request.flags.privileged_server & ^(sender_authorization.privileges.comm | (process_ring = 1))
	then do;
		call ioa_$rsnnl ("process lacks comm priv for privileged service of ^a.", reason, (0),
		     dial_server_request.dial_qualifier);
		call REJECT_DIALID_REQUEST (error_table_$ai_restricted, reason);
	     end;

	if ute.dial_qualifier ^= ""
	     &
	     /* active and not a request for the same thing? */ (ute.dial_qualifier
	     ^= dial_server_request.dial_qualifier
	     | ute.registered_dial_server ^= dial_server_request.registered_server)
	then do;					/* no can do */
		call ioa_$rsnnl ("process already serving ^a^[ (registered)^], can't serve ^a.", reason, (0),
		     ute.dial_qualifier, ute.registered_dial_server, dial_server_request.dial_qualifier);
		call REJECT_DIALID_REQUEST (error_table_$dial_active, reason);
	     end;
	if dial_server_request.flags.registered_server
	then do;
		if ^check_acs ("dial." || dial_server_request.dial_qualifier, process_group_id, process_ring)
		then do;
			call ioa_$rsnnl ("process lacks access to registered dial acs for ^a.", reason, (0),
			     dial_server_request.dial_qualifier);
			if reason_code = error_table_$noentry
			then reason_code = error_table_$name_not_found;
			call REJECT_DIALID_REQUEST (reason_code, reason);
		     end;
		if ^aim_check_registered_server_namedup (reason_code)
		then do;
			call ioa_$rsnnl ("another process is registered dial server for ^a.", reason, (0),
			     dial_server_request.dial_qualifier);
			call REJECT_DIALID_REQUEST (reason_code, reason);
		     end;
		ute.registered_dial_server = "1"b;
	     end;

	else /* request is for non-registered qualifier */
	     ute.registered_dial_server = "0"b;
	ute.privileged_dial_server = dial_server_request.privileged_server;

	ute.dial_ev_chn = chn;			/* Save dial event channel */
	ute.dial_qualifier = dial_server_request.dial_qualifier;
	ute.dial_server_ring = process_ring;

	if ute.registered_dial_server
	then do;
		added_info = "(registered";
		if ute.privileged_dial_server
		then added_info = rtrim (added_info) || " privileged";
		added_info = rtrim (added_info) || ")";
	     end;
	else if ute.privileged_dial_server
	then added_info = "(privileged)";
	else added_info = "";

	call as_access_audit_$dialid (utep, AS_AUDIT_DIALID_START, addr (DSI), added_info);

	call SEND_CONTROL_MESSAGE (bit (fixed (ute.ndialed_consoles, 15), 15));
	return;
     end start_dial_id_request;
%page;
stop_dial_id_request:
     procedure;

/**** Request to stop serving a dial id and to disconnect all channels
      dialed to this process. */

	request_type = STOP_DIAL_ID_RQ;

	DSI.dial_qualifier = dial_server_request.dial_qualifier;
	DSI.server_ring = ute.dial_server_ring;
	DSI.registered = ute.registered_dial_server;
	DSI.privileged = ute.privileged_dial_server;

	if ^(ute.at.dialok)
	then call REJECT_DIALID_REQUEST (error_table_$no_dialok, "User lacks dialok attribute");

	if ute.dial_qualifier ^= ""
	then /* actively serving anything? */
	     if ((ute.dial_qualifier = dial_server_request.dial_qualifier) | (dial_server_request.dial_qualifier = ""))
	     then do;
		     call dial_broom (utep, "stopdial");/* Remove all slaves */
		     call SEND_CONTROL_MESSAGE (""b);
		end;
	     else do;
		     reason = "Dial id not in use by this process";
		     call REJECT_DIALID_REQUEST (0, reason);
		end;
	else do;
		reason = "No dial id in use by this process";
		call REJECT_DIALID_REQUEST (0, reason);
	     end;
	call SEND_CONTROL_MESSAGE (bit (fixed (ute.ndialed_consoles, 15), 15));
     end stop_dial_id_request;
%page;
release_dial_id_request:
     procedure;

/**** Release a dial id such that future attempts to dial a console to this
      dial id will fail.  All consoles already dialed to this dial id, however
      will remain dialed. */

	request_type = RELEASE_DIAL_ID_RQ;

	DSI.dial_qualifier = dial_server_request.dial_qualifier;
	DSI.server_ring = ute.dial_server_ring;
	DSI.privileged = ute.privileged_dial_server;
	DSI.registered = ute.registered_dial_server;

	if ^(ute.at.dialok)
	then call REJECT_DIALID_REQUEST (error_table_$no_dialok, "User lacks dialok attribute");

	if ute.dial_qualifier ^= ""
	then /* actively serving anything? */
	     if ((ute.dial_qualifier = dial_server_request.dial_qualifier) | (dial_server_request.dial_qualifier = ""))
	     then do;
		     added_info = "dialid released";

		     if ute.ndialed_consoles ^= 0
		     then call ioa_$rsnnl ("^a (keeping ^d dialed console^[s^])", added_info, (0), added_info,
			     ute.ndialed_consoles, (ute.ndialed_consoles ^= 1));

		     call as_access_audit_$dialid (utep, AS_AUDIT_DIALID_STOP, addr (DSI), added_info);
		     ute.dial_qualifier = "";		/* back to default */
		     ute.registered_dial_server = "0"b; /* also default */
		end;
	     else do;
		     added_info = "Dial id not in use by this process";
		     call REJECT_DIALID_REQUEST (0, reason);
		end;
	else do;
		added_info = "No dial id in use by this process";
		call REJECT_DIALID_REQUEST (0, reason);
	     end;

	call SEND_CONTROL_MESSAGE (bit (fixed (ute.ndialed_consoles, 15), 15));
	return;
     end release_dial_id_request;
%page;
release_channel_request:
     procedure;					/* Request to release a channel */

	request_type = RELEASE_CHN_RQ;

	CAI.channel_name = dial_server_request.channel_name;
						/* for auditing */
	CAI.valid = FALSE;
	CAI.valid.user_validation_level = TRUE;
	CAI.user_validation_level = process_ring;

	if ^(ute.at.dialok)
	then call REJECT_CHANNEL_REQUEST (error_table_$no_dialok, "User lacks dialok attribute");

	if dial_server_request.channel_name = ""
	then do;					/* frequent problem */
		reason = "Null channel name specified";
		call REJECT_CHANNEL_REQUEST (0, reason);
	     end;

	call find_cdte;				/* try to find channel */
	if cdtep = null
	then do;					/* Channel doesn't exist.  Error code set by find_cdte. */
		call ioa_$rsnnl ("Channel ^a not found.", reason, (0), dial_server_request.channel_name);
		call REJECT_CHANNEL_REQUEST (reason_code, reason);
	     end;

	if cdte.dialed_to_procid ^= process_id
	then do;					/* Channel not his */
		reason = "Channel not attached to this process";
		call REJECT_CHANNEL_REQUEST (error_table_$io_no_permission, reason);
	     end;

	call decrement_ndialed;			/* one less... */
	if cdte.current_service_type = TANDD_SERVICE	/* was this in T & D service? */
	then suppress_listen = dial_server_request.flags.no_listen;
						/* then he's allowed to specify this */
	else suppress_listen = "0"b;
	call release_channel ("0"b, dial_server_request.flags.no_hangup, suppress_listen, "release");
						/* actual release */
	call SEND_CONTROL_MESSAGE (REQUEST_GRANTED);
	return;
     end release_channel_request;
%page;
privileged_attach_request:
     procedure ();

	if dial_server_request.flags.tandd_attach
	then request_type = TANDD_ATTACH_CHN_RQ;
	else request_type = PRIV_ATTACH_CHN_RQ;

	CAI.channel_name = dial_server_request.channel_name;
	CAI.valid = FALSE;
	CAI.valid.user_validation_level = TRUE;		/* for auditing */
	CAI.user_validation_level = process_ring;

	if ^(ute.at.dialok)
	then call REJECT_CHANNEL_REQUEST (error_table_$no_dialok, "User lacks dialok attribute");

	call set_desired_channel;
	if reason_code ^= 0
	then call REJECT_CHANNEL_REQUEST (reason_code, reason);

	reason = dial_server_request.channel_name;	/* assume the worst */

	if dial_server_request.flags.tandd_attach
	then call look_for_channel (T_AND_D);		/* and check access */
	else call look_for_channel (PRIV_ATTACH);

	CAI.channel_name = cdte.name;			/* update this in case starname was used */
	CAI.valid.access_class = cdte.dialup_flags.current_access_class_valid;
	CAI.access_class = cdte.current_access_class (1);
	CAI.valid.access_class_range = TRUE;
	CAI.access_class_range = cdte.access_class;

	if dial_server_request.tandd_attach		/* both acs's needed */
	then do;
		call up_sysctl_$check_acs ("tandd.acs", process_group_id, (process_ring), mode, code);
		if code ^= 0 | ((mode & RW_ACCESS) ^= RW_ACCESS)
		then do;
			if code ^= 0
			then call sys_log_$error_log (SL_LOG_SILENT, code,
				"dial_ctl_: Could not check access to ^a>tandd.acs for ^a.", as_data_$acsdir,
				process_group_id);
			call ioa_$rsnnl ("rw access is required to ^a", reason, (0),
			     pathname_ (as_data_$acsdir, "tandd.acs"));
			call REJECT_CHANNEL_REQUEST (error_table_$insufficient_access, reason);
		     end;
	     end;

	cdte.process = utep;			/* remember owner */
	cdte.dial_ev_chn = chn;			/* .. */
	cdte.dialed_to_procid = ute.proc_id;		/* .. */
	cdte.dial_ctl_ring = process_ring;		/* remember for FIN_PRIV_ATTACH access check. */
	cdte.dial_rq_privileged = sender_authorization.privileges.comm;
	ute.ndialed_consoles = ute.ndialed_consoles + 1;

	if ^dial_server_request.tandd_attach
	then if cdte.service_type ^= ANS_SERVICE
	     then /* no metering for login lines */
		cdte.n_dialups = cdte.n_dialups + 1;

	code = 0;

	call SEND_CONTROL_MESSAGE (REQUEST_GRANTED);

	if dial_server_request.flags.tandd_attach
	then do;
		if cdte.state ^= TTY_HUNG		/* have to make it stop listening */
		then do;
			if static_trace_sw
			then call trace ("(priv_attach) Hanging up ^a for T&D", cdte.name);
			call astty_$tty_order (cdtep, "hangup", null, (0));
			cdte.tra_vec = WAIT_TANDD_HANGUP;
			goto REQUEST_RETURNS;
		     end;

		else do;
			if static_trace_sw
			then call trace ("(priv_attach) ^a hung up, tandd attaching.", cdte.name);
			call astty_$tty_order (cdtep, "tandd_attach", null, code);
			if code ^= 0
			then do;
				call sys_log_$error_log (SL_LOG_SILENT, code,
				     "^a: Issuing tandd_attach control order for channel ^a.", ME, cdte.name);
				added_info = "tandd_attach control order failed";
				call fake_connect_channel_to_user (T_AND_D, added_info);
				call astty_$tty_order (cdtep, "hangup", null (), (0));
				goto REQUEST_RETURNS;
			     end;

			cdte.tra_vec = WAIT_FIN_TANDD_ATTACH;
			goto REQUEST_RETURNS;
		     end;
	     end;
	else do;
		if cdte.state = TTY_DIALED
		then do;
			if cdte.service_type ^= ANS_SERVICE
			then do;			/* not 'slave' pre-access */
				cdte.dialup_time = anstbl.current_time;
				cdte.n_logins = cdte.n_logins + 1;
			     end;
			call set_terminal_type;
			call connect_channel_to_user (PRIV_ATTACH, used_privilege);
						/* Is dialed, give it away */
		     end;
		else cdte.tra_vec = WAIT_FIN_PRIV_ATTACH;
						/* Wait for it to dialup */
	     end;

	return;
     end privileged_attach_request;
%page;
dial_out_request:
     procedure ();

/**** User request to dial out on a specified channel. */

	CAI.channel_name = dial_server_request.channel_name;
	CAI.valid = FALSE;
	CAI.valid.user_validation_level = TRUE;
	CAI.user_validation_level = process_ring;

	if ^(ute.at.dialok)				/* Must have the dialok attribute */
	then call REJECT_CHANNEL_REQUEST (error_table_$no_dialok, "User does not have dialok attribute");

	call set_requested_channel_access_class ();	/* find an appropriate channel, access-class wise */
	if reason_code ^= 0
	then call REJECT_CHANNEL_REQUEST (reason_code, reason);

	dial_out_used_privilege = used_privilege;	/* save the global since look_for_channel will zero it */
	phone_data = rtrim (dial_server_request.dial_out_destination);

	call look_for_channel (DIAL_OUT);		/* star scan for likely channel.  It will reject request if none found. */

	CAI.channel_name = cdte.name;			/* update in case starname was used */
	CAI.valid.access_class = cdte.dialup_flags.current_access_class_valid;
	CAI.access_class = cdte.current_access_class (1);
	CAI.valid.access_class_range = TRUE;
	CAI.access_class_range = cdte.access_class;

/**** The one place we SPECIFY the access class with a set order! */

	call set_dial_out_channel_access_class (reason_code);
	if reason_code ^= 0
	then call REJECT_CHANNEL_REQUEST (reason_code, "set_required_access_class failed");

	cdte.in_use = NOW_DIALING;			/* remember what we're doing ... */
	cdte.tra_vec = WAIT_DIAL_OUT;			/* and what to do next */

	CAI.valid.service_info = TRUE;
	CAI.service_info = phone_data;
	if dial_out_used_privilege
	then reason = "using comm privilege";
	else reason = "";

	call as_access_audit_$channel (cdtep, null, utep, AS_AUDIT_CHANNEL_DIALOUT, addr (CAI), reason);

	call astty_$tty_order (cdtep, "dial_out", addr (phone_data), code);
						/* start dialing */
	if code ^= 0
	then do;
		if code = -1
		then code = error_table_$io_no_permission;
		call sys_log_$error_log (0, code, ME, "after dial_out order (^a for ^a.^a).", cdte.name, ute.person,
		     ute.project);
		cdte.in_use = NOW_HUNG_UP;
		cdte.tra_vec = WAIT_SLAVE_REQUEST;
		call REJECT_CHANNEL_REQUEST (error_table_$order_error, "dial_out control order failed");
	     end;

	cdte.process = utep;			/*  looks like we can give it away... */
	cdte.dial_ctl_ring = process_ring;		/* record ring of dialer */
	cdte.dialed_to_procid = ute.proc_id;		/* .. */
	cdte.dial_ev_chn = chn;			/* remember IPC channel in request */
	cdte.n_dialups = cdte.n_dialups + 1;		/* keep track of how often we try dialing */
	ute.ndialed_consoles = ute.ndialed_consoles + 1;

	call SEND_CONTROL_MESSAGE (REQUEST_GRANTED);
	return;

     end dial_out_request;
%page;
terminate_dial_out_request:
     procedure ();

/**** User request to detach a dialed out channel. */

	CAI.channel_name = dial_server_request.channel_name;
	CAI.valid = FALSE;
	CAI.valid.user_validation_level = TRUE;
	CAI.user_validation_level = process_ring;

	if ^(ute.at.dialok)				/* Must have the dialok attribute */
	then call REJECT_CHANNEL_REQUEST (error_table_$no_dialok, "User does not have dialok attribute");

	if dial_server_request.channel_name = ""
	then do;
		reason = "Invalid channel specified";
		call REJECT_CHANNEL_REQUEST (0, reason);
	     end;

	call find_cdte;				/* find the channel */
	if cdtep = null
	then do;					/* No such channel.  Error code set by find_cdte. */
		call ioa_$rsnnl ("Channel ^a does not exist.", reason, (0), dial_server_request.channel_name);
		call REJECT_CHANNEL_REQUEST (reason_code, reason);
	     end;

	CAI.valid.access_class = cdte.dialup_flags.current_access_class_valid;
	CAI.access_class = cdte.current_access_class (1);
	CAI.valid.access_class_range = TRUE;
	CAI.access_class_range = cdte.access_class;

	if cdte.current_service_type ^= DIAL_OUT_SERVICE
	then do;					/* Channel not a dialed out */
		reason = "Channel not currently dialed out";
		call REJECT_CHANNEL_REQUEST (error_table_$action_not_performed, reason);
	     end;

	if cdte.dialed_to_procid ^= ute.proc_id
	then do;					/* Channel not his */
		reason = "Channel not currently dialed out for this process";
		call REJECT_CHANNEL_REQUEST (error_table_$io_no_permission, reason);
	     end;

	cdte.tra_vec = WAIT_DIAL_RELEASE;		/* make sure we  do the right thing */
	cdte.dial_ev_chn = chn;			/* user's dial_manager_ is blocked on this channel */
						/* which MIGHT be different than cdte.dial_ev_chn */

	call asu_$reset_access_class (cdtep);
	call astty_$tty_order (cdtep, "hangup", null, (0));
						/* drop connection to channel */
	call SEND_CONTROL_MESSAGE (REQUEST_GRANTED);
	return;
     end terminate_dial_out_request;
%page;
connect_channel_to_user:
     procedure (P_attachment_type, report_privilege);

/**** connect_channel_to_user vs fake_connect_channel_to_user:
      In the fake case, we want to issue a hangup.  It's simpler all around
      if we can just pretend that we gave the channel to the user, but don't
      actually tell the dim to new_proc.  We do everything else, including
      sending the dialed-up wakeup.  (The user 'has' to be prepared for
      a dialup wakeup resulting in io_no_permission because the channel
      has already hung up by the time he acts on the dialup.) */

dcl     P_attachment_type fixed bin (17) parameter;
dcl     P_added_info char (*) parameter;
dcl     fake_connect bit (1) aligned;
dcl     report_privilege bit (1) aligned parameter;

/* connect_channel_to_user: procedure (); */

	fake_connect = "0"b;
	go to connect_join;

fake_connect_channel_to_user:
     entry (P_attachment_type, P_added_info);

	fake_connect = "1"b;

connect_join:
	if P_attachment_type = DIAL_IN
	then cdte.current_service_type = DIAL_SERVICE;
	else if P_attachment_type = T_AND_D
	then do;
		cdte.current_service_type = TANDD_SERVICE;
		cdte.tra_vec = WAIT_DISCARD_WAKEUPS;
		cdte.in_use = NOW_HUNG_UP;
	     end;

	if cdte.current_service_type ^= TANDD_SERVICE
	then do;
		cdte.tra_vec = WAIT_DIAL_RELEASE;	/* Catch terminal when it hangs up */
		cdte.in_use = NOW_DIALED;		/* record the fact that we have channel */
	     end;

	call astty_$tty_order (cdtep, "copy_meters", null (), (0));

/* Set up for auditing */

	CAI.channel_name = cdte.name;
	CAI.valid = FALSE;
	CAI.valid.service_info = TRUE;
	CAI.service_info = ATTACHMENT_TYPES (P_attachment_type);
	CAI.valid.access_class = cdte.dialup_flags.current_access_class_valid;
	CAI.access_class = cdte.current_access_class (1);
	CAI.valid.access_class_range = TRUE;
	CAI.access_class_range = cdte.access_class;
	CAI.valid.user_validation_level = TRUE;
	CAI.user_validation_level = process_ring;

	if ^fake_connect
	then do;					/* we're really giving it to the user */

		call astty_$tty_new_proc (cdtep, ute.proc_id, code);
						/* give channel to user */
		if code = 0
		then do;
			if report_privilege
			then added_info = "using comm privilege";
			else added_info = "";

			call as_access_audit_$channel (cdtep, null, utep, AS_AUDIT_CHANNEL_ATTACH, addr (CAI),
			     added_info);
		     end;
		else call sys_log_$error_log (SL_LOG_SILENT, code, ME,
			"call to astty_$tty_new_proc of ^a for ^a.^a failed", cdte.name, ute.person, ute.project);
	     end;
	else /* audit denied attachment */
	     call as_access_audit_$channel (cdtep, null, utep, -AS_AUDIT_CHANNEL_ATTACH, addr (CAI), P_added_info);

/**** Start charging for attached device */

	call device_acct_$on ((cdte.charge_type), cdte.name, utep);

/**** Notify user */

	call SEND_CHANNEL_MESSAGE (JUST_DIALED);
	return;

     end connect_channel_to_user;
%page;
look_for_channel:
     procedure (operation);

/**** Internal procedure to scan cdt for channels that meet requirements
      such as star name match, baud desired, etc. */

dcl     found bit (1) aligned;
dcl     found_device_available bit (1) aligned;
dcl     found_in_cdt bit (1) aligned;
dcl     found_good_access bit (1) aligned;
dcl     found_good_attributes bit (1) aligned;
dcl     operation fixed bin;

	cdtep = null ();
	found, found_device_available, found_in_cdt, found_good_access, found_good_attributes = "0"b;

	reason_code = 0;

	do i = 1 to scdtp -> cdt.current_size while (^found);
	     cdtep = addr (scdtp -> cdt.cdt_entry (i));
	     found = cdte_matches_desired ();		/* try for match */
	     found_in_cdt = found_in_cdt | found;	/* remember if it were ever there */
	     if found
	     then do;				/* keep checking */
		     if dial_server_request.baud_rate ^= -1
		     then /* any baud_rate, or ... */
			if dial_server_request.baud_rate ^= cdte.baud_rate
			then found = "0"b;
		     if dial_server_request.line_type >= lbound (line_types, 1)
		     then /* any line type, or ... */
			if dial_server_request.line_type ^= cdte.line_type
			then found = "0"b;
		     found_good_attributes = found_good_attributes | found;
		end;
	     if found
	     then if dial_server_request.flags.privileged_attach
		then found = check_priv_attach_access ();
		else found = check_dial_access ();
	     found_device_available = found_device_available | found;
	     if found
	     then found =
		     access_check_channel_and_process (utep, process_ring, sender_authorization.privileges.comm,
		     operation, used_privilege);
	     found_good_access = found_good_access | found;
	end;

	if ^found
	then do;					/* need more codes */
		cdtep = null ();			/* for auditing */
		if star_channel_name | reason_code = 0
		then /* if non-star channel and have error code, keep it */
		     if ^found_in_cdt
		     then reason_code = error_table_$resource_unknown;
		     else if ^found_good_attributes
		     then reason_code = error_table_$resource_unavailable;
		     else if ^found_device_available
		     then reason_code = error_table_$resource_unavailable;
		     else if ^found_good_access
		     then reason_code = error_table_$insufficient_access;
		     else if reason_code = 0
		     then reason_code = error_table_$resource_unavailable;
		call REJECT_CHANNEL_REQUEST (reason_code, desired_channel);
	     end;
     end look_for_channel;
%page;
set_terminal_type:
     procedure ();

/**** Procedure to set a terminal type */

dcl     code fixed bin (35);
dcl     tab_string char (512) var;
dcl     modes_string char (512);

	if cdte.initial_terminal_type = ""
	then return;
	if cdte.initial_terminal_type = low (length (cdte.initial_terminal_type))
	then return;
	sttip = addr (set_type_info);
	set_term_type_info.version = stti_version_1;
	set_term_type_info.name = cdte.initial_terminal_type;
	string (set_term_type_info.flags) = "0"b;
	call astty_$tty_order (cdtep, "set_term_type", sttip, code);
	if code ^= 0
	then return;

	cdte.current_terminal_type = set_term_type_info.name;

	call ttt_info_$initial_string (cdte.current_terminal_type, tab_string, code);
	if code ^= 0
	then go to end_initial_string;
	if length (tab_string) ^= 0
	then do;
		call astty_$tty_changemode (cdtep, "rawo", code);
		if code ^= 0
		then go to end_initial_string;
		call astty_$tty_force (cdtep, addrel (addr (tab_string), 1), length (tab_string), code);
	     end;
end_initial_string:
	call ttt_info_$modes (cdte.current_terminal_type, modes_string, code);
	if code ^= 0
	then return;
	call astty_$tty_changemode (cdtep, "force,init," || rtrim (modes_string), code);
	return;

     end set_terminal_type;
%page;
release_channel:
     procedure (master_destroyed, suppress_hangup, suppress_listen, P_reason);

/**** Procedure to release a channel that was dialed to a dial server
      process */

dcl     master_destroyed bit (1);
dcl     suppress_hangup bit (1);
dcl     suppress_listen bit (1);
dcl     was_tandd bit (1);
dcl     P_reason char (*) parameter;			/* reason we are detaching channel */

	if cdte.current_service_type = DIAL_SERVICE & master_destroyed
	then call asu_$write_chn_message (cdtep, mcode, junk, code);

	call astty_$tty_detach (cdtep, 0, code);	/* Take channel away from user */
	if code ^= 0
	then call sys_log_$error_log (0, code, ME, "Attempting to detach ^a from ^a.^a.", cdte.name, ute.person,
		ute.project);
	else do;
		call ioa_$rsnnl ("^a ^[(without hangup)^]^[(without listen)^]", added_info, (0), P_reason,
		     suppress_hangup, suppress_listen);

		CAI.channel_name = cdte.name;
		CAI.valid = FALSE;
		CAI.valid.service_info = TRUE;
		CAI.service_info = SERVICE_TYPE (cdte.current_service_type);
		CAI.valid.access_class = cdte.dialup_flags.current_access_class_valid;
		CAI.access_class = cdte.current_access_class (1);
		CAI.valid.access_class_range = TRUE;
		CAI.access_class_range = cdte.access_class;
		CAI.valid.user_validation_level = TRUE;
		CAI.user_validation_level = process_ring;
		call as_access_audit_$channel (cdtep, null, utep, AS_AUDIT_CHANNEL_DETACH, addr (CAI), added_info);
	     end;

	call device_acct_$off ((cdte.charge_type), cdte.name, utep);
	call meter_dut ();				/* meter dialed_up_time */
	call asu_$reset_access_class (cdtep);		/* Place back in known state */

	if cdte.current_service_type = TANDD_SERVICE	/* restore correct service type */
	then do;
		if suppress_listen			/* channel out of service for the moment */
		then cdte.current_service_type = INACTIVE;
		else cdte.current_service_type = cdte.service_type;
		was_tandd = "1"b;
	     end;
	else do;
		cdte.current_service_type = cdte.service_type;
		was_tandd = "0"b;
	     end;

	cdte.dialed_to_procid = "0"b;
	cdte.dial_ev_chn = 0;
	cdte.process = null;
	cdte.user_name = "";

	if cdte.service_type = ANS_SERVICE & ^was_tandd
	then do;					/* if this is normally an answering service channel */
		cdte.in_use = NOW_DIALED;		/* treat this situation as if it were a logout -hold */
		cdte.tra_vec = WAIT_GREETING_MSG;	/* tell dialup_ what to do (say hello and wait for login) */
		word = "device";			/*  send simulated device wakeup to dialup_ */
		call hcs_$wakeup (anstbl.as_procid, cdte.event, addr (word) -> bf, code);
	     end;
	else if ^suppress_hangup
	then do;					/* not A.S. channel; hang it up */
hangup_anyway:
		call astty_$tty_order (cdtep, "hangup", null, (0));
		cdte.in_use = NOW_HUNG_UP;		/* remember that we did */
		call astty_$tty_state (cdtep, code);	/* see if it is hung up yet */
		if cdte.state > TTY_HUNG
		then /* not yet */
		     cdte.tra_vec = WAIT_HANGUP;	/* wait for it; dialup_ listens after it happens */
		else do;				/* channel is already hung up */
			call ipc_$drain_chn (cdte.event, code);
						/* so discard the hangup wakeup, which would
						   just confuse dialup_ if it came along later */
			if ^suppress_listen & cdte.state ^= TTY_MASKED
			then call asu_$asu_listen (cdtep, code);
						/* and do the listen immediately */
			else if cdte.tra_vec = WAIT_FIN_TANDD_ATTACH
						/* we don't want to leave it like this */
			then cdte.tra_vec = WAIT_SLAVE_REQUEST;
						/* good enough till the next time someone wants it */
		     end;
	     end;
	else do;
		call astty_$tty_state (cdtep, code);
		if cdte.state = TTY_DIALED
		then cdte.tra_vec = WAIT_SLAVE_REQUEST;
		else go to hangup_anyway;
	     end;

	return;

     end release_channel;
%page;
find_cdte:
     procedure ();

	do cdtx = 1 to scdtp -> cdt.current_size;
	     cdtep = addr (scdtp -> cdt.cdt_entry (cdtx));
	     if cdte.name = dial_server_request.channel_name
	     then return;
	end;

	cdtep = null ();
	reason = dial_server_request.channel_name;
	reason_code = error_table_$resource_unknown;

	return;

     end find_cdte;
%page;
/**** These next two answer the question of whether a channel
      is available for a given purpose. access_check_process_and_channel
      check the accessability. */

check_dial_access:
     proc returns (bit (1) aligned);

	reason_code = 0;
	if (cdte.twx = 0) | (cdte.current_service_type = INACTIVE) | (cdte.state = TTY_MASKED)
	then reason_code = error_table_$resource_unavailable;
	else if cdte.process = utep
	then reason_code = error_table_$resource_attached;
	else if cdte.current_service_type ^= DIAL_OUT_SERVICE
	then reason_code = error_table_$invalid_resource_state;
	else if cdte.in_use ^= NOW_HUNG_UP
	then reason_code = error_table_$resource_not_free;
	else do;
		if cdte.threads.mother > 0
		then /* now see what mommy has been up to */
		     mpxep = addr (scdtp -> cdt.cdt_entry (cdte.mother).initial_command);
						/* find her diary */
		else mpxep = addr (scdtp -> cdt.fnp_entry (-cdte.mother).mpxe);
		if mpxe.state ^= FNP_UP
		then reason_code = error_table_$resource_unavailable;
						/* oh, hi mom! */
	     end;
	return (reason_code = 0);

     end check_dial_access;

check_priv_attach_access:
     proc returns (bit (1) aligned);

	reason_code = 0;
	if cdte.in_use = NOW_FREE
	then reason_code = error_table_$resource_unavailable;
	else if cdte.process = utep
	then reason_code = error_table_$resource_attached;
	else if cdte.process ^= null
	then reason_code = error_table_$resource_not_free;
	else if cdte.current_service_type ^= SLAVE_SERVICE & ^dial_server_request.flags.tandd_attach
	then reason_code = error_table_$invalid_resource_state;
	return (reason_code = 0);

     end check_priv_attach_access;
%page;
access_check_channel_and_process:
     procedure (a_utep, attach_ring, privileged, operation, a_used_privilege) returns (bit (1) aligned);

declare a_utep pointer;
declare a_used_privilege bit (1) aligned;
declare privileged bit (1) unaligned;
declare operation fixed bin;
declare attach_ring fixed bin (3);

	if static_trace_sw
	then call trace (
		"(access_check) Channel: ^a User: ^a.^a Utep: ^p Ring: ^d Operation: ^[PRIV_ATTACH^;DIAL_OUT^;DIAL_IN^;T_AND_D^]",
		cdte.name, a_utep -> ute.person, a_utep -> ute.project, a_utep, attach_ring, operation);

	if ^aim_check_process_and_channel (a_utep, attach_ring, privileged, operation, a_used_privilege)
	then do;
		reason_code = error_table_$ai_restricted;
		return ("0"b);
	     end;

	if (operation = PRIV_ATTACH & cdte.flags.access_control.priv_attach)
	     | (operation = DIAL_IN & cdte.flags.access_control.dial_server)
	     | (operation = DIAL_OUT & cdte.flags.access_control.dial_out)
	     | (operation = T_AND_D & cdte.flags.access_control.priv_attach)
	then return (check_acs ((cdte.name), make_group_id (a_utep), attach_ring));
	else return ("1"b);
     end access_check_channel_and_process;
%page;
aim_check_process_and_channel:
     procedure (a_utep, attach_ring, privileged, operation, a_used_privilege) returns (bit (1) aligned);

declare a_utep pointer;
declare attach_ring fixed bin (3);
declare privileged bit (1) unaligned;
declare a_used_privilege bit (1) aligned;
declare operation fixed bin;
dcl     access_class_ok bit (1) aligned automatic;

	if static_trace_sw
	then call trace (
		"(aim_check) Channel: ^a User: ^a.^a Utep: ^p Ring: ^d^[ Privileged^] Operation: ^[PRIV_ATTACH^;DIAL_OUT^;DIAL_IN^;T_AND_D^]",
		cdte.name, a_utep -> ute.person, a_utep -> ute.project, a_utep, attach_ring, privileged, operation);



	a_used_privilege = "0"b;

/* Make sure the current access class information is valid. */

	if ^cdte.current_access_class_valid
	then do;
		call INITIALIZE_CURRENT_ACCESS_CLASS (code);
		if code ^= 0
		then return (FALSE);		/* not altogether true, however */
	     end;

	if /* tree */ (operation = DIAL_OUT)
	then if ^cdte.current_access_class_valid	/* range */
	     then access_class_ok = (aim_check_$in_range (requested_access_class, cdte.access_class));
	     else access_class_ok = (aim_check_$equal (requested_access_class, cdte.current_access_class (1)));
						/* We already validated requested_a_c */
	else if ^cdte.current_access_class_valid
	     then if privileged
		then access_class_ok =
			(
			aim_check_$greater_or_equal (a_utep -> ute.process_authorization_range (2),
			cdte.access_class (2)));
		else access_class_ok = (aim_check_$in_range (a_utep -> ute.process_authorization, cdte.access_class));
	     else if privileged
		then access_class_ok =
			(
			aim_check_$greater_or_equal (a_utep -> ute.process_authorization_range (2),
			cdte.current_access_class (1)));
		else access_class_ok =
			(aim_check_$equal (a_utep -> ute.process_authorization, cdte.current_access_class (1)));

	if access_class_ok
	then /* ok to use this channel */
	     return (TRUE);
	else do;					/* not ok, reset access class information */
		call asu_$reset_access_class (cdtep);
		return (FALSE);
	     end;

     end aim_check_process_and_channel;
%page;
aim_check_registered_server_namedup:
     procedure (code) returns (bit (1) aligned);

/**** This procedure is used to enforce the AIM rules for servers.
      There can only be one server per dial_id per access class.
      This is because we have no way to register a dial_id as having
      AIM characteristics. A privileged server serves from system_low
      up to their authorization. A privileged server is defined as one
      established with the comm privilege enabled. If a server is privileged
      the fact is recorded in ute.privileged_dial_server.

      Since processes can (foolishly) turn off their comm privilege
      after becoming privileged registered servers, we can have cases
      where no server can serve a dial request, even though some server
      claims to be serving the territory. This is because both
      ute.privileged_dial_server & the comm privilege must be on
      for the dialing in channel to find the process. */

declare code fixed bin (35);
declare i fixed bin;
declare P ptr;


	do i = 1 to anstbl.current_size;		/* check for user */
	     P = addr (anstbl.entry (i));

	     if consider_ute ()
	     then return ("0"b);			/* found a conflict */
	end;

/* Now check the daemon user table */

	do i = 1 to dutbl.current_size;		/* check for user */
	     P = addr (dutbl.entry (i));
	     if consider_ute ()
	     then return ("0"b);
	end;

/* Now check the absentee user table */

	do i = 1 to autbl.current_size;		/* check for user */
	     P = addr (autbl.entry (i));
	     if consider_ute ()
	     then return ("0"b);

	end;
	return ("1"b);

consider_ute:
     procedure returns (bit (1) aligned);

declare existing_priv_range (2) bit (72) aligned;
declare proposed_priv_range (2) bit (72) aligned;

	existing_priv_range (1) = ""b;		/* system_low */
	existing_priv_range (2) = P -> ute.process_authorization;
	proposed_priv_range (1) = ""b;		/* system_low */
	proposed_priv_range (2) = unspec (sender_authorization);

	if P -> ute.dial_ev_chn = 0
	then return ("0"b);				/* no conflict */
	if ^P -> ute.registered_dial_server
	then return ("0"b);
	if P -> ute.dial_qualifier ^= dial_server_request.dial_qualifier
	then return ("0"b);				/* no conflict */

	if P -> ute.privileged_dial_server		/* system_low --> ute.p_a */
	then do;
		if dial_server_request.privileged_server/* request for priv server */
		then
REJECT_AIM:
		     do;
			code = error_table_$dial_id_busy;
			return ("1"b);
		     end;
		else if aim_check_$in_range (unspec (sender_authorization), existing_priv_range)
		then go to REJECT_AIM;
		else return ("0"b);			/* outside claimed range */
	     end;
	else do;					/* existing server is single level */
		if (dial_server_request.privileged_server
		     & aim_check_$in_range (P -> ute.process_authorization, proposed_priv_range))
		     | (^dial_server_request.privileged_server
		     & aim_check_$equal (P -> ute.process_authorization, unspec (sender_authorization)))
		then go to REJECT_AIM;
	     end;
	return ("0"b);
     end consider_ute;
     end aim_check_registered_server_namedup;
%page;
check_acs:
     procedure (check_name, user_name, user_ring) returns (bit (1) aligned);

/* general procedure to check access on an ACS */

dcl     check_name char (*);
dcl     user_name char (*);
dcl     user_ring fixed bin (3);

	acs_name = check_name;
	reason_code = 0;
	acs_name = rtrim (acs_name, " ") || ".acs";

	call hcs_$get_user_access_modes (as_data_$rcpdir, acs_name, user_name, (user_ring), mode, ""b, code);

	if code ^= 0
	then do;
		if code = error_table_$noentry
		then reason_code = error_table_$insufficient_access;
		else reason_code = error_table_$unable_to_check_access;
		reason = acs_name;
	     end;
	else if (mode & RW_ACCESS) ^= RW_ACCESS
	then reason_code = error_table_$insufficient_access;
	if static_trace_sw
	then call trace_error (reason_code, "(check_acs) ACS: ^a USER: ^a, RING: ^d", acs_name, user_name, user_ring);
	return (reason_code = 0);

     end check_acs;
%page;
/* internal procedures and functions for channel starname handling */

set_desired_channel:
     proc;					/* expand dsr.channel_name */

	if dial_server_request.channel_name = ""
	then do;					/* default null string */
		desired_channel = "**";
		code = 2;
	     end;
	else do;					/* make sure it's a valid name */
		desired_channel = dial_server_request.channel_name;
		call check_star_name_$entry (desired_channel, code);
		if code = error_table_$badstar
		then do;
			reason_code = error_table_$bad_name;
						/* badstar message doesn't scan */
			reason = desired_channel;
		     end;
	     end;
	CAI.channel_name = desired_channel;		/* for auditing */
	star_channel_name = code ^= 0;		/* any star-convention stuff? */
     end set_desired_channel;
%page;
set_requested_channel_access_class:
     procedure ();

	used_privilege = "0"b;
	requested_access_class = aim_util_$get_access_class (unspec (sender_authorization));
						/* until set otherwise */
	if dial_server_request.flags.access_class_specified
	     & ^aim_check_$equal (unspec (sender_authorization), dial_server_request.access_class)
	then do;					/* User requested dial-out at privileged auth */
		if ^sender_authorization.privileges.comm
		then do;
			reason_code = error_table_$insufficient_access;
			reason = "process lacks comm privilege for privileged dial-out";
			return;
		     end;


		if ^aim_check_$greater_or_equal (ute.process_authorization_range (2),
		     dial_server_request.access_class)
		then do;
			reason_code = error_table_$ai_out_range;
			reason = "requested authorization is greater than maximum authorizaton";
			return;
		     end;
		requested_access_class = dial_server_request.access_class;
		used_privilege = "1"b;
	     end;
	else reason_code = 0;			/* no auth requested or same as process auth */

     end set_requested_channel_access_class;
%page;
cdte_matches_desired:
     proc () returns (bit (1) aligned);			/* check cdte channel with desired_channel */

	if ^star_channel_name
	then /* must match exactly, then */
	     if cdte.name = desired_channel
	     then return ("1"b);
	     else if cdte.generic_destination_present
	     then if addr (cdte.initial_command) -> generic_destination = desired_channel
		then return ("1"b);
	call match_star_name_ ((cdte.name), desired_channel, code);
						/* does it fit the pattern? */
	if code ^= 0
	then if cdte.generic_destination_present
	     then call match_star_name_ (addr (cdte.initial_command) -> generic_destination, desired_channel, code);
						/* does channel_desired match a channel alias? */
	return (code = 0);				/* code 0 indicates match */
     end cdte_matches_desired;
%page;
set_dial_out_channel_access_class:
     procedure (code);

declare code fixed bin (35);

	code = 0;

	call asu_$reset_access_class (cdtep);		/* since we own it, we are responsable for setting it into a reasonable state. */
	if cdte.current_access_class_valid
	then return;

	call astty_$tty_order (cdtep, "set_required_access_class", addr (requested_access_class), code);
	if code = -1				/* Channel hung up */
	then code = error_table_$io_no_permission;

	if code = error_table_$io_no_permission
	then return;				/* Let caller decide what to do */
	else if code ^= 0
	then do;
		if code = error_table_$undefined_order_request
		then do;
			code = error_table_$resource_unavailable;
						/* mis-configured */
			call sys_log_ (SL_LOG_BEEP,
			     "dial_ctl_: Autocall channel ^a declared multi-class, but does not support set_required_access_class.",
			     cdte.name);
		     end;
	     end;
	else do;
		cdte.current_access_class (*) = requested_access_class;
		cdte.current_access_class_valid = "1"b;
	     end;
	return;
     end set_dial_out_channel_access_class;

decrement_ndialed:
     procedure ();

	if ute.ndialed_consoles <= 0
	then do;
		ute.ndialed_consoles = 0;
		call sys_log_ (SL_LOG_SILENT, "dial_ctl_: ndialed negative ^a", ute.tty_name);
	     end;
	else ute.ndialed_consoles = ute.ndialed_consoles - 1;
     end decrement_ndialed;

make_group_id:
     procedure (a_utep) returns (char (32));

declare a_utep pointer;
declare group_id char (32);

	group_id = "";
	call ioa_$rsnnl ("^[anonymous^s^;^a^].^a.^a", group_id, (0), (a_utep -> ute.anonymous = 1),
	     a_utep -> ute.person, a_utep -> ute.project, a_utep -> ute.tag);
	return (group_id);
     end make_group_id;
%page;
meter_dut:
     procedure ();					/* meter dialed_up_time */

	if cdte.service_type ^= ANS_SERVICE
	then /* not 'dial' or 'slave' */
	     cdte.dialed_up_time =
		cdte.dialed_up_time + float (anstbl.current_time - cdte.dialup_time, 63) / 1e6 + .5e0;

     end meter_dut;
%page;
convert_aliases:
     procedure (rq_person, rq_project) returns (bit (1));

dcl     rq_person char (22);
dcl     rq_project char (9);

dcl     code fixed bin (35);
dcl     satx fixed bin (35);

	call pnt_manager_$admin_get_entry (rq_person, addr (pnte), code);
	if code = error_table_$id_not_found
	then return (FALSE);
	else if code ^= 0
	then do;
		call sys_log_$error_log (SL_LOG_BEEP, code, ME, "Can't find PNT entry: ^a", rq_person);
		return (FALSE);
	     end;
	else rq_person = substr (pnte.user_id, 1, length (rq_person));

	if rq_project = ""
	then rq_project = substr (pnte.default_project, 1, length (rq_project));
	else do;
		call hash_$search (as_data_$sat_htp, rq_project, satx, code);
		if code ^= 0
		then return (FALSE);
		satp = as_data_$satp;
		satep = addr (sat.project (satx));
		if rq_project ^= project.project_id
		then if rq_project ^= project.alias
		     then do;
			     call sys_log_ (SL_LOG_BEEP, "^a: sat.ht has ""^a"", sat has ""^a"" at ^p", rq_project,
				project.project_id, satep);
			     return (FALSE);
			end;
		rq_project = substr (project.project_id, 1, length (rq_project));
	     end;

	return (TRUE);
     end convert_aliases;

%page;
find_dialable_process:
     procedure returns (pointer);

/**** internal procedure to scan table (answer_table, daemon_user_table, or
      absentee_user_table) and set utep to ptr to entry which matches all
      criteria for dialing.

      Implicit parameters are find_person_project, rq_person, rq_project,
      dial_qualifier, cdte, and utep.

      We expect that at any site where system_high > system_low that
      flags.access_control.slave_dial will be on. This will force lg_ctl_
      to force the user typing the dial request to specify an access
      class in case one was not specified be the communications medium.

      If that flag is on, and cdte.current_access_class_valid is off,
      then there is a bug someplace.

      If that flag is off, and cdte.current_access_class_valid is off,
      then the user simple didn't bother to type -user on the dial
      request. We then require the channel range to include the
      process authorization, though we don't recommend this trick. */

dcl     i fixed bin;
dcl     P ptr;


	ansp = as_data_$ansp;
	do i = 1 to anstbl.current_size;		/* check for user */
	     P = addr (anstbl.entry (i));

	     if consider_ute ()
	     then return (P);
	end;

/* Now check the daemon user table */

	dutp = as_data_$dutp;
	do i = 1 to dutbl.current_size;		/* check for user */
	     P = addr (dutbl.entry (i));
	     if consider_ute ()
	     then return (P);
	end;

/* Now check the absentee user table */

	autp = as_data_$autp;
	do i = 1 to autbl.current_size;		/* check for user */
	     P = addr (autbl.entry (i));
	     if consider_ute ()
	     then return (P);

	end;
	return (null);				/* not found */

consider_ute:
     procedure returns (bit (1) aligned);

	if P -> ute.active ^= NOW_HAS_PROCESS
	then return ("0"b);


	if static_trace_sw
	then if P -> ute.dial_ev_chn ^= 0
	     then call trace (
		     "(find_dialable_process) UTE: name ^a.^a qualifier ^a ^[registered_dial_server^] ^[dialok^] dial_server_ring ^d",
		     P -> ute.person, P -> ute.project, P -> ute.dial_qualifier, P -> ute.registered_dial_server,
		     P -> ute.at.dialok, P -> ute.dial_server_ring);

	if find_person_project			/* see if we want to match by person-project */
	then do;
		if P -> ute.person ^= rq_person
		then return ("0"b);

		if P -> ute.project ^= rq_project
		then return ("0"b);
	     end;

	if ^find_person_project & ^(P -> ute.registered_dial_server)
						/* ^ person.project implies registered server */
	then return ("0"b);


	if P -> ute.dial_qualifier ^= dial_qualifier
	then /* wrong one, or none registered */
	     return ("0"b);

	if ^(P -> ute.at.dialok)
	then /* Is master allowed to have dials? */
	     return ("0"b);

	if P -> ute.dial_ev_chn = 0
	then /* Is master accepting dials? */
	     return ("0"b);

	/*** AIM and ACS checks as explained above */
	/*** Note that dialup_ checked -user NAME against acs. */

	if ^access_check_channel_and_process (P, (P -> ute.dial_server_ring), P -> ute.privileged_dial_server, DIAL_IN,
	     ("0"b))				/* code uninteresting, since we just skip */
	then return ("0"b);

	return ("1"b);

     end consider_ute;

     end find_dialable_process;
%page;
SETUP_REQUEST:
     procedure (code);

dcl     code fixed bin (35) parameter;


	if as_data_$ansp = null
	then do;
		code = 1;				/* Not used, except to check against 0. */
		return;
	     end;
	ansp = as_data_$ansp;
	dutp = as_data_$dutp;
	autp = as_data_$autp;

	request_ptr = a_request_ptr;
	as_request_sender_ptr = a_asr_sender_ptr;

	if as_request_sender.version ^= AS_REQUEST_SENDER_VERSION_2
	then do;
		call sys_log_ (SL_LOG,
		     "dial_ctl_: Program error.  as_request_sender.version (^d) not correct in dial request.  Should be ^d.",
		     as_request_sender.version, AS_REQUEST_SENDER_VERSION_2);
		code = 1;
		return;
	     end;

	process_group_id = as_request_sender.group_id;
	process_id = as_request_sender.process_id;
	process_ring = as_request_sender.validation_level;
	unspec (sender_authorization) = as_request_sender.authorization;

	reason_code = 0;
	reason = "";

	chn = dial_server_request.header.reply_channel;	/* use this channel temporarily */

	if dial_server_request.version ^= dial_server_request_version_4
	then call SEND_ERROR_MESSAGE_AND_REJECT (error_table_$unimplemented_version);

	chn = dial_server_request.dial_control_channel;	/* stop using dsr.header.reply_channel */

/**** Note that at this point, chn could be zero if it was not specified
      in the dial_server_request structure.  We interpret this to mean
      that the user is not interested in any responses from us. */

	call asu_$find_process (process_id, i, utep);	/* locate caller's ate */
	if utep = null ()
	then do;
		call sys_log_ (SL_LOG_SILENT, "dial_ctl_: Can't find process ^12.3b", process_id);
		call SEND_CONTROL_MESSAGE (REQUEST_DENIED);
		goto REQUEST_RETURNS;
	     end;

	cdtep = null ();				/* until we find a channel */
	code = 0;
	return;

     end SETUP_REQUEST;
%page;
DIAL_OUT_CHANNEL_ERROR:
     procedure ();

	if cdte.in_use = NOW_DIALED_OUT
	then do;					/* check for error after dial_out */
		call astty_$tty_order (cdtep, "hangup", null (), (0));
						/* make sure line is hungup, ignore code */
	     end;
	if code = -1
	then call sys_log_ (SL_LOG_SILENT, "dial_ctl_: Channel ^a hung up after dial_out for ^a.^a.", cdte.name,
		ute.person, ute.project);
	else if code = error_table_$request_pending | code = error_table_$undefined_order_request
	then call sys_log_$error_log (0, code, ME, "getting dial_out_status or tty info (^a for ^a.^a).", cdte.name,
		ute.person, ute.project);
	else call sys_log_$error_log (0, code, ME, "dial_out (^a for ^a.^a) failed.", cdte.name, ute.person,
		ute.project);

	cdte.process = null ();			/* cleanup the cdte */
	cdte.dialed_to_procid = (36)"0"b;
	cdte.dial_ev_chn = 0;
	call decrement_ndialed;			/* reduce ate.ndialed_consoles */
	cdte.in_use = NOW_HUNG_UP;

/**** We now set the tra_vec so that when the hangup wakeup comes in we
      will go to the dial_ctl_$dial_term entry. */

	cdte.tra_vec = WAIT_DIAL_RELEASE;

	call REJECT_CHANNEL_REQUEST (error_table_$no_connection, "error in dialing out");
     end DIAL_OUT_CHANNEL_ERROR;
%page;
REJECT_CHANNEL_REQUEST:
     procedure (code, why);

dcl     code fixed bin (35);
dcl     why char (*);

	if code = 0
	then /* default error message */
	     code = error_table_$action_not_performed;

	call convert_status_code_ (code, junk, format);
	reason = rtrim (format) || " " || why;

	CAI.valid.service_info = TRUE;
	CAI.service_info = REQUEST_TYPES (request_type);
	if (request_type = PRIV_ATTACH_CHN_RQ | request_type = TANDD_ATTACH_CHN_RQ)
	then call as_access_audit_$channel (cdtep, null, utep, -AS_AUDIT_CHANNEL_ATTACH, addr (CAI), reason);
	else if request_type = DIAL_OUT_RQ
	then do;
		CAI.valid.service_info = FALSE;
		call as_access_audit_$channel (cdtep, null, utep, -AS_AUDIT_CHANNEL_DIALOUT, addr (CAI), reason);
	     end;
	else if (request_type = RELEASE_CHN_RQ | request_type = TERMINATE_DIAL_OUT_RQ)
	then call as_access_audit_$channel (cdtep, null, utep, -AS_AUDIT_CHANNEL_DETACH, addr (CAI), reason);
	else call sys_log_ (SL_LOG_SILENT, "dial_ctl_: Refused unknown request from ^a.^a; ^a ^a", ute.person,
		ute.project, format, why);

	call SEND_ERROR_MESSAGE_AND_REJECT (code);	/* Doesn't return */
     end REJECT_CHANNEL_REQUEST;
%page;
REJECT_DIALID_REQUEST:
     procedure (code, why);

dcl     code fixed bin (35);
dcl     why char (*);

	if code = 0
	then /* default error message */
	     code = error_table_$action_not_performed;

	call convert_status_code_ (code, junk, format);
	reason = rtrim (format) || " " || why;

	if request_type = START_DIAL_ID_RQ
	then call as_access_audit_$dialid (utep, -AS_AUDIT_DIALID_START, addr (DSI), reason);
	else if request_type = STOP_DIAL_ID_RQ | request_type = RELEASE_DIAL_ID_RQ
	then call as_access_audit_$dialid (utep, -AS_AUDIT_DIALID_STOP, addr (DSI), reason);
	else call sys_log_ (SL_LOG_SILENT, "dial_ctl_: Refused unknown request from ^a.^a; ^a ^a", ute.person,
		ute.project, format, why);

	call SEND_ERROR_MESSAGE_AND_REJECT (code);	/* Doesn't return */
     end REJECT_DIALID_REQUEST;
%page;
SEND_ERROR_MESSAGE_AND_REJECT:
     procedure (code);

/**** This internal procedure informs the requesting process of the error
      and then does a non-local return to abort the request. */

dcl     code fixed bin (35);
dcl     1 rv_message_error aligned based (addr (rv.chan)),	/* how we return a full error code */
	2 error_code fixed bin (35);			/* normal error code */

	if chn ^= 0
	then do;
		rvp = addr (retval);
		unspec (rv) = ""b;
		rv.error_msg = "1"b;		/* Indicate return of error code to sender */
		rv_message_error.error_code = code;	/* set error using other overlay */
		call hcs_$wakeup (process_id, chn, retval, (0));
	     end;
	goto REQUEST_RETURNS;

     end SEND_ERROR_MESSAGE_AND_REJECT;
%page;
SEND_CHANNEL_MESSAGE:
     procedure (message);

dcl     message bit (15) aligned parameter;
dcl     1 rv_chan unal based (addr (rv.chan)),		/* overlay 6 character rv.chan field */
	2 devx fixed bin (17) unal,
	2 line_type bin (17) unal,
	2 pad fixed bin (17) unal;

	rvp = addr (retval);
	unspec (rv) = ""b;
	rv_chan.devx = cdte.twx;
	rv_chan.line_type = cdte.line_type;

	rv.devx_msg = "1"b;
	rv.control.code = message;
	call hcs_$wakeup (cdte.dialed_to_procid, cdte.dial_ev_chn, retval, (0));
	return;

     end SEND_CHANNEL_MESSAGE;
%page;
SEND_CONTROL_MESSAGE:
     procedure (message);

dcl     message bit (15) aligned parameter;

	if chn ^= 0
	then do;
		rvp = addr (retval);
		unspec (rv) = ""b;
		rv.chan = "contrl";			/* Tell user this is control message */
		rv.control.code = message;
		call hcs_$wakeup (process_id, chn, retval, (0));
	     end;
	return;

     end SEND_CONTROL_MESSAGE;
%page;
SERVICE_TYPE:
     procedure (type) returns (character (10) varying);

dcl     type fixed bin (17) unaligned;
dcl     type_names (9) character (10) varying
	   initial ("as", "ftp", "mc", "slave", "dial", "dial_out", "inactive", "mpx", "tandd");

	if type < lbound (type_names, 1) | type > hbound (type_names, 1)
	then return ("?");
	else return (type_names (type));
     end SERVICE_TYPE;
%page;
trace_request:
     procedure (caller);

declare caller char (32);
declare auth char (32) aligned;
declare access_class_string char (32) aligned;

	auth = display_access_class_ (as_request_sender.authorization);
	access_class_string = display_access_class_ (dial_server_request.access_class);
	call trace ("(^a) group_id: ^a process_id: ^w ring: ^d auth: ^a ^[comm priv^]", caller,
	     as_request_sender.group_id, as_request_sender.process_id, as_request_sender.validation_level, auth,
	     addr (as_request_sender.authorization) -> aim_template.privileges.comm);
	call trace (
	     "^5xQualifier: ^a Channel: ^a Destination: ^a Baud: ^d line_type: ^d server_type: ^a Access_class: ^a",
	     dial_server_request.dial_qualifier, dial_server_request.channel_name,
	     dial_server_request.dial_out_destination, dial_server_request.baud_rate, dial_server_request.line_type,
	     dial_server_request.server_type, access_class_string);

	call trace (
	     "^5x^[ start^]^[ stop^]^[ privileged_attach^]^[ release_channel^]^[ registered_server^]^[ no_hangup^]^[ release_dial_id^]^[ tandd_attach^]^[ no_listen^]^[ access_class_specified^]",
	     dial_server_request.start, dial_server_request.stop, dial_server_request.privileged_attach,
	     dial_server_request.release_channel, dial_server_request.registered_server, dial_server_request.no_hangup,
	     dial_server_request.release_dial_id, dial_server_request.tandd_attach, dial_server_request.no_listen,
	     dial_server_request.access_class_specified);
	return;
     end trace_request;

trace:
     procedure options (variable);

declare ioa_$general_rs
	   entry (pointer, fixed binary, fixed binary, character (*), fixed binary (21), bit (1) aligned,
	   bit (1) aligned);
declare cu_$arg_ptr entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
declare cu_$arg_list_ptr entry returns (pointer);

declare ioa_buffer char (1000);
declare code_flag bit (1) aligned;
declare code fixed bin (35) based (code_ptr);
declare code_ptr pointer;
declare (first, control) fixed bin;

	code_flag = "0"b;
	go to COMMON;

trace_error:
     entry options (variable);

	code_flag = "1"b;

COMMON:
	if code_flag
	then do;
		call cu_$arg_ptr (1, code_ptr, (0), (0));
		control = 2;
		first = 3;
	     end;
	else do;
		control = 1;
		first = 2;
	     end;

	call ioa_$general_rs (cu_$arg_list_ptr (), control, first, ioa_buffer, (0), "1"b, "0"b);
						/* pad, but don't NL */

	if code_flag
	then call sys_log_$error_log (SL_LOG_SILENT, code, "dial_ctl_", "^a", ioa_buffer);
	else call sys_log_ (SL_LOG_SILENT, "dial_ctl_: ^a", ioa_buffer);
	return;
     end trace;
%page;
ABORT_DIALIN:
     procedure (P_ec, P_reason);

dcl     P_ec fixed bin (35) parameter;
dcl     P_reason char (*) parameter;

dcl     action fixed bin (17);
dcl     code_reason char (150) varying;
dcl     code_reason_al char (100) aligned;

	if P_ec = 0
	then code_reason = P_reason;
	else do;
		call convert_status_code_ (P_ec, (""), code_reason_al);
		code_reason = rtrim(code_reason_al);
		if P_reason ^= "" 
		then do;
		          code_reason = code_reason || ", ";
			code_reason = code_reason || rtrim(P_reason);
		     end;
	     end;

	if utep ^= null ()
	then do;

		CAI.channel_name = cdte.name;
		CAI.valid = FALSE;
		CAI.valid.access_class = cdte.dialup_flags.current_access_class_valid;
		CAI.access_class = cdte.current_access_class (1);
		CAI.valid.access_class_range = TRUE;
		CAI.access_class_range = cdte.access_class;
		CAI.valid.user_validation_level = TRUE;
		CAI.user_validation_level = ute.initial_ring;

		if dial_qualifier = "system"
		then do;
			action = -AS_AUDIT_CHANNEL_DIAL_SYSTEM;
		     end;
		else do;
			action = -AS_AUDIT_CHANNEL_DIALIN;
			CAI.valid.service_info = TRUE;
			CAI.service_info = dial_qualifier;
		     end;

		call as_access_audit_$channel (cdtep, null, utep, action, addr (CAI), (code_reason));
	     end;
	else call sys_log_ (SL_LOG_SILENT,
	         "DIALIN DENIED^20t^[^a.^a^;^s^s^] ^a to ^a ^[(^a)^]",
		cdte.flags.access_control.slave_dial, cdte.user_name.person, cdte.user_name.project, cdte.name,
		dial_qualifier, (code_reason ^= ""), code_reason);

	cdte.process = null ();
	cdte.dialed_to_procid = ""b;
	cdte.dial_ev_chn = 0;

	if P_ec ^= 0
	then P_code = P_ec;				/* export this error code */
	else P_code = as_error_table_$dialnotup;	/* default error message */

	return;

     end ABORT_DIALIN;
%page;
DIALIN_OK:
     procedure ();

dcl     action fixed bin (17);

	CAI.channel_name = cdte.name;
	CAI.valid = FALSE;
	CAI.valid.access_class = TRUE;
	if cdte.dialup_flags.current_access_class_valid
	then CAI.access_class = cdte.current_access_class (1);
	else CAI.access_class = ute.process_authorization;
	CAI.valid.access_class_range = TRUE;
	CAI.access_class_range = cdte.access_class;
	CAI.valid.user_validation_level = TRUE;
	CAI.user_validation_level = ute.initial_ring;

	if dial_qualifier = "system"
	then do;
		action = AS_AUDIT_CHANNEL_DIAL_SYSTEM;
	     end;
	else do;
		action = AS_AUDIT_CHANNEL_DIALIN;
		CAI.valid.service_info = TRUE;
		CAI.service_info = dial_qualifier;
	     end;

	call as_access_audit_$channel (cdtep, null, utep, action, addr (CAI), "");
     end DIALIN_OK;
%page;
NULL_PROC:
     procedure ();

/**** This dummy procedure exists for as_any_other_handler_'s sake.
      It is a dummy cleanup handler, required by as_any_other_handler_. */

	return;
     end NULL_PROC;
%page;
INITIALIZE_CURRENT_ACCESS_CLASS:
     procedure (P_code);

/**** This procedure ensures that the cdte.current_access_class_valid
      bit reflects the true state of the channel, and that the current
      access field in the cdte is up-to-date. */

dcl     P_code fixed bin (35) parameter;		/* status code */
dcl     1 auto_tty_access_class structure aligned like tty_access_class automatic;

	P_code = 0;				/* initialize */

	call asu_$reset_access_class (cdtep);		/* reset configured state */

	if cdte.current_service_type = DIAL_OUT_SERVICE
	then return;

	if ^cdte.current_access_class_valid
	then do;					/* see if we can do it */
		unspec (auto_tty_access_class) = ""b;
		call astty_$tty_order (cdtep, "get_required_access_class", addr (auto_tty_access_class), P_code);
		if P_code = 0 & auto_tty_access_class.access_class_set
		then do;
			cdte.current_access_class_valid = TRUE;
			cdte.current_access_class = auto_tty_access_class.access_class;
		     end;
		else if P_code = 0
		then ;				/* no required access class */
		else if P_code = -1			/* stupid value if channel down */
		then P_code = 0;

		else if P_code = error_table_$undefined_order_request
		then P_code = 0;			/* of if this MUX doesn't support it */
		else /* error of some kind */
		     call sys_log_$error_log (SL_LOG_SILENT, P_code, ME,
			"From get_required_access_class control order on channel ^a.", cdte.name);
	     end;
	else P_code = 0;
	return;
     end INITIALIZE_CURRENT_ACCESS_CLASS;
%page;
/* format: off */
%page; %include absentee_user_table;
%page; %include access_mode_values;
%page; %include aim_template;
%page; %include aim_privileges;
%page; %include access_audit_bin_header;
%page; %include answer_table;
%page; %include as_audit_structures;
%page; %include as_data_;
%page; %include as_data_definitions_;
%page; %include as_request_header;
%page; %include as_request_sender_;
%page; %include author_dcl;
%page; %include cdt;
%page; %include dial_server_request;
%page; %include dialup_values;
%page; %include daemon_user_table;
%page; %include line_types;
%page; %include pnt_entry;

dcl  1 pnte		        structure aligned like pnt_entry;
%page; %include sat;

dcl  satep	        ptr;
%page; %include set_term_type_info;
%page; %include sys_log_constants;
%page; %include terminal_info;
%page; %include tty_access_class;
%page; %include user_attributes;
%page; %include user_table_entry;
%page; %include user_table_header;

/* format: on */
%page;
/* BEGIN MESSAGE DOCUMENTATION

   Message:
   dial_ctl_: Channel CHANNEL dialed to Initializer {(PERSON.PROJECT)}

   S:	as (severity2)

   T:	$run

   M:	An additional secondary terminal has been attached to the
   Initializer process as a result of a dial system command.  CHANNEL
   specifies which terminal dialed Initializer.

   A:	If this terminal has been connected to the Initializer by
   an authorized operations staff member, proceed to use it by
   issuing an "accept" command and possibly the "substty" command.
   If this is an invalid attempt to connect to the system, type
   "drop CHANNEL" to disconnect the terminal.


   Message:
   dial_ctl_: ERROR_MESSAGE.  Can't find PNT entry: PERSON_ID

   S:	as (severity2)

   T:	$run

   M:	An attempt was made to find the Person Name Table entry
   of the PERSON_ID specified in a dial preaccess command.  However,
   an error occurred which searching in the PNT.

   A:	$notify_sa

   Message:
   dial_ctl_: sat.ht has PROJECT_ID, sat has OTHER_PROJECT_ID at LOC.

   S:	as (severity2)

   T:	$run

   M:	The System Administrator's Table is inconsistent with the
   location information in its hash table.

   A:	$notify_sa

   Message:
   dial_ctl_: Rejected unknown request from PERSON.PROJECT.  No request flags set in dial_server_request.

   S:	as (severity0)

   T:	$run

   M:	The user PERSON.PROJECT attempted to send an dial_server request
   to the Initializer, but failed to specify what type of request he/she
   wanted.

   A:	$ignore


   Message:
   dial_ctl_: Channel CHANNEL (AIM_CLASS, SERV_TYPE) hung up on Initializer

   S:	as (severity1)

   T:	$run

   M:	The channel CHANNEL with access class AIM_CLASS and service type
   SERV_TYPE hung up.  It had previously been dialed to the Initializer.

   A:	$ignore


   Message:
   dial_ctl_: Channel CHANNEL (AIM_CLASS, SERV_TYPE) hung up on missing process WWWWWWWWWWWW

   S:	as (severity1)

   T:	$run

   M:	The channel CHANNEL with access class AIM_CLASS and service type
   SERV_TYPE hung up.  It had been dialed to a process, but the system cannot
   determine what process it had been connected to.  The process may have
   terminated before the hangup was detected.

   A:	If this happens often, inform the programming staff.


   Message:
   dial_ctl_: Can't find process WWWWWWWWWWW

   S:	as (severity0)

   T:	$run

   M:	An invalid signal was received by the secondary terminal
   manager.

   A:	$note


   Message:
   dial_ctl_: Tracing turned on.

   S:	as (severity1)

   T:	$run

   M:	A system administrator had enabled tracing of the dial_ctl_
   program.  Many status messages will be logged and printed on the
   console.

   A:	$ignore


   Message:
   dial_ctl_: Tracing turned off

   S:	as (severity1)

   T:	$run

   M:	A system administrator has disabled dial_ctl_ tracing.

   A:	$ignore


   Message:
   dial_ctl_: ERROR_MESSAGE. Could not check access to >sc1>admin_acs>tandd.acs for PERSON.PROJECT.

   S:	as (severity0)

   T:	$run

   M:	The user PERSON.PROJECT attempted to tandd_attach a communications
   channel.  This operation is controlled by rw access to the ACS segment
   specified.  For the reason ERROR_MESSAGE, the answering service could not
   check access to the segment.  The user tandd_attach request was refused.

   A:  	$contact_sa


   Message:
   dial_ctl_: ERROR_MESSAGE. Issuing tandd_attach control order for channel CHAN

   S:	as (severity0)

   T:	$run

   M:	The user PERSON.PROJECT attempted to tandd_attach a communications
   channel which failed for the reason given by ERROR_MESSAGE.  The user
   tandd_attach request was refused.

   A:  	$contact_sa


   Message:
   dial_ctl_: Dialing channel CHANNEL (ACC_CLASS) to DESTINATION for PERSON.PROJECT {using comm privilege}

   S:	as (severity0)

   T:	$run

   M:	The user PERSON.PROJECT is dialing out on dial channel CHANNEL
   with access class ACC_CLASS to the destination DESTINATION.  If this
   log message ends with "using comm privilege", then the process dialing
   out has used the comm privilege to circumvent AIM restrictions.

   A:	$ignore


   Message:
   dial_ctl_: ERROR_MESSAGE. after dial_out order (CHANNEL for PERSON.PROJECT)

   S:	as (severity0)

   T:	$run

   M:	The user PERSON.PROJECT is attempting a dial_out of channel
   CHANNEL.  The dial_out control order produced the error ERROR_MESSAGE.
   The dial_out attempt is aborted.

   A:	$note


   Message:
   dial_ctl_: ERROR_MESSAGE. call to astty_$tty_new_proc of CHANNEL for PERSON.PROJECT failed

   S:	as (severity0)

   T:	$run

   M:	An attempt to connect the channel CHANNEL to PERSON.PROJECT failed.
   ERROR_MESSAGE indicates why.

   A:	$contact_sa

   Message:
   dial_ctl_: ERROR_MESSAGE. Attempting to detach CHANNEL from PERSON.PROJECT

   S:	as (severity0)

   T:	$run

   M:	An attempt to disconnect channel CHANNEL from PERSON.PROJECT
   failed.  ERROR_MESSAGE explains why.

   A:	$note


   Message:
   dial_ctl_: Autocall channel CHANNEL declared multi-class, but does not support set_required_access_class.

   S:	as (severity2)

   T:	$run_

   M:	The autocall channel CHANNEL has been declared multi-class in
   the CDT, but the underlying multiplexer does not support the
   set_required_access_class control order.  The channel should be
   defined as single class.  The user's dial out request was refused.

   A:	$contact_sa


   Message:
   dial_ctl_: ndialed negative CHANNEL

   S:	as (severity0)

   T:	$run

   M:	The count of secondary consoles for a user is in error.  A
   terminal is hanging up which claims to be attached to a user but his
   count of attached terminals is zero.

   A:	$note


   Message:
   dial_ctl_: Program error.  as_request_sender.version (N) not correct in dial request.  Should be M.

   S:	as (severity1)

   T:	$run

   M:	There is a mismatch in the version number used by the
   the programs as_request_server_ and dial_ctl_ for the as_request_sender_
   structure.

   A:	$contact


   Message:
   dial_ctl_: Channel CHANNEL hung up after dial_out for PERSON.PROJECT

   S:	as (severity0)

   T:	$run

   M:	During a dial_out of channel CHANNEL by PERSON.PROJECT, the
   channel hung up.  The dial_out attempt was aborted.

   A:	$ignore


   Message:
   dial_ctl_: ERROR_MESSAGE. getting dial_out_status or tty info (CHANNEL for PERSON.PROJECT)

   S:	as (severity0)

   T:	$run

   M:	During a dial_out of channel CHANNEL by PERSON.PROJECT, the
   error ERROR_MESSAGE was returned while attempting to determine if
   the dial_out control order succeeded or failed.

   A:	$ignore


   Message:
   dial_ctl_: ERROR_MESSAGE.  dial_out (CHANNEL for PERSON.PROJECT) failed.

   S:	as (severity0)

   T:	$run

   M:	While attempting to dial_out channel CHANNEL for PERSON.PROJECT,
   the error ERROR_MESSAGE occured.  The dial_out attempt was aborted.

   A:	$ignore


   Message:
   dial_ctl_: Refused unknown request from PERSON.PROJECT; ERROR_MESSAGE REASON

   S:	as (severity0)

   T:	$run

   M:	PERSON.PROJECT send a dial_server request to the Initializer
   of unknown format. It was rejected for the reasons specified in
   ERROR_MESSAGE and REASON.


   Message:
   DIALIN DENIED {PERSON1.PROJECT1} CHANNEL to QUALIFIER {PERSON2.PROJECT2} REASON

   S:	as (severity0)

   T:	$run

   M:	A user on channel CHANNEL attempted to use the "dial" preaccess
   command to dial to QUALIFIER, owned by PERSON2.PROJECT2.  The attempt
   was rejected for REASON.  If the channel check_acs "slave_dial" flag
   was on, then PERSON1.PROJECT1 specifies the identified user on this
   channel.

   A:	$note


   Message:
   DIALIN      {PERSON1.PROJECT1} CHANNEL to QUALIFIER {PERSON2.PROJECT2}

   S:	as (severity0)

   T:     $run

   M:	A user on channel CHANNEL has used the "dial" preaccess command
   to dial the dial qualifier QUALIFIER owned by PERSON2.PROJECT2.  If
   the check_acs "slave_dial" flags was on for the channel, then
   PERSON1.PROJECT1 specifies the identified user.

   A:	$ignore

   Message:
   dial_ctl_: ERROR_MESSAGE  From get_required_access_class control order on channel CHANNEL.

   S:	as (severity0)

   T:	$run

   M:	While attempting to determine whether the channel CHANNEL
   had any access class restrictions imposed on it by the hardcore,
   ERROR_MESSAGE was returned.  The request in progress was aborted.

   A:	$note

   END MESSAGE DOCUMENTATION */

     end dial_ctl_;
