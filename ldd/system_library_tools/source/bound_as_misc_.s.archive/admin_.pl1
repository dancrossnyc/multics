/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1990   *
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

/* format: style4 */

admin_: procedure ();

/* *** The entries in admin_ implement the various operator commands of
   the same name.  They are called as a result of entries in
   sc_request_table_ via sc_process_command_line_. */

/* *** NOTE -- Entries should call sys_log, rather than sys_log_.
   Whenever this program is entered as something other than a
   command (a timer handler or the like) the entry variable
   sys_log is set to the non-command entrypoints in sys_log_,
   otherwise they use the command entrypoints.  Note than recursive
   internal calls have to be capable of doing this right. */

/*
   The following answering service functions are provided by this module
   (entry points are in the order shown):

   *     MISC. COMMANDS

   login		cause a daemon user to be logged in
   logout		cause a daemon user to be logged out
   word		set login word and dialup buffer
   sysid		set system ID (typed at dialup)
   down		schedule automatic shutdown of system at later time
   stop		shut down answering service; bump all users
   warn		blast message onto a user's console
   rcp		reply to RCP requests (only list now implemented)
   log		enter comments in the answering service log.
   maxunits	set maximum number of load units
   shift		set shift and shift change time, overriding shift table

   *     FNP COMMANDS

   fdump_fnp, or	take an fdump of a specified FNP, crashing it if it is up
   dump_fnp
   load_fnp	initiate a bootload of a specified FNP
   start_fnp	listen to the phones configured on a specified FNP
   stop_fnp	prevents booting of specified FNP or listening to its phones

   *	MULTIPLEXER COMMANDS (similiar to fnp commands)

   dump_mpx		take a dump of the specified multiplexer
   load_mpx		initialize the specified multiplexcer
   start_mpx		listen to the phones on a specified multiplexer
   stop_mpx		stop listening to the phones in the specified multiplexer
   shutdowm_mpx               shutdown multiplexer without crash

   *     ABSENTEE COMMANDS

   abs maxu	set maximum absentee users
   abs maxq	set maximum absentee queue
   abs start	start absentee
   abs stop	stop absentee
   abs bump	bump absentee job
   abs cancel	bump and do not restart absentee job
   abs qres	set number of reserved slots for each queue
   abs cpu_limit	set max cpu limit for each queue
   abs defer	do not log job(s) in until they are released
   abs list	list specified job(s)
   abs move	move specified job(s) to different queue
   abs next	log specified job in next
   abs release	allow specified deferred or suspended job(s) to log in or resume running
   abs run	log specified job in immediately
   abs suspend	don't run specified logged-in job until released
   abs terminate	terminate absentee process (bump by simulating fatal process error)

   Modified 750415 by PG to use printer_on order call.
   Modified 751020 by PG to fix bug in DOWN command and delete obsolete TAPE command.
   Modified May 1976 by T. Casey to implement SHIFT command.
   Modified July, 1976 by D. M. Wells to understand bumping FTP channels
   Modified 760819 by  Roy Planalp to produce correct message if chnl with
   no user logged in is detached, and to write ftp-format message when bumping ftp users
   Modified August 1976 by T. Casey and M. Grady to add commands that deal with FNPs
   Modified November 1976 by T. Casey to fix bug in stop_fnp command.
   Modified September 1977 by T. Casey to make drop, accept, substty, detach, and remove treat MC_SERVICE consistently,
   .	and to make the word command with no arguments print current word, session type, and message.
   Modified January 1978 by T. Casey to fix bugs in previous modification.
   Modified May 1978 by T. Casey to add abs qres command, and modify several other commands to print the current values
   .		of the parameters they set, instead of complaining, when no arguments are given.
   Modified August 1978 by Larry Johnson for multiplexer commands
   Modified November 1978 by T. Casey, for new abs command keywords.
   Modified March 1979 by T. Casey for MR7.0a, to add abs terminate, abs suspend, and abs release of suspended jobs.
   Modified August 1979 by T. Casey for MR8.0 to support process preservation across hangups and fix bugs.
   Modified December 1980 by E. N. Kittlitz for Person.Project & bugfixes
   Modified June 1981 by T. Casey for MR9.0 for new wakeup priorities.
   Modified November 1981, E. N. Kittlitz.  user_table_entry conversion.
   Modified December 1981, E. N. Kittlitz.  whotab copies of autbl control info.
   Modified April 1982, E. N. Kittlitz. down: insist uptime > downtime
   Modified May 1982, E. N. Kittlitz. New AS initialization.
   Modified June 1982, E. N. Kittlitz. Kluge MR10.0 stop_mpx support.
   Modified July 1982, E. N. Kittlitz. rename to admin_.
   Modified August 1982, E. N. Kittlitz. dialup_ re-introduction.
   Modified October 1982, E. N. Kittlitz.  minor 'word' fixes.
   Modified 83-12-14, BIM. added shutdown_mpx
   Modified March 1984 by GMP to fix the "word" command to set the special message again.
   Modified 09/10/84 by R. Michael Tague: Changed $down so that
   system_shutdown_scheduled_ IPS is sent to all processes when a shutdown
   is scheduled.
   Modified 1984-11-02, BIM: Stop masking and unmasking, its not our job.
   call the restricting entry in mc_commands_ for quit.
   Modified 84-11-14 for whotab.session. -E. A. Ranzenbach...
   Modified 1985-01-10, BIM: Add calls to mc_check_access_ for quit and
   login/logout.
   Modified 1985-02-07, E. Swenson: to allow cancellation of absentee shutdown
   once one has begun, but not yet been completed.
   Modified 1985-02-13, E. Swenson: to fix bump code.
   Modified 1985-03-12, E. Swenson: to fix system shutdown scheduling.
   Modified 1985-03-22, E. Swenson: to fix drop code.
   Modified 1985-06-28, E. Swenson: allow substty to again work for otw_.
*/

/****^  HISTORY COMMENTS:
  1) change(86-01-09,MSharpe), approve(87-05-01,MCR7690),
     audit(87-05-07,Parisek), install(87-08-04,MR12.1-1055):
     Changed to move message coordinator, process and channel comm commands
     to the newly created programs to hold them.  (These commands were
     previously in admin_.)
  2) change(86-05-13,GJohnson), approve(86-05-13,MCR7387),
     audit(86-05-13,Martinson), install(86-05-14,MR12.0-1055):
     Correct error message documentation.
  3) change(86-09-26,Beattie), approve(86-09-22,MCR7542),
     audit(86-10-31,Brunelle), install(86-11-12,MR12.0-1211):
     Remove references to the 963 and 029 preaccess commands and remove support
     for ARDS, 202_ETX, 2741 and 1050 in system interfaces.
  4) change(87-04-27,GDixon), approve(87-05-01,MCR7690),
     audit(87-05-07,Parisek), install(87-08-04,MR12.1-1055):
     Upgraded for change to answer_table.incl.pl1 and user_table_entry.incl.pl1
  5) change(87-06-25,Parisek), approve(87-06-25,MCR7690),
     audit(87-07-31,Beattie), install(87-08-04,MR12.1-1055):
     Added a cleanup handler for all entry points thereby nulling all
     pointers to system data bases previously opened up.
  6) change(87-08-06,GDixon), approve(87-08-06,MCR7690),
     audit(87-08-06,Parisek), install(87-08-06,MR12.1-1064):
     Remove the cleanup handler.  It was performing a mis-service by
     terminating segments pointed to by static pointers in as_data_.
  7) change(87-09-18,Parisek), approve(87-09-18,PBF7716),
     audit(87-09-18,Farley), install(87-09-21,MR12.1-1111):
     Correct an incorrectly formatted ioa_ control string.
  8) change(87-10-04,Beattie), approve(87-10-26,MCR7785),
     audit(87-12-04,Parisek), install(87-12-07,MR12.2-1008):
     Accomodate changes in format of date_time strings.
  9) change(88-09-30,Parisek), approve(88-10-19,MCR8014),
     audit(89-01-12,Farley), install(89-01-23,MR12.3-1009):
     Divide installation_parms.warning_time by 60 seconds to produce the
     correct number of minutes a process has left before shutdown which is
     reported by the stop command.
 10) change(90-09-20,Vu), approve(90-09-20,MCR8201), audit(90-09-24,Schroth),
     install(90-10-04,MR12.4-1037):
     Correct the oprerator command "abs stop q fg" which cause queue 1 to stop.
     Absentees are bumped at random time for a scheduled shutdown due to an
     uninitialized value.
                                                   END HISTORY COMMENTS */

/* Entries */

dcl  absentee_user_manager_$aum_abs_run entry (ptr);
dcl  absentee_user_manager_$init_aum entry (fixed bin (35));
dcl  absentee_user_manager_$term_aum entry;
dcl  absentee_user_manager_$update_whotab_abs_control entry;
dcl  absentee_utility_$abs_defer entry (ptr);
dcl  absentee_utility_$abs_release entry (ptr, fixed bin);
dcl  absentee_utility_$au_send_wakeup entry;
dcl  act_ctl_$shift_cmnd_update entry;
dcl  admin_$abs entry options (variable);
dcl  admin_$absentee_down entry;
dcl  admin_$absentee_off entry;
dcl  asu_$bump_user entry (ptr, char (*), fixed bin (35), fixed bin);
dcl  admin_$timed_stop_command entry ();
dcl  asu_$blast_user entry (ptr, char (*), char (*), fixed bin (35));
dcl  available_slots_ entry (fixed bin, fixed bin, (4) fixed bin, (4) fixed bin) returns (fixed bin);
dcl  convert_date_to_binary_ entry (char (*), fixed bin (71), fixed bin (35));
dcl  convert_status_code_ entry (fixed bin (35), char (8) aligned, char (100) aligned);
dcl  cu_$arg_list_ptr entry returns (ptr);
dcl  cu_$generate_call entry (entry, ptr);
dcl  cu_$arg_ptr_rel entry (fixed bin, ptr, fixed bin (21), fixed bin (35), ptr);
dcl  cu_$arg_count_rel entry (fixed bin, ptr, fixed bin (35));
dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
dcl  daemon_user_manager_$login entry (char (*), char (*), char (*), char (*));
dcl  daemon_user_manager_$logout entry (char (*), char (*), char (*));
dcl  dialup_$re_introduce entry;
dcl  multiplexer_mgr_$dump_mpx entry (char (*), bit (1) aligned, fixed bin (35));
dcl  multiplexer_mgr_$load_mpx entry (char (*), bit (1) aligned, bit (1) aligned, bit (1) aligned, fixed bin (35));
dcl  multiplexer_mgr_$start_mpx entry (char (*), bit (1) aligned, fixed bin (35));
dcl  multiplexer_mgr_$listen_mpx entry (char (*), fixed bin (35));
dcl  multiplexer_mgr_$stop_mpx entry (char (*), fixed bin (35));
dcl  multiplexer_mgr_$shutdown_mpx_command entry (character (*), bit (1) aligned, fixed binary (35));
dcl  datebin_$next_shift_change entry (fixed bin (71), fixed bin (71), fixed bin, fixed bin);
dcl  date_time_$format entry (char (*), fixed bin (71), char (*), char (*)) returns (char (250) var);
dcl  get_process_id_ entry () returns (bit (36));
dcl  hcs_$initiate entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
dcl  hcs_$wakeup entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
dcl  hphcs_$ips_wakeup entry (bit (36) aligned, char (*));
dcl  ioa_$rsnnl entry options (variable);
dcl  ioa_$rs entry options (variable);
dcl  ipc_$delete_ev_chn entry (fixed bin (71), fixed bin (35));
dcl  ipc_$create_ev_chn entry (fixed bin (71), fixed bin (35));
dcl  ipc_$decl_ev_call_chn entry (fixed bin (71), entry, ptr, fixed bin, fixed bin (35));
dcl  load_ctl_$set_maxunits entry (fixed bin);
dcl  load_ctl_$set_abs_parms entry;
dcl  mc_check_access_$log_daemon_in entry (pointer, character (*), fixed binary (35));
dcl  ssu_$get_info_ptr entry (pointer) returns (pointer);
dcl  sys_log entry variable options (variable) init (sys_log_$command);
dcl  sys_log$error_log entry variable options (variable) init (sys_log_$command_error);
dcl  (sys_log_, sys_log_$error_log, sys_log_$command, sys_log_$command_error)
	external entry;
dcl  timer_manager_$alarm_wakeup entry (fixed bin (71), bit (2), fixed bin (71));
dcl  timer_manager_$reset_alarm_wakeup entry (fixed bin (71));
dcl  rcp_list entry;
dcl  rcp_cancel entry;
dcl  match_star_name_ entry (char (*), char (*), fixed bin (35));
dcl  match_request_id_ entry (fixed bin (71), char (*)) returns (bit (1) aligned);
dcl  expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35));
dcl  list_abs_requests$abs_list entry (ptr, fixed bin, fixed bin (71), fixed bin); /* last arg is NOT fixed bin (35) */
dcl  cancel_abs_request$as_abs entry (ptr, fixed bin, fixed bin (71), fixed bin (35));

/* External */
dcl  as_error_table_$try_again_at_msg fixed bin (35) ext;
dcl  as_error_table_$special_sess_msg fixed bin (35) ext;
dcl  as_error_table_$sys_down_msg fixed bin (35) ext;
dcl  error_table_$action_not_performed fixed bin (35) ext;
dcl  error_table_$noarg fixed bin (35) ext;
dcl  error_table_$noentry fixed bin (35) ext static;

/* Builtin */

dcl  (addr, after, before, clock, divide, hbound, index, length, max,
     min, null, rtrim, substr, sum, unspec, verify) builtin;


/* Internal Static */

dcl  goingdown bit (1) int static init ("0"b);		/* TRUE if auto shutdown scheduled */
dcl  auto_bump_chn fixed bin (71) int static;		/* channel for auto shutdown */
dcl  stopflag bit (1) aligned init ("0"b) int static;	/* TURE once operator has typed stop */
dcl  abs_stop_chn int static fixed bin (71);		/* event channel associated with shutting down abs */
dcl  absolute_max_queue fixed bin int static init (4);	/* maximum number of queues */
dcl  abs_shut_interval fixed bin int static init (1800);	/* 30 minutes between shutdown and abs stop */
dcl  abs_shut_offset fixed bin int static init (600);	/* allow abs to run for 10 mins after interactives out */
dcl  saved_max_abs_users fixed bin (17) internal static;
dcl  saved_abs_maxu_auto bit (1) aligned internal static;

/* Constant */

dcl  DIGITS char (10) int static init ("0123456789") options (constant); /* for checking time. */
dcl  ME char (6) int static init ("admin_") options (constant);
dcl  MILLION fixed bin (35) int static init (1000000) options (constant); /* useful constant */
dcl  NL char (1) internal static options (constant) init ("
");
dcl  ONE_WEEK fixed bin (71) int static init (604800000000) options (constant); /* microseconds in a week */
dcl  SECS_IN_MIN fixed bin int static init (60) options (constant); /* seconds in a minute */
dcl  n_called fixed bin int static;			/* accumulative time from which stop absentee issued */
dcl  abs_command (16) char (12) int static options (constant) initial
	("maxu", "maxq", "stop", "start", "bump", "cancel", "qres", "cpu_limit",
	"defer", "list", "move", "next", "release", "run", "suspend",
	"terminate"
	);

dcl  four_zeros (4) fixed bin int static options (constant) init ((4) 0);
dcl  CAPITALS char (26) int static options (constant) init
	("ABCDEFGHIJKLMNOPQRSTUVWXYZ");

/* Automatic */

dcl  code fixed bin (35);
dcl  (i, j, k, l, strl) fixed bin;			/* temps */
dcl  lng fixed bin (21);
dcl  temp_sw bit (1) aligned;
dcl  (clock_value, saveclk) fixed bin (71);		/* clock readings in microseconds */
dcl  prefix char (200) aligned;			/* message for user */
dcl  shortinfo char (8) aligned, (longinfo, longinfo1) char (100) aligned;
dcl  comname char (24);
dcl  msg char (80);					/* message */
dcl  (day_now, day_back) char (6);			/* dates */
dcl  reason char (124);				/* reason for next shutdown */
dcl  string char (256);				/* string of arguments */
dcl  (wpers, wproj) char (28) init ("");		/* person and proj id to look for */
dcl  answer char (256) init ("");			/* message typed to operator */
dcl  arg_count fixed bin;				/* set in validate */
dcl  arg_list_ptr ptr;				/* pointer to our argument list */
dcl  p ptr;					/* junk ptr */
dcl  action_flag bit (1) aligned;
dcl  abs_funct char (12);				/* function to be performed by absentee commands */
dcl  mess char (8);					/* event message for use by absentee commands */
dcl  ev_p ptr;					/* pointer to above */
dcl  temp char (2);					/* abs q number */
dcl  source char (8),				/* Source name, used in "route" */
     attchan char (32);				/* .. channel ID or file name */
dcl  (check_sw, force_sw, go_sw) bit (1) aligned;
dcl  qres (4) fixed bin;
dcl  mpx_name char (32);				/* name of a mltiplexer */
dcl  fnp_only bit (1) init ("0"b);			/* set if one of obsolete fnp only commands called */
dcl  nargs fixed bin;
dcl  abs_start_at_startup bit (1) aligned;
dcl  fb71 fixed bin (71);				/* temp */
dcl  b12 bit (12);
dcl  c4 char (4);
dcl  temp_dir char (168);
dcl  temp_ename char (32);
dcl  abs_arg_ptr ptr;
dcl  continue bit (1) aligned;
dcl  error_message char (256);			/* text of error message */

/* Based */

dcl  1 auto_abs_args like abs_args aligned;
dcl  arg char (lng) based (p);			/* pickup structure for arguments */
dcl  bf fixed binary (71) based (p);			/* for event message */
dcl  1 xmessage aligned based (ev_p),			/* structure which describes a two part */
       2 string char (4) aligned,			/* event message sent to absentee user manager */
       2 table_index fixed bin;			/* index in AUT */

dcl  based_anstbl_message char (lng) based (addr (anstbl.special_message));
%page;
login: entry options (variable);

/* *** This entry implements the operator "login" command.  It allows
   the operator to log in system daemons. */

	arg_list_ptr = cu_$arg_list_ptr ();
	comname = "admin_: login";

	call validate;				/* locate anwer table */
	if arg_count = 0 then
LOGIN_USAGE:   do;
	     answer = "Usage: login Person.Project SOURCE {-control_args}";
	     go to admin_answers;
	end;


	call get_pers_proj (arg_list_ptr, 1, i, code);	/* get person, project */
	if code ^= 0 then go to LOGIN_USAGE;

	call cu_$arg_ptr_rel (i, p, lng, code, arg_list_ptr); /* see if source arg */
	if code ^= 0 then go to LOGIN_USAGE;
	attchan = arg;

	sc_subsystem_info_ptr = ssu_$get_info_ptr (sc_stat_$admin_sci_ptr);
	call mc_check_access_$log_daemon_in (sc_subsystem_info_ptr, attchan, code);
	if code ^= 0 then do;
	     if code = error_table_$noentry
	     then answer = "No MC ACS segment for the source " || rtrim (attchan) || ".";
	     else answer = "Login not permitted for message coordinator source " || rtrim (attchan) || ".";
	     go to admin_err;
	end;

	i = i + 1;				/* get next arg */
	call cu_$arg_ptr_rel (i, p, lng, code, arg_list_ptr); /* See if optional args. */
	if code ^= 0 then string = "";
	else call build_string (arg_list_ptr, (i));	/* we don't need i any more, but build_string does */

	call daemon_user_manager_$login (wpers, wproj, attchan, string);
						/* Cause automatic login of daemon */

	return;
%page;
logout: entry options (variable);

/* *** This entry implements the operator "logout" command.  It allows
   an operator to logout system daemons. */

	arg_list_ptr = cu_$arg_list_ptr ();
	comname = "admin_: logout";

	call validate;				/* locate answer table */

	call get_pers_proj (arg_list_ptr, 1, i, code);	/* get person, project, set i */
	if code ^= 0 then do;
	     answer = "Usage: logout Person.Project {SOURCE}";
	     go to admin_answers;
	end;

	call cu_$arg_ptr_rel (i, p, lng, code, arg_list_ptr); /* get source */
	if code ^= 0 then source = "*";
	else source = arg;
	call daemon_user_manager_$logout (wpers, wproj, source); /* bop */

	return;
%page;
word: entry options (variable);

/* *** This entry implements the operator "word" command.  It allows the
   operator to set the login word. */

	arg_list_ptr = cu_$arg_list_ptr ();
	comname = "admin_: word";
	call cu_$generate_call (SET_LOGIN_WORD, cu_$arg_list_ptr ());
	return;
%page;
sysid: entry options (variable);

/* *** This entry implements the operator "sysid" command.  It allows
   the operator to set the published system id in the who table. */

	arg_list_ptr = cu_$arg_list_ptr ();
	comname = "admin_: sysid";

	call validate;				/* locate answer table */

	call cu_$arg_ptr_rel (1, p, lng, code, arg_list_ptr); /* get system id argument */
	if code ^= 0 then go to admin_err;
	if whoptr = null then return;			/* in case trouble */
	whotab.sysid = arg;				/* change public system id */
	return;
%page;
down1: entry (dn_time, dn_msg, dn_until);

/* *** This entry is called by as_init_ to restore an old scheduled
   shutdown. */

dcl  (dn_time, dn_until) fixed bin (71), dn_msg char (*);

	arg_list_ptr = cu_$arg_list_ptr ();
	call validate;
	comname = "admin_: down";
	call SCHEDULE_SYSTEM_SHUTDOWN (dn_time, dn_msg, dn_until);
	return;
%page;
down: entry options (variable);

/* *** This is the operator "down" command.  It schedules a system shutdown,
   stops a scheduled shutdown, or tells the operator when the next
   system shutdown is scheduled. */

	arg_list_ptr = cu_$arg_list_ptr ();
	comname = "admin_: down";
	call validate;

	call cu_$arg_ptr_rel (1, p, lng, code, arg_list_ptr); /* get shutdown time */
	if code ^= 0 then do;			/* If no args, tell when shutdown will be. */
	     if ^goingdown then
		call sys_log (SL_LOG, "^a: down: No shutdown is scheduled.", ME);
	     else do;
		msg = date_time_$format ("date_time", whotab.nextsd, "", "");
		answer = date_time_$format ("date_time", whotab.until, "", "");
		call sys_log (SL_LOG, "^a: down: Next shutdown from ^a to ^a ^a", ME, msg, answer, whotab.why);
	     end;
	     return;
	end;

	string = arg;				/* align argument */
	if lng = 1 then
	     if string = "0" then do;			/* if time is 0 then reset previous shutdown command */
		call CANCEL_SYSTEM_SHUTDOWN (answer, code);
		if code ^= 0 then
		     goto admin_answers;
		else return;
	     end;

	if verify (arg, DIGITS) = 0 then
	     call convert_date_to_binary_ (arg || ".", saveclk, code);
	else call convert_date_to_binary_ (arg, saveclk, code);
	if code ^= 0 then do;			/* Check if time is legal. */
bad_t:	     answer = arg || " invalid clock time.";
	     go to admin_answers;
	end;

	if saveclk < clock () then go to bad_t;		/* Silly. We passed that. */

	j = 3;					/* arg. position */
	call cu_$arg_ptr_rel (2, p, lng, code, arg_list_ptr); /* Next uptime, message, or nothing */
	if code ^= 0 then do;
	     clock_value = 0;			/* default time up */
	     reason = " ";				/* default reason */
	end;
	else do;
	     if verify (arg, DIGITS) = 0 then
		call convert_date_to_binary_ (arg || ".", clock_value,
		     code);
	     else call convert_date_to_binary_ (arg, clock_value, code);
	     if code ^= 0 then do;			/* Must be a message, not time. */
		clock_value = 0;			/* default up time */
		go to why;			/* assign message */
	     end;
	     if clock_value < saveclk then do;
		answer = "uptime is earlier than downtime.";
		go to admin_answers;
	     end;

	     j = 4;				/* arg. pos */
	     call cu_$arg_ptr_rel (3, p, lng, code, arg_list_ptr); /* message, or nothing */
	     if code ^= 0 then reason = " ";		/* default reason */
	     else do;				/* there is a reason */
why:		call build_string (arg_list_ptr, j - 1);
		reason = substr (string, 1, strl);
	     end;
	end;

	if goingdown then do;			/* already a shutdown? */
	     msg = date_time_$format ("date_time", whotab.nextsd, "", "");
	     call sys_log (SL_LOG, "^a: down: resetting previous shutdown at ^a", ME, msg);
	     call CANCEL_SYSTEM_SHUTDOWN (answer, (0));
	end;

	call SCHEDULE_SYSTEM_SHUTDOWN (saveclk, reason, clock_value);
	return;
%page;
stop: entry options (variable);

/* *** This is the operator "stop" command.  It allows a graceful shutdown
   of the system by bumping all the users with grace time. */

	arg_list_ptr = cu_$arg_list_ptr ();
	comname = "admin_: stop";
	call validate;				/* locate answer table */
	call cu_$arg_count_rel (i, arg_list_ptr, (0));	/* operators keep typing "stop absentee" ... */
	if i > 0 then do;				/* .. so reject this */
	     answer = "no arguments are allowed for ""stop""";
	     go to admin_answers;			/* .. try again, dummy */
	end;

	call stop_command;				/* do the work */
	return;					/* that was easy... */
%page;
timed_stop_command:
     entry;

/* *** This entry is called as a result of an alarm timer set by the "down"
   command.  It allows the system to shut down in an orderly fashion */

	arg_list_ptr = cu_$arg_list_ptr ();
	comname = "admin_: stop";
	call set_non_command_sys_loggers;
	call sys_log (SL_LOG, "^a: stop: Automatic shutdown", ME); /* and fix all up */
	call validate;				/* going to need answer table */
	call stop_command;				/* now bump everybody */
	return;
%page;
/* format: style5,ind5 */

warn:
     entry options (variable);

/* *** This entry implements the operator "warn" command.  It allows the
   operator to blast a message on a user's terminal. */

	arg_list_ptr = cu_$arg_list_ptr ();
	comname = "admin_: warn";
	call validate;			      /* locate answer table */

	call get_pers_proj (arg_list_ptr, 1, i, code);/* get person, project, set i */
	if code ^= 0 then
	     do;
	     answer = "Usage: warn Person.Project MESSAGE";
	     go to admin_answers;
	     end;

	call build_string (arg_list_ptr, i);	      /* get message to be sent to user */

	action_flag = "0"b;			      /* haven't done anybody yet */

	continue = "1"b;
	do i = 1 to anstbl.current_size while (continue);
	     utep = addr (anstbl.entry (i));	      /* get ptr to a user entry */
	     if ute.active >= NOW_LOGGED_IN then      /* if user logged in */
		do;
		if wpers = "*" | wpers = ute.person then
		     if wproj = "*" | wproj = ute.project then
			do;
			action_flag = "1"b;	      /* did something */
			if ^ute.uflags.disconnected then
			     do;
			     call asu_$blast_user (utep, string,
			         error_message, code);
			     if code ^= 0 then
				call sys_log (SL_LOG, "^a: warn: ^a",
				    ME, error_message);
			     end;
			if wpers ^= "*" & wproj ^= "*" then
			     continue = "0"b;     /* no more searching */
			end;
		end;
	end;

	if ^action_flag then
	     call sys_log (SL_LOG, "^a: warn: ^a.^a not found.", ME, wpers,
	         wproj);
	return;
%page;

/* format: style4 */

rcp: entry options (variable);

/* *** This is the operator "rcp" command.  It forwards the call to the
   appropriate rcp command: rcp_list or rcp_cancel. */

	arg_list_ptr = cu_$arg_list_ptr ();
	comname = "admin_: rcp";

	call validate;				/* locate answer table */
	call cu_$arg_ptr_rel (1, p, lng, code, arg_list_ptr); /* get opcode, or index */
	if code ^= 0 then goto admin_err;
	if arg = "list" then
	     call cu_$generate_call (rcp_list, cu_$arg_list_ptr ());
	else if arg = "cancel" then
	     call cu_$generate_call (rcp_cancel, cu_$arg_list_ptr ());
	else do;
	     answer = "unknown rcp command " || arg;
	     goto admin_answers;
	end;

	return;
%page;
log: entry options (variable);

/* *** This is the operator "log" command.  It allows the operator to
   place an entry in the answering service log. */

	arg_list_ptr = cu_$arg_list_ptr ();
	comname = "admin_: log";

	call build_string (arg_list_ptr, 1);		/* make up a string which is the comment */
	call sys_log (SL_LOG_SILENT, "^a: log: ^a", ME, string); /* write off line */
	return;
%page;
maxunits:
     entry options (variable);

/* *** This is the "maxu" operator command.  It allows the operator to set
   the maximum number of load units allowed on the system. */

	arg_list_ptr = cu_$arg_list_ptr ();
	comname = "admin_: maxunits";

	call validate;				/* locate answer table */
	call cu_$arg_ptr_rel (1, p, lng, code, arg_list_ptr); /* get first arg */
	if code ^= 0 then do;			/* if no argument given, print current maxu */
	     call sys_log (SL_LOG, "^a: maxu: ^[^; (auto)^; (level)^]: ^d (^d normal users)",
		ME, anstbl.auto_maxu + 1, anstbl.max_units, divide (anstbl.max_units, 10, 17, 0));
	     return;
	end;
	string = arg;				/* get maxunits */
	if string = "auto" then do;			/* turn on auto setting of max */
	     anstbl.auto_maxu = 1;			/* whee */
	     call load_ctl_$set_maxunits (anstbl.shift);	/* stimulate */
	end;
	else if string = "level" then do;		/* make adjustment of max be dynamic */
	     anstbl.auto_maxu = 2;			/* whee wheee */
	     call load_ctl_$set_maxunits (anstbl.shift);	/* and poke it once */
	end;
	else do;
	     i = cv_dec_check_ (string, code);		/* want to shut off automatic thing and force it */
	     if code ^= 0 then go to wrong_maxunits;
	     if i <= 0 then do;			/* simple checks */
wrong_maxunits:
		answer = arg || " is invalid value for maxunits";
		go to admin_answers;
	     end;
	     if i < 200 then			/* check for a likely mistake */
		call sys_log (SL_LOG, "^a: maxu: Warning: maxunits are in tenths of load units.^/^-You just set maxu to ^d, or ^d normal users.",
		     ME, i, divide (i, 10, 17, 0));
	     anstbl.max_units = i;			/* set the system max load units. */
	     anstbl.auto_maxu = 0;			/* Turn off automatic adjustment */
	     whotab.mxunits = i;			/* tell users too */
	end;
	call sys_log (SL_LOG, "^a: maxu^[^; (auto)^; (level)^]: ^d (^d normal users)",
	     ME, anstbl.auto_maxu + 1, anstbl.max_units, divide (anstbl.max_units, 10, 17, 0));

	return;
%page;
/* ADMIN_$SHIFT  - Override shift table - set specified shift until specified time.

   Usage:
   shift		prints "shift S until T"
   shift auto	resets to shift given in shift table
   shift S	sets shift to S until next regular shift change time
   shift S T	sets shift to S until time T (T < one week in future)

*/

shift: entry options (variable);

	arg_list_ptr = cu_$arg_list_ptr ();
	comname = "admin_: shift";

	call validate;				/* get ptrs to various tables */
	clock_value = clock ();			/* use same clock value throughout execution of command */
	j = -1;					/* do not log the command unless we change something */

	call cu_$arg_ptr_rel (1, p, lng, code, arg_list_ptr); /* see if there is at least one argument */
	if code = 0 then do;			/* there is */
	     string = arg;				/* align the argument */

	     if string = "auto" then do;		/* revert to using shift table */
		whotab.next_shift_change_time = 0;	/* force datebin_ to look in shift table */
		call datebin_$next_shift_change (clock_value, whotab.next_shift_change_time, whotab.shift, (0));
	     end;

	     else do;				/* first arg must be shift number */
		i = cv_dec_check_ (string, code);
		if code ^= 0 | i < 0 | i > 7 then do;
		     answer = arg || " is not a legal shift number.";
		     goto admin_answers;
		end;

		call cu_$arg_ptr_rel (2, p, lng, code, arg_list_ptr); /* see if time has also been given */
		if code = 0 then do;		/* it has */
		     if verify (arg, DIGITS) = 0 then
			call convert_date_to_binary_ (arg || ".", saveclk, code);
		     else call convert_date_to_binary_ (arg, saveclk, code);
		     if code ^= 0 then do;
			answer = arg || " invalid clock time.";
			goto admin_answers;
		     end;

		     if saveclk <= clock_value | saveclk > clock_value + ONE_WEEK then do;
			answer = arg || " is not within the next week.";
			goto admin_answers;
		     end;

		     whotab.next_shift_change_time = saveclk;
		end;				/* end of time-given do group */

		whotab.shift = i;			/* we waited to see if time was ok before changing shift */
	     end;					/* end of shift-given do group */
	     j = 1;				/* we changed something, so log the command */
	end;					/* end of first-arg-given do group */

	msg = date_time_$format ("date_time", whotab.next_shift_change_time, "", "");
	call sys_log (SL_LOG, "admin_: shift: ^d until ^a", whotab.shift, msg); /* print shift and time on opr cons */

	if anstbl.shift ^= whotab.shift then do;	/* only if shift actually changed */
	     whotab.last_shift_change_time = clock_value; /* remember when it did */
	     call act_ctl_$shift_cmnd_update;		/* tell accounting to use new rates */
	end;

	return;
%page;
/* The following four entry points deal with FNPs. They allow the operator to
   perform manually some functions that are usually performed automatically by the answering service.
   These commands are provided for debugging and reconfiguration purposes,
   and should not have to be used during normal system operation. */

/* ADMIN_$FDUMP_FNP = CALL SUBROUTINE TO DUMP A SPECIFIED FNP */
/* ADMIN_$DUMP_FNP = CALL SUBROUTINE TO DUMP A SPECIFIED FNP */
/* ADMIN_$DUMP_MPX = CALL SUBROUTINE TO DUMP A SPECIFIED MULTIPLEXER */

fdump_fnp:
     entry options (variable);
dump_fnp:
     entry options (variable);

	fnp_only = "1"b;
	comname = "admin_: fdump_fnp";

dump_mpx:
     entry options (variable);

	arg_list_ptr = cu_$arg_list_ptr ();
	if ^fnp_only then
	     comname = "admin_: dump_mpx";

	call validate;

	call get_mpx_name (1);			/* first arg should be multiplexer name */

	force_sw = "0"b;
	code = 0;
	do i = 2 by 1 while (code = 0);		/* check rest of args */
	     call cu_$arg_ptr_rel (i, p, lng, code, arg_list_ptr);
	     if code = 0 then
		do;
		if arg = "-force" then
		     force_sw = "1"b;
		else
		     do;
		     answer = "unknown argument " || arg;
		     go to admin_answers;
		end;
	     end;
	end;

	call multiplexer_mgr_$dump_mpx (mpx_name, force_sw, code);
	return;

/* ================================================= */

/* ADMIN_$LOAD_FNP = INITIATE A BOOTLOAD OF THE SPECIFIED FNP */
/* ADMIN_$LOAD_MPX = INITIATE A LOAD OF THE SPECIFIED MULTIPLEXER */

load_fnp:
     entry options (variable);

	fnp_only = "1"b;
	comname = "admin_: load_fnp";

load_mpx:
     entry options (variable);			/* new, general command */

	arg_list_ptr = cu_$arg_list_ptr ();

	if ^fnp_only then
	     comname = "admin_: load_mpx";

	call validate;

	call get_mpx_name (1);			/* arg 1 is mpx name */

/* Look for additional arguments */

	check_sw, force_sw = ""b;			/* defaults, if no more args given */
	go_sw = "1"b;
	code = 0;					/* to get past the "while" */

	do i = 2 by 1 while (code = 0);
	     call cu_$arg_ptr_rel (i, p, lng, code, arg_list_ptr);
	     if code = 0 then
		do;				/* if there is an arg */
		if arg = "-ck" | arg = "-check" then
		     check_sw = "1"b;
		else if arg = "-ns" | arg = "-no_start" | arg = "-nostart"
		then
		     go_sw = ""b;
		else if arg = "-force" then
		     force_sw = "1"b;
		else
		     do;
		     answer = "unknown argument " || arg;
		     goto admin_answers;
		end;
	     end;
	end;

	call multiplexer_mgr_$load_mpx (mpx_name, check_sw, go_sw, force_sw,
	     code);

	return;

/* ================================================= */

/* ADMIN_$START_FNP = LISTEN TO THE PHONES CONFIGURED ON A SPECIFIED FNP */
/* ADMIN_$START_MPX = LISTEN TO THE PHONES CONFIGURED ON A SPECIFIED MULTIPLEXER */

start_fnp:
     entry options (variable);

	fnp_only = "1"b;
	comname = "admin_: start_fnp";

start_mpx:
     entry options (variable);

	arg_list_ptr = cu_$arg_list_ptr ();

	if ^fnp_only then
	     comname = "admin_: start_mpx";

	call validate;

	call get_mpx_name (1);			/* arg 1 should be the multiplexer name */

	call multiplexer_mgr_$start_mpx (mpx_name, "0"b, code);
	if code ^= 0 then
	     return;

	call multiplexer_mgr_$listen_mpx (mpx_name, code);
	return;

/* ================================================= */

/* ADMIN_$STOP_FNP = PREVENT LOADING, OR LISTENING TO THE PHONES OF, OR ACCEPTANCE OF CALLS BY, THE SPECIFIED FNP */
/* ADMIN_$STOP_MPX = PREVENT LOADING, OR LISTENING TO THE PHONES OF, OR ACCEPTANCE OF CALLS BY, THE SPECIFIED MULTIPLEXER */

stop_fnp:
     entry options (variable);

	fnp_only = "1"b;
	comname = "admin_: stop_fnp";

stop_mpx:
     entry options (variable);

	arg_list_ptr = cu_$arg_list_ptr ();

	if ^fnp_only then
	     comname = "admin_: stop_mpx";

	call validate;

	call get_mpx_name (1);			/* first arg is multiplexer name */

	call multiplexer_mgr_$stop_mpx (mpx_name, code);

	return;

shutdown_mpx:
     entry options (variable);

	arg_list_ptr = cu_$arg_list_ptr ();

	comname = "admin_: shutdown_mpx";

	call validate;

	call get_mpx_name (1);			/* first arg is multiplexer name */

	force_sw = "0"b;
	code = 0;
	do i = 2 by 1 while (code = 0);		/* check rest of args */
	     call cu_$arg_ptr_rel (i, p, lng, code, arg_list_ptr);
	     if code = 0 then
		do;
		if arg = "-force" then
		     force_sw = "1"b;
		else
		     do;
		     answer = "unknown argument " || arg;
		     go to admin_answers;
		end;
	     end;
	end;

	call multiplexer_mgr_$shutdown_mpx_command (mpx_name, force_sw, code);

	return;					/* END of FNP commands */

/* ================================================= */

/* ADMIN_$ABS = A SET OF FUNCTIONS PERTAINING TO ABSENTEE FACILITY */

/* admin_$abs - all operator commands which deal with absenteee enter here */
/*           - first argument indicates which absentee function is intended */

admin_$abs_not_a_command_:
     entry options (variable);

	call set_non_command_sys_loggers;
						/* ** fall down here */

abs:
     entry options (variable);

	arg_list_ptr = cu_$arg_list_ptr ();

	comname = "admin_: abs";

	call validate;				/* locate answer table */

	if autp = null then
	     do;					/* first call? */
	     call hcs_$initiate (sysdir, "absentee_user_table", "", 0, 0,
		autp, code);
	     if autp = null then
		do;
		call sys_log$error_log (SL_LOG, code, "admin_",
		     "^a>absentee_user_table", sysdir);
		return;
	     end;
	end;

	call cu_$arg_count_rel (nargs, arg_list_ptr, code);
						/* several abs commands need the count */
	abs_arg_ptr = addr (auto_abs_args);		/* initialize ptr to arg structure */
	call cu_$arg_ptr_rel (1, p, lng, code, arg_list_ptr);
						/* get actual command */
	if code ^= 0 then
	     go to admin_err;			/* abs differs from other system control cmds */
	abs_funct = p -> arg;			/* copy absentee opr command */
	ev_p = addr (mess);				/* get ptr to ipc-event message */

/* look up absentee operator command in table & go to label associated with it */

	do i = 1 to hbound (abs_command, 1)
	     while (abs_funct ^= abs_command (i));
	end;
	if i > hbound (abs_command, 1) then
	     do;
	     answer = "unknown absentee command " || arg;
	     go to admin_answers;
	end;

	if ^sc_stat_$Multics then
	     if abs_funct ^= "stop" then
		do;
		call ioa_$rsnnl (
		     "The abs ^a command can not be used before answering service startup.",
		     answer, (0), abs_funct);
		goto admin_answers;
	     end;

	comname = "admin_: abs " || abs_funct;
	goto abs_action (i);
%page;
abs_action (3):					/* ABS STOP */
						/* *** graceful shutdown of absentee facility - keeps checking until no
						   absentee processes left */
	if ^sc_stat_$Multics then			/* abs stop before startup means "don't abs start" */
	     autbl.abs_stopped, autbl.abs_up = ""b;	/* clear any garbage from last bootload */
	call cu_$arg_ptr_rel (2, p, lng, code, arg_list_ptr);
						/* see if second arg given */
	if code = 0 then
	     do;
	     if arg = "now" then
		do;				/* "abs stop now" ? */
		n_called = abs_shut_interval + 1;	/* yes. cause all process to get bumped */
		go to abs_s1;
	     end;

	     else if arg = "q" | arg = "queue" then
		do;				/* drop one or all queues */
		if ^sc_stat_$Multics then
		     do;
		     answer =
			"abs stop queue only works after answering service startup"
			;
		     goto admin_answers;
		end;
		call cu_$arg_ptr_rel (3, p, lng, code, arg_list_ptr);
		if code ^= 0 then
		     do;
		     answer = "missing argument: queue to be stopped";
		     goto admin_answers;
		end;
		if arg = "all" then
		     autbl.queue_dropped (*) = "1"b;
		else if arg = "fg" | arg = "foreground" then
		     autbl.queue_dropped (-1) = "1"b;
		else
		     do;
		     i = cv_dec_check_ (arg, code);
		     if code = 0 then
			do;
			if i >= -1 & i <= absolute_max_queue then
			     autbl.queue_dropped (i) = "1"b;
			else
			     code = 1;		/* any nonzero value, to get error msg printed */
		     end;
		     if code ^= 0 then
			do;
			answer = "invalid queue to be stopped: " || arg;
			goto admin_answers;
		     end;
		end;				/* end not all or foreground */
		goto print_dropped_queues;		/* go do a "abs start queue" to show what happened */
	     end;					/* end abs stop queue */

	     else
		do;				/* bad arg. ignore command */
		answer = "unknown argument " || arg;
		go to admin_answers;
	     end;
	end;
	else
	     n_called = 0;				/* wasn't "abs stop now" - wait a while first */

	if autbl.abs_stopped & autbl.abs_up then
	     do;					/* don't stop absentee if in process of going down */
abs_stopping:
	     answer = "absentee stop in progress";
	     go to admin_answers;
	end;

abs_s1:
	if ^autbl.abs_up then
	     do;					/* don't stop absentee if it is not up */
	     autbl.abs_stopped = "1"b;
	     call sys_log (SL_LOG,
		"^a: abs: absentee not up, and will not be started automatically", ME);
	     if ^sc_stat_$Multics then		/* if before startup */
		call absentee_user_manager_$term_aum;
						/* tell him not to start absentee automatically */
	     go to admin_abs_returns;
	end;

	if goingdown then
	     do;
	     call sys_log (SL_LOG, "^a: abs: resetting auto abs stop", ME);
	     call timer_manager_$reset_alarm_wakeup (abs_stop_chn);
	end;
	else
	     call ipc_$create_ev_chn (abs_stop_chn, code);

	call START_ABSENTEE_SHUTDOWN ();
	return;
%page;
absentee_off:
     entry ();

/* *** This entry is called automatically every 30 seconds once an
   absentee shutdown has been started if there are remaining absentee
   processes running to await their logging out. */

	arg_list_ptr = cu_$arg_list_ptr ();
	call set_non_command_sys_loggers;
	comname = "admin_: abs stop";
	call validate;
	n_called = n_called + 30;			/* keep track of time since abs shutdown performed */
	call CHECK_FOR_ABSENTEE_SHUTDOWN ();		/* Done yet? */
	return;
%page;
absentee_down:
     entry ();

/* *** This entry is called automatically by a timer wakeup when the
   absentee facility is supposed to begin shutdown. The "down"
   command schedules this absentee shutdown. */

	arg_list_ptr = cu_$arg_list_ptr ();
	call set_non_command_sys_loggers ();
	comname = "admin_: abs stop";
	call validate;

	if (^autbl.abs_up | autbl.abs_stopped) then	/* do nothing if not up or already stopped */
	     call absentee_user_manager_$update_whotab_abs_control ();
	else
	     do;
               n_called = 0;
	     call sys_log (SL_LOG, "^a: stop: auto abs stop", ME);
	     call START_ABSENTEE_SHUTDOWN ();
	end;
	return;
%page;
/* The bump, cancel, terminate, suspend, and release functions of the abs
   command share common code. They all take the same set of arguments, and
   they all operate by sending a wakeup  to AUM, with the AUT index in one
   word, and a 4 letter abbreviation of the command name in the other. The
   cancel and release functions can also operate on non-running jobs, so they
   call entry points in AU instead of, or in addition to, sending the wakeup,
   depending on the arguments given. */

/* bumps absentee users - by name, project, absentee id - leaves restartable
   requests in message segment */

/* ********** abs bump ********** */

abs_action (5):					/* ABS BUMP */
	ev_p -> xmessage.string = "bump";
	go to abs_bump_common;

/* bumps absentee users - by name, project, absentee id - deletes restartable requests from message segment */

/* ********** abs cancel ********** */

abs_action (6):					/* ABS CANCEL */
	ev_p -> xmessage.string = "canc";
	goto abs_bump_common;

/* ********** abs release ********** */

abs_action (13):
	ev_p -> xmessage.string = "rlse";
	goto abs_bump_common;

/* ********** abs suspend ********** */

abs_action (15):
	ev_p -> xmessage.string = "susp";
	goto abs_bump_common;

/* ********** abs terminate ********** */

abs_action (16):
	ev_p -> xmessage.string = "term";
	goto abs_bump_common;


abs_bump_common:
	if ^autbl.abs_up then
	     goto abs_not_up;
	k = 0;					/* clear counter of selected jobs */

	call parse_abs_args (arg_list_ptr);		/* look at job selection args and fill in structure */
	if abs_funct = "cancel" then			/* abs cancel must give user name and not "*" */
	     call validate_abs_args ("1"b, "1"b);	/* allow absN, require user */
	else
	     call validate_abs_args ("1"b, "0"b);	/* allow absN, don't require user */

	if abs_funct ^= "cancel" | abs_args.absn_sw | abs_args.abs_star_sw
	then
	     do;					/* scan AUT unless cancel &^absN */
	     if abs_args.absn_sw then
		i, j = abs_args.aut_index;		/* if absN, just look at slot N */
	     else
		do;
		i = 1;
		j = autbl.current_size;
	     end;

	     do i = i to j;
		utep = addr (autbl.entry (i));
		if ute.active < NOW_LOGGED_IN then
		     if abs_args.absn_sw then
			do;
			call ioa_$rsnnl (
			     "No job in absentee slot ^d (status= ^d).",
			     answer, (0), i, ute.active);
			goto admin_answers;
		     end;
		     else
			goto abs_bump_nomatch;

		if abs_args.user_sw then
		     if (abs_args.person ^= "*"
			& abs_args.person ^= ute.person)
			| (abs_args.project ^= "*"
			& abs_args.project ^= ute.project) then
			if abs_args.absn_sw then
			     do;
			     call ioa_$rsnnl (
				"Job in absentee slot ^d is not from user ^a.^a",
				answer, (0), i, abs_args.person,
				abs_args.project);
			     goto admin_answers;
			end;
			else
			     goto abs_bump_nomatch;

		if abs_args.id_sw then
		     if ^match_request_id_ (ute.request_id,
			(abs_args.request_id_string)) then
			if abs_args.absn_sw then
			     do;
			     call ioa_$rsnnl (
				"Job in absentee slot ^d does not match request ID ^a",
				answer, (0), i,
				abs_args.request_id_string);
			     goto admin_answers;
			end;
			else
			     goto abs_bump_nomatch;

		if abs_args.path_sw | abs_args.entry_sw then
		     do;
		     call expand_pathname_ (ute.input_seg, temp_dir,
			temp_ename, (0));
		     call match_star_name_ (temp_ename, abs_args.ename,
			code);
		     if code ^= 0
			| (abs_args.path_sw & temp_dir ^= abs_args.dirname)
		     then
			if abs_args.absn_sw then
			     do;
			     call ioa_$rsnnl (
				"Job in absentee slot ^d does not match absin ^[path ^a>^a^;entry name ^s^a^]",
				answer, (0), i, abs_args.path_sw,
				abs_args.dirname, abs_args.ename);
			     goto admin_answers;
			end;
			else
			     goto abs_bump_nomatch;
		end;

		if abs_args.sender_sw then
		     do;
		     call match_star_name_ (ute.sender, abs_args.sender,
			code);
		     if code ^= 0 then
			if abs_args.absn_sw then
			     do;
			     call ioa_$rsnnl (
				"Job in absentee slot ^d is not from sender ^a",
				answer, (0), i, abs_args.sender);
			     goto admin_answers;
			end;
			else
			     goto abs_bump_nomatch;
		end;

		if abs_args.queue_sw then
		     if (abs_args.queue > 0 & ute.queue ^= abs_args.queue)
			| (abs_args.queue = 0
			& (ute.queue ^= 1 | ^ute.adjust_abs_q_no))
			| (abs_args.queue = -1 & ^ute.foreground_job) then
			if abs_args.absn_sw then
			     do;
			     call ioa_$rsnnl (
				"Job in absentee slot ^d is not from queue ^d",
				answer, (0), i, abs_args.queue);
			     goto admin_answers;
			end;
			else
			     goto abs_bump_nomatch;

		if abs_funct = "release" then		/* if release */
		     if ^ute.sus_sent then		/* and job not suspended */
			if abs_args.absn_sw then
			     do;
			     call ioa_$rsnnl (
				"Job in absentee slot ^d is not suspended.",
				answer, (0), i);
			     goto admin_answers;
			end;
			else
			     goto abs_bump_nomatch;

		if abs_funct = "suspend" then		/* if suspend */
		     if ute.sus_sent then		/* and job already suspended */
			if abs_args.absn_sw then
			     do;
			     call ioa_$rsnnl (
				"Job in absentee slot ^d is already suspended.",
				answer, (0), i);
			     goto admin_answers;
			end;
			else
			     goto abs_bump_nomatch;

/* This job has been selected. Put AUTBL slot number into message */

		ev_p -> xmessage.table_index = i;

/* Send wakeup to absentee user manager. It contains the slot number and the action to be taken. */

		call hcs_$wakeup (whotab.abs_procid, whotab.abs_event,
		     ev_p -> bf, code);
		k = k + 1;			/* count selected jobs */
abs_bump_nomatch:
	     end;					/* end loop thru aute's */

	     if abs_funct = "release"			/* if release */
		& ^(abs_args.absn_sw | abs_args.abs_star_sw) then
		do;				/* and a running job was not specified,
						   see if we need to release deferred job(s) */
		call absentee_utility_$abs_release (abs_arg_ptr, l);
						/* l is returned count of released jobs */
		if k + l = 0 then
		     do;				/* no jobs released */
		     answer =
			"Selection arguments matched no deferred or suspended absentee requests."
			;
		     goto admin_answers;
		end;
		else if k > 0 then
		     do;				/* one or more suspended jobs were released */
		     call ioa_$rsnnl ("^d suspended request^[s^] released.",
			answer, (0), k, (k ^= 1));
		     goto admin_replies;
		end;
	     end;
	     else
		do;				/* see if scan of AUT found any jobs */
		if autbl.n_abs_run = 0 then
		     do;
		     answer = "There are no absentee jobs running.";
		     goto admin_replies;
		end;
		else if k = 0 then
		     do;
		     answer =
			"Selection arguments matched no running absentee jobs."
			;
		     goto admin_answers;
		end;
	     end;

	end;					/* end ^cancel | absN */

	else
	     do;					/* abs cancel, and not absN */
	     call cancel_abs_request$as_abs (arg_list_ptr, nargs, fb71, code);
	     if code ^= 0 & fb71 ^= 0 then
		do;				/* a running job was cancelled, so we must bump it */
		do i = 1 to autbl.current_size
		     while (addr (autbl.entry (i)) -> ute.request_id ^= fb71)
		     ;
		end;
		if i <= autbl.current_size then
		     do;
		     ev_p -> xmessage.table_index = i;
		     call hcs_$wakeup (whotab.abs_procid, whotab.abs_event,
			ev_p -> bf, code);
		end;
	     end;
	end;
	goto admin_abs_returns;

/* code to initialize the absentee facility */
/* set max abs users */
/* signals absentee user manager so that it will */
/* attempt to login max abs users */

/* ********** abs start ********** */

abs_action (4):					/* ABS START */
	if (autbl.abs_up & autbl.abs_stopped) then
	     do;					/* If absentee is running down */
	     if autbl.n_abs_run > 0 then
		call ABORT_ABSENTEE_SHUTDOWN ();
	     call ipc_$delete_ev_chn (abs_stop_chn, code);
	     call absentee_user_manager_$term_aum;
	     autbl.abs_up, autbl.abs_stopped = ""b;	/* all finished, clear indicators */
	end;
	if goingdown then				/* If an automatic shutdown is scheduled, */
	     if (whotab.nextsd - clock ()) < abs_shut_interval * MILLION then
		do;
		answer = "system coming down soon: no abs start";
		go to admin_answers;
	     end;

	abs_start_at_startup = ""b;			/* gets turned on if "abs start startup" */
	call cu_$arg_ptr_rel (2, p, lng, code, arg_list_ptr);
						/* fetch second argument - max number of absentee users */
	if code ^= 0 then
	     do;					/* if no argument default values for max users + max queue */
	     if autbl.abs_up then
		do;				/* initialization of absentee non-reentrant */
abs_already_up:
		answer = "absentee already up";	/* abs start queue (checked for below) is allowed with abs up */
		go to admin_answers;
	     end;
default_u:
	     autbl.abs_maxu_auto = "1"b;		/* remember to set default maxu later */
default_q:
	     autbl.abs_maxq_auto = "1"b;		/* remember to set default maxq later */
	end;

	else if arg = "queue" | arg = "q" then
	     do;					/* trying to restart a previously dropped queue */
	     call cu_$arg_ptr_rel (3, p, lng, code, arg_list_ptr);
						/* get queue to be restarted */
	     if code ^= 0 then
		do;				/* if no q to restart given, print q status */
		if sum (autbl.qerr) = 0 & unspec (autbl.queue_dropped) = ""b
		then
		     call sys_log (SL_LOG,
			"^a: abs: Zero errors on all absentee queues.", ME);
		else
		     do;
print_dropped_queues:
		     temp_sw = (unspec (autbl.queue_dropped) ^= ""b);
						/* make temp_sw "1"b if any queues dropped */
		     call sys_log (SL_LOG,
			"^a: abs: Queue errors^[^x(*=dropped)^]:", ME, temp_sw);
		     call sys_log (SL_LOG, "^a: abs: FG^2x0^2x1^2x2^2x3^2x4", ME);
		     call sys_log (SL_LOG, "^a: abs:^6(^x^2d^)", ME, autbl.qerr);
		     if temp_sw then
			call sys_log (SL_LOG, "^a: abs:^6(^2x^[*^;^x^]^)",
			     ME, autbl.queue_dropped);
		end;
		goto admin_abs_returns;
	     end;

	     if ^(autbl.abs_up & ^autbl.abs_stopped) then
		do;				/* can only do this when absentee is up */
		answer = "absentee not up. cannot restart queue " || arg;
		goto admin_answers;
	     end;
	     if arg = "all" then
		do;
		autbl.qerr (*) = 0;
		autbl.queue_dropped (*) = ""b;
		goto nudge;
	     end;
	     else if arg = "fg" | arg = "foreground" then
		do;
		code = 0;
		i = -1;
	     end;
	     else
		i = cv_dec_check_ (arg, code);
	     if code = 0 then
		do;
		if i >= -1 & i <= absolute_max_queue then
		     do;
		     autbl.qerr (i) = 0;		/* clear error count for this queue */
		     autbl.queue_dropped (i) = ""b;
		     goto nudge;			/* go send wakeup to see if any jobs waiting to be run */
		end;
		else
		     code = 1;			/* any nonzero value, to get error message printed */
	     end;
	     if code ^= 0 then
		do;
		answer = "invalid queue to be restarted " || arg;
		goto admin_answers;
	     end;
	end;					/* end of abs start queue */

	else
	     do;					/* normal abs start */
	     if autbl.abs_up then
		goto abs_already_up;
	     if arg = "startup" then
		do;				/* if called by load_ctl_ at a.s. startup */
		abs_start_at_startup = "1"b;		/* remember that for later */
		goto default_u;			/* go turn on default switches for maxu and maxq */
	     end;
	     else
		do;
		call abs_maxu (arg);		/* set max users for absentee from value in command line */

		call cu_$arg_ptr_rel (3, p, lng, code, arg_list_ptr);
						/* fetch third argument - highest queue to be searched */
		if code ^= 0 then
		     go to default_q;		/* if no argument set default value in absentee user table */
		call abs_maxq (arg);		/* set max queue to be searched to value from command */
	     end;
	end;

	call absentee_user_manager_$init_aum (code);	/* call initialization entry point */
	if code ^= 0 then
	     go to admin_abs_returns;			/* message already printed */

	autbl.abs_up = "1"b;			/* set indicators correctly */
	autbl.abs_stopped = ""b;
	autbl.qerr (*) = 0;				/* clear per-queue error indicators */
	autbl.queue_dropped (*) = ""b;
	autbl.abs_qres_auto, autbl.abs_cpu_limit_auto = "1"b;
						/* assume defaults for these */

	if ^abs_start_at_startup then			/* if command was "abs start startup", this is a.s. startup */
						/* and we were called from load_ctl_$set_maxunits */
						/* of which load_ctl_$set_abs_parms is an entrypoint */
	     call load_ctl_$set_abs_parms;		/* if not called from load_ctl_, call load_ctl_ */

	if goingdown then				/* if a scheduled shutdown set up timer */
	     call SCHEDULE_ABSENTEE_SHUTDOWN ();

nudge:
	if autbl.max_abs_users > 0 | abs_start_at_startup then
						/* wakeup absentee user manager if slots */
	     call absentee_utility_$au_send_wakeup;
	go to admin_abs_returns;
%page;
abs_action (1):					/* ABS MAXU */
	if ^autbl.abs_up then
	     do;
abs_not_up:
	     answer = "absentee not up";
	     goto admin_answers;
	end;

	if autbl.abs_stopped then
	     goto abs_stopping;

	call cu_$arg_ptr_rel (2, p, lng, code, arg_list_ptr);
						/* get new max. abs. users from command */
	if code ^= 0 then
	     do;					/* if no argument, print current maxu */
	     call sys_log (SL_LOG, "^a: abs: maxu (^[auto^;manual^]): ^d",
		ME, autbl.abs_maxu_auto, autbl.max_abs_users);
	     goto admin_abs_returns;
	end;

	if arg = "auto" then
	     do;
	     autbl.abs_maxu_auto = "1"b;
	     call load_ctl_$set_abs_parms;
	     go to admin_abs_returns;
	end;
	else
	     call abs_maxu (arg);			/* set new value of max abs users */

	goto nudge;
%page;
/* set queue number which is highest queue searched */

/* ********** abs maxq ********** */

abs_action (2):					/* ABS MAXQ */
	if ^autbl.abs_up then
	     go to abs_not_up;
	if autbl.abs_stopped then
	     goto abs_stopping;

	call cu_$arg_ptr_rel (2, p, lng, code, arg_list_ptr);
						/* get new max queue from command */
	if code ^= 0 then
	     do;					/* if no argument, print current maxq */
	     call sys_log (SL_LOG, "^a: abs: maxq (^[auto^;manual^]): ^d",
		ME, autbl.abs_maxq_auto, autbl.last_queue_searched);
	     goto admin_abs_returns;
	end;

	if arg = "auto" then
	     do;
	     autbl.abs_maxq_auto = "1"b;
	     call load_ctl_$set_abs_parms;
	     go to admin_abs_returns;
	end;
	else
	     do;
	     call abs_maxq (arg);			/* set new max queue in absentee user table */
	     go to nudge;
	end;

/* ********** abs qres ********** */

abs_action (7):					/* ABS QRES */
	if ^autbl.abs_up then
	     goto abs_not_up;
	j = 0;					/* clear argument counter */
	qres (*) = 0;				/* default = 0 for any queue whose reservation is not specified */
	code = 0;					/* clear possible garbage, so the while clause always works */

	do i = 2 to 5 while (code = 0);		/* go thru up to 4 arguments */
	     call cu_$arg_ptr_rel (i, p, lng, code, arg_list_ptr);
	     if code = 0 then
		do;				/* if argument is there */
		qres (i - 1) = cv_dec_check_ (arg, code);
		if code ^= 0 | qres (i) < 0 then
		     do;				/* if not positive decimal number */
		     if arg = "auto" & nargs = 2 then
			;			/* it's ok if it's "auto" */
		     else
			do;			/* but anything else is an error */
			answer = "abs qres has invalid value: " || arg;
			goto admin_answers;
		     end;
		end;
		j = j + 1;			/* count valid arguments */
	     end;
	end;

	if nargs = 1 then				/* no args means print current values */
	     call sys_log (SL_LOG, "^a: abs: qres ^[^2x(auto)^;(manual)^]:^4(^x^2d^)",
		ME, autbl.abs_qres_auto, autbl.qres);
	else if arg = "auto" then
	     do;
	     autbl.abs_qres_auto = "1"b;
	     call load_ctl_$set_abs_parms;
	end;

	else
	     do;
	     autbl.abs_qres_auto = ""b;
	     autbl.qres (*) = qres (*);		/* copy them all, setting unspecified ones to zero */
	end;
	do i = 1 to 4;				/* compute the resulting limits */
	     qres (i) =
		available_slots_ (i, autbl.max_abs_users, (autbl.qres),
		four_zeros);
	end;
	call sys_log (SL_LOG, "^a: abs: queue^2xlimits:^4(^x^2d^)",
	     ME, qres);				/* and print them */
	if nargs > 1 then
	     if arg ^= "auto" then
		goto nudge;
	goto admin_abs_returns;

/* ********** abs cpu_limit ********** */

abs_action (8):					/* cpu_limit */
	if ^autbl.abs_up then
	     goto abs_not_up;
	call cu_$arg_ptr_rel (2, p, lng, code, arg_list_ptr);
	if code ^= 0 then				/* no arg means print current values */
	     call sys_log (SL_LOG,
		"^a: abs: cpu_limit (^[auto^;manual^]), queues 1-4: ^d^3(,^d^) (seconds)",
		ME, autbl.abs_cpu_limit_auto, autbl.cpu_limit);

	else if arg = "auto" then
	     do;
	     autbl.abs_cpu_limit_auto = "1"b;
	     call load_ctl_$set_abs_parms;
	end;

	else
	     do;
	     if nargs ^= 2 | verify (arg, "0123456789,") ^= 0 then
		do;
		answer =
		     "Usage is: ""abs cpu_limit l1,l2,l3,l4"" (limits in seconds)";
		goto admin_answers;
	     end;

	     i = 1;				/* start at char 1 of limit string */
	     do k = 1 to 4 while (i <= lng);		/* look for limits for 4 queues */
		j = index (substr (arg, i), ",");	/* find next comma */
		if j = 0 then
		     j = lng - i + 2;		/* if none, pretend one after end of string */
		if j > 1 then			/* if not adjacent commas, convert and store the value */
		     autbl.cpu_limit (k) =
			cv_dec_check_ (substr (arg, i, j - 1), (0));
		i = i + j;			/* move past the comma */
		if autbl.cpu_limit (k) < 60 then	/* check for a likely mistake */
		     call sys_log (SL_LOG,
			"^a: abs: Warning: cpu limits are in seconds. You just set queue ^d limit to ^d seconds.",
			ME, k, autbl.cpu_limit (k));
	     end;
	     autbl.abs_cpu_limit_auto = ""b;		/* remember it's set by operator */
	end;

	if nargs = 2 then
	     if arg ^= "auto" then
		goto nudge;
	goto admin_abs_returns;

/* ********** abs defer ********** */

abs_action (9):					/* defer */
	if ^autbl.abs_up then
	     goto abs_not_up;
	call parse_abs_args (arg_list_ptr);
	call validate_abs_args ("0"b, "0"b);		/* reject absN, don't require user */
	call absentee_utility_$abs_defer (abs_arg_ptr);
	goto admin_abs_returns;

/* ********** abs list ********** */

abs_action (10):					/* list */
						/* abs list works when absentee is not up */
	do j = 2 to nargs;				/* look for absN */
	     call cu_$arg_ptr_rel (j, p, lng, code, arg_list_ptr);
	     if code = 0 then
		do;
		if substr (arg, 1, 3) = "abs"
		     & verify (substr (arg, 4), "0123456789") = 0 then
		     do;				/* absN */
		     if ^autbl.abs_up then
			do;
			answer =
			     "The absN argument cannot be used when absentee is not up.";
			goto admin_answers;
		     end;
		     temp = substr (arg, 4);		/* align N */
		     j = cv_dec_check_ (temp, (0));
		     if j > autbl.current_size then
			do;			/* if N is too large, don't try to reference slot N */
			call ioa_$rsnnl ("No job in absentee slot ^d.",
			     answer, (0), j);
			goto admin_answers;
		     end;
		     utep = addr (autbl.entry (j));
		     if ute.active ^= NOW_HAS_PROCESS then
			do;
			call ioa_$rsnnl (
			     "No job in absentee slot ^d (status= ^d).",
			     answer, (0), j, ute.active);
			goto admin_answers;
		     end;
		     if ute.foreground_job then
			i = -1;
		     else if ute.adjust_abs_q_no then
			i = ute.queue - 1;
		     else
			i = ute.queue;
		     fb71 = ute.request_id;
		     j = nargs;			/* get out of the loop */
		end;
	     end;
	end;
	call list_abs_requests$abs_list (arg_list_ptr, nargs, fb71, i);
	goto admin_abs_returns;

/* ********** abs move ********** */

abs_action (11):					/* move */
						/* abs move works when absentee is not up */
	call cancel_abs_request$as_abs (arg_list_ptr, nargs, fb71, code);
	goto admin_abs_returns;

/* ********** abs next ********** */

abs_action (12):					/* next */
						/* abs next works when absentee is not up */
	call cancel_abs_request$as_abs (arg_list_ptr, nargs, fb71, code);
	goto admin_abs_returns;

/* ********** abs run ********** */

abs_action (14):					/* run */
	if ^autbl.abs_up then
	     goto abs_not_up;
	call parse_abs_args (arg_list_ptr);
	call validate_abs_args ("0"b, "1"b);		/* reject absN, require user */
	call absentee_user_manager_$aum_abs_run (abs_arg_ptr);
	goto admin_abs_returns;


/* ================================================= */

admin_err:
	call sys_log$error_log (SL_LOG, code, comname, answer);
	return;

admin_answers:
	call sys_log (SL_LOG, "^a: error: ^a", comname, answer);
	return;

admin_abs_returns:
	call absentee_user_manager_$update_whotab_abs_control;
	return;

admin_replies:					/* reply without saying "error:" */
	call sys_log (SL_LOG, "^a: ^a", comname, answer);
	return;					/* almost all entries exit here */
%page;
/* Internal Procedures */

get_mpx_name:
     proc (argno);

dcl  argno fixed bin;

	call cu_$arg_ptr_rel (argno, p, lng, code, arg_list_ptr);
	if code ^= 0 then
	     do;
	     if fnp_only then
		answer = "No FNP tag specified";
	     else
		answer = "No multiplexer specified";
	     go to admin_answers;
	end;

	mpx_name = arg;
	if fnp_only then
	     do;					/* extra checks to be compatable with old commands */
	     if length (rtrim (mpx_name)) > 1 then
		do;
bad_mpx_fnp_name:
		answer = "Invalid FNP tag: " || mpx_name;
		go to admin_answers;
	     end;
	     if index ("abcdefgh", substr (mpx_name, 1, 1)) = 0 then
		go to bad_mpx_fnp_name;
	end;

	return;

     end get_mpx_name;


/* ****************************************************************************************************************** */


validate:
     proc;

	if ^sc_stat_$Multics_typed then
	     as_data_$sysdir = sc_stat_$sysdir;
	if as_data_$ansp = null then
	     do;
	     call hcs_$initiate (sysdir, "answer_table", "", 0, 0, as_data_$ansp, code);
	     as_procid = get_process_id_ ();
	     if as_data_$ansp = null then
		do;
		call sys_log$error_log (SL_LOG_BEEP, code, ME,
		     "^a>answer_table", sysdir);
		return;
	     end;
	end;
	ansp = as_data_$ansp;
	autp = as_data_$autp;
	dutp = as_data_$dutp;

	if whoptr = null then
	     do;
	     call hcs_$initiate (sysdir, "whotab", "", 0, 0, whoptr, code);
	     if whoptr = null then
		call sys_log$error_log (SL_LOG_BEEP, code, ME, "^a>whotab",
		     sysdir);
	end;
	if ip = null then
	     do;
	     call hcs_$initiate (sysdir, "installation_parms", "", 0, 1, ip, code);
	     if ip = null then
		call sys_log$error_log (SL_LOG_BEEP, code, ME,
		     "^a>installation_parms", sysdir);
	end;
	if scdtp = null then
	     do;
	     call hcs_$initiate (sysdir, "cdt", "", 0, 1, scdtp, code);
	     if scdtp = null then
		call sys_log$error_log (SL_LOG_BEEP, code, ME, "^a>cdt",
		     sysdir);
	end;
	call cu_$arg_count_rel (arg_count, arg_list_ptr, (0));
						/* AF invocation not an issue */
	return;					/* end of setup */
     end validate;

/* ****************************************************************************************************************** */

abs_maxu:
     proc (l_arg);

dcl  l_arg char (*);

	i = cv_dec_check_ (l_arg, code);
	if code = 0 then				/* check legality */
	     if i >= 0 then
		if i <= divide (anstbl.max_units, 10, 17, 0) then
		     do;
		     autbl.abs_maxu_auto = ""b;
		     autbl.max_abs_users = i;
		     whotab.max_abs_users = i;
		     return;
		end;
	if code ^= 0 then
	     answer = "abs maxusers must be numeric or ""auto"": " || l_arg;
	else if i < 0 then
	     answer = "abs maxusers may not be negative: " || l_arg;
	else
	     answer =
		"abs maxusers may not be greater than system maxusers: " || l_arg;
	go to admin_answers;
     end abs_maxu;

/* ****************************************************************************************************************** */

abs_maxq:
     proc (l_arg);

dcl  l_arg char (*);

	i = cv_dec_check_ (l_arg, code);
	if code = 0 then				/* check legality */
	     if i >= 0 then
		if i <= absolute_max_queue then
		     do;
		     autbl.abs_maxq_auto = ""b;
		     autbl.last_queue_searched = i;
		     return;
		end;
	answer = "abs maxqueue has invalid value: " || l_arg;
	go to admin_answers;
     end abs_maxq;

/* ****************************************************************************************************************** */

build_string:
     proc (arg_list_ptr, an);

dcl  arg_list_ptr pointer;

dcl  an fixed bin;					/* arg no to start from */

dcl  i fixed bin;

	i = an;
	call cu_$arg_ptr_rel (i, p, lng, code, arg_list_ptr);
	if code ^= 0 then
	     go to admin_err;
	string = arg;
	strl = lng;
bld:
	i = i + 1;
	call cu_$arg_ptr_rel (i, p, lng, code, arg_list_ptr);
	if code ^= 0 then
	     return;
	substr (string, strl + 2) = arg;
	strl = strl + 1 + lng;
	if strl > length (string) then
	     return;
	go to bld;

     end build_string;
%page;
/* Internal procedure to do the work of the STOP command.
   Called by the STOP command and the timer for the DOWN command. */

stop_command:
     procedure ();

	if stopflag then
	     return;				/* ignore subsequent stop commands */
	stopflag = "1"b;				/* prevent resignal */

	whotab.nextsd = 0;				/* a shutdown will prevent restoring */
	call SET_LOGIN_WORD ("shutdown");		/* ok, no more logins. Set dialup message */

	if anstbl.n_users = 0 then			/* ready to shut down already? */
	     call sys_log (SL_LOG, "^a: stop: All users are out. You may shut down.", ME);
	else
	     do;					/* Bump everyone still on */
	     call convert_status_code_ (as_error_table_$sys_down_msg, shortinfo,
		longinfo);
	     if whotab.until = 0 then
		string = "";
	     else
		do;
		msg = date_time_$format ("date_time", whotab.until, "", "");
		call convert_status_code_ (as_error_table_$try_again_at_msg,
		     shortinfo, longinfo1);
		call ioa_$rsnnl (longinfo1, string, i, msg);
	     end;
	     call ioa_$rs (longinfo, prefix, i, string);

	     continue = "1"b;
	     string = substr (prefix, 1, i - 1);

	     do i = 1 to anstbl.current_size while (continue); /* everybody out of the pool */
		utep = addr (anstbl.entry (i));
		if ute.active >= NOW_LOGGED_IN
		then call PROCESS_UTE (action_flag);
	     end;

	     if ^action_flag
	     then call sys_log (SL_LOG,
		     "^a: stop: There were no active users to be bumped.", ME);
	     else call sys_log (SL_LOG,
		     "^a: stop: all users have been given ^d minutes to logout",
		     ME, divide (installation_parms.warning_time, SECS_IN_MIN, 17, 0));
	end;

	return;


PROCESS_UTE:
	procedure (P_action_flag);

/* *** This procedure is used to perform the desired action on the
   specified ute.  The action is specified via the variable "action". */

dcl  P_action_flag bit (1) aligned parameter;

	     if ute.at.nobump
	     then do;
		call sys_log (SL_LOG, "^a: ^a: ^a.^a has ""nobump""", ME, comname,
		     ute.person, ute.project);
		if ^ute.uflags.disconnected
		then call asu_$blast_user (utep, "Bump attempted.  " ||
			string, (""), (0));
		return;
	     end;

	     call asu_$bump_user (utep, string, code,
		installation_parms.warning_time);

/* *** This tells the operator what we did and sets the flag saying that
   we did something. */

	     call sys_log (SL_LOG, "^a: bump: ^a.^a bumped.", ME, ute.person, ute.project);
	     P_action_flag = "1"b;			/* remember we did one */
	     return;

	end PROCESS_UTE;

     end stop_command;

%page;

parse_abs_args:
     proc (arg_list_ptr);				/* fills in abs_args structure from job selection args */

dcl  arg_list_ptr pointer;

dcl  an fixed bin;					/* arg number */
dcl  expecting fixed bin init (0);			/* if nonzero, which arg value are we expecting */
dcl  prev_arg char (20);				/* previous argument, for use in error messages */
dcl  ctl_arg_given bit (1) aligned init (""b);
						/* 1 if any control args have been processed */
dcl  USER fixed bin int static
	options (constant) init (1);
						/* values for expecting */
dcl  ID fixed bin int static
	options (constant) init (2);
dcl  ENTRY fixed bin int static
	options (constant) init (3);
dcl  SENDER fixed bin int static
	options (constant) init (4);
dcl  QUEUE fixed bin int static
	options (constant) init (5);

	unspec (abs_args) = ""b;			/* clear out argument structure */
	do an = 2 to nargs;				/* skip first arg, which is command keyword */
	     call cu_$arg_ptr_rel (an, p, lng, code, arg_list_ptr);
	     if code ^= 0 then
		goto admin_err;

	     if substr (arg, 1, 1) = "-" then
		do;				/* a control argument */
		if expecting > 0 then
		     do;				/* but if we were expecting a value, complain */
		     call sys_log$error_log (SL_LOG, error_table_$noarg, comname,
			"After ^a.", prev_arg);
		     return;
		end;

		if arg = "-user" then
		     expecting = USER;
		else if arg = "-id" then
		     expecting = ID;
		else if arg = "-et" | arg = "-entry" then
		     expecting = ENTRY;
		else if arg = "-sender" then
		     expecting = SENDER;
		else if arg = "-q" | arg = "-queue" then
		     expecting = QUEUE;
		else if arg = "-fg" | arg = "-foreground" then
		     do;				/* equivalent to -q foreground */
		     if abs_args.queue_sw then
			do;
multiple_abs_qualifiers:
			answer =
			     "More than one specification of an attribute is present: "
			     || arg;
			go to admin_answers;
		     end;
		     abs_args.queue_sw = "1"b;
		     abs_args.queue = -1;
		end;
		else
		     do;
		     answer = "Invalid abs job selection argument: " || arg;
		     goto admin_answers;
		end;
		prev_arg = arg;			/* save this arg in case of error with next one */
		ctl_arg_given = "1"b;		/* remember not to allow any more positional args */
	     end;					/* end control arg */

	     else if expecting > 0 then
		do;				/* expecting something; pick up value in appropriate way */
		if expecting = USER then
		     call get_user (arg_list_ptr);
		else if expecting = ID then
		     call get_id;
		else if expecting = ENTRY then
		     do;
		     if abs_args.entry_sw then
			go to multiple_abs_qualifiers;
		     abs_args.entry_sw = "1"b;
		     abs_args.ename = arg;
		end;
		else if expecting = SENDER then
		     do;
		     if abs_args.sender_sw then
			go to multiple_abs_qualifiers;
		     abs_args.sender_sw = "1"b;
		     abs_args.sender = arg;
		end;
		else if expecting = QUEUE then
		     do;
		     if abs_args.queue_sw then
			go to multiple_abs_qualifiers;
		     abs_args.queue_sw = "1"b;
		     if arg = "fg" | arg = "foreground" then
			abs_args.queue = -1;
		     else
			do;
			temp = arg;		/* align arg */
			abs_args.queue = cv_dec_check_ (temp, code);
			if code ^= 0 then
			     do;
			     answer = "Invalid queue number " || arg;
			     goto admin_answers;
			end;
		     end;
		end;
		expecting = 0;
	     end;

	     else if substr (arg, 1, 3) = "abs" then
		do;
		if abs_args.absn_sw | abs_args.abs_star_sw then
		     go to multiple_abs_qualifiers;
		if verify (substr (arg, min (4, length (arg))), DIGITS) = 0 then
		     do;				/* absN */
		     abs_args.absn_sw = "1"b;
		     temp = substr (arg, 4);		/* align N */
		     abs_args.aut_index = cv_dec_check_ (temp, (0));
		end;

		else if arg = "abs*" then		/* abs* means all running jobs */
		     abs_args.abs_star_sw = "1"b;
	     end;

	     else if substr (arg, 1, 1) = ">" then
		do;				/* pathname */
		if abs_args.path_sw then
		     go to multiple_abs_qualifiers;
		abs_args.path_sw = "1"b;
		call expand_pathname_ (arg, abs_args.dirname, abs_args.ename,
		     code);
		if code ^= 0 then
		     do;
		     answer = arg;
		     goto admin_err;
		end;
	     end;

	     else if an > 3 | ctl_arg_given then
		do;				/* if n.o.t.a., and positional args no longer allowed, complain */
full_path_required:					/* come here from below if positional arg has wrong format */
		answer = "Relative pathnames not allowed: " || arg;
		goto admin_answers;
	     end;
	     else if verify (arg, "0123456789.") = 0 then /* just digits and dot must be request ID */
		call get_id;
	     else if index (CAPITALS, substr (arg, 1, 1)) ^= 0
						/* if it begins with capital, could be user name */
		| substr (arg, 1, 1) = "*" then	/* and * is also legal as user name */
		call get_user (arg_list_ptr);
	     else
		goto full_path_required;		/* else assume it's a pathname and reject it */
	end;

	if abs_args.entry_sw | abs_args.path_sw then
	     do;					/* check on absin suffix */
	     i = length (rtrim (abs_args.ename));
	     if substr (abs_args.ename, max (1, i - 5), 6) ^= ".absin" then
						/* if suffix missing */
		if substr (abs_args.ename, i, 1) ^= "*" then
						/* avoid screwing up starnames */
		     if i < 27 then			/* or running off the end of the string */
			substr (abs_args.ename, i + 1, 6) = ".absin";
						/* add the suffix */
	end;

	return;

/* ---------- */

get_id:
	proc;
	     if abs_args.id_sw then
		go to multiple_abs_qualifiers;
	     abs_args.id_sw = "1"b;
	     abs_args.request_id_string = arg;
	     return;

	end get_id;

/* ---------- */

get_user:
	proc (arg_list_ptr);
dcl  arg_list_ptr pointer;

	     if abs_args.user_sw then
		go to multiple_abs_qualifiers;
	     abs_args.user_sw = "1"b;
	     abs_args.person = before (arg, ".");
	     abs_args.project = before (after (arg, "."), ".");
	     if abs_args.person = "" then
		abs_args.person = "*";
	     if abs_args.project = "" then
		do;				/* allow operator to forget dot between person and project */
		call cu_$arg_ptr_rel (an + 1, p, lng, code, arg_list_ptr);
						/* look for project in next arg */
		if code = 0 then
		     do;				/* if there is a next arg */
		     if lng <= 9
			& (index (CAPITALS, substr (arg, 1, 1)) ^= 0 | arg = "*")
		     then
			do;			/* if it could be proj name */
			abs_args.project = arg;	/* assume it is */
			an = an + 1;		/* and move past this arg */
		     end;
		end;
	     end;
	     if abs_args.project = " " then
		abs_args.project = "*";		/* if no project name anywhere, assume * */
	     return;

	end get_user;

     end parse_abs_args;
%page;
validate_abs_args:
     proc (absn_ok, user_rqd);			/* see if abs args are ok for this abs command */

dcl  absn_ok bit (1) aligned;				/* 1 of absN arg accepted by this command */
dcl  user_rqd bit (1) aligned;			/* 1 if user name required by this command */

	if unspec (abs_args.arg_switches) = ""b then
	     do;					/* if no args were given, complain */
	     answer = "No job selection arguments given.";
	     goto admin_answers;
	end;

	if user_rqd then
	     do;					/* if command requires user name */
	     if ^abs_args.user_sw then
		do;
		answer = "User name must be given.";
		goto admin_answers;
	     end;
	     else if abs_args.person = "*" then
		do;
		answer = "User name (not ""*"") must be given.";
		goto admin_answers;
	     end;
	end;

	if ^absn_ok then
	     if abs_args.absn_sw then
		do;
		answer = "The absN argument is not valid.";
		goto admin_answers;
	     end;

	return;

     end validate_abs_args;
%page;
get_pers_proj:
     proc (arg_list_ptr, a_ix, P_new_arg_index, code);

/* *** Accept command arguments "Person.Project" or "Person Project"
   from the argument list begining at argument a_ix and update
   set P_new_arg_index to the index the next argument.  A number of
   checks are made unless the brief entry is called. */

dcl  P_new_arg_index fixed bin (17) parameter;
dcl  a_ix fixed bin parameter;
dcl  arg_list_ptr pointer;
dcl  code fixed bin (35);				/* ^= 0 --> print a usage message */

dcl  flag bit (1) aligned;

	flag = "1"b;
	go to get_pp_common;

get_pers_proj$$brief:
     entry (arg_list_ptr, a_ix, P_new_arg_index, code);

	flag = "0"b;

get_pp_common:
	P_new_arg_index = a_ix;			/* initialize argument index */
	wpers, wproj = "";
	call cu_$arg_ptr_rel (P_new_arg_index, p, lng, code, arg_list_ptr);
	if code ^= 0 then
	     return;
	if index (arg, ".") ^= 0 then
	     do;
	     wpers = before (arg, ".");
	     wproj = after (arg, ".");
	     if flag then
		if length (rtrim (wpers)) > 22 then
LONG_PERSON:
		     do;
		     call ioa_$rsnnl ("Personid ^a > 22 characters.", answer,
			(0), wpers);
		     go to admin_answers;
		end;
	     if wproj = "" then
BAD_PP:
		do;
		call ioa_$rsnnl ("^a is not a valid Person.Project.", answer,
		     (0), arg);
		go to admin_answers;
	     end;
	end;
	else
	     do;
	     wpers = arg;
	     if flag then
		if length (rtrim (wpers)) > 22 then
		     go to LONG_PERSON;
	     P_new_arg_index = P_new_arg_index + 1;
	     call cu_$arg_ptr_rel (P_new_arg_index, p, lng, code, arg_list_ptr);
	     if code ^= 0 then
		go to BAD_PP;			/* Read this as bad per.proj rather than missing proj in per proj. */
	     wproj = arg;
	end;
	if length (rtrim (wproj)) > 9 then
	     if flag then
		do;
		call ioa_$rsnnl ("Projectid ^a is longer than 9 characters.",
		     answer, (0), wproj);
		go to admin_answers;
	     end;
	P_new_arg_index = P_new_arg_index + 1;
	return;

     end get_pers_proj;
%page;
set_non_command_sys_loggers:
     procedure;

	sys_log = sys_log_;
	sys_log$error_log = sys_log_$error_log;
	return;
     end set_non_command_sys_loggers;
%page;
SCHEDULE_ABSENTEE_SHUTDOWN:
     procedure ();

/* *** This procedure schedules an absentee shutdown. */

dcl  time fixed bin (71) automatic;
						/* temporary */
dcl  time_str char (48) automatic;
						/* temporary */

	call ipc_$create_ev_chn (abs_stop_chn, (0));
	call ipc_$decl_ev_call_chn (abs_stop_chn, admin_$absentee_down, null,
	     SHUTDOWN_PRIO, (0));
	time = whotab.nextsd - (abs_shut_interval - abs_shut_offset) * MILLION;
	call timer_manager_$alarm_wakeup (time, "00"b, abs_stop_chn);
	time_str = date_time_$format ("date_time", time, "", "");
	call sys_log (SL_LOG, "^a: abs: auto abs stop will be at ^a", ME, time_str);
	return;

     end SCHEDULE_ABSENTEE_SHUTDOWN;
%page;
CHECK_FOR_ABSENTEE_SHUTDOWN:
     procedure ();

/* *** This procedure is called to check to see if all absentee processes
   have logged out in preparation for an absentee shutdown.  If they
   have, we shut down the absentee facility and perform a non-local
   goto to admin_abs_returns (ugh). */

	if ^autbl.abs_stopped then			/* we have cancelled the shutdown */
	     return;

	if autbl.n_abs_run = 0 then			/* check that all absentee processes have logged out */
	     do;
	     call sys_log (SL_LOG,
		"^a: abs: All absentee processes have run to completion.", ME);
	     call ipc_$delete_ev_chn (abs_stop_chn, code);/* delete event channel created */
	     call absentee_user_manager_$term_aum;	/* close out absentee facility */
	     autbl.abs_up = ""b;			/* indicate that absentee is down */
	     call absentee_user_manager_$update_whotab_abs_control ();
	end;

/* if an extra-ordinary amount of time has elapsed since abs stop */
/* and there are still absentee processes, bump them */

	else if n_called > abs_shut_interval then
	     do;
	     call sys_log (SL_LOG,
		"^a: abs: Bumping all remaining absentee processes.", ME);
	     if sys_log = sys_log_ then		/* we are NOT a command */
		call admin_$abs_not_a_command_ ("bump", "*", "*");
	     else
		call admin_$abs ("bump", "*", "*");
	     call absentee_user_manager_$update_whotab_abs_control ();
	end;

	else					/* otherwise, check again in 30 seconds */
	     call timer_manager_$alarm_wakeup (30, "11"b, abs_stop_chn);
	return;

     end CHECK_FOR_ABSENTEE_SHUTDOWN;
%page;
START_ABSENTEE_SHUTDOWN:
     procedure ();

/* *** This procedure is called to start shutting down the absentee
   facility. */

	saved_max_abs_users = autbl.max_abs_users;	/* remember in case we must
						   reset */
	whotab.max_abs_users,			/* set max abs users to -1 in whotab */
	     autbl.max_abs_users = -1;		/* and in absentee user table */
	autbl.abs_stopped = "1"b;			/* record fact that absentee is being shutdown */
	saved_abs_maxu_auto = autbl.abs_maxu_auto;	/* remember in case we must reset */
	autbl.abs_maxu_auto = ""b;			/* tell load_ctl_ not to change abs maxu */

/* *** reuse the event channel for our own internal timer.  It will
   allow us to check every 30 seconds to ensure all processes are
   logged out before we shut down. */

	call ipc_$decl_ev_call_chn (abs_stop_chn, admin_$absentee_off, null (),
	     SHUTDOWN_PRIO, code);

/* *** Check to see if all absentee processes are done yet.  If not, schedule
   a check every 30 seconds. */

	call CHECK_FOR_ABSENTEE_SHUTDOWN ();
	return;
     end START_ABSENTEE_SHUTDOWN;
%page;
NOTIFY_USERS_OF_SHUTDOWN_TIME_CHANGE:
     procedure ();

/* *** This procedure sends a system_shutdown_scheduled_ IPS signal to all
   interactive, absentee, and daemon users on the system. */

dcl  ute_index fixed bin;

	dutp = as_data_$dutp;
	do ute_index = 1 to dutbl.current_size;
	     utep = addr (dutbl.entry (ute_index));
	     if ute.active > NOW_LOGGED_IN then
		call hphcs_$ips_wakeup (ute.proc_id,
		     "system_shutdown_scheduled_");
	end;

	autp = as_data_$autp;
	do ute_index = 1 to autbl.current_size;
	     utep = addr (autbl.entry (ute_index));
	     if ute.active > NOW_LOGGED_IN then
		call hphcs_$ips_wakeup (ute.proc_id,
		     "system_shutdown_scheduled_");
	end;

	do ute_index = 1 to anstbl.current_size;
	     utep = addr (anstbl.entry (ute_index));
	     if ute.active > NOW_LOGGED_IN then
		call hphcs_$ips_wakeup (ute.proc_id,
		     "system_shutdown_scheduled_");
	end;
     end NOTIFY_USERS_OF_SHUTDOWN_TIME_CHANGE;
%page;
SCHEDULE_SYSTEM_SHUTDOWN:
     procedure (P_shutdown_time, P_shutdown_reason, P_down_until_time);

/* *** This procedure schedules a system shutdown.  */

dcl  P_shutdown_time fixed bin (71) parameter;
						/* when we're shutting down */
dcl  P_shutdown_reason char (*) parameter;		/* why */
dcl  P_down_until_time fixed bin (71) parameter;
						/* when we'll be back up */

	whotab.nextsd = P_shutdown_time;		/* publish the shutdown time */
	whotab.obsolete_why =
	     substr (P_shutdown_reason, 1, length (whotab.obsolete_why));
	whotab.why = P_shutdown_reason;
	whotab.until = P_down_until_time;

	call ipc_$create_ev_chn (auto_bump_chn, (0));
	call ipc_$decl_ev_call_chn (auto_bump_chn, admin_$timed_stop_command, null,
	     SHUTDOWN_PRIO, (0));
	call timer_manager_$alarm_wakeup (whotab.nextsd
	     - installation_parms.warning_time * MILLION, "00"b, auto_bump_chn);

	goingdown = "1"b;				/* indicate that a shutdown has been scheduled */

	msg = date_time_$format ("date_time", whotab.nextsd, "", "");
	call sys_log (SL_LOG, "^a: down: auto shutdown will be at ^a", ME, msg);

	if autp ^= null then
	     if autbl.abs_up then
		do;				/* if absentee running */
		call SCHEDULE_ABSENTEE_SHUTDOWN ();
		call absentee_user_manager_$update_whotab_abs_control ();
	     end;

/* *** And make sure we tell all the users of the new shutdown time */

	call NOTIFY_USERS_OF_SHUTDOWN_TIME_CHANGE ();
	return;
     end SCHEDULE_SYSTEM_SHUTDOWN;
%page;
CANCEL_SYSTEM_SHUTDOWN:
     procedure (P_message, P_code);

/* *** This procedure is called to cancel a system shutdown.  It also
   cancels the absentee shutdown if it has not already been performed. */

dcl  P_message char (*) parameter;			/* reason why we didn't. */
dcl  P_code fixed bin (35) parameter;
						/* status code */

	if whotab.nextsd = 0 then
	     do;					/* no shutdown scheduled */
	     P_message = "no system shutdown scheduled";
	     P_code = error_table_$action_not_performed;
	end;
	else
	     do;					/* there is a shutdown scheduled */
	     call timer_manager_$reset_alarm_wakeup (auto_bump_chn);
	     goingdown = "0"b;			/* static flag */
	     whotab.nextsd = 0;			/* change whotab to show no shutdown expected */
	     whotab.message = "";
	     whotab.obsolete_message = "";
	     whotab.until = 0;
	     if autp ^= null () then
		if autbl.abs_up then		/* if absentee running */
		     do;
		     call timer_manager_$reset_alarm_wakeup (abs_stop_chn);
						/* cancel automatic abs stop */
		     if autbl.abs_stopped then
			call ABORT_ABSENTEE_SHUTDOWN ();
		end;
	     call NOTIFY_USERS_OF_SHUTDOWN_TIME_CHANGE ();
	end;
	return;
     end CANCEL_SYSTEM_SHUTDOWN;
%page;
ABORT_ABSENTEE_SHUTDOWN:
     procedure ();

/* *** This procedure is called to cancel an absentee shutdown which has
   already started.  That is, when we have already started waiting for
   absentees to complete before really shutting the absentee facility
   down. */

	autbl.abs_stopped = "0"b;			/* turn off this flag */
	autbl.abs_maxu_auto = saved_abs_maxu_auto;	/* restore saved values */
	autbl.max_abs_users,			/* restore saved values */
	     whotab.max_abs_users = saved_max_abs_users;
	return;
     end ABORT_ABSENTEE_SHUTDOWN;
%page;
SET_LOGIN_WORD:
     procedure options (variable);
	arg_list_ptr = cu_$arg_list_ptr ();

	call validate;				/* locate answer table */
	call cu_$arg_ptr_rel (1, p, lng, code, arg_list_ptr);
						/* get the new login word */
	if code ^= 0 then
	     do;
	     lng = max (0, anstbl.message_lng - 1);	/* set length of message to omit trailing newline */
	     call sys_log (SL_LOG,
		"^a: word: ^a; ^a message: ^[^a^;"""" (NO MESSAGE)^]",
		ME, anstbl.login_word, anstbl.session, (anstbl.message_lng > 1),
		based_anstbl_message);
	     return;
	end;
	if lng > 8 then
	     do;					/* check length */
	     call sys_log (SL_LOG,
		"^a: word: length of login-word must not exceed 8 characters", ME);
	     return;
	end;
	do i = 3 to hbound (as_data_login_words.words, 1)
	     while (arg ^= as_data_login_words.words (i));
	end;
	if i <= hbound (as_data_login_words.words, 1) then
	     do;					/* Cannot use special word as login word */
	     call sys_log (SL_LOG, "^a: word: ^a is a reserved word.", ME, arg);
	     return;
	end;
	anstbl.login_word = arg;			/* change the login word */
	call cu_$arg_ptr_rel (2, p, lng, code, arg_list_ptr);
						/* ??? */
	if code = 0 then
	     do;					/* if message given on command line */
	     call build_string (arg_list_ptr, 2);	/* build up message */
	     if strl > length (anstbl.special_message) then
		do;
		strl = length (anstbl.special_message);
		call sys_log (SL_LOG,
		     "^a: word: message truncated; maximum length is ^d characters",
		     ME, strl);
	     end;
	     anstbl.special_message = substr (string, 1, strl);
						/* set dialup buffer */
	     anstbl.message_lng, lng = strl;		/* and length */
	end;
	else
	     lng = 0;				/* no buffer set */
	if anstbl.login_word = as_data_login_words.words (1) then
						/* "l" */
	     go to wordl;				/* Normal session? */
	if anstbl.login_word = as_data_login_words.words (2) then
						/* "login" */
	     do;
wordl:
	     stopflag = "0"b;			/* yes. cancel stop */
	     anstbl.session, whotab.session = "normal";	/* allow logins to proceed */
	     if lng = 0 then
		do;
		anstbl.message_lng = 0;		/* if changed word, reset buffer */
		anstbl.special_message = "";
	     end;
	end;
	else
	     do;					/* not normal session */
	     anstbl.session, whotab.session = "special";	/* assume special */
	     if lng = 0 then
		do;				/* if no message specified */
		if anstbl.login_word = "shutdown" then
		     do;				/* if shutting down */
		     call convert_status_code_ (as_error_table_$sys_down_msg,
			shortinfo, longinfo);
		     if whotab.until = 0 then
			string = "";		/* if not specified when come up */
		     else
			do;			/* can say when to try again */
			day_back =
			     date_time_$format ("^yc^my^dm", whotab.until, "", "");
			day_now =
			     date_time_$format ("^yc^my^dm", clock (), "", "");

			if day_back = day_now	/* days different? */
			then msg = date_time_$format ("time", whotab.until, "", "");
			else msg = date_time_$format ("date_time", whotab.until, "", "");

			call convert_status_code_ (
			     as_error_table_$try_again_at_msg, shortinfo,
			     longinfo1);
			call ioa_$rsnnl (longinfo1, string, i, msg);
		     end;
		     call ioa_$rsnnl (longinfo, anstbl.special_message, i,
			string);
		end;
		else
		     do;				/* special session not shutdown */
		     call convert_status_code_ (as_error_table_$special_sess_msg,
			shortinfo, longinfo);
		     anstbl.special_message = longinfo;
		end;				/* end special session */
		anstbl.message_lng = length (rtrim (anstbl.special_message));
	     end;
	end;					/* end not normal session */
	if anstbl.login_word = "shutdown" then
	     do;
	     anstbl.session, whotab.session = "shutdown";
	     fb71 = clock ();
	     b12 = substr (unspec (fb71), 34, 12);
	     call ioa_$rsnnl ("^4.3b", c4, (0), b12);
	     anstbl.login_word = c4;
	end;
	if anstbl.message_lng > 0 then
	     do;					/* if there is a message, print it for operator */
	     call sys_log (SL_LOG, "^a: word: ^a message: ^a", ME, anstbl.session,
		substr (anstbl.special_message, 1, anstbl.message_lng));
	     anstbl.message_lng =
		min (anstbl.message_lng + 1, length (anstbl.special_message));
	     substr (anstbl.special_message, anstbl.message_lng, 1) = NL;
	end;

	call dialup_$re_introduce;			/* say hello again */

/* *** Update the "time of last message update" so that the login servers
   will notice the change and redisplay the login banner */

	anstbl.message_update_time = clock ();
	return;
     end SET_LOGIN_WORD;
%page;

/* format: off */
%page; %include abs_args;
%page; %include absentee_user_table;
%page; %include answer_table;
%page; %include as_data_;
%page; %include as_data_definitions_;
%page; %include as_wakeup_priorities;
%page; %include author_dcl;
%page; %include cdt;
%page; %include daemon_user_table;
%page; %include dialup_values;
%page; %include installation_parms;
%page; %include sc_stat_;
%page; %include sc_subsystem_info_;
%page; %include sys_log_constants;
%page; %include user_attributes;
%page; %include user_table_entry;
%page; %include user_table_header;
%page; %include whotab;
%page;
/* BEGIN MESSAGE DOCUMENTATION

   Message:
   admin_: down: No shutdown is scheduled.

   S:	$as1

   T:	In response to an operator down command.

   M:	The operator issued a down 0 command to reset a scheduled
   automatic shutdown when none was in effect.  No action was taken
   on the command.

   A:	$ignore

   Message:
   admin_: down: Next shutdown from DATE_TIME to DATE_TIME1 REASON

   S:	$as1

   T:	Response to an operator "down" command.

   M:	This message tells when the next scheduled shutdown is.

   A:	$ignore

   Message:
   admin_: down: resetting previous shutdown at MM/DD/YY HHMM.T

   S:	$as1

   T:	In response to an operator down command.

   M:	A second down command has been issued before a previously
   issued down command has been executed.  The new shutdown time is
   honored instead of the previous one.

   A:	$ignore

   Message:
   admin_: stop: Automatic shutdown

   S:	$as1

   T:	$shut

   M:	A down command issued earlier has taken effect.  An
   automatic stop command is executed.  All users are
   bumped in three minutes.

   A:	Prepare to shut down the system.

   Message:
   admin_: warn: NAME.PROJ has "no_warning"

   S:	$as1

   T:	Response to operator warn command.

   M:	This is the response to the command "warn NAME PROJ
   Message..." if the user has specified the -no_warning argument
   at login.  The message is not sent to the user.

   A:	Attempt to contact the user by other means.

   Message:
   admin_: warn: USER.PROJ not connected to a channel

   S:     as (sevreity1)

   T:     Response to operator warn command.

   M:     This is the response to the command "warn NAME PROJ Message"
   if the pointer to the channel table entry in the user table entry
   for the named user (ute.cdtep) is not set (null).  The message cannot be
   sent to the user.

   A:	Attempt to contact the user by other means.

   Message:
   admin_: warn: NAME.PROJ not found.

   S:	$as1

   T:	In response to an operator warn command.

   M:	The warn command was issued for a nonexistent user.  No
   action was taken.

   A:	The user is probably not logged in.  Check the spelling of
   the name.  $tryagain

   Message:
   admin_: log: MESSAGE

   S:	$as0

   T:	$run

   M:	The log command simply enters its arguments in the system log.
   It is occasionally used by
   operators and system programmers to record events.

   A:	$ignore

   Message:
   admin_: maxu: (MMMM): UUUU (DDDD normal users)
   
   S:	$as1

   T:     When operator entered "maxu" command.

   M:     This is an informative message indicating the current values
   manipulated by the maxu command.  MMMM is the mode, "auto" or "level".
   UUUU is the load units in tenths.  DDDD is the load units in whole numbers.

   A:     $ignore

   Message:
   admin_: maxu: Warning: maxunits are in tenths of load units.
   .brf
             You just set maxu to UUUU, or DDDD normal users.

   S:	$as1

   T:     When operator entered a maxu command line that specified < 200 load
   units or 20 normal users.

   M:     This message is a warning to the operator that he may have made a
   mistake in setting the load units of the system.  A normal system is not
   likely to set its maximum load units to less than 200.

   A:     Take corrective action (reenter the command with corrected
   arguments).

   Message:
   admin_: shift: N until DATE_TIME

   S:	$as1

   T:	response to an operator "shift" command.

   M:	The operator has issued the shift command.
   If issued with no arguments this command types the current setting.
   If issued with arguments,
   the command changes the shift and types the new value.

   A:	$ignore

   Message:
   admin_: ERROR_MESSAGE SYSDIR>absentee_user_table

   S:	$as1

   T:     When operator entered abs command.

   M:     The ERROR_MESSAGE gives reason why system was not able to find or
   access the absentee_user_table in the SYSDIR directory.  Execution of the
   command was not completed.

   A:     %inform

   Message:
   admin_: abs: absentee not up, and will not be started automatically

   S:	$as1

   T:     When operator entered "abs stop" before absentee facility was
   started.

   M:     The command can be entered at standard to prevent the absentee
   facility from starting up automatically after a "startup" command is used.

   A:     $ignore

   Message:
   admin_: abs: resetting auto abs stop

   S:	$as1

   T:	In response to an operator abs stop command.

   M:	An abs stop command overrides an automatic abs stop
   that was set up by a down command.

   A:	$ignore

   Message:
   admin_: stop: auto abs stop

   S:	$as1

   T:	$run

   M:	It is 30 minutes before an automatic stop, so an automatic
   abs stop command is being issued.  This is the result of a previous
   down command.  Refer also to the stop command description.

   A:	$ignore

   Message:
   admin_: abs: Zero errors on all absentee queues.

   S:	$as1

   T:     In response to "abs queue" operator command.

   M:     Informative message which indicates that no queue has been dropped
   and no errors recorded for any queue.

   A:     $ignore

   Message:
   admin_: abs: Queue errors (*=dropped):
   .brf
   admin_: abs: FG  0  1  2  3  4
   .brf
   admin_: abs: TT VV WW XX YY ZZ
   .brf
   admin_: abs:  *  *  *  *  *  *

   S:	$as1

   T:     In response to "abs queue" operator command.

   M:     Displays the errors for each queue and indicates which one has been
   dropped.  If none have been dropped, the last line will not be displayed nor
   will the string "(*=dropped)" appear in the first line.

   A:     $inform

   Message:
   admin_: abs: maxu (MMMM): UUUU

   S:	$as1

   T:     In response to "abs maxu" operator command without arguments.

   M:     Informative message indicating current status of maxu and maximum
   absentee users allowed.  MMMM is the mode, "auto" or "manual".  UUUU is the
   load_units.

   A:     $ignore

   Message:
   admin_: abs: maxq (MMMM): Q

   S:	$as1

   T:     In response to "abs maxq" without arguments.

   M:     Informative message indicating current status of maxq and queue last
   searched (Q).  MMMM is the mode, "auto" or "manual".

   A:     $ignore

   Message:
   admin_: abs: qres (MMMM): WW XX YY ZZ

   S:	$as1

   T:     In response to "abs maxq" without arguments.

   M:     Informative message indicating current status of absentee queue
   reservation for each queue.  MMMM is the mode, "auto" or "manual".

   A:     $ignore

   Message:
   admin_: abs: queue  limits: WW XX YY ZZ

   S:	$as1

   T:     In response to "abs qres" operator command.

   M:     Informative message indicating the current queue reservation limits.

   A:     $ignore

   Message:
   admin_: abs: cpu_limit (MMMM), queues 1-4: WW XX YY ZZ (seconds)

   S:     $as1

   T:     In response to "abs cpu_limit" command without arguments.

   M:     Informative message indicating current values of cpu_limit for each
   absentee queue.  MMM is the mode, "auto" or "manual".

   A:     $ignore

   Message:
   admin_: abs: Warning: cpu limits are in seconds. You just set queue QQ limit to LLLL seconds.

   S:     $as1

   T:     In response to "abs cpu_limit" command with arguments.

   M:     The cpu_limit (LLLL) for queue QQ is below 60 seconds which is likely
   to be a mistake.  The value already given will be still be accepted.

   A:     Reenter the command with corrected values if originally incorrect.

   Message:
   admin_: ERROR_MESSAGE SYSDIR>answer_table

   S:     $as2

   T:     In response to operator commands that require access to the system
   answer_table.

   M:     The ERROR_MESSAGE gives reason why system was not able to find or
   access the answer_table in the SYSDIR directory.  Execution of the
   command was not completed.

   A:     $inform

   Message:
   admin_: ERROR_MESSAGE SYSDIR>whotab

   S:     $as2

   T:     In response to operator commands that require access to the system
   whotab.

   M:     The ERROR_MESSAGE gives reason why system was not able to find or
   access the whotab in the SYSDIR directory.  Execution of the
   command was not completed.

   A:     $inform

   Message:
   admin_: ERROR_MESSAGE SYSDIR>installation_parms

   S:     $as2

   T:     In response to operator commands that require access to the system
   installation_parms.

   M:     The ERROR_MESSAGE gives reason why system was not able to find or
   access the installation_parms in the SYSDIR directory.  Execution of the
   command was not completed.

   A:     $inform

   Message:
   admin_: ERROR_MESSAGE SYSDIR>cdt

   S:     $as2

   T:     In response to operator commands that require access to the system
   cdt.

   M:     The ERROR_MESSAGE gives reason why system was not able to find or
   access the cdt in the SYSDIR directory.  Execution of the
   command was not completed.

   A:     $inform

   Message:
   admin_: stop: All users are out. You may shut down.

   S:	$as1

   T:	$shut

   M:	This is the response to the stop command if all users
   have been logged out.  This message provides a quick check of whether
   all users have been bumped since it does not adversely affect system
   operation to issue the stop command repeatedly.

   A:	Proceed with the shutdown.

   Message:
   admin_: stop: There were no active users to be bumped.

   S:     $as1

   T:     $shut

   M:     The system did not find any active users to be bumped.

   A:     $ignore

   Message:
   admin_: stop: all users have been given XXXX minutes to logout

   S:     $as1

   T:     $shut

   M:	A stop command, either manual or automatic, has been
   initiated.  All users have been warned that they have XXXX minutes
   to finish up and logout.  After XXXX minutes, all users will be
   bumped except those with the nobump attribute.  The login word
   has been set so that no more users may log in.  To cancel this shutdown,
   issue a word login command and an unbump * * command.

   A:     $ignore

   Message:
   admin_: COMMAND: PERSON.PROJECT has "nobump"

   S:     $as1

   T:     $shut

   M:     The PERSON.PROJECT user cannot be bumped by the automatic shutdown or
   in response to the stop command.  The nobump attribute is normally only used
   by system administrator users.

   A:     Try to contact the user to arrange a time to actually
   shutdown.  If necessary, the user can be bumped by specifying the channel
   name in the bump command.  This will only work if the process has not been
   disconnected.  Otherwise, you will have to answer "yes" to the shutdown
   command.

   Message:
   admin_: bump: USER.PROJECT bumped.

   S:     $as1

   T:     In response to the bump command or a system shutdown.

   M:     The specified user has been notified that he or she must get off the
   system.  If a grace time was specified, the user is allowed that amount of
   time to logout.  Otherwise, the user is removed from the system immediately.

   A:     $ignore

   Message:
   admin_: abs ABS_FUNCTION: Expected argument missing. After PREV_ARG.

   S:     $as1

   T:	In response to an operator abs command.

   M:     A required value to a control argument supplied in the "abs"
   command line is missing.

   A:     Reenter corrected command line.

   Message:
   admin_: abs: auto abs stop will be at MM/DD/YY HHMM.T

   S:	$as1

   T:	In response to an operator down command or at startup.

   M:	This is the response to a down command if the absentee
   facility is running, or to an abs start command if the absentee is
   brought up after a down time has been set.  The time for an automatic
   abs stop is 20 minutes before the system is to shut down.  An "abs stop now"
   is done 10 minutes after the scheduled shutdown.
   Refer also to the stop command description.

   A:	$ignore

   Message:
   admin_: abs: All absentee processes have run to completion.

   S:	$as1

   T:	When shutting down the absentee facility.

   M:	This message is printed after the operator has issued an
   abs stop command or the system has issued an automatic
   abs stop prior to shutdown.  The system allows 30 minutes for all absentee
   jobs to finish before logging them out, then prints the message.

   A:	It is now safe to proceed with the shutdown.

   Message:
   admin_: abs: Bumping all remaining absentee processes.

   S:	$as1

   T:	$shut

   M:	The absentee facility waits 30 minutes for all absentee jobs
   to run to completion after the abs stop command has been
   issued.  Then it types this message and bumps them all.
   Refer also to the stop command description.

   A:	$ignore

   Message:
   admin_: down: auto shutdown will be at MM/DD/YY HHMM.T

   S:	$as1

   T:	In response to an operator down command or at startup.

   M:	This is the response to the down command.  It indicates
   the scheduled shutdown time.  A down command is issued automatically
   at system startup time after a crash; if a down command was given before
   the crash occurred, and the time of the scheduled shutdown is more than
   30 minutes in the future.

   A:	If the value shown in the message is correct, proceed.
   If not correct, reset the shutdown by typing down 0 and
   then try again.

   Message:
   admin_: word: XXXX; TYPE message: TEXT

   S:	$as1

   T:	In response to an operator word command.

   M:	The operator issued the word command with no arguments, and
   the current values were typed. The login word is XXXX, the message
   is TEXT, and the type of session is TYPE.  The TEXT is displayed as the
   first line of the greeting banner to interactive users making the banner 3
   lines long.  If TEXT is "" (NO MESSAGE), then nothing is added to the normal
   2 line greeting banner.

   A:	Check the word, type, and message for accuracy.

   Message:
   admin_: word: length of login-word must not exceed 8 characters

   S:	$as1

   T:	In response to an operator word command.

   M:	The operator tried to set the login word with the word
   command but the first argument was too long.  No action was taken
   on the command.

   A:	$tryagain

   Message:
   admin_: word: XXXX is a reserved word.

   S:	$as1

   T:	In response to an operator word command.

   M:	The operator attempted to set the system login word to
   enter, enterp, e, ep, dial, or d.
   No action was taken.

   A:	Pick another word and type it in.

   Message:
   admin_: word: message truncated; maximum length is CCCC characters

   S:	$as1

   T:	In response to an operator word command.

   M:	The operator issued the command "word XXXX TEXT". The message
   TEXT was too long to fit in the dialup message buffer.
   The login word has been changed, and the dialup message
   has been set to the first CCCC characters of the given message.

   A:	Reword the message to fit within the CCCC-character limit,
   and retype the command.

   Message:
   admin_: word: TYPE message: TEXT

   S:	$as1

   T:	In response to an operator word command.

   M:	The operator issued the command "word XXXX TEXT".  The login
   word was set to XXXX, and a special buffer was loaded with the
   message TEXT so that it is typed out whenever a user dials up.
   The type of system session is TYPE; this may be special, normal,
   or shutdown.

   A:	Check the message for accuracy.

   Message:
   admin_: login: Entry not found. No MC ACS segment for the source SSSS.

   S:     $as1

   T:     In response to operator login command.

   M:     An MC ACS was not found in >sc1>mc_acs directory for the source
   identifier, SSSS.

   A:     $inform

   Message:
   admin_: login: ERROR_TABLE_MESSAGE Login not permitted for message coordinator source SSSS.

   S:     $as1

   T:     In response to operator login command.

   M:     The error identified by ERROR_TABLE_MESSAGE was encountered
   attempting to check the access to login the daemon whose source identifier
   is SSSS.

   Message:
   admin_: COMMAND: ERROR_TABLE_MESSAGE

   S:     $as1

   T:     In response to operator command, COMMAND.

   M:     The ERROR_TABLE_MESSAGE error was encounted when processing the
   operator command, COMMAND.

   A:     Type "help COMMAND" for details of the command's usage.

   Message:
   admin_: abs: ERROR_TABLE_MESSAGE PATHNAME

   S:     $as1

   T:     In response to the operator abs command.

   M:     The ERROR_TABLE_MESSAGE was encountered when trying to expand the
   PATHNAME supplied in the operator abs command line.

   A:     $tryagain

   Message:
   admin_: login: error: Usage: login Person.Project SOURCE {-control_args}

   S:     $as1

   T:     In response to operator login command with no arguments.

   M:     Informative message to operator when the login command was entered
   without arguments.

   A:     Also type "help login" for further details of command line syntax.

   Message:
   admin_: logout: error: Usage: logout Person.Project {SOURCE}

   S:     $as1

   T:     In response to operator logout command when entered without
   arguments.

   M:     Informative message indicating usage of the logout command.

   A:     Type "help logout" for further details of command usage.

   Message:
   admin_: down: error: no system shutdown scheduled

   S:     $as1

   T:     In response to operator entering, "down 0".

   M:     The "down 0" command line cancels a down but no system shutdown was
   scheduled.  No action was taken.

   A:     $ignore

   Message:
   admin_: down: error: XXX invalid clock time.

   S:	$as1

   T:	In response to an operator down command.

   M:	The time arguments of a down command must be specified in
   4-digit time or some form acceptable to convert_date_to_binary_.  No action
   was taken.  If the second time argument is an invalid time, it is considered
   part of the message.  This message is also displayed if the first time
   argument is not in the future.

   A:	$tryagain

   Message:
   admin_: down: error: uptime is earlier than downtime.

   S:     $as1

   T:     In response to an operator down command.

   M:     The operator down command specifies that the expected time that the
   system will be up is before the time that it is scheduled to be shutdown.
   No action was taken.

   A:     $tryagain

   Message:
   admin_: stop: error: no arguments are allowed for "stop"

   S:	$as1

   T:	In response to an operator stop command.

   M:	The operator has given an argument to the stop
   command.  No arguments are allowed.  No action was taken.

   A:	If abs stop was meant, type that command.  If stop
   was meant, type that command instead.  If "down ...." was meant,
   type in that command.

   Message:
   admin_: warn: error: Usage: warn Person.Project MESSAGE

   S:     $as1

   T:     In response to an operator warn command without any arguments.

   M:     Informative message indicating usage of the warn command.

   A:     Also, type "help warn" for more details on warn command usage.

   Message:
   admin_: rcp: error: unknown rcp command RRRR

   S:     $as1

   T:     In response to an operator rcp command.

   M:     The operator has entered an unknown rcp operator on the command line.

   A:     Type "help rcp" for further details on rcp command usage.

   Message:
   admin_: maxunits: error: XXX invalid value for maxunits

   S:	$as1

   T:	In response to an operator maxunits command.

   M:	The argument of the maxunits command was not a number, or
   was zero, or negative.  No action was taken.

   A:	$tryagain

   Message:
   admin_: shift: error: XXXX is not a legal shift number.

   S:     $as1

   T:     In response to an operator shift command.

   M:     A shift argument to the shift command was not a valid decimal number
   between 1 and 6 inclusive.

   A:     $tryagain

   Message:
   admin_: shift: error: CCCC invalid clock time.

   S:     $as1

   T:     In response to an operator shift command.

   M:     The time argument of the shift command is not a valid clock time
   acceptable to convert_date_to_binary_.

   A:     $tryagain

   Message:
   admin_: shift: error: CCCC is not within the next week.

   S:     $as1

   T:     In response to an operator shift command.

   M:     The time argument of the shift command cannot specify a time stamp
   that is over a week in the future.

   A:     $tryagain

   Message:
   admin_: fdump_fnp: error: unknown argument AAAA

   S:     $as1

   T:     In response to an operator fdump_fnp command.

   M:     An unknown argument, AAAA, was encountered in the fdump_fnp command.
   This is an obsolete command.  No action was taken.

   A:     Type "help dump_mpx" for details of the dump_mpx command and try
   again.

   Message:
   admin_: dump_fnp: error: unknown argument AAAA

   S:     $as1

   T:     In response to an operator dump_fnp command.

   M:     An unknown argument, AAAA, was encountered in the dump_fnp command
   line.  This is an obsolete command.  No action was taken.

   A:     Type "help dump_mpx" for details of the dump_mpx command and try
   again.

   Message:
   admin_: dump_mpx: error: unknown argument AAAA

   S:     $as1

   T:     In response to an operator dump_mpx command.

   M:     An unknown argument, AAAA, was encountered in the dump_mpx command
   line.  No action was taken.

   A:     Type "help dump_mpx" for details of the dump_mpx command and try
   again.

   Message:
   admin_: load_fnp: unknown argument AAAA

   S:     $as1

   T:     In response to an operator load_fnp command.

   M:     An unknown argument, AAAA, was encountered in the load_fnp command
   line.  This is an obsolete command.  No action was taken.

   A:     Type "help load_mpx" for details of the load_mpx command and try
   again.

   Message:
   admin_: load_mpx: error: unknown argument AAAA

   S:     $as1

   T:     In response to an operator load_mpx command.

   M:     An unknown argument, AAAA, was encountered in the load_mpx command
   line.  No action was taken.

   A:     Type "help load_mpx" for details of the load_mpx command and try
   again.

   Message:
   admin_: load_mpx: error: unknown argument AAAA

   S:     $as1

   T:     In response to an operator load_mpx command.

   M:     An unknown argument, AAAA, was encountered in the load_mpx command
   line.  No action was taken.

   A:     Type "help load_mpx" for use of the load_mpx command and try again.

   Message:
   admin_: stop_fnp: error: unknown argument AAAA

   S:     $as1

   T:     In response to an operator stop_mpx command.

   M:     An unknown argument, AAAA, was encountered in the stop_fnp command
   line.  This is an obsolete command.  No action was taken.

   A:     Type "help stop_mpx" for details of the stop_mpx command and try
   again.

   Message:
   admin_: stop_mpx: error: unknown argument AAAA

   S:     $as1

   T:     In response to an operator stop_mpx command.

   M:     An unknown argument, AAAA, was encountered in the stop_mpx command
   line.  No action was taken.

   A:     Type "help stop_mpx" for details of the stop_mpx command and try
   again.

   Message:
   admin_: shutdown_mpx: error: unknown argument AAAA

   S:     $as1

   T:     In response to an operator shutdown_mpx command.

   M:     An unknown argument, AAAA, was encountered in the shutdown_mpx
   command line.  No action was taken.

   A:     The shutdown_mpx command is the same as the dump_mpx command except
   that no dump is created.  Type "help dump_mpx" for command usage details
   and try again.

   Message:
   admin_: abs: error: unknown absentee command WXYZ

   S:	$as1

   T:	$response

   M:	The operator typed abs WXYZ where WXYZ was
   unrecognizable to the system.  No action was taken.

   A:	$tryagain

   Message:
   admin_: abs: error: The abs CCCC command can not be used before answering service startup.

   S:     $as1

   T:     In response to an operator abs command.

   M:     Only the "abs stop" command may be given before the answering service
   starts up.  This allows the operator to stop the absentee facility before
   the system finishes initialzation.

   A:     $tryagain

   Message:
   admin_: abs: stop: error: abs stop queue only works after answering service startup

   S:     $as1

   T:     In response to an operator abs stop queue command.

   M:     The answering service must complete initialization before the
   "abs stop queue" command can be used.

   A:     Allow the system to complete initialization and try again.

   Message:
   admin_: abs: stop: error: missing argument: queue to be stopped

   S:     $as1

   T:     In response to an operator "abs stop queue" command.

   M:     The "abs stop queue" command was entered without supplying the number
   of the queue to be stopped.

   A:     $tryagain

   Message:
   admin_: abs: stop: error: invalid queue to be stopped: DDDD

   S:     $as1

   T:     In response to an operator "abs stop queue" command.

   M:     The value of the queue number was not within the values of 1 and 4,
   inclusive.

   A:     $tryagain

   Message:
   admin_: abs: stop: error: unknown argument SSSS

   S:     $as1

   T:     In response to an operator "abs stop" command.

   M:     An unknown argument, SSSS, was supplied to the "abs stop" command.

   A:     Type "help abs" for details of the abs command and try again.

   Message:
   admin_: abs: stop: error: absentee stop in progress

   S:	$as1

   T:	$response

   M:	An abs start, abs stop, abs maxu, abs maxq, or
   down command was issued while the absentee facility was in the
   process of shutting down.

   A:	Wait for the message that all absentee processes have
   run to completion, then reissue the command.

   Message:
   admin_: abs: ABS_FUNCT: error: No job in absentee slot X (status= SSSS).

   S:     $as1

   T:     $response

   M:     The absentee slot absX has an entry status of SSSS indicating that no
   user is using it.

   A:     $tryagain

   Message:
   admin_: abs: ABS_FUNCT: error: Job in absentee slot X is not from user NAME.PROJ

   S:     $as1

   T:     $response

   M:     The job running in specified absentee slot of absX is not from
   specified user, NAME.PROJ.

   A:     Recheck job specifications and try again.

   Message:
   admin_: abs: ABS_FUNCT: error: Job in absentee slot X does not match request ID YYYY

   S:     $as1

   T:     $response

   M:     The ID of the job running in specified absentee slot of absX does not
   match the specified ID of YYYY.

   A:     Recheck job specifications and try again.

   Message:
   admin_: abs: ABS_FUNCT: error: Job in absentee slot X does not match absin path DIR_PATH>ENTRY_NAME

   S:     $as1

   T:     $response

   M:     The pathname of the absin of the job running in specified absentee
   slot of absX does not match the specified absin pathname.

   A:     Recheck job specifications and try again.

   Message:
   admin_: abs: ABS_FUNCT: error: Job in absentee slot X does not match absin entry name SSSS

   S:     $as1

   T:     $response

   M:     The entry name SSSS of the absin of the job running in specified
   absentee slot of absX does not match the specified absin entry name.

   A:     Recheck job specifications and try again.

   Message:
   admin_: abs: ABS_FUNCT: error: Job in absentee slot X is not from sender SSSS

   S:     $as1

   T:     $response

   M:     The sender of the absin of the job running in specified
   absentee slot of absX does not match the specified sender, SSSS.

   A:     Recheck job specifications and try again.

   Message:
   admin_: abs: ABS_FUNCT: error: Job in absentee slot X is not from queue DDDD

   S:     $as1

   T:     $response

   M:     The queue of the absin of the job running in specified
   absentee slot of absX does not match the queue number DDDD.

   A:     Recheck job specifications and try again.

   Message:
   admin_: abs: release: error: Job in absentee slot X is not suspended.

   S:     $as1

   T:     $response

   M:     The specified job running in
   absentee slot of absX is not suspended so a release does not apply.

   A:     Recheck job specifications and try again.

   Message:
   admin_: abs: suspend: error: Job in absentee slot X is already suspended.

   S:     $as1

   T:     $response

   M:     The specified job running in 
   absentee slot of absX is already suspended and cannot be suspended again.

   A:     Recheck job specifications and try again.

   Message:
   admin_: abs: release: error: Selection arguments matched no deferred or suspended absentee requests.

   S:     $as1

   T:     $response

   M:     No suspended or deferred job was found to release with the arguments
   supplied on the abs release command line.

   A:     Recheck job specifications and try again.

   Message:
   admin_: abs: ABS_FUNCT: error: Selection arguments matched no running absentee jobs.

   S:     $as1

   T:     $response

   M:     No running job was found that matched the selection arguments
   supplied on the abs command line.

   A:     Recheck job specifications and try again.

   Message:
   admin_: abs: start: error: system coming down soon: no abs start

   S:     $as1

   T:     $response

   M:     The system is shutting down within 30 minutes so the absentee
   facility will not be started.

   A:     $ignore

   Message:
   admin_: abs: start: error: absentee already up

   S:	$as1

   T:	In response to an operator abs start command.

   M:	abs start was typed twice.  No action was taken on the second
   issuance of the command.

   A:	$ignore

   Message:
   admin_: abs: start: error: absentee not up. cannot restart queue X

   S:     $as1

   T:     $response

   M:     Cannot use the "abs start queue" command until the absentee facility
   has been started.

   A:     Issue the "abs start" command and try again.

   Message:
   admin_: abs: start: error: invalid queue to be restarted X

   S:     $as1

   T:     $response

   M:     An invalid queue number was specified in an operator
   "abs start queue" command line.  It must be between 1 and 4 inclusive.

   A:     $tryagain

   Message:
   admin_: abs: ABS_FUNCT: error: absentee not up

   S:	$as1

   T:	$response

   M:	An abs command was given, but
   the absentee facility had never been started up.  No action was
   taken on the command.

   A:	Type abs start to start up the absentee facility.

   Message:
   admin_: abs: qres: error: abs qres has invalid value: DDDD

   S:     $as1

   T:     $response

   M:     An invalid qres argument was detected in an operator "abs qres"
   command.  The argument must be "auto" or a positive decimal number.

   A:     $tryagain

   Message:
   admin_: abs: cpu_limit: error: Usage is: "abs cpu_limit l1,l2,l3,l4" (limits in seconds)

   S:     $as1

   T:     $response

   M:     Informative message that is displayed when an operator
   "abs cpu_limit" command without arguments is entered.

   A:     $tryagain

   Message:
   admin_: abs: list: error: The absN argument cannot be used when absentee is not up.

   S:     $as1

   T:     $reponse

   M:     Cannot use the "absN" argument to select absentee jobs to list until
   the absentee facility has been started.

   A:     Use other job selection criteria or type "abs start" and try again.

   Message:
   admin_: abs: list: error: No job in absentee slot X.

   S:     $as1

   T:     $response

   M:     The absentee slot absX does not exist.

   A:     $tryagain

   Message:
   admin_: COMMAND: error: No FNP tag specified.

   S:	$as1

   T:	Response to an operator "load_fnp", "fdump_fnp", "dump_fnp",
   "start_fnp", or "stop_fnp" command.

   M:	The operator did not supply an FNP identifier.

   A:	$tryagain

   Message:
   admin_: COMMAND: error: No multiplexer specified.

   S:	$as1

   T:	Response to an operator "load_mpx", "dump_mpx", "start_mpx",
   "shutdown_mpx" or "stop_mpx" command.

   M:	The operator did not supply a multiplexer name.

   A:	$tryagain

   Message:
   admin_: COMMAND: error: Invalid FNP tag: X

   S:	$as1

   T:	Response to an operator "load_fnp", "fdump_fnp", "dump_fnp",
   "start_fnp", or "stop_fnp" command.

   M:	The supplied FNP tag was more than one character or was not between
   a-h inclusive.

   A:	$tryagain

   Message:
   admin_: abs: maxu: error: abs maxusers must be numeric or "auto": SSSS

   S:     $as1

   T:     $response

   M:     The argument, SSSS, to the operator "abs maxu" command was not a
   positive numeric or the string, "auto".  The numeric value is in tenths
   of a load unit.

   A:     $tryagain

   Message:
   admin_: abs: maxu: error: abs maxusers may not be negative: SSSS

   S:     $as1

   T:     $response

   M:     The argument, SSSS, to the operator "abs maxu" command was not a
   positive numeric or the string, "auto".  The numeric value is in tenths
   of a load unit.

   A:     $tryagain

   Message:
   admin_: abs: maxu: error: abs maxusers may not be greater than system maxusers: SSSS

   S:     $as1

   T:     $response

   M:     The argument, SSSS, to the operator "abs maxu" command cannot
   be greater than the maximum allowed users that can be on the system.

   A:     $tryagain

   Message:
   admin_: abs: maxq: error: abs maxqueue has invalid value: XXX

   S:	$as1

   T:	$response

   M:	An abs maxq or abs start command had as an argument
   something that was not a number, or was too big, or was a negative
   number.  No action is taken.

   A:	$tryagain

   Message:
   admin_: abs: ABS_FUNCT: error: More than one specification of an attribute is present: SSSS

   S:     $as1

   T:     $response

   M:     The SSSS attribute has already been specified to select an
   absentee job on the operator abs command.  An attribute can only be
   used once.

   A:     $tryagain

   Message:
   admin_: abs: ABS_FUNCT: error: Invalid abs job selection argument: SSSS

   S:     $as1

   T:     $response

   M:     The job selection argument SSSS is not recognized as valid.

   A:     Type "help abs" for details of the abs command usage and try again.

   Message:
   admin_: abs: ABS_FUNCT: Invalid queue number DDDD

   S:     $as1

   T:     $response

   M:     The value after the -queue job selection argument is invalid.
   It must be the strings "fg" or "foreground" or a between the values of
   1 and 4, inclusive.

   A:     $tryagain

   Message:
   admin_: abs: ABS_FUNCT: error: Relative pathnames not allowed: SSSS

   S:     $as1

   T:     $response

   M:     The pathname of the absin was expected and it must be an absolute
   pathname, starting with a ">" character.

   A:     $tryagain

   Message:
   admin_: abs: ABS_FUNCT: No job selection arguments given.

   S:     $as1

   T:     $response

   M:     After processing the arguments on the "abs abs_funct" operator
   command, no job selection arguments were encountered.

   A:     Type "help abs" for details of the abs command usage and try again.

   Message:
   admin_: abs: ABS_FUNCT: error: User name must be given.

   S:     $as1

   T:     $response

   M:     The "abs ABS_FUNCT" operator command requires that a user name be
   supplied.

   A:     $tryagain

   Message:
   admin_: abs: ABS_FUNCT: error: User name (not ""*"") must be given.

   S:     $as1

   T:     $response

   M:     The "abs ABS_FUNCT" operator command requires that a user name be
   supplied.  Cannot use "*".

   A:     $tryagain

   Message:
   admin_: abs: ABS_FUNCT: error: The absN argument is not valid.

   S:     $as1

   T:     $response

   M:     The "abs ABS_FUNCT" operator command cannot allow use of the absN
   argument for job selection.

   A:     $tryagain

   Message:
   admin_: abs: ABS_FUNCT: error: Personid NAME > 22 characters.

   S:     $as1

   T:     $response

   M:     The "abs ABS_FUNCT" operator command specified a user name that is
   longer than 22 characters.

   A:     $tryagain

   Message:
   admin_: abs: ABS_FUNCT: error: SSSS is not a valid Person.Project.

   S:     $as1

   T:     $response

   M:     The "abs ABS_FUNCT" operator command did not specify a valid
   Person.Project in the string SSSS.

   A:     $tryagain

   Message:
   admin_: abs: ABS_FUNCT: error: Projectid SSSS is longer than 9 characters.

   S:     $as1

   T:     $response

   M:     The "abs ABS_FUNCT" operator command incorrectly specified a
   project name that is longer than 9 characters.

   A:     $tryagain

   END MESSAGE DOCUMENTATION */

     end admin_;
