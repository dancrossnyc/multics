/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(1986-06-09,Farley), approve(1987-07-09,MCR7746),
     audit(1987-07-20,Fawcett), install(1987-07-28,MR12.1-1049):
     Corrected bug in setting exp_seg_name.
  2) change(1986-10-08,Farley), approve(1987-07-09,MCR7746),
     audit(1987-07-20,Fawcett), install(1987-07-28,MR12.1-1049):
     Added quentry.used to diskq_data for flagging incomplete "(I)" I/O.
  3) change(1987-01-06,Parisek), approve(1987-07-09,MCR7746),
     audit(1987-07-20,Fawcett), install(1987-07-28,MR12.1-1049):
     Add functionality of matching and excluding strings on event strings.
  4) change(1987-01-09,Parisek), approve(1987-07-09,MCR7746),
     audit(1987-07-20,Fawcett), install(1987-07-28,MR12.1-1049):
     Check processor_tag value before referencing it in a function.  Previously
     too large a value would cause an OOB error.
  5) change(1987-01-21,Parisek), approve(1987-07-09,MCR7746),
     audit(1987-07-20,Fawcett), install(1987-07-28,MR12.1-1049):
     Check validity of disk device name and device number before assigning an
     auto variable to them, then displaying such.
  6) change(1987-07-09,Parisek), approve(1987-07-09,MCR7746),
     audit(1987-07-20,Fawcett), install(1987-07-28,MR12.1-1049):
     Changed declaration of proc_exists_mask from bit(36) to bit(8) to prevent
     stringsize conditions.
  7) change(1988-04-04,Parisek), approve(1988-04-21,MCR7877),
     audit(1988-07-08,Farley), install(1988-07-12,MR12.2-1055):
     Changed disk_queue event processing to only process events of interest
     when processing by time.
  8) change(2016-01-15,Swenson), approve(2016-01-15,MCR10003):
     Fix to support 4-character time zone abbreviations.
                                                   END HISTORY COMMENTS */


/* format: style4,delnl,insnl,ifthenstmt,indnoniterend */
azm_display_fdump_events:
     proc (P_sci_ptr, P_amu_info_ptr, num_events, delta_time, long_report, match_info_ptr, code);



/* Routine to scan an FDUMP for interesting time-stamped events,
   sort these events by time (reverse order), and print them.

   The following events are considered as interesting:

   Machine Conditions (from BCE, prds, pds, mc_trace_buf)

   Traffic Control State Change Time

   Syserr Messages (from both syserr_data and syserr_log)

   Fim Frames in any stack

   Connects by device

   Disk queues (long report only)

   An array of pointers to FDUMP is passed as a parameter--this array
   is in order by FDUMP component (0, 1, 2, ...).  Also passed
   are pointers to copies of certain segments from the FDUMP (these
   are not within the FDUMP itself, but copied from it.

   Modification history:
   81-03-15, J. Bongiovanni: Initial coding
   81-04-21, Rich Coppola: Added expanded path name/rel offset
   81-07-10, J. Bongiovanni; Added connects, by device
   82-01-04, J. Bongiovanni: Added disk queues, mc_trace_buf
   82-05-22, Rich Coppola: Modified for new ASTE
   82-07-30, J. Bongiovanni: Modified for new time format in disk Q
   82-11-13, Rich Coppola: Modified for analyze_multics
   83-02-10, Rich Fawcett: Modified to reduce space used.
   83-01-24, B. Braun: Modified for P. Farley's change to check that all eight 
      words of SCU data are zero before assuming no scu data was stored. 
   84-01-19, BLB: Fix so events request -last and -time work (phx16720)
   84-10-01, R. A. Fawcett: Added fault_tag_1 handler to walk_stack
   84-10-02, R. A. Fawcett: Changed to use the info from the "new" disk_dim. 
   84-10-08, R. A. Fawcett: Changed walk_stack to use valid_fim_ptr
   84-12-14, W. Olin Sibert: Converted syserr stuff for new format logs
*/

/* Parameter */

dcl  P_amu_info_ptr ptr;
dcl  P_sci_ptr ptr;
dcl  num_events fixed bin;				/* number of events to print			*/
dcl  delta_time fixed bin (71);			/* interval of interest in microseconds		*/
dcl  long_report bit (1);				/* ON=>long report format, OFF=>1 line/event	*/
dcl  good_match bit (1);				/* used when calling mh_or_ex proc */
dcl  match_info_ptr ptr;				/* ptr to match/exclude strings */
dcl  temp_string char (128) varying;			/* temp for checking matches or exclusions */
dcl  temp_time char (32) varying;			/* temp time stamp for matches or exclusions */
dcl  tsl fixed bin (21);				/* length of temp_string */
dcl  code fixed bin (35);
dcl  new_disk_dim_sw bit (1);

     


/* Automatic */

dcl  apt_array_p ptr;
dcl  apt_inx fixed bin;
dcl  apt_proc_found bit (1);
dcl  bmp ptr init (null);
dcl  bound_interceptors_ptr ptr;
dcl  cur_date_time char (17);
dcl  definitions_ptr ptr;
dcl  diskq_datap ptr;
dcl  dom fixed bin;
dcl  DOM pic "99";
dcl  dow fixed bin;
dcl  dump_ptrs ptr;
dcl  dump_seginx fixed bin;
dcl  dump_segno fixed bin;
dcl  earliest_recorded_time fixed bin (71);
dcl  earliest_time fixed bin (71);
dcl  event_inx fixed bin;
dcl  events_by_time bit(1);
dcl  events_printed fixed bin;
dcl  eventsp ptr;
dcl  first_print bit (1);
dcl  1 hard_ptr_space like hardcore_cur;
dcl  hr fixed bin;
dcl  HR pic "z9";
dcl  1 interesting_segs (N_INTERESTING_SEGS) aligned,
       2 segno fixed bin (18) init ((N_INTERESTING_SEGS) - 1),
       2 process_this_seg bit (1) init ((N_INTERESTING_SEGS) (1)"1"b),
       2 handler entry  (bit (1) aligned) variable init (
                process_prds, process_pds, process_tc_data,
                process_syserr_data, setup_from_scs, process_inzr_stk0,
                process_iom_data, process_disk_queue, copy_pvt,
                process_mc_trace_buf);
     


dcl  last_date_time char (17);
dcl  last_sec fixed bin;
dcl  last_segno fixed bin;
dcl  micsec fixed bin (71);
dcl  MICSEC pic "999999";
dcl  minute fixed bin;
dcl  MIN pic "99";
dcl  mon fixed bin;
dcl  MON pic "99";
dcl  max_events fixed bin;
dcl  nametbl_ptr ptr;
dcl  prds_processor bit (8) unal;
dcl  proc_no fixed bin;
dcl  process_number fixed bin;
dcl  range fixed bin (18);
dcl sci_ptr ptr;
dcl  sec fixed bin;
dcl  SEC pic "99";
dcl  seg_found bit (1);
dcl  seginx fixed bin;
dcl  segp ptr;
dcl  sortp ptr;
dcl  sortinx fixed bin;
dcl  sortinx1 fixed bin;
dcl  sortinxt fixed bin;
dcl  stack_found bit (1);
dcl  stack_inx fixed bin;
dcl  stack_segs (0:7) fixed bin;
dcl  temp_alloc_p ptr;
dcl  temp_seg_data_p ptr;
dcl 1 translation_space like translation;
dcl  tsegp ptr;
dcl  words_copied fixed bin (18);
dcl  yr fixed bin;
dcl  YR pic "99";


/* Static */

dcl  CPU_TAG char (8) init ("abcdefgh") int static options (constant);
dcl  IOM_TAG char (4) init ("ABCD") int static options (constant);
dcl  MYNAME char (24) init ("azm_display_fdump_events") int static options (constant);
dcl  N_INTERESTING_SEGS fixed bin init (10) int static options (constant);
dcl  MC_TRACE_BUF fixed bin init (10) int static options (constant);
dcl  interesting_segname (N_INTERESTING_SEGS) char (32) int static options (constant) init (
                "prds", "pds", "tc_data", "syserr_data", "scs", "inzr_stk0",
                "iom_data", "disk_seg", "pvt", ""); 

						/* Index of mc_trace_buf */


/* Based */

dcl  1 temp_seg_data aligned based (temp_seg_data_p),	/* info on temp segs allocated 		*/
       2 n_temp_segs fixed bin,			/* number temp segs allocated this way		*/
       2 temp_segp (0 refer (n_temp_segs)) ptr;		/* array of pointers to allocated temp segs	*/

dcl  1 time_stamped_events aligned based (eventsp),	/* events of interest from FDUMP		*/
       2 n_events fixed bin,				/* number of events found			*/
       2 events (0 refer (n_events)),
         3 time_stamp fixed bin (71),			/* time of event				*/
         3 delete_on_duplicate_time bit (1),		/* ON => delete this event if time the same as another */
         3 deleted bit (1),				/* ON => this event deleted */
         3 event_struct_ptr ptr,			/* structure of interest to event		*/
         3 event_display entry (char (*), ptr, fixed bin) variable,
						/* routine to print event	*/
         3 process_number fixed bin,			/* process number in FDUMP			*/
         3 apte_offset bit (18),			/* APTE offset or "0"b */
         3 added_info char (40) unal;			/* other data to be printed			*/

dcl  1 apt_array aligned based (apt_array_p),		/* used to translate apte offset to proc number */
       2 n_aptes fixed bin,
       2 apt_desc (0 refer (n_aptes)) aligned,
         3 offset bit (18) unal,			/* offset of apte in tc_data			*/
         3 procn fixed bin (17) unal;			/* process number in FDUMP			*/



dcl  1 diskq_data aligned based (diskq_datap),		/* extract of disk queue/devtab info */
       2 pvtx fixed bin,
       2 io_type fixed bin,
       2 coreadd fixed bin (25),
       2 sector fixed bin,
       2 cylinder fixed bin,
       2 used bit (1);

dcl  1 indirect_sort_array aligned based (sortp),		/* used for sorting time_stamped_events		*/
       2 sort_index (262144) fixed bin (18);



/* Entry */

dcl  amu_$definition_offset entry (ptr, char (*), char (*), fixed bin (35)) returns (fixed bin (18));
dcl  amu_$do_translation entry (ptr, fixed bin, ptr, fixed bin (18), fixed bin (18), fixed bin (35));
dcl  amu_$error_for_caller entry () options (variable);
dcl  amu_$fdump_mpt_temp_change_idx entry (ptr, fixed bin);
dcl  amu_$fdump_mpt_revert_idx entry (ptr);
dcl  amu_$get_name entry (ptr, ptr) returns (char (*));
dcl  amu_$hardcore_info_set_cur_ptrs entry (ptr, ptr);
dcl  amu_$return_val_per_process entry (ptr, fixed bin) returns (bit (1));
dcl  amu_$slt_search_seg_ptr entry (ptr, ptr, char (32), ptr, fixed bin (35));
dcl  match_strings_$free entry (ptr);
dcl  match_strings_$test entry (ptr, char (*)) returns (bit (1) aligned);
dcl  ssu_$get_temp_segment	entry (ptr, char(*), ptr);
dcl  ssu_$print_message 	entry() options(variable);
dcl  ssu_$release_temp_segment	entry (ptr, ptr);
dcl  (
     ioa_,
     ioa_$nnl,
     ioa_$rsnnl
     ) entry options (variable);
dcl  sys_info$max_seg_size fixed bin (35) ext static;
dcl  decode_clock_value_$date_time
	entry (fixed bin (71), fixed bin, fixed bin, fixed bin, fixed bin, fixed bin, fixed bin, fixed bin (71),
	fixed bin, char (4), fixed bin (35));

/* Condition */

dcl  cleanup condition;


/* Builtin */

dcl  (addr,
      addrel,
      baseno,
      baseptr,
      bin,
      clock,
      convert,
      currentsize,
      divide,
      fixed,
      hbound,
      index,
      lbound,
      length,
      min,
      mod,
      null,
      pointer,
      ptr,
      rel,
      reverse,
      rtrim,
      size,
      string,
      substr,
      unspec)			builtin;
%page;

/* Setup pointers and cleanup handler */

	amu_info_ptr = P_amu_info_ptr;
	sci_ptr = P_sci_ptr;
	hardcore_cur_ptr = addr (hard_ptr_space);
	call amu_$hardcore_info_set_cur_ptrs (amu_info_ptr, hardcore_cur_ptr);
	dump_ptrs, dumpptr = fdump_info.dump_seg_ptr (0);
	sltp = hardcore_cur.sltp;
	nametbl_ptr = hardcore_cur.sltntp;
	definitions_ptr = hardcore_cur.defp;
	temp_alloc_p = null ();
	temp_seg_data_p = null ();
	eventsp, tsegp, pvtp = null ();
	         temp_string, temp_time = "";
	tsl = 0;
	good_match = ""b;
	on cleanup call cleanit;

	/* Initialize temporary segment allocation */

	call ssu_$get_temp_segment (sci_ptr, MYNAME, temp_seg_data_p);

	eventsp = allocate_temp_seg ();
	tsegp = allocate_temp_seg ();


						/* Find segment numbers of all interesting segments */

	do seginx = 1 to N_INTERESTING_SEGS;
	     if interesting_segname (seginx) ^= "" then do;
		call amu_$slt_search_seg_ptr (hardcore_cur.sltp, hardcore_cur.sltntp, interesting_segname (seginx), segp,
		     code);
		if code = 0
		then interesting_segs.segno (seginx) = bin (baseno (segp), 18);
		else call amu_$error_for_caller ((null ()), code, MYNAME, "^a not found in dump", interesting_segname (seginx));
		end;
	end;

%page;
	prds_processor = "11111111"b;
	call amu_$slt_search_seg_ptr (hardcore_cur.sltp, hardcore_cur.sltntp, "bound_interceptors",
	     bound_interceptors_ptr, code);
	if code ^= 0 then bound_interceptors_ptr = null ();
	new_disk_dim_sw = "1"b;
	stack_segs (*) = -1;

	proc_no = 0;
	last_segno = -1;
	earliest_recorded_time = clock ();		/* dump must be earlier than this		*/

          if num_events = -1 then 
	     events_by_time = "1"b;

	else events_by_time = "0"b;

	apt_array_p = allocate_temp_seg ();
	apt_array.n_aptes = 0;

/* First event is return to BCE								*/

          if events_by_time then do;
	   if delta_time = 0 then earliest_time = 0;
	   else earliest_time = dump.mctime - delta_time;
	   end;

	n_events = 0;

	call add_an_event (bin (dump.mctime, 71), addr (dump.scu (0)), print_dump_mc, "RTB Machine Conditions", "0"b,
	     "0"b);

/* Go through segments dumped, building events in event array					*/
	do proc_no = 0 to hbound (fdump_process_table.array, 1);
	     call amu_$fdump_mpt_temp_change_idx (amu_info_ptr, proc_no);
	     stack_segs (*) = -1;
/*	     do stack_inx = 0 to hbound (stack_segs, 1);
		stack_segs (stack_inx) = -1;
	     end;*/

	     interesting_segs (MC_TRACE_BUF).process_this_seg = "0"b;
						/* mc tracing is per-process */
	     fp_table_ptr = addr (fdump_process_table.array (proc_no));
	     do dump_seginx = fp_table.first_seg to fp_table.last_seg;
		dump_segno = bin (dump.segs (dump_seginx).segno, 18);
		if dump_segno <= slt.last_sup_seg	/* only hardcore segs are interesting		*/
		     | interesting_segs (MC_TRACE_BUF).process_this_seg
						/* unless tracing machine conditions */
		then do;
		     seg_found = "0"b;
		     seginx = 1;
		     do while (^seg_found & seginx <= N_INTERESTING_SEGS);
			if dump_segno = interesting_segs.segno (seginx)
			then seg_found = "1"b;
			else seginx = seginx + 1;
		     end;
		     if seg_found & interesting_segs (seginx).process_this_seg then do;
			call interesting_segs (seginx).handler  (interesting_segs (seginx).process_this_seg);
			if code ^= 0 then do;
COPY_ERR:
			     call amu_$error_for_caller ((null ()), code, MYNAME, "seg index ^d", dump_seginx);
			     call cleanit;
			     return;
			     end;
			end;
		     end;
		stack_found = "0"b;
		do stack_inx = 0 repeat stack_inx + 1 while (^stack_found & stack_inx <= hbound (stack_segs, 1));
		     if stack_segs (stack_inx) = dump_segno then do;

			call process_user_stack (stack_inx, dump_segno);
			if code ^= 0 then goto COPY_ERR;

			stack_found = "1"b;
			end;
		end;
	     end;
	end;

/* Now extract messages from the syserr log which are within the interval of
   interest; we must process each of the syserr log segments in turn. */

	call process_syserr_log (earliest_recorded_time, tsegp, "syserr_log_laurel");
	call process_syserr_log (earliest_recorded_time, tsegp, "syserr_log_hardy");


%page;

/* Sort event array by time stamp (tag sort)							*/

	sortp = allocate_temp_seg ();
	do sortinx = 1 to n_events;
	     sort_index (sortinx) = sortinx;
	end;

	do sortinx = 1 to n_events - 1;
	     do sortinx1 = sortinx + 1 to n_events;
		if events (sort_index (sortinx1)).time_stamp > events (sort_index (sortinx)).time_stamp then do;
		     sortinxt = sort_index (sortinx1);	/* swap pointers 				*/
		     sort_index (sortinx1) = sort_index (sortinx);
		     sort_index (sortinx) = sortinxt;
		     end;
		else if events (sort_index (sortinx1)).time_stamp = events (sort_index (sortinx)).time_stamp then do;
		     if events (sort_index (sortinx1)).delete_on_duplicate_time
		     then events (sort_index (sortinx1)).deleted = "1"b;
		     if events (sort_index (sortinx)).delete_on_duplicate_time
		     then events (sort_index (sortinx)).deleted = "1"b;
		     end;
	     end;
	end;

%page;

/* Print the sorted events by calling the print routine for each,
   passing the decoded time value								*/

	first_print = "1"b;
	last_date_time = " ";
	last_sec = -1;
          events_printed = 1;
          if events_by_time then max_events = n_events;
	else max_events = min (n_events, num_events);

	do event_inx = 1 to n_events while (events_printed <= max_events);
	     if ^events (sort_index (event_inx)).deleted then do;
	          events_printed = events_printed + 1;
		call decode_clock_value_$date_time (events (sort_index (event_inx)).time_stamp, mon, dom, yr, hr,
		     minute, sec, micsec, dow, "", code);
		if code = 0 then do;
		     MON = mon;
		     DOM = dom;
		     YR = mod (yr, 100);
		     HR = hr;
		     MIN = minute;
		     SEC = sec;
		     MICSEC = micsec;
		     cur_date_time = MON || "/" || DOM || "/" || YR || " " || HR || ":" || MIN;
		     if cur_date_time ^= last_date_time
		     then call ioa_ ("Events from ^a:^a.^a", cur_date_time, SEC, MICSEC);
		     if first_print then do;
			call ioa_ ("^4xTime^2xCPU Proc Event^27xCircumstances^/");
			first_print = "0"b;
			end;
		     last_date_time = cur_date_time;
		     if last_sec = sec
		     then call ioa_$rsnnl ("  .^6a  ", temp_time, tsl, MICSEC);
		     else call ioa_$rsnnl ("^2a.^6a  ", temp_time, tsl, SEC, MICSEC);
		     last_sec = sec;
		     if match_info_ptr = null () then call ioa_$nnl (temp_time);
/* Find FDUMP Process Number if necessary */

		     process_number = events (sort_index (event_inx)).process_number;

		     if events (sort_index (event_inx)).apte_offset ^= "0"b then do;
			apt_proc_found = "0"b;
			apt_inx = 1;
			do while (^apt_proc_found & apt_inx <= apt_array.n_aptes);
			     if events (sort_index (event_inx)).apte_offset = apt_array.apt_desc (apt_inx).offset
			     then do;
				apt_proc_found = "1"b;
				process_number = apt_array.apt_desc (apt_inx).procn;
				end;
			     else apt_inx = apt_inx + 1;
			end;
			end;


		     call events (sort_index (event_inx))
			.
			event_display (events (sort_index (event_inx)).added_info,
			events (sort_index (event_inx)).event_struct_ptr, process_number);
		     end;
		end;
	end;


GLOBAL_RETURN:
	call cleanit;
RETURN:
	return;


%page;
/* Internal procedure to add an event to the structure if its time
   is within the range of interest								*/


add_an_event:
     proc (etime, eptr, eroutine, eadded_info, delete_duplicate, apte_offset);


dcl  etime fixed bin (71);				/* time of event				*/
dcl  eptr ptr;					/* pointer to event structure			*/
dcl  eroutine entry (char (*), ptr, fixed bin) variable;	/* routine to print event			*/
dcl  eadded_info char (*);				/* clear-text info of interest		*/
dcl  delete_duplicate bit (1) aligned;			/* ON => delete this event if duplicate times */
dcl  apte_offset bit (18);				/* APTE offset or "0"b */


	if events_by_time then if etime < earliest_time then return;
	n_events = n_events + 1;
	events (n_events).time_stamp = etime;
	events (n_events).event_struct_ptr = eptr;
	events (n_events).event_display = eroutine;
	events (n_events).added_info = eadded_info;
	events (n_events).process_number = proc_no;
	events (n_events).apte_offset = apte_offset;
	events (n_events).deleted = "0"b;
	events (n_events).delete_on_duplicate_time = delete_duplicate;

	if events_by_time then if etime < earliest_recorded_time & etime ^= 0 then earliest_recorded_time = etime;

     end add_an_event;






%page;


/* Internal Procedure to allocate an additional temporary segment,
   and return a pointer to same								*/


allocate_temp_seg:
     proc returns (ptr);

	call ssu_$get_temp_segment (sci_ptr, MYNAME, temp_segp (n_temp_segs + 1));
	n_temp_segs = n_temp_segs + 1;

	return (temp_segp (n_temp_segs));


     end allocate_temp_seg;


%page;

/* Internal Procedure for Cleanup								*/


cleanit:
     proc;

dcl  i fixed bin;

	if temp_seg_data_p ^= null () then do;
	     do i = 0 to n_temp_segs;
		if temp_segp (i) ^= null then call ssu_$release_temp_segment (sci_ptr, temp_segp (i));
	     end;
	     call ssu_$release_temp_segment (sci_ptr, temp_seg_data_p);
	     temp_seg_data_p = null ();
	     end;
	if sortp ^= null then call ssu_$release_temp_segment (sci_ptr, sortp);
	if tsegp ^= null then call ssu_$release_temp_segment (sci_ptr, tsegp);
	if match_info_ptr ^= null then call match_strings_$free (match_info_ptr);

     end cleanit;

%page;
/* Internal Procedure to copy the PVT to a temporary segment. This
   is necessary to print some of the interesting stuff about disk
   queues
*/

copy_pvt:
     proc (process_it);

dcl  process_it bit (1) aligned;

	process_it = "1"b;				/* Only copy PVT once */
	if ^long_report then return;
          pvtp = allocate_temp_seg ();
          words_copied = sys_info$max_seg_size;
          call get_data (pvtp,dump_segno, 0, words_copied, code);

     end copy_pvt;

%page;

/* Internal Procedure to copy a part of a segment to a temporary segment.
   Additional temporary segments are allocated as necessary, and a pointer
   to the copy is returned									*/


copy_to_temporary:
     proc (dptr, dlength) returns (ptr);


dcl  dptr ptr;					/* pointer to part of segment to copy	*/
dcl  dlength fixed bin (18);				/* number of words to copy			*/



dcl  tlength fixed bin (18);
dcl  tptr ptr;
dcl  based_move (tlength) fixed bin (35) aligned based;


	tlength = divide (dlength + 7, 8, 18) * 8;	/* Make modulo 8				*/
	if temp_alloc_p = null ()			/* first time here				*/
	then temp_alloc_p = allocate_temp_seg ();
	else if bin (rel (temp_alloc_p), 18) + tlength > sys_info$max_seg_size then temp_alloc_p = allocate_temp_seg ();

	tptr = temp_alloc_p;
	temp_alloc_p = addrel (temp_alloc_p, tlength);
	tptr -> based_move = dptr -> based_move;
	return (tptr);


     end copy_to_temporary;
%page;
/* Internal procedure to get data from a  dump */
get_data:
     proc (data_ptr, seg, word, number, ecode);


dcl  ecode fixed bin (35);
dcl  data_ptr ptr;
dcl  index_changed bit (1) init ("0"b);
dcl  seg fixed bin;
dcl  (word, number) fixed bin (18);

	if ^amu_$return_val_per_process (amu_info_ptr, seg) then do;
	     index_changed = "1"b;
	     call amu_$fdump_mpt_temp_change_idx (amu_info_ptr, lbound (fdump_process_table.array, 1));
	     end;
	call amu_$do_translation (amu_info_ptr, seg, data_ptr, word, number, ecode);
	if index_changed = "1"b then do;
	     call amu_$fdump_mpt_revert_idx (amu_info_ptr);
	     index_changed = "0"b;
	     end;
     end get_data;
%page;


get_trans:
           proc (segno) returns (ptr);
dcl segno fixed bin;
dcl t_ptr ptr;
dcl amu_$translate_get entry (ptr, fixed bin, ptr, fixed bin(35));
dcl amu_$fdump_translate_get_translation entry (ptr, ptr, ptr, fixed bin(35));

	 call amu_$translate_get (amu_info_ptr,segno,t_ptr,code);
	 if t_ptr ^= null () then return (t_ptr);
	 else do;
	      t_ptr = addr(translation_space);
	      call amu_$fdump_translate_get_translation 
		 (amu_info_ptr,baseptr(segno),t_ptr,code);
	      if code ^= 0 then return (null ());
	      else return (t_ptr);
	 end;
      end get_trans;
      
		 

/* Internal Procedure to print apte								*/


print_apte:
     proc (added_info, structp, process_n);


dcl  added_info char (*);
dcl  structp ptr;
dcl  process_n fixed bin;
dcl  state_name char (10);
dcl  process_na pic "zz9";
dcl  real_apte_offset fixed bin (18);

dcl  STATE_NAMES (0:6) char (10) int static options (constant)
	init ("Empty", "Running", "Ready", "Waiting", "Blocked", "Stopped", "ptlocking");
dcl  WAITING fixed bin init (3) int static options (constant);

	aptep = structp;
	if bin (apte.state, 18) > hbound (STATE_NAMES, 1)
	then state_name = "Invalid";
	else state_name = STATE_NAMES (bin (apte.state, 18));

	process_na = process_n;
	real_apte_offset =
	     fixed (rel(aptep),18) - fixed (rel(hardcore_cur.tc_datap),18);
	

/* Print the interesting information from the apte */

	call ioa_$rsnnl ("^1a^2x^3a  APTE at ^6o changed to ^a^[ for ^w^;^s^]",
	     temp_string, tsl, 
	     substr (CPU_TAG, bin (apte.pr_tag, 3) + 1, 1),
	     process_na, real_apte_offset, state_name,
	     (bin (apte.state, 18) = WAITING), apte.wait_event);
	
	if match_info_ptr = null () then call ioa_ ("^a", temp_string);
	else call mh_or_ex (""b);

     end print_apte;
%page;
/* Internal Procedure to print Connect to Device information					*/


print_device_data:
     proc (added_info, structp, process_n);

dcl  added_info char (*);
dcl  structp ptr;
dcl  process_n fixed bin;				/* not meaningful for this data		*/

dcl  1 iom_dev_data aligned like per_device based (structp);

	call ioa_$rsnnl ("^8xConnect to ^1a ^2d", temp_string, tsl, substr (IOM_TAG, iom_dev_data.iom, 1), iom_dev_data.channel);
	if match_info_ptr = null () then call ioa_ ("^a", temp_string);
	else call mh_or_ex (""b);

     end print_device_data;

%page;
/* Internam Procedure to print Disk Queue information */

print_disk_queue:
     proc (info, dq_data_ptr, process_char);

dcl  info char (*);
dcl  dq_data_ptr ptr;
dcl  process_char char (*);
dcl  type_io fixed bin;
dcl  dev_num char (2);
dcl  diskadd fixed bin;
dcl  fsx fixed bin;
dcl  p99 pic "99";
dcl  sect_sw bit (1);
dcl  subsys_name char (4);
dcl  DISK_IO_TYPE (0:6) char (7) static options(constant) init
	        ("Page RD","Page WT","Vtoc RD",
	         "Vtoc WT","Test","Boot RD","Boot WT");

	diskq_datap = dq_data_ptr;
	type_io = diskq_data.io_type;
	if pvtp = null () then do;			/* PVT not in dump - not to worry */
	     subsys_name = "dskX";
	     dev_num = "NN";
	     sect_sw = "1"b;			/* Can't translate to record */
	     diskadd = diskq_data.sector;
	     end;
	else do;
	     pvt_arrayp = addr (pvt.array);
	     pvtep = addr (pvt_array (diskq_data.pvtx));
	     if index (pvte.devname, "dsk") = 0 then subsys_name = "????";
	     else subsys_name = pvte.devname;
	     if pvte.logical_area_number < -99 | pvte.logical_area_number > 99 then pvte.logical_area_number = 0;
	     dev_num = convert (p99, pvte.logical_area_number);
	     sect_sw = sector_map (type_io);
	     if sect_sw
	     then diskadd = diskq_data.sector;
	     else do;
		fsx = pvte.device_type;
		diskadd =
		     diskq_data.cylinder * rec_per_cyl (fsx)
		     + divide (diskq_data.sector - diskq_data.cylinder * sect_per_cyl (fsx), sect_per_rec (fsx), 17);
		end;
	     end;


	call ioa_$rsnnl ("^8xDisk Queue: ^a_^a ^a ^[Sec^;Rec^] ^8o Mem ^8o^[ (I)^;^]",
	   temp_string, tsl,  
	   subsys_name, dev_num, DISK_IO_TYPE(type_io),
	     sect_sw, diskadd, diskq_data.coreadd, diskq_data.used);
	if match_info_ptr = null () then call ioa_ ("^a", temp_string);
	else call mh_or_ex (""b);

     end print_disk_queue;


%page;
/* Internal Procedure to print BCE machine conditions						*/


print_dump_mc:
     proc (added_info, structp, process_n);


dcl  added_info char (*);
dcl  structp ptr;
dcl  process_n fixed bin;				/* process number meaningless here		*/


	call print_scu_data (structp, added_info, "   ");


     end print_dump_mc;
%page;


/* Internal Procedure to print machine conditions 						*/

print_mc:
     proc (added_info, structp, process_n);


dcl  added_info char (*);
dcl  structp ptr;
dcl  process_n fixed bin;

dcl  process_na pic "zz9";
dcl  process_num char (3);

	process_na = process_n;
	process_num = process_na;
	call print_scu_data (structp, added_info, process_num);


     end print_mc;
%page;
/* Internal procedure to extract parameters from syserr_log event for printing				*/

print_syserr_log:
     proc (added_info, structp, process_n);

dcl  added_info char (*);
dcl  structp ptr;
dcl  process_n fixed bin;


/* Really, this should be using format_log_message_ and doing things
   right, but this should do for the moment. The conversion should be
   finished, however, when and if syserr_data is converted to use new
   format messages. */

	log_message_ptr = structp;
	call print_syserr_message (log_message.sequence, 
	     (log_message.severity), "syserr_log", 
	     length (log_message.text), addr (log_message.text));

	return;
     end print_syserr_log;

%page;
/* Internal procedure to print a syserr message							*/

print_syserr_message:
     proc (sequence, severity, log_name, textl, textp);


dcl  sequence fixed bin (35);				/* syserr sequence number			*/
dcl  severity fixed bin;				/* syserr severity code			*/
dcl  log_name char (*);				/* name of log where the message came from	*/
dcl  textl fixed bin (21);				/* length of message is chars			*/
dcl  textp ptr;					/* pointer to text of message			*/


dcl  linel fixed bin (21);
dcl  textl_done fixed bin (21);
dcl  textl_total fixed bin (21);
dcl  trim_eol fixed bin (21);


dcl  1 message based (textp),
       2 pad char (textl_done),
       2 this_line char (linel),
       2 rest char (textl_total - linel - textl_done);


dcl  LINE_MAX_LENGTH fixed bin init (59) int static options (constant);
dcl  TEXT_MAX_LENGTH fixed bin init (200) int static options (constant);


	call ioa_ ("^8xSyserr #^d (^a), severity ^d", sequence, log_name, severity);

	textl_total = min (TEXT_MAX_LENGTH, textl);
	textl_done = 0;
	linel = textl_total;
	if linel <= 0 then return;
	do while (linel > 0);
	     if linel > LINE_MAX_LENGTH then do;
		linel = LINE_MAX_LENGTH;
		trim_eol = index (substr (reverse (message.this_line), 1, 20), " ");
		linel = linel - trim_eol;
		end;
	     call ioa_ ("^21x^a", message.this_line);
	     textl_done = textl_done + linel;
	     linel = textl_total - textl_done;
	end;


     end print_syserr_message;
%page;
/* Internal procedure to prepare a syserr message from the wired log for printing			*/

print_wired_syserr:
     proc (added_info, structp, process_n);

dcl  added_info char (*);
dcl  structp ptr;
dcl  process_n fixed bin;

dcl  sequence fixed bin (35);
dcl  severity fixed bin;
dcl  textl fixed bin (21);
dcl  textp ptr;


	wmess_ptr = structp;
	sequence = wmess.seq_num;
	severity = wmess.code;
	textl = wmess.text_len;
	textp = addr (wmess.text);
	call print_syserr_message (sequence, severity, "syserr_data", textl, textp);

     end print_wired_syserr;


%page;
/* Internal procedure to print SCU data from machine conditions					*/

print_scu_data:
     proc (scu_data_ptr, info, process_char);

dcl  scu_data_ptr ptr;				/* pointer to scu data in machine conditions	*/
dcl  info char (*);					/* additional information to print		*/
dcl  process_char char (*);				/* process number printably			*/



dcl  cpu_alph char (1);
dcl  fault_no fixed bin;
dcl  fault_sub_type bit (36);
dcl  hardware_interrupt_level fixed bin;
dcl  hardware_interrupt_no pic "99";
dcl  interrupt_level pic "9";
dcl  interrupt_no fixed bin;
dcl  iom_number char (1);
dcl  line1 char (80) varying;
dcl  ptsr bit (1);
dcl  exp_seg_name char (256) varying;
dcl  seg_valid bit (1);
dcl  sub_type_inx fixed bin;

dcl  SR_IOA_STRING char (50) int static options (constant) init ("^21x^3a ^o|^o^[, ring ^1o^;^s^[ (^a)^;^s^]^]");
dcl  FAULT_TYPES (0:31) char (4) int static options (constant)
	init ("SDF", "STR", "MME", "FT1", "TRO", "CMD", "DRL", "LUF", "CON", "PAR", "IPR", "ONC", "SUF", "OFL", "DIV",
	"EXF", "DF0", "DF1", "DF2", "DF3", "ACV", "MME2", "MME3", "MME4", "FT2", "FT3", "INV", "INV", "INV", "INV",
	"INV", "TRB");
dcl  FAULT_TSR_VALID bit (32) init ("01110111011101101111111111000001"b) int static options (constant);

dcl  FAULT_MASK_INDEX (0:31) fixed bin int static options (constant) init (0, 1, (7) 0, 2, 3, 4, (8) 0, 5, (11) 0);
dcl  FAULT_MASKS (5) bit (21) aligned int static options (constant) init ("4140000"b3,
						/* Store					*/
	"0000030"b3,				/* Parity					*/
	"3600000"b3,				/* Illegal Procedure			*/
	"0000006"b3,				/* Operation Not Complete			*/
	"7777740"b3);				/* Access Violation				*/
dcl  FAULT_SUB_TYPES (5, 21) char (5) int static options (constant) init ("ISN", (4) (3)" ", "NEA", "OOB", (14) (3)" ",
						/* Store					*/
	(16) (3)" ", "PARU", "PARL", (3) (3)" ",	/* Parity					*/
	"   ", "IOC", "IA+IM", "ISP", "IPR", (16) (3)" ", /* Illegal Procedure			*/
	(18) (3)" ", "ONC1", "ONC2", "   ",		/* Operation Not Complete			*/
	"IRO", "OEB", "E-OFF", "ORB", "R-OFF", "OWB",	/* Access Violation				*/
	"W-OFF", "NO GA", "OCB", "OCALL", "BOC", "INRET", /* Access Violation				*/
	"CRT", "RALR", "AM-ER", "OOSB", (5) (1)" ");	/* Access Violation				*/


	exp_seg_name = "";

	scup = scu_data_ptr;
	cpu_alph = substr (CPU_TAG, bin (scu.cpu_no, 3) + 1, 1);
	if scu.fi_flag then do;			/* Fault					*/
	     fault_no = bin (scu.fi_num, 17);
	     line1 = "Fault:  " || FAULT_TYPES (fault_no);
	     ptsr = substr (FAULT_TSR_VALID, fault_no + 1, 1);
	     if FAULT_MASK_INDEX (fault_no) ^= 0 then do; /* subtype of fault				*/
		fault_sub_type = unspec (scu.fd) & FAULT_MASKS (FAULT_MASK_INDEX (fault_no));
		sub_type_inx = index (fault_sub_type, "1"b);
		if sub_type_inx ^= 0
		then line1 = line1 || " (" || rtrim (FAULT_SUB_TYPES (FAULT_MASK_INDEX (fault_no), sub_type_inx))
			|| ")";
		end;
	     end;
	else do;					/* Interrupt				*/
	     ptsr = "0"b;
	     interrupt_no = bin (scu.fi_num, 5);
	     hardware_interrupt_level = divide (interrupt_no, 4, 17);
	     if hardware_interrupt_level = 0 | hardware_interrupt_level = 6 then do;
		hardware_interrupt_no = interrupt_no;
		line1 = "Interrupt: Number " || hardware_interrupt_no;
		end;
	     else do;
		interrupt_level = hardware_interrupt_level + mod (hardware_interrupt_level + 1, 2);
		iom_number = substr (IOM_TAG, mod (interrupt_no, 4) + 1, 1);
		line1 = "Interrupt: IOM " || iom_number || ", Level " || interrupt_level;
		end;
	     end;

	call ioa_$rsnnl ("^1a^2x^3a^2x^32a^a", temp_string, tsl, cpu_alph, process_char, line1, info);
	if match_info_ptr = null () then call ioa_ ("^a", temp_string);
	else call mh_or_ex (""b);

	if long_report then do;
	     seg_valid = "0"b;
	     exp_seg_name =
		     amu_$get_name (amu_info_ptr, pointer (baseptr (bin (scu.ppr.psr, 15)), bin (scu.ilc, 18)));
	     if index (exp_seg_name, "CANNOT") = 0 then seg_valid = "1"b;
	     call ioa_$rsnnl (SR_IOA_STRING, temp_string, tsl, "by ",
		bin (scu.ppr.psr, 15), bin (scu.ilc, 18), scu.ppr.prr, scu.ppr.prr,
		seg_valid, exp_seg_name);
	     if match_info_ptr = null () then call ioa_ ("^a", temp_string);
	     else call mh_or_ex ("1"b);

	     if ptsr then do;			/* print TSR/CA if valid			*/

		seg_valid = "0"b;
		exp_seg_name =
			amu_$get_name (amu_info_ptr, pointer (baseptr (bin (scu.tpr.tsr, 15)), bin (scu.ca, 18)));
		if index (exp_seg_name, "CANNOT") = 0 then seg_valid = "1"b;
		call ioa_$rsnnl (SR_IOA_STRING, temp_string, tsl, "ref", bin (scu.tpr.tsr, 15), bin (scu.ca, 18), scu.tpr.trr, scu.tpr.trr,
		     seg_valid, exp_seg_name);
		if match_info_ptr = null () then call ioa_ ("^a", temp_string);
		else call mh_or_ex ("1"b);
		end;
	     end;

     end print_scu_data;
%page;
/* Internal Procedure to scan disk_seg and extract all queue entries */

process_disk_queue:
     proc (process_it);

dcl  disk_seg_ptr ptr;
dcl  process_it bit (1) aligned;

dcl  qx fixed bin;
dcl  queue_time fixed bin (71);
dcl  1 diskq_temp aligned like diskq_data;
          if ^new_disk_dim_sw then return;
	process_it = "0"b;
	if ^long_report then return;
          words_copied = sys_info$max_seg_size;
          call get_data (tsegp, dump_segno, 0, words_copied, code);
	if code ^= 0 then return;
	disk_seg_ptr = tsegp;
	disksp = disk_seg_ptr;
	if disk_data.array(1).mbz ^= "0"b then do;
	   new_disk_dim_sw = "0"b;
	   return;
	   end;
	do qx = 1 to disk_data.free_q_size;
	   qp = addr (disk_data.free_q_entries (qx));
	   if quentry.time ^= 0 then if
	        (^events_by_time | (events_by_time & quentry.time >= earliest_time)) then do;
	      diskq_temp.pvtx = quentry.pvtx;
	      diskq_temp.io_type = quentry.type;
	      diskq_temp.coreadd = bin (quentry.coreadd, 25);
	      diskq_temp.sector = bin (quentry.sector, 21);
	      diskq_temp.cylinder = quentry.cylinder;
	      diskq_temp.used = quentry.used;
	      queue_time =  quentry.time;
	      call add_an_event (queue_time, copy_to_temporary (addr (diskq_temp), size (diskq_temp)),
	         print_disk_queue, "Disk Queue", "0"b, "0"b);
	      end;
	   end;

	end process_disk_queue;

%page;

/* Internal Procedure to scan a per-process machine condition trace buffer
   for machine conditions */

process_mc_trace_buf:
     proc (process_it);

dcl  mctbp ptr;
dcl  process_it bit (1) aligned;

dcl  len fixed bin (21);
dcl  mcptr ptr;
dcl  mcx fixed bin;
dcl  mc_seg_offset char (30);
dcl  mct_scu_ptr ptr;
     
          words_copied = sys_info$max_seg_size;
          call get_data (tsegp, dump_segno, 0, words_copied, code);
	if code ^= 0 then return;
	mctbp = tsegp;

	process_it = "0"b;
	bp = mctbp;

	do mcx = 1 to mc_trace_buf.mc_cnt;
	     mcptr = addr (mc_trace_buf.mach_cond (mcx));
	     if addr (mcptr -> mc.scu (0)) -> scu.ppr.psr ^= "0"b then do;
		call ioa_$rsnnl ("mc_trace_buf (^o|^o)", mc_seg_offset, len, dump_segno, bin (rel (mcptr)));
		mct_scu_ptr = copy_to_temporary
		     (addr(mcptr -> mc.scu), size (scu));
		call add_an_event (bin (mcptr -> mc.fault_time, 54),
		     mct_scu_ptr, print_mc,
		     mc_seg_offset, "1"b, "0"b);
		end;
	end;

     end process_mc_trace_buf;


%page;
/* Internal procedure to setup call to scan inzr_stk0						*/
process_inzr_stk0:
     proc (process_it);

dcl  process_it bit (1) aligned;			/* flag to process segment again		*/

dcl  code fixed bin (35);
dcl  segp ptr;

	process_it = "0"b;				/* only come here once			*/
	call amu_$slt_search_seg_ptr (hardcore_cur.sltp, hardcore_cur.sltntp, "inzr_stk0", segp, code);
	if code ^= 0 then return;
	call walk_stack (bin (baseno (segp)), "inzr_stk0");

     end process_inzr_stk0;

%page;
/* Internal Procedure to scan iom_data for events of interest					*/

process_iom_data:
     proc  (process_it);

dcl  iom_data_p ptr;
dcl  process_it bit (1) aligned;

dcl  dev_no fixed bin;
dcl  per_device_p ptr;

          words_copied = sys_info$max_seg_size;
          call get_data (tsegp, dump_segno, 0, words_copied, code);
	if code ^= 0 then return;
	iom_data_p = tsegp;
	

	process_it = "0"b;				/* only come here once			*/
	iom_data_ptr = iom_data_p;
	if iom_data.n_devices > 0
	then do dev_no = 1 to iom_data.n_devices;
	     per_device_p = copy_to_temporary (addr (iom_data.per_device (dev_no)), size (per_device));
	     call add_an_event (iom_data.per_device (dev_no).connect_time, per_device_p, print_device_data,
		"per_device", "0"b, "0"b);
	end;


     end process_iom_data;


%page;

/* Internal Procedure to scan the PDS for events of interest					*/

process_pds:
     proc (process_it);


dcl  pdsp ptr;					/* pointer to copied-out pds			*/
dcl  process_it bit (1) aligned;			/* flag to process this seg again		*/



dcl  aptp ptr;
dcl  bpp ptr;
dcl  mcptr ptr;
dcl  mcp_scu_ptr ptr;
dcl  names_inx fixed bin;
dcl  pds_stacks_inx fixed bin;
dcl  pds_stacks_ptr ptr;


dcl  pds_names (3) char (32) int static options (constant) init ("page_fault_data", "fim_data", "signal_data");

dcl  based_flag fixed bin (35) based;
dcl  based_ptr ptr aligned based;
dcl  based_ptr_packed ptr unaligned based;
dcl  pds_stacks (0:7) ptr aligned based (pds_stacks_ptr);

          words_copied = sys_info$max_seg_size;
          call get_data (tsegp, dump_segno, 0, words_copied, code);
	if code ^= 0 then return;
	pdsp = tsegp;
	aptp = ptr (pdsp, amu_$definition_offset (amu_info_ptr, "pds", "apt_ptr", code));
	if code ^= 0 then do;
	     call amu_$error_for_caller ((null ()), code, MYNAME, "Cannot find pds$apt_ptr in dump.");
	     end;

	if aptp = null () then return;
	if rel (aptp -> based_ptr) = "0"b then return;

	apt_array.n_aptes = apt_array.n_aptes + 1;
	apt_array.apt_desc (n_aptes).offset = rel (aptp -> based_ptr);
	apt_array.apt_desc (n_aptes).procn = proc_no;


	do names_inx = 1 to hbound (pds_names, 1);
	     call validate_mc
		(pdsp, "pds", pds_names (names_inx),mcptr,mcp_scu_ptr);
	     if mcptr ^= null ()
	     then do;					/* machine condtions exist			*/
		call add_an_event (bin (mcptr -> mc.fault_time, 54),
		     mcp_scu_ptr, print_mc,
		     "pds$" || rtrim (pds_names (names_inx)), "0"b, "0"b);
		 end;
	end;

/* Extract stack segment numbers from the pds							*/

	pds_stacks_ptr = ptr (pdsp, amu_$definition_offset (amu_info_ptr, "pds", "stacks", code));
	if code ^= 0 then do;
	     call amu_$error_for_caller ((null ()), code, MYNAME, "Cannot find pds$stacks in dump.");
	     end;
	if fixed(rel(pds_stacks_ptr),18) >= words_copied then return;
	if pds_stacks_ptr = null () then return;
	do pds_stacks_inx = 0 to hbound (pds_stacks, 1);
	     if pds_stacks (pds_stacks_inx) ^= null ()
	     then stack_segs (pds_stacks_inx) = bin (baseno (pds_stacks (pds_stacks_inx)), 17);
	     else stack_segs (pds_stacks_inx) = -1;
	end;

/* Check whether this process is tracing machine conditions */

	bpp = ptr (pdsp, amu_$definition_offset (amu_info_ptr, "pds", "mc_trace_sw", code));
	if code ^= 0 then do;
	     call amu_$error_for_caller ((null ()), code, MYNAME, "Cannot find pds$mc_trace_sw in dump.");
	     end;

	if bpp = null () then return;
	if bpp -> based_flag = 0 then return;
	bpp = ptr (pdsp, amu_$definition_offset (amu_info_ptr, "pds", "mc_trace_buf", code));
	if code ^= 0 then do;
	     call amu_$error_for_caller ((null ()), code, MYNAME, "Cannot find pds$mc_trace_buf in dump.");
	     end;
	if bpp = null () then return;
	interesting_segs (MC_TRACE_BUF).process_this_seg = "1"b;
	interesting_segs (MC_TRACE_BUF).segno = bin (baseno (bpp -> based_ptr_packed), 18);


     end process_pds;

%page;
/* Internal procedure to scan prds for interesting events						*/

process_prds:
     proc (process_it);

dcl  prdsp ptr;					/* pointer to copied-out prds			*/
dcl  process_it bit (1) aligned;			/* flag to process prds again			*/



dcl  mcptr ptr;
dcl  mcp_scu_ptr ptr;
dcl  names_inx fixed bin;
dcl  processor_tag fixed bin;
dcl  prtag_based fixed bin aligned based;
dcl  prtagp ptr;
     

dcl  apte_offset bit (18);
dcl  bpp ptr;
dcl  based_ptr ptr based;
dcl  prds_names (3) char (32) int static options (constant) init ("sys_trouble_data", "interrupt_data", "fim_data");

          words_copied = sys_info$max_seg_size;
          call get_data (tsegp, dump_segno, 0, words_copied, code);
	if code ^= 0 then return;
	prdsp = tsegp;
	prtagp = ptr (prdsp, amu_$definition_offset (amu_info_ptr, "prds", "processor_tag", code));
	if code ^= 0 then do;
	     call amu_$error_for_caller ((null ()), code, MYNAME, "Cannot find prds$processor_tag in dump.");
	     end;
	if prtagp = null () then return;
	processor_tag = prtagp -> prtag_based;
	if processor_tag > 7 then goto define_bpp;

	if ^substr (prds_processor, processor_tag + 1, 1) /* seen this prds before			*/
	then return;
	substr (prds_processor, processor_tag + 1, 1) = "0"b;
	if prds_processor = "0"b then process_it = "0"b;	/* last prds on system			*/
define_bpp:
	bpp = ptr (prdsp, amu_$definition_offset (amu_info_ptr, "prds", "apt_ptr", code));
	if code ^= 0 then do;
	     call amu_$error_for_caller ((null ()), code, MYNAME, "Cannot find prds$apt_ptr in dump.");
	     end;
	if bpp = null ()
	then apte_offset = "0"b;
	else apte_offset = rel (bpp -> based_ptr);


	do names_inx = 1 to hbound (prds_names, 1);
	     call validate_mc
		(prdsp, "prds", prds_names (names_inx),mcptr,mcp_scu_ptr);
	     if mcptr ^= null () then do;
		call add_an_event (bin (mcptr -> mc.fault_time, 54),
		     mcp_scu_ptr, print_mc,
		     "prds$" || rtrim (prds_names (names_inx)),
		     (prds_names (names_inx) ^= "sys_trouble_data"),
		     apte_offset);
		end;
	end;


     end process_prds;
%page;
/* Internal procedure to extract messages from the wired syserr buffer				*/

process_syserr_data:
     proc (process_it);

dcl  syserr_data_ptr ptr;				/* pointer to copy of syserr_data		*/
dcl  process_it bit (1) aligned;			/* flag to process this seg again		*/

dcl  wlog_inx fixed bin;
dcl  wp ptr;
dcl  wtime fixed bin (71);
          words_copied = sys_info$max_seg_size;
          call get_data (tsegp, dump_segno, 0, words_copied, code);
	if code ^= 0 then return;
	syserr_data_ptr = tsegp;
	

	process_it = "0"b;				/* only come here once			*/

	wlog_ptr = ptr (syserr_data_ptr, amu_$definition_offset (amu_info_ptr, "syserr_data", "wired_log_area", code));
	if code ^= 0 then do;
	     call amu_$error_for_caller ((null ()), code, MYNAME, "Cannot find syserr_data$wired_log_area in dump.");
	     end;

	if wlog_ptr = null () then return;
	wmess_ptr = addr (wlog.buffer);

	if wlog.head.count < 1 then return;		/* no messages in buffer			*/

	do wlog_inx = 1 to wlog.head.count;
	     wp = copy_to_temporary (wmess_ptr, divide (length (unspec (wmess)), 36, 18));
	     wtime = wmess.time;
	     call add_an_event (wtime, wp, print_wired_syserr, "syserr_data", "0"b, "0"b);
	     wmess_ptr = addrel (wmess_ptr, divide (length (unspec (wmess)), 36, 18));
	end;


     end process_syserr_data;
%page;
/* Internal procedure to scan syserr log for messages within interval of interest			*/

process_syserr_log:
     proc (low_time, temp_ptr, log_name);


dcl  low_time fixed bin (71);				/* earliest time of interest			*/
dcl  temp_ptr ptr;					/* temporary segment we can use		*/
dcl  log_name char (32);				/* name of syserr log segment (Laurel or Hardy)   */

dcl  code fixed bin (35);
dcl  slog_p ptr;
dcl  slog_no fixed bin;
dcl  last_offset fixed bin (18);
dcl  first_time bit (1) aligned;
dcl  temp_message_ptr pointer;

dcl  log_segment_$last_message_info entry (ptr, fixed bin(35), fixed bin(18), fixed bin(35));
dcl  log_position_$next_message entry (ptr, ptr, bit(1) aligned);

/* Find syserr_log in the dump								*/

	call amu_$slt_search_seg_ptr (hardcore_cur.sltp, hardcore_cur.sltntp, log_name, slog_p, code);
	if code ^= 0 then do;
SLOG_ERROR:
	     call amu_$error_for_caller ((null ()), code, MYNAME,
		"Error encountered processing ^a", log_name);
	     return;
	     end;

	slog_no = bin (baseno (slog_p), 18);

/* Copy the log_segment header */

	range = size (log_segment_header);
	call get_data (temp_ptr, slog_no, 0, range, code);

	if code ^= 0 | range = 0 then goto SLOG_ERROR;

/* Find out how much was actually used in this segment, and copy out
   as much of the segment as that accounts for */

	call log_segment_$last_message_info (temp_ptr, (0), last_offset, code);
	if (code ^= 0) then goto SLOG_ERROR;

	range = last_offset;
	call get_data (temp_ptr, slog_no, 0, range, code);

	if code ^= 0 | range = 0 then goto SLOG_ERROR;

/* Romp through, picking out events within the interval of
   interest--i.e., times less than earliest one found elsewhere					*/

	log_message_ptr = null ();
	log_segment_ptr = temp_ptr;
	first_time = "1"b;

	do while (first_time | (log_message_ptr ^= null ()));
	     first_time = "0"b;
	     call log_position_$next_message (log_segment_ptr, log_message_ptr, ("0"b));

/* If there was another message available, see if it's in the desired
   time range, and add it to the list.  NOTE: This used to check to see 
   whether the message came after the time of the dump, but that seemed
   like a pretty silly thing to be checking, since if there ARE any 
   "later" messages, we certainly would want to see them. */

	     if (log_message_ptr ^= null ()) then
		if (log_message.time >= low_time) then do;
		     temp_message_ptr = copy_to_temporary (log_message_ptr, currentsize (log_message));
		     call add_an_event ((log_message.time), 
			temp_message_ptr, print_syserr_log,
			"syserr_log", "0"b, "0"b);
		     end;				/* of case of interesting message */
	     end;					/* of loop through log segment */

	return;

     end process_syserr_log;
%page;

/* Internal procedure to scan tc_data for interesting events					*/
process_tc_data:
     proc (process_it);

dcl  process_it bit (1) aligned;
dcl  aptx fixed bin;
dcl  bp ptr;
dcl  num_aptes fixed bin;
dcl  size_of_apte fixed bin;
dcl  tp ptr;
dcl  tp_base fixed bin (35);
dcl  real_apte bit (18);
dcl  fixed_apte fixed bin (35);
dcl  EMPTY fixed bin init (0) int static options (constant);
dcl  based_fixed fixed bin (35) aligned based;

	process_it = "0"b;				/* only process tc_data once			*/

/* amu_$hardcore_info_fdump claims that tc_data is translated contiguous */

	tp = hardcore_cur.tc_datap;
	tp_base = fixed (rel (tp),35);
	bp = addrel (tp, amu_$definition_offset (amu_info_ptr, "tc_data", "apt_size", code));
	if code ^= 0 then do;
	     call amu_$error_for_caller ((null ()), code, MYNAME, "Cannot find tc_data$apt_size in dump.");
	     end;
	if bp = null () then return;
	num_aptes = bp -> based_fixed;
	if num_aptes <= 0 then return;
	bp = addrel (tp, amu_$definition_offset (amu_info_ptr, "tc_data", "apt_entry_size", code));
	if code ^= 0 then do;
	     call amu_$error_for_caller ((null ()), code, MYNAME, "Cannot find tc_data$apt_entry_size in dump.");
	     end;

	if bp = null () then return;
	size_of_apte = bp -> based_fixed;
	if size_of_apte <= 0 then return;


	aptep = addrel (tp, amu_$definition_offset (amu_info_ptr, "tc_data", "apt", code));
	if code ^= 0 then do;
	     call amu_$error_for_caller ((null ()), code, MYNAME, "Cannot find tc_data$apt in dump.");
	     end;

	if aptep = null () then return;

	do aptx = 1 to num_aptes;
	     if bin (apte.state, 18) ^= EMPTY & apte.state_change_time ^= 0
	     then do;
		fixed_apte = fixed (rel(aptep),35) - tp_base;
		real_apte = substr(unspec(fixed_apte),19,18);
		call add_an_event
		     (apte.state_change_time, aptep, print_apte,
		     "apte", "0"b, real_apte);
	     end;
	     aptep = addrel (aptep, size_of_apte);
	end;


     end process_tc_data;
%page;
/* Internal procedure to set up a stack for scanning						*/

process_user_stack:
     proc (ring_no, stack_seg_no);

dcl  ring_no fixed bin;				/* ring number of stack in process		*/

dcl  stack_seg_no fixed bin;				/* segment number of stack in process		*/

dcl  ring_num pic "9";

	ring_num = ring_no;
	call walk_stack (stack_seg_no, "stack_" || ring_num);

     end process_user_stack;
%page;
/* Internal procedure to get interesting data from scs 						*/

setup_from_scs:
     proc (process_it);

dcl  scs_ptr ptr;					/* pointer to copy of scs			*/
dcl  process_it bit (1) aligned;			/* flag to process segment again		*/

dcl  proc_number fixed bin;
dcl  proc_exists_mask bit (8);
dcl  scs_proc_data_ptr ptr;

dcl  1 pdata (0:7) aligned like scs$processor_data based (scs_proc_data_ptr);
          words_copied = sys_info$max_seg_size;
          call get_data (tsegp, dump_segno, 0, words_copied, code);
	if code ^= 0 then return;
          scs_ptr = tsegp;

	process_it = "0"b;				/* process scs but once			*/
	proc_exists_mask = "0"b;
	scs_proc_data_ptr = ptr (scs_ptr, amu_$definition_offset (amu_info_ptr, "scs", "processor_data", code));
	if code ^= 0 then do;
	     call amu_$error_for_caller ((null ()), code, MYNAME, "Cannot find scs$processor_data in dump.");
	     end;

	if scs_proc_data_ptr = null () then return;

	do proc_number = 0 to hbound (pdata, 1);	/* find all cpus which might have been active	*/
	     if pdata (proc_number).online | pdata (proc_number).offline
	     then substr (proc_exists_mask, proc_number + 1, 1) = "1"b;
	end;
	prds_processor = prds_processor & proc_exists_mask;


     end setup_from_scs;


%page;
/* Internal procedure to check a named location for valid machine conditions.
   If machine conditions are stored, they are copied to temporary storage,
   and a pointer to the temporary storage area is returned						*/

validate_mc:
     proc (segptr, segname, mc_name,a_mc_ptr, a_scu_ptr);

dcl a_mc_ptr ptr;
dcl a_scu_ptr ptr;
dcl  segptr ptr;					/* pointer to base of copy of segment		*/
dcl  segname char (*);				/* segment name				*/
dcl  mc_name char (*);				/* entry name where machine conditions are stored */

dcl  mcptr ptr;


	mcptr = ptr (segptr, amu_$definition_offset (amu_info_ptr, segname, mc_name, code));
	if code ^= 0 then do;
	     call amu_$error_for_caller ((null ()), code, MYNAME, "Cannot find ^a$^a in dump.", segname, mc_name);
	     end;

	if mcptr = null () then goto mc_data_not_valid;

	if string (mcptr -> mc.scu) = "0"b then goto mc_data_not_valid;

	a_scu_ptr =  copy_to_temporary (addr(mcptr -> mc.scu), size (scu));
	a_mc_ptr = mcptr;
	return;
mc_data_not_valid:
	a_mc_ptr = null ();
	a_scu_ptr = null ();

	

     end validate_mc;
%page;
/* Internal procedure to validate a stack pointer and construct a pointer
   to it.  The pointer is checked to contain the segment number of the stack,
   to point to a mod-16 location, and to be within the bounds defined by
   the stack_end_ptr.  A pointer to the frame in the copy of the stack is constructed 			*/

validate_stack_ptr:
     proc (stack_ptr, seg_num, stack_base_ptr) returns (fixed bin (18));

dcl  stack_ptr ptr;					/* stack pointer from FDUMP			*/
dcl  seg_num fixed bin;				/* segment number of stack in FDUMP		*/
dcl  stack_base_ptr ptr;				/* pointer to copy of stack			*/

	if baseno (stack_ptr) = "077777"b3
	then					/* if null ptr */
	     return (-1);			/* return */


	if addr (stack_ptr) -> its.mod then return (-1);
						/* return */
	if addr (stack_ptr) -> its.bit_offset then return (-1);
						/* return */
	if addr (stack_ptr) -> its.its_mod ^= ITS_MODIFIER then return (-1);

	if bin (baseno (stack_ptr)) ^= seg_num
	     | bin (rel (stack_ptr)) >= bin (rel (stack_base_ptr -> stack_header.stack_end_ptr))
	     | mod (bin (rel (stack_ptr)), 16) ^= 0
	     | bin (rel (stack_ptr)) < bin (rel (stack_base_ptr -> stack_header.stack_begin_ptr))
	     | rel (stack_ptr) = "0"b
	then return (-1);
	return (fixed (rel (stack_ptr),18));


     end validate_stack_ptr;

%page;
/* Internal procedure to walk a stack looking for fim-frames
   the walk is done forward, and only frames within the current segment
   are considered (there really shouldn't be any outside of it)					*/

walk_stack:
     proc (stack_seg, stack_name);


dcl  stack_seg fixed bin;				/* segment number of stack			*/
dcl  stack_name char (*);				/* name of stack				*/
dcl  the_hard_way bit (1);
dcl  data1 char (d1_len) based;
dcl  data2 char (d2_len) based;
dcl  data3 char (d3_len) based;
dcl  (d1_len,d2_len,d3_len) fixed bin (21);
dcl  min_length fixed bin;
dcl  fm_scup ptr;
dcl  len fixed bin (21);
dcl  loop_count fixed bin;
dcl  next_frame_mc bit (1);
dcl  seg_offset char (13);
dcl  sp_offset fixed bin (18);
dcl  stack_frame_sw bit (1);
dcl  stack_frame_save (min_length) fixed bin (36) based (sp);
dcl  stack_header_sw bit (1);
dcl  (sp_save,sb_save) ptr;
dcl (illegal_modifier,fault_tag_1) condition;
     

     on illegal_modifier begin;
        goto stack_err_cond;
        end;

     on fault_tag_1 begin;
        goto stack_err_cond;
        end;
          code = 0;
	stack_header_sw,stack_frame_sw,the_hard_way = "0"b;
	translation_ptr = get_trans (stack_seg);
	if translation_ptr = null () then return;
	sb = translation.part1.ptr;
	if translation.flags.two_part then do;
	     if translation.part1.lth < size(stack_header) then do;

		allocate stack_header in (amu_area) set (sb);

		d1_len = translation.part1.lth * 4;
		d2_len = (size(stack_header) - translation.part1.lth) * 4;
		d3_len = size(stack_header) * 4;
		sb -> data3 = translation.part1.ptr -> data1 || translation.part2.ptr -> data2;
		sp_offset = validate_stack_ptr
		     (stack_header.stack_begin_ptr, stack_seg, sb);
		the_hard_way = "1"b;
		sb_save = sb;
		stack_header_sw = "1"b;
	     end;
	end;
	if ^stack_header_sw then sp_offset = validate_stack_ptr
	     (stack_header.stack_begin_ptr, stack_seg, sb);
	if sp_offset = -1 then goto stack_done;

	loop_count = 1000;
	next_frame_mc = "0"b;
	min_length = stack_frame_min_length + size(mc);
	if the_hard_way then goto do_the_hard_way;
	do sp_offset = sp_offset repeat validate_stack_ptr (stack_frame.next_sp, stack_seg, sb)
	     while (sp_offset ^= -1 & loop_count > 0);
	     if translation.flags.two_part then
		if (sp_offset + min_length) > translation.part1.lth then
		 goto do_the_hard_way;
	     sp = addrel (sb,sp_offset);
	     mcp = null ();
	     if next_frame_mc | valid_fim_ptr (stack_frame.return_ptr) then do;
		mcp = addrel (sp, stack_frame_min_length);
		if addr (mc.scu (0)) -> scu.ppr.psr ^= "0"b then do;
		     call ioa_$rsnnl ("^a|^o", seg_offset, len,
			stack_name, sp_offset);
		     fm_scup = copy_to_temporary (addr(mc.scu), size (scu));
		     call add_an_event (bin (mc.fault_time, 71), fm_scup,
			print_mc, seg_offset, "0"b, "0"b);
		     end;
		end;
	     next_frame_mc = "0"b;
	     if stack_frame_flags.signaller then next_frame_mc = "1"b;
	     loop_count = loop_count - 1;
	end;
	goto stack_done;
do_the_hard_way:
	if sp_offset < translation.part1.lth then do;

	     allocate stack_frame_save in (amu_area) set (sp);

	     d3_len = min_length * 4;
	     d1_len = (translation.part1.lth - sp_offset) * 4;
	     d2_len = d3_len - d1_len;
	     sp -> data3 = addrel(translation.part1.ptr,sp_offset) -> data1 || translation.part2.ptr -> data2;
	     stack_frame_sw = "1"b;
	     sp_save = sp;
	     goto jump_in;
	end;
	

	do sp_offset = sp_offset repeat validate_stack_ptr (stack_frame.next_sp, stack_seg, sb)
	     while (sp_offset ^= -1 & loop_count > 0);

	     sp = addrel (translation.part2.ptr,(sp_offset - translation.part1.lth));
jump_in:	     
	     mcp = null ();
	     if next_frame_mc | valid_fim_ptr (stack_frame.return_ptr) then do;
		mcp = addrel (sp, stack_frame_min_length);
		if addr (mc.scu (0)) -> scu.ppr.psr ^= "0"b then do;
		     call ioa_$rsnnl ("^a|^o", seg_offset, len,
			stack_name,sp_offset);
		     fm_scup = copy_to_temporary (addr(mc.scu), size (scu));
		     call add_an_event (bin (mc.fault_time, 71), fm_scup,
			print_mc, seg_offset, "0"b, "0"b);
		     end;
		end;
	     next_frame_mc = "0"b;
	     if stack_frame_flags.signaller then next_frame_mc = "1"b;
	     loop_count = loop_count - 1;
	end;

stack_done:
          revert fault_tag_1;
	revert illegal_modifier;
	if stack_frame_sw then 
	     free sp_save -> stack_frame_save in (amu_area);
	if stack_header_sw then 
	     free sb_save -> stack_header in (amu_area);
	code = 0;
	return;
stack_err_cond:
	call ssu_$print_message (sci_ptr,0,
	   "The ^a in process ^d contains invalid data.",
	   stack_name, proc_no);
	goto stack_done;
     end walk_stack;
%page;
valid_fim_ptr:
  proc (t_ptr) returns (bit (1));

dcl t_ptr ptr;
dcl its_ptr ptr;

  if bound_interceptors_ptr = null () then return ("0"b);
  its_ptr = addr(t_ptr);
  if its_ptr -> its.its_mod ^= ITS_MODIFIER then return ("0"b);
  if its_ptr -> its.mod ^= "0"b then return ("0"b);
  if its_ptr -> its.segno ^= baseno(bound_interceptors_ptr) then return ("0"b);
  return ("1"b);

  end valid_fim_ptr;
%page;
mh_or_ex:
     proc (long_data);

dcl  long_data bit (1) parameter;

     if long_data then do;
	if (good_match) then call ioa_ ("^a", temp_string);
	return;
     end;
     temp_string = temp_time || temp_string;

     good_match = match_strings_$test (match_info_ptr, rtrim(temp_string));
     if (good_match) then call ioa_ ("^a", temp_string);
     else if num_events > -1 then
	events_printed = events_printed - 1;
     return;
  end mh_or_ex;
%page;
%include amu_fdump_info;
%page;
%include amu_hardcore_info;
%page;
%include amu_info;
%page;
%include amu_translation;
%page;
%include apte;
%page;
%include bind_map;
%page;
%include bos_dump;
%page;
%include dskdcl;
%page;
%include fs_dev_types;
%page;
%include iom_data;
%page;
%include its;
%page;
%include mc;
%page;
%include mc_trace_buf;
%page;
%include object_info;
%page;
%include pvt;
%page;
%include pvte;
%page;
%include scs;
%page;
%include slt;
%page;
%include stack_frame;
%page;
%include stack_header;
%page;
%include syserr_data;
%page;
%include log_message;
%page; 
%include log_segment;

     end azm_display_fdump_events;
