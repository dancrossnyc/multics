/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


/* format: style4,ifthenstmt,ifthen,ind3,ll125,lineconind1 */
isolts_: proc;

/* isolts_ - the I_S_olated O_nL_ine T_est S_ystem (ISOLTS) driver
   initially coded by James A. Bush 6/78
   Modified 09/80 by R. Fakoury to make the operator message more understandable,
   to correct a bug when displaying the last error, to request input after invalid responce,
   to add a delay between operator request reconfig messages and to force the end pass message to the terminal.
   Modified 8102 by R. Fakoury to allow margin/nomargin options and to add the display_error in the initial request.
   Modified 8112 by R. Fakoury to correct an oversight in the operator message sequence,
   to add new numbers to inv_tst_ids.
   Modified 02/04/83 by R. Fakoury to add new test ids to the invalid test list.
   Modified 03/83 by R. Fakoury to allow -type option to the display request and the type option to a pas option request.
   Also put temp cludge to increase the timeout time for prg892/893.
   Modified 03/83 by Rick Fakoury to add call to tolts_util_$get_ttl_date, and
   tolts_util_$opr_msg.
   Modified 03/83 by Rick Fakoury to remove the (non_quick) option from interpret_action and run_pas.
   Modified 08/17/83 by Rick Fakoury to allow partial config printing & correct an error in display error of one.
   Modified 09/21/83 by R. Fakoury to check for a config card with no cpu type and to modify dps8 reconfig instructions.
   Modified 10/83 by R.Fakoury to implement auditor suggested changes.
   Modified 11/84 by R. Fakoury to changes the call from tolts_pcd_$config to tolts_util_$find_card, make tst893 invalid,
   and to use the system includes files for cpu.
*/

/* External entries */

dcl  tolts_util_$get_ttl_date entry (entry, char (6));
dcl  tandd_$check_isolts_resources entry (fixed bin (5), fixed bin (5), fixed bin (5), fixed bin (35));
dcl  tandd_$create_cpu_test_env entry (fixed bin (5), fixed bin (5), (4) bit (36), ptr, fixed bin (35));
dcl  tandd_$destroy_cpu_test_env entry;
dcl  tandd_$interrupt_test_cpu entry (fixed bin (35));
dcl  tolts_pcd_ entry (char (6), char (*));
dcl  tolts_util_$find_card entry (char (4), ptr);
dcl  tolts_util_$query entry (char (*), char (132) aligned, fixed bin, (32) char (28) varying, fixed bin);
dcl  tolts_util_$config entry (char (4), ptr, char (*) varying);
dcl  tolts_util_$bci_to_ascii entry (bit (*), char (*) varying, fixed bin);
dcl  tolts_util_$search entry (ptr, char (32), ptr, fixed bin, fixed bin (35));
dcl  tolts_util_$on_off entry (char (6), char (3), char (6));
dcl  tolts_util_$opr_msg entry;
dcl  isolts_err_log_$init entry (fixed bin (35));
dcl  isolts_err_log_$write entry (ptr, fixed bin, fixed bin, fixed bin (5), fixed bin (5));
dcl  isolts_err_log_$display entry (fixed bin, fixed bin, bit (1));
dcl  isolts_err_log_$dump entry (char (5), ptr, fixed bin (18), fixed bin, fixed bin (5), fixed bin (5));
dcl  dump_segment_ entry (ptr, ptr, fixed bin, fixed bin (18), fixed bin (18), bit (*));
dcl  timer_manager_$sleep entry (fixed bin (71), bit (2));
dcl  gload_ entry (ptr, ptr, fixed bin (18), ptr, fixed bin (35));
dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
dcl  cv_oct_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
dcl  cu_$cp entry (ptr, fixed bin (21), fixed bin (35));
dcl  bcd_to_ascii_ entry (bit (*), char (*));
dcl  tolts_alm_util_$ascii_to_bci_ entry (char (*) aligned, bit (*));
dcl  continue_to_signal_ entry (fixed bin (35));
dcl  (ioa_, signal, com_err_, ioa_$rsnnl, ioa_$nnl, opr_query_) entry options (variable);
dcl  iox_$close entry (ptr, fixed bin (35));
dcl  iox_$detach_iocb entry (ptr, fixed bin (35));

/* Automatic */

dcl  code fixed bin (35);				/* standard system error code */
dcl  (cpu_tag, scu_tag, cpu_port) fixed bin (5);		/* cpu and scu tags */
dcl  switches (4) bit (36);				/* read switch descrepency data */
dcl  bf_sw bit (1) init ("0"b);			/* brief option switch */
dcl  (nxt_tst, new_tst) char (3);			/* next test id for search */
dcl  cpu_type char (4);
dcl  (term, trm, trm1, pas_sw, mess_in_prog, ntype, run, option, trace_sw,
     dump_in_prog, idump, car_nz) bit (1) init ("0"b);
dcl  out_str char (136) varying;
dcl  com_string char (132) aligned;
dcl  add_opt char (6);
dcl  tim char (12);
dcl  delay_iter fixed bin init (300);
dcl  ttl_date char (6);
dcl  d_type char (5);
dcl  args (32) char (28) varying;
dcl  (pgm_offset, first, last) fixed bin (18);
dcl  (cmd_cnt, delay, i, j, k, c_len, bcd_chars, mtype, mlen, count, limit) fixed bin;
dcl  (pip, wseg_p, t_ptr, awcp, mptr, hdr_p) ptr;

/* Constants */

dcl  (quit, cleanup, finish) condition;
dcl  pname char (6) static options (constant) init ("isolts");
dcl  tags (0:7) char (1) static options (constant) init
      ("a", "b", "c", "d", "e", "f", "g", "h");
dcl  first_pft char (3) static options (constant) init ("01c");
dcl  pas_exec char (3) static options (constant) init ("061");
dcl  inv_tst_ids (22) char (3) static options (constant) init
      ("781", "782", "783", "784", "891", "894", "895", "897", "899", "908", "920", "921", "922", "923",
      "924", "927", "928", "929", "930", "975", "980", "990");
dcl  illegal_pas_opt (2) char (8) varying static options (constant) init
      ("cardin", "i/o");
dcl  NL char (1) int static options (constant) init ("
");
dcl  pas_delay fixed bin static options (constant) init (2);
dcl  pft_delay fixed bin static options (constant) init (2);
dcl  p_err bit (1) int static init ("1"b);		/* print error flag */
dcl  df_iocbp ptr int static init (null);		/* deck file iocb ptr */
dcl  isolate_cpu bit (1) int static;			/* cleanup flag */
dcl  (cont_pas, restart, end_pas, eopt) label;		/* target of non_local gotos */
dcl  iox_$user_output ptr ext;
dcl  (addr, addrel, fixed, hbound, index, length, ltrim, mod, null, ptr, rel,
     rtrim, search, string, substr, time) builtin;

/* Structures and based variables */

dcl  1 wseg based (wseg_p) aligned,			/* structure definition of PAS2 layout */
       2 int_vectors (0:31) bit (72),			/* 0 - 77 interrupt vectors */
       2 flt_vectors (0:31) bit (72),			/* 100 - 177 fault vectors */
       2 pad1 (32) bit (72),
       2 COW bit (36),				/* 300 Connect operand word */
       2 pad2 (10) bit (36),
       2 prt_out (30) bit (36),			/* 313 - 350 printer output buffer */
       2 cons_in (21) bit (36),			/* 351 - 375 console input buffer */
       2 pad3 (322) bit (36),
       2 opt_save (25) bit (36),			/* 1100 - 1130 options save area */
       2 pad4 (31) bit (36),
       2 is_mbx,					/* 1170 - 1177 ISOLTS mailbox area */
         3 control fixed bin (35),			/* ISOLTS in control, if non-zero */
         3 service fixed bin (35),			/* ISOLTS service requested flag, If non-zero */
         3 action_codes unaligned,			/* service action codes */
	 4 pad5 bit (21),
	 4 halt bit (1),				/* bit 21 - halt imediately */
	 4 pad6 bit (4),
	 4 ld_spgm bit (1),				/* bit 26 - load slave mode program */
	 4 ld_mpgm bit (1),				/* bit 27 - load master mode program or PFT */
	 4 wc_eop bit (1),				/* bit 28 - write console, end of program */
	 4 wc_opt bit (1),				/* bit 29 - write console, option request flag */
	 4 read bit (1),				/* bit 30 - read console */
	 4 wc_type bit (1),				/* bit 31 - write console, type message */
	 4 print bit (1),				/* bit 32 - print message */
	 4 err bit (1),				/* bit 33 - error flag */
	 4 pad7 bit (2),
         3 pgm_name bit (36),				/* word 3 - program name or ptr and wd count */
         3 pad8 (4) bit (36),
       2 pad9 (64) bit (36),
       2 wk_survey (16) bit (36),			/* 1300 - 1317 working survey table */
       2 pad10 (3359) bit (36),
       2 imw unaligned,				/* 7757 - IOM interrupt multiplexor word */
         3 pad bit (18),
         3 base bit (18),				/* base address */
       2 sys_survey unaligned,			/* 7760 - 7777 system survey table */
         3 iom0,					/* IOM 0 mailbox and port */
	 4 mbx bit (18),
	 4 port fixed bin,
         3 iom1_3 (3) bit (36),			/* same info for IOMs 1, 2, and 3 */
         3 console,					/* info on system console */
	 4 chan fixed bin (8),			/* console channel number */
	 4 pad bit (27),
	 4 cons_iom bit (36),			/* iom number that console is on */
         3 printer,					/* info about system printer */
	 4 chan fixed bin (8),			/* printer channel number */
	 4 pad bit (27),
	 4 prt_iom bit (36),			/* iom number that printer is on */
         3 cont_cpu,				/* info about control cpu */
	 4 f_vec bit (18),				/* fault vector base address */
	 4 port fixed bin,				/* control cpu port number */
         3 hi_mem,					/* info about highest addressable memory location */
	 4 address fixed bin,
	 4 pad bit (18),
         3 cpu_1,					/* info about cpu # 1 */
	 4 f_vec bit (18),				/* fault vector base address */
	 4 port fixed bin,				/* cpu # 1 port number */
         3 cpu2_4 (3) bit (36),			/* the same info for cpus 2, 3, and 4 */
         3 boot,					/* info on boot device */
	 4 chan fixed bin (8),			/* boot tape chan number */
	 4 pad bit (27),
	 4 iom bit (36),				/* iom number that boot tape is on */
       2 exec (28672) bit (36),			/* 10000 - 77777 PAS2 exec area */
       2 test_pgm (32768) bit (36);			/* 100000 - 177777 slave program area */

dcl  1 slave_hdr based (hdr_p) aligned,			/* slave program header template */
       (
       2 pgm_num bit (36),				/* pgm # in bcd (e.g. - pm700, pa864, ps955) */
       2 erlink bit (18),				/* error linkage pointer */
       2 pgm_rev bit (18),				/* program revision in bcd */
       2 p_int_tab bit (18),				/* pseudo interrupt vector ptr */
       2 pgm_size bit (18),				/* program size in words */
       2 tst_name bit (72),				/* test name */
       2 num_tests bit (18),				/* number of tests in program */
       2 xfer_p bit (18),				/* transfer table pointer */
       2 cksum bit (36),				/* check sum word before init. */
       2 program_name bit (108),			/* program name */
       2 pad (9) bit (36)
       ) unaligned;					/* pad area */

dcl  1 action like is_mbx.action_codes unaligned;		/* copy of action flags */
dcl  1 pi like rsw_1_3.port_info based (pip) unaligned;
dcl  wseg1 (65536) fixed bin based (wseg_p);		/* work seg as an array */
dcl  bcd_str bit (bcd_chars * 6) based (mptr);		/* bcd message input */
dcl  add_wc (2) fixed bin unaligned based (awcp);		/* address and word count */


%include config_cpu_card;
%page;


      isolate_cpu = "0"b;				/* reset cleanup flag */
      on cleanup call clean_up;			/* establish cleanup and */
      on finish call clean_up;			/* finish condition handlers */

      call tolts_util_$get_ttl_date (isolts_, ttl_date);
      call tolts_util_$on_off (pname, "on", ttl_date);	/* signon */

/* now get a pointer to our error message file */

      call isolts_err_log_$init (code);
      if code ^= 0 then				/* if problem */
         go to t_off;				/* wrap up and return */


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
/*											*/
/* Loop until user quits									*/
/*											*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/



      term = "0"b;					/* reset terminate cndition */
      do while (^term);
         call ioa_ ("^/***enter ""test cpu <tag>"", "" display_error"", ""test pcd"", ""msg"", or ""quit """);

/* Now find out what user wants to do */

ask:
         call tolts_util_$query ("??? ", com_string, c_len, args, cmd_cnt);
         if args (1) = "quit" | args (1) = "q" then	/* user wants to quit */
	  term = "1"b;				/* so let him */
         else if args (1) = "msg" then			/* user wants to send a msg to the operator */
	  call tolts_util_$opr_msg;
         else if args (1) = "display_error" | args (1) = "display"
	| args (1) = "derr" then do;			/* display error message */
	  do i = 2 to cmd_cnt by 1;

	     if args (i) = "-type" then do;
	        p_err = "0"b;
	        args (i) = "";
	        cmd_cnt = cmd_cnt - 1;
	     end;
	  end;
	  cmd_cnt = cmd_cnt - 1;
	  if ^display_log () then			/* go display requested log entries */

bad_rsp:	     call com_err_ (0, pname, "invalid response - ""^a""", com_string);
	  go to ask;
         end;
         else if cmd_cnt < 2 | args (1) ^= "test" then	/* bad input */
	  go to bad_rsp;
         else if args (2) = "pcd" then do;		/* user wants a list of avail. cpus and scus */
	  if cmd_cnt = 3 then call tolts_pcd_ ("isolts", (args (3)));
	  else call tolts_pcd_ ("isolts", "");
         end;
         else if args (2) ^= "cpu" then			/* user goofed */
	  go to bad_rsp;
         else do;					/* test cpu request */
	  trace_sw = "0"b;				/* reset trace switch if set */
	  if cmd_cnt < 3 then			/* not enough args */
	     go to bad_rsp;
	  cpu_tag = search ("abcdefgh", args (3));	/* convert cpu tag to number */
	  if cpu_tag = 0 then			/* not correct format */
	     go to bad_rsp;
	  term = "0"b;
	  scu_tag = -1;				/* default, let hardcore decide */
	  if cmd_cnt > 3 then do;			/* additional args */
	     trm = "0"b;				/* reset flag */
	     do i = 4 to cmd_cnt;			/* process rest of args */
	        if ^trm then			/* if tag flag not set */
		 if args (i) = "-memory"
		  | args (i) = "-mem" then trm = "1"b;	/* set tag flag */
		 else if args (i) = "-brief"
		  | args (i) = "-bf" then bf_sw = "1"b; /* set brief mode */
		 else if args (i) = "-trace" then	/* user wants to trace action codes */
		    trace_sw = "1"b;		/* set trace switch */
		 else go to bad_rsp;		/* tell user about his typing problem */
	        else do;				/* ok lets find the memory tag */
		 scu_tag = search ("abcdefgh", args (i));
		 if scu_tag = 0 then		/* did not find tag */
		    go to bad_rsp;
		 else scu_tag = scu_tag - 1;
		 trm = "0"b;			/* reset tag flag */
	        end;
	     end;
	  end;

	  cpu_cardp = null;
	  do while (^term);
	     call tolts_util_$find_card ("cpu", cpu_cardp);
	     if cpu_cardp = null then term = "1"b;
	     else if cpu_card.tag = cpu_tag then do;
	        if cpu_card.type ^= "l68"
	         & substr (type, 1, 3) ^= "dps" then do;
		 call ioa_ ("isolts_: unable to determine cpu type for cpu ^a", tags (cpu_tag - 1));
reask:		 call tolts_util_$query ("enter l68 or dps8 ", com_string, c_len, args, cmd_cnt);
		 if args (1) = "l68 "
		  | args (1) = "dps8" then cpu_type = args (1);
		 else do;
		    call ioa_ ("isolts_: invalid input pls reenter.");
		    goto reask;
		 end;
	        end;
	        else cpu_type = cpu_card.type;
	        term = "1"b;
	     end;
	  end;
	  cpu_tag = cpu_tag - 1;			/* a = 0, h = 7, etc */

/* Now lets go to hardcore and check if we can get resources to run */

	  call tandd_$check_isolts_resources (cpu_tag, scu_tag, cpu_port, code);
	  if code ^= 0 then do;			/* can't get what we need */
	     call abort (code);			/* go display config error */
	     go to cmd_loop;
	  end;
	  isolate_cpu = "1"b;			/* set flag for cleanup handler */

/* now  give the operator manual reconfiguration instructions */

	  if opr_com (cpu_tag, scu_tag) then		/* if permission denied */
	     go to cmd_loop;			/* then go release resources */

/* now go do actual reconfig and primitive cpu test */

	  call tandd_$create_cpu_test_env (cpu_tag, scu_tag, switches, wseg_p, code);
	  if code ^= 0 then do;			/* some problem */
	     call abort (code);			/* go display config error */
	     go to cmd_loop;
	  end;
	  call ioa_ ("^/reconfiguration complete");	/* tell user */

	  hdr_p = addr (wseg.test_pgm);		/* set test program header ptr */
	  wseg1 = 0;				/* clear out our memory area */
	  restart = restart_label;			/* set restart label */

/* now go run the pfts and pas2 */

restart_label:					/* target of non-local gotos */
	  call run_pas;
         end;
cmd_loop: call clean_up;				/* go release resources if assigned */
      end;

/* user is all done we can wrap up now */

t_off: call tolts_util_$on_off (pname, "off", ttl_date);	/* signoff */
      return;

%page;


/* run_pas - internal procedure to run and do the test sequencing of the pfts and pas2 */

run_pas: proc;

      nxt_tst = first_pft;				/* set up for first test */
      awcp = addr (is_mbx.pgm_name);			/* set up address/word count templete ptr */
      cont_pas = continue_pas;			/* set up continue label */
      end_pas = end_tst;				/* set up quit label */
      pgm_offset = 0;				/* preset loading offset for master mode program */
      trm, pas_sw, mess_in_prog, ntype, run, option, car_nz = "0"b;
						/* reset flags */
      dump_in_prog, idump = "0"b;

/* quit_handler - quit condition handler for isolts */

      on quit begin;				/* establish quit condition handler */

         if pas_sw then do;				/* if not in primitives */
	  ntype = "0"b;				/* force options type out */
	  string (action_codes) = "0"b;		/* clear out any existing action code */
	  if dump_in_prog & ^idump then do;		/* if dumping to file */
	     dump_in_prog = "0"b;			/* abort dump and return to options */
	     go to eopt;
	  end;
	  if option then do;			/* if we are in the option loop */
	     call ioa_ ("^/");			/* force new line */
	     car_nz = "0"b;
	     go to eopt;
	  end;
	  action_codes.halt = "1"b;			/* set halt imediate flag */
	  go to cont_pas;				/* perform non local go to */
         end;
         else call continue_to_signal_ (code);		/* if not in pas2 pass it on */

      end;

      call ioa_ ("^/start pft ^a^/", nxt_tst);

      do while (^trm);				/* loop until user quits */

/* search for test page in file system */

         call tolts_util_$search (df_iocbp, "pas." || nxt_tst, t_ptr, c_len, code);
         if code ^= 0 then do;			/* if couldn't find test page */
	  call com_err_ (code, pname, "searching for pas.^a", nxt_tst);
	  ntype = "0"b;
	  string (action_codes) = "0"b;
	  action_codes.halt = "1"b;
	  go to cont_pas;
         end;

/* load the core image into our work segment */

tout_retry: call gload_ (t_ptr, addrel (wseg_p, pgm_offset), 0, addr (gload_data), code);
         if code ^= 0 then do;			/* problem durring load */
	  call com_err_ (code, pname, "^a^/attempting to load pas.^a",
	   gload_data.diagnostic, nxt_tst);
	  return;
         end;

/* reset the isolts mailbox flags and set isolts control flag */

         if ^pas_sw then				/* if pft */
	  call set_survey;				/* go set up system survey */
         else do;
	  delay = pas_delay;
	  slave_hdr.cksum = gload_data.checksum;	/* set up deck checksum in pgm header */
         end;
         if nxt_tst = "892" | nxt_tst = "893"		/* thesetests cause timeouts */
	| nxt_tst = "955" then delay_iter = 600;	/* increase the delay until fixed */
         else delay_iter = 300;
         string (is_mbx.action_codes) = "0"b;		/* reset all action flags */
         is_mbx.pgm_name = "0"b;			/* reset program name */
continue_pas:					/* target of non local go tos */
         if is_mbx.control = 0 then			/* if flag is reset */
	  is_mbx.control = 65535;			/* set it to indicate isolts in control */
         is_mbx.service = 0;				/* reset service requested flag */
         if trace_sw then				/* if tracing action codes */
	  if string (action_codes) ^= "0"b then		/* and we have  bit 21 set */
	     call itrace;				/* go trace action code */

/* send interrupt to the cpu under test */

         call tandd_$interrupt_test_cpu (code);
         if code ^= 0 then do;			/* if couldn't interrupt */
	  call com_err_ (code, pname, "attempting to interrupt cpu ^a", tags (cpu_tag));
	  return;
         end;

/* now go to sleep for awhile */

         do i = 1 to 1000 while (is_mbx.service = 0);
         end;					/* give pas2 a chance if intermediate I/O */
         if is_mbx.service = 0 then			/* if didn't make it give up processor */
wait:	  call sleep (delay);
         if is_mbx.service = 0 then do;			/* if time out */
	  call ioa_ (" ");				/* make sure we return to collum 1 */
	  if ^pas_sw & nxt_tst ^= pas_exec then do;	/* if pft and not pas2 exec */
	     call com_err_ (0, pname,
	      "time out after ^d seconds while executing PFT ^a",
	      delay * delay_iter, nxt_tst);
	     call com_err_ (0, pname,
	      "check cpu ^a's maintenence panel and consult program listing to determine failure",
	      tags (cpu_tag));
	  end;
	  else if nxt_tst = pas_exec then		/* hung up while initializing pas exec */
	     call com_err_ (0, pname,
	      "time out after ^d seconds while initializing the pas2 executive",
	      delay * delay_iter);
	  else call com_err_ (0, pname,
	        "time out after ^d seconds while executing pas2 test ^a",
	        delay * delay_iter, nxt_tst);
	  trm1 = "0"b;
	  do while (^trm1);				/* loop until user gets it right */
	     call tolts_util_$query ("respond ""quit (q)"", ""retry (r)"", or ""continue (c)"" - ",
	      com_string, c_len, args, cmd_cnt);
	     if args (1) = "quit" | args (1) = "q" then	/* user wants to get out */
	        return;
	     else if args (1) = "retry"
	      | args (1) = "r" then			/* user wants to retry test */
	        go to tout_retry;
	     else if args (1) = "continue"
	      | args (1) = "c" then			/* wait some more */
	        go to wait;
	  end;
         end;
         else do;
	  string (action) = string (is_mbx.action_codes); /* copy action codes */
	  if trace_sw then				/* if tracing action codes */
	     call itrace;				/* go trace action code */
	  string (is_mbx.action_codes) = "0"b;		/* and reset */
	  call interpret_action;			/* do what the test wants */
         end;
end_tst:						/* target of non-local gotos */
      end;



   end run_pas;

%page;

/* interpret_action - internal procedure to interpret  the isolts action flags */

interpret_action: proc;

      if action.ld_mpgm | action.ld_spgm then do;		/* load next program request */
         call complete_err_mess;			/* go complete error message if one active */
         call bcd_to_ascii_ (substr (pgm_name, 13, 18), new_tst);
						/* convert tst id to ascii */
         if trace_sw then				/* if user tracing action codes... */
	  call ioa_ ("load pgm^a", new_tst);		/* tell him what we want to load */
         do i = 1 to hbound (inv_tst_ids, 1) while (new_tst ^= inv_tst_ids (i));
         end;					/* check validity of test id */
         if i <= hbound (inv_tst_ids, 1) then do;		/* If this test is illegal for isolts */
	  ntype = "1"b;				/* set flag so we don't type options message */
	  action_codes.halt = "1"b;			/* set halt imediate flag */
	  go to cont_pas;				/* perform non local goto */
         end;
         if ^pas_sw & ^bf_sw then			/* if PFT and not in brief mode ... */
	  call ioa_ ("*** end ^a, next ^a ***", nxt_tst, new_tst); /* display test seq for user */
         nxt_tst = new_tst;				/* pick up new test id and go find it */
         if action.ld_spgm then			/* if slave program to be loaded */
	  pgm_offset = fixed (rel (addr (wseg.test_pgm)), 18); /* set slave base */
         else pgm_offset = 0;				/* if master mode pgm then offset = 0 */
      end;					/* fall through and return */
      else if action.wc_type | action.wc_eop | action.wc_opt then do;
						/* write console */
         call complete_err_mess;			/* go complete error message if one active */
         mptr = ptr (wseg_p, add_wc (1));
         bcd_chars = add_wc (2) * 6;			/* get address and word count of message */
         call tolts_util_$bci_to_ascii (bcd_str, out_str, bcd_chars); /* convert bcd */
         if substr (out_str, 1, 1) = NL & length (out_str) > 2 then /* if new line strip it off */
	  out_str = substr (out_str, 2);
         if action.wc_type & length (out_str) >= 1 then	/* if output to go on same line */
	  car_nz = "1"b;
         if action.wc_opt | action.wc_eop then option = "1"b; /* if option type request */
         else option = "0"b;

         if ^ntype then do;				/* if no type flag is on ignore message */
	  call ioa_$nnl ("^[^/^]^a^[^/^]", (car_nz & length (out_str) > 1),
	   out_str, (^action.wc_opt & length (out_str) > 1 & ^option));
	  if length (out_str) > 1 then car_nz = "0"b;	/* reset carriage position switch */
         end;
         go to cont_pas;				/* perform non local goto */
      end;
      else if action.read then			/* enter options request */
         call enter_options;
      else if action.print then do;			/* output message to printer */
         mptr = ptr (wseg_p, add_wc (1));
         mlen = add_wc (2);				/* set word count of message */
         if dump_in_prog then				/* if we are getting dump reg info from pas2 */
	  call isolts_err_log_$dump (d_type, mptr, (mlen), 1, cpu_tag, scu_tag);
         else if action.err | mess_in_prog then do;	/* if new error message or one in progress */
	  if mlen > 1 & mlen < 5 & ^mess_in_prog then do; /* must be end pass & ^message */
	     mptr = ptr (wseg_p, add_wc (1));
	     bcd_chars = add_wc (2) * 6;		/* get address and word count of message */
	     call tolts_util_$bci_to_ascii (bcd_str, out_str, bcd_chars);
						/* convert bcd */
	     call ioa_ (" ^a", out_str);		/* print on terminal */
	     go to cont_pas;
	  end;
	  else if action.err then do;			/* if beginning of new message */
	     call complete_err_mess;			/* complete old one */
	     mess_in_prog = "1"b;			/* indicate an unfinished error message */
	     mtype = 1;				/* set message type flag to start of message */
	     if ^run then do;			/* if run option not in force */
	        call ioa_ ("^/*** an error has occurred ***^/");
						/* let user know about error */
	     end;
	  end;
	  else mtype = 2;				/* must be intermediate message */
	  call isolts_err_log_$write (mptr, mlen, mtype, cpu_tag, scu_tag);
         end;
         else do;					/* write it to users terminal for now */
	  bcd_chars = mlen * 6;			/* get word count of message */
	  call tolts_util_$bci_to_ascii (bcd_str, out_str, bcd_chars);
						/* convert bcd */
	  if ^bf_sw then do;			/* if not in brief mode */
	     call ioa_ ("^[^/^]^a", car_nz, out_str);	/* display message for user */
	     car_nz = "0"b;				/* reset carriage position switch */
	  end;
         end;
         go to cont_pas;				/* perform non local goto */
      end;

   end interpret_action;

%page;

/* enter_options - internal procedure to enter pas2 or isolts options and check for legality */

enter_options: proc;

      add_opt = "";					/* pad additional option  with blanks */
      mptr = ptr (wseg_p, add_wc (1));			/* get ptr to return options string */
      eopt = opt_mess;				/* set enter options label */
      if dump_in_prog then do;			/* dumping and we get here, means we are ready to dump */
         idump = "0"b;				/* octal from the Multics side */
         call isolts_err_log_$dump (d_type, addrel (wseg_p, first), last,
	2, cpu_tag, scu_tag);			/* dump it */
         idump, ntype, dump_in_prog = "0"b;		/* dump finsihed, reset flags */
         go to opt_mess;				/* and go to enter options */
      end;
      if ntype then do;				/* if we are forcing seq option */
         ntype = "0"b;				/* reset it so we don't come back */
         bcd_chars = 6;
         call tolts_alm_util_$ascii_to_bci_ ("seq", bcd_str);
						/* convert ascii to bcd */
         go to cont_pas;				/* and return to pas2 exec */
      end;

reenter:
      call tolts_util_$query (" ", com_string, c_len, args, cmd_cnt);
      if cmd_cnt = 0 then do;				/* if user typed NL char */
         option = "0"b;				/* reset options flag */
         go to cont_pas;				/* return to pas2 at point interrupted */
      end;

/* check for ISOLTS only options first */

      if option then do;				/* execute only if options request */
         if ck_isolts_opt () then			/* if isolts option, it has already been done */
	  go to opt_mess;				/* go to options again */
         else do;					/* must be pas2 option, check them for legality */
	  k = 0;
	  trm1 = "0"b;
	  if cmd_cnt > 0 then do;
	     do i = 1 to cmd_cnt while (^trm1);
	        if length (args (i)) > 2 then do;
		 if substr (args (i), 1, 3) = "prg"
		  | substr (args (i), 1, 3) = "tst" then
		    k = i;			/* set flag for later */
	        end;
	        else
		 do j = 1 to hbound (illegal_pas_opt, 1) while (^trm1);
		 if args (i) = illegal_pas_opt (j) then
		    trm1 = "1"b;			/* if illegal option */
	        end;
	     end;
	  end;
	  if trm1 then do;				/* if user has entered options not supported by ISOLTS */
	     call com_err_ (0, pname, "^a option not supported by ^a", args (i - 1), pname);
opt_mess:	     call ioa_$nnl ("^a", out_str);
	     go to reenter;
	  end;
	  if k ^= 0 then do;			/* if "prgxxx" or "tstxxx" option specified */
	     do i = 1 to hbound (inv_tst_ids, 1) while (substr (args (k), 4, 3) ^= inv_tst_ids (i));
	     end;
	     if i <= hbound (inv_tst_ids, 1) then do;	/* found bad tst id */
	        call com_err_ (0, pname, "^a not supported by ^a",
	         args (k), pname);
	        go to opt_mess;			/* let user try again */
	     end;
	  end;
	  if add_opt ^= "" then			/* if additional option */
	     com_string = rtrim (com_string) || " " || add_opt; /* add it to end */
	  if index (com_string, "run") ^= 0 then	/* if run option specified */
	     run = "1"b;
	  if index (com_string, "halt") ^= 0 then run = "0"b; /* reset run if halt option */
	  if index (com_string, "reset") ^= 0 then do;	/* if reset option */
	     run = "0"b;				/* reset run flag */
	     p_err = "1"b;				/* set print error flag */
	  end;
	  option = "0"b;				/* reset option flag */
         end;
      end;
      bcd_chars = length (rtrim (com_string));		/* get exact options string length */
      if mod (bcd_chars, 6) ^= 0
       then					/* if not already mod 6 */
         bcd_chars = bcd_chars + (6 - mod (bcd_chars, 6));	/* make output mod 6 */
      call tolts_alm_util_$ascii_to_bci_ (com_string, bcd_str); /* convert it to bcd */
      go to cont_pas;				/* perform non_local goto */

   end enter_options;



%page;

/* clean_up - internal procedure to establish a cleanup and finish condition handler */

clean_up: proc;

      if isolate_cpu then do;				/* if cleanup flag set */
         call tandd_$destroy_cpu_test_env;
         isolate_cpu = "0"b;				/* reset flag */
      end;
      if df_iocbp ^= null then do;			/* detach deck file if attached */
         call iox_$close (df_iocbp, code);
         call iox_$detach_iocb (df_iocbp, code);
         df_iocbp = null;
      end;

   end clean_up;

/* sw_mess_1, sw_mess_2 - subroutines to set up read switch error diagnostics */

sw_mess_1: proc (arg, mess);

dcl  (arg, mess) char (*);

      arg = rtrim (arg) || NL || mess;
      return;

sw_mess_2: entry (arg, mess);

      arg = rtrim (arg) || NL || "memory " || tags (i) || " " || mess;
      return;

   end sw_mess_1;

%page;

/* sleep - internal procedure to put process to sleep for specified time period */

sleep: proc (t_delay);

dcl  (t_delay, i) fixed bin;
dcl  tm_delay fixed bin (71);

      tm_delay = t_delay;
      do i = 1 to delay_iter while (is_mbx.service = 0);	/* loop until service requested or time out */
         call timer_manager_$sleep (tm_delay, "11"b);	/* sleep for specified seconds */
      end;

   end sleep;

/* complete_err_mess - internal subroutine to check if an error message is in progress and complete it */

complete_err_mess: proc;

      if ^pas_sw then				/* if still in primitives */
         if nxt_tst >= pas_exec then			/* set pas switch if in pas exec or pas pgm */
	  pas_sw = "1"b;
      if mess_in_prog then do;			/* if error message in progress */
         mess_in_prog = "0"b;				/* reset flag */
         call isolts_err_log_$write (null, 0, 3, 0, 0);	/* complete it */
      end;
   end complete_err_mess;

/* set_survey - internal procdure to set up system survey table */

set_survey: proc;

      delay = pft_delay;				/* set up pft delay value */
      iom0.mbx = "001400"b3;				/* set up iom 0 mailbox address */
      cont_cpu.f_vec, cpu_1.f_vec = "000100"b3;		/* set up fault vector address */
      iom0.port, cont_cpu.port, cpu_1.port = cpu_port;	/* set port number */
      imw.base = "001200"b3;				/* set interrupt multiplexor base */

   end set_survey;

%page;

/* itrace - internal procedure to trace action codes and time */

itrace: proc;

      tim = time;					/* get current time */
      call ioa_ ("^a.^a - action code = ^12.3b", substr (tim, 1, 4),
       substr (tim, 5, 3), string (action_codes));
   end itrace;

/* ck_isolts_opt - internal procedure to check and perform isolts only options */

ck_isolts_opt: proc returns (bit (1));

      if args (1) = "quit" | args (1) = "q" then do;	/* user wants to quit */
         trm = "1"b;				/* set terminate condition */
         go to end_pas;				/* perform non-local goto */
      end;
      else if args (1) = "restart" then			/* user wants to restart from PFTs */
         go to restart;				/* perform non-local goto */
      else if args (1) = "itrace_on"
       | args (1) = "itn" then			/* user wants to turn on trace */
         trace_sw = "1"b;
      else if args (1) = "itrace_off"
       | args (1) = "itf" then			/* user wants to turn trace off */
         trace_sw = "0"b;
      else if args (1) = "type"
       | args (1) = "atype" then do;			/* type messages */
         p_err = "0"b;				/* reset dprint error switch */
         if args (1) = "type" then			/* pas2 still thinks he */
	  add_opt = "print";			/* is going to printer */
         else add_opt = "aprint";
      end;
      else if args (1) = "print"
       | args (1) = "aprint" then do;			/* dprint messages */
         p_err = "1"b;				/* set dprint error switch */
         add_opt = args (1);				/* set additional option */
      end;
      else if args (1) = "test"
       & args (2) = "msg" then			/* user wants to communicate with the operator */
         call tolts_util_$opr_msg;
      else if args (1) = "display_error"
       | args (1) = "display"
       | args (1) = "derr" then do;			/* display error message */
         if ^display_log () then do;			/* go display requested log entries */
inv_display:
	  call com_err_ (0, pname, "invalid input - ""^a""", com_string);
	  return ("1"b);				/* reneter options */
         end;
      end;
      else if args (1) = "E" then do;			/* user wants to execute Multics command */
         com_string = ltrim (substr (com_string, 2));
         call cu_$cp (addr (com_string), length (com_string), code);
						/* execute Multics command */
      end;
      else if args (1) = "cdump" | args (1) = "mdump"
       | args (1) = "xdump" | args (1) = "sdump" then do;
         first = 0;					/* set defaults */
         last = 65535;
         d_type = args (1);
         if cmd_cnt > 1 then do;			/* if we have offset */
	  first = cv_oct_check_ ((args (2)), code);	/* convert offset arg */
	  if code ^= 0 | first > 65535 then		/* tell user what he typed wrong */
	     go to inv_display;
	  last = last - first;			/* adjust length */
	  if cmd_cnt > 2 then do;			/* if length arg supplied */
	     last = cv_oct_check_ ((args (3)), code);
	     if code ^= 0 | first + last > 65536 then	/* tell user what he typed wrong */
	        go to inv_display;
	  end;
         end;
         if args (1) = "cdump" then do;			/* if console dump requested */
	  call ioa_ ("^/^a ""cdump"" from ^o to ^o of cpu ^a using memory ^a^/",
	   pname, first, last + first, tags (cpu_tag), tags (scu_tag));
	  call dump_segment_ (iox_$user_output, addrel (wseg_p, first), 0, first, last, "01000000000"b);
	  dump_in_prog = "0"b;			/* entire cdump done from Multics side */
	  return ("1"b);				/* return for next option */
         end;
         else if args (1) = "sdump" then do;		/* if slave dump to be taken */
	  first = fixed (rel (hdr_p), 17);		/* set first to slave base */
	  last = fixed (slave_hdr.pgm_size, 17);	/* dump this many words */
	  if last = 0 then do;			/* no slave program loaded */
	     call ioa_ ("slave program not loaded");	/* tell user */
	     return ("1"b);				/* and return for next option */
	  end;
	  else if last > hbound (wseg.test_pgm, 1) then	/* in case there is garbage here */
	     last = hbound (wseg.test_pgm, 1) - 1;	/* set it to last loc in wseg */
         end;
         dump_in_prog, ntype, idump = "1"b;		/* set flags */
         return ("0"b);				/* let pas2 handle first part of dump */
      end;
      else return ("0"b);				/* not isolts option, go process pass options */
      return ("1"b);				/* isolts option has been processed */

   end ck_isolts_opt;

%page;

/* opr_com - internal procedure to relay manual reconfiguration intructions to operator */

opr_com: proc (icpu, iscu) returns (bit (1));

dcl  (icpu, iscu) fixed bin (5);
dcl  timer_manager$sleep entry (fixed bin (71), bit (2));
dcl  d fixed bin (71) init (1);

      opr_query_info.q_sw = "1"b;			/* must wait for opr to grant or deny permission */
      opr_query_info.prim = "grant";			/* set primary expected response */
      opr_query_info.alt = "deny";			/* set alternate expected response */
      opr_query_info.r_comment = "";
      call ioa_ ("asking operators permission to test cpu ""^a"" using memory ""^a""", tags (icpu), tags (iscu));
      call opr_query_ (addr (opr_query_info),
       "permission asked to test cpu ""^a"" using memory ""^a""", tags (icpu), tags (iscu));
      if opr_query_info.answer = "deny" then do;		/* if opr doesn't want us to use cpu */
         call ioa_ ("permission denied");		/* tell user the sad news */
         return ("1"b);				/* return and indicate denial */
      end;
      call ioa_ ("permission granted");			/* operator says it ok to test cpu */
      call ioa_ ("asking operator to manually reconfigure cpu ^a", tags (icpu));
      opr_query_info.q_sw = "0"b;			/* no operator response needed */
      call opr_query_ (addr (opr_query_info),
       "execute the following manual reconfiguration on cpu ""^a"":", tags (icpu));
      call timer_manager_$sleep (d, "11"b);		/* To prevent console messages from getting out of sync */
      call opr_query_ (addr (opr_query_info),
       " 1. set all port and initialize enable switches and interlace switches to off.");
      call timer_manager_$sleep (d, "11"b);		/* To prevent console messages from getting out of sync */
      if cpu_type = "dps8"
       then
         call opr_query_ (addr (opr_query_info),
	" 2. set the assignment switches for all ports to 000.");
      else if cpu_type = "l68 "
       then
         call opr_query_ (addr (opr_query_info),
	" 2. set all port assignment switches to 000 and the size switches to full");
      call timer_manager_$sleep (d, "11"b);		/* To prevent console messages from getting out of sync */
      if cpu_type = "dps8" then
         call opr_query_ (addr (opr_query_info),
	" 3. set store size switches to 2222.");
      else if cpu_type = "l68 "
       then
         call opr_query_ (addr (opr_query_info),
	" 3. remove the right free-edge connector on the 645pq wwb at slot ab28.");
      call timer_manager_$sleep (d, "11"b);		/* To prevent console messages from getting out of sync */
      if cpu_type = "dps8" then
         call opr_query_ (addr (opr_query_info),
	" 4. verify that the mode switch is in vms.");
      else if cpu_type = "l68 " then
         call opr_query_ (addr (opr_query_info),
	" 4. install the ""cpu test""  on the right free-edge connector at slot ab28.");
      call timer_manager_$sleep (d, "11"b);		/* To prevent console messages from getting out of sync */
      call opr_query_ (addr (opr_query_info),
       " 5. depress the initialize and clear push button.");
      call timer_manager_$sleep (d, "11"b);		/* To prevent console messages from getting out of sync */
      opr_query_info.q_sw = "1"b;			/* must wait for opr response */
      opr_query_info.prim = "done";			/* set primary expected response */
      opr_query_info.alt = "unable";			/* set alternate response */
      opr_query_info.r_comment = "when reconfiguration complete";
						/* set response comment */
      call opr_query_ (addr (opr_query_info),
       " 6. set the port enable switch ""on"" for port ""^a"".", tags (iscu));
      if opr_query_info.answer = "unable" then do;
         call ioa_ ("having problems reconfiguring");
         return ("1"b);
      end;

      else return ("0"b);				/* return and indicate manual reconfig complete */
   end opr_com;






%page;

/* display_log - internal procedure to display messages in the isolts_err_log */

display_log: proc returns (bit (1));

      if cmd_cnt = 1 then				/* if only last message wanted */
         count, limit = 1;
      else if cmd_cnt >= 2 & cmd_cnt < 4 then		/* count, limit or -all */
         if args (2) = "-all" then			/* print entire log */
	  count, limit = -1;
         else do;
	  count = cv_dec_check_ ((args (2)), code);	/* convert count */
	  if code ^= 0 then				/* must be dec number */
	     return ("0"b);				/* return error */
	  if cmd_cnt < 3 then			/* no limit specified, set to 1 */
	     limit = 0;
	  else do;
	     limit = cv_dec_check_ ((args (3)), code);
	     if code ^= 0 then			/* must be dec number */
	        return ("0"b);			/* return error */
	  end;
         end;
      else return ("0"b);				/* no more than 3 args allowed, return error */
      call isolts_err_log_$display (count, limit, p_err);	/* display requested err messages */
      return ("1"b);				/* return with no error */
   end display_log;

%page;

/* abort - internal subroutine to display reconfiguration error messages */

abort: proc (ecode);

dcl  ecode fixed bin (35);
dcl  (arg1, arg3, arg4) char (12);
dcl  arg2 char (128);

dcl  reconfig_err_message (17) char (64) static options (constant) init
      ("System dynamic reconfiguration in progress, try later", /* rcerr_isolts_locked */
      "cpu tag ^a is illegal",			/* rcerr_isolts_illegal_cpu */
      "cpu ^a is online and unavailable for test",	/* rcerr_isolts_cpu_online */
      "cpu ^a is not configured",			/* rcerr_isolts_no_config */
      "there must be at least two online scus to run isolts", /* rcerr_isolts_two_scu */
      "scu tag ^a is illegal",			/* rcerr_isolts_illegal_scu */
      "scu ^a is the bootload scu and cannot be used for testing", /* rcerr_isolts_bootload_scu */
      "scu ^a is not online",				/* rcerr_isolts_scu_not */
      "requesting process is not running isolts",		/* rcerr_isolts_not */
      "cpu ^a responded to interrupt cell ^a at loc ^a",	/* rcerr_isolts_wrong_cell */
      "cpu ^a responded to an interrupt cell ^a on scu ^a", /* rcerr_isolts_wrong_scu */
      "cpu ^a responded to an interrupt cell ^a on scu ^a at loc ^a", /* rcerr_isolts_wrong_scu_cell */
      "cpu ^a failed to respond to an interrupt cell ^a interrupt", /* rcerr_isolts_no_response */
      "the following switches on cpu ^a are set incorrectly: ^a", /* rcerr_isolts_bad_switches */
      "a ""lda 2"" did not operate properly",		/* rcerr_isolts_lda_fail */
      "a ""lda 65536"" (64k) failed to produce a store fault", /* rcerr_isolts_no_str_flt */
      "scu ^a has no interrupt mask register assigned to cpu ^a"); /* rcerr_isolts_no_mask */

      call com_err_ (0, pname, "the following errors were detected while attempting reconfiguration:^/");
      if ecode > 17 then				/* if standard error code */
         call com_err_ (ecode, pname, "attempting reconfiguration");

      else do;					/* reconfig error message */
         arg1, arg2, arg3, arg4 = "";			/* initialize args */
         if ecode > 9 & ecode < 14 then do;		/* if codes 10 - 13 */
	  rswp = addr (switches (1));			/* set ptr to cpu switch data */
	  arg1 = tags (cpu_tag);			/* set cpu tag arg */
	  call ioa_$rsnnl ("^d", arg2, i, rswp -> switch_w1.cell); /* set int cell number */
	  if ecode > 10 & ecode < 13 then		/* if codes 11 or 12 */
	     arg3 = tags (scu_tag);			/* set scu_tag */
         end;
         go to etype (ecode);				/* go set up correct message */

etype (2):					/* rcerr_isolts_illegal_cpu */
etype (3):					/* rcerr_isolts_cpu_online */
etype (4):					/* rcerr_isolts_no_config */
         arg1 = tags (cpu_tag);			/* cpu tag only */
         go to display_err;				/* display message */

etype (6):					/* rcerr_isolts_illegal_scu */
etype (7):					/* rcerr_isolts_bootload_scu */
etype (8):					/* rcerr_isolts_scu_not */
         arg1 = tags (scu_tag);			/* scu_tag only */
         go to display_err;				/* display message */

etype (10):					/* rcerr_isolts_wrong_cell */
         call ioa_$rsnnl ("^o", arg3, i, rswp -> switch_w1.offset);
         go to display_err;				/* display message */

etype (12):					/* rcerr_isolts_wrong_scu_cell */
         call ioa_$rsnnl ("^o", arg4, i, rswp -> switch_w1.offset);
         go to display_err;				/* display message */

etype (17):					/* rcerr_isolts_no_mask */
         arg1 = tags (scu_tag);
         arg2 = tags (cpu_tag);
         go to display_err;				/* display message */

etype (14):					/* rcerr_isolts_bad_swiches */
         arg1 = tags (cpu_tag);
         rswp = addr (switches (2));
         if cpu_type = "l68 " then do;
	  if dps_rsw_2.fault_base then
	     call sw_mess_1 (arg2, "fault base");
	  if dps_rsw_2.cpu_num ^= 0 then
	     call sw_mess_1 (arg2, "processor number");
         end;
         else if cpu_type = "dps8" then do;
	  if dps8_rsw_2.fault_base then
	     call sw_mess_1 (arg2, "fault base");
	  if dps8_rsw_2.cpu_num ^= 0 then
	     call sw_mess_1 (arg2, "processor number");
         end;
         rswp = addr (switches (4));
         do i = 0 to 7;
	  if i < 4 then
	     pip = addr (addr (switches (1)) -> rsw_1_3.port_info (i));
	  else pip = addr (addr (switches (3)) -> rsw_1_3.port_info (i - 4));

	  if pi.port_assignment then
	     call sw_mess_2 (arg2, "port assignment");
	  if pi.port_enable then
	     call sw_mess_2 (arg2, "port enable");
	  if pi.initialize_enable then
	     call sw_mess_2 (arg2, "initialize enable");
	  if pi.interlace_enable | rsw_4.four (i) then
	     call sw_mess_2 (arg2, "interlace");
	  if pi.mem_size ^= 0 then
	     call sw_mess_2 (arg2, "size");
	  if rsw_4.half (i) then
	     call sw_mess_2 (arg2, "half/full");
         end;

         go to display_err;				/* display_message */

etype (1):					/* rcerr_isolts_locked */
etype (5):					/* rcerr_isolts_two_scu */
etype (9):					/* rcerr_isolts_not */
etype (11):					/* rcerr_isolts_wrong_scu */
etype (13):					/* rcerr_isolts_no_response */
etype (15):					/* rcerr_isolts_lda_fail */
etype (16):					/* rcerr_isolts_no_str_flt */

display_err: call com_err_ (0, pname, reconfig_err_message (ecode), arg1, arg2, arg3, arg4);

      end;



   end abort;

%page;

%include rcerr;
%include rsw;
%include opr_query_info;
%include gload_data;

%page;

/* BEGIN MESSAGE DOCUMENTATION

   Message:   <Person>.<Project>.a: permission asked to test cpu <cpu_tag> using memory <mem_tag>

   S:  $beep

   T:  $run

   M:  <person>.<Project> is asking permission to test the indicated cpu that
   is currently deconfigured from the system. The indicated memory will be usurped
   until a primitive test is made on the processor to verify switch settings and
   to assure that a memory address above 64k cannot be generated without a store fault
   occurring. After this primitive test is complete, all memory in the indicated
   SCU above 64k will be given back to the system.
   Until processor testing is completed, the reconfiguration data base is locked
   thereby not allowing dynamic reconfiguration of processors, memories,
   or bulk store.

   A:  $info

   Message:   <Person>.<Project>.a: respond "grant" or "deny".

   S:  $beep

   T:  $run

   M:  <Person>.<Project> is expecting an operator response to either grant or
   deny  permission to test the indicated processor.
   The indicated response must be made via the opr_query_response command.

   A:  Operator must respond "grant" or "deny" via the opr_query_response command
   (or with the oqr entry in the admin ec; e.g. x oqr grant) to either grant or deny the test request.

   Message:   <Person>.<Project>.a: execute the following manual reconfiguration on cpu <tag>:

   S:  $beep

   T:  $run

   M:  <person>.<Project> is asking the operator to manually reconfigure
   the indicated processor.

   A:  $ignore

   Message:   <Person>.<Project>.a:  1. set all port and initialize enable switches to off.

   S:  $beep

   T:  $run

   M:  The first step of the manual reconfiguration instructions.

   A:  $ignore

   Message:   <Person>.<Project>.a:  2. set the assignment switches for all ports to 000.

   S:  $beep

   T:  $run

   M:  The second step of the manual reconfiguration instructions.

   A:  $ignore

   Message:   <Person>.<Project>.a:  3. remove the right free-edge connector on the

   S:  $beep

   T:  $run

   M:  The third step of the manual reconfiguration instructions.
   The indicated free-edge connector contains the port size plugs
   (maximum of 4) for the configured SCU ports.

   A:  $ignore

   Message:   <Person>.<Project>.a:     645pq wwb at slot 28l.

   S:  $beep

   T:  $run

   M:  Continuation of above message.

   A:  $ignore

   Message:   <Person>.<Project>.a:  4. install the "cpu test" free-edge connector at slot 28l.

   S:  $beep

   T:  $run

   M:  The fourth step of the manual reconfiguration instructions.
   The "cpu test" free-edge connector referred to is a special tool
   provided by Field Engingeering. It is simply a port free-edge connector with
   all 4 port groups wired for 64k.

   A:  $ignore

   Message:   <Person>.<Project>.a:  5. depress the initialize and clear push button.

   S:  $beep

   T:  $run

   M:  The fifth step of the manual reconfiguration instructions.

   A:  $ignore

   Message:   <Person>.<Project>.a:  6. set the port enable switch on for port <mem_tag>.

   S:  $beep

   T:  $run

   M:  The sixth and last step of the manual reconfiguration instructions.

   A:  $ignore

   Message:   <Person>.<Project>.a: respond "done" when reconfiguration complete.

   S:  $beep

   T:  $run

   M:  The indicated response must be made via the opr_query_response command.

   A:  Operator must respond "done" via the opr_query_response command
   (x oqr done), when reconfiguration is complete.

   END MESSAGE DOCUMENTATION */

   end isolts_;
