/****^  ************************************************************
        *                                                          *
        * Copyright, (C) Honeywell Information Systems Inc., 1983  *
        *                                                          *
        * Copyright, (C) Honeywell Information Systems Inc., 1980. *
        *                                                          *
        * Copyright (c) 1972 by Massachusetts Institute of         *
        * Technology and Honeywell Information Systems, Inc.       *
        *                                                          *
        ************************************************************ */





/* mtdsim_ - (Multics T & D Slave Interface Module) Procedure to drive the gcos T & D Modules
   known as slave mode polt and slave mode molt (and eventually slave mode colt)
   originally coded by J. K. Rhodes 4Q/1977
   extensive modification by J. A. Bush 9/78
   code added to drive slave mode molts by J. A. Bush 2/79
   initial release - MR7.0A
   Modified by J. A. Bush 12/79 for static mme handler and to handle new deckfile catalog format
   Modified by G. Haney & R. Fakoury  80/03/24 to handle mtar
   Modified by J. A. Bush 5/80 for several performance enhancements
   Modified by R. Fakoury 8/80 to handle the error return of "file not found" for a MME GCALL more cleanly.
   Modified by R. Fakoury 8/80 to handle dcw tally of 4096 correctly and to handle an incorrect density from rcp_.
   Modified by R. Fakoury 10/80 to set lostit_time = rcp_ max timeout.
   Modified by R. Fakoury 12/80 for colts implementation.
   Modified by R. Fakoury 10/81 to improve the quit handler.
   Modified by R. Fakoury 11/81 to attach the mpc for disk and tape mdrs.
   Modified by R. Fakoury 11/81 to dump the test exec when a machine fault is en countered.
   Modified by R. Fakoury 01/82 to allow more room for test colts test pages and to be more user friendly on bad test requests.
   Modified by R. Fakoury 03/17/82 to redesign mme allocr handler making it more effecient.
   Modified by R. Fakoury 04/82 to change mme feptype interface, to add a timer for colts attachments,
   add cleanner wrapup sequences for colts attach errors, and to add eurc pr54 support.
   Modified by R. Fakoury 09/30/82 to change illegal zero dcws to a valid single xfer dcw and output a message.
   Modified by R. Fakoury 11/01/82 to correct problem in Colts wrap-up & add 128 chan support.
   Modified by R. Fakoury 01/07/83 to increase the value of iom table words read from the fnp.
   Modified by R. Fakoury 01/21/83 to change the manner the tolts gets print train image to aggree with the way the system gets it.
   Modified by Rick Fakoury 03/16/83 to add a call to tolts_util_$get_ttl_date.
   Modified by R. Fakoury 09/83 to correct a 128chan bug.
   Modified by R. Fakoury 11/84 for hyperchan i/o.
   Modified by R.Fakoury 01/84 to accept multiple args & to implement a debugger for the slave execs.
   Modified by R Fakoury 04/84 to add a new field in sctcmp for DAU support, and to put a temp bypass for an ioi timing problem.
   Modified by R Fakoury 09/84 to correct a problem in get_px_tcx which caused io_sel to be invalid.
   Modified by R Fakoury & Benson Margulies 10/84 to correct problems encountered with new AS,
   to add more debugging functions, and to use convert_status_code instead of com_err.
*/





/****^  HISTORY COMMENTS:
  1) change(85-02-01,Fakoury), approve(86-08-20,MCR7514),
     audit(86-12-09,Martinson), install(86-12-09,MR12.0-1235):
      implement the test nio request (Dipper/MCA) with add debug aides,
      implement extented status store,
      further correct a problem in get_px_tcx,
      prevent returning to the subexec after a fault dump,
      support of a test rsp request (responder/DN8) with added debug aides,
      to dump machine conditions and history regs,
      to increase the bar value,
      to increase the timeout time for printer mdrs,
      to correct a problem encountered while attempting an attach for colts,
      to correct poorly written error messages.
  2) change(86-12-18,Fakoury), approve(86-12-18,MCR7514),
     audit(86-12-18,Martinson), install(86-12-19,MR12.0-1252):
     PBF to correct an error in MME POINTIT that returns the IO system type.
  3) change(86-12-19,Fakoury), approve(86-12-19,MCR7514),
     audit(87-01-05,Martinson), install(87-01-05,MR12.0-1254):
     Modified to correct a problems in MME DATA. One problem was caused by a
     change in the mca driver interface and the other problem was in the trace
     function.
  4) change(87-01-06,Fakoury), approve(87-01-06,MCR7514),
     audit(87-01-07,Martinson), install(87-01-08,MR12.0-1263):
     Corrected a Colt attachment problem by increasing the no responce count,
     corrected a problem in releasing the channel when a failure occurs.
                                                   END HISTORY COMMENTS */






/* mtdsim_ - (Multics T & D Slave Interface Module) Procedure to drive the gcos T & D Modules
   known as slave mode polt and slave mode molt (and eventually slave mode colt)
*/


/* format: style4,ifthenstmt,ifthen,ind3,ll125,lineconind1 */

mtdsim_: proc;


/* External entries */

dcl  bcd_to_ascii_ entry (bit (*) aligned, char (*));
dcl  com_err_ entry () options (variable);
dcl  continue_to_signal_ entry (fixed bin (35));
dcl  convert_dial_message_$return_io_module entry (fixed bin (71), char (*), char (*), fixed bin, 1 aligned,
      2 bit (1) unal, 2 bit (1) unal, 2 bit (1) unal, 2 bit (33) unal, fixed bin (35));
dcl  convert_status_code_ entry (fixed bin (35), char (*), char (*));
dcl  cpu_time_and_paging_ entry (fixed bin, fixed bin (71), fixed bin);
dcl  cu_$arg_count entry (fixed bin);
dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
dcl  cv_oct_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
dcl  dial_manager_$privileged_attach entry (ptr, fixed bin (35));
dcl  dial_manager_$release_channel entry (ptr, fixed bin (35));
dcl  dial_manager_$release_channel_no_listen entry (ptr, fixed bin (35));
dcl  dial_manager_$tandd_attach entry (ptr, fixed bin (35));
dcl  db_fnp_eval_ entry (ptr, fixed bin, char (*), ptr, char (*), fixed bin, fixed bin (35));
dcl  db_fnp_memory_$fetch entry (ptr, fixed bin, fixed bin, fixed bin, ptr, fixed bin (35));
dcl  get_temp_segment_ entry (char (*), ptr, fixed bin (35));
dcl  gload_ entry (ptr, ptr, fixed bin (18), ptr, fixed bin (35));
dcl  hcs_$wakeup entry (bit (36) aligned, fixed bin (71), ptr, fixed bin (35)); /* arg 3 is suppose to be fixed bin (71) */
dcl  hcs_$get_ips_mask entry (bit (36) aligned);
dcl  hcs_$set_ips_mask entry (bit (36) aligned, bit (36) aligned);
dcl  (ioa_, ioa_$rsnnl) entry () options (variable);
dcl  ioi_$connect entry (fixed bin (12), fixed bin (18), fixed bin (35));
dcl  ioi_$release_devices entry (fixed bin (12), fixed bin (35));
dcl  ioi_$set_channel_required entry (fixed bin (12), fixed bin (3), fixed bin (6), fixed bin (35));
dcl  ioi_$set_status entry (fixed bin (12), fixed bin (18), fixed bin (8), fixed bin (35));
dcl  ioi_$suspend_devices entry (fixed bin (12), fixed bin (35));
dcl  ioi_$timeout entry (fixed bin (12), fixed bin (52), fixed bin (35));
dcl  ioi_$workspace entry (fixed bin (12), ptr, fixed bin, fixed bin (35));
dcl  iox_$attach_name entry (char (*), ptr, char (*), ptr, fixed bin (35));
dcl  iox_$close entry (ptr, fixed bin (35));
dcl  iox_$control entry (ptr, char (*), ptr, fixed bin (35));
dcl  iox_$detach_iocb entry (ptr, fixed bin (35));
dcl  iox_$get_chars entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
dcl  iox_$modes entry (ptr, char (*), char (*), fixed bin (35));
dcl  iox_$open entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
dcl  iox_$put_chars entry (ptr, ptr, fixed bin (21), fixed bin (35));
dcl  ioi_$connect_pcw entry (fixed bin (12), fixed bin (18), bit (36), fixed bin (35));
dcl  ipc_$block entry (ptr, ptr, fixed bin (35));
dcl  ipc_$delete_ev_chn entry (fixed bin (71), fixed bin (35));
dcl  ipc_$drain_chn entry (fixed bin (71), fixed bin (35));
dcl  ipc_$read_ev_chn entry (fixed bin (71), fixed bin, ptr, fixed bin (35));
dcl  mca_$attach_ipc entry (char (*), fixed bin, fixed bin, fixed bin (35));
dcl  mca_$attach_mca entry (char (*), fixed bin (71), fixed bin, fixed bin (35));
dcl  mca_$detach_ipc entry (char (*), fixed bin, bit (1), fixed bin (35));
dcl  mca_$detach_mca entry (fixed bin, fixed bin (35));
dcl  mca_$load_ipc entry (fixed bin, fixed bin, bit (36), fixed bin (35));
dcl  mca_$tandd_read_data entry (fixed bin, ptr, fixed bin, bit (36), fixed bin (35));
dcl  mca_$tandd_write_data entry (fixed bin, ptr, fixed bin, bit (36), fixed bin (35));
dcl  mca_$tandd_write_text entry (fixed bin, ptr, fixed bin, bit (36), fixed bin (35));
dcl  mca_$reset entry (fixed bin, bit (36), fixed bin (35));
dcl  opr_query_ entry () options (variable);
dcl  rcp_$attach entry (char (*) aligned, ptr, fixed bin (71), char (*), bit (36) aligned, fixed bin (35));
dcl  rcp_$check_attach entry (bit (36) aligned, ptr, char (*), fixed bin (12),
      fixed bin (19) aligned, fixed bin (71) aligned, fixed bin, fixed bin (35));
dcl  rcp_$detach entry (bit (36) aligned, bit (*), fixed bin, char (*), fixed bin (35));
dcl  rcp_priv_$attach entry (char (*) aligned, ptr, fixed bin (71), char (*), bit (36) aligned, fixed bin (35));
dcl  probe entry options (variable);
dcl  terminate_process_ entry (char (*), ptr);
dcl  timer_manager_$alarm_wakeup entry (fixed bin (71), bit (2), fixed bin (71));
dcl  timer_manager_$sleep entry (fixed bin (71), bit (2));
dcl  timer_manager_$reset_alarm_wakeup entry (fixed bin (71));
dcl  tolts_alm_util_$ascii_to_bcd_ entry (char (*), bit (*));
dcl  tolts_alm_util_$enter_ccc_req_ entry (ptr, bit (36));
dcl  tolts_alm_util_$enter_slave_ entry (ptr);
dcl  tolts_alm_util_$gen_ck_sum entry (ptr);
dcl  tolts_alrm_util_$quit entry;
dcl  tolts_device_info_ entry (ptr, fixed bin, fixed bin);
dcl  tolts_file_util_$close entry;
dcl  tolts_file_util_$open entry (fixed bin (35));
dcl  tolts_file_util_$snap entry (ptr);
dcl  tolts_file_util_$wdump entry (ptr);
dcl  tolts_load_firmware_ entry (fixed bin, fixed bin (35));
dcl  tolts_init_ entry (char (4), fixed bin (35));
dcl  tolts_init_$clean_up entry;
dcl  tolts_init_$cr_event_chan entry (fixed bin (71), bit (1), entry, ptr, fixed bin, fixed bin (35));
dcl  tolts_io_int_ entry;
dcl  tolts_qttyio_ entry (char (*), fixed bin);
dcl  tolts_qttyio_$dcw_list entry (ptr, fixed bin);
dcl  tolts_qttyio_$dcw_ptr entry (ptr, fixed bin, fixed bin);
dcl  tolts_qttyio_$rcw entry (ptr);
dcl  tolts_qttyio_$rs entry () options (variable);
dcl  tolts_util_$cata_sel entry (ptr, char (32), ptr, fixed bin (35));
dcl  tolts_util_$find_card entry (char (4), ptr);
dcl  tolts_init_$gc_tod entry (bit (36));
dcl  tolts_util_$get_ttl_date entry (entry, char (6));
dcl  tolts_util_$search entry (ptr, char (32), ptr, fixed bin, fixed bin (35));

/* AUTOMATIC */

dcl  bufp ptr;
dcl  (nargs, return_value, c_len, n_dialed, len, tio, dealc_err, ev_occurred,
     i, j, mesg_len, ndcws, tally, t_err) fixed bin init (0);
dcl  (chan_name, io_module) char (32);
dcl  (error, c_error, mem_needed) fixed bin (35) init (0);
dcl  filename_idx fixed bin;
dcl  lvl_idx fixed bin;
dcl  imu_found bit (1) init ("0"b);
dcl  iom_found bit (1) init ("0"b);
dcl  iom fixed bin (3), chan fixed bin (6), tio_off fixed bin (18), timeout_time fixed bin (52) init (0);
dcl  cpu_time fixed bin (71);
dcl  wake_time fixed bin (71) init (500000);
dcl  mem_now fixed bin (19);
dcl  (pcwa, bcd_callname, gcos_tod) bit (36);
dcl  b18 bit (18);
dcl  bit_buf bit (72);
dcl  pad_char bit (6);
dcl  sb_data_idx fixed bin;
dcl  ws_data_idx fixed bin;
dcl  (argptr, train_ptr, tp, cltp, t_ptr, ioe_ptr, l_ptr, gcatp, info_ptr) ptr;
dcl  coment char (256), shortinfo char (8), lginfo char (100), message char (512), ac_name char (6);
dcl  workspace_move char (c_len * 4) based (bufp);


/* INTERNAL STATIC */

dcl  (gicm_count, io_sel, isc_cntdn, last_mme, mme_number, nr_cnt) fixed bin int static init (0);
dcl  (term, gndc_flag, found, gelbar, glb_brk, in_ccc, isc_ccc_rqt, mpc_io, trace_save, debug, debugging,
     rd_blk, flt_flag, alt_flag, q_flag, rd_flag, tcd, trace_io, trace, itr_run) bit (1) aligned int static init ("0"b);
dcl  tolts_active bit (1) aligned int static init ("0"b);	/* flag for epilogue handler */
dcl  db_addr fixed dec int static;
dcl  exec char (4) int static;
dcl  ttl_date char (6) int static;
dcl  (old_mask, new_mask) bit (36) aligned int static;
dcl  clt_sw char (32) varying int static;
dcl  io_block_len fixed bin;
dcl  (gicmp, icmp, mvp, ricmp, ticmp, wicmp) ptr int static init (null);
dcl  (l, k) fixed bin (6) int static;
dcl  code fixed bin (35) init (0) int static;
dcl  db_sv_wd bit (36) int static;
dcl  (gerout_num, icm_tally, fnp_addr, fnp_num, remote_inquiry_ic) fixed bin int static;
dcl  att_desc char (40) int static;
dcl  (mmep, genp) ptr int static;
dcl  (arglen, n_read) fixed bin (21) int static;
dcl  blk_lbl label int static;
dcl  emsg char (40) int static;
dcl  term_lbl label int static;
dcl  no_blk label int static;

/* EXTERNAL STATIC */

dcl  error_table_$bad_command_name fixed bin (35) ext static;
dcl  error_table_$force_unassign external fixed bin (35);
dcl  error_table_$resource_unavailable external fixed bin (35);
dcl  printer_images_$n_images fixed bin external;
dcl  printer_images_$image_base external;
dcl  printer_images_$image_offsets (10) fixed bin (18) external;
dcl  printer_images_$image_numbers (10) fixed bin external;
dcl  sys_info$alrm_mask bit (36) aligned ext;

/* BASED */

dcl  arg char (arglen) based (argptr);
dcl  data_move char (c_len * 4) based (mvp);
dcl  prt_image (64) char (288) based unaligned;
dcl  exec_wd (0:210000) bit (36) based (execp);
dcl  ioe (11) bit (36) based (ioe_ptr);
dcl  reg_move bit (36 * 8) based aligned;
dcl  fix_wd (2) fixed bin (18) unsigned unaligned based (genp);
dcl  sctwrk (12) bit (36) based (genp);
dcl  mme_call_w (0:11) bit (36) based (mmep) aligned;	/* mme call template for full words */
dcl  1 mme_call_hw (0:11) based (mmep) aligned,		/* mme template for half words */
       (2 upper bit (18),
       2 lower bit (18)) unaligned;

dcl  1 mme_call_hf (0:11) based (mmep) aligned,		/* mme template for fixed half words */
       (2 upper fixed bin,
       2 lower fixed bin) unaligned;

/* STRUCTURES */

/* The following structure declaration defines the gcos slave prefix area as used by the slave
   mode execs. Only areas used by the execs have been defined, the remaining area is set to
   padx. For a full description of the gcos slave prefix area, refer to gcos manual DD19. */

dcl  1 spa based (execp) aligned,			/* slave prefix area, 0 - 77 of slave pgm */
       (2 user_fault (0:10) bit (36),			/* 0 - 12 = user settable fault vectors */
       2 abort,					/* 13 = used for aborting slave pgm */
         3 add bit (18),				/*  U = abort address */
         3 code bit (18),				/*  L = abort reason code */
       2 pad1 (5) bit (36),
       2 glbtmr bit (36),				/* 21 = gelbar mode timer setting */
       2 glbici,					/* 22 = gelbar ic and i value */
         3 ic bit (18),				/*  U = instruction counter value */
         3 ind bit (18),				/*  L = indicator register */
       2 glbflt bit (36),				/* 23 = gelbar fault vector */
       2 pad2 (3) bit (36),
       2 wrapup_add bit (18),				/* 27 = exec wrap up address */
       2 pad3 bit (18),
       2 pad4 bit (36),
       2 acc_fault bit (36),				/* 31 = accumulated fault status word */
       2 enter,					/* 32 = entry into exec always at this point */
         3 lreg bit (36),				/* 32 = "lreg  spa.regs" instruction */
         3 lbar,					/* 33 = "lbar  bar,du" instruction */
	 4 bar bit (18),				/*  U = bar value to load */
	 4 inst bit (18),				/*  L = "230203"b3 (lbar  bar,du) */
         3 ret bit (36),				/* 34 = "ret  spa.enter.icivlu" instruction */
         3 icivlu,					/* 35 = return ic and i value */
	 4 ic bit (18),				/*  U = instruction counter */
	 4 ind bit (18),				/*  L = indicator register */
       2 ccc_icivlu bit (36),				/* 36 = ic and i storage while in courtesy call */
       2 pad5 bit (36),
       2 regs like mc.regs,				/* 40 = return register storage */
       2 ccc_regs like mc.regs,			/* 50 = courtesy call register storage */
       2 pad6 (16) bit (36)) unaligned;

dcl  1 fatal_desc aligned,
       2 version fixed bin,
       2 fatal_code fixed bin (35);

dcl  1 ci aligned like condition_info;

dcl  1 event_out static aligned like event_wait_info;

dcl  1 flags aligned,
       2 dialed_up bit (1) unal,
       2 hung_up bit (1) unal,
       2 control bit (1) unal,
       2 pad bit (33) unaligned;

dcl  1 cata based (io_info.catp) aligned,		/* template for deckfile catalog */
       2 n fixed bin,				/* number of entries */
       2 key (1 refer (cata.n)) char (24);		/* array of key names */

dcl  1 mca_gcata (100) based (gcatp) aligned,
         (2 equip_type bit (36),
       2 cat_index fixed bin,
       2 nblk fixed bin (13),
       2 dipper_flag bit (4),
       2 filename,
         3 filename bit (48),
         3 diskette_prod_tab bit (12),
         3 prog_tab bit (12)) unaligned;


dcl  1 gcata (1000) based (gcatp) aligned,		/* template for a gcos catalog entry */
       (2 edit_rev bit (36),				/* bcd edit name and rev */
       2 cat_index fixed bin,				/* deckfile catalog index */
       2 pad1 bit (3),
       2 nblk fixed bin (14),				/* (same as cat_index) */
       2 ident bit (36),				/* word 0 of ident blk */
       2 purpose bit (36)) unaligned;			/* deck purpose (itr, mdr or fw) */

/* The following structure declaration defines the gcos 11 word I/O  entry  as  used  by  the
   slave  mode  execs.  Only areas used by the execs have been defined, the remaining area is
   set to padx. For a full description of the gcos I/O entry, refer to gcos manual DD14. */

dcl  1 io_entry based (ioe_ptr) aligned,		/* :: */
       (2 pad1 bit (36),				/* word 0 unused */
       2 ext_sts fixed bin,				/* extented status address */
       2 pad2 bit (18),
       2 pad3 bit (5),
       2 sct_add bit (13),				/* system config table entry (test page index) */
       2 pad4 bit (18),
       2 pad5 bit (36),
       2 prim,					/* primary device info */
         3 dev_cmd bit (6),				/* device command */
         3 dev bit (6),				/* punch indicator if not "00"b3 */
         3 pad6 bit (6),
         3 io_cmd bit (6),				/* iom command */
         3 pad7 bit (6),
         3 record_count bit (6),			/* idcw/pcw record count */
       2 first_dcw like dcw,				/* first dcw relative to iom lal */
       2 pad8 bit (36),
       2 second,					/* secondary device info (the same as prim unless dual cmd) */
         3 dev_cmd bit (6),				/* device command */
         3 prex bit (12),				/* preselect index */
         3 io_cmd bit (6),				/* iom command */
         3 pad9 bit (5),
         3 ignore_term bit (1),			/* ignore terminate int, report special int if on */
         3 record_count bit (6),			/* idcw/pcw record count */
       2 dcw_ptr fixed bin,				/* pointer to dcw list (offset to lal) */
       2 pad10 bit (18),
       2 stat_p bit (18),				/* ptr to place to store status */
       2 ccc_p bit (18),				/* courtesy call ptr */
       2 pad11 bit (36)) unaligned;

dcl  1 colts_op_flags aligned ext static,
       2 colt_flag bit (1) unaligned init ("0"b),
       2 dm_attach bit (1) unaligned init ("0"b),
       2 dm_detach bit (1) unaligned init ("0"b),
       2 sicm bit (1) unaligned init ("0"b),
       2 gicm bit (1) unaligned init ("0"b);

dcl  1 gicm based (gicmp) aligned,
       2 cltp ptr init (null),
       2 ricmp ptr init (null),
       2 cc_addr bit (36),
       2 st_addr fixed bin,
       2 tally fixed bin (21);


dcl  1 ricm like icm based (ricmp);
dcl  1 wicm like icm based (wicmp);
dcl  1 ticm like icm based (ticmp);
dcl  1 icm based (icmp) aligned,
       (2 word_total bit (18),
       2 rbuf_addr bit (18),
       2 cksum bit (18),
       2 test_id bit (18),
       2 host_opcode bit (18),
       2 fnp_opcode bit (18),
       2 icm_buf (icm_tally) bit (36)) unaligned;

dcl  1 info_struct based (info_ptr) aligned,
       2 ev_chan fixed bin (71),
       2 out_pend bit;


/* constants */

dcl  (quit, lockup, illop, illegal_modifier, illegal_opcode, illegal_procedure,
     store, program_interrupt, cleanup, tolts_error_) condition;
dcl  (addr, addrel, bin, bit, divide, fixed, index, length, null, rel, rtrim, string, substr, time, unspec) builtin;
%page;
/* enviornment initialization */

      debug, debugging, q_flag, trace_io, trace = "0"b;
      exec = "";
      call cu_$arg_count (nargs);
      call cu_$arg_ptr (1, argptr, arglen, code);
      if arg ^= "polt" & arg ^= "molt" & arg ^= "colt" then do; /* invalid executive */
         call com_err_ (0, "mtdsim_", "Invalid executive code - ""^a""", exec); /* tell user */
         return;
      end;
      exec = arg;
      term = "0"b;
      if nargs > 1 then do;
         do i = 2 to nargs;
	  call cu_$arg_ptr (i, argptr, arglen, code);
	  if arg = "-debug" | arg = "-db" then debug = "1"b;

	  else if arg = "-quit" | arg = "-q" then q_flag = "1"b; /* user wants to return to command level on quits  */

	  else if arg = "-trace" | arg = "-tc" then trace = "1"b; /* user wants mme trace */
	  else if arg = "-trace_cata_data" | arg = "-tcd" then tcd = "1"b;
	  else if arg = "-tio" then trace_io = "1"b;
	  else if arg = "-probe" | arg = "-pb" then call probe (mtdsim_);
         end;
         debugging = "1"b;
      end;


      last_mme, isc_cntdn, tio = 0;
      trace_save, in_ccc, isc_ccc_rqt, rd_blk, gelbar, glb_brk, itr_run = "0"b; /* reset flags */
      gicm_count = 0;
      gicmp, ricmp, ticmp, wicmp = null;		/* initialize colts pointers */
      call tolts_init_ (exec, error);			/* go init our enviornment and create slave seg */
      if error ^= 0 then return;			/* if error durring init */
      on cleanup call clean_up;			/* establish cleanup handler */
      gndc_flag = "0"b;				/* flag to prevent recursive courtsey calls */
      call tolts_util_$get_ttl_date (mtdsim_, ttl_date);
      tolts_active = "1"b;				/* set active flag for epilogue handler */

/* search for <exec>cm in file system (exec can be polt, molt, or colt) */

      call tolts_util_$search (tolts_info.df_iocbp, substr (exec, 1, 1) || "lt." || exec || "cm", t_ptr, c_len, error);
      if error ^= 0 then do;				/* if couldn't find cplt */
         call com_err_ (error, exec, "searching for ^alt.^acm", substr (exec, 1, 1), exec);
         call tolts_init_$clean_up;			/* go delete our event channels and slave seg */
         return;
      end;
      call gload_ (t_ptr, execp, 0, addr (gload_data), error); /* load core image into our work segment */
      if error ^= 0 then do;				/* problem durring load */
         call com_err_ (error, exec, "^a^/attempting to load ^alt.^acm",
	gload_data.diagnostic, substr (exec, 1, 1), exec);
         call tolts_init_$clean_up;			/* go delete our event channels and slave seg */
         return;
      end;

      if debugging then call ioa_ (" execp = ^p", execp);

      if debug then do;
         debug = "0"b;
         tolts_info.mult_ans = "";			/* clear out response */
db_query:
         call tolts_qttyio_$rs (19, "tolts_debugger: enter break point address");
         call message_wait;				/* wait for user response */
         if mult_ans ^= "" then do;
	  db_addr = cv_oct_check_ ((rtrim (mult_ans)), code);
	  if code ^= 0 | db_addr > 65535 then do;
	     call ioa_ ("Debugger: invalid address supplied");
	     goto db_query;
	  end;
	  db_sv_wd = exec_wd (db_addr);
	  exec_wd (db_addr) = "777650001000"b3;
         end;
      end;


      blk_lbl = block_disp;
      term_lbl = done;
      no_blk = no_blk_disp;
      spa.enter.lreg = rel (addr (spa.regs)) || "073200"b3; /* set lreg instruction  (lreg  spa.regs) */
      if exec = "molt" then string (spa.enter.lbar) = "000630230203"b3; /* set initial lbar instruction (lbar =o630,du) */
      else string (spa.enter.lbar) = "000201230203"b3;	/* set initial lbar instruction (lbar =o200,du) */
      spa.enter.ret = rel (addr (spa.enter.icivlu)) || "630200"b3; /* set return instruction (ret  spa.enter.icivlu) */
      spa.enter.icivlu.ic = gload_data.definition (1).offset; /* set initial entry point */
      spa.enter.icivlu.ind = "0"b;			/* initial entry indicators are zero */
      on lockup begin;
         call ioa_ ("^a encountered a lockup fault ^[a dump will be taken^]", exec, ^flt_flag);
         if ^flt_flag then call fault_dump;
         else call continue_to_signal_ (error);
      end;
      on illop begin;
         call ioa_ ("^a encountered a illop fault ^[a dump will be taken ^]", exec, ^flt_flag);
         if ^flt_flag then call fault_dump;
         else call continue_to_signal_ (error);
      end;
      on illegal_modifier begin;
         call ioa_ ("^a encountered an illegal_modifier fault ^[a dump will be taken ^]", exec, ^flt_flag);
         if ^flt_flag then call fault_dump;
         else call continue_to_signal_ (error);
      end;
      on illegal_opcode begin;
         call ioa_ ("^a encountered an illegal_opcode fault ^[a dump will be taken ^]", exec, ^flt_flag);
         if ^flt_flag then call fault_dump;
         else call continue_to_signal_ (error);
      end;
      on illegal_procedure begin;
         call ioa_ ("^a encountered an illegal_procedure fault ^[a dump will be taken ^]", exec, ^flt_flag);
         if ^flt_flag then call fault_dump;
         else call continue_to_signal_ (error);
      end;
      on store begin;
         call ioa_ ("^a encountered a store fault ^[a dump will be taken ^]", exec, ^flt_flag);
         if ^flt_flag then call fault_dump;
         else call continue_to_signal_ (error);
      end;
      on tolts_error_ begin;
         call probe (mtdsim_);
         call clean_up;
      end;

      on quit begin;				/* establish quit handler */
         if ^q_flag then				/* if normal operation */
	  call tolts_alrm_util_$quit;
         else call continue_to_signal_ (error);
      end;
      on program_interrupt begin;			/* establish pi handler for debugging */
         call hcs_$wakeup (tolts_info.process, tolts_info.quith_event, null, error);
      end;
      call tolts_qttyio_ ("??? ", 9);			/* exec read for original data */
%page;
/* this is the main program dispatcher */

      term = "0"b;					/* reset terminate condition */
      do while (^term);				/* loop until we are done */
block_disp:					/* target of nonlocal gotos */
         call ipc_$block (addr (tolts_info.wait_list), addr (event_out), error);
         if error ^= 0 then do;			/* this is a fatal error, terminate our process */
	  call com_err_ (error, exec, "*** fatal error, terminating process"); /* tell users first */
	  fatal_desc.version = 0;
	  fatal_desc.fatal_code = error;
	  if ^debugging then
	     call terminate_process_ ("fatal_error", addr (fatal_desc));
	  else signal tolts_error_;
         end;					/* no need to return, as we won't be back */
         if tolts_info.wait_list.nchan > 1 then do;	/* if we are waiting for > 1 event */
	  if event_out.channel_id ^= wait_list.wait_event_id (2)
	   | event_out.channel_id ^= tolts_info.dm_event
	  then do;				/* if the wake up is not for the second channel */
	     ev_occurred = 0;			/* initialize in case code ^= 0 */
	     call ipc_$read_ev_chn (wait_list.wait_event_id (2),
	      ev_occurred, addr (event_out), code);	/* check and see if the second channel is ready */
	     if code ^= 0 then do;
	        call com_err_ (code, exec, "Error calling ipc_$read_ev_chn");
	        if debugging then signal tolts_error_;
	     end;
	     if ev_occurred ^= 1 then do;
	        if nr_cnt < 20 then do;
		 if debugging then call ioa_ ("nr_cnt = ^d", nr_cnt);
		 wake_time = 500000;
		 call timer_manager_$sleep (wake_time, "10"b);
		 nr_cnt = nr_cnt + 1;
		 call wake_disp;			/* if the second channel hasn't awaken then wait */
	        end;
	        else do;
		 if substr (clt_sw, 3, 4) = "c000" then do; /* if exec chan - wrapup */
		    call tolts_qttyio_$rs (0, "^as: timeout error attempting attach of ^a",
		     tolts_info.exec, clt_sw);	/* notify the user */
		    call tolts_abort ("$c1");		/* then abort colts */
		 end;
		 else do;
		    call rel_tst_chan (l);
		    colts_pages (l).in_use = "0"b;	/* reset test page active */
		    call tolts_qttyio_$rs (0, "^as:  timeout error attempting a tandd_attach of ^a",
		     tolts_info.exec, substr (colts_pages (l).cdt_name, 1, 6));
		    colts_op_flags.colt_flag = "0"b;	/* make use flag is reset so we don't go blocked */
		    colts_op_flags.sicm = "0"b;
		    colts_op_flags.dm_attach = "0"b;
		    if mme_call_hf (2).lower ^= 0 then do; /* cc requested */
		       exec_wd (mme_call_hf (2).upper) = "000000000004"b3; /* store error status */
		       call tolts_alm_util_$enter_ccc_req_ (addr (tolts_info.ccc_queue),
		        (mme_call_hw (2).lower || "000000"b3)); /* enter cc request */
		    end;
		    colts_pages (l).status_word = "000000000002"b3; /* test channel - store status */
		 end;
	        end;
	     end;
	  end;
	  tolts_info.wait_list.nchan = tolts_info.wait_list.nchan - 1; /* else decrement the wait list */
	  chan_name, io_module = "";
	  n_dialed = 0;
	  flags = ""b;
	  call convert_dial_message_$return_io_module (event_out.message,
	   chan_name, io_module, n_dialed, flags, code);	/* convert the message into flags */
	  if code ^= 0 then do;
	     call ioa_$rsnnl ("error attaching channel ^a", emsg, mesg_len, chan_name);
	     call output_status_code (code, emsg);
	  end;
	  if trace_io then
	     call ioa_ ("Channel ^a, IO Module ^a, N_dialed ^d, flags^[ dialed_up^]^[ hung_up^]^[ control^]",
	      chan_name, io_module, n_dialed, flags.dialed_up, flags.hung_up, flags.control);

	  if flags.control				/* if control flag then error */
	   | (^flags.control			/* or an informative message */
	   & ^flags.dialed_up & ^flags.control) then do;	/* with no information */

	     if substr (clt_sw, 3, 4) = "c000" then do;	/* if exec chan - wrapup */
	        call tolts_qttyio_$rs (0, "^as: control error attempting dial_manager_attach of ^a",
	         tolts_info.exec, substr (clt_sw, 1, 6)); /* notify user */
	        call tolts_abort ("$c0");		/* then abort colts */
	     end;
	     else do;
	        call rel_tst_chan (l);
	        colts_pages (l).in_use = "0"b;		/* reset test page active */
	        call tolts_qttyio_$rs (0, "^as:  control error attempting a tandd_attach of ^a",
	         tolts_info.exec, substr (colts_pages (l).cdt_name, 1, 6));
	        colts_op_flags.colt_flag = "0"b;	/* make use flag is reset so we don't go blocked */
	        colts_op_flags.sicm = "0"b;
	        colts_op_flags.dm_attach = "0"b;
	        if mme_call_hf (2).lower ^= 0 then do;	/* cc requested */
		 exec_wd (mme_call_hf (2).upper) = "000000000002"b3; /* store error status */
		 call tolts_alm_util_$enter_ccc_req_ (addr (tolts_info.ccc_queue),
		  (mme_call_hw (2).lower || "000000"b3)); /* enter cc request */
	        end;
	        colts_pages (l).status_word = "000000000002"b3; /* else test channel - store status */
	     end;
	  end;

	  if flags.dialed_up & colts_op_flags.dm_attach then do; /* if the channel is dialed attaching */
	     call iox_$attach_name ((clt_sw), cltp, att_desc, null, code); /* create an io switch */
	     if code ^= 0 then goto sw_err;		/* if error */
	     call iox_$open (cltp, 3, "0"b, code);	/* open a switch */
	     if code ^= 0 then goto sw_err;		/* if error */
	     call iox_$modes (cltp, "rawi,rawo", "", code); /* now set the modes for the channel */
	     if code ^= 0 then do;			/* if error */
sw_err:	        if substr (clt_sw, 3, 4) = "c000" then do;/* if exec channel - wrapup */
		 call convert_status_code_ (code, shortinfo, lginfo); /* convert the status code */
		 call tolts_qttyio_$rs (0, "^as: ^a/ attempting a switch operation for ^a",
		  tolts_info.exec, lginfo, clt_sw);	/* and notify the user */
		 call tolts_abort ("$c1");		/* then abort colts */
	        end;
	        else do;
		 colts_pages (l).status_word = "000000000002"b3; /* else test channel - store status */
		 colts_pages (l).in_use = "0"b;
	        end;
	     end;
	     if code = 0 then do;
	        if substr (clt_sw, 3, 4) = "c000" then do;/* if exec channel */
		 tolts_info.fnp (k).exec_active = "1"b; /* set exec active */
		 fnp (k).fnp_execp = cltp;		/* save iocb ptr */
		 exec_wd (remote_inquiry_ic) = "0000000500"b3 || "1"b
		  || substr (bit (k), 2, 5);		/* answer remote inquiry request */
	        end;
	        else do;				/* else a test channel */
		 colts_pages (l).chanp = cltp;	/* save iocb ptr */
		 colts_pages (l).status_word = "000000000004"b3; /* store good status */
		 exec_wd (remote_inquiry_ic) = "0000000500"b3 || "0"b
		  || substr (bit (l), 2, 5);		/* answer remote inquiry request */
	        end;
	        colts_op_flags.colt_flag = "0"b;	/* reset colts flag */
	        colts_op_flags.dm_attach = "0"b;	/* reset dial_manager attach flag */
	        remote_inquiry_ic = 0;		/* reset remote inquiry ic */
	     end;
	  end;
         end;

         if colts_op_flags.sicm then do;		/* if an icm need to be sent to the fnp */
	  call iox_$put_chars (fnp (k).fnp_execp, wicmp, (bin (wicm.word_total) + 1) * 4, code); /* send it */
	  if code ^= 0 then do;			/* if error */
	     call convert_status_code_ (code, shortinfo, lginfo);
	     call tolts_qttyio_$rs (0, "^as: ^a/ error on data xfer to fnp colt exec ^a",
	      tolts_info.exec, lginfo, fnp (k).fnp_execp);
	     call tolts_abort ("$c1");		/* then abort colts */
	  end;
	  gicmp = addr (gicm);			/* else get ptr for return icm */
	  gicm_count = gicm_count + 1;		/* inc position in the queue */

	  if gicm_count = 17 then do;			/* if 17 - error */
	     call tolts_qttyio_$rs (0, "^as: execessive outstanding io's", tolts_info.exec);
	     call tolts_abort ("$c2");		/* abort colts */
	  end;
	  gicm.cltp = fnp (k).fnp_execp;		/* save iocb ptr */
	  gicm.ricmp = ricmp;			/* rtrn icm ptr */
	  gicm.tally = bin (wicm.word_total) + 1;	/* tally */
	  if mme_call_hf (2).lower ^= 0 then do;	/* cc requested */
	     gicm.cc_addr = mme_call_hw (2).lower || "000000"b3; /* save cc address */
	     gicm.st_addr = mme_call_hf (2).upper;	/* save status address */
	  end;
	  colts_op_flags.sicm = "0"b;			/* reset send icm flag */
         end;

         if tolts_info.special_fault then do;		/* special int. fault from tolts_io_int_ */
	  tolts_info.special_fault = "0"b;
	  call tolts_abort ("$b6");
         end;
         else if tolts_info.exec_term_io_wait then term = "1"b; /* we are all done */
         else if tolts_info.first_request_done then do;	/* if we have something to do... */
no_blk_disp:					/* target of non-local gotos */
	  if gicm_count ^= 0 then do;			/* if outstanding icm */
	     alloc info_struct;			/* alloc an info struct */
	     info_ptr = addr (info_struct);		/* get its ptr */

	     if gicm.cltp ^= null then do;		/* if slot is in use */
	        call iox_$control (gicm.cltp, "read_status", info_ptr, code); /* read the status */
	        if info_struct.out_pend then do;	/* output ready */
		 call iox_$get_chars (gicm.cltp, gicm.ricmp, gicm.tally * 4, n_read, code); /* get the icm */
		 if code ^= 0 then do;		/* if error */
		    call convert_status_code_ (code, shortinfo, lginfo);
		    call tolts_qttyio_$rs (0, "^as: ^a/ error on data xfer from fnp", tolts_info.exec, lginfo);
		    call tolts_abort ("$c1");		/* then abort colts */
		 end;
		 if gicm.cc_addr ^= "0"b3 then do;	/*  if a courtesy call requested */
		    if fnp (k).fnp_execp = gicm.cltp then
		       exec_wd (gicm.st_addr) = fnp (k).status_word;
		    else exec_wd (gicm.st_addr) = colts_pages (l).status_word;
		    call tolts_alm_util_$enter_ccc_req_ (addr (tolts_info.ccc_queue),
		     (gicm.cc_addr));		/* enter ccc request */
		 end;
		 gicm_count = gicm_count - 1;		/* dec the count */
		 gicm.cltp = null;			/* open up the slot */
		 gicm.ricmp = null;
		 if gicm_count = 0
		 then do;				/* delete unused gicms */
		    free gicm;
		    gicmp = null;
		 end;
	        end;
	     end;

	     free info_struct;			/* free the info structure */
	  end;

	  if isc_ccc_rqt then do;			/* if outstanding inter slave read ... */
	     if tolts_info.exec_dta_cnt = 0 then isc_cntdn = isc_cntdn - 1; /* but no data to xfer yet ... */
	     if isc_cntdn = 0 | tolts_info.exec_dta_cnt ^= 0 then do; /* if timeout or isc data avail */
	        isc_ccc_rqt = "0"b;			/* reset isc courtesy call flag and enter courtesy call */
	        call tolts_alm_util_$enter_ccc_req_ (addr (tolts_info.ccc_queue), (isc_queue.icivlu));
	        exec_wd (isc_queue.status_add + 1) = "0"b;/* dcw residue = zero */
	        if tolts_info.exec_dta_cnt = 0 then	/* if no data to xfer... */
		 exec_wd (isc_queue.status_add) = "400006000000"b3; /* set status to timeout */
	        else call pop_isc (isc_queue.status_add, isc_queue.data_add); /* data to xfer */
	     end;
	  end;
	  if ^in_ccc & ^gndc_flag then		/* if not in ccc */
	     if tolts_info.ccc_requests ^= 0 & ^gelbar then do; /* pay courtesy call first */
	        unspec (spa.ccc_regs) = addr (spa.regs) -> reg_move; /* move current regs into safe store */
	        spa.ccc_icivlu = string (spa.enter.icivlu);
	        string (spa.enter.icivlu) = tolts_info.ccc_queue (1).icivlu;
	        tolts_info.ccc_requests = tolts_info.ccc_requests - 1; /* decrement count */
	        do i = 1 to tolts_info.ccc_requests;
		 tolts_info.ccc_queue.icivlu (i) = tolts_info.ccc_queue.icivlu (i + 1); /* move queue down */
	        end;
	        in_ccc = "1"b;
	     end;
	     else if rd_blk then do;			/* road blocked? */
	        if isc_ccc_rqt then call wake_disp;	/* wakeup dispatcher */
	        rd_blk = "0"b;
	     end;
	  if trace | (trace_save & in_ccc) then		/* if tracing mmes and dispatches */
	     call tolts_qttyio_$rs (10,
	      "^a ^a ^12.3b^[, ^a^;^s^]^[, ^a ^6.3b^;^2s^]^[, ^a ^a ^12.3b, ^a ^12.3b^]",
	      ctime (), "Dispatch to ici -", string (spa.enter.icivlu), in_ccc,
	      "in courtesy call", gelbar, "in gelbar, BAR -", spa.enter.lbar.bar, glb_brk,
	      "gelbar break,", "gb ici -", string (spa.glbici), "gbfv -", spa.glbflt);
	  glb_brk = "0"b;				/* reset gelbar break indicator if set */
	  gndc_flag = "0"b;
	  if ^flt_flag then
	     call tolts_alm_util_$enter_slave_ (addr (spa.enter)); /* enter slave program */
         end;
done:						/* target of nonlocal goto */
      end;
      if ^tolts_active then return;
      tolts_info.exec_term_io_wait = "1"b;		/* make sure we quit */
      call clean_up;				/* go cleanup our enviornment */
      return;					/* and return  to tolts command level */
%page;

/* mme_fault - static condition handler for GCOS type mme faults */

mme_fault: entry (mcptr, cname, tptr1, tptr2, tcont);

dcl  (mcptr, tptr1, tptr2) ptr;
dcl  cname char (*);
dcl  tcont bit (1);
dcl  tags (1:8) char (1) static options (constant) init
      ("a", "b", "c", "d", "e", "f", "g", "h");
dcl  fnp_state (0:4) char (7) static options (constant) init
      ("free   ", "unknown", "down   ", "booting", "up     ");


      mcp = mcptr;					/* get ptr to machine conditions */
      scup = addr (mc.scu);				/* get ptr to scu data */
      unspec (spa.regs) = addr (mc.regs) -> reg_move;	/* save the processor regs */
      spa.enter.icivlu.ind = string (scu.ir);

      if gelbar then				/* if in gelbar mode, pass fault on to gcos module */
         call set_gelbar;				/* we want return from this call */
      mmep = addrel (execp, scu.ilc);			/* set mme call ptr */

      if substr (mme_call_w (0), 19, 10) ^= "0000000010"b then /* if not mme1 instruction... */
         go to undefm;

      if in_ccc then
         if mme_call_hw (0).upper ^= "000016"b3 then do;
	  call tolts_qttyio_$rs (0, "^as: Illegal mme in ccc  (^12.3b) @ ^p",
	   exec, mme_call_w (0), mmep);
	  call tolts_abort ("$a4");
         end;
      mme_number = mme_call_hf (0).upper;
      if (mme_number < -127 | mme_number > 31)		/* if out of legal range */
       | (mme_number < -66 & mme_number > -87)
       | (mme_number < -94 & mme_number > -127) then
         go to undefm;
      if trace | trace_save then do;			/* if tracing mmes and dispatches */
         if trace then do;				/* if currently tracing */
	  if (mme_number = -1 & last_mme = -39)
	   | (mme_number = -39 & last_mme = -1)
	   | mme_number = last_mme then do;		/* do not display idle loop */
	     trace_save = "1"b;			/* save state and turn trace off */
	     trace = "0"b;				/* idle loop */
	  end;
         end;
         else if mme_number ^= last_mme then do;		/* if idle loop has ended */
	  trace = "1"b;				/* turn back on trace */
	  trace_save = "0"b;
         end;
      end;
      last_mme = mme_number;				/* save mme number for nxt time */
      go to mme_typ (mme_number);			/* process gcos mme */
%page;
/* ********* MME ABSTIM ********* (absolute time)

   input registers: none

   mme     abstim
   ------  return

   return registers: AR = time of day, 1/64 ms. since midnight */

mme_typ (-1): if trace then call tolts_qttyio_$rs (10, "^a MME ABSTIM @ ^p", ctime (), mmep);
      call tolts_init_$gc_tod (spa.regs.a);		/* get current time of day */
      call return_plus (1);

/* ********* MME ACCWRT ********* (accounting file write, unused in Multics)

   input registers:   x1 -> message address

   mme     accwrt
   ------  return

   return registers: none */

mme_typ (-2): if trace then call tolts_qttyio_$rs (10, "^a MME ACCWRT @ ^p", ctime (), mmep);
      call return_plus (1);

/* ********* MME ASGPAT ********* (assign peripheral allocation table, unused in Multics)

   input registers:   X1 = sct (test page index mod 4),   X4 = pat address (lal offset)

   mme     asgpat
   ------  return

   return registers: X2 = sct word 1 (returned = 0) */

mme_typ (-5): if trace then call tolts_qttyio_$rs (10, "^a MME ASGPAT @ ^p", ctime (), mmep);
      spa.regs.x (2) = "0"b;				/* set # modules to zero */
      call return_plus (1);
%page;
/* *********************************************************************************
   *   alternate mtar device is defined as  "alt sct addr = (page index) *4 + 512   *
   ********************************************************************************* */

/* ********* MME ALLOCR ********* (allocate peripheral)

   input registers:   x1 = sct (test page index mod 4)
   x3 = chan number if new format

   mme	allocr
   zero	ficcdd,delaysct			ficcdd ptr, sct value if delayed allocation
   zero	sctwrk,mtardata	                    ficcdd ptr to sct work area.
   mtardata is storage for (even) mtar r/w flag (molts only)
   zero	alcflg,0				ptr to alcflg
   zero	alcccp,dldcwp			ptr to courtesy call routine, ptr to dcw for delayed allocation message
   ----	return error 			(mme call + 5)
   ----	return ask stranger permission	(mme call + 6)
   ----	return not free			(mme call + 7)
   ----	return allocated or usage count bumped	(mme call + 8)
   ----	return shared device		(mme call + 9)
   ----	return allocation in progress, wait	(mme call + 10)

   return registers:	X2 = error code on error (see set_sctwrk subroutine for error codes)
   *			output in sctwrk (12 words): see the set_sctwrk subroutine */

mme_typ (-4): if trace then call tolts_qttyio_$rs (10, "^a MME ALLOCR @ ^p", ctime (), mmep);
      call get_px_sct ("ALLOCR", bin (spa.regs.x (1), 17), "0"b); /* get test page index */
      call set_sctwrk (io_sel);			/* go set up the sct work area */
      if spa.regs.x (2) ^= "0"b then do;		/* if some error from tolts_device_info_... */
         if fixed (spa.regs.x (2)) = m_iv_iom then	/* if invalid IOM number... */
	  spa.regs.x (2) = "0"b;			/* correct error code */
         call return_plus (5);			/* take error return */
      end;
      io_info_ptr = addr (pages (io_sel));		/* get ptr to this test page */

/* create an event call channel for tdio status events */

      if ^io_info.ev_ch_ass then do;			/* we we havn't done this already */
         call tolts_init_$cr_event_chan (io_info.status_event,
	"1"b, tolts_io_int_, io_info_ptr, 2, error);
         if error ^= 0 then				/* if error creating event call chan */
	  call tolts_abort ("$a9");
         io_info.ev_ch_ass = "1"b;			/* set event chan assigned flag */
      end;

      if mme_call_hf (1).lower = 0 then do;		/* if we havn't already attached perp... */
         alt_flag, rd_flag = "0"b;			/* make sure we start in a known state */
         if io_info.devsct.type_code = "22"b3		/* if ccu as a reader */
	& ^io_info.ccu_pun then rd_flag = "1"b;		/* set read flag */
         if ^io_info.alloc_wait & ^io_info.p_att then do;

	  if io_info.io_type = mca_io_type
	   & io_info.mca_attach_state = MCA_NOT_CONFIGURED then do;
	     call mca_$attach_mca ((io_info.device_name), io_info.status_event,
	      io_info.mca_ioi_idx, error);
	     io_info.mca_attach_state = MCA_FREE;
	  end;
	  else do;

attach:	     if ^alt_flag then do;			/* if we want the primary or only channel */
	        call ioa_$rsnnl ("T&D is attaching for a ^[write^]^[read^] ^a",
	         att_desc, mesg_len, (^rd_flag), (rd_flag), io_info.device_name);
	        call rcp_priv_$attach (io_info.rcp_name, addr (io_info.rcp_area (1)), io_info.status_event,
	         att_desc, io_info.rcp_id, error);
	     end;
	     else do;
	        call ioa_$rsnnl ("T&D is attaching for a ^[write^]^[read^] ^a",
	         att_desc, mesg_len, (^rd_flag), (rd_flag), io_info.alt_device_name);
	        call rcp_priv_$attach (io_info.rcp_name, addr (io_info.alt_rcp_area (1)), io_info.status_event,
	         att_desc, io_info.alt_rcp_id, error);
	     end;

	     if error ^= 0 then do;
	        call output_status_code (error, "rcp attach error");
	        call dealcp_sub;			/* go release status event */
	        spa.regs.x (2) = bit (os_deny);		/* set appropriate error code */
	        call return_plus (5);			/* take error return */
	     end;
	     if ^alt_flag then
	        call rcp_$check_attach (io_info.rcp_id, addr (io_info.rcp_area (1)), coment, io_info.device_index,
	         tolts_info.max_wks_sz, tolts_info.max_to, io_info.rcp_state, io_info.attach_err);
	     else call rcp_$check_attach (io_info.alt_rcp_id, addr (io_info.alt_rcp_area (1)), coment,
		 io_info.alt_device_index, tolts_info.max_wks_sz,
		 tolts_info.max_to, io_info.rcp_state, io_info.attach_err);

	  end;
         end;
      end;

/* only one call to rcp_$check_attach here. If delayed allocation (tape or disk),  RCP  will  signal
   (via  the  status call channel) tolts_io_int_, when an event has ocurred. tolts_io_int_ will check the
   rcp state flag and either return and let RCP work if attachment is incomplete or enter the  courtesy
   call request and signal the dispatcher if the attachment is complete or if an error has occurred */

/* *********************************************
   *   check for mtar write permission denial	*
   ********************************************* */

      if io_info.io_type = mtar_io_type
       & (^io_info.p_att | io_info.alt_dev_flag) then do;
         if io_info.attach_err = error_table_$force_unassign then do;
	  if ^alt_flag then disk_info_ptr = addr (io_info.rcp_area (1));
	  else disk_info_ptr = addr (io_info.alt_rcp_area (1));
	  if ^rd_flag then do;			/* opr denied write request */
	     disk_info.write_flag = "0"b;		/* read only */
	     rd_flag = "1"b;
	     goto attach;
	  end;
	  else do;
	     call output_status_code (io_info.attach_err, "ioi_assign error--check attach");
	     call dealcp_sub;			/* go release status event */
	     spa.regs.x (2) = bit (os_deny);		/* set appropriate error code */
	     call return_plus (5);			/* take error return */
	  end;
         end;
      end;

      if ^io_info.p_att | ^io_info.p2_att then do;

         if io_info.attach_err ^= 0
	| error ^= 0 then do;
	  if io_info.attach_err = error_table_$resource_unavailable then do; /* must have been busy */
	     spa.regs.x (2) = bit (dev_busy);		/* set appropriate error code */
	     if ^io_info.dev_busy then do;		/* only output device busy message once */
	        call tolts_qttyio_$rs (0, "^a device busy, allocation queued", io_info.test_hdr);
	        io_info.dev_busy = "1"b;		/* set flag so we only output message once */
	     end;
	     call return_plus (7);			/* return ic + 7 */
	  end;
	  if io_info.io_type ^= mca_io_type then
	     call output_status_code (io_info.attach_err, "ioi_assign error--check attach");
	  else call output_status_code (error, " mca assign error");
	  call dealcp_sub;				/* go release status event */
	  spa.regs.x (2) = bit (os_deny);		/* set appropriate error code */
	  call return_plus (5);			/* take error return */
         end;
         if io_info.rcp_state ^= 0			/* return - allocation wait */
	| (io_info.io_type = mca_io_type
	& io_info.mca_attach_state < MCA_ATTACHED) then do;
	  io_info.alloc_wait = "1"b;			/* set wait flag for tolts_io_int_ */
	  io_info.icivlu.ic = mme_call_hw (4).upper;	/* save ccc ptr for tolts_io_int_ */
	  io_info.icivlu.ind = "0"b;
	  call tolts_qttyio_$dcw_list (addrel (execp, mme_call_hf (4).lower), 0);
	  tolts_info.glob_int_cnt = tolts_info.glob_int_cnt + 1; /* increment global IO count */
	  call return_plus (10);			/* return ic + 10, allocation wait */
         end;

         if io_info.io_type = mdr_io_type & ^io_info.p2_att then /* if running mdrs */
	  if substr (io_info.device_name, 1, 3) = "tap"	/* if tape */
	   | substr (io_info.device_name, 1, 3) = "dsk" then do; /* or disk */
	     io_info.p2_att = "1"b;			/* set perph attach flag */
	     io_info.alt_rcp_id = io_info.rcp_id;	/* mv rcp id to alt rcp id */
	     go to mme_typ (-4);			/* we have the mpc now go get the dev */
	  end;
         if ^alt_flag then io_info.p_att = "1"b;		/* set perp attach flag */
         else io_info.p2_att = "1"b;
         io_info.dev_busy = "0"b;			/* reset device busy flag */
      end;


/* ***************************************************
   *   attach alternate device for mtar if required   *
   *************************************************** */


      if io_info.io_type = mtar_io_type & io_info.alt_dev_flag
       & io_info.p_att & ^io_info.p2_att then do;

         if rd_flag then do;				/* sct requested permission equal to that of primary */
	  disk_info_ptr = addr (io_info.alt_rcp_area (1));
	  disk_info.write_flag = "0"b;
	  rd_flag, alt_flag = "1"b;
	  goto attach;
         end;
         else do;
	  disk_info_ptr = addr (io_info.alt_rcp_area (1));
	  disk_info.write_flag = "1"b;
	  rd_flag = "0"b;
	  alt_flag = "1"b;
	  goto attach;
         end;
      end;




/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
/*   set permission code for mtar								*/
/*   The address for permission storage is in the lower half of (mme call + 2).				*/
/*   appropriate permission is stored in the lower half of the target word,      			*/
/*    0 = write permission, 8 = read permission                                                               */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/



      if ^rd_flag then
         exec_wd (mme_call_hf (2).lower) = exec_wd (mme_call_hf (2).lower) & "777777000000"b3;
      else exec_wd (mme_call_hf (2).lower) = (exec_wd (mme_call_hf (2).lower)) | ("000000000010"b3);
      if io_info.rcp_name = DEVICE_TYPE (TAPE_DRIVE_DTYPEX) then /* if tape device... */
         call decode_den;				/* go decode density info */

      if io_info.io_type = mca_io_type then
         call get_temp_segment_ ("mca_workspace", io_info.workspace_ptr, error);
      else call ioi_$workspace (io_info.device_index, io_info.workspace_ptr, tolts_info.wks_sz, error);
      if error ^= 0 then do;
         call output_status_code (error, "workspace assign error");
         call dealcp_sub;				/* go release status event */
         spa.regs.x (2) = bit (os_deny);		/* set appropriate error code */
         call return_plus (5);			/* take error return */
      end;
      io_info.cur_wks_sz = tolts_info.wks_sz;		/* set current value of workspace size */
      if io_info.io_type ^= mca_io_type then do;
         ioi_wksp = io_info.workspace_ptr;
         call ioi_$set_status (io_info.device_index, fixed (rel (addr (tolts_workspace.status)), 18), 1, error);
         if error ^= 0 then do;
	  call output_status_code (error, "set_status error");
	  call dealcp_sub;				/* go detach and release status event */
	  spa.regs.x (2) = bit (os_deny);		/* set appropriate error code */
	  call return_plus (5);			/* take error return */
         end;
         if io_info.nff then do;
	  iom = fixed (substr (io_info.devsct.icc, 1, 3), 3) + 1;
	  chan = fixed (substr (io_info.devsct.icc, 6, 6), 6);
         end;
         else do;
	  iom = fixed (substr (io_info.devsct.icc, 1, 3), 3) + 1;
	  chan = fixed (substr (io_info.devsct.icc, 4, 6), 6);
         end;
         call ioi_$set_channel_required (io_info.device_index, iom, chan, error);
         if error ^= 0 then do;
	  call output_status_code (error, "set_channel error");
	  call dealcp_sub;				/* go detach and release status event */
	  spa.regs.x (2) = bit (os_deny);		/* set appropriate error code */
	  call return_plus (5);			/* take error return */
         end;

         timeout_time = 30000000;			/* set timeout to a minimum value of 30 sec */
         if io_info.io_type = mdr_io_type
	& io_info.devsct.type_code = "001110"b then	/* if mdr and 601/610 */
	  timeout_time = 390000000;			/* set timeout to 6.5 mins */
         else if io_info.io_type = itr_io_type		/* if mdrs on an eurc */
	& io_info.devsct.cr501_pr54 then
	  timeout_time = 60000000;			/* time_out = 1min */
         else if io_info.io_type = mtar_io_type then
	  timeout_time = 90000000;			/* time_out = 1.5min */
         io_info.lostit_time =			/* set lostit time = time_out time + 1sec * 64 / 1000 */
	divide ((timeout_time + 1000000) * 64, 1000, 35);
         call ioi_$timeout (io_info.device_index, timeout_time, error);
         if error ^= 0 then do;
	  call output_status_code (error, "set timeout error");
	  call dealcp_sub;				/* go release status event */
	  spa.regs.x (2) = bit (os_deny);		/* set appropriate error code */
	  call return_plus (5);			/* take error return */
         end;
      end;
      io_info.allocated = "1"b;
      call return_plus (8);				/* return ic + 8 - good return */
%page;
/* ********* MME CATA. ********* (Get itr or mdr deckfile catalog)

   input registers:		qu = ICC
   *			x1 = ptr to call seq (defined by cata_call structure (below)
   *			x2 = max load address
   *			x3 = test page base
   mme     cata.
   ------  return if error
   ------  return if more or extenstion file follows
   ------  return if all read

   return registers:	AL    = words read in this call
   *			Q-reg = error code
   *			status word 1 bit 18 set for extension call */

dcl  1 cata_call based (genp) aligned,			/* structure for mme cata and mme data */
       (2 fdcwp bit (18),				/* first dcw ptr */
       2 statp bit (18),				/* ptr to status */
       2 patp bit (18),				/* ptr to PAT entry */
       2 nblk fixed bin) unaligned;			/* next catalog block */

mme_typ (-50): if trace | tcd then call tolts_qttyio_$rs (10, "^a MME CATA. @ ^p", ctime (), mmep);
      if substr (spa.regs.q, 7, 1) then			/* if new format */
         call get_px_tcx ("CATA. ", substr (spa.regs.q, 8, 11)); /* get test page index */
      else call get_px_tcx ("CATA. ", substr (spa.regs.q, 10, 9)); /* get test page index */
      if io_info.io_type = mca_io_type then do;
         if io_info.mcata_idx = 0 then do;
	  call tolts_util_$cata_sel (tolts_info.df_iocbp, "cata.nio.mca", addr (io_info.n_keys), error);
	  if error ^= 0 then do;			/* if we couldn't find catalog */
	     call output_status_code (error, "selecting catalog subset of cata." || io_info.cat_name);
	     call return_plus (1);			/* take error return */
	  end;
	  call tolts_util_$search (tolts_info.df_iocbp, (io_info.cata_keys (1)), io_info.catp, c_len, error);
	  if error ^= 0 then do;			/* if we couldn't find catalog */
	     call output_status_code (error, "searching for " || io_info.cata_keys (io_info.mcata_idx));
	     call return_plus (1);			/* take error return */
	  end;
	  do io_info.mcata_nkeys = 1 to cata.n;
	     io_info.mcata_keys (io_info.mcata_nkeys) = cata.key (io_info.mcata_nkeys);
	  end;
	  io_info.mcata_idx = 1;
         end;
         io_info.cat_name = substr (io_info.mcata_keys (io_info.mcata_idx), 6, 7);
      end;
      if io_info.catx = 0 then do;			/* only select catalog keys once */
         call tolts_util_$cata_sel (tolts_info.df_iocbp, "cata." || io_info.cat_name, addr (io_info.n_keys), error);
         if error ^= 0 then do;			/* if we couldn't find catalog */
	  call output_status_code (error, "selecting catalog subset of cata." || io_info.cat_name);
	  call return_plus (1);			/* take error return */
         end;
         io_info.catx = io_info.n_keys;
         if io_info.io_type ^= mca_io_type
	& io_info.n_keys > 1 then do;			/* multiple catalogs */
	  call tolts_qttyio_$rs (0, "^a Multiple catalog files (^d) for ^a ^a catalog.",
	   io_info.test_hdr, io_info.n_keys, substr (io_info.cat_name, 5), substr (io_info.cat_name, 1, 3));
	  do io_info.catx = 1 to io_info.n_keys;
	     i = search (substr (io_info.cata_keys (io_info.catx), 10), ".");

	     call tolts_qttyio_$rs (0, "^a ^a catalog, ^[firmware rev ^a^] - ",
	      substr (io_info.cata_keys (io_info.catx), 10, i - 1),
	      substr (io_info.cata_keys (io_info.catx), 6, 3),
	      (substr (io_info.cata_keys (io_info.catx), 6, 3) = "itr"),
	      substr (io_info.cata_keys (io_info.catx), 10 + i));
	  end;
	  call tolts_qttyio_$rs (0, "^a^/^a",
	   "Indicate which one is to be used by answering yes to",
	   "one of the following catalog entrys:");
	  tolts_info.mult_ans = "";			/* clear out response */
	  do io_info.catx = 1 to io_info.n_keys while (mult_ans = "" | mult_ans = "no" | mult_ans = "n");
	     i = search (substr (io_info.cata_keys (io_info.catx), 10), ".");
requery:
	     call tolts_qttyio_$rs (19, "^a ^a catalog, ^[firmware rev ^a^] - ",
	      substr (io_info.cata_keys (io_info.catx), 10, i - 1),
	      substr (io_info.cata_keys (io_info.catx), 6, 3),
	      (substr (io_info.cata_keys (io_info.catx), 6, 3) = "itr"),
	      substr (io_info.cata_keys (io_info.catx), 10 + i));
	     call message_wait;			/* wait for user response */
	     if tolts_info.mult_ans ^= ""
	      & (mult_ans ^= "yes" & mult_ans ^= "y")
	      & (mult_ans ^= "no" & mult_ans ^= "n") then do;
	        call tolts_qttyio_ ("Please answer yes, no, or eom", 0);
	        go to requery;			/* go ask again */
	     end;
	  end;
	  io_info.catx = io_info.catx - 1;		/* currect io_info.catx */
	  if io_info.catx > io_info.n_keys
	   | (mult_ans ^= "yes" & mult_ans ^= "y") then
	     call return_plus (1);			/* take error return */
         end;
      end;
      else if io_info.io_type = mca_io_type then do;
         if ^io_info.cata_cycle then io_info.cata_cycle = "1"b; /* first time thru */
         else do;					/* must be second pass */
	  if io_info.catx > 1 then			/* if diskette catalog index > 1 */
	     io_info.catx = io_info.catx - 1;		/* subtract 1 */
	  else do;				/* else move to the mca cata index */
	     io_info.mcata_idx = io_info.mcata_idx + 1;
	     io_info.catx = 0;			/* reset the diskette catalog index */
	  end;
	  io_info.cata_cycle = "0"b;
         end;
         spa.regs.a = "0"b;				/* intialize words read to 0 */
      end;
      if io_info.catx ^= 0 then do;
         call tolts_util_$search (tolts_info.df_iocbp, (io_info.cata_keys (io_info.catx)), io_info.catp, c_len, error);
         if error ^= 0 then do;			/* if we couldn't find catalog */
	  call output_status_code (error, "searching for " || io_info.cata_keys (io_info.catx));
	  call return_plus (1);			/* take error return */
         end;
         genp = addrel (execp, spa.regs.x (1));		/* get ptr to slave call */
         dcwp = addrel (execp, cata_call.fdcwp);		/*  get ptr to dcw */
         gcatp = addrel (execp, dcw.address);		/* get ptr to buffer */
         if trace | tcd then call tolts_qttyio_$rs (10, "MME CATA.; loading catalog ""cata.^a"" @ ^p",
	   io_info.cat_name, gcatp);
         do i = 1 to cata.n;				/* give page all catalog entries */
	  if io_info.io_type = mca_io_type then do;
	     unspec (mca_gcata (i)) = "0"b;		/* reset this entry */
	     mca_gcata (i).cat_index, mca_gcata (i).nblk = i; /* set cata index & block number */
	     if index (cata.key (i), "HDR") ^= 0 then do;
	        mca_gcata (i).dipper_flag = "0100"b;	/* set header flag */
	        filename_idx = index (cata.key (i),
	         after (cata.key (i), "HDR."));		/* get index of filename */
	     end;

	     else if index (cata.key (i), "DIR") ^= 0 then do;
	        mca_gcata (i).dipper_flag = "0101"b;	/* set dir flag */
	        filename_idx = index (cata.key (i), "DIR"); /* get index of filename */
	     end;

	     else if index (cata.key (i), "cata") ^= 0 then do;
	        mca_gcata (i).dipper_flag = "0100"b;	/* set cata flag */
	        filename_idx = index (cata.key (i),
	         after (cata.key (i), "nio."));		/* get index of filename */
	     end;

	     else filename_idx = index (cata.key (i),
		 after (cata.key (i), "nio."));	/* get index of filename */
	     call tolts_alm_util_$ascii_to_bcd_
	      (substr (cata.key (i), filename_idx, 12), bit_buf);
	     unspec (mca_gcata (i).filename) = bit_buf;
	  end;

	  else do;
	     unspec (gcata (i)) = "0"b;		/* clear element first */
	     j = length (rtrim (cata.key (i)));		/* get true length of key */
	     ac_name = substr (cata.key (i), j - 6, 4) || substr (cata.key (i), j - 1, 2);
	     call tolts_alm_util_$ascii_to_bcd_ (ac_name, gcata (i).edit_rev); /* set edit name an rev */
	     gcata (i).cat_index, gcata (i).nblk = i;	/* set index */
	     if j < 13 then
	        call tolts_alm_util_$ascii_to_bcd_ (substr (cata.key (i), j, 6), gcata (i).ident); /* set ident */
	     else call tolts_alm_util_$ascii_to_bcd_ (substr (cata.key (i), j - 13, 6), gcata (i).ident); /* set ident */
	     if index (cata.key (i), ".") > 4 then	/* if firmware */
	        call tolts_alm_util_$ascii_to_bcd_ (substr (cata.key (i), 1, 6), gcata (i).purpose);
	     else do;
	        call tolts_alm_util_$ascii_to_bcd_ (substr (cata.key (i), 1, 3), b18);
	        substr (gcata (i).purpose, 19, 18) = b18;
	     end;
	  end;
         end;
         spa.regs.a = bit (bin (cata.n * 4, 36));		/* set words read */
      end;
      if io_info.mcata_idx <= io_info.mcata_nkeys
       & io_info.io_type = mca_io_type then call return_plus (2); /* still more catalogs to read */
      else call return_plus (3);			/* take good return */



/* ********* MME CHANTM ********* (channel time)

   input registers:   X1 = sct (test page index mod 4),   X4 = pat address (lal offset)

   mme     chantm
   ------  return

   return registers: AR = channel time */

mme_typ (-6): if trace then call tolts_qttyio_$rs (10, "^a MME CHANTM @ ^p", ctime (), mmep);
      call get_px_sct ("CHANTM", bin (spa.regs.x (1), 17), "1"b); /* get test page index */
      spa.regs.a = bit (bin (pages (io_sel).chan_time, 36));
      call return_plus (1);

/* ********* MME CLEARQ ********* (clear ISC queue)

   input/return registers: none

   mme     clearq
   ------  return */

mme_typ (-7): if trace then call tolts_qttyio_$rs (10, "^a MME CLEARQ @ ^p", ctime (), mmep);
      isc_ccc_rqt = "0"b;
      if isc_cntdn ^= 1 then isc_cntdn = 0;
      call return_plus (1);
%page;
/* ********* MME COINIT ********* (colts slave executive initialize)

   input/output registers: none

   mme	coinit
   zero	6,0       number of designators
   zero	wwflag,1
   zero	lstloc,2	core size available as loaded
   zero	tdflt,5	wrapup address
   zero	mmexec,7  interface module ttl
   zero   systyp,10  os type
   zero	crd30,11   .crd30	  bit 17 = 1 if fnp active and 18-29 = # of active fnps
   ----	return	return is mme call + the number of designators + 2

   .crfig:

   0 = series 60 0r 6000	6 = system sckd. save opt.		24-30 = reserved for gcos
   1 = class. module present	7 = reserved for gcos		31 = not in mem avail. space tab
   2 = shared memory system	8,9,10,11 = ioms 0-3 configured	32 = RLP300 present
   3 = >256k		12,13,14,15 = CPUs 0-3 configured	33 = DN30
   4 = IOM system		16-19 = reserved for gcos		34 = DN305
   5 = series 60 system	20,21,22,23 = CPU has EIS		35 = DN	355/6600
*/


mme_typ (-62): if trace then call tolts_qttyio_$rs (10, "^a MME COINIT @ ^p", ctime (), mmep);
      exec_wd (mme_call_hf (2).upper) = "0"b;		/*	zeros says not ww system */
      spa.wrapup_add = mme_call_hw (4).upper;		/* set wrapup address */
      call tolts_alm_util_$ascii_to_bcd_ (ttl_date, bcd_callname); /* convert ttl date to bcd */
      exec_wd (mme_call_hf (5).upper) = bcd_callname;	/* and store in message */
      substr (exec_wd (mme_call_hf (5).upper - 1), 19, 18) = "622017"b3; /* change version? ?? to version?s ? */
      genp = addrel (execp, mme_call_hf (3).upper);	/* get ptr to lstloc */
      if fix_wd (1) ^= 0 then				/* if lstloc specified... */
         mem_now, fix_wd (1) = fix_wd (1) + 49152;	/* add 48k to lstloc */
      else mem_now, fix_wd (1) = fixed (gload_data.text_len) + 49152; /* otherwise use loaded length */
      call cpu_time_and_paging_ (i, cpu_time, j);		/* get current cpu time */
      tolts_info.init_time = cpu_time;			/* save  */
      exec_wd (mme_call_hf (6).upper) = "000000000002"b3;	/* set os to multics */
      exec_wd (mme_call_hf (7).upper) = "000001001000"b3;	/* set fnp present bit and number of active fnp's to max */
      fnp.status_word, colts_pages.status_word = "000000000004"b3;
      call return_plus (8);

/* ********* MME CONTML ********* (controlling terminal)

   input registers:   x1 = old controlling terminal

   mme     contml
   ------  return tolts aborted
   ------  return tolts swapped
   ------  return denied
   ------  return slaves copying
   ------  return good

   return registers:   x1 = new logical controlling terminal in lower */

mme_typ (-8): if trace then call tolts_qttyio_$rs (10, "^a MME CONTML @ ^p", ctime (), mmep);
      spa.regs.x (1) = "000004"b3;			/* coded terminal 4 */
      call return_plus (5);				/* return ic + 5 */

%page;

/* ********* MME DATA. ********* (Get itr or mdr from deckfile)

   input registers:		qu = ICC
   *			x1 = ptr to call seq (defined by cata_call structure (see MME CATA.)
   *			x2 = max load address
   *			x3 = test page base
   *			x4 = diskette sector number relative to sector 0

   mme     data.
   ------  return if error
   ------  return if more or extenstion file follows
   ------  return if all read

   return registers:	AL    = words read in this call
   *			Q-reg = error code
   *			status word 1 bit 18 set for extension call */

mme_typ (-51): if trace | tcd then do;
         call tolts_qttyio_$rs (10, "^a MME DATA. @ ^p to load ^a",
	ctime (), mmep, cata.key (cata_call.nblk));
         genp = addrel (execp, spa.regs.x (1));		/* get ptr to slave call */
      end;

      if substr (spa.regs.q, 7, 1) then			/* if new format */
         call get_px_tcx ("DATA. ", substr (spa.regs.q, 8, 11)); /* get test page index */
      else call get_px_tcx ("DATA. ", substr (spa.regs.q, 10, 9)); /* get test page index */
      genp = addrel (execp, spa.regs.x (1));		/* get ptr to slave call */
      dcwp = addrel (execp, cata_call.fdcwp);		/*  get ptr to dcw */
      l_ptr = addrel (execp, dcw.address);		/* get ptr to buffer */
      call tolts_util_$search (tolts_info.df_iocbp, (cata.key (cata_call.nblk)), t_ptr, c_len, error);
      if error ^= 0 then do;				/* if we couldn't find module */
         call output_status_code (error, "searching for " || cata.key (cata_call.nblk));
         call return_plus (1);			/* take error return */
      end;

      if io_info.io_type = mca_io_type then do;
         if spa.regs.x (4) ^= "777777"b3 then do;		/* if data is wanted */
	  io_info.catx = 0;
	  io_info.mcata_idx = 1;
	  t_ptr = addrel (t_ptr, fixed (spa.regs.x (4)) * 64); /* adjust the ptr to the correct sector */
	  if bin (dcw.tally) = 0 then tally = 4096;	/* ck for a zero tally */
	  else tally = bin (dcw.tally);
	  if c_len < (fixed (spa.regs.x (4)) * 64) + tally then /* if the data wanted is > then end */
	     c_len = c_len - fixed (spa.regs.x (4)) * 64; /* adjust the amount to be sent */
	  else c_len = tally;
	  if c_len < 0 then call return_plus (1);	/* should not happen */
	  mvp = addrel (execp, dcw.address);		/* set mvp to where data is to go */
	  data_move = t_ptr -> data_move;		/* move it */
	  spa.regs.a = bit (bin (c_len, 36));		/* set words read */
         end;
         else spa.regs.a = "0"b;
      end;
      else do;
         call gload_ (t_ptr, l_ptr, fixed (spa.regs.x (3), 18), addr (gload_data), error); /* load it */
         if error ^= 0 then do;
	  call output_status_code (error,
	   gload_data.diagnostic || " loading module " || cata.key (cata_call.nblk));
	  call return_plus (1);			/* take error return */
         end;
         spa.regs.a = bit (bin (gload_data.text_len, 36));	/* set words read */
      end;
      if trace | tcd then call tolts_qttyio_$rs (10, "MME DATA.; loaded ""^a"" @ ^p to ^p for ^d",
	cata.key (cata_call.nblk), t_ptr, l_ptr, spa.regs.a);

      call return_plus (3);				/* take good return */

%page;

/* ********* MME DEALCP ********* (deallocate peripheral)

   input registers:   x1 = sct (test page index mod 4)

   mme     dealcp
   ------  return

   return registers: none */

mme_typ (-9): if trace then call tolts_qttyio_$rs (10, "^a MME DEALCP @ ^p", ctime (), mmep);
      call get_px_sct ("DEALCP", bin (spa.regs.x (1), 17), "0"b); /* get test page index */
      call dealcp_sub;
      if dealc_err ^= 0 then
         call tolts_abort ("$b3");
      else call return_plus (1);




/* ********* MME DOFPIO ********* (mme to do reponder io)

   input registers:
   x1 = pointer to FPINFO table
   x3 = test page base
   a  = PCW like direct_channel_pcw
   q  = time out time

   I/O COMMANDS
   71 - Interrupt fnp (uses level 3, 4, 5, 6 & 77)
   72 - Bootload fnp (not used)
   73 - Interrupt host (uses level 3 & 7)
   75 - Test data xfer (fnp - host)
   76 - Test data xfer (host - fnp)


   mme	DOFPIO
   zero	good return       (mme call + 1) */


mme_typ (-89): if trace | trace_io then call tolts_qttyio_$rs
	(10, "^a MME DOFPIO ^p, type - ^12.3b", ctime (), mmep, substr (spa.regs.a, 25));

      tolts_fpinfo_ptr = addrel (execp, spa.regs.x (1));

      do io_sel = 1 to hbound (tolts_info.pages, 1)	/* get the correct io_info for this page */
       while (pages (io_sel).fnp_num ^= tolts_fpinfo.pcw_info.fnp_num);
      end;

      if io_sel > hbound (tolts_info.pages, 1) then call tolts_abort ("$c3");
      io_info_ptr = addr (pages (io_sel));
      io_info.fpinfo_ptr = tolts_fpinfo_ptr;		/* save fpinfo_ptr for this page */
      tolts_rspd_wksp = io_info.tolts_rspd_wksp;		/* get work space ptr */
      tolts_fpinfo.fnpdcw.address =			/* set dcw address */
       bin (bin (spa.regs.x (3), 18) + bin (substr (spa.regs.a, 1, 18), 18), 18);
      direct_channel_pcw_ptr =			/* set pcw */
       addr (tolts_rspd_workspace.mailbox.pcw);
      substr (unspec (direct_channel_pcw), 19) = substr (spa.regs.a, 19);
      substr (unspec (tolts_fpinfo.pcw_info), 19) =
       substr (spa.regs.a, 19);			/* save pcw for test page */
      io_info.dcw_list (1) = exec_wd (tolts_fpinfo.fnpdcw.address); /* set dcw */
      direct_channel_tcw_ptr = addr (tolts_rspd_workspace.tcw); /* get tcw */
      unspec (direct_channel_tcw) = unspec (io_info.dcw_list (1));
      if direct_channel_pcw.operation = "75"b3		/* if data xfer pcw */
       | direct_channel_pcw.operation = "76"b3 then do;	/* set up pcw */
         substr (spa.regs.a, 1, 18) = unspec (tolts_fpinfo.fnpdcw.address);
         direct_channel_pcw.tcw_address = wordno (addr (tolts_rspd_workspace.tcw));
      end;

      else direct_channel_pcw.tcw_address = 0;		/* else set to 0 */
      io_info.pcwa = spa.regs.a;
      if direct_channel_pcw.operation = "76"b3 then do;	/* if sending data - move it */
         c_len = direct_channel_tcw.host_word_count;
         mvp = addrel (execp, bin (substr (spa.regs.a, 1, 18)) + 1);
         bufp = addr (tolts_rspd_workspace.data_buf);
         workspace_move = mvp -> workspace_move;
      end;

      tolts_rspd_workspace.pcw = direct_channel_pcw;
      unspec (tolts_rspd_workspace.tcw) = unspec (direct_channel_tcw);
      tio_off = wordno (direct_channel_pcw_ptr);
      io_info.lostit_time = bin (tolts_fpinfo.timeout_time);
      call tolts_init_$gc_tod ((tolts_fpinfo.timeout_time));
      tolts_fpinfo.timeout_time = bit (bin (tolts_fpinfo.timeout_time, 36) + io_info.lostit_time, 35);
      tolts_fpinfo.io_rq_cnt = tolts_fpinfo.io_rq_cnt + 1;	/* bump io request count */

      io_info.io_in_progress = "1"b;
      io_info.num_connects = io_info.num_connects + 1;
      call ioi_$connect (io_info.device_index, tio_off, error);
      if error ^= 0 then do;
         call output_status_code (error, "io connect error");
         call tolts_abort ("$c7");
      end;

      wake_time = 500000;
      call timer_manager_$sleep (wake_time, "10"b);
      tolts_info.glob_int_cnt = tolts_info.glob_int_cnt + 1;
      call return_plus (1);

/* ********* MME EXPDEV ********* (return device sct)

   input registers:   x1 = sct (test page index mod 4)

   mme     expdev
   ------  return

   return registers: A and Q regs contain 1st and 2nd words of device sct entry */

mme_typ (-12): if trace then call tolts_qttyio_$rs (10, "^a MME EXPDEV @ ^p", ctime (), mmep);
      call get_px_sct ("EXPDEV", bin (spa.regs.x (1), 17), "1"b); /* get test page index */
      spa.regs.a = unspec (io_info.devsct.w1);		/* set sct in a  */
      spa.regs.q = unspec (io_info.devsct.w2);		/* and q registers */
      call return_plus (1);

/* ********* MME FEPTYP ********* (return fnp type)

   input registers:   x2 =  logical fep number * 4

   mme     feptyp
   oct	 0         data returned here
   ------  return	     */



mme_typ (-59): if trace then call tolts_qttyio_$rs (10, "^a MME FEPTYP @ ^p", ctime (), mmep);


      cdtp = cdtptr;
      j = bin (spa.regs.x (2));			/* get true fnp number */
      tolts_info.fnp (j).type = (fnp_entry (j + 1).type);	/* find type */
      if tolts_info.fnp (j).type = 1 then spa.regs.x (2) = "000002"b3; /* if type 1 (dn355) set code */
      else if tolts_info.fnp (j).type = 3
       then spa.regs.x (2) = "000001"b3;		/* if type 3 (DN6670) set code */
      else if tolts_info.fnp (j).type = 0
       then spa.regs.x (2) = "777777"b3;		/* if type = 0 then illegal type set error return */
      if fnp_entry (j + 1).mpxe.current_service_type ^= 1
       & fnp_entry (j + 1).state ^= 4 then do;		/* if fnp is not up */
         spa.regs.x (2) = "777777"b3;			/* return a bad code */
         call tolts_qttyio_$rs (0, "^as: fnp ^a is ^a", exec, tags (j + 1),
	fnp_state (fnp_entry (j + 1).mpxe.state));	/* notify the user */
      end;
      call return_plus (1);


/* ********* MME FPWRAP ********* (Responder wrapup)

   input registers:   X1 = fpinfo pointer

   mme     fpwrap
   ------  return    */


mme_typ (-93): if trace then call tolts_qttyio_$rs (10, "^a MME FPWRAP @ ^p", ctime (), mmep);

      tolts_fpinfo_ptr = addrel (execp, spa.regs.x (1));	/* get pointer to test page fpinfo table */

      do io_sel = 1 to hbound (pages, 1)		/* get the correct io_info for this page */

       while (pages (io_sel).fnp_num ^= tolts_fpinfo.pcw_info.fnp_num);
      end;

      if io_sel > hbound (pages, 1) then call tolts_abort ("$c3"); /* page not found - */
      io_info_ptr = addr (pages (io_sel));
      tolts_rspd_wksp = io_info.tolts_rspd_wksp;		/* get the io workspace for this page */
      tolts_fpinfo.partrs = 0;			/* reset tolts assigned flag */
      if ^io_info.io_in_progress then tolts_fpinfo.io_rq_cnt = 0; /* reset io rquest count */
      unspec (tolts_rspd_workspace.mailbox.num_int) = "0"b; /* reset int count */
      tolts_rspd_workspace.mailbox.status_word = "0"b;
      call dealcp_sub;				/* release the fep */
      call return_plus (1);



/* ********* MME FREEZE ********* (wire main memory (gcos only))

   input registers:   none

   mme     freeze
   ------  return

   return registers: X5 = LAL (returned = 0) */


mme_typ (-53): if trace then call tolts_qttyio_$rs (10, "^a MME FREEZE @ ^p", ctime (), mmep);
      spa.regs.x (5) = "0"b;				/* set x 5 to 0 */
      call return_plus (1);
%page;


/* ********* MME GECALL ********* (load object deck)

   input registers: none
   output register: q       error code entry options(variable)
   mme     gecall
   bci     1,name
   zero    add,error return
   zero    transfer add,0 */



mme_typ (18): call bcd_to_ascii_ (mme_call_w (1), ac_name); /* convert callname to ascii */
      if trace then call tolts_qttyio_$rs (10, "^a MME GECALL (^a) @ ^p", ctime (), ac_name, mmep);
      coment = "";
      l_ptr = addrel (execp, mme_call_hf (2).upper);
      call tolts_util_$search (tolts_info.df_iocbp,
       substr (tolts_info.exec, 1, 1) || "lt." || ac_name, t_ptr, c_len, error);
      if error ^= 0 then				/* if could'nt find polt or molt page, try util */
         call tolts_util_$search (tolts_info.df_iocbp, "utl." || ac_name, t_ptr, c_len, error);
      if error ^= 0 then				/* if found test page */
         call ioa_$rsnnl ("searching for test page ^a", coment, mesg_len, ac_name);
      if error = 0 then
         call gload_ (t_ptr, l_ptr, fixed (spa.regs.x (3), 18), addr (gload_data), error); /* load it */
      if error ^= 0 then do;
         if coment = "" then
	  call ioa_$rsnnl ("^a loading test page ^a", coment, mesg_len, gload_data.diagnostic, ac_name);
         call output_status_code (error, coment);
         if mme_call_hw (2).lower = "0"b		/* error return = 0 */
	then spa.enter.icivlu = spa.wrapup_add;		/* set return to molts wrapup */
         else do;
	  spa.enter.icivlu.ic = mme_call_hw (2).lower;	/* error return */
	  mme_call_hw (2).lower = "0"b;		/* zero error return to prevent loop */
	  spa.regs.q = "63"b3;			/* set q = file not found eror code */
         end;
      end;
      else spa.enter.icivlu.ic = mme_call_hw (3).upper;	/* normal return */
      call wake_disp;				/* go wake up dispatcher */

/* ********* MME GEENDC ********* (end courtesy call)

   input/return registers: none

   mme     geendc
   no return from mme,   enters code whereever ccc interrupted */

mme_typ (14): if trace | trace_io then call tolts_qttyio_$rs (10, "^a MME GEENDC @ ^p", ctime (), mmep);
      if ^in_ccc then do;				/* if not in courtesy call complain */
         call tolts_qttyio_$rs (0, "^as: MME GEENDC while not in courtesy call", exec);
         call tolts_abort ("$a6");
      end;
      gndc_flag = "1"b;				/* set geendc complete flag */
      in_ccc = "0"b;				/* reset courtesy call flag */
      unspec (spa.regs) = addr (spa.ccc_regs) -> reg_move;
      string (spa.enter.icivlu) = spa.ccc_icivlu;
      call wake_disp;				/* go wake up dispatcher */
%page;
/* ********* MME GEINOS ********* (console write or interslave read)

   input/return registers: none

   isc read:	mme     geinos		console write:	mme     geinos
   *		oct     010000000000			oct     130000000000
   *		zero    quefcd,quedcw			zero    flcode,ondcw
   *		zero    quests,quecc			zero    ofstat,offccc
   *		------  return				------  return   */
mme_typ (1): if trace then call tolts_qttyio_$rs (10, "^a MME GEINOS @ ^p, type - ^12.3b", ctime (), mmep, mme_call_w (1));
      if mme_call_w (1) ^= "130000000000"b3 & mme_call_w (1) ^= "010000000000"b3 then do; /* illegal type */
         call tolts_qttyio_$rs (0, "^as: MME GEINOS type ^12.3b not supported", exec, mme_call_w (1));
         call tolts_abort ("$a7");
      end;
      dcwp = addrel (execp, mme_call_hf (2).lower);	/* get ptr to dcw */
      exec_wd (mme_call_hf (3).upper), exec_wd (mme_call_hf (3).upper + 1) = "0"b; /* set status & dcw res to 0 */
      if mme_call_hw (1).upper = "010000"b3 then do;	/* isc read */
         if dcw.type ^= "0"b then do;			/* dcw not iotd */
	  call tolts_qttyio_$rs (0, "^as: MME GEINOS; Read isc dcw type not iotd. DCW = 12.3b",
	   exec, string (dcw));
	  call tolts_abort ("$a7");
         end;
         if dcw.tally ^= "0003"b3 then do;		/* isc read word cnt must be 3 */
	  call tolts_qttyio_$rs (0, "^as: MME GEINOS; Read isc word count ^= 3. DCW = 12.3b",
	   exec, string (dcw));
	  call tolts_abort ("$a7");
         end;
         if tolts_info.exec_dta_cnt ^= 0 then do;		/* if data to xfer... */
	  j = mme_call_hf (3).upper;			/* copy status address */
	  call pop_isc (j, bin (dcw.address, 17));	/* do it */
	  if mme_call_hf (3).lower ^= 0 then		/* if courtesy call requested */
	     call tolts_alm_util_$enter_ccc_req_ (addr (tolts_info.ccc_queue),
	      mme_call_hw (3).lower || "000000"b3);
         end;
         else do;					/* no data to xfer */
	  isc_cntdn = 10000;
	  if mme_call_hf (3).lower ^= 0 then do;	/* if courtesy call requested */
	     isc_ccc_rqt = "1"b;
	     isc_queue.icivlu = mme_call_hw (3).lower || "000000"b3;
	     isc_queue.status_add = mme_call_hf (3).upper;
	     isc_queue.data_add = fixed (dcw.address);
	  end;
         end;
      end;
      else do;					/* console write */
         if mme_call_hf (3).lower ^= 0 then		/* if courtesy call requested */
	  call tolts_alm_util_$enter_ccc_req_ (addr (tolts_info.ccc_queue),
	   mme_call_hw (3).lower || "000000"b3);
         call tolts_qttyio_$dcw_list (dcwp, 0);		/* output the dcwp */
      end;
      call return_plus (4);				/* return ic + 4 */
%page;
/* ********* MME GELBAR ********* (load base address register)

   input registers:	AR = upper/ptr to LOC1 structure (defined by gelbar_temp below)
   *		QR = CPU time increment beffor interrupt

   mme   gelbar
   no return, return to ic value located in gelbar_temp.ic

   return registers: none */

dcl  1 gelbar_temp based (genp) aligned,		/* template for gelbar loc1 and loc1+1 */
       (2 bar bit (18),				/* desired bar value */
       2 reg_ptr bit (18),				/* ptr to register storage */
       2 ic bit (18),				/* instruction counter */
       2 ind bit (18)) unaligned;			/* indicator register */

mme_typ (31): if trace then call tolts_qttyio_$rs (10, "^a MME GELBAR @ ^p", ctime (), mmep);
      spa.glbtmr = spa.regs.q;			/* store entry timer setting */
      genp = addrel (execp, substr (spa.regs.a, 1, 18));	/* get ptr to LOC1 */
      spa.enter.icivlu.ic = gelbar_temp.ic;		/* set desired ic value */
      spa.enter.icivlu.ind = gelbar_temp.ind;		/* and indicators */
      spa.enter.lbar.bar = gelbar_temp.bar;		/* store new bar value to return */
      spa.acc_fault = gelbar_temp.bar || "000000"b3;	/* also save bar in accum fault status word */
      call tolts_init_$gc_tod (gcos_tod);		/* get current time of day */
      string (spa.glbici) = gcos_tod;			/* save current time of day in word 22 */
      genp = addrel (execp, gelbar_temp.reg_ptr);
      unspec (spa.regs) = genp -> reg_move;		/* move regs to be returned */
      gelbar = "1"b;				/* and set gelbar mode indicator */
      call wake_disp;				/* go wake up dispatcher */

/* ********* MME GEMORE ********* (get more memory)

   input/return registers: none

   mme     gemore
   zero    0,no. 1024 word blocks
   ------  return denial
   ------  return succesful */

mme_typ (9): if trace then call tolts_qttyio_$rs (10, "^a MME GEMORE @ ^p", ctime (), mmep);
      call return_plus (3);				/* return ic + 3 */

/* ********* MME GEMREL ********* (release memory)

   input registers:	AR = return address in upper, lower not used
   *		QR = words lower mem to release in upper, words upper mem to release in lower

   mme     gemrel
   ------  return

   return registers: none */

mme_typ (21): if trace then call tolts_qttyio_$rs (10, "^a MME GEMREL @ ^p", ctime (), mmep);
      spa.enter.icivlu.ic = substr (spa.regs.a, 1, 18);	/* return to address in a upper */
      call wake_disp;				/* go wake up dispatcher */
%page;
/* ********* MME GEPROC ********* (dedicate CPU, unused in Multics. Return error)

   input/return registers: none

   mme     geproc
   zero    gprprc,0
   zero    work,0
   ------  return error
   ------  return good */

mme_typ (-13): if trace then call tolts_qttyio_$rs (10, "^a MME GEPROC @ ^p", ctime (), mmep);
      call return_plus (3);				/* return ic + 3, error return for Multics */

/* ********* MME GERELC ********* (wait for I/O interrupt to occur)

   input/return registers: none

   mme     gerelc
   ------  return */

mme_typ (15): if trace then call tolts_qttyio_$rs (10, "^a MME GERELC @ ^p", ctime (), mmep);
      call return_plus (1);

/* ********* MME GEROAD ********* (road block, wait)

   input/return registers: none

   mme     geroad
   ------  return */
mme_typ (2): if trace then call tolts_qttyio_$rs (10, "^a MME GEROAD @ ^p", ctime (), mmep);
      rd_blk = "1"b;
      call return_plus (1);


/* ********* MME GEROUT ********* (colts communications)

   l   mme    gerout
   l+1	 vfd     18/record pointer,06/op,12/terminal id
   l+2	         status word pointer,courtesy call pointer
   l+3	         return


   There are six gerout types handled by tolts.
   04  write/read
   05  remote inquiry
   06  terminal type request
   07  fnp colts wake-up
   17  disconnect
   20  line status request	   */


mme_typ (24): if trace then call tolts_qttyio_$rs (10, "^a MME GEROUT ^p, type - ^12.3b", ctime (), mmep, mme_call_w (1));

      gerout_num = bin (substr (mme_call_hw (1).lower, 1, 6)); /* get the gerout number index 	*/
      if gicm_count > 0 then call return_plus (0);
      else go to gerout (gerout_num);			/* goto the gerout handler for this gerout	*/
%page;


gerout (4): wicmp = addrel (execp, mme_call_hf (1).upper);	/* get write icm pointer */
      ricmp = addrel (execp, bin (wicm.rbuf_addr) - 1);	/* get read icm pointer */
      if gicmp = null then alloc gicm;			/* alloc an icm area */
      gicmp = addr (gicm);				/* get a ptr to it */
      icm_tally = bin (wicm.word_total) * 2;		/* get icm tally */
      k = bin (substr (mme_call_hw (1).lower, 15, 4));	/* get index */
      if substr (mme_call_hw (1).lower, 13, 1) = "1"b then do; /* an exec request */
         if substr (wicm.host_opcode, 10, 9) = "042"b3 then do; /* if load memory request */
	  alloc ticm;				/* allocate a temp icm */
	  ticmp = addr (ticm);			/* get a ptr */
	  ticm = wicm;				/* move the icm */
	  fnp_num = bin (substr (mme_call_hw (1).lower, 16, 3)) + 1; /* get the fnp number */
	  do i = 1 to 2;
	     if substr (ticm.icm_buf (1), 1, 18) = "777777"b3 then do; /* if first get mem icm */
	        call db_fnp_eval_ (null (), fnp_num, ".criom", null (), exec, fnp_addr, code);
						/* get address of fnp iom table */
	        if code ^= 0 then go to db_err;		/* if error go to error routine */
	        icm_tally = 1;			/* else set icm tally to correct value */
	     end;
	     else do;
	        i = 2;				/* second get mem icm */
	        icm_tally = bin (wicm.word_total) * 2;	/* compute the icm tally */
	        fnp_addr = bin (substr (ticm.icm_buf (1), 1, 18)); /* fill in fnp address */
	     end;
	     call db_fnp_memory_$fetch (null (), fnp_num, fnp_addr, icm_tally, addr (ticm.icm_buf), code);
						/* get the iom table */
db_err:	     if code ^= 0 then do;			/* if error */
	        call convert_status_code_ (code, shortinfo, lginfo);
	        call tolts_qttyio_$rs (0, "^as: ^a error reading fnp memory", tolts_info.exec, lginfo);
						/* can't read fnp memory */
	        ticm.fnp_opcode = "000051"b3;		/* set bad status */
	     end;
	     else ticm.fnp_opcode = "000041"b3;		/* supply op complete code */
	  end;
	  ticm.rbuf_addr = "0"b;			/* zero read buffer pointer */
	  call tolts_alm_util_$gen_ck_sum (ticmp);	/* generate an icm check sum */
	  ricm = ticm;				/* move icm */
	  free ticm;
	  ticmp = null;
	  if mme_call_hf (2).lower ^= 0 then do;	/* a cc is requested */
	     exec_wd (mme_call_hf (2).upper) = "000000000004"b3;
	     call tolts_alm_util_$enter_ccc_req_ (addr (tolts_info.ccc_queue),
	      mme_call_hw (2).lower || "000000"b3);	/* enter a ccc request */
	  end;
         end;
         else if substr (wicm.host_opcode, 10, 9) = "001"b3 then do; /* if a start test request */
	  do i = 1 to 8 while (colts_pages (i).in_use);	/* find vacant test page slot */
	  end;
	  if i = 8 & colts_pages (8).in_use then do;	/* if 8 pages running - error */
	     call tolts_qttyio_$rs (0, "^a: mme gerout 04; no vacant test page slot found", exec);
	     call tolts_abort ("$c1");
	  end;

	  colts_pages (i).in_use = "1"b;		/* else set page in use */

	  do j = 1 to 8;
	     if substr (fnp (k).cdt_name (j), 1, 5) ^= "empty" then do;
	        colts_pages (i).cdt_name = tolts_info.fnp (k).cdt_name (j);
						/* save the cdt name in the test page */
	        tolts_info.fnp (k).cdt_name (j) = "empty";
	        j = 8;
	     end;
	  end;
	  tolts_info.exec_page_count = tolts_info.exec_page_count + 1; /* inc test page count */
	  dmap = addr (tolts_info.colts_pages (i).dm_arg);/* get dial_manager_arg ptr */
	  colts_pages (i).dm_arg.version = dial_manager_arg_version_2; /* fill in the required fields */
	  colts_pages (i).dm_arg.dial_qualifier = substr (colts_pages (i).cdt_name, 1, 22);
	  colts_pages (i).dm_arg.dial_channel = tolts_info.dm_event;
	  colts_pages (i).dm_arg.channel_name = colts_pages (i).cdt_name;
	  colts_pages (i).type_code = substr (wicm.icm_buf (1), 22, 6);
	  nr_cnt = 0;				/* reset the no responce count */
	  call dial_manager_$tandd_attach (dmap, code);	/* get the channel for testing */
	  if code ^= 0 then do;			/* if error */
	     if debugging then call com_err_ (code, "mtdsim_", "Error on tandd_attachment of ^a.",
	         colts_pages (i).cdt_name);
	     colts_pages (i).in_use = "0"b;		/* reset test page active */
	     call convert_status_code_ (code, shortinfo, lginfo);
	     call tolts_qttyio_$rs (0, "^as: ^a/ error attempting a tandd_attach of ^a",
	      tolts_info.exec, lginfo, substr (colts_pages (i).cdt_name, 1, 6));
	     colts_op_flags.colt_flag = "0"b;		/* make use flag is reset so we don't go blocked */
	     alloc ticm;				/* allocate a temp icm */
	     ticmp = addr (ticm);			/* get a ptr */
	     ticm = wicm;				/* move the icm */
	     ticm.fnp_opcode = "000051"b3;		/* set error status code */
	     ticm.rbuf_addr = "0"b;			/* zero read buffer pointer */
	     call tolts_alm_util_$gen_ck_sum (ticmp);	/* generate an icm check sum */
	     ricm = ticm;				/* move icm */
	     free ticm;
	     ticmp = null;
	     if mme_call_hf (2).lower ^= 0 then do;	/* a cc is requested */
	        exec_wd (mme_call_hf (2).upper) = "000000000004"b3;

	        call tolts_alm_util_$enter_ccc_req_ (addr (tolts_info.ccc_queue),
	         mme_call_hw (2).lower || "000000"b3);	/* enter a ccc request */
	     end;
	     call return_plus (3);
	  end;
	  tolts_info.wait_list.nchan = tolts_info.wait_list.nchan + 1; /* inc the event wait list */
	  tolts_info.wait_event_id (tolts_info.wait_list.nchan) = tolts_info.dm_event; /* store the event id */
	  clt_sw = substr (colts_pages (i).cdt_name, 1, 6) || ".sw"; /* create a switch name */
	  att_desc = "tty_ " || substr (colts_pages (i).cdt_name, 1, 6); /* and an attach description */
	  colts_op_flags.dm_attach = "1"b;		/* set colts control flags */
	  colts_op_flags.colt_flag = "1"b;
	  colts_op_flags.sicm = "1"b;
	  l = i;					/* save i for later use */
         end;
         else do;					/* else a normal exec icm */
	  call iox_$put_chars (fnp (k).fnp_execp, wicmp, (bin (wicm.word_total) + 1) * 4, code); /* transmit the icm */
	  if code ^= 0 then do;			/* if error */
	     call convert_status_code_ (code, shortinfo, lginfo);
	     call tolts_qttyio_$rs (0, "^as: ^a/ error on data xfer to fnp", tolts_info.exec, lginfo);
	     call tolts_abort ("$c1");		/* then abort colts */
	  end;
	  gicm_count = gicm_count + 1;		/* inc outstanding icms count */

	  if gicm_count = 17 then do;			/* if = 17 - error */
	     call tolts_qttyio_$rs (0, "^as: excessive outstanding io's", tolts_info.exec);
	     call tolts_abort ("$c1");		/* abort colts */
	  end;

	  gicm.cltp = fnp (k).fnp_execp;		/* save iocb ptr */
	  gicm.ricmp = ricmp;			/* rd icm ptr */
	  gicm.tally = bin (wicm.word_total) + 1;	/* icm tally */
	  if mme_call_hf (2).lower ^= 0 then do;	/* if cc requested */
	     gicm.cc_addr = mme_call_hw (2).lower || "000000"b3; /* save ccc address */
	     gicm.st_addr = mme_call_hf (2).upper;	/* save status address */
	  end;
         end;
      end;
      else do;					/* else icm for test chan */

         call iox_$put_chars (colts_pages (k).chanp, wicmp, (bin (wicm.word_total) + 1) * 4, code); /* send the icm */
         if code ^= 0 then do;			/* if error */
	  call convert_status_code_ (code, shortinfo, lginfo);
	  call tolts_qttyio_$rs (0, "^as: ^a/ error on data xfer to chan ^a",
	   tolts_info.exec, lginfo, substr (colts_pages (k).cdt_name, 1, 6));
	  colts_pages (k).status_word = "000000000002"b3; /* store bad status */
         end;

         gicm_count = gicm_count + 1;			/* inc outstanding icm count */

         if gicm_count = 17 then do;			/* if 17 - error */
	  call tolts_qttyio_$rs (0, "as: excessive outstanding io count", tolts_info.exec);
	  call tolts_abort ("$c1");			/* abort tolts */
         end;
         gicm.cltp = colts_pages (k).chanp;		/* save iocb ptr */
         gicm.ricmp = ricmp;				/* read icm ptr */
         gicm.tally = bin (wicm.word_total) + 1;		/* tally */
         if mme_call_hf (2).lower ^= 0 then do;		/* if cc requested */
	  gicm.cc_addr = mme_call_hw (2).lower || "000000"b3; /* save ccc address */
	  gicm.st_addr = mme_call_hf (2).upper;		/* status address */
         end;
      end;
      call return_plus (3);



gerout (5): remote_inquiry_ic = bin (rel (addr (mme_call_w (1)))); /* remember remote inquiry location */
      call return_plus (3);				/* return to colts */

gerout (06):
      k = bin (substr (mme_call_hw (1).lower, 15, 4));
      if substr (mme_call_hw (1).lower, 13, 1) = "1"b then
         mme_call_hw (1).upper = tolts_info.fnp (k).exec_type_code || "0000"b3; /* set type code	*/

      else substr (mme_call_hw (1).upper, 1, 6) = colts_pages (k).type_code;
      call return_plus (3);


gerout (7): if remote_inquiry_ic ^= 0 then do;		/* if no outstanding remote inquiry - error */

         k = bin (substr (mme_call_hw (1).upper, 1, 3));	/* k = fnp number */

         if ^tolts_info.fnp (k).exec_active then do;	/* if the fnp exec is not active */
	  dmap = addr (tolts_info.fnp (k).dm_arg);	/* get addr of dial_manager arg */
	  fnp (k).dm_arg.version = dial_manager_arg_version_2;
	  fnp (k).dm_arg.dial_qualifier = substr (fnp (k).exec_chan, 1, 22);
	  tolts_info.fnp (k).dm_arg.dial_channel = tolts_info.dm_event; /* set dial_channel to event channel */
	  tolts_info.fnp (k).dm_arg.channel_name = fnp (k).exec_chan; /* get channel name	*/

	  nr_cnt = 0;				/* reset the no responce count */
	  call dial_manager_$privileged_attach (dmap, code);
	  if code ^= 0 then do;
	     call convert_status_code_ (code, shortinfo, lginfo);
	     call tolts_qttyio_$rs (0, "^as: ^a/ error attempting a priviledged_attatch of ^a",
	      tolts_info.exec, lginfo, fnp (k).channel_name);
	     call tolts_abort ("$c1");		/* then abort colts */
	  end;

	  tolts_info.wait_list.nchan = wait_list.nchan + 1;
	  tolts_info.wait_event_id (tolts_info.wait_list.nchan) = tolts_info.dm_event;
	  clt_sw = substr (fnp (k).exec_chan, 1, 6) || ".sw";

	  att_desc = "tty_ " || substr (fnp (k).exec_chan, 1, 6);
	  colts_op_flags.colt_flag = "1"b;
	  colts_op_flags.dm_attach = "1"b; ;
	  fnp (k).exec_type_code = substr (mme_call_hw (1).lower, 13, 6); /* save exec type code	*/
         end;
         call return_plus (2);
      end;
      else do;
         call tolts_qttyio_$rs (0, "^as:  MME GEROUT 07 - no outstanding GEROUT 05", exec);
         call tolts_abort ("$c9");
      end;


gerout (15): if mme_call_hw (1).lower = "170000"b3 then call return_plus (3);
      k = bin (substr (mme_call_hw (1).lower, 15, 4));
      if substr (mme_call_hw (1).lower, 13, 3) = "4"b3 then call rel_exec_chan (k);

      else call rel_tst_chan (k);

      if mme_call_hf (2).lower ^= 0 then do;
         exec_wd (mme_call_hf (2).upper) = "000000000002"b3;
         call tolts_alm_util_$enter_ccc_req_ (addr (tolts_info.ccc_queue), mme_call_hw (2).lower || "000000"b3);
      end;

      call return_plus (3);



gerout (16): k = bin (substr (mme_call_hw (1).lower, 15, 4));
      if substr (mme_call_hw (1).lower, 13, 1) = "1"b then
         exec_wd (mme_call_hf (2).upper) = "000000000004"b3;
      else exec_wd (mme_call_hf (2).upper) = colts_pages (k).status_word;
      call return_plus (3);


%page;

/* ********* MME GESNAP ********* (snap shot dump)

   input/return registers: none

   mme     gesnap
   iotd    add,wc
   ------  return */

mme_typ (5): if trace then call tolts_qttyio_$rs (10, "^a MME GESNAP @ ^p", ctime (), mmep);
      if tolts_info.file_attach then			/* if print file attached */
         call tolts_file_util_$snap (addrel (mmep, 1));	/* go output snap dump */
      call return_plus (2);				/* return ic + 2 */
						/* ********* MME GETIME ********* (return date/time)

						   input registers: none

						   mme     getime
						   ------  return

						   return registers:   AR - date,  QR - time (right justified--1/64 ms. past midnight */

mme_typ (17): if trace then call tolts_qttyio_$rs (10, "^a MME GETIME @ ^p", ctime (), mmep);
      call tolts_init_$gc_tod (spa.regs.q);		/* get time of day */
      spa.regs.a = tolts_info.gc_date;			/* and bcd date */
      call return_plus (1);

/* ********* MME HUNGTM ********* (check for outstanding I/O)

   input registers:   AU = test page index (mod 4)

   mme     hungtm
   ------  return not in transmission
   ------  return in transmission

   return registers: QR = lostit time, X1 = 5 if timeout; = 3 if still time to go */

mme_typ (-16): if trace then call tolts_qttyio_$rs (10, "^a MME HUNGTM @ ^p", ctime (), mmep);
      call get_px_sct ("HUNGTM", bin (substr (spa.regs.a, 1, 18), 17), "1"b); /* get test page index */
      if substr (spa.regs.a, 1, 18) = "0"b then do;
         call tolts_qttyio_$rs (0, "^a MME HUNGTM  illegal test page index @ ^p", ctime (), mmep);
         call tolts_abort ("$b6");
      end;
      call tolts_init_$gc_tod (gcos_tod);		/* get current time of day */
      if bin (gcos_tod, 36) >= io_info.con_time + io_info.lostit_time then do; /* if time exceeded */
         spa.regs.x (1) = "000005"b3;			/* set courtesy call wating */
         exec_wd (io_info.status_add) = "510006000000"b3;	/* set time out status */
         call tolts_alm_util_$enter_ccc_req_ (addr (tolts_info.ccc_queue),
	string (io_info.icivlu));			/* enter ccc request */
         spa.regs.q = "0"b;				/* set 0 lostit time */
      end;
      else do;					/* not time out yet */
         spa.regs.x (1) = "000003"b3;			/* set in xmission */
         spa.regs.q = bit ((io_info.con_time + io_info.lostit_time) - bin (gcos_tod, 35, 0), 35);
      end;
      call return_plus (2);				/* return ic + 2 */
%page;
/* ********* MME IOCONS ********* (return number of I/O connects)

   input registers:   x1 = sct (test page index mod 4)

   mme     iocons
   ------  return

   return registers:   AR = number of connects for this test page */

mme_typ (-17): if trace then call tolts_qttyio_$rs (10, "^a MME IOCONS @ ^p", ctime (), mmep);
      call get_px_sct ("IOCONS", bin (spa.regs.x (1), 17), "1"b); /* get test page index */
      spa.regs.a = bit (bin (pages (io_sel).num_connects, 36));
      call return_plus (1);

/* ********* MME IPCW. ********* ( send initialize PCW to mpc )

   input registers:   x1 = ICC


   mme     ipcw.
   ------  return

   return registers: none */

mme_typ (-55): if trace then call tolts_qttyio_$rs (10, "^a MME IPCW. @ ^p", ctime (), mmep);
      if substr (spa.regs.x (1), 7, 1) then		/* if new format */
         call get_px_tcx ("IPCW. ", substr (spa.regs.x (1), 8, 11)); /* get test page index */
      else call get_px_tcx ("IPCW. ", substr (spa.regs.x (1), 10, 9)); /* get test page index */
      pcwa = "0"b;					/* initialize pcw first */
      pcwp = addr (pcwa);
      pcw.code = "111"b;				/* Set PCW code */
      pcw.mask = "1"b;				/* Make it a reset PCW */
      pcw.control = "11"b;
      ioi_wksp = io_info.workspace_ptr;			/* get ptr to our workspace */
      tio_off = fixed (rel (addr (tolts_workspace.p_idcw)));/* set default dcw list offset for ioi */
      idcwp = addr (tolts_workspace.p_idcw);		/* set up idcw ptr */
      string (idcw) = "0"b;				/* intiialize idcw */
      idcw.code = "7"b3;				/* set in idcw type code */
      io_info.to_no_cc = "1"b;			/* set flag for int processor */
      call ioi_$connect_pcw (io_info.device_index, tio_off, pcwa, error);
      if error ^= 0 then do;
         call output_status_code (error, "io connect error");
         call tolts_abort ("$m5");
      end;
      call return_plus (1);
%page;
/* ********* MME LODIMG ********* (load print train image (GCOS only))

   input registers:   x1 = sct (test page index mod 4)

   mme     lodimg
   ------  return good
   ------  return bad

   return registers: none */

mme_typ (-18): if trace then call tolts_qttyio_$rs (10, "^a MME LODIMG @ ^p", ctime (), mmep);
      call return_plus (1);				/* return ic + 1 */

/* ********* MME LODVFC ********* (load printer vertical format control (VFC) (GCOS only))

   input registers:   x1 = sct (test page index mod 4)

   mme     lodvfc
   ------  return good
   ------  return error

   return registers:   a-reg = error code on error */

mme_typ (-19): if trace then call tolts_qttyio_$rs (10, "^a MME LODVFC @ ^p", ctime (), mmep);
      call return_plus (1);				/* return ic + 1 */

/* ********* MME LPW. ********* ( return LPW tally residue )

   input registers:   x1 = ICC

   mme     lpw.
   ------  return

   return registers:   A-REG = LPW, .crmb1,1 */

mme_typ (-52): if trace then call tolts_qttyio_$rs (10, "^a MME LPW. @ ^p", ctime (), mmep);
      if substr (spa.regs.x (1), 7, 1) then		/* if new format */
         call get_px_tcx ("LPW.  ", substr (spa.regs.x (1), 8, 11)); /* get test page index */
      else call get_px_tcx ("LPW.  ", substr (spa.regs.x (1), 10, 9)); /* get test page index */
      ioi_wksp = pages (io_sel).workspace_ptr;		/* get ptr to proper workspace */
      spa.regs.a = tolts_workspace.lpw (1);		/* copy lpw tally residue */
      call return_plus (1);


/* ********* MME MASTER MODE ENTRY ********* */

mme_typ (30):					/* not valid on Multics */
      call return_plus (1);



%page;

/* ********* MME MBXCMP ********* (Responder compare mailbox data)

   inputr registers:

   X1 = pointer to was data
   X2 = pointer to s/b data
   X5 = fpinfo pointer
   mme     mbxcmp
   error return
   good return

   return registers:
   A = bad data if not compare  */

mme_typ (-90): if trace then call tolts_qttyio_$rs (10, "^a MME MBXCMP @ ^p", ctime (), mmep);

      tolts_fpinfo_ptr = addrel (execp, spa.regs.x (5));	/* get a ptr to the test page fpinfo table */
      do io_sel = 1 to hbound (pages, 1)		/* get the io_info for this page */
       while (pages (io_sel).fnp_num ^= tolts_fpinfo.pcw_info.fnp_num);
      end;
      if io_sel > hbound (pages, 1) then call tolts_abort ("$c3"); /* io_info for this page not found */
      io_info_ptr = addr (pages (io_sel));
      tolts_rspd_wksp = io_info.tolts_rspd_wksp;
      lvl_idx = (bin (substr (spa.regs.x (1), 13, 3)));	/* get the level */
      ws_data_idx = (bin (substr (spa.regs.x (1), 16, 3))); /* was data index */
      sb_data_idx = (bin (substr (spa.regs.x (2), 16, 3))); /* s/b data index */
      if tolts_rspd_workspace.ima_level (lvl_idx).word (sb_data_idx) /* compare the data */
       ^= tolts_rspd_workspace.ima_level (lvl_idx).word (ws_data_idx) then do;
         spa.regs.a = tolts_rspd_workspace.ima_level (lvl_idx).word (ws_data_idx);
         call return_plus (1);			/* take error return */
      end;
      else call return_plus (2);			/* take good return */


/* ********* MME MBXDAT ********* (mme to manipulate mailbox data)

   input registers:
   x1 = pointer to FPINFO table
   x2 = subcommand code
   1 = MBLC (get mbx location)       2 = INITMB (intialize mailbox data)
   3 = RDMBX (read mailbox)	       6 = RDINT (read interrupt word)
   7 = RDINT0 (rd intrpt wrd & 0)   11 = STMBX (store mailbox word)

   mme	MBXDAT
   zero	error return       (mme call + 1)
   zero	timeout return       (mme call + 2)
   zero	retry return       (mme call + 3)
   zero	good return        (mme call + 4)

   return registers:
   A & Q = data requested.

   Data is also entered into FPINFO table.

   dcl 1 tolts_fpinfo aligned based (tolts_fpinfo_ptr),
   *      2 pcw_info,
   *         3 fnp_num fixed bin unaligned,
   *         3 chan fixed bin (6) unaligned,
   *         3 cmnd fixed bin (6) unaligned,
   *     2 fnpdcw,
   *         3 address fixed bin unaligned,
   *         3 word_count fixed bin unaligned,
   *     2 io_rq_cnt fixed bin (35),
   *     2 mbxloc fixed bin (35),
   *     2 spec_cnt fixed bin,
   *     2 term_cnt fixed bin,
   *     2 partrs fixed bin (35),
   *     2 timeout_time fixed bin (35),
   *     2 temp01,
   *       3 word1,
   *         4 upper bit (18),
   *         4 lower bit (18),
   *       3 word2,
   *         4 upper bit (18),
   *         4 lower bit (18),
   *     2 temp02,
   *       3 word1,
   *         4 upper bit (18),
   *         4 lower bit (18),
   *       3 word2,
   *         4 upper bit (18),
   *         4 lower bit (18),
   *     2 temp03,
   *       3 word1,
   *         4 upper bit (18),
   *         4 lower bit (18),
   *       3 word2,
   *         4 upper bit (18),
   *         4 lower bit (18),
   *     2 lvl3_flag bit (36),
   *     2 lvl7_flag bit (36),
   *     2 lvl3_cnt fixed bin (35),
   *     2 lvl7_cnt fixed bin (35),
   *     2 pprt_avail bit (35); */



mme_typ (-65): if trace then call tolts_qttyio_$rs (10, "^a MME MBXDAT ^p, type - ^6.3b", ctime (), mmep, spa.regs.x (2));

      tolts_fpinfo_ptr = addrel (execp, spa.regs.x (1));	/* get a ptr to the test page fpinfo table */
      do io_sel = 1 to hbound (pages, 1)		/* get the io_info for this page */
       while (pages (io_sel).fnp_num ^= tolts_fpinfo.pcw_info.fnp_num);
      end;
      if io_sel > hbound (pages, 1) then call tolts_abort ("$c3"); /* io_info for this page not found */
      io_info_ptr = addr (pages (io_sel));
      io_info.fpinfo_ptr = tolts_fpinfo_ptr;
      goto sub_cmnd (bin (spa.regs.x (2)));


sub_cmnd (1):


      call tolts_device_info_ (addr (io_info.test_req), io_sel, t_err);
      if t_err ^= 0 then call tolts_abort ("$c4");

/* create an event call channel for tdio status events */

      if ^io_info.ev_ch_ass then do;			/* we we havn't done this already */
         call tolts_init_$cr_event_chan (io_info.status_event,
	"1"b, tolts_io_int_, io_info_ptr, 2, error);
         if error ^= 0 then				/* if error creating event call chan */
	  call tolts_abort ("$a9");
         io_info.ev_ch_ass = "1"b;			/* set event chan assigned flag */
      end;
      call ioa_$rsnnl ("T&D is attaching for a ^[write^]^[read^] ^a",
       att_desc, mesg_len, (^rd_flag), (rd_flag), io_info.device_name);
      call rcp_$attach (io_info.rcp_name, addr (io_info.rcp_area (1)), io_info.status_event,
       att_desc, io_info.rcp_id, error);

      if error ^= 0 then do;
         call output_status_code (error, "rcp attach error");
         call dealcp_sub;				/* go release status event */
         call tolts_abort ("$c5");
      end;

      call rcp_$check_attach (io_info.rcp_id, addr (io_info.rcp_area (1)), coment, io_info.device_index,
       tolts_info.max_wks_sz, tolts_info.max_to, io_info.rcp_state, io_info.attach_err);
      if io_info.attach_err ^= 0
       | io_info.rcp_state ^= 0 then do;
         if io_info.attach_err ^= 0 then
	  call output_status_code (io_info.attach_err, "workspace assign error");
         call dealcp_sub;
         call tolts_abort ("$c6");
      end;
      io_info.p_att = "1"b;
      io_info.tolts_rspd_wksp = addr (tolts_rspd_workspace);
      call ioi_$workspace (io_info.device_index, io_info.tolts_rspd_wksp, tolts_info.wks_sz, error);
      if error ^= 0 then do;
         call output_status_code (error, "workspace assign error");
         call dealcp_sub;				/* go release status event */
         call tolts_abort ("$c6");
      end;
      io_info.cur_wks_sz = tolts_info.wks_sz;		/* set current value of workspace size */
      call ioi_$set_status (io_info.device_index, fixed (rel (addr (tolts_rspd_workspace.mailbox.status_word)), 18), 1, error);

      tolts_fpinfo.mbxloc = 0;
      spa.regs.q = "0"b;
      tolts_fpinfo.partrs = -1;

      call return_plus (4);


sub_cmnd (2):

      tolts_rspd_wksp = io_info.tolts_rspd_wksp;
      unspec (tolts_rspd_workspace.num_int) = "0"b;

      call return_plus (4);


sub_cmnd (3):

      tolts_rspd_wksp = io_info.tolts_rspd_wksp;
      spa.regs.a = unspec (tolts_rspd_workspace.mailbox.pcw);

      call return_plus (4);

sub_cmnd (6):

      tolts_rspd_wksp = io_info.tolts_rspd_wksp;
      unspec (tolts_fpinfo.temp03.word1) = unspec (tolts_rspd_workspace.mailbox.num_int);

      call return_plus (4);

sub_cmnd (7):

      tolts_rspd_wksp = io_info.tolts_rspd_wksp;
      unspec (tolts_fpinfo.temp03.word2) = unspec (tolts_rspd_workspace.mailbox.num_int);
      unspec (tolts_rspd_workspace.mailbox.num_int) = "0"b;

      call return_plus (4);

sub_cmnd (11):

      tolts_rspd_wksp = io_info.tolts_rspd_wksp;
      k = bin (substr (tolts_fpinfo.temp03.word1.upper, 13, 3));
      unspec (tolts_rspd_workspace.ima_level (k)) = "0"b;
      do i = 1 to bin (tolts_fpinfo.temp02.word1.upper);
         ima_level (k).word (i) = spa.regs.a;
      end;

      call return_plus (4);

%page;


/* ********* MME PACMAN ********* (allocate IPC's for mcad test )

   input registers:			    Channel List format:
   x1 = sct (test page index mod 4)	    vfd 9/base chnl,9/# of chnls,16/flags
   x2 = address of channel list	    .
   x5 = address of mca config		    .
   A  =  0 then attach channels	    oct -1 end of list flag
   A ^= 0 then return channels
   Q  = ICC
   mme	pacman
   zero	error return	x2 = reason code		  (mme call + 1)
   zero	error return	no chnls requested configured	  (mme call + 2)
   zero	retry return	I/O in progress, retry	  (mme call + 3)
   zero	good return	requested chnls assigned	  (mme call + 4)

   return registers:
   X2 = error code on error (see set_sctwrk subroutine for error codes)
   *			output in sctwrk (12 words): see the set_sctwrk subroutine */

dcl  1 chan_list aligned based (clp),
         (2 base_chan fixed bin (9) uns,
       2 num_chans fixed bin (9) uns,
       2 flags,
         3 reboot bit (1),
         3 pad bit (17)) unaligned;
dcl  clp ptr;
dcl  p99 pic "99" based;


mme_typ (-87): if trace then call tolts_qttyio_$rs (10, "^a MME PACMAN @ ^p", ctime (), mmep);

      if substr (spa.regs.q, 7, 1) then			/* if new format */
         call get_px_tcx ("PACMAN", substr (spa.regs.q, 8, 11)); /* get test page index */
      else call get_px_tcx ("PACMAN", substr (spa.regs.q, 10, 9)); /* get test page index */
      clp = addrel (execp, fixed (spa.regs.x (2)));
      if spa.regs.a = "0"b then do;
         if io_info.ipc_attached then do;
	  call mca_$detach_ipc ((io_info.ipc_id), io_info.mca_ioi_idx, "0"b, code);
	  call tolts_qttyio_$rs (0, "^a ipc was still attached will detach leaving the device suspended", io_info.ipc_id);
         end;
         io_info.ipc_id = substr (io_info.device_name, 4, 1) || convert (p99, (chan_list.base_chan));
         call mca_$attach_ipc ((io_info.ipc_id), io_info.mca_ioi_idx, io_info.ipc_number, code);
         if code ^= 0 then do;
	  if code = error_table_$resource_unavailable then do; /* must have been busy */
	     spa.regs.x (2) = bit (dev_busy);		/* set appropriate error code */
	     call tolts_qttyio_$rs (0, "^a ipc ^a busy", io_info.test_hdr, io_info.ipc_id);
	     call return_plus (1);			/* return ic + 7 */
	  end;
	  else do;
	     call output_status_code (code, "ipc attach error");
	     spa.regs.x (2) = bit (os_deny);		/* set appropriate error code */
	     call return_plus (1);			/* take error return */
	  end;
         end;
         io_info.ipc_attached = "1"b;
      end;
      else if io_info.ipc_attached then do;
         call mca_$detach_ipc ((io_info.ipc_id), io_info.mca_ioi_idx,
	chan_list.flags.reboot, code);
         if code ^= 0 then call tolts_abort ("$p2");
         else io_info.ipc_attached = "0"b;
      end;
      call return_plus (4);


%page;
/* *************************************************************************************************************
   *   MTAR has to know what operating system it is running on. This code passes the Multics code to cmlt
   *   which passes it to mtar at initialize time.   *
   ************************************************************************************************************** */

/*    ********* MME POINIT ********* (slave executive initialize)

   input/output registers: none

   mme	poinit
   zero	wwflag,o.s. code	from .crfig (upper) Multics o.s. code (lower)
   zero	lstloc,0	core size available as loaded
   zero	tewrk,0	from .crctb
   zero	.tdioc,0	from .crioc
   zero	wradd,0	wrapup address
   zero	cvttbl,0	conversion table ptr
   zero	mmexec,0	position of ttl date in message
   zero	mintr,0	min/max memory test ranges (2 words)
   zero	crafc0,0	.cracf bit 3 & mpc entry if single disk & disk acf for pri and alt files (3 words )
   ----	return	return is mme call + 10

   .crfig:

   0 = series 60 0r 6000	6 = system sckd. save opt.		24-30 = reserved for gcos
   1 = class. module present	7 = reserved for gcos		31 = not in mem avail. space tab
   2 = shared memory system	8,9,10,11 = ioms 0-3 configured	32 = RLP300 present
   3 = >256k		12,13,14,15 = CPUs 0-3 configured	33 = DN30
   4 = IOM system		16-19 = reserved for gcos		34 = DN305
   5 = series 60 system	20,21,22,23 = CPU has EIS		35 = DN	355/6600

   .crctb ->    chars specify the first six tabs beyond position 0
   .crioc ->    -1 = IOMs */

mme_typ (-20): if trace then call tolts_qttyio_$rs (10, "^a MME POINIT @ ^p", ctime (), mmep);
      exec_wd (mme_call_hf (1).upper) = "0"b;		/*	zeros says not ww system */
      if mme_call_hf (1).lower ^= 0 then
         exec_wd (mme_call_hf (1).lower) = "000000000002"b3;/* store Multics code if pointer */
      exec_wd (mme_call_hf (3).upper) = "122436506274"b3;	/*	tabs at 10,20,30,40,50,60  */
      iom_cardp = null;
      term = "0"b;					/* reset terminate condition */
      do while (^term);				/* find all iom cards */
         call tolts_util_$find_card ("iom ", iom_cardp);	/* find iom card */
         if iom_cardp = null then term = "1"b;		/* completed search of the deck */
         else do;
	  if iom_card.model = "imu " then imu_found = "1"b;
	  else if iom_card.model = "iom" then iom_found = "1"b;
         end;
      end;

      if imu_found then				/* imu system  */
         exec_wd (mme_call_hf (4).upper) = "777777000000"b3;
      else if iom_found then				/* iom system */
         exec_wd (mme_call_hf (4).upper) = "777777777777"b3;
      else exec_wd (mme_call_hf (4).upper) = "0"b3;	/* let the usbexec complain */

      spa.wrapup_add = mme_call_hw (5).upper;		/* set wrapup address */
      call tolts_alm_util_$ascii_to_bcd_ (ttl_date, bcd_callname); /* convert ttl date to bcd */
      exec_wd (mme_call_hf (7).upper) = bcd_callname;	/* and store in message */
      substr (exec_wd (mme_call_hf (7).upper - 1), 19, 18) = "622017"b3; /* change version? ?? to version?s ? */
      genp = addrel (execp, mme_call_hf (2).upper);	/* get ptr to lstloc */
      if exec = "molt" then do;
         if fix_wd (1) ^= 0 then			/* if lstloc specified... */
	  mem_now, fix_wd (1) = fix_wd (1) + 196608;	/* add 196k to lstloc */
         else mem_now, fix_wd (1) = fixed (gload_data.text_len) + 196608; /* otherwise use loaded length */
      end;
      else do;
         if fix_wd (1) ^= 0 then			/* if lstloc specified... */
	  mem_now, fix_wd (1) = fix_wd (1) + 32768;	/* add 32k to lstloc */
         else mem_now, fix_wd (1) = fixed (gload_data.text_len) + 32768; /* otherwise use loaded length */
      end;
      call cpu_time_and_paging_ (i, cpu_time, j);		/* get current cpu time */
      tolts_info.init_time = cpu_time;			/* save  */
      call return_plus (10);				/* return ic + 10 */
%page;
/* ********* MME PROCTM ********* (return CPU time used since exec init)

   input registers: none

   mme     proctm
   ------  return

   return registers:   a-reg = processor time in 1/64 ms */

mme_typ (-21): if trace then call tolts_qttyio_$rs (10, "^a MME PROCTM @ ^p", ctime (), mmep);
      call cpu_time_and_paging_ (i, cpu_time, j);		/* get current cpu time */
      cpu_time = cpu_time - tolts_info.init_time;		/* compute delta */
      spa.regs.a = bit (bin (divide (cpu_time * 64, 1000, 71, 0), 36)); /* return time */
      call return_plus (1);

/* ********* MME PRTRAN ********* (load print train image for test)

   input registers:   x1 = sct (test page index mod 4)

   mme     prtran
   zero    loc,0 pointer to buffer for train image
   ------  return error
   ------  return good

   return registers: AR contains error code if error */

mme_typ (-22): if trace then call tolts_qttyio_$rs (10, "^a MME PRTRAN @ ^p", ctime (), mmep);
      call get_px_sct ("PRTRAN", bin (spa.regs.x (1), 17), "1"b); /* get test page index */
      do i = 1 to printer_images_$n_images while (io_info.devsct.ptrain ^= printer_images_$image_numbers (i));
      end;
      if i > printer_images_$n_images then do;
         call tolts_qttyio_$rs (0, "^as: MME PRTRAN; No such train number - ^d",
	exec, io_info.devsct.ptrain);
         call tolts_abort ("$b1");
      end;
      tp = addrel (addr (printer_images_$image_base), printer_images_$image_offsets (i));
      train_ptr = addrel (execp, mme_call_hf (1).upper);
      train_ptr -> prt_image = tp -> prt_image;
      call return_plus (3);				/* return ic + 3 */
%page;
/* ********* MME READIO ********* (read options)

   input registers:	   x1 = 3/exec #,9/0,6/cid
   *		   x4 -> (see opt_temp structure declaration below)

   mme     readio
   ------  return if tolts aborted
   ------  return if tolts swapped
   ------  return good

   return registers: none */

dcl  1 opt_temp based (genp) aligned,			/* template for MME READIO */
       (2 bcd_o_dash bit (18),			/* = bcd " o-" */
       2 tdpcn_add fixed bin,				/* address of .tdpcn */
       2 bufnum fixed bin,				/* tadio buffer (array element) number */
       2 nu1 bit (6),
       2 exec_num bit (6),
       2 nu2 bit (6),
       2 opt_ptr fixed bin,				/* ptr to options storage area */
       2 nu3 bit (6),
       2 phy_term bit (12)) unaligned;			/* physical terminal id */

dcl  bcd_options bit (6 * 84) based (genp);		/* to move options to test page */

mme_typ (-24): if trace then call tolts_qttyio_$rs (10, "^a MME READIO @ ^p", ctime (), mmep);
      genp = addrel (execp, spa.regs.x (4));		/* get ptr to options template */
      i = opt_temp.bufnum;				/* get tadio buffer number */
      tolts_info.tadio (i).inuse = "0"b;		/* reset  buffer in use flag */
      genp = addrel (execp, opt_temp.opt_ptr);		/* get ptr to store options */
      bcd_options = tolts_info.tadio (i).option;		/* move options to test page */
      call return_plus (3);				/* return ic + 3 */
%page;
/* ********* MME RELEAS ********* ( release device (reboot mpc firmware if running ITRs))

   input registers:

   *	POLT			MOLT
   X0	----			Master console file code
   X1	SCT (test page index * 4)	SCT (test page index * 4)
   X2	Patptr			----
   X4	----			Patptr
   X6	----			possible hang flag
   X7	0			Molt test type (In upper 6 bits: C = itrs, R = MDRs, T = MTAR, M = memory)
   AR	----			type code (tdcxxa)
   QR	----			ICC (XICCXXXX)

   mme     releas
   ------  return if error
   ------  return

   return registers: none */

mme_typ (-56): if trace then call tolts_qttyio_$rs (10, "^a MME RELEAS @ ^p", ctime (), mmep);
      if spa.regs.x (7) ^= "0"b then			/* if not polts */
         if substr (spa.regs.x (7), 1, 6) = "23"b3 then do; /* molts, running itrs */
	  call get_px_sct ("RELEAS", bin (spa.regs.x (1), 17), "1"b); /* get test page index */
	  if io_info.chan_suspended then do;		/* only load firmware if channel suspended */
	     call tolts_load_firmware_ (io_sel, error);	/* go load mpc firmware */
	     if error ^= 0 then			/* if error loading firmware */
	        call ck_release;			/* try again, and then ask user */
	  end;
         end;
      call return_plus (2);

/* ********* MME RLSMPC ********* (release mpc)

   input registers:   x1 = mpc controller sct pointer

   mme     rlsmpc
   ------  return

   return registers: none */

mme_typ (-26): if trace then call tolts_qttyio_$rs (10, "^a MME RLSMPC @ ^p", ctime (), mmep);
      call return_plus (1);

/* ********* MME RLSPAT ********* (release peripheral allocation table entry)

   input registers:   x4 = pat address (offset relative to LAL)

   mme     rlspat
   ------  return

   return registers: none */

mme_typ (-28): if trace then call tolts_qttyio_$rs (10, "^a MME RLSPAT @ ^p", ctime (), mmep);
      call return_plus (1);
%page;

/* ********* MME RSPCHK ********* (check for fnp response)

   input registers:   x1 = fpinfo table pointer

   mme     rspchk
   ----	 error return
   ----	 timeout return
   ----	 retry return
   ----	 good return

   return registers:  q = status word if fault occurs */

mme_typ (-91): if trace then call tolts_qttyio_$rs (10, "^a MME RSPCHK @ ^p", ctime (), mmep);

      tolts_fpinfo_ptr = addrel (execp, spa.regs.x (1));	/* get a ptr to the test page fpinfo table */
      do io_sel = 1 to hbound (pages, 1)		/* get the io_info for this page */
       while (pages (io_sel).fnp_num ^= tolts_fpinfo.pcw_info.fnp_num);
      end;
      if io_sel > hbound (pages, 1) then call tolts_abort ("$c3"); /* io_info for this page not found */
      io_info_ptr = addr (pages (io_sel));
      tolts_rspd_wksp = io_info.tolts_rspd_wksp;
      call tolts_init_$gc_tod (gcos_tod);
      if tolts_rspd_workspace.mailbox.status_word ^= "0"b then do; /* error status stored */
         if tolts_fpinfo.io_rq_cnt > 0 then		/* if io request cnt > 0 */
	  tolts_fpinfo.io_rq_cnt = tolts_fpinfo.io_rq_cnt - 1;
         if substr (tolts_rspd_workspace.status_word, 4, 1) = "1"b /* if timeout */
	| bin (tolts_fpinfo.timeout_time) - bin (gcos_tod) < 1 then
	  call return_plus (2);			/* take timeout return */
         else do;					/* else take normal error return */
	  spa.regs.q = tolts_rspd_workspace.status_word;	/* return the status */
	  call return_plus (1);			/* take error return */
         end;
      end;
      else do;					/* no error */
         tolts_fpinfo.spec_cnt =
	tolts_rspd_workspace.mailbox.num_int.lvl7;	/* move spec count */
         tolts_fpinfo.term_cnt =
	tolts_rspd_workspace.mailbox.num_int.lvl3;	/* move term count */
         tolts_fpinfo.lvl3_cnt =			/* decr levl 3 count with saved value */
	tolts_fpinfo.term_cnt - bin (unspec (tolts_fpinfo.temp01.word2));
         tolts_fpinfo.lvl7_cnt =			/* decr levl 7 count with saved value */
	tolts_fpinfo.spec_cnt - bin (unspec (tolts_fpinfo.temp01.word1));
         if (tolts_fpinfo.lvl3_cnt = 0 & tolts_fpinfo.lvl3_flag) /* if no term int & one expected */
	| (tolts_fpinfo.lvl7_cnt = 0 & tolts_fpinfo.lvl7_flag) /* or no spec int & one ecpected */
	& (bin (tolts_fpinfo.timeout_time) < 0) then	/* & no timeout */
	  call return_plus (3);			/* take retry return */
         else do;
	  if tolts_fpinfo.io_rq_cnt > 0 then
	     tolts_fpinfo.io_rq_cnt = tolts_fpinfo.io_rq_cnt - 1;
	  if (tolts_fpinfo.lvl3_cnt = 1 | ^tolts_fpinfo.lvl3_flag)
	   & (tolts_fpinfo.lvl7_cnt = 1 | ^tolts_fpinfo.lvl7_flag) then
	     call return_plus (4);			/* take good return */
         end;
      end;

%page;
/* ********* MME SCTCMP********* (generate SCT entry)

   input registers: X2 = 128 chan number for new format

   mme     sctcmp
   zero    ficcdd,0
   zero    sctwrk,0
   ------  return good--shared file
   ------  return good--non-shared file
   ------  return error

   return registers:	X2 = error code if error (see set_sctwrk subroutine for error codes)
   *			output in sctwrk area: see set_sctwrk subroutine */

mme_typ (-29): if trace then call tolts_qttyio_$rs (10, "^a MME SCTCMP @ ^p", ctime (), mmep);
      do i = 1 to 8 while (pages (i).in_use);		/* find vacant page */
      end;
      if i = 8 & pages (8).in_use then do;		/* no vacant page */
         call tolts_qttyio_$rs (0, "^a: MME SCTCMP; No vacant test page slot found", exec);
         call tolts_abort ("$a1");
      end;
      unspec (pages (i)) = "0"b;			/* clear test page data */
      call set_sctwrk (i);				/* go set up the sct work area */
      if spa.regs.x (2) ^= "0"b then do;		/* if error */
         if fixed (spa.regs.x (2)) = m_iv_iom then	/* if invalid IOM number... */
	  spa.regs.x (2) = "0"b;			/* correct it */
         call return_plus (5);			/* take error return */
      end;
      pages (i).in_use = "1"b;			/* set page in use flag */
      tolts_info.exec_page_count = tolts_info.exec_page_count + 1; /* increment total test page count */
      if pages (i).io_type = polt_io_type then		/* if user wants to run itrs... */
         itr_run = "1"b;				/* set flag for wake_disp subroutine */
      call return_plus (4);				/* take good return */
%page;
/* ********* MME SETPRT & MME SETPR2 ********* (reserve printer (attach print file in Multics's case ))

   input/return registers: none

   mme     setprt
   ------  return tolts aborted
   ------  return tolts swapped
   ------  no prt available
   ------  return pr2 in use
   ------  return good */

mme_typ (-30):
mme_typ (-31): if trace then call tolts_qttyio_$rs (10, "^a MME SET^[PRT^;PR2^] @ ^p", ctime (), (mme_number = -33), mmep);
      if ^tolts_info.file_attach then do;		/* if print file not already attached... */
         call tolts_file_util_$open (error);		/* attach and open it */
         if error = 0 then				/* if no attach error */
	  call return_plus (5);			/* return good */
      end;
      call return_plus (3);				/* return ic + 3 */

/* ********* MME SETPUN ********* (set reader/punch to punch mode)

   input registers:   x1 = sct (test page index mod 4)

   mme     setpun
   ------  return, no operator message
   ------	 return, Output Operator message to put reader/punch in punch mode

   return registers: X1 = sct address

   Issued for 214 reader/punch to set in punch mode before mme allocr to set punch indicator in sct */

mme_typ (-32): if trace then call tolts_qttyio_$rs (10, "^a MME SETPUN @ ^p", ctime (), mmep);
      call get_px_sct ("SETPUN", bin (spa.regs.x (1), 17), "0"b); /* get test page index */
      io_info.ccu_pun = "1"b;				/* remember we want a punch */
      call return_plus (1);

/* ********* MME SETTYP & MME DISPRT ********* (reset prt or pr2 request)

   input/return registers: none

   mme     settyp
   ------  return tolts aborted
   ------  return tolts swapped
   ------  return good */

mme_typ (-11):
mme_typ (-33): if trace then call tolts_qttyio_$rs (10, "^a MME ^[SETTYP^;DISPRT^] @ ^p", ctime (), (mme_number = -33), mmep);
      if tolts_info.file_attach then			/* if print file attached... */
         call tolts_file_util_$close;			/*  close it out */
      call return_plus (3);				/* return ic + 3 */
%page;
/* ********* MME TADIOD ********* (T&D terminal I/O)

   input registers:	a-reg = 18/.tdpcn,6/pad,1/nu,1/dont record denial,1/mbz,3/exec,6/lid

   mme     tadio
   zero    nodcws,0
   zero    iotpd,wc   from 1 to 5 of these exist
   ------  return if tolts aborted
   ------  return if tolts swapped
   ------  return if request denied
   ------  return accepted

   return registers: none

   tadio type:		bit 23 "p" 1     print line	bit 22 "c" 2    controlling terminal
   *			bit 21 "s" 4     slave term.	bit 20 "m" 8    master console output
   *			bit 19 "r" 16    output/input	bit 18 "e" 32   select console/printer by option
   all valid combinations:	ps  - 5	sp  - 5	cs  - 6	sc  - 6	mp  - 9	pm  - 9	cm  - 10
   *			mc  - 10	ms  - 12	sm  - 12	mps - 13	msp - 13	pms - 13	psm - 13
   *			smp - 13	spm - 13	cms - 14	csm - 14	mcs - 14	msc - 14
   *			scm - 14	smc - 14	ep  - 33	pe  - 33	em  - 40	me  - 40	   */

mme_typ (-34): if trace then call tolts_qttyio_$rs (10, "^a MME TADIOD @ ^p", ctime (), mmep);
      ndcws = mme_call_hf (1).upper;			/* extract number of dcws */
      if ndcws < 1 | ndcws > 5 then do;
         call tolts_qttyio_$rs (0, "^as: MME TADIOD; Number of dcws = ^d", exec, ndcws);
         call tolts_abort ("$b2");
      end;
      do i = 1 to 8 while (tolts_info.tadio (i).inuse);	/* find vacant tadio queue entry */
      end;
      if i = 8 & tolts_info.tadio (8).inuse then do;	/* no queue entry */
         call tolts_qttyio_$rs (0, "^as: MME TADIOD; No vacant queue entry", exec);
         call tolts_abort ("$b2");
      end;
      tolts_info.tadio (i).inuse = "1"b;		/* fill in the queue entry */
      tolts_info.tadio (i).return_word (3) = "000000006361"b3; /* phy term sb 24-35 */
      tolts_info.tadio (i).return_word (2) = bit (bin (i, 18)) || "000000"b3;
      if substr (mme_call_w (2), 20, 1) = "1"b then do;	/* if read involved */
         tolts_info.tadio (i).optrd = "1"b;
         tolts_info.tadio (i).return_word (1) = "204652"b3 || substr (spa.regs.a, 1, 18); /* " o-||.tdpcn */
         pad_char = substr (spa.regs.a, 19, 6);		/* pick up pad character */
         do j = 0 to 83;				/*  pad options buffer */
	  substr (tolts_info.tadio (i).option, (j * 6) + 1, 6) = pad_char;
         end;
      end;
      else do;
         tolts_info.tadio (i).optrd = "0"b;
         tolts_info.tadio (i).return_word (1) = "206252"b3 || substr (spa.regs.a, 1, 18); /* " s-||.tdpcn */
      end;
      call tolts_qttyio_$dcw_ptr (addrel (mmep, 2), ndcws, i); /* go queue up message */
      spa.enter.icivlu.ic = rel (addr (mme_call_w (5 + ndcws))); /* return ic +5 + number of dcws */
      call wake_disp;				/* go wake up dispatcher */
%page;
/* ********* MME TDIO ********* (issue I/O to device under test)

   input registers: none

   mme     tdio			eep commands:	3100007x4000 = diagnostic mode control
   zero    myioq,0					2200007x4000 = read controller main memory
   zero    tpbase,0					0600007x4000 = initiate read data transfer
   zero    datara,redfol-wrtpre+1  ( = 0 if molts)	where x = 0 if last and 2 if continue idcw
   zero    iotrac,0
   ------  return

   return registers: AR = Time of day of connect, QR = lostit time, X4 = test page index */

mme_typ (-36): ioe_ptr = addrel (execp, mme_call_hf (1).upper); /* get ptr to our io_entry */
      if trace then do;
         call tolts_qttyio_$rs (10, "^a MME TDIO @ ^p", ctime (), mmep);
         call ioa_$rsnnl ("^/io_entry:^-^4(^12.3b ^)^/^-^4(^12.3b ^)^/^-^3(^12.3b ^)",
	message, mesg_len, ioe, ioe (5), ioe (9));
         call tolts_qttyio_ (message, 10);
      end;
      if trace_io then do;				/* count number of mme tdio's if -tio option true */
         call tolts_qttyio_$rs (10, "^a MME TDIO @ ^p", ctime (), mmep);
         call ioa_$rsnnl ("^/io_entry:^-^4(^12.3b ^)^/^-^4(^12.3b ^)^/^-^3(^12.3b ^)",
	message, mesg_len, ioe, ioe (5), ioe (9));
         call tolts_qttyio_ (message, 10);
         tio = tio + 1;
         call tolts_qttyio_$rs (10, " MME TDIO =  ^b @ ^a", tio, ctime ()); /* notify user of tally of tdio's */
      end;
      call get_px_sct ("TDIO  ", bin (io_entry.sct_add, 17), "1"b); /* get test page index */
      if io_info.io_type = mca_io_type then call mca_io_setup; /* mca is special */
      else call io_setup;				/* go set up our workspace */
      if io_info.suspend_chan then do;			/* if channel to be suspended */
         call ioi_$suspend_devices (io_info.device_index, error); /* let ioi_$ stop other io */
         if error ^= 0 then do;			/* error, abort */
	  call output_status_code (error, "suspend devices error");
	  call tolts_alm_util_$enter_ccc_req_ (addr (tolts_info.ccc_queue),
	   string (io_info.icivlu));			/* enter ccc request */
	  io_info.suspend_chan = "0"b;
	  io_info.io_in_progress = "0"b;		/* reset io in progress flag */
	  if tolts_info.gewake_active then do;		/* if gewake alarm set */
	     call timer_manager_$reset_alarm_wakeup (tolts_info.gewake_event); /* reset it */
	     call ipc_$drain_chn (tolts_info.gewake_event, error); /* make sure no alarms queue up */
	     tolts_info.gewake_active = "0"b;		/* reset flag */
	  end;

	  call tolts_abort ("$b5");
         end;
         io_info.chan_suspended = "1"b;			/* remember that channel suspended */
      end;
      if io_info.io_type = mca_io_type then do;
         if io_entry.prim.dev_cmd = "40"b3 then		/* if reset dcw */
	  call mca_$reset (io_info.mca_ioi_idx, "0"b, error);
         else if io_entry.prim.dev_cmd = "15"b3 then	/* send mca data */
	  call mca_$tandd_write_data (io_info.mca_ioi_idx,
	   io_info.workspace_ptr, io_block_len, "0"b, error);
         else if io_entry.prim.dev_cmd = "13"b3 then	/* send mca command */
	  call mca_$tandd_write_text (io_info.mca_ioi_idx,
	   io_info.workspace_ptr, io_block_len, "0"b, error);
         else if io_entry.prim.dev_cmd = "03"b3 then	/* every write must be followed by a read */
	  call mca_$tandd_read_data (io_info.mca_ioi_idx,
	   io_info.workspace_ptr, io_block_len, "0"b, error);
         else error = error_table_$bad_command_name;
      end;
      else call ioi_$connect_pcw (io_info.device_index, tio_off, pcwa, error);
      if error ^= 0 then do;
         call output_status_code (error, "doing io for a tdio");
         call tolts_alm_util_$enter_ccc_req_ (addr (tolts_info.ccc_queue),
	string (io_info.icivlu));			/* enter ccc request */
         io_info.io_in_progress = "0"b;			/* reset io in progress flag */
         if tolts_info.gewake_active then do;		/* if gewake alarm set */
	  call timer_manager_$reset_alarm_wakeup (tolts_info.gewake_event); /* reset it */
	  call ipc_$drain_chn (tolts_info.gewake_event, error); /* make sure no alarms queue up */
	  tolts_info.gewake_active = "0"b;		/* reset flag */
         end;

         call tolts_abort ("$b5");
      end;
      call tolts_init_$gc_tod (spa.regs.a);		/* get current time of day */
      io_info.con_time = bin (spa.regs.a, 35);		/* save connect time */
      spa.regs.q = bit (bin (io_info.lostit_time, 36));	/* set lostit time */
      spa.regs.x (4) = bit (bin (io_sel * 4, 18));	/* return test page index, mod 4 */
      tolts_info.glob_int_cnt = tolts_info.glob_int_cnt + 1;/* increment global IO count */
      call return_plus (5);				/* return ic + 5 */
%page;
/* ********* MME TERMIN ********* (terminate slave executive)

   input registers: none

   mme     termin
   does not return */

mme_typ (-35): if trace then call tolts_qttyio_$rs (10, "^a MME TERMIN @ ^p", ctime (), mmep);
      term = "1"b;					/* set terminate condition */
      go to term_lbl;				/* and perform nonlocal goto */

/* ********* MME TNDBUG ********* (tolts debugger break point))

   input/return registers: none

   mme     tndbug

   restores mme word with original value and returns to mme location */

mme_typ (-88):
      if ^debugging then call return_plus (1);
      call probe (mtdsim_);
      exec_wd (db_addr) = db_sv_wd;
      tolts_info.mult_ans = "";			/* clear out response */
      call tolts_qttyio_$rs (19, "tolts_debugger: enter break point address");
      call message_wait;				/* wait for user response */
      if mult_ans ^= "" then do;
         db_addr = cv_oct_check_ ((rtrim (mult_ans)), code);
         db_sv_wd = exec_wd (db_addr);
         exec_wd (db_addr) = "777650001000"b3;
      end;
      call return_plus (0);				/* return ic + 0 */

/* ********* MME TOLDIS ********* (disconnect logical terminal ID (LID))

   input/return registers: none

   mme     toldis
   ------  return tolts aborted
   ------  return tolts swapped
   ------  return */

mme_typ (-37): if trace then call tolts_qttyio_$rs (10, "^a MME TOLDIS @ ^p", ctime (), mmep);
      call return_plus (3);				/* return ic + 3 */


/* ********* MME TOLGON ********* (used in gecos to inform tolts is terminating)
   mme	   tolgon
   -----   return   */

mme_typ (-38): if trace then call tolts_qttyio_$rs (10, "^a MME TOLGON @ ^p", ctime (), mmep);
      call return_plus (1);


/* ********* MME TOLTIN ********* (slave executive idle dispatcher)

   input registers:   q-reg = time in 1/64 ms for wakeup

   mme     toltin
   ------  return not in core
   ------  return in core   (does mme gewake if in core)

   return registers: none */

mme_typ (-39): if trace then call tolts_qttyio_$rs (10, "^a MME TOLTIN @ ^p", ctime (), mmep);

      wake_time = divide (fixed (spa.regs.q) * 1000, 64, 71, 0); /* convert gcos time to useconds */
      call timer_manager_$alarm_wakeup (wake_time, "10"b, tolts_info.gewake_event); /* set the alarm  */
      tolts_info.gewake_active = "1"b;			/* set flag for int processor */
      spa.enter.icivlu.ic = rel (addr (mme_call_w (2)));	/* increment ic by 2 */
      go to blk_lbl;				/* return to blocked state */
%page;
/* ********* MME TRACIO ********* (trace I/O events (GCOS only, Unused in Multics))

   input/output registers: none

   mme     tracio
   iotd    msg,wordcount
   ------  return */

mme_typ (-40): if trace then call tolts_qttyio_$rs (10, "^a MME TRACIO @ ^p", ctime (), mmep);
      call return_plus (2);				/* return ic + 2 */

/* ********* MME UNFREZ ********* (unwire  main memory (gcos only))

   input/return registers:   none

   mme     unfrez
   ------  return */

mme_typ (-54): if trace then call tolts_qttyio_$rs (10, "^a MME UNFREZ @ ^p", ctime (), mmep);
      call return_plus (1);

/* ********* MME WRDUMP ********* (wrapup dump)

   input registers:	areg = iotd for dump prefix
   *		qreg = start,size (relative to LAL)
   *		x1 = address bias (-1024 or page base)
   *		x2 = master/slave (=3hm  ,=3hs  )

   mme     wrdump
   ------  return

   return registers: none */

mme_typ (-42): if trace then call tolts_qttyio_$rs (10, "^a MME WRDUMP @ ^p", ctime (), mmep);
      if tolts_info.file_attach then do;		/* if print file attached... */
         call tolts_file_util_$wdump (addr (spa.regs));	/* go output entire dump */
         call tolts_file_util_$close;
      end;
      else call tolts_qttyio_$rcw (addr (spa.regs.a));	/* otherwise just output dump prefix */
      call return_plus (1);				/* return ic + 1 */
%page;
mme_typ (-60): mme_typ (-58): mme_typ (-57):
mme_typ (-49): mme_typ (-48): mme_typ (-47): mme_typ (-46): mme_typ (-45):
mme_typ (-44): mme_typ (-43): mme_typ (-41): mme_typ (-27): mme_typ (-23): mme_typ (-10):
mme_typ (-25): mme_typ (-15): mme_typ (-14):
mme_typ (-3): mme_typ (0): mme_typ (3): mme_typ (4): mme_typ (6): mme_typ (7):
mme_typ (8): mme_typ (10): mme_typ (11): mme_typ (12): mme_typ (13): mme_typ (16):
mme_typ (19): mme_typ (20): mme_typ (22): mme_typ (23): mme_typ (25):
mme_typ (26): mme_typ (27): mme_typ (28): mme_typ (29):
undefm:

      in_ccc = "0"b;
      call tolts_qttyio_$rs (0, "^as: Improper MME @ ^p; MME type - ^d; Instruction - ^12.3b",
       exec, mmep, mme_call_hf (0).upper, mme_call_w (0));
      call tolts_abort ("$b6");

/* epilogue - entry called by execute_epilogue_ when process is terminated */

epilogue: entry;

      if tolts_active then do;			/* continue only if we were active */
         tolts_info.finish_cond = "1"b;			/* set finish flag */
         call hcs_$get_ips_mask (old_mask);		/* get current ips mask */
         new_mask = old_mask | sys_info$alrm_mask;	/* make sure "alrm"s are enabled */
         call hcs_$set_ips_mask (new_mask, new_mask);	/* set the mask */
         call clean_up;				/* go cleanup our enviornment */
         call hcs_$set_ips_mask (old_mask, old_mask);	/* set original ips mask */
      end;
      return;
%page;

/* return_plus - int procedure to add specified value to ic, wakeup dispatcher and take non-local goto to block */

return_plus: proc (ic_inc);

dcl  ic_inc fixed bin;				/* value to increment ic by */

      spa.enter.icivlu.ic = rel (addr (mme_call_w (ic_inc))); /* increment ic */

/* wake_disp - entry to do non-local goto to dispatcher. If there is any oustanding IO,
   the wait event channel is woken up and we do non-local goto to the dispatcher block label.
   If there is no outstanding IO (terminal or test IO), we do non-local goto  directly
   back to the no_blk label, thus saving needless wakeyps and blocks */

wake_disp: entry;

      if (tolts_info.term_io_req_cnt = 0 & tolts_info.glob_int_cnt = 0 /* if there is nothing to wait for... */
       & ^tolts_info.exec_term_io_wait & ^colts_op_flags.colt_flag) then /* go back to slave exec, don't go blocked */
         go to no_blk;				/* do non-local goto */

      call hcs_$wakeup (tolts_info.process, tolts_info.wait_list.wait_event_id (1), null, error);
      if error ^= 0 then do;				/* this is a fatal error, terminate our process */
         call com_err_ (error, exec, "***fatal error, terminating process"); /* but tell user first */
         fatal_desc.version = 0;
         fatal_desc.fatal_code = error;
         if ^debugging then
	  call terminate_process_ ("fatal_error", addr (fatal_desc));
         else signal tolts_error_;
      end;					/* no need to return, as we won't be back */
      go to blk_lbl;				/* take non-local goto to dispatcher block */

   end return_plus;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
/*											*/
/* fault_dump - internal procedure to force open a file for tolts abort				*/
/*											*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

fault_dump: proc;
      flt_flag = "1"b;
      if ^tolts_info.file_attach then
         call tolts_file_util_$open (error);
      if error ^= 0 then do;
         call com_err_ (error, exec, "encountered an error while attempting to open a point file for ^a", error);
         call tolts_abort ("$t1");
      end;
      if debugging then call probe (mtdsim_);
      if tolts_info.file_attach then do;
         call display_mc;
         call tolts_file_util_$wdump (execp);		/* go output entire dump */
         call tolts_file_util_$close;

         in_ccc = "0"b;
         call tolts_abort ("$t2");
      end;
   end fault_dump;



/* tolts_abort - internal procedure to set up abort vectors for the slave exec */

tolts_abort: proc (a_code);

dcl  a_code char (3);
dcl  tfc bit (18);

      call tolts_alm_util_$ascii_to_bcd_ (a_code, tfc);	/* convert fault code to bcd */
      spa.abort.code = tfc;				/* and store in spa */
      spa.abort.add = scu.ilc;			/* equals address of last mme */
      if spa.wrapup_add = "0"b			/* if we have not been thru mme pointit yet.. */
       | flt_flag then do;				/* or we have detected a fault */
         call clean_up;
         term = "1"b;				/* set terminate condition */
         go to term_lbl;				/* take non-local goto to get out of dispatcher */
      end;
      spa.enter.icivlu.ic = spa.wrapup_add;		/* set wrapup address */
      call wake_disp;				/* and wake up dispatcher */

   end tolts_abort;

/* display_mc - int proc to display machine conditions after a fault */

display_mc: proc;

dcl  cu_$stack_frame_ptr entry (ptr);
dcl  dump_machine_cond_ entry (ptr, ptr, char (32) aligned, fixed bin);
dcl  find_condition_frame_ entry (ptr) returns (ptr);
dcl  find_condition_info_ entry (ptr, ptr, fixed bin (35));
dcl  hran_$hranl entry (ptr, ptr, bit (1));
dcl  ioa_ entry () options (variable);
dcl  ioa_$ioa_switch entry () options (variable);
dcl  (faultsp, hreg_ptr, stackp) ptr;
dcl  code fixed bin (35);


      call cu_$stack_frame_ptr (stackp);		/* get current sstack ptr */
      faultsp = find_condition_frame_ (stackp);		/* is this the cond frame ? */
      if faultsp = null () then do;
         call ioa_ ("^a: Cannot find condition frame.", "exec_name");
         return;
      end;

      call find_condition_info_ (faultsp, addr (ci), code);
      if ci.mc_ptr = null () then do;
         call ioa_ ("^a: Cannot find condition frame.", "exec_name");
         return;
      end;


      call ioa_$ioa_switch (tolts_info.pf_iocbp, "^/MACHINE CONDITIONS AT ^p:^/", ci.mc_ptr);
      call dump_machine_cond_ (addr (ci), faultsp, "err_file", 2); /* print the MC */

HREGS:
      if mcptr ^= null then hreg_ptr = addrel (mcptr, 96);
      if hreg_ptr = null then do;			/* no history regs to dump */
         call ioa_$ioa_switch (tolts_info.pf_iocbp, "History Registers are not available");
         return;
      end;
      else do;
         call ioa_$ioa_switch (tolts_info.pf_iocbp, "CPU HISTORY REGISTERS AT TIME OF FAULT");
         call hran_$hranl (hreg_ptr, tolts_info.pf_iocbp, "0"b);
      end;

      return;
   end display_mc;


%page;

/* set_sctwrk - internal procedure to set up the sct work area sctwrk */

set_sctwrk: proc (px);

dcl  px fixed bin;					/*  test page index */

/*
   output in sctwrk (12 words):

   18/devsct,6/0,12/xbicc
   18/altsct,6/g3typ,12/0
   18/cntsct,4/iotyp,4/cnttyp,1/pad,4/xiotyp,4/xcnttyp,1/pad
   18/cont. sct,18/mpc index (36/0 for non mpc)
   36/word +0 of .crcst entry for mpc
   36/word +1 of .crcst entry for mpc
   36/word +2 of .crcst entry for mpc
   36/word +3 of .crcst entry for mpc
   36/word +0 of sct entry
   36/word +1 of sct entry
   36/word +0 of alt sct
   36/word +1 of alt sct
*/
      genp = addrel (execp, mme_call_hf (2).upper);	/* get pointer to sctwrk */
      spa.regs.x (2), sctwrk = "0"b;			/* initialize sctwrk first */
      t_err = 0;
      call tolts_device_info_ (addrel (execp, mme_call_hf (1).upper), px, t_err); /* get type code */
      spa.regs.x (2) = bit (bin (t_err, 18));		/* set x2 to type_error if any */
      substr (sctwrk (2), 19, 6) = pages (px).devsct.type_code; /* set type code */
      if ^pages (px).devsct.com_prph then do;		/* if mpc subsystem */
         pages (px).sct_info.cntsct = bit (bin (px * 4 + 1024, 18)); /* set cont. sct (device sct + 1024) */
         sctwrk (3) = unspec (pages (px).sct_info);	/* fill word 3 of sct area */
         substr (sctwrk (4), 1, 18) = bit (bin (px * 4 + 1024, 18)); /* set cont. sct */
      end;
      sctwrk (5) = unspec (pages (px).crcst);		/* set crcst entry wrd 0 */
      sctwrk (6) = unspec (pages (px).crcst);		/* set crcst entry wrd 1 */
      sctwrk (9) = unspec (pages (px).devsct.w1);		/* set dev sct word 1 */
      sctwrk (10) = unspec (pages (px).devsct.w2);	/* and word 2 */
      substr (sctwrk (1), 1, 18) = bit (bin (px * 4, 18));	/* set test page index (mod 4) */

/*   The sct pointer and sct data for the alternate device must be passed back to cmlt, provided mtar is running   */

      if (pages (px).alt_dev_flag) then do;		/* alt. device exists return device info */
         sctwrk (11) = unspec (pages (px).altsct.w1);
         sctwrk (12) = unspec (pages (px).altsct.w2);
         substr (sctwrk (2), 1, 18) = bit (bin (px * 4 + 512, 18));
      end;

   end set_sctwrk;
%page;

/* mca_io_setup - internal procedure to set up the mca workspace for mca I/O */

mca_io_setup: proc;


      dcwp = addrel (execp, dcw_ptr);
      mca_work_space_ptr = io_info.workspace_ptr;		/* get a ptr to our workspace */
      unspec (mca_work_space) = "0"b;			/* clear it */
      c_len = 4;					/* want to xfer 4 words */
      mvp = addrel (execp, dcw_ptr - 1);		/* set move ptr to idcw */
      bufp = addr (mca_work_space.list_of_dcw);		/* set buf ptr to work space dcw list */
      workspace_move = mvp -> workspace_move;		/* move it */
      bufp = addr (io_info.dcw_list);			/* move the buf ptrto save the dcw list in io_info */
      workspace_move = mvp -> workspace_move;		/* move it */
      if dcw.tally = "0"b3 then c_len = 4096;		/* check for 4096 tally */
      else c_len = bin (dcw.tally);			/* else use as is */
      io_block_len = c_len + 4096 + 2;			/* set io block length to reflect the tally */
      mvp = addrel (execp, dcw.address);		/* set move ptr to data to be sent */
      bufp = addr (mca_work_space.data_header_1);		/* set buf ptr to data header area */
      workspace_move = mvp -> workspace_move;		/* move it */
      data_size_1 = fixed (data_header_1.dest_len_msb || data_header_1.dest_len_lsb, 16);
      io_info.icivlu.ic = io_entry.ccc_p;		/* set entry to call on io completion */
      io_info.icivlu.ind = "0"b;			/* initialize indicators */
      io_info.status_add = fixed (io_entry.stat_p);	/* save status storage ptr */
      exec_wd (io_info.status_add) = "0"b;		/* initialize test page status */
      exec_wd (io_info.status_add + 1) = "0"b;
      io_info.pcwa = pcwa;				/* save pcw */
      io_info.tio_off = 0;				/* save dcw list offset */
      io_info.rew_wait = "0"b;			/* not expecting special interrupt */
      io_info.io_in_progress = "1"b;			/* set flag for interrupt processing */
      io_info.num_connects = io_info.num_connects + 1;
      io_info.int_time = 0;				/* clear out interrupt time */

   end mca_io_setup;





/* io_setup - internal procedure to set up the ioi workspace for test I/O */

io_setup: proc;

dcl  (continue, first, idcw_io) bit (1);
dcl  (cbuf_add, lstloc, nxtloc) fixed bin;
dcl  dcwb fixed bin (18) uns;

      ioi_wksp = io_info.workspace_ptr;			/* get a ptr to our workspace */
      continue = "0"b;				/* reset continue flag */
      unspec (wks_init) = "0"b;			/* initialize workspace to zero */
      tolts_workspace.l_pad.e = "525252525252"b3;		/* set up our lower buffer pad */
      tolts_workspace.l_pad.o = "525252525252"b3;
      tio_off = fixed (rel (addr (tolts_workspace.p_idcw)));/* set default dcw list offset for ioi */
      idcwp = addr (tolts_workspace.p_idcw);		/* set up idcw ptr */
      idcw.code = "7"b3;				/* set in idcw type code */
      if io_entry.prim.io_cmd = "40"b3			/* if idcw I/O */
       | io_entry.prim.io_cmd = "24"b3
       & io_info.io_type = mhp_io_type then do;		/* | idcw I/O & hyper */
         idcw_io = "1"b;				/* set flag for idcw io */
         idcw.command = io_entry.prim.dev_cmd;		/* set up first idcw from io entry word 4 */
         if (idcw.command = "31"b3 & io_info.chan_suspended)/* if diagnostic mode control... */
	| io_entry.prim.dev ^= "00"b3 then		/* or punch indicator */
	  idcw.chan_cmd = "00"b3;			/* set data xfer chan command */
         else if io_entry.prim.io_cmd = "24"b3		/* if cmd = 24 */
	& io_info.io_type = mhp_io_type then		/* & hyper io */
	  idcw.chan_cmd = "00"b3;			/* set data xfer chan command */
         else if io_info.io_type = mtar_io_type then	/* if mtar  */
	  idcw.chan_cmd = "00"b3;			/* set data xfer chan command */
         else idcw.chan_cmd = "40"b3;			/* otherwise set special cont. cmd */
         idcw.count = io_entry.prim.record_count;		/* set record count */
         if idcw.count ^= "00"b3 & idcw.count ^= "01"b3 then do; /* if not single idcw */
	  idcw.control = "10"b;			/* set idcw continue bit */
	  continue = "1"b;				/* set continue flag */
         end;
         if idcw.command = "00"b3 then			/* if suspend command */
	  io_info.suspend_chan = "1"b;		/* set flag for mme tdio */
         if idcw.command = "20"b3 then			/* if release command */
	  io_info.release_chan = "1"b;		/* set flag for tolts_io_int_ */
      end;					/* note that device code is = 0 */
      else do;					/* not idcw I/O, single or dual I/O */
         idcw_io = "0"b;
         idcw.command = io_entry.second.dev_cmd;		/* get idcw from word 7 (same for single or dual I/O */
         idcw.chan_cmd = io_entry.second.io_cmd;
         idcw.count = io_entry.second.record_count;
         if io_info.io_type = itr_io_type		/* insure that release_chan is reset */
	then io_info.suspend_chan = "0"b;		/* in the event no special was returned */
         if io_entry.prim.dev_cmd ^= io_entry.second.dev_cmd then do; /* disk/dual I/O */
	  idcwp = addr (tolts_workspace.seek_idcw);	/* set up seek idcw */
	  idcw.command = io_entry.prim.dev_cmd;		/* set device command */
	  if bin (io_entry.sct_add, 13) >= 512
	   then idcw.device = io_info.altsct.device_no;
	  else idcw.device = io_info.devsct.device_no;
	  idcw.code = "7"b3;
	  idcw.control = "10"b;			/* set continue bit in idcw */
	  idcw.chan_cmd = io_entry.prim.io_cmd;
	  idcw.count = io_entry.prim.record_count;
	  dcwp = addr (tolts_workspace.seek_dcw);	/* set ptr to seek dcw */
	  string (dcw) = "0"b;			/* initialize */
	  dcw.address = rel (addr (tolts_workspace.seek_add)); /* set dcw address */
	  dcw.tally = "0001"b3;			/* set tally of one */
	  i = fixed (rel (addrel (execp, first_dcw.address))); /* compute index to seek add */
	  tolts_workspace.seek_add = exec_wd (i);	/* move seek address to workspace */
	  tio_off = fixed (rel (addr (tolts_workspace.seek_idcw))); /* set dcw list offset to seek idcw */
         end;
      end;

/* process dcw list */

      idcwp = addr (tolts_workspace.p_idcw);		/* set primary idcw ptr */

      if ^mpc_io then				/* if not controller io */
         if bin (io_entry.sct_add, 13) >= 512
	then idcw.device = io_info.altsct.device_no;
         else idcw.device = io_info.devsct.device_no;
      dcwp = addrel (execp, io_entry.dcw_ptr);		/* set dcw ptr to first dcw */
      if string (dcw) = "0"b then do;			/* if non data command */
         tolts_workspace.buf_size, c_len = 1;		/* set buffer size to 1 word */
         dcwp = addr (tolts_workspace.dcw_list (1));	/* set up iotd that should not be used */
         string (dcw) = "0"b;				/* initialize dcw */
         dcw.address = rel (addr (tolts_workspace.data_buf));
         dcw.tally = "0001"b3;			/* 1 word iotd */
         if continue then				/* if idcw continue bit set */
	  idcw.control = "00"b;			/* reset it now */
         go to non_data;				/* bypass dcw processing */
      end;
      io_info.page_base = bin (dcw.address);		/* set first dcw address as data buf base */
      first, found = "0"b;				/* reset terminate condition */
      unspec (io_info.dcw_list) = "0"b;			/* clear out saved dcw list */
      lstloc, nxtloc, j = 1;				/* set initial dcw copy index */
      bufp = addr (tolts_workspace.data_buf (1));		/* set intial buffer ptr */
      do i = 1 to hbound (tolts_workspace.dcw_list, 1) while (^found); /* go through dcw list */
         tolts_workspace.dcw_list (j) = string (dcw);	/* copy dcws (and idcws) to work space */
         io_info.dcw_list (j) = string (dcw);		/* and for interrupt processor */
         if dcw.char_pos = "7"b3 then do;		/* if idcw */
	  idcwp = addr (tolts_workspace.dcw_list (j));	/* set idcw ptr */
	  if idcw.control = "10"b then		/* if idcw continue bit set */
	     continue = "1"b;			/* set continue flag */
	  else continue = "0"b;			/* otherwise reset it */

	  if ^mpc_io then				/* if not controller io */
	     if bin (io_entry.sct_add, 13) >= 512
	      then idcw.device = io_info.altsct.device_no;/* set device code */
	     else idcw.device = io_info.devsct.device_no;
	  j = j + 1;				/* increment copy dcw index */
         end;
         else if dcw.type = "10"b then			/* if tdcw */
	  dcwp = addrel (execp, bin (dcw.address) - 1);	/* set dcwp to list -1 */
         else do;					/* data dcws */
	  if ^first then do;			/* if the first time through */
	     first = "1"b;				/* set flag, so we don't come back */
	     dcwb = bin (dcw.address);		/* set dcw base address */
	  end;
	  mvp = addrel (execp, dcw.address);		/* get ptr to data to move */
	  c_len = bin (dcw.tally);			/* get length of data */
	  if string (dcw) = "0"b then do;		/* if illegal zero dcw */
	     c_len = 1;				/* set length = 1 */
	     dcw.address = io_entry.stat_p;		/* set address to status word */
	     call tolts_qttyio_$rs			/* tell user */
	      (0, "Tolts: Last io_entry contains an illegal dcw. Please investigate");
	  end;
	  if c_len = 0 then c_len = 4096;		/* allow for a dcw tally of 4096 */
	  cbuf_add = bin (dcw.address) - dcwb;		/* compute relative address */
	  if cbuf_add = 0 then			/* if this dcw address is the same last */
	     cbuf_add = lstloc;			/* set the same index */
	  else cbuf_add = nxtloc;			/* otherwise use next avail address */
	  tolts_workspace.buf_size = cbuf_add;
	  bufp = addr (tolts_workspace.data_buf (cbuf_add)); /* set buffer ptr */
	  workspace_move = mvp -> workspace_move;	/* and move it */
	  mvp = addr (tolts_workspace.dcw_list (j));	/* set ptr to workspace dcw */
	  mvp -> dcw.address = rel (bufp);		/* set relative address */
	  lstloc = bin (mvp -> dcw.address) - bin (rel (addr (tolts_workspace.data_buf (1)))) + 1;
	  nxtloc = lstloc + c_len;			/* set next available location */
	  dcwb = bin (dcw.address);			/* set up to look at nxt dcw */
	  if idcw_io then do;			/* if running mdrs */
	     bufp = addrel (bufp, c_len);		/* set nxt buffer address for idcw io */
	     c_len = 0;				/* reset current length */
	  end;
	  j = j + 1;				/* increment copy dcw index */
	  if dcw.type = "00"b then			/* if iotd */
	     if ^continue then			/* and continue flag not set */
	        found = "1"b;			/* set terminate condition */
         end;
         dcwp = addrel (dcwp, 1);			/* increment dcw ptr to next one */
      end;
      tolts_workspace.buf_size = (bin (rel (bufp)) + c_len) - bin (rel (addr (tolts_workspace.data_buf (1))));
non_data:
      tolts_workspace.h_pad.e = "252525252525"b3;		/* set upper buffer pad */
      tolts_workspace.h_pad.o = "252525252525"b3;
      if io_info.devsct.com_prph then do;		/* if common prph channel */
         pcwa = tolts_workspace.p_idcw;			/* pick up first idcw */
         tio_off = fixed (rel (addr (tolts_workspace.dcw_list (1)))); /* can't execute idcw on com prph */
      end;
      else pcwa = "000000700000"b3;			/* otherwise set phony pcw for ioi */
      if substr (mme_call_w (4), 1, 1) = "1"b then do;	/* if user wants dcws traced */
         io_info.io_trc_flag = "1"b;			/* set io trace flag */
         call ioa_$rsnnl ("^/  ^/*** i/o trace ***^/", message, mesg_len);
         if io_entry.prim.dev_cmd ^= io_entry.second.dev_cmd & ^idcw_io then /* if disk io */
	  call ioa_$rsnnl ("^a^/seek idcw: - ^12.3b, seek dcw: - ^12.3b, seek address: - ^12.3b",
	   message, mesg_len, message, tolts_workspace.seek_idcw,
	   tolts_workspace.seek_dcw, tolts_workspace.seek_add);
         call ioa_$rsnnl ("^a^/^[pcw^;idcw^]: - ^12.3b^/dcw list:^/",
	message, mesg_len, message, io_info.devsct.com_prph, tolts_workspace.p_idcw);
         do i = 1 by 4 while (tolts_workspace.dcw_list (i) ^= "0"b); /* put out only valid dcws */
	  call ioa_$rsnnl ("^12.3b ", lginfo, mesg_len, tolts_workspace.dcw_list (i));
	  do j = 1 to 3 while (tolts_workspace.dcw_list (i + j) ^= "0"b); /* 4 wds per line */
	     call ioa_$rsnnl ("^a ^12.3b ", lginfo, mesg_len, lginfo, tolts_workspace.dcw_list (i + j));
	  end;
	  call ioa_$rsnnl ("^a^/", lginfo, mesg_len, lginfo);
	  message = rtrim (message) || lginfo;		/* add line to message */
         end;
         call tolts_qttyio_ (message, 10);
      end;
      else io_info.io_trc_flag = "0"b;			/* reset trace flag */
      io_info.ext_status_add = io_entry.ext_sts;		/* copy extended status store address */
      io_info.ignore_term = io_entry.second.ignore_term;	/* copy ignore term flag */
      io_info.icivlu.ic = io_entry.ccc_p;		/* set entry to call on io completion */
      io_info.icivlu.ind = "0"b;			/* initialize indicators */
      io_info.status_add = fixed (io_entry.stat_p);	/* save status storage ptr */
      exec_wd (io_info.status_add) = "0"b;		/* initialize test page status */
      exec_wd (io_info.status_add + 1) = "0"b;
      io_info.pcwa = pcwa;				/* save pcw */
      io_info.tio_off = tio_off;			/* save dcw list offset */
      io_info.rew_wait = "0"b;			/* not expecting special interrupt */
      io_info.io_in_progress = "1"b;			/* set flag for interrupt processing */
      io_info.num_connects = io_info.num_connects + 1;
      io_info.int_time = 0;				/* clear out interrupt time */

   end io_setup;
%page;
/* get_px_sct - subroutine to get the correct test page index, given entry index */
/* the globol variables io_sel, mpc_io and io_info_ptr are set up by this subroutine */

get_px_sct: proc (mname, px, ck_alloc);

dcl  mname char (6);
dcl  px fixed bin;
dcl  ck_alloc bit (1);

      if px >= 1024 then do;				/* ck for controller sct */
         mpc_io = "1"b;				/* set flag if controller sct */
         io_sel = px - 1024;				/* get device sct */
      end;
      else if px >= 512 then do;			/* check for alt. device sct */
         mpc_io = "0"b;
         io_sel = px - 512;				/* get primary device sct */
      end;
      else do;					/* not controller sct, it is device sct */
         mpc_io = "0"b;				/* reset controller io flag */
         io_sel = px;				/* test page index is correct as is */
      end;
      io_sel = divide (io_sel, 4, 17, 0);		/* Multics scts are mod 4 */
      if io_sel < 1 | io_sel > 8 | ^pages (io_sel).in_use |
       (ck_alloc & ^pages (io_sel).allocated) then do;	/* if error in sct */
         call tolts_qttyio_$rs (0, "^as: MME ^a; Invalid SCT - ^6.3b",
	exec, mname, bit (bin (px, 18)));
         call tolts_abort ("$a2");
      end;
      io_info_ptr = addr (pages (io_sel));		/* get ptr to this test page */

   end get_px_sct;

/* get_px_tcx - subroutine to get the correct page index, given the true channel index (ICC) */
/* the global variables io_sel and io_info_ptr are set up by this subroutine */

get_px_tcx: proc (mname, tci);

dcl  mname char (6);
dcl  tci bit (11);

      do io_sel = 1 to (hbound (pages, 1))
       while (tci ^= pages (io_sel).devsct.icc);		/* find correct page */
      end;
      if io_sel > (hbound (pages, 1)) then do;		/* no matching page */
         call tolts_qttyio_$rs (0, "^as: MME ^a; no matching page found for true chan. index - ^3.3b",
	exec, mname, tci);
         call tolts_abort ("$m1");
      end;
      else io_info_ptr = addr (pages (io_sel));		/* get ptr to this test page */

   end get_px_tcx;
%page;

/* output_status_code - internal procedure to queue up a status message */

output_status_code: proc (ecode, mess);

dcl  ecode fixed bin (35);
dcl  mess char (*);

      call convert_status_code_ (ecode, shortinfo, lginfo);
      call tolts_qttyio_$rs (0, "^as: ^a^/^a", tolts_info.exec, lginfo, mess);
   end output_status_code;

dealcp_sub: proc;

      dealc_err = 0;
      if io_info.p_att | io_info.alloc_wait then do;	/* if perp. device attached to this page */
         call ck_release;				/* go check mpc stae */
         if io_info.io_type = mca_io_type then do;
	  if io_info.ipc_attached then do;
	     call tolts_qttyio_$rs (0, "^a IPC ^a not reloaded.^/^a^/", io_info.test_hdr, io_info.ipc_number,
	      "Do you wish to quit leaving IPC unloaded?");
ask_again:     call tolts_qttyio_$rs (19, "Please answer yes or no. - ");
	     call message_wait;			/* wait for users answer */
	     if tolts_info.mult_ans = "yes"
	      | tolts_info.mult_ans = "y" then do;
	        io_info.suspend_chan = "1"b;
	        opr_query_info.q_sw = "0"b;
	        call ioa_$rsnnl ("^/^a Unrecoverable error running ipc ^a firmware.^/^-^a",
	         message, i, io_info.test_hdr, io_info.ipc_number,
	         "IPC will not be reloaded");
	        call opr_query_ (addr (opr_query_info),
	         substr (message, 1, i));		/* tell opr bad news */
	     end;
	     else if mult_ans = "no"
	      | mult_ans = "n" then do;
	        io_info.io_in_progress = "1"b;		/* set flag for interrupt processing */
	        io_info.num_connects = io_info.num_connects + 1;
	        call mca_$load_ipc (io_info.mca_ioi_idx, io_info.ipc_number,
	         "0"b, code);
	     end;
	     else goto ask_again;

	     call mca_$detach_ipc ((io_info.ipc_id), io_info.mca_ioi_idx,
	      ^io_info.suspend_chan, code);
	     io_info.ipc_attached = "0"b;
	  end;
	  if io_info.mca_attach_state ^= MCA_NOT_CONFIGURED then do;
	     io_info.io_in_progress = "1"b;		/* set flag for interrupt processing */
	     io_info.num_connects = io_info.num_connects + 1;
	     call mca_$reset (io_info.mca_ioi_idx, "0"b, code);
	     io_info.io_in_progress = "1"b;		/* set flag for interrupt processing */
	     io_info.num_connects = io_info.num_connects + 1;
	     call mca_$detach_mca (io_info.mca_ioi_idx, code);
	  end;
         end;
         else call rcp_$detach (io_info.rcp_id, "0"b, 0, "T&D is detaching " || io_info.device_name, error);
         if error ^= 0 then do;			/* error detaching device */
	  dealc_err = 1;
	  call output_status_code (error, "unassign error");
         end;
      end;

/* This code will detach the alternate device for mtar (or anyother program). The alternate device attached
   flag (io_info.p2_att) is checked to see if an alternate device is attached. If so it is detached.   */

      if io_info.p2_att then do;			/* detach alternate device if attached */
         call rcp_$detach (io_info.alt_rcp_id, "0"b, 0, "t&d is detaching " || io_info.alt_device_name, error);
         if error ^= 0 then do;			/* handle detach error */
	  dealc_err = 1;
	  call output_status_code (error, "unassign  error");
         end;
      end;
      if io_info.ev_ch_ass then do;			/* if status event channel assigned to this page */
         call ipc_$delete_ev_chn (io_info.status_event, error);
         if error ^= 0 then do;			/* error deleting event channel */
	  dealc_err = 1;
	  call output_status_code (error, " deleting test io event channel ");
         end;
      end;
      unspec (io_info) = "0"b;			/* clear the test page data */
      tolts_info.exec_page_count = tolts_info.exec_page_count - 1; /* decrement total test page count */
   end dealcp_sub;

/*  rel_exec_chan - internal procedure to release the colts exec channel */

rel_exec_chan: proc (k);

dcl  k fixed bin (6);
      dmap = addr (tolts_info.fnp (k).dm_arg);		/* get addr of dial_manager arg	*/
      fnp (k).dm_arg.version = dial_manager_arg_version_2;
      fnp (k).dm_arg.dial_qualifier = substr (fnp (k).exec_chan, 1, 22);
      tolts_info.fnp (k).dm_arg.dial_channel = tolts_info.dm_event; /* set dial_channel to event channel */
      tolts_info.fnp (k).dm_arg.channel_name = fnp (k).exec_chan; /* get channel name	*/

      call dial_manager_$release_channel (dmap, code);
      if code ^= 0 then do;
         if debugging then call com_err_ (code, "mtdsim_", "Error releasing ^a.", dmap -> dial_manager_arg.channel_name);
         call convert_status_code_ (code, shortinfo, lginfo);
         call tolts_qttyio_$rs (0, "^as: ^a/ error doing exec channel release", tolts_info.exec, lginfo);
         call com_err_ (error, exec, "*** fatal error, terminating process"); /* tell users first */
         fatal_desc.version = 0;
         fatal_desc.fatal_code = error;
         if ^debugging
	then call terminate_process_ ("fatal_error", addr (fatal_desc));
         else signal tolts_error_;
      end;					/* no need to return, as we won't be back */
      cltp = fnp (k).fnp_execp;
      call close_sw (cltp);
      tolts_info.fnp (k).exec_active = "0"b;
      return;
   end rel_exec_chan;

/* rel_tst_chan - internal procedure to release the colts test channel */

rel_tst_chan: proc (k);

dcl  k fixed bin (6);

      dmap = addr (tolts_info.colts_pages (k).dm_arg);
      tolts_info.colts_pages (k).dm_arg.version = dial_manager_arg_version_2;
      tolts_info.colts_pages (k).dm_arg.dial_qualifier = substr (colts_pages (k).cdt_name, 1, 22);
      tolts_info.colts_pages (k).dm_arg.dial_channel = tolts_info.dm_event;
      tolts_info.colts_pages (k).dm_arg.channel_name = colts_pages (k).cdt_name;
      call tolts_qttyio_$rs (0, "Do you want to return the channel ^a to service?", tolts_info.colts_pages (k).cdt_name);
reask: call tolts_qttyio_$rs (19, "Please answer yes or no - ");
      call message_wait;
      if tolts_info.mult_ans = "yes" | mult_ans = "y" then
         call dial_manager_$release_channel (dmap, code);
      else if tolts_info.mult_ans = "no" | mult_ans = "n" then
         call dial_manager_$release_channel_no_listen (dmap, code);
      else goto reask;
      if code ^= 0 then do;
         if debugging then call com_err_ (code, "mdtsim_", "Error releasing channel ^a.", dmap -> dial_manager_arg.channel_name);
         call convert_status_code_ (code, shortinfo, lginfo);
         call tolts_qttyio_$rs (0, "^as: ^a/ error doing channel detach", tolts_info.exec, lginfo);
         call com_err_ (error, exec, "*** fatal error, terminating process"); /* tell users first */
         fatal_desc.version = 0;
         fatal_desc.fatal_code = error;
         if debugging
	then call terminate_process_ ("fatal_error", addr (fatal_desc));
         else signal tolts_error_;
      end;					/* no need to return, as we won't be back */
      cltp = colts_pages (k).chanp;
      call close_sw (cltp);
      colts_pages (k).in_use = "0"b;
      tolts_info.exec_page_count = tolts_info.exec_page_count - 1;
      return;
   end rel_tst_chan;

/* close_sw - internal procedure to close and detatch colts io switches */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/



close_sw: proc (cltp);

dcl  cltp ptr;
      call iox_$close (cltp, code);			/* close a switch */
      if code ^= 0 then do;				/* if erroe */
         call convert_status_code_ (code, shortinfo, lginfo); /* convert the status code */
         call tolts_qttyio_$rs (0, "^as: ^a/ doing iox_$close", tolts_info.exec, lginfo); /* and notify the user */
         call com_err_ (error, exec, "*** fatal error, terminating process"); /* tell users first */
         fatal_desc.version = 0;
         fatal_desc.fatal_code = error;
         if ^debugging
	then call terminate_process_ ("fatal_error", addr (fatal_desc));
         else signal tolts_error_;
      end;
      call iox_$detach_iocb (cltp, code);		/* detach the io switch */
      if code ^= 0 then do;				/* if error */
         call convert_status_code_ (code, shortinfo, lginfo); /* convert the error code */
         call tolts_qttyio_$rs (0, "^as: ^a/ doing iox_$detach", tolts_info.exec, lginfo); /* notify the user */
         call com_err_ (error, exec, "*** fatal error, terminating process"); /* tell users first */
         fatal_desc.version = 0;
         fatal_desc.fatal_code = error;
         if ^debugging
	then call terminate_process_ ("fatal_error", addr (fatal_desc));
         else signal tolts_error_;
      end;
      return;
   end close_sw;

/* ctime - internal function to return pl1 time string */

ctime: proc returns (char (16));

dcl  tim char (12);
dcl  ptime char (16);
dcl  plen fixed bin;

      tim = time;					/* get current time */
      call ioa_$rsnnl ("^2a:^2a:^2a.^6a:", ptime, plen, substr (tim, 1, 2), substr (tim, 3, 2),
       substr (tim, 5, 2), substr (tim, 7, 6));
      return (ptime);				/* return time string */

   end ctime;
%page;

/* clean_up - entry to clean_up - our enviornment before returning to tolts command level */

clean_up: entry;

      if exec = "colt" then do;
         do k = 1 to hbound (pages, 1);
	  if colts_pages (k).in_use then call rel_tst_chan (k);
         end;
         do k = 0 to hbound (fnp, 1);
	  if fnp (k).exec_active then call rel_exec_chan (k);
         end;
      end;
      do io_sel = 1 to hbound (pages, 1);		/* deallocate all perp. devices */
         io_info_ptr = addr (pages (io_sel));
         if io_info.in_use then
	  call dealcp_sub;
      end;
      if gicmp ^= null then free gicm;
      if ticmp ^= null then free ticm;
      term = "1"b;					/* set terminate condtion */
      if tolts_info.file_attach then do;		/* if print file attached... */
         call tolts_file_util_$wdump (addr (spa.regs));
         call tolts_file_util_$close;			/* go close it out */
      end;

      if tolts_info.term_io_req_cnt ^= 0 & ^tolts_info.finish_cond /* if we are still doing io */
       & ^q_flag then
         go to blk_lbl;
      call tolts_init_$clean_up;			/* go delete our event channels and our slave segment */
      tolts_active = "0"b;				/* reset active state for epilogue handler */

      return;


/* decode_den - int procedure to decode density info returned from rcp and put into sct entry */

decode_den: proc;

      tape_info_ptr = addr (io_info.rcp_area);		/* set tape info ptr */
      if substr (tape_info.density, 1, 6) = "00"b3 then do; /* rcp returned bad density information */
ask:
         call tolts_qttyio_$rs (0, " ^a RCP returned incorrect device info ^/^a^/", io_info.test_hdr,
	"Please input density capabilities of device to be tested");
         call tolts_qttyio_$rs (19, "Please input densities in the form: 200,556,800,1600,6250 ^-");
         call message_wait;
         if tolts_info.mult_ans = "200,556,800" then
	  io_info.devsct.w2.den_cap = "0001"b;
         else if tolts_info.mult_ans = "200,556,800,1600" then
	  io_info.devsct.w2.den_cap = "0100"b;
         else if tolts_info.mult_ans = "556,800,1600" then
	  io_info.devsct.w2.den_cap = "0101"b;
         else if tolts_info.mult_ans = "556,800" then
	  io_info.devsct.w2.den_cap = "1001"b;
         else if tolts_info.mult_ans = "800,1600" then
	  io_info.devsct.w2.den_cap = "1000"b;
         else if tolts_info.mult_ans = "1600" then
	  io_info.devsct.w2.den_cap = "1100"b;
         else if tolts_info.mult_ans = "1600,6250" then
	  io_info.devsct.w2.den_cap = "1011"b;
         else if tolts_info.mult_ans = "6250" then
	  io_info.devsct.w2.den_cap = "1010"b;
         else do;
	  call tolts_qttyio_$rs (0, "Incorrect reply. ^/ ^a ^/", /* If no match we fall thru */
	   "Do you want to run with default density");
	  call tolts_qttyio_$rs (19, "Please answer yes or no");
	  call message_wait;
	  if tolts_info.mult_ans = "no" | mult_ans = "n" then goto ask; /* ask for density again */
	  else if io_info.crcst.mtp610 then do;
	     io_info.devsct.w2.den_cap = "1100"b;	/* if mtp610 set density to 1600 only */
	     call tolts_qttyio_$rs (0, "Test will be run at 1600bpi ^/");
	  end;
	  else do;
	     io_info.devsct.w2.den_cap = "1000"b;	/* else run at 500/800bpi */
	     call tolts_qttyio_$rs (0, "Test will be run at 500/1600bpi ^/");
	  end;
         end;
      end;
      else if substr (tape_info.density, 1, 6) = "70"b3 then/* 200,556 and 800 bpi */
         io_info.devsct.w2.den_cap = "0001"b;
      else if substr (tape_info.density, 1, 6) = "74"b3 then/* 200,556,800 and 1600 bpi */
         io_info.devsct.w2.den_cap = "0100"b;
      else if substr (tape_info.density, 1, 6) = "30"b3 then/* 556 and 800 bpi */
         io_info.devsct.w2.den_cap = "1001"b;
      else if substr (tape_info.density, 1, 6) = "14"b3 then/* 800 and 1600 bpi */
         io_info.devsct.w2.den_cap = "1000"b;
      else if substr (tape_info.density, 1, 6) = "04"b3 then/* 1600 bpi only */
         io_info.devsct.w2.den_cap = "1100"b;
      else if substr (tape_info.density, 1, 6) = "06"b3 then/* 1600 and 6250 bpi */
         io_info.devsct.w2.den_cap = "1011"b;
      else if substr (tape_info.density, 1, 6) = "02"b3 then/* 6250 bpi only */
         io_info.devsct.w2.den_cap = "1010"b;
      else if substr (tape_info.density, 1, 6) = "34"b3 then/* 556, 800, and 1600bpi */
         io_info.devsct.w2.den_cap = "0101"b;
   end decode_den;

/* pop_isc - subroutine to pop the inter slave read queue and return data to slave exec */

pop_isc: proc (s_add, d_add);

dcl  (s_add, d_add) fixed bin;

      exec_wd (s_add) = "400000000000"b3;		/* set status to complete */
      exec_wd (d_add) = tolts_info.exec_dta (1).word (1);	/* move isc data from queue */
      exec_wd (d_add + 1) = tolts_info.exec_dta (1).word (2);
      exec_wd (d_add + 2) = tolts_info.exec_dta (1).word (3);
      tolts_info.exec_dta_cnt = tolts_info.exec_dta_cnt - 1;/* decrement count */
      do i = 1 to tolts_info.exec_dta_cnt;
         tolts_info.exec_dta (i) = tolts_info.exec_dta (i + 1); /* move queue down */
      end;

   end pop_isc;
%page;
/* ck_release - subroutine to check to see if mpc firmware has been destoryed and reload it */

ck_release: proc;

      if io_info.io_in_progress then do;		/* if some io outstanding */
         call timer_manager_$reset_alarm_wakeup (tolts_info.gewake_event); /* Be sure no alarm already set */
         call ipc_$drain_chn (tolts_info.gewake_event, error); /* In case event occured */
         call timer_manager_$alarm_wakeup (10, "11"b, tolts_info.gewake_event); /* Set 10 second timer */
         tolts_info.gewake_active = "1"b;		/* set flag */
         do while (tolts_info.gewake_active);		/* wait for timer to go off or interrupt */
	  call ipc_$block (addr (tolts_info.wait_list), addr (event_out), error); /* Wait for a second */
         end;

         if io_info.chan_suspended then			/* if ioi_$suspend has been called */
	  if io_info.io_type = itr_io_type
	   | io_info.io_type = firm_ld_io_type then do;	/* and itrs have been run or attempted to load fw */
retry_ld:
	     call tolts_load_firmware_ (io_sel, error);	/* go reload firmware */
	     if error ^= 0 then do;			/* some problem, ask user what to do */
	        if tolts_info.finish_cond then		/* if we don't have a terminal... */
		 go to tell_opr;			/* just tell opr bad news */
	        call tolts_qttyio_$rs (0, "^a Error loading mpc firmware.^/^a^/", io_info.test_hdr,
	         "Do you wish to retry or quit leaving mpc suspended?");
retype:
	        call tolts_qttyio_$rs (19, "Please answer retry or quit. - ");
	        call message_wait;			/* wait for users answer */
	        if tolts_info.mult_ans = "retry" then go to retry_ld; /* go retry load again */
	        else if tolts_info.mult_ans = "quit" then do;
tell_opr:
		 opr_query_info.q_sw = "0"b;
		 call ioa_$rsnnl ("^/^a ^a^/^-^a", message, i, io_info.test_hdr,
		  "Unrecoverable error loading mpc firmware.", "I/O will remain suspended");
		 call opr_query_ (addr (opr_query_info), substr (message, 1, i)); /* tell opr bad news */
	        end;
	        else go to retype;			/* user gave wrong answer */
	     end;
	  end;

	  else if io_info.io_type ^= mca_io_type then do; /* must be suspended from mdr io */
	     ioi_wksp = io_info.workspace_ptr;		/* get a ptr to our workspace */
	     unspec (wks_init) = "0"b;		/* initialize workspace to zero */
	     idcwp = addr (tolts_workspace.p_idcw);	/* set up idcw ptr */
	     idcw.code = "7"b3;			/* set in idcw type code */
	     idcw.command = "20"b3;			/* set release command */
	     idcw.chan_cmd = "40"b3;			/* special cont. command */
	     pcwa = "000000700000"b3;			/* set up phony pcw */
	     tio_off = fixed (rel (addr (tolts_workspace.p_idcw)));
	     io_info.release_chan = "1"b;		/* set flag for interrupt processor */
	     call timer_manager_$reset_alarm_wakeup (tolts_info.gewake_event); /* Be sure no alarm already set */
	     call ipc_$drain_chn (tolts_info.gewake_event, error); /* In case event occured */
	     call timer_manager_$alarm_wakeup (10, "11"b, tolts_info.gewake_event); /* Set 10 second timer */
	     tolts_info.gewake_active = "1"b;		/* set flag */
	     if pages (io_sel).p_att then do;
	        call ioi_$connect_pcw (io_info.device_index, tio_off, pcwa, error);
	        if error ^= 0 then
		 call output_status_code (error, "cleanup io connect error");
	        tolts_info.glob_int_cnt = tolts_info.glob_int_cnt + 1; /* increment global IO count */
	     end;
	     do while (tolts_info.gewake_active);	/* wait for timer to go off or interrupt */
	        call ipc_$block (addr (tolts_info.wait_list), addr (event_out), error); /* Wait for a second */
	     end;
	     if io_info.io_in_progress then do;		/* if we still got timeout... */
	        call ioa_$rsnnl ("^/^a ^a^/^-^a", message, i, io_info.test_hdr,
	         "Unable to release mpc,", "manually reset and branch to reinitialize mpc");
	        opr_query_info.q_sw = "0"b;
	        call opr_query_ (addr (opr_query_info), substr (message, 1, i));
	        call ioi_$release_devices (io_info.device_index, error); /* do it now */
	     end;
	  end;
      end;
   end ck_release;

/* message_wait - subroutine to wait for terminal message to complete */

message_wait: proc;

      do while (tolts_info.term_io_req_cnt > 0);		/* wait for all terminal io to complete */
         call ipc_$block (addr (tolts_info.wait_list), addr (event_out), error);
      end;

   end message_wait;
%page;

/* set_gelbar - int procedure to set up information to enter gelbar mode */

set_gelbar: proc;

dcl  fwd bit (36);

dcl  1 acc_over based (addr (fwd)) aligned,		/* overlay of acc fault status */
       (2 bar bit (18),				/* BAR value from last mme gelbar */
       2 nu1 bit (1),
       2 fault bit (1),				/* "1"b = fault occurred */
       2 nu2 bit (1),
       2 overflow bit (1),				/* "1"b = fixed point overflow */
       2 ex_over bit (1),				/* "1"b = exponent overflow */
       2 ex_under bit (1),				/* "1"b = exponent underflow */
       2 ipr bit (1),				/* "1"b = eis data ipr fault */
       2 nu3 bit (4),
       2 dcf bit (1),				/* "1"b = divide check fault */
       2 f_type fixed bin (5)) unaligned;		/* fault type, (refer to gcos manual DD19) */

      fwd = "0"b;					/* reset all bits */
      acc_over.fault = "1"b;				/* valid gelbar fault,set the fault bit */
      acc_over.bar = substr (spa.acc_fault, 1, 18);	/* pick up the current bar setting */
      spa.acc_fault = fwd;				/* store accumlated ault status */
      spa.enter.lbar.bar = "000630"b3;			/* reset bar to 0 lal */
      spa.enter.icivlu.ic = rel (addr (spa.glbflt));	/* set ic to return to gelbar fault vector */
      call tolts_init_$gc_tod (gcos_tod);		/* get current time of day */
      spa.glbtmr = bit (fixed (gcos_tod, 35, 0) - fixed (string (spa.glbici), 35, 0), 36); /* delta time */
      spa.glbici.ic = bit (bin (scu.ilc, 17) + 1, 18);	/* store current ic + 1 */
      spa.glbici.ind = string (scu.ir);			/* and indicators */
      gelbar, in_ccc = "0"b;				/* reset gelbar mode, and in ccc  */
      glb_brk = "1"b;				/* and set gelbar break ind */
      call wake_disp;				/* go wake up dispatcher */

   end set_gelbar;



%page;
%include author_dcl;
%page;
%include cdt;
%page;
%include condition_info;
%page;
%include config_iom_card;
%page;
%include event_wait_info;
%page;
%include gload_data;
%page;
%include mc;
%page;
%include mca_data;
%page;
%include mca_data_area;
%page;
%include opr_query_info;
%page;
%include rcp_disk_info;
%page;
%include rcp_resource_types;
%page;
%include rcp_tape_info;
%page;
%include tolts_err_codes;
%page;
%include tolts_fpinfo;
%page;
%include tolts_info;
%page;
%include tolts_rspd_workspace;
%page;
%include tolts_workspace;





   end mtdsim_;

