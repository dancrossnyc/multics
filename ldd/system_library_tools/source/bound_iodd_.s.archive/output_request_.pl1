/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


output_request_: proc (a_stream_name, a_element_size, a_stat_p, a_banner_proc, a_code);

/* General procedure for doing output for an I/O daemon device driver */

/* Rewritten from old procedure "io_daemon" in August 1973 by Robert S. Coren */
/* Modified in March 1975 by J.C. Whitmore during driver restructuring */
/* Modified in December 1975 by M. A. Braida to include new restart capabilities and update the accounting mechanism */
/* modified 05/76 by THVV for set_kst_attributes & force deactivation */
/* Modified 06/76 by J. C. Whitmore to fix translate hardware bug */
/* Modified June 1976 by J. L. Homan to accommodate charging by line count instead of block count. */
/* modified July 1976 by THVV for message notification */
/* Modified Nov 1977 by J. C. Whitmore  for minor bug fixed and remote driver compatability */
/* Modified Mar 1978 by J. C. Whitmore for new dprint_msg format and driver upgrade */
/* Modified Aug 1978 by J. C. Whitmore for: auto defer by time estimate, separation of charge queue and request queue,
   no deletion if device error occurs, and further upgrade. */
/* Modified Nov 1978 by J. C. Whitmore to add path to device error msg and to notify user on deferring request */
/* Modified Mar 1979 by J. C. Whitmore to correct string size on some assignments */
/* Modified by J. C. Whitmore, 1/80, to limit the scope of system_privileges_ for send mail (V5.4) */
/* Modified: February 23, 1985 by C. Marker if the page labels are not the same as the access class of the segment a message will be logged.  Changed to use version 5 message segments */


/****^  HISTORY COMMENTS:
  1) change(87-05-10,Gilcrease), approve(87-07-31,MCR7686),
     audit(88-02-01,Farley), install(88-02-02,MR12.2-1019):
     Changed to implement line numbered output.
  2) change(88-06-03,Brunelle), approve(88-06-03,MCR7911),
     audit(88-10-25,Wallman), install(88-10-28,MR12.2-1199):
     Upgraded to version 5 I/O daemon tables.
                                                   END HISTORY COMMENTS */


	dcl     a_stream_name	 char (*);	/* stream to write the output on */
	dcl     a_element_size	 fixed bin;	/* number of bits in each stream element */
	dcl     a_stat_p		 ptr;		/* the value of stat_p from caller */
	dcl     a_banner_proc	 entry;		/* procedure to be called for head and tail banners */
	dcl     a_code		 fixed bin (35);	/* error code....used for driver_fatal_error */

/* AUTOMATIC */

	dcl     abort_msg		 char (256) var;	/* string for bad error messages */
	dcl     access_class	 bit (72) aligned;	/* access class of user file */
	dcl     auth		 bit (72) aligned;	/* authorization used to set banner access class */
	dcl     auth_string		 char (680);	/* string form of auth */
	dcl     banner_proc		 entry variable options (variable); /* proc to be called for messages */
	dcl     chgsw		 bit (1) aligned;	/* do we charge for this request/copy */
	dcl     code		 fixed bin (35);
	dcl     copies_left		 fixed bin;
	dcl     delete_msg		 char (32);
	dcl     desc_ptr		 ptr;
	dcl     dest		 char (24) aligned;
	dcl     device_error	 bit (1);
	dcl     dr_ptr		 ptr;		/* pointer to driver status segment */
	dcl     el_size		 fixed bin;
	dcl     ename		 char (32) aligned; /* entry name of file for output */
	dcl     err_mess		 char (200) var;
	dcl     fcbp		 ptr;
	dcl     full_path		 char (168) aligned;
	dcl     head		 char (64) aligned;
	dcl     header_sw		 bit (1);
	dcl     i			 fixed bin;	/* random variable */
	dcl     iocbp		 ptr;		/* iocb pointer for request stream */
	dcl     l			 fixed bin;
	dcl     last_error_count	 fixed bin;
	dcl     lg_msg		 char (100) aligned;
	dcl     mailname		 char (32) aligned;
	dcl     max_comp		 fixed bin;	/* highest msf component number */
	dcl     msg		 char (256) aligned;
	dcl     new_clock		 fixed bin (71);
	dcl     new_cpu		 fixed bin (52);
	dcl     new_pp		 fixed bin;
	dcl     new_rate		 fixed bin;
	dcl     new_waits		 fixed bin (35);
	dcl     nret		 fixed bin;
	dcl     old_clock		 fixed bin (71);
	dcl     oldmodes		 char (256);
	dcl     old_cpu		 fixed bin (52);
	dcl     old_pp		 fixed bin;
	dcl     old_rate		 fixed bin;
	dcl     old_waits		 fixed bin (35);
	dcl     pverb		 char (5) aligned;
	dcl     req_stream		 char (32);
	dcl     save_code		 fixed bin (35);
	dcl     seconds		 fixed bin;	/* number of seconds to do one copy */
	dcl     segp		 ptr;
	dcl     start_segp		 pointer;
	dcl     short_msg		 char (8) aligned;
	dcl     time_est		 fixed bin;	/* number of seconds estimated to do request */
	dcl     total_bits		 fixed bin (35);
	dcl     user_dir		 char (168) aligned;/* directory containing users' segment */
	dcl     val		 fixed bin;	/* for validation level */

/* INTERNAL STATIC */

	dcl     bad_chars		 char (4) int static;
	dcl     err_label		 label int static;	/* point of return from condition handler */
	dcl     fault_name		 char (32) aligned int static;
	dcl     first_call		 bit (1) static init ("1"b); /* TRUE on first call */
	dcl     privileged		 bit (1) static init ("1"b); /* TRUE if we can call phcs_ */
	dcl     sys_priv		 bit (1) static init ("1"b); /* True if process can call system_privilege_ */
	dcl     request_data_p	 ptr int static;	/* ptr to REQUEST for set_single_copy entrry */


/*	CONSTANTS 	*/

	dcl     both		 fixed bin int static options (constant) init (0);
	dcl     error		 fixed bin int static options (constant) init (2);
	dcl     error_msg		 fixed bin int static options (constant) init (3); /* value for print error message */
	dcl     factor		 float bin int static options (constant) init (0.75e0); /* smoothing factor for rate estimate */
	dcl     header		 fixed bin int static options (constant) init (1); /* value for header wanted */
	dcl     id		 char (24) int static options (constant) init ("output_request_");
	dcl     log		 fixed bin int static options (constant) init (0);
	dcl     master		 fixed bin int static options (constant) init (1);
	dcl     quiet		 bit (1) int static options (constant) init ("0"b);
	dcl     restart_source	 fixed bin int static init (1);
	dcl     slave		 fixed bin int static options (constant) init (2);
	dcl     stars		 char (40) int static options (constant) aligned init ((40)"*"); /* For error messages */
	dcl     tail		 fixed bin int static options (constant) init (2); /* value for tail wanted */
	dcl     tell_user		 bit (1) int static options (constant) init ("1"b);

	dcl     NL		 char (1) int static options (constant) init ("
");
	dcl     TAB		 char (1) int static options (constant) init ("	"); /* the tab character */
	dcl     VT		 char (1) int static options (constant) init ("");						/* the vertical  tab */
	dcl     FF		 char (1) int static options (constant) init ("");						/* and the form feed */

/* EXTERNAL STATIC */

	dcl     access_operations_$io_daemon_set_page_labels bit (36) aligned external static;

	dcl     error_table_$improper_data_format fixed bin (35) ext static;
	dcl     error_table_$noentry	 fixed bin (35) ext static;
	dcl     error_table_$moderr	 fixed bin (35) ext static;
	dcl     error_table_$dirseg	 ext static fixed bin (35);
	dcl     error_table_$ai_restricted ext static fixed bin (35);


/* EXTERNAL ENTRIES */

	dcl     access_audit_gate_$log_obj_ptr_user entry options (variable);
	dcl     aim_check_$equal	 entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
	dcl     aim_check_$greater	 entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
	dcl     clock_		 ext entry returns (fixed bin (71)); /* gets clock time */
	dcl     continue_to_signal_	 entry (fixed bin (35));
	dcl     convert_authorization_$from_string entry (bit (72) aligned, char (*), fixed bin (35));
	dcl     convert_authorization_$to_string entry (bit (72) aligned, char (*), fixed bin (35));
	dcl     convert_status_code_	 ext entry (fixed bin (35), char (8) aligned, char (100) aligned);
	dcl     cpu_time_and_paging_	 entry (fixed bin (35), fixed bin (52), fixed bin);
	dcl     cu_$level_get	 entry (fixed bin);
	dcl     cv_dec_check_	 entry (char (*), fixed bin (35)) returns (fixed bin (35));
	dcl     date_time_		 entry (fixed bin (71), char (*) aligned);
	dcl     hcs_$fs_get_mode	 ext entry (ptr, fixed bin (5), fixed bin (35));
	dcl     hcs_$fs_get_path_name	 entry (ptr, char (*) aligned, fixed bin, char (*) aligned, fixed bin (35));
	dcl     hcs_$get_access_class	 entry (char (*) aligned, char (*) aligned, bit (72) aligned, fixed bin (35));
	dcl     hcs_$get_user_effmode	 entry (char (*) aligned, char (*) aligned, char (*) aligned,
				 fixed bin, fixed bin (5), fixed bin (35));
	dcl     hcs_$status_minf	 entry (char (*) aligned, char (*) aligned, fixed bin, fixed bin (2), fixed bin (24), fixed bin (35));
	dcl     io_daemon_account_	 entry (entry, ptr);
	dcl     ioa_$ioa_stream	 entry options (variable);
	dcl     ioa_$rsnnl		 entry options (variable);
	dcl     iodd_msg_		 entry options (variable);
	dcl     iox_$control	 entry (ptr, char (*), ptr, fixed bin (35));
	dcl     iox_$modes		 entry (ptr, char (*), char (*), fixed bin (35));
	dcl     iox_$get_line	 entry (ptr, ptr, fixed bin, fixed bin, fixed bin (35));
	dcl     iox_$look_iocb	 entry (char (*), ptr, fixed bin (35));
	dcl     iox_$put_chars	 entry (ptr, ptr, fixed bin (24), fixed bin (35));
	dcl     msf_manager_$close	 entry (ptr);
	dcl     msf_manager_$get_ptr	 entry (ptr, fixed bin, bit (1), ptr, fixed bin (24), fixed bin (35));
	dcl     msf_manager_$open	 entry (char (*) aligned, char (*) aligned, ptr, fixed bin (35));
	dcl     phcs_$deactivate	 entry (ptr, fixed bin (35));
	dcl     phcs_$set_kst_attributes entry (fixed bin, ptr, fixed bin (35));
	dcl     read_allowed_	 entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
	dcl     send_mail_$access_class entry (char (*) aligned, char (*) aligned, ptr, bit (72) aligned, fixed bin (35));
	dcl     system_privilege_$ipc_priv_on entry (fixed bin (35));
	dcl     system_privilege_$ipc_priv_off entry (fixed bin (35));
	dcl     system_privilege_$ring1_priv_on entry (fixed bin (35));
	dcl     system_privilege_$ring1_priv_off entry (fixed bin (35));

/* STRUCTURES */

	dcl     1 ksta		 like kst_attributes aligned int static;

	dcl     1 counts_data	 aligned like counts;



/* BUILTINS */

	dcl     (addr, bit, divide, fixed, length, null, substr, ltrim, rtrim, translate) builtin;
	dcl     (baseno, binary, string, unspec, float, min, char) builtin;


/* CONDITIONS */

	dcl     (cleanup, linkage_error, daemon_again, daemon_again_slave, daemon_kill,
	        daemon_save, daemon_defer, daemon_cancel, any_other) condition;

/* output_request_: proc (a_stream_name,  a_element_size, a_stat_p, a_banner_proc, a_code);  MAIN ENTRY      */

/* copy arguments and initialize pointers and control switches */

	stat_p = a_stat_p;
	sdb_ptr = null ();
	banner_proc = a_banner_proc;			/* no charging yet */

	chgsw = "0"b;
	fcbp, segp, start_segp = null;
	req_stream = a_stream_name;
	el_size = a_element_size;
	a_code = 0;				/* set to zero for now */
	if first_call then do;			/* Conduct an experiment to see about phcs_ */
		bad_chars = TAB || NL || VT || FF;	/* define the bad chars for labels */
		on linkage_error begin;
			privileged = "0"b;
			go to tough;
		     end;
		string (ksta) = "0"b;
		call phcs_$set_kst_attributes (binary (baseno (stat_p), 18), addr (ksta), (0));
						/* This is a NOP - structure is 0 */
		ksta.set.tpd, ksta.value.tpd = "1"b;	/* Dont put on bulkstore just for lil ole me */
		ksta.set.explicit_deactivate_ok, ksta.value.explicit_deactivate_ok = "1"b;
		ksta.set.allow_write = "1"b;		/* Dont let me wreck user seg by accident */
		ksta.set.tus, ksta.value.tus = "1"b;	/* Save a vtoc write */
tough:		revert linkage_error;
		first_call = "0"b;			/* Now we know */
	     end;
	last_error_count = -1;			/* invalid error count, hasn't been set */

	dr_ptr = iodd_static.driver_ptr;		/* get ptr to the current driver status seg */
	desc_ptr = addr (dr_ptr -> driver_status.descriptor); /* and to the request descriptor */
	mseg_message_info_ptr = desc_ptr;		/* first part of desciptor is mseg_message_info */
	dmp = addr (dr_ptr -> driver_status.message);	/* set dprint_msg default pointer */
	request_data_p = addr (REQUEST);		/* get ready to handle "single copy" request */
	driver_data_p = addr (desc_ptr -> request_descriptor.driver_data); /* get ptr to printer_driver_data */
	orderp = addr (counts_data);			/* set auto ref ptr to counts structure */
	header_sw = ""b;

	call iox_$look_iocb (req_stream, iocbp, code);
	if code ^= 0 then do;
		call driver_fatal_error (code, "Unable to find iocb pointer for output stream.");
		go to clean_out;
	     end;

	on cleanup call clean_proc;			/* establish a cleanup handler */
	sdb_ptr = iocbp;
	err_label = abort_request;

/* Set up master structure used by this pgm. */

	string (REQUEST.control_flags) = ""b;		/* clear all the flags */
	REQUEST.requestor = mseg_message_info.sender_id;
	REQUEST.continued = desc_ptr -> request_descriptor.continued;
	REQUEST.restarted = desc_ptr -> request_descriptor.restarted;
	REQUEST.priority_request = desc_ptr -> request_descriptor.priority_request;
	REQUEST.separator = "1"b;			/* we always want a print separator first time */
	REQUEST.device_name = dr_ptr -> driver_status.dev_name_label;
	REQUEST.request_type = dr_ptr -> driver_status.req_type_label;
	REQUEST.queue = desc_ptr -> request_descriptor.q;
	REQUEST.charge_queue = desc_ptr -> request_descriptor.charge_q; /* coord may want a priority rate */
	REQUEST.request_no = desc_ptr -> request_descriptor.seq_id; /* coord assigned the number */
	REQUEST.restart_no = desc_ptr -> request_descriptor.prev_seq_id;
						/* previous number of request (0 = not restarted) */
	REQUEST.contd_no = desc_ptr -> request_descriptor.contd_seq_id;
						/* previous number of continued request (0 = not continued) */
	REQUEST.dpmp = dmp;
	if dprint_msg.delete_sw then REQUEST.delete = 1;
	else REQUEST.delete = 0;
	REQUEST.bit_count = 0;
	REQUEST.line_count = 0;
	REQUEST.page_count = 0;
	REQUEST.line_nbrs = dprint_msg.line_nbrs;
	REQUEST.copies = dprint_msg.copies;
	if ^(REQUEST.continued | REQUEST.restarted) then
	     print_driver_data.copies_done = 0;		/* no copies assumed, unless continued or restarted */
						/* if none completed, it's not continued */
	else if print_driver_data.copies_done < 1 then REQUEST.continued = "0"b;
	print_driver_data.copies_done = min (print_driver_data.copies_done, REQUEST.copies - 1);
						/* be sure we do at least one copy */
	copies_left = REQUEST.copies - print_driver_data.copies_done; /* might be partly done */
	REQUEST.copy_no = print_driver_data.copies_done + 1; /* we start with the next copy */
	REQUEST.notify = dprint_msg.notify;
	REQUEST.output_mode = "";			/* clear in case of error message */
	REQUEST.total_charge = 0e0;
	REQUEST.charge = 0e0;
	REQUEST.time_start_request = clock_ ();
	call date_time_ (REQUEST.time_start_request, REQUEST.date_time_start_request);

	if dprint_msg.output_module = 1 then do;
		REQUEST.punsw = 0;
		pverb = "print";
	     end;
	else do;
		REQUEST.punsw = 1;
		pverb = "punch";
	     end;

	l = length (rtrim (REQUEST.requestor)) - 2;	/* get length of Person.Project */
	mailname = substr (REQUEST.requestor, 1, l);
	unspec (send_mail_info) = "0"b;
	send_mail_info.version = send_mail_info_version_2;
	send_mail_info.wakeup = "1"b;
	send_mail_info.always_add = "1"b;
	send_mail_info.sent_from = REQUEST.request_type;

/* get pathname of file for operator and error messages */

	user_dir = dprint_msg.dirname;
	ename = dprint_msg.ename;
	call ioa_$rsnnl ("^a^[>^]^a", full_path, l, user_dir, (user_dir ^= ">"), ename);

	REQUEST.full_path = translate (full_path, "", bad_chars); /* force a page fault - HARDWARE BUG WRITEAROUND */
	full_path = translate (full_path, "", bad_chars); /* remove bad chars for banner */
	dprint_msg.destination = translate (dprint_msg.destination, "", bad_chars);
	dprint_msg.heading = translate (dprint_msg.heading, "", bad_chars);
	REQUEST.full_path = full_path;		/* save the clean copy */

/*  record the processing of this request in the log  */

	head = dprint_msg.heading;
	if substr (head, 1, 5) = " for " then /* see if dprint added something */
	     head = substr (head, 6);			/* if so get rid of it */
	if head ^= "" then call ioa_$rsnnl ("(for ""^a"" ", msg, l, head);
	else do;
		l = 1;				/* no heading, get ready for a dest msg */
		msg = "(";
	     end;

	dest = dprint_msg.destination;
	if dest ^= "" then call ioa_$rsnnl ("^vaat ""^a"")", msg, l, (l), substr (msg, 1, l), dest);
	else if l = 1 then msg = "";			/* no head or dest case */
	else substr (msg, l, 1) = ")";		/* heading only case */

	call iodd_msg_ (log, both, 0, "",		/* let the subr do the work */
	     "Request ^d ^a q^d:  ^a^/^2x^[(^d copies) ^;^s^]^[priority ^d ^;^s^]from ^a ^a",
	     REQUEST.request_no, REQUEST.request_type, REQUEST.queue, full_path, (copies_left > 1), copies_left,
	     REQUEST.priority_request, REQUEST.charge_queue, REQUEST.requestor, msg);

	err_mess = full_path;			/* let this sit here in case */

/* Find the access class to use for the banner */

	if aim_check_$greater (mseg_message_info.sender_authorization, dr_ptr -> driver_status.min_banner) then
	     auth = mseg_message_info.sender_authorization;
	else auth = dr_ptr -> driver_status.min_banner;	/* mark the output with auth */

	call convert_authorization_$to_string (auth, auth_string, code); /* get string form */
	if code ^= 0 then do;			/* oops....bad news */
		call fatal_error (tell_user);		/* tell the operator, and user */
		go to clean_out;			/* drop the request */
	     end;

	l = length (rtrim (auth_string));		/* how long is the string */
	if l > 132 then do;				/* when too long for one line */
		call convert_authorization_$from_string (access_class, "system_high", code);
		if code ^= 0 then do;		/* oops....bad news */
			call fatal_error (tell_user); /* tell the operator, and user */
			go to clean_out;		/* drop the request */
		     end;
		if aim_check_$equal (auth, access_class) then auth_string = "SYSTEM HIGH"; /* this is shorter */
	     end;

	REQUEST.access_class_string = char (auth_string, length (REQUEST.access_class_string));
						/* save all we can for the label */

/* check the requestor's access to the pathname he specified */

	val = mseg_message_info.sender_level;

	call check_user_access (user_dir, ename, code);	/* use the internal proc to do the work */
	if code ^= 0 then do;			/* oops....bad news */
		call fatal_error (tell_user);		/* tell the operator, and user */
		go to clean_out;			/* drop the request */
	     end;

	call open_file (user_dir, ename, fcbp, max_comp, code); /* one call does a lot */
	if code ^= 0 then do;			/* oops....bad news */
		call fatal_error (tell_user);		/* tell the operator, and user */
		go to clean_out;			/* drop the request */
	     end;

	on daemon_again begin;			/* to restart the current request.... */
		restart_source = master;		/* talking to the master terminal */
		go to check_reprint_copies;
	     end;
	on daemon_again_slave begin;			/* to restart the current request.... */
		restart_source = slave;		/* talking to slave terminal */
		go to check_reprint_copies;
	     end;
	on daemon_save begin;
		REQUEST.saved = "1"b;
		if ^header_sw then go to clean_out;
		else go to save_request;
	     end;
	on daemon_defer go to defer_request;		/* save it for later */
	on daemon_kill go to flush_request;		/* flush the current request */
	on daemon_cancel go to flush_request;		/* likewise,  the cancelled flag has been set */

	iodd_static.request_in_progress = "1"b;		/* ready to accept kill, cancel etc. */
						/* now we can restart this request if necessary */

/* with the true total bitcount, we can make an estimate of the time needed to do the request */

	if dr_ptr -> driver_status.bit_rate_est > 0 then do;
		total_bits = REQUEST.bit_count * copies_left; /* total is bits per copy times copies */
		time_est = divide (total_bits, dr_ptr -> driver_status.bit_rate_est, 17, 0);

		if (dr_ptr -> driver_status.defer_time_limit > 0) & /* if a limit is defined, check it */
		     (time_est > dr_ptr -> driver_status.defer_time_limit + 6) then do; /* allow 6 sec fuzz */
						/* so estimate will look bigger than limit in msg */
			if REQUEST.priority_request then /* priority requests go any way */
			     msg = "Defer time limit suspended for priority request.";
			else if REQUEST.restarted then /* can't defer what is not in the queue */
			     msg = "Restarted request exceeds time limit but cannot be deferred.";
			else do;			/* drop this one */
				desc_ptr -> request_descriptor.keep_in_queue = "1"b;
				call iodd_msg_ (log, both, 0, "",
				     "**Deferring request ^d. Time estimate: ^.1f mins.",
				     REQUEST.request_no, float (time_est) / 60.0e0);
				call ioa_$rsnnl ("Deferring request for ^a.^/Time estimate: ^.1f minutes.", msg, l,
				     REQUEST.full_path, float (time_est) / 60.0e0);
				call notify_user (substr (msg, 1, l));
				go to clean_out;
			     end;
		     end;
		else msg = "";

		if time_est > 60 | msg ^= "" then /* tell operator if request will exceed 1 minute */
		     call iodd_msg_ (log, slave, 0, "",
			"  Time estimate for request ^d:  ^.1f mins.^[^/^2x^a^]",
			REQUEST.request_no, float (time_est) / 60.0e0, (msg ^= ""), msg);
	     end;

	if REQUEST.copy_no > 1 then call iodd_msg_ (log, both, 0, "",
		"  Starting request ^d at copy ^d of ^d.", REQUEST.request_no, REQUEST.copy_no, REQUEST.copies);

	go to start_request;			/* begin the output of the request */

restart_this_request:

/* 	this is the point where we come to restart the current request */

	REQUEST.continued = "1"b;			/* make this look like a continuation */
	REQUEST.contd_no = REQUEST.request_no;		/* of this request */
	REQUEST.charge = 0e0;
	REQUEST.time_start_request = clock_ ();
	call date_time_ (REQUEST.time_start_request, REQUEST.date_time_start_request);

start_request:

	REQUEST.cpu_time = 0;			/* reset the usage data */
	REQUEST.real_time = 0;
	REQUEST.page_waits = 0;
	REQUEST.pre_pages = 0;
	REQUEST.copy_no = print_driver_data.copies_done + 1; /* initialize copy-counter */

	call iox_$control (iocbp, "get_error_count", addr (last_error_count), code); /* start checking for errors */
	if code ^= 0 then last_error_count = -1;	/* value not defined */

	call check_labels (user_dir, ename, start_segp, code);
	if code ^= 0 then do;			/* oops....bad news */
		call fatal_error (tell_user);		/* tell the operator, and user */
		go to clean_out;			/* drop the request */
	     end;

	do while (REQUEST.copies >= REQUEST.copy_no);	/* once around for each copy */

	     call banner_proc (req_stream, header, addr (REQUEST), code); /* print header banner */
	     if code ^= 0 then do;			/* I/O error trying to print header */
		     call driver_fatal_error (code, "I/O ERROR -- trying to print header.");
		     go to clean_out;		/* abort this request completely */
		end;

	     REQUEST.separator = "0"b;		/* separator bar was for first banner only */
	     header_sw = "1"b;			/* header was ok, do tail */
	     call iox_$control (iocbp, "runout", null, code); /* be sure head sheet is done before clock reading */

	     call cpu_time_and_paging_ (old_waits, old_cpu, old_pp); /* keep time and page waits for accounting */
	     old_clock = clock_ ();			/* time copy started */

	     call output_file (code);			/* this will do it */
	     if code ^= 0 then do;
		     call driver_fatal_error (code, (err_mess));
		     go to clean_out;
		end;

	     call iox_$control (iocbp, "runout", null, code); /* be sure copy is done before counting it */

	     if ^desc_ptr -> request_descriptor.saved then /* if leaving this til later, don't charge now */
		if REQUEST.copies > print_driver_data.copies_charged then do;
			chgsw = "1"b;		/* user honestly deserves these charges */
			print_driver_data.copies_charged = print_driver_data.copies_charged + 1;
		     end;
		else chgsw = "0"b;
	     else chgsw = "0"b;

	     call charge_for_work;			/* do the accounting so we can put price on tail */

	     if last_error_count = -1 then device_error = ""b; /* no error data */
	     else do;
		     call iox_$control (iocbp, "get_error_count", addr (i), code);
		     if code ^= 0 | i > last_error_count then device_error = "1"b;
		     else device_error = "0"b;	/* we can figure the transfer rate */
		end;

	     if ^(iodd_static.quit_during_request | device_error) then do; /* can we update the rate estimate? */
		     old_rate = dr_ptr -> driver_status.bit_rate_est; /* get the last value */
		     seconds = divide (REQUEST.real_time, 1000000, 17); /* see how many seconds have passed */
		     if seconds < 1 then new_rate = old_rate; /* avoid divide by zero */
		     else new_rate = divide (REQUEST.bit_count, seconds, 17, 0); /* get bits/sec */
		     if old_rate > 0 then /* use first good rate to start the estimate */
			new_rate = fixed (old_rate * factor + new_rate * (1e0 - factor)); /* use exp smoothing */
		     dr_ptr -> driver_status.bit_rate_est = new_rate; /* put back new value */
		end;

	     call banner_proc (req_stream, tail, addr (REQUEST), code); /* this will put on the tail banner */
	     if code ^= 0 then do;			/* some type of error..don't do it again */
		     call driver_fatal_error (code, "I/O ERROR -- attempting to write tail banner.");
		     go to clean_out;
		end;

	     print_driver_data.copies_done = print_driver_data.copies_done + 1;
	     REQUEST.copy_no = REQUEST.copy_no + 1;	/* get ready for next copy */
	     header_sw = "0"b;
	end;					/* done with this copy...check for more in while loop */

	call iodd_msg_ (log, both, 0, "",
	     "  Charge for request ^d:  $^.2f,  ^[(^d lines,  ^d pages^;(^d cards^s^]^[ per copy)^;)^]",
	     REQUEST.request_no, REQUEST.total_charge, (REQUEST.punsw = 0),
	     REQUEST.line_count, REQUEST.page_count, (copies_left > 1));

	if REQUEST.notify then do;
		call ioa_$rsnnl ("^aed ^a $^.2f queue ^d ^a ^d", abort_msg, l,
		     pverb, REQUEST.full_path, REQUEST.total_charge,
		     REQUEST.queue, REQUEST.device_name, REQUEST.request_no);
		call notify_user (substr (abort_msg, 1, l));
	     end;

clean_out:					/* get ready for the next users' request */

	if last_error_count > -1 then do;		/* if error count is defined */
		call iox_$control (iocbp, "get_error_count", addr (i), code);
		if code ^= 0 | i > last_error_count then /* if errors are possible */
		     if ^desc_ptr -> request_descriptor.dont_delete then do; /* and user not told about it */
			     if REQUEST.delete = 1 then do; /* tell user we cancelled his delete request */
				     desc_ptr -> request_descriptor.dont_delete = "1"b;
				     call ioa_$rsnnl ("Device error during request ^d.  Segment ^a will not be deleted.",
					msg, l, REQUEST.request_no, REQUEST.full_path);
				     call notify_user (substr (msg, 1, l));
				end;
			end;
	     end;

	call clean_proc;				/* get junk out of the address space */

	desc_ptr -> request_descriptor.finished = "1"b;	/* mark it as done */
	iodd_static.request_in_progress = "0"b;		/* no more commands can be effective */
	call iox_$control (iocbp, "runout", null, code);	/* make device disgorge */
	return;


check_reprint_copies:				/* on restart, we transfer back here to release the */
						/* stack frame with the dim, so the slave can again write */
						/* to the remote device and ask a question */

	call restart_request (restart_source);		/* this will do the work */
						/* and ask the operator how many copies were good */

	go to restart_this_request;			/* now go back and restart the request */

/*  This is where the condition handlers "go to" when something has gone wrong */

flush_request:					/* kill and cancel handlers jump back here */

	msg = "Operator aborted output";		/* message for kill and cancel */
	chgsw = "0"b;				/* can't charge */
	go to no_delete;

abort_request:					/* unclaimed signals transfer to here */

	chgsw = ""b;				/* assume we can't charge user */

	msg = """" || rtrim (fault_name) || """ condition occured"; /* format basic message */

	if fault_name = "seg_fault_error" & /* user deleted seg, charge for what was done */
	     iodd_static.segptr ^= null then do;
		chgsw = "1"b;
		delete_msg = "";			/* forget to tell user we won't delete his seg */
	     end;
	else do;
no_delete:
		if REQUEST.delete ^= 0
		then delete_msg = "; segment will not be deleted";
		else delete_msg = "";
	     end;

	call ioa_$rsnnl ("^a during processing of ^a request^a.", err_mess, l,
	     msg, pverb, delete_msg);

	code = 0;

	call fatal_error (tell_user);			/* this will clean things up a bit */

	go to clean_out;				/* now drop the request */


defer_request:					/* leave this in the queue for a while */

	err_mess = "Operator deferred request until a later time.";
	chgsw = ""b;
	code = 0;

	call fatal_error (tell_user);

	go to clean_out;


save_request:

	err_mess = "Processing suspended by operator.";
	chgsw = "0"b;
	code = 0;

	call fatal_error (quiet);			/* abort gently */

	go to clean_out;

/* ======================================================================================= */
/* ==============================    INTERNAL PROCEDURES    ============================== */
/* ======================================================================================= */

fatal_error: proc (notify);

	dcl     notify		 bit (1);

	save_code = code;				/* hold this for now */
	REQUEST.notify = REQUEST.notify | notify;	/* set notify flag by arg if off */
	desc_ptr -> request_descriptor.dont_delete = "1"b;/* make sure we don't delete user seg */

	if ^REQUEST.notify & ^header_sw then do;	/* try to tell requestor */
		call banner_proc (req_stream, header, addr (REQUEST), code);
		if code = 0 then header_sw = "1"b;	/* all was well */
	     end;

	if header_sw then call charge_for_work;		/* update REQUEST data if possible */

	call error_write (save_code, err_mess);

	if header_sw then /* if we owe a tail banner, do it */
	     call banner_proc (req_stream, tail, addr (REQUEST), code);

	call iodd_msg_ (log, both, 0, "",
	     "Processing of request ^d terminated.", REQUEST.request_no);

	return;					/* let the caller flush the request */

     end fatal_error;

/* ===================================== */

error_write: proc (code, message);			/* for writing error messages to console &
						   request stream */
	dcl     code		 fixed bin (35);
	dcl     message		 char (*) varying;

	short_msg, lg_msg = "";			/* clear any junk */
	if code ^= 0 then call convert_status_code_ (code, short_msg, lg_msg);

	call ioa_$rsnnl ("Request for ^a. ^a ^a", msg, l, REQUEST.full_path, lg_msg, message);

	if REQUEST.notify then /* this lets us be quiet about save and defer */
	     call notify_user (substr (msg, 1, l));

	call iodd_msg_ (log, both, 0, "", "**Request ^d: ^a ^a", REQUEST.request_no, lg_msg, message);

	if header_sw then do;			/* must not do a "reset" or line and page count is lost */
		call ioa_$rsnnl ("^2/^a^a^/io_daemon: ^a ^a^/^a^a^2/", abort_msg, l, VT,
		     stars, lg_msg, message, stars, VT);
		call banner_proc (req_stream, error_msg, addr (abort_msg), code); /* put out error msg to media */
	     end;
	return;

     end error_write;

check_labels:
     procedure (user_dir, ename, segptr, code);

/* Internal procedure to check that the top and bottom labels are
   the access class of the segment. */

	dcl     access_class	 bit (72) aligned;
	dcl     code		 fixed bin (35);
	dcl     ename		 char (*) aligned;
	dcl     level		 fixed bin;
	dcl     user_dir		 char (*) aligned;
	dcl     segptr		 pointer;
	dcl     sys_info$access_class_floor bit (72) aligned external static;


	dcl     1 local_audit_user_info aligned like audit_user_info;
	dcl     1 local_audit_eventflags aligned like audit_event_flags;

	code = 0;

	if dprint_msg.top_label ^= dprint_msg.bottom_label then do;
LOG_AUDIT_MESSAGE:
		call cu_$level_get (level);
		unspec (local_audit_user_info) = ""b;
		local_audit_user_info.version = audit_user_info_version_1;
		local_audit_user_info.user_id = mseg_message_info.sender_id;
		local_audit_user_info.ring = mseg_message_info.sender_level;
		local_audit_user_info.process_id = mseg_message_info.sender_process_id;
		local_audit_user_info.authorization = mseg_message_info.sender_authorization;
		local_audit_user_info.authorization_range (1) = sys_info$access_class_floor;
		local_audit_user_info.authorization_range (2) = mseg_message_info.sender_max_authorization;
		local_audit_user_info.audit_flags = mseg_message_info.sender_audit;

		unspec (local_audit_eventflags) = ""b;
		local_audit_eventflags.grant = "1"b;

		call access_audit_gate_$log_obj_ptr_user ("output_request_",
		     level, unspec (local_audit_eventflags),
		     access_operations_$io_daemon_set_page_labels,
		     segptr, 0, null (), 0, addr (local_audit_user_info));

		return;
	     end;

	call hcs_$get_access_class (user_dir, ename, access_class, code);
	if code ^= 0 then return;

	call convert_authorization_$from_string (authorization, rtrim (dprint_msg.top_label), code);
	if code ^= 0 then do;
		code = 0;
		goto LOG_AUDIT_MESSAGE;		/* This isn't an access class */
	     end;

	if ^(aim_check_$equal (access_class, authorization)) then goto LOG_AUDIT_MESSAGE;

	return;
     end check_labels;

notify_user: proc (message);

	dcl     message		 char (*) aligned;
	dcl     (ipc_ind, r1_ind, ec)	 fixed bin (35);

	ipc_ind, r1_ind = -1;			/* set to non-zero to test call */

	if ^sys_priv then go to send_it;		/* if they failed once, .... */

	on linkage_error begin;
		sys_priv = "0"b;			/* stop trying if we fail */
		go to revert_handler;		/* send the message if possible */
	     end;

	on any_other begin;
		if r1_ind = 0 then call system_privilege_$ring1_priv_off (r1_ind);
		if ipc_ind = 0 then call system_privilege_$ipc_priv_off (ipc_ind);
		r1_ind, ipc_ind = -1;
		call continue_to_signal_ (ec);
	     end;

	call system_privilege_$ring1_priv_on (r1_ind);

	call system_privilege_$ipc_priv_on (ipc_ind);

revert_handler:

	revert linkage_error;

send_it:

	call send_mail_$access_class (mailname, message, addr (send_mail_info),
	     mseg_message_info.sender_authorization, ec);

	if r1_ind = 0 then call system_privilege_$ring1_priv_off (r1_ind);

	if ipc_ind = 0 then call system_privilege_$ipc_priv_off (ipc_ind);

	return;

     end notify_user;

charge_for_work: proc;

/* Accounting section, done at end of processing each copy of output. */

	counts.line_count = 0;			/* Clear these items so that if the order is unknown.. */
	counts.page_count = 0;			/* .. (like if card dim doesn't do them) we still go */
	counts.line = 0;
	call iox_$control (iocbp, "get_count", orderp, code);
	new_clock = clock_ ();
	call cpu_time_and_paging_ (new_waits, new_cpu, new_pp);

	if counts.line_count > 0 then
	     REQUEST.line_count = counts.line_count;
	else REQUEST.line_count = divide (REQUEST.bit_count + 699, 700, 24, 0); /* Use block count
						   if dim returns zero line count */
	if counts.line = 1 then REQUEST.page_count = counts.page_count - 1; /* if ending with a FF */
	else REQUEST.page_count = counts.page_count;
	REQUEST.cpu_time = new_cpu - old_cpu;
	REQUEST.real_time = new_clock - old_clock;
	REQUEST.page_waits = fixed (new_waits - old_waits, 35);
	REQUEST.pre_pages = fixed (new_pp - old_pp, 35);

	if chgsw then do;
		if dr_ptr -> driver_status.have_accounting then do;
			call io_daemon_account_ (dr_ptr -> driver_status.acct_entry, addr (REQUEST));
		     end;
		else do;
			REQUEST.price_per_n_lines,	/* zap all charges to zero */
			     REQUEST.price_per_n_pages,
			     REQUEST.charge = 0e0;
			REQUEST.no_accounting = "1"b; /* and flag it */
		     end;
	     end;
	else REQUEST.charge = 0e0;			/* reset any undefined values */

	REQUEST.total_charge = REQUEST.total_charge + REQUEST.charge;

	return;

     end charge_for_work;

check_user_access: proc (user_dir, ename, ec);

/* Internal procedure to check that the requestor has at least "r" access to
   the specified segment */

	dcl     user_dir		 char (*) aligned;
	dcl     ename		 char (*) aligned;
	dcl     code		 fixed bin (35);
	dcl     ec		 fixed bin (35);
	dcl     mode		 fixed bin (5);
	dcl     access_class	 bit (72) aligned;

	call hcs_$get_user_effmode (user_dir, ename, REQUEST.requestor, val, mode, code);
	if code ^= 0 then do;
		if code = error_table_$noentry then err_mess = ""; /* simple case, just say no entry */
		else err_mess = "Unable to get user's mode.";
		ec = code;
		return;
	     end;

	if (bit (mode, 5) & "01000"b) = "0"b then do;
		err_mess = "User does not have read access.";
		ec = error_table_$moderr;
		return;
	     end;

	call hcs_$get_access_class (user_dir, ename, access_class, code);
	if code ^= 0 then do;
		err_mess = "Unable to get access class of segment.";
		ec = code;
		return;
	     end;

	if ^read_allowed_ (mseg_message_info.sender_authorization, access_class) then do;
		ec = error_table_$ai_restricted;
		err_mess = "User not allowed to read segment.";
		return;
	     end;

	ec = 0;					/* ok, user passed the checks */

	return;

     end check_user_access;

open_file: proc (user_dir, ename, fcbp, max_comp, code);

	dcl     user_dir		 char (*) aligned;
	dcl     ename		 char (*) aligned;
	dcl     fcbp		 ptr;
	dcl     max_comp		 fixed bin;
	dcl     code		 fixed bin (35);

	dcl     comp_dir		 char (168) aligned;
	dcl     comp_name		 char (32) aligned;
	dcl     type		 fixed bin (2);
	dcl     dir		 fixed bin int static options (constant) init (2);
	dcl     dir_len		 fixed bin;
	dcl     bc		 fixed bin (24);
	dcl     mode		 fixed bin (5);
	dcl     mult_ind		 fixed bin;

	REQUEST.bit_count = 0;

	call hcs_$status_minf (user_dir, ename, 1, type, bc, code); /* see what kind of a thing it is */
	if code ^= 0 then do;
		err_mess = char ("Driver cannot get status of file: " || full_path, length (err_mess));
		return;
	     end;

	if type = dir then /* directory */
	     if bc < 1 then do;			/* it was a directory */
		     code = error_table_$dirseg;
		     return;
		end;
	     else max_comp = bc - 1;			/* MSF - highest component is bitcount less one */
	else max_comp = 0;				/* SSF - highest component is 0 */

	call msf_manager_$open (user_dir, ename, fcbp, code);
	if code ^= 0 then do;
		err_mess = "Unable to open file: " || full_path;
		return;
	     end;

	do mult_ind = 0 to max_comp;			/* now we look at each component */

	     call msf_manager_$get_ptr (fcbp, mult_ind, "0"b, segp, bc, code);
	     if code ^= 0 then do;			/* we failed, don't try to do partial files */
		     call ioa_$rsnnl ("Unable to get pointer to file component: ^d.", err_mess, dir_len, mult_ind);
		     return;
		end;

	     if mult_ind = 0 then start_segp = segp;	/* this is a pointer to the first component */

/*		we got a pointer to something...where is it */
/*		and does the requestor have access to it? */

	     call hcs_$fs_get_path_name (segp, comp_dir, dir_len, comp_name, code);
	     if code ^= 0 then do;
		     err_mess = "Could not get file component pathname.";
		     return;
		end;

	     call check_user_access (comp_dir, comp_name, code);
	     if code ^= 0 then do;			/* he tried to pull a fast one and got caught */
		     err_mess = err_mess || "  " || substr (comp_dir, 1, dir_len) || ">" || comp_name;
						/* most of err_mess was set by check_user_access */
		     return;
		end;

	     if bc < el_size then do;			/* must be at least one element per component */
		     code = error_table_$improper_data_format; /* choose a good error message */
		     err_mess = "Zero length segment: " || substr (comp_dir, 1, dir_len) || ">" || comp_name;
		     return;
		end;

	     REQUEST.bit_count = REQUEST.bit_count + bc;	/* total the bits for accounting */

	     call hcs_$fs_get_mode (segp, mode, code);	/*  make sure daemon has access  */
	     if code ^= 0 then do;
		     err_mess = "Driver process does not have access to segment.";
		     return;
		end;

	     if (bit (mode, 5) & "01000"b) = "0"b then do;
		     err_mess = "Driver process does not have read access to segment.";
		     code = error_table_$moderr;	/* give some access violation code */
		     return;
		end;
	end;


/* Now we know that the file is there and that the requestor has the correct access to it.
   The continued operation of the driver now assumes that the file will remain the same
   until the driver is done.  That is, the access will not change, the number of components will not
   change, and the size of each component will not change.  */


     end open_file;

output_file: proc (ec);

	dcl     ec		 fixed bin (35);	/* you guessed it, error code */

	dcl     bc		 fixed bin (24);
	dcl     comp_no		 fixed bin;	/* current msf component number */
	dcl     max_el		 fixed bin (24);


	ec = 0;					/* clear the error code */

	segp = null;				/* don't try to deactivate */
	comp_no = 0;				/* start at the begining of msf */
	oldmodes = "";
	if REQUEST.line_nbrs then do;
		call iox_$modes (iocbp, "line_nbrs", oldmodes, code);
		if code ^= 0 then do;
			err_mess = "Setting line_nbrs mode";
			return;
		     end;
	     end;

next_comp:					/* done with last component */

	if segp ^= null & privileged then
	     call phcs_$deactivate (segp, (0));		/* so try to deactivate the seg */

	call msf_manager_$get_ptr (fcbp, comp_no, "0"b, segp, bc, ec); /* get ptr to seg */
	if segp = null then do;
		err_mess = "Invalid seg ptr to component.";
		return;
	     end;

	if privileged then /* .. do it (gently if possible) */
	     call phcs_$set_kst_attributes (binary (baseno (segp), 18), addr (ksta), (0));

	iodd_static.segptr = segp;			/* tell signal handler what segment we are using */
	max_el = divide (bc + el_size - 1, el_size, 24, 0); /* see now many elements to write out */

	call iox_$put_chars (iocbp, segp, max_el, ec);	/* This is the actual output of segment */
	iodd_static.segptr = null;			/* not referencing user seg now */
	if ec ^= 0 then do;
		err_mess = "IO error during output of file.";
		return;
	     end;

	if comp_no < max_comp then do;		/* are we at real end of file */
		comp_no = comp_no + 1;		/* go on to the next component */
		go to next_comp;			/* deactivate old and get new */
	     end;

	if REQUEST.line_nbrs then
	     if oldmodes ^= "" then call iox_$modes (iocbp, oldmodes, "", (0));
	if privileged & (REQUEST.copies = REQUEST.copy_no | max_comp > 0) then
	     call phcs_$deactivate (segp, (0));		/* try to deactivate */
	segp = null;

	return;

     end output_file;


driver_fatal_error: proc (code, err_msg);

/* Internal procedure to print messages when there is an IO error on the output stream */

	dcl     code		 fixed bin (35);
	dcl     err_msg		 char (*);

	call iodd_msg_ (error, both, code, id,
	     "^a ^/Driver returning to command level.  Request is deferred.", err_msg);

	desc_ptr -> request_descriptor.dont_delete = "1"b;/* give a reprieve....in case */
	desc_ptr -> request_descriptor.keep_in_queue = "1"b; /* defer it if possible */

	a_code = code;				/* report driver_fatal_error */

	return;

     end driver_fatal_error;

restart_request: proc (source);

/* internal procedure used to question operator regarding the restart of current request */

	dcl     source		 fixed bin;

	dcl     answer		 char (120);
	dcl     cnt_msg		 char (24);	/* space to specify a continued request */
	dcl     copies_good		 fixed bin (35);	/* operator response to number of good copies */
	dcl     nelt		 fixed bin;
	dcl     input_iocbp		 ptr;
	dcl     output_stream	 char (32);
	dcl     code		 fixed bin (35);
	dcl     pg_count_msg	 char (30);	/* space to specify pages per copy */
	dcl     restrt_msg		 char (30);	/* space that the request is to be restarted */


/* set up input/output stream for the master terminal */

	if source = master then do;
		input_iocbp = iodd_static.master_in;
		output_stream = iodd_static.master_output;
	     end;

/* set up input/output stream for the slave terminal */

	else do;
		source = slave;			/* just to be sure */
		input_iocbp = iodd_static.slave.slave_in;
		output_stream = iodd_static.slave.slave_output;
	     end;


/* is there a need to query the operator? */

	if REQUEST.punsw = 1 | print_driver_data.copies_done = 0 | REQUEST.copies = 1 then do;

		restrt_msg = "";
		REQUEST.separator = "1"b;
		print_driver_data.copies_done = 0;

	     end;

	else do;					/* must query operator */

		if REQUEST.page_count > 0 then /* is there a non zero page count? */
		     call ioa_$rsnnl (" (^d pages each)", pg_count_msg, nret, REQUEST.page_count);
		else pg_count_msg = "";

		if REQUEST.continued then /* is this a continued request? */
		     cnt_msg = " (continued request)";
		else cnt_msg = "";

ask_how_many_good:					/* tell operator how many were done */
		call ioa_$ioa_stream (output_stream, "^d of ^d copies^a were done^a.  How many were good?",
		     print_driver_data.copies_done, REQUEST.copies, pg_count_msg, cnt_msg);
						/* now let's see what the operator tells us */
		answer = "";			/* first make the answer all blank */
		call iox_$get_line (input_iocbp, addr (answer), 10, nelt, code);
		if code ^= 0 then do;
			copies_good = 0;
			go to tell_operator;
		     end;

		answer = ltrim (rtrim (answer, NL || " ")); /* remove leading spaces and NL chars */

		copies_good = cv_dec_check_ (answer, code);

		if code ^= 0 then do;		/* was the answer a number? */
bad_no:			call ioa_$ioa_stream (output_stream, "Please specify a number between 0 and ^d",
			     print_driver_data.copies_done);
			go to ask_how_many_good;
		     end;

		if copies_good < 0 | copies_good > print_driver_data.copies_done then go to bad_no;

tell_operator:	print_driver_data.copies_done = copies_good; /* update the record of finished copies */

		if copies_good = 0 then REQUEST.separator = "1"b;

		call ioa_$rsnnl (" from copy number ^d", restrt_msg, nret, copies_good + 1);

	     end;

	call ioa_$ioa_stream (output_stream, "Restarting request^a.", restrt_msg);

	return;

     end restart_request;


clean_proc: proc;

	iodd_static.segptr = null;			/* tell signal handler we are done with it */

	if fcbp ^= null then do;
		if segp ^= null then
		     if privileged then call phcs_$deactivate (segp, (0));
		call msf_manager_$close (fcbp);
	     end;

	segp, fcbp = null;				/* because this is used for several functions */

	return;

     end clean_proc;



error_during_request: entry (cond);			/* for coming back after signal */

	dcl     cond		 char (*);

	fault_name = cond;

	go to err_label;



set_single_copy: entry;

/*  to abort multiple copies if the single command must be used */

	request_data_p -> ordata.copies = 1;		/* make it fall out of the loop after tail sheet */

	return;
%page; %include access_audit_eventflags;
%page; %include access_audit_user_info;
%page; %include dprint_msg;
%page; %include driver_status;
%page; %include iod_tables_hdr;
%page; %include iodd_static;
%page; %include kst_attributes;
%page; %include mseg_message_info;
%page; %include output_request_data;
%page; %include print_driver_data;
%page; %include prt_conv_info;
%page; %include prt_info;
%page; %include prt_order_info;
%page; %include prt_sdb;
%page; %include queue_msg_hdr;
%page; %include request_descriptor;
%page; %include send_mail_info;

     end output_request_;
