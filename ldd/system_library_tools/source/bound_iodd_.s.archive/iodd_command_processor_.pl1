/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

/* format: style4,delnl,insnl,^ifthendo */

/* format: off */

iodd_command_processor_: proc (source, state, command_line, ec);

/* This procedure is called by an io_daemon driver when it's ready
   to process an operator command.  The validity of a command will depend
   on the source terminal and the state of the driver in processing requests.

   state = 0 means that there are no active devices.
   state = 1 means that we were called from iodd_listen_ with devices ready.
   state = 2 means that we were called while processing another command (or??)
   state = 3 means that we were called while processing a request (request command level).
   state = 4 means that we were called after a quit.
   state = 5 means that we were called from the signal handler (test mode)
*/


/* Originally coded as input_cmd_ in August 1973 by Robert S. Coren */
/* Modified and renamed in January 1975 by J. C. Whitmore for generalization and access isolation */
/* Modified in Dec 1975 by J. C. Whitmore for new restart functions & control terminal hangup before detach */
/* Modified in April 1976 by J. C. Whitmore to expand the dcl of ios_ mode variables to 256 */
/* Modified in August 1977 by J. C. Whitmore to extend input "state" and add new ctl_term options */
/* Modified in Nov 1977 by J. C. Whitmore to use iodd_msg_ and add new slave_term option */
/* Modified in May 1978 by J. C. Whitmore to add the x command and minor bug fixes */
/* Modified in July 1978 by J. C. Whitmore to add cmds: restart_q, auto_start_delay, defer, next, defer_time;
   to change the coord communication strategy; and to extend the save and restart commands */
/* Modified in August 1978 by J. C. Whitmore to add slave_term echo cmd and per device admin ec calls */
/* Modified 10/78 by J. C. Whitmore: go bug fix and status attach type 4 */
/* Modified 3/79 by J. C. Whitmore to support "-a" ctl arg to halt command */
/* Modified 6/81 by E. N. Kittlitz for new condition_info structures */
/* Modified January 1984 by C. Marker  Added probe as a legal command in test mode. */
/* Modified February 23, 1985 by C. Marker to use version 5 message segments */


/****^  HISTORY COMMENTS:
  1) change(88-08-19,Brunelle), approve(88-08-19,MCR7911),
     audit(88-10-19,Wallman), install(88-10-28,MR12.2-1199):
     Upgraded to version 5 iod tables.  Status command fixed to handle long
     minor device names.
                                                   END HISTORY COMMENTS */


/* format: on */

/*	ARGUMENTS	*/

dcl  source fixed bin;
dcl  state fixed bin;
dcl  command_line char (*);
dcl  ec fixed bin (35);


/*	AUTOMATIC		*/

dcl  att_desc char (64);
dcl  code fixed bin (35);
dcl  command char (256) aligned;			/* for the x command line to the command processor */
dcl  change_data bit (1);				/* flag for ok to change info */
dcl  dr_ptr ptr;
dcl  desc_ptr ptr;
dcl  ec_name char (32);
dcl  segp ptr;
dcl  lg_sw bit (1) aligned;				/* long option switch as needed */
dcl  number fixed bin (35);
dcl  msgp ptr;
dcl  err_mess char (128);
dcl  error_flag bit (1);
dcl  message char (64);				/* general message string */
dcl  what char (16);
dcl  mode char (256);
dcl  omode char (256);
dcl  i fixed bin;
dcl  idx fixed bin;
dcl  len fixed bin;
dcl  tried_once bit (1);
dcl  person char (24);
dcl  project char (24);
dcl  restart_series fixed bin (35);
dcl  seq_id fixed bin (35);
dcl  series fixed bin (35);
dcl  series_sw bit (1);
dcl  device_id_length fixed bin;
dcl  req_type_label_length fixed bin;

dcl  io_stat bit (72) aligned;

dcl  1 st aligned based (addr (io_stat)),
       2 code fixed bin (35),
       2 junk bit (36);

dcl  1 arg_list aligned,				/* structure of parsed command line tokens */
       2 max_args fixed bin init (21),			/* the amount of storage we allocated */
       2 n fixed bin,
       2 cmd char (64) var,				/* first token is always the command */
       2 args (20) char (64) var;			/* up to 20 args per command */

dcl  1 ev_chan_list aligned,				/* IPC event list for coord communication */
       2 number fixed bin,				/* number of channels in list (we use 2) */
       2 pad fixed bin,
       2 chan (2) fixed bin (71);

dcl  1 event_info aligned,				/* info returned from ipc_$block */
       2 chan fixed bin (71),				/* channel wakeup came in on */
       2 msg fixed bin (71),				/* event message from sender */
       2 sender bit (36),				/* proc id of sender */
       2 origin fixed bin,				/* junk - ring, or device flag, or ? */
       2 wait_list_idx fixed bin;			/* index of chan in ev_chan_list */

dcl  1 option aligned,				/* control option bits for next command */
       2 dev bit (1) unal,
       2 q bit (1) unal,
       2 user bit (1) unal,
       2 id bit (1) unal,
       2 et bit (1) unal,
       2 pn bit (1) unal;

dcl  1 cond_info aligned like condition_info;

/*	BASED VARIABLES	*/

dcl  sys_dir char (168) aligned based;			/* string for the variable in iodd_'s static */
dcl  floating float bin based;			/* for the convert builtin */
dcl  fixed_bin fixed bin based;			/*   "  "  "  */
dcl  fixed_bin_35 fixed bin (35) based;			/*   "  "  "  */


/*	CONSTANTS		*/

dcl  master fixed bin int static init (1) options (constant);
						/* constant indicating the master device */
dcl  slave fixed bin int static init (2) options (constant);/* constant indicating the slave device */
dcl  both fixed bin int static init (0) options (constant); /* both the salve and master */
dcl  normal fixed bin int static init (1) options (constant);
dcl  whoami char (24) int static options (constant) init ("iodd_command_processor_");
dcl  null_cmd_level fixed bin int static options (constant) init (0);
						/* command level of state 0 */
dcl  listen_cmd_level fixed bin int static options (constant) init (1);
						/* command level of state 3 */
dcl  quit_cmd_level fixed bin int static options (constant) init (4);
						/* command level of state 4 */
dcl  signal_cmd_level fixed bin int static options (constant) init (5);
						/* command level of state 5 */
dcl  null_stream char (32) int static options (constant) init ("iodd_null_stream");
dcl  unknown_cmd_code fixed bin (35) int static options (constant) init (1239);
dcl  bad_chars char (5) int static options (constant) init ("([]);");
dcl  chn_type (4) char (8) int static options (constant) init ("iom ch", "tty ch", "dial id", "tty ch");


/*	ENTRIES		*/

dcl  continue_to_signal_ entry (fixed bin (35));
dcl  convert_ipc_code_ entry (fixed bin (35));
dcl  cu_$cp entry (ptr, fixed bin, fixed bin (35));
dcl  debug entry;
dcl  find_condition_info_ entry (ptr, ptr, fixed bin (35));
dcl  logout entry ();
dcl  hcs_$initiate entry (char (*) aligned, char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
dcl  hcs_$wakeup entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
dcl  iodd_msg_ entry options (variable);
dcl  (
     ioa_,
     ioa_$rsnnl
     ) entry options (variable);
dcl  ios_$detach entry (char (*) aligned, char (*) aligned, char (*) aligned, bit (72) aligned);
dcl  ios_$attach entry (char (*) aligned, char (*) aligned, char (*) aligned, char (*), bit (72) aligned);
dcl  ios_$order entry (char (*) aligned, char (*), ptr, bit (72) aligned);
dcl  ios_$changemode entry (char (*) aligned, char (*), char (*), bit (72) aligned);
dcl  iox_$attach_ptr entry (ptr, char (*), ptr, fixed bin (35));
dcl  iox_$control entry (ptr, char (*), ptr, fixed bin (35));
dcl  iox_$detach_iocb entry (ptr, fixed bin (35));
dcl  iodd_parse_$command entry (char (*), ptr, fixed bin (35));
dcl  iodc_$command_level entry ();
dcl  message_segment_$add_file entry (char (*) aligned, char (*), ptr, fixed bin (24), bit (72) aligned, fixed bin (35));
dcl  probe entry ();
dcl  timer_manager_$alarm_wakeup entry (fixed bin (71), bit (2), fixed bin (71));
dcl  timer_manager_$reset_alarm_wakeup entry (fixed bin (71));
dcl  ipc_$drain_chn entry (fixed bin (71), fixed bin (35));
dcl  ipc_$block entry (ptr, ptr, fixed bin (35));

/*	BUILTINS		*/

dcl  (addr, fixed, index, divide, stac, convert, null, substr, before, after, string, mod, rtrim, length, search,
     currentsize, unspec, float, verify) builtin;


/*	EXTERNAL  STATIC	*/

dcl  error_table_$noarg fixed bin (35) ext static;
dcl  error_table_$noentry fixed bin (35) ext static;
dcl  error_table_$namedup fixed bin (35) ext static;
dcl  error_table_$action_not_performed fixed bin (35) ext static;
dcl  error_table_$request_not_recognized fixed bin (35) ext static;

dcl  iox_$user_output ptr ext;
dcl  iox_$user_input ptr ext;
dcl  iox_$error_output ptr ext;


/*	CONDITIONS		*/

dcl  (conversion, no_coord, re_init, daemon_logout, daemon_slave_logout, daemon_again, daemon_cancel, daemon_kill,
     daemon_new_device, daemon_again_slave, program_interrupt, daemon_defer, resume, size) condition;

dcl  (any_other, cleanup, daemon_save) condition;

/* include file no longer declares version 5 */

dcl  cq_info_version_5 fixed bin int static init (5);

dcl  coord_msg (50) fixed bin (71) aligned;		/* this is the last dcl to make indent happy */
						/* must hold iodd_comm but PL/I will not allow */
						/* us to set the size to the size (iodd_comm) */

/*	START OF MAIN PROGRAM	*/


	comm_ptr = addr (coord_msg);			/* get ready for special commands */

	on conversion
	     begin;
	     call iodd_msg_ (normal, source, 0, "", "Argument conversion error. Try again.");
	     go to ignore;
	end;

	on size
	     begin;
	     call iodd_msg_ (normal, source, 0, "", "Argument numerical size error. Try again.");
	     go to ignore;
	end;

	call iodd_parse_$command (command_line, addr (arg_list), ec);
						/* see what he said */
	if ec ^= 0
	then do;
	     if ec = error_table_$noarg
	     then do;				/* just a blank line */
ignore:
		ec = 0;				/* don't force a reset read */
		return;
	     end;
	     err_mess = "Unable to parse command line.";
error:
	     call iodd_msg_ (normal, source, 0, "", "^a driver: ^a", iodd_static.major_device, err_mess);
	     return;
	end;

/* Now the command and all the arguments are in the arg_list structure */

/* find which command it is and branch to the correct label */


	if cmd = "."
	then go to ignore;				/* just ask for a command */

/*  The full list of commands is getting long, so start on the next page */

/* Here is the real list of commands for the standard driver */

/* All commands must be accepted without the undersocre character for remote devices. */


	if cmd = "auto_start_delay" | cmd = "autostartdelay"
	then go to auto_start_delay_command;
	if cmd = "cancel"
	then go to cancel_command;
	if cmd = "coord"
	then go to coord_command;
	if cmd = "ctl_term" | cmd = "ctlterm"
	then go to ctl_term_command;
	if cmd = "debug"
	then go to debug_command;
	if cmd = "defer"
	then go to defer_command;
	if cmd = "defer_time" | cmd = "defertime"
	then go to defer_time_command;
	if cmd = "go"
	then go to go_command;
	if cmd = "halt"
	then go to halt_command;
	if cmd = "help"
	then go to help_command;
	if cmd = "hold"
	then go to hold_command;
	if cmd = "inactive_limit" | cmd = "inactivelimit"
	then go to inactive_limit_command;
	if cmd = "kill"
	then go to kill_command;
	if cmd = "logout"
	then go to logout_command;
	if cmd = "master"
	then go to master_command;
	if cmd = "new_device" | cmd = "newdevice"
	then go to new_device_command;
	if cmd = "next"
	then go to next_command;
	if cmd = "pi"
	then go to pi_command;
	if cmd = "probe" | cmd = "pb"
	then go to probe_command;
	if cmd = "ready"
	then go to ready_command;
	if cmd = "reinit"
	then go to reinit_command;
	if cmd = "release" | cmd = "rl"
	then go to release_command;
	if cmd = "restart"
	then go to restart_command;
	if cmd = "restart_q" | cmd = "restartq"
	then go to restart_q_command;
	if cmd = "resume"
	then go to resume_command;
	if cmd = "return"
	then go to return_command;
	if cmd = "save"
	then go to save_command;
	if cmd = "slave"
	then go to slave_command;
	if cmd = "slave_term" | cmd = "slaveterm"
	then go to slave_term_command;
	if cmd = "start"
	then go to start_command;
	if cmd = "status"
	then go to status_command;
	if cmd = "step"
	then go to step_command;
	if cmd = "x"
	then go to x_command;

/*	The command is not implemented here.  See if the driver module wants it. */

	ec = unknown_cmd_code;			/* set to an unlikely value in case driver module just returns */
	err_mess = "Invalid command for driver - " || cmd;

pass_on:
	call iodd_static.driver_command (source, state, addr (arg_list), ec);

	if ec = unknown_cmd_code
	then go to error;				/* no one home...other errors were already reported */
	if ec = 1 | ec = 2
	then ec = 0;				/* driver module cannot force a continue */
	return;					/* clean return for a valid driver_module command */

/* **************************************************************************************** */

/*	This is where the real work starts.  One label for each command.  */


auto_start_delay_command:
	if arg_list.n > 1
	then do;					/* set the value */
	     number = convert (fixed_bin, args (1));	/* make it fixed bin */
	     if number < 30
	     then do;				/* this is the lower limit */
		call iodd_msg_ (normal, source, 0, "", "The lower limit for the delay time is 30 seconds.");
		return;
	     end;
	     iodd_static.auto_start_delay = number;
	end;

	call iodd_msg_ (normal, source, 0, "", "The auto start delay is:  ^d seconds.", iodd_static.auto_start_delay);
	return;


cancel_command:
	what = "cancel";				/* make next section common with the kill command */

cancel_or_kill:
	if source = slave
	then if iodd_static.master_hold
	     then do;
		err_mess = "Driver in hold by master terminal.";
		go to error;
	     end;

	if iodd_static.request_in_progress
	then do;					/* can only kill or cancel active request */
	     dr_ptr = iodd_static.driver_ptr;		/* find the current request number */
	     desc_ptr = addr (dr_ptr -> driver_status.descriptor);
	     desc_ptr -> request_descriptor.dont_delete = "1"b;
						/* cancel any delete option, just in case */
	     iodd_static.master_hold = "0"b;		/* already 0 if not the master */
	     iodd_static.slave_hold = "0"b;		/* both MBZ for next command level */
	     call iox_$control (iodd_static.master_in, "start", null, ec);
						/* avoid lost wakeups */
	     if iodd_static.slave.active
	     then call iox_$control (iodd_static.slave_in, "start", null, ec);
	     if what = "cancel"
	     then do;
		desc_ptr -> request_descriptor.cancelled = "1"b;
						/* mark the request */
		signal daemon_cancel;		/* let the driver module clean out */
	     end;
	     else signal daemon_kill;			/* the other action */
	     return;
	end;

	err_mess = "No current request to " || what;
	go to error;


coord_command:					/* for calling coord command level when testing */
						/* coord and driver in one process */
	if iodd_static.test_entry
	then if source = master
	     then do;				/* only the master can do this */

		call iodc_$command_level ();		/* coord will do its own i/o */

		call iox_$control (iodd_static.master_in, "start", null, ec);
						/* just to be safe */

		return;
	     end;

	err_mess = "The coord command is for master terminal test mode only.";
	go to error;


ctl_term_command:
	if arg_list.n < 2
	then do;					/* must be one arg to the command */
	     err_mess = "Expected argument missing.";
	     go to error;
	end;

	if ^iodd_static.ctl_term.attached
	then do;					/* there must be one attached */
	     err_mess = "Control terminal not attached.";
	     go to error;
	end;

	if args (1) = "detach"
	then do;					/* drop the thing forever */
	     if source = master
	     then do;				/* if the master says so */
		call ios_$order (iodd_static.ctl_io, "hangup", null, io_stat);
						/* give back to answering service */
		if (iodd_static.slave_output = iodd_static.ctl_output) & iodd_static.slave.active
		then do;
		     iodd_static.slave.active = "0"b;	/* it was also the slave..drop it too */
		     call ios_$attach ("error_output", "syn", "error_i/o", "", io_stat);
						/* don't forget this */
		     call ios_$detach ("broadcast_errors", iodd_static.slave_output, "", io_stat);
		     iodd_static.slave.allow_quits = "0"b;
		     iodd_static.slave.print_errors = "0"b;
		     iodd_static.slave.log_msg = "0"b;
		     iodd_static.slave.accept_input = "0"b;
		     iodd_static.slave_out = null;	/* cancel the iocb ptrs too */
		     iodd_static.slave_in = null;
		     iodd_static.slave_output = null_stream;
		     iodd_static.slave_input = null_stream;
		end;
		call ios_$detach (iodd_static.ctl_io, "", "", io_stat);
		call ios_$detach (iodd_static.ctl_output, "", "", io_stat);
		call ios_$detach (iodd_static.ctl_input, "", "", io_stat);
		iodd_static.ctl_term.attached = "0"b;
		iodd_static.ctl_term.forms = "0"b;
		iodd_static.ctl_output = null_stream;
		iodd_static.ctl_input = null_stream;
		iodd_static.ctl_io = null_stream;
		return;
	     end;					/* all cleared out now */
	     err_mess = "Only the master terminal can detach the control terminal.";
	     go to error;

	end;

	if args (1) = "simulate"
	then do;					/* initiate terminal FF simulation */

	     if ^iodd_static.forms
	     then do;				/* be sure we are not already doing so */
		iodd_static.ctl_term.ctl_dev_dim = "form_";
						/* record the new dim name */
		call ios_$attach (iodd_static.ctl_output, "form_", iodd_static.ctl_io, "", io_stat);
						/* was using "syn" */
		call ios_$attach (iodd_static.ctl_input, "form_", iodd_static.ctl_io, "", io_stat);
		if st.code ^= 0
		then do;				/* errors??? */
		     ec = st.code;
		     call iodd_msg_ (normal, both, ec, whoami, "Driver goes into master hold.");
		     iodd_static.master_hold = "1"b;
		     return;
		end;

		iodd_static.forms = "1"b;		/* this is the important part */

		call iodd_msg_ (normal, source, 0, "", "Forms will have to be aligned.");

		return;
	     end;

	     err_mess = "Already simulating forms.";	/* someone goofed */
	     go to error;
	end;

	if args (1) = "aligned"
	then do;

	     if iodd_static.forms
	     then do;				/* only when simulating */
		call ios_$order (iodd_static.ctl_output, "form_aligned", null, io_stat);
		if st.code ^= 0
		then do;
		     ec = st.code;
		     call iodd_msg_ (normal, both, ec, whoami, "Driver goes into master hold.");
		     iodd_static.master_hold = "1"b;
		end;
		return;
	     end;

	     err_mess = "Driver not simulating forms.";
	     go to error;
	end;

/*	The remaining functions of this command require an additional argument */

	if arg_list.n < 3
	then do;					/* one check for all command keywords */
	     err_mess = "Invalid ctl_term command request:" || substr (command_line, 9);
	     go to error;
	end;

	if args (1) = "form_type" | args (1) = "formtype"
	then do;

	     if args (2) = "default"
	     then do;				/* we can't really set the default here */
		iodd_static.form_type = "undefined_form";
						/* so do what we can and then... */
		go to pass_on;			/* see if the driver_module wants to change it */
	     end;

	     if args (2) = "none"
	     then iodd_static.form_type = "undefined";	/* special type to supress forms */
	     else iodd_static.form_type = args (2);	/* gobble it up...we'll check it later */

	     return;
	end;

	if args (1) = "modes"
	then do;					/* change the modes of the output stream */

	     mode = args (2);			/* copy them to fixed length string */
	     omode = "not returned";			/* just to make the message clear */

	     call ios_$changemode (iodd_static.ctl_output, mode, omode, io_stat);
	     if st.code ^= 0
	     then do;				/* OOPS */
		ec = st.code;			/* report the error */
		call iodd_msg_ (normal, both, ec, whoami, "Driver goes into master hold.");
		iodd_static.master_hold = "1"b;
	     end;

	     call iodd_msg_ (normal, source, 0, "", "Mode was: ^a", omode);

	     return;
	end;

	if args (1) = "page_length" | args (1) = "pagelength"
	then do;
	     if ^iodd_static.forms
	     then do;				/* must be simulating paging */
		err_mess = "Driver not simulating forms.";
		go to error;
	     end;

	     i = convert (fixed_bin, args (2));

	     call ios_$order (iodd_static.ctl_output, "page_length", addr (i), io_stat);
	     if st.code ^= 0
	     then do;
		ec = st.code;
		call iodd_msg_ (normal, both, ec, whoami, "Driver goes into master hold.");
		iodd_static.master_hold = "1"b;
	     end;

	     return;
	end;

	err_mess = "Undefined ctl_term request:" || substr (command_line, 9);
	go to error;


debug_command:
	if source = master
	then if iodd_static.test_entry
	     then do;

		call iodd_msg_ (normal, master, 0, "", "Calling debug");
						/* give reassuring message */
		call debug ();
		return;
	     end;

	err_mess = "The debug command is for master terminal test mode only.";
	go to error;


defer_command:
	if iodd_static.request_in_progress
	then do;
	     desc_ptr = addr (iodd_static.driver_ptr -> driver_status.descriptor);
	     if desc_ptr -> request_descriptor.restarted
	     then do;

		err_mess = "Request was restarted and is no longer in the queue. Use ""save"".";
		go to error;
	     end;
	     if source = slave
	     then if iodd_static.master_hold
		then do;				/* don't interrupt the master */
		     err_mess = "Driver in hold by master terminal.";
		     go to error;
		end;
	     desc_ptr -> request_descriptor.finished = "1"b;
	     desc_ptr -> request_descriptor.keep_in_queue = "1"b;
	     call iox_$control (iodd_static.master_in, "start", null, ec);
						/* avoid lost wakeups */
	     if iodd_static.slave.active
	     then call iox_$control (iodd_static.slave_in, "start", null, ec);
	     signal daemon_defer;			/* tell the driver module (or subr ) */
	     return;
	end;
	err_mess = "No current request to defer.";
	go to error;


defer_time_command:
	if arg_list.n = 1
	then do;					/* command and no args */
	     if iodd_static.assigned_devices > 1
	     then do;				/* ambiguous */
		err_mess = "Multiple minor devices require a second argument - dev.";
		go to error;
	     end;
	     change_data = "0"b;			/* can only give current values */
	     dr_ptr = iodd_static.driver_ptr;		/* only one driver status seg */
	end;
	else if arg_list.n = 2
	then do;					/* one arg case dev or number */
	     if iodd_static.assigned_devices = 1 & verify (args (1), "1234567890.") = 0
	     then change_data = "1"b;			/* looks like a real number and its legal */
	     else change_data = "0"b;			/* must be a device id */

	     if ^change_data
	     then do;
		call find_minor_dev (args (1), dr_ptr, code);
		if code ^= 0
		then go to error;
	     end;
	     else do;
		what = args (1);			/* store the value to be converted */
		dr_ptr = iodd_static.driver_ptr;	/* must be current driver status seg */
	     end;
	end;
	else do;					/* 3 args case (don't look at any more) */
	     call find_minor_dev (args (1), dr_ptr, code);
	     if code ^= 0
	     then go to error;
	     change_data = "1"b;			/* there must be a time value */
	     what = args (2);			/* in the second argument */
	end;

	if ^change_data
	then do;					/* no data, just print current values */
	     if dr_ptr -> driver_status.defer_time_limit = 0
	     then message = "No auto defer time limit has been set.";
	     else call ioa_$rsnnl ("Auto defer time limit:  ^.1f minutes", message, i,
		     float (dr_ptr -> driver_status.defer_time_limit) / 60.0e0);

	     number = dr_ptr -> driver_status.bit_rate_est;
						/* get the xfr rate */

	     call iodd_msg_ (normal, source, 0, "",
		"^a^/Current transfer rate:  ^[^d bits/sec (^d chars/sec)^;undefined^s^s^]", message, (number > 0),
		number, divide (number, 9, 17));
	     return;				/* and we're done */
	end;

	number = fixed (convert (floating, what) * 60);	/* input is in minutes, store as seconds */
	if number < 10
	then number = 0;
	dr_ptr -> driver_status.defer_time_limit = number;

	call iodd_msg_ (normal, source, 0, "", "Changing auto defer time limit to:  ^[^.1f minutes^;no limit^s^]",
	     (number > 0), float (number) / 60.0e0);

	return;


go_command:					/* start processing requests */
	if state > listen_cmd_level
	then do;
	     err_mess = "The go command is not valid at this command level.";
	     go to error;
	end;

	if state = null_cmd_level & ^iodd_static.runout_requests
	then do;
	     err_mess = "No ready device.";
	     go to error;
	end;

	if source = slave & iodd_static.master_hold
	then do;
	     err_mess = "Driver in hold by master terminal.";
	     go to error;
	end;

	if arg_list.n = 1
	then iodd_static.requests_til_cmd = 0;
	else do;					/* operator wants to go for N requests */
	     if iodd_static.step
	     then do;
		err_mess = "The go command cannot recognize a number while in step mode.";
		go to error;
	     end;
	     i = convert (fixed_bin, args (1));		/* get the N as fixed bin */
	     if i < 1
	     then do;				/* a real value? */
		err_mess = "Invalid number of requests specified: " || args (1);
		go to error;
	     end;

	     iodd_static.requests_til_cmd = i;		/* OK, use the new value */
	end;

	iodd_static.master_hold = "0"b;
	iodd_static.slave_hold = "0"b;
	ec = 1;					/* give the "go" code */
	return;					/* let 'er rip */


halt_command:
	list_ptr = iodd_static.driver_list_ptr;		/* make the reference easier */

	if arg_list.n < 2
	then do;					/* no arguments */
	     if iodd_static.assigned_devices = 1
	     then call halt_all;			/* only legal for the one device case */
	     else do;				/* give error msg */
		err_mess = "Multiple minor devices require an argument.";
		go to error;
	     end;
	end;

	else do;					/* there were args ... check them */
	     if args (1) = "-all" | args (1) = "-a"
	     then call halt_all;			/* ctl arg must be first arg */
	     else do i = 1 to arg_list.n - 1;		/* only devices given ... search for them */

		call find_minor_dev (args (i), dr_ptr, code);
		if code = 0
		then do;
		     if dr_ptr -> driver_status.ready
		     then iodd_static.current_devices = iodd_static.current_devices - 1;
						/* reduce count */
		     dr_ptr -> driver_status.ready = "0"b;
						/* turn off the ready flag to stop driver */
		     if ^stac (addr (dr_ptr -> driver_status.request_pending), iodd_static.driver_proc_id)
		     then if dr_ptr -> driver_status.request_pending = iodd_static.coord_proc_id
			then do;
			     call iodd_msg_ (normal, source, 0, "", "Pending request for device ""^a""", args (i));
			     iodd_static.runout_requests = "1"b;
			end;
		end;
		else call iodd_msg_ (normal, source, 0, "", "Minor device ""^a"" not assigned.", args (i));
	     end;					/* look for next device arg */
	end;

	if iodd_static.runout_requests
	then do;					/* there was a pending request */
	     call iodd_msg_ (normal, source, 0, "", "Pending requests for halted devices will be processed.");
	     if state <= listen_cmd_level
	     then do;				/* avoid resetting after a quit */
		if source = master
		then iodd_static.master_hold = "0"b;	/* can we go? */
		if iodd_static.master_hold
		then do;
		     err_mess = "Driver in hold by master terminal.";
		     go to error;
		end;
		iodd_static.slave_hold = "0"b;	/* don't come back for another command until done */
		ec = 1;				/* do an automatic "go" from normal command level */
		return;
	     end;
	     return;
	end;

	if iodd_static.current_devices = 0
	then do;					/* nothing to run */
	     err_mess = "All devices are halted.";
	     go to error;
	end;
	return;


help_command:					/*	Put in a 1 line syntax description for each legal command */
	call iodd_msg_ (normal, source, 0, "", "^/** Standard Driver Commands **^/");
						/* title */

	call iodd_msg_ (normal, source, 0, "", "auto_start_delay [seconds]");
	call iodd_msg_ (normal, source, 0, "", "cancel");
	call iodd_msg_ (normal, source, 0, "", "ctl_term   <function>  [<function_value>]");
	call iodd_msg_ (normal, source, 0, "", "defer");
	call iodd_msg_ (normal, source, 0, "", "defer_time [dev] [mins]");
	call iodd_msg_ (normal, source, 0, "", "go [N]");
	call iodd_msg_ (normal, source, 0, "", "halt    (<dev1>...<devn>) | (-a|-all)");
	call iodd_msg_ (normal, source, 0, "", "hold");
	call iodd_msg_ (normal, source, 0, "", "inactive_limit [<minutes>]");
	call iodd_msg_ (normal, source, 0, "", "kill");
	call iodd_msg_ (normal, source, 0, "", "logout");
	call iodd_msg_ (normal, source, 0, "", "master  <message for master terminal>");
	call iodd_msg_ (normal, source, 0, "", "new_device");
	call iodd_msg_ (normal, source, 0, "", "next -user <pers.proj> -id ID -pn <path> -et <entry> -dev <dev>");
	call iodd_msg_ (normal, source, 0, "", "ready   (<dev1>...<devn>) | (-a|-all)");
	call iodd_msg_ (normal, source, 0, "", "reinit");
	call iodd_msg_ (normal, source, 0, "", "release | rl");
	call iodd_msg_ (normal, source, 0, "", "restart [<request_no> | -from <request_no>]");
	call iodd_msg_ (normal, source, 0, "", "restart_q [<minor_dev>]");
	call iodd_msg_ (normal, source, 0, "", "save    [<request_no> | -from <request_no>]");
	call iodd_msg_ (normal, source, 0, "", "slave   <message for slave terminal>");
	call iodd_msg_ (normal, source, 0, "", "slave_term <function>");
	call iodd_msg_ (normal, source, 0, "", "start");
	call iodd_msg_ (normal, source, 0, "", "status [-lg]");
	call iodd_msg_ (normal, source, 0, "", "step    [set|reset]");
	call iodd_msg_ (normal, source, 0, "", "x <site defined key> [<args>]");

	if iodd_static.test_entry
	then do;					/* only give the test commands in test mode */
	     call iodd_msg_ (normal, source, 0, "", "^/** Test Mode Commands **^/");
	     call iodd_msg_ (normal, source, 0, "", "coord");
	     call iodd_msg_ (normal, source, 0, "", "debug");
	     call iodd_msg_ (normal, source, 0, "", "probe");
	     call iodd_msg_ (normal, source, 0, "", "pi");
	     call iodd_msg_ (normal, source, 0, "", "resume");
	     call iodd_msg_ (normal, source, 0, "", "return");
	end;

	call driver_command (source, state, addr (arg_list), ec);

	call iodd_msg_ (normal, source, 0, "", "");	/* separate from command request */
	return;


hold_command:
	if source = slave
	then iodd_static.slave_hold = "1"b;		/* master hold will override */
	if source = master
	then iodd_static.master_hold = "1"b;
	return;


inactive_limit_command:
	if arg_list.n > 1
	then do;					/* new limit data? */
	     number = convert (fixed_bin, args (1));	/* get the value as fixed bin */
	     if number < 0 | number > 200
	     then do;
		err_mess = "Unreasonable inactivity time limit value: " || args (1) || " minutes";
		go to error;
	     end;

	     if number > 0
	     then do;				/* if not reseting, must be long enough for coord response */
		i = divide (2 * iodd_static.wakeup_time + 59, 60, 17);
						/* minutes for at least 2 wakeup intervals */
		if number < i
		then do;
		     call iodd_msg_ (normal, source, 0, "",
			"The minimum inactivity time limit for this driver is ^d minute^[s^], or zero to reset.", i,
			i > 1);
		     return;
		end;
	     end;

	     iodd_static.auto_logout_interval = number * 60;
						/* store as seconds for timer_manager_ */
	end;

	number = divide (iodd_static.auto_logout_interval, 60, 17);
						/* get current value as minutes */

	if number = 0
	then call iodd_msg_ (normal, source, 0, "", "Driver will not logout for inactivity.");
	else call iodd_msg_ (normal, source, 0, "",
		"Driver will automatically logout after ^d minute^[s^] of inactivity.", number, number > 1);

	return;


kill_command:
	what = "kill";				/* ready to make use of common code with cancel */

	go to cancel_or_kill;			/* see the cancel command */


logout_command:
	if source = master
	then iodd_static.master_hold = "0"b;

	if iodd_static.master_hold
	then do;
	     err_mess = "Cannot logout while driver in hold by master terminal.";
	     go to error;
	end;

	if arg_list.n > 1
	then if arg_list.args (1) ^= "-force"
	     then do;				/* recognize the obsolete arg */
		err_mess = "Invalid argument to logout command:  " || arg_list.args (1);
		go to error;
	     end;

	if source = slave
	then call iodd_msg_ (normal, master, 0, "", "Driver logout received from slave.");
	if iodd_static.slave.active
	then do;
	     call iodd_msg_ (normal, slave, 0, "", "^/Driver is logging out.^/");
	     call iox_$control (iodd_static.slave_out, "runout", null, ec);
	end;

	if (source = slave) & ^iodd_static.ctl_term.attached
						/* use special signal for remote slave */
	then signal daemon_slave_logout;		/* in case the driver module wants it */
	signal daemon_logout;			/* normal logout for the master or control terminal */
	return;					/* just to be tidy */


master_command:					/* slave wants to send master a message */
	if source = slave
	then do;
	     call iodd_msg_ (normal, master, 0, "From slave", substr (command_line, index (command_line, "master") + 6))
		;
	     return;
	end;
	call iodd_msg_ (normal, master, 0, "", "Invalid command for master terminal.");
						/* master talking to itself?? */
	return;


new_device_command:
	if source ^= master
	then do;					/* this one is restricted to the master */
	     err_mess = "The new_device command is valid from the master terminal only.";
	     go to error;
	end;

	if iodd_static.slave.active
	then call iodd_msg_ (normal, slave, 0, "", "^/Driver process changing to new device.^/");

	signal daemon_new_device;			/* if halt ran to completion, we are all set */
						/* if operator "QUIT" let it pass any way */
	return;

next_command:
	if iodd_static.assigned_devices = 1
	then number = 4;
	else number = 6;

	if arg_list.n < number + 1
	then do;
	     call ioa_$rsnnl ("Too few args. Specify -user <user> [-entry, -path or -id] <name> ^[-dev <minor_dev>^]",
		err_mess, len, (number = 6));
	     go to error;
	end;

	if mod (arg_list.n, 2) = 0
	then do;					/* must have command plus even number of args */
	     err_mess = "Arguments must be given in pairs.";
	     go to error;
	end;

	error_flag = ""b;
	string (option) = ""b;			/* clear the given option flags */
	coord_msg (*) = 0;				/* clear the message */
	iodd_comm.req_id = "";			/* set the char string which is optional */

	do idx = 1 to arg_list.n - 1 by 2;		/* go through the args */

	     if args (idx) = "-queue" | args (idx) = "-q"
	     then do;				/* OPTION = -queue */
		if option.q
		then do;
		     error_flag = "1"b;
		     call iodd_msg_ (normal, source, 0, "", "The -queue control argument can only be given once.");
		end;
		else do;
		     option.q = "1"b;		/* mark it as given */
		     if substr (args (idx + 1), 1, 1) = "-"
		     then go to bad_order;		/* was it an option? */
		     iodd_comm.queue_no = convert (fixed_bin, args (idx + 1));
		     if iodd_comm.queue_no < 1 | iodd_comm.queue_no > 4
		     then do;
			error_flag = "1"b;
			call iodd_msg_ (normal, source, 0, "", "Invalid queue number - ^a", args (idx + 1));
		     end;
		end;
	     end;
	     else if args (idx) = "-entry" | args (idx) = "-et"
	     then do;				/* OPTION = -entry */
		if option.pn
		then do;
		     error_flag = "1"b;
		     call iodd_msg_ (normal, source, 0, "", "The -entry and -path control args are incomaptible.");
		end;
		else if option.et
		then do;
		     error_flag = "1"b;
		     call iodd_msg_ (normal, source, 0, "", "The -entry control argument can only be given once.");
		end;
		else do;				/* OK to use it */
		     option.et = "1"b;		/* mark it */
		     if substr (args (idx + 1), 1, 1) = "-"
		     then go to bad_order;		/* was it an option? */
		     iodd_comm.data_len = length (args (idx + 1));
		     iodd_comm.data = args (idx + 1);
		end;
	     end;
	     else if args (idx) = "-path" | args (idx) = "-pn"
	     then do;				/* OPTION = -path */
		if option.et
		then do;
		     error_flag = "1"b;
		     call iodd_msg_ (normal, source, 0, "", "The -path and -entry control args are incompatible.");
		end;
		else if option.pn
		then do;
		     error_flag = "1"b;
		     call iodd_msg_ (normal, source, 0, "", "The -path control argument can only be given once.");
		end;
		else do;				/* OK to use it */
		     option.pn = "1"b;		/* mark it */
		     if substr (args (idx + 1), 1, 1) = "-"
		     then go to bad_order;		/* was it an option? */
		     iodd_comm.data_len = length (args (idx + 1));
		     iodd_comm.data = args (idx + 1);
		     if substr (args (idx + 1), 1, 1) ^= ">"
		     then do;
			error_flag = "1"b;
			call iodd_msg_ (normal, source, 0, "", "Full pathname must be given: ^a", args (idx + 1));
		     end;
		end;
	     end;
	     else if args (idx) = "-id"
	     then do;				/* OPTION = -id */
		if option.id
		then do;
		     error_flag = "1"b;
		     call iodd_msg_ (normal, source, 0, "", "The -id control argument can only be given once.");
		end;
		else do;				/* OK to use it */
		     option.id = "1"b;		/* mark it as used */
		     if substr (args (idx + 1), 1, 1) = "-"
		     then go to bad_order;		/* was it an option? */
		     iodd_comm.req_id = args (idx + 1);
		     if verify (iodd_comm.req_id, "0123456789. ") > 0
		     then do;
			error_flag = "1"b;
			call iodd_msg_ (normal, source, 0, "", "Invalid request id: ^a", iodd_comm.req_id);
		     end;
		end;
	     end;
	     else if args (idx) = "-user"
	     then do;				/* OPTION = -user */
		if option.user
		then do;
		     error_flag = "1"b;
		     call iodd_msg_ (normal, source, 0, "", "The -user control argument can only be given once.");
		end;
		else do;				/* OK record the user name */
		     option.user = "1"b;
		     if substr (args (idx + 1), 1, 1) = "-"
		     then go to bad_order;		/* was it an option? */
		     person = before (args (idx + 1), ".");
		     project = before (after (args (idx + 1), "."), ".");
						/* in case the tag was given */
		     if person = "" | project = ""
		     then do;			/* not nice */
			error_flag = "1"b;
			call iodd_msg_ (normal, source, 0, "", "The full person and project names must be given.");
		     end;
		     iodd_comm.user_id = rtrim (person) || "." || project;
		end;
	     end;
	     else if args (idx) = "-device" | args (idx) = "-dev"
	     then do;				/* OPTION = -device */
		if option.dev
		then do;
		     error_flag = "1"b;
		     call iodd_msg_ (normal, source, 0, "", "The -device control argument can only be given once.");
		end;
		else do;
		     option.dev = "1"b;
		     if substr (args (idx + 1), 1, 1) = "-"
		     then go to bad_order;		/* was it an option? */
		     call find_minor_dev (args (idx + 1), dr_ptr, code);
		     if code ^= 0
		     then do;
			error_flag = "1"b;
			call iodd_msg_ (normal, source, 0, "", err_mess);
		     end;
		     else iodd_comm.minor_idx = dr_ptr -> driver_status.dev_index;
		end;
	     end;
	     else do;				/* OPTION = Not Defined Here */
		if substr (args (idx), 1, 1) = "-"
		then call iodd_msg_ (normal, source, 0, "", "Undefined control argument ^d", args (idx));
		else do;
bad_order:
		     call iodd_msg_ (normal, source, 0, "", "Arguments missing or out of sequence at: ^a", args (idx))
			;
		end;
		error_flag = "1"b;
		idx = idx - 1;			/* try to get back in sync */
	     end;
	end;

	if error_flag
	then return;				/* that's all */

	if ^option.dev
	then do;
	     if iodd_static.assigned_devices > 1
	     then do;
		err_mess = "For multiple minor devices, the -device control argument must be given.";
		go to error;
	     end;
	     option.dev = "1"b;			/* single device, we will assume it */
	     iodd_comm.minor_idx = iodd_static.driver_ptr -> driver_status.dev_index;
	end;

	error_flag = ^option.user | ^(option.et | option.pn | option.id);

	if error_flag
	then do;
	     err_mess = "Minimum args required are user and some request identifier.";
	     go to error;
	end;

/*	we should have a good request now */

	iodd_comm.type = next_req;			/* finish off the data */
	iodd_comm.type_ext = string (option);		/* show the given options to coord */

	err_mess = "";
	call send_coord_msg (code, number);
	if code ^= 0
	then call iodd_msg_ (normal, source, code, "", err_mess);
	else call iodd_msg_ (normal, source, 0, "", "Request found.");

	return;


probe_command:
	if source = master
	then if iodd_static.test_entry
	     then do;

		call iodd_msg_ (normal, master, 0, "", "Calling probe");
						/* give reassuring message */
		call probe ();
		return;
	     end;

	err_mess = "The probe command is for master terminal test mode only.";
	go to error;

pi_command:
	if iodd_static.test_entry
	then if source = master
	     then do;				/* very restricted */

		call iox_$control (iodd_static.master_in, "start", null, ec);
						/* play safe */
		signal program_interrupt;		/* back to debug .. we hope */

		return;
	     end;

	err_mess = "The pi command is only valid from the master terminal in test mode.";

	go to error;


ready_command:					/* put the devices in the ready state */
	list_ptr = iodd_static.driver_list_ptr;		/* make the reference easier */

	if arg_list.n < 2
	then do;					/* no arguments */
	     if iodd_static.assigned_devices = 1
	     then call ready_all;			/* only legal for the one device case */
	     else do;				/* give error msg */
		err_mess = "Multiple minor devices require an argument.";
		go to error;
	     end;
	end;
	else do;					/* there were args ... check them */
	     do i = 1 to arg_list.n - 1;		/* if we find "-all" we are done */
		if args (i) = "-a" | args (i) = "-all"
		then do;
		     call ready_all;
		     return;			/* that's all there is to it */
		end;
	     end;
	     do i = 1 to arg_list.n - 1;		/* only devices given ... search for them */

		call find_minor_dev (args (i), dr_ptr, code);
		if code = 0
		then do;
		     if dr_ptr -> driver_status.attached
		     then do;			/* can only ready attached devices */
			if ^dr_ptr -> driver_status.ready
			then do;
			     iodd_static.current_devices = iodd_static.current_devices + 1;
						/* increase count */
			     dr_ptr -> driver_status.ready = "1"b;
						/* turn on the ready flag to ready driver */
			end;
			if dr_ptr -> driver_status.request_pending
			then			/* check for driver pid */
			     if dr_ptr -> driver_status.request_pending ^= iodd_static.coord_proc_id
			     then dr_ptr -> driver_status.request_pending = (36)"0"b;
		     end;
		     else do;			/* not attached, check the count */
			if dr_ptr -> driver_status.ready
			then current_devices = current_devices - 1;
			dr_ptr -> driver_status.ready = "0"b;
						/* be sure it is not ready */
			call iodd_msg_ (normal, source, 0, "", "Device ""^a"" is not attached.", args (i));
		     end;
		end;
		else call iodd_msg_ (normal, source, 0, "", "Minor device ""^a"" not assigned.", args (i));
	     end;					/* look for next device arg */
	end;
	return;


reinit_command:					/* this will force the driver to re-initialize */
	if source = master
	then iodd_static.master_hold = "0"b;		/* always go for master */
	if iodd_static.master_hold
	then do;					/* protect the master */
	     err_mess = "Driver in hold by master terminal.";
	     go to error;
	end;

	signal re_init;				/* OK, here we go! */

	return;


release_command:
	if (state < signal_cmd_level) | (source = master)
	then do;
	     if source = master
	     then iodd_static.master_hold = "0"b;
	     if iodd_static.master_hold
	     then do;				/* don't interrupt the master */
		err_mess = "Driver in hold by master terminal.";
		go to error;
	     end;
	     if iodd_static.request_in_progress
	     then call iodd_msg_ (normal, source, 0, "", "Warning - Request in progress will be run again.");
	     iodd_static.driver_ptr -> driver_status.busy = "0"b;
						/* don't throw away a pending request */
	     iodd_static.slave_hold = "1"b;		/* force a command at normal level */
	     call iox_$control (iodd_static.master_in, "start", null, ec);
						/* avoid lost wakeups */
	     if iodd_static.slave.active
	     then call iox_$control (iodd_static.slave_in, "start", null, ec);
	     signal resume;				/* go back to iodd_listen_ */
	     iodd_static.master_hold = "1"b;		/* OOPS, trouble. */
	     return;
	end;
	err_mess = "The release command is only valid from the master terminal at this command level.";
	go to error;


restart_command:
	list_ptr = iodd_static.driver_list_ptr;		/* make the reference easier */

	if source = slave
	then if iodd_static.master_hold
	     then do;				/* can't override the master */
		err_mess = "Command not valid while process is in hold by master terminal.";
		go to error;
	     end;

	if arg_list.n = 1
	then do;					/* no sequence number given */
	     if (state > listen_cmd_level) & iodd_static.request_in_progress
	     then do;
		iodd_static.master_hold = "0"b;	/* this must be the master or value is already 0 */
		iodd_static.slave_hold = "0"b;	/* be sure they are off for next command level */
		call iox_$control (iodd_static.master_in, "start", null, ec);
						/* avoid lost wakeups */
		if iodd_static.slave.active
		then call iox_$control (iodd_static.slave_in, "start", null, ec);
		if source = master
		then signal daemon_again;		/* say it was the master */
		else signal daemon_again_slave;	/* otherwise it was the slave */
	     end;
	     else do;
		err_mess = "No current request to restart.";
		go to error;
	     end;
	     return;
	end;

	iodd_comm.type = restart;			/* mark the type so following can be used for save */

restart_or_save:
	if args (1) = "-from"
	then do;					/* this is a series request */
	     series_sw = "1"b;
	     seq_id = convert (fixed_bin_35, args (2));
	end;
	else do;					/* a single request */
	     seq_id = convert (fixed_bin_35, args (1));
	     series_sw = "0"b;
	end;

	iodd_comm.data_len = 0;			/* construct the command for the coord */
	iodd_comm.queue_no = 0;
	iodd_comm.user_id = "";			/* don't care, but initialize */
	iodd_comm.req_id = "";
	dr_ptr = iodd_static.driver_ptr;		/* need any minor device index, use current */
	iodd_comm.minor_idx = dr_ptr -> driver_status.dev_index;
						/* say who we are */
	iodd_comm.dvc_idx = dr_ptr -> driver_status.maj_index;
	iodd_comm.request_no = seq_id;		/* pass on the request number */
	iodd_comm.type_ext = series_sw;		/* use type extension to indicate single/series */
	err_mess = "";				/* clear the message for the int proc */

	call send_coord_msg (code, number);		/* ship it */
	if code ^= 0
	then do;
	     if code = error_table_$namedup
	     then err_mess = "A restart is already in progress.";
	     else if code = error_table_$noentry
	     then err_mess = "Request number not found in saved list.";
	     else if code = error_table_$action_not_performed
	     then err_mess = "The specified request series is invalid for this driver.";
	     call iodd_msg_ (normal, source, code, rtrim (iodd_static.major_device) || " driver", "^a", err_mess);
	     return;
	end;

	if ^series_sw | iodd_comm.type = save
	then return;

	if number ^= seq_id
	then call iodd_msg_ (normal, source, code, rtrim (iodd_static.major_device) || " driver",
		"Series will be restarted from request ^d", number);

	restart_series = divide (seq_id, 10000, 35, 0);	/* get the series he restarted */

	do i = 1 to iodd_static.assigned_devices;	/* see if there is a pending request */
						/* of the same series */
	     dr_ptr = driver_ptr_list.stat_segp (i);	/* look at each driver_status seg */
	     desc_ptr = addr (dr_ptr -> driver_status.descriptor);
						/* and request descriptor */

	     series = desc_ptr -> request_descriptor.seq_id;
						/* get the seq no of this request */

	     series = divide (series, 10000, 35, 0);	/* strip out the series number */

	     if restart_series = series
	     then do;				/* if they match, we are done with the search */
		if dr_ptr -> driver_status.request_pending = iodd_static.coord_proc_id
		then do;				/* is it active? */
		     desc_ptr -> request_descriptor.finished = "1"b;
						/* mark it done so we can pass back */
		     if dr_ptr -> driver_status.ready
		     then dr_ptr -> driver_status.request_pending = (36)"0"b;
						/* clear the pending flag */
		     else dr_ptr -> driver_status.request_pending = iodd_static.driver_proc_id;
						/* or busy the driver */
		     if dr_ptr -> driver_status.busy
		     then do;			/* was driver processing the request? */
			iodd_static.slave_hold = "1"b;/* return to command level after aborting request */
			if iodd_static.request_in_progress
			then signal daemon_save;	/* try a normal save, or ... */
			signal resume;		/* send the current request back to the coord */
		     end;
		     else do;			/* we want to send a pending request back to the coord */
			dr_ptr -> driver_status.last_wake_time = 0;
						/* force driver to request new one */
			event_message = 0;		/* clear the message to the coord */
			msgp = addr (event_message);
			msgp -> ev_msg.code = 0;	/* code 0 means take back this request and wait */
			msgp -> ev_msg.minor_dev_index =
						/* tell which driver it was */
			     fixed (dr_ptr -> driver_status.dev_index, 17);

			call hcs_$wakeup (iodd_static.coord_proc_id, dr_ptr -> driver_status.coord_chan,
			     event_message, code);

			if code ^= 0
			then signal no_coord;	/* again, errors are bad news!! */
		     end;
		end;
		return;				/* we don't have to look at anything more */
	     end;
	end;					/* end of the loop for assigned devices */
	return;


restart_q_command:
	if iodd_static.assigned_devices > 1 & arg_list.n = 1
	then do;					/* device needed? */
	     err_mess = "Multiple minor devices require an argument.";
	     go to error;
	end;

	if arg_list.n > 1
	then do;					/* find the minor device index as requested */
	     call find_minor_dev (args (1), dr_ptr, code);
	     if code ^= 0
	     then go to error;			/* msg has been set */
	     iodd_comm.minor_idx = dr_ptr -> driver_status.dev_index;
	     iodd_comm.dvc_idx = dr_ptr -> driver_status.maj_index;
	end;
	else do;
	     iodd_comm.minor_idx = iodd_static.driver_ptr -> driver_status.dev_index;
	     iodd_comm.dvc_idx = iodd_static.driver_ptr -> driver_status.maj_index;
	end;

/*	now complete the message */

	iodd_comm.type = restart_q;
	iodd_comm.type_ext = ""b;
	iodd_comm.request_no = 0;
	iodd_comm.queue_no = 0;			/* we restart all queues */
	iodd_comm.data_len = 0;			/* define a null char string */
	iodd_comm.req_id = "";
	iodd_comm.user_id = "";
	err_mess = "";

	call send_coord_msg (code, number);

	if code ^= 0
	then call iodd_msg_ (normal, source, code, rtrim (iodd_static.major_device) || " driver", err_mess);

	else call iodd_msg_ (normal, source, 0, "", "Coord has restarted the queues.");


	return;


resume_command:
	if iodd_static.test_entry & (source = master)
	then do;
	     iodd_static.slave_hold = "1"b;		/* force a command at normal level */
	     call iox_$control (iodd_static.master_in, "start", null, ec);
						/* avoid lost wakeups */
	     if iodd_static.slave.active
	     then call iox_$control (iodd_static.slave_in, "start", null, ec);
	     signal resume;				/* go back to iodd_listen_ */
	     iodd_static.master_hold = "1"b;		/* OOPS, trouble.  But, master did it */
	     return;
	end;

	err_mess = "The resume command is valid from the master terminal in test mode only.";

	go to error;


return_command:
	list_ptr = iodd_static.driver_list_ptr;		/* make the reference easier */

	if iodd_static.test_entry
	then if source = master
	     then do;
		driver_ptr_list.number = 0;		/* don't tell the coord we are going away */
		signal daemon_logout;
		iodd_static.master_hold = "1"b;	/* we won't get here, but.... */
		return;
	     end;

	err_mess = "The return command is only valid from the master terminal in test mode.";
	return;


save_command:					/* ask coord to save requests in our device class */
	list_ptr = iodd_static.driver_list_ptr;		/* make the reference easier */

	if arg_list.n > 1
	then do;					/* the N or -from N case */
	     iodd_comm.type = save;			/* mark the type of command */
	     go to restart_or_save;			/* use some common code with restart */
	end;
	if source = slave
	then if iodd_static.master_hold
	     then do;				/* can't override the master */
		err_mess = "Command not valid while process is in hold by master terminal.";
		go to error;
	     end;

	if (state > listen_cmd_level) & iodd_static.request_in_progress
	then do;
	     iodd_static.master_hold = "0"b;		/* this must be the master or value is already 0 */
	     iodd_static.slave_hold = "0"b;		/* be sure they are off for next command level */
	     call iox_$control (iodd_static.master_in, "start", null, ec);
						/* avoid lost wakeups */
	     if iodd_static.slave.active
	     then call iox_$control (iodd_static.slave_in, "start", null, ec);
	     desc_ptr = addr (iodd_static.driver_ptr -> driver_status.descriptor);
	     desc_ptr -> request_descriptor.saved = "1"b;
	     desc_ptr -> request_descriptor.finished = "1"b;
	     desc_ptr -> request_descriptor.cancelled = ""b;
						/* just to be sure */

	     signal daemon_save;			/* try for a clean finish of what was done */
	     ec = 2;				/* make like a start command was given */
	     return;
	end;
	else do;
	     err_mess = "No current request to save.";
	     go to error;
	end;

	return;


slave_command:
	if source = master
	then					/* slave can't send itself a message */
	     if iodd_static.slave.active
	     then do;
		call iodd_msg_ (normal, slave, 0, "", "From master: ^a",
		     substr (command_line, index (command_line, "slave") + 5));
		call iox_$control (iodd_static.slave_out, "runout", null, code);
		return;
	     end;
	     else do;
		err_mess = "Slave device is not active.";
		go to error;
	     end;

	err_mess = "Invalid command for slave terminal.";
	go to error;


slave_term_command:
	if ^iodd_static.slave.active
	then do;
	     err_mess = "Slave terminal is not active.";
	     go to error;
	end;

	if arg_list.n < 2
	then do;
	     err_mess = "Expected argument missing.";
	     go to error;
	end;

	if args (1) = "errors"
	then do;
	     iodd_static.slave.print_errors = "1"b;
	     call ios_$attach ("error_output", "syn", "broadcast_errors", "", io_stat);
	end;

	else if args (1) = "no_errors" | args (1) = "noerrors"
	then do;
	     iodd_static.slave.print_errors = "0"b;
	     call ios_$attach ("error_output", "syn", "error_i/o", "", io_stat);
	end;

	else if args (1) = "commands"
	then do;
	     if source = slave
	     then do;
		call master_only ("slave_term " || args (1));
		return;
	     end;
	     iodd_static.accept_input = "1"b;
	     if state >= quit_cmd_level & ^iodd_static.slave.allow_quits
	     then call iodd_msg_ (normal, master, 0, "",
		     "This will not be effective at this level while quits are disabled.");
	end;

	else if args (1) = "no_commands" | args (1) = "nocommands"
	then do;
	     if source = slave
	     then do;
		call master_only ("slave_term " || args (1));
		return;
	     end;
	     iodd_static.accept_input = "0"b;
	     if state >= quit_cmd_level
	     then call iodd_msg_ (normal, master, 0, "",
		     "WARNING: The previous command input state may be restored after start.");
	end;

	else if args (1) = "quits"
	then do;
	     if source = slave
	     then do;
		call master_only ("slave_term " || args (1));
		return;
	     end;
	     iodd_static.allow_quits = "1"b;
	end;

	else if args (1) = "no_quits" | args (1) = "noquits"
	then do;
	     if source = slave
	     then do;
		call master_only ("slave_term " || args (1));
		return;
	     end;
	     iodd_static.allow_quits = "0"b;
	end;

	else if args (1) = "log"
	then do;
	     iodd_static.slave.log_msg = "1"b;
	end;

	else if args (1) = "no_log" | args (1) = "nolog"
	then do;
	     iodd_static.slave.log_msg = "0"b;
	end;

	else if args (1) = "echo"
	then do;
	     iodd_static.slave.echo_cmd = "1"b;
	end;

	else if args (1) = "no_echo" | args (1) = "noecho"
	then do;
	     iodd_static.slave.echo_cmd = "0"b;
	end;

	else if args (1) = "modes"
	then do;					/* see if he wants a changemode */
	     if arg_list.n < 3
	     then do;				/* just report current mode */
		mode = "";
		message = "Current_modes:";
	     end;
	     else do;
		mode = args (2);
		message = "Modes were:";
	     end;
	     omode = "not returned";			/* just to make the message clear */

	     call ios_$changemode (iodd_static.slave_output, mode, omode, io_stat);
	     if st.code ^= 0
	     then do;				/* OOPS */
		ec = st.code;			/* report the error */
		call iodd_msg_ (normal, both, ec, whoami);
	     end;
	     call iodd_msg_ (normal, source, 0, "", "^a ^a", message, omode);
	end;

	else do;					/* otherwise ...not implemented here */
	     ec = unknown_cmd_code;			/* see if driver module recognizes it */
	     err_mess = "Invalid function for slave_term command: " || args (1);
	     go to pass_on;				/* give it to the driver module for action */
	end;
	return;


start_command:
	if state > listen_cmd_level
	then do;					/* we use start after a quit */
	     iodd_static.slave_hold = "0"b;
	     if source = master
	     then iodd_static.master_hold = "0"b;
	     if iodd_static.master_hold
	     then do;
		err_mess = "Driver in hold by master terminal.";
		go to error;
	     end;
	     ec = 2;				/* this is the start code for the quit handler */
	     return;
	end;

	err_mess = "The ""start"" command is not valid at this level.";
	go to error;



status_command:
	if arg_list.n > 1
	then do;
	     if args (1) = "-long" | args (1) = "-lg"
	     then lg_sw = "1"b;			/* gave the long option */
	     else do;
		err_mess = "Invalid control argument: " || args (1);
		go to error;
	     end;
	end;
	else lg_sw = "0"b;

	list_ptr = iodd_static.driver_list_ptr;		/* make the reference easier */

	if iodd_static.step
	then message = "(step mode set)";
	else message = "";

	call iodd_msg_ (normal, source, 0, "", "^/IO Daemon Version: ^a^/Device:^2x^a^3x^a:^2x^a^3x^a",
	     iodd_static.io_daemon_version, iodd_static.major_device, chn_type (iodd_static.attach_type),
	     iodd_static.attach_name, message);

	if iodd_static.assigned_devices = 1
	then do;					/* different form for one device */
	     dr_ptr = iodd_static.driver_ptr;		/* use the current driver */
	     call iodd_msg_ (normal, source, 0, "", "Request type:  ^a", dr_ptr -> driver_status.req_type_label);
	     call get_driver_status (message);
	     call iodd_msg_ (normal, source, 0, "", "Status:^8x^a^/", message);
	     return;
	end;

/* determine length to generate legible display */
	device_id_length, req_type_label_length = 12;
	do i = 1 to iodd_static.assigned_devices;
	     dr_ptr = driver_ptr_list.stat_segp (i);
	     if dr_ptr -> driver_status.attached | lg_sw
	     then do;
		if length (rtrim (dr_ptr -> driver_status.device_id)) > device_id_length
		then device_id_length = length (rtrim (dr_ptr -> driver_status.device_id));
		if length (rtrim (dr_ptr -> driver_status.req_type_label)) > req_type_label_length
		then req_type_label_length = length (rtrim (dr_ptr -> driver_status.req_type_label));
	     end;
	end;
	call iodd_msg_ (normal, source, 0, "", "^/minor device^vx  request type^vx  status^/", device_id_length - 12,
	     req_type_label_length - 12);

	do i = 1 to iodd_static.assigned_devices;
	     dr_ptr = driver_ptr_list.stat_segp (i);
	     if dr_ptr -> driver_status.attached | lg_sw
	     then do;
		call get_driver_status (message);
		call iodd_msg_ (normal, source, 0, "", "^va  ^va  ^a", device_id_length,
		     dr_ptr -> driver_status.device_id, req_type_label_length, dr_ptr -> driver_status.req_type_label,
		     message);
	     end;
	end;

	call iodd_msg_ (normal, source, 0, "", "^/");	/* separate from command request */

	return;


step_command:
	if arg_list.n > 1
	then do;					/* an argument was given */
	     if args (1) = "set"
	     then iodd_static.step = "1"b;
	     else if args (1) = "reset"
	     then iodd_static.step = "0"b;
	     else do;				/* unknown arg */
		err_mess = "Valid arguments are set and reset.";
		go to error;
	     end;
	end;
	else iodd_static.step = "1"b;
	return;


x_command:
	if search (command_line, bad_chars) > 0
	then do;					/* trying to trick us? */
	     call iodd_msg_ (normal, source, 0, "", "Invalid characters in command line.");
	     ec = unknown_cmd_code;
	     return;
	end;

	on any_other call x_cmd_handler;		/* in case ec gets into trouble */
	on cleanup call reattach_master;

	if source = slave
	then do;					/* for slave, we must swap streams around */
	     call swap_user_io_streams (ec);
	     if ec ^= 0
	     then do;
		err_mess = "Unable to switch user io switches to salve.";
		call reattach_master;
		go to error;
	     end;
	end;
	else do;					/* for master, be sure slave doesn't get error messages */
	     att_desc = "syn_ error_i/o -inhibit close";
	     call iox_$detach_iocb (iox_$error_output, ec);
	     call iox_$attach_ptr (iox_$error_output, att_desc, null, ec);
	     if ec ^= 0
	     then do;
		err_mess = "Error switching error_output.";
		call reattach_master;		/* try like hell */
		go to error;
	     end;
	end;

	tried_once = "0"b;				/* get set for not finding <device>_admin.ec */
	ec_name = iodd_static.admin_ec_name;		/* get the first name */

once_more:
	call hcs_$initiate (iodd_static.sys_dir_ptr -> sys_dir, ec_name, "", 0, 1, segp, code);
	if segp = null
	then do;					/* not there */
	     if ^tried_once
	     then do;				/* look for iod_admin.ec */
		ec_name = "iod_admin.ec";
		tried_once = "1"b;			/* say we have tried once already */
		go to once_more;			/* try_again */
	     end;
	     ec = code;				/* too bad, give up */
	     err_mess = "Unable to find " || rtrim (iodd_static.admin_ec_name) || " or iod_admin.ec for this driver.";
	     call reattach_master;
	     go to error;
	end;

	if iodd_static.admin_ec_name ^= ec_name
	then do;					/* if we switched, tell operator */
	     call iodd_msg_ (normal, source, 0, "", "Using ^a for x command.", ec_name);
	     iodd_static.admin_ec_name = ec_name;	/* incase we had to switch */
	end;

	command =
	     "exec_com " || rtrim (iodd_static.sys_dir_ptr -> sys_dir) || ">" || rtrim (ec_name)
	     || substr (command_line, index (command_line, "x") + 1);
						/* be sure to leave in the leading space */

	call cu_$cp (addr (command), length (rtrim (command)), code);
	if code ^= 0
	then ec = unknown_cmd_code;			/* force a reset_read */

	call reattach_master;

	return;


/*      END OF DEFINED COMMANDS     */
/* ************************************ */

/* *********************************** */





init:
     entry (a_ptr);					/* initialize the static data */

dcl  a_ptr ptr;

	stat_p = a_ptr;				/* set the pointer to iodd_static */


	return;

/*	**** INTERNAL PROCEDURES ****		*/


halt_all:
     proc;					/* unready all devices assigned to the process */

dcl  i fixed bin;					/* don't destroy the one in the external proc */

	do i = 1 to iodd_static.assigned_devices;

	     dr_ptr = driver_ptr_list.stat_segp (i);
	     dr_ptr -> driver_status.ready = "0"b;	/* turn off the ready flag to stop driver */
	     if ^stac (addr (dr_ptr -> driver_status.request_pending), iodd_static.driver_proc_id)
	     then do;
		if dr_ptr -> driver_status.request_pending = iodd_static.coord_proc_id
		then iodd_static.runout_requests = "1"b;/* there was a pending request */
	     end;
	     iodd_static.current_devices = 0;		/* reset the count...all stopped */

	end;

     end halt_all;



ready_all:
     proc;					/* ready all attached minor devices */

dcl  i fixed bin;					/* save the variable in external proc */

	iodd_static.current_devices = 0;		/* clear the count */

	do i = 1 to iodd_static.assigned_devices;
	     dr_ptr = driver_ptr_list.stat_segp (i);	/* get driver ptr */
	     if dr_ptr -> driver_status.attached
	     then do;
		dr_ptr -> driver_status.ready = "1"b;
		iodd_static.current_devices = iodd_static.current_devices + 1;
						/* one more ready */
		if dr_ptr -> driver_status.request_pending
		then				/* if open to coord, leave it alone */
		     if dr_ptr -> driver_status.request_pending ^= iodd_static.coord_proc_id
		     then dr_ptr -> driver_status.request_pending = (36)"0"b;
	     end;
	     else do;
		dr_ptr -> driver_status.ready = "0"b;	/* just to be sure */
		dr_ptr -> driver_status.busy = "0"b;
	     end;
	end;

     end ready_all;


get_driver_status:
     proc (status);

/* internal procedure to set a string description of the driver status seg pointed */
/* to by dr_ptr. */

dcl  status char (*);
dcl  string char (32);
dcl  len fixed bin;
dcl  pending bit (1);

	if dr_ptr -> driver_status.ready
	then status = "ready";

	else if dr_ptr -> driver_status.attached
	then status = "halted";

	else status = "not attached";

	if dr_ptr -> driver_status.request_pending = iodd_static.coord_proc_id
	then do;					/* request there? */
	     desc_ptr = addr (dr_ptr -> driver_status.descriptor);
	     pending = ^((dr_ptr = iodd_static.driver_ptr) & iodd_static.request_in_progress);
	     seq_id = desc_ptr -> request_descriptor.seq_id;
	     call ioa_$rsnnl ("request ^d ^[pending^;in progress^]", string, len, seq_id, pending);
	     substr (status, 16) = string;
	end;

	return;

     end get_driver_status;


find_minor_dev:
     proc (dev_id, dr_ptr, code);

dcl  dev_id char (*) var;
dcl  dr_ptr ptr;
dcl  code fixed bin (35);
dcl  j fixed bin;


	code = 0;
	list_ptr = iodd_static.driver_list_ptr;
	do j = 1 to iodd_static.assigned_devices;
	     dr_ptr = driver_ptr_list.stat_segp (j);
	     if dr_ptr -> driver_status.device_id = dev_id
	     then return;				/* found the device */
	end;
	code = error_table_$noentry;
	err_mess = "Invalid minor device name: " || dev_id;
	return;

     end find_minor_dev;

master_only:
     proc (msg);

dcl  msg char (*);

	call iodd_msg_ (normal, source, 0, "", "^a driver:  Invalid function from the slave terminal.  ^a",
	     iodd_static.major_device, msg);

	ec = unknown_cmd_code;

	return;

     end master_only;



x_cmd_handler:
     proc;					/* any_other handler for the x command */

dcl  code fixed bin (35);				/* local error code */
dcl  type char (32);

	cond_info.version = 1;

	call find_condition_info_ (null, addr (cond_info), code);

	type = cond_info.condition_name;		/* for easy reference */
	if type = "cput"
	then do;
continue_signal:
	     call continue_to_signal_ (code);		/* this is harmless */
	     return;
	end;
	if type = "alrm"
	then go to continue_signal;
	if type = "finish"
	then go to continue_signal;
	if type = "command_error"
	then return;
	if type = "command_question"
	then do;
	     cq_info_ptr = cond_info.info_ptr;		/* get pointer to question info structure */
	     if command_question_info.version >= cq_info_version_5
	     then do;				/* if we can */
		command_question_info.question_iocbp = iox_$user_output;
						/* set the switches for Q and A */
		command_question_info.answer_iocbp = iox_$user_input;
		command_question_info.repeat_time = 120;/* ask every 2 minutes */
	     end;
	     return;
	end;
	if iodd_static.test_entry
	then if type = "mme2"
	     then go to continue_signal;
	     else if type = "program_interrupt"
	     then go to continue_signal;

	call ioa_ ("Error: ^a condition during the driver x command.  Command aborted.", type);

	call reattach_master;

	go to ignore;				/* go back to command level */

     end x_cmd_handler;

swap_user_io_streams:
     proc (code);

dcl  code fixed bin (35);

	code = 0;

	att_desc = "syn_ " || rtrim (iodd_static.slave_output) || " -inhibit close";

	call iox_$detach_iocb (iox_$user_output, code);
	if code ^= 0
	then return;

	call iox_$attach_ptr (iox_$user_output, att_desc, null, code);
	if code ^= 0
	then return;

	call iox_$detach_iocb (iox_$error_output, ec);
	if ec ^= 0
	then return;

	call iox_$attach_ptr (iox_$error_output, att_desc, null, ec);
	if ec ^= 0
	then return;

	att_desc = "syn_ " || rtrim (iodd_static.slave_input) || " -inhibit close ";

	call iox_$detach_iocb (iox_$user_input, code);
	if code ^= 0
	then return;

	call iox_$attach_ptr (iox_$user_input, att_desc, null, code);

	return;

     end swap_user_io_streams;

reattach_master:
     proc;

/*	reconnect the user_output, error_output and user_input switches to user_i/o */

dcl  code fixed bin (35);

	code = 0;

	att_desc = "syn_ user_i/o -inhibit close";

	call iox_$detach_iocb (iox_$user_output, code);
	if code ^= 0
	then go to fatal_error;

	call iox_$attach_ptr (iox_$user_output, att_desc, null, code);
	if code ^= 0
	then go to fatal_error;

	call iox_$detach_iocb (iox_$user_input, code);
	if code ^= 0
	then go to fatal_error;

	call iox_$attach_ptr (iox_$user_input, att_desc, null, code);
	if code ^= 0
	then go to fatal_error;

	if iodd_static.slave.active & iodd_static.slave.print_errors
	then att_desc = "syn_ broadcast_errors -inhibit close";
	else att_desc = "syn_ error_i/o -inhibit close";

	call iox_$detach_iocb (iox_$error_output, code);
	if code ^= 0
	then go to fatal_error;

	call iox_$attach_ptr (iox_$error_output, att_desc, null, code);
	if code = 0
	then return;

fatal_error:
	call iodd_msg_ (error, both, code, whoami, "Fatal error swapping user io streams.");

	if iodd_static.test_entry
	then do;
	     call iodd_msg_ (normal, master, 0, "", "Calling Probe - and hope for the best.");
	     call probe;
	     return;
	end;

	call logout;

	return;

     end reattach_master;

send_coord_msg:
     proc (code, number);

dcl  code fixed bin (35);
dcl  number fixed bin (35);
dcl  len fixed bin;
dcl  msg_id bit (72) aligned;

	iodd_comm.ack_chan = iodd_static.cmd_ack_chan;	/* this is how we expext to get confirmation */
	len = currentsize (iodd_comm);		/* get size of message */

	call message_segment_$add_file (iodd_static.sys_dir_ptr -> sys_dir, "coord_comm.ms", comm_ptr, len * 36, msg_id,
	     code);
	if code ^= 0
	then do;
	     err_mess = "unable to add command request to coord_comm.ms.";
	     return;
	end;

	call ipc_$drain_chn (iodd_static.cmd_ack_chan, code);
						/* clear any pending wakeups */
	call ipc_$drain_chn (iodd_static.timer_chan, code);
						/* especially this one */

	unspec (event_message) = msg_id;		/* give the message id to the coord in ev message */

	call hcs_$wakeup (iodd_static.coord_proc_id, iodd_static.coord_cmd_chan, event_message, code);
	if code ^= 0
	then go to bad_ipc;				/* errors are bad news */

/* set up a timer to be sure we don't block too long */

	call timer_manager_$alarm_wakeup (120, "11"b, iodd_static.timer_chan);
						/* allow coord two munutes */

	ev_chan_list.number = 2;			/* get ready to block */
	ev_chan_list.chan (1) = iodd_static.cmd_ack_chan; /* first priority is coord */
	ev_chan_list.chan (2) = iodd_static.timer_chan;	/* next is the timer */

	call ipc_$block (addr (ev_chan_list), addr (event_info), code);

	call timer_manager_$reset_alarm_wakeup (iodd_static.timer_chan);
						/* stop the timer, if possible */

	if code ^= 0
	then do;					/* very bad news */
bad_ipc:
	     call convert_ipc_code_ (code);
	     call iodd_msg_ (normal, both, code, whoami, "Fatal error.  Driver will reinitialize.");
	     signal re_init;
	end;

	if event_info.wait_list_idx = 1
	then do;					/* it was from the coord */
	     msgp = addr (event_info.msg);
	     code = msgp -> ack_msg.code;
	     number = msgp -> ack_msg.num;
	end;
	else do;					/* the timer went off, is ther a coord at all? */
	     code = error_table_$request_not_recognized;
	     err_mess = "Coordinator did not respond to command.";
	end;
	return;

     end send_coord_msg;
%page;
%include command_question_info;
%page;
%include condition_info;
%page;
%include condition_info_header;
%page;
%include driver_ptr_list;
%page;
%include driver_status;
%page;
%include iod_event_message;
%page;
%include iod_tables_hdr;
%page;
%include iodd_comm;
%page;
%include iodd_static;
%page;
%include mseg_message_info;
%page;
%include request_descriptor;

     end iodd_command_processor_;
