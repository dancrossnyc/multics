/****^  ********************************************
        *                                          *
        * Copyright, (C) Honeywell Bull Inc., 1987 *
        *                                          *
        ******************************************** */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* This module is part of the Multics Network Architecture (MNA) version of  */
/* user control.  MNA user control serves users coming into Multics via      */
/* separate networks (eg, the Distributed Systems Architecture (DSA)	       */
/* network.  MNA user control is not used for logins through the Multics     */
/* Communications System (MCS).  A separate MCS user control system serves   */
/* MCS users.						       */
/*							       */
/* To Be Supplied:						       */
/*  1) Brief module description.  See MDD010 or MTBs 751 and 752 for details */
/*     about this module, and its relationship to modules in the MCS user    */
/*     control system.					       */
/*  2) Operator error message documentation.  This program calls	       */
/*     sys_log_$general but does not contain the required descriptions of    */
/*     these messages.  This omission was waived for initial installation    */
/*     of the subsystem by the auditor, security coordinator, and by MDC     */
/*     management.						       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

/****^  HISTORY COMMENTS:
  1) change(85-08-01,Swenson), approve(87-07-14,MCR7737),
     audit(87-05-18,GDixon), install(87-08-04,MR12.1-1055):
     Initially coded.
  2) change(86-04-09,Herbst), approve(87-07-14,MCR7737),
     audit(87-07-30,Brunelle), install(87-08-04,MR12.1-1055):
     Changed Disconnect_Process proc to set ute.disconnection_rel_minutes.
  3) change(87-03-03,Brunelle), approve(87-07-14,MCR7737),
     audit(87-07-30,GDixon), install(87-08-04,MR12.1-1055):
     Added code to handle inacrcvd (inactivity msg received and processed)
     signal (signal type 12).  This reschedules the bump timer scheduled for
     the user to installation_parms.warning_time from the receipt of the
     signal by calling asu_$reschedule_bump_timer.
  4) change(87-04-27,GDixon), approve(87-07-14,MCR7737),
     audit(87-07-30,Brunelle), install(87-08-04,MR12.1-1055):
     Upgraded for change to answer_table.incl.pl1 and user_table_entry.incl.pl1
  5) change(87-05-17,GDixon), approve(87-07-14,MCR7737),
     audit(87-07-30,Brunelle), install(87-08-04,MR12.1-1055):
      A) Use automatic response structures rather than based storage.
      B) Use constants to set/test ute.preempted.
      C) Use sys_log_$general to report errors.
      D) Allow operator requests to bump/detach a logged in user with no
         process.
      E) Use new uc_send_ls_response_ calling sequence.
  6) change(87-05-18,Parisek), approve(87-07-14,MCR7690),
     audit(87-07-30,Brunelle), install(87-08-04,MR12.1-1055):
     Added call to remove MC tty when bumping a logged in user with no process
     (User logged in as operator).
  7) change(87-05-18,Brunelle), approve(87-07-14,MCR7737),
     audit(87-07-30,GDixon), install(87-08-04,MR12.1-1055):
     Added call to set anstbl.current_time which was forgotten.
  8) change(87-05-29,GDixon), approve(87-07-14,MCR7737),
     audit(87-07-30,Brunelle), install(87-08-04,MR12.1-1055):
      A) When bumping a logged-in, no-process UTE, hold the user connection
         rather than dropping it.
  9) change(87-06-02,GDixon), approve(87-07-14,MCR7737),
     audit(87-07-30,Brunelle), install(87-08-04,MR12.1-1055):
     Correct error in ioa_ control string.
 10) change(87-06-09,GDixon), approve(87-07-14,MCR7737),
     audit(87-07-30,Brunelle), install(87-08-04,MR12.1-1055):
      A) Include process ID and group ID in
         login_server_termination_response.  For dialed terminals having a
         UTE, the process ID of the target process has been placed in their
         UTE by uc_ls_dial_request_ or mc_commands_$mc_login.
 11) change(87-07-14,Parisek), approve(87-07-14,MCR7644),
     audit(87-07-30,Brunelle), install(87-08-04,MR12.1-1055):
      A) Added code for handling a user "disconnect" command.
 12) change(87-07-15,GDixon), approve(87-07-15,MCR7737),
     audit(87-07-30,Brunelle), install(87-08-04,MR12.1-1055):
      A) Audit process terminations via as_access_audit_$process.
 13) change(87-07-30,GDixon), approve(87-07-30,MCR7737),
     audit(87-07-30,Brunelle), install(87-08-04,MR12.1-1055):
      A) Correct arguments in several error messages.
      B) When user unbumped too late, give him a new process just as dialup_
         does.
                                                   END HISTORY COMMENTS */

/* format: style4,indattr,insnl */

uc_proc_term_handler_:
     procedure (P_event_call_info_ptr);

/* Parameters */

dcl  P_event_call_info_ptr  ptr parameter;

/* Automatic */

dcl  code		        fixed bin (35) automatic;
dcl  destroy_index	        fixed bin (17) automatic;
dcl  ip		        ptr automatic;
dcl  metering_enabled       bit (1) aligned automatic;
dcl  pdtep	        ptr automatic;
dcl  saved_destroy_flag     fixed bin automatic;
dcl  signal_left_half       char (4) automatic;
dcl  signal_string	        char (8) automatic;
dcl  wakeup_from	        fixed bin automatic;
dcl  whoptr	        ptr automatic;

/* Automatic Structures */

dcl  1 auto_new_proc_response
		        aligned automatic like login_server_new_proc_response;
dcl  1 auto_process_response
		        aligned automatic like login_server_process_response.fixed_part;
dcl  1 auto_termination_response
		        aligned automatic like login_server_termination_response;
dcl  1 new_proc_auth        structure aligned automatic,
       2 pad	        char (2) unaligned,
       2 authorization      bit (54) unaligned;
dcl  1 signal_term_code     structure aligned automatic,
       2 pad	        char (4) unaligned,
       2 code	        fixed bin (35) unaligned;


/* Based */

dcl  stopstop_msg	        fixed bin (71) based (addr (stopstop));
dcl  termstop_msg	        fixed bin (71) based (addr (termstop));

/* Entries */

dcl  act_ctl_$activity_unbump
		        entry (ptr, fixed bin (35));
dcl  act_ctl_$close_account entry (ptr);
dcl  act_ctl_$dp	        entry (ptr);
dcl  aim_check_$equal       entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
dcl  aim_check_$in_range    entry (bit (72) aligned, (2) bit (72) aligned) returns (bit (1) aligned);
dcl  as_access_audit_$logout
		        entry (ptr, char (*));
dcl  as_access_audit_$process
		        entry (ptr, fixed bin, char (*));
dcl  as_any_other_handler_$no_cleanup
		        entry (char (*), label);
dcl  as_meter_$enter        entry (fixed bin);
dcl  as_meter_$exit	        entry (fixed bin);
dcl  asu_$reschedule_bump_timer
		        entry (ptr, fixed bin);
dcl  asu_$send_term_signal  entry (ptr, fixed bin) returns (bit (1) aligned);
dcl  asu_$suspend_process   entry (ptr);
dcl  convert_status_code_   entry (fixed bin (35), char (8) aligned, char (100) aligned);
dcl  dpg_		        entry (ptr, char (*));
dcl  dpg_$finish	        entry (ptr);
dcl  get_process_id_        entry () returns (bit (36));
dcl  hcs_$wakeup	        entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
dcl  mc_commands_$remove_tty
		        entry (char (*), bit (1) aligned, fixed bin (35));
dcl  send_mail_$access_class
		        entry (char (*), char (*), ptr, bit (72) aligned, fixed bin (35));
dcl  timer_manager_$reset_alarm_wakeup
		        entry (fixed bin (71));
dcl  uc_create_process_     entry (ptr, fixed bin (35));
dcl  uc_logout_	        entry (ptr, char (*));
dcl  uc_send_ls_response_   entry (ptr, fixed bin (18), bit (36) aligned,
		        bit (72) aligned, fixed bin (71), ptr,
		        char (32) aligned, fixed bin (35), fixed bin (35));
dcl  user_table_mgr_$free
		        entry (ptr);

/* External */

dcl  (
     as_error_table_$activity_unbump,
     as_error_table_$automatic_logout,
     as_error_table_$bump_cancelled,
     as_error_table_$disc_hd_msg,
     as_error_table_$illegal_new_proc,
     as_error_table_$illegal_signal,
     as_error_table_$init_err,
     as_error_table_$no_disc_hd,
     as_error_table_$no_init_proc,
     as_error_table_$no_io_attach,
     as_error_table_$no_logout_hold,
     as_error_table_$no_perm_disc,
     as_error_table_$no_signal,
     as_error_table_$shutdown,
     as_error_table_$term_by_operator
     )
		        fixed bin (35) external static;
dcl  (
     error_table_$fatal_error,
     error_table_$messages_deferred,
     error_table_$messages_off,
     error_table_$null_info_ptr
     )
		        fixed bin (35) ext static;

/* Constant */

dcl  (
     FALSE	        initial ("0"b),
     TRUE		        initial ("1"b)
     )		        bit (1) aligned internal static options (constant);

dcl  MAX_USER_SIGNALS       fixed bin int static options (constant) init (19);


dcl  ME		        char (21) initial ("uc_proc_term_handler_") internal static options (constant);

dcl  (
     UNKNOWN_SOURCE	        init (0),
     RING_0	        init (1),
     USER		        init (2),
     USER_CONTROL	        init (3)
     )		        fixed bin int static options (constant);

dcl  USEC_PER_MINUTE        fixed bin (35) int static options (constant) init (60000000);
dcl  USEC_PER_SECOND        fixed bin (35) int static options (constant) init (1000000);

dcl  WAKEUP_SOURCE	        (0:3) char (16) varying int static options (constant) init (
		        "unknown source",
		        "ring 0",
		        "UTE user",
		        "user control");

dcl  (
     stopstop	        initial ("stopstop"),
     termstop	        initial ("termstop")
     )		        char (8) internal static options (constant);

/* Conditions */

dcl  any_other	        condition;
dcl  cleanup	        condition;

/* Builtin */

dcl  (addr, baseno, clock, currentsize, divide, hbound, lbound, length,
     max, null, rtrim, substr, unspec)
		        builtin;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


/* Program */

	code = 0;
	event_call_info_ptr = P_event_call_info_ptr;
	ansp = as_data_$ansp;
	ip = as_data_$rs_ptrs (0);
	whoptr = as_data_$whoptr;

	anstbl.current_time = clock ();		/* Read Clock */

	metering_enabled = FALSE;
	on cleanup
	     call Clean_Up ();

	on any_other
	     call as_any_other_handler_$no_cleanup (ME, RETURN);

	if event_call_info_ptr = null ()
	then
	     call Abort (error_table_$null_info_ptr,
		"Null event_call_info pointer.");

/**** TBS: This is not strictly correct, since we're not dialup */
	metering_enabled = TRUE;
	call as_meter_$enter (DIALUP_METER);

	unspec (signal_string) = unspec (event_call_info.message);
	destroy_index = PT_FPE;			/* fatal process error is default */

	utep = event_call_info.data_ptr;

/* Ensure ute points to one of our user tables. */
	call Validate_UTEp ();

	wakeup_from = UNKNOWN_SOURCE;

	if event_call_info.ring = 0
	then
	     wakeup_from = RING_0;
	else if event_call_info.sender = get_process_id_ ()
	then
	     wakeup_from = USER_CONTROL;
	else if ute.active = NOW_HAS_PROCESS &
	     ute.proc_id = event_call_info.sender
	then
	     wakeup_from = USER;
	else
	     call Abort (-1,
		"UTE (^d, ^p in ^a) received wakeup (^a, ^24.3b) from invalid process (^12.3b).",
		ute.ute_index, utep, TABLE_NAMES (ute.process_type),
		signal_string, unspec (signal_string), event_call_info.sender);

	if ute.active = NOW_FREE
	then
	     call Abort (-1,
		"Free UTE (^d, ^p in ^a) received wakeup (^a, ^24.3b) from ^a.",
		ute.ute_index, utep, TABLE_NAMES (ute.process_type),
		signal_string, unspec (signal_string),
		WAKEUP_SOURCE (wakeup_from));

	call Setup_LS_Termination_Response ();

/**** In the event that the operator tried to bump a user who was logged
      in with no process, handle this case.  Assume that any wakeup
      sent to the UTE is a "bump" request, since no others make a whole
      lot of sense, anyway. */

	if ute.destroy_flag < WAIT_LOGOUT_SIG
	then
	     if ute.active = NOW_LOGGED_IN then do;
		call Kill_Login_and_Notify_LS ();
	     end;
	     else call Abort (-1,
		     "UTE (^d, ^p in ^a) wakeup (^a, ^24.3b) from ^a with unexpected destroy_flag (^a, ^d).",
		     ute.ute_index, utep, TABLE_NAMES (ute.process_type),
		     signal_string, unspec(signal_string), WAKEUP_SOURCE (wakeup_from),
		     TRA_VEC_VALUES (ute.destroy_flag), ute.destroy_flag);

	if wakeup_from = USER
	then
	     call Process_User_Wakeup ();
	else
	     call Process_System_Wakeup ();

	if destroy_index < lbound (term_handler, 1) |
	     destroy_index > hbound (term_handler, 1)
	then
	     call Abort (-1,
		"UTE (^d, ^p in ^a) wakeup (^a, ^24.3b) from ^a with unexpected destroy_index (^d).",
		ute.ute_index, utep, TABLE_NAMES (ute.process_type),
		signal_string, unspec(signal_string), WAKEUP_SOURCE (wakeup_from),
		destroy_index);

	signal_left_half =
	     substr (signal_string, 1, length (signal_left_half));

	if signal_string ^= "stopstop" &
	     signal_string ^= "termsgnl"
	then
	     ute.logout_type = signal_left_half;

	goto term_handler (destroy_index);

/* PT_FPE */
term_handler (1):
	if signal_left_half = "init" |
	     signal_left_half = "term" then do;
	     unspec (signal_term_code) = unspec (signal_string);
	     login_server_termination_response.status_code =
		signal_term_code.code;
	end;
	else					/* We should have SOME error code */
	     login_server_termination_response.status_code =
		error_table_$fatal_error;

	login_server_termination_response.flags.fatal_error = TRUE;
	call Prepare_To_Terminate_Process ();
	goto TERMINATE;

/**** PT_NEW_PROC */
term_handler (2):
	ute.destroy_flag = WAIT_NEW_PROC;
	goto TERMINATE;

/**** PT_LOGOUT_HOLD */
term_handler (3):
	if installation_parms.trusted_path_login then do;
	     ute.destroy_flag = WAIT_LOGOUT;
	     login_server_termination_response.status_code =
		as_error_table_$no_logout_hold;
	end;
	else					/* ^trusted_path_login */
	     ute.destroy_flag = WAIT_LOGOUT_HOLD;
	goto TERMINATE;

/**** PT_LOGOUT */
term_handler (4):
	ute.destroy_flag = WAIT_LOGOUT;
	goto TERMINATE;

/**** PT_LOGOUT_BRIEF */
term_handler (5):
	login_server_termination_response.flags.brief = TRUE;
	ute.destroy_flag = WAIT_LOGOUT;
	goto TERMINATE;

/**** PT_LOGOUT_HOLD_BRIEF */
term_handler (6):
	if installation_parms.trusted_path_login then do;
	     login_server_termination_response.status_code =
		as_error_table_$no_logout_hold;
	     ute.destroy_flag = WAIT_LOGOUT;
	end;
	else do;					/* ^trusted_path_login */
	     login_server_termination_response.flags.brief = TRUE;
	     ute.destroy_flag = WAIT_LOGOUT_HOLD;
	end;
	goto TERMINATE;

/**** PT_INITIALIZATION_ERROR, init_err */
term_handler (7):
	login_server_termination_response.flags.offer_help = TRUE;
	login_server_termination_response.flags.fpe_during_init = TRUE;
	login_server_termination_response.status_code =
	     as_error_table_$init_err;
	ute.destroy_flag = WAIT_LOGOUT_HOLD;
	goto TERMINATE;

/**** PT_IO_ATTACHMENT_ERROR, no_ioatt */
term_handler (8):
	login_server_termination_response.flags.offer_help = TRUE;
	login_server_termination_response.status_code =
	     as_error_table_$no_io_attach;
	ute.destroy_flag = WAIT_LOGOUT_HOLD;
	goto TERMINATE;

/**** PT_BAD_INITIAL_PROCEDURE, no_initp */
term_handler (9):
	login_server_termination_response.status_code =
	     as_error_table_$no_init_proc;
	login_server_termination_response.flags.fpe_during_init = TRUE;
	login_server_termination_response.flags.offer_help = TRUE;
	ute.destroy_flag = WAIT_LOGOUT_HOLD;
	goto TERMINATE;

/**** PT_DISCONNECT_COMMAND */
term_handler (10):					/* User typed disconnect */
	if ^ute.at.disconnect_ok then do;
	     login_server_termination_response.status_code =
		as_error_table_$no_perm_disc;
	     login_server_termination_response.fatal_error = TRUE;
	     call Prepare_To_Terminate_Process();
	     goto TERMINATE;
	end;
	if installation_parms.trusted_path_login then do;
	     login_server_termination_response.status_code =
		as_error_table_$no_disc_hd;
	end;
	else login_server_termination_response.status_code =
		as_error_table_$disc_hd_msg;
	goto term_handler (20);

/**** PT_OBSOLETE_1 */
term_handler (11):
	goto term_handler (PT_LOGOUT);

/**** PT_INACTIVITY_RECEIVED */
term_handler (12):

	if (ute.preempted = PREEMPT_BUMPED &
	     ute.activity_can_unbump) then do;
						/* user waiting on bump timer */
	     call asu_$reschedule_bump_timer (utep, installation_parms.warning_time);
	end;
	go to RETURN;

/**** PT_NEW_PROC_AUTH */
term_handler (13):
	ute.destroy_flag = WAIT_NEW_PROC;
	if ute.disconnected then do;
	     login_server_termination_response.status_code =
		as_error_table_$illegal_new_proc;
	     ute.destroy_flag = WAIT_LOGOUT;
	end;
	else do;					/* not a disconnected process */
	     unspec (new_proc_auth) = unspec (signal_string);
	     if ^aim_check_$in_range ((new_proc_auth.authorization),
		ute.process_authorization_range) then do;
		login_server_termination_response.status_code =
		     as_error_table_$illegal_new_proc;
	     end;
/**** TBS: Check channel authorization */
	     else if installation_parms.trusted_path_login then do;
		if ^aim_check_$equal ((new_proc_auth.authorization),
		     ute.process_authorization)
		then
		     login_server_termination_response.status_code =
			as_error_table_$illegal_new_proc;
	     end;
	     else do;				/* everything ok */
		ute.process_authorization = new_proc_auth.authorization;
		if ute.whotabx > 0
		then
		     whotab.e (ute.whotabx).process_authorization =
			ute.process_authorization;
	     end;
	end;
	goto TERMINATE;

/**** PT_TERM_SIGNAL */
term_handler (14):

/**** ute.preempted says what to do here:
     -1  user unbumped after term signal sent
      0  user unbumped; ignore alarm___
      1  value internally used in load_ctl_
      2  user bumped; when alarm___ comes in, send term signal
      3  term signal sent; destroy process if termsgnl, alarm___, or cpulimit
         signals come in
      4  user bumped; process sick, so destroy without sending term signal
      5  trm_ signal sent, termsgnl received; (if still 3, we never got the
         termsgnl).						       */

	call timer_manager_$reset_alarm_wakeup (ute.event);
	if ute.preempted = PREEMPT_UNBUMP then do;	/* unbumped too late */
	     login_server_termination_response.status_code =
		as_error_table_$bump_cancelled;
	     ute.destroy_flag = WAIT_NEW_PROC;		/* give user a new process. Best we can do. */
	     call Prepare_To_Terminate_Process ();
	end;
	else if ute.preempted = PREEMPT_TERM_SENT then do;/* sent trm_ signal, expecting this */
	     ute.preempted = PREEMPT_TERMSGNL_RECEIVED;	/* no longer expected termsgnl */
	     goto term_handler (ute.logout_index);	/* continue doing it */
	end;
	else do;					/* unexpected termsgnl */
	     login_server_termination_response.status_code =
		as_error_table_$illegal_signal;
	     login_server_termination_response.fatal_error = TRUE;
	     ute.logout_type = "term";
	     call Prepare_To_Terminate_Process ();
	end;
	goto TERMINATE;

/**** PT_UNUSED_1 */
term_handler (15):
	goto term_handler (PT_LOGOUT);

/**** PT_UNUSED_2 */
term_handler (16):
	goto term_handler (PT_LOGOUT);

/**** PT_UNUSED_3 */
term_handler (17):
	goto term_handler (PT_LOGOUT);

/**** PT_UNUSED_4 */
term_handler (18):
	goto term_handler (PT_LOGOUT);

/**** PT_UNUSED_5 */
term_handler (19):
	goto term_handler (PT_LOGOUT);

/**** PT_HANGUP */
term_handler (20):
	if ute.active = NOW_HAS_PROCESS &
	     ute.preempted <= PREEMPT_UNBUMP_IGNORE_ALARM
	then
	     if ute.save_if_disconnected then do;
		call Disconnect_Process ();
		goto RETURN;
	     end;
	     else if signal_string = "disconn" then do;
		call Disconnect_Process ();
		call Notify_LS_After_Disconnect;
		goto RETURN;
	     end;
	if asu_$send_term_signal (utep, PT_HANGUP)
	then
	     goto RETURN;				/* come back later */
	else do;
	     ute.destroy_flag = WAIT_LOGOUT;
	     ute.logout_type = "hngp";		/* "hang" would be misleading */
	end;
	goto TERMINATE;

/**** PT_SHUTDOWN */
term_handler (21):
	if asu_$send_term_signal (utep, PT_SHUTDOWN)
	then
	     goto RETURN;
	else do;
	     ute.destroy_flag = WAIT_LOGOUT;
	     login_server_termination_response.status_code =
		as_error_table_$shutdown;
	end;
	goto TERMINATE;

/**** PT_BUMP */
term_handler (22):
	if asu_$send_term_signal (utep, PT_BUMP)
	then
	     goto RETURN;
	else do;
	     ute.destroy_flag = WAIT_LOGOUT;
	     login_server_termination_response.status_code =
		as_error_table_$automatic_logout;
	end;
	goto TERMINATE;

/**** PT_ALARM */
term_handler (23):
	if ute.sus_sent & ^ute.suspended
	then					/* timeout on sus response */
	     call Process_Ignored_Sus_Signal ();
	else if ute.preempted <= PREEMPT_UNBUMP_IGNORE_ALARM
	then					/* unbumped */
	     goto RETURN;
	else do;
	     if (ute.preempted = PREEMPT_BUMPED & ute.activity_can_unbump)
	     then do;
		call Process_Bump_Timer (code);	/* bump timer went off, see if user woke up */
		if code = 0
		then go to term_handler (PT_UNBUMP);	/* unbump */
	     end;
	     if asu_$send_term_signal (utep, PT_ALARM)
	     then
		goto RETURN;
	     else if ute.preempted = PREEMPT_TERM_SENT then do;
						/* already send trm_ signal */
		call Process_Ignored_Trm_Signal ();
	     end;
	     else do;
		ute.destroy_flag = WAIT_LOGOUT;
		if anstbl.session = AT_SHUTDOWN
		then
		     login_server_termination_response.status_code =
			as_error_table_$shutdown;
		else
		     login_server_termination_response.status_code =
			as_error_table_$automatic_logout;
	     end;
	end;
	goto TERMINATE;

/**** PT_DETACH, detach */
term_handler (24):
	if ute.active < NOW_HAS_PROCESS then do;	/* never get here */
	     goto RETURN;				/* handled at top */
	end;					/* of program.   */
	else if asu_$send_term_signal (utep, PT_DETACH)
	then
	     goto RETURN;
	else do;
	     ute.destroy_flag = WAIT_LOGOUT;
	     login_server_termination_response.status_code =
		as_error_table_$automatic_logout;
	end;
	goto TERMINATE;

/**** PT_UNBUMP */
term_handler (25):
	ute.activity_can_unbump = FALSE;
	if ute.preempted = PREEMPT_TERM_SENT
	then					/* already sent trm_ */
	     ute.preempted = PREEMPT_UNBUMP;		/* remember this */
	else ute.preempted = PREEMPT_UNBUMP_IGNORE_ALARM; /* no longer preempted */
	goto RETURN;

/**** PT_STOPSTOP */
term_handler (26):
	if ute.destroy_flag <= WAIT_LOGOUT_SIG then do;
	     call Log ("Premature stopstop for ^[*^]^a.^a ^a ^12.3b.",
		(ute.anonymous = 1), ute.person, ute.project, ute.tty_name,
		ute.proc_id);
	     call hcs_$wakeup (anstbl.as_procid, ute.event, termstop_msg, (0));
	     call hcs_$wakeup (anstbl.as_procid, ute.event, stopstop_msg, (0));
	end;
	else do;
	     call dpg_$finish (utep);
	     call act_ctl_$dp (utep);
	     ute.active = NOW_LOGGED_IN;

/**** If the user has been bumped (by the operator or for a shutdown), don't
      let him get out of the bump by getting a new process.  Otherwise,
      indicate that the user is no longer in the state of process
      destruction. */

	     if ute.destroy_flag ^= WAIT_NEW_PROC & ute.destroy_flag ^= WAIT_NEW_PROC_REQUEST
	     then
		do;
		call Close_Account_And_Logout ();
		if ute.destroy_flag = WAIT_DESTROY_REQUEST
		then
		     call Notify_LS_With_Process_Response (WAIT_DESTROY_REQUEST, 0);
	     end;
	     else do;				/* user is getting a new process */
		saved_destroy_flag = ute.destroy_flag;	/* uc_create_process_ will clobber ute.destroy_flag */

		if ute.preempted >= PREEMPT_TERM_SENT
		then
		     ute.preempted = PREEMPT_UNBUMP_IGNORE_ALARM;

		call uc_create_process_ (utep, code);
		if code ^= 0
		then
		     call Close_Account_And_Logout ();

		if saved_destroy_flag = WAIT_NEW_PROC
		then
		     call Send_New_Process_Response (code);
		else
		     call Notify_LS_With_Process_Response (saved_destroy_flag, code);

		if code = 0
		then
		     goto RETURN;			/* i.e. do not free UTE */
	     end;
	     call user_table_mgr_$free (utep);
	end;
	goto RETURN;

/**** PT_OPERATOR_TERMINATE, terminat */
term_handler (27):
	if asu_$send_term_signal (utep, PT_OPERATOR_TERMINATE)
	then
	     goto RETURN;
	else do;
	     login_server_termination_response.status_code =
		as_error_table_$term_by_operator;
	     login_server_termination_response.flags.fatal_error = TRUE;
	     call Prepare_To_Terminate_Process ();
	end;
	goto TERMINATE;

/**** PT_TERMSTOP */
term_handler (28):

	ute.destroy_flag = WAIT_LOGOUT_HOLD;
	login_server_termination_response.status_code =
	     as_error_table_$no_signal;
	goto TERMINATE;

/**** PT_CPU_LIMIT */
term_handler (29):

	if ute.ignore_cpulimit then do;
	     ute.ignore_cpulimit = FALSE;
	     goto RETURN;
	end;
	if ute.preempted = PREEMPT_TERM_SENT then do;
	     call timer_manager_$reset_alarm_wakeup (ute.event);
	     call Process_Ignored_Trm_Signal ();
	end;
	else if ute.sus_sent then do;
	     call timer_manager_$reset_alarm_wakeup (ute.event);
	     call Process_Ignored_Sus_Signal ();
	     goto TERMINATE;
	end;
	else
	     call Abort (-1,
		"Unexpected cpulimit wakeup for ^[*^]^a.^a ^a ^12.3b.",
		(ute.anonymous = 1), ute.person, ute.project, ute.tty_name,
		ute.proc_id);
	goto RETURN;

/**** PT_DESTROY_REQUEST */
term_handler (30):

/**** We get here when the user has used the -destroy control argument to the
      login command, or the "destroy" login server request.  The user process
      has been sent the trm_ signal, and has either responded properly with
      the "termsgnl", or our real or cpu timer has gone off.  In any case, we
      must now destroy the process.  When the process has destroyed itself,
      we receive the "stopstop" wakeup from ring-0 and the handler for this
      wakeup, above, will notify the login server for user. */

	ute.destroy_flag = WAIT_DESTROY_REQUEST;
	call Kill_Process ();
	goto RETURN;

/**** PT_NEW_PROC_REQUEST */
term_handler (31):

/**** We get here when the user has used the -new_proc control argument to the
      login command, or the "new_proc" login server request. The user process
      has been sent the trm_ signal, and has responded (or timed out).  Now
      we must destroy the process. */

	ute.destroy_flag = WAIT_NEW_PROC_REQUEST;
	call Kill_Process ();
	goto RETURN;

TERMINATE:
	call Kill_Process_And_Notify_LS ();

RETURN:
	call Clean_Up ();
	return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/*                 I N T E R N A L       P R O C E D U R E S	       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* Abort:  Report errors via sys_log_$general and stop execution.	       */
/*							       */
/* Syntax:  call Abort (code, ioa_ctl, args);			       */
/*							       */
/*							       */
/* Log, Log_Error:  Report errors via sys_log_$general.		       */
/*							       */
/* Syntax:  call Log (ioa_ctl, args);				       */
/*	  call Log_Error (code, ioa_ctl, args);			       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

Abort:
     procedure options (variable);

dcl  cu_$arg_list_ptr       entry returns (ptr);
dcl  sys_log_$general       entry (ptr);

	sl_info = sl_info_code_msg;
	sl_info.arg_list_ptr = cu_$arg_list_ptr ();
	sl_info.severity = SL_LOG_SILENT;
	sl_info.caller = ME;
	call sys_log_$general (addr (sl_info));
	code = sl_info.code;
	if code ^= 0
	then go to RETURN;
	return;

Log:
     entry options (variable);
	sl_info = sl_info_msg;
	sl_info.arg_list_ptr = cu_$arg_list_ptr ();
	sl_info.severity = SL_LOG_SILENT;
	sl_info.caller = ME;
	call sys_log_$general (addr (sl_info));
	return;

Log_Error:
     entry options (variable);
	sl_info = sl_info_code_msg;
	sl_info.arg_list_ptr = cu_$arg_list_ptr ();
	sl_info.severity = SL_LOG_SILENT;
	sl_info.caller = ME;
	call sys_log_$general (addr (sl_info));
	return;

     end Abort;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


Clean_Up:
     procedure ();

/**** Stop metering time in this procedure. */
	if metering_enabled
	then
	     call as_meter_$exit (DIALUP_METER);
	return;
     end Clean_Up;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


Close_Account_And_Logout:
     procedure ();

	call act_ctl_$close_account (utep);
	call uc_logout_ (utep, ute.logout_type);
	return;
     end Close_Account_And_Logout;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


Convert_Status_Code:
     procedure (P_code) returns (char (100) aligned);

dcl  P_code	        fixed bin (35) parameter;
dcl  status_code_short      char (8) aligned automatic;
dcl  status_code_string     char (100) aligned automatic;

	call convert_status_code_ (P_code, status_code_short,
	     status_code_string);
	return (status_code_string);

Convert_Status_Code_Short:
     entry (P_code) returns (char (8) aligned);

	call convert_status_code_ (P_code, status_code_short,
	     status_code_string);
	return (status_code_short);

     end Convert_Status_Code;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


Disconnect_Process:
     procedure ();

	call asu_$suspend_process (utep);
	ute.disconnected = TRUE;
	ute.disconnection_rel_minutes = divide (clock () - ute.login_time, USEC_PER_MINUTE, 17, 0);
	if ute.whotabx > 0
	then
	     whotab.e (ute.whotabx).disconnected = TRUE;
	ute.pdtep -> user.n_disconnected =
	     max (0, ute.pdtep -> user.n_disconnected + 1);
	call as_access_audit_$process (utep, AS_AUDIT_PROCESS_DISCONNECT, "hangup");
	call as_access_audit_$logout (utep, "disconnect");
	return;
     end Disconnect_Process;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


Get_Group_ID:
     procedure () returns (char (32) varying);

dcl  group	        char (32) varying;

	group = "";
	if ute.person ^= "" then do;
	     group = rtrim (ute.person);
	     group = group || ".";
	     group = group || rtrim (ute.project);
	     group = group || ".";
	     group = group || ute.tag;
	end;
	return (group);
     end Get_Group_ID;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


Get_Start_Event_Channel:
     procedure () returns (fixed bin (71));

dcl  local_code	        fixed bin (35) automatic;
dcl  r_factor	        fixed bin (35) automatic;
dcl  r_offset	        fixed bin (18) automatic;
dcl  start_event_channel    fixed bin (71) automatic;

dcl  hphcs_$get_ipc_operands
		        entry (bit (36) aligned, fixed bin (18), fixed bin (35), fixed bin (35));
dcl  ipc_validate_$encode_event_channel_name
		        entry (fixed bin (18), fixed bin (35), bit (3) aligned,
		        fixed bin (15), fixed bin (3), bit (1) aligned, fixed bin (18), fixed bin (71));

/**** We must construct an event channel which will pass the IPC event
      channel validation tests. To do this, we must learn the values of
      R-Offset and R-Factor for the process. */

	call hphcs_$get_ipc_operands (ute.proc_id, r_offset, r_factor, local_code);
	if local_code = 0 then do;
	     call ipc_validate_$encode_event_channel_name (r_offset, r_factor,
		"000"b /* flags */, 1 /* index */, 4 /* ring */,
		"1"b /* regular */, 1 /* unique id */,
		start_event_channel);
	end;
	else do;
	     call Log_Error (local_code,
		"Retrieving R-Offset and R-Factor for ^[*^]^a.^a ^a ^12.3b",
		(ute.anonymous = 1), ute.person, ute.project, ute.tty_name,
		ute.proc_id);
	     start_event_channel = 0;
	end;
	return (start_event_channel);
     end Get_Start_Event_Channel;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


Kill_Login_and_Notify_LS:
     procedure;

dcl  1 local_ls_reply_message
		        aligned like ls_reply_message automatic;

	ls_response_ptr = addr (auto_termination_response);
	login_server_termination_response.process_id =	/* dialed terms  */
	     ute.proc_id;				/* have target   */
						/* proc's ID.    */
	login_server_termination_response.process_group_id = Get_Group_ID ();
	login_server_termination_response.status_code =
	     as_error_table_$term_by_operator;
	login_server_termination_response.flags.fatal_error = TRUE;
	login_server_termination_response.flags.logout = TRUE;
	login_server_termination_response.flags.hold = TRUE;

	unspec (local_ls_reply_message) = ""b;
	call uc_send_ls_response_ (ls_response_ptr,
	     currentsize (login_server_termination_response),
	     ute.login_server_info.process_id,
	     ute.login_server_info.his_handle,
	     ute.login_server_info.response_event_channel,
	     addr (local_ls_reply_message), (ute.tty_name), 0, code);
	if code ^= 0
	then
	     call Log_Error (code,
		"Sending termination response for ^[*^]^a.^a ^a ^12.3b to login server.",
		(ute.anonymous = 1), ute.person, ute.project, ute.tty_name,
		ute.proc_id);

	call uc_logout_ (utep, "bump");
	if ute.login_flags.operator |
	     ute.login_flags.special_pw.dial_pw then do;
						/* MC terminal   */
	     call mc_commands_$remove_tty (ute.tty_name, "1"b, code);
	     if code ^= 0
	     then
		call Log_Error (code,
		     "Removing ^a from the MC answer table.", ute.tty_name);
	end;
	call user_table_mgr_$free (utep);
	goto RETURN;

     end Kill_Login_and_Notify_LS;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


Kill_Process:
     procedure ();

	if ute.active = NOW_HAS_PROCESS
	then
	     call dpg_ (utep, (signal_string));
	return;
     end Kill_Process;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


Kill_Process_And_Notify_LS:
     procedure ();

	call Kill_Process ();
	ls_response_ptr = addr (auto_termination_response);
	login_server_termination_response.process_id = ute.proc_id;
	login_server_termination_response.process_group_id = Get_Group_ID ();
	if ute.destroy_flag = WAIT_LOGOUT then do;
	     login_server_termination_response.flags.logout = TRUE;
	     login_server_termination_response.flags.hold = FALSE;
	end;
	else if ute.destroy_flag = WAIT_LOGOUT_HOLD then do;
	     login_server_termination_response.flags.logout = TRUE;
	     login_server_termination_response.flags.hold = TRUE;
	end;
	else if ute.destroy_flag = WAIT_NEW_PROC
	then
	     login_server_termination_response.flags.new_proc = TRUE;
	else
	     call Abort (-1,
		"ute.destroy_flag = ^d at after process destruction.",
		ute.destroy_flag);
	call Notify_LS ();
	return;

     end Kill_Process_And_Notify_LS;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


Notify_LS:
     procedure;

dcl  1 local_ls_reply_message
		        aligned like ls_reply_message automatic;

	login_server_termination_response.accounting_info.cpu_usage =
	     ute.cpu_usage;
	login_server_termination_response.accounting_info.cost =
	     ute.session_cost;

	unspec (local_ls_reply_message) = ""b;
	call uc_send_ls_response_ (ls_response_ptr,
	     currentsize (login_server_termination_response),
	     ute.login_server_info.process_id,
	     ute.login_server_info.his_handle,
	     ute.login_server_info.termination_event_channel,
	     addr (local_ls_reply_message), (ute.tty_name), 0, code);
	if code ^= 0
	then
	     call Log_Error (code,
		"Could not send process termination response for ^a.^a.^a to login server.",
		ute.person, ute.project, ute.tag);

     end Notify_LS;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


Notify_LS_After_Disconnect:				/* Called for    */
     procedure ();					/*  user-typed   */
						/*  disconnect   */
						/*  command.     */

	login_server_termination_response.flags.logout = TRUE;
	if login_server_termination_response.status_code =
	     as_error_table_$disc_hd_msg
	then
	     login_server_termination_response.flags.hold = TRUE;
	else login_server_termination_response.flags.hold = FALSE;
	call Notify_LS ();
	return;

     end Notify_LS_After_Disconnect;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


Notify_LS_With_Process_Response:
     procedure (P_reason, P_code);

/**** This procedure is called to notify the Login Server for a user of the
      successful execution of the "destroy" or "new_proc" login server
      requests. */

dcl  P_reason	        fixed bin parameter;
dcl  P_code	        fixed bin (35) parameter;

dcl  1 local_ls_reply_message
		        aligned like ls_reply_message automatic;

	unspec (local_ls_reply_message) = ""b;
	local_ls_reply_message.code = P_code;

	ls_process_response_accounting_message_length = 0;
	ls_response_ptr = addr (auto_process_response);
	unspec (login_server_process_response) = ""b;

	login_server_process_response.header.message_type = LS_PROCESS_RESPONSE;
	login_server_process_response.header.version = LOGIN_SERVER_PROCESS_RESPONSE_VERSION_1;

	login_server_process_response.status_code = P_code;
	login_server_process_response.process_id = ute.proc_id;
/**** Since we've switched UTEs on the loging server, we need to apprise it
      of the new handle associated with this connection. */

	login_server_process_response.new_handle = ute.login_server_info.our_handle;
	login_server_process_response.authorization = ute.process_authorization;
	login_server_process_response.process_group_id = Get_Group_ID ();
	login_server_process_response.process_number = 0;

	if ute.pdtep ^= null
	then
	     login_server_process_response.n_disconnected_processes =
		ute.pdtep -> user.n_disconnected;
	else login_server_process_response.n_disconnected_processes = 0;

	if P_reason = WAIT_NEW_PROC_REQUEST
	then
	     login_server_process_response.start_event_channel = Get_Start_Event_Channel ();

	login_server_process_response.login_instance = 0;

	login_server_process_response.accounting_info.cpu_usage = ute.cpu_usage;
	login_server_process_response.accounting_info.cost = ute.session_cost;

	if P_reason = WAIT_DESTROY_REQUEST
	then do;
	     login_server_process_response.flags.destroyed = TRUE;
/**** This could be based on an installation parameter */
	     login_server_process_response.flags.logout = TRUE;
	end;
	else if P_reason = WAIT_NEW_PROC_REQUEST
	then
	     login_server_process_response.flags.new_proc = TRUE;

	login_server_process_response.initial_ring = ute.initial_ring;
	login_server_process_response.already_logged_in_info.connection_name = "";
	login_server_process_response.already_logged_in_info.terminal_type = "";
	login_server_process_response.already_logged_in_info.terminal_id = "";
	login_server_process_response.accounting_message_length = 0;

	call uc_send_ls_response_ (ls_response_ptr,
	     currentsize (login_server_process_response),
	     ute.login_server_info.process_id,
	     ute.login_server_info.his_handle,
	     ute.login_server_info.response_event_channel,
	     addr (local_ls_reply_message), (ute.tty_name), 0, code);
	if code ^= 0
	then
	     call Log_Error (code, "Sending login server response for process destruction of ^a.^a.^a.", ute.person,
		ute.project, ute.tag);
	return;
     end Notify_LS_With_Process_Response;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


Prepare_To_Terminate_Process:
     procedure ();

          call as_access_audit_$process (utep, AS_AUDIT_PROCESS_TERMINATE,
	     Convert_Status_Code_Short(
	     login_server_termination_response.status_code));
	if ute.disconnected
	then
	     ute.destroy_flag = WAIT_LOGOUT;
	else if substr (signal_string, 1, 4) = "init" then do;
						/* during init */
	     ute.destroy_flag = WAIT_LOGOUT_HOLD;
	     login_server_termination_response.flags.fpe_during_init = TRUE;
	     login_server_termination_response.flags.offer_help = TRUE;
	end;
	else do;					/* not during init */
	     if ute.recent_fatal_error_time +
		installation_parms.fatal_error_loop_seconds * USEC_PER_SECOND <
		anstbl.current_time then do;
		if ute.uflags.fpe_causes_logout then do;
		     login_server_termination_response.flags.fpe_caused_logout = TRUE;
		     ute.destroy_flag = WAIT_LOGOUT_HOLD;
		end;
		else do;				/* ^fpe_causes_logout */
		     ute.recent_fatal_error_time = anstbl.current_time;
		     ute.recent_fatal_error_count = 1;
		     ute.destroy_flag = WAIT_NEW_PROC;
		end;
	     end;
	     else do;				/* recent fatal process error */
		ute.recent_fatal_error_count =
		     ute.recent_fatal_error_count + 1;
		if ute.recent_fatal_error_count <
		     installation_parms.fatal_error_loop_count
		then
		     ute.destroy_flag = WAIT_NEW_PROC;
		else				/* exceeded fatal_error_loop_count */
		     do;
		     ute.destroy_flag = WAIT_LOGOUT_HOLD;
		     login_server_termination_response.flags.fpe_loop = TRUE;
		     login_server_termination_response.flags.offer_help = TRUE;
		end;
	     end;
	end;
	return;
     end Prepare_To_Terminate_Process;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


Process_Bump_Timer:
     procedure (P_code);

dcl  P_code	        fixed bin (35);
dcl  code		        fixed bin (35);
dcl  user_id	        char (32);

	call act_ctl_$activity_unbump (utep, P_code);
	if P_code = 0 then do;			/* acceptably active */
	     call Log ("Cancelling inactivity bump of ^a.^a", ute.person, ute.project);
						/* notify user of unbump */
	     user_id = rtrim (ute.person) || "." ||	/* build Person.Project */
		rtrim (ute.project);
	     unspec (send_mail_info) = "0"b;
	     send_mail_info.version = send_mail_info_version_2;
	     send_mail_info.wakeup = "1"b;
	     send_mail_info.always_add = "1"b;
	     send_mail_info.sent_from = "answering service";

	     call send_mail_$access_class (user_id, Convert_Status_Code (as_error_table_$activity_unbump),
		addr (send_mail_info), ute.process_authorization, code);
	     if code ^= 0 & code ^= error_table_$messages_deferred & code ^= error_table_$messages_off
	     then call Log_Error (code, "When attempting to notify user ^a of dialup event", user_id);
	end;
     end Process_Bump_Timer;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


Process_Ignored_Sus_Signal:
     procedure ();

	call Log ("sus_ signal ignored by ^[*^]^a.^a ^a ^12.3b.",
	     (ute.anonymous = 1), ute.person, ute.project, ute.tty_name,
	     ute.proc_id);

	if asu_$send_term_signal (utep, PT_HANGUP)
	then
	     goto RETURN;
	else
	     ute.destroy_flag = WAIT_LOGOUT;
	return;
     end Process_Ignored_Sus_Signal;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


Process_Ignored_Trm_Signal:
     procedure ();

	ute.preempted = PREEMPT_TERMSGNL_RECEIVED;	/* no longer waiting termsgnl */

	call Log ("process ignored trm_ signal ^a.^a.^a on channel ^a.",
	     ute.person, ute.project, ute.tag, ute.tty_name);

	if ute.logout_index = PT_ALARM then do;		/* bump */
	     ute.destroy_flag = WAIT_LOGOUT;
	     if anstbl.session = AT_SHUTDOWN
	     then
		login_server_termination_response.status_code =
		     as_error_table_$shutdown;
	     else
		login_server_termination_response.status_code =
		     as_error_table_$automatic_logout;
	     call Kill_Process_And_Notify_LS ();
	end;
	else goto term_handler (ute.logout_index);	/* not bump */

     end Process_Ignored_Trm_Signal;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


Process_Sus_Response:
     procedure ();

	ute.sus_channel = event_call_info.message;
	if ^ute.ignore_cpulimit then do;		/* not released before responded */
	     ute.suspended = TRUE;
	     if ute.whotabx > 0
	     then
		whotab.e (ute.whotabx).suspended = TRUE;
/**** Turn off realtime timer we set for responded to sus_ signal. */
	     call timer_manager_$reset_alarm_wakeup (ute.event);
	end;
	else do;					/* released before responded */
	     ute.sus_sent = FALSE;
	     if ute.whotabx > 0
	     then
		whotab.e (ute.whotabx).suspended = FALSE;
/**** Tell process it may run again. */
	     call hcs_$wakeup (ute.proc_id, ute.sus_channel, 0, (0));
	end;
	return;

     end Process_Sus_Response;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


Process_System_Wakeup:
     procedure ();

	do destroy_index = 1 to as_data_$system_signal_types.n_system_signals
	     while (signal_string ^=
	     as_data_$system_signal_types.system_signals (destroy_index));
	end;

	if destroy_index <=
	     as_data_$system_signal_types.n_system_signals
	then
	     destroy_index = destroy_index + MAX_USER_SIGNALS;
	else
	     call Abort (-1, "Invalid system signal ^a.", signal_string);
	return;
     end Process_System_Wakeup;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


Process_User_Wakeup:
     procedure ();

	do destroy_index = 1 to as_data_$signal_types.n_signals
	     while (signal_string ^=
	     as_data_$signal_types.signals (destroy_index));
	end;

	if destroy_index <= as_data_$signal_types.n_signals
	then ;
	else if substr (signal_string, 1, 4) = "term" |
	     substr (signal_string, 1, 4) = "init"
	then
	     destroy_index = PT_FPE;
	else if substr (signal_string, 1, 2) = "np"
	then
	     destroy_index = PT_NEW_PROC_AUTH;
	else if ute.sus_sent & ^ute.suspended then do;
	     call Process_Sus_Response ();
	     goto RETURN;
	end;
	else do;
	     login_server_termination_response.status_code =
		as_error_table_$illegal_signal;
	     login_server_termination_response.flags.fatal_error = TRUE;
	     call Prepare_To_Terminate_Process ();
	     goto TERMINATE;
	end;
	return;
     end Process_User_Wakeup;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


Setup_LS_Termination_Response:
     procedure ();

	ls_response_ptr = addr (auto_termination_response);
	unspec (login_server_termination_response) = ""b;
	login_server_termination_response.header.message_type =
	     LS_TERMINATION_RESPONSE;
	login_server_termination_response.header.version =
	     LOGIN_SERVER_TERMINATION_RESPONSE_VERSION_1;
	login_server_termination_response.process_id = ute.proc_id;
	login_server_termination_response.process_group_id = Get_Group_ID ();
	return;
     end Setup_LS_Termination_Response;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


Send_New_Process_Response:
     procedure (P_code);

dcl  P_code	        fixed bin (35) parameter;
dcl  1 local_ls_reply_message
		        aligned like ls_reply_message automatic;

	if P_code ^= 0
	then
	     do;
	     call Log_Error (P_code, "Could not create new process for ^a.^a.^a.", ute.person, ute.project, ute.tag);
	     return;
	end;

	ls_response_ptr = addr (auto_new_proc_response);
	unspec (login_server_new_proc_response) = ""b;
	login_server_new_proc_response.header.message_type =
	     LS_NEW_PROC_RESPONSE;
	login_server_new_proc_response.header.version =
	     LOGIN_SERVER_NEW_PROC_RESPONSE_VERSION_1;
	login_server_new_proc_response.new_authorization =
	     ute.process_authorization;
	login_server_new_proc_response.new_start_event_channel =
	     Get_Start_Event_Channel ();
	login_server_new_proc_response.new_process_id =
	     ute.proc_id;

	unspec (local_ls_reply_message) = ""b;
	call uc_send_ls_response_ (ls_response_ptr,
	     currentsize (login_server_new_proc_response),
	     ute.login_server_info.process_id,
	     ute.login_server_info.his_handle,
	     ute.login_server_info.termination_event_channel,
	     addr (local_ls_reply_message), (ute.tty_name), 0, code);
	if code ^= 0
	then
	     call Log_Error (code,
		"Sending new process login server response for ^[*^]^a.^a ^a ^12.3b.",
		(ute.anonymous = 1), ute.person, ute.project, ute.tty_name,
		ute.proc_id);
	return;
     end Send_New_Process_Response;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


Validate_UTEp:
     procedure ();

/**** Ensure the utep supplied as the event call data pointer points into
      either the answer_table, the absentee_user_table, or the
      daemon_user_table.  Otherwise, reject the wakeup. */

	if utep = null ()
	then
	     call Abort (error_table_$null_info_ptr,
		"Null UTE pointer with wakeup (^a, ^24.3b) from process ^12.3b.",
		signal_string, unspec (signal_string),
		event_call_info.sender);

	if baseno (utep) ^= baseno (as_data_$ansp) &
	     baseno (utep) ^= baseno (as_data_$autp) &
	     baseno (utep) ^= baseno (as_data_$dutp)
	then
	     call Abort (-1,
		"Invalid UTE pointer (^p) with wakeup (^a, ^24.3b) from process ^12.3b.",
		utep, signal_string, unspec (signal_string),
		event_call_info.sender);
	return;
     end Validate_UTEp;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
/* format: off */
 %include access_audit_bin_header; /* not used, but needed by PL/I */
 %include answer_table;
 %include as_audit_structures;
 %include as_data_;
 %include as_meter_numbers;
 %include dialup_values;
 %include event_call_info;
 %include installation_parms;
 %include login_server_messages;
 %include pdt;

dcl  pdtp		        pointer automatic init(null);	/* required by pdt.incl.pl1 */
 %include send_mail_info;
 %include sys_log_constants;
 %include user_attributes;
 %include user_table_entry;
 %include user_table_header;
 %include whotab;

end uc_proc_term_handler_;
