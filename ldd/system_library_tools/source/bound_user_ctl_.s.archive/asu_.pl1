/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

/****^  HISTORY COMMENTS:
  1) change(86-01-29,Herbst), approve(87-07-13,MCR7697),
     audit(87-07-23,Brunelle), install(87-08-04,MR12.1-1055):
     Changed internal procedure BLAST_CHANNEL to BLAST_USER.
     Changed $blast_user to pass initial ring number to send_system_message_.
  2) change(86-03-11,MSharpe), approve(87-07-13,MCR7690),
     audit(87-07-23,Brunelle), install(87-08-04,MR12.1-1055):
     initiated P_code to 0 in "bump_user", so that it doesn't return a non-zero
     code  that it has received from the caller.
  3) change(86-05-13,GJohnson), approve(86-05-13,MCR7387),
     audit(86-05-13,Martinson), install(86-05-14,MR12.0-1055):
     Correct error message documentation.
  4) change(86-06-30,Swenson), approve(87-07-13,MCR7737),
     audit(87-07-23,Brunelle), install(87-08-04,MR12.1-1055):
     Added $setup_login_server_handle entry to initialize the handle in the
     UTE.
  5) change(87-02-24,Brunelle), approve(87-07-13,MCR7697),
     audit(87-07-23,GDixon), install(87-08-04,MR12.1-1055):
     Added parameter to internal procedure $BLAST_USER to signal whether this
     is a INACTIVITY or WARN message.
  6) change(87-04-09,Brunelle), approve(87-07-13,MCR7697),
     audit(87-07-23,GDixon), install(87-08-04,MR12.1-1055):
     Added entrypoint $reschedule_bump_timer to cancel the current bump timer
     and reschedule to new time.
  7) change(87-04-27,GDixon), approve(87-07-13,MCR7741),
     audit(87-07-23,Brunelle), install(87-08-04,MR12.1-1055):
     Upgraded for change to answer_table.incl.pl1 and user_table_entry.incl.pl1
  8) change(87-05-06,Brunelle), approve(87-07-13,MCR7697),
     audit(87-07-23,GDixon), install(87-08-04,MR12.1-1055):
     Fixed call to BLAST_USER in blast_user entrypoint to pass P_utep instead
     of utep.
  9) change(87-07-16,GDixon), approve(87-07-16,MCR7741),
     audit(87-07-23,Brunelle), install(87-08-04,MR12.1-1055):
      A) Use named constants when testing ute.preempted.
 10) change(87-07-22,GDixon), approve(87-07-22,MCR7741),
     audit(87-07-23,Brunelle), install(87-08-04,MR12.1-1055):
      A) Correct several minor errors found during auditing.
      B) Document undoc's sys_log_ calls.
 11) change(88-07-15,Brunelle), approve(88-09-13,MCR7980),
     audit(88-09-13,Beattie), install(88-09-16,MR12.2-1112):
     Pass entire UTE to send_system_message_ so it can get whatever info it
     needs about the user.
 12) change(88-12-09,Parisek), approve(89-04-05,MCR8086),
     audit(88-04-25,Beattie), install(89-05-02,MR12.3-1038):
     Release the UTE associated with a terminal in a login connect loop
     when the channel associated with that terminal is removed via the
     "remove" request.
                                                   END HISTORY COMMENTS */

/* format: style4 */

asu_:
     procedure ();

/* Answering service utility package

   Coded by Michael D. Schroeder, June 1969
   Revised for new System/User Control, and converted to PL/1
   by Michael J. Spier, January 1970
   Modified 750225 by PG to change calls to astty_$tty_order to pass argument pointer,
   .	and to create astty_$tty_changemode.
   Modified 750228 by PG to log all errors in asu_attach and asu_listen, and then remove line.
   Modified 750502 by PG to add asu_$reset
   Modified 750616 by PG to completely rewrite asu_attach, fixing several bugs
   Modified 750821 by PG & THVV for CDT
   Modified 760625 by Roy P. Planalp to introduce calls to network module ftp_dialup_
   .	 which performs the function of AS module dialup_ for Network FTP channels
   Modified 760819 by Roy Planalp to send ftp-format msgs when bumping or writing to ftp users,
   and to add utility routine to format ftp msgs.
   Modified August 1976 by T. Casey to make attach and attach_channel handle case of FNP not being up yet.
   Modified October 1976 by T. Casey to fix bug in error handling in attach.
   Modified September 1977 by T. Casey to fix bugs and make channel deletions reversible during the same bootload.
   Modified October 1977 by T. Casey to add send_term_signal entry.
   Modified January 1978 by T. Casey to fix bugs in previous modification.
   Modified May 1978 by T. Casey to add check_for_stopped_process entry, and to
   .	preserve privileged attachments of slave channels across FNP crashes,
   .	by having the listen entry point check for that case.
   Modified Fall 1978 by L.E.Johnson for ring zero demultiplexing.
   Modified March 1979 by T. Casey for MR7.0a to add suspend_process and release_suspended_process entries.
   Modified July 1979 by T. Casey for MR8.0 to support process preservation across hangups.
   Modified December 1980 by E. N. Kittlitz for bugfixes
   Modified March 1981 by Robert Coren to check for TANDD service type
   Modified June 1981 by T. Casey for MR9.0 for new wakeup priorities.
   Modified November 1981, E. N. Kittlitz.  user_table_entry conversion.
   Modified December 1981, E. N. Kittlitz.  whotab suspended/disconnected bits.
   Modified May 1982, E. N. Kittlitz. New AS initialization.
   Modified June 1982, B. I. Margulies, protect multiplexers from removes.
   Modified 84-04-02, BIM, remove references to cdte.dim
   and add reset_access_class.
   Modified 1984-08-07 BIM to reset_access_class at attach_channel
   and to give up as soon as we get a hangup error.
   Modified 84-10-03 by E. Swenson to incorporate Jim Falksen's changes
   for date_time_$format.
   Modified 84-11-27 by E. Swenson for new IPC validation.  Adds entry
   start_process which kicks a process out of the intitial blocked
   state.
   Modified 85-02-13 by E. Swenson for asu_$blast_user, asu_$blast_channel.
   Modified 85-11-18 by Steve Herbst to make $blast_user call send_system_message_.
*/

/* Parameters */

dcl  P_code fixed bin (35) parameter;
dcl  P_error_message char (*) parameter;		/* error message for caller */
dcl  P_message char (*) parameter;			/* message to blast on terminal */
dcl  P_utep ptr parameter;

dcl  (bv_ptr_1 ptr,					/* pointer which appears in parameter position 1 */
     p2 ptr,
     bv_code_2 fixed bin (35),			/* error code which appears in parameter position 2 */
     bv_tty_name char (*)				/* argument to asu_attach */
     ) parameter;

/* Conditions */

dcl  cleanup condition;

/* Builtins */

dcl  (addr, baseno, bit, clock, divide, index, length, mod, null, rtrim, substr, unspec) builtin;

/* Entries */

dcl  aim_check_$equal entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
dcl  astty_$tty_detach entry (ptr, fixed bin, fixed bin (35));
dcl  astty_$tty_event entry (ptr, fixed bin (35));
dcl  astty_$tty_force entry (ptr, ptr, fixed bin, fixed bin (35));
dcl  astty_$tty_index entry (ptr, fixed bin (35));
dcl  astty_$tty_order entry (ptr, char (*), ptr, fixed bin (35));
dcl  astty_$tty_state entry (ptr, fixed bin (35));
dcl  asu_$asu_listen entry (ptr, fixed bin (35));
dcl  asu_$attach_channel entry (ptr, fixed bin (35));
dcl  asu_$release_ate entry (ptr, fixed bin (35));
dcl  asu_$channel_in_use entry (ptr) returns (bit (1) aligned);
dcl  convert_status_code_ entry (fixed bin (35), char (*) aligned, char (*) aligned);
dcl  date_time_$format entry (char (*), fixed bin (71), char (*), char (*)) returns (char (250) var);
dcl  dial_ctl_$dial_term entry (ptr);
dcl  dialup_ entry;
dcl  dpg_ entry (ptr, char (*));
dcl  ftp_dialup_ entry;
dcl  ftp_dialup_$init entry;
dcl  get_system_free_area_ entry () returns (ptr);
dcl  hcs_$set_ips_mask entry (bit (36) aligned, bit (36) aligned);
dcl  hcs_$wakeup entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
dcl  hphcs_$get_ipc_operands entry (bit (36) aligned, fixed bin (18), fixed bin (35), fixed bin (35));
dcl  hphcs_$ips_wakeup entry (bit (36) aligned, char (*));
dcl  hphcs_$process_status entry (ptr);
dcl  hphcs_$set_cpu_monitor entry (bit (36) aligned, fixed bin (71), fixed bin (35));
dcl  (ioa_$rsnnl, ioa_$rs) entry options (variable);
dcl  ipc_$create_ev_chn entry (fixed bin (71), fixed bin (35));
dcl  ipc_$decl_ev_call_chn entry (fixed bin (71), entry, ptr, fixed bin, fixed bin (35));
dcl  ipc_$drain_chn entry (fixed bin (71), fixed bin (35));
dcl  ipc_$unmask_ev_calls entry (fixed bin (35));
dcl  ipc_validate_$encode_event_channel_name entry (fixed bin (18), fixed bin (35), bit (3) aligned, fixed bin (15),
	fixed bin (3), bit (1) aligned, fixed bin (18), fixed bin (71));
dcl  send_system_message_ entry (ptr, ptr, fixed bin (35));
dcl  sub_err_ entry () options (variable);
dcl  sys_log_ entry options (variable);
dcl  sys_log_$error_log entry options (variable);
dcl  timer_manager_$alarm_wakeup entry (fixed bin (71), bit (2), fixed bin (71));
dcl  timer_manager_$reset_alarm_wakeup entry (fixed bin (71));
dcl  user_table_mgr_$allocate entry (fixed bin) returns (ptr);
dcl  user_table_mgr_$free entry (ptr);

/* External */

dcl  (as_error_table_$bump_mins_msg,
     as_error_table_$bump_secs_msg,
     as_error_table_$from_multics_msg,
     as_error_table_$inactive,
     as_error_table_$tty_already,
     as_error_table_$tty_dim_err,
     as_error_table_$tty_is_master,
     as_error_table_$tty_no_room,
     as_error_table_$warn_msg) fixed bin (35) external;

dcl  (error_table_$action_not_performed,
     error_table_$null_info_ptr,
     error_table_$out_of_sequence,
     error_table_$undefined_order_request) fixed bin (35) ext static;

/* Based */

dcl  based_area area based (get_system_free_area_ ());

/* Constants */

dcl  ME char (32) initial ("asu_") internal static options (constant);
dcl  NL char (1) aligned int static options (constant) init ("
");

/* Internal Static */

dcl  ftp_dialup_init bit (1) int static init ("0"b);
dcl  (from_mx_fmt, bump_min_fmt, bump_sec_fmt) char (100) aligned int static;

/* Automatic */

dcl  activity_can_unbump bit (1) aligned init ("0"b);	/* controls ate field */
dcl  bump_added_info char (32);			/* for bump_mins and bump_secs */
dcl  cdtex fixed bin;
dcl  code fixed bin (35);
dcl  entry_name char (32) varying;			/* for printing entry point name in error messages */
dcl  error_message char (256) automatic;
dcl  (i, savi) fixed bin;				/* temps */
dcl  just_listen bit (1) aligned;
dcl  lng fixed bin;					/* temp */
dcl  long char (100) aligned;				/* Used by write_message to get message */
dcl  msg char (150) aligned, mstring char (200) aligned;	/* temps */
dcl  multics_msg_date char (64) varying;		/* for from_multics_msg */
dcl  old_ips_mask bit (36) aligned;			/* former IPS mask */
dcl  old_state fixed bin;
dcl  prefix char (100) aligned;			/* temp */
dcl  r_factor fixed bin (35);				/* ditto */
dcl  r_offset fixed bin (18);				/* IPC operands for initial wakeup */
dcl  shxx char (8) aligned;
dcl  start_proc_chn fixed bin (71);			/* event channel for start wakeup for process */

/* Program */
%page;
/* ASU_ATTACH - Called by admin to listen to an existing line which had previously been removed or detached.
*/

asu_attach:
     entry (bv_tty_name, bv_code_2);

	ansp = as_data_$ansp;
	just_listen = ""b;
	bv_code_2 = 0;				/* be sure to return zero unless something goes wrong */
	if bv_tty_name = as_tty then go to master_error;
	if bv_tty_name = anstbl.as_tty then do;		/* check for restricted tty name */

master_error:
	     bv_code_2 = as_error_table_$tty_is_master;
	     return;
	end;

	cdtp = scdtp;				/* unsave ptr to CDT */

/* CHANGE THIS TO USE cdt_mgr_ */

	do cdtex = 1 to cdt.current_size;
	     cdtep = addr (cdt.cdt_entry (cdtex));
	     if cdte.in_use ^= NOW_FREE & cdte.name = bv_tty_name
	     then goto found_cdte;
	end;					/* if we fall thru, the channel is not in the CDT */
	call sys_log_ (SL_LOG,
	     "asu_: ^a is not in CDT and so cannot be attached",
	     bv_tty_name);
	bv_code_2 = error_table_$action_not_performed;	/* tell admin that something went wrong,
						   but we already told the operator about it */
	return;
found_cdte:
	if cdte.in_use = CHANNEL_DELETED then do;
	     call sys_log_ (SL_LOG,
		"asu_: ^a has been deleted by a CDT installation, and so cannot be attached", bv_tty_name);
	     bv_code_2 = error_table_$action_not_performed; /* it didn't work and we already said why */
	     return;
	end;

	if cdte.in_use = NOT_CONFIGURED then do;
	     call sys_log_ (SL_LOG,
		"asu_: ^a was not configured at bootload time, and so cannot be attached.",
		bv_tty_name);
	     bv_code_2 = error_table_$action_not_performed; /* it didn't work and we already said why */
	     return;
	end;

	if cdte.current_service_type = MPX_SERVICE then do;
	     call sys_log_ (SL_LOG,
		"asu_: ^a in use as a multiplexer and cannot be attached.",
		bv_tty_name);
	     bv_code_2 = error_table_$action_not_performed;
	     return;
	end;

	if cdte.current_service_type = TANDD_SERVICE then do;
	     call sys_log_ (SL_LOG,
		"asu_: ^a in use for T & D and cannot be attached.",
		bv_tty_name);
	     bv_code_2 = error_table_$action_not_performed;
	     return;
	end;

	if cdte.in_use ^= NOW_HUNG_UP then do;		/* Gack! User exists! */
	     old_state = cdte.state;			/* well, maybe not. let's see */
	     call astty_$tty_state (cdtep, code);
	     if (old_state ^= cdte.state) | (cdte.state < TTY_DIALED) then
		call sys_log_ (SL_LOG,
		     "asu_: ^a has in_use = ^d, current state = ^d^[, CDTE.state was ^d^;^s^].",
		     cdte.name, cdte.in_use, cdte.state, (old_state ^= cdte.state), old_state);
	     if cdte.state < TTY_DIALED then just_listen = "1"b;

	     else do;				/* it seems ther really is a user on the channel */
		bv_code_2 = as_error_table_$tty_already;/* so complain and refuse to attach it again */
		return;
	     end;
	end;

	if cdte.state = TTY_MASKED then do;
	     call sys_log_ (SL_LOG, "asu_: unmasking channel ^a.",
		cdte.name);
	     call astty_$tty_order (cdtep, "unmask", null (), code);
	     if code ^= 0 &
		code ^= error_table_$undefined_order_request then do; /* if we don't have the right hardcore, too bad */
		bv_code_2 = code;
		call sys_log_$error_log (SL_LOG, code, "asu_",
		     "unable to unmask channel ^a.", cdte.name);
		bv_code_2 = code;
		return;
	     end;
	end;

	if cdte.current_service_type = MC_SERVICE then do;
	     call sys_log_ (SL_LOG,
		"asu_: ^a is in use by the message coordinator and cannot be attached.", cdte.name);
	     bv_code_2 = error_table_$action_not_performed; /* it didn't work and we already said why */
	     return;
	end;

	if cdte.service_type = ANS_SERVICE |		/* If permanently registered to Ans Svc */
	     cdte.service_type = SLAVE_SERVICE |	/* or a slave channel */
	     cdte.service_type = FTP_SERVICE |
	     cdte.service_type = DIAL_OUT_SERVICE then do;/* or a dial out channel */
	     cdte.current_service_type = cdte.service_type; /* give it back */
	     if just_listen then do;
		call sys_log_ (SL_LOG,
		     "asu_: ^a is already attached; will try to listen to it again", cdte.name);
		bv_code_2 = 0;
	     end;
	     else call asu_$attach_channel (cdtep, bv_code_2);
	     if bv_code_2 = 0 then			/* if attached ok, try listen. This happens for the operator */
		call asu_$asu_listen (cdtep, bv_code_2);/* command attach only, not for as_init_'s attach calls */
	end;
	else if cdte.current_service_type = ANS_SERVICE	/* Or if temporarily registered to AS */
	     | cdte.current_service_type = FTP_SERVICE
	     | cdte.current_service_type = INACTIVE	/* or if it is not doing anything at the moment */
	then do;					/* let dialup_ have it */
	     if cdte.current_service_type = INACTIVE then
		cdte.current_service_type = ANS_SERVICE;
	     if just_listen then do;
		call sys_log_ (SL_LOG,
		     "asu_: ^a is already attached; will try to listen to it again", cdte.name);
		bv_code_2 = 0;
	     end;
	     else call asu_$attach_channel (cdtep, bv_code_2);
	     if bv_code_2 = 0 then			/* see comments above */
		call asu_$asu_listen (cdtep, bv_code_2);
	end;

	else do;
	     call sys_log_ (SL_LOG,
		"asu_: ^a cannot be attached because its service type is ^[MC^;unknown^] (^d).",
		cdte.name, (cdte.service_type = MC_SERVICE), cdte.service_type);
	     code = error_table_$action_not_performed;
	end;
	return;


/* ATTACH_ATE - Called to obtain an ATE for the channel. */

attach_ate: entry (bv_ptr_1, bv_code_2);

	cdtep = bv_ptr_1;
	utep = user_table_mgr_$allocate (PT_INTERACTIVE);
	if utep = null () then do;
	     bv_code_2 = as_error_table_$tty_no_room;
	     return;
	end;

	call ipc_$decl_ev_call_chn (ute.event, dialup_, utep, INT_LOGIN_PRIO, code);
	if code ^= 0 then do;			/* if either call failed, complain and get out immediately */
	     call sys_log_$error_log (SL_LOG_BEEP, code, "asu_$attach_ate",
		"Unable to create event channel for new UTE ^p", utep);
	     bv_code_2 = as_error_table_$tty_no_room;
	     return;
	end;

	ute.tty_name = cdte.name;			/* Fill in new ATE. */
	ute.active = cdte.in_use;

	cdte.process = utep;			/* cross-link entries */
	ute.channel = cdtep;

	ute.count = 0;
	bv_code_2 = 0;
	return;
%page;
/* RELEASE_ATE - Drop the Answer Table entry associated with a channel */

release_ate: entry (bv_ptr_1, bv_code_2);

	cdtep = bv_ptr_1;
	utep = cdte.process;
	bv_code_2 = 0;
	if utep = null then return;
	ansp = as_data_$ansp;
	if baseno (utep) ^= baseno (ansp) then do;	/* trap bug */
	     call sys_log_ (SL_LOG_SILENT,
		"asu_$release_ate: bad cdte.process (^p) for ^a", cdte.process, cdte.name);
	     return;
	end;
	call user_table_mgr_$free (utep);
	cdte.process = null;
	return;
%page;
/* ATTACH_CHANNEL - called to attach a specific Channel Definition Table entry. */

attach_channel: entry (bv_ptr_1, bv_code_2);

	cdtep = bv_ptr_1;
	bv_code_2 = 0;
	entry_name = "attach_channel";

	if cdte.current_service_type = INACTIVE then do;	/* if channel was detached or removed */
	     call sys_log_ (SL_LOG_SILENT,
		"asu_: attach channel not done on ^a: current service type = INACTIVE", cdte.name);
	     bv_code_2 = error_table_$action_not_performed;
	     return;				/* then don't attach it now */
	end;

	if cdte.current_service_type = MPX_SERVICE then do;
	     call sys_log_ (SL_LOG,
		"asu_: attach channel not done on ^a: current service type = MPX_SERVICE", cdte.name);
	     bv_code_2 = error_table_$action_not_performed;
	     return;
	end;

	call reset_access_class (cdtep);		/* recurse -- this gets dial_out channels into a known state W.R.T. access class. */
	call astty_$tty_index (cdtep, code);		/* get devx from hardcore */
	if code ^= 0 then call error ("tty_index");	/* probably mispelled, or not configured */

	if cdte.event = 0 then do;
	     call ipc_$create_ev_chn (cdte.event, code);	/* Make event-call channel to run tty. */
	     if code ^= 0 then call error ("create_ev_chn"); /* this is bad news! */
	end;

	if cdte.service_type = FTP_SERVICE
	then do;
	     if ^ftp_dialup_init
	     then do;				/* only attempt to reference Network software */
		call ftp_dialup_$init;		/* if the user attaches Network channels */
		ftp_dialup_init = "1"b;
	     end;
	     call ipc_$decl_ev_call_chn (cdte.event, ftp_dialup_, cdtep, INT_LOGIN_PRIO, code);
	end;
	else call ipc_$decl_ev_call_chn (cdte.event, dialup_, cdtep, INT_LOGIN_PRIO, code);
	if code ^= 0 then call error ("decl_ev_call_chn");/* this line has just died. */

	call astty_$tty_event (cdtep, code);		/* Tell hardcore name of event channel. */
	if code ^= 0 then call error ("tty_event");	/* quit if get error */

/* Setting of line type here allows CDT installation to change a line's type.
   Except for that, setting of line type is done at initialization time */
	if cdte.line_type ^= 0 then do;		/* if line type given, set it */
	     i = cdte.line_type;			/* get it into a full word */
	     call astty_$tty_order (cdtep, "set_line_type", addr (i), code);
	     if code ^= 0 then
		call error ("set_line_type");
	end;

/* Don't listen yet; FNPs might not be up. We have grabbed the channel, though */

	return;


/* =============================================================  */

/* The following entry point is called to enable for listening a known, hungup, channel */

asu_listen:
     entry (bv_ptr_1, bv_code_2);

	entry_name = "asu_listen";

	cdtp = scdtp;				/* copy saved ptr to CDT */
	cdtep = bv_ptr_1;				/* Get ptr to chn */
	bv_code_2 = 0;				/* initialize error code */

	if asu_$channel_in_use (cdtep) then do;
	     call sys_log_ (SL_LOG_SILENT,
		"asu_: listen not done on ^a: IN_USE with state = ^d, in_use = ^d, tra_vec = ^d",
		cdte.name, cdte.state, cdte.in_use, cdte.tra_vec);
	     bv_code_2 = error_table_$action_not_performed;
	     return;				/* if channel in use, leave it alone */
	end;

	if cdte.current_service_type = INACTIVE then do;	/* if channel was detached or removed */
	     call sys_log_ (SL_LOG_SILENT,
		"asu_: listen not done on ^a: current service type = INACTIVE", cdte.name);
	     bv_code_2 = error_table_$action_not_performed;
	     return;				/* don't listen to it */
	end;

	if cdte.current_service_type = MPX_SERVICE then do; /* if channel was detached or removed */
	     call sys_log_ (SL_LOG_SILENT,
		"asu_: listen not done on ^a: current service type = MPX_SERVICE", cdte.name);
	     bv_code_2 = error_table_$action_not_performed;
	     return;				/* don't listen to it */
	end;
	if cdte.current_service_type = TANDD_SERVICE then do; /* if channel was detached or removed */
	     call sys_log_ (SL_LOG_SILENT,
		"asu_: listen not done on ^a: current service type = TANDD_SERVICE", cdte.name);
	     bv_code_2 = error_table_$action_not_performed;
	     return;				/* don't listen to it */
	end;

	if cdte.service_type = DIAL_OUT_SERVICE then do;	/* initialize cdte for dial out */
	     cdte.tra_vec = WAIT_SLAVE_REQUEST;
	     cdte.process = null ();
	     cdte.dialed_to_procid = "0"b;
	     cdte.in_use = NOW_HUNG_UP;
	     cdte.current_service_type = cdte.service_type;
	     return;
	end;

	if cdte.current_service_type = MC_SERVICE then do;
	     call sys_log_ (SL_LOG_SILENT,
		"asu_: listen not done on ^a: current service type = MC", cdte.name);
	     bv_code_2 = error_table_$action_not_performed;
	     return;				/* This here entry ignores MC */
	end;

	call astty_$tty_event (cdtep, code);		/* be sure we are the channel's user process - we should be,
						   but there are ways to get here where we might not be */
	if code ^= 0 then call error ("tty_event");

	call astty_$tty_order (cdtep, "listen", null, code); /* Tell dim to accept calls on this line */
	if code ^= 0 then call error ("listen");	/* quit if any error. */

	if cdte.state < TTY_KNOWN then do;
	     call sys_log_ (SL_LOG_SILENT,
		"asu_: listen failed on ^a. state=^d", cdte.name, cdte.state);
	     bv_code_2 = error_table_$action_not_performed;
	     return;				/* Make sure that channel is indeed being listened to. */
	end;

/* Check for a slave channel that has been priv-attached and is waiting for a dialup */

	if cdte.current_service_type = SLAVE_SERVICE
	     & cdte.tra_vec = WAIT_FIN_PRIV_ATTACH
	     & cdte.process ^= null
	     & cdte.dialed_to_procid ^= ""b then ;	/* leave it alone */

	else do;					/* otherwise wait for what is appropriate to its service type */
	     if cdte.service_type = SLAVE_SERVICE then	/* slave device set transfer vector */
		cdte.tra_vec = WAIT_SLAVE_REQUEST;	/* to ignore channel until requested */
	     else cdte.tra_vec = WAIT_DIALUP;		/* Set transfer vector to print greeting. */
	     cdte.process = null;			/* .. no ATE yet */
	     cdte.user_name = "";
	end;

	cdte.in_use = NOW_LISTENING;
	return;					/* listen */


reset_access_class:
     entry (bv_ptr_1);

	cdtep = bv_ptr_1;

	cdte.current_access_class_valid = "0"b;
	cdte.current_access_class = ""b;
	if aim_check_$equal (cdte.access_class (1), cdte.access_class (2))
	then do;
	     cdte.current_access_class_valid = "1"b;
	     cdte.current_access_class = cdte.access_class;
	end;
	return;


error: procedure (comment);				/* errors from asu_$attach and asu_$listen come here */

declare  comment char (*);

	if code = -1 then				/* astty_ uses -1 to mean channel hung up */
						/* if an operation failed and astty_ censored the code to -1 */
						/* then we give up here and now. */
	     go to nonlocal_return_label;		/* let caller continue - don't drop the channel */

error_join:
	call sys_log_$error_log (SL_LOG_BEEP, code, "asu_",
	     "^a ^a error; will remove channel ^a ^a",
	     entry_name, comment, cdte.name, cdte.comment);
	call asu_remove (cdtep);			/* make it go away */
						/* recurse ! */
	bv_code_2 = as_error_table_$tty_dim_err;	/* return standard code */
	goto nonlocal_return_label;			/* get out of internal proc and return from external one */

     end error;

nonlocal_return_label: return;			/* return from the external procedure */

/* ============================================================= */

/* the remove entry point is called to completely remove a tty channel from the system */
/* the phone is hung up; if it is a dialed console it is cleaned out;
   if it is a process it is destroyed.  The event channel remains, however,
   because there is no sure-fire way to get ring-0 to never send wakeups. */

asu_remove: entry (p2);

	cdtep = p2;				/* copy into automatic */
	if cdte.current_service_type = MPX_SERVICE
	then do;
	     call sys_log_ (SL_LOG,
		"asu_: ^a is a multiplexer and cannot be removed.", cdte.name);
	     return;				/* no error code, so we cannot return it */
	end;
	call astty_$tty_index (cdtep, code);		/* This resets channel switches, and gets devx again. */
	if code = 0 then do;			/* Only mess with it if channel does exist. */
	     call astty_$tty_order (cdtep, "hangup", null, code); /* Hang phone. */
	     cdte.tra_vec = WAIT_HANGUP;		/* There will be a hangup wakeup */
						/* this will be reset if there is a process to be destroyed */
	     call astty_$tty_detach (cdtep, 0, code);	/* Detach console from process. */
	     call ipc_$drain_chn (cdte.event, code);	/* Flush any pending wakeups. */
	end;
	if as_data_$ansp ^= null then			/* If answering service started, we're cool */
	     if cdte.service_type = ANS_SERVICE | cdte.service_type = FTP_SERVICE
	     then do;
		if cdte.dialed_to_procid ^= "0"b then	/* call dial_ctl_ if slave */
		     call dial_ctl_$dial_term (cdtep);
		else if cdte.in_use = NOW_HAS_PROCESS	/* Has a process? */
		then do;
						/* (this code should be in dialup_) */
		     utep = cdte.process;		/* Answering service channel. */
		     call dpg_ (utep, "error");	/* destroy it */
		     ute.login_flags.noprint = "1"b;
		     ute.logout_type = "remo";
		     cdte.tra_vec = WAIT_REMOVE;	/* Set dialup control point. */
		     ute.destroy_flag = WAIT_LOGOUT;	/* tell act_ctl_ */
		     return;			/* dialup_ will do the rest */
		end;
	     end;

	     else if cdte.service_type = DIAL_OUT_SERVICE then /* auto call line ? */
		if cdte.dialed_to_procid ^= "0"b then call dial_ctl_$dial_term (cdtep);

	if cdte.in_use ^= NOW_HAS_PROCESS then do;	/* if process is being destroyed, must keep cdte "live" a while */
						/* leave tra_vec at WAIT_HANGUP */
	     cdte.in_use = NOW_HUNG_UP;		/* otherwise, remember it is hung up */
	     cdte.current_service_type = INACTIVE;	/* ignore channel until CDT installation or next bootload */
	     if cdte.n_disconnected_procs > 0 then	/* release the UTE of the current connection
						   we must be in a login connect loop since our
		                                           in_use state is less than HAS_PROCESS. */
		call asu_$release_ate (cdtep, code);
	end;

	if cdte.tra_vec = WAIT_FIN_TANDD_ATTACH then	/* we don't want it to stay this way when reattached */
	     cdte.tra_vec = WAIT_DIALUP;
	return;

/* ============================================================= */


/* The remove_cdte entry point is called when a cdte is so messed up that we
   don't know what to do. We used to crash the system, but that is too drastic.
   Now, we just complain a lot, and then try to get rid of the channel and its
   cdte, so the problem does not happen repeatedly */

remove_cdte: entry (bv_ptr_1);

	cdtep = bv_ptr_1;
	cdtp = scdtp;

	if baseno (cdtp) ^= baseno (cdtep) then do;	/* just as unlikely as anything else */
	     call sys_log_ (SL_LOG_SILENT,
		"asu_: cdtep (^p) not cdt (^p)", cdtep, cdtp);
	     return;
	end;

	call astty_$tty_state (cdtep, code);
	if code ^= 0 then do;
	     if code = -1 then			/* channel hung up */
		call sys_log_ (SL_LOG_SILENT, "asu_: cdte ^p (^a) hung up",
		     cdtep, cdte.name);
	     else do;
		call sys_log_$error_log (SL_LOG_SILENT, code,
		     "asu_$remove_cdte", "cdte ^p error from tty_state", cdtep);
		return;				/* if tty_state fails, tty_hangup and detach probably will too */
	     end;
	end;

	call sys_log_ (SL_LOG_SILENT,
	     "asu_: cdte ^p (^a) state ^d in use ^d tra vec ^d",
	     cdtep, cdte.name, cdte.state, cdte.in_use, cdte.tra_vec);


	call asu_remove (cdtep);
	return;

/* ============================================================= */


/* This entry point is a function that tells the caller whether or not a channel is in use.
   A channel is considered to be in use if it is dialed up and a user has typed something,
   such as the login or dial commands, or if a process has it attached, as a slave,
   dial out, etc. channel. If it is merely dialed up, it is considered not in use,
   which is partly by design and partly by necessity: a hardwired channel always
   looks dialed up, even if there is no user doing anything to or with it.

   This function is used in place of less accurate, in-line decisions regarding
   channel activity, in various answering service procedures, such as:
   -	The count_fnp_users procedure in admin, which counts used channels on an FNP;
   -	the check in fnp_manager_$fnp_listen, to avoid re-listening to a used channel.

*/

channel_in_use: entry (bv_ptr_1) returns (bit (1) aligned);

	cdtp = scdtp;				/* copy saved ptr to CDT */
	cdtep = bv_ptr_1;				/* and ptr to CDT entry */

	if cdte.twx = 0 then go to return_false;	/* if no devx, can't be in use */

	if cdte.state <= TTY_KNOWN then		/* if hung up or listening */
	     goto return_false;			/* clearly not in use */


	if cdte.in_use <= NOW_LISTENING then		/* clearly not in use, but cdte inconsistent */
	     goto return_false;			/* say it's not in use - let caller feel free to fix it up */

	if cdte.in_use >= NOW_LOGGED_IN then		/* clearly in use */
	     goto return_true;			/* I think? */

/* cdte.in_use = NOW_DIALED, so the decision gets more complicated */

	if cdte.tra_vec >= WAIT_LOGIN_ARGS then		/* if user is logging in, or past that stage */
	     if cdte.tra_vec < WAIT_HANGUP then		/* and not on the way out */
		goto return_true;			/* this one is definitely not clear */

/* any other criteria to look at? */

/* if not, fall thru and say not in use */

return_false: return (""b);

return_true: return ("1"b);

/* ============================================================= */

/* The find_process entry is called to locate a user process in the various possible user tables.
   It looks for absentees, daemons, and interactive users, and returns
   a pointer to the answer table - style entry for the user.
   A flag is also set telling what kind of user was found. */

find_process: entry (a_pid, a_type, outp);

dcl  a_pid bit (36) aligned,				/* process id to look up user entry for */
     a_type fixed bin,				/* 1 = ia, 2 = abs, 3 = dmn */
     outp ptr;					/* ptr to entry in anstbl or aut or dut */

	a_type = PT_INTERACTIVE;
	ansp = as_data_$ansp;
	do i = 1 to anstbl.current_size;		/* interactive users first */
	     utep = addr (anstbl.entry (i));		/* Locate anwwer table entry */
	     if ute.active = NOW_HAS_PROCESS then	/* Gotta have process */
		if ute.proc_id = a_pid then go to afnd; /* processid must match */
	end;
	a_type = PT_ABSENTEE;
	autp = as_data_$autp;
	do i = 1 to autp -> autbl.current_size;		/* no, well try absentees */
	     utep = addr (autp -> autbl.entry (i));
	     if ute.active ^= NOW_FREE then		/* Is slot in use? */
		if ute.proc_id = a_pid then go to afnd;
	end;
	a_type = PT_DAEMON;
	dutp = as_data_$dutp;
	do i = 1 to dutbl.current_size;		/* Scan daemon table. */
	     utep = addr (dutbl.entry (i));		/* Get ptr to daemon entry. */
	     if ute.active = NOW_HAS_PROCESS then	/* Should have a process. */
		if ute.proc_id = a_pid then do;	/* Is this process the one we look for? */
afnd:		     outp = utep;			/* whee */
		     return;
		end;
	end;
	outp = null;				/* Couldn't find it. */
	a_type = 0;				/* ... */
	return;					/* sorry */


/* ================================================== */

/* The check_for_stopped_process entry is called when a wakeup like "logout"
   or "bump" is received for a process whose tra_vec indicates that it has
   already been bumped or logged out, and is waiting for a "stopstop" wakeup.
   We check the actual state of the process (5 = stopped) and print a message
   indicating what we found. If state = 5 we return "1"b so the caller knows
   it is safe to finish destroying the process, even though the stopstop
   never arrived (apparently it was lost). */

check_for_stopped_process: entry (P_utep, caller_name) returns (bit (1) aligned);

dcl  caller_name char (*);


	utep = P_utep;
	if utep = null then return (""b);		/* avoid fault when channel has no process */
	process_status_return.target_proc = ute.proc_id;
	call hphcs_$process_status (addr (process_status_return));
	if process_status_return.up_exec = 5 then do;
	     call sys_log_ (SL_LOG,
		"asu_: (called by ^a) ^a.^a ^a was already stopped and will be destroyed (stopstop wakeup was lost)",
		caller_name, ute.person, ute.project, ute.tty_name);
	     return ("1"b);
	end;
	else do;
	     call sys_log_ (SL_LOG,
		"asu_: (called by ^a) ^a.^a ^a is not stopped (state = ^d) even though destroy flag = ^d;
it might not be possible to destroy this process",
		caller_name, ute.person, ute.project, ute.tty_name, process_status_return.up_exec, ute.destroy_flag);
	     return (""b);
	end;

/* ======================================================= */

/* Utility entry to write a message which is in the form of a system error code.
   Usually these codes are in as_error_table_.
   The message is splashed on the user's console. */

write_chn_message: entry (chnp, mescode, short, P_code);

dcl  chnp ptr;
dcl  channel_call bit (1) init ("0"b);

	cdtep = chnp;				/* Get channel ptr */
	channel_call = "1"b;

write_message: entry (P_utep, mescode, short, P_code);

dcl  mescode fixed bin (35),				/* system error code */
     short char (8) aligned;				/* shortinfo */

	P_code = 0;
	call convert_status_code_ (mescode, short, long); /* decode message */
	if ^channel_call then do;
	     utep = P_utep;				/* copy arg */
	     if ute.queue = 0 & ^ute.adjust_abs_q_no then do; /* if interactive, see if channel exists */
		cdtep = ute.channel;		/* Get channel ptr */
	     end;
	     else if ute.queue > 0 | ute.adjust_abs_q_no then return; /* if absentee, quit */
	end;

	if long = "" then return;			/* May have null value. */
	if ^channel_call then
	     if ute.queue = -1 then do;		/* DAEMON */
		call sys_log_ (SL_LOG, rtrim (long));	/* There is intentionally no operator */
		return;				/* documentation for this arbitrary message. */
	     end;

	call ioa_$rs ("^a", mstring, i, long);
	if cdtep ^= null then do;
	     if cdte.service_type = FTP_SERVICE then
		mstring = format_ftp_msg ((long), i, i, 030);
	end;
	if channel_call then
	     call astty_$tty_force (cdtep, addr (mstring), i, P_code);
	else
	     call BLAST_USER (utep, substr (mstring, 1, i),
		"0"b /* already formatted */, "0"b /* not a warn */,
		error_message, P_code);
	return;
%page;
/* ======================================================= */

/* Utility entry to bump a user. Makes nice message and splats it on his console. */

bump_code: entry (P_utep, mcode, mshort, P_code, grctim);

dcl  mcode fixed bin (35),				/* message code */
     mshort char (8) aligned;

	utep = P_utep;
	call convert_status_code_ (mcode, mshort, prefix);
	if mcode = as_error_table_$inactive then do;
	     activity_can_unbump = "1"b;
	     bump_added_info = " unless you become active";
	end;
	else bump_added_info = "";
	go to bjoin;

bump_user: entry (P_utep, wrd, P_code, grctim);

dcl  wrd char (*),					/* message */
     grctim fixed bin;				/* seconds allowed for user cleanup */

	P_code = 0;
	utep = P_utep;				/* copy ptr into auto */
	prefix = wrd;				/* Set up message */
	bump_added_info = "";

bjoin:
	ansp = as_data_$ansp;
	anstbl.current_time = clock ();
	if ute.preempted >= PREEMPT_BUMPED then do;	/* if user has already been bumped, don't do it again */
	     ute.uflags.activity_can_unbump = "0"b;	/* nothing can save him */
	     return;
	end;
	ute.uflags.activity_can_unbump = activity_can_unbump; /* inactive? start working and save your process */

	if ute.at.no_warning then goto omit_warning;	/* if user said -no_warning then don't warn him */
	if ute.queue ^= 0 | ute.adjust_abs_q_no then goto omit_warning; /* if absentee or daemon, there's nobody to warn */

	if grctim = 0 then msg = "";			/* if immediate kill */
	else do;					/* given some grace */
	     if mod (grctim, 60) = 0 then call ioa_$rsnnl (bump_min_fmt,
		     msg, lng, divide (grctim, 60, 17, 0), bump_added_info);
	     else call ioa_$rsnnl (bump_sec_fmt, msg, lng, grctim, bump_added_info);
	end;
	multics_msg_date = date_time_$format ("date_time", anstbl.current_time, "", "");
	call ioa_$rs (from_mx_fmt, mstring, lng, multics_msg_date, prefix, msg);
	cdtep = ute.channel;			/* Locate channel */
	if cdtep ^= null () then do;			/* check for FTP service */
	     if cdte.service_type = FTP_SERVICE then do;
		if grctim = 0
		then mstring = format_ftp_msg (mstring, lng, lng, 434);
		else mstring = format_ftp_msg (mstring, lng, lng, 030);
	     end;
	end;

	error_message = "";

	call BLAST_USER (P_utep, substr (mstring, 1, lng),
	     "0"b /* already formatted */, "1"b /* bump message */,
	     error_message, P_code);
	if P_code ^= 0 & P_code ^= error_table_$action_not_performed then
	     call sys_log_$error_log (SL_LOG_SILENT, P_code,
		"asu_$bump_user",
		"^a Sending blast message to ^a.^a on ^a", error_message,
		ute.person, ute.project, ute.tty_name);

omit_warning:
	ute.preempted = PREEMPT_BUMPED;		/* Mark "waiting bump" */
	call timer_manager_$alarm_wakeup ((grctim), "11"b, ute.event);
	return;					/* Done. */
%page;
reschedule_bump_timer:
     entry (P_utep, grctim);

/* this entry reschedules the inactivity check timer to new time.
   It was put here since the bump entries set the orignal timer and is in a common place */

	utep = P_utep;

/* kill current bump timeout */
	call timer_manager_$reset_alarm_wakeup (ute.event);

/* reschedule for new time */
	call timer_manager_$alarm_wakeup ((grctim), "11"b, ute.event);

	return;
%page;
unbump_user:
     entry (P_utep, P_code);

/**** This entry provides an interface to unbump a user. */

	call process_proc_term_request ("unbump");
	return;
%page;
terminate_user:
     entry (P_utep, P_code);

/**** This entry provides an interface to terminate a user. */

	call process_proc_term_request ("terminate");
	return;
%page;
disconnect_user:
     entry (P_utep, P_code);

/**** This entry provides an interface to disconnect a user. */

	call process_proc_term_request ("hangup");
	return;
%page;
detach_user:
     entry (P_utep, P_code);

/**** This entry provides an interface to detach a user. */

	call process_proc_term_request ("detach");
	return;
%page;
send_term_signal: entry (P_utep, a_logout_index) returns (bit (1) aligned);

dcl  a_logout_index fixed bin;
dcl  term_cpu_limit fixed bin (71);
dcl  term_realtime_limit fixed bin (71);

	utep = P_utep;
	if utep = null then return (""b);		/* don't blow up because of a careless caller */
	if ute.preempted >= PREEMPT_TERM_SENT then	/* if term already sent or not to be sent */
	     return (""b);				/* tell caller to kill process immediately */

	ute.logout_index = a_logout_index;		/* remember what we were doing to this user */
	ute.preempted = PREEMPT_TERM_SENT;		/* remember that we sent term */
	call hphcs_$ips_wakeup (ute.proc_id, "trm_");	/* send it */
	term_cpu_limit = installation_parms.term_cpu_time_seconds * 1000000;
	if term_cpu_limit <= 0 then term_cpu_limit = 5000000;
	term_realtime_limit = installation_parms.term_real_time_seconds;
	if term_realtime_limit <= 0 then term_realtime_limit = installation_parms.warning_time;
	ute.ignore_cpulimit = ""b;			/* enable cpulimit timer for this process */
	call hphcs_$set_cpu_monitor (ute.proc_id, term_cpu_limit, code); /* set cpu time limit */
	call timer_manager_$alarm_wakeup (term_realtime_limit, "11"b, ute.event); /* and real time limit */

	return ("1"b);				/* tell caller to wait for termsgnl from process */

suspend_process: entry (P_utep);

	utep = P_utep;				/* copy ptr to user table entry */
	if utep = null then do;			/* trap bug */
	     call sys_log_ (SL_LOG_SILENT,
		"asu_: suspend_process called with null UTE ptr.");
	     return;
	end;

	if ute.sus_sent & ^ute.ignore_cpulimit then do;	/* trap different bug */
	     call sys_log_ (SL_LOG,
		"asu_$suspend_process: ^a.^a ^a is already suspended",
		ute.person, ute.project, ute.tty_name);
	     return;
	end;

/* Compute real and cpu time limits (borrow variables from send_term_signal). Ensure reasonable values. */

	term_cpu_limit = installation_parms.sus_cpu_time_seconds * 1000000;
	if term_cpu_limit <= 0 then term_cpu_limit = 5000000;
	term_realtime_limit = installation_parms.sus_real_time_seconds;
	if term_realtime_limit <= 0 then term_realtime_limit = 180;

/* Set flags in user table entry */

	ute.suspended = ""b;			/* clear flag that says when process has responded */
	ute.sus_sent = "1"b;			/* we will, in a few lines */
	ute.ignore_cpulimit = ""b;			/* enable cpulimit timer for this process */
	ute.sus_channel = 0;			/* clear any possible garbage */

/* Send sus_ and set real and cpu timers */

	call hphcs_$ips_wakeup (ute.proc_id, "sus_");
	call hphcs_$set_cpu_monitor (ute.proc_id, term_cpu_limit, code);
	call timer_manager_$alarm_wakeup (term_realtime_limit, "11"b, ute.event);

	return;
%page;
release_suspended_process: entry (P_utep);

	utep = P_utep;				/* copy ptr to user table entry */
	if utep = null then do;			/* trap bug */
	     call sys_log_ (SL_LOG_SILENT,
		"asu_: release_suspended_process called with null UTE ptr");
	     return;
	end;

	if ^ute.sus_sent then do;			/* trap other bug */
	     call sys_log_ (SL_LOG_SILENT,
		"asu_$release_suspended_process: ^a.^a ^a is not suspended",
		ute.person, ute.project, ute.tty_name);
	     return;
	end;

	ute.ignore_cpulimit = "1"b;			/* "turn off" the cpulimit timer */
	if ute.suspended then do;			/* if process already responded to sus_ */
	     whotab.e (ute.whotabx).suspended = ""b;	/* publish it */
	     ute.suspended, ute.sus_sent = ""b;		/* clear the switches */
	end;
	else call timer_manager_$reset_alarm_wakeup (ute.event); /* if not, turn off the alarm timer */
						/* and wait until it responds, before sending the wakeup */

	return;

/* ============================================================= */

/* Entry to unclog backed-up table installations by forcing the
   answer_table lock, setting the update pending flag, and unmasking ips signals and
   event calls.  Just for good measure, a wakeup is also sent (otherwise
   we might have to wait until dialup_ gets invoked). */

reset:
     entry;

	ansp = as_data_$ansp;
	savi = anstbl.lock_count;
	anstbl.lock_count = 0;			/* clear the lock */
	code = 0;
	i = -1;
	do while (code = 0);
	     call ipc_$unmask_ev_calls (code);
	     i = i + 1;				/* count up depth of masking */
	end;
	call hcs_$set_ips_mask ((36)"1"b, old_ips_mask);	/* unmask all IPS channels */

	call sys_log_ (SL_LOG,
	     "asu_: lock was ^d, ev call mask was ^d, ips mask was ^12.3b", savi, i, old_ips_mask);

/* It is possible that we have "lost" an alarm timer.  We will set up a new one to go off in a few seconds,
   which should shake loose any that are waiting for the lost one to go off.  The new timer will actually
   serve a useful purpose; it will wakeup the table updating program to see if any installations are
   pending.   If timer_manager_ is busted so completely that this new timer never goes off, things
   are so messed up it isn't funny.  */

	call timer_manager_$alarm_wakeup (5, "11"b /* rel secs */, anstbl.update_channel);
	return;


format_ftp_msg:
     entry (P_bufr, P_in_lng, P_lng, P_ftp_code) returns (char (200) aligned);

/* formats messages for channels of FTP service_type, as specified in */
/* Arpanet protocol for server-FTP */

dcl  P_bufr char (200) aligned,
     P_lng fixed bin,
     P_ftp_code fixed bin,
     P_in_lng fixed bin;

dcl  result picture "999b";
dcl  min builtin;

	i = min (999, P_ftp_code);
	result = i;
	return (format_ftp_output (P_bufr, P_in_lng, P_lng, (result)));


init: entry;

	if ^sc_stat_$Multics_typed | sc_stat_$Go_typed then
	     call sub_err_ (error_table_$out_of_sequence, "asu_$init", "s");
	ftp_dialup_init = "0"b;
	call convert_status_code_ (as_error_table_$from_multics_msg, shxx, from_mx_fmt);
	call convert_status_code_ (as_error_table_$bump_mins_msg, shxx, bump_min_fmt);
	call convert_status_code_ (as_error_table_$bump_secs_msg, shxx, bump_sec_fmt);

	return;
%page;
start_process:
     entry (P_utep);

/**** This entry is used to start a process.  Initially, a process is in
      the blocked state awaiting a wakeup to get it running.  This entry
      provides that wakeup.  It is called by dialup_, absentee_user_manager_,
      and daemon_user_manager_. */

	utep = P_utep;

/**** Before we send a wakeup to the process, we must construct an event
      channel which will pass the IPC event channel validation tests.  To
      do this, we must learn the values of R-Offset and R-Factor for a
      process.  */

	call hphcs_$get_ipc_operands (ute.proc_id, r_offset, r_factor, code);
	if code = 0 then do;
	     call ipc_validate_$encode_event_channel_name (r_offset, r_factor, "000"b /* flags */, 1 /* index */, 4 /* ring */, "1"b /* regular */, 1 /* unique id */, start_proc_chn);

/**** Kick the process loose from initial block state */
	     call hcs_$wakeup (ute.proc_id, start_proc_chn, -1, code);
	     if code ^= 0 then			/* log any error for debugging */
		call sys_log_$error_log (SL_LOG_SILENT, code, ME,
		     "Sending initial wakeup to ^w (^a.^a)",
		     ute.proc_id, ute.person, ute.project);
	end;
	else call sys_log_$error_log (SL_LOG_SILENT, code, ME,
		"Retrieving the values of R-Offset and R-Factor for ^w (^a.^a)",
		ute.proc_id, ute.person, ute.project);

	return;
%page;
/* format: style5,ind5 */

blast_user:
     entry (P_utep, P_message, P_error_message, P_code);

	if P_utep = null () then
	     do;
	     call sys_log_$error_log (SL_LOG_SILENT, 0,
	         "asu_: blast_user called with null UTE ptr");
	     P_error_message = "utep = null ()";
	     P_code = error_table_$action_not_performed;
	     end;
	else
	     call BLAST_USER (P_utep, P_message, "1"b /* needs formatting */,
	         "0"b /* warn message */, P_error_message, P_code);

	return;
%page;
/**** format: style4 */
%page;
setup_login_server_handle:
     entry (P_utep);

/**** This entry, give a UTE pointer, initializes the value of
      ute.login_server_handle.our_handle, used for login server to
      answering service communications. */

	if P_utep = null () then
	     call sys_log_$error_log (SL_LOG_SILENT, 0, "asu_: setup_login_server_handle called with null UTE ptr.");
	else do;
	     utep = P_utep;
	     uc_ls_handle_ptr = addr (ute.login_server_info.our_handle);
	     uc_ls_handle.process_type = ute.process_type;
	     uc_ls_handle.ute_index = ute.ute_index;
	     uc_ls_handle.unique_id = substr (bit (clock (), 54), 18, 36);
	end;
	return;
%page;
format_ftp_output:
     proc (P_message, P_msg_lng, P_new_lng, P_ftp_code) returns (char (200) aligned);

dcl  P_message char (200) aligned,
     P_msg_lng fixed bin,
     P_new_lng fixed bin,
     P_ftp_code char (4) aligned;

dcl  build_string char (200) varying,
     i fixed bin,
     temp fixed bin;

	build_string = P_ftp_code;

	if P_msg_lng = 0
	then do;					/* caller had nothing to say */
	     build_string = build_string || NL;
	     P_new_lng = 5;
	     return (build_string);
	end;

	i = 1;

	temp = index (substr (P_message, i, P_msg_lng - i + 1), NL);

	do while ((temp ^= P_msg_lng - i + 1) & (temp ^= 0));
						/* while we are not at the last line in the message */
	     substr (build_string, 4, 1) = "-";		/* indicate this is a multiple line msg */
	     build_string = build_string || substr (P_message, i, temp);
	     i = i + temp;
	     temp = index (substr (P_message, i, P_msg_lng - i + 1), NL);
	end;

	if substr (build_string, 4, 1) = "-"
	then do;
	     build_string = build_string || P_ftp_code;	/* multiple concatenations are inefficient */
	     build_string = build_string || substr (P_message, i, P_msg_lng - i + 1); /* so build it up piece by piece */
	end;
	else build_string = build_string || substr (P_message, i, P_msg_lng - i + 1);
	P_new_lng = length (build_string);

	return (build_string);

     end format_ftp_output;
%page;
BLAST_USER:
     procedure (P_utep, P_message, P_need_formatting, P_bump_msg, P_error_message, P_code);

dcl  P_utep ptr parameter;
dcl  P_message char (*) parameter;
dcl  P_need_formatting bit (1) aligned parameter;
dcl  P_bump_msg bit (1) aligned parameter;
dcl  P_error_message char (*) parameter;
dcl  P_code fixed bin (35) parameter;

	utep = P_utep;
	if ute.at.no_warning then do;
	     call ioa_$rsnnl ("^a.^a has ""no_warning""", P_error_message,
		(0), ute.person, ute.project);
	     P_code = error_table_$action_not_performed;
	     return;
	end;

/**** If there is a process, use the new system message facility to send
      the message.  Otherwise, try to blast the channel, if there is one. */

	if ute.active < NOW_HAS_PROCESS then do;
	     if ute.channel ^= null () then do;
		call astty_$tty_force ((ute.channel), addr (P_message),
		     length (rtrim (P_message)), P_code);
		P_error_message = "";
		return;
	     end;
	     else do;
		P_code = error_table_$action_not_performed;
		P_error_message = "";
		return;
	     end;
	end;

	system_message_text_len = length (P_message);

	begin;
dcl  formatted_message char (system_message_text_len + 100);
dcl  warn_template char (100) aligned;

	     if P_need_formatting then do;
		call convert_status_code_ (as_error_table_$warn_msg, (""), warn_template);
		call ioa_$rsnnl (warn_template, formatted_message, (0),
		     date_time_$format ("date_time", clock (), "", ""), P_message);
	     end;
	     else
		formatted_message = P_message;

	     system_message_text_len = length (rtrim (formatted_message));
	     system_message_ptr = null;
	     on cleanup begin;
		if system_message_ptr ^= null then free warn_system_message in (based_area);
	     end;
	     allocate warn_system_message in (based_area) set (system_message_ptr);

	     unspec (warn_system_message) = "0"b;
	     warn_system_message.header.version = SYSTEM_MESSAGE_VERSION_1;
	     if P_bump_msg then do;
		warn_system_message.header.type = SYSTEM_MESSAGE_TYPE_AS_INACTIVITY;
		warn_system_message.header.type_version = SYSTEM_MESSAGE_AS_INACTIVITY_V1;
	     end;
	     else do;
		warn_system_message.header.type = SYSTEM_MESSAGE_TYPE_AS_WARN;
		warn_system_message.header.type_version = SYSTEM_MESSAGE_AS_WARN_V1;
	     end;
	     warn_system_message.caller = "";
	     warn_system_message.text_len = length (rtrim (formatted_message));
	     warn_system_message.text = formatted_message;
	end;					/* end begin block */

	call send_system_message_ (utep, system_message_ptr, P_code);
	if P_code ^= 0 then
	     do;
	     call ioa_$rsnnl ("Calling send_system_message_ on process_id ^w",
		P_error_message, (0), ute.proc_id);
	     return;
	end;

	free warn_system_message in (based_area);
	P_error_message = "";
	return;
     end BLAST_USER;
%page;
process_proc_term_request:
     procedure (P_action_string);

/**** This internal procedure is called by the unbump_user, disconnect_user,
      terminate_user, and detach_user entrypoints. */

dcl  P_action_string char (*) parameter;

dcl  event_message fixed bin (71) automatic;
dcl  event_message_str char (8) automatic;

	utep = P_utep;
	event_message_str = P_action_string;
	code = 0;
	if utep = null () then
	     code = error_table_$null_info_ptr;
	else do;
	     unspec (event_message) = unspec (event_message_str);
	     call hcs_$wakeup (as_data_$as_procid, ute.event, event_message,
		code);
	end;
	P_code = code;
	return;
     end process_proc_term_request;

/* format: off */
%page; %include absentee_user_table;
%page; %include answer_table;
%page; %include as_data_;
%page; %include as_data_definitions_;
%page; %include as_wakeup_priorities;
%page; %include author_dcl;
%page; %include cdt;
%page; %include dialup_values;
%page; %include daemon_user_table;
%page; %include installation_parms;
%page; %include line_types;
%page; %include process_status_return;
%page; %include sc_stat_;
%page; %include sys_log_constants;
%page; %include system_message;
%page; %include uc_ls_handle;
%page; %include user_attributes;
%page; %include user_table_entry;
%page; %include user_table_header;
%page; %include whotab;
%page;
/* BEGIN MESSAGE DOCUMENTATION

   Message:
   asu_: lock was N, ev call mask was M, ips mask was ZZZZZZ

   S:	as (severity1)

   T:	In response to an operator reset command.

   M:	N is the value of anstbl.lock_value, M is the value of event call masking.
   ZZZZZZ was the ips mask.
   This message verifies that the reset
   command was given, and what effect it had.

   A:	$ignore

   Message:
   asu_: CHANNEL is not in CDT and so cannot be attached

   S:	as (severity1)

   T:	$run

   M:	An attach command specified an unknown CHANNEL.
   No action was taken.

   A:	Enter a correct command.


   Message:
   asu_: CHANNEL has been deleted by a CDT installation and so cannot be
   attached.

   S:	as (severity1)

   T:	$run

   M:	An attach command specified a CHANNEL that has been deleted.
   No action was taken.

   A:	Enter a correct command.


   Message:
   asu_: CHANNEL cannot be attached because its service type is TYPE (N).

   S:	as (severity1)

   T:	$run

   M:	An attach command specified a CHANNEL whose service type
   does not permit it to be attached.
   No action was taken.

   A:	Enter a correct command.


   Message:
   asu_: CHANNEL was not configured at bootload time, and so cannot be
   attached.

   S:	as (severity1)

   T:	$run

   M:	An attach command specified a CHANNEL that cannot be used
   until the next bootload.  No action was taken.

   A:	Enter a correct command.


   Message:
   asu_: CHANNEL is in use by the message coordinator and cannot be attached.

   S:	as (severity1)

   T:	$run

   M:	An operator attach command specified a message coordinator CHANNEL.
   The channel was not attached.

   A:	Enter a correct command.


   Message:
   asu_: ERROR_MESSAGE.  ENTRY OPERATION error; will remove channel CHANNEL 
   DESC

   S:	as (severity1)

   T:	$run

   M:	A channel error has occurred on CHANNEL.  DESC is the comment field
   for the channel given in its Channel Definition Table (CDT) entry.
   ERROR_MESSAGE gives the text describing the error code returned by
   the operation in progress.
   OPERATION may be create_ev_chn, decl_event_call_chn, listen, set_term_type,
   tty_event or tty_index, dependent upon the operation in progress when
   the error occurred.
   ENTRY specifies the asu_ entrypoint that was running when the operation
   was performed on the channel.  It may be asu_listen or attach_channel.
   The channel will be removed from use.

   A:	It may be necessary to busy out the modem for the channel.


   Message:
   asu_: cdtep (CCC|ZZZ) not cdt (YYY|0)

   S:	as (severity0)

   T:	$run

   M:	$err
   Remove_cdte is trying to get rid of a channel which is no good.

   A:	$ignore


   Message:
   asu_: cdte CCC|XXX (CHANNEL) hung up

   S:	as (severity0)

   T:	$run

   M:	Remove_cdte is trying to get rid of a channel.
   The indicated CHANNEL is in the hung up state.

   A:	$ignore


   Message:
   asu_$remote_cdte: ERROR_MESSAGE. cdte CCC|XXX error from tty_state

   S:	as (severity0)

   T:	$run

   M:	Remove_cdte is trying to get rid of a channel.
   It cannot obtain the line state.

   A:	$ignore


   Message:
   asu_: cdte CCC|XXX (CHANNEL) state A in use B tra vec C

   S:	as (severity0)

   T:	$run

   M:	Remove_cdte is trying to get rid of a channel.
   It first logs the state of the line.

   A:	$ignore


   Message:
   asu_: (called by PROCEDURE) USER.PROJ CHN was already stopped and will be destroyed (stopstop wakeup was lost)

   S:	as (severity1)

   T:	In response to an operator command to bump or log out an interactive,
   absentee, or daemon user.

   M:	The process being bumped or logged out was found to be in the stopped state
   (partially logged out). A wakeup from ring zero indicating that the process
   was stopped and could be destroyed was apparently lost. Destruction of the
   process will be completed.

   A:	$inform

   Message:
   asu_: (called by PROCEDURE) USER PROJ CHN is not stopped (state = S) even
   though destroy flag = D;
   it might not be possible to destroy this process

   S:	as (severity1)

   T:	In response to an operator command to bump or log out an interactive,
   absentee, or daemon user.

   M:	The process being bumped or logged out was found to be partially
   logged out already, but not in the stopped state. An attempt will be made to
   destroy this process, but it might fail.

   A:	$inform

   Message:
   asu_: unmasking channel CHANNEL.

   S:	as (severity1)

   T:	In response to an operator command to attach a channel which has
   been masked by MCS.

   M:	A special order is issued to MCS to unmask CHANNEL, and the
   channel should then be available for regular use.

   A:	$ignore


   Message:
   asu_: MESSAGE. unable to unmask channel CHANNEL.

   S:	as (severity1)

   T:	In response to an operator command to attach a channel which had
   been masked by MCS.

   M:	The CHANNEL could not be unmasked.

   A:	$inform


   Message:
   asu_: ENTRYPOINT called with null UTE ptr.

   S:     as (severity0)

   T:	ENTRYPOINT may be suspend_process or setup_login_server_handle.  
   suspend_process was called by one of the process termination handlers
   to suspend an interactive process whose terminal disconnected, or to suspend
   an absentee process via the operator "abs suspend" command.  
   setup_login_server_handler was called in response to a validate, connect, 
   new_proc, or destroy request from a login server.

   M:     Programming error in the process termination handlers, or the
   login server support of the Answering Service.

   A:	$inform

 
   Message:
   asu_: CHANNEL in use as a multiplexer and cannot be attached.

   S:	$as0

   T:	When issuing an operator attach command for a channel.

   M:	CHANNEL is operating as a multiplexer, supporting one or more 
   channels.  It cannot be attached directly.  The attach operation fails.

   A:	$tryagain

   Message:
   asu_: CHANNEL in use for T & D and cannot be attached.

   S:	as (severity1)

   T:	$run

   M:	An operator attach command specified a CHANNEL being tested via
   Test and Diagnostic routines.   The channel was not attached.

   A:	$tryagain


   Message:
   asu_: CHANNEL has in_use = N, current state = S, {CDTE.state was OS}

   S:	$as1

   T:	When the operator attempts to attach the channel.

   M:	The Channel Definition Table (CDT) entry for CHANNEL is in an
   inconsistent state.  See dialup_values.incl.pl1 for a description of
   the in_use and state values.  The old state value OS is displayed only if 
   it differs from the current state.

   A:	$tryagain


   Message:
   asu_: CHANNEL is already attached; will try to listen to it again

   S:	$as1

   T:	When the operator attempts to attach a channel.

   M:	The CHANNEL was already attached by the Answering Service, but was
   not dialed up.  The Answering Service will attempt to listen for dialups
   on the channel.

   A: 	$tryagain

 
   Message:
   asu_: Unable to create event channel for new UTE LOCATION

   S:	$as2

   T:	$run

   M:	$err

   A:	$notify


   Message:
   asu_$release_ate: bad cdte.process (LOCATION) for CHANNEL

   S:	$as0

   T:	$run

   M:	$err  When asked to release a User Table Entry (UTE) for an 
   interactive process, the cdte.process pointer (LOCATION) did not point into 
   the answer table.  The UTE was not released.

   A:	$ignore


   Message:
   asu_:  attach channel not done on CHANNEL; service type = TYPE

   S:	$as0

   T:	When attaching channels to the Answering Service.

   M:	The CHANNEL was found in an inactive state (TYPE = INACTIVE), or
   was found to be a multiplexer channel (TYPE = MULTIPLEXER).  It was not
   attached.  $err

   A:	$ignore


   Message:
   asu_: listen not done on CHANNEL: IN_USE with state = STATE, 
   in_use = IN_USE, tra_vec = CURRENT_OPERATION

   S:	$as0

   T:	When the Answering Service tries to listen to the channel.

   M:	The Channel Definition Table (CDT) entry for CHANNEL is in an
   inconsistent state.  See dialup_values.incl.pl1 for a description of
   the state, in_use and tra_vec values.

   A:	$ignore


   Message:
   asu_:  listen not done on CHANNEL; current service type = TYPE

   S:	$as0

   T:	When the Answering Service tried to listen to the channel.

   M:	The CHANNEL was found in an inactive state (TYPE = INACTIVE), 
   was found to be a multiplexer channel (TYPE = MULTIPLEXER), was found to
   be in use by the message coordinator (TYPE = MC), or was found to
   be attached for Testing and Diagnostics (TYPE = TANDD_SERVICE).  The attempt
   to listen on the channel failed.  $err

   A:	$ignore


   Message:
   asu_: listen failed on CHANNEL:  state = N

   S:	$as0

   T:	When attempting to listen for dialups on the channel.

   M:	The Channel Definition Table (CDT) entry for CHANNEL has an
   invalid state value N.  Channel listening will not occur.

   A:	 $ignore


   Message:
   asu_: CHANNEL is a multiplexer and cannot be removed.

   S:	$as1

   T:	When the operator attempts to remove a channel.

   M:	CHANNEL is a multiplexer channel which handles data for one or
   more subchannels.  Such multiplexers are not attached by the Answering
   Service, and therefore cannot be removed.

   A:	  $tryagain


   Message: 
   asu_$bump_user: ERROR_MESSAGE. BLAST_MESSAGE. Sending blast message to
   PERSON.PROJECT on CHANNEL

   S:	$as0

   T:	$run

   M:	An error occurred while attempting to send an operator warning 
   message to PERSON.PROJECT on CHANNEL.  ERROR_MESSAGE is the text associated
   with the error which occurred.  BLAST_MESSAGE is the undelivered operator
   warning.

   A:	 $ignore

   Message:
   asu_$suspend_process: PERSON.PROJECT CHANNEL is already suspended

   S:	$as1

   T: 	asu_$suspend_process was called by one of the process termination 
   handlers to suspend an interactive process whose terminal disconnected, or 
   to suspend an absentee process via the operator "abs suspend" command.  

   M:	The process is already suspended.  The current request will be
   ignored.

   A:	$ignore


   Message:
   asu_$release_suspended_process: PERSON.PROJECT CHANNEL is not suspended

   S:	$as0

   T:	Called in response to an operator "abs release" command, or in
   response to a user reconnecting to an interactive process.

   M:	One of the process termination handlers is incorrectly calling
   to release a process which is not currently suspended.

   A:	$ignore


   Message:
   asu_: ERROR_MESSAGE.  Sending initial wakeup to PROCESS_ID (PERSON.PROJECT)

   S:	$as0

   T:	Called at process creation to start the process running.

   M: 	ERROR_MESSAGE is the text of an error which occurred attempting
   to send a wakeup to PERSON.PROJECT.  As a result of this error, process
   creation will fail.

   A:	$ignore


   Message:
   asu_: ERROR_MESSAGE. Retrieving the values of R-0ffset and R-Factor for
   PROCESS_ID (PERSON.PROJECT).

   S:	$as0

   T:	Called at process creation.

   M:	asu_$start_process called hphcs_$get_ipc_operands.  This call failed
   with an error whose text is shown as ERROR_MESSAGE.  As a result, the
   process will not be started.

   A:	$ignore


   END MESSAGE DOCUMENTATION */

     end asu_;
