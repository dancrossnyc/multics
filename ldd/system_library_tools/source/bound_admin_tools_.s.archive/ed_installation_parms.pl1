/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

/****^  HISTORY COMMENTS:
  1) change(87-03-30,Parisek), approve(87-05-01,MCR7690),
     audit(87-07-15,Beattie), install(87-08-04,MR12.1-1055):
     Add parameter 64 - vchn_requires_accept.
  2) change(87-08-17,Hartogs), approve(88-08-15,MCR7969),
     audit(87-08-24,GDixon), install(88-08-29,MR12.2-1093):
     Error handling for -dr fixed for rate_structure_0. (phx14904)
  3) change(88-09-19,GDixon), approve(88-09-20,MCR8012),
     audit(88-10-06,Farley), install(88-10-07,MR12.2-1142):
     Fix error in initiating the installation_parms (rate_structure_0) segment
     introduced by an earlier change (error_table_$segknown is being reported
     as an error, rather than being ignored).
                                                   END HISTORY COMMENTS */

/* format: style4 */
ed_installation_parms:
     procedure;

/* ED_INSTALLATION_PARMS - program to edit the "installation_parms" segment
   which gives the prices for all system resources, and various other
   system_wide accounting-type constants.

   Modified 740805 by PG for level & category names.
   Modified 741120 by LJS for syserr log copying threshold.
   Modified Aug 1977 by T. Casey for disk and tape device price setting
   Modified May 1978 by T. Casey to add parameters 21, ..., 32: resource prices, rcp_init_flags, and
   .		various times and counters used in answering service operation.
   Modified August 1978 by M. R. Jordan to fix bug in set_rcp_init_flag.
   Modified November 1978 by T. Casey to add parameters 33,...47 for MR7.0 absentee changes.
   Modified March 1979 by C. D. Tavares to change rcp_init_flags and handling
   Modified July 1979 by J. N. R. Barnecut for MR8.0 to support multiple rate structures. (UNCA)
   Modified May 1980 by J. N. R. Barnecut to ensure devices and resources are kept in same positions. (UNCA)
   Modified 22 September 1980 by G. Palter to add parameter 48 -- abs_default_queue
   Modified 6 April 1981 by E. N. Kittlitz to add parameters 49,50 -- cwe_count, cwe_time
   Modified 3 June 1981 by E. N. Kittlitz for UNCA rate structures, re-organization.
   .    Added parameters 51-55: rates, devices, resources, rate_structure_name, all_structures.
   .    mr9_default establishes version, converts abs cpu limits from fixed bin (17) to fixed bin (35).
   .    Program extensively re-structured, although many sub-tasks stayed the same.
   Modified 22 February 1982 by E. N. Kittlitz for bug fixes.
   Modified May 1982 by E. N. Kittlitz for retype prices change.
   Modified 1984-06-19 BIM for strict_trusted_path, remove ARPA
   Modified 1984-12, BIM: pdir quota values, operator login values.
   Modified 1985-01-09, BIM: message coordinator access control.
   Modified 1985-03-01 by E. Swenson for password flags.
*/

/* automatic */

dcl  all_sw bit (1) aligned;
dcl  all_abs_queue_sw bit (1) aligned;
dcl  all_rates_sw bit (1) aligned;
dcl  all_structures_sw bit (1) aligned;
dcl  argp ptr;
dcl  arg char (argl) based (argp);
dcl  argl fixed bin (21);
dcl  argno fixed bin;
dcl  change_request bit (1) aligned;
dcl  char32 char (32);
dcl  char48 char (48);
dcl  char8 char (8);
dcl  comm char (32);
dcl  copy_ip (ipl) fixed bin based;
dcl  critical_op bit (1) aligned;
dcl  cur_rs_ptr ptr;
dcl  did_something bit (1) aligned;
dcl  dn char (168);
dcl  dnvar char (168) varying;
dcl  ec fixed bin (35);
dcl  edit_rs bit (1) aligned;
dcl  en char (32);
dcl  i fixed bin;
dcl  ip ptr defined (rs_ptrs (0));			/* working copy of installation_parms */
dcl  ip1 ptr defined (rs_ptrs1 (0));
dcl  ipl fixed bin;
dcl  j fixed bin;
dcl  k fixed bin;
dcl  keywx fixed bin;
dcl  nargs fixed bin;
dcl  path char (168) init ("");
dcl  print_comm char (32);
dcl  rs_ptrs (0:9) ptr;				/* rate structure pointers */
dcl  rs_ptrs1 (0:9) ptr;
dcl  rsp ptr;
dcl  rsp1 ptr;
dcl  selected_rs_ptr ptr;
dcl  suppress_nl bit (1) aligned;

dcl  (cleanup, program_interrupt) condition;

/* internal static constants */

dcl  NOLIMIT fixed bin (35) int static options (constant) init (-999999);
dcl  MILLION fixed bin (35) int static init (1000000);
dcl  SECONDS_PER_MONTH float bin (27) init (30 * 24 * 3600) int static options (constant);
dcl  ADD fixed bin init (1) static options (constant);
dcl  CHANGE fixed bin init (2) static options (constant);
dcl  PRINT fixed bin init (3) static options (constant);
dcl  RETYPE fixed bin init (4) static options (constant);
dcl  NO_SPECIAL_DEVICES bit (1) aligned init ("0"b) static options (constant);
dcl  SPECIAL_DEVICES_OK bit (1) aligned init ("1"b) static options (constant);
dcl  NOT_RS_ID fixed bin init (-2) static options (constant);
dcl  ID_NOT_FOUND fixed bin init (-1) static options (constant);
dcl  ALL_RS bit (1) aligned init ("1"b) static options (constant);
dcl  THIS_RS bit (1) aligned init ("0"b) static options (constant);
dcl  SET_HI bit (1) aligned init ("1"b) static options (constant);
dcl  NO_SET_HI bit (1) aligned init ("0"b) static options (constant);
dcl  COMPLAIN bit (1) aligned init ("1"b) static options (constant);

dcl  daynam char (21) int static options (constant) init ("MonTueWedThuFriSatSun");
dcl  me char (24) int static options (constant) init ("ed_installation_parms");
dcl  ip_rings (3) fixed bin (3) init (4, 5, 5) int static options (constant);

/* internal static */

dcl  told_user bit (1) aligned internal static init ("0"b);

/* based structures */

dcl  based_integer fixed bin based;

/* builtins */

declare  (addr, before, bit, char, currentsize, dim, dimension, divide, fixed, hbound, index, lbound, length, ltrim, bin,
         null, ptr, rel, reverse, rtrim, string, substr, verify, unspec) builtin;

/*  external variables */

dcl  error_table_$badopt fixed bin (35) ext static;
dcl  error_table_$inconsistent ext fixed bin (35);
dcl  error_table_$incorrect_access fixed bin (35) ext static;
dcl  error_table_$segknown fixed bin (35) ext static;
dcl  error_table_$segnamedup fixed bin (35) ext static;

/* entries */

dcl  absolute_pathname_ entry (char (*), char (*), fixed bin (35));
dcl  ask_ entry options (variable);
dcl  ask_$ask_clr entry ();
dcl  ask_$ask_flo entry options (variable);
dcl  ask_$ask_int entry options (variable);
dcl  ask_$ask_line entry options (variable);
dcl  ask_$ask_n entry options (variable);
dcl  ask_$ask_yn entry options (variable);
dcl  com_err_ entry options (variable);
dcl  cu_$arg_count entry (fixed bin);
dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
dcl  cv_$mwvf entry (float bin) returns (char (15));
dcl  cv_dec_ entry (char (*)) returns (fixed bin (35));
dcl  cv_float_ entry (char (*), fixed bin (35), float bin (27));
dcl  expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35));

dcl  hcs_$chname_file entry (char (*), char (*), char (*), char (*), fixed bin (35));
dcl  hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
dcl  hcs_$delentry_seg entry (ptr, fixed bin (35));
dcl  hcs_$set_bc_seg entry (ptr, fixed bin (24), fixed bin (35));
dcl  hcs_$set_ring_brackets entry (char (*), char (*), (3) fixed bin (3), fixed bin (35));
dcl  hcs_$set_safety_sw_seg entry (ptr, bit (1), fixed bin (35));
dcl  hcs_$truncate_seg entry (ptr, fixed bin (19), fixed bin (35));
dcl  initiate_file_ entry (character (*), character (*), bit (*), pointer, fixed binary (24),
	fixed binary (35));
dcl  ioa_ entry options (variable);
dcl  nd_handler_ entry (char (*), char (*), char (*), fixed bin (35));
dcl  terminate_file_ entry (pointer, fixed binary (24), bit (*), fixed binary (35));
%page;
/* The following two static arrays, keyw and keyn, map the keywords and their
   (zero or more) abbreviations into key numbers that map into the label arrays.
   These two arrays must be kept in sync if keywords or abbreviations are added,
   and the values in the keyn array must always be in increasing order.
   Notice that each array is the other one with its value and comment columns interchanged.
   Another array valid_rs_id must also be updated when adding an identifier
   which may be used when editing a rate structure.
   There are also arrays sequence_ALL and sequence_RATES which may require updating
   when adding a new identifier.
*/

dcl  keyw (119) char (32) int static options (constant) init ("all",
						/* 1 */
	"installation_id",				/* 2 */
	"inst",					/* 2 */
	"shift_table",				/* 3 */
	"shif",					/* 3 */
	"prices",					/* 4 */
	"titles",					/* 5 */
	"level_names",				/* 6 */
	"leve",					/* 6 */
	"inactive_time",				/* 7 */
	"inac",					/* 7 */
	"warning_time",				/* 8 */
	"warn",					/* 8 */
	"login_time",				/* 9 */
	"logi",					/* 9 */
	"tries",					/* 10 */
	"update_time",				/* 11 */
	"upda",					/* 11 */
	"device_prices",				/* 12 */
	"devprice",				/* 12 */
	"devp",					/* 12 */
	"config_table",				/* 13 */
	"conf",					/* 13 */
	"queue_prices",				/* 14 */
	"abs_queue_parameters",			/* 15 */
	"abs_",					/* 15 */
	"category_names",				/* 16 */
	"cate",					/* 16 */
	"access_ceiling",				/* 17 */
	"acce",					/* 17 */
	"log_parameters",				/* 18 */
	"log_",					/* 18 */
	"trusted_path_login",			/* 19 */
	"device_names",				/* 20 */
	"devname",				/* 20 */
	"devn",					/* 20 */
	"resource_prices",				/* 21 */
	"rscprice",				/* 21 */
	"rscp",					/* 21 */
	"resource_names",				/* 22 */
	"rscname",				/* 22 */
	"rscn",					/* 22 */
	"resource_wait_time",			/* 23 */
	"rsctime",				/* 23 */
	"rsct",					/* 23 */
	"fpe_time",				/* 24 */
	"fpetime",				/* 24 */
	"fpet",					/* 24 */
	"fpe_count",				/* 25 */
	"fpecount",				/* 25 */
	"fpec",					/* 25 */
	"trm_real_time",				/* 26 */
	"trmrealtime",				/* 26 */
	"trmr",					/* 26 */
	"trm_cpu_time",				/* 27 */
	"trmcputime",				/* 27 */
	"trmc",					/* 27 */
	"unload_on_detach",				/* 28 */
	"unlo",					/* 28 */
	"authentication_level",			/* 29 */
	"auth",					/* 29 */
	"default_pdir_seg_quota",			/* 30 */
	"df_pdsq",				/* 30 */
	"rsc_mgmt_enabled",				/* 31 */
	"rsc_",					/* 31 */
	"auto_registration",			/* 32 */
	"auto",					/* 32 */
	"enable_ss_volume_mount",			/* 33 */
	"foreground_queue_position",			/* 34 */
	"fore",					/* 34 */
	"idle_time_constant",			/* 35 */
	"idle",					/* 35 */
	"sus_cpu_time",				/* 36 */
	"susc",					/* 36 */
	"sus_real_time",				/* 37 */
	"susr",					/* 37 */
	"max_abs",				/* 38 */
	"min_abs",				/* 39 */
	"pct_abs",				/* 40 */
	"max_qres",				/* 41 */
	"min_qres",				/* 42 */
	"pct_qres",				/* 43 */
	"abs_cpu_max_limit",			/* 44 */
	"abscpumx",				/* 44 */
	"abs_timax",				/* 45 */
	"abs_cpu_default_limit",			/* 46 */
	"abscpudf",				/* 46 */
	"foreground_cpu_default_limit",		/* 47 */
	"fgcpudf",				/* 47 */
	"abs_default_queue",			/* 48 */
	"absdfq",					/* 48 */
	"cwe_time",				/* 49 */
	"cwet",					/* 49 */
	"cwe_count",				/* 50 */
	"cwec",					/* 50 */
	"rates",					/* 51 */
	"devices",				/* 52 */
	"device",					/* 52 */
	"resources",				/* 53 */
	"resource",				/* 53 */
	"rate_structure_names",			/* 54 */
	"rate_structure_name",			/* 54 */
	"rsn",					/* 54 */
	"all_structures",				/* 55 */
	"default_pdir_dir_quota",			/* 56 */
	"df_pddq",				/* 56 */
	"require_operator_login",			/* 57 */
	"operator_inactive_time",			/* 58 */
	"op_inac",				/* 58 */
	"validate_daemon_commands",			/* 59 */
	"password_min_length",			/* 60 */
	"pwml",					/* 60 */
	"password_gpw_length",			/* 61 */
	"pwgl",					/* 61 */
	"password_change_interval",			/* 62 */
	"pwci",					/* 62 */
	"password_expiration_interval",		/* 63 */
	"pwei",					/* 63 */
	"vchn_requires_accept"			/* 64 */
	);

%page;

dcl  keyn (119) fixed bin int static options (constant) init (1,
						/* all */
	2,					/* installation_id */
	2,					/* inst */
	3,					/* shift_table */
	3,					/* shif */
	4,					/* prices */
	5,					/* titles */
	6,					/* level_names */
	6,					/* leve */
	7,					/* inactive_time */
	7,					/* inac */
	8,					/* warning_time */
	8,					/* warn */
	9,					/* login_time */
	9,					/* logi */
	10,					/* tries */
	11,					/* update_time */
	11,					/* upda */
	12,					/* device_prices */
	12,					/* devprice */
	12,					/* devp */
	13,					/* config_table */
	13,					/* conf */
	14,					/* queue_prices */
	15,					/* abs_queue_parameters */
	15,					/* abs_ */
	16,					/* category_names */
	16,					/* cate */
	17,					/* access_ceiling */
	17,					/* acce */
	18,					/* log_parameters */
	18,					/* log_ */
	19,					/* trusted_path_login */
	20,					/* device_names */
	20,					/* devname */
	20,					/* devn */
	21,					/* resource_prices */
	21,					/* rscprice */
	21,					/* rscp */
	22,					/* resource_names */
	22,					/* rscname */
	22,					/* rscn */
	23,					/* resource_wait_time */
	23,					/* rsctime */
	23,					/* rsct */
	24,					/* fpe_time */
	24,					/* fpetime */
	24,					/* fpet */
	25,					/* fpe_count */
	25,					/* fpecount */
	25,					/* fpec */
	26,					/* trm_real_time */
	26,					/* trmrealtime */
	26,					/* trmr */
	27,					/* trm_cpu_time */
	27,					/* trmcputime */
	27,					/* trmc */
	28,					/* unload_on_detach */
	28,					/* unlo */
	29,					/* authentication_level */
	29,					/* auth */
	30,					/* default_pdir_quota */
	30,					/* df_pdsq */
	31,					/* rsc_mgmt_enabled */
	31,					/* rsc_ */
	32,					/* auto_registration */
	32,					/* auto */
	33,					/* enable_ss_volume_mount */
	34,					/* foreground_queue_position */
	34,					/* fore */
	35,					/* idle_time_constant */
	35,					/* idle */
	36,					/* sus_cpu_time */
	36,					/* susc */
	37,					/* sus_real_time */
	37,					/* susr */
	38,					/* max_abs */
	39,					/* min_abs */
	40,					/* pct_abs */
	41,					/* max_qres */
	42,					/* min_qres */
	43,					/* pct_qres */
	44,					/* abs_cpu_max_limit */
	44,					/* abscpumx */
	45,					/* abs_timax */
	46,					/* abs_cpu_default_limit */
	46,					/* abscpudf */
	47,					/* foreground_cpu_default_limit */
	47,					/* fgcpudf */
	48,					/* abs_default_queue */
	48,					/* absdfq */
	49,					/* cwe_time */
	49,					/* cwet */
	50,					/* cwe_count */
	50,					/* cwec */
	51,					/* rates */
	52,					/* devices */
	52,					/* device */
	53,					/* resources */
	53,					/* resource */
	54,					/* rate_structure_names */
	54,					/* rate_structure_name */
	54,					/* rsn */
	55,					/* all_structures */
	56,					/* default_pdir_dir_quota */
	56,					/* df_pddq */
	57,					/* require_operator_login */
	58,					/* operator_inactive_time */
	58,					/* op_inac */
	59,					/* validate_daemon_commands */
	60,					/* password_min_length */
	60,					/* pwml */
	61,					/* password_gpw_length */
	61,					/* psgl */
	62,					/* password_change_interval */
	62,					/* pwci */
	63,					/* password_expiration_interval */
	63,					/* pwei */
	64					/* vchn_requires_accept */
	);
%page;

/* valid_for_rs contains the indices of all change identifiers which may be
   used while editing a rate_structure. They must be in ascending order.
   A flag of 999 must be the last element. */

dcl  valid_for_rs (13) fixed bin static options (constant) init (1, 4, 12, 14, 20, 21, 22, 51, 52, 53, 54, 55, 999);

/* sequence_ALL defines the order in which individual requests will be made
   if the 'all' request is issued. */

dcl  sequence_ALL (54) fixed bin static options (constant)
	init (1, 2, 5, 7, 8, 9, 10, 49, 50, 11, 4, 14, 52, 53, 3, 6,
	16, 17, 18, 19, 57, 64, 58, 59, 60, 61, 62, 63,
	13, 23, 30, 56, 24, 25, 26, 27, 37, 36, 28,
	29, 31, 32, 33, 35, 34, 47, 48, 15, 38, 39, 40, 41, 42, 43);

/* sequence_RATES controls the order in which operations are performed when the
   identifier 'rates' (or 'all' when editing a rate_structure) is used.
   It contains only indices of rate_structure identifiers, in the same order
   as sequence_ALL. */

dcl  sequence_RATES (5) fixed bin static options (constant) init (51, 4, 14, 12, 21);

/*  sequence_ABS_Q controls the abs_queue_parameters identifier */

dcl  sequence_ABS_Q (4) fixed bin static options (constant) init (15, 44, 45, 46);
%page;
/*
   DIVERS POINTS

   This program supports the editing of installation_parms and up to
   nine additional rate_structures.  The accounting system is designed to
   charge for resources based upon pricing information contained
   in the rate_structure to which a user or project is assigned.
   The default pricing is contained in installation_parms, and is considered
   to be rate_structure 0.  If a site defines other rate_structures,
   they are numbered 1 through 9.

   The rate_structure definition is the same as installation_parms.
   However, certain fields are designated as invalid in a rate_structure.
   Additional rate_structures exist in segments names rate_structure_N.
   When accounting, a routine accesses all pricing information by using the
   rate_structure segment appropriate to the user/project being charged.

   Rate_structure names appear in installation_parms.rate_structures.
   There are installation_parms.nrates structures (<= 9), where
   structure 0 is "default" (i.e. installation_parms).

   This program is designed to allow the user to alter the fields of
   one rate_structure at a time.  The user indicates which rate_structure
   is under consideration via the "rate_structure" command.  In general,
   all subsequent editing requests act upon the last-specified rate_structure.

   Terminology: installation_parms is rate_structure 0. Its name is initially
   "default".  Within this program, the notion of editing a rate_structure is
   typically defined as editing a rate_structure other than installation_parms.
   There are a number of operations on rate_structure field which can
   only be performed while editing the default rate_structure (i.e.
   installation_parms).  In general, any operation which affects more than
   one rate_structure (such as renaming or retyping device information)
   can only be performed while editing installation_parms.

   WITHIN this program: the requests of principal interest are: add, change,
   print and retype.  These requests are dispatched to the procedure do_any.
   The do_any procedure does first-level checks to determine if a valid
   field identifier has been specified.  It also determines whether or
   not the field is "defined" in non-default rate_structures.
   An identifier is valid for a rate_structure only if its index appears in
   the array valid_for_rs.  (This technique is used to avoid having to add
   a control for every new identifier (most of which will be non-rate_structure).

   The do_any procedure calls the appropriate processor for the request given.
   If there is any conflict, an individual processor is responsible for
   detecting an invalid use of a non-rate_structure field.
   There are several field identifiers which correspond to a group of
   field identifiers.  Examples are "all", "abs_queue_parameters" and "rates".
   In these cases, do_any will make a number of calls to the designated
   processor.  The identifier "all_structures" causes do_any to loop
   over all rate_structures (including installation_parms).

   THERE are a number of internal procedures with entries.  Said entries
   have names of the form int_proc$$entry_name.
*/
%page;

/* INITIALIZATION */

	call ask_$ask_clr ();			/* make sure nothing in ask_ buffer */
	ip = null;				/* initialize pointers */
	ip1 = null;
	rs_ptrs (*), rs_ptrs1 (*) = null;
	edit_rs = "0"b;				/* and switches */
	selected_rs_ptr, cur_rs_ptr = null;
	critical_op = "0"b;

	on cleanup call clean_up;

	dn = "";

	call cu_$arg_count (nargs);			/* look for control arguments */
	if nargs > 0 then
	     do argno = 1 to nargs;
	     call cu_$arg_ptr (argno, argp, argl, ec);	/* next, please */
	     if ec ^= 0 then do;
		call com_err_ (ec, me);		/* horrors! */
		go to exit;
	     end;
	     else if arg = "-directory" | arg = "-dr" then do;
						/* containing directory? */
		if path ^= "" then			/* already have a path? */
		     go to er2;			/* inconsitent... */
		else do;
		     argno = argno + 1;		/* go for directory name */
		     call cu_$arg_ptr (argno, argp, argl, ec);
		     if ec ^= 0 then do;		/* user's fingers wore out */
			call com_err_ (ec, me);	/* display our distress */
			go to exit;		/* clean up */
		     end;
		     else do;			/* where to go */
			call absolute_pathname_ (arg, dn, ec);
			if ec ^= 0 then do;
			     call com_err_ (ec, me, "^a", arg);
			     go to exit;
			end;
			en = "installation_parms";
		     end;
		end;
	     end;
	     else if substr (arg, 1, 1) = "-" then do;	/* look like a control arg? */
		call com_err_ (error_table_$badopt, me, "^a", arg);
						/* well, it isn't */
		go to exit;
	     end;
	     else if dn ^= "" then do;		/* pathname? */
er2:
		call com_err_ (error_table_$inconsistent, me,
		     "pathname and -directory arguments may not both be specified.");
		go to exit;
	     end;
	     else do;				/* pathname, and it makes sense */
		path = arg;
		call expand_pathname_ (path, dn, en, ec);
		if ec ^= 0 then do;
		     call com_err_ (ec, me, "^a", path);
		     go to exit;
		end;
	     end;
	end;

	else do;					/* default path */
	     path = "installation_parms";
	     call expand_pathname_ (path, dn, en, ec);
	     if ec ^= 0 then do;
		call com_err_ (ec, me, "^a", path);
		go to exit;
	     end;
	end;

	if dn = ">" then
	     dnvar = ">";
	else dnvar = rtrim (dn) || ">";


/* Find all rate structures.
   NOTE: When i is set to 0 (the first trip), we get the value of
   rs_ptrs (0), i.e. also the value of the pointer "ip".  Then,
   we have an installation_parms structure 'defined', and can
   loop from 1 - installation_parms.nrates. */

	do i = 0, 1 repeat i + 1 while (i <= installation_parms.nrates);
	     if i = 0 then do;
		en = "installation_parms";		/* make or initiate installation_parms */
		call hcs_$make_seg (dn, en, "", RW_ACCESS_BIN, rsp1, ec);
		if ec = 0 then do;			/* segment was just created */
		     rsp1 -> installation_parms.version = installation_parms_version_2;
create_addname:					/* add the name rate_structure_0 to installation_parms */
		     call hcs_$chname_file (dn, "installation_parms", "", "rate_structure_0", ec);
		     if ec ^= 0 & ec ^= error_table_$segnamedup & ec ^= error_table_$incorrect_access then do;
						/* not on installation_parms? */
			call nd_handler_ (me, dn, "rate_structure_0", ec);
						/* try to get the name freed */
			if ec = 0 then go to create_addname;
						/* try again */
		     end;
		     call hcs_$set_ring_brackets (dn, en, ip_rings, ec);
						/* so try to set rings */
		     if ec ^= 0 then call com_err_ (ec, me, "Setting ring brackets of ^a.", en);
		end;				/* set the version, so we don't 'convert' later */
		else if ec ^= error_table_$segknown then do;
		     call com_err_ (ec, me, "rate_structure_^d ^a.", i, dnvar || rtrim (en));
		     go to exit;
		end;
	     end;
	     else do;				/* if installation_parms says there an RS */
		en = "rate_structure_" || ltrim (char (i));
						/* then the RS segment MUST exist */
		call initiate_file_ (dn, en, R_ACCESS, rsp1, (0), ec);
	     end;
	     if rsp1 = null then do;			/* something go wrong? */
		call write_error (ec, i, dnvar || rtrim (en));
		go to exit;
	     end;
	     call hcs_$make_seg ("", "", "", RW_ACCESS_BIN, rsp, ec);
						/* now get temporaries */
	     if rsp = null then do;
		call write_error (ec, i, "temporary segment");
		go to exit;
	     end;
	     ipl = currentsize (rsp1 -> installation_parms);
						/* copy contents to temp segment */
	     unspec (rsp -> copy_ip) = unspec (rsp1 -> copy_ip);
	     rs_ptrs (i) = rsp;
	     rs_ptrs1 (i) = rsp1;
	     if i = 0 then do;			/* some gullibility checks */
		selected_rs_ptr, cur_rs_ptr = ip;
		if installation_parms.version ^= installation_parms_version_2 then do;
		     if installation_parms.version ^= installation_parms_version_1 then do;
			call ioa_ ("The installation_parms segment is either damaged or a pre-MR9.0 version.^/If it is damaged, recover it from backup. If it is pre-MR9.0, MR10.2 or earlier must be used to convert it.");
			go to exit;
		     end;
		     else do;
			call ioa_ ("Converting installation parms to MR11 format.");
			installation_parms.version = installation_parms_version_2;

			installation_parms.trusted_path_login = "0"b;
			installation_parms.require_operator_login = "0"b;
			installation_parms.vchn_requires_accept = "0"b;
			installation_parms.operator_inactive_time = installation_parms.inactive_time;
			installation_parms.syserr_log_copy_threshold = 0;
			installation_parms.validate_daemon_commands = "0"b;
			installation_parms.password_min_length = 0; /* no minimum */
			installation_parms.password_gpw_length = 6;
			installation_parms.password_change_interval = 0; /* no change interval */
			installation_parms.password_expiration_interval = 0; /* no expiration */
			call set_pdir_quota_defaults; /* knows about communications */
		     end;
		end;
		if installation_parms.nrates < 0 | installation_parms.nrates > hbound (rs_ptrs, 1) then do;
		     call com_err_ (0, me,
			"Invalid number of rate_structures at offset ^o (8): ^d. Forcing value to 0.",
			bin (rel (addr (installation_parms.nrates)), 18), installation_parms.nrates);
		     installation_parms.nrates = 0;
		end;
	     end;
	end;


/* Handler for PROGRAM_INTERRUPT condition
   If a 'critical' operation is in progress, we ask the user whether or
   not we should really punt.  If not critical, or user says it's OK,
   we non-local goto back to the main loop.  Otherwise, restart. */

	on program_interrupt
	     begin;
dcl  yn char (4);
	     if critical_op then do;			/* HOT? */
		call ioa_ ("Terminating the current operation may leave tables in an inconsistent state.");
		call ask_$ask_yn ("Do you want to terminate? (""no"" will restart the operation)  ", yn);
		if yn = "yes" then go to main1;	/* we warned you */
	     end;
	     else go to main1;			/* safe to zap, so do it */
	end;

%page;

/* MAIN REQUEST LOOP */

main1:
	call ask_$ask_clr ();
main:
	if ^told_user then do;			/* Should we give instructions? */
	     call ioa_ ("Hit QUIT and use ""program_interrupt"" to return this request loop.");
	     told_user = "1"b;			/* never again in this process */
	end;

	cur_rs_ptr = selected_rs_ptr;			/* make sure we're using the proper rate_structure */
	edit_rs = (cur_rs_ptr ^= ip);			/* editing a rate_structure? */
	critical_op = "0"b;
	all_sw = "0"b;				/* OFF until: all, all_structures */
	all_abs_queue_sw = "0"b;			/* OFF until: all, all_structures, abs_queue_parameters */
	all_rates_sw = "0"b;			/* OFF until: all, all_structures, rates */
	all_structures_sw = "0"b;			/* OFF until: all_structures */
	change_request = "0"b;			/* OFF unless 'change' command */
	call ask_ ("type ", comm);			/* get command */
	if comm = "q" then do;
exit:
	     call clean_up;
	     return;
	end;
	else if comm = "w" then do;			/* write? */
	     call ask_$ask_n (char8, j);		/* write -force? */
	     if j ^= 0 then
		if ^(char8 = "-force" | char8 = "-fc") then j = 0;
	     do i = installation_parms.nrates to 0 by -1; /* write all rate_structures */
						/* and then installation_parms */
		ipl = currentsize (rs_ptrs (i) -> rate_structure);
						/* HOW big was it? */
		call hcs_$truncate_seg (rs_ptrs1 (i), (ipl), ec);
						/* tidy up end */
		if ec ^= 0 then do;			/* nice way to detect no-write */
		     call write_error (ec, i, "");	/* let user know */
		     if j ^= 0 then go to main1;	/* if not -force */
		end;
		unspec (rs_ptrs1 (i) -> copy_ip) = unspec (rs_ptrs (i) -> copy_ip);
						/* copy to real segment */
		call hcs_$set_bc_seg (rs_ptrs1 (i), 36 * ipl, ec);
						/* show 'em how big it is */
		if ec ^= 0 then do;			/* any little problems? */
		     call write_error (ec, i, "");
		     if j = 0 then go to main1;	/* give up, or -force ? */
		end;
		call hcs_$set_safety_sw_seg (rs_ptrs1 (i), "1"b, ec);
		if ec ^= 0 then do;			/* ok or not */
		     call write_error (ec, i, "");
		     if j = 0 then go to main1;	/* not -force? */
		end;
	     end;
	end;
	else if comm = "a" | comm = "add" then call do_any (ADD);
	else if comm = "c" | comm = "change" then call do_any (CHANGE);
	else if comm = "p" | comm = "pr" | comm = "print" then call do_any (PRINT);
	else if comm = "r" | comm = "retype" then call do_any (RETYPE);
	else if comm = "default" then go to default;	/* defaults of some kind */
	else if comm = "v" | comm = "verify" then call verify_structures;
	else if comm = "h" | comm = "help" then do;	/* help of some kind */
	     call ioa_ ("Requests: change ID, print ID, retype ID, add ID, w, q");
						/* basic requests */
	     call ioa_ ("help {-long}, default, mrXX_default, rate_structure RSN, copy, verify");
	     if edit_rs then call ioa_ ("Use: ""rate_structure ."" to edit the ""installation_parms"" segment.");
	     call ioa_ ("  Valid ids: all");		/* special case first */
	     call ask_$ask_n (char32, k);		/* user wants long output? */
	     if k ^= 0 & (char32 = "long" | char32 = "-long" | char32 = "-lg") then
		k = 1;				/* long, it is */
	     else k = 0;				/* 2 to 1 user types it later... */
	     j = 1;
	     do i = 2 to hbound (keyw, 1);		/* print all keywords */
		do while (keyn (i) > valid_for_rs (j) & j < hbound (valid_for_rs, 1));
		     j = j + 1;			/* next valid RS id */
		end;
		if ^edit_rs | keyn (i) = valid_for_rs (j) then
						/* not RS, or OK for RS */
		     if k ^= 0 | keyn (i) ^= keyn (i - 1) then
						/* not same 'ID', or -long */
			call ioa_ ("^13x^[^2x^]^a", (keyn (i) = keyn (i - 1)), keyw (i));
						/* with short forms indented */
	     end;
	     go to main1;
	end;
	else if comm = "rates" | comm = "rate_structure" then do;
	     call ask_$ask_n (char32, i);		/* trying to go somewhere? */
	     if i = 0 then				/* no - just lost */
		call ioa_ ("Editing rate_structure ""^a"".", ptr_rs_name (cur_rs_ptr));
	     else do;
		call ask_ ("", char32);		/* pick it off the line */
		i = rstab$$defined (char32, COMPLAIN);	/* does it exist? */
		if i < 0 then go to main1;		/* oh my, no it doesn't */
		selected_rs_ptr = rs_ptrs (i);	/* all works out at label main */
	     end;
	end;
	else if comm = "copy" then go to copy_rs;	/* from 1 RS to another */
	else do;
	     call ioa_ ("Illegal command ""^a"". Type help for instructions.", comm);
	     go to main1;
	end;

	go to main;				/* beg for more */
%page;

/* DEFAULT HANDLING for INSTALLATION_PARMS */

default:
	if edit_rs then go to default_rs;

/* will this change device table or resource table? VERY dangerous */

	if installation_parms.nrscp > 0 | installation_parms.ndevices > hbound (dev_id, 1)
	     | installation_parms.version < 0 | installation_parms.version > installation_parms_version_1
	     | installation_parms.version = 0 & ptr (ip, 1076) -> based_integer > 0 then do;
	     call ioa_ ("This operation may make other system tables invalid.");
	     call ask_$ask_yn ("Do you want to proceed?  ", char8);
	     if char8 ^= "yes" then go to main1;
	end;
	installation_parms.installation_id = "Installation and location";
	installation_parms.company = "Company Name";
	installation_parms.department = "Department Name";
	installation_parms.companyds = "C o m p a n y   N a m e";
	installation_parms.departmentds = "D e p a r t m e n t";
	call set_std_shifttab;
	do i = 0 to 7;
	     rate_structure.cpu_price (i) = 240e0;
	     rate_structure.log_base_price (i) = 1.25e0;
	     rate_structure.io_ops_price (i) = 0e0;
	     rate_structure.core_price (i) = 15e0;
	end;
	rate_structure.ndevices = hbound (dev_id, 1);	/* define those devices for which charging is built in */
	do i = 1 to 16;
	     if i <= rate_structure.ndevices then
		rate_structure.device_id (i) = dev_id (i);
	     else rate_structure.device_id (i) = "dev" || ltrim (char (i));
						/* fill in non-garbage for undefined ones */
	     do j = 0 to 7;
		rate_structure.device_price (i, j) = 1e0;
						/* initialize for all shifts */
	     end;
	end;
	installation_parms.default_pdir_dir_quota,
	     installation_parms.default_pdir_seg_quota = 1000;
	installation_parms.operator_inactive_time,
	     installation_parms.inactive_time = 3600;
	installation_parms.warning_time = 300;
	installation_parms.login_time = 360;
	installation_parms.acct_update = 900;
	installation_parms.login_tries = 6;
	rate_structure.disk_price = .19290120e-6;
	rate_structure.registration_price = 0e0;
	rate_structure.dolsign = "$";
	do i = 1 to 4;
	     rate_structure.abs_cpu_price (i) = 200e0;
	     rate_structure.abs_mem_price (i) = 15e0;
	     rate_structure.iod_rec_price (i) = 1.80e0;
	     installation_parms.abs_timax (i) = 16000000;
	     installation_parms.abs_cpu_default_limit (i) = 1200;
						/* 1200 seconds = 20 minutes */
	end;

	do i = 1 to hbound (installation_parms.level_names (*), 1);
	     installation_parms.level_names (i) = "level_" || ltrim (char (i));
	     installation_parms.short_level_names (i) = "l" || ltrim (char (i));
						/* man-or-boy common sub-expression test */
	end;

	installation_parms.level_names (0) = "";	/* level zero is blank */
	installation_parms.short_level_names (0) = "";

	do i = lbound (installation_parms.category_names (*), 1) to hbound (installation_parms.category_names (*), 1);
	     installation_parms.category_names (i) = "category_" || ltrim (char (i));
	     installation_parms.short_category_names (i) = "c" || ltrim (char (i));
	end;

	installation_parms.access_authorization_ceiling = ""b;
						/* Level 0, no categories */

	installation_parms.ncon = 1;
	installation_parms.cpu (1) = 8;
	installation_parms.shift (1) = 7;
	installation_parms.x1 (1) = 0;
	installation_parms.kmem (1) = 16384;
	installation_parms.kbulk (1) = 16384;
	installation_parms.x2 (1) = 0;
	installation_parms.maxa (1) = 3;
	installation_parms.maxq (1) = 3;
	installation_parms.maxu_base (1) = 900;
	installation_parms.response_high (1) = 300;
	installation_parms.response_low (1) = 100;
	installation_parms.x3 (1) = 0;
	installation_parms.syserr_log_copy_threshold = 0; /* use default value in ring 0. */

/* Following parameters added for MR6.5 */

	unspec (installation_parms.rcp_init_flags) = ""b; /* all flags off */
	installation_parms.nrscp = 0;			/* no resource prices defined */
	installation_parms.rsc_timer_seconds = 300;	/* 5 minutes between tries for resource reservations */
	installation_parms.fatal_error_loop_count = 3;	/* any user who gets 3 fatal process errors */
	installation_parms.fatal_error_loop_seconds = 60; /* within one minute, gets logged out */
	installation_parms.term_real_time_seconds = 120;	/* allow 2 minutes to signal finish after getting trm_ signal */
	installation_parms.term_cpu_time_seconds = 5;	/* and only 5 seconds of cpu time (in case of runaway process) */

/* Following parameters added for MR7.0 */

	do i = 1 to 4;
	     if installation_parms.abs_cpu_default_limit (i) > MILLION then
						/* if limit is still in microseconds */
		installation_parms.abs_cpu_default_limit (i) =
		     divide (installation_parms.abs_cpu_default_limit (i), MILLION, 35, 0);
						/* convert it to seconds */
	end;

	installation_parms.foreground_queue_position = 0; /* foreground queue comes after Q 0, before Q 1 */
	installation_parms.foreground_cpu_default_limit = installation_parms.abs_cpu_default_limit (3);
						/* current shift 3 limit is better than none at all */
	installation_parms.idle_time_constant_seconds = 900;
						/* average the idle units over the last 5 minutes */
	installation_parms.sus_cpu_time_seconds = 5;	/* allow suspended process to use up to 5 cpu seconds */
	installation_parms.sus_real_time_seconds = 180;	/* and up to 3 minutes for it to respond, before destroying it */

	do i = 0 to 7;				/* go thru shifts */
	     installation_parms.max_abs (i) = -1;	/* -1 means "use the abs_maxu in the config array" */
	     installation_parms.min_abs (i) = 0;
	     installation_parms.pct_abs (i) = 0;
	     do j = 1 to 4;				/* go thru queues */
		installation_parms.abs_cpu_max_limit (i, j) = installation_parms.abs_cpu_default_limit (j);
						/* keeping the effective limits the same as they are now */
		installation_parms.max_qres (i, j) = 0; /* no slots reserved, by default */
		installation_parms.min_qres (i, j) = 0;
		installation_parms.pct_qres (i, j) = 0;
	     end;
	end;

/* Following parameters added for MR8.0 */

	if substr (installation_parms.rcp_init_flags.pad1, 1, 1) then
						/* old skip_validation bit */
	     installation_parms.rcp_init_flags.authentication_level = No_authentication;
	else if substr (installation_parms.rcp_init_flags.pad1, 2, 1) then
						/* old exact_authentication bit */
	     installation_parms.rcp_init_flags.authentication_level = Automatic_authentication;
	else installation_parms.rcp_init_flags.authentication_level = Nominal_authentication;

	installation_parms.rcp_init_flags.pad1 = ""b;	/* zero obsolete bits */

	if edit_rs then go to cant_comm_rs;

	installation_parms.default_absentee_queue = 3;	/* for enter_abs_request, etc. */
	installation_parms.chn_wakeup_error_loop_count = 10;
						/* to control Answering Service hacking */
	installation_parms.chn_wakeup_error_loop_seconds = 3;
						/* ditto */
	installation_parms.nrates = 0;		/* only RS 0 (installation_parms) */
	installation_parms.rate_structures (*) = "";	/* all RS names are blank */
	installation_parms.rate_structures (0) = "default";
						/* except the zero-th */
	installation_parms.trusted_path_login = "0"b;
	installation_parms.require_operator_login = "0"b;
	installation_parms.vchn_requires_accept = "0"b;
	installation_parms.validate_daemon_commands = "0"b;
	installation_parms.operator_inactive_time = installation_parms.inactive_time;
	installation_parms.password_min_length = 0;	/* none */
	installation_parms.password_gpw_length = 6;	/* compatibility */
	installation_parms.password_change_interval = 0;	/* none */
	installation_parms.password_expiration_interval = 0; /* none */

	call verify_structures;			/* make a fast check */

	go to main;

cant_comm_rs:
	call ioa_ ("""^a"" is not allowed while editing a rate_structure.", comm);
	go to main1;
%page;

/* DEFAULT HANDLING for RATE-STRUCTURES */

default_rs:					/* default for a rate_structure working installation_parms */
	rsp = ip;
	go to copy_rs1;

copy_rs:						/* copy anywhere but into installation_parms */
	if cur_rs_ptr = ip then do;
	     call ioa_ ("A copy into the default rate structure is not allowed.  Use default or change all.");
	     go to main1;
	end;
crs1a:
	call ask_ ("from^-", char32);			/* what is user's desire? */
	i = rstab$$defined (char32, COMPLAIN);		/* is it feasible? */
	if i < 0 then go to crs1a;			/* 'fraid not */
	rsp = rs_ptrs (i);				/* pointer to it */
	if rsp = cur_rs_ptr then do;			/* how silly */
	     call ioa_ ("A copy from the same rate structure is not allowed.");
	     call ask_$ask_clr ();
	     go to crs1a;
	end;

copy_rs1:						/* copy all pricing info */
	do i = 0 to 7;
	     rate_structure.cpu_price (i) = rsp -> rate_structure.cpu_price (i);
	     rate_structure.log_base_price (i) = rsp -> rate_structure.log_base_price (i);
	     rate_structure.io_ops_price (i) = rsp -> rate_structure.io_ops_price (i);
	     rate_structure.core_price (i) = rsp -> rate_structure.core_price (i);
	end;
	rate_structure.disk_price = rsp -> rate_structure.disk_price;

	rate_structure.registration_price = rsp -> rate_structure.registration_price;
	rate_structure.ndevices = rsp -> rate_structure.ndevices;
	rate_structure.devtab (*) = rsp -> rate_structure.devtab (*);
	rate_structure.abs_cpu_price (*) = rsp -> rate_structure.abs_cpu_price (*);
	rate_structure.abs_mem_price (*) = rsp -> rate_structure.abs_mem_price (*);
	rate_structure.iod_rec_price (*) = rsp -> rate_structure.iod_rec_price (*);
	rate_structure.nrscp = rsp -> rate_structure.nrscp;
						/* Keep resources in order and position. */
	rate_structure.resource (*).name = rsp -> rate_structure.resource (*).name;
	rate_structure.resource (*).price = rsp -> rate_structure.resource (*).price;
	go to main;
%page;

/*  OPERATION SUPERVISOR */

do_any:
     procedure (OP);

dcl  OP fixed bin;
dcl  IX fixed bin;
dcl  i fixed bin;
dcl  seq_ptr ptr;
dcl  seq_size fixed bin;
dcl  sequence (seq_size) fixed bin based (seq_ptr);

/* This internal procedure calls the correct processor for OP */

worker:
	procedure (IX);				/* dispatch */
						/* keep everything pl1-quick */
dcl  IX fixed bin;

	     did_something = "1"b;			/* assume the best */
	     suppress_nl = "0"b;			/* ditto */
	     if OP = ADD then call do_add (IX);
	     else if OP = CHANGE then call do_change (IX);
	     else if OP = PRINT then call do_print (IX);
	     else if OP = RETYPE then call do_retype (IX);
	     return;

	end worker;


/* BEGIN do_any */

	if OP = ADD then do;			/* get a nice long name for request */
	     print_comm = "add";
	end;
	else if OP = CHANGE then do;
	     print_comm = "change";
	     change_request = "1"b;			/* this really is change, not retype */
	end;
	else if OP = PRINT then do;
	     print_comm = "print";
	end;
	else if OP = RETYPE then do;
	     print_comm = "retype";
	end;
	else do;
	     call com_err_ (0, me, "Internal error. Argument to ""do_any"" is ^d.", OP);
	     return;
	end;

	call ask_ ("id  ", char32);			/* OP on what? */
	keywx = checkid (char32, COMPLAIN);		/* is it legit? */
	if keywx < 0 then go to main1;		/* something was wrong */

do_any_common:
	if keywx = 1 | keywx = 15 | keywx = 51 then do;	/* ALL, ABS_QUEUE_PARAMETERS, RATES */
	     if keywx = 1 then do;			/* all */
		if edit_rs then go to do_rates;	/* simulate 'rates ' */
		all_rates_sw = "1"b;		/* all => rates */
		all_abs_queue_sw = "1"b;		/* all => abs_queue_parameters */
		all_sw = "1"b;			/* indicate 'all' */
		seq_ptr = addr (sequence_ALL);	/* where is the sequence array? */
		seq_size = hbound (sequence_ALL, 1);	/* and how big? */
	     end;
	     else if keywx = 15 then do;		/* abs_queue_parameters */
		all_abs_queue_sw = "1"b;		/* indicate 'abs_queue_parameters' */
		seq_ptr = addr (sequence_ABS_Q);	/* pointer to sequence array */
		seq_size = hbound (sequence_ABS_Q, 1);	/* size thereof */
	     end;
	     else if keywx = 51 then do;		/* rates */
do_rates:
		all_rates_sw = "1"b;		/* indicate all rates */
		seq_ptr = addr (sequence_RATES);	/* pointer to sequence array */
		seq_size = hbound (sequence_RATES, 1);	/* size thereof */
	     end;

	     do i = 1 to seq_size;			/* NOW, do each sub-request */
		call worker (sequence (i));		/* appropriate processor for OP */
		if ^suppress_nl & did_something then call ioa_ ("");
						/* blank line, if required */
	     end;
	end;
	else if keywx = 55 then do;
	     all_structures_sw = "1"b;		/* indicate 'all_structures' */
	     all_sw = "1"b;				/* => all */
	     all_rates_sw = "1"b;			/* => rates */
	     all_abs_queue_sw = "1"b;			/* => abs_queue_parameters */
	     do i = 0 to installation_parms.nrates;	/* now, for each rate_structure */
		cur_rs_ptr = rs_ptrs (i);		/* setup pointer ro RS */
		edit_rs = (cur_rs_ptr ^= ip);		/* flag if not IP */
		call do_any$$given_index (OP, 1);	/* 'all' for this rate_structure */
	     end;
	     cur_rs_ptr = selected_rs_ptr;		/* back to whatever it was */
	     edit_rs = (cur_rs_ptr ^= ip);
	end;
	else do;
	     call worker (keywx);			/* run-of-the-mill */
	end;

	return;

do_any$$given_index:
     entry (OP, IX);				/* alternate entry - have index already */

	keywx = IX;
	go to do_any_common;

     end do_any;
%page;

/* PROCESS SINGLE ADD REQUEST */

do_add:
     procedure (IX);

dcl  IX fixed bin;

dcl  (i, j) fixed bin;
dcl  devnm char (8);
dcl  rscnm char (32);

	if IX < lbound (add, 1) | IX > hbound (add, 1) then do;
	     call com_err_ (0, me, "Internal error. do_add index ^d.", IX);
	     return;
	end;

	go to add (IX);

add (1):						/* all */
add (2):						/* installation_id */
add (3):						/* shift_table */
add (4):						/* prices */
add (5):						/* titles */
add (6):						/* level_names */
add (7):						/* inactive_time */
add (8):						/* warning_time */
add (9):						/* login_time */
add (10):						/* tries */
add (11):						/* update_time */
add (14):						/* queue_prices */
add (15):						/* abs_queue_parameters */
add (16):						/* category_names */
add (17):						/* access_ceiling */
add (18):						/* log_parameters */
add (19):						/* trusted_path_login */
add (23):						/* resource_wait_time */
add (24):						/* fpe_time */
add (25):						/* fpe_count */
add (26):						/* trm_real_time */
add (27):						/* trm_cpu_time */
add (28):						/* unload_on_detach */
add (29):						/* authentication_level */
add (30):						/* default_pdir_seg_quota */
add (56):						/* default_pdir_dir_quota */
add (31):						/* rsc_mgmt_enabled */
add (32):						/* auto_registration */
add (33):						/* enable_ss_volume_mount */
add (34):						/* foreground_queue_position */
add (35):						/* idle_time_constant */
add (36):						/* sus_cpu_time */
add (37):						/* sus_real_time */
add (38):						/* max_abs */
add (39):						/* min_abs */
add (40):						/* pct_abs */
add (41):						/* max_qres */
add (42):						/* min_qres */
add (43):						/* pct_qres */
add (44):						/* abs_cpu_max_limit */
add (45):						/* abs_timax */
add (46):						/* abs_cpu_default_limit */
add (47):						/* foreground_cpu_default_limit */
add (48):						/* abs_default_queue */
add (49):						/* cwe_time */
add (50):						/* cwe_count */
add (51):						/* rates */
add (55):						/* all_structures */
add (57):						/* require_operator_login */
add (58):						/* operator_inactive */
add (59):						/* validate_daemon_commands */
add (60):						/* password_min_length */
add (61):						/* password_gpw_length */
add (62):						/* password_change_interval */
add (63):						/* password_expiration_interval */
add (64):						/* vchn_requires_accept */

	call ioa_ ("""add ^a"" is not allowed.  Try ""retype"".", idt (keywx));
	go to main1;

add (12):						/* device_prices */
	go to add (52);

add (13):						/* config table */
	if installation_parms.ncon = 51 then do;
	     call ioa_ ("config table full");
	     call ask_$ask_clr ();
	     return;
	end;
	i = installation_parms.ncon + 1;
	call input_config_element (i);
	if installation_parms.cona (i).cpu > 0 then installation_parms.ncon = i;
	call sort_config_table;
	return;

add (20):						/* device_names */
	go to add (52);

add (21):						/* resource_prices */
add (22):						/* resource_names */
	go to add (53);

add (52):						/* devices */
	if edit_rs then go to cant_add_rs;
	if installation_parms.ndevices = 16 then do;
	     call ioa_ ("device table full");
	     call ask_$ask_clr ();
	     return;
	end;
add52a:
	call ask_ ("device^-", devnm);
	j = devtab$$undefined (devnm, NO_SPECIAL_DEVICES, COMPLAIN);
						/* best not exist */
	if j >= 0 then go to add52a;			/* oh dear, it does */
	call input_device_price (installation_parms.ndevices + 1, devnm, ALL_RS, SET_HI);
	return;

add (53):						/* resources */
	if edit_rs then go to cant_add_rs;
	call ask_ ("resource^-", rscnm);
	j = rsctab$$undefined (rscnm, COMPLAIN);	/* best not exist */
	if j >= 0 then go to add (53);		/* horrors! it does */
	call input_resource_price (installation_parms.nrscp + 1, rscnm, ALL_RS, SET_HI);
	return;

add (54):						/* rate_structure_name */
	if edit_rs then go to cant_add_rs;
	if installation_parms.nrates >= hbound (installation_parms.rate_structures, 1) then do;
	     call ioa_ ("An attempt to add more than ^n rate structures has been made and ignored.",
		hbound (installation_parms.rate_structures, 1));
	     go to main1;
	end;
	j = installation_parms.nrates + 1;
add54a:
	call ask_ ("new rate_structure name  ", rscnm);
	i = rstab$$undefined (rscnm, COMPLAIN);		/* ensure no such RS already */
	if i >= 0 then go to add54a;			/* oh dear - try again */

	en = "rate_structure_" || ltrim (char (j));	/* make the live segment */
	call hcs_$make_seg (dn, en, "", RW_ACCESS_BIN, rsp1, ec);
	if rsp1 = null then do;
	     call write_error (ec, j, dnvar || rtrim (en));
	     return;
	end;
	call hcs_$set_ring_brackets (dn, en, ip_rings, ec);
						/* make sure it's accessible to ring 5 */
	if ec ^= 0 then call com_err_ (ec, me, "Setting ring brackets of ^a.", en);
	call hcs_$make_seg ("", "", "", RW_ACCESS_BIN, rsp, ec);
						/* make the temp copy */
	if rsp = null then do;
	     call write_error (ec, j, "temporary segment");
	     return;
	end;

	critical_op = "1"b;				/* critical while we setup the RS */
	rs_ptrs1 (j) = rsp1;
	rs_ptrs (j) = rsp;

/* make new RS look like all the rest, with 0.0 prices */
	rsp -> rate_structure.rate_structure_number = j;	/* unique */
	rsp -> rate_structure.rate_structures (*) = installation_parms.rate_structures (*);
	rsp -> rate_structure.cpu_price (*) = 0e0;
	rsp -> rate_structure.log_base_price (*) = 0e0;
	rsp -> rate_structure.io_ops_price (*) = 0e0;
	rsp -> rate_structure.core_price (*) = 0e0;
	rsp -> rate_structure.disk_price = 0e0;
	rsp -> rate_structure.registration_price = 0e0;
	rsp -> rate_structure.dolsign = "$";
	rsp -> rate_structure.ndevices = installation_parms.ndevices;
	rsp -> rate_structure.devtab (*).device_id = installation_parms.devtab (*).device_id;
	rsp -> rate_structure.devtab (*).device_price (*) = 0e0;
	rsp -> rate_structure.abs_cpu_price (*) = 0e0;
	rsp -> rate_structure.abs_mem_price (*) = 0e0;
	rsp -> rate_structure.iod_rec_price (*) = 0e0;
	rsp -> rate_structure.nrscp = installation_parms.nrscp;
	rsp -> rate_structure.resource (*).name = installation_parms.resource (*).name;
	rsp -> rate_structure.resource (*).price = 0e0;

	do i = j to 0 by -1;			/* add new rate_structure to all structures */
	     rs_ptrs (i) -> rate_structure.nrates = j;
	     rs_ptrs (i) -> rate_structure.rate_structures (j) = rscnm;
	end;

	critical_op = "0"b;
	call ioa_ ("rate_structure ""^a"" defined.  All prices are 0.0.", rscnm);
	return;

cant_add_rs:
	call ioa_ ("""^a ^a"" is not allowed while editing a rate_structure.", print_comm, idt (IX));
	go to main1;

     end do_add;
%page;

/* PROCESS SINGLE CHANGE REQUEST */

do_change:
     procedure (IX);

dcl  IX fixed bin;

dcl  (i, i1, i2, i3, i4, j, k, n) fixed bin;
dcl  rscnm char (32);
dcl  devnm char (8);

	if IX < lbound (change, 1) | IX > hbound (change, 1) then do;
	     call com_err_ (0, me, "Internal error. do_change index ^d.", IX);
	     return;
	end;

	go to change (IX);

change (2):					/* installation_id */
change (5):					/* titles */
change (7):					/* inactive_time */
change (8):					/* warning_time */
change (9):					/* login_time */
change (10):					/* tries */
change (11):					/* update_time */
change (15):					/* abs_queue_parameters */
change (17):					/* access_ceiling */
change (18):					/* log_parameters */
change (19):					/* trusted_path_login */
change (23):					/* rsctime */
change (24):					/* fpetime */
change (25):					/* fpecount */
change (26):					/* trmrealtime */
change (27):					/* trmcputime */
change (28):					/* unload_on_detach */
change (29):					/* authentication_level */
change (30):					/* default_pdir_seg_quota */
change (56):					/* default_pdir_dir_quota */
change (31):					/* rsc_mgmt_enabled */
change (32):					/* auto_registration */
change (33):					/* enable_ss_volume_mount */
change (34):					/* foreground_queue_position */
change (35):					/* idle_time_constant */
change (36):					/* sus_cpu_time */
change (37):					/* sus_real_time */
change (38):					/* max_abs */
change (39):					/* min_abs */
change (40):					/* pct_abs */
change (41):					/* max_qres */
change (42):					/* min_qres */
change (43):					/* pct_qres */
change (44):					/* abs_cpu_max_limit */
change (45):					/* abs_timax */
change (46):					/* abs_cpu_default_limits */
change (47):					/* foreground_cpu_default_limit */
change (48):					/* abs_default_queue */
change (49):					/* cwe_time */
change (50):					/* cwe_count */
change (51):					/* rates */
change (57):					/* require_operator_login */
change (58):					/* operator_inactive */
change (59):					/* validate_daemon_commands */
change (60):					/* password_min_length */
change (61):					/* password_gpw_length */
change (62):					/* password_change_interval */
change (63):					/* password_expiration_interval */
change (64):					/* vchn_requires_accept */

	call do_retype (IX);
	return;

change (1):					/* all */
	go to cant_change;

change (3):					/* shift table */
	call ask_ ("day^-", char8);
	i = index (daynam, substr (char8, 1, 3)) - 1;
	if i < 0 then do;
badday:
	     call ioa_ ("^a illegal day", char8);
	     call ask_$ask_clr ();
	     go to change (3);
	end;
	i = divide (i, 3, 17, 0);
badhour:
	call set_half_al ("hour", "", j, 0, 23);
badhalf:
	call ask_$ask_int ("half^-", n);
	if n = 30 then n = 1;
	else if n ^= 0 & n ^= 1 then do;
	     call ioa_ ("illegal half hour ^d. Must be 0 for the hour and 1 or 30 for the half.", n);
	     call ask_$ask_clr ();
	     go to badhalf;
	end;
	call ask_$ask_n (char8, i1);			/* check for type ahead */
	if i1 ^= 0 & char8 = "thru" then do;		/* if "thru" typed ahead */
	     call ask_ ("", char8);			/* get it off the input line */
	     call ask_ ("thru day^-", char8);
	     i2 = divide (index (daynam, substr (char8, 1, 3)) - 1, 3, 17, 0);
	     if i2 < 0 then go to badday;
	     call ask_$ask_int ("thru hour^-", i3);	/* i3 = hour = final value of j */
	     if i3 < 0 | i3 > 23 then go to badhour;
	     call ask_$ask_int ("thru half^-", i4);	/* i4 = half = final value of n */
	     if i4 > 0 then
		i4 = 1;
	     else i4 = 0;
	end;
	else i1 = 0;				/* remember that thru was not given */

	call set_half_al ("shift", "", k, 0, 7);
	call set_shift_field (i, j, k, n);

	if i1 ^= 0 then				/* if "thru" was given */
	     do while (i ^= i2 | j ^= i3 | n ^= i4);	/* set shifts til we reach the thru time */
	     n = n + 1;				/* advance half hour */
	     if n = 2 then do;			/* if next hour */
		n = 0;
		j = j + 1;			/* advance hour */
		if j = 24 then do;			/* if end of day */
		     j = 0;
		     i = i + 1;			/* advance day */
		     if i = 7 then			/* if end of week */
			i = 0;
		end;
	     end;
	     call set_shift_field (i, j, k, n);
	end;
	return;

change (4):					/* prices */
	call set_half_al ("shift", "", k, 0, 7);
	call ask_$ask_flo ("cpu^-", rate_structure.cpu_price (k));
	call ask_$ask_flo ("log^-", rate_structure.log_base_price (k));
	call ask_$ask_flo ("mem^-", rate_structure.core_price (k));
	call ask_$ask_flo ("io ops^-", rate_structure.io_ops_price (k));
	return;

change (6):					/* sensitivity level names */
	call set_half_al ("level", "", i, lbound (installation_parms.level_names, 1),
	     hbound (installation_parms.level_names, 1));
	call enter_level_name (i);
	return;

change (12):					/* device prices */
	call ask_ ("device^-", devnm);
	i = devtab$$defined (devnm, SPECIAL_DEVICES_OK, COMPLAIN);
						/* find that device */
	if i < 0 then go to change (12);		/* I beg your pardon */
	call input_device_price (i, devnm, THIS_RS, NO_SET_HI);
	return;

change (13):					/* config table */
	do while ("1"b);
	     call ask_$ask_int ("ncpu  ", i1);
	     call ask_$ask_int ("nmem  ", i2);
	     call ask_$ask_int ("bulk  ", i3);
	     call ask_$ask_int ("shift ", i4);
	     do i = 1 to installation_parms.ncon;
		if installation_parms.cona.cpu (i) = i1 then
		     if installation_parms.cona.kmem (i) = i2 then
			if installation_parms.cona.kbulk (i) = i3 then
			     if installation_parms.cona.shift (i) = i4 then do;
				call print_config_element (i);
				call input_config_element (i);
				call sort_config_table;
				return;
			     end;
	     end;
	     call ioa_ ("config ^d ^d ^d ^d not found", i1, i2, i3, i4);
	     call ask_$ask_clr ();
	end;

change (14):					/* queue prices */
	call set_half_al ("queue", "", i, 1, 4);
	call ask_$ask_flo ("abs CPU ^d^-", rate_structure.abs_cpu_price (i), i);
	call ask_$ask_flo ("abs mem ^d^-", rate_structure.abs_mem_price (i), i);
	call ask_$ask_flo ("iod records ^d^-", rate_structure.iod_rec_price (i), i);
	return;

change (16):					/* category names */
	call set_half_al ("category", "", i, lbound (installation_parms.category_names, 1),
	     hbound (installation_parms.category_names, 1));
	call enter_category_name (i);
	return;

change (20):					/* device name */
	if edit_rs then go to cant_change_rs;
	call ask_ ("device^-", devnm);
	i = devtab$$defined (devnm, NO_SPECIAL_DEVICES, COMPLAIN);
						/* find it in devtab */
	if i < 0 then go to change (20);		/* couldn't find it */
ch20a:
	call ask_ ("new device name^-", devnm);
	if devnm = installation_parms.device_id (i) then do;
	     k = devtab$$undefined (devnm, NO_SPECIAL_DEVICES, COMPLAIN);
						/* new name must not exist */
	     if k >= 0 then go to ch20a;		/* try again */
	end;
	k = installation_parms.ndevices;
	if devnm = "dev" || ltrim (char (i)) & i = k then k = k - 1;
	critical_op = "1"b;
	do j = installation_parms.nrates to 0 by -1;	/* All rate structures must have the same devices */
	     rs_ptrs (j) -> rate_structure.ndevices = k;
	     rs_ptrs (j) -> rate_structure.device_id (i) = devnm;
	end;
	critical_op = "0"b;
	return;

change (21):					/* resource_prices */
	call ask_ ("resource^-", rscnm);
	i = rsctab$$defined (rscnm, COMPLAIN);		/* find resource */
	if i < 0 then go to change (21);		/* couldn't */
	call input_resource_price (i, rscnm, THIS_RS, NO_SET_HI);
	return;

change (22):					/* rscname */
	if edit_rs then go to cant_change_rs;
	call ask_ ("resource^-", rscnm);
	i = rsctab$$defined (rscnm, COMPLAIN);		/* find resource */
	if i < 0 then go to change (22);		/* not present */
	call ask_ ("new resource name^-", rscnm);
ch22a:
	if rscnm ^= installation_parms.resource (i).name then do;
	     j = rsctab$$undefined (rscnm, COMPLAIN);	/* look out for duplicates */
	     if j >= 0 then go to ch22a;		/* try for another name */
	end;
	critical_op = "1"b;
	do j = installation_parms.nrates to 0 by -1;
	     rs_ptrs (j) -> rate_structure.resource (i).name = rscnm;
	end;
	critical_op = "0"b;
	return;

change (52):					/* devices */
	go to change (12);

change (53):					/* resources */
	go to change (21);

change (54):					/* rate_structure_name */
	if edit_rs then go to cant_change_rs;
	call ask_ ("rate_structure^-", rscnm);
	i = rstab$$defined (rscnm, COMPLAIN);		/* find the RS */
	if i < 0 then go to change (54);		/* doesn't exist */
ch54a:
	call ask_ ("new rate_structure name^-", rscnm);
	if rscnm ^= installation_parms.rate_structures (i) then do;
	     j = rstab$$undefined (rscnm, COMPLAIN);	/* look out for duplicate names */
	     if j >= 0 then go to ch54a;		/* oh dear - found duplicate */
	end;
	critical_op = "1"b;
	do j = installation_parms.nrates to 0 by -1;
	     rs_ptrs (j) -> rate_structure.rate_structures (i) = rscnm;
	end;
	critical_op = "0"b;
	return;

change (55):					/* all_structures */
	go to cant_change;

changed_nothing:
	did_something = "0"b;
	return;

cant_change:
	call ioa_ ("""^a ^a"" is not allowed.", print_comm, idt (IX));
	go to main1;

cant_change_rs:
	call ioa_ ("""^a ^a"" is not allowed while editing a rate_structure.", print_comm, idt (IX));
	go to main1;

     end do_change;
%page;

/* PROCESS SINGLE PRINT REQUEST */

do_print:
     procedure (IX);

dcl  IX fixed bin;

dcl  (i, j, k, m, n) fixed bin;
dcl  c15 char (15);
dcl  char48 char (48);
dcl  no_charge bit (1) aligned;
dcl  (dflt, mx, tmx) bit (1) aligned;
dcl  rscnm char (32);
dcl  devnm char (8);
dcl  pass_sw bit (1) aligned;

	if IX < lbound (print, 1) | IX > hbound (print, 1) then do;
	     call com_err_ (0, me, "Internal error. do_print index ^d.", IX);
	     return;
	end;

	go to print (IX);

print (1):					/* all */
	call ioa_ ("^/^-Installation parameters^/");
	return;

print (2):					/* installation_id */
	call ioa_ ("Installation id:^-^a", installation_parms.installation_id);
	return;

print (3):					/* shift_table */
	call ioa_ ("^4xM^15x8^7xN^11x6");
	do i = 0 to 6;
	     char48 = "";
	     m = 1;
	     do j = 0 to 23;
		do n = 0 to 1;
		     k = fixed (installation_parms.shifttab (48 * i + 2 * j + n + 1), 3);
		     substr (char48, m, 1) = ltrim (char (k));
		     m = m + 1;
		end;
	     end;
	     call ioa_ ("^a ^a", substr (daynam, 3 * i + 1, 3), char48);
	end;
	return;

print (4):					/* prices */
	call ioa_ ("disk price:^-$^f/page-second, $^f/page-30-days", rate_structure.disk_price,
	     rate_structure.disk_price * SECONDS_PER_MONTH);
	call ioa_ ("registration fee:^-^a/user^/", cv_$mwvf (rate_structure.registration_price));
	call ioa_ ("Shift^13xcpu^13xlog^13xmem^10xio ops");
	do i = 0 to 7;
	     if rate_structure.cpu_price (i) + rate_structure.log_base_price (i) + rate_structure.io_ops_price (i)
		+ rate_structure.core_price (i) > 0.0e0 then
		call ioa_ ("^4x^1d ^15a ^15a ^15a ^15a", i, cv_$mwvf (rate_structure.cpu_price (i)),
		     cv_$mwvf (rate_structure.log_base_price (i)), cv_$mwvf (rate_structure.core_price (i)),
		     cv_$mwvf (rate_structure.io_ops_price (i)));
	end;
	return;

print (5):					/* titles */
	call ioa_ ("Company:^-^-^a", installation_parms.company);
	call ioa_ ("Department:^-^a", installation_parms.department);
	call ioa_ ("Companyds:^-^a", installation_parms.companyds);
	call ioa_ ("Departmentds:^-^a", installation_parms.departmentds);
	return;

print (6):					/* level_names */
	call ioa_ ("Level    Short Name    Name");
	do i = lbound (installation_parms.level_names (*), 1) to hbound (installation_parms.level_names (*), 1);
	     call ioa_ ("^3d^6x^8a^6x^a", i, installation_parms.short_level_names (i),
		installation_parms.level_names (i));
	end;
	return;

print (7):					/* inactive_time */
	call ioa_ ("inactive_time:^-^d sec.", installation_parms.inactive_time);
	suppress_nl = "1"b;				/* tight output */
	return;

print (58):
	call ioa_ ("operator_inactive_time:^-^d sec.", installation_parms.operator_inactive_time);
	suppress_nl = "1"b;				/* tight output */
	return;

print (8):					/* warning_time */
	call ioa_ ("warning_time:^-^d sec.", installation_parms.warning_time);
	suppress_nl = "1"b;				/* tight output */
	return;

print (9):					/* login_time */
	call ioa_ ("login_time:^-^d sec.", installation_parms.login_time);
	suppress_nl = "1"b;				/* tight output */
	return;

print (10):					/* tries */
	call ioa_ ("tries:^2-^d", installation_parms.login_tries);
	suppress_nl = "1"b;
	return;

print (11):					/* update_time */
	call ioa_ ("acct_update:^-^d sec.", installation_parms.acct_update);
	return;

print (12):					/* device_prices */
	go to print (52);				/* devices */

print (13):					/* config_table */
	call ioa_ ("  cpu   mem  bulk shift     min     max    base   abs  absq");
	do i = 1 to installation_parms.ncon;
	     call print_config_element (i);
	end;
	return;

print (14):					/* queue_prices */
	call ioa_ ("Queue  Abs CPU  Abs mem   IO recs");
	do i = 1 to 4;
	     call ioa_ ("  ^1d   ^8.2f  ^8.2f ^8.2f", i, rate_structure.abs_cpu_price (i),
		rate_structure.abs_mem_price (i), rate_structure.iod_rec_price (i));
	end;
	return;

print (15):					/* abs_queue_parameters */
	tmx, dflt, mx = "1"b;			/* print all 3 parameters */
	go to print_abs_queue_parameters;

print (16):					/* category_names */
	call ioa_ ("Category Short Name    Name");
	do i = lbound (installation_parms.category_names (*), 1) to hbound (installation_parms.category_names (*), 1);
	     call ioa_ ("^3d^6x^8a^6x^a", i, installation_parms.short_category_names (i),
		installation_parms.category_names (i));
	end;
	return;

print (17):					/* access_ceiling */
	call ioa_ ("Access ceiling:^-level = ^d, categories = ^6.3b",
						/* N.B. Format depends on number of categories */
	     addr (installation_parms.access_authorization_ceiling) -> aim_template.level,
	     addr (installation_parms.access_authorization_ceiling) -> aim_template.categories);
	return;

print (18):					/* log_parameters */
	if installation_parms.syserr_log_copy_threshold = -1 then call ioa_ ("Syserr log copying disabled.");
	else if installation_parms.syserr_log_copy_threshold = 0 then
	     call ioa_ ("Syserr log copying threshold is using default value.");
	else call ioa_ ("Syserr log copying threshold: ^d pages", installation_parms.syserr_log_copy_threshold);
	return;

print (19):					/* trusted_path_login */
	call ioa_ ("trusted_path_login: ^[yes^;no^]. Terminal disconnection is^[ not^] required to change authorization.", installation_parms.trusted_path_login, ^installation_parms.trusted_path_login);
	return;

print (57):
	call ioa_ ("require_operator_login: ^[yes^;no^]. Operators are^[ not^] required to sign on before entering commands.", installation_parms.require_operator_login, ^installation_parms.require_operator_login);
	return;

print (59):
	call ioa_ ("validate_daemon_commands: ^[yes^;no^]. Access to .mcacs segments is^[ not^] required to reply, quit, login, logout, or new_proc daemons.", installation_parms.validate_daemon_commands, ^installation_parms.validate_daemon_commands);
	return;

print (60):
	call ioa_ ("password_min_length: ^[no minimum length^s^;^d^].",
	     (installation_parms.password_min_length = 0),
	     installation_parms.password_min_length);
	return;
print (61):
	call ioa_ ("password_gpw_length: ^d.",
	     installation_parms.password_gpw_length);
	return;
print (62):
	call ioa_ ("password_change_interval: ^[no enforced interval^s^;^d days^].",
	     (installation_parms.password_change_interval = 0),
	     installation_parms.password_change_interval);
	return;
print (63):
	call ioa_ ("password_expiration_interval: ^[no enforced interval^s^;^d days^].",
	     (installation_parms.password_expiration_interval = 0),
	     installation_parms.password_expiration_interval);
	return;
print (64):
	call ioa_ ("vchn_requires_accept: ^[yes^;no^]. virtual channel MC attachments do^[ not^] require ""accept""",
	     installation_parms.vchn_requires_accept, ^installation_parms.vchn_requires_accept);
	return;
print (20):					/* devname */
	if all_rates_sw then go to printed_nothing;	/* device_prices will do it */
	do i = 1 to rate_structure.ndevices;
	     call ioa_ ("^2d)^2x^8a", i, rate_structure.device_id (i));
	end;
	return;

print (21):					/* resource_prices */
	go to print (53);				/* resources */

print (22):					/* rscname */
	if all_rates_sw then go to printed_nothing;	/* resource_prices will do it */
	pass_sw = "1"b;
	do i = 1 to rate_structure.nrscp;
	     if rate_structure.resource (i).price >= 0 then do;
		pass_sw = "0"b;
		call ioa_ ("^3d)^2x^a", i, rate_structure.resource (i).name);
	     end;
	end;
	if pass_sw then call ioa_ ("no resources defined");
	return;

print (23):					/* rsctime */
	call ioa_ ("resource wait time: ^d sec.", installation_parms.rsc_timer_seconds);
	return;


print (24):					/* fpetime */
	call ioa_ ("fatal error loop time: ^d sec.", installation_parms.fatal_error_loop_seconds);
	return;


print (25):					/* fpecount */
	call ioa_ ("fatal error loop count: ^d", installation_parms.fatal_error_loop_count);
	return;

print (26):					/* trmrealtime */
	call ioa_ ("trm_ real time limit: ^d sec.", installation_parms.term_real_time_seconds);
	return;

print (27):					/* trmcputime */
	call ioa_ ("trm_ cpu time limit: ^d sec.", installation_parms.term_cpu_time_seconds);
	return;

print (28):					/* unload_on_detach */
	call ioa_ ("^a:^-^[on^;off^]", idt (28), installation_parms.rcp_init_flags.unload_on_detach);
	return;

print (29):					/* authentication_level */
	call ioa_ ("^a:^-^a", idt (29),
	     authentication_level_names (installation_parms.rcp_init_flags.authentication_level));
	return;

print (30):					/* default_pdir_seg_quota */
	call ioa_ ("^a:^-^d", idt (30), installation_parms.default_pdir_seg_quota);
	return;

print (56):					/* default_pdir_dir_quota */
	call ioa_ ("^a:^-^d", idt (56), installation_parms.default_pdir_dir_quota);
	return;

print (31):					/* rsc_mgmt_enabled */
	call ioa_ ("^a:^-^[on^;off^]", idt (31), installation_parms.rcp_init_flags.resource_mgmt_enabled);
	return;

print (32):					/* auto_registration */
	call ioa_ ("^a:^-^[on^;off^]", idt (32), installation_parms.rcp_init_flags.auto_registration);
	return;

print (33):					/* enable_ss_volume_mount */
						/* COMMENT OUT UNTIL rcp_init_flags.incl.pl1 is modified:
						   call ioa_ ("^a:^-^[on^;off^],idt(33),installation_parms.rcp_init_flags.enable_ss_volume_mount);
						   /* END COMMENT OUT */
	go to printed_nothing;

print (34):					/* foreground_queue_position */
	call print_halfword (idt (34), installation_parms.foreground_queue_position);
	return;

print (35):					/* idle_time_constant */
	call print_halfword (idt (35), installation_parms.idle_time_constant_seconds);
	return;

print (36):					/* sus_cpu_time */
	call ioa_ ("^a: ^d sec.", idt (36), installation_parms.sus_cpu_time_seconds);
	return;

print (37):					/* sus_real_time */
	call ioa_ ("^a: ^d sec.", idt (37), installation_parms.sus_real_time_seconds);
	return;

print (38):					/* max_abs */
	call print_sval (idt (38), installation_parms.max_abs);
	return;

print (39):					/* min_abs */
	call print_sval (idt (39), installation_parms.min_abs);
	return;

print (40):					/* pct_abs */
	call print_sval (idt (40), installation_parms.pct_abs);
	return;

print (41):					/* max_qres */
	call print_sqval (idt (41), installation_parms.max_qres);
	return;

print (42):					/* min_qres */
	call print_sqval (idt (42), installation_parms.min_qres);
	return;

print (43):					/* abs_cpu_default_limit */
	call print_sqval (idt (43), installation_parms.pct_qres);
	return;

print (44):					/* abs_cpu_max_limit */
	if all_abs_queue_sw then go to printed_nothing;
	mx = "1"b;
	tmx, dflt = ""b;
	go to print_abs_queue_parameters;

print (45):					/* abs_timax */
	if all_abs_queue_sw then go to printed_nothing;
	tmx = "1"b;
	mx, dflt = ""b;
	go to print_abs_queue_parameters;

print (46):					/* abs_cpu_default_limit */
	if all_abs_queue_sw then go to printed_nothing;
	dflt = "1"b;
	mx, tmx = ""b;
	go to print_abs_queue_parameters;

print_abs_queue_parameters:				/* Print lines of the following form:
						   Q TIMAX DEFAULT PER-SHIFT MAX CPU TIME LIMITS
						   -         LIMIT  0   1   2   3   4   5   6   7
						   1 timax    dflt mx0 mx1 mx2 mx3 mx4 mx5 mx6 mx7
						*/
	call ioa_ ("Q^[^xABS-TIMAX^]^[^xDEFAULT^]^[^xPER-SHIFT MAX CPU TIME LIMITS^]", tmx, dflt, mx);
	if (dflt | mx) then call ioa_ ("^x^[^10x^]^[^3xLIMIT^]^[^x^6x0^6x1^6x2^6x3^6x4^6x5^6x6^6x7^]", tmx, dflt, mx);
	do i = 1 to 4;
	     call ioa_ ("^d^[^x^9d^;^s^]^[^x^7d^;^s^]^[^x^8(^x^6d^)^]", i, tmx, installation_parms.abs_timax (i), dflt,
		installation_parms.abs_cpu_default_limit (i), mx, installation_parms.abs_cpu_max_limit (*, i));
	end;
	return;

print (47):					/* foreground_cpu_default_limit */
	call ioa_ ("foreground default cpu limit: ^d sec.", installation_parms.foreground_cpu_default_limit);
	return;

print (48):					/* abs_default_queue */
	call print_halfword (idt (48), installation_parms.default_absentee_queue);
	return;

print (49):					/* cwe_time */
	call ioa_ ("^a:^21t^d sec.", idt (49), installation_parms.chn_wakeup_error_loop_seconds);
	suppress_nl = "1"b;				/* tight output */
	return;

print (50):					/* cwe_count */
	call ioa_ ("^a:^21t^d", idt (50), installation_parms.chn_wakeup_error_loop_count);
	suppress_nl = "1"b;				/* tight output */
	return;

print (51):					/* rates */
	call ioa_ ("^/^-rate_structure ""^a""^/", ptr_rs_name (cur_rs_ptr));
	return;

print (52):					/* devices */
	k = 0;
	if ^all_rates_sw then call ask_$ask_n (devnm, k); /* look ahead on line for device name */
	if k ^= 0 then do;				/* if something is there */
	     m, n = devtab$$defined (devnm, SPECIAL_DEVICES_OK, COMPLAIN);
						/* find the device */
	     if m < 0 then go to print (52);		/* sorry, chum */
	     call ask_ ("", char8);			/* clear it off the input line */
	end;
	else do;
	     if ^check_device_names () then		/* check for missing ones, and if we complained about any */
		call ioa_ ("");			/* skip a line */
	     m = 1;
	     n = installation_parms.ndevices;
	end;

	do i = m to n;
	     call ioa_ ("device:^-^a", rate_structure.device_id (i));
	     no_charge = "1"b;			/* check for zero prices on all shifts */
	     do j = 0 to 7;
		if rate_structure.device_price (i, j) > 0.0e0 then do;
		     call ioa_ ("^-shift ^d ^15a/hr", j, cv_$mwvf (rate_structure.device_price (i, j)));
		     no_charge = ""b;		/* at least one shift has nonzero price */
		end;
	     end;
	     if no_charge then call ioa_ ("^2-^7xno charge");
	end;
	return;

print (53):					/* resources */
	k = 0;
	if ^all_rates_sw then call ask_$ask_n (rscnm, k); /* look ahead for a resource name */
	if k ^= 0 then do;				/* if something is there */
	     j, k = rsctab$$defined (rscnm, COMPLAIN);	/* find the resource */
	     if j < 0 then go to print (53);
	     call ask_ ("", char32);			/* it was; remove it from the input line */
	end;
	else do;
	     j = 1;				/* print them all */
	     k = rate_structure.nrscp;
	end;

	pass_sw = "1"b;
	do i = j to k;
	     if rate_structure.resource (i).price >= 0 then do;
		c15 = cv_$mwvf (rate_structure.resource (i).price);
						/* format price */
		if length (ltrim (c15)) < 8 then
		     c15 = substr (c15, 8, 8);	/* right-adjust price in 8 column field */
		else c15 = ltrim (c15);		/* but don't throw away any nonblanks */
		if pass_sw then do;
		     pass_sw = "0"b;
		     call ioa_ ("^3xPRICE^xNAME");
		end;
		call ioa_ ("^8a^x^a", c15, rate_structure.resource (i).name);
	     end;
	end;
	if pass_sw then call ioa_ ("no resources defined");
	return;

print (54):					/* rate_structure_name */
	call ioa_ ("Rate_structure names:");
	do i = 0 to installation_parms.nrates;
	     call ioa_ ("^-^a ^[ (current rate_structure)^]", installation_parms.rate_structures (i),
		(cur_rs_ptr = rs_ptrs (i)));
	end;
	return;

print (55):					/* all_structures */
	go to printed_nothing;

printed_nothing:
	did_something = "0"b;
	return;

cant_print:
	call ioa_ ("""^a ^a"" is not allowed.", print_comm, idt (IX));
	go to main1;

cant_print_rs:
	call ioa_ ("""^a ^a"" is not allowed while editing a rate_structure.", print_comm, idt (IX));
	go to main1;

     end do_print;
%page;

/* PROCESS SINGLE RETYPE REQUEST */

do_retype:
     procedure (IX);

dcl  IX fixed bin;

dcl  (i, j, k, n) fixed bin;
dcl  c1 char (1);
dcl  category_set bit (36) aligned;
dcl  rscnm char (32);
dcl  devnm char (8);
dcl  yn char (4);

	if IX < lbound (retype, 1) | IX > hbound (retype, 1) then do;
	     call com_err_ (0, me, "Internal error. do_retype index ^d.", IX);
	     return;
	end;

	go to retype (IX);

retype (1):					/* all */
	call ioa_ ("^/Retype installation_parms");
	return;

retype (2):					/* installation_id */
	call ask_$ask_line ("Installation id^-", installation_parms.installation_id);
	return;

retype (3):					/* shift_table */
	call ask_ ("standard shifts?^-", c1);
	if c1 = "y" then do;
	     call set_std_shifttab;
	end;
	else do;
	     call ioa_ ("Each digit specifies the shift for that half-hour. Shifts may be 0-7");
	     do i = 0 to 6;
		do j = 0 to 23;
		     do n = 0 to 1;
badshf:
			call ask_$ask_int ("^a ^2d^2d^-", k, substr (daynam, i * 3 + 1, 3), j, 30 * n);
			if k > 7 | k < 0 then do;
			     call ioa_ ("Shifts must be 0-7");
			     call ask_$ask_clr ();
			     go to badshf;
			end;
			call set_shift_field (i, j, k, n);
		     end;
		end;
	     end;
	end;
	return;

retype (4):					/* prices */
	call get_disk_price (rate_structure.disk_price);
	call ask_$ask_flo ("registration^-", rate_structure.registration_price);
	call ask_$ask_yn ("Do you want to retype CPU, log, mem and io ops prices^-", yn);
	if yn ^= "yes" then return;
	call ioa_ ("Input CPU, log, mem, io ops prices for each shift from 0 to 7");
	do i = 0 to 7;
	     call ask_$ask_flo ("CPU ^d^-", rate_structure.cpu_price (i), i);
	     call ask_$ask_flo ("log ^d^-", rate_structure.log_base_price (i), i);
	     call ask_$ask_flo ("mem ^d^-", rate_structure.core_price (i), i);
	     call ask_$ask_flo ("io ops ^d^-", rate_structure.io_ops_price (i), i);
	end;
	return;

retype (5):					/* titles */
	call ask_$ask_line ("company^-^-", installation_parms.company);
	call ask_$ask_line ("department^-", installation_parms.department);
	call ask_$ask_line ("company (ds)^-", installation_parms.companyds);
	call ask_$ask_line ("department (ds)^-", installation_parms.departmentds);
	return;

retype (6):					/* level_names */
	call ioa_ ("Enter names for ^d security levels.", dimension (installation_parms.level_names (*), 1));

	do i = lbound (installation_parms.level_names (*), 1) to hbound (installation_parms.level_names (*), 1);
	     call enter_level_name (i);
	end;

	return;

retype (7):					/* inactive_time */
	call set_half_al (idt (7), "seconds", installation_parms.inactive_time, 0, NOLIMIT);
	return;

retype (58):					/* inactive_time */
	call set_half_al (idt (58), "seconds", installation_parms.operator_inactive_time, 0, NOLIMIT);
	return;

retype (8):					/* warning_time */
	call set_half_al (idt (8), "seconds", installation_parms.warning_time, 0, NOLIMIT);
	return;

retype (9):					/* login_time */
	call set_half_al (idt (9), "seconds", installation_parms.login_time, 0, NOLIMIT);
	return;

retype (10):					/* tries */
	call set_half_al (idt (10), "", installation_parms.login_tries, 1, NOLIMIT);
	return;

retype (11):					/* update_time */
	call set_half_al ("acct update", "seconds", installation_parms.acct_update, 0, NOLIMIT);
	return;

retype (12):					/* device_prices */
	call ioa_ ("Enter device prices for all shifts");
	do i = 1 to rate_structure.ndevices;
	     call input_device_price (i, (installation_parms.devtab (i).device_id), THIS_RS, NO_SET_HI);
	end;
	return;

retype (13):					/* config_table */
	call ioa_ ("Enter config table");
	do i = 1 to hbound (installation_parms.cona, 1);
	     call input_config_element (i);
	     installation_parms.ncon = i - 1;
	     if installation_parms.cona.cpu (i) = 0 then do;
		call check_config_table;
		return;
	     end;
	end;
	call ioa_ ("config table full");
	call ask_$ask_clr ();
	return;

retype (14):					/* queue_prices */
	call ioa_ ("Enter queue prices");
	do i = 1 to 4;
	     call ask_$ask_flo ("abs CPU ^d^-", rate_structure.abs_cpu_price (i), i);
	     call ask_$ask_flo ("abs mem ^d^-", rate_structure.abs_mem_price (i), i);
	     call ask_$ask_flo ("iod records ^d^-", rate_structure.iod_rec_price (i), i);
	end;
	return;

retype (15):					/* abs_queue_parameters */
	call ioa_ ("Enter abs timax (microseconds) and default and max limits (seconds) for queues 1-4");
	return;

retype (16):					/* category_names */
	call ioa_ ("Enter names for ^d security categories.", dimension (installation_parms.category_names (*), 1));
	do i = lbound (installation_parms.category_names (*), 1) to hbound (installation_parms.category_names (*), 1);
	     call enter_category_name (i);
	end;
	return;

retype (17):					/* access_ceiling */
	call set_half_al ("Maximum sensitivity level", "", i, lbound (installation_parms.level_names, 1),
	     hbound (installation_parms.level_names, 1));

retype_category_set:
	category_set = ""b;
	n = divide (dimension (installation_parms.category_names (*), 1), 3, 17, 0);
	call ask_$ask_line ("Categories in use: (^d octal digits) ", char48, n);
	if verify (substr (char48, 1, n), "01234567") ^= 0 then do;
	     call ioa_ ("Must be ^d octal digits. Retype it.", n);
	     call ask_$ask_clr ();
	     go to retype_category_set;
	end;

	do j = 1 to n;
	     substr (category_set, 3 * j - 2, 3) = bit (fixed (index ("01234567", substr (char48, j, 1)) - 1, 3), 3);
	end;

	addr (installation_parms.access_authorization_ceiling) -> aim_template.level = i;
	addr (installation_parms.access_authorization_ceiling) -> aim_template.categories = category_set;
	string (addr (installation_parms.access_authorization_ceiling) -> aim_template.privileges) = ""b;
	return;

retype (18):					/* log_parameters */
	call ask_$ask_int ("syserr log copying threshold:^-", i);
	if i > 256 | i < -1 then do;
	     call ioa_ ("Threshold must be:  -1 (disable log copying)^/^20x0 (use built-in default)");
	     call ioa_ ("^16x1-256 (max size of log in pages before copying begins)^/Please retype.");
	     call ask_$ask_clr ();
	     go to retype (18);
	end;
	installation_parms.syserr_log_copy_threshold = i;
	return;

retype (19):					/* strict_trusted_path */
	call ask_$ask_yn ("trusted path login:^-", yn);
	installation_parms.trusted_path_login = (yn = "yes");
	return;

retype (57):					/* require_operator_login */
	call ask_$ask_yn ("require operator login:^-", yn);
	installation_parms.require_operator_login = (yn = "yes");
	return;

retype (59):					/* validate_daemon_commands */
	call ask_$ask_yn ("validate daemon commands:^-", yn);
	installation_parms.validate_daemon_commands = (yn = "yes");
	return;

retype (60):					/* password_min_length */
	call set_half_al (idt (60), "", installation_parms.password_min_length,
	     0, 8);
	return;
retype (61):					/* password_gpw_length */
	call set_half_al (idt (61), "", installation_parms.password_gpw_length,
	     1, 8);
	return;
retype (62):					/* password_change_interval */
	call ask_$ask_int ("Password Change Interval (in days):^-", i);
	if i < 0 then do;
	     call ioa_ ("Password Change Interval must be greater than zero.");
	     goto retype (62);
	end;
	installation_parms.password_change_interval = i;
	return;
retype (63):					/* password_expiration_interval */
	call ask_$ask_int ("Password Expiration Interval (in days):^-", i);
	if i < 0 then do;
	     call ioa_ ("Password Expiration Interval must be greater than zero.");
	     goto retype (62);
	end;
	installation_parms.password_expiration_interval = i;
	return;
retype (64):
	call ask_$ask_yn ("vchn_requires_accept:^-", yn);
	installation_parms.vchn_requires_accept = (yn = "yes");
	return;
retype (20):					/* devname */
	go to cant_retype_must_change;

retype (21):					/* resource_prices */
	call ioa_ ("Enter resource prices");
	do i = 1 to rate_structure.nrscp;
	     if rate_structure.resource (i).price >= 0e0 then
						/* not a rate structure */
		call input_resource_price (i, (installation_parms.resource (i).name), THIS_RS, NO_SET_HI);
	end;
	return;

retype (22):					/* rscname */
	go to cant_retype_must_change;

retype (23):					/* resource_wait_time */
	call set_halfword ("resource wait time", "seconds", installation_parms.rsc_timer_seconds, 0, NOLIMIT);
	return;

retype (24):					/* fpe_time */
	call set_halfword ("fatal process error loop time", "seconds", installation_parms.fatal_error_loop_seconds, 0,
	     NOLIMIT);
	return;

retype (25):					/* fpe_count */
	call set_halfword ("fatal process error loop count", "", installation_parms.fatal_error_loop_count, 0, NOLIMIT);
	return;

retype (26):					/* trm_real_time */
	call set_halfword ("trm_ real time limit", "seconds", installation_parms.term_real_time_seconds, 0, NOLIMIT);
	return;

retype (27):					/* trm_cpu_time */
	call set_halfword ("trm_ cpu time limit", "seconds", installation_parms.term_cpu_time_seconds, 0, NOLIMIT);
	return;

retype (28):					/* unload_on_detach */
	installation_parms.rcp_init_flags.unload_on_detach = ask_on_off (idt (keywx));
	return;

retype (29):					/* authentication_level */
	installation_parms.rcp_init_flags.authentication_level = enter_authentication_level ();
	return;

retype (30):					/* default_pdir_seg_quota */
	call set_halfword ("default pdir segment quota", "records", installation_parms.default_pdir_seg_quota, 100, NOLIMIT);
	return;

retype (56):					/* default_pdir_dir_quota */
	call set_halfword ("default pdir directory quota", "records", installation_parms.default_pdir_dir_quota, 100, NOLIMIT);
	return;

retype (31):					/* rsc_mgmt_enabled */
	installation_parms.rcp_init_flags.resource_mgmt_enabled = ask_on_off (idt (31));
	return;

retype (32):					/* auto_registration */
	installation_parms.rcp_init_flags.auto_registration = ask_on_off (idt (32));
	return;

retype (33):					/* enable_ss_volume_mount */
	go to retyped_nothing;

retype (34):					/* foreground_queue_position */
	call set_halfword (idt (34), "", installation_parms.foreground_queue_position, 0, 4);
	return;


retype (35):					/* idle_time_constant */
	call set_halfword (idt (35), "seconds", installation_parms.idle_time_constant_seconds, 60, 1800);
	return;


retype (36):					/* sus_cpu_time */
	call set_halfword (idt (36), "seconds", installation_parms.sus_cpu_time_seconds, 1, NOLIMIT);
	return;


retype (37):					/* sus_real_time */
	call set_halfword (idt (37), "seconds", installation_parms.sus_real_time_seconds, 30, NOLIMIT);
	return;


retype (38):					/* max_abs */
	call set_sval (idt (38), installation_parms.max_abs, -1, NOLIMIT);
	return;

retype (39):					/* min_abs */
	call set_sval (idt (39), installation_parms.min_abs, 0, NOLIMIT);
	return;

retype (40):					/* pct_abs */
	call set_sval (idt (40), installation_parms.pct_abs, 0, 100);
	return;

retype (41):					/* max_qres */
	call set_sqval (idt (41), installation_parms.max_qres, 0, NOLIMIT);
	return;

retype (42):					/* min_qres */
	call set_sqval (idt (42), installation_parms.min_qres, 0, NOLIMIT);
	return;

retype (43):					/* pct_qres */
	call set_sqval (idt (43), installation_parms.pct_qres, 0, 100);
	return;

retype (44):					/* abs_cpu_max_limit */
	call set_sqlval (idt (44), installation_parms.abs_cpu_max_limit, 0, NOLIMIT);
	call check_abs_cpu_limit;
	return;

retype (45):					/* abs_timax */
	call set_qval (idt (45), installation_parms.abs_timax, 1000000, NOLIMIT);
	return;

retype (46):					/* abs_cpu_default_limit */
	call set_qval (idt (46), installation_parms.abs_cpu_default_limit, 0, NOLIMIT);
	call check_abs_cpu_limit;
	return;

retype (47):					/* foregound_cpu_default_limit */
	call set_word (idt (47), "seconds", installation_parms.foreground_cpu_default_limit, 0, NOLIMIT);
	return;


retype (48):					/* abs_default_queue */
	call set_halfword (idt (48), "", installation_parms.default_absentee_queue, 1, 4);
	return;


retype (49):					/* cwe_time */
	call set_halfword ("channel wakeup error loop time", "seconds",
	     installation_parms.chn_wakeup_error_loop_seconds, 0, NOLIMIT);
	return;

retype (50):					/* cwe_count */
	call set_halfword ("channel wakeup error loop count", "", installation_parms.chn_wakeup_error_loop_count, 0,
	     NOLIMIT);
	return;


retype (51):					/* rates */
	call ioa_ ("^/Retype rate_structure ^a", ptr_rs_name (cur_rs_ptr));
	return;

retype (52):					/* devices */
	if edit_rs then go to cant_retype_rs;
	call ioa_ ("Warning: this operation changes the positions of devices in device table;");
	call ioa_ ("it should only be done in a special session just after billing has been run.");
	call ask_$ask_yn ("Do you wish to proceed?  ", char8);
	if char8 ^= "yes" then go to main1;
	call ioa_ ("Enter device prices.");
	do i = 1 to hbound (installation_parms.devtab, 1);
	     if i <= hbound (dev_id, 1) then
		devnm = dev_id (i);
	     else do;
deviclp:
		call ask_ ("Enter device id or ""x"" to exit^-", devnm);
		if devnm = "x" then return;
		j = devtab$$undefined (devnm, NO_SPECIAL_DEVICES, COMPLAIN);
						/* unique device name? */
		if j >= 0 then go to deviclp;		/* no - try again */
	     end;
	     call input_device_price (i, devnm, ALL_RS, SET_HI);
	end;
	call ioa_ ("Device table full");
	call ask_$ask_clr ();
	return;

retype (53):					/* resources */
	if edit_rs then go to cant_retype_rs;
	call ioa_ ("Warning: retyping the resource price list might make other system tables invalid.");
	call ask_$ask_yn ("Do you want to retype the resource price list?^-", char8);
	if char8 = "no" then return;
	call ioa_ ("Enter resource names and prices, or ""x"" to exit.");
	i = 0;
rt53a:
	call ask_ ("resource:^-", rscnm);
	if rscnm = "x" then return;
	j = rsctab$$undefined (rscnm, COMPLAIN);	/* unique resource name */
	if j < 0 then do;				/* nope */
	     i = i + 1;
	     call input_resource_price (i, rscnm, ALL_RS, SET_HI);
	end;
	go to rt53a;

retype (54):					/* rate_structure_name */
	go to cant_retype_must_change;

retype (55):					/* all_structures */
	if edit_rs then go to cant_retype_rs;
	go to retyped_nothing;

retyped_nothing:
	did_something = "0"b;
	return;

cant_retype_must_change:
	call ioa_ ("cannot retype ^a; use change", idt (keywx));
	go to main1;

cant_retype:
	call ioa_ ("""^a ^a"" is not allowed.", print_comm, idt (IX));
	go to main1;

cant_retype_rs:
	call ioa_ ("""^a ^a"" is not allowed while editing a rate_structure.", print_comm, idt (IX));
	go to main1;

     end do_retype;
%page;

/* ------------------------------ */

ask_on_off:
     procedure (name) returns (bit (1) aligned);

dcl  name char (*);

	call ask_ ("^a:^-", char8, name);
	do while ("1"b);
	     if char8 = "yes" | char8 = "on" then return ("1"b);
	     else if char8 = "no" | char8 = "off" then return (""b);
	     else do;
		call ask_$ask_clr ();
		call ask_ ("Please answer ""yes"", ""no"", ""on"", or ""off""; ^a: ^x", char8, name);
	     end;
	end;

     end ask_on_off;

/* ------------------------------ */

check_abs_cpu_limit:				/* make sure each default is OK */
     procedure;

dcl  (qok, qbad) (4) bit (1) aligned init ((4) (1)""b);
dcl  nbad fixed bin init (0);
dcl  (s, q) fixed bin;

	do q = 1 to 4;
	     do s = 0 to 7;
		if installation_parms.abs_cpu_default_limit (q) <= installation_parms.abs_cpu_max_limit (s, q) then
		     qok (q) = "1"b;
	     end;
	     if ^qok (q) then do;
		qbad (q) = "1"b;
		nbad = nbad + 1;
	     end;
	end;

	if nbad > 0 then do;
	     call ioa_ ("Warning: the default limit is higher than the max limit");
	     call ioa_ ("on all shifts, for queue^[s^]^[^x1^]^[^x2^]^[^x3^]^[^x4^].", (nbad > 1), qbad);
	     call ioa_ ("If you don't change one of them, jobs using the default will never log in.");
	end;

	return;

     end check_abs_cpu_limit;

/* ------------------------------ */

check_device_names:
     procedure returns (bit (1) aligned);

dcl  (i, j) fixed bin;

	do i = 1 to hbound (dev_id, 1);		/* for each required device name */
	     do j = 1 to rate_structure.ndevices while (dev_id (i) ^= rate_structure.device_id (j));
	     end;
	     if j > rate_structure.ndevices then
		call ioa_ ("Warning: device ""^a"" not in device table. It should be added.", dev_id (i));
	end;
	return ("0"b);

     end check_device_names;

/* ------------------------------ */

checkid:
     procedure (xid, loud_sw) returns (fixed bin (17));

dcl  xid char (*);
dcl  loud_sw bit (1) aligned;

dcl  ib fixed bin;
dcl  i fixed bin;
dcl  keywx fixed bin;

	do ib = 1 to hbound (keyw, 1);
	     if xid = keyw (ib) then do;
		keywx = keyn (ib);			/* key number */
		if edit_rs then do;			/* not valid for rate_structures? */
		     do i = 1 to hbound (valid_for_rs, 1) while (valid_for_rs (i) < keywx);
		     end;
		     if valid_for_rs (i) > keywx then do;
			if loud_sw then do;
			     call ioa_ ("The identifier ""^a"" is not valid while editing a rate_structure.",
				idt (keywx));
			     call ask_$ask_clr ();
			end;
			return (NOT_RS_ID);
		     end;
		end;
		return (keywx);
	     end;
	end;
	if loud_sw then do;
	     call ioa_ ("illegal change id ""^a"". Type help for instructions.", xid);
	     call ask_$ask_clr ();
	end;
	return (ID_NOT_FOUND);

     end checkid;

/* ------------------------------ */

check_config_table:
     procedure;

dcl  (this_ord, highest_ord) fixed bin (71);
dcl  i fixed bin;
dcl  (bad_dup, bad_null, bad_order) bit (1) aligned;

	bad_dup, bad_null, bad_order = ""b;
	highest_ord = -2;

	do i = 1 to installation_parms.ncon;
	     this_ord =
		gen_config_ordinal ((installation_parms.cona (i).cpu), (installation_parms.cona (i).kmem),
		(installation_parms.cona (i).kbulk), (installation_parms.cona (i).shift));
	     if this_ord = -1 then bad_null = "1"b;
	     else if this_ord < highest_ord then bad_order = "1"b;
	     else if this_ord = highest_ord then bad_dup = "1"b;
	     else highest_ord = this_ord;
	end;
	if bad_dup | bad_null | bad_order then do;
	     call ioa_ ("Config table error(s).^[ Duplicate entires.^]^[ Null entries.^]^[ Entries out of order.^]",
		bad_dup, bad_null, bad_order);
	     call sort_config_table;
	end;

     end check_config_table;

/* ------------------------------ */

clean_up:
     procedure;
dcl  i fixed bin;

	if ip = null then return;			/* no segments active */
	do i = hbound (rs_ptrs, 1) to 0 by -1;		/* do installation_parms & copy last */
	     if rs_ptrs (i) ^= null then do;		/* working copy? */
		call hcs_$delentry_seg (rs_ptrs (i), ec);
						/* delete it */
		rs_ptrs (i) = null;			/* remember it's gone */
	     end;
	     if rs_ptrs1 (i) ^= null then do;		/* real segment? */
		call terminate_file_ (rs_ptrs1 (i), (0), TERM_FILE_TERM, ec);
						/* get rid of it */
		rs_ptrs1 (i) = null;		/* forget it */
	     end;
	end;
     end clean_up;

/* ------------------------------ */

devtab$$defined:					/* search devtab */
     procedure (devnm, any_sw, loud_sw) returns (fixed bin);

dcl  devnm char (*);
dcl  any_sw bit (1) aligned;
dcl  loud_sw bit (1) aligned;

dcl  i fixed bin;
dcl  j fixed bin;
dcl  should_find bit (1) aligned;

	should_find = "1"b;				/* we WANT to find it */
	go to devtab_common;

devtab$$undefined:					/* search devtab */
     entry (devnm, any_sw, loud_sw) returns (fixed bin (17));

	should_find = "0"b;				/* don't want to find it */

devtab_common:
	do i = 1 to installation_parms.ndevices;	/* whole devtab */
	     if installation_parms.devtab (i).device_id = devnm then do;
						/* what we're checking for? */
		if should_find then			/* did we want to find it? */
		     if any_sw ^= SPECIAL_DEVICES_OK then do;
						/* have to check for special */
			do j = 1 to hbound (dev_id, 1);
						/* see if special name */
			     if devnm = dev_id (j) then do;
						/* yes, it's special */
				if loud_sw then do; /* complain? */
				     call ioa_ ("""^a"" is a reserved device name.", devnm);
				     call ask_$ask_clr ();
						/* clean up */
				end;
				return (-1);	/* indicate we're unhappy */
			     end;			/* found a special name */
			end;			/* loop to check for special */
		     end;				/* have to check for special */
		if ^should_find & loud_sw then do;	/* shouldn't have found it */
		     call ioa_ ("Device ""^a"" is already defined.", devnm);
		     call ask_$ask_clr ();
		end;
		return (i);
	     end;
	end;
	if should_find & loud_sw then do;		/* should have found it, but we didn't */
	     call ioa_ ("Device ""^a"" is not defined.", devnm);
	     call ask_$ask_clr ();
	end;
	return (-1);
     end devtab$$defined;

/* ------------------------------ */

enter_authentication_level:
     procedure returns (fixed bin);

dcl  i fixed bin,
     ans char (32);

get_again:
	call ask_$ask_line ("Authentication level: ", ans);

	do i = lbound (authentication_level_names, 1) to hbound (authentication_level_names, 1);
	     if (authentication_level_names (i) = ans) then return (i);
	end;

	call ioa_ ("Authentication level must be ^v(^a, ^) or ^a. Reenter level.",
	     dim (authentication_level_names, 1) - 1, authentication_level_names (*));
	call ask_$ask_clr ();
	go to get_again;

     end enter_authentication_level;

/* ------------------------------ */

enter_category_name:
     procedure (i);

dcl  i fixed bin;

dcl  name char (32);
dcl  short_name char (8);

	installation_parms.category_names (i) = "";	/* null out so invalid_name doesn't find a duplicate. */
	installation_parms.short_category_names (i) = "";

change_this_name:
	call ask_$ask_line ("Category ^d: ", name, i);
	if name = "." then do;
reenter_name:
	     call ioa_ ("No categories may be unnamed. Reenter name.");
	     call ask_$ask_clr ();
	     go to change_this_name;
	end;

	call ask_$ask_line (" (short name) Category ^d: ", short_name, i);
	if short_name = "." then go to reenter_name;

	if invalid_name (name, length (installation_parms.category_names (1)), "1"b) then go to change_this_name;

	if invalid_name (short_name, length (installation_parms.short_category_names (1)), "0"b) then
	     go to change_this_name;

	installation_parms.category_names (i) = name;
	installation_parms.short_category_names (i) = short_name;

     end enter_category_name;

/* ------------------------------ */

enter_level_name:
     procedure (i);

dcl  i fixed bin;

dcl  name char (32);
dcl  short_name char (8);

	installation_parms.level_names (i) = "";	/* null out so invalid_name doesn't find a duplicate. */
	installation_parms.short_level_names (i) = "";

change_this_name:
	call ask_$ask_line ("Level ^d: ", name, i);
	if name = "." then
	     if i = 0 then
		name = "";
	     else do;
reenter_name:
		call ioa_ ("Only level 0 may be unnamed. Reenter name.");
		call ask_$ask_clr ();
		go to change_this_name;
	     end;

	call ask_$ask_line (" (short name) Level ^d: ", short_name, i);
	if short_name = "." then
	     if i = 0 then
		short_name = "";
	     else go to reenter_name;

	if invalid_name (name, length (installation_parms.level_names (0)), "1"b) then go to change_this_name;

	if invalid_name (short_name, length (installation_parms.short_level_names (0)), "0"b) then
	     go to change_this_name;

	installation_parms.level_names (i) = name;
	installation_parms.short_level_names (i) = short_name;
	return;

     end enter_level_name;

/* ------------------------------ */

gen_config_ordinal:					/* make a number which describes NCPU, NMEM, NBULK and SHIFT */
						/* of a config-table entry */
     procedure (ncpu, nmem, nbulk, shift) returns (fixed bin (71));

dcl  (ncpu, nmem, nbulk, shift) fixed bin;

	if ncpu < 0 | nmem < 0 | nbulk < 0 | shift < 0 then
						/* something naughty? */
	     return (-1);
	else return ((((ncpu * 100000 + nmem) * 100000) + nbulk) * 10 + shift);

     end gen_config_ordinal;

/* ------------------------------ */

get_disk_price:
     procedure (price);

dcl  price float bin (27);

dcl  char32 char (32);
dcl  f float bin (27);
dcl  i fixed bin;

	call ask_$ask_n (char32, i);
	if i = 0 then				/* no typeahead */
	     call ioa_ ("enter disk price as 'N' (page-second) or 'N/month' (page-30-days)");
	do while ("1"b);				/* keep going until user gets it right */
	     call ask_ ("disk price^-", char32);
	     if index (char32, "/mo") ^= 0 then do;	/* per-30-day month */
		call cv_float_ (rtrim (before (char32, "/mo")), ec, f);
		if ec = 0 then do;
		     price = f / SECONDS_PER_MONTH;	/* units are page-seconds */
		     return;
		end;
	     end;
	     else do;				/* per second */
		call cv_float_ (rtrim (char32), ec, f);
		if ec = 0 then do;
		     price = f;
		     return;
		end;
	     end;
	     call ask_$ask_clr ();			/* error in floating point number */
	end;
     end get_disk_price;

/* ------------------------------ */

get_nums:
     procedure (prompt, n1, n2);

dcl  prompt char (*);
dcl  (n1, n2) fixed bin;
dcl  ia fixed bin;

ask_for_nums:
	call ask_ ("^a", char32, prompt);
	if verify (rtrim (char32), "0123456789-") ^= 0 then do;
bad_nums:
	     call ask_$ask_clr ();
	     call ioa_ ("""^a"" invalid. Give one number or two joined by a hyphen.", char32);
	     go to ask_for_nums;
	end;

	ia = index (char32, "-");
	if ia = 0 then
	     n1, n2 = cv_dec_ (char32);		/* we already checked */
	else do;
	     if ia = 1				/* if leading hyphen */
		| substr (char32, ia + 1) = ""	/* or trailing hyphen */
		| index (substr (char32, ia + 1), "-") ^= 0
						/* or more than one hyphen */
	     then go to bad_nums;			/* go complain */
	     n1 = cv_dec_ ((substr (char32, 1, ia - 1)));
	     n2 = cv_dec_ ((substr (char32, ia + 1)));
	end;

	return;

     end get_nums;

/* ------------------------------ */

get_shift_queue:
     procedure (q_lo, q_hi, s_lo, s_hi);		/* Checks for typed-ahead shift and queue numbers;
						   returns first and last shift in s_lo and s_hi;
						   s_lo = -1 if no shift typed ahead;
						   same for q_lo and q_hi for queues. */

dcl  (q_lo, q_hi, s_lo, s_hi) fixed bin;

dcl  (get_shift, get_queue) bit (1) aligned init (""b);
dcl  x fixed bin;

/* Main entry point - get both shift and queue */

	get_shift, get_queue = "1"b;
	s_lo, q_lo = -1;				/* we haven't gotten either one, yet */

gsq_common:					/* come here from get_shift or get_queue */
	call ask_$ask_n (char32, x);
	if x = 0 then return;			/* if nothing typed ahead */
	if get_shift & char32 = "shift" then do;
	     call ask_ ("", char32);			/* clear it from the line */
	     call get_nums ("shift(s)", s_lo, s_hi);	/* get "s" or "s1-s2" */
	     get_shift = ""b;			/* we have gotten it */
	end;
	else if get_queue & char32 = "queue" then do;
	     call ask_ ("", char32);
	     call get_nums ("queue(s)", q_lo, q_hi);
	     get_queue = ""b;
	end;
	else return;				/* if we wanted both, go back for the other one */
	if get_shift | get_queue then go to gsq_common;
	return;

get_shift:
     entry (s_lo, s_hi);

	s_lo = -1;
	get_shift = "1"b;
	go to gsq_common;

get_queue:
     entry (q_lo, q_hi);

	q_lo = -1;
	get_queue = "1"b;
	go to gsq_common;

     end get_shift_queue;

/* ------------------------------ */

idt:
     procedure (n) returns (char (32));			/* returns primary keyword, given key number */

dcl  n fixed bin;
dcl  ia fixed bin;

	do ia = 1 to hbound (keyn, 1);
	     if keyn (ia) = n then return (keyw (ia));
	end;
	call com_err_ (0, me, "Internal error in ""idt"" function.");
	return ("UNKNOWN!");

     end idt;

/* ------------------------------ */

input_config_element:
     procedure (i);
dcl  i fixed bin;

dcl  j fixed bin;
dcl  ftmp float bin;
	call set_half_al ("ncpu", "", j, -1, 8);
	installation_parms.cona.cpu (i) = j;
	if j <= 0 then return;
	call set_half_al ("mem", "Kwords", j, 0, NOLIMIT);
	installation_parms.cona.kmem (i) = j;
	call set_half_al ("bulk", "Kwords", j, 0, NOLIMIT);
	installation_parms.cona.kbulk (i) = j;
	call set_half_al ("shift", "", j, 0, 7);
	installation_parms.cona.shift (i) = j;
	call ask_$ask_flo ("min   ", ftmp);
	installation_parms.cona.response_low (i) = ftmp * 1e1;
	call ask_$ask_flo ("max   ", ftmp);
	installation_parms.cona.response_high (i) = ftmp * 1e1;
	call ask_$ask_flo ("base  ", ftmp);
	installation_parms.cona.maxu_base (i) = ftmp * 1e1;
	call set_half_al ("absu", "", j, 0, NOLIMIT);
	installation_parms.cona.maxa (i) = j;
	call set_half_al ("absq", "", j, 1, 4);
	installation_parms.cona.maxq (i) = j;
	installation_parms.cona.x1 (i) = 0;
	installation_parms.cona.x2 (i) = 0;
	installation_parms.cona.x3 (i) = 0;

     end input_config_element;

/* ------------------------------ */

input_device_price:
     procedure (devx, devnm, all_sw, set_hi);

dcl  devx fixed bin;
dcl  devnm char (*);
dcl  all_sw bit (1) aligned;
dcl  set_hi bit (1) aligned;

dcl  rsp ptr;
dcl  i fixed bin;
dcl  s fixed bin;
dcl  (hi, lo) fixed bin;
dcl  save_crit bit (1) aligned;

/* maybe allow copy or zero? */

	save_crit = critical_op;
	critical_op = critical_op | (all_sw = ALL_RS);
	if all_sw = ALL_RS then do;			/* one, or all RS? */
	     hi = installation_parms.nrates;
	     lo = 0;
	end;
	else hi, lo = rate_structure.rate_structure_number;

	do i = lo to hi;				/* run the gamut */
	     rsp = rs_ptrs (i);			/* which RS now? */
	     if all_sw = ALL_RS & installation_parms.nrates > 0 then
						/* tell user which one, if more than one */
		call ioa_ ("rate_structure ""^a""", ptr_rs_name (rsp));
	     rsp -> rate_structure.device_id (devx) = devnm;
	     do s = 0 to 7;				/* get price for each shift */
		call ask_$ask_flo ("^a shift ^d^-", rsp -> rate_structure.device_price (devx, s), devnm, s);
	     end;
	end;

	if set_hi = SET_HI then			/* do installation_parms last */
	     do i = hi to lo by -1;			/* set number of devices */
	     rs_ptrs (i) -> rate_structure.ndevices = devx;
	end;
	critical_op = save_crit;			/* restore old critical indicator */
     end input_device_price;

/* ------------------------------ */

input_resource_price:
     procedure (rscx, rscnm, all_sw, set_hi);

dcl  rscx fixed bin;
dcl  rscnm char (*);
dcl  all_sw bit (1) aligned;
dcl  set_hi bit (1) aligned;

dcl  f float bin (27);
dcl  i fixed bin;
dcl  rsp ptr;
dcl  (hi, lo) fixed bin;
dcl  save_crit bit (1) aligned;

	save_crit = critical_op;
	critical_op = critical_op | (all_sw = ALL_RS);
	if all_sw = ALL_RS then do;			/* which RS? */
	     hi = installation_parms.nrates;
	     lo = 0;
	end;
	else hi, lo = rate_structure.rate_structure_number;

	do i = lo to hi;				/* for each appropriate RS */
	     rsp = rs_ptrs (i);			/* point to RS */
	     if all_sw = ALL_RS & installation_parms.nrates > 0 then
						/* more than one - tell user which */
		call ioa_ ("rate_structure ""^a""", ptr_rs_name (rsp));
	     call ask_$ask_flo ("Price of ^a:^-", f, rscnm);
						/* price, please */
	     rsp -> rate_structure.resource (rscx).price = f;
	     rsp -> rate_structure.resource (rscx).name = rscnm;
	end;

	if set_hi then				/* do installation_parms last */
	     do i = hi to lo by -1;			/* set number of resources */
	     rs_ptrs (i) -> rate_structure.nrscp = rscx;
	end;

	critical_op = save_crit;			/* restore saved indicator */
	return;

     end input_resource_price;

/* ------------------------------ */

invalid_name:					/* check level and category names for duplicates, valid chars, etc. */
     procedure (bv_name, bv_max_len, blank_ok) returns (bit (1) aligned);

/* parameters */

declare  bv_name char (*);
declare  bv_max_len fixed bin;
declare  blank_ok bit (1) aligned;

/* automatic */

declare  i fixed bin;

/* program */

	if bv_name = "" then return ("0"b);		/* null names are always ok */

	if bv_name = "system_low" | bv_name = "system_high" then do;
	     call ioa_ ("The keyword ^a is not allowed as a level or category name. Reenter both names.", bv_name);
	     go to invalid;
	end;

	i = length (bv_name) - verify (reverse (bv_name), " ") + 1;

	if i > bv_max_len then do;
	     call ioa_ ("Name ^a is longer than allowed maximum of ^d characters. Reenter both names.", bv_name,
		bv_max_len);
	     go to invalid;
	end;

	if verify (substr (bv_name, 1, i), " '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ^_`abcdefghijklmnopqrstuvwxyz~") ^= 0
	then do;
	     call ioa_ ("Name ^a contains illegal character (s). Reenter both names.", bv_name);
	     go to invalid;
	end;

	if blank_ok then ;
	else if index (substr (bv_name, 1, i), " ") ^= 0 then do;
	     call ioa_ ("Short level and category names may not contain embedded blanks. Reenter both names.");
	     call ask_$ask_clr ();
	     return ("1"b);
	end;

	do i = lbound (installation_parms.level_names (*), 1) to hbound (installation_parms.level_names (*), 1);
	     if installation_parms.level_names (i) = bv_name then go to found_duplicate;
	end;

	do i = lbound (installation_parms.category_names (*), 1) to hbound (installation_parms.category_names (*), 1);
	     if installation_parms.category_names (i) = bv_name then go to found_duplicate;
	end;

	do i = lbound (installation_parms.short_level_names (*), 1)
	     to hbound (installation_parms.short_level_names (*), 1);
	     if installation_parms.short_level_names (i) = bv_name then go to found_duplicate;
	end;

	do i = lbound (installation_parms.short_category_names (*), 1)
	     to hbound (installation_parms.short_category_names (*), 1);
	     if installation_parms.short_category_names (i) = bv_name then go to found_duplicate;
	end;

	return ("0"b);

found_duplicate:
	call ioa_ ("Name ^a is already in use. Reenter both names.", bv_name);
invalid:
	call ask_$ask_clr ();
	return ("1"b);

     end invalid_name;

/* ------------------------------ */

out_of_range:					/* NOLIMIT should check hw/word limit */
     procedure (prompt, v, v_lo, v_hi) returns (bit (1) aligned);

dcl  v fixed bin (35);
dcl  (v_hi, v_lo) fixed bin (35);
dcl  prompt char (*);
dcl  dummy char (1);
dcl  flag fixed bin;
dcl  (error, error_lo, error_hi) bit (1) aligned init (""b);

	if v_lo ^= NOLIMIT then
	     if v < v_lo then error, error_lo = "1"b;
	if v_hi ^= NOLIMIT then
	     if v > v_hi then error, error_hi = "1"b;

	if error then do;				/* value is out of range */
	     call ask_$ask_n (dummy, flag);		/* see if anything else was typed ahead */
	     call ask_$ask_clr ();			/* clear anything that was typed ahead */
	     call ioa_ ("ERROR: value of ^a (^d) may not be^[ below ^d^;^s^]^[ or^]^[ above ^d^;^s^].", prompt, v,
		(error_lo), v_lo, (error_lo & error_hi), (error_hi), v_hi);
	     call ioa_ ("Please retype it^[^x(and everything that followed it)^].", (flag > 0));
	     return ("1"b);
	end;
	return (""b);				/* value is ok */

     end out_of_range;

/* ------------------------------ */

print_config_element:
     procedure (i);

dcl  i fixed bin;

	call ioa_ ("^5d ^5d ^5d ^5d ^7.1f ^7.1f ^7.1f ^5d ^5d", installation_parms.cona.cpu (i),
	     installation_parms.cona.kmem (i), installation_parms.cona.kbulk (i), installation_parms.cona.shift (i),
	     installation_parms.cona.response_low (i) * 1e-1, installation_parms.cona.response_high (i) * 1e-1,
	     installation_parms.cona.maxu_base (i) * 1e-1, installation_parms.cona.maxa (i),
	     installation_parms.cona.maxq (i));

     end print_config_element;

/* ------------------------------ */

print_halfword:
     procedure (name, v);

dcl  name char (*);
dcl  v fixed bin (17) unaligned;

	call ioa_ ("^a:^x^d", name, v);
	return;

     end print_halfword;

/* ------------------------------ */

print_sval:
     procedure (name, sarray);

dcl  name char (*);
dcl  sarray (0:7) fixed bin (17) unaligned;

dcl  nq fixed bin;
dcl  i fixed bin;
dcl  arrayp ptr;
dcl  array (0:7, nq) fixed bin (17) unaligned based (arrayp);

	nq = 1;
	arrayp = addr (sarray);

print_sval_common:
	call ioa_ ("^a - PER ^[QUEUE AND^x^]SHIFT", name, (nq = 4));
	call ioa_ ("^[Q^x^]^5x0^6x1^6x2^6x3^6x4^6x5^6x6^6x7", (nq = 4));
	do i = 1 to nq;
	     call ioa_ ("^[^d^x^;^s^]^8(^6d^x^)", (nq = 4), i, array (*, i));
	end;
	return;

print_sqval:
     entry (name, sqarray);

dcl  sqarray (0:7, 4) fixed bin (17) unaligned;

	nq = 4;
	arrayp = addr (sqarray);
	go to print_sval_common;

     end print_sval;

/* ------------------------------ */

ptr_rs_name:					/* get name of RS, given pointer to temp seg */
     procedure (rsp) returns (char (32));

dcl  rsp ptr;
dcl  i fixed bin;

	do i = 0 to installation_parms.nrates;
	     if rsp = rs_ptrs (i) then return (installation_parms.rate_structures (i));
	end;
	call com_err_ (0, me, "Internal error in ""ptr_rs_name"".");
	return ("UNKNOWN!");			/* OOG! */

     end ptr_rs_name;

/* ------------------------------ */

rstab$$defined:					/* search rate_structure name table */
						/* just like devtab$$= */
     procedure (rsnm, loud_sw) returns (fixed bin);

dcl  rsnm char (*);
dcl  loud_sw bit (1) aligned;

dcl  i fixed bin;
dcl  should_find bit (1) aligned;

	should_find = "1"b;
	go to rstab_common;

rstab$$undefined:
     entry (rsnm, loud_sw) returns (fixed bin (17));

	should_find = "0"b;

rstab_common:
	do i = 0 to installation_parms.nrates;
	     if installation_parms.rate_structures (i) = rsnm | rsnm = "." then do;
		if ^should_find & loud_sw then do;
		     call ioa_ ("rate_structure ""^a"" is already defined.", rsnm);
		     call ask_$ask_clr ();
		end;
		return (i);
	     end;
	end;
	if should_find & loud_sw then do;
	     call ioa_ ("rate_structure ""^a"" is not defined.", rsnm);
	     call ask_$ask_clr ();
	end;
	return (-1);

     end rstab$$defined;

/* ------------------------------ */

rsctab$$defined:					/* search resource table. */
						/* just like devtab$$= */
     procedure (rscnm, loud_sw) returns (fixed bin);

dcl  rscnm char (*);
dcl  loud_sw bit (1) aligned;

dcl  i fixed bin;
dcl  should_find bit (1) aligned;

	should_find = "1"b;
	go to rsctab_common;

rsctab$$undefined:
     entry (rscnm, loud_sw) returns (fixed bin (17));

	should_find = "0"b;

rsctab_common:
	do i = 0 to installation_parms.nrscp;
	     if installation_parms.resource (i).name = rscnm then do;
		if ^should_find & loud_sw then do;
		     call ioa_ ("resource ""^a"" is already defined.", rscnm);
		     call ask_$ask_clr ();
		end;
		return (i);
	     end;
	end;
	if should_find & loud_sw then do;
	     call ioa_ ("resource ""^a"" is not defined.", rscnm);
	     call ask_$ask_clr ();
	end;
	return (-1);

     end rsctab$$defined;

/* ------------------------------ */

set_halfword:
     procedure (prompt, units, v17unal, v_lo, v_hi);	/* to set fixed bin (17) unaligned scalars */

dcl  prompt char (*);
dcl  units char (*);
dcl  v17unal fixed bin (17) unaligned;
dcl  v17al fixed bin (17) aligned;
dcl  v35al fixed bin (35) aligned;
dcl  v fixed bin (35);
dcl  (v_hi, v_lo) fixed bin (35);
dcl  long_sw bit (1) aligned;
dcl  aligned_sw bit (1) aligned;

	long_sw = "0"b;
	aligned_sw = "0"b;
	go to set_join;

set_half_al:
     entry (prompt, units, v17al, v_lo, v_hi);

	long_sw = "0"b;
	aligned_sw = "1"b;
	go to set_join;

set_word:
     entry (prompt, units, v35al, v_lo, v_hi);

	aligned_sw = "1"b;
	long_sw = "1"b;
	go to set_join;

set_join:
	do while ("1"b);
	     call ask_$ask_int ("^a^[^x(^a)^;^s^]:^x", v, prompt, (units ^= ""), units);
	     if ^out_of_range (prompt, v, v_lo, v_hi) then do;
		if long_sw then v35al = v;
		else if aligned_sw then v17al = v;
		else v17unal = v;
		return;
	     end;
	end;

     end set_halfword;

/* ------------------------------ */

/* Internal procedure to set per-queue, per-shift, and per-queue-and-shift parameters */

set_qval:
     procedure (prompt, qarray, v_lo, v_hi);		/* to set per-queue parameters 45 and 46 */

dcl  prompt char (*);
dcl  qarray (4) fixed bin (35);
dcl  (v_lo, v_hi) fixed bin (35);

dcl  (set_shift, set_queue) bit (1) aligned init (""b);
dcl  esw fixed bin;
dcl  prompted bit (1) aligned init (""b);
dcl  (q, nq, s, ns) fixed bin;
dcl  v fixed bin (35);
dcl  (qx, q_ext, sx, s_ext) fixed bin;
dcl  ask_again bit (1) aligned;
dcl  (q_lo, q_hi, s_lo, s_hi) fixed bin;

	esw = 1;					/* remember which entry point we came in at */
	set_queue = "1"b;				/* and what we are supposed to do */
	go to set_common;

set_sval:
     entry (prompt, sarray, v_lo, v_hi);		/* to set parameters 38, 39, and 40 */

dcl  sarray (0:7) fixed bin (17) unaligned;

	esw = 2;					/* remember which entry point we came in at */
	set_shift = "1"b;				/* and what we are supposed to do */
	go to set_common;

set_sqval:
     entry (prompt, sqarray, v_lo, v_hi);		/* to set parameters 41 thru 43 */

dcl  sqarray (0:7, 4) fixed bin (17) unaligned;

	esw = 3;					/* remember which entry point we came in at */
	set_shift, set_queue = "1"b;			/* and what we are supposed to do */
	go to set_common;

set_sqlval:
     entry (prompt, sqlarray, v_lo, v_hi);		/* for parameter 44 */

dcl  sqlarray (0:7, 4) fixed bin (35);

	esw = 4;					/* remember which entry point we came in at */
	set_shift, set_queue = "1"b;			/* and what we are supposed to do */
	go to set_common;

set_common:
	ns, nq = 1;				/* go around shift and queue loops at least once each */

/* See if any shift or queue numbers were typed ahead */

	if esw = 1 then call get_queue (q_lo, q_hi);
	else if esw = 2 then call get_shift (s_lo, s_hi);
	else call get_shift_queue (q_lo, q_hi, s_lo, s_hi);

/* Check on what was typed ahead, and fill in defaults in the absence of typeahead */

	if set_queue then do;			/* if setting a per-queue or per-shift-and-queue parameter */
	     if q_lo = -1 then do;			/* if queue not typed ahead */
		if change_request then do;		/* default for change is to ask for, and set, a single queue */
		     ask_again = "1"b;
		     do while (ask_again);
			call ask_$ask_int ("queue:^x", q_lo);
						/* ask for it */
			ask_again = out_of_range ("queue", (q_lo), 1, 4);
		     end;
		     q_hi = q_lo;			/* q_hi=q_lo means set value for only one queue */
		end;
		else do;				/* default for retype is set all queues */
		     nq = 4;			/* ask for 4 values */
		     q_lo = 1;			/* for queues 1 */
		     q_hi = 4;			/* thru 4 */
		end;
	     end;
	     if nq = 1 then				/* if we will ask for only one per-queue value */
		q_ext = q_hi - q_lo;		/* set this many extra elements to that value */
	     else q_ext = 0;			/* otherwise, set only one element per value typed in */
	end;					/* end setting per-queue parameter */

	if set_shift then do;			/* if setting a per-shift or per-shift-and-queue parameter */
	     if s_lo = -1 then do;			/* if shift not typed ahead */
		if change_request then do;		/* default for change is a single shift */
		     ask_again = "1"b;
		     do while (ask_again);
			call ask_$ask_int ("shift:^x", s_lo);
						/* ask for it */
			ask_again = out_of_range ("shift", (s_lo), 0, 7);
		     end;
		     s_hi = s_lo;			/* one shift */
		end;
		else do;				/* default for retype is all shifts */
		     ns = 8;			/* so ask for 8 values */
		     s_lo = 0;			/* for shifts 0 */
		     s_hi = 7;			/* thru 7 */
		end;
	     end;
	     if ns = 1 then				/* if we will ask for only one per-shift value */
		s_ext = s_hi - s_lo;		/* set this many extra elements to that value */
	     else s_ext = 0;			/* otherwise, set only one element per value typed in */
	end;					/* end setting per-shift value */

/* Now, ask for, and store, the value(s) */

/* Outer loop on queue. If not setting per-queue, or per-shift-and-queue parameter,
   go around this loop just once, to get to the inner loop */

	do q = q_lo to q_lo + nq - 1;

/* Inner loop on shift. If not setting per-shift or per-shift-and-queue parameter,
   go thru this loop just once for each time around the outer loop */

	     do s = s_lo to s_lo + ns - 1;

/* This is what we're here for */
		ask_again = "1"b;
		do while (ask_again);
		     call ask_$ask_int (
			"^[^s^;^a:^x^]^[queue^[s ^d-^d^; ^d^s^]:^x^;^3s^]^[shift^[s ^d-^d^; ^d^s^]:^x^;^3s^]", v,
						/* the value to be typed in */
			prompted, prompt,		/* print the prompting word only once (first time around) */
			(set_queue & s = s_lo), (q_ext > 0), q, q_hi,
						/* if setting per-queue parm, print 1 or 2 queue numbers */
			(set_shift), (s_ext > 0), s, s_hi);
						/* if setting per-shift parm, print 1 or 2 shift #s */
		     ask_again = out_of_range (prompt, v, v_lo, v_hi);
		end;

		prompted = "1"b;			/* remember not to print prompting word again */

/* Now store the value into one or more array elements */
		if esw = 1 then
		     do qx = 0 to q_ext;
		     qarray (q + qx) = v;
		end;

		else if esw = 2 then
		     do sx = 0 to s_ext;
		     sarray (s + sx) = v;
		end;

		else do qx = 0 to q_ext;
		     do sx = 0 to s_ext;
			if esw = 3 then sqarray (s + sx, q + qx) = v;
			else if esw = 4 then sqlarray (s + sx, q + qx) = v;
		     end;
		end;

	     end;					/* end inner loop on shift */
	end;					/* end outer loop on queue */

	return;

     end set_qval;

/* ------------------------------ */

set_shift_field:
     procedure (i, j, k, n);

dcl  (i, j, k, n) fixed bin;

	installation_parms.shifttab (48 * i + (2 * j + n) + 1) = bit (fixed (k, 3), 3);
	return;

     end set_shift_field;

/* ------------------------------ */

set_std_shifttab:
     procedure;

dcl  (i, j) fixed bin;

	do i = 0 to 6;
	     do j = 0 to 15;
		installation_parms.shifttab (48 * i + j + 1) = "011"b;
	     end;
	     do j = 16 to 35;
		installation_parms.shifttab (48 * i + j + 1) = "001"b;
	     end;
	     do j = 36 to 47;
		installation_parms.shifttab (48 * i + j + 1) = "010"b;
	     end;
	end;
	do i = 5 to 6;
	     do j = 16 to 47;
		installation_parms.shifttab (48 * i + j + 1) = "100"b;
	     end;
	end;

     end set_std_shifttab;

/* ------------------------------ */

sort_config_table:
     procedure;

dcl  i fixed bin;
dcl  o1 fixed bin (71);
dcl  o2 fixed bin (71);
dcl  changed bit (1) aligned;
dcl  ever_changed bit (1) aligned;
dcl  save_crit bit (1) aligned;
dcl  ncon fixed bin;
dcl  1 tcona like installation_parms_part_1.cona aligned;

	changed = "1"b;
	ever_changed = "0"b;
	save_crit = critical_op;
	critical_op = critical_op | (all_sw = ALL_RS);
	ncon = installation_parms.ncon;		/* number of config table elements */

	do while (changed & ncon > 1);		/* keep going until we drop */
	     changed = "0"b;

	     do i = 1 repeat i + 1 while (i < ncon);
		o1 = gen_config_ordinal ((installation_parms.cona (i).cpu), (installation_parms.cona (i).kmem),
						/* get a number describing this element */
		     (installation_parms.cona (i).kbulk), (installation_parms.cona (i).shift));
		o2 = gen_config_ordinal ((installation_parms.cona (i + 1).cpu),
						/* and one for this element */
		     (installation_parms.cona (i + 1).kmem), (installation_parms.cona (i + 1).kbulk),
		     (installation_parms.cona (i + 1).shift));
		if o1 < 0 | installation_parms.cona (i).cpu <= 0 then do;
						/* should we dump this one? */
		     installation_parms.cona (i) = installation_parms.cona (ncon);
		     ncon = ncon - 1;
		     changed = "1"b;
		end;
		else if o2 < 0 | installation_parms.cona (i + 1).cpu <= 0 then do;
						/* dump this one (only one at a time, please)? */
		     installation_parms.cona (i + 1) = installation_parms.cona (ncon);
		     ncon = ncon - 1;
		     changed = "1"b;
		end;
		else if o1 > o2 then do;		/* out of order? */
		     tcona = installation_parms.cona (i);
						/* fiddle about */
		     installation_parms.cona (i) = installation_parms.cona (i + 1);
		     installation_parms.cona (i + 1) = tcona;
		     changed = "1"b;
		end;
		ever_changed = ever_changed | changed;
	     end;
	end;

	if ever_changed then do;			/* tell user if we changed anything */
	     call ioa_ ("Config table sorted.");
	     installation_parms.ncon = ncon;
	end;
	critical_op = save_crit;			/* back to where we were */

     end sort_config_table;

/* ------------------------------ */

verify_structures:
     procedure;

dcl  (i, j) fixed bin;
dcl  rsn fixed bin;
dcl  force bit (1) aligned;
dcl  char8 char (8);
dcl  phoo bit (1) aligned;
dcl  rsname char (32);

	call ask_$ask_n (char8, i);
	force = (i > 0 & (char8 = "-force" | char8 = "-fc" | char8 = "force" | char8 = "fc"));
	if force then call ask_ ("", char8);		/* remove it from line */

	do rsn = 0 to installation_parms.nrates;	/* for all rate-structures */
	     cur_rs_ptr = rs_ptrs (rsn);
	     rsname = installation_parms.rate_structures (rsn);

/* check device tables against installation_parms */

	     if rate_structure.ndevices ^= installation_parms.ndevices then do;
						/* first, check the counts */
		call ioa_ ("installation_parms has ^d devices, rate_structure ""^a"" has ^d",
		     installation_parms.ndevices, rsname, rate_structure.ndevices);
		if force then do;
		     call ioa_ ("Forcing change.");
		     rate_structure.ndevices = installation_parms.ndevices;
		end;
	     end;
	     do j = 1 to installation_parms.ndevices;	/* now check all the names */
		if installation_parms.device_id (j) ^= rate_structure.device_id (j) then do;
		     call ioa_ (
			"installation_parms has device ""^a"" at position ^d.^/rate_structure ""^a"" has device ""^a""."
			, installation_parms.device_id (j), j, rsname, rate_structure.device_id (j));
		     if force then do;
			call ioa_ ("Forcing change, price set to 0.0");
			rate_structure.device_id (j) = installation_parms.device_id (j);
			rate_structure.device_price (j, *) = 0e0;
		     end;
		end;
	     end;

/* check resources */

	     if installation_parms.nrscp ^= rate_structure.nrscp then do;
						/* first check the counts */
		call ioa_ (
		     "installation_parms has ^d resource array entries, rate_structure ""^a"" has ^d.^[ Forcing change^]"
		     , installation_parms.nrscp, rsname, rate_structure.nrscp, force);
		if force then rate_structure.nrscp = installation_parms.nrscp;
	     end;
	     do i = 1 to installation_parms.nrscp;	/* then check the names */
		if installation_parms.resource (i).name ^= rate_structure.resource (i).name then do;
		     call ioa_ (
			"installation_parms has resource ^a as entry ^d, the rate_structure resource is ""^a"".",
			installation_parms.resource (i).name, i, rate_structure.resource (i).name);
		     if force then do;
			call ioa_ ("Forcing change, price set to 0.0");
			rate_structure.resource (i).name = installation_parms.resource (i).name;
			rate_structure.resource (i).price = 0e0;
		     end;
		end;
	     end;

/* then check all the rate_structure name stuff */

	     if rate_structure.rate_structure_number ^= rsn then do;
						/* do I point to myself? */
		call ioa_ ("rate_structure ^d (^a) has incorrect rate_structure_number field ^d. ^[Forcing change^]",
		     rsn, installation_parms.rate_structures (rsn), rate_structure.rate_structure_number, force);
		if force then rate_structure.rate_structure_number = rsn;
	     end;
	     if rate_structure.nrates ^= installation_parms.nrates then do;
						/* first, check the counts */
		call ioa_ ("installation_parms has ^d rate_structures, rate_structure ""^a"" has ^d.",
		     installation_parms.nrates, rsname, rate_structure.nrates);
		if force then do;
		     call ioa_ ("Forcing change.");
		     rate_structure.nrates = installation_parms.nrates;
		end;
	     end;
	     do i = 0 to installation_parms.nrates;	/* now check the names */
		if installation_parms.rate_structures (i) ^= rate_structure.rate_structures (i) then do;
		     call ioa_ (
			"installation_parms has rate_structure ""^a"" at position ^d.^/rate_structure ""^a"" has rate_structure ""^a""."
			, installation_parms.rate_structures (i), i, rsname, rate_structure.rate_structures (i));
		     if force then do;
			call ioa_ ("Forcing change.");
			rate_structure.rate_structures (i) = installation_parms.rate_structures (i);
		     end;
		end;
	     end;
	end;

	cur_rs_ptr = selected_rs_ptr;			/* return to normalcy */
	edit_rs = (cur_rs_ptr ^= ip);
	critical_op = "0"b;
	call check_config_table;			/* config table ok? */
	phoo = check_device_names ();			/* device table have required names? */

     end verify_structures;

/* ------------------------------ */

write_error:
     procedure (ec, i, msg);
dcl  ec fixed bin (35);
dcl  i fixed bin;
dcl  msg char (*);

	call com_err_ (ec, me, "rate_structure_^d (^a) ^a.", i, installation_parms.rate_structures (i), msg);

     end write_error;

set_pdir_quota_defaults:
     procedure;

declare  code fixed bin (35);

/**** OLD COMMUNICATIONS SEGMENT */

dcl  com_p pointer;
dcl  1 communications based (com_p) aligned,		/* Administrators and answering service use it */
       2 admin_word char (8) unal,			/* Operator password for admin mode */
       2 ppmdl fixed bin,				/* Per-process master drum limit */
       2 ppmdl_daemon fixed bin,			/* ... for daemon */
       2 ssdq fixed bin,				/* Process directory disk quota */
       2 ssdq_daemon fixed bin,			/* ... for daemon */
       2 junk (4) fixed bin,
       2 version fixed bin,
       2 admin_sw fixed bin,				/* Length of administrator's command */
       2 admin_comment char (80) unal,			/* any old comment */
       2 admin_sender char (32) unal,			/* Who sent it */
       2 as_procid bit (36),				/* Process id of answering service */
       2 admin_com_chn fixed bin (71),			/* Event-call channel for admin command */
       2 admin_com char (4000) unaligned;		/* actual command line */

	call initiate_file_ (sc_stat_$sysdir, "communications", R_ACCESS, com_p, (0), code);
	if code = 0 then do;
	     installation_parms.default_pdir_seg_quota = communications.ssdq;
	     call terminate_file_ (com_p, (0), TERM_FILE_TERM, (0));
	end;
	else installation_parms.default_pdir_seg_quota = 1000;
	installation_parms.default_pdir_dir_quota = 1000;
	return;
     end set_pdir_quota_defaults;


/* ------------------------------ */

%page;
%include access_mode_values;
%page;
%include aim_template;
%page;
%include devid;
%page;
%include installation_parms;
%include rate_structure;
%include terminate_file;
%include sc_stat_;

     end ed_installation_parms;
