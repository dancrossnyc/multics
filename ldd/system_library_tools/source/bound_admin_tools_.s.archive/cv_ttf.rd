/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Bull Inc., 1987                *
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   * Copyright (c) 1972 by Massachusetts Institute of        *
   * Technology and Honeywell Information Systems, Inc.      *
   *                                                         *
   *********************************************************** */

/* cv_ttf converts a terminal-type file (TTF) into a terminal-type table (TTT)
   which can then be installed using the install command.  The cv_ttf command
   is generated by the reduction_compiler.

   Usage:	cv_ttf TTF_NAME { -brief | -long }                               */


/* HISTORY COMMENTS:
  1) change(77-05-20,RCoren), approve(), audit(), install():
      Written
      Modified 04/25/78 by Robert S. Coren to add framing_chars
      Modified 05/03/78 by Robert S. Coren & David R. Vinograd to increase
         conversion/translation tables to 256 characters
      Modified May 1979 by Larry Johnson and Bernie Greenberg for extended
         tty-char support.
      Modified June 1979 by Bernie Greenberg for video features.
      Modified February/March 1980 by Larry Johnson to finish video features.
      Modified 5/29/81 by Suzanne Krupp to add function key information.
      Modified: 9 June 1981 by G. Palter to recognize can_type mode and
         replace X/Y with LINE/COLUMN in video sequences
      Modified January 1982 BIM for author changes.
      Modified April 1982 by Robert Coren for changes to baud_rates.incl.pl1.
      Modified July 1982 by E. N. Kittlitz for [severity], ttf suffix.
      Modified September 1984 by Robert Coren to reject var_tab_delays and
         horz_delays > 1.00.
  2) change(86-09-21,Beattie), approve(86-09-21,MCR7542),
     audit(86-10-31,Brunelle), install(86-11-12,MR12.0-1211):
      Remove references to the 963 and 029 preaccess commands and
      remove support for ARDS, 202_ETX, 2741 and 1050 in system
      interfaces.
  3) change(87-03-06,LJAdams), approve(87-04-03,MCR7646),
     audit(87-05-05,Gilcrease), install(87-05-08,MR12.1-1030):
      Added reduction to check the protocol field in the terminal type
      entry table.
  4) change(87-05-21,LJAdams), approve(87-05-21,MCR7699),
     audit(87-07-31,Gilcrease), install(87-08-04,MR12.1-1055):
      Added support for MOWSE_FANSI protocol.
      Changed name of include file from terminal_type_protocols.incl.pl1
      which was to long to term_type_protocols.incl.pl1
  5) change(87-07-02,LJAdams), approve(87-07-13,MCR7742),
     audit(87-07-31,Gilcrease), install(87-08-04,MR12.1-1055):
      Added support for the reductions required by DSA.
  6) change(88-01-25,Brunelle), approve(88-01-25,MCR7813),
     audit(88-10-13,Blair), install(88-10-17,MR12.2-1171):
      1. Correct for repetition factors > 256 in initial_strings or
      additional_info.
      2. Expand special chars to 15 chars from current limit of 3.
      3. Add additional Global statements (including Input_suspend/resume,
      Output_suspend/resume, Buffer_size, Output_end_of_block,
      Output_acknowledge and Line_delimiter).
      4. Remove Additional_info statement.
      5. Correct problem of LIKE terminal_type loop.
                                                   END HISTORY COMMENTS */

%page;
/*++

	\" REDUCTIONS FOR cv_ttf

BEGIN	/ <no-token>			/ ERROR (1)				/ RETURN \

\" Scan for main delimiting statements
mainloop	/ terminal_type : <new_type_name>	/ LEX (2) init_type LEX			/ type_entry \
	/ terminal_type :			/ LEX (2) NEXT_STMT				/ mainloop \

	/ conversion_table : <new_table_name> ;	/ LEX (2) define_ct_table (CONV_TYPE) LEX (2)	/ table_entries \
	/ conversion_table :		/ LEX (2) NEXT_STMT				/ mainloop \

	/ translation_table : <new_table_name> ; / LEX (2) define_ct_table (TRANS_TYPE) LEX (2)	/ table_entries \
	/ translation_table :		/ LEX (2) NEXT_STMT				/ mainloop \

	/ special_table : <new_table_name> ;	/ LEX (2) define_special LEX (2)		/ special_entries \
	/ special_table :			/ LEX (2) NEXT_STMT				/ mainloop \

          / function_key_table : <new_table_name> ;
                                                  / LEX (2) define_fkey_table LEX (2)               / fkey_entries \
          / function_key_table :                  / LEX (2) NEXT_STMT                               / mainloop \

	/ default_types :			/ LEX (2) [default_count = 1]			/ default_types \

	/ answerback :			/ LEX (2) set_up_answerback			/ answerback \

	/ preaccess_command :		/ LEX (2)					/ preaccess \
\" 

	\" global statements

	/ Modes :				/ LEX (2) PUSH (mainloop) PUSH (dft_modes)	/ check_modes \
	/ Bauds :				/ LEX (2) [baudx = 1]			/ default_bauds \
	/ Bps :				/ LEX (2) [baudx = 1]			/ default_bauds \
	/ BPS :				/ LEX (2) [baudx = 1]			/ default_bauds \
	/ Cps :				/ LEX (2) [baudx = 1]			/ default_cps \
	/ CPS :				/ LEX (2) [baudx = 1]			/ default_cps \
	/ Line_types :			/ LEX (2) PUSH (mainloop) PUSH (dft_line_types)	/ line_types \
	/ Erase : <valid_edit> ;		/ LEX (2) [dft.erase = make_char ()] LEX (2)	/ mainloop \
	/ Erase : <any-token>		/ LEX (2) ERROR (3) NEXT_STMT			/ mainloop \
	/ Kill : <valid_edit > ;		/ LEX (2) [dft.kill = make_char ()] LEX (2)	/ mainloop \
	/ Kill : <any-token>		/ LEX (2) ERROR (3) NEXT_STMT			/ mainloop \
	/ Framing_chars : <tty_char> <tty_char> ;
					/ LEX (2) [dft.frame_begin = make_char ()]
					  LEX [dft.frame_end = make_char ()]
					  LEX (2)					/ mainloop \
	/ Framing_chars : <any-token>		/ LEX (2) ERROR (6) NEXT_STMT			/ mainloop \
	/ Line_delimiter : <tty_char> ;	/ LEX (2) [dft.line_delimiter = make_char ()] LEX (2)
					  					 / mainloop \
	/ Line_delimiter : <any-token>	/ LEX (2) ERROR (6) NEXT_STMT			/ mainloop \
	/ Input_suspend : <tty_char> ;	/ LEX (2) [dft.input_suspend = make_char ()] LEX (2)
					  					 / mainloop \
	/ Input_suspend : <any-token>		/ LEX (2) ERROR (6) NEXT_STMT			/ mainloop \
	/ Input_resume : <tty_char> ;		/ LEX (2) [dft.input_resume = make_char ()] LEX (2)
					  					 / mainloop \
	/ Input_resume : <tty_char> , timeout ; / LEX (2) [dft.input_resume = make_char (); dft.input_timeout = "1"b] LEX (4)
					  					/ mainloop \
	/ Input_resume : <any-token>		/ LEX (2) ERROR (6) NEXT_STMT			/ mainloop \
	/ Output_suspend : <tty_char> ;	/ LEX (2) [if dft.output_block_acknowledge then call ERROR (42);
						 else do;
					  	   dft.output_suspend_etb = make_char ();
						   dft.output_block_acknowledge = "0"b;
						   out_sus_set = "1"b;
						 end]
					  LEX (2)					/ mainloop \
	/ Output_suspend : <any-token>		/ LEX (2) ERROR (6) LEX (2)		/ mainloop \
	/ Output_resume : <tty_char> ;	/ LEX (2) [if dft.output_block_acknowledge then call ERROR (42);
						 else do;
						   dft.output_resume_ack = make_char ();
						   dft.output_block_acknowledge = "0"b;
						   out_sus_set = "1"b;
						 end]
					  LEX (2)					/ mainloop \
	/ Output_resume : <any-token>		/ LEX (2) ERROR (6) NEXT_STMT			/ mainloop \
	/ Buffer_size : <decimal-integer> ;	/ LEX (2) [if out_sus_set then call ERROR (42);
						 else do;
					  	   dft.output_buffer_size = token.Nvalue;
						   dft.output_block_acknowledge = "1"b;
						   block_ack_set = "1"b;
						 end]
					  LEX (2)					/ mainloop \
	/ Buffer_size : <any-token>		/ LEX (2) ERROR (6) NEXT_STMT			/ mainloop \
	/ Output_end_of_block : <tty_char> ;	/ LEX (2) [if out_sus_set then call ERROR (42);
						 else do;
					  	   dft.output_suspend_etb = make_char ();
						   dft.output_block_acknowledge = "1"b;
						   block_ack_set = "1"b;
						 end]
					  LEX (2)					/ mainloop \
	/ Output_end_of_block : <any-token>	/ LEX (2) ERROR (6) NEXT_STMT			/ mainloop \
	/ Output_acknowledge : <tty_char> ;	/ LEX (2) [if out_sus_set then call ERROR (42);
						 else do;
					  	   dft.output_resume_ack = make_char ();
						   dft.output_block_acknowledge = "1"b;
						   block_ack_set = "1"b;
						 end]
					  LEX (2)					/ mainloop \
	/ Output_acknowledge : <any-token>	/ LEX (2) ERROR (6) NEXT_STMT			/ mainloop \
	/ Keyboard_addressing :		/ LEX (2) [bitp = addr (dft.keyboard_addressing)] PUSH (mainloop)
					  					/ yes_no \
	/ Print_preaccess_message :		/ LEX (2) [bitp = addr (dft.print_preaccess_message)] PUSH (mainloop)
					  					/ yes_no \
	/ Conditional_printer_off :		/ LEX (2) [bitp = addr (dft.conditional_printer_off)] PUSH (mainloop)
					  					/ yes_no \

	/ Input_conversion : ;		/ LEX (3) [dft.input_conversion_rp = 0]		/ mainloop \
	/ Input_conversion : <legal_name> ;	/ LEX (2) set_table (dft.input_conversion_rp, CONV_TYPE) LEX (2)
					  					/ mainloop \

	/ Output_conversion : ;		/ LEX (3) [dft.output_conversion_rp = 0]	/ mainloop \
	/ Output_conversion : <legal_name> ;	/ LEX (2) set_table (dft.output_conversion_rp, CONV_TYPE) LEX (2)
					  					/ mainloop \

	/ Input_translation : ;		/ LEX (3) [dft.input_translation_rp = 0]	/ mainloop \
	/ Input_translation : <legal_name> ;	/ LEX (2) set_table (dft.input_translation_rp, TRANS_TYPE) LEX (2)
					  					/ mainloop \

	/ Output_translation : ;		/ LEX (3) [dft.output_translation_rp = 0]	/ mainloop \
	/ Output_translation : <legal_name> ;	/ LEX (2) set_table (dft.output_translation_rp, TRANS_TYPE) LEX (2)
					  					/ mainloop \

	/ Special : ;			/ LEX (3) [dft.special_rp = 0]		/ mainloop \
	/ Special : <legal_name> ;	 	/ LEX (2) set_table (dft.special_rp, SPEC_TYPE) LEX (2)
					  					/ mainloop \

          / Function_keys : ;                     / LEX (3) [tte.fkey_rp = 0]			/ mainloop \
          / Function_keys : <legal_name> ;        / LEX (2) set_table (tte.fkey_rp, FKEY_TYPE) LEX (2)
					  					/ mainloop \

	/ Video_info : ;			/ LEX (3) [dft_extended_tablesp -> extended_tables.tables_rp (VIDEO_RP) = 0]
					  					/ mainloop \
	/ Video_info :			/ LEX (2) [extended_tablesp = dft_extended_tablesp]
						define_video
					          [dft_extended_tables_defined = "1"b] PUSH (mainloop)
					  					/ video_table \
          / Dsatm_device : ;                      / LEX (3) [dft_extended_tablesp -> extended_tables.tables_rp (DSATM_DEVICE_RP) = 0]
					  					/ mainloop \
          / Dsatm_device :                        / LEX (2) [extended_tablesp = dft_extended_tablesp]
                                                            define_dsatm_device
                                                            [dft_extended_tables_defined = "1"b] PUSH (mainloop)
					  		
                       / dsatm_device_table \
	/ Old_type : <decimal-integer> ;	/ LEX (2) [dft.old_type = token.Nvalue] LEX (2)	/ mainloop \

	/ end ;				/ LEX (2)					/ finish \
	/ <any-token> :			/ ERROR (5) NEXT_STMT			/ mainloop \
	/ <any-token>			/ ERROR (6) NEXT_STMT			/ mainloop \
	/ <no-token>			/ ERROR (7)				/ RETURN \

	\" terminal type entry statements

type_entry
	/ ;				/ LEX					/ type_statements \
	/ like <defined_type> ;		/ LEX copy_type LEX (2)			/ type_statements \
	/ <any-token>			/ ERROR (6) NEXT_STMT			/ type_statements \

type_statements
	/ modes :				/ LEX (2) PUSH (type_statements) PUSH (entry_modes) / check_modes \
	/ additional_info : 		/ LEX (2) PUSH (type_statements) [p = addr (tte.additional_info)]
										/ char_string \
	/ initial_string :			/ LEX (2) PUSH (type_statements) [p = addr (tte.initial_string)]
										/ char_string \
	/ comment :			/ LEX (2) PUSH (type_statements) [p = addr (tte.comment)]
										/ char_string \
	/ bauds :				/ LEX (2) [baudx = 1]			/ bauds \
	/ bps :				/ LEX (2) [baudx = 1]			/ bauds \
	/ cps :				/ LEX (2) [baudx = 1]			/ cps \

	/ vert_nl_delays :			/ LEX (2) [delayx = 1]			/ delays \
	/ horz_nl_delays :			/ LEX (2) [delayx = 2]			/ delays \
	/ const_tab_delays :		/ LEX (2) [delayx = 3]			/ delays \
	/ var_tab_delays :			/ LEX (2) [delayx = 4]			/ delays \
	/ backspace_delays :		/ LEX (2) [delayx = 5]			/ delays \
	/ vt_ff_delays :			/ LEX (2) [delayx = 6]			/ delays \

	/ line_types :			/ LEX (2) PUSH (type_statements) PUSH (entry_line_types)
										/ line_types \
	/ erase : <valid_edit> ;		/ LEX (2) [tte.erase = make_char ()] LEX (2)	/ type_statements \
	/ erase: <any-token>		/ LEX (2) ERROR (3) NEXT_STMT			/ type_statements \
	/ kill : <valid_edit> ;		/ LEX (2) [tte.kill = make_char ()] LEX (2)	/ type_statements \
	/ kill : <any-token>		/ LEX (2) ERROR (3) NEXT_STMT			/ type_statements \
	/ framing_chars : <tty_char> <tty_char> ;
					/ LEX (2) [tte.frame_begin = make_char ()]
					  LEX [tte.frame_end = make_char ()] LEX (2)
										/ type_statements \
	/ framing_chars : <any-token>		/ LEX (2) ERROR (6) NEXT_STMT			/ type_statements \

	/ line_delimiter : <tty_char> ;	/ LEX (2) [tte.line_delimiter = make_char ()] LEX (2) / type_statements \
	/ line_delimiter : <any-token>	/ LEX (2) ERROR (6) NEXT_STMT			/ type_statements \
	/ input_suspend : <tty_char> ;	/ LEX (2) [tte.input_suspend = make_char ()] LEX (2) / type_statements \
	/ input_suspend : <any-token>		/ LEX (2) ERROR (6) NEXT_STMT			/ type_statements \
	/ input_resume : <tty_char> ;		/ LEX (2) [tte.input_resume = make_char ()] LEX (2) / type_statements \
	/ input_resume : <tty_char> , timeout ; / LEX (2) [tte.input_resume = make_char (); tte.input_timeout = "1"b] LEX (4) / type_statements \
	/ input_resume : <any-token>		/ LEX (2) ERROR (6) NEXT_STMT			/ type_statements \
	/ output_suspend : <tty_char> ;	/ LEX (2) [if block_ack_set then call ERROR (42); else do;
					  tte.output_suspend_etb = make_char (); tte.output_block_acknowledge = "0"b; out_sus_set = "1"b; end]
					  LEX (2)					/ type_statements \
	/ output_suspend : <any-token>		/ LEX (2) ERROR (6) LEX (2)		/ type_statements \
	/ output_resume : <tty_char> ;	/ LEX (2) [if block_ack_set then call ERROR (42); else do;
					  tte.output_resume_ack = make_char (); tte.output_block_acknowledge = "0"b; out_sus_set = "1"b; end]
					  LEX (2)					/ type_statements \
	/ output_resume : <any-token>		/ LEX (2) ERROR (6) NEXT_STMT			/ type_statements \
	/ buffer_size : <decimal-integer> ;	/ LEX (2) [if out_sus_set then call ERROR (42); else do;
					  tte.output_buffer_size = token.Nvalue; tte.output_block_acknowledge = "1"b; block_ack_set = "1"b; end]
					  LEX (2)					/ type_statements \
	/ buffer_size : <any-token>		/ LEX (2) ERROR (6) NEXT_STMT			/ type_statements \
	/ output_end_of_block : <tty_char> ;	/ LEX (2) [if out_sus_set then call ERROR (42); else do;
					  tte.output_suspend_etb = make_char (); tte.output_block_acknowledge = "1"b; block_ack_set = "1"b; end]
					  LEX (2)					/ type_statements \
	/ output_end_of_block : <any-token>	/ LEX (2) ERROR (6) NEXT_STMT			/ type_statements \
	/ output_acknowledge : <tty_char> ;	/ LEX (2) [if out_sus_set then call ERROR (42); else do;
					  tte.output_resume_ack = make_char (); tte.output_block_acknowledge = "1"b; block_ack_set = "1"b; end]
					  LEX (2)					/ type_statements \
	/ output_acknowledge : <any-token>	/ LEX (2) ERROR (6) NEXT_STMT			/ type_statements \
	/ keyboard_addressing :		/ LEX (2) [bitp = addr (tte.keyboard_addressing)] PUSH (type_statements)
										/ yes_no \
	/ print_preaccess_message :		/ LEX (2) [bitp = addr (tte.print_preaccess_message)] PUSH (type_statements)
										/ yes_no \
	/ conditional_printer_off :	 	/ LEX (2) [bitp = addr (tte.conditional_printer_off)] PUSH (type_statements)
										/ yes_no \

	/ input_conversion : ;		/ LEX (3) [tte.input_conversion_rp = 0]		/ type_statements \
	/ input_conversion : <legal_name> ;	/ LEX (2) set_table (tte.input_conversion_rp, CONV_TYPE) LEX (2)
										/ type_statements \

	/ output_conversion : ;		/ LEX (3) [tte.output_conversion_rp = 0]	/ type_statements \
	/ output_conversion : <legal_name> ;	/ LEX (2) set_table (tte.output_conversion_rp, CONV_TYPE) LEX (2)
										/ type_statements \

	/ input_translation : ;		/ LEX (3) [tte.input_translation_rp = 0]	/ type_statements \
	/ input_translation : <legal_name> ;	/ LEX (2) set_table (tte.input_translation_rp, TRANS_TYPE) LEX (2)
										/ type_statements \

	/ output_translation : ;		/ LEX (3) [tte.output_translation_rp = 0]	/ type_statements \
	/ output_translation : <legal_name> ;	/ LEX (2) set_table (tte.output_translation_rp, TRANS_TYPE) LEX (2)
										/ type_statements \

	/ special : ;			/ LEX (3) [tte.special_rp = 0]		/ type_statements \
	/ special : <legal_name> ;	 	/ LEX (2) set_table (tte.special_rp, SPEC_TYPE) LEX (2)
										/ type_statements \


          / function_keys : ;                     / LEX (3) [tte.fkey_rp = 0]                       / type_statements \
          / function_keys : <legal_name> ;        / LEX (2) set_table(tte.fkey_rp, FKEY_TYPE) LEX(2)
                                                                                                    / type_statements \

          / protocol : ;                          / LEX (3) [tte.protocol = 0]
                       / type_statements \
          / protocol :                            / LEX (2) [tte.protocol = get_protocol()] LEX(2)
                       / type_statements \
                     
	/ video_info : ;			/ LEX (3) set_extended [extended_tables.tables_rp (VIDEO_RP) = 0]
										/ type_statements \
	/ video_info :			/ LEX (2) set_extended define_video PUSH (type_statements)
										/ video_table \


	/ dsatm_device : ;			/ LEX (3) set_extended [extended_tables.tables_rp (DSATM_DEVICE_RP) = 0]
										/ type_statements \
	/ dsatm_device :			/ LEX (2) set_extended define_dsatm_device PUSH (type_statements)
										/ dsatm_device_table \

	/ old_type : <decimal-integer> ;	/ LEX (2) [tte.old_type = token.Nvalue] LEX (2)
										/ type_statements \

	/ <any-token>			/ finish_type				/ mainloop \
	/ <no-token>			/ ERROR (7)				/ RETURN \


	\" yes_no subroutine

yes_no	/ yes ;		/ [bitp -> based_bit1 = "1"b]  LEX (2)	/ STACK_POP \
          / YES ;             / [bitp -> based_bit1 = "1"b]  LEX (2)  / STACK_POP \
	/ no ;		/ [bitp -> based_bit1 = "0"b]  LEX (2)	/ STACK_POP \
          / NO ;              / [bitp -> based_bit1 = "0"b]  LEX (2)  / STACK_POP \
	/ <any-token> ;	/ ERROR (4) NEXT_STMT		/ STACK_POP \
	/ <any-token>	/ ERROR (6) NEXT_STMT		/ STACK_POP \
	/ <no-token>	/ ERROR (7)			/ RETURN \


	\" default_bauds subroutine

default_bauds
	/ <valid_baud>	/ [dft_bauds (baudx) = token.Nvalue; baudx = baudx + 1] LEX
							/ default_bauds \
	/		/ PUSH (default_bauds)		/ general_dft_baud \

general_dft_baud
	/ other		/ [dft_bauds (baudx) = 0; baudx = baudx + 1] LEX
							/ STACK_POP \
	/ ;		/ [n_dft_bauds = baudx - 1] LEX POP	/ mainloop \

	/ <any-token>	/ ERROR (8) POP NEXT_STMT		/ mainloop \
	/ <no-token>	/ ERROR (7)			/ RETURN \

default_cps
	/ <valid_cps>	/ [dft_bauds (baudx) = cps_baud_value; baudx = baudx + 1] LEX
							/ default_cps \
	/		/ PUSH (default_cps)		/ general_dft_baud \


	\" bauds subroutine

bauds	/ <valid_baud>	/ make_delay_entry ((token.Nvalue)) [baudx = baudx + 1] LEX
							/ bauds \
	/		/ PUSH (bauds)			/ general_baud \

general_baud
	/ other		/ make_delay_entry (0) LEX		/ STACK_POP \
	/ ;		/ LEX  POP			/ type_statements \
	/ <any-token>	/ ERROR (8) POP  NEXT_STMT		/ type_statements \
	/ <no-token>	/ ERROR (7)			/ RETURN \

cps	/ <valid_cps>	/ make_delay_entry (cps_baud_value) [baudx = baudx + 1] LEX
							/ cps \
	/		/ PUSH (cps)			/ general_baud \


	\" subroutine for initial_string, comment or additional_info

char_string
	/ ;		/ [p -> based_two_words (*) = 0] LEX			/ STACK_POP \
	/ <quoted-string> ;	/ copy_string (p) LEX (2)				/ STACK_POP \
	/		/ [exp_char_index, unexp_char_index = 1; rep_depth, expanded(*), unexpanded(*) = 0; rep_error, rep_used = "0"b;]
								          / string_item \

string_item
	/ <rep_err_found>	/ NEXT_STMT					/ STACK_POP \
	/ <quoted-string>	/ insert_quoted_string LEX				/ string_item \
	/ <tty_char>	/ [ call insert_single_char ((token.Nvalue)) ] LEX	/ string_item \

	/ ( <decimal-integer> ) <_
			/ LEX push_rep LEX (3)				/ string_item \

	/ >_		/ pop_rep LEX					/ string_item \
	/ ;		/ store_string (p) LEX				/ STACK_POP \
	/ <any-token>	/ ERROR (6) NEXT_STMT				/ STACK_POP \
	/ <no-token>	/ ERROR (7)					/ RETURN \

	\" subroutine for delay statements

delays	/		/ [n_spec = 0; delay_error_printed = "0"b] / delay_token \

delay_token
	/ <delay_value>	/ set_delay  LEX			/ delay_token \
	/ ;		/ LEX				/ type_statements \
	/ <any-token>	/ ERROR (9) NEXT_STMT		/ type_statements \
	/ <no-token>	/ ERROR (7)			/ RETURN \


	\" line_types subroutine

line_types
	/ ;		/ LEX				/ STACK_POP \
	/		/ [line_type_str = ""b]		/ line_type_values \

line_type_values
	/ <valid_line_type>	/ [substr (line_type_str, token.Nvalue, 1) = "1"b] LEX
							/ next_line_type \
	/ <any-token>	/ ERROR (10) NEXT_STMT		/ STACK_POP \
	/ <no-token>	/ ERROR (7)			/ RETURN \

next_line_type
	/ ,		/ LEX				/ line_type_values \
	/ ;		/ LEX				/ STACK_POP \

entry_line_types
	/		/ [tte.line_types = line_type_str]	/ STACK_POP \

dft_line_types
	/		/ [dft.line_types = line_type_str]	/ STACK_POP \

	\" subroutine to construct conversion/translation tables

table_entries
	/ <no_table>	/ NEXT_STMT			/ mainloop \
	/		/ [entryx = 0]			/ table_entry \

table_entry
	/ <tty_char>	/ [if entryx > hbound (tablep -> cv_trans.value, 1) then call semant_error (11, cur_table_name, "");
			  else temp_table (entryx) = token.Nvalue; entryx = entryx + 1]  LEX
							/ table_entry \

	/ ;		/ [if entryx < 128 then call semant_error (12, cur_table_name, "")] LEX
							/ mainloop \

	/ <any-token>	/ semant_error (13, cur_table_name, token_value) NEXT_STMT / mainloop \
	/ <no-token>	/ ERROR (7)			/ RETURN \

	\" subroutine for constructing special_chars table

special_entries
	/ new_line :	/ LEX (2) [p = addr (temp_special_table.nl_seq)] PUSH (single_sequence) / sequence \
	/ carriage_return :	/ LEX (2) [p = addr (temp_special_table.cr_seq)] PUSH (single_sequence) / sequence \
	/ backspace :	/ LEX (2) [p = addr (temp_special_table.bs_seq)] PUSH (single_sequence) / sequence \
	/ tab :		/ LEX (2) [p = addr (temp_special_table.tab_seq)] PUSH (single_sequence) / sequence \
	/ vertical_tab :	/ LEX (2) [p = addr (temp_special_table.vt_seq)] PUSH (single_sequence) / sequence \
	/ form_feed :	/ LEX (2) [p = addr (temp_special_table.ff_seq)] PUSH (single_sequence) / sequence \
	/ printer_on :	/ LEX (2) [p = addr (temp_special_table.printer_on)] PUSH (single_sequence) / sequence \
	/ printer_off :	/ LEX (2) [p = addr (temp_special_table.printer_off)] PUSH (single_sequence) / sequence \
	/ red_shift :	/ LEX (2) [p = addr (temp_special_table.red_ribbon_shift)] PUSH (single_sequence) / sequence \
	/ black_shift :	/ LEX (2) [p = addr (temp_special_table.black_ribbon_shift)] PUSH (single_sequence) / sequence \
	/ end_of_page :	/ LEX (2) [p = addr (temp_special_table.end_of_page)] PUSH (single_sequence) / sequence \

	/ output_escapes :	/ LEX (2) [esc_p = addr (not_edited); not_edited (*) = 0]		/ output_escapes \
	/ edited_output_escapes :
			/ LEX (2) [esc_p = addr (edited); edited (*) = 0]			/ output_escapes \
	/ input_escapes :	/ LEX (2) [count = 0]					/ input_escapes \

	/ <any-token>	/ check_special						/ mainloop \
	/ <no-token>	/ ERROR (7)						/ RETURN \

output_escapes
	/		/ [max_output_escapes = 0]					/  \
output_indicator
	/ <indicator_value>	/ PUSH (escape_sequences) [p = addr (esc_p -> escapes (token.Nvalue - 16));
			max_output_escapes = max (max_output_escapes, token.Nvalue - 16)] LEX
										/ sequence \

	/ <any-token>	/ ERROR (14) NEXT_STMT					/ special_entries \
	/ <no-token>	/ ERROR (7)						/ RETURN \

sequence	/ <no_table>	/ NEXT_STMT [STACK_DEPTH = 0]					/ special_entries \
	/		/ [count = 0]						/ sequence_values \

sequence_values
	/ <tty_char>	/ [count = count + 1; if count > hbound (c_chars.chars, 1) then call ERROR (15);
			else addr (p -> c_chars.chars (count)) -> based_fb8 = token.Nvalue] LEX
										/ sequence_values \
	/ <any-token>	/							/ STACK_POP \
	/ <no-token>	/ ERROR (7)						/ RETURN \

escape_sequences
	/ ,		/ [p -> c_chars.count = count] LEX				/ output_indicator \
single_sequence
	/ ;		/ [p -> c_chars.count = count] LEX				/ special_entries \
	/ <any-token>	/ ERROR (16) NEXT_STMT					/ special_entries \
	/ <no-token>	/ ERROR (7)						/ RETURN \

input_escapes
	/ <no_table>	/ NEXT_STMT						/ special_entries \

	/ <tty_char>	/ [count = count + 1; addr (input_escapes.str) -> fb8_array (count) = token.Nvalue] LEX
										/ input_result \

input_esc_error
	/ <any-token>	/ ERROR (6) NEXT_STMT					/ special_entries \
	/ <no-token>	/ ERROR (7)						/ RETURN \

input_result
	/ <tty_char>	/ [addr (input_results.str) -> fb8_array (count) = token.Nvalue] LEX	/ next_esc \
	/		/							/ input_esc_error \

next_esc
	/ ,		/ LEX							/ input_escapes \
	/ ;		/ LEX [input_escapes.len = count]				/ special_entries \
	/		/							/ input_esc_error \

          \" function_key_data table

fkey_entries
fkey_loop
          / home :            / LEX (2) start_fkey_seq(addr(function_key_data.home(0)))   / fkey_entry \
          / left :            / LEX (2) start_fkey_seq(addr(function_key_data.left(0)))   / fkey_entry \
          / right :           / LEX (2) start_fkey_seq(addr(function_key_data.right(0)))  / fkey_entry \
          / up :              / LEX (2) start_fkey_seq(addr(function_key_data.up(0)))     / fkey_entry \
          / down :            / LEX (2) start_fkey_seq(addr(function_key_data.down(0)))   / fkey_entry \
          / key ( <decimal-integer> ) :
                              / LEX (2) [token.Nvalue = bin(token_value, 35, 0)]
                                init_fkey_area((token.Nvalue))
                                start_fkey_seq(addr(function_key_data.function_keys(token.Nvalue, 0))) LEX (3)
                                                                                          / fkey_entry \
          / <any-token>       / finish_fkey_table                                         / mainloop \
          / <no-token>        / ERROR (7)                                                 / RETURN \

fkey_entry
          / <fkey_entry_err>  / statement_error(52, cur_table_name, "") NEXT_STMT         / fkey_entries \

fkey_seq
          / <quoted-string>   / insert_quoted_string LEX                                  / fkey_seq \
          / <tty_char>        / insert_single_char((token.Nvalue)) LEX                    / fkey_seq \
          / ,                 / end_fkey_seq LEX                                          / fkey_entry \
          / ;                 / end_fkey_seq LEX                                          / fkey_entries \
          / <any-token>       / ERROR (50) NEXT_STMT                                      / fkey_entries \
          / <no-token>        / ERROR (7)                                                 / RETURN \

	\" default_types table

default_types
	/ <valid_baud>	/ [temp_dftte (default_count).baud = token.Nvalue] LEX	/ dftt_line_type \
	/ any		/ [temp_dftte (default_count).baud = 0]  LEX		/ dftt_line_type \
	/ <any-token>	/ ERROR (8) LEX					/ dftt_line_type \
	/ <no-token>	/ ERROR (7)					/ RETURN \

dftt_line_type
	/ <valid_dft_line_type>
			/ [temp_dftte (default_count).line_type = token.Nvalue] LEX	/ dft_term_type \
	/ any		/ [temp_dftte (default_count).line_type = 0]  LEX		/ dft_term_type \
	/ <any-token>	/ ERROR (10) LEX					/ dft_term_type \
	/ <no-token>	/ ERROR (7)					/ RETURN \

dft_term_type
	/ <defined_type>	/ [temp_dftte (default_count).term_type_index = token.Nvalue] LEX
									/ next_default \
	/ <legal_name>	/ [temp_dftte (default_count).type_name = token_value] LEX	/ next_default \
	/ <any-token>	/ LEX						/ next_default \

next_default
	/ ,		/ [default_count = default_count + 1] LEX		/ default_types \
	/ ;		/ LEX [temp_dftt.dft_count = default_count] check_for_any	/ mainloop \
	/ <any-token>	/ ERROR (6) NEXT_STMT				/ mainloop \
	/ <no-token>	/ ERROR (7)					/ RETURN \

	\" answerback table

answerback
	/ match		/ [answerback_entry.def_string.chars (ansbck_char_index) = "m"] LEX	/ match_string \
	/ search		/ [answerback_entry.def_string.chars (ansbck_char_index) = "s"] LEX	/ match_string \
	/ skip <decimal-integer>
			/ LEX [answerback_entry.def_string.chars (ansbck_char_index) = "k";
			addr (answerback_entry.def_string.chars (ansbck_char_index+1)) -> based_fb8 = token.Nvalue;
			ansbck_char_index = ansbck_char_index + 2] LEX			/ next_spec \

	/ id <decimal-integer>
			/ LEX [answerback_entry.def_string.chars (ansbck_char_index) = "i";
			addr (answerback_entry.def_string.chars (ansbck_char_index+1)) -> based_fb8 = token.Nvalue;
			ansbck_char_index = ansbck_char_index + 2] LEX			/ next_spec \

	/ id rest		/ [answerback_entry.def_string.chars (ansbck_char_index) = "i";
			answerback_entry.def_string.chars (ansbck_char_index+1) = NUL_CHAR;
			ansbck_char_index = ansbck_char_index + 2] LEX (2)		/ next_spec \

ansbck_error
	/ <any-token>	/ ERROR (17) NEXT_STMT					/ ans_back_type \
	/ <no-token>	/ ERROR (7)						/ RETURN \

match_string
	/ <quoted-string>	/ [addr (answerback_entry.def_string.chars (ansbck_char_index+1)) -> based_fb8 = token.Lvalue;
			substr (answerback_entry.def_string.chars (1), ansbck_char_index+2, token.Lvalue)
			= token_value; ansbck_char_index = ansbck_char_index + token.Lvalue + 2] LEX
										/ next_spec \

	/ digit		/ [addr (answerback_entry.def_string.chars (ansbck_char_index+1)) -> based_fb8 = -2;
			ansbck_char_index = ansbck_char_index + 2] LEX			 / next_spec \

	/ letter		/ [addr (answerback_entry.def_string.chars (ansbck_char_index+1)) -> based_fb8 = -1;
				ansbck_char_index = ansbck_char_index + 2] LEX		/ next_spec \


	/ <any-token>	/ ERROR (17) LEX						/ next_spec \
	/ <no-token>	/ ERROR (7)						/ RETURN \

next_spec
	/ ,		/ LEX							/ answerback \
	/ ;		/ LEX [answerback_entry.def_string.length = ansbck_char_index - 1]	/ ans_back_type \
	/		/							/ ansbck_error \

ans_back_type
	/ type : ;	/ LEX (3)							/ mainloop \
	/ type : <defined_type> ;
			/ LEX (2) [answerback_entry.term_type_index = token.Nvalue] LEX (2)	/ mainloop \
	/ type :		/ LEX (2) ERROR (18) NEXT_STMT				/ mainloop \
	/ <any-token>	/							/ mainloop \
	/ <no-token>	/ ERROR (7)						/ RETURN \

	\"Video stuff 6/3/79 - BSG

video_table

video_loop
	/ clear_screen :	/ LEX (2) start_vseq (CLEAR_SCREEN)				/ vseq \
	/ clear_to_eos :	/ LEX (2) start_vseq (CLEAR_TO_EOS)				/ vseq \
	/ home :		/ LEX (2) start_vseq (HOME)				/ vseq \
	/ clear_to_eol :	/ LEX (2) start_vseq (CLEAR_TO_EOL)				/ vseq \
	/ cursor_up :	/ LEX (2) start_vseq (CURSOR_UP)				/ vseq \
	/ cursor_right :	/ LEX (2) start_vseq (CURSOR_RIGHT)				/ vseq \
	/ cursor_down :	/ LEX (2) start_vseq (CURSOR_DOWN)				/ vseq \
	/ cursor_left :	/ LEX (2) start_vseq (CURSOR_LEFT)				/ vseq \
	/ insert_chars :	/ LEX (2) start_vseq (INSERT_CHARS)				/ vseq \
	/ end_insert_chars : / LEX (2) start_vseq (END_INSERT_CHARS)			/ vseq \
	/ delete_chars :	/ LEX (2) start_vseq (DELETE_CHARS)				/ vseq \
	/ insert_lines :	/ LEX (2) start_vseq (INSERT_LINES)				/ vseq \
	/ delete_lines :	/ LEX (2) start_vseq (DELETE_LINES)				/ vseq \
	/ abs_pos :	/ LEX (2) start_vseq (ABS_POS)				/ vseq \
	/ screen_height : <decimal-integer> ;	/ LEX (2) [tty_video_table.screen_height = token.Nvalue] LEX (2)
										/ video_loop \
	/ screen_line_length : <decimal-integer> ; / LEX (2) [tty_video_table.screen_line_length = token.Nvalue] LEX (2)
										/ video_loop \
	/ scroll_count : <decimal-integer> ; / LEX (2) [tty_video_table.scroll_count = token.Nvalue] LEX (2)
										/ video_loop \
	/ <any-token>		/ finish_video_table				/ STACK_POP \
	/ <no-token>		/ ERROR (7) 					/ RETURN \
vseq
vseq_loop
	/ <quoted-string>	/ insert_quoted_string LEX					/ vseq_loop \
	/ ;		/ LEX end_vseq						/ video_loop \

	/ (		/ LEX							/ vseq_numeric_expr \
	/ <tty_char>	/ insert_single_char ((token.Nvalue)) LEX			/ vseq_loop \
	/ , pad <decimal-integer> ms  / LEX (2) video_encode_pad (1000 * token.Nvalue) LEX (2)	/ vseq_loop \
	/ , pad <decimal-integer> us  / LEX (2) video_encode_pad ((token.Nvalue)) LEX (2)	/ vseq_loop \
	/ , pad <decimal-integer>	/ LEX (2) [tty_video_seq.flags.cpad_present, tty_video_seq.flags.cpad_in_chars = "1"b]
				  [tty_video_seq.cpad = token.Nvalue] LEX		/ vseq_loop \
	/ <any-token>		/ ERROR (48) NEXT_STMT				/ video_loop \
	/ <no-token>		/ ERROR (7)					/ RETURN \


vseq_numeric_expr
	/		/ [unspec (temp_numeric_encoding) = "0"b]
			  [temp_numeric_encoding.must_be_on = "1"b]			/ \
	\" Open paren pre-parsed out
	/ binary		/ LEX							/ vseq_numencode_1 \
	/ decimal <decimal-integer> / [temp_numeric_encoding.flags.express_in_decimal = "1"b]
				LEX [temp_numeric_encoding.num_digits = token.Nvalue] LEX 	/ vseq_numencode_1 \
	/ decimal			/ LEX [temp_numeric_encoding.num_digits = 0]
				  [temp_numeric_encoding.express_in_decimal = "1"b]	/ vseq_numencode_1 \
	/ octal  <decimal-integer> / [temp_numeric_encoding.flags.express_in_octal = "1"b]
				LEX [temp_numeric_encoding.num_digits = token.Nvalue] LEX 	/ vseq_numencode_1 \
	/ octal			/ LEX [temp_numeric_encoding.num_digits = 0]
				  [temp_numeric_encoding.express_in_octal = "1"b]		/ vseq_numencode_1 \

vseq_numencode_1
	/ line		/ [temp_numeric_encoding.l_c_or_n = 0] LEX 			/ vseq_numencode_2 \
	/ LINE		/ [temp_numeric_encoding.l_c_or_n = 0] LEX 			/ vseq_numencode_2 \
	/ column		/ [temp_numeric_encoding.l_c_or_n = 1] LEX 			/ vseq_numencode_2 \
	/ COLUMN		/ [temp_numeric_encoding.l_c_or_n = 1] LEX 			/ vseq_numencode_2 \
	/ n		/ [temp_numeric_encoding.l_c_or_n = 2] LEX 			/ vseq_numencode_2 \
	/ N		/ [temp_numeric_encoding.l_c_or_n = 2] LEX 			/ vseq_numencode_2 \
	/ <any-token>	/ ERROR (46) NEXT_STMT POP					/ video_loop \
	/ <no-token>	/ ERROR (7)						/ RETURN \
vseq_numencode_2
	/ + <tty_char>	/ LEX [temp_numeric_encoding.offset  = token.Nvalue] LEX		/ vseq_numencode_3 \
	/ - <tty_char>	/ LEX [temp_numeric_encoding.offset = - token.Nvalue] LEX		/ vseq_numencode_3 \

vseq_numencode_3
	/ )		/ LEX [if temp_numeric_encoding.offset = 0 then temp_numeric_encoding.offset_is_0 = "1"b]
										/ \
	/		/ insert_single_char (bin (substr (unspec (temp_numeric_encoding), 1, 9)))
	  [if ^temp_numeric_encoding.offset_is_0 then call insert_single_char (bin (substr (unspec (temp_numeric_encoding), 10, 9)))]
	  [if temp_numeric_encoding.l_c_or_n = 2 then tty_video_seq.flags.able_to_repeat = "1"b]
			  [tty_video_seq.flags.interpret = "1"b]			/ vseq_loop \
	/ <any-token>	/ ERROR (46) NEXT_STMT POP					/ video_loop \
	/ <no-token>	/ ERROR (7)						/ RETURN \


	\"DSA TM stuff 12/21/84 Roger Negaret
          \" description of the negotiation information for a logical device

dsatm_device_table
dsatmdev_loop

          / data_presentation : ;                 / LEX (3) / dsatmdev_loop \
          / data_presentation :                   / LEX (2) / dpp \

          / sdp_class : ;                         / LEX (3) /dsatmdev_loop \
          / sdp_class :			/ LEX (2) / sdp_class \

          / real_class : ;			/ LEX (3) / dsatmdev_loop \
          / real_class :			/ LEX (2) / real_class \

          / device_id : ;			/ LEX (3) / dsatmdev_loop \
          / device_id : <decimal-integer> ;       / LEX (2) [dsatm_device.dev_id = token.Nvalue] LEX (2)                                 / dsatmdev_loop \

          / device_type : ;			/ LEX (3) / dsatmdev_loop \
          / device_type : <legal_dev_type> ;	/ LEX (2) [dsatm_device.dev_type = name_idx] LEX (2)                                   / dsatmdev_loop \

          / shareability : ;			/ LEX (3) / dsatmdev_loop \
          / shareability : <legal_shareability> ; / LEX (2) [dsatm_device.shareability = name_idx] LEX (2)                               / dsatmdev_loop \

          / allocation_unit : ;	          / LEX (3) / dsatmdev_loop \
          / allocation_unit : <legal_alloc_unit>  / LEX (2) set_alloc_unit LEX                                                           / alloc_unit \

          / line_overflow : ;			/ LEX (3) / dsatmdev_loop \
          / line_overflow : <legal_line_overflow> ; / LEX (2) [dsatm_device.line_overflow = name_idx] LEX (2)                            / dsatmdev_loop \

          / page_overflow : ;			/ LEX (3) / dsatmdev_loop \
          / page_overflow : <legal_page_overflow> ; / LEX (2) [dsatm_device.page_overflow = name_idx] LEX (2)                            / dsatmdev_loop \

          / character_encoding : ;		/ LEX (3) / dsatmdev_loop \
          / character_encoding :		/ LEX (2) / char_encoding \

          / character_set : ;			/ LEX (3) / dsatmdev_loop \
          / character_set :			/ LEX (2) / char_set \

          / character_subset : ;		/ LEX (3) / dsatmdev_loop \
          / character_subset :		/ LEX (2) / char_subset \

          / national_language : ;		/ LEX (3) / dsatmdev_loop \
          / national_language:		/ LEX (2) / nat_lang \

          / compression_algorithm : ;		/ LEX (3) / dsatmdev_loop \
          / compression_algorithm :		/ LEX (2) / compression \

          / character_font : ;		/ LEX (3) / dsatmdev_loop \
          / character_font :			/ LEX (2) / char_font \

          / max_record_size : ;		/ LEX (3) / dsatmdev_loop \
          / max_record_size : <decimal-integer> ; / LEX (2) [dsatm_device.max_rec_size = token.Nvalue] LEX (2)                           / dsatmdev_loop \

          / attd : ;                              / LEX (3) / dsatmdev_loop \
          / attd : <legal_attd> ;  / LEX (4)                / dsatmdev_loop \

          / att1 : ;                         / LEX (3)      / dsatmdev_loop \
          / att1 : <legal_att1> ;  / LEX (4)                / dsatmdev_loop \

          / stc_available :                 / LEX (2) [bitp = addr (dsatm_device.stc_available)] PUSH (dsatmdev_loop)                   / yes_no \

          / <any-token>		          / finish_dsatm_device                                                                 / STACK_POP \

          / <no-token>		          / ERROR (7) 			                                              / RETURN \

dpp

          / ;               			/ [dsatm_device.dpp_nb = dppx] LEX 									       / dsatmdev_loop \
          / <legal_dpp>                           / set_dpp LEX                  		/ dpp \
	/ <any-token>			/ ERROR (55) NEXT_STMT			/ dsatmdev_loop \
          / <no-token>		 	/ ERROR (7) 				/ RETURN \

sdp_class

          / ; 				/ [dsatm_device.sc_nb = scx] LEX 									       / dsatmdev_loop \
          / <legal_sdp_class> 		/ set_sdp_class  LEX			/ sdp_class \
	/ <any-token>			/ ERROR (55) NEXT_STMT			/ dsatmdev_loop \
          / <no-token>			/ ERROR (7) 				/ RETURN \

real_class

          / ; 				/ [dsatm_device.rc_nb = rcx] LEX 									       / dsatmdev_loop \
          / <legal_real_class> 		/ set_real_class  LEX			/ real_class \
	/ <any-token>			/ ERROR (55) NEXT_STMT			/ dsatmdev_loop \
          / <no-token>			/ ERROR (7) 				/ RETURN \

alloc_unit

          / ; 				/  LEX                                            / dsatmdev_loop \
          / <legal_alloc_unit> 		/ set_alloc_unit  LEX			/ alloc_unit \
	/ <any-token>			/ ERROR (55) NEXT_STMT			/ dsatmdev_loop \
          / <no-token>			/ ERROR (7) 				/ RETURN \

char_encoding
          
          / ;                                     / [dsatm_device.ce_nb = cex] LEX                  / dsatmdev_loop \
          / <legal_char_encoding> 		/ set_char_encoding LEX			/ char_encoding \
	/ <any-token>			/ ERROR (55) NEXT_STMT			/ dsatmdev_loop \
          / <no-token>			/ ERROR (7) 				/ RETURN \

char_set

          / ; 				/ [dsatm_device.cs_nb = csx] LEX 									       / dsatmdev_loop \
          / <legal_char_set> 			/ set_char_set LEX			/ char_set \
	/ <any-token>			/ ERROR (55) NEXT_STMT			/ dsatmdev_loop \
          / <no-token>			/ ERROR (7) 				/ RETURN \

char_subset

          / ; 				/ [dsatm_device.css_nb = cssx] LEX 									       / dsatmdev_loop \
          / <legal_char_subset> 		/ set_char_subset LEX			/ char_subset \
	/ <any-token>			/ ERROR (55) NEXT_STMT			/ dsatmdev_loop \
          / <no-token>			/ ERROR (7) 				/ RETURN \

char_font

          / ; 				/ [dsatm_device.cf_nb = cfx] LEX 									       / dsatmdev_loop \
          / <legal_char_font> 		/ set_char_font LEX			/ char_font \
	/ <any-token>			/ ERROR (55) NEXT_STMT			/ dsatmdev_loop \
          / <no-token>			/ ERROR (7) 				/ RETURN \

nat_lang

          / ; 				/ [dsatm_device.nl_nb = nlx] LEX 									       / dsatmdev_loop \
          / <legal_nat_lang> 			/ set_nat_lang LEX			/ nat_lang \
	/ <any-token>			/ ERROR (55) NEXT_STMT			/ dsatmdev_loop \
          / <no-token>			/ ERROR (7) 				/ RETURN \

compression

          / ; 				/ [dsatm_device.ca_nb = cax] LEX 									       / dsatmdev_loop \
          / <legal_compression> 		/ set_compression LEX			/ compression \
	/ <any-token>			/ ERROR (55) NEXT_STMT			/ dsatmdev_loop \
          / <no-token>			/ ERROR (7) 				/ RETURN \

          \" END of the DSA TM stuff

	\" preaccess command types

preaccess
	/ MAP ;		/ [p = addr (ttt.type_map); pa_type = 1] LEX (2)		/ preaccess_type \
	/ map ;		/ [p = addr (ttt.type_map); pa_type = 1] LEX (2)		/ preaccess_type \
	/ <any-token>	/ ERROR (34) NEXT_STMT				/ mainloop \
	/ <no-token>	/ ERROR (7)					/ RETURN \

preaccess_type
	/ type : <defined_type> ;
			/ LEX (2) [p -> based_fb = token.Nvalue] LEX (2)		/ mainloop \
	/ type :		/ LEX (2) ERROR (18) NEXT_STMT			/ mainloop \
	/ <any-token>	/ semant_error (35, pa_name (pa_type), "")		/ mainloop \
	/ <no-token>	/ ERROR (7)					/ RETURN \

	\" mode checking

check_modes
	/		/ [mode_string = ""]			/  \
	/ ;	 	/ LEX					/ STACK_POP \

next_mode
	/ <valid_mode>	/ [mode_string = mode_string || token_value] LEX	/ delim \
	/ <any-token>	/ ERROR (2) [mode_string = mode_string || token_value] LEX
								/ delim \
mode_err	/ <no-token>	/ ERROR (7)				/ RETURN \

delim
	/ ,		/ [mode_string = mode_string || ","] LEX	/ next_mode \
	/ ;		/ LEX					/ STACK_POP \
	/ <any-token>	/ ERROR (40) NEXT_STMT POP			/ STACK_POP \
	/		/					/ mode_err \

dft_modes
	/		/ [dft.modes = mode_string]			/ STACK_POP \

entry_modes
	/		/ [tte.modes = mode_string]			/ STACK_POP \


	\" end statement handler

finish
	/ <any-token>	/ ERROR (27)				/ RETURN \
	/ <no-token>	/					/ RETURN \

					++*/
%page;
/* format: style4 */
cv_ttf: proc;


/* External Entries */

dcl  com_err_ entry options (variable);
dcl  com_err_$suppress_name entry () options (variable);
dcl  cu_$arg_count entry (fixed bin, fixed bin (35));
dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin);
dcl  cv_oct_check_ entry (char (*), fixed bin (35)) returns (fixed bin);
dcl  expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35));
dcl  expand_pathname_$add_suffix entry (char (*), char (*), char (*), char (*), fixed bin (35));
dcl  get_group_id_ entry returns (char (32));
dcl  get_temp_segments_ entry (char (*), (*) ptr, fixed bin (35));
dcl  get_wdir_ entry returns (char (168));
dcl  hcs_$delentry_seg entry (ptr, fixed bin (35));
dcl  hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
dcl  hcs_$set_bc_seg entry (ptr, fixed bin (24), fixed bin (35));
dcl  hcs_$truncate_seg entry (ptr, fixed bin, fixed bin (35));
dcl  initiate_file_ entry (char (*), char (*), bit (*), ptr, fixed bin (24), fixed bin (35));
dcl  ioa_ entry options (variable);
dcl  lex_error_ entry options (variable);
dcl  lex_string_$init_lex_delims entry (char (*), char (*), char (*), char (*), char (*), bit (*), char (*) varying, char (*) varying, char (*) varying, char (*) varying);
dcl  lex_string_$lex entry (ptr, fixed bin (21), fixed bin (21), ptr, bit (*), char (*), char (*), char (*), char (*), char (*), char (*) varying, char (*) varying, char (*) varying, char (*) varying, ptr, ptr, fixed bin (35));
dcl  pathname_ entry (char (*), char (*)) returns (char (168));
dcl  release_temp_segments_ entry (char (*), (*) ptr, fixed bin (35));
dcl  suffixed_name_$new_suffix entry (char (*), char (*), char (*), char (32), fixed bin (35));
dcl  terminate_file_ entry (ptr, fixed bin (24), bit (*), fixed bin (35));
dcl  translator_temp_$get_segment entry (char (*), ptr, fixed bin (35));
dcl  translator_temp_$release_all_segments entry (ptr, fixed bin (35));


/* External Static */

dcl  cv_ttf_severity_ fixed bin (35) ext init (0);

dcl  dsatm_data_$device_multics_dft ext aligned;

dcl  (error_table_$badopt,
     error_table_$noentry,
     error_table_$too_many_args,
     error_table_$zero_length_seg,
     error_table_$noarg,
     error_table_$bad_conversion,
     error_table_$translation_failed) fixed bin (35) ext static;


/* Internal Static */

dcl  ALL_CAPS char (26) int static options (constant) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
dcl  ALL_LOWERCASE char (26) int static options (constant) init ("abcdefghijklmnopqrstuvwxyz");
dcl  BS char (1) int static options (constant) init ("");	/* backspace */
dcl  LEGAL_CHARS char (63) int static options (constant) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_");
dcl  NUL_CHAR char (1) int static options (constant) init (" "); /* NUL char (all zero) */
dcl  already_called bit (1) int static init ("0"b);
dcl  breaks char (43) varying int static;
dcl  ctl_chars char (32) varying int static;
dcl  lexctl char (80) varying int static;
dcl  lexdlm char (80) varying int static;
dcl  max_rep_depth fixed bin int static options (constant) init (2);
dcl  prog_name char (6) int static options (constant) init ("cv_ttf");
dcl  translation_failure fixed bin int static options (constant) init (3);


/* Automatic */

dcl  ans_back_table_ptr ptr init (null ());		/* ptr to work area for answerback tables */
dcl  ans_size fixed bin (18);				/* # words in specific answerback table entry */
dcl  ansbck_char_index fixed bin;			/* used in storing parsed answerback entry */
dcl  arg char (argl) based (argp);			/* overlay for input arg */
dcl  argc fixed bin;				/* # input args */
dcl  argl fixed bin;				/* length of specific input arg */
dcl  argp ptr;					/* ptr to specific input arg */
dcl  argx fixed bin;				/* which input arg being processed */
dcl  baud_error_printed bit (1);			/* flag for single output of baud error statement */
dcl  baudx fixed bin;				/* baud table entry index */
dcl  bit_count fixed bin (24);			/* input TTF bit_count */
dcl  bitp ptr init (null ());				/* misc bit string ptr */
dcl  block_ack_set bit (1);				/* flag to denote block ACK used in this type entry */
dcl  cax fixed bin;					/* used in dsatm_device coding (compression index) */
dcl  cex fixed bin;					/* used in dsatm_device coding (character encoding index) */
dcl  cfx fixed bin;					/* used in dsatm_device coding (character font index) */
dcl  check_0nums bit (1);
dcl  code fixed bin (35);				/* general error code */
dcl  count fixed bin;				/* c_chars.count temp counter */
dcl  cps_baud_value fixed bin;			/* equivalent of specified CPS expressed as bps */
dcl  created_table_segment bit (1) aligned;		/* flag to show cv_ttf created output TTT segment */
dcl  cssx fixed bin;				/* used in dsatm_device coding (character subset index) */
dcl  csx fixed bin;					/* used in dsatm_device coding (character set index) */
dcl  ct_table_offset fixed bin (18);			/* offset to next conversion table entry */
dcl  cur_delay_value fixed bin;			/* temp value of current delay value being processed */
dcl  cur_table_name char (32);			/* name of current table being processed */
dcl  default_count fixed bin;				/* counter for default_types temp entry */
dcl  defined fixed bin;				/* denotes new table name has entry for it in table_names */
dcl  delay_error_printed bit (1);			/* flag for single output of delay error statement */
dcl  delay_stmt bit (1);				/* flag to denote delay statement found */
dcl  delayx fixed bin;				/* delay table type index */
dcl  dft_bauds (12) fixed bin;			/* array of baud rates specified in Bauds statement */
dcl  dft_extended_tables_defined bit (1);		/* denotes have one or more default extended tables defined */
dcl  dft_extended_tablesp ptr init (null ());		/* ptr to any default extended tables */
dcl  dirname char (168);				/* directory for input TTF */
dcl  dppx fixed bin;				/* used in dsatm_device coding */
dcl  edited (1024) fixed bin;				/* placeholders for output escape sequences */
dcl  entryx fixed bin;				/* count of entries in conversion/translation table */
dcl  esc_p ptr init (null ());			/* ptr to special string to store edited/non-edited output escape values in */
dcl  extended_tables_workp ptr init (null ());		/* ptr to work area for all extended tables */
dcl  fb35 fixed bin (35);				/* general fixed bin (35) storage value */
dcl  fkey_table_offset fixed bin (18);			/* offset to start next function key table at */
dcl  fkey_tables_ptr ptr init (null ());		/* ptr to work area for function key tables */
dcl  floating_delay_value float bin;			/* general floating value for delay item */
dcl  got_temps bit (1);				/* flag to show have temp segments */
dcl  highest fixed bin;
dcl  i fixed bin;
dcl  increment fixed bin (18);
dcl  j fixed bin;
dcl  length_in_words fixed bin;
dcl  line_type_str bit (72);
dcl  max_output_escapes fixed bin;
dcl  max_values char (2);
dcl  maxind fixed bin (8);
dcl  misc_relocs_count fixed bin;
dcl  misc_relocs_ptr ptr init (null ());		/* ptr to work area for all relocs */
dcl  misc_tables_ptr ptr init (null ());		/* ptr to work area where will build all misc tables */
dcl  mode_line_length fixed bin;
dcl  mode_page_length fixed bin;
dcl  mode_string char (256) varying;
dcl  n_answerbacks fixed bin;
dcl  n_dft_bauds fixed bin;
dcl  n_fkey_tables fixed bin;
dcl  n_spec fixed bin;				/* number of delay values specified */
dcl  n_special_tables fixed bin;
dcl  n_table_names fixed bin;
dcl  n_tables fixed bin;
dcl  name_idx fixed bin;
dcl  name_to_test_for char (32);			/* translated name to check tables for */
dcl  new_delay_table_ptr ptr init (null ());
dcl  next_misc_offset fixed bin (18);
dcl  next_offset fixed bin (18);
dcl  nlx fixed bin;
dcl  not_edited (1024) fixed bin;
dcl  num_0nums fixed bin;
dcl  off_sw bit (1);
dcl  out_sus_set bit (1);
dcl  p ptr init (null ());
dcl  pa_type fixed bin;
dcl  prev_ptr ptr init (null ());
dcl  rcx fixed bin;
dcl  real_name char (32);
dcl  rep_depth fixed bin;
dcl  rep_error bit (1);
dcl  rep_factor (2) fixed bin;
dcl  rep_length fixed bin;
dcl  rep_start (2) fixed bin;
dcl  rep_used bit (1);
dcl  scx fixed bin;
dcl  seqs_index fixed bin;
dcl  size_of_ttt fixed bin (18);
dcl  sourcep ptr init (null ());
dcl  spec_offset fixed bin (18);
dcl  special_tables_ptr ptr init (null ());		/* ptr to area where special tables will be built */
dcl  specialp ptr init (null ());
dcl  stmtp ptr init (null ());
dcl  supplied_ename char (32);
dcl  table_names_ptr ptr init (null ());		/* ptr to work area for names of all tables */
dcl  table_size fixed bin (18);
dcl  tables_ptr ptr init (null ());			/* ptr to work area for tables entries */
dcl  targetp ptr init (null ());
dcl  temp_dfttp ptr init (null ());			/* ptr to temp copy of dftt with type names */
dcl  temp_strings_ptr ptr init (null ());		/* ptr to work area for all temp strings */
dcl  temp_ptr (10) ptr init ((10) null ());
dcl  temp_ttep ptr init (null ());
dcl  tempp ptr init (null ());
dcl  test_value char (8);
dcl  ttf_ename char (32);
dcl  ttfp ptr init (null ());
dcl  ttt_ename char (32);
dcl  wdir char (168);

dcl  1 dft aligned like tte;				/* for default values */

dcl  1 input_escapes aligned,
       2 len fixed bin (8) unal,
       2 str char (128) unal;

dcl  1 input_results aligned like input_escapes;


/* Based */

dcl  based_bit1 bit (1) based;
dcl  based_fb fixed bin based;
dcl  based_fb8 fixed bin (8) unal based;
dcl  based_fb17 fixed bin (17) unal based;
dcl  based_two_words (2) fixed bin based;
dcl  exp_string char (2048) based (addr (expanded));
dcl  fb8_array (count) fixed bin (8) unal based;
dcl  misc_strings (next_misc_offset) fixed bin based;
dcl  temp_table (0:255) fixed bin (8) unal based (tablep);
dcl  unexp_string char (2048) based (addr (unexpanded));

dcl  1 dummy_dftte based aligned like dftt.dftte;		/* for taking "size" of */

dcl  1 escapes (max_output_escapes) aligned based like c_chars;

dcl  1 extended_tables_work aligned based (extended_tables_workp),
       2 seqs char (4096),
       2 table fixed bin (71);			/* put a table here */

dcl  1 table_names (n_table_names) based (table_names_ptr) aligned,
       2 name char (32) unal,
       2 type fixed bin,				/* 1 = conv/trans, 2 = special */
       2 offset fixed bin (18);			/* -1 = undefined */

dcl  misc_relocs (misc_relocs_count) ptr unal based (misc_relocs_ptr);

dcl  1 temp_dftt based (temp_dfttp),			/* temporary copy of dftt, with type names */
       2 dft_count fixed bin,
       2 temp_dftte (0 refer (temp_dftt.dft_count)),
         3 entry like dftt.dftte,
         3 type_name char (32);

dcl  temp_key_index fixed bin;
dcl  temp_key_infop ptr init (null ());

dcl  1 temp_key_info (0:3) aligned based (temp_key_infop) like key_info;

dcl  1 temp_special_table aligned based (tablep),
       2 nl_seq aligned like c_chars,			/* new-line sequence */
       2 cr_seq aligned like c_chars,			/* carriage-return sequence */
       2 bs_seq aligned like c_chars,			/* backspace sequence */
       2 tab_seq aligned like c_chars,			/* horizontal tab sequence */
       2 vt_seq aligned like c_chars,			/* vertical tab sequence */
       2 ff_seq aligned like c_chars,			/* form-feed sequence */
       2 printer_on aligned like c_chars,		/* printer-on sequence */
       2 printer_off aligned like c_chars,		/* printer_off sequence */
       2 red_ribbon_shift aligned like c_chars,		/* red ribbon shift sequence */
       2 black_ribbon_shift aligned like c_chars,		/* black ribbon shift sequence */
       2 end_of_page aligned like c_chars,		/* end-of-page warning sequence */

       2 escape_length fixed bin,			/* number of escape sequences */
       2 not_edited_escapes (sc_escape_len refer (temp_special_table.escape_length)) like c_chars, /* use in ^edited mode */
       2 edited_escapes (sc_escape_len refer (temp_special_table.escape_length)) like c_chars, /* use in edited mode */

       2 input_escapes aligned,
         3 len fixed bin (8) unaligned,			/* length of string */
         3 str char (sc_input_escape_len refer (temp_special_table.input_escapes.len)) unaligned, /* escape sequence characters */
       2 input_results aligned,
         3 pad bit (9) unaligned,			/* so that strings will look the same */
         3 str char (sc_input_escape_len refer (temp_special_table.input_escapes.len)) unaligned; /* results of escape sequences */

dcl  1 temp_numeric_encoding unaligned like tty_numeric_encoding automatic;

dcl  1 temp_strings aligned based (temp_strings_ptr),
       2 exp_char_index fixed bin,
       2 unexp_char_index fixed bin,
       2 expanded (2048) fixed bin (8) unal,
       2 unexpanded (2048) fixed bin (8) unal,
       2 rep_item char (2048) varying;

/* Conditions */

dcl  (cleanup, conversion) condition;


/* Builtins */

dcl  (addr, addrel, baseno, bin, byte, char, collate, currentsize, dimension, divide, float, hbound, index, lbound,
     length, ltrim, max, mod, null, ptr, rank, rel, rtrim, size, substr, translate, unspec, verify) builtin;
%page; %include access_mode_values;
%page; %include author_dcl;
%page; %include baud_rates;
%page; %include dsatm_attn_fcn_info;
%page; %include dsatm_negotiate_info;
%page; %include dsatm_tty_modes;
%page; %include function_key_data;
%page; %include line_types;
%page; %include term_type_protocols;
%page; %include terminate_file;
%page; %include ttt;
%page; %include tty_can_types;
%page; %include tty_mode_names;
%page; %include tty_video_tables;
%page;
/* introductory setup */

	ttfp, tttp, tempp, temp_ptr (*) = null;		/* setup for clean_up */
	dft_extended_tablesp = null;
	c_chars_ptr = null;				/* make the compiler happy */
	got_temps = ""b;
	created_table_segment = ""b;
	dirname, supplied_ename, ttf_ename, ttt_ename = "";
	check_0nums = "0"b;

	on cleanup begin;
	     call clean_up;
	     cv_ttf_severity_ = 5;
	end;

	call cu_$arg_count (argc, code);
	if code ^= 0 then do;
	     call com_err_ (code, prog_name);
	     go to severity_5_failure;
	end;
	if argc < 1
	then do;
give_usage:    call com_err_$suppress_name (0, prog_name,
		"Usage:  cv_ttf ttf_name [-brief | -long]");
	     go to severity_5_failure;
	end;

	do argx = 1 to argc;
	     call cu_$arg_ptr (argx, argp, argl, code);
	     if char (arg, 1) ^= "-"
	     then do;
		if supplied_ename ^= ""
		then do;
		     call com_err_ (error_table_$too_many_args, prog_name, "Only one pathname may be given. ^a was the second.", arg);
		     go to severity_5_failure;
		end;

		call expand_pathname_ (arg, dirname, supplied_ename, code);
		if code ^= 0 then do;
path_error:
		     call com_err_ (code, prog_name, "^a", arg);
		     go to severity_5_failure;
		end;
		call expand_pathname_$add_suffix (arg, "ttf", dirname, ttf_ename, code);
		if code ^= 0 then go to path_error;

		call suffixed_name_$new_suffix (supplied_ename, "ttf", "ttt", ttt_ename, code); /* if we get this far, how can we fail? */
		if code ^= 0			/* still, let's have a look */
		then go to path_error;

	     end;					/* Pathname case */
	     else if arg = "-bf" | arg = "-brief"
	     then SERROR_CONTROL = "01"b;

	     else if arg = "-lg" | arg = "-long"
	     then SERROR_CONTROL = "10"b;

	     else if arg = "-ck1dig" then do;
		check_0nums = "1"b;			/* they made me change the name from ck0num to ck1dig */
		num_0nums = 0;
	     end;

	     else if arg = "-severity" | arg = "-sv" then do;
		if argx >= argc then do;
		     call com_err_ (error_table_$noarg, prog_name, "After ""^a"".", arg);
		     go to severity_5_failure;
		end;
		argx = argx + 1;
		call cu_$arg_ptr (argx, argp, argl, code);
		fb35 = cv_dec_check_ (arg, code);
		if code ^= 0 | fb35 < 0 | fb35 > 5 then do;
		     call com_err_ (error_table_$bad_conversion, prog_name,
			"Severity must be an integer in the range 0 - 5, not ""^a"".", arg);
		     go to severity_5_failure;
		end;
		MIN_PRINT_SEVERITY = fb35;
	     end;

	     else do;
		code = error_table_$badopt;
arg_error:	call com_err_ (code, prog_name, arg);
		go to severity_5_failure;
	     end;
	end;					/* argument processing loop */
	if supplied_ename = "" then go to give_usage;

/* initialize some variables */

	n_tables, n_answerbacks, n_table_names, n_dft_bauds, ct_table_offset, spec_offset, fkey_table_offset, default_count = 0;
	dsatmdevp = null;

	next_misc_offset = 1;			/* so that no valid offset will be zero */

	call initiate_file_ (dirname, ttf_ename, R_ACCESS, ttfp, bit_count, code);
	if code = error_table_$noentry
	then if ttf_ename ^= supplied_ename
	     then do;
		call initiate_file_ (dirname, supplied_ename, R_ACCESS, ttfp, bit_count, code);
		if code = 0
		then do;
		     call com_err_ (0, prog_name, "Warning: converting ^a. The segment should be named ^a.",
			pathname_ (dirname, supplied_ename), ttf_ename);
		     ttf_ename = supplied_ename;
		end;
	     end;
	if code ^= 0
	then do;
ttf_error:     call com_err_ (code, prog_name, "^a.", pathname_ (dirname, ttf_ename));
	     go to severity_5_failure;
	end;
	if bit_count = 0 then do;
	     code = error_table_$zero_length_seg;
	     go to ttf_error;
	end;

/* now create segment in which to build TTT */

	wdir = get_wdir_ ();
	call hcs_$make_seg (wdir, ttt_ename, "", 01010b, tttp, code);
	created_table_segment = (code = 0);
	if tttp = null
	then go to ttt_error;

	call hcs_$truncate_seg (tttp, 0, code);		/* start clean */
	if code ^= 0
	then do;
ttt_error:     call com_err_ (code, prog_name, ttt_ename);
	     go to severity_5_failure;
	end;

/* get a bunch of temporary segments for pieces of TTT */

	call get_temp_segments_ (prog_name, temp_ptr, code);
	if code ^= 0
	then do;
	     call com_err_ (code, prog_name, "Creating temporary segments");
	     go to severity_5_failure;
	end;

	got_temps = "1"b;
	tables_ptr = temp_ptr (1);
	special_tables_ptr = temp_ptr (2);
	misc_tables_ptr = temp_ptr (3);
	ans_back_table_ptr = temp_ptr (4);
	table_names_ptr = temp_ptr (5);
	temp_dfttp = temp_ptr (6);
	extended_tables_workp = temp_ptr (7);
	misc_relocs_ptr = temp_ptr (8);
	fkey_tables_ptr = temp_ptr (9);
	temp_strings_ptr = temp_ptr (10);
	misc_relocs_count = 0;

/* Set up TTT header */

	ttt.author.proc_group_id = get_group_id_ ();
	ttt.last_install_time = 0;
	ttt.lock = ""b;
	ttt.author.table = "TTT";
	ttt.author.w_dir = substr (wdir, 1, length (ttt.author.w_dir));
	ttt.version = TTT_version_4;

/* initialize default structure */

	ttep = addr (ttt.tt_entries (1));
	dft = tte;				/* all zero */
	dft.name = "";
	dft.modes = "";
	dft.protocol = 0;
	dft.line_types = (72)"1"b;			/* all valid initially */
	dft.erase = "#";
	dft.kill = "@";

	allocate extended_tables set (dft_extended_tablesp);
	dft_extended_tablesp -> extended_tables.tables_rp (*) = 0;
	dft_extended_tables_defined = "0"b;

/* set up for lex_string_ */

	call translator_temp_$get_segment (prog_name, tempp, code);
	if tempp = null
	then do;
	     call com_err_ (code, prog_name, "From translator_temp_$get_segment");
	     go to severity_5_failure;
	end;

	if ^already_called
	then do;
	     ctl_chars = substr (collate (), 1, 8) || substr (collate (), 10, 24);
	     breaks = ctl_chars || "()<>*,:;";
	     call lex_string_$init_lex_delims ("""", """", "/*", "*/", ";", "10"b, breaks, ctl_chars, lexdlm, lexctl);
	     already_called = "1"b;
	end;

	call lex_string_$lex (ttfp, divide (bit_count, 9, 21, 0), 0, tempp, "1000"b, """", """", "/*", "*/", ";",
	     breaks, ctl_chars, lexdlm, lexctl, stmtp, Pthis_token, code);

/* Go to it! */

	call SEMANTIC_ANALYSIS ();

/*  put everything together */

	if MERROR_SEVERITY >= translation_failure
	then call com_err_ (error_table_$translation_failed, prog_name);

	else do;
	     do i = 1 to n_table_names;		/* append conv/trans tables to TTT */
		if table_names (i).offset = -1	/* oops, this one was never defined */
		then call semant_error (28, table_names (i).name, "");

		else if table_names (i).type ^= SPEC_TYPE & table_names (i).type ^= FKEY_TYPE
		then do;
		     n_tables = n_tables + 1;
		     tablep = addr (ttt.tables (n_tables));
		     table_entry.name = table_names (i).name;
		     table_entry.type = table_names (i).type;
		     sourcep = ptr (tables_ptr, table_names (i).offset);
		     table_entry.table = sourcep -> cv_trans_struc;
		     table_names (i).offset = bin (rel (tablep), 18); /* update offset for later use */
		end;
	     end;

	     ttt.n_tables = n_tables;

/* now special tables */

	     specialp = addr (ttt.rest_of_ttt);
	     next_offset = bin (rel (specialp), 18);

	     n_special_tables = 0;
	     do i = 1 to n_table_names;
		if table_names (i).type = SPEC_TYPE & table_names (i).offset ^= -1
		then do;
		     n_special_tables = n_special_tables + 1;
		     specialp -> special_table.name = table_names (i).name;
		     sourcep = ptr (special_tables_ptr, table_names (i).offset);
		     specialp -> special_table.version = SPECIAL_VERSION_2;
		     specialp -> special_table.default = 0;
		     specialp -> special_table.table.special_chars = sourcep -> special_chars;

		     table_names (i).offset = next_offset;
		     table_size = divide (length (unspec (sourcep -> special_chars)) + 35, 36, 18, 0);
		     next_offset = next_offset + table_size + 11; /* include name and header */
		     specialp = ptr (tttp, next_offset);
		end;
	     end;


	     ttt.n_special_tables = n_special_tables;

/* now function key tables */

	     n_fkey_tables = 0;
	     ttt.fkey_offset = next_offset;

	     do i = 1 to n_table_names;
		if table_names (i).type = FKEY_TYPE & table_names (i).offset ^= -1
		then do;
		     n_fkey_tables = n_fkey_tables + 1;
		     fkey_tablep = ptr (tttp, next_offset);
		     function_key_data_ptr = ptr (fkey_tables_ptr, table_names (i).offset);
		     fkey_table.name = table_names (i).name;
		     fkey_table.version = function_key_data.version;
		     fkey_table.highest = function_key_data.highest;
		     fkey_table.cursor_motion_keys = function_key_data.cursor_motion_keys;
		     fkey_table.function_keys = function_key_data.function_keys;
		     sourcep = function_key_data.seq_ptr; /* move corresponding fkey sequences */
		     targetp = ptr (tttp, next_offset + currentsize (fkey_table));
		     targetp -> function_key_seqs = sourcep -> function_key_seqs;
		     fkey_table.seq_offset = bin (rel (targetp));
		     fkey_table.seq_len = function_key_data.seq_len;
		     table_names (i).offset = next_offset;
		     next_offset = next_offset + currentsize (fkey_table) + currentsize (targetp -> function_key_seqs);
		end;
	     end;
	     ttt.n_fkey_tables = n_fkey_tables;

	     increment = next_offset - 1;		/* to be added to all relative ptrs in tte */
	     targetp = ptr (tttp, next_offset);		/* pointer to next free spot in TTT */
	     misc_tables_ptr = addrel (misc_tables_ptr, 1); /* skip over first (unused) word */
	     next_misc_offset = next_misc_offset - 1;	/* so size of array is right */

	     targetp -> misc_strings = misc_tables_ptr -> misc_strings; /* fill it in */
	     next_offset = next_offset + next_misc_offset;

	     if default_count = 0
	     then do;
		ttt.default_type_offset = 0;
		call ERROR (32);
	     end;

	     else do;
		ttt.default_type_offset = next_offset;
		dfttp = ptr (tttp, next_offset);	/* this is where we will put default_types table */

		do i = 1 to default_count;
		     dftte (i) = temp_dftte (i).entry;
		     if temp_dftte (i).term_type_index = 0 /* default type specified before type defined */
		     then do;
			name_to_test_for = translate (temp_dftte (i).type_name, ALL_CAPS, ALL_LOWERCASE);
			do j = 1 to ttt.n_tt_entries; /* find it now */
			     ttep = addr (ttt.tt_entries (j));
			     if tte.name = name_to_test_for
			     then go to found_match;
			end;

			if j > ttt.n_tt_entries
			then call semant_error (29, temp_dftte (i).type_name, "");
			else
found_match:		     dftte (i).term_type_index = j;

		     end;
		end;

		dftt.dft_count = default_count;
		next_offset = next_offset + default_count * size (dummy_dftte) + 1;
	     end;

	     if n_answerbacks > 0
	     then ttt.answerback_offset = next_offset;
	     else ttt.answerback_offset = 0;

/* now append answerback table */

	     answerback_entry_ptr = ans_back_table_ptr;	/* get pointer to base of temp seg */
	     do i = 1 to n_answerbacks;
		targetp = ptr (tttp, next_offset);

		if i > 1				/* not first one */
		then prev_ptr -> answerback_entry.next = next_offset;

		answerback_length = answerback_entry.length; /* so refer will work when we assign it */
		targetp -> answerback_entry = answerback_entry;

		ans_size = divide (answerback_length + 3, 4, 18, 0) + 3; /* total number of words in entry */
		next_offset = next_offset + ans_size;
		answerback_entry_ptr = addrel (answerback_entry_ptr, ans_size);
		prev_ptr = targetp;
	     end;

	     size_of_ttt, ttt.total_ttt_size = next_offset;

/* go through all entries. for each one, update the relative pointers,
   *  and check for reasonable consistency between output_conversions and
   *  special tables
*/

	     call perform_misc_relocs;

	     highest = 0;

	     do i = 1 to ttt.n_tt_entries;
		ttep = addr (ttt.tt_entries (i));

		call set_table_offset (tte.input_translation_rp);
		call set_table_offset (tte.output_translation_rp);
		call set_table_offset (tte.input_conversion_rp);
		call set_table_offset (tte.output_conversion_rp);
		call set_table_offset (tte.special_rp);
		call set_table_offset (tte.fkey_rp);

		if tte.special_rp <= 0		/* no special table */
		then if tte.output_conversion_rp > 0	/* but there is an output_conversion table */
		     then call semant_error (30, tte.name, "");
		     else ;			/* it's all right not to have either */

		else if tte.output_conversion_rp > 0	/* if we have both, cross-check */
		then do;
		     tablep = ptr (tttp, tte.output_conversion_rp);
		     specialp = ptr (tttp, tte.special_rp);
		     specialp = addr (specialp -> special_table.special_chars);

		     maxind = table_entry.cv_trans.value (0);

		     do j = 1 to hbound (tablep -> cv_trans.value, 1); /* make sure all indicators are represented by sequences */
			if table_entry.cv_trans.value (j) > maxind
			then maxind = table_entry.cv_trans.value (j);
		     end;

		     if maxind > 16			/* any escape sequences at all */
		     then if maxind - 16 > specialp -> special_chars.escape_length
			then call semant_error (31, tte.name, table_entry.name);
		end;

/* check for consistent framing characters */

		if tte.frame_begin ^= NUL_CHAR & tte.frame_end = NUL_CHAR
		then call semant_error (41, tte.name, "");

/* check for consistent flow control specifications */

		if tte.output_block_acknowledge
		then if tte.output_buffer_size = 0 | tte.output_suspend_etb = NUL_CHAR | tte.output_resume_ack = NUL_CHAR
		     then call semant_error (43, tte.name, "");
		     else ;

		else if (tte.output_suspend_etb = NUL_CHAR & tte.output_resume_ack ^= NUL_CHAR) |
		     (tte.output_suspend_etb ^= NUL_CHAR & tte.output_resume_ack = NUL_CHAR)
		then call semant_error (43, tte.name, "");

		if (tte.input_suspend = NUL_CHAR & tte.input_resume ^= NUL_CHAR & ^tte.input_timeout) |
		     (tte.input_suspend ^= NUL_CHAR & tte.input_resume = NUL_CHAR)
		then call semant_error (44, tte.name, "");

/* make sure coded type is reasonable in case this is site's first TTT */

		highest, tte.coded_type = highest + 1;
	     end;

	     ttt.highest_coded_type = highest;		/* if install/up_ttt_ is used, this will be overwritten */

	     if ttt.type_map = 0
	     then call semant_error (35, "MAP", "");	/* warn if preaccess types omitted */

/* essentially all done */

	     if check_0nums
	     then if num_0nums > 0 then call com_err_ (0, prog_name, "^d incompatible character specification^[s^] found",
			num_0nums, num_0nums ^= 1);
		else call ioa_ ("No incompatible character specifications found.");

	     if MERROR_SEVERITY >= translation_failure
	     then do;
		call com_err_ (error_table_$translation_failed, prog_name);
		if created_table_segment then size_of_ttt = -1;
		else size_of_ttt = 0;
	     end;
	     if size_of_ttt >= 0 then do;
		call terminate_file_ (tttp, 36 * size_of_ttt, TERM_FILE_TRUNC_BC_TERM, code);
		if code ^= 0
		then do;
		     call com_err_ (code, prog_name, "Could not set bit count of TTT");
		     go to severity_5_failure;
		end;
	     end;
	end;

	call clean_up;				/* final wrapup */
	cv_ttf_severity_ = MERROR_SEVERITY;
	return;

severity_5_failure:
	call clean_up;
	cv_ttf_severity_ = 5;
	return;
%page;
clean_up: proc;

/* cleanup handler -- makes sure anything we initiated gets terminated, anything we allocated gets freed */

	if ttfp ^= null
	then call terminate_file_ (ttfp, (0), TERM_FILE_TERM, (0));

	if tttp ^= null
	then if created_table_segment
	     then do;
		call hcs_$delentry_seg (tttp, (0));
		tttp = null;
	     end;
	     else call terminate_file_ (tttp, (0), TERM_FILE_TRUNC_BC_TERM, (0));

	if tempp ^= null
	then call translator_temp_$release_all_segments (tempp, (0));
	tempp = null;

	if got_temps
	then call release_temp_segments_ (prog_name, temp_ptr, code);
	got_temps = "0"b;

	if dft_extended_tablesp ^= null () then free dft_extended_tablesp -> extended_tables;

	return;

     end /* clean_up */;

add_increment: proc (rp);

/* internal procedure to add increment to offsets in misc_tables */

dcl  rp fixed bin (18);				/* input as offset in misc_tables, output as correct offset in TTT */

	if rp <= 0 then return;			/* no target */
	else rp = rp + increment;
	return;

     end /* add_increment */;



set_table_offset: proc (rp);

/* internal procedure to set offsets in tte from table_names array */

dcl  rp fixed bin (18);				/* input as index in array, output as correct offset */

	if rp <= 0 then return;			/* no table, leave it alone */
	else rp = table_names (rp).offset;
	return;

     end /* set_table_offset */;

statement_error: proc (error_num, parm1, parm2);

dcl  error_num fixed bin;
dcl  parm1 char (*);
dcl  parm2 char (*);
dcl  (stmt_ptr, token_ptr) ptr init (null);

	stmt_ptr = token.Pstmt;
	token_ptr = Pthis_token;

semant_error: entry (error_num, parm1, parm2);

	if error_control_table (error_num).severity >= MIN_PRINT_SEVERITY
	then call lex_error_ (error_num, SERROR_PRINTED (error_num), (error_control_table.severity (error_num)),
		MERROR_SEVERITY, stmt_ptr, token_ptr, SERROR_CONTROL,
		(error_control_table.message (error_num)), (error_control_table.brief_message (error_num)),
		parm1, parm2);
	else do;
	     MERROR_SEVERITY = max (MERROR_SEVERITY, error_control_table (error_num).severity);
	     SERROR_PRINTED (error_num) = "1"b;
	end;
	return;

     end /* statement_error */;

/* Syntax Functions */


/* returns TRUE if token contains upper/lower case, numeric or underscore */

legal_name: proc returns (bit (1) aligned);

	return (verify (token_value, LEGAL_CHARS) = 0);
     end legal_name;


/* returns TRUE if legal name
   and token_value is either a new table name (defined = 0)
   or references a table which has not been filled in yet (defined = table index) */
new_table_name: proc returns (bit (1) aligned);

	if ^legal_name ()
	then do;
	     call statement_error (19, token_value, "");
	     return ("0"b);
	end;

	if token.Lvalue > 32
	then do;
	     call statement_error (39, token_value, "");
	     return ("0"b);
	end;

	do i = 1 to n_table_names;
	     if table_names.name (i) = token_value
	     then if table_names.offset (i) >= 0
		then do;
		     call statement_error (21, token_value, "");
		     return ("0"b);
		end;

		else do;
		     defined = i;			/* to be used by action routine */
		     return ("1"b);
		end;
	end;

	defined = 0;
	return ("1"b);
     end new_table_name;


/* returns TRUE if legal name and not a currently defined terminal type */

new_type_name: proc returns (bit (1) aligned);

	if ^legal_name () then do;
	     call statement_error (19, token_value, "");
	     return ("0"b);
	end;

	if token.Lvalue > 32
	then do;
	     call statement_error (39, token_value, "");
	     return ("0"b);
	end;

	name_to_test_for = translate (token_value, ALL_CAPS, ALL_LOWERCASE);
	do i = 1 to ttt.n_tt_entries;
	     ttep = addr (ttt.tt_entries (i));
	     if tte.name = name_to_test_for
	     then do;
		call statement_error (20, token_value, "");
		return ("0"b);
	     end;
	end;

	return ("1"b);
     end new_type_name;


valid_mode:
     procedure () returns (bit (1) aligned);

	if substr (token_value, 1, 1) = "^" then do;
	     test_value = substr (token_value, 2);
	     off_sw = "1"b;
	end;
	else do;
	     test_value = token_value;
	     off_sw = "0"b;
	end;

	do i = lbound (modestr, 1) to hbound (modestr, 1);/* see if MCS value */
	     if modestr (i) = test_value then return ("1"b);
	end;

	do i = lbound (TTY_BOOLEAN_MODE_DSA_NAME, 1) to	/* see if DSA value */
	     hbound (TTY_BOOLEAN_MODE_DSA_NAME, 1);
	     if DSA_modestr (i) = test_value then return ("1"b);
	end;

	do i = lbound (CAN_TYPE_NAMES, 1) to hbound (CAN_TYPE_NAMES, 1);
	     if token_value = CAN_TYPE_NAMES (i) then return ("1"b);
	end;

	if (test_value = "force") then		/* either "force" or "^force" */
	     return ("1"b);

	if (token_value = "default") | (token_value = "init") then
	     return ("1"b);				/* these modes can't be negated */

	if (substr (test_value, 1, 2) = "ll") then
	     if (token.Lvalue <= 2) then
		return ("0"b);
	     else do;
		if off_sw then do;
		     if dsatmdevp = null () then mode_line_length = 0;
		     else dsatm_device.line_length = 0;
		     return ("1"b);
		end;
		else do;
		     if substr (test_value, 3, 1) = "=" then
			i = cv_dec_check_ (substr (test_value, 4, token.Lvalue - 3), code);
		     else
			i = cv_dec_check_ (substr (test_value, 3, token.Lvalue - 2), code);
		     if code ^= 0 then return ("0"b);
		     else do;
			if dsatmdevp = null () then mode_line_length = i;
			else dsatm_device.line_length = i;
			return ("1"b);
		     end;
		end;
	     end;

	if (substr (test_value, 1, 2) = "pl") then
	     if (token.Lvalue <= 2) then
		return ("0"b);
	     else do;
		if off_sw then do;
		     if dsatmdevp = null () then mode_page_length = 0;
		     else dsatm_device.page_length = 0;
		     return ("1"b);
		end;
		else do;
		     if substr (test_value, 3, 1) = "=" then
			i = cv_dec_check_ (substr (test_value, 4, token.Lvalue - 3), code);
		     else
			i = cv_dec_check_ (substr (test_value, 3, token.Lvalue - 2), code);
		     if code ^= 0 then return ("0"b);
		     else do;
			if dsatmdevp = null () then mode_page_length = i;
			else dsatm_device.page_length = i;
			return ("1"b);
		     end;
		end;
	     end;

	return ("0"b);				/* here iff not recognized */

     end valid_mode;


valid_edit: proc returns (bit (1) aligned);

	if tty_char () then return (token.Nvalue ^= rank (BS));
	else return ("0"b);

     end /* valid_edit */;


valid_baud: proc returns (bit (1) aligned);

	token.Nvalue = cv_dec_check_ (token_value, code);
	if code ^= 0
	then return ("0"b);

	do i = 1 to hbound (baud_table, 1);
	     if token.Nvalue = baud_table (i)
	     then return ("1"b);
	end;

	return ("0"b);
     end /* valid_baud */;


valid_cps: proc returns (bit (1) aligned);

	token.Nvalue = cv_dec_check_ (token_value, code);
	if code ^= 0
	then return ("0"b);

	if token.Nvalue = 10
	then do;
	     cps_baud_value = 110;
	     return ("1"b);
	end;

	else do;
	     cps_baud_value = token.Nvalue * 10;
	     do i = 1 to hbound (baud_table, 1);
		if cps_baud_value = baud_table (i)
		then return ("1"b);
	     end;

	     return ("0"b);
	end;

     end /* valid_cps */;


delay_value: proc returns (bit (1) aligned);

/* floating point values 0.0 < X < 1.0 */

	if delayx = 2 | delayx = 4
	then do;
	     on conversion go to bad_delay;
	     floating_delay_value = float (token_value);
	     revert conversion;

	     if floating_delay_value < 0 | floating_delay_value > 1.0
	     then
bad_delay:	return ("0"b);
	     else return ("1"b);
	end;

/* fixed point values */
	else do;
	     token.Nvalue = cv_dec_check_ (token_value, code);
	     if code ^= 0
	     then return ("0"b);

	     if delayx = 1 | delayx = 5 then do;
		if token.Nvalue < -127 | token.Nvalue > 127 then
		     return ("0"b);
	     end;
	     else if delayx = 3 then do;
		if token.Nvalue < 0 | token.Nvalue > 127 then
		     return ("0"b);
	     end;
	     else if delayx = 6 then do;
		if token.Nvalue < 0 | token.Nvalue > 511 then
		     return ("0"b);
	     end;

	     return ("1"b);
	end;

     end /* delay_value */;


defined_type: proc returns (bit (1) aligned);

	name_to_test_for = translate (token_value, ALL_CAPS, ALL_LOWERCASE);
	do i = 1 to ttt.n_tt_entries;
	     temp_ttep = addr (ttt.tt_entries (i));
	     if temp_ttep -> tte.name = name_to_test_for
	     then do;
		token.Nvalue = i;
		return ("1"b);
	     end;
	end;

	return ("0"b);
     end /* defined_type */;


valid_line_type: proc returns (bit (1) aligned);

dcl  lowest fixed bin;

	lowest = 1;
	go to check_line_type;

valid_dft_line_type: entry returns (bit (1) aligned);

	lowest = -2;

check_line_type:
	do i = lowest to max_line_type;
	     if token_value = line_types (i)
	     then do;
		token.Nvalue = i;
		return ("1"b);
	     end;
	end;

	return ("0"b);
     end /* valid_line_type */;


octal_char: proc returns (bit (1) aligned);

	if token.Lvalue > 3
	then return ("0"b);

	token.Nvalue = cv_oct_check_ (token_value, code);
	return (code = 0);
     end /* octal_char */;

tty_char: proc returns (bit (1) aligned);

dcl  i fixed bin;
dcl  asc_mnemonic char (3);

dcl  asc_value (0:32) char (3) static options (constant) init
	("nul", "soh", "stx", "etx", "eot", "enq", "ack", "bel",
	"bs ", "tab", "lf ", "vt ", "ff ", "cr ", "so ", "si ",
	"dle", "dc1", "dc2", "dc3", "dc4", "nak", "syn", "etb",
	"can", "em ", "sub", "esc", "fs ", "gs ", "rs ", "us ", "sp ");

	if token.quoted_string & token.Lvalue = 1
	then call return_tty_char (bin (unspec (token_value)));

	if token.Lvalue = 1 then do;
	     if index ("01234567", token_value) ^= 0 then do;
		if check_0nums then do;
		     call ERROR (49);
		     num_0nums = num_0nums + 1;
		     if octal_char () then return ("1"b);
		end;
	     end;
	     if index (breaks, token_value) = 0
	     then call return_tty_char (bin (unspec (token_value)));
	end;
	if octal_char () then return ("1"b);
	if token.Lvalue = 2 & substr (token_value, 1, 1) = "^" then do;
	     i = index ("@abcdefghijklmnopqrstuvwxyz[\]^_", substr (token_value, 2, 1));
	     if i = 0 then i = index ("@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_", substr (token_value, 2, 1));
	     if i = 0 then return ("0"b);
	     call return_tty_char (i - 1);
	end;
	if token.Lvalue <= 3 then do;
	     asc_mnemonic = translate (token_value, ALL_LOWERCASE, ALL_CAPS);
	     if asc_mnemonic = "del" then call return_tty_char (127);
	     if asc_mnemonic = "nl " then call return_tty_char (10);
	     if asc_mnemonic = "pad" then call return_tty_char (0);
	     if asc_mnemonic = "ht" then call return_tty_char (9);
	     do i = lbound (asc_value, 1) to hbound (asc_value, 1);
		if asc_value (i) = asc_mnemonic then call return_tty_char (i);
	     end;

	end;
	return ("0"b);

return_tty_char: proc (a_value);

dcl  a_value fixed bin;

	     token.Nvalue = a_value;
	     go to nlret;
	end return_tty_char;

nlret:	return ("1"b);

     end tty_char;

indicator_value: proc returns (bit (1) aligned);

	if ^octal_char ()
	then return ("0"b);

	return (token.Nvalue > 16);
     end /* indicator_value */;


no_table: proc returns (bit (1) aligned);

	return (tablep = null);
     end /* no_table */;


rep_err_found: proc returns (bit (1) aligned);

	return (rep_error);
     end /* rep_err_found */;

/* Syntax functions for function_key tables */

fkey_entry_err: proc returns (bit (1) aligned);

	if temp_key_index > KEY_CTRL_AND_SHIFT
	then return ("1"b);
	else return ("0"b);

     end fkey_entry_err;

/* ACTION ROUTINES */

init_type: proc;

/* set up a new terminal type entry */

	mode_line_length, mode_page_length = -1;
	dsatmdevp = null ();

	ttt.n_tt_entries = ttt.n_tt_entries + 1;
	ttep = addr (ttt.tt_entries (ttt.n_tt_entries));
	unspec (tte.tables) = "0"b;
	tte = dft;
	tte.name = translate (token_value, ALL_CAPS, ALL_LOWERCASE);
	baud_error_printed, delay_stmt, block_ack_set, out_sus_set = "0"b;
	if dft_extended_tables_defined then do;
	     call set_extended;
	     extended_tables = dft_extended_tablesp -> extended_tables;
	end;

	return;

     end /* init_type */;


finish_type: proc;

	if tte.initial_string.offset ^= 0 then
	     call register_misc_reloc (tte.initial_string.offset);
	if tte.additional_info.offset ^= 0 then
	     call register_misc_reloc (tte.additional_info.offset);
	if tte.delay_rp ^= 0 then
	     call register_misc_reloc (tte.delay_rp);
	if tte.extended_tables_rp ^= 0 then
	     call register_misc_reloc (tte.extended_tables_rp);
	return;

     end finish_type;

get_protocol: proc returns (fixed bin);

	do i = 1 to hbound (protocol_names, 1);
	     if rtrim (token_value) = protocol_names (i) then
		return (protocol_values (i));
	end;

	call ERROR (54);
	return (-1);

     end get_protocol;


define_table: proc (table_type, a_ptr, next_offset);

/* assign an offset to a table */

dcl  table_type fixed bin;
dcl  a_ptr ptr;
dcl  next_offset fixed bin (18);

	if defined > 0				/* its name has been used */
	then if table_names.type (defined) ^= table_type
	     then do;				/* wrong type */
		call statement_error (22, token_value, table_types (table_names.type (defined)));
		tablep = null;
		return;
	     end;
	     else ;

	else do;
	     defined, n_table_names = n_table_names + 1;
	     table_names.name (defined) = token_value;
	     table_names.type (defined) = table_type;
	end;

	table_names.offset (defined) = next_offset;
	cur_table_name = token_value;
	tablep = ptr (a_ptr, next_offset);
	return;
     end /* define_table */;


define_ct_table: proc (table_type);

dcl  table_type fixed bin;

	call define_table (table_type, tables_ptr, ct_table_offset);
	if tablep = null then return;

	ct_table_offset = ct_table_offset + size (cv_trans) + 2;

	tablep -> cv_trans_struc.version = CV_TRANS_VERSION;
	tablep -> cv_trans_struc.default = 0;
	tablep = addrel (tablep, 2);
	return;
     end /* define_ct_table */;

set_extended: proc;

dcl  i fixed bin;

	if tte.extended_tables_rp = 0 then do;
	     extended_tablesp = get_misc_space (size (extended_tables));
	     tte.extended_tables_rp = bin (rel (extended_tablesp));
	     unspec (extended_tables) = "0"b;
	     extended_tables.ntables = extended_tables_ntables;
	     do i = 1 to extended_tables.ntables;
		call register_misc_reloc (extended_tables.tables_rp (i));
	     end;
	end;
	extended_tablesp = ptr (misc_tables_ptr, tte.extended_tables_rp);
	return;

     end set_extended;

define_video: proc;

	ttyvtblp = addr (extended_tables_work.table);	/* build a table here temporarily */
	tty_video_table.nseq = N_VIDEO_SEQUENCES;
	tty_video_table.video_chars_len = 4096;		/* to clear max space */
	unspec (tty_video_table) = "0"b;
	tty_video_table.nseq = N_VIDEO_SEQUENCES;
	tty_video_table.version = tty_video_tables_version_1;
	extended_tables_work.seqs = "";
	seqs_index = 0;
	return;

     end define_video;

finish_video_table: proc;

/* Make a lotta checks:
   abspos, screenlinelne, screenheight must be defined,
   abspos char syntax, extensions, */

dcl  p ptr;

	tty_video_table.video_chars_len = seqs_index;
	if seqs_index > 0 then
	     tty_video_table.video_chars = substr (extended_tables_work.seqs, 1, seqs_index);
	p = get_misc_space (currentsize (tty_video_table));
	extended_tables.tables_rp (VIDEO_RP) = bin (rel (p));
	p -> tty_video_table = tty_video_table;
	ttyvtblp = p;

	return;

     end finish_video_table;

/* start define a new video sequence */

start_vseq: proc (a_seqn);

dcl  a_seqn fixed bin;

	ttyvseqp = addr (tty_video_table.sequences (a_seqn));
	unspec (tty_video_seq) = "0"b;
	exp_char_index, unexp_char_index = 1;
	tty_video_seq.present = "1"b;
	return;

     end start_vseq;

end_vseq: proc;

	if exp_char_index <= 1 then do;		/* not really any sequence */
	     tty_video_seq.present = "0"b;
	     return;
	end;
	tty_video_seq.len = exp_char_index - 1;
	tty_video_seq.seq_index = seqs_index + 1;
	seqs_index = seqs_index + tty_video_seq.len;
	substr (extended_tables_work.seqs, tty_video_seq.seq_index, tty_video_seq.len) = substr (exp_string, 1, tty_video_seq.len);
	return;

     end end_vseq;

/* DSA stuffs */

define_dsatm_device: proc;

dcl  dftdevp ptr init (null ());

	dsatmdevp = addr (extended_tables_work.table);	/* build a table here temporarily */

	/*** initialization with the structure defined in dsatm_data_ */

	dftdevp = addr (dsatm_data_$device_multics_dft);
	dsatmdevp -> dsatm_device = dftdevp -> dsatm_device;

	/*** update of the line and page length from the modes statement */

	if mode_line_length ^= -1 then dsatm_device.line_length = mode_line_length;
	if mode_page_length ^= -1 then dsatm_device.page_length = mode_page_length;

	/*** initialization of the internal variables */

	dppx, scx, rcx, cex, csx, cssx, cfx, nlx, cax = 0;


	/*** initialization of dsatm_device structure */

	dsatm_device.init_accept_confg = 0;
	dsatm_device.dpp (*) = 0;
	dsatm_device.sdp_dpp.version = 0;
	dsatm_device.sdp_dpp.sdp_class (*) = 0;
	dsatm_device.real_dpp.version = 0;
	dsatm_device.real_dpp.real_class (*) = 0;
	dsatm_device.real_dpp.real_model = "";
	dsatm_device.trans_dpp.version = 0;
	dsatm_device.dev_id = 0;
	dsatm_device.dev_type = 0;
	dsatm_device.attribute.shareability = 0;
	dsatm_device.attribute.alloc_unit = "0"b;
	dsatm_device.line_length = 0;
	dsatm_device.page_length = 0;
	dsatm_device.line_overflow = 0;
	dsatm_device.page_overflow = 0;
	dsatm_device.char_encoding (*) = 0;
	dsatm_device.char_set (*) = 0;
	dsatm_device.char_subset (*) = 0;
	dsatm_device.nat_lang (*) = 0;
	dsatm_device.compression (*) = 0;
	dsatm_device.char_font (*) = 0;
	dsatm_device.terminal_type = "";
	dsatm_device.ete_ack_level = 0;
	dsatm_device.max_rec_size = 0;
	unspec (dsatm_device.attentions) = "0"b;
	dsatm_device.stc_available = "0"b;
	unspec (dsatm_device.repetitive_parm_nb) = "0"b;
	unspec (dsatm_device.parm_rejected) = "0"b;

	return;

     end define_dsatm_device;


legal_dpp: proc returns (bit (1) aligned);

	name_to_test_for = translate (token_value, ALL_CAPS, ALL_LOWERCASE);
	do name_idx = 1 to hbound (DPP_NAME, 1);
	     if name_to_test_for = DPP_NAME (name_idx) then return ("1"b);
	end;

	return ("0"b);

     end;

set_dpp: proc;

	dppx = dppx + 1;
	max_values = ltrim (char (hbound (dsatm_device.dpp, 1)));
	if dppx > hbound (dsatm_device.dpp, 1) then call statement_error (56, max_values, "");

	dsatm_device.dpp (dppx) = name_idx;

     end;

legal_sdp_class: proc returns (bit (1) aligned);

	name_to_test_for = translate (token_value, ALL_CAPS, ALL_LOWERCASE);
	do name_idx = 1 to hbound (SC_NAME, 1);
	     if name_to_test_for = SC_NAME (name_idx) then return ("1"b);
	end;

	return ("0"b);

     end;

set_sdp_class: proc;

	scx = scx + 1;
	max_values = ltrim (char (hbound (dsatm_device.sdp_dpp.sdp_class, 1)));
	if scx > hbound (dsatm_device.sdp_dpp.sdp_class, 1) then call statement_error (56, max_values, "");

	dsatm_device.sdp_dpp.sdp_class (scx) = name_idx;

     end;

legal_real_class: proc returns (bit (1) aligned);

	name_to_test_for = translate (token_value, ALL_CAPS, ALL_LOWERCASE);
	do name_idx = 1 to hbound (RC_NAME, 1);
	     if name_to_test_for = RC_NAME (name_idx) then return ("1"b);
	end;

	return ("0"b);

     end;

set_real_class: proc;

	rcx = rcx + 1;
	max_values = ltrim (char (hbound (dsatm_device.real_dpp.real_class, 1)));
	if rcx > hbound (dsatm_device.real_dpp.real_class, 1) then call statement_error (56, max_values, "");

	dsatm_device.real_dpp.real_class (rcx) = name_idx;

     end;

legal_dev_type: proc returns (bit (1) aligned);

	name_to_test_for = translate (token_value, ALL_CAPS, ALL_LOWERCASE);
	do name_idx = 0 to hbound (DT_NAME, 1);
	     if name_to_test_for = DT_NAME (name_idx) then return ("1"b);
	end;

	return ("0"b);

     end;

legal_shareability: proc returns (bit (1) aligned);

	name_to_test_for = translate (token_value, ALL_CAPS, ALL_LOWERCASE);
	do name_idx = 1 to hbound (SH_NAME, 1);
	     if name_to_test_for = SH_NAME (name_idx) then return ("1"b);
	end;

	return ("0"b);

     end;

legal_alloc_unit: proc returns (bit (1) aligned);

	name_to_test_for = translate (token_value, ALL_CAPS, ALL_LOWERCASE);
	do name_idx = 1 to hbound (AU_NAME, 1);
	     if name_to_test_for = AU_NAME (name_idx) then return ("1"b);
	end;

	return ("0"b);

     end;

set_alloc_unit: proc;

	dsatm_device.alloc_unit = dsatm_device.alloc_unit | AU_VALUE (name_idx);

     end;

legal_line_overflow: proc returns (bit (1) aligned);

	name_to_test_for = translate (token_value, ALL_CAPS, ALL_LOWERCASE);
	do name_idx = 2 to hbound (LO_NAME, 1);
	     if name_to_test_for = LO_NAME (name_idx) then return ("1"b);
	end;

	return ("0"b);

     end;

legal_page_overflow: proc returns (bit (1) aligned);

	name_to_test_for = translate (token_value, ALL_CAPS, ALL_LOWERCASE);
	do name_idx = 2 to hbound (PO_NAME, 1) - 1;
	     if name_to_test_for = PO_NAME (name_idx) then return ("1"b);
	end;

	return ("0"b);

     end;

legal_char_encoding: proc returns (bit (1) aligned);

	name_to_test_for = translate (token_value, ALL_CAPS, ALL_LOWERCASE);
	do name_idx = 1 to hbound (CE_NAME, 1);
	     if name_to_test_for = CE_NAME (name_idx) then return ("1"b);
	end;

	return ("0"b);

     end;

set_char_encoding: proc;

	cex = cex + 1;
	max_values = ltrim (char (hbound (dsatm_device.char_encoding, 1)));
	if cex > hbound (dsatm_device.char_encoding, 1) then call statement_error (56, max_values, "");

	dsatm_device.char_encoding (cex) = name_idx;

     end;

legal_char_set: proc returns (bit (1) aligned);

	name_to_test_for = translate (token_value, ALL_CAPS, ALL_LOWERCASE);
	do name_idx = 1 to hbound (CS_NAME, 1);
	     if name_to_test_for = CS_NAME (name_idx) then return ("1"b);
	end;

	return ("0"b);

     end;

set_char_set: proc;

	csx = csx + 1;
	max_values = ltrim (char (hbound (dsatm_device.char_set, 1)));
	if csx > hbound (dsatm_device.char_set, 1) then call statement_error (56, max_values, "");

	dsatm_device.char_set (csx) = name_idx;

     end;

legal_char_subset: proc returns (bit (1) aligned);

	name_to_test_for = translate (token_value, ALL_CAPS, ALL_LOWERCASE);
	do name_idx = 1 to hbound (CSS_NAME, 1);
	     if name_to_test_for = CSS_NAME (name_idx) then return ("1"b);
	end;

	return ("0"b);

     end;

set_char_subset: proc;

	cssx = cssx + 1;
	max_values = ltrim (char (hbound (dsatm_device.char_subset, 1)));
	if cssx > hbound (dsatm_device.char_subset, 1) then call statement_error (56, max_values, "");

	dsatm_device.char_subset (cssx) = name_idx;

     end;

legal_char_font: proc returns (bit (1) aligned);

	name_to_test_for = translate (token_value, ALL_CAPS, ALL_LOWERCASE);
	do name_idx = 1 to hbound (CF_NAME, 1);
	     if name_to_test_for = CF_NAME (name_idx) then return ("1"b);
	end;

	return ("0"b);

     end;

set_char_font: proc;

	cfx = cfx + 1;
	max_values = ltrim (char (hbound (dsatm_device.char_font, 1)));
	if cfx > hbound (dsatm_device.char_font, 1) then call statement_error (56, max_values, "");

	dsatm_device.char_font (cfx) = name_idx;

     end;

legal_nat_lang: proc returns (bit (1) aligned);

	name_to_test_for = translate (token_value, ALL_CAPS, ALL_LOWERCASE);
	do name_idx = 1 to hbound (NL_NAME, 1);
	     if name_to_test_for = NL_NAME (name_idx) then return ("1"b);
	end;

	return ("0"b);

     end;

set_nat_lang: proc;

	nlx = nlx + 1;
	max_values = ltrim (char (hbound (dsatm_device.nat_lang, 1)));
	if nlx > hbound (dsatm_device.nat_lang, 1) then call statement_error (56, max_values, "");

	dsatm_device.nat_lang (nlx) = name_idx;

     end;

legal_compression: proc returns (bit (1) aligned);

	name_to_test_for = translate (token_value, ALL_CAPS, ALL_LOWERCASE);
	do name_idx = 1 to hbound (CA_NAME, 1);
	     if name_to_test_for = CA_NAME (name_idx) then return ("1"b);
	end;

	return ("0"b);

     end;

set_compression: proc;

	cax = cax + 1;
	max_values = ltrim (char (hbound (dsatm_device.compression, 1)));
	if cax > hbound (dsatm_device.compression, 1) then call statement_error (56, max_values, "");

	dsatm_device.compression (cax) = name_idx;

     end;

legal_attd: proc returns (bit (1) aligned);
dcl  attx fixed bin;

	attx = 0;
	go to common;

legal_att1: entry returns (bit (1) aligned);

	attx = 1;
	go to common;

common:

	if /* case */ token_value = "BREAK" | token_value = "break" then
	     dsatm_device.attentions.attn (attx).invocation.break = "1"b;

	else if token_value = "SEC_DIALOG" | token_value = "sec_dialog" then
	     dsatm_device.attentions.attn (attx).invocation.sec_dialog = "1"b;

	else if tty_char () | (token.quoted_string & token.Lvalue = 2) then do;
	     dsatm_device.attentions.attn (attx).invocation.string = "1"b;
	     dsatm_device.attentions.attn (attx).string_value (1) = token_value;
	end;

	else return ("0"b);

	return ("1"b);

     end;

finish_dsatm_device: proc;

dcl  p ptr;

	p = get_misc_space (currentsize (dsatm_device));
	extended_tables.tables_rp (DSATM_DEVICE_RP) = bin (rel (p));
	p -> dsatm_device = dsatm_device;
	dsatmdevp = p;

	return;

     end /* finish_dsatm_device */;

define_special: proc;

	call define_table (SPEC_TYPE, special_tables_ptr, spec_offset);
	max_output_escapes,
	     input_escapes.len = 0;
	return;
     end /* define_special */;


check_special: proc;

	if tablep -> special_chars.nl_seq.count = 0
	then call semant_error (23, table_names.name (defined), "new_line");

	if tablep -> special_chars.cr_seq.count = 0 &
	     tablep -> special_chars.bs_seq.count = 0
	then call semant_error (23, table_names.name (defined), "carriage_return and backspace");

	tablep -> special_chars.escape_length = max_output_escapes;
	tablep -> special_chars.not_edited_escapes = addr (not_edited) -> escapes;
	tablep -> special_chars.edited_escapes = addr (edited) -> escapes;
	tablep -> special_chars.input_escapes.len = input_escapes.len;
	tablep -> special_chars.input_escapes.str = input_escapes.str;
	tablep -> special_chars.input_results.str = input_results.str;

	length_in_words = divide (length (unspec (tablep -> special_chars)) + 35, 36, 17);
	spec_offset = spec_offset + length_in_words;

	return;
     end /* check_special */;


copy_string: proc (targetp);

dcl  targetp ptr;
dcl  1 target aligned based (targetp),
       2 offset fixed bin (18),
       2 len fixed bin;

dcl  stringp ptr;
dcl  stringl fixed bin;
dcl  target_string char (stringl) based aligned;
dcl  target_string_array (stringl) char (1) based;

	stringl = token.Lvalue + 2;
	stringp = get_misc_char_space (stringl);
	target.len = token.Lvalue;
	target.offset = bin (rel (stringp));

	stringp -> target_string = token_value;
	addr (stringp -> target_string_array (stringl - 1)) -> based_fb17 = 0;

	return;
     end /* copy_string */;


push_rep: proc;

/* for starting repetition factors in string specifications */

	if rep_depth >= max_rep_depth
	then do;
	     call ERROR (37);
	     rep_error = "1"b;
	     return;
	end;

	if token.Nvalue <= 0
	then do;
	     call statement_error (36, token_value, "");
	     rep_error = "1"b;
	     return;
	end;

	rep_depth = rep_depth + 1;
	rep_factor (rep_depth) = token.Nvalue;

	if token.Nvalue > 1
	then do;
	     rep_used = "1"b;
	     addr (unexpanded (unexp_char_index)) -> based_fb17 = -token.Nvalue;
	     unexp_char_index = unexp_char_index + 2;
	     rep_start (rep_depth) = exp_char_index;
	end;

	return;
     end /* push_rep */;


pop_rep: proc;

/* processes ">" at end of repeated spec */

	if rep_depth <= 0
	then do;
	     call ERROR (38);
	     rep_error = "1"b;
	     return;
	end;

	if rep_factor (rep_depth) > 1
	then do;
	     addr (unexpanded (unexp_char_index)) -> based_fb17 = -1;
	     unexp_char_index = unexp_char_index + 2;

	     rep_length = exp_char_index - rep_start (rep_depth);
	     rep_item = substr (exp_string, rep_start (rep_depth), rep_length);

	     do i = 2 to rep_factor (rep_depth);	/* copy the string the requisite number of times */
		substr (exp_string, exp_char_index, rep_length) = rep_item;
		exp_char_index = exp_char_index + rep_length;
	     end;
	end;

	rep_depth = rep_depth - 1;
	return;
     end /* pop_rep */;


insert_single_char: proc (n);

dcl  n fixed bin (18);

	expanded (exp_char_index) = n;
	unexpanded (unexp_char_index) = n;
	exp_char_index = exp_char_index + 1;
	unexp_char_index = unexp_char_index + 1;
	return;

     end insert_single_char;

insert_quoted_string: proc;

dcl  i fixed bin;
dcl  c char (1);

	do i = 1 to token.Lvalue;
	     c = substr (token_value, i, 1);
	     call insert_single_char (rank (c));
	end;
	return;

     end insert_quoted_string;

video_encode_pad: proc (time);

dcl  time fixed bin (35);

	tty_video_seq.cpad_present = "1"b;
	if time < 100 then do;
	     call ERROR (48);
	     return;
	end;
	tty_video_seq.cpad = divide (time + 99, 100, 18, 0);
	return;

     end video_encode_pad;

store_string: proc (targetp);

/* sets up pointer and length of string specified in octal */

dcl  targetp ptr;

dcl  1 target based (targetp) aligned,
       2 offset fixed bin (18),
       2 len fixed bin;

dcl  target_string char (stringl) based;
dcl  target_string_array (stringl) char (1) based;
dcl  stringl fixed bin;
dcl  stringp ptr;

	if rep_depth ^= 0
	then do;
	     call ERROR (38);
	     return;
	end;

	exp_char_index = exp_char_index - 1;
	unexp_char_index = unexp_char_index - 1;

	stringl = exp_char_index + 2;
	if rep_used then stringl = stringl + unexp_char_index;
	stringp = get_misc_char_space (stringl);

	target.len = exp_char_index;
	target.offset = bin (rel (stringp));

	substr (stringp -> target_string, 1, exp_char_index) = substr (exp_string, 1, exp_char_index);

	if ^rep_used				/* in this case, no need to store unexpanded version */
	then
	     addr (stringp -> target_string_array (exp_char_index + 1)) -> based_fb17 = -1;

	else do;
	     addr (stringp -> target_string_array (exp_char_index + 1)) -> based_fb17 = unexp_char_index;
	     substr (stringp -> target_string, exp_char_index + 3, unexp_char_index) =
		substr (unexp_string, 1, unexp_char_index);
	end;

	return;
     end /* store_string */;


set_table: proc (target, table_type);

dcl  target fixed bin (18);
dcl  table_type fixed bin;

	do i = 1 to n_table_names;
	     if table_names.name (i) = token_value
	     then if table_names.type (i) ^= table_type
		then do;
		     call statement_error (22, token_value, table_types (table_names.type (i)));
		     target = 0;
		     return;
		end;

		else do;
		     target = i;			/* use index into names table for now */
		     return;
		end;
	end;

/* didn't find it, have to add entry */

	n_table_names = i;				/* i.e., n_tables_names + 1 */
	table_names.name (n_table_names) = token_value;
	table_names.type (n_table_names) = table_type;
	table_names.offset (n_table_names) = -1;
	target = n_table_names;

	return;
     end /* set_table */;


copy_type: proc;

dcl  hold_extended_tables_rp fixed bin (18);

/* for like attribute */

	temp_ttep = addr (ttt.tt_entries (token.Nvalue));
	real_name = tte.name;			/* hang on to name of new type */
	hold_extended_tables_rp = tte.extended_tables_rp;
	tte = temp_ttep -> tte;
	tte.name = real_name;			/* put correct name back */
	tte.like_type = token.Nvalue;			/* display_ttt needs this */
	tte.bauds_overridden, tte.delay_overridden (*) = "0"b;
	if tte.extended_tables_rp ^= 0 then do;		/* must have one of our own */
	     tte.extended_tables_rp = hold_extended_tables_rp;
	     call set_extended;
	     extended_tables = ptr (misc_tables_ptr, temp_ttep -> tte.extended_tables_rp) -> extended_tables;
	end;
	return;
     end /* copy_type */;


make_delay_entry: proc (baud_rate);

/* when a new baud rate specified, set up an array of delay values for it */

dcl  baud_rate fixed bin;

	if delay_stmt
	then do;
	     if ^baud_error_printed
	     then do;
		call statement_error (24, tte.name, "");
		baud_error_printed = "1"b;
	     end;
	     return;
	end;

	if baudx = 1				/* first one for this terminal type */
	then do;
	     tte.delay_rp = next_misc_offset;
	     delay_tablep = ptr (misc_tables_ptr, next_misc_offset);
	     next_misc_offset = next_misc_offset + 1;
	     delay_table.n_bauds = 1;
	     if tte.like_type ^= 0
	     then tte.bauds_overridden = "1"b;
	end;

	else delay_table.n_bauds = delay_table.n_bauds + 1;

	delay_table.baud_rate (delay_table.n_bauds) = baud_rate;
	delay_table.version (delay_table.n_bauds) = DELAY_VERSION;
	delay_table.mbz (delay_table.n_bauds) = 0;	/* "default" word */

	next_misc_offset = next_misc_offset + 9;	/* for baud rate, version, default word, 6 delay values */
	return;
     end /* make_delay_entry */;


set_delay: proc;

	if tte.delay_rp = 0
	then do;
	     if n_dft_bauds <= 0
	     then do;
		if ^delay_error_printed
		then do;
		     call statement_error (25, tte.name, "");
		     delay_error_printed = "1"b;
		end;
		return;
	     end;

	     do baudx = 1 to n_dft_bauds;
		call make_delay_entry (dft_bauds (baudx));
	     end;
	end;

	delay_tablep = ptr (misc_tables_ptr, tte.delay_rp);

	if tte.like_type ^= 0			/* overriding "like" */
	then if ^tte.bauds_overridden			/* but using same bauds statement */
	     then do;
		if ^delay_stmt			/* first one */
		then do;				/* copy delay table of original type */
		     new_delay_table_ptr = ptr (misc_tables_ptr, next_misc_offset);
		     new_delay_table_ptr -> delay_table.n_bauds = delay_table.n_bauds;
		     do baudx = 1 to delay_table.n_bauds;
			new_delay_table_ptr -> delay_table.delay_array (baudx) =
			     delay_table.delay_array (baudx);
		     end;

		     tte.delay_rp = next_misc_offset;
		     next_misc_offset = next_misc_offset + 1 + 9 * (baudx - 1);
		     delay_tablep = new_delay_table_ptr;
		end;

		tte.delay_overridden (delayx) = "1"b;
	     end;

	delay_stmt = "1"b;				/* we've got one now */
	n_spec = n_spec + 1;

	if n_spec > delay_table.n_bauds		/* more values than we have room for */
	then do;
	     if ^delay_error_printed
	     then do;
		call ERROR (26);
		delay_error_printed = "1"b;
	     end;
	     return;
	end;

	if delayx = 2 | delayx = 4
	then cur_delay_value = addr (floating_delay_value) -> based_fb; /* fake the floating ones */
	else cur_delay_value = token.Nvalue;

	delay_table.delay_array (n_spec).delays (delayx) = cur_delay_value;
	return;
     end /* set_delay */;


set_up_answerback: proc;

	if n_answerbacks = 0
	then answerback_entry_ptr = ans_back_table_ptr;
	else answerback_entry_ptr = addrel (answerback_entry_ptr,
		divide (length (unspec (answerback_entry)) + 35, 36, 17, 0));
	n_answerbacks = n_answerbacks + 1;
	answerback_entry.next,
	     answerback_entry.term_type_index = 0;

	ansbck_char_index = 1;
	return;
     end /* set_up_answerback */;


check_for_any: proc;

	if temp_dftte (default_count).baud ^= 0 |
	     temp_dftte (default_count).line_type ^= 0
	then call ERROR (33);
	return;
     end /* check_for_any */;

/* Get current token numeric value in character form */

make_char: proc returns (char (1));

	return (byte (token.Nvalue));

     end make_char;

/* get some space in the misc_tables segment */

get_misc_space: proc (n) returns (ptr);

dcl  n fixed bin;
dcl  p ptr;

	p = ptr (misc_tables_ptr, next_misc_offset);
	next_misc_offset = next_misc_offset + n;
	return (p);

     end get_misc_space;

get_misc_char_space: proc (n) returns (ptr);

dcl  n fixed bin;

	return (get_misc_space (divide (n + 3, 4, 17, 0)));

     end get_misc_char_space;

/* keep track of relocations of stuff in misc space */

register_misc_reloc: proc (n);

dcl  n fixed bin (18);

	misc_relocs_count = misc_relocs_count + 1;
	misc_relocs (misc_relocs_count) = addr (n);
	return;

     end register_misc_reloc;

/* preform the relocations */

perform_misc_relocs: proc;

dcl  reloc_abort condition;
dcl  i fixed bin;
dcl  p ptr;
dcl  based_rp fixed bin (18) based (p);
dcl  temp_rp fixed bin (18);

	do i = 1 to misc_relocs_count;
	     p = misc_relocs (i);
	     if baseno (tttp) = baseno (p) then		/* in ttt segment */
		call add_increment (based_rp);
	     else if baseno (misc_tables_ptr) = baseno (p) then do;
		temp_rp = bin (rel (p));
		call add_increment (temp_rp);
		p = ptr (tttp, temp_rp);
		call add_increment (based_rp);
	     end;
	     else signal reloc_abort;
	end;
	return;

     end perform_misc_relocs;

/* Function key table routines */

define_fkey_table: proc;

	call define_table (FKEY_TYPE, fkey_tables_ptr, fkey_table_offset);
	function_key_data_ptr = addr (extended_tables_work.table);

/* Initialize */

	unspec (function_key_data.sequence) = "0"b;
	unspec (function_key_data.cursor_motion_keys) = "0"b;
	function_key_data_highest = -1;
	function_key_data.version = function_key_data_version_1;
	seqs_index = 0;
	extended_tables_work.seqs = "";

     end define_fkey_table;

finish_fkey_table: proc;

dcl  table_p ptr;
dcl  seq_p ptr;

	function_key_data.highest = function_key_data_highest;
	if function_key_data.highest < 0		/* no function keys defined */
	then do;
	     function_key_data.highest = 0;
	     function_key_data.function_keys (0, *) = 0;
	end;
	else do i = 1 to function_key_data.highest;
	     key_info_ptr = addr (function_key_data.function_keys (i, 0));
	     if key_info.sequence_length = 0
	     then call semant_error (51, cur_table_name, ltrim (char (i)));
	end;
	table_p = ptr (fkey_tables_ptr, fkey_table_offset);
	seq_p = ptr (fkey_tables_ptr, fkey_table_offset + currentsize (function_key_data));
	function_key_data.seq_len = seqs_index;
	function_key_data.seq_ptr = addr (extended_tables_work.seqs);
	table_p -> function_key_data = function_key_data;
	seq_p -> function_key_seqs = function_key_seqs;
	tablep -> function_key_data.seq_ptr = seq_p;
	fkey_table_offset = fkey_table_offset + currentsize (function_key_data) + currentsize (function_key_seqs);
	if mod (fkey_table_offset, 2) > 0
	then fkey_table_offset = fkey_table_offset + 1;

     end finish_fkey_table;

start_fkey_seq: proc (a_ptr);

dcl  a_ptr ptr;

	temp_key_infop = a_ptr;
	temp_key_index = 0;
	exp_char_index, unexp_char_index = 1;

     end start_fkey_seq;

end_fkey_seq: proc;

	if exp_char_index > 1
	then do;
	     if temp_key_index = KEY_PLAIN &
		temp_key_info (temp_key_index).sequence_length > 0
	     then call statement_error (53, cur_table_name, "");
	     temp_key_info (temp_key_index).sequence_length = exp_char_index - 1;
	     temp_key_info (temp_key_index).sequence_index = seqs_index + 1;
	     seqs_index = seqs_index + temp_key_info (temp_key_index).sequence_length;
	     substr (extended_tables_work.seqs,
		temp_key_info (temp_key_index).sequence_index,
		temp_key_info (temp_key_index).sequence_length)
		= substr (exp_string, 1, temp_key_info (temp_key_index).sequence_length);
	end;
	temp_key_index = temp_key_index + 1;
	exp_char_index, unexp_char_index = 1;

     end end_fkey_seq;

init_fkey_area: proc (curr_index);

dcl  curr_index fixed bin;
dcl  j fixed bin;

	if curr_index > function_key_data_highest
	then do;
	     do i = function_key_data_highest + 1 to curr_index;
		do j = lbound (function_key_data.function_keys, 2) to hbound (function_key_data.function_keys, 2);
		     unspec (function_key_data.function_keys (i, j)) = "0"b;
		end;
	     end;
	     function_key_data_highest = curr_index;
	end;

     end init_fkey_area;

/* ERROR CONTROL TABLE */

dcl  1 error_control_table (56) aligned int static options (constant),
       2 severity fixed bin (17) unal init (
	  3,					/* 1 */
	  1,					/* 2 */
	  (4) 3,					/* 3-6 */
	  3,					/* 7 */
	  (4) 3,					/* 8-11 */
	  1,					/* 12 */
	  (10) 3,					/* 13-22 */
	  1,					/* 23 */
	  (8) 3,					/* 24-31 */
	  (2) 1,					/* 32-33 */
	  2,					/* 34 */
	  1,					/* 35 */
	  (13) 3,					/* 36-48 */
	  1,					/* 49 */
	  3,					/* 50 */
	  3,					/* 51 */
	  3,					/* 52 */
	  1,					/* 53 */
	  1,					/* 54 */
	  (2) 3),					/* 55-56 */

       2 Soutput_stmt bit (1) unal init (

	  "0"b,					/* 1 */
	  (5) (1)"1"b,				/* 2-6 */
	  "0"b,					/* 7 */
	  (3) (1)"1"b,				/* 8-10 */
	  (3) (1)"0"b,				/* 11-13 */
	  (9) (1)"1"b,				/* 14-22 */
	  "0"b,					/* 23 */
	  (3) (1)"1"b,				/* 24-26 */
	  (7) (1)"0"b,				/* 27-33 */
	  "1"b,					/* 34 */
	  "0"b,					/* 35 */
	  (5) (1)"1"b,				/* 36-40 */
	  "0"b,					/* 41 */
	  "1"b,					/* 42 */
	  (2) (1)"0"b,				/* 43-44 */
	  (2) (1)"1"b,				/* 45-46 */
	  "0"b,					/* 47 */
	  (3) (1)"1"b,				/* 48-50 */
	  "0"b,					/* 51 */
	  (2) (1)"1"b,				/* 52-53 */
	  "0"b,					/* 54 */
	  (2) (1)"1"b),				/* 55-56 */

       2 message char (100) varying init (

	  "TTF is empty.",				/* 1 */
	  "Unrecognized mode ""^a"" specified.",	/* 2 */
	  "Invalid editing char ""^a"" specified.",	/* 3 */
	  "Value must be yes or no.",			/* 4 */
	  "Keyword ""^a"" unrecognized or out of order.", /* 5 */
	  "Syntax error.",				/* 6 */
	  "Unexpected end of TTF encountered.",		/* 7 */
	  "Invalid baud rate ^a specified.",		/* 8 */
	  "Invalid delay value ^a specified.",		/* 9 */
	  "Invalid line type ^a specified.",		/* 10 */
	  "Too many entries in table ""^a"".",		/* 11 */
	  "Table ""^a"" has fewer than 128 entries. Remainder have been set to 0.", /* 12 */
	  "Table ""^a"" contains invalid entry ""^a"".",	/* 13 */
	  """^a"" is not a valid indicator value.",	/* 14 */
	  "More than 3 items in a sequence.",		/* 15 */
	  """^a"" is not a valid sequence element.",	/* 16 */
	  """^a"" is not a valid answerback specification.", /* 17 */
	  "Type ""^a"" has not been defined.",		/* 18 */
	  "The name ""^a"" contains an invalid character.", /* 19 */
	  "Type ""^a"" has already been defined.",	/* 20 */
	  "Table ""^a"" has already been defined.",	/* 21 */
	  "Table ""^a"" has already been specified as a ^a table.", /* 22 */
	  "Table ""^a"" contains a null ^a sequence.",	/* 23 */
	  "A bauds statement appears after a delay statement for terminal type ""^a"".", /* 24 */
	  "No baud rates have been specified for terminal type ""^a"".", /* 25 */
	  "More delay values than baud rates specified.", /* 26 */
	  "Text follows the end statement.",		/* 27 */
	  "Table ""^a"" has been referenced but not defined.", /* 28 */
	  "Type ""^a"" has been referenced in default types table but not defined.", /* 29 */
	  "Type ""^a"" has an output conversion table but no special table.", /* 30 */
	  "Type ""^a"" uses conversion table ""^a"", which contains an escape not represented in the special table.", /* 31 */
	  "No default_types statement specified.",	/* 32 */
	  "Last entry in default_types statement does not specify ""any any"".", /* 33 */
	  "Unrecognized preaccess command ^a specified.", /* 34 */
	  "No type specified for preaccess command ^a.",	/* 35 */
	  "Invalid repetition factor ^a specified.",	/* 36 */
	  "Repetition factors nested too deep.",	/* 37 */
	  "Unbalanced brackets.",			/* 38 */
	  "Name ""^a"" is too long.",			/* 39 */
	  "Mode delimiter missing at or before ""^a"".",	/* 40 */
	  "Entry for type ^a contains one null and one non-null framing character.", /* 41 */
	  "Attempt to specify incompatible output flow control protocols.", /* 42 */
	  "Inconsistency in specification of output flow control for type ^a.", /* 43 */
	  "Inconsistency in specification of input flow control for type ^a.", /* 44 */
	  "Invalid token ""^a"" in video control sequence.", /* 45 */
	  "Invalid token ""^a"" in video argument sequence.", /* 46 */
	  "Video control sequence too long or empty.",	/* 47 */
	  "Unexpressible padding time: ^a.",		/* 48 */
	  "This character specification will convert invalidly without -ck1dig. Precede it by a zero. ^a", /* 49 */
	  "Invalid token ""^a"" in function key control sequence.", /* 50 */
	  "Table ""^a"", missing function key data for key(^a)", /* 51 */
	  "Table ""^a"", too many control sequences specified for a function key.", /* 52 */
	  "Table ""^a"", function key control sequence already defined.", /* 53 */
	  "Invalid protocol ""^a"" specified.",		/* 54 */
	  "Option not defined for this keyword: ^a.",	/* 55 */
	  "Maximum number of allowable options ""^a"" exceeded."), /* 56 */

       2 brief_message char (30) varying init (

	  "",					/* 1 */
	  (2) (1)"^a",				/* 2-3 */
	  "",					/* 4 */
	  "^a",					/* 5 */
	  (2) (1)"",				/* 6-7 */
	  (5) (1)"^a",				/* 8-12 */
	  """^a"" contains ""^a""",			/* 13 */
	  "^a",					/* 14 */
	  "",					/* 15 */
	  (6) (1)"^a",				/* 16-21 */
	  "^a is ^a",				/* 22 */
	  "^a has null ^a",				/* 23 */
	  (2) (1)"^a",				/* 24-25 */
	  (2) (1)"",				/* 26-27 */
	  (3) (1)"^a",				/* 28-30 */
	  "^a uses ^a",				/* 31 */
	  (2) (1)"",				/* 32-33 */
	  (3) (1)"^a",				/* 34-36 */
	  (2) (1)"",				/* 37-38 */
	  (3) (1)"^a",				/* 39-41 */
	  "",					/* 42 */
	  (4) (1)"^a",				/* 43-46 */
	  "",					/* 47 */
	  (3) (1)"^a",				/* 48-50 */
	  "Table ""^a"" - key(^a)",			/* 51 */
	  (2) (1)"Table ""^a""",			/* 52-53 */
	  "^a",					/* 54 */
	  "Option not defined: ""^a"".",		/* 55 */
	  "Max number of options is ^a.");		/* 56 */
