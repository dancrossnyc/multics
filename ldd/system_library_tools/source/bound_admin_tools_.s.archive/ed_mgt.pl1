/* ******************************************************
   *                                                    *
   *                                                    *
   * Copyright (c) 1972 by Massachusetts Institute of   *
   * Technology and Honeywell Information Systems, Inc. *
   *                                                    *
   *                                                    *
   ****************************************************** */
/* format: style4 */
ed_mgt: procedure options (variable);

/* ed_mgt - edit "master_group_table"
   which gives load control parameters for the load control groups
   and work class definitions for the work classes used by the priority scheduler

   Modified by T. Casey, June 1975, to edit work class information for priority scheduler
   Modified by T. Casey, October 1975 to fix bugs
   Modified by T. Casey, October 1976 to add deadline scheduler parameters.
   Modified by T. Casey, Sept 1977, to fix bugs in print and verify requests,
   .		and to permit the deletion of a group (which used to produce a warning).
   Modified by T. Casey, November 1978, to add group parameters: absentee_(max min pct).
   Modified May 1979 by T. Casey for MR7.0a to fix bug in verify (re the above absentee parameters).
   Modified July 1981 by J. Bongiovanni for governed work classes
   Modified 1984-09-17 BIM to remove call to reformat_mgt_,
   add page_weight support.
   Modified 1984-09-26 by E. Swenson to fix bug introduced by above change.
*/

%include mgt;
%include access_mode_values;
%include terminate_file;
%page;

dcl  arg_count fixed bin;
dcl  created_new_mgt bit (1) aligned;
dcl  dn char (168),
     en char (32),
     grp char (8),
     change_code char (20),
     (i, j, k, n) fixed bin,
     mgtp1 ptr init (null),
     comm char (8),
     movelen fixed bin,
     ap ptr,
     al fixed bin (21),
     bchr char (al) unaligned based (ap),
     code fixed bin (35),
     mgtp ptr init (null),				/* ptr to master group table (work copy) */
     qq ptr,
     ask_$ask_clr entry options (variable),
     ask_$ask_flo entry options (variable),
     ask_$ask_int entry options (variable),
     ask_$ask_yn entry options (variable),
     ask_ entry options (variable),
     ask_$ask_n entry options (variable),
     ask_$ask_nint entry options (variable),
     ask_$ask_nflo entry options (variable),
     ask_$ask_c entry options (variable),
     ask_$ask_cint entry options (variable),
     ask_$ask_cflo entry options (variable),
     ask_$ask_setline entry (char (*)),
     btemp bit (1) aligned,
     itemp fixed bin,
     ftemp float bin;

dcl  (addr, fixed, float, hbound, index, length, max, min, mod,
     null, reverse, size, string, substr, verify) builtin;

dcl  program_interrupt condition;
dcl  cleanup condition;

dcl  cu_$arg_count entry (fixed bin, fixed bin (35));
dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
dcl  expand_pathname_$add_suffix entry (character (*), character (*), character (*), character (*),
	fixed binary (35));
dcl  pathname_ entry (character (*), character (*)) returns (character (168));
dcl  ioa_ entry options (variable);
dcl  ioa_$rsnnl entry options (variable);
dcl  ioa_$nnl entry options (variable);
dcl  com_err_ entry options (variable);
dcl  com_err_$suppress_name entry () options (variable);
dcl  initiate_file_$create entry (character (*), character (*), bit (*), pointer, bit (1) aligned,
	fixed binary (24), fixed binary (35));
dcl  terminate_file_ entry (pointer, fixed binary (24), bit (*), fixed binary (35));
dcl  get_temp_segment_ entry (character (*), pointer, fixed binary (35));
dcl  release_temp_segment_ entry (character (*), pointer, fixed binary (35));
dcl  get_group_id_ entry () returns (char (32));
dcl  get_wdir_ entry () returns (character (168));

dcl  error_table_$unimplemented_version fixed bin (35) ext static;

dcl  mgtix fixed bin;
dcl  change_item fixed bin;
dcl  change_type fixed bin;
dcl  (fshift, lshift, nshift) fixed bin;
dcl  (mxval, nval) fixed bin;
dcl  flag fixed bin;
dcl  (gcfirst, gclast) fixed bin;
dcl  undefwc fixed bin;
dcl  shift fixed bin;
dcl  shift_pct fixed bin;
dcl  no_abs_count fixed bin;

dcl  dflt_g (4) fixed bin;
dcl  ival (8) fixed bin;
dcl  fval (8) float bin;
dcl  bval (8) bit (1) aligned;
dcl  shifts (8) fixed bin;
dcl  shf (8) fixed bin;				/* set by get_shift_spec: list of shifts to be changed */
dcl  nshf fixed bin;

dcl  print_pct_ignored bit (1) aligned;
dcl  default_absentee bit (1) aligned;
dcl  int_wc bit (1) aligned;
dcl  gcsw bit (1) aligned;
dcl  wcsw bit (1) aligned;
dcl  wcundef bit (1) aligned;
dcl  (got_shift_spec, got_int_abs, got_values) bit (1) aligned;
dcl  (padflt, pawc, pagrp, patot, paxrf) bit (1) aligned;
dcl  no_abs bit (1) aligned;

dcl  shift_used (0:7) bit (1) aligned;
dcl  q (4) bit (1) aligned;
dcl  dflt_q (4) bit (1) unaligned;

dcl  wcp ptr;

dcl  char32 char (32);

dcl  change_entry_type (2:26) fixed bin int static options (constant) init /* entry types that each change_code is valid for:
						   0=header,1=group,2=work class,3=group OR work class */
	(0,					/* 2: prio sked */
	(9) 1,					/* 3-11: maxu thru wc */
	3,					/* 12: absentee */
	(7) 2,					/* 13-19: pct thru mode */
	(2) 0,					/* 20,21: normal moce, shifts */
	(3) 1,					/* 22-24: absentee_(max min pct) */
	(2) 2);					/* 25: max_pct, 26: page_weight */


dcl  change_types (2:26) fixed bin int static options (constant) init /* data types for each item that change deals with */
	(3, 2, 0, 2, 1, 1, 1, 1, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1, 4, 4);
						/* 0=char;1=float;2=float*10;3=yes/no;4=variable_format */

dcl  vtypes (11:26) fixed bin int static options (constant) init /* mapping between change_item and value type,
						   for the variable format change items */
	(1, 3, 1, 3, 2, 2, 2, 2, 3, 3, 0, 0, 0, 0, 1, 1); /* 1=integer;2=floating point;3=keyword */


dcl  change_names (2:26) char (12) int static options (constant) init (/* ITEM - names used in prompting messages */
	"prio_sked"				/* 2 */
	, "max_prim"				/* 3 */
	, "id"					/* 4 */
	, "abs_max"				/* 5 */
	, "numerator"				/* 6 */
	, "denominator"				/* 7 */
	, "num1"					/* 8 */
	, "denom1"				/* 9 */
	, "constant"				/* 10 */
	, "work_class"				/* 11 */
	, "absentee y/n"				/* 12 */
	, "percent(s)"				/* 13 */
	, "defined y/n"				/* 14 */
	, "int_resp"				/* 15 */
	, "int_quantum"				/* 16 */
	, "resp"					/* 17 */
	, "quantum"				/* 18 */
	, "mode norm/rt"				/* 19 */
	, "deadline/pct"				/* 20 */
	, "shifts"				/* 21 */
	, "absentee_max"				/* 22 */
	, "absentee_min"				/* 23 */
	, "absentee_pct"				/* 24 */
	, "max_pct(s)"				/* 25 */
	, "page_weight"				/* 26 */
	);

dcl  change_items (50) fixed bin int static options (constant) init /* correspondence between the 50 change_codes and the 26 items */
	(1, 1, 2, 2, 3, 3, 3, 3, 4, 5, 5, 5, 6, 6, 7, 7, 7, 8, 9, 9, 10, 10, 10, 11, 11, 12, 13, 13, 13, 14, 14,
	15, 15, 16, 16, 17, 17, 18, 18, 19, 20, 20, 21, 22, 23, 24, 25, 25, 26, 26);

dcl  change_codes (50) char (12) int static options (constant) init (
						/* CODE	ITEM  - names that user can give in change request */

/* control items - used to exit from change mode */

	"*"					/* 1	1 */
	, "."					/* 2	1 */

/* header items (see additional header items below) */

	, "prio"					/* 3	2 */
	, "prio_sked"				/* 4	2 */

/* group items */

	, "maxu"					/* 5	3 */
	, "max_prim"				/* 6	3 */
	, "maxp"					/* 7	3 */
	, "m"					/* 8	3 */
	, "id"					/* 9	4 */
	, "abs"					/* 10	5 */
	, "abs_max"				/* 11	5 */
	, "minamax"				/* 12	5 */
	, "numerator"				/* 13	6 */
	, "num"					/* 14	6 */
	, "denominator"				/* 15	7 */
	, "den"					/* 16	7 */
	, "denom"					/* 17	7 */
	, "num1"					/* 18	8 */
	, "denom1"				/* 19	9 */
	, "den1"					/* 20	9 */
	, "constant"				/* 21	10 */
	, "const"					/* 22	10 */
	, "con"					/* 23	10 */
	, "work_class"				/* 24	11 */
	, "wc"					/* 25	11 */

/* both group and work class item */

	, "absentee"				/* 26	12 */

/* work class only items */

	, "percent"				/* 27	13 */
	, "pct"					/* 28	13 */
	, "%"					/* 29	13 */
	, "defined"				/* 30	14 */
	, "def"					/* 31	14 */
	, "int_resp"				/* 32	15 */
	, "ir"					/* 33	15 */
	, "int_quantum"				/* 34	16 */
	, "iq"					/* 35	16 */
	, "resp"					/* 36	17 */
	, "r"					/* 37	17 */
	, "quantum"				/* 38	18 */
	, "q"					/* 39	18 */
	, "mode"					/* 40	19 */

/* additional header items */

	, "normal_mode"				/* 41	20 */
	, "norm"					/* 42	20 */
	, "shifts"				/* 43	21 */
	, "absentee_max"				/* 44	22 */
	, "absentee_min"				/* 45	23 */
	, "absentee_pct"				/* 46	24 */

/* additional work class only items */

	, "max_percent"				/* 47     25 */
	, "max_pct"				/* 48     25 */
	, "page_weight"				/* 49     26 */
	, "pw"					/* 50     26 */
	);


declare  ME char (32) int static init ("ed_mgt") options (constant);
declare  DEFAULT_MGT_PATH char (168) init ("MGT.mgt") int static options (constant);


	call cu_$arg_count (arg_count, code);
	if code ^= 0 then do;
	     call com_err_ (code, ME);
	     return;
	end;

	if arg_count > 1 then do;
	     call com_err_$suppress_name (0, ME, "Usage: ed_mgt {pathname}");
	     return;
	end;

	if arg_count = 0 then do;
	     ap = addr (DEFAULT_MGT_PATH);
	     al = length (rtrim (DEFAULT_MGT_PATH));
	end;

	else call cu_$arg_ptr (1, ap, al, (0));

	call expand_pathname_$add_suffix (bchr, "mgt", dn, en, code);
	if code ^= 0 then do;
	     call com_err_ (code, "ed_mgt", bchr);
	     return;
	end;

	created_new_mgt = "0"b;
	mgtp, mgtp1 = null ();
	on cleanup call clean_up;
	call initiate_file_$create (dn, en, RW_ACCESS, mgtp1, created_new_mgt, (0), code);
	if code ^= 0 then do;
	     call com_err_ (code, ME, "^a", pathname_ (dn, en));
	     call clean_up;
	end;

	call get_temp_segment_ (ME, mgtp, code);
	if code ^= 0 then do;
	     call com_err_ (code, ME, "Internal error; cannot get a temp segment.");
	     call clean_up;
	end;

	on condition (program_interrupt) go to main1;

	if ^(created_new_mgt | mgtp1 -> mgt.version_indicator ^= "VERSION ") then
	     mgtp -> mgt = mgtp1 -> mgt;

	else do;
	     call ioa_ ("Creating new MGT ^a.", pathname_ (dn, en));
	     call initialize_mgt;
	end;

	if mgt.version ^= MGT_version_3 then do;	/* if not current version, see what it is */
	     call com_err_ (error_table_$unimplemented_version,
		ME, "MGT version is ^d, must be ^d.",
		mgt.version, MGT_version_3);
	     call clean_up;
	     return;
	end;					/* end version not 3 */


/* Initialize current position and enter request loop */

	mgtix = 17;				/* group 1 */
	mgtep = addr (mgt.entry (17));		/* gotta start somewhere */
	if mgt.current_size < mgtix then do;		/* nobody home? */
	     call ioa_ ("no groups defined, ""add"" assumed");
	     go to acom;
	end;

/* Come here after an error, to clear any typed ahead input before prompting for next request */

main1:	call ask_$ask_clr;

/* Come here to prompt for another request */

main:	call ask_ ("type    ", comm);			/* get command */
	mgtep = addr (mgt.entry (mgtix));		/* mgtep gets moved around -
						   mgtix is the true "current pointer" */
	if comm = "quit" then goto qcom;
	else if comm = "q" then
qcom:
exit:	     do;
	     call clean_up;
	     return;
	end;
	else if comm = "write" | comm = "w"
	then do;					/* write? */
wcom:
	     created_new_mgt = "0"b;			/* don't delete me! */

	     mgtp1 -> mgt = mgtp -> mgt;

	     call terminate_file_ (mgtp1, 36 * (64 + mgtp1 -> mgt.current_size * 32), TERM_FILE_TRUNC | TERM_FILE_BC, (0));

	     goto main;				/* leave pointer where it was, after a write */
	end;
	else if comm = "f" then go to fcom;		/* find */
	else if comm = "find" then do;
fcom:	     call ask_ ("group   ", grp);
	     do i = 1 to mgt.current_size;
		mgtep = addr (mgt.entry (i));
		if group.group_id = grp then do;
		     mgtix = i;
		     go to pentry;
		end;
	     end;
	     call ioa_ ("group ""^a"" not found", grp);
	     go to main1;
	end;
	else if comm = "c" then go to ccom;		/* change */
	else if comm = "change" then do;

ccom:	     gcsw = "0"b;				/* not global change */
	     if mgtix <= 16 then wcsw = "1"b;
	     else wcsw = "0"b;
	     call change;
	end;

	else if comm = "gc" then goto gccom;
	else if comm = "global_change" then do;
gccom:	     gcsw = "1"b;
	     call ask_ ("entry type ", change_code);
	     if change_code = "load_control_group" then goto lctype;
	     if substr (change_code, 1, 5) = "group" then goto lctype; /* allow singular or plural */
	     else if change_code = "lcg" then do;
lctype:		wcsw = "0"b;
	     end;
	     else if change_code = "work_class" then goto wctype;
	     else if change_code = "wc" then do;
wctype:		wcsw = "1"b;
	     end;
	     else do;
		call ioa_ ("bad entry type: ""^a""^/must be ""work_class"" or ""load_control_group""", change_code);
		call ask_$ask_clr;
		goto gccom;
	     end;

	     call change;
	end;

	else if comm = "p" then go to pcom;
	else if comm = "print" then do;
pcom:
	     if mgtix > 16 then
		call prgp (mgtep);
	     else do;
		wcundef = ""b;
		call prwc (mgtep);
		if wcundef then do;
		     call ioa_ (" is undefined");
		     wcundef = ""b;
		end;
	     end;
	end;

	else if comm = "p*" then go to pacom;
	else if comm = "pa" then go to pacom;
	else if comm = "pall" then do;
pacom:

	     padflt = "1"b;				/* assume no optional arguments */
	     patot, pawc, pagrp, paxrf = "0"b;
paloop:	     call ask_$ask_n (char32, flag);		/* check for optional arguments */
	     if flag = 0 then goto no_pa_arg;		/* if nothing there */
	     if substr (char32, 1, 3) = "tot" then do;	/* allow "tot", "total", "totals" */
		patot = "1"b;
pa_arg:		padflt = "0"b;			/* remember that some args were given */
		call ask_$ask_c (char32, flag);	/* get rid of it from line */
		goto paloop;			/* go see if more */
	     end;
	     else if char32 = "lcg" then goto pa_grp;
	     else if substr (char32, 1, 5) = "group" then goto pa_grp; /* allow singular or plural form */
	     else if substr (char32, 1, 18) = "load_control_group" then do;
pa_grp:		pagrp = "1"b;
		goto pa_arg;
	     end;
	     else if char32 = "wc" then goto pa_wc;
	     else if substr (char32, 1, 10) = "work_class" then do; /* allow singular or plural form */
pa_wc:		pawc = "1"b;
		goto pa_arg;
	     end;
	     else if char32 = "xref" then goto pa_xref;
	     else if char32 = "cref" then goto pa_xref;
	     else if substr (char32, 1, 5) = "cross" then do; /* allow cross reference, in any form */
pa_xref:		paxrf = "1"b;
		goto pa_arg;
	     end;

no_pa_arg:					/* fall thru if no match, or come here if no typed ahead arg */
	     if padflt then				/* if no args given, use the default */
		patot, pawc, pagrp, paxrf = "1"b;	/* which is to print everything  */

/* now, print the stuff */

	     if patot then do;			/* if we are to print totals from mgt header */
		call ioa_ ("max_size ^d", mgt.max_size);
		call ioa_ ("current_size ^d", mgt.current_size);
		call ioa_ ("total_units ^d", mgt.total_units);
		call ioa_ ("prio_sked_enabled: ^[yes^;no^]", mgt.switches.prio_sked_enabled);
		call ioa_ ("wc_initialized: ^[yes^;no^]", mgt.switches.wc_initialized);
		call print_shfs (mgt.shift_defined, "defined shifts: ", "^x^d");
		call print_bvals (mgt.shift_defined, "scheduling mode:", "^x^[d^;%^]", mgt.switches.deadline_mode);
	     end;


	     if pagrp then				/* if we should print all groups */
		do n = 17 to mgt.current_size;	/* do so */
		qq = addr (mgt.entry (n));
		call prgp (qq);
	     end;

	     if pawc then do;			/* if we should print all work classes */
		wcundef = ""b;			/* we check for a series of undefined work classes */
		do n = 1 to 16;			/* to avoid aggravating the user */
		     qq = addr (mgt.entry (n));	/* by printing a long list of "... is undefined" lines */
		     if wcundef then do;		/* if the previous one was undefined */
			if string (qq -> work_class.switches.defined) ^= ""b then do; /* but this one is defined */
plast:			     wcundef = ""b;
			     if undefwc = n - 1 then	/* if only the last one was undefined */
				call ioa_ (" is undefined");
			     else call ioa_ ("-^d are undefined", n - 1);
			     if n <= 16 then	/* if not entered at plast to print "last few undefined" */
				call prwc (qq);	/* go print the current work class */
			end;
		     end;
		     else do;			/* previous one was not undefined */
			call prwc (qq);
			if wcundef then		/* prwc checks, and sets this switch */
			     undefwc = n;		/* remember the first undefined one in the series */
		     end;
		end;
		if wcundef then			/* if last few were undefined */
		     goto plast;			/* go print message to that effect */
	     end;

	     if paxrf then				/* if we are to print a cross reference */
		call pxref;			/* go do so */


	end;

	else if comm = "a" then go to acom;
	else if comm = "add" then do;
acom:	     call ask_ ("group   ", grp);
	     do mgtix = 1 to mgt.current_size;
		mgtep = addr (mgt.entry (mgtix));
		if group.group_id = grp then do;
		     if mgtix < 17 then call ioa_ ("use the ""change"" request to define a work class");
		     else call ioa_ ("group ""^a"" already exists", grp);
		     go to main1;
		end;
	     end;
	     mgtix = mgt.current_size + 1;
	     mgtep = addr (mgt.entry (mgtix));
	     group.group_id = grp;
	     group.minamax = 32767;			/* will have to change this if Multics gets really big */
	     group.absentee.allowed = "1"b;		/* by default */
	     call ask_$ask_flo ("constant ", ftemp);
	     if ftemp < 0e0 then group.max_prim = -1;
	     else group.minu = ftemp * 10;

	     if mgt.switches.wc_initialized then	/* if work classes (other than the initial
						   default of 1) have been defined */
		call ask_$ask_int ("work class ", itemp); /* keep it simple - just ask for one */
	     else itemp = 1;			/* none defined - use the initial default work class */
	     do i = 0 to 7;
		if mgt.shift_defined (i) then
		     group.int_wc (i), group.abs_wc (i) = itemp;
		else group.int_wc (i), group.abs_wc (i) = 0;
	     end;

	     mgt.current_size = mgtix;
	end;

	else if comm = "delete" then do;
	     if mgtix <= 16 then do;
		call ioa_ ("use the ""change"" request to undefine a work class");
		goto main1;
	     end;
	     do i = mgtix + 1 to mgt.current_size;
		mgt.entry (i - 1) = mgt.entry (i);
	     end;
	     mgt.current_size = mgt.current_size - 1;
	     mgtix = min (mgtix, mgt.current_size);	/* in case we deleted the last group */
	     mgtep = addr (mgt.entry (mgtix));
	     goto pentry;				/* tell user the current group has changed */
	end;

	else if comm = "n" then go to ncom;
	else if comm = "next" then do;
ncom:	     mgtix = mgtix + 1;
	     if mgtix > mgt.current_size then do;
		call ioa_ ("EOF");
		mgtix = mgt.current_size;
	     end;
	     mgtep = addr (mgt.entry (mgtix));
	     goto pentry;
	end;
	else if comm = "top" then go to tcom;
	else if comm = "t" then go to tcom;
	else if comm = "-" then do;
	     mgtix = mgtix - 1;
	     if mgtix <= 0 then do;
		call ioa_ ("TOP");
tcom:		mgtix = 1;
	     end;
	     mgtep = addr (mgt.entry (mgtix));
	     goto pentry;
	end;

	else if comm = "verify" then goto vcom;
	else if comm = "v" then do;
vcom:	     call verify_mgt;
	end;

	else if comm = "define" then call define;
	else if comm = "redefine" then call redefine;
	else if comm = "undefine" then call undefine;

	else do;					/* ? */
	     call ioa_ ("illegal command ""^a""", comm);
	     go to main1;
	end;

/* Fall thru to here after executing a request, unless:
   1) an error occurred and we went directly to main1 to flush possible typeahead; or
   2) we moved the current pointer and went to pentry (just below) to print the name of the new current entry.
*/

	go to main;

pentry:						/* come here to print line telling user where he is */
	call ask_$ask_n (char32, flag);		/* see if anything typed ahead */
	if flag ^= 0 then goto main;			/* if user typed ahead, we assume he knows where he is */
	if mgtix <= 16 then
	     call ioa_ ("work class: ^a", work_class.wc_name);
	else call ioa_ ("group: ^a", group.group_id);
	goto main;



/* ****************************************************************************************************************** */


/* Internal procedures, in alphabetic order */


ask_cval: proc (vtype, where, flag);

dcl  (flag, vtype, where) fixed bin;

	if vtype = 1 then
	     call ask_$ask_cint (ival (where), flag);
	else if vtype = 2 then
	     call ask_$ask_cflo (fval (where), flag);
	else if vtype = 3 then
	     call ask_ckey (bval (where), flag);

	return;

     end ask_cval;


/* ****************************************************************************************************************** */


ask_key: proc (bval, prompt);

dcl  prompt char (*);
dcl  bval bit (1) aligned;
dcl  (prompt_sw, remove_sw, yn_sw) bit (1) aligned;
dcl  (flag, local_flag) fixed bin;

	prompt_sw, remove_sw = "1"b;
	yn_sw = ""b;
	goto key_common;

/* ********** */

ask_ckey: entry (bval, flag);
	flag = 0;
	prompt_sw, yn_sw = ""b;
	remove_sw = "1"b;
	goto key_common;

/* ********** */

ask_nkey: entry (bval, flag);

	flag = 0;
	prompt_sw, remove_sw, yn_sw = ""b;
	goto key_common;

/* ********** */

ask_yn: entry (bval, prompt);

	prompt_sw, yn_sw = "1"b;
	remove_sw = ""b;
	goto dont_ask_key;				/* caller already asked, and char32 contains the response */

/* ********** */

ask_cyn: entry (bval, flag);

	remove_sw, prompt_sw = ""b;
	yn_sw = "1"b;
	goto dont_ask_key;				/* caller already asked, as above */

/* ********** */

key_common:

	if prompt_sw then
ask_key_again: call ask_ ("^a ", char32, prompt);
	else do;
	     call ask_$ask_n (char32, flag);
	     if flag = 0 then return;
	end;

dont_ask_key:

	local_flag = 0;
	if change_item = 12 | change_item = 14 | yn_sw then
	     call scan_key ("allowed,yes,y,on,1,ok,^allowed,not_allowed,no,n,off,0", (6), bval, local_flag);
	else if change_item = 19 then
	     call scan_key ("realtime,rt,normal,norm", (2), bval, local_flag);
	else if change_item = 20 then
	     call scan_key ("deadline,percent,pct,%", (1), bval, local_flag);

	if local_flag = 0 then do;			/* no match with keywords */
	     if prompt_sw then do;			/* but caller insists on getting one */
		call ioa_ ("bad value: ""^a""", char32);
		call ask_$ask_clr;			/* flush typeahead */
		goto ask_key_again;			/* and go insist */
	     end;
	     else flag = -1;			/* caller just wants to know,
						   so say "something there but not what you want" */
	end;

	else					/* there was a match */
	     if ^prompt_sw then do;			/* if caller was not insisting */
	     flag = 1;				/* tell him we found good value */
	     if remove_sw then
		call ask_$ask_c (char32, local_flag);	/* read it again to remove it from the input line */
	end;

	return;

     end ask_key;


/* ****************************************************************************************************************** */


ask_val: proc (vtype, where, prompt);

dcl  (vtype, where) fixed bin;
dcl  prompt char (*);

	if vtype = 1 then
	     call ask_$ask_int ("^a ", ival (where), prompt);
	else if vtype = 2 then do;
	     call ask_$ask_flo ("^a ", fval (where), prompt);
	     if change_item >= 15 & change_item <= 18 then/* int_resp, int_quantum, resp, or quantum */
		fval (where) = fval (where) * 100e0 + .005e0;
	end;
	else if vtype = 3 then
	     call ask_key (bval (where), prompt);

	return;

     end ask_val;


/* ****************************************************************************************************************** */


assign_value: proc (vtype, to, from);

dcl  (from, to, vtype) fixed bin;

	if vtype = 1 then
	     ival (to) = ival (from);
	else if vtype = 2 then
	     fval (to) = fval (from);
	else if vtype = 3 then
	     bval (to) = bval (from);

	return;

     end assign_value;


/* ****************************************************************************************************************** */


change: proc;

/* procedure to implement the change subcommand. it is called by both the
   change and global_change requests. it dechange_codes one change request and makes
   the change (to one entry or all entries of the specified type), and then
   reads the next request. the "." and "*" requests cause exit from the change subcommand */

dcl  i fixed bin;

ask_code: call ask_ ("code ", change_code);
	do i = 1 to hbound (change_codes, 1)
	     while (change_code ^= change_codes (i));
	end;
	if i > hbound (change_codes, 1) then do;	/* not found */
	     call ioa_ ("bad change code: ""^a""", change_code);
change_clr:    call ask_$ask_clr;
	     goto ask_code;
	end;

	change_item = change_items (i);		/* pick up which variable is to be changed */
	change_type = change_types (change_item);	/* and what type it is */

	if change_item = 1 then return;		/* "." or "*" */

/* See of change_code is valid for entry type being changed */

	if change_entry_type (change_item) ^= 0 then do;	/* if change_code is for a header item, it is ok; otherwise, check */
	     if wcsw & change_entry_type (change_item) = 1 then do;
						/* we're changing a work class, but change_code is for groups only */
		call ioa_ ("code ""^a"" is not legal for a work class", change_code);
		goto change_clr;
	     end;

	     else if ^wcsw & change_entry_type (change_item) = 2 then do;
						/* we're changing a group, but change_code is for work classes only */
		call ioa_ ("code ""^a"" is not legal for a load control group", change_code);
		goto change_clr;
	     end;
						/* notice that we fall thru for change_entry_type = 3, which means
						   "valid for both group and work class" */
	end;

	goto ask_type (change_type);			/* go read value(s) from the input line */

ask_type (0):					/* character string */
ask_type (3):					/* yes or no word */
	call ask_ ("^a ", char32, change_names (change_item));

	if change_type = 3 then
	     call ask_yn (bval (1), change_names (change_item));

	goto asked_type;

ask_type (1):					/* float */
ask_type (2):					/* float*10e0 */
	call ask_$ask_flo ("^a ", ftemp, change_names (change_item));

	if change_type = 2 then			/* if float*10e0 */
	     if ftemp > 0e0 then			/* and value is not negative */
		ftemp = ftemp * 10e0;		/* multiply it by 10 */

	goto asked_type;

/* variable format - got to look ahead on the line to see what we have */

ask_type (4):

/* "c absentee" for a group is different from all the other variable format requests

   it can be either of:
   c absentee <yes-or-no value>
   c absentee queue <queue value(s)>|none
*/

	if change_item = 12 & ^wcsw then do;		/* if that's what we have */
ask_abs:	     call ask_ ("""yes"" or ""no"" or ""queue""", char32);
	     if char32 = "queue" then goto abs_q;
	     else if char32 = "q" then do;
abs_q:		call get_int_list ("queue(s)", 4, nval);

		q (*) = "0"b;
		do i = 1 to nval;			/* if nval = 0, q(*) stays = "0"b, which is what we want */
		     if ival (i) <= 0 then goto badq;
		     if ival (i) > 4 then do;
badq:			call ioa_ ("bad absentee queue number: ^d", ival (i));
			call ask_$ask_clr;
			goto abs_q;
		     end;

		     q (ival (i)) = "1"b;
		end;
		default_absentee = "1"b;		/* we are changing this group's default absentee switch */
	     end;

	     else do;				/* changing the absentee allowed bit */
		call ask_cyn (bval (1), itemp);	/* see if yes or no word there */
		if itemp <= 0 then do;		/* not a yes or no word */
		     call ioa_ ("bad value: ^a", char32);
		     call ask_$ask_clr;
		     goto ask_abs;
		end;
		default_absentee = "0"b;		/* we are not changing this group's default absentee switch */
	     end;

	end;					/* end of "c absentee for a group" do group */

/* all the other variable format requests */

	else do;

/* * ITEM	FORMAT ( "[]" denotes an optional argument)
   * 11  	work_class   [shift spec] [int|abs] <integer per-shift work class number values>
   * 12  	absentee     [shift spec] <yes-or-no per-shift absentee-allowed values>
   * 13  	percent      [shift spec] <integer per-shift percent values>
   * 14  	defined      [shift spec] <yes-or-no per-shift work-class-defined values>
   * 15	int_resp     [shift spec] <float*100 per-shift interaction response values>
   * 16	int_quantum  [shift spec] <float*100 per-shift interaction quantum values>
   * 17	resp         [shift spec] <float*100 per-shift steady state response values>
   * 18	quantum      [shift spec] <float*100 per-shift steady state quantum values>
   * 19	mode         [shift spec] <"normal" or "realtime" per-shift mode indicators>
   * 25	max_percent  [shift spec] <integer per-shift governing percent values>
   *
   *  THE ABOVE APPLY SEPARATELY TO EACH WORK CLASS
   *
   *  THE FOLLOWING APPLY TO ALL WORK CLASSES AND ARE STORED IN THE MGT HEADER
   *
   * 20	normal_mode  [shift spec] <"deadline" or "percent" per-shift mode indicators>
   * 21	shifts <list of shift numbers (all of them) in use at the site>  (can be i j k OR m-n OR mixture)
   *
   * There are several comments below, related to whether or not "values" have been typed ahead.
   * These refer only to the values described in "<  >" brackets above.
   * They specifically exclude the shift spec and the int|abs indicators.
   * The significant point here is that, if a list of values is typed ahead, omitted
   * shift specification information takes on default values that are a function
   * of the number of values typed ahead, but if a list of values is not typed ahead,
   * then the shift spec is prompted for and must be given. A different path
   * is taken through the code below in each of these two cases.
   *
   * The default when one value is given is "shift all" (all defined shifts get set to the one value).
   * When a list of values is given, the default is "shift S1" where S1 is the lowest
   * numbered defined shift, and the values are assigned to successive defined shifts, starting with S1.
   *
   *   */

/* set up default shift specification */

	     nshf = 0;				/* no shifts have actually been given by the user */
	     fshift = -1;				/* scan for defined shifts starting after -1 (i.e. at zero) */
	     mxval = 0;				/* initialize counter for defined shifts */
	     call set_default_shift_spec;		/* go count defined shifts and remember their numbers */
						/* mxval now = number of defined shifts
						   (= number of values we can use) */
	     lshift, nshift = 0;			/* only used when shift spec given, but clear garbage anyway */

	     got_shift_spec, got_int_abs, got_values = "0"b;
	     int_wc = "1"b;				/* the default is interactive work class */

look_ahead:    call ask_$ask_n (char32, flag);		/* look at next word without removing it from line */

	     if flag ^= 0 then do;			/* something was typed ahead */

		if ^got_shift_spec & change_item ^= 21
		     & substr (char32, 1, 5) = "shift" then do;
		     call get_shift_spec;
		     goto look_ahead;		/* go look for more typed ahead stuff */
		end;

		else if ^got_int_abs
			& change_item = 11 then do;	/* check for "int" or "abs" */
		     got_int_abs = check_int_abs ();
		     if got_int_abs then goto look_ahead; /* go look for more typed ahead stuff */
		     else goto check_values;		/* go see if this is values */
		end;

		else do;				/* must be values that were typed ahead */
check_values:
		     nval = 0;			/* so we can tell if we got any values */
		     if change_item = 21		/* shifts */
			& ck_int (char32, (0), (0)) then /* and we have shift number(s) */
			call get_int_list (change_names (change_item), (8), nval);
		     else call look_ahead_value (vtypes (change_item), nval);

		     if nval > 0 then got_values = "1"b;
		     else do;
			call ioa_ ("""^a"" unrecognized", char32);
			call ask_$ask_clr;
		     end;

		end;				/* from here, we fall thru to the label "asked_type", without
						   looking for any more type ahead, or prompting for anything */
	     end;					/* end of "there is type ahead" do group */

	     else do;				/* there is no more type ahead */
						/* NOTE: this do group is not entered if values were typed ahead;
						   and note again that "values" do not include the
						   shift_spec or int|abs items */
		if ^got_shift_spec then		/* if shift not already given */
		     call get_shift_spec;		/* go ask user for it */

		if change_item = 11 then		/* if this is "c work_class" */
		     if ^got_int_abs then		/* and int|abs was not already given */
			call get_int_abs;		/* go ask user for it */

/* we know values were not already given, or we would not be here */
		if change_item = 21 then		/* shifts */
		     call get_int_list (change_names (change_item), (8), nval);
		else call get_values (vtypes (change_item), change_names (change_item), nval);

	     end;					/* end "no more type ahead" do group */
	end;					/* end of "all other variable formats" do group */

asked_type:

/* we now have all the info necessary to make a change */

	if gcsw then do;				/* if global change */
	     if wcsw then do;
		gcfirst = 1;
		gclast = 16;
	     end;
	     else do;
		gcfirst = 17;
		gclast = mgt.current_size;
	     end;

	     do i = gcfirst to gclast;
		mgtep = addr (mgt.entry (i));
		call change_one_item;
	     end;
	end;

	else call change_one_item;			/* regular change */

	goto ask_code;

     end change;


/* ****************************************************************************************************************** */


change_one_item: proc;

/* procedure to change one item in one mgt entry; called in a loop over all
   entries of one type, for the global_change request, or just once, for the change request */

dcl  i fixed bin;

	goto item (change_item);

/* item 1 is a "." or "*" which exits from change without coming here */

item (2): mgt.switches.prio_sked_enabled = bval (1);	/* prio, prio_sked */
	return;

item (3): if ftemp = -1e0 then group.max_prim = -1;	/* maxu, max_prim, maxp */
	else do;
	     call ioa_ ("warning: changing max_prim to value not -1");
	     group.max_prim = ftemp;
	end;
	return;

item (4): group.group_id = char32;			/* id */
	return;

item (5): if ftemp < 0 then group.minamax = 32767;	/* Multics will never get that big ... */
	else group.minamax = ftemp;			/* abs, abs_max, minamax */
	return;

item (6): group.num = ftemp;				/* numerator, num */
	return;

item (7): group.denom = ftemp;			/* denominator, denom, den */
	return;

item (8): group.num1 = ftemp;				/* num1 */
	return;

item (9): group.denom1 = ftemp;			/* denom1, den1 */
	return;

item (10): group.minu = ftemp;			/* constant, const, con */
	return;

item (11): do i = 1 to nshf;				/* work_class, wc */
	     if int_wc then
		group.int_wc (shf (i)) = ival (i);
	     else group.abs_wc (shf (i)) = ival (i);
	end;
	return;

item (12):					/* absentee */
	if ^wcsw then do;				/* c absentee for a group   */
	     if default_absentee then do;
		do i = 1 to 4;
		     group.absentee.default_queue (i) = q (i);
		end;
		if string (group.absentee.default_queue) ^= ""b then /* if it is the default for any queues */
		     group.absentee.default_group = "1"b; /* flag it as a default absentee group */
		else group.absentee.default_group = "0"b; /* otherwise clear possible old value */
	     end;
	     else group.absentee.allowed = bval (1);
	end;

/* items above are all for groups - those below, for work classes */

	else do i = 1 to nshf;			/* item 12 can be for group or work class */
	     if (^gcsw | work_class.switches.defined (shf (i))) then
		work_class.switches.absentee_allowed (shf (i)) = bval (i);
	end;

	return;

item (13): do i = 1 to nshf;				/* percent, pct, % */
	     if (^gcsw | work_class.switches.defined (shf (i))) then
		work_class.min_pct (shf (i)) = ival (i);
	end;
	return;

item (14): do i = 1 to nshf;				/* defined, def */
	     work_class.switches.defined (shf (i)) = bval (i);
	     if mgtix ^= 1 then			/* if we are defining a wc other than 1 */
		mgt.switches.wc_initialized = "1"b;	/* this is no longer a transitional MGT */
	end;
	return;

item (15):					/* int_resp, ir */
item (16):					/* int_quantum, iq */
item (17):					/* resp, r */
item (18):					/* quantum, q */
item (19):					/* mode */

	do i = 1 to nshf;
	     if (^gcsw | work_class.switches.defined (shf (i))) then
		if change_item = 15 then		/* int_resp */
		     work_class.int_response (shf (i)) = fixed (fval (i));
		else if change_item = 16 then		/* int_quantum */
		     work_class.int_quantum (shf (i)) = fixed (fval (i));
		else if change_item = 17 then		/* resp */
		     work_class.response (shf (i)) = fixed (fval (i));
		else if change_item = 18 then		/* quantum */
		     work_class.quantum (shf (i)) = fixed (fval (i));
		else				/* change_item = 19 (mode) */
		     work_class.switches.realtime (shf (i)) = bval (i);
	end;
	return;

item (25):					/* max_percent, max_pct */
	do i = 1 to nshf;
	     if (^gcsw | work_class.switches.defined (shf (i))) then
		work_class.max_pct (shf (i)) = ival (i);
	end;
	return;

item (26):
	call ioa_ ("Page_weight is not yet supported.");
	return;



/* items above are per-work_class items; those below are header items, that apply to all work classes */


item (20):					/* normal_mode, norm */
	do i = 1 to nshf;
	     mgt.switches.deadline_mode (shf (i)) = bval (i);
	end;
	return;

item (21):					/* shifts */
	mgt.shift_defined (*) = ""b;			/* clear list of defined shifts - we have a new one */
	do i = 1 to nval;				/* count of defined shifts is in nval, not nshf */
	     mgt.shift_defined (ival (i)) = "1"b;
	end;
	return;

item (22):					/* absentee_max */
	if ftemp > 3276.6e0 & ftemp < 3276.8e0 then	/* perpetuate an old design error */
	     ftemp = 32767e0;
	group.absentee_max = ftemp;
	return;

item (23):					/* absentee_min */
	group.absentee_min = ftemp;
	return;

item (24):					/* absentee_pct */
	if ftemp < 1e0 then				/* if user typed 0.10 for 10% */
	     ftemp = ftemp * 100e0;			/* multiply by 100, since we store it as an integer */
	group.absentee_pct = ftemp;
	return;


     end change_one_item;


/* ****************************************************************************************************************** */


ck_int: proc (char_int, f, n) returns (bit (1));

/* procedure to decode a number (or pair of numbers) of the following form:
   n
   m-n

   and return the first value and the number of consecutive values implied by the pair.
   m and n can be any of the digits 0 thru 7 */

dcl  char_int char (*);
dcl  (f, n) fixed bin;
dcl  (i, j) fixed bin;
dcl  digits char (8) int static init ("01234567");

	if substr (char_int, 2) = "" then goto onedigit;
	else if substr (char_int, 4) = "" then goto hyph;
	else goto bad;
onedigit:
	i = index (digits, substr (char_int, 1, 1));	/* look up the digit */
	if i = 0 then goto bad;			/* not one of 0 thru 7 */
	n = 1;					/* one value returned */
	f = i - 1;				/* its value */
	goto good;

hyph:
	if substr (char_int, 2, 1) ^= "-" then goto bad;
	i = index (digits, substr (char_int, 1, 1));	/* scan digits starting at 0 */
	if i = 0 then goto bad;
	j = index (digits, substr (char_int, 3, 1));	/* therefore i and j are 1+ value of digit */
	if j = 0 then goto bad;
	if j < i then goto bad;			/* "6-3" is bad - user must say "3-6" */
	f = i - 1;				/* first value */
	n = j - f;				/* number of values */
						/* for example, "3-6" => f=3,n=4, since i=4,j=7 */

good:	return ("1"b);
bad:	return ("0"b);

     end ck_int;


/* ****************************************************************************************************************** */


copy_shift: proc (tsh, fsh);

dcl  (fsh, tsh) fixed bin;
dcl  i fixed bin;

	do i = 1 to 16;
	     mgtep = addr (mgt.entry (i));
	     if work_class.switches.defined (fsh) then do;/* only if wc defined on this shift */
		work_class.switches.defined (tsh) = "1"b;
		work_class.switches.absentee_allowed (tsh) = work_class.switches.absentee_allowed (fsh);
		work_class.switches.realtime (tsh) = work_class.switches.realtime (fsh);
		work_class.min_pct (tsh) = work_class.min_pct (fsh);
		work_class.max_pct (tsh) = work_class.max_pct (fsh);
		work_class.int_response (tsh) = work_class.int_response (fsh);
		work_class.int_quantum (tsh) = work_class.int_quantum (fsh);
		work_class.response (tsh) = work_class.response (fsh);
		work_class.quantum (tsh) = work_class.quantum (fsh);
	     end;
	end;

	do i = 17 to mgt.current_size;
	     mgtep = addr (mgt.entry (i));
	     group.int_wc (tsh) = group.int_wc (fsh);
	     group.abs_wc (tsh) = group.abs_wc (fsh);
	end;

	return;

     end copy_shift;


/* ****************************************************************************************************************** */


default_shift: proc (sh);

dcl  sh fixed bin;
dcl  i fixed bin;

	mgtep = addr (mgt.entry (1));			/* work class 1 is the only one, by default */
	work_class.switches.defined (sh) = "1"b;
	work_class.switches.absentee_allowed (sh) = "1"b;
	work_class.switches.realtime (sh) = ""b;
	work_class.min_pct (sh) = 100;
	work_class.max_pct (sh) = 0;
	work_class.int_response (sh) = 400;
	work_class.int_quantum (sh) = 50;
	work_class.response (sh) = 3200;
	work_class.quantum (sh) = 100;

	call undefine_wc (sh, 2, 16);			/* make sure of no garbage in wc 2-16 */

	do i = 17 to mgt.current_size;
	     mgtep = addr (mgt.entry (i));
	     group.int_wc (sh) = 1;
	     group.abs_wc (sh) = 1;
	end;

	return;

     end default_shift;


/* ****************************************************************************************************************** */


define: proc;

dcl  (like_sw, redefine_sw, undefine_sw) bit (1) aligned;
dcl  (i, lsh) fixed bin;

	redefine_sw, undefine_sw = ""b;

define_common:
	call get_shift_list (nval);
	if ^undefine_sw then
	     call get_like_shift (lsh, like_sw);

	do i = 1 to nval;				/* shifts to be defined are in ival(1) thru ival(nval) */
	     if redefine_sw | ^shift_is_defined (ival (i)) then do; /* if it's ok to change this shift */
		if undefine_sw then
		     call undefine_shift (ival (i));
		else if like_sw then
		     call copy_shift (ival (i), lsh);
		else call default_shift (ival (i));

		if undefine_sw then mgt.shift_defined (ival (i)) = ""b;
		else mgt.shift_defined (ival (i)) = "1"b;
	     end;

	     else call ioa_ ("shift ^d already defined; use redefine to change it", ival (i));
	end;

	return;

redefine: entry;

	redefine_sw = "1"b;
	undefine_sw = ""b;
	goto define_common;

undefine: entry;

	redefine_sw, undefine_sw = "1"b;
	goto define_common;

     end define;


/* ****************************************************************************************************************** */


get_int_abs: proc;

/* procedure to read the interactive|absentee specification;
   it may be "interactive", "absentee", "int" or "abs";
   this entry point prompts for it if it was not typed ahead;
   the check_int_abs entry point checks if it was typed ahead,
   if so, reads it and returns "1"b, if not, returns "0"b */

dcl  cksw bit (1) aligned;

	cksw = "0"b;

	call ask_ ("""interactive"" or ""absentee"" ", char32);

int_abs_common:
	if char32 = "interactive" then goto int;
	if char32 = "int" then do;
int:	     int_wc = "1"b;
	     goto exit_ok;
	end;
	else if char32 = "absentee" then goto abs;
	else if char32 = "abs" then do;
abs:	     int_wc = "0"b;
	     goto exit_ok;
	end;
	else do;
	     if cksw then goto exit_ng;		/* go return "0"b */
	     call ioa_ ("bad value: ""^a""", char32);
	     call ask_$ask_clr;
	     goto int_abs_common;			/* insist */
	end;

exit_ng:	return ("0"b);
exit_ok:	if cksw then do;
	     call ask_$ask_c (char32, flag);		/* remove it from the line */
	     return ("1"b);
	end;
	else return;

check_int_abs: entry returns (bit (1));
	cksw = "1"b;
	call ask_$ask_n (char32, flag);
	if flag = 0 then goto exit_ng;		/* nothing typed ahead */
	goto int_abs_common;			/* something there - go see if it is "int" or "abs" */

     end get_int_abs;


/* ****************************************************************************************************************** */


get_int_list: proc (prompt, mxv, nv);

/* procedure to read a list, prompting for it if not typed ahead;
   the list is of the form:
   i  j  k-l  m  n-o  p  ...
   that is, integers, or pairs of the form m-n;
   m-n pairs are expanded into m m+1 ... n-1 n;

   prompt is the prompting message;
   mxv is the most values the caller wants;
   nv is the actual number of values returned;
   values are returned in ival(1) thru ival(nv).
*/

dcl  prompt char (*);
dcl  (mxv, nv) fixed bin;
dcl  i fixed bin;
dcl  (f, n) fixed bin;

ask_int_list:
	call ask_ ("^a ", char32, prompt);
	nv = 0;					/* initialize counter */
	if char32 = "none" then return;		/* the list is empty */
	if ^ck_int (char32, f, n) then do;		/* bad value */
bad_int:	     call ioa_ ("bad value: ""^a""", char32);
	     call ask_$ask_clr;
	     goto ask_int_list;
	end;

get_int_loop:
	if nv + n > mxv then			/* if m-n pair expands into too many values */
	     goto bad_int;				/* go complain and start over */

	do i = 0 to n - 1;				/* this loop stores values for both m-n pairs and single values */
	     nv = nv + 1;
	     ival (nv) = f + i;
	end;

	if nv = mxv then return;			/* if we have gotten max allowed values */

	call ask_$ask_n (char32, flag);		/* see if anything typed ahead */
	if flag = 0 then return;			/* nothing */
	if ^ck_int (char32, f, n) then return;		/* something, but not right form */
	call ask_$ask_c (char32, flag);		/* right form: read it again to remove it from the line */
	goto get_int_loop;				/* go decode and store it */

     end get_int_list;


/* ****************************************************************************************************************** */


get_like_shift: proc (sh, sw);

dcl  sh fixed bin;
dcl  sw bit (1) aligned;

	sw = ""b;					/* we have not gotten a "like" shift yet */

	call ask_$ask_n (char32, flag);		/* look for type ahead */
	if flag > 0 then				/* there is some */
	     if char32 = "like" then do;		/* "like" must be typed ahead if it is to be given */
		call ask_$ask_c (char32, flag);	/* get past "like" */
		call ask_$ask_n (char32, flag);	/* see what's next */
		if flag > 0 then			/* something there */
		     if char32 = "shift" then		/* allow "shift" to preceed the number, if typed ahead */
			call ask_$ask_c (char32, flag); /* get past "shift" */

ask_like_shift:
		call ask_$ask_int ("like shift ", sh);	/* ask for one shift number */
		if sh < 0 | sh > 7 then do;
		     call ioa_ ("illegal shift number: ^d", sh);
		     call ask_$ask_clr;
		     goto ask_like_shift;
		end;

		sw = "1"b;			/* we got a like shift */
	     end;

	return;

     end get_like_shift;


/* ****************************************************************************************************************** */


get_shift_list: proc (nv);

dcl  nv fixed bin;

	call ask_$ask_n (char32, flag);		/* see if any type ahead */
	if flag > 0 then				/* if there is */
	     if substr (char32, 1, 5) = "shift" then	/* allow shift or shifts to be typed ahead */
		call ask_$ask_c (char32, flag);	/* get past it, if there */
ask_shifts:
	call get_int_list ("shifts ", (8), nv);
	if nv = 0 then do;
	     call ioa_ ("some shifts must be given");
	     call ask_$ask_clr;
	     goto ask_shifts;
	end;

	return;

     end get_shift_list;


/* ****************************************************************************************************************** */


get_shift_spec: proc;

/* procedure to read a shift specification of one of the following forms, returning output as indicated:

   shift n		nshf=1;shf(1)=n;shf(2) thru shf(mxval) = possible other shifts; mxval = how many altogether.
   shift m-n		nshf = number of shifts defined in m-n range;shf(1) thru shf(nshf) = those shifts; mxval = 1.
   shift all		nshf = number of shifts defined at site;shf(1) thru shf(nshf) = those shifts; mxval = 1.

   in all cases, fshift = shf(1); lshift = shf(nshf);nshift = lshift-fshift+1 (=nshf unless gaps in defined shifts)

*/

dcl  (f, n) fixed bin;

ask_shift: call ask_ ("shift(s) ", char32);		/* "shift" is optional if we prompted the user */
	if substr (char32, 1, 5) = "shift" then goto ask_shift; /* but required if he typed ahead */

	nshf = 0;					/* initialize counter of specified shifts */

	if char32 = "all" then do;			/* all defined shifts */
	     do shift = 0 to 7;
		if mgt.shift_defined (shift) then do;	/* is this one defined? */
		     nshf = nshf + 1;		/* if so, count it */
		     shf (nshf) = shift;		/* and remember its number */
		end;
	     end;

	     fshift = shf (1);
	     lshift = shf (nshf);
	     nshift = lshift - fshift + 1;
	end;

	else do;					/* not "all" so better be a shift number or s1-s2 pair */
	     if ^ck_int (char32, f, n) then do;		/* if not an integer or an s1-s2 pair */
		call ioa_ ("bad shift value: ""^a""", char32);
		call ask_$ask_clr;
		goto ask_shift;
	     end;

	     nshift = n;				/* number of shifts */
	     fshift = f;				/* first one */
	     lshift = fshift + nshift - 1;		/* last one */

	     do shift = fshift to lshift;		/* fill in shift numbers in this range */
		if mgt.shift_defined (shift)		/* if shift defined */
		     | shift = fshift | shift = lshift then do; /* or is one of the shifts typed in */
		     nshf = nshf + 1;
		     shf (nshf) = shift;
		end;
	     end;
	end;

	got_shift_spec = "1"b;			/* remember that user gave it and we are not using the default */
	mxval = 1;				/* we expect one value, to be assigned to all specified shifts */

	if nshift > 1 then return;			/* provided that more than one shift (m-n) was specified */
						/* but if only a single shift number was specified, then a list
						   of values can be given, to be assigned to successive defined
						   shifts, starting with the one given */
	mxval = 1;				/* initialize counter of how many values could be given */
						/* and fall thru, past the set default entry point */

set_default_shift_spec: entry;			/* come here to set defaults before seeing what was typed */
						/* a single value is assigned to all defined shifts, by default,
						   while the elements of a list of values are assigned
						   to successive shifts */
	do shift = fshift + 1 to 7;			/* fshift is -1 if we came in at the set default entry */
	     if mgt.shift_defined (shift) then do;	/* find all defined shifts after the specified one */
		mxval = mxval + 1;			/* count them in mxval */
		shf (mxval) = shift;		/* and remember their numbers */
	     end;
	end;


	return;

     end get_shift_spec;


/* ****************************************************************************************************************** */


get_values: proc (vtype, prompt, nv);

/* procedure to read a list of one or more values, prompting for them if they are not typed ahead.
   vtype is the value type: 1=integer;2=floating point;3=keyword.
   prompt is the prompting message.
   nv is the number of values returned.
   values are returned in one of the arrays: ival, fval, or bval, depending on vtype.

*/

dcl  prompt char (*);
dcl  (nv, vtype) fixed bin;
dcl  i fixed bin;

	call ask_val (vtype, 1, prompt);
	nv = 1;					/* we have at least one value */

	if mxval > 1 then				/* if more than one value allowed */
	     do i = 2 to mxval;			/* see if any more values were given */
	     call ask_$ask_n (char32, flag);		/* look ahead without removing next word from line */
	     if flag ^= 0 & char32 ^= "." & char32 ^= "*" then do; /* if something there, and not terminator char */
		call ask_cval (vtype, i, flag);	/* see if it is of the right data type */
		if flag > 0 then			/* if it is, ask_cval has stored it */
		     nv = nv + 1;			/* count it */
	     end;					/* end something there */
	end;					/* end loop from 2 to mxval */

/* having gotten one or more values, see what we got, and set some variables accordingly */

	if nv > 1 then				/* if more than one value was given */
	     nshf = nv;				/* remember to set exactly that many values */

	else do;					/* only one value was given */
	     if ^got_shift_spec then			/* default is "shift all" when one value given */
		nshf = mxval;			/* so remember to set values for all defined shifts */

	     if nshf > 1 then			/* if we want to assign values for several shifts */
		do i = 2 to nshf;			/* since we got only one value */
		call assign_value (vtype, i, 1);	/* make the right number of copies of it */
	     end;
	end;

	return;

     end get_values;


/* ****************************************************************************************************************** */


look_ahead_value: proc (vtype, nv);

/* procedure to look ahead on the line for one or more typed ahead values.
   If none there, nv = 0 on return. If at least one there, get_values is called
   to get it, and any others that follow it. Values are returned as described under get_values.

*/

dcl  (nv, vtype) fixed bin;

	nv = 0;					/* until we find something */

	if vtype = 1 then				/* integers */
	     call ask_$ask_nint (itemp, flag);
	else if vtype = 2 then			/* floating points */
	     call ask_$ask_nflo (ftemp, flag);
	else if vtype = 3 then			/* keywords */
	     call ask_nkey (btemp, flag);		/* internal procedure */

	if flag = 1 then				/* if something was there */
	     call get_values (vtype, "", nv);		/* go get it, and others */

	return;

     end look_ahead_value;


/* ****************************************************************************************************************** */


prgp: proc (zp);

/* procedure to print all information about one group.
   zp is a pointer to the mgt entry containing the group. */

dcl  zp ptr;
dcl  (ctmp1, ctmp2) char (32) aligned, ii fixed bin;
dcl  i fixed bin;
	if zp -> group.minamax < 32767 then call ioa_$rsnnl ("(abs max ^.1f + ^d/^d)", ctmp1, ii,
		zp -> group.minamax / 1e1, zp -> group.num1, zp -> group.denom1);
	else ctmp1 = "";
	if zp -> group.denom ^= 0 then call ioa_$rsnnl ("+ ^d/^d", ctmp2, ii,
		zp -> group.num, zp -> group.denom);
	else ctmp2 = "";
	if zp -> group.max_prim < 0 then call ioa_ ("^/^8a^2x-1 ^a",
		zp -> group.group_id, ctmp1);
	else call ioa_ ("^/^8a^2x^5.1f ^a ^a",
		zp -> group.group_id, zp -> group.minu / 1e1, ctmp2, ctmp1);

	call ioa_ ("int wc: ^8(^d^x^)",
	     zp -> group.int_wc);
	call ioa_ ("abs wc: ^8(^d^x^)",
	     zp -> group.abs_wc);

/* Print lines of the form:
   absentee: max min pct
   .          MX  MN PCT%
*/

	call ioa_ ("absentee:^11tmax^15tmin^19tpct^/^11t^3d^15t^3d^19t^3d%",
	     zp -> group.absentee_max, zp -> group.absentee_min, zp -> group.absentee_pct);

	if zp -> group.absentee.allowed then
	     call ioa_ ("absentee allowed");
	else call ioa_ ("absentee not allowed");
	if zp -> group.absentee.default_group then do;
	     call ioa_$nnl ("default group for queues:");
	     do i = 1 to 4;
		if zp -> group.absentee.default_queue (i) then
		     call ioa_$nnl ("^x^d", i);
	     end;
	     call ioa_ ("");
	end;

	return;

     end prgp;


/* ****************************************************************************************************************** */


print_ivals: proc (which, heading, fmt, ivals);

dcl  (which, bvals) (0:7) bit (1) unaligned;
dcl  ivals (0:7) fixed bin;
dcl  iflts (0:7) fixed bin (17) unaligned;
dcl  (fmt, heading) char (*);
dcl  scale float bin;
dcl  (i, vtype) fixed bin;

	vtype = 1;
	goto print_common;

/* ********** */

print_iflt: entry (which, heading, fmt, iflts, scale);

	vtype = 2;
	goto print_common;

/* ********** */

print_bvals: entry (which, heading, fmt, bvals);

	vtype = 3;
	goto print_common;

/* ********** */

print_shfs: entry (which, heading, fmt);

	vtype = 4;
	goto print_common;

/* ********** */

print_ivals_check_zero:
     entry (which, heading, fmt, iflts);

	vtype = 5;

/* ********** */

print_common:

	call ioa_$nnl (heading);

	do i = 0 to 7;
	     if which (i) then
		if vtype = 1 then
		     call ioa_$nnl (fmt, ivals (i));
		else if vtype = 2 then
		     call ioa_$nnl (fmt, float (iflts (i)) / scale);
		else if vtype = 3 then
		     call ioa_$nnl (fmt, bvals (i));
		else if vtype = 4 then
		     call ioa_$nnl (fmt, i);
		else call ioa_$nnl (fmt, (iflts (i) = 0), iflts (i)); /* vtype must be 5 */
	end;
	call ioa_ ("");

	return;

     end print_ivals;


/* ****************************************************************************************************************** */


prwc: proc (zp);

/* procedure to print all information about one work class.
   zp is a pointer to the mgt entry containing the work class. */

dcl  zp ptr;

	call ioa_$nnl ("^/^2a", zp -> work_class.wc_name);
	if string (zp -> work_class.switches.defined) = ""b then do;
	     wcundef = "1"b;
	     return;
	end;

	call print_shfs (zp -> work_class.switches.defined, "^xdefined on shifts", "^x^5d");

	call print_bvals (zp -> work_class.switches.defined, "^4xabsentee allowed",
	     "^[^3xyes^;^4xno^]", zp -> work_class.switches.absentee_allowed);

	call print_bvals (zp -> work_class.switches.defined, "^16xmode",
	     "^[^4xrt^;^2xnorm^]", zp -> work_class.switches.realtime);

	call print_ivals (zp -> work_class.switches.defined, "^9xmin percent",
	     "^3x^3d", zp -> work_class.min_pct);

	call print_ivals_check_zero (zp -> work_class.switches.defined, "^9xmax percent",
	     "^[^6x^1s^;^3x^3d^]", zp -> work_class.max_pct);


	call print_iflt (zp -> work_class.switches.defined, "^12xint resp",
	     "^x^5.2f", zp -> work_class.int_response, 100e0);

	call print_iflt (zp -> work_class.switches.defined, "^9xint quantum",
	     "^x^5.2f", zp -> work_class.int_quantum, 100e0);

	call print_iflt (zp -> work_class.switches.defined, "^16xresp",
	     "^x^5.2f", zp -> work_class.response, 100e0);

	call print_iflt (zp -> work_class.switches.defined, "^13xquantum",
	     "^x^5.2f", zp -> work_class.quantum, 100e0);


	return;

     end prwc;


/* ****************************************************************************************************************** */


pxref: proc;

/* procedure to print a cross reference of groups and work classes.
   NOTE: this code assumes that the mgt passes the "verify" checks, and no
   attempt is made to do anything sensible with an mgt that fails those checks.
   User documentation emphasizes this. */

/* Scan work classes and groups - see which shifts are used,
   and if any groups do not allow absentees (forcing them to be moved to other groups) */

	print_pct_ignored = ""b;			/* turned on if we must print msg explaining asterisk */
	no_abs_count = 0;				/* count the no-absentee groups, if any */
	no_abs = ""b;				/* remember if there are any at all */
	nshift = 0;				/* count shifts used */
	shift_used (*) = ""b;			/* remember which ones are used */

	do i = 1 to 16;				/* go thru work classes */
	     mgtep = addr (mgt.entry (i));		/* get ptr to work class */
	     do shift = 0 to 7;			/* go thru shifts */
		if work_class.switches.defined (shift) then
		     shift_used (shift) = "1"b;
	     end;
	end;

	do shift = 0 to 7;				/* fill in array of shift numbers
						   (for convenience in later code) */
	     if shift_used (shift) then do;
		nshift = nshift + 1;		/* count shifts used */
		shifts (nshift) = shift;		/* and save their numbers */
	     end;
	end;

	do i = 17 to mgt.current_size;		/* go thru groups */
	     mgtep = addr (mgt.entry (i));		/* get ptr to group */
	     if ^group.absentee.allowed then do;	/* if it does not allow absentees */
		no_abs = "1"b;			/* remember that such groups exists */
		no_abs_count = no_abs_count + 1;	/* and count them */
	     end;
	end;

/* Print heading */

	call ioa_$nnl ("^/Work classes defined on shift(s):");
	do i = 1 to nshift;
	     call ioa_$nnl ("^x^d", shifts (i));
	end;
	call ioa_ ("^2/WC^13xGROUP(S)");

/* Initialize for printing cross reference of each shift */

	lshift = -1;				/* we don't print out identical shifts more than once -
						   we just say "like shift N" */
						/* lshift remembers which one it is like, while we see if there
						   are any more like it */
	ival (*) = 0;				/* we use ival to remember which ones we actually printed out */

/* Outer loop on shifts - but only the ones for which work classes are defined */
	do i = 1 to nshift;
	     shift = shifts (i);			/* get actual shift number */

/* Check for this shift being like one we already printed */

	     if lshift >= 0 then do;			/* the previous shift we looked at was like one we printed */
		if shifts_alike (lshift, shift) then	/* if this one is like it too */
		     if i < nshift then		/* and there are more shifts */
			goto next_shift;		/* go look at next one */
		     else i = i + 1;		/* trick to special case the last one, when the
						   last n shifts are alike (code below says "i-1") */
						/* fall thru and print message which includes this shift */

/* This shift is not like the previous one. Print message for previous ones,
   of the form: shift(s) i j k ... like shift N */

		do j = 1 to nshift			/* find index of first shift that was like the one printed */
		     while (shifts (j) ^= fshift);
		end;
		if j = i - 1 then			/* if just one shift like it */
print_one_alike:
		     call ioa_ ("^5xshift ^d like shift ^d", shifts (j), lshift);
		else do;
		     call ioa_$nnl ("^5xshifts");
		     do k = j to i - 1;
			call ioa_$nnl ("^x^d", shifts (k));
		     end;
		     call ioa_ ("^xlike shift ^d", lshift);
		end;

		if i > nshift then goto next_shift;	/* exit, if last n shifts were alike */
	     end;

/* If this shift was not like the previous one, it might still be like one of the others */

	     lshift = -1;				/* start by assuming it isn't */
	     if i > 1 then				/* if there are any others */
		do j = 1 to i - 1;			/* go thru them */
		if ival (shifts (j)) = 1 then		/* only look at ones that were printed */
		     if shifts_alike (shifts (j), shift)/* compare them to this one */
		     then do;			/* if equal */
			lshift = shifts (j);	/* remember the number of the earlier one */
			fshift = shift;		/* and remember that this one is the first one like it */
			if i = nshift then do;	/* special case last one like one other */
			     j = nshift;		/* index of last shift, used for printing it */
			     i = i + 1;		/* force exit from loop */
			     goto print_one_alike;
			end;
			goto next_shift;		/* go look at next one */
		     end;
	     end;

/* if we fall thru here, there is no way we can get out of printing this shift */

	     call ioa_ ("^5xshift ^d", shift);
	     call pxshft (shift);			/* go print it */
	     ival (shift) = 1;			/* and remember that we did so */

next_shift: end;

	if print_pct_ignored then			/* if there was a realtime work class */
	     call ioa_ ("^/* This percent is not counted because the work class is realtime on this shift.");

	return;


/* ********** INTERNAL PROCEDURE WITHIN THIS INTERNAL PROCEDURE ********** */


shifts_alike: proc (s1, s2) returns (bit (1) aligned);

/* procedure to determine whether or not two shifts are alike,
   with respect to work class and load control group definitions */

dcl  (s1, s2) fixed bin;
dcl  i fixed bin;

	     do i = 1 to 16;
		mgtep = addr (mgt.entry (i));
		if work_class.min_pct (s1) ^= work_class.min_pct (s2) then goto diff;
		if work_class.max_pct (s1) ^= work_class.max_pct (s2) then goto diff;
		if work_class.switches.defined (s1) ^= work_class.switches.defined (s2) then goto diff;
		if work_class.switches.absentee_allowed (s1) ^= work_class.switches.absentee_allowed (s2)
		then goto diff;
	     end;
	     do i = 17 to mgt.current_size;
		mgtep = addr (mgt.entry (i));
		if group.int_wc (s1) ^= group.int_wc (s2) then goto diff;
		if group.abs_wc (s1) ^= group.abs_wc (s2) then goto diff;
	     end;
	     return ("1"b);				/* we were unable to find any differences */
diff:	     return ("0"b);				/* something was different */

	end shifts_alike;


     end pxref;


/* ****************************************************************************************************************** */


pxshft: proc (shift);

/* procedure to print cross reference for one shift */

dcl  shift fixed bin;
dcl  (i, j, igrp, agrp, dfct, colct) fixed bin;
dcl  (int, abs, int_abs_diff) bit (1) aligned;
dcl  print_asterisk bit (1) aligned;


	do i = 1 to 16;				/* go thru work classes, examining and printing each */
	     mgtep = addr (mgt.entry (i));
	     if ^work_class.switches.defined (shift) then goto next_wc; /* skip undefined ones */
	     wcp = mgtep;				/* remember the ptr to it */
	     int_abs_diff = ""b;			/* these are per-work class data */
	     igrp, agrp = 0;
	     default_absentee = "0"b;
	     string (dflt_q) = ""b;
	     do j = 17 to mgt.current_size;		/* pre-scan groups to see what we have to print */
		mgtep = addr (mgt.entry (j));
		if group.int_wc (shift) = i then int = "1"b;
		else int = ""b;
		if ^group.absentee.allowed then goto noabs;
		if group.abs_wc (shift) = i then abs = "1"b;
		else
noabs:		     abs = ""b;

		if ^int & ^abs then			/* if this group does not use the work class we're printing */
		     goto next_group;
		if int ^= abs then int_abs_diff = "1"b;
		if int then igrp = igrp + 1;		/* count interactive groups */
		if abs then agrp = agrp + 1;		/* count absentee groups */
		if group.absentee.default_group then do;/* if this is a default absentee group */
		     default_absentee = "1"b;		/* remember that such a group exists */
		     string (dflt_q) = string (dflt_q) | string (group.absentee.default_queue);
						/* remember which queues have defaults */
		end;
next_group:    end;					/* end of prescan loop over groups */

	     if wcp -> work_class.switches.realtime (shift) then /* if realtime */
		print_pct_ignored, print_asterisk = "1"b; /* remember to say so */
	     else print_asterisk = ""b;		/* otherwise don't */

/* now print the stuff */

	     call ioa_$nnl ("^2d^2x^3d^[*^;%^]^[(^3d)^;^5x^1s^]^2x", i, wcp -> work_class.min_pct (shift),
		print_asterisk, (^print_asterisk & (wcp -> work_class.max_pct (shift) ^= 0)),
		wcp -> work_class.max_pct (shift));


	     if igrp > 0 then do;			/* if any interactive groups in this work class */
		if int_abs_diff then call ioa_$nnl ("int^x");
		else call ioa_$nnl ("i&a^x");
		call pxgrps (igrp, 1);		/* go print igrp interactive groups */
	     end;

	     if agrp > 0 & int_abs_diff then do;	/* if absentees not identical to interactives */
		if igrp > 0 then call ioa_$nnl ("^10xabs^x"); /* if we printed interactives */
		else call ioa_$nnl ("abs^x");
		call pxgrps (agrp, 2);		/* go print agrp absentee groups */
	     end;
	     else if igrp = 0 then			/* if neither interactive nor absentee groups in this wc */
		call ioa_ ("");			/* get back to left margin - last call was to ioa_$nnl */

	     if default_absentee then do;		/* if a default absentee group is in this work class */
		call ioa_$nnl ("^2xq");		/* print which ^2xqueues */
		dfct = 0;
		colct = 0;
		do j = 1 to 4;			/* go over the queues */
		     if dflt_q (j) then do;
			dfct = dfct + 1;
			if dfct = 1 then goto prq;	/* go print q number */
			if j = 4 then do;		/* if last one */
			     j = 5;		/* tricky */
			     goto prq;		/* prq says "j-1" */
			end;
		     end;
		     else if dfct = 1 then dfct = 0;	/* previous q but not this one */
		     else if dfct > 0 then do;	/* previous few queues - print the last one */
prq:
			colct = colct + 2;		/* count cols, for later spacing to next field */
			if dfct > 2 then		/* if more than 2 queues */
			     call ioa_$nnl ("-^d", j - 1); /* print "m-n" */
			else call ioa_$nnl ("^x^d", j); /* just print a queue */
			if dfct > 1 then dfct = 0;	/* previous queues but not this one */
		     end;
		end;

		colct = 11 - colct + 1;		/* number of columns left to get to next field */
		call ioa_$nnl ("^vxdflt", colct);

		call pxgrps (no_abs_count, 3);	/* go print groups whose absentees get put into this work class */
	     end;

next_wc:	end;

/* ********** INTERNAL PROCEDURE WITHIN THIS INTERNAL PROCEDURE ********** */

pxgrps:	proc (ngroups, type);

/* procedure to print ngroups group names, that fit into the
   category specified by type. type can be 1, 2, or 3, indicating
   interactive, absentee, and default absentee groups, respectively.
   names are printed four per line, starting in column 16 */

dcl  (ngroups, type) fixed bin;
dcl  (lct, gct) fixed bin;

	     gct, lct = 0;				/* initialize group and groups-per-line counters */
	     do j = 17 to mgt.current_size;
		mgtep = addr (mgt.entry (j));
		if type = 1 then do;		/* interactive */
		     if group.int_wc (shift) = i then goto prgp;
		     else goto skip_grp;
		end;
		else if type = 2 then do;		/* absentee */
		     if group.abs_wc (shift) = i then goto prgp;
		     else goto skip_grp;
		end;
		else if type = 3 then do;		/* default absentee */
		     if ^group.absentee.allowed then	/* if absentees not allowed in this group */
			goto prgp;		/* they will have to be moved to a default absentee group */
		     else goto skip_grp;
		end;

prgp:		gct = gct + 1;			/* count groups printed */
		lct = lct + 1;			/* count groups on this line */
		if lct >= 5 then do;
		     lct = 1;
		     call ioa_$nnl ("^/^14x");
		end;
		call ioa_$nnl ("^x^8a", group.group_id);

skip_grp:		if gct >= ngroups then goto ret;	/* quit as soon as all groups are printed */
	     end;
ret:	     if lct > 0 | gct = 0 then call ioa_ ("");	/* carriage return, if we have printed part of a line */
	     return;
	end pxgrps;



     end pxshft;


/* ****************************************************************************************************************** */


scan_key: proc (keys, comma_count, bval, flag);

dcl  keys char (*);
dcl  key char (32) varying;
dcl  (comma_count, flag) fixed bin;
dcl  bval bit (1) aligned;
dcl  (comma_offset, curpos, keypos, kln, ln, n_commas) fixed bin;

	kln = length (keys);
	ln = length (char32) + 1 - verify (reverse (char32), " "); /* 1 nonblank gives 32+1-32=1 */

/* See if given keyword is one of the legal ones, and if so, get its position in the set of legal ones */

	key = "," || substr (char32, 1, ln) || ",";	/* to force match only on word delimited by commas */
	if keys = substr (key, 2, kln) then keypos = 1;	/* trivial case - only one legal keyword */
	else if ln + 1 > kln then keypos = 0;		/* keyword plus one comma longer than keys - no match possible */
	else if substr (keys, 1, ln + 1) = substr (key, 2, ln + 1) then /* first legal keyword has no leading comma */
	     keypos = 1;
	else if substr (keys, kln - ln, ln + 1) = substr (key, 1, ln + 1) then /* last one has no trailing comma */
	     keypos = kln - ln + 1;
	else if ln + 2 > kln then keypos = 0;		/* keyword plus two commas too long - no match possible */
	else do;					/* scan for match within legal keyword string */
	     keypos = index (keys, key);
	     if keypos > 0 then			/* if we found a match */
		keypos = keypos + 1;		/* move past the leading comma */
	end;

	if keypos = 0 then				/* if no match */
	     flag = 0;				/* tell caller, and do nothing else */

	else do;					/* keyword legal, so see if it corresponds to "1"b or "0"b */
	     flag = 1;				/* tell caller */
	     n_commas = 0;				/* count commas before the matching key */
	     curpos = 1;				/* start at beginning of first key */
	     do while (curpos < keypos);		/* keep looking until we hit the matching key */
		comma_offset = index (substr (keys, curpos, keypos - curpos), ","); /* look for comma */
		if comma_offset > 0 then do;		/* if we found one */
		     n_commas = n_commas + 1;		/* count it */
		     curpos = curpos + comma_offset;	/* move past it */
		end;
	     end;					/* fall thru when curpos >= keypos */

	     if n_commas < comma_count then		/* if the matching key is in the first half */
		bval = "1"b;			/* the keyword corresponds to "1"b */
	     else bval = "0"b;			/* if in the second half, "0"b */

	end;

	return;

     end scan_key;


/* ****************************************************************************************************************** */


shift_is_defined: proc (sh) returns (bit (1) aligned);

dcl  sh fixed bin;
dcl  i fixed bin;

	do i = 1 to 16				/* look thru all work classes */
	     while (^addr (mgt.entry (i)) -> work_class.switches.defined (sh));
	end;					/* to see if any are defined on the specified shift */

	if i <= 16 then				/* if any are */
	     return ("1"b);				/* say yes */
	else return (""b);				/* else say no */

     end shift_is_defined;

/* ****************************************************************************************************************** */


undefine_shift: proc (sh);

dcl  sh fixed bin;
dcl  i fixed bin;

	call undefine_wc (sh, 1, 16);			/* undefine work classes 1-16 on this shift */
	do i = 17 to mgt.current_size;		/* undefine all groups on this shift */
	     mgtep = addr (mgt.entry (i));
	     group.int_wc (sh) = 0;
	     group.abs_wc (sh) = 0;
	end;

	return;

     end undefine_shift;


/* ****************************************************************************************************************** */


undefine_wc: proc (sh, ft, lt);

dcl  (ft, lt, sh) fixed bin;
dcl  i fixed bin;

	do i = ft to lt;
	     mgtep = addr (mgt.entry (i));
	     work_class.switches.defined (sh) = ""b;
	     work_class.switches.absentee_allowed (sh) = ""b;
	     work_class.switches.realtime (sh) = ""b;
	     work_class.min_pct (sh) = 0;
	     work_class.max_pct (sh) = 0;
	     work_class.int_response (sh) = 0;
	     work_class.int_quantum (sh) = 0;
	     work_class.response (sh) = 0;
	     work_class.quantum (sh) = 0;
	end;

	return;

     end undefine_wc;


/* ****************************************************************************************************************** */


verify_mgt: proc;

/* procedure to verify the correctness and consistency of the mgt,
   and report all errors it finds */

dcl  err_max fixed bin init (5);
dcl  err_count fixed bin init (0);
dcl  warning_printed bit (1) aligned;
dcl  wc_printed bit (1) aligned;
dcl  low_pct (0:7) bit (1) aligned;
dcl  unused_pct (0:7) bit (1) aligned;
dcl  print_unused_pct bit (1) aligned;
dcl  pct_is_used bit (1) aligned;
dcl  wc_empty (0:7, 16) bit (1) aligned;

	wc_empty = ""b;				/* array initializations */
	low_pct = ""b;

	call ask_$ask_cint (itemp, flag);		/* check for optional max error count */
	if flag > 0 then err_max = itemp;		/* if given, override default with it */

/* The following code makes the same correctness tests that up_mgt_ makes, but when it
   finds an error, it reports it in more detail, and keeps going instead of quitting at the first error. */


	do shift = 0 to 7;				/* check consistency on each shift */

	     shift_used (shift) = ""b;		/* remember which shifts are used */
	     shift_pct = 0;				/* sum of percentages */
	     no_abs = ""b;
	     string (dflt_q) = ""b;			/* keep track of absentee groups */
	     unused_pct (shift) = ""b;		/* keep track of pcts unused because of
						   deadline or realtime scheduling */

	     do i = 1 to 16;			/* first go thru work classes */
						/* checking if defined, and adding up percentages */
		wcp = addr (mgt.entry (i));
		if wcp -> work_class.switches.defined (shift) then do; /* if defined */
		     wc_empty (shift, i) = "1"b;	/* since wc defined on shift, see if it is used */
						/* assume it is not used until we see that it is */
		     shift_used (shift) = "1"b;	/* at least one is, on this shift */

		     if mgt.switches.deadline_mode (shift) | wcp -> work_class.switches.realtime (shift) then do;
			pct_is_used = ""b;		/* remember not to count this one's percent */
			unused_pct (shift) = "1"b;	/*  remember to explain, if % < 100 on this shift */
		     end;
		     else pct_is_used = "1"b;		/* remember to add in this one's percent */
		     if wcp -> work_class.min_pct (shift) <= 0 then do;
			call ioa_ ("bad percent (^d) for work class ^d on shift ^d",
			     wcp -> work_class.min_pct (shift), i, shift);
			if ^pct_is_used then
			     call ioa_ ("(percent is ignored for realtime workclass, but must be > 0 to install MGT.)");
			call count_error;
		     end;

		     if wcp -> work_class.max_pct (shift) < 0 | wcp -> work_class.max_pct (shift) > 100 then do;
			call ioa_ ("bad max percent (^d) for work class ^d on shift ^d",
			     wcp -> work_class.max_pct (shift), i, shift);
			call count_error;
		     end;

		     call check_rq (wcp -> work_class.int_quantum (shift), "010"b); /* resp=0;int=1;realtm=0 */
		     call check_rq (wcp -> work_class.quantum (shift), "000"b); /* resp=0;int=0;realtm=0 */
		     if wcp -> work_class.switches.realtime (shift) then do; /* if realtime work class */
			call check_rq (wcp -> work_class.int_response (shift), "111"b); /* resp=1;int=1;realtm=1 */
			call check_rq (wcp -> work_class.response (shift), "101"b); /* resp=1;int=0;realtm=1 */
		     end;

		     if pct_is_used then		/* except for realtime work classes */
			shift_pct = shift_pct + wcp -> work_class.min_pct (shift); /* add up percentages */
		end;
	     end;					/* end loop on work classes */
	     if shift_pct > 100 then do;
		call ioa_ ("sum of work class percents > 100 (^d) on shift ^d", shift_pct, shift);
		call count_error;
	     end;
	     else if shift_used (shift) then
		if shift_pct < 100 then
		     low_pct (shift) = "1"b;

	     do i = 17 to mgt.current_size;		/* now go thru all groups */
		mgtep = addr (mgt.entry (i));

		if ^shift_used (shift) then do;	/* if no work classes defined on this shift */
		     if group.int_wc (shift) ^= 0 then call shift_err_int; /* there better be no work classes used */
		     if group.abs_wc (shift) ^= 0 then call shift_err_abs;
		end;

		else do;				/* some work classes are defined */
		     wc_empty (shift, group.int_wc (shift)) = "0"b; /* not empty */
		     wcp = addr (mgt.entry (group.int_wc (shift)));
		     if ^wcp -> work_class.switches.defined (shift) then /* see if this one is */
			call shift_err_int;		/* and complain if not */

		     if group.absentee.allowed then do; /* if absentees allowed in this group */
			wc_empty (shift, group.abs_wc (shift)) = "0"b; /* not empty */
			wcp = addr (mgt.entry (group.abs_wc (shift)));
			if ^wcp -> work_class.switches.defined (shift) then
						/* make sure their work class is defined */
			     call shift_err_abs;	/* and complain if not */
			if ^wcp -> work_class.switches.absentee_allowed (shift) then do;
			     call ioa_ ("group ""^a"" absentees on shift ^d are in work class ^d,
but that work class does not allow absentees", group.group_id, shift, group.abs_wc (shift));
			     call count_error;
			end;

			if group.absentee.default_group then do; /* if this is a default group for some queue(s) */
			     do j = 1 to 4;		/* go thru queues */
				if group.absentee.default_queue (j) then /* if it is for this queue */
				     if dflt_q (j) then do; /* but there already is one */
					call ioa_ ("more than one default group for absentee queue ^d:
group ""^a"" is an additional one (group ""^a"" is the first one)", j, group.group_id,
					     addr (mgt.entry (dflt_g (j))) -> group.group_id);
					call count_error;
				     end;

				     else do;	/* otherwise, remember that we have a default for this queue */
					dflt_q (j) = "1"b;
					dflt_g (j) = i;
				     end;		/* and remember which group, for possible error message */
			     end;
			end;
		     end;				/* end absentee allowed */

		     else do;			/* absentee not allowed in this group */
			no_abs = "1"b;		/* remember that there is such a group */
			if group.absentee.default_group then do;
			     call ioa_ ("group ""^a"" does not allow absentees, but is given as the default
group for absentee queue ^d", group.group_id, j);
			     call count_error;
			end;
		     end;				/* end absentees not allowed */
		end;				/* end some work classes defined on this shift */
	     end;					/* end loop thru all groups */

	     if no_abs then				/* if a no-absentee group exists */
		if string (dflt_q) ^= "1111"b then do;	/* and there are not default groups for all queues */
		     do j = 1 to 4;			/* print message for each queue */
			if ^dflt_q (j) then do;
			     call ioa_ ("There is no default group for absentee queue ^d, but there is a
group that does not allow absentees", j);
			     call count_error;
			end;
		     end;
		end;

	end;					/* end loop on shifts */

	do i = 17 to mgt.current_size;		/* make a last pass thru groups, checking group only parameters */
	     mgtep = addr (mgt.entry (i));
	     if group.absentee_pct < 0 | group.absentee_pct > 100 then do;
		call ioa_ ("illegal absentee percent (^d%) for group ""^a""",
		     group.absentee_pct, group.group_id);
		call count_error;
	     end;

	     if group.absentee_min > group.absentee_max then do;
		call ioa_ ("absentee_min (^d) greater than absentee_max (^d) for group ""^a""",
		     group.absentee_min, group.absentee_max, group.group_id);
		call count_error;
	     end;

	     if group.absentee_max < 0 then do;
		call ioa_ ("absentee_max (^d) for group ""^a"" is negative.", group.absentee_max, group.group_id);
		call count_error;
	     end;
	end;

	if err_count = 0 then
	     call ioa_ ("No errors");
	else call ioa_ ("^d errors - the mgt can not be installed", err_count);

/* Check for suspicious-looking conditions, that are not fatal errors,
   but are likely to be oversignts on the part of the user */

	warning_printed = "0"b;			/* remember that we have not printed a heading line */
	print_unused_pct = ""b;			/* stays off unless we print a * beside some shift */

	do shift = 0 to 7;				/* check for sum of percents < 100% on any shift */
	     if low_pct (shift)			/* look for first such shift */
		& ^mgt.switches.deadline_mode (shift) then do; /* except realtime shifts, whose pcts aren't used */
		call print_warning;			/* go print heading, if not already done */
		call ioa_$nnl ("Sum of work class percents is < 100% on shift(s):");
		do shift = shift to 7;		/* go thru shifts from this one to last */
		     if low_pct (shift) then do;
			call ioa_$nnl ("^x^d^[*^]", shift, unused_pct (shift));
			if unused_pct (shift) then print_unused_pct = "1"b; /* remember to explain the * */
		     end;
		end;
		if print_unused_pct then		/* if we put asterisks beside some shifts, explain them */
		     call ioa_
			("^/* There are realtime work classes in this shift; their percents are not counted.");
		call ioa_ ("");
	     end;
	end;					/* inner loop runs the index of this one out to its limit */

	wc_printed = ""b;				/* remember we have not printed wc heading */
	do shift = 0 to 7;				/* check for wc with no groups in it */
	     do i = 1 to 16;
		if wc_empty (shift, i) then do;	/* search for first such occurrence */
		     call print_warning;
		     if ^wc_printed then do;
			wc_printed = "1"b;
			call ioa_ ("The following work class(es) are unused on the indicated shifts");
		     end;
		     call ioa_$nnl ("shift ^d:  ", shift);
		     do i = i to 16;		/* go thru work classes from this one to last */
			if wc_empty (shift, i) then
			     call ioa_$nnl ("^x^d", i);
		     end;
		     call ioa_ ("");
		end;
	     end;					/* inner loop runs the index of this one out to its limit */
	end;					/* end loop on shifts */

	do shift = 0 to 7;
	     do i = 1 to 16;
		wcp = addr (mgt.entry (i));
		if wcp -> work_class.switches.defined (shift) &
		     ^wcp -> work_class.switches.realtime (shift) then do;
		     call check_rq (wcp -> work_class.int_response (shift), "110"b);
		     call check_rq (wcp -> work_class.response (shift), "100"b);
		end;
	     end;
	end;

	do i = 17 to mgt.current_size;		/* check for reasonable absentee user limits */
	     mgtep = addr (mgt.entry (i));
	     if group.absentee_max = 0		/* if max is zero */
		& ^(group.absentee_min = 0		/* and min and percent are not */
		& group.absentee_pct = 0) then do;	/* both zero, no absentee jobs for the group can log in */
		call print_warning;			/* print warning heading if not already done */
		call ioa_ ("group ""^a"": absentee_max=^d, absentee_min=^d, absentee_pct=^d%, so jobs from this group will never log in.",
		     group.group_id, group.absentee_max, group.absentee_min, group.absentee_pct);
	     end;
	end;

verify_exit: return;

/* ********** INTERNAL PROCEDURES WITHIN THIS INTERNAL PROCEDURE ********** */


check_rq: proc (val, sw);				/* check response and quantum values */

dcl  val fixed bin (17) unaligned;
dcl  sw bit (3) unaligned;
dcl  resp bit (1) unaligned defined (sw) pos (1);
dcl  int bit (1) unaligned defined (sw) pos (2);
dcl  realtm bit (1) unaligned defined (sw) pos (3);

	     if val > 0 then return;			/* positive value is ok for anything */
	     if resp & val = 0 then return;		/* zero is ok for realtime response */
						/* quantum must always be >0 */
						/* realtime response must >= 0 */
						/* nonrealtime response should be >= 0,
						   but we only give warning if it is negative */

	     if resp & ^realtm then			/* if just a warning */
		call print_warning;			/* tell user so */
	     else call count_error;			/* otherwise increment fatal error count */

	     call ioa_ ("^[^;zero or ^]negative ^[int_^]^[response^;quantum^] (^.2f) for ^[realtime ^]work class ^d on shift ^d",
		realtm, int, resp, float (val) / 100e0, realtm, i, shift);

	     return;

	end check_rq;


/* ********** ********** */

print_warning: proc;

	     if ^warning_printed then do;
		call ioa_ ("Warnings (will not prevent installation of MGT):");
		warning_printed = "1"b;
	     end;
	     return;

	end print_warning;

/* ********** ********** */

shift_err_int: proc;
dcl  wc fixed bin;
dcl  ia char (11);					/* interactive or absentee */
	     wc = group.int_wc (shift);
	     ia = "interactive";
shift_err_common:
	     if wc = 0 then
		call ioa_ ("^a work class of group ""^a"" on shift ^d is undefined (=0),
but work classes are defined on that shift", ia, group.group_id, shift);
	     else call ioa_ ("work class ^d is undefined on shift ^d but is used by group ""^a"" (^a)",
		     wc, shift, group.group_id, ia);
	     call count_error;
	     return;
shift_err_abs: entry;
	     wc = group.abs_wc (shift);
	     ia = "absentee";
	     goto shift_err_common;
	end shift_err_int;

/* ********** ********** */

count_error: proc;
	     err_count = err_count + 1;
	     if mod (err_count, err_max) = 0 then do;
		call ask_$ask_yn ("^d errors - do you wish to continue? ", char32, err_count);
		if char32 = "no" then goto verify_exit; /* nonlocal goto */
	     end;
	     return;
	end count_error;

     end verify_mgt;

initialize_mgt:
     procedure;

dcl  wcx fixed bin;

	mgt.author.proc_group_id = get_group_id_ ();
	mgt.table = "MGT";
	mgt.w_dir = get_wdir_ ();
	mgt.max_size = hbound (mgt.entry, 1);
	mgt.current_size = 17;			/* start with WCTE's */
	mgt.total_units = 0;
	mgt.version_indicator = "VERSION ";
	mgt.version = MGT_version_3;
	mgt.wc_initialized = "0"b;
	mgt.prio_sked_enabled = "1"b;
	mgt.prio_sked_on_tape = "1"b;
	do wcx = 1 to 16;
	     mgtep = addr (mgt.entry (wcx));
	     work_class.wc_name = ltrim (char (wcx));
	end;

	string (mgt.user_wc_defined) = "100000000000000"b;
	string (mgt.shift_defined) = (8)"1"b;		/* define all shifts */
	mgt.user_wc_min_pct = 100;

/**** We will define one work-class and one group */

	mgtep = addr (mgt.entry (1));
	work_class.switches.defined (*) = "1"b;		/* defined on all shifts */
	work_class.switches.absentee_allowed (*) = "1"b;	/* with absentee allowed */
	work_class.min_pct (*) = 100;			/* and getting all the time */
	work_class.min_pct (*) = 100;
	work_class.int_response (*) = 400;
	work_class.int_quantum (*) = 50;
	work_class.response (*) = 3200;
	work_class.quantum (*) = 100;

	mgtep = addr (mgt.entry (17));

	group.group_id = "Other";
	group.max_prim = -1;
	group.int_wc = 1;
	group.abs_wc = 1;
	group.absentee.allowed = "1"b;
	group.absentee_max = 1000;
	group.absentee_pct = 100;
	return;
     end initialize_mgt;

clean_up:
     procedure;

	if mgtp ^= null () then call release_temp_segment_ (ME, mgtp, (0));
	if mgtp1 ^= null () then if created_new_mgt then
		call terminate_file_ (mgtp1, (0), TERM_FILE_DELETE, (0));
	     else call terminate_file_ (mgtp1, 36 * (64 + mgtp1 -> mgt.current_size * 32), TERM_FILE_TRUNC_BC_TERM, (0));
	return;
     end clean_up;
     end ed_mgt;
