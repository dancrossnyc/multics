/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(75-08-01,GDixon), approve(), audit(),
     install(86-07-18,MR12.0-1098):
     Written initially.
  2) change(84-01-20,Lippard), approve(), audit(),
     install(86-07-18,MR12.0-1098):
     Use archive_$list_components.
  3) change(84-03-05,Lippard), approve(), audit(),
     install(86-07-18,MR12.0-1098):
     Free the correct archive component array structure and treat
     error_table_$logical_volume_not_connected as a fatal error (so it will
     complain instead of being quiet about it.
  4) change(86-02-15,GDixon), approve(86-03-24,MCR7365),
     audit(86-04-22,Dickson), install(86-04-22,MR12.0-1042):
     Fix bug which prevents listing segments when a .1 version of the segment
     also exists in the libraries.
  5) change(86-05-17,GDixon), approve(86-05-17,MCR7357),
     audit(86-07-10,Farley), install(86-07-18,MR12.0-1098):
     Changed call to tct_ to reference find_char_$first_in_table; this
     subroutine was renamed.
                                                   END HISTORY COMMENTS */



/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


lib_get_tree_:	procedure (APparent, path, Pstarname, Pexclude, Srequirements, Scontrol, tree_level, 
			 link_level, Parea, director, Pdirector_args, Pnodes, Acode)
		options	(rename	((alloc_, smart_alloc_)));

     dcl	APparent			ptr,		/* ptr to parent node of the node array we are	*/
						/* to create.  It must not be null. (In)	*/
	path			char(168) varying;	/* path name of the parent node, or a link path	*/
						/* if the parent node was a link. (In)		*/
%include lib_based_args_;
     dcl	tree_level		fixed bin,	/* number of generations which are parent to the	*/
						/* node array we are to create. (In)		*/
	link_level		fixed bin,	/* number of consecutive links we have processed	*/
						/* when in no-chase-links mode. (In)		*/
	Parea			ptr,		/* ptr to MSA we are to create the node in. (In)	*/
	director			entry (ptr, char(168) varying, ptr, ptr, bit(72) aligned, bit(36) aligned,
				       fixed bin, fixed bin, ptr, entry, ptr, ptr, fixed bin(35)),
						/* entry we are to call to validate (and further	*/
						/* process) each node in the array. (In)	*/
						/* Note that the director's calling sequence is	*/
						/* the same as ours.			*/
	Pdirector_args		ptr,		/* ptr to director-defined structure containing	*/
						/* information used by the director. (In)	*/
	Pnodes			ptr,		/* ptr to the node array which we created. (Out)	*/
	Acode			fixed bin(35),	/* (Ignored)				*/
	1 root_names		based (Proot_names),/* list of names on a root. 			*/
	  2 N			fixed bin,	/*     count of names.			*/
	  2 root_name (0 refer (root_names.N))		/*     array of names.			*/
				char (32),
	Proot_names		ptr,		/* ptr to root_names structure. (In)		*/
	root_type			fixed bin,	/* type of a root.  2 = directory, 4 = archive.	*/
	root_search_proc		char(65) varying,	/* procedure used to search root. (In)		*/
	MNnodes			fixed bin;	/* maximum size of the root node array. (In)	*/

     dcl						/*	automatic variables			*/
	Inode			fixed bin,	/* index of the node array element (node) we're	*/
						/* working on now.				*/
	Lstring_			fixed bin(35),	/* length of string_.			*/
	Nentries			fixed bin,	/* number of arch comp entries.		*/
	Nterminal_account		fixed bin(1),	/* terminal account switch from hcs_$quota_read	*/
	PBDarch			ptr unal,		/* ptr to base of archive descriptor chain.	*/
	PDarch			ptr,		/* ptr to an archive descriptor chain entry.	*/
	Pacl			ptr,		/* ptr to a segment ACL.			*/
	Parch			ptr,		/* ptr to the archive component we're working on.	*/
	Pdir_acl			ptr,		/* ptr to a directory ACL.			*/
	Piacl			ptr,		/* ptr to a group of IACLs from list_inacl_all.	*/
	Pparent			ptr,		/* ptr to our node's parent node.		*/
	Pstring_			ptr,		/* ptr to string_.				*/
	Ptemp			ptr,		/* a temporary ptr.				*/
	Schase_links		fixed bin(1),	/* chase switch.				*/
	author			char(33),		/* author of a link (33 chars so guaranteed to	*/
						/*  end with a space).			*/
	bit_count			fixed bin(24),	/* a segment or archive component bit count.	*/
	call_id			bit(70) aligned,	/* unique identifier of each logical call to	*/
						/* hcs_$star_ or hcs_$status_long.		*/
	char32			char(32),		/* character temporary.			*/
	clock			fixed bin(71),	/* a binary clock value.			*/
	code			fixed bin(35),	/* a status code.				*/
	count			fixed bin,	/* number of matching entries in a dir.		*/
	e			fixed bin,	/* entry switch:  1-$lib_root_node, 2-$root_node 	*/
	ent			char(32),		/* entry part of a path name.			*/
	error			label local,	/* address of current error handler.		*/
	1 flags			aligned,
	  2 archive		bit(1),		/* segment is an archive.			*/
	  2 object_seg		bit(1),		/* segment is an object segment.		*/
	  2 ascii			bit(1),		/* segment contains only ascii characters.	*/
	i			fixed bin,	/* a do-group index and integer temporary.	*/
	1 iacl_info,				/* information structure req'd by list_inacl_all.	*/
	  2 seg,					/*   information about segment IACLs.		*/
	    3 offsets (0:7)		bit(18) aligned,	/*     per ring offset of first ACLe in array.	*/
	    3 counts  (0:7)		fixed bin,	/*     per ring count of ACL entries.		*/
	  2 dir,					/*   information about directory IACLs.		*/
	    3 offsets (0:7)		bit(18) aligned,	/*     per ring offset of first ACLe in array.	*/
	    3 counts  (0:7)		fixed bin,	/*     per ring count of ACL entries.		*/
	j			fixed bin,	/* a do-group index.			*/
	k			fixed bin,	/* a do-group index.			*/
	msf_dir			char(168),	/* pathname of MSF directory.			*/
	n_components		fixed bin,	/* number of archive components		*/
	type			fixed bin;	/* a temporary containing node type of parent to	*/
						/* the node array we're creating.		*/

%include status_for_backup;

declare 1 sfb automatic aligned like status_for_backup;

     dcl						/*	based variables			*/
	1 Darch			aligned based (PDarch),
						/* an archive component descriptor.		*/
	  2 Pnext			ptr unal,		/* ptr to the next descriptor in the chain.	*/
	  2 Parch			ptr unal,		/* ptr to the archive component.		*/
	  2 Smode			bit(3) unal,	/* mode from archive component.		*/
	  2 pad			bit(8) unal,
	  2 bit_count		fixed bin(24) unal,	/* bit count from archive component.		*/
	  2 dtm			bit(36) aligned,	/* date-time modified for archive component.	*/
	  2 dtupdated		bit(36) aligned,	/* date-time component last updated.		*/
	  2 name			char(32) aligned,	/* component name.				*/
	1 acl (Nacls)		based (Pacl) like Dacl.acls,
						/* a segment ACL structure.			*/
	1 arch			based (Parch),	/* an archive component header.		*/
	  2 header_begin		char(8),		/* start-of-archive-header identification field.	*/
	  2 pad1			char(4),
	  2 name			char(32),		/* name of the archive component.		*/
	  2 dtem			char(16),		/* date-time component updated.		*/
	  2 mode			char(4),		/* user's access mode to segment when archived.	*/
	  2 dtm			char(16),		/* date-time segment last modified before it was	*/
	  2 pad2			char(4),		/*     archived.				*/
	  2 bit_count		char(8),		/* length of archive component (minus header), in	*/
						/* bits).					*/
	  2 header_end		char(8),		/* end-of-archive-header identification field.	*/
	area_var			area based (Parea),	/* area where tree is to be allocated.		*/
	clock_string		bit(72) aligned based (addr (clock)),
						/* bit string overlay for a binary clock value.	*/
	1 dir_acl (Ndir_acls)	based (Pdir_acl) like Ddir_acl.acls,
						/* a directory ACL structure.			*/
	node_string		bit(Lnode_string) aligned based (Pnode),
						/* overlay for the storage occupied by a node.	*/
	stop_search		label local,	/* where to go if search is being stopped	*/
	string_			char(Lstring_) based (Pstring_);

     dcl						/*	builtin functions			*/
         (addr, addrel, binary, divide, length, min, mod, null, pointer, rel,
          reverse, rtrim, size, string, substr, sum, verify)
				builtin;


     dcl						/*	entries				*/
	area			condition,	/* a condition name.			*/
	cleanup			condition,	/* a condition name.			*/
	archive_$list_components	entry (ptr, fixed bin(24), fixed bin, ptr, ptr, fixed bin, fixed bin(35)),
	find_char_$first_in_table	entry (char(*), char(512) aligned) returns (fixed bin(21)) reducible,
	get_ring_			entry returns (fixed bin(5)),
	hcs_$get_author		entry (char(*), char(*), fixed bin(1), char(*), fixed bin(35)),
	hcs_$get_max_length		entry (char(*), char(*), fixed bin(35), fixed bin(35)),
	hcs_$get_safety_sw		entry (char(*), char(*), bit(1), fixed bin(35)),
	hcs_$initiate		entry (char(*), char(*), char(*), fixed bin(1),
				       fixed bin(2), ptr, fixed bin(35)),
	hcs_$list_acl		entry (char(*), char(*), ptr, ptr, ptr, fixed bin, fixed bin(35)),
	hcs_$list_dir_acl		entry (char(*), char(*), ptr, ptr, ptr, fixed bin, fixed bin(35)),
	hcs_$list_inacl_all		entry (char(*), ptr, ptr, ptr, fixed bin(35)),
         (hcs_$dir_quota_read,
	hcs_$quota_read)		entry (char(*), fixed bin(35), fixed bin(71), bit(36), fixed bin(35),
				       fixed bin(1), fixed bin(35), fixed bin(35)),
	hcs_$star_		entry (char(*), char(*), fixed bin(2), ptr, fixed bin,
				       ptr, ptr, fixed bin(35)),
	hcs_$status_for_backup	entry (char(*), char(*), ptr, fixed bin(35)),
	hcs_$status_long		entry (char(*), char(*), fixed bin(1), ptr, ptr,
				       fixed bin(35)),
	hcs_$terminate_noname	entry (ptr, fixed bin(35)),
	lib_free_node_$array	entry (ptr),
	lib_free_node_$descriptors	entry (ptr),
	lib_ptr_and_bc_		entry (ptr, fixed bin, ptr, ptr, fixed bin(24), fixed bin(35)),
	match_star_name_		entry (char(*), char(*)) returns (fixed bin(35)),
	msf_manager_$acl_list	entry (ptr, ptr, ptr, ptr, fixed bin, fixed bin (35)),
	msf_manager_$close		entry (ptr),
	msf_manager_$open		entry (char(*), char(*), ptr, fixed bin(35)),
	object_info_$display	entry (ptr, fixed bin(24), ptr, fixed bin(35)),
	smart_alloc_$area_full	entry (fixed bin, ptr, bit(70) aligned);

     dcl						/*	static variables			*/
						/* length of an archive component header (in bits)*/
	Lnode_string		fixed bin int static init (0),
						/* length of a node (in bits).		*/
	Lrecord			fixed bin(35) int static init (0),
						/* length of a record (in bits).		*/
	NO_MATCH			fixed bin(2) unsigned int static options(constant) init(3),
         (Svalid_added_status, Svalid_archive, Svalid_archive_comp, Svalid_directory, Svalid_link, Svalid_msf, 
	Svalid_msf_comp, Svalid_object_info, Svalid_root init(""b), Svalid_segment)
				bit(72) aligned int static,
         (archive_data_$header_begin,
	archive_data_$header_end,
	archive_data_$ident)	char(8) aligned ext static,
         (error_table_$archive_fmt_err,
	error_table_$logical_volume_not_connected,
	error_table_$noalloc,
	error_table_$nomatch,
	error_table_$notalloc,
	error_table_$out_of_bounds,
	error_table_$process_stopped,
	error_table_$toomanylinks,
	error_table_$typename_not_found)
				fixed bin(35) ext static,
	find_char_$not_ascii_table	char(512) aligned external static,
	ring			fixed bin(5) int static init(8),
						/* current validation level.			*/
	sys_info$maxlinks		fixed bin(35) ext static,
	sys_info$page_size		fixed bin(35) ext static;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


	Acode = 0;
	if Svalid_root = ""b then call init_Svalid();
	if ring > 7 then ring = get_ring_();
	if Lnode_string = 0 then do;
	     Lnode_string = size(node) * 36;
	     Lrecord = sys_info$page_size * 36;
	     end;
	Schase_links = 0;
	Pparent = APparent;				/* copy input argument for use by internal subr.	*/
	Pnodes = null;				/* initialize output arguments.		*/
	PDnodes = null;				/* initialize node structure ptr.		*/
	Parch = null;				/* initialize temporary pointer so that cleanup	*/
						/* can see if segment must be terminated.	*/
	on cleanup call terminate_archive;		/* cleanup by terminating any archive.		*/

	type = Pparent -> node.T;			/* get parent's node type.			*/
	go to proc_node(type);			/* process each node, according to its type.	*/

proc_node(1):					/* don't process nodes whose parents are	*/
proc_node(4):					/*    segments, archive components, or msf	*/
proc_node(6):					/*    components any further.			*/
	return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


proc_node(0):
	error = fatal;				/* processing used when parent is a link.  Any 	*/
						/* error is fatal.				*/
	if link_level > sys_info$maxlinks then do;	/* too many consecutive links can get us into a	*/
	     code = error_table_$toomanylinks;		/* loop.  Use the system-defined limit for	*/
	     go to error;				/* consecutive links to prevent this.		*/
	     end;

	ent = "";					/* use path as entire path name of link.	*/
	call get_node_array (1);			/* get a node array containing only a single node.*/
	call init_node;				/* initialize this node.			*/
	Schase_links = binary (Sc.chase, 1);		/* interpret link chase switch here.		*/
	call status_long ((path), ent);		/* get status info about the item linked to.	*/
						/* store this information in the node.		*/
	stop_search = end_search;
	call director_caller;			/* let director have a chance to validate node.	*/
end_search:
	Pnodes = PDnodes;				/* return ptr to the node array descriptor.	*/
	return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


proc_node(2):					/* processing used when parent is a directory.	*/
	if starname.N > 1 then			/* process multiple starnames in outer ring.	*/
	     ent = "**";
	else					/* let ring 0 process single starname.		*/
	     ent = starname(1).V;
	go to call_star;

proc_node(3):					/* processing used when parent is an msf.	*/
	ent = "**";				/* return information about all msf components.	*/

call_star:
	call_id = "0"b;				/* initialize call id, so that it will be set the	*/
						/* first time smart_alloc_$area_full is called.	*/
call_again:
	call hcs_$star_ ((path), ent, star_ALL_ENTRIES, Parea,
	   star_entry_count, star_entry_ptr, star_names_ptr, code);
						/* get the name and type of each matching entry 	*/
						/* in the directory.			*/
	if code = error_table_$notalloc then do;	/* if the current SSA of the MSA is full, 	*/
	     call smart_alloc_$area_full (0, Parea, call_id);
	     go to call_again;			/* get another SSA in the MSA, and try again.	*/
	     end;
	else if code ^= 0 then			/* treat any other status code as a fatal error.	*/
	     go to fatal;

	count = star_entry_count;			/* find out how many entries match any starname.	*/
	go to star_test(type);			/* no checking needed for msfs.		*/

star_test(2):
	if starname.N > 1 then do;			/* compare entry names with starnames.  Flag	*/
	     do i = 1 to star_entry_count;		/*    entry type with "11"b for non-matches.	*/
		do j = star_entries(i).nindex  to  star_entries(i).nindex + star_entries(i).nnames - 1;
		     do k = 1 to starname.N;
			go to dir_test(starname(k).C);

dir_test(0):		if star_names(j) = starname(k).V then go to dir_match;
			go to dir_nomatch;

dir_test(1):		if match_star_name_(star_names(j), starname(k).V) = 0 then go to dir_match;

dir_nomatch:		end;
		     end;
		star_entries(i).type = NO_MATCH;	/* Flag entry as non-matching.		*/
		count = count - 1;			/* Exclude it from entry count.		*/
dir_test(2):
dir_match:	end;

	     if count = 0 then do;
		code = error_table_$nomatch;
		go to fatal;
		end;
	     end;

star_test(3):
	call get_node_array (count);			/* get a node array with 1 node for each matching	*/
						/* entry in the directory.			*/
	error = record_and_skip;			/* record any errors returned by status.	*/

	stop_search = star_test_stop;
	do i = star_entry_count to 1 by -1;		/* fill in nodes, one by one, most recently	*/
						/*   created first.				*/
	     if star_entries(i).type = NO_MATCH then go to next_entry;
						/* Ignore this entry.  It didn't match.		*/
						/* then discard the erring entry, and continue.	*/
	     call init_node;			/* initialize this node.			*/
	     call status_long ((path), star_names (star_entries(i).nindex));
						/* fill status of this entry into the node.	*/

	     call director_caller;			/* the director has his chance at the node now.	*/
	     go to next_entry;			/* if director OKed node, then fill in next one.	*/

record_and_skip:
	     if Dnodes.C ^= error_table_$logical_volume_not_connected then
		Dnodes.C = code;			/* remember what the last code was from status.	*/
	     call lib_free_node_$descriptors (Pnode);	/* free any node descriptors.			*/
	     Inode = Inode - 1;			/* reuse this node for the next entry.		*/

next_entry:    end;

star_test_stop:
	free star_names in (area_var),		/* free name list returned by star_.		*/
	     star_entries in (area_var);		/* free entry array returned by star_.		*/
	Dnodes.N = Inode;				/* store count of nodes we've filled into descr.	*/
	if Inode = 0 then do;			/* if no nodes were filled (because of bad status	*/
	     if Dnodes.C ^= 0 then code = Dnodes.C;
	     else code = error_table_$nomatch;		/* or director rejection), then tell parent node.	*/
	     go to fatal;
	     end;
	else Dnodes.C = 0;
	Pnodes = PDnodes;				/* return ptr to the node array descriptor.	*/
	return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


proc_node(5):					/* processing used when parent node is an archive	*/
	error = terminate_arch;			/* terminate the archive if an error occurs.	*/

	call lib_ptr_and_bc_ (Pparent, 0, null, Parch, bit_count, code);
	if code ^= 0 then go to error;		/* get ptr to, and bit count of, parent archive.	*/
	PDarch = addr (PBDarch);			/* make PBDarch point to the first archive	*/
						/* descriptor (Darch) we create.		*/
	PBDarch = null;				/* to start with, there are no descriptors.	*/
	Nentries = 0;

	call_id = "0"b;

get_components:
	on area go to arch_expand_area;

	call archive_$list_components (Parch, bit_count, ARCHIVE_COMPONENT_INFO_VERSION_1,
	     Parea, archive_component_info_ptr, n_components,
	     code);

	revert area;

	if code ^= 0 then do;
	     call terminate_archive;
	     go to fatal;
	     end;

	do j = 1 to n_components;
	     do k = 1 to starname.N;
		go to arch_test(starname(k).C);

arch_test(0):	if starname (k).V = archive_component_info_array (j).name then go to arch_match;
		go to arch_nomatch;

arch_test(1):	if match_star_name_ (archive_component_info_array (j).name, starname (k).V) = 0 then
		     go to arch_match;
		go to arch_nomatch;

arch_test(2):
arch_match:
		Nnames = 1;			/* create a name descriptor; use temporarily as	*/
		allocate Dnames in (area_var) set (Ptemp); /* archive component descriptor until we find out	*/
		Darch.Pnext = Ptemp;
		PDarch = Ptemp;			/* how many matching archive components exist.	*/
		Darch.Pnext = null ();
		Darch.Parch = archive_component_info_array (j).comp_ptr;
		Darch.name = archive_component_info_array (j).name;
		Darch.bit_count = archive_component_info_array (j).comp_bc;
		clock = archive_component_info_array (j).time_modified;
		Darch.dtm = substr (clock_string, 21, 36);
		clock = archive_component_info_array (j).time_updated;
		Darch.dtupdated = substr (clock_string, 21, 36);
		Darch.Smode = substr (archive_component_info_array (j).access, 1, 3);
		Nentries = Nentries + 1;
		if starname.N = 1 then
		     if starname (1).C = 0 then go to arch_test_done;
arch_nomatch:
		end;
	     end;

	     free archive_component_info_array in (area_var);

arch_test_done:					/* if a format error occurred, or if we scanned	*/
	if Nentries = 0 then do;			/* thru entire archive, or if no *'s in star name,*/
	     if code = error_table_$archive_fmt_err then;	/* then if no matching components were found,	*/
	     else					/* store an error code in patent node, terminate	*/
		code = error_table_$nomatch;		/* the archive, and return.			*/
terminate_arch:
	     call terminate_archive;
	     go to fatal;
	     end;

	stop_search = arch_test_stop;
	error = director_reject;			/* errors in this section are caused by the	*/
						/* director's rejection of a node.		*/
	call get_node_array (Nentries);		/* get node array with 1 node for each matching	*/
						/* component.				*/

	if Dnodes.C ^= error_table_$logical_volume_not_connected then
	     Dnodes.C = code;			/* save any archive format error.		*/
	PDarch = PBDarch;				/* starting at head of descriptor chain,	*/
	do i = 1 to Nentries;			/* scan thru component descriptors, filling	*/
						/* in a node for each matching component.	*/
	     call init_node;			/* initialize the node.			*/
	     node.bit_count = Darch.bit_count;		/* store bit count from descriptor.		*/
	     node.Smode = Darch.Smode;		/* store mode.				*/
	     node.dtm = Darch.dtm;			/* store dtm.				*/
	     node.dtem = Darch.dtupdated;		/* store dtem.				*/
	     PDnames = PDarch;			/* use archive descriptor as name descriptor.	*/
	     Parch = Darch.Parch;			/* but first, save ptr to archive component.	*/
	     PDarch  = Darch.Pnext;			/* Also, save ptr to next descriptor.		*/
	     Dnames.N = 1;				/* set number of names in descriptor to 1.	*/
	     Dnames.length = size (Dnames);		/* store length of descriptor.		*/
	     Dnames.version = Vnames_1;		/* and version number.			*/
	     Dnames.Pnext = node.PD;			/* chain descriptor to node.			*/
	     node.PD = PDnames;
	     Dnames.T = Tnames;			/* specify this is a name descriptor.		*/

	     node.current_length = divide (node.bit_count + Lrecord - 1, Lrecord, 35, 0);
						/* compute current length (in records) from	*/
						/* component's bit count.			*/
	     node.offset = binary (rel (Parch), 18);
						/* fill in component's offset from base of segment*/
						/* containing the archive.  This works		*/
						/* for archived archives, too.		*/

	     node.Svalid = Svalid_archive_comp;		/* indicate which basic node fields are valid.	*/
	     if Sc.check_ascii then do;		/* see if component contents is printable.	*/
		call test_ascii (Parch, node.bit_count, flags.ascii);
		Svalid.not_ascii = ^flags.ascii;
		end;
	     else do;
		flags.ascii = "0"b;
		end;
	     flags.archive = "0"b;			/* assume component is not an archived archive.	*/
	     if Sc.check_archive then
	          flags.archive = test_archive (node.bit_count);
	     if flags.archive then
		node.T = Tarchive;
	     else do;
		node.T = Tarchive_comp;
		if flags.ascii & Sc.check_ascii then;
		else if Sc.object_info then do;	/* see if component is an object component.	*/
		     flags.object_seg = object_seg_ (Parch, node.bit_count);
		     if flags.object_seg then
			node.Svalid = node.Svalid | Svalid_object_info;
		     end;
		end;
	     node.Sreq = node.Svalid & Srequirements;	/* say which fields are required for output.	*/
	     call director_caller;			/* let the director validate this node.		*/
	     go to end_component;			/* all done for this component.		*/

director_reject:					/* if director rejected this node, then		*/
	     call lib_free_node_$descriptors (Pnode);	/* free node's descriptors.			*/
	     Inode = Inode - 1;			/* reuse this node for next component.		*/
end_component: end;

arch_test_stop:
	Dnodes.N = Inode;				/* record number of filled nodes in node array.	*/
	call terminate_archive;			/* terminate the archive.			*/
	if Inode = 0 then do;			/* if no acceptable components were found,	*/
	     if code = error_table_$archive_fmt_err then;	/* set error code in a null node array descriptor.*/
	     else
		code = error_table_$nomatch;
	     go to fatal;
	     end;
	Pnodes = PDnodes;				/* return ptr to the node array descriptor.	*/
	return;

arch_expand_area:					/* let msa_manager_ expand the area		*/
	revert area;
	call smart_alloc_$area_full (0, Parea, call_id);
	go to get_components;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


fatal:						/* this is the global exit for errors which are	*/
						/* fatal to the process of getting a node array.	*/
	if PDnodes ^= null then do;			/* if a node array was allocated, free it.	*/
	     Dnodes.N = Inode;			/* store count of number of filled node in descr.	*/
	     call lib_free_node_$array (PDnodes);
	     end;
	call get_node_array (0);			/* get a node descriptor with zero nodes.	*/
	if Dnodes.C ^= error_table_$logical_volume_not_connected then
	     Dnodes.C = code;			/* fill in its error code.			*/
	Pnodes = PDnodes;				/* return this error code descriptor.		*/
	return;					/* You lose, buddy.  Too bad.			*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/*	A  D  D  I  T  I  O  N  A  L     E  N  T  R  Y     P  O  I  N  T  S		*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


root_array:	entry	(MNnodes, Parea, Pnodes, Acode);

	call get_node_array(MNnodes);			/* get a node array of specified length.	*/
	Dnodes.N = 0;				/* record current length of node array.		*/
	Pnodes = PDnodes;				/* return pointer to node array.		*/
	Acode = 0;
	return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


root_array_info:	entry	(Pnodes, MNnodes, Acode);

	PDnodes = Pnodes;				/* address the specified node array.		*/
	MNnodes = Dnodes.N;				/* return current dimension of array, and any	*/
	Acode = Dnodes.C;				/*    error code returned while getting array.	*/
	return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


lib_root_node:	entry	(Proot_names, root_type, path, root_search_proc, Pstarname, Pexclude, Srequirements,
			 Scontrol, Parea, director, Pdirector_args, Pnodes, MNnodes, Acode);

	e = 1;
	go to COMMON;


root_node:	entry	(Proot_names, root_type, path, Pstarname, Pexclude, Srequirements, Scontrol,
			 Parea, director, Pdirector_args, Pnodes, MNnodes, Acode);

	e = 2;

COMMON:	if Svalid_root = ""b then call init_Svalid();	/* initialize internal static variables.	*/
	Pparent = null;				/* a root node has no parent node.		*/
	PDnodes = Pnodes;				/* address the root node array.		*/
	if Dnodes.N = MNnodes then do;		/* make sure array isn't full.		*/
	     Acode = error_table_$out_of_bounds;
	     return;
	     end;
	if root_type ^= Tdirectory then if root_type ^= Tarchive then do;
	     Acode = error_table_$typename_not_found;
	     return;
	     end;

	Inode = Dnodes.N;				/* address the last filled node of array.	*/
	Dnodes.N = Dnodes.N + 1;			/* extend current length of array.		*/
	call init_node;				/* initialize new node.			*/
	link_node.T = root_type;			/* fill in root type.			*/
	link_node.Svalid = Svalid_root;		/*	      valid fields.			*/
	Nnames = root_names.N;			/*	      names.			*/
	if Nnames > 0 then do;
	     allocate Dnames in (area_var);
	     Dnames.length = size (Dnames);
	     Dnames.version = Vnames_1;
	     Dnames.Pnext = link_node.PD;
	     link_node.PD = PDnames;
	     Dnames.T = Tnames;
	     Dnames.names(*) = root_names.root_name(*);
	     end;
	else do;
	     Svalid.primary_name = "0"b;
	     Svalid.matching_names = "0"b;
	     Svalid.names = "0"b;
	     end;
	link_node.link_target = path;			/* 	      path.			*/
	if e = 1 then if length(root_search_proc) > 0 then do;
	     allocate Dsearch_proc in (area_var);
	     Dsearch_proc.length = size(Dsearch_proc);
	     Dsearch_proc.version = Vsearch_proc_1;
	     Dsearch_proc.Pnext = link_node.PD;
	     link_node.PD = PDsearch_proc;
	     Dsearch_proc.T = Tsearch_proc;
	     Dsearch_proc.search_proc = root_search_proc;
	     Svalid.root_search_proc = "1"b;
	     end;
	node.Sreq = node.Svalid & Srequirements;	/*              required fields.		*/

	Acode = 0;				/* no more errors from here on can affect code.	*/
	error = root_error;
	stop_search = root_stop;
	call director_caller;			/* search this root for entries matching starname.*/
root_stop:
	return;

root_error:
	if Dnodes.C ^= error_table_$logical_volume_not_connected then
	     Dnodes.C = code;			/* remember last root error code.		*/
	call lib_free_node_$descriptors (Pnode);
	Dnodes.N = Dnodes.N - 1;			/* remove node from array.			*/
	return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/*	     I  N  T  E  R  N  A  L          P  R  O  C  E  D  U  R  E  S		*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


cv_num:	proc (n) returns (char(32));			/* procedure to convert integer to char string.	*/

     dcl	n			fixed bin,	/* number to be converted. (In)		*/
	char32			char(32),		/* the result.				*/
	i			fixed bin,
	pic			pic "zzzzzzzzzzzz9";

	pic = n;
	i = verify (pic, " ");
	char32 = substr(pic,i);
	return (char32);

	end cv_num;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
/*  *  * 
 *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


director_caller:	procedure;			/* This internal procedure is called in order to	*/
						/* have the director validate each node after it	*/
						/* has been filled, but before the next node	*/
						/* in the array is filled.  If the director	*/
						/* rejects the node, then this procedure	*/
						/* branches to the caller's error handler.	*/

	code = 0;					/* initialize search director's return code 	*/
	PD = null;				/* and output node ptr.			*/
	if node.Pparent = null then			/* for a root node, pass the root path, tree level*/
						/* 1, link level 0.				*/
	     call director (Pnode, link_node.link_target, Pstarname, Pexclude, Srequirements, Scontrol, 1, 0, 
			Parea, director, Pdirector_args, PD, code);
	else if node.T = Tlink then			/* for the first link in a chain, pass the link 	*/
	     if link_level = 0 then			/* path and increment both tree and link level.	*/
		call director (Pnode, link_node.link_target, Pstarname, Pexclude, Srequirements, Scontrol,
			     tree_level+1, link_level+1, Parea, director, Pdirector_args, PD, code);
	     else					/* for succeeding links in a chain, pass the link	*/
						/* path and increment just the link level.	*/
		call director (Pnode, link_node.link_target, Pstarname, Pexclude, Srequirements, Scontrol,
			     tree_level, link_level+1, Parea, director, Pdirector_args, PD, code);
	else if link_level > 0 then			/* for the target of a link, pass on the target	*/
						/* path, zero the link level, and pass on the	*/
						/* current tree level.			*/
	     call director (Pnode, path, Pstarname, Pexclude, Srequirements, Scontrol,
			tree_level, 0, Parea, director, Pdirector_args, PD, code);
	else do;					/* otherwise, compute path by adding node's 1st	*/
						/* name to path we rec'd as input, increment	*/
						/* the tree level, and zero the link level.	*/
	     j = min(32, 33-verify(reverse(Dnames.names(1)), " "));
	     if path = ">" then
		call director (Pnode, path || substr (Dnames.names(1), 1, j), Pstarname, Pexclude,
			     Srequirements, Scontrol, tree_level+1, 0, Parea, director, Pdirector_args, PD, code);
	     else call director (Pnode, path || ">" || substr (Dnames.names(1), 1, j), Pstarname, Pexclude,
			     Srequirements, Scontrol, tree_level+1, 0, Parea, director, Pdirector_args, PD, code);
	     end;

	if PD ^= null then do;			/* if the director created a node descriptor,	*/
	     D.Pnext = node.PD;			/* attach it to the node.			*/
	     node.PD = PD;
	     Svalid.kids = "1"b;
	     if PD -> Dnodes.C ^= 0 then do;		/* validate the error code, if there was one.	*/
		Svalid.kids_error = "1"b;
		Sreq.kids_error = S.kids_error;
		Sreq.primary_name = Sreq.primary_name | S.kids_error;
		end;
	     end;
	if code = error_table_$process_stopped then
	     go to stop_search;
	else if code ^= 0 then			/* if the director rejected the node for any	*/
	     go to error;				/* reason, then go to the caller's error handler.	*/

	end director_caller;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


get_acl:		procedure (dir, ent);		/* Internal procedure called to get ACL for a	*/
						/* segment, and store it in a segment ACL	*/
						/* descriptor.				*/
     dcl	dir			char(*),		/* dir part of segment's path name. (In)	*/
	ent			char(*);		/* ent part of segment's path name. (In)	*/

	call_id = "0"b;				/* initialize id used for smart_alloc_.		*/
acl_again:
	call hcs_$list_acl (dir, ent, Parea, Pacl, null, Nacls, code);
	if code = error_table_$noalloc then do;		/* if our SSA of MSA was full, get another one.	*/
	     call smart_alloc_$area_full (0, Parea, call_id);
	     go to acl_again;
	     end;
	else if code ^= 0 then Nacls = 0;		/* fake it if there is no ACL.		*/
						/* if no trouble getting ACL, get access class.	*/
	allocate Dacl in (area_var);
	Dacl.length = size(Dacl);
	Dacl.version = Vacl_1;
	Dacl.Pnext = node.PD;			/* chain ACL descriptor to the node.		*/
	node.PD = PDacl;
	Dacl.T = Tacl;
	Dacl.C = code;
	Dacl.N = Nacls;
	if Dacl.N > 0 then Dacl.acls = acl;		/* copy ACL into descriptor.			*/

	end get_acl;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

get_dir_acl:	procedure (dir, ent);		/* Internal procedure to get ACL for a directory	*/
						/* and store it in a directory ACL descriptor.	*/
     dcl	dir			char(*),		/* dir part of directory's path name. (In)	*/
	ent			char(*);		/* ent part of directory's path name. (In)	*/

	call_id = "0"b;				/* initialize id used for smart_alloc_.		*/
dir_acl_again:
	call hcs_$list_dir_acl (dir, ent, Parea, Pdir_acl, null, Ndir_acls, code);
	if code = error_table_$noalloc then do;		/* if our SSA of MSA was full, get another one.	*/
	     call smart_alloc_$area_full (0, Parea, call_id);
	     go to dir_acl_again;
	     end;
	else if code ^= 0 then Ndir_acls = 0;		/* fake it if there is no ACL.		*/
						/* if no trouble getting ACL, get access class.	*/
	allocate Ddir_acl in (area_var);
	Ddir_acl.length = size(Ddir_acl);
	Ddir_acl.version = Vdir_acl_1;
	Ddir_acl.Pnext = node.PD;			/* chain descriptor onto node.		*/
	node.PD = PDdir_acl;
	Ddir_acl.T = Tdir_acl;
	Ddir_acl.C = code;
	Ddir_acl.N = Ndir_acls;
	if Ddir_acl.N > 0 then Ddir_acl.acls = dir_acl;	/* copy ACL into descriptor.			*/

	end get_dir_acl;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


get_iacls:	procedure (dir, ent);		/* Internal procedure to get all IACLs for a	*/
						/* directory and store them in an IACL descriptor.*/
     dcl	dir			char(*),		/* dir part of directory's path name. (In)	*/
	ent			char(*),		/* ent part of directory's path name. (In)	*/
	i			fixed bin,	/* a do-group index.			*/
	path			char(168);	/* directory's path name.			*/

	path = dir || ">" || ent;
	call_id = "0"b;				/* initialize id used for smart_alloc_.		*/
iacl_again:
	call hcs_$list_inacl_all (path, Parea, Piacl, addr(iacl_info), code);
	if code = error_table_$noalloc then do;		/* if our SSA of MSA was full, get another one.	*/
	     call smart_alloc_$area_full (0, Parea, call_id);
	     go to iacl_again;
	     end;
	else if code ^= 0 then			/* fake it if a fatal error occurred.		*/
	     do i = 0 to 7;
		iacl_info.seg.counts(i) = 0;
		iacl_info.dir.counts(i) = 0;
		end;
	Niacls, Ndir_iacls = 0;
	do i = 0 to 7;				/* add up counts of IACL entries.		*/
	     Niacls = Niacls + iacl_info.seg.counts(i);
	     Ndir_iacls = Ndir_iacls + iacl_info.dir.counts(i);
	     end;

	allocate Diacl in (area_var);			/* fill in the segment IACL descriptor.		*/
	Diacl.length = size(Diacl);
	Diacl.version = Viacl_1;
	Diacl.Pnext = node.PD;			/* chain descriptor onto node.		*/
	node.PD = PDiacl;
	Diacl.T = Tiacl;
	Diacl.C = code;
	Diacl.N = Niacls;
	Diacl.N = 1;				/* copy IACLs into descriptor.		*/
	do i = 0 to 7;
	     Diacl.Iring(i) = Diacl.N;
	     Diacl.Nring(i) = iacl_info.seg.counts(i);
	     if iacl_info.seg.counts(i) > 0 then do;
		Pacl = addrel(Piacl, iacl_info.seg.offsets(i));
		Nacls = iacl_info.seg.counts(i);
		addr(Diacl.acls(Diacl.N)) -> acl = acl;
		Diacl.N = Diacl.N + Nacls;
		end;
	     end;
	Diacl.N = Diacl.N - 1;
	allocate Ddir_iacl in (area_var);			/* fill in the directory IACL descriptor.	*/
	Ddir_iacl.length = size(Ddir_iacl);
	Ddir_iacl.version = Vdir_iacl_1;
	Ddir_iacl.Pnext = node.PD;			/* chain descriptor onto node.		*/
	node.PD = PDdir_iacl;
	Ddir_iacl.T = Tdir_iacl;
	Ddir_iacl.C = code;
	Ddir_iacl.N = Ndir_iacls;
	Ddir_iacl.N = 1;				/* copy IACLs into descriptor.		*/
	do i = 0 to 7;
	     Ddir_iacl.Iring(i) = Ddir_iacl.N;
	     Ddir_iacl.Nring(i) = iacl_info.dir.counts(i);
	     if iacl_info.dir.counts(i) > 0 then do;
		Pdir_acl = addrel(Piacl, iacl_info.dir.offsets(i));
		Ndir_acls = iacl_info.dir.counts(i);
		addr(Ddir_iacl.acls(Ddir_iacl.N)) -> dir_acl = dir_acl;
		Ddir_iacl.N = Ddir_iacl.N + Ndir_acls;
		end;
	     end;
	Ddir_iacl.N = Ddir_iacl.N - 1;

	end get_iacls;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


get_msf_acl:	procedure (dir, ent);		/* Internal procedure to get ACL for an MSF,	*/
						/* and store it in a segment ACL descriptor.	*/
     dcl	dir			char(*),		/* dir part of MSF's path name. (In)		*/
	ent			char(*);		/* ent part of MSF's path name. (In)		*/

	call msf_manager_$open (dir, ent, Ptemp, code);	/* open the MSF.				*/
	if code = 0 then do;
	     call_id = "0"b;			/* initialize id used for smart_alloc_.		*/
msf_acl_again: call msf_manager_$acl_list (Ptemp, Parea, Pacl, null, Nacls, code);
	     if code = error_table_$noalloc then do;	/* if our SSA of MSA is full, get another one.	*/
		call smart_alloc_$area_full (0, Parea, call_id);
		go to msf_acl_again;
		end;
	     end;
	if code ^= 0 then Nacls = 0;			/* fake it if there is no ACL.		*/
						/* if no trouble getting ACL, get access class.	*/
	allocate Dacl in (area_var);
	Dacl.length = size(Dacl);
	Dacl.version = Vacl_1;
	Dacl.Pnext = node.PD;			/* chain descriptor onto the node.		*/
	node.PD = PDacl;
	Dacl.T = Tacl;
	Dacl.C = code;
	Dacl.N = Nacls;
	if Dacl.N > 0 then Dacl.acls = acl;		/* copy ACL into descriptor.			*/
	call msf_manager_$close (Ptemp);		/* close the MSF.				*/

	end get_msf_acl;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


get_node_array:	procedure (N);			/* This internal procedure allocates a node array	*/
						/* and initializes its header.		*/

     dcl	N			fixed bin;	/* Number of nodes to be allocated in the array.	*/

	Nnodes = N;				/* set variable which controls number of nodes	*/
						/* which get allocated in our adjustable based	*/
						/* array.					*/
	allocate Dnodes in (area_var);		/* allocate the node array descriptor.		*/
	Dnodes.length = size (Dnodes);		/* fill in its size,			*/
	Dnodes.version = Vnodes_1;			/*	     version,			*/
	Dnodes.Pnext = null;			/*	     next descriptor ptr, and		*/
	Dnodes.header.T = Tnodes;			/*	     type.			*/
	Dnodes.C = 0;				/* clear its error code.			*/

	Inode = 0;				/* initialize number of filled nodes to zero.	*/

	end get_node_array;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


init_Svalid:	procedure;			/* Internal procedure which initializes the 	*/
						/* internal static constants defining which of	*/
						/* the basic node fields are valid for each type	*/
     dcl	Srequirements		bit(72) aligned,	/* of node.				*/
	1 S			like Svalid_req based (addr(Srequirements));

	string(S) = ""b;
	S.primary_name = "1"b;
	S.matching_names = "1"b;
	S.names = "1"b;
	S.type = "1"b;
	S.pathname = "1"b;
	S.dtem = "1"b;
	S.dtd = "1"b;
	S.link_target = "1"b;
	S.new_line = "1"b;
	S.level = "1"b;
	S.cross_ref = "1"b;
	Svalid_link = Srequirements;

	string(S) = ""b;
 	S.primary_name = "1"b;
	S.matching_names = "1"b;
	S.names = "1"b;
	S.type = "1"b;
	S.pathname = "1"b;
	S.dtm = "1"b;
	S.dtu = "1"b;
	S.dtem = "1"b;
	S.dtd = "1"b;
	S.current_length = "1"b;
	S.records_used = "1"b;
	S.bit_count = "1"b;
	S.max_length = "1"b;
	S.lvid = "1"b;
	S.mode = "1"b;
	S.rb = "1"b;
	S.copy = "1"b;
	S.safety = "1"b;
	S.unique_id = "1"b;
	S.new_line = "1"b;
	S.level = "1"b;
	S.cross_ref = "1"b;
	Svalid_segment = Srequirements;
	Svalid_msf_comp = Srequirements;
	Svalid_archive = Srequirements;
	S.max_length = "0"b;
	S.copy = "0"b;
	S.msf_indicator = "1"b;
	Svalid_msf = Srequirements;
	S.bit_count = "0"b;
	S.msf_indicator = "0"b;
	Svalid_directory = Srequirements;

	string(S) = ""b;
	S.dtc = "1"b;
	S.compiler_name = "1"b;
	S.compiler_version = "1"b;
	S.compiler_options = "1"b;
	S.object_info = "1"b;
	Svalid_object_info = Srequirements;

	string(S) = ""b;
	S.primary_name = "1"b;
	S.matching_names = "1"b;
	S.names = "1"b;
	S.type = "1"b;
	S.pathname = "1"b;
	S.dtm = "1"b;
	S.dtem = "1"b;
	S.current_length = "1"b;
	S.bit_count = "1"b;
	S.offset = "1"b;
	S.mode = "1"b;
	S.new_line = "1"b;
	S.level = "1"b;
	S.cross_ref = "1"b;
	Svalid_archive_comp = Srequirements;

	string(S) = ""b;
	S.primary_name = "1"b;
	S.matching_names = "1"b;
	S.names = "1"b;
	S.type = "1"b;
	S.pathname = "1"b;
	S.new_line = "1"b;
	S.level = "1"b;
	S.cross_ref = "1"b;
	Svalid_root = Srequirements;

	string(S) = ""b;
	S.access_class = "1"b;
	S.aim = "1"b;
	S.author = "1"b;
	S.bit_count_author = "1"b;
	S.entry_bound = "1"b;
	S.pvid = "1"b;
	Svalid_added_status = Srequirements;

	end init_Svalid;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


init_node:	procedure;			/* This internal procedure initializes a node.	*/

	Inode = Inode + 1;				/* increment the filled node count to get the next*/
						/* available node.				*/
	Pnode = addr (Dnodes.nodes (Inode));		/* access the node.				*/
	node_string = ""b;				/* zero out storage occupied by node.		*/
	node.Pparent = Pparent;
	node.PD = null;				/* initialize the node's pointers.		*/

	end init_node;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


object_seg_:	procedure (Pseg, bit_count)		/* This internal procedure checks to see if a	*/
		returns	(bit(1) aligned);		/* segment is an object segment and, if so, it	*/
						/* appends an object_info_ descriptor to the node	*/
						/* which represents the segment.		*/

     dcl	Pseg			ptr,		/* ptr to the segment.			*/
	bit_count			fixed bin(35);	/* bit count of the segment.			*/
						/* overlay for object segment strings.		*/

	oi.version_number = object_info_version_2;	/* initialize the object_info_ structure.	*/
	call object_info_$display (Pseg, binary(bit_count, 24), addr(oi), code);
	if code ^= 0 then				/* let object_info_ decide if this is an obj seg.	*/
	     return ("0"b);
	allocate Dobj in (area_var);			/* create an object_info_ descriptor.		*/
	Dobj.version = Vobj_1;			/* initialize its header.			*/
	Dobj.length = size (Dobj);
	Dobj.T = Tobj;
	Dobj.Pnext = node.PD;
	node.PD = PDobj;


	Dobj.info.Otext = binary (rel (oi.textp), 18);	/* fill in the structure, converting pointers	*/
	Dobj.info.Odefinitions = binary (rel (oi.defp),18);/* to offsets.				*/
	Dobj.info.Olink = binary (rel (oi.linkp), 18);
	Dobj.info.Ostatic = binary (rel (oi.statp), 18);
	Dobj.info.Osymbols = binary (rel (oi.symbp), 18);
	Dobj.info.Obreaks = binary (rel (oi.bmapp), 18);
	Dobj.info.Ltext = oi.tlng;
	Dobj.info.Ldefinitions = oi.dlng;
	Dobj.info.Llink = oi.llng;
	Dobj.info.Lstatic = oi.ilng;
	Dobj.info.Lsymbols = oi.slng;
	Dobj.info.Lbreaks = oi.blng;
	string (Dobj.info.format) = string (oi.format);
	Dobj.info.entry_bound = oi.entry_bound;
	Dobj.info.Otext_links = binary (rel (oi.textlinkp), 18);
	Dobj.info.compiler = oi.compiler;
	Dobj.info.compile_time = oi.compile_time;
	Dobj.info.userid = oi.userid;
	Dobj.info.cversion.O = Dobj.info.Osymbols +  binary (oi.cvers.offset, 18);
	Dobj.info.cversion.L = binary (oi.cvers.length, 18);
	Dobj.info.comment.O = Dobj.info.Osymbols + binary (oi.comment.offset, 18);
	Dobj.info.comment.L = binary (oi.comment.length, 18);
	Dobj.info.Osource = Dobj.info.Osymbols + oi.source_map;
	Pstring_ = pointer (Pseg, Dobj.info.cversion.O);
	Lstring_ = Dobj.info.cversion.L;
	Dobj.cversion = string_;
	Pstring_ = pointer (Pseg, Dobj.info.comment.O);
	Lstring_ = Dobj.info.comment.L;
	Dobj.comment = string_;

	return ("1"b);

	end object_seg_;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

status_long:	procedure (dir, ent);		/* This procedure calls hcs_$status_long to get	*/
						/* status information for dir>ent, and fills this	*/
						/* information in the node.			*/

     dcl	dir			char(*),		/* dir part of path of entry to get status of.(In)*/
	ent			char(*);		/* ent path of path of entry to get status of.(In)*/

     dcl	i			fixed bin;	/* do-group index.				*/

	call_id = "0"b;				/* initialize call id so that it will be set on	*/
						/* our first call to smart_alloc_$area_full.	*/
	status_ptr = addr (auto_status_branch);
call_again:
	status_area_ptr = Parea;
	call hcs_$status_long (dir, ent, Schase_links, addr (status_branch),
	   Parea, code);
	if code = error_table_$noalloc then do;		/* if our SSA of MSA was full, get another SSA by	*/
						/* calling smart_alloc_$area_full.		*/
	     call smart_alloc_$area_full (0, Parea, call_id);
	     go to call_again;			/* try getting status info again.		*/
	     end;
	else if code ^= 0 then			/* return to caller's error handler for any other	*/
	     go to error;				/* error.					*/

	Nnames = status_branch.nnames;		/* compute number of names.			*/
	allocate Dnames in (area_var);		/* store them in a name descriptor, attached to	*/
	Dnames.length = size (Dnames);		/* the node.				*/
	Dnames.version = Vnames_1;
	Dnames.T = Tnames;
	addr(Dnames.names)->status_entry_names = status_entry_names;
	free status_entry_names in (area_var);		/* copy names into the descriptor.		*/

	go to type (status_branch.type);		/* do rest of processing according to type of 	*/
						/* entry we got the status of.		*/

type(0):	link_node.T = Tlink;			/* this is a link!				*/
	link_node.link_target = status_pathname;
	free status_pathname in (area_var);		/* free the link path name status returned.	*/
	link_node.dtem = status_link.dtem;		/* fill in the dates.			*/
	link_node.dtd = status_link.dtd;
	link_node.Svalid = Svalid_link;		/* record which attributes of link_node are valid.*/
	if Sc.all_status then do;
	     call hcs_$get_author (dir, ent, 0, author, 0);
	     link_node.author = rtrim(author);
	     Svalid.author = "1"b;
	     end;
	link_node.Sreq = link_node.Svalid & Srequirements;/* record which are required for output.	*/
	Dnames.Pnext = node.PD;			/* make name descriptor first in the chain of	*/
	node.PD = PDnames;				/*   descriptors off node.  It's referenced most.	*/
	return;					/* not much processing for a link node.		*/

type(1):						/* this is a segment!			*/
	node.Smode = substr (status_branch.mode, 2, 3);	/* map "xrewx" into "rew".			*/
	node.rb = status_branch.ring_brackets;		/* copy ring brackets into node.		*/
	node.records_used = status_branch.records_used;
	node.current_length = status_branch.current_length;
						/* copy the current length.			*/
	node.bit_count = status_branch.bit_count;	/* copy the bit count.			*/
	call hcs_$get_max_length (dir, ent, node.max_length, code);

	call test_segment (dir, ent, flags);		/* find out about segment.			*/
	if Pparent -> node.T = Tmsf then do;		/* is it an msf component?			*/
	     node.T = Tmsf_comp;			/* yes.					*/
	     node.Svalid = Svalid_msf_comp;
	     if flags.archive then			/* MSF component is also an archive. Hum!	*/
		go to process_archive;
	     else 				/* process flags further, and set requirements	*/
		go to process_segment;		/* switches in node.			*/
	     end;
	else if flags.archive then do;		/* is it an archive?			*/
	     node.Svalid = Svalid_archive;
process_archive:
	     node.T = Tarchive;
	     Svalid.not_ascii = ^flags.ascii;
	     end;
	else do;	 				/* otherwise, it's just a plain segment.	*/
	     node.T = Tsegment;
	     node.Svalid = Svalid_segment;
process_segment:
	     if flags.object_seg then			/* if an object segment, say so.		*/
		node.Svalid = node.Svalid | Svalid_object_info;
	     Svalid.not_ascii = ^flags.ascii;		/* say whether segment is printable or not.	*/
	     end;
	if Sc.acl & (node.T ^= Tmsf_comp) then do;	/* get ACL for segment or archive.		*/
	     call get_acl (dir, ent);			/*   This call automatically chains ACL to node.	*/
	     Svalid.acl = "1"b;
	     end;
	go to fill_node;				/* fill remainder of node from status block.	*/

type(2):						/* this is a directory!			*/
	node.records_used = status_branch.records_used;
	node.current_length = status_branch.current_length;
	if status_branch.bit_count = 0 then do;		/* is it a directory?			*/
	     node.T = Tdirectory;			/*  yes, it is.				*/
	     node.Svalid = Svalid_directory;
	     substr (node.Smode, 1, 1) = substr (status_branch.mode, 2, 1);
	     substr (node.Smode, 2, 2) = substr (status_branch.mode, 4, 2);
						/* map "xsxma" into "sma".			*/
	     node.rb = status_branch.ring_brackets;
	     if Sc.acl then do;			/* get acl of directory.			*/
		call get_dir_acl (dir, ent);		/*   This call automatically chains ACL to node.	*/
		Svalid.acl = "1"b;
		end;
	     if Sc.iacl then do;			/* get initial ACLs associated with directory.	*/
		call get_iacls (dir, ent);		/*   This call automatically chains IACLs to node.*/
		Svalid.iacl = "1"b;
		end;
	     end;
	else do;					/* is it an MSF?				*/
	     node.T = Tmsf;				/* yes, it is.				*/
	     node.Svalid = Svalid_msf;
	     substr (node.Smode, 1, 1) = substr (status_branch.mode, 2, 1);
	     substr (node.Smode, 2, 1) = "0"b;		/* map "xsxmx" dir mode into "rxw" seg mode.	*/
	     substr (node.Smode, 3, 1) = substr (status_branch.mode, 4, 1);
	     node.rb(1) = status_branch.ring_brackets(1);
	     node.rb(2) = status_branch.ring_brackets(2);
	     node.rb(3) = status_branch.ring_brackets(2); /* map dir rb's into seg rb's.		*/
	     node.msf_indicator = status_branch.bit_count;
	     if dir = ">" then
		msf_dir = dir || ent;
	     else msf_dir = dir || ">" || ent;
	     do i = 0  to  node.msf_indicator - 1;	/* get aggregate records_used, current_length,	*/
		char32 = cv_num(i);			/*  and bit_count for MSF dir and components.	*/
		call hcs_$status_long (msf_dir, char32, 1, addr(msf_comp), null, code);
		if code = 0 then do;
		     node.records_used = node.records_used + msf_comp.records_used;
		     node.current_length = node.current_length + msf_comp.current_length;
		     node.bit_count = node.bit_count + msf_comp.bit_count;
		     end;
		end;
	     if Sc.acl then do;			/* get acl of MSF.				*/
		call get_msf_acl (dir, ent);		/*   This call automatically chains ACL to node.	*/
		Svalid.acl = "1"b;
		end;
	     end;
	if Sc.quota then do;			/* get quota information for MSFs and directories.*/
	     call hcs_$quota_read (dir||">"||ent, node.segment.quota, node.segment.trp,
		node.segment.dttrp, node.segment.Ninf_quota,
		Nterminal_account, node.segment.quota_used, code);
	     if code ^= 0 then go to error;
	     if Nterminal_account > 0 then node.Sterminal_account = "1"b;
	     call hcs_$dir_quota_read (dir||">"||ent, node.directory.quota, node.directory.trp,
		node.directory.dttrp, node.directory.Ninf_quota,
		Nterminal_account, node.directory.quota_used, code);
	     if code ^= 0 then go to error;
	     if Nterminal_account > 0 then node.Sterminal_account_dir = "1"b;
	     Svalid.quota = "1"b;
	     end;

fill_node:					/* fill in node values from entry status.	*/
	node.Scopy = status_branch.copy_switch;
	node.Stpd = status_branch.tpd_switch;		/* NEED TO ADD SUPPORT FOR OTHER SWITCHES.	*/
	call hcs_$get_safety_sw (dir, ent, node.Ssafety, code);
	node.unique_id = status_branch.uid;
	node.lvid = status_branch.lvid;
	node.dtem = status_branch.dtem;
	node.dtd = status_branch.dtd;
	node.dtm = status_branch.dtcm;
	node.dtu = status_branch.dtu;
	if Sc.all_status then do;			/* get additional information about branches.	*/
	     sfb.version = status_for_backup_version_2;
	     call hcs_$status_for_backup (dir, ent, addr(sfb), code);
	     if code ^= 0 then go to error;
	     node.Smaster_dir = sfb.master_dir;
	     node.Saim_security_oos = sfb.security_oosw;
	     node.Saim_audit = sfb.audit_flag;
	     node.Saim_multiple_class = sfb.multiple_class;
	     i = min (32, 33-verify(reverse(sfb.author)," "));
	     node.author = substr(sfb.author,1,i);
	     node.access_class = sfb.access_class;
	     i = min (32, 33-verify(reverse(sfb.bc_author), " "));
	     node.bit_count_author = substr(sfb.bc_author,1,i);
	     node.entry_bound = binary (sfb.entrypt_bound,14);
	     node.pvid = sfb.pvid;
	     node.Svalid = node.Svalid | Svalid_added_status;
	     if ^sfb.entrypt then do;
		node.entry_bound = 0;
		Svalid.entry_bound = "0"b;
		end;
	     end;
	Dnames.Pnext = node.PD;			/* make name descriptor first in the chain of	*/
	node.PD = PDnames;				/*   descriptors off node.  It's referenced most.	*/
	node.Sreq = node.Svalid & Srequirements;

	end status_long;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


terminate_archive:	procedure;			/* This internal procedure terminates an archive	*/
						/* if one has been initiated.			*/
     dcl	code			fixed bin(35);	/* a dummy status code.			*/

	if Parch ^= null then do;
	     call hcs_$terminate_noname (Parch, code);
	     Parch = null;
	     end;

	end terminate_archive;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


test_archive:	procedure (bit_count)		/* This internal procedure determines if a segment*/
		returns (bit(1) aligned);		/* is an archive.				*/
     dcl	bit_count			fixed bin(35);

	if bit_count >= 900 then
	     if arch.header_begin = archive_data_$header_begin then
		if arch.header_end = archive_data_$header_end then
		     return ("1"b);
		else;
	    else if arch.header_begin = archive_data_$ident then
		return ("1"b);
	return ("0"b);

	end test_archive;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


test_ascii:	procedure (Pseg, bit_count, Sascii);	/* This internal procedure checks the contents of	*/
						/* a segment to see if it is completely ascii	*/
     dcl	Pseg			ptr,		/* ptr to base of segment.(In)		*/
	bit_count			fixed bin(35),	/* segment's bit count.(In)			*/
	Sascii			bit(1) aligned;	/* on, if ascii segment. (Out)		*/
     dcl	Inon_ascii		fixed bin(21);	/* index of first non-ascii character of segment.	*/

	if bit_count = 0 then go to not_ascii;
	if mod (bit_count, 9) ^= 0 then do;		/* segment can't contain chars if bit count bad.	*/
not_ascii:     Sascii = "0"b;
	     return;
	     end;
	Pstring_ = Pseg;				/* overlay segment with character string.	*/
	Lstring_ = divide (bit_count, 9, 24, 0);	/* compute character length of segment.		*/
	Inon_ascii = find_char_$first_in_table (string_, find_char_$not_ascii_table);
						/* search for a non-ascii character in the string.*/
	if Inon_ascii = 0 then			/* if none found, its an ascii segment.		*/
	     Sascii = "1"b;
	else Sascii = "0"b;

	end test_ascii;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


test_segment:	procedure (dir, ent, flags);		/* This internal procedure examines a segment to	*/
						/* determine if it is an archive or an object 	*/
						/* segment.				*/
     dcl (dir, ent)			char(*),		/* dir/ent of segment to be tested.		*/
	1 flags			aligned,
	  2 archive		bit(1),		/* segment is an archive.			*/
	  2 object_seg		bit(1),		/* segment is an object segment.		*/
	  2 ascii			bit(1);		/* segment is composed only of ascii characters.	*/

	flags.archive = "0"b;			/* initialize output flags.			*/
	flags.object_seg = "0"b;
	flags.ascii = "1"b;				/* assume segment is ascii until check made.	*/
	if node.rb(2) < ring then;			/* if segment is readable from our ring,	*/
	else if ^substr(node.Smode,1,1) then;
	else if node.bit_count <= 0 then; 		/* and it has a non-zero bit count, 		*/
	else if divide(node.bit_count + Lrecord - 1, Lrecord, 35, 0) > node.current_length then;
	else if (Sc.check_archive & node.bit_count >= 900) | Sc.check_ascii | Sc.object_info then do;
						/* if caller requests archive/ascii/object info,	*/
	     call hcs_$initiate (dir, ent, "", 0, 0, Parch, code);
	     if Parch = null then return;		/* initiate the segment.			*/
	     if Sc.check_ascii then			/* check for ascii segments.			*/
		call test_ascii (Parch, node.bit_count, flags.ascii);
	     if Sc.check_archive then			/* check for archives.			*/
		flags.archive = test_archive (node.bit_count);
	     if flags.archive then;
	     else if flags.ascii & Sc.check_ascii then;
	     else if Sc.object_info then		/* check for object segment.			*/
		flags.object_seg = object_seg_ (Parch, node.bit_count);
	     call terminate_archive;			/* terminate the segment.			*/
	     end;

	end test_segment;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


%include lib_node_;

%include archive_component_info;

     dcl	1 archive_component_info_array (n_components)
				aligned like archive_component_info based (archive_component_info_ptr);

%include object_info;

     dcl	1 oi			aligned like object_info;

%include star_structures;

%include status_structures;

     dcl	1 auto_status_branch	aligned like status_branch,
	1 msf_comp		aligned like status_branch;

	end lib_get_tree_;
