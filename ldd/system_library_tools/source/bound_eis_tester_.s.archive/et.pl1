/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   * Copyright (c) 1972 by Massachusetts Institute of        *
   * Technology and Honeywell Information Systems, Inc.      *
   *                                                         *
   *********************************************************** */


eis_tester: et: procedure;


/*	This procedure is the main procedure in the  eis  instruction tester.
   *	It calls  "et_test"  to parse the statements in the user provided data
   *	file.  It translates these statements into the data needed to build and
   *	test an eis instruction in the external segment  etx.     After building
   *	the instruction this procedure will call  etx  in order to execute the  eis
   *	instructuion.  When  etx returns the results of the eis instruction will be
   *	examined.   "et"  will continue to build  and test  eis instructions until
   *	there is no data left in the input file.
   *
   *	Each instruction may be tested several times.  Also, the user may specify
   *	that variations of the same instruction be tested.  Each variation may be
   *	tested several times.
   *
   *	Note, the failure of one instruction will only cause the termination of that
   *	one instruction test.  Any remaining instructions specified in the input
   *	file will be processed and tested.
   *
   *	Created  Oct, 72  by  Bill Silver.
   *	Modified Aug, 80 by R. L. Coppola to add the -to control arg, and
   *	display_mc_ procedure, also increased declaration of several fixed bin
   *	variables to fixed bin (35) to enable processing of the new ets scripts.
   *      Modified March 1981 by Rich Coppola for DPS8 history reg support.
   *	Modified March 31, 1983 by GA Texada to make the argument processing more Multicious.
   *
   *
   *	ET  has two entries.  Both are called with one command option - a path name.
   *
   *	1.  et        aaaa		The path name  "aaaa"  refers to a segment which
   *				contains input script data which defines the
   *				instruction to test.  This is the main entry.
   *
   *	2.  et$gen    aaaa		The path name  "aaaa"  refers to a procedure which
   *				will generate the  ET data needed to test ONE
   *				instruction.
   *
   *	In addition each entry may be called with two optional arguments.
   *
   *	     a)  "-bf"	Specifies that BRIEF mode will be entered.  All but identification
   *			and error messages will be suppressed.
   *
   *	     b)  "-nox"	Specifies  NO eXecute mode.  This implies that the instruction
   *			will be set up but not executed.  It is used to test the validity
   *			of the input script.
   *
   *	     c)  "-debug"	Specifies that this test is to be run in a  DEBUGGING  LOOP.
   *			Each instruction will be tested  10  times.  The results from
   *			the test will not be checked.  Each time through the loop the
   *			instruction will be set up completeley including all the
   *			specified page faults.
   *
   *	     d)  "-do" X	X is a positive decimal number which specifies the NUMBER of
   *			the test that is to be processed.  This number has NO
   *			relationship to the  -ns  field in any test.
   *
   *	     e)  "-fm" X	X is the number of the first test that will be processed.  All
   *			remaining tests in the input segment will also be processed
   *			unless the -to option is also selected..


   *	     f)  "-to" X	X is the number of the last test that will be processed.
*/






/*		AUTOMATIC  DATA		*/


dcl  script_ptr ptr,				/* Pointer to the input data file.  */

     script_len fixed bin,				/* The length of the input data file.  */

     gen_seg_ptr ptr;				/* Pointer to the procedure segment which
						   *  will generate the input test data.  */



/*	This is the area where the  et_setup_data  resides.  It is declared as pointers
   *	so it will begin on an even word boundary.  It is slightly longer than necessary.
*/

dcl  setup_data_area (92) ptr;

dcl  code fixed bin (35),				/* Error code. */

     dup_string char (16),				/* Area where the previous line is saved.  */

     debug_loop_flag fixed bin,			/* Used to specify a tight loop from command
						   *  level.  Will not even test results of test.  */

     plural char (1),				/* Used to add an "s" to the end of words
						   *  in a print line.  */

     print_string char (16) aligned,			/* Area where the lines of data are printed. */

     print_pages (14) char (4),			/* Used to print the names of the pages
						   *  which this instruction will fault on.  */

     print_ptr ptr,					/* Pointer to the line being printed. */

     print_len fixed bin,				/* The number of characters still to be printed. */

     long_hregs bit (1) init ("0"b),			/* prints octal hregs if = 1 */

     num_words fixed bin,				/* The number of words in a string to be printed */


     line_length fixed bin,

     set_indicators bit (36),				/* Word used to set up the indicators in  etx.  */

     skip_count fixed bin,				/* The number of duplicated print lines
						   *  that have been skipped.  */

     test_num (10) fixed bin,				/* The number of the special test(s) we are
						   *  looking for due to a  "-fm" or "-do" option. */

     TEST_INSTR char (6) var init (""),			/* The type of instruction we want to test */

     stop_num fixed bin,				/* The number of the last test we are to run */

     times_to_repeat fixed bin,			/* The number of times to repeat a set of scripts */

     RPT fixed bin init (1),				/* itreration var for repeat opt */

    (SEL, SELECT) fixed bin,				/* used to set up and select a set of tests */


     temp_seg_name char (32),				/* name of temp seg being created */
     temp_segp ptr,					/* pointer to temp seg being created */
     copy_segp ptr,					/* pointer to segment to copy into temp seg */
     copy_bit_count fixed bin (24),			/* bit count of seg to copy */
     type fixed bin (2),
     sof_ bit (1) init ("0"b);			/* stop on test failure */

dcl  terminate_sel bit (1);


dcl (brief_flag, verbose_flag) fixed bin,		/* Used to suppress printing the data of
						   *  an instruction.  */

     gen_flag fixed bin,				/* Used to call a procedure to generate
						   *  the test data.  */

     nox_flag fixed bin,				/* Used to denote that the instructions are
						   *  not to be executed.  */

     finished_flag fixed bin,				/* Indicates when all of the instructions
						   *  have been tested.  */

     error_flag fixed bin,				/* ON when an error has been found.  */

     do_flag fixed bin,				/* Indicates that we are looking for one special
						   *  test to run.  */

     start_flag fixed bin,				/* Indicates that we are looking for one special
						   *  test to start with.  All test following it will
						   *  be processed unless the stop_ flag is set.  */

     remember_start fixed bin,			/* need to remember start falg when repeating */

     test_instr_flag fixed bin,			/* indicates we are looking for a type of instr */

     stop_flag fixed bin;				/* indicates we are to look for a test number which will stop our processing */



dcl  arg_ptr ptr,					/* Pointer to input argument. */
     arg_len fixed bin,				/* Length  of input argument. */
     num_args fixed bin,				/* Number of arguments to ET. */
     dir_name char (168),				/* Directory containing input file. */
     ent_name char (32),				/* Entry name of input file. */
     bit_count fixed bin (24);			/* Size of data file in bits. */


dcl  print_chars (1:4) char (12),			/* Used to print a word in octal while
						   *  doing some of our own editing.  */

     char_word char (4),				/* One word of the octal string se are printing. */

     character char (1);				/* One character of the octal print string. */


dcl (i, j, k, xx, argcount) fixed bin,			/* Work indexes. */
     loopx fixed bin,				/* Main test loop index. */
     datax fixed bin;				/* Index used to print data areas.  */

dcl  hreg_state bit (1) aligned;			/* state of this processes hreg switch */

dcl 1 bug_structure,				/* Just here for compiler bug. */
   (2 dummy_print_char char (1),			/* Used to pad data strings for printing so
						   *  they occupy fill words.  "707" octal. */
    2 dummy_test_char char (1),			/* Used to pad the beginning and end of the
						   *  test and result fields.  "717" octal. */
    2 result_fill_char char (1),			/* Used to fill in the result field.
						   *  "000" octal.  */
    2 bug_pad char (1)) unaligned;
dcl  touch_word bit (36),				/* Used to touch a page in order to bring
						   *  it into core.  */
     workx fixed bin,				/* A work variable.  */
     wptr ptr;					/* A work pointer.  */
dcl  int_cond_name char (32);

dcl  cond_infop ptr;				/* pointer to condition info */

dcl  instr_ptr ptr,					/* Pointer to where the  eis  instruc-
						   *  tion goes in  etx.  */

     save_data_ptr ptr,				/* Used to save a data pointer while printing. */

     our_offset fixed bin;				/* The instruction offset after it has been
						   *  converted from the input version to the
						   *  version we need internally.  Our offset
						   *  is from the beginning of the instruction
						   *  area and not from the end of the page.  */

dcl 1 akst aligned like kst_attributes;



/*		BASED  DATA		*/


dcl 1 eis_map based,				/* Map of the whole  eis  instruction. */
    2 instruction bit (36),
    2 desc_array (3) bit (36);


dcl  instr_overlay (7) bit (36) based;			/* Used to reference the  etx  instruc-
						   *  tion area as an array of words. */


dcl  word_overlay bit (36) based,			/* Used to reference an individual word. */

     char_overlay bit (9) based,			/* Used to reference one character.  */

     based_string char (16) based unaligned,		/* Used to reference one line of input
						   *  data that is actually in the data
						   *  string being printed.  */

/*	These arrays are used to reference the print string as an array of words and
   *	and a character as an array of 3 octal digits.
*/

     char_words (4) char (4) based (addr (print_string)) aligned,

     char_bits (3) bit (3) based (addr (character)) unaligned;



/*	This array is used to reference a data string as an array of characters.  */

dcl  data_array (1:4352) char (1) based unaligned,

     ptr_array (8) ptr based,				/* Used to reference the pointer
						   *  registers as an array of pointers. */

/*	reg_array is used to reference the registers as an array of half words.  */

     reg_array (16) fixed bin (17) based unaligned;

dcl script_path char(501);				/* make pathname big enough...		*/


dcl  data char (data_len) based,			/* Used to reference the data areas. */

     data_len fixed bin;				/* Size of the data field.  */



/*        used to copy a segment into a temporary segment */

dcl  copy_seg char (divide (copy_bit_count + 8, 9, 21, 0)) based;




/*		INTERNAL  STATIC  DATA	*/



/*	This table points to the three set up areas for data in etx.    Entries 4 and 5 are
   *	dummy entries.  They make this array correspond to the data_ptrs array.
*/

dcl  set_data_ptrs (5) ptr internal static;


/*	Word used to initialize the word we use to set up the indicators.
   *	The  BAR MODE indicator bit is always ON
*/
dcl  init_indicators bit (36) internal static
     init ("000000000000000000000000000010000000"b);




/*	This table contains static constants which are used to identify data
   *	strings when they are typed.  */

dcl  data_names (5) char (12) internal static
     init ("data field 1", "data field 2", "data field 3",
     "test  data  ", "result data ");


/*	This table contains the names of the pages which are defined by ET. */

dcl  page_names (14) char (4)
     init (" in1", " in2",
     " id1", " d11", " d12", " d13",
     " id2", " d21", " d22", " d23",
     " id3", " d31", " d32", " d33");

dcl  tx fixed bin internal static init (4),		/* Index to data arays for */
     rx fixed bin internal static init (5);		/* test and result data fields. */


dcl  oct_chars (0:7) char (1) internal static aligned
     init ("0", "1", "2", "3", "4", "5", "6", "7");

dcl  segs_initialized bit (1) internal static init ("0"b);

dcl  seg_ref_names (7) char (32) internal static options (constant)
     init ("etx", "eti1", "eti2", "eti3", "etd1", "etd2", "etd3");

dcl  condition_label label internal static,
     truncation_label label internal static;
dcl (stringsize, quit, et_error) condition;


/*  */
/*		EXTERNAL  DATA		*/


/*	The following declarations reference the dummy programs used to execute
   *	the  eis  instructions.
*/

dcl (etx$set_ptrs, etx$set_regs,
     etx$set_ind, etx$indicators,
     etx$instruction_area,
     etx$set_data1, etx$set_data2, etx$set_data3) external;


dcl  com_err_ entry options (variable),
     cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35)),
     cu_$arg_count entry (fixed bin),
     cu_$ptr_call entry options (variable),
     get_line_length_$switch entry (ptr, fixed bin (35)) returns (fixed bin),
     find_condition_info_ entry (ptr, ptr, fixed bin (35)),
     continue_to_signal_ entry (fixed bin (35)),
     et_util$char_rel entry (ptr, fixed bin),
     etx$execute entry options (variable),
     expand_pathname_ entry (char(*), char(*), char(*), fixed bin(35)),
     hcs_$initiate_count entry (char (*), char (*), char (*), fixed bin (24),
     fixed bin (12), ptr, fixed bin (35)),
     hcs_$make_ptr entry (ptr, char (*), char (*), ptr, fixed bin (35)),
     hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35)),
     hcs_$history_regs_get entry (bit (1) aligned),
     hcs_$history_regs_set entry (bit (1) aligned),
     hcs_$set_bc_seg entry (ptr, fixed bin (24), fixed bin (35)),
     hcs_$status_mins entry (ptr, fixed bin (2), fixed bin (24), fixed bin (35)),
     hcs_$terminate_name entry (char (*), fixed bin (35)),
     hcs_$terminate_noname entry (ptr, fixed bin (35)),
     phcs_$deactivate entry (ptr, fixed bin (35)),
     phcs_$set_kst_attributes entry (fixed bin (35), ptr, fixed bin (35)),
     ioa_ entry options (variable),
     unique_bits_ entry () returns (bit (70)),
     unique_chars_ entry (bit (*)) returns (char (15)),
     error_table_$badopt fixed bin(35) ext static,
     error_table_$bad_arg fixed bin (35) ext static,
     et_test entry (ptr, fixed bin, ptr, fixed bin, fixed bin (35));

%page;
%include kst_attributes;

dcl 1 cond_info aligned,
% include cond_info;


     dcl (addr, addrel, baseno, divide, fixed, hbound, null, rtrim, substr, unspec, verify) builtin;
%page;
%include et_setup_data;
%page;

	times_to_repeat = 1;
	test_num (*) = -1;
	script_path = "";
	SELECT = 1;
	

/*	 see if there are any optional arguments to  ET.  */

	verbose_flag, brief_flag, nox_flag = 0;		/* Initialize the flags OFF. */

	call cu_$arg_count (num_args);
	if num_args <= 0 then goto USAGE;

	debug_loop_flag = 0;			/* Zero implies we are not going to be
						   *  in a  debug  loop.  */
	remember_start, start_flag, stop_flag, do_flag = 0;
               do argcount = 1 to num_args;
	     call cu_$arg_ptr (argcount, arg_ptr, arg_len, code);

	     if code ^= 0
	     then do;
		call com_err_ (code, "ET", "Can't get command argument ^d", argcount);
		return;
	     end;
new_arg:
	     data_len = arg_len;

	     if arg_ptr -> data = "-help"
	     then go to USAGE;

	     else if arg_ptr -> data = "-bf"
	     | arg_ptr -> data = "-brief"
	     then brief_flag = 1;


	     else if arg_ptr -> data = "-long"
	     | arg_ptr -> data = "-lg" then
		verbose_flag = 1;


	     else
	     if arg_ptr -> data = "-nox"
	     then nox_flag = 1;

	     else
	     if arg_ptr -> data = "-debug"
	     then debug_loop_flag = 1;

	     else
	     if (arg_ptr -> data = "-fm")
	     | (arg_ptr -> data = "-from")
	     then do;

		start_flag, remember_start = 1;

		if argcount = num_args
		then do;
		     code = error_table_$bad_arg;
		     call com_err_ (code, "ET", "No number following ^a option.",
			arg_ptr -> data);
			return;
		end;

		argcount = argcount + 1;

		call cu_$arg_ptr (argcount, arg_ptr, arg_len, code);
		if code ^= 0 then goto bad_arg ;

		test_num (1) = verify (substr (arg_ptr -> data, 1, arg_len), "0123456789");

		if test_num (1) ^= 0
		then do;
		     code = error_table_$bad_arg;
		     call com_err_ (code, "ET", "Illegal numeric option argument: ^a",
			arg_ptr -> data);
		     return;
		end;
		test_num (1) = fixed (substr (arg_ptr -> data, 1, arg_len), 17);
	     end;


	     else
	     if (arg_ptr -> data = "-instruction_type")
	     | (arg_ptr -> data = "-inst")
	     then do;


		if argcount = num_args
		then do;
		     code = error_table_$bad_arg;
		     call com_err_ (code, "ET", "No instruction type following ^a option.",
			arg_ptr -> data);
		     return;
		end;

		argcount = argcount + 1;

		call cu_$arg_ptr (argcount, arg_ptr, arg_len, code);
		if code ^= 0 then go to bad_arg;

		TEST_INSTR = substr (arg_ptr -> data, 1, arg_len);
		test_instr_flag = 1;
		if substr (TEST_INSTR, 1, 1) = "-"
		then do;
		     code = error_table_$bad_arg;
		     call com_err_ (code, "ET", "An instruction type does not follow argument: ^a",
			arg_ptr -> data);
		     return;
		end;
	     end;


	     else if arg_ptr -> data = "-to"
	     then do;

		stop_flag = 1;

		if argcount = num_args then do;
		     code = error_table_$bad_arg;
		     call com_err_ (code, "ET", "No number following ^a option.", arg_ptr -> data);
		     return;
		end;

		argcount = argcount + 1;
		call cu_$arg_ptr (argcount, arg_ptr, arg_len, code);
		if code ^= 0 then go to bad_arg;
		stop_num = verify (substr (arg_ptr -> data, 1, arg_len), "0123456789");
		if stop_num ^= 0 then do;
		     code = error_table_$bad_arg;
		     call com_err_ (code, "ET", "Illegal numeric option argument: ^a", arg_ptr -> data);
		     return;
		end;

		stop_num = fixed (substr (arg_ptr -> data, 1, arg_len), 17);
	     end;


	     else
	     if (arg_ptr -> data = "-do")
	     | (arg_ptr -> data = "-select")
	     | (arg_ptr -> data = "-sel")
	     then do;

		do_flag = 1;

		if argcount = num_args
		then do;
		     code = error_table_$bad_arg;
		     call com_err_ (code, "ET", "No number following ^a option.",
			arg_ptr -> data);
		     return;
		end;

		terminate_sel = "0"b;
		SELECT = 0;
		do SEL = 1 to 10 while (^terminate_sel); /* get the set to run */
		     argcount = argcount + 1;

		     call cu_$arg_ptr (argcount, arg_ptr, arg_len, code);

		     if code ^= 0 then do;
			if SEL = 1 then do;
bad_sel_arg:		     call com_err_ (code, "ET", "No number following the select arg.");
			     return;
			end;
			terminate_sel = "1"b;
			go to set_up_sel;
		     end;

		     if substr (arg_ptr -> data, 1, 1) = "-" then do;

			if SEL = 1 then do;
			     code = error_table_$bad_arg;
			     go to bad_sel_arg;
			end;
			argcount = argcount -1;
			terminate_sel = "1"b;
			go to set_up_sel;
		     end;

		     test_num (SEL) = verify (substr (arg_ptr -> data, 1, arg_len), "0123456789");

		     if test_num (SEL) ^= 0
		     then do;
			if (SEL >1) & ((substr(arg_ptr->data, 1, 1) ="-")
			     | (script_path = "")) then goto new_arg;
			code = error_table_$bad_arg;
			call com_err_ (code, "ET", "Illegal numeric option argument: ^a",
			     arg_ptr -> data);
			return;
		     end;
		     test_num (SEL) = fixed (substr (arg_ptr -> data, 1, arg_len), 17);

		end;
		SELECT = SELECT + 1;
set_up_sel:
	     end;

	     else if arg_ptr -> data = "-stop_on_failure"
	     | arg_ptr -> data = "-sof"
	     then sof_ = "1"b;

	     else if arg_ptr -> data = "-repeat"
	     | arg_ptr -> data = "-rpt" then do;
		if argcount = num_args then do;
		     code = error_table_$bad_arg;
		     call com_err_ (code, "ET", "No number following ^a option.", arg_ptr -> data);
		     return;
		end;

		argcount = argcount + 1;
		call cu_$arg_ptr (argcount, arg_ptr, arg_len, code);
		if code ^= 0 then go to bad_arg;
		times_to_repeat = verify (substr (arg_ptr -> data, 1, arg_len), "0123456789");

		if times_to_repeat ^= 0 then do;
		     code = error_table_$bad_arg;
		     call com_err_ (code, "ET", "Illegal numeric option argument: ^a", arg_ptr -> data);
		     return;
		end;

		times_to_repeat = fixed (substr (arg_ptr -> data, 1, arg_len), 17);

	     end;
	     else
use_as_script_path:
	     if script_path = "" then script_path = arg_ptr -> data;
	     else do;
		if substr(arg_ptr -> data, 1, 1) = "-" then code = error_table_$badopt;
		else
bad_arg:	          code = error_table_$bad_arg;
ARG_ERROR:	call com_err_ (code, "ET", "^a.", arg_ptr -> data);
		return;
USAGE:		call ioa_ ("ET: Usage is: et path {-control_args}");
		call ioa_ ("Valid control args: -brief, -bf^/^-^--debug");
		call ioa_ ("^-^--from TEST_NUM,-fm TEST_NUM^/^-^--instruction_type INSTR, -inst INSTR");
		call ioa_ ("^-^--long, -lg^/^-^--nox^/^-^--repeat NUM, -rpt NUM");
		call ioa_ ("^-^--select TEST_NUM, -sel TEST_NUM^/^-^--stop_on_failure, -sof^/^-^--to TEST_NUM");

incons_arg:
		if ^hreg_state then			/* if they were off when we started.. */
		     call hcs_$history_regs_set ("0"b); /* turn off hregs */
		return;
	     end;

	end;
%page;



/*	"eis_tester" (ET) is called with one command option - the path name of a
   *	segment containing input script data or the path name of a procedure which will
   *	be called to set up the input data.
*/


	gen_flag = 0;				/* This is the normal entry.  */

	goto join;



gen:	entry;

	gen_flag = 1;



join:

	line_length = get_line_length_$switch (null (), code);
	if line_length < 132 then long_hregs = "0"b;
	else long_hregs = "1"b;


	call hcs_$history_regs_get (hreg_state);	/* get state of processes save hreg switch */

	if ^hreg_state then
	     call hcs_$history_regs_set ("1"b);		/* turn on for testing */

          if (gen_flag = 1) then do;			/* for this we have to get one and only one argument*/
	     call cu_$arg_ptr(1, arg_ptr, arg_len, code); /* no other checking is done			*/
	     if code ^= 0 then goto ARG_ERROR;
	     data_len = arg_len;
	     script_path = arg_ptr -> data;
	     end;

/*	Now expand this path name  so we can initiate the segment.
*/

	call expand_pathname_ (script_path, dir_name, ent_name, code);

	if code ^= 0
	then do;
	     call com_err_ (code, "ET", "Can't expand path name of input segment ^a.", script_path);
	     return;
	end;



/*	If we have a script segment then get a pointer to the base of this segment.
   *	Also get the length of the segment in characters.
*/

	do RPT = 1 to times_to_repeat;		/* repeat set x times */

	     if remember_start = 1 then		/* reset starting test indicator */
		start_flag = 1;

	     SELECT = 1;
	     if gen_flag = 0			/* Is there script input?  */


	     then do;

		call hcs_$initiate_count (dir_name, ent_name, "", bit_count, 1,
		     script_ptr, code);

		if script_ptr = null ()
		then do;
		     call com_err_ (code, "ET", "Cannot initiate data segment ^a^[>^]^a.", dir_name, (dir_name ^= ">"), ent_name);
		     return;
		end;

		code = 0;

		bit_count = bit_count + 8;

		script_len = bit_count / 9;		/* Get size in chars. */

	     end;



	     else do;				/* The input is a path name of a procedure
						   *  segment.  Get a pointer to the entry
						   *  point of this procedure.  */

		call hcs_$make_ptr (null (), ent_name, ent_name, gen_seg_ptr, code);

		if code ^= 0
		then do;
		     call com_err_ (code, "ET", "Can't get pointer to entry point of gen seg ^a^[>^]^a.", 
			dir_name, (dir_name ^= ">"), ent_name);
		     return;
		end;

	     end;

%page;
/*        Create the temporary segments we will use, if they have not been
   created in a prior invocation.  Before touching them, make them
   deactivatable explicitly */

	     if ^segs_initialized then do;
		do i = 1 to hbound (seg_ref_names, 1);
		     call hcs_$terminate_name (seg_ref_names (i), code); /* get rid of residual */
		     call hcs_$make_ptr (null (), seg_ref_names (i), "", copy_segp, code);
		     if code ^= 0 then do;
			call com_err_ (code, "ET", seg_ref_names (i));
			return;
		     end;
		     call hcs_$status_mins (copy_segp, type, copy_bit_count, code);
		     if code ^= 0 then do;
			call com_err_ (code, "ET", seg_ref_names (i));
			return;
		     end;
		     temp_seg_name = unique_chars_ (unique_bits_ ()) || "." || rtrim (seg_ref_names (i));
		     call hcs_$make_seg ("", temp_seg_name, "", 01110b, temp_segp, code);
		     if code ^= 0 then do;
			call com_err_ (code, "ET", "Creating [pd]>^a", temp_seg_name);
			return;
		     end;
		     unspec (akst) = "0"b;
		     akst.set.explicit_deactivate_ok,
			akst.value.explicit_deactivate_ok = "1"b;
		     call phcs_$set_kst_attributes (fixed (baseno (temp_segp), 17), addr (akst), code);
		     if code ^= 0 then do;
			call com_err_ (code, "ET", "Setting KST attributes for [pd]>^a", temp_seg_name);
			return;
		     end;
		     temp_segp -> copy_seg = copy_segp -> copy_seg;
		     call hcs_$terminate_name (seg_ref_names (i), code);
		     call hcs_$make_seg ("", temp_seg_name, seg_ref_names (i), 01110b, (null ()), code);
		     call hcs_$set_bc_seg (temp_segp, copy_bit_count, code);
		     if code ^= 0 then do;
			call com_err_ (code, "ET", "Setting bit count for [pd]>^a", temp_seg_name);
			return;
		     end;
		end;
		segs_initialized = "1"b;
	     end;
	call ioa_ ("^/ET");
%page;
/*	Initialize those arguments that have to be initialized only once */

	     condition_label = condition_restart;

	     set_data_ptrs (1) = addr (etx$set_data1);
	     set_data_ptrs (2) = addr (etx$set_data2);
	     set_data_ptrs (3) = addr (etx$set_data3);
	     set_data_ptrs (4),
		set_data_ptrs (5) = null ();

	     et_data_ptr = addr (setup_data_area);

	     page_ptrs (*) = null ();

	     next_instruction_x = 0;

	     finished_flag = 0;

	     test_count = 0;

	     addr (result_fill_char) -> char_overlay = "000000000"b;
	     addr (dummy_print_char) -> char_overlay = "111000111"b;
	     addr (dummy_test_char) -> char_overlay = "111001111"b;

/*	Note, the dummy value for the registers is 8191 decimal.  This value is used
   *	because it is greater than any number we will use in a register and is equal
   *	to  17777 octal.
*/

	     do i = 12 to 15;
		addr (regs) -> reg_array (i) = 8191;
	     end;


/*	We must reference the location in  etx  where we transfer to so we will not take
   *	a linkage fault when we actually call  etx$execute.
*/

	     touch_word = addr (etx$execute) -> word_overlay;
						/* 	*/

/*	The input script segment may contian data for more than one instruction.
   *	We will process one instruction at a time until we are told to stop.
   *	( finished_flag will be  on ).  */


	     do while (finished_flag = 0);

		call test_instruction;

condition_restart:
	     end;					/* End the main  do  loop. */

	end;					/* end RPT loop */


/*	We are all done so clean up input script if there was any.  */

	if gen_flag = 0

	then call hcs_$terminate_noname (script_ptr, code);



/*	Logical end of  eis_tester.  */

	if ^hreg_state then
	     call hcs_$history_regs_set ("0"b);		/* turn off hregs */
	return;

/*  */
test_instruction: procedure;


/*	This procedure is called from the main  eis_tester  procedure.  It will set up
   *	and test one  eis  instruction.  Once it has parsed the input data describing this
   *	instruction it will set up the external segments and actually execute the
   *	instruction.  Before returning it will test the results of the instruction.
*/

	     code = 0;
	     error_flag = 0;
	     name = " ";
	     note = " ";

	     test_count = test_count + 1;



/*	Now we will set up to handle a truncation fault.
*/



/*	Initialize the instruction area in  etx to all  nop  instructions. */

	     do i = 1 to 7;
		addr (etx$instruction_area) -> instr_overlay (i) =
		     "000000000000000000000001001000000000"b;
	     end;



/*	Now test the  "gen_flag" to see how we are getting our input.  */


	     if gen_flag = 0


	     then do;

		call et_test (script_ptr, script_len, et_data_ptr, finished_flag, code);

		if code ^= 0			/* If anything is wrong don't bother
						   *  to test this instruction. */
		then do;
		     call com_err_ (0, "ET", "Error in input statement for test:  ^d  -  ^a", test_count, name);
		     return;
		end;
	     end;


	     else do;

		call cu_$ptr_call (gen_seg_ptr, et_data_ptr);

		finished_flag = 1;

	     end;





/*	See if we are to check for a special test to start with.
   *	If so we will count the number of tests we have parsed so far.  If this
   *	is not the one we want we will return and thus not process this test.
   *	If the start_flag is OFF then the do_flag must be ON and thus we will
   *	only do this one test.   If the start_flag is ON then we will stop counting
   *	the test and just do all the rest of the tests.  NOTE, if both flags
   *	are ON the  start_flag will override the do_flag.
*/

	     if test_instr_flag = 1 then
		if TEST_INSTR ^= name then return;

	     if start_flag = 1
	     then do;
		if test_count ^= test_num (1)
		then return;

		else do;
		     start_flag = 0;
		     do_flag = 0;
		end;
	     end;


	     if do_flag = 1 then do;
		if test_num (SELECT) = -1 then do;
		     finished_flag = 1;
		     return;
		end;
		if test_count ^= test_num (SELECT)
		then return;
		else
		SELECT = SELECT +1;
	     end;


	     if stop_flag = 1 then do;		/* check for end test */
		if test_count = stop_num then
		     finished_flag = 1;
	     end;

	     if brief_flag = 0 then
		call ioa_ ("TEST ^3d (^a)", test_count, name);



/*	First set up  the instruction in the  etx  segment.  */


/*	Get a pointer to where we must place the instruction.  Note, the instruction
   *	area words that are not used are left as  nops.  Once we have the pointer
   *	we will move the instruction word.  Note, the instruction offset defined by
   *	the user is backwards as far as we are concerned.  We need the offset from the
   *	beginning of the instruction area.  We will convert it.
*/

	     our_offset = (instr_offset - 3)* (-1);

	     instr_ptr = addrel (addr (etx$instruction_area), our_offset);

	     instr_ptr -> eis_map.instruction = instr_word;


/*	Now set up the descriptor words.  If there is an indirect word it will take
   *	the place of a descriptor word.   In that case we must put the descriptor
   *	word somewhere else.
*/

	     do i = 1 to 3;

		if descriptors (i) ^= "0"b		/* Check to see if we must move this
						   *  descriptor. */

		then do;				/* Descriptor present - set it up. */

		     if ind_words (i) = "0"b		/* Check for indirect descriptor. */

/*	If there is no indirect word just move the descriptor into the instruction
   *	in  etx.  */
		     then instr_ptr -> eis_map.desc_array (i) = descriptors (i);

/*	If there is an indirect word then the indirect word will replace the
   *	descriptor in the  eis  instruction.  The descriptor will be move into
   *	a word as specified by the pointer in the desc_ptrs array. */

		     else do;
			instr_ptr -> eis_map.desc_array (i) = ind_words (i);
			desc_ptrs (i) -> word_overlay = descriptors (i);
		     end;

		end;

	     end;					/* End of descriptor move do loop.  */



/*	Initialize the set_indicators word.  By default we will just have the  BAR MODE
   *	indicator ON.  If the user has specified that the instruction is to turn ON
   *	the  -  overflow, exponent overflow, or exponent underflow  -  indicators then
   *	we will turn  ON  the overflow mask so we will not get an overflow type fault
   *	from the test instruction.
*/

	     set_indicators = init_indicators;

	     if (substr (ir_word, 22, 1) = "1"b) |
	     (substr (ir_word, 23, 1) = "1"b) |
	     (substr (ir_word, 24, 1) = "1"b)
	     then do;
		substr (set_indicators, 25, 1) = "1"b;
		substr (ir_word, 25, 1) = "1"b;
	     end;



/*	If there is test and result data we want to put special characters at the
   *	beginning and end of these data strings.  Thus if the  EIS  instruction
   *	incorrectly stores into words beyond the bounds of the result data string
   *	we will be able to recognize the error.  Eight special characters ("717" octal)
   *	will be stored at the beginning and end of these two strings.
*/

	     if data_lens (tx) = 0 then goto print_instr_data;


	     do i = tx to rx;

		call et_util$char_rel (data_ptrs (i), -8);
		data_lens (i) = data_lens (i) + 16;

		do j = 1 to 8;
		     data_ptrs (i) -> data_array (j),
			data_ptrs (i) -> data_array (data_lens (i) +1 -j) = dummy_test_char;
		end;

	     end;





/*	Now if we are in VERBOSE mode we will print all of the data involved with
   *	this test.  We will start with the instruction itself
*/

print_instr_data:

	     if RPT > 1 then verbose_flag = 0;


	     if verbose_flag = 0 then goto check_execute;

	     call ioa_ ("^/Test Description:  ^a", note);

	     call ioa_ ("^/Eis instruction:^-( ^p )   Ind  Desc.", instr_ptr);

	     if instr_offset = 0
	     then call ioa_ ("^4x- - - -- - - -");

	     call ioa_ ("^5x^w", instr_ptr -> eis_map.instruction);


	     do i = 1 to 3;

		if instr_offset = i
		then call ioa_ ("^4x- - - -- - - -");

		if (i = 3) & (descriptors (3) = "0"b)
		then goto print_ptrs;

		if ind_words (i) = "0"b

		then call ioa_ ("^5x^w", instr_ptr -> eis_map.desc_array (i));

		else call ioa_ ("^5x^w^8x->      ^w   ( ^p )",
		     instr_ptr -> eis_map.desc_array (i),
		     descriptors (i), desc_ptrs (i));
	     end;


/* 	Now print the pointer registers if any of them are being used.  */

print_ptrs:

	     do i = 0 to 7;

		if pointers (i) ^= null ()

		then do;
		     call ioa_ ("^/Pointer Registers:^-( ^p )", addr (etx$set_ptrs));
		     call ioa_ ("^5xpr0 - pr3    ^p  ^p  ^p  ^p",
			pointers (0), pointers (1), pointers (2), pointers (3));
		     call ioa_ ("^5xpr4 - pr7    ^p  ^p  ^p  ^p",
			pointers (4), pointers (5), pointers (6), pointers (7));
		     goto print_regs;
		end;
	     end;


/*	If any of the index registers of the A or Q have been used then we will print out
   *	all of the index registers includeing A and Q.
*/

print_regs:

	     do i = 0 to 7;
		if regs.x (i) ^= 8191
		then goto found_used_regs;
	     end;

	     if (regs.A ^= 8191) | (regs.Q ^= 8191)
	     then goto found_used_regs;
	     else goto print_indicators;


found_used_regs:
	     call ioa_ ("^/Index Registers:^-( ^p  )", addr (etx$set_regs));
	     call ioa_ ("^5x X0 - X7     ^6o ^6o ^6o ^6o ^6o ^6o ^6o ^6o",
		regs.x (0), regs.x (1), regs.x (2), regs.x (3),
		regs.x (4), regs.x (5), regs.x (6), regs.x (7));
	     call ioa_ ("^5x    A  ^w      Q  ^w", regs.A, regs.Q);



print_indicators:

	     call ioa_ ("^/Test Indicators:^-( ^p )", addr (etx$indicators));
	     call ioa_ ("^5x^w", ir_word);



/*	Now print out the names of the pages which we will take faults on.  */

	     workx = 0;				/* Initialize count of page faults.  */

	     do i = 1 to 14;

		print_pages (i) = " ";

		if (page_faults (i) = "1"b) & (page_ptrs (i) ^= null)

		then do;
		     workx = workx + 1;
		     print_pages (workx) = page_names (i);
		end;
	     end;

	     if workx = 1
	     then plural = " ";
	     else plural = "s";

	     call ioa_ ("^/This test will take  ^d  page fault^a.", workx, plural);

	     if workx ^= 0
	     then call ioa_ ("^4x^a^a^a^a^a^a^a^a^a^a^a^a^a^a",
		print_pages (1), print_pages (2), print_pages (3), print_pages (4),
		print_pages (5), print_pages (6), print_pages (7), print_pages (8),
		print_pages (9), print_pages (10), print_pages (11),
		print_pages (12), print_pages (13), print_pages (14));


/*	Now print the data referenced by the descriptors.  We will print it only if the
   *	descriptor actually has data.
*/

	     do datax = 1 to 3;

		if data_ptrs (datax) ^= null () then call print_data;
	     end;


/*	Now print the test data.  */

	     if data_lens (tx) ^= 0

	     then do;
		datax = tx;
		call print_data;
	     end;



/*	We will test to see if we really are going to execute this instruction.
   *	If not we will just return.
*/

check_execute:

	     if nox_flag ^= 0 then return;


/*	Now execute the instruction.  It will be executed the number of times
   *	specified in  loop_count.   Before each execution we must reset the data fields
   *	and set up the page faults.  After each test we will compare the data results
   *	and the settings of the indicator registers.  If the debug loop flag is  ON
   *	then we will override any loop count specified by the user and set the loop
   *	count to  10.
*/


	     if debug_loop_flag = 1
	     then loop_count = 10;

	     do loopx = 1 to loop_count;


/*	If there is a result area we will initialize it to the special fill characters.  */

		if data_lens (rx) ^= 0

		then do i = 9 to data_lens (rx) - 8;
		     data_ptrs (rx) -> data_array (i) = result_fill_char;
		end;


/*	Now move all the data fields into position.  */

		do j = 1 to 3;

		     if (data_ptrs (j) ^= null ()) & (data_lens (j) ^= 0)

		     then do;
			data_len = data_lens (j);
			data_ptrs (j) -> data = set_data_ptrs (j) -> data;
		     end;

		end;				/* End of the data set up loop.  */


/*	Now set up the pointer registers,  registers, and the indicator word in
   *	etx.  Before we store the index registers which  etx  will use we must put
   *	our instruction offset in  X0.   etx uses X0 so it can transfer directly to the
   *	first word of the eis instruction and not just the beginning of the instruction
   *	area.
*/

		regs.x (0) = our_offset;

		addr (etx$set_ptrs) -> ptr_array = pointers;

		addr (etx$set_regs) -> reg_array = addr (regs) -> reg_array;

		addr (etx$set_ind) -> word_overlay = set_indicators;
		addr (etx$indicators) -> word_overlay = "0"b;

/*	Now set up the handlers for possible conditions */

		truncation_label = check_errors;
		on stringsize begin;		/* truncation handler */


/*	If the truncation flag is not  ON  then we took an illegal truncation fault.
*/

		     if truncation_flag = 0
		     then do;
			error_flag = 1;
			call com_err_ (0, "ET", "Unexpected truncation fault for test:  ^d  -  ^a", test_count, name);
			call display_mc_;
			go to truncation_label;
		     end;


/*	This truncation fault is OK.  We will trun off the truncation flag so that the
   *	error checking code will not think that there is an error.
*/


		     else truncation_flag = 2;
		     go to truncation_label;
		end;

		if ^sof_ then go to SETUP;		/* just run like old unless told otherwise */


		on condition (et_error) begin;
		     cond_infop = addr (cond_info);
		     call find_condition_info_ (null (), cond_infop, code);
		     int_cond_name = cond_info.condition_name;
		     call display_mc_;
		     call continue_to_signal_ (code);
		end;				/* end any_other */
SETUP:



/*	Now we will flush out all of the pages used by this process.
   *	Then we can bring back the ones we want - thus leaving faults
   *	set in the pages that we want to take faults on.  */



LOOP:		call DEACTIVATE;


/*	Look through the page_fault table.  Those entries that are ON represent
   *	pages that should take faults during the execution of the  eis  instruction.
   *	We will leave them alone since after the  flush we will assume that they
   *	are not in core.  Those entries that are still  OFF we will touch so that
   *	we can be sure that they are in core and will not take a page fault during
   *	the execution of the  eis  instruction.  We assume, of course, that there
   *	is not enough paging going on to drive these pages out before we can
   *	execute the  eis  instruction.
*/

		do i = 1 to 14;

		     if (page_faults (i) = "0"b) & (page_ptrs (i) ^= null ())

		     then touch_word = page_ptrs (i) -> word_overlay;

		end;


/*	Now we can execute the  eis  instruction.  */


		call etx$execute;
		revert stringsize;


/*	Once we have returned from  etx  we must test the resulting data and the
   *	resulting indicator word.  Note, some instructions do not actually move any
   *	data and thus there is no result data to test.  Note, if the debug loop
   *	flag is  ON  then we will not test the results.  We will just go back and
   *	and do the test again.
*/


check_errors:

		if debug_loop_flag = 1
		then goto end_test_loop;

		data_len = data_lens (rx);

		if data_len ^= 0

		then if data_ptrs (tx) -> data ^= data_ptrs (rx) -> data

		     then do;			/* Print  data fields in octal. */
			call ioa_ ("^/Data resulting from test ( ^d - ^a ) is incorrect.", test_count, name);
			datax = rx;
			call print_data;		/* Print the invalid result data. */
			error_flag = 1;
		     end;


/*	If we took a truncation fault we will not check the indicators since the
   *	sti  instruction in  etx  was not executed.
*/

		if truncation_flag = 2
		then goto check_for_trun;

		if addr (etx$indicators) -> word_overlay ^= ir_word

		then do;
		     call ioa_ ("^/Indicators not set correctly for test:  ^d  -  ^a", test_count, name);
		     call ioa_ ("^/Test   indicator word is: ^w", ir_word);
		     call ioa_ ("Result indicator word is: ^w",
			addr (etx$indicators) -> word_overlay);
		     error_flag = 1;
		end;


/*	If the truncation flag is ON then we were expecting a truncation fault but none
   *	occurred.  If one had occurred the handler would have set the flag to  2.
*/

check_for_trun:

		if truncation_flag = 1
		then do;
		     call com_err_ (0, "ET", "^/Expected truncation fault did not occur.");
		     error_flag = 1;
		end;

		if error_flag = 1 then
		     call ioa_ ("^/*** TEST NOTES: ^a ***^/", note);

		if (error_flag = 1) & (sof_ = "1"b) then
		     signal et_error;

end_test_loop:
	     end;					/* End of the  test  loop.  */


/*	This is the logical end of   test_instructions	*/
/*  */
print_data:    procedure;



/*	This procedure is called to print out a data field.  the data field will be
   *	printed in octal words, four words to the line.  The first line printed
   *	will contain the name of the data field and a pointer to the data field.
   *	Note, the special fill characters will be converted so they will not be printed
   *	out as octal digits.  They will be converted to:
   *	dummy_print_char  -  3 blanks  "   "
   *	dummy_fill_char   -  3 x's     "xxx"
*/


		call ioa_ ("^/^a^-( ^p )", data_names (datax), data_ptrs (datax));


/*	If the length of this data is zero then this data field must be a result field.
   *	We will print a message telling the user this and  also print what the fill character
   *	will be.
*/

		if data_lens (datax) = 0

		then do;
		     call ioa_ ("^5xResult data field initialized to all zero bits.");
		     return;
		end;


/*	Get a pointer to the data to print.  We also need its length.  If we are printing
   *	the data for a descriptor we will use the data in the set up areas of  etx.
*/

		if set_data_ptrs (datax) = null ()

		then print_ptr = data_ptrs (datax);
		else print_ptr = set_data_ptrs (datax);

		print_len = data_lens (datax);


/*	Since we will be printing full words we must set the unused characters in the
   *	first word to a special value.  We must also adjust the print pointer so that
   *	it points to what we now consider the beginning of the first word of the
   *	string.  Note, this may not actually be on a word boundary.
*/

		call et_util$char_rel (print_ptr, -data_offsets (datax));
		print_len = print_len + data_offsets (datax);

		do i = 1 to data_offsets (datax);
		     print_ptr -> data_array (i) = dummy_print_char;
		end;


/*	Now we must fill in the unused characters of the last word of the string.  They
   *	will be set to the same dummy character.
*/

		workx = print_len - 1;
		workx = 4 - (print_len - (divide (workx, 4, 17, 0))*4);

		do i = 1 to workx;
		     print_len = print_len + 1;
		     print_ptr -> data_array (print_len) = dummy_print_char;
		end;


/*	Now we will print the data string.   A maximum of   4  words of data will be
   *	printed on each line.  Duplicate lines will be suppressed.
*/

		skip_count = 0;			/* Initialize count of the duplicate lines. */

		dup_string = "_$<-+;*><)(:|||";

		num_words = divide (print_len, 4, 17, 0);




		do while (num_words > 0);		/* Each iteration prints 1 line. */

		     if num_words > 3		/* Get number of words in this line. */
		     then workx = 4;
		     else workx = num_words;

		     num_words = num_words - 4;

		     if (num_words > 0) & (print_ptr -> based_string = dup_string)


		     then do;			/* This line is a duplicate of the previous
						   *  line.  If it is not the last line we will
						   *  skip it.  The last line is always printed.  */
			skip_count = skip_count + 1;
			print_ptr = addr (print_ptr -> data_array (17));
			goto end_line;
		     end;


/*	This is the last line or it is not the same as the previous line.  */

		     if skip_count ^= 0		/* Were there duplicate lines before? */

		     then do;			/* YES. */
			if skip_count = 1
			then plural = " ";
			else plural = "s";
			call ioa_ ("^5xPrevious line repeated  ^d  time^a.", skip_count, plural);
			skip_count = 0;
		     end;

/*	Move the line to be printed to an aligned area so it can be printed as an array
   *	of words.  Save it in the duplicate string so we can test the next line.
   *	Then we must update the print pointer to reference the next line.
*/

		     print_string = print_ptr -> based_string;

		     dup_string = print_ptr -> based_string;

		     print_ptr = addr (print_ptr -> data_array (17));


/*	Now convert the string of octal words to the character representation for these
   *	octal digits.  This is done just so the special dummy characters will not be
   *	printed in octal.
*/

		     do i = 1 to workx;		/* One iteration for each word in the line. */

			char_word = char_words (i);

			do j = 1 to 4;		/* One iteration for each character in
						   *  the word.  */

			     character = substr (char_word, j, 1);

			     if character = dummy_print_char
			     then do;
				xx = 1 + (j-1)*3;
				substr (print_chars (i), xx, 3) = "   ";
				goto end_char;
			     end;

			     if character = dummy_test_char
			     then do;
				xx = 1 + (j-1)*3;
				substr (print_chars (i), xx, 3) = "xxx";
				goto end_char;
			     end;

			     do k = 1 to 3;
				xx = k + (j-1)*3;
				substr (print_chars (i), xx, 1) =
				     oct_chars (fixed (char_bits (k), 3));
			     end;

end_char:
			end;
		     end;


/*	Use the  "ioa_" call for the number of words in this line.  If the
   *	number is less than 4 we know this is the last line.
*/

		     goto print_line (workx);



print_line (1):

		     call ioa_ ("^5x^a", print_chars (1));

		     return;


print_line (2):

		     call ioa_ ("^5x^a  ^a", print_chars (1), print_chars (2));

		     return;


print_line (3):

		     call ioa_ ("^5x^a  ^a  ^a", print_chars (1),
			print_chars (2), print_chars (3));

		     return;


print_line (4):

		     call ioa_ ("^5x^a  ^a  ^a  ^a", print_chars (1), print_chars (2),
			print_chars (3), print_chars (4));


end_line:

		end;				/* This is the end of the print  do  loop. */


	     end print_data;





	end test_instruction;
						/* 	*/
display_mc_: proc;

dcl  cu_$stack_frame_ptr entry (ptr);
dcl  find_condition_frame_ entry (ptr) returns (ptr);
dcl  find_condition_info_ entry (ptr, ptr, fixed bin (35));
dcl  dump_machine_cond_ entry (ptr, ptr, char (32) aligned, fixed bin);
dcl  hran_$hranl entry (ptr, ptr, bit (1));
dcl  hreg_ptr ptr;


dcl 1 condinfo aligned,
% include cond_info;

     dcl (stackp, faultsp) ptr;
dcl (null, addr) builtin;
dcl  ec fixed bin (35);


	     call cu_$stack_frame_ptr (stackp);		/* get current stack pointer */
	     faultsp = find_condition_frame_ (stackp);	/*  is this the condition frame? */
	     if faultsp = null then do;		/* no */
		call ioa_ (" No condition frame.");
		return;
	     end;
	     else call find_condition_info_ (faultsp, addr (condinfo), ec); /* get a pointer to the machine conditions */
	     if condinfo.mcptr = null () then
		return;
	     call ioa_ ("^/MACHINE CONDITIONS AT ^p:^/", condinfo.mcptr);

	     call dump_machine_cond_ (addr (condinfo), faultsp, "user_output", 2); /* print the MC */
	     if mcptr ^= null then
		hreg_ptr = addrel (mcptr, 96);
	     if hreg_ptr = null then do;		/* no history regs to dump */
		call ioa_ ("History Registers are not available");
		return;
	     end;
	     else do;
		call ioa_ ("CPU HISTORY REGISTERS AT TIME OF FAULT");
		call hran_$hranl (hreg_ptr, null, long_hregs);
	     end;

	     return;
	end display_mc_;

%page;
DEACTIVATE: proc;
dcl  i fixed bin;

/* Deactivate each segment.  This will force its pages out of memory. */


	     do i = 1 to 14;
		if page_ptrs (i) ^= null () then
		     if baseno (page_ptrs (i)) ^= "077777"b3 then
			call phcs_$deactivate (page_ptrs (i), code);
	     end;


	     return;

	end DEACTIVATE;



     end eis_tester;
