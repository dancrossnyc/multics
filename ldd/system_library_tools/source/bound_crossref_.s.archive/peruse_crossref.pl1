/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


/* This program peruses a cross-reference output file, as generated by the
   online crossreference program. It is used to print out entries from the
   crossref in a relatively readable format.

   Modification history:
   08/13/80 W. Olin Sibert
   03/04/81 E. N. Kittlitz - divers alterations.
   04/22/81 E. N. Kittlitz - handle cref* error messages in CREF MSF.
   Fix assumes that all messages are at end of MSF.
   12/31/81 J. Spencer Love - fix search bug, fix long include file names
   bug, minor improvements.
   2/82 BIM for default cref path.
   4 Apr 82, WOS: Modified for active function usage.
   1984-08-26 BIM -brief_errors
   1985-01-03, BIM: fixed leading _ names to work for include files.
*/


/****^  HISTORY COMMENTS:
  1) change(86-08-16,JSLove), approve(86-08-16,MCR7430),
     audit(86-09-12,GDixon), install(86-09-15,MR12.0-1153):
     Added support for synonyms in input file.  Added undocumented -debug
     control argument.
                                                   END HISTORY COMMENTS */


/* format: style2 */

pcref:
peruse_crossref:
     procedure () options (variable);

	dcl     alp		 pointer;
	dcl     code		 fixed bin (35);
	dcl     debug		 bit (3) aligned;
	dcl     nargs		 fixed bin;
	dcl     rs_ptr		 pointer;
	dcl     rs_lth		 fixed bin (21);
	dcl     return_string	 char (rs_lth) based (rs_ptr) varying;
	dcl     complain		 variable entry options (variable);
	dcl     active_function	 bit (1) aligned;
	dcl     brief_sw		 bit (1) aligned;
	dcl     brief_error_sw	 bit (1) aligned;
	dcl     questionable_module	 bit (1) aligned;	/* GLOBAL for communication between process_entry and process_entrypoint. */

	dcl     dname		 char (168);
	dcl     ename		 char (32);
	dcl     bitcount		 fixed bin (24);
	dcl     fs_type		 fixed bin (2);
	dcl     fcb_ptr		 pointer;

	dcl     system_area_ptr	 pointer;
	dcl     system_area		 area based (system_area_ptr);

	dcl     first_entry		 fixed bin;
	dcl     n_entries		 fixed bin;
	dcl     entry_ptr		 pointer;
	dcl     1 entry		 (n_entries) based (entry_ptr),
		2 argno		 fixed bin,
		2 name		 char (36) varying,
		2 ep		 char (36) varying,
		2 non_star_lth	 fixed bin,
		2 include		 bit (1) aligned;

	dcl     n_parts		 fixed bin;
	dcl     1 part		 (64) aligned,	/* "parts" of the cref. Segments and last/first lines */
		2 ptr		 pointer,		/* pointer to beginning of this part */
		2 lth		 fixed bin (21),	/* length in characters */
		2 first		 fixed bin (30),	/* index (from char 1 of part 1) of first char in this part */
		2 last		 fixed bin (30),	/* index of last char in this part */
		2 allocated	 bit (1) aligned;	/* whether this part was allocated, and hence must be freed */

	dcl     active_fnc_err_	 entry options (variable);
	dcl     check_star_name_$entry entry (char (*), fixed bin (35));
	dcl     com_err_		 entry options (variable);
	dcl     cu_$af_return_arg	 entry (fixed bin, pointer, fixed bin (21), fixed bin (35));
	dcl     cu_$arg_list_ptr	 entry (pointer);
	dcl     cu_$arg_ptr_rel	 entry (fixed bin, pointer, fixed bin (21), fixed bin (35), pointer);
	dcl     expand_pathname_$add_suffix
				 entry (character (*), character (*), character (*), character (*),
				 fixed binary (35));
	dcl     get_system_free_area_	 entry () returns (pointer);
	dcl     hcs_$status_minf	 entry (char (*), char (*), fixed bin (1), fixed bin (2), fixed bin (24),
				 fixed bin (35));
	dcl     initiate_file_	 entry (character (*), character (*), bit (*), pointer, fixed binary (24),
				 fixed binary (35));
	dcl     terminate_file_	 entry (pointer, fixed binary (24), bit (*), fixed binary (35));
	dcl     pathname_		 entry (character (*), character (*)) returns (character (168));
	dcl     ioa_		 entry options (variable);
	dcl     ioa_$nnl		 entry options (variable);
	dcl     match_star_name_	 entry (char (*), char (*), fixed bin (35));
	dcl     msf_manager_$close	 entry (pointer);
	dcl     msf_manager_$get_ptr	 entry (pointer, fixed bin, bit (1) aligned, pointer, fixed bin (24),
				 fixed bin (35));
	dcl     msf_manager_$open	 entry (char (*), char (*), pointer, fixed bin (35));

	dcl     (
	        error_table_$badopt,
	        error_table_$dirseg,
	        error_table_$noarg,
	        error_table_$not_act_fnc,
	        error_table_$too_many_args
	        )			 fixed bin (35) external static;

	dcl     WHOAMI		 char (32) internal static options (constant) init ("peruse_crossref");
	dcl     DEFAULT_CREF_PATH	 char (168) init (">library_dir_dir>crossref>total.crossref") internal
				 static options (constant);
	dcl     SUFFIX		 char (8) init ("crossref") internal static options (constant);
	dcl     FIRST_CH		 char (63) aligned internal static options (constant)
				 init ("_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789");
	dcl     DASH		 char (1) aligned internal static options (constant) init ("-");
	dcl     SPACE		 char (1) aligned internal static options (constant) init (" ");
	dcl     TWO_SPACES		 char (2) aligned internal static options (constant) init ("  ");
	dcl     TAB		 char (1) aligned internal static options (constant) init ("	");
	dcl     TWO_TABS		 char (2) aligned internal static options (constant)
				 init ("		");
	dcl     NEWLINE		 char (1) aligned internal static options (constant) init ("
");
	dcl     WHITESPACE		 char (3) aligned internal static options (constant) init ("
	 ");					/* NEWLINE, TAB, SPACE */

	dcl     (
	        LESS		 init (1),
	        EQUAL		 init (2),
	        GREATER		 init (3)
	        )			 fixed bin internal static options (constant);

	dcl     (
	        EXACT		 init (1),
	        PARTIAL		 init (2),
	        MISS		 init (3)
	        )			 fixed bin internal static options (constant);

	dcl     (cleanup, logic_error) condition;

	dcl     (addr, after, before, bit, copy, divide, index, length, ltrim, maxlength, min, null, reverse, rtrim,
	        search, substr, unspec, verify)
				 builtin;

%page;
%include access_mode_values;
%page;
%include terminate_file;
%page;
	call cu_$af_return_arg (nargs, rs_ptr, rs_lth, code);

	if (code = 0)
	then do;
		complain = active_fnc_err_;
		return_string = "";
		active_function = "1"b;
	     end;
	else if (code = error_table_$not_act_fnc)
	then do;
		complain = com_err_;
		rs_ptr = null ();
		active_function = "0"b;
	     end;
	else do;
		call com_err_ (code, WHOAMI);
		return;
	     end;

	call cu_$arg_list_ptr (alp);

	system_area_ptr = get_system_free_area_ ();	/* sundry initializations, for cleanup etc. */
	n_parts = 0;
	part.ptr (1) = null ();
	first_entry = 0;
	n_entries = 0;
	dname = "";
	entry_ptr = null ();
	fcb_ptr = null ();

	on condition (cleanup) call clean_up ();

	if nargs < 1
	then do;
USAGE:
		call complain (error_table_$noarg, WHOAMI,
		     "^/Usage:^-^a {crossref_pathname} entrypoint_name(s) {-control_args}", WHOAMI);

MAIN_RETURN:
		call clean_up ();
		return;
	     end;

	call process_args ();

	if n_entries = 0
	then /* must have at least one entrypoint, natch */
	     goto USAGE;

	allocate entry in (system_area) set (entry_ptr);	/* allocate the info array */

	call check_entries ();

	call default_input_file ();

	call hcs_$status_minf (dname, ename, 1b /* chase */, fs_type, bitcount, code);
	if code ^= 0
	then do;
BAD_XREF:
		call complain (code, WHOAMI, "^a", pathname_ (dname, ename));
		goto MAIN_RETURN;
	     end;

	if fs_type = 1
	then /* segment */
	     call initiate_segment ();

	else do;					/* must be an MSF */
		if bitcount = 0
		then do;				/* but it's NOT */
			code = error_table_$dirseg;
			goto BAD_XREF;
		     end;

		call initiate_msf ();
	     end;

	if (debug & "1"b) ^= ""b
	then call print_parts ();

	if (debug & "01"b) = ""b
	then call print_matches ();

	return;
%page;
print_parts:
     proc ();

/* Debugging procedure to list parts of cref file */

	dcl     part_idx		 fixed bin;

	do part_idx = 1 to n_parts;
	     call ioa_ ("Part ^d: ^d chars @ ^p.", part_idx, part.lth (part_idx), part.ptr (part_idx));
	end;

	call ioa_ ("");

	return;
     end print_parts;


print_matches:
     proc ();

/* procedure to print matches found in cref. */

	dcl     line_start		 fixed bin (30);
	dcl     line_ptr		 pointer;
	dcl     line_lth		 fixed bin (21);
	dcl     line		 char (line_lth) based (line_ptr);

	dcl     match		 fixed bin;
	dcl     entry_idx		 fixed bin;
	dcl     search_name		 char (36) varying;
	dcl     exact		 bit (1) aligned;
	dcl     include		 bit (1) aligned;


	do entry_idx = 1 to n_entries;
	     search_name = substr (entry.name (entry_idx), 1, entry.non_star_lth (entry_idx));
	     exact = (length (search_name) = length (entry.name (entry_idx)));
	     include = entry.include (entry_idx);

	     call find_line (search_name, include, exact, line_ptr, line_start, line_lth, match);

	     if (debug & "001"b) ^= ""b
	     then call ioa_ ("^[Exact^;Partial^;No^] match for ""^a"" in ^d char line at char ^d (^p):^/^a", match,
		     entry.name (entry_idx), line_lth, line_start, line_ptr, line);

	     call process_entry (entry_idx, line_start, line_ptr, line_lth);
	end;

	return;
     end print_matches;
%page;
clean_up:
     proc ();

/* cleanup procedure */

	dcl     s1p		 pointer;
	dcl     s1l		 fixed bin (21);
	dcl     s1		 char (s1l) based (s1p);
	dcl     part_idx		 fixed bin;

	if entry_ptr ^= null ()
	then free entry in (system_area);

	if fcb_ptr = null ()
	then do;					/* not an MSF to close */
		if part.ptr (1) ^= null ()
		then /* but there is a segment */
		     call terminate_file_ (part.ptr (1), (0), TERM_FILE_TERM, (0));
	     end;

	else do;					/* otherwise, close the MSF */
		call msf_manager_$close (fcb_ptr);
		do part_idx = 2 to (n_parts - 1) by 2;	/* and free all the strings */
		     s1p = part.ptr (part_idx);
		     s1l = part.lth (part_idx);
		     if part.allocated (part_idx)
		     then free s1 in (system_area);
		end;
	     end;					/* of closing MSF */

	return;
     end clean_up;
%page;
process_args:
     proc ();

/* Simple procedure to process arguments */

	dcl     ap		 pointer;
	dcl     al		 fixed bin (21);
	dcl     arg		 char (al) based (ap);
	dcl     argno		 fixed bin;

	brief_sw, brief_error_sw = "0"b;
	debug = ""b;
	do argno = 1 to nargs;
	     call cu_$arg_ptr_rel (argno, ap, al, (0), alp);

	     if index (arg, "-") = 1
	     then if (^active_function) & ((arg = "-brief") | (arg = "-bf"))
		then brief_sw = "1"b;
		else if (^active_function) & ((arg = "-long") | (arg = "-lg"))
		then brief_sw = "0"b;
		else if arg = "-brief_errors" | arg = "-bfe"
		then brief_error_sw = "1"b;
		else if arg = "-debug" | arg = "-db"
		then do;
			if argno = nargs
			then do;
				call complain (error_table_$noarg, WHOAMI,
				     "^a must be followed by a debug bit mask.", arg);
				goto MAIN_RETURN;
			     end;
			argno = argno + 1;
			call cu_$arg_ptr_rel (argno, ap, al, (0), alp);
			debug = bit (arg, 3);
		     end;
		else if arg = "-long_errors" | arg = "-lgfe"
		then brief_error_sw = "0"b;
		else if (arg = "-pathname") | (arg = "-pn")
		then do;
			if argno = nargs
			then do;
				call complain (error_table_$noarg, WHOAMI,
				     "^a must be followed by a crossreference pathname.", arg);
				goto MAIN_RETURN;
			     end;
			argno = argno + 1;
			call cu_$arg_ptr_rel (argno, ap, al, (0), alp);
			goto PATHNAME;
		     end;

		else do;
			call complain (error_table_$badopt, WHOAMI, "^a", arg);
			goto MAIN_RETURN;
		     end;

	     else if search (arg, "<>") > 0
	     then
PATHNAME:
		do;				/* Looks Like a PATHNAME! */
		     if dname ^= ""			/* Two PATHNAMES? */
		     then do;
			     call complain (error_table_$too_many_args, WHOAMI,
				"Only one crossref pathname is allowed, but ^a appears to be a second pathname.",
				arg);
			     goto MAIN_RETURN;
			end;

		     call expand_pathname_$add_suffix (arg, SUFFIX, dname, ename, code);
		     if code ^= 0
		     then do;
			     call complain (code, WHOAMI, "^a", arg);
			     goto MAIN_RETURN;
			end;
		end;

	     else do;				/* A SEARCH NAME (a search name) */
		     if first_entry = 0
		     then first_entry = argno;
		     n_entries = n_entries + 1;	/* otherwise, remember that we've seen an entrypoint */
		end;

	end;					/* of loop through args */

	return;
     end process_args;
%page;
check_entries:
     proc ();

/* This procedure is used to extract and validate the arguments from the command line
   which specify things to be searched for. */

	dcl     ap		 pointer;
	dcl     al		 fixed bin (21);
	dcl     arg		 char (al) based (ap);
	dcl     argno		 fixed bin;

	dcl     name		 char (36) varying;
	dcl     ep		 char (36) varying;
	dcl     i1		 fixed bin;
	dcl     entry_idx		 fixed bin;

	entry_idx = 0;
	do argno = first_entry to nargs;
	     call cu_$arg_ptr_rel (argno, ap, al, (0), alp);

	     if index (arg, "-") ^= 1 & search (arg, "<>") = 0
	     then do;				/* thats us */
		     entry_idx = entry_idx + 1;	/* get to the next slot */
		     entry.argno (entry_idx) = argno;
		end;
	end;

	do entry_idx = 1 to n_entries;		/* validate the name portions */
	     ep = "";
	     call cu_$arg_ptr_rel (entry.argno (entry_idx), ap, al, (0), alp);

	     name = before (arg, "$");		/* split it in pieces */
	     ep = after (arg, "$");

	     if index (arg, ".incl") = 0
	     then entry.include (entry_idx) = "0"b;
	     else do;
		     entry.include (entry_idx) = "1"b;

		     if length (name) <= 25 & substr (reverse (name), 1, 5) = "lcni."
		     then name = name || ".*";

		     if ep ^= ""
		     then call bad_entry_format ("$ not allowed in include name.");
		end;

	     if length (name) > 32
	     then call bad_entry_format ("Segment name too long.");
	     if length (ep) > 256
	     then call bad_entry_format ("Entrypoint name too long.");

	     entry.name (entry_idx) = name;
	     entry.ep (entry_idx) = ep;

	     call check_star_name_$entry ((name), code);
	     if code > 2
	     then call bad_entry_format ("Invalid star name.");
	     else if code = 2
	     then call bad_entry_format ("Double star not allowed in segment name.");
	     else if code = 1
	     then do;				/* special stuff for hacking star names */
		     i1 = search (name, "*?");	/* find first star-like char -- there is guaranteed to be one */
		     if i1 = 1
		     then /* too complicated to implement this time */
			call bad_entry_format ("Star names may not begin with star.");
		     entry.non_star_lth (entry_idx) = i1 - 1;
						/* length of non-starred portion */
		end;
	     else entry.non_star_lth (entry_idx) = length (name);
						/* otherwise, is whole thing */

	     if length (ep) > 0
	     then do;				/* validate entrypoint name, too */
		     call check_star_name_$entry ((ep), code);
		     if code > 2
		     then call bad_entry_format ("Invalid star name.");
		end;
	end;					/* of validation loop */

	return;					/* end of main code of check_entries */
%page;
bad_entry_format:
     proc (P_message);

	dcl     P_message		 char (*) parameter;

	call cu_$arg_ptr_rel (entry.argno (entry_idx), ap, al, (0), alp);

	call complain (0, WHOAMI, "Invalid search name ^a. ^a", arg, P_message);
	goto MAIN_RETURN;

     end bad_entry_format;

     end check_entries;
%page;
initiate_segment:
     proc ();

/* This procedure is used to initiate a single segment if the xref is not an MSF;
   it creates, effectively, information about a one component MSF. */

	unspec (part (1)) = ""b;

	call initiate_file_ (dname, ename, R_ACCESS, part.ptr (1), bitcount, code);
	if code ^= 0
	then goto BAD_XREF;

	n_parts = 1;

	part.lth (1) = divide (bitcount, 9, 21, 0);
	part.first (1) = 1;				/* first and only component */
	part.last (1) = part.lth (1);			/* last char */
	part.allocated (1) = "0"b;			/* should be terminated, not freed */

	return;
     end initiate_segment;
%page;
initiate_msf:
     proc ();

/* This procedure is used to initiate all the components of an MSF, and then create
   extra "lines" between each component which contain all the characters after (but not
   including) the last newline in component N, followed by all the characters up to and
   including the first newline in component N+1. The starting addresses and lengths of
   each component are then updated appropriately to compensate for the characters
   thus extracted. */

	dcl     (s1p, s2p, s3p)	 pointer;		/* assorted based strings */
	dcl     (s1l, s2l, s3l)	 fixed bin (21);
	dcl     s1		 char (s1l) based (s1p);
	dcl     s2		 char (s2l) based (s2p);
	dcl     s3		 char (s3l) based (s3p);

	dcl     (i1, i2)		 fixed bin (30);
	dcl     part_idx		 fixed bin;
	dcl     component_idx	 fixed bin;


	call msf_manager_$open (dname, ename, fcb_ptr, code);
	if (fcb_ptr = null ()) | (code ^= 0)
	then goto BAD_XREF;

	part_idx = 1;				/* incremented by two each time through */
	do component_idx = 0 by 1;
	     unspec (part (part_idx)) = ""b;		/* initialize */
	     unspec (part (part_idx + 1)) = ""b;
	     part.ptr (part_idx + 1) = null ();

	     call msf_manager_$get_ptr (fcb_ptr, component_idx, "0"b, part.ptr (part_idx), bitcount, code);
	     if part.ptr (part_idx) = null ()
	     then /* last one, probably */
		goto MSF_INITIATED;

	     part.lth (part_idx) = divide (bitcount, 9, 21, 0);
	     n_parts = part_idx;
	     part_idx = part_idx + 2;
	end;

MSF_INITIATED:
	do part_idx = 1 to (n_parts - 2) by 2;		/* now, combine the end and beginning of each segment */
	     s1p = part.ptr (part_idx);		/* into a bare line, so that each part contains only */
	     s1l = part.lth (part_idx);		/* integral lines */
	     i1 = length (s1) - index (reverse (s1), NEWLINE) + 2;
						/* first char after last newline */

	     s2p = part.ptr (part_idx + 2);		/* next segment */
	     s2l = part.lth (part_idx + 2);
	     i2 = index (s2, NEWLINE);		/* first newline */

	     s3l = length (substr (s1, i1)) + length (substr (s2, 1, i2));
						/* length of string to be allocated */
	     allocate s3 in (system_area) set (s3p);	/* -- sum of lengths of line parts */

	     substr (s3, 1, length (substr (s1, i1))) = substr (s1, i1);
						/* and copy in the two pieces */
	     substr (s3, 1 + length (substr (s1, i1))) = substr (s2, 1, i2);

	     part.lth (part_idx) = part.lth (part_idx) - length (substr (s1, i1));
						/* shorten it by amount removed */

	     part.ptr (part_idx + 1) = addr (substr (s3, 1, 1));
						/* remember location of line */
	     part.lth (part_idx + 1) = length (s3);
	     part.allocated (part_idx + 1) = "1"b;

	     part.ptr (part_idx + 2) = addr (substr (s2, i2 + 1));
						/* move the beginning up */
	     part.lth (part_idx + 2) = length (substr (s2, i2 + 1));
						/* and shorten it */
	end;

	part.first (1) = 1;				/* first char of part 1 is 1 */
	do part_idx = 1 to n_parts - 1;		/* now, set the "first" char of each */
	     part.first (part_idx + 1) = part.first (part_idx) + part.lth (part_idx);
	end;

	do part_idx = 1 to n_parts;			/* now set part.last for all the parts */
	     part.last (part_idx) = part.first (part_idx) + part.lth (part_idx) - 1;
	end;

	return;
     end initiate_msf;
%page;
locate_char:
     proc (P_idx, P_part_idx, P_part_offset);

/* This procedure takes a character index (as counted from character one of
   part one) and returns the index of the part which contains it and
   an index into that part. */

	dcl     (
	        P_idx		 fixed bin (30),
	        P_part_idx		 fixed bin,
	        P_part_offset	 fixed bin (21)
	        )			 parameter;

	dcl     idx		 fixed bin;

	do idx = 1 to n_parts;
	     if P_idx >= part.first (idx)
	     then if P_idx <= part.last (idx)
		then do;				/* found it */
			P_part_idx = idx;
			P_part_offset = P_idx - part.first (idx) + 1;
			return;
		     end;
	end;					/* of loop through parts */

	P_part_idx = -1;				/* force a fault if we fall through */
	P_part_offset = -1;

	return;
     end locate_char;
%page;
/* This procedure locates the beginning and end of the text line containing the
   referenced character, and returns a pointer to its first character and the length
   of the line. The line contains a trailing newline, unless the last line of the
   crossreference lacks one and is returned. */

locate_line:
     proc (P_idx, P_line_ptr, P_line_start, P_line_lth);

	dcl     (
	        P_idx		 fixed bin (30),
	        P_line_ptr		 pointer,
	        P_line_start	 fixed bin (30),
	        P_line_lth		 fixed bin (21)
	        )			 parameter;

	dcl     part_ptr		 pointer;
	dcl     part_lth		 fixed bin (21);
	dcl     part		 char (part_lth) based (part_ptr);
	dcl     part_idx		 fixed bin;
	dcl     char_idx		 fixed bin (21);
	dcl     first		 fixed bin (21);
	dcl     lth		 fixed bin (21);

	call locate_char (P_idx, part_idx, char_idx);

	part_ptr = part.ptr (part_idx);
	part_lth = part.lth (part_idx);

	first = index (reverse (substr (part, 1, char_idx)), NEWLINE);
	if first = 0
	then /* no previous newline, start at char 1 */
	     first = 1;
	else first = char_idx - first + 2;

	lth = index (substr (part, first), NEWLINE);
	if lth = 0
	then /* no trailing newline */
	     P_line_lth = length (substr (part, first));
	else P_line_lth = lth;			/* otherwise, include the newline */

	P_line_start = part.first (part_idx) + first - 1; /* the index of the first char */
	P_line_ptr = addr (substr (part, first, 1));

	return;
     end locate_line;
%page;
next_line:
     proc (P_old_line_start, P_old_line_lth, P_new_line_ptr, P_new_line_start, P_new_line_lth);

/* This procedure takes the index of the first character in a line, and returns pointer, start,
   and length for the next line in the file, or a null pointer if there is none. */

	dcl     (
	        P_old_line_start	 fixed bin (30),
	        P_old_line_lth	 fixed bin (21),
	        P_new_line_ptr	 pointer,
	        P_new_line_start	 fixed bin (30),
	        P_new_line_lth	 fixed bin (21)
	        )			 parameter;

	dcl     part_ptr		 pointer;
	dcl     part_lth		 fixed bin (21);
	dcl     part		 char (part_lth) based (part_ptr);
	dcl     part_idx		 fixed bin;
	dcl     char_idx		 fixed bin (21);
	dcl     lth		 fixed bin (21);


	call locate_char (P_old_line_start + P_old_line_lth, part_idx, char_idx);
	if part_idx < 0
	then goto NO_APPROPRIATE_LINE;

	part_ptr = part.ptr (part_idx);
	part_lth = part.lth (part_idx);

	lth = index (substr (part, char_idx), NEWLINE);
	if lth = 0
	then /* no trailing newline */
	     P_new_line_lth = length (substr (part, char_idx));
	else P_new_line_lth = lth;			/* otherwise, include the newline */

	goto RETURN_INDICES;


prev_line:
     entry (P_old_line_start, P_old_line_lth, P_new_line_ptr, P_new_line_start, P_new_line_lth);

	if P_old_line_start - 1 <= 0
	then goto NO_APPROPRIATE_LINE;

	call locate_line (P_old_line_start - 2, P_new_line_ptr, P_new_line_start, P_new_line_lth);

	if "1"b
	then return;

	call locate_char (P_old_line_start - 2, part_idx, char_idx);
	if part_idx < 0
	then goto NO_APPROPRIATE_LINE;

	part_ptr = part.ptr (part_idx);
	part_lth = part.lth (part_idx);

	lth = index (reverse (substr (part, 1, char_idx)), NEWLINE) + 1;
	if lth = 1
	then lth = char_idx + 1;
	else char_idx = char_idx - lth + 3;

	P_new_line_lth = lth;
	goto RETURN_INDICES;


RETURN_INDICES:
	P_new_line_start = part.first (part_idx) + char_idx - 1;
						/* the index of the first char */
	P_new_line_ptr = addr (substr (part, char_idx, 1));

	return;


NO_APPROPRIATE_LINE:
	P_new_line_ptr = null ();
	P_new_line_start = -1;
	P_new_line_lth = -1;
	return;

     end next_line;
%page;
/* This procedure finds the line which either starts with P_string, or the first
   line after that in collating sequence. Collating sequence is strictly ASCII,
   except that anything containing the string ".incl." collates after anything
   that doesn't. The finding is done by binary search. */

find_line:
     proc (P_string, P_include, P_exact, P_line_ptr, P_line_start, P_line_lth, P_matched);

	dcl     (
	        P_string		 char (36) varying,
	        P_include		 bit (1) aligned,
	        P_exact		 bit (1) aligned,
	        P_line_start	 fixed bin (30),
	        P_line_ptr		 pointer,
	        P_line_lth		 fixed bin (21),
	        P_matched		 fixed bin
	        )			 parameter;

	dcl     include		 bit (1) aligned;	/* whether P_string contains ".incl." */
	dcl     str_lth		 fixed bin;
	dcl     backward		 bit (1) aligned;	/* which direction are we scanning */

	dcl     (lb, ub)		 fixed bin (30);	/* bounds for binary search */
	dcl     try		 fixed bin (30);

	dcl     (line_start, try_line_start)
				 fixed bin (30);	/* line we work with */
	dcl     (line_ptr, try_line_ptr)
				 pointer;
	dcl     (line_lth, try_line_lth)
				 fixed bin (21);
	dcl     line		 char (line_lth) based (line_ptr);

	dcl     continue		 bit (1) aligned;
	dcl     comparison		 fixed bin;
	dcl     matched		 fixed bin;

	dcl     last_char		 fixed bin (30);
	dcl     first_char		 fixed bin (30);
%page;
	include = P_include;
	str_lth = length (P_string);

	lb = 1;
	ub = part.last (n_parts);

ITERATE:
	try = divide ((lb + ub), 2, 30, 0);		/* beginning of loop -- see goto at bottom of procedure */

	call locate_line (try, line_ptr, line_start, line_lth);

	try_line_ptr = line_ptr;			/* remember info about this line, in case we must search back */
	try_line_start = line_start;
	try_line_lth = line_lth;

	do while (index (FIRST_CH, substr (line, 1, 1)) = 0);
						/* stop looping at the first non-whitespace */
	     call next_line (line_start, line_lth, line_ptr, line_start, line_lth);
	     if line_ptr = null ()
	     then /* last line */
		goto LOOK_BACK_INSTEAD;
	end;					/* of finding next line with a name on it */

	call compare_line (line, P_string, include, comparison, matched);

	if comparison = EQUAL
	then /* strings are more or less equal. Finish and return */
	     goto EQUAL_MATCH;

	last_char = line_start + line_lth - 1;		/* last char we have "looked" at */

	if comparison = LESS
	then do;					/* if LESS, then search backwards to the previous one */
LOOK_BACK_INSTEAD:
		line_ptr = try_line_ptr;		/* start from the line we ended up trying */
		line_start = try_line_start;
		line_lth = try_line_lth;

		continue = "1"b;
		do while (continue);		/* look at prev line, stop when we hit a good one */
		     call prev_line (line_start, line_lth, line_ptr, line_start, line_lth);
		     if line_ptr = null ()
		     then /* first line */
			goto FINISH_AND_RETURN;

		     if index (FIRST_CH, substr (line, 1, 1)) ^= 0
		     then continue = "0"b;		/* stop looping at the first non-whitespace */
		end;				/* of finding next line with a name on it */

		call compare_line (line, P_string, include, comparison, matched);
						/* see what this line looks like */

		if comparison = EQUAL
		then goto EQUAL_MATCH;

		first_char = line_start;		/* remember the index of the first char we look at */
	     end;					/* of marching backward for "prev" comparison */

	else first_char = try_line_start;		/* remember where we started looking */

	if comparison = LESS
	then /* reset the bounds */
	     ub = first_char;
	else lb = last_char;

	if lb <= ub
	then /* go around and try again */
	     goto ITERATE;				/* Yes, I know it's an evil way to loop, but I think */
	else goto FINISH_AND_RETURN;			/* it's actually somewhat clearer this way than it */
						/* would have been with a do while loop */

EQUAL_MATCH:
	if "1"b
	then do;					/* always scan backwards, just for laughs */
		backward = "1"b;
		continue = "1"b;

EQUAL_MATCH_RESTART:
		do while (continue);
		     if backward
		     then call prev_line (line_start, line_lth, line_ptr, line_start, line_lth);
		     else call next_line (line_start, line_lth, line_ptr, line_start, line_lth);
		     if line_ptr = null ()
		     then if ^backward
			then signal condition (logic_error);
			else do;
				backward = "0"b;
				goto EQUAL_MATCH_RESTART;
			     end;

		     if index (FIRST_CH, substr (line, 1, 1)) ^= 0
		     then do;			/* see if this is a match */
			     call compare_line (line, P_string, include, comparison, matched);
			     if comparison ^= EQUAL
			     then do;		/* stop scan in this direction */
				     if backward
				     then backward = "0"b;
				     else if comparison = LESS
				     then goto FINISH_AND_RETURN;
				end;
			     else if ^backward
			     then /* really set, now */
				if ^P_exact | (matched = EXACT)
				then continue = "0"b;
			end;

		end;				/* of loop to find previous exact match */
	     end;

FINISH_AND_RETURN:
	P_line_ptr = line_ptr;
	P_line_start = line_start;
	P_line_lth = line_lth;
	P_matched = matched;

	return;
     end find_line;
%page;
/* This procedure compares P_string to the first token on P_line, setting P_comparison
   and P_matching appropriately. It is used to determine what direction to search in next,
   and also when to stop looping through lines. This is the procedure where the knowledge
   of the special effects of ".incl." on the collating sequence is embodied. */

compare_line:
     proc (P_line, P_string, P_include, P_comparison, P_matching);

	dcl     (
	        P_line		 char (*),
	        P_string		 char (36) varying,
	        P_include		 bit (1) aligned,
	        P_comparison	 fixed bin,
	        P_matching		 fixed bin
	        )			 parameter;

	dcl     token_lth		 fixed bin;
	dcl     token_ptr		 pointer;
	dcl     token		 char (token_lth) based (token_ptr);

	dcl     test_lth		 fixed bin;

	token_lth = search (P_line, WHITESPACE) - 1;	/* find the first token on the line */
	token_ptr = addr (substr (P_line, 1, 1));
	if token_lth < 0
	then /* no trailing delimiter */
	     token_lth = length (P_line);

	P_matching = MISS;				/* likely this is the case; only set it otherwise if not */

	if index (token, ".incl.") ^= 0
	then do;					/* we have hit an include file line */
		if ^P_include
		then do;				/* but we are not searching for one, so punt */
			P_comparison = LESS;
			return;
		     end;
	     end;

	else if substr (token, token_lth, 1) = ":"
	then do;
		P_comparison = LESS;		/* nasty error message at end of file */
		return;
	     end;

	else do;					/* otherwise, check the opposite */
		if P_include
		then do;				/* include file always after than non-include */
			P_comparison = GREATER;
			return;
		     end;
	     end;

	test_lth = min (length (token), length (P_string));

	if substr (P_string, 1, test_lth) > substr (token, 1, test_lth)
	then P_comparison = GREATER;

	else if substr (P_string, 1, test_lth) < substr (token, 1, test_lth)
	then P_comparison = LESS;

	else if token_lth < length (P_string)
	then /* short token is always greater than string */
	     P_comparison = GREATER;

	else do;					/* they compare equal */
		if length (token) = length (P_string)
		then /* if strings are identical */
		     P_matching = EXACT;
		else P_matching = PARTIAL;

		P_comparison = EQUAL;
	     end;

	return;
     end compare_line;
%page;
/* This procedure prints out formatted information for a single entry. It is given the
   location of the line containins the first reference to the entry. */

process_entry:
     proc (P_entry_idx, P_line_start, P_line_ptr, P_line_lth);

	dcl     (
	        P_entry_idx		 fixed bin,
	        P_line_start	 fixed bin (30),
	        P_line_ptr		 pointer,
	        P_line_lth		 fixed bin (21)
	        )			 parameter;

	dcl     line_start		 fixed bin (30);
	dcl     line_ptr		 pointer;
	dcl     line_lth		 fixed bin (21);
	dcl     line		 char (line_lth) based (line_ptr);

	dcl     name_starname	 char (32);
	dcl     ep_starname		 char (32);
	dcl     name		 char (36) varying;
	dcl     ep		 char (36) varying;

	dcl     n_entrypoints	 fixed bin (17);
	dcl     header_bumf		 char (64) varying;
	dcl     out_str		 char (1000) varying;
	dcl     include		 bit (1) aligned;
	dcl     comparison		 fixed bin (17);
	dcl     matched		 fixed bin (17);
	dcl     ep_scanning		 bit (1) aligned;
	dcl     exact_match		 bit (1) aligned;
	dcl     i1		 fixed bin (21);
	dcl     seg_name		 char (32);
	dcl     synonym		 bit (1) aligned;
	dcl     processing_synonym	 bit (1) aligned;
	dcl     syn_name		 char (32);
	dcl     saved_line_start	 fixed bin (30);
	dcl     saved_line_lth	 fixed bin (21);
	dcl     match		 fixed bin (17);
	dcl     len		 fixed bin (21);
	dcl     pos		 fixed bin (21);


	line_start = P_line_start;
	line_ptr = P_line_ptr;
	line_lth = P_line_lth;

	n_entrypoints = 0;
	out_str = "";
	header_bumf = "FOO!";
	processing_synonym = "0"b;

	name = substr (entry.name (P_entry_idx), 1, entry.non_star_lth (P_entry_idx));
	name_starname = entry.name (P_entry_idx);
	exact_match = (length (name) = length (entry.name (P_entry_idx)));
	include = entry.include (P_entry_idx);
	ep, ep_starname = entry.ep (P_entry_idx);

/* set up to read the ----- bumf line */

TRY_SYNONYM:
	call prev_line (line_start, line_lth, line_ptr, line_start, line_lth);
	ep_scanning = "0"b;				/* no call to look at entrypoint lines yet */

	do while (line_ptr ^= null ());		/* loop through the lines, looking for things to print */

	     if index (FIRST_CH, substr (line, 1, 1)) ^= 0
	     then do;				/* extract segment name */
		     call compare_line (line, name, include, comparison, matched);
						/* is this line interesting? */
		     if comparison ^= EQUAL
		     then /* no longer equal */
			goto FINISHED;		/* the first of these comparisons will always be spurious */
		     else if (matched ^= EXACT) & exact_match
		     then /* we've run out of candidates, even */
			goto FINISHED;

		     ep_scanning, questionable_module, synonym = "0"b;
		     i1 = search (line, WHITESPACE);
		     if i1 = 0
		     then seg_name = line;
		     else do;
			     seg_name = substr (line, 1, i1 - 1);
			     if index (substr (line, i1 + 1), "(?)") ^= 0
			     then questionable_module = "1"b;
			     else if index (substr (line, i1 + 1), "SEE:") ^= 0
			     then synonym = "1"b;
			end;

		     if ^exact_match
		     then do;
			     call match_star_name_ (seg_name, name_starname, code);
			     if code ^= 0
			     then goto NEXT_LINE;	/* it doesn't match -- ignore it */
			end;

		     if include
		     then call process_include ();	/* well, is it ? */
		     else if synonym
		     then do;
			     if processing_synonym
			     then do;
				     call complain (0, WHOAMI, "Nested synonym ^a.", name);
				     goto MAIN_RETURN;
				end;
			     saved_line_start = line_start;
			     saved_line_lth = line_lth;
			     syn_name = seg_name;
			     name, name_starname =
				ltrim (rtrim (after (substr (line, i1 + 1), ":"), WHITESPACE), WHITESPACE);
			     call find_line (name, "0"b, "1"b, line_ptr, line_start, line_lth, match);
			     if (debug & "001"b) ^= ""b
			     then call ioa_ ("^[Exact^;Partial^;No^] match for synonym ^a line[^d,^d]@^p:^/^a",
				     match, name, line_start, line_lth, line_ptr, line);
			     exact_match, processing_synonym = "1"b;
			     goto TRY_SYNONYM;
			end;
		     else do;
			     if processing_synonym
			     then seg_name = syn_name;
			     ep_scanning = "1"b;
NEXT_LINE:
			     call next_line (line_start, line_lth, line_ptr, line_start, line_lth);
			end;			/* skip the segname line */
		end;

	     else if ep_scanning & substr (line, 1, 1) = SPACE
	     then do;				/* see if it's an entrypoint name */
		     if index (FIRST_CH, substr (line, 2, 1)) ^= 0
		     then call process_entrypoint ();
		     else call next_line (line_start, line_lth, line_ptr, line_start, line_lth);
		end;

	     else do;
		     if ^include & (substr (line, 1, 1) = DASH)
		     then do;			/* must be dat ole debbil --- bumf line */
			     pos = index (line, "***** ") + 6;
			     if pos > 6
			     then do;
				     len = index (substr (line, pos), " *****") - 1;
				     if len > 0 then header_bumf = substr (line, pos, len);
				end;
			end;
		     call next_line (line_start, line_lth, line_ptr, line_start, line_lth);
		end;
	end;					/* otherwise, just skip it */

FINISHED:
	if processing_synonym
	then do;
		processing_synonym = "0"b;
		name = substr (entry.name (P_entry_idx), 1, entry.non_star_lth (P_entry_idx));
		name_starname = entry.name (P_entry_idx);
		exact_match = (length (name) = length (entry.name (P_entry_idx)));
		line_start = saved_line_start;
		line_lth = saved_line_lth;
		goto NEXT_LINE;
	     end;

	if n_entrypoints = 0			/* found nothing there */
	then if ^brief_error_sw
	     then call complain (0, WHOAMI, "Not found: ^a^[$^a^]^/", name_starname, (ep_starname ^= ""), ep_starname);
	     else ;
	else if ^active_function
	then call ioa_$nnl ("^a", out_str);		/* all done */

	return;					/* end of code for process_entry */
%page;
process_entrypoint:
     proc ();

/* This procedure (internal to process_entry) collects information about a single entrypoint. */

	dcl     (idx, jdx)		 fixed bin (21);
	dcl     ep_name		 char (32);
	dcl     caller_name		 char (32) varying;

	dcl     first_on_line	 bit (1) aligned;
	dcl     questionable_entry	 bit (1) aligned;
	dcl     header_output	 bit (1) aligned;
	dcl     obj_name		 char (72) varying;
	dcl     line_size		 fixed bin (17);
	dcl     MAX_LINE_SIZE	 fixed bin internal static options (constant) init (72);


	idx = search (substr (line, 2), WHITESPACE);
	ep_name = substr (line, 2, idx - 1);		/* extract the entrypoint name */
	idx = 1 + idx;

	if ep_starname ^= ""
	then do;					/* see if we should print this one */
		call match_star_name_ ((ep_name), ep_starname, code);
		if code ^= 0
		then do;				/* it doesn't match -- ignore it */
			call next_line (line_start, line_lth, line_ptr, line_start, line_lth);
			return;			/* get to the beginning of the next line */
		     end;				/* and return to let it get inspected */
	     end;

	questionable_entry = "0"b;
	jdx = index (substr (line, idx), "(?)");
	if jdx > 0
	then do;
		idx = idx + jdx + 3;
		questionable_entry = ^questionable_module;
	     end;

	n_entrypoints = n_entrypoints + 1;

	if (ep_name = seg_name)
	then /* figure out what to call this */
	     obj_name = rtrim (seg_name);
	else if (ep_name = "")
	then obj_name = rtrim (seg_name) || "$";
	else obj_name = rtrim (seg_name) || "$" || rtrim (ep_name);

	line_size = MAX_LINE_SIZE + 1;		/* force "overflow" for first time through */
	header_output = "0"b;			/* whether we've commented on this entry yet */

GET_NEXT_TOKEN:
	if ^active_function
	then /* If we're gonna be printing this, see if it's too big */
	     if (length (out_str) + 200 > maxlength (out_str))
	     then do;				/* time to flush the buffer */
		     call ioa_$nnl ("^a", out_str);
		     out_str = "";
		end;

	if idx >= line_lth
	then do;					/* get the next line */
GET_TO_NEXT_LINE:
		call next_line (line_start, line_lth, line_ptr, line_start, line_lth);

		if (substr (line, 1, min (2, length (line))) ^= TWO_SPACES) & (substr (line, 1, 1) ^= TAB)
		then do;
			if active_function
			then return;		/* Not gonna say anything */

			if ^header_output
			then do;			/* whether we have said anything about this entry */
				if brief_sw
				then return;
				out_str = out_str || "No references to ";
				out_str = out_str || obj_name;
				out_str = out_str || " (";
				out_str = out_str || header_bumf;
				out_str = out_str || ")";
			     end;

			out_str = out_str || NEWLINE; /* finish it with two newlines */
			out_str = out_str || NEWLINE; /* watch cretinous pl1 concatenation implementation */
			return;			/* and return for the next entrypoint */
		     end;

		idx = 1;				/* start at the beginning */
	     end;

	jdx = verify (substr (line, idx), WHITESPACE);
	if jdx = 0
	then goto GET_TO_NEXT_LINE;

	idx = idx + jdx - 1;			/* first non-white char */
	jdx = search (substr (line, idx), WHITESPACE) - 1;
	if jdx < 0
	then jdx = length (substr (line, idx));

	caller_name = substr (line, idx, jdx);

	if active_function
	then do;					/* Just add to the return string, and go back for more */
		if length (return_string) > 0
		then return_string = return_string || " ";
		return_string = return_string || caller_name;
		idx = idx + jdx;
		goto GET_NEXT_TOKEN;
	     end;

	if line_size + 2 + length (caller_name) > MAX_LINE_SIZE
	then do;
		if ^header_output
		then do;
			out_str = out_str || "References to ";
			out_str = out_str || obj_name;
			out_str = out_str || ":  (";
			out_str = out_str || header_bumf;
			out_str = out_str || ")";
			if questionable_entry
			then out_str = out_str || " ** Not Found **";
			out_str = out_str || NEWLINE;
			out_str = out_str || copy (SPACE, 4);

			header_output = "1"b;
		     end;

		else do;
			out_str = out_str || ",";
			out_str = out_str || NEWLINE;
			out_str = out_str || copy (SPACE, 4);
		     end;

		line_size = 4;
	     end;

	else if ^first_on_line
	then do;
		out_str = out_str || ", ";
		line_size = line_size + 2;
	     end;

	out_str = out_str || caller_name;
	line_size = line_size + length (caller_name);
	first_on_line = "0"b;

	idx = idx + jdx;				/* get on to next token */
	goto GET_NEXT_TOKEN;

     end process_entrypoint;
%page;
process_include:
     proc ();

/* This procedure (internal to process_entry) collects information about a single include file. */

	dcl     (idx, jdx)		 fixed bin (21);
	dcl     caller_name		 char (32) varying;
	dcl     first_on_line	 bit (1) aligned;
	dcl     header_output	 bit (1) aligned;
	dcl     incl_name		 char (32) varying;
	dcl     incl_dtcm		 char (40) varying;
	dcl     line_size		 fixed bin (17);
	dcl     MAX_LINE_SIZE	 fixed bin internal static options (constant) init (72);


	n_entrypoints = n_entrypoints + 1;
	incl_name = rtrim (seg_name);

	if index (line, "*****") = 0
	then call next_line (line_start, line_lth, line_ptr, line_start, line_lth);

	incl_dtcm = substr (line, index (line, "***** ") + 6);
	incl_dtcm = substr (incl_dtcm, 1, length (incl_dtcm) - 7);

	idx = line_lth;				/* force next_line */
	line_size = MAX_LINE_SIZE + 1;		/* force "overflow" for first time through */
	header_output = "0"b;			/* whether we've commented on this entry yet */

GET_NEXT_TOKEN:
	if ^active_function
	then /* If we're gonna be printing this, see if it's too big */
	     if (length (out_str) + 200 > maxlength (out_str))
	     then do;				/* time to flush the buffer */
		     call ioa_$nnl ("^a", out_str);
		     out_str = "";
		end;

	if idx >= line_lth
	then do;					/* get the next line */
GET_TO_NEXT_LINE:
		call next_line (line_start, line_lth, line_ptr, line_start, line_lth);

		if (substr (line, 1, 2) ^= TWO_TABS)
		then if header_output
		     then do;			/* whether we have said anything about this include incarnation */
			     if active_function
			     then return;		/* Not gonna say anything */

			     out_str = out_str || NEWLINE;
						/* add one newline for now */
			     out_str = out_str || NEWLINE;
						/* and another for later */
			     return;		/* and return for the next entrypoint */
			end;

		idx = 1;				/* start at the beginning */
	     end;

	jdx = verify (substr (line, idx), WHITESPACE);
	if jdx = 0
	then goto GET_TO_NEXT_LINE;

	idx = idx + jdx - 1;			/* first non-white char */
	jdx = search (substr (line, idx), WHITESPACE) - 1;
	if jdx < 0
	then jdx = length (substr (line, idx));

	caller_name = substr (line, idx, jdx);

	if active_function
	then do;					/* Just add to the return string, and go back for more */
		if length (return_string) > 0
		then return_string = return_string || " ";
		return_string = return_string || caller_name;
		idx = idx + jdx;
		header_output = "1"b;		/* Force above logic to terminate properly */
		goto GET_NEXT_TOKEN;
	     end;

	if line_size + 2 + length (caller_name) > MAX_LINE_SIZE
	then do;
		if ^header_output
		then do;
			out_str = out_str || "References to ";
			out_str = out_str || incl_name;
			out_str = out_str || ":  (";
			out_str = out_str || incl_dtcm;
			out_str = out_str || ")";
			out_str = out_str || NEWLINE;
			out_str = out_str || copy (SPACE, 4);

			header_output = "1"b;
		     end;

		else do;
			out_str = out_str || ",";
			out_str = out_str || NEWLINE;
			out_str = out_str || copy (SPACE, 4);
		     end;

		line_size = 4;
	     end;

	else if ^first_on_line
	then do;
		out_str = out_str || ", ";
		line_size = line_size + 2;
	     end;

	out_str = out_str || caller_name;
	line_size = line_size + length (caller_name);
	first_on_line = "0"b;

	idx = idx + jdx;				/* get on to next token */
	goto GET_NEXT_TOKEN;

     end process_include;

     end process_entry;
%page;
default_input_file:
     procedure;

	if dname ^= ""
	then return;
	ename = "";

	call expand_pathname_$add_suffix (DEFAULT_CREF_PATH, SUFFIX, dname, ename, code);
	if code ^= 0
	then do;
		call complain (code, WHOAMI, "Bad default path ^a.", DEFAULT_CREF_PATH);
		goto MAIN_RETURN;
	     end;

     end default_input_file;

     end peruse_crossref;
