/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        *                                                         *
        *********************************************************** */

/* format: style2,indcomtxt */
msl:
monitor_sys_log:
     procedure () options (variable);

/**** Modification History:
      Created 1984-11-29 BIM from print_sys_log.
      Modified 1984-12-26, BIM: Added -continuation_indent.
      Modified 1985-01-16, BIM: Added -match/exclude/all_data_class, -pid, -data_class.
      Modified 1985-01-25, BIM: fixed dm log name, other silly bugs.
      Modified 1985-02-07, Steve Herbst: Changed to call dm_misc_util_$get_log_path.
      Modified 1985-02-21, Steve Herbst: Fixed bug in -dms  */



/****^  HISTORY COMMENTS:
  1) change(86-04-29,Kissel), approve(86-07-31,MCR7456), audit(86-08-01,Wong),
     install(86-11-03,MR12.0-1149):
     Changed to support the DSA system logs using the -dsasl and -dsasal
     control arguments.
                                                   END HISTORY COMMENTS */


	declare an_entry_ptr	 pointer;
	declare 1 an_entry		 aligned like monitor_sys_log_array.entry based (an_entry_ptr);
	declare code		 fixed bin (35);
	declare dm_system_log_path	 char (168);
	declare dsa_system_log_path	 char (168);
	declare log_index		 fixed bin;
	declare log_dname		 char (168);
	declare log_ename		 char (32);
	declare 1 log_open_info	 aligned like log_read_open_info;
	declare sci_ptr		 pointer;
	declare old_mask		 bit (36) aligned;
	declare 1 opt1		 like opt based;	/* To catch unqualified references */

	declare 1 opt		 automatic aligned, /* Miscellaneous options for the command itself; */
		2 pathname	 char (168) unal,	/* note that formatting options are kept separately */
		2 pointers,			/* in the log_message_format structure */
		  3 log_read_ptr	 pointer,
		  3 expand_select_ptr
				 pointer,
		  3 lmd_ptr	 pointer,
		  3 iocb_ptr	 pointer,
		2 reader_procedure	 char (32) varying,
		2 iocb_name	 char (32) unaligned,
		2 call_command	 aligned,
		  3 ptr		 pointer,
		  3 length	 fixed bin (21),
		2 time		 fixed bin (71),
		2 log_number	 fixed bin,
		2 flags		 aligned,
		  3 the_syserr_log_sw
				 bit (1),
		  3 the_as_log_sw	 bit (1),
		  3 the_admin_log_sw bit (1),
		  3 the_dm_log_sw	 bit (1),
		  3 the_dsas_log_sw	 bit (1),
		  3 the_dsasa_log_sw bit (1),
		  3 all_sw	 bit (1),
		  3 expand_sw	 bit (1),
		  3 octal_sw	 bit (1),
		  3 interpret_sw	 bit (1),
		  3 add_sw	 bit (1),
		  3 remove_sw	 bit (1),
		  3 on_sw		 bit (1),
		  3 off_sw	 bit (1),
		  3 status_sw	 bit (1),
		  3 replace_sw	 bit (1),
		  3 modify_sw	 bit (1),
		  3 time_given_sw	 bit (1),
		  3 prefix_given_sw	 bit (1),
		  3 call_given_sw	 bit (1),
		  3 free_from_opt	 bit (1),		/* info in here should be freed */
		  3 process_id_sw	 bit (1),
		  3 data_class_sw	 bit (1);

	declare opt_call_command_string
				 char (opt.call_command.length) based (opt.call_command.ptr);

	declare iox_$user_output	 ptr ext static;
	declare error_table_$bad_arg	 fixed bin (35) ext static;
	declare error_table_$namedup	 fixed bin (35) ext static;
	declare error_table_$inconsistent
				 fixed bin (35) ext static;
	declare error_table_$name_not_found
				 fixed bin (35) ext static;
	declare error_table_$unexpected_condition
				 fixed bin (35) ext static;
	declare error_table_$badopt	 fixed bin (35) external static;
	declare error_table_$bad_conversion
				 fixed bin (35) external static;
	declare error_table_$moderr	 fixed bin (35) external static;
	declare error_table_$noarg	 fixed bin (35) external static;
	declare error_table_$noentry	 fixed bin (35) external static;
	declare error_table_$too_many_args
				 fixed bin (35) external static;
	declare error_table_$no_log_message
				 fixed bin (35) external static;


	declare log_data_$syserr_log_name
				 char (32) external static;
	declare log_data_$syserr_log_dir
				 char (168) external static;

	declare check_gate_access_	 entry (char (*), ptr, fixed bin (35));
	declare com_err_		 entry options (variable);
	declare command_query_	 entry () options (variable);
	declare continue_to_signal_	 entry (fixed binary (35));
	declare cv_dec_check_	 entry (char (*), fixed bin (35)) returns (fixed bin (35));

	declare cu_$arg_list_ptr	 entry returns (pointer);
	declare dm_misc_util_$get_log_path
				 entry (char (*));
	declare dsa_nit_$get_field	 entry (char (*), char (*), char (*), char (*), fixed bin (35));
	declare expand_pathname_	 entry (char (*), char (*), char (*), fixed bin (35));
	declare format_log_message_$init
				 entry (pointer);
	declare format_log_message_$adjust
				 entry (pointer, fixed bin (35));
	declare format_log_message_$free
				 entry (pointer);
	declare get_line_length_$switch
				 entry (pointer, fixed bin (35)) returns (fixed bin);
	declare get_system_free_area_	 entry () returns (ptr);
	declare system_area		 area based (get_system_free_area_ ());
	declare hcs_$set_ips_mask	 entry (bit (36) aligned, bit (36) aligned);
	declare hcs_$reset_ips_mask	 entry (bit (36) aligned, bit (36) aligned);
	declare ioa_		 entry () options (variable);
	declare iox_$look_iocb	 entry (char (*), pointer, fixed bin (35));
	declare ipc_$create_ev_chn	 entry (fixed bin (71), fixed bin (35));
	declare ipc_$decl_event_call_chn
				 entry (fixed bin (71), entry, ptr, fixed bin, fixed bin (35));
	declare ipc_$delete_ev_chn	 entry (fixed bin (71), fixed bin (35));
	declare ipc_$cutoff		 entry (fixed bin (71), fixed bin (35));
	declare ipc_$reconnect	 entry (fixed bin (71), fixed bin (35));
	declare log_expand_select_$add entry (pointer, character (*), fixed binary (35));
	declare log_expand_select_$free
				 entry (pointer);
	declare log_expand_select_$print
				 entry (pointer, pointer, fixed binary);

	declare log_match_$add_match	 entry (pointer, char (*));
	declare log_match_$add_exclude entry (pointer, char (*));
	declare log_match_$add_match_data
				 entry (pointer, char (*));
	declare log_match_$add_exclude_data
				 entry (pointer, char (*));
	declare log_match_$clear_text_strings
				 entry (pointer);
	declare log_match_$clear_data_strings
				 entry (pointer);
	declare log_match_$add_match_data_class
				 entry (pointer, character (*));
	declare log_match_$add_exclude_data_class
				 entry (pointer, character (*));
	declare log_match_$clear_data_class_strings
				 entry (pointer);
	declare log_match_$add_severity
				 entry (pointer, fixed bin, fixed bin);
	declare log_match_$clear_severity
				 entry (pointer);
	declare log_match_$free	 entry (pointer);
	declare log_match_$print	 entry (pointer, pointer, fixed binary);
	declare log_read_$open	 entry (char (*), char (*), pointer, fixed bin (35));
	declare log_read_$open_long	 entry (character (*), character (*), pointer, pointer, fixed binary (35));
	declare log_read_$update	 entry (fixed binary (35), pointer, pointer, fixed binary (35));
	declare log_read_$close	 entry (pointer, fixed bin (35));
	declare log_read_$prev_message entry (pointer, pointer, fixed bin (35));
	declare log_read_$get_log_uid	 entry (pointer, bit (36) aligned, fixed binary (35));
	declare monitor_sys_log_wakeup_$timer
				 entry (pointer);

	declare pathname_		 entry (char (*), char (*)) returns (char (168));

	declare sub_err_		 entry () options (variable);
	declare ssu_$arg_count	 entry (ptr, fixed bin);
	declare ssu_$standalone_invocation
				 entry (ptr, char (*), char (*), ptr, entry, fixed bin (35));
	declare ssu_$destroy_invocation
				 entry (ptr);
	declare ssu_$arg_ptr	 entry (ptr, fixed bin, ptr, fixed bin (21));
	declare ssu_$abort_line	 entry () options (variable);
	declare timer_manager_$alarm_wakeup
				 entry (fixed binary (71), bit (2), fixed binary (71));
	declare timer_manager_$reset_alarm_wakeup
				 entry (fixed binary (71));

	declare any_other		 condition;
	declare cleanup		 condition;

	declare COMMAND_NAME	 char (32) internal static options (constant) init ("monitor_sys_log");
	declare SYSERR_PATH		 char (10) internal static options (constant) init ("<>SYSERR<>");
	declare AS_PATH		 char (10) internal static options (constant) init ("<>AS_LOG<>");
	declare ADMIN_PATH		 char (10) internal static options (constant) init ("<>ADMIN<>");
	declare DM_PATH		 char (10) internal static options (constant) init ("<>DM<>");
	declare DSA_SL_PATH		 char (10) internal static options (constant) init ("<>DSASL<>");
	declare DSA_SAL_PATH	 char (10) internal static options (constant) init ("<>DSASAL<>");
	declare ALL_PATH		 char (10) internal static options (constant) init ("<>ALL<>");
	declare NUMBER_PATH		 char (10) internal static options (constant) init ("<>NUMBER<>");


	declare MC_LOG_DIR		 char (168) init (">system_control_dir>as_logs") int static options (constant);

	declare DEFAULT_LINE_LENGTH	 fixed bin internal static options (constant) init (132);
						/* assume a file of some sort */

	declare (abs, addr, after, before, char, codeptr, index, length, null, substr, unspec)
				 builtin;

	declare DM_READER_PROCEDURE	 char (32) init ("dm_log_read_") int static options (constant);
	declare DSA_READER_PROCEDURE	 char (32) init ("dsa_log_admin_gate_") int static options (constant);


	call initialize_options ();

	on condition (cleanup) call clean_up ();


	call ssu_$standalone_invocation (sci_ptr, COMMAND_NAME, "1.0", cu_$arg_list_ptr (), SSU_ABORT, code);
	if code ^= 0
	then do;
		call com_err_ (code, COMMAND_NAME, "Unable to create ssu invocation.");
		return;
	     end;


	call process_arguments$$find_log_and_action ();	/* sets opt to indicate what log and what is to be done with it */

	if opt.time_given_sw
	then /* one possible action is to set the clock */
	     do;
		monitor_sys_log_data_.wakeup_interval = opt.time;
		call reset_timer;
	     end;

	if opt.pathname = ""
	then /* just the time, or the time and -status */
	     if opt.status_sw
	     then call print_status_header ();
	     else ;
	else call process_log;			/* reparse args to do the real work */

	call ssu_$destroy_invocation (sci_ptr);
	go to MAIN_RETURN;


SSU_ABORT:
     procedure;
	call finished ();
     end SSU_ABORT;


MAIN_RETURN:					/* This is the ONLY return statement for this procedure */
	return;



finished:						/* This is a procedure in order to aid debugging; one */
     procedure ();					/* can set a breakpoint in it to catch all error returns */

	call clean_up ();

	goto MAIN_RETURN;

     end finished;


fault_masked:
     procedure;

	if substr (old_mask, 36, 1) = "0"b
	then call continue_to_signal_ ((0));
	else do;
		call hcs_$reset_ips_mask (old_mask, old_mask);
		monitor_sys_log_data_.initialized = "0"b;
		call sub_err_ (error_table_$unexpected_condition, COMMAND_NAME, ACTION_CANT_RESTART, null (), (0),
		     "Error signalled while manipulating database.");
	     end;
	return;
     end fault_masked;

clean_up:
     procedure ();

	if opt.free_from_opt
	then do;
		if (opt.lmd_ptr ^= null ())
		then call log_match_$free (opt.lmd_ptr);

		if (opt.log_read_ptr ^= null ())
		then call log_read_$close (opt.log_read_ptr, (0));

		if (log_message_format_ptr ^= null ())
		then call format_log_message_$free (log_message_format_ptr);
	     end;
	if sci_ptr ^= null ()
	then call ssu_$destroy_invocation (sci_ptr);

	return;
     end clean_up;

reset_timer:
     procedure;

	if monitor_sys_log_data_.active & monitor_sys_log_data_.wakeup_event_channel ^= 0
	then call timer_manager_$reset_alarm_wakeup (monitor_sys_log_data_.wakeup_event_channel);
	monitor_sys_log_data_.active = "0"b;

	if monitor_sys_log_data_.n_logs_on_timer = 0
	then return;
	if monitor_sys_log_data_.wakeup_event_channel = 0
	then do;
		call ipc_$create_ev_chn (monitor_sys_log_data_.wakeup_event_channel, code);
		if code ^= 0
		then call sub_err_ (code, COMMAND_NAME, ACTION_CANT_RESTART, null (), (0),
			"Failed to create event channel for log timer.");
		call ipc_$decl_event_call_chn (monitor_sys_log_data_.wakeup_event_channel,
		     monitor_sys_log_wakeup_$timer, null (), 0, code);
		if code ^= 0
		then call sub_err_ (code, COMMAND_NAME, ACTION_CANT_RESTART, null (), (0),
			"Failed to declare event call channel for log timer.");
	     end;
	monitor_sys_log_data_.active = "1"b;
	call timer_manager_$alarm_wakeup (monitor_sys_log_data_.wakeup_interval, "11"b,
	     monitor_sys_log_data_.wakeup_event_channel);

	return;
     end reset_timer;


/**** When this is called, opt has a pathname of a log (and
      bits for the special logs), and the opt bits that
      specify actions are set. This procedure must determine
      if the specified log is already being monitored.
      If this is incompatable with the control arguments,
      then it must abort.

      Otherwise, the action can be one of:

      replace: remove the current monitor and then do an add.
      modify:  fill up opt from an_entry, parse args changing opt,
      and then copy back from opt to an_entry.
*/

process_log:
     procedure;

	declare already_monitored	 bit (1) aligned;
	declare explicit_action	 bit (1) aligned;
	declare explicit_modification	 bit (1) aligned;

	explicit_action = opt.add_sw | opt.remove_sw | opt.modify_sw | opt.on_sw | opt.off_sw | opt.status_sw;
	explicit_modification = explicit_action & ^opt.add_sw;
	if opt.all_sw
	then do;
		if ^explicit_modification
		then call ssu_$abort_line (sci_ptr, 0, "-all requires -on, -off, -remove, or -status.");
		call process_all_logs;
		return;
	     end;

	call make_log_pathname;			/* turn <<X>> to FS path */
	call find_log;				/* if the specified log exists, then set log_index and an_entry_ptr */

	already_monitored = (log_index ^= 0);

	if opt.add_sw & already_monitored
	then call ssu_$abort_line (sci_ptr, 0,
		"You are already monitoring ^a. Use -replace or -modify to change its parameters.", opt.pathname);

	if explicit_modification & ^already_monitored
	then call ssu_$abort_line (sci_ptr, 0,
		"-^[modify^]^[replace^]^[remove^]^[on^]^[off^]^[status^] specified, but you are not monitoring ^a.",
		opt.modify_sw, opt.replace_sw, opt.remove_sw, opt.on_sw, opt.off_sw, opt.status_sw, opt.pathname);

	if ^explicit_action
	then if already_monitored
	     then opt.modify_sw = "1"b;		/* The default is to modify */
	     else opt.add_sw = "1"b;			/* unless its not there at all, so we add */

/**** Now we have enough information to know what we are doing */

	if opt.modify_sw				/* an_entry is valid, guaranteed */
	then do;
		opt.free_from_opt = "0"b;		/* we are putting live goodies in here */
		opt.expand_select_ptr = an_entry.expand_select_ptr;
		opt.lmd_ptr = an_entry.lmd_ptr;
		log_message_format_ptr = an_entry.format_ptr;
		opt.log_read_ptr = an_entry.log_read_ptr;
	     end;
	if opt.replace_sw
	then do;
		if log_index > 0			/* its OK to -update when nothing is there, it just adds */
		then call remove_log;		/* POOF */
		opt.replace_sw = "0"b;
		opt.add_sw = "1"b;
	     end;
	if opt.add_sw
	then call initialize_add_options;
	if opt.add_sw | opt.modify_sw
	then do;
		call process_arguments$$fill_opt_with_options ();
		if opt.add_sw
		then do;
			call open_log;		/* fills in opt with read_data_ptr */
			call make_new_entry;	/* given a findable log, create a slot for it */
		     end;
		call fill_entry_from_opt;
	     end;
	else call process_existing_log;		/* take care of -remove, -on, -off, -status */
	return;
     end process_log;



/**** This procedure sets log_index to 0 or the index of a log
      with a pre-existing monitor. It always leaves an_entry_ptr
      consistent with log_index. */

find_log:
     procedure;

	log_index = 0;				/* assume no match */
	an_entry_ptr = null ();

	if monitor_sys_log_data_.initialized
	then monitor_sys_log_array_ptr = monitor_sys_log_data_.log_array_ptr;

	if ^monitor_sys_log_data_.initialized | monitor_sys_log_data_.n_logs = 0
	     | monitor_sys_log_data_.log_array_ptr = null ()
	then return;				/* surely no match */

	if opt.log_number > 0
	then do;					/* asked by number */
		if opt.log_number > monitor_sys_log_array.n_entries
		then return;
		if monitor_sys_log_array.entry (opt.log_number).dir_name = ""
		then return;
		log_index = opt.log_number;
		an_entry_ptr = addr (monitor_sys_log_array.entry (log_index));
		return;
	     end;

	/*** done with the numbered case. */

	do log_index = 1 to monitor_sys_log_array.n_entries;
	     an_entry_ptr = addr (monitor_sys_log_array.entry (log_index));
	     if an_entry.dir_name = ""
	     then ;				/* not in use */
	     else if opt.the_syserr_log_sw & an_entry.the_syserr_log
	     then return;
	     else if opt.the_as_log_sw & an_entry.the_as_log
	     then return;
	     else if opt.the_admin_log_sw & an_entry.the_admin_log
	     then return;
	     else if opt.the_dm_log_sw & an_entry.the_dm_log
	     then return;
	     else if opt.the_dsas_log_sw & an_entry.the_dsas_log
	     then return;
	     else if opt.the_dsasa_log_sw & an_entry.the_dsasa_log
	     then return;
	     else if same_pathname ()
	     then return;
	end;
	log_index = 0;
	return;

same_pathname:
     procedure returns (bit (1) aligned);

	declare (new_uid, old_uid)	 bit (36) aligned;
	declare temp_opening	 pointer;

	if an_entry.the_syserr_log | an_entry.the_as_log | an_entry.the_admin_log | an_entry.the_dm_log
	     | an_entry.the_dsas_log | an_entry.the_dsasa_log
	then return ("0"b);				/* already checked */

	call open_log;				/* sets opt.log_read_ptr */
	temp_opening = opt.log_read_ptr;
	opt.log_read_ptr = null ();
	call log_read_$get_log_uid (temp_opening, new_uid, code);
	call log_read_$close (temp_opening, (0));
	if code ^= 0
	then return ("0"b);
	call log_read_$update (an_entry.last_sequence, an_entry.log_read_ptr, an_entry.last_message_ptr, code);
	call log_read_$get_log_uid (an_entry.log_read_ptr, old_uid, code);
	if code ^= 0
	then return ("0"b);
	if new_uid = old_uid
	then return ("1"b);
	else return ("0"b);

     end same_pathname;
     end find_log;


print_status_header:
     procedure;

	declare select_timer	 fixed bin;

	if ^monitor_sys_log_data_.initialized | monitor_sys_log_data_.n_logs = 0
	then do;
		call ioa_ ("No logs, timer wakeup interval ^d seconds.", monitor_sys_log_data_.wakeup_interval);
		return;
	     end;

	if monitor_sys_log_data_.n_logs = 0
	then select_timer = 1;			/* don't print */
	else if monitor_sys_log_data_.n_logs = 1
	then if monitor_sys_log_data_.n_logs_on_timer = 1
	     then select_timer = 2;
	     else select_timer = 3;
	else if monitor_sys_log_data_.n_logs_on_timer = monitor_sys_log_data_.n_logs
	then select_timer = 4;			/* all */
	else if monitor_sys_log_data_.n_logs_on_timer = 0
	then select_timer = 5;			/* none */
	else select_timer = 6;

	call ioa_ (
	     "^d log^[s^]^[^s^;^s on timer^;^s^;^s, all on timer wakeup^;^s, none on timer wakeup^;, ^d on timer wakeup^]. Wakeup interval ^d seconds.",
	     monitor_sys_log_data_.n_logs, monitor_sys_log_data_.n_logs ^= 1, select_timer,
	     monitor_sys_log_data_.n_logs_on_timer, monitor_sys_log_data_.wakeup_interval);
	return;
     end print_status_header;



process_existing_log:
     procedure;

	if opt.status_sw
	then call status_log;
	else if opt.off_sw
	then call disable_log;
	else if opt.on_sw
	then call enable_log;
	else if opt.remove_sw
	then call remove_log;

	return;
     end process_existing_log;

process_all_logs:
     procedure;

	monitor_sys_log_array_ptr = monitor_sys_log_data_.log_array_ptr;

	if opt.status_sw
	then do;
		call print_status_header;
		if monitor_sys_log_data_.n_logs = 0
		then return;
	     end;
	else if monitor_sys_log_data_.n_logs = 0
	then call ssu_$abort_line (sci_ptr, 0, "There are no monitors set.");


	do log_index = 1 to monitor_sys_log_array.n_entries;
	     an_entry_ptr = addr (monitor_sys_log_array.entry (log_index));
	     if an_entry.dir_name ^= ""
	     then call process_existing_log;
	end;
	return;
     end process_all_logs;

status_log:
     procedure;

	call ioa_ (
	     "# ^d: Pathname ^a^[ (the syserr log)^]^[ (the Answering Service log)^]^[ (the Admin command log)^]^[ (the DM system log)^]^[ (the DSA system log)^]^[ (the DSA system aep log)^]",
	     log_index, pathname_ (an_entry.dir_name, an_entry.entryname), an_entry.the_syserr_log, an_entry.the_as_log,
	     an_entry.the_admin_log, an_entry.the_dm_log, an_entry.the_dsas_log, an_entry.the_dsasa_log);
	call ioa_ ("   ^[Examined on timer^;Registered to receive wakeups on messages^]", ^an_entry.registered);
	if an_entry.inhibited
	then call ioa_ ("   Currently inhibited.");
	if an_entry.expand_select_ptr ^= null ()
	then call log_expand_select_$print (an_entry.expand_select_ptr, iox_$user_output, 3);
	if an_entry.lmd_ptr ^= null ()
	then call log_match_$print (an_entry.lmd_ptr, iox_$user_output, 3);
	/*** The formatting options are too hairy */
	call ioa_ ("   Last sequence number ^d.", an_entry.last_sequence);
	return;
     end status_log;

disable_log:
     procedure;

	if an_entry.inhibited
	then call ssu_$abort_line (sci_ptr, 0, "Log ^a is already off.", an_entry.entryname);
	an_entry.inhibited = "1"b;
	if an_entry.registered
	then call ipc_$cutoff (an_entry.registered_wakeup_event_channel, (0));
	else call reset_timer;
	return;
     end disable_log;

enable_log:
     procedure;

	if ^an_entry.inhibited
	then call ssu_$abort_line (sci_ptr, 0, "Log ^a is already on.", an_entry.entryname);
	call log_read_$update (an_entry.last_sequence, an_entry.log_read_ptr, an_entry.last_message_ptr, (0));
						/* ignore this code */
	an_entry.last_message_ptr = null ();
	call log_read_$prev_message (an_entry.log_read_ptr, an_entry.last_message_ptr, code);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code, "Failed to find last message in log ^a to process -on.",
		an_entry.entryname);
	an_entry.last_sequence = an_entry.last_message_ptr -> log_message.sequence;
	an_entry.prev_message_ptr = null ();
	an_entry.inhibited = "0"b;
	if an_entry.registered
	then call ipc_$reconnect (an_entry.registered_wakeup_event_channel, (0));
	else call reset_timer;
	return;
     end enable_log;

remove_log:
     procedure;

	if an_entry.registered
	then do;					/* de-register, etc */
	     end;
	else monitor_sys_log_data_.n_logs_on_timer = monitor_sys_log_data_.n_logs_on_timer - 1;
	monitor_sys_log_data_.n_logs = monitor_sys_log_data_.n_logs - 1;

	old_mask = ""b;
	on any_other call fault_masked;
	on cleanup
	     begin;
		if substr (old_mask, 36, 1) = "1"b
		then call hcs_$reset_ips_mask (old_mask, old_mask);
	     end;
	call hcs_$set_ips_mask (""b, old_mask);
	an_entry.dir_name = "";			/* chase handlers away */
	call hcs_$reset_ips_mask (old_mask, old_mask);
	revert any_other, cleanup;

	call log_read_$close (an_entry.log_read_ptr, (0));
	if an_entry.expand_select_ptr ^= null ()
	then call log_expand_select_$free (an_entry.expand_select_ptr);
	if an_entry.lmd_ptr ^= null ()
	then call log_match_$free (an_entry.lmd_ptr);
	if an_entry.format_ptr ^= null ()
	then call format_log_message_$free (an_entry.format_ptr);
	if an_entry.registered_wakeup_event_channel ^= 0
	then call ipc_$delete_ev_chn (an_entry.registered_wakeup_event_channel, (0));
	if an_entry.call_command.ptr ^= null ()
	then begin;
		declare call_command_string	 char (an_entry.call_command.length) based (an_entry.call_command.ptr);
		free call_command_string;
	     end;

	call clear_entry;
	call reset_timer;
	return;
     end remove_log;

make_new_entry:
     procedure;

	if ^monitor_sys_log_data_.initialized
	then call initialize_data ();			/* sets array ptr if needed */

/**** we have to mask IPS to avoid QUIT and foolishness */

	old_mask = ""b;
	on any_other call fault_masked;
	on cleanup
	     begin;
		if substr (old_mask, 36, 1) = "1"b
		then call hcs_$reset_ips_mask (old_mask, old_mask);
	     end;
	call hcs_$set_ips_mask (""b, old_mask);

	do log_index = 1 to monitor_sys_log_array.n_entries;
	     if monitor_sys_log_array.entry (log_index).dir_name = ""
	     then go to HAVE_EMPTY_SLOT;
	end;

	call reallocate_array ();

HAVE_EMPTY_SLOT:
	an_entry_ptr = addr (monitor_sys_log_array.entry (log_index));
						/* set pointer for caller */

	call hcs_$reset_ips_mask (old_mask, old_mask);
	revert any_other, cleanup;

     end make_new_entry;



fill_entry_from_opt:
     procedure;

	declare log_last_sequence	 fixed bin (35);
	declare log_last_message_ptr	 pointer;

	if opt.add_sw
	then call get_last_message_info (log_last_sequence, log_last_message_ptr);

	if ^opt.prefix_given_sw
	then do;
		if opt.the_syserr_log_sw
		then log_message_format.prefix = "SYSERR: ";
		else if opt.the_as_log_sw
		then log_message_format.prefix = "AS: ";
		else if opt.the_admin_log_sw
		then log_message_format.prefix = "ADMIN: ";
		else if opt.the_dm_log_sw
		then log_message_format.prefix = "DM: ";
		else if opt.the_dsas_log_sw
		then log_message_format.prefix = "DSASL: ";
		else if opt.the_dsasa_log_sw
		then log_message_format.prefix = "DSASAL: ";
		else log_message_format.prefix = rtrim (log_ename) || ": ";
		call adjust_log_message_format ("Adding default prefix", (log_message_format.prefix));
	     end;

	an_entry.dir_name = log_dname;
	an_entry.entryname = log_ename;
	an_entry.log_read_ptr = opt.log_read_ptr;
	an_entry.the_syserr_log = opt.the_syserr_log_sw;
	an_entry.the_as_log = opt.the_as_log_sw;
	an_entry.the_admin_log = opt.the_admin_log_sw;
	an_entry.the_dm_log = opt.the_dm_log_sw;
	an_entry.the_dsas_log = opt.the_dsas_log_sw;
	an_entry.the_dsasa_log = opt.the_dsasa_log_sw;
	an_entry.registered = "0"b;			/* not yet implemented */
	an_entry.inhibited = "0"b;
	an_entry.expand_select_ptr = opt.expand_select_ptr;
	an_entry.lmd_ptr = opt.lmd_ptr;
	an_entry.iocb_ptr = opt.iocb_ptr;
	an_entry.octal_sw = opt.octal_sw;
	an_entry.interpret_sw = opt.interpret_sw;
	an_entry.process_id_sw = opt.process_id_sw;
	an_entry.data_class_sw = opt.data_class_sw;

	an_entry.format_ptr = log_message_format_ptr;
	if opt.add_sw
	then do;
		an_entry.last_sequence = log_last_sequence;
						/* found by open_log */
		an_entry.last_message_ptr = log_last_message_ptr;
		an_entry.prev_message_ptr = null ();
	     end;
	if opt.call_given_sw
	then begin;
		declare copy_of_call_command	 char (an_entry.call_command.length) based (an_entry.call_command.ptr);
		an_entry.call_command.length = opt.call_command.length;
		allocate copy_of_call_command in (system_area);
		copy_of_call_command = opt_call_command_string;
	     end;

	if opt.add_sw
	then do;					/* This won't be right if we are modifying the registered status. Implementors of -registered beware */
		monitor_sys_log_data_.n_logs = monitor_sys_log_data_.n_logs + 1;
		if ^an_entry.registered
		then do;
			monitor_sys_log_data_.n_logs_on_timer = monitor_sys_log_data_.n_logs_on_timer + 1;
			if monitor_sys_log_data_.n_logs_on_timer = 1
						/* first one */
			then call reset_timer ();
		     end;

	     end;

	return;
     end fill_entry_from_opt;

make_log_pathname:
     procedure ();

	if opt.all_sw
	then return;
	if (opt.pathname = NUMBER_PATH)
	then return;

	if (opt.pathname = SYSERR_PATH)
	then do;
		log_dname = log_data_$syserr_log_dir;
		log_ename = log_data_$syserr_log_name;
		opt.pathname = pathname_ (log_dname, log_ename);
	     end;

	else if opt.pathname = AS_PATH
	then do;
		log_dname = ">system_control_dir>as_logs";
		log_ename = "log";
		opt.pathname = pathname_ (log_dname, log_ename);
	     end;
	else if opt.pathname = ADMIN_PATH
	then do;
		log_dname = ">system_control_dir>as_logs";
		log_ename = "admin_log";
		opt.pathname = pathname_ (log_dname, log_ename);
	     end;
	else if opt.pathname = DM_PATH
	then do;
		call dm_misc_util_$get_log_path (dm_system_log_path);
		call expand_pathname_ (dm_system_log_path, log_dname, log_ename, 0);
		opt.pathname = dm_system_log_path;
		opt.reader_procedure = DM_READER_PROCEDURE;
	     end;
	else if opt.pathname = DSA_SL_PATH
	then do;

		/*** Check to see if we will succeed. */

		call check_gate_access_ (DSA_READER_PROCEDURE, null (), code);

		if code = error_table_$noentry
		then call ssu_$abort_line (sci_ptr, error_table_$bad_arg, "DSA is not installed on this system.");
		else if code = error_table_$moderr
		then call ssu_$abort_line (sci_ptr, code, "You need e access to ^a to read the DSA log.",
			DSA_READER_PROCEDURE);
		else if code ^= 0
		then call ssu_$abort_line (sci_ptr, code, "Trying to check the access to: ^a.", DSA_READER_PROCEDURE);

		/*** The code was 0, proceed. */

		else call dsa_nit_$get_field ("mna_general_info", "", "dsa_system_log", dsa_system_log_path, code);

		if code ^= 0
		then call ssu_$abort_line (sci_ptr, code, "Cannot find the name of the dsa system log.");

		call expand_pathname_ (dsa_system_log_path, log_dname, log_ename, 0);
		opt.pathname = dsa_system_log_path;
		opt.reader_procedure = DSA_READER_PROCEDURE;
	     end;
	else if opt.pathname = DSA_SAL_PATH
	then do;

		/*** Check to see if we will succeed. */

		call check_gate_access_ (DSA_READER_PROCEDURE, null (), code);

		if code = error_table_$noentry
		then call ssu_$abort_line (sci_ptr, error_table_$bad_arg, "DSA is not installed on this system.");
		else if code = error_table_$moderr
		then call ssu_$abort_line (sci_ptr, code, "You need e access to ^a to read the DSA log.",
			DSA_READER_PROCEDURE);
		else if code ^= 0
		then call ssu_$abort_line (sci_ptr, code, "Trying to check the access to: ^a.", DSA_READER_PROCEDURE);

		/*** The code was 0, proceed. */

		else call dsa_nit_$get_field ("mna_general_info", "", "dsa_system_aep_log", dsa_system_log_path, code)
			;

		if code ^= 0
		then call ssu_$abort_line (sci_ptr, code, "Cannot find the name of the dsa system aep log.");

		call expand_pathname_ (dsa_system_log_path, log_dname, log_ename, 0);
		opt.pathname = dsa_system_log_path;
		opt.reader_procedure = DSA_READER_PROCEDURE;
	     end;
	else do;
		call expand_pathname_ (opt.pathname, log_dname, log_ename, code);
		if (code ^= 0)
		then call ssu_$abort_line (sci_ptr, code, "Log pathname ^a", opt.pathname);
	     end;

	return;
     end make_log_pathname;

open_log:
     procedure;

	if opt.reader_procedure ^= ""
	then do;
		log_open_info.version = LOG_READ_OPEN_INFO_VERSION_1;
		log_open_info.reader_procedure = opt.reader_procedure;
		log_open_info.allocation_area_ptr = get_system_free_area_ ();
						/* since we never use hold_message, it is reasonable for log_read_ to allocate the 2 copies it keeps around in here */
		log_open_info.allocate_copies = "0"b;	/* That is the inner-ring's job */
		call log_read_$open_long (log_dname, log_ename, addr (log_open_info), opt.log_read_ptr, code);
	     end;
	else call log_read_$open (log_dname, log_ename, opt.log_read_ptr, code);

	if (code ^= 0)
	then call ssu_$abort_line (sci_ptr, code, "Cannot open ^a", opt.pathname);

	return;
     end open_log;

get_last_message_info:
     procedure (last_seq, last_msg_ptr);

	declare last_seq		 fixed bin (35);
	declare last_msg_ptr	 pointer;

	last_msg_ptr = null ();
	call log_read_$prev_message (opt.log_read_ptr, last_msg_ptr, code);
	if code ^= 0 & code ^= error_table_$no_log_message/* no_log_message happens if the log is empty. */
	then call ssu_$abort_line (sci_ptr, code, "Failed to find last message in log ^a.", opt.pathname);
						/* This may need to know about empty logs ... */
	if last_msg_ptr = null ()
	then last_seq = -1;
	else last_seq = last_msg_ptr -> log_message.sequence;
	return;
     end get_last_message_info;

initialize_data:
     procedure;

	declare 1 init_entry	 aligned like monitor_sys_log_array.entry automatic;

	declare new_array_ptr	 pointer;
	declare x			 fixed bin;

	msl_n_entries = 100;			/* lots */
	allocate monitor_sys_log_array in (system_area);
	call set_init_entry ();

	monitor_sys_log_array.entry (*) = init_entry;
	monitor_sys_log_data_.log_array_ptr = monitor_sys_log_array_ptr;
	monitor_sys_log_data_.initialized = "1"b;
	return;

reallocate_array:
     entry;

	msl_n_entries = 2 * monitor_sys_log_array.n_entries;
	allocate monitor_sys_log_array in (system_area) set (new_array_ptr);
	call set_init_entry ();
	new_array_ptr -> monitor_sys_log_array.entry (*) = init_entry;
	do x = 1 to monitor_sys_log_array.n_entries;
	     new_array_ptr -> monitor_sys_log_array.entry (x) = monitor_sys_log_array.entry (x);
	end;
	log_index = x;				/* first free slot in new array */

	old_mask = ""b;
	on any_other call fault_masked;
	on cleanup
	     begin;
		if substr (old_mask, 36, 1) = "1"b
		then call hcs_$reset_ips_mask (old_mask, old_mask);
	     end;
	call hcs_$set_ips_mask (""b, old_mask);
	monitor_sys_log_data_.log_array_ptr = new_array_ptr;
	free monitor_sys_log_array;
	monitor_sys_log_array_ptr = new_array_ptr;
	call hcs_$reset_ips_mask (old_mask, old_mask);
	revert any_other, cleanup;
	return;

clear_entry:
     entry;					/* assumes an_entry is the victim */

	call set_init_entry ();
	an_entry = init_entry;
	return;

set_init_entry:
     procedure;

	init_entry.dir_name = "";
	init_entry.entryname = "";
	init_entry.log_read_ptr = null ();
	init_entry.the_syserr_log = "0"b;
	init_entry.the_as_log = "0"b;
	init_entry.the_admin_log = "0"b;
	init_entry.the_dm_log = "0"b;
	init_entry.the_dsas_log = "0"b;
	init_entry.the_dsasa_log = "0"b;
	init_entry.registered = "0"b;
	init_entry.inhibited = "0"b;
	init_entry.expand_select_ptr = null ();
	init_entry.interpret_sw = "0"b;
	init_entry.octal_sw = "0"b;
	init_entry.lmd_ptr = null ();
	init_entry.format_ptr = null ();
	init_entry.iocb_ptr = null ();
	init_entry.call_command.ptr = null ();
	init_entry.call_command.length = 0;
	init_entry.last_sequence = 0;
	init_entry.last_message_ptr = null ();
	init_entry.prev_message_ptr = null ();
	init_entry.registered_wakeup_event_channel = 0;
	return;
     end set_init_entry;

     end initialize_data;


initialize_options:
     procedure ();

/* This must be run before the cleanup handler gets set up */

	unspec (opt) = ""b;				/* Turn all options off */
	opt.pointers = null ();			/* Aggregate assignment */
	opt.free_from_opt = "1"b;
	opt.pathname = "";
	opt.iocb_ptr = iox_$user_output;
	opt.call_command.ptr = null ();
	opt.call_command.length = 0;
	log_message_format_ptr = null ();
	opt.reader_procedure = "";			/* Default */
	return;
     end initialize_options;

initialize_add_options:
     procedure;

	call format_log_message_$init (log_message_format_ptr);
	log_message_format.continuation_indent = 3;	/* economize on space */
	log_message_format.caller = COMMAND_NAME;
	log_message_format.equal_sw = "0"b;

	log_message_format.line_lth = get_line_length_$switch (opt.iocb_ptr, code);
	if (code ^= 0)
	then log_message_format.line_lth = DEFAULT_LINE_LENGTH;
						/* Pretend to be a printer, by default */

	call adjust_log_message_format ("Initializing log_message_format structure", "");

	return;
     end initialize_add_options;


process_arguments$$find_log_and_action:
     procedure ();

	declare arg		 char (arg_lth) based (arg_ptr);
	declare arg_lth		 fixed bin (21);
	declare arg_ptr		 pointer;
	declare arg_count		 fixed bin;
	declare arg_idx		 fixed bin;

	declare looking_for		 fixed bin;
	declare saved_looking_for	 fixed bin;
	declare number_arg		 char (20) varying;
	declare iocb_arg		 char (32) varying;
	declare temp_v_string_arg	 char (200) varying;
	declare pass		 fixed bin;

	declare FIND_LOG		 fixed bin init (1) int static options (constant);
	declare DO_CONTROL_ARGS	 fixed bin init (2) int static options (constant);

	declare LOG_PATHNAME	 init (1) fixed bin internal static options (constant);
	declare MATCH_STRING	 init (2) fixed bin internal static options (constant);
	declare EXCLUDE_STRING	 init (3) fixed bin internal static options (constant);
	declare MATCH_DATA_STRING	 init (4) fixed bin internal static options (constant);
	declare EXCLUDE_DATA_STRING	 init (5) fixed bin internal static options (constant);
	declare SEVERITY		 init (6) fixed bin internal static options (constant);
	declare CALL_COMMAND	 init (7) fixed bin internal static options (constant);
	declare EXPAND_TYPE		 init (8) fixed bin internal static options (constant);
	declare MC_PATHNAME		 init (9) fixed bin internal static options (constant);
	declare MATCH_DATA_CLASS_STRING
				 init (10) fixed bin internal static options (constant);
	declare EXCLUDE_DATA_CLASS_STRING
				 init (11) fixed bin internal static options (constant);


	pass = FIND_LOG;
	go to COMMON;

process_arguments$$fill_opt_with_options:
     entry;

	pass = DO_CONTROL_ARGS;

COMMON:
	call ssu_$arg_count (sci_ptr, arg_count);

	looking_for = 0 - LOG_PATHNAME;		/* Start out "casually" looking for a pathname */

	do arg_idx = 1 to arg_count;
	     call ssu_$arg_ptr (sci_ptr, arg_idx, arg_ptr, arg_lth);

	     if (looking_for > 0)
	     then do;				/* First one after a control argument */
		     call process_looking_for ();	/* -match -fred matches "-fred", but */
		     looking_for = 0 - looking_for;	/* -match str -fred is an error */
		end;				/* "Casually" looking for signalled by negative value */

	     else if (arg = "-match") | (arg = "-mh")
	     then do;
		     looking_for = MATCH_STRING;
		end;
	     else if (arg = "-exclude") | (arg = "-ex")
	     then do;
		     looking_for = EXCLUDE_STRING;
		end;

	     else if (arg = "-match_data_class") | (arg = "-mdc")
	     then do;
		     looking_for = MATCH_DATA_CLASS_STRING;
		end;
	     else if (arg = "-exclude_data_class") | (arg = "-exdc")
	     then do;
		     looking_for = EXCLUDE_DATA_CLASS_STRING;
		end;
	     else if (arg = "-match_data") | (arg = "-md")
	     then do;
		     looking_for = MATCH_DATA_STRING;
		end;
	     else if (arg = "-exclude_data") | (arg = "-exd")
	     then do;
		     looking_for = EXCLUDE_DATA_STRING;
		end;
	     else if (arg = "-all_text") | (arg = "-atxt")
	     then do;
		     if (pass = DO_CONTROL_ARGS)
		     then do;
			     call log_match_$clear_text_strings (opt.lmd_ptr);
			end;
		end;
	     else if (arg = "-all_data") | (arg = "-ad")
	     then do;
		     if (pass = DO_CONTROL_ARGS)
		     then do;
			     call log_match_$clear_data_strings (opt.lmd_ptr);
			end;
		end;

	     else if (arg = "-all_data_class") | (arg = "-adc")
	     then do;
		     if (pass = DO_CONTROL_ARGS)
		     then do;
			     call log_match_$clear_data_class_strings (opt.lmd_ptr);
			end;
		end;


	     else if (arg = "-severity") | (arg = "-sv") | (arg = "-action")
	     then do;
		     looking_for = SEVERITY;
		end;

	     else if (arg = "-all_severities") | (arg = "-asv")
	     then do;
		     if (pass = DO_CONTROL_ARGS)
		     then call log_match_$clear_severity (opt.lmd_ptr);
		end;

	     else if (arg = "-expand") | (arg = "-exp")
	     then do;
		     looking_for = (0 - EXPAND_TYPE);
		     opt.expand_sw = "1"b;
		end;
	     else if (arg = "-no_expand") | (arg = "-nexp")
	     then do;
		     if (pass = DO_CONTROL_ARGS)
		     then do;
			     opt.expand_sw = "0"b;
			     opt.octal_sw = "0"b;
			     opt.interpret_sw = "0"b;
			end;
		end;

	     else if (arg = "-octal") | (arg = "-oc")
	     then do;
		     if (pass = DO_CONTROL_ARGS)
		     then do;
			     opt.expand_sw = "1"b;
			     opt.octal_sw = "1"b;
			end;
		end;
	     else if (arg = "-interpret") | (arg = "-int") | (arg = "-it")
	     then do;
		     if (pass = DO_CONTROL_ARGS)
		     then do;
			     opt.expand_sw = "1"b;
			     opt.interpret_sw = "1"b;
			end;
		end;

	     else if (arg = "-no_process_id") | (arg = "-npid")
	     then do;
		     if (pass = DO_CONTROL_ARGS)
		     then opt.process_id_sw = "0"b;
		end;
	     else if (arg = "-process_id") | (arg = "-pid")
	     then do;
		     if (pass = DO_CONTROL_ARGS)
		     then opt.process_id_sw = "1"b;
		end;

	     else if (arg = "-no_data_class") | (arg = "-ndc")
	     then do;
		     if (pass = DO_CONTROL_ARGS)
		     then opt.data_class_sw = "0"b;
		end;

	     else if (arg = "-data_class") | (arg = "-dc")
	     then do;
		     if (pass = DO_CONTROL_ARGS)
		     then opt.data_class_sw = "1"b;
		end;

	     else if (arg = "-procedure") | (arg = "-proc")
	     then do;
		     call get_next_arg (opt.reader_procedure);
		end;

	     else if (arg = "-line_length") | (arg = "-ll")
	     then do;
		     call get_next_arg (number_arg);
		     if (pass = DO_CONTROL_ARGS)
		     then do;
			     log_message_format.line_lth = cv_dec_check_ ((number_arg), code);
			     if (code ^= 0) | (log_message_format.line_lth < 25)
				| (log_message_format.line_lth > 500)
			     then call ssu_$abort_line (sci_ptr, error_table_$bad_conversion,
				     "Line length must be between 25 and 500, not ^a", number_arg);

			     call adjust_log_message_format ("Processing -line_length.", arg);
			end;
		end;				/* Of -line_length processing */

	     else if (arg = "-output_switch") | (arg = "-osw")
	     then do;
		     call get_next_arg (iocb_arg);
		     if (pass = DO_CONTROL_ARGS)
		     then do;
			     call iox_$look_iocb ((iocb_arg), opt.iocb_ptr, code);
			     if (code ^= 0)
			     then call ssu_$abort_line (sci_ptr, code, "I/O switch ^a", iocb_arg);
			     log_message_format.line_lth = get_line_length_$switch (opt.iocb_ptr, code);
			     if (code ^= 0)
			     then /* Must reset the line length, also reapply the default */
				log_message_format.line_lth = DEFAULT_LINE_LENGTH;

			     call adjust_log_message_format ("Setting line length from -output_switch", arg);
			end;
		end;				/* Of -line_length processing */

	     else if (arg = "-indent") | (arg = "-ind") | (arg = "-in")
	     then do;
		     call get_next_arg (number_arg);
		     if (pass = DO_CONTROL_ARGS)
		     then do;
			     log_message_format.indentation = cv_dec_check_ ((number_arg), code);
			     if (code ^= 0) | (log_message_format.indentation < 0)
				| (log_message_format.indentation > 50)
			     then call ssu_$abort_line (sci_ptr, error_table_$bad_conversion,
				     "Indentation must be between 0 and 50, not ^a", number_arg);

			     call adjust_log_message_format ("Processing -indent", arg);
			end;
		end;				/* Of -indent processing */

	     else if (arg = "-continuation_indent") | (arg = "-ci")
	     then do;
		     call get_next_arg (number_arg);
		     if (pass = DO_CONTROL_ARGS)
		     then do;
			     if number_arg = "std" | number_arg = "standard"
			     then log_message_format.continuation_indent = -1;
			     else do;
				     log_message_format.continuation_indent = cv_dec_check_ ((number_arg), code);
				     if (code ^= 0) | (log_message_format.continuation_indent < 0)
					| (log_message_format.continuation_indent > 50)
				     then call ssu_$abort_line (sci_ptr, error_table_$bad_conversion,
					     "Continuation indent must be between 0 and 50 or ""standard"", not ^a",
					     number_arg);
				end;
			     call adjust_log_message_format ("Processing -continuation_indent", (number_arg));
			end;
		end;				/* Of -continuation_indent processing */

	     else if (arg = "-prefix") | (arg = "-pfx")
	     then do;
		     call get_next_arg (temp_v_string_arg);
		     if (pass = DO_CONTROL_ARGS)
		     then do;
			     opt.prefix_given_sw = "1"b;
			     log_message_format.prefix = temp_v_string_arg;
			     call adjust_log_message_format ("Processing -prefix", arg);
			end;
		end;				/* Of -prefix processing */


	     else if (arg = "-time_format") | (arg = "-tfmt")
	     then do;
		     call get_next_arg (temp_v_string_arg);
		     if (pass = DO_CONTROL_ARGS)
		     then do;
			     log_message_format.time_format = temp_v_string_arg;
			     call adjust_log_message_format ("Processing -time_format", arg);
			end;
		end;

	     else if (arg = "-date_format") | (arg = "-dfmt")
	     then do;
		     call get_next_arg (temp_v_string_arg);
		     if (pass = DO_CONTROL_ARGS)
		     then do;
			     log_message_format.date_format = temp_v_string_arg;
			     call adjust_log_message_format ("Processing -date_format", arg);
			end;
		end;
	     else if (arg = "-all") | (arg = "-a")
	     then do;
		     if (pass = FIND_LOG)
		     then do;
			     if opt.pathname ^= ""
			     then call two_logs;
			     opt.all_sw = "1"b;
			     opt.pathname = ALL_PATH;
			end;
		end;
	     else if (arg = "-mc_log") | (arg = "-mcl")
	     then looking_for = MC_PATHNAME;
	     else if (arg = "-number_format") | (arg = "-nfmt")
	     then do;
		     call get_next_arg (temp_v_string_arg);
		     if (pass = DO_CONTROL_ARGS)
		     then do;
			     log_message_format.number_format = temp_v_string_arg;
			     call adjust_log_message_format ("Processing -number_format", arg);
			end;
		end;

	     else if (arg = "-add")
	     then if (pass = FIND_LOG)
		then opt.add_sw = "1"b;
		else ;
	     else if (arg = "-remove") | (arg = "-rm")
	     then if (pass = FIND_LOG)
		then opt.remove_sw = "1"b;
		else ;
	     else if (arg = "-on")
	     then if (pass = FIND_LOG)
		then opt.on_sw = "1"b;
		else ;
	     else if (arg = "-off")
	     then if (pass = FIND_LOG)
		then opt.off_sw = "1"b;
		else ;

	     else if (arg = "-replace") | (arg = "-rp")
	     then if (pass = FIND_LOG)
		then opt.replace_sw = "1"b;
		else ;

	     else if (arg = "-update") | (arg = "-ud")
	     then if (pass = FIND_LOG)
		then opt.replace_sw = "1"b;
		else ;
	     else if (arg = "-status") | (arg = "-st")
	     then if (pass = FIND_LOG)
		then opt.status_sw = "1"b;
		else ;

	     else if (arg = "-time") | (arg = "-tm")
	     then do;
		     call get_next_arg (number_arg);
		     if (pass = FIND_LOG)
		     then do;
			     opt.time = cv_dec_check_ ((number_arg), code);
			     opt.time_given_sw = "1"b;
			     if code ^= 0 | opt.time < 1
			     then call ssu_$abort_line (sci_ptr, error_table_$bad_conversion,
				     "-time must be followed by a positive number of seconds.");
			end;
		end;

	     else if (arg = "-number") | (arg = "-nb")
	     then do;
		     call get_next_arg (number_arg);
		     if (pass = FIND_LOG)
		     then do;
			     opt.log_number = cv_dec_check_ ((number_arg), code);
			     if opt.pathname ^= ""
			     then call two_logs;
			     opt.pathname = NUMBER_PATH;
			     if code ^= 0 | opt.log_number < 1
			     then call ssu_$abort_line (sci_ptr, error_table_$bad_conversion,
				     "-number must be followed by a positive number.");
			end;
		end;
	     else if (arg = "-syserr")
	     then do;
		     if (pass = FIND_LOG)
		     then do;
			     opt.pathname = SYSERR_PATH;
			     opt.the_syserr_log_sw = "1"b;
			end;
		end;

	     else if (arg = "-answering_service") | (arg = "-as")
	     then do;
		     if (pass = FIND_LOG)
		     then do;
			     opt.pathname = AS_PATH;
			     opt.the_as_log_sw = "1"b;
			end;
		end;
	     else if (arg = "-admin")
	     then do;
		     if (pass = FIND_LOG)
		     then do;
			     opt.pathname = ADMIN_PATH;
			     opt.the_admin_log_sw = "1"b;
			end;
		end;

	     else if (arg = "-dm_system_log") | (arg = "-dms")
	     then do;
		     if (pass = FIND_LOG)
		     then do;
			     opt.pathname = DM_PATH;
			     opt.the_dm_log_sw = "1"b;
			end;
		end;

	     else if (arg = "-dsa_sys_log") | (arg = "-dsasl")
	     then do;
		     if (pass = FIND_LOG)
		     then do;
			     opt.pathname = DSA_SL_PATH;
			     opt.the_dsas_log_sw = "1"b;
			end;
		end;

	     else if (arg = "-dsa_sys_aep_log") | (arg = "-dsasal")
	     then do;
		     if (pass = FIND_LOG)
		     then do;
			     opt.pathname = DSA_SAL_PATH;
			     opt.the_dsasa_log_sw = "1"b;
			end;
		end;

	     else if (arg = "-call")
	     then do;
		     opt.call_given_sw = "1"b;
		     looking_for = CALL_COMMAND;
		end;

	     else if (char (arg, 1) = "-")
	     then call ssu_$abort_line (sci_ptr, error_table_$badopt, "^a", arg);

	     else call process_looking_for ();
	end;					/* of loop through arguments */

	if (pass = FIND_LOG)
	then call check_options ();
	if (pass = DO_CONTROL_ARGS)
	then if opt.expand_sw & ^(opt.octal_sw | opt.interpret_sw)
	     then opt.interpret_sw = "1"b;		/* If neither specified, default is -interpret */

	return;					/* End of argument processing */


process_looking_for:
     procedure ();

	declare really_looking_for	 fixed bin;
	declare severity1		 fixed bin;
	declare severity2		 fixed bin;


	really_looking_for = abs (looking_for);

	if (really_looking_for = LOG_PATHNAME)
	then do;
		if (pass = FIND_LOG)
		then do;
			if (opt.pathname ^= "")
			then call two_logs;
			opt.pathname = arg;
		     end;
	     end;

	else if (really_looking_for = MC_PATHNAME)
	then do;
		if (pass = FIND_LOG)
		then do;
			if (opt.pathname ^= "")
			then call two_logs;
			if search (arg, "<>") > 0
			then call ssu_$abort_line (sci_ptr, 0,
				"-log must be followed by a log entryname of a log in >sc1>as_logs.");
			opt.pathname = pathname_ (MC_LOG_DIR, arg);
		     end;
	     end;

	else if (really_looking_for = MATCH_STRING)
	then if (pass = DO_CONTROL_ARGS)
	     then call log_match_$add_match (opt.lmd_ptr, arg);
	     else ;

	else if (really_looking_for = EXCLUDE_STRING)
	then if (pass = DO_CONTROL_ARGS)
	     then call log_match_$add_exclude (opt.lmd_ptr, arg);
	     else ;

	else if (really_looking_for = MATCH_DATA_CLASS_STRING)
	then if (pass = DO_CONTROL_ARGS)
	     then call log_match_$add_match_data_class (opt.lmd_ptr, arg);
	     else ;

	else if (really_looking_for = EXCLUDE_DATA_CLASS_STRING)
	then if (pass = DO_CONTROL_ARGS)
	     then call log_match_$add_exclude_data_class (opt.lmd_ptr, arg);
	     else ;

	else if (really_looking_for = MATCH_DATA_STRING)
	then if (pass = DO_CONTROL_ARGS)
	     then call log_match_$add_match_data (opt.lmd_ptr, arg);
	     else ;

	else if (really_looking_for = EXCLUDE_DATA_STRING)
	then if (pass = DO_CONTROL_ARGS)
	     then call log_match_$add_exclude_data (opt.lmd_ptr, arg);
	     else ;

	else if (really_looking_for = SEVERITY)
	then do;
		if (pass = DO_CONTROL_ARGS)
		then do;
			severity1 = cv_dec_check_ (before (arg, ":"), code);
			if (code ^= 0)
			then
INVALID_SEVERITY_RANGE:
			     call ssu_$abort_line (sci_ptr, error_table_$bad_conversion,
				"Invalid severity value ""^a"": must be <N> or <N>:<M>", arg);

			if (index (arg, ":") = 0)
			then /* Not a range, just a single number */
			     severity2 = severity1;
			else severity2 = cv_dec_check_ (after (arg, ":"), code);
			if (code ^= 0)
			then goto INVALID_SEVERITY_RANGE;

			call log_match_$add_severity (opt.lmd_ptr, severity1, severity2);
		     end;
	     end;

	else if (really_looking_for = EXPAND_TYPE)
	then do;
		if (pass = DO_CONTROL_ARGS)
		then do;
			call log_expand_select_$add (opt.expand_select_ptr, arg, code);
			if (code ^= 0)
			then call ssu_$abort_line (sci_ptr, code, "Invalid expansion type/modes: ""^a"".", arg);
		     end;
	     end;
	else if really_looking_for = CALL_COMMAND
	then do;
		if (pass = DO_CONTROL_ARGS)
		then do;
			if opt.call_command.ptr ^= null ()
			then free opt_call_command_string;
			if arg ^= ""
			then do;
				opt.call_command.ptr = addr (arg);
				opt.call_command.length = length (arg);
			     end;
			else do;
				opt.call_command.ptr = null ();
				opt.call_command.length = 0;
				opt.call_given_sw = "0"b;
			     end;
		     end;
	     end;
	return;
     end process_looking_for;

two_logs:
     procedure;
	call ssu_$abort_line (sci_ptr, error_table_$too_many_args,
	     "Only one log may be specified, and ^a is the second.", arg);
	return;
     end two_logs;


get_next_arg:
     procedure (P_option);

	declare P_option		 char (*) varying parameter;


	if (arg_idx >= arg_count)
	then call ssu_$abort_line (sci_ptr, error_table_$noarg, "Value missing after ^a", arg);

	arg_idx = arg_idx + 1;
	call ssu_$arg_ptr (sci_ptr, arg_idx, arg_ptr, arg_lth);

	P_option = arg;

	return;
     end get_next_arg;


check_options:
     procedure ();

	declare action_opt		 (7) bit (1) unaligned;

	if (opt.pathname = "") & ^opt.time_given_sw & ^opt.status_sw
	then call ssu_$abort_line (sci_ptr, error_table_$noarg, "^/Usage:^-^a  LogPathname  {-control_args}",
		COMMAND_NAME);

	if (looking_for > 0)
	then call ssu_$abort_line (sci_ptr, error_table_$noarg, "After ^a", arg);

	string (action_opt) =
	     opt.add_sw || opt.remove_sw || opt.replace_sw || opt.modify_sw || opt.on_sw || opt.off_sw || opt.status_sw;
	if sum (bin (action_opt (*), 1)) > 1
	then call ssu_$abort_line (sci_ptr, 0,
		"Only one of -add, -remove, -replace, -modify, -on, -off, or -status may be given.");

	return;
     end check_options;

     end process_arguments$$find_log_and_action;


adjust_log_message_format:
     procedure (P_doing_what, P_doing_it_with);

	declare P_doing_what	 char (*) parameter;
	declare P_doing_it_with	 char (*) parameter;


	call format_log_message_$adjust (log_message_format_ptr, code);
	if (code = 0)
	then /* All OK */
	     return;

	call ssu_$abort_line (sci_ptr, code, "^a ^a",	/* Hope this identifies the source of error correctly */
	     P_doing_what, P_doing_it_with);		/* There are many possible errors from $adjust */

     end adjust_log_message_format;

/* format: off */
%page; %include log_message;
%page; %include log_message_format;
%page; %include log_read_open_info;
%page; %include monitor_sys_log_info_;
%include sub_err_flags;
        end monitor_sys_log;
