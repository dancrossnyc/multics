/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1989                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        *                                                         *
        *********************************************************** */

/* format: style2,indcomtxt */

ssl:
summarize_sys_log:
     procedure options (variable);

/**** This command scans a standard system log for specified text
      strings, writing information to pre-attached IO switches.

      A control file (in an archaic and incomprehensible format)
      controls what is written to the switches.

      Distribution of the output is controlled by the control file.
      This file has comment lines beginning with "*", and lines of the form

      .	streamname,S,opcode,text

      streamname	is the name of the stream on which a line will be written.
      S		Is the severity to be selected, in the form L:H
      .			*	selects all lines.
      opcode 	is the operation code (see below)
      text		is optional text which is the operand of opcode.

      Legal opcodes are:
      .	all	selects all lines at this severity
      .	any	selects all lines containing text
      .	begin	selects all lines beginning text
      .	not	inhibits all lines containing text
      .	nbegin	inhibits all lines beginning text
      .	count	counts all lines containing text
      .	bcount	counts all lines beginning text
      .	allx	same as all but binary data is expanded
      .	anyx	same as any but binary data is expanded
      .	beginx	same as begin, but binary data is expanded

      "not" and "nbegin" must precede any selectors they are to inhibit, for a given stream.

      At the end of processing, total lines are written. Then, if any lines were selected, a total count is output.

      THVV as daily_syserr_process
*/

/* Modified November 1975 by Larry Johnson for new syserr format */
/* Modified April 1976 by Larry Johnson to work correctly if first message read is "=" */
/* Modified September 1982 by E. N. Kittlitz to increase number of selectors and streams and check array bounds */
/* Modified 1984-12-03, BIM: converted to summarize_sys_log. */
/* Modified 1984-12-26, BIM: Added -continuation_indent. */
/* Modified 1985-02-21, Steve Herbst: Changed -dms to call dm_misc_util_$get_log_path */
/* Modified 1985-03-14, Steve Herbst: Fixed to recheck time range at end of find_first_message. Fixes bug where */
/*		if no messages within time range, procedure was getting the previous and next messages. */
/* Modified 1985-04-09, Steve Herbst: Fixed OOB caused by star-extent reference to switches_inhibited array */
/* Modified 1985-04-17, Steve Herbst: Fixed bug causing failure when using an already open output switch */
/* Modified 1985-05-02, Steve Herbst: Fixed to ensure from_time<=to_time. */


/****^  HISTORY COMMENTS:
  1) change(86-04-30,Kissel), approve(86-07-31,MCR7456), audit(86-08-01,Wong),
     install(86-11-03,MR12.0-1149):
     Modified to support DSA logs using the -dsasl and -dsasal control
     arguments.
  2) change(89-01-18,TLNguyen), approve(89-01-18,MCR8048),
     audit(89-02-23,RBarstad), install(89-03-01,MR12.3-1018):
     Fix the following errors:
        1. The -to control argument is ignored by summarize_sys_log.  The
           command processes the entry log from the date_time given in the
           -from control argument to the current date_time always.
        2. The command with no argument gets fault_tag_1.
                                                   END HISTORY COMMENTS */


	declare COMMAND_NAME	 char (32) int static init ("summarize_sys_log") options (constant);

	declare sci_ptr		 pointer;
	declare arg_count		 fixed bin;
	declare ap		 ptr;
	declare al		 fixed bin (21);
	declare arg		 char (al) based (ap);

	declare dm_system_log_path	 char (168);
	declare dsa_system_log_path	 char (168);
	declare code		 fixed bin (35);

	declare absolute_pathname_$add_suffix
				 entry (character (*), character (*), character (*), fixed binary (35));
	declare check_gate_access_	 entry (char (*), ptr, fixed bin (35));
	declare convert_date_to_binary_
				 entry (char (*), fixed bin (71), fixed bin (35));
	declare cu_$arg_list_ptr	 entry returns (pointer);
	declare com_err_		 entry () options (variable);
	declare cv_dec_check_	 entry (character (*), fixed binary (35)) returns (fixed binary (35));
	declare dm_misc_util_$get_log_path
				 entry (char (*));
	declare dsa_nit_$get_field	 entry (char (*), char (*), char (*), char (*), fixed bin (35));
	declare expand_pathname_	 entry (character (*), character (*), character (*), fixed binary (35));
	declare log_read_$open	 entry (character (*), character (*), pointer, fixed binary (35));
	declare log_read_$open_long	 entry (character (*), character (*), pointer, pointer, fixed binary (35));
	declare log_read_$free_message entry (pointer, pointer);
	declare log_read_$hold_message entry (pointer, pointer);
	declare log_read_$close	 entry (pointer, fixed binary (35));
	declare log_read_$next_message entry (pointer, pointer, fixed binary (35));
	declare log_read_$prev_message entry (pointer, pointer, fixed binary (35));
	declare format_log_message_$init
				 entry (pointer);
	declare format_log_message_$adjust
				 entry (pointer, fixed binary (35));
	declare format_log_message_$free
				 entry (pointer);
	declare format_log_message_$format
				 entry (pointer, pointer, pointer, character (*) var, character (*) var,
				 fixed binary (35));

	declare expand_log_message_	 entry (pointer, pointer, pointer, character (*) var, fixed binary (35));
	declare log_format_time_	 entry (fixed binary (71)) returns (character (32) var);
	declare log_limit_scan_	 entry (pointer, pointer, bit (1) aligned, pointer);

	declare log_match_$add_match	 entry (pointer, character (*));
	declare log_match_$add_severity
				 entry (pointer, fixed binary, fixed binary);
	declare log_match_$test	 entry (pointer, pointer, character (*) varying) returns (bit (1) aligned);
	declare log_match_$free	 entry (pointer);
	declare log_match_$print	 entry (pointer, pointer, fixed binary);

	declare ioa_		 entry options (variable);
	declare ioa_$ioa_switch	 ext entry options (variable);
	declare get_wdir_		 entry () returns (char (168));

	declare (addr, addwordno, after, before, hbound, index, length, ltrim, null, rtrim, substr, unspec)
				 builtin;


%include iox_entries;
%include iox_modes;
	declare pathname_		 entry (character (*), character (*)) returns (character (168));
	declare ssu_$arg_count	 entry (ptr, fixed bin);
	declare ssu_$get_area	 entry (ptr, ptr, char (*), ptr);
	declare ssu_$standalone_invocation
				 entry (ptr, char (*), char (*), ptr, entry, fixed bin (35));
	declare ssu_$destroy_invocation
				 entry (ptr);
	declare ssu_$arg_ptr	 entry (ptr, fixed bin, ptr, fixed bin (21));
	declare ssu_$abort_line	 entry () options (variable);
	declare ssu_$print_message	 entry () options (variable);
	declare ssu_$set_debug_mode	 entry (ptr, bit (1) aligned);

	declare unique_chars_	 entry (bit (*)) returns (char (15));

	declare log_data_$syserr_log_dir
				 char (168) external;
	declare log_data_$syserr_log_name
				 char (32) external;

	declare cleanup		 condition;

%include log_message;
%include log_message_format;
%include log_limit_info;
%include log_read_open_info;
	declare 1 log_open_info	 aligned like log_read_open_info;

	declare 1 opt		 aligned,
		2 log_read_ptr	 pointer,
		2 log_pathname	 char (168) unal,
		2 control_file_pathname
				 char (168) unal,
		2 limit		 aligned like log_limit_info,
		2 procedure	 char (32) unal,
		2 control_iocb	 pointer,
		2 long_sw		 bit (1) aligned,
		2 debug_sw	 bit (1) aligned;

	declare (
	        SYSERR_PATH		 init ("<<SYSERR>>"),
	        AS_PATH		 init ("<<AS>>"),
	        ADMIN_PATH		 init ("<<ADMIN>>"),
	        DM_PATH		 init ("<<DM>>"),
	        DSASL_PATH		 init ("<<DSASL>>"),
	        DSASAL_PATH		 init ("<<DSASAL>>")
	        )			 char (32) int static options (constant);

	declare 1 switches		 (1000) aligned,
		2 switch		 char (32) unal,
		2 prev_message_ptr	 pointer,
		2 iocb_ptr	 pointer,
		2 opened_here	 bit (1) aligned,	/* Opened by this program as a courtesy */
		2 message_count	 fixed bin,
		2 line_length	 fixed bin;

	declare 1 selectors		 (1000) aligned,
		2 switchx		 fixed bin,
		2 opcode		 fixed bin,
		2 match_ptr	 pointer,
		2 message_count	 fixed bin,
		2 exclude		 bit (1) aligned,	/* exclude all other selectors for the switch */
		2 expand		 bit (1) aligned;


	declare (n_switches, n_selectors)
				 fixed bin;

	declare line		 fixed bin;
	declare dir_name		 char (168);
	declare entryname		 char (32);
	declare buffer_space	 char (1000);
	declare buffer_length	 fixed bin (21);

	declare (
	        ALL		 init (1),
	        ANY		 init (2),
	        BEGIN		 init (3),
	        NOT		 init (4),
	        N_BEGIN		 init (5),
	        COUNT		 init (6),
	        B_COUNT		 init (7)
	        )			 fixed bin int static options (constant);
	declare DEFAULT_CONTROL_FILE	 char (32) init ("daily_report.ssl") int static options (constant);
	declare CONTROL_SUFFIX	 char (32) init ("ssl") int static options (constant);

	declare error_table_$not_attached
				 fixed bin (35) ext static;
	declare error_table_$end_of_info
				 fixed bin (35) ext static;
	declare error_table_$no_log_message
				 fixed bin (35) ext static;
	declare error_table_$bad_arg	 fixed bin (35) ext static;
	declare error_table_$badopt	 fixed bin (35) ext static;
	declare error_table_$moderr	 fixed bin (35) ext static;
	declare error_table_$noarg	 fixed bin (35) ext static;
	declare error_table_$noentry	 fixed bin (35) ext static;
	declare error_table_$too_many_args
				 fixed bin (35) ext static;
	declare error_table_$bad_conversion
				 fixed bin (35) ext static;


	declare DM_READER_PROCEDURE	 char (32) init ("dm_log_read_") int static options (constant);
	declare DSA_READER_PROCEDURE	 char (32) init ("dsa_log_admin_gate_") int static options (constant);



	sci_ptr = null ();
	log_message_format_ptr = null ();
	opt.log_read_ptr = null ();
	opt.control_iocb = null ();
	n_selectors, n_switches = 0;

	on cleanup call clean_up;

	call ssu_$standalone_invocation (sci_ptr, COMMAND_NAME, "1.0", cu_$arg_list_ptr (), SSU_ABORT, code);
	if code ^= 0
	then do;
		call com_err_ (code, COMMAND_NAME);
		return;
	     end;

	call ssu_$arg_count (sci_ptr, arg_count);
	if arg_count = 0
	then call ssu_$abort_line (sci_ptr, 0, "Usage: ^a LOG_PATHNAME {-control_arguments}", COMMAND_NAME);

	call initialize_options;
	call process_arguments;

/**** Now find things */

/**** The log itself */

	call make_log_pathname;			/* pathname of log */

	if opt.procedure ^= ""
	then do;
		log_open_info.version = LOG_READ_OPEN_INFO_VERSION_1;
		log_open_info.reader_procedure = opt.procedure;
		call ssu_$get_area (sci_ptr, null (), "log_read_ copies", log_open_info.allocation_area_ptr);
		log_open_info.allocate_copies = "0"b;	/* That is the inner-ring's job */
		call log_read_$open_long (dir_name, entryname, addr (log_open_info), opt.log_read_ptr, code);
	     end;
	else call log_read_$open (dir_name, entryname, opt.log_read_ptr, code);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code, "^a", opt.log_pathname);

	call read_control_file;

	call log_limit_scan_ (sci_ptr, addr (opt.limit), "0"b, opt.log_read_ptr);

	call find_first_message ();


	call print_limits (iox_$user_output, "1"b);

	call process_messages ();


	call clean_up;
	return;


clean_up:
     procedure;

	declare slx		 fixed bin;

	if opt.control_iocb ^= null ()
	then do;
		call iox_$close (opt.control_iocb, (0));
		call iox_$detach_iocb (opt.control_iocb, (0));
		call iox_$destroy_iocb (opt.control_iocb, (0));
	     end;

	if opt.log_read_ptr ^= null ()
	then call log_read_$close (opt.log_read_ptr, (0));
	if log_message_format_ptr ^= null ()
	then call format_log_message_$free (log_message_format_ptr);
	do slx = 1 to n_selectors;
	     if selectors (slx).match_ptr ^= null ()
	     then call log_match_$free (selectors (slx).match_ptr);
	end;
	do slx = 1 to n_switches;
	     if switches (slx).opened_here
	     then call iox_$close (switches (slx).iocb_ptr, (0));
	end;

	if sci_ptr ^= null ()
	then call ssu_$destroy_invocation (sci_ptr);

	return;

     end clean_up;


make_log_pathname:
     procedure ();


	if (opt.log_pathname = SYSERR_PATH)
	then do;
		dir_name = log_data_$syserr_log_dir;
		entryname = log_data_$syserr_log_name;
		opt.log_pathname = pathname_ (dir_name, entryname);
	     end;

	else if opt.log_pathname = AS_PATH
	then do;
		dir_name = ">system_control_dir>as_logs";
		entryname = "log";
		opt.log_pathname = pathname_ (dir_name, entryname);
	     end;
	else if opt.log_pathname = ADMIN_PATH
	then do;
		dir_name = ">system_control_dir>as_logs";
		entryname = "admin_log";
		opt.log_pathname = pathname_ (dir_name, entryname);
	     end;
	else if opt.log_pathname = DM_PATH
	then do;
		call dm_misc_util_$get_log_path (dm_system_log_path);
		call expand_pathname_ (dm_system_log_path, dir_name, entryname, 0);
		opt.procedure = DM_READER_PROCEDURE;
		opt.log_pathname = dm_system_log_path;
	     end;
	else if opt.log_pathname = DSASL_PATH
	then do;

		/*** Check to see if we will succeed. */

		call check_gate_access_ (DSA_READER_PROCEDURE, null (), code);

		if code = error_table_$noentry
		then call ssu_$abort_line (sci_ptr, error_table_$bad_arg, "DSA is not installed on this system.");
		else if code = error_table_$moderr
		then call ssu_$abort_line (sci_ptr, code, "You need e access to ^a to read the DSA log.",
			DSA_READER_PROCEDURE);
		else if code ^= 0
		then call ssu_$abort_line (sci_ptr, code, "Trying to check the access to: ^a.", DSA_READER_PROCEDURE);

		/*** The code was 0, proceed. */

		else call dsa_nit_$get_field ("mna_general_info", "", "dsa_system_log", dsa_system_log_path, code);

		if code ^= 0
		then call ssu_$abort_line (sci_ptr, code, "Cannot find the name of the dsa system log.");

		call expand_pathname_ (dsa_system_log_path, dir_name, entryname, 0);
		opt.procedure = DSA_READER_PROCEDURE;
		opt.log_pathname = dsa_system_log_path;
	     end;
	else if opt.log_pathname = DSASAL_PATH
	then do;

		/*** Check to see if we will succeed. */

		call check_gate_access_ (DSA_READER_PROCEDURE, null (), code);

		if code = error_table_$noentry
		then call ssu_$abort_line (sci_ptr, error_table_$bad_arg, "DSA is not installed on this system.");
		else if code = error_table_$moderr
		then call ssu_$abort_line (sci_ptr, code, "You need e access to ^a to read the DSA log.",
			DSA_READER_PROCEDURE);
		else if code ^= 0
		then call ssu_$abort_line (sci_ptr, code, "Trying to check the access to: ^a.", DSA_READER_PROCEDURE);

		/*** The code was 0, proceed. */

		else call dsa_nit_$get_field ("mna_general_info", "", "dsa_system_aep_log", dsa_system_log_path, code)
			;

		if code ^= 0
		then call ssu_$abort_line (sci_ptr, code, "Cannot find the name of the dsa system aep log.");

		call expand_pathname_ (dsa_system_log_path, dir_name, entryname, 0);
		opt.procedure = DSA_READER_PROCEDURE;
		opt.log_pathname = dsa_system_log_path;
	     end;

	else do;
		call expand_pathname_ (opt.log_pathname, dir_name, entryname, code);
		if (code ^= 0)
		then call ssu_$abort_line (sci_ptr, code, "Log pathname ^a", opt.log_pathname);
	     end;

	return;
     end make_log_pathname;


process_line:
     procedure;

	declare buffer		 char (buffer_length - 1) /* NO NL */ defined (buffer_space) pos (1);
	declare commax		 fixed bin (21);
	declare switch_name		 char (32);
	declare switchx		 fixed bin;
	declare 1 a_switch		 aligned like switches based (asp);
	declare asp		 pointer;
	declare 1 a_select		 aligned like selectors based (aslp);
	declare aslp		 pointer;
	declare match_text		 char (500) varying;
	declare new_commax		 fixed bin (21);
	declare (severity1, severity2) fixed bin;
	declare start_line		 bit (1) aligned;
	declare severity_string	 char (32);
	declare opcode_string	 char (32);
	declare text_required	 bit (1) aligned;

	line = line + 1;
	if substr (buffer, 1, 1) = "*"
	then return;

	commax = index (buffer, ",");
	if commax = 0
	then call ssu_$abort_line (sci_ptr, (0), "Error on line ^d: No comma after the switch name ^a.", line, buffer);
	if commax = 1
	then call ssu_$abort_line (sci_ptr, (0), "Error on line ^d:  Null switch name.", line);

	switch_name = ltrim (substr (buffer, 1, commax - 1));
	do switchx = 1 to n_switches;
	     if switch_name = switches (switchx).switch
	     then do;
		     asp = addr (switches (switchx));
		     go to FOUND_SWITCH;
		end;
	end;

/* switchx is now 1 past n_switches. */

	if switchx >= hbound (switches, 1)
	then call ssu_$abort_line (sci_ptr, error_table_$too_many_args,
		"Error on line ^d: Limit of ^d switches exceeded.", line, hbound (switches, 1));
	n_switches = switchx;

	asp = addr (switches (switchx));

	a_switch.switch = switch_name;
	a_switch.prev_message_ptr = null ();
	a_switch.opened_here = "0"b;			/* Until proven elsewise */
	call iox_$look_iocb (switch_name, a_switch.iocb_ptr, code);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code, "Error on line ^d: Switch ^a not attached.", line, switch_name);
	a_switch.message_count = 0;
	call check_switch_state;

FOUND_SWITCH:
	if n_selectors = hbound (selectors, 1)
	then call ssu_$abort_line (sci_ptr, error_table_$too_many_args,
		"Error on line ^d: more than ^d selection lines.", line, hbound (selectors, 1));

	n_selectors = n_selectors + 1;
	aslp = addr (selectors (n_selectors));

	a_select.switchx = switchx;
	a_select.match_ptr = null ();
	a_select.message_count = 0;
	a_select.expand = "0"b;

/**** next we look for the severity */

	new_commax = index (substr (buffer, commax + 1), ",");
	if new_commax = 0
	then call ssu_$abort_line (sci_ptr, (0), "Error on line ^d: No comma after the severity for switch ^a.", line,
		switch_name);

	severity_string = substr (buffer, commax + 1, new_commax - 1);
	if length (severity_string) = 0
	then call ssu_$abort_line (sci_ptr, 0, "Error on line ^d: null severity.", line);
	commax = commax + new_commax;

	if severity_string = "*"
	then ;
	else do;					/* something here */
		severity1 = cv_dec_check_ (before (severity_string, ":"), code);
		if (code ^= 0)
		then
INVALID_SEVERITY_RANGE:
		     call ssu_$abort_line (sci_ptr, error_table_$bad_conversion,
			"Error on line ^d: Invalid severity value ""^a"": must be <N> or <N>:<M> or *", line,
			severity_string);

		if (index (severity_string, ":") = 0)
		then /* Not a range, just a single number */
		     severity2 = severity1;
		else severity2 = cv_dec_check_ (after (severity_string, ":"), code);
		if (code ^= 0)
		then goto INVALID_SEVERITY_RANGE;

		call log_match_$add_severity (a_select.match_ptr, severity1, severity2);

	     end;

/**** Next, the opcode */

	new_commax = index (substr (buffer, commax + 1), ",");

	if new_commax = 0
	then do;
		opcode_string = substr (buffer, commax + 1);
		commax = 0;			/* flag no text */
	     end;
	else do;
		opcode_string = substr (buffer, commax + 1, new_commax - 1);
		commax = commax + new_commax;
	     end;

	if opcode_string = ""
	then call ssu_$abort_line (sci_ptr, 0, "Error on line ^d: null opcode.", line);
	text_required = "0"b;
	a_select.exclude = "0"b;
	start_line = "0"b;
	if opcode_string = "all"
	then a_select.opcode = ALL;
	else if opcode_string = "any"
	then do;
		a_select.opcode = ANY;
		text_required = "1"b;
	     end;
	else if opcode_string = "begin"
	then do;
		a_select.opcode = BEGIN;
		text_required = "1"b;
		start_line = "1"b;
	     end;
	else if opcode_string = "not"
	then do;
		a_select.opcode = NOT;
		text_required = "1"b;
		a_select.exclude = "1"b;
	     end;
	else if opcode_string = "nbegin"
	then do;
		a_select.opcode = N_BEGIN;
		start_line = "1"b;
		a_select.exclude = "1"b;
		text_required = "1"b;
	     end;
	else if opcode_string = "count"
	then a_select.opcode = COUNT;
	else if opcode_string = "bcount"
	then do;
		a_select.opcode = B_COUNT;
		start_line = "1"b;
		text_required = "1"b;
	     end;
	else if opcode_string = "allx"
	then do;
		a_select.opcode = ALL;
		a_select.expand = "1"b;
	     end;
	else if opcode_string = "anyx"
	then do;
		a_select.opcode = ANY;
		a_select.expand = "1"b;
		text_required = "1"b;
	     end;
	else if opcode_string = "beginx"
	then do;
		a_select.opcode = BEGIN;
		a_select.expand = "1"b;
		text_required = "1"b;
		start_line = "1"b;
	     end;
	else call ssu_$abort_line (sci_ptr, 0, "Error on line ^d: Invalid opcode ^a.", line, opcode_string);


	if text_required & commax = 0
	then call ssu_$abort_line (sci_ptr, 0, "Error on line ^d: the opcode ^a requires a selector string.", line,
		opcode_string);


	if commax > 1
	then do;					/* add the match string */
		match_text = ltrim (rtrim (substr (buffer, commax + 1)));
		if start_line
		then do;
			match_text = "/^" || match_text;
			match_text = match_text || "/";
		     end;
		call log_match_$add_match (a_select.match_ptr, (match_text));
	     end;
	return;                                           /* return from process_line internal procedure */
%page;

/**** This procedure is not a "valid" use of iox_. However, there is
      really no better way to find out whether a switch is open.
      Doing I/O and looking at the return code is not reasonable. */

check_switch_state:
     procedure;

	if a_switch.iocb_ptr -> iocb.attach_data_ptr = null ()
	then call ssu_$abort_line (sci_ptr, error_table_$not_attached, "Error on line ^d: Switch ^a.", line,
		a_switch.switch);
	if a_switch.iocb_ptr -> iocb.open_descrip_ptr = null ()
	then do;
		a_switch.opened_here = "1"b;
		call iox_$open (a_switch.iocb_ptr, Stream_output, "0"b, code);
		if code ^= 0
		then call ssu_$abort_line (sci_ptr, code,
			"Error on line ^d: Failed to open switch ^a for stream_output.", line, a_switch.switch);
	     end;
	return;                                           /* return from check_switch_state internal procedure */


%include iocb;


     end check_switch_state;

     end process_line;


process_arguments:
     procedure;

	declare argx		 fixed bin;
	declare v_log_ename		 char (32) varying;
	declare number_arg		 char (32) varying;
	declare temp_number		 fixed bin;
	declare (from_time, to_time)	 fixed bin (71);
	declare exchange_opt	 char (50) varying;
	declare code		 fixed bin (35);

	do argx = 1 to arg_count;
	     call ssu_$arg_ptr (sci_ptr, argx, ap, al);
	     if index (arg, "-") ^= 1
	     then do;
		     if opt.log_pathname ^= ""
		     then call two_logs;
		     opt.log_pathname = arg;
		end;
	     else if (arg = "-syserr")
	     then do;
		     if opt.log_pathname ^= ""
		     then call two_logs;
		     opt.log_pathname = SYSERR_PATH;
		end;

	     else if (arg = "-answering_service") | (arg = "-as")
	     then do;
		     if opt.log_pathname ^= ""
		     then call two_logs;
		     opt.log_pathname = AS_PATH;
		end;
	     else if (arg = "-admin")
	     then do;
		     if opt.log_pathname ^= ""
		     then call two_logs;
		     opt.log_pathname = ADMIN_PATH;
		end;
	     else if (arg = "-dm_system") | (arg = "-dms")
	     then do;
		     if opt.log_pathname ^= ""
		     then call two_logs;
		     opt.log_pathname = DM_PATH;
		end;
	     else if (arg = "-dsa_sys_log") | (arg = "-dsasl")
	     then do;
		     if opt.log_pathname ^= ""
		     then call two_logs;
		     opt.log_pathname = DSASL_PATH;
		end;
	     else if (arg = "-dsa_sys_aep_log") | (arg = "-dsasal")
	     then do;
		     if opt.log_pathname ^= ""
		     then call two_logs;
		     opt.log_pathname = DSASAL_PATH;
		end;
	     else if (arg = "-mc_log") | (arg = "-mcl")
	     then do;
		     if opt.log_pathname ^= ""
		     then call two_logs;
		     call get_next_arg (v_log_ename);
		     opt.log_pathname = pathname_ (">system_control_dir>as_logs", (v_log_ename));
		end;

	     else if (arg = "-from") | (arg = "-fm")
	     then call get_next_arg (opt.limit.from_opt);
	     else if (arg = "-last") | (arg = "-lt")
	     then call get_next_arg (opt.limit.last_opt);
	     else if (arg = "-to")
	     then call get_next_arg (opt.limit.to_opt);
	     else if (arg = "-for") | (arg = "-next")
	     then call get_next_arg (opt.limit.for_opt);


	     else if (arg = "-control")
	     then do;
		     if argx = arg_count
		     then call ssu_$abort_line (sci_ptr, error_table_$noarg,
			     "-control must be followed by a control file pathname.");
		     argx = argx + 1;
		     call ssu_$arg_ptr (sci_ptr, argx, ap, al);
		     opt.control_file_pathname = arg;
		end;

	     else if (arg = "-long") | (arg = "-lg")
	     then opt.long_sw = "1"b;
	     else if (arg = "-brief") | (arg = "-bf")
	     then opt.long_sw = "0"b;
	     else if (arg = "-debug") | (arg = "-db")
	     then do;
		     opt.debug_sw = "1"b;
		     call ssu_$set_debug_mode (sci_ptr, "1"b);
		end;
	     else if (arg = "-procedure") | (arg = "-proc")
	     then do;
		     if argx = arg_count
		     then call ssu_$abort_line (sci_ptr, error_table_$noarg,
			     "-procedure must be followed by a log reading procedure.");
		     argx = argx + 1;
		     call ssu_$arg_ptr (sci_ptr, argx, ap, al);
		     opt.procedure = arg;
		end;

	     else if (arg = "-number_format") | (arg = "-nfmt")
	     then do;
		     call get_next_arg (log_message_format.number_format);
		     call format_log_message_$adjust (log_message_format_ptr, code);
		     if code ^= 0
		     then call ssu_$abort_line (sci_ptr, code, "Processing -number_format",
			     log_message_format.number_format);
		end;

	     else if (arg = "-indent") | (arg = "-ind") | (arg = "-in")
	     then do;
		     call get_next_arg (number_arg);
		     log_message_format.indentation = cv_dec_check_ ((number_arg), code);
		     if (code ^= 0) | (log_message_format.indentation < 0) | (log_message_format.indentation > 50)
		     then call ssu_$abort_line (sci_ptr, error_table_$bad_conversion,
			     "Indentation must be between 0 and 50, not ^a", number_arg);

		     call format_log_message_$adjust (log_message_format_ptr, code);
		     if code ^= 0
		     then call ssu_$abort_line (sci_ptr, code, "Processing -indent ^a", number_arg);
		end;				/* Of -indent processing */
	     else if (arg = "-continuation_indent") | (arg = "-ci")
	     then do;
		     call get_next_arg (number_arg);
		     if number_arg = "std" | number_arg = "standard"
		     then log_message_format.continuation_indent = -1;
		     else do;
			     log_message_format.continuation_indent = cv_dec_check_ ((number_arg), code);
			     if (code ^= 0) | (log_message_format.continuation_indent < 0)
				| (log_message_format.continuation_indent > 50)
			     then call ssu_$abort_line (sci_ptr, error_table_$bad_conversion,
				     "Continuation indent must be between 0 and 50 or ""standard"", not ^a",
				     number_arg);
			end;
		     call format_log_message_$adjust (log_message_format_ptr, code);
		     if code ^= 0
		     then call ssu_$abort_line (sci_ptr, code,
			     "Failed to adjust log message format after processing -continuation_indent ^a.", arg);
		end;				/* Of -continuation_indent processing */


	     else if (arg = "-prefix") | (arg = "-pfx")
	     then do;
		     call get_next_arg (log_message_format.prefix);
		     call format_log_message_$adjust (log_message_format_ptr, code);
		     if code ^= 0
		     then call ssu_$abort_line (sci_ptr, code, "Error processing -prefix ^a",
			     log_message_format.prefix);
		end;				/* Of -prefix processing */


	     else if (arg = "-time_format") | (arg = "-tfmt")
	     then do;
		     call get_next_arg (log_message_format.time_format);
		     call format_log_message_$adjust (log_message_format_ptr, code);
		     if code ^= 0
		     then call ssu_$abort_line (sci_ptr, "Processing -time_format ^a", log_message_format.time_format)
			     ;
		end;

	     else if (arg = "-date_format") | (arg = "-dfmt")
	     then do;
		     call get_next_arg (log_message_format.date_format);
		     call format_log_message_$adjust (log_message_format_ptr, code);
		     if code ^= 0
		     then call ssu_$abort_line (sci_ptr, code, "Processing -date_format ^a",
			     log_message_format.date_format);
		end;

	     else call ssu_$abort_line (sci_ptr, error_table_$badopt, "^a", arg);
	end;


/**** Okay, do we have some needful args? */

	if opt.log_pathname = ""
	then call ssu_$abort_line (sci_ptr, error_table_$noarg, "Usage: ^a LOG_PATHNAME -control_args", COMMAND_NAME);

/* Make sure the -from time is less than the -to time */

	if opt.limit.from_opt ^= "" & opt.limit.to_opt ^= ""
	then do;
		temp_number = cv_dec_check_ ((opt.limit.from_opt), code);
		if code ^= 0
		then do;
			temp_number = cv_dec_check_ ((opt.limit.to_opt), code);
			if code ^= 0
			then do;
				call convert_date_to_binary_ ((opt.limit.from_opt), from_time, 0);
				call convert_date_to_binary_ ((opt.limit.to_opt), to_time, 0);
				if from_time > to_time
				then do;
					exchange_opt = opt.limit.from_opt;
					opt.limit.from_opt = opt.limit.to_opt;
					opt.limit.to_opt = exchange_opt;
				     end;
			     end;
		     end;
	     end;

	return;                       /* complete process_arguments procedure */

%page;
/* the following procedures are internal to the process_arguments procedure */

/*-------------------- get_next_arg internal procedure -------------------- */
get_next_arg:
     procedure (P_option);

	declare P_option		 char (*) varying parameter;


	if (argx >= arg_count)
	then call ssu_$abort_line (sci_ptr, error_table_$noarg, "Value missing after ^a", arg);

	argx = argx + 1;
	call ssu_$arg_ptr (sci_ptr, argx, ap, al);

	P_option = arg;

	return;
     end get_next_arg;

/*---------------------- two_logs internal procedure ---------------------- */
two_logs:
     procedure;

	call ssu_$abort_line (sci_ptr, 0, "More than one log was specified on the input line.  ""^a"" was the second log.", arg);

	return;
     end two_logs;

/* complete all internal procedures which are called by process_arguments */

     end process_arguments;

%page;
initialize_options:
     procedure;


	opt.control_iocb, opt.log_read_ptr = null ();
	opt.long_sw = "0"b;
	opt.debug_sw = "0"b;
	opt.log_pathname, opt.control_file_pathname = "";
	opt.control_file_pathname = pathname_ (get_wdir_ (), DEFAULT_CONTROL_FILE);
	opt.limit.version = LOG_LIMIT_INFO_VERSION_1;
	opt.limit.to_opt = "";			/* Set up to call the limit scanner */
	opt.limit.from_opt = "";
	opt.limit.for_opt = "";
	opt.limit.last_opt = "";
	opt.procedure = "";
	call format_log_message_$init (log_message_format_ptr);
	log_message_format.caller = COMMAND_NAME;
	log_message_format.line_lth = 132;
	log_message_format.indentation = 0;
	log_message_format.equal_sw = "0"b;
	log_message_format.error_sw = "1"b;
	log_message_format.prefix = "";
	call format_log_message_$adjust (log_message_format_ptr, code);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code, "Failed to adjust initial log message format.");

	return;
     end initialize_options;

%page;
read_control_file:
     procedure;
	declare control_iocb_name	 char (32);

	call absolute_pathname_$add_suffix ((opt.control_file_pathname), CONTROL_SUFFIX, opt.control_file_pathname,
	     code);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code, "^a", opt.control_file_pathname);

	control_iocb_name = "summarize_sys_log" || unique_chars_ (""b);
	call iox_$attach_name (control_iocb_name, opt.control_iocb, "vfile_ " || opt.control_file_pathname, null (),
	     code);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code, "Failed to attach ^a", opt.control_file_pathname);
	call iox_$open (opt.control_iocb, Stream_input, "0"b, code);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code, "Failed to open ^a", opt.control_file_pathname);

	n_switches, n_selectors = 0;

	code = 0;
	line = 0;
	do while (code ^= error_table_$end_of_info);
	     call iox_$get_line (opt.control_iocb, addr (buffer_space), length (buffer_space), buffer_length, code);
	     if code = 0
	     then call process_line;
	     else if code ^= error_table_$end_of_info
	     then do;
		     line = line + 1;		/* we skipped a line */
		     call ssu_$print_message (sci_ptr, code, "Error reading line ^d.", line);
		end;
	end;

	call iox_$close (opt.control_iocb, (0));
	call iox_$detach_iocb (opt.control_iocb, (0));
	call iox_$destroy_iocb (opt.control_iocb, (0));
	opt.control_iocb = null ();

	call ioa_ ("^a: ^d streams, ^d selectors", COMMAND_NAME, n_switches, n_selectors);

	if n_selectors = 0 | n_switches = 0
	then call ssu_$abort_line (sci_ptr, error_table_$noarg,
		"There must be at least one switch and at least one selctor.");
	return;
     end read_control_file;

%page;
print_limits:
     procedure (iocb, identify);

	declare iocb		 pointer;
	declare identify		 bit (1) aligned;

	if (opt.first_msg = null ())
	then call ioa_$ioa_switch (iocb, "^[^a ^;^s^]Log ^a to ^a", identify, COMMAND_NAME, opt.log_pathname,
		log_format_time_ ((opt.last_msg -> log_message.time)));

	else if (opt.last_msg = null ())
	then call ioa_$ioa_switch (iocb, "^[^a: ^;^s^]Log ^a from ^a", identify, COMMAND_NAME, opt.log_pathname,
		log_format_time_ ((opt.first_msg -> log_message.time)));
	else call ioa_$ioa_switch (iocb, "^[^a: ^;^s^]Log ^a from ^a to ^a", identify, COMMAND_NAME, opt.log_pathname,
		log_format_time_ ((opt.first_msg -> log_message.time)),
		log_format_time_ ((opt.last_msg -> log_message.time)));

	return;
     end print_limits;


find_first_message:
     procedure ();

	declare total_count		 fixed bin;
	declare hold_message_sw	 bit (1);

	total_count = 0;

/* This procedure locates the message we're going to start with, in case we're
   doing something like "-last 10", where log_limit_scan_ can't determine the
   real starting point because it might depend (if we had -match) on message
   content. */

	hold_message_sw = "0"b;
	if (opt.first_msg ^= null ())
	then /* We know where we're starting */
	     go to FOUND;

/* Otherwise, we look backwards to find where to start.  We are guaranteed,
   by log_limit_scan_, that at least one limit is non-null, and also that if
   one is null, there is a limit count. If, however, we run out of messages
   before we hit the limit, that's still OK, and we print all that we have. */

	log_message_ptr = opt.last_msg;

	do total_count = 1 by 1 while (total_count < opt.msg_count);

	     call log_read_$prev_message (opt.log_read_ptr, log_message_ptr, code);
	     if (code ^= 0)
	     then do;
		     if code = error_table_$no_log_message
		     then log_message_ptr = null ();
		     else call ssu_$abort_line (sci_ptr, code,
			     "Internal error: Failed to find message before message ^p.", log_message_ptr);
		end;
	     if (log_message_ptr = null ())
	     then /* If we've run out, terminate the loop */
		total_count = opt.msg_count;
	end;

	if (log_message_ptr = null ())
	then
NO_MESSAGES:
	     call ssu_$abort_line (sci_ptr, 0, "No messages matched criteria. ^d message^[s^] read.", total_count,
		(total_count ^= 1));

	opt.first_msg = log_message_ptr;
	hold_message_sw = "1"b;

FOUND:
	if hold_message_sw
	then call log_read_$hold_message (opt.log_read_ptr, opt.first_msg);
	return;
     end find_first_message;


process_messages:
     procedure;

/* Following code is the processing loop on log entries.
   Each line is checked against all selectors to see if it should be written. */
	declare total_messages	 fixed bin (35);
	declare slx		 fixed bin;
	declare s_iocb		 pointer;

	total_messages = 0;

	do slx = 1 to n_switches;
	     call print_limits (switches (slx).iocb_ptr, "0"b);
	     call ioa_$ioa_switch (switches (slx).iocb_ptr, "");
	end;

	if opt.long_sw
	then call ioa_ ("^/SUMMARY OF SELECTORS:^/");
	do slx = 1 to n_selectors;
	     if opt.long_sw
	     then do;
		     call ioa_ ("^3d ^a ^[all^;any^;begin^;not^;nbegin^;count^;bcount^]^[x^]", slx,
			switches (selectors (slx).switchx).switch, selectors (slx).opcode, selectors (slx).expand);
		     if selectors (slx).match_ptr ^= null ()
		     then call log_match_$print (selectors (slx).match_ptr, iox_$user_output, 5);
		end;

	     s_iocb = switches (selectors (slx).switchx).iocb_ptr;
	     call ioa_$ioa_switch (s_iocb, "^/^3d  ^a ^[all^;any^;begin^;not^;nbegin^;count^;bcount^]^[x^]", slx,
		switches (selectors (slx).switchx).switch, selectors (slx).opcode, selectors (slx).expand);
	     if selectors (slx).match_ptr ^= null ()
	     then call log_match_$print (selectors (slx).match_ptr, s_iocb, 5);
	     else call ioa_$ioa_switch (s_iocb, "^5xAll severities.");
	     call ioa_$ioa_switch (s_iocb, "");
	end;


	log_message_ptr = opt.first_msg;
	do while (log_message_ptr ^= null ());   /* Catch running out of messages */
                                                   /* determine whether the current message matches selection criteria. */
                                                   /* If it matches then print it out. */
	     call process_log_message;

                                                   /* Determine whether the specified last message (-to TIME, -to NUMBER) has been reached. */
	     if log_message_ptr = opt.last_msg
	     then log_message_ptr = null;        /* indicates that all requested messages are completely processed. */
	     else do;                            /* The -to control argument is not specified. */
                                                   /* so continue to process all remaining messages in the log ( by default) */
		     call log_read_$next_message (opt.log_read_ptr, log_message_ptr, code);
		     if code ^= 0
		     then do;
                                                   /* terminate the do while loop */
			     log_message_ptr = null ();

		               if code ^= error_table_$no_log_message
		               then call ssu_$print_message (sci_ptr, code, "Reading next message.");
		          end;
	         end;
	end;                                    /* process all mesages in the log */


	/*** Skip lines on all switches */

	do slx = 1 to n_switches;
	     call ioa_$ioa_switch (switches (slx).iocb_ptr, "");
	end;

/**** Write summary lines for selectors */

	do slx = 1 to n_selectors;
	     if selectors (slx).opcode = COUNT | selectors (slx).opcode = B_COUNT
	     then do;
		     call ioa_$ioa_switch (switches (selectors (slx).switchx).iocb_ptr, "^d messages:",
			selectors (slx).message_count);
		     call log_match_$print (selectors (slx).match_ptr, switches (selectors (slx).switchx).iocb_ptr,
			5 /* indent */);
		end;
	end;

/**** Write  summary for stream */

	do slx = 1 to n_switches;
	     call ioa_$ioa_switch (switches (slx).iocb_ptr, "^/TOTAL: ^d written.", switches (slx).message_count);
	end;

	call ioa_ ("summarize_sys_log: ^d messages read.", total_messages);
	return;                                           /* return from process_messages internal procedure */


process_log_message:
     procedure;
	declare text_buffer		 char (5000) varying;
	declare expand_buffer	 char (5000) varying;
	declare slx		 fixed bin;
	declare test_sw		 bit (1) aligned;
	declare switches_inhibited	 (1000) bit (1) unaligned;

	total_messages = total_messages + 1;
	unspec (switches_inhibited) = "0"b;		/* no NOTs yet */
	do slx = 1 to n_selectors;
	     if switches_inhibited (selectors (slx).switchx)
	     then call SKIP_SELECT;
	     if selectors (slx).match_ptr ^= null ()
	     then do;
		     test_sw = log_match_$test (selectors (slx).match_ptr, log_message_ptr, "");
		     if selectors (slx).exclude
		     then do;
			     if test_sw
			     then switches_inhibited (selectors (slx).switchx) = "1"b;
			     call SKIP_SELECT;
			end;
		     else if ^test_sw
		     then call SKIP_SELECT;
		end;

	     selectors (slx).message_count = selectors (slx).message_count + 1;
	     expand_buffer = "";
	     if selectors (slx).expand
	     then call expand_log_message_ (log_message_format_ptr, log_message_ptr, null (), expand_buffer, code);

	     call format_log_message_$format (log_message_format_ptr, log_message_ptr,
		switches (selectors (slx).switchx).prev_message_ptr, expand_buffer, text_buffer, (0));

	     call iox_$put_chars (switches (selectors (slx).switchx).iocb_ptr, addwordno (addr (text_buffer), 1),
		length (text_buffer), (0));

	     if switches (selectors (slx).switchx).prev_message_ptr ^= null ()
	     then call log_read_$free_message (opt.log_read_ptr, switches (selectors (slx).switchx).prev_message_ptr);
	     call log_read_$hold_message (opt.log_read_ptr, log_message_ptr);
	     switches (selectors (slx).switchx).prev_message_ptr = log_message_ptr;
	     switches (selectors (slx).switchx).message_count = switches (selectors (slx).switchx).message_count + 1;

SKIP_SELECTOR:
	end;


SKIP_SELECT:
     procedure;
	go to SKIP_SELECTOR;
     end SKIP_SELECT;


     end process_log_message;

     end process_messages;


SSU_ABORT:
     procedure;
	call clean_up;
	go to ABORT;
     end SSU_ABORT;
ABORT:
	return;

     end summarize_sys_log;
