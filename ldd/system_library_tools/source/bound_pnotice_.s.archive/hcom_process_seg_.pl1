/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1990   *
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1985 *
        *                                                         *
        *********************************************************** */

/****^  HISTORY COMMENTS:
  1) change(1985-09-03,LJAdams), approve(1985-11-06,MCR7278),
     audit(1986-02-19,Gilcrease), install(1986-03-06,MR12.0-1021):
     Program to process each individual segment to
     determine if there are or are not history comments present and update
     accordingly.
  2) change(1986-03-05,LJAdams), approve(1986-03-05,MCR7278),
     audit(1986-03-05,Gilcrease), install(1986-03-06,MR12.0-1029):
     Reformat summary when the format command is issued.
  3) change(1986-04-17,LJAdams), approve(1986-04-17,MCR7386),
     audit(1986-05-27,Gilcrease), install(1986-06-05,MR12.0-1071):
     Add an argument to indicated fill mode on (-fill, -fi) or fill mode off
     (-no_fill, -nfi) for the summary fields for the add operation.  The
     default will be fill mode.  Change the format operation to allow comment
     specification for reformatting.
  4) change(1986-05-05,LJAdams), approve(1986-05-08,MCR7414),
     audit(1986-05-27,Gilcrease), install(1986-06-05,MR12.0-1071):
     Moved the validation error reporting out of here and into hcom_parse_.rd.
  5) change(1986-05-21,LJAdams), approve(1986-05-27,MCR7429),
     audit(1986-05-27,Gilcrease), install(1986-06-05,MR12.0-1071):
     While doing the check option if no comments were found that met the check
     criteria all comments were being displayed as in error; rather than
     displaying all the comments an error message will be put out stating: No
     comments were found with all fields present except the install field.
     
     When doing the compare operation the NL was being included as part of the
     summary for the src_array but not the orig_array.
  6) change(1986-07-07,LJAdams), approve(1986-07-07,MCR7429),
     audit(1986-07-07,Hartogs), install(1986-07-07,MR12.0-1087):
     PBF for ID 1021.  ck operation was erroneously passing comments missing
     the audit field; depending on their sequence in the history comment block.
     Dates greater than the current date were being accepted.
  7) change(1986-07-08,LJAdams), approve(1986-07-08,MCR7429),
     audit(1986-07-08,Brunelle), install(1986-07-08,MR12.0-1088):
     PBF for ID 1021.  Change error message wording for ck failure.
  8) change(1986-08-08,LJAdams), approve(1986-08-19,MCR7526),
     audit(1986-11-05,GDixon), install(1986-11-12,MR12.0-1213):
     Change the method of determining the size of the copy of the comment to
     use the relative character offset and not the actual offset to determine
     the size of the length of the copy.
     
     Fixed problem with include files - if there was a format error the status
     was still being returned as true instead of false.
     
     Added check so that if hcom_parse_ found a critical fix number present
     only critical fix values can be added.  If critical fix number present
     the INSTALL operation is invalid unless -cfix specified.
     
     Fixed null pointer problem - field in orig array was being checked when
     the pointer to orig_array had not been set.
     
     Changed design so that comments in the original and the source need not
     be in comment number order as long as all the comments in the original
     are found in the source.
     
     phx20629:  Changed error_table_$badstar to error_table_$bad_file_name.
  9) change(1987-03-16,LJAdams), approve(1987-04-22,MCR7653),
     audit(1987-04-02,Gilcrease), install(1987-04-26,MR12.1-1026):
     Added support for C header (.h) files.  They are treated as type 1
     include files.  (phx20795)
 10) change(1987-03-26,LJAdams), approve(1987-03-26,MCR7653),
     audit(1987-04-02,Gilcrease), install(1987-04-26,MR12.1-1026):
     If the comment length is greater than max length allowed display error
     message; for a display operation continue; for modify operation halt so as
     not to damage given segment."
 11) change(1987-03-30,LJAdams), approve(1987-03-30,MCR7653),
     audit(1987-04-02,Gilcrease), install(1987-04-26,MR12.1-1026):
     Display error msg for old history comments that have a null approve, null
     audit, and/or are missing or have a non-null value for the install field.
 12) change(1987-04-28,LJAdams), approve(1987-04-28,PBF7653),
     audit(1987-04-28,Farley), install(1987-05-08,MR12.1-1031):
     Change checking for .h include files to exclude .header files.
 13) change(1987-11-09,LJAdams), approve(1987-11-10,MCR7802),
     audit(1987-12-04,RBarstad), install(1988-01-12,MR12.2-1012):
     If a history comment exceeded the maximum length the error message was
     printing the error code instead of the length of the comment in error.
 14) change(1990-07-23,Itani), approve(1990-07-23,MCR8186),
     audit(1990-07-30,Vu), install(1990-08-21,MR12.4-1027):
     Change history_comment so that when it is invoked as an active function,
     it returns all the values requested for the get operation when a star name
     is specified for the pathname.
 15) change(2016-01-15,Swenson), approve(2016-01-15,MCR10006):
     Fix history_comment to use 4-digit years and be able to handle current
     date/times when there are existing history comments without thinking that
     the new ones are in the past.
                                                   END HISTORY COMMENTS */

/* format: off */

hcom_process_seg_:	
   proc(Pd, ERROR_RETURN_LABEL);

dcl	
/*	Pd			ptr,		/* ptr to d structure, dcl in hcom_data.incl.pl1	*/
	ERROR_RETURN_LABEL		label parameter;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* This command is used to insert history_comments into source_programs.        	*/
	/* The command uses the pnotice_language_info_ database (created by CDS) to obtain        */
	/* information on the source language segment.			          	*/
	/*									*/
	/* Status:								*/
	/* 0) Created	   June 1985 by LJ Adams					*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */



	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* INTERNAL PROCEDURES IN THIS PROGRAM. THESE ARE LISTED IN THE ORDER THAT THEY EXIST	*/
	/* INLINE, AS WELL AS THE MOST FREQUENT PATH OF EXECUTION.				*/
	/*									*/
	/* Name		       Brief description					*/
	/* get_language_info       obtains per-language parameters like comment delimiters, etc.	*/
	/* comment_parse	       finds the extents of a notice box, if any.			*/
	/* process_tokens	       drives the parsing procedures to locate notices.		*/
	/* sort_comments	       sorts >1 comment into proper order.			*/
	/* insert_notice	       puts new star box into proper place in a segment.		*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	



/*  A U T O M A T I C  */
dcl	Sany_found		bit(1),
	Sblank_after		bit(1),
	Sblank_before		bit(1),
          Sfirst_cmt		bit(1),
	Sformat			bit(1),
	code			fixed bin(35),
	current_date		char(10),
          error_msg			char (100) varying,
         (i, j, k)			fixed bin (24),
	valid			bit(1);

/*  E X T E R N A L   E N T R I E S  */
dcl	cu_$generate_call		entry (entry, ptr),
	date_time_$format		entry (char(*),fixed bin(71),char(*),char(*)) returns (char(250) var),
	format_document_$string	entry (char(*), char(*), fixed bin(21), ptr, fixed bin(35)),
	get_ec_version_		entry (char(*), char(*), fixed bin, fixed bin (21), fixed bin (35)),
	get_line_length_$switch	entry (ptr, fixed bin(35)) returns(fixed bin),
	hcom_command_query_		entry options(variable),
	hcom_cfix_validate_		entry (char(*) var, char(*) var, char(*) var, bit(1), char(*) var, 
                                              char(*) var, char(100) var),
	hcom_parse_		entry (label, char(*), char(*), char(*), bit,  ptr, 1 aligned, 
                                             2 char(10), 2 pic "9999", 2 bit(1), 2 bit(1), 2 fixed bin, 
                                             2 fixed bin, 2 char(24) var, 2 char(10), 2 char(24) var,
				     2 char(10), 2 char(24) var, 2 char(10),
				     2 char(24) var, 2 char(2000) var, 
                                             2 (5) char(80) var, fixed bin(35)),
         (ioa_, ioa_$nnl)		     entry() options(variable),
	pathname_$component		entry (char(*), char(*), char(*)) returns(char(194)),
	pnotice_mlr_		entry (ptr, fixed bin(21), ptr, fixed bin(21)),
	pnotice_mrl_		entry (ptr, fixed bin(21), ptr, fixed bin(21));


/*  I N T E R N A L   S T A T I C  */
dcl	CHARS_PER_WORD		fixed bin int static options(constant) init(4),
	FALSE			bit(1) int static options (constant) init ("0"b),
          HT_SP                         char(2) int static options(constant) init("	 "),
	HT_SP_NL_VT_NP		char(5) int static options(constant) init ("	 
"),
	NL			char(1) aligned int static options(constant) init ("
"),
	SP			char(1) int static options(constant) init (" "),
	TRUE			bit(1) int static options (constant) init ("1"b);

/*  E X T E R N A L   S T A T I C  */
dcl      (error_table_$bad_arg,
	error_table_$bad_file_name,
          error_table_$bigarg,
	error_table_$improper_data_format,
	error_table_$recoverable_error)
				fixed bin(35) ext static,
	sys_info$max_seg_size    	fixed bin(35) ext static;

/*  B U I L T I N  */
dcl      (addr, addcharno, after, before, char, charno, clock, convert, dim,
          hbound, index, lbound, length, ltrim, maxlength, null, reverse,
          rtrim, search, string, substr, unspec, verify)
				builtin;

/*  S T R U C T U R E S  */

dcl	Psegment			ptr,
	Lsegment			fixed bin(21),
	segment			char(Lsegment) based (Psegment);

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

   call init_structures$src_array;
   Porig_array = null;
   current_date = date_time_$format("^9999yc-^my-^dm",clock(),"","");
   Sformat = FALSE;
   

   call get_language_info (d.seg);			/* parse comments in the source segment		*/
   call comment_parse(addr(src_array), d.seg, pathname_$component(d.seg.dir, d.seg.ent, d.seg.comp));

   if d.orig_seg.Pseg ^= null & d.orig_seg.Lseg_in ^= 0 then do;
      call init_structures$orig_array;			/* parse comments in the original segment	*/
      call get_language_info(d.orig_seg);
      call comment_parse(addr(orig_array), d.orig_seg, pathname_$component(d.orig_seg.dir, d.orig_seg.ent, d.orig_seg.comp));
      end;

   if d.ag.op.name ^= ADD & d.ag.op.name ^= COMPARE then
      Sany_found = select_comments(Sany_found);		/* use com specs to get requested src cmts	*/
   else
      Sany_found = FALSE;				/* So far, no comments have been selected.	*/
   goto OPER(d.ag.op.name);

OPER(1):	                                                  /* ADD					*/
   if d.ag.input.sm = INPUTxxx | d.ag.input.apv = INPUTxxx | 
      d.ag.input.in = INPUTxxx then
      call prompt_req;
   call ADD_comment (Sany_found);
   goto END_OPER;

OPER(2):	                                                  /* ADD_FIELD				*/
   if ^Sany_found then				/* error means no slection criteria was met	*/
      call check_error (-1, "", "^a^/^3xNo^[^; matching^] history comments.",
         pathname_$component(d.seg.dir, d.seg.ent, d.seg.comp),
         string(d.com_spec.selected) = ALL & d.com_spec.Nrange = 0);
   if d.ag.input.apv = INPUTxxx | d.ag.input.in = INPUTxxx then
      call prompt_req;
   call ADD_FIELDs (Sany_found);
   if ^Sany_found then				/* error means no slection criteria was met	*/
      call check_error (-1, "", "^a^/^3xNone of the selected history comments needed the given fields.",
         pathname_$component(d.seg.dir, d.seg.ent, d.seg.comp),
         string(d.com_spec.selected) = ALL & d.com_spec.Nrange = 0);
   goto END_OPER;
	

OPER(3):                                                    /* CHECK					*/
   if ^Sany_found then do;
      if d.Saf then
         call d.set_return_arg ("false");
      else
         call check_error (-1, "", "^a:^/^3xERROR:  Either an audit or approve field is missing from a comment^/^15x----- or -----^/^11xNo new comments were found.",
         pathname_$component(d.seg.dir, d.seg.ent, d.seg.comp));
      goto END_OPER;
      end;
   else do;
      call CHECK_FIELDs(Sany_found);
      goto END_OPER;
      end;
	
OPER(4):						/* COMPARE				*/
   call COMPARE_modules;
   goto END_OPER;

OPER(5):	                                                  /* DISPLAY				*/
   goto END_OPER;
	
OPER(6):	                                                  /* EXISTS					*/
   goto END_OPER;

OPER(7):	                                                  /* FORMAT					*/
   call cmt_renumber;				/* check to be sure comments are in date sequence */
   call FORMAT_CMTS(Sany_found);
   if ^Sany_found then
      call check_error (-1, "", "^a^/^3x No matching history comments were found.",
      pathname_$component(d.seg.dir,d.seg.ent,d.seg.comp));
                               			/* error means no selection criteria was met	*/
   Sformat = TRUE;
   goto END_OPER;
	
OPER(8):	                                                  /* GET					*/
   call GET_fields;
   goto RETURN;
	
OPER(9):	                                                  /* INSTALL				*/
   if ^Sany_found then do;
      if d.Saf then
         call d.set_return_arg("false");
      call check_error (-1, "", "^a:^/^3xcontains no history comments.", pathname_$component (d.seg.dir, d.seg.ent, d.seg.comp));
      end;
   else do;
      if d.ag.input.apv = INPUTxxx | d.ag.input.in = INPUTxxx then
         call prompt_req;
      if d.ag.orig.path ^= "" then
         if orig_array.Ncoms > 0 then
            call COMPARE_modules;
      call INSTALL_ck;
      goto RETURN;
      end;
   

OPER(10):						/* REPLACE_FIELD				*/
   if Sany_found then do;
      if d.ag.input.sm = INPUTxxx | d.ag.input.apv = INPUTxxx |
         d.ag.input.in = INPUTxxx then
         call prompt_req;
      call REPLACE_FIELDs;
      end;
   goto END_OPER;

END_OPER:
   if d.ag.op.type = MODIFY then do;
      if ^Sany_found then				/* error means no slection criteria was met	*/
         call check_error (-1, "", "^a^/^3xNo^[^; matching^] history comments.",
	  pathname_$component(d.seg.dir, d.seg.ent, d.seg.comp),
	  string(d.com_spec.selected) = ALL & d.com_spec.Nrange = 0);
      call format_comments();
      call insert_notice();				/* put it into the seg */
      end;
   call display_comments(Sany_found);

RETURN:
   return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

ADD_comment:
   proc (Sany_found);

dcl	Sany_found		bit(1);

   if d.ag.input.value.approve_value ^= "" & d.Scfix_found & 
      index(d.ag.input.value.approve_value,"fix_") = 0 then
						/* Only critical fix numbers are allowed once spec*/
      call check_error (error_table_$bad_arg, CALLER, "^a^/^3x^a^/^3xOnly critical fix numbers are currently acceptable.", 
         d.ag.input.value.approve_value, 
         pathname_$component(d.seg.dir, d.seg.ent, d.seg.comp));

   d.ag.input.value.selected = TRUE;
   Sany_found = TRUE;
   if src_array.Ncoms = 0 then do;			/* First comment				*/
      src_array.Ncoms = 1;
      d.ag.input.value.comment_no = src_array.Ncoms;
      d.ag.input.value.seqno = 1;
      src_array.comments(src_array.Ncoms) = d.ag.input.value;
      src_array.comments(src_array.Ncoms).fill = d.ag.ctl.fill;
      end;
   else do;
      src_array.Ncoms = src_array.Ncoms + 1;
      d.ag.input.value.comment_no = src_array.Ncoms;
      d.ag.input.value.seqno = src_array.comments(src_array.Ncoms-1).seqno +1;
      src_array.comments(src_array.Ncoms) = d.ag.input.value;
      src_array.comments(src_array.Ncoms).fill = d.ag.ctl.fill;
      end;

   end ADD_comment;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

ADD_FIELDs:
   proc(Sany_found);

dcl	Sany_found		bit(1),
	Sfound			bit(1);

   Sany_found = FALSE;
   do i = 1 to src_array.Ncoms;
      Sfound = FALSE;
      if src_array.comments(i).selected then do;

         if d.ag.input.apv = OPERANDxxx &
	  src_array.comments(i).approve_dt = "" &
	  src_array.comments(i).approve_value = "" then do;
	  src_array.comments(i).approve_value = d.ag.input.value.approve_value;
            src_array.comments(i).approve_dt = d.ag.input.value.approve_dt;
            Sfound = TRUE;
            end;

         if d.ag.input.aud = OPERANDxxx &
	  src_array.comments(i).audit_dt = "" &
	  src_array.comments(i).audit_person = "" then do;
	  if src_array.comments(i).change_person = d.ag.input.value.audit_person then
	     call check_error (-1, CALLER, "^a^/^3xYou created the matching history comment ^d and cannot also be the auditor.",
	        pathname_$component (d.seg.dir, d.seg.ent, d.seg.comp),
	        src_array.comments(i).comment_no);
            src_array.comments(i).audit_dt = d.ag.input.value.audit_dt;
            src_array.comments(i).audit_person = d.ag.input.value.audit_person;
            Sfound = TRUE;
            end;

         if d.ag.input.in = OPERANDxxx &
	  src_array.comments(i).install_dt = "" &
	  src_array.comments(i).install_id = "" then do;
            src_array.comments(i).install_dt = d.ag.input.value.install_dt;
            src_array.comments(i).install_id = d.ag.input.value.install_id;
	  Sfound = TRUE;
            end;
         src_array.comments(i).selected = Sfound;		/* reset if no fields were added.		*/
         Sany_found = Sany_found | Sfound;
         end;
      end;

   end ADD_FIELDs;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* Syntax:  dcl check_error entry options(variable);				*/
	/* 	  call check_error (code, procedure_name, ioa_ctl_str, args);		*/
	/*									*/
	/* Function: calls com_err_ to report an error on	behalf of hcom.			*/
          /*									*/
	/* Args:									*/
	/* code (fixed bin(35))							*/
	/*    a status code.							*/
	/* procedure_name (char(*))							*/
	/*    name of the procedure reporting the error.					*/
	/* ioa_ctl_str								*/
	/*    error message								*/
	/* args									*/
	/*    args ioa_ will substitute into the error message.				*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

dcl	Serror_has_occurred		bit(1) init("0"b);

check_error:
   proc options(variable);

    dcl  	Pcode			ptr,
	code			fixed bin(35) based(Pcode),
         	com_err_			entry() options(variable),
       	cu_$arg_list_ptr		entry returns(ptr),
	cu_$arg_ptr		entry (fixed bin, ptr, fixed bin(21), fixed bin(35));

   call cu_$arg_ptr (1, Pcode, 0, 0);			/* Access error table code argument.		*/
   if code = 0 then return;				/* If non-zero, this ISN'T an error.		*/
   Serror_has_occurred  = TRUE;
   if code = -1 then code = 0;			/* No error table code fits the desired err msg.	*/
   call cu_$generate_call (com_err_, cu_$arg_list_ptr());
   goto ERROR_RETURN_LABEL;

end check_error;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

CHECK_FIELDs:
   proc (Sany_found);

dcl       Sany_found		bit (1);

   if d.orig.path ^= "" then
      if orig_array.Ncoms > 0 then 
         call COMPARE_modules;

   Sany_found = TRUE;
   do i = 1 to src_array.Ncoms while (Sany_found);
      if src_array.comments(i).selected then
         if src_array.comments(i).change_dt ^= "" & src_array.comments(i).change_person ^= "" &
            (src_array.comments(i).audit_dt = "^" |
             src_array.comments(i).audit_dt ^= "" & src_array.comments(i).audit_person ^= "") &
            (src_array.comments(i).approve_dt = "^" |
	   src_array.comments(i).approve_dt ^= "" & src_array.comments(i).approve_value ^= "") &
            (src_array.comments(i).install_dt = "^" |
	   src_array.comments(i).install_dt = "" & src_array.comments(i).install_id = "") then do;
	  src_array.comments(i).selected = FALSE;
	  end;
         else
	   Sany_found = FALSE;
      else
         ;
      end;

   end CHECK_FIELDs;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

FORMAT_CMTS:
   proc (Sany_found);

   dcl	Sany_found		bit(1);

   Sany_found = FALSE;
   do i = 1 to src_array.Ncoms;
      if src_array.comments(i).selected then do;
         src_array.comments(i).fill = d.ag.ctl.fill;
         Sany_found = TRUE;
         end;
      end;
   
end FORMAT_CMTS;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
    
cmt_renumber:
   proc;

   if d.ag.ctl.renumber then do;   
      call sort_comments (Psrc_array);
      do i = 1 to src_array.Ncoms;
         src_array.comments(i).comment_no = i;
         end;
      end;
   return;

end cmt_renumber;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

comment_parse:
   proc(Pcom_array, seg, com_path);

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* This procedure determines the extents of what appears to be a valid history comment.	*/
	/* languages. Once this is done, these extents are then used by the process_tokens	*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

dcl	Pcom_array		ptr,
	1 seg			aligned like d.seg,
	com_path			char(*);
   
dcl	1 com_array		aligned based(Pcom_array),
	  2 Ncoms			fixed bin,
	  2 comments (0 refer(com_array.Ncoms))
				aligned like src_array.comments;

dcl	Send_history_cmt		bit(1),
	Sincl			bit(1),
	Spnotice			bit(1),
          Snopnotice		bit(1),
	Sprt_path			bit(1),
          Sstar_line                    bit(1),
	save_length		fixed bin(21),
	save_ptr			ptr;

dcl	rest			char(Lrest) based (Prest),
	Prest			ptr,
	Lrest			fixed bin (21),
	Icmt			fixed bin (21),
	rest_ch (Lrest)		char(1) based (Prest);

dcl	Pcomment			ptr,
	Lcomment			fixed bin(21),
	comment			char(Lcomment) based(Pcomment),
	comment_chr (Lcomment)	char(1) based(Pcomment),
	Pcomment_line		ptr,
	Lcomment_line		fixed bin(21),
	comment_line		char(Lcomment_line) based(Pcomment_line);

dcl	Pcopy			ptr,
	Lcopy			fixed bin(21),
	copy			char(Lcopy) based(Pcopy) aligned,
	Pcopy_cmt			ptr,
	Lcopy_cmt			fixed bin(21);

dcl       err_code			fixed bin(35);

    Sblank_before, Sblank_after = FALSE;         
    Sprt_path = FALSE;
    seg.Pbox = seg.Pseg;
    seg.Loldbox = 0;
  
    Psegment = seg.Pseg;				/* get source segment to pass to hcom_parse_	*/
    Lsegment = seg.Lseg_in;

    Prest = seg.Pseg;
    Lrest = seg.Lseg_in;
    Sincl = FALSE;

    if d.seg.comp ^= "" & index(d.seg.comp,".incl.") > 0 then
						/* determine if working with incl file		*/
       Sincl = TRUE;
    else if d.seg.ent ^= "" & index(d.seg.ent,".incl.") > 0 then
       Sincl = TRUE;
    else if d.seg.comp ^= "" & after(d.seg.comp,".") = "h" then
						/* determine if working with C header file	*/
       Sincl = TRUE;
    else if d.seg.ent ^= "" & after(d.seg.ent,".") = "h" then
       Sincl = TRUE;

    goto TYPE(seg.type);

TYPE(1):
TYPE(4):
    Icmt = verify(rest, HT_SP_NL_VT_NP);		/* disregard white space at front		*/
    if Icmt = 0 then
       goto end_parse1;
    else do;
       Prest = addr(rest_ch(Icmt));
       Lrest = Lrest - (Icmt-1);
       if Sincl then
	call ck_incl_file$pl1;			/* adjust cmt begin/length to skip include block	*/
       end;

    if ck_history_cmt() then do;
       i = index(comment,NL);				/* skip begin block line			*/
       Pcomment = addcharno(addr(comment_chr(i)), 1);	/* skip begin block line			*/
       Lcomment = Lcomment -i;
       i = index(substr(reverse(comment),2),NL);		/* strip off end block line			*/
       Lcomment = Lcomment - i;

       if index(comment,"change") > 0 then do;
	call process_tokens;
	goto end_parse1;
	end;
       else 
	call check_error (error_table_$improper_data_format,CALLER, "^/^a^/^3xMissing change keyword in history comment box.",
	pathname_$component(seg.dir, seg.ent, seg.comp));
       end;
    else do;
       if d.seg.type = 4 & substr(rest,1,2) ^= "/*" |
	d.seg.type ^= 4 & substr(rest,1,length(seg.cmt_bgn)) ^= seg.cmt_bgn then do;
						/* first non-white space not a comment		*/
	Sblank_before, Sblank_after = TRUE;
	goto end_parse1;
	end;
         
       Pcomment = addr(rest);
       Lcomment = Lrest;
       Lcomment = index(comment,seg.cmt_end) -1 + length(seg.cmt_end);
       Spnotice = TRUE;
       
       do while (Spnotice);
	if substr(comment,length(seg.cmt_bgn)+5,10) = "**********" &
	   (index(comment,"Copyright") > 0 |		/* find out if its a pnotice - if its not a 	*/
						/* pnotice history comment comes 1st		*/
	   index(comment,"PROPRIETARY") > 0 |
	   index(comment,"PUBLIC DOMAIN") > 0) then do;
             Prest = addcharno(addr(rest_ch(Lcomment)), 1);
	   Lrest = Lrest - Lcomment;
	   Icmt = verify(rest, HT_SP_NL_VT_NP);		/* skip white space if present		*/
	   if Icmt > 0 then do;
	      Prest = addr(rest_ch(Icmt));
	      Lrest = Lrest - (Icmt-1);
	      end;
	   end;
	else
	   Spnotice = FALSE;
	if Spnotice & substr(rest,length(seg.cmt_bgn)+5,10) = "**********"  then do;
	   Pcomment = Prest;
	   Lcomment = index(rest, seg.cmt_end) -1 + length(seg.cmt_end) + length(NL);
	   end;
	else
	   Spnotice = FALSE;
	end;

       Sblank_before, Sblank_after = TRUE;
       seg.Pbox = Prest;
       end;

   Pcomment = Prest;
   Lcomment = index(rest, seg.cmt_end) -1 + length(seg.cmt_end) + length(NL);
   Pcomment_line = Pcomment;
   Lcomment_line = index(comment,NL);
   if Lcomment_line = 0 then
      Lcomment_line = Lcomment;
   i = index(comment_line,"HISTORY");
   j = index(comment_line,"COMMENTS:");
   if i ^< j | i = 0 | j = 0 then do;			/* not a history comment			*/
      Sblank_before, Sblank_after = TRUE;
      goto end_parse1;
      end;
   
   seg.Loldbox = Lcomment;
   if length(comment) > length(comment_line) then
      Pcomment = addr(comment_chr(Lcomment_line+1));
   Lcomment = Lcomment - Lcomment_line;

   if index(comment,"END") > 0 & index(comment,"HISTORY") > 0 & index(comment,"COMMENTS") > 0 then do;
      i = index(substr(reverse(comment),2),NL);
      Lcomment = Lcomment - i;
      end;
   else
      call check_error (error_table_$improper_data_format, CALLER, "^/^a^/^3xMissing history comment end block.",
      pathname_$component(seg.dir, seg.ent, seg.comp));

   if index(comment, "change") > 0 then
      call process_tokens;
   else
      call check_error (error_table_$improper_data_format, CALLER, "^/^a^/^3xMissing change keyword in history comment box.",
      pathname_$component(seg.dir, seg.ent, seg.comp));

end_parse1:
   return;


TYPE(3):						/* adjust things for ec's and absin */
   Prest = addr(rest_ch(seg.text_pos));			/* adjust to avoid any "&version" lines */
   Lrest = Lrest - (seg.text_pos - 1);
          					/* after this, type 3 is just like type 2 */
   seg.Pbox = Prest;
TYPE(2):
TYPE(5):						/* compin and runoff files			*/

   Icmt = verify(rest, HT_SP_NL_VT_NP);			/* disregard white space at front		*/
   if Icmt = 0 then
      goto end_parse2;
   if (Icmt - 1) + length(seg.cmt_bgn) > length(rest) then
      goto end_parse2;				/* no room left for comment			*/
   Prest = addr(rest_ch(Icmt));
   Lrest = Lrest - (Icmt-1);
   if Sincl then					/* adjust cmt begin/length to skip 1st incl line	*/
      call ck_incl_file$alm;

   if ck_history_cmt() then do;
      i = index(comment,NL);				/* strip off begin block line			*/
      Pcomment = addcharno(addr(comment_chr(i)), 1);
      Lcomment = Lcomment - i;
      i = index(substr(reverse(comment),2),NL);		/* strip off end block line			*/
      Lcomment = Lcomment - i;

      if index(comment, "change") > 0 then do;		/* make a copy of seg for hcom_parse_		*/
         Pcopy = Pseg;
         Lcopy = charno(Pcomment) - charno(Pseg);
         call form_string$init();
         call form_string$fixed(copy);
         call form_string$fixed(" ");			/* establish start of copy			*/
         Pcopy_cmt = addcharno(addr(formed_string_array(Lcopy)), 1);
						/* strip off CMTBGN character			*/
         do while(Lcomment > 0);
	  Pcomment_line = Pcomment;
	  Lcomment_line = index(comment,NL);
	  if Lcomment_line = 0 then do;
	     Lcomment_line = Lcomment;
	     Lcomment = 0;
	     end;
	  else do;
	     Pcomment = addcharno(addr(comment_chr(Lcomment_line)),1);
	     Lcomment = Lcomment - Lcomment_line;
	     end;
	  k = index(comment_line,seg.cmt_bgn);
	  if k = 0 then
	     call form_string$var (substr(comment_line,1));
	  else
	     call form_string$var (substr(comment_line,k+length(seg.cmt_bgn)));
	  end;
         Psegment = Pformed_string;
         Lcopy_cmt = charno(addr(formed_string_array(Lformed_string))) - charno(Pcopy_cmt);
         Pcomment = Pcopy_cmt;
         Lcomment = Lcopy_cmt;
         call process_tokens;
         goto end_parse2;
         end;
      else 
         call check_error (error_table_$improper_data_format,CALLER, "^/^a^/^3xMissing change keyword in history comment box.",
         pathname_$component(seg.dir, seg.ent, seg.comp));
      end;
   else if substr(rest,1,length(seg.cmt_bgn)) ^= seg.cmt_bgn then do;
      Sblank_before, Sblank_after = TRUE;
      goto end_parse2;
      end;
   else do;
      Spnotice = TRUE;
      Snopnotice = FALSE;
      do while (Spnotice);
         Pcomment = Prest;
         Lcomment = Lrest;
         save_length = 0;
         Sstar_line = FALSE;

         if substr(comment,length(seg.cmt_bgn)+5,10) = "**********" &
						/* pnotices begin with a star line		*/
	  (index(comment,"PROPRIETARY") > 0 |
	  index(comment,"PUBLIC DOMAIN") > 0 |
	  index(comment,"Copyright") > 0) then do;
	  do while(Lcomment > 0);
						/* ensure that history cmt follows pnotice	*/
	     Pcomment_line = Pcomment;
	     Lcomment_line = index (comment,NL);
	     if Lcomment_line = 0 then
	        Lcomment_line = Lcomment;
	     else
	        Pcomment = addr(comment_chr(Lcomment_line+1));
	     Lcomment = Lcomment - Lcomment_line;
	     save_length = save_length + Lcomment_line;
	     if substr(comment_line,length(seg.cmt_bgn)+5,10) = "**********" then do;
	        if ^Sstar_line then
		 Sstar_line = TRUE;
	        else do;
		 Prest = addcharno(addr(rest_ch(save_length)),1);
		 Lrest = Lrest - save_length;
		 Lcomment = 0;
		 end;
	        end;
	     end;
	  Icmt = verify(rest, HT_SP_NL_VT_NP);
	  Prest = addr(rest_ch(Icmt));
	  Lrest = Lrest - (Icmt-1);
	  if substr(rest,length(seg.cmt_bgn)+5,10) ^= "**********" |
	     Lrest = 0 then
	     Spnotice = FALSE;
	  end;
         else do;					/* no pnotices found - pnotices are the		*/
						/* first comments in a program		*/
	  Spnotice = FALSE;
	  Snopnotice = TRUE;
	  end;
         seg.Pbox = Prest;
         end;
      if d.seg.type ^= 5 then do;			/* dont add blank lines for compin/runoff files	*/
         if Snopnotice then
            Sblank_after = TRUE;
         else
	  Sblank_after, Sblank_before = TRUE;
         end;

      goto end_parse2;
      end;

	
end_parse2:
   return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

ck_incl_file:					/* adjust comment beginning to skip 1st line of	*/
						/* include files.				*/
   proc;

ck_incl_file$pl1:
   entry;
   
   Pcomment, Pcomment_line = Prest;
   Lcomment = Lrest;
   Lcomment_line = index(comment,NL);
   call ck_begin_line;				/* include files must have begin line		*/
   if index(comment_line,"HISTORY") > 0 & index(comment_line,"COMMENTS:") > 0 then
      ;
   else do;					/* skip begin incl file line			*/
      i = index(comment,seg.cmt_end);
      Pcomment = addcharno(addr(comment_chr(i)), length(seg.cmt_end));
      Lcomment = Lcomment - i+length(seg.cmt_end)-1;
      i = verify (comment,HT_SP_NL_VT_NP);
      if i > 0 then do;
         Pcomment = addr(comment_chr(i));
         Lcomment = Lcomment -i-1;
         end;
      end;

   seg.Pbox = Pcomment;
   Prest = Pcomment;
   Lrest = Lcomment;
   return;

ck_incl_file$alm:
   entry;

   Pcomment, Pcomment_line = Prest;
   Lcomment = Lrest;
   Lcomment_line = index(comment,NL);
   call ck_begin_line;				/* include files must have begin line		*/
   if index(comment_line,"HISTORY") > 0 & index(comment_line,"COMMENTS:") > 0 then
      ;
   else 
      if substr(comment_line,1,length(seg.cmt_bgn)) = seg.cmt_bgn then do;
						/* if 1st line is a comment put history comment	*/
						/* after it else put history comment before	*/
         Pcomment = addcharno(addr(comment_chr(Lcomment_line)), 1);
         Lcomment = Lcomment - Lcomment_line;
         end;

   Prest = Pcomment;
   Lrest = Lcomment;
   seg.Pbox = Pcomment;
   return;

ck_begin_line:
   proc;
   
   if d.seg.type = 4 & substr(comment_line,1,length("/*")) ^= "/* " then
      goto LINE_ERROR;
   else if d.seg.type ^= 4 & substr(comment_line,1,length(seg.cmt_bgn)) ^= seg.cmt_bgn then
						/* include files must begin with a cmt		*/
      goto LINE_ERROR;
   else if index(comment_line,rtrim(seg.ent)) ^= 0 |	/* see if file name is anotated		*/
      index(comment_line,rtrim(seg.comp)) ^= 0 then
      goto END_CK;
   else if index(comment_line,"BEGIN") = 0 & index(comment_line,"Begin") = 0 &
      index(comment_line,"begin") = 0 then
      goto LINE_ERROR;
   else if index(comment_line,"INCLUDE") = 0 & index(comment_line,"Include") = 0 &
      index(comment_line,"include") = 0 then
      goto LINE_ERROR;
   else if index(comment_line,"FILE") = 0 & index(comment_line,"File") = 0 &
      index(comment_line,"file") = 0 then
      goto LINE_ERROR;
   else
      goto END_CK;

LINE_ERROR:
   call d.set_return_arg ("false");

   call check_error (error_table_$improper_data_format,CALLER, "^/^a^/^3xINCLUDE file missing ""BEGIN INCLUDE FILE"" line.",
   pathname_$component(seg.dir,seg.ent,seg.comp));

END_CK:
end ck_begin_line;

end ck_incl_file;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
ck_history_cmt:
   proc returns(bit(1));

   dcl  Shistory_cmt_bgn		bit(1);
   

   Shistory_cmt_bgn = FALSE;
   Pcomment = Prest;
   Lcomment = Lrest;

   do while (Lcomment > 0 & ^Shistory_cmt_bgn);
      Pcomment_line = Pcomment;
      Lcomment_line = index(comment,NL);
      if Lcomment_line = 0 then do;
         Lcomment_line = Lcomment;
         Lcomment = 0;
         end;
      else do;
         if Lcomment - Lcomment_line > 0 then
	  Pcomment = addcharno(addr(comment_chr(Lcomment_line)), 1);
         Lcomment = Lcomment - Lcomment_line;
         end;
      if Lcomment_line >= length(seg.cmt_bgn) then
         if index(substr(comment_line,1,length(seg.cmt_bgn)),seg.cmt_bgn) > 0 &
            index(comment_line,"HISTORY") > 0 &
            index(comment_line,"COMMENTS:") > 0 then
            Shistory_cmt_bgn = TRUE;
      end;
   
   if ^Shistory_cmt_bgn then
      return (FALSE);

   Lrest = Lrest - (charno(Pcomment_line) - charno(Prest));
   Prest = Pcomment_line;
   seg.Pbox = Prest;
   Pcomment = Prest;
   Lcomment = Lrest;

   if seg.type = 1 | seg.type = 4 then do;
      if index(comment,"END") > 0 & index(comment,"HISTORY") > 0 & index(comment,"COMMENTS") > 0 then
         ;
      else
         call check_error (error_table_$improper_data_format, CALLER, "^/^a^/^3xMissing history comment end block.",
         pathname_$component(seg.dir, seg.ent, seg.comp));
      Lcomment = index(rest,seg.cmt_end) -1 + length(seg.cmt_end) + length(NL);
      seg.Loldbox = Lcomment;
      end;
   else do;
      Lcomment = Lrest;
      save_ptr = Pcomment;
      save_length = 0;
      Send_history_cmt = FALSE;
      do while (^Send_history_cmt & Lrest > 0);
         Pcomment_line = Pcomment;
         Lcomment_line = index(comment,NL);
         if Lcomment_line = 0 then do;
	  Lcomment_line = Lrest;
	  Lrest = 0;
	  end;
         else do;
	  Pcomment = addcharno(addr(comment_chr(Lcomment_line)), 1);
	  Lcomment = Lcomment - Lcomment_line;
	  end;
         if index(comment_line,"END") > 0 &
	  index(comment_line,"HISTORY") > 0 then
	  Send_history_cmt = TRUE;
         save_length = save_length + Lcomment_line;
         end;
      if ^Send_history_cmt then
         call check_error (error_table_$improper_data_format, CALLER, "^/^a^/^3xMissing "" END HISTORY COMMENTS"".",
         pathname_$component(seg.dir,seg.ent,seg.comp));

      seg.Loldbox = save_length;
      Pcomment = save_ptr;
      Lcomment = save_length;
      end;

   return(TRUE);
      
end ck_history_cmt;



/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


process_tokens:
   proc;

dcl	Lstring			fixed bin(21),	/* length of an individual comment		*/
	Pstring			ptr,
	string			char(Lstring) based(Pstring);

   Pstring = Pcomment;
   Lstring = 0;
   Sfirst_cmt = TRUE;
   com_array.Ncoms = 0;

   do while (line$cmt());
      if line$new_cmt() then do;
         if Sfirst_cmt then do;
	  com_array.Ncoms = 1;
	  call init_structures$array(com_array.comments(com_array.Ncoms));
	  com_array.comments(com_array.Ncoms).seqno = 1;
	  Lstring = Lstring + Lcomment_line + length(NL);
	  Sfirst_cmt = FALSE;
	  end;
         else do;
	  if Lstring = 0 then 
	     call check_error (error_table_$improper_data_format, CALLER, "^a^/^3xZero length comment.",
	     pathname_$component(d.seg.dir,d.seg.ent,d.seg.comp));

	  call hcom_parse_ (ERROR_RETURN_LABEL, segment, string, com_path, Sprt_path, Pd,
	     com_array.comments(com_array.Ncoms), code);

	  if com_array.comments(com_array.Ncoms).err_msg(1) ^= "" then do;
               err_code = convert (err_code, ltrim(com_array.comments(com_array.Ncoms).err_msg(1)));
               if err_code = error_table_$improper_data_format then do;
	        if d.ag.op.type = NO_MODIFY then
                     call ioa_ ("^/^a^/^3xComment ^d has null approve and audit values a null install value is required.",
		 pathname_$component(d.seg.dir, d.seg.ent, d.seg.comp),
                     com_array.comments(com_array.Ncoms).comment_no);
	        else call check_error (error_table_$improper_data_format, CALLER, "^/^a^/^3xComment ^d has null approve and audit values a null install value is required.",
		 pathname_$component(d.seg.dir, d.seg.ent, d.seg.comp), 
		 com_array.comments(com_array.Ncoms).comment_no);
	     end;
	  else if err_code = error_table_$bigarg then do;
	        if d.ag.op.type = NO_MODIFY then
		 call ioa_ ("^/^a^/^3xThe length of comment ^d is ^a which exceeds max allowable length of ^d.", 
		 pathname_$component (d.seg.dir, d.seg.ent, d.seg.comp), 
		 com_array.comments(com_array.Ncoms).comment_no,
		 ltrim(com_array.comments(com_array.Ncoms).err_msg(2)),
		 maxlength(d.ag.input.summary));
	        else call check_error (error_table_$bigarg, CALLER, "^/^a^/^3xThe length of comment ^d is ^a which exceeds max allowable length of ^d.",
		 pathname_$component(d.seg.dir, d.seg.ent, d.seg.comp), 
		 com_array.comments(com_array.Ncoms).comment_no,
		 ltrim(com_array.comments(com_array.Ncoms).err_msg(2)), 
		 maxlength(d.ag.input.summary));
	        end;
	     end;

	  if ^d.Scfix & d.Scfix_found & d.ag.op.name = INSTALL then
						/* if cfix value present; install op invalid	*/
	     call check_error (error_table_$bad_arg, CALLER, "^/^a^/^3xA module may not be installed with critical fix numbers present.",
	     pathname_$component(d.seg.dir, d.seg.ent, d.seg.comp));
	  if cfix_required() then
	      call check_error (error_table_$improper_data_format, CALLER, "^a^/^3x^a^/^3xA critical fix number is required.", 
	     d.ag.input.value.approve_value, 
	     pathname_$component(d.seg.dir, d.seg.ent, d.seg.comp));
	  com_array.Ncoms = com_array.Ncoms + 1;
	  call init_structures$array(com_array.comments(com_array.Ncoms));
	  com_array.comments(com_array.Ncoms).seqno = com_array.Ncoms;
	  Pstring = Pcomment_line;
	  Lstring = Lcomment_line + length(NL);
	  end;
         end;
      else
         Lstring = Lstring + Lcomment_line + length(NL);
      end;


   call hcom_parse_ (ERROR_RETURN_LABEL, segment, string, com_path, Sprt_path, Pd,
      com_array.comments(com_array.Ncoms), code);

   if com_array.comments(com_array.Ncoms).err_msg(1) ^= "" then do;
      err_code = convert (err_code, ltrim(com_array.comments(com_array.Ncoms).err_msg(1)));
      if err_code = error_table_$improper_data_format then do;
         if d.ag.op.type = NO_MODIFY then
	  call ioa_ ("^/^a^/^3xComment ^d has null approve and audit values a null install value is required.",
            pathname_$component(d.seg.dir, d.seg.ent, d.seg.comp),
            com_array.comments(com_array.Ncoms).comment_no);
         else call check_error (error_table_$improper_data_format, CALLER, "^/^a^/^3xComment ^d has null approve and audit values a null install value is required.",
	  pathname_$component(d.seg.dir, d.seg.ent, d.seg.comp), 
	  com_array.comments(com_array.Ncoms).comment_no);
         end;
      else if err_code = error_table_$bigarg then do;
	  if d.ag.op.type = NO_MODIFY then
	     call ioa_ ("^/^a^/^3xThe length of comment ^d is ^a which exceeds max allowable length of ^d.", 
	     pathname_$component (d.seg.dir, d.seg.ent, d.seg.comp), 
	     com_array.comments(com_array.Ncoms).comment_no,
	     ltrim(com_array.comments(com_array.Ncoms).err_msg(2)),
	     maxlength(d.ag.input.summary));
	  else call check_error (error_table_$bigarg, CALLER, "^/^a^/^3xThe length of comment ^d is ^a which exceeds max allowable length of ^d.",
	     pathname_$component(d.seg.dir, d.seg.ent, d.seg.comp), 
	     com_array.comments(com_array.Ncoms).comment_no,
	     ltrim(com_array.comments(com_array.Ncoms).err_msg(2)), 
	     maxlength(d.ag.input.summary));
	  end;
         end;

   if ^d.Scfix & d.Scfix_found & d.ag.op.name = INSTALL then/* if cfix value present; install op invalid	*/
      call check_error (error_table_$bad_arg, CALLER, "^/^a^/^3xA module may not be installed with critical fix numbers present.",
      pathname_$component(d.seg.dir, d.seg.ent, d.seg.comp));
   if cfix_required() then
      call check_error (error_table_$bad_arg, CALLER, "^a^/^3x^a^/^3xA critical fix number is required.", 
      d.ag.input.value.approve_value, 
      pathname_$component(d.seg.dir, d.seg.ent, d.seg.comp));

   call field_check();

   return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

cfix_required:
   proc returns (bit(1));

/* If a critical fix number currently exists in a history comment then:     */
/*      add     critical fix number will always be required		      */
/*      af      critical fix number required if the field being added is    */
/*              the approve field.                                          */
/*      install critical fix numbers are not allowed for installation       */
/*              This is part of the install check and not relevant to       */
/*              needing a critical fix number.                              */
/*      rpf     always ok to replace                                        */
/*      fmt     always ok to format                                         */

   if d.Scfix & d.ag.op.type = MODIFY &
      index(d.ag.input.value.approve_value,"fix_") = 0 then do;
      if d.ag.op.name = ADD then
         return (TRUE);
      else if d.ag.op.name = ADD_FIELD then
         if d.ag.input.apv ^= NOxxx then
         return (TRUE);
      end;
      
   return (FALSE);

end cfix_required;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

field_check:
   proc;

dcl	date_ck			char(10),
	comment_ck		fixed bin;

   date_ck = com_array.comments(1).change_dt;
   comment_ck = com_array.comments(1).comment_no;
   if com_array.comments(1).change_person = com_array.comments(1).audit_person then
      call check_error (-1, "", "^a^/^3xThe same person (^a) is given as both change person and auditor^/^3xin comment ^d.  The ^a operation stops.",
      com_path, com_array.change_person(1),
         com_array.comment_no(1), oper(d.ag.op.name,1));

   do i = 2 to com_array.Ncoms;			/* check to be sure comment nos are in sequence.	*/
      if com_array.comments(i).change_person = com_array.comments(i).audit_person then
         call check_error (-1, "", "^a^/^3xThe same person (^a) is given as both change person and auditor^/^3xin comment ^d.  The ^a operation stops.",
	  com_path, com_array.change_person(i),
	  com_array.comment_no(i), oper(d.ag.op.name,1));
      if com_array.comments(i).change_dt > current_date then
         call check_error(-1, "", "^a^/^3xComment number ^d date (^a) is greater than todays date (^a).^/^3xThe ^a operation stops.",
         com_path, com_array.comments(i).comment_no, com_array.comments(i).change_dt,
         current_date, oper(d.ag.op.name,1));

      if ^ d.ag.ctl.renumber then do;
         if com_array.comments(i).change_dt < date_ck then
	  call check_error (-1, "", "^a^/^3xComment dates are out of sequence.  Date (^a) in comment ^d occurs^/^3xafter date (^a) in comment ^d.  The ^a operation stops.",
	  com_path, com_array.comments(i).change_dt,
	  com_array.comments(i).comment_no, date_ck, comment_ck,
	  oper(d.ag.op.name,1));
         else
	  date_ck = com_array.comments(i).change_dt;
         if com_array.comments(i).comment_no < comment_ck then
	  call check_error(-1, "", "^a^/^3xComment numbers are out of sequence.  Comment ^d occurs^/^3xafter number ^d.  The ^a operation stops.",
            com_path, com_array.comments(i).comment_no, comment_ck,
	  oper(d.ag.op.name,1));
         else if com_array.comments(i).comment_no = comment_ck then
	  call check_error(-1, "", "^a^/^3xComment number ^d is repeated in comments ^d and ^d.^/^3xThe ^a operation stops.",
	  com_path, comment_ck, i-1, i, oper(d.ag.op.name,1));
         else
	  comment_ck = com_array.comments(i).comment_no;
         end;
      else
         comment_ck = com_array.comments(i).comment_no;
      end;

   end field_check;

  end process_tokens;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

line$cmt:
   proc returns(bit(1));

dcl	Iline			fixed bin(24);

   if length(comment) = 0 then
      return(FALSE);
   Iline = index(comment,NL);
   if Iline = 0 | Lcomment - Iline = 0 then do;
      Pcomment_line = Pcomment;
      Lcomment_line = length(comment);
      Lcomment = 0;
      end;
   else do;
      Pcomment_line = Pcomment;
      Lcomment_line = Iline - 1;
      Pcomment = addcharno(addr(comment_chr(Iline)), 1);
      Lcomment = Lcomment - Iline;
      end;

   return (TRUE);

   end line$cmt;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


line$new_cmt:
   proc returns(bit(1));

dcl      Ibreak			fixed bin(21),
         Inonwhite			fixed bin(21),
         Iskip			fixed bin(21),
         Lword_text                     fixed bin(21),
         Pword_text			ptr;
         
 dcl     word_text			char(Lword_text) based(Pword_text),
         word_text_arr (Lword_text)	char(1) based(Pword_text),
         word (2)                       char(80) var,
         Nwords                         fixed bin;

 dcl     WORD_BREAKS		char(4) int static options(constant) init("	 ()");
						/* HT SP ( and )					*/


   if index(comment_line,"change") = 0 |		/* do not parse if not change line		*/
      verify(before(comment_line,"change"),"0123456789 )") ^= 0 then
      return(FALSE);

   Pword_text = Pcomment_line;
   Lword_text = Lcomment_line;
   Nwords = 0;
   word (*) = "";

   Inonwhite = verify (word_text, HT_SP);		/* skip over white space			*/
   if Inonwhite = 0 then
      Lword_text = 0;
   else if Inonwhite > 1 then do;
      Pword_text = addr(word_text_arr(Inonwhite));
      Lword_text = length(word_text) - (Inonwhite-1);
      end;

   do while (Lword_text > 0 & Nwords <= dim(word,1));
      Ibreak = search (word_text, WORD_BREAKS);
      if Ibreak = 0 then
         Ibreak = length(word_text) + 1;
      if Ibreak > 1 then do;
         Nwords = Nwords + 1;
         if Nwords <= dim(word,1) then
	  word(Nwords) = substr(word_text,1,Ibreak-1);
         Pword_text = addr(word_text_arr(Ibreak));
         Lword_text = length(word_text) - (Ibreak-1);
         end;
      Iskip = verify(word_text,WORD_BREAKS);		/* skip over all consecutive breaks chars	*/
      if Iskip >0 then do;
         Pword_text = addr(word_text_arr(Iskip));
         Lword_text = length(word_text) - (Iskip-1);
         end;
      else
         Lword_text = 0;				/* nothing but break characters remain		*/
      end;
      
   if verify(word(1),"0123456789") = 0 & word(2) = "change" then
      return(TRUE);
   else
      return(FALSE);

   end line$new_cmt;


 end comment_parse;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

comments_comparable:

   proc (src, orig) returns (bit(1));

dcl	1 (src, orig)		aligned like src_array.comments;

   return (src.change_dt = orig.change_dt &
	 src.change_person = orig.change_person);

comments_equal:
   entry (src, orig) returns (bit(1));

   return (src.audit_dt = orig.audit_dt &
	 src.audit_person = orig.audit_person &
	 src.install_dt = orig.install_dt &
	 src.install_id = orig.install_id &
	 src.summary = orig.summary);

comments_almost_equal:
   entry (src, orig) returns (bit(1));

    if src.audit_dt = orig.audit_dt &
       src.audit_person = orig.audit_person &
       src.summary = orig.summary then
       return(TRUE);
    else
       return(FALSE);

end comments_comparable;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

COMPARE_modules:
   proc;

dcl	Scomparable		bit(1),
	last_eq_orig_comment	fixed bin;

   if orig_array.Ncoms > 0 then
      orig_array.comments(*).Ieq = 0;
   if src_array.Ncoms > 0 then
      src_array.comments(*).Ieq = 0;
   last_eq_orig_comment = 0;

   do i = 1 to src_array.Ncoms;
      Scomparable = FALSE;
      do j = last_eq_orig_comment+1 to orig_array.Ncoms while(^Scomparable);
         if comments_comparable (src_array.comments(i), orig_array.comments(j)) then do;
	  Scomparable = TRUE;
	  if (d.ag.op.name = INSTALL & comments_almost_equal(src_array.comments(i), orig_array.comments(j))) | 
	     (d.ag.op.name ^= INSTALL & comments_equal (src_array.comments(i), orig_array.comments(j))) then do;
	     orig_array.comments(j).Ieq = i;
	     src_array.comments(i).Ieq, last_eq_orig_comment = j;
	     end;
	  end;
         end;
      end;

   end COMPARE_modules;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

display_comments:
   proc(Sany_found);
  
dcl	Sany_found		bit(1),
	Serrors			bit(1);

dcl	Iorig			fixed bin,
	Isrc			fixed bin,
	Nskip_src			fixed bin,
	Nskip_orig		fixed bin;

   call form_string$init();
   goto DISPLAY(d.ag.op.name);

DISPLAY(1):					/* ADD					*/
DISPLAY(2):					/* ADD_FIELD				*/
DISPLAY(7):					/* FORMAT					*/
DISPLAY(10):					/* REPLACE_FIELD				*/
   call display_selected_comments("");
   return;

DISPLAY(3):					/* CHECK					*/
   Serrors = FALSE;
   if ^Sany_found then do;
      if d.ctl.errors then
         call ioa_("^/^a:^/^3xERROR:  Either an audit or approve field is missing from a comment
^15x----- or -----^/^11xNo new comments were found.",
         pathname_$component(d.seg.dir, d.seg.ent, d.seg.comp));
      else if ^d.Saf then
         call ioa_ ("^/^a:^/^3xFailed the history comment check.",
	  pathname_$component (d.seg.dir, d.seg.ent, d.seg.comp));
      if d.Saf then
         call d.set_return_arg("false");
      end;
   else do;
      if d.orig.path ^= "" then do i = 1 to orig_array.Ncoms;
         if orig_array.comments(i).Ieq = 0 then
	  Serrors = TRUE;
	  end;

         if Serrors then do;
	  if ^d.Saf then
	     call ioa_("^/ORIGINAL:^3x^a^/NEW SOURCE:^x^a^/^/The original and source are not equal. For more information use the compare^/operation.",
               pathname_$component (d.orig_seg.dir, d.orig_seg.ent, d.orig_seg.comp),
	     pathname_$component (d.seg.dir, d.seg.ent, d.seg.comp));
	  else
	     call d.set_return_arg("false");
	  end;

      if ^d.Saf & ^Serrors then
         call ioa_ ("^/^a:^/^3xHas correct history comments.",
         pathname_$component(d.seg.dir, d.seg.ent, d.seg.comp));
      end;
   return;

DISPLAY(4):					/* COMPARE				*/
   Iorig = 1;
   Nskip_src = 0;
   Nskip_orig = 0;
   do Isrc = 1 to src_array.Ncoms;
      if src_array.comments(Isrc).Ieq  = 0 then		/* Haven't found a source comment matched by orig */
         Nskip_src = Nskip_src + 1;			/* yet.					*/
      else if src_array.comments(Isrc).Ieq ^= 0 then do;
         Nskip_orig = src_array.comments(Isrc).Ieq - Iorig;
         if Nskip_orig = 0 & Nskip_src = 0 then		/* no differences found so far		*/
	  Iorig = Iorig + 1;
         else if Nskip_orig > 0 & Nskip_src = 0 then do;	/* differences in the original		*/
	  call form_string$fixed(NL);
	  do j = Iorig to src_array.comments(Isrc).Ieq-1;
	     call format_comment$body(orig_array.comments(j));
	     end;
	  call form_string$fixed_line(".unl 5");
	  call form_string$fixed_line("Deleted from source prior to:");
	  call format_comment$body(src_array.comments(Isrc));
	  Iorig = src_array.comments(Isrc).Ieq+1;
	  end;
         else if Nskip_src > 0 & Nskip_orig = 0 then do;	/* differences in the source			*/
	  call form_string$fixed(NL);
	  do j = Isrc - Nskip_src to Isrc-1;
	     call format_comment$body(src_array.comments(j));
	     end;
	  call form_string$fixed_line(".unl 5");
	  call form_string$fixed_line("Inserted in source prior to:");
	  call format_comment$body(src_array.comments(Isrc));
	  Iorig = src_array.comments(Isrc).Ieq+1;
	  Nskip_src = 0;
	  end;
         else if Nskip_src > 0 & Nskip_orig > 0 then do;	/* differences in both source & orig		*/
	  call form_string$fixed(NL);
	  do j = Iorig to src_array.comments(Isrc).Ieq-1;
	     call format_comment$body(orig_array.comments(j));
	     end;
	  call form_string$fixed_line(".unl 5");
	  call form_string$fixed_line("Changed in source to:");
	  do j = Isrc - Nskip_src to Isrc-1;
	     call format_comment$body(src_array.comments(j));
	     end;
	  Iorig = src_array.comments(Isrc).Ieq+1;
	  Nskip_src = 0;
	  end;
         end;
      end;
   Nskip_orig = orig_array.Ncoms - Iorig + 1;
   if Nskip_src > 0 & Nskip_orig = 0 then do;		/* comments inserted in source at end.		*/
      call form_string$fixed(NL);
      do j = Isrc - Nskip_src to hbound(src_array.comments,1);
         call format_comment$body(src_array.comments(j));
         end;
      call form_string$fixed_line(".unl 5");
      call form_string$fixed_line("Inserted in source at end.");
      end;
   else if Nskip_orig > 0 & Nskip_src = 0 then do;	/* comments deleted from end of original.	*/
      call form_string$fixed(NL);
      do j = Iorig to hbound(orig_array.comments,1);
         call format_comment$body(orig_array.comments(j));
         end;
      call form_string$fixed_line(".unl 5");
      call form_string$fixed_line("Deleted from end of original.");
      end;
   else if Nskip_orig > 0 & Nskip_src > 0 then do;	/* comments at end replaced by other comments.	*/
      call form_string$fixed(NL);
      do j = Iorig to hbound(orig_array.comments,1);
         call format_comment$body(orig_array.comments(j));
         end;
      call form_string$fixed_line(".unl 5");
      call form_string$fixed_line("Changed in source to:");
      do j = Isrc - Nskip_src to hbound(src_array.comments,1);
         call format_comment$body(src_array.comments(j));
         end;
      end;
   if d.Saf then do;
      if formed_string = "" then;			/* Result is "true" if all origs = all sources.	*/
						/* "true" was set in hcom.pl1 as the initial 	*/
						/*   return value.				*/
      else
         call d.set_return_arg ("false");
      end;
   else do;
      if formed_string = "" then do;
         if src_array.Ncoms = 0 & orig_array.Ncoms = 0 then
	  call form_string$fixed_line (
	     "     No history comments found in source or original.");
         else
	  call form_string$fixed_line(
	     "     History comments are identical.");
         Presult = Pformed_string;
         Lresult = Lformed_string;
         end;
      else
         call format_comment$fdoc(get_line_length_$switch(null,code));
      call ioa_("^/ORIGINAL:^3x^a^/NEW SOURCE:^x^a^/^a",
         pathname_$component (d.orig_seg.dir, d.orig_seg.ent, d.orig_seg.comp),
         pathname_$component (d.seg.dir, d.seg.ent, d.seg.comp),
         result);
      end;
   return;

DISPLAY(5):					/* DISPLAY				*/
   if ^Sany_found then				/* error means no slection criteria was met	*/
      call check_error (-1, "", "^a^/^3xNo^[^; matching^] history comments.",
         pathname_$component(d.seg.dir, d.seg.ent, d.seg.comp),
         string(d.com_spec.selected) = ALL & d.com_spec.Nrange = 0);
   call display_selected_comments("");
   return;

DISPLAY(6):					/* EXISTS					*/
   if ^Sany_found then 
      call d.set_return_arg("false");

   return;

DISPLAY(8):					/* GET					*/
   return;
DISPLAY(9):					/* INSTALL				*/
   return;
      
display_selected_comments:
   proc (extra_msg);

dcl	extra_msg			char(*);

   do i = 1 to src_array.Ncoms;
      if src_array.comments(i).selected then do;
         call format_comment$body(src_array.comments(i));
         end;
      end;
   call format_comment$fdoc(get_line_length_$switch(null,code));
   call ioa_$nnl("^/^a:^[^/^3x^a^;^s^]^/^a",
      pathname_$component(d.seg.dir, d.seg.ent, d.seg.comp),
      extra_msg ^= "", extra_msg, result);
   end display_selected_comments;

   end display_comments;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/* This internal procdure is used to build a string to submit to format document*/

dcl	Pformed_string		ptr,
	Lformed_string		fixed bin(21),
	formed_string		char(Lformed_string) based(Pformed_string),
	formed_string_array (Lformed_string)
				char(1) based(Pformed_string);

form_string$fixed:
   proc (fixed_str);
  
dcl	fixed_str			char(*) aligned,
	Lorig			fixed bin(21);
  
   Lorig = length(formed_string);
   Lformed_string = length(formed_string) + length(fixed_str);
   substr(formed_string, Lorig+1) = fixed_str;
   return;

form_string$fixed_line:				/* This entrypoint ensures the string is placed	*/
   entry (fixed_str);				/* on a line by itself.			*/

   if length(formed_string) > 0 then
   if substr(formed_string, length(formed_string), length(NL)) ^= NL then do;
      Lformed_string = Lformed_string + length(NL);
      substr(formed_string,length(formed_string),length(NL)) = NL;
      end;
   Lorig = length(formed_string);
   Lformed_string = length(formed_string) + length(fixed_str);
   substr(formed_string, Lorig+1) = fixed_str;
   if substr(formed_string, length(formed_string), length(NL)) ^= NL then do;
      Lformed_string = Lformed_string + length(NL);
      substr(formed_string,length(formed_string),length(NL)) = NL;
      end;
   return;   

form_string$var:
   entry (var_str);
  
dcl	var_str			char(*) var;

   Lorig = length(formed_string);
   Lformed_string = length(formed_string) + length(var_str);
   substr(formed_string, Lorig+1) = var_str;
   return;

form_string$init:
   entry;

   Lformed_string = 0;
   Pformed_string = d.temp_seg.Pformed_string;

   end form_string$fixed;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

dcl	Presult			ptr,
	Lresult			fixed bin(21),
	result			char(Lresult) based(Presult),
	result_array(Lresult)	char(1) based(Presult);

format_comments:
   proc;

dcl	chr_cmtno			char(4) aligned,
	footer			char (74) aligned,
	header			char (79) var,
   	ll			fixed bin,
	save_footer		char (74) var;	/* undented 5 */

   if d.seg.type = 1 | d.seg.type = 4 then do;
      if Sblank_before then
         header = NL || d.seg.cmt_bgn || SP || "HISTORY COMMENTS:" || NL;
      else
         header = d.seg.cmt_bgn || SP || "HISTORY COMMENTS:" || NL;
      save_footer = "END HISTORY COMMENTS" || SP || d.seg.cmt_end;      
      ll = 79;
      end;
   else do;					/* exec com or alm				*/
      if Sblank_before then
         header = NL || SP || "HISTORY COMMENTS:" || NL;
      else
         header = SP || "HISTORY COMMENTS:" || NL;
      save_footer = "END HISTORY COMMENTS";
      ll = 79 - (length(d.seg.cmt_bgn) + length(SP));
      end;
   footer = "";
   substr(footer,length(footer)-length(save_footer)+1) = save_footer;

   call form_string$init();
   call form_string$var(header);
   do i = 1 to src_array.Ncoms;
      call format_comment$body(src_array.comments(i));
      end;
   call form_string$fixed_line(".inl 0");
   call form_string$fixed_line(footer);
   if Sblank_after then
      call form_string$fixed(NL);
   call format_comment$fdoc(ll);

   if d.seg.type ^= 1 & d.seg.type ^= 4 then do;		/* add comment beginning for non-pl1 source	*/
      call form_string$init();
      do while (Lresult > 0);
         i = index(result,NL);
         if i > 0 then do;
	  if d.seg.type = 2 & substr(result,1,i-1) = "" then
						/* dont add cmt_bgn for blank lines for alm progs	*/
	     call form_string$fixed(substr(result,1,i));
	  else
	     call form_string$fixed(d.seg.cmt_bgn || substr(result,1,i));
	  Presult = addcharno(addr(result_array(i)), 1);
	  Lresult = Lresult - i;
	  end;
         else do;
	  call form_string$fixed(d.seg.cmt_bgn || result);
	  Lresult = 0;
	  end;
         end;
      Lresult = Lformed_string;			/* reset result				*/
      Presult = Pformed_string;
      end;
   return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

format_comment$body:
   entry(cmt);

dcl	1 cmt			aligned like src_array.comments;

   call form_string$fixed_line(".inl 5");
   call form_string$fixed_line(".unl 5");
   chr_cmtno = reverse(ltrim(char(cmt.comment_no)) || ")");
   chr_cmtno = reverse(chr_cmtno);
   call form_string$fixed(chr_cmtno);
   call form_string$fixed(" change");
   call form_string$fixed("(");
   call form_string$fixed(cmt.change_dt);
   call form_string$fixed(",");
   call form_string$var(cmt.change_person);
   call form_string$fixed(")");
   if cmt.approve_dt ^= "" then do;
      call form_string$fixed(",");
      call form_string$fixed(NL);
      call form_string$fixed("approve");
      if cmt.approve_dt = "^" then 
         call form_string$fixed("()");
      else do;
         call form_string$fixed("(");
         call form_string$fixed(cmt.approve_dt);
         call form_string$fixed(",");
         call form_string$var(cmt.approve_value);
         call form_string$fixed(")");
         end;
      end;
   if cmt.audit_dt ^= "" then do;
      call form_string$fixed(",");
      call form_string$fixed(NL);
      call form_string$fixed("audit");
      if cmt.audit_dt = "^" then 
         call form_string$fixed("()");
      else do;
         call form_string$fixed("(");
         call form_string$fixed(cmt.audit_dt);
         call form_string$fixed(",");
         call form_string$var(rtrim(cmt.audit_person));
         call form_string$fixed(")");
         end;
      end;
   if cmt.install_dt ^= "" then do;
      call form_string$fixed(",");
      call form_string$fixed(NL);
      call form_string$fixed("install");
      if cmt.install_dt = "^" then 
         call form_string$fixed("()");
      else do;
         call form_string$fixed("(");
         call form_string$fixed(cmt.install_dt);
         call form_string$fixed(",");
         call form_string$var(cmt.install_id);
         call form_string$fixed(")");
         end;
      end;
   call form_string$fixed(":  ");
   call form_string$fixed_line(".brf");
   if cmt.fill then do;
      call form_string$fixed_line(".fin");
      call form_string$var(cmt.summary);
      call form_string$fixed_line(".fif");
      end;
   else do;
      call form_string$fixed_line(".fif");
      call form_string$var(cmt.summary);
      end;
   call form_string$fixed_line(".fin");
   end format_comments;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


format_comment$fdoc:
   proc (line_length);

dcl	line_length		fixed bin;

   unspec(fdoc) = "0"b;
   fdoc.version_number = format_document_version_2;
   fdoc.line_length = line_length;
   fdoc.switches = "0"b;
   fdoc.pgno_sw = "0"b;
   fdoc.adj_sw = "0"b;
   fdoc.galley_sw = "1"b;
   fdoc.error_sw = "0"b;
   fdoc.literal_sw = "0"b;
   fdoc.dont_compress_sw = "1"b;
   fdoc.break_word_sw = "1"b;
   fdoc.max_line_length_sw = "1"b;
   fdoc.dont_break_indented_lines_sw = "1"b;
   fdoc.sub_err_sw = "1"b;
   fdoc.dont_fill_sw = "0"b;
   fdoc.hyphenation_sw = "0"b;

   Presult = d.temp_seg.Presult;
   Lresult = sys_info$max_seg_size*CHARS_PER_WORD;
   call format_document_$string(formed_string, result, Lresult, addr(fdoc), code);
   if code ^= 0 & code ^= error_table_$recoverable_error then
      call check_error (code, CALLER, "^/^3xError while formatting the string.", formed_string);

end format_comment$fdoc;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

GET_fields:
   proc;

call form_string$init();
call form_string$fixed_line(".inl 3");

do i = 1 to src_array.Ncoms;
   if src_array.comments(i).selected then do;
      do j = 1 to hbound(d.field_array,1) while(d.field_array(j) ^= 0);
         if j = 1 then
	  call form_string$fixed_line(".unl 3");
         goto CASE(d.field_array(j));
CASE(0):						/* ERROR - no fields were selected		*/
      call check_error (error_table_$bad_arg, CALLER, "^a^/^3xNo field values were selected.",
         pathname_$component(d.seg.dir, d.seg.ent, d.seg.comp));
CASE(1):						/* change date				*/
      if d.Saf then
         call d.add_to_return_arg((src_array.comments(i).change_dt));
      else do;
         call form_string$fixed(src_array.comments(i).change_dt);
         call form_string$fixed(" ");
         end;
      goto END_CASE;
CASE(2):						/* change person id				*/
      if d.Saf then
         call d.add_to_return_arg_var(src_array.comments(i).change_person);
      else do;
         call form_string$var(src_array.comments(i).change_person);
         call form_string$fixed(" ");
         end;
      goto END_CASE;
CASE(3):						/* approve date				*/
      if d.Saf then
         call d.add_to_return_arg((src_array.comments(i).approve_dt));
      else do;
         call form_string$fixed(src_array.comments(i).approve_dt);
         call form_string$fixed(" ");
         end;
      goto END_CASE;
CASE(4):						/* approve value				*/
      if d.Saf then
         call d.add_to_return_arg_var(src_array.comments(i).approve_value);
      else do;
         call form_string$var(src_array.comments(i).approve_value);
         call form_string$fixed(" ");
         end;
      goto END_CASE;
CASE(5):						/* audit date				*/
      if d.Saf then
         call d.add_to_return_arg((src_array.comments(i).audit_dt));
      else do;
         call form_string$fixed(src_array.comments(i).audit_dt);
         call form_string$fixed(" ");
         end;
      goto END_CASE;
CASE(6):						/* auditor				*/
      if d.Saf then
         call d.add_to_return_arg_var(src_array.comments(i).audit_person);
      else do;
         call form_string$var(src_array.comments(i).audit_person);
         call form_string$fixed(" ");
         end;
      goto END_CASE;
CASE(7):						/* install date				*/
      if d.Saf then
         call d.add_to_return_arg((src_array.comments(i).install_dt));
      else do;
         call form_string$fixed(src_array.comments(i).install_dt);
         call form_string$fixed(" ");
         end;
      goto END_CASE;
CASE(8):						/* install id				*/
      if d.Saf then
         call d.add_to_return_arg_var(src_array.comments(i).install_id);
      else do;
         call form_string$var(src_array.comments(i).install_id);
         call form_string$fixed(" ");
         end;
      goto END_CASE;
CASE(9):						/* summary				*/
      if d.Saf then
         call d.add_to_return_arg_var(src_array.comments(i).summary);
      else do;
         call form_string$var(src_array.comments(i).summary);
         call form_string$fixed(" ");
         end;
      goto END_CASE;
END_CASE:
      end;
   end;
  end;
  if ^d.Saf then do;
     call format_comment$fdoc (get_line_length_$switch(null,code));
     call ioa_("^a",result);
     end;

end GET_fields;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

get_language_info:
   proc(seg);

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* This procedure determines the parameters of the language of the source segment. These	*/
	/* parameters are: type, name, and comment begin and end delimiters.			*/
	/* If the source is an exec_com or absin, there are two added parameters needed: the	*/
	/* version (ec_version) and the character position of the first non-version character	*/
	/* (text_pos). These values are obtained from calling get_ec_version_.		*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

dcl 1 seg		    aligned like d.seg;

dcl comp_or_ent         char(32);

dcl Acode		    fixed bin(35),
    Ilang               fixed bin,
    language            char(8) var;			/* language name */

%include pnotice_language_info_;

   seg.ec_version = 0;
   seg.text_pos = 0;
   if seg.comp = "" then				/* determine if archive component or entry name	*/
      comp_or_ent = seg.ent;
   else
      comp_or_ent = seg.comp;
   if index(comp_or_ent, ".") = 0 then			/* primarily for the archive case, if it is a */
      call check_error (error_table_$bad_file_name, CALLER, "^/^3x^a^/^3xSingle-component entrynames not permitted.",
         pathname_$component (seg.dir, seg.ent, seg.comp)); /*check_error returns a code of 0 & comes back here*/
   language = reverse(before(reverse (comp_or_ent), "."));	/* determine language name			*/

   do Ilang = 1 to hbound(pnotice_language_info.languages.lang_array, 1) while
      (language ^= pnotice_language_info.languages.lang_array(Ilang).lang_name);
      end;					/* look it up in pnotice_language_info_ */
   if Ilang > pnotice_language_info.languages.N then do;
      if language = "archive" then
         call check_error (-1, CALLER, "^a^/^3xArchived archives are not supported.",
	  pathname_$component (seg.dir, seg.ent, seg.comp));
      else
         call check_error (-1, CALLER, "^a^/^3xThe ^a suffix is not supported because it is not defined in^/^3xpnotice_language_info_. Entry not processed.",
         pathname_$component(d.seg.dir,d.seg.ent,d.seg.comp),language);
      end;

   seg.type = pnotice_language_info.languages.lang_array(Ilang).lang_type;
						/* type better be 1, 2, 3, 4, or 5	*/
   if seg.type < 1 | seg.type > 5 then
      call check_error (-1, CALLER, "^a^/^3xLanguage type (^d) found for the ^a suffix in pnotice_language_info_
is not implemented.",
         pathname_$component(seg.dir, seg.ent, seg.comp),seg.type, language);
						/* get comment delimiters               */
   seg.cmt_bgn = pnotice_language_info.languages.lang_array(Ilang).comment_start;
   seg.cmt_end = pnotice_language_info.languages.lang_array(Ilang).comment_end;

   if seg.type = 3 then do;
      if d.seg.comp ^= "" then			/* can't support archived exec_coms		*/
         call check_error (-1, CALLER, "^a^/^3xProcessing of archived exec_coms is not supported.",
	  pathname_$component (seg.dir, seg.ent, seg.comp));

      call get_ec_version_ (d.seg.dir, d.seg.ent, seg.ec_version, seg.text_pos, Acode);
      if Acode ^= 0 then
         call check_error (Acode, CALLER, "^a^/^3xGetting ec version.",
	  pathname_$component(seg.dir, seg.ent, seg.comp));
      if seg.text_pos < 1 then			/* prevent invalid subscripting */
         seg.text_pos = 1;
      if seg.ec_version = 1 then
         seg.cmt_bgn = seg.cmt_bgn || SP;
      else
         seg.cmt_bgn = seg.cmt_bgn || "-";
      end;
   end get_language_info;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


init_structures:
	proc;

init_structures$array:				/* initialize fields of arrays		*/
  entry(array_in);
  
  dcl 1 array_in               aligned like src_array.comments;
  
  array_in.change_dt = "";
  array_in.seqno = 0;
  array_in.fill = "0"b;
  array_in.selected = "0"b;
  array_in.Ieq = 0;
  array_in.comment_no = 0;
  array_in.change_person = "";
  array_in.approve_dt = "";
  array_in.approve_value = "";
  array_in.audit_dt = "";
  array_in.audit_person = "";
  array_in.install_dt = "";
  array_in.install_id = "";
  array_in.summary = "";
  array_in.err_msg = "";

  return;

init_structures$src_array:
	entry;
        	      
   Psrc_array = d.temp_seg.Psrc_array;
   src_array.Ncoms = 0;
   return;

init_structures$orig_array:
          entry;

   Porig_array = d.temp_seg.Porig_array;
   orig_array.Ncoms = 0;
   return;

end init_structures;



/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

insert_notice:
   proc;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* This procedure adds the notice to a segment. In the case of free-standing segments,	*/
	/* the target is the segment itself, but for archives, the target is a copy of the	*/
	/* archive component in the process dir. The archive command then will update the	*/
	/* archive via process_archive_components.					*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

dcl	Psource			ptr,
	Ptarget			ptr,
	new_box			char(d.seg.Lnewbox) based (d.seg.Pbox);

    d.seg.Lnewbox = Lresult;				/* lgth of pnotice + lgth of comments		*/

    Psource = addcharno (d.seg.Pbox, d.seg.Loldbox);	/* ptr to start of history comment box		*/
                                                            /* + length of old history comments		*/
    Ptarget = addcharno (d.seg.Pbox, d.seg.Lnewbox);	/* ptr to start of history comment box		*/
                                                            /* + length of result (old + new) history comments*/
						/* determine proper size hole for append */
						/* if new box is same size, we go by this. */
    if d.seg.Lnewbox > d.seg.Loldbox then		/* new notice box larger than old */
       call pnotice_mrl_ (Psource, d.seg.Lseg_in - d.seg.Loldbox, Ptarget, d.seg.Lseg_in - d.seg.Loldbox);
						/* append seg */
    else if d.seg.Lnewbox < d.seg.Loldbox then		/* new notice box smaller than old */
						/* this may happen if source had >1 box in it */
      call pnotice_mlr_ (Psource, d.seg.Lseg_in - d.seg.Loldbox, Ptarget, d.seg.Lseg_in - d.seg.Loldbox);

    d.seg.Lseg_out = (d.seg.Lseg_in - d.seg.Loldbox) + d.seg.Lnewbox;

    new_box = result;
						/* copy box back from temp storage */

end insert_notice;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

INSTALL_ck:
   proc;

   dcl   Snew_comment		bit,
         Sequal			bit,
         Serrors			bit,
         Sinstall			bit,
         Sinstall_match		bit,
         Sapprove			bit;
   

/* The following generic errors will be generated:						*/
/*   No missing approve values were found.							*/
/*   No missing install values were found.							*/
/*   (path) contains no new comments.								*/
/*											*/
/* The following individual cmt errors will be put in err_msg as appropriate:				*/
/*   has been backed out.									*/
/*   is missing audit value(s).								*/
/*   is misssing summary.									*/
/*   original installation id MRxxx.x-xxxx is different.						*/

   Snew_comment = FALSE;
   Sany_found = FALSE;
   Serrors = FALSE;
   Sinstall = FALSE;
   Sinstall_match = FALSE;
   Sapprove = FALSE;
   call form_string$init();				/* The select switch is on for those cmts selected*/
						/* Set the switch off for those not in error	*/
						/* as only these will be printed		*/
   
   if d.ag.orig.path = "" then 
      ;
   else if Porig_array ^= null then
           if orig_array.Ncoms > 0 then			/* new module being installed	or no cmts in orig	*/
              goto ORIG_CK;

SRC_CK:
   if src_array.Ncoms = 0 then do;			/* error no comments are present		*/
      Serrors = TRUE;
      if ^d.Saf then
         call check_error (error_table_$improper_data_format, CALLER, "^a contains no comments.",
         pathname_$component(d.seg.dir, d.seg.ent, d.seg.comp));
      end;
   else do;
      src_array.comments(*).selected = FALSE;
      goto INSTALL_values;
      end;

ORIG_CK:
   do i = 1 to src_array.Ncoms;			/* find out if there are new comments in source	*/
						/* check install ids			*/
      k = 0;
      Sequal = FALSE;
      do j = 1 to orig_array.Ncoms while(^Sequal);
         if comments_comparable(src_array.comments(i), orig_array.comments(j)) then do;
	  if comments_almost_equal (src_array.comments(i), orig_array.comments(j)) then do;
						/* src, audit, and summary fields are equal	*/
	     if src_array.comments(i).install_id = "" then do;
						/* src install id will be equal to orig 	*/
	        src_array.comments(i).install_id = orig_array.comments(j).install_id;
	        src_array.comments(i).install_dt = orig_array.comments(j).install_dt;
	        src_array.comments(i).selected = TRUE;
	        Sequal = TRUE;			/* if requested install id matches an existing id	*/
						/* set switch so no error will be flaged on AF	*/
	        end;
	     else if src_array.comments(i).install_id ^= orig_array.comments(j).install_id then do;
						/* installation ids must be the same		*/
	        Serrors = TRUE;
	        src_array.comments(i).err_msg(k+1) = ("original installation id "
		 || orig_array.comments(j).install_id || " is different");
	        end;
	     end;
	  if ^Sequal & comments_equal (src_array.comments(i), orig_array.comments(j)) then do;
	     src_array.comments(i).selected = FALSE;
	     orig_array.comments(j).selected = FALSE;
	     Sequal = TRUE;
	     end;
	  end;
         if ^Sequal then				/* new comment found			*/
	  Snew_comment = TRUE;
      end;
   end;

   if ^Snew_comment then do;
      Serrors = TRUE;
      if ^d.Saf then
         call check_error (error_table_$improper_data_format, CALLER, "^a contains no new comments.",
         pathname_$component(d.seg.dir, d.seg.ent, d.seg.comp));
      end;
      
   do i = 1 to orig_array.Ncoms;
      if orig_array.comments(i).Ieq = 0 then do;
         Serrors = TRUE;
         orig_array.comments(i).selected = TRUE;
         orig_array.comments(i).err_msg(1) = "has been backed out from source.";
						/* This is the only error msg for the orig array	*/
         end;
      end;
   
INSTALL_values:
   k = 0;
   do i = 1 to src_array.Ncoms;
      if src_array.comments(i).audit_dt = ""  & src_array.comments(i).audit_person = "" then do;
         Serrors = TRUE;
         src_array.comments(i).err_msg(k+1) = "missing audit value(s).";
         src_array.comments(i).selected = TRUE;
         end;
      if src_array.comments(i).summary = "" then do;
         Serrors = TRUE;
         src_array.comments(i).err_msg(k+1) = "missing summary.";
         src_array.comments(i).selected = TRUE;
         end;
      if src_array.comments(i).approve_dt = "" & d.input.select.apv = NOxxx then do;
         Serrors = TRUE;
         src_array.comments(i).err_msg(k+1) = "missing approve field(s).";
         src_array.comments(i).selected = TRUE;
         end;
      if index(src_array.comments(i).approve_value,"fix_") > 0 
         & ^d.Scfix then do;
         Serrors = TRUE;
         src_array.comments(i).err_msg(k+1) = "contains a critical fix number.";
         src_array.comments(i).selected = TRUE;
         end;
      if src_array.comments(i).install_dt = "" then 
         Sinstall = TRUE;
      else if src_array.comments(i).install_id = d.ag.input.value.install_id then do;
						/* If an existing id matches the requested one	*/
						/* do not flag it as an error but continue	*/
	  Sinstall_match = TRUE;
	  src_array.comments(i).selected = TRUE;
	  end;

      if src_array.comments(i).approve_dt = "" then
         Sapprove = TRUE;
      end;

   if ^Sinstall & ^Sinstall_match then do;
      call d.set_return_arg("false");
      call check_error(error_table_$bad_arg, CALLER, "^/^a ^/^3xNo missing installation fields were found.",
         pathname_$component(d.seg.dir, d.seg.ent, d.seg.comp));
      end;

/* Those comments which are selected and have src_array.err_msg = "" */
/* are valid and will be updated if no other errors are present.     */

      if ^Serrors then do i = 1 to src_array.Ncoms;
         if d.input.select.apv = OPERANDxxx | d.input.select.apv = INPUTxxx then do;
	  if src_array.comments(i).approve_dt = "" & src_array.comments(i).approve_value = "" then do;
	     src_array.comments(i).approve_dt = current_date;
	     src_array.comments(i).approve_value = d.ag.input.value.approve_value;
	     src_array.comments(i).selected = TRUE;
	     Sany_found = TRUE;
	     end;
	  end;
         if src_array.comments(i).install_dt = "" then do;
	  src_array.comments(i).install_dt = current_date;
	  src_array.comments(i).install_id = d.ag.input.value.install_id;
	  src_array.comments(i).selected = TRUE;
	  Sany_found = TRUE;
	  end;
         end;

      if Sinstall_match then				/* install id in src was filled in from the orig	*/
         Sany_found = TRUE;

      if ^Serrors then do;				/* cmts were found without errors		*/
         call format_comments();
         call insert_notice();
         end;

      if ^Sany_found then do;
         if ^d.ctl.errors then do;
	  if d.Saf then
	     call d.set_return_arg("false");
	  else
	     call ioa_ ("^/^a:^/^3xFailed the preinstallation check.",
	     pathname_$component(d.seg.dir, d.seg.ent, d.seg.comp));
	  goto ERROR_RETURN_LABEL;
	  end;
         do i = 1 to src_array.Ncoms;
	  if src_array.comments(i).selected = TRUE then do;	/* cmts were found with errors		*/
	     do j = 1 to hbound(src_array.comments.err_msg,2) while(src_array.comments(i).err_msg(j) ^= "");
	        if j = 1 then
		 call form_string$var("Comment " || ltrim(char(src_array.comments(i).comment_no)) || " ");
	        else
		 call form_string$fixed(", ");
	        call form_string$var(src_array.comments(i).err_msg(j));
	        end;
	     if src_array.comments(i).err_msg(1) ^= "" then do;
	        /* only cmts with errors are being displayed here */
	        call format_comment$body(src_array.comments(i));
	        call form_string$fixed_line(".unl 5");
	        end;
	     end;
	  end;

         if d.ag.orig.path ^= "" then do i = 1 to orig_array.Ncoms;
	  if orig_array.comments(i).selected = TRUE then do; /* only 1 error is possible with orig array	*/
	     call form_string$var("Comment " || ltrim(char(orig_array.comments(i).comment_no)) || " " || 
	        orig_array.comments(i).err_msg(1));
	     call format_comment$body(orig_array.comments(i));
	     call form_string$fixed(NL);
	     end;
	  end;
         
         call format_comment$fdoc(get_line_length_$switch(null,code));
         call ioa_("^a^/^a",pathname_$component(d.seg.dir, d.seg.ent, d.seg.comp), result);
         if d.Saf then
	  call d.set_return_arg("false");
         call check_error (-1, "", "");
         end;

      else do;
         call form_string$init();
         do i = 1 to src_array.Ncoms;
	  if src_array.comments(i).selected = TRUE then do;
	     call format_comment$body(src_array.comments(i));
	     call form_string$fixed(NL);
	     end;
	  end;
         call format_comment$fdoc(get_line_length_$switch(null,code));
         call ioa_$nnl("^a^/^a",pathname_$component(d.seg.dir, d.seg.ent, d.seg.comp), result);
         end;

END_INSTALL_CK:
      
end INSTALL_ck;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

prompt_req:
   proc;

dcl	APV_EXP			char(57) int static options(constant) init(
"Identifier authorizing the change.  For example: MCR6734."),
	INSTALL_EXP		char(114) int static options(constant) init(
"Identifier associated with installing the changed module into the
execution libraries.  For example: MR12.0-00234."),
	SUMMARY_EXP		char(47) int static options(constant) init(
"Text summarizing the change made to the module.");

dcl      reply	                    char(maxlength(d.ag.input.summary)+1) var;

   query_info.version = 7;
   query_info.ending_delim = "";
   query_info.suppress_name_sw = TRUE;
   query_info.prompt_after_explanation = TRUE;
   query_info.cp_escape_control = "11"b;		/* Needed since nobody has called 		*/
						/* hcom_command_query_$set_cp_escape_enable.	*/

   if d.ag.input.apv = INPUTxxx then do;
      query_info.explanation_ptr = addr(APV_EXP);
      query_info.explanation_len = length(APV_EXP);
RE_APV:
      call hcom_command_query_ (addr(query_info), reply, CALLER, "Enter approve value:");
      if reply ^= "" then do;
         d.ag.input.value.approve_value = reply;
         valid = TRUE;
         if d.Scfix then
	  call hcom_cfix_validate_ ((CALLER), APPROVAL_FIELD_NAME,
	     d.ag.input.value.approve_value, valid, 
	     d.ag.input.value.approve_value,"", "");
         else
	  call d.ag.vdt ((CALLER), APPROVAL_FIELD_NAME,
	     d.ag.input.value.approve_value, valid,
	     d.ag.input.value.approve_value, "", "");
         if ^valid then
	  goto RE_APV;
         d.ag.input.value.approve_dt = current_date;
         d.ag.input.apv = OPERANDxxx;
         end;
      else
         d.ag.input.apv = NOxxx;
      end;

   if d.ag.input.in = INPUTxxx then do;
      query_info.explanation_ptr = addr(INSTALL_EXP);
      query_info.explanation_len = length(INSTALL_EXP);
RE_INSTALL:
      call hcom_command_query_ (addr(query_info), reply, CALLER, "Enter installation id:");
      if reply ^= "" then do;
         d.ag.input.value.install_id = reply;
         valid = TRUE;
         if d.Scfix then
	  call d.ag.vdt ((CALLER), INSTALL_FIELD_NAME,
	     d.ag.input.value.install_id, valid,
	     d.ag.input.value.install_id, "", error_msg);
         else
	  call d.ag.vdt ((CALLER), INSTALL_FIELD_NAME,
               d.ag.input.value.install_id, valid,
	     d.ag.input.value.install_id, "", error_msg);
         if ^valid then do;
            call ioa_ ("^3x^a", error_msg);
	  goto RE_INSTALL;
	  end;
         d.ag.input.value.install_dt = current_date;
         d.ag.input.in = OPERANDxxx;
         end;
      else do;
         if d.ag.op.name = INSTALL then do;
	  call ioa_ ("^/^a^/The install id is required for the install operation", 
	     pathname_$component(seg.dir,seg.ent,seg.comp));
	  go to RE_INSTALL;
	  end;
         else
            d.ag.input.in = NOxxx;
         end;
      end;

   if d.ag.input.sm = INPUTxxx then do;
      query_info.explanation_ptr = addr(SUMMARY_EXP);
      query_info.explanation_len = length(SUMMARY_EXP);
      query_info.ending_delim = ".";
      query_info.ending_delim_description = "a period";
RE_SUMMARY:
      call hcom_command_query_ (addr(query_info), reply, CALLER, "Enter summary:");
      if length(reply) > maxlength(d.ag.input.summary)-15 then do;
						/* need 15 chars for compose values		*/
         call ioa_ ("^/^a^/Summary length is greater than ^d characters.",
      pathname_$component(seg.dir,seg.ent,seg.comp),maxlength(d.ag.input.summary)-15);
         goto RE_SUMMARY;
         end;
      else
         if reply ^= "" then do;
	  d.ag.input.value.summary = reply || NL;
	  d.ag.input.sm = OPERANDxxx;
	  end;
      else do;
         call ioa_ ("A summary must be provided in every history comment.");
         go to RE_SUMMARY;
         end;
      end;

   end prompt_req;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

REPLACE_FIELDs:
   proc;

   do i = 1 to src_array.Ncoms;
      if src_array.comments(i).selected then do;
         if d.ag.input.sm = OPERANDxxx then do;
	  src_array.comments(i).summary = d.ag.input.value.summary;
	  src_array.comments(i).fill = d.ag.ctl.fill;
	  end;

         if d.ag.input.apv = OPERANDxxx then do;
            src_array.comments(i).approve_value =
	     d.ag.input.value.approve_value;
            src_array.comments(i).approve_dt = d.ag.input.value.approve_dt;
            end;
         else if d.ag.input.apv = CLEARxxx then 
	  src_array.comments(i).approve_value,
	     src_array.comments(i).approve_dt = "";

         if d.ag.input.aud = OPERANDxxx then do;
	  if src_array.comments(i).change_person = d.ag.input.value.audit_person then
	     call check_error (-1, CALLER, "^a^/^3xYou created the matching history comment ^d and cannot also be the auditor.",
	        pathname_$component (d.seg.dir, d.seg.ent, d.seg.comp),
	        src_array.comments(i).comment_no);
            src_array.comments(i).audit_person = d.ag.input.value.audit_person;
            src_array.comments(i).audit_dt = d.ag.input.value.audit_dt;
            end;					/* Currently, there is no way to specify to clear */
         else if d.ag.input.aud = CLEARxxx then		/*  the audit field.  But there may be someday.	*/
	  src_array.comments(i).audit_person,
	     src_array.comments(i).audit_dt = "";

         if d.ag.input.in = OPERANDxxx then do;
            src_array.comments(i).install_id = d.ag.input.value.install_id;
            src_array.comments(i).install_dt = d.ag.input.value.install_dt;
            end;
         else if d.ag.input.in = CLEARxxx then
	  src_array.comments(i).install_id,
	     src_array.comments(i).install_dt = "";
         end;
      end;

   end REPLACE_FIELDs;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

select_comments:
   proc(Sany_selected) returns(bit(1));

dcl	Sequal			bit(1),
	Sany_selected		bit(1);

   Sany_selected = FALSE;

   if src_array.Ncoms > 0 then do;
      if d.com_spec.Nrange = 0 then do;			/* if no range assume all			*/
         src_array.comments(*).selected = TRUE;
         Sany_selected = TRUE;
         end;
      else do;
         src_array.comments(*).selected = FALSE;
         do i = 1 to d.com_spec.Nrange;
	  d.com_spec.range(i).from.result = get_range(d.com_spec.range(i).from);
	  if d.com_spec.range(i).to.set ^= UNSET then
	     d.com_spec.range(i).to.result= get_range(d.com_spec.range(i).to);
	  else
	     d.com_spec.range(i).to.result = d.com_spec.range(i).from.result;
	  
	  do j = d.com_spec.range(i).from.result to d.com_spec.range(i).to.result;
	     src_array.comments(j).selected = TRUE;
	     Sany_selected= TRUE;			/* at least one comment was selected		*/
	     end;
	  end;
         end;
      end;

   if Porig_array ^= null then
      orig_array.comments(*).selected = FALSE;

   if Sany_selected & string(d.com_spec.selected) ^= FALSE then do;
      Sany_selected = FALSE;
      do i = 1 to src_array.Ncoms;			/* if a comment range/number was specified but no */
						/* com_specs were selected, d.com_spec.selected	*/
						/* would be FALSE.				*/
         d.com_spec.matched = FALSE;
         if src_array.comments(i).selected then do;
	  d.com_spec.matched.all = d.com_spec.selected.all;
	  d.com_spec.matched.cpt =
	     d.com_spec.selected.cpt &
	     src_array.comments(i).approve_dt ^= "" &
	     src_array.comments(i).audit_dt ^= "" & 
	     src_array.comments(i).install_dt ^= "";
	  d.com_spec.matched.icpt =
	     d.com_spec.selected.icpt &
	     (src_array.comments(i).approve_dt = "" |
	      src_array.comments(i).audit_dt = "" | 
	      src_array.comments(i).install_dt = "");
	  d.com_spec.matched.apv = d.com_spec.selected.apv &
	     src_array.comments(i).approve_dt ^= "";
	  d.com_spec.matched.unapv = d.com_spec.selected.unapv &
	     src_array.comments(i).approve_dt = "";

	  d.com_spec.matched.aud = d.com_spec.selected.aud &
	     src_array.comments(i).audit_dt ^= "";
	  d.com_spec.matched.unaud = d.com_spec.selected.unaud &
	     src_array.comments(i).audit_dt = "";
	  d.com_spec.matched.in = d.com_spec.selected.in &
	     src_array.comments(i).install_dt ^= "";
	  d.com_spec.matched.unin = d.com_spec.selected.unin &
	     src_array.comments(i).install_dt = "";

	  if (d.com_spec.selected.new | d.com_spec.selected.old) &
	     Porig_array ^= null then do;
	     Sequal = FALSE;
	     do j = 1 to orig_array.Ncoms while (^Sequal);
	        if ^orig_array.comments(j).selected then do;
		 if comments_comparable (src_array.comments(i),
				     orig_array.comments(j)) &
	              comments_equal      (src_array.comments(i),
				     orig_array.comments(j)) then do;
		    orig_array.comments(j).selected = TRUE;
		    Sequal = TRUE;
		    end;
		 end;
	        end;
	     d.com_spec.matched.new =  (d.com_spec.selected.new  & ^Sequal);
	     d.com_spec.matched.old =  (d.com_spec.selected.old  &  Sequal);
	     end;

	  if d.ag.op.name = EXISTS | d.ag.op.name = GET |	/* For these operations, a comment is selected	*/
	     d.ag.op.name = REPLACE_FIELD then		/* ONLY if it matches ALL the comment specs.	*/
	     src_array.comments(i).selected =
	        (string(d.com_spec.selected) = string(d.com_spec.matched));
	  else					/* For other operations, a comment is selected if */
	     src_array.comments(i).selected =		/* it matches ANY of the comment specs.		*/
	        (string(d.com_spec.matched) ^= ""b);
	  Sany_selected = (Sany_selected | src_array.comments(i).selected);
	  end;
         end;
      end;
   return(Sany_selected);

get_range:
   proc (arg_in) returns(fixed bin);

dcl	1 arg_in			aligned like d.com_spec.range.from;
   
   if arg_in.set = LAST then
      arg_in.no = src_array.Ncoms;
   if arg_in.op = PLUS then
      arg_in.result = arg_in.no + arg_in.addend;
   else if arg_in.op = MINUS then
      arg_in.result = arg_in.no - arg_in.addend;
   else arg_in.result = arg_in.no;

   if arg_in.result > src_array.Ncoms then
      call check_error (error_table_$bad_arg, CALLER, "^/^a^/^3xComment selection expression ^[^d^;^slast^]^[^s^;+^d^;-^d^]^[=^d^;^s^] is greater than the number^/^3xof existing comments (^d)",
         pathname_$component(d.seg.dir, d.seg.ent, d.seg.comp),
         arg_in.set, arg_in.no,
         arg_in.op+1, arg_in.addend,
         arg_in.set=LAST | arg_in.op^=UNSET, arg_in.result,
         src_array.Ncoms);
   if arg_in.result <= 0 then do;
      if d.ag.op.type ^= MODIFY & arg_in.set = LAST & arg_in.op = MINUS then
         arg_in.result = 1;
      else
         call check_error (error_table_$bad_arg, CALLER, "^/^a^/^3xComment selection expression ^[^d^;^slast^]^[^s^;+^d^;-^d^]^[=^d^;^s^] is less than comment number 1.",
	  pathname_$component(d.seg.dir, d.seg.ent, d.seg.comp),
	  arg_in.set, arg_in.no,
	  arg_in.op+1, arg_in.addend,
	  arg_in.set=LAST | arg_in.op^=UNSET, arg_in.result);
      end;
   return(arg_in.result);

   end get_range;
   
   end select_comments;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

sort_comments:
	proc (Porig);


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* This procedure is called upon to sort multiple history comments into the proper	*/
	/* order, i.e., ascending by comment number.					*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	

dcl Porig                      ptr,
    Psort_copy		 ptr;		

dcl 1 V			 aligned,			/* sort vector of pointers */
      2 N			 fixed bin (18),
      2 vector		 (Porig->src_array.Ncoms) ptr unaligned;
	
dcl 1 src_copy		 aligned based(Psort_copy),
      2 Ncoms		 fixed bin,
      2 comments(0 refer(src_copy.Ncoms)) like src_array.comments;

dcl 1 comment                  aligned like src_array.comments based;

dcl Idx1			 fixed bin;

dcl  sort_items_$char  entry(ptr, fixed bin(24));
	
          Psort_copy = d.temp_seg.Psort_copy;
	Psort_copy->src_copy.Ncoms = Porig->src_array.Ncoms;

	V.N = dim(Porig->src_array.comments,1);
	do Idx1 = lbound(Porig->src_array.comments,1) to hbound(Porig->src_array.comments,1);
	     V.vector(Idx1) = addr(Porig->src_array.comments(Idx1));
						/* get ptr value to it			*/
	     end;
                               
	call sort_items_$char (addr(V), 12);
						/* sort on change date and seq no		*/
    
          do Idx1 = 1 to V.N;
            Psort_copy->src_copy.comments(Idx1) = V.vector(Idx1)->comment;
            end;
    
          Porig = Psort_copy;

end sort_comments;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

%include format_document_options;

dcl	1 fdoc			aligned like format_document_options automatic;

%include hcom_data;

dcl	1 orig_array		aligned based(Porig_array),
	  2 Ncoms			fixed bin,
	  2 comments (0 refer (orig_array.Ncoms)) like src_array.comments,
	Porig_array		ptr;

%include hcom_field_names;

%include hcom_query_info;

%include pnotice_paths;

end hcom_process_seg_;
