/* ***********************************************************
   *                                                         *
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
   *                                                         *
   *                                                         *
   *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(85-09-27,LJAdams), approve(85-09-27,MCR7150),
     audit(86-02-07,Wallman), install(86-02-13,MR12.0-1017):
     The following
     changes were made:  (1) Accept -dc, -dts, and public_domain as valid
     pnotice names, (2) Accept multiple component prefixes for pnotice names,
     (3) Accept new format of template name without the date, and (4)
     compatibiltiy and validity checking of template names of user input and of
     psp_info_.
                                                   END HISTORY COMMENTS */


generate_pnotice:
	proc;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* NAME:	        generate_pnotice						*/
	/*									*/
	/* FUNCTION:								*/
	/*     This program is the tool that provides software protection notices (pnotices) for	*/
	/* the various Multics Priced Software Products (PSPs). There are numerous checks built	*/
	/* into the program to check the consistency and accuracy of the psp_info_ database,	*/
	/* which is the driver data structure for each PSP's protection notices. This program	*/
	/* also provides the Software Technical Identifiers (STIs) for each product. The method	*/
	/* used to protect each product is, basically, to build an ALM source  containing	*/
	/* pnotices and STIs. This source is put into the source archive (primary archive) of	*/
	/* the PSP. The ALM source is compiled, and that is put into the corresponding object	*/
	/* archive of the PSP.							*/
	/*									*/
	/* CREATED:     May 1981 by JM Stansbury.					*/
	/*									*/
	/* Modified:    June 1982 by JM Stansbury.					*/
	/*              1. To force access if necessary to archives if -special is used.	*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	

%page;
	

/*  A U T O M A T I C  */
dcl Fany		          bit (1),			/* flag to say that any args other than		*/
						/*  "-special" have been supplied.		*/
    Fcopy_right               bit (1),
    Fdcopy_right		bit (1),                      /* flag for indicating default copyright	*/
    Fdtrade_secret            bit (1),                      /* flag for indicating default trade secret	*/
    Fname		          bit (1),			/* flag for indication of the "-name" arg	*/
    Fmust_reset_object        bit (1),			/* indicate actions on acl			*/
    Fmust_reset_source	bit (1),
    Fsti		          bit (1),			/* flag for indication of the "-sti" arg	*/
    Fpublic_domain            bit (1),                      /* flag for indicating public domain		*/
    Fmid		          bit (1),			/* flag for indication of the "-id" arg for MIDs	*/
    Fspec		          bit (1),			/* flag for indication of the "-special" arg	*/
    Ftrade_secret             bit (1),                      
    Idx		          fixed bin,		/* general purpose indices			*/
    Idx1		          fixed bin,
    Idx2		          fixed bin,
    Idx3		          fixed bin,
    Isnotice	          fixed bin,
    Ionotice	          fixed bin,
    Larg		          fixed bin (21),		/* lgth of current argument			*/
    Ltemp		          fixed bin,		/* lgth of a single pnotice			*/
    Ltotal		fixed bin,		/* lgth of multiple pnotices			*/
    Nargs		          fixed bin,		/* no. of input args			*/
    Parg		          ptr,			/* ptr to current argument			*/
    P_line	          ptr,			/* ptr to a command line for cu_$cp		*/
    Piocb		          ptr,
    Pnotices	          ptr,			/* ptr to Ppaths temp seg for pnotice_paths_	*/
    Po_archive	          ptr,			/* ptr to the object archive			*/
    Ppsp_info                 ptr,                          /* ptr to psp_info_ structure			*/
    Ps_archive	          ptr,			/* ptr to the source archive			*/
    Ptemp		          ptr,			/* ptr to temp segment			*/
    answer		char (168) var,		/* from command_query_			*/
    sbit_count	          fixed bin (24),		/* bit count of source archive		*/
    obit_count	          fixed bin (24),		/* bit count of object archive		*/
    case		          fixed bin,
    code		          fixed bin (35),
    component_name	          char (32),		/* name of PNOTICE seg in an archive		*/
    current_year_a            char(4),
    Iyr                       fixed bin(24),
    sdir		          char (168),
    odir		          char (168),
    match_found		bit (1),			/* checks correspondence between source & object	*/
    object_pnotices	          fixed bin,		/* count of object pnotices			*/
    oentry		char (32),
    path		          char (168),
    pn		          char (512) var,		/* string containing text of multiple pnotices	*/
    prod		          char (20),		/* generic product name			*/
    prod_mid		char (7),			/* product marketing ID, if supplied via args	*/
    prod_object_pnotice       (10) char (32) var,
    prod_object_ename         char (32),
    prod_source_pnotice       (10) char (32) var,		/* use the primary name of template		*/
    prod_source_ename         char (32),
    prod_sti	          char (12),		/* product's STI number			*/
    sentry		char (32),
    source_pnotices	          fixed bin,		/* count of source pnotices			*/
    this_is_object_archive    bit(1),
    this_is_source_archive    bit(1),
    user_on_source_acl	bit(1),
    user_on_object_acl        bit(1),
    working_dir		char (168);
	

/*  B A S E D    A N D   S T R U C T U R E S */
dcl argument	          char (Larg) based (Parg);
dcl temp		          char (Ltemp) based (Ptemp);
dcl 1 ACI,
      2 aci like archive_component_info;		/* structure filled in by 			*/
						/* archive_$get_component_info		*/
dcl 1 ACIS		aligned int static options (constant),
      2 vers		fixed bin init (1),
      2 bc		fixed bin (24),
      2 c_ptr	          ptr,
      2 nm		char (32) unaligned,
      2 tmod	          fixed bin (71),
      2 tupd	          fixed bin (71),
      2 c_lgth	          fixed bin (19),
      2 acl		bit (36) unaligned;

						/* structure used by command_query_		*/
dcl 1 query_info	          aligned int static,
      2 version		fixed bin init (1),
      2 switches,
        3 yes_or_no_sw        bit (1) unal init ("0"b),
        3 suppress_name_sw    bit (1) unal init ("1"b),
        3 suppress_spacing_sw bit (1) unal init ("1"b),
        3 cp_escape_control   bit (2) unal init ("00"b),
        3 pad	          bit (31) unal,
      2 status_code	          fixed bin (35) init (0),
      2 query_code	          fixed bin (35) init (0),
      2 question_iocbp        ptr init (null),
      2 answer_iocbp	ptr init (null),
      2 repeat_time	          fixed bin (71) init (0);
	


/*  B U I L T I N  */
dcl (addr,
     after,
     before,
     clock,
     dim,
     hbound,
     index,
     length,
     null,
     reverse,
     rtrim,
     substr,
     unspec)	          builtin;

/*  C O N D I T I O N S  */
dcl (cleanup,
     not_in_write_bracket,
     no_write_permission)     condition;

/*  E N T R I E S  */
dcl alm			entry options(variable),
    archive		entry options(variable),
    archive_$get_component_info
			entry (ptr, fixed bin(24), char(*), ptr, fixed bin(35)),
    check_entryname_	entry (char(*), fixed bin(35)),
    com_err_		entry() options(variable),
    command_query_		entry() options(variable),
    cu_$arg_count		entry (fixed bin, fixed bin(35)),
    cu_$arg_ptr		entry (fixed bin, ptr, fixed bin(21), fixed bin(35)),
    date_time_$format         entry (char(*), fixed bin(71), char(*), char(*)) returns(char(250) var),
    delete_$path		entry (char(*), char(*), bit(6), char(*), fixed bin(35)),
    expand_pathname_	entry (char(*), char(*), char(*), fixed bin(35)),
    get_group_id_		entry() returns(char(32)),
    get_temp_segment_	entry (char(*), ptr, fixed bin(35)),
    get_wdir_		entry() returns(char(168)),
    hcs_$add_acl_entries	entry (char(*), char(*), ptr, fixed bin, fixed bin(35)),
    hcs_$delete_acl_entries	entry (char(*), char(*), ptr, fixed bin, fixed bin(35)),
    hcs_$initiate_count	entry (char(*), char(*), char(*), fixed bin(24), fixed bin(2), ptr, fixed bin(35)),
    hcs_$list_acl		entry (char(*), char(*), ptr, ptr, ptr, fixed bin, fixed bin(35)),
    ioa_			entry() options(variable),
    ioa_$ioa_switch		entry() options(variable),
    iox_$attach_ioname	entry (char(*), ptr, char(*), fixed bin(35)),
    iox_$close		entry (ptr, fixed bin(35)),
    iox_$detach_iocb	entry (ptr, fixed bin(35)),
    iox_$open		entry (ptr, fixed bin, bit(1) aligned, fixed bin(35)),
    list_pnotice_names	entry options(variable),
    parse_pnotice_info_       entry (ptr, fixed bin (35)),
    parse_pnotice_info_$validate_sti
			entry (char(12)) returns(bit(1)),
    pnotice_paths_		entry (char(*), bit(*), ptr, fixed bin(35)),
    release_temp_segment_	entry (char(*), ptr, fixed bin(35)),
    terminate_file_		entry (ptr, fixed bin(24), bit(*), fixed bin(35));
    

/*  E X T E R N A L   S T A T I C  */
dcl error_table_$badopt	          fixed bin(35) ext static,
    error_table_$name_not_found	fixed bin(35) ext static,
    error_table_$active_function        fixed bin(35) ext static,
    error_table_$no_w_permission	fixed bin(35) ext static,
    error_table_$lower_ring   	fixed bin(35) ext static,
    error_table_$no_component	          fixed bin(35) ext static,
    error_table_$noentry		fixed bin(35) ext static,
    error_table_$wrong_no_of_args	fixed bin(35) ext static;
	
	

/*  I N T E R N A L   S T A T I C  */
dcl ME			char (16) int static options (constant) init ("generate_pnotice"),
    NL		          char (1) int static options (constant) init ("
"),
    True		          bit (1) int static options (constant) init ("1"b),
    False		          bit (1) int static options (constant) init ("0"b);
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


	on cleanup call clean_up;
	call init;
	call cu_$arg_count (Nargs, code);
	if code = error_table_$active_function then
	     goto USAGE;
	else if Nargs = 0 then do;
	     code = error_table_$wrong_no_of_args;
	     go to USAGE;
	     end;
	do Idx = 1 to Nargs;
	     call cu_$arg_ptr (Idx, Parg, Larg, code);
	     if code ^= 0 then do;
		call com_err_ (code, ME, argument);
		return;
		end;
	     else if substr(argument, 1, 1) ^= "-" then
		goto USAGE;
	     else if argument = "-name" | argument = "-nm" then do;
		Idx = Idx + 1;
		call cu_$arg_ptr (Idx, Parg, Larg, code);
		if code ^= 0 then do;
		     call com_err_ (code, ME, "Arg= ^a", argument);
		     return;
		     end;
		prod = argument;			/* should be generic name of product.		*/
		Fany = True;
		Fname = True;
		end;
	     else if argument = "-id" then do;
		Idx = Idx + 1;
		call cu_$arg_ptr (Idx, Parg, Larg, code);
		if code ^= 0 then do;
		     call com_err_ (code, ME, "Arg= ^a", argument);
		     return;
		     end;
		prod_mid = argument;		/* product's marketing ID.			*/
		Fany = True;
		Fmid = True;
		end;
	     else if argument = "-sti" then do;		/* product STI. Input if user wants to 		*/
						/* over-ride psp_info_			*/
		Idx = Idx + 1;
		call cu_$arg_ptr (Idx, Parg, Larg, code);
		if code ^= 0 then do;
		     call com_err_ (code, ME, "Arg= ^a", argument);
		     return;
		     end;
		prod_sti = argument;
		if ^parse_pnotice_info_$validate_sti (prod_sti) then do;
		     call ioa_ ("Error - invalid STI: ^a", argument);
		     return;
		     end;
		Fany = True;
		Fsti = True;
		end;
	     else if argument = "-special" then
		Fspec = True;			/* user wants to provide most of the info.	*/
	     else do;
		code = error_table_$badopt;
		goto USAGE;
		end;
	     end;
MORE_TRASH:
	if Fname & Fmid then do;
	     call ioa_ ("The name and match args are mutually exclusive.");
	     code = error_table_$wrong_no_of_args;
	     goto USAGE;
	     end;
	else if Fspec & Fany then do;
	     call ioa_ ("The special arg is to be used alone.");
	     code = error_table_$wrong_no_of_args;
	     goto USAGE;
	     end;
	else go to WORK;
USAGE:	call com_err_ (code, ME, "
Usage:  generate_pnotice {-name | -nm <generic name>}
                         {-id <MID>}
		     {-sti <STI>}
		     {-special}");
	return;
WORK:	call get_temp_segment_ (ME, Ppsp_info, code);
	if code ^= 0 then do;
	     call com_err_ (code, ME, "getting temp seg for psp_info.");
	     return;
	     end;
	SI_ptr = Ppsp_info;
	call parse_pnotice_info_ (SI_ptr, code);	/* fill in the psp_info structure		*/
	if code ^= 0 then do;
	     call com_err_ (code, ME, "filling in psp_info.");
	     call release_temp_segment_ (ME, Ppsp_info, code);
	     return;
	     end;
	call pnotice_paths_ (ME, "00"b, Ppaths, code);	/* fill in template information		*/
	if code ^= 0 then				/* pnotice_paths_ will complain for us.		*/
	     goto CLEAN;				/* get out of this				*/
	pnotice_paths.templates(*).primary_name = before(pnotice_paths.templates(*).primary_name, ".pnotice");
						/* this program was written before pnotice_paths_ */
						/* was trained to return the entire name.	*/
	working_dir = get_wdir_ ();			/* use wdir for archives and PNOTICEs		*/
	if Fspec then do;
	     call get_PNOTICE_info;
	     goto CHECK_PN;
	     end;
	else if Fname then do;
	     do Idx3 = 1 to product.prod_number while (prod ^= product.num(Idx3).prod_name);
		end;
	     if Idx3 > product.prod_number then do;
		code = error_table_$name_not_found;
		call com_err_ (code, ME, "^/Looking for ""^a"" in psp_info_", prod);
		call clean_up;
		return;
		end;
	     end;
	else if Fmid then do;
	     do Idx3 = 1 to product.prod_number while (prod_mid ^= product.num(Idx3).MI);
		end;
	     if Idx3 > product.prod_number then do;
		code = error_table_$name_not_found;
		call com_err_ (code, ME, "^/Specified MID was not found in psp_info_.", prod_mid);
		call clean_up;
		end;
	     end;
	prod = product.num(Idx3).prod_name;		/* generic name				*/
	if product.num(Idx3).prod_use(1) ^= "" then do;
	     call ioa_ ("Multiple products found in psp_info_.
                 ^/Please use this command with each product.");
	     call clean_up;
	     return;
	     end;
	if ^Fsti then
	     prod_sti = product.num(Idx3).prod_STI;	/* STI in psp_info_ is for source code		*/
          Idx = 0;                                          /*Initialize index to 0			*/
	do Idx2 = 1 to 10 while (product.num(Idx3).source_C(Idx2) ^= "");
						/* get all source pnotice names		*/
	     prod_source_pnotice(Idx2) = product.num(Idx3).source_C(Idx2);
               Idx1 = check_name(prod_source_pnotice(Idx2));
               if Idx1 > pnotice_paths.Ntemplates then do;
                 code = error_table_$name_not_found;
                 call com_err_ (code, ME, "^/Invalid psp_info_ name - ^a.", prod_source_pnotice(Idx2));
                 goto CLEAN;
                 end;
               Idx = Idx + 1;
               if Idx > 1 then
                 if ^templates_compatible(prod_source_pnotice) then do;
                  call com_err_ (code, ME, "^a - ^/pnotice types not compatible.", prod);
                  goto CLEAN;
	        end;
	     source_pnotices = source_pnotices + 1;	/* count them				*/
	     end;
          Idx = 0;                                          /* Initialize index to 0			*/
	do Idx2 = 1 to 10 while (product.num(Idx3).object_C(Idx2) ^= "");
						/* get all object pnotice names		*/
	     prod_object_pnotice(Idx2) = product.num(Idx3).object_C(Idx2);
               Idx1 = check_name(prod_object_pnotice(Idx2));
               if Idx1 > pnotice_paths.Ntemplates then do;
                 code = error_table_$name_not_found;
                 call com_err_ (code, ME, "^/Invalid psp_info_ name - ^a.", prod_object_pnotice(Idx2));
                 goto CLEAN;
                 end;
               Idx = Idx + 1;
               if Idx > 1  then
                 if ^templates_compatible(prod_object_pnotice) then do;
                  call com_err_ (code, ME, "^a - ^/pnotice types not compatible.", prod);
                  goto CLEAN;
	        end;
	     object_pnotices = object_pnotices + 1;	/* count these too				*/
	     end;
						/* next, get source archive name		*/
	prod_source_ename = product.num(Idx3).source_path.entryname;
						/* next, get object archive name		*/
	prod_object_ename = product.num(Idx3).object_path.entryname;
CHECK_PN: 
	if source_pnotices = 1 & object_pnotices = 1 then do;
	     if prod_source_pnotice(1) = prod_object_pnotice(1) then
		case = 1;				/* only one PNOTICE source has to be made	*/
	     else case = 3;				/* two PNOTICE source segs needed		*/
	     end;
	else do;

	     if ^check_multiple_pnotices() then do;
		call ioa_ ("Unexpected errors encountered - procedure terminated.");
		call clean_up;
		return;
		end;
	     if source_pnotices ^= object_pnotices then do;
		case = 4;
		goto CONTINUE;
		end;
	     else do Idx = 1 to source_pnotices;	/* check to see if there is an object		*/
						/* pnotice corresponding to each source pnotice	*/
		match_found = False;
		do Idx2 = 1 to object_pnotices;
		     if prod_object_pnotice(Idx2) = prod_source_pnotice(Idx) then
			match_found = True;
		     end;
		if ^match_found then do;
		     case = 4;
		     goto CONTINUE;
		     end;
		end;
	     case = 2;
	     end;
	
CONTINUE: 
	call make_PNOTICE (case);			/* create the ALM source and object segs	*/
	if Fspec then
	     call archive_PNOTICE (sdir, odir);
	else
	     call archive_PNOTICE (working_dir, working_dir);
						/* put them into proper archives		*/
CLEAN:	call clean_up;				/* logical exit from the program		*/
	return;

%page;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
check_archive:
	proc (Adir, Aentry, Aptr);
	
dcl Adir		   char(*),
    Aentry	   char(*),
    Aptr		   ptr;
dcl one_word	   char(4) based;

	on not_in_write_bracket begin;
	     call com_err_ (error_table_$lower_ring, ME, "^/Writing ^a>^a.", Adir, Aentry);
	     goto CLEAN;
	     end;
	on no_write_permission goto COMPLAIN;
	Aptr -> one_word = Aptr -> one_word;		/* try to write the first word		*/
	return;					/* if it worked, everything is OK		*/
COMPLAIN: call com_err_ (error_table_$no_w_permission, ME, "^/Checking ACL of ^a>^a.", Adir, Aentry);
	goto CLEAN;
	end check_archive;

%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

clean_up: proc;

	if Ppaths ^= null then do;
	     do Idx = 1 to dim(pnotice_paths.templates, 1);
						/* terminate all templates first		*/
		call terminate_file_ (pnotice_paths.templates(Idx).Ptemplate,
		  pnotice_paths.templates(Idx).Ltemplate * 9, TERM_FILE_TERM, code);
		end;
	     call release_temp_segment_ (ME, Ppaths, code);
						/* now release temp seg			*/
	     end;

	if Ppsp_info ^= null then
	     call release_temp_segment_ (ME, Ppsp_info, code);

	if Fspec then do;
	     if Fmust_reset_source then
		call check_acl$reset_acl (Ps_archive, sdir, sentry, "1"b, user_on_source_acl);
	     if Fmust_reset_object then
		call check_acl$reset_acl (Po_archive, odir, oentry, "0"b, user_on_object_acl);
	     end;
	if Ps_archive ^= null then
	     call terminate_file_ (Ps_archive, sbit_count, TERM_FILE_TERM, code);
	if Po_archive ^= null then
	     call terminate_file_ (Po_archive, obit_count, TERM_FILE_TERM, code);
	end clean_up;
%page;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


init:	proc;

	Fmust_reset_source, Fmust_reset_object = False;
	Idx = 0;
	Idx2 = 0;
	Idx3 = 0;
	Isnotice = 0;
	Ionotice = 0;
	Ps_archive = null;
	Po_archive = null;
	Ppaths = null;
	Ptemp = null;
	P_line = null;
	Ppsp_info = null;
	Pnotices = null;
	Ltotal = 0;
	pn = "";
	source_pnotices = 0;
	object_pnotices = 0;
	prod_source_pnotice(*) = "";
	prod_object_pnotice(*) = "";
	unspec (ACI) = unspec (ACIS);
	match_found = False;
	Fany = False;
	Fname = False;
	Fsti = False;
	Fspec = False;
	Fmid = False;
	case = 0;
       
          current_year_a = date_time_$format("^9999yc",clock(),"","");
	end init;

%page;
	

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

make_PNOTICE:
	proc (CASE);



	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* This internal procedure creates the ALM source macro and the corresponding object	*/
	/* segment for inclusion into the proper source and object archives as shown in		*/
	/* psp_info_. There are four cases depicted in this procedure. They are:		*/
	/*									*/
	/* 1) Both source and object are protected by single pnotices, and so only one PNOTICE	*/
	/* source segment needs to be created and compiled.				*/
	/*									*/
	/* 2) Source and object are protected by more than one pnotice (i.e. multiple		*/
	/* copyrights), but these are the same ones. So, again only one PNOTICE source is	*/
	/* required.								*/
	/*									*/
	/* 3) Source and object are protected by only one pnotice each, but these pnotices are	*/
	/* different (i.e. source ->Trade Secret and object -> Copyright). This requires that	*/
	/* two PNOTICE source segments be created, since the notices in each are different. In	*/
	/* this case, the PNOTICE source destined for the object archive is created first,	*/
	/* compiled, and then the source is deleted. Then, the PNOTICE source destined for the	*/
	/* source archive is created, but not compiled.					*/
	/*									*/
	/* 4) Source and object are protected by multiple pnotices, and these are not identical.	*/
	/* So, again multiple PNOTICE segments must be created as outlined above in (3).	*/
	/*									*/
	/* A second temporary segment has been set up to hold the pnotice			*/
	/* with the current date inputted in place of the <yr> deliminator.			*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	

dcl CASE			          fixed bin;
	

	goto PNOTICE (CASE);

PNOTICE(1):					/* one PNOTICE source req'd and not 		*/
						/* multiple notices				*/

	Piocb = null;
	call iox_$attach_ioname (ME, Piocb, "vfile_ " 
	     || rtrim(working_dir) || ">" || "PNOTICE_" 
	     || rtrim(prod) || ".alm", code);
	if code ^= 0 then do;
	     call com_err_ (code, ME, "^/Attaching PNOTICE segment.");
	     return;
	     end;
	call iox_$open (Piocb, 2, "0"b, code);
	if code ^= 0 then do;
	     call com_err_ (code, ME, "^/Opening PNOTICE seg switch for output.");
	     return;
	     end;
	call ioa_ ("Creating ^a>PNOTICE_^a.alm.", rtrim(working_dir), prod);
	call ioa_$ioa_switch (Piocb, "^-dec^-1^3-""version 1 structure");
	call ioa_$ioa_switch (Piocb, "^-dec^-^d^3-""no. of pnotices", source_pnotices);
	call ioa_$ioa_switch (Piocb, "^-dec^-3^3-""no. of STIs");
						/* this may change eventually			*/
	if substr (prod_source_pnotice(1), 1, 8) = "default." then
						/* if it is a default copyright...		*/
	     do Idx2 = 1 to pnotice_paths.Ntemplates;
	     if pnotice_paths.templates(Idx2).defaultC then do;
		Ltotal = Ltotal + pnotice_paths.templates(Idx2).Ltemplate - 1;
		Ltemp = pnotice_paths.templates(Idx2).Ltemplate - 1;
						/* leave the new line off			*/
		Ptemp = pnotice_paths.templates(Idx2).Ptemplate;
                    call get_year;                          /*put in current date			*/
		end;
	     end;
	else if substr (prod_source_pnotice(1), 1, 20) = "default_trade_secret" then
						/* if it is a default TS pnotice...		*/
	     do Idx2 = 1 to pnotice_paths.Ntemplates;
	     if pnotice_paths.templates(Idx2).defaultTS then do;
		Ltotal = Ltotal + pnotice_paths.templates(Idx2).Ltemplate - 1;
		Ltemp = pnotice_paths.templates(Idx2).Ltemplate - 1;
						/* leave the new line off			*/
		Ptemp = pnotice_paths.templates(Idx2).Ptemplate;
		pn = pn || "          acc       " || """" || temp || """" || NL;
		end;
	     end;
						/* otherwise, look for a matching pnotice...	*/
	else do Idx2 = 1 to pnotice_paths.Ntemplates;
	     if pnotice_paths.templates(Idx2).primary_name = prod_source_pnotice(1) then do;
		Ltotal = Ltotal + pnotice_paths.templates(Idx2).Ltemplate - 1;
						/* leave the new line off the lgth		*/
		Ltemp = pnotice_paths.templates(Idx2).Ltemplate - 1;
		Ptemp = pnotice_paths.templates(Idx2).Ptemplate;
                    call get_year;                          /*put in current date			*/
		end;
	     end;
	call ioa_$ioa_switch (Piocb, "^-dec^-^d^3-""lgth of all pnotices + no. of pnotices", Ltotal + source_pnotices);
	call ioa_$ioa_switch (Piocb, "^a", pn);		/* insert all pnotices			*/
	call ioa_$ioa_switch (Piocb, "^-aci^-""^a""", prod_sti);
						/* STI for source code			*/
	call ioa_$ioa_switch (Piocb, "^-aci^-""^a""", substr(prod_sti, 1, 1) || "2" || substr(prod_sti, 3));
						/* STI for object code			*/
	call ioa_$ioa_switch (Piocb, "^-aci^-""^a""", substr(prod_sti, 1, 1) || "3" || substr(prod_sti, 3));
						/* STI for executable code			*/
	call ioa_$ioa_switch (Piocb, "^-end");
	call iox_$close (Piocb, code);
	if code ^= 0 then
	     call com_err_ (code, ME, "Closing PNOTICE switch.");
	call iox_$detach_iocb (Piocb, code);
	if code ^= 0 then
	     call com_err_ (code, ME, "Detaching PNOTICE switch.");
						/* finished with source segment now		*/
	

	call ioa_ ("Creating ^a>PNOTICE_^a.", rtrim(working_dir), prod);
	call alm (rtrim(working_dir) || ">PNOTICE_" || prod);
	return;

PNOTICE(2):					/* one PNOTICE source, multiple pnotices	*/
	

	Piocb = null;
	working_dir = get_wdir_ ();
	call iox_$attach_ioname (ME, Piocb, "vfile_ " 
	     || rtrim(working_dir) || ">" || "PNOTICE_" 
	     || rtrim(prod) || ".alm", code);
	if code ^= 0 then do;
	     call com_err_ (code, ME, "^/Attaching PNOTICE segment.");
	     return;
	     end;
	call iox_$open (Piocb, 2, "0"b, code);
	if code ^= 0 then do;
	     call com_err_ (code, ME, "^/Opening PNOTICE seg switch for output.");
	     return;
	     end;
	call ioa_ ("Creating ^a>PNOTICE_^a.alm.", rtrim(working_dir), prod);
	call ioa_$ioa_switch (Piocb, "^-dec^-1^3-""version 1 structure");
	call ioa_$ioa_switch (Piocb, "^-dec^-^d^3-""no. of pnotices", source_pnotices);
	call ioa_$ioa_switch (Piocb, "^-dec^-3^3-""no. of STIs");
						/* this may change eventually			*/
	do Idx = 1 to source_pnotices;
						/* this time, there are multiple pnotices, so	*/
						/* they must all be processed.		*/
	     if substr (prod_source_pnotice(Idx), 1, 8) = "default." then
						/* if it is a default copyright...		*/
		do Idx2 = 1 to pnotice_paths.Ntemplates;
		if pnotice_paths.templates(Idx2).defaultC then do;
		     Ltotal = Ltotal + pnotice_paths.templates(Idx2).Ltemplate - 1;
		     Ltemp = pnotice_paths.templates(Idx2).Ltemplate - 1;
						/* leave the new line off			*/
		     Ptemp = pnotice_paths.templates(Idx2).Ptemplate;
                         call get_year;                     /*put in current date			*/
		     end;
		end;
	     else if substr (prod_source_pnotice(Idx), 1, 20) = "default_trade_secret" then
						/* if it is a default TS pnotice...		*/
		do Idx2 = 1 to pnotice_paths.Ntemplates;
		if pnotice_paths.templates(Idx2).defaultTS then do;
		     Ltotal = Ltotal + pnotice_paths.templates(Idx2).Ltemplate - 1;
		     Ltemp = pnotice_paths.templates(Idx2).Ltemplate - 1;
						/* leave the new line off			*/
		     Ptemp = pnotice_paths.templates(Idx2).Ptemplate;
		     pn = pn || "          acc       " || """" || temp || """" || NL;
						/* add it to the list of pnotices.		*/
		     end;
		end;
						/* otherwise, look for a matching pnotice...	*/
	     else do Idx2 = 1 to pnotice_paths.Ntemplates;
		if pnotice_paths.templates(Idx2).primary_name = prod_source_pnotice(Idx) then do;
		     Ltotal = Ltotal + pnotice_paths.templates(Idx2).Ltemplate - 1;
						/* leave the new line off the lgth		*/
		     Ltemp = pnotice_paths.templates(Idx2).Ltemplate - 1;
		     Ptemp = pnotice_paths.templates(Idx2).Ptemplate;
                         call get_year;                     /*put in current date			*/
		     

		     end;
		end;
	     end;
	call ioa_$ioa_switch (Piocb, "^-dec^-^d^3-""lgth of all pnotices + no. of pnotices", Ltotal + source_pnotices);
	call ioa_$ioa_switch (Piocb, "^a", pn);		/* insert all pnotices			*/
	call ioa_$ioa_switch (Piocb, "^-aci^-""^a""", prod_sti);
						/* STI for source code			*/
	call ioa_$ioa_switch (Piocb, "^-aci^-""^a""", substr(prod_sti, 1, 1) || "2" || substr(prod_sti, 3));
						/* STI for object code			*/
	call ioa_$ioa_switch (Piocb, "^-aci^-""^a""", substr(prod_sti, 1, 1) || "3" || substr(prod_sti, 3));
						/* STI for executable code			*/
	call ioa_$ioa_switch (Piocb, "^-end");
	call iox_$close (Piocb, code);
	if code ^= 0 then
	     call com_err_ (code, ME, "Closing PNOTICE switch.");
	call iox_$detach_iocb (Piocb, code);
	if code ^= 0 then
	     call com_err_ (code, ME, "Detaching PNOTICE switch.");
						/* finished with source segment now		*/
	

	call ioa_ ("Creating ^a>PNOTICE_^a.", rtrim(working_dir), prod);
	call alm (rtrim(working_dir) || ">PNOTICE_" || prod);
	return;

PNOTICE(3):					/* two PNOTICE source segs, single pnotices	*/
	

	Piocb = null;
	working_dir = get_wdir_ ();
	call iox_$attach_ioname (ME, Piocb, "vfile_ " 
	     || rtrim(working_dir) || ">" || "PNOTICE_" 
	     || rtrim(prod) || ".alm", code);
	if code ^= 0 then do;
	     call com_err_ (code, ME, "^/Attaching PNOTICE segment.");
	     return;
	     end;
	call iox_$open (Piocb, 2, "0"b, code);
	if code ^= 0 then do;
	     call com_err_ (code, ME, "^/Opening PNOTICE seg switch for output.");
	     return;
	     end;
						/* create the source PNOTICE for object 	*/
						/* archive first, compile it, and then delete it	*/
						/*  before going to work on the PNOTICE for the	*/
						/*  source archive.				*/
	call ioa_ ("Multiple PNOTICE segs required. Object will be done first.");
	call ioa_$ioa_switch (Piocb, "^-dec^-1^3-""version 1 structure");
	call ioa_$ioa_switch (Piocb, "^-dec^-^d^3-""no. of pnotices", object_pnotices);
	call ioa_$ioa_switch (Piocb, "^-dec^-3^3-""no. of STIs");
						/* this may change eventually			*/
	if substr (prod_object_pnotice(1), 1, 8) = "default." then
						/* if it is a default copyright...		*/
	     do Idx2 = 1 to pnotice_paths.Ntemplates;
	     if pnotice_paths.templates(Idx2).defaultC then do;
		Ltotal = Ltotal + pnotice_paths.templates(Idx2).Ltemplate - 1;
		Ltemp = pnotice_paths.templates(Idx2).Ltemplate - 1;
						/* leave the new line off			*/
		Ptemp = pnotice_paths.templates(Idx2).Ptemplate;
                    call get_year;                          /*put in current_date			*/
		end;
	     end;
	else if substr (prod_object_pnotice(1), 1, 20) = "default_trade_secret" then
						/* if it is a default TS pnotice...		*/
	     do Idx2 = 1 to pnotice_paths.Ntemplates;
	     if pnotice_paths.templates(Idx2).defaultTS then do;
		Ltotal = Ltotal + pnotice_paths.templates(Idx2).Ltemplate - 1;
		Ltemp = pnotice_paths.templates(Idx2).Ltemplate - 1;
						/* leave the new line off			*/
		Ptemp = pnotice_paths.templates(Idx2).Ptemplate;
		pn = pn || "          acc       " || """" || temp || """" || NL;
						/* add it to the list of pnotices.		*/
		end;
	     end;
						/* otherwise, look for a matching pnotice...	*/
	else do Idx2 = 1 to pnotice_paths.Ntemplates;
	     if pnotice_paths.templates(Idx2).primary_name = prod_object_pnotice(1) then do;
		Ltotal = Ltotal + pnotice_paths.templates(Idx2).Ltemplate - 1;
						/* leave the new line off the lgth		*/
		Ltemp = pnotice_paths.templates(Idx2).Ltemplate - 1;
		Ptemp = pnotice_paths.templates(Idx2).Ptemplate;
                    call get_year;                          /*put in current date			*/
		end;
	     end;
	call ioa_$ioa_switch (Piocb, "^-dec^-^d^3-""lgth of all pnotices + no. of pnotices", Ltotal + object_pnotices);
	call ioa_$ioa_switch (Piocb, "^a", pn);		/* insert all pnotices			*/
	call ioa_$ioa_switch (Piocb, "^-aci^-""^a""", prod_sti);
						/* STI for source code			*/
	call ioa_$ioa_switch (Piocb, "^-aci^-""^a""", substr(prod_sti, 1, 1) || "2" || substr(prod_sti, 3));
						/* STI for object code			*/
	call ioa_$ioa_switch (Piocb, "^-aci^-""^a""", substr(prod_sti, 1, 1) || "3" || substr(prod_sti, 3));
						/* STI for executable code			*/
	call ioa_$ioa_switch (Piocb, "^-end");
	call iox_$close (Piocb, code);
	if code ^= 0 then
	     call com_err_ (code, ME, "Closing PNOTICE switch.");
	call iox_$detach_iocb (Piocb, code);
	if code ^= 0 then
	     call com_err_ (code, ME, "Detaching PNOTICE switch.");
						/* finished with source segment now		*/
	

	call ioa_ ("Creating ^a>PNOTICE_^a.", rtrim(working_dir), prod);
	call alm (rtrim(working_dir) || ">PNOTICE_" || prod);
	call delete_$path (working_dir, "PNOTICE_" || rtrim(prod) || ".alm", "100100"b, ME, code);
	if code ^= 0 then
	     call com_err_ (code, ME, "Deleting PNOTICE source for the object archive.");
						/* now create PNOTICE for the source archive.	*/
	Piocb = null;
	Ltotal = 0;				/* don't use anything from the object PNOTICE.	*/
	pn = "";					/* ditto					*/
	call iox_$attach_ioname (ME, Piocb, "vfile_ " 
	     || rtrim(working_dir) || ">" || "PNOTICE_" 
	     || rtrim(prod) || ".alm", code);
	if code ^= 0 then do;
	     call com_err_ (code, ME, "^/Attaching PNOTICE segment.");
	     return;
	     end;
	call iox_$open (Piocb, 2, "0"b, code);
	if code ^= 0 then do;
	     call com_err_ (code, ME, "^/Opening PNOTICE seg switch for output.");
	     return;
	     end;
	call ioa_ ("Creating ^a>PNOTICE_^a.alm.", rtrim(working_dir), prod);
	call ioa_$ioa_switch (Piocb, "^-dec^-1^3-""version 1 structure");
	call ioa_$ioa_switch (Piocb, "^-dec^-^d^3-""no. of pnotices", source_pnotices);
	call ioa_$ioa_switch (Piocb, "^-dec^-3^3-""no. of STIs");
						/* this may change eventually			*/
	if substr (prod_source_pnotice(1), 1, 8) = "default." then
						/* if it is a default copyright...		*/
	     do Idx2 = 1 to pnotice_paths.Ntemplates;
	     if pnotice_paths.templates(Idx2).defaultC then do;
		Ltotal = Ltotal + pnotice_paths.templates(Idx2).Ltemplate - 1;
		Ltemp = pnotice_paths.templates(Idx2).Ltemplate - 1;
						/* leave the new line off			*/
		Ptemp = pnotice_paths.templates(Idx2).Ptemplate;
                    call get_year;                          /*put in current date			*/
		end;
	     end;
	else if substr (prod_source_pnotice(1), 1, 20) = "default_trade_secret" then
						/* if it is a default TS pnotice...		*/
	     do Idx2 = 1 to pnotice_paths.Ntemplates;
	     if pnotice_paths.templates(Idx2).defaultTS then do;
		Ltotal = Ltotal + pnotice_paths.templates(Idx2).Ltemplate - 1;
		Ltemp = pnotice_paths.templates(Idx2).Ltemplate - 1;
						/* leave the new line off			*/
		Ptemp = pnotice_paths.templates(Idx2).Ptemplate;
		pn = pn || "          acc       " || """" || temp || """" || NL;
						/* add it to the list of pnotices.		*/
		end;
	     end;
						/* otherwise, look for a matching pnotice...	*/
	else do Idx2 = 1 to pnotice_paths.Ntemplates;
	     if pnotice_paths.templates(Idx2).primary_name = prod_source_pnotice(1) then do;
		Ltotal = Ltotal + pnotice_paths.templates(Idx2).Ltemplate - 1;
						/* leave the new line off the lgth		*/
		Ltemp = pnotice_paths.templates(Idx2).Ltemplate - 1;
		Ptemp = pnotice_paths.templates(Idx2).Ptemplate;
                    call get_year;                          /*put in current date			*/
		end;
	     end;
	call ioa_$ioa_switch (Piocb, "^-dec^-^d^3-""lgth of all pnotices + no. of pnotices", Ltotal + source_pnotices);
	call ioa_$ioa_switch (Piocb, "^a", pn);		/* insert all pnotices			*/
	call ioa_$ioa_switch (Piocb, "^-aci^-""^a""", prod_sti);
						/* STI for source code			*/
	call ioa_$ioa_switch (Piocb, "^-aci^-""^a""", substr(prod_sti, 1, 1) || "2" || substr(prod_sti, 3));
						/* STI for object code			*/
	call ioa_$ioa_switch (Piocb, "^-aci^-""^a""", substr(prod_sti, 1, 1) || "3" || substr(prod_sti, 3));
						/* STI for executable code			*/
	call ioa_$ioa_switch (Piocb, "^-end");
	call iox_$close (Piocb, code);
	if code ^= 0 then
	     call com_err_ (code, ME, "Closing PNOTICE switch.");
	call iox_$detach_iocb (Piocb, code);
	if code ^= 0 then
	     call com_err_ (code, ME, "Detaching PNOTICE switch.");
						/* finished with source segment now		*/
	

	return;

PNOTICE(4):					/* two PNOTICE source segs, multiple pnotices	*/
	

	Piocb = null;
	working_dir = get_wdir_ ();
	call iox_$attach_ioname (ME, Piocb, "vfile_ " 
	     || rtrim(working_dir) || ">" || "PNOTICE_" 
	     || rtrim(prod) || ".alm", code);
	if code ^= 0 then do;
	     call com_err_ (code, ME, "^/Attaching PNOTICE segment.");
	     return;
	     end;
	call iox_$open (Piocb, 2, "0"b, code);
	if code ^= 0 then do;
	     call com_err_ (code, ME, "^/Opening PNOTICE seg switch for output.");
	     return;
	     end;
						/* create the source PNOTICE for object archive 	*/
						/* first, compile it, and then delete it before 	*/
						/* going to work on the PNOTICE for the source	*/
						/*  archive.				*/
	call ioa_ ("Multiple PNOTICE segs required. Object will be done first.");
	call ioa_$ioa_switch (Piocb, "^-dec^-1^3-""version 1 structure");
	call ioa_$ioa_switch (Piocb, "^-dec^-^d^3-""no. of pnotices", object_pnotices);
	call ioa_$ioa_switch (Piocb, "^-dec^-3^3-""no. of STIs");
						/* this may change eventually			*/
	do Idx = 1 to object_pnotices;
						/* this time, there are multiple pnotices, so	*/
						/* they must all be processed.		*/
	     if substr (prod_object_pnotice(Idx), 1, 8) = "default." then
						/* if it is a default copyright...		*/
		do Idx2 = 1 to pnotice_paths.Ntemplates;
		if pnotice_paths.templates(Idx2).defaultC then do;
		     Ltotal = Ltotal + pnotice_paths.templates(Idx2).Ltemplate - 1;
		     Ltemp = pnotice_paths.templates(Idx2).Ltemplate - 1;
						/* leave the new line off			*/
		     Ptemp = pnotice_paths.templates(Idx2).Ptemplate;
                         call get_year;                     /*put in current date			*/
		     end;
		end;
	     else if substr (prod_object_pnotice(Idx), 1, 20) = "default_trade_secret" then
						/* if it is a default TS pnotice...		*/
		do Idx2 = 1 to pnotice_paths.Ntemplates;
		if pnotice_paths.templates(Idx2).defaultTS then do;
		     Ltotal = Ltotal + pnotice_paths.templates(Idx2).Ltemplate - 1;
		     Ltemp = pnotice_paths.templates(Idx2).Ltemplate - 1;
						/* leave the new line off			*/
		     Ptemp = pnotice_paths.templates(Idx2).Ptemplate;
		     pn = pn || "          acc       " || """" || temp || """" || NL;
						/* add it to the list of pnotices.		*/
		     end;
		end;
						/* otherwise, look for a matching pnotice...	*/
	     else do Idx2 = 1 to pnotice_paths.Ntemplates;
		if pnotice_paths.templates(Idx2).primary_name = prod_object_pnotice(Idx) then do;
		     Ltotal = Ltotal + pnotice_paths.templates(Idx2).Ltemplate - 1;
						/* leave the new line off the lgth		*/
		     Ltemp = pnotice_paths.templates(Idx2).Ltemplate - 1;
		     Ptemp = pnotice_paths.templates(Idx2).Ptemplate;
                         call get_year;                     /*put in current date			*/
		     end;
		end;
	     end;
	call ioa_$ioa_switch (Piocb, "^-dec^-^d^3-""lgth of all pnotices + no. of pnotices", Ltotal + object_pnotices);
	call ioa_$ioa_switch (Piocb, "^a", pn);		/* insert all pnotices			*/
	call ioa_$ioa_switch (Piocb, "^-aci^-""^a""", prod_sti);
						/* STI for source code			*/
	call ioa_$ioa_switch (Piocb, "^-aci^-""^a""", substr(prod_sti, 1, 1) || "2" || substr(prod_sti, 3));
						/* STI for object code			*/
	call ioa_$ioa_switch (Piocb, "^-aci^-""^a""", substr(prod_sti, 1, 1) || "3" || substr(prod_sti, 3));
						/* STI for executable code			*/
	call ioa_$ioa_switch (Piocb, "^-end");
	call iox_$close (Piocb, code);
	if code ^= 0 then
	     call com_err_ (code, ME, "Closing PNOTICE switch.");
	call iox_$detach_iocb (Piocb, code);
	if code ^= 0 then
	     call com_err_ (code, ME, "Detaching PNOTICE switch.");
						/* finished with source segment now		*/
	

	call ioa_ ("Creating ^a>PNOTICE_^a.", rtrim(working_dir), prod);
	call alm (rtrim(working_dir) || ">PNOTICE_" || prod);

	call delete_$path (working_dir, "PNOTICE_" || rtrim(prod) || ".alm", "100100"b, ME, code);
	if code ^= 0 then
	     call com_err_ (code, ME, "Deleting PNOTICE source for the object archive.");
						/* now create PNOTICE for the source archive.	*/
	Piocb = null;
	Ltotal = 0;				/* don't use anything from the object PNOTICE.	*/
	pn = "";					/* ditto					*/
	call iox_$attach_ioname (ME, Piocb, "vfile_ " 
	     || rtrim(working_dir) || ">" || "PNOTICE_" 
	     || rtrim(prod) || ".alm", code);
	if code ^= 0 then do;
	     call com_err_ (code, ME, "^/Attaching PNOTICE segment.");
	     return;
	     end;
	call iox_$open (Piocb, 2, "0"b, code);
	if code ^= 0 then do;
	     call com_err_ (code, ME, "^/Opening PNOTICE seg switch for output.");
	     return;
	     end;
	call ioa_ ("Creating ^a>PNOTICE_^a.alm.", rtrim(working_dir), prod);
	call ioa_$ioa_switch (Piocb, "^-dec^-1^3-""version 1 structure");
	call ioa_$ioa_switch (Piocb, "^-dec^-^d^3-""no. of pnotices", source_pnotices);
	call ioa_$ioa_switch (Piocb, "^-dec^-3^3-""no. of STIs");
						/* this may change eventually			*/
	do Idx = 1 to source_pnotices;		/* there may also be multiple pnotices here.	*/
	     if substr (prod_source_pnotice(Idx), 1, 8) = "default." then
						/* if it is a default copyright...		*/
		do Idx2 = 1 to pnotice_paths.Ntemplates;
		if pnotice_paths.templates(Idx2).defaultC then do;
		     Ltotal = Ltotal + pnotice_paths.templates(Idx2).Ltemplate - 1;
		     Ltemp = pnotice_paths.templates(Idx2).Ltemplate - 1;
						/* leave the new line off			*/
		     Ptemp = pnotice_paths.templates(Idx2).Ptemplate;
                         call get_year;                     /*put in current date			*/
		     end;
		end;
	     else if substr (prod_source_pnotice(Idx), 1, 20) = "default_trade_secret" then
						/* if it is a default TS pnotice...		*/
		do Idx2 = 1 to pnotice_paths.Ntemplates;
		if pnotice_paths.templates(Idx2).defaultTS then do;
		     Ltotal = Ltotal + pnotice_paths.templates(Idx2).Ltemplate - 1;
		     Ltemp = pnotice_paths.templates(Idx2).Ltemplate - 1;
						/* leave the new line off			*/
		     Ptemp = pnotice_paths.templates(Idx2).Ptemplate;
		     pn = pn || "          acc       " || """" || temp || """" || NL;
						/* add it to the list of pnotices.		*/
		     end;
		end;
						/* otherwise, look for a matching pnotice...	*/
	     else do Idx2 = 1 to pnotice_paths.Ntemplates;
		if pnotice_paths.templates(Idx2).primary_name = prod_source_pnotice(Idx) then do;
		     Ltotal = Ltotal + pnotice_paths.templates(Idx2).Ltemplate - 1;
						/* leave the new line off the lgth		*/
		     Ltemp = pnotice_paths.templates(Idx2).Ltemplate - 1;
		     Ptemp = pnotice_paths.templates(Idx2).Ptemplate;
                         call get_year;                     /*put in current date			*/
		     end;
		end;
	     end;
	call ioa_$ioa_switch (Piocb, "^-dec^-^d^3-""lgth of all pnotices + no. of pnotices", Ltotal + source_pnotices);
	call ioa_$ioa_switch (Piocb, "^a", pn);		/* insert all pnotices			*/
	call ioa_$ioa_switch (Piocb, "^-aci^-""^a""", prod_sti);
						/* STI for source code			*/
	call ioa_$ioa_switch (Piocb, "^-aci^-""^a""", substr(prod_sti, 1, 1) || "2" || substr(prod_sti, 3));
						/* STI for object code			*/
	call ioa_$ioa_switch (Piocb, "^-aci^-""^a""", substr(prod_sti, 1, 1) || "3" || substr(prod_sti, 3));
						/* STI for executable code			*/
	call ioa_$ioa_switch (Piocb, "^-end");
	call iox_$close (Piocb, code);
	if code ^= 0 then
	     call com_err_ (code, ME, "Closing PNOTICE switch.");
	call iox_$detach_iocb (Piocb, code);
	if code ^= 0 then
	     call com_err_ (code, ME, "Detaching PNOTICE switch.");
						/* finished with source segment now		*/
	

	return;


get_year: 
  proc;

  dcl temp2                    char(Ltemp);
  
  Iyr = index(Ptemp->temp,"<yr>");
  if Iyr = 0 then
    pn = pn || "          acc       " || """" || temp || """" || NL;
  else do;
    temp2 = Ptemp->temp;
    substr(temp2,Iyr,4) = current_year_a;
    pn = pn || "          acc       " || """" || temp2 || """" || NL;
    end;
 return;
 end get_year;


end make_PNOTICE;
%page;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

archive_PNOTICE:
	proc (source_dir, object_dir);


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* This internal procedure provides the capability for appending or replacing the	*/
	/* PNOTICE segments in both source and object archives. In order to do so, the archive	*/
	/* command itself is called....which may be questionable....but it was in the specs, so	*/
	/* it was done.								*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

dcl source_dir	        char(*),
    object_dir	        char(*);
	

S_ARCHIVE:
	component_name = "PNOTICE_" || rtrim(prod) || ".alm";
	if Fspec then do;				/* if "-special" has been used		*/
	     this_is_source_archive = True;
	     call check_acl (Ps_archive, sdir, sentry, Fmust_reset_source);
	     goto S_INFO;				/* archive is already known			*/
	     end;
	call hcs_$initiate_count (source_dir, prod_source_ename, "", sbit_count, 0, Ps_archive, code);
	if Ps_archive = null then do;
	     call com_err_ (code, ME, "Initiating source archive - Procedure terminated.");
	     return;
	     end;
S_INFO:	call archive_$get_component_info (Ps_archive, sbit_count, component_name, addr(ACI), code);
	if code = error_table_$no_component then
	     goto NO_S_COMPONENT;
	else if code ^= 0 then do;
	     call com_err_ (code, ME, "^/Getting source archive component info, PNOTICE not appended.");
	     return;
	     end;
	else do;
	     call ioa_ ("Replacing ^a in ^a in ^a.", component_name, prod_source_ename, source_dir);
	     call archive ("rd", rtrim(source_dir) || ">" || rtrim(prod_source_ename),
	       rtrim(working_dir) || ">" || rtrim(component_name));
						/* Replace and Delete			*/
	     goto O_ARCHIVE;
	     end;
	
NO_S_COMPONENT:
	call ioa_ ("Appending ^a to ^a in ^a.", component_name, prod_source_ename, source_dir);
	call archive ("ad", rtrim(source_dir) || ">" || rtrim(prod_source_ename),
	  rtrim(working_dir) || ">" || rtrim(component_name));
						/* Append and Delete			*/
	

O_ARCHIVE:
	component_name = rtrim("PNOTICE_" || rtrim(prod));
	if Fspec then do;
	     this_is_object_archive = True;
	     call check_acl (Po_archive, odir, oentry, Fmust_reset_object);
	     goto O_INFO;
	     end;
	call hcs_$initiate_count (object_dir, prod_object_ename, "", obit_count, 0, Po_archive, code);
	if Po_archive = null then do;
	     call com_err_ (code, ME, "Initiating object archive - Procedure terminated.");
	     return;
	     end;
O_INFO:	call archive_$get_component_info (Po_archive, obit_count, component_name, addr(ACI), code);
	if code = error_table_$no_component then
	     goto NO_O_COMPONENT;
	else if code ^= 0 then do;
	     call com_err_ (code, ME, "^/Getting object archive component info, PNOTICE not appended.");
	     return;
	     end;
	else do;
	     call ioa_ ("Replacing ^a in ^a in ^a.", component_name, prod_object_ename, object_dir);
	     call archive ("rd", rtrim(object_dir) || ">" || rtrim(prod_object_ename),
	       rtrim(working_dir) || ">" || rtrim(component_name));
						/* Replace and Delete			*/
	     goto END_ARCHIVE;
	     end;
NO_O_COMPONENT:
	call ioa_ ("Appending ^a to ^a in ^a.", component_name, prod_object_ename, object_dir);
	call archive ("ad", rtrim(object_dir) || ">" || rtrim(prod_object_ename),
	  rtrim(working_dir) || ">" || rtrim(component_name));
						/* Append and Delete			*/
	

END_ARCHIVE:
	return;
	end archive_PNOTICE;
%page;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

check_acl:
	proc (Aptr, Adir, Aentry, Areset_acl);

	
dcl Aptr	              ptr,  			/* IN					*/
    Adir	              char(*),			/* IN					*/
    Aentry              char(*),			/* IN					*/
    Atype               bit(1),			/* IN, True = source and False = object		*/
    Areset_acl          bit(1);			/* OUT					*/
dcl Acode	              fixed bin (35),
    original_source_mode     bit(36) aligned,
    original_object_mode     bit(36) aligned;

dcl 1 acle(1),					/* structure for the list_acl and		*/
						/* add_acl_entries calls			*/
      2 name		 char(32) aligned,
      2 mode		 bit(36) aligned,
      2 mbz		 bit(36) aligned,
      2 code		 fixed bin (35);

dcl 1 del_acl(1),					/* structure for the delete_acl_entries call	*/
      2 name		 char(32) aligned,
      2 code		 fixed bin (35);

dcl one_word			char(4) based,
    error_table_$user_not_found	fixed bin(35) ext static;

	on no_write_permission goto FORCE_ACL;
	Aptr -> one_word = Aptr -> one_word;		/* try to write the first word of the seg.	*/
	return;					/* no need to go further if it worked.		*/
	

FORCE_ACL:
	acle(1).name = get_group_id_ ();
	acle(1).mode = "0"b;
	acle(1).mbz = "0"b;
	acle(1).code = 0;
	call hcs_$list_acl (Adir, Aentry, null, null, addr(acle), 1, Acode);
	if acle(1).code ^= 0 then
	     if acle(1).code = error_table_$user_not_found then do;
						/* this user not in ACL			*/
		if this_is_source_archive then
		     user_on_source_acl = False;
		if this_is_object_archive then
		     user_on_object_acl = False;
		end;
	     else
		goto ERROR;
	else do;
	     if Acode ^= 0 then do;
		acle(1).code = Acode;
		goto ERROR;
		end;
	     if this_is_source_archive then do;
		user_on_source_acl = True;
		original_source_mode = acle(1).mode;	/* save current mode for restoring		*/
		end;
	     if this_is_object_archive then do;
		user_on_object_acl = True;
		original_object_mode = acle(1).mode;
		end;
	     end;
	acle(1).mode = "101"b;			/* we need rw access			*/
	acle(1).mbz = "0"b;
	acle(1).code = 0;
	call hcs_$add_acl_entries (Adir, Aentry, addr(acle), 1, Acode);
	if Acode ^= 0 then do;
	     call com_err_ (Acode, ME, "
Unable to force write access for ^a to ^a>^a.", acle(1).name, Adir, Aentry);
	     goto CLEAN;
	     end;
	Areset_acl = True;				/* some resetting will be required		*/
	return;
ERROR:	call com_err_ (acle(1).code, ME, "
When listing ^a's access to ^a>^a", acle(1).name, Adir, Aentry);
	goto CLEAN;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


check_acl$reset_acl:
	entry (Aptr, Adir, Aentry, Atype, Areset_acl);

	acle(1).name = get_group_id_ ();		/* this proc has its own stack frame, so don't	*/
						/* rely on earlier name being there...		*/
	if Areset_acl then do;			/* we must restore old mode			*/
	     if Atype = True then
		acle(1).mode = original_source_mode;
	     else
		acle(1).mode = original_object_mode;
	     acle(1).mbz = "0"b;
	     acle(1).code = 0;
	     call hcs_$add_acl_entries (Adir, Aentry, addr(acle), 1, Acode);
	     if acle(1).code ^= 0 then do;
		call com_err_ (Acode, ME, "
Restoring access for ^a to ^a>^a.", acle(1).name, Adir, Aentry);
		return;
		end;
	     end;
	else do;
	     del_acl(1).name = acle(1).name;
	     del_acl(1).code = 0;
	     call hcs_$delete_acl_entries (Adir, Aentry, addr(del_acl), 1, Acode);
	     if Acode ^= 0 then
		call com_err_ (Acode, ME, "
Removing access for ^a to ^a>^a.", del_acl(1).name, Adir, Aentry);
	     return;
	     end;
	return;

	end check_acl;

%page;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


check_multiple_pnotices:
	proc returns (bit (1));

dcl Idx1	           fixed bin,
    Idx2	           fixed bin,
    value	           bit (1),
    TS	           bit (1),
    CP	           bit (1);

	value = True;				/* assume things are OK			*/
	TS = False;
	CP = False;
	do Idx = 1 to source_pnotices;
	     if after(prod_source_pnotice(Idx), ".") = "trade_secret.pnotice" then
		TS = True;
	     else
		CP = True;
	     do Idx1 = 1 to source_pnotices;
		do Idx2 = Idx1 + 1 to source_pnotices;
		     if prod_source_pnotice(Idx1) = prod_source_pnotice(Idx2) then
			call ioa_ ("Error in psp_info_ for ^a: Duplicate source notices.", prod);
		     end;
		end;
	     end;
	if CP & TS then do;
	     call ioa_ ("Error in psp_info_ for ^a: mixed copyright and Trade Secret for source.", prod);
	     value = False;
	     end;
						/* now check object too			*/
	TS = False;
	CP = False;
	do Idx = 1 to object_pnotices;
	     if after(prod_object_pnotice(Idx), ".") = "trade_secret.pnotice" then
		TS = True;
	     else
		CP = True;
	     do Idx1 = 1 to object_pnotices;
		do Idx2 = Idx1 + 1 to object_pnotices;
		     if prod_object_pnotice(Idx1) = prod_object_pnotice(Idx2) then
			call ioa_ ("Error in psp_info_ for ^a: duplicate object notices.", prod);
		     end;
		end;
	     end;
	if CP & TS then do;
	     call ioa_ ("Error in psp_info_ for ^a: mixed copyright and Trade Secret for object.", prod);
	     value = False;
	     end;
	

	return (value);
	end check_multiple_pnotices;
%page;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


get_PNOTICE_info:
	proc;


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* This internal procedure is used only when the "-special" control argument has been	*/
	/* specified. A user of this command must have good reason to use this argument because	*/
	/* it basically over-rides psp_info_, and in most cases, ignores it. The presumed major	*/
	/* use of this functionality would be to create PNOTICEs for pre-release software or	*/
	/* RPQ'd software. It is presumed that the user has proper legal and other documentation	*/
	/* necessary to correctly protect and identify the software in question.		*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	
dcl product_known	     bit(1),
    prodno	     fixed bin;
	

	call ioa_ ("Type ""?"" for more info on any question.");
	call ioa_ ("Type ""exit"" at any time to exit prematurely.");
ASK_PROD: call command_query_ (addr(query_info), answer, ME, "-> Generic name? ");
	if answer = "exit" then
	     goto CLEAN;
	if answer = "?" then do;
	     call ioa_ ("Generic name (<= 20 chars).
	     ^/A descriptive short name for the software module(s) to be protected.");
	     goto ASK_PROD;
	     end;
	else do;
	     call check_entryname_ ("PNOTICE_" || answer || ".alm", code);
						/* check the source form of the name		*/
	     if code ^= 0 then do;			/* if its bad, complain			*/
		call com_err_ (code, ME, "
Your answer would form an illegal name:^/PNOTICE_^a.alm", answer);
		goto ASK_PROD;
		end;
	     else
		prod = answer;			/* else accept it				*/
	     end;
	do prodno = 1 to product.prod_number while (prod ^= product.num(prodno).prod_name);
						/* find out if it is a known product		*/
	     end;
	if prodno > product.prod_number then
	     product_known = False;			/* it is not known				*/
	else product_known = True;			/* it IS known				*/
	if product_known & product.num(prodno).prod_use(1) ^= "" then do;
	     call ioa_ ("Multiple products found in psp_info_.
                ^/Please use this command for each product.");
						/* This msg is produced if the user tries this	*/
						/* command and finds only a "Use: " statement	*/
	     

	     goto CLEAN;
	     end;
	if product_known then
	     call ioa_ ("^a is in psp_info_, type ""pr"" to see the STI, else input new STI.", prod);
ASK_STI:	call command_query_ (addr(query_info), answer, ME, "-> STI? ");
	if answer = "exit" then
	     goto CLEAN;
	if answer = "?" then do;
	     call ioa_ ("STI (12 chars).
Software Technical ID. May be blank for non-product software.
Type CR for blank STI.^/Type ""..help sti.gi"" for more information.");
	     goto ASK_STI;
	     end;
	else if answer = "pr" then do;
	     if product_known then
		call ioa_ ("STI for ^a:^-^a", prod, product.num(prodno).prod_STI);
	     else
		call ioa_ ("^a is not in psp_info_, there is no STI.", prod);
	     goto ASK_STI;
	     end;
	else if product_known then do;			/* there is such a product		*/
	     if answer = "" then do;
		call ioa_ ("Error - ^a is in psp_info_. You must supply an updated STI.", prod);
		call ioa_ ("Type ""pr"" to see STI, type ""..help sti.gi"" for more information.");
		goto ASK_STI;
		end;
	     else if length(answer) ^= 12 then do;
		call ioa_ ("Error - the STI must be 12 characters long.");
		goto ASK_STI;
		end;
	     prod_sti = answer;
	     if ^parse_pnotice_info_$validate_sti (prod_sti) then do;
		call ioa_ ("Error - invalid STI: ^a", prod_sti);
		goto ASK_STI;
		end;
	     end;
	else do;					/* there is no product in psp_info_		*/
	     if answer = "" then do;
		prod_sti = answer;			/* accept blank for non-products		*/
		goto ASK_PNOTICE;
		end;

	     else if length(answer) ^= 12 then do;
		call ioa_ ("Error - the STI must be 12 characters long.^/Type ""..help sti.gi"" for more information.");
		goto ASK_STI;
		end;
	     prod_sti = answer;
	     if ^parse_pnotice_info_$validate_sti (prod_sti) then do;
		call ioa_ ("Error - Invalid Software Technical Identifier.");
		goto ASK_STI;
		end;
	     end;
	answer = "";				/* avoid possible problems			*/
ASK_PNOTICE:
	if product_known then do;			/* if there is already a product, ask if they	*/
						/* should be included or not.			*/
	     call ioa_ ("^a is in psp_info_.^/Type ""ls"" for list of notice names in psp_info_ for ^a.", prod, prod);
	     call ioa_ ("Type ""lpn"" to see all available notice names.
Type ""yes"" to include notices already in psp_info_, or ""no"" to input your own notices.");
ASK1:	     call command_query_ (addr(query_info), answer, ME,
	        "Include the notices from psp_info_? Type ""yes"" or ""no"".");
	     if answer = "exit" then			/* just want out				*/
		goto CLEAN;
	     if answer = "yes" then do;		/* get names from psp_info_			*/
                    Idx = 0;                                /*Initialize index to 0			*/
		do Idx3 = 1 to hbound (product.num.source_C, 2);
		     if product.num(prodno).source_C(Idx3) = "" then;
		     else do;
			prod_source_pnotice(Idx3) = product.num(prodno).source_C(Idx3);
                              Idx1 = check_name(prod_source_pnotice(Idx3));
                              if Idx1 > pnotice_paths.Ntemplates then do;
                                code = error_table_$name_not_found;
                                call com_err_ (code, ME, "^/Invalid psp_info_ name - ^a.", prod_source_pnotice(Idx3));
                                goto CLEAN;
                                end;
                              Idx = Idx + 1;
                              if Idx > 1 then
                                if ^templates_compatible(prod_source_pnotice) 
                                  then do; 
                                    call com_err_ (code, ME, "^a - ^/pnotice types not compatible", prod);
                                    goto CLEAN;
                                    end;
			source_pnotices = source_pnotices + 1;
			end;
		     end;
                    Idx = 0;                                /* Initialize index to 0			*/
		do Idx3 = 1 to hbound (product.num.object_C, 2);
		     if product.num(prodno).object_C(Idx3) = "" then;
		     else do;
			prod_object_pnotice(Idx3) = product.num(prodno).object_C(Idx3);
                              Idx1 = check_name(prod_object_pnotice(Idx3));
                              if Idx1 > pnotice_paths.Ntemplates then do;
                                code = error_table_$name_not_found;
                                call com_err_ (code, ME, "^/Invalid psp_info_ name - ^a.", prod_object_pnotice(Idx3));
                                goto CLEAN;
                                end;
                              Idx = Idx + 1;
                              if Idx > 1  then
                                if ^templates_compatible(prod_object_pnotice)
                                  then do; 
                                    call com_err_ (code, ME, "^a - ^/pnotice types not compatible", prod);
                                    goto CLEAN;
                                    end;
			object_pnotices = object_pnotices + 1;
			end;
		     end;
		goto GOT_PSP;			/* got'em					*/
		end;

	     else if answer = "lpn" then do;
						/* tell me what's available			*/
		call list_pnotice_names ();
		goto ASK1;
		end;
	     else if answer = "ls" then do;		/* tell me what's in psp_info_		*/
		call ioa_ ("Source notices in psp_info_ for ^a:", prod);
		do Idx = 1 to hbound(product.num.source_C, 2) while (product.num(prodno).source_C(Idx) ^= "");
		     call ioa_ ("^3x^a", product.num(prodno).source_C(Idx));
		     end;
		call ioa_ ("Object notices in psp_info_ for ^a:", prod);
		do Idx = 1 to hbound(product.num.object_C, 2) while (product.num(prodno).object_C(Idx) ^= "");
		     call ioa_ ("^3x^a", product.num(prodno).object_C(Idx));
		     end;
		goto ASK1;
		end;
	     else if answer = "no" then do;
		source_pnotices = 0;
		object_pnotices = 0;
		goto START_PN;
		end;
	     else do;
		call ioa_ ("Unrecognized answer - ^a", answer);
		goto ASK_PNOTICE;
		end;
GOT_PSP:	     call ioa_ ("Notices from psp_info_ have been included.");
	     call command_query_ (addr(query_info), answer, ME, "->Do you wish to input more? Type ""yes"" or ""no"":");
	     if answer = "exit" then
		goto CLEAN;
	     if answer = "yes" then do;
START_PN:		call ioa_ ("Input source pnotice names, type ""q"" when done.");
		Idx = 0;
GET_PN:		do Idx3 = source_pnotices to hbound(prod_source_pnotice, 1);
ASK_SNAME:	     call command_query_ (addr(query_info), answer, ME, "-> Source pnotice name? ");
		     if answer = "exit" then
			goto CLEAN;
		     else if answer = "q" then do;
			if source_pnotices = 0 then do;
			     call ioa_ ("There must be at least one source notice.");
			     goto ASK_SNAME;
			     end;
			else
			     goto BEGIN_ONAME;
			end;
		     else if answer = "?" then do;
			call ioa_ ("Source pnotice name (<= 24 chars).
^/Primary name of a pnotice template, without the "".pnotice"" suffix.");
			goto ASK_SNAME;
			end;
		     else if answer = "lpn" then do;
			call list_pnotice_names ();
			goto ASK_SNAME;
			end;
		     else if index (answer, "pnotice") ^= 0 then do;
			call ioa_ ("Error - Type template primary name, without the ""pnotice"" suffix.");
			goto ASK_SNAME;
			end;
		     else do;
                              Idx2 = check_name(answer);
			if Idx2 > pnotice_paths.Ntemplates then do;
			     code = error_table_$name_not_found;
			     call com_err_ (code, ME, "^/The template was not found - ^a.", answer);
			     call ioa_ ("Type ""lpn"" for template names.");
			     goto ASK_SNAME;
			     end;
			Idx = Idx + 1;
			prod_source_pnotice(Isnotice + Idx) = 
                                templates(Idx2).primary_name;
						/* add this one to the list			*/
                              if Idx > 1 then
                                if ^templates_compatible(prod_source_pnotice)
                                  then do;
                                    call com_err_ (code, ME, "^a - ^/pnotice types not compatible", prod);
                                    goto ASK_SNAME;
                                    end;
			end;
		     source_pnotices = Idx;
		     end;
BEGIN_ONAME:	call ioa_ ("Input object pnotice names, type ""q"" when done.");
		Idx = 0;
		do Idx3 = object_pnotices to hbound(prod_object_pnotice, 1);
ASK_ONAME:	     call command_query_ (addr(query_info), answer, ME, "-> Object pnotice name? ");
		     if answer = "exit" then
			goto CLEAN;
		     if answer = "q" then do;
			if object_pnotices = 0 then do;
			     call ioa_ ("There must be at least one object notice.");
			     goto ASK_ONAME;
			     end;
			else
			     goto ASK_SARCHIVE;
			end;
		     else if answer = "?" then do;
			call ioa_ ("Object pnotice name (<= 24 chars).
			^/Primary name of a pnotice template, without the "".pnotice"" suffix.");
			goto ASK_ONAME;
			end;
		     else if answer = "lpn" then do;
			call list_pnotice_names ();
			goto ASK_ONAME;
			end;
		     else if index (answer, "pnotice") ^= 0 then do;
			call ioa_ ("Error - Type template primary name, without the ""pnotice"" suffix.");
			goto ASK_ONAME;
			end;
		     else do;
			Idx2 = check_name(answer);
			if Idx2 > pnotice_paths.Ntemplates then do;
			     code = error_table_$name_not_found;
			     call com_err_ (code, ME, "^/The template was not found - ^a.", answer);
			     call ioa_ ("^/Type ""lpn"" for template names.");
			     goto ASK_ONAME;
			     end;
			Idx = Idx + 1;
			prod_object_pnotice(Ionotice + Idx) = 
                                templates(Idx2).primary_name;
						/* add this one to the list			*/
                              if Idx > 1 then
                                if ^templates_compatible(prod_object_pnotice)
                                  then do;
                                    call com_err_ (code, ME, "^a - ^/pnotice types not compatible", prod);
                                    goto ASK_ONAME;
                                    end;			end;
		     object_pnotices = Idx;
		     end;
		end;
	     end;
	else do;					/* if there is no psp_info_ entry		*/
	     Idx = 0;
	     call ioa_ ("Input source pnotice names.
Type ""q"" when done.^/Type ""lpn"" to see all available notice names.");
	     do Idx3 = object_pnotices to hbound(prod_object_pnotice, 1);
ASK_SNAME_ALL:	call command_query_ (addr(query_info), answer, ME, "-> Source pnotice name? ");
		if answer = "exit" then
		     goto CLEAN;
		if answer = "?" then do;
		     call ioa_ ("Source pnotice name (<= 24 chars).
Primary name of a pnotice template, without the "".pnotice"" suffix.
Type ""lpn"" for available names. Type ""q"" when finished.");
		     goto ASK_SNAME_ALL;
		     end;
		else if answer = "lpn" then do;
		     call list_pnotice_names ();
		     goto ASK_SNAME_ALL;
		     end;
		else if index (answer, "pnotice") ^= 0 then do;
		     call ioa_ ("Error - Type template primary name, without the ""pnotice"" suffix.");
		     goto ASK_SNAME_ALL;
		     end;
		else if answer = "" then do;
		     call ioa_ ("Error - A pnotice primary name is required.");
		     goto ASK_SNAME_ALL;
		     end;
		else if answer = "q" & source_pnotices > 0 then
		     goto BEGIN_ONAME_ALL;
		else do;
		     Idx2 = check_name(answer);
		     if Idx2 > pnotice_paths.Ntemplates then do;
			code = error_table_$name_not_found;
			call com_err_ (code, ME, "^/The template was not found - ^a.", answer);
			call ioa_ ("Type ""lpn"" for available names.");
			goto ASK_SNAME_ALL;
			end;
		     Idx = Idx + 1;
		     prod_source_pnotice(Idx) = 
                           templates(Idx2).primary_name;
						/* add this one to the list			*/
                         if Idx > 1 then
                           if ^templates_compatible(prod_source_pnotice) then
                           goto ASK_SNAME_ALL;
		     end;
		source_pnotices = Idx;
		end;
BEGIN_ONAME_ALL:
	     Idx = 0;
	     call ioa_ ("Input object pnotice names. Type ""q"" when done.");
	     do Idx3 = object_pnotices to hbound(prod_object_pnotice, 1);
ASK_ONAME_ALL:	call command_query_ (addr(query_info), answer, ME, "-> Object pnotice name? ");
		if answer = "exit" then
		     goto CLEAN;
		if answer = "?" then do;
		     call ioa_ ("Object pnotice name (<= 24 chars).
Primary name of a pnotice template, without the "".pnotice"" suffix. 
Type ""lpn"" for available names. Type ""q"" when finished.");
		     goto ASK_ONAME_ALL;
		     end;
		else if answer = "lpn" then do;
		     call list_pnotice_names ();
		     goto ASK_ONAME_ALL;
		     end;
		else if index (answer, "pnotice") ^= 0 then do;

		     call ioa_ ("Error - Type template primary name, without the ""pnotice"" suffix.");
		     goto ASK_ONAME_ALL;
		     end;
		else if answer = "" then do;
		     call ioa_ ("Error - A pnotice primary name is required.");
		     goto ASK_ONAME_ALL;
		     end;
		else if answer = "q" & object_pnotices > 0 then
		     goto ASK_SARCHIVE;
		else do;
		     Idx2 = check_name(answer);
		     if Idx2 > pnotice_paths.Ntemplates then do;
			code = error_table_$name_not_found;
			call com_err_ (code, ME, "^/The template was not found - ^a.", answer);
			call ioa_ ("^/Type ""lpn"" for available names.");
			goto ASK_ONAME_ALL;
			end;
		     Idx = Idx + 1;
		     prod_object_pnotice(Idx) = 
                           templates(Idx2).primary_name;
						/* add this one to the list			*/
                         if Idx > 1 then
                           if ^templates_compatible(prod_object_pnotice) then
                           goto ASK_ONAME_ALL;              /*templates in prod_object_pnotice not compatible */
						/* - reinput correctly			*/
		     end;
		object_pnotices = Idx;
		end;
	     end;
ASK_SARCHIVE:
	call command_query_ (addr(query_info), answer, ME, "-> Pathname of source archive? ");
	if answer = "exit" then
	     goto CLEAN;
	if answer = "?" then do;
	     call ioa_ ("Archive pathname of source archive.
^/Example: >exl>new_dir>source>bound_new_.s");
	     goto ASK_SARCHIVE;
	     end;
	if index(answer, ".archive") = 0 then
	     path = answer || ".archive";
	else
	     path = answer;
	call expand_pathname_ (path, sdir, sentry, code);
	if code ^= 0 then do;
	     call com_err_ (code, ME, "^a.", path);
	     goto CLEAN;
	     end;
	call hcs_$initiate_count (sdir, sentry, "", sbit_count, 0, Ps_archive, code);
	if Ps_archive = null then do;
	     if code = error_table_$noentry then do;
		call com_err_ (code, ME, "^a.", path);
		goto ASK_SARCHIVE;
		end;
	     else do;
		call com_err_ (code, ME, "^a. ^/Terminating this procedure.", path);
		goto CLEAN;
		end;
	     end;
	if ^Fspec then
	     call check_archive (sdir, sentry, Ps_archive);
	prod_source_ename = sentry;			/* save entry name				*/
	

ASK_OARCHIVE:
	call command_query_ (addr(query_info), answer, ME, "-> Pathname of object archive? ");
	if answer = "exit" then
	     goto CLEAN;
	if answer = "?" then do;
	     call ioa_ ("Archive pathname of object archive.
^/Example: >exl>new_dir>object>bound_new_");
	     goto ASK_OARCHIVE;
	     end;
	if index(answer, ".archive") = 0 then
	     path = answer || ".archive";
	else
	     path = answer;
	call expand_pathname_ (path, odir, oentry, code);
	if code ^= 0 then do;
	     call com_err_ (code, ME, "^a.", path);
	     goto CLEAN;
	     end;
	call hcs_$initiate_count (odir, oentry, "", obit_count, 0, Po_archive, code);
          if Po_archive = Ps_archive then do;               /*cannot use same archive for both source and 	*/
						/* object pnotices				*/
            call ioa_ ("The same archive may not be used for both source and object pnotices.");
            call com_err_ (code, ME, "^a. ^/Terminating this procedure.",path);
            goto CLEAN;
            end;
	if Po_archive = null then do;
	     if code = error_table_$noentry then do;
		call com_err_ (code, ME, "^a.", path);
		goto ASK_OARCHIVE;
		end;
	     else do;
		call com_err_ (code, ME, "^a. ^/Terminating this procedure.", path);
		goto CLEAN;
		end;
	     end;
	if ^Fspec then
	     call check_archive (odir, oentry, Po_archive);
	prod_object_ename = oentry;			/* save entry name				*/
	

 
              

	end get_PNOTICE_info;

%page;
check_template_name:
  proc;
check_name:
          entry(name_in) returns (fixed bin);

dcl name_in                    char(*) var,
    count_of		 fixed bin;
	
Fdcopy_right = False;
Fdtrade_secret = False;

if name_in = "-trade_secret" | name_in = "-dts" then
  Fdtrade_secret = True;

if name_in = "-default_copyright" | name_in = "-dc" then
  Fdcopy_right = True;

if Ftrade_secret then do count_of = 1 to pnotice_paths.Ntemplates while (^pnotice_paths.templates(count_of).defaultTS);
   end;

if Fdcopy_right then do count_of = 1 to pnotice_paths.Ntemplates while (^pnotice_paths.templates(count_of).defaultC);
  end;      

if ^Fdcopy_right & ^Fdtrade_secret then
  do count_of = 1 to pnotice_paths.Ntemplates while (name_in ^= templates(count_of).primary_name);
  end;

return(count_of);

end check_template_name;
%page;
templates_compatible:
  proc(name_in) returns(bit(1));
  
  dcl name_in (10)             char(32) varying,
      i			 fixed bin(24);
  
  Ftrade_secret = False;
  Fdtrade_secret = False;
  Fpublic_domain = False;
  Fcopy_right = False;
  Fdcopy_right = False;
  
  do i = 1 to Idx by 1;
     if name_in(i) = "-default_trade_secret" | name_in(i) = "-dts" then
       Fdtrade_secret = True;
     else
       if name_in(i) = "-default_copy_right" | name_in(i) = "-dc" then
          Fdcopy_right = True;
       else
          if name_in(i) = "public_domain" then
            Fpublic_domain = True;
          else
            if reverse(before(reverse(name_in(i)),".")) = "trade_secret" then
              Ftrade_secret = True;
	  else
              Fcopy_right = True;
  end;

  if (Fcopy_right | Fdcopy_right | Ftrade_secret| Fdtrade_secret) &
    Fpublic_domain then do;
    call ioa_ ("A public domain pnotice can only exist by itself");
    Idx = Idx - 1;
    return(False);
    end;
  if (Fcopy_right | Fdcopy_right | Fpublic_domain) & (Ftrade_secret |
    Fdtrade_secret) then do;
     call ioa_("Trade secret pnotices can only exist by themselves");
     return(False);
     end;
  
  return(True);
  
end templates_compatible;
%page;
%include archive_component_info;
%page;
%include pnotice_paths;
%page;
%include software_pnotice_info_;
%page;
%include terminate_file;

	end generate_pnotice;
