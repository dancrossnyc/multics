/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1992   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(86-04-23,Martinson), approve(86-04-23,MCR7363),
     audit(86-04-30,GDixon), install(86-05-01,MR12.0-1050):
     Fix transfer request to work again when changing requisition or account
     number.
  2) change(92-09-23,Zimmerman), approve(92-09-23,MCR8268), audit(92-10-13,Vu),
     install(92-10-21,MR12.5-1034):
     edit_proj changed to allow deletion of project alias from SAT (phx21304)
                                                   END HISTORY COMMENTS */


/* format: style2 */
edit_proj_:
     procedure (EPA_ptr);

/* Written by T. H. VanVleck in 1973
   Modified June 1975 by T. Casey to add groups
   Modified August 1977 by T. Casey to add min_ring and max_ring
   Modified May 1978 by T. Casey to add pdir_quota.
   Modified November 1978 by T. Casey for MR7.0 to add new absentee control parameters.
   Modified July 1979 by J. Bakal to implement the multiple rate structure feature.
   Modified November 1979 by T. Casey to implement -long and change the default to not -long.
   Modified Feb 1980 by M. B. Armstrong to make corrections re rate structures.
   Modified June 1980 by J. N. R. Barnecut to integrate multiple rate structure feature into MR8.0
   Modified April 1980 by J. N. R. Barnecut to allow reset when changing requistion number or account number.
   Modified 1984-07-05 BIM to clean up, ready for B2 new fields.
   Modified 1984-09-14 BIM for bugs in group handling.
   Modified 1984-10-24 by E. Swenson to allow attributes to be set properly.
   Modified 1984-12-14 by EJ Sharpe for new audit flags
   Modified 1985-04-19 by EJ Sharpe to fix checking to always return, report
	project name before prompting for changes, support matching for
	project supervisor, fix out-of-bounds error
*/
	dcl     code		 fixed bin (35);
	dcl     printed_projname	 bit (1) aligned;
	dcl     rs_name		 char (32);
	dcl     rs_number		 fixed bin;
	dcl     (set_attr, reset_attr) bit (36);


	dcl     midnight		 fixed bin (71);
	dcl     (i, j)		 fixed bin;
	dcl     (vstr, vstr2)	 char (200) varying;
	dcl     char_16		 char (16);
	dcl     char_32		 char (32);
	dcl     (char_100, char_100_2) char (100);
	dcl     (char_500, char_500_2) char (500);
	dcl     sign		 char (1);
	dcl     fb71		 fixed bin (71);
	dcl     ftemp		 float bin;
	dcl     temp_aim_range	 (2) bit (72) aligned;
	dcl     temp_audit		 bit (36) aligned;

	dcl     (pp, qp)		 pointer;		/* use in include files */
	dcl     mgtp		 pointer;
	dcl     (Nsatep, Nprojfile_p, Nreqfile_p)
				 pointer;
	dcl     EPA_ptr		 pointer;		/* paramter */

	declare error_table_$bad_conversion
				 fixed bin (35) ext static;

	dcl     (satp, satep)	 ptr;		/* hush */

	dcl     1 Nsate		 aligned like project based (Nsatep);

	dcl     1 Nprojfile		 aligned like projfile.projfiletab based (Nprojfile_p);
	dcl     1 Nreqfile		 aligned like reqfiletab based (Nreqfile_p);
	dcl     1 temp_attr		 unaligned like user_attributes;

	dcl     LEGAL		 char (70) int static options (constant)
				 init
				 /* Legal chars */ (
				 "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'_`^~/-abcdefghijklmnopqrstuvwxyz");

	dcl     (addr, after, before, char, hbound, length, ltrim, null, rtrim, string, substr, unspec, verify)
				 builtin;


/* Entries */

	dcl     com_err_		 entry () options (variable);
	dcl     command_query_	 entry () options (variable);
	dcl     command_query_$yes_no	 entry () options (variable);
	dcl     convert_date_to_binary_
				 entry (char (*), fixed bin (71), fixed bin (35));
	dcl     convert_date_to_binary_$relative
				 entry (character (*), fixed binary (71), fixed binary (71), fixed binary (35));
	dcl     convert_access_class_$to_string_range_short
				 entry ((2) bit (72) aligned, character (*), fixed binary (35));
	dcl     convert_access_class_$from_string_range
				 entry ((2) bit (72) aligned, character (*), fixed binary (35));
	dcl     convert_access_class_$to_string_range
				 entry ((2) bit (72) aligned, character (*), fixed binary (35));
	dcl     convert_access_audit_flags_$to_string
				 entry (bit (36) aligned, character (*), fixed binary (35));
	dcl     convert_access_audit_flags_$from_string
				 entry (character (*), bit (36) aligned, fixed binary (35));
	dcl     convert_access_audit_flags_$edit_from_string
				 entry (character (*), bit (36) aligned, fixed binary (35));
	dcl     cu_$arg_list_ptr	 entry (ptr);
	dcl     cv_float_		 entry (character (*), fixed binary (35)) returns (float binary (27));
	dcl     cv_dec_check_	 entry (character (*), fixed binary (35)) returns (fixed binary (35));
	dcl     date_time_		 entry (fixed bin (71), char (*));
	dcl     datebin_$last_midnight entry (fixed binary (71));
	dcl     format_attributes_	 entry (ptr, char (*) var);
	dcl     ioa_		 entry () options (variable);
	dcl     ioa_$rsnnl		 entry () options (variable);
	dcl     ioa_$general_rs	 entry (pointer, fixed binary, fixed binary, character (*), fixed binary (21),
				 bit (1) aligned, bit (1) aligned);
	dcl     parse_attributes_	 entry (character (*), bit (36), bit (36), fixed binary (35));

	dcl     system_info_$rs_number entry (char (*), fixed bin, fixed bin (35));
	dcl     system_info_$rs_name	 entry (fixed bin, char (*), fixed bin (35));
	dcl     sub_err_		 entry () options (variable);

%include query_info;
%include sub_err_flags;
%include edit_proj_arguments_;
%include edit_proj_keywords_;
%include user_attributes;
%include sat;
%include projfile;
%include reqfile;
%include mgt;


	code = 0;
	printed_projname = "0"b;

	edit_proj_arg_ptr = EPA_ptr;
	Nsatep = edit_proj_arg.satep;
	Nprojfile_p = edit_proj_arg.projfile_ep;
	Nreqfile_p = edit_proj_arg.reqfile_ep;
	mgtp = edit_proj_arg.mgtp;

	if edit_proj_arg.all
	then call process_all_items ();
	else call process_one_item (edit_proj_arg.value_index, "0"b);
						/* Don't perform a check, really make the change */
	return;

check:
     entry (EPA_ptr);
	edit_proj_arg_ptr = EPA_ptr;
	Nsatep = edit_proj_arg.satep;
	Nprojfile_p = edit_proj_arg.projfile_ep;
	Nreqfile_p = edit_proj_arg.reqfile_ep;
	mgtp = edit_proj_arg.mgtp;
	call process_one_item (edit_proj_arg.value_index, "1"b);
	return;


process_all_items:
     procedure;

	declare x			 fixed bin;
	declare again		 bit (1) aligned;

	again = "1"b;
	do while (again);
	     do x = 1 to hbound (PROJ_KEY_ALL_ORDER, 1);
		call process_one_item (PROJ_KEY_ALL_ORDER (x), "0"b);
	     end;
	     call command_query_$yes_no (again, (0), edit_proj_arg.caller, "", "Do you wish to review the project?");
	end;

	return;
     end process_all_items;



process_one_item:
     procedure (Value_index, check);			/* uses EPA for other data */

	declare Value_index		 fixed bin;
	declare check		 bit (1) aligned;
	declare new		 bit (1) aligned;

/**** check can only be on if there is a match or new_value to check */

	new = edit_proj_arg.new_value.ptr ^= null ();
	go to item (Value_index);


/**** Title */
item (1):
	call simple_string ("Title", Nprojfile.title);
	return;

/**** Investigator */
item (2):
	call simple_string ("Investigator", Nprojfile.inv);
	return;

/**** inv Address */
item (3):
	call simple_string ("Inv. Address", Nprojfile.inv_addr);
	return;

/**** Supervisor */
item (4):
	if check
	then return;
	char_100 = Nprojfile.sup;
	if edit_proj_arg.match
	then if match_value_string ^= char_100
	     then call no_match;
	call get_string ("Supervisor", Nprojfile.sup);
	if Nprojfile.sup = "="
	then do;
		Nprojfile.sup = Nprojfile.inv;
		Nprojfile.sup_addr = Nprojfile.inv_addr;
	     end;
	if char_100 ^= Nprojfile.sup
	then do;
		call long_report ("""^a"" to ""^a""", char_100, Nprojfile.sup);
		edit_proj_arg.changes.anything = "1"b;
	     end;
	return;

/**** Supervisor addr */
item (5):
	if check
	then return;
	if edit_proj_arg.all			/* minor non-modularity */
	then if Nprojfile.sup = Nprojfile.inv
	     then return;				/* Let the = to (4) do the work */

	char_100 = Nprojfile.sup_addr;
	if edit_proj_arg.match
	then if match_value_string ^= char_100
	     then call no_match;
	call get_string ("Sup. Address", Nprojfile.sup_addr);
	if Nprojfile.sup_addr = "="
	then Nprojfile.sup_addr = Nprojfile.inv_addr;
	if char_100 ^= Nprojfile.sup_addr
	then do;
		call long_report ("""^a"" to ""^a""", char_100, Nprojfile.sup_addr);
		edit_proj_arg.changes.anything = "1"b;
	     end;
	return;

/**** Supervisor phone */
item (6):
	call simple_string (" Phone", Nprojfile.sup_phone);
	return;

/**** Account */
item (7):
	if check
	then return;				/* nothing is invalid */
	char_16 = Nreqfile.mitacct;			/* save the old req */
	if edit_proj_arg.match
	then if match_value_string ^= char_16
	     then call no_match;

	/*** get_string will retrieve the value from EPA if available */
	call get_string ("Account", char_16);		/* get the new one, dont set changed  */
	if char_16 ^= Nreqfile.mitacct
	then call change_account (char_16);		/* switch */
	return;

/**** Requisition */
item (8):
	if check
	then return;
	char_16 = Nreqfile.reqno;
	if edit_proj_arg.match
	then if match_value_string ^= char_16
	     then call no_match;
	call get_string ("Requisition", char_16);
	if char_16 ^= Nreqfile.reqno
	then call change_requisition (char_16);
	return;

/**** Amount */
item (9):
	if check
	then do;
		if edit_proj_arg.match
		then call sub_err_ (error_table_$bad_conversion, edit_proj_arg.caller, ACTION_CANT_RESTART, null (),
			(0), "Matching on the value of Amount is not possible.");
		if new
		then do;
			ftemp = cv_float_ (new_value_string, code);
			if code ^= 0
			then call sub_err_ (error_table_$bad_conversion, edit_proj_arg.caller, ACTION_CANT_RESTART,
				null (), (0), """^a"" is not a valid requisition amount.", new_value_string);
		     end;
		return;
	     end;


	char_16 = "";
	sign = "r";
	if Nreqfile.req_amt = 0e0
	then char_16 = "open";
	else call ioa_$rsnnl ("^.2f", char_16, (0), Nreqfile.req_amt);
	call get_string ("Amount", char_16);
	if char_16 = "open"
	then ftemp = 0;
	else do;
		if substr (char_16, 1, 1) = "+" | substr (char_16, 1, 1) = "-"
		then sign = substr (char_16, 1, 1);

		ftemp = cv_float_ ((char_16), code);
		if code ^= 0
		then do;
			call com_err_ (error_table_$bad_conversion, edit_proj_arg.caller,
			     "Invalid specification of amount ""^a""", char_16);
			go to item (9);
		     end;

		if sign ^= "r"
		then ftemp = Nreqfile.req_amt + ftemp;

		if ftemp = 0e0
		then do;
			call com_err_ (0, edit_proj_arg.caller,
			     "Setting an Amount of zero will not cut the project off. Say ""open"" to give the project an open requisition, or set the cutoff date to cut it off."
			     );
			go to item (9);
		     end;
	     end;
	if ftemp ^= Nreqfile.req_amt
	then do;
		Nsate.cutoff = " ";			/* Reset this. */
		edit_proj_arg.changes.anything = "1"b;
		call long_report ("^[open^s^;^.2f^] to ^[open^;^.2f^]", Nreqfile.req_amt = 0e0, Nreqfile.req_amt,
		     ftemp = 0e0, ftemp);
		Nreqfile.req_amt = ftemp;
	     end;
	return;

/**** Cutoff date */
item (10):
	if check
	then do;
		if edit_proj_arg.match
		then do;
			call convert_date_to_binary_ (match_value_string, (0), code);
			if code ^= 0
			then call sub_err_ (code, edit_proj_arg.caller, ACTION_CANT_RESTART, null (), (0),
				"""^a"" is not a valid cutoff date.", match_value_string);
		     end;
		if new
		then do;
			call convert_date_to_binary_ (new_value_string, (0), code);
			if code ^= 0
			then call sub_err_ (code, edit_proj_arg.caller, ACTION_CANT_RESTART, null (), (0),
				"""^a"" is not a valid cutoff date.", new_value_string);
		     end;
		return;
	     end;

	if edit_proj_arg.match
	then do;
		call convert_date_to_binary_ (match_value_string, fb71, (0));
		if fb71 ^= Nreqfile.cutoff
		then call no_match;
	     end;

	call datebin_$last_midnight (midnight);

RE_GET_CUTOFF:
	call date_time_ (Nreqfile.cutoff, char_100_2);
	char_100 = char_100_2;
	call get_string ("Cutoff date", char_100);
	call convert_date_to_binary_$relative ((char_100), fb71, midnight, code);
	if code ^= 0
	then do;
		call com_err_ (code, edit_proj_arg.caller, "Cutoff date ""^a"". ", char_100);
		go to item (10);
	     end;

	if fb71 ^= Nreqfile.cutoff
	then do;
		call date_time_ (fb71, char_100);
		call long_report ("^a to ^a", char_100_2, char_100);
		Nreqfile.cutoff = fb71;
		Nsate.cutoff = " ";
		edit_proj_arg.changes.anything = "1"b;
	     end;
	return;

/**** Billing name */
item (11):
	call simple_string ("Billing name", Nreqfile.billing_name);
	return;

/**** Billing address */
item (12):
	call simple_string ("Billing Address", Nreqfile.billing_addr);
	return;

/**** Rate structure */
item (26):
	if check
	then do;
		if edit_proj_arg.match
		then do;
			call system_info_$rs_number (match_value_string, (0), code);
			if code ^= 0
			then call sub_err_ (code, edit_proj_arg.caller, ACTION_CANT_RESTART, null (), (0),
				"""^a"" is not a valid rate structure.", match_value_string);
		     end;
		if new
		then do;
			call system_info_$rs_number (new_value_string, (0), code);
			if code ^= 0
			then call sub_err_ (code, edit_proj_arg.caller, ACTION_CANT_RESTART, null (), (0),
				"""^a"" is not a valid rate structure.", new_value_string);
		     end;
		return;
	     end;

	call system_info_$rs_name ((Nsate.rs_number), rs_name, (0));
	if edit_proj_arg.match
	then if match_value_string ^= rs_name
	     then call no_match;

RS_LOOP:
	char_32 = rs_name;
	call get_string ("Rate structure", char_32);
	if char_32 = ""
	then return;				/* no change requested */

	call system_info_$rs_number ((char_32), rs_number, code);
	if code ^= 0
	then do;
		call com_err_ (code, edit_proj_arg.caller, "Invalid rate structure name: ""^a""", char_32);
		go to RS_LOOP;
	     end;
	if rs_number ^= Nsate.rs_number
	then do;
		call long_report ("^a to ^a", rs_name, char_32);
		Nsate.rs_number = rs_number;
		edit_proj_arg.changes.anything = "1"b;
	     end;
	return;

/**** (default) Group */
item (13):
	if check
	then do;
		if new
		then if new_value_string ^= ""
		     then do;
			     if ^valid_group (rtrim (new_value_string))
			     then call sub_err_ (0, edit_proj_arg.caller, ACTION_CANT_RESTART, null (), (0),
				     """^a"" is not a group defined in >sc1>mgt.", new_value_string);
			     if new_value_string = "*"
			     then call sub_err_ (0, edit_proj_arg.caller, ACTION_CANT_RESTART, null (), (0),
				     """*"" is not valid as a default group.");
			end;
		return;
	     end;

	if edit_proj_arg.match
	then if match_value_string ^= Nsate.group
	     then call no_match;

DEFAULT_GROUP_LOOP:
	char_32 = Nsate.group;
	call get_string ("Default group", char_32);
	if char_32 = ""
	then return;				/* no change */
	if ^valid_group (rtrim (char_32))
	then do;
		call com_err_ (0, edit_proj_arg.caller, """^a"" is not a group defined in >sc1>mgt.", char_32);
		go to DEFAULT_GROUP_LOOP;
	     end;
	if char_32 = "*"
	then do;
		call com_err_ (0, edit_proj_arg.caller, """*"" is not a valid default group.");
		go to DEFAULT_GROUP_LOOP;
	     end;

	Nsate.group = substr (char_32, 1, length (Nsate.group));
	edit_proj_arg.changes.anything = "1"b;
	return;

/**** Attributes  -- parsed into explicitly set/reset */
item (14):
	if check
	then do;
		if edit_proj_arg.match
		then do;
			call parse_attributes_ (match_value_string, (""b), (""b), code);
			if code ^= 0
			then call sub_err_ (code, edit_proj_arg.caller, ACTION_CANT_RESTART, null (), (0),
				"""^a"" is not a valid attribute string.", match_value_string);
		     end;
		if new
		then do;
			call parse_attributes_ (new_value_string, (""b), (""b), code);
			if code ^= 0
			then call sub_err_ (code, edit_proj_arg.caller, ACTION_CANT_RESTART, null (), (0),
				"""^a"" is not a valid attribute string.", new_value_string);
		     end;
		return;
	     end;

/**** What should matching mean for attributes? Any with these on and off
      and no others? sounds reasonable */

	if edit_proj_arg.match
	then do;
		call parse_attributes_ (match_value_string, set_attr, reset_attr, (0));
		temp_attr = Nsate.at;
		temp_attr.pm_ok = ^temp_attr.pm_ok;	/* no_prim instead if prim_ok */
		temp_attr.sb_ok = ^temp_attr.sb_ok;	/* no_sb ... */
		temp_attr.eo_ok = ^temp_attr.eo_ok;	/* no_eo ... */
		if ^(((string (temp_attr) & set_attr) = set_attr) /* all the sets are set */
		     & ((^string (temp_attr) & reset_attr) = reset_attr))
						/* all the resets are off */
		then call no_match;
	     end;

	call format_attributes_ (addr (Nsate.at), vstr);	/* get current set */
ATTR_LOOP:
	char_500 = vstr;				/* always reprompt with old value */
	call get_string ("Attributes", char_500);
	if char_500 = ""
	then return;				/* Yawn */
	call parse_attributes_ ((char_500), set_attr, reset_attr, code);
	if code ^= 0
	then do;
		call com_err_ (code, edit_proj_arg.caller, "Invalid attribute specification ""^a"" .", char_500);
		go to ATTR_LOOP;
	     end;

	if (set_attr | reset_attr) = ""b
	then return;				/* nothing doing */

	temp_attr = Nsate.at;
	temp_attr.pm_ok = ^temp_attr.pm_ok;		/* no_prim instead if prim_ok */
	temp_attr.sb_ok = ^temp_attr.sb_ok;		/* no_sb ... */
	temp_attr.eo_ok = ^temp_attr.eo_ok;		/* no_eo ... */
	string (temp_attr) = (string (temp_attr) | set_attr) & ^reset_attr;
	temp_attr.pm_ok = ^temp_attr.pm_ok;
	temp_attr.sb_ok = ^temp_attr.sb_ok;
	temp_attr.eo_ok = ^temp_attr.eo_ok;
	if string (temp_attr) = string (Nsate.at)
	then return;
	call format_attributes_ (addr (temp_attr), vstr2);
	call long_report ("^a to^/ ^a", vstr, vstr2);
	Nsate.at = temp_attr;
	edit_proj_arg.changes.anything = "1"b;
	return;

/**** (say) Grace */
item (15):
	call sfb17 ("Grace", 0, -1, Nsate.grace_max);
	return;

%page;
/**** Administrators ... */
item (16):
	if check
	then do;
/**** Don't check match value, there might be junk in there */
		if new
		then if new_value_string ^= ""
		     then call check_admin (new_value_string);
		return;
	     end;

	if edit_proj_arg.match
	then do;					/* We are looking for just one */
		do i = 1 to 4;
		     if Nsate.admin (i).userid = match_value_string
		     then go to HAVE_MATCHING_ADMIN;
		end;
		call no_match;

HAVE_MATCHING_ADMIN:
RE_PROMPT_ONE_ADMIN:
		char_32 = Nsate.admin (i).userid;
		call get_string ("Administrator", char_32);
		if char_32 = Nsate.admin (i).userid
		then return;
		if (char_32 = "." | char_32 = "")
		then do;				/* Delete the creature */
			if Nsate.admin (i).userid ^= ""
			then do;			/* unless already gone */
				call long_report_ ("Deleted administrator ""^a""", Nsate.admin (i).userid);
				do j = i to 3;
				     Nsate.admin (i).userid = Nsate.admin (i + 1).userid;
				end;
				Nsate.admin (4).userid = "";
			     end;
		     end;
		else do;				/* its a replacement */
			if ^check_admin_ (char_32)
			then do;
				call com_err_ (0, edit_proj_arg.caller,
				     "Project administrator ""^a"" not of form Name.Project.", char_32);
				go to RE_PROMPT_ONE_ADMIN;
			     end;
			if Nsate.admin (i).userid = ""
			then call long_report_ ("Added administrator ""^a"".", char_32);
			else call long_report ("^a to ^a", Nsate.admin (i).userid, char_32);
			Nsate.admin (i).userid = substr (char_32, 1, length (Nsate.admin (i).userid));
		     end;
		edit_proj_arg.changes.anything, edit_proj_arg.changes.acls = "1"b;
		return;
	     end;					/* dealing with the match */

/**** We wind up here for the vanilla "show me them one by one" case. */
/**** There can be no "new_value" for this unless we were in the 
      match department, upstairs. */

	if edit_proj_arg.report_project_name & ^printed_projname
	then do;
		call ioa_ ("Project ^a:", Nsate.project_id);
		printed_projname = "1"b;		/* once only */
	     end;
	call ioa_ ("Project administrators. Type ""."" to delete.");
	do i = 1 to 4;
	     if i > 1
	     then if Nsate.admin (i - 1).userid = ""
		then go to DONE_ADMIN;
RE_GET_ADMIN:
	     char_32 = Nsate.admin (i).userid;
	     call get_string (" Administrator", char_32);
	     if char_32 = Nsate.admin (i).userid
	     then ;
	     else if char_32 = "."
	     then do;				/* Deleting */
		     if Nsate.admin (i).userid = ""
		     then go to DONE_ADMIN;		/* . to empty slot */
		     call long_report_ ("Deleted administrator ""^a""", Nsate.admin (i).userid);
		     do j = i to 3;
			Nsate.admin (j).userid = Nsate.admin (j + 1).userid;
		     end;
		     Nsate.admin (4).userid = "";
		     i = i - 1;
		     edit_proj_arg.changes.acls, edit_proj_arg.changes.anything = "1"b;
		end;
	     else do;				/* Replacing */
		     if ^check_admin_ (char_32)
		     then do;
			     call com_err_ (0, edit_proj_arg.caller, "Invalid administrator ""^a"" .", char_32);
			     go to RE_GET_ADMIN;
			end;

		     if Nsate.admin (i).userid = ""
		     then call long_report_ ("Added administrator ""^a""", char_32);
		     else call long_report ("""^a"" to ""^a""", Nsate.admin (i).userid, char_32);
		     Nsate.admin (i).userid = substr (char_32, 1, length (Nsate.admin (i).userid));
		     edit_proj_arg.changes.acls, edit_proj_arg.changes.anything = "1"b;
		end;
	end;

DONE_ADMIN:
	return;					/* PHEW */
%page;

/**** Segment quota */
item (17):
	call quota_value ("seg", "Segment quota", Nprojfile.disk_quota);
	return;

/**** Dir quota */
item (27):
	call quota_value ("dir", "Directory quota", Nprojfile.dir_disk_quota);
	return;

/**** Alias */
item (18):
	if check
	then do;
	     call simple_string ("Alias", char_32);
	end;
	else do;
	     char_32 = Nsate.alias;		/* will need this to see if it changed */
	     call ioa_ ("Project Alias: type ""."" to delete current alias from SAT.");
	     call simple_string ("Alias", Nsate.alias);
	     if Nsate.alias ^= char_32
	     then do;
		edit_proj_arg.changes.alias = "1"b;
		if Nsate.alias = "." then Nsate.alias = "";
	     end;
	end;

	return;

%page;
/**** Groups */
item (19):
	if check
	then do;
/**** Don't check match value, it might contain an invalid group */

		if new
		then if new_value_string ^= ""
		     then if ^valid_group (rtrim (new_value_string))
			then call sub_err_ (0, edit_proj_arg.caller, ACTION_CANT_RESTART, null (), (0),
				"""^a"" is not a group defined in >sc1>mgt.", new_value_string);
		return;
	     end;

	if edit_proj_arg.match
	then do;					/* We are looking for just one */
		do i = 1 to 2;
		     if Nsate.groups (i) = match_value_string
		     then go to HAVE_MATCHING_GROUP;
		end;
		return;				/* not one of ours, jack */
HAVE_MATCHING_GROUP:
RE_PROMPT_ONE_GROUP:
		char_32 = Nsate.groups (i);
		call get_string ("Group", char_32);
		if char_32 = Nsate.groups (i)
		then return;
		if char_32 = "." | char_32 = ""
		then do;				/* Delete the creature */
			if Nsate.groups (i) ^= ""
			then do;
				call long_report_ ("Deleted group ^a", Nsate.groups (i));
				if i = 1
				then Nsate.groups (1) = Nsate.groups (2);
				Nsate.groups (2) = "";
				i = i - 1;	/* revisit */
				edit_proj_arg.changes.anything = "1"b;
			     end;
		     end;
		else do;				/* its a replacement */
			if ^valid_group (rtrim (char_32))
			then do;
				call com_err_ (0, edit_proj_arg.caller,
				     """^a"" is not a group defined in >sc1>mgt.", char_32);
				go to RE_PROMPT_ONE_GROUP;
			     end;
			if Nsate.groups (i) = ""
			then call long_report_ ("Added group ""^a""", char_32);
			else call long_report ("""^a"" to ""^a""", Nsate.groups (i), char_32);
			Nsate.groups (i) = substr (char_32, 1, length (Nsate.groups (i)));
			edit_proj_arg.changes.anything = "1"b;
		     end;
		return;
	     end;					/* dealing with the match */

/**** We wind up here for the vanilla "show me them one by one" case. */
/**** There can be no "new_value" for this unless we were in the 
      match department, upstairs. */

	if edit_proj_arg.report_project_name & ^printed_projname
	then do;
		call ioa_ ("Project ^a:", Nsate.project_id);
		printed_projname = "1"b;		/* once only */
	     end;
	call ioa_ ("Authorized groups. Type ""."" to delete.");
	do i = 1 to 2;
	     if i = 2
	     then if Nsate.groups (1) = ""
		then go to DONE_GROUPS;
RE_PROMPT_FOR_VALID_GROUP:
	     char_32 = Nsate.groups (i);
	     call get_string (" Group", char_32);
	     if char_32 = Nsate.groups (i)
	     then ;
	     else if char_32 = "."
	     then do;				/* Deleting */
		     if Nsate.groups (i) = (8)" "
		     then return;
		     call long_report_ ("Deleted group ^a", Nsate.groups (i));
		     if i = 1
		     then Nsate.groups (1) = Nsate.groups (2);
		     Nsate.groups (2) = "";
		     i = i - 1;
		     edit_proj_arg.changes.anything = "1"b;
		end;
	     else do;				/* Replacing */
		     if ^valid_group (rtrim (char_32))
		     then do;
			     call com_err_ (0, edit_proj_arg.caller, """^a"" is not a group defined in >sc1>mgt.",
				char_32);
			     go to RE_PROMPT_FOR_VALID_GROUP;
			end;

		     if Nsate.groups (i) = ""
		     then call long_report_ ("Added group ""^a""", char_32);
		     else call long_report ("""^a"" to ""^a""", Nsate.groups (i), char_32);
		     Nsate.groups (i) = substr (char_32, 1, length (Nsate.groups (i)));
		     edit_proj_arg.changes.anything = "1"b;
		end;
	end;
DONE_GROUPS:
	return;					/* PHEW */
%page;

/**** Min ring */
item (20):
	call sfb17 ("Minimum login ring", 1, 7, Nsate.min_ring);
	return;

/**** Max ring */
item (21):
	call sfb17 ("Maximum login ring", 1, 7, Nsate.max_ring);
	return;

/**** Pdir Quota */
item (22):
	call sfb17u ("Maximum pdir quota", 0, 262143, Nsate.pdir_quota);
	return;


/**** Max FG */
item (23):
	call sfb9uu ("Maximum foreground processes", 0, -1, Nsate.max_foreground);
	return;

/**** Max BG */
item (24):
	call sfb9uu ("Maximum background processes", 0, -1, Nsate.max_background);
	return;

/**** Abs fg cpu limit */
item (25):
	call sfb17u ("Absentee foreground cpu limit", 0, -1, Nsate.abs_foreground_cpu_limit);
	return;

/**** Authorization */
item (28):
	if check
	then do;
		if edit_proj_arg.match
		then do;
			call convert_access_class_$from_string_range (temp_aim_range, match_value_string, code);
			if code ^= 0
			then call sub_err_ (code, edit_proj_arg.caller, ACTION_CANT_RESTART, null (), (0),
				"Invalid authorization range ""^a"" .", match_value_string);
		     end;

		if new
		then do;
			call convert_access_class_$from_string_range (temp_aim_range, new_value_string, code);
			if code ^= 0
			then call sub_err_ (code, edit_proj_arg.caller, ACTION_CANT_RESTART, null (), (0),
				"Invalid authorization range ""^a"" .", new_value_string);
		     end;
		return;
	     end;

	if edit_proj_arg.match
	then do;
		call convert_access_class_$from_string_range (temp_aim_range, match_value_string, (0));
		if unspec (Nsate.project_authorization) ^= unspec (temp_aim_range)
		then call no_match;
	     end;

	call convert_access_class_$to_string_range (Nsate.project_authorization, char_500, (0));
RE_GET_AUTH:
	call get_string ("Authorization", char_500);
	call convert_access_class_$from_string_range (temp_aim_range, char_500, code);
	if code ^= 0
	then do;
		call com_err_ (code, edit_proj_arg.caller, "Invalid AIM authorization range ""^a"" .", char_500);
		go to item (28);
	     end;

	if unspec (Nsate.project_authorization) = unspec (temp_aim_range)
	then return;				/* no change */

	call convert_access_class_$to_string_range_short (Nsate.project_authorization, char_100, (0));
	call convert_access_class_$to_string_range_short (temp_aim_range, char_100_2, (0));
	call long_report ("""^a""^/ to ""^a""", char_100, char_100_2);
	Nsate.project_authorization = temp_aim_range;
	edit_proj_arg.changes.anything = "1"b;
	return;
%page;

/**** Audit */
item (29):
	if check
	then do;
		if edit_proj_arg.match
		then call sub_err_ (0, edit_proj_arg.caller, ACTION_CANT_RESTART, null (), (0),
			"Matching on the audit flags is not supported");
		if new
		then do;
			call convert_access_audit_flags_$from_string (new_value_string, temp_audit, code);
			if code ^= 0
			then call sub_err_ (code, edit_proj_arg.caller, ACTION_CANT_RESTART, null (), (0),
				"Invalid audit string ""^a"".", new_value_string);
		     end;
		return;
	     end;


	call convert_access_audit_flags_$to_string (Nsate.audit, char_500, (0));
	temp_audit = Nsate.audit;
RE_GET_AUDIT:
	char_500_2 = char_500;
	call get_string ("Audit flags", char_500_2);
	if char_500_2 = ""
	then return;

	call convert_access_audit_flags_$edit_from_string (char_500_2, temp_audit, code);
	if code ^= 0
	then do;
		call com_err_ (code, edit_proj_arg.caller, "Invalid audit flag string ""^a"" .", char_500_2);
		go to RE_GET_AUDIT;
	     end;

	if temp_audit = Nsate.audit
	then return;

/* now the combined flags */
	call convert_access_audit_flags_$to_string (temp_audit, char_500_2, (0));

	call long_report ("""^a""^/ to ""^a""", char_500, char_500_2);
	Nsate.audit = temp_audit;
	edit_proj_arg.changes.anything = "1"b;
	return;

dispose_of_old_charges:
     procedure;

	declare response		 char (12);
	declare explanation		 char (100) init
	  ("You may respond ""drop"", ""bill"", ""transfer"" or ""reset"".")
	  int static options (constant);

	if Nreqfile.chg_mo <= 0e0 & Nreqfile.chg_tr <= 0e0
	then return;


	query_info.version = query_info_version_6;
	query_info.yes_or_no_sw = "0"b;
	query_info.suppress_name_sw = "1"b;
	query_info.suppress_spacing = "1"b;
	query_info.literal_sw = "0"b;
	query_info.prompt_after_explanation = "1"b;
	query_info.explanation_ptr = addr (explanation);
	query_info.explanation_len = length (rtrim (explanation));

RE_QUERY:
	call command_query_ (addr (query_info), response, edit_proj_arg.caller,
	     "What is the disposition of charges of $^.2f to acct ^a, req ^a?", Nreqfile.chg_mo + Nreqfile.chg_tr,
	     Nreqfile.mitacct, Nreqfile.reqno);
	if response = "drop"
	then do;
		Nreqfile.chg_tr = 0.0e0;
		Nreqfile.chg_mo = 0.0e0;
	     end;
	else if response = "transfer"
	then do;
	end;
	else if response = "bill"
	then do;
		call ioa_ ("Generate a manual charge for $^.2f to ^a ^a", Nreqfile.chg_mo, Nreqfile.mitacct,
		     Nreqfile.reqno);
		Nreqfile.chg_tr = 0.0e0;
		Nreqfile.chg_mo = 0.0e0;
	     end;
	else if response = "reset"
	then do;
		call ioa_ ("Charge this requistion has been changed from $^.2f to $0.00", Nreqfile.chg_tr);
		if Nreqfile.req_amt = 0.0e0
		then Nreqfile.chg_tr = 0.0e0;
		else do;
			call ioa_ ("The requisition amount has been changed from $^.2f to $^.2f", Nreqfile.req_amt,
			     Nreqfile.req_amt - Nreqfile.chg_tr);
			Nreqfile.req_amt = Nreqfile.req_amt - Nreqfile.chg_tr;
			Nreqfile.chg_tr = 0.0e0;
		     end;
	     end;
	else do;
		call ioa_ ("^a", explanation);
		go to RE_QUERY;
	     end;
	return;
     end dispose_of_old_charges;

simple_string:
     procedure (prompt, target);
	declare prompt		 char (*);
	declare target		 char (*);
	declare old_target		 char (600);

	if check
	then return;				/* what's to say? */
	if edit_proj_arg.match
	then if match_value_string ^= target
	     then call no_match;

	old_target = target;
	call get_string (prompt, target);
	if target = old_target
	then return;

	call long_report ("""^a"" to ""^a""", old_target, target);
	edit_proj_arg.changes.anything = "1"b;
	return;
     end simple_string;

get_string:
     procedure (prompt, target);
	declare prompt		 char (*);
	declare target		 char (*);
	declare response		 char (500);

	if new					/* use the global so we can turn it off to use it only once. */
	then do;
		target = new_value_string;
		new = "0"b;
		return;
	     end;

	query_info.version = query_info_version_6;
	query_info.yes_or_no_sw = "0"b;
	query_info.suppress_name_sw = "1"b;
	query_info.suppress_spacing = "1"b;
	query_info.literal_sw = "0"b;
	query_info.prompt_after_explanation = "1"b;
	query_info.explanation_ptr = null ();
	query_info.explanation_len = 0;

	if edit_proj_arg.report_project_name & ^printed_projname
	then do;
		call ioa_ ("Project ^a:", Nsate.project_id);
		printed_projname = "1"b;		/* once is enough */
	     end;

	call command_query_ (addr (query_info), response, edit_proj_arg.caller, "^a:^[^25t^a^/^;   ^]", prompt,
	     target ^= "", target);
	if response = ""
	then return;
	target = response;

	return;
     end get_string;


change_account:
     procedure (new_account);
	declare new_account		 char (*);

	call long_report ("""^a"" to ""^a""", Nreqfile.mitacct, new_account);
	call dispose_of_old_charges;
	Nreqfile.mitacct = new_account;
	edit_proj_arg.changes.anything = "1"b;
	return;
     end change_account;

change_requisition:
     procedure (new_requisition);

	declare new_requisition	 char (*);

	call long_report ("""^a"" to ""^a""", Nreqfile.reqno, new_requisition);
	call dispose_of_old_charges;
	Nreqfile.reqno = new_requisition;
	edit_proj_arg.changes.anything = "1"b;
	return;
     end change_requisition;

long_report:
     procedure options (variable);

	declare alp		 pointer;
	declare change_string	 char (1000);
	declare csl		 fixed bin (21);

	if ^edit_proj_arg.long
	then return;
	call cu_$arg_list_ptr (alp);
	call ioa_$general_rs (alp, 1, 2, change_string, csl, "0"b, "0"b);
	call ioa_ ("Changed ^a^[ for project ^a^;^s^] from ^a.", PROJ_KEY_NAMES (Value_index),
	     edit_proj_arg.report_project_name, Nsate.project_id, substr (change_string, 1, csl));
	return;
     end long_report;

long_report_:
     procedure options (variable);

	declare alp		 pointer;
	declare change_string	 char (1000);
	declare csl		 fixed bin (21);

	if ^edit_proj_arg.long
	then return;
	call cu_$arg_list_ptr (alp);
	call ioa_$general_rs (alp, 1, 2, change_string, csl, "0"b, "0"b);
	call ioa_ ("^[Changed project ^a: ^;^s^]^a.", edit_proj_arg.report_project_name, Nsate.project_id,
	     substr (change_string, 1, csl));
	return;
     end long_report_;

sfb17:
     procedure (prompt, min, max, target);

	declare prompt		 char (*);
	declare (min, max)		 fixed bin (18);
	declare (target)		 fixed bin;
	declare junk		 fixed bin (35);

	if check
	then do;
		call sfbcheck (min, max);
		return;
	     end;
	if edit_proj_arg.match
	then if ^sfbmatch ((target))
	     then call no_match;

	call get_fb (prompt, min, max, junk, (target));
	target = junk;
	return;
     end sfb17;


sfb17u:
     procedure (prompt, min, max, target);

	declare prompt		 char (*);
	declare (min, max)		 fixed bin (18);
	declare (
	        target		 unaligned
	        )			 fixed bin;
	declare junk		 fixed bin (35);

	if check
	then do;
		call sfbcheck (min, max);
		return;
	     end;
	if edit_proj_arg.match
	then if ^sfbmatch ((target))
	     then call no_match;

	call get_fb (prompt, min, max, junk, (target));
	target = junk;
	return;
     end sfb17u;


sfb9uu:
     procedure (prompt, min, max, target);

	declare prompt		 char (*);
	declare (min, max)		 fixed bin (18);
	declare target		 fixed bin (9) uns unal;
	declare junk		 fixed bin (35);

	if check
	then do;
		call sfbcheck (min, max);
		return;
	     end;
	if edit_proj_arg.match
	then if ^sfbmatch ((target))
	     then call no_match;

	call get_fb (prompt, min, max, junk, (target));
	target = junk;
	return;
     end sfb9uu;


sfbcheck:
     procedure (min, max);

	declare (min, max)		 fixed bin (18);

	if edit_proj_arg.new_value.ptr ^= null ()
	then call sfbcheck_ (new_value_string);
	if edit_proj_arg.match_value.ptr ^= null ()
	then call sfbcheck_ (match_value_string);

	return;

sfbcheck_:
     procedure (checkee);

	declare checkee		 char (*);
	declare junk		 fixed bin (35);

	junk = cv_dec_check_ (checkee, code);
	if code ^= 0 | junk < min | (max > 0 & junk > max)
	then call sub_err_ (error_table_$bad_conversion, edit_proj_arg.caller, ACTION_CANT_RESTART, null (), (0),
		"Invalid value ""^a"".", checkee);
	return;
     end sfbcheck_;
     end sfbcheck;

sfbmatch:
     procedure (test) returns (bit (1) aligned);

	declare test		 fixed bin;
	declare junk		 fixed bin (35);

	junk = cv_dec_check_ (match_value_string, (0));
	return (junk = test);
     end sfbmatch;

get_fb:
     procedure (prompt, min, max, newfb, oldfb);

	declare prompt		 char (*);
	declare (min, max)		 fixed bin (18);
	declare (newfb, oldfb)	 fixed bin (35);
	declare fb_string		 char (20);

	if new
	then do;					/* already checked */
		newfb = cv_dec_check_ (new_value_string, (0));
		new = "0"b;
		if newfb ^= oldfb
		then do;
			edit_proj_arg.changes.anything = "1"b;
			call long_report ("^d to ^d", oldfb, newfb);
		     end;
		return;
	     end;

RE_GET_FB:
	fb_string = ltrim (char (oldfb));
	call get_string (prompt, fb_string);
	newfb = cv_dec_check_ (fb_string, code);
	if code ^= 0 | newfb < min | (max > 0 & newfb > max)
	then do;
		call com_err_ (error_table_$bad_conversion, edit_proj_arg.caller, "Invalid value ""^a"".", fb_string);
		go to RE_GET_FB;
	     end;
	if newfb = oldfb
	then return;
	call long_report ("^d to ^d", oldfb, newfb);
	edit_proj_arg.changes.anything = "1"b;
	return;
     end get_fb;

check_admin:
     procedure (admin_name);

	declare admin_name		 char (*);

	if ^check_admin_ (admin_name)
	then call sub_err_ (0, edit_proj_arg.caller, ACTION_CANT_RESTART, null (), (0),
		"Invalid project administrator name ""^a"".", admin_name);
	return;
     end check_admin;

check_admin_:
     procedure (admin) returns (bit (1) aligned);

	declare admin		 char (*);
	declare u			 char (32) varying;
	declare p			 char (32) varying;

	u = rtrim (before (admin, "."));
	p = rtrim (after (admin, "."));
	if u = admin
	then return ("0"b);				/* has to have a . */
	if p = ""
	then return ("0"b);				/* followed by something */
	if u = "*" & p = "*"
	then return ("0"b);
	if (u ^= "*" & verify (u, LEGAL) > 0) | (p ^= "*" & verify (p, LEGAL) > 0)
	then return ("0"b);
	return ("1"b);
     end check_admin_;

quota_value:
     procedure (qtype, prompt, target);
	declare qtype		 char (3);
	declare prompt		 char (*);
	declare target		 fixed bin (35);
	declare junk		 fixed bin (35);
	declare (new_string, old_string)
				 char (20);

	if check
	then do;
		if edit_proj_arg.match
		then call sub_err_ (0, edit_proj_arg.caller, ACTION_CANT_RESTART, null (), (0),
			"Matching on quota values is not permitted.");
		if new
		then call sfbcheck (0, 262120);
		return;
	     end;

	if qtype = "dir"
	then old_string = ltrim (char (Nprojfile.dir_disk_quota));
	else old_string = ltrim (char (Nprojfile.disk_quota));

RE_GET_QUOTA:
	new_string = old_string;
	call get_string (prompt, new_string);
	if new_string = old_string
	then return;

	sign = substr (new_string, 1, 1);
	if sign ^= "+" & sign ^= "-"
	then sign = "r";
	junk = cv_dec_check_ (new_string, code);
	if code ^= 0
	then do;
		call com_err_ (error_table_$bad_conversion, edit_proj_arg.caller, "Invalid quota value ""^a"".",
		     new_string);
		go to RE_GET_QUOTA;
	     end;

	if sign ^= "r"
	then if qtype = "dir"
	     then junk = Nprojfile.dir_disk_quota + junk;
	     else junk = Nprojfile.disk_quota + junk;

	if qtype = "dir"
	then do;
		call long_report ("^d to ^d", Nprojfile.dir_disk_quota, junk);
		Nprojfile.dir_disk_quota = junk;
	     end;
	else do;
		call long_report ("^d to ^d", Nprojfile.disk_quota, junk);
		Nprojfile.disk_quota = junk;
	     end;
	edit_proj_arg.changes.anything = "1"b;
	if qtype = "seg"
	then edit_proj_arg.changes.seg_quota = "1"b;
	else edit_proj_arg.changes.dir_quota = "1"b;
	return;
     end quota_value;

no_match:
     procedure;
	go to RETURN;
     end no_match;

valid_group:
     procedure (perhaps_group_name) returns (bit (1) aligned);
	declare perhaps_group_name	 char (*);
	declare groupx		 fixed bin;

	if length (perhaps_group_name) > length (Nsate.group)
						/* easy case */
	then return ("0"b);
	if perhaps_group_name = "*"
	then return ("1"b);				/* special case "*" means "any" */
	do groupx = 17 to mgt.current_size;		/* first 16 are WC's, uggh */
	     mgtep = addr (mgt.entry (groupx));
	     if group.group_id = perhaps_group_name
	     then return ("1"b);
	end;
	return ("0"b);
     end valid_group;

RETURN:
	return;

     end process_one_item;
     end edit_proj_;
