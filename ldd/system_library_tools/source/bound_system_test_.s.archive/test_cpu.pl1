/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   * Copyright (c) 1972 by Massachusetts Institute of        *
   * Technology and Honeywell Information Systems, Inc.      *
   *                                                         *
   *********************************************************** */
/* format: style4,delnl,insnl,ifthenstmt,indnoniterend,ifthendo,ifthen,^thendo */


test_cpu:
     proc;

/* This program calls several test cases that have been known to fail at one time or another on the
   various CPUs. It is assumed that they have been fixed; this program justs checks to make sure
   they indeed have been.

   If no arguments are specified, all tests are run.

   It is assumed new tests will be added as they are developed.

   Coded.		01/10/74 by S.Webber
   Updated	03/27/74 by S.Webber to add mpy_ofl, test_xed, bad_fill.
   Updated	3/20/76 by S.Webber to add test_cmpc_fill, extra_fill, cmpc7
   Updated	3/21/76 by S.Webber to add acv_restart, scm_tally
   Updated	8/27/76 by J. A. Bush to add tests 23 to 32
   Updated          8/30/80 by R. L. Coppola to add tests 33 to 42
   Updated          8/30/80 by R.L. Coppola to make this and associated tests
   bindable.
   Updated          2/24/81 by Rich Coppola to add call to save history regs
   Updated          9/01/81 by Rich Coppola to add test 43, and restructure
   the entire thing.
   Updated          02/15/82 by Rich Fawcett to add test 44 (scm_tro).
   Updated          02/25/82 by Rich Fawcett to add test 45 (rpt_test_odd).
   Updated          02/25/82 by Rich Fawcett to add test 46 (rpt_test_evn)
   Updated	Apr 2, 1982 by Rich Coppola to add FCO info and determine
   CPU type that a test fails on.
   Updated          Nov 8, 1983 by Rich Coppola to add test 47 and beef up test 43.
   Updated          Oct 1984 by Rich Fawcett to add tests 48 to 52.
   Updated          Oct 1984 by Rich Fawcett to call the test cases as cpu_test_$TEST_NMAE
*/


/* Automatic */

dcl  1 ACL (1) aligned,
       2 access_name char (32) aligned,
       2 modes bit (36),
       2 zero bit (36) init ("0"b),
       2 status fixed bin (35);

dcl  num_sel_tests fixed bin;
dcl  targ char (tc) based (tp);
dcl  temp_data char (temp_data_size) based (temp_data_ptr);
dcl  temp_data_ptr ptr;
dcl  temp_data_size fixed bin (21);
dcl  temp_words (temp_data_size) bit (36) based (temp_data_ptr);
dcl  sel_list (NUM_TESTS) fixed bin;
dcl  excl_list (NUM_TESTS) fixed bin;
dcl  long_sw bit (1) init ("0"b);
dcl  line_length fixed bin;
dcl  pdir char (168) aligned;
dcl  (argcount, i, j, k, next_test, start_test, last_test, num_to_cycle, num_to_repeat) fixed bin init (0);
dcl  (COND, sum, RPT, SEL, CYCL) fixed bin;
dcl  tries fixed bin;
dcl  (hreg_ptr, stackp, faultsp, test_data1p) ptr;
dcl  tmlr_ptr ptr init (null);
dcl  (TERM, sel_flag, from_flag, to_flag, cycle_flag, found_arg) bit (1) init ("0"b);
dcl  tp ptr;
dcl  tc fixed bin;
dcl  code fixed bin (35);
dcl  1 akst aligned like kst_attributes;
dcl  (no_display_mc, h_sw, mc_sw, no_cond, brief_sw) bit (1) init ("0"b);
dcl  hreg_state bit (1) aligned;			/* state of the process hreg switch */
dcl  int_cond_name char (32);
dcl  pertinent_info char (100) var init ("");
dcl  FCO_required char (100) var init ("");
dcl  cond_infop ptr;				/* pointer to condition info */
dcl  str char (j) based (tmlr_ptr);
dcl  (no_write_permission, cleanup, any_other, no_read_permission, program_interrupt) condition;
dcl  STR char;
dcl  (null, collate, addr, addrel, baseno, char,fixed,index,length,
     ltrim,rtrim,substr,unspec) builtin;

/* Constants */


dcl  NUM_TESTS fixed bin init (52) static options (constant);

/* LIST OF TEST NAMES */

dcl  test_name (52) char (40) var int static options (constant)
	init ("mlrstern", "tmlr", "csl_oob", "mvn", "mvn_ofl", "tct", "sreg", "csl_onc", "test_sc2", "test_ci",
	"rpd_test", "mlr_tst", "csl_test", "cmpc", "bad_fill", "mpy_ofl", "test_xed", "cmpc7", "extra_fill",
	"test_cmpc_fill", "acv_restart", "scm_tally", "mvt_ascii_to_bcd", "mvt_bcd_to_ascii", "mvt_nine_to_four",
	"mvt_four_to_nine", "mvt_ascii_to_ebcdic", "mvt_ebcdic_to_ascii", "ci_mod_case_2", "acv_restart_csl",
	"cmpn_tst", "itp_mod", "mvnoosb", "cmpb_with_sixbit_offset", "cmpb_with_rotate", "cmpc_pgbnd", "csl_pgflt",
	"scm_pgflt", "scd_con_flt", "xed_dirflt_even", "xed_dirflt_odd", "cmpc_adj_len", "cmpc_zero_ind", "scm_tro",
	"rpt_test_odd", "rpt_test_evn", "scd_oob_tst","cmpb_onc","cmpc_a","cmpc_b","sreg_no_write","tnz");


dcl  num_temps fixed bin int static;
dcl  expected_condition (5) char (32) int static init ((5) (32)"");
dcl  num_expected_cond fixed bin int static;
dcl  myname char (8) int static options (constant) init ("test_cpu");
dcl  mvtr_sw bit (1) int static init ("0"b);

dcl  tempseg_ptr (1:3) ptr int static init ((3) null);
dcl  TRUNC_and_DEACT fixed bin int static init (1);
dcl  DELETE fixed bin int static init (2);
dcl  TRUNCATE fixed bin int static init (3);
dcl  DEACT fixed bin int static init (4);


/* External  */

dcl  ioa_ entry options (variable);
dcl  hcs_$add_acl_entries entry (char (*) aligned, char (*), ptr, fixed bin, fixed bin (35));
dcl  get_group_id_ entry returns (char (32));
dcl  get_line_length_$switch entry (ptr, fixed bin (35)) returns (fixed bin);
dcl  hcs_$history_regs_get entry (bit (1) aligned);
dcl  hcs_$history_regs_set entry (bit (1) aligned);
dcl  hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
dcl  term_$refname entry (char (*) aligned, fixed bin (35));
dcl  phcs_$deactivate entry (ptr, fixed bin (35));
dcl  phcs_$set_kst_attributes entry (fixed bin (35), ptr, fixed bin (35));
dcl  get_pdir_ entry returns (char (168) aligned);
dcl  delete_$ptr entry (ptr, bit (6) aligned, char (*), fixed bin (35));
dcl  hcs_$set_max_length_seg entry (ptr, fixed bin (19), fixed bin (35));
dcl  hcs_$truncate_seg entry (ptr, fixed bin, fixed bin (35));
dcl  com_err_ entry options (variable);
dcl  cu_$arg_count entry returns (fixed bin);
dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
dcl  find_condition_info_ entry (ptr, ptr, fixed bin (35));
dcl  continue_to_signal_ entry (fixed bin (35));
dcl  find_condition_frame_ entry (ptr) returns (ptr);
dcl  cu_$stack_frame_ptr entry (ptr);
dcl  dump_machine_cond_ entry (ptr, ptr, char (32) aligned, fixed bin);
dcl  hran_$hranl entry (ptr, ptr, bit (1));
dcl  test_data1_$ ext;
     


/* test_cpu test cases and support routines */


dcl  cpu_tests_$tmlr entry (fixed bin, ptr, fixed bin, ptr);
dcl  cpu_tests_$tmlr_data char (58) aligned ext;
dcl  cpu_tests_$mvn entry (ptr);
dcl  cpu_tests_$tct entry (ptr);
dcl  cpu_tests_$mvn_ofl entry (ptr);
dcl  cpu_tests_$mlrstern entry (ptr, ptr);
dcl  cpu_tests_$sreg entry;
dcl  cpu_tests_$csl_onc entry (ptr);
dcl  cpu_tests_$test_sc2 entry (ptr);
dcl  cpu_tests_$test_ci entry;
dcl  cpu_tests_$rpd_test entry;
dcl  cpu_tests_$mlr_tst entry (ptr);
dcl  cpu_tests_$cmpc entry;
dcl  cpu_tests_$csl_test entry (ptr, ptr);
dcl  cpu_tests_$csl_oob entry (ptr);
dcl  cpu_tests_$bad_fill entry (ptr, ptr);
dcl  cpu_tests_$mpy_ofl entry;
dcl  cpu_tests_$test_xed entry;
dcl  cpu_tests_$cmpc7 entry (ptr);
dcl  cpu_tests_$extra_fill entry (ptr);
dcl  cpu_tests_$test_cmpc_fill entry;
dcl  cpu_tests_$acv_restart entry (ptr);
dcl  cpu_tests_$scm_tally entry (ptr);
dcl  cpu_tests_$mvt_tst_ascii_to_bcd entry;
dcl  cpu_tests_$mvt_tst_bcd_to_ascii entry;
dcl  cpu_tests_$mvt_tst_nine_to_four entry;
dcl  cpu_tests_$mvt_tst_four_to_nine entry;
dcl  cpu_tests_$mvt_tst_ascii_to_ebcdic entry;
dcl  cpu_tests_$mvt_tst_ebcdic_to_ascii entry;
dcl  cpu_tests_$mvt_tst_release_t_segs entry;
dcl  cpu_tests_$ci_mod_case_2 entry (ptr);
dcl  cpu_tests_$acv_restart_csl entry (ptr);
dcl  cpu_tests_$cmpn_tst entry (ptr);
dcl  cpu_tests_$itp_mod entry;
dcl  cpu_tests_$mvnoosb entry (ptr);
dcl  cpu_tests_$cmpb_with_sixbit_offset entry (ptr);
dcl  cpu_tests_$cmpb_with_rotate entry (ptr);
dcl  cpu_tests_$cmpc_pgbnd entry (ptr);
dcl  cpu_tests_$csl_pgflt entry (ptr);
dcl  cpu_tests_$scm_pgflt entry (ptr);
dcl  (cpu_tests_$scd_con_flt,
      cpu_tests_$sreg_no_write) entry;
dcl  cpu_tests_$xed_dirflt_even entry (ptr);
dcl  cpu_tests_$xed_dirflt_odd entry (ptr);
dcl  cpu_tests_$cmpc_zero_ind entry (ptr);
dcl  cpu_tests_$scm_tro entry (ptr);
dcl  cpu_tests_$rpt_test_odd entry (ptr);
dcl  cpu_tests_$rpt_test_evn entry (ptr);
dcl  cpu_tests_$scd_oob_tst entry (ptr, ptr);
dcl  cpu_tests_$cmpc_adj_len entry (ptr);
dcl  (cpu_tests_$cmpb_onc,
      cpu_tests_$cmpc_a,
      cpu_tests_$cmpc_b,
      cpu_tests_$tnz) entry (ptr);
    





dcl  1 cond_info aligned,
%include cond_info;


%page;
%include kst_attributes;
%page;

	on cleanup call CLEANUP;



/* set default options */

	line_length = get_line_length_$switch (null (), code);
	if line_length < 132 then
	     ;
	else long_sw = "1"b;


	call hcs_$history_regs_get (hreg_state);	/* get current state */
	if ^hreg_state then /* if off, turn them on */ call hcs_$history_regs_set ("1"b);

	h_sw = "0"b;				/* set display of hregs to off */
	mc_sw = "0"b;				/* set display of mach cond's to off */
	no_display_mc = "1"b;

	test_data1p = addr (test_data1_$);
	num_to_cycle, num_to_repeat, start_test = 1;
	num_sel_tests, last_test = NUM_TESTS;

	do i = 1 to NUM_TESTS;			/* fill in the test selection */
	     sel_list (i) = i;			/* to default values */
	     excl_list (i) = -1;
	end;

	do i = 1 to 3;				/* ensure all are nul */
	     tempseg_ptr (i) = null ();
	end;



/* get the arguments if given and handle the test specified */



	argcount = cu_$arg_count ();			/* get argument count */

	do j = 1 to argcount;			/* process args */
	     call cu_$arg_ptr (j, tp, tc, code);
	     if code ^= 0 then do;
		call com_err_ (0, (myname), "Invalid or unrecognized control_arg.");
		go to BAD_ARG;
		end;
command_loop:
	     if targ = "-from" | targ = "-fm" then do;
		j = j + 1;
		call cu_$arg_ptr (j, tp, tc, code);
		if code ^= 0 then do;
		     call com_err_ (0, (myname), "Invalid or unrecognized control_arg.");
		     go to BAD_ARG;
		     end;

		start_test = cv_dec_check_ (targ, code);
		from_flag = "1"b;
		if code ^= 0 then do;
		     do k = 1 to NUM_TESTS while (^found_arg);
			if test_name (k) = targ then do;
			     found_arg = "1"b;
			     start_test = k;
			     end;
		     end;
		     if ^found_arg then do;
			call com_err_ (0, myname, "test (^a) not recognized", targ);
			return;
			end;
		     end;
		end;

	     else if targ = "-to" then do;
		to_flag = "1"b;
		j = j + 1;
		call cu_$arg_ptr (j, tp, tc, code);
		if code ^= 0 then do;
		     call com_err_ (0, (myname), "Invalid or unrecognized control_arg.");
		     go to BAD_ARG;
		     end;

		last_test = cv_dec_check_ (targ, code);
		if code ^= 0 then do;
		     do k = 1 to NUM_TESTS while (^found_arg);
			if test_name (k) = targ then do;
			     found_arg = "1"b;
			     last_test = k;
			     end;
		     end;
		     if ^found_arg then do;
			call com_err_ (0, myname, "test (^a) not recognized", targ);
			return;
			end;
		     end;
		end;

	     else if targ = "-repeat" | targ = "-rpt" then do;
		sel_flag = "1"b;
		j = j + 1;
		call cu_$arg_ptr (j, tp, tc, code);
		if code ^= 0 then do;
		     call com_err_ (0, (myname), "Invalid or unrecognized control_arg.");
		     go to BAD_ARG;
		     end;

		num_to_repeat = cv_dec_check_ (targ, code);

		if code ^= 0 then do;
		     call com_err_ (code, (myname),
			"The ""repeat"" control_arg must be followed by a decimal number, not (^a).", targ);
		     go to BAD_ARG;
		     end;
		end;

	     else if targ = "-cycle" | targ = "-cyc" then do;
		j = j + 1;
		cycle_flag = "1"b;
		call cu_$arg_ptr (j, tp, tc, code);

		if code ^= 0 then do;
		     call com_err_ (0, (myname), "Invalid or unrecognized control_arg.");
		     go to BAD_ARG;
		     end;

		num_to_cycle = cv_dec_check_ (targ, code);

		if code ^= 0 then do;
		     call com_err_ (code, (myname),
			"The ""-cycle"" control_arg must be followed by a decimal number, not (^a).", targ);
		     go to BAD_ARG;
		     end;
		end;

	     else if targ = "-sel" | targ = "-select" | targ = "-do" then do;
		sel_flag = "1"b;
		j = j + 1;

		num_sel_tests = 0;
		do i = 1 to NUM_TESTS;		/* zip the select array */
		     sel_list (i) = NUM_TESTS + 1;
		end;


		do j = j to argcount;
		     call cu_$arg_ptr (j, tp, tc, code);
		     if code ^= 0 then do;
			call com_err_ (0, (myname), "bad arg in -select");
			goto BAD_ARG;
			end;
		     if substr (targ, 1, 1) = "-" then goto command_loop;
		     num_sel_tests = num_sel_tests + 1;
		     sel_list (num_sel_tests) = cv_dec_check_ (targ, code);
		     if code ^= 0 then do;
			found_arg = "0"b;
			do k = 1 to NUM_TESTS while (^found_arg);
			     if test_name (k) = targ then do;
				found_arg = "1"b;
				sel_list (num_sel_tests) = k;
				end;
			end;
			if ^found_arg then do;
			     call com_err_ (0, myname, "test (^a) not recognized", targ);
			     return;
			     end;
			end;
		end;
		end;

	     else if targ = "-excl" | targ = "-exclude" then do;
		j = j + 1;

		do j = j to argcount;
		     call cu_$arg_ptr (j, tp, tc, code);
		     if code ^= 0 then do;
			call com_err_ (code, (myname), "bad arg in -exclude");
			goto BAD_ARG;
			end;
		     if substr (targ, 1, 1) = "-" then goto command_loop;

		     k = cv_dec_check_ (targ, code);

		     if code ^= 0 then do;
			found_arg = "0"b;
			do k = 1 to NUM_TESTS while (^found_arg);
			     if test_name (k) = targ then do;
				found_arg = "1"b;
				excl_list (k) = k;
				end;
			end;
			if ^found_arg then do;
			     call com_err_ (0, myname, "test (^a) not recognized", targ);
			     return;
			     end;
			end;

		     if (k > 1) & (k ^> NUM_TESTS) then excl_list (k) = k;
		end;
		end;


	     else if targ = "-test_names" then do;
		call ioa_ ("Test Names:");
		do k = 1 to NUM_TESTS;
		     call ioa_ ("^3d. ^a.", k, test_name (k));
		end;
		return;
		end;

	     else if targ = "-help" then go to USAGE;


	     else if targ = "-history_regs" | targ = "-hregs" then h_sw = "1"b;


	     else if targ = "-machine_conditions" | targ = "-mc" then mc_sw = "1"b;

	     else if targ = "-brief" | targ = "-bf" then brief_sw = "1"b;


	     else if targ = "-long" | targ = "-lg" then do;
						/* turn hregs and mc on */
		mc_sw, h_sw = "1"b;
		call hcs_$history_regs_get (hreg_state);/* get current state */
		if ^hreg_state then /* if off, turn them on */ call hcs_$history_regs_set ("1"b);
		end;


	     else if targ = "-stop_on_failure" | targ = "-sof" then /* don't handle any conditions */ no_cond = "1"b;


	     else do;
		call com_err_ (0, (myname), "Invalid or unrecognizable control_arg (^a)", targ);
		go to BAD_ARG;
		end;


	end;					/* end process args */
	if (sel_flag & from_flag) | (sel_flag & to_flag) then
	     if num_to_repeat = 1 then do;
		call com_err_ (0, (myname), "The -select argument cannot be used with the -to or -from arguments.");
		goto BAD_ARG;
		end;


	go to START;



BAD_ARG:
	call com_err_ (0, (myname), "For a list of valid control_args type 'test_cpu -help'.");
	return;
USAGE:
	call ioa_ ("Usage: test_cpu {-control_args}");
	call ioa_ ("control_args:^/     -from TEST_NUM/NAME (-fm)   -to TEST_NUM/NAME	-test_names
     -exclude TEST_LIST (-excl)  -stop_on_failure (-sof)	-long (lg)");
	call ioa_ ("     -history_regs (-hregs)	   -machine_conditions (-mc)	-brief (-bf)
     -repeat COUNT (-rpt)	   -select (-sel) TEST_LIST   -cycle COUNT^/");
	return;

%page;

START:
	if no_cond then go to start_join;

	on condition (any_other)
	     begin;

		TERM = "0"b;
		cond_infop = addr (cond_info);
		call find_condition_info_ (null (), cond_infop, code);
		int_cond_name = cond_info.condition_name;

		if cond_info.condition_name = "cleanup"
		     | /* dont bother with these */ cond_info.condition_name = "quit"
		     | cond_info.condition_name = "command_error" | cond_info.condition_name = "command_question"
		     | cond_info.condition_name = "linkage_error" | cond_info.condition_name = "finish" then
		     go to END_COND;


		do COND = 1 to num_expected_cond while (^TERM);
		     if rtrim (cond_info.condition_name) = rtrim (expected_condition (COND)) then do;
			call ioa_ ("^a: Test ^a failed --^a-- condition.^/^-^-^-*** HARDWARE FAILING ***", myname,
			     test_name (next_test - 1), int_cond_name);

			if pertinent_info ^= "" then call ioa_ ("^a: ^a", myname, pertinent_info);
			if FCO_required ^= "" then call ioa_ ("^a: ^a", myname, FCO_required);


			TERM = "1"b;
			if ^no_display_mc then call display_mc;
			if next_test > NUM_TESTS /* error in last test? */ then go to done;
			if ^sel_flag then go to test (next_test);
			go to sel_loop;
			end;
		end;


/* If we get here, some fault other than the one we expected ("normal" failure)
   occurred! Here it is our duty to display the MCs and Hregs whether the
   user requested them or not. */


		call ioa_ (
		     "^a: Test ^a encountered an unexpected ^a.^/^-^-^-*** HARDWARE FAILING ***^/^-The function under test does not normally exhibit this failure."
		     , myname, test_name (next_test - 1), int_cond_name);
		no_display_mc = "0"b;
		mc_sw, h_sw = "1"b;
		call display_mc;
		if next_test > NUM_TESTS then /* did last test fail */ go to done;

		if ^sel_flag then go to test (next_test);
		go to sel_loop;

END_COND:
		call continue_to_signal_ (code);

	     end;					/* end cond handler */
%page;

start_join:
	on condition (program_interrupt)
	     begin;
		call ioa_ ("test_cpu: Restarting test ^d.", next_test - 1);
		go to test (next_test - 1);
	     end;					/* end pi handler */


	if (h_sw | mc_sw) then no_display_mc = "0"b;

	if from_flag = "1"b | to_flag = "1"b then do;

	     if from_flag = "0"b then start_test = 1;
	     if to_flag = "0"b then last_test = NUM_TESTS;
	     if start_test > last_test then do;
		call com_err_ (0, (myname), " -from ^d is greater then the -to ^d .", start_test, last_test);
		return;
		end;

	     sel_flag = "1"b;

	     TERM = "0"b;
	     num_sel_tests = 0;
	     do i = 1 to NUM_TESTS while (^TERM);
		num_sel_tests = i;
		sel_list (i) = start_test;
		start_test = start_test + 1;
		if start_test > last_test then TERM = ^TERM;
	     end;
	     end;

	if ^sel_flag then go to test (1);		/* normal pass */

	do RPT = 1 to num_to_repeat;
	     do SEL = 0 to num_sel_tests - 1 while (sel_list (SEL + 1) ^> NUM_TESTS);
		go to test (sel_list (SEL + 1));
sel_loop:
	     end;
	end;

	go to done;
%page;

/*	TEST 1.   mlrstern     */

/* This test tests a particular failure whereby the fill  character is placed as the
   first character of a new page */

test (1):
	next_test = 2;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude1;

	if ^brief_sw then call ioa_ ("Test  1^-<mlrstern>");

	call set_up_conds (3, "derail,mme1,mme4",
	     "Derail = MLR failed; MME1 = MLR and CMPC failed; MME4 = CMPC failed.", "");

	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */
	do CYCL = 1 to num_to_cycle;
	     call prepare_segment (TRUNC_and_DEACT);
	     call cpu_tests_$mlrstern (test_data1p, tempseg_ptr(1));
	end;
	call prepare_segment (DELETE);


exclude1:
	if sel_flag then goto sel_loop;
	if next_test > last_test then goto done;

%page;


/*	TEST 2.	tmlr	*/

/* This test consists of calling " which in turn calls tmlr to do a MLR instruction.
   If test_tmlr notices that the MLR failed it prints out a message.	*/

test (2):
	next_test = 3;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude2;

	if ^brief_sw then call ioa_ ("Test  2^-<tmlr>");

	call set_up_conds (0, "", "", "");

	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call prepare_segment (TRUNC_and_DEACT);

	     do j = 54 to 58;
		do i = 0 to 4;
		     call cpu_tests_$tmlr (i, tmlr_ptr, j, tempseg_ptr (1));
		     if substr (cpu_tests_$tmlr_data, 1, j) ^= str then do;
			call ioa_ (
			     "test tmlr; strings do not match *** HARDWARE FAILING ***^/data should be:^-^a^/data is^7x^-^a^/"
			     , substr (cpu_tests_$tmlr_data, 1, j), str);
			end;
		     call prepare_segment (DEACT);
		end;
	     end;
	end;
	call prepare_segment (DELETE);
exclude2:
	if sel_flag then goto sel_loop;
	if next_test > last_test then goto done;

%page;


/* 	TEST 3.	csl_oob	*/

/* This test consists in calling the program csl_oob, failure gives us an out_of_bounds */

test (3):
	next_test = 4;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude3;

	if ^brief_sw then call ioa_ ("Test  3^-<csl_oob>");

	call set_up_conds (1, "out_of_bounds", "Key to failure is starting Bit No. in D1.", "");

	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call prepare_segment (TRUNC_and_DEACT);
	     call cpu_tests_$csl_oob (tempseg_ptr (1));
	end;

	call prepare_segment (DELETE);

exclude3:
	if sel_flag then goto sel_loop;
	if next_test > last_test then goto done;


%page;


/*	TEST 4.	mvn	*/

/* This test consists in a call to the routine "mvn" does not fault if the hardware works. */

test (4):
	next_test = 5;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude4;

	if ^brief_sw then call ioa_ ("Test  4^-<mvn>");

	call set_up_conds (3, "derail,mme1,mme4",
	     "DERAIL = MVN failed; MME1 = MVN and CMPC failed; MME4 = CMPC failed.", "");
	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call prepare_segment (TRUNC_and_DEACT);
	     call cpu_tests_$mvn (tempseg_ptr (1));
	end;

	call prepare_segment (DELETE);

exclude4:
	if sel_flag then goto sel_loop;
	if next_test > last_test then goto done;

%page;


/*	TEST 5.	mvn_ofl	*/

/* This test checks the moving of a number which has value 0. It should not get
   an overflow */

test (5):
	next_test = 6;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude5;

	if ^brief_sw then call ioa_ ("Test  5^-<mvn_ofl>");

	call set_up_conds (1, "overflow", "", "");

	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call prepare_segment (TRUNC_and_DEACT);
	     call cpu_tests_$mvn_ofl (tempseg_ptr(1));
	end;

	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */


exclude5:
	if sel_flag then goto sel_loop;
	if next_test > last_test then goto done;

%page;


/*	TEST 6.	tct	*/

/* This test consists in a call to the routine "tct" which gets  an op_not_complete
   if the hardware fails. */

test (6):
	next_test = 7;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude6;

	if ^brief_sw then call ioa_ ("Test  6^-<tct>");

	call set_up_conds (1, "op_not_complete", "", "");

	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call prepare_segment (TRUNC_and_DEACT);
	     call cpu_tests_$tct (tempseg_ptr(1));
	end;

	call prepare_segment (DELETE);


exclude6:
	if sel_flag then goto sel_loop;
	if next_test > last_test then goto done;

%page;


/*	TEST 7.	sreg	*/

/* This test is done by calling the program sreg which has an sreg instruction as the
   last instruction on a page and the next procedure page faults.

   The test fails (the hardware is broken) if we get an op-not-complete. */


test (7):
	next_test = 8;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude7;

	if ^brief_sw then call ioa_ ("Test  7^-<sreg>");

	call set_up_conds (1, "op_not_complete", "", "");

	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call cpu_tests_$sreg ();				/* run the actual test */
	end;

	call prepare_segment (DELETE);

exclude7:
	if sel_flag then goto sel_loop;
	if next_test > last_test then goto done;

%page;


/*	TEST 8.	csl_onc	*/

/* This test consists in calling csl_onc which gets an op_not_complete if it fails. */

test (8):
	next_test = 9;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude8;

	if ^brief_sw then call ioa_ ("Test  8^-<csl_onc>");

	call set_up_conds (1, "op_not_complete", "", "");

	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call prepare_segment (TRUNC_and_DEACT);
	     call cpu_tests_$csl_onc (tempseg_ptr (1));
	end;

	call prepare_segment (DELETE);

exclude8:
	if sel_flag then goto sel_loop;
	if next_test > last_test then goto done;

%page;


/*	TEST 9.	test_sc2	*/

/* This test checks the sequence character tag.  A ZOP fault occurs if the hardware fails. */

test (9):
	next_test = 10;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude9;

	if ^brief_sw then call ioa_ ("Test  9^-<test_sc2>");

	call set_up_conds (1, "illegal_opcode", "", "");


	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call prepare_segment (TRUNC_and_DEACT);
	     call cpu_tests_$test_sc2 (tempseg_ptr(1));
	end;

	call prepare_segment (DELETE);

exclude9:
	if sel_flag then goto sel_loop;
	if next_test > last_test then goto done;

%page;


/*	TEST 10.	test_ci	*/

/* This test tries out a CI modifier. The test gets a ZOP fault if the hardware fails. */

test (10):
	next_test = 11;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude10;

	if ^brief_sw then call ioa_ ("Test 10^-<test_ci>");

	call set_up_conds (1, "illegal_opcode", "", "");

	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */


	do CYCL = 1 to num_to_cycle;
	     call cpu_tests_$test_ci ();
	end;

	call prepare_segment (DELETE);


exclude10:
	if sel_flag then goto sel_loop;
	if next_test > last_test then goto done;

%page;


/* 	TEST 11.	rpd_test	*/

/* This test tries a particluar RPD sequence that failed on Serial 7 at MIT */

test (11):
	next_test = 12;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude11;

	if ^brief_sw then call ioa_ ("Test 11^-<rpd_test>");

	call set_up_conds (1, "illegal_opcode", "", "");

	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call cpu_tests_$rpd_test ();
	end;

	call prepare_segment (DELETE);

exclude11:
	if sel_flag then goto sel_loop;
	if next_test > last_test then goto done;

%page;


/*	TEST 12.	mlr_tst	*/

/* This test tries a particular MLR sequence. */

test (12):
	next_test = 13;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude12;

	if ^brief_sw then call ioa_ ("Test 12^-<mlr_tst>");

	call set_up_conds (3, "derail,mme1,mme4",
	     "Derail = MLR failed; MME1 = MLR and CMPC failed; MME4 = CMPC failed.", "");


/* This test interacts with the bound fault mechanism. We must create anew the testcpu_tempseg(1) each time we run the
   test as well as terminate the test itself */

	num_temps = 1;				/* need one temp seg */
	do CYCL = 1 to num_to_cycle;
	     call make_tempsegs;			/* make it */
	     call term_$refname ("mlr_tst", code);
	     call cpu_tests_$mlr_tst (tempseg_ptr(1));
	     call prepare_segment (DELETE);
	end;

exclude12:
	if sel_flag then goto sel_loop;
	if next_test > last_test then goto done;


%page;

/*	TEST 13.	csl_test	*/

/* This test tries a given CSL instruction which fails across a boundsfault boundary */

test (13):
	next_test = 14;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude13;

	if ^brief_sw then call ioa_ ("Test 13^-<csl_test>");

	call set_up_conds (1, "illegal_opcode", "", "");

/* This test, like test 12, interacts with the boundfault mechanism. Similar things are done */
	num_temps = 1;				/* need one temp seg */
	do CYCL = 1 to num_to_cycle;
	     call make_tempsegs;			/* make it */
	     call term_$refname ("csl_test", code);
	     call cpu_tests_$csl_test (test_data1p, tempseg_ptr(1));
	     call prepare_segment (DELETE);
	end;

exclude13:
	if sel_flag then goto sel_loop;
	if next_test > last_test then goto done;

%page;

/*	TEST 14.  cmpc	*/

/* This test tries a given cmpc insruction which fails when hit with */
/* a TRO or connect fault 				*/

test (14):
	next_test = 15;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude14;

	if ^brief_sw then call ioa_ ("Test 14^-<cmpc>");

	call set_up_conds (1, "illegal_opcode", "", "");
	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call cpu_tests_$cmpc ();
	end;

	call prepare_segment (DELETE);

exclude14:
	if sel_flag then goto sel_loop;
	if next_test > last_test then go to done;
%page;


/*	TEST 15.	bad_fill	*/

/* This test checks to see if an MLR or CMPC that ends in the first 2 words of a new page
   works correctly. */

test (15):
	next_test = 16;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude15;

	if ^brief_sw then call ioa_ ("Test 15^-<bad_fill>");

	call set_up_conds (1, "illegal_opcode", "MLR generating bad fill.", "");
	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */


	do CYCL = 1 to num_to_cycle;
	     call prepare_segment (TRUNC_and_DEACT);
	     call cpu_tests_$bad_fill (test_data1p, tempseg_ptr(1));
	end;

	call prepare_segment (DELETE);

exclude15:
	if sel_flag then goto sel_loop;
	if next_test > last_test then goto done;

%page;


/*	TEST 16.	mpy_ofl	*/

/* This test checks to see if an overflow fault occurs when the number -2**35 is
   multiplied by itself. An overflow should not occur. */

test (16):
	next_test = 17;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude16;

	if ^brief_sw then call ioa_ ("Test 16^-<mpy_ofl>");

	call set_up_conds (1, "fixedoverflow", "", "");

	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call cpu_tests_$mpy_ofl;
	end;

	call prepare_segment (DELETE);


exclude16:
	if sel_flag then goto sel_loop;
	if next_test > last_test then goto done;

%page;

/* 	TEST 17.	test_xed	*/

/* This test checks a particular XED sequence which fails to do the proper indexing
   in the executed instructions. */

test (17):
	next_test = 18;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude17;

	if ^brief_sw then call ioa_ ("Test 17^-<test_xed>");

	call set_up_conds (1, "illegal_opcode", "XED did not index properly.", "");

	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call cpu_tests_$test_xed;
	end;

	call prepare_segment (DELETE);


exclude17:
	if sel_flag then goto sel_loop;
	if next_test > last_test then goto done;

%page;

/*	TEST 18.	cmpc7	*/

/* This test checks a particular cmpc use where both strrings are 7 words from the end of a page */

test (18):
	next_test = 19;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude18;

	if ^brief_sw then call ioa_ ("Test 18^-<cmpc7>");

	call set_up_conds (1, "illegal_opcode", "", "");

	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call cpu_tests_$cmpc7 (test_data1p);
	end;

	call prepare_segment (DELETE);


exclude18:
	if sel_flag then goto sel_loop;
	if next_test > last_test then goto done;

%page;

/*	TEST 19.	extra_fill	*/

/* This test checks to see if extra fill characters are placed after a string moved by an MLR which
   starts 6 words from the end of a page */

test (19):
	next_test = 20;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude19;

	if ^brief_sw then call ioa_ ("Test 19^-<extra_fill>");

	call set_up_conds (1, "illegal_opcode", "MLR causing extra fill.", "");

	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */


	do CYCL = 1 to num_to_cycle;
	     call prepare_segment (TRUNC_and_DEACT);
	     call cpu_tests_$extra_fill (tempseg_ptr(1));
	end;

	call prepare_segment (DELETE);


exclude19:
	if sel_flag then goto sel_loop;
	if next_test > last_test then goto done;

%page;

/* 	TEST 20.	test_cmpc_fill	*/

/* This test checks that the fill character used in a cmpc instruction is correct */

test (20):
	next_test = 21;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude20;

	if ^brief_sw then call ioa_ ("Test 20^-<test_cmpc_fill>");

	call set_up_conds (1, "illegal_opcode", "", "");

	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call cpu_tests_$test_cmpc_fill;
	end;

	call prepare_segment (DELETE);


exclude20:
	if sel_flag then goto sel_loop;
	if next_test > last_test then goto done;

%page;

/*	TEST 21.	acv_restart	*/

/* This test check that the hardware can successfully restart the machine conditions after an
   access violation fault caused by a reference to data via an EIS (mlr) instruction */

test (21):
	next_test = 22;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude21;

	if ^brief_sw then call ioa_ ("Test 21^-<acv_restart>");

	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	on no_write_permission
	     begin;
		if tries > 1 then do;
		     call ioa_ ("^a (restart did not work  *** HARDWARE FAILING ***)", test_name (next_test - 1));
		     if ^no_display_mc then /* are we in brief mode? */ call display_mc;
						/* no go print out the machine conditions */
		     revert no_write_permission;
		     go to exclude21;
		     end;
		ACL.access_name = get_group_id_ ();
		ACL.modes = "101"b;
		pdir = get_pdir_ ();
		call hcs_$add_acl_entries (pdir, "testcpu_tempseg_1", addr (ACL), 1, code);
		tries = tries + 1;
	     end;

	do CYCL = 1 to num_to_cycle;
	     tries = 0;
	     call prepare_segment (TRUNC_and_DEACT);
	     call cpu_tests_$acv_restart (tempseg_ptr(1));
	end;

	call prepare_segment (DELETE);

exclude21:
	revert no_write_permission;
	if sel_flag then goto sel_loop;
	if next_test > last_test then goto done;

%page;


/* 	TEST 22.	scm_tally */

/* This test attempts to see if the SCM instruction works with the tally runout indicator being
   set correctly. The test calls a small alm program that uses an scm instruction. Sometimes the hardware
   fails -- sometimes it doesn't. Therefore the test is run 100 times to get a slight statistical
   sampling */

test (22):
	next_test = 23;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude22;

	if ^brief_sw then call ioa_ ("Test 22^-<scm_tally>");

	call set_up_conds (1, "illegal_opcode", "SCM failed to set the tally runout indicator.", "");

	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     sum = 0;
	     call prepare_segment (TRUNC_and_DEACT);
	     do i = 1 to 100;
		call prepare_segment (DEACT);
		call cpu_tests_$scm_tally (tempseg_ptr(1));
	     end;
	end;

	call prepare_segment (DELETE);

exclude22:
	if sel_flag then goto sel_loop;
	if next_test > last_test then goto done;

%page;

/* test 23. mvt_ascii_to_bcd */
/*
   This test checks nine to six (ascii to bcd) conversion using the MVT instruction. A large ascii data
   segment  is  generated  and  a  subsequent  bcd segment is generated using non EIS conversion. Three
   segments are then converted from ascii to bcd, using the MVT  instruction  and  these  segments  are
   compared  to  the  known  good bcd segment. If any compare errors are detected, the contents of both
   segments are dumped in octal at the failing location.
*/

test (23):
	next_test = 24;
	mvtr_sw = "1"b;				/* set release switch */
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude23;

	if ^brief_sw then call ioa_ ("Test 23^-<mvt_ascii_to_bcd>");

	call set_up_conds (0, "", "", "");
	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call cpu_tests_$mvt_tst_ascii_to_bcd;
	end;

	call prepare_segment (DELETE);

exclude23:
	if sel_flag then goto sel_loop;
	if next_test > last_test then go to done;

%page;

/* test 24. mvt_six_to_nine */
/*
   This test checks six to nine (bcd to ascii) conversion using the MVT instruction. A large ascii data
   segment  is generated and then a bcd segment is generated, converting the ascii segment with non EIS
   code. The known good bcd segment is then converted to ascii, using the MVT instruction, into 3 large
   segments.  The  3  converted  segments  are  then  compared to the original ascii segment and if any
   descrepencies are found the contents of both segments are dumped in octal at the failing location.
*/

test (24):
	mvtr_sw = "1"b;				/* set release switch */
	next_test = 25;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude24;

	if ^brief_sw then call ioa_ ("Test 24^-<mvt_bcd_to_ascii>");

	call set_up_conds (0, "", "", "");
	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call cpu_tests_$mvt_tst_bcd_to_ascii;
	end;

	call prepare_segment (DELETE);


exclude24:
	if sel_flag then goto sel_loop;
	if next_test > last_test then go to done;

%page;

/* test 25. mvt_nine_to_four */
/*
   This test checks 9 bit to 4 bit (decimal to packed decimal) conversion using the MVT instruction.  A
   large  segment of data is generated containing 9 bit charaters with a value of 0 to 15 in a rotating
   pattern. Then a second segment if generated, converting the 9 bit characters into 4  bit  characters
   using  non  EIS  conversion techniques. The 9 bit data is then converted to 4 bit data using the MVT
   instruction, into 3 segments and this converted data is compared to the known good 4  bit  data.  If
   any descrepencies are found, the contents of both segments are dumped in octal at the failing.
*/

test (25):
	next_test = 26;
	mvtr_sw = "1"b;				/* set release switch */
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude25;

	if ^brief_sw then call ioa_ ("Test 25^-<mvt_nine_to_four>");

	call set_up_conds (0, "", "", "");
	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call cpu_tests_$mvt_tst_nine_to_four;
	end;
	call prepare_segment (DELETE);

exclude25:
	if sel_flag then goto sel_loop;
	if next_test > last_test then go to done;

%page;

/* test 26 */
/*
   This test checks 4 bit to 9 bit (packed decimal to decimal ) conversion using the MVT instruction. 9
   bit  and  4  bit data segments are generated using non EIS conversion as described in test 25. The 4
   bit data is then converted to 9 bit with an MVT instruction into 3 segments. The 3 segments are then
   compared  to  the  original  9  bit  segment.  If  any descrepencies are found, the contents of both
   segments are dumped in octal ato the failing location.
*/

test (26):
	next_test = 27;
	mvtr_sw = "1"b;				/* set release switch */
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude26;

	if ^brief_sw then call ioa_ ("Test 26^-<mvt_four_to_nine>");

	call set_up_conds (0, "", "", "");
	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call cpu_tests_$mvt_tst_four_to_nine;
	end;
	call prepare_segment (DELETE);

exclude26:
	if sel_flag then goto sel_loop;
	if next_test > last_test then go to done;

%page;

/* test 27. mvt_ascii_to_ebcdic */
/*
   This test checks nine to nine (ascii to ebcdic) character conversion using the  MVT  instruction.  A
   large  ascii  segment  is  generated  and  then  this  segment  is converted to ebcdic using non EIS
   techniques. The ascii segment is then converted  into  3  segments  using  a  MVT  instruction.  The
   resultant  ebcdic  segments  are  compared to the know good ebcdic segment. If any descrepencies are
   found, the contents of both segments are dumped at the failing location.
*/

test (27):
	next_test = 28;
	mvtr_sw = "1"b;				/* set release switch */
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude27;

	if ^brief_sw then call ioa_ ("Test 27^-<mvt_ascii_to_ebcdic>");

	call set_up_conds (0, "", "", "");
	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call cpu_tests_$mvt_tst_ascii_to_ebcdic;
	end;
	call prepare_segment (DELETE);

exclude27:
	if sel_flag then goto sel_loop;
	if next_test > last_test then go to done;

%page;

/* test 28. mvt_ebcdic_to_ascii */
/*
   This test checks nine to nine (ebcdic to ascii) character  conversion  using  the  MVT  instruction.
   Large  ascii  and  ebcdic segments are generated using non EIS conversion techniques as described in
   test 27. The known good ebcdic segment is converted to  ascii  using  the  MVt  instruction  into  3
   segments.  The  known  good  ascii  segment  is  compared  with  the  3  converted  segments. If any
   descrepencies are found, the contents of both segments are dumped in octal at the failing location.
*/

test (28):
	next_test = 29;
	mvtr_sw = "1"b;				/* Set release switch */
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude28;

	if ^brief_sw then call ioa_ ("Test 28^-<mvt_ebcdic_to_ascii>");

	call set_up_conds (0, "", "", "");
	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call cpu_tests_$mvt_tst_ebcdic_to_ascii;
	end;
	call prepare_segment (DELETE);

exclude28:
	if sel_flag then goto sel_loop;
	if next_test > last_test then go to done;

%page;

/* test 29. ci_mod_case_2 */
/*
   This test checks character indirect modification with 2 tally words and  2  data  character  strings
   each located at a page boundary. A LDA instruction is executed on one tally word with ci mod, a cmpa
   is executed with a second tally word, ci mod. Both tally words point to a char. string  that  should
   be  equal.  If the zero indicator does not come on as a result of the cmpa, a ZOP fault is taken and
   the test failed. */

test (29):
	next_test = 30;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude29;

	if ^brief_sw then call ioa_ ("Test 29^-<ci_mod_case_2>");

	call set_up_conds (1, "illegal_opcode", "", "");
	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call prepare_segment (TRUNC_and_DEACT);
	     call cpu_tests_$ci_mod_case_2 (tempseg_ptr (1));
	end;
	call prepare_segment (DELETE);

exclude29:
	if sel_flag then goto sel_loop;
	if next_test > last_test then go to done;

%page;

/*	TEST 30.	acv_restart_csl	*/

/* This test check that the hardware can successfully restart the machine conditions after an
   access violation fault caused by a reference to data via an EIS (csl) instruction */

test (30):
	next_test = 31;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude30;

	if ^brief_sw then call ioa_ ("Test 30^-<acv_restart_csl>");

	call set_up_conds (0, "", "", "");
	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	on no_write_permission
	     begin;
		if tries > 1 then do;
		     call ioa_ ("restart did not work  *** HARDWARE FAILING ***");
		     if ^no_display_mc then /* are we in brief mode? */ call display_mc;
						/* no go print out the machine conditions */
		     revert no_write_permission;
		     goto exclude30;
		     end;
		ACL.access_name = get_group_id_ ();
		ACL.modes = "101"b;
		pdir = get_pdir_ ();
		call hcs_$add_acl_entries (pdir, "testcpu_tempseg_1", addr (ACL), 1, code);
		tries = tries + 1;
	     end;

	do CYCL = 1 to num_to_cycle;
	     tries = 0;
	     call prepare_segment (TRUNC_and_DEACT);
	     call cpu_tests_$acv_restart_csl (tempseg_ptr (1));
	end;
	call prepare_segment (DELETE);


exclude30:
	revert no_write_permission;
	if sel_flag then goto sel_loop;
	if next_test > last_test then goto done;

%page;

/* test 31. cmpn_tst */
/* This test checks that numeric data moved with a mvn instruction can be successfully compared
   with a cmpn instruction. */

test (31):
	next_test = 32;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude31;

	if ^brief_sw then call ioa_ ("Test 31^-<cmpn_tst>");

	call set_up_conds (1, "illegal_opcode", "", "");
	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call prepare_segment (TRUNC_and_DEACT);
	     call cpu_tests_$cmpn_tst (tempseg_ptr (1));
	end;
	call prepare_segment (DELETE);

exclude31:
	if sel_flag then goto sel_loop;
	if next_test > last_test then go to done;
%page;

/*	TEST 32. itp_mod */

/* This test checks that an epp2,* to a word pair tahat  contains an itp modifier
   with a bit offset actually loads pr2 with the correct information */


test (32):
	next_test = 33;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude32;

	if ^brief_sw then call ioa_ ("Test 32^-<itp_mod>");

	call set_up_conds (1, "illegal_opcode", "", "");
	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call cpu_tests_$itp_mod;
	end;
	call prepare_segment (DELETE);

exclude32:
	if sel_flag then goto sel_loop;
	if next_test > last_test then go to done;

%page;


test (33):
	next_test = 34;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude33;

	if ^brief_sw then call ioa_ ("Test 33^-<mvnoosb>");

	call set_up_conds (1, "out_of_bounds", "Pre-page (FPTW2) logic not working.", "");
	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call prepare_segment (TRUNC_and_DEACT);
	     call cpu_tests_$mvnoosb (tempseg_ptr (1));
	end;
	call prepare_segment (DELETE);

exclude33:
	if sel_flag then goto sel_loop;
	if next_test > last_test then go to done;

%page;

test (34):
	next_test = 35;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude34;

	if ^brief_sw then call ioa_ ("Test 34^-<cmpb_with_sixbit_offset>");

	call set_up_conds (0, "", "", "");
	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call prepare_segment (TRUNC_and_DEACT);
	     call cpu_tests_$cmpb_with_sixbit_offset (tempseg_ptr (1));
	end;
	call prepare_segment (DELETE);

exclude34:
	if sel_flag then goto sel_loop;
	if next_test > last_test then go to done;

%page;

test (35):
	next_test = 36;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude35;

	if ^brief_sw then call ioa_ ("Test 35^-<cmpb_with_rotate>");

	call set_up_conds (0, "", "", "");
	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call prepare_segment (TRUNC_and_DEACT);
	     call cpu_tests_$cmpb_with_rotate (tempseg_ptr (1));
	end;
	call prepare_segment (DELETE);

exclude35:
	if sel_flag then goto sel_loop;
	if next_test > last_test then go to done;
%page;


/*	TEST 36. cmpc_pgbnd (cmpc fails on page bound when one string is zero length) */

/* This tests a CMPC instruction at seg|1767 (octal) for 38 chars against a 0 length string
   with blank fill. */

test (36):
	next_test = 37;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude36;

	if ^brief_sw then call ioa_ ("Test 36^-<cmpc_pgbnd>");

	call set_up_conds (1, "illegal_opcode", "", "");
	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call prepare_segment (TRUNC_and_DEACT);
	     call cpu_tests_$cmpc_pgbnd (tempseg_ptr (1));
	end;
	call prepare_segment (DELETE);

exclude36:
	if sel_flag then goto sel_loop;
	if next_test > last_test then go to done;

%page;


/*	TEST 37. csl_pgflt (csl gets no_write_perm if page faults on target & source is read-only */

test (37):
	next_test = 38;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude37;

	if ^brief_sw then call ioa_ ("Test 37^-<csl_pgflt>");

	call set_up_conds (1, "no_write_permission", "", "");
	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call prepare_segment (TRUNC_and_DEACT);
	     call cpu_tests_$csl_pgflt (tempseg_ptr (1));
	end;
	call prepare_segment (DELETE);

exclude37:
	if sel_flag then goto sel_loop;
	if next_test > last_test then goto done;

%page;


/*	TEST 38.  scm_pgflt (trouble with SCM instruction when operand gets a pagefault) */

test (38):
dcl  scm_str char (1044449) based (tempseg_ptr (1));
dcl  start fixed bin (21) init (143242);


	next_test = 39;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude38;

	if ^brief_sw then call ioa_ ("Test 38^-<scm_pgflt>");

	call set_up_conds (1, "illegal_opcode", "", "");
	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     substr (scm_str, start, 132) = "";
	     substr (scm_str, start + 132, 1) = "
";						/* a new line */

	     do i = 1 to 500;
		call prepare_segment (DEACT);
		call cpu_tests_$scm_pgflt (tempseg_ptr (1));
	     end;
	end;
	call prepare_segment (DELETE);

exclude38:
	if sel_flag then goto sel_loop;
	if next_test > last_test then go to done;

%page;


/*	TEST 39.	scd_con_flt (SCD fails very rarely when interrupted by connect fault(?)) */

test (39):
	next_test = 40;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude39;

	if ^brief_sw then call ioa_ ("Test 39^-<scd_conflt>");

	call set_up_conds (1, "illegal_opcode", "", "");
	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call cpu_tests_$scd_con_flt;
	end;
	call prepare_segment (DELETE);

exclude39:
	if sel_flag then goto sel_loop;
	if next_test > last_test then go to done;

%page;
/*        TEST 40. xed_dirflt_even (xed on an even word bound executes the second instr
   of the op pair twice when a dir'd flt occurs on the second op.) */

test (40):
	next_test = 41;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude40;

	if ^brief_sw then call ioa_ ("Test 40^-<xed_dirflt_even>");

	call set_up_conds (1, "illegal_opcode", "", "PHAFPG174/175/934");
	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call prepare_segment (TRUNC_and_DEACT);
	     call cpu_tests_$xed_dirflt_even (tempseg_ptr (1));
	end;
	call prepare_segment (DELETE);

exclude40:
	if sel_flag then goto sel_loop;
	if next_test > last_test then go to done;
%page;


/*        TEST 41. xed_dirflt_odd (xed on an odd word bound skips the second instr
   of the op pair when a dir'd flt occurs on the first? op.) */

test (41):
	next_test = 42;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude41;

	if ^brief_sw then call ioa_ ("Test 41^-<xed_dirflt_odd>");

	call set_up_conds (1, "illegal_opcode", "", "PHAFPG174/175/934");
	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call prepare_segment (TRUNC_and_DEACT);
	     call cpu_tests_$xed_dirflt_odd (tempseg_ptr (1));
	end;
	call prepare_segment (DELETE);

exclude41:
	if sel_flag then goto sel_loop;
	if next_test > last_test then go to done;
%page;


/*        TEST 42. CMPC falsely sets the zero indicator if D2 takes a fault
   and has residue (MIF flag on), d2 (4'th fetch takes a fault).
   The level count on D2 does not get adjusted correctly on the SP&L */

test (42):
	next_test = 42;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude42;

	if ^brief_sw then call ioa_ ("Test 42^-<cmpc_adj_len>");

	call set_up_conds (1, "illegal_opcode", "", "");
	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call prepare_segment (TRUNC_and_DEACT);
	     call cpu_tests_$cmpc_adj_len (tempseg_ptr (1));
	end;
	call prepare_segment (DELETE);

exclude42:
	if sel_flag then goto sel_loop;
	if next_test > last_test then go to done;
%page;


/*        TEST 43. CMPC fails to set the zero indicator after returning from
   a page fault on d2. */

test (43):
	next_test = 44;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude43;

	if ^brief_sw then call ioa_ ("Test 43^-<cmpc_zero_ind>");

	call set_up_conds (1, "illegal_opcode", "", "PHAFPG192,193,194");
	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call prepare_segment (TRUNC_and_DEACT);
	     call cpu_tests_$cmpc_zero_ind (tempseg_ptr (1));
	end;
	call prepare_segment (DELETE);

exclude43:
	if sel_flag then goto sel_loop;
	if next_test > last_test then go to done;


%page;


/*        TEST 44. SCM fails to find the correct char (sets the tro and it
   should not  (simulate pl1 statment:
   index (collate (), aray_char (i));  */

test (44):
	next_test = 45;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude44;

	if ^brief_sw then call ioa_ ("Test 44^-<scm_tro>");

	call set_up_conds (1, "illegal_opcode", "", "");
	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */
	call prepare_segment (DEACT);			/* set it set up to deactivae before we use it */

          temp_data_size = 200;
	tempseg_ptr (1) -> temp_data = collate ();
	do CYCL = 1 to num_to_cycle;
	     call prepare_segment (DEACT);
	     call cpu_tests_$scm_tro (tempseg_ptr (1));
	end;
	call prepare_segment (DELETE);

exclude44:
	if sel_flag then goto sel_loop;
	if next_test > last_test then go to done;


%page;


/*        TEST 45. RPT at odd location fails after a page fault on a stz when crossing page bound */

test (45):
	next_test = 46;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude45;

	if ^brief_sw then call ioa_ ("Test 45^-<rpt_test_odd>");

	call set_up_conds (1, "lockup", "", "");
	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call prepare_segment (DEACT);
	     call cpu_tests_$rpt_test_odd (tempseg_ptr (1));
	end;
	call prepare_segment (DELETE);


exclude45:
	if sel_flag then goto sel_loop;
	if next_test > last_test then go to done;


%page;


/*        TEST 46. RPT at even location fails after a page fault on a stz when crossing page bound */

test (46):
	next_test = 47;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude46;

	if ^brief_sw then call ioa_ ("Test 46^-<rpt_test_evn>");

	call set_up_conds (1, "no_write_permission", "", "");
	num_temps = 1;				/* need one temp seg */
	call make_tempsegs;				/* make it */

	do CYCL = 1 to num_to_cycle;
	     call prepare_segment (DEACT);
	     call cpu_tests_$rpt_test_evn (tempseg_ptr (1));
	end;
	call prepare_segment (DELETE);


exclude46:
	if sel_flag then goto sel_loop;
	if next_test > last_test then go to done;



%page;


/*        TEST 47 scd_oob_tst. The SCD would fail if arg (d3) resided in a
   different segment than D1 or D2 AND there was no match, AND the scan ended
   a few words from the end of a 64K seg AND a seg fault was taken on the seg
   described by d3. This failed on a L68.
   The failure manifested itself by continuing the scan 'till the seg grew > 256K */

test (47):
	next_test = 48;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude47;

	if ^brief_sw then call ioa_ ("Test 47^-<scd_oob_tst>");

	call set_up_conds (2, "out_of_bounds,illegal_opcode", "", "PHAFPG192,193,194");

	num_temps = 2;				/* this test requires 2 temp_segs */
	call make_tempsegs;				/* make it */

	call hcs_$set_max_length_seg (tempseg_ptr (2), 1024 * 64, code);
						/* make max len 64k so mct will have a chance to capture pertinent info */
	call prepare_segment (DEACT);

	do CYCL = 1 to num_to_cycle;
	     call prepare_segment (DEACT);
	     call term_$refname ("scd_oob_tst", code);
	     call cpu_tests_$scd_oob_tst(tempseg_ptr (1), tempseg_ptr(2));
	end;
	call prepare_segment (DELETE);

exclude47:
	if sel_flag then goto sel_loop;
	if next_test > last_test then go to done;

%page;


/*    TEST 48 cmpb_onc.
      with the right magic numbers the cmpb will onc without the correct fix.
*/

test (48):
	next_test = 48+1;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude48;

	if ^brief_sw then call ioa_ ("Test 48^-<cmpb_onc>");

	call set_up_conds (2, "op_not_complete,illegal_opcode", "For DPS8M", "PHAOPD369");

	num_temps = 1;

	call make_tempsegs;				/* make it */
	call prepare_segment (DEACT);

/* setup the needed data using the magic numbers */

	temp_data_ptr = addrel(tempseg_ptr (1),1459);
	temp_data_size = 70;
	do i = 1 to temp_data_size;
	   temp_words(i) = "777777777777"b3;
	   end;
	

	do CYCL = 1 to num_to_cycle;
	     call prepare_segment (DEACT);
	     call cpu_tests_$cmpb_onc (tempseg_ptr (1));
	end;
	call prepare_segment (DELETE);

exclude48:
	if sel_flag then goto sel_loop;
	if next_test > last_test then go to done;

%page;


/*        TEST 49 cmpc_a.
          With the correct magic numbers and data a cmpc will not set 
	the indicators correctly
*/

test (49):
	next_test = 49+1;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude49;

	if ^brief_sw then call ioa_ ("Test 49^-<cmpc_a>");

	call set_up_conds (1, "illegal_opcode", "", "FPG194");

	num_temps = 1;

	call make_tempsegs;				/* make it */
	call prepare_segment (DEACT);

/*      use the correct magic numbers and data */
	temp_data_size = 253;
	temp_data_ptr = addrel(tempseg_ptr(1),4402);
	temp_data = "101";

	temp_data_size = 3921;
	temp_data_ptr = addrel(tempseg_ptr(1),254480);
	temp_data = "101";
	

	do CYCL = 1 to num_to_cycle;
	     call prepare_segment (DEACT);
	     call cpu_tests_$cmpc_a (tempseg_ptr (1));
	end;
	call prepare_segment (DELETE);

exclude49:
	if sel_flag then goto sel_loop;
	if next_test > last_test then go to done;

%page;


/*        TEST 50 cmpc_b.
          With the correct magic numbers and data a cmpc will not set 
	the indicators correctly. Very similar to test 49.
*/

test (50):
	next_test = 50+1;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude50;

	if ^brief_sw then call ioa_ ("Test 50^-<cmpc_b>");

	call set_up_conds (1, "illegal_opcode", "", "FPG195,FPD358");

	num_temps = 1;

	call make_tempsegs;				/* make it */
	call prepare_segment (DEACT);

/*      use the correct magic numbers and data */
	temp_data_size = 253;
	temp_data_ptr = addrel(tempseg_ptr(1),4402);
	temp_data = "102";

	temp_data_size = 3921;
	temp_data_ptr = addrel(tempseg_ptr(1),254670);
	temp_data = "102";
	

	do CYCL = 1 to num_to_cycle;
	     call prepare_segment (DEACT);
	     call cpu_tests_$cmpc_b (tempseg_ptr (1));
	end;
	call prepare_segment (DELETE);

exclude50:
	if sel_flag then goto sel_loop;
	if next_test > last_test then go to done;

%page;


/*        TEST 51 sreg_no_write.
          If an sreg at page bound -2 the PSR segment number will be used
	instead of the TRS if fix not installed.
	Test  sreg_no_write dose not use a temp seg.
*/

test (51):
	next_test = 51+1;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude51;

	if ^brief_sw then call ioa_ ("Test 51^-<sreg_no_write>");

	call set_up_conds (1, "no_write_permission", "", "FPD312");

	do CYCL = 1 to num_to_cycle;
	     call cpu_tests_$sreg_no_write;
	end;

exclude51:
	if sel_flag then goto sel_loop;
	if next_test > last_test then go to done;

%page;


/*        TEST 52 tnz.
          Without fix a tnz at page bound -1 will not work
*/

test (52):
	next_test = 52+1;
	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude52;

	if ^brief_sw then call ioa_ ("Test 52^-<tnz>");

	call set_up_conds (1, "illegal_opcode", "", "FPD354");

	num_temps = 1;

	call make_tempsegs;				/* make it */
	call prepare_segment (DEACT);

	do CYCL = 1 to num_to_cycle;
	     call prepare_segment (DEACT);
	     call cpu_tests_$tnz (tempseg_ptr (1));
	end;
	call prepare_segment (DELETE);

exclude52:
	if sel_flag then goto sel_loop;
	if next_test > last_test then go to done;
%page;

/* END OF TESTS */
%page;
/*****************************************************************************/
/*  This is an example for adding test cases			       */
/*							       */
/*        TEST XX TEST_NAME.					       */
/*	What it tries to test if known.			       */
/*							       */
/*****************************************************************************/
/*
test (XX):
	next_test = XX+1;

 "**** exclude this test? **** "
	if excl_list (next_test - 1) = next_test - 1 then go to excludeXX;

	if ^brief_sw then call ioa_ ("Test XX^-<TEST_NAME>");

	call set_up_conds (NUM_OF_COND, "LIST_OF_COND", "", "FCO_LIST");

	num_temps = NUMBER_OF_TEMPSEGS;

	call make_tempsegs;			" **** make it **** "
	call prepare_segment (ACTION);

 " *****  any special data is placed here ***** "

	do CYCL = 1 to num_to_cycle;
	     call prepare_segment (ACTION);
	     call cpu_tests_$TEST_NAME (ARGLIST);
	end;
	call prepare_segment (DELETE);

excludeXX:
	if sel_flag then goto sel_loop;
	if next_test > last_test then go to done;
*/
%page;


/* This procedure creates the temp seg(s) to be used by all test cases and set up for deactivation. */

make_tempsegs:
     proc;

dcl  i fixed bin;


	do i = 1 to num_temps;
	     STR = ltrim (rtrim (char (i)));
	     call hcs_$make_seg ("", "testcpu_tempseg_" || STR, "testcpu_tempseg_" || STR, 1111b, tempseg_ptr (i), code)
		;

	     if tempseg_ptr (i) = null () then do;

notempseg:
		call com_err_ (code, "test_cpu", "Cannot get ptr to temporary segment.");
		return;
		end;

	     unspec (akst) = "0"b;			/* set up KST so we can deactivate the tempseg */
	     akst.set.explicit_deactivate_ok, akst.value.explicit_deactivate_ok = "1"b;

	     on no_read_permission
		begin;
link_err:
		     call com_err_ (0, (myname), "test_cpu requires access to >sl1>phcs_.");
		     go to done;
		end;

	     call phcs_$set_kst_attributes (fixed (baseno (tempseg_ptr (i)), 17), addr (akst), code);
						/* now set permissions */

	     revert no_read_permission;

	     call phcs_$deactivate (tempseg_ptr (i), code);
						/* do it now before its touched */
	     if code ^= 0 then do;			/* just quit */
		call com_err_ (code, myname, "Call to deactivate failed.");
		return;
		end;

	end;
	return;
     end;


%page;
prepare_segment:
     proc (operation);

dcl  operation fixed bin;
dcl  idx fixed bin;

	go to OP (operation);

OP (1):						/* truncate & deactivate */
	do idx = 1 to num_temps;
	     call hcs_$truncate_seg (tempseg_ptr (idx), 0, code);
	     if code ^= 0 then do;			/* just quit */
		call com_err_ (code, myname, "Call to truncate failed.");
		return;
		end;

	     call phcs_$deactivate (tempseg_ptr (idx), code);
						/* do it now before its touched */
	     if code ^= 0 then do;			/* just quit */
		call com_err_ (code, myname, "Call to deactivate failed.");
		return;
		end;
	end;

	return;

OP (2):						/* delete */
	do idx = 1 to num_temps;
	     call delete_$ptr (tempseg_ptr (idx), "100101"b, "test_cpu", code);
	end;
	return;

OP (3):						/* truncate only */
	do idx = 1 to num_temps;
	     call hcs_$truncate_seg (tempseg_ptr (idx), 0, code);
	end;
	return;

OP (4):						/* deactivate only */
	do idx = 1 to num_temps;
	     call phcs_$deactivate (tempseg_ptr (idx), code);

	     if code ^= 0 then do;			/* just quit */
		call com_err_ (code, myname, "Call to deactivate failed.");
		return;
		end;
	end;
	return;

     end prepare_segment;


%page;

/* This routine is used by those test cases that need to deactivate the temp seg */

test_cpu$deactivate_tempseg:
     entry;

dcl  idx fixed bin;


	do idx = 1 to num_temps;
	     call phcs_$deactivate (tempseg_ptr (idx), code);
						/* do it now before its touched */
	     if code ^= 0 then do;			/* just quit */
		call com_err_ (code, myname, "Call to deactivate failed.");
		return;
		end;
	end;

	return;

%page;
done:
	call CLEANUP;

	return;

CLEANUP:
     proc;
dcl  idx fixed bin;

	if mvtr_sw then /* if mvt release switch set go release temp segs */ call cpu_tests_$mvt_tst_release_t_segs;

	do idx = 1 to 3;
	     if tempseg_ptr (idx) ^= null then call delete_$ptr (tempseg_ptr (idx), "100101"b, "test_cpu", code);
	end;

	if ^hreg_state then /* leave hreg state the way it was */ call hcs_$history_regs_set ("0"b);
	return;

     end CLEANUP;
%page;
display_mc:
     proc;

	call cu_$stack_frame_ptr (stackp);		/* get current sstack ptr */
	faultsp = find_condition_frame_ (stackp);	/* is this the cond frame ? */
	if faultsp = null () then do;
	     call ioa_ ("^a: Cannot find condition frame.", myname);
	     return;
	     end;

	call find_condition_info_ (faultsp, addr (cond_info), code);
	if cond_info.mcptr = null () then return;

	if ^mc_sw then go to HREGS;
	call ioa_ ("^/MACHINE CONDITIONS AT ^p:^/", cond_info.mcptr);
	call dump_machine_cond_ (addr (cond_info), faultsp, "user_output", 2);
						/* print the MC */

HREGS:
	if ^h_sw then return;
	if mcptr ^= null then hreg_ptr = addrel (mcptr, 96);
	if hreg_ptr = null then do;			/* no history regs to dump */
	     call ioa_ ("History Registers are not available");
	     return;
	     end;
	else do;
	     call ioa_ ("CPU HISTORY REGISTERS AT TIME OF FAULT");
	     call hran_$hranl (hreg_ptr, null, long_sw);
	     end;

	return;
     end display_mc;
%page;

/* This procedure will establish the number of, and type of conditions
   expected for each test case and any additional info that may be helpful
   to a user when a test case fails, including FCO(s) that may be required. */

set_up_conds:
     proc (num_to_expect, conds, add_info, fco_info);

dcl  (num_to_expect, idx, start_idx, end_idx) fixed bin;
dcl  (conds, add_info, fco_info) char (256) var;

	num_expected_cond = num_to_expect;
	start_idx = 1;				/* init for first pass */
	do idx = 1 to num_to_expect;
	     end_idx = index (substr (conds, start_idx), ",");

	     if end_idx ^= 0 then			/* not the last condition name */
		expected_condition (idx) = substr (conds, start_idx, end_idx - 1);
	     else expected_condition (idx) = substr (conds, start_idx, (length (conds) - start_idx + 1));
	     start_idx = end_idx + start_idx;
	end;

	pertinent_info = add_info;
	if fco_info ^= "" then
	     FCO_required = "FCO(s) " || fco_info || " MUST be installed for this test to run sucessfully.";
	else FCO_required = "";
	return;

     end set_up_conds;

     end test_cpu;
