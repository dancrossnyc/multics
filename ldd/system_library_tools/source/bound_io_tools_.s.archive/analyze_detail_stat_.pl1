/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

/* format: style4,delnl,insnl,ifthenstmt,indnoniterend */

analyze_detail_stat_:
     proc (dev_name, iom_stats, det_stats, auto_analp, code);

/*  Completed for installation May, 1981 by Rich Coppola */
/*  Modified Apr 12, 1982 by Rich Coppola to add support for STC tape drives and
   PR54 */
/* Modified September 1982 by C. Hornig for new PRPH TAP config card. */
/*  Modified Oct 1982 by Rich Coppola to fix bugs in initialization of variables
   used by the rs and rsnnl entries and in their return.  Also added code to
   decode byte 10 and 11 of disk detail status now that all of it is available.
   The calling sequence to the rs and rsnnl had to be changed by the way.

   Modified Oct 1983 by Paul Farley to change tape analysis to conform to
   io_log_status_info.cds. Also changed tracks_in_error to be sorted by track.
   Modified Feb. 1985 by Paul Farley to check for null ptrs from find_config_card_.
   Modified June 1985 by Paul Farley to handle FIPS tape & disk, and
   to handle PR54 if it is configed as a PR71. Also removed support of DSU190(A&B).
*/
/****^  HISTORY COMMENTS:
  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
     audit(86-02-18,Coppola), install(86-03-21,MR12.0-1033):
     Support FIPS.
  2) change(86-08-05,Farley), approve(86-08-05,MCR6979),
     audit(86-08-08,Fawcett), install(86-08-18,MR12.0-1125):
     Post bug fix to look for an IPC card instead of a FIPS card.
                                                   END HISTORY COMMENTS */

dcl  iom_stats bit (36) aligned,
     dev_name char (*),				/* the name of the device */
     det_stats bit (*) unal,
     auto_analp ptr,
     message char (256) var,				/* return STR for rs and rsnnl entries */
     is_interesting bit (1),
     code fixed bin (35);

/* External */

dcl  config_deck$ ext;
dcl  hcs_$fs_get_mode entry (ptr, fixed bin (5), fixed bin (35));
dcl  hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
dcl  error_table_$no_r_permission fixed bin (35) ext static;
dcl  error_table_$resource_unknown fixed bin (35) ext static;
dcl  error_table_$resource_type_inappropriate fixed bin (35) ext static;
dcl  error_table_$unimplemented_version fixed bin (35) ext static;
dcl  error_table_$bad_arg fixed bin (35) ext static;
dcl  error_table_$request_not_recognized fixed bin (35) ext static;
dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
dcl  ioa_$rsnnl entry () options (variable);
dcl  config_$find entry (char (4) aligned, ptr);
dcl  config_$find_periph entry (char (4) aligned, ptr);

dcl  1 status aligned based (statp),
       2 stat_pad bit (2) unal,
       2 stat_maj bit (4) unal,
       2 stat_min bit (6) unal,
       2 stat_pad1 bit (4) unal,
       2 stat_init bit (1) unal,
       2 stat_pad2 bit (1) unal,
       2 stat_chan bit (3) unal,
       2 stat_cent bit (3) unal,
       2 stat_pad3 bit (48) unal;


dcl  statp ptr;

dcl  (i, j) fixed bin;
dcl  name char (7) var;
dcl  a_is_interesting bit (1) init ("0"b);		/* det. stat has data of import */
dcl  fips_controller bit (1);
dcl  (number_analyzed, anlzd) fixed bin;		/* number of bits analyzed */
dcl  mode fixed bin (5);
dcl  ret_str char (20) var init ("");			/* return string for ioa_$rsnnl */

dcl  1 a_tape_analysis,
       2 mth_model char (8),
       2 num_tracks fixed bin,
       2 trks_in_err char (18),
       2 dbie_array (9) fixed bin,
       2 modes,
         3 density fixed bin,
         3 operation char (6) var,			/* write/read/rew */
       2 anal (50) char (65) var;

dcl  1 a_disk_analysis,
       2 dsk_model char (7) var,
       2 CA fixed bin,
       2 PORT fixed bin,
       2 analyses (50) char (50) var;

dcl  1 a_prt_analysis,
       2 prt_model char (7) var,
       2 density char (6),				/* 6/8 lpi */
       2 analyses (50) char (40) var;

dcl  1 a_rdr_pun_analysis,
       2 rdr_pun_model char (6),
       2 analyses (60) char (40) var;

dcl  (rs_sw, rsnnl_sw) bit (1) init ("0"b);
dcl  xcode fixed bin (35);
dcl  NEW_LINE char (1) internal static options (constant) init ("
");
dcl  (addr, bin, bool, char, fixed, hbound, ltrim, rtrim, substr, null, bit) builtin;

%page;
	auto_analp = null ();
	go to START;				/* bypass rs and rsnnl entries */


analyze_detail_stat_$rsnnl:
     entry (dev_name, iom_stats, det_stats, message, is_interesting, code);

	rsnnl_sw = "1"b;
	go to START;

analyze_detail_stat_$rs:
     entry (dev_name, iom_stats, det_stats, message, is_interesting, code);

	rs_sw = "1"b;

START:
	number_analyzed, code = 0;			/* initialize */
	a_is_interesting = "0"b;

	if (rs_sw | rsnnl_sw) then do;
	     is_interesting = "0"b;
	     message = "";
	     end;


	if iom_stats = "0"b then do;			/* validate iom status */
	     code = error_table_$bad_arg;
	     return;
	     end;

	if det_stats = "0"b then do;			/* and detail status */
	     code = error_table_$bad_arg;
	     return;
	     end;


/* check callers access to the config_deck, without it can do nothing for him */


	call hcs_$fs_get_mode (addr (config_deck$), mode, code);
	if code ^= 0 then return;
	if (bit (mode) & bit (R_ACCESS_BIN)) ^= bit (R_ACCESS_BIN) then do;
	     code = error_table_$no_r_permission;
	     return;
	     end;


	name = dev_name;

	if substr (name, 1, 3) = "tap" then call anal_tape_;

	else if substr (name, 1, 3) = "dsk" then call anal_disk_;

	else if substr (name, 1, 3) = "prt" then call anal_prt_;

	else if substr (name, 1, 3) = "rdr" then call anal_rdr_pun;

	else if substr (name, 1, 3) = "pun" then call anal_rdr_pun;



	else do;
	     code = error_table_$resource_type_inappropriate;
	     return;
	     end;

	return;

%page;
anal_disk_:
     proc;

dcl  dev_no fixed bin (35);
dcl  dev_model fixed bin;
dcl  dev_no_index fixed bin;
dcl  temp_dsk_det_stats bit (47) init ("0"b);

dcl  trans_table_dsu451 (29) char (45) varying int static options (constant)
	init ("DLI Fault. ", "Device Protected. ", "Device Fault. ", "In Diagnostic Mode. ", "Command Parity Error. ",
	"Invalid Command. ", "Invalid Command Sequence. ", "State Violation. ", "Protect Violation. ",
	"Transfer Timing Error. ", "Data Parity Error. ", "Loss of Write Current. ",
	"Write Current & NO Write Command. ", "Loss of AC Write Current. ", "No or Multiple Head Select. ",
	"Spindle Speed Loss. ", "DC Power Loss. ", "Seek Incomplete. ", "Positioner Overtravel. ", "RPS Error. ",
	"1st Seek Cycle Incomplete. ", "Loss of Cooling. ", "Heads Retracted. ", "Positioner Offset. ",
	"Read Clock Offset. ", "Write AND Read Set. ", "Fine Servo. ", "Forward FF Set. ", "Reverse FF Set. ");


dcl  trans_table_dsu5xx (25) char (45) varying int static options (constant)
	init ("DLI Fault. ", "Device Protected. ", "Device Fault. ", "In Diagnostic Mode. ", "Command Parity Error. ",
	"Invalid Command. ", "Invalid Command Sequence. ", "State Violation. ", "Protect Violation. ",
	"Transfer Timing Error. ", "Data Parity Error. ", "Loss of Write Current. ",
	"Write Current & NO Write Command. ", "Loss of AC Write Current. ", "No or Multiple Head Select. ",
	"Spindle Speed Loss. ", "Seek Incomplete. ", "RPS Error. ", "Servo off Track. ", "Access Check. ",
	"Pack Unsafe. ", "Index Check. ", "Read AND Write Check. ", "Inhibit HDA Cycle. ", "HDA Sequence Check. ");


	a_disk_analysis.dsk_model = "";
	a_disk_analysis.CA = fixed (substr (det_stats, 80, 1), 1);
	a_disk_analysis.PORT = fixed (substr (det_stats, 84, 5), 5);
	a_disk_analysis.analyses (*) = "";
	anlzd = 0;
	statp = addr (iom_stats);
	temp_dsk_det_stats = "0"b;
	dev_no = cv_dec_check_ (substr (name, 6, 2), code);
						/* will need drive no. later */


/* Check iom status to see if detail status is worth analyzing */

	if stat_maj = "1101"b |			/* MPC cmd rej */
	     stat_maj = "0101"b |			/* dev cmd rej */
	     stat_maj = "0100"b |			/* EOFs */
	     stat_maj = "0001"b |			/* dev busy */
	     stat_maj = "0000"b then do;		/* Ready */

/* detail status is either not available or not worthy of analysis, return */


	     anlzd = 0;
	     code = error_table_$request_not_recognized;
	     return;
	     end;


/* Now determine the model of the drive  */


	dev_no_index, dev_model = 0;
	prph_dsk_cardp = null ();
	call config_$find_periph (substr (name, 1, 4), prph_dsk_cardp);
	if prph_dsk_cardp = null () then do;
	     code = error_table_$resource_unknown;
	     return;
	     end;

	call find_controller (prph_dsk_card.iom, prph_dsk_card.chan);
	if mpc_cardp = null () & ipc_cardp = null () then return;
						/* not MPC/FIPS driven */
	do j = 1 to 5 while (dev_model = 0);
	     dev_no_index = dev_no_index + prph_dsk_card.ndrives (j);
	     if dev_no < dev_no_index | (^fips_controller & dev_no = dev_no_index)
	     then dev_model = prph_dsk_card.model (j);
	end;

	if fips_controller then do;			/* handle fips differently */
	     call anal_fips_disk_;
	     goto fill_dsk_struct;
	     end;

	if dev_model = 450 | dev_model = 451
	then					/* go do it */
	     go to type_451;

	else if dev_model = 500 | dev_model = 501 then go to type_5xx;


/* If none of the above, then device type is unknown, therefore... */


	code = error_table_$resource_type_inappropriate;
	return;

type_451:
	a_disk_analysis.dsk_model = "DSU451";


/* set up to look at interesting bits only */

	substr (temp_dsk_det_stats, 1, 5) = substr (det_stats, 5, 5);
	substr (temp_dsk_det_stats, 6, 10) = substr (det_stats, 11, 10);
	substr (temp_dsk_det_stats, 16, 1) = substr (det_stats, 22, 1);
	substr (temp_dsk_det_stats, 17, 3) = substr (det_stats, 24, 3);
	substr (temp_dsk_det_stats, 20, 1) = substr (det_stats, 29, 1);
	substr (temp_dsk_det_stats, 21, 1) = substr (det_stats, 36, 1);
	substr (temp_dsk_det_stats, 22, 1) = substr (det_stats, 38, 1);
	substr (temp_dsk_det_stats, 23, 4) = substr (det_stats, 45, 4);
	substr (temp_dsk_det_stats, 27, 1) = substr (det_stats, 33, 1);
	substr (temp_dsk_det_stats, 28, 2) = substr (det_stats, 39, 2);


	do i = 1 to 29;
	     if substr (temp_dsk_det_stats, i, 1) then do;
		anlzd = anlzd + 1;
		a_disk_analysis.analyses (anlzd) = trans_table_dsu451 (i);
		a_is_interesting = "1"b;
		end;
	end;


	if (stat_maj ^= "0010"b)
	then if (substr (det_stats, 4, 1) & substr (det_stats, 33, 1)) then do;
		anlzd = anlzd + 1;
		a_disk_analysis.analyses (anlzd) = "Positioner busy AND data Xfer.";

		anlzd = anlzd + 1;
		a_disk_analysis.analyses (anlzd) = "(POSSIBLE actuator problem).";
		a_is_interesting = "1"b;
		end;


	go to fill_dsk_struct;

type_5xx:
	a_disk_analysis.dsk_model = "MSU" || ltrim (char (dev_model));

	substr (temp_dsk_det_stats, 1, 5) = substr (det_stats, 5, 5);
	substr (temp_dsk_det_stats, 6, 10) = substr (det_stats, 11, 10);
	substr (temp_dsk_det_stats, 16, 1) = substr (det_stats, 22, 1);
	substr (temp_dsk_det_stats, 17, 1) = substr (det_stats, 25, 1);
	substr (temp_dsk_det_stats, 18, 1) = substr (det_stats, 29, 1);
	substr (temp_dsk_det_stats, 19, 4) = substr (det_stats, 33, 4);
	substr (temp_dsk_det_stats, 23, 1) = substr (det_stats, 40, 1);
	substr (temp_dsk_det_stats, 24, 2) = substr (det_stats, 55, 2);


	do i = 1 to 25;
	     if substr (temp_dsk_det_stats, i, 1) then do;
		anlzd = anlzd + 1;
		a_disk_analysis.analyses (anlzd) = trans_table_dsu5xx (i);
		a_is_interesting = "1"b;
		end;
	end;

	go to fill_dsk_struct;


fill_dsk_struct:
	number_analyzed = anlzd;


	if (^rs_sw & ^rsnnl_sw) then do;
	     call hcs_$make_seg ("", "analyze_detail_stat_.temp", "", 10, disk_analp, xcode);
	     auto_analp = disk_analp;
	     disk_analysis.disk_analysis_version = analyze_det_stat_info_version_2;
	     disk_analysis.num_analyzed = anlzd;
	     disk_analysis.dsk_model = a_disk_analysis.dsk_model;
	     disk_analysis.is_interesting_disk = a_is_interesting;
	     disk_analysis.fips_controller = fips_controller;
	     disk_analysis.pad = ""b;
	     disk_analysis.CA = a_disk_analysis.CA;
	     disk_analysis.PORT = a_disk_analysis.PORT;


	     if number_analyzed > 0
	     then do j = 1 to number_analyzed;
		disk_analysis.analyses (j) = a_disk_analysis.analyses (j);
	     end;

	     else disk_analysis.analyses (*) = "";

	     return;
	     end;

	if (rsnnl_sw | rs_sw) then do;
	     if fips_controller
	     then ret_str = "";
	     else call ioa_$rsnnl ("[CA ^1o, Port ^2d]", ret_str, 15, a_disk_analysis.CA, a_disk_analysis.PORT);
	     do j = 1 to number_analyzed;
		message = message || a_disk_analysis.analyses (j);
	     end;
	     message = message || ret_str;
	     if message ^= "" then do;
		if rs_sw then message = message || NEW_LINE;
		is_interesting = a_is_interesting;
		end;
	     else is_interesting = "0"b;
	     end;
	return;
%page;
anal_fips_disk_:
	proc;

dcl  (format_type, message_no) fixed bin;
dcl  symptom_code bit (16);
dcl  trans_tbl (16) char (50) varying int static options (constant) init
						/* misc compacted bits */
	("Command Reject ", "Intervention Required ", "Bus Out Parity Error ", "Equipment Check ", "Data Check ",
	"Overrun ", "Permanent Error ", "Invalid Track Format ", "End of Cylinder ", "No Record Found ",
	"File Protected ", "Write Inhibited ", "Correctable Error ", "Intent Violation ", "Imprecise Ending ",
	"Write Op ");

dcl  format_0_type1_tbl (0:15) char (50) varying int static options (constant) init
						/* program or system checks (byte1,bit3=0) */
	("", "Invalid Command ", "Invalid Command Seq. ", "CCW Count Error ", "Invalid Data Arg ",
	"Diagnostic Command Error ", "Retry status w/o chaining ", "Command Mis-match after Retry ", "", "", "",
	"Def/Alt Track pointing at self ", "Path Select/Device installation Check ", "", "", "");

dcl  format_0_type2_tbl (0:15) char (50) varying int static options (constant) init
						/* program or system checks (byte1,bit3=1) */
	("", "Sense Data Logged for Device ", "Sense Data Logged for Controller ", (13) (""));

dcl  format_1_tbl (0:15) char (50) varying int static options (constant) init
						/* device equipment check */
	("", "Device status 1 was not as expected ", "", "Index was missing ", "Unresettable Interrupt ",
	"Device did not respond to Selection ", "Drive check 2 or Set Sector Incomplete ", "Head Address Miscompare ",
	"Invalid Device Status 1 ", "Device Not Ready ", "Track Physical Address Miscompare ", "",
	"Drive Motor Switch was OFF ", "Seek Incomplete ", "Cylinder Adress Miscompare ", "Unresettable Offset Active ")
	;

dcl  format_2_tbl (0:15) char (50) varying int static options (constant) init
						/* storage director equipment check */
	((9) (""), "Selective Reset while Drive Selected ", "Failed to Latch the First Sync In Line ", "",
	"No Channel Response on a Selective Reset Request ", "", "", "Microcode Detected Error ");

dcl  format_3_tbl (0:15) char (50) varying int static options (constant) init
						/* storage director control check */
	((8) (""), "Clock Stopped Check 1 ", "Channel Check 1 or Storage Director Timeout ",
	"Trace Table saved in this Storage Director ", "", "", "", "", "");

dcl  format_4_tbl (0:15) char (50) varying int static options (constant) init
						/* data check w/o displacement info */
	("Uncorrectable Error in Home Addr ", "Uncorrectable Error in Count Area ", "Uncorrectable Error in Key Area ",
	"Uncorrectable Error in Data Area ", "Unsuccessful Sync on Home Addr ", "Unsuccessful Sync on Count Area ",
	"Unsuccessful Sync on Key Area ", "Unsuccessful Sync on Data Area ",
	"Uncorrectable Error in Home Addr(offset active) ", "Uncorrectable Error in Count Area(offset active) ",
	"Uncorrectable Error in Key Area(offset active) ", "Uncorrectable Error in Data Area(offset active) ",
	"Unsuccessful Sync on Home Addr(offset active) ", "Unsuccessful Sync on Count Area(offset active) ",
	"Unsuccessful Sync on Key Area(offset active) ", "Unsuccessful Sync on Data Area(offset active) ");

dcl  format_5_tbl (0:15) char (50) varying int static options (constant) init
						/* data check with displacement info */
	("Correctable Error in Home Address ", "Correctable Error in Count Area ", "Correctable Error in Key Area ",
	"Correctable Error in Data Area ", (4) (""), "Correctable Error in Home Address(offset active) ",
	"Correctable Error in Count Area(offset active) ", "Correctable Error in Key Area(offset active) ",
	"Correctable Error in Data Area(offset active) ", (4) (""));

dcl  format_6_tbl (0:15) char (50) varying int static options (constant) init
						/* usage statistics/overrun errors */
	((8) (""), "Channel A overrun ", "Channel B overrun ", "Channel C overrun ", "Channel D overrun ",
	"Channel E overrun ", "Channel F overrun ", "Channel G overrun ", "Channel H overrun ");

dcl  format_7_tbl (0:15) char (50) varying int static options (constant) init
						/* SD-to-controller path or controller check */
	("RCC Initiated by a CCA ", "Unsuccessful RCC1 sequence ", "Unsuccessful RCC1 and RCC2 sequence ",
	"Invalid DDC Tag Sequence ", "Extra RCC Required ", "Invalid DDC selection Response or Timeout ",
	"Missing End Op Transfer was Complete ", "Missing End Op Transfer was Incomplete ",
	"Invalid Tag In on Immediate Command ", "Invalid Tag In for Extended Command Sequence ", "Deselection Timeout ",
	"No Controller Response after Poll Interrupt ", "Controller Not Available ",
	"Controller Not Available on Disconnected Chain ", "", "");

dcl  format_8_tbl (0:15) char (50) varying int static options (constant) init
						/* Controller Equipment check */
	("", "ECC Hardware Failure ", "", "Unexpected End Op Response code Received ",
	"End Op Active with Transfer Count > 0 ", "End Op Active with Transfer Count = 0 ",
	"Controller Stopped The Path Selection Cleanup ", "DPS array conot be Initialized ",
	"Short Busy timeout during Device Selection ", "Controller failed to set/reset long-term Busy ", (6) (""));

	     if dev_model = 3380
	     then a_disk_analysis.dsk_model = "IBM3380";
	     else a_disk_analysis.dsk_model = "IBM3390";
	     a_disk_analysis.CA, a_disk_analysis.PORT = 0;
	     substr (temp_dsk_det_stats, 1, 6) = substr (det_stats, 1, 6);
	     substr (temp_dsk_det_stats, 7, 3) = substr (det_stats, 9, 3);
	     substr (temp_dsk_det_stats, 10, 3) = substr (det_stats, 13, 3);
	     substr (temp_dsk_det_stats, 13, 1) = substr (det_stats, 18, 1);
	     substr (temp_dsk_det_stats, 14, 3) = substr (det_stats, 21, 3);

	     do i = 1 to 16;
		if substr (temp_dsk_det_stats, i, 1) then do;
		     anlzd = anlzd + 1;
		     a_disk_analysis.analyses (anlzd) = trans_tbl (i);
		     a_is_interesting = "1"b;
		     end;
	     end;

	     anlzd = anlzd + 1;
	     a_disk_analysis.analyses (anlzd) = "";
	     a_is_interesting = "1"b;
	     format_type = bin (substr (det_stats, 57, 4), 4);
	     message_no = bin (substr (det_stats, 61, 4), 4);

	     if format_type = 0 then do;
		if ^substr (det_stats, 12, 1)
		then a_disk_analysis.analyses (anlzd) = format_0_type1_tbl (message_no);
		else a_disk_analysis.analyses (anlzd) = format_0_type2_tbl (message_no);
		end;
	     else if format_type = 1 then a_disk_analysis.analyses (anlzd) = format_1_tbl (message_no);
	     else if format_type = 2 then a_disk_analysis.analyses (anlzd) = format_2_tbl (message_no);
	     else if format_type = 3 then a_disk_analysis.analyses (anlzd) = format_3_tbl (message_no);
	     else if format_type = 4 then a_disk_analysis.analyses (anlzd) = format_4_tbl (message_no);
	     else if format_type = 5 then a_disk_analysis.analyses (anlzd) = format_5_tbl (message_no);
	     else if format_type = 6 then a_disk_analysis.analyses (anlzd) = format_6_tbl (message_no);
	     else if format_type = 7 then a_disk_analysis.analyses (anlzd) = format_7_tbl (message_no);
	     else if format_type = 8 then a_disk_analysis.analyses (anlzd) = format_8_tbl (message_no);

	     if a_disk_analysis.analyses (anlzd) = "" then do;
						/* no message */
		anlzd = anlzd - 1;
		if anlzd = 0 then a_is_interesting = "0"b;
						/* nothing interesting */
		end;

	     if a_is_interesting & (format_type ^= 5 & format_type ^= 6) then do;
		symptom_code = substr (det_stats, 177, 16);
						/* bytes 22 & 23 */
		if symptom_code ^= ""b then do;
		     anlzd = anlzd + 1;
		     call ioa_$rsnnl ("Symptom_code=^4.4b ", a_disk_analysis.analyses (anlzd), 18, symptom_code);
		     end;
		end;
	     return;
	end anal_fips_disk_;
     end anal_disk_;

%page;


anal_prt_:
     proc;

dcl  ptr_model fixed bin;
dcl  DENSITY (2) char (6) int static options (constant) init ("6 lpi.", "8 lpi.");
dcl  temp_prt_det_stat bit (44) init ("0"b);
dcl  (msg_indx, bysc) fixed bin;
dcl  ec_sc_bit bit (10) init ("0"b);
dcl  pr71_index fixed bin;


dcl  trans_table_prt (40) char (36) var int static options (constant) init
						/* for pr71 */
	("Print Check. ", "Belt Sync Error. ", "Scanning register Error. ", "LNS Delay Error. ",
	"DAI Data Parity Error. ", "Bad PLB Address Increment. ", "PLB Parity Error. ",
	"Non-printable Character in PLB. ", "Fire Hammer Register Error. ", "Invalid PLB Address. ",
	"Image Belt Buffer Parity Error. ", "Image Belt Address Error. ", "Invalid Image Belt Buffer Address. ",
	"Space Line Error. ", "Sync Error. ", "Tractors Not Engaged. ", "Belt gate Open. ", "Broken Finger on Belt. ",
	"Vertical Belt Position. ", "Ribbon Error. ", "Skew Error. ", "Stacker Error. ", "Phase Failure Alert. ",
	"DC Alert. ", "Thermal Alert. ", "Skip Supply Alert. ", "Print Supply Alert. ", "Paper Failure. ",
	"Paper Runaway. ", "Emergency Off. ", "Skip Overcurrent. ", "Finger Sensor Failure. ", "Finger Sensor Dirty. ",
	"Airflow Check. ", "AC Overcurrent. ", "Multiple Echo Check Error. ", "Echo Check Error. ",
	"Short Circuit Error No. 2. ", "Short Circuit Error No. 1. ", "Short Circuit Error No. 1 and 2. ");


dcl  col_trans_136 (1:9, 0:15) char (35) var int static options (constant) init
						/* for pr71 */
	("Bad Decode. ", "Col. 04, Hammer Driver Card 04. ", "Bad Decode. ", "Bad Decode. ",
	"Col. 05, Hammer Driver Card 04. ", "Bad Decode. ", "Bad Decode. ", "Col. 06, Hammer Driver Card 04. ",
	"Col. 01, Hammer Driver Card 04. ", "Bad Decode. ", "Col. 07, Hammer Driver Card 04. ",
	"Col. 02, Hammer Driver Card 04. ", "Bad Decode. ", "Col. 08, Hammer Driver Card 04. ",
	"Col. 03, Hammer Driver Card 04. ", "Bad Decode. ", "Col. 09, Hammer Driver Card 05. ",
	"Col. 20, Hammer Driver Card 06. ", "Col. 15, Hammer Driver Card 05. ", "Col. 10, Hammer Driver Card 05. ",
	"Col. 21, Hammer Driver Card 06. ", "Col. 16, Hammer Driver Card 05. ", "Col. 11, Hammer Driver Card 05. ",
	"Col. 22, Hammer Driver Card 06. ", "Col. 17, Hammer Driver Card 06. ", "Col. 12, Hammer Driver Card 05. ",
	"Col. 23, Hammer Driver Card 06. ", "Col. 18, Hammer Driver Card 06. ", "Col. 13, Hammer Driver Card 05. ",
	"Col. 24, Hammer Driver Card 06. ", "Col. 19, Hammer Driver Card 06. ", "Col. 14, Hammer Driver Card 05. ",
	"Col. 25, Hammer Driver Card 07. ", "Col. 36, Hammer Driver Card 08. ", "Col. 31, Hammer Driver Card 07. ",
	"Col. 26, Hammer Driver Card 07. ", "Col. 37, Hammer Driver Card 08. ", "Col. 32, Hammer Driver Card 07. ",
	"Col. 27, Hammer Driver Card 07. ", "Col. 38, Hammer Driver Card 08. ", "Col. 33, Hammer Driver Card 08. ",
	"Col. 28, Hammer Driver Card 07. ", "Col. 39, Hammer Driver Card 08. ", "Col. 34, Hammer Driver Card 08. ",
	"Col. 29, Hammer Driver Card 07. ", "Col. 40, Hammer Driver Card 08. ", "Col. 35, Hammer Driver Card 08. ",
	"Col. 30, Hammer Driver Card 07. ", "Col. 41, Hammer Driver Card 09. ", "Col. 52, Hammer Driver Card 10. ",
	"Col. 47, Hammer Driver Card 09. ", "Col. 42, Hammer Driver Card 09. ", "Col. 53, Hammer Driver Card 10. ",
	"Col. 48, Hammer Driver Card 09. ", "Col. 43, Hammer Driver Card 09. ", "Col. 54, Hammer Driver Card 10. ",
	"Col. 49, Hammer Driver Card 10. ", "Col. 44, Hammer Driver Card 09. ", "Col. 55, Hammer Driver Card 10. ",
	"Col. 50, Hammer Driver Card 10. ", "Col. 45, Hammer Driver Card 09. ", "Col. 56, Hammer Driver Card 10. ",
	"Col. 51, Hammer Driver Card 10. ", "Col. 46, Hammer Driver Card 09. ", "Col. 57, Hammer Driver Card 11. ",
	"Col. 68, Hammer Driver Card 12. ", "Col. 63, Hammer Driver Card 11. ", "Col. 58, Hammer Driver Card 11. ",
	"Col. 69, Hammer Driver Card 12. ", "Col. 64, Hammer Driver Card 11. ", "Col. 59, Hammer Driver Card 11. ",
	"Col. 70, Hammer Driver Card 12. ", "Col. 65, Hammer Driver Card 12. ", "Col. 60, Hammer Driver Card 11. ",
	"Col. 71, Hammer Driver Card 12. ", "Col. 66, Hammer Driver Card 12. ", "Col. 61, Hammer Driver Card 11. ",
	"Col. 72, Hammer Driver Card 12. ", "Col. 67, Hammer Driver Card 12. ", "Col. 62, Hammer Driver Card 11. ",
	"Col. 73, Hammer Driver Card 13. ", "Col. 84, Hammer Driver Card 14. ", "Col. 79, Hammer Driver Card 13. ",
	"Col. 74, Hammer Driver Card 13. ", "Col. 85, Hammer Driver Card 14. ", "Col. 80, Hammer Driver Card 13. ",
	"Col. 75, Hammer Driver Card 13. ", "Col. 86, Hammer Driver Card 14. ", "Col. 81, Hammer Driver Card 14. ",
	"Col. 76, Hammer Driver Card 13. ", "Col. 87, Hammer Driver Card 14. ", "Col. 82, Hammer Driver Card 14. ",
	"Col. 77, Hammer Driver Card 13. ", "Col. 88, Hammer Driver Card 14. ", "Col. 83, Hammer Driver Card 14. ",
	"Col. 78, Hammer Driver Card 13. ", "Col. 89, Hammer Driver Card 15. ", "Col. 100, Hammer Driver Card 16. ",
	"Col. 95, Hammer Driver Card 15. ", "Col. 90, Hammer Driver Card 15. ", "Col. 101, Hammer Driver Card 16. ",
	"Col. 96, Hammer Driver Card 15. ", "Col. 91, Hammer Driver Card 15. ", "Col. 102, Hammer Driver Card 16. ",
	"Col. 97, Hammer Driver Card 16. ", "Col. 92, Hammer Driver Card 15. ", "Col. 103, Hammer Driver Card 16. ",
	"Col. 98, Hammer Driver Card 16. ", "Col. 93, Hammer Driver Card 15. ", "Col. 104, Hammer Driver Card 16. ",
	"Col. 99, Hammer Driver Card 16. ", "Col. 94, Hammer Driver Card 15. ", "Col. 105, Hammer Driver Card 17. ",
	"Col. 116, Hammer Driver Card 18. ", "Col. 111, Hammer Driver Card 17. ", "Col. 106, Hammer Driver Card 17. ",
	"Col. 117, Hammer Driver Card 18. ", "Col. 112, Hammer Driver Card 17. ", "Col. 107, Hammer Driver Card 17. ",
	"Col. 118, Hammer Driver Card 18. ", "Col. 113, Hammer Driver Card 18. ", "Col. 108, Hammer Driver Card 17. ",
	"Col. 119, Hammer Driver Card 18. ", "Col. 114, Hammer Driver Card 18. ", "Col. 109, Hammer Driver Card 17. ",
	"Col. 120, Hammer Driver Card 18. ", "Col. 115, Hammer Driver Card 18. ", "Col. 110, Hammer Driver Card 17. ",
	"Col. 121, Hammer Driver Card 19. ", "Col. 132, Hammer Driver Card 20. ", "Col. 127, Hammer Driver Card 19. ",
	"Col. 122, Hammer Driver Card 19. ", "Col. 133, Hammer Driver Card 20. ", "Col. 128, Hammer Driver Card 19. ",
	"Col. 123, Hammer Driver Card 19. ", "Col. 134, Hammer Driver Card 20. ", "Col. 129, Hammer Driver Card 20. ",
	"Col. 124, Hammer Driver Card 19. ", "Col. 135, Hammer Driver Card 20. ", "Col. 130, Hammer Driver Card 20. ",
	"Col. 125, Hammer Driver Card 19. ", "Col. 136, Hammer Driver Card 20. ", "Col. 131, Hammer Driver Card 20. ",
	"Col. 126, Hammer Driver Card 19. ");

dcl  col_trans_160 (0:9, 0:15) char (35) var int static options (constant) init
						/* for pr71 */
	("Col. 1, Hammer Driver Card 1. ", "Col. 12, Hammer Driver Card 2. ", "Col. 7, Hammer Driver Card 1. ",
	"Col. 2, Hammer Driver Card 1. ", "Col. 13, Hammer Driver Card 2. ", "Col. 8, Hammer Driver Card 1. ",
	"Col. 3, Hammer Driver Card 1. ", "Col. 14, Hammer Driver Card 2. ", "Col. 9, Hammer Driver Card 2. ",
	"Col. 4, Hammer Driver Card 1. ", "Col. 15, Hammer Driver Card 2. ", "Col. 10, Hammer Driver Card 2. ",
	"Col. 5, Hammer Driver Card 1. ", "Col. 16, Hammer Driver Card 2. ", "Col. 11, Hammer Driver Card 2. ",
	"Col. 6, Hammer Driver Card 1. ", "Col. 17, Hammer Driver Card 3. ", "Col. 28, Hammer Driver Card 4. ",
	"Col. 23, Hammer Driver Card 3. ", "Col. 18, Hammer Driver Card 3. ", "Col. 29, Hammer Driver Card 4. ",
	"Col. 24, Hammer Driver Card 3. ", "Col. 19, Hammer Driver Card 3. ", "Col. 30, Hammer Driver Card 4. ",
	"Col. 25, Hammer Driver Card 4. ", "Col. 20, Hammer Driver Card 3. ", "Col. 31, Hammer Driver Card 4. ",
	"Col. 26, Hammer Driver Card 4. ", "Col. 21, Hammer Driver Card 3. ", "Col. 32, Hammer Driver Card 4. ",
	"Col. 27, Hammer Driver Card 4. ", "Col. 22, Hammer Driver Card 3. ", "Col. 33, Hammer Driver Card 5. ",
	"Col. 44, Hammer Driver Card 6. ", "Col. 39, Hammer Driver Card 5. ", "Col. 34, Hammer Driver Card 5. ",
	"Col. 45, Hammer Driver Card 6. ", "Col. 40, Hammer Driver Card 5. ", "Col. 35, Hammer Driver Card 5. ",
	"Col. 46, Hammer Driver Card 6. ", "Col. 41, Hammer Driver Card 6. ", "Col. 36, Hammer Driver Card 5. ",
	"Col. 47, Hammer Driver Card 6. ", "Col. 42, Hammer Driver Card 6. ", "Col. 37, Hammer Driver Card 5. ",
	"Col. 48, Hammer Driver Card 6. ", "Col. 43, Hammer Driver Card 6. ", "Col. 38, Hammer Driver Card 5. ",
	"Col. 49, Hammer Driver Card 7. ", "Col. 60, Hammer Driver Card 8. ", "Col. 55, Hammer Driver Card 7. ",
	"Col. 50, Hammer Driver Card 7. ", "Col. 61, Hammer Driver Card 8. ", "Col. 56, Hammer Driver Card 7. ",
	"Col. 51, Hammer Driver Card 7. ", "Col. 62, Hammer Driver Card 8. ", "Col. 57, Hammer Driver Card 8. ",
	"Col. 52, Hammer Driver Card 7. ", "Col. 63, Hammer Driver Card 8. ", "Col. 58, Hammer Driver Card 8. ",
	"Col. 53, Hammer Driver Card 7. ", "Col. 64, Hammer Driver Card 8. ", "Col. 59, Hammer Driver Card 8. ",
	"Col. 54, Hammer Driver Card 7. ", "Col. 65, Hammer Driver Card 9. ", "Col. 76, Hammer Driver Card 10. ",
	"Col. 71, Hammer Driver Card 9. ", "Col. 66, Hammer Driver Card 9. ", "Col. 77, Hammer Driver Card 10. ",
	"Col. 72, Hammer Driver Card 9. ", "Col. 67, Hammer Driver Card 9. ", "Col. 78, Hammer Driver Card 10. ",
	"Col. 73, Hammer Driver Card 10. ", "Col. 68, Hammer Driver Card 9. ", "Col. 79, Hammer Driver Card 10. ",
	"Col. 74, Hammer Driver Card 10. ", "Col. 69, Hammer Driver Card 9. ", "Col. 80, Hammer Driver Card 10. ",
	"Col. 75, Hammer Driver Card 10. ", "Col. 70, Hammer Driver Card 9. ", "Col. 81, Hammer Driver Card 11. ",
	"Col. 92, Hammer Driver Card 12. ", "Col. 87, Hammer Driver Card 11. ", "Col. 82, Hammer Driver Card 11. ",
	"Col. 93, Hammer Driver Card 12. ", "Col. 88, Hammer Driver Card 11. ", "Col. 83, Hammer Driver Card 11. ",
	"Col. 94, Hammer Driver Card 12. ", "Col. 89, Hammer Driver Card 12. ", "Col. 84, Hammer Driver Card 11. ",
	"Col. 95, Hammer Driver Card 12. ", "Col. 90, Hammer Driver Card 12. ", "Col. 85, Hammer Driver Card 11. ",
	"Col. 96, Hammer Driver Card 12. ", "Col. 91, Hammer Driver Card 12. ", "Col. 86, Hammer Driver Card 11. ",
	"Col. 97, Hammer Driver Card 13. ", "Col. 108, Hammer Driver Card 14. ", "Col. 103, Hammer Driver Card 13. ",
	"Col. 98, Hammer Driver Card 13. ", "Col. 109, Hammer Driver Card 14. ", "Col. 104, Hammer Driver Card 13. ",
	"Col. 99, Hammer Driver Card 13. ", "Col. 110, Hammer Driver Card 14. ", "Col. 105, Hammer Driver Card 14. ",
	"Col. 100, Hammer Driver Card 13. ", "Col. 111, Hammer Driver Card 14. ", "Col. 106, Hammer Driver Card 14. ",
	"Col. 101, Hammer Driver Card 13. ", "Col. 112, Hammer Driver Card 14. ", "Col. 107, Hammer Driver Card 14. ",
	"Col. 102, Hammer Driver Card 13. ", "Col. 113, Hammer Driver Card 15. ", "Col. 124, Hammer Driver Card 16. ",
	"Col. 119, Hammer Driver Card 15. ", "Col. 114, Hammer Driver Card 15. ", "Col. 125, Hammer Driver Card 16. ",
	"Col. 120, Hammer Driver Card 15. ", "Col. 115, Hammer Driver Card 15. ", "Col. 126, Hammer Driver Card 16. ",
	"Col. 121, Hammer Driver Card 16. ", "Col. 116, Hammer Driver Card 15. ", "Col. 127, Hammer Driver Card 16. ",
	"Col. 122, Hammer Driver Card 16. ", "Col. 117, Hammer Driver Card 15. ", "Col. 128, Hammer Driver Card 16. ",
	"Col. 123, Hammer Driver Card 16. ", "Col. 118, Hammer Driver Card 15. ", "Col. 129, Hammer Driver Card 17. ",
	"Col. 140, Hammer Driver Card 18. ", "Col. 135, Hammer Driver Card 17. ", "Col. 130, Hammer Driver Card 17. ",
	"Col. 141, Hammer Driver Card 18. ", "Col. 136, Hammer Driver Card 17. ", "Col. 131, Hammer Driver Card 17. ",
	"Col. 142, Hammer Driver Card 18. ", "Col. 137, Hammer Driver Card 18. ", "Col. 132, Hammer Driver Card 17. ",
	"Col. 143, Hammer Driver Card 18. ", "Col. 138, Hammer Driver Card 18. ", "Col. 133, Hammer Driver Card 17. ",
	"Col. 144, Hammer Driver Card 18. ", "Col. 139, Hammer Driver Card 18. ", "Col. 134, Hammer Driver Card 17. ",
	"Col. 145, Hammer Driver Card 19. ", "Col. 156, Hammer Driver Card 20. ", "Col. 151, Hammer Driver Card 19. ",
	"Col. 146, Hammer Driver Card 19. ", "Col. 157, Hammer Driver Card 20. ", "Col. 152, Hammer Driver Card 19. ",
	"Col. 147, Hammer Driver Card 19. ", "Col. 158, Hammer Driver Card 20. ", "Col. 153, Hammer Driver Card 20. ",
	"Col. 148, Hammer Driver Card 19. ", "Col. 159, Hammer Driver Card 20. ", "Col. 154, Hammer Driver Card 20. ",
	"Col. 149, Hammer Driver Card 19. ", "Col. 160, Hammer Driver Card 20. ", "Col. 155, Hammer Driver Card 20. ",
	"Col. 150, Hammer Driver Card 19. ");

dcl  pr54_byte12 (7:99) char (60) var int static options (constant)
	init ("Manual Halt, PRT Off-Line. ", "EOP or EOS out of Sequence. ", "",
						/* ignore paper low */
	"Invalid VFC Load. ", "PRT Off-Line. ", "Paper Motion Alert, No VFC Channel Match. ",
	"BIB From System Does Not Contain 240 Chars. ", "Invalid Line Density In VFC Load. ",
	"Form Length Greater Than 144 line in VFC Load. ", "Invalid Line No. In VFC Load. ",
	"Invalid Auto Slew Data in VFC Load. ", "Invalid TOP/BOP in VFC Load. ", "Error on Status Read. ",
	"Unexpected PDSI Reg. in Response Frame. ", "TTE, No Response From PRT. ", "Horizontal Tab Greater Than 127. ",
	"Left Tab Operation Attempted. ", "Vertical Tab Greater Than 127. ", "Horizontal Skip Greater Than 127. ",
	"Skip Past End of Line. ", "ASCII CTL CHAR in Non-Edit Mode. ", "Invalid Code (1C). ",
						/* 1c thru 2d undefined */
	"Invalid Code (1D). ",			/* Define them as invalid */
	"Invalid Code (1E). ",			/* as it will indicate a HW problem */
	"Invalid Code (1F). ",			/* if they are entered */
	"Invalid Code (20). ", "Invalid Code (21). ", "Invalid Code (22). ", "Invalid Code (23). ",
	"Invalid Code (24). ", "Invalid Code (25). ", "Invalid Code (26). ", "Invalid Code (27). ",
	"Invalid Code (28). ", "Invalid Code (29). ", "Invalid Code (2A). ", "Invalid Code (2B). ",
	"Invalid Code (2C). ", "Invalid Code (2D). ", "Power OFF, No Response on Link. ", "Link Error, EURC ALERT. ",
	"Link Error, EURC Attention. ", "ATTN Cond. On Previous Operation. ", "", "Skip Loop CTL Error [FC=01]. ",
	"Invalid Code (34). ", "Tractors De-clutched [FC=03]. ", "Paper Jam at Tractors [FC=04]. ", "",
						/* paper low, ignore */
	"Yoke Open [FC=06]. ", "Broken Finger [FC=07]. ", "Belt Start Problem [FC=08]. ",
	"Ribbon Motion Problem [FC=09]. ", "Ribbon Seam Time-out [FC=0A]. ", "Stacker Alert [FC=0B]. ",
	"Ribbon Cartridge Not Present [FC=0C]. ", "Invalid Code (3F). ", "Line Strobe Problem [FC=0E]. ",
	"Invalid Code (41). ", "Invalid Code (42). ", "Invalid Code (43). ", "Invalid Code (44). ",
	"Invalid Code (45). ", "Character Not on Band Image [FC=14]. ", "Invalid Code (47). ", "Invalid Code (48). ",
	"Invalid Code (49). ", "Invalid Code (4A). ", "Echo Check IMP1 PWA [FC=19]. ", "Echo Check IMP2 PWA [FC=1A]. ",
	"Over Temperature [FC=1B]. ", "Skip PWA Failure [FC=1C]. ", "+40V failure [FC=1D]. ", "-40V Failure [FC=1E]. ",
	"Belt Command Failure [FC=1F]. ", "-9V Failure [FC=20]. ", "Dialogue Failure MPI to INT PWA [FC=21]. ",
	"Print/Slew Time-out. ", "Invalid Code (55). ", "Invalid Code (56). ", "Invalid Code (57). ",
	"Invalid Code (58). ", "Invalid Code (59). ", "Invalid Code (5A). ", "PLB Load Overflow [FC=91]. ",
	"VFU Load Overflow [FC=92]. ", "BIB Load Overflow [FC=93]. ", "Invalid BIB Data Load [FC=94]. ",
	"Invalid VFU Data Load [FC=95]. ", "Invalid VFU Channel No. [FC=96]. ",
	"No Stop on Selected VFU Channel [FC=97]. ", "Invalid Command Sequence [FC=98]. ",
	"Illegal Command Code [FC=99]. ");
%page;

	a_prt_analysis.prt_model = "";
	a_prt_analysis.density = "";
	a_prt_analysis.analyses (*) = "";
	anlzd = 0;
	statp = addr (iom_stats);



/* Check iom status to see if detail status is worth analyzing */


	if stat_maj = "0010"b then ;			/* dev attn */


	else if stat_maj = "0011"b then ;		/* any dev data alert */
	else if (stat_maj = "0101"b) &		/* cmd rej */
	     (fixed (stat_min, 6) = 20 |		/* slew error */
	     fixed (stat_min, 6) = 40)
	then ;					/* TOP echo */

	else if stat_maj = "1010"b then ;		/* mpc attn */


	else if stat_maj = "1011"b then ;		/* mpc data alert */


	else do;

/* detail status is either not available or not worthy of analysis, return */


	     anlzd = 0;
	     code = error_table_$request_not_recognized;
	     return;
	     end;

/*  Scan the config deck to determine the type of prt we are working on  */

	prph_cardp = null ();
	call config_$find_periph (substr (name, 1, 4), prph_cardp);
	if prph_cardp = null () then do;
	     code = error_table_$resource_unknown;
	     return;
	     end;
	ptr_model = prph_card.model;

	if ptr_model = 1200 | ptr_model = 1600
	then					/* PR71 */
	     go to do_PR71;

	if ptr_model = 901 | ptr_model = 1000 | ptr_model = 1201
	then					/* PR54 */
	     go to do_PR54;

	go to unimplemented;			/* don't know this type */
%page;

/* Routine for PR71 */

do_PR71:
	if substr (det_stats, 48, 1) then goto do_PR54;	/* only PR54s have this bit on! */
	pr71_index = 1;
	a_prt_analysis.prt_model = "PRU" || ltrim (char (ptr_model));

	if fixed (substr (det_stats, 23, 2), 2) ^= 0	/* 1=6lpi, 2=8lpi */
	then if fixed (substr (det_stats, 23, 2), 2) < 3
	     then a_prt_analysis.density = DENSITY (fixed (substr (det_stats, 23, 2), 2));

	if (stat_maj = "0010"b) & (stat_min = "0"b) then do;
						/* if power fault */
	     pr71_index = 23;
	     go to check_pr71_fault;
	     end;

	if substr (det_stats, 1, 1) ^= "1"b then do;
	     anlzd = anlzd + 1;
	     a_prt_analysis.analyses (anlzd) = "Belt Image Not Loaded. ";
	     a_is_interesting = "1"b;
	     end;

	if substr (det_stats, 25, 1) ^= "1"b then do;
	     anlzd = anlzd + 1;
	     a_prt_analysis.analyses (anlzd) = "VFC Image Not Loaded. ";
	     a_is_interesting = "1"b;
	     end;

	if substr (det_stats, 26, 1) ^= "1"b then do;
	     anlzd = anlzd + 1;
	     a_prt_analysis.analyses (anlzd) = "VFC Out of Sync. ";
	     a_is_interesting = "1"b;
	     end;

check_pr71_fault:
	substr (temp_prt_det_stat, 1, 1) = substr (det_stats, 35, 1);
	substr (temp_prt_det_stat, 2, 4) = substr (det_stats, 43, 4);
	substr (temp_prt_det_stat, 6, 11) = substr (det_stats, 49, 11);
	substr (temp_prt_det_stat, 17, 6) = substr (det_stats, 65, 6);
	substr (temp_prt_det_stat, 23, 8) = substr (det_stats, 73, 8);
	substr (temp_prt_det_stat, 31, 5) = substr (det_stats, 83, 5);
	substr (temp_prt_det_stat, 36, 2) = substr (det_stats, 41, 2);
	substr (temp_prt_det_stat, 38, 2) = substr (det_stats, 81, 2);

	do i = pr71_index to 35;
	     if substr (temp_prt_det_stat, i, 1) = "1"b then do;
		anlzd = anlzd + 1;
		a_prt_analysis.analyses (anlzd) = trans_table_prt (i);
		a_is_interesting = "1"b;
		end;
	end;


/* Now check for echo check and short circuit errors */

	if fixed (substr (det_stats, 41, 2), 2) > 0 then do;
						/* echo ck err */
	     msg_indx = fixed (substr (det_stats, 41, 2), 2);

	     if msg_indx > 2 then msg_indx = 1;

	     anlzd = anlzd + 1;
	     a_prt_analysis.analyses (anlzd) = trans_table_prt (35 + msg_indx);
	     bysc = fixed (substr (det_stats, 101, 4), 4);/* use for col decode */
	     ec_sc_bit = substr (det_stats, 89, 10);
	     go to anal_ec_sc;
	     end;

	else if fixed (substr (det_stats, 81, 2), 2) > 0 then do;
						/* short ckt err */

	     msg_indx = fixed (substr (det_stats, 81, 2), 2);
	     if msg_indx > 2 then msg_indx = 3;

	     anlzd = anlzd + 1;
	     a_prt_analysis.analyses (anlzd) = trans_table_prt (37 + msg_indx);
	     bysc = fixed (substr (det_stats, 117, 4), 4);/* use for col decode */
	     ec_sc_bit = substr (det_stats, 105, 10);
	     go to anal_ec_sc;
	     end;

	else go to fill_prt_struct;
anal_ec_sc:
	if substr (det_stats, 17, 3) = "001"b
	then					/* 136 col prt */
	     do i = 1 to 10;
	     if substr (ec_sc_bit, i, 1) = "1"b then do;
		anlzd = anlzd + 1;
		a_prt_analysis.analyses (anlzd) = col_trans_136 (i - 1, bysc);
		a_is_interesting = "1"b;
		end;
	end;

	else if substr (det_stats, 17, 3) = "010"b
	then					/* 160 col prt */
	     do i = 1 to 10;
	     if substr (ec_sc_bit, i, 1) = "1"b then do;
		anlzd = anlzd + 1;
		a_prt_analysis.analyses (anlzd) = col_trans_160 (i - 1, bysc);
		a_is_interesting = "1"b;
		end;
	end;


	else do;
	     anlzd = anlzd + 1;
	     a_prt_analysis.analyses (anlzd) = "Cannot Determine Number of Columns.";
	     end;

	go to fill_prt_struct;

%page;

/* Routine for PR54 */

do_PR54:
	a_prt_analysis.prt_model = "PRU" || ltrim (char (ptr_model));
	if substr (det_stats, 121, 1) = "0"b		/* 0=6lpi, 1=8lpi */
	then a_prt_analysis.density = DENSITY (1);
	else a_prt_analysis.density = DENSITY (2);

	if substr (det_stats, 1, 1) = "0"b then do;
	     anlzd = anlzd + 1;
	     a_prt_analysis.analyses (anlzd) = "Belt Image Not Loaded. ";
	     a_is_interesting = "1"b;
	     end;

	if substr (det_stats, 25, 1) = "0"b then do;
	     anlzd = anlzd + 1;
	     a_prt_analysis.analyses (anlzd) = "VFC Image Not Loaded. ";
	     a_is_interesting = "1"b;
	     end;

	if substr (det_stats, 26, 1) = "0"b then do;
	     anlzd = anlzd + 1;
	     a_prt_analysis.analyses (anlzd) = "VFC Out of Sync. ";
	     a_is_interesting = "1"b;
	     end;


	if substr (det_stats, 97, 8) ^= "0"b then do;	/* bypass paper out */
	     i = bin (substr (det_stats, 97, 8), 8);
	     if i < 7 then goto fill_prt_struct;	/* and CMD REJs */
	     anlzd = anlzd + 1;

	     if i ^> 99
	     then					/* Max table entry of 63hex */
		a_prt_analysis.analyses (anlzd) = pr54_byte12 (i);

	     else a_prt_analysis.analyses (anlzd) = "Illegal Code in Byte 12. ";
	     a_is_interesting = "1"b;
	     end;

	if substr (det_stats, 105, 8) = "ff"b4
	then					/* Not an error */
	     go to fill_prt_struct;			/* no more error bytes */

%page;
fill_prt_struct:
	number_analyzed = anlzd;

	if (^rs_sw & ^rsnnl_sw) then do;
	     call hcs_$make_seg ("", "analyze_detail_stat_.temp", "", 10, prt_analp, xcode);
	     auto_analp = prt_analp;
	     prt_analysis.prt_analysis_version = analyze_det_stat_info_version_1;
	     prt_analysis.num_analyzed = anlzd;
	     prt_analysis.prt_model = a_prt_analysis.prt_model;
	     prt_analysis.density = a_prt_analysis.density;
	     prt_analysis.is_interesting_prt = a_is_interesting;


	     if number_analyzed > 0
	     then do j = 1 to number_analyzed;
		prt_analysis.analyses (j) = a_prt_analysis.analyses (j);
	     end;

	     else prt_analysis.analyses (*) = "";
	     return;
	     end;

	if (rsnnl_sw | rs_sw) then do;
	     do j = 1 to number_analyzed;
		message = message || a_prt_analysis.analyses (j);
	     end;
	     if message ^= "" then do;
		if rs_sw then message = message || NEW_LINE;
		is_interesting = a_is_interesting;
		end;
	     else is_interesting = "0"b;
	     end;

	return;


unimplemented:
	code = error_table_$unimplemented_version;
	return;
     end anal_prt_;

%page;
anal_rdr_pun:
     proc;

dcl  rdr_pun char (3) init ("");
dcl  rdr_pun_model fixed bin;
dcl  rdr_pun_trans_table (50) char (34) var int static options (constant)
	init ("Punch Station Present. ", "Punch Buffer Allow. ", "Jam Between Read & Punch Station. ",
	"Jam on Incremental Failure. ", "Jam on Extra Strobe. ", "Blank Data Found. ", "Punch Error, COL 1 Knives. ",
	"Punch Error, COL 2 Knives. ", "Punch Error, COL 41 Knives. ", "Punch error, COL 42 Knives. ",
	"Disconnect to DOE. ", "Inhibit EV3'S. ", "Set APM1 to DOE. ", "Set APM2 to DOE. ", "Set APM3 to DOE. ",
	"Set APM4 to DOE. ", "Set APM5 to DOE. ", "Lower Light to DOE. ", "Read Compare Error. ",
	"All Light/dark Check. ", "Strobe Count Error. ", "Transfer Error. ", "Illegal Punch. ", "Blank Card. ",
	"Address Incrementing Command. ", "EV1 Present. ", "Hopper Empty. ", "Stacker Full. ", "Anti-Fountain Off. ",
	"Throat Error. ", "JPK/JRK Type Jam. ", "Jam in Kick Station. ", "Chad Box Full. ", "Interlock Open. ",
	"Jam in Wait Station. ", "Jam in Read Station. ", "EV2 Present. ", "End of Process. ", "Device Ready. ",
	"Data Parity Error. ", "Read Lamp Voltage Marginal. ", "+5 volts Low. ", "Punch Lamp Marginal. ",
	"Index Time Marginal. ", "Check Byte Count. ", "Residual Byte Count. ", "Buffer Check Error. ", "Illegal EV1. ",
	"NO End of Process. ", "Device Timer Runout. ");

dcl  board_code (2:7) char (9) int static options (constant)
	init ("RCL PWB. ", "RCL PWB. ", "RCL PWB. ", "PPK PWB. ", "PPK PWB. ", "RSL PWB. ");

dcl  temp_rdr_pun_dtstat bit (72);


	a_rdr_pun_analysis.rdr_pun_model = "";
	a_rdr_pun_analysis.analyses (*) = "";
	anlzd = 0;
	statp = addr (iom_stats);

/*  Now check iom status to see if its worth it */


	if (stat_maj = "0010"b) &			/* attention, but not chad box full */
	     (fixed (stat_min, 6) ^= 4)
	then ;

	else if (stat_maj = "0011"b) then ;		/* any dev data alert */

	else if stat_maj = "1011"b then ;		/* mpc data alert */

	else if stat_maj = "1010"b then ;		/* mpc attention */

	else do;

/* detail status is either not available or not worthy of analysis, return */


	     anlzd = 0;
	     code = error_table_$request_not_recognized;
	     return;
	     end;

/*  Scan the config deck to determine the type of rdr/pun we are working on  */

	prph_cardp = null ();
	call config_$find_periph ((name), prph_cardp);
	if prph_cardp = null () then do;
	     code = error_table_$resource_unknown;
	     return;
	     end;
	rdr_pun_model = prph_card.model;
	if substr (name, 1, 3) = "rdr"
	then rdr_pun = "CRZ";
	else rdr_pun = "CPZ";

	if rdr_pun_model ^= 300
	then if rdr_pun_model ^= 301 then go to not_yet;


	a_rdr_pun_analysis.rdr_pun_model = rdr_pun || ltrim (char (rdr_pun_model));
	substr (temp_rdr_pun_dtstat, 1, 6) = substr (det_stats, 1, 6);
	substr (temp_rdr_pun_dtstat, 7, 4) = substr (det_stats, 9, 4);
	substr (temp_rdr_pun_dtstat, 11, 24) = substr (det_stats, 17, 24);
	substr (temp_rdr_pun_dtstat, 35, 11) = substr (det_stats, 47, 11);
	substr (temp_rdr_pun_dtstat, 46, 5) = substr (det_stats, 65, 5);

	do i = 1 to hbound (rdr_pun_trans_table, 1);
	     if substr (temp_rdr_pun_dtstat, i, 1) then do;
		anlzd = anlzd + 1;
		a_rdr_pun_analysis.analyses (anlzd) = rdr_pun_trans_table (i);
		a_is_interesting = "1"b;
		end;
	end;

	if fixed (substr (det_stats, 44, 3), 3) > 1 & fixed (substr (det_stats, 44, 3), 3) <= 7 then do;
	     anlzd = anlzd + 1;
	     a_rdr_pun_analysis.analyses (anlzd) = "Board Code = " || board_code (fixed (substr (det_stats, 44, 3), 3));
	     a_is_interesting = "1"b;
	     end;

fill_rdr_pun_struct:
	number_analyzed = anlzd;

	if (^rsnnl_sw & ^rs_sw) then do;
	     call hcs_$make_seg ("", "analyze_detail_stat_.temp", "", 10, rdr_pun_analp, xcode);

	     auto_analp = rdr_pun_analp;
	     rdr_pun_analysis.rdr_pun_analysis_version = analyze_det_stat_info_version_1;
	     rdr_pun_analysis.num_analyzed = anlzd;
	     rdr_pun_analysis.is_interesting_rdr_pun = a_is_interesting;
	     rdr_pun_analysis.rdr_pun_model = a_rdr_pun_analysis.rdr_pun_model;

	     if number_analyzed > 0
	     then do j = 1 to number_analyzed;
		rdr_pun_analysis.analyses (j) = a_rdr_pun_analysis.analyses (j);
	     end;

	     else rdr_pun_analysis.analyses (*) = "";

	     return;
	     end;

	if (rsnnl_sw | rs_sw) then do;
	     do j = 1 to number_analyzed;
		message = message || a_rdr_pun_analysis.analyses (j);
	     end;
	     if message ^= "" then do;
		if rs_sw then message = message || NEW_LINE;
		is_interesting = a_is_interesting;
		end;
	     else is_interesting = "0"b;
	     end;


	return;



not_yet:
	code = error_table_$unimplemented_version;
	return;
     end anal_rdr_pun;


%page;
anal_tape_:
     proc;

dcl  tks fixed bin init (0);
dcl  (valid, att_sw, da_alert, cmts, tracks_v) bit (1) init ("0"b);
dcl  mpc_model fixed bin init (0);
dcl  dev_type fixed bin init (0);
dcl  trk9_tbl (9) char (2) internal static options (constant) init ("0-", "1-", "2-", "3-", "4-", "5-", "6-", "7-", "P-");

dcl  trk7_tbl (9) char (2) internal static options (constant) init ("", "", "2-", "3-", "4-", "5-", "6-", "7-", "P-");

dcl  trk9_idx (9) fixed bin int static options (constant) init (5, 7, 9, 13, 1, 17, 3, 15, 11);

dcl  trk7_idx (9) fixed bin int static options (constant) init (0, 0, 7, 9, 11, 13, 15, 17, 5);

dcl  ext_stats (26) bit (8) unal based (ext_ptr);
dcl  ext_ptr ptr;
dcl  curr_mode char (1) init ("");
dcl  (str1, str2, str3) bit (9);
dcl  fdmask9 bit (9) init ("111111111"b);		/* mask for frame drop 9trk */
dcl  fdmask7 bit (9) init ("001111111"b);		/* mask for frame drop 7trk */
dcl  curr_dens char (2) init ("");


	a_tape_analysis.mth_model = "";
	a_tape_analysis.density = 0;
	a_tape_analysis.operation = "";
	a_tape_analysis.trks_in_err = "------------------";
	a_tape_analysis.dbie_array (*) = 0;
	a_tape_analysis.anal (*) = "";
	a_tape_analysis.num_tracks = 0;
	anlzd = 0;
	statp = addr (iom_stats);
	mpc_model = 0;

/*  This routine scans the config deck to see if the tape mpc is a mtc500
   If it is then it sets the switch that disables intrepreting the controller
   status, as the 500 doesn't have this available....       */

	prph_tap_cardp = null ();
	call config_$find_periph (substr (name, 1, 4), prph_tap_cardp);
	if prph_tap_cardp = null () then do;		/* device nolonger configured */
	     code = error_table_$resource_unknown;
	     return;
	     end;
	call find_controller (prph_tap_card.iom, prph_tap_card.chan);
	if mpc_cardp = null () & ipc_cardp = null () then return;
						/* not MPC/FIPS driven */
	if fips_controller then do;			/* handle fips differently */
	     call anal_fips_tape_;
	     goto fill_struct;
	     end;

	mpc_model = mpc_card.model;

	if stat_maj = "0010"b			/* don't try to analyze tkie data for this one */
	then if substr (stat_min, 4, 1) = "1"b then do;	/* dev in standby */
STDBY:
		anlzd = 0;
		code = error_table_$request_not_recognized;
		return;
		end;



	if (stat_maj = "1011"b) &			/* MPC data alert */
	     (stat_min = "100000"b)			/* margin cond */
	then att_sw = "1"b;

	else if (stat_maj = "0010"b) &		/* DEV Attention */
	     (substr (stat_min, 3, 1) = "1"b |		/* dev fault */
	     substr (stat_min, 2, 1) = "1"b)		/* blank tape on write */
	then att_sw = "1"b;

	else if (stat_maj = "1010"b) &		/* MPC Attention */
	     (substr (stat_min, 2, 1) = "1"b)		/* dev malfunction */
	then att_sw = "1"b;

	else if (stat_maj = "0011"b) &		/* dev data alert */
	     (substr (stat_min, 5, 2) = "11"b |		/* bit detected during erase */
	     substr (stat_min, 3, 1) = "1"b |		/* lateral parity */
	     substr (stat_min, 2, 1) = "1"b)		/* longitudinal parity */
	then da_alert = "1"b;

	else if (stat_maj = "1011"b) &		/* mpc data alert */
	     (fixed (stat_min, 6) = 8 |		/* id-burst write error */
	     fixed (stat_min, 6) = 9 |		/* preamble error */
	     fixed (stat_min, 6) = 16 |		/* multi-track error */
	     fixed (stat_min, 6) = 17 |		/* skew error */
	     fixed (stat_min, 6) = 18 |		/* postamble error */
	     fixed (stat_min, 6) = 19)		/* nrzi CCC error */
	then da_alert = "1"b;

	else if (stat_maj = "0100"b) &		/* eof */
	     (fixed (stat_min, 6) = 63)		/* data alert */
	then da_alert = "1"b;

	else if (stat_maj = "1010"b) &		/* MPC Attention */
	     (substr (stat_min, 3, 2) = "11"b)		/* TCA malfunction */
	then da_alert = "1"b;			/* not really, but will */
						/* allow detail register checking */

	else do;
	     anlzd = 0;
	     code = error_table_$request_not_recognized;
	     return;
	     end;


	dev_type = 0;

	if substr (det_stats, 7, 1) = "1"b
	then					/* dev in standby */
	     go to STDBY;				/* det stat worthless */

	if substr (det_stats, 17, 3) = "000"b then do;
	     a_tape_analysis.density = 1600;
	     curr_dens = "pe";
	     end;

	else if substr (det_stats, 17, 3) = "001"b then do;
	     curr_dens = "gc";
	     a_tape_analysis.density = 6250;
	     end;

	else do;
	     curr_dens = "nr";
	     a_tape_analysis.density = 800;
	     end;


	if substr (det_stats, 12, 1) = "1"b then do;
	     curr_mode = "";
	     a_tape_analysis.operation = "Rewind";
	     end;


	else if substr (det_stats, 10, 1) = "1"b then do;
	     curr_mode = "W";
	     a_tape_analysis.operation = "Write";
	     end;


	else if substr (det_stats, 10, 1) = "0"b then do;
	     curr_mode = "R";
	     a_tape_analysis.operation = "Read";
	     end;


	if substr (det_stats, 27, 1) = "0"b
	then					/* dev is a mtu400/500 */
	     dev_type = 500;

	else if substr (det_stats, 53, 4) = "0100"b
	then					/* dev is a MTU600 (OKC) type */
	     dev_type = 600;

	else if substr (det_stats, 53, 4) = "1000"b
	then					/* dev is a mtu610 (MPI) */
	     dev_type = 610;

	else if substr (det_stats, 53, 4) = "0110"b
	then					/* dev is a mtu640 MTUMPT (STC) */
	     dev_type = 640;

	if dev_type ^= 0 then a_tape_analysis.mth_model = "MTH" || ltrim (rtrim (char (dev_type)));


	if substr (det_stats, 26, 1) = "1"b then tks = 1; /* 1 = 9 trk, 0 = 7 trk drive */
	if tks = 1
	then a_tape_analysis.num_tracks = 9;
	else a_tape_analysis.num_tracks = 7;

	if att_sw then go to dev_model (dev_type);

	if da_alert then go to data_alert;

	if (rs_sw | rsnnl_sw) then do;
	     message = "";
	     is_interesting = "0"b;
	     end;

	return;

dev_model (0):
	code = error_table_$resource_type_inappropriate;
	a_is_interesting = "0"b;
	return;
%page;
dev_model (500):
	begin;

dcl  raw_status bit (208) based (addr (det_stats));
dcl  int_status bit (47);


dcl  trans_table_mth500 (47) char (35) varying internal static options (constant) init ("Device Fault: ",
						/* byte 0,bit 0 */
	"Command Code Error. ",			/*      ,bit 1 */
	"Write Echo Error. ",			/*      ,bit 2 */
	"Multiple BOT Status. ",			/*      ,bit 3 */
	"Margin Condition: ",			/*      ,bit 7 */
	"Load air failure. ",			/* byte 6,bit 1 */
	"File hub engage failure. ", "Window failed to shut. ", "Vacuum start-up failure. ", "File hub open. ",
	"Cannister failed to shut. ", "Semi-Auto thread-wrap failure. ", "Auto thread-wrap failure. ",
	"Machine Col. load failure. ", "File Col. load failure. ", "Door Interlock Open. ",
						/* byte 7, bit2 */
	"Window Interlock Open. ",			/*      , bit 3 */
	"Hi Tape-File Col. ",			/*      , bit 4 */
	"Hi Tape-Mach Col. ",			/*    , bit 5 */
	"Lo Tape-File Col. ",			/*      , bit  6 */
	"Lo Tape-Mach Col. ",			/*      , bit 7 */
	"Vacuum Loss. ",				/* byte 8, bit 0 */
	"Col Vacuum-Marginal. ",			/*     , bit 1 */
	"LTOR Lamp. ",				/*      , bit 2 */
	"BOT/EOT Lamp. ",				/*      , bit 3 */
	"Cannister Shut Failure. ",			/*      , bit 4 */
	"File Hub Release Failure. ",			/*      , bit 5 */
	"Erase Current Failure. ",			/*      , bit 6 */
	"Window Safety Bar. ",			/*      , bit 7 */
	"Over Temp (LOGIC). ",			/* byte 9, bit 0 */
	"Over Temp (CAPSTAIN). ",			/*      , bit 1 */
	"DC Breaker Switched. ",			/*      , bit 2 */
	"+5V (OV/UV) Failure. ",			/*      , bit 3 */
	"-24V (OV/UV) Failure. ",			/*      , bit 4 */
	"+12V (OV/UV) Failure. ",			/*      , bit 5 */
	"-12V (OV/UV) Failure. ",			/*      , bit 6 */
	"+24V (OV/UV) Failure. ",			/*      , bit 7 */
	"Over Speed. ",				/* byte 10, bit 0 */
	"Under Speed. ",				/*       , bit 1 */
	"+5V (Marginal). ",				/*       , bit 4 */
	"-24V (Marginal). ",			/*       , bit 5 */
	"+12V (Marginal). ",			/*       , bit 6 */
	"-12v (Marginal). ",			/*       , bit 7 */
	"File Reel CONTROL Malfunction. ",		/* byte 15, bit 2 */
	"Lo Tape-File. ",				/* byte 16, bit 3 (mtc500 only) */
	"Lo Tape-Mach. ",				/*       , bit 7  "" */
	"Mach Reel CONTROL Malfunction. ");		/* byte 18 bit 2 (mtc500 only) */

	     anlzd = 0;
	     substr (int_status, 1, 4) = substr (raw_status, 1, 4);
	     substr (int_status, 5, 1) = substr (raw_status, 8, 1);
	     substr (int_status, 6, 10) = substr (raw_status, 49, 10);
	     substr (int_status, 16, 24) = substr (raw_status, 59, 24);
	     substr (int_status, 40, 4) = substr (raw_status, 85, 4);
	     substr (int_status, 44, 1) = substr (raw_status, 123, 1);
	     substr (int_status, 45, 1) = substr (raw_status, 132, 1);
	     substr (int_status, 46, 1) = substr (raw_status, 136, 1);
	     substr (int_status, 47, 1) = substr (raw_status, 147, 1);

	     do i = 2 to 4;
		if substr (int_status, i, 1) = "1"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = trans_table_mth500 (i);
		     a_is_interesting = "1"b;
		     end;
	     end;

	     if substr (int_status, 1, 1) = "1"b then do; /* dev fault */
		anlzd = anlzd + 1;
		a_tape_analysis.anal (anlzd) = trans_table_mth500 (1);

		do i = 6 to 37;			/* cycle thru dev fault bits */
		     if substr (int_status, i, 1) = "1"b then do;
			anlzd = anlzd + 1;
			a_tape_analysis.anal (anlzd) = trans_table_mth500 (i);
			a_is_interesting = "1"b;
			end;
		end;

		if substr (int_status, 44, 1) = "1"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = trans_table_mth500 (44);
		     a_is_interesting = "1"b;
		     end;


		if mpc_model = 500 then do;		/* these bits only valid for mtc500 mpc */
		     if substr (int_status, 45, 1) = "1"b then do;
			anlzd = anlzd + 1;
			a_tape_analysis.anal (anlzd) = trans_table_mth500 (45);
			a_is_interesting = "1"b;
			end;

		     if substr (int_status, 46, 1) = "1"b then do;
			anlzd = anlzd + 1;
			a_tape_analysis.anal (anlzd) = trans_table_mth500 (46);
			a_is_interesting = "1"b;
			end;

		     if substr (int_status, 47, 1) = "1"b then do;
			anlzd = anlzd + 1;
			a_tape_analysis.anal (anlzd) = trans_table_mth500 (47);
			a_is_interesting = "1"b;
			end;
		     end;

		end;				/* end dev fault checks */

	     if substr (int_status, 5, 1) = "1"b then do; /* now check for margin cond */
		anlzd = anlzd + 1;
		a_tape_analysis.anal (anlzd) = trans_table_mth500 (5);

		do i = 38 to 43;
		     if substr (int_status, i, 1) = "1"b then do;
			anlzd = anlzd + 1;
			a_tape_analysis.anal (anlzd) = trans_table_mth500 (i);
			a_is_interesting = "1"b;
			end;
		end;
		end;

	     go to fill_struct;


	end;					/* end begin bolck mth500 */
%page;
dev_model (600):
	begin;

dcl  raw_status bit (208) based (addr (det_stats));
dcl  int_status bit (24);
dcl  trans_table_mth600 (39) char (35) varying internal static options (constant) init ("Device Fault: ",
						/* byte 0, bit 0 */
	"Command Code Error. ",			/*      ,bit 1 */
	"Write Echo Error. ",			/*      ,bit 2 */
	"Multiple BOT Status. ",			/*     ,bit 3 */
	"Margin Condition: ",			/*      ,bit 7 */
	"Column Vacuum Failure. ",			/* byte 6,bit 0 */
	"Main Blower Failure. ",			/*      ,bit 1 */
	"Overtemp (Deck Hot). ",			/*      ,bit 2 */
	"TMC ROM Error. ",				/*      ,bit 3 */
	"Erase Current Failure. ",			/* byte 8,bit 0 */
	"Door Open. ",				/*     ,bit 1 */
	"Capstan Blower Failure. ",			/*      ,bit 2 */
	"Air Bearing Failure. ",			/*      ,bit 3 */
	"Marginal Gap. ",				/*      ,bit 7 */
	"Duty Cycle Exceeded. ",			/* byte 9, bit 7 */
	"Power window failure. ", "File hub failure. ", "Cannister failure. ", "Load retry failure. ",
	"BOT/EOT Sensor Failure. ", "LTOR Sensor Failure. ", "Hi Tape Sensor Failure. ", "Column load failure. ",
	"Thread-wrap failure. ", "Load/Unload ROM addr. failure. ", "Hi Tape (File Column). ",
	"Lo Tape (File Column). ", "Hi Tape (Machine Column). ", "Lo Tape (Machine Column). ",
	"Mach/File Tach Failure. ", "Vacuum Failure. ", "Column Sensor 4 Failure. ", "+5V Marginal. ", "+5V Fault. ",
	"+/- 12V Marginal. ", "+/- 12V Fault. ", "+24V Fault. ", "Circuit Breaker Tripped. ",
	"Mach/File Reel Malfunction. ");


dcl  x fixed bin;

	     anlzd = 0;
	     substr (int_status, 1, 4) = substr (raw_status, 1, 4);
	     substr (int_status, 5, 1) = substr (raw_status, 8, 1);
	     substr (int_status, 6, 4) = substr (raw_status, 49, 4);
	     substr (int_status, 10, 4) = substr (raw_status, 65, 4);
	     substr (int_status, 14, 1) = substr (raw_status, 72, 1);
	     substr (int_status, 15, 1) = substr (raw_status, 80, 1);
	     substr (int_status, 16, 8) = substr (raw_status, 57, 8);
	     substr (int_status, 24, 1) = substr (raw_status, 93, 1);


	     do i = 2 to 4;
		if substr (int_status, i, 1) = "1"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = trans_table_mth600 (i);
		     a_is_interesting = "1"b;
		     end;
	     end;

	     if substr (int_status, 1, 1) = "1"b |	/* dev fault */
		substr (int_status, 5, 1) = "1"b then do;
						/* or margin cond */
		anlzd = anlzd + 1;
		if substr (int_status, 1, 1) = "1"b then do;
		     a_tape_analysis.anal (anlzd) = trans_table_mth600 (1);
		     a_is_interesting = "1"b;
		     end;

		else if substr (int_status, 5, 1) = "1"b then do;
		     a_tape_analysis.anal (anlzd) = trans_table_mth600 (5);
		     a_is_interesting = "1"b;
		     end;

		do i = 6 to 15;
		     if substr (int_status, i, 1) = "1"b then do;
			anlzd = anlzd + 1;
			a_tape_analysis.anal (anlzd) = trans_table_mth600 (i);
			a_is_interesting = "1"b;
			end;
		end;

		if substr (int_status, 23, 1) = "1"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = trans_table_mth600 (38);
		     a_is_interesting = "1"b;
		     go to fill_struct;
		     end;

		if substr (int_status, 24, 1) = "1"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = trans_table_mth600 (39);
		     a_is_interesting = "1"b;
		     end;


		if substr (int_status, 16, 5) = "10000"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = trans_table_mth600 (16);
		     a_is_interesting = "1"b;
		     end;

		if substr (int_status, 16, 5) = "01000"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = trans_table_mth600 (17);
		     a_is_interesting = "1"b;
		     end;

		if substr (int_status, 16, 5) = "11000"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = trans_table_mth600 (18);
		     a_is_interesting = "1"b;
		     end;

		if substr (int_status, 16, 5) = "00100"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = trans_table_mth600 (19);
		     a_is_interesting = "1"b;
		     end;


		if substr (int_status, 16, 5) = "10100"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = trans_table_mth600 (20);
		     a_is_interesting = "1"b;
		     end;


		if substr (int_status, 16, 5) = "01100"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = trans_table_mth600 (21);
		     a_is_interesting = "1"b;
		     end;


		if substr (int_status, 16, 3) = "111"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = trans_table_mth600 (22);
		     a_is_interesting = "1"b;
		     end;

		if substr (int_status, 16, 5) = "00010"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = trans_table_mth600 (23);
		     a_is_interesting = "1"b;
		     end;

		if substr (int_status, 16, 5) = "10010"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = trans_table_mth600 (24);
		     a_is_interesting = "1"b;
		     end;

		if substr (int_status, 16, 5) = "01010"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = trans_table_mth600 (25);
		     a_is_interesting = "1"b;
		     end;


		if substr (int_status, 16, 2) = "10"b
		then if substr (int_status, 20, 1) = "1"b then do;
			anlzd = anlzd + 1;
			a_tape_analysis.anal (anlzd) = trans_table_mth600 (26);
			a_is_interesting = "1"b;
			end;


		if substr (int_status, 16, 2) = "01"b
		then if substr (int_status, 20, 1) = "1"b then do;
			anlzd = anlzd + 1;
			a_tape_analysis.anal (anlzd) = trans_table_mth600 (27);
			a_is_interesting = "1"b;
			end;


		if substr (int_status, 18, 3) = "101"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = trans_table_mth600 (28);
		     a_is_interesting = "1"b;
		     end;


		if substr (int_status, 18, 3) = "011"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = trans_table_mth600 (29);
		     a_is_interesting = "1"b;
		     end;


		if substr (int_status, 16, 5) = "11010"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = trans_table_mth600 (30);
		     a_is_interesting = "1"b;
		     end;


		if substr (int_status, 16, 5) = "00110"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = trans_table_mth600 (31);
		     a_is_interesting = "1"b;
		     end;


		if substr (int_status, 16, 5) = "10110"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = trans_table_mth600 (32);
		     a_is_interesting = "1"b;
		     end;


		x = fixed (substr (int_status, 1, 1) || substr (int_status, 5, 1), 2);

		if x > 0 then go to volt_check_mth600 (x);

		go to fill_struct;


volt_check_mth600 (1):
		if substr (int_status, 21, 2) = "10"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = trans_table_mth600 (33);
		     a_is_interesting = "1"b;
		     end;


		if substr (int_status, 21, 2) = "01"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = trans_table_mth600 (35);
		     a_is_interesting = "1"b;
		     end;


		go to fill_struct;


volt_check_mth600 (2):
		if substr (int_status, 21, 2) = "10"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = trans_table_mth600 (37);
		     a_is_interesting = "1"b;
		     end;


		go to fill_struct;

volt_check_mth600 (3):
		if substr (int_status, 21, 2) = "10"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = trans_table_mth600 (34);
		     a_is_interesting = "1"b;
		     end;


		if substr (int_status, 21, 2) = "01"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = trans_table_mth600 (36);
		     a_is_interesting = "1"b;
		     end;


end_mth600_attn:
		end;				/* end dev fault/malf checks */

	end;					/* end begin block for mth600 */
	go to fill_struct;

%page;
dev_model (610):
	begin;
dcl  raw_status bit (208) based (addr (det_stats));
dcl  int_status bit (19);
dcl  trans_table_mth610 (19) char (65) varying internal static options (constant)
	init ("Device Fault: ", "Command Code Error. ", "Signal Fault: ", "Multiple BOT Status. ",
	"Marginal Condition: ", "Incorrect Speed Detected. ", "Main Blower Failure. ", "Over Temp. ",
	"Low Air Bearing Pressure. ", "Erase Current Failure. ", "Door Open Switch. ", "Write Current Failure. ",
	"Auto Hub Air Pressure Failure. ", "Fibre Optics Failure. ", "Voltage Failure. ",
	"Column Vacuum Failure (Soft Servo, Capstan Speed or Col Sensor). ", "Load/Unload Failure. ",
	"Speed Status (<95% or >105%). ", "GCR AGC @ Max while SIG AMP below reference. ");

	     anlzd = 0;
	     substr (int_status, 1, 4) = substr (raw_status, 1, 4);
	     substr (int_status, 5, 1) = substr (raw_status, 8, 1);
	     substr (int_status, 6, 4) = substr (raw_status, 49, 4);
	     substr (int_status, 10, 8) = substr (raw_status, 57, 8);
	     substr (int_status, 18, 1) = substr (raw_status, 103, 1);
	     substr (int_status, 19, 1) = substr (raw_status, 118, 1);

	     if substr (int_status, 2, 1) = "1"b then do;
		anlzd = anlzd + 1;
		a_tape_analysis.anal (anlzd) = trans_table_mth610 (2);
		a_is_interesting = "1"b;
		end;


	     if substr (int_status, 4, 1) = "1"b then do;
		anlzd = anlzd + 1;
		a_tape_analysis.anal (anlzd) = trans_table_mth610 (4);
		a_is_interesting = "1"b;
		end;


	     if substr (int_status, 3, 1) = "1"b then do;
		anlzd = anlzd + 1;
		a_tape_analysis.anal (anlzd) = trans_table_mth610 (3);
		a_is_interesting = "1"b;
		end;


	     if substr (int_status, 1, 1) = "1"b then do; /* dev fault */
		anlzd = anlzd + 1;
		a_tape_analysis.anal (anlzd) = trans_table_mth610 (1);

		do i = 10 to 17;
		     if substr (int_status, i, 1) = "1"b then do;
			anlzd = anlzd + 1;
			a_tape_analysis.anal (anlzd) = trans_table_mth610 (i);
			a_is_interesting = "1"b;
			end;
		end;
		go to end_mth610_attn;
		end;				/* end dev fault checks */

	     if substr (int_status, 5, 1) = "1"b then do; /* margin condition */
		anlzd = anlzd + 1;
		a_tape_analysis.anal (anlzd) = trans_table_mth610 (5);

		do i = 6 to 9;
		     if substr (int_status, i, 1) = "1"b then do;
			anlzd = anlzd + 1;
			a_tape_analysis.anal (anlzd) = trans_table_mth610 (i);
			a_is_interesting = "1"b;
			end;
		end;

		if substr (int_status, 18, 1) = "1"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = trans_table_mth610 (18);
		     a_is_interesting = "1"b;
		     end;
		end;				/* end margin cond checks */

	     if substr (int_status, 19, 1) = "1"b then do;
		anlzd = anlzd + 1;
		a_tape_analysis.anal (anlzd) = trans_table_mth610 (19);
		a_is_interesting = "1"b;
		end;


end_mth610_attn:
	end;					/* end begin block for mth610 */
	go to fill_struct;
%page;
/* Routine to analyze detail status for the MTUMPT (STC) tape drive */

dev_model (640):
	begin;

dcl  raw_status bit (208) based (addr (det_stats));
dcl  int_status bit (18);
dcl  CODE char (2) init ("");
dcl  trans_table_mth640 (17) char (31) varying internal static options (constant)
	init ("Device Fault: ", "Command Code Error. ", "Command Even Parity: ", "Signal Fault:",
	"Multiple BOT Status. ", "Marginal Condition: ", "Write Current Failure. ", "Erase Current Failure. ",
	"Air Pressure/Vacuum Failure. ", "Door Open. ", "Regulated Voltage Missing. ", "Un-Regulated Voltage Missing. ",
	"Processor Failure. ", "Incorrect Speed Detected. ", "Marginal Gap. ", "Marginal Air Bearing Pressure. ",
	"Marginal Voltage. ");

dcl  sub_test1 (7) char (21) var int static options (constant)
	init ("Load Fault. ", "Unload Fault. ", "Write Inhibit Fault. ", "Multiple BOT Fault. ", "Runaway Fault. ",
	"Rewind Fault. ", "Z-80 Interrupt. ");


	     anlzd = 0;
	     substr (int_status, 1, 2) = substr (raw_status, 1, 2);
	     substr (int_status, 3, 1) = substr (raw_status, 16, 1);
	     substr (int_status, 4, 2) = substr (raw_status, 3, 2);
	     substr (int_status, 6, 1) = substr (raw_status, 8, 1);
	     substr (int_status, 7, 3) = substr (raw_status, 49, 3);
						/* ^(door closed) */
	     substr (int_status, 10, 1) = ^(substr (raw_status, 52, 1));
	     substr (int_status, 11, 2) = substr (raw_status, 57, 2);
	     substr (int_status, 13, 1) = substr (raw_status, 80, 1);
	     substr (int_status, 14, 3) = substr (raw_status, 41, 3);
	     substr (int_status, 17, 1) = substr (raw_status, 59, 1);


	     if substr (int_status, 1, 1) = "1"b then do; /* dev fault */
		anlzd = anlzd + 1;
		a_tape_analysis.anal (anlzd) = trans_table_mth640 (1);

		do i = 7 to 14;
		     if substr (int_status, i, 1) = "1"b then do;
			anlzd = anlzd + 1;
			a_tape_analysis.anal (anlzd) = trans_table_mth640 (i);
			a_is_interesting = "1"b;
			end;
		end;
		if substr (raw_status, 62, 3) ^= "0"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = sub_test1 (bin (substr (raw_status, 62, 3), 3));
		     end;
		if substr (raw_status, 65, 8) ^= "0"b then do;
		     anlzd = anlzd + 1;
		     call ioa_$rsnnl ("^2.4b", CODE, 2, substr (raw_status, 65, 8));
		     a_tape_analysis.anal (anlzd) = "FAULT CODE = " || CODE;
		     end;


		go to end_mth640_attn;		/* other faults do not matter */
		end;				/* end dev fault checks */


	     if substr (int_status, 6, 1) = "1"b then do; /* margin condition */
		anlzd = anlzd + 1;
		a_tape_analysis.anal (anlzd) = trans_table_mth640 (6);

		do i = 15 to 17;
		     if substr (int_status, i, 1) = "1"b then do;
			anlzd = anlzd + 1;
			a_tape_analysis.anal (anlzd) = trans_table_mth640 (i);
			a_is_interesting = "1"b;
			end;
		end;
		end;


	     do i = 2 to 3;				/* check command errors */
		if substr (int_status, i, 1) = "1"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = trans_table_mth640 (i);
		     a_is_interesting = "1"b;
		     end;
	     end;


	     if substr (int_status, 5, 1) = "1"b then do; /* multiple bot? */
		anlzd = anlzd + 1;
		a_tape_analysis.anal (anlzd) = trans_table_mth640 (5);
		a_is_interesting = "1"b;
		end;


	     if substr (int_status, 4, 1) = "1"b then do; /* signal fault ? */
		anlzd = anlzd + 1;
		a_tape_analysis.anal (anlzd) = trans_table_mth640 (4);
		a_is_interesting = "1"b;
		end;


end_mth640_attn:
	end;					/* end begin block for mth640 */
end_attn:
	go to fill_struct;
%page;

data_alert:
dcl  rc_misc_reg (8) char (25) varying internal static options (constant)
	init ("C2 1. ", "C2 0. ", "Illeg Code Conv Char. ", "", "Lateral Parity Err. ", "RC Reg R3 Par Err. ",
	"RC Reg R4 Par Err. ", "Data Out Par Err. ");

dcl  FRAME_DROP char (18) init ("----FRAME DROP----");

	anlzd = 0;


	if mpc_model < 601
	then					/* mpc ext stats bytes 16-25 valid only for 601/610 */
	     go to fill_struct;			/* not mtc500 */

	if curr_dens ^= "nr" then go to not_nrzi;

Dens (800):					/* NRZI Decode */
	ext_ptr = addr (det_stats);


	if curr_mode ^= "W"
	then					/* write treated differently */
	     go to nrzi_read;
nrzi_write:					/* **************************************************************************
						   *   join the hi and lo clip error bytes to their respective parity bits   *
						   *   for an xor compare of which bit(s) didn't make it		         *
						   ************************************************************************** */
	str1 = substr (ext_stats (19), 1, 8) || substr (ext_stats (18), 2, 1);
	str2 = substr (ext_stats (20), 1, 8) || substr (ext_stats (18), 3, 1);
	str3 = bool (str1, str2, "0110"b);		/* XOR to get diff */
	if str3 = "0"b then go to nrzi_read;

	anlzd = anlzd + 1;
	a_tape_analysis.anal (anlzd) = "HI/LO Clip compare error. ";

	if tks = 0
	then					/* 7 track drive */
	     do j = 3 to 9;
	     if substr (str3, j, 1) = "1"b then do;
		substr (a_tape_analysis.trks_in_err, trk7_idx (j), 2) = trk7_tbl (j);
		a_tape_analysis.dbie_array (j) = 1;
		end;
	end;

	else do j = 1 to 9;				/* same thing for 9 track */
	     if substr (str3, j, 1) = "1"b then do;
		substr (a_tape_analysis.trks_in_err, trk9_idx (j), 2) = trk9_tbl (j);
		a_tape_analysis.dbie_array (j) = 1;
		end;
	end;

	go to end_tkie_sum;

nrzi_read:
	str1 = substr (ext_stats (17), 1, 8) || substr (ext_stats (18), 1, 1);

	if tks = 0 then do;
	     if str1 = fdmask7 then do;
		anlzd = anlzd + 1;
		a_tape_analysis.anal (anlzd) = "Frame Drop. ";
		a_tape_analysis.trks_in_err = FRAME_DROP;
		go to end_tkie_sum;
		end;

	     else do j = 3 to 9;
		if substr (str1, j, 1) = "1"b then do;
		     substr (a_tape_analysis.trks_in_err, trk7_idx (j), 2) = trk7_tbl (j);
		     a_tape_analysis.dbie_array (j) = 1;
		     end;
	     end;
	     end;

	else do;					/* must be a 9 track drive */

	     if str1 = fdmask9 then do;
		a_tape_analysis.trks_in_err = FRAME_DROP;
		anlzd = anlzd + 1;
		a_tape_analysis.anal (anlzd) = "Frame Drop. ";
		go to end_tkie_sum;
		end;

	     else do j = 1 to 9;
		if substr (str1, j, 1) = "1"b then do;
		     substr (a_tape_analysis.trks_in_err, trk9_idx (j), 2) = trk9_tbl (j);
		     a_tape_analysis.dbie_array (j) = 1;
		     end;
	     end;
	     end;

	go to end_tkie_sum;


not_nrzi:
Dens (6250):					/* Group Code Recording (GCR) decode */
Dens (1600):					/* Phase Encoded (PE) Decode */
	ext_ptr = addr (det_stats);
	anlzd = 0;


	if curr_dens = "gc" then do;

	     if substr (ext_stats (15), 6, 1) = "1"b then do;
		anlzd = anlzd + 1;
		a_tape_analysis.anal (anlzd) = "GCR AGC @ Max while SIG AMP below reference. ";
		a_is_interesting = "1"b;
		end;

	     if substr (ext_stats (20), 3, 1) = "1"b then do;
		anlzd = anlzd + 1;
		a_tape_analysis.anal (anlzd) = "3 or more tracks in error. ";
		go to ck_skew;
		end;

	     if substr (ext_stats (20), 2, 1) = "1"b then do;
		anlzd = anlzd + 1;
		a_tape_analysis.anal (anlzd) = "2 tracks in error. ";
		go to ck_skew;
		end;

	     if substr (ext_stats (20), 1, 1) = "1"b then do;
		anlzd = anlzd + 1;
		a_tape_analysis.anal (anlzd) = "1 track in error. ";
		end;



ck_skew:
	     if curr_mode = "W" then do;

		if substr (ext_stats (20), 5, 1) = "1"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = "10 Chars of Skew. ";
		     go to decode_tkie;
		     end;

		if substr (ext_stats (20), 4, 1) = "1"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = "5 Chars of Skew. ";
		     go to decode_tkie;
		     end;
		end;

	     else if curr_mode = "R" then do;
		if substr (ext_stats (20), 6, 1) = "1"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = "25 Chars of Skew. ";
		     go to decode_tkie;
		     end;
		end;
	     end;					/* end 6250 specifics */



	if (mpc_model = 610) & (curr_dens = "pe") then do;

	     if substr (ext_stats (23), 7, 1) = "1"b then do;
		anlzd = anlzd + 1;
		if curr_mode = "R"
		then a_tape_analysis.anal (anlzd) = "PE Multi-Track Err. ";
		else a_tape_analysis.anal (anlzd) = "PE Single-Track Err. ";
		end;


	     if curr_mode ^= "W" then go to decode_tkie;

	     if substr (ext_stats (23), 8, 1) = "1"b then do;
		anlzd = anlzd + 1;
		a_tape_analysis.anal (anlzd) = "PE Buffer Overload. ";
		go to decode_tkie;
		end;


	     end;


	else if mpc_model = 601
	then if substr (ext_stats (21), 4, 1) = "0"b then do;

		if curr_mode ^= "W" then go to decode_tkie;

		anlzd = anlzd + 1;
		a_tape_analysis.anal (anlzd) = "PE Write Window Err. ";
		go to decode_tkie;
		end;

decode_tkie:
	str1 = substr (ext_stats (17), 1, 8) || substr (ext_stats (18), 1, 1);

	if str1 = fdmask9 then do;
	     a_tape_analysis.trks_in_err = FRAME_DROP;
	     anlzd = anlzd + 1;
	     a_tape_analysis.anal (anlzd) = "Frame Drop. ";
	     go to end_tkie_sum;
	     end;

	do j = 1 to 9;				/* must have valid tkie data, get it */
	     if substr (str1, j, 1) = "1"b then do;
		substr (a_tape_analysis.trks_in_err, trk9_idx (j), 2) = trk9_tbl (j);
		a_tape_analysis.dbie_array (j) = 1;
		end;
	end;
end_tkie_sum:
	if mpc_model = 610 then do;

	     if substr (ext_stats (21), 3, 1) = "1"b then do;
		anlzd = anlzd + 1;
		a_tape_analysis.anal (anlzd) = "DOS Drop. ";
		end;

	     if substr (ext_stats (22), 7, 1) = "1"b then do;
		anlzd = anlzd + 1;
		a_tape_analysis.anal (anlzd) = "Echo-Read Dropout. ";
		end;


	     if substr (ext_stats (23), 6, 1) = "1"b then do;
		anlzd = anlzd + 1;
		a_tape_analysis.anal (anlzd) = "TTE MTH->MPC. ";
		end;


/* now check the IE register */

	     if substr (ext_stats (26), 4, 1) = "1"b then do;
		anlzd = anlzd + 1;
		a_tape_analysis.anal (anlzd) = "DO Parity Err. ";
		a_is_interesting = "1"b;
		end;


	     if substr (ext_stats (26), 7, 1) = "1"b then do;
		anlzd = anlzd + 1;
		a_tape_analysis.anal (anlzd) = "Write Buffer Parity Err. ";
		a_is_interesting = "1"b;
		end;


	     if substr (ext_stats (26), 8, 1) = "1"b then do;
		anlzd = anlzd + 1;
		a_tape_analysis.anal (anlzd) = "RO Parity Err. ";
		a_is_interesting = "1"b;
		end;


	     do j = 6 to 8;				/* check RC misc register */
		if substr (ext_stats (24), j, 1) = "1"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = rc_misc_reg (j);
		     a_is_interesting = "1"b;
		     end;
	     end;


/* Bypass the next check until HW eng define the meaning of these bits

   do j = 1 to 4;			 now do the RC board id
   if substr (ext_stats (25), (j+4), 1) = "1"b then do;
   anlzd = anlzd +1;
   a_tape_analysis.anal (anlzd) =
   rc_bd_id (j);
   end;
*/


	     end;					/* end mtp610 specifics */


	else if mpc_model = 601 then do;		/* check mtp601 specifics */

	     if substr (ext_stats (21), 2, 1) = "1"b then do;
		anlzd = anlzd + 1;
		a_tape_analysis.anal (anlzd) = "TTE MTH->MPC. ";
		end;


	     if substr (ext_stats (21), 3, 1) = "1"b then do;
		anlzd = anlzd + 1;
		a_tape_analysis.anal (anlzd) = "Illegal Char. ";
		end;


	     if curr_dens = "nr" then do;

		if substr (ext_stats (22), 1, 1) = "1"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = "Hi Clip Parity Err. ";
		     a_is_interesting = "1"b;
		     end;


		if substr (ext_stats (22), 2, 1) = "1"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = "Lo Clip Parity Err. ";
		     a_is_interesting = "1"b;
		     end;
		end;


	     else if curr_dens = "pe" then do;
		if substr (ext_stats (21), 5, 1) = "1"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = "Skew Error. ";
		     end;


		if substr (ext_stats (21), 6, 1) = "1"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = "Postamble Error. ";
		     end;

		if substr (ext_stats (22), 2, 1) = "1"b then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = "PE Deskew Char Parity Bit Err. ";
		     end;
		end;

	     end;					/* mtp601 specifics */

fill_struct:
	number_analyzed = anlzd + 1;

	if (^rsnnl_sw & ^rs_sw) then do;
	     call hcs_$make_seg ("", "analyze_detail_stat_.temp", "", 10, tape_analp, xcode);
	     auto_analp = tape_analp;
	     tape_analysis.tape_analysis_version = analyze_det_stat_info_version_2;
	     tape_analysis.num_analyzed = anlzd;
	     tape_analysis.is_interesting_tape = a_is_interesting;
	     tape_analysis.fips_controller = fips_controller;
	     tape_analysis.pad = ""b;
	     tape_analysis.mth_model = a_tape_analysis.mth_model;
	     tape_analysis.num_tracks = a_tape_analysis.num_tracks;
	     tape_analysis.tracks_in_error = a_tape_analysis.trks_in_err;
	     tape_analysis.dbie_array = a_tape_analysis.dbie_array;
	     tape_analysis.density = a_tape_analysis.density;
	     tape_analysis.operation = a_tape_analysis.operation;

	     if number_analyzed > 0
	     then do j = 1 to number_analyzed;
		tape_analysis.analyses (j) = a_tape_analysis.anal (j);
	     end;

	     else tape_analysis.analyses (*) = "";
	     return;
	     end;


	if (rsnnl_sw | rs_sw) then do;
	     if a_is_interesting
	     then do j = 1 to number_analyzed;
		message = message || a_tape_analysis.anal (j);
	     end;
	     if message ^= "" then do;
		if rs_sw then message = message || NEW_LINE;
		is_interesting = a_is_interesting;
		end;
	     else is_interesting = "0"b;
	     end;
	return;
%page;
anal_fips_tape_:
	proc;

dcl  (dev_no, dev_no_idx) fixed bin;
dcl  (ft_in_pe, ft_can_run_6250) bit (1) init ("0"b);
dcl  ft_general_err_bits bit (8) init (""b);
dcl  ft_unit_err_bits bit (9) init (""b);
dcl  ft_data_err_bits bit (23) init (""b);

dcl  ft_general_table (8) char (65) varying internal static options (constant)
	init ("Command Reject ", "Bus Out Check ", "Equipment Check ", "Reject Tape Unit ", "EOT Mark Detected ",
	"Tape Unit Check ", "Channel Buffer Check ", "Command Status Reject ");

dcl  ft_unit_table (9) char (65) varying internal static options (constant)
	init ("Intervention Required ", "Micro Hardware Check ", "Column Out ", "File Column Check ",
	"Machine Column Check ", "Reset Key ", "Load Check ", "Tach Start Failure ", "Velocity Check ");

dcl  ft_data_table (23) char (65) varying internal static options (constant)
	init ("Data Check ", "Overrun ", "Word Count Zero ", "Noise ", "Not Capable ", "R/W VRC ", "MTE/LRC ",
	"Skew Error ", "EDC/CRC ", "ENV/ECC ", "C/P Compare ", "Write VRC ", "WTM Check ", "ID Burst Check ",
	"Partial Record ", "Postamble Error ", "Write Check ", "DSE Check ", "Erase Check ", "IBG Detected ",
	"Velocity Change ", "CRC III ", "Record NOT Detected ");

	     a_tape_analysis.num_tracks = 9;		/* all are 9-track */
	     dev_no = cv_dec_check_ (substr (name, 6, 2), code);
	     dev_no_idx = 0;
	     do j = 1 to 5 while (a_tape_analysis.mth_model = "");
		dev_no_idx = dev_no_idx + prph_tap_card.ndrives (j);
		if dev_no < dev_no_idx
		then a_tape_analysis.mth_model = "MTU" || ltrim (char (prph_tap_card.model (j)));
	     end;

	     ft_in_pe = substr (det_stats, 30, 1);
	     ft_can_run_6250 = substr (det_stats, 77, 1);
	     if ft_in_pe then a_tape_analysis.density = 1600;
	     else if ft_can_run_6250 then a_tape_analysis.density = 6250;
	     else a_tape_analysis.density = 800;

	     substr (ft_general_err_bits, 1, 1) = substr (det_stats, 1, 1);
	     substr (ft_general_err_bits, 2, 2) = substr (det_stats, 3, 2);
	     substr (ft_general_err_bits, 4, 2) = substr (det_stats, 34, 2);
	     substr (ft_general_err_bits, 6, 1) = substr (det_stats, 39, 1);
	     substr (ft_general_err_bits, 7, 1) = substr (det_stats, 75, 1);
	     substr (ft_general_err_bits, 8, 1) = substr (det_stats, 81, 1);

	     substr (ft_unit_err_bits, 1, 1) = substr (det_stats, 2, 1);
	     substr (ft_unit_err_bits, 2, 1) = substr (det_stats, 33, 1);
	     substr (ft_unit_err_bits, 3, 4) = substr (det_stats, 57, 4);
	     substr (ft_unit_err_bits, 7, 1) = substr (det_stats, 64, 1);
	     substr (ft_unit_err_bits, 8, 1) = substr (det_stats, 86, 1);
	     substr (ft_unit_err_bits, 9, 1) = substr (det_stats, 88, 1);

	     substr (ft_data_err_bits, 1, 3) = substr (det_stats, 5, 3);
	     substr (ft_data_err_bits, 4, 1) = substr (det_stats, 9, 1);
	     substr (ft_data_err_bits, 5, 1) = substr (det_stats, 16, 1);
	     substr (ft_data_err_bits, 6, 5) = substr (det_stats, 25, 5);
	     substr (ft_data_err_bits, 11, 1) = substr (det_stats, 32, 1);
	     substr (ft_data_err_bits, 12, 1) = substr (det_stats, 36, 1);
	     substr (ft_data_err_bits, 13, 2) = substr (det_stats, 43, 2);
	     substr (ft_data_err_bits, 15, 2) = substr (det_stats, 46, 2);
	     substr (ft_data_err_bits, 17, 1) = substr (det_stats, 50, 1);
	     substr (ft_data_err_bits, 18, 2) = substr (det_stats, 61, 2);
	     substr (ft_data_err_bits, 20, 1) = substr (det_stats, 65, 1);
	     substr (ft_data_err_bits, 21, 1) = substr (det_stats, 74, 1);
	     substr (ft_data_err_bits, 22, 1) = substr (det_stats, 76, 1);
	     substr (ft_data_err_bits, 23, 1) = substr (det_stats, 84, 1);

	     if ft_general_err_bits
	     then do i = 1 to 8;
		if substr (ft_general_err_bits, i, 1) then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = ft_general_table (i);
		     a_is_interesting = "1"b;
		     end;
	     end;

	     if ft_unit_err_bits
	     then do i = 1 to 9;
		if substr (ft_unit_err_bits, i, 1) then do;
		     anlzd = anlzd + 1;
		     a_tape_analysis.anal (anlzd) = ft_unit_table (i);
		     a_is_interesting = "1"b;
		     end;
	     end;

	     if ft_data_err_bits then do;
		if substr (det_stats, 14, 1)
		then a_tape_analysis.operation = "Write";
		else a_tape_analysis.operation = "Read";
		do i = 1 to 23;
		     if substr (ft_data_err_bits, i, 1) then do;
			anlzd = anlzd + 1;
			a_tape_analysis.anal (anlzd) = ft_data_table (i);
			a_is_interesting = "1"b;
			end;
		end;

		str1 = substr (det_stats, 17, 8) ||	/* add on P track check */
		     (^ft_in_pe & ^substr (det_stats, 14, 1) & (substr (det_stats, 17, 8) = ""b));
		if ^ft_in_pe & (substr (det_stats, 17, 8) = "03"b4)
		then a_tape_analysis.trks_in_err = "-Track Not Found-";
		else do j = 1 to 9;
		     if substr (str1, j, 1) = "1"b then do;
			substr (a_tape_analysis.trks_in_err, trk9_idx (j), 2) = trk9_tbl (j);
			a_tape_analysis.dbie_array (j) = 1;
			end;
		end;
		end;
	     if a_is_interesting & substr (det_stats, 177, 8) ^= ""b then do;
		anlzd = anlzd + 1;
		call ioa_$rsnnl ("Symptom_code=^2.4b ", a_tape_analysis.anal (anlzd), 16, substr (det_stats, 177, 8));
		end;
	     return;
	end anal_fips_tape_;
     end anal_tape_;
%page;
find_controller:
     proc (a_iom, a_chan);
dcl  a_iom fixed bin (3);
dcl  a_chan fixed bin (8);

	fips_controller = "0"b;
	ipc_cardp = null ();
	mpc_cardp = null ();
	do while ("1"b);
	     call config_$find (MPC_CARD_WORD, mpc_cardp);
	     if mpc_cardp = null () then goto check_for_fips;
	     do i = 1 to hbound (mpc_card.port, 1) while (mpc_card.port (i).iom ^= -1);
		if (a_iom = mpc_card.port (i).iom) & (a_chan >= mpc_card.port (i).chan)
		     & (a_chan < mpc_card.port (i).chan + mpc_card.port (i).nchan)
		then return;
	     end;
	end;

check_for_fips:
	do while ("1"b);
	     call config_$find (IPC_CARD_WORD, ipc_cardp);
	     if ipc_cardp = null () then return;
	     if ipc_card.type = IPC_FIPS then do;
		if (a_iom = ipc_card.iom) & (a_chan >= ipc_card.chan) & (a_chan < ipc_card.chan + ipc_card.nchan)
		then do;
		     fips_controller = "1"b;
		     return;
		     end;
		end;
	end;
     end find_controller;
%page;
%include access_mode_values;
%page;
%include analyze_det_stat_info;
%page;
%include config_ipc_card;
%page;
%include config_mpc_card;
%page;
%include config_prph_card;
%page;
%include config_prph_tap_card;
%page;
%include config_prph_dsk_card;

     end analyze_detail_stat_;

