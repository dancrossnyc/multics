/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(86-06-04,Hartogs), approve(86-06-04,MCR7383),
     audit(86-06-05,Coppola), install(86-07-18,MR12.0-1098):
     Changed to user version constants in rcp_disk_info.incl.pl1,
     rcp_device_info.incl.pl1, and rcp_printer_info.incl.pl1.
                                                   END HISTORY COMMENTS */


/* TEST_DCW: a program to build dcw lists to test an I/O device */

/* Written in bits and pieces from 1975 to March 1977 by Larry Johnson */
/* Modified August 1977 by Larry Johnson to automatically supply device address in idcws */
/* Modified December 1978 by Michael R. Jordan for version 2 tape info */
/* Modified January 1980 by Larry Johnson for get_detailed_status and get_spacial_status commands */

test_dcw: proc;

/* Automatic storage */

dcl  dcw_list (32, 32) bit (36);			/* A table of 32 different lists */
dcl  pcw_list (32) bit (36);				/* One PCW for each list */
dcl  list fixed bin init (1);				/* The "current" list */
dcl  idx fixed bin init (1);				/* Position in the current list */
dcl  dcw_len (32) fixed bin;				/* Length of each list */
dcl  input_line char (132);				/* A command line read from the terminal */
dcl  input_len fixed bin (21);			/* The actual length of that line */
dcl  input_pos fixed bin;				/* The current char position in scanning input_line */
dcl  word char (132);				/* A word extracted from the input line */
dcl  code fixed bin (35);				/* A standard system status code */
dcl  temp_char char (1);				/* To hold 1 character */
dcl (i, j) fixed bin;				/* A temporary index */
dcl  end_line bit (1);				/* Set when end of line reached */
dcl  octal_word bit (1);				/* Set if current word will convert to octal */
dcl  octal_val fixed bin (35);			/* Value of current word if converted to octal */
dcl  dec_word bit (1);				/* Set if word will convert to decimal */
dcl  dec_val fixed bin (35);				/* Value if convert to decimal */
dcl  insert_mode bit (1) init ("0"b);			/* Set if insert mode, reset if replace mode */
dcl  output_line char (128) var;			/* For building line to print */
dcl  out_temp char (64) var;				/* Temp area for building output strings */
dcl  pcw_sw bit (1);				/* Set if pcw is being built */
dcl  devx fixed bin init (-1);			/* Ioi device index */
dcl  exec_rept_cnt fixed bin;				/* Count of repeated executions */
dcl (dp_loc, dp_len, dp_rpt) fixed bin;			/* Indexes for dumps and patches */
dcl  dp_byte bit (1);				/* Set when dumping binary bytes */
dcl  arg_cnt fixed bin;				/* Number of command arguments */
dcl  arg_ptr ptr;					/* A pointer to a command argument */
dcl  arg_len fixed bin;				/* The length of that argument */
dcl  arg char (arg_len) based (arg_ptr);		/* Hence, this is the argument */
dcl  survey_ptr ptr;				/* Pointer to survey devices data */
dcl  time_limit fixed bin (52);			/* Connect time limit - 30 seconds initially */
dcl  dev_name char (16) varying;			/* This will be name of device assigned */
dcl  dev_type char (16) varying;			/* Generic device type */
dcl  id_name char (16) varying;			/* This will be the pack id or tape volume */
dcl  priv_sw bit (1) init ("0"b);			/* Will be 1 if -priv specified */
dcl  write_sw bit (1) init ("1"b);			/* Will be "0" if -read specified */
dcl  debug_sw bit (1) init ("0"b);			/* Set if -db used */
dcl  prompt_msg char (10) varying init ("");		/* Promt character for command input */
dcl  rcp_id bit (36) aligned init ("0"b);		/* RCP_ attachment id */
dcl  rcp_state fixed bin;				/* State code returned by rcp_$check_attach */
dcl  max_time fixed bin (71);				/* Max time limit for connects */
dcl  max_work fixed bin (19);				/* Max buffer size supported by ioi_ */
dcl  rcp_info_ptr ptr;				/* Pointer to the rcp info block being used */
dcl  sys_sw bit (1) init ("0"b);			/* Set if -sys control argument specified */
dcl  list_name (32) char (8);				/* Names of dcs lists */
dcl  new_name char (8);
dcl  dcw_word bit (36) aligned;			/* Dcws are built here */
dcl  something_printed bit (1);
dcl  track_sw bit (1) aligned init ("0"b);		/* "1"b if -7track specified */
dcl  exec_spec_sw bit (1);				/* Set when exec command requires special */
dcl  exec_no_err_sw bit (1);				/* Set when exec command to ignore error */
dcl  exec_rept_sw bit (1);				/* Set when executing in repeat mode */
dcl  iom fixed bin (3);				/* Required iom number if chan command used */
dcl  chan fixed bin (6);				/* Required channel if chan command used */
dcl  ptr_array (1) ptr init (null);			/* For get temp segments */
dcl  new_work_size fixed bin (18);
dcl  flush_sw bit (1);
dcl  dir char (168);
dcl  unsuffixed_ename char (32);
dcl  ename char (32);
dcl  time_string char (24);
dcl  status_tablep ptr;				/* Address of appropriate status table */
dcl  status_mode fixed bin init (1);			/* 1=brief, 2=long, 3=edited */
dcl  save_status_mode fixed bin;
dcl  default_device bit (6);				/* Device number to put in all idcws */
dcl  stat_found bit (1) aligned;
dcl  spec_status bit (36) aligned;
dcl  detailed_status bit (6*36);
dcl  detailed_status_array (1:27) bit (8) unal based (addr (detailed_status));

dcl 1 my_tape_info like tape_info aligned automatic;	/* Copy of rcp_tape_info in my stack */
dcl 1 my_disk_info like disk_info aligned automatic;	/* Copy of rcp_disk_info in my stack */
dcl 1 my_printer_info like printer_info aligned automatic;	/* Copy of rcp_printer_info in my stack */
dcl 1 my_device_info like device_info aligned automatic;	/* Copy of rcp_device_info in my stack */

/* Format of detailed status returned by mtc500 handler */

dcl  dtstp ptr;					/* Pointer to the structure */

dcl 1 dt_stat aligned based (dtstp),			/* The detailed status structure */
						/* ... Byte # 0 ... */
   (2 devflt bit (1),				/* Device Fault */
    2 ccerr bit (1),				/* Command code error */
    2 rawerr bit (1),				/* Read-after_write error */
    2 mbot bit (1),					/* Multiple BOTs */
    2 bot bit (1),					/* BOT */
    2 eot bit (1),					/* EOT */
    2 standby bit (1),				/* Standby state */
    2 marg bit (1),					/* Marginal condition */
						/* ... Byte # 1 ... */
    2 loaded bit (1),				/* Loaded (standby) */
    2 lcw bit (1),					/* Last command write */
    2 lcf bit (1),					/* Last command forward */
    2 rewind bit (1),				/* Rewinding */
    2 wpr bit (1),					/* Write permit ring */
    2 spr bit (1),					/* Software write permit */
    2 diag bit (1),					/* Diagnostic mode */
    2 ccpe bit (1),					/* Command code parity even */
						/* ... Byte # 2 ... */
    2 denr bit (3),					/* Density return */
    2 lowt bit (1),					/* Low threshold */
    2 denc bit (4),					/* Recording capability */
						/* ... Byte # 3 ... */
    2 speed bit (5),				/* Device speed */
    2 track bit (1),				/* 7/9 channel */
    2 nsbot bit (1),				/* Non-standard BOT */
    2 mbz1 bit (1),					/* Must be zero */
						/* ... Byte # 4 ... */
    2 dms bit (1),					/* Device multiple select */
    2 mbz2 bit (2),					/* Must be zero */
    2 addr bit (5)) unal;				/* Physical device address */

dcl  speed_constant (0:15) char (5) var int static options (constant) init ("16", "18.75", "24", "25", "35", "37.5",
     "45", "48", "70", "75", "80", "105", "120", "125", "150", "200");

dcl 1 survey_table (16) unaligned based (survey_ptr),	/* Tape data returned by survey devices */
   (2 pad1 bit (1),
    2 hand_resv bit (1),				/* Handler reserved */
    2 hand_op bit (1),				/* Handler operational */
    2 hand_ready bit (1),				/* Handler ready */
    2 hand_addr bit (5),				/* Handler address */
    2 pad2 bit (1),
    2 hand_speed bit (3),				/* Handler speed */
    2 hand_track bit (1),				/* 7/9 track code */
    2 hand_record bit (4)) unaligned;			/* Handler recording capability */

/* Ioi buffer area */

dcl  workp ptr;					/* Pointer to it */
dcl  work_size fixed bin (18) init (1024);		/* Size of segment */
dcl  work_seg (work_size) bit (36) aligned based (workp);	/* The ioi workspace buffer */
						/* Words 1 to 32 reserved for dcw list */
						/* Words 33 to 64 reserved for status queue */

dcl  byte_ptr ptr;					/* Pointer to bytes in work area */
dcl  nbytes fixed bin;				/* Number of bytes in question */

dcl 1 bin_bytes aligned based (byte_ptr),
    2 bbyte (nbytes) bit (8) unaligned;			/* An array of bytes */

dcl 1 event_list,					/* A list of ipc events */
    2 ev_count fixed bin init (1),			/* Always 1 entry */
    2 ev_chan fixed bin (71) init (-1);			/* And this is it */

dcl 1 event_info,					/* Structure returned by ipc */
    2 channel_id fixed bin (71),
    2 message fixed bin (71),
    2 sender bit (36),
    2 origin,
      3 dev_signal bit (18) unaligned,
      3 ring bit (18) unaligned,
    2 channel_index fixed bin;


/* Structure define a segment where test_dcw data is saved */

dcl  save_segp ptr init (null);

dcl 1 save_seg aligned based (save_segp),
    2 version fixed bin,
    2 code char (16),
    2 time fixed bin (71),
    2 pcw_list (32) bit (36) aligned,
    2 dcw_len (32) fixed bin,
    2 list_name (32) char (8),
    2 dcw_list (32, 32) bit (36) aligned;

dcl  save_seg_code char (16) int static options (constant) init ("*test_dcw data*");

%include ioi_stat;

/* Areas for handling status */

dcl 1 stat like istat aligned automatic;		/* Ioi_stat structure in my stack */
dcl 1 status_queue (4) like istat aligned based (sqptr);	/* Status queue in ioi buffer */
dcl  sqptr ptr;					/* Pointer to status queue */
dcl  status_index fixed bin;				/* Current status queue entry */


%include iom_stat;


%include rcp_tape_info;

%include rcp_disk_info;

%include rcp_printer_info;

%include rcp_resource_types;

%include rcp_device_info;

%include iom_pcw;
%include iom_dcw;

/* Constants */

dcl  new_line char (1) static init ("
");						/* A new_line character */
dcl  tab char (1) static init ("	");			/* A tab character */
dcl  cmd_name char (8) init ("test_dcw");		/* The name of this thing */

/* Entry constants */

dcl  com_err_ entry options (variable);
dcl  convert_ipc_code_ entry (fixed bin (35));
dcl  cu_$arg_count entry (fixed bin);
dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
dcl  cv_dec_check_ entry (char (*), fixed bin) returns (fixed bin (35));
dcl  cv_oct_check_ entry (char (*), fixed bin) returns (fixed bin (35));
dcl  ioa_ entry options (variable);
dcl  ioa_$nnl entry options (variable);
dcl  ioa_$rsnnl entry options (variable);
dcl  ioi_$connect entry (fixed bin, fixed bin, fixed bin (35));
dcl  ioi_$connect_pcw entry (fixed bin, fixed bin, bit (36), fixed bin (35));
dcl  ioi_$set_status entry (fixed bin, fixed bin (18), fixed bin (8), fixed bin (35));
dcl  ioi_$timeout entry (fixed bin, fixed bin (52), fixed bin (35));
dcl  ioi_$workspace entry (fixed bin, ptr, fixed bin (18), fixed bin (35));
dcl  iox_$get_line entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
dcl  ipc_$block entry (ptr, ptr, fixed bin (35));
dcl  ipc_$create_ev_chn entry (fixed bin (71), fixed bin (35));
dcl  ipc_$delete_ev_chn entry (fixed bin (71), fixed bin (35));
dcl  ipc_$read_ev_chn entry (fixed bin (71), fixed bin, ptr, fixed bin (35));
dcl  ipc_$drain_chn entry (fixed bin (71), fixed bin (35));
dcl  ioi_$release_devices entry (fixed bin, fixed bin (35));
dcl  ioi_$get_detailed_status entry (fixed bin, bit (1) aligned, bit (216), fixed bin (35));
dcl  ioi_$get_special_status entry (fixed bin, bit (1) aligned, bit (36) aligned, fixed bin (35));
dcl  ioi_$set_channel_required entry (fixed bin, fixed bin (3), fixed bin (6), fixed bin (35));
dcl  ioi_$suspend_devices entry (fixed bin, fixed bin (35));
dcl  rcp_$attach entry (char (*), ptr, fixed bin (71), char (*), bit (36) aligned, fixed bin (35));
dcl  rcp_$check_attach entry (bit (36) aligned, ptr, char (*), fixed bin, fixed bin (19), fixed bin (71),
     fixed bin, fixed bin (35));
dcl  rcp_$detach entry (bit (36) aligned, bit (*), fixed bin, char (*), fixed bin (35));
dcl  rcp_priv_$attach entry (char (*), ptr, fixed bin (71), char (*), bit (36) aligned, fixed bin (35));
dcl  get_temp_segments_ entry (char (*), dim (*) ptr, fixed bin (35));
dcl  release_temp_segments_ entry (char (*), dim (*) ptr, fixed bin (35));
dcl  expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35));
dcl  hcs_$initiate entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
dcl  suffixed_name_$make entry (char (*), char (*), char (32), fixed bin (35));
dcl  date_time_ entry (fixed bin (71), char (*));
dcl  hcs_$terminate_noname entry (ptr, fixed bin (35));
dcl  adjust_bit_count_ entry (char (168), char (32), bit (1) aligned, fixed bin (24), fixed bin (35));
dcl  hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
dcl  analyze_device_stat_$rsnnl entry (char (*) var, ptr, bit (72) aligned, bit (18) aligned);
dcl  parse_io_channel_name_ entry (char (*), fixed bin (3), fixed bin (6), fixed bin (35));

/* External symbols */

dcl  iox_$user_input ext pointer;
dcl  sys_info$max_seg_size ext fixed bin (18);

dcl  disk_status_table_$disk_status_table_ ext;
dcl  tape_status_table_$tape_status_table_ ext;
dcl  prt_status_table_$prt_status_table_ ext;
dcl  cpz_status_table_$cpz_status_table_ ext;
dcl  crz_status_table_$crz_status_table_ ext;
dcl  imp_status_table_$imp_status_table_ ext;

dcl  error_table_$badopt ext fixed bin (35);
dcl  error_table_$request_not_recognized ext fixed bin (35);

/* Built in functions */

dcl (addr, before, bin, binary, bit, clock, divide, hbound, length, max, min, null, string, substr, unspec) builtin;

dcl (cleanup, program_interrupt) condition;

/* Initialize some stuff first */

	dcw_list = "0"b;				/* Reset all dcw */
	pcw_list = "0"b;				/* Reset all pcws */
	dcw_len = 0;				/* And their lengths */
	list_name = "";				/* No lists have names */
	pcwp, idcwp, dcwp, tdcwp = addr (dcw_word);

	on cleanup call clean_up;

/* Scan argument list */

	call cu_$arg_count (arg_cnt);			/* First find out how many */
	dev_name = "";				/* Device is unknown now */
	id_name = "";				/* Pack or volume unknown */
	do i = 1 to arg_cnt;
	     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
	     if code ^= 0 then do;
		call com_err_ (code, cmd_name, "Arg ^d", i);
		go to quit;
	     end;
	     if substr (arg, 1, 1) ^= "-" then do;	/* If not control arg */
		if dev_name = "" then dev_name = arg;	/* If no device specified yet */
		else if id_name = "" then id_name = arg; /* May be id name */
		else do;
		     code = error_table_$request_not_recognized; /* Multiple devices */
arg_err:		     call com_err_ (code, cmd_name, "^a", arg);
		     go to quit;
		end;
	     end;
	     else if arg = "-priv" then priv_sw = "1"b;	/* If request for privileged attach */
	     else if arg = "-read" then write_sw = "0"b;	/* Switch to read-only mode */
	     else if arg = "-7tr" | arg = "-7track" then track_sw = "1"b;
	     else if arg = "-sys" then sys_sw = "1"b;
	     else if arg = "-debug" | arg = "-db" then debug_sw = "1"b;
	     else do;				/* Nothing else I recognize */
		code = error_table_$badopt;
		go to arg_err;
	     end;
	end;
	if dev_name = "" then dev_name = "tap";		/* Default device is tape */
	if debug_sw then do;
	     call get_temp_segments_ (cmd_name, ptr_array, code); /* Get segment for work area */
	     if code ^= 0 then do;
		call com_err_ (code, cmd_name, "Unable to allocate temp segment.");
		go to quit;
	     end;
	     workp = ptr_array (1);
	     max_work = sys_info$max_seg_size;
	     default_device = "0"b;
	     go to ready;
	end;

/* Now determine the device type to be assigned */

	if dev_name = DEVICE_TYPE (TAPE_DRIVE_DTYPEX) | dev_name = DEVICE_TYPE (DISK_DRIVE_DTYPEX) then /* Any tape, or any disk */
	     dev_type = dev_name;
	else if dev_name = "tap" then
	     dev_type, dev_name = DEVICE_TYPE (TAPE_DRIVE_DTYPEX);
	else if dev_name = "dsk" then			/* Alternate form of any disk */
	     dev_type, dev_name = DEVICE_TYPE (DISK_DRIVE_DTYPEX);
	else if dev_name = DEVICE_TYPE (PRINTER_DTYPEX) | dev_name = "prt" then /* Any printer */
	     dev_name, dev_type = DEVICE_TYPE (PRINTER_DTYPEX);
	else if dev_name = DEVICE_TYPE (READER_DTYPEX) | dev_name = "rdr" then /* Any reader */
	     dev_name, dev_type = DEVICE_TYPE (READER_DTYPEX);
	else if dev_name = DEVICE_TYPE (PUNCH_DTYPEX) | dev_name = "pun" then /* Any punch */
	     dev_name, dev_type = DEVICE_TYPE (PUNCH_DTYPEX);
	else if length (dev_name) > 3 then do;		/* May be specific device */
	     if substr (dev_name, 1, 3) = "prt" then	/* Specific printer */
		dev_type = DEVICE_TYPE (PRINTER_DTYPEX);
	     else if substr (dev_name, 1, 3) = "rdr" then /* Specific reader */
		dev_type = DEVICE_TYPE (READER_DTYPEX);
	     else if substr (dev_name, 1, 3) = "pun" then /* Specific punch */
		dev_type = DEVICE_TYPE (PUNCH_DTYPEX);
	     else if substr (dev_name, 1, 3) = "tap" then do; /* Specific tape */
		dev_type = DEVICE_TYPE (TAPE_DRIVE_DTYPEX);
		if length (dev_name) >= 7 then if substr (dev_name, 6, 2) = "00" then /* Tape mpc */
			dev_type = DEVICE_TYPE (SPECIAL_DTYPEX);
	     end;
	     else if substr (dev_name, 1, 3) = "dsk" then do; /* Specific disk */
		dev_type = DEVICE_TYPE (DISK_DRIVE_DTYPEX);
		if length (dev_name) >= 7 then if substr (dev_name, 6, 2) = "00" then /* New form disk mpc */
			dev_type = DEVICE_TYPE (SPECIAL_DTYPEX);
	     end;
	     else dev_type = DEVICE_TYPE (SPECIAL_DTYPEX); /* Don't recognize it */
	end;
	else dev_type = DEVICE_TYPE (SPECIAL_DTYPEX);	/* Don't recognize it */

/* Now assign some device as specified in the command */

	call ipc_$create_ev_chn (ev_chan, code);	/* First, I need a channel for interrupts */
	if code ^= 0 then do;
	     call convert_ipc_code_ (code);
	     call com_err_ (code, cmd_name, "Unable to create event channel");
	     go to quit;
	end;

	if dev_type = DEVICE_TYPE (TAPE_DRIVE_DTYPEX) then do; /* If tape requested */
	     tape_info_ptr = addr (my_tape_info);	/* Use my tape info block */
	     tape_info.version_num = tape_info_version_2; /* And initialize it */
	     tape_info.usage_time = 0;
	     tape_info.wait_time = 0;
	     tape_info.system_flag = sys_sw;
	     if dev_name = DEVICE_TYPE (TAPE_DRIVE_DTYPEX) then tape_info.device_name = ""; /* No specific drive requested */
	     else tape_info.device_name = dev_name;	/* Ask for specific name */
	     tape_info.model = 0;
	     if track_sw then tape_info.tracks = 7;	/* 7 track drive requested */
	     else tape_info.tracks = 9;
	     tape_info.density = "0"b;
	     tape_info.speed = "0"b;			/* And initialize this also */
	     tape_info.unused_qualifier = "0"b;
	     if id_name = "" then tape_info.volume_name = "scratch"; /* If no volume requested */
	     else tape_info.volume_name = id_name;	/* Otherwise, use name requested */
	     tape_info.write_flag = write_sw;
	     tape_info.position_index = 0;
	     rcp_info_ptr = tape_info_ptr;		/* This is info block to use */
	end;

	else if dev_type = DEVICE_TYPE (DISK_DRIVE_DTYPEX) then do; /* If attaching a disk */
	     disk_info_ptr = addr (my_disk_info);	/* Get pointer to my disk info block */
	     disk_info.version_num = DISK_INFO_VERSION_1;
	     disk_info.usage_time = 0;
	     disk_info.wait_time = 0;
	     disk_info.model = 0;
	     disk_info.system_flag = sys_sw;
	     if dev_name = DEVICE_TYPE (DISK_DRIVE_DTYPEX) then disk_info.device_name = ""; /* If any disk will do */
	     else disk_info.device_name = dev_name;	/* Use name requested */
	     if id_name = "" then disk_info.volume_name = "scratch"; /* Use scratch if no volume given */
	     else disk_info.volume_name = id_name;	/* Otherwise use what was requested */
	     disk_info.write_flag = write_sw;
	     rcp_info_ptr = disk_info_ptr;		/* This the rcp block being used */
	end;

	else if dev_type = DEVICE_TYPE (PRINTER_DTYPEX) then do;
	     printer_info_ptr = addr (my_printer_info);	/* Use my printer block */
	     printer_info.version_num = PRINTER_INFO_VERSION_1;
	     printer_info.usage_time = 0;
	     printer_info.wait_time = 0;
	     printer_info.system_flag = sys_sw;
	     if dev_name = DEVICE_TYPE (PRINTER_DTYPEX) then printer_info.device_name = ""; /* If any printer will do */
	     else printer_info.device_name = dev_name;
	     printer_info.model = 0;
	     printer_info.print_train = 0;
	     rcp_info_ptr = printer_info_ptr;		/* Remember control block address */
	end;

	else do;					/* Some other device type */
	     device_info_ptr = addr (my_device_info);	/* Use my device info block */
	     device_info.version_num = DEVICE_INFO_VERSION_1;
	     device_info.usage_time = 0;
	     device_info.wait_time = 0;
	     device_info.system_flag = sys_sw;
	     if dev_name = dev_type then device_info.device_name = ""; /* No special device requested */
	     else device_info.device_name = dev_name;
	     device_info.model = 0;
	     rcp_info_ptr = device_info_ptr;
	end;

/* The rcp control block has been set up, so now do the attachment */

	if priv_sw then				/* If privileged */
	     call rcp_priv_$attach ((dev_type), rcp_info_ptr, ev_chan, "", rcp_id, code); /* Do privileged attachment */
	else call rcp_$attach ((dev_type), rcp_info_ptr, ev_chan, "", rcp_id, code);
	if code ^= 0 then do;
dev_err:	     call com_err_ (code, cmd_name, "^a", dev_name);
	     go to quit;
	end;

rcp_loop:	call rcp_$check_attach (rcp_id, rcp_info_ptr, word, devx, max_work, max_time, rcp_state, code);
	if rcp_state = 3 then go to dev_err;		/* Fatal error occured */
	if rcp_state = 0 then go to begin;		/* Attachment succeeded */
	if rcp_state = 1 then do;			/* Short wait code */
	     if word ^= "" then			/* If comment from somebody */
		call ioa_ ("^a: RCP indicates short wait for attachment. ^a", cmd_name, word);
	     call ipc_$block (addr (event_list), addr (event_info), code); /* Wait for attachment */
	     if code ^= 0 then do;
		call convert_ipc_code_ (code);
		call com_err_ (code, cmd_name, "While waiting for attachment.");
		go to quit;
	     end;
	     go to rcp_loop;			/* Check attachment again */
	end;

	call com_err_ (0, cmd_name, "RCP indicates long wait for attachment. ^a", word);
	go to quit;				/* I don't want to wait */


begin:	if dev_type = DEVICE_TYPE (DISK_DRIVE_DTYPEX) then dev_name = disk_info.device_name;
	else if dev_type = DEVICE_TYPE (TAPE_DRIVE_DTYPEX) then dev_name = tape_info.device_name;
	else if dev_type = DEVICE_TYPE (PRINTER_DTYPEX) then dev_name = printer_info.device_name;
	else dev_name = device_info.device_name;
	call ioa_ ("Device ^a assigned.", dev_name);

	if dev_type = DEVICE_TYPE (DISK_DRIVE_DTYPEX) | dev_type = DEVICE_TYPE (TAPE_DRIVE_DTYPEX) then default_device = bit (bin (substr (dev_name, 6, 2), 6), 6);
	else if dev_type = DEVICE_TYPE (SPECIAL_DTYPEX) then default_device = "00"b3;
	else default_device = "01"b3;

	call ipc_$drain_chn (ev_chan, code);		/* Don't leave stay events around */

	if substr (dev_name, 1, 3) = "dsk" then status_tablep = addr (disk_status_table_$disk_status_table_);
	else if substr (dev_name, 1, 3) = "tap" then status_tablep = addr (tape_status_table_$tape_status_table_);
	else if substr (dev_name, 1, 3) = "prt" then status_tablep = addr (prt_status_table_$prt_status_table_);
	else if substr (dev_name, 1, 3) = "rdr" then status_tablep = addr (crz_status_table_$crz_status_table_);
	else if substr (dev_name, 1, 3) = "pun" then status_tablep = addr (cpz_status_table_$cpz_status_table_);
	else if substr (dev_name, 1, 3) = "imp" then status_tablep = addr (imp_status_table_$imp_status_table_);
	else status_tablep = null;

/* Set up work space */

	call ioi_$workspace (devx, workp, work_size, code); /* Get work area */
	if code ^= 0 then do;
	     call com_err_ (code, cmd_name, "Unable to allocate workspace of ^d words.", work_size);
	     go to quit;
	end;

/* Initialize status queue */

	call ioi_$set_status (devx, 32, 4, code);	/* Define status queue */
	if code ^= 0 then do;
	     call com_err_ (code, cmd_name, "Unable to allocate status queue.");
	     go to quit;
	end;
	sqptr = addr (work_seg (33));			/* Status queue is here */
	status_queue.completion.st = "0"b;		/* Reset all status present bits */
	stat.completion.st = "0"b;
	status_index = 1;				/* This is the first entry to use */

	time_limit = max_time;			/* Set time limit to max */
	call ioi_$timeout (devx, time_limit, code);	/* Set time limit */
	if code ^= 0 then
	     call com_err_ (code, cmd_name, "Unable to set time limit to ^d seconds.",
	     divide (time_limit, 1000000, 17, 0));

/* Enable program interrupt as a way to escape from being blocked when no event is coming */

ready:	on program_interrupt begin;			/* By getting a command when it happens */
	     if debug_sw then go to next;
	     flush_sw = "1"b;
	     go to get_stat;			/* Flush out last status */
	end;

/* Read next command line */

next:	if prompt_msg ^= "" then call ioa_$nnl ("^a", prompt_msg);
	call iox_$get_line (iox_$user_input, addr (input_line), length (input_line), input_len, code);
	if code ^= 0 then do;
	     call com_err_ (code, cmd_name, "Reading for user_input");
	     go to next;
	end;
	if input_len > 0 then if substr (input_line, input_len, 1) = new_line then /* If line ends in a nl */
		input_len = input_len - 1;		/* Then truncate it */
	input_pos = 1;				/* Current position */

/* Analyze first word for command type */

	call next_word;				/* First get the next word */
	if end_line then go to next;			/* Some sort of null line  */
	dcw_word = "0"b;				/* Start with empty dcw */
	pcw_sw = "0"b;				/* Not now building a pcw */
	exec_spec_sw, exec_rept_sw, exec_no_err_sw = "0"b; /* Not in any special mode now */
	flush_sw = "0"b;

	if word = "tdcw" then go to b_tdcw;
	if word = "iotp" then go to b_iotp;
	if word = "iontp" then go to b_iontp;
	if word = "iotd" then go to b_iotd;
	if word = "idcw" then go to b_idcw;
	if word = "nidcw" then go to b_nidcw;
	if word = "pcw" then go to b_pcw;
	if word = "odcw" then go to b_oct;
	if word = "opcw" then go to b_opcw;
	if word = "print" | word = "p" then go to print;
	if word = "edit" | word = "e" then go to edit;
	if word = "name" then go to set_name;
	if word = "insert" | word = "i" then go to insert;
	if word = "update" | word = "u" then go to update;
	if word = "quit" | word = "q" then go to quit;
	if word = "delete" | word = "dl" | word = "d" then go to delete;
	if word = "execute" | word = "x" then go to execute;
	if word = "xs" then go to exec_spec;
	if word = "xr" then go to exec_rept;
	if word = "xre" then go to exec_rept_no_err;
	if word = "getstat" | word = "g" then go to get_stat;
	if word = "block" | word = "b" then go to block;
	if word = "dump" then go to dump;
	if word = "dumpb" then go to dumpb;
	if word = "patch" then go to patch;
	if word = "survey" then go to dump_survey;
	if word = "dtstat" then go to dump_dtstat;
	if word = "time" then go to set_time;
	if word = "work" then go to set_work;
	if word = "chan" then go to set_chan;
	if word = "susp" then go to susp_dev;
	if word = "rel" then go to rel_dev;
	if word = "prompt" then go to set_prompt;
	if word = "pattern" then go to set_pattern;
	if word = "save" then go to save_segment;
	if word = "restore" then go to restore_segment;
	if word = "reprint_status" | word = "rs" then go to reprint_status;
	if word = "status" | word = "st" then go to status_command;
	if word = "get_special" | word = "get_special_status" then go to get_special_status;
	if word = "get_detail" | word = "get_detailed_status" then go to get_detailed_status;

/* More possible requests */

	if word = "." then do;			/* If requested to identify my self */
	     call ioa_ ("^a", cmd_name);		/* Its me!!! */
	     go to next;
	end;
	if word = "?" then do;			/* If request for current status */
	     if insert_mode then out_temp = "insert"; else out_temp = "update";
	     call ioa_ ("Current list: ^d^[ (^a)^;^s^], dcw: ^d, mode: ^a", list, (list_name (list) ^= ""),
		list_name (list), idx-1, out_temp);
	     go to next;
	end;

std_err:	call ioa_ ("invalid word: ^a", word);
	go to next;

quit:	call clean_up;
	return;

/* Come here after dcw is built to update the correct dcw list */

store:	if pcw_sw then pcw_list (list) = dcw_word;	/* Pcw goes here */

	else do;
	     if insert_mode then do;			/* If in insert mode, list must be moved */
		i = dcw_len (list);			/* End of current list */
		do while (i >= idx);
		     j = i+1;			/* Destination word */
		     if j <= 32 then dcw_list (list, j) = dcw_list (list, i); /* Move it, but don't go off end */
		     i = i-1;
		end;
		dcw_len (list) = min (32, dcw_len (list)+1); /* Calc new length */
	     end;
	     dcw_list (list, idx) = dcw_word;		/* Copy in new word */
	     dcw_len (list) = max (dcw_len (list), idx);	/* Adjust count */
	     idx = min (32, idx+1);
	end;
	go to next;

/* Routine to build a TDCW */

b_tdcw:	tdcw.type = "10"b;				/* This makes it a TDCW */
	call next_word;				/* Get the next word */
	if end_line then go to store;			/* If all done */
	if octal_word then do;			/* If octal, then this is the address */
	     tdcw.address = bit (binary (octal_val, 18, 0)); /* So store it */
	     go to b_tdcw2;
	end;
b_tdcw1:	if word = "ec" then tdcw.ec = "1"b;		/* If ec bit needed */
	else if word = "res" then tdcw.res = "1"b;	/* If res bit wanted */
	else if word = "rel" then tdcw.rel = "1"b;	/* If rel bit wanted */
	else go to std_err;				/* Don't recognize it */
b_tdcw2:	call next_word;				/* Get next word */
	if end_line then go to store;
	else go to b_tdcw1;

/* Routine to build an IDCW */

b_idcw:	idcw.code = "111"b;				/* This makes it an IDCW */
	idcw.device = default_device;
	call next_word;
	if end_line then go to store;
	if octal_word then do;			/* Must be inst code */
	     idcw.command = bit (binary (octal_val, 6, 0)); /* So store it */
	     go to b_idcw2;
	end;

b_idcw1:	if word = "da" then idcw.device = bit6 ();	/* Device addrss follows */
	else if word = "ae" then idcw.ext = bit6 ();	/* Address extension follows */
	else if word = "ci" then idcw.chan_cmd = bit6 (); /* Channel instruction follows */
	else if word = "t" then idcw.count = bit6 ();	/* Tally follows */
	else if word = "ec" then idcw.ext_ctl = "1"b;
	else if word = "cont" then substr (idcw.control, 1, 1) = "1"b;
	else if word = "mark" then substr (idcw.control, 2, 1) = "1"b;
	else if word = "mask" then pcw.mask = "1"b;
	else if word = "reset" & pcw_sw then do;
	     pcw.mask = "1"b;
	     pcw.control = "11"b;
	end;
	else go to std_err;				/* No more things to test */

b_idcw2:	call next_word;				/* On to next one */
	if ^end_line then go to b_idcw1;
	else go to store;

/* Simple command for setting up a non-data transfer IDCW */

b_nidcw:	idcw.count = "000001"b;			/* Set tally = 1 */
	idcw.chan_cmd = "000010"b;			/* Non-data transfer code */
	go to b_idcw;				/* Otherwise, just like a regular IDCW */

/* Build a PCW, which is a lot like a IDCW */

b_pcw:	pcw_sw = "1"b;
	go to b_idcw;				/* Use the IDCW routine */

/* Build IOTP, IOTD, or IONTP dcw */

b_iotd:	dcw.type = "00"b;				/* Start here for IOTD */
	go to b_iodcw;

b_iotp:	dcw.type = "01"b;				/* Start here for IOTP */
	go to b_iodcw;

b_iontp:	dcw.type = "11"b;				/* Start here for IONTP */

b_iodcw:	call next_word;				/* This should be address */
	if end_line then go to store;
	if ^octal_word then go to std_err;
	dcw.address = bit (binary (octal_val, 18, 0));

	call next_word;				/* This should be tally */
	if end_line then go to store;
	if ^octal_word then go to std_err;
	dcw.tally = bit (binary (octal_val, 12, 0));

	call next_word;				/* This should be char pos */
	if end_line then go to store;
	if ^octal_word then go to std_err;
	dcw.char_pos = bit (binary (octal_val, 3, 0));

	go to store;				/* Done */

/* Store a dcw entered in octal */

b_oct:	call next_word;
	if end_line then go to store;			/* Just store zero */
	if ^octal_word then go to std_err;		/* Must be in octal */
	dcw_word = unspec (octal_val);
	go to store;

/* Build a pcw entered in octal */

b_opcw:	pcw_sw = "1"b;				/* Remember that this is pcw */
	go to b_oct;				/* And use octal routine */

/* Edit command which changes the dcw list being edited */

edit:	call next_word;				/* See if arg given */
	if ^end_line then do;
	     if word = "*" then do;			/* Any empty list */
		do i = 1 to 32;			/* Check all lists */
		     if empty_list (i) & list_name (i) = "" then do;
			call ioa_ ("Using list #^d.", i);
			list = i;
			go to edit1;
		     end;
		end;
		call ioa_ ("No empty lists.");
		go to next;
	     end;
	     else call check_list_num;		/* See if valid number or name */
	     list = dec_val;
edit1:	     call next_word;			/* See if name given */
	     if end_line then new_name = "";
	     else new_name = word;
	end;
	idx = 1;
	insert_mode = "0"b;
	if new_name ^= "" then go to set_name2;
	else go to next;

/* Update command, which turns off insert mode, and may change the current position */

update:	call get_dcw_num;
	insert_mode = "0"b;
	go to next;

/* Insert command, which turns on insert mode, and may change the current position */

insert:	call get_dcw_num;
	insert_mode = "1"b;
	go to next;

/* Routine to delete a word from a dcw list */

delete:	call get_dcw_num;
	i = idx;					/* Target word */
delete1:	j = i+1;					/* Source word to move from */
	if j > dcw_len (list) then do;		/* If reached end */
	     dcw_len (list) = max (dcw_len (list)-1, 0);	/* Adjust length */
	     go to next;
	end;
	dcw_list (list, i) = dcw_list (list, j);	/* Move word */
	i = i+1;					/* Next target word */
	go to delete1;

/* Routine to give a dcw list a name */

set_name:	call next_word;
	if end_line then new_name = "";
	else new_name = word;
set_name2:
	if new_name ^= "" then do i = 1 to 32;		/* Be sure name is not used elsewhere */
	     if list_name (i) = new_name then list_name (i) = "";
	end;
	list_name (list) = new_name;
	go to next;

/* Routine to set the time limit for connects */

set_time:	call debug_check;
	call next_word;				/* Get the next word */
	if end_line then do;			/* If nothing, then just print current time limit */
	     call ioa_ ("Time limit is ^d seconds", divide (time_limit, 1000000, 17, 0));
	     call ioa_ ("Max time limit is ^d seconds", divide (max_time, 1000000, 17, 0));
	     go to next;
	end;
	if ^dec_word then go to std_err;		/* Should be limit in seconds */
	time_limit = 1000000*dec_val;			/* Convert to micro seconds */
	call ioi_$timeout (devx, time_limit, code);
	if code ^= 0 then call com_err_ (code, cmd_name);
	go to next;

/* Command to change the size of the work space */

set_work:	call debug_check;
	call next_word;				/* Get next word */
	if end_line then do;			/* If no param, just print current size */
	     call ioa_ ("Buffer size is ^d words", work_size);
	     call ioa_ ("Max buffer size is ^d words", max_work);
	     go to next;
	end;
	if ^dec_word then go to std_err;		/* If specified, must be decimal */
	new_work_size = max (512, dec_val);		/* Save new size */
	call ioi_$workspace (devx, workp, new_work_size, code); /* Change size */
	if code ^= 0 then do;
	     call com_err_ (code, cmd_name, "Setting workspace to ^d words.");
	     go to next;
	end;
	work_size = new_work_size;
	go to next;

/* Command to change the prompt message */

set_prompt: call next_word;
	if end_line then prompt_msg = "";		/* If null, set to no prompt */
	else prompt_msg = before (word, " ");		/* Otherwise get rest of word */
	go to next;

/* Command to set a channel required for I/O */

set_chan:	call debug_check;
	call next_word;
	if end_line then do;			/* No arguments means reset this feature */
	     call ioi_$set_channel_required (devx, 0, 0, code);
	     if code ^= 0 then call com_err_ (code, cmd_name);
	     go to next;
	end;

	call parse_io_channel_name_ (word, iom, chan, code);
	if code ^= 0 then do;
	     call com_err_ (code, cmd_name, "^a", word);
	     go to next;
	end;

	call ioi_$set_channel_required (devx, iom, chan, code);
	if code ^= 0 then call com_err_ (code, cmd_name);
	go to next;

/* Suspend io on all devices on the mpc */

susp_dev:	call debug_check;
	call ioi_$suspend_devices (devx, code);
	if code ^= 0 then call com_err_ (code, cmd_name);
	go to next;

/* Release io on all devices on the mpc */

rel_dev:	call debug_check;
	call ioi_$release_devices (devx, code);
	if code ^= 0 then call com_err_ (code, cmd_name);
	go to next;

/* Commands for special and detailed status */

get_special_status:
	call debug_check;
	call ioi_$get_special_status (devx, stat_found, spec_status, code);
	if code ^= 0 then call com_err_ (code, cmd_name);
	else if ^stat_found then call ioa_ ("No special status stored.");
	else call ioa_ ("special status: ^w", spec_status);
	go to next;

get_detailed_status:
	call debug_check;
	call ioi_$get_detailed_status (devx, stat_found, detailed_status, code);
	if code ^= 0 then call com_err_ (code, cmd_name);
	else if ^stat_found then call ioa_ ("No detailed status from previous I/O.");
	else do;
	     do i = 27 to 2 by -1 while (detailed_status_array (i) = "0"b);
	     end;
	     call ioa_ ("Detailed status : ^v(^.4b ^)", i, detailed_status_array);
	end;
	go to next;

/* Routine to execute the dcw list */

execute:	exec_spec_sw = "0"b;			/* This is normal start */
	exec_rept_sw = "0"b;			/* Set  to execute once */
	exec_no_err_sw = "0"b;			/* Do not ignore errors */
	go to ex_join;

exec_spec: exec_spec_sw = "1"b;			/* Enter here if special interrupt required */
	exec_rept_sw = "0"b;
	exec_no_err_sw = "0"b;
	go to ex_join;

exec_rept_no_err:
	exec_no_err_sw = "1"b;			/* Going to ignore errors. */
	go to repeat;

exec_rept: exec_no_err_sw = "0"b;
repeat:	exec_spec_sw = "0"b;			/* No special wait */
	exec_rept_sw = "1"b;			/* But doing repeats */
ex_join:	exec_rept_cnt = 0;

	call debug_check;
	call get_list_num;
	if dec_val > 0 then do;			/* New list number */
	     list = dec_val;
	     idx = 1;
	     insert_mode = "0"b;
	end;

	if dcw_len (list) = 0 then do;		/* If list is empty */
	     call ioa_ ("List ^d^[ (^a)^] is empty.", list, list_name (list) ^= "", list_name (list));
	     go to next;
	end;

	do i = 1 to hbound (dcw_list, 2);		/* Copy list to work space */
	     if i <= dcw_len (list) then work_seg (i) = dcw_list (list, i);
	     else work_seg (i) = "0"b;
	end;

xagain:	if pcw_list (list) then call ioi_$connect_pcw (devx, 0, pcw_list (list), code); /* If i have a pcw */
	else call ioi_$connect (devx, 0, code);
	if code ^= 0 then do;
	     call com_err_ (code, cmd_name, "Issuing connect");
	     go to next;
	end;

block:	call debug_check;
	call ipc_$block (addr (event_list), addr (event_info), code); /* Wait for interrupt */
	if code ^= 0 then do;
	     call convert_ipc_code_ (code);
	     call com_err_ (code, cmd_name, "While blocking for interrupt.");
	     go to next;
	end;

/* Analyze status */

gstat:	imp = addr (event_info.message);		/* Get pointer to ioi message */

	if imess.level = "111"b then do;		/* If special status */
	     if flush_sw then go to get_stat;
	     unspec (stat) = "0"b;			/* Cons up a status queue entry */
	     stat.level = 7;
	     stat.iom_stat = imess.status;
	     stat.completion.st = "1"b;
	     call print_status;
	     go to next;
	end;

	isp = addr (status_queue (status_index));	/* Current status entry */
	if ^istat.completion.st then do;
	     if flush_sw then go to get_stat;
	     call print_status;
	     go to next;
	end;

	stat = istat;				/* Copy status to my automatic area */
	istat.completion.st = "0"b;			/* Status no longer present in buffer */
	status_index = status_index+1;		/* Index for next status */
	if status_index > 4 then status_index = 1;
	if flush_sw then go to get_stat;

	if stat.completion.time_out then do;		/* If event due to time out */
	     call print_status;
	     go to next;
	end;

	statp = addr (stat.iom_stat);			/* Get pointer to iom stat area */

	if exec_rept_sw then do;			/* If doing repeatedly */
	     if exec_no_err_sw then go to xagain;	/* Forget about errors. */
	     if stat.level ^= 3 then go to pr_stat;	/* If not terminate */
	     if stat.completion.er then go to pr_stat;	/* If status indicates any error */
	     exec_rept_cnt = exec_rept_cnt + 1;
	     go to xagain;				/* Otherwise do it again */
	end;

pr_stat:	call print_status;

	if stat.completion.run then go to block;	/* If still running, wait for more status */
	if exec_spec_sw then go to block;		/* If a special needed.. */
	if exec_rept_sw then call ioa_ ("^d operations suceeded.", exec_rept_cnt);
	go to next;

/* Routine to force ioi get status call to check for any status */

get_stat:	call debug_check;
	call ipc_$read_ev_chn (ev_chan, i, addr (event_info), code); /* Check for event */
	if code ^= 0 then do;
	     call convert_ipc_code_ (code);
	     call com_err_ (code, cmd_name, "Reading event channel.");
	     go to next;
	end;
	if i ^= 0 then go to gstat;			/* Status has occured */
	if ^flush_sw then call ioa_ ("No events");	/* Nothing has happened */
	go to next;

/* Command to reprint the last_status */

reprint_status:
	save_status_mode = status_mode;		/* Reember current mode */
	call next_word;
	if end_line then status_mode = 3;		/* Default is edited */
	else call check_status_mode;
	call print_status;
	status_mode = save_status_mode;
	go to next;

/* Command to set the status mode */

status_command:
	call next_word;
	if end_line then call ioa_ ("Status mode is ^[brief^;long^;edited^]", status_mode);
	else call check_status_mode;
	go to next;

/* Procedure to print status */

print_status: proc;

dcl  bstat (8) bit (36) aligned based (addr (stat));

	     if ^stat.completion.st then do;
		call ioa_ ("No status available.");
		return;
	     end;

	     if status_mode = 2 then do;		/* Long mode */
		call ioa_ ("^(^w ^)", bstat);
		return;
	     end;

	     if stat.level = 1 | stat.level = 7 then do;
		call ioa_ ("^d ^.3b", stat.level, substr (stat.iom_stat, 1, 36));
		return;
	     end;

	     if stat.completion.time_out then do;
		call ioa_ ("Channel timed out.");
		return;
	     end;

	     if status_mode = 3 then do;
		call analyze_device_stat_$rsnnl (output_line, status_tablep, stat.iom_stat, "0"b);
		call ioa_ ("^a", output_line);
		return;
	     end;

	     call ioa_ ("^d ^w ^w maj=^b sub=^b", stat.level,
		substr (stat.iom_stat, 1, 36), substr (stat.iom_stat, 37, 36),
		addr (stat.iom_stat) -> status.major,
		addr (stat.iom_stat) -> status.sub);
	     return;

	end print_status;

/* Procedure to check a word for a valid status mode */

check_status_mode: proc;

	     if word = "brief" | word = "bf" then status_mode = 1;
	     else if word = "long" | word = "lg" then status_mode = 2;
	     else if word = "edited" | word = "ed" then status_mode = 3;
	     else do;
		call ioa_ ("Invalid status mode: ^a", word);
		go to next;
	     end;
	     return;

	end check_status_mode;

/* Routine to print a dcw list */

print:	call next_word;
	if ^end_line then do;			/* There is an arg */
	     if word = "all" then do;
		something_printed = "0"b;
		do i = 1 to 32;
		     if ^empty_list (i) then do;	/* List in use */
			call ioa_ ("List #^d ^[(^a)^]", i, (list_name (i) ^= ""), list_name (i));
			call print_subr (i);
			something_printed = "1"b;
		     end;
		end;
		if ^something_printed then call ioa_ ("No dcw lists defined");
		go to next;
	     end;
	     else if word = "names" then do;		/* Request for list of names */
		something_printed = "0"b;
		do i = 1 to 32;
		     if (list_name (i) ^= "") | ^empty_list (i) then do;
			call ioa_ ("^2d ^[*noname*^s^;^a^] ^[(empty)^]", i, (list_name (i) = ""), list_name (i),
			     empty_list (i));
			something_printed = "1"b;
		     end;
		end;
		if ^something_printed then call ioa_ ("No dcw lists defined.");
		go to next;
	     end;
	     call check_list_num;			/* Check for valid arg */
	     list = dec_val;
	     idx = 1;
	     insert_mode = "0"b;
	end;

	if empty_list (list) then call ioa_ ("List #^d ^[(^a) ^]empty.", list, list_name (list) ^= "",
	     list_name (list));
	else call print_subr (list);
	go to next;

/* Subroutine to print 1 dcw list */

print_subr: proc (listnum);

dcl  listnum fixed bin;
dcl  i fixed bin;

	     do i = 0 to dcw_len (listnum);		/* Loop thru current list */
		output_line = "";			/* Start with null line */

		if i = 0 then do;			/* Special case to print the pcw */
		     if pcw_list (listnum) then do;	/* If there is one */
			dcw_word = pcw_list (listnum); /* Get it */
			output_line = "pcw   ";
			go to print_pcw;
		     end;
		end;

		else do;
		     dcw_word = dcw_list (listnum, i);	/* Copy the current word */

		     if idcw.code = "111"b then do;	/* If an IDCW */
			output_line = "idcw  ";
print_pcw:		call oct (2, binary (idcw.command)); /* Get device instruction */
			if idcw.device then do;	/* If an address is present */
			     output_line = output_line || " da=";
			     call oct (2, binary (idcw.device));
			end;
			if idcw.ext then do;	/* If address extension present */
			     output_line = output_line || " ae=";
			     call oct (2, binary (idcw.device));
			end;
			if idcw.chan_cmd then do;	/* If channel instruction present */
			     output_line = output_line || " ci=";
			     call oct (2, binary (idcw.chan_cmd));
			end;
			if idcw.count then do;	/* If a tally is present */
			     output_line = output_line || " t=";
			     call oct (2, binary (idcw.count));
			end;
			if idcw.ext_ctl then if i = 0 then output_line = output_line || " mask";
			     else output_line = output_line || " ec";
			if substr (idcw.control, 1, 1) then output_line = output_line || " cont";
			if substr (idcw.control, 2, 1) then output_line = output_line || " mark";
		     end;

		     else if tdcw.type = "10"b then do; /* If a TDCW */
			output_line = "tdcw  ";
			call oct (6, binary (tdcw.address)); /* Convert address */
			if tdcw.ec then output_line = output_line || " ec";
			if tdcw.res then output_line = output_line || " res";
			if tdcw.rel then output_line = output_line || " rel";
		     end;

		     else do;			/* Some type of IODCW */
			if dcw.type = "00"b then output_line = "iotd  "; /* Get type first */
			else if dcw.type = "01"b then output_line = "iotp  ";
			else output_line = "iontp ";	/* Only one left */
			call oct (6, binary (dcw.address)); /* Data address first */
			output_line = output_line || " ";
			call oct (4, binary (dcw.tally));
			if dcw.char_pos then do;	/* If character pos present */
			     output_line = output_line || " cp=";
			     call oct (1, binary (dcw.char_pos));
			end;
		     end;

		     call ioa_$rsnnl ("^w", word, (0), dcw_word); /* Unpack the word */
		     if i = 0 then call ioa_ ("    ^a ^a  ^a", substr (word, 1, 6), substr (word, 7, 12),
			output_line);
		     else call ioa_ ("^2o^[*^; ^] ^a ^a  ^a", i-1, (i = idx & list = listnum), substr (word, 1, 6),
			substr (word, 7, 6), output_line);
		end;
	     end;

	     return;

	end print_subr;

/* Command to dump contents of ioi work space segment */

dumpb:	dp_byte = "1"b;				/* Dump is in bytes */
	go to dp_join;

dump:	dp_byte = "0"b;				/* Dump is in words */
dp_join:	dp_loc = 65;				/* Default location */
	dp_len = 8;				/* Default word count */

	call next_word;
	if end_line then go to dump_go;		/* Use defaults */
	if ^octal_word then go to std_err;
	dp_loc = octal_val + 1;
	call next_word;
	if end_line then go to dump_go;
	if ^octal_word then go to std_err;
	dp_len = octal_val;				/* This is word count */

dump_go:	i = 0;					/* This will count words on current print line */
	output_line = "";

	if ^dp_byte then do dp_loc = dp_loc to (dp_loc+dp_len-1); /* If dump is in words */

dp_nl:	     if i = 0 then do;			/* If line is empty */
		call ioa_$rsnnl ("^4o", word, (0), dp_loc-1); /* Edit address */
		output_line = substr (word, 1, 4) || " ";
	     end;
	     i = i + 1;				/* Count another word on the line */
	     if i > 8 then do;			/* If no room for another line */
		call ioa_ ("^a", output_line);	/* Dump current */
		i = 0;
		go to dp_nl;			/* And start another */
	     end;
	     call ioa_$rsnnl ("^w", word, (0), work_seg (dp_loc)); /* Edit a word */
	     output_line = output_line || " " || substr (word, 1, 12);
	end;

	else do;					/* Dump is in binary bytes */
	     byte_ptr = addr (work_seg (dp_loc));	/* Get array pointer */
	     nbytes = dp_len;			/* Number of bytes to dump */
	     do j = 1 to nbytes;
		i = i + 1;			/* Count entry on line */
		if i > 10 then do;			/* If line full */
		     call ioa_ ("^a", output_line);
		     i = 1;
		     output_line = "";
		end;
		call ioa_$rsnnl ("^b", word, (0), bbyte (j)); /* Format new word */
		output_line = output_line || " " || substr (word, 1, 8);
	     end;
	end;

	call ioa_ ("^a", output_line);		/* Dump last line */
	go to next;

/* Command to patch data into ioi buffer */

patch:	call next_word;				/* Get address */
	if end_line then do;
	     call ioa_ ("Address missing");
	     go to next;
	end;
	if ^octal_word then go to std_err;
	dp_loc = octal_val + 1;			/* First word to patch */

	call next_word;				/* First data word */
	if end_line then do;
	     call ioa_ ("Data missing");
	     go to next;
	end;

	do while (^end_line);			/* Do for rest of input line */
	     if ^octal_word then go to std_err;		/* Only octal allowed */
	     work_seg (dp_loc) = unspec (octal_val);	/* Store whole word */
	     dp_loc = dp_loc + 1;			/* Step to next word */
	     call next_word;			/* Fetch next arg */
	end;
	go to next;

/* Command to repeat a data pattern in the buffer */

set_pattern:
	call next_word;				/* Address */
	if end_line then do;
	     call ioa_ ("Address missing");
	     go to next;
	end;
	if ^octal_word then go to std_err;
	dp_loc = octal_val + 1;			/* Start address */

	call next_word;				/* Count */
	if end_line then do;
	     call ioa_ ("Count missing");
	     go to next;
	end;
	if ^octal_word then go to std_err;
	dp_rpt = octal_val;

	dp_len = 0;
	call next_word;
	do while (^end_line);			/* Scan rest of command */
	     if ^octal_word then go to std_err;
	     work_seg (dp_loc) = unspec (octal_val);
	     dp_len = dp_len + 1;
	     dp_loc = dp_loc + 1;
	     call next_word;
	end;

	if dp_len = 0 then do;
	     call ioa_ ("No data");
	     go to next;
	end;

	do dp_rpt = dp_rpt-1 by -1 while (dp_rpt > 0);
	     do i = 1 to dp_len;
		work_seg (dp_loc) = work_seg (dp_loc - dp_len);
		dp_loc = dp_loc + 1;
	     end;
	end;
	go to next;

/* Dump data returned by survey devices is readable format */

dump_survey: dp_loc = 65;				/* Default location of data */
	call next_word;				/* See if location given */
	if ^end_line then do;			/* If it was */
	     if ^octal_word then go to std_err;
	     else dp_loc = octal_val + 1;		/* Use this loc */
	end;

	survey_ptr = addr (work_seg (dp_loc));		/* This locates the data */

	do i = 1 to 16 while (string (survey_table (i))); /* Do until all devices done */
	     call ioa_$rsnnl ("handler ^d:", out_temp, (0), binary (hand_addr (i)));
	     output_line = out_temp;			/* This starts the line */
	     if hand_resv (i) then output_line = output_line || " reserved";
	     if hand_op (i) then output_line = output_line || " operational";
	     if hand_ready (i) then output_line = output_line || " ready";
	     if hand_track (i) then output_line = output_line || " 9 track";
	     else output_line = output_line || " 7 track";
	     if hand_speed (i) = "001"b then output_line = output_line || " 75 ips";
	     else if hand_speed (i) = "010"b then output_line = output_line || " 125 ips";
	     else if hand_speed (i) = "100"b then output_line = output_line || " 200 ips";
	     else do;				/* Some unusual speed code */
		call ioa_$rsnnl (" speed code=^b", out_temp, (0), hand_speed (i));
		output_line = output_line || out_temp;
	     end;
	     if hand_record (i) = "0000"b then output_line = output_line || " 1600 bpi";
	     else if hand_record (i) = "0001"b then output_line = output_line || " 200,556,800 bpi";
	     else if hand_record (i) = "0100"b then output_line = output_line || " 200,556,800,1600 bpi";
	     else do;				/* Some other strange code */
		call ioa_$rsnnl (" density code=^b", out_temp, (0), hand_record (i));
		output_line = output_line || out_temp;
	     end;

	     call ioa_ ("^a", output_line);
	end;

	go to next;

/* Command to display detailed tape status */

dump_dtstat: dp_loc = 65;				/* Default location */
	call next_word;
	if ^end_line then do;
	     if ^octal_word then go to std_err;
	     dp_loc = octal_val + 1;
	end;

	dtstp = addr (work_seg (dp_loc));		/* Get pointer to detailed status */

	output_line = "Byte 0:";
	if dt_stat.devflt then output_line = output_line || "  device-fault";
	if dt_stat.ccerr then output_line = output_line || "  command-code-error";
	if dt_stat.rawerr then output_line = output_line || "  read-after-write-error";
	if dt_stat.mbot then output_line = output_line || "  multiple BOTs";
	if dt_stat.bot then output_line = output_line || "  BOT";
	if dt_stat.eot then output_line = output_line || "  EOT";
	if dt_stat.standby then output_line = output_line || "  standby";
	if dt_stat.marg then output_line = output_line || "  marginal-condition";
	call ioa_ ("^a", output_line);

	output_line = "Byte 1:";
	if dt_stat.loaded then output_line = output_line || "  loaded";
	if dt_stat.lcw then output_line = output_line || "  last-command-write";
	if dt_stat.lcf then output_line = output_line || "  last-command-forward";
	if dt_stat.rewind then output_line = output_line || "  rewinding";
	if dt_stat.wpr then output_line = output_line || "  write-permit-ring";
	if dt_stat.spr then output_line = output_line || "  software-write-permit";
	if dt_stat.diag then output_line = output_line || "  diagnostic-mode";
	if dt_stat.ccpe then output_line = output_line || "  command-code-parity-even";
	call ioa_ ("^a", output_line);

	output_line = "Byte 2:";
	output_line = output_line || "  density=";
	if dt_stat.denr = "000"b then output_line = output_line || "1600";
	else if dt_stat.denr = "001"b then output_line = output_line || "3200";
	else if dt_stat.denr = "100"b then output_line = output_line || "800";
	else if dt_stat.denr = "101"b then output_line = output_line || "1200";
	else if dt_stat.denr = "110"b then output_line = output_line || "200";
	else if dt_stat.denr = "111"b then output_line = output_line || "556";
	else do;
	     call ioa_$rsnnl ("(^b)", out_temp, (0), dt_stat.denr);
	     output_line = output_line || out_temp;
	end;
	if dt_stat.lowt then output_line = output_line || "  low-threshold";
	output_line = output_line || "  recording=";
	if dt_stat.denc = "0000"b then output_line = output_line || "1600";
	else if dt_stat.denc = "0001"b then output_line = output_line || "1600,800,556,200";
	else if dt_stat.denc = "0010"b then output_line = output_line || "1200,800,556,200";
	else if dt_stat.denc = "0011"b then output_line = output_line || "1200";
	else if dt_stat.denc = "0100"b then output_line = output_line || "800,556,200";
	else if dt_stat.denc = "0101"b then output_line = output_line || "556,200";
	else if dt_stat.denc = "0110"b then output_line = output_line || "200";
	else if dt_stat.denc = "0111"b then output_line = output_line || "3200";
	else do;
	     call ioa_$rsnnl ("(^b)", out_temp, (0), dt_stat.denc);
	     output_line = output_line || out_temp;
	end;
	call ioa_ ("^a", output_line);

	output_line = "Byte 3:";
	i = bin (dt_stat.speed);
	output_line = output_line || "  speed=";
	if i <= 15 then output_line = output_line || speed_constant (i);
	else do;
	     call ioa_$rsnnl ("(^b)", out_temp, (0), dt_stat.speed);
	     output_line = output_line || out_temp;
	end;
	if dt_stat.track then output_line = output_line || "  9-channel";
	else output_line = output_line || "  7-channel";
	if dt_stat.nsbot then output_line = output_line || "  non-stanard-BOT";
	call ioa_ ("^a", output_line);

	output_line = "Byte 4:";
	if dt_stat.dms then output_line = output_line || "  device-multiple-select";
	output_line = output_line || "  address=";
	call ioa_$rsnnl ("^d", out_temp, (0), bin (dt_stat.addr));
	output_line = output_line || out_temp;
	call ioa_ ("^a", output_line);

	go to next;

/* Save dcw lists in a segment */

save_segment:
	call save_seg_util ("1"b);			/* Find and/or make segment */

	save_seg.version = 1;
	save_seg.code = save_seg_code;
	save_seg.time = clock ();
	save_seg.pcw_list = pcw_list;
	save_seg.dcw_len = dcw_len;
	save_seg.list_name = list_name;
	save_seg.dcw_list = dcw_list;
	call adjust_bit_count_ (dir, ename, "0"b, (0), code);
	if code ^= 0 then call com_err_ (code, cmd_name, "Setting bit_count");
	call hcs_$terminate_noname (save_segp, code);
	save_segp = null;
	go to next;

/* Restore dcw lists from a segment */

restore_segment:
	call save_seg_util ("0"b);			/* Find segment */

	if (save_seg.code ^= save_seg_code) | (save_seg.version ^= 1) then do;
	     call ioa_ ("not a test_dcw data segment");
	     call hcs_$terminate_noname (save_segp, code);
	     save_segp = null;
	     go to next;
	end;

	call date_time_ (save_seg.time, time_string);
	call ioa_ ("Segment saved at ^a", time_string);
	pcw_list = save_seg.pcw_list;
	dcw_len = save_seg.dcw_len;
	list_name = save_seg.list_name;
	dcw_list = save_seg.dcw_list;
	call hcs_$terminate_noname (save_segp, code);
	save_segp = null;
	insert_mode = "0"b;
	idx, list = 1;
	if ^debug_sw then do i = 1 to 32;		/* Loop thru and fix device addresses */
	     if pcw_list (i) ^= "0"b then addr (pcw_list (i)) -> pcw.device = default_device;
	     do j = 1 to dcw_len (i);
		if addr (dcw_list (i, j)) -> idcw.code = "111"b then
		     addr (dcw_list (i, j)) -> idcw.device = default_device;
	     end;
	end;
	go to next;


/* Procedure for initiating or making the save segment */

save_seg_util: proc (make_sw);

dcl  make_sw bit (1);				/* Says whether to call make_seg or initiate */

	     call next_word;
	     if end_line then do;
		call ioa_ ("Path missing");
		go to next;
	     end;
	     call expand_pathname_ (word, dir, unsuffixed_ename, code);
	     if code ^= 0 then do;
		call com_err_ (code, cmd_name, "^a", word);
		go to next;
	     end;
	     call suffixed_name_$make (unsuffixed_ename, cmd_name, ename, code);
	     if code ^= 0 then do;
		call com_err_ (code, cmd_name, "^a", unsuffixed_ename);
		go to next;
	     end;
	     if make_sw then call hcs_$make_seg (dir, ename, "", 01010b, save_segp, code);
	     else call hcs_$initiate (dir, ename, "", 0, 0, save_segp, code);
	     if save_segp = null then do;
		call com_err_ (code, cmd_name, "^a^[>^]^a", dir, dir ^= ">", ename);
		go to next;
	     end;

	     return;

	end save_seg_util;

/* Internal procedure to extract the next word from the input line */

next_word: proc;

	     end_line = "0"b;			/* Reset the end of line flag */
nw_loop:	     if input_pos > input_len then do;		/* Past end of line */
		end_line = "1"b;			/* Set end of line flag */
		return;				/* And exit */
	     end;
	     temp_char = substr (input_line, input_pos, 1); /* Get next char */
	     if temp_char = " " | temp_char = tab then do; /* If white space */
		input_pos = input_pos + 1;		/* Ignore it */
		go to nw_loop;
	     end;

	     i = input_pos;				/* Current position */
nw_scan:	     i = i + 1;				/* Next position */
	     if i > input_len then go to nw_found;	/* Word is ended by the end of the line */
	     temp_char = substr (input_line, i, 1);	/* Get next char */
	     if ^(temp_char = " " | temp_char = tab) then go to nw_scan; /* If a meaningful character */
nw_found:	     word = substr (input_line, input_pos, i-input_pos); /* Extract the word */
	     input_pos = i;				/* Update position */

	     octal_val = cv_oct_check_ (word, i);	/* Test it */
	     octal_word = (i = 0);			/* Set octal flag if no errors */
	     dec_val = cv_dec_check_ (word, i);		/* Attempt the conversion */
	     dec_word = (i = 0);			/* Set decimal flag if no errors */

	     return;

	end next_word;

/* Routines to convert numbers to octal char strings */

oct:	proc (l, val);

dcl  l fixed bin;					/* Length of string */
dcl  val fixed bin (35);				/* Value to convert */

	     call ioa_$rsnnl ("^w", word, (0), val);	/* Get octal version of word */
	     output_line = output_line || substr (word, 13-l, l);

	end oct;

/* Fuction which returns the next word on the input line as a bit string */

bit6:	proc returns (bit (6));

	     call next_word;			/* Get next word */
	     if end_line then go to store;
	     if ^octal_word then go to std_err;
	     return (bit (binary (octal_val, 6, 0)));

	end bit6;


/* Called by commands which are not allowed in debug mode */

debug_check: proc;

	     if ^debug_sw then return;

	     call ioa_ ("Command not allowed in debug mode");
	     go to next;

	end debug_check;

/* Routine to get next word as a list number */

get_list_num: proc;

	     dec_val = -1;
	     call next_word;
	     if end_line then return;
check_list_num: entry;
	     if dec_word then do;
		if dec_val < 1 | dec_val > 32 then do;
		     call ioa_ ("Invalid dcw list number: ^d", dec_val);
		     go to next;
		end;
		else return;
	     end;
	     do i = 1 to 32;
		if list_name (i) = word then do;
		     dec_val = i;
		     return;
		end;
	     end;
	     call ioa_ ("No dcw list named ^a", word);
	     go to next;

	end get_list_num;

/* Function which tests for an empty DCW list */

empty_list: proc (l) returns (bit (1));

dcl  l fixed bin;

	     return ((pcw_list (l) = "0"b) & (dcw_len (l) = 0));

	end empty_list;

/* Routine to return the next word as a dcw number */

get_dcw_num: proc;

	     call next_word;
	     if end_line then return;			/* If no more, don't change num */
	     if ^octal_word then go to std_err;
	     if octal_val < 0 | octal_val > 31 then go to std_err;
	     idx = octal_val + 1;
	     return;

	end get_dcw_num;

/* Cleanup handler */

clean_up:	proc;

	     if rcp_id ^= "0"b then do;		/* If device attached thru rcp */
		call rcp_$detach (rcp_id, "0"b, 0, "", code);
		rcp_id = "0"b;
	     end;

	     if ev_chan ^= -1 then do;		/* If event channel created */
		call ipc_$delete_ev_chn (ev_chan, code);
		ev_chan = -1;
	     end;

	     if ptr_array (1) ^= null then do;
		call release_temp_segments_ (cmd_name, ptr_array, code);
		ptr_array = null;
	     end;

	     if save_segp ^= null then do;
		call hcs_$terminate_noname (save_segp, code);
		save_segp = null;
	     end;

	     return;

	end clean_up;

     end test_dcw;
