/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1992   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(85-09-11,Farley), approve(85-09-11,MCR6979),
     audit(86-02-18,Coppola), install(92-10-21,MR12.5-1037):
     Add support for FIPS disk and tape.
  2) change(85-12-18,Farley), approve(85-12-18,MCR7318),
     audit(86-02-18,Coppola), install(92-10-21,MR12.5-1037):
     bug fixes, plus one new arg.
  3) change(92-10-02,WAAnderson), approve(92-10-02,MCR8276),
     audit(92-10-14,Vu), install(92-10-21,MR12.5-1037):
     1) Added support for fdisk_status_table_.alm 2) Added support for device
     channels. (ie -channel control arg & new column) 3) Added sector number
     for -cylinder argument. 4) Corrected problem with data bit error counts.
                                                   END HISTORY COMMENTS */
/* IO_ERROR_SUMMARY: Command to summarize I/O errors from the syserr log */

/* Coded January-February 1976 by Larry Johnson */
/* Modified May 1976 by Larry Johnson for new config cards and disk and opc devices */
/* Modified March 1977 by Larry Johnson to get device names from log instead of config deck */
/* Modified November 1979 by Larry Johnson for detailed device status */
/* Modified January 1980 by Larry Johnson to use hashing to improve performance */
/* Modified October 1980 by Rich Coppola to reduce superflous output from detail status */
/* Modified May 1981 by Rich Coppola to add interface to analyze_detail_stat_
   add -status (-st) arg and the -hex_detail_status (-hxdtst) arg. */
/* Modified Apr 1982 by Rich Coppola to add support of PR54 printer and MPT Tape drives */
/* Modified September 1982 by C. Hornig for PRPH TAP card change. */
/* Modified Oct 1982 by Rich Coppola to use new calling sequence to
   analyze_detail_stat_$rs/rsnnl and remove some superflous code for detail
   status analysis that was better done in analyze_detail_stat_.
*/
/* Modified Jan. 28, 1983 by Paul Farley to add a "-io_command(-ioc)" arg to */
/* allow for displaying the IO command executed prior to recieving the error. */
/* Modified Nov 1983 by Paul Farley to fix TR 16222,16432
   Modified Jan 1984 by Paul Farley to fix TR 14550
   Modified Jan 1985 by Paul Farley to pack ascii formatted detailed status
   from EURCs and UR-IPCs before printing in HEX or before analyzing.
   Modified Feb 1985 by Paul Farley to check for null ptrs from config_.
   Modified July 1985 by Paul Farley for FIPS disk/tape.
*/

/* format: style4,delnl,insnl,ifthenstmt,indnoniterend */

io_error_summary:
     proc;

dcl  code fixed bin (35);				/* Standard system status code */
dcl  open_status bit (36) aligned;			/* Code from syserr_log_util_$open */
dcl  tab_cnt fixed bin init (0);			/* Number of seperate status found */
dcl  indent fixed bin;				/* The number of spaces to indent */
dcl  (i, j) fixed bin;
dcl  mode fixed bin (5);
dcl  stat_tablep ptr internal static;			/* Pointer to device status table */
dcl  my_tape_analp ptr;				/* Pointer to tape detail status analysis */
dcl  my_disk_analp ptr;
dcl  my_prt_analp ptr;
dcl  mask bit (36) aligned;				/* Mask of significant bits in status word */
dcl  arg_ptr ptr;					/* Pointer to an argument */
dcl  arg_len fixed bin;				/* Length of an argument */
dcl  arg char (arg_len) based (arg_ptr);		/* A command argument */
dcl  arg_count fixed bin;				/* The number of arguments */
dcl  arg_list_ptr ptr;				/* Pointer to commands argument list */
dcl  for_ptr ptr;					/* Saved pointer to the -for argument */
dcl  for_len fixed bin;				/* Saved length of -for argument */
dcl  for_arg char (for_len) based (for_ptr);		/* This is the -for argument */
dcl  from_sw bit (1) init ("0"b);			/* Set if -from used */
dcl  to_sw bit (1) init ("0"b);			/* Set if -to used */
dcl  for_sw bit (1) init ("0"b);			/* Set if -for used */
dcl  detailed_status_sw bit (1) init ("0"b);		/* Set if -dtstat specified */
dcl  hex_detailed_status_sw bit (1) init ("0"b);		/* Set if user want to see hex detail status */
dcl  chn_sw bit (1) init ("0"b);			/* Set if user wants to see channel */
dcl  cyl_sw bit (1) init ("0"b);			/* Set if user wants to see disk addresses */
dcl  tdbie_sw bit (1) init ("0"b);			/* Set if user wants to see tape data bits in error */
dcl  io_cmd_sw bit (1) init ("0"b);			/* Set if user wants to see the I/O commands */
dcl  fips_controller bit (1) init ("0"b);
dcl  more_args bit (1);				/* Set while there are more arguments to scan */
dcl  from_time fixed bin (71);			/* Time specified on -from */
dcl  to_time fixed bin (71);				/* Time specified on -to */
dcl  for_time fixed bin (71);				/* Time specified on -for */
dcl  arg_no fixed bin init (1);			/* For scanning argument list */
dcl  statentp ptr;					/* Pointer to status table entry */
dcl  msg_time fixed bin (71);				/* Time of syserr message */
dcl  msg_seq fixed bin (35);				/* Sequence number */
dcl  dev_cnt fixed bin init (0);			/* Number of devices requested */
dcl  stat_req_cnt fixed bin init (0);			/* Number of stati requested */
dcl  stat_cnt fixed bin init (0);			/* Entries in status table */
dcl  devreq (32) char (7) var;			/* Table of requested devices */
dcl  1 statreq (32),				/* Table of requested stati */
       2 statreq_maj bit (4),				/* major status */
       2 statreq_min bit (6);				/* minor status */
dcl  1 dev_pack_list (20) aligned,
       2 valid bit (1) aligned,
       2 device char (4) aligned,
       2 pack bit (1) aligned;
dcl  1 dev_idx_list (20) aligned,
       2 valid bit (1) aligned,
       2 device_name char (8) aligned,
       2 device_idx fixed bin aligned;
dcl  1 disk_list (20) aligned,
       2 valid bit (1) aligned,
       2 device_name char (8) aligned,
       2 fips bit (1) aligned;
dcl  stat_arg fixed bin (35);
dcl  buffer (500) bit (36) aligned;			/* Syserr messages are read here */
dcl  sortp ptr;					/* Segment containing sort array */
dcl  areap ptr;					/* Work area */
dcl  hashp ptr;
dcl  chars_in_sort_info fixed bin;
dcl  1 auto_area_info aligned like area_info automatic;

dcl  meter_sw bit (1) init ("0"b);			/* Set if -meter used */
dcl  total_time fixed bin (71);
dcl  open_time fixed bin (71);
dcl  scan_time fixed bin (71);
dcl  count_time fixed bin (71);
dcl  sort_time fixed bin (71);
dcl  start_count fixed bin (71);
dcl  print_time fixed bin (71);
dcl  n_counted fixed bin (35);
dcl  n_statuses fixed bin (35);
dcl  longest_chain fixed bin;
dcl  buckets_used fixed bin;
dcl  mpc_model fixed bin init (0);
dcl  oct_char (0:7) char (1) int static options (constant) init ("0", "1", "2", "3", "4", "5", "6", "7");
dcl  analysis_char_count fixed bin;
dcl  analysis_string char (256) var init ("");
dcl  display_detail_count fixed bin;
dcl  null_tape_tracks char (18) init ((18)"-");
dcl  dbie_counts (9) fixed bin;
dcl  track_analysis char (256) var;

/* Constants */

dcl  name char (16) int static options (constant) init ("io_error_summary");
						/* Name of procedure */
dcl  n_buckets fixed bin int static options (constant) init (2047);


dcl  mth500_mask bit (208) int static options (constant) init ("f3ffffffffffffffffffff000000002011002000000040000000"b4);

dcl  mth600_mask bit (208) int static options (constant) init ("f3ffffffff00ffffff01000000000000ffffffffffffffffffff"b4);

dcl  mth610_mask bit (208) int static options (constant) init ("f3ffffffff00ffff000000000a000400ffffffffffffffffffff"b4);

dcl  mth640_mask bit (208) int static options (constant) init ("f3ffffffffe0ffe7ff17000000000000ffffffffffffffffffff"b4);

dcl  mtc500_mask bit (208) int static options (constant) init ("ffffffffffffffffffffffffffffffff00000000000000000000"b4);

dcl  mtp601_mask bit (208) int static options (constant) init ("fffffffffffffffffffffffffffffffffffffffffef200000000"b4);

dcl  mtp610_mask bit (208) int static options (constant) init ("ffffffffffffffffffffffffffffffffffffffff7a820727003f"b4);

dcl  fips_tape_mask bit (208) int static options (constant)
	init ("fe85fffdf23640fd80f8950000000000000000000000ff000000"b4);

dcl  pr71_mask bit (128) int static options (constant) init ("ffffffffffffffffffffff0000000000"b4);

dcl  pr54_mask bit (128) int static options (constant) init ("800000c00000000000000000ff000080"b4);

dcl  db_trk_str9 char (58) int static options (constant)
	init ("Data Bit/Track 0/7  1/6  2/5  3/3  4/9  5/1  6/8  7/2  P/4");

dcl  db_trk_str7 char (49) int static options (constant) init ("Data Bit/Track  2/6  3/5  4/4  5/3  6/2  7/1  P/7");

dcl  DEV_LEN fixed bin int static options (constant) init (9);
dcl  CHN_LEN fixed bin int static options (constant) init (4);
dcl  IOC_LEN fixed bin int static options (constant) init (5);

/* Based */

dcl  1 sort_list aligned based (sortp),
       2 count fixed bin (35),
       2 entryp (0 refer (sort_list.count)) ptr unal;

dcl  hash_table (n_buckets) ptr unal based (hashp);

dcl  1 stat aligned based (statentp),			/* Entry for each different status found */
       2 sort_info like stat_sort_info,
       2 next ptr unal,				/* Next in chain */
       2 count fixed bin (17) unal;			/* Number of occurances of the status */

dcl  1 stat_sort_info aligned based,
       2 devname char (8),				/* Name of device */
       2 chnname char (8),
       2 time_out_sort char (1) unal,			/* Make time outs sort before rest */
       2 sysfault_sort char (1) unal,			/* Make system faults sort before rest */
       2 pad char (2) unal,
       2 dsk_sect fixed bin (24),			/* seek field fom dsk_ctl */
       2 pad1 fixed bin (12) unal,
       2 dsk_mult_rec char (8),			/* and the assoc record */
       2 status bit (36),				/* The status */
       2 command char (2) unal,			/* IO command */
       2 pad2 char (2) unal,
       2 detailed_status bit (216);			/* The detailed status */

dcl  work_area area based (areap);

/* External */

dcl  syserr_log_util_$open entry (bit (36) aligned, fixed bin (35));
dcl  print_syserr_msg_$open_err entry (bit (36) aligned, char (*), fixed bin (35));
dcl  com_err_ entry options (variable);
dcl  get_temp_segment_ entry (char (*), ptr, fixed bin (35));
dcl  syserr_log_util_$read entry (ptr, fixed bin, fixed bin, fixed bin (35));
dcl  syserr_log_util_$close entry (fixed bin (35));
dcl  release_temp_segment_ entry (char (*), ptr, fixed bin (35));
dcl  ioa_ entry options (variable);
dcl  ioa_$rsnnl entry () options (variable);
dcl  ioa_$rs entry () options (variable);
dcl  ioa_$rsnpnnl entry options (variable);
dcl  syserr_log_util_$search entry (fixed bin (71), fixed bin (71), fixed bin (35), fixed bin (35));
dcl  analyze_device_stat_$rsnnl entry (char (*) var, ptr, bit (72) aligned, bit (18) aligned);
dcl  analyze_detail_stat_$rsnnl entry (char (*), bit (36) aligned, bit (*) unal, char (*) var, bit (1), fixed bin (35));
dcl  analyze_detail_stat_ entry (char (*), bit (36) aligned, bit (*) unal, ptr, fixed bin (35));
dcl  date_time_ entry (fixed bin (71), char (*));
dcl  cu_$arg_list_ptr entry (ptr);
dcl  cu_$arg_count entry (fixed bin);
dcl  cu_$arg_ptr_rel entry (fixed bin, ptr, fixed bin, fixed bin (35), ptr);
dcl  convert_date_to_binary_ entry (char (*), fixed bin (71), fixed bin (35));
dcl  convert_date_to_binary_$relative entry (char (*), fixed bin (71), fixed bin (71), fixed bin (35));
dcl  config_$find entry (char (4) aligned, ptr);
dcl  config_$find_periph entry (char (4) aligned, ptr);
dcl  config_$find_peripheral entry (char (4) aligned, fixed bin (3), fixed bin (8), bit (36) aligned, fixed bin (35));
dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
dcl  cv_oct_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
dcl  define_area_ entry (ptr, fixed bin (35));
dcl  release_area_ entry (ptr);
dcl  sort_items_$bit entry (ptr, fixed bin (24));
dcl  hash_index_ entry (ptr, fixed bin, fixed bin, fixed bin) returns (fixed bin);
dcl  hcs_$fs_get_mode entry (ptr, fixed bin (5), fixed bin (35));
dcl  parse_io_channel_name_ entry (char (*), fixed bin (3), fixed bin (6), fixed bin (35));

dcl  error_table_$no_r_permission fixed bin (35) ext static;
dcl  error_table_$end_of_info ext fixed bin (35);
dcl  error_table_$badopt ext fixed bin (35);
dcl  sys_info$max_seg_size fixed bin (35) ext static;
dcl  disk_status_table_$disk_status_table_ ext;
dcl  fdisk_status_table_$fdisk_status_table_ ext;
dcl  opc_status_table_$opc_status_table_ ext;
dcl  tape_status_table_$tape_status_table_ ext;
dcl  prt_status_table_$prt_status_table_ ext;
dcl  cpz_status_table_$cpz_status_table_ ext;
dcl  crz_status_table_$crz_status_table_ ext;
dcl  config_deck$ ext;
dcl  cleanup condition;

dcl  (addr, bin, divide, fixed, float, hbound, index, lbound, length, ltrim, max, mod, null, rtrim, size, substr,
     subtract, unspec, vclock, bit) builtin;
%page;
/* Initialization */

	total_time = vclock ();
	areap = null ();
	sortp = null ();
	unspec (dev_pack_list (*)) = ""b;
	unspec (dev_idx_list (*)) = ""b;
	on cleanup call clean_up;

	call get_temp_segment_ (name, sortp, code);	/* Get a work segment */
	if code ^= 0 then do;
	     call com_err_ (code, name, "Can't get temp segment");
	     go to done;
	     end;
	sort_list.count = 0;

	area_infop = addr (auto_area_info);
	unspec (area_info) = "0"b;
	area_info.version = area_info_version_1;
	area_info.owner = name;
	area_info.size = sys_info$max_seg_size;
	area_info.areap = null ();
	area_info.control.extend = "1"b;
	area_info.no_freeing = "1"b;
	call define_area_ (area_infop, code);
	if code ^= 0 then do;
	     call com_err_ (code, name, "Unable to setup area.");
	     go to done;
	     end;

	areap = area_info.areap;
	allocate stat_sort_info in (work_area) set (hashp);
						/* Dummy, to get size */
	chars_in_sort_info = 4 * size (hashp -> stat_sort_info);

	allocate hash_table in (work_area);
	hash_table (*) = null ();

	call cu_$arg_list_ptr (arg_list_ptr);		/* Need pointer to argument list */
	call cu_$arg_count (arg_count);		/* And the length */
	more_args = (arg_count > 0);			/* Set if args to scan */
	call scan_args;				/* Scan the argument list */

	open_time = vclock ();
	call syserr_log_util_$open (open_status, code);	/* Open the syserr log */
	if code ^= 0 | substr (open_status, 1, 2) ^= "11"b then do;
						/* If error */
	     call print_syserr_msg_$open_err (open_status, name, code);
	     if code ^= 0 then go to done;		/* Not recoverable */
	     end;
	open_time = vclock () - open_time;

	if ^from_sw then do;			/* No -from, so start at beginning */
	     call syserr_log_util_$search (0, msg_time, msg_seq, code);
	     if code ^= 0 then do;
		call com_err_ (code, name, "Can't find first message in log.");
		go to done;
		end;
	     from_time = msg_time;			/* Official starting time */
	     end;
	else do;					/* -from used, find right message */
	     call syserr_log_util_$search (from_time, msg_time, msg_seq, code);
	     if code ^= 0 then do;
		call com_err_ (code, name, "Locating first message requested.");
		go to done;
		end;
	     end;

	if for_sw then do;				/* Now can compute -for limit */
	     call convert_date_to_binary_$relative (for_arg, to_time, from_time, code);
	     if code ^= 0 then do;
		call com_err_ (code, name, "-for ^a", for_arg);
		go to done;
		end;
	     to_sw = "1"b;				/* Now, just as if -to was specified */
	     end;
	if ^to_sw then to_time = from_time;		/* Initialize last message time */

	indent = 0;

	if chn_sw
	then indent = DEV_LEN + CHN_LEN;
	else indent = DEV_LEN;

	if io_cmd_sw then indent = indent + IOC_LEN;

	syserr_msgp = addr (buffer);			/* Read here */
	mask = "0"b;
	statp = addr (mask);			/* Initialize mask of important things in status word */
	status.t = "1"b;
	status.power = "1"b;
	status.major = "1111"b;
	status.sub = "111111"b;
	status.channel_stat = "111"b;
	status.central_stat = "111"b;

	if detailed_status_sw then do;		/* check callers access to the config_deck, without it can do nothing for him */


	     call hcs_$fs_get_mode (addr (config_deck$), mode, code);
	     if code ^= 0 then do;
no_cd_access:
		call com_err_ (code, name, "Cannot decode detailed status.");
		return;
		end;
	     if (bit (mode) & bit (R_ACCESS_BIN)) ^= bit (R_ACCESS_BIN) then do;
		code = error_table_$no_r_permission;
		goto no_cd_access;
		end;
	     end;


%page;
/* Loop thru the file */

	scan_time = vclock ();
	count_time = 0;
	n_counted, n_statuses = 0;

loop:
	call syserr_log_util_$read (syserr_msgp, hbound (buffer, 1), (0), code);
	if code ^= 0 then do;
	     if code = error_table_$end_of_info then go to print;
	     call com_err_ (code, name, "Reading syserr log");
	     go to done;
	     end;

	if to_sw then do;				/* If time limit */
	     if syserr_msg.time > to_time then go to print;
	     end;
	else to_time = syserr_msg.time;		/* Save last message time */

	if syserr_msg.data_code = SB_io_err | syserr_msg.data_code = SB_io_err_detail
	     | syserr_msg.data_code = SB_disk_err | syserr_msg.data_code = SB_ocdcm_err then do;
	     start_count = vclock ();
	     n_counted = n_counted + 1;
	     call count_it;
	     count_time = count_time + (vclock () - start_count);
	     end;
	go to loop;

/* End of log reached */

print:
	scan_time = vclock () - scan_time - count_time;

	sort_time = vclock ();
	if sort_list.count > 0 then call sort_items_$bit (sortp, 9 * chars_in_sort_info);
	sort_time = vclock () - sort_time;

	print_time = vclock ();
	call print_it;				/* Print results */
	print_time = vclock () - print_time;

/* End of command */

	total_time = vclock () - total_time;

	if meter_sw then do;
	     call ioa_ ("^2/");
	     call ioa_ ("Total:^-^.1f", float (total_time) / 1.0e6);
	     call ioa_ ("Open:^-^.1f", float (open_time) / 1.0e6);
	     call ioa_ ("Scan:^-^.1f", float (scan_time) / 1.0e6);
	     call ioa_ ("Count:^-^.1f (^d records, ^d statuses)", float (count_time) / 1.0e6, n_counted, n_statuses);
	     call ioa_ ("Sort:^-^.1f (^d entries)", float (sort_time) / 1.0e6, sort_list.count);
	     call ioa_ ("Print:^-^.1f", float (print_time) / 1.0e6);
	     buckets_used = 0;
	     longest_chain = 0;
	     do i = 1 to hbound (hash_table, 1);
		if hash_table (i) ^= null () then do;
		     buckets_used = buckets_used + 1;
		     j = 0;
		     do statentp = hash_table (i) repeat (stat.next) while (statentp ^= null ());
			j = j + 1;
		     end;
		     longest_chain = max (j, longest_chain);
		     end;
	     end;
	     call ioa_ ("^d of ^d buckets used, longest list was ^d", buckets_used, n_buckets, longest_chain);
	     end;

done:
	call clean_up;
	return;
%page;
/* Procedure to scan the argument list */

scan_args:
     proc;

	do while (more_args);			/* Do while thins to look at */
	     call get_arg;
	     if arg = "-from" | arg = "-fm" then do;	/* Start time */
		from_sw = "1"b;
		call time_arg (from_time);
		end;
	     else if arg = "-to" then do;		/* Ending time */
		to_sw = "1"b;
		call time_arg (to_time);
		end;
	     else if arg = "-for" then do;		/* Time limit */
		for_sw = "1"b;
		call time_arg (for_time);		/* For syntax checking only */
		for_len = arg_len;			/* Save pointer to this argument */
		for_ptr = arg_ptr;
		end;
	     else if arg = "-device" | arg = "-dv" then do;
						/* List of devices */
		if ^more_args then do;		/* Need more args */
no_dev:
		     call com_err_ (0, name, "Argument missing after -device");
		     go to done;
		     end;
		call get_arg;
		if substr (arg, 1, 1) = "-" then go to no_dev;
						/* Shouldn't be control arg */
new_dev:
		dev_cnt = dev_cnt + 1;		/* Count device found */
		devreq (dev_cnt) = arg;		/* Save name */
		if more_args then do;		/* If more to scan */
		     call get_arg;
		     if substr (arg, 1, 1) ^= "-" then do;
						/* Found another device */
			if dev_cnt < hbound (devreq, 1)
			then go to new_dev;
			else do;			/* Too many */
			     call com_err_ (0, name, "There were more than ^d devices specified.",
				hbound (devreq, 1));
			     go to done;
			     end;
			end;
		     else call put_arg;		/* Went too far, back up 1 */
		     end;
		end;

	     else if arg = "-status" | arg = "-st" then do;
						/* List of statuses */
		if ^more_args then do;		/* Need more args */
no_stat:
		     call com_err_ (0, name, "Argument missing after -status");
		     go to done;
		     end;
		call get_arg;
		if substr (arg, 1, 1) = "-" then go to no_stat;
						/* Shouldn't be control arg */
new_stat:
		stat_req_cnt = stat_req_cnt + 1;	/* Count status found */
		stat_arg = cv_oct_check_ (arg, code);
		if code ^= 0 then do;

		     call com_err_ (code, name, "Status must be octal.");
		     go to done;
		     end;
		statreq.statreq_maj (stat_req_cnt) = substr (unspec (stat_arg), 27, 4);
		statreq.statreq_min (stat_req_cnt) = substr (unspec (stat_arg), 31, 6);
		if more_args then do;		/* If more to scan */
		     call get_arg;
		     if substr (arg, 1, 1) ^= "-" then do;
						/* Found another status */
			if stat_req_cnt < hbound (statreq, 1)
			then go to new_stat;
			else do;			/* Too many */
			     call com_err_ (0, name, "There were more than ^d statuses specified.",
				hbound (statreq, 1));
			     go to done;
			     end;
			end;
		     else call put_arg;		/* Went too far, back up 1 */
		     end;
		end;


	     else if arg = "-detailed_status" | arg = "-dtstat" | arg = "-dtst" then detailed_status_sw = "1"b;

	     else if arg = "-hex_detailed_status" | arg = "-hxdtstat" | arg = "-hxdtst"
	     then hex_detailed_status_sw = "1"b;
	     else if arg = "-meter" then meter_sw = "1"b;

	     else if arg = "-cylinders" | arg = "-cyl" then cyl_sw = "1"b;

	     else if arg = "-tape_data_bit_in_error" | arg = "-tdbie" then tdbie_sw = "1"b;

	     else if arg = "-io_command" | arg = "-ioc" then io_cmd_sw = "1"b;
	     else if arg = "-channel" | arg = "-chn" then chn_sw = "1"b;

	     else do;				/* Bad arg */
		call com_err_ (error_table_$badopt, name, "^a", arg);
		go to done;
		end;
	end;


	if to_sw & for_sw then do;			/* Conflict */
	     call com_err_ (0, name, "Conflicting arguments: -to and -for");
	     go to done;
	     end;

	if hex_detailed_status_sw & detailed_status_sw then do;
						/* ditto */
	     call com_err_ (0, name, "Conflicting arguments: -hex_detailed_status and -detailed_status.");
	     go to done;
	     end;


	return;

     end scan_args;
%page;
/* Procedure to return the next argument from command line */

get_arg:
     proc;

	call cu_$arg_ptr_rel (arg_no, arg_ptr, arg_len, code, arg_list_ptr);
	if code ^= 0 then do;			/* Should never happen */
	     call com_err_ (code, name, "Arg ^d", arg_no);
	     go to done;
	     end;
	arg_no = arg_no + 1;			/* For next call */
	more_args = (arg_no <= arg_count);
	return;

put_arg:
     entry;					/* Entry to return argument after scanning too far */
	arg_no = arg_no - 1;
	more_args = (arg_no <= arg_count);
	return;

     end get_arg;

/* Procedure to convert a time argument */

time_arg:
     proc (t);

dcl  t fixed bin (71);				/* The time to ouput */
dcl  arg_copy char (10) var;				/* Save copy of arg here */

	arg_copy = arg;
	if ^more_args then do;			/* Must be more */
	     call com_err_ (0, name, "Argument required after ^a.", arg_copy);
	     go to done;
	     end;
	call get_arg;
	call convert_date_to_binary_ (arg, t, code);
	if code ^= 0 then do;
	     call com_err_ (code, name, "^a ^a", arg_copy, arg);
	     go to done;
	     end;

	return;

     end time_arg;
%page;
/* Procedure to count a status */

count_it:
     proc;

dcl  ntimes fixed bin;				/* Number of times status occured */
dcl  dev_edit picture "99";
dcl  dev_name char (3);
dcl  detail_temp char (71);				/* 24 bytes */
dcl  (start_char, start_pos) fixed bin;
dcl  1 temp_stat like stat aligned automatic;
dcl  bucket_no fixed bin;
dcl  i fixed bin;
dcl  p ptr;
dcl  temp_char char (8);


	if syserr_msg.data_size < 5
	then					/* not enough info to do aanything */
	     return;

	unspec (temp_stat) = "0"b;
	statentp = addr (temp_stat);
	stat.dsk_sect = 0;
	stat.dsk_mult_rec = "";
	stat.next = null ();

	io_msgp = addr (syserr_msg.data);		/* Point at data portion */

	ntimes = bin (io_msg.count) + 1;
	n_statuses = n_statuses + ntimes;
	stat.devname = io_msg.devname;		/* Pick up name of device */
	if chn_sw
	then stat.chnname = io_msg.channel;		/* Pick up name of channel */
	else stat.chnname = "";

	if substr (stat.devname, 1, 3) = "dsk" | substr (stat.devname, 1, 3) = "tap" then do;
	     substr (stat.devname, 5, 1) = "_";
	     dev_edit = bin (io_msg.device);
	     substr (stat.devname, 6, 2) = dev_edit;
	     end;

	if dev_cnt > 0 then do;			/* Only doing certain devices */
	     do i = 1 to dev_cnt;
		if substr (stat.devname, 1, length (devreq (i))) = devreq (i) then go to dev_wanted;
	     end;
	     return;				/* Not wanted */
dev_wanted:
	     end;

	if stat_req_cnt > 0 then do;			/* Only doing certain stati */
	     do i = 1 to stat_req_cnt;
		if substr (io_msg.status, 3, 4) = statreq.statreq_maj (i) then do;
						/* special case 00 status */
		     if statreq.statreq_min (i) = "00"b3 then do;
			if substr (io_msg.status, 7, 6) = statreq.statreq_min (i) then go to stat_wanted;
			end;

		     else if substr (io_msg.status, 7, 6) & statreq.statreq_min (i) then go to stat_wanted;
		     end;
	     end;
	     return;				/* Not wanted */
stat_wanted:
	     end;


	stat.time_out_sort = "1";			/* 1 means not timeout */
	stat.sysfault_sort = "1";
	if io_cmd_sw
	then stat.command =
		oct_char (bin (substr (io_msg.command, 1, 3))) || oct_char (bin (substr (io_msg.command, 4, 3)));
	else stat.command = "";

	if io_msg.level = "001"b then do;		/* System fault */
	     stat.status = io_msg.status;		/* Use all status */
	     stat.sysfault_sort = "0";		/* To sort before other status */
	     end;

	else if io_msg.level = "011"b then do;		/* If terminate */
	     if io_msg.time_out then do;
		stat.time_out_sort = "0";		/* To sort before others */
		stat.status = "0"b;			/* No status if time out */
		end;

	     else stat.status = io_msg.status & mask;	/* Keep just good part of rest */
	     if cyl_sw = "1"b
	     then					/* only if he wants 'em */
		if index (syserr_msg.text, "disk_control:") ^= 0 then do;
		     stat.dsk_mult_rec = "";
		     start_char = index (syserr_msg.text, "rec ");
		     if start_char > 0
		     then stat.dsk_mult_rec =
			     substr (syserr_msg.text, start_char + 4,
			     (index (substr (syserr_msg.text, start_char + 4), ",") - 1));

		     start_char = index (syserr_msg.text, ", sect ");
		     if start_char > 0
		     then temp_char =
			     substr (syserr_msg.text, start_char + 7,
			     (index (substr (syserr_msg.text, start_char + 7), ",") - 1));

		     stat.dsk_sect = cv_oct_check_ (temp_char, code);
		     end;

	     if (detailed_status_sw | hex_detailed_status_sw) then do;
		if syserr_msg.data_size = 11 then do;
		     dev_name = substr (stat.devname, 1, 3);

		     if dev_name = "prt" | dev_name = "rdr" | dev_name = "pun" then call pack_detail;

		     if dev_name = "dsk" then do;
			if fips_disk (stat.devname)
			then stat.detailed_status = substr (io_msg.detailed_status, 1, 192);
						/* fips disks have 24 bytes */
			else stat.detailed_status = substr (io_msg.detailed_status, 1, 112);
						/* others have 14 bytes */
			end;

		     else if dev_name = "tap" then do;
			stat.detailed_status = substr (io_msg.detailed_status, 1, 208);
						/* Only want 26 bytes */
			if stat.detailed_status = "0"b then go to sort_it;
			if detailed_status_sw then call process_tape_status;

			end;


		     else if dev_name = "prt" then do;
			stat.detailed_status = substr (io_msg.detailed_status, 1, 128);
						/* Only want 16 bytes */

			if stat.detailed_status = "0"b then go to sort_it;
			if detailed_status_sw then call process_prt_status ((stat.devname));
			end;

		     else if dev_name = "rdr" | dev_name = "pun"
		     then stat.detailed_status = substr (io_msg.detailed_status, 1, 72);
						/* Only want 9 bytes */

		     else stat.detailed_status = io_msg.detailed_status;
						/* If none of the above give it all */
		     end;

		else if index (syserr_msg.text, "disk_control:") ^= 0
		     & index (syserr_msg.text, "detailed status:") ^= 0 then do;
		     start_pos = index (syserr_msg.text, "detailed status:") + 17;
		     if start_pos > 0 then do;
			detail_temp =
			     substr (syserr_msg.text, start_pos, (syserr_msg.text_len - 1) - (start_pos - 1));
			if fips_disk (stat.devname)
			then stat.detailed_status = cv_detail (detail_temp, 24);
			else stat.detailed_status = cv_detail (detail_temp, 14);
			end;

		     end;
		end;

	     end;

	else return;
%page;
sort_it:
	bucket_no = hash_index_ (addr (stat.sort_info), chars_in_sort_info, 13, n_buckets) + 1;

	do p = hash_table (bucket_no) repeat (p -> stat.next) while (p ^= null ());
	     if unspec (p -> stat.sort_info) = unspec (stat.sort_info) then do;
		p -> stat.count = p -> stat.count + ntimes;
		return;
		end;
	end;

	allocate stat in (work_area) set (p);
	p -> stat = stat;
	p -> stat.count = ntimes;
	p -> stat.next = hash_table (bucket_no);
	hash_table (bucket_no) = p;

	sort_list.count = sort_list.count + 1;
	sort_list.entryp (sort_list.count) = p;
	return;
%page;
cv_detail:
	proc (detail_string, bytes_wanted) returns (bit (216));
dcl  detail_string char (*);
dcl  bytes_wanted fixed bin;
dcl  (det_idx, bit_idx, hex_idx) fixed bin;
dcl  detailed_bits bit (216) init (""b);

	     det_idx = 1;
	     do bit_idx = 1 to bytes_wanted * 8 by 4;	/* index thru bit string */
find_hex_idx:
		hex_idx = index ("0123456789ABCDEF", substr (detail_string, det_idx, 1));
		if hex_idx = 0 then do;		/* skip spaces or other bad things */
		     det_idx = det_idx + 1;
		     goto find_hex_idx;
		     end;
		substr (detailed_bits, bit_idx, 4) = bit (subtract (hex_idx, 1, 4), 4);
		det_idx = det_idx + 1;
	     end;
	     return (detailed_bits);
	end cv_detail;
%page;
pack_detail:
	proc;
dcl  temp_detail bit (216);
dcl  1 unpacked (24) based (unpack_ptr),
       2 unused bit (1) unaligned,
       2 data bit (8) unaligned;
dcl  packed (27) bit (8) unaligned based (pack_ptr);
dcl  (pack_ptr, unpack_ptr) ptr;
dcl  periph char (4) aligned;
dcl  (dev_idx, byte_idx) fixed bin;
dcl  do_pack bit (1);
dcl  iom_no fixed bin (3);
dcl  chan_no fixed bin (8);
	     periph = substr (stat.devname, 1, 4);
	     do dev_idx = 1 to hbound (dev_pack_list, 1) while (dev_pack_list (dev_idx).valid);
		if dev_pack_list (dev_idx).device = periph then goto pack_it;
	     end;
	     call config_$find_peripheral (periph, iom_no, chan_no, ""b, code);
	     if code ^= 0 then do;
		do_pack = "0"b;
		goto save_info;
		end;
	     mpc_cardp = null ();
	     do while ("1"b);
		call config_$find ("mpc", mpc_cardp);
		if mpc_cardp = null () then do;
		     do_pack = "1"b;
		     goto save_info;
		     end;
		do i = 1 to hbound (mpc_card.port, 1) while (mpc_card.port (i).iom ^= -1);
		     if (iom_no = mpc_card.port (i).iom) & (chan_no >= mpc_card.port (i).chan)
			& (chan_no < mpc_card.port (i).chan + mpc_card.port (i).nchan) then do;
			if mpc_card.model = 2 | mpc_card.model = 600
			then do_pack = "0"b;
			else do_pack = "1"b;
			goto save_info;
			end;
		end;
	     end;
save_info:
	     if dev_idx > hbound (dev_pack_list, 1) then dev_idx = hbound (dev_pack_list, 1);
	     dev_pack_list (dev_idx).valid = "1"b;
	     dev_pack_list (dev_idx).device = periph;
	     dev_pack_list (dev_idx).pack = do_pack;
pack_it:
	     if ^dev_pack_list (dev_idx).pack then return;
	     unpack_ptr = addr (io_msg.detailed_status);
	     pack_ptr = addr (temp_detail);
	     temp_detail = ""b;			/* clear it out */
	     do byte_idx = 1 to hbound (unpacked, 1);	/* Pack it up */
		packed (byte_idx) = unpacked (byte_idx).data;
	     end;
	     io_msg.detailed_status = temp_detail;	/* copy back */
	     return;
	end pack_detail;
     end count_it;
%page;
/* Procedure to print results */

print_it:
     proc;

dcl  (tm1, tm2) char (24);				/* For editing times */
dcl  msg char (256) var;				/* Build status message here */
dcl  (break, is_interesting) bit (1);			/* Flags */
dcl  prev_dev char (8) init ("");
dcl  (i, j, k) fixed bin;
dcl  p ptr;
dcl  name_ck char (3);
dcl  total_status fixed bin;
dcl  ndtstats fixed bin;
dcl  dtstat (1:27) bit (8) unal based (addr (stat.detailed_status));
dcl  temp_detailed_status bit (208) unal based (addr (stat.detailed_status));
dcl  (cyl, head, isect) fixed bin (24);


	call date_time_ (from_time, tm1);		/* Edit start */
	call date_time_ (to_time, tm2);
	call ioa_ ("^/Summary from ^a to ^a^/^/", tm1, tm2);
	call ioa_ ("DEVICE^3x^[CHN^x^;^]^[CMD^2x^;^]COUNT^xIOM STATUS^[/DETAILED STATUS^]", chn_sw, io_cmd_sw,
	     (detailed_status_sw | hex_detailed_status_sw));

	stat_tablep = null ();
	do i = 1 to sort_list.count;
	     statentp = sort_list.entryp (i);
	     break = (prev_dev ^= stat.devname);
	     prev_dev = stat.devname;
	     total_status = stat.count;
	     if break then call pick_status_table;
	     ndtstats = 0;
	     display_detail_count = 0;
	     analysis_string = "";
	     dbie_counts (*) = 0;

	     if (detailed_status_sw | hex_detailed_status_sw) then do;
		do j = i + 1 to sort_list.count;
		     p = sort_list.entryp (j);
		     if p -> stat.devname ^= stat.devname then go to end_dup_scan;
		     if p -> stat.sysfault_sort ^= stat.sysfault_sort then go to end_dup_scan;
		     if p -> stat.time_out_sort ^= stat.time_out_sort then go to end_dup_scan;
		     if p -> stat.status ^= stat.status then go to end_dup_scan;
		     if p -> stat.command ^= stat.command then go to end_dup_scan;
		     if p -> stat.dsk_mult_rec ^= stat.dsk_mult_rec then go to end_dup_scan;

		     total_status = total_status + p -> stat.count;
		     ndtstats = ndtstats + 1;
		end;
end_dup_scan:
		end;

	     if stat.time_out_sort = "0" then msg = "Channel timed out.";
	     else if stat.sysfault_sort = "0" then call ioa_$rsnpnnl ("System fault: ^w", msg, (0), stat.status);
	     else call analyze_device_stat_$rsnnl (msg, stat_tablep, (stat.status), ("0"b));
	     call ioa_ ("^[^/^8a^x^;^9x^s^]^[^3a^x^;^s^]^[(^2a)^x^;^s^]^5d^x^a", break, stat.devname, chn_sw,
		stat.chnname, io_cmd_sw, stat.command, total_status, msg);

	     if stat.dsk_mult_rec ^= "" then do;
		call convert_seek_addr (stat.dsk_sect, stat.devname, stat.chnname, cyl, head, isect);
		call ioa_ ("^vx^6xCylinder ^[???^s^;^3d^] Head ^[??^s^;^2d^] Sector ^[???^s^;^3d^] Record ^a", indent,
		     (cyl = -1), cyl, (head = -1), head, (isect = -1), isect, stat.dsk_mult_rec);
		end;

	     if hex_detailed_status_sw then do;
		do j = i to i + ndtstats;
		     statentp = sort_list.entryp (j);
		     if stat.detailed_status ^= "0"b then do;
			name_ck = substr (stat.devname, 1, 3);
			if name_ck = "dsk" then do;
			     if fips_disk (stat.devname)
			     then k = 24;		/* 24 bytes for fips */
			     else k = 11;		/* 11 bytes for others */
			     end;
			else if name_ck = "tap" then k = 26;
						/* print 26 bytes */
			else if name_ck = "prt" then k = 16;
						/* print 15 bytes */
			else if name_ck = "rdr" | name_ck = "pun" then k = 9;
						/* print 9 bytes */
			else do k = hbound (dtstat, 1) to lbound (dtstat, 1) + 1 by -1 while (dtstat (k) = "0"b);
			end;
			call ioa_ ("^vx^5d^3x^v( ^.4b^)", indent, stat.count, k, dtstat);
			end;
		end;
		i = i + ndtstats;
		end;

	     else if detailed_status_sw then do;
		do j = i to i + ndtstats;
		     statentp = sort_list.entryp (j);
		     if stat.detailed_status ^= "0"b then do;
			if substr (stat.devname, 1, 3) = "tap" then do;
			     call analyze_detail_stat_ ((stat.devname), stat.status, temp_detailed_status,
				my_tape_analp, code);
			     if code ^= 0 then go to end_anal_display;

			     tape_analp = my_tape_analp;

			     if tape_analysis.num_analyzed = 0
			     then if tdbie_sw = "0"b then go to end_anal_display;

			     if tape_analysis.num_analyzed = 0
			     then if (tdbie_sw = "1"b & tape_analysis.tracks_in_error = null_tape_tracks)
				then go to end_anal_display;

			     call tally_details_tape_;
			     if j = i + ndtstats then do;
				call ioa_ ("^vx^5d^3x^a", indent, display_detail_count, analysis_string);
				if tdbie_sw = "1"b then call ioa_ ("^vx^6x^a", indent, rtrim (track_analysis));
				end;
			     go to end_anal_display;
			     end;			/* end tape display */

			else if substr (stat.devname, 1, 3) = "dsk" then do;

			     call analyze_detail_stat_ ((stat.devname), stat.status, (stat.detailed_status),
				my_disk_analp, code);
			     if code ^= 0 then go to end_anal_display;

			     disk_analp = my_disk_analp;

			     call tally_details_disk_;
			     if j = i + ndtstats
			     then call ioa_ ("^vx^5d^3x^a", indent, display_detail_count, ltrim (analysis_string));
			     go to end_anal_display;
			     end;			/* end disk display */


			else if substr (stat.devname, 1, 3) = "prt" then do;

			     call analyze_detail_stat_ ((stat.devname), stat.status, (stat.detailed_status),
				my_prt_analp, code);
			     if code ^= 0 then go to end_anal_display;

			     prt_analp = my_prt_analp;
			     if prt_analysis.num_analyzed = 0 then go to end_anal_display;

			     call tally_details_prt_;

			     if j = i + ndtstats
			     then call ioa_ ("^vx^5d^3x^a", indent, display_detail_count, ltrim (analysis_string));
			     go to end_anal_display;
			     end;			/* end prt display */

			else if substr (stat.devname, 1, 3) = "rdr" | substr (stat.devname, 1, 3) = "pun" then do;
			     call analyze_detail_stat_$rsnnl ((stat.devname), stat.status, (stat.detailed_status),
				msg, is_interesting, code);
			     if is_interesting then call ioa_ ("^vx^5d^3x^a", indent, stat.count, msg);

			     go to end_anal_display;
			     end;			/* end rdr_pun display */

end_anal_display:
			end;
		end;
		i = i + ndtstats;
		end;
	end;
	call ioa_ ("");
	return;

     end print_it;


%page;
convert_seek_addr:
     proc (sector, disk_name, chn_name, cyl_, hd_, sec_);

/* **********************************************************************
   *   given a seek address, this routine returns the sector, head and   *
   *   cylinder information from that address. High efficiency format    *
   *   is assumed.                      			   *
   ********************************************************************** */

dcl  (sector, sec_, sa, cyl_, hd_) fixed bin (24);
dcl  disk_name char (8) aligned;
dcl  chn_name char (8) aligned;
dcl  (dev_idx, i, j) fixed bin;
dcl  (dev_model, dev_no_index, dev_no) fixed bin;
dcl  iom_number fixed bin (3);
dcl  chn_number fixed bin (6);

	cyl_ = -1;
	hd_ = -1;
	sec_ = -1;

	do i = 1 to hbound (dev_idx_list, 1) while (dev_idx_list (i).valid);
	     if dev_idx_list (i).device_name = disk_name then goto calc;
	end;

	if i > hbound (dev_idx_list, 1) then i = hbound (dev_idx_list, 1);
	dev_idx_list (i).valid = "1"b;
	dev_idx_list (i).device_name = disk_name;
	dev_idx_list (i).device_idx = 0;

/* Determine the model of the drive  */

	dev_no_index, dev_model = 0;
	dev_no = cv_dec_check_ (substr (disk_name, 6, 2), code);

	call config_$find_periph (substr (disk_name, 1, 4), prph_dsk_cardp);
						/* will need drive no. later */
	if prph_dsk_cardp = null () then return;

	if chn_sw then do;
	     call parse_io_channel_name_ ((chn_name), iom_number, chn_number, code);
	     call find_controller (iom_number, (chn_number));
	     end;
	else call find_controller (prph_dsk_card.iom, prph_dsk_card.chan);

	if mpc_cardp = null () & ^fips_controller then return;

	do j = 1 to 5 while (dev_model = 0);
	     dev_no_index = dev_no_index + prph_dsk_card.ndrives (j);
	     if dev_no < dev_no_index | (^fips_controller & dev_no = dev_no_index)
	     then dev_model = prph_dsk_card.model (j);
	end;
	if dev_model = 0 then goto calc;		/* device not found */

	do j = 1 to hbound (MODEL, 1) while (dev_idx_list (i).device_idx = 0);
	     if dev_model = MODEL (j) then dev_idx_list (i).device_idx = MODELX (j);
	end;

calc:
	dev_idx = dev_idx_list (i).device_idx;
	if dev_idx < 2 then return;

	sa = divide (sector, sect_per_track (dev_idx), 24, 0);
	sec_ = mod (sector, sect_per_track (dev_idx));
	cyl_ = divide (sa, tracks_per_cyl (dev_idx), 24, 0);
	hd_ = mod (sa, tracks_per_cyl (dev_idx));

	return;
     end convert_seek_addr;
%page;
/* Cleanup handler */

clean_up:
     proc;

	call syserr_log_util_$close (code);

	if sortp ^= null () then call release_temp_segment_ (name, sortp, code);
	if areap ^= null () then call release_area_ (areap);

	return;

     end clean_up;
%page;
pick_status_table:
     proc;

	if substr (stat.devname, 1, 3) = "tap" then stat_tablep = addr (tape_status_table_$tape_status_table_);
	else if substr (stat.devname, 1, 3) = "prt" then stat_tablep = addr (prt_status_table_$prt_status_table_);
	else if substr (stat.devname, 1, 3) = "rdr" then stat_tablep = addr (crz_status_table_$crz_status_table_);
	else if substr (stat.devname, 1, 3) = "pun" then stat_tablep = addr (cpz_status_table_$cpz_status_table_);
	else if substr (stat.devname, 1, 3) = "dsk" then do;
	     if fips_disk (stat.devname)
	     then stat_tablep = addr (fdisk_status_table_$fdisk_status_table_);
	     else stat_tablep = addr (disk_status_table_$disk_status_table_);
	     end;
	else if substr (stat.devname, 1, 3) = "opc" then stat_tablep = addr (opc_status_table_$opc_status_table_);
	else stat_tablep = null;

	return;

     end pick_status_table;
%page;

/* This routine will determine the type of MPC and MTH we are dealing with,
   and then it will mask off meaningless certain bits in the detailed status
   depending on the type of IO error so that the detail status can be sorted
   properly. */

process_tape_status:
     proc;

dcl  mth_type fixed bin;
dcl  iom_number fixed bin (3);
dcl  chn_number fixed bin (6);

	call config_$find_periph (substr (stat.devname, 1, 4), prph_tap_cardp);
	if prph_tap_cardp = null () then return;

	if chn_sw then do;
	     call parse_io_channel_name_ ((stat.chnname), iom_number, chn_number, code);
	     call find_controller (iom_number, (chn_number));
	     end;
	else call find_controller (prph_tap_card.iom, (prph_tap_card.chan));

	if fips_controller then do;
	     stat.detailed_status = stat.detailed_status & fips_tape_mask;
	     return;
	     end;

	if mpc_cardp = null () then return;
	mpc_model = mpc_card.model;

/* Now determine the MTH type */

	if substr (stat.detailed_status, 27, 1) = "0"b then mth_type = 500;
	else if substr (stat.detailed_status, 53, 4) = "4"b4 then mth_type = 600;
	else if substr (stat.detailed_status, 53, 4) = "8"b4 then mth_type = 610;
	else if substr (stat.detailed_status, 53, 4) = "6"b4 then mth_type = 640;


	if mpc_model = 501 | mpc_model = 502 | mpc_model = 600
	then stat.detailed_status = stat.detailed_status & mtc500_mask;

	else if mpc_model = 601 | mpc_model = 602 then stat.detailed_status = stat.detailed_status & mtp601_mask;

	else if mpc_model = 610 | mpc_model = 611 then do;
	     stat.detailed_status = stat.detailed_status & mtp610_mask;

	     if substr (stat.detailed_status, 17, 1) = "1"b
	     then					/* If NRZI then.. */
		stat.detailed_status =
		     stat.detailed_status & "ffffffffffffffffffffffffffffffffff80ffff008264ff0000"b4;

	     else if substr (stat.detailed_status, 17, 3) = "0"b
	     then					/* if PE (1600) */
		stat.detailed_status =
		     stat.detailed_status & "ffffffffffffffffffffffffffffffffff800000008267ff0000"b4;
	     else if substr (stat.detailed_status, 17, 3) = "001"b then do;
						/* if GCR (6250) */
		stat.detailed_status =
		     stat.detailed_status & "ffffffffffffffffffffffffffffffffff8000fff20000ff00ff"b4;
		if substr (stat.detailed_status, 10, 1) = "1"b
		then				/* if write op */
		     substr (stat.detailed_status, 158, 1) = "0"b;

		else if substr (stat.detailed_status, 10, 1) = "0"b
		then				/* if read op */
		     substr (stat.detailed_status, 156, 2) = "0"b;
		end;
	     end;

	if mth_type = 500 then stat.detailed_status = stat.detailed_status & mth500_mask;

	else if mth_type = 600 then stat.detailed_status = stat.detailed_status & mth600_mask;

	else if mth_type = 610 then stat.detailed_status = stat.detailed_status & mth610_mask;

	else if mth_type = 640 then stat.detailed_status = stat.detailed_status & mth640_mask;

	if tdbie_sw = "0"b
	then					/* mask off data bit in err data */
	     stat.detailed_status = stat.detailed_status & "ffffffffffffffffffffffffffffffff001fffffffffffffffff"b4;


	return;
     end process_tape_status;

%page;
process_prt_status:
     proc (prt_name);

dcl  prt_name char (8);
dcl  ptr_model fixed bin;



	if substr (stat.status, 1, 12) = "4201"b3 then do;/* Paper out ? */
	     stat.detailed_status = "0"b;
	     return;
	     end;


/*  Scan the config deck to determine the type of prt we are working on  */


	call config_$find_periph (substr (prt_name, 1, 4), prph_cardp);
	if prph_cardp = null () then return;
	ptr_model = prph_card.model;

	if substr (stat.status, 1, 12) = "4310"b3 then do;/* Paper low ? */
	     if ptr_model = 1200 | ptr_model = 1600
	     then if substr (stat.detailed_status, 61, 1) = "1"b then do;
		     stat.detailed_status = "0"b;
		     return;
		     end;

	     if ptr_model = 901 | ptr_model = 1000 | ptr_model = 1201
	     then if substr (stat.detailed_status, 97, 8) = "09"b4 then do;
		     stat.detailed_status = "0"b;
		     return;
		     end;
	     end;

	if ptr_model = 1200 | ptr_model = 1600 then do;
	     if substr (stat.status, 1, 12) = "4302"b3 |	/* if alrt bef/aftr print */
		substr (stat.status, 1, 12) = "4304"b3 then do;
						/* see if we need to mask off echo ck data */
						/* ECHO CHECK ?? */
		if fixed (substr (stat.detailed_status, 41, 2), 2) > 0
		then				/*  no mask */
		     return;

/* SHORT CKT */
		if fixed (substr (stat.detailed_status, 81, 2), 2) > 0
		then				/*  no mask */
		     return;

		end;				/*  mask off echo check short ckt ctrs */

	     stat.detailed_status = stat.detailed_status & pr71_mask;
	     end;

	else if ptr_model = 901 | ptr_model = 1000 | ptr_model = 1201
	then stat.detailed_status = stat.detailed_status & pr54_mask;
	return;
     end process_prt_status;

%page;
tally_details_disk_:
     proc;
dcl  temp1 char (256) var init ("");
dcl  cur_analysis char (256) var;
dcl  ca_port_str char (50) var init ("");
dcl  ret_str_len fixed bin;

	call ioa_$rsnnl ("^[^2s^;CA ^1o, Port ^2d^/^]", ca_port_str, ret_str_len, disk_analysis.fips_controller,
	     disk_analysis.CA, disk_analysis.PORT);

	if analysis_string = "" then do;		/* first time here for this status */
	     display_detail_count = display_detail_count + stat.count;
	     if disk_analysis.is_interesting_disk
	     then call ioa_$rs ("^vx^8x^v(^a ^)", temp1, analysis_char_count, indent, disk_analysis.num_analyzed,
		     disk_analysis.analyses);
	     analysis_string = ca_port_str || rtrim (temp1);

	     return;
	     end;

	if disk_analysis.is_interesting_disk
	then call ioa_$rs ("^vx^8x^v(^a ^)", temp1, analysis_char_count, indent, disk_analysis.num_analyzed,
		disk_analysis.analyses);

	cur_analysis = ca_port_str || rtrim (temp1);

	if unspec (analysis_string) ^= unspec (cur_analysis) then do;
	     call ioa_ ("^vx^5d^3x^a", indent, display_detail_count, ltrim (analysis_string));
	     analysis_string = cur_analysis;
	     display_detail_count = stat.count;
	     unspec (cur_analysis) = "0"b;
	     return;
	     end;
	else display_detail_count = display_detail_count + stat.count;

	return;
     end tally_details_disk_;

%page;
tally_details_prt_:
     proc;
dcl  temp1 char (50) var init ("");
dcl  temp2 char (256) var init ("");
dcl  cur_analysis char (256) var;


	if analysis_string = "" then do;		/* first time here for this status */
	     display_detail_count = display_detail_count + stat.count;

	     if prt_analysis.density ^= ""
	     then call ioa_$rs ("^vx^8x^a", temp1, analysis_char_count, indent, prt_analysis.density);
	     call ioa_$rs ("^vx^8x^v(^a ^)", temp2, analysis_char_count, indent, prt_analysis.num_analyzed,
		prt_analysis.analyses);

	     analysis_string = rtrim (temp1) || rtrim (temp2);

	     return;
	     end;

	if prt_analysis.density ^= ""
	then call ioa_$rs ("^vx^8x^a", temp1, analysis_char_count, indent, prt_analysis.density);
	call ioa_$rs ("^vx^8x^v(^a ^)", temp2, analysis_char_count, indent, prt_analysis.num_analyzed,
	     prt_analysis.analyses);

	cur_analysis = rtrim (temp1) || rtrim (temp2);

	if unspec (analysis_string) ^= unspec (cur_analysis) then do;
	     call ioa_ ("^vx^5d^3x^a", indent, display_detail_count, ltrim (analysis_string));
	     analysis_string = cur_analysis;
	     display_detail_count = stat.count;
	     unspec (cur_analysis) = "0"b;
	     return;
	     end;
	else display_detail_count = display_detail_count + stat.count;

	return;
     end tally_details_prt_;

%page;
tally_details_tape_:
     proc;
dcl  (temp1, tracks_hdr, tracks_str) char (150) var init ("");
dcl  temp2 char (256) var init ("");
dcl  cur_analysis char (256) var;
dcl  (i, tracks) fixed bin;
dcl  dbie_7track (7) fixed bin;

	if analysis_string = "" then do;		/* first time here for this status */
	     call ioa_$rs ("Operation: ^a, Density: ^d Tracks: ^d", temp1, analysis_char_count, tape_analysis.operation,
		tape_analysis.density, tape_analysis.num_tracks);

	     if tdbie_sw then do;
		if null_tape_tracks ^= tape_analysis.tracks_in_error then do;
		     tracks = tape_analysis.num_tracks;
		     call ioa_$rs ("^[^a^;^s^]^[^a^;^s^]", tracks_hdr, analysis_char_count, (tracks = 9), db_trk_str9,
			(tracks = 7), db_trk_str7);
		     do i = 1 to 9;
			if tape_analysis.dbie_array (i) ^= 0
			then dbie_counts (i) = tape_analysis.dbie_array (i) * stat.count;
		     end;
		     if tracks = 9
		     then call ioa_$rs ("^vx^6xError Count:  ^v(^4d ^)", tracks_str, analysis_char_count, indent, 9,
			     dbie_counts);

		     else do;			/* convert array */
			do i = 3 to 9;
			     dbie_7track (i - 3) = dbie_counts (i);
			end;
			call ioa_$rs ("^vx^6xError Count:  ^v(^4d ^)", tracks_str, analysis_char_count, indent, 7,
			     dbie_7track);
			end;

		     end;
		end;

	     if tape_analysis.num_analyzed > 0
	     then call ioa_$rsnnl ("^vx^8x^v(^a ^)", temp2, analysis_char_count, indent, tape_analysis.num_analyzed,
		     tape_analysis.analyses);

	     analysis_string = rtrim (temp1) || rtrim (temp2);
	     track_analysis = rtrim (tracks_hdr) || rtrim (tracks_str);
	     display_detail_count = stat.count;
	     return;
	     end;

	call ioa_$rs ("Operation: ^a, Density: ^d Tracks: ^d", temp1, analysis_char_count, tape_analysis.operation,
	     tape_analysis.density, tape_analysis.num_tracks);

	if tdbie_sw then do;
	     if null_tape_tracks ^= tape_analysis.tracks_in_error then do;

		tracks = tape_analysis.num_tracks;
		call ioa_$rs ("^[^a^;^s^]^[^a^;^s^]", tracks_hdr, analysis_char_count, (tracks = 9), db_trk_str9,
		     (tracks = 7), db_trk_str7);
		do i = 1 to 9;
		     if tape_analysis.dbie_array (i) ^= 0
		     then dbie_counts (i) = dbie_counts (i) + (tape_analysis.dbie_array (i) * stat.count);
		end;
		if tracks = 9
		then call ioa_$rs ("^vx^6xError Count:  ^v(^4d ^)", tracks_str, analysis_char_count, indent, 9,
			dbie_counts);

		else do;				/* convert array */
		     do i = 3 to 9;
			dbie_7track (i - 3) = dbie_counts (i);
		     end;
		     call ioa_$rs ("^vx^6xError Count:  ^v(^4d ^)", tracks_str, analysis_char_count, indent, 7,
			dbie_7track);
		     end;

		end;
	     end;

	if tape_analysis.num_analyzed > 0
	then call ioa_$rsnnl ("^vx^8x^v(^a ^)", temp2, analysis_char_count, indent, tape_analysis.num_analyzed,
		tape_analysis.analyses);

	cur_analysis = rtrim (temp1) || rtrim (temp2);
	track_analysis = rtrim (tracks_hdr) || rtrim (tracks_str);
	if unspec (analysis_string) ^= unspec (cur_analysis) then do;
	     call ioa_ ("^vx^5d^3x^a", indent, display_detail_count, analysis_string);
	     analysis_string = cur_analysis;
	     display_detail_count = stat.count;
	     return;
	     end;
	else display_detail_count = display_detail_count + stat.count;

	return;
     end tally_details_tape_;
%page;
find_controller:
     proc (a_iom, a_chan);
dcl  a_iom fixed bin (3);
dcl  a_chan fixed bin (8);

	fips_controller = "0"b;
	ipc_cardp = null ();
	mpc_cardp = null ();
	do while ("1"b);
	     call config_$find ("mpc", mpc_cardp);
	     if mpc_cardp = null () then goto check_for_fips;
	     do i = 1 to hbound (mpc_card.port, 1) while (mpc_card.port (i).iom ^= -1);
		if (a_iom = mpc_card.port (i).iom) & (a_chan >= mpc_card.port (i).chan)
		     & (a_chan < mpc_card.port (i).chan + mpc_card.port (i).nchan)
		then return;
	     end;
	end;

check_for_fips:
	do while ("1"b);
	     call config_$find ("ipc", ipc_cardp);
	     if ipc_cardp = null () then return;
	     if (a_iom = ipc_card.iom) & (a_chan >= ipc_card.chan) & (a_chan < ipc_card.chan + ipc_card.nchan) then do;
		fips_controller = (ipc_card.type = "fips");
		return;
		end;
	end;
     end find_controller;
%skip (4);
fips_disk:
     proc (disk_name) returns (bit (1));

dcl  disk_name char (8) aligned;
dcl  i fixed bin;


	do i = 1 to hbound (disk_list, 1) while (disk_list (i).valid);
	     if disk_list (i).device_name = disk_name then return (disk_list (i).fips);
	end;

	if i > hbound (disk_list, 1) then i = hbound (disk_list, 1);
	disk_list (i).valid = "1"b;
	disk_list (i).device_name = disk_name;
	disk_list (i).fips = ""b;

	call config_$find_periph (substr (disk_name, 1, 4), prph_dsk_cardp);
	if prph_dsk_cardp = null () then return (""b);

	call find_controller (prph_dsk_card.iom, prph_dsk_card.chan);

	disk_list (i).fips = fips_controller;
	return (fips_controller);
     end fips_disk;
%page;
%include syserr_message;
%page;
%include io_syserr_msg;
%page;
%include iom_stat;
%page;
%include syserr_binary_def;
%page;
%include area_info;
%page;
%include analyze_det_stat_info;
%page;
%include config_prph_tap_card;
%page;
%include config_prph_dsk_card;
%page;
%include config_prph_card;
%page;
%include fs_dev_types;
%page;
%include config_ipc_card;
%page;
%include config_mpc_card;
%page;
%include access_mode_values;


     end io_error_summary;
