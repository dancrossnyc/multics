/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
     audit(86-02-18,Coppola), install(86-07-18,MR12.0-1098):
     Support FIPS.
  2) change(86-01-16,Fawcett), approve(86-04-10,MCR7383),
     audit(86-06-05,Coppola), install(86-07-18,MR12.0-1098):
     Add support for 512_WORD_IO devices.
  3) change(86-06-04,Hartogs), approve(86-06-04,MCR7383),
     audit(86-06-05,Coppola), install(86-07-18,MR12.0-1098):
     Changed to use version constant in rcp_disk_info.incl.pl1
  4) change(86-10-21,Fawcett), approve(86-10-21,PBF7383),
     audit(86-10-23,Farley), install(86-10-28,MR12.0-1200):
     Change the d338 to 3380 and d339 to 3381.
                                                   END HISTORY COMMENTS */

exercise_disk: proc;


/* Written by B. Greenberg sometime in '75 */
/* Modified by P.B. Kelley 02/05/79 - to add the "-all" control argument.	  	*/
/*	The sector ranges were changed to NOT include those in the ALT partition,	*/
/*	unless the  "-all" control argument were given.				*/
/* Modified by Michael R. Jordan 1/80  to add -system (-sys) */


/* ********************************************************
   *    Completely re-written July 1980 by R.L. Coppola   *
   ******************************************************** */

/*  Modified 5/81 by Rich Coppola to remove PL1 I/O. */
/*  Modified 5/81 by Rich Coppola to add -no_write_compare (-nwc) */
/*  Modified 5/81 by Rich coppola to call analyze_detail_stat_ to have
   detailed status interpreted. */
/*  Modified Oct 1982 by Rich Coppola to change call to analyze_detail_stat_
   to use new calling sequence.
*/
/*  Modified 6/85 by Rich Fawcett
	   to use only 512_seeks for MSU3380s and MSU3381s and delete MSU0509 */
/* ****************************************************************************
   *   This test is intended to be an extension of the standard T&D's.	 *
   *   when they cannot reproduce a problem the FER should invoke this 	 *
   *   test to attempt to replicate the problem experienced by the customer.	 *
   *   This test uses the write and verify command to ensure that,
   *   as much as possible, all error conditions are captured.
   *
   **************************************************************************** */



/* Subroutine entry declarations */


	dcl     iox_$find_iocb	 entry (char (*), ptr, fixed bin (35));

	dcl     iox_$destroy_iocb	 entry (ptr, fixed bin (35));

	dcl     analyze_device_stat_$rsnnl entry (char (*) var, ptr, bit (72) aligned, bit (18) aligned);

	dcl     analyze_detail_stat_$rsnnl entry (char (*), bit (36) aligned, bit (*) unal, char (*) var, bit (1), fixed bin (35));

	dcl     disk_status_table_$disk_status_table_ ext;

	dcl     clock_		 entry returns (fixed bin (52));

	dcl     command_query_	 entry options (variable);

	dcl     error_table_$badopt	 external fixed bin (35);

	dcl     error_table_$noarg	 external fixed bin (35);


	dcl     error_table_$device_parity fixed bin (35) ext static;

	dcl     com_err_		 entry options (variable);

	dcl     cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin, fixed bin (35));

	dcl     cu_$arg_count	 entry () returns (fixed bin);

	dcl     date_time_		 entry (fixed bin (52), char (*));

	dcl     ioa_		 entry options (variable);

	dcl     cv_dec_check_	 entry (char (*), fixed bin (35)) returns (fixed bin (35));

	dcl     error_table_$wrong_no_of_args fixed bin (35) ext static;


/* Automatic */

	dcl     dt		 char (24);
	dcl     code		 fixed bin (35);
	dcl     argptr		 ptr,		/* Pointers to input args  */
	        argcnt		 fixed bin,	/* number of args */
	        arglen		 fixed bin,	/* Lengths of input args  */
	        arg		 char (arglen) based (argptr),
	        arg_sw		 bit (1) init ("1"b);
	dcl     i			 fixed bin;	/* iteration var's */
	dcl     arg1		 char (8) varying;
	dcl     pack_id		 char (12);
	dcl     (from_sw, to_sw, dev_sw) bit (1) init ("0"b);
	dcl     (from, to_)		 fixed bin (24);
	dcl     dev_idx		 fixed bin;
	dcl     words_per_sector	 fixed bin init (64);
	dcl     (a, seek_counter)	 fixed bin;	/* counter) for the write read pass */
	dcl     (x, y, sectors_written, sectors_read, highest_sector, loest_sector) fixed bin (24);
	dcl     seek_addr_read	 fixed bin (24);
	dcl     to_sector		 fixed bin (24);
	dcl     device_type		 char (4);
	dcl     model_num		 fixed bin;

	dcl     1 my_key1,
		2 key1_len	 fixed bin init (8),
		2 f91		 pic "99999999";

	dcl     1 my_key2,
		2 key2_len	 fixed bin init (8),
		2 f92		 pic "99999999";

	dcl     key1		 char (256) var based (addr (my_key1));
	dcl     key2		 char (256) var based (addr (my_key2));
	dcl     (data_init_sw, compare_err) bit (1) init ("0"b);
	dcl     constant_		 bit (36) init ("0"b);
	dcl     doing		 char (5) var init ("");
	dcl     (cleanup, program_interrupt) condition;
	dcl     (ii, err_cnt)	 fixed bin init (0);
	dcl     system		 char (4) varying init ("");
	dcl     write_compare	 char (7) varying init ("wrtcmp");
	dcl     (rec_len, read_data_len) fixed bin (21);


	dcl     1 errors		 (50) aligned,
		2 iom_status_	 bit (72),
		2 det_status	 (11) bit (8) unal,
		2 dev_cmd_	 fixed bin,
		2 seek_addr_	 fixed bin (24);

	dcl     (quit_flag, ndc_sw, alt_sw) bit (1) init ("0"b);
	dcl     (random_sw, read_sw, write_sw) bit (1);	/* bit switches for program modes */
	dcl     (seq_sw, range_sw, dev_evn, dev_attached, dev_open) bit (1) init ("0"b);
	dcl     mode_string		 char (11);	/* string storage for ioa_ */
	dcl     (write_errors, read_errors, read_cmp_err, seek_errors) fixed bin;
	dcl     answer		 char (32) varying;
	dcl     (data_bufp, read_ptr, stat_tablep, iocbp, dev_infop, dev_statp, querie) ptr;
	dcl     (sa1, sn1, cn1, hn1, seek, seek1, seek2) fixed bin (24);
	dcl     (PC, PH, epc, opc)	 fixed bin (24);

	dcl     1 device_info	 aligned,		/* my dev info from exdim_ */
		2 dev_type_	 char (4),	/* the model number */
		2 dev_name	 char (8),	/* i.e. dskx_xx */
		2 sect_per_dev_	 fixed bin (35),
		2 cyl_per_dev_	 fixed bin,
		2 sect_per_cyl_	 fixed bin,
		2 sect_per_track_	 fixed bin,
		2 num_label_sect_	 fixed bin,
		2 num_alt_sect_	 fixed bin,
		2 sect_size_	 fixed bin (12);

	dcl     1 device_status_info	 aligned,		/* device status info */
		2 iom_status	 bit (72),
		2 detail_status	 (11) bit (8) unal,
		2 dev_cmd		 fixed bin,
		2 seek_addr	 fixed bin (24);

	dcl     device_name		 char (8);
	dcl     open_mode		 fixed bin init (13); /* assume write oper. */
	dcl     options_ptr		 ptr;
	dcl     1 options_,
		2 num_opts	 fixed bin,
		2 options		 (6) char (32) varying;


/* Static */

	dcl     myname		 char (13) init ("exercise_disk") static options (constant);
	dcl     str1		 bit (4) init ("1101"b) static options (constant);
	dcl     str2		 bit (4) init ("1011"b) static options (constant);
	dcl     str3		 bit (4) init ("0110"b) static options (constant);
	dcl     err_retry		 fixed bin static init (0);
	dcl     cmd_tbl		 (26:28) char (1) int static options (constant) init
				 ("R", "W", "S");
	dcl     TRUE		 bit (1) int static options (constant) init ("1"b);
	dcl     FALSE		 bit (1) int static options (constant) init ("0"b);
	dcl     test_in_progress	 fixed bin internal static;
	dcl     d500_sw		 bit (1) init ("0"b);


/* Based */

	dcl     data		 (0:(words_per_sector - 1)) bit (36) based (data_bufp) aligned;
	dcl     read_data		 (0:(words_per_sector - 1)) bit (36) based (read_ptr);

/* Builtins */

	dcl     (addr, addrel, bin, bit, ceil, char, clock, divide, fixed, floor, hbound, index, length, ltrim, max, min, mod, null, rel, rtrim, substr, unspec) builtin;


	if test_in_progress = -1 then do;
		call com_err_ (0, myname, "exercise_disk has been recursively invoked ");
		call com_err_ (0, myname, "enter the release (rl) command and re-call");
		return;
	     end;

/*                  Housekeeping                  */

	stat_tablep = addr (disk_status_table_$disk_status_table_);
	device_name = "";
	sectors_written, sectors_read, write_errors = 0;
	read_errors, seek_errors, read_cmp_err = 0;
	querie = addr (query_info);
	yes_or_no_sw = TRUE;
	repeat_time = 60;
	cp_escape_control = "11"b;			/* allow cp escape */
	suppress_name_sw = FALSE;
	constant_ = str1 || str2 || str3 || str1 || str2 || str3 || str1 || str2 || str3;
	data_bufp = null;
	read_ptr = null;
	from, to_, loest_sector = 0;


	on cleanup begin;
		call EXIT;
		test_in_progress = 0;
	     end;

	argcnt = cu_$arg_count ();

	if argcnt < 2 then do;
		arg_sw = "0"b;
		code = error_table_$wrong_no_of_args;
		go to bad_arg;
	     end;

	a = 1;					/* set to get first argument */
	call cu_$arg_ptr (a, argptr, arglen, code);
	if code ^= 0				/* No arg1  */
	then do;
		arg_sw = "0"b;
		go to bad_arg;			/* inform user on correct call */
	     end;

	arg1, device_type = arg;
						/*        Verify Device Type    */

	do i = 1 to maxdevt;
	     if device_type = device_names (i) then do;
		     model_num = MODELN (i);
		     if MODELN (i) >= 500 then
			d500_sw = "1"b;
		     dev_idx = i;
		end;
	end;



/*                            Get high sector no.                            */
	highest_sector = get_dev_size (code);
	if code ^= 0
	then go to bad_arg;				/* inform user on correct call */


/*                            Get pack Ser No. for Mount MSG.                */

	a = 2;					/* set up to get second argument */
	call cu_$arg_ptr (a, argptr, arglen, code);
	if code ^= 0
	then do;
		arg_sw = "0"b;
		go to bad_arg;			/* tell him how to invoke */
	     end;

	pack_id = rtrim (arg);
						/*                            See if there are anymore args                  */

	random_sw, write_sw, read_sw = TRUE;		/* set defaults */
	seq_sw, range_sw, ndc_sw, alt_sw = FALSE;	/* set defaults */
	from, to_ = 0;

	if argcnt > 2 then /* process control args if they exist */
	     do a = 3 to argcnt;

		arg_sw = "1"b;
		call cu_$arg_ptr (a, argptr, arglen, code);
		if code ^= 0
		then go to bad_arg;

		if arg = "-w" | arg = "-write" then do;
			read_sw = FALSE;		/* turn off read switch */
			write_sw = TRUE;		/* turn on write switch */

		     end;


		else if arg = "-r" | arg = "-read" then do;
			read_sw = TRUE;
			write_sw = FALSE;		/* turn off write switch */
			open_mode = 11;		/* set to read only */
		     end;




		else if arg = "-wr" | arg = "-write_read" then do; /* default but set them, anyway */
			read_sw = TRUE;
			write_sw = TRUE;

		     end;

		else if arg = "-device" |
		     arg = "-dv" then do;		/* he wants to select a specific  drive */
			a = a + 1;		/* bump arg ptr */
			call cu_$arg_ptr (a, argptr, arglen, code);

			if code ^= 0 then
			     go to bad_arg;

			if (arglen ^= 7) | (substr (arg, 1, 3) ^= "dsk") then do;
				a = a - 1;
				go to bad_arg;
			     end;

			else device_name = arg;
			dev_sw = "1"b;
		     end;


		else if arg = "-ndc" | arg = "-no_data_compare" then
		     ndc_sw = TRUE;			/* Turn off data compare on read  */

		else if arg = "-alternate_track" | arg = "-altrk" then /* pack formatted with alt tracks */
		     alt_sw = TRUE;


		else if arg = "-random" then /* random option */
		     random_sw = TRUE;


		else if arg = "-sequential" | arg = "-sq" then do; /* sequential seek option */
			random_sw = FALSE;
			seq_sw = TRUE;
		     end;

		else if arg = "-from" | arg = "-fm" then do;
			range_sw = TRUE;
			random_sw = FALSE;
			a = a + 1;
			call cu_$arg_ptr (a, argptr, arglen, code);

			if code ^= 0 then
			     go to bad_arg;

			if index (arg, "-") ^= 0
			then go to bad_arg;

			from = cv_dec_check_ (arg, code);

			if code ^= 0 then
			     go to bad_arg;

			loest_sector = get_seek_addr (from, code);
			if code ^= 0 then
			     go to bad_arg;

			from_sw = TRUE;
		     end;

		else if arg = "-to" then do;

			range_sw = TRUE;
			a = a + 1;
			call cu_$arg_ptr (a, argptr, arglen, code);

			if code ^= 0 then
			     go to bad_arg;

			if index (arg, "-") ^= 0
			then go to bad_arg;

			to_ = cv_dec_check_ (arg, code);

			if code ^= 0 then
			     go to bad_arg;

			to_sector = get_seek_addr (to_, code);
			if code ^= 0 then
			     go to bad_arg;

			to_sw = TRUE;
		     end;

		else if arg = "-system" | arg = "-sys"
		then system = "-sys";

		else if arg = "-no_write_compare" | arg = "-nwc" then
		     write_compare = "^wrtcmp";


		else do;				/* unrecognizable arg */
bad_arg:

			if arg_sw = "1"b then do;
				code = error_table_$badopt;
				call com_err_ (code, myname, "Invalid or unrecognizable control arg in string (^a).", arg);
			     end;
			else do;
				code = error_table_$noarg;
				call com_err_ (code, myname, "Number of args received insufficient.");
			     end;
			call ioa_ ("^a: Usage: exercise_disk DEVICE_TYPE PACK_ID {-control_args}", myname);
			return;
		     end;
	     end;


done_args:


	if MODELN (dev_idx) > 451 then /* all 5xx have alt tracks */
	     alt_sw = "1"b;


	call ioa_ ("^/^a: Device type is ^a pack serial no. is ^a", myname, arg1, pack_id);
	if write_sw then do;			/* ask only if writing */
		call ioa_ ("^a: exercise_disk will destroy all data on this pack ! ", myname);
		call command_query_ (querie, answer, myname, "Do You Wish To Continue?");
		if answer ^= "yes" then
		     return;
	     end;
start:

	options_.num_opts = 2;
	options_.options (*) = "";			/* init options */
	options_.options (1) = arg1;			/* now fill 'em in */
	options_.options (2) = pack_id;

	if dev_sw then do;
		options_.num_opts = options_.num_opts + 2;
		options_.options (options_.num_opts - 1) = "-dv";
		options_.options (options_.num_opts) = device_name;
	     end;
	if write_sw then do;
		options_.num_opts = options_.num_opts + 1;
		options_.options (options_.num_opts) = "-write";
	     end;
	if system = "-sys" then do;
		options_.num_opts = options_.num_opts + 1;
		options_.options (options_.num_opts) = system;
	     end;


	call ioa_ ("^a: Requesting mount of volume ^a^[ on ^a^].", myname, pack_id, dev_sw, device_name);

	iocbp = null;

	call iox_$find_iocb ("exercise_disk", iocbp, code);
	if code ^= 0 then do;
		call com_err_ (code, myname, "Finding IOCB.");
		return;
	     end;

	test_in_progress = -1;			/* we have really started */

	options_ptr = addr (options_);
	call exdim_attach (iocbp, options_ptr, "0"b, code);

	if code ^= 0 then do;
		call com_err_ (code, "exercise_disk", "Attaching I/O disk.");
		go to llose;
	     end;

	dev_attached = "1"b;

	call exdim_open (iocbp, open_mode, code);
	if code ^= 0 then do;
		call com_err_ (code, myname, "Setting opening mode ^a", open_mode);
		go to llose;
	     end;

	dev_open = "1"b;

	if alt_sw then do;				/* Alt track setup */
		call exdim_modes (iocbp, "^label,alttrk," || write_compare, code);
		if code ^= 0 then do;
			call com_err_ (code, myname, "Setting modes (altrk).");
			go to llose;
		     end;

		highest_sector = last_sect_num (dev_idx);
	     end;



	else do;					/* No ^alt. trk format */
		call exdim_modes (iocbp, "^label," || write_compare, code);
		if code ^= 0 then do;
			call com_err_ (code, myname, "Setting modes.");
		     end;
	     end;

	words_per_sector = words_per_sect (dev_idx);


	if write_sw then /* option w or wr */
	     allocate data set (data_bufp);

	if read_sw then do;
		allocate read_data set (read_ptr);	/* option wr or r */
		if ^write_sw then
		     if ^ndc_sw then
			allocate data set (data_bufp);/* option r */
	     end;

	if random_sw				/* fill in string for startup message */
	then mode_string = "random";

	else if seq_sw
	then mode_string = "sequential";

	else mode_string = "range";

	dev_infop = addr (device_info);
	call exdim_control (iocbp, "device_info", dev_infop, code);
	device_name = dev_name;

	if mod (bin (substr (device_name, 6, 2)), 2) = 0 then
	     dev_evn = "1"b;

	else dev_evn = "0"b;

	rec_len, read_data_len = 4 * sect_size_;	/* num chars in a sector */

	call date_time_ (clock_ (), dt);
	call ioa_ ("^/^a: Begin ^a test on ^a (^a) @  ^a", myname, mode_string, dev_name, dev_type_, substr (dt, 11, 6));

	on program_interrupt begin;
		call convert_seek_addr (seek, sa1, sn1, cn1, hn1); /* get cyl and head info */
		call ioa_ ("^a:^2xCurrently at cyl ^d head ^d", myname, cn1, hn1);
		call ioa_ ("^a:^2xsectors read^10d; sectors written^10d.", myname, sectors_read, sectors_written);
	     end;

	if random_sw				/* check random versus sequential */
	then do;					/* random test */
		seek_counter = 0;
		do while (seek_counter < 10000000);	/* a nominal number */
start_rand:	     x = mod (clock (), highest_sector);/* generate one seek address */
		     y = highest_sector - x;		/* and its converse */
		     err_retry = 0;			/* zero on successful io */
random_write:	     if write_sw then do;		/* first do the write of two sectors */
			     seek1 = x;
			     seek2 = y;
			     call write_sector;
			     seek_counter = seek_counter + 2; /* bump counter */
			end;			/* end of write of two sectors */

		     if read_sw then do;		/* do read of two sectors */
			     seek1 = x;
rand_read:		     call read_sector;
			     seek1 = y;
			     call read_sector;
			     seek_counter = seek_counter + 2; /* bump counter by number of reads */
			end;			/* end of read of two sectors */
		end;				/* seek_counter now max */
	     end;					/* end of a random pass */

	else if seq_sw then
	     do x = 0 to (highest_sector - 1) by 2;	/* walk through sequentially */
start_seq:	y = x + 1;
		err_retry = 0;			/* zero on successful io */
seq_write:	if write_sw then do;		/* write two sectors */
			seek1 = x;
			seek2 = y;
			call write_sector;
		     end;				/* end of writing two */

		if read_sw then do;			/* read two sectors */
			seek1 = x;
seq_read:			call read_sector;
			seek1 = y;
			call read_sector;
		     end;				/* end of read of two sectors */
	     end;					/* end of a sequential pass */


	else do;					/* Must be a range */

start_range:	x = loest_sector;			/* Beginning seek addr */
		y = to_sector;
range_cont:	err_retry = 0;

range_write:	if write_sw then do;
			seek1 = x;
			seek2 = y;
			call write_sector;
		     end;

range_read:	if read_sw then do;
			seek1 = x;
			call read_sector;
			seek1 = y;
			call read_sector;
		     end;

		err_retry = 0;

		x = x + 1;
		y = y - 1;


		if x = to_sector then
		     go to start_range;

		else go to range_write;
	     end;

llose:
	call EXIT;
	return;


error1:

	err_retry = err_retry + 1;
	call error;

	if quit_flag then /* time to go home */
	     go to llose;

	if err_retry = 5 then do;			/* have reached the limit */
		err_retry = 0;
		call command_query_ (querie, answer, myname, "Unrecoverable disk error.  Do you wish to continue?");
		if answer ^= "yes" then do;
			go to llose;
		     end;


		if random_sw then go to start_rand;

		else if seq_sw then go to start_seq;
		else go to range_write;
	     end;

	if random_sw & ^compare_err then
	     go to random_write;			/* go retry */

	if random_sw & compare_err then
	     go to rand_read;			/* see if we can read and display the mis-compare */

	if seq_sw & ^compare_err then
	     go to seq_write;

	if seq_sw & compare_err then
	     go to seq_read;

	if range_sw & ^compare_err then
	     go to range_write;

	if range_sw & compare_err then
	     go to range_read;

	else go to llose;				/* must be lost */


%page;

write_sector: proc;

/* ************************************************************************
   *   this routine is used to issue the write and read and compare the    *
   *   data read from the read command			       *
   ************************************************************************ */

	dcl     (data_was, data_sb)	 bit (36 * words_per_sector) based;
	dcl     (seek_addr, sect_no, cylno, hdno) fixed bin (24);
	dcl     z			 fixed bin;



	f91 = seek1;
	f92 = seek2;
	seek = seek1;
	call build_sb;				/* build the data buffer */
	call exdim_seek (iocbp, key1, rec_len, code);

	if code ^= 0 then do;
		call com_err_ (code, myname, "Attempt to use an invalid seek key (^a).", f91);
		go to llose;
	     end;


	call exdim_rewrite (iocbp, data_bufp, rec_len, code);

	if code ^= 0 then do;
		if code ^= error_table_$device_parity then do; /* my prob */
			call com_err_ (code, myname, "Performing rewrite operation.");
			go to llose;
		     end;

		else go to error1;
	     end;

	seek = seek2;
	call build_sb;				/* build the data buffer */
	call exdim_seek (iocbp, key2, rec_len, code);

	if code ^= 0 then do;
		call com_err_ (code, myname, "Attempt to use an invalid seek key (^a).", f92);
		go to llose;
	     end;


	call exdim_rewrite (iocbp, data_bufp, rec_len, code);

	if code ^= 0 then do;
		if code ^= error_table_$device_parity then do; /* my prob */
			call com_err_ (code, myname, "Performing rewrite operation.");
			go to llose;
		     end;

		else go to error1;
	     end;

	sectors_written = sectors_written + 2;		/* keeep track of what weve done */

	return;

read_sector: entry;
	seek, f91 = seek1;
	if ndc_sw then ;				/* do nothing if not checking data */

	else do;					/* user requested data compare */
		call build_sb;			/* so generate a "should be" image */
		read_ptr -> data_was = FALSE;		/* zap the read buffer */
	     end;					/* finished preparingg for data compare */


	call exdim_seek (iocbp, key1, rec_len, code);

	if code ^= 0 then do;
		call com_err_ (code, myname, "Attempt to use an invalid seek key (^a).", f91);
		go to llose;
	     end;


	call exdim_read (iocbp, read_ptr, read_data_len, rec_len, code);

	if code ^= 0 then do;
		if code ^= error_table_$device_parity then do; /* my prob */
			call com_err_ (code, myname, "Performing read operation.");
			go to llose;
		     end;

		else go to error1;
	     end;

	sectors_read = sectors_read + 1;		/* keep track of what weve done */
	if ndc_sw					/* check not data compare switch */
	then ;					/* no data compare wanted */

	else do;					/* now check the read versus the should be */
		if read_ptr -> data_was = data_bufp -> data_sb /* fast compare on entire sector */
		then ;				/* they are equal...all is well */

		else do z = 0 to (words_per_sector - 1);/* fast compare failed so walk and find first error */
			if data (z) ^= read_data (z) then do;
				call ioa_ ("^/^a data compare error at address ^d, word ^d", myname, seek, z);
				call convert_seek_addr (seek, seek_addr, sect_no, cylno, hdno);
				if z = 0 then do;	/* error in seek addr */
					seek_addr_read = bin (substr (read_data (0), 13, 24), 24);
					call ioa_ ("Word in error is the seek address.");
					call ioa_ ("Word 0 should be: ^d (cyl ^4d, head ^3d, sector ^4d).",
					     seek, cylno, hdno, sect_no);

					call convert_seek_addr (seek_addr_read, seek_addr, sect_no, cylno, hdno);
					call ioa_ ("Word 0 was      : ^d (cyl ^4d, head ^3d, sector ^4d).",
					     seek_addr_read, cylno, hdno, sect_no);
					read_cmp_err = read_cmp_err + 1;
					return;
				     end;


				call ioa_ ("^9x Seek Address^2x^d^2xSector^2x^d^2xCyl^2x^d^2xHead^2x^d",
				     seek_addr, sect_no, cylno, hdno);

				call ioa_ ("^/^9xWord ^d^5xWord ^d^5xWord ^d^5xWord ^d", z, z + 1, z + 2, z + 3);
				call ioa_ ("^2xis:^3x^.4b^2x^.4b^2x^.4b^2x^.4b", read_data (z), read_data (z + 1), read_data (z + 2), read_data (z + 3));

				call ioa_ ("^xs/b:^3x^.4b^2x^.4b^2x^.4b^2x^.4b", data (z), data (z + 1), data (z + 2), data (z + 3));
				read_cmp_err = read_cmp_err + 1;
				return;
			     end;
		     end;
	     end;

	return;
     end write_sector;

%page;
build_sb: proc;					/*  build up the should be buffer for the read compare */

	dcl     i			 fixed bin;

	data (0) = bit (0, 12) || bit (seek, 24);	/* put in seek address */
	do i = 1 to words_per_sector - 1;
	     data (i) = constant_;
	end;

	return;
     end build_sb;

%page;
error: proc;


/* ************************************************************************
   *   this routine displays the error data to the user and stores the     *
   *   error info away for test summarization. On an attention condition   *
   *   it will ask the user whether or not he wishes to continue.          *
   ************************************************************************ */

	dcl     (s_a, se_n, cyl_no, hd_no) fixed bin (24);
	dcl     my_analyses		 (20) char (40) varying;

	dcl     detailed_status	 bit (88) unal based (addr (detail_status));
	dcl     msg		 char (256) var init ("");
	dcl     is_interesting	 bit (1);
	dcl     DATA_ALRT_CMPRR	 bit (10) int static options (constant) init (
				 "0011100000"b);	/* Data Alert, Compare Error */
	dcl     ATTN		 bit (4) int static options (constant) init (
				 "0010"b);	/* Attention Condition major status */

	is_interesting = "0"b;
	compare_err = FALSE;
	my_analyses (*) = "";
	dev_statp = addr (device_status_info);
	call exdim_control (iocbp, "hardware_status", dev_statp, code); /* get the status */

	if dev_cmd = 27 then do;
		doing = "write";
		write_errors = write_errors + 1;
	     end;

	else if dev_cmd = 21 then do;
		doing = "read";
		read_errors = read_errors + 1;
		dev_cmd = dev_cmd + 5;
	     end;

	else if dev_cmd = 28 then do;
		doing = "seek";
		seek_errors = seek_errors + 1;
	     end;

	if substr (iom_status, 3, 10) = DATA_ALRT_CMPRR then
	     compare_err = TRUE;

	if err_cnt < 50 then do;
		err_cnt = err_cnt + 1;

		device_status_info.seek_addr = seek;
		errors (err_cnt) = device_status_info;	/* save this for later analysis */
	     end;

	else do;
		call ioa_ ("^/^a: Too many errors encountered in test!^/^15xFix disk drive (^a) and re-run.", myname, device_name);
		quit_flag = TRUE;
	     end;

	call convert_seek_addr (seek, s_a, se_n, cyl_no, hd_no);

	call analyze_device_stat_$rsnnl (msg, stat_tablep, (iom_status), ("0"b));
	call date_time_ (clock_ (), dt);

	call ioa_ ("^/^a: ^a error on ^a @ ^a;",
	     myname, doing, device_name, substr (dt, 11, 6));

	call ioa_ ("^15xSeek Addr ^o, ^[Logical ^]cyl ^d hd ^d^[, Physical cyl ^d hd ^d^]",
	     seek, d500_sw, cyl_no, hd_no, d500_sw, PC, PH);


	call ioa_ ("^15x^a (^2o/^2o)", msg, substr (iom_status, 3, 4),
	     substr (iom_status, 7, 6));

	if detail_status (1) then do;
		msg = "";
		call analyze_detail_stat_$rsnnl (device_name, substr (iom_status, 1, 36),
		     detailed_status, msg, is_interesting, code);
		if msg ^= "" then
		     call ioa_ ("^15xDetailed Status: ^a", msg);
	     end;


	if quit_flag then return;

	if substr (iom_status, 3, 4) = ATTN then do;	/* is it an attention cond? */
		call command_query_ (querie, answer, myname,
		     "Your disk drive (^a) requires attention.^/^-^5xPlease check it out or have the operator do so
^-^5xand reply appropriately AFTER the device has been checked.

^-^5xDo you wish to retry?", device_name);

		if answer ^= "yes" then
		     quit_flag = TRUE;

	     end;



	return;
     end error;
%page;

get_dev_size: proc (acode) returns (fixed bin (24));

/* **********************************************************************
   *   Returns the highest sector address for the specified device type   *
   ********************************************************************** */

	dcl     acode		 fixed bin (35);
	dcl     dvt		 fixed bin;

	acode = 0;
	do dvt = 1 to maxdevt;
	     if device_type = device_names (dvt) then do;
		     acode = 0;
		     return (last_alt_sect_num (dvt));
		end;
	end;
	acode = 1;
	return (0);


     end;
%page;

convert_seek_addr: proc (sector, sa, se_no, cyl_, hd_);

/* **********************************************************************
   *   given a seek address, this routine returns the sector, head and   *
   *   cylinder information from that address			     *
   ********************************************************************** */

	dcl     ecode		 fixed bin (35);
	dcl     (sector, se_no, sa, cyl_, hd_) fixed bin (24);


	sa = divide (sector, sect_per_track (dev_idx), 24, 0);
	se_no = mod (sector, sect_per_track (dev_idx));
	cyl_ = divide (sa, tracks_per_cyl (dev_idx), 24, 0);
	hd_ = mod (sa, tracks_per_cyl (dev_idx));

	if model_num >= 500 then do;
		if mod (cyl_, 2) = 0 then do;
			epc = cyl_ + 1;
			opc = cyl_;
			PH = hd_ * 2;
		     end;

		else do;
			epc = cyl_;
			opc = cyl_ - 1;
			PH = (hd_ * 2) + 1;
		     end;
		if dev_evn then
		     PC = epc;
		else PC = opc;

	     end;


	return;


get_seek_addr: entry (sector, ecode) returns (fixed bin (24));


/* This routine returns a seek address from the user supplied
   * starting/ending  cylinder number (from/to N) */


	ecode = 0;
	if alt_sw then /* check that the cyl input is not > largest cyl allowed */
	     if (sector * sect_per_cyl (dev_idx)) >
		last_sect_num (dev_idx) then do;
bad_ret:		     ecode = 1;
		     return (0);
		end;

	if ^alt_sw then
	     if (sector * sect_per_cyl (dev_idx)) >
		last_alt_sect_num (dev_idx) then
		go to bad_ret;

	return (sector * sect_per_cyl (dev_idx));

     end convert_seek_addr;
%page;
EXIT: proc;

	dcl     (sect_addr, sect, cyl, hd) fixed bin (24);
	dcl     temp_		 (err_cnt + 1) char (100) var init ((err_cnt + 1) (""));
	dcl     temp_str		 char (100) var init ("");
	dcl     (i, j, count_)	 fixed bin;
	dcl     (CA, PORT)		 char (10) var;
	dcl     ioa_$rsnnl		 entry () options (variable);
	dcl     linelth		 fixed bin;

	if test_in_progress = 0 then /* haven't really started */
	     return;

	if dev_open then do;
		call exdim_close (iocbp, code);
		dev_open = "0"b;
	     end;

	if dev_attached then do;
		call exdim_detach (iocbp, code);
		if code ^= 0 then
		     call com_err_ (code, myname, "Problems detaching, suggest a ""new_proc""");
		dev_attached = "0"b;
	     end;
	if data_bufp ^= null then
	     free data;				/* clean up if used */
	if read_ptr ^= null then /* ditto */
	     free read_data;

	if iocbp ^= null then
	     call iox_$destroy_iocb (iocbp, code);

	test_in_progress = 0;			/* truly I am dead */

	if sectors_written + sectors_read + err_cnt + read_cmp_err > 0 then do;

		call ioa_ ("^/^a: Testing Completed for ^a (^a).", myname, device_name, device_type);
		call ioa_ ("Test Summary:");
		call ioa_ ("Number of Sectors Written   ^12d", sectors_written);
		call ioa_ ("Number of Sectors Read^6x^12d", sectors_read);

		if err_cnt + read_cmp_err > 0 then do;

			call ioa_ ("Number of Write  I/O errors^7x ^5d", write_errors);
			call ioa_ ("Number of Read   I/O errors^7x ^5d", read_errors);
			call ioa_ ("Number of Read Compare Errors^6x^5d", read_cmp_err);
			if err_cnt < 1 then return;


			call ioa_ ("^/Error Location Summary:^/^/^xError Count^4xCylinder^2xHead^3xR/W^2xCA^2xPort^[ Physical  CYL/HD^]", d500_sw);
			call ioa_ ("^x===========^4x========^2x====^3x===^2x==^2x====^[ ================^]", d500_sw);

			do ii = 1 to err_cnt;
			     if errors (ii).det_status (1) then do;
				     CA = ltrim (rtrim (char (fixed (substr (errors (ii).det_status (10), 8, 1), 1))));
				     PORT = ltrim (rtrim (char (fixed (substr (errors (ii).det_status (11), 4, 5), 5))));
				end;
			     else do;
				     CA = " ";
				     PORT = "     ";
				end;

			     if length (PORT) = 1 then
				PORT = "    " || PORT;
			     else if length (PORT) = 2 then
				PORT = "   " || PORT;

			     call convert_seek_addr (errors (ii).seek_addr_, sect_addr, sect, cyl, hd);
			     call ioa_$rsnnl ("^12d^2x^4d^4x^1a^4x^1a^x^5a^[^46t^3d/^2d^]",
				temp_ (ii), linelth, cyl, hd,
				cmd_tbl (errors (ii).dev_cmd_),
				CA, PORT, d500_sw, PC, PH);


			end;

			do i = 1 to err_cnt - 1;	/* sort the errors */
			     do j = (i + 1) to err_cnt;
				if temp_ (i) > temp_ (j) then do;
					temp_str = temp_ (i);
					temp_ (i) = temp_ (j);
					temp_ (j) = temp_str;
				     end;
			     end;
			end;

			count_, x = 1;

print_it:			do i = x to err_cnt;
			     do j = (i + 1) to err_cnt + 1;
				if temp_ (i) = temp_ (j) then
				     count_ = count_ + 1;
				else do;
					call ioa_ ("^7x^5d^a", count_, temp_ (i));
					x = j;
					count_ = 1; /* reset the counter */
					go to print_it;
				     end;
			     end;
			end;

			call ioa_ ("^/^/");
		     end;


		else call ioa_ ("^/^a: No errors encountered in test.", myname);
	     end;

	return;
     end EXIT;
%page;


/* This subroutine is a modified version of rdisk_. It has been modisfied to
   * support exercise_disk in a streamline fashion, with a much improved
   * error handling capability. */


exdim_: proc;
	return;					/* do not enter here */


	dcl     1 disk_data		 based (disk_ptr),	/*  exdim_ data structure  */
		2 attach_descrip	 aligned,		/*  Current attach description  */
		  3 length	 fixed bin (17),	/*  Length of description in chars.  */
		  3 descrip	 char (168),	/* the actual description  */
		2 attach_data	 aligned,		/*  attachment data for use by  exdim_  */
		  3 sze		 fixed bin (35),	/* if ^= 0 => size specified in attach or control  */
		  (3 err_sw,			/* on if error messages are to be printed  */
		  3 write_sw,			/*  on if  device is to be mounted in write mode  */
		  3 compare_sw,			/*   on if Write_and_Compare idcw is to be used for writes  */
		  3 raw_sw,			/* ON => raw mode */
		  3 alt_sw,			/* ON => alt mode */
		  3 label_sw,			/* ON => label mode */
		  3 sys_sw)	 bit (1) unal,	/*  on if this is a privileged system process  */
		  3 pack_id	 char (32),	/*  Current disk pack id.  */
		  3 rcp_id	 bit (36),	/* rcp unique id. */
		  3 max_buff_size	 fixed bin (19),	/* ioi_ buffer size limit set by rcp_ */
		  3 wait_list,			/*  event channel information  */
		    4 nchan	 fixed bin,	/* number of channels (currently using 1)  */
		    4 ev_chan	 fixed bin (71),	/* event channel id.  */
		  3 dev_type	 fixed bin,	/*  device type indicator   */
		  3 devx		 fixed bin,	/* device index returned by ioi_ */
		  3 drive		 fixed bin (6),	/* drive number returned by ioi_ */
		  3 errors	 fixed bin,	/* error count */
		  3 sect_per_dev	 fixed bin (35),	/* sectors per device */
		  3 sect_size	 fixed bin (12),	/* quantity of words in one sector */
		  3 num_alt_sect	 fixed bin,	/* quantity of sectors reserved for alternate sector usage */
		  3 device_group	 fixed bin,	/* 1 = MSU04XX */
						/* 2 = MSU0500/1 */
						/* 3 = MSU3380 & MSU3381 */
		2 open_descrip	 aligned,		/* open description */
		  3 length	 fixed bin (17),	/* number of characters in open descrip. */
		  3 descrip	 char (32),	/* the actual open descrip. */
		2 open_data	 aligned,		/* more exdim_ data */
		  3 mode		 fixed bin,	/* mode number:  4 = sq_i, 5 = sq_o, 7 = sq_u,
						   11 = d_i, 13 = d_u    */
		  3 buf_ptr	 ptr,		/* pointer to buffer created by ioi_$workspace */
		  3 fill		 bit (9),		/* Fill left-over part of last sector of the current record with this value when writing. */
		  3 buf_len	 fixed bin (19),	/*  length (words) of buffer */
		  3 data_len	 fixed bin (19),	/* length of data area in buffer */
		  3 time_int	 fixed bin (52),	/* current time out interval */
		  3 next_key	 fixed bin (35),	/* next key as per iox_ */
		  3 current_key	 fixed bin (35),	/* current key as per iox_ */
		  3 key_for_insertion fixed bin (35),	/* key for insertion as per iox_  */
						/* key_for_insertion is always null for the
						   present implementation, since write_record
						   is not supported for direct_update.  */
		  3 bounds,			/* current key  boundaries */
		    4 low		 fixed bin (35),	/* the lower bound */
		    4 high	 fixed bin (35),	/* higher bound */
		  3 mode_string	 char (32) varying, /* current modes */
		  3 rcp_data	 (size (disk_info)) fixed bin (35); /* area for rcp_disk_info structure */

	dcl     1 status		 based (addr (iom_stat)), /* breakout of iom_stat */
		2 pad		 bit (2) unal,	/* not used */
		2 maj		 bit (4) unal,	/* major status */
		2 sub		 bit (6) unal,	/* sub status */
		2 pad2		 bit (48) unal,	/* not used */
		2 residue		 bit (12) unal;	/* tally residue */

	dcl     1 seek		 aligned,
		2 block_count_limit	 fixed bin (12) unsigned unal,
		2 ti		 bit (2) unal,
		2 mbz		 bit (1) unal,
		2 sector		 fixed bin (21) unsigned unal;

	dcl     1 super_seek	 aligned,
		2 sector_number	 fixed bin (8) unsigned unal,
		2 mbz1		 bit (4) unal,
		2 ti		 bit (2) unal,
		2 is_super_seek	 bit (1) unal,
		2 flag		 bit (1) unal,
		2 mbz2		 bit (4) unal,
		2 cyl_lower	 fixed bin (8) unsigned unal,
		2 cyl_upper	 fixed bin (2) unsigned unal,
		2 head		 fixed bin (6) unsigned unal;

	dcl     1 buffer		 based (buf_ptr),	/* ioi_ buffer */
		2 control_info,			/* device control data */
		  3 (rst_idcw, sk_idcw, sk_dcw, rw_idcw, rw_dcw) fixed bin (35), /* DCW's */
		  3 seek_data	 like seek,	/* Information for seek DCW */
		  3 rsr_data	 bit (88) unal,	/* detailed device status read by RSR */
		  3 reserved	 (5) fixed bin (35),/* pad for future expansion */
		  3 istat		 aligned,		/* I/O Interfacer status structure */
		    4 completion,			/* completion flags */
		    ( 5 st	 bit (1),		/* "1"b if status returned */
		      5 er	 bit (1),		/* "1"b if status indicates error condition */
		      5 run	 bit (1),		/* "1"b if channel still running */
		      5 time_out	 bit (1)) unal,	/* "1"b if time-out occurred */
		    4 level	 fixed bin (3),	/* IOM interrupt level */
		    4 offset	 fixed bin (18),	/* DCW list offset */
		    4 absaddr	 fixed bin (24),	/* absolute address of workspace */
		    4 iom_stat	 bit (72),	/* IOM status */
		    4 lpw		 bit (72),	/* LPW residue */
		2 data		 char (4 * data_len); /* data area  */

	dcl     1 event_info	 aligned,		/*  event message info  */
		2 chan_id		 fixed bin (71),
		2 message,
		  3 pad1		 bit (15) unal,
		  3 int_level	 bit (3) unal,
		  3 pad2		 bit (36) unal,
		  3 special_type	 fixed bin (17) unal,
		2 sender		 bit (36),
		2 origin,
		  3 dev_signal	 bit (18) unal,
		  3 ring		 bit (18) unal,
		2 chan_x		 fixed bin;

	dcl     1 tp_info,				/*  terminate_process_ information */
		2 version		 fixed bin,	/* version no. (currently 0) */
		2 code		 fixed bin (35);	/* error code to be printed before process is termed */

	dcl     (disk_ptr, iocb_ptr, real_iocb_ptr, ubuf_ptr, block_ptr, rs_ptr, info_ptr, fmdp) ptr init (null); /* pointers */
	dcl     dcw_offset		 fixed bin (18);	/* offset in ioi_ buffer to first IDCW */
	dcl     (code, rec_len, data_left, mode_len, mode_start) fixed bin (35);
	dcl     key		 fixed bin (21);	/* working seek key */
	dcl     track_indicators	 bit (2) init ("00"b); /* track indicator bits for seek cmd */
	dcl     (count_limit_fixed, block_len) fixed bin (12);
	dcl     (i, num_opts, err_ct, rcp_state) fixed bin;
	dcl     (cyl, head)		 fixed bin (16);
	dcl     (again, not_sw, mode_err_sw) bit (1) unal;

	dcl     block		 char (4 * block_len) based (block_ptr); /*  current user data block */
	dcl     dev_id		 char (4);	/* alpha device id, e.g. D191 */
	dcl     rs_mode		 fixed bin (5);	/* rcp_sys_ access mode for this process */

	dcl     1 user_bounds	 based (info_ptr),	/* current bounds returned via this structure */
		2 low		 fixed bin (35),
		2 high		 fixed bin (35);

	dcl     new_modes		 char (24);	/* new modes for  modes oper. */
	dcl     next_mode		 char (8) varying init ("dummy");
	dcl     mask_str		 bit (36) aligned;	/* ips_ mask */
	dcl     1 mask		 based (addr (mask_str)), /* different def'n of above */
		2 pad		 bit (35) unal,	/* we don't use this */
		2 masked		 bit (1) unal;	/* flag to indicate if we are masked */
	dcl     temp_key		 fixed bin (35);
	dcl     1 drive_number,
		2 sign		 char (1),
		2 number		 char (2);
	dcl     drive_dec		 dec (2) based (addr (drive_number)); /* used for drive number conversion */
	dcl     drive_name		 char (8);	/* name of the requested device or spaces */
	dcl     model_number	 fixed bin;	/* model number requested by user */


/*	The following internal static items should all become constants when exdim_ is compiled.  */


	dcl     DEVICE_GROUP	 (9) fixed bin int static init (0, 2, 1, 1, 1, 1, 2, 3, 3);
						/* "bulk", "d500", "d451", "d400", "d190", "d181", "d501", "3380" "3381" */
	dcl     MSU04XX		 fixed bin int static init (1);
	dcl     overhead		 fixed bin int static init (24); /* number of control words reserved in ioi_ buffer */
	dcl     max_retries		 int static fixed bin init (110); /* number of times we will retry certain operations */
	dcl     ATTENTION		 int static bit (4) init ("0010"b);
	dcl     EOF		 int static bit (4) init ("0100"b);
	dcl     LAST_BLOCK		 int static bit (6) init ("000001"b);
	dcl     LAST_BLOCK_MASK	 int static bit (6) init ("111101"b);
	dcl     EXEC		 bit (5) int static init ("00100"b);
	dcl     STANDBY		 int static bit (6) init ("010000"b);
	dcl     INHIB_AUTO_RETRY	 bit (6) int static init ("010001"b);
	dcl     SPECIAL_SEEK	 bit (6) int static init ("011110"b);
	dcl     SEEK_512		 bit (6) int static init ("30"b3);
	dcl     SPECIAL_SEEK_512	 bit (6) int static init ("35"b3);
	dcl     LONG_WAIT		 fixed bin int static init (2);
	dcl     COMPLETE		 fixed bin int static init (0);
	dcl     DEFAULT		 bit (1) int static init ("0"b);
	dcl     NOT_SET		 fixed bin (6) int static init (-1);
	dcl     num_label_sect	 fixed bin int static init (8);
	dcl     rcp_dev_type	 char (32) int static init ("disk_drive");

/*	This is the end of the set of internal static items which should all become constants during compilation. */



	dcl     standby_idcw_string	 int static bit (36) init ("720000720201"b3);
	dcl     restore_idcw_string	 int static bit (36) init ("420000720201"b3);
	dcl     seek_idcw_string	 int static bit (36) init ("340000720000"b3);
	dcl     seek_dcw_string	 int static bit (36) init ("000000000001"b3);
	dcl     read_idcw_string	 int static bit (36) init ("250000700000"b3);
	dcl     write_idcw_string	 int static bit (36) init ("310000700000"b3);
	dcl     write_and_compare_idcw_string int static bit (36) init ("330000700000"b3);
	dcl     read_write_dcw_string	 int static bit (36) init ("000000000000"b3);

	dcl     1 standby_idcw_template defined (standby_idcw_string) like idcw;
	dcl     1 restore_idcw_template defined (restore_idcw_string) like idcw;
	dcl     1 seek_idcw_template	 defined (seek_idcw_string) like idcw;
	dcl     1 seek_dcw_template	 defined (seek_dcw_string) like dcw;
	dcl     1 read_idcw_template	 defined (read_idcw_string) like idcw;
	dcl     1 write_and_compare_idcw_template defined (write_and_compare_idcw_string) like idcw;
	dcl     1 write_idcw_template	 defined (write_idcw_string) like idcw;
	dcl     1 read_write_dcw_template defined (read_write_dcw_string) like dcw;

	dcl     (

	        error_table_$action_not_performed,	/*  notacted, The requested action was not performed.;  */
	        error_table_$bad_arg,			/*  bad_arg , Illegal command or subroutine argument.;  */
	        error_table_$bad_mode,		/*  badmode , Improper mode specification for this device.;  */
	        error_table_$device_end,		/*  devend  , Physical end of device encountered.;  */
	        error_table_$device_parity,		/*  xmiterr , Unrecoverable data-transmission error on physical device.;  */
	        error_table_$incompatible_attach,	/*  att^=opn, Attach and open are incompatible.;  */


	        error_table_$no_operation,		/*  no_oper , Invalid I/O operation.;  */
	        error_table_$no_record,		/*  no_rec  , Record not located.;  */
	        error_table_$noarg,			/*          , Expected argument missing.;  */
	        error_table_$not_attached,		/*  notattch, I/O switch (or device) is not attached.;  */
	        error_table_$not_closed,		/*  not_clsd, I/O switch is not closed.;  */
	        error_table_$not_detached,		/*  not_det , I/O switch is not detached.;  */
	        error_table_$not_open,		/*  not_open, I/O switch is not open.;  */
	        error_table_$request_not_recognized,	/*  reqnorec, Request not recognized.;  */
	        error_table_$termination_requested,	/*  termrqu , Process terminated because of system defined error condition.;  */
	        error_table_$user_not_found,		/*  usernfd , User-name not on access control list for branch.;  */
	        error_table_$unimplemented_version

	        )			 external static fixed bin (35);




	dcl     ipc_$delete_ev_chn	 entry (fixed bin (71), fixed bin (35));
	dcl     iox_$err_no_operation	 entry options (variable);
	dcl     iox_$err_not_closed	 entry options (variable);
	dcl     iox_$err_not_open	 entry options (variable);
	dcl     ioi_$timeout	 entry (fixed bin, fixed bin (52), fixed bin (35));
	dcl     ioi_$workspace	 entry (fixed bin, ptr, fixed bin (19), fixed bin (35));
	dcl     hcs_$make_seg	 entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
	dcl     hcs_$delentry_seg	 entry (ptr, fixed bin (35));
	dcl     iox_$propagate	 entry (ptr);
	dcl     ipc_$create_ev_chn	 entry (fixed bin (71), fixed bin (35));
	dcl     cv_dec_check_	 entry (char (*), fixed bin (35)) returns (fixed bin (35));
	dcl     ioi_$connect	 entry (fixed bin, fixed bin (18), fixed bin (35));
	dcl     ipc_$block		 entry (ptr, ptr, fixed bin (35));
	dcl     ioi_$set_status	 entry (fixed bin, fixed bin (18), fixed bin (8), fixed bin (35));
	dcl     ioi_$get_detailed_status entry (fixed bin, bit (1) aligned, bit (*), fixed bin (35));
	dcl     timer_manager_$sleep	 entry (fixed bin (71), bit (2));
	dcl     hcs_$initiate	 entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
	dcl     hcs_$fs_get_mode	 entry (ptr, fixed bin (5), fixed bin (35));
	dcl     hcs_$set_ips_mask	 entry (bit (36) aligned, bit (36) aligned);
	dcl     hcs_$reset_ips_mask	 entry (bit (36) aligned, bit (36) aligned);
	dcl     default_handler_$set	 entry (entry);
	dcl     terminate_process_	 entry (char (*), ptr);
	dcl     rcp_$attach		 entry (char (*), ptr, fixed bin (71), char (*), bit (36) aligned, fixed bin (35));
	dcl     rcp_$check_attach	 entry (bit (36) aligned, ptr, char (*), fixed bin, fixed bin (19), fixed bin (71),
				 fixed bin, fixed bin (35));
	dcl     rcp_$detach		 entry (bit (36) aligned, bit (*), fixed bin, char (*), fixed bin (35));
	dcl     a_iocb_ptr		 ptr;		/* parameter:  IOCB pointer */
	dcl     a_code		 fixed bin (35);	/* parameter:  return code */
	dcl     a_rec_len		 fixed bin (21);	/* parameter:  user record length */
	dcl     a_ubuf_ptr		 ptr;		/* parameter:  pointer to user buffer */
	dcl     a_ubuf_len		 fixed bin (21);	/* parameter: length (chars.) of user buffer */

	dcl     based_rsr_data	 (11) bit (8) unal based (addr (buffer.control_info.rsr_data));
	dcl     found		 bit (1) aligned;

	dcl     1 user_dev_char_table	 based (info_ptr) aligned, /* Users device Characteristics Table */
		2 user_subsystem_name char (4),	/* Disk subsystem name */
		2 user_device_name	 char (8),	/* Device name */
		2 user_sect_per_dev	 fixed bin (35),	/* total no. of non-T&D sectors on pack */
		2 user_cyl_per_dev	 fixed bin,	/* no. of non-T&D cylinders on pack */
		2 user_sect_per_cyl	 fixed bin,	/* no of sectors per cylinder */
		2 user_sect_per_track fixed bin,	/* no. of sectors per track */
		2 user_num_label_sect fixed bin,	/* no. of sectors to reserve for label */
		2 user_num_alt_sect	 fixed bin,	/* no. of sectors to reserve for alt. track area */
		2 user_sect_size	 fixed bin (12);	/* no. of words in sector */

	dcl     1 user_status_info	 based (info_ptr) aligned, /* user's status data */
		2 user_hardware_status bit (72),	/* iom status */
		2 user_dev_detail_status (11) bit (8) unal, /* 11 bytes of dev detail status */
		2 user_dev_cmd	 fixed bin;	/* the command issued to the disk */
	dcl     last_cmd_		 fixed bin static;	/* last command to experience an error */
%page;
	dcl     io_command		 char (8) varying;	/* values are "read", "write", or "rewrite" */
	dcl     current_mode_name	 char (24);	/* name of current opening mode */

	dcl     END		 fixed bin int static init (-5); /* used to indicate that a key is at the end of the file */
	dcl     NULL		 fixed bin int static init (-1); /* used to flag keys as currently being invalid */
	dcl     unique_chars_	 entry (bit (*)) returns (char (15));
	dcl     unique_entry_name	 char (22);
          dcl     length		 builtin;
%page;

/*  Start of ATTACH module  */

exdim_attach: entry (a_iocb_ptr, options_ptr, a_err_sw, a_code);


	dcl     options_ptr		 ptr;
	dcl     1 options_		 based (options_ptr), /* parameter:  attach description elements */
		2 number_opts	 fixed bin,
		2 options		 (number_opts) char (32) varying;


	dcl     a_err_sw		 bit (1) aligned;	/* parameter: print errors flag */


	code = 0;					/* clear return code */

	unique_entry_name = unique_chars_ ("0"b) || ".exdim_";
	call hcs_$make_seg ("", unique_entry_name, "", 01010b, disk_ptr, code); /* make our work segment */
	if disk_ptr = null then call error (code, "");	/* if it didn't work */

	err_sw = a_err_sw;				/* fill in print errors flag */
	iocb_ptr = a_iocb_ptr;			/* grab IOCB pointer */

	if iocb_ptr -> attach_descrip_ptr ^= null then call att_err (error_table_$not_detached);
						/* must be detached */

	write_sw, sys_sw, compare_sw = "0"b;		/* initialize switches */
	pack_id = " ";				/* clear pack id */
	sze = 0;					/* reset size field */
	drive = NOT_SET;				/* init drive field */
	drive_name = "";				/* no specific drive specified */
	model_number = 0;

	num_opts = options_.number_opts;		/* how many descrip. elements? */

	if num_opts >= 2 then do;			/* if enough */
		dev_id = options (1);		/* set device name */
		pack_id = options (2);		/* set pack id */
	     end;
	else call att_err (error_table_$noarg);		/* complain if not enough  */

	if dev_id = "d191" then dev_id = "d400";	/* set up for compatibility */
						/* ******** */
	else if dev_id = "d450" then dev_id = "d451";


	dev_type = 0;				/* clear device type indicator */
	do i = 1 to maxdevt while (dev_type = 0);	/*  look up dev. name in dev. char. table */
	     if dev_id = device_names (i) then dev_type = i; /* if found, set device type indicator */
	end;
						/* ******** */


	do i = 3 to num_opts;			/* check out attach options */

	     if options (i) = "-write" then write_sw = "1"b; /* if -write set write mode switch */


	     else if options (i) = "-device"
		| options (i) = "-dv"
	     then do;				/* -device device-name */
		     if i >= num_opts
		     then call att_err (error_table_$noarg);
		     i = i + 1;
		     drive_name = options (i);
		     if drive_name ^= options (i)
		     then call att_err (error_table_$bad_arg);
		end;


	     else if options (i) = "-system" | options (i) = "-sys"
	     then do;				/* if a reserved drive is wanted */

		     call hcs_$initiate (">system_library_1", "rcp_sys_", "", 0, 0, rs_ptr, code); /* test rcp_sys_ access */
		     if rs_ptr ^= null then do;	/* if can be initiated */
			     call hcs_$fs_get_mode (rs_ptr, rs_mode, code); /* check caller's access */
			     if code = 0 then if bit (rs_mode) & EXEC then sys_sw = "1"b; /* if execute, then priv. process */
			end;
		     if ^sys_sw then call att_err (error_table_$user_not_found); /* User does not have correct access to rcp_sys_ gate. */
		end;

	     else call att_err (error_table_$request_not_recognized); /* if not valid option, complain */

	end;

	if dev_type = 0
	then attach_descrip.descrip = "exdim_ """" " || pack_id;
	else attach_descrip.descrip = "exdim_ " || device_names (dev_type) || " " || pack_id; /* init. att. descrip. */
	attach_descrip.length = length (rtrim (attach_descrip.descrip));
	do i = 3 to num_opts;			/* add the options */
	     attach_descrip.descrip = substr (attach_descrip.descrip, 1, attach_descrip.length)
		|| " " || options (i);		/* concatenate the next option */
	     attach_descrip.length = length (rtrim (attach_descrip.descrip));
	end;

	call ipc_$create_ev_chn (ev_chan, code);	/* create an event channel */
	if code ^= 0 then call att_err (code);		/* if we didn't make it */
	nchan = 1;				/* only one channel */

	disk_info_ptr = addr (rcp_data);		/* init. disk info prior to assignment */
	disk_info.version_num = DISK_INFO_VERSION_1;
	disk_info.usage_time, disk_info.wait_time = 0;
	disk_info.system_flag = sys_sw;
	if dev_type ^= 0
	then disk_info.model = MODELN (dev_type);
	else disk_info.model = 0;
	disk_info.device_name = drive_name;
	disk_info.write_flag = write_sw;
	raw_sw = "0"b;				/* reset raw mode if set */
	alt_sw = "0"b;
	label_sw = "1"b;
	call mount ();				/* attach drive, and mount pack */
	if code ^= 0 then call att_err (code);		/* complain if we didn't make it */

	dev_type = 0;
	do i = 1 to hbound (MODELN, 1) while (dev_type = 0);
	     if disk_info.model = MODELN (i)
	     then dev_type = i;
	end;


	device_group = DEVICE_GROUP (dev_type);

	sect_per_dev = sect_per_cyl (dev_type) * cyl_per_dev (dev_type); /* Set up device specific constants */
	sect_size = words_per_sect (dev_type);
	num_alt_sect = last_alt_sect_num (dev_type) - first_alt_sect_num (dev_type) + 1;

	if sys_sw then bounds.low = 0;
	else bounds.low = num_label_sect;		/* initialize the seek low bound */
	if device_group = MSU04XX
	then bounds.high = last_alt_sect_num (dev_type);
	else bounds.high = last_sect_num (dev_type);

	mode_string = "label,^alttrk,^wrtcmp,^raw";	/* set the modes string */

	mask_str = "0"b;				/* initialize ips_ mask */
	call default_handler_$set (cond_hdlr);		/* protect ourselves */
	call hcs_$set_ips_mask (mask_str, mask_str);

	iocb_ptr -> attach_descrip_ptr = addr (attach_descrip); /* fill in IOCB; attach descrip. */
	iocb_ptr -> attach_data_ptr = disk_ptr;		/* attach data */
	iocb_ptr -> detach_iocb = exdim_detach;		/* detach entry */
	iocb_ptr -> iocb.open = exdim_open;		/* open entry */
	iocb_ptr -> iocb.control = exdim_control;	/* control entry */
	iocb_ptr -> iocb.modes = exdim_modes;		/* modes entry */

	call iox_$propagate (iocb_ptr);		/*  let iox_ have its turn */

	call hcs_$reset_ips_mask (mask_str, mask_str);	/* back to normal */

	next_key, current_key, key_for_insertion = NULL;	/* Change when valid values established */


exit:	a_code = code;				/* return the code */
	return;					/* bye-bye */
%page;
/*  Internal handler for errors occurring during ATTACH  */

att_err: proc (b_code);

	dcl     (b_code, c_code)	 fixed bin (35);	/* error code */

	c_code = b_code;

	call hcs_$delentry_seg (disk_ptr, c_code);	/* get rid of work segment */
	code = b_code;				/* set code */
	go to exit;				/* return */

     end att_err;


/*  End of ATTACH module  */
%page;
/*  Start of OPEN module  */

exdim_open: entry (a_iocb_ptr, a_mode, a_code);

/*
   *           Only the direct_update and direct_input opening modes are
   *           supported:

   *           Note that the  attach  description  must  include the  -write

   *           control  argument  so  that  the operator  will not  press  the

   *           PROTECT button when pack is mounted if direct_update is used.
*/

	dcl     a_mode		 fixed bin;	/* parameter:  open mode  */

	call setup ("closed");			/* set up working environment */
						/* If setup returns to here, the switch is closed. */

	mode = a_mode;				/* pick up requested opening mode */


/*  Set up various items which are opening-mode dependent.  */
/*  Since current_key remains NULL for all modes, it is not changed and hence does not show below. */



	if mode = Direct_update then do;
		if ^write_sw then call error (error_table_$incompatible_attach,
			"direct_update requires -write control arg."); /* complain if not attached for write */
		open_descrip.length = 13;
		open_descrip.descrip = "direct_update";
		real_iocb_ptr -> read_record = exdim_read;
		real_iocb_ptr -> rewrite_record = exdim_rewrite;
		real_iocb_ptr -> seek_key = exdim_seek;
						/* next_key remains NULL */
		fill = "000000000"b;		/* Zero fill last sector when write. */
	     end;


	else if mode = Direct_input then do;
		open_descrip.length = 12;
		open_descrip.descrip = "direct_input";
		real_iocb_ptr -> read_record = exdim_read;
		real_iocb_ptr -> seek_key = exdim_seek;
						/* next_key remains NULL */
		fill = "110110110"b;		/* Should never be used. */
	     end;


	else do;					/* complain if an invalid opening mode was requested. */
		current_mode_name = iox_modes (mode);
		call error (error_table_$request_not_recognized, current_mode_name); /* complain if invalid opening mode */
	     end;


	mask_str = "0"b;				/* initialize ips_ mask */
	call default_handler_$set (cond_hdlr);		/* protect ourselves */
	call hcs_$set_ips_mask (mask_str, mask_str);

/*  The file is now open.  Set up to allow a close, but not an open or detach. */

	real_iocb_ptr -> close = exdim_close;
	real_iocb_ptr -> open,
	     real_iocb_ptr -> detach_iocb = iox_$err_not_closed;


	real_iocb_ptr -> open_descrip_ptr = addr (open_descrip); /* fill in IOCB open descrip. pointer */

	call iox_$propagate (iocb_ptr);		/* let iox_ have a turn again */

	call hcs_$reset_ips_mask (mask_str, mask_str);	/* back to normal */

	a_code = 0;				/* give successful code */
	return;					/* auf wiedersehen */

/*  End of OPEN module  */
%page;
/*  Start of SEEK module  */

exdim_seek: entry (a_iocb_ptr, a_key, a_rec_len, a_code);

/*
   *      S__e_e_k_K__e_y_O__p_e_r_a_t_i_o_n


   *           This operation returns a status code of 0 for any key that  is  a
   *      valid  sector  number.   The  record  length  returned  is  always 256
   *      (current physical sector size in characters) for any valid  key.   The
   *      specified key must be a character string that could have been produced
   *      by  editing  through  a  PL/I picture of "(8)9".
   *      This operation is supported for only the direct opening modes.
*/

	dcl     a_key		 char (256) varying;/* parameter:   key to seek on  */

	call setup ("open");			/* set up working environment */
	if mode = Direct_input | mode = Direct_update then ;
	else call error (error_table_$no_record, "seek valid only for direct openings.");

	temp_key = cv_dec_check_ (ltrim (rtrim (a_key)), code);
	if code ^= 0
	then call error (error_table_$no_record, (a_key));

	if (temp_key < bounds.low) | (temp_key > bounds.high) then
	     call error (error_table_$no_record, "Requested sector outside available area.");
	else next_key, current_key = temp_key;
						/* key_for_insertion is not changed */

	a_rec_len = 4 * sect_size;			/* return canned rec. len. of sect. size (chars.) */
	a_code = 0;				/* and good code */
	return;					/* 'til next time */

/*  End of SEEK module  */
%page;

/*  Start of READ and WRITE modules  */

exdim_read: entry (a_iocb_ptr, a_ubuf_ptr, a_ubuf_len, a_rec_len, a_code);

/*
   *	     If the amount of data to be read does  not  terminate  on  a
   *	sector  boundary,  the  excess portion of the last sector will be
   *	discarded.  A zero code will be  returned  in  this  case.
*/

	call setup ("open");			/* set up working environment */


	if next_key = NULL then
	     call error (error_table_$no_record, "next_key must be non-null to read");
	else if next_key = END then do;
		next_key = NULL;
		current_key = NULL;
		call error (error_table_$device_end, "Attempted to read (di, du) past end of avilable area.");
	     end;
	io_command = "read";			/* set switch for read */

	rec_len = a_ubuf_len;
	a_rec_len = 0;
	key = next_key;				/* set working key value */
	go to read_write_common;			/* proceed  to common code */
%page;
exdim_rewrite: entry (a_iocb_ptr, a_ubuf_ptr, a_rec_len, a_code);

/*
   *           If the amount of data to be  written  does  not  terminate  on  a
   *      sector  boundary,  the  remaining portion of the last sector is filled
   *      with  spaces in  sequential modes and binary zeros in direct modes.  A
   *      code  of 0  is returned  in  this  case.  This
   *      operation is supported for only the update opening modes.
*/

	call setup ("open");			/* set up working environment */

	if current_key = NULL then
	     call error (error_table_$no_record, "Attempted to rewrite before the start of the file.");
	else if current_key = END then do;
		next_key = END;
		call error (error_table_$device_end, "Attempted to rewrite when already at the end of the file.");
	     end;

	io_command = "rewrite";			/* set switch for rewrite */


	rec_len = a_rec_len;			/* set output record length */
	key = current_key;				/* set working key */

%page;
read_write_common:

/*
   *      For  all other opening modes, if an attempt is made to read or
   *      write beyond the end of the user-accessible area on disk, the  code
   *      error_table_$device_end  is   returned.   If  a  defective  track  is
   *      encountered or if any other unrecoverable data transmission  error  is
   *      encountered, the code error_table_$device_parity is returned.
   *
   *           The  record length is specified through the buff_len parameter in
   *      the read_record operation, and through the rec_len parameter  for
   *      rewrite  operation.
*/

	dcl     sectors_for_record	 fixed bin;	/* Qty. of sectors necessary to hold the record to be written */
	dcl     potential_next_sector	 fixed bin (21);	/* Tentative address of sector immediately following the last */
						/* sector this record will occupy if this is a write. */

	sectors_for_record = ceil (rec_len / (4 * sect_size));

	potential_next_sector = key + sectors_for_record;

	if key = NULL then do;			/* if he didn't do a seek */
		code = error_table_$no_record;	/* complain */
		call io_err ("0"b);
	     end;

	if io_command = "rewrite" then
	     if potential_next_sector > bounds.high + 1 then
		call error (error_table_$no_operation, "Record will not fit in space left on disk.");

	ubuf_ptr = a_ubuf_ptr;			/* grab pointer to user buffer */

	track_indicators = "00"b;			/* reset ti bits if set */



/*  if record longer than maximum or current ioi_ buffer size */


	if (rec_len > 4 * (floor ((max_buff_size - overhead) / sect_size) * sect_size))
	     | (rec_len > 4 * floor (data_len / sect_size) * sect_size) then
	     call error (error_table_$no_operation, "Invalid record length.");


	block_ptr = ubuf_ptr;			/* initialize block pointer */
	block_len = ceil (ceil (rec_len / 4) / sect_size) * sect_size; /* and block length */
	data_left = rec_len;			/* and data left to xmit */
	call do_io;				/* go do the I/O  */


io_succeeded:

/* 			PATH 1 */

	if io_command = "read" then do;

		current_key = next_key;
		a_rec_len = rec_len;		/* Send back length of data actually read. */
		next_key = NULL;			/* mode = direct_update */


	     end;


/* 			PATH 2 */

	else if io_command = "rewrite" then /* No change to  current_key  */

	     next_key = NULL;			/* mode = direct_update */


/* Do this every time, for any case */

	a_code = 0;				/* give good  code */
	return;					/* come again, sometime */

%page;

/*  Internal Procedure to  reset certain fields after the occurrence of an I/O error  */

io_err: proc (clear_space);

	dcl     clear_space		 bit (1);		/*  flag to tell us to zap ioi_ workspace */

	if clear_space then do;			/* if space  no good */
		buf_ptr = null;			/* zap it!! */
		buf_len, data_len = 0;
	     end;

	call error (code, "");			/* let user know */

     end io_err;

%page;

/*  Internal procedure to actually perform I/O  */

do_io: proc;

	dcl     (true_len, data_read)	 fixed bin (35);	/* internal data  manipulation variables */

	true_len = min (4 * block_len, data_left);	/* set true amount to xmit */


/* If we are going to write onto the disk, fill in unused area at end of the disk sector
   with zeros for direct opening modes
   or with ASCII spaces for sequential opening modes. */
/*  and fill in unused space with zeros */

	if io_command ^= "read" then do;		/* if an output command  */
		substr (data, 1, true_len) = substr (block, 1, true_len); /* move data to ioi_ buffer */
		if true_len < 4 * block_len then unspec (substr (data, true_len + 1, 4 * block_len - true_len)) = fill;
	     end;

	idcwp = addr (sk_idcw);			/* get pointer to  seek IDCW */
	idcw = seek_idcw_template;			/* move in template seek IDCW */
	idcw.device = bit (drive);			/* set drive no. */
	count_limit_fixed = ceil (block_len / sect_size); /* and sector  count limit  in seek data */

	if key <= last_sect_num (dev_type)		/* in the data region */
	then goto BUILD_DATA_SEEK (device_group);
	else if key <= last_alt_sect_num (dev_type)	/* in the alternate region */
	then goto BUILD_ALT_SEEK (device_group);

	else
	     call error (error_table_$no_record, "Requested record outside available area.");


BUILD_DATA_SEEK (1):				/* Data region on MSU04XX device */
BUILD_ALT_SEEK (1):					/* Alternate track region on MSU04XX device */
BUILD_DATA_SEEK (2):				/* Data region on MSU0500/1 device */
BUILD_NORMAL_SEEK:

	unspec (seek) = "0"b;
	seek.block_count_limit = count_limit_fixed;
	seek.ti = track_indicators;
	seek.sector = key;
	unspec (seek_data) = unspec (seek);
	goto SEEK_BUILT;


BUILD_ALT_SEEK (2):					/* Alternate track region on MSU0500/1 device */


	idcw.command = SPECIAL_SEEK;


BUILD_SUPER_SEEK:

	unspec (super_seek) = "0"b;
	super_seek.sector_number = mod (key, sect_per_track (dev_type));
	super_seek.ti = track_indicators;
	super_seek.is_super_seek = "1"b;
	super_seek.flag = "1"b;			/* ON => sector number in 0-12 rather than block count limit */
	cyl = divide (key, sect_per_cyl (dev_type), 16, 0);
	head = mod (key, sect_per_cyl (dev_type));
	head = divide (head, sect_per_track (dev_type), 16, 0) * 2 + mod (cyl, 2);
	if mod (cyl, 2) = mod (drive, 2) then /* see EPS for details of this crock */
	     if mod (cyl, 2) = 0 then cyl = cyl + 1;
	     else cyl = cyl - 1;
	super_seek.cyl_lower = mod (cyl, 256);
	super_seek.cyl_upper = divide (cyl, 256, 2, 0);
	super_seek.head = head;
	unspec (seek_data) = unspec (super_seek);
	goto SEEK_BUILT;


BUILD_DATA_SEEK (3):				/* Data region on MSU3380 & MSU3381 devices */

	idcw.command = SEEK_512;
	goto BUILD_NORMAL_SEEK;


BUILD_ALT_SEEK (3):					/* Alternate track region on MSU3380 & MSU3381 devices */


	idcw.command = SPECIAL_SEEK_512;
	goto BUILD_SUPER_SEEK;


SEEK_BUILT:					/* Seek command and data are ready */

	dcwp = addr (sk_dcw);			/* get pointer to seek DCW */
	dcw = seek_dcw_template;			/* put in canned value */
	dcw.address = rel (addr (seek_data));		/* fill in data address */

	idcwp = addr (rw_idcw);			/* get pointer to read/write IDCW */

	if (io_command = "read") then idcw = read_idcw_template; /* if read, put in canned read value */
	else if compare_sw then /*  put in compare comd. if in that mode */
	     idcw = write_and_compare_idcw_template;
	else idcw = write_idcw_template;		/* normal write */


	idcw.chan_cmd = INHIB_AUTO_RETRY;		/* inhibit mpc auto retries */
	idcw.device = bit (drive);			/*  fill in drive number */

	dcwp = addr (rw_dcw);			/* get pointer to read/write DCW */
	dcw = read_write_dcw_template;		/* put in canned value */
	dcw.address = rel (addr (data));		/* fill in data address */
	dcw.tally = bit (block_len);			/* fill in tally */

	dcw_offset = fixed (rel (addr (sk_idcw)));	/* set offset for ioi_ */

	again = "1"b;				/* so we do it at least once */
	err_ct = 0;				/* init. error count */

	do while (again);				/* I/O loop */

	     completion.st = "0"b;			/* initialize status entry */
	     completion.run = "1"b;

	     call ioi_$connect (devx, dcw_offset, code);	/* Start I/O */
	     if code ^= 0 then call io_err ("0"b);	/* didn't get away from the starting line */

	     do while (^completion.st & completion.run);	/* while connected and no status */

		call ipc_$block (addr (wait_list), addr (event_info), code); /* wait for completion */
		if code ^= 0 then call io_err ("0"b);	/* No loiterers?? */

	     end;

	     again = "0"b;				/* set for no retry */

	     if completion.time_out |
		^(completion.st | completion.er | completion.run | completion.time_out) /* if nothing */
	     then call retry;			/* try again */

	     else if level <= 1 then call perm_err;	/* if fault */

	     else if level > 3 then call retry;		/* if special or marker */

	     else if status.maj = ATTENTION then
		if status.sub & STANDBY then call delay_retry; /* other MPC may have control */
		else call perm_err;			/* just plain attention, let user know */

	     else if status.maj = EOF then
		if (status.sub & LAST_BLOCK_MASK = LAST_BLOCK) then do; /* if we've run off end of the pack */
			if (io_command = "read") then do; /* and we were reading */
				data_read = min (true_len, (block_len - fixed (status.residue) - 1) * 4); /* amount read */
				substr (block, 1, data_read) = substr (data, 1, data_read); /* give user what we can */
				a_rec_len, rec_len = rec_len - data_left + data_read; /* and tell him how much */
				unspec (substr (block, rec_len + 1, data_left - data_read)) = fill;
						/* spaces for sequential; zeros for direct */
			     end;


			else code = error_table_$device_end; /* all other modes */


			call io_err ("0"b);		/* tell user */
		     end;

		else call perm_err;			/* any other EOF is bad news */

	     else if status.maj ^= "0000"b then call perm_err; /* don't beat a dead horse */

	end;

	if (io_command = "read") then do;		/* if normal read command */
		substr (block, 1, true_len) = substr (data, 1, true_len); /* give the user his data */
		rec_len = true_len;			/* Send back length of data actually read. */
	     end;


     end do_io;

%page;

/*  Internal procedure to retry I/O  */

retry: proc;

	if status.maj ^= ATTENTION then err_ct = err_ct + 1; /* don't keep track of attentions */

	if err_ct <= max_retries then do;		/* is it worth while? */
		idcwp = addr (rst_idcw);		/* yes, get pointer to restore IDCW */
		idcw = restore_idcw_template;		/* put in canned restore value */
		idcw.device = bit (drive);		/* fill in drive no. */
		dcw_offset = fixed (rel (addr (rst_idcw))); /* set up offset for ioi_ */
		again = "1"b;			/* and set flag to try again */
	     end;
	else call perm_err;				/* our patience has worn thin */

     end retry;

%page;

/*  Internal procedure to handle ATTENTION status with STANDBY sub-status.  */

delay_retry: proc;

/*  Have been told that this status occurs in dual-MPC configurations
   if the other MPC has the device.  This procedure merely delays for a
   short time, and then retries.  */

	err_ct = err_ct + 1;			/* keep track of how often we do this */

	if err_ct >= max_retries then do;		/* if too often */
		err_ct = 0;			/* reset error count */
		call perm_err;			/* let user decide what to do */
	     end;
	else do;
		call timer_manager_$sleep (500000, "10"b); /* delay for 1/2 sec.  */
		call retry;			/* and try again */
	     end;

     end delay_retry;

%page;


/*  Internal procedure to handle permanent I/O errors  */

perm_err: proc;




	idcwp = addrel (buf_ptr, offset);		/* look at the offending DCW chain */
	do while (idcw.code ^= "111"b & fixed (rel (idcwp)) > 0); /* look for IDCW or beginning of seg */
	     idcwp = addrel (idcwp, -1);		/* back track */
	end;
	dcwp = addrel (idcwp, 1);			/* set to corresponding DCW */
	disk_info_ptr = addr (rcp_data);		/* initialize pointer first */
	call ioi_$get_detailed_status (devx, found, buffer.control_info.rsr_data, code);
	last_cmd_ = fixed ((substr (idcw.command, 1, 6)), 6);

	if level <= 1 then do;
		call com_err_ (0, "exercise_disk:",
		     "Unrecoverable error on ^a device ^a, sector ^o (^d.).^/IOM Status:^-^w ^w^/IDCW/DCW Pair:^-^w ^w",
		     device_names (dev_type), disk_info.device_name, key, key,
		     substr (iom_stat, 1, 36), substr (iom_stat, 37, 36), idcw, dcw);

	     end;
	errors = errors + 1;			/* increment pack  error count */

	code = error_table_$device_parity;		/* tell user about his misfortune */
	goto exit;

     end perm_err;

%page;

/*  Start of CONTROL module  */

exdim_control: entry (a_iocb_ptr, order, a_info_ptr, a_code);

/*
   *	     The  following  orders  are supported when the I/O switch is
   *	open, except for getbounds, which is supported while  the  switch
   *	is attached.
*/

	dcl     order		 char (*);	/* parameter: the control order */
	dcl     a_info_ptr		 ptr;		/* parameter:  pointer to supplemental information */

	call setup ("don't_care");			/* set up working environment */

	if order ^= "getbounds" then if real_iocb_ptr -> open_descrip_ptr = null then
		call error (error_table_$not_open,
		     "Only getbounds is allowed when file is not open.");

	info_ptr = a_info_ptr;			/* grab pointer to additional info */

	if order = "getbounds" then do;		/* process the "getbounds" order */
		user_bounds.low = bounds.low;		/* pass back the low bound */
		user_bounds.high = bounds.high;	/* and the high bound */
	     end;					/*  getbounds  */


	else if order = "disk_info" then do;		/* process the disk_info order */
		disk_info_ptr = addr (rcp_data);
		if info_ptr -> disk_info.version_num ^= disk_info.version_num
		then do;
			a_code = error_table_$unimplemented_version;
			return;
		     end;
		info_ptr -> disk_info = disk_info;
	     end;

	else if order = "device_info" then do;		/* process the device_info order */
		disk_info_ptr = addr (rcp_data);	/* initialize pointer first */
		user_dev_char_table.user_subsystem_name = device_names (dev_type);
		user_dev_char_table.user_device_name = disk_info.device_name;
		user_dev_char_table.user_sect_per_dev = sect_per_dev;
		user_dev_char_table.user_cyl_per_dev = cyl_per_dev (dev_type);
		user_dev_char_table.user_sect_per_cyl = sect_per_cyl (dev_type);
		user_dev_char_table.user_sect_per_track = sect_per_track (dev_type);
		user_dev_char_table.user_num_label_sect = num_label_sect;
		user_dev_char_table.user_num_alt_sect = num_alt_sect;
		user_dev_char_table.user_sect_size = sect_size;
	     end;



	else if order = "hardware_status" then do;	/* give user the hardware details */
		user_hardware_status = iom_stat;
		user_dev_detail_status = based_rsr_data;
		user_dev_cmd = last_cmd_;
	     end;

	else call error (error_table_$no_operation, order); /* if bad order,  tell the user */

	a_code = 0;				/* made it */
	return;					/* au revoir */

/*  End of CONTROL module  */

%page;

/*  Start of MODES module  */

exdim_modes: entry (a_iocb_ptr, a_new_modes, a_code);

/*
   *	     The modes operation is supported  when  the  I/O  switch  is
   *	attached. Each mode has a complement indicated by the character
   *      "^" (e.g. "^label")  that turns the mode off.
   *
*/

	dcl     a_new_modes		 char (*);	/* parameter: new modes string */
	dcl     temp_next_mode	 char (16);	/* for type conversion for call error */

	call setup ("don't_care");			/* set up working environment */

	mode_len = length (a_new_modes);		/* see how much we've got */
	if mode_len > 0 then do;			/* if something */

		new_modes = a_new_modes;		/* grab the new modes */
		mode_start = 1;			/* keep track of where we are in the string */

		do while (next_mode ^= "");		/* mode processing loop */

		     call get_next_mode;		/* extract a  mode */
		     if next_mode ^= "" then do;	/* if we got one, do something with it */

			     mode_err_sw = "0"b;	/* give user  the benefit of the doubt */

			     if next_mode = "label"
			     then do;
				     bounds.low = num_label_sect; /* reserve label area */
				     label_sw = "1"b;
				end;
			     else if next_mode = "^label"
			     then do;
				     bounds.low = 0;/* let him  play,starting at sect. 0 */
				     label_sw = "0"b;
				end;

			     else if (next_mode = "alttrk")
			     then do;
				     bounds.high = last_sect_num (dev_type); /* reserve alternate track area */
				     alt_sw = "1"b;
				end;
			     else if next_mode = "^alttrk"
			     then do;
				     if device_group = MSU04XX
				     then bounds.high = last_alt_sect_num (dev_type);
				     else bounds.high = last_sect_num (dev_type);
				     alt_sw = "0"b;
				end;

			     else if next_mode = "wrtcmp" then compare_sw = "1"b; /* set compare mode switch */
			     else if next_mode = "^wrtcmp" then compare_sw = "0"b; /* set for ordinary write */

			     else if next_mode = "raw" then do;
				     bounds.low = 0;/* let user have entire pack in this mode */
				     bounds.high = last_physical_sect_num (dev_type);
				     raw_sw = "1"b; /* set indicator */
				end;
			     else if next_mode = "^raw" then do;
				     if label_sw	/* in label mode */
				     then bounds.low = num_label_sect; /* reset origial defaults */
				     else bounds.low = 0;
				     if ^alt_sw /* in alt mode */
					& device_group = MSU04XX /* and on a 400 series device */
				     then bounds.high = last_alt_sect_num (dev_type);
				     else bounds.high = last_sect_num (dev_type);
				     raw_sw = "0"b; /* reset raw indicator */
				end;
			     else do;		/* oh oh */
				     code = error_table_$bad_mode; /* tried to fool mother exdim_, eh?  */
				     mode_err_sw = "1"b; /* can't let that happen */
				end;

			     if ^mode_err_sw then call set_mode; /* update the mode string */

			end;
		end;
	     end;

	temp_next_mode = next_mode || "                "; /* obtain proper type for */
	temp_next_mode = substr (temp_next_mode, 1, 16);	/* the call to error */
	if code ^= 0 then call error (code, temp_next_mode); /* let him know how he did */
	else a_code = 0;

	return;					/* don't rush off */

/*  Internal procedure to extract single modes from the mode string  */

get_next_mode: proc;

	if mode_len > 0 then do;			/* if we still have something left */

		new_modes = substr (new_modes, mode_start, mode_len); /* update work string */

		i = index (new_modes, ",");		/* set i to length of next mode + 1 */
		if i = 0 then do;
			i = index (new_modes, " ");
			if i = 0 then i = mode_len + 1;
		     end;

		mode_len = mode_len - i;		/* keep track of how much we have left */
		mode_start = i + 1;			/* and where to start */
		next_mode = substr (new_modes, 1, i - 1); /* pass back the mode */

	     end;

	else next_mode = "";			/* nothing to return */

     end get_next_mode;

/*  Internal procedure to update the mode string  */

set_mode: proc;

	not_sw = (substr (next_mode, 1, 1) = "^");	/* set switch if a  "^" mode */

	i = index (mode_string, substr (next_mode, 1 + fixed (not_sw))); /* point to basic mode */

	if i <= 1 then if not_sw then mode_string = "^" || mode_string; else ; /* if at beg. just prefix "^" */

	else if not_sw & (substr (mode_string, i - 1, 1) ^= "^") /* insert a  "^" */
	then substr (mode_string, i) = "^" || substr (mode_string, i);

	else if ^not_sw & (substr (mode_string, i - 1, 1) = "^") then /* delete a "^" */
	     substr (mode_string, i - 1) = substr (mode_string, i);

     end set_mode;

/*  End of MODES module  */

%page;

/*  Start of CLOSE module  */

exdim_close: entry (a_iocb_ptr, a_code);

/*
   This operation has no effect on the device, but merely  resets some
   fields in the IOCB.
*/

	call setup ("open");			/* set up working environment */

	mask_str = "0"b;				/* initialize ips_ mask */
	call default_handler_$set (cond_hdlr);		/* protect ourselves */
	call hcs_$set_ips_mask (mask_str, mask_str);

	real_iocb_ptr -> open_descrip_ptr = null;	/* put IOCB in closed state;  open descrip. pointer */

	real_iocb_ptr -> open = exdim_open;		/* set open entry */
	real_iocb_ptr -> detach_iocb = exdim_detach;	/* and detach entry */

	real_iocb_ptr -> close,			/* shut the close entry */
	     real_iocb_ptr -> read_record,		/* and the read record entry */
	     real_iocb_ptr -> rewrite_record,		/* and the rewrite record entry */
	     real_iocb_ptr -> position,		/* and the position entry */
	     real_iocb_ptr -> write_record,		/* and the write record entry */
	     real_iocb_ptr -> seek_key = iox_$err_not_open; /* and the seek key entry */

	call iox_$propagate (iocb_ptr);		/* give iox_ a turn */

	call hcs_$reset_ips_mask (mask_str, mask_str);	/* back to normal */

	next_key, current_key, key_for_insertion = NULL;	/* reset all keys to invalid state */

	a_code = 0;				/* be nice to him */
	return;					/* and he may call us again, sometime */

/*  End of CLOSE module  */
%page;
/*  Start of DETACH  module  */

exdim_detach: entry (a_iocb_ptr, a_code);

/*
   This operation dismounts and detaches the device, and cleans up the IOCB.
*/

	call setup ("closed");			/* set up working environment */

/* The following code dismounts the pack.  It can be deleted when RCP gets around to doing this. */

	if media_removable (dev_type)
	then do;					/* unload the pack */
		idcwp = addr (rst_idcw);		/* use the restore IDCW slot */
		idcw = standby_idcw_template;		/* and put in canned standby idcw */
		idcw.device = bit (drive);		/* fill in drive number */
		dcw_offset = fixed (rel (addr (rst_idcw))); /* and offset  for ioi_ */
		call ioi_$connect (devx, dcw_offset, code); /* start it up, we won't wait for it to finish */
	     end;


	call rcp_$detach (rcp_id, (DEFAULT), errors, "", code); /* detach the device */

	call ipc_$delete_ev_chn (ev_chan, code);	/* get rid of event channel */

	call hcs_$delentry_seg (disk_ptr, code);	/* get rid of work segment */
	disk_ptr = null;				/* null the pointer */

	mask_str = "0"b;				/* initialize ips_ mask */
	call default_handler_$set (cond_hdlr);		/* protect ourselves */
	call hcs_$set_ips_mask (mask_str, mask_str);

	iocb_ptr -> attach_data_ptr = null;		/* clean up the IOCB;  null the data pointer */
	iocb_ptr -> attach_descrip_ptr = null;		/* and the attach descrip. pointer */

	iocb_ptr -> iocb.control,			/* reset control */
	     iocb_ptr -> iocb.modes = iox_$err_no_operation; /* and modes operations */

	call iox_$propagate (iocb_ptr);		/* tell iox_ */

	call hcs_$reset_ips_mask (mask_str, mask_str);	/* back to normal */

	if code ^= 0 then call error (code, "Problem in detaching."); /* tell user if something went wrong */

	a_code = 0;				/* otherwise, give him a good send-off */
	return;

/*  End of DETACH module  */
%page;
/*  Internal SETUP Procedure  */

setup: proc (setup_input_arg);

	dcl     setup_input_arg	 char (*);
	dcl     desired_switch_state	 char (12) varying;

/*  call setup ("open")       means the switch should be open   -- complain if it is closed.  */
/*  call setup ("closed")       "    "     "     "    "  closed --    "     "  "  "    open.  */
/*  call setup ("don't_care") means that the switch can be either open or closed.  */

	dcl     who_did_the_attach	 char (6);	/*  Which I/O module attached this file?  */
	dcl     setup_error_msg	 char (36);	/*  temporary error message  */

	code = 0;					/* give him a chance to make it */

	desired_switch_state = setup_input_arg;
	iocb_ptr = a_iocb_ptr;			/* pick up pointer to IOCB */
	real_iocb_ptr = iocb_ptr -> actual_iocb_ptr;	/* the real one, this time */
	disk_ptr = real_iocb_ptr -> attach_data_ptr;	/* and a pointer to our work seg */

	if real_iocb_ptr -> attach_descrip_ptr = null then
	     call error (error_table_$not_attached, "");
						/*  must be attached */

	who_did_the_attach = substr (attach_descrip.descrip, 1, index (attach_descrip.descrip, " ") - 1);
	if who_did_the_attach ^= "exdim_" then do;
		setup_error_msg = "Not attached by exdim_ but by " || who_did_the_attach;
		call error (error_table_$not_attached, setup_error_msg);
	     end;


	if desired_switch_state = "open" then
	     if real_iocb_ptr -> open_descrip_ptr = null then
		call error (error_table_$not_open, "");

	     else if desired_switch_state = "closed" then
		if real_iocb_ptr -> open_descrip_ptr ^= null then
		     call error (error_table_$not_closed, "");

		else if desired_switch_state = "don't_care" then
		     return;

     end setup;
%page;

/*  Internal ERROR Procedure  */

error: proc (cd, err_msg);

	dcl     cd		 fixed bin (35);	/* code */
	dcl     err_msg		 char (*);	/* Additional text. */

	code = cd;				/* set code */
	go to exit;				/* and exit, stage right */

     end error;

%page;

/*  Internal PACK MOUNT procedure  */

mount: proc;


	errors = 0;				/* give the pack a fresh start */

	disk_info_ptr = addr (rcp_data);		/* init. disk info prior to attaching device */
	disk_info.volume_name = pack_id;		/* fill in new pack id */

	call rcp_$attach ((rcp_dev_type), disk_info_ptr, ev_chan, "", rcp_id, code); /* attach device */
	if code ^= 0 then return;			/* let caller handle problems */

	call rcp_$check_attach (rcp_id, disk_info_ptr, "", devx, max_buff_size, (time_int), rcp_state, code);
	if code ^= 0 then return;			/* check attachment completion */

	do while (rcp_state ^= COMPLETE);		/* loop until attachment is complete or fails */
	     on cleanup call detach;			/* detach disk if user aborting */
	     call ipc_$block (addr (wait_list), addr (event_info), code); /* wait to hear from rcp_ */
	     revert cleanup;
	     if code ^= 0 then return;
	     call rcp_$check_attach (rcp_id, disk_info_ptr, "", devx, max_buff_size, (time_int), rcp_state, code);
	     if code ^= 0 then return;		/* let caller worry about it */
	     if rcp_state < COMPLETE | rcp_state >= LONG_WAIT then do;
		     code = error_table_$action_not_performed; /* let user know he has a problem */
		     return;			/* let caller pass bad news to user */
		end;
	end;

	if drive = NOT_SET then do;
		drive_number.sign = "+";		/* successful assignment, convert and save drive number */
		drive_number.number = substr (disk_info.device_name, 6, 2);
		drive = drive_dec;
	     end;

	buf_len = min (max (divide (sze, 4, 17, 0), 1024), max_buff_size); /* determine ioi_ buffer size */
	call ioi_$workspace (devx, buf_ptr, buf_len, code); /* and try to get it */
	if code ^= 0 then return;			/* win some -- lose some */
	data_len = buf_len - overhead;		/* set length of data area */

	call ioi_$set_status (devx, fixed (rel (addr (istat))), 1, code); /* tell ioi_ how to reach us */
	if code ^= 0 then return;

	call ioi_$timeout (devx, time_int, code);	/* have ioi_ do it */
	if code ^= 0 then return;			/* how do you like that! */

detach: proc;
	call rcp_$detach (rcp_id, "0"b, (0), "", (0));
	return;
     end detach;

     end mount;

%page;

/*  Internal CONDITION HANDLER */

cond_hdlr: proc (mc_ptr, cond_name, wc_mc_ptr, info_ptr, cont_sw);

/*
   This procedure handles any unusual conditions signaled while we are
   masked by terminating the process.  This avoids problems we
   would have if we attempted to use an IOCB  which was left in an
   inconsistent state.
*/
	dcl     (mc_ptr, wc_mc_ptr, info_ptr) ptr;
	dcl     cond_name		 char (*);	/* condition name */
	dcl     cont_sw		 bit (1) aligned;	/* continuation switch */

	if masked then do;				/* if we were masked, kill the process */
		tp_info.version = 0;		/* currently version 0 */
		tp_info.code = error_table_$termination_requested; /* as good a reason as any */
		call terminate_process_ ("fatal_error", addr (tp_info)); /* do the dirty deed */
	     end;

	if cond_name ^= "cleanup" then cont_sw = "1"b;	/* don't pass on cleanup */

     end cond_hdlr;



     end exdim_;

%page;
%include iocbx;
%page;
%include iom_pcw;
%page;
%include iom_dcw;
%page;
%include rcp_disk_info;
%page;
%include iox_modes;
%page;
%include fs_dev_types;
%page;
%include query_info;


     end exercise_disk;
