/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

update_seg:  us:	procedure
		options ( rename (( alloc_, smart_alloc_ )) );


/*

	This procedure is the first-generation user interface to the Multics
	Online Updater.  Facilities are provided for batching several segments
	which must be installed together into a single operation, for error
	recovery (consisting of restoring the affected libraries to a consistent
	state), and for deinstallation.  Flexible options are provided for
	setting names and acl's on installed segments.

	All calls to update_seg are of the form:

		update_seg function args options


	"function" may be: set_defaults (sd), print_defaults (pd), init (in),
	print (pr), add, replace (rp), move (mv), delete (dl), install,
	de_install, clear, and list (ls).  All installation requests
	are placed in a list of updater tasks;  these tasks are then
	compiled into a list of installation operations in which the
	most sensitive operations (adding names to target segments)
	come last in the list, and are processed nearly simultaneously.
	Error recovery during processing may be inhibited if desired.  Actions
	performed may be logged on the console (before or after processing)
	via the "print" function.  

	P. Bos, June 1972
	G. Dixon, February 1973
	P. Kelley, May 1973
	P. Kelley, March 1980
	  1) Added optional pathname specification to the "-log"
	     control argument with the "initiate" function.
	  2) Added the "-initial_acl" & "-iacl" control arguments for
	     the add, replace, move operations.
	     MIS version number changed to 1.5
	E. N. Kittlitz, March 1981
	  Changed MIS version number to 1.6 for entry_bound support
	  in upd_install_task_ and upd_copy_seg_task_.
            Modified 1984-12-05 BIM to pass signal_io_ conditions.
*/

/****^  HISTORY COMMENTS:
  1) change(86-07-17,GDixon), approve(86-08-18,MCR7494),
     audit(86-08-18,Martinson), install(86-08-19,MR12.0-1129):
     Add -fill and -no_fill control arguments to control filling of the
     -log description.
                                                   END HISTORY COMMENTS */

/**/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

     dcl	com_err_			entry options (variable),
	command_query_		entry options (variable),
	condition_		entry (char(*), entry),
	condition_interpreter_	entry (ptr, ptr, fixed bin, fixed bin, ptr, char(*), ptr, ptr),
	continue_to_signal_		entry (fixed bin(35)),
	cu_$arg_count		entry (fixed bin),
	cu_$arg_ptr		entry (fixed bin, ptr, fixed bin, fixed bin(35)),
	cu_$cl			entry,
	cu_$level_get		entry returns (fixed bin),
	cv_dec_check_		entry (char(*), fixed bin(35)) returns (fixed bin(35)),
	cv_mode_			entry (char(*), bit(36) aligned, fixed bin(35)),  
	cv_userid_		entry (char(*)) returns (char(32)),
	date_time_		entry (fixed bin(71), char(*) aligned),
	date_time_$fstime		entry (fixed bin(35), char(*) aligned),
	equal_			entry (ptr, ptr, ptr, fixed bin(35)),
	expand_path_		entry (ptr, fixed bin, ptr, ptr, fixed bin(35)),
	find_condition_info_	entry (ptr, ptr, fixed bin(35)),
	get_group_id_$tag_star	entry returns (char(32) aligned),
	get_process_id_		entry returns (bit(36) aligned),
	get_wdir_			entry returns (char(168) aligned),
	hcs_$delentry_file		entry (char(*), char(*), fixed bin(35)),
	ioa_$ioa_stream		entry options (variable),
	ios_$attach		entry (char(*), char(*), char(*), char(*), bit(72) aligned),
	ios_$detach		entry (char(*), char(*), char(*), bit(72) aligned),
	msa_manager_$area_handler	entry (ptr, char(*), ptr, ptr, bit(1) aligned),
	msa_manager_$make_special	entry (fixed bin, char(*), char(*), ptr, fixed bin, ptr, fixed bin(35)),
	msa_manager_$initiate	entry (char(*), char(*), ptr, fixed bin, ptr, fixed bin(35)),
	msa_manager_$terminate	entry (ptr, fixed bin(35)),
	msf_manager_$adjust		entry (ptr, fixed bin, fixed bin(24), bit(3), fixed bin(35)),
	msf_manager_$close		entry (ptr),
	msf_manager_$open		entry (char(*), char(*), ptr, fixed bin(35)),
	upd_print_acl_		entry (ptr, fixed bin, bit(*)),
	reversion_		entry (char(*)),
	set_lock_$lock		entry (bit(36) aligned, fixed bin, fixed bin(35)),
	set_lock_$unlock		entry (bit(36) aligned, fixed bin(35)),
	suffixed_name_$find		entry (char(*), char(*), char(*), char(*), fixed bin(2), fixed bin(5),
				fixed bin(35)),
	suffixed_name_$new_suffix	entry (char(*), char(*), char(*), char(*), fixed bin(35)),
	upd_add_task_$init		entry (ptr, ptr),
	upd_add_task_$reset		entry (ptr),
	upd_gen_call_		entry (ptr, ptr),
	upd_print_err_		entry options (variable),
	upd_task_			entry (bit(1), ptr, entry, ptr),
	upd_thread_task_		entry (ptr, ptr);

     dcl	upd_install_task_		entry (bit(36) aligned, ptr, ptr, fixed bin(35), fixed bin, ptr, fixed bin,
				(3) char(168), (3) char(32), (3) fixed bin(5), (3) ptr, (3) fixed bin, (3) ptr, 
				(3) fixed bin, bit(36) aligned, ptr, fixed bin(18), bit(1), char(168) aligned,
				fixed bin(35), fixed bin(35)),
	upd_install_task_$init	entry (bit(36) aligned, ptr, ptr, fixed bin(35), fixed bin, ptr, fixed bin,
				bit(1), bit(1), ptr, char(32) aligned),
	upd_describe_task_		entry (bit(36) aligned, ptr, ptr, fixed bin(35), fixed bin, ptr, fixed bin,
				ptr, char (168) aligned, ptr, fixed bin(35) ),
	upd_subtask_		entry (bit(36) aligned, ptr, ptr, fixed bin(35), fixed bin, ptr, fixed bin,
				ptr, ptr);

     dcl (addr, baseno, clock, dim, fixed, index, length, max, mod, null, size, substr)
				builtin;

     dcl (error_table_$bad_conversion,
	error_table_$bad_ring_brackets,
	error_table_$badcall,
	error_table_$badopt,
	error_table_$dirseg,
	error_table_$fatal_error,
	error_table_$improper_data_format,
	error_table_$invalid_lock_reset,
	error_table_$segno_in_use,
	error_table_$locked_by_this_process,
	error_table_$lock_wait_time_exceeded,
	error_table_$moderr,
	error_table_$namedup,
	error_table_$noentry,
	error_table_$not_done,
	error_table_$out_of_bounds,
	error_table_$out_of_sequence,
	error_table_$seg_not_found,
	error_table_$seglock,
	error_table_$too_many_names,
	error_table_$too_many_acl_entries,
	error_table_$wrong_no_of_args)
				fixed bin(35) ext static;

     dcl  (sys_info$default_max_length,
	 sys_info$max_seg_size)	fixed bin ext static;

     dcl	area			area based (Pmsa_ptr);	/* all allocations will be within log segment */

     dcl (argp, fp, p, q, inp, rqp, desp)	 ptr;

     dcl	(logp, msa_ptr)		ptr int static init (null);	/* log segment pointer */

     dcl  Pmsa_ptr			ptr based (msa_ptr);

     dcl	a			fixed bin,	/* used by acl, name options */
	argi			fixed bin,	/* argument index */
	argl			fixed bin,	/* argument length */
	code			fixed bin(35),	/* status code */
	f			fixed bin,	/* updater function called */
	fail			fixed bin,	/* from -severity option */
	fl			fixed bin,	/* length of function arg */
         (i, j)			fixed bin,	/* random */
	mode			fixed bin(5),	/* argument to suffixed_name_$find */
	n			fixed bin,	/* used by acl, ringbracket, name options */
	nargs			fixed bin,	/* argument count */
	npath			fixed bin,	/* number of non-control (i.e. pathname) args */
	option			fixed bin,	/* code for control arg being processed */
	r			fixed bin,	/* temp used by ringbracket option */
	state			fixed bin,	/* used in decoding acl option */
	status			bit(72) aligned,	/* an I/O system status code. */
	type			fixed bin(2);	/* argument to suffixed_name_$find */

     dcl	arg			char(argl) based (argp);	/* argument */

     dcl	answer			char(3) aligned,	/* answer to a query */
	date			char(24) aligned,	/* a date-time string */
	dir (3)			char(168),	/* dirname array */
	doc_dir			char(168) aligned,	/* documentation directory */
	docsw			bit(1) init ("0"b),	/* ON if documentation directory being changed */
	dummy			char(1),		/* dummy char string */
	eqseg			char(32),		/* entryname to match = */
	fcbp			ptr,	/* ptr to _file _control _block used by msf_manager_ */
	function			char(fl) based (fp),/* updater function invoked */
	init_log_segment		char(168) aligned,		/* pathname of opt. "init" log segment */
	listdir			char(168),		/* dirname of installation list segment */
	Llistdir			fixed bin,		/* length of non-blank part of listdir */
	listseg			char(32), 		/* entryname of installation list segment */
	logdir			char(168) int static,	/* dirname of current installation log */
	logseg			char(32) int static,/* entryname of log */
	maxl			fixed bin(18) init (0), /* max seg length */
	proc			char(10) aligned int static init ("update_seg"),	/* for com_err_ */
	seg (3)			char(32),		/* entryname array */
	tseg			char(32),		/* temp. entryname */
	Version_No		char(4) aligned int static init ("1.6"), /* MIS Version No. */
	xxx			char(16);		/* part of com_err_ comment */

     dcl	ctlw			bit(36) aligned,	/* control word for task procedures */
	eqsw			bit(1) aligned,	/* non-zero if = may be decoded */
	nofillsw			bit(1) aligned,	/* non-zero for "-no_fill" */
	rstrtsw			bit(1) aligned,	/* non-zero for "-restart" option */
	stopsw			bit(1) aligned,	/* non-zero for "-stop" option */
	sws			bit(36) aligned;	/* option word for segment request */

     dcl  owp ptr;					/* ptr to option switches		*/
						/* meaning of switches depends upon	*/
						/* function being performed, so...	*/
     dcl	1 request_option_word	aligned based (owp),/* breakdown of sws by "request" actions */
	 (2 archivesw		bit (1),		/* "-archive" */
	  2 old_namesw		bit (1),		/* "-old_name" */
	  2 spec_segsw		bit (1),		/* "-special_seg" */
	  2 logsw			bit (1),		/* "-log" */
	  2 defersw		bit (1),		/* "-defer" */
	  2 mlsw			bit (1),		/* "-max_length" */
	  2 pad			bit (30)) unal;

     dcl	1 print_option_word		aligned based (owp),/* breakdown of sws by "print"/"list" actions */
	 (2 errorsw		bit (1),		/* "-error" */
	  2 briefsw		bit (1),		/* "-brief" */
	  2 longsw		bit (1),		/* "-long" */
	  2 log_sw		bit (1),		/* "-log" */
	  2 pad			bit (32)) unal;

     dcl	1 clear_option_word		aligned based (owp),/* breakdown of sws by "clear" actions */
	 (2 cerrorsw		bit (1),		/* "-error" */
	  2 uidsw			bit (1),		/* "-uid" */
	  2 pad			bit (34)) unal;

     dcl	1 install_option_word	aligned based (owp),/* breakdown of sws by "install" actions */
	 (2 stopsw		bit (1),		/* "-stop" */
	  2 pad			bit (35)) unal;

     dcl	1 init_option_word		aligned based (owp),/* breakdown of sws by "init" actions */
	 (2 restartsw		bit (1),		/* "-restart" */
	  2 padd			bit (2),
	  2 log_sw		bit (1),		/* "-log" */
	  2 pad			bit (32)) unal;

     dcl (endlabel, errlabel)		label local;	/* used for install/de_install functions */

     dcl	faultlabel		label local init (logerr);
						/* used to recover from seg_fault errors during */
						/* installation object segment initialization. */

     dcl	1 stat			based (addr (status)),/* overlay for I/O status code */
	  2 code			fixed bin(35);	/* a system status code */


     dcl	1 global_default		aligned int static,	/* per-process default acl, rb's */
	  2 log_directory		char (168) aligned init (""),/* default is "working_dir" */
	  2 rb (3)		fixed bin init (1,5,5), /* default is " 1,5,5 " */
	  2 acl,					/* n.b. not same as "acl" array */
	    3 n			fixed bin init (1),	/* 1 entry to start with */
	    3 a1,					/* default is "re *.*.*" */
	      4 userid		char(32) init ("*.*.*"),
	      4 mode		bit(36) init ("1100"b),
	      4 bits		bit(36) init ("0"b),
	      4 code		fixed bin(35) init (0),
	    3 a2 (29),				/* leave room for 30 entries in default acl */
	      4 userid		char(32),
	      4 mode		bit(36),
	      4 pad		bit(36),
	      4 code		fixed bin(35);

     dcl	1 t			aligned,		/* all acl, rb, name args fill in here */
	  2 log_directory		char (168) aligned, /* -sld */
	  2 rb (3)		fixed bin,	/* -rb */
	  2 acl (3),				/* -acl, -deleteacl, -setacl */
	    3 n			fixed bin,	/* acl count */
	    3 a (30),				/* acl array */
	      4 userid		char(32),		/* user name */
	      4 mode		bit(36),		/* mode (rew) */
	      4 pad		bit(36),		/* padding     */
	      4 code		fixed bin(35),	/* error code   */
	  2 names (3),				/* -names, -deletenames, -addnames */
	    3 n			fixed bin,	/* name count */
	    3 a (30),				/* name array */
	      4 name		char(32),		/* name */
	      4 pcode		fixed bin(35),	/* installation code */
	      4 rcode		fixed bin(35);	/* de_installation code */

     dcl	1 default			aligned based,	/* overlay for "t", "global_default" */
	  2 log_directory		char (168) aligned, /* documentation dir */
	  2 rb (3)		fixed bin,	/* ring brackets */
	  2 acl,					/* default acl */
	    3 n			fixed bin,	/* acl count */
	    3 a (30),				/* acl array */
	      4 userid		char(32),		/* user name */
	      4 mode		bit(36),		/* mode	         */
	      4 pad		bit(36),		/* padding */
	      4 code		fixed bin(35);	/* error code */

     dcl	1 acl (n)			aligned based,	/* single acl array */
	  2 userid		char(32),		/* .. used for allocations */
	  2 mode			bit(36),
	  2 pad			bit(36),
	  2 code			fixed bin(35);

     dcl	1 names (n)		aligned based,	/* single names array */
	  2 name			char(32),		/* .. also for allocations */
	  2 pcode			fixed bin(35),	/* installation status code */
	  2 rcode			fixed bin(35);	/* de_installation status code */

     dcl	1 in			aligned based(inp),	/* args for upd_install_task_$init call */
	  2 temp			ptr init (null),	/* pointer to its internal temps */
	  2 taskp			ptr init (null),	/* its task pointer */
	  2 code			fixed bin(35) init (0), /* status code */
	  2 sev			fixed bin init (0),	/* severity code */
	  2 seqno			fixed bin init (0),	/* sequence no (no special task ordering) */
	  2 io_name		char (32) aligned init (""); /* name of io seg */

     dcl	1 desc			aligned based (desp), /* args for upd_describe_task_ task call */
	  2 taskp			ptr init (null),	/* its task pointer */
	  2 code			fixed bin(35) init (0), /* status code */
	  2 sev			fixed bin init (0),	/* severity code */
	  2 seqno			fixed bin init (1),	/* sequence no. */
	  2 temp			ptr init (null);	/* ptr to temps */

     dcl	1 rq			aligned based(rqp),	/* args for upd_install_task_ call */
	  2 temp			ptr init (null),	/* pointer to his internal temps */
	  2 taskp			ptr init (null),	/* his task pointer */
	  2 ap (3)		ptr init ((3) null),/* acl array pointers */
	  2 np (3)		ptr init ((3) null),/* name array pointers */
	  2 an (3)		fixed bin init ((3) 0),	/* acl counts */
	  2 nn (3)		fixed bin init ((3) 0),	/* name counts */
	  2 code			fixed bin(35) init (0),	/* status code */
	  2 sev			fixed bin init (0),	/* severity code */
	  2 seqno			fixed bin init (0),	/* sequence no. (no ordering) */
	  2 dir (3)		char(168) unal,	/* dirname array */
	  2 seg (3)		char(32) unal,	/* entryname array */
	  2 rb (3)		fixed bin(5),	/* ring brackets for target seg */
	  2 maxlen		fixed bin(18),	/* max length attribute */
	  2 options		bit(36);		/* installation options (-archive, -oldnames, etc.) */

     dcl	1 log			aligned based (logp),	/* installation log */
	  2 version		char(4) aligned,	/* updater version number */
	  2 init_id		bit(36),		/* process id of process which initialized it last */
	  2 selfp			ptr,		/* pointer to self, to remember segment no. */
	  2 areap			ptr,		/* addr (log.area) */
	  2 linkp			ptr,		/* task linkage table root pointer */
	  2 listp			ptr,		/* task list root pointer */
	  2 processp		ptr,		/* copy of listp, modified by upd_subtask_ */
	  2 nullp			ptr,		/* static null pointer */
	  2 lock,					/* items related to locking io seg while its in use */
	    3 word		bit(36) aligned,	/* lock word */
	    3 group_id		char(32) aligned,	/* process group id of user who locked log */
	  2 fcn (4),				/* items related to groups of update_seg functions */
	    3 group_id		char(32) aligned,	/* process group id of last user to perform one */
						/* of the functions in this group on this log. */
	    3 date		fixed bin(35),	/* date on which function was performed. */
	  2 sw			aligned,		/* random switches */
	   (3 full_recovery		bit(1),		/* on if segs can be deleted in de_installation 	*/
	    3 special_segs		bit(1),		/* on if special segs are being installed */
	    3 error		bit(1),		/* on if errors occurred in install/de_install */
	    3 logging_sw		bit(1)) unal,	/* on if any documentation is being performed */
	  2 d,					/* defaults for this installation */
	    3 log_directory		char (168) aligned, /* default documentation dir */
	    3 rb (3)		fixed bin,	/* default ring brackets */
	    3 acl,				/* default access control list for new segments */
	      4 n			fixed bin,	/* number of entries in default acl */
	      4 a (30),				/* out of a maximum of 30 */
	        5 userid		char(32),		/* user name for this entry */
	        5 mode		bit(36),		/* mode */
	        5 bits		bit(36),		/* padding */
	        5 code		fixed bin(35),	/* error code */
	  2 description		ptr,		/* ptr to documentation reason description */
	  2 t,					/* args for task call to upd_subtask_ */
	    3 taskp		ptr,		/* his task pointer */
	    3 temp		ptr,		/* pointer to his internal temps */
	    3 code		fixed bin(35),	/* status code for him */
	    3 sev			fixed bin,	/* severity code */
	    3 seqno		fixed bin,	/* task sequence number (=32767) */
	  2 area			area;		/* rest of segment */

     dcl	function_table (20)		char(16) aligned int static init (
				"set_defaults",	/*  (1) */
				"print_defaults",	/*  (2) */
				"initiate",	/*  (3) */
				"print",		/*  (4) */
				"add",		/*  (5) */
				"replace",	/*  (6) */
				"move",		/*  (7) */
				"delete",		/*  (8) */
				"install",	/*  (9) */
				"de_install",	/* (10) */
				"clear",		/* (11) */
				"list",		/* (12) */
				"sd",		/* (13) (1) */
				"pd",		/* (14) (2) */
				"in",		/* (15) (3) */
				"pr",		/* (16) (4) */
				"rp",		/* (17) (6) */
				"mv",		/* (18) (7) */
				"dl",		/* (19) (8) */
				"ls");		/* (20)(12) */

     dcl	function_index (20)		fixed bin int static init (
				1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
				1, 2, 3, 4,    6, 7, 8,            12);

     dcl	option_table (44)		char(16) aligned int static init (
				"-acl",		/* (1) */
				"-delete_acl",	/* (2) */
				"-set_acl",	/* (3) */
				"-ring_brackets",	/* (4) */
				"-name",		/* (5) */
				"-delete_name",	/* (6) */
				"-add_name",	/* (7) */
				"-old_name",	/* (8) */
				"-archive",	/* (9) */
				"-severity",	/* (10) */
				"-restart",	/* (11) */
				"-stop",		/* (12) */
				"-error",		/* (13) */
				"-brief",		/* (14) */
				"-long",		/* (15) */
				"-special_seg",	/* (16) */
				"-log",		/* (17) */
				"-defer",		/* (18) */
				"-uid",		/* (19) */
				"-set_log_dir",	/* (20) */
				"-max_length",	/* (21) */
				"-da",		/* (22) (2) */
				"-sa",		/* (23) (3) */
				"-rb",	 	/* (24) (4) */
				"-nm",		/* (25) (5) */
				"-dn",		/* (26) (6) */
				"-an",		/* (27) (7) */
				"-onm",		/* (28) (8) */
				"-ac",		/* (29) (9) */
				"-sv",		/* (30) (10) */
				"-rt",		/* (31) (11) */
				"-er",		/* (32) (13) */
				"-bf",		/* (33) (14) */
				"-lg",		/* (34) (15) */
				"-ss",		/* (35) (16) */
				"-df",		/* (36) (18) */
				"-sld",		/* (37) (20) */
				"-ml",		/* (38) (21) */
	/* The next 6 control arguments don't follow the above ordering. */
	/* Too many unecessary changes would have been required.         */
				"-initial_acl",	/* (39) (22) */
				"-iacl",		/* (40) (22) */
				"-fill",		/* (41) (23) */
				"-fi",		/* (42) (23) */
				"-no_fill",	/* (43) (24) */
				"-nfi");		/* (44) (24) */

     dcl	option_index (44)		fixed bin int static init (
	1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
	   2, 3, 4, 5, 6, 7, 8, 9, 10, 11,     13, 14, 15, 16,     18,     20, 21, 
	22, 22, 23, 23, 24, 24);

     dcl	option_matrix (24, 12)	fixed bin int static init (
				1,  0,  1,  0,  1,  1,  1,  0,  0,  0,	0,  0,  /*  (1) -acl */
				0,  0,  0,  0,  2,  2,  2,  0,  0,  0,	0,  0,  /*  (2) -deleteacl */
				0,  0,  0,  0,  3,  3,  3,  0,  0,  0,	0,  0,  /*  (3) -setacl */
				4,  0,  4,  0,  4,  4,  4,  0,  0,  0,	0,  0,  /*  (4) -ring_brackets */
				0,  0,  0,  0,  5,  5,  5,  0,  0,  0,	0,  0,  /*  (5) -names */
				0,  0,  0,  0,  6,  6,  6,  0,  0,  0,	0,  0,  /*  (6) -deletenames */
				0,  0,  0,  0,  7,  7,  7,  0,  0,  0,	0,  0,  /*  (7) -addnames */
				0,  0,  0,  0,  0,  8,  0,  0,  0,  0,	0,  0,  /*  (8) -oldnames */
				0,  0,  0,  0,  9,  9,  9,  0,  0,  0,	0,  0,  /*  (9) -archive */
				0,  0,  0,  0,  0,  0,  0,  0, 10, 10,	0,  0,  /* (10) -severity */
				0,  0, 11,  0,  0,  0,  0,  0,  0,  0,	0,  0,  /* (11) -restart */
				0,  0,  0,  0,  0,  0,  0,  0, 12, 12,	0,  0,  /* (12) -stop */
				0,  0,  0, 13,  0,  0,  0,  0,  0,  0, 13,  0,  /* (13) -error */
				0,  0,  0, 14,  0,  0,  0,  0,  0,  0,	0, 14,  /* (14) -brief */
				0,  0,  0, 15,  0,  0,  0,  0,  0,  0,	0, 15,  /* (15) -long */
				0,  0,  0,  0, 16, 16, 16, 16,  0,  0,	0,  0,  /* (16) -special_seg */
				0,  0, 17, 17, 17, 17, 17, 17,  0,  0,	0,  0,  /* (17) -log */
				0,  0,  0,  0, 18, 18, 18, 18,  0,  0, 	0,  0,  /* (18) -defer */
				0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 19,  0,  /* (19) -uid */
			         20,  0, 20,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /* (20) -set_log_dir */
				0,  0,  0,  0, 21, 21, 21,  0,  0,  0,  0,  0,  /* (21) -max_length */
			          0,  0,  0,  0, 22, 22, 22,  0,  0,  0,  0,  0,  /* (22) -initial_acl */
			          0,  0, 23,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /* (23) -fill */
			          0,  0, 24,  0,  0,  0,  0,  0,  0,  0,  0,  0); /* (24) -no_fill */

     dcl	path_matrix (12, 3)		fixed bin int static init (
				0, 0, 0,		/* set_defaults */
				1, 0, 0,		/* print_defaults */
				1, 0, 0,		/* init */
				1, 0, 0,		/* print */
				1, 3, 0,		/* add */
				1, 2, 3,		/* replace */
				2, 3, 0,		/* move */
				2, 0, 0,		/* delete */
				1, 0, 0,		/* install */
				1, 0, 0, 		/* de_install */
				1, 0, 0,		/* clear */
				1, 0, 0);		/* list */

     dcl	pmax (12)			fixed bin int static init (0, 1, 1, 1, 2, 3, 2, 1, 1, 1, 1, 1),
	pmin (12)			fixed bin int static init (0, 0, 0, 0, 2, 2, 2, 1, 0, 0, 0, 0);

     dcl	fail_max			fixed bin(35) int static init (5),
	fail_min			fixed bin(35) int static init (1);

     dcl	1 query_info		aligned int static,	/* command_query_ info structure. */
	  2 version		fixed bin init (2),
	  2 yes_no_sw		bit(1) unal init ("1"b),
	  2 suppress_name		bit(1) unal init ("0"b),
	  2 status		fixed bin(35) init (0),
	  2 code			fixed bin(35) init (0);

     dcl	cleanup			condition;	/* capture this condition */

/**/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

	owp = addr(sws);

	call cu_$arg_count (nargs);			/* get number of arguments */
	if nargs = 0 then do;			/* no arguments, tell user format */
	     call com_err_ (error_table_$wrong_no_of_args, (proc),
		"^/Calling sequence is:^-^a <function> <args> <options>",
		(proc));
	     return;				/* exit to user */
	     end;
	argi = 1;					/* first arg */
	call cu_$arg_ptr (argi, fp, fl, code);		/* get pointer and length */
	if code ^= 0 then				/* unlikely */
	     go to argerr;				/* but check anyway */
	do i = 1 to dim (function_table, 1);		/* first arg is updater function */
	     if function = function_table(i) then do;	/* search table for a match */
		f = function_index(i);		/* found; get function code; */
		on cleanup begin;			/* set up handler to unlock log and detach streams */
		     call ios_$detach ( "installation_list_", "", "", status);
		     call ios_$detach ( "installation_error_", "", "", status);
		     call unlock_log;
		     end;
		go to init(f);			/* and go process call */
		end;
	     end;
	call com_err_(error_table_$badcall, (proc), "Unknown updater function specified. ""^a""", function);
	return;					/* return to user */


init(1):     					/* "set_defaults" function */
join0:	p = addr (t);				/* will be used to overlay "default" */
	q = addr (global_default);			/* copy current defaults for this process */
	p -> default = q -> default;			/* .. so arg processor can update them */
	go to join1;				/* go look at args */


init(2):	npath = 0;				/* "print_defaults" function, allow log pathname */
	go to join1;				/* go get args */


init(3):	npath = 0;				/* "initiate" function, we expect a pathname */
	rstrtsw = "0"b;				/* reset "-restart" switch */
	sws = "0"b;				/* reset switches */
	nofillsw = "0"b;				/* -log -fill is the default.			*/
	go to join0;				/* go get global defaults */

init(11):	endlabel = return;				/* "clear" function; return to user after processing */
init(4):						/* "print" function */
init(12):	sws = "0"b;				/* "list" function; reset option switches */
	npath = 0;				/* assume no log pathname supplied */
	go to join1;				/* skip to argument processor */


init(5):						/* "add" function */
init(6):						/* "replace" function */
init(7):						/* "move" function */
init(8):	npath = 0;				/* "delete" function */
	fail = 1;					/* make any error a fatal error. */
	call init_log ("1"b);			/* make sure there is an installation object segment. */
	do i = 1 to 3;				/* three of everything, by sheer coincidence */
	     dir(i), seg(i) = "";			/* blank out all pathname args */
	     t.acl(i).n, t.names(i).n = 0;		/* no names or acls yet */
	     end;
	p = addr (t);				/* first part overlaid by "default" */
	q = addr (log.d);				/* will use installation defaults */
	p -> default = q -> default;			/* copies default ringbrackets and acl */
	if f ^= 5 then				/* want acl only for add function */
	     t.acl(1).n = 0;			/* zero acl count for any other */
	if (f = 6) | (f = 7) then do i = 1 to 3;	/* if "replace" or "move", then we'll  */
	     t.rb(i) = 0;				/* determine default rings via upd_ring_task_$list   */
	     end;					/* for the "old" segment, unless "-rb" option appears later */
	npath = 0;				/* no pathnames yet */
	sws = "0"b;				/* no options either */
	maxl = sys_info$default_max_length;		/* default  */
	go to join1;				/* skip to arg processor */


init(9):	stopsw = "0"b;				/* "install" function; reset "-stop" switch */
init(10):	npath = 0;				/* "de_install" function. */
	fail = 1;					/* any error is fatal, by default. */


join1:	option = 0;				/* here to process argument list; zero option code */
	eqsw = "0"b;				/* first pathname can't have "=" */
nxtarg:	argi = argi + 1;				/* increment arg counter */
	if argi > nargs then			/* that's all there are */
	     go to aend(option);			/* go finish up current option if any */
	call cu_$arg_ptr (argi, argp, argl, code);	/* get pointer, length for this arg */
	if code ^= 0 then do;			/* unlikely error */
	     argp = addr (dummy);			/* avoid null pointer reference */
	     argl = 0;				/* didn't get nothin' */
argerr:	     call com_err_(code, (proc), """^a"" (arg ^d)", arg, argi);	/* complain to user */
	     go to return;				/* and let him figure it out */
	     end;
	if substr (arg, 1, 1) = "-" then		/* argument is option specifier */
	     go to aend(option);			/* go finish up last option */
	else					/* not a control arg, */
	     go to aarg(option);			/* go process normal arg */

ckopt:	if argi > nargs then			/* reenter here after aend(i), check arg count again */
	     go to start(f);			/* exit from arg processor if done */
	do i = 1 to dim (option_table, 1);		/* search option table for this control arg */
	     if arg = option_table(i) then do;		/* found it */
		option = option_matrix(option_index(i), f);/* very table-driven program */
		if option = 0 then			/* option not permitted for this function */
		     go to badopt;			/* pretend we never heard of it */
		go to abgn(option);			/* ok option, go process */
		end;
	     end;
badopt:	call com_err_(error_table_$badopt, (proc), "^a", arg);/* unknown updater option */
	go to return;				/* go unlock log segment, if its locked */

logerr:	call com_err_(error_table_$out_of_sequence, (proc), "^/^a.^/^a^a ^a.", 
	     "No installation object (io) segment is active", "Type:  """,
	     (proc), "initiate <io_path_name>""  to initiate an io segment");
						/* error return after log initiation failure */
return:	call unlock_log;				/* standard return point from update_seg; unlock log */
return_without_unlocking:
	return;
/**/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


aarg(0):	npath = npath + 1;				/* here for pathname argument */
	if npath > pmax(f) then			/* is that too many? */
	     go to path_err;			/* then tell user. */
	if arg ^= "" then do;			/* leave hooks for funny functions */
	     j = path_matrix (f, npath);		/* find out where to put it */
	     dir(j), seg(j) = "";			/* clear the place, cause expand_path_ doesn't */
	     call expand_path_(argp, argl, addr (dir(j)), addr (seg(j)), code);
	     if code ^= 0 then			/* bad pathname syntax */
		go to argerr;			/* go tell user */
	     i = index (seg(j), "=");			/* see if entryname includes "=" components */
	     if i ^= 0 then if eqsw then do;		/* ahaa! */
		tseg = seg(j);			/* copy entryname (equal_ blows it otherwise) */
		call equal_(addr (eqseg), addr (tseg), addr (seg(j)), code);
		if code ^= 0 then			/* bad "=" syntax */
		     go to argerr;			/* go complain */
		end;
	     eqseg = seg(j);			/* following args may use "=" option, if not already */
	     eqsw = "1"b;				/* cheaper to test than eqseg ^= "" */
	     end;
	go to nxtarg;				/* go process next argument */

aend(0):	go to ckopt;				/* no deferrred processing, go check new arg */


abgn(1):						/* "-acl" option */
abgn(2):						/* "-deleteacl" option */
abgn(3):	a = option;				/* "-setacl" option; get index for which acl (1, 2, 3) */
	state = 0;				/* first arg to option is mode */
	n = 0;					/* nothing yet */
	go to nxtarg;				/* and jump back in again */

aarg(1):						/* "-acl" option arg */
aarg(2):						/* "-deleteacl" option arg */
aarg(3):	if state = 0 then do;			/* "-setacl" option arg */
	     n = n + 1;				/* starts a new acl entry */
	     if n > dim (t.acl.a, 2) then do;		/* limit number of ACLe's to max we can store */
		call com_err_(error_table_$too_many_acl_entries, (proc),
		     "^/Only  ^d  acl entries may be specified after the  ^a  control argument.",
		     dim (t.acl.a, 2), (option_table(option)));
		go to return;			/* unlock log, if necessary, and return to user */
		end;
	     t.acl(a).a(n).code = 0;			/* reset status code */
	     if a = 2 then do;			/* is this "-deleteacl"? */
		t.acl(a).a(n).mode = "0"b;		/* yes, no mode arg */
		go to aarg2a;			/* arg is userid each time */
		end;
	     call cv_mode_(arg, t.acl(a).a(n).mode, code);/* go convert mode to binary */
	     if code ^= 0 then			/* bad mode specification */
		go to argerr;			/* go complain */
	     t.acl(a).a(n).userid = "*.*.*";		/* assume *.*.* in case no userid specified */
	     state = 1;				/* next arg should be userid */
	     end;
	else do;					/* arg is userid */
aarg2a:	     t.acl(a).a(n).userid = cv_userid_(arg);	/* get userid in standard format */
	     state = 0;				/* next arg will be mode again */
	     end;
	go to nxtarg;				/* go get next argument */

aend(1):						/* "-acl" option terminated */
aend(2):						/* "-deleteacl" option terminated */
aend(3):	t.acl(a).n = n;				/* "-setacl" option terminated; record acl size */
	go to ckopt;				/* and go check new option */


abgn(4):	n = 0;					/* "-ring_brackets", tell the rest */
	go to nxtarg;				/* go get next argument */

aarg(4):	n = n + 1;				/* should be a ring bracket */
	r = cv_dec_check_(arg, code);			/* go convert to binary */
	if code ^= 0 then do;			/* conversion error */
	     code = error_table_$bad_conversion;
	     go to argerr;				/* gripe bitch complain */
	     end;
	if r <= 0 then				/* we don't allow ring brackets of 0 or less */
	     go to rberr;				/* save hardcore the trouble */
	if r > 7 then				/* and nobody allows ringbrackets bigger than 7 */
	     go to rberr;				/* gripe */
	if n ^= 1 then if r < t.rb(n-1) then do;	/* better not be smaller than last one */
rberr:	     code = error_table_$bad_ring_brackets;	/* set error code */
	     go to argerr;				/* and go tell user what he can do with them */
	     end;
	t.rb(n) = r;				/* record ring bracket */
	if n = 3 then 				/* -rb option is self-terminating */
	     option = 0;				/* pathname may follow */
	go to nxtarg;				/* go get next argument */

aend(4):	if n = 0					/* "-ring_bracket" option terminated */
	     then do;				/* bit he didn't give us any rings! */
		n = 1;				/* start him off at ring 1 */
		t.rb(n) = max((cu_$level_get()), 5);	/* default him to highest he can handle */
		end;
	if n < 3					/* finish up the three rings */
	     then do i = n+1 to 3;
		t.rb(i) = max((cu_$level_get()), t.rb(i-1), 5);/* default him to highest */
		end;
	option = 0;				/* finished with the rings */
	go to ckopt;				/* go check next option */


abgn(5):						/* "-names" option */
abgn(6):						/* "-deletenames" option */
abgn(7):	a = option - 4;				/* "-addnames" option; get array index (1, 2, 3) */
	n = 0;					/* nobody home yet */
	go to nxtarg;				/* go get next arg */

aarg(5):						/* "-names" option arg */
aarg(6):						/* "-deletenames" option arg */
aarg(7):	n = n + 1;				/* "-addnames" option arg; increment count */
	if n > dim (t.names.a, 2) then do;		/* limit number of names to max we can store */
	     call com_err_(error_table_$too_many_names, (proc),
		"^/Only  ^d  names may be specified after the  ^a  control argument.",
		dim (t.names.a, 2), (option_table (option)));
	     go to return;				/* unlock log and return to user */
	     end;
	t.names(a).a(n).name = arg;			/* put name in array */
	t.names(a).a(n).pcode = error_table_$not_done;	/* initialize install code */
	t.names(a).a(n).rcode = 0;			/* and de_install code */
	go to nxtarg;				/* go process next argument */

aend(5):						/* "-names" option terminated */
aend(6):						/* "-deletenames" option terminated */
aend(7):	t.names(a).n = n;				/* "-addnames" option terminated; record array size */
	go to ckopt;				/* and go check up on new option */


abgn(8):	old_namesw = "1"b;				/* "-oldnames" */
	go to endopt;				/* skip */


abgn(9):	archivesw = "1"b;				/* "-archive" */
	go to endopt;


abgn(10):	go to nxtarg;				/* "-severity"; no initialization necessary */

aarg(10):	fail = cv_dec_check_ (arg, code);		/* convert severity to a number */
	if code ^= 0 then do;			/* conversion failed? Tell user. */
	     call com_err_(error_table_$bad_conversion, (proc), "Argument  ^a  ^a.",
		arg, "could not be converted to a severity number");
	     go to return;				/* unlock log and return to user */
	     end;
	go to nxtarg;

aend(10):	if (fail < fail_min) | (fail > fail_max) then do;	/* Severity outside allowable bounds. */
	     call com_err_(error_table_$out_of_bounds, (proc), "^d^/^a  ^d  to  ^d.", fail,
		"Failure severity must be a number from", (fail_min), (fail_max));
	     return;
	     end;
	go to ckopt;


abgn(11):	rstrtsw = "1"b;				/* "-restart" */
	substr (sws, 1, 1) = "1"b;
	go to endopt;


abgn(12):	stopsw = "1"b;				/* "-stop" */
	go to endopt;


abgn(13):	substr (sws, 1, 1) = "1"b;			/* "-error" */
	go to endopt;


abgn(14):	briefsw = "1"b;				/* "-brief" */
	go to endopt;


abgn(15):	longsw = "1"b;				/* "-long" */
	go to endopt;


abgn(16):	spec_segsw = "1"b;				/* "-special_seg" */
	go to endopt;


abgn(17):	substr (sws, 4, 1) = "1"b;			/* "-log" */
	if f = 3					/* if "initiate" function, then possible pathname follows*/
	     then go to nxtarg;			/* optional pathname argument may follow */
	     else go to endopt;			/* else no pathname is allowed */

						/* opt. pathname of "initiate" function*/
aarg(17):	init_log_segment = "";			/* set 1st to null */
	call expand_path_ ( argp, argl, addr(init_log_segment), null, code);
	if code ^= 0
	     then go to argerr;
	go to endopt;				/* terminate this option */

aend(17):	init_log_segment = "";			/* no pathname was supplied */
	go to ckopt;				/* find out what arg really is */
	     
abgn(18):	defersw = "1"b;				/* "-defer" */
	go to endopt;


abgn(19):	uidsw = "1"b;				/* "-uid" */
	go to endopt;


abgn(20):	goto nxtarg;				/* "-set_log_dir" option */
						/* go pick up pathname of documentation dir. */

aarg(20): doc_dir = "";				/* get ready to test expected path */
	if arg ^= "" then
	     call expand_path_(argp, argl, addr(doc_dir), null, code);
	if code ^= 0
	     then goto argerr;			/* bad pathname syntax */
	t.log_directory = doc_dir;			/* update our temporary */
	docsw = "1"b;
	goto endopt;


aend(20):	code = error_table_$wrong_no_of_args;		/* means we didn't get expected arg */
	goto argerr;


abgn(21):	mlsw = "1"b;				/* "-max_length" */
	go to nxtarg;


aarg(21):	maxl = cv_dec_check_ (arg, code);		/* check for numeric arg */
	if code ^= 0 then do;
	     call com_err_ (error_table_$bad_conversion, (proc), "Argument  ^a  ^a.",
		arg,  "could not be converted to a proper length" );
	     go to return;
	     end;
	go to endopt;				/* self terminating */


aend(21):	maxl = sys_info$max_seg_size;			/* default to highest */
	go to ckopt;				/* check new option */


abgn(22):	substr(sws, 7, 1) = "1"b;			/* "-initial_acl" */
	if f = 5					/* if "add" function then */
	     then t.acl(1).n = 0;			/* reset default acl */
	go to endopt;				/* self-terminating option */


abgn(23): nofillsw = "0"b;				/* "-fill" */
	go to endopt;
	

abgn(24): nofillsw = "1"b;				/* "-no_fill" */
	go to endopt;


endopt:	option = 0;				/* self-terminating options */
	go to nxtarg;				/* go get next argument if any */

/**/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


start(1):	p = addr (global_default);			/* "set_defaults" function */
	q = addr (t);				/* copy updated defaults back to static storage */
	p -> default = q -> default;			/* quick copy */
	return;					/* done */


						/* "print_defaults" function */
start(2):	call ios_$attach ("installation_list_", "syn", "user_output", "w", status);
	faultlabel = start2a;			/* recover from a segment fault error in case */
						/* someone deleted the "current" installation */
						/* object segment from under our noses. */
	call init_log ((npath > 0));			/* validate current log pointer, unless user specified */
						/* his own object seg as an option. */
	if logp = null then				/* if no log is "current", then */
	     go to start2a;				/* we can't very well print its defaults. */
	p = addr (log.d);				/* otherwise, print its path name and defaults */
	call ioa_$ioa_stream ("installation_list_",
	     "^/Defaults for  ^a>^a^/^5xring brackets:^/^-^d,^d,^d^/^5xACL:",
	     logdir, logseg, p->default.rb(1), p->default.rb(2), p->default.rb(3));
	call upd_print_acl_ (addr (p->default.acl.a), p->default.acl.n, "100"b);
	if p->default.log_directory ^= ""		/* if default log dir was set */
	     then call ioa_$ioa_stream ("installation_list_", /* then tell the user */
		"^5xdocumentation directory:^/^-^a", p->default.log_directory);
start2a:	p = addr (global_default);			/* print the global defaults, at the very least */
	call ioa_$ioa_stream ("installation_list_",
	     "^/Global defaults^/^5xring brackets:^/^-^d,^d,^d^/^5xACL:",
	     p->default.rb(1), p->default.rb(2), p->default.rb(3));
	call upd_print_acl_ (addr (p->default.acl.a), p->default.acl.n, "100"b);
	if p->default.log_directory ^= ""		/* if global default log dir was set */
	     then call ioa_$ioa_stream ("installation_list_", /* then tell the user */
		"^5xdocumentation directory:^/^-^a", p->default.log_directory);
	call ioa_$ioa_stream ("installation_list_", "");	/* space up paper */
	go to clean_up;				/* detach streams, and quit. */


start(3):	call init_log (rstrtsw);			/* "init" function, see about log */
	p = addr (log.d);				/* copy acl, rb defaults into log segment */
	q = addr (t);				/* consist of global defaults updated by args */
	p -> default = q -> default;			/* quick copy */
	log.fcn(1).date = fs_date();			/* record date that log was changed. */
	log.fcn(1).group_id = log.lock.group_id;	/* record installer's name in create-log slot */
	if docsw then				/* we're going to change the documentation dir */
	     if log.processp ^= null then		/* if we've already "installed" then */
						/* we can't change it.		*/
		call com_err_ (error_table_$out_of_sequence, (proc), "^/^a ^a>^a^/^a.^/^a.",
		     "Installation object (io) segment", logdir, logseg, "has previously been installed",
		     "The documentation directory has not be changed");
	if logsw then do;				/* there's a description coming... */
	     if log.processp ^= null then 		/* if desc. task already allocated, then can't change it */
		call com_err_ (error_table_$out_of_sequence, (proc), "^/^a ^a>^a^/^a.^/^a^/^a",
		     "Installation object (io) segment", logdir, logseg, "has previously been installed",
		     "The installation description cannot be changed.",
		     "As a result, the ""-log"" argument has been ignored.");
	     else 
		call get_reason(Pmsa_ptr, nofillsw, log.description);
						/* pick up the typed lines */
						/* we'll allocate the task at "install" time */
	     end;
	go to return;				/* unlock log and return to installer */


start(4):	call init_log ("1"b);			/* "print" function, see about log */
	call ios_$attach ("installation_list_", "syn", "user_output", "w", status);
	call ios_$attach ("installation_error_", "syn", "error_output", "w", status);
						/* attach the installation output streams 	*/
	if logsw then do;				/* print the documentation description only */
	     if log.description ^= null then		/* looks like something's there */
						/* pass only minimum args */
		call upd_describe_task_ ( "000001"b, log.nullp, log.nullp, 0, 0, log.nullp, 0,
		     log.nullp, log.d.log_directory, log.description, log.fcn(3).date);
	     goto skip_print;			/* skip other print functions */
	     end;
	ctlw = substr("000001"b || sws,1, length(ctlw));	/* form print control word */
	call condition_("task_linkage_err_", linkage_err);/* set up handler for linkage errors */
	call upd_task_("0"b, (log.listp), upd_gen_call_, addr (ctlw));
						/* go process task list */
skip_print:
	call ioa_$ioa_stream ("installation_list_", "");	/* insert a blank line after the output. */
	go to clean_up;


start(5):						/* "add" function */
start(6):						/* "replace" function */
start(7):						/* "move" function */
start(8):	if log.processp ^= null then do;		/* "delete" function; make sure installation */
						/* requests can still be added to log */
	     call com_err_ (error_table_$out_of_sequence, (proc), "^/^a ^a>^a^/^a.^/^a.",
		"Installation object (io) segment", logdir, logseg, "has previously been installed",
		"No more installation requests may be added to the segment");
	     go to return;				/* unlock log and return to installer */
	     end;
	if npath < pmin(f) then do;			/* check minimum pathname count */
path_err:	     if pmin(f) = pmax(f) then		/* specialize form of error msg. */
		eqseg = "^/^a^/^a  ""^a""  ^a:  ^d.";	/* min # of paths = max # */
	     else
		eqseg = "^/^a^/^a  ""^a""  ^a:  ^d  or  ^d.";	/* min # of paths < max # paths */
	     call com_err_(error_table_$wrong_no_of_args, (proc), eqseg,
		"The number of path names which must be specified",
		"with the", (function_table(f)), "function is", (pmin(f)), (pmax(f)));
	     go to return;				/* unlock log and return to installer */
	     end;
	if f = 6 then if npath = 2 then do;		/* third arg is optional for replace */
	     dir(3) = dir(2);			/* if omitted, third path becomes directory part	*/
	     seg(3) = seg(1);			/* of second path, and entryname part of first	*/
	         					/* path, meaning put new seg in old directory.	*/
	     end;
	if ( f = 5 | f = 6) then if npath = 2 then	/* if we're adding/replacing and only 2 paths given,	*/
	     if t.names(1).n ^= 0 then		/* and  "-name" option was issued,		*/
		seg(3) = t.names(1).a(1).name;	/* then entryname part of third path becomes	*/
						/* first name in "-name" array"		*/
	call condition_ ("area", msa_manager_$area_handler );
						/* set up handler for "area" condition	*/
	allocate rq in (area);			/* get some space to put things for this call */
	do i = 1 to 3;				/* three of everything (coincidence?) */
	     rq.dir(i) = dir(i);			/* dirname */
	     rq.seg(i) = seg(i);			/* entryname */
	     rq.rb(i) = t.rb(i);			/* ring brackets */
	     n = t.acl(i).n;			/* get count for this acl entry */
	     if n ^= 0 then do;			/* anything there? */
		allocate acl in (area) set (p);	/* yes, make us an acl */
		q = addr (t.acl(i).a(1));		/* get pointer to temporary one */
		p -> acl = q -> acl;		/* copy acl into log segment */
		rq.ap(i) = p;			/* set pointer and length in request block */
		rq.an(i) = n;			/* for call to upd_install_task_ */
		end;
	     n = t.names(i).n;			/* get count for name array entry */
	     if n ^= 0 then do;			/* same as for acl */
		allocate names in (area) set (p);	/* we got one, allocate space in log */
		q = addr (t.names(i).a(1));		/* get pointer to names array */
		p -> names = q -> names;		/* copy names */
		rq.np(i) = p;			/* set pointer */
		rq.nn(i) = n;			/* and size */
		end;
	     end;
	rq.options = sws;				/* copy option switches */
	rq.maxlen = maxl;				/* max length */
	ctlw = "01"b;				/* allocating task only, no processing */
	errlabel = command_ignored;			/* no error recovery either */
	call ios_$attach ("installation_error_", "syn", "error_output", "w", status);
						/* attach error stream in case one occurs.	*/
	call condition_("task_error_", task_error);	/* set up condition handler for task errors */
	call condition_("task_linkage_err_", linkage_err);/* .. for linkage errors */
	call condition_("thread_task_", thread_task);	/* .. for task threading */
	call upd_add_task_$init (Pmsa_ptr, log.linkp);	/* tell tasker where area and link list are */
	call upd_install_task_(ctlw, Pmsa_ptr, log.nullp, rq.code, rq.sev, rq.taskp, rq.seqno,
	     rq.dir, rq.seg, rq.rb, rq.ap, rq.an, rq.np, rq.nn, rq.options, rq.temp, rq.maxlen,
	     log.sw.full_recovery, log.d.log_directory, log.fcn(3).date, log.fcn(4).date);
	log.sw.special_segs = log.sw.special_segs | substr (sws, 3, 1); /* if we're installing a special segment */
	log.sw.logging_sw = log.sw.logging_sw | substr (sws, 4, 1);    /* if there's documenting... */
	log.fcn(1).date = fs_date();			/* record date that log was changed. */
	log.fcn(1).group_id = log.lock.group_id;	/* record who changed the log last */
	go to cleanerr;				/* do some cleanup work, then quit */
command_ignored:
	call com_err_ (error_table_$fatal_error, (proc),
	     "^/As a result, the  ""^a ^a""  command has been ignored.",
	     (proc), (function_table(f)));
	log.sw.error = "0"b;			/* ignore this error in any listing. */
	go to cleanerr;				/* see, we had an error. Detach error stream. */


start(9):	call init_log ("1"b);			/* "install" function; make sure log exists 	*/
	if log.listp = null then do;			/* no listp -> no tasks in list		*/
nolistp:	     call com_err_(error_table_$out_of_sequence, (proc), "^/Installation log is empty.  ^a>^a.",
		logdir, logseg );			/* let user figure this one out !		*/
	     goto return;				/* and exit stage do_nothing			*/
	     end;
	if log.processp = log.listp then		/* if log was installed before, but completely	*/
	     if log.sw.error then do;			/* de_installed, and if errors occurred during	*/
	 	endlabel = start9a;			/* installation, then clear these errors by	*/
		ctlw = "00000000010"b;		/* calling "update_seg clear -error" function as	*/
		go to start11a;			/* internal subroutine.			*/
		end;
start9a:	endlabel = full_recovery_off;			/* if installation completes successfully, then	*/
						/* installation can never be fully-de_installed	*/
	ctlw = "00101"b;				/* set up a "compile" and "task_run" control word	*/
	xxx = "Installation";			/* set up directional variable for com_err_ msg	*/
	log.fcn(3).date = fs_date();			/* set date and time of installation. 		*/
	log.fcn(3).group_id = log.lock.group_id;	/* record who installed the log.		*/
	log.fcn(4).date = 0;			/* clear date for possible future de_installation.*/
	go to start9b;				/* skip initialization for "de_install" function	*/

start(10):call init_log ("1"b);			/* "de_install" function; make sure log exists	*/
	if log.listp = null 			/* and make sure listp -> a list of tasks	*/
	     then goto nolistp;			/* no listp -> no task list			*/
	if log.fcn(3).date = 0 then do;		/* zero install date means we can't "de_install"	*/
	     call com_err_(error_table_$out_of_sequence, (proc),
		"^/Installation Object segment ^a>^a has NOT been ""installed"".",
		logdir, logseg );			/* tell user the good news			*/
	     goto return;				/* and exit				*/
	     end;
	endlabel = clean_up;			/* cleanup when done.			*/
	ctlw = "10101"b;				/* set "reverse", "compile", & "task_run" control	*/
	xxx = "De-installation";			/* set reverse direction in var for com_err_ msg	*/
	log.fcn(4).date = fs_date();			/* set date and time of de_installation.	*/
	log.fcn(4).group_id = log.lock.group_id;	/* record who de_installed the log.		*/

start9b:	if stopsw then				/* user doesn't want error recovery */
	     errlabel = abort;			/* customer always knows best */
	else					/* he didn't say, */
	     errlabel = recover;			/* so do it for him */
	call ios_$attach ("installation_list_", "syn", "user_output", "w", status);
	call ios_$attach ("installation_error_", "syn", "error_output", "w", status);
						/* Here We GO!  Attach installation streams first */
	call condition_("task_error_", task_error);	/* set up condition handlers */
	call condition_("task_linkage_err_", linkage_err);/* for all kinds of errors */
	call condition_("thread_task_", thread_task);	/* set up handler for task threading */
	call condition_ ("area", msa_manager_$area_handler);
						/* handler for "area" condition.	*/
          call condition_ ( "any_other", default_handler );	/* handle all conditions and treat them as */
						/* fatal errors unless they're very special. */
	call upd_add_task_$init (Pmsa_ptr, log.linkp);	/* initialize task allocator */
	if log.processp = null then do;		/* is this the very first time we've "process"ed log? */
	     allocate in in (area);			/* get some space to put things in for initialize call */
	     in.io_name = logseg;			/* copy name of current io seg */
	     call upd_install_task_$init ("01"b, Pmsa_ptr, log.nullp, in.code, in.sev, in.taskp, in.seqno,
		log.sw.special_segs, log.sw.full_recovery, in.temp, in.io_name);
						/* add installer message routine to task list. */
	     log.processp = log.listp;		/* copy task list root pointer */
	     if log.description ^= null then		/* at least we're writing a description */
		log.sw.logging_sw = "1"b;		/* make sure the switch is set */
	     if log.sw.logging_sw then do;		/* add description task, (if logging anything) */
		allocate desc in (area);		/* grab space for description call */
		call upd_describe_task_ ("01"b, Pmsa_ptr, log.nullp, desc.code, desc.sev, 
		     desc.taskp, desc.seqno, desc.temp, log.d.log_directory, log.description, log.fcn(3).date);
		end;
	     end;
rerun:	call upd_subtask_(ctlw, Pmsa_ptr, log.nullp, log.t.code, log.t.sev, log.t.taskp, log.t.seqno,
	     log.processp, log.t.temp);		/* process task list */
	go to endlabel;				/* "full_recovery_off" or "clean_up" */

recover:	call reversion_ ("any_other");				/* stop handling conditions */
	substr (ctlw, 1, 1) = ^(substr (ctlw, 1, 1));	/* here for error recovery, do it backward now */
	call com_err_(error_table_$fatal_error, (proc), "^/^a aborted. The installation will be de-installed.", xxx);
	errlabel = abort;				/* avoid infinite error recovery loop */
	endlabel = clean_up;			/* after recovery; don't unset full_recovery sw */
	xxx = "Error recovery";			/* for com_err_ call */
	log.fcn(4).date = fs_date();			/* set date of restoration and		*/
	log.fcn(4).group_id = log.lock.group_id;	/* record who is restoring the installation	*/
	go to rerun;				/* and call task dispatcher again */

abort:	call reversion_ ("any_other");				/* stop handling conditions */
	call com_err_(error_table_$fatal_error, (proc), "^a aborted.", xxx);
	go to clean_up;				/* cleanup, then return to user */

full_recovery_off:
	log.sw.full_recovery = "0"b;			/* once installation is complete, we cannot	*/
	go to clean_up;				/* cleanup io streams and return. */
						/* fully recover (by deleting new segs) during a	*/
						/* de_installation operation.	*/


start(11):call init_log("1"b);			/* "clear" function; make sure log exists 	*/
	if cerrorsw then				/* are we clearing errors? */
	     if log.listp ^= null then		/* if log has been installed before, */
		if log.processp ^= log.listp then do;	/* but hasn't been completely de-installed... */
		     call com_err_ (error_table_$out_of_sequence, (proc),
			"^/Performing the ""^a ^a -error"" function at this time^/will render ^a>^a unusable.", 
			(proc), (function_table(f)), logdir, logseg);
		     goto return;
		     end;
	ctlw = substr("000000000"b || sws,1,length(ctlw));/* do nothing but clearing task indicated by user */
start11a:	call condition_("task_linkage_err_", linkage_err);/* resolve our special linkage errors 		*/
	call upd_task_ ("0"b, (log.listp), upd_gen_call_, addr (ctlw));
						/* process all upd_install_task_'s in task list 	*/
	log.fcn(2).date = fs_date();			/* record date clear operation was performed. */
	log.fcn(2).group_id = log.lock.group_id;	/* record who cleared the log.		*/
	if ctlw & "00000000010"b then			/* if errors have been cleared, then		*/
	     log.sw.error = "0"b;			/* reset global error switch.			*/
	go to endlabel;


start(12):call init_log("1"b);			/* "list" function, log must exist */
	call suffixed_name_$new_suffix (logseg, "io", "il", listseg, code);
						/* store name of listing segment */
	listdir = get_wdir_();			/* put listing segment in working directory */
	Llistdir = mod (index (listdir, " ")+168, 169);	/* calculate length of non-blank part of dir */
	call msf_manager_$open (listdir, listseg, fcbp, code);
	if code = 0 then do;			/* if it already exists, truncate it */
	     call msf_manager_$adjust (fcbp, 0, 0, "111"b, code);
	     if code ^= 0 then
		go to listerr;
	     end;
	else if code = error_table_$noentry then;	/* if it doesn't exist yet, all is well */
	else do;
listerr:	     call com_err_ (code, (proc), 		/* report other errors to user */
		"^/Installation list (il) segment  ^a>^a  cannot be created.", listdir, listseg);
	     go to return;				/* unlock the log and return to installer.	*/
	     end;
	call msf_manager_$close (fcbp);		/* close msf to conserve space in system_free_ */

	call ios_$attach ("installation_list_", "file_", substr (listdir, 1, Llistdir) || ">" || listseg,
	     "w", status);				/* attach I/O streams to installation list segment */
	if stat.code ^= 0 then do;
	     code = stat.code;
	     go to listerr;
	     end;
	call ios_$attach ("installation_error_", "syn", "installation_list_", "w", status);
						/* write error messages into the segment, too */
	call condition_ ("task_linkage_err_", linkage_err);	/* resolve task linkage errors */

	call date_time_ (clock(), date);		/* write header of listing segment */
	call ioa_$ioa_stream ("installation_list_", "^|^/^a^2x^a>^a^2/^20a^a",
	     "INSTALLATION OBJECT SEGMENT", logdir, logseg,
	     "Listed on:", date);

	call date_time_$fstime (log.fcn(1).date, date);
	call ioa_$ioa_stream ("installation_list_", "^20a^a^/^20a^a (^a ^a)^/^20a^a",
	     "Created by:", log.fcn(1).group_id,
	     "Created with:", (proc), "MIS Version", log.version,
	     "Created on:", date);

	if log.fcn(2).date ^= 0 then do;		/* if log has been cleared, tell about that. */
	     call date_time_$fstime (log.fcn(2).date, date);
	     call ioa_$ioa_stream ("installation_list_", "^20a^a^/^20a^a",
		"Cleared by:", log.fcn(2).group_id,
		"Cleared on:", date);
	     end;

	if log.fcn(3).date ^= 0 then do;		/* if log has been installed, tell about that. 	*/
	     call date_time_$fstime (log.fcn(3).date, date);
	     call ioa_$ioa_stream ("installation_list_", "^20a^a^/^20a^a",
		"Installed by:", log.fcn(3).group_id,
		"Installed on:", date);
	     end;

	if log.fcn(4).date ^= 0 then do;		/* if log has been de_installed, tell about that 	*/
	     call date_time_$fstime (log.fcn(4).date, date);
						/* emphasize the fact of de-installation */
	     call ioa_$ioa_stream ("installation_list_", "^/INSTALLATION HAS BEEN DE-INSTALLED");
	     call ioa_$ioa_stream ("installation_list_", "^20a^a^/^20a^a",
		"De-installed by:", log.fcn(4).group_id,
		"De-installed on:", date);
	     end;


	if log.description ^= null then do;		/* documentation description follows: */
	     call ioa_$ioa_stream ("installation_list_", "^/DOCUMENTATION DESCRIPTION FOLLOWS:");
						/* pass only minimum args. */
	     call upd_describe_task_ ( "00000100100"b, log.nullp, log.nullp, 0, 0, log.nullp, 0,
		log.nullp, "", log.description, log.fcn(3).date);
	     end;

	call ioa_$ioa_stream ("installation_list_", "^3/SUMMARY OF THE INSTALLATION:");
	ctlw = "00000101000"b;			/* output in brief mode */
	call upd_task_ ("0"b, (log.listp), upd_gen_call_, addr (ctlw));
						/* let installation primitives generate output */

	if log.sw.error then do;			/* if errors occurred, list them next */
	     call ioa_$ioa_stream ("installation_list_", "^3/SUMMARY OF ERRORS WHICH OCCURRED DURING INSTALLATION:");
	     ctlw = "00000110000"b;			/* output errors only */
	     call upd_task_ ("0"b, (log.listp), upd_gen_call_, addr (ctlw));
	     end;
	else if log.fcn(3).date ^= 0 then		/* if no errors occurred during installation, tell user */
	     call ioa_$ioa_stream ("installation_list_", "^3/NO ERRORS OCCURRED DURING INSTALLATION.");
	else					/* otherwise, tell user log hasn't been installed */
	     call ioa_$ioa_stream ("installation_list_",
		"^3/INSTALLATION OBJECT SEGMENT HAS N_O_T_ BEEN INSTALLED.");

	if ^briefsw then do;			/* if ^"-brief" mode, then print normal output */
	     call ioa_$ioa_stream ("installation_list_",
		"^5/A DESCRIPTION OF THE INSTALLATION FOLLOWS.^|^/INSTALLATION DESCRIPTION:");
	     ctlw = "00000100000"b;			/* output in normal mode */
	     call upd_task_ ("0"b, (log.listp), upd_gen_call_, addr (ctlw));
	     end;

	if longsw then do;				/* if "-long" mode, then print details */
	     call ioa_$ioa_stream ("installation_list_", "^5/INSTALLATION DETAILS FOLLOW:");
	     ctlw = "00000100100"b;			/* output in detailed mode */
	     call upd_task_ ("0"b, (log.listp), upd_gen_call_, addr (ctlw));
	     end;


clean_up:	call ios_$detach ("installation_list_", "", "", status);
cleanerr:	call ios_$detach ("installation_error_", "", "", status);
						/* detach streams as a cleanup measure. */
	go to return;				/* unlock the log and return to installer.	*/

/**/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


init_log:		procedure (sw);			/* initialize installation log segment 		*/


     dcl	sw			bit(1) aligned;	/* non-zero if reinitiating old segment 	*/

     dcl	process_id		bit(36) aligned;	/* process id.				*/

     dcl	seg_fault_error		condition;	/* condition				*/


	if npath = 0 then do;			/* no log specified as argument 		*/
	     on seg_fault_error begin;		/* trap condition where io seg deleted without	*/
		logp = null;			/* telling update_seg.			*/
		go to faultlabel;
		end;
	     if logp ^= null then			/* validate our log pointer as best we can.	*/
		if logp = log.selfp then do;
		     revert seg_fault_error;		/* stop handling this condition		 */
		     call validate_user;
		     return;
		     end;
	     logp = null;				/* already null, or inconsistent 		*/
	     go to faultlabel;			/* go bitch at user 			*/
	     end;
	logp = null;				/* make sure pointer, name not inconsistent 	*/
	msa_ptr = null;				/* ditto					*/
	logdir = dir(1);				/* copy dirname of segment specified 		*/
	call suffixed_name_$find (logdir, seg(1), "io", logseg, type, mode, code);
						/* find the io seg if it exists, or create	*/
						/* properly-suffixed path name from the one given	*/
						/* to us by the user.			*/
	if sw then do;				/* perform re-initiation processing.		*/
	     if code ^= 0 then do;			/* if we're re-init-ing a seg which doesn't exist,*/
re_init_fail:	call com_err_ (code, (proc),
		     "^/Installation object (io) segment ^a>^a cannot be re-initiated.", logdir, seg(1));
	 	go to return_without_unlocking;	/* then tell installer about it, and return.	*/
		end;
	     if type = 2 then do;			/* if a directory was found, then		*/
		call com_err_ (error_table_$dirseg, (proc), "^/^a>^a ^a.^/^a.", logdir, logseg,
		     "is a directory",
		     "It cannot be re-initiated as an installation object (io) segment");
		go to return_without_unlocking;
		end;
	     if mod (mode, 4) = 0 then do;		/* if user can't useio seg, then complain.	*/
		code = error_table_$moderr;
		go to re_init_fail;
		end;
	     call msa_manager_$initiate (logdir, logseg, msa_ptr, (size(log)), logp, code);
	     if code ^= 0 then do;			/* Oh, Boy!  An error during initialization.	*/
		if code = error_table_$segno_in_use then 
						/* Component of io seg couldn't be initiated	*/
						/* with segno which was used before.  Tell the	*/
						/* user he must free this segno.		*/
		     call com_err_ (code, (proc), "^/^a ^a>^a^/^a ^o (octal).^/^a^/^a ^a again.",
			"A component of the installation object (io) segment", logdir, logseg,
			"must be initiated with the segment number", fixed (baseno(msa_ptr), 35),
			"Please terminate the segment which is now known",
			"by this number, and re-initiate", logseg);
		else
		     if code = error_table_$noentry then do;
						/* The first SSA of the MSA was not found.	*/
			call com_err_ (code, (proc), "^/^a ^a>^a^/^a.^/^a.",
			     "The first component of the installation object (io) segment", logdir, logseg,
			     "was discovered to be missing",
			     "The installation object (io) segment cannot be re-initiated");
			go to return_without_unlocking;
			end;
		else
		     if code = error_table_$seg_not_found then
						/* An SSA, other than the first SSA of MSA, was	*/
						/* discovered to be missing.  A new SSA is	*/
						/* created to replace the old SSA.		*/
			call com_err_ ( code, (proc), "^/^a ^a>^a^/^a.^/^a.",
			     "A component of the installation object (io) segment", logdir, logseg,
			     "was discovered to be missing.  A new component was created to replace it",
			     "Some data may be missing" );
		else
		     if code = error_table_$improper_data_format then
						/* an attempt was made to initiate an MSA which	*/
						/* was found to not be an MSA.		*/
		     call com_err_ (code, (proc), "^/^a>^a ^a.^/^a.",
			logdir, logseg, "does not have the format of an installation object (io) segment",
			"Please check its consistency" );
		else 				/* otherwise, it was another error.		*/
		     call com_err_ ( code, (proc), "^a>^a", logdir, logseg);
		go to return;
		end;
	     if msa_ptr = null then			/* initiation failed.			*/
		go to re_init_fail;
	     if log.init_id = "0"b then do;		/* if this segment was never initiated before,	*/
		call msa_manager_$terminate (msa_ptr, code);
						/* terminate it, and go initiate it with a high number. */
		logp, msa_ptr = null;		/* null ptr's, because terminate_seg doesn't.	*/
		go to init_high;
		end;
	     call validate_user;			/* make sure this user knows what he's doing.	*/
	     process_id = get_process_id_();
	     if log.init_id ^= process_id then		/* has log been initialized by this process?	*/
		call upd_add_task_$reset (log.linkp);	/* no, reset procedure entry pointers.		*/
	     log.init_id = process_id;		/* leave out mark.				*/
	     end;

	else do;					/* otherwise, we're creating the io seg.	*/
	     if code = 0 then do;			/* zero code means log already exists. Tell user.	*/
		call com_err_ (error_table_$namedup, (proc),
		     "^/Installation object (io) segment ^a>^a already exists.", logdir, logseg);
		go to return_without_unlocking;	/* quit.					*/
		end;
	     if code ^= error_table_$noentry then do;	/* any other errors are somewhat serious.	*/
randomerr:	call com_err_ (code, (proc),
		     "^/^a  ^a>^a  ^a", "Installation object segment", logdir, seg(1),
		     "cannot be initiated.");
		go to return_without_unlocking;	/* quit.					*/
		end;
init_high:     call msa_manager_$make_special (256, logdir, logseg, msa_ptr, (size(log)), logp, code);
	     if code ^= 0 then do;
		msa_ptr = null;			/* make sure it's null */
		if sw then go to randomerr;		/* re-initting old one */
		if code = error_table_$segno_in_use then do;/* msa_man_ has this gross bug */
						/* which leaves new seg hanging around */
		     call hcs_$delentry_file ( logdir, logseg, (0) );
	     	     call com_err_ (code, (proc), "^/^a.  ^a>^a ^a.^/^a.",
		          "No high segment numbers are available", logdir, logseg,
		          "cannot be initiated",
			"Type:  ""new_proc""  and try again");

	     	     go to return_without_unlocking;
		     end;
		go to randomerr;			/* something else */
	          end;

	     log.lock.word = "0"b;			/* lock the new installation object segment.	*/
	     log.lock.group_id = get_group_id_$tag_star();
	     log.version = Version_No;		/* initialize the io seg header.		*/
	     call validate_user;
	     log.areap = msa_ptr;
	     log.d.log_directory = "";
	     log.init_id = "0"b;			/* make sure it's 0				*/
	     log.selfp = logp;			/* save copy of log pointer in log segment	*/
	     log.linkp,				/* initialize linkage list ptr.		*/
	     log.listp,				/* no task list...				*/
	     log.processp,				/* no task-last-processed.			*/
	     log.nullp,
	     log.description,
	     log.t.taskp,
	     log.t.temp = null;
	     log.fcn.group_id = log.lock.group_id;	/* record creator of io seg.  Only he can build,	*/
						/* install, de_install, or clear seg w/o questions*/

	     log.fcn.date,
	     log.d.rb(1),
	     log.d.rb(2),
	     log.d.rb(3),
	     log.d.acl.n,
	     log.t.code,
	     log.t.sev = 0;

	     log.t.seqno = 32767;			/* highest seqno means append upd_subtask_ to the	*/
						/* very end of the primary task list.		*/
	     log.sw.full_recovery = "1"b;		/* to start with, full recoveries are allowed.	*/
	     log.sw.special_segs,			/* to start with, there are no special segs 	*/
	     log.sw.error,				/* there are no errors,			*/
	     log.sw.logging_sw = "0"b;		/* and, to start, there's no documentation 	*/

	     log.init_id = get_process_id_();		/* leave our mark.				*/
	     end;

	end init_log;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


/**/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


validate_user:	procedure;			/* This procedure validates the current user	*/

	if log.version ^= Version_No then do;		/* first, check version numbers		*/
						/* if not same, tell user the bad news		*/
		call com_err_ (error_table_$fatal_error, (proc),
		     "^a>^a was created with MIS Version ^a.^/^a ^a.^/^a ^a ^a ^a.", logdir, logseg,
		     log.version, "The version you are now using is MIS Version ", Version_No,
		     "As a result, the", (proc), (function_table(f)), "command has been ignored");
		logp = null;
		go to return;			/* can't use this log */
		end;

	call set_lock_$lock (log.lock.word, 0, code);	/* lock the installation object segment.	*/
	if code ^= 0 then
	     if code = error_table_$invalid_lock_reset then;
						/* somebody bombed out while processing io seg?	*/
						/* ignore him.				*/
	     else if code = error_table_$locked_by_this_process then
		call com_err_ (code, (proc), "^/^a  ^a>^a.^/^a ^a ^a function.",
		     "Non-fatal error encountered while locking", logdir, logseg,
		     (proc), "will continue performing the", (function_table(f)));
	     else if code = error_table_$lock_wait_time_exceeded then do;
lockerr:		call com_err_ (error_table_$seglock, (proc), "^/^a  ^a>^a^/^a ^a.^/The  ""^a ^a""  ^a.",
		     "Installation object (io) segment", logdir, logseg,
		     "is already being manipulated by", log.lock.group_id,
		     (proc), (function_table(f)), "command cannot be performed");
		go to return_without_unlocking;	/* don't unlock seg; just return.		*/
		end;
	     else					/* report any other errors.			*/
	 	go to lockerr;
	if log.lock.group_id ^= get_group_id_$tag_star() then do;
						/* if another installer last referenced this log	*/
						/* then ask this installer if he knows what he's	*/
						/* doing.					*/
	     call command_query_ (addr (query_info), answer, (proc), 
		"^a>^a ^a ^a.^/^a  ""^a ^a""  command?",
		logdir, logseg, "was created by", log.lock.group_id,
		"Do you still wish to issue the", (proc), (function_table(f)));
		     				/* make sure this user wants to do his thing.	*/
	     if answer = "yes" then
		log.lock.group_id = get_group_id_$tag_star();
	     	     				/* now this guy owns the io seg.		*/
	     else do;
		logp = null;			/* forget the initialization done so far. 	*/
		go to return;
		end;
	     end;
	end validate_user;				/* return to init_log, if user is OK.		*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
/*  */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */



unlock_log:	procedure;			/* unlock io segment, if it is locked.		*/

	if logp ^= null then if log.lock.word then do;	/* if we have an io seg which is locked, then	*/
	     call set_lock_$unlock (log.lock.word, code);	/* unlock it.				*/
	     if code ^= 0 then
		call com_err_ (code, (proc), "^/While unlocking  ^a>^a.", logdir, logseg);
	     end;
	end unlock_log;				/* return to caller.			*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


fs_date:		procedure returns (fixed bin(35));	/* return current fs_time value.		*/

     dcl	date			fixed bin(35),	/* the fs_date value.			*/
	date_str			bit(36) aligned based (addr (date)),
	time			fixed bin(71),	/* the current time.			*/
	time_str			bit(72) aligned based (addr (time));

	time = clock();				/* The time is now ...			*/
	date_str = substr (time_str, 21, 36);		/* The fs_time is now...			*/
	return (date);

	end fs_date;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


thread_task:	procedure (mcp, name, wcp, taskp, csw);	/* handler for "thread_task_" condition */


     dcl	mcp			ptr,		/* machine conditions pointer */
	name			char(*),		/* condition name */
	wcp			ptr,		/* crawl-out data pointer */
	taskp			ptr,		/* pointer to allocated task */
	csw			bit(1) aligned;	/* continue switch */

	call upd_thread_task_(log.listp, taskp);	/* add task to current task list */
	end thread_task;				/* and return to signaller. */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
/**/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


task_error:	procedure (mcp, name, wcp, sp, csw);	/* "task_error_" handler */

     dcl	mcp			ptr,		/* machine conditions pointer */
	name			char(*),		/* condition name signalled */
	wcp			ptr,		/* crawl-out data pointer */
	sp			ptr,		/* status block pointer */
	csw			bit(1) aligned;	/* continue switch */

     dcl	1 s			aligned based (sp),	/* status block for task error */
	  2 proc			char(32) unal,	/* name of procedure causing error */
	  2 entry			char(32) unal,	/* entry point name */
	  2 code			fixed bin(35),	/* status code */
	  2 sev			fixed bin,	/* severity code */
	  2 string		char(200);	/* optional message */


	log.sw.error = "1"b;			/* record the fact that some error occurred 	*/
	if s.sev >= fail then do;			/* if the error is fatal, then attempt to recover	*/
	     call upd_print_err_(s.code, s.sev, "Error", "", s.proc, s.entry, s.string);
	     go to errlabel;			/* unwind stack and begin error recovery */
	     end;
	else					/* report non-fatal errors to user & continue.	*/
	     call upd_print_err_ (s.code, s.sev, "Warning", "", s.proc, s.entry, s.string);
	end task_error;				/* continue installing/de_installing 		*/


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


linkage_err:	procedure (mcp, name, wcp, sp, csw);	/* handler for "task_linkage_err_" condition */


     dcl	mcp			ptr,		/* machine conditions pointer */
	name			char(*),		/* condition name */
	wcp			ptr,		/* crawl-out data pointer */
	sp			ptr,		/* pointer to status block */
	csw			bit(1) aligned;	/* continue switch */

     dcl	1 s			aligned based (sp),	/* n.b. not same as for "error", above */
	  2 proc			char(32),		/* name of procedure signalling error */
	  2 entry			char(32),		/* entry point name */
	  2 code			fixed bin(35),	/* status code */
	  2 sev			fixed bin,	/* severity code */
	  2 rname			char(32),		/* refname of referenced procedure */
	  2 ename			char(32);		/* entryname of referenced procedure */


	call upd_print_err_(s.code, s.sev, "Task linkage error", "", s.proc, s.entry,
	     "Entry point referenced was ^a$^a", s.rname, s.ename);
	call cu_$cl;				/* reenter command level, let user fix it */
	end linkage_err;				/* return to try again */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
/**/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */




default_handler:	procedure;			/* handler for "unknown" conditions		*/


     dcl	1  cond_info aligned,			/* condition info */
	   2 mcptr	ptr,
	   2 version	fixed bin,
	   2 condition_name char(32) var,
	   2 infop	ptr,
	   2 wcptr	ptr,
	   2 loc_ptr	ptr,
	   2 flags	aligned,
	     3 crawlout	bit(1) unal,
	     3 pad1	bit(35) unal,
	   2 pad_word	bit(36) aligned,
	   2 user_loc	ptr,
	   2 pad(4)	bit(36) aligned;

	call find_condition_info_ ( null, addr(cond_info), code);
	if code ^= 0 then do;
	     call ioa_$ioa_stream ("error_output", "Error:  Unknown signal has been received." );
	     go to errlabel;				/* if call fails then try to back up */
	     end;

	if cond_info.condition_name = "alrm" then do;
continue:	     call continue_to_signal_ (code);			/* pass this error on to another handler. */
	     return;
	     end;
	if cond_info.condition_name = "signal_io_" then 
	     go to continue;

	if cond_info.condition_name = "cput" then		/* ditto					*/
	     go to continue;
	if cond_info.condition_name = "linkage_error" then	/* let system's default handler handle these	*/
	     go to continue;
	if cond_info.condition_name = "mme2" then		/* let debug intercept breakpoints.		*/
	     go to continue;
	if cond_info.condition_name = "quit" then		/* let system quit handler handle them.		*/
	     go to continue;
	if cond_info.condition_name = "command_error" then	/* if our own error handler passed, 	*/
	     go to continue;				/* pass it on.  */
	if cond_info.condition_name = "finish" then		/* means it's all over anyway 	*/
	     go to continue;
	if cond_info.condition_name = "stack" then		/* we're coming close to the end	*/
	     go to continue;
	if cond_info.condition_name = "program_interrupt" then	/* ignore program interrupts.			*/
	     return;
	if cond_info.condition_name = "stringsize" then do;	/* handle stringsize by reporting it. */
	     call ioa_$ioa_stream ("error_output", "Error: stringsize condition occurred.");
	     go to STOP;					/* condition_interpreter_ ignores these */
	     end;						/*  conditions.			*/

	call condition_interpreter_ (null(), null(), 0, 3, cond_info.mcptr, (cond_info.condition_name),
	      cond_info.wcptr, cond_info.infop);
	if stopsw then do;
STOP:	     call ioa_$ioa_stream ("error_output",
		"Returning to command level.  Type: ""start"" to begin recovery operations.");
	     call cu_$cl();
	     go to recover;
	     end;

	go to errlabel;					/* treat them as fatal errors.		*/

	end default_handler;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
/**/
get_reason:	proc (areap, nofillsw, rcp);		/* this proc accepts typed line input for */
						/* documentation later */
	/* As of March, 1980, the "reason" may be contained in a segment
	   rather than always asking the user to type it in.  The variable
	   init_log_segment is the pathname of that segment.	      */

dcl
     areap	ptr,				/* area ptr for allocation */
     nofillsw	bit(1) aligned,			/* on if reason is NOT to be filled.		*/
     rcp		ptr;				/* ptr to description within area */

dcl						/* misc. error codes */
    (error_table_$end_of_info,
     error_table_$short_record,
     error_table_$not_detached)	ext static fixed bin(35);
dcl
     code		fixed bin(35),
     i		fixed bin,
     total	fixed bin,			/* total no. of chars in area */
     null		builtin,
     substr	builtin,
     break_sw	bit (1),
     tab_sw	bit(1),
     nelemt	fixed bin(21),			/* no. of elements read */
     blockp	ptr,				/* ptr to allocated block */
     buffp	ptr;				/* ptr to input buffer */

dcl  buffer	char (512) aligned;			/* input buffer */

dcl  out_buffer	char (16384) aligned;		/* output buffer */

dcl  Area		area based (areap);			/* allocation area */

dcl  1 block	based (blockp),			/* block to be allocated */
       2 editsw	bit(1),				/* edit sw, "on" if already editted */
       2 no_chars	fixed bin(35),			/* # of chars in this block */
       2 string	char (total refer (block.no_chars));	/* the character string */

dcl  term_line (4)	char (1) init (
	".",
	"?",
	":",
	";");

dcl  HT		char (1) int static options(constant) init("	");
dcl  NL		char (1) int static options(constant) init ("
");						/* new_line char */

dcl
     ioa_			entry options (variable),
     iox_$attach_name	entry (char(*), ptr, char(*), ptr, fixed bin(35)),
     iox_$find_iocb		entry ( char(*), ptr, fixed bin(35)),
     iox_$open		entry ( ptr, fixed bin, bit(1) aligned, fixed bin(35)),
     iox_$get_line		entry ( ptr, ptr, fixed bin(21), fixed bin(21), fixed bin(35)),
     iox_$detach_iocb	entry ( ptr, fixed bin(35)),
     iox_$close		entry ( ptr, fixed bin(35));
dcl
     iocb_ptr		ptr,			/* ptr to the I/O control block */
     atd			char(256),		/* attach description */
     switch_name		char(32),
     Path			bit(1),			/* ON = look for segment */
     ref_ptr		ptr;

	total = 0;
	out_buffer = "";
	ref_ptr = null;
	buffp = addr(buffer);

	if init_log_segment ^= ""			/* means look for a segment */
	     then Path = "1"b;
	     else	Path = "0"b;			/* otherwise, ask from the terminal */

	if Path then do;
	     switch_name = "upd_init_log_sw_";
	     atd = "vfile_ " || init_log_segment;	/* build attach description */
	     call iox_$attach_name ( switch_name, iocb_ptr, atd, ref_ptr, code);
	     if ( code ^= 0 ) & (code ^= error_table_$not_detached) then do;
		call com_err_ (code, (proc), "Attaching ^a.^/^a",
		     init_log_segment,
		     "The ""log"" information remains unchanged.");
		return;
	     end;

	     call iox_$open ( iocb_ptr, 1, "0"b, code);
	     if code ^= 0 then do;
		call com_err_ (code, (proc), "Opening ^a^/^a",
		     init_log_segment,
		     "The ""log"" information remains unchanged.");
		go to DETACH_ILS;
	     end;
	end;
	else do;
	     call iox_$find_iocb ( "user_input", iocb_ptr, code );
	     if code ^=0 then do;
		call com_err_ ( code, (proc),
		     "Attaching ""user_input"".^/^a",
		     "the ""log"" information remains unchanged.");
	     end;
	     call ioa_ ("Input");			/* tell user to type */
	end;

read:	call iox_$get_line (iocb_ptr, buffp, length(buffer), nelemt, code);
	if code = error_table_$end_of_info
	     then go to process;
	if (code ^= 0) & (code ^= error_table_$short_record) then do;
	     call com_err_ (code, (proc), "Reading ""log"" information.^/^a",
		"The ""log"" information remains unchanged.");
	     go to RETURN;
	end;
	if nelemt = 2
	     then if substr(buffer,1,1) = "."
		then goto process;			/* end of input reached */
	if nelemt < 2 then do;
	     nelemt = 3;				/* just so we don't lose a NL char */
	     substr(buffer,2,1) = NL;			/* takes 2 NL's to make a blank line */
	     end;
	if (total + (nelemt-1)) >= length(out_buffer)
	     then goto warn;			/* too many chars read */
	if nofillsw then;
	else do;
	     tab_sw = "0"b;
tab:	     i = index(substr (buffer, 1, nelemt), HT);
						/* look for tabs */
	     if i ^= 0 then do;			/* found one */
	          substr( buffer,i,1) = " ";		/* convert to single char */
		tab_sw = "1"b;			/* tell the user later. */
		go to tab;
		end;
	     break_sw = "0"b;
	     do i = 1 to 4;				/* search for end of sentence chars */
		if substr(buffer,(nelemt-1),1) = term_line(i)
		     then break_sw = "1"b;
		end;
	     if break_sw then do;
		substr(buffer,nelemt,2) = "  ";	/* add 2 blanks */
		nelemt = nelemt + 2;
		end;
	     end;

	if substr(buffer, 1, 1) = " " then 		/* start on new line */
	     if total ^= 0 then do;
	     total = total + 1;
	     substr(out_buffer,total,1) = NL;		/* append new_line to out buffer */
	     end;
	if total ^= 0
	     then if substr(out_buffer,total,1) ^= NL
		then if substr(out_buffer,total,1) ^= " " then do; /* add a blank between words */
		     total = total + 1;
		     substr(out_buffer,total,1) = " ";
		     end;
						/* copy buffer into temp storage */
	substr(out_buffer,(total+1),(nelemt-1)) = substr(buffer,1,(nelemt-1));
	total = total + (nelemt -1);			/* reset total */
	if total >= length(out_buffer)		/* check total again */
	     then goto warn;
	goto read;

process:						/* allocate in area for keeping */
	if total = 0 then do;			/* someone wanted to zap previous desc. */
	     rcp = null;				/* null the pointer */
	     go to RETURN;;				/* and xfer out */
	     end;
	allocate block in (Area) set (blockp);		/* grab the storage */
	blockp->block.editsw = nofillsw;		/* not editted yet */
	blockp->block.no_chars = total;		/* copy the number of characters */
	blockp->block.string = substr(out_buffer,1,total); /* and copy the characters */
	rcp = blockp;				/* finally, the return ptr */
	if tab_sw then				/* tell the user about any conversion */
	     call ioa_ ( "Warning:  tabs have been converted to single blanks.^/");
RETURN:	code = 0;
	if Path
	     then call iox_$close ( iocb_ptr, code);
	if code ^= 0
	     then call com_err_ (code, (proc), "Closing ""log"" info.");
DETACH_ILS:
	if Path
	     then call iox_$detach_iocb ( iocb_ptr, code);
	if code ^= 0
	     then call com_err_ (code, (proc), "Detaching ""log"" info.");
	return;					/* finished */

warn:						/* too many characters entered */
	call ioa_("Maximum number of characters have been entered.^/""Input"" mode is terminated");
	goto process;
	end;

	end update_seg;
