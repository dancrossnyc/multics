/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

upd_doc_task_:	procedure
		options ( rename (( alloc_, smart_alloc_ )) );

/*	April 1973,  P. B. Kelley								*/
/*	October 1981, E. N. Kittlitz  multiply sys_info_$max_seg_size by 4, not 9			  */

/****^  HISTORY COMMENTS:
  1) change(86-06-25,GDixon), approve(86-08-18,MCR7494),
     audit(86-08-18,Martinson), install(86-08-19,MR12.0-1129):
     Changed to use more flexible mechanism to change Installations.info.
  2) change(87-01-13,GDixon), approve(87-04-16,MCR7609),
     audit(87-08-10,GJohnson), install(87-08-11,MR12.1-1080):
     Fix bug which prevents adding installation documentation in a totally
     empty Installations.info segment.
                                                   END HISTORY COMMENTS */
dcl
     control_word		bit (36) aligned,		/* control word */
     areap		ptr,			/* ptr to segment Area */
     parentp		ptr,			/* ptr to parent */
     acode		fixed bin (35),		/* error code */
     asev			fixed bin,		/* error severity */
     taskp		ptr,			/* task ptr */
     seqno		fixed bin,		/* sequence no. */
     treep		ptr,			/* ptr to modification description */
     log_name		char (168),		/* pathname of documentation segment */
     info_name		char (168),		/* pathname of documentation info segment */
     ename (3)		char(32) aligned,		/* entry name array */
     dname (3)		char(168) aligned,		/* directory name array */
     Uid (3)		bit (36) aligned,		/* unique id array */
     Sfwd_done		bit(1),			/* ON if already done */
     install_date		fixed bin (35),		/* installation date */
     de_install_date	fixed bin(35),		/* de-installation date */
     log_directory		char (168) aligned,		/* pathname of documentation directory */
     max_line_size		fixed bin,		/* maximum line size */
     prosep		ptr;			/* ptr to documentation description structure */

dcl  LOG_NAME		char(32) int static options(constant) init("Installations.log" ),
						/* MUST end with suffix ".log" */
     INFO_NAME		char(32) int static options(constant) init("Installations.info" ),
						/* MUST end with suffix ".info" */
     INFO_NAME_WHEN_FULL	char(32) int static options(constant) init("Installations.new.info"),
     INFO_HEADER		char(56) int static options(constant) init("Reverse chronological list of system software changes.

" );						/* Standard header for Installations.info. 	*/
						/* MUST be changed in this program.     	*/

dcl  1  c  aligned based (addr ( control_word)),
       (2  reverse_sw	bit (1),
        2  task_sw		bit (1),
        2  compile_sw	bit (1),
        2  run_sw		bit (1),
        2  task_run_sw	bit (1),
        2  log_sw		bit (1),
        2  error_sw		bit (1),
        2  brief_sw		bit (1),
        2  detail_sw	bit (1) ) unaligned;

dcl  A  area based (areap);				/* outside segment area where everything happens */


dcl  1  limb  aligned based (blkp),			/* block to be allocated by $get_tree */
        2  Nsegname	char (32),			/* primary name of Nsegment */
        2  Osegname	char (32),			/* former name of seg       */
        2  Nlib	char (168) aligned,			/* "target" seg library     */
        2  Olib	char (168) aligned,			/* "old" seg library */
        2  date	char (16),			/* install date */
        2  actxn	fixed bin,			/* action code of segment  */
        2  nc	fixed bin (17),			/* number components if bound */
        2  el 	(nn refer (limb.nc)),		/* array of components   */
	 3  cname		char (32),		/* component name */
	 3  cactxn	fixed bin;		/* action code of component */

dcl  1  prose based (prosep),					/* place where prose is stored */
        2  editsw		bit(1),				/* "on" if editted */
        2  no_char		fixed bin,			/* no. of characters */
        2  prose_string	char (0 refer (prose.no_char));	/* the string */

						/* structures for moving info seg around */
dcl  Inon_nl		fixed bin(21),
     created_sw		bit(1) aligned,
     full_bc		fixed bin(24),
     full_info_p		ptr,
     header_l		fixed bin(21),
     header_p		ptr,
     header		char(header_l) based(header_p),
     info_bc		fixed bin(24),
     info_l		fixed bin(21),
     info_p		ptr,
     info			char(info_l) based(info_p);

dcl  BITS_PER_CHAR		fixed bin int static options(constant) init(9);
dcl  CHARS_PER_WORD		fixed bin int static options(constant) init(4);
dcl  NL			char(1) int static options(constant) init ("
");
dcl  NL_NL		char(2) int static options(constant) init("

");

dcl  1  control_base aligned based (addr(control)),
       (2  path_given (3)	bit(1),
        2  pad 		bit(33) ) unal;

dcl  1  status based (addr(scode)),
        2  code	fixed bin(35);

dcl  mask (4) bit (36) aligned init
	("101"b,		/* ADD     action */
	 "111"b,		/* REPLACE action */
	 "010"b,		/* DELETE  action */
	 "011"b );	/* MOVE - NO REPL action */

dcl					/* codes for possible actions */
     added       fixed bin init	(1),
     replaced    fixed bin init	(2),
     deleted     fixed bin init	(3),
     moved       fixed bin init	(4),
     del_com     fixed bin init	(3);

dcl   com (1:8)  char (17)  init		/* printable comments for action codes */
    ("added to",
     "replaced in",
     "deleted from",
     "moved to",
     "de-installed from",
     "de-installed from",
     "re-installed to",
     "moved back"  );

dcl  comp_array (4) char (16) init
	("          added:",
	 "       replaced:",
	 "        deleted:",
	 "          moved:");

dcl
     cu_$arg_list_ptr 	entry (ptr),
     upd_add_task_ 		entry (char (*), ptr),
     upd_log_task_$lock	entry (char(*) aligned, fixed bin(35)),
     upd_log_task_$unlock	entry (char(*) aligned, fixed bin(35)),
     upd_print_err_		entry options ( variable ),
     upd_status_$long	entry ( char (*) aligned, char (*) aligned, fixed bin, ptr, ptr, fixed bin (35)),
     upd_task_err_ 		entry  options (variable),
     ioa_$ioa_stream 	entry options (variable),
     ios_$attach		entry  (char(*) aligned, char(*) aligned, char(*), char(32) aligned,
			       bit(72) aligned),
     ios_$detach		entry (char(*) aligned, char(*) aligned, char(*) aligned, bit(72) aligned),
     ios_$write		entry (char(*) aligned, ptr, fixed bin, fixed bin, fixed bin, bit(72) aligned),
     date_time_$fstime 	entry (fixed bin(35), char(*) aligned),
     get_wdir_		entry returns (char(168) aligned),
     get_temp_segments_	entry (char(*), (*) ptr, fixed bin(35)),
     hcs_$delentry_seg	entry (ptr, fixed bin(35)),
     hcs_$initiate_count	entry (char(*), char(*), char(*), fixed bin(24), fixed bin(2), ptr,
			     fixed bin(35)),
     hcs_$terminate_noname 	entry (ptr, fixed bin(35)),
     initiate_file_$create	entry (char(*), char(*), bit(*), ptr, bit(1) aligned, fixed bin(24),
			     fixed bin(35)),
     pathname_		entry (char(*), char(*)) returns(char(168)),
     release_temp_segments_	entry (char(*), (*) ptr, fixed bin(35)),
     terminate_file_	entry (ptr, fixed bin(24), bit(*), fixed bin(35));

dcl
    (error_table_$bad_segment,
     error_table_$moderr,
     error_table_$namedup,
     error_table_$noarg,
     error_table_$non_matching_uid,
     error_table_$oldobj,
     error_table_$rqover,
     error_table_$segknown)		fixed bin(35) ext static,
     sys_info$max_seg_size		ext fixed bin (35);

dcl  1  s1  (1000)  aligned,				/* structure containing info on segment */
        2   segname 	char (32) aligned,
        2   dtc      	fixed bin (71);
dcl  1  s2  (1000)  aligned,
        2   segname 	char(32) aligned,
        2   dtc     	fixed bin(71);

dcl  1  Stat aligned,				/* structure for upd_status_$long   */
      (2  type	bit (2),
       2  nnames	bit (16),
       2  nrp	bit (18),
       2  dtm	bit (36),
       2  dtu	bit (36),
       2  mode	bit (5),
       2  pad	bit (13),
       2  rec	bit (18),
       2  dtd	bit (36),
       2  dtem	bit (36),
       2  acct	bit (36),
       2  curlen	bit (12),
       2  bitcnt	bit (24),
       2  did	bit (4),
       2  mdid	bit (4),
       2  copysw	bit (1),
       2  pad2	bit (9),
       2  rbs (3)	bit (6),
       2  uid	bit (36)  )  unaligned;

dcl						/* misc variables */
     actions (1001)		fixed bin,
     axn 			fixed bin,		
     b1_date		char(24) aligned init (" "),
     b2_date		char(24) aligned init (" "),
     b1_name		char(32) aligned init (" "),
     b2_name		char(32) aligned init (" "),
     bitc 		fixed bin (24),
     buffer		char(132) aligned,
     code			fixed bin (35),
     control		bit(36) aligned init ("0"b),
     Date			char(16) aligned,
     de_installation_sw	bit (1),
     entry		char (32),
     errname		char(32),
     errpath		char (168),
     gate_sw		bit (1) init ("0"b),
     ignore		fixed bin(35),
     log_dir		char(168),
     logsw		bit (1),
     names (1001) 		char (32),
     new_lib		char (168) aligned,
     no_more		bit(1) init ("0"b),
     old_lib		char (168) aligned,
     record_quota_overflow	condition,
     rev			fixed bin,
     runsw		bit (1),
     scode		bit (72) aligned,
     sev			fixed bin,
     unb_sw 		bit (1) init ("1"b);

dcl (e, i, ii, nn, line_size, point) fixed bin (17);
dcl (j, k) fixed bin(17) init (1);		/* needed for do loops */
dcl (argp, q, p1, p2, Pseg, blkp) ptr init (null);
dcl  p(2) ptr init((2) null);
dcl (addr, dimension, divide, fixed, index, length, min, null, reverse,
     rtrim, setcharno, substr, verify) builtin;


/*  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  ==  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  */
/**/
get_tree:		entry (control_word, areap, parentp, acode, asev, taskp, seqno,
		     dname, ename, Uid, treep );

	e = 1;
	entry = "upd_doc_task_$get_tree";
	go to common;

write_tree:	entry (control_word, areap, parentp, acode, asev, taskp, seqno,
		     treep, install_date, de_install_date, log_directory, Sfwd_done);

	e = 2;
	entry = "upd_doc_task_$write_tree";
	go to common;

write_prose:	entry (control_word, areap, parentp, acode, asev, taskp, seqno,
		     log_directory, prosep, install_date, Sfwd_done, max_line_size);

	e = 3;
	entry = "upd_doc_task_$write_prose";

common:
	call cu_$arg_list_ptr (argp);			/* get arglist ptr       */
	logsw = c.log_sw;				/* set internal log switch */
	runsw = c.run_sw | c.task_run_sw;		/* and internal process switch */
	if c.error_sw then if asev = 0 then		/* print errors only */
	     logsw = "0"b;
	if c.task_sw then				/* add a task to list */
	     call upd_add_task_ ( entry, argp );		
	if e ^= 1 then do;				/* get_tree entry doesn't pass log_directory */
	     if substr(log_directory, 1, 1) = " " then do;
		log_dir = get_wdir_();
		log_name = LOG_NAME;		/* set the value of log_name */
		info_name = INFO_NAME;		/* and info name */
		end;
	     else do;
		log_dir = log_directory;
		log_name =  rtrim(log_directory)||">"||LOG_NAME;
		info_name = rtrim(log_directory)||">"||INFO_NAME;
		end;
	     end;

	go to start(e);

/**/
start(1):						/* get_tree entry */
	if logsw then do; 				/* user wants something printed, so... */
	     call ioa_$ioa_stream ( "installation_list_",
		"^5x^RGather documentation info^B");
	     if asev ^= 0 then
	 	call upd_print_err_ ( acode, asev );
	     return;				/* that's all we do when logging */
	     end;
	if c.reverse_sw then			/* do not run in reverse mode */
	     return;
	if ^runsw then return;			/* if not processing now, quit  */
	if treep ^= null then return;			/* if info already gathered, then quit */

	nn = 0;
	do i = 1 to 3;				/* which paths were received?  */
	     if substr (dname(i), 1, 1) ^= " "
		then path_given (i) = "1"b;
	     end;
	if control = "0"b then do;			/* means no paths received */
	     code = error_table_$noarg;		/* can't do something with nothing */
	     sev = 3;				/* bad error */
	     errpath = "<no paths received>";
	     errname = "";
	     go to err;				/* leave thru error exit */
	     end;

	do i = 1 to 2;				/* let's get some info on existing paths */
	     if path_given(i) then do;
		call upd_status_$long ( dname(i), ename(i), 1, addr(Stat), null, code);    
		   if code = 0 then do;				/* it better be */
		     if fixed(Stat.rbs(2),6) ^= fixed(Stat.rbs(3),6)     	/* If gate seg... */
			then gate_sw = "1"b;			/* then don't worry 'bout it */
		     if fixed(Uid(i)) ^= 0 then if Uid(i) ^= Stat.uid then do;/* check uid           */
			sev = 3;					/* whoops, got one */
			code = error_table_$non_matching_uid;
			errpath = dname(i);
			errname = ename(i);
			go to err;				/* let's get out now  */
			end;
		     end;
		end;
	     end;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
/*			Find action being performed		 				*/

	if (control & "010"b)			/* get standardized form of "old" lib */
	     then call valid_lib_ (dname(2), old_lib);
	     else old_lib = "";
	if (control & "001"b)			/* and standardized form of "target" lib */
	     then call valid_lib_ (dname(3), new_lib);	/* (may be different) */
	     else new_lib = old_lib;			/* only poss. is DEL; print routine expects "new_lib" */

	if control = mask(1) then do;			/* ADD action			*/
	     axn = added;
	     ename(2) = ename(3);				/* used later		 */
	     end;
	else if control = mask(2) then do;		/* REPLACE action			*/
	     if new_lib = old_lib then         			/* simple REPLACE		*/
		axn = replaced;
	     else    					/* REPLACE with MOVE	*/
		axn = moved;
	     end;
	else if control = mask(3) then do;		/* DELETE action			*/
	     axn = deleted;
	     ename(3) = ename(2);				/* used later		*/
	     end;
	else if control = mask(4) then do;		/* MOVE with no replace		*/
	     axn, del_com = moved;
	     end;
	go to init_entry;

err:						/* common out for severe errors	 */
	call upd_task_err_ ( code, sev, argp, entry, "^a>^a", errpath, errname );/* call error handler */
	return;							/* scram    */
/**/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
/*			gather info for segs given						*/
init_entry:
	if gate_sw then go to record_seg;			/* special case gates, might not have access  	*/
	errpath = dname(1);
	errname = ename(1);
	sev = 3;
	p1 = addr(s1);
	p2 = addr(s2);
	s1(1).segname, s2(1).segname = "";

	if (control & "100"b) then do;			/* let's find out about the "new" seg */
	     call hcs_$initiate_count ((dname(1)), (ename(1)), "", bitc, 0, Pseg, code); 
		 if code ^= 0 then if code ^= error_table_$segknown then do; /* sounds like it's not there */
		     if code = error_table_$moderr then go to no_rec;	/* nope, just no access */
		     go to err;					/* bad error */
		     end;
	     call doc_util_ (Pseg, bitc, p1, ename(1), unb_sw, k, b1_date, b1_name, code);
	 	if code ^= 0 then if code ^= error_table_$bad_segment then	/* might not be an object segment */
		     go to err;				/* segment probably clobbered */
	     call hcs_$terminate_noname ( Pseg, code);
	     end;

	errpath = dname(2);
	errname = ename(2);

	if (control & "010"b) then do;				/* let's find out about the "old" seg */
	     call hcs_$initiate_count ((dname(2)), (ename(2)), "", bitc, 0, Pseg, code); 
		if code ^= 0 then if code ^= error_table_$segknown then do; /* might not be there */
		     if code = error_table_$moderr then go to no_rec;	/* rings are probably 1,1,1 */
		     go to err;					/* bad error */
		     end;
	     call doc_util_ ( Pseg, bitc, p2, ename(2), unb_sw, j, b2_date, b2_name, code);
		if code ^= 0 then do;				/* couldn't get it    */
		     if code = error_table_$bad_segment then go to record_seg; /* could be non-object segment  */
		     if code = error_table_$oldobj then do;		/* wrong incls for older than '72 stuff */
			if unb_sw  then go to record_seg;		/* if unbound then don't worry  */
no_rec:			sev = 0;					/* inform user if it */
			if substr(ename(2),1,6) = "bound_" then		/* starts with "bound_"*/
			     call upd_task_err_ ( code, sev, argp, entry,
				"Not recording component changes.  ^a>^a" , errpath, errname);
			go to record_seg;				/* non-fatal, so continue... */
			end;
		     go to err;
		     end;
	     call hcs_$terminate_noname ( Pseg, code);
	     end;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
/*  */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
/*			what kind of info have we found ?					*/
	if unb_sw then
	     go to record_seg;				/* neither seg is bound */

	if (control & "010"b) then do ii = 1 to j;		/*  dig out the deleted ones first  */
	     do i = 1 to k;
		if s1(i).segname = s2(ii).segname then go to next1; /* this one's still there  */
		end;
	     nn = nn + 1;					/* this name didn't match up, so add it to list */
	     names(nn) = s2(ii).segname;
	     actions(nn) = del_com;
next1:	     end;

	if control = mask(4) then go to changed;		/* if moving w/ no repl. then xfer */

	if (control & "001"b) then do i = 1 to k;		/* now for the replaced and added ones */
	     do ii = 1 to j;
		if s1(i).segname = s2(ii).segname then do;	/* found a name-match */
		     if s1(i).dtc ^= s2(ii).dtc then do;	/* this one's being replaced */
			nn = nn + 1;			/* add it to our collection */
			names(nn) = s1(i).segname;
			actions(nn) = replaced;
			go to next2;
			end;
		     if axn = moved then do;			/* if moving, then record all components */
			nn = nn + 1;			/* add it to collection */
			names(nn) = s1(i).segname;
			actions(nn) = moved;
			end;
		     go to next2;
		     end;
		end;
	     nn = nn + 1;					/* no name-match, must be an added one */
	     names(nn) = s1(i).segname;			/* so we'll add it   */
	     actions(nn) = added;
next2:	     end;

	if b1_date ^= " " then				/* check for bindfile change */
	     if b2_date ^= " " then				/* both have been bound with v2 */
		if b1_date ^= b2_date then go to changed;  	/* and not with same bindfile */
		else go to record_seg;
							/* one (or both) was bound with v1 */
	do i = 1 to nn;					/* if any components were added, deleted, */
	     if actions(i) ^= replaced then go to changed;	/* or moved, then report bindfile change */
	     end;
	go to record_seg;
changed:  nn = nn + 1;					/* add it to our list */
	if (control & "100"b) then
	     names(nn) = b1_name;
	else
	     names(nn) = b2_name;
	actions(nn) = axn;				/* assume the action of the bound seg */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
/**/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
/*			transfer info into external area					*/

record_seg:
	allocate limb in (A) set (q);			/* allocate storage for limb */
	q->limb.Nsegname = ename(3);			/* new name of seg   */
	q->limb.Osegname = ename(2);			/* former name of seg	   */
	q->limb.Nlib = new_lib;			/* "target" seg lib */
	q->limb.Olib = old_lib;			/* "old" seg library */
	q->limb.date = "  (date)";			/* future date */
	q->limb.actxn = axn;			/* action code reflecting segment */
	if nn = 1 then if ename(3) = names(1) then 	/* means unbound seg being added|replaced|deleted */
	     nn = 0;				/* pretend no components */
	q->limb.nc = nn;				/* number of components (if bound seg) */
	if nn > 0 then do i = 1 to nn;		/* if bound, then copy all components changed */
	     q->limb.el(i).cname = names(i);		/* component name 		*/
	     q->limb.el(i).cactxn = actions(i);		/* action code reflecting component */
	     end;	
	treep = q;				/* set treep to limb   */
	return;					/* finis */

/*			end of upd_doc_task_$get_tree					*/
/*  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  ==  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  */
/**/
start(2):							/* write_tree entry */
	if ^logsw then if ^runsw then
	     return;
	if logsw then do;					/* if we're in "print" mode, then do it. */
	     if c.detail_sw then 				/* if detail, then print what's happening */ 
		call ioa_$ioa_stream ("installation_list_", "^5x^RLog into^B^-^a", log_name);
	     if treep = null then do;				/* we haven't gotten info yet */
		call ioa_$ioa_stream ("installation_list_", "^-Log Information list is empty.^/");
		return;
		end;
	     call ios_$attach ( "installation_log_", "syn", "installation_list_", "w", scode);
	     if status.code ^= 0 then do;			/* attach unsuccessful */
		call upd_task_err_ (status.code, 0, argp, entry, "Attempting to attach I/O stream.");
		go to skip_comps;
		end;
	     go to print_it;		     		/* zip thru the printing routine */
	     end;

	if Sfwd_done ^= c.reverse_sw then
	     return;					/* already finished in this direction*/
	if treep = null then 				/* can't get info from null ptr   */
	     return;

	call upd_log_task_$lock ((log_name), code);		/* lock the installation log file */
	if code ^= 0 then do;				/* whoops, something's not there */
	     call upd_task_err_ (code, 0, argp, entry, "Referencing ^R^a^B.", log_name);
	     return;					/* only issue warning if processing */
	     end;
	call ios_$attach ("installation_log_", "file_", log_name, "w", scode);
	if status.code ^= 0 then do;				/* attach unsuccessful? */
	     call upd_task_err_ (status.code, 0, argp, entry, "Referencing ^R^a^B.", log_name);
	     go to skip_comps;
	     end;

print_it:	de_installation_sw = c.reverse_sw;

	if ^de_installation_sw then do;			/* if going forward... */
	     rev = 0;
	     if install_date ^=  0 then			/* and if we have a date */
		call date_time_$fstime (install_date, Date);	/* then decode it */
	     else
		Date = "  (date)";				/*  or, for printing...	*/
	     if runsw then					/* unless we're listing */
		treep->limb.date = Date;			/* set Date fwd only 	*/
	     end;
	else do;						/* if going in reverse... */
	     rev = 4;
	     call date_time_$fstime (de_install_date, Date);
	     call ioa_$ioa_stream ( "installation_log_", "^/+++++"); /* a "reverse" separator? */
	     end;

	if treep->limb.actxn ^= moved then do;			/* Major line, fwd or rev, not moving	*/
	     call ioa_$ioa_stream ("installation_log_", "^/^16a^4x^a ^a ^a",
		Date, treep->limb.Nsegname, com(treep->limb.actxn+rev),treep->limb.Nlib);
	     if de_installation_sw then do;			/* reverse		*/
		call ioa_$ioa_stream ("installation_log_", "^/^-^5x(previously installed ^16a)",
		     treep->limb.date);			/* use block date */
		go to skip_comps;				/* skip component printing */
		end;
	     if treep->limb.Nsegname ^= treep->limb.Osegname then
		call ioa_$ioa_stream ("installation_log_", "^/^-^5x(renamed from ^a)",
			treep->limb.Osegname);
	     go to print_comps;
	     end;
							/* Major line for moving */
	if ^de_installation_sw then do;			/* fwd...		*/
	     call ioa_$ioa_stream ("installation_log_", "^/^16a^4x^a moved from ^a to ^a",
		Date, treep->limb.Nsegname, treep->limb.Olib,treep->limb.Nlib);
	     if treep->limb.Nsegname ^= treep->limb.Osegname then
		call ioa_$ioa_stream ("installation_log_", "^/^-^5x(renamed from ^a)",
		     treep->limb.Osegname);
	     end;
	else do;						/* reverse	*/
	     call ioa_$ioa_stream ("installation_log_", "^/^16a^4x^a moved back from ^a to ^a",
		Date, treep->limb.Osegname, treep->limb.Nlib, treep->limb.Olib);
	     call ioa_$ioa_stream ("installation_log_", "^/^-^5x(previously installed ^16a)",
		treep->limb.date);
	     go to skip_comps;
	     end;

print_comps:						/* now for the components */
	if treep->limb.nc = 0 then				/* if zero comps, then can't print them */
	     go to skip_comps;
	do i = 1 to 4;					/* 4 possible actions */
	     k = i;
	     do j = 1 to treep->limb.nc;			/* random arrangement, so simplest is..*/
		if treep->limb.el(j).cactxn = i then do;
		     if k ^= 0 then
			call ioa_$ioa_stream ("installation_log_",
			     "^/^16a^4x^a", comp_array(k), treep->limb.el(j).cname);
		     else
			call ioa_$ioa_stream ("installation_log_", "^2-^a", treep->limb.el(j).cname);
		     k = 0;
		     end;
		end;
	     end;

skip_comps:
	call ios_$detach ("installation_log_", "", "", scode);	/* remember to always detach this stream here */
	if runsw then do;
	     call upd_log_task_$unlock ((log_name), code);	/* unlocks log file */
	     Sfwd_done = ^Sfwd_done;
	     if substr(log_directory, 1, 1) = " " then
		log_directory = get_wdir_();
	     end;

	return;

/*			end of upd_doc_task_$write_tree				*/
/*  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  ==  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  */
/**/
start(3):							/* write_prose entry */
	if ^runsw then if ^logsw then
	     return;
	if c.reverse_sw then
	     return;					/* do nothing in reverse */
	if logsw then do;					/* user wants to check */
	     call ioa_$ioa_stream ("installation_list_",		/* already attached at this point */
		"^2/^RDocument modification description into:^B^/^5x^a.", log_name);
	     if asev ^= 0 then
		call upd_print_err_ ( acode, asev );		/* print any errors */
	     if prosep = null then do;			/* but description is empty */
		call ioa_$ioa_stream ("installation_list_",	/* already attached */
		     "^/^5x(modification description is empty)^/");
		return;
		end;
	     if (c.detail_sw | ^c.brief_sw) then do;		/* print what's there */
		call ios_$attach ( "installation_log_", "syn", "installation_list_", "w", scode);
		if status.code ^= 0 then do;
		     call upd_task_err_ ( status.code, 0, argp, entry, "Referencing ^R^a^B.", log_name);
		     return;
		     end;
		end;
	     else
		return;
	     end;

	if runsw then
	     if Sfwd_done ^= c.reverse_sw then			/* we've already done this */
		return;
	if runsw then
	     if prosep = null then do;			/* at least print separator */
	     no_more = "1"b;
	     go to skipedit;
	     end;
	if prose.editsw then				/* if we've already gone thru this... */
	     go to skipedit;				/* then let's save some time */
							/* *************************** */
							/* EDIT the best we can        */
							/* *************************** */
	point = 1;
	line_size = max_line_size;
look:	i = min ( line_size, ( (no_char - point) + 1 ) );		/* make sure we don't grab too much */
	buffer = substr ( prose_string, point, i );		/* let's look at the string */
	if i < line_size then
	     go to process;					/* we've got all we need */
	i = index ( buffer, NL );				/* look for a new_line */
	if i = 0 then do;					/* let's try something else */
	     if line_size > max_line_size then			/* if we had to grap extra chars */
		i = index ( substr ( buffer, 1, line_size ) , " "); /* look for first occurance of a blank */
	     else do;					/* non-expanded buffer, so... */
		k = index ( reverse ( substr ( buffer, 1, line_size ) ), " "); /* look for last occurance of a blank */
		if k ^= 0 then
		     i = line_size - ( k - 1 );		/* set i to blank char */
		end;
	     if i ^= 0 then do;				/* if we found one */
		substr ( buffer, i, 1 ) = NL;			/* make it a new_line */
		go to process;
		end;
	     if line_size ^> (max_line_size + 10) then do;	/* increase size of line ( max. 10) */
		line_size = line_size + 5;
		go to look;
		end;
	     i = max_line_size;				/* have to cut off line */
	     end;

process:	substr ( prose_string, point, i) = substr ( buffer, 1, i);
	point = point + i;					/* adjust out pointer */
	if point < no_char then				/* check for end of the line */
	     go to look;

skipedit:	if logsw then do;					/* write description on already attached stream */
	     call ioa_$ioa_stream ("installation_log_", "");	/* NL */
	     call ios_$write ("installation_log_", addr(prose.prose_string), 0, prose.no_char, i, scode);
	     call ioa_$ioa_stream ("installation_log_", "");	/* NL (really CR here) */
	     go to return;					/* nothing more to do here */
	     end;
							/* *************************** */
							/* first, the LOG file         */
							/* *************************** */
	call upd_log_task_$lock ((log_name), code );		/* set the lock */
	if code ^= 0 then 
	     go to lock_err;
	call ios_$attach ( "installation_log_", "file_", log_name, "w", scode);
	if status.code ^= 0 then do;
	     call upd_task_err_ ( status.code, 0, argp, entry, "Referencing ^R^a^B.", log_name);
	     go to un_log;
	     end;
	call ioa_$ioa_stream ( "installation_log_", "^/*****");	/* start with a separator */
	if ^no_more then do;				/* continue only if there's more */
	     call ios_$write ("installation_log_", addr(prose.prose_string), 0, prose.no_char, i, scode);
	     call ioa_$ioa_stream ("installation_log_", "");     	/* NL */
	     end;
un_log:	call ios_$detach ("installation_log_", "", "", scode);	/* detach the print stream */
	call upd_log_task_$unlock ((log_name), code);		/* unlock the log */
	if code ^= 0 then
	     call upd_task_err_ ( code, 0, argp, entry, "Referencing ^R^a^B.", log_name);
	if no_more then					/* nothing more to do */
	     go to return;
							/* *************************** */
							/* and now the INFO file       */
							/* *************************** */
	call date_time_$fstime ( install_date, Date);
	call upd_log_task_$lock ((info_name), code);		/* lock the info file */
	if code ^= 0 then do;
	     log_name = info_name;
	     go to lock_err;
	     end;
							/* get temp space */
	call get_temp_segments_ ("upd_doc_task_", p, code);
	if code ^= 0 then do;
	     call upd_task_err_ ( code, 0, argp, entry, "Getting temp segment.");
	     go to un_info;
	     end;
							/* now the REAL seg */
	call hcs_$initiate_count ( log_dir, INFO_NAME, "", info_bc, 1, info_p, code);
	if (code ^= 0 & code ^= error_table_$segknown) then do;
	     call upd_task_err_ ( code, 0, argp, entry, "^2xInitiating info segment^/^2x(^a).",
		info_name);
	     go to un_info;
	     end;
	info_l = divide (info_bc, BITS_PER_CHAR, 21, 0);

	call save$init (p(1));				/* save copy of current info seg in case*/
	call save$str (info);				/*   it must be restored (eg on RQO).	*/

	call out$init (p(2));				/* prepare to build new copy of info seg. */
	if substr(info,1,min(length(info),length(INFO_HEADER))) = INFO_HEADER then do;
							/* if our heading line is present, then */
	     header_p = info_p;				/* insert new data between header and   */
	     header_l = length(INFO_HEADER);			/* existing data.			*/
	     end;
	else do;						/* if our heading line is NOT present,  */
	     header_p = info_p;				/* insert new data after first blank    */
	     header_l = index(info, NL_NL);			/* line in the info segment.		*/
	     if header_l > 0 then
	        header_l = header_l - 1 + length(NL_NL);
	     end;
	info_p = setcharno(info_p, length(header));
	info_l = info_l - length(header);

	Inon_nl = verify(info, NL);				/* Strip extra NLs from start of data.	*/
	if Inon_nl > 1 then do;
	     info_p = addcharno(info_p, Inon_nl-1);
	     info_l = info_l - (Inon_nl-1);
	     end;

	call out$str (header);				/* output our header, date line and	*/
	call out$str (substr(Date,1,8));			/* new documentation into temp segment. */
	call out$str (":");
	call out$str (NL);
	call out$str (prose_string);
	call out$str (NL);
	call out$str (NL);
	call out$str (NL);

	if out$len() + length(info) > sys_info$max_seg_size * CHARS_PER_WORD then do;
							/* handle overflow of info seg by 	*/
							/* writing new data into a new 	*/
							/* permanent segment, leaving the old	*/
							/* segment untouched.		*/
	     call upd_print_err_ ( 0, 0, "Warning", "", entry, "",	/* print a warning to the effect	*/
		"^2xInfo segment is full^/(^a).
  New data placed in ^a.
  Please rename info segment as appropriate.",
		info_name, pathname_ (log_dir, INFO_NAME_WHEN_FULL));
	     on record_quota_overflow begin;
		call hcs_$delentry_seg (full_info_p, code);
		code = error_table_$rqover;
		go to rqo_full;
		end;
	     call initiate_file_$create (log_dir, INFO_NAME_WHEN_FULL, RW_ACCESS,
		full_info_p, created_sw, full_bc, code);
	     if code = 0 & ^created_sw then do;
		code = error_table_$namedup;
		call terminate_file_ (full_info_p, 0, TERM_FILE_TERM, ignore);
		end;
	     if code ^= 0 then do;
rqo_full:		call upd_task_err_ (code, 0, argp, entry, "Creating ^a.
Documentation for current installation lost.",
		     pathname_ (log_dir, INFO_NAME_WHEN_FULL));
		go to un_info;
		end;
	     call out$copy (full_info_p, full_bc);
	     revert record_quota_overflow;
	     call terminate_file_ (full_info_p, full_bc, TERM_FILE_TRUNC_BC_TERM, code);
	     if code ^= 0 then do;
		call upd_task_err_ (code, 0, argp, entry, "Setting bit count on ^a.
Documentation for current installation lost.",
		     pathname_ (log_dir, INFO_NAME_WHEN_FULL));
		go to un_info;
		end;
	     end;
	else do;
	     call out$str (info);
	     on record_quota_overflow begin;		/* restore info contents to its previous value 	*/
		call save$copy (info_p, info_bc);	/*   abandon built data, report the error.	*/
		call upd_task_err_ (error_table_$rqover, 0, argp, entry,
		   "Updating ^a.
Documentation for current installation lost.",
		     info_name);
		go to term_info;
		end;
	     info_p = header_p;
	     call out$copy (info_p, info_bc);
term_info:     revert record_quota_overflow;
	     call terminate_file_ (info_p, info_bc, TERM_FILE_TRUNC_BC, code);
	     if code ^= 0 then
		call upd_task_err_ (code, 0, argp, entry, "Writing ^a.
Segment may be damaged.",
		     info_name);
	     end;

un_info:	call terminate_file_ (info_p, 0, TERM_FILE_TERM, code);	/* terminate original and copy */
	call release_temp_segments_ ("upd_doc_task_", p, code);
	call upd_log_task_$unlock ((info_name), code);		/* unlock the lock */
	if code ^= 0 then
	     call upd_task_err_ (code, 0, argp, entry, "While unlocking ^a", info_name);



return:	if runsw then do;
	     Sfwd_done = ^Sfwd_done;				/* reset the forward done sw */
	     if substr(log_directory, 1, 1) = " " then
		log_directory = get_wdir_();
	     end;
	if logsw then					/* remember to detach I/O stream */
	     call ios_$detach ( "installation_log_", "", "", scode);
	return;

lock_err:	call upd_task_err_ ( code, 0, argp, entry, "Referencing ^R^a^B.", log_name);
	go to return;


/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* The following declarations and internal procedures provide a utility for  */
/* building up the new contents of an info segment in a temp segment.	       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	

    dcl   out_len		fixed bin(21),		/* data built so far.			*/
	out_ptr		ptr,
	out_seg		char(out_len) based (out_ptr);


out$copy: proc (target_ptr, target_bc);			/* proc to copy built data into info seg.	*/

    dcl	target_ptr	ptr,
	target_bc		fixed bin(24);

	target_ptr -> out_seg = out_seg;
	target_bc = length(out_seg) * BITS_PER_CHAR;
	return;


out$init:	entry (aout_ptr);				/* procedure to initialize temp seg to empty 	*/
						/* state (ie, no built data).			*/

    dcl	aout_ptr		ptr;

	out_ptr = aout_ptr;
	out_len = 0;
	return;


out$len:	entry returns(fixed bin(21));			/* function returning length of data built so far.*/

	return (out_len);


out$str:	entry (str);				/* procedure to add a string to end of built data.*/

    dcl	str		char(*);
    dcl	insert_point	fixed bin(21);

	insert_point = out_len + 1;
	out_len = out_len + length(str);
	substr(out_seg,insert_point) = str;
	return;

	end out$copy;



    dcl	save_len		fixed bin(21),		/* saved copy of previous info seg contents,	*/
	save_ptr		ptr,			/*   stored beyond end of built (new) data.	*/
	save_seg		char(save_len) based(save_ptr);

save$copy:
	proc (target_ptr, target_bc);			/* proc to copy saved data into info seg.	*/

    dcl	target_ptr	ptr,
	target_bc		fixed bin(24);

	target_ptr -> save_seg = save_seg;
	target_bc = length(save_seg) * BITS_PER_CHAR;
	return;

save$init:
	entry (asave_ptr);				/* procedure to initialize temp seg to empty 	*/
						/* state (ie, no built data).			*/

    dcl	asave_ptr		ptr;

	save_ptr = asave_ptr;
	save_len = 0;
	return;


save$str:						/* procedure to add data to saved info seg image. */
     	entry (str);

    dcl	str		char(*);
    dcl	insert_point	fixed bin(21);

	insert_point = save_len + 1;
	save_len = save_len + length(str);
	substr(save_seg,insert_point) = str;
	return;

	end save$copy;

/*			end of upd_doc_task_$write_prose					 */
/*  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  ==  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  */

/*  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  ==  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  */

doc_util_:   procedure (p, bitc, ptrp, Segname, unb_sw, i, bf_date, bfname, ec);
/* Procedure which returns information about referenced segment. Notably,
   name (or component names) and compile date ( or component compile dates ).	*/
%include symbol_block;
%include bind_map;
%include object_info;

dcl  1  oi  aligned like object_info;
dcl  p 		ptr,				/* ptr to segment                 IN  */
     bitc 	fixed bin(24),			/* bitcount of seg                IN  */
     ptrp 	ptr,				/* ptr to structure               IN  */
     Segname	char (32) aligned,			/* name of seg, we might need it  IN  */
     unb_sw 	bit (1),				/* = 0 if bound, = 1 if not bound OUT */
     i 		fixed bin,			/* number of components of        OUT */
     bf_date	char(24) aligned,			/* bindfile date updated	    OUT */
     bfname	char(32) aligned,			/* bindfile name		    OUT */
     ec 		fixed bin(35);			/* return error code              OUT */
dcl  1  struc  (1000)  aligned based (ptrp),		/* likeness of ext  structure          */
        2  segname  	char (32) aligned,		/* name of component         */
        2  dtc      	fixed bin (71);		/* compile time of component */
dcl  ( j, k ) 		fixed bin,
     (bmp, sblkp, mapp, q)	ptr,
     name			char (k) based (q),
     (addr, addrel, index, substr)	builtin;
dcl  object_info_$display 	entry (ptr, fixed bin (24), ptr, fixed bin (35)),
     get_bound_seg_info_ 	entry (ptr, fixed bin (24), ptr, ptr, ptr, fixed bin (35));

	     i = 1;
	     oi.version_number = 2;
	     call object_info_$display (p, bitc, addr (oi), ec);
	          if ec ^= 0 then do;		/* might not be an object segment  */
		     ptrp->struc(1).segname = Segname;
		     ptrp->struc(1).dtc = 0;
		     unb_sw = "1"b;
		     return;
		     end;
	     if oi.format.bound then do;			/* if bound then do this...   */
		unb_sw = "0"b;
		call get_bound_seg_info_ (p, bitc, addr (oi), bmp, sblkp, ec);
		     if ec ^= 0 then return;			/* bad error here  */
		do i = 1 to n_components while ( i < 1001 );	/* put upper limit on this */
		     q = addrel (sblkp, component (i).name.name_ptr);
		     k = fixed (component (i).name_lng, 18);
		     j = fixed (component (i).symb_start, 18);
		     mapp = addrel (oi.symbp, j);
		     ptrp->struc(i).dtc = mapp->sb.obj_creation_time;
		     ptrp->struc(i).segname = substr(name, 1, k);
		     end;
		i = i - 1;				/* do loops count one too many */
		if dcl_version > 1 then do;			/* report bindfile date if possible */
		     bf_date = bindmap.bf_date_up;
		     q = addrel (sblkp, bf_name_ptr);
		     k = fixed ( bf_name_lng, 18 );
		     if k ^= 0 then bfname = substr ( name, 1, k);
		     end;
		else do;
		     bf_date = " ";				/* earlier version */
		     k = index(Segname, " ");
		     bfname = substr(Segname, 1, k)||".bind";
		     end;
		return;
	          end;
	     ptrp->struc(1).segname = Segname;			/* for unbound segments, the following... */
	     ptrp->struc(1).dtc = oi.compile_time;
          end doc_util_;
/*  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  ==  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  */
/*  */
/*  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  ==  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  */

valid_lib_:	 procedure ( dn, lib);

/* Since directories can be referenced by several names, this procedure standardizes
   the system library names for documentation purposes and sets them to CAPS		     */

dcl
     dn 	char (168) aligned,				/* primary directory name       IN */
     lib 	char (168) aligned,				/* library name (or directory)  OUT */
     lb   char (32) aligned,
     i 	fixed bin;

dcl n_root_libs    fixed bin;

dcl root_libs (27) char (32) aligned init (
	"standard", "system_library_standard", "sss", "SSS",
	"system_library_dev",
	"system_library_tools", "tools", "t",
	"system_library_languages", "lang",
	"system_library_auth_maint", "auth_maint", "am", "aml",
	"installation_maintained_library", "iml", "IML",
	"system_library_unbundled", "unbundled", "unb",
	"network", "net", "system_library_network", "NET",
	 "system_library_obsolete", "obsolete", "obs" );

dcl LIBS (27) char (10) aligned init (
	"SSS", "SSS", "SSS", "SSS",
	"DEV",
	"TOOLS", "TOOLS", "TOOLS",
	"LANG", "LANG",
	"AML", "AML", "AML", "AML",
	"IML", "IML", "IML",
	"UNB", "UNB", "UNB",
	"NET", "NET", "NET", "NET",
	 "OBS", "OBS", "OBS" );

dcl n_odd_libs 	fixed bin;

dcl ODD_LIBS (10) char (10) init (
	"INCL",
	"INFO",
	"IIS",
	"RDMS",
	"RDMS_TOOLS",
	"RDMS_INCL",
	"RDMS_INFO",
	"HARD",
	"BOS",
	"MCS" );

	n_root_libs = dimension ( LIBS, 1 );
	n_odd_libs  = dimension ( ODD_LIBS, 1 );

	lb = substr (dn, 2, length(lb));			/* get rid of leading ">" */
	i = index ( lb , ">");
	if i ^= 0
	    then lb = substr ( lb, 1, (i-1));

	do i = 1 to n_root_libs;
	     if lb = root_libs(i)
		then go to got_lib;			/* look for system library */
	     end;
	i = 1;
	call MATCH_PATHS ( dn, ">ldd>include", code );		/* INCLUDE SEG? */
	if code = 0
	     then go to got_odd_lib;	

	i = 2;	
	call MATCH_PATHS ( dn, ">doc>info", code );		/* INFO SEG? */
	if code = 0
	     then go to got_odd_lib;	

	i = 3;	
	call MATCH_PATHS ( dn, ">doc>iis", code );		/* IML INFO SEG? */
	if code = 0
	     then go to got_odd_lib;	

	i = 4;	
	call MATCH_PATHS ( dn, ">lib>rdms", code );		/* RDMS SERVICE? */
	if code = 0
	     then go to got_odd_lib;	

	i = 5;	
	call MATCH_PATHS ( dn, ">lib>rdms>tools", code);		/* RDMS TOOLS? */
	if code = 0
	     then go to got_odd_lib;	

	i = 6;	
	call MATCH_PATHS ( dn, ">lib>rdms>include", code );	/* RDMS INCL? */
	if code = 0
	     then go to got_odd_lib;	

	i = 7;	
	call MATCH_PATHS ( dn, ">lib>rdms>info", code );		/* RDMS INFO? */
	if code = 0
	     then go to got_odd_lib;	

	i = 8;	
	call MATCH_PATHS (dn, ">ldd>hard>object", code );		/* HARDCORE */
	if code = 0					/*  .        */
	     then go to got_odd_lib;				/*  .        */
							/*  .        */
	call MATCH_PATHS (dn, ">ldd>hard>execution", code );	/* HARDCORE */
	if code = 0
	     then go to got_odd_lib;	

	i = 9;	
	call MATCH_PATHS (dn, ">ldd>bos>object", code );		/* BOS */
	if code = 0					/*  .  */
	     then go to got_odd_lib;				/*  .  */
							/*  .  */
	call MATCH_PATHS (dn, ">ldd>bos>execution", code );	/* BOS */
	if code = 0
	     then go to got_odd_lib;	

	i = 10;	
	call MATCH_PATHS (dn, ">ldd>comm>fnp>o", code );		/* MCS */
	if code = 0					/*  .  */
	     then go to got_odd_lib;				/*  .  */
							/*  .  */
	call MATCH_PATHS (dn, ">ldd>comm>fnp>execution", code);	/* MCS */
	if code = 0
	     then go to got_odd_lib;	

	code = 0;						/* zap error code - not needed */
no_lib:	lib = dn;						/* can't get a proper name for this one */
	return;						/* if not system lib, then leave it alone */

got_lib:	lib = LIBS(i);				/* if system lib, then set to CAPS */
	return;

got_odd_lib:
	lib = ODD_LIBS(i);				/* if known ODD lib, then set to CAPS */
	return;

     end valid_lib_;


MATCH_PATHS:	proc ( path1, path2, code );
					/* This procedure compares the unique id's of the   */
					/* two input pathnames to determine if they REALLY  */
					/* point to the same place.  If so, a 0 is returned */
					/* in the error code.  If not, a non-zero.          */

dcl
     path1	char(168) aligned,
     path2	char(168) aligned,
     code		fixed bin(35);

dcl
     UID1		bit(36),
     UID2		bit(36),
     dir_name	char(168) aligned,
     entry_name	char(32) aligned;

dcl
     expand_pathname_	entry (char(*) aligned, char(*) aligned, char(*) aligned, fixed bin(35));


	call expand_pathname_ (path1, dir_name, entry_name, code );
	if code ^= 0
	     then return;

	call upd_status_$long ( dir_name, entry_name, 1, addr(Stat), null, code );
	if code ^=0
	     then return;

	UID1 = Stat.uid;

	call expand_pathname_ ( path2, dir_name, entry_name, code );
	if code ^= 0
	     then return;

	call upd_status_$long ( dir_name, entry_name, 1, addr(Stat), null, code );
	if code ^= 0
	     then return;

	UID2 = Stat.uid;

	if UID1 = UID2
	     then code = 0;
	     else code = 1;

	return;

	end MATCH_PATHS;

%include access_mode_values;

%include terminate_file;

end upd_doc_task_;
