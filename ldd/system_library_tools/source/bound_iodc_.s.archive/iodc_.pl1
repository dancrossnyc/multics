/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


/* format: style2 */
iodc_:
     procedure;

/* This is the central procedure of the I/O Daemon Coordinator.
   *  It has various entries which are woken up by event calls.
*/

/* Coded by Robert S. Coren  in August 1973 */
/* Modified for the Access Isolation Mechanism by J. Stern, December 1974 */
/* Modified by J. Stern, 11/25/75 */
/* Modified by J. C. Whitmore, 4/78, to support max queues per request type and save more descriptor flags */
/* Modified by J. C. Whitmore, 7/78, for extended driver commands and queue priority functions */
/* Modified by J. C. Whitmore, 11/78, for version 3 iod_tables format and start using coord version numbers */
/* Modified by J. C. Whitmore, 5/80, to mark priority requests in the queue */
/* Modified by Benson I. Margulies 1980*12*29 for unaligned system_dir
   argument and variable iod_table segname. */
/* Modified January 1984 by C. Marker  Added probe as a valid command in test mode. */
/* Modified December 1984 by Keith Loepere to set dir_quota. */
/* Modified January 1985 by Keith Loepere to be smarter about same. */
/* Modified February 23, 1985 by C. Marker to use version 5 message segments */


/****^  HISTORY COMMENTS:
  1) change(87-02-04,Gilcrease), approve(87-02-04,MCR7610),
     audit(87-02-18,Farley), install(87-03-25,MR12.1-1013):
               Correct call to internal subroutine for the NEXT command.
  2) change(88-06-03,Brunelle), approve(88-06-03,MCR7911),
     audit(88-10-17,Wallman), install(88-10-28,MR12.2-1199):
     Upgraded to handle version 5 I/O daemon tables.
                                                   END HISTORY COMMENTS */

	dcl     a_ptr		 ptr;		/* pointer passed as argument to most entries */


/* External entries */

	dcl     aim_check_$equal	 entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
	dcl     aim_check_$greater_or_equal
				 entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
	dcl     com_err_		 entry options (variable);
	dcl     convert_ipc_code_	 entry (fixed bin (35));
	dcl     debug		 entry;
	dcl     delete_$path	 entry (char (*) aligned, char (*) aligned, bit (6), char (*), fixed bin (35));
	dcl     expand_pathname_	 entry (char (*) aligned, char (*) aligned, char (*) aligned, fixed bin (35));
	dcl     find_next_request_	 entry (fixed bin, ptr) returns (bit (1) aligned);
	dcl     find_next_request_$init
				 entry (ptr);
	dcl     free_oldest_request_$cleanup
				 entry;
	dcl     free_oldest_request_$force
				 entry;
	dcl     free_oldest_request_$init
				 entry (ptr);
	dcl     get_authorization_	 entry returns (bit (72) aligned);
	dcl     get_group_id_$tag_star entry returns (char (32));
	dcl     get_process_id_	 entry returns (bit (36) aligned);
	dcl     get_ring_		 entry returns (fixed bin (6));
	dcl     get_system_free_area_	 entry (ptr);
	dcl     hcs_$chname_seg	 entry (ptr, char (*) aligned, char (*), fixed bin (35));
	dcl     hcs_$create_branch_	 entry (char (*) aligned, char (*) aligned, ptr, fixed bin (35));
	dcl     hcs_$delentry_seg	 entry (ptr, fixed bin (35));
	dcl     hcs_$get_access_class	 entry (char (*) aligned, char (*), bit (72) aligned, fixed bin (35));
	dcl     hcs_$initiate_count	 entry (char (*) aligned, char (*) aligned, char (*), fixed bin (24),
				 fixed bin (2), ptr, fixed bin (35));
	dcl     hcs_$make_seg	 entry (char (*) aligned, char (*) aligned, char (*), fixed bin (5), ptr,
				 fixed bin (35));
	dcl     hcs_$set_ring_brackets entry (char (*) aligned, char (*) aligned, (3) fixed bin (3), fixed bin (35));
	dcl     hcs_$terminate_noname	 entry (ptr, fixed bin (35));
	dcl     hcs_$wakeup		 entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
	dcl     ioa_		 entry options (variable);
	dcl     ioa_$ioa_stream	 entry options (variable);
	dcl     ioa_$rsnnl		 entry options (variable);
	dcl     iod_overseer_$coord_ready
				 entry;
	dcl     iodc_$command_level	 entry;
	dcl     iodc_$free_device	 entry (ptr, fixed bin (35));
	dcl     iodc_message_	 entry (bit (3) aligned, fixed bin (35), char (*));
	dcl     iodc_message_$loud	 entry (bit (3) aligned, fixed bin (35), char (*));
	dcl     iodc_message_$init	 entry;
	dcl     iodd_$iodd_init	 entry (char (*) aligned, bit (1) aligned);
	dcl     iox_$control	 entry (ptr, char (*), ptr, fixed bin (35));
	dcl     iox_$get_line	 entry (ptr, ptr, fixed bin, fixed bin, fixed bin (35));
	dcl     ipc_$create_ev_chn	 entry (fixed bin (71), fixed bin (35));
	dcl     ipc_$delete_ev_chn	 entry (fixed bin (71), fixed bin (35));
	dcl     ipc_$decl_ev_call_chn	 entry (fixed bin (71), ptr, ptr, fixed bin, fixed bin (35));
	dcl     ipc_$drain_chn	 entry (fixed bin (71), fixed bin (35));
	dcl     ipc_$mask_ev_calls	 entry (fixed bin (35));
	dcl     ipc_$unmask_ev_calls	 entry (fixed bin (35));
	dcl     logout		 entry;
	dcl     match_request_id_	 entry (fixed bin (71), char (*) aligned) returns (bit (1) aligned);
	dcl     message_segment_$create
				 entry (char (*) aligned, char (*) aligned, fixed bin (35));
	dcl     message_segment_$delete
				 entry (char (*) aligned, char (*) aligned, fixed bin (35));
	dcl     message_segment_$delete_index
				 entry (fixed bin, bit (72) aligned, fixed bin (35));
	dcl     message_segment_$ms_acl_add
				 entry (char (*) aligned, char (*) aligned, ptr, fixed bin, fixed bin (35));
	dcl     message_segment_$read_message_index
				 entry (fixed bin, pointer, pointer, fixed bin (35));
	dcl     message_segment_$open	 entry (char (*) aligned, char (*) aligned, fixed bin, fixed bin (35));
	dcl     message_segment_$check_salv_bit_index
				 entry (fixed bin, bit (1) aligned, bit (1) aligned, fixed bin (35));
	dcl     message_segment_$update_message_index
				 entry (fixed bin, fixed bin (24), bit (72) aligned, ptr, fixed bin (35));
	dcl     new_proc		 entry;
	dcl     print_devices	 entry options (variable);
	dcl     privileged_make_seg_	 entry (char (*) aligned, char (*) aligned, char (*), fixed bin (5), ptr,
				 fixed bin (35));
	dcl     probe		 entry ();
	dcl     save_request_	 entry (ptr, ptr);
	dcl     save_request_$init	 entry (ptr);
	dcl     set_lock_$lock	 entry (bit (36) aligned, fixed bin, fixed bin (35));
	dcl     signal_		 entry (char (*));
	dcl     system_info_$access_ceiling
				 entry (bit (72) aligned);
	dcl     system_privilege_$initiate_count
				 entry (char (*) aligned, char (*) aligned, char (*), fixed bin (24),
				 fixed bin (2), ptr, fixed bin (35));
	dcl     timer_manager_$reset_alarm_wakeup
				 entry (fixed bin (71));
	dcl     unique_bits_	 entry returns (bit (70));
	dcl     unique_chars_	 entry (bit (*)) returns (char (15));
	dcl     unthread_descriptor_	 entry (ptr);
	dcl     unthread_descriptor_$init
				 entry (ptr);

/* Automatic storage */

	dcl     ack_chan		 fixed bin (71);
	dcl     area_flag		 fixed bin;
	dcl     auth		 bit (72) aligned;	/* process access authorization */
	dcl     bc		 fixed bin (24);	/* bit count */
	dcl     chan_name		 fixed bin (71);
	dcl     cmd		 char (24) aligned;
	dcl     code		 fixed bin (35);
	dcl     code2		 fixed bin (35);
	dcl     copy_ptr		 ptr;		/* pointer to copy of descriptor */
	dcl     copy_words		 fixed bin;	/* size of copy_template array */
	dcl     cwtp		 ptr;		/* ptr to coord_working_tables */
	dcl     dcx		 fixed bin;	/* index of a device_class entry */
	dcl     desc_off		 fixed bin (18);	/* offset of a request descriptor */
	dcl     desc_ptr		 ptr;		/* pointer to a request descriptor */
	dcl     dev_id		 char (32) aligned;
	dcl     dir_quota		 fixed bin;
	dcl     dr_ptr		 ptr;
	dcl     entry_type		 fixed bin;
	dcl     ev_info_ptr		 ptr;
	dcl     finish		 fixed bin;
	dcl     fwx		 fixed bin;
	dcl     i			 fixed bin;
	dcl     idtx		 fixed bin;	/* iod device table index */
	dcl     iodc_data_ptr	 ptr;
	dcl     iwtp		 ptr;		/* ptr to iod_working_tables */
	dcl     iwtrb		 (3) fixed bin (3); /* ring brackets for iod_working_tables */
	dcl     len		 fixed bin;
	dcl     line		 char (80);
	dcl     lwx		 fixed bin;
	dcl     mask_code		 fixed bin (35);	/* status code from ipc_$unmask_ev_calls */
	dcl     match_dir		 char (168) aligned;
	dcl     match_ent		 char (32) aligned;
	dcl     mdtx		 fixed bin;	/* minor device table index */
	dcl     message_len		 fixed bin;	/* length (in bits) of based_message */
	dcl     ms_id		 bit (72) aligned;	/* message id */
	dcl     nc		 fixed bin;
	dcl     new_driver_id	 char (32) aligned; /* person/project id of new driver */
	dcl     new_idx		 fixed bin;
	dcl     new_iwtp		 ptr;		/* ptr to new copy of iod_working_tables */
	dcl     next_ptr		 ptr;		/* pointer to next request descriptor */
	dcl     nseries		 fixed bin;	/* number of series in series_info */
	dcl     nx		 fixed bin;
	dcl     out_len		 fixed bin;	/* length of error message */
	dcl     out_msg		 char (200);
	dcl     proc_id		 bit (36) aligned;
	dcl     q			 fixed bin;
	dcl     q_idx		 fixed bin;	/* index of queue message seg. */
	dcl     q_name		 char (32) aligned;
	dcl     quota		 fixed bin;
	dcl     retry		 fixed bin;
	dcl     reqp		 ptr;
	dcl     seg_name		 char (32) aligned;
	dcl     sender_class	 char (32) aligned; /* name of device class of sender of driver signal */
	dcl     sender_device	 char (32) aligned; /* name of device run by sender of  a driver signal */
	dcl     sender_id		 char (32) aligned;
	dcl     seq_id		 fixed bin (35);
	dcl     series_id		 fixed bin (35);
	dcl     series_sw		 bit (1) aligned;
	dcl     sig_type		 fixed bin;
	dcl     sip		 ptr;		/* ptr to series_info structure */
	dcl     start		 fixed bin;
	dcl     subdir		 char (168) aligned;/* used to hold pathnames of subdirs of sysdir */
	dcl     system_high		 bit (72) aligned;	/* system high authorization */
	dcl     unbit		 bit (1) aligned;
	dcl     user_id		 char (32) aligned;
	dcl     wlp		 ptr;
	dcl     x			 fixed bin;

/* Internal static storage */

	dcl     areap		 ptr int static;	/* ptr to sys_area */
	dcl     driver_sig_chan	 fixed bin (71) int static;
						/* name of channel over which signals from */
						/* driver processes will come */
	dcl     static_idtp		 int static ptr;	/* pointer to io daemon device table */
	dcl     static_mdtp		 int static ptr;	/* pointer to minor device table */
	dcl     driver_cmd_chan	 fixed bin (71) int static;
						/* IPC channel for driver to signal commands which */
						/* are read through the coord_comm.ms seg */
	dcl     recursion_flag	 fixed bin int static;
						/* used to prevent recursive faults */
	dcl     scu_msg		 char (120) int static init ("");
	dcl     sysdir		 char (168) aligned int static;
	dcl     testing		 bit (1) int static;
	dcl     quit_flag		 bit (1) int static;
	dcl     err_label		 label int static;
	dcl     return_label	 label int static;	/* for returning in test environment */

	dcl     comm_mseg_idx	 fixed bin int static;
						/* message segment index for coord_comm.ms */
	dcl     sysdir_len		 fixed bin int static;
						/* length of pathname in sysdir */
	dcl     sysdir_class	 bit (72) aligned int static;
						/* access class of sysdir */
	dcl     initialized		 bit (1) aligned int static;
						/* turned on when coord initialization is complete */
	dcl     coord_proc_id	 bit (36) int static;
						/* coordinator's process id */
	dcl     new_driver_series	 int static;	/* first sequence number for new driver */
	dcl     com_level		 fixed bin int static;
						/* command level depth */
	dcl     n_acl		 fixed bin int static;

/* External static */

	dcl     error_table_$action_not_performed
				 fixed bin (35) ext static;
	dcl     error_table_$bad_segment
				 fixed bin (35) ext static;
	dcl     error_table_$invalid_move_qmax
				 fixed bin (35) ext static;
	dcl     error_table_$noentry	 fixed bin (35) ext static;
	dcl     error_table_$namedup	 fixed bin (35) ext static;
	dcl     error_table_$pathlong	 fixed bin (35) ext static;
	dcl     error_table_$argerr	 fixed bin (35) ext static;
	dcl     error_table_$invalid_lock_reset
				 fixed bin (35) ext static;
	dcl     error_table_$segknown	 fixed bin (35) ext static;
	dcl     error_table_$request_not_recognized
				 fixed bin (35) ext static;
	dcl     error_table_$ai_above_allowed_max
				 fixed bin (35) ext static;
	dcl     error_table_$ai_restricted
				 fixed bin (35) ext static;

	dcl     iox_$user_input	 ptr ext;
	dcl     iox_$user_io	 ptr ext static;
%page;

/* Constants */

	dcl     io_coordinator_version char (8) int static options (constant) init ("3.2");
	dcl     driver_command	 fixed bin int static options (constant) init (100);
	dcl     id		 char (16) int static options (constant) init ("io_coordinator");
	dcl     new_driver		 fixed bin int static options (constant) init (200);
	dcl     priority		 fixed bin int static options (constant) init (2);
	dcl     NL		 char (1) int static options (constant) init ("
");


/* Conditions */

	dcl     any_other		 condition;
	dcl     quit		 condition;
	dcl     cleanup		 condition;
	dcl     area		 condition;

/* these guys are just used to pass addresses to ipc_$decl_ev_call_chn */

	dcl     free_oldest_request_$free_oldest_request_
				 fixed bin ext static;
	dcl     iodc_$new_driver	 fixed bin ext static;
	dcl     iodc_$driver_signal	 fixed bin ext static;
	dcl     iodc_$driver_command	 fixed bin ext static;

/* Based storage */

	dcl     based_message	 bit (message_len) aligned based;
	dcl     copy_template	 (copy_words) fixed bin based;
						/* for segment copying */
	dcl     sys_area		 area (65560) based (areap);
						/* system area */

/* Builtins */

	dcl     (addr, before, divide, empty, fixed, length, ltrim, max, mod, null, ptr, rel, rtrim, stac, string,
	        substr, unspec)	 builtin;
%page;

/* Structure declarations */

	dcl     1 ev_info		 based (ev_info_ptr),
		2 channel		 fixed bin (71),
		2 message		 fixed bin (71),
		2 sending_proc	 bit (36);

	dcl     1 acl		 (3) aligned int static,
		2 ac_name		 char (32),
		2 modes		 bit (36),
		2 pad		 bit (36) init ((3) (36)"0"b),
		2 code		 fixed bin (35);

	dcl     1 dir_acl		 (2) aligned int static,
		2 ac_name		 char (32),
		2 modes		 bit (36),
		2 code		 fixed bin (35);

	dcl     1 driver_mmi	 aligned like mseg_message_info;

	dcl     1 msg_mmi		 aligned like mseg_message_info;

	dcl     1 coord_static	 int static aligned like iodc_static;
						/* space for iodc_static */

	dcl     1 branch_info	 aligned int static like create_branch_info;

	dcl     1 ms_acl		 aligned,		/* for setting extended acl on message segment */
		2 acc_name	 char (32),
		2 mode		 bit (36),
		2 exmode		 bit (36),
		2 reterr		 fixed bin (35);

	dcl     1 series_info	 (nseries) aligned based (sip),
						/* for restart_status command */
		2 count		 fixed bin,
		2 first		 fixed bin,
		2 last		 fixed bin,
		2 dcx		 fixed bin;

	dcl     1 option		 aligned,		/* control options for the next_req driver request */
		2 dev		 bit (1) unal,
		2 q		 bit (1) unal,
		2 user		 bit (1) unal,
		2 id		 bit (1) unal,
		2 et		 bit (1) unal,
		2 pn		 bit (1) unal,
		2 pad		 bit (30) unal;

%page;

iodc_init:
     entry (dir, test_bit, test_iod_tables);

/* Main entry point for I/O Coordinator */
/* Initializes I/O Coordinator and waits for drivers.
*/

	dcl     dir		 char (*);
	dcl     test_bit		 bit (1) aligned;
	dcl     test_iod_tables	 char (*);

	call iodc_message_$init ();			/* set up stream attachments */

	call ioa_ ("I/O Coordinator Version: ^a", io_coordinator_version);

	sysdir = dir;
	sysdir_len = length (rtrim (sysdir));
	if sysdir_len > 136
	then do;
		call com_err_ (error_table_$pathlong, "iodc_init", "Cannot append max size device name to ^a.",
		     sysdir);
		go to forget_it;
	     end;

	subdir = substr (sysdir, 1, sysdir_len) || ">coord_dir";
						/* construct pathname of coord_dir */

	testing = test_bit;
	return_label = back;
	err_label = forget_it;
	stat_p = addr (coord_static);

	call get_system_free_area_ (areap);		/* set this once for temp allocations */

	new_driver_series = 0;
	com_level = -1;



	initialized = "0"b;
	quit_flag = "0"b;
	on quit call quit_handler;
	call iox_$control (iox_$user_io, "quit_enable", null, code);

	recursion_flag = 0;
	on cleanup call clean_up;			/* unmask, drop timer, etc. */
	on any_other call iodc_handler;

/* set up acl for data segs and directories */

	n_acl = 2;

	dir_acl (1).ac_name, acl (1).ac_name = get_group_id_$tag_star ();
						/* make sure this process always has access */
	dir_acl (1).modes, acl (1).modes = "111"b;

	dir_acl (2).ac_name, acl (2).ac_name = "*.*.*";
	dir_acl (2).modes, acl (2).modes = "100"b;

/* First thing to do is check the saved list left by the last
   coordinator for segments to be deleted.  To do this we need
   two data bases:  req_desc_seg, and request_seg.
*/

	call free_oldest_request_$init (stat_p);
	call unthread_descriptor_$init (stat_p);

	call initiate (subdir, "req_desc_seg", iodc_static.descr_seg_ptr, code);
	if code ^= 0
	then
no_purge:
	     call com_err_ (0, "iodc_init",
		"Warning -- Cannot get old saved list.  Some deletions may not be performed.");
	else do;
		call initiate (subdir, "request_seg", iodc_static.req_seg_ptr, code);
		if code ^= 0
		then go to no_purge;

		iodc_static.save_first_req_p = addr (req_desc_seg.first_saved);
		iodc_static.first_req_done = req_desc_seg.first_saved;
		do while (iodc_static.first_req_done ^= 0);
		     call free_oldest_request_$cleanup;
		end;
	     end;

/* delete coord_dir to make sure it gets recreated with proper access class */

	call delete_$path (sysdir, "coord_dir", "101101"b, "", code);
	if code ^= 0
	then if code ^= error_table_$noentry
	     then do;
		     call com_err_ (code, "iodc_init", "Deleting coord_dir");
		     go to forget_it;
		end;


/* get access class of sysdir and process authorization */

	call hcs_$get_access_class (sysdir, "", sysdir_class, code);
	if code ^= 0
	then do;
		call com_err_ (code, "iodc_init", sysdir);
		go to forget_it;
	     end;

	auth = get_authorization_ ();
	if ^testing
	then do;
		call system_info_$access_ceiling (system_high);
		if ^aim_check_$equal (system_high, auth)
		then call com_err_ (0, "iodc_init", "Warning -- Coordinator authorization is not ""system_high"".");
	     end;

/* make a subdirectory to hold the coordinator's writable data segs (i.e. segs modified after initialization) */
/* this subdirectory will be upgraded (if necessary) to the coordinator's authorization */
/* if upgraded, a quota of 250/25 records will be assigned */

	branch_info.version = create_branch_version_2;	/* initialize branch info structure */
	branch_info.dir_sw = "1"b;
	branch_info.copy_sw = "0"b;
	branch_info.chase_sw = "1"b;
	branch_info.priv_upgrade_sw = "0"b;
	branch_info.mbz1 = ""b;
	branch_info.mode = "101"b;
	branch_info.mbz2 = ""b;
	branch_info.rings (1), branch_info.rings (2), branch_info.rings (3) = get_ring_ ();
	branch_info.userid = acl (1).ac_name;
	branch_info.bitcnt = 0;

	call make_dir ("coord_dir", auth, 250, 25, code);
	if code ^= 0
	then do;
		call com_err_ (code, "iodc_init", "^a>^a", sysdir, "coord_dir");
		go to forget_it;
	     end;

/* set up data segments residing in sysdir */

	seg_name = "iodc_data";
	call make (sysdir, seg_name, iodc_data_ptr, code);
	if code ^= 0
	then do;
no_init:
		call com_err_ (code, "iodc_init", "Could not initiate(create) ^a", seg_name);
forget_it:
		call ioa_$ioa_stream ("error_output", "Process cannot be initialized.");
		return;
	     end;

	if test_bit & test_iod_tables ^= ""
	then seg_name = test_iod_tables;
	else seg_name = "iod_tables";			/* get ptr to most recently compiled iod tables */
	call initiate (sysdir, seg_name, ithp, code);
	if code ^= 0
	then go to no_init;
	copy_words = divide (bc, 36, 24, 0);		/* remember number of words */

	if iod_tables_hdr.version ^= IODT_VERSION_5
	then do;
		call com_err_ (0, "iodc_init", "Wrong version number for iod_tables.");
		go to forget_it;
	     end;

/* now get the last iod_working_tables used to see if anything has changed. */
	iwtp = null;
	seg_name = "iod_working_tables";
	call initiate (sysdir, seg_name, iwtp, code);
	if code ^= 0
	then if code = error_table_$noentry
	     then go to update;
	     else go to no_init;

/* If version number has changed, iod_working_tables is to be ignored.
   Fake a new table update.
   If the version numbers are the same, then see if iod_tables is newer.
   If so update the working tables with the new tables */
	if iwtp -> iod_tables_hdr.version ^= IODT_VERSION_5
	then go to update;
	if iod_tables_hdr.date_time_compiled > iwtp -> iod_tables_hdr.date_time_compiled
	then do;					/* new tables, must update the working tables */
update:
		seg_name = unique_chars_ (unique_bits_ ());
						/* create unique name segment */
		call make (sysdir, seg_name, new_iwtp, code);
		if code ^= 0
		then go to no_init;

		iwtrb (1) = branch_info.rings (1);	/* set up ring brackets for working tables */
		iwtrb (2), iwtrb (3) = 5;		/* make available through ring 5 */
		call hcs_$set_ring_brackets (sysdir, seg_name, iwtrb, code);
		if code ^= 0
		then do;
			call com_err_ (code, "iodc_init", "Attempting to set ring brackets of ^a", seg_name);
			go to forget_it;
		     end;

		new_iwtp -> copy_template = ithp -> copy_template;
						/* copy in iod_tables */

		if iwtp ^= null
		then do;
			call hcs_$delentry_seg (iwtp, code);
						/* delete old working tables */
			if code ^= 0
			then do;
				call com_err_ (code, "iodc_init", "Attempting to delete iod_working_tables");
				go to forget_it;
			     end;
		     end;
		call hcs_$chname_seg (new_iwtp, seg_name, "iod_working_tables", code);
						/* change name of new working tables */
		if code ^= 0
		then do;
			call com_err_ (code, "iodc_init", "Attempting to change name of iod_working_tables");
			go to forget_it;
		     end;
		iwtp = new_iwtp;
	     end;

	call hcs_$terminate_noname (ithp, code);


/* set up segments in "coord_dir" */

	seg_name = "coord_working_tables";		/* make coordinator's private copy of iod_tables */
	call make (subdir, seg_name, cwtp, code);
	if code ^= 0
	then go to no_init;
	cwtp -> copy_template = iwtp -> copy_template;

	call hcs_$terminate_noname (iwtp, code);

	seg_name = "waiting_list";
	call make (subdir, seg_name, iodc_static.wait_list_ptr, code);
	if code ^= 0
	then go to no_init;

	seg_name = "req_desc_seg";
	call make (subdir, "req_desc_seg", iodc_static.descr_seg_ptr, code);
	if code ^= 0
	then go to no_init;
	descr_area = empty;

	seg_name = "request_seg";
	call make (subdir, "request_seg", iodc_static.req_seg_ptr, code);
	if code ^= 0
	then go to no_init;
	req_area = empty;


/* initialize table pointers and other static info */

	static_idtp = ptr (cwtp, cwtp -> iod_tables_hdr.device_tab_offset);
	static_mdtp = ptr (cwtp, cwtp -> iod_tables_hdr.minor_device_tab_offset);
	text_strings_ptr = ptr (cwtp, cwtp -> iod_tables_hdr.text_strings_offset);
	iodc_static.qgtp = ptr (cwtp, cwtp -> iod_tables_hdr.q_group_tab_offset);
	iodc_static.dctp = ptr (cwtp, cwtp -> iod_tables_hdr.dev_class_tab_offset);
	iodc_static.time_interval = cwtp -> iod_tables_hdr.grace_time;
	iodc_static.max_q = cwtp -> iod_tables_hdr.max_queues;
	iodc_static.first_req_done, iodc_static.last_req_done = 0;
	iodc_static.save_first_req_p = addr (req_desc_seg.first_saved);
	req_desc_seg.first_saved = 0;

/* set up message segment for new driver messages */

	call message_segment_$delete (sysdir, "coord_comm.ms", code);
						/* delete old message seg, if any */
	if code ^= 0
	then if code ^= error_table_$noentry
	     then do;				/* could not delete it */
		     call com_err_ (code, "iodc_init", "Attempting to delete coord_comm.ms");
		     go to forget_it;
		end;

	seg_name = "coord_comm.ms";			/* for error message */
	call message_segment_$create (sysdir, "coord_comm.ms", code);
						/* create new message seg */
	if code ^= 0
	then go to no_init;				/* give up */
	call message_segment_$open (sysdir, "coord_comm.ms", comm_mseg_idx, code);
						/* open it */
	if code ^= 0
	then go to no_init;				/* give up */

/* place the userid for each queue group on the message segment acl */

	ms_acl.mode = "101"b;			/* want "rw" real access */
	ms_acl.exmode = "1"b;			/* want "a" extended access */

	do q = 1 to iodc_static.qgtp -> q_group_tab.n_q_groups;
						/* loop through queue groups */
	     qgtep = addr (iodc_static.qgtp -> q_group_tab.entries (q));
						/* get ptr to q group entry */
	     if qgte.driver_id ^= acl (1).ac_name
	     then do;				/* don't change coord's access */
		     ms_acl.acc_name = qgte.driver_id;
		     call message_segment_$ms_acl_add (sysdir, "coord_comm.ms", addr (ms_acl), 1, code);
		     if code ^= 0
		     then do;
			     if code = error_table_$argerr
			     then code = ms_acl.reterr;
			     call com_err_ (code, "iodc_init", "Adding to acl of coord_comm.ms");
			     go to forget_it;
			end;
		end;

	     qgte.open = 0;				/* initialize this while we're here */
	end;

/* initialize other coordinator procedures */

	call find_next_request_$init (stat_p);
	call save_request_$init (stat_p);

/*  free all devices, i.e. delete all device dirs and segs */

	do idtx = 1 to static_idtp -> iod_device_tab.n_devices;
	     idtep = addr (static_idtp -> iod_device_tab.entries (idtx));
	     idte.process_id = ""b;
	     call iodc_$free_device (idtep, code);
	     if code ^= 0
	     then /* failed to delete device directory */
		go to forget_it;
	end;


/* initialize the device class table */

	do dcx = 1 to iodc_static.dctp -> dev_class_tab.n_classes;
	     dctep = addr (iodc_static.dctp -> dev_class_tab.entries (dcx));
	     dcte.pending_request, dcte.restart_req = 0;
	end;

/* change initial acl so it will work for driver segs. */

	n_acl = 3;
	acl (n_acl).modes = "101"b;


/* set up drivers' event channels */
/* new-driver signal will have lower priority so coming-up message */
/* can't beat previous logout message for same device */

	call ipc_$create_ev_chn (chan_name, code);
	if code ^= 0
	then do;
no_ipc:
		call convert_ipc_code_ (code);
		call com_err_ (code, "iodc_init", "IPC error setting up event channels.");
		go to forget_it;
	     end;
	call ipc_$decl_ev_call_chn (chan_name, addr (iodc_$new_driver), null, 3, code);
	if code ^= 0
	then go to no_ipc;
	iodc_data.init_event_channel = chan_name;

	call ipc_$create_ev_chn (chan_name, code);
	if code ^= 0
	then go to no_ipc;
	call ipc_$decl_ev_call_chn (chan_name, addr (iodc_$driver_signal), null, 1, code);
	if code ^= 0
	then go to no_ipc;
	driver_sig_chan = chan_name;

	call ipc_$create_ev_chn (chan_name, code);
	if code ^= 0
	then go to no_ipc;
	call ipc_$decl_ev_call_chn (chan_name, addr (iodc_$driver_command), null, 2, code);
	if code ^= 0
	then go to no_ipc;
	driver_cmd_chan = chan_name;

/* and timer channel for freeing "saved" requests */

	call ipc_$create_ev_chn (iodc_static.timer_chan, code);
	if code ^= 0
	then go to no_ipc;
	call ipc_$decl_ev_call_chn (iodc_static.timer_chan, addr (free_oldest_request_$free_oldest_request_), null, 1,
	     code);
	if code ^= 0
	then go to no_ipc;


/* OK, let the show begin ... */

	coord_proc_id, iodc_data.proc_id = get_process_id_ ();

	initialized = "1"b;
	call iodc_message_ ("010"b, 0, "I/O Coordinator initialized");
	call iod_overseer_$coord_ready;		/* drivers can now get started */
	call iodc_$command_level;


back:
	call clean_up;
	return;					/* return to overseer (only in test mode) */


clean_up:
     proc;

	call timer_manager_$reset_alarm_wakeup (iodc_static.timer_chan);
						/* through with this */
	call ipc_$drain_chn (iodc_static.timer_chan, code);
	call iox_$control (iox_$user_io, "start", null (), code);
	call ipc_$unmask_ev_calls (code2);
	call ipc_$delete_ev_chn (iodc_static.timer_chan, code2);
	call ipc_$delete_ev_chn (driver_cmd_chan, code2);
	call ipc_$delete_ev_chn (driver_sig_chan, code2);
	call ipc_$delete_ev_chn (iodc_data.init_event_channel, code2);
	return;

     end clean_up;
%page;

make:
     proc (dirname, entname, p, code);

	dcl     dirname		 char (*) aligned;
	dcl     entname		 char (*) aligned;
	dcl     p			 ptr;
	dcl     code		 fixed bin (35);
	dcl     hcs_$replace_acl	 entry (char (*) aligned, char (*) aligned, ptr, fixed bin, bit (1) aligned,
				 fixed bin (35));

	if testing
	then call hcs_$make_seg (dirname, entname, "", 01111b, p, code);
	else call privileged_make_seg_ (dirname, entname, "", 01111b, p, code);
	if code ^= 0
	then if code ^= error_table_$namedup
	     then if code ^= error_table_$segknown
		then return;
	call hcs_$replace_acl (dirname, entname, addr (acl), n_acl, "0"b, code);

	return;
     end;

/* ********************************************************** */

make_dir:
     proc (ename, aclass, aquota, adir_quota, code);

	dcl     ename		 char (*) aligned;
	dcl     aclass		 bit (72) aligned;	/* access class of directory */
	dcl     aquota		 fixed bin;	/* quota on directory */
	dcl     adir_quota		 fixed bin;
	dcl     code		 fixed bin (35);
	dcl     hcs_$replace_dir_acl	 entry (char (*) aligned, char (*) aligned, ptr, fixed bin, bit (1),
				 fixed bin (35));

	branch_info.access_class = aclass;
	if aim_check_$equal (aclass, sysdir_class)
	then branch_info.quota, branch_info.dir_quota = 0;
	else do;
		branch_info.quota = aquota;		/* need quota if dir is upgraded */
		branch_info.dir_quota = adir_quota;
	     end;

create_branch:
	call hcs_$create_branch_ (sysdir, ename, addr (branch_info), code);
	if code = error_table_$invalid_move_qmax
	then if branch_info.dir_quota = 0
	     then return;
	     else do;				/* try create without dir quota */
		     branch_info.dir_quota = 0;
		     go to create_branch;
		end;
	if code ^= 0
	then return;

	call hcs_$replace_dir_acl (sysdir, ename, addr (dir_acl), 2, "0"b, code);
     end make_dir;

/* ********************************************************** */

initiate:
     proc (dir, ent, p, code);

	dcl     dir		 char (*) aligned;
	dcl     ent		 char (*) aligned;
	dcl     p			 ptr;
	dcl     code		 fixed bin (35);

	if testing
	then /* don't use system_privilege_ in test mode */
	     call hcs_$initiate_count (dir, ent, "", bc, 0, p, code);
	else call system_privilege_$initiate_count (dir, ent, "", bc, 0, p, code);

	if code = error_table_$segknown
	then code = 0;

     end initiate;
%page;

driver_signal:
     entry (a_ptr);

/* This entry receives the wakeup from a driver process that has
   *  just finished a request (or otherwise become ready for work),
   *  or has just received a "restart", "save", or "logout" command.
   *  The code in the event message will tell us which.
*/

	mask_code = -1;
	on cleanup
	     begin;
		if mask_code = 0
		then call ipc_$unmask_ev_calls (code2);
	     end;
	call ipc_$mask_ev_calls (mask_code);

	ev_info_ptr = a_ptr;
	err_label = iodc_return;
	proc_id = ev_info.sending_proc;

/* find out which driver sent signal and make sure it's legitimate */

	mdtx = addr (ev_info.message) -> ev_msg.minor_dev_index;
						/* get minor device index */

	call identify_sender (code);
	if code ^= 0
	then go to bad_signal;			/* reject the signal */

/* find out what kind of signal it was, and branch accordingly */

	sig_type = addr (ev_info.message) -> ev_msg.code;
	if sig_type < 0 | sig_type > 5		/* Uh oh */
	then do;
		call ioa_$rsnnl ("Driver signal rejected from device ^a (bad code: ^d)", out_msg, out_len,
		     sender_device, sig_type);
bad_signal:
		call iodc_message_ ("101"b, 0, out_msg);
		go to iodc_return;
	     end;

	go to sig_label (sig_type);


/* **************************************************** */

identify_sender:
     proc (code);

	dcl     code		 fixed bin (35);

	if mdtx < 0 | mdtx > static_mdtp -> minor_device_tab.n_minor
						/* a bum index */
	then do;
		out_msg = "Driver signal rejected (bad device index)";
		code = error_table_$request_not_recognized;
		return;
	     end;

	mdtep = addr (static_mdtp -> minor_device_tab.entries (mdtx));
						/* get ptr to minor device entry */
	idtx = mdte.major_index;			/* get major device index for this minor device */
	idtep = addr (static_idtp -> iod_device_tab.entries (idtx));
						/* get ptr to major device entry */

	if idte.process_id ^= ev_info.sending_proc	/* whoever sent signal does not own the device */
	then do;
		out_msg = "Driver signal rejected (device not assigned to process)";
		code = error_table_$request_not_recognized;
		return;
	     end;

	if mdte.active ^= 1
	then do;					/* device isn't active, cannot accept signal */
		out_msg = "Driver signal rejected (minor device not active)";
		code = error_table_$request_not_recognized;
		return;
	     end;

	dr_ptr = mdte.driver_ptr;			/* pick up ptr to driver status segment */
	dcx = mdte.dev_class_index;			/* pick up index of device class entry */
	dctep = addr (iodc_static.dctp -> dev_class_tab.entries (dcx));
						/* get ptr to device class entry */
	qgtep = addr (iodc_static.qgtp -> q_group_tab.entries (dcte.qgte_index));

	sender_device = get_device_name ();		/* keep signal sender's device name handy */
	sender_class = get_class_name ();		/* and device class name too */

	code = 0;
	return;

     end identify_sender;

/* ********************************************************** */

get_device_name:
     proc returns (char (32) aligned);

	dcl     name		 char (32) aligned;

	if idte.last_minor > idte.first_minor /* if more than one minor */ | idte.dev_id ^= mdte.dev_id
	then /* or if minor name is different, add it on */
	     name = rtrim (idte.dev_id) || "." || mdte.dev_id;
	else name = idte.dev_id;
	return (name);

     end get_device_name;


/* ********************************************************** */

get_class_name:
     proc returns (char (32) aligned);

	dcl     name		 char (32) aligned;

	if qgte.last_dev_class > qgte.first_dev_class /* if more than one device class */ | qgte.name ^= dcte.id
	then /* or if device class name is different, add it on */
	     name = rtrim (qgte.name) || "." || dcte.id;
	else name = qgte.name;
	return (name);

     end get_class_name;
%page;

sig_label (0):
sig_label (1):					/*
 Come here on normal driver signal.
 (sig_type = 0) => driver done with request
 (sig_type = 1) => driver wants a new request (and is done with any current request) */
						/* find out if driver just finished a request */
	if mdte.current_request ^= 0
	then do;

/* yes, we've got a descriptor */
/* copy updated portions */

		desc_ptr = ptr (iodc_static.descr_seg_ptr, mdte.current_request);
		copy_ptr = addr (dr_ptr -> driver_status.descriptor);
		if ^(copy_ptr -> request_descriptor.finished | copy_ptr -> request_descriptor.cancelled)
		then go to iodc_return;		/* don't screw up active request */
		call update_descriptor;

		mdte.current_request = 0;

/* if it hasn't been saved yet, save it */

		call save_request_ (desc_ptr, dctep);
	     end;

	if sig_type = 0
	then go to iodc_return;			/* driver doesn't want a new request */

/* is there a request hanging? */

	if dcte.pending_request ^= 0
	then do;
		desc_ptr = ptr (iodc_static.descr_seg_ptr, dcte.pending_request);
		dcte.pending_request = desc_ptr -> request_descriptor.next_pending;
	     end;


/* are we in a restart cycle ? */

	else if dcte.restart_req ^= 0
	then do;					/* in restart cycle */
		desc_ptr = ptr (iodc_static.descr_seg_ptr, dcte.restart_req);
		call unthread_descriptor_ (desc_ptr);	/* will be moved to end of saved list */
		desc_ptr -> request_descriptor.restarted = "1"b;
		desc_ptr -> request_descriptor.prev_seq_id = desc_ptr -> request_descriptor.seq_id;
		dcte.restart_req = 0;		/* reset indicator til we find another */

/* 	if restarting a series, find the next request to restart next time around */

		if desc_ptr -> request_descriptor.series_restart
		then do;
			series_id = divide (desc_ptr -> request_descriptor.seq_id, 10000, 35, 0);
			desc_off = desc_ptr -> request_descriptor.next_done;
			do while (desc_off ^= 0);	/* look for next request to restart */
			     next_ptr = ptr (iodc_static.descr_seg_ptr, desc_off);
						/* if this is part of the series */
			     if divide (next_ptr -> request_descriptor.seq_id, 10000, 35, 0) = series_id
			     then do;
				     next_ptr -> request_descriptor.saved = "1"b;
						/* should be on already, make sure */
				     next_ptr -> request_descriptor.series_restart = "1"b;
						/* so should this */
				     dcte.restart_req = desc_off;
						/* we'll do this one next time */
				     desc_off = 0;	/* drop out of loop */
				end;

			     else desc_off = next_ptr -> request_descriptor.next_done;
			end;
		     end;
	     end;


	else do;

/* Now we must get a brand new request from one of the queues */

		area_flag = 0;			/* indicates area condition not raised yet */
		on area call area_handler;
		allocate request_descriptor in (descr_area) set (desc_ptr);
		revert area;

		unspec (desc_ptr -> request_descriptor) = ""b;

		if ^find_next_request_ (dcx, desc_ptr)
		then do;

/* we didn't get one */

			free desc_ptr -> request_descriptor in (descr_area);

			if dr_ptr -> driver_status.acknowledge
			then do;			/* must tell driver anyway */
				call hcs_$wakeup (idte.process_id, dr_ptr -> driver_status.driver_chan, 0, code);
				if code ^= 0
				then call check_wakeup_code (code);
			     end;

			go to iodc_return;
		     end;

	     end;


/* Okay, let's send it! */

	desc_ptr -> request_descriptor.seq_id = mdte.seq_id + 1;
	desc_ptr -> request_descriptor.finished = "0"b;

	addr (dr_ptr -> driver_status.descriptor) -> request_descriptor = desc_ptr -> request_descriptor;
	addr (dr_ptr -> driver_status.descriptor) -> request_descriptor.saved = "0"b;
						/* see if driver wants it saved */
	message_len = desc_ptr -> mseg_message_info.ms_len;
	addr (dr_ptr -> driver_status.message) -> based_message = desc_ptr -> mseg_message_info.ms_ptr -> based_message;

	desc_off = fixed (rel (desc_ptr), 18);

	if ^stac (addr (dr_ptr -> driver_status.request_pending), coord_proc_id)
	then do;					/* driver no longer wants request */
make_pending:
		desc_ptr -> request_descriptor.next_pending = dcte.pending_request;
		dcte.pending_request = desc_off;
		go to iodc_return;
	     end;

	call hcs_$wakeup (idte.process_id, dr_ptr -> driver_status.driver_chan, 0, code);
	if code ^= 0
	then do;
		call check_wakeup_code (code);
		go to make_pending;
	     end;

	mdte.current_request = desc_off;
	if mod (desc_ptr -> request_descriptor.seq_id, 10000) = 9999
	then do;
new_series:
		new_driver_series = new_driver_series + 10000;
		mdte.seq_id = new_driver_series;
		call ioa_$rsnnl ("Device ^a switched to series ^d.", out_msg, out_len, sender_device,
		     new_driver_series);
		call iodc_message_ ("100"b, 0, out_msg);
	     end;
	else mdte.seq_id = desc_ptr -> request_descriptor.seq_id;

/* all done, go home */

iodc_return:
	call ipc_$unmask_ev_calls (code);
	recursion_flag = 0;
	return;


/* ***************************************************** */


/* This procedure updates a few items in the coord's
   copy of a descriptor from the driver's copy. */

update_descriptor:
     proc;

	desc_ptr -> request_descriptor.driver_data = copy_ptr -> request_descriptor.driver_data;
	desc_ptr -> request_descriptor.cancelled = copy_ptr -> request_descriptor.cancelled;
	desc_ptr -> request_descriptor.dont_delete = copy_ptr -> request_descriptor.dont_delete;
	if ^desc_ptr -> request_descriptor.saved
	then /* if still in queue we may keep it there */
	     desc_ptr -> request_descriptor.keep_in_queue = copy_ptr -> request_descriptor.keep_in_queue;
	desc_ptr -> request_descriptor.saved =
	     /* hold request if saved or deferred by driver command */ copy_ptr -> request_descriptor.saved
	     | copy_ptr -> request_descriptor.keep_in_queue;

     end update_descriptor;
%page;

sig_label (2):
	series_sw = "1"b;
	ack_chan = 0;
	seq_id = addr (ev_info.message) -> ev_msg.seq_id;
	go to restart_or_save;

sig_label (3):
	series_sw = "1"b;
	ack_chan = 0;
	seq_id = addr (ev_info.message) -> ev_msg.seq_id;


restart_or_save:					/*
   Here for "restart _n"(2) or "save _n"(3) command given to driver. For
   "restart" we will record that requests for the device class have been
   restarted, and look for the request from which to restart. For "save" we
   will simply scan through setting "saved" bit in all requests done of 
   specified series. */

	if sig_type = save
	then cmd = "Save";				/* set up for messages */
	else cmd = "Restart";

	call ioa_$rsnnl ("^a command received from device ^a", out_msg, out_len, cmd, idte.dev_id);
	call iodc_message_ ("110"b, 0, out_msg);

	series_id = divide (seq_id, 10000, 35, 0);

	do desc_off = iodc_static.first_req_done repeat desc_ptr -> request_descriptor.next_done while (desc_off ^= 0);
	     desc_ptr = ptr (iodc_static.descr_seg_ptr, desc_off);

	     if divide (desc_ptr -> request_descriptor.seq_id, 10000, 35, 0) = series_id
	     then /* right series? */
		if desc_ptr -> request_descriptor.seq_id >= seq_id
		then /* right request or next one in series? */
		     if desc_ptr -> request_descriptor.dev_class_index = dcx
		     then /* is it ours? */
			go to found_desc;		/* WHEW!  Now make decisions for this one */

		     else do;

/* A restart or save of a given series is logically only allowed
   to be performed by a driver of the same device class that the
   series was originally done under.  However, a driver with multiple
   minor devices has one device class for each minor device.
   Therefore, even if the minor device that actually sent the
   wakeup does not have the matching device class, we will allow
   it so long as one of the other minor devices of the same
   driver process does have the matching device class.
*/

			     if idte.last_minor > idte.first_minor
			     then /* more than one minor device */
				do mdtx = idte.first_minor to idte.last_minor;
						/* look for one with right device class */
				     mdtep = addr (static_mdtp -> minor_device_tab.entries (mdtx));
				     if mdte.active = 1
				     then if mdte.dev_class_index = desc_ptr -> request_descriptor.dev_class_index
					then do;
						sender_device = get_device_name ();
						dctep =
						     addr (iodc_static.dctp
						     -> dev_class_tab.entries (mdte.dev_class_index));
						qgtep =
						     addr (iodc_static.qgtp
						     -> q_group_tab.entries (dcte.qgte_index));
						sender_class = get_class_name ();
						go to found_desc;
					     end;
				end;

			     call ioa_$rsnnl (
				"^a rejected.  Sender device class does not match that of specified request.",
				out_msg, out_len, cmd);
			     call iodc_message_ ("110"b, 0, out_msg);
			     code = error_table_$action_not_performed;
			     call driver_ack (code, 0);
						/* tell driver */
			     go to iodc_return;
			end;

	end;

/* come here if the specified sequence id was not found and
   neither were any higher sequence ids in the same series.
*/

	call ioa_$rsnnl ("No saved requests from number ^d", out_msg, out_len, seq_id);
	call iodc_message_ ("101"b, 0, out_msg);
	code = error_table_$noentry;
	go to tell_driver;


found_desc:
	if sig_type = restart
	then /* restart only */
	     if dcte.restart_req ^= 0
	     then do;
		     call ioa_$rsnnl ("Restart already in progress for request type ^a", out_msg, out_len,
			sender_class);
		     call iodc_message_ ("101"b, 0, out_msg);
		     code = error_table_$namedup;	/* duplicate request for restart */
		     go to tell_driver;
		end;

	if desc_ptr -> request_descriptor.seq_id > seq_id
	then do;
		call ioa_$rsnnl ("Request ^d is gone.", out_msg, out_len, seq_id);
		call iodc_message_ ("001"b, 0, out_msg);
		code = error_table_$noentry;		/* for single restart error message */
		if ^series_sw
		then go to tell_driver;		/* stop now if no series */
	     end;

	code = 0;					/* we will do a restart now, tell driver OK */
	seq_id = desc_ptr -> request_descriptor.seq_id;	/* say we started at this request */

	call ioa_$rsnnl ("^a ^[from^;of^] request ^d initiated for request type ^a", out_msg, out_len, cmd, series_sw,
	     seq_id, sender_class);
	call iodc_message_ ("110"b, 0, out_msg);

	if sig_type = restart
	then /* establish restart cycle */
	     dcte.restart_req = desc_off;

/* for both restart and save, turn on "saved" indicators */

	desc_ptr -> request_descriptor.saved = "1"b;
	if series_sw
	then do;
		if sig_type = restart
		then desc_ptr -> request_descriptor.series_restart = "1"b;
						/* this triggers the sequence for next req cmd */
		do desc_off = desc_ptr -> request_descriptor.next_done
		     repeat desc_ptr -> request_descriptor.next_done while (desc_off ^= 0);
		     desc_ptr = ptr (iodc_static.descr_seg_ptr, desc_off);
		     if divide (desc_ptr -> request_descriptor.seq_id, 10000, 35, 0) = series_id
		     then do;
			     desc_ptr -> request_descriptor.saved = "1"b;
			     if sig_type = restart
			     then desc_ptr -> request_descriptor.series_restart = "1"b;
			end;
		end;
	     end;

/* if the series restarted or saved is in use, give driver a new series */

	do mdtx = 1 to static_mdtp -> minor_device_tab.n_minor;
						/* see if series is in use */
	     mdtep = addr (static_mdtp -> minor_device_tab.entries (mdtx));
	     if mdte.active = 1
	     then if divide (mdte.seq_id, 10000, 35, 0) = series_id
		then do;
			idtep = addr (static_idtp -> iod_device_tab.entries (mdte.major_index));
			sender_device = get_device_name ();
			call driver_ack (0, seq_id);	/* be sure driver gets OK */
			go to new_series;
		     end;
	end;

tell_driver:
	call driver_ack (code, seq_id);		/* tell what happened and which request number */
	go to iodc_return;				/* ============= */

/* ********************************************************** */

driver_ack:
     proc (code, num);

	dcl     code		 fixed bin (35);
	dcl     num		 fixed bin (35);
	dcl     ec		 fixed bin (35);

	if ack_chan = 0
	then return;				/* if nothing defined, quit */

	addr (event_message) -> ack_msg.code = code;
	addr (event_message) -> ack_msg.num = num;

	call hcs_$wakeup (proc_id, ack_chan, event_message, ec);

	if ec ^= 0
	then call iodc_message_ ("101"b, code, "Unable to acknowledge driver command.");

	return;

     end driver_ack;
%page;


sig_label (4):					/* 
   This branch is taken when a driver process has received a "logout" command.
   It frees the major device assigned to the driver process. */

	call iodc_$free_device (idtep, code);
	if code = 0
	then do;
		call ioa_$rsnnl ("Driver logout for device ^a", out_msg, out_len, idte.dev_id);
		call iodc_message_ ("100"b, 0, out_msg);
	     end;
	go to iodc_return;


/* ********************************************************** */


sig_label (5):					/* 
This branch is taken when the driver wants to get the event channel needed to
send commands through coord_comm.ms, which is only given to live drivers */

	event_message = driver_cmd_chan;

	call hcs_$wakeup (proc_id, dr_ptr -> driver_status.driver_chan, event_message, code);

	if code ^= 0
	then call check_wakeup_code (code);

	go to iodc_return;
%page;

free_device:
     entry (a_idtep, a_code);

/* This entry frees a major device for subsequent use by  another driver. */
/* The process id assigned to the device is zeroed, and each minor device is marked inactive */
/* The major device directory and all contained driver status segments are deleted. */
/* If an unfinished request is found for a minor device, that request is
   made pending for the associated device class and marked as "continued". */

	dcl     a_idtep		 ptr;		/* device table entry ptr */
	dcl     a_code		 fixed bin (35);


	idtep = a_idtep;

/* loop thru minor devices making each inactive */

	do mdtx = idte.first_minor to idte.last_minor;
	     mdtep = addr (static_mdtp -> minor_device_tab.entries (mdtx));
	     if idte.process_id ^= ""b
	     then if mdte.active = 1
		then if mdte.current_request ^= 0
		     then do;			/* could be an unfinished request */
			     dctep = addr (iodc_static.dctp -> dev_class_tab.entries (mdte.dev_class_index));
			     desc_ptr = ptr (iodc_static.descr_seg_ptr, mdte.current_request);
			     copy_ptr = addr (mdte.driver_ptr -> driver_status.descriptor);
			     call update_descriptor;
			     if copy_ptr -> request_descriptor.finished | copy_ptr -> request_descriptor.cancelled
			     then /* consider it done */
				call save_request_ (desc_ptr, dctep);

			     else do;		/* not finished, make request pending */
				     desc_ptr -> request_descriptor.next_pending = dcte.pending_request;
				     dcte.pending_request = fixed (rel (desc_ptr), 18);
				     desc_ptr -> request_descriptor.continued = "1"b;
						/* this request is not brand new */
				     desc_ptr -> request_descriptor.contd_seq_id =
					desc_ptr -> request_descriptor.seq_id;
				end;

			     mdte.current_request = 0;
			end;

	     mdte.active = 0;
	end;

	idte.lock, idte.process_id = ""b;

	call delete_$path (sysdir, idte.dev_id, "101101"b, "", code);
						/* delete major device dir */
	if code ^= 0
	then if code ^= error_table_$noentry
	     then do;
		     call ioa_$rsnnl ("Deleting ^a>^a.  Cannot free device.", out_msg, out_len, sysdir, idte.dev_id);
		     call iodc_message_ ("101"b, code, out_msg);
		end;
	     else code = 0;

	a_code = code;

	return;
%page;

new_driver:
     entry (a_ptr);

/* This entry gets a wakeup from a driver that's just come up. We
   *  must allocate a structure for it and alert it that we're ready for it
   *  to operate.
*/

	entry_type = new_driver;
	go to read_comm_msg;


driver_command:
     entry (a_ptr);

/* this entry uses some similar code to the new driver entry, but is used by a driver to signal commands
   which need more space than an event message can provide */

	entry_type = driver_command;

read_comm_msg:
	ack_chan = 0;				/* define this as not known for now */
	mask_code = -1;
	on cleanup
	     begin;
		call driver_ack (error_table_$action_not_performed, 0);
						/* break driver loose */
		if mask_code = 0
		then call ipc_$unmask_ev_calls (code2);
	     end;
	call ipc_$mask_ev_calls (mask_code);
	err_label = iodc_return;
	ev_info_ptr = a_ptr;
	proc_id = ev_info.sending_proc;

/* The event message for the new driver wakeup should contain a message id. */
/* The message id  identifies a message placed in coord_comm.ms by the driver */

	ms_id = unspec (ev_info.message);
	unspec (driver_mmi) = ""b;
	driver_mmi.version = MSEG_MESSAGE_INFO_V1;
	driver_mmi.ms_id = ms_id;
	driver_mmi.message_code = MSEG_READ_SPECIFIED;
	call message_segment_$read_message_index (comm_mseg_idx, areap, addr (driver_mmi), code);
	if code ^= 0
	then do;
		call iodc_message_ ("101"b, code, "Attempting to read driver message from coord_comm.ms");
		go to iodc_return;
	     end;
	call message_segment_$delete_index (comm_mseg_idx, ms_id, code);
						/* delete the message */
	if code ^= 0
	then call iodc_message_ ("101"b, code, "Deleting coord_comm.ms driver message");

	if entry_type = new_driver
	then go to make_new_driver;

/* otherwise, this is a driver command .. so get set up for it */
%page;

	comm_ptr = driver_mmi.ms_ptr;			/* set pointer to message for easy reference */
	ack_chan = iodd_comm.ack_chan;		/* this is how we tell what happened */
	err_label = abort_driver_cmd;			/* be sure we jolt driver on errors */
	mdtx = iodd_comm.minor_idx;			/* see who the driver says he is */

	call identify_sender (code);
	if code ^= 0
	then do;
bad_req:
		call driver_ack (code, 0);		/* don't let the driver hang */
		go to iodc_return;
	     end;

	sig_type = iodd_comm.type;			/* this is the command code */

	if sig_type = save | sig_type = restart
	then do;					/* for save and restart commands */
		seq_id = iodd_comm.request_no;
		if iodd_comm.type_ext = ""b
		then series_sw = ""b;
		else series_sw = "1"b;
		go to restart_or_save;		/* join the main part */
	     end;

	if sig_type = restart_q
	then go to restart_queue;			/* for restart_q command */

	if sig_type = next_req
	then go to next_request;

	code = error_table_$request_not_recognized;
	go to bad_req;


abort_driver_cmd:
	call driver_ack (error_table_$action_not_performed, 0);
	go to iodc_return;
%page;

make_new_driver:
	new_driver_id = driver_mmi.sender_id;		/* get person/project name of new driver */
	i = length (rtrim (new_driver_id));		/* locate tag portion of group id */
	substr (new_driver_id, i) = "*";		/* any tag is ok */
	auth = driver_mmi.sender_authorization;		/* get authorization of new driver */
	new_driver_msg_p = driver_mmi.ms_ptr;
	chan_name = new_driver_msg.wakeup_chan;		/* pick up channel on which to wakeup driver */

/* find out what device class the new driver wants */
/* make sure the driver's authorization is right for the device class */

	dcx = new_driver_msg.dev_class_index;		/* get index of desired device class */
	if dcx < 1 | dcx > iodc_static.dctp -> dev_class_tab.n_classes
						/* bad index */
	then do;
		code = 1;
		call ioa_$rsnnl ("New driver rejected: ^a (bad device class index)", out_msg, out_len, new_driver_id);

bad_new_driver:
		call iodc_message_ ("100"b, 0, out_msg);
		go to wake_driver;
	     end;

	dctep = addr (iodc_static.dctp -> dev_class_tab.entries (dcx));
						/* get dev class table entry ptr */

	qgtep = addr (iodc_static.qgtp -> q_group_tab.entries (dcte.qgte_index));
						/* get q group tab entry ptr */

	sender_class = get_class_name ();		/* get device class name */

	if ^aim_check_$greater_or_equal (auth, dcte.max_access)
	then do;					/* insufficient authorization */
		code = 2;
		call ioa_$rsnnl ("New driver rejected: ^a (wrong authorization for device class ^a)", out_msg,
		     out_len, new_driver_id, sender_class);
		go to bad_new_driver;
	     end;

/* make sure driver's userid is right for queue group */

	if qgte.driver_id ^= new_driver_id
	then do;					/* wrong userid */
		code = 3;
		call ioa_$rsnnl ("New driver rejected: ^a (invalid userid for ^a queue group)", out_msg, out_len,
		     new_driver_id, qgte.name);
		go to bad_new_driver;
	     end;

/* now find out which device the new driver wants */
/* make sure that its valid for the device class and that its not already in use */

	mdtx = new_driver_msg.device_index;
	if mdtx < 1 | mdtx > static_mdtp -> minor_device_tab.n_minor
						/* bad index */
	then do;
		code = 4;
		call ioa_$rsnnl ("New driver rejected: ^a (bad minor device index)", out_msg, out_len, new_driver_id);
		go to bad_new_driver;
	     end;

	mdtep = addr (static_mdtp -> minor_device_tab.entries (mdtx));
	idtx = mdte.major_index;			/* get major device index */
	idtep = addr (static_idtp -> iod_device_tab.entries (idtx));
	sender_device = get_device_name ();		/* pick up major device name */

	if ^substr (dcte.device_list, mdtx, 1)
	then do;					/* device not valid for this class */
		code = 5;
		call ioa_$rsnnl ("New driver rejected: ^a (device ^a invalid for device class ^a)", out_msg, out_len,
		     new_driver_id, sender_device, sender_class);
		go to bad_new_driver;
	     end;

	if idte.process_id ^= ""b
	then /* major device is already assigned */
	     if idte.process_id ^= proc_id
	     then do;				/* but not to this process */
		     call set_lock_$lock (idte.lock, 0, code);
						/* see if lock is still valid */
		     if code = 0 | code = error_table_$invalid_lock_reset
		     then do;			/* bad lock so free the device */
			     call iodc_$free_device (idtep, code);
			     if code ^= 0
			     then do;
				     code = 10;
				     go to wake_driver;
				end;
			end;
		     else do;			/* lock was good, can't give new driver this device */
			     code = 6;
			     call ioa_$rsnnl ("New driver rejected: ^a (device ^a assigned to other process)",
				out_msg, out_len, new_driver_id, idte.dev_id);
			     go to bad_new_driver;
			end;
		end;
	     else if mdte.active ^= 0
	     then do;				/* we already gave him this one */
		     code = 7;
		     call ioa_$rsnnl ("New driver rejected: ^a (device ^a already active)", out_msg, out_len,
			new_driver_id, sender_device);
		     go to bad_new_driver;
		end;

/* if the message segment queues have not yet been opened for this group, then open them */

	if qgte.open = 0
	then /* queues have not been opened */
	     do q = 1 to qgte.max_queues;		/* open them */
		qgte.last_read (q) = "0"b;
		call ioa_$rsnnl ("^a_^d.ms", q_name, out_len, qgte.name, q);
		call message_segment_$open (sysdir, q_name, q_idx, code);

		if code ^= 0
		then do;
			if code = error_table_$noentry
			then call ioa_$rsnnl ("Queue ^d for request type ^a missing.", out_msg, out_len, q, dcte.id)
				;
			else call ioa_$rsnnl ("Could not open ^a>^a", out_msg, out_len, sysdir, q_name);
			call iodc_message_ ("101"b, code, out_msg);
			code = 8;
			go to wake_driver;
		     end;

		call message_segment_$check_salv_bit_index (q_idx, "1"b, unbit, code);
		if unbit
		then do;
			call ioa_$rsnnl ("Message segment ^a was salvaged. Some requests may have been lost.",
			     out_msg, out_len, q_name);
			call iodc_message_ ("110"b, 0, out_msg);
		     end;

		qgte.mseg_index (q) = q_idx;		/* save the message segment index */
	     end;

/* If the major device was not previously assigned, we must  create */
/* a directory to hold all driver status segments for the major device. */
/* This directory will be upgraded (if necessary) to the authorization of the new driver. */
/* If upgraded, a quota of 2 records per minor device will be assigned. 
The dir_quota will be a min of 5, or 1/6 page per segment. */

	if idte.process_id = ""b
	then do;					/* device not previously assigned */
		quota = 2 * (idte.last_minor - idte.first_minor + 1);
						/* 2 records per minor device */
		dir_quota = max (5, divide (idte.last_minor - idte.first_minor + 1, 6, 17));
		call make_dir (idte.dev_id, auth, quota, dir_quota, code);
		if code ^= 0
		then do;				/* failed to create dir */
			call ioa_$rsnnl ("Cannot create directory for device ^a", out_msg, out_len, idte.dev_id);
			call iodc_message_ ("101"b, code, out_msg);
						/* tell the operator */
			code = 9;
			go to wake_driver;
		     end;
	     end;

/* now we're ready to set up driver status segment */

	subdir = sysdir;
	substr (subdir, sysdir_len + 1, 1) = ">";
	substr (subdir, sysdir_len + 2) = idte.dev_id;	/* construct dir name */
	acl (n_acl).ac_name = new_driver_id;		/* put driver on the acl of driver status seg */
	call make (subdir, mdte.dev_id, dr_ptr, code);

	if code ^= 0
	then do;
		call ioa_$rsnnl ("Cannot create driver status segment for device ^a", out_msg, out_len, sender_device)
		     ;
		call iodc_message_ ("101"b, code, out_msg);
		code = 10;
		go to wake_driver;
	     end;

/* set up driver status segment contents */

	unspec (dr_ptr -> driver_status) = "0"b;
	dr_ptr -> driver_status.req_type_label = sender_class;
	dr_ptr -> driver_status.dev_name_label = sender_device;
	dr_ptr -> driver_status.device_id = mdte.dev_id;
	dr_ptr -> driver_status.device_class_id = dcte.id;
	dr_ptr -> driver_status.coord_chan = driver_sig_chan;
	dr_ptr -> driver_status.request_pending = "0"b;
	dr_ptr -> driver_status.dev_index = mdtx;
	dr_ptr -> driver_status.maj_index = idtx;
	dr_ptr -> driver_status.dev_class_index = dcx;
	dr_ptr -> driver_status.minor_args = mdte.args;
	dr_ptr -> driver_status.min_banner = dcte.min_banner;

	dr_ptr -> driver_status.rqti_ptr = null;
	dr_ptr -> driver_status.dev_out_iocbp = null;
	dr_ptr -> driver_status.dev_in_iocbp = null;
	dr_ptr -> driver_status.dev_out_stream = "";
	dr_ptr -> driver_status.dev_in_stream = "";
	dr_ptr -> driver_status.forms_validation_ptr = null;
	dr_ptr -> driver_status.dev_ptr1 = null;
	dr_ptr -> driver_status.dev_ctl_ptr = null;

/* modify coordinator data bases to reflect new driver */

	qgte.open = 1;
	idte.lock = new_driver_msg.lock_id;
	idte.process_id = proc_id;
	mdte.dev_class_index = dcx;
	mdte.active = 1;
	mdte.driver_ptr = dr_ptr;
	mdte.current_request = 0;
	new_driver_series = new_driver_series + 10000;
	mdte.seq_id = new_driver_series;

	call ioa_$rsnnl ("New driver for device ^a, request type ^a (series = ^d)", out_msg, out_len, sender_device,
	     sender_class, new_driver_series);
	;
	call iodc_message_ ("100"b, 0, out_msg);


wake_driver:					/* tell the guy all about it */
	event_message = 0;
	addr (event_message) -> ev_msg.code = code;

	call hcs_$wakeup (proc_id, chan_name, event_message, code);
	if code ^= 0
	then call check_wakeup_code (code);
	go to iodc_return;
%page;

restart_queue:					/* 
go back to the head of the queues for this driver, flush any normal waiting
requests from the wait list, but leave all priority requests */

	wlp = iodc_static.wait_list_ptr;
	qgte.last_read (*) = ""b;			/* next time read the first message */

	do dcx = qgte.first_dev_class to qgte.last_dev_class;
	     dctep = addr (iodc_static.dctp -> dev_class_tab.entries (dcx));
	     do q = 1 to 4;				/* look at all possible queues */
		nx = dcte.first_waiting (q);		/* get first waiting list index for this queue */
		if nx ^= 0
		then do;				/* do we need to check? */
			lwx, fwx = 0;		/* get ready to re-thread the list */
			do x = nx repeat nx while (nx ^= 0);
			     nx = wlp -> waiting_list.next (x);
						/* advance the forward thread */
			     if wlp -> waiting_list.state (x) = priority
			     then do;
				     if fwx = 0
				     then fwx = x;
				     else wlp -> waiting_list.next (lwx) = x;
						/* add to tail of list */
				     lwx = x;	/* advance the tail marker */
				     wlp -> waiting_list.next (x) = 0;
						/* mark this as the end */
				end;
			     else do;		/* this is a normal entry, drop it */
				     if x = wlp -> waiting_list.last_used
				     then do;	/* drop the high water mark */
					     wlp -> waiting_list.next (x) = 0;
					     wlp -> waiting_list.last_used = wlp -> waiting_list.last_used - 1;
					end;
				     else do;	/* add to the free list */
					     wlp -> waiting_list.next (x) = wlp -> waiting_list.first_free;
					     wlp -> waiting_list.first_free = x;
					end;
				     wlp -> waiting_list.state (x) = 0;
						/* clear any garbage */
				     wlp -> waiting_list.ms_id (x) = ""b;
				     wlp -> waiting_list.orig_q (x) = 0;
				     dcte.n_waiting = dcte.n_waiting - 1;
						/* reduce the count */
				end;
			end;
			dcte.first_waiting (q) = fwx;
			dcte.last_waiting (q) = lwx;
		     end;
	     end;
	end;

	call driver_ack (0, 0);
	go to iodc_return;
%page;

next_request:					/* 
   Here a driver has requested the coord to make a certain request high priority.
   This is done by searching the driver's queues for a request which matches given parameters.
   Then the message_id and queue number data are threaded into the drivers queue 1 waiting
   list, behind any other priority requests */

	if iodd_comm.queue_no = 0
	then do;					/* do we look in each possible queue? */
		start = 1;
		finish = qgte.max_queues;
	     end;
	else start, finish = iodd_comm.queue_no;	/* just look in the given queue */

	if start < 1 | finish > qgte.max_queues
	then do;					/* bad to start with */
		code = error_table_$action_not_performed;
		go to bad_req;
	     end;

	user_id = iodd_comm.user_id;
	string (option) = iodd_comm.type_ext;

	if option.et
	then do;					/* use this as precedence */
		option.pn = ""b;			/* in case both were set */
		match_dir = "";
		match_ent = iodd_comm.data;		/* get the entry name we will look for */
	     end;
	else if option.pn
	then do;
		call expand_pathname_ (iodd_comm.data, match_dir, match_ent, code);
		if code ^= 0
		then go to bad_req;
	     end;
	else do;
		match_dir, match_ent = "";		/* clear the names */
		if ^option.id
		then do;
			code = error_table_$action_not_performed;
			go to bad_req;
		     end;
	     end;

/*	now look for a request matching user, segment and/or request_id */

	code = 0;					/* clear, then watch for aim errors */

	do q = start to finish;
	     q_idx = qgte.mseg_index (q);		/* get the message segment index for reading */
	     ms_id = ""b;				/* start at the begining of the queue */

	     retry = 0;
retry1:
	     unspec (msg_mmi) = ""b;
	     msg_mmi.version = MSEG_MESSAGE_INFO_V1;
	     msg_mmi.message_code = MSEG_READ_FIRST;
	     call message_segment_$read_message_index (q_idx, areap, addr (msg_mmi), code2);
	     if code2 ^= 0
	     then /* normal test should be cheap */
		if code2 = error_table_$bad_segment	/* message seg was salvaged */
		then if retry = 0
		     then do;			/* try once more */
			     retry = 1;
			     go to retry1;
			end;

	     do while (code2 = 0);
		ms_id = msg_mmi.ms_id;		/* record the last message read */
		reqp = msg_mmi.ms_ptr;		/* get pointer to request */

		sender_id = msg_mmi.sender_id;	/* see who put it there */
		len = length (rtrim (sender_id));	/* get its size */
		sender_id = substr (sender_id, 1, len - 2);
						/* strip off the tag */

		if sender_id ^= user_id
		then go to next_msg;		/* user didn't match, skip the request */


		if option.et
		then if match_ent ^= reqp -> queue_msg_hdr.ename
		     then go to next_msg;

		if option.pn
		then do;
			if match_ent ^= reqp -> queue_msg_hdr.ename
			then go to next_msg;
			if match_dir ^= reqp -> queue_msg_hdr.dirname
			then go to next_msg;
		     end;

		if option.id
		then if ^match_request_id_ (reqp -> queue_msg_hdr.msg_time, iodd_comm.req_id)
		     then go to next_msg;

/*	We have a matching request, see if the driver can run it */

		auth = msg_mmi.sender_authorization;

		if ^aim_check_$greater_or_equal (auth, dcte.min_access)
		then /* below minimum? */
		     code = error_table_$ai_restricted;
		else if aim_check_$greater_or_equal (dcte.max_access, auth)
		then do;				/* not above max */
			reqp -> queue_msg_hdr.state = STATE_ELIGIBLE;
			retry = 0;
retry3:
			call message_segment_$update_message_index (q_idx, msg_mmi.ms_len, ms_id, reqp, code2);
			if code2 ^= 0
			then do;			/* normal test should be cheap */
				if code2 = error_table_$bad_segment
						/* message seg was salvaged */
				then if retry = 0
				     then do;	/* try once more */
					     retry = 1;
					     go to retry3;
					end;

				go to next_msg;
			     end;
			go to found_next_request;	/* OK, put it into the waiting list */
		     end;
		else code = error_table_$ai_above_allowed_max;

/*		if driver can't see the request, pretend we didn't see it either */

next_msg:
		free reqp -> queue_msg_hdr in (sys_area);
						/* free the old request */
		retry = 0;
retry2:
		unspec (msg_mmi) = ""b;
		msg_mmi.version = MSEG_MESSAGE_INFO_V1;
		msg_mmi.ms_id = ms_id;
		msg_mmi.message_code = MSEG_READ_AFTER_SPECIFIED;
		call message_segment_$read_message_index (q_idx, areap, addr (msg_mmi), code2);
		if code2 ^= 0
		then /* normal test should be cheap */
		     if code2 = error_table_$bad_segment/* message seg was salvaged */
		     then if retry = 0
			then do;			/* try once more */
				retry = 1;
				go to retry2;
			     end;
	     end;
	end;

/* No matching request was found or it was out of aim range */

	if code = 0
	then code = error_table_$noentry;
	go to bad_req;

found_next_request:
	free reqp -> queue_msg_hdr in (sys_area);	/* we are done with the text for now */

/* 	thread the request info into the waiting list */

	wlp = iodc_static.wait_list_ptr;

	if wlp -> waiting_list.first_free > 0
	then do;
		new_idx = wlp -> waiting_list.first_free;
						/* pick off a free entry */
		wlp -> waiting_list.first_free = wlp -> waiting_list.next (new_idx);
						/* move the list back */
	     end;
	else do;					/* list is full, extend it */
		if wlp -> waiting_list.last_used = max_wl_size
		then do;
			call iodc_message_ ("101"b, 0, "Waiting_list full.");
			code = error_table_$action_not_performed;
			go to bad_req;
		     end;
		new_idx = wlp -> waiting_list.last_used + 1;
						/* allocate the next entry */
		wlp -> waiting_list.last_used = new_idx;/* record the usage */
	     end;

	wlp -> waiting_list.next (new_idx) = 0;		/* fill in the new entry */
	wlp -> waiting_list.state (new_idx) = priority;
	wlp -> waiting_list.ms_id (new_idx) = ms_id;
	wlp -> waiting_list.orig_q (new_idx) = q;

	nx = dcte.first_waiting (1);			/* find queue 1 waiting list */
	if nx > 0
	then do;					/* is there a real list? */
		lwx = 0;				/* last good entry not found yet */
		do x = nx repeat nx while (nx ^= 0);
		     nx = wlp -> waiting_list.next (x); /* offset of next in the chain */
		     if wlp -> waiting_list.state (x) ^= priority
		     then do;			/* found last of the priority entries */
			     nx = 0;		/* stop the loop */
			     wlp -> waiting_list.next (new_idx) = x;
						/* put new one in front */
			     if lwx = 0
			     then dcte.first_waiting (1) = new_idx;
						/* if this was the first one */
			     else wlp -> waiting_list.next (lwx) = new_idx;
						/* link the last one to the new one */
			end;
		     else if nx = 0
		     then do;			/* last entry was also priority */
			     wlp -> waiting_list.next (x) = new_idx;
						/* put this on the end */
			     dcte.last_waiting (1) = new_idx;
						/* update the last pointer for chaining to end */
			end;
		     lwx = x;			/* save the last index of skipped request */
		end;
	     end;
	else dcte.first_waiting (1), dcte.last_waiting (1) = new_idx;
						/* no list, so start one */

	dcte.n_waiting = dcte.n_waiting + 1;

	call driver_ack (0, 0);			/* tell driver we found it */
	go to iodc_return;
%page;

proc_dies:					/* Come here for new process after disaster */
	call ioa_$rsnnl ("^a^/New coordinator process will be created. All device drivers will be reinitialized.",
	     out_msg, out_len, out_msg);
	call iodc_message_$loud ("001"b, code, out_msg);

/* put machine conditions if any in log */

	if scu_msg ^= ""
	then call iodc_message_ ("100"b, code, scu_msg);
	call new_proc;
%page;

quit_handler:
     proc;

/* Entered when coordinator receives QUIT.
*/

	dcl     mask_code		 fixed bin (35);

	if quit_flag
	then if ^testing
	     then do;				/* don't stack quits */
		     call com_err_ (0, "io_coordinator", "QUIT already pending.");
		     return;
		end;

	mask_code = -1;
	on cleanup
	     begin;
		if mask_code = 0
		then call ipc_$unmask_ev_calls (code2);
	     end;
	call ipc_$mask_ev_calls (mask_code);

	quit_flag = "1"b;
	call ioa_ ("QUIT received.");
	call iox_$control (iox_$user_input, "resetread", null (), code);

	call iodc_$command_level;

	quit_flag = "0"b;
	call ipc_$unmask_ev_calls (code2);
	call iox_$control (iox_$user_io, "start", null, code);
	return;

     end quit_handler;
%page;

command_level:
     entry;

/* This is the IO Coordinator command processor.  It is
   called by the quit handler and also by the unclaimed
   signal handler when in test mode.
*/

	com_level = com_level + 1;
	mask_code = -1;

	on cleanup
	     begin;
		com_level = com_level - 1;
		if mask_code = 0
		then call ipc_$unmask_ev_calls (code2);
	     end;

	if com_level > 0
	then /* don't ask for a command just after initialization */
ask:
	     call ioa_ ("Enter command.^[ (level ^d)^;^s^]", (com_level > 1), com_level);

	if mask_code = 0
	then do;
		call ipc_$unmask_ev_calls (code2);
		mask_code = -1;
	     end;

	line = "";
	call iox_$get_line (iox_$user_input, addr (line), length (line), nc, code);
	line = ltrim (rtrim (line, NL || " "));		/* trim spaces and NL chars */
	cmd = before (line, " ");			/* command is the first part */
	if cmd = "" | cmd = "."
	then go to ask;

	call ipc_$mask_ev_calls (mask_code);

	if cmd = "help"
	then do;					/* HELP COMMAND */
		call ioa_ ("list, logout, print_devices, restart_status, start, term, wait_status");
		if testing
		then call ioa_ ("**Test: debug, probe, driver, pi, return");
		go to ask;
	     end;

	if cmd = "start"				/* START COMMAND */
	then if com_level > 0
	     then do;
		     com_level = com_level - 1;
		     if mask_code = 0
		     then call ipc_$unmask_ev_calls (code2);
		     return;
		end;
	     else do;
		     call com_err_ (0, "io_coordinator", "Coordinator already started.");
		     go to ask;
		end;

	if cmd = "return"
	then /* RETURN COMMAND */
	     if testing
	     then go to return_label;
	     else go to bad_cmd;

	if cmd = "debug"				/* DEBUG COMMAND */
	then if testing
	     then do;
		     call debug;
		     go to ask;
		end;

	if cmd = "probe" | cmd = "pb"			/* PROBE COMMAND */
	then if testing
	     then do;
		     call probe;
		     go to ask;
		end;

	if cmd = "pi"				/* PI COMMAND */
	then if testing
	     then do;
		     call signal_ ("program_interrupt");
		     go to ask;
		end;

	if cmd = "logout"				/* LOGOUT COMMAND */
	then if testing
	     then go to return_label;
	     else call logout;

	if ^initialized
	then go to bad_cmd;				/* other commands only valid after initialization */

	if cmd = "print_devices"
	then do;					/* PRINT_DEVICES COMMAND */
		call print_devices ("-dir", sysdir);
		go to ask;
	     end;

	if cmd = "list"
	then do;					/* LIST COMMAND */
		i = 0;
		do idtx = 1 to static_idtp -> iod_device_tab.n_devices;
		     idtep = addr (static_idtp -> iod_device_tab.entries (idtx));
		     if idte.process_id ^= ""b
		     then do mdtx = idte.first_minor to idte.last_minor;
			     mdtep = addr (static_mdtp -> minor_device_tab.entries (mdtx));
			     if mdte.active = 1
			     then do;
				     dctep =
					addr (iodc_static.dctp -> dev_class_tab.entries (mdte.dev_class_index));
				     qgtep = addr (iodc_static.qgtp -> q_group_tab.entries (dcte.qgte_index));
				     sender_device = get_device_name ();
				     sender_class = get_class_name ();
				     call ioa_ ("device ^a is active, request type ^a, request ^d", sender_device,
					sender_class, mdte.seq_id);
				     i = i + 1;
				end;
			end;
		end;
		if i = 0
		then call ioa_ ("No active devices");
		go to ask;
	     end;

	if cmd = "restart_status"			/* RESTART_STATUS COMMAND */
	then do;
		nseries = divide (new_driver_series, 10000, 35, 0);
		if nseries = 0
		then go to no_restartable;

		allocate series_info in (sys_area);
		series_info (*).count = 0;

		desc_off = iodc_static.first_req_done;
		do while (desc_off ^= 0);		/* scan the saved list */
		     desc_ptr = ptr (iodc_static.descr_seg_ptr, desc_off);
		     series_id = divide (desc_ptr -> request_descriptor.seq_id, 10000, 35, 0);

		     if series_info (series_id).count = 0
		     then do;			/* first request of this series */
			     series_info (series_id).first = desc_ptr -> request_descriptor.seq_id;
			     series_info (series_id).dcx = desc_ptr -> request_descriptor.dev_class_index;
			end;
		     series_info (series_id).last = desc_ptr -> request_descriptor.seq_id;
		     series_info (series_id).count = series_info (series_id).count + 1;

		     desc_off = desc_ptr -> request_descriptor.next_done;
		end;

		i = 0;
		do series_id = 1 to nseries;		/* now let's see what we found */
		     if series_info (series_id).count > 0
		     then do;
			     dctep = addr (iodc_static.dctp -> dev_class_tab.entries (series_info (series_id).dcx));
			     qgtep = addr (iodc_static.qgtp -> q_group_tab.entries (dcte.qgte_index));
			     sender_class = get_class_name ();
						/* get type/class name for series */

			     call ioa_ ("^d restartable request(s) from ^d to ^d (^a)",
				series_info (series_id).count, series_info (series_id).first,
				series_info (series_id).last, sender_class);

			     if dcte.restart_req ^= 0
			     then do;		/* restart in progress for device class */
				     desc_ptr = ptr (iodc_static.descr_seg_ptr, dcte.restart_req);
				     if divide (desc_ptr -> request_descriptor.seq_id, 10000, 35, 0) = series_id
				     then call ioa_ ("   restart in progress at request ^d",
					     desc_ptr -> request_descriptor.seq_id);
				end;

			     i = i + 1;		/* count number of series */
			end;
		end;

		free series_info in (sys_area);

		if i = 0
		then
no_restartable:
		     call ioa_ ("No restartable requests.");

		go to ask;
	     end;

	if cmd = "wait_status" | /* WAIT_STATUS COMMAND */ cmd = "defer_status"
	then do;					/* old command name */
		i = 0;
		do q = 1 to iodc_static.qgtp -> q_group_tab.n_q_groups;
		     qgtep = addr (iodc_static.qgtp -> q_group_tab.entries (q));
		     if qgte.open = 1
		     then do dcx = qgte.first_dev_class to qgte.last_dev_class;
			     dctep = addr (iodc_static.dctp -> dev_class_tab.entries (dcx));
			     if dcte.n_waiting ^= 0
			     then do;
				     sender_class = get_class_name ();
				     call ioa_ ("^d request(s) waiting for device class ^a", dcte.n_waiting,
					sender_class);
				     i = i + 1;
				end;
			end;
		end;
		if i = 0
		then call ioa_ ("No waiting requests");
		go to ask;
	     end;

	if cmd = "term"				/* TERM COMMAND */
	then if com_level > 0
	     then go to not_after_quit;
	     else do;

/* operator asked to terminate driver */

		     dev_id = ltrim (substr (line, 5));
		     if dev_id = ""
		     then do;
			     call ioa_ ("Name of major device missing: term <devid>");
			     go to ask;
			end;

		     do idtx = 1 to static_idtp -> iod_device_tab.n_devices;
			idtep = addr (static_idtp -> iod_device_tab.entries (idtx));
			if idte.dev_id = dev_id
			then do;
				call iodc_$free_device (idtep, code);
				go to ask;
			     end;
		     end;
		     call com_err_ (0, "io_coordinator", "Unrecognized device name: ^a", dev_id);

		     go to ask;
		end;

	if cmd = "driver"
	then /* DRIVER COMMAND */
	     if testing
	     then if com_level > 0
		then go to not_after_quit;
		else do;
			if mask_code = 0
			then do;
				call ipc_$unmask_ev_calls (code2);
				mask_code = -1;
			     end;
			call iodd_$iodd_init (sysdir, "1"b);
			go to ask;
		     end;

bad_cmd:
	call com_err_ (0, "io_coordinator", "Invalid response -- ^a", line);
	go to ask;


not_after_quit:
	if testing
	then call com_err_ (0, id, "Specified command can only be used at command level 0:  ^a", cmd);
	else call com_err_ (0, id, "Specified command cannot be used after a QUIT:  ^a", cmd);

	go to ask;
%page;

area_handler:
     proc;

/* Handler for area condition when allocating a descriptor.
   *  If it happens once, free a descriptor and try again. If
   *  it still fails, area is screwed up, and we're in trouble.
*/

	if area_flag ^= 0
	then do;
		out_msg = "Multiple area condition in request descriptor segment.";
		go to proc_dies;			/* blow */
	     end;

	area_flag = 1;				/* watch for recursion */
	call free_oldest_request_$force;		/* do our best to get some space */
	return;

     end;
%page;

check_wakeup_code:
     proc (wcode);

/* Another little internal procedure, this one to check the return code from hcs_$wakeup */

	dcl     wcode		 fixed bin (35);
	dcl     wp		 ptr;
	dcl     code		 fixed bin (35);

	dcl     1 two		 based aligned,
		2 word1		 fixed bin,
		2 word2		 fixed bin;


	if wcode = 2
	then call ioa_$rsnnl ("Invalid arguments to hcs_$wakeup.", out_msg, out_len);

	else if wcode = 1 | wcode = 3
	then do;
		call ioa_$rsnnl ("Driver for device ^a is gone.", out_msg, out_len, idte.dev_id);
		call iodc_$free_device (idtep, code);	/* driver is gone, free device */
	     end;

	else do;
		wp = addr (dr_ptr -> driver_status.driver_chan);
		call ioa_$rsnnl ("^w ^w", out_msg, out_len, wp -> two.word1, wp -> two.word2);
	     end;

	if wcode < 4
	then wcode = 0;
	call iodc_message_$loud ("101"b, wcode, out_msg);

	return;

     end;
%page;

iodc_handler:
     proc;

/* Unclaimed signal handler for I/O Coordinator */

	dcl     conname		 char (32);
	dcl     ec		 fixed bin (35);

	dcl     ap		 ptr;
	dcl     mp		 ptr;

	dcl     m_len		 fixed bin;

	dcl     cond_mess		 char (m_len) based (mp);

	dcl     find_condition_info_	 entry (ptr, ptr, fixed bin (35));
	dcl     continue_to_signal_	 entry (fixed bin (35));
	dcl     condition_interpreter_ entry (ptr, ptr, fixed bin, fixed bin, ptr, char (*), ptr, ptr);
	dcl     ioa_$ioa_stream_nnl	 entry options (variable);

	dcl     w			 (8) fixed bin based (scup);
						/* for storing scu data on recursion */

	dcl     1 local_condition_info aligned like condition_info;

	local_condition_info.version = condition_info_version_1;
						/* version of condition_info structure */
	call find_condition_info_ (null, addr (local_condition_info), ec);
	conname = local_condition_info.condition_name;

	if conname = "command_question"
	then return;
	if conname = "command_error"
	then return;

	if conname = "cput"
	then do;
pass_on:
		call continue_to_signal_ (ec);
		return;
	     end;
	if conname = "alrm"
	then go to pass_on;
	if conname = "finish"
	then go to pass_on;
	if testing
	then if conname = "program_interrupt"
	     then go to pass_on;
	     else if conname = "mme2"
	     then go to pass_on;

	call get_system_free_area_ (ap);
	call condition_interpreter_ (ap, mp, m_len, 3, local_condition_info.mc_ptr, conname,
	     local_condition_info.wc_ptr, local_condition_info.info_ptr);

/* now we've got message to send to err_output and log */

	if m_len > 0
	then do;
		call ioa_$ioa_stream_nnl ("error_output", "io_coordinator: ");
		call iodc_message_ ("101"b, 0, cond_mess);
	     end;

	if testing
	then do;
		call iodc_$command_level;		/* give tester a chance to do something */
		return;
	     end;


	if recursion_flag ^= 0
	then do;					/* Bad news indeed */
		call ioa_$rsnnl ("Condition ^a signalled while handling unclaimed signal.", out_msg, out_len, conname)
		     ;

/* try to save scu data so we can check what happened some day */

		if local_condition_info.mc_ptr ^= null
		then do;
			scup = addr (local_condition_info.mc_ptr -> mc.scu);
			code = local_condition_info.mc_ptr -> mc.errcode;
			call ioa_$rsnnl ("^/scu: ^w ^w ^w ^w^/^5x^w ^w ^w ^w", scu_msg, out_len, w (1), w (2),
			     w (3), w (4), w (5), w (6), w (7), w (8));
		     end;

		else do;
			code = 0;
			scu_msg = "";
		     end;

		go to proc_dies;
	     end;

	recursion_flag = 1;
	go to err_label;

     end;
%page;
%include condition_info;
%page;
%include create_branch_info;
%page;
%include device_class;
%page;
%include driver_status;
%page;
%include iod_device_tab;
%page;
%include iod_event_message;
%page;
%include iod_tables_hdr;
%page;
%include iodc_data;
%page;
%include iodc_static;
%page;
%include iodc_wait_list;
%page;
%include iodd_comm;
%page;
%include mc;
%page;
%include mseg_message_info;
%page;
%include new_driver_msg;
%page;
%include q_group_tab;
%page;
%include queue_msg_hdr;
%page;
%include request_descriptor;

     end iodc_;
