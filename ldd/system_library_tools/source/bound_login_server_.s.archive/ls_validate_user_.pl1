/****^  ********************************************
        *                                          *
        * Copyright, (C) Honeywell Bull Inc., 1987 *
        *                                          *
        ******************************************** */

/****^  HISTORY COMMENTS:
  1) change(85-08-01,Coren), approve(87-06-26,MCR7679),
     audit(87-07-10,Parisek), install(87-08-04,MR12.1-1055):
     Initial coding.
  2) change(87-02-20,GDixon), approve(87-06-26,MCR7679),
     audit(87-07-10,Parisek), install(87-08-04,MR12.1-1055):
      A) Modified to properly set terminal type, based upon answerback
         term_type information returned by tty_info_$decode_answerback.
      B) Eliminate extra newline following special session line of greeting
         banner (dsa 141).
      C) Look for changes to greeting banner only every 3 minutes, rather than
         every 30 seconds.
      D) Changed to use ls_cp_info.(login connect)_info_dir.
      E) Make destroy -hold the default for the login-connect-loop request.
         Add -no_hold to counter -hold.  Allow -immediate for new_proc and
         destroy. (dsa 111)
      F) Add -auth to the dial request.
      G) Added login timeout handler to allow logins for only
         installation_parms.login_time seconds.  Add a wakeup loop count
         mechanism to detect high rate of wakeups (indicating comm line
         failure) and disconnect comm line. (dsa 70)
      H) Modified to make hello always print greeting banner, even at login
         request loop returned to by "logout -hold -brief".
      I) Correct coding standard violations.
      J) Add check for minimum password length.
      K) Add check for new password same as original password.
      L) Generate passwords whose length is specified by
         installation_parms.password_gpw_length and .password_min_length.
      M) Avoid telling Initializer when login fails because of too many
         bad passwords. (dsa 154)
      N) Prompt for login args when user just types "login", "enter" or
         "enterp". (dsa 135)
  3) change(87-04-16,GDixon), approve(87-06-25,MCR7702),
     audit(87-07-10,Parisek), install(87-08-04,MR12.1-1055):
      A) Include LS_RESPONSE_TYPES value in Unexpected response error message.
      B) Include time of last bad password in incorrect_passwords warning.
      C) Copy login_server_operator_response.process_group_id into
         ls_process_info for operator logins, so process_group_id will be
         correct in connection list.
      D) Add login_server_validate_request.connection_info.line_type. (dsa 123)
      E) Upgraded for change to answer_table.incl.pl1.
      F) Add support for login_server_process_request.minimum_ring, setting it
         to the minimum ring for DSA (ring 2).  This enforces the limitation in
         dsa 208.
  4) change(87-05-05,GDixon), approve(87-06-26,MCR7679),
     audit(87-07-10,Parisek), install(87-08-04,MR12.1-1055):
      A) Don't attempt to call ssu_$abort_subsystem in io_error on unit until
         after ssu_$listen has been called.  Otherwise, ssu_ will attempt to
         print a message on the terminal, causing another io_error (thus
         looping to get oob_stack).
  5) change(87-05-07,GDixon), approve(87-06-25,MCR7702),
     audit(87-07-10,Parisek), install(87-08-04,MR12.1-1055):
      A) Make LOGIN_TIMEOUT handler correctly check ls_validate.info.state to
         determine if hangup is needed.
      B) Changed MINIMUM_DSA_RING to 2.
  6) change(87-05-14,GDixon), approve(87-06-25,MCR7702),
     audit(87-07-10,Parisek), install(87-08-04,MR12.1-1055):
      A) Copy login_server_process_response.brief into ls_validate_info.brief.
      B) Change list request to print initial ring and authorization of
         disconnected processes, and use table format.
      C) Add cleanup handler to delete Initializer reply event channel.
      D) Allow process termination (eg, operator bump) after user is logged in
         but before process creation.
      E) Consolidate handling of validate_response in a new internal proc.
      F) Remove access_class_range from our calling sequence.
      G) Use ls_connection_desc.access_class_range and .minimum_ring instead.
      H) Add connection_info to login_server_list_request structure.
  7) change(87-05-26,GDixon), approve(87-06-26,MCR7679),
     audit(87-07-10,Parisek), install(87-08-04,MR12.1-1055):
      A) Use new ls_report_subr_error_ calling sequence.  Avoid lsdumps for
         some, "expected" errors.
  8) change(87-06-08,GDixon), approve(87-06-26,MCR7679),
     audit(87-07-10,Parisek), install(87-08-04,MR12.1-1055):
      A) Change Parse_login_args to remove -hd as short name for -hold.  This
         program (and the documentation) says -hd is short name for
         -home_dir.
  9) change(87-06-13,GDixon), approve(87-06-26,MCR7679),
     audit(87-07-10,Parisek), install(87-08-04,MR12.1-1055):
      A) Correctly diagnose io_error condition when going to NO_SETUP label
         from io_error on unit.
      B) Similarly, diagnose "iox_$control terminal_info" when going there
         from Read_answerback internal proc.
 10) change(87-06-26,GDixon), approve(87-06-26,MCR7679),
     audit(87-07-10,Parisek), install(87-08-04,MR12.1-1055):
      A) Change -printer_off/-no_printer_off to match parse_login_line_'s
         -print_off/-no_print_off.
      B) Add these control args to the dial preaccess command.
 11) change(87-07-06,GDixon), approve(87-07-06,MCR7679),
     audit(87-07-10,Parisek), install(87-08-04,MR12.1-1055):
      A) Fix bug in handling of enter and enterp preaccess commands.  These
         commands were never getting forwarded to the Initializer.
                                                   END HISTORY COMMENTS */

/* format: style4,delnl,insnl,^ifthendo */
ls_validate_user_:
     procedure (a_ls_cp_info_ptr, a_ls_validate_options_ptr,
	a_process_info_ptr, a_code);

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* This procedure engages in the login dialogue with the user, and exchanges */
/* requests/responses with the Initializer in order to get a process created */
/* or reconnected, etc.					       */
/*							       */
/* A non-zero status code is returned if and only if the connection is       */
/* terminated.						       */
/*							       */
/* The login dialogue is implemented as an ssu_ subsystem, wherein the       */
/* various preaccess and access requests are subsystem requests.  The	       */
/* "unknown_request" procedure is replaced in order to check for a special   */
/* session login word.					       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

/* PARAMETERS */

dcl  a_arg_list_ptr pointer parameter;
dcl  a_code fixed bin (35) parameter;
dcl  a_cond_name char (*) parameter;			/* for timer call routine -- not used */
dcl  a_continue_sw bit (1) aligned parameter;
dcl  a_data_ptr pointer parameter;
dcl  a_info_ptr pointer parameter;
dcl  a_ls_cp_info_ptr pointer parameter;
dcl  a_ls_validate_options_ptr pointer parameter;
dcl  a_mc_ptr pointer parameter;			/* for timer call routine -- not used */
dcl  a_process_info_ptr pointer parameter;
dcl  a_request_name char (*) parameter;
dcl  a_sci_ptr pointer parameter;
dcl  a_wc_ptr pointer parameter;			/* for timer call routine -- not used */


/* AUTOMATIC */

dcl  anonymous bit (1) aligned;
dcl  answer char (3);
dcl  arg_list_ptr pointer;
dcl  argl fixed bin (21);
dcl  argp pointer;
dcl  auth_range_string char (512);
dcl  code fixed bin (35);
dcl  dial_person char (22);
dcl  dial_project char (9);
dcl  gpw_length fixed bin;
dcl  hangup_flag bit (1) aligned;
dcl  help_flag bit (1) aligned;
dcl  hold bit (1) aligned;
dcl  new_password char (8) aligned;
dcl  new_password_generated char (8);
dcl  new_password_hyphenated char (12);
dcl  period_index fixed bin;
dcl  process_request_size fixed bin (18);
dcl  quit_flag bit (1) aligned;
dcl  request_name char (32);
dcl  sci_ptr pointer;
dcl  second_new_password char (8) aligned;
dcl  subr_name char (64);
dcl  this_arg fixed bin;
dcl  user_specified bit (1);


/* AUTOMATIC STRUCTURES */

dcl  1 auto_as_user_message_info aligned like as_user_message_info;
dcl  1 auto_dial_request aligned like login_server_dial_request;
dcl  1 auto_hangup_request aligned like login_server_disconnect_request;
dcl  1 auto_logout_request aligned like login_server_logout_request;
dcl  1 auto_rp_options aligned like rp_options;
dcl  1 auto_validate_info aligned like ls_validate_info;
dcl  1 auto_validate_request aligned like login_server_validate_request;


/* The following declarations are grouped together because they are all
   "global" variables set by Parse_login_args in response to control arguments
   on the initial request line.
*/

dcl  auth_specified bit (1) aligned;
dcl  authorization bit (72) aligned;
dcl  brief bit (1) aligned;
dcl  brief_specified bit (1) aligned;
dcl  cda bit (1) aligned;
dcl  cdp bit (1) aligned;
dcl  change_password bit (1) aligned;
dcl  command_type fixed bin;
dcl  first_arg_arg fixed bin;				/* position in argument list of first arg after "-args" */
dcl  force bit (1) aligned;
dcl  force_specified bit (1) aligned;
dcl  generate_password bit (1) aligned;
dcl  hold_given bit (1) aligned;
dcl  hold_on_destroy bit (1) aligned;
dcl  home_dir char (168);
dcl  immediate bit (1) aligned;
dcl  mask_needed bit (1) aligned;
dcl  mode_string char (512);
dcl  no_start_up bit (1) aligned;
dcl  number_of_args fixed bin;
dcl  operator bit (1) aligned;
dcl  outer_module char (32);
dcl  person_name char (22);
dcl  preempt bit (1) aligned;
dcl  preempt_specified bit (1) aligned;
dcl  process_number fixed bin;
dcl  process_overseer char (168);
dcl  project_name char (9);
dcl  ring fixed bin;
dcl  ring_specified bit (1) aligned;
dcl  save bit (1) aligned;
dcl  save_specified bit (1) aligned;
dcl  subsystem char (168);
dcl  terminal_id char (4);
dcl  terminal_type char (32);
dcl  virtual_channel_name char (32);
dcl  warn bit (1) aligned;
dcl  warn_specified bit (1) aligned;


/* BASED */

dcl  arg char (argl) based (argp);
dcl  system_area area based (system_areap);


/* ENTRIES */

dcl  check_password_ entry (char (*), char (*), fixed bin (35));
dcl  convert_authorization_$from_string entry (bit (72) aligned, char (*), fixed bin (35));
dcl  convert_authorization_$to_string entry (bit (72) aligned, char (*), fixed bin (35));
dcl  convert_authorization_$to_string_range entry ((2) bit (72) aligned, char (*), fixed bin (35));
dcl  cu_$arg_count_rel entry (fixed bin, ptr, fixed bin (35));
dcl  cu_$arg_ptr_rel entry (fixed bin, ptr, fixed bin (21), fixed bin (35), ptr);
dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
						/** */
dcl  dsa_log_manager_$trace_message entry options (variable);
	/*** */
dcl  date_time_$format entry (char (*), fixed bin (71), char (*), char (*)) returns (char (250) var);
dcl  date_time_$format_max_length entry (char (*), char (*), char (*)) returns (fixed bin);
dcl  generate_word_ entry (char (*), char (*), fixed bin, fixed bin);
dcl  get_system_free_area_ entry () returns (ptr);
dcl  ioa_ entry () options (variable);
dcl  ioa_$nnl entry () options (variable);
dcl  iox_$control entry (ptr, char (*), ptr, fixed bin (35));
dcl  iox_$get_chars entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
dcl  iox_$get_line entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
dcl  iox_$modes entry (ptr, char (*), char (*), fixed bin (35));
dcl  ipc_$create_ev_chn entry (fixed bin (71), fixed bin (35));
dcl  ipc_$delete_ev_chn entry (fixed bin(71), fixed bin(35));
dcl  ls_convert_as_error_code_ entry (fixed bin (35)) returns (fixed bin (35));
dcl  ls_message_$print entry options (variable);
dcl  ls_message_$print_nnl entry options (variable);
dcl  ls_message_$print_error entry options (variable);
dcl  ls_report_internal_error_ entry options (variable);
dcl  ls_report_subr_error_ entry (fixed bin(35), char(*), ptr, char(*), bit(1) aligned, bit(1) aligned);
dcl  net_info_$get_field entry (char (*), char (*), char (*), char (*), fixed bin (35));
dcl  scramble_ entry (char (8)) returns (char (8));
dcl  send_ls_request_ entry (ptr, fixed bin (18), ptr, fixed bin (35));
dcl  ssu_$abort_line entry () options (variable);
dcl  ssu_$abort_subsystem entry () options (variable);
dcl  ssu_$add_info_dir entry (ptr, char (*), fixed bin, fixed bin (35));
dcl  ssu_$add_request_table entry (ptr, ptr, fixed bin, fixed bin (35));
dcl  ssu_$arg_count entry (ptr, fixed bin);
dcl  ssu_$arg_list_ptr entry (ptr, ptr);
dcl  ssu_$arg_ptr entry (ptr, fixed bin, ptr, fixed bin (21));
dcl  ssu_$cpescape_disabled entry options (variable);
dcl  ssu_$create_invocation entry (char (*), char (*), ptr, ptr, char (*), ptr, fixed bin (35));
dcl  ssu_$delete_info_dir entry (ptr, char (*), fixed bin (35));
dcl  ssu_$delete_request_table entry (ptr, ptr, fixed bin (35));
dcl  ssu_$destroy_invocation entry (ptr);
dcl  ssu_$execute_line entry (ptr, ptr, fixed bin (21), fixed bin (35));
dcl  ssu_$get_request_name entry (ptr) returns (char (32));
dcl  ssu_$get_info_ptr entry (ptr) returns (ptr);
dcl  ssu_$get_procedure entry (ptr, char (*), entry, fixed bin (35));
dcl  ssu_$get_request_processor_options entry (ptr, char (8), ptr, fixed bin (35));
dcl  ssu_$listen entry (ptr, ptr, fixed bin (35));
dcl  ssu_$print_message entry () options (variable);
dcl  ssu_$set_procedure entry (ptr, char (*), entry, fixed bin (35));
dcl  ssu_$set_prompt_mode entry (ptr, bit (*));
dcl  ssu_$set_request_processor_options entry (ptr, ptr, fixed bin (35));
dcl  ssu_requests_$help entry options (variable);
dcl  system_info_$installation_id entry (char (*));
dcl  system_info_$sysid entry (char (*));
dcl  timer_manager_$alarm_call entry (fixed bin (71), bit (2), entry, ptr);
dcl  timer_manager_$reset_alarm_call entry (entry, ptr);
dcl  ttt_info_$decode_answerback entry (char (*), fixed bin, char (*), char (4), fixed bin (35));
dcl  user_message_$read_message entry (ptr, ptr, fixed bin (35));


/* EXTERNAL STATIC */

dcl  (
     as_error_table_$no_connect_aclass,
     as_error_table_$no_such_process_msg
     ) fixed bin (35) external static;

dcl  (
     error_table_$action_not_performed,
     error_table_$bad_arg,
     error_table_$bad_conversion,
     error_table_$bad_mode,
     error_table_$badopt,
     error_table_$fatal_error,
     error_table_$inconsistent,
     error_table_$long_record,
     error_table_$noarg,
     error_table_$no_message,
     error_table_$smallarg,
     error_table_$timeout,
     error_table_$too_many_args,
     error_table_$unimplemented_version,
     error_table_$user_requested_hangup,
     error_table_$user_requested_logout,
     error_table_$wrong_no_of_args
     ) fixed bin (35) external static;

dcl  (
     iox_$user_input,
     iox_$user_io
     ) pointer external static;

dcl  ls_data_$suffix (0:9) char (4) external static;
dcl  ls_data_$teens_suffix (0:9) char (4) external static;

dcl  (
     ls_message_table_$aclass_banner_msg,
     ls_message_table_$already_logged_in,
     ls_message_table_$authorization,
     ls_message_table_$bad_password_check,
     ls_message_table_$bad_password_format,
     ls_message_table_$connect_requests,
     ls_message_table_$connected,
     ls_message_table_$connected_after_new_proc,
     ls_message_table_$cost_message,
     ls_message_table_$current_modes,
     ls_message_table_$current_terminal_id,
     ls_message_table_$current_terminal_type,
     ls_message_table_$default_auth_changed,
     ls_message_table_$default_project_changed,
     ls_message_table_$dial_connect_msg,
     ls_message_table_$dialed_to_mc,
     ls_message_table_$disconnected_processes,
     ls_message_table_$dropped_by_mc,
     ls_message_table_$generated_password,
     ls_message_table_$generated_password_error,
     ls_message_table_$give_instructions,
     ls_message_table_$greeting_msg,
     ls_message_table_$hangup,
     ls_message_table_$help_gpw_verify,
     ls_message_table_$help_new_password,
     ls_message_table_$help_npw_verify,
     ls_message_table_$help_password,
     ls_message_table_$incorrect_passwords,
     ls_message_table_$last_login,
     ls_message_table_$list_process,
     ls_message_table_$list_proc_header,
     ls_message_table_$login,
     ls_message_table_$login_args,
     ls_message_table_$login_excess_wakeups,
     ls_message_table_$login_requests,
     ls_message_table_$login_timeout,
     ls_message_table_$logout,
     ls_message_table_$logout_disconnected,
     ls_message_table_$multiple_login_msg,
     ls_message_table_$must_give_process_no,
     ls_message_table_$new_password,
     ls_message_table_$new_password_again,
     ls_message_table_$new_password_error,
     ls_message_table_$new_password_indistinct,
     ls_message_table_$no_connect_aclass,
     ls_message_table_$no_disconnected_processes,
     ls_message_table_$no_such_process,
     ls_message_table_$password,
     ls_message_table_$password_changed,
     ls_message_table_$password_expired,
     ls_message_table_$password_format_warning,
     ls_message_table_$password_quit,
     ls_message_table_$password_unused_too_long,
     ls_message_table_$please_try_again,
     ls_message_table_$process_destroyed,
     ls_message_table_$requesting_dial_to_mc,
     ls_message_table_$special_session,
     ls_message_table_$user_required_for_dial
     ) fixed bin (35) external static;

dcl  ls_ssu_request_tables_$connect_requests fixed bin external static;
dcl  ls_ssu_request_tables_$enabled_standard_requests fixed bin external static;
dcl  ls_ssu_request_tables_$login_requests fixed bin external static;

dcl  (
     ssu_et_$program_interrupt,
     ssu_et_$request_line_aborted,
     ssu_et_$subsystem_aborted
     ) fixed bin (35) external static;

/* INTERNAL STATIC */

dcl  BS char (1) int static options (constant) initial (""); /* backspace */
dcl  CONSTANT_MASK char (72) internal static options (constant)
	initial ("QMQMQMQMQMQM" || (12)"" || "XWXWXWXWXWXW" || (12)"" || "986543435689" || (12)"");
						/* constant part of password mask -- contains backspaces between graphic strings */
dcl  DONT_FORCE_MESSAGE bit (1) int static options (constant) init ("0"b);
dcl  DONT_TAKE_DUMP bit (1) aligned int static options (constant) init ("0"b);
dcl  DONT_TELL_INITIALIZER bit (1) aligned int static options (constant) init ("0"b);
dcl  DONT_TELL_USER bit (1) aligned int static options (constant) init ("0"b);
dcl  DOT char (1) internal static options (constant) initial (".");
dcl  FALSE bit (1) int static options (constant) init ("0"b);
dcl  FORCE_MESSAGE bit (1) int static options (constant) init ("1"b);
dcl  HELP_GI_REQUEST char (17) internal static options (constant) initial ("help general_info");
dcl  HYPHEN char (1) internal static options (constant) initial ("-");
dcl  LARGE_NUMBER fixed bin internal static options (constant) initial (100000);
						/* for adding standard request table at end */
dcl  LS_DIALOGUE_NAME char (14) internal static options (constant) initial ("login_dialogue");
dcl  LS_DIALOGUE_VERSION char (4) internal static options (constant) initial ("1.0 ");
dcl  NL char (1) internal static options (constant) initial ("
");
dcl  ONE_MILLION fixed bin (35) internal static options (constant) initial (1000000);
dcl  OUR_NAME char (17) internal static options (constant) initial ("ls_validate_user_");
dcl  RANDOM_ALPHABET char (40) aligned int static init ("etaiosqwertyuioplkjhgfdsazxcvbnmqhpwygdj");
						/* For variable part of password mask */
dcl  SP char (1) int static options (constant) init (" ");
dcl  SPSP char (2) int static options (constant) init ("  ");
dcl  SPACE_SEMICOLON char (2) internal static options (constant) initial (" ;");
dcl  SYSTEM_DIAL_ID char (6) internal static options (constant) initial ("system");
dcl  SYSTEM_LOW bit (72) int static options (constant) init (""b);
dcl  TAKE_DUMP bit (1) aligned int static options (constant) init ("1"b);
dcl  TELL_INITIALIZER bit (1) aligned int static options (constant) init ("1"b);
dcl  TELL_USER bit (1) aligned int static options (constant) init ("1"b);
dcl  THREE_MINUTES fixed bin (71) internal static options (constant) initial (180000000);
dcl  TRUE bit (1) int static options (constant) init ("1"b);
dcl  system_areap pointer internal static initial (null ());


/* BUILTINS & CONDITIONS */

dcl  (addr, after, before, bit, clock, copy, currentsize, divide, float, hbound, index, lbound, length, max, mod, null,
     rank, rtrim, search, size, string, substr, translate, unspec) builtin;

dcl  (cleanup, io_error) condition;

	ls_cp_info_ptr = a_ls_cp_info_ptr;
	ls_validate_options_ptr = a_ls_validate_options_ptr;
	ls_process_info_ptr = a_process_info_ptr;

	if system_areap = null ()
	then system_areap = get_system_free_area_ ();

	ls_connection_desc_ptr = ls_cp_info.connection_desc_ptr;

	if ls_process_info.version ^= LS_PROCESS_INFO_V1
	then do;
	     a_code = error_table_$unimplemented_version;
	     return;
	end;

	unspec (auto_validate_info) = ""b;
	auto_validate_info.cp_info_ptr = ls_cp_info_ptr;
	auto_validate_info.options_ptr = ls_validate_options_ptr;
	auto_validate_info.process_info_ptr = ls_process_info_ptr;
	auto_validate_info.connection_desc_ptr = ls_cp_info.connection_desc_ptr;
	auto_validate_info.process_request_ptr = null ();
	auto_validate_info.brief = ls_validate_options.brief;
	auto_validate_info.minimum_ring = ls_connection_desc.minimum_ring;
	auto_validate_info.connection_name = ls_connection_desc.name;
	auto_validate_info.access_class_range = ls_connection_desc.access_class_range;
	ls_validate_info_ptr = addr (auto_validate_info);
	call Change_state (JUST_CONNECTED);

	sci_ptr = null ();
	on cleanup
	     begin;
	     if ls_validate_info.process_request_ptr ^= null ()
						/* which means lower-level cleanup handler didn't get it */
	     then free ls_validate_info.process_request_ptr -> login_server_process_request in (system_area);

	     if auto_validate_info.reply_channel ^= 0 then
		call ipc_$delete_ev_chn (auto_validate_info.reply_channel,
		code);

	     if sci_ptr ^= null ()
	     then call ssu_$destroy_invocation (sci_ptr);

	     call Change_state (DISCONNECTED);
	end;

	call ssu_$create_invocation (LS_DIALOGUE_NAME, LS_DIALOGUE_VERSION, addr (auto_validate_info),
	     addr (ls_ssu_request_tables_$login_requests), ls_cp_info.login_info_dir, sci_ptr, code);

	if code ^= 0
	then do;
	     call ls_report_subr_error_ (code, OUR_NAME, ls_cp_info_ptr,
		"ssu_$create_invocation", TELL_USER, TAKE_DUMP);
	     call Hangup (DONT_TELL_INITIALIZER);
	     a_code = code;
	     return;
	end;

	auto_validate_info.sci_ptr = sci_ptr;

	call ssu_$set_procedure (sci_ptr, "cpescape", ssu_$cpescape_disabled, code);
						/* don't want ".." escapes in login dialogue */
	if code ^= 0
	then do;
	     subr_name = "ssu_$set_procedure";
	     go to NO_SETUP;
	end;

	call ssu_$add_request_table (sci_ptr, addr (ls_ssu_request_tables_$enabled_standard_requests), LARGE_NUMBER,
	     code);
	if code ^= 0
	then do;
	     subr_name = "ssu_$add_request_table";
	     go to NO_SETUP;
	end;

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* Disable iteration in requests.				       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	call ssu_$get_request_processor_options (sci_ptr, RP_OPTIONS_VERSION_1, addr (auto_rp_options), code);
	if code ^= 0
	then do;
	     subr_name = "ssu$get_request_processor_options";
	     go to NO_SETUP;
	end;
	auto_rp_options.non_standard_language = "1"b;
	auto_rp_options.character_types (rank ("(")), auto_rp_options.character_types (rank (")")),
	     auto_rp_options.character_types (rank ("[")), auto_rp_options.character_types (rank ("]")),
	     auto_rp_options.character_types (rank (";")) = NORMAL_CHARACTER;
	call ssu_$set_request_processor_options (sci_ptr, addr (auto_rp_options), code);
	if code ^= 0
	then do;
	     subr_name = "ssu_$set_request_processor_options";
	     go to NO_SETUP;
	end;

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* Setup procedure to look for special session login word.		       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	call ssu_$set_procedure (sci_ptr, "unknown_request", unknown_request, code);
	if code ^= 0
	then do;
	     subr_name = "ssu_$set_procedure";
	     go to NO_SETUP;
	end;

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* Establish procedure and data to measure wakeup frequency.  Login aborted  */
/* if the wakeups (incoming lines) are too frequent.		       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	ls_validate_info.wakeup_loop.recent_wakeup_time = clock ();
	ls_validate_info.wakeup_loop.recent_wakeup_count = 1;
	call ssu_$get_procedure (sci_ptr, "execute_line", ls_validate_info.wakeup_loop.real_execute_line, code);
	if code ^= 0
	then do;
	     subr_name = "ssu_$get_procedure";
	     go to NO_SETUP;
	end;
	call ssu_$set_procedure (sci_ptr, "execute_line", COUNT_WAKEUP_FOR_REQUEST_LINE, code);
	if code ^= 0
	then do;
	     subr_name = "ssu_$set_procedure";
	     go to NO_SETUP;
	end;

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* Turn off ssu_ prompting for request lines.			       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	call ssu_$set_prompt_mode (sci_ptr, DONT_PROMPT | DONT_PROMPT_AFTER_NULL_LINES | DONT_PROMPT_IF_TYPEAHEAD);


	call ipc_$create_ev_chn (auto_validate_info.reply_channel, code);
						/* set up event channel for as_request replies */
	if code ^= 0
	then do;
	     subr_name = "ipc_$create_ev_chn";
	     go to NO_SETUP;
	end;

	auto_validate_info.server_handle = bit (clock (), 72);

	on io_error				/* connection must be gone, prior to entering */
	     begin;				/* ssu_$listen; we cannot call ssu_$abort_subsystem */
						/* here, for it would try to write on connection */
	     call Hangup_no_message (DONT_TELL_INITIALIZER);
	     ls_validate_info.code = error_table_$fatal_error;
	     subr_name = "io_error condition";
	     go to NO_SETUP;			/* calling ssu_$abort_subsystem here would cause */
						/* ssu_ to print message, causing resignal of */
	end;					/* io_error condition, and infinite loop! */

	if ^ls_validate_options.not_first | ^ls_process_info.terminal_info_set
	then call Read_answerback ();			/* this will also set initial terminal type */
						/* and do all the necessary mode-setting */
	else do;
	     auto_validate_info.user_connection_info.terminal_type = ls_process_info.terminal_type;
	     auto_validate_info.user_connection_info.terminal_id = ls_process_info.terminal_id;
	     auto_validate_info.user_connection_info.line_type = ls_process_info.line_type;
	end;

	call Write_greeting_message (DONT_FORCE_MESSAGE);

	call Change_state (AWAITING_INITIAL_REQUEST);

	on io_error				/* ready to enter ssu_$listen; can now call */
	     begin;				/* ssu_$abort_subsystem if connection is gone */
	     call Hangup_no_message (ls_validate_info.initializer_handle ^= ""b);
	     ls_validate_info.code = error_table_$fatal_error;
	     call ssu_$abort_subsystem (sci_ptr);
	end;

	call ssu_$listen (sci_ptr, null (), code);

	call Change_state (USER_VALIDATED);

	if ls_cp_info.trace
	then call dsa_log_manager_$trace_message (LS_CALLER_TYPE, OUR_NAME, INFO_LOG_SEVERITY, auto_validate_info.code,
		null (), 0, "", "(validate_info.code) returned from ssu_$listen.");

	if code = ssu_et_$subsystem_aborted
	then a_code = auto_validate_info.code;
	else do;
	     call ls_report_subr_error_ (code, OUR_NAME, ls_cp_info_ptr,
		"ssu_$listen", DONT_TELL_USER, TAKE_DUMP);
	     a_code = code;
	end;

DESTROY:
          call ipc_$delete_ev_chn (auto_validate_info.reply_channel, code);
	call ssu_$destroy_invocation (sci_ptr);

	return;

NO_SETUP:
	call ls_report_subr_error_ (code, OUR_NAME, ls_cp_info_ptr,
	     subr_name, TELL_USER, TAKE_DUMP);
	call Hangup (DONT_TELL_INITIALIZER);
	a_code = code;
	go to DESTROY;

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* ALARM CALL HANDLERS					       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* LOGIN_TIMEOUT:						       */
/*    alarm call triggered entry, called installation_parms.login_time       */
/*    seconds after starting to login, to cause the login attempt to	       */
/*    timeout.  If the user does not login within this many seconds, the     */
/*    connection is dropped.  It is an entry rather than an internal	       */
/*    procedure so that procedures it calls (eg, Hangup_with_error)	       */
/*    can remain quick.  It is also an entry rather than an internal proc    */
/*    so that it gets passed to timer_manager_ with a null environment ptr.  */
/*    This allows any invocation of ls_validate_user_ (eg, the one calling   */
/*    ssu_$listen, the one invoked for each request, the one invoked for     */
/*    an alarm call) to reset the timer, and establish a new timer than any  */
/*    other invocation can later reset.				       */
/* LOGIN_TIMEOUT_CHECK:					       */
/*    establishes the alarm call timer for login timeouts.		       */
/* LOGIN_TIMEOUT_CHECK_stop:					       */
/*    turns off the alarm call.				       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

LOGIN_TIMEOUT:
     entry (a_mc_ptr, a_cond_name, a_wc_ptr, a_data_ptr);
	ls_validate_info_ptr = a_data_ptr;
	if login_timeout_check_required (ls_validate_info.state)
	then do;
	     sci_ptr = ls_validate_info.sci_ptr;
	     ls_cp_info_ptr = ls_validate_info.cp_info_ptr;
	     ip = ls_cp_info.installation_parms_ptr;
	     call ls_message_$print (ls_message_table_$login_timeout, Minutes (installation_parms.login_time),
		Minutes (installation_parms.login_time) ^= 1.0);
	     call Hangup_with_error (error_table_$timeout, DONT_TELL_INITIALIZER);
	end;
	else ;					/* ignore timeout if login just completed. */
	return;


LOGIN_TIMEOUT_CHECK:
     procedure;
	ip = ls_cp_info.installation_parms_ptr;
	call timer_manager_$alarm_call ((installation_parms.login_time), RELATIVE_SECONDS, LOGIN_TIMEOUT,
	     ls_validate_info_ptr);
	return;
LOGIN_TIMEOUT_CHECK_stop:
     entry;
	call timer_manager_$reset_alarm_call (LOGIN_TIMEOUT, ls_validate_info_ptr);
     end LOGIN_TIMEOUT_CHECK;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* PRINT_BANNER_IF_CHANGED:					       */
/*    alarm call triggered entry, called every 3 minutes to check if	       */
/*    greeting banner changes so the new banner can be printed on the	       */
/*    connection if it's still waiting for the login request.  It is an      */
/*    entry rather than an internal procedure so that procedures it calls    */
/*    (eg, Write_greeting_message) can remain quick.		       */
/* PRINT_CHANGED_BANNER:					       */
/*    checks for change, and actually prints the banner.		       */
/* WATCH_FOR_CHANGED_BANNER:					       */
/*    turns on the alarm call.				       */
/* WATCH_FOR_CHANGED_BANNER_stop:				       */
/*    turns off the alarm call.				       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

PRINT_BANNER_IF_CHANGED:
     entry (a_mc_ptr, a_cond_name, a_wc_ptr, a_data_ptr);

	ls_validate_info_ptr = a_data_ptr;
	call PRINT_CHANGED_BANNER ();
	return;



PRINT_CHANGED_BANNER:
     procedure;

	if ls_validate_info.state = AWAITING_INITIAL_REQUEST
	then do;
	     if ls_validate_info.cp_info_ptr -> ls_cp_info.answer_table_ptr -> anstbl.message_update_time
		> ls_validate_info.banner_checked_time
	     then do;
		call ioa_ ("");			/* put out blank line */
		call Write_greeting_message (FORCE_MESSAGE);
		call iox_$control (iox_$user_io, "start", null (), (0));
	     end;					/* in case this is necessary */
	     call WATCH_FOR_CHANGED_BANNER ();
	end;
     end PRINT_CHANGED_BANNER;


WATCH_FOR_CHANGED_BANNER:
     procedure;
	ls_validate_info.banner_checked_time = clock ();
	call timer_manager_$alarm_call (THREE_MINUTES, RELATIVE_MICROSECONDS, PRINT_BANNER_IF_CHANGED,
	     ls_validate_info_ptr);
	return;

WATCH_FOR_CHANGED_BANNER_stop:
     entry;
	call timer_manager_$reset_alarm_call (PRINT_BANNER_IF_CHANGED, ls_validate_info_ptr);
     end WATCH_FOR_CHANGED_BANNER;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/*  SSU_ REPLACEMENT PROCEDURES				       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* COUNT_WAKEUP_FOR_REQUEST_LINE:				       */
/* This is a replacement for the ssu_$execute_line procedure.  It is invoked */
/* for each request line (eg, login) typed by the user.		       */
/* 1) Check for excessive incoming wakeups.			       */
/* 2) If high rate found, hangup the terminal.			       */
/* 3) Otherwise, execute the request line via the normal ssu_ mechanisms.    */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

COUNT_WAKEUP_FOR_REQUEST_LINE:
     entry (a_sci_ptr, a_request_line_ptr, a_request_line_len, a_code);

dcl  a_request_line_ptr ptr parameter;
dcl  a_request_line_len fixed bin (21) parameter;

	sci_ptr = a_sci_ptr;
	ls_validate_info_ptr = ssu_$get_info_ptr (sci_ptr);
	call Count_wakeups ();
	call ls_validate_info.wakeup_loop.real_execute_line (a_sci_ptr, a_request_line_ptr, a_request_line_len, a_code);
	return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* LOGIN REQUESTS:						       */
/*   access_class, acc   enter, e     hello      noecho		       */
/*   dial, d             enterp, ep   login, l   terminal_id, tid	       */
/*   echo                hangup       modes      terminal_type, ttp	       */
/*							       */
/* In addition, the "unknown_request" handler in included in this group, to  */
/* field special session logins that use a system-generated login number or  */
/* operator-specified login word.				       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

access_class:
     entry (a_sci_ptr, a_info_ptr);

/* display the connection's access class range */

	sci_ptr = a_sci_ptr;
	ls_validate_info_ptr = a_info_ptr;

	call ssu_$arg_count (sci_ptr, number_of_args);	/* there shouldn't be any */
	if number_of_args ^= 0
	then call ssu_$abort_line (sci_ptr, error_table_$too_many_args, "This request takes no arguments.");

	ls_connection_desc_ptr = ls_validate_info.connection_desc_ptr;
	call convert_authorization_$to_string_range (ls_connection_desc.access_class_range, auth_range_string, code);

	if code ^= 0 & code ^= error_table_$smallarg
	then call ls_report_subr_error_ (code, OUR_NAME,
	     ls_validate_info.cp_info_ptr,
	     "convert_authorization_$to_string_range", TELL_USER, TAKE_DUMP);
	else call ls_message_$print (ls_message_table_$aclass_banner_msg, auth_range_string);

	return;

dial:
     entry (a_sci_ptr, a_info_ptr);

/* the "dial" request is for connection as a "slave" to an existing process, identified
   by a dial qualifier and optionally by a user ID. The user entering the dial
   request may also identify himself (or may be required to do so) by means of
   the -user control argument.
*/

	sci_ptr = a_sci_ptr;
	ls_validate_info_ptr = a_info_ptr;

	call ssu_$arg_list_ptr (sci_ptr, arg_list_ptr);
	call Parse_dial_args ();
	ls_validate_info.mask_needed = mask_needed;

	ls_request_ptr, ls_response_ptr = null ();
	on cleanup call Cleanup_handler ();

	ls_process_info_ptr = ls_validate_info.process_info_ptr;
	ls_process_info.server_handle = ls_validate_info.server_handle;

	if user_specified
	then do;					/* have to get password and validate user */
	     ls_request_ptr = addr (auto_validate_request);

	     call Get_initial_password (code);

	     if code ^= 0
	     then go to RESTART_DIAL;

	     login_server_validate_request.person_id = dial_person;
	     login_server_validate_request.project_id = dial_project;
	     login_server_validate_request.authorization = authorization;
	     login_server_validate_request.terminate_event_channel =
		ls_validate_info.connection_desc_ptr -> ls_connection_desc.terminate_event_channel;
	     login_server_validate_request.network_connection_type = NETWORK_CONNECTION_LOGIN;
	     string (login_server_validate_request.flags) = ""b;
	     login_server_validate_request.auth_given = auth_specified;
	     login_server_validate_request.connection_info = ls_validate_info.user_connection_info;

	     call Send_request_to_initializer (LS_VALIDATE_REQUEST,
		LS_VALIDATE_REQUEST_VERSION_1,
		size (login_server_validate_request), "0"b,
		LS_VALIDATE_RESPONSE, ls_response_ptr, code);

	     call Process_validate_response (code);

	     ls_validate_info.initializer_handle =
		login_server_validate_response.handle;
	     ls_process_info.initializer_handle =
		ls_validate_info.initializer_handle;
	     dial_person = login_server_validate_response.person_id;
	     dial_project = login_server_validate_response.project_id;

	     free login_server_validate_response in (system_area);
	end;

	else do;					/* didn't say -user */
	     ls_validate_info.initializer_handle = ""b;	/* to make sure we start clean */
	     dial_person, dial_project = "";

	     if ls_validate_info.dial_id = SYSTEM_DIAL_ID
	     then go to USER_REQUIRED;		/* "dial system" always requires -user */

	     call net_info_$get_field ("endpoint",
		(ls_validate_info.connection_desc_ptr -> ls_connection_desc.endpoint_name),
		"user_required_for_dial", answer, code);
	     if code ^= 0
	     then do;
		call ls_report_subr_error_ (code, OUR_NAME,
		     ls_validate_info.cp_info_ptr, "net_info_$get_field",
		     TELL_USER, TAKE_DUMP);
		go to RESTART_DIAL;
	     end;

	     else if answer = "yes"
	     then do;
USER_REQUIRED:
		call ls_message_$print (
		     ls_message_table_$user_required_for_dial);
		go to RESTART_DIAL;
	     end;

	     ls_process_info.initializer_handle = ""b;	/* no UTE was created */
	end;

	if ls_validate_info.dial_id = SYSTEM_DIAL_ID
	then do;					/* "system" is special -- treat like operator login */
	     call Login_operator (dial_person, dial_project, "", code);
	     if code ^= 0
	     then go to RESTART_DIAL;
	end;

	else do;
	     ls_request_ptr = addr (auto_dial_request);

	     login_server_dial_request.initializer_handle = ls_validate_info.initializer_handle;
	     login_server_dial_request.terminate_event_channel =
		ls_validate_info.connection_desc_ptr ->
		ls_connection_desc.terminate_event_channel;
	     login_server_dial_request.dial_qualifier =
		ls_validate_info.dial_id;
	     login_server_dial_request.person_id =
		ls_validate_info.person_id;
	     login_server_dial_request.project_id =
		ls_validate_info.project_id;
	     login_server_dial_request.connection_info =
		ls_validate_info.user_connection_info;
	     login_server_dial_request.user_person_id = dial_person;
	     login_server_dial_request.user_project_id = dial_project;

	     call Send_request_to_initializer (LS_DIAL_REQUEST, LS_DIAL_REQUEST_VERSION_1,
		size (login_server_dial_request), "0"b, LS_DIAL_RESPONSE, ls_response_ptr, code);

	     if code ^= 0
	     then do;
		call ssu_$print_message (sci_ptr, code);
		if ls_response_ptr ^= null ()
		then free login_server_dial_response in (system_area);
		go to RESTART_DIAL;
	     end;

/* now look at response and see if it worked */

	     if login_server_dial_response.status_code ^= 0
	     then do;
		ls_validate_info.code = ls_convert_as_error_code_ (
		     login_server_dial_response.status_code);
		call ls_message_$print_error (ls_validate_info.code);
		hangup_flag = login_server_dial_response.disconnect;

		free login_server_dial_response in (system_area);

		if hangup_flag
		then call Hangup_with_error (ls_validate_info.code, DONT_TELL_INITIALIZER);
		else go to RESTART_DIAL;
	     end;

/* otherwise, all is well, pass it back  */

	     ls_validate_info.code = 0;
	     ls_process_info.process_group_id =
		login_server_dial_response.process_group_id;
	     ls_process_info.start_event_channel =
		login_server_dial_response.start_event_channel;
	     ls_process_info.authorization =
		login_server_dial_response.authorization;
	     ls_process_info.process_id =
		login_server_dial_response.process_id;
	     ls_process_info.initial_ring =
		login_server_dial_response.process_ring;
	     ls_process_info.usage_type = LS_DIAL_USAGE;
	     ls_process_info.terminal_type = ls_validate_info.
		user_connection_info.terminal_type;
	     ls_process_info.terminal_id = ls_validate_info.
		user_connection_info.terminal_id;
	     ls_process_info.line_type = ls_validate_info.
		user_connection_info.line_type;
	     ls_process_info.flags.terminal_info_set = "1"b;

	     call ls_message_$print (ls_message_table_$dial_connect_msg,
		ls_validate_info.user_connection_info.terminal_type,
		ls_validate_info.user_connection_info.terminal_id,
		ls_process_info.process_group_id, date_time_$format (
		"system_time", clock (), "system_zone", "system_lang"));

	     free login_server_dial_response in (system_area);
	end;

	call ssu_$abort_subsystem (sci_ptr);		/* ALL DONE */
	return;

echo:
     entry (a_sci_ptr, a_info_ptr);

/* "echo" and "noecho" are pretty simple: just turn echoplex mode on or off */

	call Set_modes ("echoplex");
	return;



noecho:
     entry (a_sci_ptr, a_info_ptr);

	call Set_modes ("^echoplex");
	return;

enter:
     entry (a_sci_ptr, a_info_ptr);

/* "enter" request: create a process for an anonymous user */

	command_type = ENTER_REQ;
	go to ENTER_JOIN;


enterp:
     entry (a_sci_ptr, a_info_ptr);

/* "enterp" request: create a process for an anonymous user, but require a password */
	command_type = ENTERP_REQ;
ENTER_JOIN:
	sci_ptr = a_sci_ptr;
	ls_validate_info_ptr = a_info_ptr;
	ls_cp_info_ptr = ls_validate_info.cp_info_ptr;
	ansp = ls_cp_info.answer_table_ptr;
	anonymous = "1"b;
	arg_list_ptr = null ();
	request_name = ssu_$get_request_name (sci_ptr);
	go to LOGIN_JOIN;

hangup:
     entry (a_sci_ptr, a_info_ptr);

/* the "hangup" request causes the breaking of the connection with no further action */

	sci_ptr = a_sci_ptr;
	ls_validate_info_ptr = a_info_ptr;

	call Hangup ((ls_validate_info.initializer_handle ^= ""b));

	ls_validate_info.code = error_table_$user_requested_hangup;
	call ssu_$abort_subsystem (sci_ptr);
	return;

hello:
     entry (a_sci_ptr, a_info_ptr);

/* The "hello" request simply requests the (re)display of the "greeting" banner */

	sci_ptr = a_sci_ptr;
	ls_validate_info_ptr = a_info_ptr;

	call Write_greeting_message (FORCE_MESSAGE);
	return;					/* with no change of state */

help:
     entry (a_sci_ptr, a_info_ptr);

/* Normally this entry simply passes the help request along to the standard request; with
   no arguments, however, it translates it into a line that will cause the standard
   request to print the "general_info" info.
*/

	sci_ptr = a_sci_ptr;
	ls_validate_info_ptr = a_info_ptr;

	call ssu_$arg_count (sci_ptr, number_of_args);

	if number_of_args > 0			/* normal help request */
	then call ssu_requests_$help (sci_ptr, ls_validate_info_ptr);

	else do;
	     call ssu_$execute_line (sci_ptr, addr (HELP_GI_REQUEST), length (HELP_GI_REQUEST), code);

	     if code ^= 0				/* if it's not one of the "standard" ones, */
						/* we'd better report it */
	     then if code ^= ssu_et_$request_line_aborted & code ^= ssu_et_$subsystem_aborted
		     & code ^= ssu_et_$program_interrupt
		then call ls_report_subr_error_ (code, OUR_NAME,
		     ls_validate_info.cp_info_ptr, "ssu_$execute_line",
		     TELL_USER, TAKE_DUMP);
	end;

	return;					/* no change of state */

login:
     entry (a_sci_ptr, a_info_ptr);

/* the entry to handle the "login" request. Also contains common code used by "enter" and "enterp",
   and is branched into by the unknown_request handler if the "unknown" request
   turns out to be the login word.
*/

	sci_ptr = a_sci_ptr;
	ls_validate_info_ptr = a_info_ptr;
	ls_cp_info_ptr = ls_validate_info.cp_info_ptr;
	ansp = ls_cp_info.answer_table_ptr;
	arg_list_ptr = null ();
	anonymous = "0"b;
	command_type = LOGIN_REQ;
	request_name = ssu_$get_request_name (sci_ptr);

LOGIN_JOIN:					/* common for all of login, enter, enterp */
	if anstbl.login_word ^= "login" & anstbl.login_word ^= "l"
						/* oops, special session */
	then do;
	     call ls_message_$print (ls_message_table_$special_session);
	     go to TRY_AGAIN;
	end;

ACTUALLY_LOGIN:					/* we branch to here from unknown_request if it was */
						/* a special-session login word */
	ls_request_ptr, ls_response_ptr = null ();
	on cleanup call Cleanup_handler ();

	if arg_list_ptr = null ()
	then call ssu_$arg_list_ptr (sci_ptr, arg_list_ptr);

	call cu_$arg_count_rel (number_of_args, arg_list_ptr, (0));
	if number_of_args < 1
	then do;
	     call Get_and_process_login_args (TRY_AGAIN);
	     return;
	end;

	call Parse_login_args ();
	if terminal_type ^= ""			/* user specified terminal type */
	then call Set_terminal_type (terminal_type);
	if mode_string ^= ""			/* user specified modes */
	then call Set_modes (mode_string);

	if terminal_id ^= ""
	then call Set_term_id (terminal_id);

	ls_validate_info.brief = brief;
	ls_validate_info.mask_needed = mask_needed;

	ls_request_ptr = addr (auto_validate_request);

	if command_type ^= ENTER_REQ			/* if password required */
	then do;
	     call Get_initial_password (code);
	     if code ^= 0
	     then go to RESTART_LOGIN;

	     if generate_password
	     then do;
		ip = ls_cp_info.installation_parms_ptr;
		gpw_length = max (installation_parms.password_gpw_length, installation_parms.password_min_length, 1);
REGENERATE_PASSWORD:
		call generate_word_ (new_password_generated, new_password_hyphenated, gpw_length,
		     length (new_password));
		new_password = scramble_ (new_password_generated);
		if login_server_validate_request.current_password = new_password
		then go to REGENERATE_PASSWORD;
		call ls_message_$print (ls_message_table_$generated_password, new_password_generated,
		     new_password_hyphenated);
		new_password_generated, new_password_hyphenated = "";

CHECK_GENERATED_PASSWORD:
		call ls_message_$print_nnl (ls_message_table_$new_password);
		call Get_password (second_new_password, quit_flag, help_flag, code);

		if quit_flag
		then go to RESTART_LOGIN;
		else if help_flag
		then do;
		     call ls_message_$print (ls_message_table_$help_gpw_verify);
		     go to CHECK_GENERATED_PASSWORD;
		end;

		else if code ^= 0 | second_new_password ^= new_password
		then do;
		     call ls_message_$print (ls_message_table_$generated_password_error);
		     go to CHECK_GENERATED_PASSWORD;
		end;
	     end;

	     else if change_password
	     then do;
GET_NEW_PASSWORD:
		call ls_message_$print_nnl (ls_message_table_$new_password);
		call Get_password (new_password, quit_flag, help_flag, code);

		if code ^= 0
		then go to RESTART_LOGIN;
		else if quit_flag
		then go to RESTART_LOGIN;
		else if help_flag
		then do;
		     call ls_message_$print (ls_message_table_$help_new_password);
		     go to GET_NEW_PASSWORD;
		end;

		if login_server_validate_request.current_password = new_password
		then do;
		     call ls_message_$print (ls_message_table_$new_password_indistinct);
		     go to RESTART_LOGIN;
		end;

NEW_PASSWORD_AGAIN:
		call ls_message_$print_nnl (ls_message_table_$new_password_again);
		call Get_password (second_new_password, quit_flag, help_flag, code);

		if code ^= 0
		then go to RESTART_LOGIN;
		else if quit_flag
		then go to RESTART_LOGIN;
		else if help_flag
		then do;
		     call ls_message_$print (ls_message_table_$help_npw_verify);
		     go to NEW_PASSWORD_AGAIN;
		end;

		if second_new_password ^= new_password
		then do;
		     call ls_message_$print (ls_message_table_$new_password_error);
		     go to GET_NEW_PASSWORD;
		end;
	     end;
	end;

/* we have ID and password (if any), now send validate request */

	login_server_validate_request.person_id = person_name;
	login_server_validate_request.project_id = project_name;
	login_server_validate_request.connection_info = ls_validate_info.user_connection_info;
	login_server_validate_request.terminal_id = ls_validate_info.user_connection_info.terminal_id;
	login_server_validate_request.authorization = authorization;
	login_server_validate_request.terminate_event_channel =
	     ls_validate_info.connection_desc_ptr -> ls_connection_desc.terminate_event_channel;
	login_server_validate_request.network_connection_type = NETWORK_CONNECTION_LOGIN;
	login_server_validate_request.gpw = generate_password;
	login_server_validate_request.auth_given = auth_specified;
	login_server_validate_request.anonymous = (command_type = ENTERP_REQ);
	login_server_validate_request.anon_no_password = (command_type = ENTER_REQ);
	login_server_validate_request.change_password = change_password | generate_password;
	login_server_validate_request.change_default_auth = cda;
	login_server_validate_request.change_default_proj = cdp;
	login_server_validate_request.operator = operator;
	login_server_validate_request.pad = ""b;
	login_server_validate_request.new_password = new_password;

	call Send_request_to_initializer (LS_VALIDATE_REQUEST, LS_VALIDATE_REQUEST_VERSION_1,
	     size (login_server_validate_request), "0"b, LS_VALIDATE_RESPONSE, ls_response_ptr, code);

	call Process_validate_response (code);

	ls_validate_info.initializer_handle =
	     login_server_validate_response.handle;
	ls_validate_info.person_id =
	     login_server_validate_response.person_id;
	ls_validate_info.project_id =
	     login_server_validate_response.project_id;
	ls_validate_info.n_disconnected_processes =
	     login_server_validate_response.n_disconnected_processes;
	ls_validate_info.previous_login_info =
	     login_server_validate_response.previous_login_info;

	ls_process_info_ptr = ls_validate_info.process_info_ptr;
	ls_process_info.authorization =
	     login_server_validate_response.authorization;
	ls_process_info.server_handle = ls_validate_info.server_handle;
	ls_process_info.initializer_handle =
	     ls_validate_info.initializer_handle;

	free login_server_validate_response in (system_area);

	if operator
	then do;					/* use operator request instead of process request */
	     call Login_operator ((ls_validate_info.person_id), (ls_validate_info.project_id), virtual_channel_name,
		code);
	     if code ^= 0
	     then go to TRY_AGAIN;

	     else call ssu_$abort_subsystem (sci_ptr);	/* we're finished */
	end;

	else do;

/* now we're ready to set up create request. First we have to get the login args (subject of -arguments arg) if any */

	     ls_process_request_n_args = number_of_args - first_arg_arg + 1;
	     if ls_process_request_n_args = 0
	     then ls_process_request_arg_string_length = 0;
	     else ls_process_request_arg_string_length = Get_total_arg_length ();

	     process_request_size = size (login_server_process_request);
						/* allowing for args */
	     allocate login_server_process_request in (system_area) set (ls_request_ptr);
	     ls_validate_info.process_request_ptr = ls_request_ptr;

/* now fill in the actual args */

	     call Get_arg_args ();
	     call Fill_in_process_request (command_type);

	     if command_type = LIST_REQ
	     then call List_request ();
	     else if command_type = ENTER_REQ | command_type = ENTERP_REQ
	     then do;				/* anonymous proc*/
						/* cannot be     */
						/* disconnected  */
		call Send_request_to_initializer (LS_PROCESS_REQUEST, LS_PROCESS_REQUEST_VERSION_1,
		     currentsize (login_server_process_request), "0"b, LS_PROCESS_RESPONSE, ls_response_ptr, code);

		call Process_process_response (code);
	     end;
	     else do;				/* login, create */
						/* et al can have*/
						/* disconnected  */
						/* processes.    */
		if ls_validate_info.n_disconnected_processes > 0
		then do;
		     call ls_message_$print (ls_message_table_$disconnected_processes,
			ls_validate_info.n_disconnected_processes, (ls_validate_info.n_disconnected_processes > 1));

		     if command_type ^= CREATE_REQ
		     then if command_type = LOGIN_REQ | ls_validate_info.n_disconnected_processes < process_number
			then do;
			     if command_type = LOGIN_REQ
			     then call ls_message_$print (ls_message_table_$give_instructions);
			     else call ls_message_$print (ls_message_table_$no_such_process, process_number);
			     call Enter_connect_loop ();
			     return;
			end;

			else if ls_validate_info.n_disconnected_processes > 1
			then if process_number = 0	/* process number omitted, ambiguous */
			     then do;
				call ls_message_$print (ls_message_table_$must_give_process_no);
				call Enter_connect_loop ();
				return;
			     end;
		end;

		else if command_type ^= LOGIN_REQ & command_type ^= CREATE_REQ
		then do;
		     call ls_message_$print (ls_message_table_$no_disconnected_processes);
		     call Enter_connect_loop ();
		     return;
		end;

		call Send_request_to_initializer (LS_PROCESS_REQUEST, LS_PROCESS_REQUEST_VERSION_1,
		     currentsize (login_server_process_request), "0"b, LS_PROCESS_RESPONSE, ls_response_ptr, code);

		call Process_process_response (code);
	     end;

	     return;
	end;

RESTART_LOGIN:
RESTART_DIAL:
TRY_AGAIN:
	call ls_message_$print (ls_message_table_$please_try_again);
	call Change_state (AWAITING_INITIAL_REQUEST);
	return;					/*  back to ssu_ listener */

modes:
     entry (a_sci_ptr, a_info_ptr);

/* set or print the terminal modes */

	sci_ptr = a_sci_ptr;
	ls_validate_info_ptr = a_info_ptr;

	call ssu_$arg_count (sci_ptr, number_of_args);
	if number_of_args > 1
	then call ssu_$abort_line (sci_ptr, error_table_$too_many_args);

	if number_of_args = 0
	then do;
	     call iox_$modes (iox_$user_io, "", mode_string, code);
	     if code ^= 0
	     then call ls_report_subr_error_ (code, OUR_NAME,
		ls_validate_info.cp_info_ptr, "iox_$modes", TELL_USER,
		DONT_TAKE_DUMP);

	     else call ls_message_$print (ls_message_table_$current_modes, mode_string);
	end;

	else do;
	     call ssu_$arg_ptr (sci_ptr, 1, argp, argl);
	     call Set_modes (arg);
	end;

	return;

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* The slave request is left over from the old answering service, and is not */
/* applicable in this context.				       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

slave:
     entry (a_sci_ptr, a_info_ptr);

	sci_ptr = a_sci_ptr;

	call ssu_$abort_line (sci_ptr, 0, "The ""slave"" request is not available on this type of connection.");
	return;

terminal_id:
     entry (a_sci_ptr, a_info_ptr);

/* set or print the terminal ID */

	sci_ptr = a_sci_ptr;
	ls_validate_info_ptr = a_info_ptr;

	call ssu_$arg_count (sci_ptr, number_of_args);
	if number_of_args > 1
	then call ssu_$abort_line (sci_ptr, error_table_$too_many_args);

	if number_of_args = 0
	then call ls_message_$print (ls_message_table_$current_terminal_id,
		ls_validate_info.user_connection_info.terminal_id);

	else do;
	     call ssu_$arg_ptr (sci_ptr, 1, argp, argl);
	     call Set_term_id (arg);
	end;

	return;

terminal_type:
     entry (a_sci_ptr, a_info_ptr);

/* set or print the terminal type */

	sci_ptr = a_sci_ptr;
	ls_validate_info_ptr = a_info_ptr;

	call ssu_$arg_count (sci_ptr, number_of_args);
	if number_of_args > 1
	then call ssu_$abort_line (sci_ptr, error_table_$too_many_args);

	if number_of_args = 0
	then call ls_message_$print (ls_message_table_$current_terminal_type,
		ls_validate_info.user_connection_info.terminal_type);

	else do;
	     call ssu_$arg_ptr (sci_ptr, 1, argp, argl);
	     call Set_terminal_type (arg);
	end;

	return;


/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* unknown request handler: it might be that the "unknown" request is	       */
/*   actually a special-session login word.			       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

unknown_request:
     entry (a_sci_ptr, a_info_ptr, a_request_name, a_arg_list_ptr, a_continue_sw);

	sci_ptr = a_sci_ptr;
	ls_validate_info_ptr = a_info_ptr;
	ls_cp_info_ptr = ls_validate_info.cp_info_ptr;
	ansp = ls_cp_info.answer_table_ptr;
	arg_list_ptr = a_arg_list_ptr;
	request_name = a_request_name;
	anonymous = "0"b;
	command_type = LOGIN_REQ;

	if anstbl.login_word = request_name		/* equivalent of "login" */
	then do;
	     a_continue_sw = "1"b;			/* we'll handle it, thanks */
	     go to ACTUALLY_LOGIN;
	end;

	else a_continue_sw = "0"b;			/* really unknown */
	return;

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* CONNECT LOOP REQUESTS:					       */
/*   connect   destroy   logout				       */
/*   create    list      new_proc				       */
/*							       */
/* The following several request entry points implement "connect loop"       */
/* requests, and are only included in the request table used when in the     */
/* connect loop.  They behave very similarly, and most of their work is done */
/* by the internal procedure Connect_loop_process_request.		       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

connect:
     entry (a_sci_ptr, a_info_ptr);

/* connect to an existing disconnected process */

	sci_ptr = a_sci_ptr;
	ls_validate_info_ptr = a_info_ptr;
	ls_cp_info_ptr = ls_validate_info.cp_info_ptr;

	ls_request_ptr, ls_response_ptr = null ();
	on cleanup call Cleanup_handler ();

	call Get_process_number ("0"b, "0"b, process_number, ("0"b), ("0"b));
	call Connect_loop_process_request (CONNECT_REQ, process_number, "0"b);
	return;


create:
     entry (a_sci_ptr, a_info_ptr);

/* create a new process */

	sci_ptr = a_sci_ptr;
	ls_validate_info_ptr = a_info_ptr;
	ls_cp_info_ptr = ls_validate_info.cp_info_ptr;

	ls_request_ptr, ls_response_ptr = null ();
	on cleanup call Cleanup_handler ();

	call Connect_loop_process_request (CREATE_REQ, 0, "0"b);
	return;


destroy:
     entry (a_sci_ptr, a_info_ptr);

/* destroy a disconnected process */

	sci_ptr = a_sci_ptr;
	ls_validate_info_ptr = a_info_ptr;
	ls_cp_info_ptr = ls_validate_info.cp_info_ptr;

	ls_request_ptr, ls_response_ptr = null ();
	on cleanup call Cleanup_handler ();

	call Get_process_number ("1"b, "1"b, process_number, immediate, hold_on_destroy);
	call Connect_loop_process_request (DESTROY_REQ, process_number, immediate);
	return;


list:
     entry (a_sci_ptr, a_info_ptr);

/* list the user's disconnected processes */

	sci_ptr = a_sci_ptr;
	ls_validate_info_ptr = a_info_ptr;
	ls_cp_info_ptr = ls_validate_info.cp_info_ptr;

	call List_request ();
	return;

logout:
     entry (a_sci_ptr, a_info_ptr);

	sci_ptr = a_sci_ptr;
	ls_validate_info_ptr = a_info_ptr;
	ls_cp_info_ptr = ls_validate_info.cp_info_ptr;

	hold, brief = "0"b;
	call ssu_$arg_count (sci_ptr, number_of_args);

	do this_arg = 1 to number_of_args;
	     call ssu_$arg_ptr (sci_ptr, this_arg, argp, argl);

	     if index (arg, HYPHEN) ^= 1
	     then call ssu_$abort_line (sci_ptr, error_table_$bad_arg, "^a", arg);

	     if arg = "-hold" | arg = "-hd"
	     then hold = "1"b;

	     else if arg = "-no_hold" | arg = "-nhd"
	     then hold = "0"b;

	     else if arg = "-brief" | arg = "-bf"
	     then brief = "1"b;

	     else if arg = "-long" | arg = "-lg"
	     then brief = "0"b;

	     else call ssu_$abort_line (sci_ptr, error_table_$badopt, arg);
	end;

	if ls_validate_info.initializer_handle ^= ""b
	then do;					/* if initializer has ever heard of us, */
						/* tell it we're going away */
	     ls_request_ptr = addr (auto_logout_request);
	     login_server_logout_request.handle = ls_validate_info.initializer_handle;
	     login_server_logout_request.connection_info = ls_validate_info.user_connection_info;
	     call Send_request_to_initializer (LS_LOGOUT_REQUEST, LS_LOGOUT_REQUEST_VERSION_1,
		size (auto_logout_request), "0"b, 0, (null ()), code);
	end;

	if code ^= 0
	then call ssu_$print_message (sci_ptr, code);
	call Logout (^hold, brief, error_table_$user_requested_logout);
	return;

new_proc:
     entry (a_sci_ptr, a_info_ptr);

/* execute new_proc in disconnected process */

	sci_ptr = a_sci_ptr;
	ls_validate_info_ptr = a_info_ptr;
	ls_cp_info_ptr = ls_validate_info.cp_info_ptr;

	ls_request_ptr, ls_response_ptr = null ();
	on cleanup call Cleanup_handler ();

	call Get_process_number ("1"b, "0"b, process_number, immediate, ("0"b));
	call Connect_loop_process_request (NEW_PROC_REQ, process_number, immediate);
	return;

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* INTERNAL PROCEDURES					       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* Change_state:						       */
/* 1) Set ls_validate_info.state to a new value.			       */
/* 2) If state is changing to AWAITING_INITIAL_REQUEST, establish timer to   */
/*    watch for a change to the login banner, and time login attempt.	       */
/* 3) If state is changing from AWAITING_INITIAL_REQUEST, turn off the       */
/*    timers.						       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

Change_state:
     procedure (new_state);

dcl  new_state fixed bin;

	if ls_validate_info.state = new_state
	then ;
	else if new_state = AWAITING_INITIAL_REQUEST
	then call WATCH_FOR_CHANGED_BANNER ();
	else if ls_validate_info.state = AWAITING_INITIAL_REQUEST
	then call WATCH_FOR_CHANGED_BANNER_stop ();

	if login_timeout_check_required (ls_validate_info.state) = login_timeout_check_required (new_state)
	then ;
	else if login_timeout_check_required (new_state)
	then call LOGIN_TIMEOUT_CHECK ();
	else if login_timeout_check_required (ls_validate_info.state)
	then call LOGIN_TIMEOUT_CHECK_stop ();

	ls_validate_info.state = new_state;

     end Change_state;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* cleanup on unit:						       */
/* 1) Free any allocated login_server requests or responses.	       */
/* 2) Change state to AWAITING_INITIAL_REQUEST.			       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

Cleanup_handler:
     procedure ();

	if ls_request_ptr ^= null ()
	then do;					/* check for "process" requests, which are */
						/*  the only kind we allocate */
	     if ls_request_header.request_type = LS_PROCESS_REQUEST
	     then do;
		if ls_validate_info.process_request_ptr = ls_request_ptr
						/* check to see if we've got another one hidden away */
		then ls_validate_info.process_request_ptr = null ();
						/* not any more we don't */
		free login_server_process_request in (system_area);
	     end;
	end;

	if ls_response_ptr ^= null ()			/* there's a response around, free it */
	then do;
	     if login_server_response_header.message_type = LS_VALIDATE_RESPONSE
	     then free login_server_validate_response in (system_area);
	     else if login_server_response_header.message_type = LS_PROCESS_RESPONSE
	     then free login_server_process_response in (system_area);
	     else if login_server_response_header.message_type = LS_LIST_RESPONSE
	     then free login_server_list_response in (system_area);
	     else if login_server_response_header.message_type = LS_DIAL_RESPONSE
	     then free login_server_dial_response in (system_area);
	     else if login_server_response_header.message_type = LS_OPERATOR_RESPONSE
	     then free login_server_operator_response in (system_area);
	end;

	call Change_state (AWAITING_INITIAL_REQUEST);

     end Cleanup_handler;

Connect_loop_process_request:
     procedure (command_type, process_number, immediate);

/* build a new process request, or (for a "create" request) update an already-allocated one,
   in response to a connect-loop request */

dcl  command_type fixed bin parameter;
dcl  process_number fixed bin parameter;
dcl  immediate bit (1) aligned parameter;

dcl  new_request bit (1) aligned;

	if command_type ^= CREATE_REQ & ls_validate_info.n_disconnected_processes > 1 & process_number = 0
						/* process number omitted, ambiguous */
	then do;
	     call ls_message_$print (ls_message_table_$must_give_process_no);
	     call Enter_connect_loop ();
	     return;
	end;

	ls_validate_info.process_number = process_number;
	if ls_validate_info.process_request_ptr ^= null ()
	then do;					/* use the process request that was filled in from the original login request */
	     new_request = "0"b;
	     ls_request_ptr = ls_validate_info.process_request_ptr;
	     login_server_process_request.command_type = command_type;
	     login_server_process_request.process_number = process_number;
	     login_server_process_request.connection_info = ls_validate_info.user_connection_info;
						/* some of this might have been changed by an intervening terminal_type request */
	end;

	else do;					/* allocate a fresh one */
	     ls_process_request_n_args = 0;
	     ls_process_request_arg_string_length = 0;
	     process_request_size = size (login_server_process_request);
	     allocate login_server_process_request in (system_area) set (ls_request_ptr);
	     new_request = "1"b;

/* initialize values that Fill_in_process_request will need, which otherwise would
   have been supplied on initial command line */

	     auth_specified, brief_specified, brief, warn_specified, force_specified, save_specified, preempt_specified,
		no_start_up, ring_specified = ""b;

	     outer_module, process_overseer, subsystem, home_dir = "";

	     call Fill_in_process_request (command_type);
	end;

	login_server_process_request.immediate = immediate;
	call Send_request_to_initializer (LS_PROCESS_REQUEST, LS_PROCESS_REQUEST_VERSION_1,
	     currentsize (login_server_process_request), new_request, LS_PROCESS_RESPONSE, ls_response_ptr, code);

	call Process_process_response (code);
	return;

     end Connect_loop_process_request;

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* COUNT_WAKEUPS:						       */
/* This procedure implements the wakeup loop counter.  Reading of a request  */
/* line, a password, answerback data, etc occurs via a wakeup.  Such wakeups */
/* coming at too fast a rate may indicating garbage transmissions of the     */
/* communication line.  This procedure detects high wakeup frequency and     */
/* hangs up the connection.					       */
/*							       */
/* An excessive rate is defined to be more than COUNT wakeups within	       */
/* INTERVAL seconds, where COUNT and INTERVAL are installation parameters.   */
/* Whenever we get through an interval with fewer than COUNT wakeups,	       */
/* we reset the counter and start a new interval.  Thus, in the most extreme */
/* case, we could get 2 * COUNT -1 wakeups within INTERVAL + DELTA before we */
/* decide to hang up.					       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

Count_wakeups:
     procedure;

dcl  code fixed bin (35);
dcl  current_time fixed bin (71);

	ls_cp_info_ptr = ls_validate_info.cp_info_ptr;
	ip = ls_cp_info.installation_parms_ptr;
	current_time = clock ();
	if ls_validate_info.wakeup_loop.recent_wakeup_time + installation_parms.chn_wakeup_error_loop_seconds * 1000000
	     < current_time
	then do;
	     ls_validate_info.wakeup_loop.recent_wakeup_count = 1;
	     ls_validate_info.wakeup_loop.recent_wakeup_time = current_time;
	end;
	else do;
	     ls_validate_info.wakeup_loop.recent_wakeup_count = ls_validate_info.wakeup_loop.recent_wakeup_count + 1;
	     if ls_validate_info.wakeup_loop.recent_wakeup_count > installation_parms.chn_wakeup_error_loop_count
	     then do;				/* wakeup loop rate exceeded. */
						/* reset the wakeup loop counters */
		ls_validate_info.wakeup_loop.recent_wakeup_time = 0;
		ls_validate_info.wakeup_loop.recent_wakeup_count = 0;
						/* we'll start counting again at next wakeup */
		call iox_$control (iox_$user_io, "abort", null, code);
		call ls_message_$print (ls_message_table_$login_excess_wakeups);
		call Hangup_with_error (error_table_$fatal_error, DONT_TELL_INITIALIZER);
	     end;
	end;
     end Count_wakeups;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


Enter_connect_loop:
     procedure ();

/* procedure to switch to (or remain in) connect loop: print instructions, set
   new request table if necessary
*/

	if ls_validate_info.n_disconnected_processes > 0
	then call ls_message_$print (ls_message_table_$connect_requests);
	else call ls_message_$print (ls_message_table_$login_requests);

	if ^ls_validate_info.connect_loop
	then do;
	     call ssu_$delete_request_table (sci_ptr, addr (ls_ssu_request_tables_$login_requests), (0));
	     call ssu_$add_request_table (sci_ptr, addr (ls_ssu_request_tables_$connect_requests), 1, code);
	     if code ^= 0
	     then do;
		call ls_report_subr_error_ (code, OUR_NAME,
		     ls_validate_info.cp_info_ptr,
		     "ssu_$add_request_table", TELL_USER, TAKE_DUMP);
		call Hangup_with_error (code, TELL_INITIALIZER);
	     end;

/* make sure "help" works for connect-loop requests */

	     call ssu_$delete_info_dir (sci_ptr, ls_cp_info.login_info_dir, (0));
	     call ssu_$add_info_dir (sci_ptr, ls_cp_info.connect_info_dir, 1, code);
	     if code ^= 0
	     then call ls_report_subr_error_ (code, OUR_NAME,
		ls_validate_info.cp_info_ptr, "ssu_$add_info_dir",
		TELL_USER, TAKE_DUMP);

	     ls_validate_info.connect_loop = "1"b;
	end;

	call Change_state (AWAITING_CONNECT_REQUEST);

	return;
     end Enter_connect_loop;

Fill_in_process_request:
     procedure (command_type);

/* this procedure puts together a login_server_process_request to pass to Send_request_to_initializer.
   The "process" request has already been allocated, and the login args already filled in.
*/

dcl  command_type fixed bin parameter;

	login_server_process_request.handle =
	     ls_validate_info.initializer_handle;
	login_server_process_request.person_id =
	     ls_validate_info.person_id;
	login_server_process_request.project_id =
	     ls_validate_info.project_id;
	login_server_process_request.connection_info =
	     ls_validate_info.user_connection_info;
	login_server_process_request.command_type = command_type;
	login_server_process_request.process_number =
	     ls_validate_info.process_number;
	login_server_process_request.default_io_module =
	     ls_validate_info.connection_desc_ptr ->
	     ls_connection_desc.io_module;

/* in case we're creating a process from login line, copy values set by Parse_login_args */

	login_server_process_request.warn_given = warn_specified;
	login_server_process_request.force_given = force_specified;
	login_server_process_request.save_given = save_specified;
	login_server_process_request.preempt_given = preempt_specified;
	login_server_process_request.brief_given = brief_specified;
	login_server_process_request.init_ring_given = ring_specified;
	login_server_process_request.minimum_ring_given = "1"b;
	login_server_process_request.warn = warn;
	login_server_process_request.force = force;
	login_server_process_request.save_on_disconnect = save;
	login_server_process_request.preempt = preempt;
	login_server_process_request.brief = brief;
	login_server_process_request.initial_ring = ring;
	login_server_process_request.minimum_ring =
	     ls_validate_info.minimum_ring;
	login_server_process_request.no_start_up = no_start_up;
	login_server_process_request.home_dir = home_dir;
	login_server_process_request.outer_module = outer_module;
	login_server_process_request.process_overseer = process_overseer;
	login_server_process_request.subsystem = subsystem;

	if command_type = NEW_PROC_REQ | command_type = DESTROY_REQ
	then login_server_process_request.immediate = immediate;

	return;
     end Fill_in_process_request;

Get_and_process_login_args:
     procedure (TRY_AGAIN);

dcl  TRY_AGAIN label parameter;

dcl  login_line char (100);
dcl  login_line_read fixed bin (21);

	call ls_message_$print (ls_message_table_$login_args);
	call Change_state (AWAITING_LOGIN_ARGS);
	call iox_$get_line (iox_$user_input, addr (login_line), length (login_line), login_line_read, code);
	if code ^= 0
	then do;
	     call ssu_$print_message (sci_ptr, code, "Reading login arguments.");
	     go to TRY_AGAIN;
	end;
	login_line = rtrim (request_name) || " " || substr (login_line, 1, login_line_read);
	call Change_state (AWAITING_INITIAL_REQUEST);
	call ssu_$execute_line (sci_ptr, addr (login_line), length (rtrim (login_line)), code);
	if code ^= 0
	then do;
	     call ssu_$print_message (sci_ptr, code, "Processing login arguments.");
	     go to TRY_AGAIN;
	end;

     end Get_and_process_login_args;

Get_arg_args:
     procedure ();

/* this procedure gets all the user-supplied arguments (i.e., sub-args of the
   "-ag" control arg) and fills them into the login_server_process_request structure.
*/

dcl  current_index fixed bin (21);
dcl  current_entry fixed bin;

	login_server_process_request.n_args = ls_process_request_n_args;
	login_server_process_request.arg_string_length = ls_process_request_arg_string_length;

	if ls_process_request_n_args > 0
	then do;
	     current_index = 1;
	     current_entry = 1;

	     do this_arg = first_arg_arg to number_of_args;
		call cu_$arg_ptr_rel (this_arg, argp, argl, (0), arg_list_ptr);

		login_server_process_request.args (current_entry).start_index = current_index;
		login_server_process_request.args (current_entry).arg_length = argl;
		substr (login_server_process_request.arg_string, current_index, argl) = arg;

		current_index = current_index + argl;
		current_entry = current_entry + 1;
	     end;
	end;

     end Get_arg_args;

Get_initial_password:
     procedure (code);

/* procedure to get current password initially for login or dial request */

dcl  code fixed bin (35) parameter;
dcl  quit_flag bit (1) aligned;
dcl  help_flag bit (1) aligned;


REREAD_PASSWORD:
	call ls_message_$print_nnl (ls_message_table_$password);
	call Get_password (login_server_validate_request.current_password, quit_flag, help_flag, code);

	if code ^= 0
	then return;

	if quit_flag
	then code = error_table_$action_not_performed;

	else if help_flag
	then do;
	     call ls_message_$print (ls_message_table_$help_password);
	     go to REREAD_PASSWORD;
	end;

	else code = 0;
	return;

     end Get_initial_password;

Get_password:
     procedure (result_password, quit_flag, help_flag, code);

dcl  result_password char (8) aligned parameter;
dcl  quit_flag bit (1) aligned parameter;		/* set to "1"b if response is "quit" */
dcl  help_flag bit (1) aligned parameter;		/* set to "1"b if response is "help" or "?" */
dcl  code fixed bin (35) parameter;

dcl  error_message char (64);
dcl  password char (8);

	result_password = "";
	quit_flag, help_flag = "0"b;
	code = 0;

	password = Read_password ();

	if search (rtrim (password), SPACE_SEMICOLON) ^= 0
	then do;
	     password = "";				/* keep possible typo hidden */
	     call ls_message_$print (ls_message_table_$bad_password_format);
	     code = error_table_$action_not_performed;
	end;

	else if password = "help" | password = "HELP" | password = "?"
	then help_flag = "1"b;

	else if password = "quit" | password = "QUIT"
	then do;
	     call ls_message_$print (ls_message_table_$password_quit);
	     quit_flag = "1"b;
	end;

	else do;
	     call check_password_ (password, error_message, code);
	     if code ^= 0				/* check password minimum length and content */
	     then do;
		password = "";
		call ls_message_$print (ls_message_table_$bad_password_check, error_message);
		code = error_table_$action_not_performed;
	     end;
	     else do;
		result_password = scramble_ (password);
		password = "";			/* cover this up as soon as possible */
	     end;
	end;

	return;

     end Get_password;

Get_process_number:
     procedure (immediate_allowed, hold_allowed, process_number, immediate, hold);

/* this procedure gets the (optional) arguments for the connect loop requests:
   process number, and possibly -immediate and/or -hold
*/

dcl  immediate_allowed bit (1) aligned parameter;
dcl  hold_allowed bit (1) aligned parameter;
dcl  process_number fixed bin parameter;
dcl  immediate bit (1) aligned parameter;
dcl  hold bit (1) aligned parameter;

	immediate = "0"b;
	hold = "1"b;
	process_number = 0;
	call ssu_$arg_count (sci_ptr, number_of_args);

	if number_of_args = 0
	then return;

	else if number_of_args > 3
	then call ssu_$abort_line (sci_ptr, error_table_$too_many_args);

	else do this_arg = 1 to number_of_args;
	     call ssu_$arg_ptr (sci_ptr, this_arg, argp, argl);

	     if index (arg, HYPHEN) = 1
	     then if (arg = "-immediate" | arg = "-im") & immediate_allowed
		then immediate = "1"b;

		else if (arg = "-hold" | arg = "-hd") & hold_allowed
		then hold = "1"b;

		else if (arg = "-no_hold" | arg = "-nhd") & hold_allowed
		then hold = "0"b;

		else call ssu_$abort_line (sci_ptr, error_table_$badopt, "^a", arg);

	     else do;
		if arg = ""
		then call ssu_$abort_line (sci_ptr, error_table_$bad_conversion, "Null value for process number.");
		process_number = cv_dec_check_ (arg, code);
		if code ^= 0
		then call ssu_$abort_line (sci_ptr, error_table_$bad_conversion, "^a", arg);
	     end;
	end;
	return;

     end Get_process_number;

Get_total_arg_length:
     procedure () returns (fixed bin (21));

/* this procedure returns the total length of the user-supplied arguments (i.e.,
   the sub-arguments of the "-ag" control arg)
*/

dcl  total_length fixed bin (21);

	total_length = 0;
	do this_arg = first_arg_arg to number_of_args;
	     call cu_$arg_ptr_rel (this_arg, argp, argl, (0), arg_list_ptr);
	     total_length = total_length + argl;
	end;

	return (total_length);
     end Get_total_arg_length;

Hangup:
     procedure (tell_initializer);

/* close the connection. the argument indicates whether a disconnect_request has to
   be sent to the Initializer, or whether the latter has already discarded it.
*/

dcl  tell_initializer bit (1) aligned parameter;

	call ls_message_$print (ls_message_table_$hangup);

Hangup_no_message:
     entry (tell_initializer);

	ls_connection_desc_ptr = ls_validate_info.connection_desc_ptr;
	login_service_entries_ptr = ls_connection_desc.service_entries_ptr;

	call login_service_entries
	     .disconnect ((ls_connection_desc.name), ls_connection_desc.connection_handle, ""b, code);

	if ls_validate_info.cp_info_ptr -> ls_cp_info.trace
	then call dsa_log_manager_$trace_message (LS_CALLER_TYPE, OUR_NAME, INFO_LOG_SEVERITY, code, null (), 0, "",
		"Disconnecting ^a", ls_connection_desc.name);

	if tell_initializer
	then do;
	     ls_request_ptr = addr (auto_hangup_request);
	     login_server_disconnect_request.handle = ls_validate_info.initializer_handle;
	     login_server_disconnect_request.process_id = ""b;
	     login_server_disconnect_request.connection_info = ls_validate_info.user_connection_info;

	     call Send_request_to_initializer (LS_DISCONNECT_REQUEST, LS_DISCONNECT_REQUEST_VERSION_1,
		size (auto_hangup_request), "0"b, 0, (null ()), (0));
	end;

	return;

     end Hangup;

Hangup_with_error:
     procedure (code, tell_initializer);

/* Called to wrap up when some unrecoverable disaster occurs */

dcl  code fixed bin (35) parameter;
dcl  tell_initializer bit (1) aligned parameter;

	ls_validate_info.code = code;
	call Hangup (tell_initializer);
	call ssu_$abort_subsystem (sci_ptr);
	return;

     end Hangup_with_error;

List_request:
     procedure ();

/* This procedure sends a "list" request, and displays the information provided in the response */

dcl  auth_case fixed bin;
dcl  (auth_col, chn_col, date_col, id_col, type_col) fixed bin;
dcl  auth_sw bit (1);
dcl  code fixed bin (35);
dcl  (chn_len, date_len, id_len, type_len) fixed bin;
dcl  n_processes fixed bin;
dcl  px fixed bin;

dcl  1 auto_list_request aligned like login_server_list_request;

	ls_request_ptr = addr (auto_list_request);

	login_server_list_request.connection_info =
	     ls_validate_info.user_connection_info;
	login_server_list_request.handle =
	     ls_validate_info.initializer_handle;

	ls_response_ptr = null ();
	on cleanup
	     begin;
	     if ls_response_ptr ^= null ()
	     then free login_server_list_response in (system_area);
	end;

	call Send_request_to_initializer (LS_LIST_REQUEST,
	     LS_LIST_REQUEST_VERSION_1, size (login_server_list_request),
	     "0"b, LS_LIST_RESPONSE, ls_response_ptr, code);

	if code ^= 0
	then call ssu_$print_message (sci_ptr, code);

	else do;
	     n_processes, ls_validate_info.n_disconnected_processes = login_server_list_response.n_processes;

	     if n_processes = 0
	     then call ls_message_$print (ls_message_table_$no_disconnected_processes);

	     else do;
		call ls_message_$print (ls_message_table_$disconnected_processes, n_processes, (n_processes > 1));

/* NOTE: the access_class_range in the user_connection_info substructure in
   the list_response is not accurate and is not to be used.  */

		date_len = date_time_$format_max_length ("system_date_time", "system_zone", "system_lang");
		chn_len = length ("CHANNEL");
		type_len = length ("TERM TYPE");
		id_len = length ("ID");
		auth_sw = FALSE;
		do px = 1 to n_processes;
		     chn_len = max (chn_len, length (rtrim (login_server_list_response.connection_name (px))));
		     type_len = max (type_len, length (rtrim (login_server_list_response.terminal_type (px))));
		     id_len = max (id_len, length (rtrim (login_server_list_response.terminal_id (px))));
		     if login_server_list_response.initial_ring (px) ^= 0
		     then auth_sw = TRUE;
		     if login_server_list_response.authorization (px) ^= SYSTEM_LOW
		     then auth_sw = TRUE;
		end;
		date_col = length ("NN.  D");
		chn_col = date_col + date_len + length (SPSP);
		type_col = chn_col + chn_len + length (SP);
		id_col = type_col + type_len + length (SP);
		if auth_sw
		then auth_col = id_col + id_len + length (SPSP);
		else auth_col = id_col + id_len;

		call ls_message_$print (ls_message_table_$list_proc_header, date_col, chn_col, type_col, id_col,
		     auth_col, auth_sw);

		do px = 1 to n_processes;
		     auth_case = 0;
		     if login_server_list_response.authorization (px) ^= SYSTEM_LOW
		     then auth_case = 2;
		     if login_server_list_response.initial_ring (px) ^= 0
		     then auth_case = auth_case + 1;
		     call ls_message_$print (ls_message_table_$list_process, px, date_col,
			date_time_$format ("system_date_time", login_server_list_response.creation_time (px),
			"system_zone", "system_lang"), chn_col, login_server_list_response.connection_name (px),
			type_col, login_server_list_response.terminal_type (px), id_col,
			login_server_list_response.terminal_id (px), auth_col, auth_case,
			login_server_list_response.initial_ring (px), login_server_list_response.authorization (px))
			;
		end;
	     end;
	end;

	if ls_response_ptr ^= null ()
	then free login_server_list_response in (system_area);
	call Enter_connect_loop ();
	return;

     end List_request;

Login_operator:
     procedure (a_person, a_project, a_virtual_channel, a_code);

/* procedure to send an operator_request and process the response. invoked when
   user enters "dial system" or "login...-operator".
*/

dcl  a_person char (22) parameter;
dcl  a_project char (9) parameter;
dcl  a_virtual_channel char (32) parameter;
dcl  a_code fixed bin (35) parameter;

dcl  1 auto_operator_request aligned like login_server_operator_request;

/* let the user know we're initiating the request -- it might be a while before the operator accepts */

	call ls_message_$print (ls_message_table_$requesting_dial_to_mc);

	ls_request_ptr = addr (auto_operator_request);

	login_server_operator_request.initializer_handle = ls_validate_info.initializer_handle;
	login_server_operator_request.terminate_event_channel =
	     ls_validate_info.connection_desc_ptr -> ls_connection_desc.terminate_event_channel;
	login_server_operator_request.person_id = a_person;
	login_server_operator_request.project_id = a_project;
	login_server_operator_request.virtual_channel = a_virtual_channel;
	login_server_operator_request.connection_info = ls_validate_info.user_connection_info;

	ls_response_ptr = null ();
	on cleanup
	     begin;
	     if ls_response_ptr ^= null ()
	     then free login_server_operator_response in (system_area);
	end;

	call Send_request_to_initializer (LS_OPERATOR_REQUEST, LOGIN_SERVER_OPERATOR_REQUEST_VERSION_1,
	     size (login_server_operator_request), "0"b, LS_OPERATOR_RESPONSE, ls_response_ptr, code);

	if code ^= 0
	then do;
	     call ssu_$print_message (sci_ptr, code);
	     if ls_response_ptr ^= null ()
	     then free login_server_operator_response in (system_area);
	     a_code = code;
	     return;
	end;

	if login_server_operator_response.status_code ^= 0
	then do;
	     ls_validate_info.code = ls_convert_as_error_code_ (login_server_operator_response.status_code);
	     if ls_validate_info.code = error_table_$action_not_performed
	     then call ls_message_$print (ls_message_table_$dropped_by_mc,
		     ls_validate_info.user_connection_info.connection_name);
	     else call ls_message_$print_error (ls_validate_info.code);
	     hangup_flag = login_server_operator_response.disconnect;

	     free login_server_operator_response in (system_area);

	     if hangup_flag
	     then do;
		call Hangup (DONT_TELL_INITIALIZER);
		call ssu_$abort_subsystem (sci_ptr);
	     end;

	     a_code = ls_validate_info.code;
	     return;
	end;

/* successfully connected to message coordinator */

	ls_validate_info.code = 0;
	ls_process_info.process_group_id = login_server_operator_response.process_group_id;
	ls_process_info.start_event_channel = login_server_operator_response.event_channel;
	ls_process_info.authorization = ""b;		/* like process_group_id */
	ls_process_info.process_id = login_server_operator_response.process_id;
	ls_process_info.initial_ring = login_server_operator_response.ring;
	ls_process_info.usage_type = LS_MC_USAGE;
	ls_process_info.terminal_type = ls_validate_info.user_connection_info.terminal_type;
	ls_process_info.terminal_id = ls_validate_info.user_connection_info.terminal_id;
	ls_process_info.line_type = ls_validate_info.user_connection_info.line_type;
	ls_process_info.flags.terminal_info_set = "1"b;

	call ls_message_$print (ls_message_table_$dialed_to_mc, ls_validate_info.user_connection_info.connection_name);

	free login_server_operator_response in (system_area);
	a_code = 0;
	return;

     end Login_operator;

Logout:
     procedure (hangup_flag, brief_flag, hangup_code);

/* procedure to terminate the dialogue, and either hang up or restart with the banner,
   depending on the value of hangup_flag */

dcl  hangup_flag bit (1) aligned parameter;
dcl  brief_flag bit (1) aligned parameter;
dcl  hangup_code fixed bin (35) parameter;

	if ^brief_flag
	then call ls_message_$print (ls_message_table_$logout_disconnected, ls_validate_info.person_id,
		ls_validate_info.project_id,
		date_time_$format ("system_date_time", clock (), "system_zone", "system_lang"));

	if hangup_flag
	then do;
	     call Hangup (DONT_TELL_INITIALIZER);
	     ls_validate_info.code = hangup_code;
	     call ssu_$abort_subsystem (sci_ptr);
	end;

/* now reinitialize the validate_info structure */

	if ls_validate_info.process_request_ptr ^= null ()
	then do;
	     free ls_validate_info.process_request_ptr -> login_server_process_request in (system_area);
	     ls_validate_info.process_request_ptr = null ();
	end;

	ls_validate_info.initializer_handle = ""b;
	ls_validate_info.n_disconnected_processes = 0;
	ls_validate_info.process_number = 0;
	ls_validate_info.validation_failures = 0;
	ls_validate_info.person_id = "";
	ls_validate_info.project_id = "";
	ls_validate_info.dial_id = "";

	if ls_validate_info.connect_loop
	then do;
	     call ssu_$delete_request_table (sci_ptr, addr (ls_ssu_request_tables_$connect_requests), (0));
	     call ssu_$add_request_table (sci_ptr, addr (ls_ssu_request_tables_$login_requests), 1, code);
	     if code ^= 0
	     then do;
		call ls_report_subr_error_ (code, OUR_NAME,
		     ls_validate_info.cp_info_ptr,
		     "ssu_$add_request_table", TELL_USER, TAKE_DUMP);
		call Hangup_with_error (code, TELL_INITIALIZER);
	     end;

/* make sure "help" doesn't find connect-loop requests */

	     call ssu_$delete_info_dir (sci_ptr, ls_cp_info.connect_info_dir, (0));
	     call ssu_$add_info_dir (sci_ptr, ls_cp_info.login_info_dir, 1, code);
	     if code ^= 0
	     then call ls_report_subr_error_ (code, OUR_NAME,
		ls_validate_info.cp_info_ptr, "ssu_$add_info_dir",
		TELL_USER, TAKE_DUMP);

	     ls_validate_info.connect_loop = "0"b;
	end;

	call ioa_ ("");				/* just put out newline */
	call Write_greeting_message (DONT_FORCE_MESSAGE);
	call Change_state (AWAITING_INITIAL_REQUEST);

	return;
     end Logout;

Minutes:
     procedure (seconds) returns (fixed decimal (5, 1)) reducible;

dcl  seconds fixed bin;
dcl  minutes fixed decimal (5, 1);
dcl  seconds_dec fixed decimal (7);
dcl  SECONDS_PER_MINUTE fixed decimal (2, 0) int static options (constant) init (60);

	seconds_dec = seconds;
	minutes = divide (seconds_dec, SECONDS_PER_MINUTE, 5, 1);
	return (minutes);
     end Minutes;

Parse_dial_args:
     procedure ();

dcl  keyword char (32);

	call cu_$arg_count_rel (number_of_args, arg_list_ptr, 0);

	if number_of_args < 1 | number_of_args > 6
	then call ssu_$abort_line (sci_ptr, error_table_$wrong_no_of_args,
		"^/Usage: dial dial_qualifier {Person.Project} {-control_args}");

	ls_validate_info.person_id, ls_validate_info.project_id = "";
	user_specified, auth_specified, mask_needed = "0"b;

	call cu_$arg_ptr_rel (1, argp, argl, 0, arg_list_ptr);
	ls_validate_info.dial_id = arg;		/* first arg is always the dial qualifier */

	do this_arg = 2 to number_of_args;
	     call cu_$arg_ptr_rel (this_arg, argp, argl, 0, arg_list_ptr);

	     if index (arg, HYPHEN) ^= 1
	     then do;				/* not control arg. must be Person.Project */
		if this_arg = 2
		then do;				/* User_id must be second arg if given. */
		     period_index = index (arg, DOT);
		     if period_index <= 1 | period_index >= length (arg)
		     then call ssu_$abort_line (sci_ptr, error_table_$bad_arg,
			     "Second argument must have the form Person.Project.");
		     else do;
			ls_validate_info.person_id = before (arg, DOT);
			ls_validate_info.project_id = after (arg, DOT);
		     end;
		end;
		else call ssu_$abort_line (sci_ptr, error_table_$bad_arg,
			"^a^/Usage: dial dial_qualifier {Person.Project} {-control_args}");
	     end;
	     else do;

		if arg = "-user"
		then do;
		     call Get_value (dial_person);
		     user_specified = "1"b;
		     if index (dial_person, DOT) = 0
		     then dial_project = "";
		     else do;
			dial_project = after (dial_person, DOT);
			dial_person = before (dial_person, DOT);
		     end;
		end;

		else if arg = "-authorization" | arg = "-auth"
		then do;
		     auth_specified = "1"b;
		     call Get_value (auth_string);
		     call convert_authorization_$from_string (authorization, auth_string, code);
		     if code ^= 0
		     then call ssu_$abort_line (sci_ptr, code, "^a ^a", keyword, auth_string);
		end;

		else if arg = "-print_off" | arg = "-pf"
		then mask_needed = "0"b;

		else if arg = "-no_print_off" | arg = "-npf"
		then mask_needed = "1"b;

		else call ssu_$abort_line (sci_ptr, error_table_$badopt, "^a", arg);
	     end;
	end;

	if auth_specified & ^user_specified
	then call ssu_$abort_line (sci_ptr, error_table_$inconsistent, "-auth ^a requires the -user control argument.",
		auth_string);
	return;

Parse_login_args:
     entry ();

/* parse the arguments to the login, enter, enterp requests */

/* we have to use cu_$arg_ptr_rel because one path into here is via the unknown_request
   procedure, in which case ssu_$arg_ptr doesn't work.
*/

dcl  first_control_arg fixed bin;
dcl  auth_string char (256);

	auth_specified, brief_specified, brief, immediate, hold_given, hold_on_destroy, change_password,
	     generate_password, cda, cdp, warn_specified, force_specified, save_specified, preempt_specified,
	     no_start_up, ring_specified, mask_needed, operator = ""b;

	terminal_type, mode_string, terminal_id, outer_module, process_overseer, subsystem, home_dir,
	     virtual_channel_name = "";

	first_arg_arg = number_of_args + 1;		/* initially, to indicate no -arguments */

/* get first arg, may be person ID or Person.Project) */

	call cu_$arg_ptr_rel (1, argp, argl, (0), arg_list_ptr);
	if index (arg, DOT) ^= 0			/* Person.project */
	then do;
	     person_name = before (arg, DOT);
	     project_name = after (arg, DOT);
	     first_control_arg = 2;
	end;

	else do;					/* first arg is person, second might be project */
	     person_name = arg;
	     if number_of_args < 2
	     then do;
		project_name = "";
		return;
	     end;

	     call cu_$arg_ptr_rel (2, argp, argl, (0), arg_list_ptr);
	     if index (arg, HYPHEN) ^= 1
	     then do;
		project_name = arg;
		first_control_arg = 3;
	     end;

	     else do;				/* it's a control arg, process it later */
		project_name = "";
		first_control_arg = 2;
	     end;
	end;

	do this_arg = first_control_arg to number_of_args;
	     call cu_$arg_ptr_rel (this_arg, argp, argl, (0), arg_list_ptr);
	     if index (arg, HYPHEN) ^= 1
	     then call ssu_$abort_line (sci_ptr, error_table_$bad_arg, "^a", arg);

	     if arg = "-arguments" | arg = "-ag"
	     then do;
		first_arg_arg = this_arg + 1;		/* we'll process the rest later */
		go to NO_MORE_CONTROL_ARGS;
	     end;

	     else if arg = "-brief" | arg = "-bf"
	     then do;
		brief_specified = "1"b;
		brief = "1"b;
	     end;

	     else if arg = "-long" | arg = "-lg"
	     then do;
		brief_specified = "1"b;
		brief = "0"b;
	     end;

	     else if arg = "-modes" | arg = "-mode" | arg = "-md"
	     then call Get_value (mode_string);

	     else if arg = "-terminal_id" | arg = "-tid"
	     then call Get_value (terminal_id);

	     else if arg = "-terminal_type" | arg = "-ttp"
	     then call Get_value (terminal_type);

	     else if arg = "-print_off" | arg = "-pf"
	     then mask_needed = "0"b;

	     else if arg = "-no_print_off" | arg = "-npf"
	     then mask_needed = "1"b;

	     else if arg = "-warning"
	     then do;
		warn_specified = "1"b;
		warn = "1"b;
	     end;

	     else if arg = "-no_warning" | arg = "-nw"
	     then do;
		warn_specified = "1"b;
		warn = "0"b;
	     end;

	     else if arg = "-force"
	     then do;
		force_specified = "1"b;
		force = "1"b;
	     end;

	     else if arg = "-home_dir" | arg = "-hd"
	     then call Get_value (home_dir);

	     else if arg = "-no_preempt" | arg = "-np"
	     then do;
		preempt_specified = "1"b;
		preempt = "0"b;
	     end;

	     else if arg = "-no_start_up" | arg = "-ns"
	     then no_start_up = "1"b;

	     else if arg = "-outer_module" | arg = "-om"
	     then call Get_value (outer_module);

	     else if arg = "-process_overseer" | arg = "-po"
	     then call Get_value (process_overseer);

	     else if arg = "-subsystem" | arg = "-ss"
	     then call Get_value (subsystem);

	     else if arg = "-ring" | arg = "-rg"
	     then do;
		call Get_numeric_value (ring);
		if ring < 1 | ring > 7
		then call ssu_$abort_line (sci_ptr, error_table_$bad_arg, "^d is not a valid ring number.", ring);
		ring_specified = "1"b;
	     end;

	     else if anonymous
	     then go to UNRECOGNIZED_ARG;		/* the rest are not allowed for anonymous users */

	     else if arg = "-authorization" | arg = "-auth"
	     then do;
		auth_specified = "1"b;
		call Get_value (auth_string);
		call convert_authorization_$from_string (authorization, auth_string, code);
		if code ^= 0
		then call ssu_$abort_line (sci_ptr, code, "^a ^a", keyword, auth_string);
	     end;

	     else if arg = "-change_password" | arg = "-cpw"
	     then change_password = "1"b;

	     else if arg = "-generate_password" | arg = "-gpw"
	     then generate_password = "1"b;

	     else if arg = "-change_default_auth" | arg = "-cda"
	     then cda = "1"b;

	     else if arg = "-change_default_project" | arg = "-cdp"
	     then cdp = "1"b;

	     else if arg = "-save_on_disconnect" | arg = "-save"
	     then do;
		save_specified = "1"b;
		save = "1"b;
	     end;

	     else if arg = "-no_save_on_disconnect" | arg = "-nosave"
	     then do;
		save_specified = "1"b;
		save = "0"b;
	     end;

	     else if arg = "-immediate" | arg = "-im"
	     then immediate = "1"b;

	     else if arg = "-hold"			/* -hd refers to */
	     then hold_on_destroy, hold_given = "1"b;	/* -home_dir.    */

	     else if arg = "-no_hold"
	     then do;
		hold_on_destroy = "0"b;
		hold_given = "1"b;
	     end;

	     else if arg = "-connect"
	     then do;
		call Check_consistent ();
		call Get_optional_numeric_arg (process_number);
		command_type = CONNECT_REQ;
	     end;

	     else if arg = "-new_proc"
	     then do;
		call Check_consistent ();
		call Get_optional_numeric_arg (process_number);
		command_type = NEW_PROC_REQ;
	     end;

	     else if arg = "-destroy"
	     then do;
		call Check_consistent ();
		call Get_optional_numeric_arg (process_number);
		command_type = DESTROY_REQ;
	     end;

	     else if arg = "-create"
	     then do;
		call Check_consistent ();
		command_type = CREATE_REQ;
	     end;

	     else if arg = "-list"
	     then do;
		call Check_consistent ();
		command_type = LIST_REQ;
	     end;

	     else if arg = "-operator" | arg = "-op"
	     then operator = "1"b;

	     else if arg = "-virtual_channel" | arg = "-vchn" | arg = "-vc"
	     then call Get_value (virtual_channel_name);

	     else
UNRECOGNIZED_ARG:
		call ssu_$abort_line (sci_ptr, error_table_$badopt, "^a", arg);
	end;

NO_MORE_CONTROL_ARGS:
	if immediate & (command_type ^= NEW_PROC_REQ & command_type ^= DESTROY_REQ)
	then call ssu_$abort_line (sci_ptr, error_table_$inconsistent, "-immediate without -new_proc or -destroy.");

	if hold_given
	then if command_type ^= DESTROY_REQ
	     then call ssu_$abort_line (sci_ptr, error_table_$inconsistent, "-hold without -destroy.");
	     else ;
	else if command_type = DESTROY_REQ		/* -hold is default with -destroy. */
	then hold_on_destroy = "1"b;

	if cda & ^auth_specified
	then call ssu_$abort_line (sci_ptr, error_table_$inconsistent,
		"-change_default_auth requires that -authorization also be used.");

	if cdp & project_name = ""
	then call ssu_$abort_line (sci_ptr, error_table_$inconsistent,
		"Syntax is ""login Person.NewDefaultProj -change_default_project"".");

	if virtual_channel_name ^= "" & ^operator
	then call ssu_$abort_line (sci_ptr, error_table_$inconsistent, "-virtual_channel without -operator.");

	if operator
	then if (auth_specified | warn_specified | force_specified | save_specified | preempt_specified | no_start_up
		| ring_specified | first_arg_arg <= number_of_args | process_overseer ^= "" | subsystem ^= ""
		| home_dir ^= "" | command_type ^= LOGIN_REQ)
	     then call ssu_$abort_line (sci_ptr, error_table_$inconsistent,
		     "-operator with one or more arguments that only apply to normal user processes.");

	return;

Check_consistent:
	procedure ();

/* (internal to Parse_login_args) checks for inconsistent combinations (such as
   -destroy and -connect) */

	     if command_type ^= LOGIN_REQ
	     then call ssu_$abort_line (sci_ptr, error_table_$inconsistent,
		     "Only one of -connect, -new_proc, -destroy, -create, or -list may be specified.");
	     return;
	end Check_consistent;


Get_value:
	procedure (value);

/* this procedure (internal to Parse_login_args) gets the string value associated
   with a control argument, and returns it
*/

dcl  value char (*) parameter;
dcl  n_value fixed bin parameter;

dcl  numeric bit (1);

	     numeric = "0"b;
	     go to GET_VALUE_COMMON;

Get_numeric_value:
	entry (n_value);

/* likewise, but value must be a number */

	     numeric = "1"b;

GET_VALUE_COMMON:
	     if this_arg >= number_of_args		/* oops, there isn't one */
	     then call ssu_$abort_line (sci_ptr, error_table_$noarg, "After ^a", arg);

	     else do;
		keyword = arg;
		this_arg = this_arg + 1;

		call cu_$arg_ptr_rel (this_arg, argp, argl, (0), arg_list_ptr);
		if index (arg, HYPHEN) = 1
		then call ssu_$abort_line (sci_ptr, error_table_$noarg, "After ^a", keyword);

		else if ^numeric
		then value = arg;

		else do;
CHECK_NUMERIC:
		     if arg = ""
		     then call ssu_$abort_line (sci_ptr, error_table_$bad_conversion, "Null value for ^a.", keyword);
		     n_value = cv_dec_check_ (arg, code);
		     if code ^= 0
		     then call ssu_$abort_line (sci_ptr, error_table_$bad_conversion, "^a ^a", keyword, arg);
		end;
	     end;
	     return;

Get_optional_numeric_arg:
	entry (n_value);

/* this procedure returns a numeric value for a keyword; if there is no value,
   it returns 0
*/

	     n_value = 0;
	     if this_arg >= number_of_args
	     then return;

	     call cu_$arg_ptr_rel (this_arg + 1, argp, argl, (0), arg_list_ptr);
	     if index (arg, HYPHEN) = 1
	     then return;

	     else do;
		this_arg = this_arg + 1;
		go to CHECK_NUMERIC;
	     end;

	end Get_value;

     end Parse_dial_args;

Print_password_mask:
     procedure ();

/* take a constant set of overprinting and overprint it with a random, clock-derived
   string to make deciphering very difficult */

	call ioa_$nnl ("^a^a", CONSTANT_MASK, substr (RANDOM_ALPHABET, mod (clock (), 28), 12) || copy (BS, 12));
						/* 12 backspaces at the end */

	return;
     end Print_password_mask;

Process_process_response:
     procedure (reply_code);

/* this procedure is called when a response comes from a "process" request --
   this is how we determine if the user's intentions were carried out
*/

dcl  reply_code fixed bin (35) parameter;		/* an input parameter indicating the reply code from Send_request_to_initializer */

dcl  logout bit (1) aligned;
dcl  hangup bit (1) aligned;
dcl  process_code fixed bin (35);
dcl  cpu_seconds fixed bin;
dcl  cpu_minutes fixed bin;
dcl  instance fixed bin;
dcl  suffix char (4);
dcl  auth_string char (256);

	if reply_code ^= 0
	then do;					/* got back non-zero code in response to process request */
	     call ssu_$print_message (sci_ptr, reply_code);
	     if ls_response_ptr ^= null ()
	     then free login_server_process_response in (system_area);
	     call Enter_connect_loop ();
	     return;
	end;

	logout = login_server_process_response.logout;
	hangup = login_server_process_response.disconnect;

	if login_server_process_response.status_code ^= 0
	then do;					/* but we didn't succeed */
	     process_code = ls_convert_as_error_code_ (login_server_process_response.status_code);

	     if process_code = as_error_table_$no_such_process_msg
	     then call ls_message_$print (ls_message_table_$no_such_process, ls_validate_info.process_number);

	     else if process_code = as_error_table_$no_connect_aclass
	     then call ls_message_$print (ls_message_table_$no_connect_aclass,
		     (ls_validate_info.n_disconnected_processes > 1), ls_validate_info.process_number);

	     else if login_server_process_response.already_logged_in
	     then call ls_message_$print (ls_message_table_$already_logged_in, ls_validate_info.person_id,
		     ls_validate_info.project_id, login_server_process_response.already_logged_in_info.terminal_type,
		     login_server_process_response.already_logged_in_info.terminal_id);

	     else call ls_message_$print_error (process_code);

	     if logout | hangup
	     then do;
		free login_server_process_response in (system_area);
		if ls_validate_info.process_request_ptr ^= null ()
		then free ls_validate_info.process_request_ptr -> login_server_process_request in (system_area);
		if logout
		then call Logout (hangup, (ls_validate_info.brief), process_code);

		else if hangup
		then do;
		     ls_validate_info.code = process_code;
		     call Hangup (DONT_TELL_INITIALIZER);
		     call ssu_$abort_subsystem (sci_ptr);
		end;
		return;
	     end;

	     if login_server_process_response.n_disconnected_processes > 0
	     then call ls_message_$print (ls_message_table_$disconnected_processes,
		     login_server_process_response.n_disconnected_processes,
		     (login_server_process_response.n_disconnected_processes > 1));
	     ls_validate_info.n_disconnected_processes = login_server_process_response.n_disconnected_processes;
	     free login_server_process_response in (system_area);
	     call Enter_connect_loop ();
	     return;
	end;

/* code is 0, so the initializer did what was requested */

	ls_process_info_ptr = ls_validate_info.process_info_ptr;
	if login_server_process_response.new_handle ^= ""b
	then ls_validate_info.initializer_handle, ls_process_info.initializer_handle =
		login_server_process_response.new_handle;
						/* in case handle is different from */
						/* the one in the validate_response */
	if login_server_process_response.flags.brief
	then ls_validate_info.brief = "1"b;

	if login_server_process_response.destroyed
	then do;
	     call ls_message_$print (ls_message_table_$process_destroyed,
		(ls_validate_info.n_disconnected_processes > 1), ls_validate_info.process_number);

	     cpu_seconds = divide (login_server_process_response.cpu_usage, ONE_MILLION, 17, 0);
	     cpu_minutes = divide (cpu_seconds, 60, 17, 0);
	     cpu_seconds = cpu_seconds - 60 * cpu_minutes;

	     if logout
	     then call ls_message_$print (ls_message_table_$logout, ls_validate_info.person_id,
		     ls_validate_info.project_id,
		     date_time_$format ("system_date_time", clock (), "system_zone", "system_lang"),
		     (cpu_minutes ^= 0), cpu_minutes, cpu_seconds, login_server_process_response.cost);

	     else call ls_message_$print (ls_message_table_$cost_message, (cpu_minutes ^= 0), cpu_minutes, cpu_seconds,
		     login_server_process_response.cost);

	     free login_server_process_response in (system_area);
						/* don't need this any more */

	     if logout
	     then call Logout (^hold_on_destroy, "1"b, error_table_$user_requested_logout);

	     else call Enter_connect_loop ();

	     return;
	end;

/* There's now a process (new or pre-existing) to connect to */

	ls_process_info.process_group_id = login_server_process_response.process_group_id;
	ls_process_info.start_event_channel = login_server_process_response.start_event_channel;
	ls_process_info.process_id = login_server_process_response.process_id;
	ls_process_info.usage_type = LS_LOGIN_USAGE;
	ls_process_info.authorization = login_server_process_response.authorization;
	ls_process_info.initial_ring = login_server_process_response.initial_ring;
	ls_process_info.terminal_type = ls_validate_info.user_connection_info.terminal_type;
	ls_process_info.terminal_id = ls_validate_info.user_connection_info.terminal_id;
	ls_process_info.line_type = ls_validate_info.user_connection_info.line_type;
	ls_process_info.flags.terminal_info_set = "1"b;

/* other fields in ls_process_info were filled in earlier */

	call convert_authorization_$to_string (login_server_process_response.authorization, auth_string, code);
	if auth_string ^= ""
	then call ls_message_$print (ls_message_table_$authorization, auth_string);

	if login_server_process_response.connected
	then call ls_message_$print (ls_message_table_$connected, (ls_validate_info.n_disconnected_processes > 1),
		login_server_process_response.process_number);

	else if login_server_process_response.new_proc
	then call ls_message_$print (ls_message_table_$connected_after_new_proc,
		(ls_validate_info.n_disconnected_processes > 1), ls_validate_info.process_number);

	else do;					/* brand-new process */
	     if login_server_process_response.login_instance > 1
	     then do;
		instance = login_server_process_response.login_instance;
		if instance > 9 & instance < 20
		then suffix = ls_data_$teens_suffix (mod (instance, 10));
		else suffix = ls_data_$suffix (mod (instance, 10));
		call ls_message_$print (ls_message_table_$multiple_login_msg, instance, suffix);
	     end;

	     if ^ls_validate_info.brief
	     then do;

		if login_server_process_response.accounting_message_length > 0
		then call ls_message_$print_error (0, "^a", login_server_process_response.accounting_message);

		call ls_message_$print (ls_message_table_$login, login_server_process_response.anonymous,
		     ls_validate_info.person_id, ls_validate_info.project_id,
		     date_time_$format ("system_date_time", clock (), "system_zone", "system_lang"),
		     ls_validate_info.user_connection_info.terminal_type,
		     ls_validate_info.user_connection_info.terminal_id);
		call ls_message_$print (ls_message_table_$last_login,
		     date_time_$format ("system_date_time", ls_validate_info.previous_login_info.time, "system_zone",
		     "system_lang"), ls_validate_info.previous_login_info.terminal_type,
		     ls_validate_info.previous_login_info.terminal_id);
	     end;
	end;

	free login_server_process_response in (system_area);
	if ls_validate_info.process_request_ptr ^= null ()
	then free ls_validate_info.process_request_ptr -> login_server_process_request in (system_area);

	ls_validate_info.code = 0;			/* all is OK */
	call ssu_$abort_subsystem (sci_ptr);		/* and we're ALL DONE */
	return;

     end Process_process_response;

Process_validate_response:
     procedure (reply_code);
     
dcl  reply_code fixed bin (35) parameter;		/* an input parameter indicating the reply code from Send_request_to_initializer */

	if reply_code ^= 0
	then do;
	     call ssu_$print_message (sci_ptr, reply_code);
	     if ls_response_ptr ^= null ()
	     then free login_server_validate_response in (system_area);
	     go to TRY_AGAIN;
	end;

/* attributes might have been changed even if login refused, so report it now */

	if login_server_validate_response.password_changed
	then call ls_message_$print (ls_message_table_$password_changed);

	if login_server_validate_response.default_auth_changed
	then call ls_message_$print (ls_message_table_$default_auth_changed);

	if login_server_validate_response.default_proj_changed
	then call ls_message_$print (ls_message_table_$default_project_changed);

	if login_server_validate_response.status_code ^= 0
	then do;
	     ls_validate_info.code = ls_convert_as_error_code_ (login_server_validate_response.status_code);
	     call ssu_$print_message (sci_ptr, ls_validate_info.code);
	     hangup_flag = login_server_validate_response.disconnect;

	     if login_server_validate_response.password_expired
	     then call ls_message_$print (ls_message_table_$password_expired,
		     login_server_validate_response.password_interval);

	     if login_server_validate_response.password_unused_too_long
	     then call ls_message_$print (ls_message_table_$password_unused_too_long,
		     login_server_validate_response.password_interval);

	     free login_server_validate_response in (system_area);
	     if hangup_flag
	     then do;
		call Hangup (DONT_TELL_INITIALIZER);
		call ssu_$abort_subsystem (sci_ptr);
	     end;

	     else do;
		ls_validate_info.validation_failures = ls_validate_info.validation_failures + 1;
		ip = ls_cp_info.installation_parms_ptr;
		if ls_validate_info.validation_failures >= installation_parms.part_1.login_tries
		then do;				/* not logged in */
		     call Hangup (DONT_TELL_INITIALIZER);
		     call ssu_$abort_subsystem (sci_ptr);
		end;

		else go to TRY_AGAIN;
	     end;
	end;

/* user is validated now. Tell him if his password has been entered incorrectly */

	if login_server_validate_response.incorrect_passwords > 0
	then call ls_message_$print (ls_message_table_$incorrect_passwords,
		(login_server_validate_response.incorrect_passwords > 1),
		login_server_validate_response.incorrect_passwords,
		date_time_$format ("system_date_time", login_server_validate_response.last_incorrect_password.time,
		"system_zone", "system_lang"), login_server_validate_response.last_incorrect_password.terminal_type,
		login_server_validate_response.last_incorrect_password.terminal_id);
     end Process_validate_response;
	
Read_answerback:
     procedure ();

/* this procedure reads the answerback, and adjusts the terminal type if necessary */

dcl  new_term_type char (32);
dcl  answerback char (64);
dcl  length_read fixed bin (21);

dcl  terminal_id char (4);

dcl  1 auto_terminal_info aligned like terminal_info;

	auto_terminal_info.version = terminal_info_version;
	call iox_$control (iox_$user_io, "terminal_info", addr (auto_terminal_info), code);
	if code ^= 0
	then do;
	     subr_name = "iox_$control terminal_info";
	     call Hangup_no_message (DONT_TELL_INITIALIZER);
	     go to NO_SETUP;
	end;

	ls_validate_info.user_connection_info.terminal_id = auto_terminal_info.id;
	ls_validate_info.user_connection_info.terminal_type = auto_terminal_info.term_type;
	ls_validate_info.user_connection_info.line_type = auto_terminal_info.line_type;

	call iox_$control (iox_$user_io, "wru", null (), code);
	if code = 0
	then do;
	     call iox_$get_chars (iox_$user_input, addr (answerback), length (answerback), length_read, code);
	     if code ^= 0
	     then call Hangup_with_error (code, DONT_TELL_INITIALIZER);
	     call Count_wakeups ();

	     if length_read ^= 0
	     then do;
		call ttt_info_$decode_answerback (substr (answerback, 1, length_read), -1, new_term_type, terminal_id,
		     code);
		if code = 0
		then do;
		     if terminal_id ^= "" & terminal_id ^= auto_terminal_info.id
		     then call Set_term_id (terminal_id);
		     if new_term_type ^= "" & new_term_type ^= auto_terminal_info.term_type
		     then call Set_terminal_type (new_term_type);
		end;
	     end;
	end;
	else code = 0;				/* set main proc's code argument, used at NO_SETUP */
	return;
     end Read_answerback;

Read_password:
     procedure () returns (char (8));

/* read the password, unechoed */

dcl  password_buff char (10);
dcl  length_read fixed bin (21);
dcl  code fixed bin (35);
dcl  send_mask bit (1);

	password_buff = "";
	call Change_state (AWAITING_PASSWORD);
	send_mask = ls_validate_info.mask_needed;

	if ^send_mask
	then do;
	     call iox_$control (iox_$user_io, "printer_off", null (), code);
	     if code ^= 0
	     then send_mask = "1"b;
	end;

	call ioa_ ("");				/* put out newline after printer_off */
	if send_mask
	then call Print_password_mask ();

	call iox_$get_line (iox_$user_input, addr (password_buff), length (password_buff), length_read, code);
	if code ^= 0
	then if code ^= error_table_$long_record
	     then call Hangup_with_error (code, (ls_validate_info.initializer_handle ^= ""b));
	call Count_wakeups ();

	if length_read > 9 | code = error_table_$long_record
	then do;
	     call ls_message_$print (ls_message_table_$password_format_warning);
	     call iox_$control (iox_$user_input, "resetread", null (), (0));
						/* to get rid of any extra characters */
	end;

	if ^send_mask
	then call iox_$control (iox_$user_io, "printer_on", null (), (0));
	return (before (password_buff, NL));

     end Read_password;

Send_request_to_initializer:
     procedure (a_request_type, a_request_version, a_request_size, free_request, response_expected, response_ptr, a_code);

/* procedure to send any of the various login_server requests to the Initializer, using send_ls_request_.
   If the request does not provoke the expected response, it is bad news. */

dcl  a_request_type fixed bin parameter;
dcl  a_request_version char (8) parameter;
dcl  a_request_size fixed bin parameter;
dcl  free_request bit (1) aligned parameter;
dcl  response_expected fixed bin parameter;
dcl  response_ptr pointer parameter;
dcl  a_code fixed bin (35) parameter;

dcl  request_size fixed bin (18);
dcl  message_name fixed bin;
dcl  message_type fixed bin;
dcl  code fixed bin (35);
dcl  reply_code fixed bin (35);

dcl  1 auto_ls_reply_message aligned like ls_reply_message;

dcl  user_message (as_user_message_info.message_length) bit (36) aligned based (ls_response_ptr);

dcl  ls_request (request_size) bit (36) aligned based (ls_request_ptr);


	request_size = a_request_size;

	ls_request_header.request_type = a_request_type;
	ls_request_header.request_version = a_request_version;
	ls_request_header.header_version = LS_REQUEST_HEADER_VERSION_1;
	ls_request_header.reply_event_channel = ls_validate_info.reply_channel;
	ls_request_header.reply_handle = ls_validate_info.server_handle;
	ls_request_header.pad1 = ""b;

	ls_validate_info.expected_response = response_expected;
	call Change_state (AWAITING_INITIALIZER_RESPONSE);

	ls_reply_message_ptr = addr (auto_ls_reply_message);
	call send_ls_request_ (ls_request_ptr, request_size, ls_reply_message_ptr, code);
	if free_request
	then free ls_request in (system_area);

	if code ^= 0
	then do;
	     call ls_report_subr_error_ (code, OUR_NAME,
		ls_validate_info.cp_info_ptr, "send_ls_request_",
		TELL_USER, TAKE_DUMP);
	     call Hangup_with_error (code, DONT_TELL_INITIALIZER);
	end;

	reply_code = ls_convert_as_error_code_ (ls_reply_message.code);

	if reply_code ^= 0
	then if ls_reply_message.request_invalid
	     then do;
		call ls_report_internal_error_ (reply_code, OUR_NAME, ls_validate_info.cp_info_ptr,
		     "Reported in as_reply_message.");
		call Hangup_with_error (reply_code, ls_validate_info.initializer_handle ^= ""b);
	     end;

	if ls_reply_message.response_sent
	then do;
	     as_user_message_info_ptr = addr (auto_as_user_message_info);

	     as_user_message_info.version = AS_USER_MESSAGE_INFO_VERSION_1;
	     string (as_user_message_info.flags) = ""b;
	     as_user_message_info.message_info.message_handle = ls_validate_info.server_handle;

	     call user_message_$read_message (system_areap, as_user_message_info_ptr, code);

	     if code ^= 0
	     then do;
		call ls_report_subr_error_ (code, OUR_NAME,
		     ls_validate_info.cp_info_ptr,
		     "user_message_$read_message", TELL_USER,
		     (code ^= error_table_$no_message));
		call Hangup_with_error (code, ls_validate_info.initializer_handle ^= ""b);
	     end;

	     ls_response_ptr = as_user_message_info.message_ptr;

	     message_type = login_server_response_header.message_type;
	     if message_type = response_expected then;
	     else if message_type = LS_TERMINATION_RESPONSE
	     then do;				/* valid anytime */
		reply_code =
		     ls_convert_as_error_code_ (login_server_termination_response.status_code);
		call Hangup_with_error (reply_code, DONT_TELL_INITIALIZER);
	     end;
	     else if message_type ^= response_expected
	     then do;
		free user_message in (system_area);
		if lbound (LS_RESPONSE_TYPES, 1) <= message_type & message_type <= hbound (LS_RESPONSE_TYPES, 1)
		then message_name = message_type;
		else message_name = LS_UNKNOWN_RESPONSE;
		call ls_report_internal_error_ (0, OUR_NAME, ls_validate_info.cp_info_ptr, "1"b,
		     "Unexpected response from initializer:
  expected ^d (^a response), received ^d (^a response)", response_expected, LS_RESPONSE_TYPES (response_expected),
		     message_type, LS_RESPONSE_TYPES (message_name));
		call Hangup_with_error (error_table_$fatal_error, ls_validate_info.initializer_handle ^= ""b);
	     end;

	     response_ptr = ls_response_ptr;
	     a_code = 0;				/* because relevant information is in response; */
	end;

	else do;					/* no response */
	     response_ptr = null ();
	     a_code = reply_code;
	     if a_code = 0				/* claimed there was nothing wrong */
	     then if response_expected ^= 0		/* but didn't send expected response */
		then do;
		     call ls_report_internal_error_ (0, OUR_NAME, ls_validate_info.cp_info_ptr, "1"b,
			"No response when ^d expected, but code = 0", response_expected);
		     call Hangup_with_error (error_table_$fatal_error, ls_validate_info.initializer_handle ^= ""b);
		end;
	end;

	return;
     end Send_request_to_initializer;

Set_modes:
     procedure (a_mode_string);

dcl  a_mode_string char (*) parameter;

dcl  mode_string char (512);
dcl  returned_modes char (32);
dcl  code fixed bin (35);

	mode_string = a_mode_string;

	call iox_$modes (iox_$user_io, mode_string, returned_modes, code);

	if code ^= 0
	then if code = error_table_$bad_mode
	     then call ls_message_$print_error (code, returned_modes);
	     else call ls_report_subr_error_ (code, OUR_NAME,
		ls_validate_info.cp_info_ptr, "iox_$modes",
		TELL_USER, DONT_TAKE_DUMP);

	return;
     end Set_modes;

Set_term_id:
     procedure (a_terminal_id);

dcl  a_terminal_id char (*);

dcl  code fixed bin (35);

	call iox_$control (iox_$user_io, "store_id", addr (a_terminal_id), code);
	if code ^= 0
	then call ls_message_$print_error (code, "Cannot set terminal id.");
	else ls_validate_info.user_connection_info.terminal_id = a_terminal_id;

	return;
     end Set_term_id;

Set_terminal_type:
     procedure (a_type);

dcl  a_type char (*) parameter;

dcl  terminal_type char (32);

dcl  1 auto_set_term_info aligned like set_term_type_info;

	terminal_type = translate (a_type, "ABCDEFGHIJKLMNOPQRSTUVWXYZ", "abcdefghijklmnopqrstuvwxyz");
						/* make it be all upper case */

	auto_set_term_info.version = stti_version_1;
	auto_set_term_info.name = terminal_type;
	auto_set_term_info.send_initial_string = "1"b;
	auto_set_term_info.set_modes = "1"b;
	auto_set_term_info.ignore_line_type = "0"b;
	auto_set_term_info.mbz = ""b;

	call iox_$control (iox_$user_io, "set_term_type", addr (auto_set_term_info), code);
	if code ^= 0
	then call ls_message_$print_error (code, "Cannot set terminal type.");
	else ls_validate_info.user_connection_info.terminal_type = terminal_type;

	return;
     end Set_terminal_type;


/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* Write_greeting_message:					       */
/* 1) If not in brief mode, then print greeting banner message on terminal.  */
/*    Also, update ls_validate_info.banner_checked_time, since the banner is */
/*    checked by the act of printing.				       */
/*							       */
/* NOTE: This procedure is called by PRINT_BANNER_IF_CHANGED, an alarm call  */
/* handler which is a separate entrypoint into ls_validate_user_.  The only  */
/* variable set by this separate entrypoint is ls_validate_info_ptr, so only */
/* the ls_validate_info structure (and things it points to) can be	       */
/* referenced by this procedure.				       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

Write_greeting_message:
     procedure (force_message);

dcl  force_message bit (1);

dcl  installation_id char (64);
dcl  special_length fixed bin (21);
dcl  special_msg char (special_length) based;
dcl  sysid char (8);

	if ^ls_validate_info.brief | force_message
	then do;
	     ansp = ls_validate_info.cp_info_ptr -> ls_cp_info.answer_table_ptr;

	     if anstbl.special_message ^= ""
	     then do;
		special_length = anstbl.message_lng;
		call ioa_$nnl ("^a", addr (anstbl.special_message) -> special_msg);
	     end;

	     call system_info_$sysid (sysid);
	     call system_info_$installation_id (installation_id);

	     call ls_message_$print (ls_message_table_$greeting_msg, sysid, installation_id,
		ls_validate_info.connection_desc_ptr -> ls_connection_desc.name, float (anstbl.n_units) / 10.0e0,
		float (anstbl.max_units) / 10.0e0, anstbl.n_users,
		date_time_$format ("system_date_time", clock (), "system_zone", "system_lang"));
	     ls_validate_info.banner_checked_time = clock ();
	end;

	return;
     end Write_greeting_message;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

%include answer_table;

%include as_user_message_info;

%include cp_character_types;

%include dsa_log_constants;

%include installation_parms;

dcl  ip pointer;

%include login_server_messages;

%include login_service_entries;

%include ls_connection_desc;

%include ls_cp_info;

%include ls_process_info;

%include ls_usage_types;

%include ls_validate_info;

%include set_term_type_info;

%include ssu_prompt_modes;

%include ssu_rp_options;

%include terminal_info;

%include timer_manager_constants;

%include user_table_header;

     end ls_validate_user_;
