/****^  ******************************************************
        *                                                    *
        * Copyright, (C) Honeywell Bull Inc., 1989           *
        *                                                    *
        * Copyright (c) 1986 by Massachusetts Institute of   *
        * Technology and Honeywell Information Systems, Inc. *
        *                                                    *
        * Copyright (c) 1972 by Massachusetts Institute of   *
        * Technology and Honeywell Information Systems, Inc. *
        *                                                    *
        ****************************************************** */

/**** format: ind3,ll80,initcol6,indattr,^inddcls,dclind4,idind16	       */
/**** format: struclvlind2,^ifthenstmt,^ifthendo,^ifthen,^indnoniterdo       */
/**** format: ^inditerdo,^indnoniterend,^indthenelse,case,^indproc,^indend   */
/**** format: ^delnl,^insnl,comcol41,^indcom,^indblkcom,linecom,^indcomtxt   */

validate_info_seg: vis: proc;

/* This command validates the syntax of an info segment.

   Syntax:
	     vis paths {-control_args}
	     [vis path {-control_args}]
   Arguments:

   path
      the pathname of an info seg. The .info suffix is added if necessary.
      The star convention is allowed.

   Control arguments:
   -names, -nm
   -no_names, -nnm (default)
   -severity N, -sv N
      Suppresses error messages of severity less than N.
   -total, -tt
      Prints only the total number of errors or nothing.

   The vis active function must be invoked on a single info segment and
   returns the severity number of the highest severity error encountered.

   Error messages are shown in the first DCL of the program.  The first
   character of each one is its severity. */


/****^  HISTORY COMMENTS:
  1) change(78-12-01,Herbst), approve(), audit(), install():
      Written by S. Herbst.
  2) change(79-10-15,Herbst), approve(), audit(), install():
      Fixed to accept/convert extra paragraphs of standard sections.
  3) change(80-02-25,Herbst), approve(), audit(), install():
      Fixed to diagnose missing :Info: entry lines.
  4) change(80-03-26,Herbst), approve(), audit(), install():
      Max line length changed from 79+NL to 71+NL.
  5) change(80-07-17,Herbst), approve(), audit(), install():
      Changed to print text of nonstandard section titles.
  6) change(81-06-29,Herbst), approve(), audit(), install():
      Changed to convert in place if -of PATH = path, accept any cdtb_ date,
      bugs fixed.
  7) change(82-12-10,Herbst), approve(), audit(), install():
      Fixed long lines bug and -fill on simple header line.
  8) change(83-12-02,Falksenj), approve(85-11-04,MCR7289),
     audit(86-06-17,Hartogs), install(86-06-17,MR12.0-1076):
      Removed all output capabilities, completely changed message style.
  9) change(85-08-15,Falksenj), approve(85-11-04,MCR7289),
     audit(86-06-17,Hartogs), install(86-06-17,MR12.0-1076):
      Add CHECK_INFO_TYPE and associate routines + segname checking.
 10) change(85-09-24,Lippard), approve(85-11-04,MCR7289),
     audit(86-06-17,Hartogs), install(86-06-17,MR12.0-1076):
      Modified by Jim Lippard to not complain about ":Entry:" or ":Info:"
      lines over 71 characters long.
 11) change(86-01-07,Lippard), approve(85-11-04,MCR7289),
     audit(86-06-17,Hartogs), install(86-06-17,MR12.0-1076):
      Modified to not try to handle addnames on general infos, not consider
      names ending in "_status.info" to be general infos.
 12) change(86-02-13,Lippard), approve(85-11-04,MCR7289),
     audit(86-06-17,Hartogs), install(86-06-17,MR12.0-1076):
      Modified to count number of infos correctly.
 13) change(86-04-03,Lippard), approve(85-11-04,MCR7289),
     audit(86-06-17,Hartogs), install(86-06-17,MR12.0-1076):
      Modified to allow multiple short names in header.
 14) change(86-05-13,Lippard), approve(85-11-04,MCR7289),
     audit(86-06-17,Hartogs), install(86-06-17,MR12.0-1076):
      Modified to require "Syntax" instead of "Usage" for subroutine info
      segs.
 15) change(86-05-16,Lippard), approve(85-11-04,MCR7289),
     audit(86-06-17,Hartogs), install(86-06-17,MR12.0-1076):
      Modified to allow subroutine "Syntax" section to have a blank line
      between the declaration and the call descriptions.
 16) change(86-10-08,Lippard), approve(86-12-01,MCR7581),
     audit(87-03-31,Dickson), install(87-04-01,MR12.1-1019):
      Modified to not put commas at the beginnings of continuation lines.
 17) change(87-01-07,Lippard), approve(87-01-26,MCR7604),
     audit(87-03-31,Dickson), install(87-04-01,MR12.1-1019):
      Modified to complain about more than two blank lines preceding a
      section.
 18) change(88-09-28,Lee), approve(88-11-14,MCR8019), audit(88-11-28,Flegel),
     install(89-01-23,MR12.3-1010):
     phx18806 (Commands 294) - Modified to complain about multiple
     paragraphs separated by single blank lines whose total exceeds 15
     lines.
                                                   END HISTORY COMMENTS */

%page;
/* format: off */
dcl (
/**** SEVERITY 1 messages ****/
     this_form_preferred init ("1This form is preferred:^s^/^13t^a"),
/**** SEVERITY 2 messages ****/
     non_std_title	     init ("2Nonstandard section title^[: ^a^]"),

     paragraph_size	     init ("2Paragraph ^[size (^s^i lines)^;^2s^] exceeds limit of ^i."),

     no_syntax_name	     init ("2Short name ^[""^a"" ^]not used."),

     no_usage_name	     init ("2Name ^[""^a"" ^]not present in Syntax line."),

     end_white_space     init ("2Th^[ese lines end^;is line ends^] in white space"),

     blank_white_space   init ("2Th^[ese blank lines contain^;is blank line contains^] white space"),

     backspace	     init ("2Th^[ese lines contain^;is line contains^] backspace"),
     missing_name	     init ("2Name missing from the segment: ^s^a"),

     extra_name          init ("2Extra name on segment: ^s^a"),

     order_name          init ("2Names out of order on segment."),
/**** SEVERITY 3 messages ****/
     non_printable	     init ("3Th^[ese lines contain^;is line contains^] non-printable characters"),

     lines_too_long	     init ("3These lines of section exceed 71 chars"),

     need_usage	     init ("3This section must be ""Syntax""."),

     need_function	     init ("3This section must be ""Function""."),

     need_command        init ("3This section must be ""Syntax as a command""."),

     not_belong          init ("3This section does not belong here."),

     out_of_sequence     init ("3This section is out of sequence."),

     missing_section     init ("3Missing ^[""^a"" ^]section."),

     too_many	     init ("3Only ^[^s^i^] of these sections allowed."),

     bad_date	     init ("3Unrecognizable date string^[: ^a^]"),

     entry_too_late      init ("3Entry date is later than the info date."),
/**** SEVERITY 4 messages ****/
     missing_info	     init ("4Missing :Info: or :Internal: at beginning of segment.^/"),

     no_entries          init ("4Missing :Entry:."),

     bad_entry           init ("4:Entry: not in a subroutine info."),

     no_hdr_name	     init ("4No name in header line."),

     no_sections	     init ("4No sections in component."),

     need_2_blank_lines  init ("4^[^a^;Section^] not preceded by 2 blank lines."),

     need_ending_NL	     init ("4Segment does not end with a NL."),

     ends_in_NUL	     init ("4Segment ends in^[ ^s^i^] NUL characters."),

     big_header	     init ("4Too many lines^[ (^s^i)^] in header."),
/**** SEVERITY 5 messages ****/
     no_entry	     init ("5Entry not found."),

     nothing_done	     init ("5No processing done."),

     null_segment	     init ("5Segment consists only of ^2s^i NUL characters."),
     zero_segment        init ("5Zero length segment."))

		char (80) var;	/* format: on */ %page;
/* ---------------------------------------------------------------------------

   (START)                                                                                      
      |                                   [S] represents "Scan a section title"                 
   ___v___                                                                                      
  / .gi/  \       GENERAL                                                                       
 / .error/ \ Y       +-----------------+                                                        
<  status/  >------->| section         |                                                        
 \ changes /         |{section ...}    |                                                        
  \_______/          +-----------------+                                                        
      |N                                                                     ("Error")          
     [S]                                                                         |              
      |                                                                          |N             
  ____v____                                             _________            ____|____          
 /         \ Y                                         / Entry-  \ Y        /         \         
< untitled  >--[S]----------------------------------->< points in >-------><  :Entry:  >        
 \_________/                                           \_________/          \_________/         
      |N                                                    |N                   |Y             
      |     An info is prescanned enough to determine       |                    |              
      |     it's type, then a real scan begins.             |                    |              
      |                                                     |      SUBROUTINE    v              
  ____v____                                                 |         +---------------------+   
 /         \ Y                                              v         | Function            |   
< Function  >-------------------------------------------------------->| Syntax              |   
 \_________/                           COMMAND                        |{Arguments}         *|   
      |N                                  +---------------------+     |{Access required}   *|   
      |                                   | Syntax as commamd   |     |{Examples}           |   
  ____v____            _________          |                     |     +---------------------+   
 /Syntax as\ Y        /Syntax as\ N       | Function            |                |              
< a command >--[S]--><an act.fun.>------->|{Arguments}         *|           If came from :Entry:
 \_________/          \_________/        #|{Control args}      *|           go look for another 
      |N                   |Y            #|{CA as a command}   *|                               
      |                    |             #|{CA COMMAND...}     *|  COMMAND/ACTIVE FUNCTION                   
      |                    |              |{Access required}   *|     +---------------------+   
      |                    |              |{Examples}           |     | Syntax as command   |   
      |                    |              +---------------------+     | Syntax as act.fun.  |   
      |                    +----------------------------------------->|                     |   
      |                    |Y          ACTIVE FUNCTION                | Function            |   
  ____v____            ____|____          +---------------------+     |{Arguments}         *|   
 /Syntax as\ Y        /Syntax as\ N       | Syntax as act.fun.  |    #|{Control Args}      *|   
<an act.fun.>--[S]-->< a command >------->|                     |    #|{CA as a command}   *|   
 \_________/          \_________/         | Function            |    #|{CA as an act.func} *|   
      |N                                  |{Arguments}         *|    #|{CA for...}         *|   
      |                                  #|{Control args}      *|     |{Access required}   *|   
      |                                  #|{CA as an act.func} *|     |{Examples}           |   
      |                                  #|{CA for...}         *|     +---------------------+   
      |                                   |{Access required}   *|                               
      |                                   |{Examples}           |                               
      |                                   +---------------------+ (*) These sections can occur  
      |                                                               next in any order:        
      |                                REQUEST                            List of...            
      |                                   +---------------------+         Notes                 
      |                                   | Syntax              |         Notes on...           
  ____v____            _________          |                     |                               
 /         \ Y        /Syntax as\ N       | Function            | (#) Sections can occur as     
<  Syntax   >--[S]--><an act.req.>------->|{Arguments}         *|     a group in any order.     
 \_________/          \_________/        #|{Control args}      *|                               
      |N                   |Y            #|{CA as a request}   *|                               
      |                    |             #|{CA for...}         *|  REQUEST/ACTIVE REQUEST       
      |                    |              |{Access required}   *|     +---------------------+   
      |                    |              |{Examples}           |     | Syntax              |   
      |                    |              +---------------------+     | Syntax as act.req.  |   
      |                    +----------------------------------------->|                     |   
      |                    |Y          ACTIVE REQUEST                 | Function            |   
  ____v____            ____|____          +---------------------+     |{Arguments}         *|   
 /Syntax as\ Y        /         \ N       | Syntax as act.req.  |    #|{Control args}      *|   
<an act.req.>--[S]--><  Syntax   >------->|                     |    #|{CA as a request}   *|   
 \_________/          \_________/         | Function            |    #|{CA as an act.req}  *|   
      |N                                  |{Arguments}         *|    #|{CA for...}         *|   
 ("Not a defined type")                  #|{Control args}      *|     |{Access required}   *|   
      |                                  #|{CA as an act.req}  *|     |{Examples}           |   
      v                                  #|{CA for...}         *|     +---------------------+   
+-----------+                             |{Access required}   *|                               
| sections  |                             |{Examples}           |                               
+-----------+                             +---------------------+                               


---------------------------------------------------------------------------  */
/* In this list, all names which are the full 41 chars long must be an exact */
/*  match to a section name, while the shorter ones only need to match their */
/*  length's worth at the beginning.				       */
dcl std_section	(45) char (41) var int static options (constant) init (
		" 1Access required                        ",
		" 2Arguments                              ",
		" 3Control arguments                      ",
		" 4Control arguments as a command         ",
		" 5Control arguments as a request         ",
		" 6Control arguments as an active function",
		" 7Control arguments as an active request ",
		" 8Control arguments for ",
		" 9Entry points in ",
		"10Examples                               ",
		"11Function                               ",
		"12List of ",
		"13Notes                                  ",
		"14Notes on ",
		"15Syntax                                 ",
		"16Syntax as a command                    ",
		"17Syntax as an active function           ",
		"18Syntax as an active request            ",
		"19Syntax                                 ",
		"20<untitled>                             ",
/**** improper forms follow, they reference proper ones above.	       */
		"17Syntax as active function              ",
		"16Syntax as command                      ",
		"11Purpose                                ",
		" 2Argument ",
		" 2Where                                  ",
		" 3Control argument ",
		"10Example ",
		" 1Access requirement                     ",
		" 1Access requirements                    ",
		"13Note                                   ",
		"17Active function syntax                 ",
		"17Active function usage                  ",
		" 2Active function arguments              ",
		" 2Active function argument               ",
		" 2Arguments as active function           ",
		" 6Active function control arguments      ",
		" 6Active function control argument       ",
		" 6Control arguments as active function   ",
		"16Command syntax                         ",
		"16Command usage                          ",
		" 2Command arguments                      ",
		" 2Command argument                       ",
		" 4Command control arguments              ",
		" 4Command control argument               ",
		" 4Control argument as command            ");


dcl (
    UNKNOWN_TITLE	init (0),
    ACCESS_REQUIRED init (1),
    ARGUMENTS	init (2),
    CONTROL_ARGUMENTS init (3),
    CONTROL_ARGUMENTS_AS_A_COMMAND init (4),
    CONTROL_ARGUMENTS_AS_A_REQUEST init (5),
    CONTROL_ARGUMENTS_AS_AN_ACTIVE_FUNCTION init (6),
    CONTROL_ARGUMENTS_AS_AN_ACTIVE_REQUEST init (7),
    CONTROL_ARGUMENTS_FOR init (8),
    ENTRY_POINTS_IN init (9),
    EXAMPLES	init (10),
    FUNCTION	init (11),
    LIST_OF	init (12),
    NOTES		init (13),
    NOTES_ON	init (14),
    SYNTAX	init (15),
    SYNTAX_AS_A_COMMAND init (16),
    SYNTAX_AS_AN_ACTIVE_FUNCTION init (17),
    SYNTAX_AS_AN_ACTIVE_REQUEST init (18),
    USAGE		init (19),
    UNTITLED	init (20),
    EOF		init (99)
    )		fixed bin int static options (constant);

dcl 1 global, 2 (
	 backspace, bad_date, bad_entry, blank_white_space,
	 end_white_space, ends_in_NUL, entry_too_late, extra_name,
	 lines_too_long, missing_info, missing_name, missing_section,
	 need_2_blank_lines, need_command, need_ending_NL, need_function,
	 need_usage, no_entries, no_entry, no_hdr_name, no_sections,
	 no_syntax_name, no_usage_name, non_printable, non_std_title,
	 not_belong, nothing_done, null_segment, order_name, out_of_sequence,
	 paragraph_size, this_form_preferred, too_many
	 )	fixed bin (18);
/**** This "funny" size of (18) was chosen so the compiler could help	       */
/**** catch improperly called subroutines.			       */

dcl 1 local	like global;

dcl first_section_head char (80) var;


/* additional paragraphs of standard sections */

dcl 1 map		aligned,		/* error map for each type of error */
      2 count	fixed bin,	/* up to hbound (number) */
      2 actual_count fixed bin,
      2 number	(40) fixed bin;	/* line number of each occurrence */

dcl 1 errors	aligned,		/* global for a whole :Info: block or info seg */
      2 backspaces	like map,
      2 badchars	like map,		/* lines with non-printable chars */
      2 endblanks	like map,		/* lines end in white space */
      2 nonblanks	like map,		/* blank lines having white space */
      2 long_lines	like map;		/* lines longer than line_char_limit */

/* CONSTANTS */

dcl ME		char (32) int static options (constant) init ("validate_info_seg");

dcl ((T		init ("1"b),
    F		init (""b)) bit (1),
/****	printable includes BS HT NL and SP			       */
    PRINTABLE	char (98) init ("	
 !""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_"
		|| "`abcdefghijklmnopqrstuvwxyz{|}~"),
    LOWER_CASE	char (26) init ("abcdefghijklmnopqrstuvwxyz"),
    UPPER_CASE	char (26) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
				/*    DIGITS	char (10) init ("0123456789"),*/
    HDR_NAME_BREAK	char (4) init (",	) "), /* , HT ) SP */
				/*    IGNORE_CHARS	char (10) init ("	 
{[(,)]}"),			/* HT SP NL {... */
    WHITE_SPACE	char (2) init ("	 "), /* HT SP */
    HT		char (1) init ("	"),
				/*    OH_OH_SIX	char (1) init (""),/* \006 */
    NUL		char (1) init (" "),/* NUL */
    BS		char (1) init (""),	/* backspace */
    SP		char (1) init (" "),
    NL		char (1) init ("
")
    )		int static options (constant);

/**** LIMIT VALUES						       */

dcl (
    line_char_limit init (72),	/* including newline at end	       */
    heading_char_limit init (72),	/* for a section heading	       */
    par_line_limit	init (15)
    )		fixed bin int static options (constant);

/* error info */

dcl (highest_severity, severity_count, severity_limit) fixed bin;
dcl seg_count	fixed bin;
dcl info_count	fixed bin;
dcl 1 error_count,			/* error tabulation by severity      */
      2 (total,			/* # of occurances		       */
      segs,			/* # of segments containing..	       */
      infos,			/* # of infos containing...	       */
      seg,			/* 1- occurred in current segment    */
      info			/* 1- occurred in currend info       */
      )		(5) fixed bin;
dcl err_count	fixed bin;


/* star info */

dcl area		area based (area_ptr);


dcl area_ptr	ptr;
dcl star_index	fixed bin;


/* status info */

dcl 1 status_br	aligned like status_branch;

dcl af_sw		bit (1) aligned;
dcl arg		char (arg_len) based (arg_ptr);
dcl arg_count	fixed bin;
dcl arg_index	fixed bin;
dcl arg_len	fixed bin;
dcl arg_ptr	ptr;
dcl bf_format	char (4);
dcl current_names	(status_branch.nnames) char (32) based (current_names_ptr);
dcl current_names_ptr ptr;
dcl format	char (24);
dcl internal_sw	bit (1) aligned;
dcl path_count	fixed bin;	/* # of paths on command line	       */
dcl return_arg	char (return_len) varying based (return_ptr);
dcl return_len	fixed bin;
dcl return_ptr	ptr;
dcl src_arg	char (168);
dcl src_seg	char (src_len) unaligned based (src_ptr);
dcl src_ptr	ptr;
dcl src_len	fixed bin (24);
dcl src_index	fixed bin (24);
dcl src_bc	fixed bin (24);
dcl src_path	char (201);
dcl src_dname	char (168);
dcl saved_dn	char (168);
dcl src_ename	char (32);
dcl star_en	char (32);
dcl temp_ptr	ptr;
dcl two_paragraph_syntax_sw bit (1) aligned;
dcl div_names_ct	fixed bin;
dcl div_names_ptr	ptr;
dcl div_names_x1	fixed bin;
dcl div_names_x2	fixed bin;
dcl 1 temp	based (temp_ptr),
      2 sort	aligned,		/* array to use with sort_items_     */
        3 n	fixed bin (18),
        3 vector	(1023) ptr unaligned, /* -> a name set		       */
      2 list_ct	fixed bin,	/* # of list elements in use	       */
      2 list	(1023) like div_names;
dcl 1 div_names	(div_names_ct) based (div_names_ptr),
      2 name	char (32),	/* addname, including ".info"	       */
      2 flag	fixed bin;

dcl 1 current,			/* data about info being checked     */
      2 count	fixed bin,	/* # of sections in use	       */
      2 pass	fixed bin,
      2 e		(12),
        3 used	fixed bin,	/* # of uses of this title	       */
        3 minuse	fixed bin,	/* minimum # required	       */
        3 maxuse	fixed bin (24),	/* maximum # allowed	       */
        3 title	fixed bin;	/* text of the title	       */

/* header info */

dcl header_date	char (32);
dcl header_clock	fixed bin (71);
dcl header	char (72) var;	/* text after the date */
dcl header_short_name char (256) var;
dcl header_short_name_temp char (256) var;
dcl names_left_to_add bit (1) aligned;
dcl info_name	char (32) var;
dcl entry_date	char (32);
dcl entry_clock	fixed bin (71);


/* section info */

dcl 1 section_ptr_len aligned,
      2 section_ptr ptr,
      2 section_len fixed bin;
/**** values set by the HEAD routine				       */
dcl section_head	char (40) var;	/* section heading returned	       */
dcl section_id	fixed bin;	/* section head ID		       */
dcl last_section_head char (40) var;
dcl normal_head	char (40) var;	/* normalized section heading	       */
dcl section_head_len fixed bin;	/* number of chars in section head   */
dcl section_line_number fixed bin;	/* number of first line in section   */
dcl section_line_count fixed bin;	/* number of lines in section	       */
dcl section_skip	fixed bin;	/* chars occupied by section heading as given */
dcl section_index	fixed bin;
dcl last_seq	fixed bin;

dcl (blank_char_count, blank_line_count) fixed bin;


/* paragraph info */

dcl par		char (par_len) based (par_ptr);
dcl 1 par_ptr_len	aligned,
      2 par_ptr	ptr,
      2 par_len	fixed bin (24);
dcl par_offset	fixed bin (24);

dcl par_1st_line_len fixed bin;	/* length of 1st line of paragraph */
dcl par_line_number fixed bin;	/* number of first line in paragraph */
dcl par_line_count	fixed bin (24);	/* number of lines in paragraph */
dcl par_unit_line_number fixed bin;     /* number of first line in paragraph unit */
dcl par_unit_line_count fixed bin (24); /* number of lines in paragraph unit */

/* line info */

dcl line		char (line_len) based (line_ptr);
dcl 1 line_ptr_len	aligned,
      2 line_ptr	ptr,
      2 line_len	fixed bin;

dcl line_number	fixed bin;	/* line number in segment */
dcl n_cols	fixed bin;	/* number of character positions in line */
dcl (line_index, special_index) fixed bin (21); /* for counting character positions */


/* switches */

dcl (
    begin_info_sw,			/* starting a new Info	       */
    blank_line_sw,			/* blank line returned by get_line   */
    colon_info_seen_sw,		/* :Info: has been seen	       */
    colon_entry_seen_sw,		/* otherwise, :Entry: has been seen  */
    subroutine_info,		/* This is a subroutine block	       */
    end_info_sw,			/* get_section hit :Info:/:Entry:    */
    entry_info,			/* in a :Entry: block	       */
    general_info,			/* "general info" component	       */
    got_par_sw,			/* a paragraph has been read	       */
    header_shown_sw,		/* header has been displayed	       */
    link_sw,			/* current path is to a link.	       */
    name_sw,			/* -names specified		       */
    non_standard,			/* non-standard section title	       */
    new_segment_sw,			/* starting a new segment	       */
    scanning,			/* 1- just looking, suppress msgs    */
    total_sw)	bit (1) aligned;	/* -total specified		       */

dcl temp_sw	bit (1);

dcl dtem_string	char (32);

dcl (i, j)	fixed bin;

dcl code		fixed bin (35);

dcl error_table_$bad_conversion fixed bin(35) ext static;
dcl error_table_$badopt fixed bin (35) ext;
dcl error_table_$badstar fixed bin (35) ext;
dcl error_table_$noentry fixed bin (35) ext;
dcl error_table_$not_act_fnc fixed bin (35) ext;

dcl complain	automatic entry options (variable);
dcl get_an_info	automatic entry;

dcl active_fnc_err_ entry options (variable);
dcl active_fnc_err_$suppress_name entry options (variable);
dcl check_star_name_$entry entry (char (*), fixed bin (35));
dcl com_err_	entry () options (variable);
dcl com_err_$suppress_name entry options (variable);
dcl convert_date_to_binary_$relative entry (char (*), fixed bin (71), fixed bin (71), fixed bin (35));
dcl cu_$af_return_arg entry (fixed bin, ptr, fixed bin, fixed bin (35));
dcl cu_$arg_ptr	entry (fixed bin, ptr, fixed bin, fixed bin (35));
dcl cv_fstime_	entry (bit (36) aligned) returns (fixed bin (71));
dcl date_time_$format entry (char (*), fixed bin (71), char (*), char (*)) returns (char (250) var);
dcl expand_pathname_$add_suffix entry (char (*), char (*), char (*), char (*), fixed bin (35));
dcl release_temp_segment_ entry (char (*), ptr, fixed bin (35));
dcl get_temp_segment_ entry (char (*), ptr, fixed bin (35));
dcl get_system_free_area_ entry returns (ptr);
dcl hcs_$star_dir_list_ entry (char (*), char (*), fixed bin (3), ptr, fixed bin, fixed bin,
		ptr, ptr, fixed bin (35));
dcl hcs_$status_	entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35));
dcl initiate_file_	entry (char (*), char (*), bit (*), ptr, fixed bin (24), fixed bin (35));
dcl pathname_	entry (char (*), char (*)) returns (char (168));
dcl sort_items_$char entry (ptr, fixed bin (24));
dcl terminate_file_ entry (ptr, fixed bin(24), bit(*), fixed bin(35));
dcl (ioa_, ioa_$nnl) entry options (variable);

dcl (addcharno, addr, before, binary, char, charno, convert, divide, fixed,
    hbound, index, lbound, length, ltrim, max, min, mod, null, pointer,
    reverse, rtrim, search, setcharno, string, substr, translate, unspec,
    verify
    )		builtin;

dcl (cleanup, conversion, program_interrupt, size) condition; %page;
/* ------------------------------------------------------------------------- */
/* MAINLINE -- all is controlled from here			       */
/* ------------------------------------------------------------------------- */

/**** Establish the proper command or AF environment		       */
      call cu_$af_return_arg (arg_count, return_ptr, return_len, code);
      if code = error_table_$not_act_fnc
      then do;
         if arg_count = 0
         then do;
usage:	  call com_err_$suppress_name (0, ME, "Usage:  vis paths {-control_args}");
	  return;
         end;
         af_sw = F;
         complain = com_err_;
      end;
      else do;
         if arg_count = 0
         then do;
af_usage:	  call active_fnc_err_$suppress_name (0, ME, "Usage:  [vis paths {-control_args}]");
	  return;
         end;
         af_sw = T;
         complain = active_fnc_err_;
      end;
/**** Begin initialization, Process control args			       */
      name_sw, total_sw = F;
      path_count, highest_severity, severity_limit = 0;
      do arg_index = 1 to arg_count;
         call cu_$arg_ptr (arg_index, arg_ptr, arg_len, (0));
         if substr (arg, 1, length ("-")) = "-"
         then if arg = "-severity" | arg = "-sv"
	    then do;
	       arg_index = arg_index + 1;
	       if arg_index > arg_count
	       then do;
		call complain (0, ME, "No value specified for ^a", arg);
		return;
	       end;
	       call cu_$arg_ptr (arg_index, arg_ptr, arg_len, (0));
	       on conversion,size goto BAD_CONVERSION;
	       severity_limit = convert (severity_limit, arg);
	       revert conversion,size;
	       if severity_limit > hbound (error_count.total, 1)
		  | severity_limit < lbound (error_count.total, 1)
	       then do;
		call complain (0, ME, "^d outside severity range ^d to ^d",
		     severity_limit, lbound (error_count.total, 1),
		     hbound (error_count.total, 1));
		return;
	       end;
	    end;
	    else if arg = "-total" | arg = "-tt"
	    then total_sw = T;
	    else if arg = "-names" | arg = "-nm"
	    then name_sw = T;
	    else if arg = "-no_names" | arg = "-nnm"
	    then name_sw = F;
	    else do;
	       call complain (error_table_$badopt, ME, "^a", arg);
	       return;
	    end;

         else path_count = path_count + 1;
      end;
/**** Check argument consistency				       */
      if (path_count = 0)
      then if af_sw
	 then goto af_usage;
	 else goto usage;
      if af_sw
      then do;
         total_sw = T;
         if (path_count > 1)
         then do;
AF_TOO_MANY:
	  call active_fnc_err_ (0, ME, "Active function does not accept multiple segments.");
	  return;
         end;
      end;
/**** Finish initializing.					       */
      backspaces.actual_count = hbound (backspaces.number, 1);
      badchars.actual_count = hbound (badchars.number, 1);
      endblanks.actual_count = hbound (endblanks.number, 1);
      nonblanks.actual_count = hbound (nonblanks.number, 1);
      long_lines.actual_count = hbound (long_lines.number, 1);
      get_an_info = VALIDATE;		/* make sure it points SOMEWHERE     */
      star_list_branch_ptr, star_list_names_ptr, status_ptr, src_ptr,
	 temp_ptr = null;
      on condition (cleanup) call CLEAN_UP;
      unspec (error_count) = ""b;
      seg_count, info_count = 0;
      info_name = "";
      unspec (global) = ""b;
      call get_temp_segment_ (ME, temp_ptr, code);
      if (code ^= 0)
      then do;
         call complain (code, ME, "Getting temp segment.");
         return;
      end;
      src_ename = star_en;
      if ^db_sw
      then on condition (program_interrupt) goto PI;
      if total_sw & ^af_sw
      then do;
         call ioa_ ("Info types:");
         call ioa_ ("^-"" ?  "" means UNKNOWN format info");
         call ioa_ ("^- ""GEN ""  means GENERAL info");
         call ioa_ ("^- ""COM ""  means COMMAND info");
         call ioa_ ("^- ""AFUN""  means ACTIVE FUNTION info");
         call ioa_ ("^- ""C/AF""  means COMMAND/ACTIVE FUNCTION info");
         call ioa_ ("^- ""REQ ""  means REQUEST info");
         call ioa_ ("^- ""AREQ""  means ACTIVE REQUEST info");
         call ioa_ ("^- ""R/AR""  means REQUEST/ACTIVE REQUEST info");
         call ioa_ ("^- ""SUB+""  means SUBROUTINE w/entries info");
         call ioa_ ("^- ""SUBe""  means SUBROUTINE entry info");
         call ioa_ ("^- ""SUBR""  means SUBROUTINE (no entries) info");
         call ioa_ ("^-"":Info:"" means the segment contains multiple infos.");
         call ioa_ ("
 HIGH #LONG #LONG  info
  SEV  pghs lines  type  INFO/Entry/SEGMENT NAME");
      end;

/**** Process pathnames					       */
      do arg_index = 1 to arg_count;
         call cu_$arg_ptr (arg_index, arg_ptr, arg_len, (0));
         if substr (arg, 1, length ("-")) ^= "-"
         then do;
	  src_arg = arg;
	  call expand_pathname_$add_suffix (src_arg, "info", src_dname, star_en, code);
	  if code ^= 0
	  then do;
BAD_PATH:	     call complain (code, ME, "^a", src_arg);
	     return;
	  end;
	  call PROCESS_STARNAME;
         end;
         else if arg = "-severity" | arg = "-sv"
         then arg_index = arg_index + 1;/* gobble up the associated arg      */
      end;
PI:   if total_sw & ^af_sw
      then do;
/****    Show totals					       */
         call ioa_ ("^/^d Segments, ^d Infos", seg_count, info_count);
         do i = hbound (error_count.total, 1) by -1 to 1;
	  temp_sw = (error_count.total (i) = 0);
	  call ioa_ (
	       "^[  NO^s^;^4d^] severity ^d errors^[ in ^4d segment^[ ^;s^] (^4d info^[s^])",
	       temp_sw, error_count.total (i), i, ^temp_sw,
	       error_count.segs (i), (error_count.segs (i) = 1),
	       error_count.infos (i), (error_count.infos (i) > 1));
         end;
         call ioa_ ("");
      end;

      if af_sw then return_arg = ltrim (char (highest_severity));

RETURN: call CLEAN_UP;
      return;

BAD_CONVERSION:
      call complain (error_table_$bad_conversion, ME, "^a", arg);
      return; %page;
/* ------------------------------------------------------------------------- */
/* Apply the star conventions to the source pathnames,		       */
/* then call VALIDATE for each info seg.			       */
/* ------------------------------------------------------------------------- */

PROCESS_STARNAME: proc;

      status_ptr, star_list_branch_ptr, star_list_names_ptr = null ();
      call check_star_name_$entry (star_en, code);
      if code = error_table_$badstar
      then do;
         call complain (code, ME, "^a", src_arg);
         goto RETURN;
      end;
      if code = 0
      then do;
         src_ename = star_en;
         call VALIDATE;
      end;
      else do;
         area_ptr = get_system_free_area_ ();
         star_select_sw = star_ALL_ENTRIES;
         call hcs_$star_dir_list_ (src_dname, star_en, star_select_sw,
	    area_ptr, star_branch_count, star_link_count, star_list_branch_ptr,
	    star_list_names_ptr, code);
         if code ^= 0
         then do;
	  call complain (code, ME, "^a^[>^]^a", src_dname, src_dname ^= ">", star_en);
	  return;
         end;
         if (star_branch_count > 1) & af_sw
         then goto AF_TOO_MANY;
         saved_dn = src_dname;
         do star_index = 1 to star_branch_count + star_link_count;
	  src_ename = star_list_names (star_dir_list_branch (star_index).nindex);
	  src_dname = saved_dn;
	  call VALIDATE;
         end;
      end;
      call CLEAN_UP$some;

   end PROCESS_STARNAME; %page;
/* ------------------------------------------------------------------------- */
/* Validate a single info segment, printing non-brief information,	       */
/* then printing error messages				       */
/* ------------------------------------------------------------------------- */

VALIDATE: proc;

      src_path = pathname_ (src_dname, src_ename);
      status_area_ptr = get_system_free_area_ ();
      status_ptr = addr (status_br);
      unspec (status_branch) = ""b;
      status_branch.type = Directory;
      call hcs_$status_ (src_dname, src_ename, 1, status_ptr, status_area_ptr, code);

      if code = 0
      then dtem_string = date_time_$format ("date", cv_fstime_ ((status_branch.dtem)), "", "");
      else dtem_string = "";
      link_sw = (status_link.type = Link);
      current_names_ptr = addr (status_entry_names);
      if ^total_sw
      then call ioa_ ("^/^a^[ (LINK)^]", src_path, link_sw);
      call initiate_file_ (src_dname, src_ename, "100"b, src_ptr, src_bc, code); /* Read mode */
      if (code ^= 0)
      then do;
         if code = error_table_$noentry
         then call ERR_MSG3 (local.no_entry, 0, no_entry);
         else do;
	  call complain (code, ME, "^a", src_path);
	  call ERR_MSG3 (local.nothing_done, 0, nothing_done);
         end;
         goto null_file;
      end;

      if ep_sw
      then call ioa_ ("FIL:^( ^a: ^a: ^a:^/^)", current_names);
      seg_count = seg_count + 1;
      new_segment_sw = T;
      colon_info_seen_sw, colon_entry_seen_sw, general_info, entry_info = F;

      nest = 1;
      temp.sort.n, temp.list_ct, line_number = 0;
      src_index = 1;
      src_len = divide (src_bc, 9, 24, 0);
      if (src_len = 0)
      then do;
         call ERR_MSG3 (local.null_segment, 0, zero_segment);
         goto null_file;
      end;
/**** See if there are any trailing NULs (complain if so), strip them off    */
/**** and see if anything left (complain if not).			       */
      nest = verify (reverse (src_seg), NUL) - 1;
      if (nest = -1)
      then do;
         call ERR_MSG (local.null_segment, 0, null_segment, "", src_len, 0);
         goto null_file;
      end;
      if (nest > 0)
      then do;
         call ERR_MSG (local.ends_in_NUL, 0, ends_in_NUL, "", nest, 0);
         src_len = src_len - nest;
      end;
/**** Check for NL at end of segment (complain if none).		       */
      if (substr (src_seg, src_len, 1) ^= NL)
      then call ERR_MSG3 (local.need_ending_NL, 0, need_ending_NL);
      highest_severity, par_line_count = 0;
      par_unit_line_count = 0;
      unspec (errors) = "0"b;
      nest = 1;

      got_par_sw = F;
      header_shown_sw = F;
      if (index (src_seg, "
:Info:") ^= 0) | (index (src_seg, "
:Internal:") ^= 0)
      then do;			/* this is multi-info format	       */
         colon_info_seen_sw = T;
         if (substr (src_seg, 1, 6) ^= ":Info:")
	    & (substr (src_seg, 1, 10) ^= ":Internal:")
         then call ERR_MSG3 (local.missing_info, 0, missing_info);
      end;
      else if (index (src_seg, "
:Entry:") ^= 0)
      then do;
         colon_entry_seen_sw = T;
      end;
      line_number = 0;
      src_index = 1;
      do while (src_index < src_len);	/* go as long as any data is left    */
         call GET_INFO;
      end;
      if ^general_info then call check_addnames();

null_file:
      do sev = 1 to 5;
         error_count.segs (sev) = error_count.segs (sev) + error_count.seg (sev);
         error_count.seg (sev) = 0;
      end;

      if ^total_sw
      then call ioa_ ("^/");
      if src_ptr ^= null
      then call terminate_file_ (src_ptr, (0), TERM_FILE_TERM, (0));
      return; %page;
/* ------------------------------------------------------------------------- */
/* Compare the list of names on the segment with the list of names derived   */
/* from the dividers in the segment.  If they are not the same (including    */
/* order), either change the segment's names (-names) or tell what is wrong  */
/* (-no_names). The names are sorted by longname. Any short names follow a   */
/* longname in the order they occurred in the divider. If no divider exists, */
/* the names are gotten from the header.			       */
/* ------------------------------------------------------------------------- */

check_addnames: proc;

dcl t_ptr		ptr;
dcl t_ct		fixed bin;
dcl a_name	char(32);
dcl done		bit (1) aligned;
dcl error_table_$segnamedup fixed bin(35) ext static;
dcl hcs_$chname_seg entry (ptr, char(*), char(*), fixed bin(35));
dcl order_sw	bit (1) aligned;
dcl used_sw	(status_branch.nnames) bit (1) aligned;

      if (temp.sort.n = 1)
      then do;
         div_names_ptr = temp.sort.vector (1);
         do div_names_ct = 1 to 1000 while (div_names.flag (div_names_ct) ^= 0);
         end;
      end;
      else do;
/****    There's plenty of room in temp, make a sorted array there	       */
         call sort_items_$char (addr (temp.sort), length (temp.list.name (1)));
         div_names_ptr = addr (temp.list (temp.list_ct + 1));
         t_ct = 0;
         div_names_x1, div_names_x2 = 1;
         do while (div_names_x1 <= temp.sort.n);
	  t_ptr = temp.sort.vector (div_names_x1);
	  t_ct = t_ct + 1;
	  div_names.name (t_ct) = t_ptr -> div_names.name (div_names_x2);
	  if (t_ptr -> div_names.flag (div_names_x2) = 0)
	  then do;
	     div_names_x1 = div_names_x1 + 1;
	     div_names_x2 = 1;
	  end;
	  else div_names_x2 = div_names_x2 + 1;
         end;
         div_names_ct = t_ct;
      end;

      unspec (used_sw) = "0"b;
/**** If derived list is the same size as addname list, check equality       */
      if (div_names_ct = status_branch.nnames)
      then do;
         do i = 1 to div_names_ct;
	  if (div_names.name (i) ^= current_names (i))
	  then goto does_not_match;
         end;
         return;			/* AOK			       */

does_not_match:
      end;
      if name_sw
      then do;
/****    Change the set of names to what we want.	Since we are not working  */
/****    ..with extended objects, we are using hcs_$chname_file	       */
         a_name = div_names.name (1);
/****    First make sure the new primary name is there.		       */
         do j = 1 to status_branch.nnames;
	  if (current_names (j) = a_name)
	  then goto already_there;
         end;
/****    Since the needed name is not there, add it		       */
         call hcs_$chname_seg (src_ptr, "", a_name, code);
         if (code ^= 0)
         then if (code ^= error_table_$segnamedup)
         then do;
	  call complain (code, ME, "Trying to add ^a to ^a", a_name, src_path);
	  return;
         end;
already_there:
/****    Next, delete all names except the new primary one.		       */
         do j = 1 to status_branch.nnames;
	  if (current_names (j) ^= a_name)
	  then do;
	     call hcs_$chname_seg (src_ptr, (current_names (j)), "", code);
	     if (code ^= 0)
	     then do;
	        call complain (code, ME, "Trying to delete ^a from ^a",
		 current_names (j), src_path);
	        return;
	     end;
	  end;
         end;
/****    Lastly, add all the needed extra names.			       */
         do i = 2 to div_names_ct;
	  call hcs_$chname_seg (src_ptr, "", div_names.name (i), code);
	  if (code ^= 0)
	  then do;
	     call complain (code, ME, "Trying to add ^a to ^a",
	        div_names.name (i), src_path);
	     return;
	  end;
         end;
         return;
      end;
/**** Tell what is wrong with the addnames.			       */
/****       (No attempt was made here to optimize this searching procedure.) */
      order_sw = T;
/**** Each name in the divider list should be in the addname list.	       */
      do i = 1 to div_names_ct;
         a_name = div_names.name (i);
         done = ""b;
         do j = 1 to status_branch.nnames while (^done);
	  if (current_names (j) = a_name)
	  then do;
	     used_sw (j) = "1"b;
	     done = "1"b;
	  end;
         end;
         if ^done
         then do;
	  order_sw = F;
	  call ERR_MSG (local.missing_name, 00, missing_name,
	     a_name, 0, 0);
         end;
      end;
/**** Each name in the addname list should be in the divider list.	       */
      do j = 1 to status_branch.nnames;
         if ^used_sw (j)
         then do;
	  order_sw = F;
	  call ERR_MSG (local.extra_name, 00, extra_name,
	     (current_names (j)), 0, 0);
         end;
      end;
/**** If all names were accounted for, then the problem is ORDER.	       */
      if order_sw
      then call ERR_MSG3 (local.order_name, 0, order_name);
      return;

   end check_addnames;


dcl sev		fixed bin; %skip (4);
/* ------------------------------------------------------------------------- */
/*			tracing utilities			       */
/* ------------------------------------------------------------------------- */
dcl nest		fixed bin (24) init (1);

PUSH: proc (name);
dcl name		char (24);
      call ioa_ ("^v(: ^)>^a ^i:^i^[ eof^]^[ par^]^[ SCAN^]",
	 nest, name, src_index, src_len, end_info_sw, got_par_sw, scanning);
      nest = nest + 1;
   end PUSH;

POP: proc (name);
dcl name		char (24);
      nest = nest - 1;
      call ioa_ ("^v(: ^)<^a ^i:^i^[ eof^]^[ par^]^[ SCAN^]",
	 nest, name, src_index, src_len, end_info_sw, got_par_sw, scanning);
   end POP; %page;
/* ------------------------------------------------------------------------- */
/* GET_INFO considers an "Info" to be a whole segment, or a portion of a     */
/* segment beginning with either ":Info:" or ":Entry:" and including every-  */
/* thing up to either ":Info:", ":Entry:", or end-of-segment.                */
/* ------------------------------------------------------------------------- */

GET_INFO: proc;
dcl hold_type	entry automatic;
      if tr_sw then call PUSH ("GET_INFO");
      unspec (local) = ""b;
      hold_type = get_an_info;
      get_an_info = CHECK_INFO_TYPE ();
      if (hold_type = MULTSUB_INFO)
	 & (get_an_info ^= ENTRY___INFO)
      then call ERR_MSG3 (local.no_entries, 0, no_entries);
      else if (get_an_info = ENTRY___INFO)
	 & (hold_type ^= ENTRY___INFO)
	 & (hold_type ^= MULTSUB_INFO)
      then call ERR_MSG3 (local.bad_entry, 0, bad_entry);
      div_names_ct = 0;
      div_names_ptr = null ();
      unspec (local) = ""b;
      call get_an_info;		/* process an info block	       */
      if (first_section_head = "<empty info>")
      then call ERR_MSG3 (local.no_sections, 0, no_sections);
      call PRINT_ERR_SUMMARY;
      do sev = 1 to 5;
         error_count.infos (sev) = error_count.infos (sev) + error_count.info (sev);
         error_count.info (sev) = 0;
      end;
      info_name = "";
/**** if there is still more segment to process, back up to the beginning    */
/**** ..of the info divider.					       */
      if (src_index < src_len)
      then do;
         src_index = par_offset;
         line_number = par_line_number - 1;
      end;
      if tr_sw then call POP ("GET_INFO");

   end GET_INFO; %page;
CHECK_INFO_TYPE: proc returns (entry);

dcl hold_src_index	fixed bin;
dcl hold_line_number fixed bin;
dcl result	entry automatic;

      scanning = T;
      subroutine_info = F;
      hold_src_index = src_index;
      hold_line_number = line_number;
      got_par_sw = F;
      call GET_HEADER;		/* scanning		       */
      if general_info
      then result = GENERAL_INFO;
      else if entry_info
      then result = ENTRY___INFO;
      else if colon_entry_seen_sw
      then result = MULTSUB_INFO;
      else do;
         call GET_SECTION;
         if (section_id = UNTITLED)
         then do;
	  call GET_SECTION;
	  if (section_id = ENTRY_POINTS_IN)
	  then result = MULTSUB_INFO;
	  else do;
	     result = SINGSUB_INFO;
	     subroutine_info = T;
	  end;
         end;
         else if (section_id = FUNCTION)
         then do;
	  result = SINGSUB_INFO;
	  subroutine_info = T;
         end;
         else if (section_id = SYNTAX_AS_A_COMMAND)
         then do;
	  call GET_SECTION;
	  if (section_id = SYNTAX_AS_AN_ACTIVE_FUNCTION)
	  then result = COMM_AF_INFO;
	  else result = COMMAND_INFO;
         end;
         else if (section_id = SYNTAX_AS_AN_ACTIVE_FUNCTION)
         then do;
	  call GET_SECTION;
	  if (section_id = SYNTAX_AS_A_COMMAND) | (section_id = SYNTAX)
	  then result = COMM_AF_INFO;
	  else result = ACT_FUN_INFO;
         end;
         else if (section_id = SYNTAX)
         then do;
	  call GET_SECTION;
	  if (section_id = SYNTAX_AS_AN_ACTIVE_REQUEST)
	  then result = REQU_AR_INFO;
	  else if (section_id = SYNTAX_AS_AN_ACTIVE_FUNCTION)
	  then result = COMM_AF_INFO;
	  else result = REQUEST_INFO;
         end;
         else if (section_id = SYNTAX_AS_AN_ACTIVE_REQUEST)
         then do;
	  call GET_SECTION;
	  if (section_id = SYNTAX)
	  then result = REQU_AR_INFO;
	  else result = ACT_REQ_INFO;
         end;
         else result = UNKNOWN_INFO;
      end;
      src_index = hold_src_index;
      line_number = hold_line_number;
      scanning = F;
      got_par_sw = F;
      if db_sw then call ioa_ ("|----------");
      return (result);

   end CHECK_INFO_TYPE; %page;
/* ------------------------------------------------------------------------- */
/* These routines (*_INFO) are designed to make it obvious for each of the   */
/*  Info Types what the allowed sections are, whether optional or required,  */
/*  and what order they must occur in.				       */
/* ------------------------------------------------------------------------- */

/* ------------------------------------------------------------------------- */
/*			COMMAND-only info			       */
/* ------------------------------------------------------------------------- */

COMMAND_INFO: proc;

/**** set the identification for total and complete cases		       */
      bf_format = "COM "; format = "COMMAND";
      if tr_sw then call PUSH ("COMMAND_INFO");
				/* format: off */
      call GET_HEADER;		/* process first line of info block  */
      call SEC$init (8);
/****             seq min max next "title"			       */
L(0):
L(1): goto L(SEC  ( 1,  1,  1,  1, SYNTAX_AS_A_COMMAND));
L(2): goto L(SEC  ( 2,  1,  1,  2, FUNCTION));
L(3): goto L(SEC  ( 3,  0,  1,  3, ARGUMENTS));
L(4): goto L(SECx ( 4,  0,  1,  4, CONTROL_ARGUMENTS));
L(5): goto L(SECx ( 5,  0,  1,  4, CONTROL_ARGUMENTS_AS_A_COMMAND));
L(6): goto L(SECx ( 6,  0, 99,  4, CONTROL_ARGUMENTS_FOR));
L(7): goto L(SECx ( 7,  0,  1,  7, ACCESS_REQUIRED));
L(8): goto L(SECx ( 8,  0,  1,  8, EXAMPLES));
L(9):	;			/* end-of-info		       */
     				/* format: on		       */

      if tr_sw then call POP ("COMMAND_INFO");

   end COMMAND_INFO; %skip (5);
/* ------------------------------------------------------------------------- */
/*		      ACTIVE FUNCTION only info		       */
/* ------------------------------------------------------------------------- */

ACT_FUN_INFO: proc;

      bf_format = "AFUN"; format = "ACTIVE FUNTION";
      if tr_sw then call PUSH ("ACT_FUN_INFO");
				/* format: off */
      call GET_HEADER;		/* process first line of info block  */
      call SEC$init (8);
/****             seq min max next "title"			       */
L(0):
L(1): goto L(SEC  ( 1,  1,  1,  1, SYNTAX_AS_AN_ACTIVE_FUNCTION));
L(2): goto L(SEC  ( 2,  1,  1,  2, FUNCTION));
L(3): goto L(SEC  ( 3,  0,  1,  3, ARGUMENTS));
L(4): goto L(SECx ( 4,  0,  1,  4, CONTROL_ARGUMENTS));
L(5): goto L(SECx ( 5,  0,  1,  4, CONTROL_ARGUMENTS_AS_AN_ACTIVE_FUNCTION));
L(6): goto L(SECx ( 6,  0, 99,  4, CONTROL_ARGUMENTS_FOR));
L(7): goto L(SECx ( 7,  0,  1,  7, ACCESS_REQUIRED));
L(8): goto L(SECx ( 8,  0,  1,  8, EXAMPLES));
L(9):	;			/* end-of-info		       */
     				/* format: on		       */
      if tr_sw then call POP ("ACT_FUN_INFO");

   end ACT_FUN_INFO; %skip (5);
/* ------------------------------------------------------------------------- */
/*		    COMMAND & ACTIVE FUNCTION info		       */
/* ------------------------------------------------------------------------- */

COMM_AF_INFO: proc;
      bf_format = "C/AF"; format = "COMMAND/ACTIVE FUNCTION";
      if tr_sw then call PUSH ("COMM_AF_INFO");
				/* format: off */
      call GET_HEADER;		/* process first line of info block  */
      call SEC$init (10);
/****             seq min max next "title"			       */
L(0):
L(1): goto L(SEC  ( 1,  1,  1,  1, SYNTAX_AS_A_COMMAND));
L(2): goto L(SEC  ( 2,  1,  1,  1, SYNTAX_AS_AN_ACTIVE_FUNCTION));
L(3): goto L(SEC  ( 3,  1,  1,  3, FUNCTION));
L(4): goto L(SEC  ( 4,  0,  1,  4, ARGUMENTS));
L(5): goto L(SECx ( 5,  0,  1,  5, CONTROL_ARGUMENTS));
L(6): goto L(SECx ( 6,  0,  1,  5, CONTROL_ARGUMENTS_AS_A_COMMAND));
L(7): goto L(SECx ( 7,  0,  1,  5, CONTROL_ARGUMENTS_AS_AN_ACTIVE_FUNCTION));
L(8): goto L(SECx ( 8,  0, 99,  5, CONTROL_ARGUMENTS_FOR));
L(9): goto L(SECx ( 9,  0,  1,  9, ACCESS_REQUIRED));
L(10):goto L(SECx (10,  0,  1, 10, EXAMPLES));
L(11):		;		/* end-of-info		       */
     				/* format: on		       */
      if tr_sw then call POP ("COMM_AF_INFO");

   end COMM_AF_INFO; %skip (5);
/* ------------------------------------------------------------------------- */
/*			REQUEST only info			       */
/* ------------------------------------------------------------------------- */

REQUEST_INFO: proc;
      bf_format = "REQ "; format = "REQUEST";
      if tr_sw then call PUSH ("REQUEST_INFO");
				/* format: off */
      call GET_HEADER;		/* process first line of info block  */
      call SEC$init (8);
/****             seq min max next "title"			       */
L(0):
L(1): goto L(SEC  ( 1,  1,  1,  1, SYNTAX));
L(2): goto L(SEC  ( 2,  1,  1,  2, FUNCTION));
L(3): goto L(SEC  ( 3,  0,  1,  3, ARGUMENTS));
L(4): goto L(SECx ( 4,  0,  1,  4, CONTROL_ARGUMENTS));
L(5): goto L(SECx ( 5,  0,  1,  4, CONTROL_ARGUMENTS_AS_A_REQUEST));
L(6): goto L(SECx ( 6,  0, 99,  4, CONTROL_ARGUMENTS_FOR));
L(7): goto L(SECx ( 7,  0,  1,  7, ACCESS_REQUIRED));
L(8): goto L(SECx ( 8,  0,  1,  8, EXAMPLES));
L(9):		;		/* end-of-info		       */
     				/* format: on		       */
      if tr_sw then call POP ("REQUEST_INFO");

   end REQUEST_INFO; %skip (5);
/* ------------------------------------------------------------------------- */
/*		       ACTIVE REQUEST only info		       */
/* ------------------------------------------------------------------------- */

ACT_REQ_INFO: proc;
      bf_format = "AREQ"; format = "ACTIVE REQUEST";
      if tr_sw then call PUSH ("ACT_REQ_INFO");
				/* format: off */
      call GET_HEADER;		/* process first line of info block  */
      call SEC$init (8);
/****             seq min max next "title"			       */
L(0):
L(1): goto L(SEC  ( 1,  1,  1,  1, SYNTAX_AS_AN_ACTIVE_REQUEST));
L(2): goto L(SEC  ( 2,  1,  1,  2, FUNCTION));
L(3): goto L(SEC  ( 3,  0,  1,  3, ARGUMENTS));
L(4): goto L(SECx ( 4,  0,  1,  4, CONTROL_ARGUMENTS));
L(5): goto L(SECx ( 5,  0,  1,  4, CONTROL_ARGUMENTS_AS_AN_ACTIVE_REQUEST));
L(6): goto L(SECx ( 6,  0, 99,  4, CONTROL_ARGUMENTS_FOR));
L(7): goto L(SECx ( 7,  0,  1,  7, ACCESS_REQUIRED));
L(8): goto L(SECx ( 8,  0,  1,  8, EXAMPLES));
L(9):		;		/* end-of-info		       */
     				/* format: on		       */
      if tr_sw then call POP ("ACT_REQ_INFO");

   end ACT_REQ_INFO; %skip (5);
/* ------------------------------------------------------------------------- */
/*		    REQUEST & ACTIVE REQUEST info		       */
/* ------------------------------------------------------------------------- */

REQU_AR_INFO: proc;
      bf_format = "R/AR"; format = "REQUEST/ACTIVE REQUEST";
      if tr_sw then call PUSH ("REQU_AR_INFO");
				/* format: off */
      call GET_HEADER;		/* process first line of info block  */
      call SEC$init (10);
/****             seq min max next "title"			       */
L(0):
L(1): goto L(SEC  ( 1,  1,  1,  1, SYNTAX));
L(2): goto L(SEC  ( 2,  1,  1,  1, SYNTAX_AS_AN_ACTIVE_REQUEST));
L(3): goto L(SEC  ( 3,  1,  1,  3, FUNCTION));
L(4): goto L(SEC  ( 4,  0,  1,  4, ARGUMENTS));
L(5): goto L(SECx ( 5,  0,  1,  5, CONTROL_ARGUMENTS));
L(6): goto L(SECx ( 6,  0,  1,  5, CONTROL_ARGUMENTS_AS_A_REQUEST));
L(7): goto L(SECx ( 7,  0,  1,  5, CONTROL_ARGUMENTS_AS_AN_ACTIVE_REQUEST));
L(8): goto L(SECx ( 8,  0, 99,  5, CONTROL_ARGUMENTS_FOR));
L(9): goto L(SECx ( 9,  0,  1,  9, ACCESS_REQUIRED));
L(10):goto L(SECx (10,  0,  1, 10, EXAMPLES));
L(11):		;		/* end-of-info		       */
     				/* format: on		       */
      if tr_sw then call POP ("REQU_AR_INFO");

   end REQU_AR_INFO; %skip (5);
/* ------------------------------------------------------------------------- */
/*		    SUBROUTINE w/multiple entries		       */
/* ------------------------------------------------------------------------- */

MULTSUB_INFO: proc;
      bf_format = "SUB+"; format = "SUBROUTINE w/entries";
      if tr_sw then call PUSH ("MULTSUB_INFO");
				/* format: off */
      call GET_HEADER;		/* process first line of info block  */
      call SEC$init (2);
/****             seq min max next "title"			       */
P(0):   
P(1): goto P(SEC  ( 1,  1,  1,  1, UNTITLED));
P(2): goto P(SEC  ( 2,  1,  1,  2, ENTRY_POINTS_IN));
P(3):	;			/* end-of-info		       */
      if tr_sw then call POP ("MULTSUB_INFO");
      return;

ENTRY___INFO: entry;
      bf_format = "SUBe"; format = "SUBROUTINE entry";
      if tr_sw then call PUSH ("ENTRY___INFO");
      subroutine_info = T;
      header_shown_sw = F;
      call GET_HEADER;		/* process first line of info block  */
      call SEC$init (5);
/****             seq min max next "title"			       */
L(0):
L(1): goto L(SEC  ( 1,  1,  1,  1, FUNCTION));
L(2): goto L(SEC  ( 2,  1,  1,  2, USAGE));
L(3): goto L(SEC  ( 3,  0,  1,  3, ARGUMENTS));
L(4): goto L(SECx ( 4,  0,  1,  4, ACCESS_REQUIRED));
L(5): goto L(SECx ( 5,  0,  1,  5, EXAMPLES));
L(6):		;		/* end-of-info		       */
     				/* format: on		       */
      if tr_sw then call POP ("ENTRY___INFO");

   end MULTSUB_INFO; %skip (5);
/* ------------------------------------------------------------------------- */
/*		        SUBROUTINE w/one entry		       */
/* ------------------------------------------------------------------------- */

SINGSUB_INFO: proc;
      bf_format = "SUBR"; format = "SUBROUTINE (no entries)";
      if tr_sw then call PUSH ("SINGSUB_INFO");
				/* format: off */
      call GET_HEADER;		/* process first line of info block  */
      call SEC$init (5);
/****             seq min max next "title"			       */
L(0):
L(1): goto L(SEC  ( 1,  1,  1,  1, FUNCTION));
L(2): goto L(SEC  ( 2,  1,  1,  2, USAGE));
L(3): goto L(SEC  ( 3,  0,  1,  3, ARGUMENTS));
L(4): goto L(SECx ( 4,  0,  1,  4, ACCESS_REQUIRED));
L(5): goto L(SECx ( 5,  0,  1,  5, EXAMPLES));
L(6):	;			/* end-of-info		       */
     				/* format: on		       */
      if tr_sw then call POP ("SINGSUB_INFO");

   end SINGSUB_INFO; %skip (3);
/* ------------------------------------------------------------------------- */
/*	         could not figure out what kind this was		       */
/* ------------------------------------------------------------------------- */
UNKNOWN_INFO: proc;
      bf_format = " ?  "; format = "UNKNOWN format";
      goto common;

/* ------------------------------------------------------------------------- */
/*		  GENERAL info - any kind of section		       */
/* ------------------------------------------------------------------------- */

GENERAL_INFO: entry;
      bf_format = "GEN "; format = "GENERAL";
common:
      if tr_sw then call PUSH (format);
      call GET_HEADER;		/* process first line of info block  */
      do while (^end_info_sw);
         call GET_SECTION;
      end;
      if tr_sw then call POP (format);

   end UNKNOWN_INFO; %page;
/* ------------------------------------------------------------------------- */
/* Test for the current section being what is needed. Returns the number of  */
/* the next test to run. SEC just tests for the presence of P_title, while   */
/* SECx also accepts LIST_OF, NOTES, and NOTES_ON.		       */
/* ------------------------------------------------------------------------- */

SEC: proc (P_seq_no, P_min, P_max, P_group_no, P_title) returns (fixed bin);
      extra_sw = ""b;
      goto common;

SECx: entry (P_seq_no, P_min, P_max, P_group_no, P_title) returns (fixed bin);
      extra_sw = "1"b;
      goto common;

dcl (
    P_seq_no	fixed bin,	/* sequence # of this title	       */
    P_min		fixed bin,	/* Minimum # of these allowed	       */
    P_max		fixed bin,	/* Maximum # of these allowed	       */
    P_group_no	fixed bin,	/* group # of this title, when some  */
				/* ..titles occur in any order, they */
				/* ..all have the same group #       */
    P_title	fixed bin		/* title identifier		       */
    )		parameter;

dcl extra_sw	bit (1) aligned;
dcl i		fixed bin;

common:
      if tr_sw then call ioa_ ("  SEC ^4(^3i^) ^i::^a", P_seq_no, P_min, P_max,
	      P_group_no, section_id, std_section (P_title));
/**** fill in item data for later use				       */
      current.title (P_seq_no) = P_title;
      current.minuse (P_seq_no) = P_min;
      current.maxuse (P_seq_no) = P_max;
/**** If no data left, still walk down the list			       */
      if (section_id = EOF)
      then do;
         if (P_seq_no = current.count)
         then do i = 1 to current.count;
	  if (current.used (i) < current.minuse (i))
	  then do;
	     call ERR_MSG (local.missing_section, 00, missing_section,
		substr (std_section (current.title (i)), 3), 0, 0);
	  end;
         end;
         return (P_seq_no + 1);	/* MATCH EOF- keep moving down the   */
				/* ..list and eventually exit it. It */
				/* ..is done this way to make sure   */
				/* ..that current gets all filled in */
      end;
      if (P_title = section_id)
      then do;
         if (P_seq_no < last_seq)
         then call ERR_MSG3 (local.out_of_sequence, 0, out_of_sequence);
         last_seq = P_seq_no;
         current.used (last_seq) = current.used (last_seq) + 1;
         if (current.used (last_seq) > current.maxuse (last_seq))
         then call ERR_MSG (local.too_many, 0, too_many, "", current.maxuse (last_seq), 0);
         if ^end_info_sw
         then call GET_SECTION;
         else section_id = EOF;
         current.pass = 1;
         return (P_group_no);		/* MATCH- continue in same group     */
      end;
/**** no match						       */
      if extra_sw
      then if (section_id = LIST_OF) | (section_id = NOTES) | (section_id = NOTES_ON)
	 then do;
	    if tr_sw then call ioa_ ("  SEC ^4(^3x^) ^i::^a", section_id,
		    std_section (P_title));
next:
	    if ^end_info_sw
	    then call GET_SECTION;
	    else section_id = EOF;
	    current.pass = 1;
	    return (last_seq);	/* MATCH extra- continue in the list */
				/*  where the last match was	       */
	 end;
/**** when we hit the end of the first pass, try again from the top	       */
      if (P_seq_no = current.count)
      then do;
         if (current.pass = 1)
         then do;
	  current.pass = 2;
	  return (1);		/* FAIL- go back to the top	       */
         end;
         if ^non_standard
         then call ERR_MSG3 (local.not_belong, 00, not_belong);
         goto next;
      end;
      return (P_seq_no + 1);		/* FAIL- go on to next test	       */

/* ------------------------------------------------------------------------- */

SEC$init: entry (ct);

dcl ct		fixed bin parameter;

      unspec (current) = ""b;
      current.count = ct;
      current.pass = 1;
      last_seq = 0;
      begin_info_sw = T;
      call GET_SECTION;		/* get first section	       */
      return;

   end SEC; %page;
/* ------------------------------------------------------------------------- */
/*	Validate and save the info segment header. Its syntax is:	       */
/*	  {divider} date <SP><SP> long_name{, short_name}...	       */
/* ------------------------------------------------------------------------- */

GET_HEADER: proc;

      if tr_sw then call PUSH ("GET_HEADER");
      call GET_PARAGRAPH (1301,(F));	/* up to first paragraph break (blank line) */

      header_shown_sw, end_info_sw, end_info_sw, internal_sw = F;
      if ^colon_info_seen_sw
      then do;
/**** This is a single-info segment, check its names		       */
         if (index (string (current_names), "changes.info") ^= 0)
	    | (index (string (current_names), ".error.info") ^= 0)
	    | (index (string (current_names), ".gi.info") ^= 0)
	    | (index (string (current_names), "diffs.info") ^= 0)
	    | (index (string (current_names), "differences.info") ^= 0)
	    | (index (string (current_names), "new_features.info") ^= 0)
         then general_info = T;
         call SHOW_HEADER;
      end;
      else do;
/****    This is a multi-info segment. Check out the divider.	       */
         if substr (par, 1, 6) = ":Info:"
         then do;			/* this info seg has entry points    */
	  internal_sw, entry_info = F;
	  call PROCESS_DIVIDER (6);
         end;
         else if substr (par, 1, 10) = ":Internal:"
         then do;			/* this info seg has entry points    */
	  entry_info = F;
	  internal_sw = T;
	  call PROCESS_DIVIDER (10);
         end;
      end;
      if substr (par, 1, 7) = ":Entry:"
      then do;			/* this info seg has entry points    */
         internal_sw, entry_info = T;
         call PROCESS_DIVIDER (7);
      end;
      long_lines.count, backspaces.count,
	 endblanks.count, badchars.count, nonblanks.count = 0;
      last_section_head, section_head = "";
      begin_info_sw = T;
      first_section_head = "<empty info>";
      i = verify (par, WHITE_SPACE);
      j = search (substr (par, i), WHITE_SPACE);
      if j = 0
      then j = par_len - i + 1;
      if entry_info
      then entry_date = substr (par, i, j - 1);
      else header_date = substr (par, i, j - 1);
      i = i + j - 1;
      if substr (par, i, 1) = NL
      then header = "";
      else do;
         i = i + verify (substr (par, i), WHITE_SPACE) - 1;
         j = index (substr (par, i), NL) - 1;
         header = substr (par, i, j);
         i = i + j;
         i = search (header, " ,");
         if i = 0
         then header_short_name = header;
         else do;
	  j = verify (substr (header, i), HDR_NAME_BREAK);
	  header_short_name = substr (header, i + j - 1);
	  header = substr (header, 1, i - 1);
         end;
         if ^scanning & ^internal_sw & ^colon_info_seen_sw & ^general_info
         then do;
	  div_names_ct = div_names_ct + 1;
	  temp.list_ct = temp.list_ct + 1;
	  div_names_ptr = addr (temp.list (temp.list_ct));
	  temp.sort.n = temp.sort.n + 1;
	  temp.sort.vector (temp.sort.n) = div_names_ptr;
	  temp.list.name (temp.list_ct) = header || ".info";
	  temp.list.flag (temp.list_ct) = 1;
	  if ep_sw then call ioa_ ("^3i HDR: <^a> **", temp.list_ct, header);

/* In most cases there will only be one header name and one header short name.
   In the case of some subsystem requests, though, there will be multiple
   short names.  The first of these will be kept in header_short_name and
   considered to be *the* short name for the purpose of checking the Syntax
   line.  The rest will just be additional names. */
	  if (header_short_name ^= header)
	  then do;
	     header_short_name_temp = header_short_name;

	     i = search (header_short_name, " ,");
	     if i ^= 0 then do;
		j = verify (substr (header_short_name, i), HDR_NAME_BREAK);
		header_short_name = substr (header_short_name, 1, i - 1);
	     end;

	     names_left_to_add = T;
	     do while (names_left_to_add);
		i = search (header_short_name_temp, " ,");
		if i ^= 0 then j = verify (substr (header_short_name_temp, i), HDR_NAME_BREAK);
		else names_left_to_add = F;
		div_names_ct = div_names_ct + 1;
		temp.list_ct = temp.list_ct + 1;
		if names_left_to_add then temp.list.name (temp.list_ct) = substr (header_short_name_temp, 1, i - 1) || ".info";
		else temp.list.name (temp.list_ct) = header_short_name_temp || ".info";
		temp.list.flag (temp.list_ct) = 1;
		if ep_sw then call ioa_ ("^3i HDR: <^a>", temp.list_ct, temp.list.name (temp.list_ct));
		header_short_name_temp = substr (header_short_name_temp, i + j - 1);
	     end;
	  end;
	  temp.list.flag (temp.list_ct) = 0;
         end;
      end;
      par_line_count = par_line_count - 1;
      par_unit_line_count = par_unit_line_count - 1;
      if (par_line_count < 1)
      then got_par_sw = F;
      else do;
         got_par_sw = T;
         par_line_number = par_line_number + 1;
         par_ptr = addcharno (par_ptr, i);
         par_len = par_len - i;
      end;

/**** test syntax and semantics of header/entry date fields.	       */
/**** 1) all must be valid					       */
/**** 2) all entry<=header					       */
      if entry_info
      then do;
         call convert_date_to_binary_$relative (entry_date, entry_clock, 0, code);
         if db_sw & (code = 0)
         then call ioa_ ("-Entry: ^a", date_time_$format ("date_time", entry_clock, "", ""));
         if code ^= 0
         then call ERR_MSG (local.bad_date, 0, bad_date, entry_date, 0, 0);
         else if header_date_sw
         then if (header_clock < entry_clock)
	    then call ERR_MSG3 (local.entry_too_late, 0, entry_too_late);
      end;
      else do;
         header_date_sw = "1"b;
         call convert_date_to_binary_$relative (header_date, header_clock, 0, code);
         if db_sw & (code = 0)
         then call ioa_ ("-Header: ^a", date_time_$format ("date_time", header_clock, "", ""));
         if code ^= 0
         then do;
	  call ERR_MSG (local.bad_date, 0, bad_date, header_date, 0, 0);
	  header_date_sw = ""b;	/* don't compare against bad date    */
         end;
      end;
      if header = ""
      then call ERR_MSG3 (local.no_hdr_name, 0, no_hdr_name);

      if entry_info			/* turn "foo" or "bar$foo" into      */
      then do;			/* .."$foo"		       */
         info_name = "$" || substr (info_name, index (info_name, "$") + 1);
      end;
      if tr_sw then call POP ("GET_HEADER");

dcl header_date_sw	bit (1);		/* 1-header_date is valid	       */

   end GET_HEADER; %page;
/* ------------------------------------------------------------------------- */
/* Check out a divider. It's format is:				       */
/*  | :Info:     |						       */
/*  | :Internal: |   name: {name:} ... {NL}			       */
/*  | :Entry:    |						       */
/* ------------------------------------------------------------------------- */

PROCESS_DIVIDER: proc (P_id_len);

dcl P_id_len	fixed bin parm;

dcl id_len	fixed bin;
dcl t_ptr		ptr;
dcl do_names	bit (1);
dcl ch1		char (1);

      do_names = ^scanning & ^internal_sw;
      call SHOW_HEADER;
      if ^scanning then info_count = info_count + 1;
      if (charno (par_ptr) > 2)
      then do;
         t_ptr = addcharno (par_ptr, -3);
         if (substr (t_ptr -> par, 1, 3) ^= "


") | blank_line_count > 2
         then call ERR_MSG (local.need_2_blank_lines, 0, need_2_blank_lines,
	         substr (par, 1, P_id_len), 0, 0);
      end;
      info_name = "";
      general_info = F;
      par_ptr = addcharno (par_ptr, P_id_len);
      par_len = par_len - P_id_len;
      if do_names
      then do;
      end;
NEXT_COLON:
      id_len = index (par, ":");
      if id_len ^= 0
      then do;
         header = ltrim (substr (par, 1, id_len - 1));
         header = rtrim (header);
         if do_names
         then do;
	  div_names_ct = div_names_ct + 1;
	  temp.list_ct = temp.list_ct + 1;
	  if (div_names_ct = 1)
	  then do;
	     div_names_ptr = addr (temp.list (temp.list_ct));
	     temp.sort.n = temp.sort.n + 1;
	     temp.sort.vector (temp.sort.n) = div_names_ptr;
	  end;
	  temp.list.name (temp.list_ct) = header || ".info";
	  temp.list.flag (temp.list_ct) = 1;
	  if ep_sw then call ioa_ ("^3i DIV: <^a>^[ **^]", temp.list_ct, header, (div_names_ct = 1));
         end;
         if (info_name = "")
         then info_name = header;
         header = header || "#";
         if (index (header, ".gi#") ^= 0)
	    | (index (header, ".error#") ^= 0)
	    | (index (header, "status#") ^= 0)
	    | (index (header, "changes#") ^= 0)
	    | (index (header, "diffs#") ^= 0)
	    | (index (header, "differences#") ^= 0)
	    | (index (header, "new_features#") ^= 0)
         then general_info = T;
         ch1 = substr (par, id_len + 1, 1);
         if (ch1 = NL)
         then do;
	  id_len = id_len + 1;
	  par_line_count = par_line_count - 1;
            par_unit_line_count = par_unit_line_count - 1;
	  par_line_number = par_line_number + 1;
            par_unit_line_number = par_unit_line_number + 1;
         end;
         par_ptr = addcharno (par_ptr, id_len);
         par_len = par_len - id_len;
         if (ch1 ^= NL)
         then goto NEXT_COLON;
      end;
      if do_names
      then temp.list.flag (temp.list_ct) = 0;
   end PROCESS_DIVIDER; %skip (3);
SHOW_HEADER: proc;

      if ^total_sw & ^header_shown_sw & ^scanning
      then do;
         header_shown_sw = T;
         call ioa_ ("^/-----------^a info^/LINE: ^i^13t^a", format,
	    par_line_number, substr (par, 1, par_1st_line_len - 1));
         if par_line_count > 1
         then call ioa_ ("^13t^a", before (substr (par, par_1st_line_len + 1), NL));
      end;
   end SHOW_HEADER; %page;
/* ------------------------------------------------------------------------- */
/* Validate the next section, up to a double blank line or section heading.  */
/* ------------------------------------------------------------------------- */

GET_SECTION: proc;

dcl t_ptr		ptr;
dcl done		bit (1);

      if tr_sw then call PUSH ("GET_SECTION");

      call GET_PARAGRAPH (1584,(T));

      section_id = EOF;		/* setup in case nothing else here   */
      if end_info_sw
      then do;
         got_par_sw = T;
         goto exit;			/* do this one first */
      end;

      end_info_sw = F;

      if section_head ^= ""
      then last_section_head = section_head;
      section_head = HEAD (par);
      section_skip = section_head_len;
      section_line_number = par_line_number;
      section_ptr_len = par_ptr_len;
      section_line_count = par_line_count;

      par_unit_line_count = par_line_count;
      par_unit_line_number = par_line_number;

      if (section_head ^= "")
      then do;
         if ^total_sw & (^scanning | db_sw)
         then call ioa_ ("LINE: ^i^13t^a", section_line_number, section_head);

         if (charno (par_ptr) > 2) & ^begin_info_sw
         then do;
	  t_ptr = addcharno (par_ptr, -3);
	  if (substr (t_ptr -> par, 1, 3) ^= "


") | blank_line_count > 2
	  then call ERR_MSG (local.need_2_blank_lines, 0, need_2_blank_lines, "Section", 0, 0);
         end;
      end;
      begin_info_sw = F;

      call NORMALIZE_SECTION_HEAD;

      if (SYNTAX <= section_id) & (section_id <= USAGE)
      then do;
         two_paragraph_syntax_sw = F;
         if ^scanning & ^general_info
         then call PARSE_SYNTAX_SECTION;
         if ^two_paragraph_syntax_sw
         then goto exit;		/* just get 1 paragraph for Syntax:  */
      end;

      done = F;
      do while ((src_index < src_len) & ^done);
         call GET_PARAGRAPH (1635,(T));
         if ((search (par, WHITE_SPACE) = 1)
	    | (index (substr (par, 1, par_1st_line_len), ":") = 0)
	    ) & ^end_info_sw
         then do;
	  section_len = section_len + par_len + blank_char_count;
	  section_line_count = section_line_count + par_line_count + blank_line_count;
         end;
         else done, got_par_sw = T;
      end;

      if general_info
      then goto exit;
      goto rtn (section_id);

rtn (2) /* ARGUMENTS			 */ :

      call CHECK_ARGS_FORMAT;
      goto exit;
rtn (3) /* CONTROL_ARGUMENTS			 */ :
rtn (4) /* CONTROL_ARGUMENTS_AS_A_COMMAND	 */ :
rtn (5) /* CONTROL_ARGUMENTS_AS_A_REQUEST	 */ :
rtn (6) /* CONTROL_ARGUMENTS_AS_AN_ACTIVE_FUNCTION */ :
rtn (7) /* CONTROL_ARGUMENTS_AS_AN_ACTIVE_REQUEST  */ :
rtn (8) /* CONTROL_ARGUMENTS_FOR		 */ :
      call CHECK_CTL_ARGS_FORMAT;
      goto exit;
rtn (9) /* ENTRY_POINTS_IN			 */ :
      goto exit;
rtn (12) /* LIST_OF				 */ :
      call CHECK_LIST_OF;
      goto exit;
rtn (19) /* USAGE				 */ :
      call CHECK_USAGE;
      goto exit;

rtn (0) /* UNKNOWN_TITLE			 */ :
      call ERR_MSG (local.non_std_title, 0, non_std_title, (section_head), 0, 0);
      non_standard = T;

rtn (1) /* ACCESS_REQUIRED			 */ :
rtn (10) /* EXAMPLES			 */ :
rtn (11) /* FUNCTION			 */ :
rtn (13) /* NOTES				 */ :
rtn (14) /* NOTES_ON			 */ :
rtn (15) /* SYNTAX				 */ :
rtn (16) /* SYNTAX_AS_A_COMMAND		 */ :
rtn (17) /* SYNTAX_AS_AN_ACTIVE_FUNCTION	 */ :
rtn (18) /* SYNTAX_AS_AN_ACTIVE_REQUEST		 */ :
rtn (20) /* UNTITLED			 */ :
exit:
      if (first_section_head = "<empty info>")
      then first_section_head = section_head;
      if tr_sw then call POP ("GET_SECTION");


CHECK_CTL_ARGS_FORMAT: CHECK_LIST_OF: CHECK_USAGE:
CHECK_ARGS_FORMAT: proc;

/* For Arguments:, Control arguments:, and List of...: sections, checks format of list:
	name1, name2,
	name3, etc.
	<SP><SP><SP>description
*/

   end CHECK_ARGS_FORMAT;


   end GET_SECTION; %page;
/* ------------------------------------------------------------------------- */
/* Verify the syntax of the Syntax: paragraph, including whether	       */
/* the short name is used in the syntax line.			       */
/* ------------------------------------------------------------------------- */

PARSE_SYNTAX_SECTION: proc;

dcl i		fixed bin;


      if tr_sw then call PUSH ("PARSE_SYNTAX_SECTION");
      i = index (par, header_short_name);
      if (i = 0)
      then if subroutine_info
	 then call ERR_MSG (local.no_usage_name, 0, no_usage_name, (header_short_name), 0, 0);
	 else call ERR_MSG (local.no_syntax_name, 0, no_syntax_name, (header_short_name), 0, 0);

/* Since it is highly likely that a subroutine info will have a blank line
   between the declaration and call descriptions of its syntax section, we
   want to allow a second paragraph if "call" does not appear in the first. */
      if subroutine_info
      then if index (par, "call") = 0
           then two_paragraph_syntax_sw = T;
      if tr_sw then call POP ("PARSE_SYNTAX_SECTION");
   end PARSE_SYNTAX_SECTION; %page;
/* ------------------------------------------------------------------------- */
/* Validate the next paragraph, up to a blank line.		       */
/* (There may already be an unused paragraph waiting.)		       */
/* ------------------------------------------------------------------------- */

GET_PARAGRAPH: proc (ln,par_unit_sw);
dcl ln		fixed bin;	/* this parameter is for debugging   */
				/* only, to indicate which call is   */
				/* being executed		       */
dcl par_unit_sw     bit(1) aligned;     /* handle multiple paragraphs        */
                                        /* delimited by single blank as unit */
      if tr_sw & ^scanning
      then call PUSH ("GET_PARAGRAPH");
      if ^got_par_sw		/* already read-ahead?	       */
      then do;			/* ..No			       */
         if (^par_unit_sw & par_unit_line_count > par_line_limit)
         then do;
	  call ERR_MSG (local.paragraph_size, par_unit_line_number, paragraph_size, "", par_unit_line_count, (par_line_limit));
         end;
         if (src_index >= src_len)
         then do;

            if par_unit_sw & par_unit_line_count > par_line_limit
            then do;
               call ERR_MSG (local.paragraph_size, par_unit_line_number, paragraph_size, "", par_unit_line_count, (par_line_limit));
            end;

	  end_info_sw = T;
	  goto exit;
         end;
         par_1st_line_len = 0;
         blank_line_count, blank_char_count = 0;
         blank_line_sw = (src_index < src_len);
         do while (src_index < src_len & blank_line_sw); /* skip leading blank lines */
	  par_offset = src_index;
	  call GET_LINE;
         end;

         if src_index >= src_len & blank_line_sw
         then do;
				/*	  errors.trailing_blank_lines = ^scanning;*/
	  goto exit;
         end;

         if par_unit_sw then do;
            if blank_line_count > 0
            then do;

               if (par_unit_line_count > par_line_limit)
               then do;
	        call ERR_MSG (local.paragraph_size, par_unit_line_number, paragraph_size, "", par_unit_line_count, (par_line_limit));
               end;

               par_unit_line_count = 1;
               par_unit_line_number = line_number;

            end;

            else
                par_unit_line_count = par_unit_line_count + 2;
         end;

         par_1st_line_len = line_len;
         par_line_number = line_number;
         par_ptr_len = line_ptr_len;
         par_line_count = 1;
         do while (src_index < src_len & ^blank_line_sw);
	  call GET_LINE;
	  if ^blank_line_sw
	  then do;
	     par_len = par_len + line_len;
	     par_line_count = par_line_count + 1;
               par_unit_line_count = par_unit_line_count + 1;
	  end;
         end;
      end;

      if substr (par, 1, 6) = ":Info:"	/* beginning of next :Info: block    */
	 | substr (par, 1, 7) = ":Entry:"
	 | substr (par, 1, 10) = ":Internal:"
      then end_info_sw = T;
      else end_info_sw = F;
exit:
      if db_sw & ^scanning
      then call ioa_ ("^4i)^4i ""^a""(^i)^[ got^]^[ EOF^]", ln, par_line_number,
	      before (substr (par, 1, 15), NL), par_line_count, got_par_sw, end_info_sw);
      got_par_sw = F;

      if tr_sw & ^scanning
      then call POP ("GET_PARAGRAPH");
   end GET_PARAGRAPH; %page;
/* ------------------------------------------------------------------------- */
/* Validate next line, advancing src_index and checking various attributes.  */
/* ------------------------------------------------------------------------- */

GET_LINE: proc;

/**** Set pointer/length of next line.				       */
      line_number = line_number + 1;
      line_ptr = setcharno (src_ptr, src_index - 1);
      line_len = src_len - src_index + 1;
      i = index (line, NL);		/* remove trailing newline */
      if i ^= 0
      then line_len = i;
      src_index = src_index + line_len; /* advance offset into string */
      n_cols = 0;
      if line = NL
      then goto BLANK;
/**** Count character positions in printed line			       */
      line_index, special_index = 1;
      do while (special_index ^= 0);
         special_index = index (substr (line, line_index), HT) - 1;
         if special_index = -1
         then special_index = length (line) - line_index + 1;
         line_index = line_index + special_index;
         n_cols = n_cols + special_index;
         if line_index <= length (line)
         then do;
	  n_cols = n_cols + 10 - mod (n_cols, 10);
	  line_index = line_index + 1;
         end;
      end;
      if (n_cols > line_char_limit)
      then do;
         if (par_line_count > 1) & (substr (line, 1, 6) ^= ":Info:") & (substr (line, 1, 7) ^= ":Entry:")
         then call ERR_LOG (errors.long_lines, line_number);
      end;
      if verify (substr (line, 1, line_len - 1), WHITE_SPACE) = 0
      then do;			/* all blanks? */
         call ERR_LOG (errors.nonblanks, line_number);
BLANK:
         blank_line_sw = T;
         blank_line_count = blank_line_count + 1;
         blank_char_count = blank_char_count + length (line);
         line_ptr = setcharno (src_ptr, src_index - 2);
         line_len = 1;
      end;
      else do;
         if (substr (line, line_len - 1, 1) = HT) | (substr (line, line_len - 1, 1) = SP)
         then call ERR_LOG (errors.endblanks, line_number);
         blank_line_sw = F;
         if index (line, BS) ^= 0
         then call ERR_LOG (errors.backspaces, line_number);
         if verify (line, PRINTABLE) ^= 0
         then call ERR_LOG (errors.badchars, line_number);
      end;
      if db_sw & ^scanning
      then call ioa_ ("^2-**^i-^i^[BL^;^-^a^]", line_number, n_cols,
	      (line_len = 1), substr (line, 1, min (40, max (1, line_len - 1))));

   end GET_LINE; %page;
/* ------------------------------------------------------------------------- */
/* Return the section heading of P_string. This is any string	       */
/*  (<= heading_char_limit chars long) before a colon. Set section_head_len  */
/*  to be the number of chars occupied by heading and colon.	       */
/* ------------------------------------------------------------------------- */

HEAD: proc (P_string) returns (char (40));

dcl P_string	char (*);
dcl i		fixed bin;
dcl j		fixed bin;

      if substr (P_string, 1, 1) = NL | search (P_string, WHITE_SPACE) = 1
      then goto NULL;
      if substr (P_string, 1, 1) = ":"
      then i = 2;			/* to allow for ":Info:" as the heading */
      else i = 1;
      j = search (substr (P_string, i), ":
");
      if j = 0 | j > heading_char_limit + 1 | substr (P_string, i + j - 1, 1) = NL
      then do;
NULL:    section_head_len = 0;
         return ("<untitled>");
      end;
      else do;
         section_head_len = j + i - 1;
         return (ltrim (substr (P_string, i, j - 1)));
      end;

   end HEAD; %page;
/* ------------------------------------------------------------------------- */
/* Reduce a section heading to a standard form, if possible.	       */
/* ------------------------------------------------------------------------- */

NORMALIZE_SECTION_HEAD: proc;

dcl old_len	fixed bin;
dcl section_temp	char (40) var;

      normal_head = section_head;
      section_id = UNKNOWN_TITLE;
      non_standard = F;

      if index (normal_head, BS) ^= 0
      then do;			/* remove underlining */
         do i = 1 to length (normal_head) - 1 while (substr (normal_head, i, 1) ^= " ");
	  if substr (normal_head, i, 2) = BS || "_"
	  then do;
	     normal_head = substr (normal_head, 1, i - 1) || substr (normal_head, i + 1);
	     i = i - 1;
	  end;
         end;
         bsp_sw = T;
      end;
      else bsp_sw = F;

      normal_head = translate (substr (normal_head, 1, 1), UPPER_CASE, LOWER_CASE)
	 || translate (substr (normal_head, 2), LOWER_CASE, UPPER_CASE);
      do section_index = hbound (std_section, 1) by -1 to 1 while
	 (substr (std_section (section_index), 3) ^= substr (normal_head, 1, length (std_section (section_index)) - 2));
      end;
      if (section_index > 0)
      then do;
         section_id = fixed (substr (std_section (section_index), 1, 2));
         old_len = length (std_section (section_index)) - 2;
         section_temp = substr (std_section (section_id), 3);
         if (length (section_temp) < 40)
         then section_temp = section_temp || substr (normal_head, old_len + 1);
         normal_head = section_temp;
         if section_head ^= normal_head
         then do;
	  call ERR_MSG (local.this_form_preferred, 0, this_form_preferred, (normal_head), 0, 0);
	  section_head = normal_head;
         end;
         if (bf_format = "C/AF") & (section_id = SYNTAX)
         then do;
	  call ERR_MSG3 (local.need_command, 0, need_command);
	  section_id = SYNTAX_AS_A_COMMAND;
         end;
         if subroutine_info
         then do;
	  if (SYNTAX <= section_id) & (section_id <= SYNTAX_AS_AN_ACTIVE_REQUEST)
	  then do;
	     call ERR_MSG3 (local.need_usage, 0, need_usage);
	     section_id = USAGE;
	  end;
	  if (section_id = UNTITLED)
	  then do;
	     call ERR_MSG3 (local.need_function, 0, need_function);
	     section_id = FUNCTION;
	  end;
         end;
      end;

dcl bsp_sw	bit (1);

   end NORMALIZE_SECTION_HEAD; %page;
/* ------------------------------------------------------------------------- */
/* ------------------------------------------------------------------------- */

PRINT_ERR_SUMMARY: proc;

      call ERR_PRINT (long_lines, local.lines_too_long, lines_too_long);
      call ERR_PRINT (badchars, local.non_printable, non_printable);
      call ERR_PRINT (nonblanks, local.blank_white_space, blank_white_space);
      call ERR_PRINT (endblanks, local.end_white_space, end_white_space);
      call ERR_PRINT (backspaces, local.backspace, backspace);

      if af_sw then return;

      if total_sw & (highest_severity >= severity_limit)
      then do;
         if (info_name ^= "") & new_segment_sw
         then do;
	  call ioa_ ("^19x:Info: ^a^[ (LINK)^]", src_path, link_sw);
	  new_segment_sw = F;
         end;
         call ioa_ ("^3(^5d ^)  ^4a  ^[^a^[ (LINK)^]^;^2s  ^a^]",
	    highest_severity, local.paragraph_size, local.lines_too_long,
	    bf_format,
	    new_segment_sw, src_path, link_sw, info_name);
         new_segment_sw = F;
      end;
      global = global + local;
      highest_severity = 0;

   end PRINT_ERR_SUMMARY; %page;
/* ------------------------------------------------------------------------- */
/* ------------------------------------------------------------------------- */

ERR_MSG: proc (err_ct, lino, msg, ch_arg, fb_arg1, fb_arg2);
      argct = 6;
      goto common;
ERR_MSG3: entry (err_ct, lino, msg);
      argct = 3;

dcl (err_ct	fixed bin (18),	/* error accumulator	       */
    lino		fixed bin,	/* where it occurred	       */
    msg		char (80) var,	/* text of message		       */
    ch_arg	char (*),		/* character value		       */
    fb_arg1	fixed bin (24),	/* binary value		       */
    fb_arg2	fixed bin (24)	/* another binary value	       */
    )		parm;

dcl argct		fixed bin;
dcl sev		fixed bin;
dcl ch1		char (1);

common:
      if scanning then return;
      err_ct = err_ct + 1;
      ch1 = substr (msg, 1, 1);
      sev = index ("012345", ch1) - 1;
      highest_severity = max (highest_severity, sev);
      error_count.total (sev) = error_count.total (sev) + 1;
      error_count.seg (sev) = 1;
      error_count.info (sev) = 1;
      if total_sw | (sev < severity_limit)
      then return;

      call ioa_$nnl ("Severity ^a", ch1);
      if (lino ^= 0)
      then call ioa_$nnl (", line ^i", lino);
      call ioa_$nnl (". ");
      if (argct = 3)
      then call ioa_ (substr (msg, 2), T);
      else call ioa_ (substr (msg, 2), T, ch_arg, fb_arg1, fb_arg2);

   end ERR_MSG; %page;
/* ------------------------------------------------------------------------- */
/* ------------------------------------------------------------------------- */

ERR_LOG: proc (P_map, P_line_number);

/* This internal procedure adds a line number to the appropriate error array. */

dcl 1 P_map	aligned like map;
dcl P_line_number	fixed bin;

      if (P_map.count = 0)
      then P_map.actual_count = 0;
      P_map.actual_count = P_map.actual_count + 1;
      if P_map.actual_count > hbound (P_map.number, 1)
      then return;
      P_map.count = P_map.count + 1;
      P_map.number (P_map.count) = P_line_number;

   end ERR_LOG; %page;
/* ------------------------------------------------------------------------- */
/* ------------------------------------------------------------------------- */

ERR_PRINT: proc (P_map, P_accum, P_msg);

/* This internal procedure lists the line numbers for a particular error. */

dcl 1 P_map	aligned like map,
    P_accum	fixed bin (18),
    P_msg		char (80) var;

dcl i		fixed bin;
dcl sev		fixed bin;
dcl ch1		char (1);

      if P_map.count = 0
      then return;
      ch1 = substr (P_msg, 1, 1);
      sev = index ("012345", ch1) - 1;
      highest_severity = max (highest_severity, sev);
      error_count.total (sev) = error_count.total (sev) + P_map.actual_count;
      error_count.seg (sev) = 1;
      error_count.info (sev) = 1;
      P_accum = P_accum + P_map.actual_count;

      if total_sw | (sev < severity_limit)
      then return;

      call ioa_$nnl ("Severity ^a. ", ch1);
      severity_count = sev;

      call ioa_$nnl (substr (P_msg, 2), (P_map.count ^= 1));
      call ioa_$nnl (":  ");

      err_count = 2;
      do i = 1 to P_map.count;
         if err_count = 10
         then do;
	  call ioa_$nnl (",^/^10x");
	  err_count = 1;
         end;
         else err_count = err_count + 1;
         if i = 1 | err_count = 1
         then call ioa_$nnl ("^d", P_map.number (i));
         else call ioa_$nnl (",  ^d", P_map.number (i));
      end;
      if P_map.actual_count > P_map.count
      then call ioa_ (",  etc.  (^d in all)", P_map.actual_count);
      else call ioa_ ("");

   end ERR_PRINT;

   end VALIDATE; %page;
CLEAN_UP: proc;

/* ------------------------------------------------------------------------- */
/*		     This is the cleanup handler.		       */
/* ------------------------------------------------------------------------- */

      if src_ptr ^= null ()
      then call terminate_file_ (src_ptr, (0), TERM_FILE_TERM, (0));
      if temp_ptr ^= null ()
      then call release_temp_segment_ (ME, temp_ptr, (0));

CLEAN_UP$some: entry;

/**** allocations from hcs_$status_				       */
      if (status_ptr ^= null ())
      then do;
         if (status_link.type = Link)
         then if (status_link.pathname_relp ^= ""b)
	    then do;
	       free status_pathname in (area);
	       status_link.pathname_relp = ""b;
	    end;
         if (status_branch.names_relp ^= ""b)
         then do;
	  free status_entry_names in (area);
	  status_branch.names_relp = ""b;
         end;
         status_ptr = null ();
      end;
/**** allocations from hcs_$star_dir_list_			       */
      if star_list_names_ptr ^= null	/* this is done first because it     */
      then free star_list_names in (area); /* ...uses the next one.	       */
      if star_list_branch_ptr ^= null
      then free star_dir_list_branch in (area);

   end CLEAN_UP;

dcl db_sw		bit (1) int static init (""b);
dbn: entry; db_sw = "1"b; return;
dbf: entry; db_sw = "0"b; return;

dcl tr_sw		bit (1) int static init (""b);
trn: entry; tr_sw = "1"b; return;
trf: entry; tr_sw = "0"b; return;

dcl ep_sw		bit (1) int static init (""b);
epn: entry; ep_sw = "1"b; return;
epf: entry; ep_sw = "0"b; return;

%page;
%include star_structures;
%page;
%include status_structures;
%page;
%include terminate_file;

   end validate_info_seg;
