* ***********************************************************
* *                                                         *
* * Copyright, (C) Honeywell Information Systems Inc., 1982 *
* *                                                         *
* * Copyright (c) 1972 by Massachusetts Institute of        *
* * Technology and Honeywell Information Systems, Inc.      *
* *                                                         *
* ***********************************************************

	lbl	,bsc_tables
	ttl	bsc_tables -- tables for bisync line type
	editp	on
	pcc	off
	pmc	off
	detail	off
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	bsc_tables
*
*	these tables are designed to run all types of bisync line
*	discipline - ascii and ebcdic, transparent and non-
*	transparent.
*
*	coded by bob adsit may 1976
*	completed and debugged by Larry Johnson, November 1976
*	modified: 23 November 1980 by G. Palter to fix a bug
*	   which caused FNP crashes with a store fault
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
bsc	null
	rem
	symdef	bsc
	symdef	bscstr
	symdef	bscacu	return from autocall
	symdef	bsctst	bisync test state handler
	symdef	bscwt	write w/o recieve mode
	symdef	bscwtr	write with recieve mocd
	symdef	bscrd	read routine
	symdef	bsccki	check input routine
	symdef	bsccko	check output routine
	symdef	bscswa	switch acks routine
	symdef	bscbad	report bad block subroutine
	symdef	bshang	when line hangs up
	rem
	symref	begin
	symref	hungup
	symref	frebfh	subroutine to free a buffer
	symref	setbpt	subroutine to set buffer pte
	symref	cvabs	subroutine to 'absolutize' an address
	symref	cvaddr	subroutine to convert a tib extension address
	symref	st3270	start of 3270 control tables
	symref	sthasp	start of hasp control tables
	symref	acutst	make autocall
	rem
	pmc	save,on
	cctdef
	rem
ct.bcc	equ	ct.t2s+ct.sw+ct.tb4
	rem
	base	64
	rem
cct.ab	null	* cct for ascii binary synchronous devices
	rem	* table 0 - non transparent text and control sequences
	rem
	vfd	9/ct.ncs,9/ct.ncs * 000   001
	vfd	9/ct.ncs,9/ct.etx * 002   etx
	vfd	9/ct.nak,9/ct.nak * eot   enq
	vfd	9/ct.ncs,9/ct.ncs * 006   007
	vfd	9/ct.ncs,9/ct.ncs * 010   011
	vfd	9/ct.ncs,9/ct.ncs * 012   013
	vfd	9/ct.ncs,9/ct.ncs * 014   015
	vfd	9/ct.ncs,9/ct.ncs * 016   017
	vfd	9/ct.tb1,9/ct.ncs * dle   021
	vfd	9/ct.ncs,9/ct.ncs * 022   023
	vfd	9/ct.ncs,9/ct.nak * 024   nak
	vfd	9/ct.ign,9/ct.etx * 026   etb
	vfd	9/ct.ncs,9/ct.ncs * 030   031
	vfd	9/ct.ncs,9/ct.ncs * 032   033
	vfd	9/ct.ncs,9/ct.ncs * 034   035
	vfd	9/ct.ncs,9/ct.itb * 036   itb
	rem
	rem
	dup	1,48
	vfd	9/ct.ncs,9/ct.ncs
	rem
	rem	* table 1 - looking at character following dle
	rem
	vfd	9/ct.ncs,9/ct.ncs * 000   001
	vfd	9/ct.stx,9/ct.nak * stx   etx
	vfd	9/ct.nak,9/ct.nak * eot   enq
	vfd	9/ct.ncs,9/ct.ncs * 006   007
	vfd	9/ct.ncs,9/ct.ncs * 010   011
	vfd	9/ct.ncs,9/ct.ncs * 012   013
	vfd	9/ct.ncs,9/ct.ncs * 014   015
	vfd	9/ct.ncs,9/ct.ncs * 016   017
	vfd	9/ct.ncs,9/ct.ncs * 020   021
	vfd	9/ct.ncs,9/ct.ncs * 022   023
	vfd	9/ct.ncs,9/ct.ncs * 024   025
	vfd	9/ct.ncs,9/ct.nak * 026   etb
	vfd	9/ct.ncs,9/ct.ncs * 030   031
	vfd	9/ct.ncs,9/ct.ncs * 032   033
	vfd	9/ct.ncs,9/ct.ncs * 034   035
	vfd	9/ct.ncs,9/ct.mtb * 036   itb
	vfd	9/ct.ncs,9/ct.ncs * 040   041
	vfd	9/ct.ncs,9/ct.ncs * 042   043
	vfd	9/ct.ncs,9/ct.ncs * 044   045
	vfd	9/ct.ncs,9/ct.ncs * 046   047
	vfd	9/ct.ncs,9/ct.ncs * 050   051
	vfd	9/ct.ncs,9/ct.ncs * 052   053
	vfd	9/ct.ncs,9/ct.ncs * 054   055
	vfd	9/ct.ncs,9/ct.ncs * 056   057
	vfd	9/ct.nak,9/ct.nak * ak0   ak1
	vfd	9/ct.ncs,9/ct.ncs * 062   063
	vfd	9/ct.ncs,9/ct.ncs * 064   065
	vfd	9/ct.ncs,9/ct.ncs * 066   067
	vfd	9/ct.ncs,9/ct.ncs * 070   071
	vfd	9/ct.ncs,9/ct.nak * 072   wak
	vfd	9/ct.nak,9/ct.ncs * rvi   075
	vfd	9/ct.ncs,9/ct.ncs * 076   077
	rem
	rem
	dup	1,32
	vfd	9/ct.ncs,9/ct.ncs
	rem
	rem	* table 2 - transparent text
	rem
	vfd	9/ct.tb2,9/ct.tb2 * 000   001
	vfd	9/ct.tb2,9/ct.tb2 * 002   003
	vfd	9/ct.tb2,9/ct.tb2 * 004   005
	vfd	9/ct.tb2,9/ct.tb2 * 006   007
	vfd	9/ct.tb2,9/ct.tb2 * 010   011
	vfd	9/ct.tb2,9/ct.tb2 * 012   013
	vfd	9/ct.tb2,9/ct.tb2 * 014   015
	vfd	9/ct.tb2,9/ct.tb2 * 016   017
	vfd	9/ct.tb3,9/ct.tb2 * dle   021
	vfd	9/ct.tb2,9/ct.tb2 * 022   023
	vfd	9/ct.tb2,9/ct.tb2 * 024   025
	vfd	9/ct.tb2,9/ct.tb2 * 026   027
	vfd	9/ct.tb2,9/ct.tb2 * 030   031
	vfd	9/ct.tb2,9/ct.tb2 * 032   033
	vfd	9/ct.tb2,9/ct.tb2 * 034   035
	vfd	9/ct.tb2,9/ct.tb2 * 036   037
	rem
	rem
	dup	1,48
	vfd	9/ct.tb2,9/ct.tb2
	rem
	rem	* table 3 - looking for end of transparent text
	rem
	vfd	9/ct.tb2,9/ct.tb2 * 000   001
	vfd	9/ct.tb2,9/ct.bcc * 002   etx
	vfd	9/ct.tb2,9/ct.nak * 004   enq
	vfd	9/ct.tb2,9/ct.tb2 * 006   007
	vfd	9/ct.tb2,9/ct.tb2 * 010   011
	vfd	9/ct.tb2,9/ct.tb2 * 012   013
	vfd	9/ct.tb2,9/ct.tb2 * 014   015
	vfd	9/ct.tb2,9/ct.tb2 * 016   017
	vfd	9/ct.tb2,9/ct.tb2 * 020   021
	vfd	9/ct.tb2,9/ct.tb2 * 022   023
	vfd	9/ct.tb2,9/ct.tb2 * 024   025
	vfd	9/ct.tb2,9/ct.bcc * 026   etb
	vfd	9/ct.tb2,9/ct.tb2 * 030   031
	vfd	9/ct.tb2,9/ct.tb2 * 032   033
	vfd	9/ct.tb2,9/ct.tb2 * 034   035
	vfd	9/ct.tb2,9/ct.mtb * 036   itb
	rem
	rem
	dup	1,48
	vfd	9/ct.tb2,9/ct.tb2
	rem
	rem	* table 4 - end of text and control sequences
	rem	* ignoring all characters
	rem	* setcct micro-op must take us out of here for next
	rem	* data message or control sequence
	rem
	vfd	9/ct.ign+ct.tb4,9/ct.ign+ct.tb4 * 000   001
	vfd	9/ct.ign+ct.tb4,9/ct.ign+ct.tb4 * 002   003
	vfd	9/ct.ign+ct.tb4,9/ct.ign+ct.tb4 * 004   005
	vfd	9/ct.ign+ct.tb4,9/ct.ign+ct.tb4 * 006   007
	vfd	9/ct.ign+ct.tb4,9/ct.ign+ct.tb4 * 010   011
	vfd	9/ct.ign+ct.tb4,9/ct.ign+ct.tb4 * 012   013
	vfd	9/ct.ign+ct.tb4,9/ct.ign+ct.tb4 * 014   015
	vfd	9/ct.ign+ct.tb4,9/ct.ign+ct.tb4 * 016   017
	vfd	9/ct.ign+ct.tb4,9/ct.ign+ct.tb4 * 020   021
	vfd	9/ct.ign+ct.tb4,9/ct.ign+ct.tb4 * 022   023
	vfd	9/ct.ign+ct.tb4,9/ct.ign+ct.tb4 * 024   025
	vfd	9/ct.ign+ct.tb4,9/ct.ign+ct.tb4 * 026   027
	vfd	9/ct.ign+ct.tb4,9/ct.ign+ct.tb4 * 030   031
	vfd	9/ct.ign+ct.tb4,9/ct.ign+ct.tb4 * 032   033
	vfd	9/ct.ign+ct.tb4,9/ct.ign+ct.tb4 * 034   035
	vfd	9/ct.ign+ct.tb4,9/ct.ign+ct.tb4 * 036   037
	rem
	rem
	dup	1,48
	vfd	9/ct.ign+ct.tb4,9/ct.ign+ct.tb4
	rem
	start	bsc,,c3bism0b0000
	tib
	sfcm	hsla
	meters
	csbits
	tconst
	buffer
	bscdat
	pmc	restore
	rem
	rem		/* input scan control strings */
	rem
inenq	chstr	(rescan,match,enq)
inenqs	chstr	(rescan,search,enq)
ineot	chstr	(rescan,match,tibeot)
inack	chstr	(rescan,match,dle,ignore,match,tiback)
innak	chstr	(rescan,match,tibnak)
indisc	chstr	(rescan,match,dle,ignore,match,tibeot)
inwack	chstr	(rescan,match,dle,ignore,match,wack)
inrvi	chstr	(rescan,match,dle,ignore,match,rvi)
	rem
	rem		/* output bldmsg control strings */
	rem
otack	chstr	(dle,tiback,seteom)
otnak	chstr	(tibnak,seteom)
otenq	chstr	(enq,seteom)
oteot	chstr	(tibeot,seteom)
otdisc	chstr	(dle,tibeot,seteom)
otwack	chstr	(dle,wack,seteom)
otttd	chstr	(stx,enq,seteom)
otrvi	chstr	(dle,rvi,seteom)
	rem
	rem
	rem
	rem
	ttls	dialup control for bisync lines
************************************************************************
*
*	wait for bisync line to dial up. we distinguish here between
*	half and full duplex lines in how we handle
*	rts/cts during initialization
*
************************************************************************
	rem
bscstr	tstflg	tfacu,acutst	/* must dial telephone first */
	tstflg	tflisn,lisn	/* shall we listen for channel? */
	wait	0,0,begin
	rem
lisn	tstflg	tfdlup,lisnhf
	contrl	sdtr+srts+stat	/* ready fulldpx channel for operation */
	rem
waitfl	wait	0,0,bstlsn	/* wait for channel to come ready */
	status	cd+cts+dsr,0,bsdial /* go it now */
	rem
lisnhf	contrl	sdtr+rrts+stat	/* ready half dumplex chan for operation */
waithf	wait	0,0,bstlsn
	status	dsr,0,bsdial
	rem
bstlsn	tstflg	tfhang,bshang	/* do hangup if requested */
	tstflg	tflisn,lisnok	/* is listen still on? */
	goto	hungup	/* no, bail out */
lisnok	waitm
	rem
bscacu	contrl	stat	/* return from autocall, be sure line is up */
	tstflg	tfdlup,waithf
	goto	waitfl
	rem
************************************************************************
*
*	line has dialed up. do software initialization
*
************************************************************************
	rem
bsdial	getext	,bserr	/* setup tib extension */
	setlcl	exflg1,0	/* reset all flags */
	setlcl	exflg2,0
	setlcl	bidlmt,0	/* start off with indefinite bidding */
	setlcl	ttdlmt,0
	setlcl	ttdtim,5
	setlcl	naklmt,3
reinit	calasm	bsinit	/* call subr to setup some flags */
	tstlcf	exflg1,codasc,bsasci /* do ascii initialization */
	goto	bsebcd	/* do ebcdic initialization */
	rem
	rem
	rem	bisync initialization of code dependent char values
	rem
	rem		/* bisync -  ascii */
	rem
bsasci	setchr	ack0,aack0	/* establish ascii values */
	setchr	ack1,aack1
	setchr	enq,aenq
	setchr	tibnak,anak
	setchr	tibeot,aeot
	setchr	rvi,arvi
	setchr	wack,awack
	setchr	etb,aetb
	setcct	cct.ab	/* ascii needs cct */
	goto	bstart	/* get to work */
	rem
	rem		/* bisync -  ebcdic */
	rem
bsebcd	setchr	ack0,eack0	/* establish ebcdic values */
	setchr	ack1,eack1
	setchr	enq,eenq
	setchr	tibnak,enak
	setchr	tibeot,eeot
	setchr	rvi,ervi
	setchr	wack,ewack
	setchr	etb,eetb
	setcct	scc.dl	/* dont need cct for ebcdic */
	rem
bstart	tstlcf	exflg1,dialed,ck3270 /* skip if dialup part already done */
	calsub	dmpall	/* toss out any left over output */
	dumpin		/* also any input */
	signal	dialup	/* tell ring-0 about this line */
	setlcf	exflg1,dialed
	rem
	rem		/* find something to do */
	rem
bswork	tstflg	tfhang,bshang	/* hangup, if directed */
	clrlcf	exflg1,datrcv
	tstlcf	exflg1,cfgpnd,gocfg /* reconfig now if needed */
	setflg	tfmrcv	/* we are msg receive mode user */
	tstwrt	bswrit	/* if output present, try write */
	goto	bsread
	rem
************************************************************************
*
*	switch here to ibm 3270 control tables if requested
*
************************************************************************
	rem
ck3270	tstlcf	exflg2,ib3270,go3270 /* requested 3270 mode? */
	tstlcf	exflg2,haspmd,gohasp /* hasp mode selected? */
	goto	bswork
go3270	tstlcl	a3270,badadr,bswork /* dont do it if not in core */
	clrlcf	exflg1,cfgok
	tstflg	tfhang,bshang	/* last chance to bail out */
	goto	st3270	/* become a 3270 */
gohasp	tstlcl	ahasp,badadr,bswork /* ignore if hasp not configued */
	clrlcf	exflg1,cfgok
	tstflg	tfhang,bshang
	goto	sthasp
a3270	ind	st3270
ahasp	ind	sthasp
badadr	bool	776
	ttls	bisync read routines
************************************************************************
*
*	wait here for enq. this can either be a line bid
*	or the writers response to our wack
*
************************************************************************
	rem
bsread	setchr	tiback,ack0	/* prime ack value */
	clrlcf	exflg1,naksw+nakksw+wacksw+rvisw+needrv+ctlmsg
	tstlcf	exflg1,cfgpnd,gocfg /* reconfigure now if needed */
	setlcf	exflg1,cfgok	/* can accept reconfig op now */
	setime	30	/* dont wait forever if stuff to write */
	tstwrt	wtenqx
	setime	0
wtenqx	setcct	scc.bs	/* initialize cct back to base */
	setflg	tfcrcv	/* can use control rcv for line bids */
	contrl	srec+rxmit	/* setup for read */
	rem
wtenq	setlcf	exflg2,lookot	/* watch for output during read */
	calsub	read
	tstlcf	exflg2,gotot,bswrit /* got something to write */
	tstlcf	exflg2,timout,bidto /* timed out, nothing happened */
	rem
************************************************************************
*
*	got some input, so check it
*
************************************************************************
	rem
	tstlcf	exflg1,alwbid,bidsok /* branch if accepting bids */
	goto	dumpi	/* throw this away */
bidsok	inscan	inenq,notbid	/* look for line bid */
	dumpin		/* toss out line bid */
	goto	doread
	rem
notbid	tstlcf	exflg1,wacksw,chkdsc /* must be exactly enq if wack */
	inscan	inenqs,chkdsc	/* search for enq */
	dumpin		/* got it */
	goto	doread
chkdsc	inscan	indisc,dumpi	/* look for disconnect */
	goto	dumpi	/* got it, hangup */
	rem
dumpi	dumpin		/* toss out garbage */
	setime	20
	tstlcf	exflg1,wacksw,wtenqx
	goto	bswork	/* keep looking */
	rem
bidto	tstlcf	exflg1,wacksw,readto /* treat as timeout if waiting for wack */
	goto	bswork
	eject
************************************************************************
*
*	respond to the previous transmission. this could have been a
*	line bid, or we could be ackknowlidgine the previous msg.
*
************************************************************************
	rem
doread	tstlcf	exflg1,wacksw,bldwak /* is wack maybe needed? */
bldack	tstlcf	exflg1,needrv,bldrvi /* should use rvi, not ack */
useack	bldmsg	otack,bserr	/* build buffer with ack msg */
	goto	dored2
bldrvi	tstlcf	exflg1,rvisw,useack /* send ack if rvi already used */
	setlcf	exflg1,rvisw	/* try rvi */
	bldmsg	otrvi,bserr
	goto	dored2
bldwak	clrlcf	exflg1,wacksw
	tstfld	t.dcp,0,bldack	/* ok to send ack now, dia caught up */
	setime	-100	/* before wacking, pause - things may get better */
	wait	chkwak,0,bstest
	status	0,dsr,bshang
chkwak	tstfld	t.dcp,0,bldack /* temp wait worked, no need to wack at all */
	setlcf	exflg1,wacksw	/* another wack may be required later */
	bldmsg	otwack,bserr	/* build a wack message */
	meter2	m.cnt4,1	/* count it */
dored2	clrlcf	exflg1,nakksw	/* clear nak sent flag */
	holdot		/* hold ack msg */
sndrsp	clrlcf	exflg1,naksw	/* clear nak required flag */
	setlcf	exflg1,ctlmsg	/* remeber this is control message */
	calsub	writer	/* write out response */
	rem
	dmpout		/* toss out response */
	clrlcf	exflg1,ctlmsg	/* no longer have control message */
	setime	20	/* 20 seconds for input */
	tstlcf	exflg1,wacksw,wtenq /* if we wacked msg, go wait for enq */
	rem
************************************************************************
*
*	block has been read, so check it
*
************************************************************************
	rem
	calsub	read	/* rad data block */
	tstlcf	exflg2,timout,readto /* time out */
	tstlcf	exflg1,naksw,sndnak /* must nak */
	calasm	chkims	/* check for valid input block */
	tstlcl	result,resack,gotdat
	tstlcl	result,resenq,rptrsp
	tstlcl	result,reseot,gteot
	goto	sndnak
	rem
************************************************************************
*
*	must nak the current block
*
************************************************************************
	rem
sndnak	dumpin		/* toss out input */
	meter2	m.cnt1,1
rptnak	bldmsg	otnak,bserr	/* respond with nak */
	setlcf	exflg1,nakksw	/* set nak sent flag */
	holdot		/* hold nak msg */
	goto	sndrsp
	rem
************************************************************************
*
*	read eot. return to line contention mode
*
************************************************************************
	rem
gteot	sendin		/* ship eot to multics */
	goto	bswork	/* end of input blocks */
	rem
************************************************************************
*
*	read a good block. ack it and ship to multics
*
************************************************************************
	rem
gotdat	tstfld	t.dcp,0,doack	/* before shipping msg, see if dia_man caught up */
	tstlcl	wackcd,1,sndnak	/* see if wacks or naks wanted */
	setlcf	exflg1,wacksw	/* must send wack to slow sender down */
doack	meterm	0	/* count the message */
	sendin
	calsub	advack	/* advance to next ack */
	tstwrt	setrvi	/* if there is output, use rvi */
	goto	doread	/* continue with input */
setrvi	setlcf	exflg1,needrv
	goto	doread
	rem
************************************************************************
*
*	asked to repeat out previous response
*
************************************************************************
	rem
rptrsp	dumpin		/* toss out any input */
	tstlcf	exflg1,nakksw,rptnak /* repeat nak */
	bldmsg	otack,bserr	/* repeat ack */
	holdot		/* hold ack msg */
	goto	sndrsp	/* send it */
	rem
************************************************************************
*
*	time out while waiting for input
*
************************************************************************
	rem
readto	meter2	m.cnt3,1
	dumpin		/* toss out input */
	bldmsg	otdisc,bserr	/* respond with disconnect */
	setlcf	exflg1,ctlmsg	/* have a control message */
	holdot		/* hold disconnect msg */
	calsub	write	/* write the eot */
	dmpout
	clrlcf	exflg1,ctlmsg
	goto	bswork
	rem
************************************************************************
*
*	come here when reconfiguration needed. the rmode and smode
*	opblocks have already been set up in the tib extension
*
************************************************************************
	rem
gocfg	clrlcf	exflg1,cfgpnd+cfgok
	unwind
	calsub	rcvoff
	dumpin
	setlcv	gocfgr,cfgrmd	/* copy mode settings into inline code */
	setlcv	gocfgs,cfgsmd
	config
gocfgr	rmode	0
gocfgs	smode	0
	goto	reinit	/* go setup tib extension for new modes */
	ttls	bisync write routines
************************************************************************
*
*	start here with something to write. the message to write
*	is checked to insure it is valid and complete. when it
*	is, the line will be bid for.
*
************************************************************************
	rem
bswrit	clrlcf	exflg1,naksw+nakksw+wacksw+cfgok+ttdsw+ntrsw+ctlmsg
	setlcl	bidcnt,0	/* no bids yet */
	calasm	chkoms	/* check output message */
	tstlcl	result,resinc,getmor /* message incomplete */
	tstlcl	result,resack,sndenq /* good message */
	tstlcl	result,resnul,bsread /* no buffers at all yet, go wait */
	tstlcl	result,resntr,setntr /* found non-trans block in trans mode */
	dmpout
	tstlcl	result,reseot,bswork /* user asked to send eot, ignore */
	calsub	rptbad	/* report back a bad block */
	goto	bsread	/* dmpout did the sndout */
	rem
getmor	signal	sndout	/* need more output from ring-0 */
	goto	bsread	/* not complete */
	rem
************************************************************************
*
*	there is now a valid message to write, so bid for
*	the line.
*
************************************************************************
	rem
setntr	setlcf	exflg1,ntrsw	/* remember non-transparent message */
sndenq	calsub	rcvoff	/* turn off receive */
	dumpin		/* toss out any input */
	rem
	tstlcl	bidlmt,0,gobid	/* send bid if no limit */
	tstlcv	bidlmt,bidcnt,bdfail /* check for limit */
	addlcl	bidcnt,1
	rem
gobid	bldmsg	otenq,bserr	/* setup line bid */
	setchr	tiback,ack0	/* prime ack value */
	holdot		/* hold line bid */
	setlcf	exflg1,ctlmsg	/* have a control message */
	setflg	tfcrcv	/* use control rcv for efficiency */
	rem
	calsub	writer	/* write a line bid */
	eject
************************************************************************
*
*	line bid has been sent, so now wait for a response.
*
************************************************************************
	rem
	dmpout		/* toss out enq */
	clrlcf	exflg1,ctlmsg
	setime	3	/* 3 secs for response */
	rem
	calsub	read	/* read response */
	tstlcf	exflg2,timout,sndenq /* no response */
	rem
************************************************************************
*
*	some response has been received from the bid, so
*	analyze it here.
*	if the response is an ack, we will start transmitting. if
*	the response is enq (another line bid) be will go to start
*	reading. any other response (or no response) is ignored any
*	the bid will be repeated.
*
************************************************************************
	rem
	inscan	inenq,chkack	/* look for line bid */
	dumpin		/* toss out enq */
	goto	doread	/* input over output */
	rem
chkack	inscan	inack,sndenq	/* look for ack */
	dumpin		/* toss out ack */
	calsub	advack	/* advance to next ack */
	goto	sdout
	rem
************************************************************************
*
*	line bidding has failed. report back to multics
*
************************************************************************
	rem
bdfail	meter2	m.cnt8,1
	setlcl	ctlop,lstbdf	/* code to report bid failure */
	setlcl	ctlvl1,0
	linsta	ctlop
	goto	bsread
	eject
************************************************************************
*
*	transmit a data block
*
************************************************************************
	rem
sdout	calasm	tsthld	/* see if hold flag already is on */
	tstlcl	tempsw,1,skphld /* if so, we have already been */
	rem		/* here for this message and must not do */
	rem		/* another send output */
	meterm	1	/* here to make sure we count it only once */
	holdot		/* hold output message */
	signal	sndout	/* get next data message from ring-0 */
skphld	setlcl	nakcnt,0	/* reset count of naks */
	setlcl	enqcnt,0	/* reset count of bad resp and timout */
	clrlcf	exflg1,ttdsw
	setlcl	ttdcnt,0
	rem
rptout	tstlcf	exflg1,ntrsw,rptot2 /* must go to non-trans mode */
	goto	rptot3
rptot2	config
	rmode	fg.btr	/* turn off transparency */
rptot3	setflg	tfcrcv	/* can use control rcv for ack */
	calsub	writer	/* repeat response */
	rem
************************************************************************
*
*	data block has been transmitted, wait for response.
*
************************************************************************
	rem
sntout	setime	3	/* 3 secs for response */
	rem
	calsub	read
	tstlcf	exflg2,timout,rspto
	rem
************************************************************************
*
*	a response has been received to our transmission.
*	that response is analyzed here. possibles replies are:
*
*	ack	msg recieved ok, the next will be sent
*	nack	error in msg, retransmit
*	eot	throw out msg, rtuurn to line contention
*	dle-eot	same as eot
*	wack	treated as positive response, but we
*		must sned enqs to see when it is ok to send
*		next message.
*
*	if there is any other response, it is assumed to be a garbled
*	message and we will send enq to have it repeated.
*
************************************************************************
	rem
	tstlcf	exflg1,ntrsw,gotrs0 /* must go back to transparent */
	goto	gotrs1
gotrs0	config
	smode	fg.btr
gotrs1	inscan	innak,gotrs2	/* check for nak */
	goto	gotnak
gotrs2	inscan	inack,gotrs3	/* check for ack */
	goto	gudack
gotrs3	inscan	indisc,gotrs4	/* check for dle,eot */
	goto	likeot
gotrs4	inscan	inwack,gotrs5	/* check for wack */
	goto	gotwck
gotrs5	inscan	inrvi,gotrs6	/* check for rvi */
	goto	gotrvi
gotrs6	inscan	ineot,rspagn	/* check for eot */
	rem
************************************************************************
*
*	response is an eot. throw out msg and go back to line
*	contention mode.
*
************************************************************************
	rem
likeot	dumpin
	goto	bswork
	rem
************************************************************************
*
*	the response is an ack. throw out current message
*
************************************************************************
	rem
gudack	dumpin		/* toss out ack */
	calsub	advack	/* advance to next ack */
	tstlcf	exflg1,wacksw,skpdmp /* if previously wacked, msg already gone */
	dmpout		/* toss out data sent */
	clrlcf	exflg1,ntrsw
skpdmp	clrlcf	exflg1,wacksw
	rem
************************************************************************
*
*	now look for next message. if one is not ready in the
*	specified time limit, we will give up and send an
*	eot.
*
************************************************************************
	rem
chkout	calasm	chkoms	/* check output message */
	tstlcl	result,resack,sdout /* good message */
	tstlcl	result,resntr,fndntr /* got non-transparent msg */
	tstlcl	result,resinc,getout /* incomplete message */
	tstlcl	result,resnul,justwt /* wait, data should be coming */
	dmpout		/* throw away bad stuff */
	tstlcl	result,reseot,sndeot /* asked for eot */
	calsub	rptbad	/* report bad block */
	goto	justwt	/* skip sndout, dmpout did it */
getout	signal	sndout	/* get next data message from ring-0 */
justwt	setimv	ttdtim	/* wait before sending eot */
	wait	sndttd,chkout,bstest
	status	0,dsr,bshang
fndntr	setlcf	exflg1,ntrsw	/* must reconfigure for this msg */
	goto	sdout
	rem
************************************************************************
*
*	next message not ready soon enough. we must either send a ttd
*	or and eot
*
************************************************************************
	rem
sndttd	tstlcv	ttdcnt,ttdlmt,sndeot /* eot if too many already */
	addlcl	ttdcnt,1
	bldmsg	otttd,bserr	/* constucte ttd message */
	setlcf	exflg1,ctlmsg
	holdot
	setflg	tfcrcv
	calsub	writer	/* transmit it */
	setlcf	exflg1,ttdsw
	dmpout		/* throw out ttd */
	clrlcf	exflg1,ctlmsg
	goto	sntout
	rem
*	come here when nak received in response to ttd
	rem
ttdnak	clrlcf	exflg1,ttdsw
	goto	chkout	/* go see if message ready now */
	rem
************************************************************************
*
*	here when eot must be sent. this can be because Multics
*	requested it, too many errors occured, or because the
*	next message was not available soon enough.
*
************************************************************************
	rem
sndeot	bldmsg	oteot,bserr	/* setup eot */
	setlcf	exflg1,ctlmsg
	holdot		/* hold eot msg */
	calsub	write
	rem
	dmpout		/* toss out eot msg */
	clrlcf	exflg1,ctlmsg
	goto	bsread	/* wait 3 secs before next write */
	rem
************************************************************************
*
*	here when the response to out transmission is a nak.
*	we will retransmit unless that has been done too many times
*	already.
*
************************************************************************
	rem
gotnak	dumpin		/* toss out nak */
	tstlcf	exflg1,ttdsw,ttdnak /* nak in response to our ttd */
	meter2	m.cnt2,1
	tstlcv	nakcnt,naklmt,manynk /* too many naks? */
	addlcl	nakcnt,1	/* count another */
	addlcl	nakmtr,1
	goto	rptout	/* repeat data */
manynk	meter2	m.cnt6,1
	setlcl	ctlop,lstnak	/* report excessive naks */
	setlcl	ctlvl1,0
	linsta	ctlop
	dmpout
	goto	sndeot
nakmtr	oct	0
	rem
************************************************************************
*
*	the response to out message was a wack. this is a posituve
*	response, but we must send enqs looking for an ack before sending
*	the next message.
*
************************************************************************
	rem
gotwck	dumpin		/* toss out wack */
	meter2	m.cnt5,1
	tstlcf	exflg1,wacksw,waitwk /* dont dmpout unless this is first wack */
	dmpout
	setlcf	exflg1,wacksw
waitwk	setime	1	/* wait a while before retry */
	wait	tryenq,0,bstest
	rem
************************************************************************
*
*	rvi received in response to our transmission.
*	tell multics and treat as an ack
*
************************************************************************
	rem
gotrvi	tstlcf	exflg1,ttdsw,sndeot /* in response to our ttd */
	dmpout		/* treat as good ack */
	goto	sndeot	/* turn line around */
	rem
************************************************************************
*
*	come here to send an enq because of a wack, a garbled
*	response, or no response.
*
************************************************************************
	rem
rspto	meter2	m.cnt3,1
	calsub	rcvoff	/* turn off receive */
	tstlcf	exflg1,ntrsw,rspto1 /* must go back to transparent */
	goto	rspagn
rspto1	config
	smode	fg.btr
rspagn	meter2	m.cnt7,1
	dumpin		/* toss out input */
	tstlcl	enqcnt,enqlmt,sndeot /* test for limit exceeded */
	addlcl	enqcnt,1
tryenq	bldmsg	otenq,bserr	/* setup enq */
	holdot		/* hold enq msg */
	setlcf	exflg1,ctlmsg
	setflg	tfcrcv
	calsub	writer
	rem
	dmpout		/* toss out enq */
	clrlcf	exflg1,ctlmsg
	goto	sntout	/* wait for response */
	ttls	bisync test-state routine
************************************************************************
*
*	bisync test state handler
*
************************************************************************
	rem
bsctst	null		/* external calls state here */
bstest	tstflg	tfhang,bshang	/* hangup, if directed */
	linctl	ctlop,tstret	/* check for line control call */
	tstlcl	ctlop,lctbid,setbid /* 1 = set bid limit */
	tstlcl	ctlop,lctabd,accbid /* 2 = set bids ok flag */
	tstlcl	ctlop,lctcfg,recfg /* 3 = reconfigure */
	tstlcl	ctlop,lctttd,setttd /* 4 = set ttd params */
	tstlcl	ctlop,lcttwr,testwr /* 5 = report write status */
	tstlcl	ctlop,lct327,set327 /* 6 = set ibm3270 mode */
	tstlcl	ctlop,lctpla,setpla /* 7 = set polling address */
	tstlcl	ctlop,lctsla,setsla /* 9 = set selection address */
	tstlcl	ctlop,lctmst,setmst /* 11 = set master of slave */
	tstlcl	ctlop,lcthsp,sethsp /* 12 = set hasp mode */
	tstlcl	ctlop,lctnak,setnkl /* 13 = set nak limit */
	tstlcl	testrt,0,tstret /* extra handler */
	gotov	testrt	/* if so, call it */
tstret	waitm
	rem
setbid	setlcv	bidlmt,ctlvl1	/* set bid limit */
	waitm
	rem
accbid	setlcf	exflg1,alwbid	/* read side can take bids now */
	waitm
	rem
setttd	setlcv	ttdtim,ctlvl1	/* time interval */
	setlcv	ttdlmt,ctlvl2	/* max to send */
	waitm
	rem
set327	setlcf	exflg2,ib3270
	waitm
	rem
setpla	setlcv	polad1,ctlvl1	/* copy addr */
	setlcv	polad2,ctlvl2
	setlcv	polad3,ctlvl3
	waitm
	rem
setsla	setlcv	selad1,ctlvl1	/* set selection address */
	setlcv	selad2,ctlvl2
	setlcv	selad3,ctlvl3
	waitm
	rem
setmst	clrlcf	exflg2,master	/* assume secondary */
	tstlcl	ctlvl1,0,tstret
	setlcf	exflg2,master
	waitm
	rem
sethsp	setlcf	exflg2,haspmd
	waitm
	rem
setnkl	setlcv	naklmt,ctlvl1
	waitm
	rem
************************************************************************
*
*	order is to report write status. a line_status signal will be
*	returned indicating wheterh or not there is data in the fnp
*	yet to be written. if 'ctlmsg' is off, and output chain
*	represents data to write. if 'ctlmsg' is on, the first output
*	buffer is a control sequence, not data, and the second buffer
*	must be checked. (with a special asm subr)
*
************************************************************************
	rem
testwr	setlcl	ctlop,lstrwr	/* code for reporting write */
	setlcl	ctlvl1,1	/* assume data present */
	tstlcf	exflg1,ctlmsg,testw1 /* is there a control message? */
	tstwrt	testw2	/* there is output */
	setlcl	ctlvl1,0	/* indicate none */
testw2	linsta	ctlop	/* send back answer */
	waitm
testw1	calasm	tstbf2	/* check second buffer */
	setlcv	ctlvl1,tempsw	/* copy answer */
	goto	testw2
	rem
************************************************************************
*
*	here when test state call is to reconfigure. the rmode and
*	smode blocks needed are built in the tib extenstion, and
*	the actual reconfiguration is either done now, or pending
*	depending on 'cfgok'.
*
************************************************************************
	rem
recfg	setlcv	cfgrmd,recfgr	/* initialize rmode and smode words */
	setlcv	cfgsmd,recfgs
	tstlcl	ctlvl1,0,recfg1	/* non-tran ascii */
	tstlcl	ctlvl1,1,recfg2	/* non-tran ebcdic */
	tstlcl	ctlvl1,2,recfg3	/* tran ascii */
	tstlcl	ctlvl1,3,recfg4	/* tran ebcidc */
	waitm
recfg1	setlcf	cfgrmd,fg.beb+fg.btr /* non-trans ascii */
	setlcf	cfgsmd,fg.lpr+fg.lps+fg.lpo+fg.cct
	goto	recfg5
recfg2	setlcf	cfgrmd,fg.btr+fg.lpr+fg.lps+fg.lpo+fg.cct /* non-trans ebcdic */
	setlcf	cfgsmd,fg.beb
	goto	recfg5
recfg3	setlcf	cfgrmd,fg.beb	/* trans ascii */
	setlcf	cfgsmd,fg.btr+fg.cct+fg.lps+fg.lpr+fg.lpo
	goto	recfg5
recfg4	setlcf	cfgsmd,fg.beb+fg.btr /* trans ebcdic */
	setlcf	cfgrmd,fg.lpr+fg.lps+fg.lpo+fg.cct
recfg5	setlcf	exflg1,cfgpnd	/* reconfig now pending */
	tstlcf	exflg1,cfgok,gocfg /* if now is a good time */
	waitm
recfgr	rmode	0
recfgs	smode	0
	rem
	rem
************************************************************************
*
*	come here to hangup
*
************************************************************************
	rem
bshang	retext
	unwind
	stpchn		/* stop channel */
	calsub	dmpall	/* toss out any output */
	dumpin		/* toss out any input */
	clrflg	(tfwabt,tfrabt)	/* clear abort flags */
	clrflg	(tflisn,tfhang)	/* clear listen, hang flags */
	signal	hangup	/* tell ring-0 */
	goto	hungup	/* that's all folks */
	rem
bserr	punt	100	/* bad condition-bombs away */
	ttls	bisync opblock subroutines
************************************************************************
*
*	subroutine to switch acks
*
************************************************************************
	rem
bscswa	null
advack	cmpchr	tiback,ack0,prime1 /* test for ack0 */
	setchr	tiback,ack0	/* prime to ack0 */
	retsub		/* return */
prime1	setchr	tiback,ack1	/* prime to ack1 */
	retsub		/* return */
	rem
************************************************************************
*
*	subroutine to turn off recieve mode
*
************************************************************************
	rem
rcvoff	setime	1
	contrl	rrec+smark
	wait	rcvoff,0,bstest
	status	marker,0,rcvofx
	status	0,dsr,bshang
rcvofx	retsub
	rem
************************************************************************
*
*	subroutine to dump the entire output chain
*
************************************************************************
	rem
dmpall	dmpout
	tstwrt	dmpall
	retsub
	rem
************************************************************************
*
*	report a bad block bad to multics
*
************************************************************************
	rem
bscbad	null		/* external entry */
rptbad	setlcl	ctlop,lstbbk
	setlcl	ctlvl1,0
	linsta	ctlop
	retsub
	eject
************************************************************************
*
*	subroutine to write the current output stuff.
*	it can be called at "write", in which case only output
*	is done, or it can be called at "writer", which
*	also sets receive mode during the output. the flag
*	"datrcv" in the tib ext will be set if data is read while
*	the output is in progress.
*
************************************************************************
	rem
bscwt	null
write	clrlcf	exflg1,rflag	/* remember which entry */
	goto	write1
	rem
bscwtr	null
writer	setlcf	exflg1,rflag
	rem
write1	setime	0
	setcct	scc.bs	/* back to base cct */
	clrlcf	exflg1,datrcv
	rem
	tstflg	tfdlup,write3	/* half duplex */
	goto	write4	/* full duplex */
	rem
write3	tstlcf	exflg1,rflag,write5 /* choose between dcw lists */
	dcwlst
	cmd	sxmit+srts
	output	(outmsg)
	cmd	rxmit+rrts+sterm
	goto	write6
	rem
write5	dcwlst
	cmd	sxmit+srec+srts
	output	(outmsg)
	cmd	rxmit+rrts+sterm
	goto	write6
	rem
write4	tstlcf	exflg1,rflag,write7 /* choose between fulldpx dcwlists */
	dcwlst
	cmd	sxmit
	output	(outmsg)
	cmd	rxmit+sterm
	goto	write6
	rem
write7	dcwlst
	cmd	sxmit+srec
	output	(outmsg)
	cmd	rxmit+sterm
	rem
write6	wait	0,write2,bstest	/* common wait block */
	status	0,dsr,bshang
	status	term,0,write9
	status	brkchr,0,write8	/* got input during output */
	status	parity,0,wpar
	status	bscrcv,0,write8
	status	exh,0,wexh
	rem
wpar	meter1	m.par,1
	goto	write8
	rem
wexh	meter2	m.exh,1
write8	setlcf	exflg1,datrcv	/* remember data came in */
	waitm
	rem
write2	setlcf	exflg2,outarv	/* flag saying output arrived */
	waitm
	rem
write9	retsub
	eject
************************************************************************
*
*	common subroutine to do input
*
************************************************************************
	rem
bscrd	null
read	clrlcf	exflg1,naksw	/* no error yet */
	clrlcf	exflg2,timout+gotot
	tstlcf	exflg1,datrcv,read8 /* input already here */
	tstlcf	exflg1,codasc,read1 /* ascii input */
	rem
************************************************************************
*
*	wait for input (ebcdic)
*
************************************************************************
	rem
	wait	read10,read11,bstest /* wait for ebcdic input */
	status	0,dsr,bshang
	status	xte,0,rxte
	status	bscrcv+parity,0,rpar
	status	bscrcv,0,read8
	status	rcvto,0,read3
	status	exh,0,rexh
	status	parity,0,read2
	rem
rxte	meter1	m.xte,1
	goto	read3
	rem
rpar	meter1	m.par,1
	goto	read3
	rem
read2	meter1	m.par,1
	setlcf	exflg1,naksw
	clrlcf	exflg1,cfgok
	waitm
read3	setlcf	exflg1,naksw
	goto	read8
	rem
************************************************************************
*
*	wait for input (ascii)
*
************************************************************************
	rem
read1	wait	read10,read11,bstest /* wait for ascii input */
	status	0,dsr,bshang	/* no dsr, may have hungup */
	status	bscrcv+bscdmk,0,read8 /* dle,stx,...,dle,(etx,etb or enq) */
	status	bscrcv,0,read3	/* ...,dle,(etx,etb,itb or enq) */
	status	bscdmk+bscmrk,0,read5 /* dle,stx,...,dle,itb */
	status	bscdmk+brkchr,0,read6 /* dle,stx,...,dle,(etx,etb or enq) */
	status	bscdmk,0,read4	/* dle,stx,... */
	status	brkchr,0,read8	/* non-transparent text or control sequence */
	status	rcvto,0,read3	/* receive time out */
	status	exh,0,rexh
	rem
read4	clrlcf	exflg1,cfgok
	wait	read10,read14,bstest /* transparent text */
	status	0,dsr,bshang	/* no dsr, may have hungup */
	status	bscrcv,0,read3	/* ...,dle,enq */
	status	brkchr,0,read6	/* ...,dle,(etx,etb, or enq) */
	status	bscmrk,0,read5	/* ...,dle,itb */
	status	exh,0,rexh
	rem
read5	clrlcf	exflg1,cfgok
	wait	read10,read14,bstest /* wait for rbt after itb */
	status	0,dsr,bshang	/* no dsr, may have hungup */
	status	parity,0,read7	/* crc error */
	status	bscrcv,0,read4	/* good itb block */
	status	exh,0,rexh
	rem
read6	clrlcf	exflg1,cfgok
	wait	read10,read14,bstest /* wait for rbt after etx or etb */
	status	0,dsr,bshang	/* no dsr, may have hungup */
	status	parity,0,rpar	/* crc error */
	status	bscrcv,0,read8	/* good block */
	status	exh,0,rexh
	rem
read7	meter1	m.par,1
	setlcf	exflg1,naksw	/* remember nak required */
	goto	read4
	rem
************************************************************************
*
*	input terminated, reset recieve mode */
*
************************************************************************
	rem
rexh	meter2	m.exh,1
read8	clrlcf	exflg1,cfgok
read13	setime	1	/* retry if it takes too long */
	contrl	rrec+smark
	wait	read13,read14,bstest
	status	0,dsr,bshang
	status	marker,0,read9
	rem
read9	clrlcf	exflg2,lookot
	retsub
	rem
************************************************************************
*
*	timeout during input
*
************************************************************************
	rem
read10	setlcf	exflg2,timout
	goto	read8
	rem
************************************************************************
*
*	got write during read
*
************************************************************************
	rem
read11	setlcf	exflg2,outarv	/* remember output for hasp */
	tstlcf	exflg2,lookot,read12 /* see if we care */
	waitm		/* no */
read12	setlcf	exflg2,gotot
	goto	read8
read14	setlcf	exflg2,outarv
	waitm
	ttls	bisync assembler subroutines
************************************************************************
*
*	subroutine called when a bisync line dials up. it
*	sets some flags and pointers in the tib extension
*
************************************************************************
	rem
bsinit	subr
	rem
*	generate an index, based on mode
*	0=non-transparent ascii
*	1=non-transparent ebcdic
*	2=    transparent ascii
*	3=    transparent ebcdic
	rem
	ldx2	l.a001-*	=0
	ldx3	t.sfcm,1	software comm region
	lda	sf.cfg+1,3	second word of config pcw
	cana	l.a008-*	=400, ebcdic bit
	tze	bsi010-*	off
	iacx2	1
	lda	l.a013-*	=tfkpar
	orsa	t.flg3,1	indicate that parity is to be kept
	tra	bsi020-*
bsi010	lda	l.a014-*	=^tfkpar
	ansa	t.flg3,1	parity not to be kept
bsi020	lda	sf.cfg+1,3	get second word of pcw back
	icana	=o200	check transparent bit
	tze	2	off
	iacx2	2
	rem
*	get flags for tib extension flag word
	rem
	ldx3	l.a002-*	=exflg1
	tsy	a.a001-*,*	=cvaddr
	lda	l.a009-*	mask to turn off all config bits
	ansa	0,3
	lda	l.a003-*,*	get flags from table
	orsa	0,3
	rem
*	get address of ascii or ebcdic table
	rem
	ldx3	l.a004-*	=chartb
	tsy	a.a001-*,*	=cvaddr
	lda	l.a005-*,*
	sta	0,3
	rem
*	get address of state transition table
	rem
	ldx3	l.a006-*	=stattb
	tsy	a.a001-*,*	=cvaddr
	lda	l.a007-*,*	get addr
	sta	0,3
	rem
	ldx2	l.a001-*
	return	bsinit
	rem
a.a001	ind	cvaddr
a.a002	ind	setbpt
	rem
l.a001	oct	0
l.a002	vfd	18/exflg1
l.a003	ind	*+1,2
	vfd	o18/trnoff+codasc
	vfd	o18/trnoff+codebc
	vfd	o18/trnon+codasc
	vfd	o18/trnon+codebc
l.a004	vfd	18/chartb
l.a005	ind	*+1,2
	ind	atab
	ind	etab
	ind	atab
	ind	etab
l.a006	vfd	18/stattb
l.a007	ind	*+1,2
	ind	sttnta
	ind	sttnte
	ind	stttrn
	ind	stttrn
l.a008	oct	400
l.a009	vfd	o18//trnon*/trnoff*/codebc*/codasc
l.a010	vfd	18/bffhld
l.a013	vfd	18/tfkpar
l.a014	vfd	o18//tfkpar
	eject
************************************************************************
*
*	test to see if the hold output flag is on for the
*	current write message
*
************************************************************************
	rem
tsthld	subr
	stz	tempsw-*
	lda	t.ocp,1
	tsy	a.a002-*,*	setbpt
	cax3		get virtual address
	lda	bf.flg,3
	cana	l.a010-*	=bfflst
	tze	2
	aos	tempsw-*
	return	tsthld
tempsw	bss	1
	rem
************************************************************************
*
*	test1 to see if there is a second write buffer
*
************************************************************************
	rem
tstbf2	subr
	stz	tempsw-*	say no
	lda	t.ocp,1	addr of first buffer
	tze	tstbfr-*
	tsy	a.a002-*,*	setbpt
	cax3
	szn	bf.nxt,3	more?
	tze	tstbfr-*	no
	aos	tempsw-*
tstbfr	return	tstbf2
	eject
************************************************************************
*
*	subroutine that checks the validity of bisync messages
*
************************************************************************
	rem
*	entry point to check output message
*
bsccko	null
chkoms	subr
	stz	iosw-*
	aos	iosw-*	non-zero indicates output
	tra	chk010-*
	rem
*	entry point to check input messages
	rem
bsccki	null
chkims	subr
	stz	iosw-*	zero indciates input
	rem
*	common path
	rem
chk010	stz	ntrflg-*	no non-transparent msg
	ila	result	get addr of anser in tib ext
	cax3
	tsy	a.a001-*,*	=cvaddr
	stx3	ireslt-*
	stz	ireslt-*,*
	tsy	chkini-*	get pointer to first buffer
	tra	tttnul-*	none, msg incomplete
	ldx3	l.b001-*	=chartb
	tsy	a.b001-*,*	=cvaddr
	lda	0,3	get pointer to character table
	sta	tabadr-*	and save
	lda	chartb-stattb,3	get table address
	sta	astate-*
	sta	curstt-*	current state is 0
	rem
*	loop thru each character
	rem
chk020	tsy	chkget-*
	tra	tttinc-*	no more, msg incomplete
	ada	curstt-*	get index into current state table
	cax2
	lda	0,2	current action code
	tpl	0,2*	+ means branch address
	ila	0
	sba	0,2	get new state
chk030	mpf	l.b003-*	=statel
	lls	17
	ada	astate-*	addr of new state entry
	sta	curstt-*
	tra	chk020-*	and back around
	rem
*	message is incomplete
	rem
tttnul	ila	resnul	no data at all
	sta	ireslt-*,*
tttinc	szn	iosw-*	input or output?
	tze	tttnak-*	nak inputete input
	lda	nbufs-*	get count of bufs in output msg
	icmpa	4*bufmax	over max?
	tpl	tttnak-*	yes, this is garbage
	tra	chkret-*
	rem
*	bad message, should be nakked
	rem
tttnak	ila	resnak
	sta	ireslt-*,*
	tra	chkret-*
	rem
*	message was an enq
	rem
tttenq	ila	resenq
	sta	ireslt-*,*
	tra	chkret-*
	rem
*	message was an eot
	rem
ttteot	ila	reseot
	sta	ireslt-*,*
	tra	tttak3-*
	rem
*	message was non-transparent while in transparent mode
*	setup to rescan message in appropriate non-transparent mode
	rem
tttntr	aos	ntrflg-*	flag as non-tranaparent
	lda	tabadr-*	check ascii or ebcdic
	cmpa	a.b003-*	=addr (atab)
	tze	tttnt1-*	ascii
	lda	a.b004-*	addr of ebcdic state table
	tra	tttnt2-*
	rem
tttnt1	lda	a.b005-*	addr of ascii state table
tttnt2	sta	astate-*
	sta	curstt-*
	tsy	chkini-*	setup to rescan
	nop
	tra	chk020-*	and rescan
	rem
*	special functions
	rem
*	function 1 - zero lrc and go to state 1
	rem
tttsp1	stz	lrcwrd-*
	stz	lrcprv-*
	ila	1
	tra	chk030-*
	rem
*	function 2 - check lrc and go to ack
	rem
tttsp2	tsy	chklrc-*
	tra	tttnak-*	error
	tra	tttack-*	ok
	rem
*	function 3 - check lrc and go to state 4
	rem
tttsp3	tsy	chklrc-*
	tra	tttnak-*	error
	ila	4
	tra	chk030-*
	rem
*	good message
	rem
tttack	ila	resack
	szn	ntrflg-*	was it non-transparent
	tze	2	no
	ila	resntr
	sta	ireslt-*,*
tttak3	szn	iosw-*	input or output?
	tze	tttak1-*	input
	tsy	chkget-*	if output, there should be no more chars
	tra	tttak2-*	that is true
	tra	tttnak-*	bad output msg
tttak2	ldx2	curbuf-*	pointer to last buffer
	lda	l.b006-*	=bfflst, flag as last
	orsa	bf.flg,2
	tra	chkret-*
tttak1	tsy	chkdel-*	trim extraneous stuff from input
	lda	t.ilst,1	set break in last buffer
	tsy	a.b006-*,*	setbpt
	cax2
	lda	l.b008-*	=bffbrk
	orsa	bf.flg,2
	rem
*	return
	rem
chkret	ldx2	l.b007-*	=0
	szn	iosw-*	check which entry
	tze	chkrti-*
	return	chkoms
chkrti	return	chkims
	rem
*	subroutine to get pointer to first buffer
	rem
chkini	subr
	stz	nbufs-*	initialize buffer counter
	ldx2	t.icp,1	input bufer chain
	szn	iosw-*	is it input?
	tze	2	yes
	ldx2	t.ocp,1	output buffer chain
	tsy	chkbuf-*	setup pointers
	tra	2	non-skip return means no buffers
	aos	chkini-*	skip return means buffer ok, so we skip too
	return	chkini
	rem
*	routine which, given a buffer, sets up a pointer and tally
	rem
chkbuf	subr
	cx2a
	tze	chkb01-*	no buffer
	aos	chkbuf-*	there is a buffer, so return will skip
	tsy	a.b006-*,*	setbpt
	cax2
	sta	curbuf-*	save virtual pointer to buffer
	iaa	bf.dta-1	make pointer to char(-1)
	ora	l.b004-*
	sta	curptr-*
	lda	bf.tly,2	get tally from buffer
	ana	l.b005-*	=buftmk
	sta	curcnt-*
	aos	nbufs-*	count buffers
chkb01	return	chkbuf
	rem
*	subroutine to fetch and decode the next character
	rem
chkget	subr
chkgt0	szn	curcnt-*	any chars left in buf?
	tnz	chkgt1-*	yes
	ldx2	curbuf-*	start of buffer
	lda	bf.flg,2	pick up flag word
	cana	l.b006-*	=buflst, last buffer in msg?
	tnz	chkgt2-*	yes, return, no more chars
	ldx2	bf.nxt,2	next buffer
	tsy	chkbuf-*	set it up
	tra	chkgt2-*	no more buffers
	tra	chkgt0-*	go get char from this buffer
chkgt1	aos	chkget-*	so return will skip
	ila	-1
	asa	curcnt-*	count character
	ldx2	curptr-*	pointer to previous char
	iacx2	0,b.1
	stx2	curptr-*	save pointer for next call
	lda	0,2,b.0	get current char
	ldq	lrcwrd-*	save copy of lrc before this char
	stq	lrcprv-*
	ersa	lrcwrd-*	update lrc
	icmpa	64	is it text?
	tmi	chkgt3-*	no
	ila	tb.cha	load text code
	tra	chkgt2-*
chkgt3	ada	tabadr-*	get addr of table entry for char
	cax2
	lda	0,2	get type code
chkgt2	return	chkget
	rem
*	subroutine that truncates the input buffer chain, starting with the next
*	character. this is called in case extra data was stored by the
*	hsla sub-channel before receive mode was turned off.
	rem
chkdel	subr
	ldx2	curbuf-*	buffer that shouldd be last
	lda	bf.tly,2	get current tally
	sba	curcnt-*	subtract any chars not needed
	sta	bf.tly,2
	ana	l.b005-*	look at tally
	tze	chkdl1-*	it's zero, find previous one
	cx2a		get absolute address
	tsy	a.b007-*,*	cvabs
	tra	chkdl3-*	ok to use
chkdl1	lda	t.icp,1	following loop gets ptr to prev buf
chkdl2	tsy	a.b006-*,*	setbpt
	cax2
	lda	bf.nxt,2
	cmpa	curbuf-*	find buf that points to curbuf
	tnz	chkdl2-*	not yet
chkdl3	sta	t.ilst,1	this is really last buffer
	lda	bf.nxt,2	get first buffer to free
	stz	bf.nxt,2	make chain stop here
	tze	chkdl4-*	no buffers to free
chkdl5	sta	freadr-*	hold on to buffer address
	tsy	a.b006-*,*	setbpt
	cax3		get it in virtual form
	lda	bf.nxt,3	save next pointer in case more bufs
	sta	curbuf-*
	ldx2	bf.siz,3	get size word from buffer
	lda	freadr-*	get address for freeing
	ilq	0	let frebuf get buffer size
	tsy	a.b002-*,*	=frebfh
	cx2a		get saved size word
	arl	15	=number of 32 word buffers - 1
	iera	-1	add 1 and negate
	asa	t.icpl,1
	lda	curbuf-*	see if more to free
	tnz	chkdl5-*
chkdl4	return	chkdel
	rem
	rem
*	function to check or generate lrc
	rem
chklrc	subr
	ldx2	curptr-*	addr of lrc in msg
	lda	lrcprv-*	value computed so far
	szn	iosw-*	input or output?
	tze	chklr1-*	input
	sta	0,2,b.0	output - store lrc
	tra	chklr2-*	done
chklr1	cmpa	0,2,b.0	input - lrc correct?
	tnz	chklr3-*	no, take error return
chklr2	aos	chklrc-*	setup skip return
chklr3	return	chklrc
	rem
ireslt	bss	1	addr of final answer
	rem
iosw	bss	1	0=input call, 1=output call
astate	bss	1	addr of state table
curstt	bss	1	address of current state
tabadr	bss	1	addr of either atab or etab
curbuf	bss	1	current (virtual) buffer pointer
curptr	bss	1	current (virtual) character pointer
curcnt	bss	1	current tally in buffer
lrcwrd	bss	1	lrc accumulation word
lrcprv	bss	1	lrc accumulation before current char
nbufs	bss	1	count buffers in a chain
ntrflg	bss	1	flag for non-trans in trans mode
freadr	bss	1	absolute address of buffer to be freed
	rem
a.b001	ind	cvaddr
a.b002	ind	frebfh
a.b003	ind	atab
a.b004	ind	sttnte
a.b005	ind	sttnta
a.b006	ind	setbpt
a.b007	ind	cvabs
	rem
l.b001	vfd	18/chartb
l.b002	vfd	18/stattb
l.b003	vfd	18/statel
l.b004	ind	0,b.1
l.b005	vfd	18/buftmk
l.b006	vfd	18/bfflst
l.b007	oct	0
l.b008	vfd	18/bffbrk
	eject
*
*	state transition tables for checking bisync message formats
*
statel	equ	9	length of entry for one state
*
*	table for transparent ascii or ebcdic
*
stttrn	null
*
*		state 0 - looking at start of message
*
	ind	tttnak	normal character is error here
	ind	tttntr	stx means non-transparent block
	ind	tttnak	etx is error here
	ind	tttnak	etb is error here
	ind	tttenq	enq is a valid msg
	ind	ttteot	eot is valid msg
	ind	tttnak	itb is error here
	dec	-1	dle means enter state 1
	ind	tttntr	soh means non-transparent block
*
*		state 1 - first character was a dle
*
	ind	tttnak	text char is error here
	dec	-2	stx means start message
	ind	tttnak	etx is error here
	ind	tttnak	etb is error here
	ind	tttenq	dle-enq is valid msg
	ind	ttteot	dle-eot is valid msg
	ind	tttnak	itb is error here
	ind	tttnak	dle is error here
	ind	tttnak	dle-soh is error
*
*		state 2 - msg started dle-stx
*
	dec	-2
	dec	-2
	dec	-2
	dec	-2
	dec	-2
	dec	-2
	dec	-2
	dec	-3	dle is only interesting char here
	dec	-2
*
*		state 3 - found dle in text
*
	dec	-2	text char is data
	ind	tttnak	dle-stx is error
	ind	tttack	dle-etx is good end
	ind	tttack	dle-etb is good end
	ind	tttnak	dle-enq is error
	ind	tttnak	dle-eot is error
	dec	-4	dle-itb is end of int block
	dec	-2	dle-dle is data
	ind	tttnak	dle-soh is error
*
*		state 4 - found dle-itb in text
*
	ind	tttnak
	ind	tttnak
	ind	tttnak
	ind	tttnak
	ind	tttnak
	ind	tttnak
	ind	tttnak
	dec	-5	only good character is dle
	ind	tttnak
*
*		state 5 - found dle after itb in text
*
	ind	tttnak	text char is error here
	dec	-2	stx starts another block
	ind	tttack	etx ends block
	ind	tttack	etb ends block
	ind	tttnak	enq is error
	ind	tttnak	eot is error
	dec	-2	itb is null block
	ind	tttnak	dle is error here
	ind	tttnak	soh is error
	eject
*
*	state transition table for non-transparent ebcdic
*
sttnte	null
*
*		state 0 - looking at start of message
*
	ind	tttnak	text char is error
	dec	-1	stx starts message
	ind	tttnak	etx is error
	ind	tttnak	etb is error
	ind	tttenq	enq is valid message
	ind	ttteot	eot is valid message
	ind	tttnak	itb is error here
	ind	tttnak	dle is error here
	dec	-3	soh starts header
*
*		state 1 - found stx at front
*
	dec	-1	text char is valid
	ind	tttnak	stx error here
	ind	tttack	etx is good end
	ind	tttack	etb ius good end
	ind	tttnak	enq is error
	ind	tttnak	eot is error
	dec	-2	itb is end of int block
	dec	-1	dle is text char
	ind	tttnak	soh is error
*
*		state 2 - found itb in text
*
	dec	-1	text can start without stx
	dec	-1	stx starts new block
	ind	tttack	etx is good end
	ind	tttack	etb is good end
	ind	tttnak	enq is error
	ind	tttnak	eot is error
	dec	-2	itb is null int block
	dec	-1	dle is just the first data char here
	ind	tttnak	soh is error
*
*		state 3 - found soh
*
	dec	-3	text ok
	dec	-1	stx starts text
	ind	tttack	etx good end
	ind	tttack	etb good end
	ind	tttnak	enq is error
	ind	tttnak	eot is error
	ind	tttnak	itb is error
	dec	-3	dle is data
	ind	tttnak	soh is error
	eject
*
*	state transition table for non-transparent ascii
*
sttnta	null
*
*		state 0 - looking at start of message
*
	ind	tttnak	text char is error
	ind	tttsp1	stx - zero lrc and go to state 1
	ind	tttnak	etx is error
	ind	tttnak	etb is error
	ind	tttenq	enq
	ind	ttteot	eot
	ind	tttnak	itb is error
	ind	tttnak	dle is error
	ind	tttnak	soh is error
*
*		state 1 - found stx
*
	dec	-1	text char ok
	ind	tttnak	stx is error
	dec	-2	etx - go to state 2
	dec	-2	etb - go to state 2
	ind	tttenq	enq
	ind	ttteot	eot
	dec	-3	itb - go to state 3
	dec	-1	dle is got text
	ind	tttnak	soh is error
*
*		state 2 - check lrc after etx or etb
*
	ind	tttsp2	check char and go to tttack
	ind	tttsp2
	ind	tttsp2
	ind	tttsp2
	ind	tttsp2
	ind	tttsp2
	ind	tttsp2
	ind	tttsp2
	ind	tttsp2
*
*		state 3 -check lrc after itb
*
	ind	tttsp3	check lrc and goto state 4
	ind	tttsp3
	ind	tttsp3
	ind	tttsp3
	ind	tttsp3
	ind	tttsp3
	ind	tttsp3
	ind	tttsp3
	ind	tttsp3
*
*		state 4 - looking for stx after itb
*
	ind	tttnak	text is error
	ind	tttsp1	stx - reset lrc and goto 1
	ind	tttnak	etx is error
	ind	tttnak	etb is error
	ind	tttenq
	ind	ttteot
	ind	tttnak	itb is error
	ind	tttnak	dle is error
	ind	tttnak	soh is error
	eject
*	tables for recognizing interesting characters in
*	ascii or ebcdic data
*
gentb	macro	c,m
	org	*-64+#1
	crsm	save,off
	ife	'#2','',1
	vfd	18/tb.#1
	ine	'#2','',1
	vfd	18/tb.#2
	crsm	restore
	org	*-#1-1+64
	endm	gentb
	rem
tb.cha	equ	0	non-control character
tb.stx	equ	1
tb.etx	equ	2
tb.etb	equ	3
tb.enq	equ	4
tb.eot	equ	5
tb.itb	equ	6
tb.dle	equ	7
tb.soh	equ	8
	rem
atab	null		ascii table
	dup	1,64	start with 64 words of zero
	oct	0
	gentb	aenq,enq	and then fill in improtant chars
	gentb	aetb,etb
	gentb	aeot,eot
	gentb	soh
	gentb	stx
	gentb	etx
	gentb	dle
	gentb	itb
	rem
	rem
etab	null		ebcidc table
	dup	1,64	start with 64 words of zero
	oct	0
	gentb	eenq,enq	fill in interesting chars
	gentb	eetb,etb
	gentb	eeot,eot
	gentb	soh
	gentb	stx
	gentb	etx
	gentb	dle
	gentb	itb
	ttls	bisync options
	rem
*	the following word controls what the bisync read side will
*	do in a wait-acknowledgement situation. if "0", the block
*	just read will be accepted with a wack. if "1", the
*	block will be rejected with an nak.
	rem
wackcd	oct	0
	rem
*	the following equ defines how many times the write side
*	of this module will send enq to have a bad response
*	(or no response) repeated before giving up and sending an
*	eot.
	rem
enqlmt	equ	3
	rem
	end
