* ***********************************************************
* *                                                         *
* * Copyright, (C) Honeywell Information Systems Inc., 1982 *
* *                                                         *
* * Copyright (c) 1972 by Massachusetts Institute of        *
* * Technology and Honeywell Information Systems, Inc.      *
* *                                                         *
* ***********************************************************

	ttl	multics/fnp direct interface adapter -- dia_man
	lbl	,dia_man
	pmc	off
	pcc	on
	editp	on
	rem
*************************************************************
*
*  note:  cs means "central system"
*
*************************************************************
*
*		dia_man contains the code to control the direct interface
*		adapter (dia) in order to handle communications between
*		the fnp and multics. all such communications are transmitted
*		by means of "mailboxes" of eight (36-bit) words each
*		which are supplied by the cs.
*
*		dia activity is triggered by:
*			1) entries in the dia i/o request queues
*			   (placed there by the denq entry)
*
*			2) interrupts from the cs indicating that
*			   a mailbox is to be transmitted to the fnp
*
*		the two basic scenarios are as follows
*
*		1) fnp-initiated i/o
*
*		entry is placed in request queue by denq
*		(one queue for each line)
*		dgetwk (which is scheduled at completion of i/o cycle)
*		finds entry and builds large mailbox which it writes
*		into cs memory
*		cs responds either by "freeing" the mailbox
*		(interrupt level 12-15) or by rewriting it with new
*		information (interrupt level 8-11), in either case
*		causing an entry to be added to the mailbox queue;
*		dia_man reads the mailbox as described below, interprets
*		it and marks it free
*		queue entries are freed immediately upon sending of the mailbox
*		except in the case of input operations, which are freed
*		when the input has been accepted
*
*		2) cs-initiated i/o
*
*		cs sends interrupt to add entry to mailbox queue
*		when dgetwk finds mailbox queue non-empty, it calls
*		rdmbx to read the mailbox in from the cs
*		dia_man does whatever is indicated by the contents of the
*		mailbox, and when finished either writes a modified copy
*		of the mailbox back to the cs or just informs the cs
*		that the mailbox is free
*
*
*		during such a cycle as described above, a global
*		lock (the "dia lock") is locked so that there is no attempt
*		to process more than one mailbox at a time
*
*		a "transaction control word" is used to indicate the
*		current state of the dia i/o cycle in progress
*
*		two interrupt handlers are used:
*		dterm handles the interrupt that comes in at the com-
*		pletion of each i/o operation and schedules
*		the transaction processor (dtrans) to deal with the
*		results of the i/o
*
*		dmail handles the "mailbox ready" interrupt from the
*		cs and adds an entry to the mailbox queue
*
*		except when copying output buffers from the cs,
*		dcws for dia i/o are built starting at location "dcws"
*		in the "conect" subroutine
*
*		the address and length of the current dcw list are
*		also kept in "conect" so that if necessary the most
*		recent i/o can simply be restarted by calling conect
*		again
*
*
*		labelling conventions:
*
*		literals have names of the form l.xnnn
*		where "x" is a letter that varies from subroutine
*		to subroutine and "nnn" is a 3-digit number that starts
*		over for each new value of "x"
*
*		address constants have names of the form a.xnnn
*		where "x" and "nnn" are as above
*
*
*		coded August 1974 by Robert S. Coren
*		modified December 1975 by Jay Goldman
*		modified November 1978 by robert coren for fnp-initiated
*		   mailboxes.
*		modified 4th of July, 1979 by Bernard Greenberg
*		   for FNP echo negotiation
*		modified 1979 may by art beattie to support dn6670
*		   extended memory.
*		modified September 1984 by Robert Coren to zero block
*		   count when turning off oflow and to call hmode when
*		   setting flow control characters.
*		modified April 1985 by Robert Coren to include tfabf0
*		   and tfabf1 in "permanent" t.flg3 flags
*
*************************************************************
	
* HISTORY COMMENTS:
*  1) change(86-04-23,Coren), approve(86-04-23,MCR7300),
*     audit(86-05-19,Beattie), install(86-07-08,MR12.0-1089):
*     Modified November 1984 by Robert Coren to read echo negotiation break
*     table from CS.
*                                                      END HISTORY COMMENTS

	eject
	symdef	dia
	symdef	dterm
	symdef	dmail
	symdef	denq
	symdef	dindcw
	symdef	dicell
	symdef	dmbx
	symdef	derrq
	symdef	diajt
	symdef	dlist
	symdef	diconf
	symdef	ecgifl
	symdef	lctlck
	symdef	diasel	'sel' instruction in conect subroutine
	rem
	symref	mdisp
	symref	secdsp
	symref	dspqur
	symref	g3wjt
	symref	getbuf
	symref	getbfh
	symref	frebuf
	symref	frebfh
	symref	frelbf
	symref	getmem
	symref	fremem
	symref	gettib
	symref	globsw
	symref	iwrite
	symref	itest
	symref	loutav,houtav
	symref	invp
	symref	hmode
	symref	trace
	symref	ctrl
	symref	brkptr
	symref	shrcct	hsla_man subr to release cct
	symref	setptw	set page table word
	symref	setbpt	set buffer page table word
	symref	cvabs	convert buffer address to absolute
	symref	mvpgsc	move data paging source
	symref	mvpgtg	move data paging target
	symref	hcfg	hsla reconfigure subroutine
	symref	hunmsk	unmask subchannel
	symref	mincs
	symref	mincd
	symref	mupdat
	rem
	ttls	m a c r o s
	rem
jumptb	macro
	idrp	#1
jmps#1	zero
	tsy	ivp-*,*
	vfd	4/0,7/#1,1/0,6/mbxmod
	idrp
	endm
	rem
	rem
	rem
	rem
mpy	macro	(multiplier location-*)
	mpf	#1
	lrl	1
	endm
	rem
	rem
dvd	macro	(divisor location-*)
	qls	1
	dvf	#1
	endm
	rem
	pmc	save,on
	systm
	rem
	comreg
	rem
	tib
	rem
	sfcm	hsla
	rem
	meters
	rem
	devtab
	rem
	dlytbl
	rem
	buffer
	rem
	global
	rem
	hslatb
	rem
	csbits
	rem
	ttls	dia mailbox opcodes
	diaop
	rem
	alterp
	rem
	ttls	symbol definitions
	rem
	rem	transaction control word states
	rem
tcfrst	equ	0	first interrupt of session
tcdcwl	equ	1	dcw list was read
tcdata	equ	2	data was read
tcmbxr	equ	3	mailbox was read
tcwrd	equ	4	wrote data to cs
tcblst	equ	5	blast message was read
tcpchm	equ	6	reading data for patch_fnp order
tcdmpm	equ	7	writing data for dump_fnp order
tcinmb	equ	8	sent input in a mailbox
tcmetr	equ	9	sent metering information
tcrecn	equ	10	echo neg. table was read
tcreq	equ	11	sent mailbox request count
tcfree	equ	12	freed mailbox
tcwmbx	equ	13	wrote mailbox to cs
	rem
tcmax	equ	14	maximum value of tcword + 1
maxbuf	equ	20	maximum number of cs buffers
	rem
	rem
	rem	dia opcodes
	rem
diatrg	bool	65	transfer gate from cs to fnp
diadis	bool	70	disconnect
diainf	bool	71	interrupt fnp
diajmp	bool	72	jump
diainc	bool	73	interrupt cs
diardc	bool	74	read configuration switches
diaftc	bool	75	data transfer from fnp to cs
diactf	bool	76	 "      "      "   cs to fnp
diawrp	bool	77	wraparound
	rem
	rem
	rem
ntflsn	bool	/tflisn	for turning off listen flag
ntfacu	bool	/tfacu	for turning off acu flag
lnmask	bool	000700	lsla/hsla number in line number
submsk	bool	000077	subchannel number in line number
hslafl	bool	001000	hsla bit in line number
retry	bool	400000	flag for retrying i/o request
rejflg	bool	200000	flag indicating i/o request has been rejected
quitfl	bool	100000	flag indicating a quit or hangup is in queue
nretry	bool	/retry*/rejflg
ntfwrt	bool	/tfwrit
fatal	bool	777640	bits in status word indicating unrecoverable
	rem		error
maxerr	equ	5	maximum number of consecutive dia errors
maxcke	equ	2	maximum number of consecutive checksum errors
maxchn	equ	24	max number of buffers sent to cs by 1 dcw list
	rem
eb.tly	equ	2	position in echo buffer of tally (upper 9 bits)
	rem
qtib	equ	0	offset from tib entry of tib address
qbuf	equ	1	offset from tib entry of buffer address
	rem
dtprty	equ	0	priority for dtrans
gtprty	equ	1	priority for dgetwk
rtprty	equ	gtprty	priority for dretry
	rem
	rem
mqmask	bool	17	mask for mailbox queue address
mnmask	bool	37	mask for mailbox number in 3rd word
	rem		of jump table
	rem
	rem
	rem	parity for dcws
	rem
pupper	bool	040000	parity bit for bits 0-17
plower	bool	020000	parity bit for bits 18-35
npbits	bool	/pupper*/plower	both bits off
	rem
absflg	bool	400000	flag to indicate absolute addressing
	rem
	rem
	rem	cs mailbox header format
	rem	(36-bit offsets)
	rem
mh.pcw	equ	0	peripheral control word
mh.cnt	equ	mh.pcw+1	mailbox request count
mh.tim	equ	mh.cnt+1	terminate interrupt multiplex word (timw)
mh.oct	equ	mh.tim+1	old request count
mh.sub	equ	mh.pcw+8	submailbox area
mh.fsb	equ	mh.sub+64	start of FNP-controlled submailboxes
	rem
	rem
	rem	cs submailbox
	rem	(18-bit offsets)
	rem
sm.lno	equ	0	line number and fnp number
sm.fre	equ	sm.lno+1	number of free FNP buffers
sm.cdl	equ	sm.fre+1	command data length (in 6-bit chars)
sm.op	equ	sm.cdl+1	opcode and i/o command
sm.cd	equ	sm.op+1	command data (6 18-bit words)
sm.adr	equ	sm.cd+6	cs data address
sm.len	equ	sm.adr+1	data length
sm.cks	equ	sm.len+4	checksum
	rem
	rem	fields in fnp-controlled submailbox with
	rem	input-in-mailbox opcode
	rem
sm.ict	equ	sm.cdl	input character count
sm.dat	equ	sm.cd	input data
sm.fcd	equ	sm.dat+50	flags with input data
	rem
	rem	fields in fnp-controlled submailbox with
	rem	accept-input opcode
	rem
sm.nbf	equ	4	number of buffers in input chain
sm.dcw	equ	6	start of pseudo-dcw list
	rem
mbxmax	equ	2*sm.fcd-2*sm.dat
	rem
sm3msk	bool	700000	mask for fnp number
smlmsk	bool	001777	mask for line number
smomsk	bool	777000	mask for opcode
smcmsk	bool	000777	mask for i/o command
	rem
mbxsz	equ	16
fmbxsz	equ	56	size of fnp-controlled mailbox
	rem
ecbits	equ	256	number of useful bits in echo negotiation
	rem		break table
ecnlen	equ	ecbits/16	resulting length in words
	rem
bufinc	bool	003000	mask for flags showing amount by which
	rem		buffer tally has been adjusted
	rem
ttcolt	equ	19	line type for colts executive channel
	rem
trmmod	equ	2
mbxmod	equ	3
	rem
	rem
	rem	memory trace types
	rem
mt.trm	equ	1
mt.mbx	equ	2
mt.rmb	equ	3
mt.inq	equ	4
mt.wcd	equ	5
mt.ouq	equ	6
mt.inc	equ	7
mt.wmb	equ	8
mt.fre	equ	9
mt.wtx	equ	10
mt.rtx	equ	11
mt.alt	equ	12
mt.acu	equ	13
	rem
	rem	printer trace switches
	rem
tr.que	bool	002
tr.mbx	bool	004
tr.int	bool	010
	rem
ct.dev	equ	1	offset in control tables of array of
	rem		device table pointers
ct.wru	equ	4	offset in control tables of "wru" wait block
ct.dly	equ	5	offset in control tables of first delay table
ct.brk	equ	6	offset in control tables of send_break pointer
	rem
dia	null
	start	dia,2,c3mcsm0c0000
	pmc	restore
	rem
	ttls	dterm -- handles terminate interrupts from dia
	rem
	rem	this entry processes terminate interrupts.
	rem	it checks the status and if a recoverable
	rem	error occurred, it restarts the i/o.
	rem	if the i/o succeeded, it uses the transaction
	rem	control word (tcword) to see whether to schedule
	rem	the transaction processor or the "get-work" subroutine.
	rem
	rem
dterm	null
	rem
	rem		status should be 000001000000
	lda	stat-*	high-order word of status
	icmpa	1
	tnz	dte005-*
	szn	stat+1-*	is low-order word 0?
	tze	dte010-*	yes, all is well
dte005	null
	rem
	lda	errcnt-*	no, get error count
	als	1	double error count to use as an offset
	cax2
	ldaq	stat-*	store bad status in table
	staq	a.a011-*,*	(badsts,2)
	lda	errcnt-*	calc true count
	iaa	1
	sta	bdstct-*	number of consecutive io errors in table
	rem
	lda	stat+1-*	get right-hand word in a
	ana	l.a003-*	see if it's one of the restartable ones
	tze	2
	die	2	it wasn't, die
	rem
	lda	errcnt-*	get error count again
	icmpa	maxerr	reached maximum?
	tmi	2
	die	3	yes, that's all for you
	rem
	iaa	1	increment count
	sta	errcnt-*
	ilq	errmsg	queue an error message to tell cs
	ldx2	a.a007-*	addr(sterr), command data for error message
	tsy	a.a008-*,*	derrq
	rem
	smeter	mincs,.mdias,l.a004-*
	rem
	szn	iopend-*	did we have a connect pending?
	tze	2	no, don't reconnect
	tsy	a.a003-*,*	(conect) reconnect the i/o
	tra	a.a002-*,*	return to master dispatcher
	rem
	rem		i/o was all right
dte010	null
	stz	errcnt-*	start error count over
	szn	iopend-*	were we actually expecting something?
	tze	a.a002-*,*	(mdisp) no, ignore it
	stz	iopend-*	if we were, we have it now
	rem
	trace	mt.trm,tr.int,(a.a001-*(*))
	rem
	lda	a.a001-*,*	(tcword) get transaction control word
	tmi	dte020-*	it had better not be negative
	tze	dte040-*	if it's zero, nothing to do
	icmpa	tcmax	if it's over maximum
	tmi	2	  we die
dte020	die	4
	icmpa	tcinmb	did we write a mailbox with input?
	tze	a.a002-*,*	(mdisp) yes, don't do anything until we hear
	rem		more from multics
	rem
	icmpa	tcreq	one of the ones we have to act on?
	tpl	dte030-*	no, just go unlock
	rem		yes, schedule transaction processor
	ldaq	l.a002-*	priority and address of dtrans
	tsy	a.a004-*,*	dspqur
	tra	a.a002-*,*	back to master dispatcher
	rem
dte030	null		nothing to do, unlock dia and call gate
	tsy	a.a005-*,*	unlock
dte040	null
	tsy	a.a006-*,*	gate
	tra	a.a002-*,*	back to master dispatcher
	rem
	rem
	rem
a.a001	ind	tcword	transaction control word
a.a002	ind	mdisp	master dispatcher
a.a003	ind 	conect
a.a004	ind	dspqur	scheduling routine
a.a005	ind	unlock
a.a006	ind	gate
a.a007	ind	sterr
a.a008	ind	derrq
a.a009	ind	shinp	short input flag
a.a010	ind	mbxfre,3	for marking FNP mailboxes free
a.a011	ind	badsts,2	index into bad status table
	rem
	even
l.a001	oct	1,0	good status from dia
l.a002	zero	dtprty	priority and address for
	ind	dtrans	scheduling dtrans
l.a003	vfd	18/fatal	non-restartable dia errors
l.a004	dec	1
	rem
	rem
iopend	dec	1	indicates whether i/o is pending
	rem		but set to 1 so first call to gate will happen
	rem
	even
errcnt	oct	0	count of dia i/o errors
sterr	dec	2	command data for reporting dia error
stat	oct	1,0	place where dia status is to go
badsts	bss	12	bad status table
bdstct	oct	0	number of consecutive errors in table
	rem
	ttls	dmail -- handler for mailbox interrupt
	rem
	rem	this entry handles interrupt that comes in when
	rem	mailbox is read from cs
	rem
	rem	it queues the mailbox for later processing
	rem
dmail	null		get 3rd word of jump table
	tsy	a.b001-*,*	g3wjt
	rem		word is in q
	lls	11	shift mailbox number into a low
	iana	mnmask	mask out rest of word
	icmpa	12	is it to be read or just freed?
	tmi	dma010-*	read
	szn	a.a009-*,*	(shinp) is there short input pending?
	tze	dma010-*	no, deal with it later
	cax1		save mailbox number for trace
	iaa	-12	get mailbox # in range 0-3
	cax3		mark it free now
	lda	a.a010-*,*	mbxfre,3
	icmpa	inmbx	is this the one?
	tnz	dma012-*	no, free mailbox later
	rem		else do it now
	stz	a.a010-*,*	mbxfre,3
	stz	a.a009-*,*	zero the flag now
	ila	-1	and decrement mbx use count
	asa	a.b018-*,*	mbused
	ldaq	l.a002-*	scheduling stuff for dtrans
	tsy	a.a004-*,*	dspqur -- make sure transaction processor runs
	tra	dma020-*	done
dma010	null
	cax1		get mailbox no. into x1
dma012	tsy	upmbq-*	update the mailbox queue
	rem
	cx1a		get mailbox no. again
	icmpa	8	ours originally?
	tmi	dma020-*	no, done
	iaa	-8	get it in range 0-3
	cax3		yes, look at saved opcode
	lda	a.a010-*,*	mbxfre,3
	icmpa	inmbx	input in mailbox?
	tnz	dma020-*	no
	rem		yes, it must have been rejected
	szn	a.a009-*,*	(shinp) were we working on it now?
	tze	dma020-*	no, worry about it later
	stz	a.a009-*,*	yes, clear the flag now
	tsy	a.a005-*,*	(unlock) make sure mailbox gets read
	rem
dma020	null
	trace	mt.mbx,tr.int,(x1)
	tra	a.b002-*,*	return to master dispatcher
	rem
	rem
	rem	rpmbx is scheduled to cause reprocessing of a mailbox
	rem	because of lack of buffer space. to the rest of dia_man,
	rem	it will appear that an interrupt was received for the
	rem	mailbox and handled by dmail
	rem
	rem	mailbox number is in x1
	rem
rpmbx	null
	tsy	upmbq-*	update mailbox queue
	tra	a.b015-*,*	return to secondary dispatcher
	rem
	ttls	upmbq -- update mailbox queue
	rem
	rem	mailbox number to be added to queue of mailboxes to be
	rem	processed is passed in x1
	rem
upmbq	subr	upm,(inh,x1)
	rem
	ldx2	mbqnxa-*	get offset of next available slot
	lda	a.b014-*,*	in mailbox queue
	icmpa	-1	is it free?
	tnz	upm010-*	it had better be
	lda	mbqcnt-*	get count, which had better be <16
	icmpa	16
	tmi	upm020-*
upm010	die	1	mailbox queue overflowed
	rem
upm020	null
	aos	mbqcnt-*	increment queue count
	stx1	a.b014-*,*	store number in queue entry
	rem
	aos	mbqnxa-*	bump "next available" pointer
	ila	mqmask	make it mod 16
	ansa	mbqnxa-*
	rem
	tsy	a.b003-*,*	gate (to schedule dgetwk)
	return	upmbq
	rem
	ttls	rdmbx -- subroutine to read mailbox from cs
	rem
	rem	this subroutine is called by dgetwk when mailbox
	rem	queue count is non-zero in order to read a mailbox from
	rem	the cs. The number of the mailbox is picked up from the
	rem	"next-to-process" entry of the mailbox queue
	rem
	rem	the routine is entered with interrupts inhibited,
	rem	x1 points to saved copy of indicators for reenabling them
	rem
rdmbx	subr	rdm,(x2,x3)
	rem
	lda	mbqcnt-*	get mailbox queue count
	tnz	2	if it's zero,
	die	5	we screwed up somehow
	rem
	iaa	-1	decrement it
	sta	mbqcnt-*
	ldx2	mbqnxt-*	get pointer to next entry to process
	ldq	a.b014-*,*	pick up mailbox number
	ila	-1	and mark the entry as free
	sta	a.b014-*,*
	aos	mbqnxt-*	bump the "next-to-process" pointer
	ila	mqmask	force it mod 16
	ansa	mbqnxt-*
	cqa		get mailbox number
	tmi	rdm010-*	make sure it's in range of
	icmpa	16	0-15
	tmi	2
rdm010	die	6
	icmpa	12	mailbox to be read or just freed?
	tmi	rdm020-*	read
	iaa	-12	freed, get number to be 0-3
	cax3		to use as index to freed words
	stz	a.b016-*,*	mbxfre,3
	ila	-1	and decrement mbx use count
	asa	a.b018-*,*	mbused
	ldi	0,1	****enable interrupts now
	ila	tcfree	set tcword to "freed mailbox"
	sta	a.b012-*,*	tcword
	rem
	tsy	a.b017-*,*	unlock
	tsy	a.b003-*,*	(gate) make sure dgtwrk runs
	tra	rdmbak-*	done
rdm020	null		we are to read mailbox
	rem		save mailbox number
	sta	a.b008-*,*	mbxno
	icmpa	8	fnp's or cs's?
	tmi	rdm030-*	his
	iaa	-8	ours, make it 0 to 3
	mpy	l.b001-*	(fmbxsz/2) get size
	iaq	mh.fsb	and correct offset
	stq	mbxadr-*
	ila	fmbxsz/2	size again
	sta	rdsize-*	save it for later
	tra	rdm040-*
rdm030	null
	als	3	multiply mbx no by 8 for addressing
	iaa	mh.sub	get full offset in mailbox area
	sta	mbxadr-*	save it
	ila	8	get correct size for cs-controlled mailbox
	sta	rdsize-*
rdm040	null
	rem
	ldi	0,1	****enable interrupts
	stz	a.b004-*,*	count of consecutive checksum errors
	rem
	trace	mt.rmb,tr.mbx,(a.b008-*(*))
	rem
	rem		now set up dcw list to read the mailbox
	rem
	ldx3	a.b005-*	get address of dcw area
	lda	a.b007-*,*	(csmbx) get cs mailbox header addr
	ada	mbxadr-*	add mailbox offset
	ilq	diactf	get cs -> fnp opcode
	staq	0,3
	rem
	ldq	rdsize-*	tally for reading mailbox
	lda	a.b006-*	addr(savmbx), w.2
	staq	2,3
	rem
	rem		save dcw list address for conect subroutine
	stx3	a.b009-*,*	dcwadr
	iacx3	4	point to next place for dcw
	tsy	a.b011-*,*	(bdisc) set up disconnect dcw
	rem		save tally for conect subroutine
	ila	4
	sta	a.b010-*,*	dcwlen
	rem
	rem		dcws are all set up
	rem		set transaction control word
	rem		to "mailbox read"
	rem
	ila	tcmbxr
	sta	a.b012-*,*	tcword
	rem
	tsy	a.b013-*,*	conect
rdmbak	return	rdmbx
	eject
a.b001	ind	g3wjt	get 3rd word of jump table
a.b002	ind	mdisp	master dispatcher
a.b003	ind	gate
a.b004	ind	ckecnt	count of consecutive checksum errors
a.b005	ind	dcws	static dcw list
a.b006	zero	savmbx,w.2	fnp's copy of last-read mailbox
a.b007	ind	csmbx	cs address of mailbox header
a.b008	ind	mbxno	mailbox number
a.b009	ind	dcwadr	conect's address of dcw list
a.b010	ind	dcwlen	conect's dcw tally
a.b011	ind	bdisc	subroutine to build a disconnect dcw
a.b012	ind	tcword	transaction control word
a.b013	ind	conect	subroutine to connect to dia
a.b014	ind	mbqhed,2	for accessing mailbox queue entries
a.b015	ind	secdsp	secondary dispatcher
a.b016	ind	mbxfre,3
a.b017	ind	unlock
a.b018	ind	mbused
	rem
	rem
l.b001	zero	fmbxsz/2
	rem
	rem
rdsize	bss	1	size of this mailbox in 36-bit words
dmsvi	bss	1	place to save indicators
mbxadr	bss	1	offset for cs address of mailbox
mbqcnt	oct	0	mailbox queue count
mbqnxa	oct	0	next available entry in mailbox queue
mbqnxt	oct	0	next entry in mailbox queue to process
	rem
	rem
	base	16
	rem		mailbox queue
mbqhed	dec	-1,-1,-1,-1,-1,-1,-1,-1
	dec	-1,-1,-1,-1,-1,-1,-1,-1
	rem
	ttls	gate -- subroutine to schedule dgetwk
	rem
	rem	subroutine called when a task is completed to make
	rem	sure that dgetwk gets scheduled. dgetwk will figure
	rem	out if there's more work to do
	rem
	rem	if dgetwk is already scheduled, we won't bother
	rem
gate	subr	gat,(inh,a,q)
	rem
	szn	gqued-*	see if it's already queued
	tnz	gatbak-*	it is, just return
	rem
	aos	gqued-*	else mark it queued now
	ldaq	l.c001-*	get dgetwk's priority and address
	tsy	a.c001-*,*	(dspqur) and schedule it
	rem
gatbak	return	gate
	rem
	ttls	dgetwk -- reads or requests a mailbox
	rem
	rem	this routine is scheduled by gate to find out
	rem	if there's anything to do
	rem	(more mailboxes to read or request)
	rem
	rem	if the dia lock is locked we will do nothing
	rem
	rem
dgetwk	null
	sti	dgsvi-*	hold on to indicators
	inh		****inhibit interrupts
	rem
	smeter	mupdat,.mimbx,mbused-* good time to update this
	rem
	stz	gqued-*	turn off "dgetwk queued" flag
	szn	a.c002-*,*	(=dilock) is dia already locked?
	tnz	dgebak-*	if it is, return
	tsy	a.c003-*,*	(=lock) else, lock it
	rem
	szn	a.c014-*,*	(mbqcnt) any mailboxes waiting to be read?
	tze	dge005-*	no, don't bother
	ldx1	a.c016-*	(dgsvi) get address of where indicators are stored
	tsy	a.c015-*,*	(rdmbx) go read the mailbox
	tra	a.c018-*,*	and return to secondary dispatcher
	rem
dge005	szn	qcnt-*	anything in the queue?
	tze	dge030-*	no, nothing to do
	ldx3	a.c019-*	addr (mbxfre)
	ila	-4	check if any are free
dge010	szn	0,3	this one?
	tze	dge020-*	yes
	iaa	1	no, are there more?
	tze	dge030-*	no, we'll have to deal with it later
	iacx3	1	look at next
	tra	dge010-*
	rem
dge020	aos	mbused-*	keep count of mailboxes in use
	iaa	12	make it in range 8-11
	sta	a.c020-*,*	mbxno
	ldx3	a.c022-*	addr (savmbx)
	tsy	a.c021-*,*	filmbx
	tra	dgebak-*	all done
	rem		if we come here, nothing to do
dge030	null		so just clear dia lock and return
	tsy	a.c017-*,*	unlock
	rem
dgebak	null
	ldi	dgsvi-*	****restore indicators (to enable)
	tra	a.c018-*,*	return to secondary dispatcher
	rem
	rem
	rem
a.c001	ind	dspqur	scheduling routine
a.c002	ind	dilock	dia lock
a.c003	ind	lock	locking subroutine
a.c004	ind	tcword	transaction control word
a.c006	ind	dcws	static area for building dcw list
a.c007	ind	dcwadr	address of dcw list (for conect)
a.c008	ind	dcwlen	length of dcw list (36-bit words)
*a.c009	unused
a.c010	ind	csmbx	cs mailbox header address
a.c011	ind 	bint	subroutine to build interrupt dcw
a.c012	ind	bdisc	subroutine to build disconnect dcw
a.c013	ind	conect	subroutine to do connect to dia
a.c014	ind	mbqcnt	mailbox queue count
a.c015	ind	rdmbx	subroutine to read a mailbox from cs
a.c016	ind	dgsvi	saved indicators (to pass to rdmbx)
a.c017	ind	unlock	unlocking subroutine
a.c018	ind	secdsp	secondary dispatcher
a.c019	ind	mbxfre
a.c020	ind	mbxno
a.c021	ind 	filmbx
a.c022	ind	savmbx	mailbox save area
	rem
l.c002	oct	004000	for masking overflow
	even
l.c001	zero	gtprty	priority and address
	ind	dgetwk	for scheduling dgetwk
	rem
	even
qcnt	oct	0
mbxfre	bss	4	words marked to show fnp mailboxes in use
mbused	oct	0	number of inbound mailboxes now in use
gqued	oct	0	"dgetwk is queued" flag
dgsvi	bss	1	place to save indicators
	rem
	ttls	denq -- subroutine to add entry to dia i/o queue
	rem
	rem	this subroutine is called from outside dia_man
	rem	to queue a request for dia i/o.
	rem
	rem	separate queues are maintained for each
	rem	line; a list of tibs and queue pointers is maintained
	rem	for finding the queue for each line.
	rem
	rem	we will update the mailbox request count as long as
	rem	there are no "accept input" requests already
	rem	on the queue for this line; but there may never be more
	rem	than one mailbox request outstanding for an "accept input"
	rem	opcode for any line.
	rem
	rem	if a quit or a hangup is queued, and there is a
	rem	rejected "accept input" at the head of
	rem	the queue, all accept inputs are cleansed from the queue
	rem	to ensure that the quit or hangup gets sent.
	rem
	rem	at entry:
	rem
	rem	q: opcode to be put in mailbox
	rem	x1: virtual tib address
	rem
	rem	the opcode is stored in queue element
	rem
	rem	queue consists of chained buffers, each pointing
	rem	to next buffer
	rem	elements are processed first in, first out
	rem
denq	subr	den,(a,q,x2,x3)
	stz	noai-*	initialize
	lda	t.line,1	save line number for trace
	sta	a.d013-*,*	(curqln)
	cx1a		need real tib address in a
	ldx2	t.sfcm,1	assume this is an hsla tib
	ldx2	sf.hsl,2	get hsla table entry for this channel
	lda	ht.tib,2	this is the real tib address
	rem
den010	null
	tsy	a.d006-*,*	getque
	rem		address of this tib's entry in list is in x2
	lda	densq-*	is this to mask the line?
	icmpa	linmsk
	tnz	den030-*	no, proceed normally
	ilq	0	initialize q decrement
	tsy	a.d007-*,*	(getqai) any accept inputs in queue?
	tra	den020-*	no, queue linmsk now
	lda	0,2	yes, look at first one
	ana	l.d009-*	(retry+rejflg) see if it's active
	cmpa	l.d010-*	(retry only)
	tze	denbak-*	it is, do the rest when it finishes
	ilq	1	otherwise, it's counted in the queue
den020	tsy	a.d001-*,*	(qmask) empty the queue and add linmsk
	adq	a.d011-*,*	(nnonai) now have total number removed
	stq	dendec-*	that had been counted in qcnt
	lda	a.d009-*,*	(qcnt)
	sba	dendec-*	decrement the count accordingly
	sta	a.d009-*,*
	tra	denbak-*	finished now
	rem
den030	tsy	a.d007-*,*	(getqai) find first accept input in queue
	tra	den060-*	none, so must update request count
	tra	den070-*	adding entry after a previous accept input
	rem		so no need to update request count
	rem
den060	null		add one to queue entry count
	aos	noai-*	there's no accept input now
	aos	a.d009-*,*	(qcnt)
	tsy	a.d003-*,*	(gate) make sure dgetwk gets scheduled
	rem		to process queue
den070	ldx2	densx2-*	get pointer to data
	ldq	densq-*	and origional opcode
	tsy	a.d010-*,*	(adqent) update queue
	rem
	cqa		get opcode in a
	icmpa	accin	is opcode "accept input"?
	tnz	den140-*
	ila	1	get double-precision 1
	lrl	18
	szn	noai-*	first accept input for this line?
	tnz	den080-*	yes
	adaq	prevai-*	no, meter presence of previous one
	staq	prevai-*
	tra	den090-*
den080	adaq	nprvai-*	meter addition of accept input without one already
	staq	nprvai-*
den090	ldq	t.icp,1	get pointer to head of chain
	tnz	2	(which must exist)
	die	19
	rem
	lda	t.dlst,1	get last buffer of previous chain
	tze	den120-*	if any
	tsy	a.d014-*,*	setbpt
	cax3		get virtual address
	rem		hook new chain onto
	stq	bf.nxt,3	previous one
	tra	den130-*
den120	null
	rem		no old chain, set up new chain pointer
	stq	t.dcp,1
den130	null
	cqa		get t.icp back
den131	tsy	a.d014-*,*	(setbpt) convert it
	cax3
	stz	denbuf-*	init buffer count
	stz	accum-*	start counter
den132	lda	bf.siz,3	count the number of 32-word blocks
	arl	15	get size code in low-order 3 bits
	iaa	1
	asa	t.dcpl,1	save length of t.dcp chain
	szn	bf.nxt,3	is this last buffer in chain?
	tze	den135-*	yes, go mark it
	lda	bf.flg,3	is this the end of a message?
	cana	l.d001-*	=bfflst
	tnz	den133-*	yes, break chain here
	lda	bf.tly,3	no, increment running tally
	ana	l.d007-*	=buftmk
	ada	accum-*	new result
	cmpa	l.d008-*	more than max chain length?
	tpl	den133-*	yes
	sta	accum-*	no, save new running tally
	lda	denbuf-*	get buffer count
	iaa	1	increment
	icmpa	maxchn	more than max number of buffers ?
	tpl	den133-*	yes
	sta	denbuf-*	save new buffer count
	lda	bf.nxt,3	and check next
	tsy	a.d014-*,*	setbpt
	cax3
	tra	den132-*
	rem
den133	ldx2	densx2-*	put another accept input in queue
	ldq	densq-*
	tsy	a.d010-*,*	(=adqent)
	rem
den135	lda	l.d001-*	=bfflst
	orsa	bf.flg,3	mark buffer as last in request
	lda	bf.nxt,3	are there more?
	tnz	den131-*	yes, start counting again
	cx3a		get absolute address to save
	tsy	a.d015-*,*	cvabs
	sta	t.dlst,1	else mark end of chain
	rem
	stz	t.icp,1	zero out tib fields so lsla_man or
	stz	t.ilst,1	hsla_man can start new chain
	stz	t.icpl,1
	lda	l.d012-*	tfinq
	orsa	t.flg3,1	inproc may add characters to t.dcp chain 
	tra	denbak-*	all done
	rem
den140	null		is it quit or hangup?
	icmpa	brkcon	check for quit
	tze	den150-*	yup
	icmpa	lindis	no, check for hangup
	tnz	denbak-*	none of above, we're all done
den150	null		we must cleanse any accept inputs from the queue
	stz	t.scll,1	turn off echo negotiation
	tsy	a.d007-*,*	(getqai) are there any?
	tra	denbak-*	no, forget it
	lda	0,2	yes, has it been rejected?
	cana	l.d005-*	=rejflg
	tnz	den160-*
	ora	l.d006-*	(=quitfl) if not, mark there's a quit
	sta	0,2	behind it in case it does get rejected
	tra	denbak-*
	rem
den160	null		cleanse the queue
	tsy	a.d008-*,*	cleanq
	rem
denbak	return	denq
	rem
denbuf	bss	1
noai	bss	1
	even
prevai	bss	2	count of accept inputs when one already
			present for the same channel
nprvai	bss	2	count of accept inputs added to queue
			without one already present
	ttls	deque -- remove an accept input from an i/o queue
	rem
	rem	the first item in the relevant line's i/o queue
	rem	must be an "accept input"; it will be removed from the
	rem	queue, and the mailbox request count will be updated
	rem
	rem	x1: virtual tib address
	rem
deque	subr	deq,(a,q,x1,x2,x3)
	rem
	lda	a.n001-*,*	(tibadr) get real tib address
	tsy	a.d006-*,*	(getque)
	rem		x2 -> tib table entry
	tsy	a.d007-*,*	(=getqai) find first accept input
	die	16	none is fatal
	szn	a.d011-*,*	(=nnonai) be sure no other entries before accin
	tze	2	ok
	die	16
	rem
	tsy	a.d012-*,*	(dlqent) free accept input entry
	rem
	lda	t.flg3,1	is the channel masked?
	cana	l.d011-*	tfmask
	tze	deq005-*	no, proceed
	tsy	a.d001-*,*	(qmask) now is the time to empty the queue
	tra	deqbak-*	that's it
	rem
deq005	tsy	a.d007-*,*	(=getqai) find first accin in new queue
	tra	deq010-*	none
	lda	l.d012-*	tfinq
	orsa	t.flg3,1	it's okay to add to existing t.dcp chain
	ila	1	must add 1 to req cnt for accin
	tra	2
deq010	ila	0
	ada	a.d011-*,*	(=nnonai) add in entries before  accin
	tze	deqbak-*	no requests in queue, return
	asa	a.d009-*,*	qcnt
	rem
deqbak	null		all done
	return	deque
	ttls	dretry -- scheduled to retry accept input
	rem
	rem	this entry is scheduled if an attempt to send
	rem	input to the cs was rejected for lack of
	rem	buffer space. it turns off the "rejected" flag
	rem	in the first "accept input" entry for the tib
	rem	pointed to by x1, and puts out a request for one mailbox
	rem
	rem	if there is no rejected request queued for this
	rem	line, we will do nothing
	rem
	rem	x1 - real tib address
	rem
dretry	null
	rem
	cx1a		need real tib address in a
	tsy	a.d006-*,*	getque
	tsy	a.d007-*,*	(=getqai) find first accept input
	tra	drebak-*	none, return
	lda	0,2	pick up queue entry
	cana	l.d005-*	(=rejflg) has it been rejected?
	tze	drebak-*	no, queue must have been cleaned
	rem		we have one
	lda	l.d004-*	=nretry
	ansa	0,2	zero "retry" flag
	aos	a.d009-*,*	(qcnt) add one to count of queue entries
	tsy	a.d003-*,*	(gate) schedule dgetwk
drebak	tra	a.d005-*,*	return to secondary dispatcher
	rem
	rem
a.d001	ind	qmask	subr that clears queue and adds linmsk
a.d003	ind	gate
a.d005	ind	secdsp	secondary dispatcher
a.d006	ind	getque	subroutine to find entry in tib queue list
a.d007	ind	getqai	subr thats finds first accin in queue
a.d008	ind	cleanq	cleans accept inputs out of queue
a.d009	ind	qcnt	 count of pending queue entries
a.d010	ind	adqent	subr that adds entry to end of queue
a.d011	ind	nnonai	counter set by getqai subr that indicates
	rem		the number of entries before the first accin
a.d012	ind	dlqent	subr that deletes entry from the queue
a.d013	ind	curqln	line number for trace
a.d014	ind	setbpt
a.d015	ind	cvabs
	rem
	rem
l.d001	vfd	18/bfflst
l.d002	oct	37	for checking 0 mod 32
l.d003	oct	004000	inhibit overflow indicator
l.d004	vfd	18/nretry
l.d005	vfd	18/rejflg
l.d006	vfd	18/quitfl
l.d007	vfd	18/buftmk
l.d008	dec	2048	arbitrary maximum chain length
l.d009	vfd	o18/retry+rejflg
l.d010	vfd	18/retry
l.d011	vfd	18/tfmask
l.d012	vfd	18/tfinq
	rem
	rem
dendec	bss	1	amount by which to decrement qcnt if masking
accum	bss	1	running length of chain in characters
	rem
	ttls	derrq -- subroutine to add entry to error message queue
	rem
	rem	this subroutine adds an entry to a special i/o
	rem	queue for error messages. each entry contains an
	rem	opcode and 4 words (72 bits) of command data to be
	rem	passed to the cs
	rem	queue is allocated in buffers of which second word is zero,
	rem	leaving room for 6 five-word entries
	rem
	rem	because this routine can be called at interrupt
	rem	time, it must save and restore the variables used
	rem	to describe the current request queue
	rem
	rem	at entry:
	rem
	rem	q: opcode
	rem	x2: address of command data
	rem
derrq	subr	der,(inh,a,q,x2,x3)
	rem
	lda	a.n005-*,*	=curque
	ldq	a.d013-*,*	=curqln
	staq	tcurq-*	save these in temporary
	lda	a.n009-*,*	=curqbf
	sta	tcurbf-*	this too
	rem
	stz	a.d013-*,*	=curqln, zero line number
	lda	a.n004-*	get address of simulated tib table entry
	sta	a.n005-*,*	(curque)
	rem
	ldq	dersq-*	restore opcode to q
	adq	l.n002-*	(=004000) indicate 4 words of data
	tsy	a.d010-*,*	(adqent) add entry to error queue
	aos	a.n002-*,*	qcnt
	rem		now restore common values
	ldaq	tcurq-*
	sta	a.n005-*,*	=curque
	stq	a.d013-*,*	=curqln
	lda	tcurbf-*
	sta	a.n009-*,*	=curqbf
	return	derrq
	rem
	rem
a.n001	ind	tibadr
a.n002	ind	qcnt
a.n003	ind	fremem
a.n004	ind	errqtb
a.n005	ind	curque
a.n006	ind	pchbuf
a.n007	ind	pchadr
a.n008	ind	pchlen
a.n009	ind	curqbf
a.n010	ind	tcword
	rem
l.n002	oct	004000
	rem
*	the following two words simuulate a tib table entry for
*	the dia error queue. the first word corresponds to the
*	tib address word, but is not used here. the second word
*	points to the first buffer in the queue.
	rem
errqtb	oct	0
errqbf	oct	0
	even
tcurq	bss	1	temporary for saving curque
tcurln	bss	1	likewise for curqln
tcurbf	bss	1	likewise for curqbf
	rem
tcword	oct	0	transaction control word
	ttls	dtrans -- transaction processor
	rem
	rem	this subroutine is scheduled after dia i/o is finished
	rem	in order to process the results of the i/o
	rem
	rem	the transaction control word  (tcword)
	rem	indicates what was just done
	rem
	rem	dia lock is locked at entry
	rem
dtrans	null
	lda	a.n010-*,*	(tcword) get transaction control word
	tze	dtr100-*	do nothing if it's zero
	icmpa	tcreq	is its value one that requires action?
	tpl	dtr100-*	no, go away
	rem
	lda	a.n001-*,*	(tibadr) get real address of relevant tib
	tsy	a.e019-*,*	(setptw) virtualize it
	cax1		need it in x1
	rem
	lda	tcword-*	get tcword back in a
	icmpa	tcdcwl	did we read dcw list?
	tnz	dtr010-*	if not, try something else
	rem		if so, set up dcw list to read the data
	tsy	a.e001-*,*	(rddata)
	tra	dtr200-*	error return (buffer allocation failed)
	ila	tcdata	reset transaction control word
	sta	tcword-*	to "read data"
	tsy	a.e002-*,*	(conect) do the connect
	tra	a.e003-*,*	return to secondary dispatcher
	rem
dtr010	null
	icmpa	tcdata	did we read data?
	tnz	dtr050-*	if not, try something else
	stz	bflag-*	indicate not blast write
	tsy	write-*	set up chains and notify control tables
	rem
	rem
	szn	sndflg-*	immediate send output response?
	tze	dtr090-*	no, just free mailbox and return
	ldx3	a.e033-*	addr (savmbx)
	aos	sm.cd,3	turn on send output flag in mbx
	cx3a
	tsy	a.e034-*,*	(wmbx) write mailbox back
	tra	a.e003-*,*	(secdsp) and done
	rem
dtr050	null
	icmpa	tcmbxr	did we read a mailbox?
	tnz	dtr060-*
	tsy	a.e014-*,*	(decmbx) yes, go decode it
	tra	a.e003-*,*	that's all
	rem
dtr060	null
	icmpa	tcblst	did we read blast message?
	tnz	dtr080-*
	ldx3	blbuf-*	yes, get buffer address
	rem
	iacx3	2*bufsiz	save address of second buffer
	stx3	blbuf2-*
	aos	bflag-*	so write will know this is blast
	rem
	ldx2	a.e029-*,*	.crttb
	rem		start scanning all tibs
dtr065	null
	lda	qtib,2	this is the real tib address
	tsy	a.e019-*,*	(setptw) virtualize it
	cax1		put in x1
	lda	t.stat,1	find out if it's dialed up
	ana	l.e010-*	tsfcd+tsfdsr
	cmpa	l.e010-*	carrier and dsr both on?
	tnz	dtr075-*	not dialed up, look at next
	rem
	lda	t.type,1	get line type
	icmpa	8	tn1200 on 202c?
	tze	dtr070-*	yes, treat like ascii
	icmpa	5	regular terminal type (1-4)?
	tpl	dtr075-*	no, look at next tib
	icmpa	2	is it ibm-type?
	tze	dtr068-*	it's 1050
	icmpa	3	if not, 2741?
	tnz	dtr070-*	no
dtr068	ldx3	blbuf2-*	yes, point to ebcdic buffer
	ila	1	set ebcdic indicator
	tra	dtr072-*
	rem
dtr070	ldx3	blbuf-*	ascii, point to ascii buffer
	ila	0	set ascii indicator
dtr072	tsy	gblast-*	allocate output buffers
	tsy	write-*	update output chain, tell control tables
	rem
dtr075	iacx2	2	look at next entry in tib list
	cmpx2	a.e030-*,*	(.crtte) reached end?
	tnz	dtr065-*	no, look at next tib
	ilq	6*bufsiz	yes, free message buffers
	ldx3	blbuf-*
	tsy	a.e024-*,*	(frebuf)
	rem
	tra	dtr090-*	free mailbox and return
	rem
dtr080	icmpa	tcpchm	patching memory?
	tnz	dtr084-*	no
	ldx2	a.n006-*,*	(pchbuf) yes. address of buffer
	ldx3	a.n007-*,*	(pchadr) address to patch
	ldq	a.n008-*,*	(pchlen) length of patch
	tsy	a.e018-*,*	(mvpgtg) move the patch into place
dtr083	null		release buffer
	ldx3	a.n006-*,*	(pchbuf) memory space to free
	ldq	a.n008-*,*	(pchlen) length of memory space
	tsy	a.n003-*,*	(fremem)
	tsy	a.e009-*,*	(gate) make sure dgetwk runs
	tra	dtr100-*	and done
	rem
dtr084	icmpa	tcdmpm	dumping memory?
	tze	dtr083-*	yes. release temp memory space
	rem
dtr085	icmpa	tcinmb	wrote data in mailbox?
	tnz	dtr089-*	no
	lda	t.dcp,1	yes, must take buffers off chain now
	ldx3	t.dcp,1	for call to frelbf
	stz	dnblks-*	initialize count
dtr086	tsy	a.e037-*,*	setbpt
	cax2		get virutal address in x2
	lda	bf.siz,2	get buffer size
	arl	15	in 32-word blocks
	iaa	1
	asa	dnblks-*	update count
	lda	bf.flg,2	this the last one?
	cana	l.e005-*	bfflst
	tnz	dtr088-*	yes
	lda	bf.nxt,2	look at next
	tnz	dtr086-*
dtr088	ldq	dnblks-*	get block count
	tsy	a.e017-*,*	(instrp) take them off t.dcp chain
	cx3a
	tsy	a.e005-*,*	(frelbf)
	tsy	a.e016-*,*	(deque) remove accin from queue now
	ila	tcfree	set transaction control word to indicate
	sta	tcword-*	end of transaction
	tsy	a.e009-*,*	(gate) make sure dgetwk runs
	tra	dtr100-*	done with transaction
	rem
dtr089	icmpa	tcmetr	sent metering info?
	tnz	dtr110-*
	ldx3	a.e035-*,*	(gmebuf) get address of temporary buffer
	ldq	a.e036-*,*	(gmesiz)
	tsy	a.n003-*,*	(fremem) we're through with it now
	tra	dtr090-*	free mailbox and return
	rem
dtr090	null		free mailbox and return
	tsy	a.e013-*,*	frembx
	tra	a.e003-*,*	and return to secondary dispatcher
	rem
dtr100	null		nothing to do, unlock dia lock
	tsy	a.e023-*,*	unlock
	tra	a.e003-*,*	return to secondary dispatcher
	rem
dtr110	icmpa	tcrecn	did we read echo negotiation table?
	tnz	dtr150-*	no
	ldx2	a.e020-*	(addr (pdcws)) point to the table
	tsy	a.e021-*,*	makecn
	tra	dtr090-*	free mailbox and return
	rem
dtr150	null		by default, we wrote data to cs
	rem		free buffer chain that was sent
	lda	a.e015-*,*	oldhed
	tsy	a.e005-*,*	frelbf
	tsy	a.e016-*,*	(deque) remove accin from queue now
	tsy	a.e009-*,*	(gate) make sure dgetwk runs
	tra	dtr100-*	unlock & return
	rem
	rem
dtr200	null		attempt to allocate output buffers failed
	rem		we will schedule rpmbx to reprocess the
	rem		mailbox after 6 seconds
	ldx1	a.e027-*,*	mbxno
	ldaq	l.e008-*	time, priority, and address of rpmbx
	tsy	a.e028-*,*	dspqur
	ila	tcmax	set transaction control word to illegal value
	sta	tcword-*
	tra	dtr100-*
	ttls	write -- subroutine to set up for sending output
write	subr	wri,(x2)
	stz	sndflg-*
	lda	t.flg3,1	is this for a line that's been masked?
	cana	l.e013-*	tfmask
	tze	wri003-*	no, proceed
	szn	bflag-*	for blast message?
	tnz	wribak-*	yes, done
	lda	a.e007-*,*	(rhead) else free the buffer chain now
	tsy	a.e005-*,*	(frelbf) since we certainly can't use it
	tra	wribak-*
	rem
wri003	lda	l.e001-*	=tfwrit
	cana	t.flg,1	output in progress?
	tze	wri005-*	no, check t.ocp chain
	lda	t.flg2,1	else see if it's in block acknowledge
	ana	l.e009-*	=tfblak+tfofc
	cmpa	l.e009-*	both on?
	tze	wri005-*	yes, don't chain to t.ocur
	lda	t.echo,1	else check if there's pending echoing
	tze	wri040-*	obviously not, chain new stuff on
	tsy	a.e037-*,*	setbpt
	cax2
	lda	eb.tly,2	there's an echo buffer, anything in it?
	arl	9	isolate tally
	tze	wri040-*	no, chain new stuff on
wri005	null		else check current chain pointer
	lda	t.ocp,1	load the pointer
	tnz	wri010-*	already there, must chain on here too
	rem		none, just set ptr
	lda	a.e007-*,*	=rhead (set by rddata)
	sta	t.ocp,1	new output chain
	tra	wri030-*	skip out
	rem
wri010	tsy	a.e037-*,*	setbpt
	cax2
	szn	bf.nxt,2	any forward ptr this block?
	tze	wri020-*	no, chain in here
	lda	bf.nxt,2	chain to next block
	tra	wri010-*	loop
	rem
wri020	null
	cmeter	mincs,m.over,l.e012-*
	rem
	lda	a.e007-*,*	(=rhead) get head of new chain
	sta	bf.nxt,2	reset forward ptr in block
	rem
wri030	null		call "write" entry of control table interpreter
	tsy	a.e010-*,*	iwrite
	tra	wribak-*
	rem
wri040	null		write is in progress
	szn	t.ocur,1	make sure there's a real live chain
	tnz	2
	die	20	there had better be
	rem
	cmeter	mincs,m.over,l.e012-*
	rem		hook new output chain onto active chain
	lda	t.olst,1	get old last buffer
	tsy	a.e037-*,*	setbpt
	cax2
	lda	a.e007-*,*	=rhead (head of new data)
	sta	bf.nxt,2	attach new chain
	lda	a.e008-*,*	=rtail
	sta	t.olst,1	update "last buffer"
	rem		update output chain buffer count
	lda	a.e025-*,*	ndcws (same as number of new buffers)
	asa	t.ocnt,1
	szn	bflag-*	is this for blast?
	tnz	wri050-*	yes, don't check for threshold
	ila	bufthr	is count over threshold now?
	cmpa	t.ocnt,1
	tmi	wri050-*	yes, it's all right
	aos	sndflg-*	no, ask for more output
	rem
wri050	null
	lda	t.type,1	is this colts executive channel?
	icmpa	ttcolt
	tze	wribak-*	yes, don't call anybody
	lda	t.line,1	get line number to find out if it's
	rem		hsla or lsla
	cana	l.e002-*	=hslafl
	rem		call relevant "output available" entry
	tnz	wri060-*
	tsy	a.e011-*,*	loutav
	tra	wribak-*
wri060	tsy	a.e012-*,*	houtav
wribak	return	write
	ttls	storage for dtrans and write
	rem
a.e001	ind	rddata	subroutine to set up dcw lists to read data
a.e002	ind	conect
a.e003	ind	secdsp	secondary dispatcher
a.e004	ind	dcwadr	address of last-used dcw list
a.e005	ind	frelbf	subroutine to free a linked list of input buffers
a.e007	ind	rhead	head of buffer chain allocated by rddata
a.e008	ind	rtail	tail "     "     "       "      "    "
a.e009	ind	gate
a.e010	ind	iwrite
a.e011	ind	loutav	lsla "output available" subroutine
a.e012	ind	houtav	hsla     "      "           "
a.e013	ind	frembx
a.e014	ind	decmbx
a.e015	ind	oldhed	old head of input chain just sent
a.e016	ind	deque
a.e017	ind	instrp
a.e018	ind	mvpgtg	move data paging target subroutine
a.e019	ind	setptw	set page table word
a.e020	ind	pdcws
a.e021	ind	makecn
a.e023	ind	unlock
a.e024	ind	frebfh	subroutine to free a single buffer
a.e025	ind	ndcws	same as number of buffers read in
a.e026	ind	denq
a.e027	ind	mbxno
a.e028	ind	dspqur
a.e029	ind	.crttb	head of tib list
a.e030	ind	.crtte	end of tib list
a.e032	ind	getbfh
a.e033	ind	savmbx
a.e034	ind	wmbx
a.e035	ind	gmebuf
a.e036	ind	gmesiz
a.e037	ind	setbpt
	rem
	rem
l.e001	vfd	18/tfwrit
l.e002	vfd	18/hslafl
l.e003	oct	37	for testing 0 mod 32
l.e004	oct	004000	inhibit overflow indicator
l.e005	vfd	18/bfflst
l.e007	vfd	18/ntfwrt
	even
l.e008	vfd	12/1,6/rtprty
	ind	rpmbx	for scheduling rpmbx after 1 second
	rem
l.e009	vfd	18/tfblak+tfofc
l.e010	vfd	18/tsfcd+tsfdsr
l.e011	vfd	18/gbfbla	"blast" flag (for utilities)
l.e012	dec	1	for meter increment
l.e013	vfd	18/tfmask
	rem
	rem
dtrsvi	bss	1	for saving indicators
	rem		blast buffers are three consecutive
	rem		double-size buffers
	rem		first is ascii, second is ebcdic,
	rem		third is correspondence
blbuf	bss	1	address of blast buffers
blbuf2	bss	1	address of ebcdic blast buffers
bflag	bss	1	flag indicating blast call
dnblks	bss	1	number of 32-word blocks to take off chain
	ttls	gblast -- subroutine to allocate buffers for blast output
sndflg	bss	1
	rem
	rem		this subroutine allocates the buffer(s) to be used
	rem		to send a blast message to a particular line
	rem		one double-size buffer is sent to ascii lines,
	rem		or two to ebcdic lines.
	rem
	rem		the message is copied into the allocated buffers
	rem
	rem		Inputs:
	rem		   x3 points to source for message
	rem		   a  is 0 for ascii or 1 for ebcdic
	rem
gblast	subr	gbl,(x2)
	rem
	sta	tflag-*	save arguments
	stx3	gsrce-*
	rem
	ilq	2*bufsiz	get double buffer size
	szn	tflag-*	ebcdic?
	tze	2	no
	qls	1	yes, double it again
	tsy	a.e032-*,*	getbuf
	die	10	if we can't get buffers, forget it
	rem
	sta	gtarg-*	store absolute target address
	stx3	vtarg-*	and virtual also
	ldx2	gsrce-*
	stq	gsize-*
gbl010	ldaq	0,2	get two words of source
	staq	0,3	put them in target buffer
	iacx2	2
	iacx3	2
	ila	-2	reduce count
	asa	gsize-*
	tnz	gbl010-*	not exhausted, go around again
	rem
	lda	gtarg-*	get address of head buffer
	sta	a.e007-*,*	(rhead) where write will look for it
	ldx3	vtarg-*	get virtual address back
	szn	tflag-*	ascii or ebcdic?
	tze	gbl020-*	ascii
	iaa	2*bufsiz	ebcdic, set forward pointer
	sta	bf.nxt,3
	tra	2
gbl020	stz	bf.nxt,3	ascii, only one buffer
	sta	a.e008-*,*	(rtail)
	return	gblast
	rem
	rem
tflag	bss	1	ascii/ebcdic flag
gsrce	bss	1	address of source characters
gtarg	bss	1	address of target buffer
vtarg	bss	1	virtual address of target buffer
gsize	bss	1	size of target buffer
	rem
ckecnt	oct	0	consecutive checksum error count
	ttls	decmbx -- routine to decode a mailbox from the cs
	rem
	rem	this routine is called if transaction control word
	rem	indicates that a mailbox has been read from the cs.
	rem	it will interpret the mailbox that has been read into
	rem	"savmbx" and take appropriate action depending on the
	rem	i/o command and opcode in the mailbox
	rem
	rem
decmbx	subr	dec
	ldx3	a.f018-*	=addr(savmbx)
	lda	sm.lno,3	get line number from mailbox
	ana	l.f001-*	=smlmsk
	tnz	dec005-*	there's really a line number
	stz	a.f017-*,*	(tibadr) use 0
	tra	dec010-*	there's a 0 in the a for x1
dec005	null		convert to tib address
	tsy	a.f003-*,*	gettib
	sta	a.f017-*,*	(tibadr) save real tib address
	tsy	a.e019-*,*	(setptw) virtualize it
dec010	cax1		x1 gets virtual tib address
	rem		pick up i/o command
	ldq	sm.op,3	get i/o command and opcode
	ila	0
	lls	9
	sta	opcode-*	 save opcode
	rem
	ila	0
	lls	9	get i/o command into a
	icmpa	wcd	write command data?
	tnz	dec210-*	 no, check for something else
	rem		yes, search wcd table to determine
	rem		where to go
	trace	mt.wcd,tr.mbx,(a.f023-*(*),opcode,sm.lno(3))
	rem
	ldx2	a.f004-*	(wcdtab)
	lda	opcode-*
dec015	null
	cmpa	0,2	check opcode against table entry
	tze	1,2*	if it matches, go where table says
	iacx2	2	else check next entry
	cmpx2	a.f025-*,*	(wcdend) reached end?
	tnz	dec015-*	no, look at next entry
	die	8	else invalid
	rem
	rem
dec020	null		terminal accepted
	szn	tibadr-*	is this line really configured?
	tze	dec100-*	if not, forget it
	ilq	sndout	queue "send output"
	tsy	a.f005-*,*	denq
	tra	dec100-*
	rem
dec030	null		disconnect line
	szn	tibadr-*	is there a tib?
	tze	dec100-*	no, don't try to do anything
	lda	l.f002-*	(tfhang)
	orsa	t.flg,1	hang it up
	lda	l.f003-*	(ntflsn)
	ansa	t.flg,1	turn off listen flag
	rem		call test-state entry of interpreter
	tsy	a.f006-*,*	(itest)
	tra	dec100-*
	rem
dec040	null		disconnect all lines
	lda	l.f004-*	(gbfhng) turn on "hung up" flag
	orsa	a.f007-*,*	globsw
	rem		now hang up all dialed-up lines
	ldx2	a.f013-*,*	(.crttb)
	rem
dec045	null
	lda	qtib,2	get real tib address
	tsy	a.e019-*,*	(setptw) virtualize it
	cax1		put virtual tib address in x1
	lda	l.f002-*	(tfhang)
	orsa	t.flg,1	set hangup flag in tib
	tsy	a.f006-*,*	(itest)
	rem
	iacx2	2	look at next entry in tib list
	cmpx2	a.f039-*,*	(.crtte) reached end?
	tnz	dec045-*	no, go around again
	tra	dec100-*
	rem
dec046	null		don't accept calls
	lda	l.f005-*	(gbfup)
	iera	-1	complement it
	ansa	a.f007-*,*	(globsw) turn it off
	tra	dec100-*	that's all
	rem
dec050	null		accept calls
	rem		turn global "cs up" switch on
	lda	l.f005-*	(gbfup)
	orsa	a.f007-*,*	(globsw)
	lda	sm.cd,3	get buffer limit for input
	sta	a.f029-*,*	(blimit) save for future use
	rem		now call itest for all lines in case they need to
	rem		start listening again
	ldx2	a.f013-*,*	.crttb
dec054	lda	qtib,2	get tib address
	tze	dec055-*	none, skip it
	tsy	a.e019-*,*	setptw
	cax1		now have virtual tib address
	tsy	a.f006-*,*	itest
dec055	iacx2	2	next entry in tib list
	cmpx2	a.f039-*,*	(.crtte) reached the end?
	tnz	dec054-*	no, do the next one
	tra	dec100-*
	rem
dec060	null		reject request
	rem		i.e. cs didn't have room for input
	rem		we will schedule retry routine to retry
	rem		"accept input" one second from now
	tsy	a.f008-*,*	reject
	tra	dec100-*
	rem
dec065	null		enter receive mode
	szn	tibadr-*	not if no line
	tze	dec100-*
	lda	l.f015-*	(tfercv)
	orsa	t.flg2,1	turn on flag (in second word)
	tsy	a.f006-*,*	(itest) tell interpreter
	tra	dec100-*	done
	rem
dec070	null		terminal rejected
	szn	tibadr-*	don't try to hang up nonexistent line
	tze	dec100-*
	lda	l.f002-*	(tfhang)
	orsa	t.flg,1	hang it up, tell interpreter
	tsy	a.f006-*,*	(itest)
	tra	dec100-*	done
	rem
dec075	null		set line type
	szn	tibadr-*	if no line, skip it
	tze	dec100-*
	lda	sm.cd,3	get new type
	sta	t.type,1	set it in tib
	tra	dec100-*	that's all
	rem
dec080	null		checksum error
	ila	0	rewrite same mailbox as last time
	tsy	a.f010-*,*	wmbx
	tra	a.f026-*,*	(decbak) return now
	rem
dec085	null		blast message
	tsy	a.f040-*,*	(rblast) sets up dcw to read msg
	ila	tcblst	set transaction control word
	sta	a.f021-*,*	(tcword)
	tsy	a.f002-*,*	(conect)
	tra	a.f026-*,*	(decbak)
	rem
dec090	null		alter parameters, done by subroutine
	szn	tibadr-*	but not if there's no line
	tze	dec100-*
	tsy	a.f009-*,*	(alterp)
	tra	dec100-*	done
	rem
dec095	null		dial out request
	szn	tibadr-*	but not if there's no line
	tze	dec100-*
	tsy	a.f032-*,*	(acusr) done by subroutine
	tra	dec100-*
	rem
dec096	null		dump memory
	stx3	dctemp-*	save mailbox address
	ldq	sm.cd+3,3	get length of area to dump
	stq	pchlen-*	so memory space can be freed later
	tsy	a.f012-*,*	(getmem) get equal amount of memory space
	die	10	failed
	stx3	pchbuf-*	save address of buffer
	ldx3	dctemp-*	retrieve mailbox address
	rem		copy memory to dump into buffer, it may come
	rem		 from upper 32k
	ldx2	sm.cd+2,3	get source address
	ldq	sm.cd+3,3	get length of memory to be dumped
	ldx3	pchbuf-*	get address of target
	tsy	a.f014-*,*	(mvpgsc) move data paging source
	rem
	ldx3	dctemp-*	retrieve mailbox address
	lda	pchbuf-*	put buffer address in mailbox
	sta	sm.cd+2,3
	ila	tcdmpm	set tcword for dump_fnp order
	sta	a.f021-*,*	(tcword)
	ilq	diaftc	we'll be writing to cs
	tra	dec098-*	enter common code with patch_fnp order
	rem
dec097	null		patch memory
	stx3	dctemp-*	save mailbox addr
	ldq	sm.cd+3,3	get length of area to patch
	tsy	a.f012-*,*	(getmem) get equal amount of memory space
	die	10	failed
	stx3	pchbuf-*	save address of patch buffer
	cx3a
	ldx3	dctemp-*	get mailbox addr back
	ldq	sm.cd+2,3	fnp address to patch
	stq	pchadr-*	save
	sta	sm.cd+2,3	setup transfer to temp buffer
	ldq	sm.cd+3,3	get length in words
	stq	pchlen-*	and save
	ila	tcpchm	set tcword for patch_fnp order
	sta	a.f021-*,*	(tcword)
	ilq	diactf	we'll be reading from cs
dec098	ldx2	a.f033-*	(dcws)
	stx2	a.f034-*,*	(dcwadr)
	ila	10	space for five dcws
	sta	a.f035-*,*	(dcwlen)
	rem		get cs address
	lda	sm.cd+1,3	bottom 18 bits anyway
	staq	0,2	store along with opcode (set above)
	lda	sm.cd,3	high-order 6 bits of cs address?
	tze	dec099-*	not there
	als	6	yes, put in dcw (24-29)
	orsa	1,2
	rem
dec099	null
	ldaq	sm.cd+2,3	get fnp address and tally
	ora	l.f016-*	(0,w.2)
	iaq	1	convert tally to 36-bit words
	qrs	1
	staq	2,2	put them in dcw
	cx2a		get dcw address
	iaa	4	updated
	cax3		into x3
	rem		free the mailbox (can't use frembx because
	rem		it assumes a new dcw list)
	tsy	a.f036-*,*	(wtimw)
	tsy	a.f037-*,*	(bint)
	iacx3	4
	tsy	a.f038-*,*	(bdisc)
	tsy	a.f002-*,*	(conect)
	tra	a.f026-*,*	(decbak) done
	rem
dec100	null		through with wcd, free the mailbox
	tsy	a.f011-*,*	(frembx)
	tra	a.f026-*,*	(decbak) and return
	rem
dec101	null		msgsiz
	lda	t.line,1	find out if hsla line
	cana	l.f007-*	hslafl
	tze	dec100-*	it isn't, ignore this mailbox
	ldx2	t.sfcm,1	get sfcm address
	lda	sm.cd,3	get new message size
	sta	sf.mms,2	save it
	tra	dec100-*	done
	rem
dec105	null		fnp_break order
	tsy	a.f041-*,*	(=brkptr) subr to do break point request
	tra	dec100-*	done
	rem
dec106	stx3	lctlmb-*	line_control - save mbx addr
	tsy	a.f006-*,*	make test state call
	stz	lctlmb-*	this means line_control done
	tra	dec100-*
	rem
dec107	null		set_delay
	szn	tibadr-*	any line?
	tze	dec100-*	not really
	cx3a		get pointer to
	iaa	sm.cd	command data
	cax2		into x2
	tsy	a.f044-*,*	makdly
	tra	dec100-*
	rem
dec300	null		set framing chars
	szn	tibadr-*	forget it if no line
	tze	dec100-*
	lda	sm.cd,3	get the characters
	sta	t.frmc,1	save in tib
	lda	t.line,1
	cana	l.f007-*	=hslafl
	tze	dec100-*	not hsla line, don't bother
	tsy	a.f048-*,*	=hmode
	tra	dec100-*
	rem
	eject
a.f001	ind	gmeter	sets up dcw list to report meters
a.f002	ind	conect
a.f003	ind	gettib	translates line number to tib
a.f004	ind	wcdtab	branch table for wcd opcodes
a.f005	ind	denq
a.f006	ind	itest	interpreter's "test_state" entry
a.f007	ind	globsw	global switch word
a.f008	ind	reject
a.f009	ind	alterp	subroutine for "alter parameters"
a.f010	ind	wmbx
a.f011	ind	frembx
a.f012	ind	getmem
a.f013	ind	.crttb	head of tib list
a.f014	ind	mvpgsc	move data paging source subroutine
a.f015	ind	ecgifl	echo negotiation input flush
*a.f016			unused
a.f017	ind	tibadr	some places can`t quite reach it
a.f018	ind	savmbx
a.f019	ind	rddcw
a.f021	ind	tcword	transaction control word
a.f022	ind	indata	subroutine to set up dcws for sending
	rem		input to cs
a.f023	ind	mbxno
a.f024	ind	.crmet
a.f025	ind	wcdend
a.f026	ind	decbak	return from this routine
a.f027	ind	setbpt
a.f029	ind	blimit
*a.f030	unused
	rem
a.f032	ind	acusr	for starting acu
a.f033	ind	dcws	standard dcw area
a.f034	ind	dcwadr
a.f035	ind	dcwlen
a.f036	ind	wtimw	updates timw
a.f037	ind	bint	builds interrupt dcw
a.f038	ind	bdisc	builds disconnect dcw
a.f039	ind	.crtte	end of tib list
a.f040	ind	rblast
a.f041	ind	brkptr	break point request handler
*a.f042	unused
*a.f043	unused
a.f044	ind	makdly
*a.f045	unused
*a.f046	unused
*a.f047	unused
a.f048	ind	hmode	subr that handles mode change for hsla lines
	rem
	rem
l.f001	vfd	18/smlmsk
l.f002	vfd	18/tfhang
l.f003	vfd	18/ntflsn
l.f004	vfd	18/gbfhng
l.f005	vfd	18/gbfup
l.f006	vfd	18/tfblak+tfofc
l.f007	vfd	18/hslafl
l.f008	vfd	18/lnmask
l.f009	vfd	18/nretry
l.f010	vfd	18/tfitim
l.f011	vfd	18/tfblak
l.f012	vfd	o18//tfitim
l.f013	vfd	18/tfctrl
l.f014	vfd	o18//tfblak
l.f015	vfd	18/tfercv
l.f016	zero	0,w.2
l.f017	vfd	18/tfofc
l.f018	vfd	18/tfdild
l.f019	vfd	18/tfifc
	rem
	rem
tibadr	bss	1	real address of currently relevant tib
opcode	bss	1	opcode from mailbox
dctemp	bss	1	temporary
lctlmb	oct	0	contains mbx addr during line_control order
pchbuf	bss	1	address of patch buffer
pchadr	bss	1	address being patched
pchlen	bss	1	number of words to patch
	eject
dec210	null		not wcd
	icmpa	wtx	write text?
	tnz	dec230-*	no, try rtx
	lda	opcode-*	yes, get opcode
	icmpa	accout	must be accept output or
	tze	dec220-*	accept last output
	icmpa	aclout
	tze	dec220-*
	die	8	otherwise, forget it
	rem
dec220	null		set up to read dcw list
	rem
	trace	mt.wtx,tr.mbx,(a.f023-*(*),sm.lno(3),sm.adr+1(3))
	rem
	szn	tibadr-*	is there really a line?
	tze	dec100-*	if not, just free mailbox and return
	rem
	tsy	a.f019-*,*	rddcw
	rem
	rem		set transaction control word to
	ila	tcdcwl	"dcw list read"
	sta	a.f021-*,*	tcword
	tsy	a.f002-*,*	conect
	tra	decbak-*	and return
	rem
	rem
dec230	null		i/o command is rtx or invalid
	icmpa	rtx
	tze	2
	die	17
	rem
	rem		it's rtx, opcode must be
	lda	opcode-*	input accepted
	icmpa	inacc
	tze	2
	die	8
	rem
	trace	mt.rtx,tr.mbx,(a.f023-*(*),sm.lno(3))
	rem
	rem		put together dcw list for transmitting input
	rem		to cs
	tsy	a.f022-*,*	indata
	rem
	ila	tcwrd	set transaction control word to "wrote data"
	sta	a.f021-*,*	tcword
	tsy	a.f002-*,*	conect
	rem
decbak	return	decmbx
	rem
dec350	null		set echnego break table
	rem
	rem		the table is too big to fit in a mailbox,
	rem		so we'll read it into the pseudo-dcw area
	szn	tibadr-*
	tze	dec100-*	no line?
	tsy	a.f019-*,*	(rddcw)
	ila	tcrecn	set tcword to "read echo neg. table"
	sta	a.f021-*,*	tcword
	tsy	a.f002-*,*	conect
	tra	decbak-*
	rem
dec360	null		start echo negotiation
	rem		which has the option to refuse echnegooin
	rem		by zeroing t.scll for any reason whatsoever.
	szn	tibadr-*
	tze	dec100-*	no line
	lda	t.echo,1	is there pending echoing?
	tze	dec370-*	no
	tsy	a.f027-*,*	setbpt
	cax2
	lda	eb.tly,2	maybe
	arl	9	isolate tally to make sure
	tnz	dec380-*	yes, can't echnego
dec370	szn	t.dcp,1	is there a dia-queued input chain?
	tnz	dec380-*	yes, don't negotiate
	tsy	a.f015-*,*	(engifl) get icp chain queued
	szn	t.entp,1	make sure there had better be a table
	tze	dec380-*	punt if not
	lda	sm.cd,3	get # of chars seen by ring 0
	cmpa	t.sncc,1	is it the same as # of chars we sent out?
	tnz	dec380-*	no, can't echnego
	lda	sm.cd+1,3	get screen length left, 0 works too.
	sta	t.scll,1	ok, we're echo negotiating
	tra	dec100-*
dec380	null		fail to start echo negotiation
	stz	t.scll,1	shoulda been zero anyway for engogo
	tra	dec100-*
	rem
dec400	null		stop echo negotiation
	szn	tibadr-*
	tze	dec100-*
	tsy	a.f015-*,*	get queued stuff out
	ilq	engaof	acknowledge_echnego_stop
	tsy	a.f005-*,*	(denq) send one
	tra	dec380-*	turn off negotiation
	rem
dec440	null		init echo negotiation
	szn	tibadr-*
	tze	dec100-*	no line?
	tsy	a.f015-*,*	get the act synchronized
	stz	t.sncc,1	synchronize ctrs
	ilq	engain	acknowledge_echnego_init
	tsy	a.f005-*,*	(denq)
	tra	dec100-*
	rem
dec450	null		set input flow control chars
	lda	sm.cd,3	get the characters
	sta	t.ifch,1
	szn	sm.cd+1,3	timeout options specified?
	tze	dec455-*	no
	lda	l.f010-*	=tfitim
	orsa	t.flg3,1	yes, set it in tib
	tra	dec458-*
dec455	lda	l.f012-*	=^tfitim
	ansa	t.flg3,1	otherwise, turn it off
dec458	lda	t.flg2,1	check if iflow already on
	cana	l.f019-*	=tfifc
	tze	dec100-*	no, never mind
	tsy	a.f048-*,*	(hmode) have to make sure cct is updated
	tra	dec100-*
	rem
dec460	null		set output flow control chars
	lda	sm.cd,3	get the chars
	cmpa	t.ofch,1	have they changed?
	tze	dec462-*	no, may not want to reinitialize
	sta	t.ofch,1	else store them
	tra	dec463-*	and skip other test
dec462	lda	t.flg2,1	check for modes already on
	ana	l.f006-*	=tfblak+tfofc
	cmpa	l.f006-*	both on?
	tze	dec464-*	yes, don't initialize block count
dec463	stz	t.omct,1	initialize message count
dec464	szn	sm.cd+1,3	block acknowledgement protocol?
	tze	dec465-*	no
	lda	l.f011-*	=tfblak
	orsa	t.flg2,1	yes, set it in tib
	tra	dec468-*
dec465	lda	l.f014-*	=^tfblak
	ansa	t.flg2,1	otherwise, turn it off
dec468	lda	t.flg2,1	see if mode is already on
	cana	l.f017-*	=tfofc
	tze	dec100-*	nope
	tsy	a.f048-*,*	(hmode) yes, have to make sure cct gets updated
	tra	dec100-*
	rem
dec470	null		report meters
	szn	a.f024-*,*	(.crmet) is metering enabled?
	tze	dec100-*	no, just free mailbox
	tsy	a.f001-*,*	gmeter subroutine does it all
	tra	decbak-*
	rem
	rem
	even
savmbx	bss	fmbxsz	copy of input mailbox
	rem
	eject
	rem
	rem	This macro is used to set up a branch table fo
	rem	mailbox opcodes. It generates a word containing
	rem	 the opcode to be checked for, and a word containing
	rem	the address to branch to for that opcode.
	rem
optab	macro	c,m
	zero	#1
	ind	#2
	rem
	endm	optab
	rem
wcdtab	null		table of locations for transfer
	rem		on wcd opcodes
	optab	termac,dec020
	optab	dislin,dec030
	optab	disall,dec040
	optab	accall,dec050
	optab	rejreq,dec060
	optab	entrcv,dec065
	optab	trmrej,dec070
	optab	setcls,dec075
	optab	cserr,dec080
	optab	alter,dec090
	optab	blast,dec085
	optab	disacc,dec100
	optab	incomp,dec100
	optab	frmchr,dec300
	optab	brack,dec100
	optab	dodial,dec095
	optab	dmpmem,dec096
	optab	pchmem,dec097
	optab	brkpnt,dec105
	optab	noacc,dec046
	optab	linctl,dec106
	optab	setdly,dec107
	optab	msgsiz,dec101
	optab	engstb,dec350
	optab	engogo,dec360
	optab	engoff,dec400
	optab	engini,dec440
	optab	infcc,dec450
	optab	outfcc,dec460
	optab	rmeter,dec470
wcdend	zero	*	to mark end of table
	rem
	rem
*
*	this subroutine is called by a linctl opblock to see if the
*	current test state call is caused by a line_control
*	order. the convention is that during a line_control order,
*	"lctlmb" is non-zero, and contains the mailbox addr
*
lctlck	subr	lct,(a)
	lda	a.g007-*,*	=lctlmb, pick up mailbox addr
	tze	lctret-*	not line contorl
	iaa	sm.cd	get addr of data
	cax3
	aos	lctlck-*	take skip return
lctret	return	lctlck
	ttls	alterp -- subroutine to handle "alter parameters"
	rem
	rem
	rem	this subroutine does whatever is necessary when an
	rem	"alter parameters" opcode is sent from the cs
	rem
	rem	the subcommand to be performed is in the first 9
	rem	bits of the command data in the mailbox
	rem	for most of the subcommands currently implemented,
	rem	the low-order bit of the first word of command
	rem	data indicates "on" or "off"
	rem
	rem	at entry:
	rem	x1 -- virtual tib address
	rem	x3 -- mailbox address
	rem
alterp	subr	alt
	rem
	trace	mt.alt,tr.mbx,(sm.cd(3))
	rem
	stz	caltst-*	initialize "call itest" flag
	stz	chmode-*	and "call hmode" flag
	stz	checho-*	and "change acho mode" flag
	lda	a.g009-*	=t.flg,1
	sta	flgptr-*	initialize pointer to t.flg
	lda	t.type,1	is this colts executive channel?
	icmpa	ttcolt	if so, we use a much shorter
	tze	alt500-*	list of subcommands
	lda	sm.cd,3	get first 18 bits of command data
	lrl	9	isolate subcommand
	ldx2	a.g001-*	addr(alttab)
alt010	null
	cmpa	0,2	does subcommand match table entry?
	tze	1,2*	yes, go process it
	iacx2	2	no, check next
	cmpx2	a.g011-*,*	(altend) if not at end of table
	tnz	alt010-*
	die	8	else die
	rem
alt020	null		crecho
	lda	l.g001-*	=tfcrec
	tra	alt135-*	join common code
	rem
alt030	null		lfecho
	lda	l.g002-*	=tflfec
	tra	alt135-*
	rem
alt040	null		tbecho
	lda	l.g003-*	=tftbec
	tra	alt140-*
	rem
alt050	null		handle quit
	lda	l.g004-*	=tfquit
	tra	alt150-*
	rem
alt060	null		listen
	tsy	a.g012-*,*	(setsiz) pick up buffer size from mailbox
	qrl	0	check flag
	tze	alt065-*	turning it off, don't worry
	lda	t.flg3,1	was the channel masked?
	cana	l.g027-*	=tfmask
	tze	alt065-*	no
	tsy	a.g013-*,*	(hunmsk) yes, unmask it now
alt065	lda	l.g005-*	=tflisn
	aos	caltst-*	call itest when done
	rem
	tra	alt150-*
	rem
alt070	null		lock
	lda	l.g008-*	=tfctrl
	tra	alt150-*
	rem
alt080	null		full duplex
	lda	l.g009-*	=tffdpx
	tra	alt150-*
	rem
alt090	null		change-string
	tra	altbak-*	that's all
	rem
alt100	null		who-are-you
	rem		must start control tables at special place
	rem		to read answerback
	lda	l.g005-*	=tflisn
	cana	t.flg,1	if line isn't listening,
	tze	altbak-*	don't bother
	rem
	ila	-wruinc	check list of line types for which wru is no good
	ldx2	a.g005-*	addr(wrutbl)
	ldq	t.type,1
	rem
alt101	cmpq	0,2	is this one?
	tze	alt102-*	yes
	iacx2	1	look at next
	iaa	1	exhausted table?
	tnz	alt101-*	no
	rem
	ilq	wrutim	send "wru timeout" right away
	tsy	a.g006-*,*	denq
	tra	altbak-*
	rem
alt102	ldx2	a.g004-*	addr(ctrl)
	lda	ct.wru,2	address of special wait block
	sta	t.cur,1	tell interpreter to start there
	stz	t.reta,1	in case we yanked it out of subr
	tsy	a.g002-*,*	itest
	tra	altbak-*
	rem
alt110	null		echoplex mode
	lda	l.g011-*	=tfecpx
	tra	alt135-*
	rem
alt120	null		framei mode
	lda	t.line,1	hsla line?
	cana	l.g010-*	=hslafl
	tze	alt125-*	no, buffer sizes are uninteresting
	qrl	0	check the flag
	tze	alt125-*	turning it off, no buffer sizes
	ldx2	t.sfcm,1	get sfcm address
	lda	sm.cd+1,3	get intermediate buffer size
	tsy	rndsiz-*	get it in words
	sta	sf.bsz,2	save it
	lda	sm.cd+2,3	get size to be used during frame
	tze	2	if any
	tsy	rndsiz-*	in words
	sta	sf.fbs,2	save it
	rem
alt125	null
	ila	t.flg2-t.flg
	asa	flgptr-*	update flgptr to point to t.flg2
	lda	l.g018-*	tffrmi
	tra	alt140-*
	rem
alt135	aos	checho-*	echoing mode changed
	rem
alt140	null
	aos	chmode-*
	rem
alt150	null		flag on or off?
	qrl	0
	tze	alt160-*
	orsa	flgptr-*,*	on
	tra	alt170-*
alt160	null		off
	iera	-1
	ansa	flgptr-*,*
	rem
alt170	null		mode changed?
	szn	chmode-*
	tze	alt180-*	no
	lda	t.line,1	yes, hsla line?
	cana	l.g010-*	hslafl
	tze	alt175-*	no
	tsy	a.g003-*,*	call hmode
	rem
alt175	szn	checho-*	did we change an echoing mode?
	tze	alt180-*	no
	lda	t.flg,1
	cana	l.g016-*	tflfec+tfcrec+tfecpx
	tnz	alt180-*	echoing not all off
	tsy	a.g008-*,*	(deldly) we have stopped echoing, remove delay table
	stz	t.dtp,1
	rem
alt180	null		call itest?
	szn	caltst-*
	tze	altbak-*	no,return
	tsy	a.g002-*,*	itest
	tra	altbak-*
	rem
alt190	null		dump input
	lda	l.g013-*	=tfrabt
	orsa	t.flg2,1	set read abort flag
	tsy	a.g002-*,*	itest
	tra	altbak-*
	rem
alt200	null		dump output
	lda	l.g006-*	=tfwabt
	orsa	t.flg,1	on
	lda	l.g007-*	=^tfwrit
	ansa	t.flg,1	tfwrit off
	tsy	a.g002-*,*	itest
	tra	altbak-*
	rem
alt210	null		xmit hold
	lda	l.g012-*	=tfxhld
	qrl	0	on or off?
	tze	alt220-*
	orsa	t.flg2,1	on, just do it
	tra	altbak-*
alt220	null		off, we'll have to do test-state also
	iera	-1
	ansa	t.flg2,1	turn flag off
	tsy	a.g002-*,*	itest
	tra	altbak-*
	rem
alt230	null		replay mode
	lda	l.g014-*	(=tfrply) get bit
	rem
alt240	qrl	0	on or off?
	tze	alt245-*	off, do it
	orsa	t.flg2,1	turn it on
	tra	altbak-*
	rem
alt245	null
	iera	-1	invert flag bit
	ansa	t.flg2,1	turn it off
	tra	altbak-*
	rem
alt250	null		polite mode
	lda	l.g015-*	(=tfplit) get the bit
	tra	alt240-*	common code to set second flag word bits
	rem
alt260	null		set buffer size
	tsy	setsiz-*	just do it
	tra	altbak-*	and begone
	rem
alt270	null		breakall mode
	ila	t.flg3-t.flg
	asa	flgptr-*	make flgptr point to t.flg3
	lda	l.g019-*	(=tfbral) prepare to set breakall flag
	tra	alt140-*
	rem
alt280	null		prefixnl mode
	ila	t.flg2-t.flg
	asa	flgptr-*
	lda	l.g020-*	(=tfpfnl)
	tra	alt150-*
	rem
alt290	null		iflow mode
	ila	t.flg2-t.flg	make flgptr point to t.flg2
	asa	flgptr-*
	lda	t.line,1	is it hsla line?
	cana	l.g010-*	=hslafl
	tze	alt295-*
	ldx2	t.sfcm,1	if so, have to update buffer size
	lda	sm.cd+1,3	get it from mailbox
	tsy	rndsiz-*
	sta	sf.fbs,2
alt295	lda	l.g021-*	=tfifc
	tra	alt140-*	go set it
	rem
alt300	null		oflow mode
	ila	t.flg2-t.flg	make flgptr point at t.flg2
	asa	flgptr-*
	qrl	0	turning it on or off?
	tnz	alt309-*	on, go ahead
	lda	t.flg2,1	off, was it block acknowledgement?
	cana	l.g023-*	=tfblak
	tze	alt309-*	no, hsla_man will take care of it
	stz	t.omct,1	else must reset counter
	aos	caltst-*	and alert control tables
alt309	lda	l.g022-*	=tfofc
	tra	alt140-*	go do it
	rem
alt310	null		odd parity
	ila	t.flg3-t.flg	make flgptr point at t.flg3
	asa	flgptr-*
	lda	l.g024-*	=tfoddp
	tra	alt140-*
	rem
alt320	null		no input parity
	ila	t.flg3-t.flg	make flgptr point at t.flg3
	asa	flgptr-*
	lda	l.g025-*	=tf8in
	tra	alt150-*
	rem
alt330	null		no output parity
	ila	t.flg3-t.flg	make flgptr point at t.flg3
	asa	flgptr-*
	lda	l.g026-*	=tf8out
	tra	alt140-*
	rem
	rem
alt400	null		send line break
	rem		must start control tables at special place
	rem		to send line break
	rem
	ldx2	a.g004-*	addr(ctrl)
	lda	ct.brk,2	address of special wait block
	sta	t.cur,1	tell interpreter to start there
	stz	t.reta,1	in case we yanked it out of subr
	tsy	a.g002-*,*	itest
	tra	altbak-*
	rem
alt500	null		come here for colts channel
	lda	sm.cd,3	get ifrst 18 bits of command data
	lrl	9	isolate subcommand
	ldx2	a.g010-*	addr (alctab)
alt510	null
	cmpa	0,2	does subcommand match table entry?
	tze	1,2*	yes, go process it
	iacx2	2	no, check next
	cmpx2	alcend-*	reached end of table?
	tnz	alt510-*	no, look again
	tra	altbak-*	ignore any not in table
	rem
altbak	return	alterp
	rem
	rem
	rem
a.g001	ind	alttab
a.g002	ind	itest	"test_state" entry of interpreter
a.g003	ind	hmode	"change-mode" entry of hsla_man
a.g004	ind	ctrl
a.g005	ind	wrutbl	table of invalid "wru" line types
a.g006	ind	denq
a.g007	ind	lctlmb
a.g008	ind	deldly
a.g009	ind	t.flg,1	used to set up address variable for flag word
a.g010	ind	alctab
a.g011	ind	altend
a.g012	ind	setsiz
a.g013	ind	hunmsk
	rem
l.g001	vfd	18/tfcrec
l.g002	vfd	18/tflfec
l.g003	vfd	18/tftbec
l.g004	vfd	18/tfquit
l.g005	vfd	18/tflisn
l.g006	vfd	18/tfwabt
l.g007	vfd	18/ntfwrt
l.g008	vfd	18/tfctrl
l.g009	vfd	18/tffdpx
l.g010	vfd	18/hslafl
l.g011	vfd	18/tfecpx
l.g012	vfd	18/tfxhld
l.g013	vfd	18/tfrabt
l.g014	vfd	18/tfrply
l.g015	vfd	18/tfplit
l.g016	vfd	18/tflfec+tfcrec+tfecpx
l.g017	vfd	18/bfmsiz
l.g018	vfd	18/tffrmi
l.g019	vfd	18/tfbral
l.g020	vfd	18/tfpfnl
l.g021	vfd	18/tfifc
l.g022	vfd	18/tfofc
l.g023	vfd	18/tfblak
l.g024	vfd	18/tfoddp
l.g025	vfd	18/tf8in
l.g026	vfd	18/tf8out
l.g027	vfd	18/tfmask
	rem
	rem
caltst	bss	1	flag indicating whether to call itest
chmode	bss	1	flag indicating mode change
checho	bss	1	flag indicating echo-mode change
altemp	bss	1	temporary storage
atemp2	bss	1	more temporary storage
flgptr	ind	**	this will be set with x1 modification
	rem
	rem
alttab	equ	*	branch table for alter parameters subcommands
	rem
	optab	alcrec,alt020
	optab	allfec,alt030
	optab	altbec,alt040
	optab	alquit,alt050
	optab	allisn,alt060
	optab	allock,alt070
	optab	alfdpx,alt080
	optab	alchng,alt090
	optab	alwru,alt100
	optab	alecpx,alt110
	optab	aldpin,alt190
	optab	aldump,alt200
	optab	alxhld,alt210
	optab	alrply,alt230
	optab	alplit,alt250
	optab	alfrmi,alt120
	optab	alsetb,alt260
	optab	albral,alt270
	optab	alpfnl,alt280
	optab	alifc,alt290
	optab	alofc,alt300
	optab	aloddp,alt310
	optab	al8in,alt320
	optab	al8out,alt330
	optab	albrk,alt400
altend	zero	*	marks end of table
	rem
	rem
alctab	equ	*	branch table used for colts channel
	optab	allisn,alt060
	optab	aldpin,alt190
	optab	aldump,alt200
alcend	zero	*	marks end of table
	rem
	rem		table of line types for which wru is allowed
wrutbl	dec	1	ascii
	dec	2	1050
	dec	3	2741
	dec	8	202c6
wruinc	equ	*-wrutbl	length of table
	ttls	rndsiz -- subroutine to convert buffer size to words
	rem
	rem	this subroutine takes a buffer size in characters
	rem	and returns it in words rounded up to the next
	rem	multiple of 32
	rem
	rem	input:
	rem	   a -- chars per buffer
	rem
	rem	output:
	rem	   a -- buffer size in words
	rem
	rem
rndsiz	subr	rnd
	iaa	71	round up to multiple of 32 words
	ars	6
	als	5	convert to words
	cmpa	l.g017-*	(bfmsiz) respect upper limit
	tmi	2
	lda	l.g017-*
	return	rndsiz
	rem
	rem
*	setsiz -- subroutine to set buffer size in sfcm
	rem
	rem
	rem	copy input buffer size from mailbox to sf.bsz for
	rem	listen order or set_buffer_size order (dialout)
	rem
	rem	input:
	rem	   x1 -- virtual tib address
	rem	   x3 -- submailbox address
	rem
	rem	output:
	rem	   buffer size stored in sf.bsz
	rem	   zero stored in sf.mms
	rem
	rem
setsiz	subr	set,(q,x2)
	lda	t.line,1	is this an hsla line?
	cana	l.g010-*	hslafl
	tze	setbak-*	no, don't bother with sfcm stuff
	ldx2	t.sfcm,1
	tze	setbak-*	better leave it alone if no sfcm
	lda	sm.cd+1,3	get buffer size in chars
	tsy	rndsiz-*	get it in words rounded up to multiple of 32
	sta	sf.bsz,2	save size in sfcm
	stz	sf.mms,2	start clean
setbak	return	setsiz
	ttls	filmbx -- subroutine to fill FNP-controlled mailbox from i/o queue
	rem
	rem
	rem		this routine is called by dgetwk if the i/o queue is
	rem		non-empty and there's a free mailbox for sending to the CS
	rem
	rem		x3: mailbox save area address
	rem
	rem
filmbx	subr	fil
	rem		start by getting request from i/o queue
	tsy	a.v027-*,*	(fetch)
	lda	0,2	pick up opcode word from queue
	sta	filopc-*
	stx2	filtmp-*	save queue address
	als	9	put opcode in mailbox
	iora	rcd	with rcd
	sta	sm.op,3
	stz	sm.cdl,3	initialize command data length to zero
	stz	sm.lno,3	likewise line number
	ila	-1	correct the queue count
	asa	a.v004-*,*	(qcnt)
	lda	filopc-*	pick up opcode again
	ana	l.v019-*	(=007000) see if any data words
	tze	fil020-*	none
	ars	9	compute nwords
	caq
	cx3a
	iaa	sm.cd	point at beginning of command data
	cax1
	ldx2	filtmp-*	get opcode back
fil010	null
	lda	1,2	pick up word from queue
	sta	0,1	store in mailbox
	iaq	-1
	tze	fil020-*	all words moved in
	iacx1	1	bump pointers
	iacx2	1
	tra	fil010-*
	rem
fil020	null		now dequeue the error message
	lda	filopc-*	pick up original opcode
	iana	255
	sta	filopc-*	save masked version
	icmpa	errmsg	sending an error message?
	tnz	fil030-*	no
	ldx2	filtmp-*	addr of q entry
	ldx1	l.v004-*	(=0) so dlqent will know not to meter
	tsy	a.v042-*,*	(=dlqent) delete it
	tra	fil120-*	done
	rem
fil030	ldx1	a.v043-*,*	address of current queue
	lda	qtib,1	get real tib addrss
	sta	a.v001-*,*	(tibadr) save real tib address
	tsy	a.v006-*,*	(setptw) virtualize it
	cax1		put virtual tib address in x1
	lda	t.line,1	put line number in mailbox
	orsa	sm.lno,3
	rem		now deal with opcode
	lda	filopc-*
	icmpa	accin	"accept input"?
	tze	fil100-*	yes, go do special stuff
	ldx2	filtmp-*	get queue address
	tsy	a.v042-*,*	(=dlqent) and free it
	rem
	trace	mt.ouq,tr.que,(filtmp,filopc,t.line(1))
	rem
	lda	filopc-*	get op code again
	ldx2	a.v015-*	addr(rcdtab)
fil040	null		search table for opcode
	cmpa	0,2	if found,
	tze	1,2*	branch according to table
	iacx2	2	else go to next entry
	cmpx2	rcdend-*	table exhausted?
	tnz	fil040-*
	die	8	yes, invalid opcode
	rem
	rem
fil050	null		accept new terminal
	rem
	smeter	mincs,.mndil,l.v001-*
	smeter	mupdat,.mdilc,(a.v007-*(*))
	rem
	lda	t.type,1	pass type back as command data
	stz	sm.cd,3	cs looks at 36 bits
	sta	sm.cd+1,3
	stz	sm.cd+2,3	zero second 36 bits of command data
	stz	sm.cd+3,3
	lda	l.v017-*	(=tfauto)
	cana	t.flg,1	is the an autobaud line?
	tze	fil060-*	no
	ldx2	t.sfcm,1	address of software com region
	ldx2	sf.hsl,2	address of hsla table
	lda	ht.flg,2	flag word
	iana	htfspd	isolate speed
	iaa	-1	compute cs speed index
	icmpa	7	less then 1200?
	tmi	2	yes
	iaa	-1	further fudge (multics does not know 1050 baud)
	sta	sm.cd+3,3	and store in command data
fil060	ila	12	set command data length also
	sta	sm.cdl,3
	lda	l.v018-*	tfdild
	orsa	t.flg2,1	mark it dialed up now
	tra	fil120-*
	rem
fil070	null		line disconnected
	rem		turn off listen flag in tib
	lda	l.v003-*	=^tflisn
	ansa	t.flg,1
	lda	l.v010-*	get permanent t.flg bits
	ansa	t.flg,1	turn off all the others
	lda	l.v011-*	get permanent t.flg2 bits
	ansa	t.flg2,1	turn off all the others
	lda	l.v014-*	get permanent t.flg3 bits
	ansa	t.flg3,1	turn off all the others
	rem
	rem		if this type of line has tfctrl by default,
	rem		leave it on
	ldx3	a.v024-*	addr(ctrl)
	ldx3	ct.dev,3	array of device table addresses
	adcx3	t.type,1	indexed by device type
	ldx3	-1,3	(which starts at 1, not 0)
	rem		x3 -> relevant device table entry
	lda	l.v012-*	dtfctl
	cana	dt.flg,3	should tfctrl be on?
	tze	fil080-*	no, leave it off
	lda	l.v013-*	=tfctrl
	orsa	t.flg,1	turn it on
	rem
fil080	null
	lda	t.echo,1	is there an echo buffer?
	tze	fil090-*
	ilq	bufsiz	if so, free it
	tsy	a.v016-*,*	frebfh
	stz	t.echo,1
	rem
fil090	null
	tsy	a.v045-*,*	(deldly) get rid of any delay table
	stz	t.dtp,1	and remember that it's gone
	tsy	a.v047-*,*	(deletb) free echnego tbl if any
	stz	t.entp,1	and remember that it's gone
	stz	t.scll,1	turn off pendant echo negotiation
	stz	t.sncc,1	Clear this for good luck
	rem
	smeter	mincs,.mndil,l.v002-*
	smeter	mupdat,.mdilc,(a.v007-*(*))
	rem		if hsla line, free cct buffer if any
	lda	t.line,1	is it hsla line?
	cana	l.v007-*	=hslafl
	tze	fil120-*	if not, don't bother
	lda	t.type,1	make sure it's a real channel
	icmpa	ttcolt	and not just colts executive
	tze	fil120-*	nope
	ilq	0
	tsy	a.v046-*,*	shrcct
	tra	fil120-*	that's it for disconnected line
	rem
	rem
fil100	null		accept input
	ila	9	command data will be 54 bits
	sta	sm.cdl,3
	rem		get count of input characters to put in cmd
	tsy	a.v017-*,*	(incnt) data
	rem
	lda	a.v030-*,*	(.crnbf) get number of buffers left
	sta	sm.fre,3	tell multics what it is
	szn	a.v005-*,*	(shinp) was it short input?
	tze	fil120-*	no
	ila	inmbx	yes, reset opcode
	sta	filopc-*
	lda	l.v005-*	(^tfinq) while, accept input is being processed,
	ansa	t.flg3,1	don't allow appending to the last buffer
	tra	fil120-*
	rem
	rem
fil110	null		send output
	ila	9	54 bits of command data
	sta	sm.cdl,3	because we will put buffer count in same
	rem		place as for accept input
	lda	a.v030-*,*	(.crnbf) get number of buffers remaining
	sta	sm.fre,3
	rem
	rem
fil120	null		finished with rcd, now write mailbox
	rem		back to cs
	lda	filopc-*
	ldx2	a.v002-*,*	mbxno
	sta	a.v003-*,*	mbxfre-8,2 (mark mailbox with current opcode)
	lda	a.v018-*	addr(savmb)
	tsy	a.v010-*,*	wmbx
filbak	return	filmbx
	eject
	rem
	rem
a.v001	ind	tibadr
a.v002	ind	mbxno
a.v003	ind	mbxfre-8,2
a.v004	ind	qcnt
a.v005	ind	shinp
a.v006	ind	setptw	set up variable cpu page table word
a.v007	ind	.mndil
*a.v008		unused
*a.v009		unused
a.v010	ind	wmbx
a.v015	ind	rcdtab	branch table for rcd opcodes
a.v016	ind	frebfh
a.v017	ind	incnt	subroutine to count input characters
a.v018	ind	savmbx
a.v024	ind	ctrl
a.v027	ind	fetch
a.v030	ind	.crnbf
a.v042	ind	dlqent
a.v043	ind	curque
a.v045	ind	deldly
a.v046	ind	shrcct	subr that shares or releases cct
a.v047	ind	deletb
	rem
	rem
l.v001	dec	1
l.v002	dec	-1
l.v003	vfd	18/ntflsn
l.v004	dec	0
l.v005	vfd	o18//tfinq
l.v007	vfd	18/hslafl
l.v010	vfd	18/tfdlup+tfauto
l.v011	vfd	18/tfsftr
l.v012	vfd	18/dtfctl
l.v013	vfd	18/tfctrl
l.v014	vfd	18/tfbkpt+tfoddp+tfmask+tfabf0+tfabf1
l.v017	vfd	18/tfauto
l.v018	vfd	18/tfdild
l.v019	oct	007000
	rem
	rem
filtmp	bss	1
filopc	bss	1
	rem
	rem
rcdtab	null		branch table for rcd opcodes
	rem
	optab	acctrm,fil050
	optab	lindis,fil070
	optab	sndout,fil110
	optab	brkcon,fil120
	optab	wrutim,fil120
	optab	acupwi,fil120
	optab	acudlo,fil120
	optab	acuacr,fil120
	optab	acung,fil120
	optab	linsta,fil120
	optab	engain,fil120
	optab	engaof,fil120
	optab	linmsk,fil070
rcdend	zero	*	to mark end of table
	rem
	ttls	gmeter -- report meters to cs
	rem
	rem	this subroutine sets up a dcw list to copy either
	rem	per-channel or FNP-wide meters in response to a 
	rem	report-meters mailbox. The meters are copied to a
	rem	temporary buffer both to avoid having them paged out and
	rem	to make sure a consistent copy is sent.
	rem
	rem	at entry:
	rem	x1 contains address of tib (or tibadr = 0 if for whole fnp)
	rem	x3 points to mailbox; sm.cd in mailbox contains address
	rem	   of cs buffer
	rem
gmeter	subr	gme,(x2,x3)
	szn	a.s001-*,*	(tibadr) for a subchannel?
	tze	gme010-*	no
	ldx2	t.metr,1	yes, get pointer to its meters
	ilq	m.synl	this is how much space they take up
	stq	gmelen-*
	tra	gme020-*
gme010	ldx2	a.s002-*	whole fnp, get addr (.mdilc)
	ilq	.mleng	size of metering area
	stq	gmelen-*	this is how much to copy
	iaq	14	extra stuff copied from elsewhere
gme020	stq	gmesiz-*	save size
	tsy	a.s003-*,*	getmem
	die	10	please not
	stx3	gmebuf-*	save address of buffer
	ldq	gmelen-*	get copying length
gme030	lda	0,2	copy a word
	sta	0,3
	iacx2	1	move to next
	iacx3	1
	iaq	-1	any more?
	tnz	gme030-*	yes
	rem
	szn	a.s001-*,*	(tibadr) for a subchannel?
	tnz	gme040-*	yes
	rem		no, fill in some extra fnp-wide stuff
	ldx2	a.s010-*	addr (.crbdt)
	ldaq	0,2	get bootload time
	staq	0,3
	ldaq	2,2	all 4 words of it
	staq	2,3
	ldx2	a.s011-*,*	(.crsked) get pointer to idle meters
	ldaq	0,2	this is 8 words
	staq	4,3
	ldaq	2,2
	staq	6,3
	ldaq	4,2
	staq	8,3
	ldaq	6,2
	staq	10,3
	ldaq	a.s012-*,*	(yelcnt) get edac error count
	staq	12,3
	rem
gme040	ldx2	a.s004-*	addr (dcws) -- put dcw list in usual place
	stx2	a.s005-*,*	dcwadr
	ila	4	set length
	sta	a.s006-*,*	dcwlen
	rem
	ldx3	gmesx3-*	get mailbox pointer
	lda	sm.cd,3	get cs address
	ilq	diaftc	fnp -> cs transfer
	staq	0,2
	lda	gmebuf-*	get pointer to data
	ora	l.s001-*	0,w.2 for dia
	ldq	gmesiz-*	get data length
	qrs	1	in 36-bit words
	staq	2,2	rest of dcw
	iacx2	4	point to place for next dcw
	cx2a		but bdisc wants it in x3
	cax3
	tsy	a.s007-*,*	(bdisc) disconnect dcw
	ila	tcmetr	set transaction control word
	sta	a.s008-*,*	tcword
	tsy	a.s009-*,*	conect
	return	gmeter
	rem
	rem
a.s001	ind	tibadr
a.s002	ind	.mdilc
a.s003	ind	getmem
a.s004	ind	dcws
a.s005	ind	dcwadr
a.s006	ind	dcwlen
a.s007	ind	bdisc
a.s008	ind	tcword
a.s009	ind	conect
a.s010	ind	.crbdt
a.s011	ind	.crskd
a.s012	ind	yelcnt
	rem
l.s001	zero	0,w.2
	rem
	rem
gmebuf	bss	1	address of temporary space for meters
gmesiz	bss	1	size of same
gmelen	bss	1	length to copy from metering area
	ttls	makdly -- allocate new delay table
	rem
	rem	this subroutine takes a list of delay values and associates
	rem	them with a given line. It does this by searching the chain of delay
	rem	tables starting at .crdly, and if it finds one matching the
	rem	supplied values it increases its reference count; if
	rem	none is found, it chains a new one on to the end. t.dtp is
	rem	updated accordingly.
	rem
	rem	input:
	rem	   x1 -> virtual tib address
	rem	   x2 -> array of 6 delay values
	rem
	rem
makdly	subr	mak,(x2,x3)
	rem
	ilq	dl.siz-dl.hsz	count of values
	ldx3	maksx2-*	use x3 for tbl clobberably
mak010	szn	0,3	find out if all are zero
	tnz	mak020-*	clearly not
	iacx3	1	check next
	iaq	-1	are there more?
	tnz	mak010-*	yes
	ila	0
	cax3		indicate no table
	tra	mak030-*	and go delete old one
	rem
mak020	null
	ldx3	a.p001-*	addr (.crdly) -- start looking at existing tables
	ilq	dl.siz-dl.hsz	table size
	tsy	a.p004-*,*	(=cmptbl) x2 -> table
	tra	mak040-*	didnt find it, x3 is last
	rem		come here if corresponding table already exists
	cmpx3	t.dtp,1	already in use by this line?
	tze	makret-*	yes, nothing to do
	aos	dl.rfc,3	up the reference count
	rem
mak030	null		here to update t.dtp and free old table
	tsy	deldly-*	free old one
	stx3	t.dtp,1	save it in tib
	rem
makret	return	makdly
mak040	null		table does not already exist
	ilq	dl.siz	allocate a new block
	tsy	a.p002-*,*	=newtbl
	tra	mak030-*
	rem
	ttls	deldly -- free delay table
	rem
	rem	frees delay table pointed to by t.dtp
	rem	if reference count > 1, just reduces it
	rem
	rem	x1 -> virtual tib address
	rem
	rem
deldly	subr	dld,(x3)
	rem
	ilq	dl.siz	use delay tbl size
	cx1a		use t.dtp
	iaa	t.dtp
	cax3		get tbl ptr in x3
	tsy	deltbl-*
	return	deldly
	rem
	rem	delete any table
	rem	delay or echnego
	rem	x1 = tib (not used)
	rem	x3 = ptr to tib tbl ptr word
	rem	q = size of table (for fremem)
	rem
deltbl	subr	del,(x1,x2,x3,q)
	ldx3	0,3	is there an old table?
	tze	delret-*	no, forget it
	rem
	lda	dl.rfc,3	anyone else using it?
	iaa	-1
	sta	dl.rfc,3	decrement ref count
	tnz	delret-*	someone else wants it, leave it alone
	rem
	ldx1	dl.bck,3	get pointer to previous block
	ldx2	dl.fwd,3	and next one
	tze	2	is no next one
	stx1	dl.bck,2	if there is, attach it to previous one
	stx2	dl.fwd,1	correct previous block's forward ptr
	rem		note: even if freed block is first one, its
	rem		backptr points to .crdly or .cretb
	rem
	rem		q has right size at this point.
	tsy	a.p003-*,*	=fremem
	rem
delret	return	deltbl
	rem
	rem
	rem
a.p001	ind	.crdly
a.p002	ind	newtbl
a.p003	ind	fremem
a.p004	ind	cmptbl
	rem
	ttls	table sharing routines
	rem
	rem	compare tables for sharing
	rem	x1 => tib (saved, not used)
	rem	x2 => values in table
	rem	x3 -> chain head
	rem	q = size of table data
	rem
cmptbl	subr	cmt,(x2,q)
	rem
cmt010	null
	lda	0,3	get next in chain
	tze	cmt050-*	there are no more
	sta	cmtbuf-*
	cax3		find out if this one matches new one
	iacx3	dl.hsz	start at first value
cmt020	lda	0,2
	cmpa	0,3	values equal?
	tze	cmt030-*	yes, look at next
	ldx3	cmtbuf-*	no, see if there are more in chain
	ldx2	cmtsx2-* restore pointer to first value
	ldq	cmtsq-*	restore count
	tra	cmt010-*
	rem
cmt030	iaq	-1	checked all values?
	tze	cmt040-*	yes, we've found matching table
	iacx2	1	no, move to next value
	iacx3	1
	tra	cmt020-*	and test again
	rem
cmt040	ldx3	cmtbuf-*
	aos	cmptbl-*
cmt050	return	cmptbl
	rem
cmtbuf	bss	1
	rem
	rem
	rem	subr to allocate a new table
	rem	x2 -> table data
	rem	x3 -> end of previous chain
	rem	q = data size, incl.header
	rem	return x3 -> new block
	rem
newtbl	subr	nwt,(x2,x3,q)
	rem
	tsy	a.p501-*,*	=getmem
	die	10	if we can't get one, horrors.
	stx3	nwttmp-*	this is the new one
	rem
	ldx2	nwtsx3-*	thread it to previous one
	stx2	dl.bck,3
	stx3	dl.fwd,2
	ila	1	initialize reference count
	sta	dl.rfc,3
	iacx3	dl.hsz	point to first value
	ldx2	nwtsx2-*	restore pointer to supplied values
	ldq	nwtsq-*	get table length
	iaq	-dl.hsz	dont copy the header!
nwt010	lda	0,2
	sta	0,3
	iaq	-1	got 'em all ?
	tze	nwt020-*	yes
	iacx2	1	no, get another
	iacx3	1
	tra	nwt010-*
nwt020	null
	ldx3	nwttmp-*
	stx3	nwtsx3-*
	return	newtbl
	rem
a.p501	ind	getmem
nwttmp	bss	1
	rem
	ttls	makecn - make echnego table
	rem
	rem	make an echo negotiation bit table
	rem	try to share it like a delay table
	rem
	rem
makecn	subr	mnt,(x2,x3)
	rem
mnt010	null
	ldx3	a.y001-*	addr (.cretb) -- start looking at existing tables
	ilq	ecnlen	table size
	tsy	a.y002-*,*	(=cmptbl) x2 -> table
	tra	mnt040-*	didnt find it, x3 is last
	rem		come here if corresponding table already exists
	cmpx3	t.entp,1	already in use by this line?
	tze	mnt030-*	yes, nothing to do
	aos	dl.rfc,3	up the reference count
	rem
mnt020	null		here to update t.dtp and free old table
	tsy	deletb-*	free old one
	stx3	t.entp,1	save it in tib
	rem
mnt030	return	makecn
mnt040	null		table does not already exist
	ilq	dl.hsz+ecnlen	allocate a new block
	tsy	a.y003-*,*	=newtbl
	tra	mnt020-*

	rem
a.y001	ind	.cretb
a.y002	ind	cmptbl
a.y003	ind	newtbl
	rem
	rem	Free echo negotiation table
deletb	subr	dle,(x3)
	rem
	ilq	dl.hsz+ecnlen
	cx1a
	iaa	t.entp
	cax3
	tsy	a.y501-*,*	(=deltbl)
	return	deletb
	rem
a.y501	ind	deltbl
	rem
	ttls	ecgifl  -- echnego input flush (to 6180)
	rem	send icp chains off to dcp chain (dia queue)
	rem	so echnego sync requests work.
	rem
ecgifl	subr	ecf
	rem
	szn	t.icp,1	do we have an icp chain?
	tze	ecfret-*
	ilq	accin	send accept input
	tsy	a.y601-*,*	(denq)
ecfret	return	ecgifl
	rem
a.y601	ind	denq
	rem
	ttls	rblast -- subroutine to set up dcw for reading blast message
	rem
	rem	mailbox address passed in x3
	rem	address field of mailbox (word 10) points to
	rem	6-buffer area containing blast message in three languages
	rem	(two buffers per message)
	rem
rblast	subr	rbl,(x3)
	ldx2	a.t003-*	(dcws)
	stx2	a.t004-*,*	(dcwadr) tell conect to use usual dcw place
	ila	4
	sta	a.t005-*,*	dcwlen
	rem
	lda	sm.adr,3	get cs address
	ilq	diactf	read cs opcode
	staq	0,2	into dcw
	ilq	6*bufsiz	get three double buffers together
	tsy	a.t001-*,*	(getbfh)
	die	10	oh my god
	sta	a.t007-*,*	(blbuf) for dtrans
	ilq	3*bufsiz	3 buffers worth of 36-bit words
	staq	2,2	put in dcw
	lda	l.t005-*	=absflg
	orsa	3,2	put absolute address flag in dcw
	iacx2	4	next dcw
	cx2a
	cax3		into x3 for bdisc
	tsy	a.t006-*,*	(bdisc) build disconnect dcw
	return	rblast	done
	ttls	acusr -- subroutine to handle dial out request
	rem
	rem	this routine sets the tfacu flag in the tib and then
	rem	it copies the phone number that has been passed
	rem	to the fnp in the command data portion of the mailbox
	rem	into a buffer (coverting the 6bit bcd into 9bit)
	rem	and invokes the control table interpreter at the test state
	rem	entry.
	rem
acusr	subr	acu
	rem
	lda	t.flg3,1	was the channel masked?
	cana	l.t006-*	=tfmask
	tze	acu005-*	no
	tsy	a.t008-*,*	(hunmsk) if so, unmask it now
acu005	null
	rem
	trace	mt.acu,tr.mbx,(sm.cdl(3),sm.cd(3),sm.cd+1(3),sm.cd+2(3),s
	etc	m.cd+3(3))
	rem
	lda	l.t001-*	(tfacu)
	orsa	t.flg2,1	set flag on
	rem		now to get a buffer
	lda	sm.cdl,3	get number of digits
	ana	l.t007-*	(low-order 9 bits only)
	tpl	acu010-*	must be at least 1 digit
	die	8	bad acu request, stop
	rem
acu010	null
	cx3a		getbuf restores all but x3
	cax2		x2 will contain addr of mailbox
	ilq	bufsiz	get a buffers worth
	tsy	a.t001-*,*	(getbuf)
	die	10	no buffers means bad problems
	stx3	t.ocp,1	remember absolute addr of buffer
	ldq	sm.cdl,2	get number of digits
	qls	9	reduce to lower half-word only
	qrl	9
	stq	1,3	store as tally in buffer
	iacx3	bf.dta	set x3 to addr of data part of buffer
	iacx2	sm.cd	set x2 to addr of command data part of mailbox
	rem
	rem		now to copy 6bit chars from mailbox into
	rem		9bit chars in buffer. number of characters
	rem		to move is in q.
	rem
	cx2a
	ora	l.t002-*	(0,c.0) change x2 to 6bit chars
	cax2
	cx3a
	ora	l.t003-*	(0,b.0) change x3 to 9bit chars
	cax3
	rem
acumvc	null
	lda	0,2,c.0	load 6bits right justified (other bits of q are zeroed)
	sta	0,3,b.0	store rightmost 9bits
	iacx2	0,c.1	move 1 char to right
	iacx3	0,b.1	move 1 byte to right
	iaq	-1	decrement count of digits remaining
	tpl	acumvc-*	stop when count goes to zero
	tsy	a.t002-*,*	(itest)
	return	acusr
	rem
a.t001	ind	getbuf
a.t002	ind	itest	"test_state" entry of interpreter
a.t003	ind	dcws
a.t004	ind	dcwadr
a.t005	ind	dcwlen
a.t006	ind	bdisc
a.t007	ind	blbuf	place to store address of blast buffers
a.t008	ind	hunmsk
	rem
l.t001	vfd	18/tfacu
l.t002	zero	0,c.0	for setting '6bit char mode'
l.t003	zero	0,b.0	for setting '9bit char mode'
l.t004	zero	0,w.2	for setting 36-bit mode
l.t005	vfd	18/absflg
l.t006	vfd	18/tfmask
l.t007	oct	000777
	rem
	ttls	fetch -- subroutine to get next item to satisfy an rcd
	rem
	rem	this routine first checks error message queue;
	rem	otherwise entry is taken from queue for a tib
	rem	inputs: none
	rem
	rem	outputs:
	rem	x2: pointer to queue entry
	rem
fetch	subr	fet,(a,q,x3)
	rem
	szn	a.o001-*,*	(=errqbf) anyting in error queue?
	tze	fet010-*	no
	lda	a.o002-*	(=errqtb) addr of simulated tib table
	sta	a.o007-*,*	(=curque)
	tra	fet050-*
	rem
fet010	null
	ldx2	dqcur-*	look at tib table entry whose turn it is
	tnz	fet020-*	if it's never been set,
	ldx2	a.o004-*,*	set it to .crttb
fet020	null
	cmpx2	a.o003-*,*	(.crtte) time to wrap around?
	tnz	2
	ldx2	a.o004-*,*	.crttb
	rem
	szn	qbuf,2	is there a queue for this line?
	tnz	fet040-*	yes, go get something out of it
fet030	null
	iacx2	2	look at next tib entry
	cmpx2	dqcur-*	have we gone all the way around?
	tnz	fet020-*
	die	9	yes, spurious rcd
	rem
fet040	stx2	a.o007-*,*	(=curque) save current tib table entry
fet050	tsy	a.o008-*,*	(=getqhd) get head of queue
	die	8	queue can't be empty
	rem
	lda	0,2	pick up first word of entry
	tpl	fet060-*	not already picked up
	ldx2	a.o007-*,*	pick up current queue
	tra	fet030-*	back tp bump to next
fet060	iana	255	mask down to opcode
	tnz	2	make sure it's more or less legal
	die	8
	rem
	lda	l.o001-*	(=400000) set active bit
	orsa	0,2
	ldx3	a.o007-*,*	(curque) get current tib table entry
	cmpx3	a.o002-*	(errqtb) is it error queue?
	tze	fetbak-*	yes
	iacx3	2	bump i/o queue to next tib
	stx3	dqcur-*
fetbak	return	fetch
	rem
	rem
a.o001	ind	errqbf
a.o002	ind	errqtb
a.o003	ind	.crtte
a.o004	ind	.crttb
	rem
a.o006	ind	dlqent
a.o007	ind	curque
a.o008	ind	getqhd
	rem
l.o001	oct	400000
	rem
dqcur	ind	0	pointer to entry in tib table whose turn it is
	ttls	getque -- finds entry in tib i/o queue list
	rem
	rem	this subroutine finds the entry in the tib i/o queue list
	rem	for a given tib
	rem
	rem	input:
	rem	a: real tib address
	rem
	rem	output:
	rem	x2: address of entry in list
	rem
	rem	if there is none, we will crash
	rem
getque	subr	gtq
	rem
	ldx2	a.o004-*,*	(.crttb) get pointer to tib table base
gtq010	null
	cmpa	qtib,2	is this the one?
	tze	gtqbak-*	yes, we got it
	iacx2	2	no, look at next
	cmpx2	a.o003-*,*	(.crtte)
	tnz	gtq010-*	if there are any more
	die	22	else crash
	rem
gtqbak	stx2	a.o007-*,*	(=curque) save current queue addr
	return	getque
	ttls	reject -- subroutine to reschedule rejected accept input
	rem
	rem	this subroutine finds the rejected accept input for the tib
	rem	pointed to by x1, marks it "rejected", and schedules
	rem	dretry routine to try it again a second later
	rem
	rem	x1 - virtual tib address
	rem
reject	subr	rej
	lda	a.q001-*,*	(tibadr) need real tib address for getque
	tsy	getque-*
	rem		x2 -> tib queue entry
	tsy	a.q004-*,*	(=getqai) find first accept input
	die	16	better be one
	szn	a.q005-*,*	(=nonnai) better be nothing before it
	tze	2
	die	16
	rem
	lda	0,2	is there a quit or hangup behind it?
	cana	l.q001-*	=quitfl
	tze	rej040-*	no
	tsy	a.q002-*,*	(cleanq) yes, remove all accept inputs
	rem		from queue
	tra	rejbak-*
	rem
rej040	null		mark entry rejected
	ora	l.q002-*	=rejflg
	sta	0,2
	ldx1	a.q001-*,*	(tibadr) need real address for dspqur
	ldaq	l.q003-*	delay time, priority, and address of dretry
	tsy	a.q003-*,*	dspqur
	rem
rejbak	return	reject
	rem
	rem
a.q001	ind	tibadr	real tib address
a.q002	ind	cleanq
a.q003	ind	dspqur
a.q004	ind	getqai
a.q005	ind	nnonai
	rem
l.q001	vfd	18/quitfl
l.q002	vfd	18/rejflg
	even
l.q003	vfd	12/1,6/rtprty	delay time, priority, and address
	ind	dretry	for scheduling dretry
	ttls	cleanq -- remove accept inputs from queue with a reject
	rem
	rem	this routine is called to remove all accept input requests
	rem	from a line's i/o queue so that quits and hangups will go
	rem	through although an input request has been rejected
	rem
	rem	input:
	rem	     x1: virtual tib address
	rem	     x2: address of first accept input in queue
	rem
cleanq	subr	cle,(a,q,x2,x3)
	rem
	lda	t.dcp,1	free any input chain(s)
	tze	cle003-*
	tsy	a.r001-*,*	frelbf
	stz	t.dcp,1
	stz	t.dlst,1
	stz	t.dcpl,1
cle003	null
	lda	t.icp,1
	tze	cle006-*
	tsy	a.r001-*,*
	stz	t.icp,1
	stz	t.ilst,1
	stz	t.icpl,1
	rem
cle006	null
	lda	a.q005-*,*	(=nnonai) number of queue entries before first accin
	sta	savnai-*	will need this in a second
	tsy	a.r003-*,*	(=dlqent) delete the accept inpuut
cle010	tsy	a.r004-*,*	(=getqai) find first accept input again
	tra	cle020-*	none, queue is clean
	tsy	a.r003-*,*	(=dlqent) delete this accept input
	tra	cle010-*	back to find another
cle020	lda	a.q005-*,*	(=nnonai) this is total entries now in queue
	sba	savnai-*	subtract out number before the first accin
	rem		that used to be there and get the number
	rem		if new mailboxes needed
	tze	2	were none, do nothing
	asa	a.r002-*,*	qcnt
	rem
	return	cleanq
	rem
	rem
a.r001	ind	frelbf
a.r002	ind	qcnt
a.r003	ind	dlqent
a.r004	ind	getqai
	rem
savnai	bss	1
	ttls	incnt -- subroutine to get input character count
	rem
	rem	this subroutine gets count of input characters
	rem	for "accept input" in order to send the count to the
	rem	cs
	rem	it also sets the "break" flag in the mailbox if appropriate
	rem
	rem	x1 -- virtual tib address
	rem	x3 -- mailbox address
	rem
incnt	subr	inc,(x2,x3)
	rem
	stz	icount-*	initialize character count
	stz	iflags-*	and break char flag
	stz	nbufs-*	and buffer count
	lda	a.h001-*	addr (tallys)
	sta	tallyp-*	initialize temporary tally array pointer
	lda	t.dcp,1	point to beginning of input chain
	rem
inc010	null
	aos	nbufs-*	bump buffer count
	tsy	a.h003-*,*	setbpt
	cax2		get virtual address
	lda	bf.tly,2	get tally from buffer
	ana	l.h001-*	=buftmk
	tnz	2	if it's zero, something's very wrong
	die	21
	rem
	asa	icount-*	add it into count
	sta	tallyp-*,*	save it in temporary array
	aos	tallyp-*	bump array pointer
	lda	bf.flg,2	is break flag in buffer on?
	cana	l.h002-*	=bffbrk
	tze	inc020-*
	ilq	1
	stq	iflags-*	yes, turn it on in mailbox
	rem
inc020	null		last buffer?
	cana	l.h003-*	=bfflst
	tze	inc030-*	no, go to next
	rem		else we're done
	trace	mt.inc,tr.que,(icount,t.line(1))
	rem
	szn	t.ocp,1	is there any kind of output chain?
	tnz	inc025-*
	szn	t.ocur,1
	tze	inc040-*	no
	rem
inc025	ila	2	yes, set flag in command data
	orsa	iflags-*
	rem
inc040	lda	iflags-*	store flags
	sta	sm.fcd,3
	lda	icount-*	get total char count
	icmpa	mbxmax	will it fit in mailbox?
	tmi	inc050-*	yes, go copy the data
	sta	sm.ict,3	no, put the char count in the mbx
	lda	a.h002-*	addr (sm.dcw)+1
	sta	incdcw-*	initialize pointer to dcws in mbx
	ila	0
	ldq	nbufs-*	get number of buffers in chain
	staq	sm.nbf,3	put it in mbx
	rem		we'll count it in q
	lda	a.h001-*	reinitialize pointer to temp array of tallies
	sta	tallyp-*
	rem
inc045	lda	tallyp-*,*	get next tally
	sta	incdcw-*,*	store it in mbx
	iaq	-1	count it
	tze	incbak-*	finished when we reach zero
	aos	tallyp-*	bump pointers
	ila	2
	asa	incdcw-*
	tra	inc045-*	back for next one
	rem
inc050	ila	inmbx	change opcode
	als	9	to "input in mailbox"
	iora	rcd	(keep it rcd)
	sta	sm.op,3
	cx3a
	ada	l.h006-*	(sm.dat,b.0) point x3 at mailbox data area
	cax3
	lda	t.dcp,1	point x2 at input chain
	sta	oldhed-*	save it for later freeing
	stz	icount-*	start count over
inc060	tsy	a.h003-*,*	setbpt
	cax2
	lda	bf.tly,2
	ana	l.h001-*	buftmk
	asa	icount-*	keep count of total number
	stx2	ibufp-*	remember current buffer address
	caq		hold running count in q
	cx2a
	ada	l.h007-*	(bf.dta,b.0) get pointer to data in buffer
	cax2
inc080	lda	0,2,b.0	get a character form the buffer
	sta	0,3,b.0	store it in mailbox
	iacx2	0,b.1	bump pointers
	iacx3	0,b.1
	iaq	-1	count the character
	tnz	inc080-*	if more, go get the next one
	ldx2	ibufp-*	no more, get buffer pointer back in x2
	lda	bf.flg,2	last one?
	cana	l.h003-*	bfflst
	tnz	inc090-*	yes, wrap it up
	lda	bf.nxt,2	no, get forward pointer
	tra	inc060-*	process next buffer
	rem
inc090	null
	lda	icount-*	get final count
	ldx3	incsx3-*	get saved mailbox address
	sta	sm.ict,3
	aos	shinp-*	set flag showing short input in progress
	rem
incbak	return	incnt
	rem
inc030	null
	lda	bf.nxt,2
	tnz	inc010-*	go process next buffer
	rem		if there isn't one, something's wrong
	die	11
	rem
	rem
	rem
	rem
a.h001	ind	tallys	pointer to tally array
a.h002	ind	sm.dcw+1,3	pointer to lower half of dcws
a.h003	ind	setbpt
	rem
	rem
l.h001	vfd	18/buftmk
l.h002	vfd	18/bffbrk
l.h003	vfd	18/bfflst
l.h004	oct	777774
*l.h005	unused
l.h006	zero	sm.dat,b.0
l.h007	zero	bf.dta,b.0
l.h008	oct	777000
	rem
nbufs	bss	1	number of buffers processed so far
icount	bss	1	number of characters processed
iflags	bss	1	flags for sending back to multics
increm	bss	1	amount by which tally has beeen adjusted
itally	bss	1
ibufp	bss	1
shinp	bss	1	global dia_man flag indicating short input transaction
tallyp	bss	1	pointer to current element of tally array
incdcw	bss	1	pointer to current pseudo-dcw in mailbox
tallys	bss	24	temporary array of buffer tallies
	ttls	indata -- sets up dcw list for rtx
	rem
	rem	this subroutine sets up a dcw list for sending
	rem	an input chain to the cs
	rem	the mailbox in "savmbx" has the following information
	rem	in (18-bit) words 8-11:
	rem
	rem	word 8:	second address or 0
	rem	word 9:	second tally or 0
	rem	word 10:	data address
	rem	word 11:	tally
	rem
	rem	words 8 and 9 are only used if cs is supplying
	rem	two addresses because of wraparound in its circular
	rem	input buffer
	rem
	rem	tallies are in characters
	rem
	rem	x1: virtual tib address
	rem
indata	subr	ind
	ldx3	a.i001-*	addr(dcws)
	stx3	a.i002-*,*	dcwadr
	stx3	curdcw-*	initialize dcw pointer
	stz	a.i003-*,*	initialize dcwlen
	ldx3	a.i004-*	addr(savmbx) -- get mailbox address
	rem
	lda	t.dcp,1	get pointer to first buffer
	sta	oldhed-*	hang on to it for later freeing
	iacx3	sm.dcw	point to dcw array in mbx
	stx3	pdcwa-*
	stz	nblks-*	initialize this too
	rem
ind010	null
	sta	curabs-*	save absolute address of current buffer
	tsy	a.i008-*,*	setbpt
	cax2		get virtual address
	lda	bf.siz,2	find out how many blocks long this buffer is
	arl	15
	iaa	1
	asa	nblks-*	keep running count
	lda	bf.tly,2	get buffer tally
	ana	l.i001-*	=buftmk
	caq		put tally in q
	lda	curabs-*	recover buffer address
	iaa	bf.dta	get fnp address in a
	tsy	indcw-*	make the dcw
	rem
	lda	bf.flg,2	is this last buffer?
	cana	l.i002-*	=bfflst
	tnz	ind050-*	yes,finish up
	lda	bf.nxt,2	no, get next buffer
	tnz	ind010-*
	die	11	 bad news if there isn't one
	rem
ind050	null		no more input buffers
	ldq	nblks-*
	tsy	instrp-*	take buffers of dcp chain
	ldx3	curdcw-*	get dcw address
	rem		to set timw bit
	rem		and make interrupt and disconnect dcws
	tsy	a.i007-*,*	wtimw (which updates x3 itself)
	tsy	a.i005-*,*	bint
	iacx3	4
	tsy	a.i006-*,*	bdisc
	ila	8	update dcw length
	asa	a.i003-*,*	dcwlen
	return	indata	all done
	rem
	ttls	indcw -- build dcw for indata
	rem
	rem	input:
	rem	a -- fnp address
	rem	q -- tally in characters
	rem
	rem	curdcw contains address of dcw to be built
	rem	pdcwa contains pointer to next pseudo-dcw
	rem	   containing cs address
	rem	both of these are to be updated
	rem	as is dcwlen (no. of 36-bit words in dcw list)
	rem
indcw	subr	inw,(a,q,x3)
	rem
	ldx3	curdcw-*	get dcw pointer
	iaq	3	convert tally to words
	qrs	2	(words = (char+3)/4)
	staq	2,3	put tally and fnp address in dcw
	lda	l.i003-*	=absflg
	orsa	3,3	mark dcw for absolute addressing
	ldaq	pdcwa-*,*	get next absolute cs address
	llr	6	get low-order 18 bits in a
	qls	12	isolate high-order part of address
	qrl	6	it ends up in bits 24-29 of dcw
	staq	0,3	store in dcw
	rem
	ila	diaftc	get opcode (fnp -> cs transfer)
	orsa	1,3	store in dcw
	ila	4
	asa	curdcw-*	update dcw pointer
	ila	2	and list length
	asa	a.i003-*,*	dcwlen
	asa	pdcwa-*
	return	indcw	that's all
	ttls	instrp -- subroutine to strip input buffers of t.dcp chain
	rem
	rem	removes input buffers that have been sent from t.dcp chain
	rem	and adjusts t.dcpl accordingly
	rem
	rem	input:
	rem	q -- number of buffers in chain sent
	rem
instrp	subr	ins,(q)
	lda	t.dcpl,1	we've removed some blocks from t.dcp chain
	sba	inssq-*	this many
	sta	t.dcpl,1
	lda	bf.nxt,2	save next-pointer from last buffer
	sta	t.dcp,1	will be head of next input chain
	tnz	2	if there isn't another chain,
	stz	t.dlst,1	kill tail pointer
	stz	bf.nxt,2	zero next-pointer so chain can be freed
	return	instrp
	ttls	storage for indata and indcw
	rem
a.i001	ind	dcws
a.i002	ind	dcwadr
a.i003	ind	dcwlen
a.i004	ind	savmbx
a.i005	ind	bint
a.i006	ind	bdisc
a.i007	ind	wtimw
a.i008	ind	setbpt
	rem
	rem
l.i001	vfd	18/buftmk
l.i002	vfd	18/bfflst
l.i003	vfd	18/absflg
	rem
	rem
oldhed	bss	1	head of input chain being sent
curdcw	bss	1	address of current dcw
pdcwa	bss	1	address of current pseudo-dcw in mailbox
blimit	bss	1	highest allowed cs address + one
nblks	bss	1	number of 32-word blocks used by input chain
curabs	bss	1	absolute address of current buffer
	rem
	ttls	rddcw -- set up dcw list to read cs dcw list
	rem
	rem	this subroutine is called when a decoded mailbox
	rem	contains a wtx command
	rem
	rem	the mailbox contains (in words 10-11) the address
	rem	and length (in 36-bit words) of a cs dcw list
	rem	for transmitting the output data
	rem
	rem	this routine creates dia dcw list to read the cs
	rem	dcw list (the "pseudo-dcws") into a static area
	rem
	rem	x3 contains the mailbox address
	rem
rddcw	subr	rdw,(x3)
	rem		set up dcw address and length for conect
	ldx2	a.j001-*	addr(dcws)
	stx2	a.j002-*,*	dcwadr
	ila	4
	sta	a.j003-*,*	dcwlen
	rem
	ldaq	sm.adr,3	get address and length of cs dcw list
	cmpa	blimit-*	make sure it's probably in buffer area
	tnc	rdw010-*	it isn't
	stq	ndcws-*	save length
	stq	3,2	put tally in dcw
	ilq	diactf	get cs->fnp transfer opcode
	staq	0,2	put it in dcw
	rem
	lda	a.j006-*	get address of pseudo-dcw area (pdcws)
	sta	2,2	put in fnp address of dcw
	rem
	iacx2	4	bump dcw pointer
	cx2a		copy it into x3 to make disconnect dcw
	cax3
	tsy	a.j005-*,*	bdisc
rdwbak	return	rddcw	all done
	rem
rdw010	die	20
	rem
	ttls	rddata -- set up dcw list to read output data
	rem
	rem	this subroutine uses the pseudo-dcws read from
	rem	the cs by rddcw to set up a dia dcw list for
	rem	reading in the output data itself
	rem
	rem	the dcws will be built in a static area (dcws) and
	rem	a chain of buffers will be allocated for the data
	rem
rddata	subr	rdd
	rem
	ldx1	a.j001-*	(dcws) get address of dcw list area
	stx1	a.j002-*,*	(dcwadr) setup dcw list address for conect
	lda	ndcws-*	length of dcw list is
	iaa	1	2*(ndcws+1) because of disconnect dcw
	als	1
	sta	a.j003-*,*	(dcwlen) setup dcw list length for conect
	rem
	ldx2	a.j006-*	get pointer to first pseudo-dcw
	stz	rhead-*	init head of chain addr
	stz	rtail-*	init tail of chain addr
	lda	ndcws-*	get number of dcws
	iera	-1	negate it
	iaa	1
	sta	dcwcnt-*	init loop counter
	rem
rdd010	null
	ldq	1,2	get character tally
	tnz	2	zero ain't posssible
	die	20
	iaq	67	4 chars overhead + 63 to round up
	qrs	6	divide by 64 (chars per buffer)
	qls	bufshf	multiply by words per buffer
	tsy	a.j004-*,*	getbfh
	tra	rdd030-*	failed, go clean up
	caq		put new buffer addr in q
	lda	rtail-*	get addr of prev buffer
	tze	rdd015-*	no prev buffer
	tsy	a.j009-*,*	setbpt
	cax3
	stq	bf.nxt,3	chain to next buffer
	tra	2
rdd015	stq	rhead-*	save head of chain
	stq	rtail-*	save tail of chain
	cqa		put new buffer addr in a
	tsy	a.j009-*,*	setbpt
	cax3		convert it into x3
	rem
	lda	0,2	get cs address from pseudo-dcw
	tze	rdd040-*	zero address is unlikely to be right
	cmpa	blimit-*	so is one below the buffer area
	tnc	rdd040-*
	ilq	diactf	cs -> fnp transfer opcode
	staq	0,1	put in dcw
	lda	1,2	get character tally
	orsa	bf.tly,3	put it in buffer
	iaa	3	convert to words
	ars	2	right-adjust
	ora	l.j002-*	=absflg
	lrs	18	and put in q
	lda	rtail-*	get absolute buffer address
	iaa	bf.dta	get pointer to output buffer data
	staq	2,1	put fnp address and tally in dcw
	rem
	iacx1	4	point to next place for dcw
	aos	dcwcnt-*	increment loop counter
	tze	rdd020-*	done if zero
	iacx2	2	get addr of next pseudo-dcw
	tra	rdd010-*	build next dcw
	rem
rdd020	null		through building dcws
	rem		except for disconnect
	cx1a		put addr of next dcw ...
	cax3		in x3 (for bdisc)
	tsy	a.j005-*,*	bdisc
	aos	rddata-*	give success return
	rem
rddbak	return	rddata
	rem
rdd030	null		couldn't allocate enough data buffers
	lda	rhead-*	must free data buffers
	tze	rddbak-*	none allocated yet
	tsy	a.j008-*,*	frelbf
	tra	rddbak-*	cleanup and take error exit
	rem
rdd040	die	20
	ttls	storage for rddcw and rddata
	rem
a.j001	ind	dcws	static dcw list area
a.j002	ind	dcwadr	conect's address of base of dcw list
a.j003	ind	dcwlen	length of dcw list (36-bit words)
a.j004	ind	getbfh	subroutine to get a buffer from high memory
a.j005	ind	bdisc	subroutine to make a disconnect dcw
a.j006	ind	pdcws	address of static pseudo-dcw area
a.j007	ind	frebuf	subroutine to release a single buffer
a.j008	ind	frelbf	subroutine to free linked list of buffers
a.j009	ind	setbpt	subroutine to convert buffer address to 15-bit
	rem
	rem
l.j001	vfd	18/buftmk
l.j002	vfd	18/absflg	absolute address ing in dcw
	rem
	rem
ndcws	bss	1	number of cs dcws in list
rhead	bss	1	address of head of allocated output chain
rtail	bss	1	address of last buffer in allocated chain
dcwcnt	bss	1	dcw loop counter
	even
pdcws	bss	16*2	space for reading in pseudo-dcws
	ttls	bint -- builds an "interrupt cs" dcw
	rem
	rem	interrupt cell assignment has been set by init
	rem	from configuration status
	rem
	rem	x3 points to dcw to be built
	rem
bint	subr	bin
	rem
	ldaq	intdcw-*	get interrupt cell and opcode
	staq	0,3
	lda	l.z001-*	0,w.2
	ilq	0
	staq	2,3	this stuff will be ignored, but should be 36-bit
	return	bint
	rem
	ttls	bdisc -- builds a "disconnect" dcw
	rem
	rem	a "disconnect" dcw will be put at the address
	rem	pointed to by x3
	rem
bdisc	subr	bdi
	rem
	ila	0
	ilq	diadis	disconnect opcode
	staq	0,3
	lda	l.z001-*	0,w.2 (make unused fnp address 36-bit addressing)
	ilq	0
	staq	2,3
	return	bdisc
	rem
l.z001	zero	0,w.2
	rem
	even
intdcw	oct	0
dindcw	vfd	12/0,6/diainc	interrupt cell is or'ed in at init time
	rem
	ttls	lock and unlock -- control the dia lock
	rem
	rem	no new dia activity is initiated while the dia
	rem	lock is locked
	rem
lock	subr	loc,(inh)
	rem
	szn	dilock-*	lock already locked?
	tze	2
	die	14	yes, we shouldn't be locking it again
	rem
	lda	lock-*	no, lock it with address of caller
	sta	dilock-*
	return	lock
	rem
	rem
	rem
unlock	subr	unl,(inh)
	rem
	szn	dilock-*	is it unlocked?
	tnz	2
	die	15	then we shouldn't be trying to unlock it
	rem
	stz	dilock-*	unlock it now
	return	unlock
	rem
	rem
dilock	oct	0	dia lock
	rem
	ttls	conect -- connect to the dia
	rem
	rem	this subroutine is called when it's time to
	rem	do a connect to the dia
	rem
	rem	it must:
	rem		store the address and tally (36-bit words)
	rem		of the dcw list in the list icw
	rem
	rem		calculate parity on all the dcws in the list
	rem
	rem		put the list icw address in the pcw mailbox
	rem
	rem		issue the connect
	rem
	rem	dcwadr is preset with the address of the dcw list
	rem	dcwlen is preset with the number of 36-bit words
	rem	this is so that in case of an i/o error we can
	rem	just use the same dcw list again
	rem
conect	subr	con,(inh)
	rem
	lda	a.k003-*,*	globsw
	cana	l.k005-*	(gbfhng) is anyone listening at other end?
	tnz	conbak-*	no, don't bother doing connect
	rem
	lda	dcwadr-*	get pointer to head of list
	cax2
	ora	l.k004-*	0.w,2
	ldq	dcwlen-*	get length
	staq	lsticw-*
	rem
	rem		now calculate parity on dcws
	rem		set bit 21 to be odd parity with bits 0-17
	rem		then set bit 22 to be odd parity with bits 18-35
	rem
con010	null
	lda	l.k001-*	=npbits
	ansa	1,2	turn them both off first
	lda	0,2	get high-order word
	alp	18	get parity
	tnz	con020-*	already odd, do nothing
	lda	l.k002-*	=pupper
	orsa	1,2	or on upper parity bit
	rem
con020	null
	lda	1,2	get second word
	alp	18
	tnz	con030-*	if already odd, don't bother it
	lda	l.k003-*	=plower
	orsa	1,2	or on lower parity bit
	rem
con030	null		on to next dcw word
	iaq	-1	any more?
	tze	con040-*
	iacx2	2	yes, bump pointer
	tra	con010-*	go around again
	rem
con040	null		parity all set
	ldaq	licadr-*	get address and parity of list icw
	staq	a.k001-*,*	(dimb) dia pcw mailbox
	rem		refresh status icw
	ldaq	sticw-*	clean status icw model
	staq	a.k002-*,*	(dist) dia status icw
	ila	1	indicate that connect is pending
	sta	a.k004-*,*	iopend
	rem
	rem
diasel	sel	**	patched by init for correct channel
	cioc	a.k001-*,*	dimb (dia pcw mailbox)
	rem		that's it
conbak	return	conect
	rem
	rem
a.k001	ind	dimb	dia pcw mailbox
a.k002	ind	dist
a.k003	ind	globsw
a.k004	ind	iopend
	rem
l.k001	vfd	18/npbits
l.k002	vfd	18/pupper
l.k003	vfd	18/plower
l.k004	zero	0,w.2	36-bit addressing
l.k005	vfd	18/gbfhng
	rem
	rem
	even
lsticw	icw	dcws,w.2,4	list icw
dlist	null		init uses this to do parity calculations
sticw	icw	stat,w.2,1,1	dia status icw template
	rem		with exhaust bit so we always see latest one
	rem
	even
licadr	zero	lsticw,w.2	list icw address
	oct	70	init will or in parity
	rem
dcwadr	bss	1	address of dcw list
dcwlen	bss	1	length of dcw list (36-bit words)
	even
dcws	bss	4*28	place where most dcw lists are created
	rem
	ttls	wmbx -- write a mailbox to the cs
	rem
	rem	this subroutine writes a mailbox to the cs after
	rem	computing the checksum and storing it in the mailbox
	rem
	rem	a contains address of mailbox to be written, which
	rem	will first be copied into swmbx
	rem	if a is 0, mailbox is already in swmbx, and
	rem	is being rewritten because of checksum error
	rem
	rem	mailbox number in mbxno will be used by wtimw
	rem	to determine what bit to set in cs's
	rem	"terminate interrupt multiplex word" (timw)
	rem	and the mailbox size
	rem
wmbx	subr	wmb
	rem
	cax3		get mailbox address
	tze	wmb020-*	if zero, use swmbx
	rem		else we'll copy it in
	lda	mbxno-*
	icmpa	8	fnp or cs origin?
	tmi	3	cs
	ila	-fmbxsz/2	fnp, use large size
	tra	2
	ila	-8	get repetition count
	sta	rcnt-*
	iera	-1	now make it positive
	iaa	1
	sta	wsize-*
	ldx2	a.l001-*	addr(swmbx)
	rem
wmb010	null
	ldaq	0,3	pick up two words of mailbox
	staq	0,2	copy them
	aos	rcnt-*	is that all?
	tze	wmb020-*
	iacx2	2	no, bump input and output pointers
	iacx3	2
	tra	wmb010-*	do it again
	rem
wmb020	null		set transaction control word
	szn	a.l011-*,*	shinp
	tze	3	if "short input", set it to
	ila	tcinmb	"sent input in mailbox"
	tra	2	else, set it
	ila	tcwmbx	to "wrote mailbox"
	sta	a.l002-*,*	tcword
	rem
	rem		now set up dcw list
	trace	mt.wmb,tr.mbx,(mbxno)
	rem
	ldx3	a.l004-*	addr(dcws)
	stx3	a.l005-*,*	dcwadr
	ila	10	10 words of dcws
	sta	a.l006-*,*	dcwlen
	rem
	lda	mbxno-*	get mailbox number
	icmpa	8	cs mailbox?
	tmi	wmb030-*	yes
	iaa	-8	no, get it in range 0-3
	mpy	l.l004-*	(fmbxsz) use fnp size
	cqa
	iaa	mh.fsb	add base of fnp mailbox area
	tra	wmb040-*
wmb030	null
	als	3	for cs mailbox, use mailbox no. times 8
	iaa	mh.sub	and offset of submailbox 0
wmb040	null
	ada	csmbx-*	add address of cs mailbox header
	ilq	diaftc	fnp->cs transfer opcode
	staq	0,3	cs address and opcode into dcw
	rem
	lda	a.l001-*	get addr(swmbx) in a
	ora	l.l001-*	0,w.2
	ldq	wsize-*	tally for writing mailbox
	staq	2,3	into dcw
	iacx3	4	point to next dcw
	rem		call subroutine to update timw
	tsy	wtimw-*
	rem		dcw pointer is also updated
	rem		now put in interrupt and disconnect dcws
	tsy	a.l007-*,*	bint
	iacx3	4
	tsy	a.l008-*,*	bdisc
	rem		all done, now just connect
	tsy	a.l009-*,*	conect
	return	wmbx
	rem
	ttls	frembx -- tells cs a mailbox is free
	rem
	rem	this subroutine sets up a dcw list to or on 
	rem	the bit corresponding to a mailbox being frees in the
	rem	cs's "terminate interrupt multiplex word" (timw)
	rem
frembx	subr	fre
	rem		set transaction control word
	ila	tcfree	to "mailbox freed"
	sta	a.l002-*,*	tcword
	rem
	trace	mt.fre,tr.mbx,(mbxno)
	rem
	lda	mbxno-*	cs or fnp mailbox?
	icmpa	8
	tmi	fre010-*	cs
	icmpa	12	fnp, rewritten or not?
	tmi	2	yes
	iaa	-4	no, get number in range 8-11
	iaa	-8	now get it in range 0-3
	cax3
	stz	a.l012-*,*	(mbxfre,3) mark it free
	ila	-1	decrement used count
	asa	a.l015-*,*	mbused
	tsy	a.l013-*,*	(unlock) unlock dia now
	tsy	a.l014-*,*	(gate) make sure dgetwk runs
	tra	frebak-*	no need to tell multics anything
fre010	null
	ldx3	a.l004-*	addr(dcws)
	stx3	a.l005-*,*	dcwadr
	ila	8	8 words of dcws
	sta	a.l006-*,*	dcwlen
	tsy	wtimw-*	set up dcws to update timw
	rem		set up interrupt and disconnect dcws
	tsy	a.l007-*,*	bint
	iacx3	4
	tsy	a.l008-*,*	bdisc
	rem		do connect now
	tsy	a.l009-*,*	conect
frebak	return	frembx
	rem
	ttls	wtimw -- sets up dcws to update timw
	rem
	rem	this subroutine sets up dcws to "or" in a bit
	rem	corresponding to the mailbox number in "mbxno"
	rem	to the cs's "terminate interrupt multiplex word" (timw)
	rem
	rem	we will use the dia opcode "transfer gate", which means
	rem	"read and clear cs and or fnp",
	rem	followed by fnp->cs transfer
	rem
	rem	x3 contains address of first dcw to be built
	rem	on return it will point to next free spot in dcw list
	rem
wtimw	subr	wti
	rem
	lda	l.l002-*	"arl 0" instruction
	ora	mbxno-*	make it "arl [mbxno]"
	sta	wti010-*	store it where we'll execute it
	rem		get high-order bit for shifting
	lda	l.l003-*	=400000
	rem		shift it
wti010	zero		shift instruction goes here
	sta	timw-*	result will be new timw
	rem		now set up dcws
	lda	csmbx-*	cs address of mailbox header
	iaa	mh.tim	+offset of timw
	ilq	diatrg	"transfer gate" opcode
	staq	0,3
	ilq	diaftc	second dcw is same but with fnp->cs transfer
	staq	4,3
	rem
	lda	a.l010-*	addr(timw),w.2
	ilq	1	tally of one 36-bit word
	staq	2,3	this is for both dcws
	staq	6,3
	rem
	iacx3	8	update dcw pointer
	return	wtimw	that's all
	rem
	ttls	storage for wmbx, frembx, wtimw
	rem
a.l001	ind	swmbx
a.l002	ind	tcword
*a.l003		unused
a.l004	ind	dcws
a.l005	ind	dcwadr
a.l006	ind	dcwlen
a.l007	ind	bint
a.l008	ind	bdisc
a.l009	ind	conect
a.l010	zero	timw,w.2
a.l011	ind	shinp	"short input" flag
a.l012	ind	mbxfre,3
a.l013	ind	unlock
a.l014	ind	gate
a.l015	ind	mbused
	rem
	rem
l.l001	zero	0,w.2
l.l002	arl	0	template for shift of [mbxno] bits
l.l003	oct	400000
l.l004	zero	fmbxsz/2
	rem
	rem
wsize	bss	1	size of this mailbox (in 36-bit words)
	even
timw	bss	2	fnp's copy of cs timw
rcnt	bss	1	repetition count for copying mailbox
mbxno	bss	1	mailbox number
	rem
	even
swmbx	bss	56	mailbox to be written
	rem
	ttls	dia configuration region
	rem
	rem
	even
cspab	oct		port a and port b
cspcd	oct		port c and port d
csmbx	oct		cs mailbox address
csics	oct		cs interrupt cell switch
cslwa	oct		lower address bounds switches
	rem		(bits 0-8)
csupc	oct		upper address bounds switches
	rem		(bits 0-8)
	rem		bit 15 - store timer
	rem		bit 16 - address bounds
zerwd	oct	0,0	36 bit zero word for end-of-file
cssca	oct		cs system controller address
	rem
dicell	equ	csics
dmbx	equ	csmbx
diconf	equ	cspab
	ttls	qmask -- clear out a queue for masked channel
	rem
************************************************************
*
*	This routine is called when it's time to add a
*	"mask channel" entry to a dia request queue. First
*	it clears out whatever is currently in the channel's
*	queue, and frees its t.dcp chain, if any.
*	It is called by denq when a linmsk op code is passed
*	to it, unless there's a currently active accept input in
*	in the queue; in the latter case, it is called by deque
*	when the accept input is finished. in either case, it is
*	the caller's responsibility to worry about decrementing
*	qcnt to account for the removed queue entries.
*
*	input:
*	     x1: virtual tib address
*	     curque points to corresponding tib table entry
*
************************************************************
	rem
qmask	subr	qma,(a,q,x2,x3)
	rem
	ldx3	a.m001-*,*	curque
qma010	ldx2	qbuf,3	get pointer to first entry in queue
	tze	qma020-*	none left
	stx2	curqbf-*	make sure dlqent knows where to look
	tsy	a.m002-*,*	(dlqent) remove it
	tra	qma010-*	do next one
qma020	lda	t.dcp,1	if any queued input,
	tze	qma030-*
	tsy	a.m003-*,*	(frelbf) not any more
	stz	t.dcp,1
	stz	t.dcpl,1
	stz	t.dlst,1
qma030	ilq	linmsk	get opcode
	tsy	a.m004-*,*	adqent
	aos	a.m005-*,*	(qcnt) update queue count
	tsy	a.m006-*,*	(gate) make sure dgetwk runs
	return	qmask
	rem
a.m001	ind	curque
a.m002	ind	dlqent
a.m003	ind	frelbf
a.m004	ind	adqent
a.m005	ind	qcnt
a.m006	ind	gate
	ttls	subroutines to manage dia queues
	rem
************************************************************
*
*	One dia queue is maintained for each tib as well
*	as one for an error queue.
*	each queue consists of blocks linked
*	together with one entry per block.
*
*	format of first word of a dia queue entry
*
*	*******************************
*	*         *     *             *
*	* flags   * cnt *  opcode     *
*	*         *     *             *
*	*******************************
*	0        5 6   8 9           17
*
*	followed by the number of data words specified in count
*
*	format of a block in the dia queue
*
*	word 0 (qbnext) - address of next buffer in chain
*	                  0 specifies end of chain
*	word 1 (qbsize) - size of this block in words
*	word 2 (qbdata) - queue entries start here
*
************************************************************
	rem
*	define buffer addresses
	rem
qbnext	equ	0	addr of next buffer
qbsize	equ	1	number of words in this block
qbdata	equ	2	data starts here
	rem
*	the queue handling routines set and/or depend on the
*	following variables:
	rem
curque	bss	1	must contain the address of the tib
	rem		table entry for the current queue
curqbf	bss	1	address of buffer that contains current
	rem		queue entry
curqln	bss	1	current line number, set for trace
nnonai	bss	1	set by getqai to indicate the number
	rem		if non-accept input queue entries
	rem		before the first accept input entry
	eject
************************************************************
*
*	adqent - subroutine to add a new entry to a dia queue
*
*	at input, the q contains the dia opcode in the lower
*	half and, if data is to be passed, the word count
*	in the upper half. if the word count is non-0,
*	x2 must contain the address of the data.
*
*	this subroutine can be called by derrq at interrupt time,
*	and therefore must run inhibited
*
*	there are no outputs.
*
************************************************************
	rem
adqent	subr	adq,(inh,a,q,x2,x3)
	cqa		first word of queue entry
	ars	9	get word count
	iaa	1	allow 1 word for opcode
	sta	adqsnw-*	save number of words required
	rem
*	the new entry goes in the last buffer, so find it
	rem
	ldx2	curque-*	tib table entry
	ldx3	qbuf,2	get buffer pointer
	tze	adq010-*	no buffers, go allocate one
adq030	szn	qbnext,3	is this last buffer?
	tze	adq010-*	yes
	ldx3	qbnext,3	follow thread
	tra	adq030-*
	rem
*	must allocate a new buffer for this entry
	rem
adq010	stx3	adqtmp-*	save last buffer address
	lda	adqsnw-*	number of data words
	iaa	3	+1 for chain, +1 for size, +1 for rounding
	iana	-2	force it even
	caq
	tsy	a.u001-*,*	(=getmem) allocate new entry
	die	10
	stq	qbsize,3	save size
	szn	qbuf,2	is this the first buffer for queue
	tze	adq050-*	yes
	ldx2	adqtmp-*	get pointer to old last buffer
	stx3	qbnext,2	complete chain
	tra	adq040-*
adq050	stx3	qbuf,2	store as first buffer in chain
	rem
*	now a buffer has been found where the entry will fit
	rem
adq040	stx3	curqbf-*	this is the new current buffer
	iacx3	qbdata	address of first word to use
	rem
	trace	mt.inq,tr.que,(x3,adqsq,curqln)
	rem
	lda	adqsq-*	pick up opcode from save area
	sta	0,3	store in queue
	iacx3	1	and bump pointer
	ars	9	get number of data words to copy
	tze	adq060-*	none
	ldx2	adqsx2-*	get their address
adq070	ldq	0,2	get a word
	stq	0,3	copy it
	iacx2	1	bump pointers
	iacx3	1
	iaa	-1
	tnz	adq070-*	loop til copied
adq060	szn	curqln-*	was this for s apecific line?
	tze	adqbak-*	no, skip metering
	rem
	ldx3	t.metr,1
	cmeter	mincs,m.cql,l.u001-*
	cmeter	mupdat,m.dql,(m.cql(3))
	rem
adqbak	return	adqent	all done
	rem
adqsnw	bss	1
adqtmp	bss	1
	rem
a.u001	ind	getmem
a.u002	ind	fremem
	rem
	rem
l.u001	dec	1	for metering
l.u002	dec	-1	likewise
	eject
************************************************************
*
*	dlqent - suboutine to delete an entry for the queue.
*
*	input - x2 must point at entry to delete
*
************************************************************
	rem
dlqent	subr	dlq,(a,q,x2,x3)
	rem
	cx1a		for a specific line?
	tze	dlq010-*	no, no metering
	ldx3	t.metr,1
	cmeter	mincs,m.cql,l.u002-*
	cmeter	mupdat,m.dql,(m.cql(3))
	rem
dlq010	ldx3	curqbf-*	start of buffer
	ldx2	qbnext,3	hold onto pointer to next buffer
	ldq	qbsize,3
	tsy	a.u002-*,*	(=fremem) free this buffer
	rem
*	rethread the buffer chain
	rem
	lda	curqbf-*	addr of buffer just freed
	ldx3	curque-*	tib table entry
	cmpa	qbuf,3	did we free first buffer in chain
	tnz	dlq040-*	no
	stx2	qbuf,3	yes, next buffer now first
	tra	dlqret-*
dlq040	ldx3	qbuf,3	follow buffer trail
dlq060	cmpa	qbnext,3	does this buffer point to one just freed?
	tze	dlq050-*	yes
	ldx3	qbnext,3
	tra	dlq060-*
dlq050	stx2	qbnext,3	thread out freed buffer
dlqret	return	dlqent
	eject
************************************************************
*
*	getqhd - subroutine to find first entry in a dia queue.
*
*	no inputs
*
*	output - if queue empty, return is inline
*	otherwise, a skip return is done, and x2 will point to the
*	first entry.
*
************************************************************
	rem
getqhd	subr	ghd
	rem
	ldx2	curque-*	current tib table
	ldx2	qbuf,2	first buffer
	tze	ghdret-*	queue empty
	stx2	curqbf-*	this becomes current buffer
	iacx2	qbdata	data starts here
	aos	getqhd-*	found entry, so skip
ghdret	return	getqhd
	rem
	rem
************************************************************
*
*	getqai - subroutine to find first accept input in queue
*
*	output - x2 points to accept input, if found, and
*	a skip return is made. if not found, the return is inline.
*	the variable nnonai is set to the number of queue
*	entries skipped over.
*
************************************************************
	rem
getqai	subr	gai,(a,x3)
	rem
	stz	nnonai-*	zero counter initially
	tsy	getqhd-*	get head of queue
	tra	gairet-*	empty
gai020	lda	0,2	pick up opcode
	iana	255
	icmpa	accin	found it?
	tze	gai010-*	yes
	aos	nnonai-*	count something else
	ldx3	curqbf-*	get block address
	ldx2	qbnext,3	go to next
	tze	gairet-*	if any
	stx2	curqbf-*	this is current buffer now
	iacx2	qbdata	point at data
	tra	gai020-*	check for accin
gai010	aos	getqai-*	skip return, found accin
gairet	return	getqai
	ttls		j u m p  t a b l e s
	rem
	rem
	rem	format:
	rem
	rem	word 0 return addr after interrupt processed
	rem	word 1 place to go on interrupt (in dia_man)
	rem	word 2 ioc#,channel#,module#(3)
	rem
	rem
diajt	null		used to find jump tables for setting up iv's
jmptm	zero		terminate
	tsy	ivp-*,*
	vfd	4/0,8/0,6/trmmod
	rem
	rem		mailbox requests
	jumptb	(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
	rem
ivp	zero	invp
	rem
	rem
enddia	equ	*
	end
