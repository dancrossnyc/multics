* ***********************************************************
* *                                                         *
* * Copyright, (C) Honeywell Information Systems Inc., 1982 *
* *                                                         *
* * Copyright (c) 1972 by Massachusetts Institute of        *
* * Technology and Honeywell Information Systems, Inc.      *
* *                                                         *
* ***********************************************************

	
	lbl	,control_tables
	editp	on
	pmc	off
	pcc	off
	detail	off
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*
*	control_tables, ctrl
*
*	     The control_tables are the primary driving program
*	for the 355. They are interpreted by the control table
*	interpreter, who performs various functions on behalf
*	of the tables and calls the lsla, hsla, and dia interface
*	routines when required.
*
*	     This module contains the control tables for general-purpose
*	low-speed lines and vanilla synchronous lines. It also contains
*	all cct's, device tables, etc. Other modules contain
*	special-purpose control tables for such things as g115, ards,
*	tn1200 on 202c modem, and anything else which might come up.
*
*	     The tables specify what actions are to be peformed for
*	each line on the 355 and in what sequence these are to be
*	done. This includes control of the datasets, printer/keyboard
*	addressing for terminals which require it, and the initiation
*	of i/o to the terminals. The tables are entered (or "started")
*	for each line at the label "begin" by the init routine. After
*	that the path through the tables is controlled by external
*	events and the actions taken by these tables.
*
*	Originally coded 6/14/74 by Mike Grady
*	Modified by Bob Adsit 7/20/75 to handle 115's
*	Modified by Robert Coren 7/31/75 to handle tn1200 on 202c
*	Modified by Robert Coren 4/29/76 to split up into several modules
*	Modified by C. Hornig October 1980 to not send DLE EOT on hangup
*	Modified by T. Oke to allow hardware flow control using CTS
*	Modified by T. Oke to merge rapid breaks (less than .25 seconds)
*	  and avoid buffer overruns -- TR8447
*	Modified by D. W. Cousins on Nov 22 1985 to abort the hungup 
*	  500 ms timer for X.25 in order to process the activation order
*	  in time, else the wait loop will lose it. (TR PHX19612)
*
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

* HISTORY COMMENTS:
*  1) change(86-02-03,Kissel), approve(86-02-03,MCR7324):
*     Modified to abort the hangup 500 ms timer for X.25 in order to process
*     the activation order in time.  Otherwise, the wait loop would lose it
*     (TR phx19612).
*                                                      END HISTORY COMMENTS

	ttl	control_tables
	rem
	rem
ctrl	null		/* setup primary symdef */
	rem
	symdef	ctrl
	rem
	symdef	begin
	symdef	hungup
	symdef	tdhung
	symdef	signal
	symdef	error
	symdef	cct.2
	symdef	stpchn
	symdef	diftyp	autobaud returns here for 1050 or 2741
	symdef	cct.3	syncronous etx cct
	symdef	cct.br
	symdef	chkaut	acu_tables come back to here
	symdef	maskr	restart point after masking channel
	rem
	symref	acutst
	symref	astart
	symref	ahang
	symref	tstart
	symref	ant202
	symref	gstar
	symref	bscstr
	symref	vstart
	symref	autost
	symref	a1star
	symref	a2star
	symref	a3star
	symref	s1star
	symref	s2star
	symref	s3star
	symref	pvstar
	symref	x25str
	symref	hdlstr
	symref	colts
	rem
	ind	begin1	/* 0, starting location of control tables */
	ind	devtbl	/* 1, ptr to array of device info tbls */
	dec	-1	/* 2, used to be ptr to cct array */
	ind	devtyp	/* 3, ptr to device type - speed table */
	ind	wru	/* 4, ptr to answerback reading code */
	bss	1	/* 5, reserve for delay tbl ptr*/
	ind	brk	/* 6, ptr to send line break code*/
	rem
	rem
	start	ctrl
	rem
	rem
	ttls	macro definitions
	eject
* * * * * * * * * * * * * * * * * * * * *
*
*	devtyp macro
*
* * * * * * * * * * * * * * * * * * * * *
	rem
devtyp	macro
	vfd	1/#1,4/0,o4/#2,o9/#3
	endm	devtyp
	rem
* * * * * * * * * * * * * * * * * * * * *
*
*	devtbl macro
*
* * * * * * * * * * * * * * * * * * * * *
	rem
devtbl	macro
	tab2	#1	sequence chars
	zero	#2	cct table addr
	zero	#3	keyboard addressing string array
	zero	#4	printer      "         "     "
	vfd	o18/#5	addressing flag and others
	tab6	#6	carriage movement table
	pmc	save,off
dk	set	0
	idrp	#7
	ife	dk,0,3
dk	set	1
dval	set	#7
	ife	1,2,4
dk	set	0
	pmc	restore
	vfd	o9/dval,o9/#7	break list
	pmc	save,off
	idrp
	pmc	restore
	ife	dk,1,1
	vfd	o9/dval,o9/0
	endm	devtbl
	rem
tab2	macro
	vfd	o9/#1,o9/#2
	endm	tab2
	rem
tab4	macro
	vfd	o9/#1,o9/#2
	vfd	o9/#3,o9/#4
	endm	tab4
	rem
tab6	macro
	vfd	o9/#1,o9/#2
	vfd	o9/#3,o9/#4
	vfd	o9/#5,o9/#6
	endm	tab6
	rem
* * * * * * * * * * * * * * * * * * * * *
*
*	adstr macro
*
* * * * * * * * * * * * * * * * * * * * *
	rem
adstr	macro
	pmc	save,off
adcnt	set	0
adk	set	0
	idrp	#1
	ife	adk,0,3
adk	set	1
adval	set	#1
	ife	1,2,4
adk	set	0
	pmc	restore
	vfd	o9/adval,o9/#1
	pmc	save,off
adcnt	set	adcnt+1
	idrp
adcnt	set	adcnt+1
adcnt	set	adcnt/2
adcnt	set	madlen-adcnt
	pmc	restore
	ife	adk,1,1
	vfd	o9/adval,o9/0
	bss	adcnt
	endm	adstr
	rem
	pmc	save,on
	tib
	meters
	buffer
	csbits
	tconst
	pmc	restore
	rem
	rem
inlshf	bool	155	/* ibm nl with uppercase bit */
	rem
	rem
	rem	scan control strings
	rem
	rem
iscn1	chstr	(rescan,search,ibmnl)
iscn2	chstr	(rescan,search,ibmeot)
iscn3	chstr	(rescan,search,inlshf)
iscn6	chstr	(rescan,search,eotshf)
	ttls	device info tables
devtbl	zero	d.asci	table for ascii devices
	zero	d.1050	table for 1050's
	zero	d.2741	table for 2741's
	zero	d.ards	table for the ards
	zero	d.sync	table for sync devices
	zero	d.sync	table for g115's
	zero	d.sync	table for bsc
	zero	d.t202	table for t202
	zero	d.vip	table for vip
	zero	d.asci	table for async1
	zero	d.asci	table for async2
	zero	d.asci	table for async3
	zero	d.sync	table for sync1
	zero	d.sync	table for sync2
	zero	d.sync	table for sync3
	zero	d.sync	table for polled vip
	zero	d.sync	table for X.25 LAP
	rem
	rem
	rem
	rem
	rem	devtbl flags
	rem
dtfctl	bool	1	default setting of tfctrl
dtfsft	bool	4	default setting of tfsftr
	rem
	rem	break list types
	rem
blt.s	bool	1	break on one char
blt.d	bool	2	break on two chars
blt.t	bool	3	break on three chars
blt.p1	bool	775	break on char plus one
	rem
	rem
d.asci	devtbl	(0,0),0,k.asci,p.asci,0,
	etc	(nl,cr,tab,bs,nochar,nochar),(blt.t,ff,nl,etx)
	rem
d.1050	devtbl	(0,0),0,k.1050,p.1050,dtfctl+dtfsft,
	etc	(ibmnl,nochar,ibmtab,ibmbs,ibmup,ibmdwn),
	etc	(blt.d,ibmnl,ibmeot)
	rem
d.2741	devtbl	(0,0),0,k.2741,p.2741,dtfctl+dtfsft,
	etc	(ibmnl,nochar,ibmtab,ibmbs,ibmup,ibmdwn),
	etc	(blt.d,ibmnl,ibmeot)
	rem
d.ards	devtbl	(0,0),0,0,0,0,(nl,cr,tab,bs,nochar,nochar),
	etc	(blt.d,ff,nl)
	rem
d.sync	devtbl	(101,102),0,0,0,0,
	etc	(nochar,nochar,nochar,nochar,nochar,nochar),
	etc	(blt.p1,etx)
	rem
d.t202	devtbl	(0,0),0,0,0,0,(nl,cr,tab,bs,nochar,nochar),
	etc	(blt.t,etx,ack,nak)
	rem
d.vip	devtbl	(0,0),0,0,0,0,
	etc	(nochar,nochar,nochar,nochar,nochar,nochar),
	etc	(blt.p1,etx)
	rem
	rem
madlen	equ	4	max addressing string length
	rem
k.asci	adstr	(1,ack)
	rem
p.asci	adstr	(1,nak)
	rem
k.1050	adstr	(4,ibmdwn,ibmeot,ibmsl,ibm0)
	rem
p.1050	adstr	(2,ibmsl,ibm9)
	rem
k.2741	adstr	(2,ibmdwn,ibmeot)
	rem
p.2741	adstr	(1,eoa)
	ttls	devtyp tables - device type/speed correspondence
	rem
	rem	Note: 2400 and 1800 synchronous are out of order for
	rem	compatibility with previous version that did not have
	rem	1200 and 1800
	rem
	rem	code      async speed         sync speed
	rem	----      ----- -----         ---- -----
	rem
	rem	01         75                  1200
	rem	02         110                 2400
	rem	03         134.5               1800
	rem	04         150                 4800
	rem	05         300                 5400
	rem	06         600                 7200
	rem	07         1050                9600
	rem	10         1200               19200
	rem	11         1800               40800
	rem	12         option             50000
	rem	13	 ----		72000
	rem
async	equ	1
sync	equ	0
	rem
devtyp	devtyp	async,02,ttasci	110 baud, ascii type
	devtyp	async,03,tt2741	133 baud, 2741/1050
	devtyp	async,04,ttasci	150 baud, ascii type
	devtyp	async,05,ttasci	300 baud, ascii type
	devtyp	async,06,ttasci	600 baud, ascii type
	devtyp	async,10,ttasci	1200 baud, ascii type
	devtyp	async,11,ttasci	1800 baud, ascii type
	devtyp	async,12,ttasci	optn baud, ascii type
	devtyp	sync,01,ttsync	1200 baud, sync type
	devtyp	sync,03,ttsync	1800 baud, sync type
	devtyp	sync,02,ttsync	2400 baud, sync type
	devtyp	sync,04,ttsync	4800 baud, sync type
	devtyp	sync,06,ttsync	7200 baud, sync type
	devtyp	sync,07,ttsync	9600 baud, sync type
	devtyp	sync,10,ttsync	19200 baud, sync type
	devtyp	sync,11,ttsync	40800 baud, sync type
	devtyp	sync,12,ttsync	50000 baud, sync type
	devtyp	sync,13,ttsync	72000 baud, sync type
	dec	-1	end of table
	ttls	cct's - control character tables
	rem
	pmc	save,on
	cctdef
	pmc	restore
	rem
	rem
	base	64
	rem
	rem
cct.2	null	* cct for ibm 2741 on hsla subchannel
	rem
	vfd	9/ct.ncs,9/ct.ncs * 000   001
	vfd	9/ct.ncs,9/ct.ncs * 002   003
	vfd	9/ct.ncs,9/ct.ncs * 004   005
	vfd	9/ct.ncs,9/ct.ncs * 006   007
	vfd	9/ct.ncs,9/ct.ncs * 010   011
	vfd	9/ct.ncs,9/ct.ncs * 012   013
	vfd	9/ct.ncs,9/ct.ncs * 014   015
	vfd	9/ct.ncs,9/ct.ncs * 016   017
	vfd	9/ct.ncs,9/ct.ncs * 020   021
	vfd	9/ct.ncs,9/ct.ncs * 022   023
	vfd	9/ct.ncs,9/ct.ncs * 024   025
	vfd	9/ct.ncs,9/ct.ncs * 026   027
	vfd	9/ct.ncs,9/ct.ncs * 030   031
	vfd	9/ct.ncs,9/ct.ncs * 032   033
	vfd	9/ct.ncs,9/ct.ncs * 034   035
	vfd	9/ct.ncs,9/ct.ncs * 036   037
	vfd	9/ct.ncs,9/ct.ncs * 040   041
	vfd	9/ct.ncs,9/ct.ncs * 042   043
	vfd	9/ct.ncs,9/ct.ncs * 044   045
	vfd	9/ct.ncs,9/ct.ncs * 046   047
	vfd	9/ct.ncs,9/ct.ncs * 050   051
	vfd	9/ct.ncs,9/ct.ncs * 052   053
	vfd	9/ct.ncs,9/ct.mrk * 054   nl
	vfd	9/ct.ncs,9/ct.ncs * 056   057
	vfd	9/ct.ncs,9/ct.ncs * 060   061
	vfd	9/ct.ncs,9/ct.ncs * 062   063
	vfd	9/ct.ncs,9/ct.ncs * 064   065
	vfd	9/ct.ncs,9/ct.ncs * 066   067
	vfd	9/ct.ncs,9/ct.ncs * 070   071
	vfd	9/ct.ncs,9/ct.ncs * 072   073
	vfd	9/ct.mrk,9/ct.ncs * eot   075
	vfd	9/ct.ncs,9/ct.ncs * 076   077
	rem
	vfd	9/ct.ncs,9/ct.ncs * 100   101
	vfd	9/ct.ncs,9/ct.ncs * 102   103
	vfd	9/ct.ncs,9/ct.ncs * 104   105
	vfd	9/ct.ncs,9/ct.ncs * 106   107
	vfd	9/ct.ncs,9/ct.ncs * 110   111
	vfd	9/ct.ncs,9/ct.ncs * 112   113
	vfd	9/ct.ncs,9/ct.ncs * 114   115
	vfd	9/ct.ncs,9/ct.ncs * 116   117
	vfd	9/ct.ncs,9/ct.ncs * 120   121
	vfd	9/ct.ncs,9/ct.ncs * 122   123
	vfd	9/ct.ncs,9/ct.ncs * 124   125
	vfd	9/ct.ncs,9/ct.ncs * 126   127
	vfd	9/ct.ncs,9/ct.ncs * 130   131
	vfd	9/ct.ncs,9/ct.ncs * 132   133
	vfd	9/ct.ncs,9/ct.ncs * 134   135
	vfd	9/ct.ncs,9/ct.ncs * 136   137
	vfd	9/ct.ncs,9/ct.ncs * 140   141
	vfd	9/ct.ncs,9/ct.ncs * 142   143
	vfd	9/ct.ncs,9/ct.ncs * 144   145
	vfd	9/ct.ncs,9/ct.ncs * 146   147
	vfd	9/ct.ncs,9/ct.ncs * 150   151
	vfd	9/ct.ncs,9/ct.ncs * 152   153
	vfd	9/ct.ncs,9/ct.mrk * 154   nl
	vfd	9/ct.ncs,9/ct.ncs * 156   157
	vfd	9/ct.ncs,9/ct.ncs * 160   161
	vfd	9/ct.ncs,9/ct.ncs * 162   163
	vfd	9/ct.ncs,9/ct.ncs * 164   165
	vfd	9/ct.ncs,9/ct.ncs * 166   167
	vfd	9/ct.ncs,9/ct.ncs * 170   171
	vfd	9/ct.ncs,9/ct.ncs * 172   173
	vfd	9/ct.mrk,9/ct.ncs * eot   175
	vfd	9/ct.ncs,9/ct.ncs * 176   177
	rem
cct.3	null	* cct for use with grts, terminate on etx + bcc
	rem
	vfd	9/ct.ncs,9/ct.ncs * 000   001
	vfd	9/ct.ncs,9/ct.grt * 002   etx
	vfd	9/ct.ncs,9/ct.ncs * 004   005
	vfd	9/ct.ncs,9/ct.ncs * 006   007
	vfd	9/ct.ncs,9/ct.ncs * 010   011
	vfd	9/ct.ncs,9/ct.ncs * 012   013
	vfd	9/ct.ncs,9/ct.ncs * 014   015
	vfd	9/ct.ncs,9/ct.ncs * 016   017
	vfd	9/ct.ncs,9/ct.ncs * 020   021
	vfd	9/ct.ncs,9/ct.ncs * 022   023
	vfd	9/ct.ncs,9/ct.ncs * 024   025
	vfd	9/ct.ign,9/ct.ncs * syn   027
	vfd	9/ct.ncs,9/ct.ncs * 030   031
	vfd	9/ct.ncs,9/ct.ncs * 032   033
	vfd	9/ct.ncs,9/ct.ncs * 034   035
	vfd	9/ct.ncs,9/ct.ncs * 036   037
	rem
	rem
	dup	1,48
	vfd	9/ct.ncs,9/ct.ncs
	rem
	rem
*	cct that breaks on all characters
*	used occosionally for 1050's and 2741's, and
*	externally by autobaud tables
	rem
cct.br	null
	dup	1,64
	vfd	9/ct.eol,9/ct.eol
	ttls	wait for dialup
tdhung	null		/* defined symbol for "hungup" t&d channel */
begin	tstglb	gbf6up,start	/* make sure 6180 is up before start */
begin1	wait	0,0,begin	/* wait for test state */
	rem
start	tstflg	tfauto,isauto	/* make all autobaud lines start ascii */
	goto	start1
isauto	setype	ttasci
	rem
start1	tstflg	tfhang,hangak	/* check for extra hangup */
	gotype	(norm,norm,norm,astart,norm,gstar,bscstr,tstart,vstart,a1
	etc	star,a2star,a3star,s1star,s2star,s3star,pvstar,x25str,hdl
	etc	str,colts) /* start up */
	rem
norm	tstflg	tfacu,acutst	/* check if auto call unit is to be started */
	tstflg	tflisn,listen	/* if told to listen do it */
restrt	clrflg	tfhang
maskr	wait	0,0,begin	/* wait till told to start again */
	rem
hangak	signal	hangup	/* acknowledge hangup orders, since */
	goto	restrt	/* host may depend on interrupt */
	rem
hungup	stpchn		/* hungup, stop and start over */
	contrl	rdtr	/* reset data term ready */
	setcct	scc.dl	/* get rid of any cct */
	setime	-500	/* make sure we leave dtr down for at least */
	wait	begin,0,hgtest	/* half a second */
	rem
hgtest	tstglb	gbf6up,h1test	/* fnp must be up, else false start */
	waitm		/* no go - return to wait loop */
	rem
h1test	iftype	ttx25l,x25str	/* x25 only aborts hangup timer */
	waitm		/* all others must wait */
	rem
listen	clrflg	tfhang	/* so as not to be caught later by an old hangup */
	contrl	sdtr+srts+stat	/* set dtr and wait for status */
	setime	0	/* turn off the timer */
	rem
	wait	0,0,tstlsn	/* and wait here */
	status	ring,cd+cts+dsr,waitcd /* ring, wait for cd */
	status	cd+cts+dsr,0,dialed /* all on, dialup */
	rem
waitcd	setime	20	/* wait 20 secs for cd */
	rem
	wait	nocd,0,tstlsn	/* if timeout, hangup on him */
	status	cd+cts+dsr,0,dialed
	rem
nocd	contrl	rdtr	/* nothing, hangup on him now */
	setime	5	/* wait 5 secs for this to happen */
	wait	hungup,0,0	/* go to hungup when done */
	rem
dialed	tstglb	gbf6up,godial	/* make sure we're supposed to accept calls */
	goto	hungup	/* we aren't */
godial	gotype	(chkaut,diftyp,diftyp,error,dialsy)
	rem
chkaut	setcct	scc.df	/* set default ascii cct */
	tstflg	tfauto,autost	/* do autobaud setting if needed */
	goto	signal
	rem
tstlsn	tstglb	gbf6up,tsthng	/* see if multics stopped accepting calls */
	goto	hungup	/* it did */
	eject
************************************************************************
*
*	perform test to determine if 1050 or 2741 terminal
*	the following code runs only on lsla's
*
************************************************************************
	rem
diftyp	ifhsla	difh01	/* special processing for hsla lines */
	dcwlst
	cmd	srec	/* enter receive mode for eoa */
	input	1,eoa	/* look for eoa from 2741 */
	cmd	smark	/* marker if recvd */
	rem
	setime	3	/* wait 3 seconds for eoa */
	rem
	wait	dt1050,0,0	/* timeout, is 1050 */
	status	marker,0,dt2741	/* yup, its a 2741 */
	rem
dt1050	setype	tt1050	/* set to 1050 */
	rem
	dcwlst		/* make sure is really 1050 */
	cmd	sbrk	/* send line break */
	setime	1	/* give line break half a second to take */
	wait	dt105a,0,0
dt105a	dcwlst
	cmd	rrec+sxmit	/* go into xmit mode */
	output	(ibmeot)	/* put 2741 into control-receive */
	cmd	srec+rxmit	/* go into recv */
	input	1,eoa	/* should respond with eoa */
	cmd	smark	/* send marker status */
	rem
	setime	3	/* wait 3 seconds for device */
	wait	signal,0,0	/* timeout, is really 1050 */
	status	marker,0,dt2741	/* got eoa, really 2741 */
	rem
dt2741	setype	tt2741	/* set to 2741 */
	goto	signal
	rem
************************************************************************
*
*	perform test to determine if 1050 or 2741 terminal
*	the following code runs only on hsla's
*
************************************************************************
	rem
difh01	setcct	cct.br	/* break on all characters */
	contrl	srec	/* set receive mode to wait for eoa */
	setime	3
	wait	difh02,0,0
	status	brkchr,0,difh03	/* got it, must be 2741 */
	rem
difh02	setype	tt1050	/* no eoa, probably 1050 */
	dcwlst		/* but try 2741 test once more */
	cmd	sbrk
	setime	1	/* give line break time to take */
	wait	difh2a,0,0
difh2a	dcwlst
	cmd	sxmit
	output	(ibmeot)
	cmd	rxmit
	setime	3
	wait	difh04,0,0	/* wait for eoa once more */
	rem
	status	brkchr,0,difh03	/* really 2741 */
	rem
difh03	setype	tt2741
difh04	setcct	cct.2	/* back to standard cct */
	goto	signal
	rem
************************************************************************
*
*	signal dialu to multics to say terminal is here
*
************************************************************************
	rem
dialsy	setcct	cct.3	/* cct for sync line */
	rem
signal	dmpout		/* throw away any leftover output from 6180 */
	dumpin		/* likewise any input left on the line */
	signal	dialup	/* tell multics about this line */
	rem
	goto	getwrk	/* start looking for work */
	ttls	wru - read the answer back for a line
************************************************************************
*
*	perform wru processing to read answerback
*	dia_man puts this address in t.cur to make us start here
*
************************************************************************
	rem
wru	wait	0,0,rdansb	/* test state here when answer back wanted */
	rem
rdansb	scntr	0
	rem
anslp	gotype	(rawru,ra1050,ra2741,error,error,error,error,ant202)
	rem
************************************************************************
*
*	ascii line
*
************************************************************************
	rem
rawru	stpchn		/* halt channel */
	dcwlst		/* dcw list to read answerback */
	cmd	sxmit	/* enter xmit mode */
	output	(awru)	/* send ascii wru char */
	cmd	rxmit+srec	/* go into receive mode */
	rem
	clrflg	tfkybd	/* clobbered keyboard */
	goto	answt	/* wait */
	rem
************************************************************************
*
*	1050 on lsla
*
************************************************************************
	rem
ra1050	stpchn		/* halt channel */
	ifhsla	rahs10	/* seperate code for hsla
	dcwlst		/* dcw list for 1050 answerback */
	cmd	sbrk	/* send line break */
	setime	1	/* give it time to happen */
	wait	ra105a,0,0
ra105a	dcwlst
	cmd	sxmit+rrec
	output	(adprtr)
	cmd	rxmit+srec	/* enter rec for ans */
	rdtly	1	/* read only one char */
	cmd	sxmit+rrec	/* finish addressing */
	output	(eoa)
	cmd	rxmit+sterm
	rem
	clrflg	tfkybd	/* no more keyboard */
	setflg	tfprtr	/* printer on now */
	goto	answt	/* wait */
	rem
************************************************************************
*
*	1050 on hsla
*
************************************************************************
	rem
rahs10	setcct	cct.br	/* break on all chars */
	dcwlst
	cmd	sbrk
	setime	1	/* give it time to happen */
	wait	rahs1a,0,0
rahs1a	dcwlst
	cmd	sxmit+srec
	output	(adprtr)
	cmd	rxmit
	setime	4
	wait	anstim,0,tsthng
	status	0,cts,hang2
	status	0,cd,hang2
	status	brkchr,0,rahs30	/* got reply */
	rem
rahs30	dcwlst	sxmit+rrec
	output	(eoa)
	cmd	rxmit+sterm
	wait	anstim,0,tsthng
	status	0,cd,hang2
	status	0,cts,hang2
	status	term,0,rahs40
rahs40	setflg	tfprtr
	clrflg	tfkybd
	setcct	cct.2
	goto	ansend
	rem
************************************************************************
*
*	2741 line
*
************************************************************************
	rem
ra2741	stpchn		/* halt channel */
	setcct	cct.2	/* should be this if hsla */
	dcwlst
	cmd	sbrk	/* line break */
	setime	1
	wait	ra274a,0,0
ra274a	dcwlst
	cmd	sxmit+rrec
	output	(eoa,ibmprf,ibmpls,ibmeot)
	cmd	rxmit+srec
	rem
	clrflg	tfkybd
	goto	answt	/* wait */
	rem
************************************************************************
*
*	common answerback code
*
************************************************************************
	rem
answt	setime	4	/* wait four seconds for response */
	rem
	wait	anstim,0,0	/* retry on timeout */
	status	0,cts,hang2
	status	0,cd,hangb
	status	brkchr,0,ansend	/* got it */
	status	term,0,ansend	/* also */
	eject
ansend	sendin		/* ship it */
	goto	getwrk	/* continue real stuff */
	rem
anstim	acntr	1	/* bump counter */
	tcntr	3,ansnot	/* too much, punt */
	rem
	goto	anslp	/* loop for more */
	rem
ansnot	signal	wrutim	/* tell as_ that there is no answer back */
	stpchn		/* throw away any funny input */
	dumpin
	iftype	tt1050,ansnt2	/* must reset cct on hsla 1050 */
	goto	getwrk
ansnt2	setcct	cct.2
	goto	getwrk
	ttls	brk - send line break to the terminal
************************************************************************
*
*	send line break at users request
*	dia_man puts this address in t.cur to make us start here
*
************************************************************************
	rem
brk	wait	0,0,brkst	/*test state here when send break wanted*/
	rem
brkst	scntr	0
	rem
	stpchn		/* kill user channel */
	dumpin		/* throw away input */
	setime	-100	/* wait for 100mils */
	contrl	sbrk
	wait	brkout,0,0
	status	0,cts,hang2
	status	0,cd,hangb
	status	break,0,brkout
brkout	setcct	scc.bs	/* back to base cct, in case */
	clrflg	tffip	/* turn off frame in progress */
	tstflg	tfquit,writnl	/* print new-line if asked to */
	clrflg	(tfprtr,tfkybd)	/* nothing is addressed now */
	goto	getwrk	/* no newline, go read more */
	ttls	reading part of control tables
************************************************************************
*
*	start of real work of control_tables. if there is output
*	to do, go do it, otherwise setup to read.
*
************************************************************************
	rem
getwrk	clrflg	(tfwabt,tfrabt)	/* clear in case we just did one */
	tstwrt	write	/* if any writing, do it */
	tstflg	tfhang,hanga	/* if we are to hangup, do it */
	tstflg	tfctrl,ckkybd	/* if control mode, check kybd */
	goto	read	/* go directly to it */
	rem
************************************************************************
*
*	starting input on a device that requires keyboard
*	addressing. do it here.
*
************************************************************************
	rem
ckkybd	tstflg	tfkybd,read	/* if kybd addressed, read */
	clrflg	tfprtr	/* we are about to kill prtr */
	rem
	gotype	(kbasci,kb1050,kb2741,error,read)
	rem
kbasci	dcwlst		/* dcwlst to address kybd */
	cmd	rrec+sxmit	/* set xmit mode */
	output	(adkybd)	/* send ack to tty37 */
	cmd	srec+rxmit+smark /* marker when done */
	rem
	goto	kybdwt	/* go to wait block */
	rem
kb1050	null
kb2741	ifhsla	kbhs01	/* special processing for hsla lines */
	dcwlst		/* same basic stuff 1050/2741 */
	cmd	sxmit+rrec	/* set xmit mode */
	output	(adkybd)	/* 1050 = lc, eot, /, 0 */
	rem		/* 2741 = lc, eot */
	cmd	srec+rxmit	/* set recv to get eoa */
	input	1,eoa	/* read 1 look for eoa */
	cmd	smark	/* send marker */
	rem
	clrflg	tfupsf	/* we have sent low shift to device */
	goto 	kybdwt	/* wait for marker */
	rem
kbhs01	setcct	cct.br	/* break on all characters */
	dcwlst	
	cmd	sxmit+srec
	output	(adkybd)
	cmd	rxmit
	setime	3
	wait	kbhs03,0,tsthng	/* wait for addressing to complete */
	status	0,cd,hang2
	status	break,0,kbhs04	/* user hit quit */
	status	brkchr,0,kbhs02	/* break char, kybd addressed */
	rem
kbhs04	setcct	cct.2	/* back to standard cct */
	goto	otquit
kbhs02	setcct	cct.2
	clrflg	tfupsf
	dumpin
	goto	kybdon
kbhs03	setcct	cct.2
	goto	kybdto
	rem
kybdwt	setime	3	/* wait 3 secs for keyboard */
	rem
	wait	kybdto,0,0	/* wait for kybd to be addressed */
	status	0,cd,hangb	/* no cd, maybe hangup */
	status	break,0,otquit	/* quit, tell 6180 */
	status	marker,0,kybdon	/* done addressing */
	rem
kybdon	setflg	tfkybd	/* kybd on, set flag */
	tstwrt	write	/* if we are to write do it */
	goto	rwait	/* go to read wait */
	rem
kybdto	contrl	rrec+rxmit+smark /* time out, stop and give up */
	wait	0,0,tstdmp
	status	0,cd,hangb
	status	marker,0,getwrk
	rem
************************************************************************
*
*	keyboard  addressing not required,  just set  rcv mode
*
************************************************************************
	rem
read	contrl	srec+rxmit	/* setup regular read */
	rem
************************************************************************
*
*	in receive mode now, wait for something to happen
*
************************************************************************
	rem
rwait	setime	0	/* turn off the timer */
	rem
	wait	0,rabort,tstrbp /* wait here for something */
	status	0,cd,hangb
	status	parity,0,sndchk	/* watch for parity errors */
	status	break,0,inquit
	status	brkchr,0,ckdata	/* check for eot 2741 */
	status	exh,0,inexh	/* too much input */
	status	xte,0,inxte	/* input too fast */
	status	prexh,0,preshp
	rem
************************************************************************
*
*	got input data - break character status
*
************************************************************************
	rem
ckdata	tstflg	tfrabt,dmpin	/* are we supposed to throw it away? */
	gotype	(sndata,sndata,ck2741,error,sndata)
	rem
preshp	meter2	m.prex,1
	sendin		/* just send data on pre-exaust */
	waitm
	rem
************************************************************************
*
*	input is from 2741. special processing required for eots
*
************************************************************************
	rem
ck2741	inscan	iscn1,ckupnl	/* see if it looks like uppercase nl */
	setflg	tfeotx	/* got the nl, eot is next */
	goto	sndata	/* ship the data now */
	rem
ckupnl	inscan	iscn3,ckeot	/* not an nl, see if it's eot */
	setflg	tfeotx	/* eot would be appropriate now */
	goto	sndata	/* pretend uppercase NL is lowercase NL */

ckeot	inscan	iscn2,upeot	/* might be shifted eot */
	goto	goteot	/* all right, we have eot */
upeot	inscan	iscn6,sndata	/* non-standard break, just send input */
	rem
goteot	tstflg	tfeotx,ckfin	/* got the eot, fix kybd */
	clrflg	tfkybd	/* however his keyboard is still unaddressed */
	goto	inquit	/* not expected, must be quit */
	rem
ckfin	clrflg	tfeotx	/* got it, turn of expected flag */
	stpchn		/* stop the channel */
	dumpin		/* throw away the eot */
	goto	kb2741	/* unlock his keyboard */
	rem
************************************************************************
*
*	have real data to send to multics
*
************************************************************************
	rem
sndata	sendin		/* send data to 6180 */
	tstwrt	getwrk	/* make sure no write to be done */
	goto	rwait	/* wait for more input */
	rem
************************************************************************
*
*	parity error. this is ignored except for sync line type
*
************************************************************************
	rem
sndchk	meter1	m.par,1
	iftype	ttsync,sndstp	/* if line sync type, stop channel */
	goto	sndata	/* else send data in to multics */
	rem
sndstp	stpchn		/* stop reciever (resync) */
	sendin		/* ship stuff anyway */
	goto	getwrk	/* look for other processing */
	rem
************************************************************************
*
*	come here when too much input, or input too fast
*
************************************************************************
	rem
inxte	meter1	m.xte,1
	goto	holdup
	rem
inexh	meter2	m.exh,1
holdup	stpchn		/* kill users channel */
	sendin		/* ship off any input */
	meter1	m.quit,1	/* count 'bell-quits' */
	gotype	(holdac,holdwt,holdwt,error,holdwt)
holdac	scntr	0	/* zero a bell counter */
holdbl	dcwlst		/* warn  user of problems  with  bells */
	cmd	sxmit
	output	(bel)
	cmd	rxmit+sterm
	wait	0,0,tstrbt	/* wait for  bells to finish */
	status	0,cd,hangb
	status	break,0,otquit
	status	term,0,holdlp
	rem
holdlp	acntr	1	/* count bells */
	tcntr	3,holdwt	/* done */
	setime	-150	/* scientifically determined optimal bell delay */
	wait	holdbl,0,tstrbt
	status	0,cd,hangb
	status	break,0,inquit
	rem
holdwt	setime	10	/* give user 10 seconds to quit */
	contrl	sbrk
	wait	inquit,0,tstrbt
	status	0,cd,hangb
	status	break,0,inquit
	ttls	utility functions
rabort	null		/* come here when output arrives */
	ckinpt	getwrk	/* check for input, none goto getwrk */
	tstflg	tfplit,raplit	/* polite mode? */
	goto	getwrk	/* no, process normally */
	rem
raplit	setime	30	/* partial input, wait for it to complete */
	wait	pltout,0,tsthng
	status	0,cd,hangb
	status	parity,0,sndchk	/* watch for parity errors */
	status	break,0,otquit
	status	brkchr,0,ckdata	/* check for eot 2741 */
	status	exh,0,inexh
	status	xte,0,inxte
	status	prexh,0,preshp
	rem
pltout	null		/* we have waited long enough, process output */
	tstflg	tfrabt,tstecp	/* are we supposed to throw away accumulated input? */
	goto	getwrk	/* no, proceed */
	rem
tstdmp	tstflg	tfwabt,dump	/* test for dump output */
	goto	tsthng	/* no, check for hangup */
	waitm
	rem
tstrbp	tstflg	tfrabt,tstplt	/* dump input? */
	goto	tsthng	/* no, check for hangup */
	rem
tstrbt	tstflg	tfrabt,tstecp	/* check for read abort */
tsthng	tstflg	tfhang,hanga	/* hang it up */
twaitm	waitm
	rem
tstplt	ckinpt	getwrk	/* there isn't anything to throw away */
	tstflg	tfplit,twaitm	/* if being polite, dump it later */
tstecp	tstflg	tfecpx,echoat	/* are we in echoplex? */
	goto	dmpin	/* no, just dump it */
	rem
echoat	ckinpt	getwrk	/* no accumulated input, forget it */
	echo	atchar	/* put at sign in echo buffer */
	rem
dmpin	stpchn		/* stop the channel */
	dumpin		/* throw away read chain */
	dmprpy		/* dump any accumulated replay */
	goto	getwrk
	rem
dump	stpchn		/* stop channel */
	dmpout		/* dump the output */
	goto	getwrk
	rem
inquit	stpchn		/* stop the input for now */
	setcct	scc.bs	/* back to base cct, in case */
	clrflg	tffip	/* turn off frame in progress */
	sendin		/* send any input to 6180 */
	signal	quit	/* tell 6180 */

***************************************************************************
*
*	Throw away rapid breaks to prevent over-run.
*	Here we require a .25 second gap between observable breaks to
*	prevent too many breaks and send_outputs caused by a terminal
*	set at too low a line speed.
*
*	This is done by waiting .25 seconds before continuing break
*	processing.  If another break occurs within this period, it is
*	ignored and any stored up input is dumped, to prevent buffer
*	over-commitment.
*
*	We will get out of it, either if mcs sends us stuff, or the line
*	is hung up (cd drops).
*
***************************************************************************

iqthld	setime	-250	/* wait 1/4 second for break timeout
	wait	iqtcon,iqtcon,tsthng  /* timeout or mcs output - continue
*                                            control order - obey hangup
	status	0,cd,hangb	/* carrier drop loses the line
	status	break,0,iqtbrk	/* continued break

iqtbrk	dumpin                        /* lose the input accumulated input
          dmprpy                        /* dump accumulated replay
          goto iqthld                   /* continue break

iqtcon	tstflg	tfquit,writnl	/* print new-line if asked to */
	clrflg	(tfprtr,tfkybd)	/* nothing is addressed now */
	goto	getwrk	/* no newline, go read more */
	rem
otquit	stpchn		/* stop the input for now */
	setcct	scc.bs	/* back to base cct */
	clrflg	tffip	/* turn off frame in progress */
	sendin		/* ship any input */
	setfld	t.omct,0	/* treat like block acknowledgement */
	signal	quit	/* tell 6180 */

*****************************************************************************
*
*	Same break processing as for input, for same reasons.
*
****************************************************************************

oqthld	setime	-250
	wait	oqtcon,oqtcon,tsthng
	status	0,cd,hangb
	status	break,0,oqtbrk

oqtbrk	dumpin
	dmprpy
	goto	oqthld

oqtcon	tstflg	tfquit,qdump	/* dump and print nl ? */
	clrflg	(tfprtr,tfkybd)	/* we'll have to re-address */
	goto	getwrk	/* go look for work to be done */
	rem
qdump	dmpout		/* throw away the output chain */
writnl	prepnl		/* setup new-line for output */
	scntr	-10	/* flag meaning printing new-line after quit */
	goto	write2
	rem
error	punt	1	/* ards error */
	ttls	writing part of tables
write	tstflg	tfpfnl,write3	/* see if in prefixnl mode */
	goto	write1	/* no, dont prepnl check */
write3	ckinpt	write1	/* check to see if input snuck in */
	prepnl		/* it did, setup to write newline */
write1	scntr	0	/* flag meaning not doing nl after quit */
write2	tstflg	tfctrl,ckprtr	/* if we need to address ptr */
	goto	print	/* nope, go and print */
	rem
ckprtr	tstflg	tfprtr,print	/* if we need to address ptr */
	clrflg	tfkybd	/* yes, clear kybd */
	rem
	gotype	(ptasci,pt1050,pt2741,error,print)
	rem
ptasci	dcwlst		/* dcw list to address prtr */
	cmd	sxmit+rrec	/* go to xmit mode */
	output	(adprtr)	/* send prtr addr string, nak for 37 */
	cmd	smark	/* send marker when done */
	output	(outmsg)	/* send the data */
	cmd	sterm+rxmit	/* and terminate when finished */
	rem
	goto	prtrwt	/* go wait for addressing */
	rem
pt1050	dcwlst		/* dcw list for 1050 adressing */
	cmd	sbrk	/* send a line break */
	setime	1	/* have to let it happen */
	wait	pt105a,0,0
pt105a	dcwlst
	cmd	sxmit+rrec	/* go to transmit mode */
	output	(adprtr)	/* address 1050 prtr, with /9 */
	cmd	srec+rxmit	/* enter receive mode */
	input	1,null	/* read one char */
	cmd	sxmit+rrec	/* enter transmit mode again */
	output	(eoa)	/* send eoa char */
	cmd	smark	/* send marker status when done */
	output	(outmsg)	/* now, send the guys data */
	cmd	sterm+rxmit	/* and terminate when done */
	rem
	goto	prtrwt	/* wait for addressing to finish */
	rem
pt2741	dcwlst		/* address 2741 printer */
	cmd	sbrk	/* send a line break */
	setime	1	/* give it time */
	wait	pt274a,0,0
pt274a	dcwlst
	cmd	sxmit+rrec	/* enter transmit mode */
	output	(adprtr)	/* address printer now with eoa */
	cmd	smark	/* send marker when done addressing */
	output	(outmsg)	/* send the data */
	cmd	sterm+rxmit	/* send term when done outout */
	rem
	clrflg	tfeotx	/* clear eot expected flag */
	goto	prtrwt
	rem
prtrwt	setime	5	/* wait 5 secs for addressing */
	rem
	wait	prtrto,0,tsthng	/* if timeout, punt */
	status	0,cd,hangb
	status	marker,0,prtron	/* printer is addressed now */
	status	break,0,otquit	/* quit? */
	rem
prtrto	stpchn		/* timed out waiting for printer addressing */
	contrl	stat	/* make sure no hangup during stpchn */
	setime	-150
	wait	prttim,0,tstdmp
	status	0,cd,hangb
	rem
prttim	tstflg	tfwabt,dump
	tstwrt	write1	/* real timeout, try again */
	goto	getwrk
	rem
prtron	setflg	tfprtr	/* printer on now */
	tcntr	-10,wwait	/* ignore write-abort on nl after quit */
	tstflg	tfwabt,dump	/* were we asked to punt */
	goto	wwait	/* no, wait for write to finish */
	rem
print	tstflg	tffdpx,printf	/* full dpx, dont reset rec */
	tstflg	tfecpx,printf	/* likewise for echoplex */
	rem
	dcwlst		/* start output on device wo addressing */
	cmd	sxmit+rrec	/* enter xmit mode and reset rec */
	output	(outmsg)	/* put in the data */
	cmd	sterm+rxmit	/* and terminate */
	rem
	goto	wwait	/* wait for terminate */
	rem
printf	tstflg	(tfblak,tfofc),chkeob /* check for block acknowledgement */
sprint	dcwlst		/* full dpx write */
	cmd	sxmit+srec	/* enter xmit mode */
	output	(outmsg)
	cmd	sterm+rxmit	/* term when done */
	rem
wwait	tstflg	tfrpon,wwait1	/* replay already started? */
	tstflg	tfrply,prplay	/* no, should we start one? */
	goto	wwait1	/* no, go wait */
	rem
prplay	ckinpt	wwait1	/* check for any input */
	setflg	tfrpon	/* set replay in progress flag */
	gtinpt		/* scoop up current input */
	rem
wwait1	setime	0	/* turn off the timer */
	rem
	wait	0,0,wtest	/* wait for status or dump */
	status	0,cd,hangb
	status	brkchr,0,wsend	/* send data input during full dpx */
	status	exh,0,wexh	/* stop the receiver now */
	status	break,0,otquit	/* quit? */
	status	term,0,wterm	/* all done */
	rem
wterm	tstflg	tfrabt,tstecp	/* see if there was a resetread */
	tstwrt	getwrk	/* if any to do, do it */
	tstflg	tfrpon,wdrply	/* replay ready, do it */
	tstflg	tfplit,wdplit	/* check polite write term */
	goto	getwrk	/* all ok */
	rem
wdrply	tstrpy	wdrpdn	/* if no replay chain goto wdrpdn */
	setime	1	/* wait 1 second for all output */
	wait	wdrpto,write1,tstrbt
	status	0,cd,hangb
	status	brkchr,0,wsend	/* send data input during full dpx */
	status	exh,0,wexh	/* stop the receiver now */
	status	break,0,otquit	/* quit? */
	rem
wdrpto	replay		/* make the saved input an output chain */
	goto	write1	/* put out those chars now */
	rem
wdrpdn	clrflg	tfrpon	/* done now, clear flag */
	goto	getwrk	/* all done replaying */
	rem
wdplit	ckinpt	getwrk	/* had we just been polite to him? */
	setime	1	/* yes, wait for more output */
	wait	wdplto,write1,tsthng
	status	0,cd,hangb
	status	brkchr,0,wsend	/* send data input during full dpx */
	status	exh,0,wexh	/* stop the receiver now */
	status	break,0,otquit	/* quit? */
	rem
wdplto	goto	getwrk	/* ok, we have waited for all output */
	rem
wsend	tstflg	tfrabt,wtstec	/* see if we were told to throw it away */
	sendin		/* no, ship the data */
	waitm		/* and wait some more */
	rem
wtstec	tstflg	tfecpx,wdecho	/* echoplex? */
	goto	wdmpin	/* no, just dump it */
	rem
wdecho	echo	atchar	/* put at sign in echo buffer */
wdmpin	dumpin		/* throw away input */
	dmprpy		/* dump any accumulated replay */
	waitm		/* keep waiting */
	rem
wexh	meter2	m.exh,1
	contrl	rrec	/* stop the input now */
	goto	wsend	/* ship it and wait more */
	rem
wtest	tcntr	-10,wtestm	/* doning newline after quit */
	tstflg	tfwabt,dump	/* dump_output, do it */
wtestm	clrflg	tfwabt
	waitm		/* but don't perform hangup till output finishes */
	rem
chkeob	tstfld	t.omct,2,waitak	/* more than two blocks outstanding? */
	goto	sprint	/* proceed with output */
	rem
waitak	contrl	srec	/* we have to be able to see ack char */
	wait	0,0,tstack	/* here to suspend output until ack */
	status	0,cd,hangb	/* likewise */
	status	brkchr,0,wsend	/* forward input anyway */
	status	exh,0,wexh	/* always handle exhaust */
	status	break,0,otquit	/* likewise quit */
	rem
tstack	tstfld	t.omct,2,wtest	/* wasn't ack, look for other things */
	goto	sprint	/* was ack, resume output */
	ttls	check and perform hangups
	rem	come here when told to hangup line
	rem
hanga	stpchn		/* stop the channel */
	tstwrt	write	/* make sure there is no output now */
	setime	1	/* wait to make sure there's no more output */
	rem
	wait	hanga1,getwrk,0	/* if timeout, time to hang up */
	status	0,cts,hang3	/* line is hung up anyway */
	status	0,cd,hang3	/* likewise */
	rem
hanga1	gotype	(hang5,hang5,hang5,ahang,hang3)
	rem
	rem
	rem
	rem	come here when cts drops on a line
	rem
hang2	gotype	(hang5,hang5,hang5,hang5,hang10)
	rem
hang5	contrl	rxmit+rrec+rdtr+stat /* hangup and request status */
	rem
hangwt	setime	5	/* wait 5 seconds for it to happen */
	rem
	wait	hang3,0,0	/* if timeout, give up on him */
	status	0,cts,hang3	/* still down, done */
	rem
hang3	stpchn		/* stop channel again */
	dmpout		/* throw away output */
	signal	hangup	/* did it, tell 6180 */
	clrflg	(tflisn,tfhang)	/* clear the listen and hangup flags */
	goto	hungup
	rem
	rem
	rem
	rem	here when cd drops on a line
	rem
hangb	setime	1	/* wait one sec for carrier */
	rem
	wait	hang4,0,0	/* if timeout, check somemore */
	status	0,cts,hang2	/* if cts has dropped now, hangup */
	rem
hang4	contrl	rxmit+rrec+stat	/* get status of line */
	setime	5	/* wait 5 seconds */
	rem
	wait	hang4,0,0	/* if timeout, try to get status again */
	status	0,cts,hang2	/* cts down, hangup */
	status	0,cd,hang2	/* cd down still, giveup */
	status	cd+cts+dsr,0,hangqt /* back up, call it quit */
	rem
hangqt	gotype	(hang6,hang6,hang6,hang6,hang11)
	rem
hang6	sendin		/* send any input to 6180 */
	signal	quit	/* tell 6180 of quit */
	goto	dump	/* dump any output, what else can I do */
	rem
	rem	here when cd or cts drop on private sync lines
	rem
hang10	contrl	rxmit+rrec+stat	/* get line status */
	setime	10	/* wait 10 seconds for return */
	rem
	wait	hang10,0,tsthng
	status	cd+cts+dsr,0,hang11
	rem
hang11	goto	getwrk
	rem
	rem
	rem
*	the following is a control table subroutine to stop a channel
*	it is called by the stpchn macro from all control tables.
	rem
stpchn	contrl	rrec+rxmit+smark
	setime	1	/* if it doesn't come through in a second */
	wait	stptmo,0,0	/* try again */
	status	marker,0,stpch2
stpch2	retsub
	rem
stptmo	addlcl	stptmc,1	/* timed out, keep count */
	goto	stpchn	/* try it again */
stptmc	oct	0
	rem
	end
