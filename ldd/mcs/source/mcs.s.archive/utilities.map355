* ***********************************************************
* *                                                         *
* * Copyright, (C) Honeywell Information Systems Inc., 1982 *
* *                                                         *
* * Copyright (c) 1972 by Massachusetts Institute of        *
* * Technology and Honeywell Information Systems, Inc.      *
* *                                                         *
* ***********************************************************
	

	lbl	,utilities
	ttl	fnp utility programs for mcs
***************************************************************************
*
*  note:  cs means "central system"
*
***************************************************************************
*	change list
*
*	modified on july 24, 1972 by rbs to add code to handle dia
*
*	modified october 1974 by rsc for new system
*
*	modified july 4 1979 by bsg for echo negotiation
*
*	modified 1979 august 23 by art beattie to add 'setptw', 'mvpgsc' and
*	   'mvpgtg' routines.
*
*	modified january 19, 1981 by robert coren to add metering
*
*	modified march 1982 by robert coren to add space management in high
*	    memory
*
***************************************************************************

* HISTORY COMMENTS:
*  1) change(86-04-23,Coren), approve(86-04-23,MCR7300),
*     audit(86-05-19,Beattie), install(86-07-10,MR12.0-1089):
*     Modified november 1984 by robert coren to suppress check for eighth bit
*     before looking character up in echo break table.
*  2) change(88-01-15,Farley), approve(88-02-22,MCR7843),
*     audit(88-02-22,Beattie), install(88-03-01,12.2-1029):
*     added check in the inproc routine to see if there is no more room on the
*     line for echo negotiation (t.scll=0) after echoing a character. If no
*     room is left the input buffer should be sent to the host.
*                                                      END HISTORY COMMENTS
	rem
	rem
	pcc	on
	pmc	off
	detail	on
	editp	on
	rem
	rem
	symdef	util
	rem
	rem	system service package
	symdef	meterc	counting meter subroutine
	symdef	metert	timing meter subroutine
	symdef	gettib	get a tib address
	symdef	exist	* summary of iom channels that exist
	symdef	hfv	hardware fault vector entry base address
	symdef	ignore	ignore interrupts routine
	symdef	badint	extraneous interrupts routine
	symdef	iomflt	iom channel fault routine
	symdef	conabt	console operator abort
	symdef	octasc	binary-octal ascii routine
	symdef	conchn	console channel number
	symdef	outprc	subroutine to process "output" subop
	symdef	fulbuf	subroutine to check if a buffer is full
	symdef	chkiv	checks interrupt vectors
	symdef	utsave	place where registers get saved
	symdef	puteco	subroutine to add char to echo buffer
	symdef	inproc	subroutine to copy chars into input buffers
	symdef	move	looks up chars in carriage movement table
	symdef	setptw	converts absolute address to a virtual address
	symdef	setbpt	converts buffer address to virtual
	symdef	cvabs	converts a virtual address to absolute
	symdef	mvpgsc	move data paging source address
	symdef	mvpgtg	move data paging target address
	symdef	mvplmm	move paged lower memory maximum address
	symdef	conman	set to -1 by init if console_man is in image
	rem
	symdef	getbuf
	symdef	frebuf
	symdef	frelbf
	symdef	getubf
	symdef	getbfh	get a buffer in high memory
	symdef	frebfh	free a buffer in high memory
	symdef	getmem
	symdef	fremem
	symdef	fresml
	symdef	getbfm	interrupt time metering area
	symdef	fpsel	'sel' instructions patched by init
	symdef	obsel
	rem
	symref	dicell	cs interrupt cells
	symref	dmbx	cs mailbox address
	symref	contip	interrupt processor for console terminate
	symref	wcon	routine to write on console
	symref	ctrl	control tables
	symref	istat	status entry of interpreter
	symref	itest	test-state entry of interpreter
	symref	trace
	symref	ecgifl	accept-input queuer
	symref	denq	dia enqueuing routine
	symref	derrq	dia error message queue
	symref	hcheck	hsla_man starts echoing
	symref	simclk	simulated clock value
	symref	dspqur	dispatcher queuer
	symref	secdsp	secondary dispatcher
	symref	mincs
	symref	mincd
	symref	mupdat
	rem
	rem
	pmc	save,on
util	null
	start	util,4
	rem
	rem
	ttls	multiply and divide macros
	rem
mpy	macro	(multiplier loca	tion-*)
	mpf	#1
	lrl	1
	endm	mpy
	rem
	rem
dvd	macro	(divisor locatio	n-*)
	qls	1
	dvf	#1
	endm	dvd
	rem
	systm
	rem
	comreg
	rem
	tib
	rem
	meters
	rem
	intm
	rem
	sfcm	hsla
	rem
	buffer
	rem
	devtab
	rem
	dlytbl
	rem
	csbits
	rem
	pmc	restore
	ttls	miscellaneous symbols
	rem
************************************************************************
*		miscellaneous        
************************************************************************
	rem
	rem
k	equ	1024
itprty	equ	7	priority for timeout routine
	rem
bcdspc	bool	20
	rem
null	bool	000
space	bool	040
blank	equ	space
ht	bool	011
tab	equ	ht
lf	bool	012
cr	bool	015
rubout	bool	177
	rem
mask6	bool	077
mask7	bool	177
	rem
hslafl	bool	1000
	rem		return flags from inproc
reteco	bool	001	char(s) put in echo buffer
retsus	bool	002	output-suspend character
retres	bool	004	output-resume character
	rem
oct002	bool	002
oct003	bool	003
oct005	bool	005
oct007	bool	007
oct017	bool	017
oct020	bool	020
oct177	bool	177
sndout	bool	105	"send output" mailbox opcode
errmsg	bool	115	"error message" mailbox opcode
	rem
fbdevc	bool	37	device code mask
fcdevc	equ	13	device code lsb position
dclock	bool	01	device code for fnp's clocks
dprint	bool	06	device code for printer
ddia	bool	02	device code for dia
dcon	bool	05	device code for console
	rem
brkall	equ	-1	break on every character
brkctl	equ	-2	break on all control characters
brknxt	equ	-3	break on char after specifed char
	rem
ct.dev	equ	1	offset in ctrl of array of device table addrs
	rem
	rem
	rem
	rem	get and release buffer symbol definitions
	rem
adrs	equ	0	address
wrdsz	equ	1	number of words in buffer
fwdpt	equ	2	forward pointer
bckpt	equ	3	backward pointer
	rem
	rem
	rem	trace types
	rem
mt.get	equ	1	allocating single buffer
mt.fre	equ	2	freeing single buffer
mt.gtc	equ	3	allocating buffer chain
mt.frc	equ	4	freeing buffer chain
	rem
	rem
	ttls	miscellaneous external values
	rem
************************************************************************
*
*	Miscellaneous values shared by several modules, but kept here
* for simplicity.
*
************************************************************************
	rem
	rem
	rem
	rem	**********************************************
	rem	*
	rem	*      "exist" -- a summary of which IOM chans
	rem	* init found to exist.  the mapping
	rem	* used herein is: if bit N is on, the channel
	rem	* N has a valid channel attached to it.
	rem	*
	rem	**********************************************
	rem
	rem
exist	bss	1
	rem
	rem
	ttls	fault processing routines
	rem	*********************************************************
	rem	*     first level fault processing
	rem	*********************************************************
	rem
hfv	null
f0	ind	**	pf
	tsy	fp-*
f1	ind	**	po
	tsy	fp-*
f2	ind	**	mp
	tsy	fp-*
f3	ind	**	op
	tsy	fp-*
f4	ind	**	ov
	tsy	fp-*
f5	ind	**	im
	tsy	fp-*
f6	ind	**	dc
	tsy	fp-*
f7	ind	**	ii
	tsy	fp-*
	rem
	rem	the following "fault entry points" are not caused by any
	rem	of the eight above processor faults. they are entered
	rem	by software which detects the indicated condition.
	rem
badint	ind	**	xi -- extraneous interrupt
	tsy	fp-*
iomflt	ind	**	cf -- iom channel fault
	tsy	fp-*
conabt	ind	**	cn -- console operator abort
	tsy	fp-*
	eject
	rem	*********************************************************
	rem	*     second level fault processing
	rem	*********************************************************
	rem
fp	ind	**
	sti	save+1-*	save indicator register
	ldi	fp.inh-*	set "inh" and parity inh
	staq	save+2-*	save registers
	lda	iomflt+1-*	get iom channel fault vector
	sta	fvsave-*	and save it
	lda	l.a008-*	(tsy -1,*)
	sta	iomflt+1-*	so we don't get clobbered during fault handling
	stx1	save+4-*
	stx2	save+5-*
	stx3	save+6-*
	rier
	sta	save+7-*	save interrupt level enable register
	lda	a.a001-*,*	(etmb)
	sta	save+8-*	save elapsed timer value
	ldx1	fp-*	x1 = address+2 of original ic
	lda	-2,1	ar = original ic
	sta	save-*	save original instruction counter value
	rem
	cx1a		compute
	sba	a.a002-*	(f0+2) fault
	arl	1	number
	sta	fltnum-*	and save
	rem
	icmpa	9	is it an iom channel fault?
	tnz	fp006-*	no, continue
	ldx3	a.a012-*	addr(tyfts), fault status for chan 0
	lda	0,3	get fault status
	tze	fp001-*	not chan 0, check hsla channels
	icmpa	12	is status o14 on chan 0?
	tnz	fp006-*	no, go ahead and crash
	tra	fp004-*	yes, queue error message and resume work
	rem
fp001	null		check for hsla parity error
	ldx3	a.a016-*	addr(h1fts), fault status for hsla 1
fp002	null
	lda	0,3	get status
	tnz	fp003-*	non-zero, take a look at it
	iacx3	1	zero. was this last hsla fault status?
	cmpx3	a.a017-*	addr(h3fts) + 1
	tnz	fp002-*	no, check next one
	tra	fp006-*	yes, it's something else, crash
	rem
fp003	null		non-zero hsla fault status
	cmpa	l.a007-*	=o415 (parity)
	tnz	fp006-*	other bad status, crash
	rem
fp004	null		queue error message
	sta	rstat-*	save fault status
	rem
	ila	1	get error message code
	sta	rfault-*	save
	cx3a		get address of fault status word
	sba	a.a012-*	addr(tyfts) -- subtract origin to get chan no.
	sta	ric-*
	stz	rword-*	unused
	rem
	ilq	errmsg	get the opcode for derrq
	ldx2	a.a014-*	(=reason) get addr of data
	tsy	a.a013-*,*	(=derrq) queue the error_message
	rem
	stz	0,3	zero the fault status so we don't see it again
	tra	a.a015-*,*	restart the processor
	rem
fp006	lda	fltnum-*	restor the fault number
	als	3
	ada	a.a009-*	(f.name) compute address
	cax1		of and
	rem		get and save fault name
	ila	-4	(four doublewords worth)
	sta	fptemp-*
	ldx2	a.a010-*	addr(fltnam)
fp008	null
	ldaq	0,1	pick up two words
	staq	0,2	store them
	iacx1	2	bump from and to pointers
	iacx2	2
	aos	fptemp-*	done?
	tnz	fp008-*	no, do it again
	rem
	rem
	rem
	rem
	rem	*********************************************************
	rem	*  mask all hsla's and lsla's
	rem	*********************************************************
	rem
	ila	h1ch	starting with first hsla channel
fp009	null
	cax3		hang on to iom channel no.
	ora	l.a002-*	(=o730000) "sel" opcode
	sta	msksel-*
msksel	zero		patched with sel instruction
	cioc	dispcw-*	issue mask pcw
	cx3a
	iaa	1	next iom channel
	icmpa	l6ch+1	finished lsla's?
	tmi	fp009-*	no, do it again
	rem
	rem
	rem	*********************************************************
	rem	*  set interrupt level enable register to enable
	rem	*  levels 0, 1, and 2 only.  set up ignore iv's
	rem	*  for all devices on levels 0, 1, and 2 except
	rem	*  console.
	rem	*********************************************************
	rem
	lda	l.a001-*	(=o700000)
	sier
	rem
	ldx3	l.a003-*	(=o000400)
	ldx2	a.a007-*	(sd.iv+48-3)
fp010	null
	ldaq	-16,3	move iv's for levels 0, 1, and 2
	sta	0,2	to save area (sd.iv) and replace with
	stq	1,2	address of ignore routine
	lda	-14,3
	sta	2,2
	ldaq	a.a004-*	(ignore)
	staq	-16,3
	sta	-14,3
	iacx2	-3
	iacx3	-16
	tnz	fp010-*
	rem
	lda	conchn-*	re-initialize console iv's
	tmi	fp015-*
	als	4
	cax3
	lda	a.a008-*
	sta	2,3
	rem
	rem
	rem	***************************************************
	rem	*  use software fault vector to write
	rem	*  farewell message on console
	rem	***************************************************
	rem
fp015	null
	ldx1	fltnum-*
	adcx1	a.a003-* (sfv)
	tsy	0,1*
	rem
	rem
	rem	*******************************************************
	rem	*   send cs reason for crash
	rem	*******************************************************
	rem
	rem
	lda	fltnum-*	get fault type code
	sta	rfault-*
	rem		get cs address (word 6 of mailbox header)
	lda	a.a011-*,*	dmbx
	iaa	6
	sta	dcwlst-*	put it in dcw
	alp	18	fix parity
	tnz	fp16-*	odd, nothing to do
	lda	l.a005-*	parity bits
	orsa	dcwlst+1-*
	rem
fp16	null		fix parity on second half of dcw
	lda	dcwlst+2-*
	alp	18
	tnz	fp17-*
	lda	l.a005-*
	orsa	dcwlst+3-*
	rem
fp17	null		fix parity in list icw address for pcw
	lda	licadr-*
	alp	18
	tnz	fp18-*
	ldq	l.a006-*	=o060070
	tra	2
fp18	null
	ilq	56	i.e., o000070
	staq	a.a005-*,*	dimb (dia pcw mailbox)
	rem
fpsel	sel	**
	cioc	a.a005-*,*	dimb
	rem
	rem
	rem	*********************************************************
	rem	*  shut down all io devices
	rem	*********************************************************
	rem
	tsy	a.a006-*,*	(obit) disconnect the cs
	rem
	ldaq	diapcw-*	insert mask pcw into
	staq	a.a005-*,*	dia pcw mailbox
	rem
	ila	16	* pick up number of channels to mask
fp020	cax3		* put current channel num in X3
	ora	l.a002-*	* (=o730000) get the "sel" op-code
	sta	fp030-*	* and store for execution
fp030	zero		* (ALTRD) patched to "sel" instruction
	cioc	dispcw-*	* issue the masking PCW
	rem
fp.040	cx3a		* get current channel into A reg
	iaa	-1	* subtract one from it
	tpl	fp020-*	* and if still positive, go mask it
	rem
	rem
	rem
	tra	stop-*	that's all, go to sleep
	eject
	even
dispcw	oct	0,010000	mask bit on to disable channel
diapcw	oct	0,070000	dia pcw with parity bits
l.a001	oct	700000
l.a002	oct	073000
l.a003	zero	256
l.a004	zero	oct020
l.a005	oct	060000
l.a006	oct	060070
l.a007	oct	000415	iom parity fault status
l.a008	tsy	-1,*	used to make fault vector into nop
	rem
a.a001	ind	etmb	elapsed timer mailbox address
a.a002	zero	f0+2
a.a003	zero	sfv
	even
a.a004	ind	ignore
	ind	ignore
a.a005	ind	dimb	dia mailbox address
a.a006	ind	obit
a.a007	zero	sd.iv+48-3
a.a008	ind	contip	console terminate interrupt proc.
a.a009	zero	f.name
a.a010	zero	fltnam
a.a011	ind	dmbx
a.a012	ind	tyfts
a.a013	ind	derrq
a.a014	ind	reason
a.a015	ind	pwron
a.a016	ind	h1fts	iom fault status word, hsla 1
a.a017	ind	h3fts+1	1 word past iom fault status word for hsla 3
a.a018	ind	iomflt+1	to restore branch address
fp.inh	oct	030000
	rem
	even
utsave	null		symdef symbol
save	bss	9	(ic, i, a, q, x1, x2, x3, er, et)
fltnum	bss	1	save current fault number
fltnam	bss	8	save current fault name
conchn	zero	tych	= console ch no.
fptemp	bss	1
fvsave	bss	1	place to save iom channel fault vector
	rem
	rem
	even
reason	null		72 bits sent to cs to tell why we crashed
rfault	bss	1	fault type code
ric	bss	1	instruction counter
rstat	bss	1	iom fault status if applicable
rword	bss	1	contents of fault word, or iom channel
	rem
	even
lsticw	zero	dcwlst,w.2
	oct	4
	rem
	rem		dcw list for sending reason to cs
dcwlst	zero		cs address (filled in later)
	oct	75	fnp -> cs opcode (parity added later)
	zero	reason,w.2	fnp address
	oct	2	tally (parity added later)
	zero
	oct	060070	disconnect opcode (with parity)
	zero	0,w.2
	oct	020000	(parity)
	rem
	rem
	even
licadr	zero	lsticw,w.2
	rem
	rem
	rem
	even
f.name	ascii	8,power off	fault mnemonic names
	ascii	8,power on
	ascii	8,memory parity
	ascii	8,illegal opcode
	ascii	8,overflow
	ascii	8,store fault
	ascii	8,divide check
	ascii	8,illegal int
	ascii	8,extra int
	ascii	8,iom fault
	ascii	8,console abort
	eject
	rem	*********************************************************
	rem	*     software fault vectors
	rem	*********************************************************
	rem
sfv	null
	ind	ignore	pf
	ind	ignore	po
	ind	mempar	mp
	ind	illop	op
	ind	icprt	ov
	ind	icprt	im
	ind	icprt	dc
	ind	ignore	ii
	ind	ignore	xi
	ind	chflt	cf
	ind	ignore	cn
	rem
	rem
	rem
	eject
************************************************************************
*	power off fault processing routine
************************************************************************
	rem
stop	null
pwroff	null
	ila	0	disable all interrupts and stop
	sier
	dis
	tra	-1
	rem
	rem
	rem
************************************************************************
*	power turn on fault processing routine
************************************************************************
	rem
pwron	null
	inh
	lda	save+7-*	restore interrupt level enable register
	sier
	lda	save+8-*	restore elapsed timer value
	sta	a.a001-*,* (etmb	)
	lda	fvsave-*	pick up saved iom channel fault vector
	sta	a.a018-*,*	(iomflt+1) restore it
	ldaq	save+2-*	restore arithmetic registers
	ldx1	save+4-*
	ldx2	save+5-*
	ldx3	save+6-*
	ldi	save+1-*
	tra	save-*,*	return to point of interruption
	rem
	rem
	rem
************************************************************************
*	ignore interrupts routine
************************************************************************
	rem
ignore	ind	**
	tra	-1,*
	rem
	eject
************************************************************************
*	routine to print faulting ic (and possibly instruction)
*	on console
************************************************************************
	rem
illop	ind	**	this entry to print instruction as well
	aos	wflag-*	set flag
	lda	illop-*	copy return point
	sta	icprt-*
	tra	icp010-*
	rem
	rem		this entry to print ic only
	rem
icprt	ind	**
	stz	wflag-*
icp010	null		both come to here
	ldx2	a.i007-*	addr(msgnam)
	ldx3	a.i005-*	addr(fltnam) get address of fault name
	ila	-4	4 doublewords worth
	sta	itemp-*	to move it into message
icp020	null
	ldaq	0,3
	staq	0,2
	iacx2	2
	iacx3	2
	aos	itemp-*
	tnz	icp020-*	if not done, do next two words
	rem
	ldq	a.i006-*,*	(save) get ic value
	iaq	-1	really points to next instruction
	stq	itemp-*	save it
	stq	a.i012-*,*	(ric) save for sending to cs
	ldx3	a.i001-*	addr(icasci)
	rem		now convert it to ascii and put it in
	tsy	a.i003-*,*	octasc
	rem
	szn	wflag-*	write out word too?
	tze	icp030-*	no, go write on console
	rem		else convert instruction word
	rem		to octal ascii and put in message
	ldx3	itemp-*
	ldq	0,3	got word
	stq	a.i013-*,*	(rword) save for sending to cs
	ldx3	a.i002-*	addr(wdasci)
	tsy	a.i003-*,*	octasc
	rem
	ila	16	increase tally in icw
	asa	flticw+1-*
	rem
icp030	null		now write on console
	szn	conman-*	is console_man in image?
	tze	icprt-*,*	no. skip console stuff and return
	tsy	a.i004-*,*	(wcon) yes. go do it
	zero	flticw	argument is address of data icw
	nop		if no console, don't worry
	tra	icprt-*,*	return to caller
	rem
	rem
************************************************************************
*	routine to write out message for iom channel fault
************************************************************************
	rem
chflt	subr	chf
	rem
	rem		write the channel number and
	rem		associated fault status
	rem
	rem		we start by finding a non-zero fault status
	ilq	0	initialize channel number
	ldx3	a.i008-*	addr(iom fault status)
chf010	null
	lda	0,3
	tnz	chf020-*	non-zero, we got it
	iaq	1	else bump channel number
	iacx3	1	and fault status pointer
	tra	chf010-*	and try again
	rem
chf020	null		channel no. is in q
	sta	itemp-*	save fault status
	staq	a.i011-*,*	(rstat) save both for sending to cs
	ldx3	a.i009-*	addr(chnasc)
	tsy	a.i003-*,*	(octasc) convert channel no.
	rem
	lda	chnasc+2-*	pick up low-order 2 digits
	sta	chfnum-*	put them in console message
	rem
	ldq	itemp-*	get fault status and convert it to ascii
	ldx3	a.i010-*	addr(chfst)
	tsy	a.i003-*,*	octasc
	rem		now just write the message out
	szn	conman-*	is console_man in image?
	tze	chfret-*	no. skip console stuff
	tsy	a.i004-*,*	(wcon) yes. go do it
	zero	chficw
	nop
	rem
chfret	null
	return	chflt
	rem
	rem
************************************************************************
*	routine to write out memory parity fault message
*	we will go through all of memory until we find something
*	that results in parity indicator coming on
************************************************************************
	rem
mempar	subr	mmp
	stz	pagbas-*	initialize this
	lda	a.i015-*,*	(.crmem)
	cmpa	l.i001-*	(=o100000) more than 32k?
	tpl	mmp010-*	no
	sta	memlst-*	then that's the end
	tra	mmp020-*
mmp010	lda	l.i002-*	(=o077777) more than 32k, first pass will stop there
	sta	memlst-*
	ldx3	a.i016-*,*	(.crpte)
	stz	0,3	disable paging for now
mmp020	stz	tstadr-*	start at 0
	ldi	a.i014-*,*	fp.inh (make sure we start with clean indicators)
mmp030	lda	tstadr-*,*	pick up contents of next word
	sti	tstind-*	see what happened to the indicators
	lda	l.i003-*	=o002000, parity error indicator bit
	cana	tstind-*	is it on?
	tnz	mmp050-*	yes, we found it
	lda	tstadr-*	no, we'll advance the address
	cmpa	memlst-*	finished this pass?
	tze	mmp040-*	yes
	aos	tstadr-*	no, increment test address
	tra	mmp030-*	and go around again
	rem
mmp040	ldq	pagbas-*	see if current address is real or virtual
	tze	mmp045-*	it's real
	iaq	255	it's virtual, test for real limit
	cqa
mmp045	cmpa	a.i015-*,*	(.crmem) have we reached the end?
	tpl	mmp060-*	yes, we didn't find it
	iaa	1	else do next page
	sta	pagbas-*	this is the base of it
	tsy	a.i017-*,*	(setptw)
	rem		note that this is safe because we've tested here
	sta	tstadr-*	this is presumably 077400 (virtual page base)
	iaa	255	this is the last virtual address in it
	sta	memlst-*
	tra	mmp030-*	start again
	rem
mmp050	null		here when we find a parity indicator
	cmpa	l.i004-*	(o077400) in window?
	tmi	mmp070-*	no, it's exact
	szn	pagbas-*	but we were really there?
	tze	mmp070-*	yes
	sba	l.i004-*	else reduce to offset within page
	ada	pagbas-*	add page address
	tra	mmp070-*	this is it
mmp060	ila	-1	we never found it, use dummy value
mmp070	sta	a.i012-*,*	(ric) save it to send to cs
	szn	conman-*	is there a console?
	tze	mmpret-*	no, we're done
	caq		get value in q
	ldx3	a.i018-*	addr (mmpadr)
	tsy	a.i003-*,*	octasc
	tsy	a.i004-*,*	wcon
	zero	mmpicw
	nop
mmpret	return	mempar
	rem
	rem
	rem
a.i001	zero	icasci,b.0
a.i002	zero	wdasci,b.0
a.i003	ind	octasc	binary to octal ascii conversion routine
a.i004	ind	wcon	console-writing routine
a.i005	ind	fltnam
a.i006	ind	save	contains ic
a.i007	zero	msgnam
a.i008	zero	fltst	iom fault status
a.i009	zero	chnasc,b.0
a.i010	zero	chfst,b.0
a.i011	ind	rstat	used in sending crash info to cs
a.i012	ind	ric	likewise
a.i013	ind	rword	likewise
a.i014	ind	fp.inh
a.i015	ind	.crmem
a.i016	ind	.crpte
a.i017	ind	setptw
a.i018	ind	mmpadr,b.0
	rem
l.i001	oct	100000
l.i002	oct	077777
l.i003	oct	002000	parity error indicator
l.i004	oct	077400	base of paging 'window'
	rem
conman	oct	0	set to -1 by init if console_man is in image
	rem
	even
flticw	icw	fltmsg,b.0,38
	zero		to force fltmsg odd to force msgnam even
	rem
	detail	save,off
fltmsg	saci	cr,lnf
msgnam	bss	8	fault name
	ascii	7,fault -- ic =
icasci	bss	3
	ascii	4,, word =
	saci	sp,sp
wdasci	bss	3
	rem
	rem
	even
chficw	icw	chfmsg,b.0,48
	rem
chfmsg	saci	cr,lnf
	ascii	10,iom fault: ch	annel
chfnum	bss	1
	ascii	9,, fault status	-
chfst	bss	3
	rem
	even
mmpicw	icw	mmpmsg,b.0,34
	rem
mmpmsg	saci	cr,lnf
	ascii	13,memory parity referencing
mmpadr	bss	3
	detail	restore
	rem
	rem
chnasc	bss	3
wflag	bss	1
itemp	bss	1
memlst	bss	1	last address to test in each pass
pagbas	bss	1	base of current page
tstadr	bss	1	adress on which to test parity
tstind	bss	1	indicators resulting from test
	rem
	rem
	eight
sd.iv	bss	3*16  (level 0,	1, and 2 iv's at time of fault)
	ttls	obit -- notify cs of fnp's death
************************************************************************
*
* this subroutine will send an "emergency interrupt" to the cs,
* thereby indicating that the fnp is about to crash
*
************************************************************************
	rem
obit	ind	**
	lda	obit0-*	as a last gesture of politeness, allow
	iaa	-1	the dia to xmt its last message
	tnz	-1
	rem
	lda	obit1-*,*	get emergency interrupt cell
	iana	7	isolate it
	caq		put in q
	qls	6	position
	adq	obit3-*	get interrupt cs command
	cqa		save this in a
	qlp	18	get parity on this word
	tnz	2	already odd
	ora	obit4-*	make odd parity lower
	caq		put correctly paritized word back in q
	lda	obit5-*	load word with 36 bit xfer mode bit on
	staq	obit2-*,*
	rem
obsel	sel	**	so long, its been good to know you
	cioc	obit2-*,*
	tra	obit-*,*
	rem
	rem
	rem
obit0	dec	3500
obit1	ind	dicell
obit2	ind	dimb
obit3	oct	000073	upper half odd parity and int cs cmd
obit4	oct	020000	lower half parity bit
obit5	zero	0,w.2	word with 36-bit xfer mode
	ttls	bdecac -- binary-decimal ascii routine
************************************************************************
* this routine converts a binary number into four ascii characters which
* represent the decimal equivalent of the number.
*
* the input binary number must be non-negative and <= 9999 (23417, oct).
*
* calling sequence --
*
*	c(x3) = ch/wd address of where 1st digit is to be stored.
*	c(ar) = the binary number to be converted.
*	tsy     bdecac-*
*
* on return, x3 will point to the position following the 4th digit.
************************************************************************
	rem
bdecac	ind	**
	sti	bdasvi-*	save indicators
	inh		inhibit interrupts
	stx2	bdasx2-*	save x2
	ilq	-4	set loop counter
	stq	bdactr-*	for 4 iterations
	ldx2	bdacon-*	set x2 for 1st conversion constant
	rem
bda1	null
	ilq	0	clear q-register
	lrs	18-1-3	build dividend multiplied by 8
	dvf	0,2	produce a bcd digit in a-register
	iora	48 (060)	convert it to ascii code
	sta	0,3,b.0	store in user's area
	cqa
	rem
	iacx3	0,b.1	bump pointer to next digit store position
	iacx2	1	bump pointer to next conversion constant
	aos	bdactr-*	? done this 4 times, yet ?
	tnz	bda1-*	nope
	rem
	ldx2	bdasx2-*	restore x2
	ldi	bdasvi-*	restore indicators
	tra	bdecac-*,*	restore control to user
	rem
bdasvi	bss	1	safe store indicators
bdasx2	bss	1	safe store x2
bdactr	bss	1	loop counter
bdacon	zero	*+1	conversion constant initial pointer
	dec	8000,6400,5120,4096
	ttls	octal-to-bcd/ascii subroutines
************************************************************************
* octbcd/octasc will convert the six octits in the quotient register
* into six 6-bit/9-bit bcd/ascii characters and store them in sequential
* positions beginning at the address in x3.
*
* calling sequence --
*
*	ldq     <octal word to be converted>
*	ldx3    <ch/wd address for 1st character>
*	tsy     <octbcd/octasc>
************************************************************************
	rem
octbcd	ind	**
	stx2	octsv-*	save x2
	ldx2	octsv+1-*	set x2 = 6
	ila	0
	lls	3
	sta	0,3,c.0	store character
	iacx3	0,c.1	bump character pointer
	iacx2	-1	? finished ?
	tnz	-5	no
	ila	bcdspc	yes, store a space
	sta	0,3,c.0
	iacx3	0,c.1
	ldx2	octsv-*	restore x2
	tra	octbcd-*,*	return
	rem
octasc	ind	**
	stx2	octsv-*	save x2
	ldx2	octsv+1-*	set x2 = 6
	ila	6
	lls	3
	sta	0,3,b.0	store character
	iacx3	0,b.1	bump character pointer
	iacx2	-1	? finished ?
	tnz	-5	no
	ldx2	octsv-*	restore x2
	tra	octasc-*,*	return
	rem
	rem
octsv	bss	1
	dec	6
	ttls	get tib address routine
************************************************************************
*
*	gettib
*
*		enter a - multics line number
*
*		this routine will take a multics line number and
*		convert it to the associated real tib address which will
*		be returned in the a. if no tib exists, the
*		a will contain 0. In either case, the address of the
*		lsla or hsla table entry for the line will be returned
*		in the q
*
*		a multics line number is a 10 bit value which is right
*		justified in the a. the rightmost 6 bits contain the
*		slot number/line number (starting with 0), the next 3 bits
*		hold the lsla or hsla number (starting with 0) and the
*		next bit is 1 if hsla or 0 if lsla
*
*		line 1777 is a pseudo-channel used fro communication with
*		the colts executive; its tib address is held in .crtdt,
*		and it does not have the other associated data bases
*
************************************************************************
	rem
gettib	subr	gtb,(inh,x1)
	cmpa	l.h001-*	(=o1777) is this colts channel?
	tze	gtb020-*	yes, special case
	lrl	6	put line number in q
	iera	8	flip hsla/lsla flag (1 = lsla now)
	icana	8	test for hsla or lsla
	tnz	2	it is an lsla
	iaa	5	hsla, add to hsla number
	iaa	1	add 1 to lsla or hsla no.
	als	1	multiply hsla/lsla number by 2 (iom table entry s
	ada	a.h001-*,*	add iom table base
	cax1		and put in x1
	ila	0	clear a
	lls	6	refetch line number
	als	1	times 2
	ada	1,1	add table base address from iom table entry
	cax1		put addr of word 0 of table entry in x1
	ldq	1,1	get tib address from table
	llr	18	put tib addr in a, slot addr in q
gtb010	return	gettib	return to caller
	rem
gtb020	lda	a.h002-*,*	.crtdt
	ilq	0	no table entry for colts channel
	tra	gtb010-*	return
	rem
a.h001	ind	.criom
a.h002	ind	.crtdt
	rem
l.h001	oct	1777
	ttls	chkiv -- procedure to check the interrupt vectors
	rem
************************************************************************
*
*	"chkiv" -- procedure to check that the Interrupt Vectors
* are not destroyed.  This procedure does not verify that all IV's are
* correct; it only checks the "reasonableness" of them.
*
*
************************************************************************
	rem
	rem
	rem
chkiv	subr	chk,(inh,a,q,x1)
	rem
	ldaq	chkcnt-*	* let us add one to the call counter
	adaq	chkone-*	* add one ..
	staq	chkcnt-*	* and put back
	rem
	ila	0
	cax1
	rem
chklp	lda	0,1
	cmpa	chkhgh-*
	tmi	chkstp-*
	iacx1	1
	cmpx1	chkmax-*
	tnz	chklp-*
	rem
	return	chkiv
	rem
chkstp	die	6
	rem
	rem
chkmax	oct	40	* number of locations to check
chkhgh	oct	1000	* highest number which is not ok
	rem
	even
chkone	dec	0,1	* double precision one
chkcnt	dec	0,0
	rem
	ttls	inproc subroutine -- copy chars into input buffers
	rem
	rem	called by hsla_man and lsla_man as input characters
	rem	arrive in order to put them in input buffers in t.icp
	rem	chain; updates t.pos and puts characters in echo buffer
	rem	if appropriate, and may present status to the control tables.
	rem	implements echoplex, tabecho, echo negotiation, etc.
	rem
	rem	at entry:
	rem	   a  contains 0 for 7-bit, nonzero for 6-bit chars
	rem	   q  contains number of characters
	rem	   x3 points to first character
	rem
	rem	returns in a:
	rem	   bit 17 on if anything put in echo buffer
	rem	   bit 16 on if output-suspend char received
	rem	   bit 15 on if output-resume char received
	rem
inproc	subr	inp,(x1,x2,x3)
	rem
	iaa	0	6- or 7-bit characters?
	tze	inp005-*	7
	ila	mask6	6
	tra	2
inp005	ila	mask7
	sta	pmask-*	hang on to parity mask
	rem
	cqa		get character count
	tze	a.b016-*,*	(inpbak) none, nothing to do
	iera	-1	negate it
	iaa	1
	sta	inrem-*	save negative version
	stz	inecho-*
	stz	insusp-*
	stz	inres-*
	stz	inq-*
	rem
	stz	inpte-*	initially
	cx3a		find out if input pointer is in buffer window
	ana	l.b025-*	=o077777 (get word part alone)
	cmpa	l.b030-*	=window, general addressing window
	tpl	inp006-*	it's there, therefore not in buffer window
	cmpa	l.b031-*	=bwndow, buffer window
	tmi	inp006-*	below it, in regular low memory
	ldx2	a.b022-*,*	.crbte
	lda	0,2	save contents of buffer pte
	sta	inpte-*
	rem
inp006	lda	t.flg2,1	in iflow now?
	cana	l.b022-*	(=tfifc)
	tze	inp010-*
	lda	t.flg3,1	watching the time?
	cana	l.b021-*	=tfitim
	tze	inp010-*
	cana	l.b027-*	(=tfsked) inptim already scheduled?
	tnz	inp007-*	yes, don't do it again
	lda	t.line,1	we need absolute tib address
	tsy	a.b019-*,*	gettib
	cax1		into x1 for dspqur
	ldaq	a.b010-*	time, priority, address for inptim
	tsy	a.b011-*,*	(dspqur) make sure it runs
	ldx1	inpsx1-*	get x1 back
	lda	l.b027-*	=tfsked
	orsa	t.flg3,1	it's scheduled now
	rem
inp007	stz	intime-*	initialize for recording current time
	lda	a.b012-*,*	(itmb) get interval timer
	sta	intime+1-*
	ldaq	a.b013-*,*	(simclk) and time it's due to go off
	sbaq	intime-*	now we have current time
	staq	t.itim,1	hang on to it
	rem
inp010	stx3	inchrp-*	save char pointer
	ldq	0,3,b.0	get next char
	stq	inchar-*
	lda	t.flg3,1	if we're supposed to,
	cana	l.b028-*	(tf8in)
	tnz	inp012-*
	lda	pmask-*	fix parity on it
	ansa	inchar-*
inp012	ldq	inchar-*	save as original value
	stq	inorig-*	in case lfecho changes it
	lda	t.flg2,1
	cana	l.b012-*	(=tffrmi) in frame mode?
	tze	inp015-*	no, don't bother checking
	lda	t.frmc,1
	arl	9	get frame-begin char alone
	tze	3	zero (null) means any
	cmpa	inchar-*	is this it?
	tnz	inp015-*	no, check for break
	lda	l.b010-*	=tffip
	orsa	t.flg2,1	frame in progress now
	rem
inp015	null
	tsy	a.b015-*,*	(chkofc) see if it's output flow control char
	tra	a.b017-*,*	(inp300) chkofc fully processed the character
	ldq	inchar-*	get character back without parity
	rem		now check carriage movement table
	lda	t.pos,1	save old column indicator
	sta	oldpos-*
	tsy	a.b004-*,*	=addr(move)
	tra	inp020-*	for line feed
	tra	inp030-*	for carriage return
	tra	inp050-*	for tab
	tra	inp060-*	for backspace (do nothing)
	tra	inp070-*	no hit
	rem
	rem
inp020	null		line feed
	lda	l.b002-*	=tfcrec
	cana	t.flg,1	crecho mode?
	tze	inp100-*
	szn	oldpos-*	were we already in column 0?
	tze	inp100-*	if so, don't echo carriage return
	ilq	cr	put carriage return in echo buffer
	tsy	a.b003-*,*	=addr(puteco)
	tra	inp100-*
	rem
inp030	null		carriage return
	lda	l.b003-*	=tflfec
	cana	t.flg,1	lfecho mode?
	tze	inp100-*
	lda	l.b004-*	=tfecpx
	cana	t.flg,1	echoplex mode?
	tze	inp040-*	no, go ahead
	ilq	cr	else have to echo cr explicitly
	tsy	a.b003-*,*	puteco
inp040	null
	ilq	lf	put line feed in echo buffer
	rem		and input buffer
	stq	inchar-*
	tsy	a.b003-*,*	=addr(puteco)
	tra	inp110-*
	rem
inp050	null		tab
	cax2		save space count
	lda	l.b005-*	=tftbec
	cana	t.flg,1	tbecho mode?
	tze	inp100-*
	tsy	a.b003-*,*	puteco
	tra	inp110-*	don't echoplex it also
	rem
inp060	null
	tra	inp100-*
	rem
inp070	null
	lda	a.b006-*,*	mshift (set by move subroutine)
	tze	inp090-*	not a case shift character
	icmpa	1	yes, is it up-shift?
	tnz	inp080-*	no
	lda	l.b006-*	=tfupsf
	orsa	t.flg2,1	yes, turn flag on
	tra	inp100-*
inp080	null		down-shift
	lda	l.b007-*	=^tfupsf
	ansa	t.flg2,1	turn flag off
	tra	inp100-*
	rem
inp090	null
	lda	l.b006-*	=tfupsf
	cana	t.flg2,1	are we in uppercase?
	tze	inp100-*
	ila	64	yes, mark character
	orsa	inchar-*
	rem
inp100	null
	ldq	inchar-*
	lda	l.b004-*	=tfecpx
	cana	t.flg,1	echoplex?
	tze	inp110-*
	rem		yes, put char in echo buffer
	tsy	a.b003-*,*	=addr(puteco)
	tra	inp110-*	branch around literals & storage
	eject
pmask	bss	1	parity mask
inchrp	bss	1	pointer to current character
inrem	bss	1	number of characters remaining (negative)
inecho	bss	1	nonzero if something put in echo buffer
insusp	bss	1	nonzero if output_suspend char received
inres	bss	1	nonzero if output_resume char received
inchar	bss	1	copy of current character
inorig	bss	1	original contents of inchar
oldpos	bss	1	original value of t.pos
inenef	bss	1	echo negotiation flag
inpte	bss	1	buffer pte when we started
inpvir	bss	1	temporary storage for virtual address
inq	bss	1	nonzero => can append to queued input chain
	even
intime	bss	2	current time
	rem
	rem
a.b001	ind	istat
a.b002	ind	getubf
a.b003	ind	puteco
a.b004	ind	move
a.b005	ind	fulbuf
a.b006	ind	mshift
a.b007	ind	hcheck
a.b008	ind	echngo
a.b009	ind	ecgifl
	even
a.b010	vfd	12/1,6/itprty	1 second, and priority of inptim
	ind	inptim
a.b011	ind	dspqur
a.b012	ind	itmb	interval timer mailbox
a.b013	ind 	simclk	simulated clock value
a.b014	ind	itest
a.b015	ind	chkofc
a.b016	ind	inpbak
a.b017	ind	inp300
*a.b018		unused
a.b019	ind	gettib
a.b020	ind	.crnbf
a.b021	ind	setbpt
a.b022	ind	.crbpe
a.b023	ind	eforce
      	rem
	rem
l.b001	zero	0,b.0
l.b002	vfd	18/tfcrec
l.b003	vfd	18/tflfec
l.b004	vfd	18/tfecpx
l.b005	vfd	18/tftbec
l.b006	vfd	18/tfupsf
l.b007	vfd	o18//tfupsf
l.b008	vfd	18/s.exh
l.b009	vfd	18/s.prex
l.b010	vfd	18/tffip
l.b011	oct	000777
l.b012	vfd	18/tffrmi
l.b013	vfd	18/bffbrk
l.b014	vfd	18/s.brch
l.b015	vfd	18/tfbral
l.b016	vfd	18/tfsftr
l.b017	vfd	o18//tfwrit
l.b018	vfd	18/hslafl
l.b019	vfd	18/buftmk
l.b020	oct	024000	"inhibit overflow" & "inhibit interrupts"
l.b021	vfd	18/tfitim
l.b022	vfd	18/tfifc
*l.b023		unused
*l.b024		unused
l.b025	oct	077777
l.b026	vfd	18/tfisus
l.b027	vfd	18/tfsked
l.b028	vfd	18/tf8in
l.b029	dec	1	for adding to meters
l.b030	vfd	18/window
l.b031	vfd	18/bwndow
l.b032	vfd	18/tfinq
	eject
inp110	null
	stz	inenef-*	zero echnego did echo flag.
	szn	t.scll,1	are we echo-negotiating?
	tze	inp114-*
	lda	inchar-*	hand the character to echngo
	tsy	a.b008-*,*	(echngo) echo negotiably
	sta	inenef-*	remember whether he actually echoed.
inp114	null
	szn	t.icp,1	are we already building an input chain?
	tnz	inp119-*	yes
	rem		otherwise we might just want to add to t.dcp
	szn	inq-*	have we done so once already?
	tnz	inp116-*	yes, some of these tests are unnecessary
	lda	t.flg3,1	in breakall mode?
	cana	l.b015-*	tfbral
	tze	inp120-*	no, never mind
	cana	l.b032-*	(tfinq) is it safe to append?
	tze	inp120-*	no, don't try
inp116	lda	t.dlst,1	get last buffer of queued input
	tze	inp120-*	surprise, there isn't one
	tsy	a.b021-*,*	(setbpt) get its virtual address
	cax3		find out if it's full
	tsy	a.b005-*,*	fulbuf
	tra	inp120-*	it is. oh well, we tried
	aos	inq-*	remember that that's where the character goes
	tra	inp200-*	and skip all the buffer manipulation stuff
	rem
inp119	null		old chain
	lda	t.ilst,1	find out if last buffer is full
	tsy	a.b021-*,*	(setbpt) convert address to virtual
	cax3
	tsy	a.b005-*,*	fulbuf
	tra	2	it is
	tra	inp190-*	it isn't, branch around buffer allocation code
	rem
inp120	null		check for exhaust condition
	stz	inq-*	can't add to dia chain now
	lda	t.icpl,1	how many buffers have we got so far?
	ada	t.dcpl,1
	icmpa	bufmax	too many?
	tmi	inp125-*	no
	lda	t.stat,1	yes, send exhaust status
	iana	s.dss	common bits only
	ora	l.b008-*	=s.exh
	tsy	a.b001-*,*	=addr(istat)
	tra	inp140-*
	rem
inp125	lda	t.flg2,1	see if we should request input suspension
	cana	l.b022-*	=tfifc
	tze	inp130-*	mode isn't on, certainly not
	lda	t.icpl,1	chain long enough?
	icmpa	bufmax/2
	tpl	inp128-*	yes
	als	2	multiply by 4
	cmpa	a.b020-*,*	(.crnbf) more than 1/4 of remaining space?
	tmi	inp130-*	no, skip it
inp128	ldq	t.ifch,1	yes, get input flow control chars
	qrl	9	get suspend char alone
	tsy	a.b023-*,*	(eforce) into echo buffer
	rem
inp130	lda	t.icpl,1	have we got enough to send no matter what?
	icmpa	bufpre
	tmi	inp140-*	no
	lda	t.stat,1	yes, signal pre-exhaust status
	iana	s.dss	common bits only
	ora	l.b009-*	s.prex
	tsy	a.b001-*,*	=istat
	rem
inp140	null		
	rem
	rem		get a fresh buffer
	ilq	bufsiz
	tsy	a.b002-*,*	=addr(getubf)
	tra	inp150-*	error, cannot get buffer
	aos	t.icpl,1	increment buffer count
	caq		hold on to address
	tra	inp160-*	continue
	rem
	rem		send exhaust status, forget input char
inp150	cmeter	mincs,m.inaf,l.b029-*
	rem
	lda	t.stat,1	get tib status bits
	iana	s.tib	common bits only
	ora	l.b008-*	=s.exh
	tsy	a.b001-*,*	=addr(istat)
	tra	inp300-*	go to next slot
	rem
inp160	szn	t.icp,1	new chain or old?
	tze	inp170-*	new
	rem		old, chain new buffer on
	lda	t.ilst,1
	tsy	a.b021-*,*	setbpt
	cax2
	stq	bf.nxt,2
	tra	inp180-*
	rem
inp170	null
	stq	t.icp,1	new buffer is input chain head
	rem
inp180	null
	rem		set new last buffer pointer
	stq	t.ilst,1
	cqa		get virtual address
	tsy	a.b021-*,*	setbpt
	cax3		also save it for later
	iaa	bf.dta	to set new character pointer
	ora	l.b001-*	0,b.0
	sta	t.icch,1
	rem
inp190	null
	stx3	inpvir-*	hang on to virtual buffer address
	ldx3	t.icch,1
	lda	inchar-*	now put data character in input buffer
	sta	0,3,b.0
	rem		now increment tally
	ldx3	inpvir-*
	ila	1	add one to tally in last buffer
	asa	bf.tly,3
	rem		increment char pointer
	ldx3	t.icch,1	increment character pointer
	iacx3	0,b.1
	stx3	t.icch,1
	rem
	lda	t.flg2,1	check for shifter
	cana	l.b016-*	=tsfstr
	tze	inp200-*	not an ibm type
	ila	63	yes it is, mask off possible shift
	ansa	inchar-*	when testing for break
inp200	null
	lda	t.flg2,1	see if we're in a frame
	cana	l.b010-*	=tffip
	tze	inp210-*	nope
	lda	t.frmc,1	yes, get framing chars
	ana	l.b011-*	(=o000777) mask down to frame-end only
	cmpa	inorig-*	is this it?
	tze	inp250-*	yes, break
	tra	inp300-*	no, don't break
	rem
inp210	null
	lda	t.flg2,1	check for input_suspend char
	cana	l.b022-*	(=tfifc) if appropriate
	tze	inp220-*	it isn't
	lda	t.ifch,1	get input flow control chars
	lrl	9	suspend in a low, resume in q high
	cmpa	inorig-*	received suspend char?
	tnz	inp220-*	no
	lda	t.icpl,1	yes, should we resume right away?
	icmpa	bufmax/2
	tmi	inp215-*	yes, chain is short enough
	lda	l.b026-*	=tfisus
	orsa	t.flg,1	else set suspended flag in tib
	tra	inp220-*
inp215	qrl	9	get resume char in q low
	tsy	a.b023-*,*	eforce
	rem
inp220	lda	t.flg3,1	get flags
	cana	l.b015-*	=tfbral
	tnz	inp250-*	in breakall mode, break on everything
	rem
	rem		break list pointed to by t.brkp has maximum of
	rem		8 characters, of which first is
	rem		either a special code or a count.
	lda	t.brkp,1	get pointer to beginning of break list
	ora	l.b001-*	0,b.0
	cax3
	rem
	lda	0,3,b.0	get first char of break list
	tze	inp300-*	no break list, no break char.
	als	9	extend high-order bit of char
	ars	9	for immediate compare
	rem
	icmpa	brkall	break on every character?
	tze	inp250-*	yes, that includes this one
	rem
	icmpa	brkctl	break on all control chars?
	tnz	inp230-*
	lda	inchar-*	yes, find out if this is one
	icmpa	blank
	tmi	inp250-*	it is, break
	tra	inp300-*	else don't
	rem
inp230	null		first char is count of list
	caq		get it in q
	rem
inp240	null		check for match
	iacx3	0,b.1	bump to next char in break list
	lda	0,3,b.0	pick it up
	cmpa	inchar-*
	tze	inp250-*	this one, break now
	rem		get next char in break list
	iaq	-1	if there are any more
	tze	inp300-*
	tra	inp240-*	
	rem
	rem
inp250	null		we have a break char, send appropriate
	rem		status to interpreter
	lda	l.b010-*	=tffip (frame in progress)
	iera	-1	always turned off by break
	ansa	t.flg2,1
	rem
	lda	t.line,1	hsla line?
	cana	l.b018-*	=hslafl
	tze	inp260-*	no, skip this
	ldx2	t.sfcm,1	else have to update input pointer
	ldx3	inchrp-*	address of char just processed
	iacx3	0,b.1	point to next char
	stx3	sf.nic,2	update pointer in sfcm
	szn	inecho-*	have we put anything in echo buffer?
	tze	inp260-*	no, proceed
	stz	inecho-*	yes, reset flag
	tsy	a.b007-*,*	(hcheck) and tell hsla_man now
	rem
inp260	null
	lda	t.flg3,1	check for breakall super-optimization
	cana	l.b015-*	=tfbral
	tze	inp265-*	nope
	szn	inenef-*	did FNP echnego this char?
	tze	3	no, proceed
	szn	t.scll,1	is there room for more echnego?
	tnz	inp298-*	great, don't ship:  turn on tfwrit
	rem		if there's input on the t.dcp chain that can
	rem		be safely appended to (as determined above),
	rem		simply put the current character into it; it
	rem		will be included in an already queued
	rem		accept_input
	rem
	szn	inq-*	is there input queued?
	tze	inp261-*	no, never mind
	lda	t.dlst,1	get the last buffer in the queued input
	tsy	a.b021-*,*	(setbpt) get virtual address
	sta	inpvir-*	save it
	cax3
	lda	bf.tly,3	get the current tally
	ana	l.b019-*	buftmk
	lrl	1	get number of words (saving possible odd char)
	aos	bf.tly,3	increment buffer tally
	iaa	bf.dta	account for buffer header
	ada	inpvir-*	add address of origin, we now have word address
	ora	l.b001-*	0,b.0
	cax3		x3 now points to correct word
	iaq	0	was there an odd number of characters?
	tpl	2	no
	iacx3	0,b.1	yes, advance character pointer
	lda	a.g008-*,*	(inorig) get the current character
	sta	0,3,b.0	store it in buffer
	tra	inp300-*	done
inp261	null		if that didn't work, at least we can
	rem		try to avoid running the control tables
	rem
	rem		breakable chars come one at a time
	rem		or the very last in an echoed chain.
	rem		at any rate, we are gonna ship.
	rem
	lda	t.ilst,1	first char in some buffer, not echoed?
	cmpa	t.icp,1	only buffer in chain?
	tnz	inp262-*	no, leave break bit on or off as was set before.
	tsy	a.b021-*,*	(setbpt) get virtual address
	cax3
	lda	bf.tly,3	check out the tally
	ana	l.b019-*
	icmpa	1	1st char?
	tnz	inp262-*	no, dont mark as break chars
	lda	l.b013-*	otherwise, turn on break flag
	orsa	bf.flg,3
inp262	null
	tsy	a.b009-*,*	(ecgifl), ech(nego) iflush
	tra	inp300-*
inp265	null
	lda	t.ilst,1	get buffer pointer
	tsy	a.b021-*,*	make it virtual
	cax3		so as to set
	lda	l.b013-*	(=bffbrk) break flag
	orsa	bf.flg,3
      	lda	t.stat,1	get tib status
	iana	s.dss	mask down to common bits
	ora	l.b014-*	(=s.brch) set break char received
	tsy	a.g009-*,*	=addr(istat)
	lda	t.flg,1	check for echoplex
	cana	l.b004-*	=tfecpx
	tze	inp300-*	no, we're done
inp298	null		here for thoughts that want chance to echo
	lda	l.b017-*	=^tfwrit
	ansa	t.flg,1	turn it off to make sure we get a chance to echo
	rem
inp300	null		through with that character
	szn	t.entp,1	is there a echnego table?
	tze	inp310-*	no
	szn	a.g010-*,*	(inenef) did echngo echo this char?
	tnz	inp310-*	yes, it was echoed. echngo zeroed sncc
	sti	inpind-*	save indicators - it was not echoed,
	ldi	l.b020-*	inhibit overflow- so count against sync ctr
	aos	t.sncc,1	aos the sync ctr
	ldi	inpind-*
inp310	null
	lda	a.g011-*,*	(inpte) pte to restore?
	tze	inp320-*	no
	ldx2	a.g012-*,*	(.crbpe) yes
	sta	0,2	do it
inp320	null
	ldx3	a.g005-*,*	(inchrp) recover char pointer
	iacx3	0,b.1	go to next
	aos	a.g006-*,*	(inrem) are there any more?
	tmi	a.g013-*,*	(inp010) yes, go do next one
	rem		done, set return flags
	ila	0
	szn	a.g007-*,*	(inecho) did we put anything in echo buffer?
	tze	2	no
	iora	reteco
	szn	a.g001-*,*	(insusp) found an output_suspend char?
	tze	2	no
	iora	retsus
	szn	a.g002-*,*	(inres) how about output_resume?
	tze	2	no
	iora	retres
	rem
inpbak	return	inproc
	ttls	chkofc -- looks for output flow control chars
	rem	this subroutine looks for output flow control characters
	rem	and sets appropriate flags. If it completely processes
	rem	the character (i.e., it is not to be echoed or stored)
	rem	it returns to the next location; otherwise it returns
	rem	one location further on
	rem
	rem
chkofc	subr
	lda	t.flg2,1	oflow mode?
	cana	l.g001-*	=tfofc
	tze	chk030-*	no, forget it
	lda	t.ofch,1	we'll check for output flow control char
	lrl	9	get suspend char. first
	cmpa	a.g003-*,*	(inchar) is it?
	tnz	chk010-*	 no, check for resume
	lda	t.flg2,1	yes, see if it's block acknowledgement
	cana	l.g002-*	=tfblak
	tnz	chk010-*	yes, so suspend char isn't interesting
	aos	a.g001-*,*	(insusp) indicate receipt of suspend character
	stz	a.g002-*,*	(inres) overrides any preceding resume char
	tra	chkret-*	don't echo or store char
chk010	qrl	9	get resume char
	cmpq	a.g003-*,*	(inchar)  is our current char one?
	tnz	chk030-*
	lda	t.flg2,1	yes, block acknowledgement?
	cana	l.g002-*	=tfblak
	tnz	chk020-*	yes, we'll have to adjust message count
	stz	a.g001-*,*	(insusp) overrides any previous suspend character
	aos	a.g002-*,*	(inres) yes, mark that it's to be resumed
	tra	chkret-*	done with char (don't echo or store)
	rem
chk020	null		ack
	lda	t.omct,1	get outstanding message count
	tze	chkret-*	don't let it go negative
	iaa	-1	else decrement it
	sta	t.omct,1
	icmpa	2	can we resume now?
	tpl	chkret-*	no
	tsy	a.g004-*,*	(itest) yes, tell interpreter
	tra	chkret-*	done with char (don't store or echo)
	rem
chk030	aos	chkofc-*	to return + 1
chkret	return	chkofc
	rem
	rem
inpind	bss	1	save indicator reg
	rem
a.g001	ind	insusp
a.g002	ind	inres
a.g003	ind	inchar
a.g004	ind	itest
a.g005	ind	inchrp
a.g006	ind	inrem
a.g007	ind	inecho
a.g008	ind	inorig
a.g009	ind	istat
a.g010	ind	inenef
a.g011	ind	inpte
a.g012	ind	.crbpe
a.g013	ind	inp010
	rem
l.g001	vfd	18/tfofc
l.g002	vfd	18/tfblak
	ttls	inptim -- subroutine to run 1 second after inproc
	rem
	rem	this subroutine is scheduled by inproc to run one second
	rem	later if a channel is in input flow control/timeout
	rem	mode. Its function is to see if more than half a second
	rem	has elapsed since the last time inproc was called on behalf
	rem 	of the channel, and if so, to send an input_resume
	rem	character to it on the assumption that it decided to
	rem	suspend input.
	rem
	rem	x1 contains absolute tib address at entry
	rem
	rem
inptim	null		transferred to by secondary dispatcher
	cx1a		copy absolute tib address into a
	sta	ipabs-*	save it for possible later call to dspqur
	tsy	a.e006-*,*	(setptw) virtualize it
	cax1		and back into x1
	ldaq	t.itim,1	get the time inproc last ran
	tze	a.e001-*,*	(secdsp) never, forget it
	lda	a.e002-*,*	(itmb) see how much later it is now
	sta	iptemp+1-*
	stz	iptemp-*
	ldaq	a.e003-*,*	(simclk) next timer runout time
	sbaq	iptemp-*	result is current time
	sbaq	t.itim,1	how long has it been?
	tmi	a.e001-*,*	hasn't happened yet (unlikely)
	iaa	0	more than 2**18 msec??
	tnz	itm010-*	well, that's sure more than half a second
	cmpq	l.e001-*	501(10) -- else, was it in fact?
	tpl	itm010-*	yes
	rem		else we should check again in a second
	ldaq	a.e007-*,*	time, priority, address of this routine
	ldx1	ipabs-*	recover absolute tib address
	tsy	a.e008-*,*	(dspqur) make sure we get called again
	tra	a.e001-*,*	(secdsp) done
	rem
itm010	ldq	t.ifch,1	it has been, so send resume char
	qls	9	get rid of suspend char
	qrl	9
	tsy	a.e004-*,*	eforce
	lda	l.e003-*	=^tfsked
	ansa	t.flg3,1	turn off scheduled flag
	lda	t.line,1	hsla line?
	cana	l.e002-*	=hslafl
	tze	a.e001-*,*	(secdsp) no, done
	tsy	a.e005-*,*	(hcheck) yes, make sure echoing happens
	tra	a.e001-*,*	(secdsp) finished now
	rem
	rem
a.e001	ind	secdsp
a.e002	ind	itmb
a.e003	ind	simclk
a.e004	ind	eforce
a.e005	ind	hcheck
a.e006	ind	setptw
a.e007	ind	a.b010	contains word pair for dspqur
a.e008	ind	dspqur
	rem
	rem
l.e001	dec	501
l.e002	vfd	18/hslafl
l.e003	vfd	o18//tfsked
	rem
ipabs	bss	1	absolute tib address (temp stored here)
	even
iptemp	bss	2
	ttls	move subroutine does carriage movement
	rem
	rem	this subroutine looks in carriage movement
	rem	table supplied in device table for character
	rem	supplied in q reg.
	rem
	rem	returns:	0 -- linefeed char
	rem		1 -- carriage return
	rem		2 -- tab (a contains  no. of blanks)
	rem		3 -- backspace
	rem		4 -- no match
	rem
	rem	tib address assumed in x1 as always
	rem
move	subr	mov,(q,x3)
	rem
	rem		first find out if we should bother
	stz	mshift-*	initially not a shift char
	ldx3	a.m001-*	base of control tables
	ldx3	ct.dev,3	array of device table ptrs
	adcx3	t.type,1	indexed by terminal type
	lda	-1,3	-1 to convert index to offset
	ora	l.m001-*	(0, b.0) convert to char. addressing
	cax3		x3 now points to device table entry
	rem		we want to check against carriage mvmt
	rem		characters in device table entry
	rem
	lda	l.m004-*	=tfsftr
	cana	t.flg2,1
	tze	mov005-*	not a shifter, only look for carriage movement
	ila	6	else we have to look for shifts too
	tra	mov010-*
mov005	null
	ila	4	limit
mov010	sta	mlimit-*
	ila	0
mov012	cmpq	dt.cmt,3,b.0
	tze	mov030-*	hit
	iaa	1	and increment counter
	cmpa	mlimit-*	end of table?
	tze	mov020-*	no hits
	iacx3	0,b.1	not last, bump pointer
	tra	mov012-*	check next char. in table
*
mov020	null		not a special carriage mvmt. char.
	lda	l.m004-*	=tfsftr
	cana	t.flg2,1
	tnz	mov025-*	if we don't have an ibm terminal,
	cqa		find out if it's a control char.
	icmpa	rubout
	tze	mov027-*	if so, don't bump column pointer
	icmpa	space
	tmi	mov027-*
mov025	lda	t.pos,1	make sure we're not over limit
	icmpa	255
	tpl	2	we are, don't increment
	aos	t.pos,1	else, push to next column
mov027	ila	4	indicate no hit return
	tra	movbak-*
*
mov030	null
	rem		hit on carriage movement table
	icmpa	4	was it a shift character?
	tmi	mov035-*	no, check for something else
	iaa	-3	yes, reduce it to 1 or 2
	sta	mshift-*	save it for later
	ila	4	return as though no hit
	tra	movbak-*	all done (carriage didn't move)
	rem
mov035	null
	icmpa	2	cr or lf?
	tpl	mov040-*
	stz	t.pos,1	yes, zero column indicator
	tra	movbak-*
mov040	null
	icmpa	3	backspace?
	tnz	mov050-*
	szn	t.pos,1	don't decrement column indicator if
	tze	movbak-*	it's already zero
	ila	-1
	asa	t.pos,1
	ila	3	bump return point for backspace
	tra	movbak-*
*
mov050	null		must be tab
	ila	0
	ldq	t.pos,1	get mod(t.pos, 10)
	cmpq	l.m005-*	(=255) make sure we're not over limit
	tpl	mov070-*	we are, don't increment t.pos
	cmpq	l.m002-*	=10
	tmi	mov060-*	if it's < 10, don't bother dividing
	dvd	(l.m002-*)	else divide by 10
	rem		remainder is in q
mov060	null
	stq	mtemp-*	save mod(t.pos,10)
	ila	10	t.pos<-t.pos+10-mod(t.pos,10)
	sba	mtemp-*
	asa	t.pos,1
mov070	aos	move-*	bump return pointer for tab return
	aos	move-*	by hand because have to keep space count in a
	tra	2
	rem
movbak	asa	move-*	bump return pointer appropriately
	return	move
	rem
	rem
l.m001	zero	0,b.0
l.m002	dec	10
l.m003	vfd	18/tfcrec+tflfec+tftbec+tfecpx
l.m004	vfd	18/tfsftr
l.m005	dec	255
a.m001	ind	ctrl	address of control tables
mtemp	bss	1	temp for saving mod(t.pos,10)
mshift	bss	1	char was case shift (1 for upper, 2 for lower)
mlimit	bss	1	number of chars to scan in cmt
	ttls	echo buffer subroutines
	rem	echo buffer format
	rem
eb.inp	equ	0	ptr to next place for input character
eb.out	equ	1	ptr to next output character
eb.tly	equ	2	current character count (upper half)
eb.dta	equ	2	first data char (lower half)
eb.end	equ	bufsiz	end of echo buffer
ebsize	equ	bufsiz*2-5	maximum number of echo chars
	rem
	rem
	rem	puteco subroutine puts input character in
	rem	echo buffer. character is supplied in q
	rem	tib address on x1 as usual
	rem	if character is ht, space count is in x2
	rem
hecho	null
lecho	null		this is the external interface
puteco	subr	put,(x2,x3,a,q)
	rem
	lda	t.flg2,1	frame in progress?
	cana	l.c006-*	=tffip
	tnz	putbak-*	yes, no echoing
	rem
	tsy	putone-*
	tra	putbak-*	if no more room, skip other stuff
	rem
	lda	t.line,1	hsla line?
	cana	l.c008-*	=hslafl
	tze	put070-*	no, lsla_man will handle delays later
	ldx2	t.dtp,1	yes, put delays in echo buffer
	tze	put039-*	no delay table, check tabecho
	lda	putsq-*	get echoed char
	icmpa	lf	linefeed?
	tnz	put020-*	no, try something else
	lda	dl.lf,2	yes, get linefeed delays
	tze	putbak-*	none, skip it
	tra	put030-*	go do it
	rem
put020	icmpa	cr	carriage return?
	tnz	put040-*	nope
	lda	dl.cr,2	get cr delay factor
	mpy	(a.c002-*,*)	oldpos, original column position
	tze	putbak-*	no delays, skip it
	qrs	9	divide by 512
	iaq	3	for good measure
	cqa		result into a
put030	ilq	null	delay char
	tra	put050-*	go put nulls in echo buffer
	rem
put039	lda	putsq-*	get character into a again
put040	icmpa	tab	not cr or lf, is it tab?
	tnz	putbak-*	no, done
	lda	t.flg,1	tab echo?
	cana	l.c005-*	=tftbec
	tze	putbak-*	no, skip it
	lda	putsx2-*	get space count
	ilq	blank	get space char
	rem
put050	null		here to store blanks or nulls in buffer
	iera	-1	negate count
	iaa	1
	sta	puttmp-*
put060	tsy	putin-*	put one in
	tra	putbak-*	buffer full, no more
	aos	puttmp-*	count one
	tmi	put060-*	more, go do them
	tra	putbak-*	no more, finished
	rem
put070	null		lsla line, may need to restore t.pos
	lda	t.flg,1	echoplex?
	cana	l.c004-*	=tfecpx
	tnz	put080-*	yes
	cana	l.c005-*	(=tftbec) no, try tab echo
	tze	putbak-*	no, done
	lda	putsq-*	get original char again
	icmpa	ht	is it a tab?
	tnz	putbak-*	no, not interesting
put080	lda	a.c002-*,*	oldpos
	sta	t.pos,1
	rem
putbak	return	puteco
	rem
	rem
eforce	subr	efo,(a,q,x3)
	rem
	rem	short version of puteco that puts the character
	rem	in the echo buffer even if in a blk_xfer frame,
	rem	and doesn't bother about delays or tabs. called
	rem	for such things as input suspend/resume characters.
	rem
	rem	q contains character to be echoed.
	rem
	tsy	putone-*	this actually does all the work
	nop		doesn't matter whether or not it succeeds
	return	eforce
	ttls	putin -- insert a char in the echo buffer
putin	subr	pin,(a,q,x2)
	rem
	rem	this subroutine does the actual insertion in the
	rem	echo buffer
	rem
	rem	q contains character to insert
	rem	x3 points to echo buffer
	rem	returns to callpoint if echo buffer full,
	rem	to one loc. beyond otherwise
	rem
	lda	eb.tly,3	see if it's full
	arl	9
	icmpa	ebsize	check against maximum
	tmi	pin010-*
	lda	l.c003-*	(=tfbel) echo buffer is full,
	orsa	t.flg,1	set flag to send bell
	cmeter	mincd,m.ebof,l.c011-*  meter this
	tra	pinbak-*	and return
pin010	null
	aos	putin-*	bump return pointer
	lda	t.line,1	if hsla line in tabecho, don't store tab
	cana	l.c008-*	=hslafl
	tze	pin015-*	not hsla, as you were
	cqa		get character
	icmpa	tab
	tnz	pin015-*	not tab, go ahead
	lda	t.flg,1	check for tabecho
	cana	l.c005-*	tftbec
	tnz	pinbak-*	don't store it, we'll put in spaces later
pin015	null
	ldx2	eb.inp,3	get input pointer
	rem		we're ready to store char
	stq	0,2,b.0	do it
	iacx2	0,b.1	increment input pointer
	cx2a		find out if we went off end
	cana	l.c007-*	=o077777
	tze	pin020-*	we went off end of memory, in fact
	cana	l.c002-*	=o000037
	tnz	pin030-*
pin020	cx3a		0 mod 32 (wraparound)
	ada	l.c001-*	so point to beginning again
*
pin030	null
	sta	eb.inp,3
	lda	l.c010-*	=o1000
	asa	eb.tly,3	increment tally
pinbak	return	putin
	ttls	putone -- set up echo buffer
putone	subr	puo,(q)
	rem
	rem	this subroutine allocates an echo buffer (if
	rem	necessary) and puts a character in it, updating
	rem	the "inecho" flag. It is called by puteco and eforce.
	rem
	rem	q contains character to echo
	rem	on exit, x3 points to the echo buffer if any
	rem	returns to callpoint if echo buffer full or no
	rem	buffer could be allocated, otherwise to one location
	rem	further on
	rem
	lda	t.echo,1	is there an echo buffer?
	tze	puo005-*	no, we'll have to get one
	tsy	a.c004-*,*	(setbpt) yes, get virtual address
	cax3
	tra	puo010-*	proceed
	rem		set up echo buffer
puo005	ilq	bufsiz
	tsy	a.c001-*,*	(getubf) get a buffer
	tra	puo020-*	couldn't get one, never mind
*
	sta	t.echo,1	now we have it, save (absolute) address
	ldq	putsq-*	copy char back to q
	cx3a		get (virtual) pointer to
	ada	l.c001-*	first data char. save it in
	sta	eb.inp,3	input and
	sta	eb.out,3	output pointers
	stz	eb.tly,3	initialize tally
puo010	tsy	putin-*	put the character in
	tra	puobak-*	if no more room, skip other stuff
	rem
	aos	putone-*
	ila	1	mark the echoed flag
	orsa	a.c003-*,*	inecho
puobak	return	putone
	rem
puo020	null		allocation failure, meter it
	cmeter	mincs,m.inaf,l.c011-*
	tra	puobak-*
	rem
	rem
a.c001	ind	getubf	subr to get an unreserved buffer
a.c002	ind	oldpos
a.c003	ind	inecho
a.c004	ind	setbpt
	rem
l.c001	zero	eb.dta,b.1	offset of first char. position
l.c002	oct	37	mask for mod 32
l.c003	vfd	18/tfbel
l.c004	vfd	18/tfecpx
l.c005	vfd	18/tftbec
l.c006	vfd	18/tffip
l.c007	oct	077777
l.c008	vfd	18/hslafl
l.c009	vfd	18/tflfec
l.c010	oct	1000
l.c011	dec	1
	rem
	rem
puttmp	bss	1
	ttls	negotiated echo handler
	rem
	rem	called by inproc when would normally
	rem	do echoplex echoing
	rem	x1 is tib, return a nonzero if echoed, 0 if did not.
	rem	inchar in a
	rem
echngo	subr	eng
	rem
	sta	engich-*
	lda	t.flg3,1	breakall?
	cana	l.s002-*	=tfbral no echo if not
	tze	eng180-*
	szn	t.scll,1	is there room left to echo?
	tze	eng180-*	no, dont attempt to echo.
	lda	engich-*	Take a look at char
	rem
	rem	check char's bit in table.
	rem
	iana	15	get low bits
	ada	l.s001-*	build instruction
	sta	eng020-*
	lda	engich-*	get char
	arl	4	get high bits
	sta	engtmp-*
	ldx2	t.entp,1	damn well better be table
	tnz	2	or r0 screwed up
	die	99
	adcx2	engtmp-*	build word address
	lda	dl.hsz,2	get table word
eng020	bss	1	test high bit
	tmi	eng180-*	this is a true break, no echo.
	rem
	rem	now we have to echo this thing.
	rem
	ldq	engich-*
	ila	0
	cax2
	tsy	a.s002-*,*	until we have something cleverer
	rem
	stz	t.sncc,1	we echoed this char, so zero the
	rem		protocol sync count of chars not
	rem		echoed since echoed char.
	rem
	rem	char has been echoed, update line length left.
	ila	-1
	asa	t.scll,1	decrement line space left
	rem		and return nonzero a.
	tra	engret-*
	rem
eng180	stz	t.scll,1	turn off all further echnego
	ila	0	say that we did not echo
	rem		inproc will aos t.sncc apropriately
engret	return	echngo
	rem
l.s001	als	0	instruction template
l.s002	vfd	18/tfbral
a.s001	ind	ecgifl
a.s002	ind	puteco
engich	bss	1
engtmp	bss	1
	rem
	ttls	outprc subroutine -- for output subop
	rem	subroutine called by both lsla_man and hsla_man
	rem	to process output subop of dcw list
	rem
	rem	x1 - virtual tib address
	rem
opend	bool	77
pradd	equ	1
kyadd	equ	2
outmsg	equ	3
repeat	equ	4
maxctl	equ	4	maximum number of words in addressing string
	rem
nbftmk	bool	/buftmk
	rem
	rem
outprc	subr	out,(a,q,x2,x3)
	rem
	rem
	lda	t.dcwa,1
	ora	l.o001-*	0,b.0
	cax3		point to first character of "output"
	rem
out010	null
	iacx3	0,b.1	next char.
	lda	0,3,b.0	pick it up
	cmpa	l.o002-*	=o000400
	tpl	out020-*	if less than 400(8),
	tsy	a.o001-*,*	literal char is to be inserted in buffer
	rem		(insert)
	tra	out010-*	and get next
	rem
out020	null
	iana	255	we know high-order bit is on, so turn
	rem		it off for easier comparison
	tze	out090-*	die if result is zero
	rem
	icmpa	opend
	tze	out200-*	end of subop
	rem
	icmpa	kyadd+1	printer or keyboard addressing?
	tpl	out050-*
	rem		yes, get device table pointer
	rem		but first check and make sure tfctrl is on
	caq
	lda	l.o003-*	=tfctrl
	cana	t.flg,1
	tze	out010-*	if it isn't, skip this item
	rem
	ldx2	a.o002-*	address of control tables
	ldx2	ct.dev,2
	adcx2	t.type,1
	ldx2	-1,2	now points to correct device tab entry
	cqa		restore control char
	icmpa	kyadd
	tze	out030-*
	lda	dt.prt,2	get pointer to printer addr sequence
	szn	t.ocur,1	if there's already an output chain,
	tze	out028-*
	sta	otemp-*	put printer addr ahead of it
	ldq	t.ocp,1	which means putting it at head of pending output
	lda	t.olst,1	get end of t.ocur chain
	tsy	a.o004-*,*	(setbpt) virtualize it
	cax2
	stq	bf.nxt,2	hook t.ocp chain on at end
	lda	t.ocur,1	this becomes new t.ocp chain
	sta	t.ocp,1
	rem
	stz	t.ocur,1	clear current output chain
	stz	t.olst,1
	stz	t.ocnt,1
	rem
	lda	otemp-*	restore a register
out028	null
	tra	2	skip over fetch of kybd string
out030	null
	lda	dt.key,2	get keyboard addr sequence
	ora	l.o001-*	0,b.0
	cax2		point to beginning of string
	ldq	0,2,b.0	get character count in q
	rem
out040	null
	iacx2	0,b.1	get next char.
	lda	0,2,b.0
	tsy	a.o001-*,*	(insert) put it in output buffer
	iaq	-1	more?
	tnz	out040-*	yes, get next addressing char
	tra	out010-*	else get next output char
	rem
out050	null
	icmpa	outmsg	thread output message into chain?
	tnz	out080-*
	rem		yes
	stz	ohldot-*	turn off local flag
	lda	t.ocp,1	get pointer to head of output chain
	tze	out075-*	if there isn't one, nothing to do
	caq		save absolute address in q
	tsy	a.o004-*,*	(setbpt)
	cax2		get virtual in x2
	lda	bf.flg,2	get buffer flags
	cana	l.o010-*	check hold output buffer flag
	tze	out054-*	not on - usual outmsg
	stz	t.ocur,1
	rem
	aos	ohldot-*	turn on local flag
out052	stq	t.olst,1
	cana	l.o011-*	check last buffer in message flag
	tnz	out054-*	yes - end of partial chain
	lda	bf.nxt,2	advance to next buffer
	tze	out054-*	end of chain
	caq		hang on to absolute address
	tsy	a.o004-*,*	(setbpt) virtualize address
	cax2
	lda	bf.flg,2	get buffer flags
	tra	out052-*	loop
out054	ldq	t.ocp,1	get pointer to output chain
	szn	t.ocur,1	are we currently working on one?
	tnz	out060-*
	stq	t.ocur,1	no, make head of chain current buffer
	cqa
	tsy	a.o004-*,*	setbpt
	iaa	bf.dta	and point t.occh to first char slot
	ora	l.o001-*	=0,b.0
	sta	t.occh,1
	lda	t.ocur,1
	szn	ohldot-*	check local flag
	tze	out070-*
	tra	out075-*	skip all this other stuff
	rem
out060	null		there is a chain, make sure
	lda	t.olst,1	t.olst really points to last buffer
	tsy	a.o004-*,*	(setbpt) get virtual address
	cax2
	szn	bf.nxt,2
	tze	2
	die	11
	rem
	stq	bf.nxt,2	now hook new chain to last buffer
out070	null
	aos	t.ocnt,1	increment output buffer count
	cqa		convert to virtual for local storage
	tsy	a.o004-*,*	(setbpt)
	cax2
	stx2	obufad-*	save this address for later
	lda	t.flg2,1	block-acknowledgement mode?
	ana	l.o009-*	=tfblak+tfofc
	cmpa	l.o009-*	see if they're both on
	tnz	out071-*	no, proceed
	lda	bf.tly,2	yes, we must check to see if buffer ends in etb
	ana	l.o012-*	buftmk
	iaa	-1	back up one to get right word
	lrs	1	separate word and char parts of address
	ada	l.o013-*	(bf.dta,b.0) a now points to word of last char
	qls	0	one more char?
	tpl	2	no
	ora	l.o014-*	(0,b.1), yes, account for it
	ada	obufad-*	add address of base of buffer
	cax2		x2 now points to last char
	lda	t.ofch,1	get flow control chars
	arl	9	isolate eond-of-block char
	cmpa	0,2,b.0	is this it?
	tnz	out071-*	no, proceed normally
	aos	t.omct,1	yes, count the message
	ldx2	obufad-*	and break chain here
	cx2a		convert it ot absolute for permanent storage
	tsy	a.o005-*,*	cvabs
	sta	t.olst,1
	lda	bf.nxt,2	keep the remains in t.ocp
	sta	t.ocp,1
	stz	bf.nxt,2	detach the chain
	tze	out073-*	if there is no more, check for sendout
	tra	out075-*	else we're done -- don't turn on tfwrit
out071	ldx2	obufad-*	restore current buffer address
	ldq	bf.nxt,2	search chain for new end
	tnz	out070-*
	rem
	lda	l.o008-*	(=tfwrit) turn on tfwrit now
	orsa	t.flg,1	not before.
	rem
	cx2a
	tsy	a.o005-*,*	(cvabs)
	sta	t.olst,1
	stz	t.ocp,1	zero output chain pointer to allow
	rem		for new one
out073	ila	bufthr	get output buffer threshold
	cmpa	t.ocnt,1	if we're not over it,
	tmi	out075-*
	ilq	sndout	ask for more output
	tsy	a.o003-*,*	denq
	rem
out075	null
	iacx3	0,b.1	get next char
	lda	0,3,b.0	had better be end of subop
	cmpa	l.o005-*	=477
	tze	out200-*
	die	7
	rem
out080	null		only remaining possibility
	icmpa	repeat	is repeat
	tze	out100-*
out090	null
	die	9
	rem
out100	null
	lda	0,3,b.1	get character to be repeated
	iacx3	1,b.0
	ldq	0,3,b.0	get repeat count
	tnz	2	where 0 means 512
	ldq	l.o006-*	=512
	rem
out110	null
	tsy	a.o001-*,*	insert
	iaq	-1	repeat count exhausted?
	tnz	out110-*	no, do it again
	tra	out010-*	yes, get next item
	rem
	rem
out200	null		end of output subop
	cx3a
	ana	l.o007-*	=o077777 convert to word addressing
	iaa	1	point to next word
	caq		save new address
	sba	t.dcwa,1	get number of words processed
	sta	otemp-*
	lda	t.dcwl,1	decrement dcw length accordingly
	sba	otemp-*
	sta	t.dcwl,1
	stq	t.dcwa,1	save new dcw list pointer
	return	outprc
*
	rem
	rem
l.o001	zero	0,b.0	for character addressing
l.o002	oct	400
l.o003	vfd	18/tfctrl
l.o004	vfd	18/maxctl
l.o005	oct	477
l.o006	dec	512
l.o007	oct	77777
l.o008	vfd	18/tfwrit
l.o009	vfd	18/tfblak+tfofc
l.o010	vfd	18/bffhld	hold output buffer flag
l.o011	vfd	18/bfflst	last buffer in message flag
l.o012	vfd	18/buftmk
l.o013	zero	bf.dta,b.0
l.o014	zero	0,b.1
	rem
otemp	bss	1	temporary storage
obufad	bss	1	temporary for buffer address
ohldot	bss	1	flag - on if hold output buffers set
	rem
a.o001	ind	insert
a.o002	ind	ctrl
a.o003	ind	denq
a.o004	ind	setbpt
a.o005	ind	cvabs
	rem
	ttls	insert -- subroutine to insert a char into output chain
	rem
	rem	insert called by outprc to insert char (passed in a)
	rem
insert	subr	ins,(a,q,x2,x3)
	rem
	rem
	szn	t.ocur,1	is there a buffer chain?
	tnz	ins010-*
	rem		no, must allocate a buffer
	ilq	bufsiz
	tsy	a.p001-*,*	getbfh
	die	10	die if we couldn't get one
	rem
	sta	t.ocur,1	this is now current buffer
	sta	t.olst,1	last one, too
	tsy	a.p002-*,*	setbpt
	cax3		now have virtual address in a and x3
	sta	insbuf-*	save it for later also
	iaa	bf.dta	point output char. pointer at
	ora	l.p001-*	(0,b.0)  first data char of new chain
	sta	t.occh,1
	tra	ins030-*
	rem
ins010	null		find out if last buffer is full
	lda	t.olst,1
	tsy	a.p002-*,*	(setbpt)
	cax3
	tsy	l.p002-*,*	=addr(fulbuf)
	rem		returns normally if full
	rem		or +1 with tally in a
	tra	ins020-*
	stx3	insbuf-*	save virtual address for later
	lrs	1	get tally in words but save
	sta	itemp1-*	low-order bit in q
	cx3a
	iaa	bf.dta
	ada	itemp1-*
	ora	l.p001-*	0,b.0
	cax3
	qls	0	was tally odd?
	tpl	ins040-*
	iacx3	0,b.1	yes, bump data pointer
	tra	ins040-*
	rem
ins020	null
	ilq	bufsiz	buffer was full, get another
	tsy	a.p001-*,*	getbfh
	die	10	die if we can't
	rem
	caq		hang on to absoute address
	lda	t.olst,1
	tsy	a.p002-*,*	(setbpt)
	cax2
	stq	bf.nxt,2	save in old last buffer's
	rem		forward pointer
	cqa		have to revirtualize
	tsy	a.p002-*,*	to make sure pte is right
	cax3		save virtual address
	sta	insbuf-*	store it for later also
	iaa	bf.dta	point to first data char
	ora	l.p001-*	0,b.0
	stq	t.olst,1	set new last buffer
ins030	null		mark this buffer as containing control chars
	caq		save the a reg.
	lda	l.p006-*	=bffctl
	orsa	bf.flg,3
	cqa
	rem
	cax3
	rem
	rem
ins040	null		x3 points to where char should go
	lda	inssa-*	get the char
	sta	0,3,b.0	store it in buffer
	ldx2	insbuf-*	get addressable pointer to buffer
	lda	bf.tly,2	get the old tally
	ana	l.p003-*	=buftmk
	iaa	1	bump it
	sta	itemp1-*	save it
	lda	l.p005-*	=^buftmk
	ansa	bf.tly,2	zero out tally field
	lda	itemp1-*	so as to replace it
	orsa	bf.tly,2
	return	insert
	rem
	rem
	rem
l.p001	zero	0,b.0	character addressing
l.p002	ind	fulbuf	routine to see if buffer full
l.p003	vfd	18/buftmk
l.p004	dec	4
l.p005	vfd	18/nbftmk	complement mask for tally
l.p006	vfd	18/bffctl
	rem
itemp1	bss	1	temporary storage
insbuf	bss	1	virtual address of t.olst
	rem
a.p001	ind	getbfh	buffer allocation routine
a.p002	ind	setbpt
	rem
	ttls	fulbuf subroutine finds out if buffer is full
	rem
	rem	this subroutine, passed a buffer address in
	rem	x3, looks to see if tally indicates that buffer
	rem	is full.
	rem
	rem	returns to callpoint+1 if buffer is full
	rem	else to callpoint+2 with tally in a
	rem
fulbuf	subr	ful
	rem
	lda	bf.siz,3
	arl	15	isolate size code
	iaa	1
	mpf	l.f002-*	=bufsiz
	rem		mpf comes out double so it gives number of chars
	sbq	l.f001-*	=4 (4 chars worth of header)
	stq	ftemp-*
	lda	bf.tly,3	get tally
	ana	l.f003-*	=buftmk
	cmpa	ftemp-*	tally>=size?
	tpl	2	yes, regular return
	aos	fulbuf-*	else return+1
	return	fulbuf
	rem
	rem
l.f001	dec	4	number words of buffer header
l.f002	vfd	18/bufsiz
l.f003	vfd	18/buftmk	mask for buffer tally
ftemp	bss	1
	ttls	metering subroutines
	rem
************************************************************************
*
*	meterc  -- adds one to a "counting" meter
*
*	index of meter to be incremented is passed in q reg.
*
************************************************************************
	rem
meterc	subr	mtc,(inh,q,x3)
	rem
	ldi	l.d001-*	(o024000) inhibit overflow
	cmpq	cmax-*	is value legal?
	tnc	mtc010-*
	aos	meterr-*	if not, meter invalid call
	tra	mtcbak-*	and return
	rem
mtc010	null
	ldx3	mtcsq-*	ok, get meter name into x3
	aos	cmetrs-*,*	increment it
mtcbak	return	meterc
	rem
	rem
************************************************************************
*
*	metert  -- increments a "time" meter
*
*	index of meter is passed in q reg.
*	increment (in microseconds) is passed in a reg.
*
************************************************************************
	rem
metert	subr	mtt,(inh,a,q,x3)
	rem
	ldi	l.d001-*	(o024000) inhibit overflow
	cmpq	tmax-*	is meter index too big?
	tnc	mtt010-*	if so, meter that
	aos	meterr-*
	tra	mttbak-*	and return
	rem
mtt010	qls	1	multiply by two for indexing
	stq	mttemp-*	(time meters are 2 words each)
	ldx3	mttemp-*	index into x3
	lrs	18	time into aq
	adaq	tmetrs-*,*	increment meter
	staq	tmetrs-*,*
mttbak	return
	rem
	rem
	rem
meterr	zero		invalid meter count
	rem
	rem
	rem
l.d001	oct	024000	"inhibit overflow" & "inhibit interrupts"
	rem
	rem
mttemp	bss	1
tmax	zero	tmaxd/2	maximum value for "time" meters
	rem
	rem
cmetrs	ind	*+1,3	"count" meters
	bss	50
cmax	zero	*-cmetrs-1	maximum value for a count meter
	rem
	rem
tmetrs	ind	tmorg,3	"timing" meters
	even
tmorg	null
	bss	100
tmaxd	equ	*-tmorg
	ttls	virtual/absolute address conversion routines
************************************************************************
*
*  setptw
*	converts an 18 bit absolute address to a 15 bit virtual
*	address and sets up the page table entry in the cpu page
*	table.  this routine is only required if more than 32K of
*	memory is configured for a dn6670.  a 'tra -1' is stored into
*	setptw+1 by init if otherwise.
*
*  input:
*	a reg - 18 bit absolute address
*
*  output:
*	a reg - 15 bit virtual address
*
*  modified registers: none
*
************************************************************************
	rem
	rem		a 'tra -1,*' is stored in setptw+1 by init if
	rem		only 32k is configured
setptw	subr	ptw,(inh,x2)	cannot allow interruptions
	ldx2	a.v001-*,*	.crpte
	tsy	setpte-*
	ora	l.v001-*	concatenate with window address
	return	setptw	all done
	rem
	rem
************************************************************************
*
*  setbpt
*      like setptw except used for buffer addresses. sets pte for buffer
*      window rather than general address window
*
************************************************************************
	rem
setbpt	subr	bpt,(inh,x2)
	cmpa	l.v003-*	=o100000
	tmi	bptbak-*	not in high memory, leave it alone
	ldx2	a.v002-*,*	.crbpe
	tsy	setpte-*	to do the work
	ora	l.v002-*	(bwndow) concatenate window base
bptbak	return	setbpt
	eject
************************************************************************
*
*  setpte
*      common subroutine used to set a page table entry
*
*  input:
*      a reg - 18 bit absolute address
*      x2    - address of page table entry
*
*  output:
*      a reg - low-order 8 bits of virtual address (offset in page)
*
************************************************************************
	rem
setpte	subr	spt
	sta	sargsv-*	save to provide offset
	iana	-256	get page number
	iora	pte.a	turn on active bit
	sta	0,2	put in relevant page table entry
	lda	sargsv-*	get page offset
	iana	255
	return	setpte
	rem
	rem
************************************************************************
*
*  cvabs
*      routine to convert virtual address to absolute.
*      assumes corresponding page table entry (buffer or tib/sfcm)
*      points to correct page.
*
*  input:
*      a reg - 15-bit virtual address
*
*  output:
*      a reg - corresponding 18-bit absolute address
*
************************************************************************
	rem
cvabs	subr	cva,(inh,q,x2)
	cmpa	l.v002-*	(bwndow) make sure address is in a window
	tmi	cvabak-*	it's below
	cmpa	l.v003-*	(=o100000) not a virtual address at all
	tpl	cvabak-*	it's above
	caq		hang on to address
	cmpa	l.v001-*	(window) which window is it in?
	tpl	cva010-*	tib/sfcm
	ldx2	a.v002-*,*	(.crbpe) buffer
	sba	l.v002-*	bwndow
	tra	cva020-*
cva010	ldx2	a.v001-*,*	.crpte
	sba	l.v001-*	window
cva020	sta	cvaoff-*	save offset within page
	lda	0,2	get real address of page base
	icana	pte.a	make sure it's active
	tnz	cva030-*	yes
	cqa		no, restore original address
	tra	cvabak-*	return
cva030	null
	iana	-256	reduce to address only
	ada	cvaoff-*	add offset
cvabak	return	cvabs	done
	rem
pte.r	bool	200	page table entry read only bit
pte.s	bool	100	page table entry security bit
pte.a	bool	40	page table entry active bit
window	bool	77400	base address of paged memory
bwndow	bool	77000	base address of buffer window
	rem
a.v001	ind	.crpte
a.v002	ind	.crbpe
	rem
l.v001	vfd	18/window
l.v002	vfd	18/bwndow
l.v003	oct	100000	smallest address outside 32k
	rem
sargsv	oct	0	storage for argument
cvaoff	bss	1
	ttls	move with paging on source or target address
************************************************************************
*
*  mvpgsc
*	this entry moves a block of data from an absolute location anywhere
*	in the fnp memory using the paging mechanism to a target in the lower
*	32k of fnp memory.
*
*  mvpgtg
*	this entry moves a block of data from the lower 32k of fnp memory
*	to a target anywhere in fnp memory using the paging mechanism.
*
*	either entry can be directed to cross page boundaries and to start
*	and end anywhere in a page.  each time a page boundary is crossed
*	the page table entry for the virtual window will be initialized.
*
*  input registers:
*	x2	source address
*	x3	target address
*	q	length of move
*
*  output registers:
*	none
*
*  modified registers: a, q, x2, x3
*
*  unmodified registers: x1
*
************************************************************************
	rem
	rem
*
*  entry points
	rem
mvpgsc	subr	mps,(inh)
	lda	mvpgsc-*	set up a common return point
	sta	mvpgtg-*
	lda	mpssi-*
	sta	mptsi-*
	stx2	mabsad-*	save as absolute address to virtualize
	lda	l.w001-*	'cax2' inst to set up x2 with virtual address
	sta	mvp080-*
	cx3a		for checking non-paged address
	tra	mvp000-*
	rem
mvpgtg	subr	mpt,(inh)
	stx3	mabsad-*	save as absolute address to virtualize
	lda	l.w002-*	'cax3' inst to set up x3 with virtual address
	sta	mvp080-*
	cx2a		for checking non-paged address
*
*  check input values
	rem
mvp000	null
	ldi	l.w004-*	(=o024000) inhibit overflow for logical adds
	sta	mtstad-*	save for compare
	stq	mrmlen-*	total length of move
	ldq	mvplmm-*	get last legal lower memory address
	cmpq	mtstad-*	is non-paged starting address below
	rem		 lower memory maximum?
	tpl	2	yes
	die	14	no. this shouldn't happen
	ada	mrmlen-*	calculate ending non-paged address
	iaa	-1
	sta	mtstad-*	save for compare
	cmpq	mtstad-*	is non-paged ending address below
	rem		 lower memory maximum?
	tpl	2	yes
	die	14	no. this shouldn't happen
	ldq	a.w001-*,*	(.crmem) get last legal absolute address
	cmpq	mabsad-*	is starting absolute address ok?
	tpl	2	yes
	die	14	no. this shouldn't happen
	lda	mabsad-*	calculate ending absolute address
	ada	mrmlen-*
	iaa	-1
	sta	mtstad-*	save for compare
	cmpq	mtstad-*	is this address ok?
	tpl	2	yes
	die	14	no. this shouldn't happen
	ldq	mrmlen-*	is length of move > 0?
	tnz	2	yes
	die	1	no. this shouldn't happen
*
*  set up length of first move
	rem
	lda	mabsad-*	calculate number of words in first page
	iana	-256
	ada	l.w003-*	(=256)
	sba	mabsad-*	now have it
	cmpa	mrmlen-*	will first pass move all?
	tnc	mvp020-*	no
	stz	mrmlen-*	yes
	tra	mvp040-*	go do it
	rem
mvp020	null
	caq		length of first move
	stq	mvllmp-*	save it for absolute address update
	iera	-1	calculate remaining length of total move after
	iaa	1	 first pass
	asa	mrmlen-*
	rem
mvp040	null
	lda	mabsad-*	setup to virtualize absolute address
*
*  virtualize source or target address
	rem
mvp060	null		outer move loop point
	tsy	setptw-*	virtualize and set ptw
	rem
mvp080	oct	0	this location is set to 'cax2' or 'cax3' inst
	rem
*
*  paged move loop
	rem
mvp100	null		move no more than one page here
	lda	0,2	get one source word
	sta	0,3	store in target
	iacx2	1	update pointers
	iacx3	1
	iaq	-1	is current page moved?
	tnz	mvp100-*	no. continue move
*
*  check if whole move is finished
	rem
	ldq	mrmlen-*	has everything been moved?
	tze	mvpret-*	yes. return
*
*  update absolute address
	rem
	lda	mabsad-*	update absolute address
	ada	mvllmp-*	 with length of last move pass
	sta	mabsad-*
*
*  set up length of next move pass
	rem
	sbq	l.w003-*	(=256) update length of total remaining move
	stq	mrmlen-*	is it negative?
	tmi	mvp110-*	yes
	ldq	l.w003-*	(=256) no. move a whole page
	stq	mvllmp-*
	tra	mvp060-*	move some more
	rem
mvp110	null
	adq	l.w003-*	(=256) back up last subtract
	stz	mrmlen-*	last pass coming up
	tra	mvp060-*	go do it
	rem
mvpret	null
	return	mvpgtg
	rem
	rem
a.w001	ind	.crmem	last legal memory address
	rem
l.w001	cax2
l.w002	cax3
l.w003	dec	256
l.w004	oct	024000	inhibit interrupts and overflow
	rem
mabsad	oct	0	absolute address
mrmlen	oct	0	current remaining total length of move
mtstad	oct	0	test address value for legalness
mvllmp	oct	0	length of last move pass
mvplmm	zero		move paged lower memory maximum address
	ttls	mcs space management routines
************************************************************************
*
*	format of buffer pool header
*
************************************************************************
	rem
fp.fst	equ	0	pointer to first free block
	rem
************************************************************************
*
*	format of free block
*
************************************************************************
	rem
fb.nxt	equ	0	next block pointer
fb.siz	equ	1	size of this block in words
	eject
************************************************************************
*
*	subroutine to allocate buffer space in low memory.
*	the request is rounded up to a 'bufsiz' boundary
*	and removed from the full buffer pool.
*
*	calling sequence:
*
*		q  =  size of space to allocate
*
*	returns:
*
*		returns in line if request fails
*		takes skip return if request suceeds
*		x3 -> space allocated
*
************************************************************************
	rem
getbuf	subr	gbf,(inh,a,q,x1)
	tsy	a.y011-*,*	(timein) record time entered
	cqa		number of words to allocate
	tsy	a.y005-*,*	(chksiz) check for valid size
	iaa	bufsiz-1	round to multiple of bufsiz
	iana	-bufsiz
	caq
	ldx1	a.y003-*	=addr(.crnxa) start of chain
	tsy	a.y006-*,*	(getspc) allocate the space
	tra	gbfnsp-*	failed
gbfok	aos	getbuf-*	succeeded, setup skip return
	staq	gbfaq-*	safe store aq (smeter uses them)
	smeter	mincd,.mbufa,l.y001-*
	ldaq	gbfaq-*	restore them
	rem
*	update .crnbf
	rem
	ars	bufshf	convert from words to buffers
	iera	-1	complement
	iaa	1
	asa	a.y001-*,*	update .crnbf
	tsy	a.y013-*,*	(setsc) set size code and clear buffer
	rem
	trace	mt.get,0,(x3,gbfsq,getbuf,gbfsx1)
	rem
gbfbak	ila	0	indicate allocation call
	tsy	a.y012-*,*	extime
	return	getbuf
	rem
*	request for buffers failed. try cleaning up small space
	rem
gbfnsp	tsy	a.y002-*,*	(=fresml) this does cleanup
	tra	gbfng-*	didn't do any good
	tsy	a.y006-*,*	(getspc) retry request
	tra	gbfng-*	still fails
	tra	gbfok-*	this made request work
	rem
gbfng	smeter	mincs,.malof,l.y001-*
	tra	gbfbak-*
	eject
************************************************************************
*
*	procedure for getting a small amount of memory. the
*	calling sequence is the same as for getbuf, except
*	the request is rounded to an even number, and the returned
*	address will only be on an even boundary
*
************************************************************************
	rem
getmem	subr	gtm,(inh,a,q,x1)
	tsy	a.y011-*,*	timein
	cqa		word count
	tsy	a.y005-*,*	(chksiz) check for valid size
	iaa	1	make it even
	iana	-2
gbfsml	caq		word count
	ldx1	a.y009-*	=addr(.crnxs)
	tsy	a.y006-*,*	(getspc) look in small space chain
	tra	gbfail-*	not there
	aos	getmem-*	found it, take skip
	tsy	a.y014-*,*	(clrbuf) go clear space
	rem
	trace	mt.get,0,(x3,gtmsq,getmem,gtmsx1)
	rem
gtmbak	ila	0	indicate allocate call
	tsy	a.y012-*,*	extime
	return	getmem
	rem
*	must allocate more buffers for small space
	rem
gbfail	sta	gbftmp-*	save word count
	iaa	bufsiz-1	round to next multiple
	iana	-bufsiz
	caq
	ldx1	a.y007-*	=addr(.crnxa)
	tsy	a.y006-*,*	(getspc) get buffer
	tra	gtmng-*	failed, give up
	ldx1	a.y009-*	=addr(.crnxs)
	tsy	a.y004-*,*	(relspc) free in to small chain
	ars	bufshf	convert to buffers
	asa	a.y010-*,*	increment .crnbs
	iera	-1	complement
	iaa	1
	asa	a.y001-*,*	decrement .crnbf
	lda	gbftmp-*	get original word count
	tra	gbfsml-*	retry allocate
	rem
gtmng	smeter	mincs,.malof,l.y001-*
	tra	gtmbak-*
	rem
	rem
a.y001	ind	.crnbf
a.y002	ind	fresml
a.y003	ind	.crnxa
a.y004	ind	relspc
a.y005	ind	chksiz
a.y006	ind	getspc
a.y007	ind	.crnxa
*a.y008		unused
a.y009	ind	.crnxs
a.y010	ind	.crnbs
a.y011	ind	timein
a.y012	ind	extime
a.y013	ind	setsc
a.y014	ind	clrbuf
	rem
l.y001	dec	1
	rem
gbftmp	bss	1
	even
gbfaq	bss	2
	eject
************************************************************************
*
*	timein: records the elapsed timer at entry so that the time
*	spent in the allocation/freeing routines can be metered
*
************************************************************************
	rem
timein	subr	tmn
	lda	a.x001-*,*	etmb
	sta	sttime-*	record time of entry
	return	timein
	rem
	rem
************************************************************************
*
*	extime: records elapsed time at exit from
*	allocation/freeing routines, for metering.
*	also meters current use of buffer pool
*
*	input:
*	    a reg contains 0 for allocate, 1 for free
*
************************************************************************
	rem
extime	subr	ext,(a,q,x2)
	lda	a.y001-*,*	(.crnbf)
	ada	a.y010-*,*	(.crnbs)
	als	bufshf	convert to words for metering
	sta	savcnt-*
	smeter	mupdat,.mspav,savcnt-*
	rem
	rem		measure time spent
	lda	a.x001-*,*	etmb (current elapsed timer value)
	sta	sttimx-*	save it (for debugging)
	sba	sttime-*	a now contains time spent
	ldx1	extsa-*	get alloc/free indicator
	ldx2	a.x002-*,*	get pointer to relevant structure
	lrl	18	make time into doubleword
	staq	loctim-*	hang on to it
	adaq	it.tot,2	update running total
	staq	it.tot,2
	ldaq	loctim-*
	cmpq	it.max,2	new maximum?
	tmi	2
	stq	it.max,2	yes, save it
	ilq	1	see if it's more than 1 msec.
	cmpq	loctim+1-*
	tpl	ext010-*	nope
	adaq	it.gt1,2	yes, add 1 (which happens to be in aq)
	staq	it.gt1,2	to count of same
	ila	0
	ilq	1	get the one back
ext010	adaq	it.inc,2	update increment count
	staq	it.inc,2
	return	extime
	rem
	rem
a.x001	ind	etmb
a.x002	ind	itaddr,1
	rem
savcnt	bss	1	number of free words (for metering)
sttime	bss	1	elapsed timer reading at entry
sttimx	bss	1	elapsed timer reading at exit
itaddr	ind	getbfm
	ind	frebfm
	rem
	even
loctim	bss	2	elapsed time while in routine
getbfm	bss	8	time meters for get calls
frebfm	bss	8	time meters for free calls
	eject
************************************************************************
*
*	subroutine to fill in buffer size code
*	and zero the rest of the buffer
*
*	input:
*	    q contains size in words
*	    x3 points to buffer
*
************************************************************************
	rem
setsc	subr	ssc,(a,q,x3)
	iaq	-32	reduce by one unit
	qls	15-bufshf	align in word
	stq	bf.siz,3
	stz	bf.nxt,3
	lda	sscsq-*	total words
	iaa	-2	number left to clear
	iacx3	2	starting address to clear
	tsy	clrbuf-*
	return	setsc
	rem
************************************************************************
*
*	subroutine to clear buffer or allocated space
*
*	input:
*	    x3 points to space to be cleared
*	    a contains number of words to clear
*
************************************************************************
	rem
clrbuf	subr	clr,(a,q,x3)
	ars	1	number of double words to clear
	iera	-1	complement
	iaa	1
	sta	clrtmp-*
	ila	0	constants to store
	ilq	0
clr010	staq	0,3	zero two words
	iacx3	2
	aos	clrtmp-*
	tnz	clr010-*
	return	clrbuf
	rem
	rem
clrtmp	bss	1
	eject
************************************************************************
*
*	subroutine to free buffer space in low memory
*
*	calling sequence:
*
*		x3 -> space to be freed
*		q  =  size of space (or 0 meaning use buffer size code)
*
************************************************************************
	rem
frebuf	subr	fbf,(inh,a,q,x1)
	tsy	a.n001-*,*	timein
	cqa		pick up size
	tnz	fbf010-*	size is given
	lda	fb.siz,3	get size code
	arl	15
	iaa	1	number of buffers
	als	bufshf	convert to words
	tra	fbf020-*
fbf010	tsy	chksiz-*	check for valid size
	iaa	bufsiz-1	round to multiple of bufsiz
	iana	-bufsiz
fbf020	sta	fretmp-*	save buffer size temporarily
	rem
	trace	mt.fre,0,(x3,fretmp,frebuf,fbfsx1)
	rem
	lda	fretmp-*
	ldx1	a.n002-*	=addr(.crnxa) free from full buffer chain
	caq
	tsy	a.n003-*,*	relspc
	ars	bufshf	get buffer count
	asa	a.n004-*,*	update .crnbf
	ila	1	indicate free call
	tsy	a.n005-*,*	extime
	return	frebuf
	rem
fretmp	bss	1
	eject
************************************************************************
*
*	similiar entry for freeing memory
*
************************************************************************
	rem
fremem	subr	frm,(inh,a,q,x1)
	tsy	a.n001-*,*	timein
	cqa		word count
	tsy	chksiz-*	check for valid size
	iaa	1	make it even
	iana	-2
	sta	fretmp-*	save size
	rem
	trace	mt.fre,0,(x3,fretmp,fremem,frmsx1)
	rem
	ldq	fretmp-*	retrieve size
	ldx1	a.n006-*	=addr(.crnxs)
	tsy	a.n003-*,*	relspc
	ila	1	indicate free call
	tsy	a.n005-*,*	extime
	return	fremem
	rem
	rem
a.n001	ind	timein
a.n002	ind	.crnxa
a.n003	ind	relspc
a.n004	ind	.crnbf
a.n005	ind	extime
a.n006	ind	.crnxs
	eject
************************************************************************
*
*	subroutine to check for a valid buffer size in the a
*
************************************************************************
	rem
chksiz	oct	0
	szn	bfcksw-*	should we check?
	tnz	chksiz-*,*	no
	icmpa	1
	tpl	2
	die	1
	cmpa	maxsiz-*
	tmi	2
	die	2
	tra	chksiz-*,*
	rem
maxsiz	ind	bfmsiz+1
	rem
	symdef	bfcksw	indicates whether calls are checked
	rem
bfcksw	oct	1	start out as no
	eject
************************************************************************
*
*	getbfh -- get a buffer in extended memory. address boundary
*	will be chosen based on buffer size so as to ensure that no
*	buffer spans a page boundary
*
*	input:
*	    q -- size in words
*
*	output:
*	    a -- absolute address of allocated buffer
*	    x3 -- virtual   "     "        "     "
*	    buffer window page table entry set up appropriately
*
************************************************************************
	rem
getubf	null		name retained for compatibility
getbfh	subr	gfh,(inh,q,x1,x2)
	tsy	a.j007-*,*	timein
	cqa		hang on to size
	tsy	a.j006-*,*	chksiz
	iaa	bufsiz-1
	iana	-bufsiz	round size to nearest multiple of bufsiz
	caq		this is size we'll use
	stq	size-*	put it in cold storage
	ila	0	clear the a
	iaq	-1	and shift size-1
	lls	18-bufshf	so as to get number of bufsiz blocks
	cax2		in order to force appropriate boundary
	adcx2	a.j003-*	addr (bounds)
	lda	0,2	get the boundary in the a
	sta	bndry-*	save it
	stz	prvadr-*	initialize
	lda	a.j001-*,*	(.crnxe) start search
	tze	gfh025-*	no extended memory at all
	rem
gfh010	sta	blkadr-*	block we're testing
	tsy	a.j002-*,*	(setbpt) get virtual address
	cax2
	cana	bndry-*	is it properly aligned?
	tnz	gfh020-*	no, go to next free block
	lda	fb.siz,2	yes, is it big enough?
	cmpa	size-*
	tpl	gfh030-*	yes, use it
	rem		look at next block
gfh020	lda	blkadr-*	save block address as previous
	sta	prvadr-*
	lda	fb.nxt,2	get next
	tnz	gfh010-*	if any
	rem		no usable blocks in high memory,
	rem		try low
gfh025	ldx1	a.j004-*	addr (.crnxa)
	ldq	size-*
	tsy	a.j009-*,*	(getspc) regular space allocating subroutine
	tra	gfh070-*	forget it, no space to be had
	stx3	blkadr-*	ok
	rem		meter instance of having to use low memory
	smeter	mincs,.mblow,l.j001-*
	rem
	tra	gfh060-*	join common code
	rem		found usable block in high memory
gfh030	null		a contains size
	stx2	blkvir-*	save virtual address
	ldq	fb.nxt,2	pick up address of next free block
	sba	size-*	size of remainder
	tze	gfh040-*	none
	adcx2	size-*	this is address of new free block
	stq	fb.nxt,2	put forward pointer in
	sta	fb.siz,2	and size
	lda	blkadr-*	now get absolute address of allocated block
	ada	size-*
	caq		now, however we got here, address
gfh040	null		of next block is in q
	lda	prvadr-*	get address of previous block
	tze	gfh050-*	if any
	tsy	a.j002-*,*	(setbpt) make it usable
	cax2
	stq	fb.nxt,2	rethread new next block
	lda	blkadr-*	now get allocated block address back
	tsy	a.j002-*,*	(setbpt)
	cax3
	tra	gfh060-*	go turn it into a buffer
	rem
gfh050	stq	a.j001-*,*	(.crnxe) new head of free chain
	ldx3	blkvir-*	we haven't lost its page
gfh060	aos	getbfh-*	take successful return
	ldq	size-*	set the size code and clear the buffer
	tsy	a.j005-*,*	setsc
	rem		now update .crnbf
	cqa		get size in a
	ars	bufshf	convert to buffers
	iera	-1	complement
	iaa	1
	asa	a.j010-*,*	.crnbf
	rem
	smeter	mincd,.mbufa,l.j001-*
	rem
	trace	mt.get,0,(blkadr,gfhsq,getbfh,gfhsx1)
	rem
gfhbak	ila	0
	tsy	a.j008-*,*	extime
	lda	blkadr-*	absolute address as well
	return	getbfh
	rem
gfh070	null		failure branch
	smeter	mincs,.malof,l.j001-*
	tra	gfhbak-*
	rem
	rem
l.j001	dec	1
	rem
a.j001	ind	.crnxe
a.j002	ind	setbpt
a.j003	ind	bounds
a.j004	ind	.crnxa
a.j005	ind	setsc
a.j006	ind	chksiz
a.j007	ind	timein
a.j008	ind	extime
a.j009	ind	getspc
a.j010	ind	.crnbf
	rem
size	bss	1
prvadr	bss	1
blkadr	bss	1
blkvir	bss	1
bndry	bss	1
	rem
bounds	equ	*	array of strings for and'ing to ensure
	rem		correct boundary -- indexed by buffer size
	oct	000037
	oct	000077
	oct	000177
	oct	000177
	oct	000177
	oct	000377
	oct	000377
	oct	000377
	oct	000377
	eject
************************************************************************
*
*	frebfh -- external entry to free a single buffer in high
*	memory. internal subroutine frhbuf does most of the real work.
*
*	input:
*	    a contains absolute address of buffer to be freed
*	    q contains size in words (if zero, use size code in buffer)
*
************************************************************************
	rem
frebfh	subr	frb,(a,q,x2,x3)
	cmpa	l.l001-*	(bwndow) is buffer in fact in high memory?
	tnc	frb010-*	no, use frebuf
	cax2		hang on to absolute address
	tsy	a.l001-*,*	setbpt
	cax3		get virtual address in x3
	lda	frebfh-*	save return address
	sta	frertn-*	for trace call
	cx2a		get absolute address back in a
	tsy	a.l002-*,*	frhbuf
frbbak	return	frebfh
	rem
frb010	cax3		address in x3
	tsy	a.l003-*,*	frebuf
	tra	frbbak-*
	eject
************************************************************************
*
*	subroutine to free a buffer chain
*
*	calling sequence:
*
*		a contains absolute address of buffer chain
*
************************************************************************
	rem
frelbf	subr	frl,(a,q,x2)
	rem
	trace	mt.frc,0,(frlsa,frelbf,x1,x3)
	rem
	ldq	frelbf-*	for trace calls on individual
	stq	frertn-*	buffers
	ilq	0	always use size in buffer
	lda	frlsa-*
frl010	cmpa	l.l001-*	(bwndow) is buffer in high memory?
	tmi	frl030-*	no, use frebuf
	cax2		hang on to absolute address
	tsy	a.l001-*,*	setbpt
	cax3		get virtual into x3
	lda	bf.nxt,3	hold forward pointer
	sta	frlnxt-*	hang on to it
	cx2a		recover absolute address of buffer
	tsy	a.l002-*,*	(frhbuf) free one buffer
frl020	lda	frlnxt-*	recover next pointer
	tnz	frl010-*	not at end yet
	return	frelbf
	rem
frl030	cax3
	lda	bf.nxt,3
	sta	frlnxt-*
	tsy	a.l003-*,*	frebuf
	tra	frl020-*
	rem
	rem
a.l001	ind	setbpt
a.l002	ind	frhbuf
a.l003	ind	frebuf
	rem
l.l001	vfd	18/bwndow
	rem
frlnxt	bss	1
frertn	bss	1
	eject
************************************************************************
*
*	frhbuf -- subroutine to do the real work of freeing a buffer
*	in high memory.
*
*	input:
*	    a - absolute address of buffer
*	    q - size in words
*	    x3 - virtual address of buffer
*	    buffer page table entry set up appropriately
*
************************************************************************
	rem
frhbuf	subr	frh,(inh,a,q,x1,x2,x3)
	sta	freadr-*
	tsy	a.k003-*,*	timein
	ldx2	a.k005-*,*	.crbpe
	lda	0,2	save pte
	sta	frepte-*	which callers may be counting on
	rem
	stz	frenxt-*	initialize
	stz	freprv-*
	cqa		get size
	tnz	frh005-*	if supplied
	ldq	bf.siz,3	else derive it from buffer size code
	qrl	15
	iaq	1
	qls	bufshf
	tra	frh007-*
frh005	iaa	bufsiz-1	round it to multiple of bufsiz
	iana	-bufsiz
	caq
frh007	stq	fb.siz,3
	stq	fresiz-*
	trace	mt.fre,0,(freadr,fresiz,frertn,frhsx1)
	rem
	lda	a.k001-*,*	(.crnxe) get head of chain
	tze	frh060-*	no chain at the moment
frh010	cmpa	freadr-*	see if new block comes before next free one
	tnc	frh030-*	no, look for next block
	tze	frhdie-*	oops, this is already free
	sta	frenxt-*	we've found the first block after the one we're
	cax2		freeing
	lda	freadr-*	get the original one back
	tsy	a.k002-*,*	(setbpt) get the pte right
	cax3
	stx2	fb.nxt,3	set its forward pointer
	lda	freprv-*	hook it on to previous one
	tnz	frh020-*	if any
	lda	freadr-*
	sta	a.k001-*,*	(.crnxe) none, this is head
	tra	frh050-*	combine ahead
	rem
frh020	tsy	a.k002-*,*	(setbpt) get previous block's
	cax1		virtual address
	lda	freadr-*	thread new one to it
	sta	fb.nxt,1
	tra	frh040-*	combine behind
	rem
frh030	sta	freprv-*	save most recent block address
	tsy	a.k002-*,*	(setbpt) get virtual address
	cax1		to look at forward pointer
	lda	fb.nxt,1
	tnz	frh010-*	if any
	sta	frenxt-*	no next pointer, remember that
	lda	freadr-*	thread new one to last found
	sta	fb.nxt,1
	tsy	a.k002-*,*	(setbpt) get new one's virtual
	cax3		address
	stz	fb.nxt,3	set its forward pointer
	rem
frh040	null		try to combine with previous block
	lda	freprv-*
	caq
	tsy	a.k002-*,*	setbpt
	cax3		virtual address in x3
	adq	fb.siz,3	end of previous block
	cmpq	freadr-*	does it reach new one?
	tnc	frh050-*	no, can't combine
	tnz	frhdie-*	overlaps!
	lda	freprv-*	make sure they're in same page
	ana	l.k001-*	=o777400
	sta	frebas-*
	lda	freadr-*
	ana	l.k001-*	=o777400
	cmpa	frebas-*
	tnz	frh050-*	they are not, don't combine
	lda	frenxt-*	they are, so previous now points
	sta	fb.nxt,3	to next
	ldq	fb.siz,3
	adq	fresiz-*	and its size increases accordingly
	stq	fb.siz,3
	lda	freprv-*	and this the address of
	sta	freadr-*	the current block
	rem
frh050	null		try to combine with following block
	lda	frenxt-*
	tze	frhbak-*	there is none, we're done
	ana	l.k001-*	=o777400
	sta	frebas-*	save base of next block's page
	lda	freadr-*
	ana	l.k001-*
	cmpa	frebas-*	compare with current one
	tnz	frhbak-*	different, can't combine
	lda	freadr-*	get current block
	caq
	tsy	a.k002-*,*	setbpt
	cax3		virtualized
	adq	fb.siz,3	see if it extends to next
	cmpq	frenxt-*
	tnc	frhbak-*	it doesn't
	tnz	frhdie-*	goes past it!
	lda	frenxt-*	to combine, get virtual address
	tsy	a.k002-*,*	(setbpt) of next block
	cax2		since they're in same page, both
	lda	fb.siz,3	are addressable
	ada	fb.siz,2	so combine their sizes
	sta	fb.siz,3	this is new size of current block
	lda	fb.nxt,2	which points past old next one
	sta	fb.nxt,3
	rem
frhbak	ldx2	a.k005-*,*	.crbpe
	lda	frepte-*	restore original pte
	sta	0,2
	lda	fresiz-*	get size so as to update .crnbf
	ars	bufshf	convert to buffers
	asa	a.k006-*,*	.crnbf
	ila	1	mark as free call
	tsy	a.k004-*,*	extime
	return	frhbuf
	rem
frh060	lda	freadr-*	this is only free block
	sta	a.k001-*,*	.crnxe
	stz	fb.nxt,3
	tra	frhbak-*
	rem
frhdie	die	4	free blocks overlap
	rem
	rem
a.k001	ind	.crnxe
a.k002	ind	setbpt
a.k003	ind	timein
a.k004	ind	extime
a.k005	ind	.crbpe
a.k006	ind	.crnbf
	rem
l.k001	oct	777400
	rem
frenxt	bss	1
freprv	bss	1
freadr	bss	1
fresiz	bss	1
frebas	bss	1
frepte	bss	1
	eject
************************************************************************
*
*	subroutine to find free space of a desired size
*	it is unthreaded from the beginning of the smallest block
*	large enough to hold it.
*
*	calling sequence:
*
*		x1 -> buffer pool header
*		q  =  size of space needed, in words
*
*	returns:
*
*		procedure takes skip return if it succeeds,
*		non-skip return if it fails.
*
*		x3 -> space allocated
*
************************************************************************
	rem
getspc	subr	gsp,(a,x2)
	stz	prvblk-*	initialize some stuff
	stz	bstblk-*	will be addr of smallest block
	ldx3	bstblk-*	to zero the reg
	lda	a.z001-*,*	=.crmem, bigger that biggest free block
	ldx2	fp.fst,1	pick up pointer to first free block
gsp040	tze	gsp010-*	end of chain
	cmpq	fb.siz,2	is this block big enough?
	tze	gsp020-*	exactly right, dont look anymore
	tpl	gsp030-*	too small, skip to next
	cmpa	fb.siz,2	is this a better (smaller) block to use?
	tze	gsp030-*	same, dont use it
	tmi	gsp030-*	already have smaller block
	stx2	bstblk-*	save pointer to best block
	ldx3	prvblk-*	rembember best blocks predessor
	lda	fb.siz,2	remember best blocks size
gsp030	stx2	prvblk-*
	ldx2	fb.nxt,2	step to next block
	tra	gsp040-*
gsp010	ldx2	bstblk-*	get pointer to best block
	tze	gspret-*	no block big enough, take error return
	stx3	prvblk-*	unthread subr needs this pointer
gsp020	aos	getspc-*	call will succeed, setup skip return
	cx2a
	cax3		x2-x3 to unthread from beginning of block
	tsy	unthrd-*	unthread selected space
gspret	return	getspc
	rem
bstblk	bss	1
a.z001	ind	.crmem
a.z002	ind	.crnxa
a.z003	ind	.crnbf
a.z004	ind	.crnxs
a.z005	ind	.crnbs
a.z006	ind	fresml
a.z007	ind	timein
a.z008	ind	.crbuf
a.z009	ind	extime
	rem
l.z001	dec	1	for metering
	eject
************************************************************************
*
*	subroutine to unthread space from a free chain
*
*	calling sequence:
*
*		x1 -> buffer poll header
*		x2 -> starting address to unthread
*		x3 -> free block space is coming from
*		q  =  size of block to unthread
*		prvblk contains address of free block which proceeds
*		       the block pointed to by x2
*
************************************************************************
	rem
unthrd	subr	unt,(a,q,x2,x3)
	lda	fb.siz,3	size of entire block
	sba	untsq-*	amount of space that will be left
	sta	unttmp-*	this number will be useful later
	tze	untall-*	if zero, unthreading entire free block
	cx2a		addr of space to unthread
	sba	untsx3-*	amount of space before block unthreaded
	tze	untbeg-*	if 0, unthreding from beginning
	cmpa	unttmp-*	equal to size remaining?
	tze	untend-*	yes, unthreading from end of block
	rem
*	unthreading from the middle of a free block
	rem
untmid	sta	fb.siz,3	size of first partial block
	adq	untsx2-*	compute addr of second partial block
	lda	fb.nxt,3	hold forward pointer
	stq	fb.nxt,3	make first block point to second
	ldx2	fb.nxt,3	addr of second block
	ldq	unttmp-*	total space in both free blocks
	sbq	fb.siz,3	subtract out size of first block
	staq	fb.nxt,2	update pointer and size
	tra	untret-*
	rem
*	unthreading from end of a free block
	rem
untend	lda	unttmp-*	new size of partial block
	sta	fb.siz,3
	tra	untret-*	thats all to do
	rem
*	unthread an entire free block
	rem
untall	lda	fb.nxt,3	pick up pointer to next block
untjon	ldx2	prvblk-*	addr of previous whole block
	tze	unthed-*	none, unthreading head
	sta	fb.nxt,2	make prev point to next
	tra	untret-*
unthed	sta	fp.fst,1	new head of chain
	tra	untret-*
	rem
*	unthreading from beginning of a free block
	rem
untbeg	adcx2	untsq-*	compute address of new partial block
	lda	fb.nxt,3	it will now point forward
	ldq	unttmp-*	and this will be its size
	staq	fb.nxt,2	update block
	cx2a
	tra	untjon-*	go update preceeding block
	rem
untret	return	unthrd
	rem
unttmp	bss	1
prvblk	bss	1
	eject
************************************************************************
*
*	subroutine to free space no longer needed. it is returned to
*	the free pool and combined with any adjacent blocks
*
*	calling sequence:
*
*		x1 -> free pool header
*		x3 -> block to free
*		q  =  size of block
*
************************************************************************
	rem
relspc	subr	rsp,(a,x2)
	cx3a		validate addr >= .crbuf
	cmpa	a.z008-*,*	=.crbuf
	tze	3
	tpl	2
	die	3
	stq	fb.siz,3	free block will need its size
	ldx2	fp.fst,1	pick up first block pointer
	tnz	rsp010-*	non-null chain
	stx3	fp.fst,1	freeing only block in chain
	stz	fb.nxt,3	no forward pointer
	tra	rspret-*
rsp010	stz	prvblk-*
	stx3	rsptmp-*
rsp030	cx2a		into 'a' for the compare
	cmpa	rsptmp-*	found spot for this block?
	tpl	rsp020-*	yes, goes before this block
	stx2	prvblk-*
	ldx2	fb.nxt,2	step foward
	tnz	rsp030-*
	rem
*	free a block which goes at end of chain
	rem
	ldx2	prvblk-*
	stx3	fb.nxt,2	make old last point at new last
	stz	fb.nxt,3	make new last the end
	tra	rsp050-*
	rem
*	freeing a block that is not at end
	rem
rsp020	ldx2	prvblk-*	pick up proceeding block
	tnz	rsp040-*
	rem
*	block goes at head of chain
	rem
	lda	fp.fst,1	old head
	stx3	fp.fst,1	new head
	sta	fb.nxt,3	make new head point at old head
	tra	rsp060-*
	rem
*	block goes in middle
	rem
rsp040	lda	fb.nxt,2	forward pointer from prev block
	stx3	fb.nxt,2	its new pointer is to this block
	sta	fb.nxt,3	forward pointer to next block
	rem
*	combine new block with preceeding
	rem
rsp050	cx2a		address of previous block
	ada	fb.siz,2	calculate end of previous block
	stx3	rsptmp-*	address of current block
	cmpa	rsptmp-*	check for join
	tmi	rsp060-*	don't join
	tze	rsp070-*	they do
	die	4	they overlap
rsp070	lda	fb.nxt,3	block after current
	sta	fb.nxt,2	make previous point at it
	lda	fb.siz,3	size of current
	asa	fb.siz,2	add into size of previous
	cx2a
	cax3		make x3 point at new combined cuurrent block
	rem
*	combine current block with following one
	rem
rsp060	szn	fb.nxt,3	last block?
	tze	rspret-*	yes
	cx3a		address of current
	ada	fb.siz,3	end of current
	cmpa	fb.nxt,3	does it join with next?
	tmi	rspret-*	no
	tze	rsp080-*	yes
	die	4	overlap
rsp080	ldx2	fb.nxt,3	address of next block
	lda	fb.siz,2	get next block size
	asa	fb.siz,3	add into current block size
	lda	fb.nxt,2	next blocks follower
	sta	fb.nxt,3	thrad after current
	rem
rspret	ila	-1	put bad addr in x3
	cax3
	return	relspc
rsptmp	bss	1
	eject
************************************************************************
*
*	subroutine to scan the small buffer chain and find any space
*	that can be recombined into large buffers. it is called when
*	we run out of real buffers as a last resort.
*
*	return:
*
*		will take a skip return if any buffers were freed
*
************************************************************************
	rem
fresml	subr	fsm,(a,q,x1,x2,x3)
	stz	fsmcnt-*	zero count of buffers found
fsm040	stz	prvblk-*	initialze to follow threads
	ldx3	a.z004-*,*	=addr(.crnxs) next small block
	tze	fsm010-*	empty chain
fsm050	cx3a		start of free block
	ada	fb.siz,3	compute end address
	sta	fsmtmp-*	save
	cx3a
	iaa	bufsiz-1	round up to next buffer address
	iana	-bufsiz
	cmpa	fsmtmp-*	does next buffer start in free block?
	tpl	fsm020-*	no
	cax2		save buffer start address
	iaa	bufsiz	compute end of possible buffer address
	cmpa	fsmtmp-*	is buffer complete in block?
	tmi	fsm030-*	yes
	tnz	fsm020-*	no
fsm030	ilq	bufsiz	setup to unthread the buffer we found
	ldx1	a.z004-*	=addr(.crnxs)
	tsy	unthrd-*	unthread from current chain
	ldx1	a.z002-*	=addr(.crnxa)
	cx2a
	cax3
	tsy	relspc-*	free in to regular buffer chain
	aos	fsmcnt-*	count buffers i found
	tra	fsm040-*	and continue
fsm020	stx3	prvblk-*	step to next block
	ldx3	fb.nxt,3
	tnz	fsm050-*
fsm010	lda	fsmcnt-*	count of buffers freed
	tze	fsmret-*	none
	aos	fresml-*	 can take skip return
	asa	a.z003-*,*	update .crnbf
	iera	-1	complement count
	iaa	1
	asa	a.z005-*,*	update .crnbs
fsmret	return	fresml
fsmcnt	bss	1
fsmtmp	bss	1
	end
