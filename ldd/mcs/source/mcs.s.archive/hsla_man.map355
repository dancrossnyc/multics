* ***********************************************************
* *                                                         *
* * Copyright, (C) Honeywell Information Systems Inc., 1982 *
* *                                                         *
* * Copyright (c) 1972 by Massachusetts Institute of        *
* * Technology and Honeywell Information Systems, Inc.      *
* *                                                         *
* ***********************************************************

* HISTORY COMMENTS:
*  1) change(85-07-29,Cousins), approve(85-10-28,MCR7274),
*     audit(85-07-29,Coren), install():
*     change hardware status queue refresh mechanism
*        to swap between a pair of queues.  This strategy avoids windows in
*        refresh operation during which status can arrive unnoticed.
*  2) change(85-10-28,Cousins), approve(85-10-28,MCR7275),
*     audit(85-10-28,Coren), install():
*     Change suspend/resume strategy to send a PCW with the transmit bit off
*      instead of manipulating ICWs to force an exhaust condition.
*  3) change(85-11-08,Coren), approve(85-11-08,MCR7275),
*     audit(85-11-17,Beattie), install(88-09-20,MR12.2-1115):
*     Make some corrections to the changes for suspend/resume.
*  4) change(85-12-20,Kozlowski), approve(88-08-15,MCR7965),
*     audit(88-09-08,Farley), install(88-09-20,MR12.2-1115):
*     Add support to set speeds of 2400, 4800 and 9600 as required by
*     autobaud_tables.
*  5) change(88-07-22,Beattie), approve(88-08-15,MCR7965),
*     audit(88-09-08,Farley), install(88-09-20,MR12.2-1115):
*     Prepared for installation.
*                                                      END HISTORY COMMENTS

	ttl	hsla_man - multics/fnp (mcs) hsla manager
	ttls	hsla_man - multics/fnp (mcs) hsla manager
	lbl	,hsla_man
	editp	on
	pmc	on
	pcc	off
	base	8
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	hsla_man, hsla
*
*	     This is hsla_man, the high speed line
*	adaptor support routine for the multics/fnp
*	communications system (mcs). It is driven by
*	dcw lists supplied by the control_tables and
*	interrupts from the various types of lines
*	connected to the hsla subchannels.
*
*	     Status from the interrupts is not
*	processed at interrupt time, but is queued
*	for later processing. This avoids problems of
*	processing status for a line while the call side
*	is changing parameters about that line.
*
*	coded 9/5/74 by mike grady
*
*	modified 79 jul 20 by art beattie to support dn6670
*	  extended memory.
*
*	modified july 1981 by robert coren to incorporate
*	   dave cousins' code for faster icw switching.
*
*	modified september 1984 by robert coren to fix several bugs:
*	   correct the order of storing icw words;
*	   set flow control characters in first half of a double cct;
*	   resume suspended output on quit;
*	   make mskchn free chains correctly if t.ocur is
*	    a non-first subset of t.ocp;
*	   fix oscan's check for overflowing t.pos with tabs;
*	   make hmode resume output if oflow turned off while
*	    suspended.
*	modified april 1985 by robert coren to make scan subroutine not
*	   use page table entry if buffer address is in low memory.
*
*	modified sept 1985 by D. W. Cousins to do suspend and resume
*	   by turning off the pcw transmit bit instead of forcing
*	   an exhaust condition, which could result in a race with the
*	   hardware.
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	tib
	ttls	software communications region, hsla
	sfcm	hsla
	rem
	rem
	hwcm
	rem
	meters
	rem
	hslatb
	csbits
	devtab
	buffer
	rem
hbfnch	equ	bufsiz*2-5	number of real spots in hsla input bfr
	rem
	comreg
	rem
	dlytbl
	ttls
	cctdef
	ttls	symrefs and symdefs
	symdef	hsla	primary sysdef
	symdef	hdcw	dcw list processor
	symdef	hintr	interrupt processor
*	symdef	hbreak	change break list
	symdef	hgeti	get ptr and tally of input bfr
	symdef	hmode	chnage modes entry
	symdef	houtav	output has arrived entry
	symdef	hcfg	change confiuration
	symdef	hslajt	location of hsla jump tables
	symdef	setcct	setcct opblock handler
	symdef	shrcct	shared cct handler
	symdef	hcheck	to start echoing if possible
	symdef	cbufsz	change sf.bsz size for sync pre alloc buffer
	symdef	hunmsk	subroutine to unmask a subchannel
	rem
	rem
	symref	trace
	symref	outprc	processor for output sub-op
	symref	istat	entry in intrp for status
	symref	maskr	return point in control_tables after masking
	symref	itest	test-state entry of control_tables
	symref	invp	interrupt handler in scheduler
	symref	g3wjt	entry to get interrupt info
	symref	dspqur	secondary dispatcher
	symref	mdisp	return to master dispatcher
	symref	secdsp	return to secondary dispatcher
	symref	gettib	entry to get the tib addr
	symref	getbuf	entry to grab a buffer
	symref	getbfh	entry to grab a buffer from high memory
	symref	frebuf	entry to free a buffer
	symref	frebfh	entry to free a buffer in high memory
	symref	frelbf	entry to free a buffer chain
	symref	setbpt	entry to convert buffer address to virtual
	symref	cvabs	entry to convert address to absolute
	symref	denq	queuer for dia man requests
	symref	derrq	queuer for error messages to cs
	symref	meterc	metering subroutine
	symref	getmem
	symref	fremem
	symref	getcmt	get address of carriage mvmt tbl
	symref	inproc	processes input chars for asynchronous lines
	symref	setptw	set up page table word
	symref	mincs
	symref	mincd
	symref	mupdat	metering subroutines
	rem
	rem
	rem
hsla	null
	start	hsla,6
	hslast
	ttls	hsla pcw op-codes and broadside commands
	rem
	rem	pcw command type codes
	rem
pcw.0	bool	000000	command type 0 pcw
pcw.1	bool	200000	cmd type 1 w/broadside
pcw.2	bool	400000	config type 2 async
pcw.3	bool	600000	config type 3 sync
	rem
	rem	op-codes
	rem
p.nop	bool	000000	no operation
p.ris	bool	010000	request input status
p.ros	bool	020000	request output status
p.rcs	bool	030000	request config status
p.msk	bool	040000	set subchannel mask bit
p.rmsk	bool	050000	reset subchannel mask bit
p.sriw	bool	060000	switch receive icw
p.ssiw	bool	070000	switch send icw
p.init	bool	100000	initialize
p.smsk	bool	110000	store subchannel mask register
	bool	120000
	bool	130000
p.rsyn	bool	140000	re-sync the subchannel
p.tlbk	bool	150000	transmit line break
	bool	160000
	bool	170000
	rem
	rem	broadside bits
	rem
pb.rcv	bool	000400	set receive mode
pb.xmt	bool	000200	set xmit mode
pb.wam	bool	000100	set wraparound mode
pb.dtr	bool	000040	set data terminal ready
pb.rts	bool	000020	set request to send
pb.mby	bool	000010	make busy
pb.sxt	bool	000004	set supervisory transmit
pb.tre	bool	000004	set tally runout enable (hdlc)
pb.crq	bool	000002	set call request(acu)
pb.msk	bool	000001
	rem
	rem	pcw type 2 (asynch confiuration) mode bits
	rem
p2.5bt	bool	140000	5-bit characters
p2.6bt	bool	150000	6-bit characters
p2.7bt	bool	160000	7-bit characters
p2.8bt	bool	170000	8-bit characters
p2.mbt	bool	170000	mask for char size field
p2.lpr	bool	000040	lateral parity receive
p2.lps	bool	000020	lateral parity send
p2.lpo	bool	000010	lateral parity odd
p2.icw	bool	000004	two send icw's
p2.cct	bool	000002	cct enable
p2.spr	bool	000001
	rem
	rem
	rem	pcw type 3 (sync config)
	rem
p3.itf	bool	000400	hdlc interframe time fill
p3.beb	bool	000400	bsc ebcdic mode
p3.btr	bool	000200	bsc transparent
	ttls	random bits, flags, and definitions
	rem
	rem	sub-op types for dcw list
	rem
dl.cmd	equ	1	command sub-op
dl.in	equ	2	input sub-op
dl.out	equ	3	output sub-op
dl.rdt	equ	4	read tally sub-op
dl.sup	equ	5	additional command sub-op data
	rem
	rem	sub-op types for config list
	rem
fg.smd	equ	1	set mode bit
fg.rmd	equ	2	reset mode bit
fg.bd	equ	3	change baud rate
	rem
	rem	control tables and cct stuff
	rem
ct.dev	equ	1	offset of dev table ptr
	rem
ttasci	equ	1	t.type value for ascii channels
	rem
linmsk	bool	103
sndout	bool	105	send output op for denq
errmsg	bool	115	error message op for derrq
	rem
	rem
lposhf	equ	5	amount to shift tfoddp to get p2.lpo
lpsshf	equ	3	amount to shift tf8out to get p2.lps
	rem
	rem
h1ch	equ	6	first hsla iom channel number
h3ch	equ	8	last hsla iom channel number
	rem
schdmn	equ	4	module number for scheduler invp
	rem
minsiz	equ	bufsiz	size of smallest asynchronous input pseudo-buffer
	rem
mxntty	equ	32	max number subchannels per hsla
maxtty	equ	mxntty*3	max tty on hslas
	rem
hpri	equ	6	priority of hsla_man hstprc
hprip3	equ	3	high priority for ptro status
hprip2	equ	2	highest priority for >9600 ptro status
	rem
sw.dbg	equ	0	on if debugging the module
	rem
nl	bool	12	new-line
ff	bool	14	form-feed
cr	bool	15	carriage return
tab	bool	11	horizontal tab
etx	bool	3
	rem
bwndow	bool	077000	base address of paging window
	eject
************************************************************************
*
*	format of cct descriptor entry
*	one exists for each shared cct
*
************************************************************************
	rem
cct.nx	equ	0	pointer to next entry
cct.pr	equ	1	pointer to previous entry
cct.ad	equ	2	address of the cct
cct.sz	equ	3	length of the cct
cct.rc	equ	4	referenct count
cct.ln	equ	5	length of descriptor
	rem
	rem
	rem
	rem	equates for echo buffer things
	rem
eb.inp	equ	0
eb.otp	equ	1
eb.tly	equ	2
eb.dta	equ	2
	rem
ebmax	equ	bufsiz*2-5
	ttls	trace types and switches
	rem
tt.dcw	equ	1	trace hdcw calls
tt.pcw	equ	2	trace pcw connects
tt.int	equ	3	trace interrupts
tt.sta	equ	4	trace status
tt.ira	equ	5	trace icw recovery attempt
	rem
	rem
ts.dcw	bool	000002
ts.pcw	bool	000004
ts.int	bool	000010
ts.sta	bool	000020
	ttls	macros for hsla_man
	rem
	rem	macro to generate command bit lookup
	rem
cmdtab	macro
	vfd	1/#2,17/#1
	ife	'#2','c.on',2
	vfd	18/#3
	ife	1,0,1
	vfd	o18//#3
	endm
	rem
	rem	macro to generate pcw lookup table
	rem
pcwtab	macro
	vfd	18/#1
	vfd	18/#2
	endm
	rem
	rem	macro to generate config mode bit lookup table entry
	rem
cfgtab	macro
	vfd	18/#1
	vfd	18/#2
	vfd	18/#3
	ind	#4
	endm
	rem
	rem	macro to generate status lookup tables
	rem
stats	macro
	vfd	18/#1
	ind	#2
	endm
	rem
	rem	macro to setup status match table
	rem
smap	macro
	vfd	18/#1
	vfd	18/#2
	endm
	rem
	rem	macro to do real divide
	rem
dvd	macro
	qls	1
	dvf	#1
	endm
	eject
	rem
	rem	macro to do real multiply
	rem
mpy	macro
	mpf	#1
	lrl	1
	endm
	rem
	rem	generates the odd word of a dn6670 paged data address icw
	rem	  which allows iom to directly address 64k memory.
	rem	uses same format as icw pseudo-op except the address is
	rem	  is not supplied and the third argument must be supplied.
	rem
amicwo	macro
	vfd	2/2,3/#1,1/#3,12/#2
	endm	amicwo
	ttls	hdcw - hsla dcw list processor
	pmc	off
hdcw	subr	dcw,(x1,x2,x3)	save the index regs
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	hdcw
*
*	     subroutine called by interpreter to process
*	a dcw list found in the control_tables.
*
*	Upon entry:
*	     x1 - virtual tib address
*	     t.dcwa - address of dcw list
*	     t.dcwl - dcw list length
*
*	returns:
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	ldx2	t.sfcm,1	get ptr to sfcm
	lda	sf.flg,2	get sfcm flags
	icana	sffech	some echo now?
	tze	dcw004-*	no, go ahead
	rem
	lda	t.dcwl,1	get count of times we've skipped out
	lrl	9	it's in upper half of t.dcwl
	iaa	1	increment it
	icmpa	60	over limit?
	tpl	dcw002-*	yes, force it through
	rem
	lls	9	restore lower half of word
	sta	t.dcwl,1	update count
	ilq	7	meter delayed processing
	tsy	a.a008-*,*	meterc
	tra	dcwret-*	done here for now
	rem
dcw002	ila	sffech	we're going to force this off
	iera	-1
	ansa	sf.flg,2
	rem
	ila	pb.xmt	transmit mode too
	iera	-1
	ansa	sf.pcw,2
	rem
	ilq	8	meter overriding of sffech
	tsy	a.a008-*,*	meterc
	rem
dcw004	ila	-1	we're going to process dcw list
	arl	9	wipe out count in upper half of t.dcwl
	ansa	t.dcwl,1
	rem
dcw005	lda	t.dcwl,1	look for real work to be done
	tnz	2	sure, go do it.
	die	8
	rem
	ldx3	sf.hsl,2	get pointer to hsla table entry
	ldx3	ht.tib,3	get real tib address for trace
	trace	tt.dcw,ts.dcw,(x3,t.dcwa(1),t.dcwl(1))
	rem
	ldx3	t.dcwa,1	get ponter to dcw list
	lda	0,3	get first dcw
	arl	18-3	shift to get type
	icmpa	dl.cmd	is it a command dcw?
	tze	dcw010-*	yes, go process it
	rem
	icmpa	dl.in	is it input sub-op?
	tze	dcwret-*	yes, done
	rem
	icmpa	dl.rdt	is it a read tally sub-op?
	tze	dcwret-*	yes, done
	rem
	tsy	bldobf-*	look for output sub-op
	rem
	tra	dcwret-*	all done.
	rem
dcw010	ldq	l.a005-*	(=p.ris) get request input status op
	stq	dcwpcw-*	save for later
	rem
	lda	t.stat,1	pick up tib status
	ana	l.a001-*	(=tsfxmt&tsfrcv) isolate rcv and xmt
	sta	dcwst-*	and save for later, also
	rem
	lda	a.a001-*	(=cmdtab) get addr of cmd table
	sta	cmdls-*	set for subr to use
	lda	a.a002-*	(=cmdend) get end of table addr
	sta	cmdle-*	also for subr
	tsy	cmdprc-*	process the command op
	rem
	szn	t.dcwl,1	any more dcw list left?
	tze	dcw020-*	no, done
	rem
	ldx3	t.dcwa,1	yes, get addr of dcw list
	lda	0,3	get the dcw
	arl	18-3	shift down to look at type
	rem
	icmpa	dl.sup	is it a supplemental cmd op?
	tnz	dcw020-*	no, continue
	rem
	lda	a.a011-*	(=suptab) get addr of sup table
	sta	cmdls-*	set for subr process
	lda	a.a012-*	(=supend) end of cmd table
	sta	cmdle-*	set also for subr
	tsy	cmdprc-*	process sup cmd op
	rem
dcw020	lda	dcwst-*	get the old rcv & xmt modes
	ana	l.a003-*	(=tsfrcv) old rcv mode only
	era	l.a003-*	(=tsfrcv) ^old rcv mode now
	cana	t.stat,1	^oldrcv&rcv, did we just enter rcv?
	tze	dcw030-*	no, continue...
	rem
	lda	sf.flg,2	synchronous line?
	cana	l.a010-*	=sffsyn
	tze	dcw025-*	no, don't set message size
	ldq	sf.mms,2	get max message size
	stq	sf.rms,2	reset residual message size
	rem
dcw025	tsy	bldibf-*	go setup rcv data
	rem
	lda	l.a011-*	get control rcv mask
	iera	-1	invert bits
	ansa	t.flg2,1	turn off control rcv
	rem
dcw030	lda	t.stat,1	get the tib status
	cana	l.a004-*	(=tsfxmt) in xmit mode?
	tze	dcw035-*	no
	rem
	szn	sf.ob0,2	get addr of first output
	tnz	dcw035-*	output still ready, skip
	szn	sf.ob1,2	check second
	tnz	dcw035-*	likewise
	rem
	tsy	bldobf-*	yes, setup output buffers
	tra	dcw040-*	done
	rem
dcw035	lda	t.stat,1	get new xmit mode setting
	ana	l.a004-*	(=tsfxmt) leave only xmit mode
	era	l.a004-*	(=tsfxmt) invert for ^xmit
	cana	dcwst-*	^xmit&oldxmit, did we just leave xmit mode?
	tze	dcw040-*	no, continue
	rem
	lda	l.a008-*	(=sffstp) get bit to indicate this
	ldx2	t.sfcm,1	get ptr to sfcm and
	orsa	sf.flg,2	turn it on in the sfcm
	rem
dcw040	lda	l.a007-*	(=tsfbrk) shd we send line break?
	cana	t.stat,1	line break?
	tze	dcw050-*	no, skip it
	rem
	ldq	l.a006-*	(=p.tlbk) transmit line break op
	stq	dcwpcw-*	reset default op code
	rem
	iera	-1	complement tsfbrk
	ansa	t.stat,1	and turn it off in tib
	rem
dcw050	ldx2	t.sfcm,1	get ptr to sfcm
	ldx3	a.a003-*	(=pcwtab) get ptr to pcw table
	lda	l.a014-*	(pb.msk) preserve "masked" bit
	ansa	sf.pcw,2	init rest of pcw to zero
	rem
dcw055	lda	t.stat,1	get tib status bits
	cana	0,3	is this one on in tib?
	tze	dcw060-*	no, jump out
	rem
	lda	1,3	get pcw broadside bit
	orsa	sf.pcw,2	and or it into or pcw
	rem
dcw060	iacx3	pcwlen	add in table element size
	cmpx3	a.a004-*	(=pcwend) at end of table?
	tnz	dcw055-*	no, loop
	rem
	lda	t.flg,1	check for suspended output
	cana	l.a012-*	=tfosus
	tze	dcw070-*	not suspended, all is well
	lda	l.a013-*	=^pb.xmt
	ansa	sf.pcw,2	if suspended we don't want xmit now
	rem
dcw070	lda	dcwpcw-*	get the op-code
	tsy	a.a007-*,*	do a connect
	rem
	szn	t.dcwl,1	any more dcw list now?
	tze	dcwret-*	no, done
	rem
	lda	dcwpcw-*	get pcw just sent
	cmpa	l.a006-*	(=p.tlbk) sent line break?
	tnz	dcwret-*	no, done
	rem
	ldx3	t.dcwa,1	get addr of dcw list
	lda	0,3	get the next dcw
	arl	18-3	shift into position
	icmpa	dl.cmd	is it command?
	tze	dcw005-*	yes, process it now
	rem
dcwret	return	hdcw	all done, go back
	rem
	rem
dcwpcw	bss	1	(altrd) save pcw op-code for connect
dcwst	bss	1	(altrd) status save for old rcv and xmt
	rem
	rem
l.a001	vfd	18/tsfxmt+tsfrcv tib rcv and xmt
l.a002	vfd	o18/400000	on/off bit in cmdtab
l.a003	vfd	18/tsfrcv	tib receive alone
l.a004	vfd	18/tsfxmt	tib transmit alone
l.a005	vfd	18/p.ris	request input status op-code
l.a006	vfd	18/p.tlbk	transmit line break op-code
l.a007	vfd	18/tsfbrk	tib transmit line break
l.a008	vfd	18/sffstp	stop channel bit
l.a009	oct	077777
l.a010	vfd	18/sffsyn
l.a011	vfd	18/tfcrcv
l.a012	vfd	18/tfosus
l.a013	vfd	o18//pb.xmt
l.a014	vfd	18/pb.msk
	rem
	rem
a.a001	ind	cmdtab	command bit lookup table
a.a002	ind	cmdend
a.a003	ind	pcwtab	pcw bit lookup table
a.a004	ind	pcwend
a.a005	ind	outprc	output sub-op processor
a.a006	ind	seticw	setup icw's subr
a.a007	ind	cioc	connect routine
a.a008	ind	meterc
*a.a009        unused
a.a011	ind	suptab
a.a012	ind	supend
	rem
	ttls	command and pcw lookup tables
	rem
	rem	command table
	rem
cmdtab	null
	cmdtab	c.srec,c.on,tsfrcv
	cmdtab	c.rrec,c.off,tsfrcv
	cmdtab	c.sxmt,c.on,tsfxmt
	cmdtab	c.rxmt,c.off,tsfxmt
	cmdtab	c.sdtr,c.on,tsfdtr
	cmdtab	c.rdtr,c.off,tsfdtr
	cmdtab	c.ssup,c.on,tsfsxt
	cmdtab	c.rsup,c.off,tsfsxt
	cmdtab	c.stat,c.on,tsfst
	cmdtab	c.sbrk,c.on,tsfbrk
	cmdtab	c.smrk,c.on,tsfmrk
	cmdtab	c.strm,c.on,tsftrm
	cmdtab	c.srqs,c.on,tsfrts
	cmdtab	c.rrqs,c.off,tsfrts
cmdend	equ	*
	rem
suptab	null
	cmdtab	c.scrq,c.on,tsfcrq
	cmdtab	c.rcrq,c.off,tsfcrq
supend	equ	*
	rem
cmdlen	equ	2
	rem
c.on	equ	0
c.off	equ	1
	rem
	rem	pcw table
	rem
pcwtab	null
	pcwtab	tsfrcv,pb.rcv
	pcwtab	tsfxmt,pb.xmt
	pcwtab	tsfdtr,pb.dtr
	pcwtab	tsfrts,pb.rts
	pcwtab	tsfsxt,pb.sxt
	pcwtab	tsfcrq,pb.crq
pcwend	equ	*
	rem
pcwlen	equ	2
	ttls	cmdprc - subr to process cmd op from list
cmdprc	subr	cpr,(x1,x2)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	cmdprc
*
*	     this subroutine is internal proc for hdcw
*	which processes type 1 and 5 dcw cmd blocks.
*	it is list driven.
*
*	upon entry:
*	     x1 - virtual tib address
*	     cmdls - points to head of list
*	     cmdle - points to end of list
*
*	returns:
*	     tib flags set
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	ldx2	cmdls-*	get addr of command table
cpr010	lda	0,3	pick up cmd bits
	ana	l.a009-*	leave only the cmd bits
	cana	0,2	is this cmd bit on in dcw?
	tze	cpr030-*	no, continue loop
	rem
	lda	0,2	look at function bit
	cana	l.a002-*	(=400000) is it on?
	tnz	cpr020-*	yes, we want to turn bit off in tib
	rem
	lda	1,2	pick up t.stat bits
	orsa	t.stat,1	and turn them on in the tib
	rem
	tra	cpr030-*	go look for more work
	rem
cpr020	lda	1,2	get the correct bits
	ansa	t.stat,1	and turn them off in the tib
	rem
cpr030	iacx2	cmdlen	increment table ptr
	cmpx2	cmdle-*	at the end of table?
	tnz	cpr010-*	nope, go for more
	rem
	aos	t.dcwa,1	increment dcw list addr
	ila	-1	and decrement the dcw list
	asa	t.dcwl,1	length word
	rem
	return	cmdprc
	rem
cmdls	bss	1
cmdle	bss	1
	ttls	bldobf - build output buffers from dcw list
bldobf	subr	bob,(x1,x2,x3)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	bldobf
*
*	     subroutine to build output buffers from
*	an output dcw. called by hdcw.
*
*	upon entry:
*	     x1 - virtual tib address
*	     t.dcwa - addr of output dcw
*	     t.dcwl - length of dcw list
*
*	returns:
*	     a pair of output buffers is ready to connect to.
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	lda	t.dcwl,1	is dcw list gone?
	tze	bobret-*	yes, exit
	rem
	ldx3	t.dcwa,1	get addr of first dcw
	lda	0,3	pick up that dcw
	arl	18-3	get the sub-op type
	icmpa	dl.out	is it output?
	tnz	bobret-*	no, exit
	rem
	tsy	a.a005-*,*	(=outprc) go process output subop
	rem
	ldx2	t.sfcm,1	get sfcm address
	lda	t.flg,1	check for output suspended
	cana	l.b007-*	=tfosus
	tnz	bobret-*	it is, wait for resume char
	tsy	a.a006-*,*	(=seticw) else set up the icw's
	rem
bobret	return	bldobf	all done
	ttls	bldibf - build input buffers
bldibf	subr	bib,(x1,x2,x3)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	bldibf
*
*	     this subroutine builds input buffers from dcw
*	list. called by hdcw.
*
*	upon entry:
*	     x1 - virtual tib address
*	     t.dcwa - addr of dcw list
*	     t.dcwl - length of dcw list
*
*	returns:
*	     a pair of input buffers to connect to.
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	ldx2	t.sfcm,1	pick up sfcm addr
	ldx3	sf.hcm,2	pick up addr of hwcm
	rem
	iacx3	h.ric0	add in offset
	stx3	bibicw-*	save ptr to icw
	ldx3	t.sfcm,1	get ptr to sfcm again
	iacx3	sf.ib0	add in offset of ib1
	stx3	bibibp-*	and save taht too
	rem
	lda	sf.flg,2	get sfcm flags
	icana	sffcii	which icw is active?
	tze	bib010-*	primary, use it first
	rem
	ila	h.ric1-h.ric0	get diff
	asa	bibicw-*	add to save to get right one
	ila	sf.ib1-sf.ib0	get other diff
	asa	bibibp-*	and update ptr
	rem
bib010	tsy	rboibf-*	setup old input buffer
	rem
	ila	sfhmk	pick up icw mask
	ersa	bibicw-*	switch icw ptr to alt
	ila	sfbfmk	pick up buffer mask
	ersa	bibibp-*
	rem
	lda	t.flg2,1	get tib flags
	cana	l.b015-*	(=tfcrcv) control rcv mode?
	tze	bib020-*	no, need another buffer
	rem
	stz	bibibp-*,*	zero input buffer ptr
	ldx3	bibicw-*	get icw addr
	lda	a.b009-*	(=bnispc) get addr of spare word
	ldq	l.b008-*	(=450000) get exhausted tally
	staq	0,3	set icw
	tra	bibret-*	done
	rem
bib020	tsy	bnibuf-*	build a new input buffer
	rem
bibret	return	bldibf	all done in here
	rem
	rem
	rem
bibibp	bss	1	(altrd) ptr to sf.ib0/1
bibicw	bss	1	(altrd) ptr to icw1/2
bibcnt	bss	1	(altrd) count for cct copy
bibabs	bss	1	(altrd) absolute ptr to reused buffer
bibvir	bss	1	(altrd) virtual pointer to reused buffer
	rem
	rem
l.b001	vfd	18/bufsmk	buffer size code mask
l.b002	zero	minsiz
l.b003	vfd	18/sffsyn
l.b004	vfd	18/tffrmi
l.b005	zero	0,b.1
l.b006	vfd	18/tfifc
l.b007	vfd	18/tfosus
l.b008	oct	450000
l.b009	vfd	18/bfflst
l.b010	ind	0,b.0
l.b011	vfd	18/buftmk
	even
*l.b012	unused
l.b013	vfd	18/tfabf0
l.b014	vfd	18/tfabf1
l.b015	vfd	18/tfcrcv
l.b016	vfd	18/tfmrcv
l.b017	vfd	18/tffip
	rem
	rem
a.b001	ind	getbfh
a.b002	ind	setbpt
a.b003	ind	bldicw
a.b004	ind	.crpte
*a.b005
a.b006	ind	ghibuf
*a.b007	unused
*a.b008
a.b009	ind	bnispc
	ttls	rboibf - rebuild old input buffer
rboibf	subr	rbo,(x1)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	rboibf
*
*	     this routines checks for a partially filled
*	input buffer. if one is found it is setup as the
*	current input buffer, with correct icw and buffer
*	tallies. if none is found bnibuf is called to allocate
*	a fresh one.
*
*	upon entry:
*	     x1 - virtual tib address
*	     x2 - virtual sfcm address
*	     bibibp - ind word to sf.ib0/1
*	     bibicw - ind word to h.ric0/1
*
*	returns:
*	     icw and sf.ib0/1 setup
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	lda	sf.flg,2	synchronous line?
	cana	l.b003-*	=sffsyn
	tze	rbo050-*	no, don't reuse old buffer
	rem
	szn	t.icp,1	any input chain now?
	tze	rbo050-*	nope, no need to reuse any
	rem
	lda	t.ilst,1	get ptr to last buffer
	sta	bibabs-*
	tsy	a.b002-*,*	(setbpt) convert to virtual
	cax3
	lda	bf.tly,3	get tally
	ana	l.b011-*	(=buftmk) leave only tally
	sta	bibcnt-*	save it
	lda	bf.siz,3	get buffer size code
	arl	15	right adjust
	als	bufshf+1	convert to chars
	iaa	hbfnch	one buffer, less overhead
	cmpa	bibcnt-*	is buffer full (tally = size)?
	tze	rbo050-*	yes, can't add to it
	sta	rbotly-*	save max tally
	rem
	lda	t.flg2,1	get tib flags
	cana	l.b016-*	(=tfmrcv) message rcv mode ?
	tze	rbo005-*	no, continue
	lda	l.b009-*	(=bfflst)
	orsa	bf.flg,3	set buffer last flag
	tra	rbo050-*	get a shiny new buffer
	rem
rbo005	stx3	bibvir-*	save buffer ptr
	lda	t.icp,1	get ptr to head of chain
	caq		save it
	tsy	a.b002-*,*	setbpt
	cax3		get virtual address
	cmpq	bibabs-*	same as tail?
	tnz	rbo010-*	no
	rem
	stz	t.icp,1	zero all chain ptrs now
	stz	t.ilst,1
	tra	rbo030-*
	rem
rbo010	lda	bf.nxt,3	get the next ptr
	cmpa	bibabs-*	does it point to last?
	tze	rbo020-*	yes, steal off chain
	lda	bf.nxt,3	bump to next on chain
	caq		hang on to absolute address
	tsy	a.b002-*,*	setbpt
	cax3		get virtual in x3
	tra	rbo010-*	loop
	rem
rbo020	stz	bf.nxt,3	clobber next pointer
	stq	t.ilst,1	make as new last
	rem
rbo030	lda	bf.siz,3	get buffer size code
	arl	15	right adjust
	iera	-1	add one and negate
	asa	t.icpl,1	decrement chain length
	rem
	lda	bibabs-*	get ptr to buffer we will use
	sta	bibibp-*,*	put ptr into sfcm
	tsy	a.b002-*,*	setbpt
	cax3
	stz	bf.nxt,3	make next ptr zero
	lda	l.b001-*	get size code mask
	ansa	bf.tly,3	leave only size code
	lda	rbotly-*	get max tally
	orsa	bf.tly,3	put tally in buffer
	rem
	lda	bibcnt-*	get tally in buffer
	ars	1	divide to get word count
	ada	l.b010-*	(=0,b.0) add in addr bits
	iaa	bf.dta	add offset of data
	asa	bibvir-*	add into address of buffer
	lda	bibcnt-*	get tally again
	icana	1	is it odd?
	tze	rbo040-*	no
	rem
	ldx3	bibvir-*	get addr
	iacx3	0,b.1	bump up
	stx3	bibvir-*	put it back
rbo040	lda	rbotly-*	get whole tally
	sba	bibcnt-*	leave icw tally
	caq		put into q
	lda	bibvir-*	get virtual addr
	ldx3	bibicw-*	get ptr to icw
	tsy	a.b003-*,*	(bldicw) fill in icw now
	tra	rboret-*
	rem
rbo050	null		no partial input buffer
	tsy	bnibuf-*	allocate a new one
	rem
rboret	return	rboibf
	rem
rbotly	bss	1
	ttls	bnibuf - build a new input buffer for the current icw
bnibuf	subr	bni,(x1)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	bnibuf
*
*	     this routine allocates a new input buffer
*	for the current icw and sets the tally.
*
*	upon entry:
*	     x1 - virtual tib address
*	     x2 - virtual sfcm address
*	     bibibp - ind word to sf.ib0/1
*	     bibicw - ind word to h.ric0/1
*
*	returns:
*	     icw and bf.tly setup
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	tsy	a.b006-*,*	(=ghibuf) get input buffer
	tra	2	error, no buffer
	tra	bni030-*	got buffer, continue
	rem
	rem		failed to get buffer, best we can
	rem		do now is to set exhaust bit in icw
	stz	bibibp-*,*	zero input buffer ptr
	ldx3	bibicw-*	get icw addr
	lda	a.b009-*	(=bnispc) get addr of spare word
	ldq	l.b008-*	(=450000) get exhausted tally
	staq	0,3	set icw
	tra	bniret-*	better luck next time
	rem
bni030	szn	bibibp-*,*	be sure no old buffer left
	tze	2
	die	9
	rem
	sta	bibibp-*,*	store addr in sfcm ib1/2
	lda	sf.flg,2	synchronous line?
	cana	l.b003-*	=sffsyn
	tnz	bni040-*	yes, this buffer will go into an input chain
	cx3a		no, this is a "pseudo-buffer"
	ora	l.b005-*	(0,b.1) data starts in 2nd character
	tra	bni050-*
	rem
bni040	iacx3	bf.dta	add in offset of start of data
	cx3a
	ora	l.b010-*	(=0,b.0) get the character addressing flags
	rem
bni050	ldx3	bibicw-*	get ptr to icw
	tsy	bldicw-*	set it up
	lda	sf.flg,2	sync line?
	cana	l.b003-*	=sffsyn
	tze	bniret-*	no, don't bother with buffer size stuff
	ldq	sf.bsz,2	*get current buffer size
	tsy	cbufsz-*	*set sync prebuffer if needed
	rem
bniret	return	bnibuf
	rem
bnispc	bss	1	space to store char on tally runout
	ttls	bldicw - build a data icw
**********************************************************************
*
*	bldicw: sets up a data icw for transfer to/from extended
*	memory. translates an old-style 32k icw into extended form.
*
*	input:
*	   a  - character address (assumes buffer pte correct)
*	   q  - tally
*	   x3 - address of icw
*
*	output:
*	   an icw of the following form:
*	   word 0: 18-bit address
*	   word 1: bit 0 = 1
*	           bit 1 = 0
*	           bits 2-4: character addressing code
*	           bit 5 = 0
*	           bits 6-17 = tally
*
**********************************************************************
	rem
bldicw	subr	bic,(inh,a,q)
	ana	l.v005-*	(o077777) get word part alone
	tsy	a.v003-*,*	(cvabs) convert to absolute
	sta	0,3	put it in icw
	lda	bicsa-*	get address back in a
	ana	l.v003-*	(o700000) get character code alone
	arl	2	move it to bits 2-4
	ora	l.v004-*	(o400000) get 18-bit address flag
	ora	bicsq-*	or in tally
	sta	1,3	this is second word
	return	bldicw
	ttls	cbufsz - change buffer size
**********************************************************************
*
*	cbufsz - change buffer size in sfcm
*
*	this subroutine sets up the preallocated
*	buffer chain queue for a given buffer size.
*	   q -- new size
*	  x1 -- tib address
*
*	written for icw switching problem by
*		D. W. Cousins on March 24,1981
*
***********************************************************************
cbufsz	subr	cbu,(x1,x2,x3)
	ldx2	t.sfcm,1	*load sfcm
	tze	cburet-*	*problem no sfcm
	cqa		*set some indicators
	icmpa	32
	tmi	cbu010-*	*not if less then 32 words
	cmpa	l.v001-*	*(=401)check for max
	tmi	2	*within range
cbu010	ldq	l.v002-*	*(=400)set to max
	stq	sf.bsz,2	*ok store it
	qrs	5	*set up table index
	iaq	-1	*
	cqa
	cax3
	ila	4
	sta	a.v001-*,*	*=pbfmax,3 set max buffer count
	tsy	a.v002-*,*	*=albchs
cburet	return	cbufsz
a.v001	ind	pbfmax,3	max buffer count for this pool
a.v002	ind	albchs	allocated buffer check
a.v003	ind	cvabs
	rem
l.v001	oct	000401	max buffer + 1 in octal words
l.v002	oct	000400	max in octal words for buffer
l.v003	oct	700000
l.v004	oct	400000
l.v005	oct	077777
	ttls	ghibuf - get hsla input buffer
ghibuf	subr	ghi
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	ghibuf
*
*	allocates an hsla input buffer of the proper size
*
*	upon entry:
*	     x1 - virtual tib address
*	     x2 - virtual sfcm address
*
*	return 1:
*	     no more buffers can/should be allocated
*
*	return 2:
*	     virtual buffer addr in x3, with size code and tally
*	      set up if appropriate
*	     absolute buffer address in a
*	     buffer tally in q
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	ilq	bufsiz	buffer size for control rcv mode
	lda	t.flg2,1	get tib flags
	cana	l.b015-*	control rcv mode?
	tnz	ghi025-*	yes
	rem
	ldq	sf.bsz,2	get regular buffer size
	cana	l.b016-*	(=tfmrcv) message rcv mode ?
	tnz	ghi015-*	yes, get size
	lda	sf.flg,2	synchronous line?
	cana	l.b003-*	=sffsyn
	tnz	ghi025-*	yes, use full size
	lda	t.flg2,1	no, are we in a frame?
	ldq	sf.fbs,2	if so, use frame buffer size
	cana	l.b017-*	=tffip
	tnz	ghi010-*	we are
	cana	l.b006-*	=tfifc
	tnz	ghi010-*	likewise if input flow control
	ldq	sf.bsz,2	but if in blk_xfer, use intermediate size
	cana	l.b004-*	=tffrmi
	tnz	ghi010-*	that's it
	ldq	l.b002-*	(=minsiz) else use minimum size
ghi010	null		here to allocate asynchronous pseudo-buffer
	cmpq	l.b002-*	(=minsiz) is buffer nore than minimum size?
	tze	2	equal isn't larger
	tpl	ghi012-*	larger is
	lda	l.b013-*	(tfabf0) use one of the permanent ones
	cana	t.flg3,1	first one available?
	tze	ghi011-*	no, use second
	ldx3	t.abf0,1	yes, get it
	ersa	t.flg3,1	turn flag off
	tra	ghi01a-*
ghi011	lda	l.b014-*	tfabf1
	cana	t.flg3,1	is other one available?
	tze	ghi012-*	no, we'll have to allocate
	ldx3	t.abf1,1	yes, get other permanent buffer
	ersa	t.flg3,1	mark it unavailable
ghi01a	cx3a		convert address to virtual
	sta	ghiadr-*	butr save it first
	tsy	a.b002-*,*	setbpt
	cax3		back to x3
	ldq	0,3	get size (in upper half)
	qrl	8	convert to chars in lower half
	tra	ghi014-*
ghi012	null		have to really allocate
	tsy	a.b001-*,*	getbfh
	tra	ghi040-*	couldn't get it
	sta	ghiadr-*	hang on to absolute address (virtual is in x3)
	cqa		we have to store size in first char
	als	9
	sta	0,3
	stz	1,3	get rid of supposed size code
	stq	sf.csz,2	keep it here, too
	qls	1	convert to characters
ghi014	lda	ghiadr-*	get address back
	iaq	-3	size char. and ***two*** extra char. at end
	aos	ghibuf-*	for successful return
	tra	ghiret-*	done
	rem
ghi015	null		here for message receive mode
	szn	sf.mms,2	test max message size
	tze	ghi025-*	zero, ignore it
	rem
	lda	sf.rms,2	get residual message size
	tze	ghiret-*	zero, don't want buffer
	tmi	ghiret-*	negative, don't want buffer
	iaa	6	buffer overhead + round-up
	ars	1	convert to words
	sta	ghitmp-*	put in temporary
	cmpq	ghitmp-*	compare with buffer size
	tmi	ghi020-*	buffer size is smaller, use it
	caq		use message size instead
	rem
ghi020	tsy	a.z007-*,*	(=getbfh) get a buffer
	tra	ghi040-*	failed, make error return
	sta	ghiadr-*	succeeded, save absolute address
	rem
	qls	1	convert buffer size to characters
	iaq	-5	subtract overhead
	cqa		move to a
	iera	-1	negate a
	iaa	1
	asa	sf.rms,2	decrement residual message size
	tra	ghi030-*	done
	rem
ghi025	tsy	a.z007-*,*	(=getbfh) get a buffer
	tra	ghi040-*	failed, make error return
	sta	ghiadr-*	save absolute address
	rem
ghi030	aos	ghibuf-*	setup normal return
	stz	bf.nxt,3	init the next ptr
	lda	bf.siz,3	get buffer size code
	arl	15	right adjust
	als	bufshf+1	convert to chars
	iaa	hbfnch	one buffer, less overhead
	orsa	bf.tly,3	put tally in buffer
	caq		save tally in q
	lda	ghiadr-*	get absolute address back
	rem
ghiret	return	ghibuf
	rem
ghi040	null		allocation failed, meter it
	cmeter	mincs,m.inaf,l.z017-*
	tra	ghiret-*
	rem
ghitmp	bss	1
ghiadr	bss	1
	eject
	ttls	makcct - make cct based on modes
************************************************************************
*
*	subroutine to compute a cct for an ascii line.
*	all modes (crecho,lfecho,tabecho,echoplex, etc.)
*	are taken into account to compute the proper cct.
*
*	called with:
*		x1 - virtual tib address
*
************************************************************************
	rem
makcct	subr	mct,(x1,x2,x3,a,q)
	rem
*	first, get memory for cct
	rem
	ilq	64	normal ones are 64 words
	stz	mctsbx-*	initialize indicator
	lda	t.flg2,1
	cana	l.z001-*	=tffrmi, check for blk_xfer mode
	tze	mct060-*	no
	lda	t.frmc,1	any framing chars?
	tze	mct060-*	no
	arl	9	is there a start char?
	tnz	mct059-*	yes
	aos	mctsbx-*	indicate single cct with block xfer
	tra	mct060-*
mct059	iaq	64	must use double size
mct060	stq	mctsz-*	remember size
	tsy	a.z001-*,*	=getmem
	die	9
	stx3	mctad-*	save address
	rem
*	fill in default for all character positions.
*	this is:
*		ct.ncs	for most modes
*		ct.mrk	for echoplex & breakall
	rem
	ldq	l.z002-*	=vfd 9/ct.ncs,9/ct.ncs
	szn	mctsbx-*	single cct with block xfer?
	tnz	mct005-*	yes, ignore other modes
	lda	t.flg,1
	cana	l.z003-*	=tfecpx, in echoplex mode?
	tze	2	no
	ldq	l.z004-*	=vfd 9/ct.mrk,9/ct.mrk use marker for echoplex
	lda	t.flg3,1
	cana	l.z005-*	=tfbral, in breakall mode
	tze	2	no
	ldq	l.z004-*	=vfd 9/ct.mrk,9/ct.mrk marker on all characters
mct005	ila	64	store 64 copies
mct010	stq	0,3
	iacx3	1
	iaa	-1
	tnz	mct010-*
	rem
*	if double cct, second half is filled with
*	ct.ncs + ct.tb1 (to stay in second cct when entered)
	rem
	lda	mctsz-*	get size
	icmpa	64
	tze	mct020-*	standard size
	ldq	l.z007-*	=vfd 9/ct.ncs+ct.tb1,9/ct.ncs+ct.tb1
	ila	64	store 64 copies
mct030	stq	0,3
	iacx3	1
	iaa	-1
	tnz	mct030-*
	rem
*	fill in special character codes
	rem
mct020	ldx3	mctad-*	cct address
	szn	mctsbx-*	single cct with block xfer?
	tnz	mct055-*	yes, skip this stuff
	lda	t.flg3,1	check for breakall mode
	cana	l.z005-*	=tfbral
	tnz	mct050-*	skip for breakall mode,
	ila	nl	break on newline
	ilq	ct.mrk
	tsy	mctstr-*
	ila	ff	break on formfeed
	tsy	mctstr-*
	ila	etx	break on etx
	tsy	mctstr-*
	lda	t.flg,1	break on cr, if lfecho
	cana	l.z009-*	=tflfec
	tze	3
	ila	cr
	tsy	mctstr-*
	ilq	ct.mrk
	lda	t.flg,1	marker on tab, if tabecho
	cana	l.z008-*	=tftbec
	tze	3
	ila	tab
	tsy	mctstr-*
	rem
*	fill in codes for blk_xfer mode
	rem
mct050	lda	t.flg2,1
	cana	l.z001-*	=tffrmi
	tze	mct040-*
	lda	t.frmc,1	get framing chars
	tze	mct040-*	none, skip
	ilq	ct.tb1	switch to second cct
	ars	9	start char
	tsy	mctstr-*
	iacx3	64	switch to second cct
mct055	lda	t.frmc,1	get framing chars
	ana	l.z010-*	=o777
	ilq	ct.mrk
	tsy	mctstr-*
	ldx3	mctad-*	get pointer to first cct back
mct040	lda	t.flg2,1	check for input flow control
	cana	l.z006-*	=tfifc
	tze	mct080-*
	lda	t.ifch,1	yes
	arl	9	get suspend char
	tze	mct070-*	never mind, there is none
	ilq	ct.mrk	set marker for it
	tsy	mctstr-*
mct070	lda	t.flg2,1	recover flag word
mct080	cana	l.z015-*	(=tfofc) check output flow control
	tze	mct100-*
	cana	l.z016-*	(=tfblak) yes, block acknowledge also?
	tnz	mct090-*	yes, marker on ack char only
	lda	t.ofch,1	otherwise for both characters
	arl	9	get suspend char
	ilq	ct.mrk	marker in cct
	tsy	mctstr-*
mct090	lda	t.ofch,1	nopw get resume char (or ack)
	ana	l.z010-*	=o777
	ilq	ct.mrk
	tsy	mctstr-*
	rem
*	cct now ready, so store it
	rem
mct100	ldx3	mctad-*	its address
	ldq	mctsz-*	its size
	tsy	shrcct-*
	tsy	a.z002-*,*	and release temp memory
	rem
	szn	mctsbx-*	single cct with block xfer?
	tze	mctret-*	no
	lda	l.z014-*	(=tffip) get frame in progress bit
	orsa	t.flg2,1	always on for this cct
	rem
mctret	return	makcct
	rem
mctsz	bss	1
mctad	bss	1
mctsbx	bss	1
	rem
	rem
*	subroutine to store 1 cct character
	rem
mctstr	subr	cst,(a,q)
	ars	1	get word offset
	stx3	csttmp-*	cct address
	ada	csttmp-*	word address
	ora	l.z011-*	=0,b.0 - make character addressing
	cax2
	lda	cstsa-*	get character again
	iana	1	isolate last bit
	tze	2	even
	iacx2	0,b.1	go to odd address
	stq	0,2,b.0	update cct
	return	mctstr
	rem
csttmp	bss	1
	rem
a.z001	ind	getmem
a.z002	ind	fremem
a.z003	ind	.crcct
a.z004	ind	getbuf
a.z005	ind	frebuf
a.z006	ind	makcct
a.z007	ind	getbfh
	rem
l.z001	vfd	o18/tffrmi
l.z002	vfd	9/ct.ncs,9/ct.ncs
l.z003	vfd	o18/tfecpx
l.z004	vfd	9/ct.mrk,9/ct.mrk
l.z005	vfd	o18/tfbral
l.z006	vfd	o18/tfifc
l.z007	vfd	9/ct.ncs+ct.tb1,9/ct.ncs+ct.tb1
l.z008	vfd	o18/tftbec
l.z009	vfd	o18/tflfec
l.z010	oct	777
l.z011	ind	0,b.0
l.z012	vfd	o18/sffdct
l.z013	vfd	o18/sffsct
l.z014	vfd	o18/tffip
l.z015	vfd	o18/tfofc
l.z016	vfd	o18/tfblak
l.z017	dec	1
	eject
	ttls shrcct - subroutine to share and store ccts
************************************************************************
*
*	subroutine to store and share ccts
*
*	it is called with:
*		x3 -> cct
*		q = size (0 for no new cct)
*
*	the channel is update to use this cct, freeing the old cct
*	if necessary. The new cct is shared with an existing cct if possible.
*
************************************************************************
	rem
shrcct	subr	sct,(a,q,x1,x2,x3)
	rem
*	first, find the length of the cct. if the length is given
*	as 64, check to see if a short cct can be used
	rem
	stq	sctsz-*	size as given
	cqa
	tze	sct010-*	no new cct
	icmpa	64	single cct?
	tnz	sct020-*	no, cant use short cct
	iaa	-16	check 64-16 words
	ldq	l.z002-*	=vfd 9/ct.ncs,9/ct.ncs
sct030	cmpq	16,3	check all cct words
	tnz	sct020-*	cant use short cct
	iacx3	1
	iaa	-1
	tnz	sct030-*	loop
	ila	16	test passes - use short cct
	sta	sctsz-*
	rem
*	now try to locate an existing cct that matches the new one
	rem
sct020	stz	sctnds-*	pointer to new descriptor
	ldx1	a.z003-*,*	addr of first descriptor
	tze	sct010-*	none, no existing cct to share
sct060	lda	sctsz-*	size of new cct
	cmpa	cct.sz,1	match against existing cct
	tnz	sct040-*	sizes dont match, skip word check
	ldx2	sctsx3-*	addr of callers cct
	ldx3	cct.ad,1	address of existing cct
sct050	ldq	0,2	word to compare
	cmpq	0,3
	tnz	sct040-*	no match
	iacx2	1
	iacx3	1
	iaa	-1
	tnz	sct050-*
	stx1	sctnds-*	found matching cct in use
	lda	cct.ad,1	address of good cct
	ldx1	sctsx1-*	get tib address
	ldx2	t.sfcm,1
	cmpa	sf.cct,2	is this the cct already in use?
	tze	sctret-*	yes, all done
	tra	sct010-*
sct040	ldx1	cct.nx,1	step to next cct descriptor
	tnz	sct060-*
	rem
*	locate old cct descriptor and decrement usage
	rem
sct010	stz	sctods-*	pointer to old descriptor
	ldx1	sctsx1-*	get tib address
	ldx2	t.sfcm,1
	lda	sf.flg,2
	cana	l.z012-*	=sffdct, useing dynamic cct?
	tze	sct070-*	no old cct to locate
	ldx1	a.z003-*,*	=.crcct
sct090	tnz	2
	die	6	cant find cct descriptor
	ldx3	cct.ad,1	cct pointed to by this descrip
	cmpx3	sf.cct,2	this channels cct?
	tze	sct080-*	yes
	ldx1	cct.nx,1	keep looking
	tra	sct090-*
sct080	stx1	sctods-*	save address
	rem
*	setup descriptor for new cct if needed
	rem
sct070	szn	sctsz-*	is there new cct?
	tnz	sct160-*	yes
	ila	0	addr of no cct
	ilq	0	not short flag
	tra	sct110-*
sct160	ldx1	sctnds-*	new descriptor address
	tnz	sct170-*	all setup already
	ilq	cct.ln	allocate space for new descriptor
	tsy	a.z001-*,*	=getmem
	die	9
	stx3	sctnds-*
	ldx1	sctnds-*
	ldx3	a.z003-*,*	=.crcct, addr of first cct desc
	tze	2	new one is only desc
	stx1	cct.pr,3	make second desc point at first
	stx1	a.z003-*,*	new desc to head of chain
	stx3	cct.nx,1	make first point to second
	stz	cct.pr,1	no previous pointer
	rem
*	allocate memory for new cct and copy it. memory must be 64-word aligned
	rem
	ldq	sctsq-*	origional size
	iaq	32	allocate extra 32 words to force alignment
	tsy	a.z004-*,*	=getbuf
	die	9
	cx3a		allocate address?
	icana	=o77	on 64-word boundry?
	tze	sct120-*	yes
	iaa	32	this will get to 64-word boundry
	sta	cct.ad,1	for the real cct
	tra	sct130-*
sct120	sta	cct.ad,1	allocated address is aligned ok
	adcx3	sctsq-*	get addr of 32 words at end to free
sct130	ilq	32	free the extra 32 words
	tsy	a.z005-*,*	=frebuf
	lda	sctsz-*	set size
	sta	cct.sz,1
	icmpa	16	is this 16 word cct
	tnz	sct140-*	no
	ldx3	cct.ad,1	can free last 32 words of 64 word buffer
	iacx3	32
	ilq	32
	tsy	a.z005-*,*	=frebuf
sct140	ldx2	cct.ad,1	setup to copy cct
	ldx3	sctsx3-*
	lda	cct.sz,1
sct150	ldq	0,3	copy loop
	stq	0,2
	iacx2	1
	iacx3	1
	iaa	-1
	tnz	sct150-*
	stz	cct.rc,1	zero reference count
sct170	aos	cct.rc,1	new user of this cct
	ilq	0	flag meaning not short cct
	lda	cct.sz,1
	icmpa	16
	tnz	2
	ilq	1	it is short cct
	lda	cct.ad,1	address of cct
	rem
*	make channel use the new cct (it maybe 0)
*	a -> cct, q = short cct switch
*	a descriptor cannot be referenced here (there may not be one)
	rem
sct110	ldx1	sctsx1-*	tib address
	ldx2	t.sfcm,1
	sta	sf.cct,2	record cct address
	lda	l.z012-*	=sffdct, dynamic cct bit
	szn	sf.cct,2	is there cct
	tnz	2
	ila	0	reset bit
	era	sf.flg,2	get bit into word
	ana	l.z012-*	=sffdct
	ersa	sf.flg,2
	lda	l.z013-*	short cct bit
	iaq	0	test flag, is it short?
	tnz	2
	ila	0	not short
	era	sf.flg,2	store in flag word
	ana	l.z013-*	=sffsct
	ersa	sf.flg,2
	ldx3	sf.hcm,2	update hardware comm region too
	lda	sf.cct,2
	als	3
	iaq	0	short cct?
	tze	2	no
	iora	=o100	set short flag
	sta	h.baw,3	this effects he change officially
	rem
*	all done with old cct for this line, free it if last user
	rem
	ldx1	sctods-*	old descriptor address
	tze	sctret-*	no old one
	ila	-1	decrement usage count
	asa	cct.rc,1
	tnz	sctret-*	no
	ldq	cct.sz,1	free the cct first
	ldx3	cct.ad,1
	tsy	a.z005-*,*	=frebuf
	ldx2	cct.pr,1	unthread descriptor
	ldx3	cct.nx,1
	tze	2
	stx2	cct.pr,3	make next point to previous
	iacx2	0	is there a previous?
	tze	3	no
	stx3	cct.nx,2	make prev point at next
	tra	2
	stx3	a.z003-*,*	=.crcct, make next first
	cx1a		free descriptor
	cax3
	ilq	cct.ln
	tsy	a.z002-*,*	=fremem
	rem
sctret	return	shrcct
	rem
sctsz	bss	1	size of cct
sctods	bss	1	old descriptor address
sctnds	bss	1	new descriptor address
	ttls	setcct - implements the setcct opblock
	rem
************************************************************************
*
*	subroutine use by the interpreter when it encounters a setcct opblock
*
*	x1 - virtual tib address
*	a  =  arg to opblock
*
************************************************************************
	rem
setcct	subr	cct,(a,q,x2,x3)
	rem
	ldx2	t.sfcm,1
	ldx3	sf.hcm,2
	rem
	icmpa	scc.dl	delete cct?
	tze	cct010-*
	icmpa	scc.df	set default cct?
	tze	cct020-*
	icmpa	scc.bs	set to base of cct?
	tze	cct030-*
	rem
*	argument is real cct address
	rem
	ilq	0	release dynamic cct, if any
	tsy	shrcct-*
	sta	sf.cct,2
	als	3	align for baw
	sta	h.baw,3
	tra	cctret-*
	rem
*	process various coded requests
	rem
cct010	ilq	0	delete current cct
	tsy	shrcct-*
	tra	cctret-*
cct020	tsy	a.z006-*,*	build cct from modes
	tra	cctret-*
cct030	ldq	sf.cct,2	set to base cct
	qls 	3
	lda	sf.flg,2	get flags
	cana	l.z013-*	=sffsct, short cct?
	tze	2	no
	iaq	=o100	short cct bit for h.baw
	stq	h.baw,3
	rem
cctret	return	setcct
	ttls	hbreak - entry point to change break list
* hbreak	subr	brk,(x1,x3)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	hbreak
*
*	     entry to change the break list. causes
*	hsla_man to build a new cct for the line.
*
*	upon entry:
*	     x1 - virtual tib address
*	     x3 - points to change break command data
*
*	returns:
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	rem
*	well that is all for now
	rem
*	return	hbreak
	ttls	hgeti - entry to collect input from current buffer
hgeti	subr	hgi,(x2,x3)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	hgeti
*
*	obtains a ptr to the unscanned portion of the current input buffer
*	(if any)
*	and the number of unscanned characters in the buffer.
*
*	upon entry:
*	     x1 - virtual tib address
*	     x3 - points to 2 words (returned)
*
*	returns:
*	     x3 -> 1st: virtual ptr to first unscanned character of buffer
*		   2nd: tally        
*		   buffer page table entry set up
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	ldx2	t.sfcm,1	get virtual sfcm addr
	tsy	gettly-*	get current buffer addr & tally
	iaa	0	is there a buffer at all?
	tze	hgi020-*	no, done
	szn	sf.nic,2	any scanning done in this buffer?
	tze	hgi020-*	no, use as is
	sta	hgitly-*	save buffer tally temporarily
	cmpx3	sf.nic,2	scan pointer at beginning?
	tze	hgi010-*	yes, nothing new
	cx3a		convert current buffer pointer to word addr
	ana	l.r007-*	=o077777
	sta	hgibp-*	save
	lda	sf.nic,2	get scan pointer
	ana	l.r007-*	(=o077777) convert to word address
	sba	hgibp-*	number of words already scanned
	caq
	qls	1	convert to characters
	cx3a		started at odd character?
	cana	l.r008-*	=o100000
	tze	2	no
	iaq	-1	yes, one character less
	lda	sf.nic,2	stopped at odd character?
	cana	l.r008-*	=o100000
	tze	2	no
	iaq	1	yes, one character more
	ldx3	sf.nic,2	point to first unscanned char
	lda	hgitly-*	get original tally
	stq	hgitly-*	this is number already scanned
	sba	hgitly-*	result is number remaining
	tze	hgi010-*	none
	tpl	hgi020-*	negative would mean none
hgi010	ila	0	return zero tally
	cax3		and zero buffer address
hgi020	stx3	hgisx3-*,*	return buffer addr
	ldx3	hgisx3-*	restore x3
	sta	1,3	return tally
	rem
	return	hgeti
	rem
hgitly	bss	1
hgibp	bss	1
	ttls	gettly - get the addr and tally of the current input buffer
gettly	subr	gtl,(x2,inh)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	gettly
*
*	computes the tally of, i.e. the number of chars in,
*	the current input buffer.  if the buffer is active
*	(icw active), the tally is given by the difference
*	between the max buffer tally and the icw tally.
*	if not active, the tally is given by the tally
*	field of the buffer.
*
*	upon entry:
*	     x1 - virtual tib address
*
*	returns:
*	     x3 - points to first char. current buffer (or zero if none)
*	      a - contains buffer tally (or zero if none)
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	ldx2	t.sfcm,1	get virtual sfcm address
	lda	sf.flg,2	get sfcm flags
	ldq	sf.ib0,2	get primary buffer addr
	icana	sffcii	alt buffer in use
	tze	2	no
	ldq	sf.ib1,2	get alt buffer addr
	rem
	iaq	0	do we have a buffer ?
	tnz	gtl010-*	yes, continue
	ila	0	return zero tally
	cax3		return zero buffer addr
	tra	gtlret-*
	rem
gtl010	ldx3	sf.hcm,2	get hwcm addr
	iacx3	h.ric0	get primary rcv icw addr
	icana	sffcii	alt icw active ?
	tze	2	no
	iacx3	h.ric1-h.ric0	get alt rcv icw addr
	rem
	cqa		move buffer addr to a
	tsy	a.r001-*,*	setbpt
	ldq	1,3	get icw tally
	cax3		move (virtual) buffer addr to x3
	lda	sf.flg,2	synchronous line?
	cana	l.r004-*	=sffsyn
	tnz	gtl020-*	yes, regular buffer
	cx3a		no, point to second char. of block
	ada	l.r006-*	0,b.1
	cax3
	lda	-1,3,b.1	pick up size from first char.
	als	1	convert to chars (allow for ***two*** at end)
	iaa	-3	a now contains max. tally
	tra	gtl030-*
	rem
gtl020	null
	lda	bf.tly,3	get buffer tally word
	ana	l.r001-*	(=buftmk) leave only tally
	sta	gtltmp-*	hang on to max. tally
	cx3a		update pointer to first data char.
	ada	l.r005-*	=bf.dta,b.0
	cax3		back to x3
	lda	gtltmp-*	restore tally
	rem
gtl030	null
	qls	5	get rid of character addressing bits
	qrl	5
	cmpq	l.r002-*	(=010000) icw tally exhausted ?
	tze	gtlret-*	yes, done
	rem
	stq	gtltmp-*	put icw tally in temp
	sba	gtltmp-*	subtract from max buffer tally
	rem
gtlret	return	gettly
	rem
gtltmp	bss	1
	rem
a.r001	ind	setbpt
	rem
l.r001	vfd	18/buftmk
l.r002	oct	010000
l.r003	vfd	o18/777000
l.r004	vfd	18/sffsyn
l.r005	zero	bf.dta,b.0
l.r006	zero	0,b.1
l.r007	oct	077777
l.r008	oct	100000
	ttls	hcfg - entry point to change configuration of channel
hcfg	subr	cfg,(x1,x2,x3)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	hcfg
*
*	     entry to change to the configuration of the channel
*	the current config pcw (stored in the sfcm at sf.cfg) is
*	is modified according to the sub-op's in the config list
*	and a pcw type 2 is issued, the new current config pcw
*	is stored in the sfcm.
*
*	upon entry:
*	     x1 - virtual tib address
*	     x2 - points to first config sub-op
*
*	returns:
*	    x2 - points to opblock after sub-ops
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	ldx2	t.sfcm,1	get addr of sfcm
	ldaq	sf.cfg,2	get current config pcw
	staq	newcfg-*	newcfg will be modified
	ldx3	cfgsx2-*	get address of first sub-op
	rem
cfg010	null		start of sub-op decoding loop
	lda	0,3	pick up sub-op
	ana	l.r003-*	=777000
	cmpa	l.r003-*	is this opblock, not a sub-op
	tze	cfg070-*	yes, done
	ila	0	zero a
	ldq	0,3	get sub-op
	lls	3	isolate sub-op code in a
	qrl	3	right justify sub-op data
	icmpa	fg.bd	changing the baud rate?
	tze	cfg050-*	go process baud sub-op
	rem
	rem		mode sub-op (smode or rmode)
	rem		find specified entry in cfgtab
	llr	18	swap a and q
	rem		sub-op code is in q
	rem		sub-op data is in a
	sta	cfgsub-*
cfg019	ldx2	a.q001-*	get addr of config table (=cfgtab)
cfg020	cana	0,2	compare sub-op data with cfgtab entry
	tze	cfg041-*	tra if desired bit not set
	lda	0,2	bit that just matched
	era	l.q002-*	(=777777) invert all bits
	ansa	cfgsub-*	turn off in arg - this bit done
	rem
	szn	3,2	check for subr
	tze	2	skip if no subr
	tsy	3,2*	call subr (subr must maintain x1, x2,
	rem		x3, and q)
	rem
	lda	1,2	get first word of pcw mask
	cmpq	l.q001-*	check for rmode
	tnz	cfg030-*	transfer if smode
	rem
	rem		reset a mode bit
	era	l.q002-*	invert the bits
	ansa	newcfg-*	reset the bit
	lda	2,2	get 2nd word of mask
	era	l.q002-*
	ansa	newcfg-*+1
	tra	cfg040-*
	rem
cfg030	null		set a mode bit
	orsa	newcfg-*	set the bit in the new config pcw
	lda	2,2
	orsa	newcfg-*+1
	rem
cfg040	null
	lda	cfgsub-*
	tze	cfg060-*	all bits processed
	tra	cfg019-*	back to next bit
	rem
cfg041	iacx2	cfglen	next cfgtab entry
	cmpx2	a.q002-*	end of table?
	tnz	cfg020-*	nope, try again
	tra	cfg060-*	next config list entry
	rem
cfg050	null		change baud rate
	qls	0	baud rate given?
	tnz	2	yes
	ldq	t.cntr,1	if not in control table, it is here
	ldx2	a.q004-*	(=cfgbds) addr of baud table
cfg052	cmpq	0,2	does it match baud given
	tze	cfg051-*	yes
	iacx2	1	step to next entry
	cmpx2	a.q005-*	(cfgbds+cfgbdl) at end of table?
	tnz	cfg052-*	no
	die	2
	rem
cfg051	stz	cfgsvf-*	this will be setting of ebcdic bit in sfcm
	cmpq	bd133-*	setting to 133 baud?
	tnz	cfg053-*	no
	lda	l.q010-*	(=sffebd) ebcdic bit for sfcm
	sta	cfgsvf-*
cfg053	lda	l.q003-*	mask for pcw baud bits
	ansa	newcfg-*+1	turn off current bits
	lda	cfgflg-cfgbds,2	get pcw bits to set baud rate
	orsa	newcfg-*+1	and store in pcw
	stx2	cfgtmp-*	save baud table index
	ldx2	t.sfcm,1	get addr of sfcm from tib
	lda	l.q011-*	(=^sffebd)
	ansa	sf.flg,2	turn off ebcdic bit
	lda	cfgsvf-*	get new value
	orsa	sf.flg,2	and set it
	ldx2	sf.hsl,2	get hsla table addr from sfcm
	lda	l.q008-*	mask to turn off speed field
	ansa	ht.flg,2
	lda	cfgtmp-*	retreive baud table index
	sba	a.q004-*	get offset in table
	iaa	1	this gives final baud index
	orsa	ht.flg,2	save in hsla table
	rem
	rem		check that pcw is type 2
	lda	newcfg-*
	ana	l.q006-*	zero all but pcw type code
	cmpa	l.q007-*	check for right type
	tze	cfg060-*
	die	2
	rem
cfg060	null
	iacx3	1	next entry in config list
	tra	cfg010-*	go back for another entry
	rem
cfg070	stx3	cfgsx2-*	all done, return bumbed addr to caller
	ldx2	t.sfcm,1	get sfcm addr again
	rem
	ldaq	newcfg-*	get new config pcw
	staq	sf.cfg,2	save it in sfcm
	rem
	rem		now select channel and do cioc
	rem
	tsy	sndcfg-*
	return	hcfg	done
	rem
	even
newcfg	bss	2	(altrd) pcw temp for new config pcw
cfgsub	bss	1	(altrd) copy of sub-op data
cfgtmp	bss	1
cfgsvf	bss	1
	rem
a.q001	ind	cfgtab
a.q002	ind	cfgend
a.q003	ind	cioc
a.q004	ind	cfgbds
a.q005	ind	cfgbds+cfgbdl
	rem
l.q001	vfd	18/fg.rmd
l.q002	vfd	o18/777777
l.q003	vfd	o18/777400	mask to zero baud bits
l.q004	sel	*-*	template select instruction
l.q005	vfd	18/p.ssiw
l.q006	vfd	o18/600000
l.q007	vfd	o18/pcw.2
l.q008	vfd	o18//htfspd
l.q009	vfd	o18//p2.mbt
l.q010	vfd	o18/sffebd
l.q011	vfd	o18//sffebd
	rem
cfgbds	dec	75	tables of bauds that can be configured
	dec	110
bd133	dec	133
	dec	150
	dec	300
	dec	600
	dec	1050	shouldn't be here but dia_man understands
	dec	1200
	dec	1800
	dec	2400
	dec	4800
	dec	7200	filler to index into baud_rates properly
	dec	9600
cfgbdl	equ	*-cfgbds
	rem		pcw bits to set each baud
cfgflg	oct	021	  75 baud
	oct	200	 110 baud
	oct	100	 133 baud
	oct	040	 150 baud
	oct	020	 300 baud
	oct	161	 600 baud
	oct	010	1050 baud
	oct	004	1200 baud
	oct	002	1800 baud
	oct	301	2400 baud
	oct	321	4800 baud
	oct	000	7200 baud (for indexing into baud_rates)
	oct	341	9600 baud
	rem
	ttls	config mode bits lookup table
cfgtab	null
	cfgtab	fg.icw,p2.icw,0,cfgicw icw bit is in first word of pcw
	cfgtab	fg.lpr,p2.lpr,0,0
	cfgtab	fg.lps,p2.lps,0,0
	cfgtab	fg.lpo,p2.lpo,0,0
	cfgtab	fg.5bt,p2.5bt,0,cfgrsc
	cfgtab	fg.6bt,p2.6bt,0,cfgrsc
	cfgtab	fg.7bt,p2.7bt,0,cfgrsc
	cfgtab	fg.8bt,p2.8bt,0,cfgrsc
	cfgtab	fg.beb,0,p3.beb,0
	cfgtab	fg.btr,0,p3.btr,0
	cfgtab	fg.cct,p2.cct,0,0
cfgend	equ	*
	rem
cfglen	equ	4
	rem
cfgicw	subr	icw
	rem
	rem	this subroutine is called when the number
	rem	of send icw's is being changed.
	rem	we always make sure that the channel is set to
	rem	use the primary send icw.
	rem
	lda	sf.flg,2	get tib flags
	icana	sffcoi	are we currently using alternate?
	tze	icwbak-*	transfer if not
	rem
	lda	l.q005-*	switch send icw pcw op-code
	tsy	a.q003-*,*	(=cioc) do a connect
icwbak	null
	return	cfgicw	done
	rem
*	subroutine to turn off the character size field in the pcw
	rem
cfgrsc	subr	rsc
	lda	l.q009-*	(=^p2.mbt)
	ansa	newcfg-*
	return	cfgrsc
	rem
*	subroutine to send the config pcw
	rem
sndcfg	subr	snd,(x1,x2,x3)
	lda	t.line,1	get line no
	ars	6
	iana	7	turn off "is_hsla" bit
	iaa	h1ch	add in base hsla chan no to
	rem		get iom chan no 6, 7, or 8
	ora	l.q004-*	(=sel 0) or in sel instruction
	sta	1	make a the next instruction
	sel	*-*	(patched) select correct channel
	rem
	ldx3	sf.hsl,2	get pointer to hsla table entry
	ldx3	ht.tib,3	get real tib address for trace
	trace	tt.pcw,ts.pcw,(x3,newcfg,newcfg+1)
	rem
	cioc	sf.cfg,2	hit the channel with the pcw
	return	sndcfg
	ttls	hmode - entry point to change modes
hmode	subr	mod,(x1,x2,x3)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	hmode
*
*	     entry to notify us that certain mode bits
*	have been changed, including those having to do
*	with echoing, flow control, or parity.
*
*	upon entry:
*	     x1 - virtual tib address
*
*	returns:
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	ldx2	t.sfcm,1	get virtual sfcm address
	tze	modret-*	no sfcm, forget it
	lda	sf.flg,2	check for ebcd type
	cana	l.p013-*	=sffebd
	tnz	2	don't touch cct if it is
	tsy	a.p001-*,*	=makcct, select proper cct
	rem
	lda	t.flg2,1	find out if entered or left framei
	ana	l.p001-*	isolate tffrmi
	era	sf.flg,2	compare it against sffofr (same bit position)
	ana	l.p001-*	isolate relevant bit
	tze	mod010-*	not changed
	ersa	sf.flg,2	it is, change it in sfcm
	lda	l.p006-*	=sffnib
	orsa	sf.flg,2	we'll need a new input buffer
	rem
	lda	t.flg2,1	get tib flags
	cana	l.p001-*	(=tffrmi) frame input mode ?
	tnz	mod010-*	yes
	lda	l.p005-*	(=/tffip) cannot be frame in progress
	ansa	t.flg2,1	so turn off tffip
	rem
mod010	lda	t.flg2,1	check for input flow control
	cana	l.p007-*	=tfifc
	tze	mod020-*	no
	lda	l.p006-*	=sffnib
	orsa	sf.flg,2	yes, we'll need a new input buffer
mod020	lda	l.p012-*	p2.lps, on initially
	sta	tstcfg-*	we're going to see if we have to
	lda	t.flg3,1	change parity configuration
	ana	l.p008-*	tfoddp
	arl	lposhf	line it up on p2.lpo
	orsa	tstcfg-*	if on in tib, on in pcw
	lda	t.flg3,1	get flags again
	ana	l.p009-*	=tf8out
	arl	lpsshf	line it up on p2.lps
	ersa	tstcfg-*	on in tib => off in pcw, and vice versa
	lda	sf.cfg,2
	ana	l.p010-*	p2.lpo+p2.lps
	cmpa	tstcfg-*	have we changed either of these bits?
	tze	mod030-*	no, don't bother with new pcw
	lda	l.p011-*	^(p2.lpo+p2.lps)
	ansa	sf.cfg,2	turn them off so we can start clean
	lda	tstcfg-*	get new values
	orsa	sf.cfg,2
	tsy	sndcfg-*	now set the pcw
	rem
mod030	lda	t.flg2,1	check if we left oflow with output suspended
	cana	l.p020-*	=tfofc
	tnz	mod040-*	mode is on, never mind
	lda	t.flg,1	is output suspended now?
	cana	l.p021-*	=tfosus
	tze	mod040-*	no, no problem
	tsy	a.p012-*,*	(resout) yes, resume it
	rem
mod040	lda	t.flg,1	get the tib flags
	cana	l.p002-*	(=tfcrec+lfec+tbec+ecpx) any echoing modes on?
	tze	modret-*
	rem
	szn	t.echo,1	is there an echo buffer?
	tnz	modret-*	yes, done
	rem
	ilq	bufsiz	allocate a buffer
	tsy	a.p002-*,*	(=getbfh)
	tra	modret-*	if couldn't get it, tough
	rem
	sta	t.echo,1	set absolute ptr to echo buffer
	cx3a		put virtual addr into a
	ada	l.p003-*	(=eb.dta,b.1) make ptr to data
	sta	eb.inp,3	set in ptr
	sta	eb.otp,3	set out ptr
	stz	eb.tly,3	zero the tallytoo
	rem
modret	return	hmode
	rem
tstcfg	bss	1	place for temporary parity bits
	rem
a.p001	ind	makcct
a.p002	ind	getbfh
a.p003	ind	denq
a.p004	ind	maskr	restart wait block in control_tables
a.p005	ind	cioc
a.p006	ind	frelbf
a.p007	ind	frebuf
a.p008	ind	setbpt
a.p009	ind	fribuf
a.p010	ind	fremem
a.p011	ind	itest
a.p012	ind	resout
	rem
l.p001	vfd	18/tffrmi
l.p002	vfd	18/tfcrec+tflfec+tftbec+tfecpx
l.p003	ind	eb.dta,b.1
l.p004	vfd	18/tfecpx
l.p005	vfd	o18//tffip
l.p006	vfd	18/sffnib
l.p007	vfd	18/tfifc
l.p008	vfd	18/tfoddp
l.p009	vfd	18/tf8out
l.p010	vfd	18/p2.lpo+p2.lps
l.p011	vfd	o18//p2.lpo*/p2.lps
l.p012	vfd	18/p2.lps
l.p013	vfd	18/sffebd
l.p014	vfd	o18//tflisn
l.p015	vfd	18/tfmask
l.p016	vfd	18/p.rmsk
l.p017	vfd	18/sffsct+sffebd+sffdct+sffcii+sffcoi
l.p018	vfd	18/sffbsc+sffsyn+sffhdl
l.p019	oct	010000	icw exhaust bit
l.p020	vfd	18/tfofc
l.p021	vfd	18/tfosus
	ttls	subroutines for masking/unmasking channel
	rem
	rem	mskchn is called by the status processor when it discovers
	rem	that the interrupt handler masked a channel because of
	rem	excessive interrupts. its job is to report this to the
	rem	host (via denq), set a flag in the tib, and force the
	rem	channel to its starting point in the control tables. the
	rem	channel should remain dormant until the host sends a new
	rem	listen order.
	rem
	rem	x1 contains virtual tib address as usual
	rem	x2 contains virtual sfcm address
	rem
mskchn	subr	msk,(x3)
	ilq	linmsk
	tsy	a.p003-*,*	denq
	lda	l.p014-*	=^tflisn
	ansa	t.flg,1	force listen flag off
	lda	l.p015-*	=tfmask
	orsa	t.flg3,1	and masked flag on
	rem		now clear out all buffers (except t.dcp,
	rem		which is dia_man's problem)
	stz	mocur-*	initialize ocur flag
	lda	t.ocp,1
	tze	msk010-*
msk005	cmpa	t.ocur,1	is t.ocur included in t.ocp?
	tze	msk007-*	yes
	tsy	a.p008-*,*	(setbpt) not this one, look at next
	cax3
	lda	bf.nxt,3	pointer to next buffer
	tnz	msk005-*	if any
	tra	msk008-*	else no match, proceed
msk007	aos	mocur-*	set flag to indicate overlap
msk008	lda	t.ocp,1	get original pointer back
	tsy	a.p006-*,*	frelbf
msk010	lda	t.ocur,1
	tze	msk020-*
	szn	mocur-*	was t.ocur chain subset of t.ocp chain?
	tnz	msk015-*	yes, it's already been freed
	tsy	a.p006-*,*	frelbf
msk015	stz	t.ocur,1
msk020	stz	t.ocp,1
	stz	sf.ob0,2
	stz	sf.ob1,2
	stz	t.ocnt,1	all output buffers flushed now
	lda	t.icp,1
	tze	msk050-*
	tsy	a.p006-*,*	frelbf
	stz	t.icp,1
	stz	t.icpl,1
msk050	lda	sf.ib0,2
	tze	msk060-*
	tsy	a.p008-*,*	(setbpt) fribuf wants virtual address
	cax3		in x3
	tsy	a.p009-*,*	fribuf
	stz	sf.ib0,2
msk060	lda	sf.ib1,2
	tze	msk070-*
	tsy	a.p008-*,*	(setbpt) fribuf wants virtual address
	cax3		in x3
	tsy	a.p009-*,*	fribuf
	stz	sf.ib1,2
msk070	null		buffers all gone, wipe out temporary sfcm flags
	lda	l.p017-*	sfcm flags that should stay around
	ora	l.p018-*	and more of the same
	ansa	sf.flg,2	turning off any others that are on
	ldx3	sf.hcm,2	ruin all icws
	ila	0
	ldq	l.p019-*	=010000, exhaust bit
	staq	h.ric0,3
	staq	h.ric1,3
	staq	h.sic0,3
	staq	h.sic1,3
	stz	sf.nic,2	don't keep old character pointers
	rem
	lda	t.type,1	ascii or other?
	icmpa	ttasci
	tnz	msk075-*	non-ascii, check for tib extension
	lda	t.rcp,1	else check for replay chain
	tze	msk080-*	none, we're finished
	tsy	a.p006-*,*	(frelbf) free it
	stz	t.rcp,1	not there any more
	tra	msk080-*	done now
	rem
msk075	ldx3	t.elnk,1	get address of tib extension to free it
	tze	msk080-*	none, do nothing
	stz	t.elnk,1	no longer has ext
	ldq	0,3	length
	iaq	1	plus control word
	tsy	a.p010-*,*	=fremem
	rem
msk080	stz	t.reta,1
	lda	a.p004-*	address of restarting op block
	sta	t.cur,1	make channel start there next time
	tsy	a.p011-*,*	(itest) poke it so it goes to right tables
	return	mskchn
	rem
	rem
	rem
	rem	hunmsk is called by dia_man when a listen order is
	rem	received for a channel with tfmask on (i.e., that has
	rem	previously been masked). it resets the various masked bits,
	rem	re-establishes the sfcm status queue pointers, and unmasks
	rem	the channel.
	rem
	rem
hunmsk	subr	unm,(inh,x2)
	ldx2	t.sfcm,1	we'll need the sfcm
	lda	sf.pcw,2
	icana	pb.msk	did we mask it, in fact?
	tze	unm010-*	no
	cx2a		get (virtual) address of
	iaa	sf.waq	software status queue
	sta	sf.nxp,2	and store it
	sta	sf.nxa,2	in sfcm
	lda	sf.ssl,2	get length of queue
	sta	sf.tly,2	initialize this too
	stz	sf.pcw,2	clear out the "masked" bit
	lda	l.p016-*	(=p.rmsk) get "reset mask" opcode
	tsy	a.p005-*,*	cioc
unm010	lda	l.p015-*	=tfmask
	iera	-1	complement tib "masked" bit
	ansa	t.flg3,1	so as to turn it off
	return	hunmsk
	rem
	rem
	rem
mocur	bss	1	indicator for whether t.ocp and t.ocur
	rem		chains overlap
	ttls	cioc - connect subroutine
cioc	subr	cio,(x1,x2,x3,inh)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	cioc
*
*	     subroutine to perform a connect to a hsla
*	subchannel. a pcw type 1 is issued with the pcw
*	broadside bits in the sfcm.
*
*	upon entry:
*	     a  - contains pcw op-code to use
*	     x1 - virtual tib address
*
*	returns:
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	sta	ciopcw-*	save the pcw op-code
	lda	l.c006-*	(=pcw.1) get command type code
	orsa	ciopcw-*	and put it into pcw
	lda	t.line,1	get the line number
	iana	31	(=o37) leave just subch number
	als	6	position it for pcw
	orsa	ciopcw-*	put into pcw
	rem
	ldx2	t.sfcm,1	get ptr to sfcm
	lda	sf.pcw,2	get pcw broadside bits
	sta	ciopcw+1-*	put them into pcw, too
	rem
	rem	pcw model setup, select chan and do cioc
	rem
	lda	t.line,1	get line no again
	ars	6
	iana	7	turn off "is_hsla" bit
	iaa	h1ch	add in base hsla chan no
	rem		to get iom chan no 6, 7 or 8
	ora	l.c007-*	(=sel 0) or in select instruction
	sta	1	put it down to execute
	sel	0	(patched) select the right chan
	rem
	ldx3	sf.hsl,2	get pointer to hsla table entry
	ldx3	ht.tib,3	get real tib address for trace
	trace	tt.pcw,ts.pcw,(x3,ciopcw,ciopcw+1)
	rem
	cioc	ciopcw-*	hit channel with pcw
	return	cioc
	even
ciopcw	bss	2	(altrd) pcw temp for cioc
	ttls	seticw - setup the output icw's
seticw	subr	sic,(x1,x2,x3)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	seticw
*
*	     seticw setups the output icw's for the
*	buffer chain pointed to by t.ocur. it assumes no
*	active output icw and stores into both.
*
*	upon entry:
*	     x1 - virtual tib address
*
*	returns:
*	     both output icw's setup
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	ldx2	t.sfcm,1	get addr of sfcm
	ldx3	sf.hcm,2	get addr of hwcm region
	rem
	iacx3	h.sic0	add in offset
	stx3	sicicw-*	save it away
	ldx3	t.sfcm,1	get ptr to sfcm
	iacx3	sf.ob0	add in other offset
	stx3	sicobp-*	save it also
	rem
	lda	sf.flg,2	get sfcm flag word
	icana	sffcoi	which icw is active?
	tze	sic010-*	primary, use it first
	rem
	ila	h.sic1-h.sic0	get difference
	asa	sicicw-*	update ind word
	ila	sf.ob1-sf.ob0	get other difference
	asa	sicobp-*	save it also
	rem
sic010	lda	t.ocur,1	pick up ptr to next output buffer
	sta	sicobp-*,*	put into the sfcm
	tsy	a.c005-*,*	setbpt
	cax3		get virtual address
	stx3	sicbuf-*	hang on to it
sic020	cx3a		get ptr into the a
	tze	sicret-*	no buffer
	iaa	bf.dta	get offset of data
	ora	l.c005-*	(=0,b.0) or in the character  addressing
	caq		hide it away
	rem
	lda	bf.tly,3	get the buffer tally
	ana	l.c001-*	(=buftmk) isolate the tally
	llr	18	switch a and q
	stx3	settmp-*
	ldx3	sicicw-*	get ptr to icw words
	tsy	a.c006-*,*	(bldicw) set up icw
	rem
	ldx3	settmp-*	get the buffer addr again
	tsy	a.c002-*,*	(=oscan) scan the buffer
	rem
	tsy	a.c001-*,*	(=outpar) output parity for ebcdic
	rem
sic030	lda	bf.flg,3	get buffer flag bits
	cana	l.c002-*	(=bfflst) last buffer in msg?
	tnz	sic050-*	yes, pretty much done
	rem
	szn	bf.nxt,3	is there any more chain?
	tze	sicret-*	nope, all done here
	rem
	ila	sfhmk	get mask to switch icw ptr
	ersa	sicicw-*
	ila	sfbfmk	get mask to switch buffer ptrs
	ersa	sicobp-*
	rem
	lda	bf.nxt,3	get addr of next guy in chain
	sta	sicobp-*,*	and into sfcm
	tsy	a.c005-*,*	(setbpt) get virtual address
	cax3		we'll need it in x3 too
	iaa	bf.dta	get offset of data
	ora	l.c005-*	(=0,b.0) or in char addressing bits
	caq		hang on to address
	rem
	lda	bf.tly,3	get the tally
	ana	l.c001-*	(=buftmk) isolate tally
	llr	18	switch a and q
	ldx3	sicicw-*	get ptr to icw
	tsy	a.c006-*,*	(bldicw) put into icw
	rem
	lda	t.ocur,1	get ptr to first buffer
	tsy	a.c005-*,*	setbpt
	cax3
	lda	bf.nxt,3	get next buffer addr
	tsy	a.c005-*,*	setbpt
	cax3
	tsy	a.c002-*,*	(=oscan) scan the buffer
	tsy	a.c001-*,*	(=outpar) output parity for ebcdic
	rem
	lda	bf.flg,3	get buffer flags
	cana	l.c002-*	(=bfflst) last buffer ?
	tze	sicret-*	no
	rem
sic050	lda	l.c010-*	(=sffhdl) is it HDLC?
	cana	sf.flg,2
	tze	sicret-*	no
	lda	l.c008-*	(=tsftre) get tally runout enable bit
	orsa	t.stat,1	turn it on in tib status
	rem
	rem
sicret	return	seticw
	rem
	rem
sicicw	bss	1	(altrd) icw ptr
sicobp	bss	1	(altrd) sf.ob0/1 ptr
oddchr	bss	1
settmp	bss	1
sicbuf	bss	1	virtual pointer to current buffer
sicnoc	bss	1	local address of next output character
	rem
l.c001	vfd	18/buftmk
l.c002	vfd	18/bfflst
*l.c003		unused
*l.c004		unused
l.c005	ind	0,b.0
l.c006	vfd	18/pcw.1	pcw type 1
l.c007	sel	0	select instruction
l.c008	vfd	18/tsftre
l.c009	vfd	o18//tfwrit
l.c010	vfd	18/sffhdl
	rem
a.c001	ind	outpar
a.c002	ind	oscan
a.c003	ind	freout
a.c004	ind	g3wjt
a.c005	ind	setbpt
a.c006	ind	bldicw
	ttls	hintr - hsla interrupt handler
hintr	null
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	hintr
*
*	     this routine handles interrupts for all of
*	the hsla subchannels, and takes status from the
*	hardware status buffer and queues it for process-
*	ing by the scheduled status processor, hstprc. hstprc
*	will be scheduled to process the status queue if it is
*	not already scheduled.
*
*	upon entry:
*	     a call to g3jwt will return the third word of
*	     the jump table, as follows:
*
*		bits 0-3    iom channel number        
*		bits 4-5    hsla number(1-3)        
*		bits 6-10   subchannel number(0-31)        
*		bits 11-17  module number of hsla_man        
*
*	returns:
*	     entries queued for hstprc
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	tsy	a.c004-*,*	(=g3jwt) get third word of jump table
	stq	intjtw-*	save the result
	rem
	trace	tt.int,ts.int,(intjtw)
	ldq	intjtw-*
	cqa		put copy into the a
	ars	12	shift down to get hsla number
	iana	3	leave only the hsla number
	iaa	-1	subtract one to get 0-2
	ora	l.d001-*	(=000010) turn on is_hsla bit
	als	6	shift back into proper position
	sta	intlno-*	save as part of line number
	rem
	cqa		get another copy
	ars	7	shift down subchannel number
	iana	31	leave only subchan number
	orsa	intlno-*	put into line number
	rem
	lda	intlno-*	pick it up for call
	tsy	a.d005-*,*	(=gettib) get the tib addr
	iaa	0	set the indicators
	tze	intret-*	no tib, ignore interrupt
	rem
	sta	intrtb-*	save real tib address for dspqur
	tsy	a.d010-*,*	(setptw) virtualize real tib address
	sta	intvtb-*	save for easy reference
	cax1		put virtual tib address into x1
	ldx2	t.sfcm,1	get the virtual sfcm address
	tnz	2	should be non-zero
	die	10	nope, die
	rem
	lda	sf.ssl,2	figure out current number of pending status
	sba	sf.tly,2	to meter it
	sta	intcnt-*
	cmeter	mupdat,m.nst,intcnt-*
	rem
	stz	inthqf-*	clear status exhaust indicator
	stz	intsqo-*	clear status queue overflow switch
	ila	hpri	get basic priority
	sta	intskd-*	set in sked words
	rem
	ldx3	sf.hcm,2	get hardware comm region address
	lda	h.aicw+1,3 get second word of status icw
	cana	l.d002-*	is it exhausted?
	tze	int002-*	no
	aos	inthqf-*	indicate that is so for later
	rem
int002	lda	t.sfcm,1	get address of sfcm
	iaa	sf.sta	add in the queue offset
	sta	intcrp-*	first status if primary
	rem
	lda	sf.flg,2	get sfcm flag word
	cana	l.d019-*	(=sffcai) is hardware alt buffer being used
	tnz	int004-*	yes
	rem
	lda	l.d019-*	(=sffcai) or in alt hardware status
	orsa	sf.flg,2
	lda	intcrp-*	get back address of status queu
	iaa	sf.shq-sf.sta add in the difference
	tra	int006-*
	rem
int004	lda	l.d020-*	(=^sffcai)
	ansa	sf.flg,2	turn off alt indicator
	ldq	intcrp-*	get current position
	ila	sf.shq-sf.sta delta of hardware queue
	asa	intcrp-*	adjust first status pointer
	cqa		get back orginal address for status
	rem
int006	sta	intvir-*	temporarily save virtual address
	tsy	a.d007-*,*	(cvabs) get absolute address for icw
	ldq	intsai-*	second word of status icw
int007	staq	h.aicw,3	store icw now
	nop		buy some time
	cmpa	h.aicw,3	see if we change it
	tze	int008-*	yes all done
	ldx3	intvir-*	set to point to first status of this queue
	szn	0,3	set indicators
	tnz	int008-*	new status all done
	ldx3	sf.hcm,2	get hcm address
	tra	int007-*	try again
	rem
int008	lda	intcrp-*	get first status to process
	iaa	sfhsiz*2+2 calc end of queue
	sta	intend-*	for later processing
	ldx3	intcrp-*	set to point to first status
	rem
	lda	sf.flg,2	get sfcm flags
	icana	sffisc	inactive subchannel?
	tnz	int050-*	yes, get out of here
	rem
int010	lda	0,3	is this status word zero?
	tze	int050-*	yes, all done
	cana	l.d010-*	(=hs.rcs) rcv status ?
	tze	int014-*	no
	rem
	cana	l.d004-*	(=hs.tro) tally runout ?
	tze	int011-*	no
	rem
	rem		tally runout means we just dropped out of
	rem		rcv mode.  make sure we stay out.
	rem
	lda	l.d011-*	(=/pb.rcv)
	ansa	sf.pcw,2	turn off pcw rcv bit
	tra	int020-*
	rem
int011	cana	l.d007-*	(=hs.siw) switching icw ?
	tze	int020-*	no, continue
	rem
	stx3	intcrp-*	save status queue addr
	caq		put status word in q
	rem
	ldx3	sf.hcm,2	get hwcm addr
	iacx3	h.ric0	get primary rcv icw addr
	cana	l.d008-*	(=hs.aiw) alt icw active ?
	tze	2	no
	iacx3	h.ric1-h.ric0	get alt rcv icw addr
	rem
	lda	1,3	get icw tally
	ana	l.d009-*	(=007777) leave only tally
	sta	inttly-*	save it
	rem
	lda	l.d018-*	(=410000) get exhausted tally
	sta	1,3	put it in icw
	rem
	lda	sf.flg,2	synchronous?
	cana	l.d005-*	=sffsyn
	tnz	int012-*	yes
	cqa		no, get first word of status again
	tra	int013-*	skip tally manipulation
int012	cqa		get status back in a
	ldx3	sf.ib0,2	get primary buffer addr
	cana	l.d008-*	(=hs.aiw) alt. icw active ?
	tze	2	no
	ldx3	sf.ib1,2	get alt buffer addr
	cx3a		virtualize it
	tsy	a.d001-*,*	setbpt
	cax3
	rem
	ldq	bf.tly,3	get max buffer tally
	sbq	inttly-*	subtract icw tally
	stq	bf.tly,3	put actual tally in buffer
	rem
int013	ldx3	intcrp-*	restore status queue addr
	rem
int014	cana	l.d007-*	(=hs.siw) switching icw ?
	tze	int020-*	no, process status at normal priority
	rem
*	lda	sf.flg,2	get sfcm flags
*	cana	l.d005-*	synchronous line ?
*	tze	int015-*	no, use priority 3
*	rem
*	ldx2	sf.hsl,2	get address of hsla table
*	lda	ht.flg,2	pick up word with speed
*	ldx2	t.sfcm,1	restore x2
*	iana	htfspd	leave only the channel speed
*	icmpa	8	is it more than 9600 baud?
*	tmi	int015-*	no, use priority 3
*	rem
*	ila	hprip2	use real high priority
*	tra	2
	rem
int015	ila	hprip3	get priority 3 for sked
	sta	intskd-*	reset scheduler priority
	rem
	lda	l.d014-*	=sffmsp
	iera	-1	if switching icws, turn it off
	ansa	sf.flg,2
	rem
int020	szn	sf.tly,2	any room in status queue?
	tnz	int025-*	yes, continue
	rem
	szn	intsqo-*	status overflow occurred already ?
	tnz	int024-*	yes, skip it
	rem
	tsy	a.d015-*,*	handle status queue overflow
	aos	intsqo-*	remember it
	rem
int024	stz	0,3	zero the ignored status
	tra	int030-*	leave here
	rem
int025	lda	sf.flg,2	synchronous?
	cana	l.d005-*	=sffsyn
	tnz	int028-*	yes, skip the marker test
	lda	0,3	get first word of status
	cana	l.d013-*	(=hs.nms) marker status?
	tze	int028-*	nope
	lda	sf.flg,2	yes, is one already pending
	cana	l.d014-*	(=sffmsp)
	tze	int027-*	no, we'll have to store this one
	lda	0,3	(get first word of status back)
	cana	l.d015-*	yes, but are there any other interesting ones?
	tnz	int027-*	yep
	stz	0,3	ignore this status
	tra	int040-*
	rem
int027	lda	0,3	get first word of status again
	cana	l.d007-*	(=hs.siw) switching icws?
	tnz	int028-*	then don't set flag
	lda	l.d014-*	=sffmsp
	orsa	sf.flg,2	turn it on
int028	null
	ldaq	0,3	get the current status words
	staq	sf.nxa,2*	put into the software queue
	stz	0,3	zero the current status
	rem
	cana	l.d007-*	*is it hs.siw for switching
	tze	int28a-*	*no continue
	cana	l.d010-*	*is it hs.rcv recieve only
	tze	int28a-*	*no again
	lda	sf.flg,2
	cana	l.d017-*	*(sffhdl+sffbsc) is it bsc or HDLC?
	tze	int28a-*	no
	tsy	a.d014-*,*	*(swphic) switch buffer now
	rem
int28a	ila	-1	decrement the tally
	asa	sf.tly,2
	ila	4	increment the next available
	asa	sf.nxa,2	pointer
	rem
	lda	sf.ssl,2	get length of status queue
	als	2	in words
	sta	intsql-*
	cx2a		put sfcm ptr into a
	iaa	sf.waq
	ada	intsql-*	get ptr to end of status queue
	cmpa	sf.nxa,2	are we at end of queue?
	tnz	int030-*	nope, continue
	rem
	cx2a		copy sfcm ptr to a
	iaa	sf.waq	get ptr to beginning of queue
	sta	sf.nxa,2	put into q ptr, wrapping q
	rem
int030	lda	sf.flg,2	get the sfcm flags
	icana	sffskd	is the status processor scheduled?
	tnz	int040-*	yes, continue
	rem
	ila	sffskd	get flag bit
	orsa	sf.flg,2	turn it on now
	rem
	ldx1	intrtb-*	get real tib address for dspqur
	ldaq	intskd-*	(queue element)
	tsy	a.d002-*,*	(=dspqur) queue hstprc to process status
	rem		note: x1 contains real tib address
	ldx1	intvtb-*	restore virtual tib address to x1
	rem
int040	iacx3	2	bump to next status
	cmpx3	intend-*	are we at end of buffer?
	tnz	int010-*	no, continue
	rem
int050	szn	intsqo-*	did we overflow?
	tnz	int060-*	yes and we process it
	szn	inthqf-*	hardware overflow?
	tze	int060-*	no
	rem
	cmeter	mincs,m.hsqo,l.d016-*
	rem
	tsy	sqovfl-*	handle status queue overflow
	aos	intsqo-*	now process hardware the same as software
	rem
int060	null
int070	szn	intsqo-*	did we get another status queue overflow?
	tze	intret-*	no, all is well
	rem
	aos	sf.rct,2	bump the repeat count
	lda	sf.rct,2	get the new value
	icmpa	20	compare to some random number
	tmi	intret-*	no there yet, let channel run a bit more
	rem
	ldx2	t.sfcm,1	reset sfcm ptr
	ila	pb.msk	set software "mask" bit
	sta	sf.pcw,2	in pcw, and zero other bits (like dtr!!)
	lda	l.d003-*	(=p.msk) get mask op
	tsy	a.d009-*,*	(=cioc) connect to channel
	rem
intret	tra	a.d004-*,*	(=mdisp) return to master dispatcher
	rem
	rem
intcnt	bss	1	used for count of pending status
intjtw	bss	1	(altrd) 3rd word of jump table
inthqf	bss	1	hardware queue overflow
intend	bss	1	(altrd) end of hardware status buffer
intcrp	bss	1	(altrd) current hardware status ptr
intrtb	bss	1	save for real tib address
intvtb	bss	1	save for virtual tib address
intsql	bss	1	length of software status queue
intvir	bss	1	virtual address of head of hardware status queue
	rem
	even
intskd	zero	hpri	priority of hstprc
	ind	hstprc	routine to be run
intsai	amicwo	w.2,sfhsiz,0
	rem
	rem	following two words must be together for error message
interr	dec	4	error code
intlno	bss	1	(altrd) line number - tib type
	rem
intsqo	bss	1
inttly	bss	1
	rem
	rem
l.d001	vfd	o18/000010	is_hsla bit
l.d002	vfd	o18/010000
l.d003	vfd	18/p.msk
l.d004	vfd	18/hs.tro
l.d005	vfd	18/sffsyn
l.d006	oct	000130,000110
l.d007	vfd	18/hs.siw
l.d008	vfd	18/hs.aiw
l.d009	oct	007777
l.d010	vfd	18/hs.rcs
l.d011	vfd	o18//pb.rcv
l.d012	vfd	18/sffsqo
l.d013	vfd	18/hs.nms
l.d014	vfd	18/sffmsp
l.d015	vfd	18/hs.siw+hs.ptr+hs.tro+hs.dss
l.d016	dec	1
l.d017	vfd	18/sffhdl+sffbsc
l.d018	oct	410000	exhausted icw with 18-bit addressing on
l.d019	vfd	18/sffcai	altenate status buffer
l.d020	vfd	o18//sffcai and mask for turning off alt status
	rem
a.d001	ind	setbpt
a.d002	ind	dspqur
a.d003	ind	0,w.2
a.d004	ind	mdisp
a.d005	ind	gettib
a.d006	ind	.crpte	pointer to variable cpu page table word
a.d007	ind	cvabs
*a.d008	unused
a.d009	ind	cioc
a.d010	ind	setptw	set up page table word
a.d011	ind	stpcnt
a.d012	ind	stpret
a.d013	ind	stpswd
a.d014	ind	swphic
a.d015	ind	sqovfl
	ttls	preallocated buffer tables
	rem
	rem	preallocated chain table
	rem	a pointer to the preallocated buffer pool.
	rem
pchtbl	oct	000000
	oct	000000
	oct	000000
	oct	000000
	oct	000000
	oct	000000
	oct	000000
	oct	000000
	rem
	rem	preallocated chain left table
	rem	the number of buffers in the preallocated chain
	rem
pchlft	oct	000000
	oct	000000
	oct	000000
	oct	000000
	oct	000000
	oct	000000
	oct	000000
	oct	000000
	rem
	rem	preallocated buffer max count table
	rem
pbfmax	oct	000000
	oct	000000
	oct	000000
	oct	000000
	oct	000000
	oct	000000
	oct	000000
	oct	000000
	ttls	albchs - allocate buffer check
******************************************************************************
*
*	albchs - alocate buffer check
*
*	This will check and allocate the preallocated buffer
*	chains for any high speed sync lines.
*	If no buffer can be allocated,
*	the icw switching code will handle it when the time comes
*	as an exhaust condition.
*	Coded for switching icw problem by
*		D. W. Cousins on March 24, 1981
*
*****************************************************************************
albchs	subr	alb,(a,q,x1,x2,x3)
	ila	0	*set up index for table
	cax2
alb010	icmpa	8	*is it max yet
	tze	albret-*	*finish
	lda	a.w003-*,*	*(pbfmax,2) get max buffer for this line
	tze	alb040-*	*if zero no allocate
	sta	pamax-*	*store it temp for compare
alb020	lda	a.w002-*,*	*(pchlft,2) number of buffer left
	cmpa	pamax-*	*compare number left to max
	tze	alb040-*	*already full
	tpl	alb040-*	*that all for now
	cx2a		*calc the bufer size
	iaa	1
	als	5
	caq		*put it in q for getubf
	tsy	a.w004-*,*	*=getubf
	tra	alb030-*	*error no buffer
	sta	albabs-*	save absolute address
	lda	bf.siz,3	*get it real size
	arl	15
	als	bufshf+1
	iaa	hbfnch
	orsa	bf.tly,3
	ldx3	albabs-*	get absolute address again
	tsy	adtopa-*	*add it to the chain
	rem
	smeter	mincd,.mbfpa,l.w002-*
	rem
	tra	alb020-*	*go again
alb030	null		*allocation failed it ok now
alb040	iacx2	1	*inc the counter for next buffer
	cx2a		*get it to a for max test
	tra	alb010-*	*check again
albret	return	albchs
	rem
pamax	bss	1
albabs	bss	1
	rem
a.w001	ind	pchtbl,2	prellocated buffer chain
a.w002	ind	pchlft,2	number of buffer left in chain
a.w003	ind	pbfmax,2	max number of buffer in a chain
a.w004	ind	getbfh	get user buffer
a.w005	ind	frebfh	free buffer
a.w006	ind	setbpt	virtualize buffer address
	rem
l.w001	vfd	18/sffhdl+sffbsc
l.w002	dec	1
	ttls	adtopa - add to preallocated chain
***********************************************************************
*	adtopa - add to preallocated chain
*
*	This inhibited code adds a buffer to the
*	preallocated chain for a particular buffer size.
*
*	   x2 contains offset into buffer-size tables for the
*		given size.
*
*	This is to help icw switching problem
*	coded by D. W. Cousins on March 24, 1981
*
*********************************************************************
adtopa	subr	adt,(x1,inh)
	lda	a.w001-*,*	(pchtbl,2) get head of chain
	tze	adt020-*	*may be finish
adt010	tsy	a.w006-*,*	setbpt
	cax1		*ok we got the virtual address
	lda	bf.nxt,1	*get the next address
	tze	adt030-*	*good we arrive
	tra	adt010-*	*again
adt020	stx3	a.w001-*,*	*(pchtbl,2) store the address at the head
	tra	adt040-*	*all done
adt030	stx3	bf.nxt,1	*store it in the buffer
adt040	aos	a.w002-*,*	*(pchlft,2) add one to number of buffer in chain
	return	adtopa	*all done
	ttls	dumsbf - dump store buffer
*******************************************************************
*
*	dumsbf - dump store buffer
*
*	icw switching stored the buffer address with the software
*	status in the sfcm for bsc and hdlc channels. This will dump it.
*
*	Written by D. W. Cousins on April 13, 1981 for sicw problem
*
*******************************************************************
	rem
dumsbf	subr	dsf,(x2)
	ldx2	t.sfcm,1	*some basic check
	lda	sf.flg,2
	cana	l.w001-*	* (sffhdl+sffbsc) is it bsc or hdlc?
	tze	dsfret-*	*no
	ilq	0	*going to tell frebuf to use buffer size
	lda	bftsa-*	*get the buffer
	tze	dsfret-*	*zero buffer address
	tsy	a.w005-*,*	*=frebfh
dsfret	return	dumsbf
	rem
bftx3	bss	1
bftsa	bss	1
	ttls	sqovfl - status queue overflow
sqovfl	subr	sqo(x2)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	sqovfl
*
*	finds the last status stored in the software
*	status queue and turns on the sqo bit.  also,
*	takes the channel out of receive mode.
*
*	upon entry:
*	     x1 - virtual tib address
*	     x2 - virtual sfcm address
*
*	returns:
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	cmeter	mincs,m.ssqo,l.d016-*
	rem
	lda	l.d012-*	(=sffsqo)
	cana	sf.flg,2	status queue overflow pending ?
	tnz	sqoret-*	yes, done
	orsa	sf.flg,2	indicate status queue overflow
	rem
	lda	l.d011-*	(=/pb.rcv)
	ansa	sf.pcw,2	turn off pcw rcv bit
	ila	p.nop	get pcw nop command
	tsy	a.d009-*,*	(cioc) exit rcv mode
	rem
	lda	sf.ssl,2	get length of status queue
	qls	4	in words
	sta	sqosql-*
	cx2a		put sfcm addr in a
	iaa	sf.waq	get start of status queue addr
	cmpa	sf.nxa,2	next status at start of queue ?
	tnz	sqo010-*	no
	ada	sqosql-*	get end of queue addr
	tra	sqo020-*
	rem
sqo010	null
	lda	sf.nxa,2	get next status addr
	rem
sqo020	null
	iaa	-4	back up to last status
	cax2		put in x2
	rem
	ila	hs.sqo	get status queue overflow bit
	orsa	0,2	set sqo in last status
	rem
sqoret	return	sqovfl
	rem
sqosql	bss	1
	ttls	hstprc - hsla status processor
hstprc	null		transfered to by secondary dispatcher
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	hstprc
*
*	     this routine is the main guts of hsla_man.
*	it is the scheduled status processor, which processes
*	the status queued for it by hintr, the interrupt
*	handling routine. All queued status for a line is processed
*	by hstprc before it returns. some of this processing
*	may result in the dcw interpreter or the control
*	table interpreter being called.
*
*	upon entry:
*	     x1 - real tib address
*
*	returns:
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	cx1a		get real tib address in a
	sta	stptib-*	save for use with dspqur and trace
	tsy	a.d010-*,*	(setptw) virtualize real tib address
	cax1		virtual tib address goes in x1
	ldx2	t.sfcm,1	get virtual sfcm address
	rem
	lda	sf.ssl,2	figure out current number of pending status
	sba	sf.tly,2	to meter it
	sta	a.d011-*,*	(stpcnt)
	cmeter	mupdat,m.nst,(a.d011-*(*))
	rem
	lda	sf.tly,2	get queue tally
	cmpa	sf.ssl,2	is it at max?
	tze	a.e019-*,*	(stp210) yes, no work to be done here
	rem
	stz	a.d011-*,*	(stpcnt) zero status processed counter
	rem
stp010	lda	sf.pcw,2	check to see if channel is masked
	icana	pb.msk
	tze	stp012-*	it isn't, proceed
	tsy	a.e026-*,*	(mskchn) it is, report it
	ila	sffskd	through processing status
	iera	-1	so turn off "scheduled" bit
	ansa	sf.flg,2
	stz	sf.rct,2
	tra	a.e027-*,*	(stpret) all finished
stp012	aos	a.d011-*,*	(stpcnt) bump counter of number processed
	lda	a.d011-*,*	(stpcnt) get counter value
	icmpa	3	have we done to many in a row?
	tmi	stp015-*	no
	rem
	ldx1	stptib-*	yes. get real tib address
	ila	hpri	get default scheduling priority
	ldq	intskd-*+1	(=hstprc) get addr of status processor
	tsy	a.d002-*,*	(=dspqur) reschedule status processor
	tra	a.d012-*,*	(=stpret) done for now
	rem
stp015	tsy	a.e023-*,*	(=albchs)
	ldaq	sf.nxp,2*	pick up the next status to be processed
	staq	a.d013-*,*	(=stpswd) save it away
	ldx3	sf.nxp,2	*get address of current status
	lda	2,3	*get the buffer address
	sta	bftsa-*	*store it now
	stx3	bftx3-*	*save the address to it
	trace	tt.sta,ts.sta,(stptib,stpswd,stpswd+1)
	rem
	aos	sf.tly,2	increment the tally
	ila	4	and also the next ptr
	asa	sf.nxp,2	to the status q
	rem
	lda	sf.ssl,2	get size of status queue
	als	2	in words
	sta	stpsql-*
	cx2a		put x2 into a
	iaa	sf.waq	get ptr to end of queue
	ada	stpsql-*
	cmpa	sf.nxp,2	are we at the end?
	tnz	stp020-*	no, continue
	rem
	cx2a		put sfcm into a again
	iaa	sf.waq	make ptr to head of queue
	sta	sf.nxp,2	and reset ptr, wraping queue
	rem
stp020	stz	stpmrk-*	init saved status
	lda	stpswd-*	get the first word of status
	cana	l.e001-*	(=hs.rcs) input status?
	tze	a.e020-*,*	(=stp100) no, output status
	eject
	rem	input status processor
	rem
	lda	t.stat,1
	ana	l.e006-*	(tsfst+tsfmrk+tsftrm) isolate requested status
	sta	stpmrk-*	save it for later
	iera	-1
	ansa	t.stat,1	turn off the tib flags
	rem
	lda	stpswd+1-*	get the 2nd status word
	arl	1	line up with tib rcv status bit
	ora	t.stat,1	or in tib status
	ana	l.e002-*	(=tsfrcv) leave only that, rcv mode?
	tnz	stp030-*	yes, continue
	rem
	tsy	a.e001-*,*	(=dmpbuf) dump any input buffers
	tsy	dumsbf-*	dump tempory store buffer
	rem
	lda	stpswd-*	get the first word of status
	cana	l.e007-*	(=hs.dss) any data set status changes?
	tze	stp080-*	no, skip rest of hardware status
	rem
	tsy	a.e009-*,*	(=ipdss) process the data set changes
	rem
	tra	a.e024-*,*	(stp095)
	rem
stp030	lda	stpswd-*	get the status word
	ars	12	shift into line with the other bit
	era	sf.flg,2	x-or the other one in
	icana	sffcii	are the two bits the same?
	tze	stp040-*	yes, all ok
	rem
	lda	sf.flg,2	*must check for bsc and hdlc
	cana	l.e014-*	*(sffhdl+sffbsc) bsc or hdlc?  already got buffer
	tnz	stp040-*
	rem
	trace	tt.ira,ts.sta,(stptib) trace recovery try
	rem
	ldx3	sf.ib0,2	get ptr to first input buffer
	lda	sf.flg,2	get sfcm flag bits
	icana	sffcii	are we in alt buffer?
	tze	2	no
	ldx3	sf.ib1,2	get it here
	rem
	cx3a		any buffer?
	tze	stp035-*	no buffer
	rem
	rem		need virtual address
	tsy	a.e025-*,*	setbpt
	cax3
	tsy	a.e013-*,*	(=ipterm) simulate terminate interrupt
	rem
stp035	ila	sffcii	get bit
	ersa	sf.flg,2	invert it, we are right now?
	rem
stp040	lda	sf.flg,2	*check line type
	cana	l.e014-*	*(sffhdl+sffbsc) is it bsc or hdlc?
	tze	stp045-*	*no
	lda	stpswd-*	switched icws?
	cana	l.e024-*	=hs.siw
	tze	stp045-*	no, buffer isn't stored with status
	ldx3	bftsa-*	*load the buffer address
	tra	stp050-*	*go to next step
stp045	ldx3	sf.ib0,2	get primary buffer prt
	lda	sf.flg,2	get the sfcm flags
	icana	sffcii	alternate icw?
	tze	stp050-*	no, continue
	ldx3	sf.ib1,2	get the secondary buf ptr
	rem
stp050	stx3	stpbuf-*	indicate which buffer
	iacx3	0	zero buffer address ?
	tnz	stp051-*	no
	lda	l.e018-*	get mask for status word 0
	ansa	stpswd-*	turn off bits that imply a buffer
	lda	l.e019-*	get mask for status word 1
	ansa	stpswd+1-*	turn off bits that imply a buffer
	rem
stp051	lda	l.e014-*	(=sffbsc+sffhdl)
	cana	sf.flg,2	is it bisync or HDLC?
	tze	stp060-*	no
	rem
	rem	check bisync and hdlc status conditions
	rem
stp052	lda	stpswd-*	get first status word
	cana	l.e007-*	(=hs.dss), data set status change?
	tze	2	no
	tsy	a.e009-*,*	(=ipdss), process it first
	rem
	lda	stpswd-*	*load status word
	cana	l.e004-*	=hs.siw
	tze	stp053-*	*not switching yet
	lda	bftsa-*	*load the buffer address
	tze	stp053-*	*no buffer get out
	tsy	a.e025-*,*	setbpt
	cax3		get virtual address in x3
	tsy	a.e015-*,*	*(=ipbfsw) switch buffers
	rem
stp053	stz	stptra-*	zero status accumulation
	lda	l.e023-*	(=sffhdl)
	cana	sf.flg,2	HDLC line?
	tnz	stp05a-*	yes
	rem
	ldx3	a.e016-*	get bsc status map ptr
	lda	a.e017-*	get bsc status map end ptr
	sta	stpend-*	save it
	tra	stp05b-*
	rem
stp05a	ldx3	a.e021-*	get hdlc status map ptr
	lda	a.e022-*	get hdlc status map end ptr
	sta	stpend-*	save it
	rem
stp05b	lda	stpswd-*	get first status word
stp054	cana	0,3	isolate interesting bits
	tnz	stp057-*	if on, set them
	rem
stp056	iacx3	2	bump table ptr
	cmpx3	stpend-*	end of table ?
	tze	stp058-*	yes
	rem
	szn	0,3	switch words ?
	tnz	stp054-*	not yet
	rem
	lda	stpswd+1-*	get second status word
	tra	stp056-*
	rem
stp057	caq		save status word
	lda	1,3	get status bits
	orsa	stptra-*	turn them on
	cqa		restore status word
	tra	stp056-*
	rem
stp058	lda	stptra-*	check for any new status bits
	tze	stp080-*	none - try usual case
	rem
	lda	t.stat,1	get tib status flags
	iana	s.dss	leave only common bits
	ora	stptra-*	add interesting bits
	tsy	a.e004-*,*	(=istat) call interp to process status
	tra	stp075-*	continue
	rem
	even
stpswd	bss	2	save area for status word
stpbuf	bss	1	ptr to current buffer
stptra	bss	1	addr of routine to run
stpcnt	bss	1	count of processed status this call
stpmrk	bss	1	saved copy of tsfst+tsfmrk+tsftrm
stptib	bss	1	saved value of real tib address
stpend	bss	1	set to bscend or hdcend
stpsql	bss	1	length of software status queue
	rem
	rem
	rem
l.e001	vfd	18/hs.rcs
l.e002	vfd	18/tsfrcv
l.e003	vfd	o18//tsfst
l.e004	vfd	18/hs.siw
l.e005	vfd	18/tsfmrk+tsftrm
l.e006	vfd	18/tsfst+tsfmrk+tsftrm
l.e007	vfd	18/hs.dss
l.e008	vfd	o18/410000
l.e009	vfd	18/sffstp
l.e010	vfd	18/hs.nms
l.e011	vfd	18/hs.ptr
l.e012	vfd	18/tsfst
l.e013	vfd	o18//sffsqo
l.e014	vfd	18/sffhdl+sffbsc
l.e015	vfd	18/hs.rcv
l.e016	vfd	18/hs.xmt
l.e017	vfd	18/s.xte
l.e018	vfd	o18//hs.nms*/hs.dms*/hs.trm*/hs.ptr*/hs.per
l.e019	vfd	o18//hs.rbt*/hs.crc
l.e020	vfd	18/hs.per
l.e021	vfd	18/s.prty
*l.e022	unused
l.e023	vfd	18/sffhdl
l.e024	vfd	18/hs.siw
	rem
a.e001	ind	dmpbuf
a.e002	ind	istats
a.e003	ind	iends
a.e004	ind	istat
a.e005	ind	ostats
a.e006	ind	oends
a.e007	ind	hdcw
a.e008	ind	secdsp
a.e009	ind	ipdss
a.e010	ind	ipptro
a.e011	ind	dssflg
a.e012	ind	echock
a.e013	ind	ipterm
a.e014	ind	opptro
a.e015	ind	ipbfsw
a.e016	ind	bscsts
a.e017	ind	bscend
a.e018	ind	stp010
a.e019	ind	stp210
a.e020	ind	stp100
a.e021	ind	hdcsts
a.e022	ind	hdcend
a.e023	ind	albchs
a.e024	ind	stp095
a.e025	ind	setbpt
a.e026	ind	mskchn
a.e027	ind	stpret
	rem
	ttls	status lookup tables for hstprc
	rem
	rem	input status table
	rem
istats	stats	hs.tro,iptro
	stats	hs.trm,ipterm
	stats	hs.nms,ipmark
	stats	hs.ptr,ipptro
	stats	hs.xte,ipxte
	stats	hs.dss,ipdss
iends	equ	*
	rem
	rem	output status table
	rem
ostats	stats	hs.ptr,opptro
	stats	hs.tro,optro
	stats	hs.xte,opxte
oends	equ	*
	rem
	rem	table to map bisync status to wait block status
	rem
bscsts	smap	hs.trm,s.brch
	smap	hs.nms,s.bmk
	smap	hs.dms,s.bdmk
	smap	hs.xte,s.xte
	smap	hs.per,s.prty
	smap	hs.tro,s.xte
	smap	0,0
	smap	hs.rbt,s.rbt
	smap	hs.crc,s.prty
	smap	hs.rto,s.rto
bscend	equ	*
	rem
	rem	table to map hdlc status to wait block status
	rem
hdcsts	smap	hs.tro,s.exh
	smap	hs.isd,s.isd
	smap	hs.xte,s.xte
	smap	hs.fce,s.fcse
	smap	hs.rab,s.rabt
	smap	0,0
	smap	hs.byt,s.pbyt
	smap	hs.rbt,s.rbt
hdcend	equ	*
	ttls	hstprc - hsla status processor
	eject
stp060	lda	stpswd-*	get status word
	cana	l.e020-*	(=hs.per) parity error ?
	tze	stp062-*	no
	rem
	lda	t.stat,1	get tib status
	iana	s.dss	leave only interesting bits
	ora	l.e021-*	(=s.prty) set parity error status
	tsy	a.e004-*,*	(=istat) call interpreter
	rem
stp062	ldx3	a.e002-*	(=istats) get status table ptr
	lda	stpswd-*	get the status word
stp065	cana	0,3	is this status bit on?
	tnz	stp070-*	yes, call that routine
	rem
	iacx3	2	bump the ptr to next entry
	cmpx3	a.e003-*	(=iends) end of table?
	tnz	stp065-*	no, continue loop
	rem
	tra	stp080-*	continue status processing
	rem
stp070	lda	1,3	get the routine to call
	sta	stptra-*	save this addr
	lda	stpbuf-*	get pointer to the current buffer
	tsy	a.e025-*,*	setbpt
	cax3
	tsy	stptra-*,*	go call that routine
	rem
	lda	stpswd-*	get status word
	cana	l.e010-*	(=hs.nms) was it marker status?
	tze	stp075-*	no, continue
	rem
	cana	l.e011-*	(=hs.ptr) ptro status also?
	tze	stp075-*	no
	rem
	tsy	a.e010-*,*	(=ipptro) process the ptro
	rem
stp075	lda	stpswd-*	get the status word
	cana	l.e004-*	(=hs.siw) switching icw's?
	tze	stp095-*	no, continue
	rem
	ila	sffcii	get the icw indicator bit
	ersa	sf.flg,2	and flip the bit in flag word
	tra	stp095-*	finish the status processing
	rem
stp080	lda	l.e009-*	(=sffstp) get the stop channel bit
	cana	sf.flg,2	did we just reset xmit mode?
	tze	stp090-*	no, done
	rem
	iera	-1	invert the bit
	ansa	sf.flg,2	and turn it off in the sfcm
	rem
	stz	sf.ob0,2	zero ptrs in case we
	stz	sf.ob1,2	just did a stop channel
	rem
	ldx3	sf.hcm,2	get ptr to hwcm
	lda	l.e008-*	(=410000) get the exhaust bit
	sta	h.sic0+1,3	store in both icws to
	sta	h.sic1+1,3	make sure hsla does not use again
	rem
stp090	lda	stpswd-*	get the status word
	cana	l.e004-*	(=hs.siw) are we switching icw's?
	tze	stp092-*	no, continue
	rem
	ila	sffcii	get the icw bit
	ersa	sf.flg,2	invert it now
	rem
stp092	lda	sf.flg,2	get sfcm flag bits
	icana	sffech	is echo in progress now?
	tnz	stp095-*	yes, skip it
	rem
	lda	sf.pcw,2	get pcw bits
	icana	pb.xmt	are we in xmit mode?
	tnz	stp095-*	yes, can't echo now
	rem
	tsy	a.e012-*,*	(=echock) check about echoing now
	tra	stp095-*	win, we started to echo
	tra	stp095-*	but who cares anyway.
	rem
stp095	lda	stpmrk-*	any requested status?
	tze	stp200-*	no, continue
	cana	l.e005-*	(=tsfmrk+tsftrm) marker or terminate?
	tze	stp096-*	no
	rem
*	only do terminate and/or marker status if hardware status agrees
*	with tib status with respect to recieve and transmit modes
	rem
	lda	t.stat,1	pick up tib status
	als	1	line up tib rcv bit with hw rcv bit
	era	stpswd+1-*	get xor of rcv bits
	ana	l.e015-*	(=hs.rcv) isolate result
	tnz	stp096-*	bits were different
	lda	t.stat,1	get tib status bits again
	ars	1	line up xmt bits
	era	stpswd+1-*
	ana	l.e016-*	isolate xor of xmt bits
	tnz	stp096-*	bits were different
	rem
	lda	t.stat,1	get tib status
	iana	s.dss	but only the ones we want
	ora	stpmrk-*	get requested status bits
	ana	l.e003-*	(=/tsfst) but turn off this one
	caq		save status bits
	lda	l.e005-*	(=tsfmrk+tsftrm)
	iera	-1	invert bits
	ansa	stpmrk-*	turn off marker and terminate
	cqa		get saved status back in a
	rem
	tsy	a.e004-*,*	(=istat) call intrp to process status
	tra	stp200-*	done with rcv status
	rem
stp096	lda	stpmrk-*
	cana	l.e012-*	(=tsfst) requested status?
	tze	stp200-*	no, all done with status
	rem
	lda	l.e012-*	(=tsfst) get the bit
	iera	-1	invert it
	ansa	stpmrk-*	turn it off
	rem
	aos	a.e011-*,*	(=dssflg) set flag to ipdss
	rem		to indicate requested status
	tsy	a.e009-*,*	(=ipdss) process status
	tra	stp200-*	done
	eject
	rem	output status processor
	rem
stp100	lda	stpswd-*	get the status word
	ars	11	align the icw bits
	era	sf.flg,2	leave only the one we want
	icana	sffcoi	should not be on!
	tze	stp105-*	good, all ok
	rem
	trace	tt.ira,ts.sta,(stptib) trace recovery try
	rem
	ldx3	sf.ob0,2	recover output buffers
	lda	sf.flg,2	get flags
	icana	sffcoi	alt output bfr?
	tze	2	no
	ldx3	sf.ob1,2	yes, get it
	rem
	cx3a		set indicators
	tze	stp101-*	no buffer
	rem
	tsy	a.e025-*,*	setbpt
	cax3		now we have virtual address
	tsy	a.e014-*,*	(=opptro) simulate ptro on buffer
	tra	stp105-*	it flipped indicator for us
	rem
stp101	ila	sffcoi	get bit
	ersa	sf.flg,2	flip it
	rem
stp105	ldx3	sf.ob0,2	get the current output buffer ptr
	lda	sf.flg,2	get the sfcm flags
	icana	sffcoi	are we using alternate icw?
	tze	stp110-*	no, primary in use
	ldx3	sf.ob1,2	get the alternate buf ptr
	rem
stp110	stx3	stpbuf-*	save the buffer ptr
	ldx3	a.e005-*	(=ostats) get ptr to table of status
	rem
stp120	lda	stpswd-*	get the status word
	cana	0,3	is this bit on?
	tnz	stp130-*	yes, call routine
	rem
	iacx3	2	increment ptr
	cmpx3	a.e006-*	(=oends) end of table?
	tnz	stp120-*	no, loop more
	rem
	lda	stpswd-*	get status word
	cana	l.e004-*	(=hs.siw) are we switching send icw's?
	tze	3	skip if not
	ila	sffcoi	get bit
	ersa	sf.flg,2	flip it
	tra	stp200-*	yes, all done
	rem
stp130	lda	1,3	get addr of routine to call
	sta	stptra-*	save it
	lda	stpbuf-*	get buffer addr
	tsy	a.e025-*,*	setbpt
	cax3		now we have virtual address
	tsy	stptra-*,*	go to routine
	rem
	eject
stp200	ila	hs.sqo
	cana	a.f008-*,*	(stpswd) status queue overflow ?
	tze	stp205-*	no
	rem
	lda	l.e013-*	(=/sffsqo)
	ansa	sf.flg,2	turn off status queue overflow flag
	rem
	lda	t.stat,1	get tib status bits
	iana	s.dss	but only the ones we want
	ora	l.e017-*	(=s.xte) set xte status
	tsy	a.e004-*,*	(=istat) call interpreter
	rem
stp205	lda	a.f009-*,*	(stpmrk) in case requested status not performed
	orsa	t.stat,1	put back for next time
	lda	sf.tly,2	get the wrap around queue tally
	cmpa	sf.ssl,2	is queue empty?
	tnz	a.e018-*,*	(stp010) no, more status to be processed
	rem
stp210	ila	sffskd	get the sCked flag
	iera	-1	invert it
	ansa	sf.flg,2	and store it into sfcm
	rem
	lda	sf.tly,2	tally still at max?
	cmpa	sf.ssl,2	well?
	tnz	a.e018-*,*	(=stp010) nope, process more status
	stz	sf.rct,2	zero sqo repeat count
	rem
	lda	a.f008-*,*	(=stpswd) get the status word
	cana	l.f008-*	(=hs.rcs) is this receive status?
	tze	stpret-*	nope, done
	rem
	szn	sf.ob0,2	are both of the output buffers gone yet?
	tnz	stpret-*	not first one
	szn	sf.ob1,2	second?
	tnz	stpret-*	nope, done
	rem
	lda	t.flg,1	is output suspended?
	cana	l.f012-*	=tfosus
	tnz	stpret-*	yes, we'l pick up rest of dcw list later
	rem
	lda	l.f009-*	(=sffhdl)
	cana	sf.flg,2	skip this for HDLC lines
	tnz	stpret-*
	rem
	lda	t.dcwl,1	is there a dcw list?
	tze	stpret-*	nope, done
	rem
	tsy	a.f011-*,*	(=hdcw) call the dcw list processor
	rem
stpret	tra	a.f012-*,*	(=secdsp) return to secondary dispatcher
	rem
	rem
	ttls	dmpbuf - proc to dump input buffers when we exit rcv
dmpbuf	subr	dmp,(x1,x2,x3)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	dmpbuf
*
*	     proc to dump the input buffers when we leave
*	receive mode. If there is any input in the current
*	input buffer, we will chain it onto the input
*	chain, otherwise we will just free the buffers.
*
*	upon entry:
*	     x1 - virtual tib address
*	     x2 - virtual sfcm address
*
*	returns:
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	szn	sf.ib0,2	look to see if the buffers are already gone.
	tnz	dmp005-*	first one isn't, proceed
	szn	sf.ib1,2	it is, what about second?
	tze	dmpret-*	yes, all done
	rem
dmp005	tsy	a.f004-*,*	(=gettly) get current buffer tally & addr
	sta	dmptmp-*	save buffer tally
	cx3a		is there a buffer ?
	tze	dmp050-*	no, skip null buffer
	lda	sf.flg,2	synchronous line?
	cana	l.f006-*	sffsyn
	tze	dmp010-*	no
	cx3a		yes, back to beginning of buffer
	sba	l.f007-*	bf.dta,b.0
	cax3
	tra	dmp020-*
dmp010	null		asynchronous pseudo-buffer
	cx3a		just wipe out char. addressing
	ana	l.f001-*	=o077777
	cax3
dmp020	szn	dmptmp-*	zero tally?
	tze	dmp040-*	yes, free buffer
	rem
	lda	sf.flg,2	synchronous?
	cana	l.f006-*	=sffsyn
	tnz	dmp030-*	yes, copy to input chain
	tsy	a.f003-*,*	(=scan) else scan chars
	stz	sf.nic,2	make sure next scan starts clean
	tra	dmp040-*	scan took care of copying to input chain
	rem
dmp030	lda	l.f002-*	(=buftmk) get tally mask
	iera	-1	invert mask
	ansa	bf.tly,3	zero tally field
	lda	dmptmp-*	get back buffer tally
	orsa	bf.tly,3	put tally in buffer
	rem
	tsy	a.f002-*,*	(=parity) strip off parity bits
	rem
	tsy	a.f005-*,*	(=ichain) put buffer on input chain
	tra	dmp050-*	free second buffer
	rem
dmp040	tsy	fribuf-*
	rem
dmp050	cx3a
	tsy	a.f007-*,*	cvabs
	rem		we need absolute address for this
	cmpa	sf.ib0,2	primary buffer addr in x3 ?
	tze	3	yes
	lda	sf.ib0,2	no, get primary buffer addr
	tra	2
	lda	sf.ib1,2	get alt. buffer addr
	tze	dmp060-*	skip null buffer
	tsy	a.f010-*,*	setbpt
	cax3		fribuf wants virtual address
	tsy	fribuf-*	free the buffer
	rem
dmp060	stz	sf.ib0,2	zero the buffer ptrs
	stz	sf.ib1,2
	rem
dmpret	return	dmpbuf	all done
	rem
	rem
	rem
	rem
fribuf	subr	fri,(x3)	free an input buffer for dmpbuf
	rem
	lda	sf.flg,2	synchronous?
	cana	l.f006-*	=sffsyn
	tze	fri005-*	no
	cx3a		yes, get absolute address
	tsy	a.f007-*,*	cvabs
	tra	fri030-*	and free it
fri005	cx3a		else find out if it's one of the permanent ones
	tsy	a.f007-*,*	cvabs
	cmpa	t.abf0,1	is it first one?
	tnz	fri010-*	no
	lda	l.f010-*	(tfabf0) yes
	orsa	t.flg3,1	mark it available
	tra	fribak-*	done
fri010	cmpa	t.abf1,1	is it the other one?
	tnz	fri020-*	no, free it
	lda	l.f011-*	tfabf1
	orsa	t.flg3,1	mark 2nd one available
	tra	fribak-*
fri020	ldq	0,3	else get size out of buffer
	qrl	9
	tra	fri040-*
	rem
fri030	ilq	0	let frebfh determine size
fri040	tsy	a.f001-*,*	frebfh
fribak	return	fribuf
	rem
	rem
dmptmp	bss	1
	rem
	rem
l.f001	oct	077777
l.f002	vfd	18/buftmk
l.f003	vfd	18/tflfec+tfcrec+tftbec
l.f004	vfd	18/s.prex
l.f005	vfd	18/s.exh
l.f006	vfd	18/sffsyn
l.f007	zero	bf.dta,b.0
l.f008	vfd	18/hs.rcs
l.f009	vfd	18/sffhdl
l.f010	vfd	18/tfabf0
l.f011	vfd	18/tfabf1
l.f012	vfd	18/tfosus
	rem
a.f001	ind	frebfh
a.f002	ind	parity
a.f003	ind	scan
a.f004	ind	gettly
a.f005	ind	ichain
a.f006	ind	istat
a.f007	ind	cvabs
a.f008	ind	stpswd
a.f009	ind	stpmrk
a.f010	ind	setbpt
a.f011	ind	hdcw
a.f012	ind	secdsp
	ttls	addbuf - add buffer to input chain
addbuf	subr	abf
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	addbuf
*
*	adds a buffer to the end of the input chain and
*	signals pre-exhaust and/or exhaust status if
*	appropriate.
*
*	upon entry:
*	     x1 - virtual tib address
*	     x2 - virtual sfcm address
*	     x3 - buffer to be added to input chain
*
*	returns:
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	tsy	ichain-*	thread buffer onto input chain
	rem
	lda	sf.flg,2	get sfcm flags
	cana	l.f006-*	(=sffsyn) synch line ?
	tnz	abf010-*	yes, don't check pre-exhaust
	rem
	lda	t.icpl,1	get input chain length
	icmpa	10	at pre-exhaust limit ?
	tmi	abf011-*	no
	rem
	lda	t.stat,1	get tib status
	iana	s.dss	relevant bits only
	ora	l.f004-*	(=s.prex) set pre-exhaust status
	tsy	a.f006-*,*	(=istat) call interpreter
	rem
abf010	null
	lda	l.f009-*	(=sffhdl)
	cana	sf.flg,2	is it HDLC?
	tnz	abfret-*	don't check for exaust
	rem
	lda	t.icpl,1	get input chain length again
abf011	ada	t.dcpl,1	get total input buffer usage
	icmpa	40	at exhaust limit ?
	tmi	abfret-*	no, done
	rem
	lda	t.stat,1	get tib status
	iana	s.dss	relevant bits only
	ora	l.f005-*	(=s.exh) set exhaust status
	tsy	a.f006-*,*	(=istat) call interpreter
	rem
abfret	return	addbuf
	ttls	ichain - thread buffer onto input chain
ichain	subr	ich,(x2,x3)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	ichain
*
*	threads a buffer onto the end of the input chain
*	and updates the chain length (t.icpl)
*
*	upon entry:
*	     x1 - virtual tib address
*	     x3 - virtual address of buffer to be threaded
*                   onto input chain
*
*	returns:
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	cx3a
	tsy	a.g006-*,*	(cvabs) get absolute address
	szn	t.ilst,1	any input chain ?
	tnz	ich010-*	yes
	rem
	sta	t.icp,1	start a new chain
	sta	t.ilst,1	end a new chain
	tra	ich020-*
	rem
ich010	caq		safe store
	lda	t.ilst,1	get addr of last buffer
	tsy	a.g007-*,*	setbpt
	cax2		virtual address into x2
	stq	bf.nxt,2	thread on new last buffer
	stq	t.ilst,1	update last ptr
	cqa		set up pte for last buffer again
	tsy	a.g007-*,*	(address is already in x3)
	rem
ich020	lda	bf.siz,3	get buffer size code
	arl	15	right adjust
	iaa	1	get true block count
	asa	t.icpl,1	update input chain length
	rem
	return	ichain
	ttls	ipterm - process input terminate status
ipterm	subr	trm,(x1,x2,x3)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	ipterm
*
*	     process the input terminate status. this will
*	be stored as a result of a user typing nis break
*	character, and can only mean that it is time to
*	ship his data to the cs.
*
*	upon entry:
*	     x1 - virtual tib address
*	     x2 - virtual sfcm address
*	     x3 - points to the current buffer
*
*	returns:
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	lda	l.g001-*	(=bffbrk) get the break bit
	orsa	bf.flg,3	turn it on in the buffer
	rem
	lda	sf.flg,2	synchronous line?
	cana	l.g004-*	=sffsyn
	tnz	trm010-*	no, don't bother scanning
	rem
	tsy	a.g005-*,*	(=scan) scan the input
	rem
trm010	tsy	a.g002-*,*	(=setnib) setup new input buffer
	rem
	lda	sf.flg,2	synchronous?
	cana	l.g004-*	=sffsyn
	tze	trm020-*	no, scan took care of input chain
	tsy	a.g003-*,*	(=parity) strip off parity
	tsy	a.g008-*,*	(=addbuf) add buffer to input chain
	rem
trm020	lda	t.stat,1	get the tib status bits
	iana	s.dss	but only the ones we want
	ora	l.g002-*	s.brch
	tsy	a.g001-*,*	(=istat) call status processor
	rem
	return	ipterm
	rem
l.g001	vfd	18/bffbrk
l.g002	vfd	18/s.brch
l.g003	vfd	o18//sffmsp
l.g004	vfd	18/sffsyn
	rem
a.g001	ind	istat
a.g002	ind	setnib
a.g003	ind	parity
a.g005	ind	scan
a.g006	ind	cvabs
a.g007	ind	setbpt
a.g008	ind	addbuf
	ttls	ipmark - process input marker status
ipmark	subr	mrk,(x1,x2,x3)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	ipmark
*
*	process input marker status indicating one or more
*	of the following events:
*
*	- any char received in echoplex or breakall mode
*
*	- tab received in tabecho mode
*
*	- frame begin char received in frame input mode
*
*	- any break character received
*
*	upon entry:
*	     x1 - virtual tib address
*	     x2 - virtual sfcm address
*	     x3 - points to buffer
*
*	returns:
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	lda	l.g003-*	=^sffmsp
	ansa	sf.flg,2	indicate no marker pending
	rem
	tsy	a.g005-*,*	(=scan) scan the input
	rem
	return	ipmark
	rem
	ttls	ipbfsw - process buffer switch for bisync and hdlc
ipbfsw	subr	bsw
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	ipbfsw
*
*	     process buffer switch for bisync and hdlc channels
*
*	upon entry:
*	     x1 - points to tib
*	     x2 - points to sfcm
*	     x3 - points to the current buffer (virtual address)
*
*	returns:
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	tsy	a.i008-*,*	(=parity) strip all parity
	rem
	tsy	a.i009-*,*	(=addbuf) add buffer to input chain
	stz	a.x001-*,*	*=bftsa  all finished, clear it
	ldx3	a.x002-*,*	*=bftx3 buffer address pointer
	stz	2,3
	stz	a.x002-*,*	*=bftx3 clear up old buffer address
	rem
bswret	return	ipbfsw
a.x001	ind	bftsa
a.x002	ind	bftx3
	ttls	swphic - switch preallocated icw s
**********************************************************************
*
*	swphic - switch with preallocated buffer for icw
*
*	This routine will start the icw switching process using
*	the preallocated buffer pools. It sets up the registers
*	and other variables to complete the switch. It will store
*	the buffer in the software com area; it will not add it to
*	the input chain in the tib.
*
*	upon entry:
*	 x1 - tib
*	 x2 - sfcm
*
*	returns:
*
*	Coded by D. W. Cousins for icw switch problem
*
**********************************************************************
swphic	subr	swp,(i,x2,x3)
	cx2a		*get address of sfcm into a
	caq		*place it into q
	iaq	sf.ib0	*add in offset
	lda	sf.flg,2	*get software flags
	sta	sfflag-*	*store them for later
	ana	l.y001-*	*=^sfcii mask
	sta	sf.flg,2
	lda	sf.nxa,2*	*load the status word
	arl	12
	iana	sffcii	*mask all bits ecept alt icw
	orsa	sf.flg,2	*this should work
	lda	sf.flg,2	*get the flags for test
	icana	sffcii	*alternate buffer
	tze	2	*no
	iaq	sf.ib1-sf.ib0	*change offset
	stq	sfptr-*	*save it tempory
	ldq	sfptr-*,*	*load the buffer address
	ldx3	sf.nxa,2	*load current ptr to status
	stq	2,3	*store buffer after the status
	lda	sf.bsz,2	*get this line buffer size
	ars	5	*get table index
	iaa	-1
	cax2
	inh
	ldq	a.y001-*,*	(=pchtbl,2) get the buffer address
	tze	swp010-*	no buffer
	ila	-1
	asa	a.y002-*,*	(=pchlft,2) reduce buffer total
	cqa
	sta	swpabs-*	save it for later
	tsy	a.y003-*,*	(setbpt)
	cax3		place virtual address into x3
	ldq	bf.nxt,3	get next address
	stq	a.y001-*,*	(=pchtbl,2) put it as the head
	ldi	swpsi-*
	stz	bf.nxt,3	zero next buffer pointer
	lda	bf.tly,3	get it tally
	ana	l.f002-*	=buftmk mask the tally
	caq		place it in q
	ldx2	t.sfcm,1	get sfcm again
	lda	l.y002-*	=sffnib
	iera	-1
	ansa	sf.flg,2
	ansa	sfflag-*	*save it here also
	lda	swpabs-*	get absolute address back
	sta	sfptr-*,*
	rem
	stq	swpq-*	hang on to size
	smeter	mincd,.mupab,l.y003-*
	tra	swp020-*
	rem
swp010	ila	0
	ldx2	t.sfcm,1	get sfcm again
	ldi	swpsi-*	restore interrupt state
	stz	sfptr-*,*
	cax3
	rem
	stq	swpq-*	hang on to size
	smeter	mincd,.mpanf,l.y003-*
	rem
swp020	ldq	swpq-*
	tsy	nibicw-*
	lda	sfflag-*	*return old sf.flg
	sta	sf.flg,2
	return	swphic
	rem
a.y001	ind	pchtbl,2
a.y002	ind	pchlft,2
a.y003	ind	setbpt
	rem
l.y001	vfd	o18//sffcii
l.y002	vfd	18/sffnib
l.y003	dec	1
	rem
sfflag	bss	1
sfptr	bss	1
swpq	bss	1
swpabs	bss	1
	ttls	ipxte - process input transfer timing error
ipxte	subr	ixt,(x1,x2,x3)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	ipxte
*
*	     process transfer timing errors. currently we
*	will not expect these, and will crash on any.
*
*	upon entry:
*
*	returns:
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	die	4
	rem
	return	ipxte
	ttls	ipptro - process input pre-tally runout
ipptro	subr	ipt,(x1,x2,x3)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	ipptro
*
*	     process input pre-tally runout status. this
*	status is stored just before we switch to a new input
*	buffer, and the old one should be put onto the input
*	chain.
*
*	upon entry:
*	     x1 - virtual tib address
*	     x2 - virtual sfcm address
*	     x3 - points to the buffer
*
*	returns:
*	     with a new input buffer setup
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	lda	sf.flg,2	synchronous line?
	cana	l.i001-*	=sffsyn
	tnz	ipt010-*	yes, copy buffer directly to chain
	rem
	tsy	a.i001-*,*	(=scan) scan rest of input data
	tra	ipt030-*
	rem
ipt010	tsy	a.i008-*,*	(=parity) remove parity bits
	tsy	a.i009-*,*	(=addbuf) add buffer to input chain
	rem
ipt030	tsy	a.i005-*,*	(=setnib) setup new input buffer
	rem
	return	ipptro	bye
	ttls	iptro - process input tally runout
iptro	subr	itr,(x1,x2,x3)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	iptro
*
*	     processs input tally runout status. this indicates
*	an attempt to use an exhausted icw.  this could occur
*	either because there was not enough time to set up a new
*	buffer or because no buffer was available.  the latter
*	case is indicated by a zero buffer address.  in this case,
*	we signal exhaust status to the interpreter.  in the
*	former case, we signal transfer timing error (xte) status.
*
*	upon entry:
*	     x1 - virtual tib address
*	     x2 - virtual sfcm address
*	     x3 - points to buffer
*
*	returns:
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	lda	t.stat,1	get tib status bits
	iana	s.dss	but only the ones we want
	rem
	iacx3	0	do we have a buffer?
	tze	3	no
	ora	l.i003-*	(=s.xte) set xte status
	tra	2
	ora	l.i009-*	(=s.exh) set exhaust status
	rem
	tsy	a.i004-*,*	(=istat) call interpreter
	rem
	return	iptro	all done
	rem
	rem
l.i001	vfd	18/sffsyn
*l.i002
l.i003	vfd	18/s.xte
*l.i004
*l.i005		unused
l.i006	vfd	18/tfecpx+tftbec
*l.i007		unused
l.i009	vfd	18/s.exh
	eject
a.i001	ind	scan
*a.i002
*a.i003
a.i004	ind	istat
a.i005	ind	setnib
*a.i007
a.i008	ind	parity
a.i009	ind	addbuf
	ttls	ipdss - process data set status change
ipdss	subr	ids,(x1,x2,x3)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	ipdss
*
*	     process data set status changes. record the
*	change and inform the control_tables.
*
*	upon entry:
*	     x1 - virtual tib address
*	     x2 - virtual sfcm address
*	     lower 18 bits of status in stpswd+1
*
*	returns:
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	stz	idsst-*	zero current status word
	ldx3	a.j002-*	(=hstat) get the address of the table
	rem
	lda	t.flg2,1	are we dialing out?
	cana	l.j002-*	=tfacu
	tnz	ids010-*	yes
	rem		else we'll have to mask off acu bits
	lda	l.j003-*	^hs.dlo & ^hs.pwi
	ansa	a.j006-*,*	=stpswd
	lda	l.j004-*	^hs.ads & ^hs.acr
	ansa	a.j001-*,*	=stpswd+1
	rem
ids010	lda	a.j001-*,*	(=stpswd+1) get the status word
	cana	0,3	is this a match?
	tze	ids020-*	no, keep looking
	rem
	lda	1,3	get the bit to set
	orsa	idsst-*	or into saved status
	rem
ids020	iacx3	2	increment to next entry
	cmpx3	a.j003-*	(=ehstat) end of table?
	tnz	ids010-*	no, continue
	rem
	ldx3	a.j005-*	(=h1stat) get the address of the table for first
	rem
ids030	lda	a.j006-*,*	(=stpswd) get the status word
	cana	0,3	is this a match
	tze	ids040-*	no, skip it
	rem
	lda	1,3	get the bit to set
	orsa	idsst-*	or into saved status
	rem
ids040	iacx3	2	increment to next entry
	cmpx3	a.j007-*	(=endh1) end of table?
	tnz	ids030-*	no, continue
	rem
	ila	0	zero the a reg
	szn	dssflg-*	requested status?
	tze	2	no
	rem
	lda	l.j001-*	(=s.st) get status bit
	stz	dssflg-*	clear flag
	rem
	ora	idsst-*	get new data set status
	tsy	a.j004-*,*	(=istat) call interpreter w/status
	rem
	rem		if this was line break, and output is suspended,
	rem		resume it
	lda	idsst-*	get status flags
	cana	l.j005-*	=s.brk
	tze	ids050-*	wasn't line break, never mind
	lda	t.flg,1	was output suspended?
	cana	l.j006-*	=tfosus
	tze	ids050-*	no, don't worry about it
	tsy	a.j008-*,*	(resout) start output going again
ids050	null
	ila	15	(=o17) mask for common bits
	rem		cd+cts+dsr+src
	ansa	idsst-*	leave only those bits now
	iera	-1	flip over the mask
	ansa	t.stat,1	turn off the bits in the tib
	rem
	lda	idsst-*	get the real status bits
	orsa	t.stat,1	and turn only those on in the tib
	rem
	return	ipdss	all done
	rem
	rem
idsst	bss	1	(altrd) loc for current dataset status
dssflg	oct	0	(altrd) flag to indicate requested status
	rem
hstat	smap	hs.dsr,s.dsr
	smap	hs.cts,s.cts
	smap	hs.cd,s.cd
	smap	hs.src,s.sprc
	smap	hs.ri,s.ring
	smap	hs.brk,s.brk
	smap	hs.acr,s.acr
	smap	hs.ads,s.ads
ehstat	equ	*
	rem
h1stat	smap	hs.dlo,s.dlo
	smap	hs.pwi,s.pwi
endh1	equ	*
	rem
	rem
l.j001	vfd	18/s.st
l.j002	vfd	18/tfacu
l.j003	vfd	o18//hs.dlo*/hs.pwi   ^(acu bits in first word)
l.j004	vfd	o18//hs.acr*/hs.ads   ^(acu bits in second word)
l.j005	vfd	18/s.brk
l.j006	vfd	18/tfosus
	rem
a.j001	ind	stpswd+1	status save word
a.j002	ind	hstat
a.j003	ind	ehstat
a.j004	ind	istat
a.j005	ind	h1stat
a.j006	ind	stpswd
a.j007	ind	endh1
a.j008	ind	resout
	ttls	setnib - setup new input buffer
setnib	subr	snb,(x1,x2,x3)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	setnib
*
*	     setup a new input buffer for the channel. the
*	buffer will be allocated, and the icw setup
*	ready to be used by the channel.
*
*	upon entry:
*	     x1 - virtual tib address
*	     x2 - virtual sfcm address
*
*	returns:
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	ldx3	a.h004-*,*	.crbpe
	lda	0,3	have to save buffer pte
	sta	snbpte-*
	rem
	cx2a		get sfcm addr into a
	caq		now into the q
	iaq	sf.ib0	add in offset
	rem
	lda	sf.flg,2	get the flags
	icana	sffcii	alternate buffer?
	tze	snb010-*	no,
	rem
	iaq	sf.ib1-sf.ib0	change offset
	rem
snb010	stq	snbptr-*	save the ptr
	rem
	lda	sf.flg,2	synchronous line?
	cana	l.h001-*	=sffsyn
	tnz	snb030-*	yes, always allocate afresh
	stz	sf.nic,2	async, clear current char. pointer
	lda	snbptr-*,*	is there one now?
	tze	snb030-*	no, we'll have to allocate one
	tsy	a.h003-*,*	(setbpt) yes, get virtual address
	cax3
	lda	sf.flg,2	get flag word back
	cana	l.h003-*	(sffnib) are we supposed to allocate one anyway?
	tnz	snb020-*	yes
	ldq	0,3	get size of current one
	qrl	9
	cmpq	sf.csz,2	is it correct?
	tnz	snb025-*	no
	qls	1	yes, convert it to characters
	iaq	-3	allow for overhead (***two*** at end)
	tra	snb050-*
	rem
snb020	ldq	0,3	make sure we have the size
	qrl	9
snb025	lda	snbptr-*,*	find out if it's a permanent one
	cmpa	t.abf0,1
	tnz	snb027-*	not first one
	lda	l.h005-*	(tfabf0) yes, mark it available
	orsa	t.flg3,1
	tra	snb030-*
snb027	cmpa	t.abf1,1	second one?
	tnz	snb028-*	no, it's allocated
	lda	l.h006-*	tfabf1
	orsa	t.flg3,1	mark it available
	tra	snb030-*	get new one
snb028	tsy	a.h001-*,*	(frebfh) free the old one
	rem
snb030	tsy	a.h007-*,*	(=ghibuf) get input buffer
	tra	snb040-*	error, cannot get buffer
	rem
	sta	snbptr-*,*	store the buffer ptr
	rem
	lda	l.h003-*	=sffnib
	iera	-1	turn it off
	ansa	sf.flg,2
	tra	snb050-*	continue
	rem
snb040	stz	snbptr-*,*	no buffer, zero buffer ptr
	ila	0
	cax3		and x3 too
	rem
snb050	tsy	nibicw-*	setup icw
	rem
	ldx3	a.h004-*,*	.crbpe
	lda	snbpte-*	get saved pte back
	sta	0,3	restore it
	return	setnib
	rem
snbptr	bss	1	(altrd) pointer to current buf ptr
snbpte	bss	1	saved copy of buffer pte
	ttls	nibicw - setup new input icw
nibicw	subr	nib,(inh,q,x1,x2,x3)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	nibicw
*
*	     setup new icw for the input buffer which is
*	being setup. the buffer addr is in x3, and sffcii
*	tells us which icw to setup.
*
*	upon entry:
*	     x1 - virtual tib address
*	     x2 - virtual sfcm address
*	     x3 - virtual buffer address
*	     q - contains buffer tally
*
*	returns:
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	lda	sf.hcm,2	get the hwcm ptr
	rem
	iaa	h.ric0	get ptr to icw
	sta	nibiwp-*	save it in temp
	rem
	lda	sf.flg,2	get the flags
	icana	sffcii	alternate buffer?
	tze	nib010-*	no, go
	rem
	lda	nibiwp-*	get the ptr
	iaa	h.ric1-h.ric0	add offset
	sta	nibiwp-*	save it in temp
	rem
nib010	ldx3	nibsx3-*	restor buffer ptr to x3
	tze	nib020-*	zero buffer addr, special case
	rem
	lda	sf.flg,2	synchronous?
	cana	l.h001-*	=sffsyn
	tze	nib015-*	no
	cx3a		get buffer ptr into a reg
	ada	l.h002-*	bf.dta,b.0
	tra	nib016-*
nib015	cx3a		get buffer ptr into a reg
	ora	l.h004-*	(=0,b.1) async, start at second char
nib016	ldx3	nibiwp-*	get ptr to icw in x3
	rem
	ldq	nibsq-*	get buffer tally
	tsy	a.h002-*,*	(bldicw) and store into icw
	tra	nibret-*	done
	rem
nib020	lda	a.h008-*	(=bnispc) get addr of spare word
	ldq	l.h007-*	(=450000) get exhausted tally
	staq	nibiwp-*,*	set icw
	rem
nibret	return	nibicw
	rem
nibiwp	bss	1	(altrd) icw ptr
	eject
	rem
l.h001	vfd	18/sffsyn
l.h002	ind	bf.dta,b.0
l.h003	vfd	18/sffnib
l.h004	zero	0,b.1
l.h005	vfd	18/tfabf0
l.h006	vfd	18/tfabf1
l.h007	oct	450000
	rem
a.h001	ind	frebfh
a.h002	ind	bldicw
a.h003	ind	setbpt
a.h004	ind	.crbpe
*a.h005
*a.h006
a.h007	ind	ghibuf
a.h008	ind	bnispc
	ttls	parity - strip parity bits off input characters
parity	subr	par,(x1,x2,x3)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	parity
*
*	     parity will remove the parity bits from the
*	input data. status will have noted any parity errors
*	for us.
*
*	upon entry:
*	     x1 - virtual tib address
*	     x2 - virtual sfcm address
*	     x3 - virtual buffer address
*
*	returns:
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	lda	t.flg3,1	see if we should bother
	cana	l.m007-*	=tf8in
	tnz	par030-*	no, keeping all 8 bits
	rem
	cx3a
	cmpa	l.m009-*	(=1000(8)) bad?
	tpl	2	no, continue
	die	1	gotcha
	rem
	lda	t.flg3,1	see if parity should be kept
	cana	l.m010-*	=tfkpar
	tnz	par030-*	dont strip parity
	rem
	ldq	l.m001-*	(=177177) get parity bits
	rem
	lda	sf.flg,2	get sfcm flags
	icana	sffebd	ebcdic characters?
	tze	par010-*	no,
	rem
	ldq	l.m002-*	(=077077) get the ebcdic parity mask
	rem
par010	lda	bf.tly,3	get the buffer tally
	ana	l.m003-*	(=buftmk) leave only tally
	iaa	1	add one
	ars	1	divide by two
	sta	parcnt-*	store it here
	ila	0	get a zero
	ssa	parcnt-*	makes it negative
	rem
	iacx3	bf.dta	point to data in buffer
	cqa		put parity mask into a reg
	rem
par020	ansa	0,3	mask parity bits
	iacx3	1	bump ptr
	aos	parcnt-*	decrement count
	tmi	par020-*	loop
	rem
par030	return	parity
	rem
parcnt	bss	1
	rem
l.m001	vfd	o18/177177
l.m002	vfd	o18/077077
l.m003	vfd	18/buftmk
l.m004	vfd	18/tflfec
l.m005	ind	0,b.0
l.m006	vfd	18/tftbec
l.m007	vfd	18/tf8in
l.m008	vfd	18/tffip
l.m009	oct	1000
l.m010	vfd	18/tfkpar
	rem
	ttls	outpar - output parity for ebcdic terminals
outpar	subr	opr,(x3)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	outpar
*
*	     outpar generates parity bits on 6-bit ebcdic
*	data. odd parity only.
*
*	upon entry:
*	     x2 - virtual sfcm address
*	     x3 - virtual buffer address
*
*	returns:
*	     parity bits in buffer
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	lda	sf.flg,2	get the sfcm flag bits
	icana	sffebd	edcbic data?
	tze	oprret-*	no
	rem
	lda	bf.tly,3	get the buffer tally
	ana	l.m003-*	(=buftmk) leave only tally
	sta	oprcnt-*	save
	ila	0
	ssa	oprcnt-*	make negative
	rem
	lda	oprsx3-*	reload x3 value
	ora	l.m005-*	(=char bits)
	iaa	bf.dta	point at data
	cax3		put into x3
	rem
opr010	lda	0,3,b.0	pick up char
	iana	63	drop to 6 bits
	alp	18	get the parity on it
	tnz	2	all ok now
	iora	64	or in 7th bit for odd-parity
	sta	0,3,b.0	replace char
	iacx3	0,3,b.1	bump ptr
	aos	oprcnt-*	decrement count
	tmi	opr010-*	loop for all chars
	rem
oprret	return	outpar	done
	rem
oprcnt	bss	1
	ttls	oscan - scan the output to get t.pos
oscan	subr	scn,(x1,x2,x3,a)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	oscan
*
*	scans an output buffer and updates the column
*	position in t.pos accordingly.
*
*	upon entry:
*	     x1 - virtual tib address
*	     x3 - virtual buffer address
*
*	returns:
*	     updated column position in t.pos
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	ldx2	t.sfcm,1	get virtual sfcm address
	lda	sf.flg,2	asynchronous?
	cana	l.n004-*	=sffsyn
	tnz	scnret-*	no
	rem
	rem		see if output scan is needed
	lda	t.flg,1	get tib flags
	cana	l.m006-*	(=tftbec) tabecho mode ?
	tnz	scn010-*	yes, must scan
	cana	l.n011-*	(=tfecpx+tfcrec) echoplex or crecho mode?
	tze	scnret-*	no, skip scan
	rem
	ldx2	t.dtp,1	any delay table ?
	tze	scnret-*	no, skip scan
	szn	dl.cr,2	any cr delays ?
	tze	scnret-*	no, skip scan
	rem
scn010	lda	bf.tly,3	get buffer tally
	ana	l.n002-*	(=buftmk) leave only tally
	iaa	0	anything to scan ?
	tze	scnret-*	nope
	tmi	scnret-*	be serious
	sta	scntly-*	save tally
	rem
	cx3a		put buffer addr in a
	iaa	bf.dta	get addr of data
	ora	l.n001-*	(=0,b.0) make char address
	cax3		put it in x3
	tsy	a.o003-*,*	=getcmt, get the addr of cmt in x2
	stx2	scncmt-*	save addr
	rem
scn020	ldx2	scncmt-*	get cmt addr
	stz	scnidx-*	zero index
	rem
	ilq	4-1	set max cmt table size
	lda	t.flg2,1	get tib flags
	cana	l.n006-*	(=tfsftr) is this one a shifter?
	tze	2	nope
	iaq	2	extend cmt, look at shifts
	rem
	lda	0,3,b.0	get the char we are interested in
	ana	l.n007-*	(=000177) mask out parity
	sta	scnchr-*	save it
scn030	cmpa	0,2,b.0	is it a special char?
	tze	scn040-*	yes, process
	rem
	cmpq	scnidx-*	at max yet?
	tze	scn031-*	yes, character not found in cmt
	rem
	aos	scnidx-*	bump index word
	iacx2	0,b.1	bump cmt ptr
	tra	scn030-*	loop processing more cmt chars
	rem
	rem	not in cmt, must be regular char
	rem
scn031	lda	t.flg2,1	get the tib flag bits
	cana	l.n006-*	(=tfsftr) shifty device?
	tze	scn035-*	no
	rem
	lda	t.flg2,1
	cana	l.n005-*	(=tfupsf) in upshift now?
	tze	scn037-*	no
	lda	0,3,b.0	get the char
	iora	64	set 100 bit
	sta	0,3,b.0	replace char
	tra	scn037-*
	rem
scn035	lda	scnchr-*	get current character again
	icmpa	32	is it a printing char?
	tmi	scn200-*	no, get out
	rem
scn037	lda	t.pos,1	get current position
	icmpa	255	over limit ?
	tpl	scn200-*	yes, don't increment
	rem
	aos	t.pos,1	increment position
	tra	scn200-*	continue
	rem
scn040	ldx2	scnidx-*	get the index value
	tra	a.n001-*,*	(=scntbl,2*) go to right routine
	rem
scntbl	ind	scn050	line-feed
	ind	scn060	carriage return
	ind	scn070	tab
	ind	scn080	backspace
	ind	scn090	upshift
	ind	scn100	downshift
	rem
scn050	null		linefeed
	stz	t.pos,1	reset column position
	tra	scn200-*
	rem
scn060	null		carriage return
	stz	t.pos,1	reset column position
	tra	scn200-*
	rem
scn070	null		tab
	ldq	t.pos,1	get current position
	ila	0	prepare to divide aq
	dvd	l.n003-*	(=10) divide by 10
	stq	scntmp-*	save remainder
	rem
	ila	10	get max cols per tab
	sba	scntmp-*	get cols moved
	ada	t.pos,1	this will be new column position
	icmpa	255	over limit ?
	tpl	scn200-*	yes, don't increment
	sta	t.pos,1	update column position
	tra	scn200-*
	rem
scn080	lda	t.pos,1	backspace
	tze	scn200-*	already in column 0, do nothing
	iaa	-1	otherwise decrement column position
	sta	t.pos,1
	tra	scn200-*	done
	rem
scn090	lda	l.n005-*	(=tfupsf) set bit on
	orsa	t.flg2,1	in tib, we are upshifted now
	tra	scn200-*
	rem
scn100	lda	l.n005-*	(=tfupsf) get bit
	iera	-1	complement it
	ansa	t.flg2,1	turn it off in tib
	rem
scn200	iacx3	0,b.1	bump buffer ptr
	rem
	ila	-1	decrement
	asa	scntly-*	the scan tally
	tnz	scn020-*	loop for more
	rem
scnret	return	oscan
	rem
	ttls	scan - scan and process an input buffer
scan	subr	isc,(x1,x2,x3)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	scan
*
*	calls inproc to scan an input buffer, update the column
*	position in t.pos accordingly, perform echoing and
*	beginning of frame detection when scanning the current
*	input buffer.
*
*	upon entry:
*	     x1 - virtual tib address
*	     x3 - virtual buffer address
*
*	returns:
*	     updated column position in t.pos
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	ldx2	a.n006-*,*	.crbpe
	lda	0,2	save buffer pte
	sta	iscpte-*	which callers count on being preserved
	rem
	ldx2	t.sfcm,1	get virtual sfcm address
	lda	sf.flg,2	asynchronous?
	cana	l.n004-*	=sffsyn
	tnz	iscret-*	no
	rem
	lda	t.flg2,1	save tffip for later comparison
	ana	l.n012-*	=tffip
	sta	scnfrm-*
	rem
	ldx3	sf.hcm,2	get hwcm address
	lda	sf.nic,2	get addr of next char to process
	tnz	isc010-*	if any
	lda	iscsx3-*	otherwise, use beginning of buffer
	ora	l.n011-*	0,b.1
	rem
isc010	sta	fstchr-*	temp store begin point
	ana	l.n008-*	(=o077777) make it word address
	sta	fstwrd-*
	lda	sf.flg,2	now find out which icw we're on
	icana	sffcii
	tze	2
	iacx3	h.ric1-h.ric0
	lda	iscpte-*	get page base address
	iana	-256	mask down to address only
	sta	iscbas-*
	ldaq	0,3	get address of hardware's next char
	rem		make sure it's in high memory
	tmi	isc013-*	high-order bit is on, it is
	cmpa	l.n014-*	(bwndow)
	tmi	isc015-*	below buffer window, so skip page address
	rem		manipulation
isc013	sba	iscbas-*	get offset within page
	ada	l.n014-*	(bwndow) buffer window base address
isc015	sta	nxtwrd-*	this is word part of next address
	llr	18	switch a and q
	als	2	shift out 18-bit addressing flag
	arl	15	get character addressing flag in low 3 bits
	qls	3	move word address up next to it
	lrl	3	now whole thing is in the q
	stq	nxtchr-*	save it
	lda	nxtwrd-*	get word address
	caq
	sbq	fstwrd-*	find word difference
	qls	1	convert to chars
	lda	l.n009-*	=o100000
	cana	fstchr-*	started on odd char?
	tze	2	no
	iaq	-1	yes, one character less
	cana	nxtchr-*	ended on odd char?
	tze	2	no
	iaq	1	yes, one character more
	iaq	0	is total any chars at all?
	tze	iscret-*	no
	tmi	iscret-*	and no
	rem
	lda	sf.flg,2	get ebcdic bit for inproc
	iana	sffebd
	ldx3	fstchr-*	get address
	tsy	a.n002-*,*	inproc
	ldx3	nxtchr-*	update scan pointer now
	stx3	sf.nic,2
	sta	scntmp-*	hang on to returned flags
	lda	t.flg2,1	did we enter or leave a frame?
	ana	l.n012-*	=tffip
	cmpa	scnfrm-*	same as before?
	tze	isc020-*	yes
	lda	l.n013-*	(=sffnib) no, we'll need a different buffer size
	orsa	sf.flg,2
isc020	lda	scntmp-*	get returned flags
	icana	retsus	output_suspend char?
	tze	isc030-*	no
	tsy	a.n004-*,*	(susout) yes, manipulate icws
	tra	iscret-*	and done
isc030	icana	retres	output_resume char?
	tze	isc040-*	no
	tsy	a.n005-*,*	(resout) yes, restore icws
	tra	iscret-*	done
isc040	icana	reteco	inproc added char(s) to echo buffer?
	tze	iscret-*	no
	lda	sf.flg,2	get sfcm flag bits
	icana	sffech	echoing on now?
	tnz	iscret-*	yes, done
	rem
	lda	sf.pcw,2	look at pcw bits
	icana	pb.xmt	are we already xmiting?
	tnz	iscret-*	yes, done
	rem
	tsy	a.n003-*,*	(=echock) try to do echoing
	tra	iscret-*	echoing started
	rem
iscret	ldx2	a.n006-*,*	.crbpe
	lda	iscpte-*	restore original pte
	sta	0,2
	return	scan
	rem
	rem
scntmp	bss	1
scncmt	bss	1
scnidx	bss	1
scntly	bss	1
scnchr	bss	1
scnfrm	bss	1
fstchr	bss	1
fstwrd	bss	1
nxtchr	bss	1
nxtwrd	bss	1
iscbas	bss	1
iscpte	bss	1
	rem
l.n001	ind	0,b.0
l.n002	vfd	18/buftmk
l.n003	dec	10
l.n004	vfd	18/sffsyn
l.n005	vfd	18/tfupsf
l.n006	vfd	18/tfsftr
l.n007	oct	000177
l.n008	oct	077777
l.n009	oct	100000
l.n010	vfd	18/tfcrec
l.n011	ind	0,b.1
l.n012	vfd	18/tffip
l.n013	vfd	18/sffnib
l.n014	vfd	18/bwndow
	rem
a.n001	ind	scntbl,2*
a.n002	ind	inproc
a.n003	ind	echock
a.n004	ind	susout
a.n005	ind	resout
a.n006	ind	.crbpe
	rem
	rem
reteco	bool	000001
retsus	bool	000002
retres	bool	000004
	rem
	rem
a.o001	ind	setbpt
*a.o002
a.o003	ind	getcmt
	rem
*l.o001
*l.o002
l.o003	ind	eb.dta,b.1
*l.o004
*l.o005
*l.o006
*l.o007
*l.o008
*l.o009
l.o010	vfd	18/tfrpon
	ttls	geteb - get chars from the echo buffer
geteb	subr	geb,(x1,x2,x3)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	geteb
*
*	     subroutine to get the pointer and tally of
*	chars in the echo buffer which are to be
*	echoed now.
*
*	input:
*	     x1 - virtual tib address
*	     x2 - virtual sfcm address
*
*	output:
*	     a - char address of data
*	     q - tally in chars
*
*	calling sequence:
*	     tsy   geteb-*
*	     tra   fail-*  no more to echo
*	     tra   good-*  got some chars
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	ldx3	t.echo,1	get ptr to echo buffer
	tze	geb005-*	none
	rem
	lda	t.flg2,1	get tib flag bits
	cana	l.o010-*	(=tfrpon) replay on?
	tnz	geb005-*	yes, inhibit removal from echo buffer
	rem
	cx3a		convert echo buffer address
	tsy	a.o001-*,*	(setbpt) to virtual
	cax3
	lda	eb.tly,3	get the echo buffer tally
	ars	9	shift
	tnz	geb010-*	we have some
	rem
geb005	lls	36	zero aq
	tra	gebret-*	return, fail exit
	rem
geb010	lda	eb.otp,3	get ptr to chars to be echoed
	als	3
	arl	3	drop char addressing
	sta	gebadr-*	save
	cx3a		get echo buf ptr again
	iaa	32	point to end
	sba	gebadr-*	get difference
	als	1	multiply by two
	sta	gebtly-*	save
	rem
	lda	eb.otp,3	get outptr
	ars	15	leave only char bits
	icana	1	is it odd char?
	tze	geb020-*	no, ok
	rem
	lda	gebtly-*	fix up the tally
	iaa	-1
	sta	gebtly-*
	rem
geb020	ldx2	eb.otp,3	get ptr
	stx2	gebadr-*	save it
	lda	eb.tly,3	get the real tally
	lrs	9	into lower a
	cmpa	gebtly-*	compare against max possible
	tpl	geb030-*	more, use tally to end of buffer
	rem
	sta	gebtly-*	less, use real tally
	ldx2	eb.inp,3	advance otp to inp
	tra	geb040-*
	rem
geb030	sta	gebtmp-*	save value of a reg
	cx3a		get ptr to base of buffer
	ada	l.o003-*	(=eb.dta,b.1) point to start of data
	cax2		put into x2 now
	lda	gebtmp-*	get back saved a reg
	rem
geb040	sba	gebtly-*	get new tally
	lls	9	get back into position
	sta	eb.tly,3	put back into eb
	rem
	stx2	eb.otp,3	reset otp now
	rem
	aos	geteb-*	bump return addr to good
	ldaq	gebadr-*	get return args
	rem
gebret	return	geteb
	rem
	even
gebadr	bss	1
gebtly	bss	1
	rem
gebtmp	bss	1
	ttls	echock - check to see if any echoing to do
echock	subr	eck,(x3)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	echock
*
*	     subroutine to test if any chars in echo buf
*	and start echoing if there are.
*
*	upon entry:
*	     x1 - virtual tib address
*	     x2 - virtual sfcm address
*
*	returns:
*	     +1 - if echoing started
*	     +2 - if no echoing to do
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	lda	t.stat,1	make sure data set leads are up
	ana	l.t001-*	=tsfdtr+tsfdsr+tsfcts+tsfcd
	cmpa	l.t001-*	they must all be on
	tnz	eck020-*	we won't echo to a dead line
	rem
	lda	t.flg,1	nor to one whose output is suspended
	cana	l.t003-*	=tfosus
	tnz	eck020-*
	rem
	tsy	geteb-*	check the echo buffer
	tra	eck020-*	none, return +2
	rem
	staq	eckicw-*	save icw for now
	rem
	ldx3	sf.hcm,2	get ptr to hwcm region
	iacx3	h.sic0	point at primary icw
	rem
	lda	sf.flg,2	get flags
	icana	sffcoi	alternate icw?
	tze	eck010-*	no
	rem
	iacx3	h.sic1-h.sic0	bump up to alt
eck010	ldaq	eckicw-*	get the icw to use
	tsy	a.t002-*,*	(bldicw) put into icw
	rem
	ila	sffech	get flag for echo
	orsa	sf.flg,2	turn it on
	rem
	ila	pb.xmt	get xmit mode for pcw
	orsa	sf.pcw,2	turn it on too
	rem
	lda	l.t002-*	(=p.nop) get pcw command
	tsy	a.t001-*,*	(=cioc) connect to channel
	rem
	tra	eckret-*	done
	rem
eck020	aos	echock-*	bump return addr
	rem
eckret	return	echock	return to caller
	even
eckicw	bss	2
	rem
	rem
a.t001	ind	cioc
a.t002	ind	bldicw
	rem
	rem
l.t001	vfd	18/tsfdtr+tsfdsr+tsfcts+tsfcd
l.t002	vfd	18/p.nop
l.t003	vfd	18/tfosus
	ttls	hcheck - start echoing if not in xmit
	rem
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
*
*	this routine is called by the inproc subroutine of the
*	utilities in order to make sure echoing starts before sending
*	status to the control tables.
*
*	upon entry:
*	     x1 - virtual tib address
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
	rem
hcheck	subr	hch,(x2)
	ldx2	t.sfcm,1
	lda	sf.pcw,2	find out if in xmit now
	icana	pb.xmt
	tnz	hchret-*	we are, deal with echoing later
	tsy	echock-*	else start it now
	tra	hchret-*	if there is any
hchret	return	hcheck
	ttls	subroutines to suspend and resume output
	rem
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
*
*	this routine is called by scan if inproc returns an indication
*	that an output_suspend character was received. It will turn off
*	the transmitter by cioc with a pcw with ^pb.xmt off. If a 
*	tally runout occurs, it will not process it now but later when
*	resume is performed. If pre-tally runout occurs, it will be 
*	processed normally and t.ocur will reflect the changes.
*	upon entry:
*	    x1 - tib address
*	    x2 - sfcm address
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
	rem
susout	subr	sus,(x3,i)
	lda	t.flg,1	suspend already in progress?
	cana	l.s005-*	(=tfosus)
	tnz	susret-*	yes, punt for now
	lda	sf.pcw,2	in transmit at the moment?
	icana	pb.xmt
	tze	sus010-*	no, skip pcw manipulation
*
*	NOTE: inh is not really needed, but make a smooth
*	transaction and insure minimum amount of output
*	being transmitted at this time 
*
	inh		<+><+><+><+><+><+><+><+><+><+>
	lda	l.s002-*	(=^pb.xmt) load mask to flip xmt
	ansa	sf.pcw,2	set xmt off in pcw
	lda	l.s007-*	=p.nop
	tsy	a.s002-*,* cioc
sus010	lda	l.s005-*	(=tfosus)
	orsa	t.flg,1	mark tib to show output suspended
susret	return	susout
	eject
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
*
*	this subroutine is called when inproc detects an output_resume
*	character. It turns off the "output suspended" flag, then checks
*	to see if anything is on t.ocur; if so it will restart the output
*	channel by pcw connect, else it will simulate output TRO by
*	calling the optro routine.
*	upon entry:
*	    x1 - tib address
*	    x2 - sfcm address
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
	rem
	rem
resout	subr	res
	lda	t.flg,1	suspended?
	cana	l.s005-*	tfosus
	tze	resret-*	no, return
	lda	l.s006-*	^tfosus
	ansa	t.flg,1	turn the flag off
	szn	t.ocur,1	any pending output chain?
	tze	res010-*	no, simulate tro
	ila	pb.xmt	else go back into transmit
	orsa	sf.pcw,2
	lda	l.s007-*	=p.nop
	tsy	a.s002-*,*	cioc
	tra	resret-*	done
	rem
res010	tsy	a.s003-*,*	optro
resret	return	resout
	rem
	rem
	rem
*l.s001	unused
l.s002	vfd	o18//pb.xmt	revert xmit pcw mask
*l.s003	unused
l.s004	oct	010000	icw exhaust and 0 tally
l.s005	vfd	18/tfosus
l.s006	vfd	o18//tfosus
l.s007	vfd	18/p.nop	pcw no-op command
*l.s008	unused
*l.s009	unused
*l.s010	unused
	rem
	rem
*a.s001	unused
a.s002	ind	cioc
a.s003	ind	optro
	rem
	ttls	opptro - output pre-tally runout status
opptro	subr	opt,(x1,x2,x3)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	opptro
*
*	     process the pre-tally runout status. this
*	is stored as the hsla picks up the last char from
*	the buffer and therefore we will setup a new output
*	buffer and icw.
*
*	upon entry:
*	     x1 - virtual tib address
*	     x2 - virtual sfcm address
*	     x3 - virtual buffer address
*
*	returns:
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	lda	sf.flg,2	get the sfcm flafs
	icana	sffech	is a tab, cr, lf, echo in progress?
	tnz	optret-*	yes, all done here
	rem
	ldx3	a.k009-*,*	.crbpe
	lda	0,3	get current page base address
	sta	optpte-*	save it
	lda	t.ocur,1	get t.ocur, points to buffer just finished
	tze	opt015-*	somebody dumped while we weren't looking
	tsy	a.k007-*,*	setbpt
	cax3		virtual version of t.ocur
	lda	bf.flg,3	get buffer flags
	cana	l.k009-*	check hold output buffer flag
	tze	opt006-*	no - as usual
	cana	l.k010-*	check last buffer in message flag
	tze	opt006-*	no - as usual
	stz	t.ocur,1	break chain here
	tra	opt008-*
opt006	null
	lda	bf.nxt,3	get the next ptr
	sta	t.ocur,1	update t.ocur
	rem
opt008	null
	lda	sf.flg,2	get sfcm flag word
	icana	sffcoi	are we using alternate?
	tze	2	nope, continue
	iacx2	sf.ob1-sf.ob0	add offset of alternate
	stz	sf.ob0,2	zero correct buffer ptr (note use of x2)
	ldx2	t.sfcm,1	restore sfcm ptr
	rem
	szn	t.ocur,1	any more buffers left
	tze	opt010-*	no, zero last ptr also
	rem
	lda	t.ocur,1	get ptr to first
	tsy	a.k007-*,*	(setbpt)
	cax3		in virtual form
	lda	bf.flg,3	get buffer flags
	cana	l.k010-*	(=bfflst) last buffer in msg?
	tnz	opt015-*	yes, leave here
	rem
	szn	bf.nxt,3	look at next ptr in first
	tze	opt015-*	no more, all done
	rem
	ila	0	indicate sffcoi is inactive now
	tsy	a.k003-*,*	(=nobicw) setup new output icw
	rem
	tra	opt020-*	all done
	rem
opt010	stz	t.olst,1	zero the last pointer
	rem
	lda	l.k018-*	(=tfwrit) get flag bit
	iera	-1	flip it over
	ansa	t.flg,1	and turn it off in tib
	rem
opt015	ldx3	sf.hcm,2	we will now zero address field of icw
	lda	sf.flg,2	find out which one
	icana	sffcoi
	tze	2
	iacx3	h.sic1-h.sic0	adjust x3 accordingly
	stz	h.sic0,3	this will be correct icw
	rem
opt020	ldx3	a.k009-*,*	.crbpe
	lda	optpte-*	get original pte back
	sta	0,3	restore it
	ldx3	optsx3-*	get ptr to buffer just finished
	tze	optret-*	someone did a stpchn, don't bother
	tsy	a.k002-*,*	(freout) free it and update count
optret	null
	lda	a.k008-*,*	get saved status word
	cana	l.k007-*	(=hs.siw) are we switching icw's?
	tze	3	don't change sffcoi in not
	ila	sffcoi	get the current icw switch
	ersa	sf.flg,2	flip it over in flag word
	rem
optfin	return	opptro
	rem
optpte	bss	1	safe store for buffer pte
	ttls	houtav - hsla output available entry
houtav	subr	hav,(x1,x2,x3)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	houtav
*
*	     routine to setup icws for output which may
*	arrive at the right time from a send_output
*	op to the cs.
*
*	upon entry:
*	     x1 - virtual tib address
*
*	returns:
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	ldx2	t.sfcm,1	get ptr to sfcm for this guy
	tze	havret-*	none, forget it
	ldx3	sf.hcm,2	get ptr to hwcm
	rem
	lda	h.sic0+1,3	get tally word of first
	ora	h.sic1+1,3	get tally word of second
	cana	l.k002-*	(=010000) is either exhaust bit on?
	tze	havret-*	no, made in plenty of time
	rem
	lda	t.flg,1	is output suspended?
	cana	l.k006-*	tfosus
	tnz	havret-*	yes, don't interfere
	rem
	lda	h.sic0+1,3	get first again
	ana	h.sic1+1,3	get the second
	cana	l.k002-*	(=010000) are they both on?
	tnz	havret-*	yes, return, too late to act
	rem
	lda	h.sic0+1,3	get first yet again
	cana	l.k002-*	(=010000) was this the one?
	tze	hav010-*	no
	lda	sf.flg,2	yes, see if software thinks it's active
	cana	l.k001-*	=sffcoi
	tze	havret-*	it does, there's status pending
	tra	hav020-*	go ahead
hav010	lda	sf.flg,2	alternate was exhausted
	cana	l.k001-*	(=sffcoi) did we think it was active?
	tnz	havret-*	yes, there must be status pending
	rem
hav020	lda	t.ocur,1	get ptr to t.ocur
	tsy	a.k007-*,*	setbpt
	cax3		virtual
	szn	bf.nxt,3	check to make sure all is ok
	tnz	2	yes
	die	12	no bad error
	rem
	ila	1	indicate that sffcoi is active now
	tsy	a.k003-*,*	(=nobicw) go setup icws
	rem
havret	return	houtav
	ttls	nobicw - new output buffer icw setup
nobicw	subr	nob,(a,x1,x2,x3)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	nobicw
*
*	     setup the output icw and buffer for the
*	next output buffer in the chain.
*
*	upon entry:
*	     x1 - virtual tib address
*	     x2 - virtual sfcm address
*	     a = 0 sffcoi points to inactive icw
*		 1 sffcoi points to active icw        
*
*	returns:
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	ldq	sf.hcm,2	get addr of hwcm
	lda	t.sfcm,1	get addr of sfcm also
	rem
	iaq	h.sic0	get offset of icw 0
	iaa	sf.ob0	and buf0
	sta	nobibp-*	save it away
	stq	nobiwp-*	and this also
	rem
	lda	sf.flg,2	get the flags
	szn	nobsa-*	check input arg
	tze	2	normal, sffcoi points to inactive one
	iera	sffcoi	invert meaning of sffcoi
	rem
	icana	sffcoi	alt?
	tze	nob010-*	nope, continue
	rem
	ila	h.sic1-h.sic0	get the diff
	asa	nobiwp-*	update word
	ila	sf.ob1-sf.ob0	get other diff
	asa	nobibp-*	update word
	rem
nob010	lda	t.ocur,1	get the current buffer ptr
	tsy	a.k007-*,*	setbpt
	cax3
	lda	bf.nxt,3	get the next guy
	sta	nobibp-*,*	put into sfcm
	tsy	a.k007-*,*	setbpt
	cax3		hang on to virtual address
	stx3	nobbuf-*	save it away as well
	rem
	iaa	bf.dta	add in offset of data
	ora	l.k003-*	(=0,b.0) get char addressing flags
	caq		hang on to it
	rem
	lda	bf.tly,3	get the tally from buffer
	ana	l.k004-*	(=buftmk) isolate tally
	llr	18	switch a and q
	ldx3	nobiwp-*	get the icw ptr
	tsy	a.k010-*,*	(bldicw) store icw
	rem
	ldx3	nobbuf-*	get latest buffer pointer back
	lda	l.k016-*	(=sffhdl)
	cana	sf.flg,2	is it HDLC?
	tze	nob020-*	no
	lda	bf.flg,3	get buffer flags
	cana	l.k010-*	(=bfflst) last buffer ?
	tze	nob020-*	no
	rem
	lda	l.k014-*	(=pb.tre) get tally runout enable bit
	orsa	sf.pcw,2	turn it on in saved pcw
	lda	l.k013-*	(=p.ris) get pcw opcode
	tsy	a.k011-*,*	(=cioc) connect
	rem
nob020	tsy	a.k005-*,*	(=oscan) scan output buffer
	tsy	a.k001-*,*	(=outpar) put parity on ebcdic
	rem
nobret	return	nobicw
	rem
nobibp	bss	1
nobiwp	bss	1
nobbuf	bss	1
	rem
	rem
	rem
l.k001	vfd	18/sffcoi
l.k002	vfd	o18/010000
l.k003	ind	0,b.0
l.k004	vfd	18/buftmk
l.k005	vfd	18/p.nop
l.k006	vfd	18/tfosus
l.k007	vfd	18/hs.siw
l.k008	vfd	18/bffctl
l.k009	vfd	18/bffhld	hold output buffer flag
l.k010	vfd	18/bfflst	last buffer in message flag
l.k011	vfd	18/c.rrec+c.rdtr+c.sbrk
l.k012	vfd	18/tfacu
l.k013	vfd	18/p.ris
l.k014	vfd	18/pb.tre
*l.k015	see below
l.k016	vfd	18/sffhdl
*l.k017	unused
l.k018	vfd	18/tfwrit
	even
l.k015	oct	0,1	for adding 1 to doubleword
	even
havcnt	bss	2
	rem
	rem
a.k001	ind	outpar
a.k002	ind	freout
a.k003	ind	nobicw
a.k004	ind	denq
a.k005	ind	oscan
a.k006	ind	echock
a.k007	ind	setbpt
a.k008	ind	stpswd	status save word
a.k009	ind	.crbpe
a.k010	ind	bldicw
a.k011	ind	cioc
	ttls	optro - output tally runout status
optro	subr	otr,(x1,x2,x3)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	optro
*
*	     process the tally runout status, this means
*	that the output is finished, or that we didnt
*	reconnect the next buffer in time.
*
*	NOTE: if output is in suspend state, this routine will
*	be no-op by a tra to otrret.
*
*	upon entry:
*	     x1 & x2 -as usual
*
*	returns:
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	lda	t.flg,1	was output suspended?
	cana	l.l003-*	tfosus
	tze	otr050-*	no, normal processing
	rem
	tra	otrret-*	no processing for now
	rem
otr050	szn	t.dcwl,1	any dcw list to do?
	tze	otr060-*	no, check echo
	rem
	ldx3	t.dcwa,1	get addr of said list
	lda	0,3	get the dcw
	arl	15	get op type
	icmpa	dl.cmd	is it cmd dcw?
	tnz	otr060-*	no, not so important
	rem
	lda	0,3	reload dcw
	cana	l.k011-*	(=c.rrec+c.rdtr+c.sbrk) ?
	tnz	otr070-*	yes, process dcw first
	rem
otr060	tsy	a.k006-*,*	(=echock) test for echoing
	tra	otrret-*	good, there was some
	tra	otr070-*	no, cleanup the remains
	rem
otr070	lda	sf.flg,2	get the sfcm flags
	icana	sffech	is a tab, cr, lf, echo in progress?
	tze	otr080-*	no, cleanup
	rem
	ila	sffech	get the echo flag
	iera	-1	invert the word
	ansa	sf.flg,2	and turn it off in sfcm
	rem
	ila	pb.xmt	get the xmt bit
	iera	-1
	ansa	sf.pcw,2	and turn it off in the pcw
	rem
otr080	lda	t.dcwl,1	any dcw list?
	tze	otrret-*	nope, done
	icmpa	1	exactly one dcw left?
	tnz	otr100-*	no, process it like any other
	ldx3	t.dcwa,1	otherwise see if it's a normal end-of-output
	lda	0,3	get the subop
	cmpa	otrdc1-*	=(cmd rxmit+sterm)
	tnz	otr100-*	 no, check for one other special
	stz	t.dcwl,1	we're going to take care of dcwlist now
	tsy	gentrm-*	do terminate status
	tra	otrret-*	done
	rem		check for same but also turning off rts
otr100	tsy	a.l003-*,*	(=hdcw) call dcw processor
	rem
otrret	return	optro
	rem
	rem
otrdc1	cmd	c.rxmt+c.strm
otrdc2	cmd	c.rxmt+c.rrqs+c.strm
otrdc3	cmd	c.rrqs
	ttls	opxte - output transfer timing error status
opxte	subr	oxt,(x1)
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	opxte
*
*	     output transfer timming errors are very
*	unusual, and in debugging mode we will
*	die on them, otherwise ctrl tables will
*	be poked with status
*
*	upon entry:
*	     x1 - virtual tib address
*	     x2 - virtual sfcm address
*
*	returns:
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	lda	t.stat,1	get the tib status bits
	iana	s.dss	but only the ones we want
	ora	l.l002-*	(=s.xte) get the xte status
	tsy	a.l004-*,*	(=istat) call intrp
	rem
	ife	sw.dbg,1,1
	die	7
	rem
	return	opxte
	ttls	gentrm - subroutine to generate output terminate status
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	gentrm
*
*		this subroutine is called by optro to generate terminate
*	status and clean up after exiting transmit mode
*
*	upon entry:
*		x1 - virtual tib address
*		x2 - virtual sfcm address
*
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
gentrm	subr	gen
	stz	sf.ob0,2	xmit is down, no buffers now
	stz	sf.ob1,2
	ldx3	sf.hcm,2	get hardware comm address
	lda	l.l006-*	=o410000
	sta	h.sic0+1,3	mark both send icws exhausted
	sta	h.sic1+1,3
	lda	l.l007-*	=^tsfxmt
	ansa	t.stat,1	not in xmit now
	ila	pb.xmt	mark sf.pcw also
	iera	-1
	ansa	sf.pcw,2
	lda	t.stat,1	get current status
	iana	s.dss	interesting part
	ora	l.l008-*	(=s.term) set terminate status
	tsy	a.l004-*,*	istat
	return	gentrm
	rem
	rem
	rem
*l.l001		unused
l.l002	vfd	18/s.xte
l.l003	vfd	18/tfosus
l.l004	vfd	18/sffcoi
*l.l005	unused
l.l006	oct	410000	exhausted icw tally word
l.l007	vfd	o18//tsfxmt
l.l008	vfd	18/s.term
*l.l009	unused
*l.l010	unused
l.l011	vfd	o18//tfosus
	rem
a.l001	ind	otrdc3
a.l002	ind	setbpt
a.l003	ind	hdcw
a.l004	ind	istat
a.l005	ind	resout
	ttls	freout subroutine, frees output buffer
	rem
	rem	this subroutine is called when output from a buffer is
	rem	finished. its job is to free the buffer (unless its
	rem	bffhld flag is on), decrement t.ocnt, and issue a send_output
	rem	request if appropriate
	rem
	rem	at entry:
	rem	   x1 cpntains virtual tib address
	rem	   x3 contains virtual address of buffer
	rem
	rem
freout	subr	fre,(x3)
	rem
	lda	bf.flg,3	get buffer flags
	cana	l.u001-*	check hold output buffer flag
	tnz	freret-*	yes - dont free the buffer
	rem
	cana	l.u002-*	(=bffctl) control info in this buffer?
	tnz	fre010-*	yes, don't decrement count
	rem
	ila	-1	get the minus one
	asa	t.ocnt,1	decrement counter
	rem
	lda	t.flg2,1	get 2nd word of tib flags
	cana	l.u003-*	check if we just used acu
	tnz	fre010-*	there's no output to ask for
	rem
	lda	t.ocnt,1	get new value of count
	icmpa	bufthr	are we at the threshold?
	tnz	fre010-*	no, continue
	rem
	szn	t.ocp,1	is there more output in the FNP already?
	tnz	fre010-*	yes, don't ask for more yet
	rem
	ilq	sndout	get the "send_output" op-code
	tsy	a.u001-*,*	(=denq) queue it up
	rem
fre010	cx3a
	tsy	a.u003-*,*	(cvabs) get absolute address of buffer
	ilq	0	let frebfh get buffer size
	tsy	a.u002-*,*	(=frebfh) free the spent buffer
	rem
freret	return	freout
	rem
	rem
a.u001	ind	denq
a.u002	ind	frebfh
a.u003	ind	cvabs
	rem
l.u001	vfd	18/bffhld
l.u002	vfd	18/bffctl
l.u003	vfd	18/tfacu
	ttls	hsla jump tables
	rem
	rem	macro to create jump tables
	rem
jmptbl	macro
	crsm	on
	idrp	#1
#3#1	ind	invp	interrupt processor (sked$invp)
	zero	0
	tsy	#3#1-*,*
#2#1	vfd	4/h1ch+#1-1,2/#1,5/0,7/schdmn
	dup	5,31
	zero	0
	tsy	#3#1-*,*
subch	set	*-#2#1
subch	set	subch/3
	vfd	4/h1ch+#1-1,2/#1,5/subch,7/schdmn
	idrp
	endm	jmptbl
	rem
	rem
	rem
	rem
	rem	*********************************************************
	rem	*
	rem	* a jump table consists of a three word vector.
	rem	* a jump table is transferred to by the hardware upon an
	rem	* interrupt for this device.
	rem	*
	rem	* word 0 is tsy'ed to by the hardware and thus contains
	rem	*        the ic at the time of the interrupt
	rem	* word 1 contains the instruction tsy scheduler$invp
	rem	* word 2 contains a packed representation of the device
	rem	*        which interrupted -- it has:
	rem	*        4 bits of iom chan #,
	rem	*        2 bits device # (1 - 3 for hsla's),
	rem	*        5 bits subchannel # (0 - 37(8) for hsla's)
	rem	*        7 bits module # for the scheduler.
	rem	*
	rem	*********************************************************
	rem
	rem
hslajt	null
	rem
	jmptbl	(1,2,3)
	rem
	end
