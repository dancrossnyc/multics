* ***********************************************************
* *                                                         *
* * Copyright, (C) Honeywell Information Systems Inc., 1982 *
* *                                                         *
* * Copyright (c) 1972 by Massachusetts Institute of        *
* * Technology and Honeywell Information Systems, Inc.      *
* *                                                         *
* ***********************************************************

	lbl	,scheduler
	ttl	multics/fnp scheduler and timer manager
	pcc	off
	pmc	off
	editp	on
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	scheduler, sked
*
*	     This module is the scheduler and timer manager
*	for the multics/fnp communications system (mcs). it
*	handles all interrupts and dispatches routines to
*	process them. it also will queue routines to be run as soon
*	as possible or delay for some time before letting them run.
*
*	     the timer manager handles the elapsed and interval
*	timers, and includes mechanisms to support time outs
*	for the control_tables and the delayed queueing for the
*	scheduler.
*
*	modified and revised 11/18/74 by mike grady
*	modified 79 jul 26 by art beattie to add support for
*	  dn6670 extended memory.
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
	symdef	sked
	symdef	invp,mdisp,msdsp
	symdef	dspqur,secdsp
	symdef	g3wjt
	symdef	simclk
	symdef	setime
	symdef	etrip
	symdef	timrjt
	symdef	skdata	address of scheduler data
	symdef	etrmon	pointer to ic monitoring data
	symdef	etrint	elapsed timer interval
	symdef	idlmrk	address of one before start of idle loop
	symdef	idloop	address of start of idle loop
	symdef	idlend	address of end of idle loop
	symdef	idlint	idle metering interval (used by init)
	symdef	idlcnt	idle loop count (used by init)
	symdef	idlmax	idle loop maximum count (set by init)
	symdef	idlmin	idle loop minimum count (set by init)
	rem
	symref	trace
	symref	chkiv
	symref	hintr
	symref	dterm
	symref	dmail
	symref	lip
	symref	consol
	symref	tdip
	symref	getbuf
	symref	frelbf
	symref	itmout
	symref	icmon
	symref	gettib
	symref	setptw	set up variable cpu page table word
	rem
	rem
	pmc	save,on
	systm
	tib
	hwcm
	comreg
	pmc	restore
	ttls	symbol definitions
	rem     dsptab symbol definitions
	rem
crtwd	equ	0	control word
prent	equ	1	primary entry point
scent	equ	2	secondary entry point
rqcnt	equ	3	request count
	rem
	rem                     where the control word has the following
	rem                     format:
	rem
	rem            bit  - 0   ** request bit
	rem                   1   ** execution bit
	rem                   2   ** secondary entry pt. present
	rem                 3-17  ** suppression bits
	rem
	rem
	rem     dattab symbol definitions
	rem
stadd	equ	0	starting add. for list of data
entcnt	equ	1	entry count
excnt	equ	2	exit count
msk	equ	3	count mask
	rem
	rem
	rem     dispatcher queuer symbol definitions
	rem
dqlink	equ	0	link word
dqrtn	equ	1	routine address
dqx1	equ	2	x1 - passed to routine when run
dqpri	equ	3	priority
	rem
nmqlk	equ	10	number of permanent queue links
nmdqlk	equ	20	number of permanent delay queue links
	rem
	rem     assigned locations in interrupt saver blocks
	rem
intx1	equ	0	x1
intx2	equ	1	x2
intx3	equ	2	x3
inta	equ	3	a reg.
intq	equ	4	q reg.
intir	equ	5	indicator reg.
intic	equ	6	ic at interrupt
intptw	equ	7	cpu ptw at interrupt
intbpw	equ	8	buffering ptw at interrupt
	rem
	rem
	rem     miscellaneous
	rem
bufsiz	equ	32
dqlpb	equ	bufsiz/4	dispatcher links/buffer
	rem
modtmr	equ	5
	rem
	rem        control word symbol definitions
	rem
rqstbt	bool	400000	request bit
exctbt	bool	200000	execute bit
scdent	bool	100000	secondary entry present
suprmk	bool	/rqstbt*/exctbt*/scdent	suppression mask
	rem
	rem        mask bits for jump table data
	rem
iocmk	bool	740000	mask for ioc#
clmmk	bool	30000	mask for clm#
clmsmk	bool	7600	mask for clmsc#
modmk	bool	77	mask for mod#
	rem
	rem	dispatcher priority definitions
	rem
intpri	bool	7	priority of interpreter
itpri	bool	4	interval timer priority
	rem
	base	8	temporary for debugging
	ttls	trace types and switches
	rem
tt.int	equ	1	trace interrupts
tt.idl	equ	2	trace idle time
tt.run	equ	3	trace running of interrupt rtn
tt.rst	equ	4	trace restart of interrupted routine
tt.rnq	equ	5	trace running of queued routine
tt.set	equ	6	trace set timer calls
tt.itr	equ	7	trace interval timer runouts
tt.que	equ	8	trace dspqur entries
	rem
	rem
ts.int	bool	000002
ts.skd	bool	000004
ts.tim	bool	000010
	ttls	various scheduler macros
	rem
mpy	macro	(multiplier location-*)
	mpf	#1
	lrl	1
	endm	mpy
	rem
	rem
dvd	macro	(divisor location-*)
	qls	1
	dvf	#1
	endm	dvd
	rem
	rem
dspm	macro
	oct	0
	zero	#1
	oct	0,0
	endm
	rem
	rem
chkivs	macro
	tsy	2,*
	tra	2
	ind	chkiv
	endm	chkivs
	rem
	rem
datm	macro
	pcc	save,off
	pmc	save,off
offset	set	0
count	set	0
	pmc	restore
dattab	null
	idrp	#1
	zero	data+offset
	dec	0,0,#1
	pmc	save,off
offset	set	offset+#1
count	set	count+1
	pmc	restore
	idrp
	odd
savtab	bss	10*count
	rem
data	bss	offset
	pcc	restore
	endm
	eject
cmpaq	macro
	crsm	off
	ife	'#2','',2
	cmpa	#1
	ife	1,2,1
	cmpa	#1,#2
	tnz	2
	ife	'#2','',2
	cmpq	#1+1
	ife	1,2,1
	cmpq	#1+1,#2
	crsm	on
	endm	cmpaq
	rem
	rem
tblk	macro	(number of blocks to create)
tcnt	set	#1-1
	dup	2,tcnt
	zero	*+2
	oct	0
	oct	0,0
	endm	tblk
	rem
	rem
dlyblk	macro	(number of blocks to create)
dcnt	set	#1-1
	dup	4,dcnt
	zero	*+6
	oct	0
	oct	0,0
	oct	0,0
	oct	0,0
	oct	0,0
	oct	0,0
	endm	dlyblk
	ttls	links macro
	rem
	rem            this macro is used to generate linked buffers.
	rem         the calling sequence is
	rem
	rem               links     n,l
	rem
	rem            n is the number of buffers to generate
	rem            l is the length of each buffer
	rem            the first word of each buffer points to the
	rem            first word of the next buffer.  the last
	rem            buffer has a pointer of zero
	rem
links	macro
	pmc	save,off
	dup	2,#1-1
	zero	*+#2
	bss	#2-1
	zero	0
	bss	#2-1
	pmc	restore
	endm	links
	ttls	common area for invp, savreg and mdisp
	rem
sked	null
	rem
	even
indreg	oct		indicator register save-store
icreg	oct		ic of the interrupt
modsv	oct		temporary save locations
dtsv	oct		x
asv	oct		x
qsv	oct		x
x1sv	oct		x
zerow	oct		a zero word (always)
reqbt	vfd	18/rqstbt	request bit
excmsk	vfd	18/exctbt	execute bit
secmsk	vfd	18/scdent	secondary entry present
supmsk	vfd	18/suprmk	suppression mask
dstnum	oct		number of interrupted module
	rem
dspta	zero	dsptab	address of dsptab
datta	zero	dattab	"     "  dattab
savra	zero	savtab	address of savtab(must start on odd loc.)
dspi	ind	dsptab,1	indirect word for dsptab
	rem
	rem                     at end of dsptab insert:
	rem                     dspsz     zero   *-dsptab
	rem
	rem
	start	sked,1
	ttls	interrupt vector processor
	rem
***********************************************************
*
*       invp
*
*            input
*                 address of third word of jump table
*               stored in invp.
*
*                  format of jump table:
*
*                1  -  zero        (ic at interrupt)
*                2  -  tsy        invp-*
*                3  -  ioc#,  clm#,  clmsc#,  mod#
*
*              bit #    4  ,   2  ,    5   ,   7
*
***********************************************************
invp	zero		add. of third word of jump table
	sti	indreg-*	save indicator register
	inh		inhibit on
	staq	asv-*	temp. save a register
	stx1	x1sv-*	and x1 register
	rem
*      chkivs
	rem
	ldx1	invp-*
	lda	0,1	have ioc#,clmx#,clmsc#,mod#
	sta	dtsv-*	save for later
	ldx1	-2,1	have ic at interrupt
	stx1	icreg-*	save it
	rem
	iana	modmk	mask out all but mod#
	iaa	-1	subtract 1 from mod#
	als	2	mult. mod# by 4
	sta	modsv-*	save it
	rem
	ada	dspta-*	find right place in dsptab
	cax1		have dsptab add. + 4 x mod#
	rem
	lda	reqbt-*
	orsa	crtwd,1	set request bit on for this mod
	aos	rqcnt,1	add 1 to request count
	rem
	ldx1	datta-*
	adcx1	modsv-*	have dattab add. + 4 x mod#
	lda	entcnt,1	entry count
	cmpa	msk,1	compare to que size
	tmi	invp5-*	ok
	rem
	stz	entcnt,1	reset
	ila	0	this too
	rem
invp5	ada	stadd,1	address of list + entry count
	aos	entcnt,1	add 1 to entry count
	cax1
	lda	dtsv-*	get the saved data
	sta	0,1	store it
	rem
	rem        if requested, trace (1) the ic at the interrupt
	rem       and (2) the third word of the jump table.
	rem
	trace	tt.int,ts.int,(icreg,dtsv)
	rem
	rem	m a s t e r   s a v e r
	rem
	lda	dstnum-*	get mod#
	tze	msdsp-*	were in the dispatcher on the interrupt
	rem
	iaa	-1	mod# is one more than position in dsptab
	mpy	(l.a001-*)	mult. mod# by 10
	cqa
	cax1
	adcx1	savra-*	savtab + 10 x mod#
	ldaq	asv-*	get original contents of aq
	stx2	intx2,1	store x2
	ldx2	x1sv-*	get orig. contents of x1
	stx2	intx1,1
	stx3	intx3,1
	staq	inta,1
	ldaq	indreg-*	get indicator and ic
	staq	intir,1	store indicator and ic
	lda	a.a001-*,*	(.crpte,*) get current page table entry
	sta	intptw,1	store page table entry
	lda	a.a002-*,*	(.crbpe,*) likewise buffer pte
	sta	intbpw,1
	rem
	tra	msdsp-*	go to master dispatcher
	rem
	rem
a.a001	ind	.crpte,*	variable cpu page table entry
a.a002	ind	.crbpe,*
	rem
l.a001	dec	10
	ttls	m a s t e r   d i s p a t c h e r
	rem
	rem     entry on completion of dispatched routine
	rem
mdisp	null
	inh		inhibit on
	lda	dstnum-*	get mod#
	iaa	-1	subtract one
	als	2	mult. by 4
	cax1
	adcx1	dspta-*	dsptab address + 4 x mod#
	lda	excmsk-*	execute mask
	ersa	crtwd,1	turn off execute mask
	rem
	rem     normal entry point from master saver
	rem
msdsp	null
	stz	dstnum-*	set to 0 - are in master dispatcher
	eni		allow interrupts
*      chkivs
	nop
	nop
	rem
msds5	ldx1	zerow-*	zero x1
	rem
msrch	null
	lda	dspi-*,*	examine dsptab (control words)
	tze	nxmd-*	nothing on at all
	rem
	cana	excmsk-*	was mod interrupted?
	tnz	hvint-*	yes
	rem
	cana	supmsk-*	is it suppressed?
	tnz	nxmd-*	yes - continue search
	rem
	cana	reqbt-*	is it requested?
	tnz	hvreq-*	yes
	rem
nxmd	iacx1	4	increment x1 by 4
	cmpx1	dspsz-*	are we at the end of table ??
	tnz	msrch-*	no
	rem
	ttls	idle routine
	rem
	rem	trace state at start of idle
	rem
	rier		read interrupt enable registers
	sta	tcrier-*	save for use in trace
	sti	tcint-*	save indicators register
	rem
*	trace	tt.idl,ts.int,(tcint,tcrier)
	rem
	nop
idlmrk	nop
**********************************************************************
*
*	idle loop increments a counter continuously, which permits
*	metering of idle time by comparing counter to value to its
*	maximum value (which is established during initialization by
*	running the idle loop for a second)
*
**********************************************************************
	rem
idloop	ila	0	get a doubleword 1
	ilq	1
	inh		have to protect load/store sequence
	adaq	idlcnt-*	increment counter
	staq	idlcnt-*
	eni		ok
	tra	idloop-*	go around again until interrupted
idlend	null		so icmon can locate idle loop
	rem
	even
idlcnt	bss	2
tcint	bss	1
tcrier	bss	1
	ttls	run the requested routine
	rem
hvreq	cx1a		get the dsptab offset
	ars	2	divide by 4
	iaa	1	increment by 1
	rem
	inh		inhibit
	sta	dstnum-*	set dstnum to mod# (1,2,3,,,)
	adcx1	dspta-*	address of dsptab + c(x1)
	ila	-1
	asa	rqcnt,1	subtract 1 from rqcnt
	tnz	hv1-*	did request count go to zero?
	rem
	lda	reqbt-*	yes -- set request bit to 0
	ersa	crtwd,1
	rem
hv1	lda	excmsk-*	set execute bit
	orsa	crtwd,1
	rem
*	chkivs
	rem
*	trace	tt.run,ts.int,(prent(1))
	rem
	ldi	zerow-*	initialize the indicator register
	tra	prent,1*	go to routine
	ttls	return to interrupted module
	rem
	rem     module was interrupted:  restore registers and
	rem     transfer to point of interrupt or secondary
	rem     entry point if present.
	rem
hvint	stx1	x1sv-*	save for awhile
	stz	hvsec-*	initialize
	cana	secmsk-*	is there a secondary entry point?
	tze	noscp-*	no
	rem
	aos	hvsec-*	have a secondary entry
	adcx1	dspta-*	have desired 4 word block in dsptab
	ldx2	scent,1	get secondary entry point
	rem
noscp	lda	x1sv-*	get the dsptab offset again
	ars	2	divide by 4 to module offset
	mpy	(l.a001-*)	multiply by 10
	cqa
	cax1		for use in accessing savtab
	adcx1	savra-*	desired block in savtab
	lda	x1sv-*	recover dsptab offset once more
	ars	2	convert to module offset
	iaa	1	add 1, have mod# (1,2,3...)
	rem
	szn	hvsec-*	did we find secondary entry?
	tze	ictr-*	no
	rem
	ldx3	intic,1	yes - get ic at interrupt
	stx3	0,2	store as first word of secondary routine
	iacx2	1
	tra	ictr5-*
	rem
ictr	ldx2	intic,1	ic at interrupt
	rem
ictr5	stx2	icreg-*	store for transfer
	cax2		mod# in x2
	rem
*	trace	tt.rst,tt.int,(icreg)
	rem
	ldx3	intx3,1	restore registers -- x3
	lda	intir,1	get indicator register
	sta	indreg-*	save
	lda	intptw,1	restore page table word
	sta	a.a001-*,*	(.crpte,*)
	lda	intbpw,1	and buffer page table word
	sta	a.a002-*,*	(.crbpe,*)
	rem
	ldaq	inta,1	restore a and q reg.
	inh
	stx2	dstnum-*	set dstnum to mod#
	ldx2	intx2,1	restore x2
	ldx1	intx1,1	and x1
	rem
	rem
	ldi	indreg-*	load indicator reg.
	tra	icreg-*,*	restart the interrupted routine
	rem
	rem
hvsec	bss	1	indicates whether we have secondary entry
	ttls	master dispatcher tables
	rem
	pmc	save,on
	even
dsptab	null
	dspm	lip	lsla_man, module 1
	dspm	dterm	dia_man terminate, module 2
	dspm	dmail	dia_man special, module 3
	dspm	hintr	hsla_man, module 4
	dspm	itrout	timer_manager, module 5
	dspm	consol	console_man, module 6
	dspm	tdip	colts (t&d), module 7
scdspa	vfd	18/scdent
	zero	secdsp
	zero	intsv
	oct	0
	rem
dspsz	zero	*-dsptab
	eject
	datm	(8,2,8,8,2,3,2,1)
	pmc	restore
	odd
grph	bss	10
grpm	bss	10
grpl	bss	10
	rem
	ttls	retrieve jump table data
	rem
*******************************************************
*
*         g3wjt
*                 load q register with saved third word
*                 of jump table and set up registers
*                 x2 and x3 as shown:
*
*               x2 - software communication region
*               x3 - hardware communication region
*
*         calling sequence -
*
*                           tsy      g3wjt-*
*                           return
*
*********************************************************
	rem
g3wjt	subr	g3w,(inh)
	rem
	lda	a.c001-*,*	(=dstnum) get mod number of him
	iaa	-1	subtract one
	als	2	mult. by 4
	ada	a.c002-*	(=dattab) have respective 4 word block
	cax1		in dattab
	rem
	ldx2	excnt,1	exit count
	cmpx2	msk,1	compare to length of que
	tnz	g3wjt5-*	ok
	rem
	stz	excnt,1	reset it
	ldx2	excnt,1	zero  x2 also
	rem
g3wjt5	adcx2	stadd,1	address of list + exit count
	aos	excnt,1	increment exit count
	ldq	0,2	data (ioc#,clm#,clmsc#,mod#)
	cqa
	ana	l.c001-*	(=037600) mask out clm# and clmsc#
	ars	3	convert to relative address
	cax3		x3 - hardware communication region
	ldx2	h.sfcm,3	x2 - software communication region
	rem
	return	g3wjt	return to caller
	rem
l.c001	oct	37600	mask for clm# and subchannel #
	rem
a.c001	zero	dstnum	pointer to interupted module number
a.c002	zero	dattab	pointer to dattab
	ttls	dispatcher queuer
	rem
********************************************************************
*
* dspqur
*      inputs
*             ar  --  time delay/priority
*             qr  --  routine name
*             x1  --  passed to routine when run
*      outputs
*             none
*       registers altered - a,q
*
**********************************************************************
	rem
dspqur	subr	qur,(a,q,x1,x2,x3,inh)
	rem
*	trace	tt.que,ts.skd,(qursa,qursq,x1)
	rem
	lda	qursa-*
	ldq	qursq-*	restore a and q
	icana	-64	(777700) entry for delayed queuer?
	tnz	delayq-*	yes
	rem
	ldx2	lnkptr-*	get link from available chain
	tnz	dspq2-*	unless chain is exhausted
	tsy	a.d010-*,*	(=getqlk) get and format a new block
	ind	lnkchn
	rem
dspq2	sta	dqpri,2	store priority into link
	stq	dqrtn,2	store routine into link
	stx1	dqx1,2	store x1 into link
	ldq	dqlink,2	detatch link from remainder of
	stq	lnkptr-*	availible chain
	rem
	ldq	a.d001-*	(=dque) get address of pointer
	stq	dtmp1-*	to dispatcher queue chain
	rem
	ldx3	dque-*	get start of chain
	tnz	dspq6-*	good chain, start search
	rem
	stz	dqlink,2	make link end of chain
	tra	dspq12-*
	rem
dspq6	cmpa	dqpri,3	search chain until lower priority
	tnc	dspq10-*	is found
	stx3	dtmp1-*	not yet - save previous link
	ldx3	dqlink,3	get next
	tnz	dspq6-*	test for end of chain
	eject
dspq10	stx3	dqlink,2	put the foward pointer into new link
	rem
dspq12	stx2	dtmp1-*,*	make previous link point at new one
	ldx2	a.d002-*	get address of secondary disp. block
	rem
	lda	l.d001-*	(=rqstbt) get request bit
	orsa	crtwd,2	set request bit on for secondary disp.
	ila	1
	sta	rqcnt,2	set request count to one
	rem
dspq20	null
	return	dspqur	return to caller
	rem
dtmp1	oct	0	temp for workspace
	rem
dque	zero	0	pointer to the dispatcher que chain
	rem
	rem
lnkchn	ind	0	extra buffer chain
	ind	nmqlk	number of permanent links
	ind	0	number of calls on getqlk
lnkptr	ind	*+1	pointer to available link chain
	links	nmqlk,4	generate permanent links
	rem
a.d001	ind	dque
a.d002	ind	scdspa
a.d010	ind 	getqlk
	rem
l.d001	vfd	18/rqstbt
	ttls	delayq -- time delay queuer routine
************************************************************************
* the function of this routine is identical to the normal queuer
* routine "dspqur" with the following single exception --
*
*      the routine to be queued will be queued only after
*      the specified time interval has elapsed.
*
* the calling sequence is also identical to that of the normal queuer
* except that bits 0-11 of the accumulator are non-zero and represent
* the desired time delay before the routine is actually queued.
*
* inputs--
*      ar(00-11)= desired time delay, in seconds
*      ar(12-17)= priority
*      qr      = routine address
*      x1      = will be passed to routine when run
*
* outputs -- none
*
************************************************************************
	rem
delayq	null		transfered to by dspqur
	rem
	sel	tmch	select timer channel
	cioc	a.e006-*,*	(=mskpcw) mask the interval timer
	rem
	lda	a.e003-*,*	(=itmb) get the timer value
	sta	dtimer+1-*	save it
	rem
	ldaq	a.e004-*,*	(=simclk) get the simulated clock
	sbaq	dtimer-*	get the current time
	staq	curtim-*	and save it away
	rem
	ldx3	dfree-*	get ptr to free chain
	tnz	2	all ok
	die	1	no more delay queue buffers
	rem
	lda	dfwd,3	get fwd ptr from first blk
	sta	dfree-*	put into free ptr, taking blk
	rem
	lda	qursa-*	restore a reg
	iana	63	leave priority
	sta	dpri,3	put into block
	lda	qursq-*	get the routine addr
	sta	drtn,3	save in block
	ldx1	qursx1-*	get the value of x1
	stx1	dx1,3	save in block, also
	lda	qursa-*	get time value
	ars	6	shift down
	mpy	l.e002-*	(=1000) in to milliseconds
	adaq	curtim-*	add in current time
	staq	dtime,3	and put into block
	staq	ntime-*	save local copy
	rem
	stx3	dnew-*	save addr of new block
	lda	a.e005-*	(=dnext) get addr of next ptr
	sta	dlasta-*	save it also
	rem
	ldx3	dnext-*	get the next ptr, head of chain
	tze	dqr020-*	no chain, start one
	rem
dqr010	ldaq	ntime-*	get the new time
	cmpaq	dtime,3	is ntime < dtime?
	tnc	dqr020-*	yes, chain in here
	rem
	stx3	dlasta-*	save addr of this block
	ldx3	dfwd,3	bump to next block
	tnz	dqr010-*	loop for more
	rem
	ldx3	dnew-*	get ptr to new block
	stx3	dlasta-*,*	store into fwd of last block
	stz	dfwd,3	zero fwd ptr, end of chain
	tra	dqr030-*	all done
	rem
dqr020	cx3a		save addr of current block
	ldx3	dnew-*	get addr of new block
	stx3	dlasta-*,*	put into last block fwd ptr
	sta	dfwd,3	chain ahead to next block
	rem
dqr030	szn	a.e009-*,*	(=itrint) has interval timer run out?
	tnz	dqr060-*	yes, all done, will be set later
	rem
	ldx3	dnext-*	get ptr to first block
	szn	a.e008-*,*	(=runing) is the clock runing?
	tze	dqr032-*	no, just start it
	rem
	ldaq	a.e004-*,*	(=simclk) get the simclk
	cmpaq	dtime,3	is simclk < dtime?
	tnc	dqr050-*	yes, go start clock
	rem
dqr032	ldaq	dtime,3	get the time in block
	sbaq	curtim-*	subtract current time, leaving interval
	tnz	dqr035-*	zero interval, bad
	rem
	ila	0	set to very small one
	ilq	1	like 1 or so
	tra	dqr040-*	done
	rem
dqr035	iaa	0	set the indicators
	tze	dqr040-*	less than max, set clock
	rem
	ila	1	get the max value for clock
	ilq	0	into the aq
	rem
dqr040	stq	a.e003-*,*	(=itmb) set the interval timer
	adaq	curtim-*	get the new simclk time
	staq	a.e004-*,*	(=simclk) and save it
	rem
dqr050	sel	tmch	select the timer channel
	cioc	a.e007-*,*	(=runpcw) start the timer
	aos	a.e008-*,*	(=runing) it is running now
	rem
dqr060	tra	dspq20-*	restore registers and return
	rem
	rem
	even
dtimer	oct	0,0	interval timer value
curtim	oct	0,0	current time
ntime	oct	0,0	new time for new block
	rem
dnext	oct	0	ptr to chain of active blocks
dfree	ind	dlyque	ptr to chain of free blocks
	rem
dlyque	dlyblk	nmdqlk
	rem
dlasta	oct	0
dnew	oct	0
	rem
	rem
a.e003	ind	itmb
a.e004	ind	simclk
a.e005	ind	dnext
a.e006	ind	mskpcw
a.e007	ind	runpcw
a.e008	ind	runing
a.e009	ind	itrint
a.e012	ind	frelbf
	rem
l.e002	dec	1000
	rem
	rem	equates for a delay queue block
	rem
dfwd	equ	0
drtn	equ	1
dtime	equ	2
dx1	equ	4
dpri	equ	5
	ttls	emergency queue link routines
	rem
************************************************************
* the function of this subroutine is to fetch and format
* buffers needed by the normal queuer.  the address of
* the first word of the new link chain is returned
* in x2 on exit.
************************************************************
	rem
getqlk	subr	sub,(a,q)
	rem
	ilq	bufsiz	set size of buffer desired
	tsy	a.i004-*,*	(=getbuf) get a buffer
	die	1	** error - no more buffers  **
	ldx2	getqlk-*,*	get pointer to link control words
	aos	2,2	increment call count
	lda	0,2	get the extended chain
	sta	0,3	link it to the new buffer
	stx3	0,2	set new chain pointer
	iacx3	4	compute first link address
	cx3a		save link address in x2
	cax2
	ilq	dqlpb-2	number of links to link
	rem
get010	iacx3	4	move to next link
	stx3	-4,3	save new pointer in link
	iaq	-1	bump loop control counter
	tnz	get010-*	process next unless done
	rem
	stz	0,3	yes, reset last link pointer to zero
	aos	getqlk-*	increment return address
	rem
	return	getqlk	return to caller
	eject
	rem
************************************************************
* this routine returns to available space the
* buffers used by the queuer routines
************************************************************
	rem
relqlk	subr	rel,(x1,x2,x3,inh)
	rem
	ldx1	relqlk-*,*	get pointer to link control words
	ldq	1,1	get number of permanent links
	iaq	-1
	cx1a
	iaa	4	compute address of first link
	sta	3,1	set new link chain pointer
	cax2
	rem
rel010	iacx2	4	step address to next link
	stx2	-4,2	link it to previous link
	iaq	-1	decrement link count
	tnz	rel010-*	process next unless done
	rem
	stz	0,2	zero last link pointer
	lda	0,1	get the buffer chain
	stz	0,1	clear pointer to it
	tsy	a.e012-*,*	(=frelbf) release the chain
	rem
	aos	relqlk-*	increment return address
	rem
	return	relqlk	return to caller
	ttls	e v e n t   d i s p a t c h e r
	rem
*************************************************************
*
*           purpose - dispatch routines from a queued list
*
*           calling sequence -   tra   secdsp-*
*
*                  input
*                         dque - points to top of
*                                  queued chain
*                         dlink - points to avail. chain
*                         prdrt - set to minus one
*
*                  output
*                         x1 - contains saved value
*                         x3 - contains link address
*                         prdrt - contains priority
*                                    shifted 3 right
*
*************************************************************
	rem
secdsp	null
	rem
*      chkivs
	rem
	inh		inhibit on
	ila	-1	set to minus
	sta	prdrt-*	in the disp. routine
	ldx3	a.h002-*,*	(=dque) get queue pointer
	tnz	dspr10-*	process next entry
	rem
	szn	a.h003-*,*	(=lnkchn) queue empty - any buffers to release
	tze	a.h001-*,*	no - return to master dispatcher
	tsy	relqlk-*	yes - release them
	ind	lnkchn
	tra	secdsp-*	process new entry in queue
	rem
dspr10	lda	dqlink,3	get link address of first rtn queued
	sta	a.h002-*,*	(=dque) update queue pointer
	ldq	a.h004-*,*	(=lnkptr) pres. disp. routine pointer
	stq	dqlink,3	store in queue link
	stx3	a.h004-*,*	(=lnkptr) place on top of availible list
	lda	dqpri,3	get priority
	ars	3	shift right (0,1,2...)
	sta	prdrt-*
	rem
*	trace	tt.rnq,ts.skd,(dqrtn(3))
	rem
	ila	pte.s	turn on security bit in ptws so any reference will
	orsa	a.h005-*,*	(.crpte,*) cause a store fault
	orsa	a.h006-*,*	(.crbpe,*)
	rem
	ldx1	dqx1,3	saved value in x1
	stx1	svx1-*	save for interrupt
	ldi	l.h001-*	(=0) initialize indicator register
	tra	dqrtn,3*	go execute
	rem
	rem
prdrt	oct	400000
svx1	zero
	rem
a.h001	ind	mdisp
a.h002	ind	dque
a.h003	ind	lnkchn
a.h004	ind	lnkptr
a.h005	ind	.crpte,*	variable cpu page table entry
a.h006	ind	.crbpe,*	buffering page table entry
	rem
l.h001	oct	0
	rem
pte.s	bool	100	page table entry security bit
	ttls	secondary level s a v e r
	rem
******************************************************************
*
*            purpose - save all registers of the interrupted
*                      routine in the following block
*                      format:
*
*                   note:  block must start at an
*                          odd location
*
*                              word        contents
*                               0            x1
*                               1            x2
*                               2            x3
*                               3            a reg.
*                               4            q reg.
*                               5            ind. reg.
*                               6            ic at interrupt
*                               7            page table word
*
*
*                    each priority group has its own 7 word
*                    block.  after all saves; get interrupted
*                    routine's priority, tib address and
*                    queue.
*
******************************************************************
	rem
intsv	zero		will contain ic at interrupt on entry
	rem                     from master dispatcher
	sti	sv1-*	save ind. register
	inh		inhibit on
	szn	prdrt-*	were we in dispatched routine?
	tmi	int020-*	no
	tnz	svrg-*	yes- save registers and queue
	rem
	ldi	sv1-*	priority is 0 -- skip queueing
	eni
	tra	intsv-*,*	go to point of interrupt
	rem
svrg	stx1	sv2-*	save registers in respective group
	ldx1	prdrt-*	get priority ( 0,1,2,...
	ldx1	a.i002-*,*	(=grptbl,1) load x1 with add. of group
	staq	inta,1	store a and q reg. in word 3 and 4
	stx2	intx2,1	"    x2 in word 1
	stx3	intx3,1	"    x3 "   "   2
	ldaq	sv1-*	load ind. reg. and x1 in aq
	sta	intir,1	indicator register
	stq	intx1,1	x1 saved in word 0
	lda	intsv-*	ic at interrupt
	sta	intic,1	save in block
	lda	a.h005-*,*	(.crpte,*) get current ptw
	sta	intptw,1	save page table word
	lda	a.h006-*,*	(.crbpe,*)
	sta	intbpw,1	and buffer ptw
	rem
	lda	prdrt-*	get priority
	rem
	als	3	reposition ( 0-7,10-17,...
	ldq	a.i003-*	(=restor) add. of restore routine
	ldx1	svx1-*	restore x1 for restorer
	tsy	a.i001-*,*	(=dspqur) call queuer
	rem
	eni
int020	tra	secdsp-*	return to event dispatcher
	rem
	even
sv1	oct	0	start at even location
sv2	oct	0
	rem
grptbl	zero	grph	points to priority group - h
	zero	grpm	  "    "      "      "     m
	zero	grpl	  "    "      "      "     l
	rem
a.i001	ind	dspqur
a.i002	ind	grptbl,1
a.i003	ind	restor
a.i004	ind	getbuf
	ttls	r e s t o r e r
	rem
******************************************************************
*
*            entered from the dispatcher.
*             restores all registers and transfers to
*             the interrupted routine via ic (word 6
*             of block).
*
******************************************************************
	rem
restor	null
	inh
	ldx1	prdrt-*	get priority ( 0,1,2,..
	ldx1	a.i002-*,*	(=grptbl) load x1 with add. of chain
	ldaq	intir,1	load ind. reg. and ic at interrupt
	staq	sv1-*	store temp
	lda	intptw,1	restore page table entry
	sta	a.h005-*,*	(.crpte,*)
	lda	intbpw,1
	sta	a.h006-*,*	(.crbpe,*)
	rem
	ldaq	inta,1	restore a and q
	ldx2	intx2,1	restore x2
	ldx3	intx3,1	restore x3
	ldx1	intx1,1	restore x1
	ldi	sv1-*	restore indicator register
	tra	sv2-*,*	go finish it
	ttls	etrip -- elapsed timer rollover interrupt processor
************************************************************************
* this routine is implemented directly from the interrupt vector.
*
* this routine handles elapsed timer runouts. it is responsible for idle
* time metering and calling the instruction counter monitor if the latter
* is enabled. the idle meter interval is established at initialization
* time, and is normally one second. the ic monitor interval is dynamically
* configurable, and is apt to be shorter.
*
* when this routine finds that the idle meter interval has expired, it
* updates the running total of the idle loop counter so that user-ring
* programs can determine an average idle time.
*
* the idle loop is run for one meter interval during initialization, to
* establish a maximum value for the counter.
************************************************************************
	rem
etrip	subr	etr,(inh,a,q)
	ldi	l.o001-*	(=024000o) inhibit overflow as well
	lda	etrprv-*	last setting of elapsed timer
	tze	etr035-*	this is first time, don't meter
	cmpa	idlint-*	was it a full idle time interval?
	tpl	etr010-*	yes, meter idle count
	ada	etrcum-*	no, has idle interval passed since we
	cmpa	idlint-*	last recorded it?
	tpl	etr010-*	yes, meter idle now
	sta	etrcum-*	no, update cumulative time
	tra	etr040-*	check for ic monitoring
	rem
etr010	ldaq	a.o001-*,*	idlcnt
	cmpaq	idlmin-*	new minimum?
	tpl	etr020-*	no
	staq	idlmin-*	yes, store it
	tra	etr030-*	don't check for max
etr020	cmpaq	idlmax-*	new maximum?
	tmi	etr030-*	no
	staq	idlmax-*	yes, record it
etr030	adaq	idlcum-*	increment cumulative count
	staq	idlcum-*	save result
	ila	0	get a double-word 1
	ilq	1
	adaq	idlinc-*	to update count of idle meters
	staq	idlinc-*
etr035	null		now zero the counter. note that a reg
	ilq	0	contains 0 no matter how we got here
	staq	a.o001-*,*	idlcnt
	stz	etrcum-*	starting new idle interval
	rem
etr040	szn	etrmon-*	ic monitoring in effect?
	tze	etr050-*	no, skip it
	tsy	a.o002-*,*	(icmon) yes, call routine
etr050	lda	etrint-*	new interval value
	sta	a.o003-*,*	(etmb) to elapsed timer mailbox
	iera	-1	convert to positive number
	iaa	1
	sta	etrprv-*	save for next time
	return	etrip
	rem
	rem
etrprv	bss	1	most recent setting of elapsed timer
etrcum	bss	1	time since last idle measurement
idlint	dec	1000	default idle meter interval (1 second)
	rem
l.o001	oct	024000	inhibit interrupts and overflow
	rem
a.o001	ind	idlcnt	counter kept by idle loop
a.o002	ind	icmon	address of ic monitoring routine
a.o003	ind	etmb	address of elapsed timer
	rem
*	the following data is pointed to .crskd in the comm region
*	ring 4 multics software knows the format of this data
	rem
	even
skdata	null
idlcum	oct	0,0	cumulative value of idle counter
idlinc	oct	0,0	count of increments to ildcum
idlmax	oct	0,0	max value of counter
idlmin	oct	0,0	min value of counter
etrint	dec	-1000	interrupt every second (may be changed)
etrmon	oct	0	address of data block in ic metering module
	rem		(if configured)
	ttls	setime -- routine to set time-outs for tib lines
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	setime
*
*	     setime is a routine called by the control tables
*	via the interpreter to set time-outs for the various ttys
*	so that the line can be prodded every so often to determine
*	its state.
*
*	upon entry:
*	     x1 - virtual tib address for this line
*	     a - time to wait in seconds
*	       - or zero to reset a timer
*
*	returns:
*	     with a timer set to queue itmout when it goes off.
*
*	notes:
*	     If a timer is already running for the line it will
*	just be reset to the new value.
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
setime	subr	set,(x1,x2,x3,a)
	rem
	sel	tmch	select the timer channel
	cioc	mskpcw-*	mask the timer now
	rem
	lda	a.h005-*,*	(.crpte,*) get current cpu page table entry
	sta	savpte-*	save it for return
	rem
	lda	t.line,1	get the line number
	tsy	a.l002-*,*	(gettib) get real tib address
	sta	strtib-*	save it for trace call
	rem
	trace	tt.set,ts.tim,(setsa,strtib)
	rem
	lda	a.l007-*,*	(=itmb) get the value of the interval timer
	sta	itimer+1-*	store it away
	rem
	ldaq	simclk-*	get the simulated clock value
	sbaq	itimer-*	subtract interval timer value
	staq	ctime-*	store as current time
	rem
	ldx3	tnext-*	get the next ptr
	tze	set030-*	none in queue
	rem
	lda	a.l006-*	(=tnext) save addr of next ptr
	sta	tlasta-*	in tlasta for now
	lda	strtib-*	get real tib address
	rem
set010	cmpa	ttib,3	is this the same tib?
	tze	set020-*	yes, process
	rem
	stx3	tlasta-*	save addr of this block
	ldx3	tfwd,3	get fwd ptr
	tze	set030-*	end of queue, done
	tra	set010-*	loop for more
	rem
set020	lda	tfwd,3	get the fwd ptr
	sta	tlasta-*,*	and store in last blk
	lda	tfree-*	get free ptr
	sta	tfwd,3	put into this block
	stx3	tfree-*	reset free, putting this on head
	rem
set030	lda	setsa-*	restore a reg value
	tze	set080-*	zero, no new value to set
	tpl	set031-*	positive, value in seconds
	ila	0
	ilq	0
	sbq	setsa-*	compute positive milliseconds
	tra	set032-*
	rem
set031	mpy	l.l001-*	(=1000) convert to milliseconds
set032	adaq	ctime-*	add in current time
	staq	time-*	save as expected timeout time
	staq	t.time,1	update into tib
	rem
	ldx3	tfree-*	get ptr to free block
	tnz	set050-*	good, we have one
	rem
	ilq	bufsiz	load buffer size
	tsy	a.i004-*,*	(=getbuf) get the needed buffer
	die	1
	stx3	tfree-*	save its address
	rem
	ila	bufsiz-2	get size minus two
	ars	1	divide by two
set040	iacx3	2	bump to next block
	stx3	-2,3	store its addr in last fwd ptr
	iaa	-1	decrement count
	tnz	set040-*	loop for more
	rem
	stz	0,3	zero the last fwd ptr
	ldx3	tfree-*	get the free ptr again
	rem
set050	lda	tfwd,3	take the block
	sta	tfree-*	update free ptr
	lda	strtib-*	get real tib address
	sta	ttib,3	save real tib address in blk
	rem
	stx3	tcur-*	save addr of new block
	lda	a.l006-*	(=tnext) save addr of next ptr
	sta	tlasta-*	for later reference
	ldx3	tnext-*	get addr of chain
	tze	set070-*	no chain here
	rem
set060	lda	ttib,3	get real tib address from blk
	tsy	a.l001-*,*	(setptw) virtualize it
	cax1		put virtual tib address in x1
	ldaq	time-*	get the new time value
	cmpaq	t.time,1	is time < t.time?
	tnc	set070-*	yes, chain new block here
	rem
	stx3	tlasta-*	save addr of this blk
	ldx3	tfwd,3	bump to next blk
	tnz	set060-*	loop if more blks to look at
	rem
	ldx3	tcur-*	pick up addr of new blk
	stx3	tlasta-*,*	store in fwd ptr of last blk
	stz	tfwd,3	zero fwd ptr of this one
	tra	set080-*	continue
	rem
set070	cx3a		save addr of next blk
	ldx3	tcur-*	pick up addr of new blk
	stx3	tlasta-*,*	store in fwd ptr of last blk
	sta	tfwd,3	reset fwd ptr of this blk
	rem
set080	szn	itrint-*	has interval timer run out?
	tnz	set110-*	yes, will be set later...
	rem
	ldx3	tnext-*	pick up next ptr again
	tnz	set081-*	there are tib entries
	szn	runing-*	timer runing?
	tze	set110-*	no, nothing at all to do
	tra	set100-*	yes, just restart from current value
	rem
set081	lda	ttib,3	get real tib address from first blk
	tsy	a.l001-*,*	(setptw) virtualize it
	cax1		put virtual tib address in x1
	szn	runing-*	is the clock running now?
	tze	set082-*	no, just set it
	rem
	ldaq	simclk-*	get the simulated clk value
	cmpaq	t.time,1	is simclk < t.time?
	tnc	set100-*	yes, all set
	rem
set082	ldaq	t.time,1	get the tib time
	sbaq	ctime-*	subtract current time
	tnz	set085-*
	rem
	ila	0	set clock to very small number
	ilq	1	so we will get interrupt
	tra	set090-*
	rem
set085	iaa	0	set the indicators
	tze	set090-*	less than max, set clock
	rem
	ila	1	set max timer value in aq
	ilq	0	all zeros in q
	rem
set090	stq	a.l007-*,*	(=itmb) reset the clock
	rem
	adaq	ctime-*	add in current time to get new
	staq	simclk-*	simulated clock time, and store
	rem
set100	sel	tmch	select the timer channel
	cioc	runpcw-*	run clock run
	aos	runing-*	is running now
	rem
set110	null
	lda	savpte-*	get orig page table entry
	sta	a.l009-*,*	(.crpte,*) restore page table entry
	rem
	return	setime
	rem
	rem
savpte	bss	1	saves variable page table entry
strtib	bss	1	saves real tib address
	rem
	even
mskpcw	vfd	18/0
	vfd	5/0,1/1,12/0
runpcw	vfd	18/0
	vfd	18/0
	rem
simclk	oct	0,0
ctime	oct	0,0
itimer	oct	0,0
time	oct	0,0
	rem
runing	oct	0
	rem
tnext	oct	0
tfree	ind	tque
	rem
tque	tblk	16
	rem
	rem	equates for the symbols in a tque entry
	rem
tfwd	equ	0
ttib	equ	1
	rem
	rem
tcur	oct	0
tlasta	oct	0
	rem
	rem
l.l001	dec	1000
	even
l.l002	vfd	18/intpri
	ind	itmout
	rem
a.l001	ind	setptw	set up variable cpu page table word
a.l002	ind	gettib
a.l003	ind	dspqur
a.l004	ind	dnext
a.l005	ind	dfree
a.l006	ind	tnext
a.l007	ind	itmb
a.l008	ind	secdsp
a.l009	ind	.crpte,*	variable cpu page table entry
	ttls	itrout -- interval timer runout interrupt processor
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	itrout
*
*	     this routine handles the interval timer runout
*	interrupt and schedules the itrip routine to
*	handle the processing of the timouts.
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
itrout	ldaq	l.m001-*	get the priority and routine
	rem		don't care whats in x1
	tsy	a.m001-*,*	(=dspqur) queue to run
	rem
	aos	itrint-*	interval timer has run out.
	rem
	tra	a.m002-*,*	(=mdisp) return to master dispatcher
	rem
itrint	oct	0
	even
l.m001	zero	itpri
	ind	itrip
	rem
a.m001	ind	dspqur
a.m002	ind	mdisp
	rem
	rem
	rem	jump table for interval timer runout
	rem
timrjt	zero
	tsy	.invp-*,*
	vfd	18/modtmr
	rem
.invp	ind	invp
	ttls	itrip - interval timer processor
	rem
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*	itrip
*
*	     this routine does the actual processing for
*	the interval timer runout. it finds all people
*	in the tib and delayq lists who have reached
*	the requested time.
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	rem
itrip	null		called by dispatcher
	rem
	stz	itrint-*	we have handled interrupt now
	stz	runing-*	not running now
	ila	0	get a very small number in aq
	ilq	2	to use as fudge in finding timouts
	adaq	simclk-*	get the real time of this
	staq	ctime-*	and save as current time
	rem
	trace	tt.itr,ts.tim,(ctime,ctime+1)
	rem
	ldx3	tnext-*	get ptr to tib list
	tze	itr020-*	no tibs in tib list
	rem
itr010	lda	ttib,3	get ptr to first tib in list
	tsy	a.l001-*,*	(setptw) virtualize it
	cax1		put virtual tib address in x1
	ldaq	ctime-*	get current time
	cmpaq	t.time,1	is ctime < t.time?
	tnc	itr020-*	yes, all done
	rem		no, give timeout
	ldx1	ttib,3	need real tib address for dspqur
	ldaq	l.l002-*	get priority and addr of itmout
	tsy	a.l003-*,*	(=dspqur) queue it up, real tib in x1
	rem
	lda	tfwd,3	save old fwd ptr
	ldq	tfree-*	get the free ptr
	stq	tfwd,3	save as fwd ptr of this one
	stx3	tfree-*	make this one first free
	rem
	cax3		bump to next block
	stx3	tnext-*	point the que head at this blk
	iacx3	0	set the indicators
	tnz	itr010-*	loop if more blks to look at
	rem
itr020	ldx3	a.l004-*,*	(=dnext) get delayq next ptr
	tze	itr040-*	none in queue now
	rem
itr030	ldaq	ctime-*	get the current time
	cmpaq	dtime,3	compare: is ctime < dtime?
	tnc	itr040-*	yes, all done
	rem		no, give time out
	lda	dpri,3	get the priority
	ldq	drtn,3	and the routine addr
	ldx1	dx1,3	and his value in x1
	tsy	a.l003-*,*	(=dspqur) and queue him to run
	rem
	lda	dfwd,3	get the fwd ptr in this blk
	ldq	a.l005-*,*	(=dfree) get the free ptr
	stq	dfwd,3	and put into this blk
	stx3	a.l005-*,*	(=dfree) and put this on at top
	rem
	cax3		bump to next guy in list
	stx3	a.l004-*,*	(=dnext) point head at this one
	iacx3	0	set the indicators
	tnz	itr030-*	loop for more work
	rem
itr040	stz	itrsw-*	zero the switch word
	rem
	szn	tnext-*	any tibs in tib list?
	tze	3	no
	rem
	ila	1	yes, set bit
	orsa	itrsw-*
	rem
	szn	a.l004-*,*	(=dnext) any entries in delayq?
	tze	3	no
	rem
	ila	2	yes, set other bit
	orsa	itrsw-*
	rem
	ldx3	itrsw-*	load the switch word
	tra	a.n001-*,*	(=itrtbl,3*) use as index to label array
	rem
itrtbl	ind	itr041	no timers needed
	ind	itr042	only tib timers set
	ind	itr043	only delayq timers on
	ind	itr044	both set, compare
	rem
itr041	ila	0	set standard time for clock
	ldq	l.n001-*	(=60*1000) so we idle for a minute
	adaq	ctime-*	add it in so we can subtract it out
	tra	itr050-*	set clock
	rem
itr042	ldx3	tnext-*	get ptr to first tib entry
	lda	ttib,3	get real tib address
	tsy	a.l001-*,*	(setptw) virtualize it
	cax1		put virtual tib address in x1
	ldaq	t.time,1	have tib time
	tra	itr050-*	set clock
	rem
itr043	ldx3	a.l004-*,*	(=dnext) get ptr to delayq list
	ldaq	dtime,3	get first delayq time
	tra	itr050-*	set clock
	rem
itr044	ldx3	tnext-*	get ptr to tib list
	lda	ttib,3	get real ptr to first tib in list
	tsy	a.l001-*,*	(setptw) virtualize it
	cax1		put virtual tib address in x1
	ldaq	t.time,1	get the tib time
	rem
	ldx3	a.l004-*,*	(=dnext) get ptr to delay list
	cmpaq	dtime,3	is t.time < dtime?
	tnc	itr050-*	yes, all set
	rem
	ldaq	dtime,3	get the delay q time instead
	rem
itr050	sbaq	ctime-*	subtract current time to get interval
	tnz	itr055-*	non-zero, all set
	rem
	ila	0	set to a very
	ilq	1	small number to get interrupt
	tra	itr060-*
	rem
itr055	iaa	0	set indicators
	tze	itr060-*	less than max timer values, all set
	rem
	ila	1	set max value allowed
	ilq	0
	rem
itr060	stq	a.l007-*,*	(=itmb) put into timer loc
	adaq	ctime-*	get next simclk time
	staq	simclk-*	and save it away
	rem
	sel	tmch	select timer
	cioc	runpcw-*	start the clock, run, run, run.
	aos	runing-*	running again
	rem
itr070	tra	a.l008-*,*	(=secdsp) return dispatcher
	rem
itrsw	bss	1
	rem
l.n001	dec	60000
	rem
a.n001	ind	itrtbl,3*
	end
