******************************************************
*                                                    *
*                                                    *
* Copyright (c) 1972 by Massachusetts Institute of   *
* Technology and Honeywell Information Systems, Inc. *
*                                                    *
*                                                    *
******************************************************

	lbl	,init
	ttl	init - fnp initialization module for multics 
	rem
***********************************************************************
*
*  note:  cs means "central system"
*
***********************************************************************
*
* init is the initialization module for mcs. it is entered from
* gicb just after bootload. init is always the last module
* loaded into the fnp and most of it is freed as buffer
* space after initialization is complete.
*
* this routine takes care of setting up each configured
* io channel and allocating tibs for each line.
*
* initially coded for gerts and stolen for mcs.
* modified by Coren for mcs.
* modified by grady and coren to delete pre-init code
*   from other modules.
* modified by Grady to add stuff for printer init.
* modified by art beattie to support dn6670 extended memory.
* modified by Robert Coren to add allocation of metering area
* modified by Robert Coren to support buffers in extended memory and
*   to eliminate code for 32k FNP.
* modified September 1983 by Robert Coren to check for zero-length
*   trace buffer.
*
***********************************************************************
	rem
	pcc	on
	pmc	off
	detail	on
	editp	on
	rem
	symdef	init
	symdef	istart
	rem
	symref	ignore	ignore interrupts routine
	symref	badint	extraneous interrupt routine
	symref	exist	summary of which iom channels exist
	symref	iomflt	iom channel fault routine
	symref	hfv	hardware fault vector entry base address
	symref	msdsp	master dispatcher entry location
	symref	etrip	elapsed timer rollover interrupt proc.
	symref	dicell	dia configuration switch data location
	symref	dindcw	dia_man interrupt dcw
	symref	wcon	console routine entry point
	symref	contip	console terminate interrupt proc address
	symref	conchn	console channel number
	symref	getbuf	buffer allocating subroutine
	symref	frebuf	buffer freeing subroutine
	symref	frebfh	free buffer in extended memory
	symref	getmem	memory allocating subroutine
	symref	fremem	memory freeing subroutine
	symref	fresml	routine to clean up fres space
	symref	bfcksw	switch that controls buffer checking
	symref	ctrl	control tables
	symref	itest	"test-state" entry to interpreter
	symref	hslajt	hsla jump tables
	symref	diajt	dia jump tables
	symref	dlist	dia icws, pcws, etc.
	symref	diconf	dia configuration area
	symref	consjt	console jump tables
	symref	timrjt	timer jump tables
	symref	utsave	place in utilities where regs get saved
	symref	pterm	printer terminate interrupt handler
	symref	pspec	printer special handler
	symref	brktab	addr of table in breakpoint_man
	symref	skdata	address of scheduler data block
	symref	icmdat	address of ic-moniroting data block
	symref	etrmon	address of icmdat in sskdata
	symref	etrint	address of timer interval in skdata
	symref	idlint	idle metering interval
	symref	idloop	start of idle loop
	symref	idlcnt	counter maintained by idle loop
	symref	idlmax	maximum idle count value
	symref	idlmin	mininum  "     "    "
	symref	dspqur	secondary queuer
	symref	secdsp	secondary dispatcher
	symref	setptw	set page table word
	symref	trace	trace module
	symref	endtrc	(in trace module) last word in trace buffer
	symref	nxtrce	(in trace module) next entry in trace buffer
	symref	mvplmm	move paged lower memory maximum address
	symref	conman	set to -1 by init if console_man is in image
	symref	getbfm	interrupt time metering area for getbuf
	symref	diasel	'sel' instruction in dia_man
	symref	fpsel	and two in utilities
	symref	obsel
	rem
	pmc	save,on
	systm
	comreg
	rem
	hwcm
	rem
	tib
	rem
	meters
	rem
	sfcm	hsla
	rem
	devtab
	rem
	buffer
	eject
pbit	bool	200
	rem
	rem		character codes
	rem
cr	bool	15
lf	bool	12
stx	bool	2
esc	bool	33
sync	bool	26
us	bool	37
	rem
	rem
ptro	bool	2000	pre-tally runout status
rts	bool	20	set request-to-send
dtr	bool	40	data terminal ready
rcv	bool	400	receive mode
snd	bool	200	send mode
	rem
	rem		pcw opcodes
	rem
initop	bool	10
reqcst	bool	3
rstmsk	bool	5
setmsk	bool	4
stomrg	bool	11
	ttls	configuration tree table definitions
************************************************************************
* these symbolic names are used to access the various fields of the
* configuration tree table (fig tree).
*
* three symbols are defined for each field:
*
*	fa      can be used as a mask to isolate the field.
*	fb      can be used as a mask when the field is right justified.
*	fc      the position ofthe lsb of the field.
*
* when changes are made to this table, be sure to check all useage
* of symbols beginning with "fa".
************************************************************************
	rem
fampx	bool	400000	1 = multiplexed channel
fbmpx	bool	1
fcmpx	equ	0
	rem
farel	bool	200000	1 = device released
fbrel	bool	1
fcrel	equ	1
	rem
faasyn	bool	100000	1 = asynchronous device
fbasyn	bool	1
fcasyn	equ	2
	rem
fadacn	bool	070000	device number for hsla and lsla
fbdacn	bool	7
fcdacn	equ	5
	rem
fatnd	bool	004000	1 = t&d is in control
fbtnd	bool	1
fctnd	equ	6
	rem
fachrl	bool	003000	character length code
fbchrl	bool	3
fcchrl	equ	8
	rem
fadevc	bool	000760	device type code
fbdevc	bool	37
fcdevc	equ	13
	rem
fasped	bool	000017	device speed code
fbsped	bool	17
fcsped	equ	17
	eject
	rem	*********************************************************
	rem	* device type codes
	rem	*********************************************************
	rem
dnimp	bool	00	not implemented
	rem
dclock	bool	01	fnp's clocks
	rem
ddia	bool	02	dia
	rem
dhsla	bool	03	hsla
	rem
dlsla	bool	04	lsla
	rem
dcon	bool	05	console
	rem
dprint	bool	06	printer
	rem
	rem	unused codes 07 - 14
	ttls	symbol definition	rem
	rem
	pmc	on,save
	hslatb
	pmc	restore
	rem
	rem
	rem	********************************************
	rem	* modem types
	rem	********************************************
	rem
mt103a	equ	1
mt201c	equ	2
mt2025	equ	3
mt2026	equ	4
mt208a	equ	5
mt208b	equ	6
mt209a	equ	7
	rem	10-17 unused
	rem
tt2741	equ	3	terminal type "2741"
ttbsc	equ	7	line type for bisync
ttx25	equ	17	line type for x.25
tthdlc	equ	18	line type for hdlc
ttcolt	equ	19	line type for colts channel
	rem
diardc	bool	74	dia opcode -- read configuration
diadis	bool	70	dia opcode -- disconnect
	rem
	rem
	rem
init	null
	start	init,9
	pmc	restore
	rem
	even
tibtab	bss	816	2 words per tib (unused space will be freed)
	ttls	init macros
	rem
	rem	*******************************************************
	rem	*
	rem	*  dn6670 paged data address icw (odd word)
	rem	*    allows IOM to directly address all 64k memory
	rem	*
	rem	*******************************************************
	rem
amicwo	macro
	vfd	2/2,3/#1,1/#3,12/#2
	endm	amicwo
	rem
	rem
	rem	* multiply macro
	rem
mpy	macro
	mpf	#1
	lrl	1
	endm	mpy
	ttls	miscellaneous subroutines
************************************************************************
* setclk -- set interval timer
* rstclk -- reset interval timer
*
* entry -- setclk
*
*	lda     (number milliseconds)
*	ldq     (return address on runout)
*	tsy     setclk-*
*
* entry -- rstclk
*
*	tsy     rstclk-*
************************************************************************
	rem
setclk	ind	**
	sti	scindc-*	save io select register
	sel	tmch	select clock channel
	cioc	scoff-*	turn clock off
	sta	scvalu-*,*	store time value
	stq	sciv-*,*	store user's iv
	cioc	scon-*	turn clock on
	ldi	scindc-*	restor io select reg <?><?><?><?><?><?><?><?>
	tra	setclk-*,*	return
	rem
	rem
	rem
rstclk	ind	**
	sti	scindc-*	save io select register
	sel	tmch	select clock channel
	cioc	scoff-*	turn clock off
	ldi	scindc-*	restore io select register <?><?><?><?><?>
	tra	rstclk-*,*	return
	rem
	rem
	rem
	even
scon	oct	0,0
scoff	oct	0,010000
scvalu	ind	itmb	interval timer mailbox address
sciv	ind	tmro	interval timer runout iv address
scindc	bss	1
	ttls	main initialization loop
	rem
******************************************************************************
*
* the code from istart-1 to the begining of channel initialization is only
* executed once.  therefore, this code is located at the end of the module
* so it can be released as buffer space and used for tib and sfcm allocation.
* this helps in making available as much memory as
* possible for channel initialization.
*
******************************************************************************
	rem
	rem
	rem	*********************************************************
	rem	* scan fig tree and initialize devices
	rem	*********************************************************
	rem
figtre	ind	**+0,1	points to current "fig" -- 1st word
	ind	**+1,1	points to current "fig" -- 2nd word
	rem
itl010	null
	lda	iomch-*
	als	1
	cax1		x1 = 2 * iom channel number
	lda	figtre-*,*	pluck a fig from the tree of knowledge
	caq
	ldx2	figtre+1-*,*	get wd 2 of entry
	arl	18-fcdevc-1	r-just device code bits
	rem
	rem	* at this point,
	rem	*      q  = word  0 of config table
	rem	*      x1 = 2 * (iom channel #)
	rem	*      x2 = word  1 of config table
	rem
	iana	fbdevc	? non-implemented channel ?
	tze	nodev-*	yes
	icmpa	ddia	? device = dia ?
	tze	a.a001-*,*	(dia) yes
	icmpa	dhsla	? device = hsla ?
	tze	a.a002-*,*	(hsla) yes
	icmpa	dprint	? device = printer ?
	tze	a.a004-*,*	(print) yes
	icmpa	dclock	? device = clocks ?
	tze	a.a005-*,*	(clocks) yes, also -- last iom channel
	rem
itl020	null
	aos	iomch-*	bump to next iom channel
	tra	itl010-*
	rem
	rem
	rem	device initialization routines:
a.a001	ind	dia	direct interface adapter
a.a002	ind	hsla	high speed line adapter
*a.a003		unused
a.a004	ind	print	line printer
a.a005	ind	clocks	clocks -- final start up procedures
a.a006	zero	savein
	rem
l.a001	qls	0
savein	bss	3*16
	ttls	nodev -- initialize for non-implemented channel
************************************************************************
* non-implemented channel:
*
*  --set appropriate iv's to point to an "extraneous interrupt"
*    reporting routine.
*
*  --send a mask pcw (bit 23 =1) to insure channel is off.
************************************************************************
	rem
nodev	null
	rem
	lda	iomch-*	compute base address of iv's for
	als	1	this channel
	ada	iomch-*
	ada	a.a006-*	(savein)
	cax1
	lda	a.b001-*	(badint)
	sta	0,1
	sta	1,1
	sta	2,1
	lda	iomch-*	store channel # in "sel"
	ora	l.b001-*	(sel 0) instruction
	sta	ndv010-*
	rem
ndv010	sel	**	select the channel
	cioc	nmpcw-*	send mask pcw
	rem
	tra	itl020-*
	rem
	rem
	rem
a.b001	ind	badint
	rem
l.b001	sel	0
	rem
iomch	zero	0	current iom channel number
	even
nmpcw	oct	0,010000	pcw0 -- mask channel
	ttls	print - initialize for line printer
**********************************************************************
* setup to run the line printer. init the interrupt vectors
* into ptrac.
**********************************************************************
	rem
print	null
	rem
	lda	iomch-*	get the channel number
	als	1	times 2
	ada	iomch-*	now is times 3
	ada	a.a006-*	(savein) plus base of save area
	cax1		copy into x1
	rem
	lda	a.c001-*	(pspec) get special handler addr
	sta	1,1	put into save area
	lda	a.c002-*	(pterm) and terminate handler
	sta	2,1	save it too, to be restored later
	rem
	tra	itl020-*	return for next channel
	rem
	rem
a.c001	ind	pspec
a.c002	ind	pterm
	ttls	dia -- initialize for inter-computer adapter
************************************************************************
* this routine initializes the dia by reading the setting of the
* configuration data switches.
************************************************************************
	rem
dia	null
	rem
	aos	icflag-*
	rem
	lda	iomch-*
	cmpa	diachn-*	is it the one on which we got the interrupt?
	tnz	itl020-*	no, ignore it altogether
	orsa	dia030-*
	orsa	dia070-*
	orsa	dia020-*
	orsa	a.d007-*,*	bst010
	orsa	a.d025-*,*	diasel (in dia_man)
	orsa	a.d026-*,*	fpsel (in utilities)
	orsa	a.d027-*,*	obsel (in utilities)
	als	1	set level 1 iv to extraneous int routine
	ada	iomch-*
	ada	a.a006-*	(savein)
	cax1
	lda	a.b001-*	(badint)
	sta	1,1
	rem
	lda	l.d001-*	(=o400000)
dia020	arl	**
	sta	cdiaic-*	save operand for "sic"
	rem
	ldq	a.d002-*,*	(exist)
dia030	qls	**	? does this channel exist ?
	tmi	dia040-*	yes
	tra	1,*
	ind	stop04	"dia does not exist" eeeeeeeeeeeeeeeeeeee
	rem
dia040	ldx2	a.d010-*	(diajt)
	stx2	2,1	put address of dia terminate jump table
	rem		in saved iv
	lda	diachn-*	and put dia channel no. in jump table entries
	als	14	line it up
	orsa	2,2
	ldx1	a.d011-*	(dis0) -- first dia "special" iv
	ilq	-16	we will store 16 jump table addresses
dia050	iacx2	3	increment jump table address
	stx2	0,1	put it in interrupt vector
	orsa	2,2	and store channel number
	iaq	1	bump counter
	tze	dia060-*	all done
	iacx1	16	no, bump interrupt vector address
	tra	dia050-*	go round again
	rem
dia060	ldx2	a.d012-*	(dlist)
	lda	1,2	get 2nd word of status icw template
	ora	l.d003-*	(=o010000) 'or' in exhaust bit
	caq
	lda	0,2	get rest of status icw template
	staq	a.d013-*,*	(dist) store it in status icw mbx
	cx2a
	iaa	2	point to pcw template
	cax3		in x3
	ila	2	get count
	cax1
	tsy	a.d014-*,*	(parity)
	rem		pcw has correct parity now
	ldaq	2,2	pick it up
	staq	a.d001-*,*	(dimb) put it in pcw mailbox
	rem
	iacx2	6	point x2 at dcw area
	ila	0	we will set up dcw list to read configuration
	ilq	diardc	config opcode (74)
	staq	0,2
	lda	a.d015-*	(diconf),w.2
	ilq	4
	staq	2,2
	rem		now disconnect dcw
	ila	diadis	disconnect opcode (70)
	sta	5,2
	lda	l.d002-*	(0,w.2)
	sta	6,2
	cx2a
	cax3		copy into x3 for parity subroutine
	ila	8	get count
	cax1
	tsy	a.d014-*,*	(parity)
	rem
dia070	null
	sel	**
	lda	diatmv-*,*	pick up terminate vector location of
	sta	ictmtp-*	dia and temp store it
	lda	a.d008-*	(dia090) pick up location to use for this
	sta	diatmv-*,*	terminate and put in iv loc
	cioc	a.d001-*,*	(dimb) pcw -- read dia configuration switches
	rem
	ila	5	set timeout (5 ms) for terminate interrupt
	ldq	dia080-1-*	pick up addr of timeout handler
	tsy	a.d005-*,*	(setclk) and go start up clock
	dis		wait for dia interrupt
	tra	-1	dont let just any interrupt do it
	rem
	ind	dia080
dia080	ind	**
	tra	1,*
	ind	stop05	"dia did not respond in time" eeeeeeeeeee
	rem
dia090	ind	**	gets "tsy"d to on dia interrupt
	tsy	a.d006-*,*	(rstclk) dia terminate interrupt occurred
	rem
	lda	a.d016-*	(dia100) get new temporary iv
	sta	diatmv-*,*	
	ldaq	initst-*	get "init entered" status
	tsy	a.d024-*,*	(btsts) send it to dia
	tra	dia100+1-*	if we come here, we are in sim
	rem
	rem		btsts waits for interrupt
	rem
dia100	ind	**	tsy'd to after interrupt
	lda	ictmtp-*	pick up saved loc of dia terminate
	sta	diatmv-*,*	handler, and put it back
	rem
	rem		put terminate interrupt cell into dia_man's dcw
	lda	a.d003-*,*	(dicell) get it from configuration switches
	arl	3	isolate terminate interrupt cell
	als	6
	orsa	a.d009-*,*	(dindcw)
	rem		dia is all set up now
	tra	itl020-*
	eject
	rem
a.d001	ind	dimb	dia mailbox address
a.d002	ind	exist
a.d003	ind	dicell
a.d005	ind	setclk
a.d006	ind	rstclk
a.d007	ind	bts010
a.d008	ind	dia090
a.d009	ind	dindcw
a.d010	ind	diajt
a.d011	ind	dis0
a.d012	ind	dlist
a.d013	ind	dist
a.d014	ind	parity
a.d015	zero	diconf,w.2
a.d016	ind	dia100
a.d017	ind	hslano
a.d018	ind	hlahcr
a.d019	ind	getchn
a.d020	ind	hmsg01+2
a.d021	ind	iwcon
a.d022	ind	hslajt
a.d023	zero	.criom
a.d024	ind	btsts	bootload status reporting routine
a.d025	ind	diasel	'sel' instruction in dia_man
a.d026	ind	fpsel	'sel' instruction in fault processor
a.d027	ind	obsel	'sel' instruction in crash routine
	rem
l.d001	oct	400000
l.d002	zero	0,w.2
l.d003	oct	010000	exhaust bit
	even
initst	oct	450000,000000	"init entered" status
	rem
cdiaic	bss	1
icflag	oct	0
ictmtp	oct	0
diachn	bss	1	dia iom channel
diatmv	ind	**	patched to address of dia terminate vector
	ttls	hsla -- initialize for high speed line adapter
	rem
************************************************************************
*
* this routine will initialize all that is necessary to operate
* from one to three high speed line adapters.  subchannels which are
* found to not exist or configured improperly will be marked by
* setting the "exhaust" bit in the active status icw. no tib or software
* comm region will be created for such subchannels.
*
************************************************************************
	rem
	rem
	rem	*      this procedure is entered with:
	rem	* q  = word 0 of config table
	rem	* x1 = 2 * (iomchannel #)
	rem	* x2 = word 1 of config table
	rem
hsla	null
	cqa		lets figure out the hsla #
	arl	18-fcdacn-1	from word 0 of config table
	iana	fbdacn	-- now we have got it
	iaa	-1	internal count is from 0
	sta	a.d017-*,*	(hslano) save it for later
	iaa	1
	als	9	multiply by 1000 (octal) and we
	sta	a.d018-*,*	(hlahcr) have the hardware region address
	rem
	cax3		x3 -> this hsla hardware comm region
	rem
	lda	iomch-*	now, lets see if this iom channel
	ora	l.a001-*	(qls 0) exists (from the "exist" variable)
	sta	+2	put this "qls iomch#" where we will execute it
	ldq	a.d002-*,*	(exist) pick up the knowledgeable variable
	qls	**	and shift left until our bit is in the
	rem		sign position (this loc patched)
	tmi	hsl010-*	this channel does exist
	rem
	tsy	a.d019-*,*	(getchn) get the current iom chan # in ascii
	stq	a.d020-*,*	(hmsg01+2) and save its ascii value
	tsy	a.d021-*,*	(iwcon) use "disaster" mode console routine
	ind	hicw01
	nop		dont bomb if no console exists
	tra	itl020-*	give up on this hsla
	rem
hsl010	null		hsla does exist, and was initialized
	ila	97	get size of each jump table (per hsla)
	mpy	hslano-*	times hsla no to get addr offset
	rem
	adq	a.d022-*	(hslajt) add in base addr
	stq	hjtloc-*	save
	aos	hjtloc-*	bump by one to skip ind word
	rem
	stz	hsbchn-*	set to 0th subchannel
	cx1a		get iom channel no.
	rem		times 2
	ada	a.d023-*,*	(.criom)
	cax2		pointer to iom table entry
	ldx2	1,2	pointer to hsla table
	rem
	rem	*********************************************************
	rem	*
	rem	*      perform the following initialization procedures for
	rem	* each subchannel that was configured in the cdt.
	rem	* if a subchannel does not exist, or does not conform
	rem	* to the configuration desired, set the "exhaust" bit in
	rem	* its active status icw; otherwise, allocate a tib
	rem	* (terminal information block) and a software comm.
	rem	* region for the subchannel.
	rem	*
	rem	*********************************************************
	rem
hsl020	null
	lda	iomch-*	get the iom channel number
	ora	l.b001-*	(sel 0) and build a "sel" instruction
	sta	1	and put it where we'll use it
	sel	**	(patched) select this hsla
	rem
	ldaq	h.cnfg,3	get config pcw, if any (stored
	rem		here by load_fnp_ routine)
	tze	hsl400-*	this channel isnt configured
	rem
	staq	hcnfig-*	save the configuration pcw
	rem
	cx3a		get addr of hwcm into the a
	arl	9	divide by 1000(8)
	als	2	multiply by 4(8)
	sta	hivloc-*	save as iv location so far
	lda	hsbchn-*	get subchannel number
	icmpa	16	is it > 20(8)?
	tmi	hsl030-*	no, continue
	rem
	aos	hivloc-*	yes, bump ivloc by one
	iaa	-16	and decrement sbchn by 16
hsl030	als	4	multiply subchn by 20(8)
	asa	hivloc-*	add into ivloc
	rem
	lda	hjtloc-*	get the jump table addr
	sta	hivloc-*,*	deposit in iv
	rem
	ldaq	hsticw-*	set my active status icw
	staq	h.aicw,3	and store it in hwcm
	rem
	rem		build an "unmask" pcw
	lda	hsbchn-*	load subchannel number
	als	6	move into subchannel field
	ora	hunmsk-*	or in pcw 0, command 5
	ldq	hunmsk+1-*	and pick up no broadside commands
	staq	hpcw-*	and save this pcw for execution
	rem
	cioc	hpcw-*	unmask the subchannel
	rem
	cioc	hcnfig-*	configure this subchannel
	rem
	lda	hsbchn-*	now lets build a "request config" pcw
	als	6	move subchannel number in
	ora	hreqcn-*	(=230000) pcw 1,command 3
	ldq	hreqcn+1-*	get second word (request to send)
	staq	hpcw-*	and save it for a bit later
	rem
	stz	h.cnfg,3	clear config status words to be able
	stz	h.cnfg+1,3	to detect no response
	rem
	cioc	hpcw-*	request configuration status
	rem
	ila	10	wait 10 ms for status store
	ldq	hsl040-1-*	get location to tsy thru then
	tsy	a.f001-*,*	(setclk) go start up the clock
	dis
	tra	-1	ignore all interrupts til then
	rem
	ind	hsl040
hsl040	ind	**	control gets here when done waiting
	rem		for config status store
	rem	*********************************************************
	rem	*      now test received configuration status against
	rem	* desired configuration and other criteria.
	rem	*********************************************************
	rem
	ldaq	hcnfig-*	test upper half for matching bits
	ana	hmask1-*	(=o600076) (see hmask1 for expl)
	sta	htemp-*	this is what it should be
	rem
	lda	h.cnfg,3	now, lets see what it is
	ana	hmask1-*	(=o600076) (see hmask1 for expl)
	cmpa	htemp-*	see if what is is what should be
	tnz	hsl390-*	nope, go mask off channel
	rem
	cana	l.f002-*	(=o200000) is it synchronous?
	tnz	hsl050-*	if so, don't bother with second word
	rem
	lda	h.cnfg+1,3	pick up lower half of status to test char length
	ana	l.f003-*	(=o170000) mask out all but character lengths
	cmpa	l.f004-*	(=o040000) see if 8 bit byte size
	tze	hsl050-*	yes, this is ok
	cmpa	l.f005-*	(=o020000) see if 7 bit byte size
	tze	hsl050-*	yes, this is ok
	cmpa	l.f006-*	(=o010000) see if 6 bit byte size
	rem		yes, this is ok, fall through
	tnz	hsl390-*	not ok, mask out this channel
	rem
	rem
hsl050	null
	lda	ht.flg,2	get the baud rate into
	iana	htfspd	hbaud for maktib
	sta	hbaud-*
	rem
	lda	ht.flg,2	get flags again
	ana	l.f008-*	(hftasy) is it sync or async?
	arl	7	just put bit into hbaud
	orsa	hbaud-*	in the right place
	rem
	stx2	hsavx2-*	save ptr to hsla table entry
	rem		set up software comm. region and tib
	stx3	hsavx3-*	save hardware comm. region address
	tsy	a.f003-*,*	(hgsfcm) allocate an sfcm
	rem
	ldx3	hsavx3-*	get hwcm address and store
	sta	h.sfcm,3	software comm. region address
	rem
	rem		set up active status icw in hwcm
	iaa	sf.sta	point to hardware status in sfcm
	ldq	hsaicw-*	get odd word of dn6670 status icw
	staq	h.aicw,3	note that the channel can store 6 though
	rem		 tally is set to 5. hardware stores status
	rem		 in sixth word after tally runout.
	lda	l.f010-*	(=o10000) exhaust bit in icw
	sta	h.sic0+1,3	init both of the xmit
	sta	h.sic1+1,3	to exhaust condition
	rem
	rem		now get line number
	ldq	hslano-*	hsla number
	qls	6
	adq	hsbchn-*	subchannel no.
	adq	l.f001-*	(=o1000) hsla indicator
	rem		now make the tib
	lda	hbaud-*	restore baud code
	tsy	a.f008-*,*	(maktib) allocate a tib for it
	rem
	sta	ht.tib,2	put real tib address in hsla table entry
	rem
	lda	h.sfcm,3	get real sfcm address from hwcm
	tsy	a.f013-*,*	(setptw) virtualize it
	sta	t.sfcm,1	put virtual sfcm address in tib
	cax2		get it into right register
	rem
	rem	fill in stuff in sfcm
	rem
	stx3	sf.hcm,2	put hwcm addr into sfcm
	cx2a		get sfcm addr in a
	iaa	sf.waq	put starting address of wraparound queue
	sta	sf.nxa,2	in sfcm pointers
	sta	sf.nxp,2
	lda	a.f016-*,*	 (hsfssl) initialize count of free slots in queue
	sta	sf.tly,2
	sta	sf.ssl,2	save as status queue length too
	lda	hsavx2-*	address of hsla table
	sta	sf.hsl,2	save addr in sfcm
	rem
	ldx2	hsavx2-*	reload ptr to hsla table
	lda	ht.flg,2	get the flag bits
	arl	4	shift line type into position
	iana	31	mask down
	tze	hsl060-*	none specified, use default
	rem
	sta	t.type,1	put into tib
	rem
hsl060	lda	ht.flg,2	reload flag bits
	sta	htflgt-*	save in "stack" temporary
	ldx2	t.sfcm,1	reload sfcm ptr
	cana	l.f008-*	(htfasy) asynchronous?
	tnz	hsl070-*	yes
	lda	l.f017-*	(sffsyn) no, mark the sfcm
	orsa	sf.flg,2
	lda	htflgt-*	get the hsla table flags back
	rem
hsl070	null
	arl	9	look at modem type this time
	iana	15	mask down
	tze	hsl180-*	none specified
	rem
	iaa	-1	relative to zero
	ada	a.f011-*	(hsl080) get jump list base
	sta	hsltra-*	store so we can indirect
	rem
	tra	hsltra-*,*	dispatch on modem type
	rem
hsl080	tra	hsl130-*	mt103a
	tra	hsl090-*	mt201c
	tra	hsl140-*	mt202c5
	tra	hsl150-*	mt202c6
	tra	hsl160-*	mt208a
	tra	hsl120-*	mt208b
	tra	hsl170-*	mt209a
	rem
hsl090	lda	htflgt-*	get ht flags
	cana	l.f011-*	(htfpl) private line dataset?
	tnz	hsl180-*	yes, all done
	rem
hsl100	lda	l.f012-*	(tfdlup) set tib flag for dial operation
	orsa	t.flg,1	in first tib flag word
	tra	hsl180-*	done
	rem
hsl120	tra	hsl100-*	208b are always dial
	rem
hsl130	null		nothing special for these datasets
hsl140	null
hsl150	null
hsl160	null
hsl170	null
hsl180	null
	eject
	rem	process line type specification
	rem
	lda	t.type,1	now process type setting
	iaa	-1	can never be zero here
	ada	a.f012-*	(hsl190) get table base
	sta	hsltra-*	save to indirect through
	rem
	tra	hsltra-*,*	dispatch on line type
	rem
hsl190	null
	tra	hsl200-*	ascii
	tra	hsl210-*	1050
	tra	hsl220-*	2741
	tra	hsl240-*	ards
	tra	hsl250-*	sync
	tra	hsl260-*	g115
	tra	hsl230-*	bsc
	tra	hsl270-*	202etx
	tra	hsl280-*	vip
	tra	hsl290-*	async1
	tra	hsl300-*	async2
	tra	hsl310-*	async3
	tra	hsl320-*	sync1
	tra	hsl330-*	sync2
	tra	hsl340-*	sync3
	tra	hsl350-*	polled vip
	tra	hsl234-*	X.25 LAP
	tra	hsl234-*	HDLC
	tra	hsl359-*	COLTS
	rem
hsl200	lda	htflgt-*	get hsla table flag bits
	cana	l.f014-*	(hftop1) option 1 set?
	tze	hsl360-*	no
	lda	l.f016-*	(tfauto) opt1 means autobaud
	orsa	t.flg,1
	tra	hsl360-*
	rem
hsl210	null		1050 or
hsl220	ila	sffebd	2741
	orsa	sf.flg,2	set ebcdic flag in sfcm
	tra	hsl360-*	done
	rem
hsl230	lda	l.f013-*	(sffbsc) bsc type
	orsa	sf.flg,2	set sffbsc in sfcm
	tra	hsl360-*
	rem
hsl234	lda	l.f015-*	(=sffhdl) HDLC type
	orsa	sf.flg,2	set in SFCM
	tra	hsl360-*
	rem
hsl240	null		nothing to do for these types
hsl250	null
hsl260	null
hsl270	null
hsl280	null
hsl290	null
hsl300	null
hsl310	null
hsl320	null
hsl330	null
hsl340	null
hsl350	null
hsl359	null
hsl360	null
	eject
	rem
	stx1	sf.tib,2	put tib addr in sfcm
	rem
	ldaq	hcnfig-*	get configuration pcw for channel
	staq	sf.cfg,2	store it in sfcm for later modifications
	rem
	ldx2	hsavx2-*	reload ptr to hsla table
	ldx3	hsavx3-*	and ptr to hwcm
	rem
	rem
hsl380	null		increment to next subchannel
	iacx2	2	next hsla table entry
	iacx3	16	hwcm is 16 words long
	aos	hsbchn-*	bump subchannel number
	ila	3	bump jump table ptr
	asa	hjtloc-*	by three
	rem
	ila	32	valid numbers are 0 - 31
	cmpa	hsbchn-*	see if still more subchannels
	tnz	hsl020-*	yes, go process them
	rem		no, now store the mask register
	rem
	cioc	hsmska-*	store the mask register
	cioc	hsmskb-*	in case this is a dn6670, do it for each mlc
	cioc	hsmskc-*
	cioc	hsmskd-*
	rem
	tra	1,*	return to main routine
	ind	itl020
	rem
	rem
hjtloc	bss	1	hold current jump table addr
hsbchn	bss	1	this loc always has cur subchannel number
hslano	bss	1	current hsla number
	eject
	rem
hsl390	null		come here for bad configuration
	tsy	a.f002-*,*	(hgetch) get iom channel number in ascii
	stq	hmsg02+2-*	and store in error message
	lda	hsbchn-*	pick up subchannel number
	ada	a.f005-*	(hsasbc) add offset of subchannel table
	sta	htemp-*	store it for a moment
	lda	htemp-*,*	and pick up ascii equiv of subch nums
	sta	hmsg02+6-*	and store into error message
	tsy	a.f004-*,*	(iwcon) use disaster mode console routine
	ind	hicw02
	nop		ignore inability to write on console
	rem
	ila	-1	set sfcm addr in hwcm to -1
	sta	h.sfcm,3
	lda	hsbchn-*	load subchannel number
	als	6	move into subchannel field
	ora	hmskch-*	or in pcw 0, command 4
	ldq	hmskch+1-*	and pick up no broadside commands
	staq	hpcw-*	and store for execution
	rem
	cioc	hpcw-*	mask this subchannel
	rem
	rem		end up here for badly-configured or
	rem		non-configured line
hsl400	null		we will set up active status icw with
	rem		exhaust bit on
	cx3a		get hwcm address
	iaa	h.baw	we will point status icw at base address word
	rem		pointer to avoid getting status stored randomly
	ldq	hbdicw+1-*	get rest of icw with exhaust bit
	staq	h.aicw,3
	tra	hsl380-*	on to next subchannel
	rem
	rem
	even
	rem
hbdicw	icw	**,w.2,1,1	status icw for inactive subchannel
	rem
hsticw	icw	hstat,w.2,1	icw to store status for configuration
hicw01	icw	hmsg01-1,b.0,32	icw to type on fnp console
hicw02	icw	hmsg02-1,b.0,44	icw to type on fnp console
	rem		  status
	rem
	rem		pcw to unmask a subchannel
hunmsk	vfd	2/0,4/rstmsk,2/0,4/**,6/0,18/0
	rem
	rem		pcw to mask a subchannel
hmskch	vfd	2/0,4/setmsk,2/0,4/**,6/0,18/0
	rem		pcw to request configuration status
hreqcn	vfd	2/1,4/reqcst,2/0,4/**,6/0,18/rts
	rem		pcw to store the mask register
hsmska	vfd	2/0,4/stomrg,12/0,18/0
hsmskb	vfd	2/0,4/stomrg,6/8,6/0,18/0
hsmskc	vfd	2/0,4/stomrg,6/16,6/0,18/0
hsmskd	vfd	2/0,4/stomrg,6/24,6/0,18/0
hpcw	bss	2	temporary for pcws to execute
hcnfig	bss	2	temporary for configuration pcw
hastat	bss	2	temporary storage for status icw
	rem
hstat	bss	4	destination of status words for configuration
	rem
hsaicw	amicwo	w.2,sfhsiz,0	dn6670 icw prototype (odd word) for hardware
	rem		  status
htibad	bss	1	tib address
hbaud	bss	1	baud rate code(temporary)
hivloc	bss	1	holds location of iv for this subchannel
htemp	bss	1	an alround temporary
hsavx2	bss	1	place to save hsla table addr
hsavx3	bss	1	place to save hwcm address
hsltra	bss	1	jump indirect through this word
htflgt	bss	1	temp for hsla table flags
hlahcr	vfd	3/0,15/**	hsla's hcr base address
hmask1	oct	600076	mask to leave only (mbo's, async/sync
	rem		 parity stuff, icw alternation, and ccc enabled
hmask2	oct	004377	mask to leave only (2 stop bits and speed)
	rem
a.f001	ind	setclk	routine to delay for n ms
a.f002	ind	getchn	routine to convert iom channel to ascii
a.f003	ind	hgsfcm
a.f004	ind	iwcon	routine to write on console if there
a.f005	ind	hsasbc	table of ascii equivs of subch nums
a.f006	ind	.crmem	last legal address configured
a.f007	ind	getmem	memory allocating subroutine
a.f008	ind	maktib	subroutine for making a tib
a.f009	ind	.crtrb	base address of trace buffer
a.f010	ind	tibadr	real tib address
a.f011	ind	hsl080
a.f012	ind	hsl190
a.f013	ind	setptw	set up page table entry
a.f014	ind	.crmet	flag indicating metering
a.f015	ind	metadr	real metering area address
a.f016	ind	hsfssl	number of entries in software status queue
	rem
	rem
l.f001	oct	1000	hsla indicator
l.f002	oct	200000	this bit is on if synchronous
l.f003	oct	170000	mask to leave only char length field
l.f004	oct	040000	char length field of 6 bits
l.f005	oct	020000	char length field of 7 bits
l.f006	oct	010000	char length field of 8 bits
l.f007	oct	000400	bit for marking asynch baud code
l.f008	vfd	18/htfasy	"async" bit in hsla table entry
l.f009	zero	0,w.2	36-bit addressing
l.f010	oct	010000	exhaust bit in icw
l.f011	vfd	18/htfpl	private line flag
l.f012	vfd	18/tfdlup	dialup flag in tib
l.f013	vfd	18/sffbsc	bisync bit in sfcm
l.f014	vfd	18/htfop1	hsla table option flag 1
l.f015	vfd	18/sffhdl	HDLC channel
l.f016	vfd	18/tfauto	autobaud flag in tib
l.f017	vfd	18/sffsyn	synchronous flag in sfcm
l.f018	oct	024000	inhibit interrupts and overflow
	rem
	detail	off	dont print all the words for messages
	rem
	vfd	9/cr,9/lf
hmsg01	aci	14,*ch-xx, hsla does not exist
	vfd	9/cr,9/lf
hmsg02	aci	20,*ch-xx, sch-xx, bad configuration status
	vfd	9/cr,9/lf
	rem
hsasbc	null		table of ascii subchannel nums
	aci	1,00
	aci	1,01
	aci	1,02
	aci	1,03
	aci	1,04
	aci	1,05
	aci	1,06
	aci	1,07
	aci	1,08
	aci	1,09
	aci	1,10
	aci	1,11
	aci	1,12
	aci	1,13
	aci	1,14
	aci	1,15
	aci	1,16
	aci	1,17
	aci	1,18
	aci	1,19
	aci	1,20
	aci	1,21
	aci	1,22
	aci	1,23
	aci	1,24
	aci	1,25
	aci	1,26
	aci	1,27
	aci	1,28
	aci	1,29
	aci	1,30
	aci	1,31
	aci	1,32
	aci	1,33
	aci	1,34
	aci	1,35
	aci	1,36
	aci	1,37
	aci	1,38
	aci	1,39
	aci	1,40
	aci	1,41
	aci	1,42
	aci	1,43
	aci	1,44
	aci	1,45
	aci	1,46
	aci	1,47
	aci	1,48
	aci	1,49
	aci	1,50
	aci	1,51
	aci	1,52
	rem
	detail	on
	ttls	hsla subroutine to get a sfcm or sfcm/tib pair
	rem
hgsfcm	subr	hgs,(x1,x2,i)
	rem
	rem		figure out sfcm size
	lda	ht.flg,2
	arl	4	shift line type down
	iana	31	isolate it
	icmpa	ttx25	x.25?
	tze	hgs001-*	yes
	icmpa	tthdlc	hdlc?
	tze	hgs001-*	yes
	icmpa	ttbsc	bisync?
	tze	hgs001-*	yes
	ilq	sfssq	none of above, use short status queue
	tra	hgs002-*
hgs001	ilq	sflsq	use long size
hgs002	stq	hsfssl-*	save queue length
	qls	2	multiply by 4 (to get in words)
	iaq	sf.hln	add basic sfcm length
	stq	hsflen-*	this is total size to allocate
	rem
	rem
	rem
	rem	*****************************************************************
	rem	*    the following code allocates space for a sfcm and tib
	rem	*  starting at 32768.  the sfcm and tib have to be allocated in
	rem	*  the same page for a given channel.
	rem	*
	rem	*    since the tib has to be allocated now, its real address is
	rem	*  stored in 'tibadr'.  the 'maktib' subroutine is coded to
	rem	*  account for this.
	rem	*****************************************************************
	rem
	stz	hmetln-*	initially
	szn	a.f014-*,*	(.crmet) are we metering at all?
	tze	hgs008-*	no, skip this calculation
	lda	ht.flg,2	see if it's synchronous channel
	cana	l.f008-*	=htfasy
	tnz	hgs003-*	no
	ilq	m.synl	yes, use synchronous length
	tra	2
hgs003	ilq	m.asyl	else asynchronous
	stq	hmetln-*	save this for later
hgs008	null
	lda	hcurpg-*	get page base address
	ada	hsflen-*	recalculate the end of the pair
	sta	a.f010-*,*	(tibadr)
	ada	htibln-*
	sta	a.f015-*,*	(metadr)
	ada	hmetln-*
	caq		get it into the right register
	rem
hgs010	null
	szn	a.f009-*,*	(.crtrb) is trace configured?
	tnz	hgs020-*	yes
	cmpq	a.f006-*,*	(.crmem) no. will sfcm/tib pair fit in
	tra	hgs030-*	  rest of memory?
	rem
hgs020	null
	cmpq	a.f009-*,*	(.crtrb) will sfcm/tib pair fit below
	rem		  trace buffer?
hgs030	null
	tnc	hgs040-*	yes. we are cool
	tze	hgs040-*	whew. this better be the last one
	die	1	no. out of memory
	rem
hgs040	null
	stq	hnxstp-*
	lda	hcurpg-*	get sfcm address for return
	caq
	ldi	l.f018-*	(=o024000) inhibit overflow
	adq	l.i006-*	=256
	stq	hcurpg-*	save address of next page for next pair
	rem
hgsret	null
	return	hgsfcm
	rem
	rem
hcurpg	dec	32768	base of current page
hnxstp	dec	32768	pointer to next sfcm/tib pair
hsflen	oct	0	next even number of words in sfcm
hsfssl	oct	0	size of software status queue
htibln	oct	0	next even number of words in tib
hmetln	oct	0
	ttls	maktib -- subroutine to allocate a tib
	rem
	rem	this subroutine allocates space for a tib (terminal
	rem	information block) and fills in stuff common to hsla
	rem	and lsla
	rem
	rem	input:
	rem		a reg contains baud rate code
	rem		(with bit 9 marking asynch line)
	rem		q reg contains line number
	rem
	rem	output:
	rem		x1: contains virtual tib address
	rem		 a: contains real tib address
	rem
maktib	subr	mak,(x2,x3)
	rem
	staq	mtemp-*	save baud rate code and line number
	lda	tibadr-*	get real tib address
*
*  save tib address in table for later use
	rem
	ldx2	a.i003-*,*	(.crtte) get address of next available slot
	sta	0,2
	iacx2	2	bump pointer
	stx2	a.i003-*,*	(.crtte)
	rem
	ldx3	a.i001-*	(ctrl) get control_tables address
	ldx3	3,3	x3 points to device type table
	rem
mak020	null		search table for type corresponding to baud rate
	lda	0,3	get table entry
	icmpa	-1	hit end of table?
	tnz	2
	die	6	if so, very bad news
	lrl	9	get baud rate code in a, device type in q
	cmpa	mtemp-*	matches argument?
	tze	mak030-*
	iacx3	1	no, keep looking
	tra	mak020-*
	rem
	rem		now put associated device type into tib
mak030	null
	lda	tibadr-*	virtualize tib address
	tsy	a.i004-*,*	(setptw)
	cax1		get it into x1
	qrl	9	align device type in q
	stq	t.type,1
	ldq	mtemp+1-*	get line number again
	stq	t.line,1	put it in tib
	lda	a.i001-*,*	(ctrl) pointer to start of control tables
	sta	t.cur,1	this is where interpreter will start
	rem
	ldx3	a.i001-*	(ctrl)
	ldx3	1,3	addr(array of device table addresses)
	adcx3	t.type,1	index by device type
	ldx3	-1,3	convert index to offset
	rem		x3 now points to relevant device table entry
	lda	dt.flg,3	find out how tfctrl should be set
	cana	l.i001-*	(dtfctl)
	tze	mak040-*	it's off to start with
	lda	l.i002-*	(tfctrl)
	orsa	t.flg,1	if dtfctl was on, turn tfctrl on
mak040	null
	lda	dt.flg,3	now check setting of dtfsft
	cana	l.i004-*	(dtfsft)
	tze	mak050-*
	lda	l.i005-*	(tfsftr) get tib bit to set
	orsa	t.flg2,1
mak050	null
	iacx3	dt.brk	get address of default break list
	stx3	t.brkp,1	into tib
	rem
	lda	metadr-*	get address of metering area
	tsy	a.i004-*,*	(setptw) virtualize it
	sta	t.metr,1
	rem
	rem
	rem		for asynchronous line, take 2 32-word blocks
	rem		for permanent input buffers (if available).
	rem		remainder of page is added to buffer pool
	rem
	lda	mtemp-*	synchronous line?
	cana	l.i006-*	(=o400)
	tze	mak070-*	yes, don't bother with buffers
	lda	hcurpg-*	get address of next page base
	sba	hnxstp-*	find out how much space is left in page
	icmpa	2*bufsiz	enough for two buffers?
	tnc	mak070-*	no, skip it
	lda	hnxstp-*	get starting address
	sta	t.abf0,1	this is first one
	caq
	tsy	a.i004-*,*	(setptw)
	cax2		make it addressable
	ila	bufsiz	get size in words
	als	9	store in first character
	sta	0,2
	iaq	bufsiz	point to next one
	stq	t.abf1,1	address into tib
	iacx2	bufsiz	virtual address also
	sta	0,2
	iaq	bufsiz	this is address of remaining space in the page
	szn	a.i007-*,*	is there any trace buffer?
	tnz	mak058-*	yes, go ahead
	cmpq	a.i008-*,*	(.crmem) else see if it fits in memory
	tra	2
mak058	cmpq	a.i007-*,*	(.crtrb) does it overlap trace buffer?
	tnc	mak060-*	no
	tze	mak060-*	also no, but it's close
	die	1	yes, image won't work
mak060	lda	l.i007-*	tfabf0+tfabf1
	orsa	t.flg3,1	mark them available
	cmpq	hcurpg-*	any space left in page?
	tze	makbak-*	no, that's all
	stq	hnxstp-*	yes, save address
mak070	lda	hnxstp-*	get last available address
	iaa	bufsiz-1	round it up to even bufsiz boundary
	iana	-bufsiz
	sta	hnxstp-*	save it for size determination
	ldq	hcurpg-*	find end of page
	sbq	hnxstp-*	how much space is left?
	tze	makbak-*	none
	tnc	makbak-*	this is unlikely, but check anyway
	tsy	a.i006-*,*	(frebfh) free what remains in the page
makbak	null		that's all
	lda	tibadr-*	this is the real value where virtual value is
	rem		  is in the x1 register
	return	maktib
	rem
	rem
a.i001	ind	ctrl	control tables
a.i002	ind	getmem	memory allocating subroutine
a.i003	ind	.crtte
a.i004	ind	setptw	set up page table word
a.i005	ind	.crmet
a.i006	ind	frebfh
a.i007	ind	.crtrb
a.i008	ind	.crmem
	rem
l.i001	vfd	18/dtfctl
l.i002	vfd	18/tfctrl
l.i003	oct	1000
l.i004	vfd	18/dtfsft
l.i005	vfd	18/tfsftr
l.i006	oct	400
l.i007	vfd	18/tfabf0+tfabf1
	rem
	even
mtemp	bss	2	place to put arguments
tibadr	bss	1	real address of allocated tib
metadr	bss	1	real address of allocated metering area
	ttls	stopxx -- error notification routines
	rem
	rem
stop	ind	**
	orsa	badsts-*	put error code in status
	ldq	a.k001-*,*	(iomch) get iom channel number
	stq	badsts+1-*	put it in bootload status
	iaa	-2	no. get 2*(message index)
	als	1
	ada	a.j001-*	(icws)
	sta	stp020-*	this is the icw to be passed to wcon
	szn	inhchn-*	does message need channel number?
	tnz	stp010-*	no
	cax1		copy icw address
	lda	0,1	get message address
	ana	l.j001-*	(=o077777) get rid of char addressing
	cax1
	tsy	getchn-*	get channel number for error message
	stq	3,1	store channel number in message
	rem
stp010	null
	tsy	a.k002-*,*	(iwcon) write it on console
stp020	zero	**	icw address goes here
	nop		don't fret if no console
	rem
	ldaq	badsts-*	notify cs of error
	tsy	a.j003-*,*	(btsts)
	dis		just stop
	tra	-1
	rem
	even
badsts	oct	440000,000000
	rem
	rem
stop02	null
	aos	inhchn-*	inhibit storing of channel no. in message
	ila	2
	tsy	stop-*
	rem
stop03	null
	aos	inhchn-*	inhibit storing of channel no. in message
	ila	3
	tsy	stop-*
	rem
stop04	null
	ila	4
	tsy	stop-*
	rem
stop05	null
	ila	5
	tsy	stop-*
	rem
stop06	null
	aos	inhchn-*	inhibit storing of channel no. in message
	ila	6
	tsy	stop-*
	rem
warn07	ind	**
	tsy	getchn-*
	stq	msg07+2-*
	tsy	a.k002-*,*	(iwcon)
	zero	icw07
	nop		dont let lack of console screw us
	tra	warn07-*,*	return to caller
	rem
stop08	null
	aos	inhchn-*
	ila	8
	tsy	stop-*
	rem
stop09	null
	ila	9
	tsy	stop-*
	rem
stop10	null
	ila	10
	tsy	stop-*
	rem
stop11	null
	ila	11
	tsy	stop-*
	rem
stop12	null
	aos	inhchn-*	inhibit storing of channel no. in message
	ila	12
	tsy	stop-*
	rem
stop13	null
	ila	13
	tsy	stop-*
	rem
stop14	null
	aos	inhchn-*	inhibit storing of channel no. in message
	ila	14
	tsy	stop-*
	rem
stop15	null
	aos	inhchn-*	inhibit storing of channel no. in message
	ila	15
	tsy	stop-*
	rem
inhchn	oct	0
	rem
a.j001	ind	icws
*a.j002		unused
a.j003	ind	btsts
	rem
l.j001	oct	077777	to eliminate character addressing
	eject
	rem	*********************************************************
	rem	* getchn -- get current iom channel number, convert to
	rem	*           ascii code, and place in q-register
	rem	*********************************************************
	rem
getchn	ind	**
	lda	a.k001-*,*	(iomch) get current iom channel number
	als	18-6	convert to ascii characters and leave
	ilq	6	in q-register
	llr	3
	qls	6
	iaq	6
	llr	3
	tra	getchn-*,*
	rem
a.k001	ind	iomch
a.k002	ind	iwcon
	eject
	even
icws	null
	rem
icw02	icw	msg02-1,b.0,28
icw03	icw	msg03-1,b.0,32
icw04	icw	msg04-1,b.0,30
icw05	icw	msg05-1,b.0,30
icw06	icw	msg06-1,b.0,30
icw07	icw	msg07-1,b.0,32
icw08	icw	msg08-1,b.0,40
icw09	icw	msg09-1,b.0,40
icw10	icw	msg10-1,b.0,42
icw11	icw	msg11-1,b.0,40
icw12	icw	msg12-1,b.0,38
icw13	icw	msg13-1,b.0,44
icw14	icw	msg14-1,b.0,36
icw15	icw	msg15-1,b.0,36
	rem
	detail	off
	rem
	vfd	9/cr,9/lf
msg02	aci	13,timer channel not enabled
	vfd	9/cr,9/lf
msg03	aci	15,more than one dia configured
	vfd	9/cr,9/lf
msg04	aci	13,*ch-xx, dia does not exist
	vfd	9/cr,9/lf
msg05	aci	13,*ch-xx, dia did not respond in time
	vfd	9/cr,9/lf
msg06	aci	15,extended memory not configured
	vfd	9/cr,9/lf
msg07	aci	14,*ch-xx, lsla does not exist
	vfd	9/cr,9/lf
msg08	aci	18,core image specifies too much memory
	vfd	9/cr,9/lf
msg09	aci	18,*ch-xx, illegal lsla speed specified
	vfd	9/cr,9/lf
msg10	aci	19,*ch-xx, lsla failed for the tenth time
	vfd	9/cr,9/lf
msg11	aci	18,*ch-xx, lsla actual <> desired speed
	vfd	9/cr,9/lf
msg12	aci	17,timer switch set to 64 khz, s/b 1
	vfd	9/cr,9/lf
msg13	aci	20,*ch-xx, actual config doesn't match cdt
	vfd	9/cr,9/lf
msg14	aci	16,pager is disabled or inoperative
	vfd	9/cr,9/lf
msg15	aci	16,unable to allocate trace buffer
	vfd	9/cr,9/lf
	rem
	detail	on
	ttls	initialization main program -- wrap up
***********************************************************************
*
*  all devices have now been initialized
* all that remains is to open up the appropriate floodgates in an
* orderly and meaningful sequence.
*
***********************************************************************
	rem
clocks	null
	rem
	rem
	rem	*********************************************************
	rem	* if t&d executive channel is configured, allocate a tib
	rem	* for it. if in >32k, we will keep the sfcm area and fake
	rem	* an hsla table entry therein to store the real tib
	rem	* address, so the code in dia_man that finds the tib
	rem	* table entry this way will work.
	rem	*********************************************************
	rem
	szn	a.m037-*,*	.crtdt
	tze	itl025-*	line not configured
	tsy	a.m039-*,*	(hgsfcm) set up tib address
	sta	csfcm-*	save sfcm address
	lda	l.m004-*	(=o412) give it a baud rate of 9600
	ldq	l.m003-*	=o1777, line number for colts
	tsy	a.m038-*,*	maktib
	sta	a.m037-*,*	save tib address in .crtdt
	ila	ttcolt	set line type
	sta	t.type,1
	lda	csfcm-*	get sfcm address back
	tsy	a.m034-*,*	(setptw) get virtual addr
	sta	t.sfcm,1	keep it for future reference
	cax2		we will pretend 2nd and 3rd words are
	iaa	1	hsla table entry
	sta	sf.hsl,2
	cax3		in order to save real tib address there
	lda	a.m037-*,*	(.crtdt)
	sta	ht.tib,3
	stx1	sf.tib,2	just for cleanliness
	rem
	rem	*********************************************************
	rem	* send bootload status to cs. first we'll spin our wheels
	rem	* for a second or so to give it time to process the
	rem	* previous status
	rem	*********************************************************
	rem
itl025	ila	1
	ilq	-1	aq contains 1777777, a good-sized loop index
itl026	sbaq	dbl1-*	a doubleword 1
	tnz	itl026-*	keep going until it's zero
	ldaq	gudsts-*	get some good status
	tsy	btsts-*	send the bootload status
	rem
	inh		inhibit interrupts <-><-><-><-><-><-><-><-><-><
	rem
	rem	*********************************************************
	rem	* restore level 0, 1, and 2 interrupt vectors to their
	rem	* operational settings
	rem	*********************************************************
	rem
	ldx3	a.m030-*	(intv+256)
	ldx2	a.m031-*	(savein+48-3)
	rem
itl030	null
	lda	0,2
	ldq	1,2
	staq	-16,3
	lda	2,2
	sta	-14,3
	iacx2	-3
	iacx3	-16
	tnz	itl030-*
	rem
	lda	a.m027-*	(consjt)
	cmpa	l.m001-*	(=o776) is console_man in image?
	tze	itl040-*	no. skip console stuff
	sta	a.m028-*,*	(tytm) yes. set up interrupt vectors for console
	iaa	3	now point to "special" jump table
	sta	a.m029-*,*	(tyrq)
	rem
itl040	null
	eject
	rem	************************************************
	rem	* now free all of init for use as buffer
	rem	* space. note we will run in here for
	rem	* awhile, so we must be careful about allocating
	rem	* buffers.
	rem	************************************************
	rem
	aos	a.m017-*,*	(bfcksw) suspend buffer size checking
	lda	a.m020-*,*	(.crtte)
	iaa	bufsiz-1	round up to bufsiz boundary
	iana	-bufsiz
	sta	cbufr-*	this will be beginning of buffer space
	rem
	ldq	a.m001-*,*	(.crbuf) old buffer area start
	sbq	cbufr-*	q contains total size
	cax3		point at which to be freed
	stx3	a.m001-*,*	(.crbuf) so frebuf doesn't get upset
	tsy	a.m013-*,*	(frebuf)
	rem
	lda	cbufr-*	start of buffer space
	sba	a.m020-*,*	(.crtte) free space before first buffer
	icmpa	2	if at least 2 words, we will use it
	tmi	itl050-*
	ldx3	a.m020-*,*	(.crtte) addr of small space
	caq
	stx3	a.m001-*,*	(.crbuf)
	tsy	a.m016-*,*	(fremem)
	rem
itl050	null		now free the rest of extended memory
	rem		one page at a time
	sti	itlind-*	save indicators
	ldi	l.m002-*	(=024000o) inhibit interrupt & overflow
	lda	a.m041-*,*	(hcurpg)
itl052	ada	l.m006-*	(=256) get address of end of page
	szn	a.m042-*,*	(.crtrb) is there any trace buffer?
	tze	itl055-*	no, free whole page
	cmpa	a.m042-*,*	(.crtrb) overlaps trace buffer?
	tnc	itl055-*	no
	tze	itl055-*	not quite
	lda	a.m042-*,*	.crtrb
	sba	a.m041-*,*	hcurpg
	iana	-bufsiz	rounded to bufsize, this is actual amount left
	tze	itl058-*	which isn't any
	tnc	itl058-*
	caq		get size in q
	tra	itl056-*
itl055	ldq	l.m006-*	(=256) free whole page
itl056	lda	a.m041-*,*	(hcurpg)
	tsy	a.m043-*,*	frebfh
	ada	l.m006-*	(=256) next page address
	sta	a.m041-*,*	hcurpg
	cmpa	a.m044-*,*	.crmem
	tnc	itl052-*	if any more pages
	rem
itl058	tsy	a.m033-*,*	(fresml) clean up small space
	nop		dont care which return
	stz	a.m018-*,*	(.crnbs) number of buffers for small space
	stz	a.m017-*,*	(bfcksw) enable buffer checking
	rem
	lda	a.m035-*,*	.crnbf
	als	bufshf	get buffer pool size in words
	sta	a.m036-*,*	(.mpool) store where metering will find it
	ldi	itlind-*	restore previous indicators
	rem
	rem	********************************************************
	rem	* start the control tables for each tib we created
	rem	********************************************************
	rem
	ldx2	a.m019-*	(tibtab) get address of first entry in tib
	rem		  address table
	stx2	a.m012-*,*	(.crttb) save it in system comreg
	rem
itl060	null
	cmpx2	a.m020-*,*	(.crtte) any more?
	tze	itl070-*	no
	lda	0,2	yes. get real tib address
	tsy	a.m034-*,*	(setptw) virtualize it
	cax1		get virtual tib address into x1
	tsy	a.m014-*,*	(itest) call test-state entry of interpreter
	iacx2	2	get address of next entry
	tra	itl060-*	get next entry
	rem
itl070	null
	eject
	rem	*********************************************************
	rem	* setup the interval and elapsed timers
	rem	*********************************************************
	rem
	stz	a.m006-*,*	(itmb) interval timer value = 0 
	lda	a.m007-*	(timrjt) interval timer jump table
	sta	a.m008-*,*	(tmro) timer interrupt vector
	lda	a.m021-*,*	(etrint) get elapsed timer default value
	sta	a.m009-*,*	(etmb)
	lda	a.m010-*	(etrip) elapsed timer interrupt handler
	sta	a.m011-*,*	(etr) timer interrupt vector
	tsy	a.m015-*,*	(rstclk) turn clock off
	rem
	ldaq	sdqdat-*	schedule dummy rtn to kick off timer
	tsy	a.m026-*,*	(dspqur) since clock doesnt start til it is used
	rem
	rem	*********************************************************
	rem	* setup pointer to scheduler control blocks
	rem	*********************************************************
	rem
	lda	a.m022-*	(skdata) addr of scheduler block
	sta	a.m023-*,*	(.crskd) store in .crskd
	lda	a.m024-*	(icmdat) addr of ic monitoring data
	cmpa	l.m001-*	(=o776) is it configured?
	tze	2	no
	sta	a.m025-*,*	(etrmon) store addr in sked block
	rem
	rem	*********************************************************
	rem	* set a level 2 interrupt for the dia so it can run
	rem	*********************************************************
	rem
	lda	a.m005-*,*	(cdiaic) get mask word for interrupt cell
	sic	2
	rem
	rem	*********************************************************
	rem	* set the interrupt enable mask register according to the
	rem	* number of hsla's configured.
	rem	*********************************************************
	rem
	ldx1	a.m003-*,*	(.crnhs)
	adcx1	a.m032-*	(cenimk)
	lda	0,1
	sier
	rem
	stz	a.m004-*,*	(.crcon) make sure console io enabled
	eject
	rem	*********************************************************
	rem	* well, here goes everything
	rem	*********************************************************
	rem
	eni		enable interrupts <+><+><+><+><+><+><+><+><+><+
	rem
	tra	1,*	go to the main dispatcher "dis"
	ind	msdsp
	eject
	rem
a.m001	ind	.crbuf	addr of very 1st buffer
*a.m002		unused
a.m003	ind	.crnhs	number of hsla's configured
a.m004	ind	.crcon	console io flag
a.m005	ind	cdiaic	set interrupt cell word for dia
a.m006	ind	itmb	interval timer mailbox addr
a.m007	ind	timrjt	interval timer jump table addr
a.m008	ind	tmro	interval timer iv addr
a.m009	ind	etmb	elapsed timer mailbox addr
a.m010	ind	etrip	elapsed timer interrupt handler
a.m011	ind	etr	elapsed timer iv addr
a.m012	ind	.crttb
a.m013	ind	frebuf
a.m014	ind	itest	"test-state" entry of interpreter
a.m015	ind	rstclk	stop clock routine
a.m016	ind	fremem
a.m017	ind	bfcksw
a.m018	ind	.crnbs
a.m019	zero	tibtab	pointer to current entry of tib address table
a.m020	zero	.crtte	pointer to end of tib address table
a.m021	ind	etrint	address of default elapsed timer value
a.m022	ind	skdata	address of scheduler control block
a.m023	ind	.crskd
a.m024	ind	icmdat	address of data in ic-monitor routine
a.m025	ind	etrmon	pointer to icmdat in skdata
a.m026	ind	dspqur
a.m027	ind	consjt	console_man jump tables
a.m028	ind	tytm	console terminate iv
a.m029	ind	tyrq	console special iv
a.m030	zero	intv+256
a.m031	zero	savein+48-3
a.m032	zero	cenimk
a.m033	ind	fresml
a.m034	ind	setptw	set up variable cpu page table word
a.m035	ind	.crnbf	number of free "buffers"
a.m036	ind	.mpool	buffer pool size for metering
a.m037	ind	.crtdt	t&d channel indicator (later tib address)
a.m038	ind	maktib
a.m039	ind	hgsfcm
a.m040	ind	hsflen
a.m041	ind	hcurpg
a.m042	ind	.crtrb
a.m043	ind	frebfh
a.m044	ind	.crmem
	rem
l.m001	oct	776	address of missing module
l.m002	oct	024000	inhibit interrupts & overflow
l.m003	oct	1777	line number for colts pseudo-channel
l.m004	oct	412	baud rate code for async 9600 baud
l.m005	oct	100000	first address above 32k
l.m006	dec	256
	even
sdqdat	vfd	12/60,6/1
	ind	secdsp
	rem
	even
gudsts	oct	400000,000000	bootloaded successfully status
dbl1	dec	0,1	a doubleword 1 for subtracting from aq
cbufr	zero
	rem
csfcm	bss	1	"sfcm" for colts channel
itlind	bss	1	for safe-storing indicators
	rem
cenimk	oct	740000,776000,777700,777774
	even
clkonx	oct	0,0
	ttls	btsts - send bootload status to cs
************************************************************************
*    this routine will send status to the central system
************************************************************************
btsts	ind	**
	staq	.sstat-*	save status to be sent
	lda	intcel-*	get interrupt cell word
	ana	mbxmsk-*	mask mailbox address
	iaa	6	add in relative location of status word
	sta	stdcw1-*	store in data transfer dcw
	rem
	lda	intcel-*	get execute interrupt cell to set
	arl	6	position it
	ana	intmsk-*	mask away extraneous bits
	orsa	stdcw2+1-*	store in interrupt dcw
	rem
	ldx1	lstsls-*	get length of status dcw block
	ldx3	lstsl-*	get pointer to dcw block
	tsy	parity-*	go calculate parity
	rem
	ldaq	list-*	get list icw pointer (dia pcw)
	staq	ldimb-*,*	store in pcw mailbox
	rem
	ila	2	set word count for parity calculation
	cax1
	ldx3	ldimb-*	calculate dia parity for pcw mailbox
	tsy	parity-*
	rem
	ldaq	limodl-*	get the list icw model
	staq	stslst-*	fill in for dia
	rem
bts010	sel	**	select the intercomputer channel
	cioc	ldimb-*,*	initiate i/o in dia channel
	dis		wait for interrupt
	tra	btsts-*,*	return
	eject
	rem
	even
.sstat	dec	0,0	bootload status to go
mbxmsk	oct	007777	mailbox address mask
intmsk	oct	007700	interrupt cell mask
ldimb	ind	dimb	dia mailbox location
lstsl	ind	stslst	location of status list
	even
list	zero	stslst,w.2	pcw model - ptr to list icw
	oct	72	opcode - list operation
	rem
limodl	dcw	stdcw1,6	bootload status list icw model
stslst	oct	0,0	place for list icw
stdcw1	vfd	18/,12/,o6/75	data transfer fnp to cs dcw
	dcw	.sstat,1
stdcw2	vfd	18/,12/,o6/73	interrupt cs dcw
	zero	0,w.2
	oct
stdcw3	vfd	18/,12/,o6/70	disconnect dcw
	zero	0,w.2
	oct
lstsls	ind	*-stslst	length of status dcw block
	ttls	calculate parity routine
	rem
parity	ind	**
	ldq	0,3	get first word of dcw
	lda	1,3	get second word of dcw
	rem
	qlp	18	calculate parity for 1st word
	tnz	2	odd parity...
	ora	parwd1-*	even - set parity bit
	rem
	alp	18	calculate parity for 2nd word
	tnz	2	odd parity...
	ora	parwd2-*	even - set parity bit
	rem
	sta	1,3	restore 2nd word with parity bits
	rem
	iacx3	2	bump words pointer
	iacx1	-2	decrement word count
	tnz	parity+1-*	more to do
	rem
	tra	parity-*,*	return
	rem
parwd1	oct	040000	parity bit for 1st word of dia dcw
parwd2	oct	020000	parity bit for 2nd word of dia dcw
	rem		beginning of free space while init is running
intcel	dec	0	interrupt cell passed by gicb
	ttls	iwcon - common interface to wcon
	rem
iwcon	subr	iwc,(x1)
	szn	a.n001-*,*	(conman) is console_man in image?
	tze	iwc020-*	no. take error return
	lda	iwcon-*,*	yes. get icw address
	sta	iwc010-*	store it after tsy to wcon
	aos	iwcon-*	set up for error return
	tsy	a.n002-*,*	(wcon) write on console
iwc010	zero	**	icw address
	tra	iwcret-*	error return
	rem
iwc020	null
	aos	iwcon-*	bump return address
	rem
iwcret	null
	return	iwcon
	rem
	rem
a.n001	ind	conman
a.n002	ind	wcon
	ttls	initialization main program
	rem
	rem
	rem	*********************************************
	rem	* gicb enters inti by way of
	rem	*        tra =(istart-1),*
	rem	*
	rem	* and passes:
	rem	*     the highest address in mcs in x2
	rem	*     the interrupt cell for the cs in x3
	rem	*     the dia iom channel in the a
	rem	**********************************************
	rem
	stx3	a.t017-*,*	(intcel) set interrupt cell
istart	null
	inh		inhibit interrupts <-><-><-><-><-><-><-><-><-><
	rem
	sta	a.t003-*,*	(diachn) save dia i/o channel
	rem		and derive terminate interrupt vector address
	als	4	which is 16*(channel)+2
	iaa	2
	sta	a.t010-*,*	diatmv
	rem
	rem	**************************************************************
	rem	* clear all unused configured memory including extended memory
	rem	**************************************************************
	rem
	lda	a.t008-*,*	(.crmem) get memory size
	sta	a.t007-*,*	(mvplmm) set lower memory maximum address
	sta	istpcl-*	stops memory clear loop
	cmpa	l.t002-*	(=32768) is last address above 32k?
	tnc	a.t022-*,*	(stop06) no. we can't run this code
	lda	l.t002-*	(=32768) yes. calculate last address in lower 32k
	iaa	-1
	sta	istpcl-*	stops memory clear loop
	iaa	-256	account for paging window
	iaa	-256	and buffer window
	sta	a.t007-*,*	(mvplmm) set lower memory maximum address
*
*  check pager operation
*
	ldx1	l.t009-*	get address of loc. 0
	lda	0,1	save its contents
	sta	itloc0-*
	ila	-1	put something recognizable there
	sta	0,1
	ldx1	l.t004-*	(window) base of window
	stz	0,1	clear test cells
	stz	-256,1
	ldx3	a.t009-*,*	(.crpte)
	lda	l.t006-*	(=o100040) init page table to window page 77000
	sba	l.t003-*	(=o400)
	sba	l.t003-*	(=o400)
	sta	0,3
	lda	a.t006-*,*	(.crcpt) init cpu pager
	sta	a.t004-*,*	(cptp)
	ila	-1	lets see where this goes
	sta	0,1	store test value
	stz	0,3	disable pager
	lda	0,1	this is the real 77400, has it changed?
	tnz	itl120-*	yes. bad news
	lda	-256,1	this is where store should go
	icmpa	-1	is it correct?
	tnz	itl120-*	no. bad news
	rem
itl100	null		clear lower memory loop
	stz	0,2	clear one word
	iacx2	1	udate pointer
	cmpx2	istpcl-*	is clearing finished?
	tnz	itl100-*	no. continue clear
	stz	0,2	yes. clear the last location
	rem
	lda	a.t008-*,*	(.crmem) get memory size
	iaa	1	yes. calculate stop for memory clear loop
	sta	istpcl-*
	ldx1	l.t004-*	(window) get pointer to paged address space
	ldx2	a.t009-*,*	(.crpte) get address of variable page table entry
	lda	l.t006-*	(=o100040) set up page table entry for window
	sta	0,2
	ldx3	l.t003-*	(=o400) set up counter
	lda	iabsad-*	absolute address value
	ldi	l.t001-*	inhibit overflow
	rem
itl110	null		clear one page of extended memory loop
	stz	0,1	clear one word
	cana	l.t008-*	(=o077777) first word of a 32k block?
	tnz	itl115-*	no, proceed
	stx1	itx1-*	save contents of x1
	ldx1	l.t009-*	zero
	szn	0,1	did we clobber loc. 0?
	tze	a.t002-*,*	(stop08) yes, there isn't this much memory
	ldx1	itx1-*	restore x1
itl115	iaa	1	increment absolute address value
	cmpa	istpcl-*	has the whole upper memory been written?
	tze	itl140-*	yes. extended memory clearing is done
	iacx1	1	no. increment page pointer
	iacx3	-1	done with this page?
	tze	itl118-*	yes, set up for next
	stz	0,1	no. continue clearing
	tra	itl115-*
	rem
itl118	sta	iabsad-*	save absolute address value
	lda	0,2	current page table entry
	ada	l.t003-*	(=o400) point to next page in upper memroy
	sta	0,2	hope the pager sees this
	lda	iabsad-*	restore absolute address value to A register
	ldx1	l.t004-*	(window) re-init page pointer
	ldx3	l.t003-*	(=o400) re-init counter
	tra	itl110-*	do the next page
	rem
itl120	null
	aos	ipgerr-*	remember paging error
	tra	itl180-*	init iv's for console write
	rem
a.t001	ind	setptw+1
a.t002	ind	stop08
a.t003	ind	diachn
a.t004	ind	cptp
a.t006	ind	.crcpt
a.t007	ind	mvplmm	lower memory maximum address (in utilities)
a.t008	ind	.crmem	memory size
a.t009	ind	.crpte
a.t010	ind	diatmv
*a.t011		unused
*a.t012		unused
*a.t013		unused
a.t014	ind	stop14
a.t016	ind	.criom
a.t017	ind	intcel
a.t019	ind	figtre
a.t020	ind	hsflen
a.t021	ind	htibln
a.t022	ind	stop06
	rem
l.t001	oct	024000	inhibit overflow and interrupts
l.t002	dec	32768
l.t003	oct	400
l.t004	vfd	18/window
l.t005	tra	-1,*
l.t006	vfd	10/128,3/1,5/0
l.t007	nop
l.t008	oct	077777
l.t009	oct	0
l.t010	oct	020000	inhibit interrupts only
	rem
iabsad	oct	100000
ipgerr	oct	0
istpcl	oct	0
itcerr	oct	0
itx1	bss	1
itloc0	bss	1
itrcdm	oct	0	dummy area used in case trace module is not
	rem		 configured
	rem
pte.s	bool	100	page table entry security bit
window	bool	77400
	rem
	even
hfvi	ind	hfv	fault vector images
	ind	hfv+2
	ind	hfv+4
	ind	hfv+6
	ind	hfv+8
	ind	hfv+10
	ind	hfv+12
	ind	hfv+14
	eject
	rem
itl140	null
	ila	pte.s	turn on 'security' bit in ptw so
	orsa	0,2	 any reference to window will cause a store fault
	rem
	rem	*********************************************************
	rem	* set up some values for hgsfcm subroutine in init module
	rem	*********************************************************
	rem
	ila	t.leng	get length of tib
	iaa	1	make it an even number of words
	iana	-2
	sta	a.t021-*,*	(htibln)
	rem
itl170	null
	ldx1	a.u007-*	(fltv) move processor fault vector images to
	ldaq	hfvi-*	fault vector locations
	staq	0,1
	ldaq	hfvi+2-*
	staq	2,1
	ldaq	hfvi+4-*
	staq	4,1
	ldaq	hfvi+6-*
	staq	6,1
	rem
	rem	*********************************************************
	rem	* get buffer routine metering area address
	rem	*********************************************************
	rem
	lda	a.u025-*	addr (getbfm)
	sta	a.u026-*,*	.crbtm
	rem
	rem	*********************************************************
	rem	* if breakpoint_man in coreimage, setup .crbrk
	rem	*********************************************************
	rem
	lda	a.u015-*	(brktab) address of break control table
	cmpa	l.u004-*	(=o776) valid (not equal to 776)
	tnz	2	yes, ok
	ila	0	use 0, no break table
	sta	a.u016-*,*	(.crbrk) store in comm region
	eject
	rem	*********************************************************
	rem	* set up fig tree table pointers
	rem	*********************************************************
	rem
	ldx1	a.t019-*	(figtre)
	lda	a.t016-*,*	(.criom) get address of fig tree table
	asa	0,1
	asa	1,1
	rem
itl180	null
	rem
	rem	*********************************************************
	rem	* if console_man is in coreimage, turn on 'conman' switch
	rem	*********************************************************
	rem
	lda	a.u011-*	(wcon) get address of entry point in console_man
	cmpa	l.u004-*	(=o776) is console_man in image?
	tze	itl190-*	no
	ila	-1	yes. turn on conman switch
	sta	a.u014-*,*	(conman)
	rem
itl190	null
	rem
	rem	*********************************************************
	rem	* set up level 0, 1, and 2 iv's so that "iom channel
	rem	* faults" are trapped and all other's ignored.  save
	rem	* previous contents of these iv's for later restoration.
	rem	*********************************************************
	rem
	ldi	l.t010-*	(=o020000) resume permission of overflow faults
	ldx1	l.t009-*	zero
	lda	itloc0-*	restore original contents of location 0
	sta	0,1
	ldx1	l.t003-*	(=o400) fill iom channel fault iv's
	lda	a.u008-*	(iomflt) with pointer's to "iomflt"
	sta	-16,1
	iacx1	-16
	tnz	-2
	rem
	ldx3	l.t003-*	(=o400) replace all zero iv's with a pointer
	lda	a.u027-*	(ignore)    to an ignore interrupts routine
itl200	null
	ldq	-1,3
	tnz	2
	sta	-1,3
	iacx3	-1
	tnz	itl200-*
	rem
	ldx3	l.t003-*	(=o400) save present values of level 0, 1, 2
	ldx2	a.u024-*	(savein+48-3) interrupt vectors for restoration
itl210	null
	ldaq	-16,3	later
	sta	0,2
	stq	1,2
	lda	-14,3
	sta	2,2
	ldaq	ignrad-*	set iv's to "ignore"
	staq	-16,3
	sta	-14,3
	iacx2	-3
	iacx3	-16
	tnz	itl210-*
	rem
	lda	l.u005-*	(=o700000) enable level 0,1,2 interrupts
	sier		<-><+><-><+><-><+><-><+><-><+><-><+>
	rem
	ila	3*16+1	allow any interrupts waiting
	rem		to cycle thru
	eni		enable interrupts <+><+><+><+><+><+><+><+><+><+
	nop
	iaa	-1	loop for a while to give them a chance
	tnz	-2	 to do their thing
	rem
	rem		now run the idle loop for one metering interval
	rem		to establish a counter value for an idle interval
	rem
	lda	a.u017-*	addr (itl215)
	sta	a.u018-*,*	(etr) direct timer interrupt to here
	ila	0	get negative interval size to set timer
	sba	a.u019-*,*	idlint
	sta	a.u009-*,*	etmb
	tra	a.u020-*,*	(idloop) run the idle loop till timer goes off
	rem
itl215	ind	**	elapsed timer runout comes here
	ldaq	a.u021-*,*	idlcnt
	staq	a.u022-*,*	(idlmax) this is maximum value
	staq	a.u023-*,*	(idlmin) and also minimum so far
	lda	ignrad-*	now ignore timer interrupts again
	sta	a.u018-*,*	etr
	ila	0	and clear the counter
	ilq	0
	staq	a.u021-*,*	idlcnt
	rem
	ldx1	l.t003-*	(=o400) fill iom channel fault iv's
	lda	a.u008-*	(iomflt) with pointer's to "iomflt"
	sta	-16,1
	iacx1	-16
	tnz	-2
	rem
	lda	a.u010-*,*	(conchn) initialize console terminate iv
	als	4
	cax1
	lda	a.u012-*	(contip)
	cmpa	l.u004-*	(=o776) is console_man in image?
	tze	itl220-*	no. skip console stuff
	sta	2,1	yes. set up console terminate interrupt vector
	lda	a.u013-*,*	(.crcon) save console switch
	sta	conswt-*
	stz	a.u013-*,*	(.crcon) zero switch so cr/lf goes through
	tsy	a.u011-*,*	(wcon) send cr/lf to console to unmask channel
	zero	iwcrlf	(9/cr,9/lf)
	nop		don't loop if no console
	lda	conswt-*	restore .crcon
	sta	a.u013-*,*	(.crcon)
	rem
itl220	null
	eject
	rem	***********************************************************
	rem	* now that the console has been set up,
	rem	*  check for fatal errors.
	rem	***********************************************************
	rem
	szn	ipgerr-*	was there a paging error?
	tnz	a.t014-*,*	(stop14) yes. cannot continue
	rem
	rem
	rem	***********************************************************
	rem	* check if timer is enabled and running
	rem	***********************************************************
	rem
	lda	a.u009-*,*	(etmb) get current value of elapsed timer
	ldq	l.v002-*	(=1000) get two millisecond counter
	iaq	-1	wait two milliseconds
	tnz	-1
	cmpa	a.u009-*,*	(etmb) check and see if timer changed
	tnz	itl230-*	yes-ok
	tra	1,*	no. error...timer not enabled
	ind	stop02
	rem
	rem
	rem	***********************************************************
	rem	* check to make sure interval timer switch is set
	rem	* to click every msec and not every 64th of a msec
	rem	***********************************************************
	rem
itl230	null
	ila	2	set timer to go off in 2 msec
	ldq	itl250-*	..
	tsy	a.v018-*,*	(setclk)
	ldq	l.v001-*	(=250) get half millisecond counter
	iaq	-1	wait half millisecond
	tnz	-1	..
	stz	itl250-*	if we finished counting, timer is set to click
	rem		every msec. set flag and wait for timer to go off
	dis
itl240	ind	stop12
itl250	ind	*+1	addr of place to go on timer interrupt
	ind	**
	szn	itl250-*	did we finish counting above?
	tnz	itl240-*,*	no - timer sw is wrong - inform cs
	eject
	rem	***********************************************************
	rem	* determine which iom channels are physically present.
	rem	* save the results in word "exist" such that a one in
	rem	* bit position "x" indicates that channel "x" exists.
	rem	***********************************************************
	rem
itl260	null
	ilq	0	the q reg contains the status found so far
	ila	0	want x1 to hold current subch num -- but
	cax1		it needs to be loaded first
	rem
	ldx3	xstsav-*	x3 will point to table of 16 readbacks
	rem
itl270	null
	cx1a		get the iom chan num into a reg
	ora	l.v003-*	(sel 0) 'or' in the sel instruction
	sta	1	put it where we will execute it
	sel	**	(altrd) select the current iom chan
	stex	itemp-*	store this channel's static status
	lda	itemp-*	pick up the status status
	sta	0,3	save it in readback vector
	icmpa	0	by experiment, non-existant channels
	rem		* return 0, most others dont (dia is exception)
	tze	2	it doesn't exist, dont turn on this bit
	iaq	1	it does exist, turn on low order bit
	qls	1	move over to make room for next channel
	iacx1	1	add one to subchannel number
	iacx3	1	add one to readback vector loc
	cx1a		get the subchannel number again
	icmpa	16	was it the last one,
	tnz	itl270-*	no
	rem
	qls	1	move word over one more to left justify
	rem
	rem	dia doesn't perform properly for experiment, so...
	rem
	stq	mexist-*,*	save word where others can find it
	lda	a.u028-*,*	(diachn) get dia channel
	ora	l.u006-*	'arl 0'
	sta	itl275-*	patch shift instruction
	lda	l.u007-*	(=o400000) get bit to shift
itl275	arl	**
	orsa	mexist-*,*	update 'exists' word
	eject
	rem	*********************************************************
	rem	* send an initialize pcw to each hsla configured
	rem	*********************************************************
	rem
itl280	null
	szn	a.u002-*,*	(.crnhs) first, are there any hsla's ??
	tze	a.u004-*,*	(itl350) no, don't bother with this code
	tra	itl300-*	skip over channel incrementation
	rem
itl290	null		* come here to increment to next channel
	aos	a.u005-*,*	(iomch)
itl300	null
	lda	a.u005-*,*	(iomch) load iom channel
	als	1	multiply by two
	cax1		x1 <- 2 * (iom ch #)
	lda	a.u006-*,*	(figtre,*) pick up 1st word of config tree
	arl	18-fcdevc-1	right justify the device type
	iana	fbdevc	mask out the rest of the word
	icmpa	dhsla	is it any hsla ??
	tnz	itl310-*	no, jump out of this section
	rem		* yes, prepare to initialize it
	lda	a.u005-*,*	(iomch) pick up the iom channel #
	ora	l.u003-*	(sel 0) 'or' in a select instruction
	sta	+1	store in where we will execute it
	sel	**	(this instruction patched above)
	rem		* select this hsla for operation
	rem
	rem		* now, check to see if this channel exists
	iana	15	mask out all but iom channel # (=o17)
	ora	l.u002-*	(qls 0) 'or' in 'qls' instruction
	sta	+2	store where we will execute it
	ldq	a.u003-*,*	(exist) pick up word on which channels exist
	qls	**	(patched from above)
	rem		* move desired bit into sign bit
	tpl	itl320-*	doesn't exist, the hsla initialization
	rem		* will print out a message later
	rem
	rem		* initialize this hsla
	rem		* (we need to hit it 4 times in case it's a 6670
	rem		*   with 4 mlcs pretending to be 1 hsla)
	cioc	ipcwa-*	pcw1, cmd 10, subchannel 0
	cioc	ipcwb-*	 "      "          "     8
	cioc	ipcwc-*	 "      "          "     16
	cioc	ipcwd-*	 "      "          "     24
	tra	itl320-*
	rem
itl310	null
	icmpa	dclock	is this the clock (the clock must be
	rem		* the last iom channel
	tze	itl330-*	yes, go initialize the devices
	rem
itl320	null		* no, go look for other hsla's
	tra	itl290-*
	rem
itl330	null
	lda	l.u001-*	(=5000) set clock for 5 sec to allow hsla's
	ldq	a.u001-*	(itl340) to finish
	tsy	a.v018-*,*	(setclk) wait here for clock to time out
	dis
	tra	-1
	rem
	rem
	rem
	rem
a.u001	ind	itl340	jump over the following area of data
a.u002	ind	.crnhs	number of hsla's configured
a.u003	ind	exist
a.u004	ind	itl350
a.u005	ind	iomch
a.u006	ind	figtre,*
a.u007	zero	fltv	fault vector base address
a.u008	ind	iomflt	iom channel fault routine
a.u009	ind	etmb	elapsed timer mailbox
a.u010	ind	conchn
a.u011	ind	wcon
a.u012	ind	contip
a.u013	ind	.crcon
a.u014	ind	conman
a.u015	ind	brktab	address of table in breakpoint_man
a.u016	ind	.crbrk
a.u017	ind	itl215
a.u018	ind	etr	elapsed timer interrupt vector
a.u019	ind	idlint	idle metering interval (in scheduler)
a.u020	ind	idloop	start of idle loop (in scheduler)
a.u021	ind	idlcnt	counter incremented by idle loop (in scheduler)
a.u022	ind	idlmax	maximum value of idlcnt (in scheduler)
a.u023	ind	idlmin	minimum   "   "    "     "      "
a.u024	zero	savein+48-3
a.u025	ind	getbfm
a.u026	ind	.crbtm
a.u027	ind	ignore
a.u028	ind	diachn
	rem
l.u001	dec	5000
l.u002	qls	0
l.u003	sel	0
l.u004	oct	776	a missing address
l.u005	oct	700000
l.u006	arl	0
l.u007	oct	400000
	rem
	even
ipcwa	vfd	2/1,4/initop,12/0,18/0  initialize pcw
ipcwb	vfd	2/1,4/initop,6/8,6/0,18/0   same for second mlc
ipcwc	vfd	2/1,4/initop,6/16,6/0,18/0  third
ipcwd	vfd	2/1,4/initop,6/24,6/0,18/0  fourth
	rem
	rem
	rem
itl340	ind	**
itl350	null
	stz	a.u005-*,*	(iomch)
	eject
	rem	***********************************************************
	rem	* set up initial buffer space parameters.
	rem	* we will allocate buffers starting at istart of init
	rem	* but we will free the rest of init for use as buffer space
	rem	* later.  the code from istart to the end of init is no
	rem	* longer needed.
	rem	***********************************************************
	rem
	lda	a.v007-*	(istart-1) the begining of the end of init
	iaa	bufsiz-1	round to buffer boundary
	iana	-bufsiz
	cax3		address to free
	sta	a.v020-*,*	(.crbuf) starting addr of buffer area
	lda	a.v023-*	(endtrc) is trace module in image?
	cmpa	l.u004-*	(=o776)
	tnz	itl360-*	yes
	lda	a.v012-*	(itrcdm) no. fake out initialization of
	sta	a.v019-*	(nxtrce) trace module
	sta	a.v023-*	(endtrc)
	sta	a.v025-*	(.crtrb)
	sta	a.v026-*	(.crtrc)
	rem
itl360	null
	lda	a.v013-*,*	(mvplmm) set up trace variables
	sta	a.v023-*,*	(endtrc)
	iaa	1
	rem
itl370	null
	sba	a.v020-*,*	(.crbuf) base of current free buffer area
	tze	a.v027-*,*	(stop15) there's no room left
	tnc	a.v027-*,*	(stop15) bad news
	caq		>0. ok. almost ready for frebuf
*
* finish up trace buffer allocation
	rem
	lda	a.v022-*,*	(.crmem) yes. put trace buffer at high
	rem		 end of configured memory
	sta	a.v023-*,*	(endtrc)
	sba	a.v024-*,*	(.crtsz)
	cmpa	a.v023-*,*	(endtrc) is there really a trace buffer?
	tze	2	no, skip the addition
	iaa	1
	sta	a.v025-*,*	(.crtrb)
	sta	a.v026-*,*	(.crtrc)
	sta	a.v019-*,*	(nxtrce)
	cmpa	l.v006-*	(=32768) is base above 32k?
	tnc	a.v027-*,*	(stop15) no. cannot handle this
	rem
itl380	null
	tsy	a.v014-*,*	(frebuf) free initial buffer space
	lda	a.v008-*	(utsave)
	sta	a.v009-*,*	(.crreg) save place where regs are saved
	lda	a.v010-*	(tibtab) init end of tib tab ptr
	sta	a.v011-*,*	(.crtte) so maktib can fill it in
	stz	a.v006-*,*	(bfcksw) enable buffer size checking
	rem
	tra	1,*
	ind	itl010	all set to pick the figtre
	eject
	rem
diexst	oct	020000	bit to be turned on to say dia exists
mexist	ind	exist
	rem
xstsav	ind	*+1	ptr to table of stex reads from devices
	bss	16
	even
ignrad	ind	ignore	ignore interrupts routine
	ind	ignore
	rem
iwcrlf	icw	l.v004,b.0,2
	rem
a.v006	ind	bfcksw
a.v007	ind	istart-1
a.v008	ind	utsave
a.v009	ind	.crreg
a.v010	ind	tibtab
a.v011	ind	.crtte
a.v012	ind	itrcdm
a.v013	ind	mvplmm	lower memory maximum address (in utilities)
a.v014	ind	frebuf
*a.v015		unused
*a.v016		unused
*a.v017		unused
a.v018	ind	setclk
a.v019	ind	nxtrce	(in trace module) next entry in trace buffer
a.v020	ind	.crbuf
a.v021	ind	.crpte	variable cpu page table entry
a.v022	ind	.crmem	last legal memory address
a.v023	ind	endtrc	(in trace module) last word in trace buffer
a.v024	ind	.crtsz
a.v025	ind	.crtrb
a.v026	ind	.crtrc
a.v027	ind	stop15
	rem
l.v001	dec	250	half of a millisecond in inst xec time
l.v002	dec	1000	two milliseconds in inst xec time
l.v003	sel	0
l.v004	vfd	9/cr,9/lf
*l.v005		unused
l.v006	dec	32768
	rem
itemp	bss	1
conswt	bss	1	temporary for .crcon
	end
