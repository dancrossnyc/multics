* ***********************************************************
* *                                                         *
* * Copyright, (C) Honeywell Information Systems Inc., 1982 *
* *                                                         *
* * Copyright (c) 1972 by Massachusetts Institute of        *
* * Technology and Honeywell Information Systems, Inc.      *
* *                                                         *
* ***********************************************************


*HISTORY COMMENTS:
*  1) change(85-10-25,Coren), approve(85-10-25,MCR7274),
*     audit(85-11-17,Beattie):
*     Add a second hardware status queue to the sfcm macro (sf.ast).
*  2) change(85-10-28,Coren), approve(85-10-28,MCR7275),
*     audit(85-11-17,Beattie):
*     Remove definitions of flags no longer used because of change in
*      suspend/resume strategy: sffssb, tfsoip, tforp.
*                                                      END HISTORY COMMENTS

	lbl	macros,macro file for multics communications system
	ttl	multics/mcs system macros
	pcc	on
	rem
	rem	this macro file should be entered on the system
	rem	library with the catalog name '.gmac'
	rem
	ttls	datanet configuration description macro
	rem	this macro should be called at the start of every
	rem	assembly through the use of the op-code "systm" in order
	rem	to define the fnp memory map for the processor, memory,
	rem	iom, and general utility package.  by using the
	rem	location symbols defined below, adaption to a new system
	rem	configuration will require only a reassembly with a
	rem	different macro package.
	rem
*++symget  h1mb,h3mb
*++symget  l1mb,l6mb
*++symlen  h1mb,512,h2mb,512,h3mb,512
*++symlen  l1mb,16,l2mb,16,l3mb,16,l4mb,16,l5mb,16,l6mb,16
*++symget  h1ch,h3ch
*++symget  l1ch,l6ch
*++symget  itmb,etmb
*++symget  cptp,yelcnt
*++symlen  yelcnt,2
	rem
systm	macro	c,m
	ttls	datanet configuration description
	rem
intv	set	0	iom interrupt vector base address
	rem
intc	set	256	program interrupt cell base address
	rem
fltst	set	272	iom fault status base address
	rem
fltv	set	288	processor fault vector base address
	rem
iomm	set	296	iom mailbox base address
	rem
	rem		***************************
	rem		* iom channel assignments *
	rem		***************************
	rem
	rem
tych	set	0	typewriter channel
	rem
lpch	set	2	line printer channel
	rem
h1ch	set	6	high speed line adapter number one
	rem
h2ch	set	7	high speed line adapter number two
	rem
h3ch	set	8	high speed line adapter number three
	rem
l1ch	set	9	low speed line adapter number one
	rem
l2ch	set	10	low speed line adapter number two
	rem
l3ch	set	11	low speed line adapter number three
	rem
l4ch	set	12	low speed line adapter number four
	rem
l5ch	set	13	low speed line adapter number five
	rem
l6ch	set	14	low speed line adapter number six
	rem
tmch	set	63	interval timer channel
	rem
swch	set	63	data switch channel
	eject
	rem		*************************
	rem		* iom interrupt vectors *
	rem		*************************
	rem
tyft	set	0	typewriter fault
	rem
tyrq	set	1	typewriter request
	rem
tytm	set	2	typewriter terminate
	rem
lpft	set	32	line printer fault
	rem
lpat	set	33	line printer attention
	rem
lptm	set	34	line printer terminate
	rem
dis0	set	3	dia special - 0
	rem
dis1	set	19	dia special - 1
	rem
dis2	set	35	dia special - 2
	rem
dis3	set	51	dia special - 3
	rem
dis4	set	67	dia special - 4
	rem
dis5	set	83	dia special - 5
	rem
dis6	set	99	dia special - 6
	rem
dis7	set	115	dia special - 7
	rem
dis8	set	131	dia special - 8
	rem
dis9	set	147	dia special - 9
	rem
dis10	set	163	dia special - 10
	rem
dis11	set	179	dia special - 11
	rem
dis12	set	195	dia special - 12
	rem
dis13	set	211	dia special - 13
	rem
dis14	set	227	dia special - 14
	rem
dis15	set	243	dia special - 15
	rem
h1ft	set	96	hsla 1 fault
	rem
h1a0	set	4	hsla 1 subch  0 active terminate vector
	rem
h1a16	set	5	hsla 1 subch 16 active terminate vector
	rem
h1c0	set	6	hsla 1 subch  0 config terminate vector
	rem
h1c16	set	7	hsla 1 subch 16 config terminate vector
	rem
h1a1	set	20	hsla 1 subch  1 active terminate vector
	rem
h1a17	set	21	hsla 1 subch 17 active terminate vector
	rem
h1c1	set	22	hsla 1 subch  1 config terminate vector
	rem
h1c17	set	23	hsla 1 subch 17 config terminate vector
	rem
h1a2	set	36	hsla 1 subch  2 active terminate vector
	rem
h1a18	set	37	hsla 1 subch 18 active terminate vector
	rem
h1c2	set	38	hsla 1 subch  2 config terminate vector
	rem
h1c18	set	39	hsla 1 subch 18 config terminate vector
	rem
h1a3	set	52	hsla 1 subch  3 active terminate vector
	rem
h1a19	set	53	hsla 1 subch 19 active terminate vector
	rem
h1c3	set	54	hsla 1 subch  3 config terminate vector
	rem
h1c19	set	55	hsla 1 subch 19 config terminate vector
	rem
h1a4	set	68	hsla 1 subch  4 active terminate vector
	rem
h1a20	set	69	hsla 1 subch 20 active terminate vector
	rem
h1c4	set	70	hsla 1 subch  4 config terminate vector
	rem
h1c20	set	71	hsla 1 subch 20 config terminate vector
	rem
h1a5	set	84	hsla 1 subch  5 active terminate vector
	rem
h1a21	set	85	hsla 1 subch 21 active terminate vector
	rem
h1c5	set	86	hsla 1 subch  5 config terminate vector
	rem
h1c21	set	87	hsla 1 subch 21 config terminate vector
	rem
h1a6	set	100	hsla 1 subch  6 active terminate vector
	rem
h1a22	set	101	hsla 1 subch 22 active terminate vector
	rem
h1c6	set	102	hsla 1 subch  6 config terminate vector
	rem
h1c22	set	103	hsla 1 subch 22 config terminate vector
	rem
h1a7	set	116	hsla 1 subch  7 active terminate vector
	rem
h1a23	set	117	hsla 1 subch 23 active terminate vector
	rem
h1c7	set	118	hsla 1 subch  7 config terminate vector
	rem
h1c23	set	119	hsla 1 subch 23 config terminate vector
	rem
h1a8	set	132	hsla 1 subch  8 active terminate vector
	rem
h1a24	set	133	hsla 1 subch 24 active terminate vector
	rem
h1c8	set	134	hsla 1 subch  8 config terminate vector
	rem
h1c24	set	135	hsla 1 subch 24 config terminate vector
	rem
h1a9	set	148	hsla 1 subch  9 active terminate vector
	rem
h1a25	set	149	hsla 1 subch 25 active terminate vector
	rem
h1c9	set	150	hsla 1 subch  9 config terminate vector
	rem
h1c25	set	151	hsla 1 subch 25 config terminate vector
	rem
h1a10	set	164	hsla 1 subch 10 active terminate vector
	rem
h1a26	set	165	hsla 1 subch 26 active terminate vector
	rem
h1c10	set	166	hsla 1 subch 10 config terminate vector
	rem
h1c26	set	167	hsla 1 subch 26 config terminate vector
	rem
h1a11	set	180	hsla 1 subch 11 active terminate vector
	rem
h1a27	set	181	hsla 1 subch 27 active terminate vector
	rem
h1c11	set	182	hsla 1 subch 11 config terminate vector
	rem
h1c27	set	183	hsla 1 subch 27 config terminate vector
	rem
h1a12	set	196	hsla 1 subch 12 active terminate vector
	rem
h1a28	set	197	hsla 1 subch 28 active terminate vector
	rem
h1c12	set	198	hsla 1 subch 12 config terminate vector
	rem
h1c28	set	199	hsla 1 subch 28 config terminate vector
	rem
h1a13	set	212	hsla 1 subch 13 active terminate vector
	rem
h1a29	set	213	hsla 1 subch 29 active terminate vector
	rem
h1c13	set	214	hsla 1 subch 13 config terminate vector
	rem
h1c29	set	215	hsla 1 subch 29 config terminate vector
	rem
h1a14	set	228	hsla 1 subch 14 active terminate vector
	rem
h1a30	set	229	hsla 1 subch 30 active terminate vector
	rem
h1c14	set	230	hsla 1 subch 14 config terminate vector
	rem
h1c30	set	231	hsla 1 subch 30 config terminate vector
	rem
h1a15	set	244	hsla 1 subch 15 active terminate vector
	rem
h1a31	set	245	hsla 1 subch 31 active terminate vector
	rem
h1c15	set	246	hsla 1 subch 15 config terminate vector
	rem
h1c31	set	247	hsla 1 subch 31 config terminate vector
	rem
l1ft	set	144	lsla 1 fault
	rem
l1a	set	145	lsla 1 active terminate vector
	rem
l1c	set	146	lsla 1 configuration terminate vector
	rem
l2ft	set	160	lsla 2 fault
	rem
l2a	set	161	lsla 2 active terminate vector
	rem
l2c	set	162	lsla 2 configuration terminate vector
	rem
l3ft	set	176	lsla 3 fault
	rem
l3a	set	177	lsla 3 active terminate vector
	rem
l3c	set	178	lsla 3 configuration terminate vector
	rem
l4ft	set	192	lsla 4 fault
	rem
l4a	set	193	lsla 4 active terminate vector
	rem
l4c	set	194	lsla 4 configuration terminate vector
	rem
l5ft	set	208	lsla 5 fault
	rem
l5a	set	209	lsla 5 active terminate vector
	rem
l5c	set	210	lsla 5 configuration terminate vector
	rem
l6ft	set	224	lsla 6 fault
	rem
l6a	set	225	lsla 6 active terminate vector
	rem
l6c	set	226	lsla 6 configuration terminate vector
	rem
tmft	set	240	timer channel fault
	rem
tmro	set	241	interval timer runout
	rem
etr	set	242	elapsed timer roll-over
	eject		1
	rem		***************************
	rem		* program interrupt cells *
	rem		***************************
	rem
ilev0	set	256	level 0  (common peripheral fault)
	rem
ilev1	set	257	level 1  (common peripheral req/attn)
	rem
ilev2	set	258	level 2  (common peripheral terminate)
	rem
ilev3	set	259	level 3  (dia special)
	rem
ilev4	set	260	level 4  (hsla 1 subch  0-15 active)
	rem
ilev5	set	261	level 5  (hsla 1 subch 16-31 active)
	rem
ilev6	set	262	level 6  (hsla 1 subch  0-15 config)
	rem
ilev7	set	263	level 7  (hsla 1 subch 16-31 config)
	rem
ilev8	set	264	level 8  (hsla 2 subch  0-15 active)
	rem
ilev9	set	265	level 9  (hsla 2 subch 16-31 active)
	rem
ilev10	set	266	level 10 (hsla 2 subch  0-15 config)
	rem
ilev11	set	267	level 11 (hsla 2 subch 16-31 config)
	rem
ilev12	set	268	level 12 (hsla 3 subch  0-15 active)
	rem
ilev13	set	269	level 13 (hsla 3 subch 16-31 active)
	rem
ilev14	set	270	level 14 (hsla 3 subch  0-15 config)
	rem
ilev15	set	271	level 15 (hsla 3 subch 16-31 config)
	rem
	rem		********************
	rem		* iom fault status *
	rem		********************
	rem
	rem
tyfts	set	272	typewriter fault status word
	rem
lpfts	set	274	line printer fault status word
	rem
difts	set	276	dia fault status word
	rem
h1fts	set	278	hsla 1 fault status word
	rem
h2fts	set	279	hsla 2 fault status word
	rem
h3fts	set	280	hsla 3 fault status word
	rem
l1fts	set	281	lsla 1 fault status word
	rem
l2fts	set	282	lsla 2 fault status word
	rem
l3fts	set	283	lsla 3 fault status word
	rem
l4fts	set	284	lsla 4 fault status word
	rem
l5fts	set	285	lsla 5 fault status word
	rem
l6fts	set	286	lsla 6 fault status word
	rem
tmfts	set	287	timer fault status word
	rem
	rem		***************************
	rem		* processor fault vectors *
	rem		***************************
	rem
	rem
suflt	set	288	startup fault
	rem
sdflt	set	289	shutdown fault
	rem
parflt	set	290	memory parity fault
	rem
iopflt	set	291	illegal operation fault
	rem
ovflt	set	292	overflow fault
	rem
memflt	set	293	illegal memory operation fault
	rem
dvflt	set	294	divide check fault
	rem
ipiflt	set	295	illegal program interrupt fault
	eject
	rem		************************************
	rem		* iom mailbox communication region *
	rem		************************************
	rem
itmb	set	296	interval timer mailbox
	rem
etmb	set	297	elapsed timer mailbox
	rem
dimb	set	300	dia pcw mailbox
	rem
dist	set	302	dia status icw mailbox
	rem
tyst	set	304	typewriter status icw mailbox
	rem
tyicw	set	306	typewriter data icw mailbox
	rem
lpst	set	312	line printer status icw mailbox
	rem
lpicw	set	314	line printer data icw mailbox
	rem
cptp	set	317	cpu page table pointer
	rem
yelcnt	set	318	memory yellow counter (edac corected errors)
	rem
l1mb	set	320	lsla 1 mailbox base address
	rem
l2mb	set	336	lsla 2 mailbox base address
	rem
l3mb	set	352	lsla 3 mailbox base address
	rem
l4mb	set	368	lsla 4 mailbox base address
	rem
l5mb	set	384	lsla 5 mailbox base address
	rem
l6mb	set	400	lsla 6 mailbox base address
	rem
h1mb	set	512	hsla 1 mailbox base address
	rem
h2mb	set	1024	hsla 2 mailbox base address
	rem
h3mb	set	1536	hsla 3 mailbox base address
	rem
.end.	set	1024	end of iom mailbox communication region
	endm	systm
	ttls	system communication region macro
	rem
	rem	this macro defines the locations of the system
	rem	communication region. this region contains
	rem	addresses of various tables and contains
	rem	certain pieces of configuration information.
	rem
*++symget  .crldt,.crcpr
*++symtype .crldt,clock,.crbdt,clock,.crver,character,.crbrk,addr
*++symtype .crskd,addr,.crbtm,addr,.crcpr,character
*++symlen  .crldt,4,.crbdt,4,.crver,2,.crcpr,14
	rem
comreg	macro	c,m
	ttls	system communications region
	rem		**********************************
	rem		*  system communication region   *
	rem		**********************************
	rem
.crldt	set	416	date and time of binding
	rem
.crbdt	set	420	date and time of bootloading
	rem
.crbuf	set	424	starting address of buffer area
	rem
.crmem	set	425	last location of memory
	rem
.crnbf	set	426	number of buffers available
	rem
.criom	set	427	start of iom table
	rem
.crnhs	set	428	number of hsla's configured
	rem
.crnls	set	429	number of lsla's configured
	rem
.crcon	set	430	console enabled flag
	rem
.crmod	set	431	starting address of module chain
	rem
.crnxa	set	432	ptr to next avaliable buffer
	rem
.crtra	set	433	trace entry enable mask
	rem
.crtrb	set	434	base address of trace table
	rem
.crtrc	set	435	next available location in trace table
	rem
.crreg	set	436	disaster fault register storage location
	rem
.crttb	set	437	location of tib table
	rem
.crtte	set	438	location of end of tib table
	rem
.crdly	set	439	head of delay table chain
	rem
.crver	set	440	mcs version number, 4 chars
	rem
.crbrk	set	442	addr of breakpoint control table
	rem
.crtsw	set	443	if non-zero, tracing will cease
	rem
.crnxs	set	444	next free small block
	rem
.crnbs	set	445	number of buffers devoted to small space
	rem
.crcct	set	446	address of first cct descriptor
	rem
.crskd	set	447	address of scheduler data block
	rem
.cretb	set	448	list of echo-negotiation bit tables
	rem
.crcpt	set	449	address of cpu page table
	rem
.crpte	set	450	address of variable cpu page table entry
	rem
.crtsz	set	451	size of trace data buffer
	rem
.crmet	set	452	non-zero if metering enabled
	rem
.crtdt	set	453	address of tib for t&d executive channel
	rem
.crbtm	set	454	address of time meters for getbuf/frebuf
	rem
.crnxe	set	455	next available space in extended memory
	rem
.crbpe	set	456	buffer paging window table entry
	rem
.crcpr	set	496	copyright notice
	endm	comreg
	ttls	macro to define dia mailbox opcode values
	rem
*++symget  termac,linsta,,diaop
	rem
diaop	macro	c,m	rem
	rem	mailbox i/o commands
	rem
rcd	equ	1
rtx	equ	2
wcd	equ	3
wtx	equ	4
	rem
	rem
	rem	mailbox opcodes
	rem
	rem	<6180 -> 355>
	rem
termac	bool	000	terminal accepted
dislin	bool	001	disconnect this line
disall	bool	002	disconnect all lines
noacc	bool	003	don't accept calls
accall	bool	004	accept calls
inacc	bool	005	input accepted
setcls	bool	006	set device class
entrcv	bool	007	enter receive mode
frmchr	bool	010	set framing characters
blast	bool	011	send output to all lines
accout	bool	012	accept output
aclout	bool	013	accept last output
dodial	bool	014	do dial out
rejreq	bool	016	reject request
trmrej	bool	020	terminal rejected
disacc	bool	021	disconnect accepted
incomp	bool	022	init complete
dmpmem	bool	023	dump 355 memory
pchmem	bool	024	patch 355 memory
brkpnt	bool	025	fnp_break order
linctl	bool	026	line_control order
msgsiz	bool	027	set input message size
engstb	bool	030	set echnego break table
engogo	bool	031	start negotiated echo
engoff	bool	032	stop negotiated echo
engini	bool	033	init negotiated echo
brack	bool	035	break acknowledged
infcc	bool	036	set input flow control characters
outfcc	bool	037	set output flow control characters
alter	bool	042	alter parameters
cserr	bool	043	checksum error
rmeter	bool	044	report meters
setdly	bool	045	set delay values
	rem
	rem	<355 -> 6180>
	rem
acctrm	bool	100	accept new terminal
lindis	bool	101	line disconnected
inmbx	bool	102	input in mailbox
linmsk	bool	103	line masked
sparms	bool	104	send 6180 parameters
sndout	bool	105	send output
engain	bool	106	ack_echnego_init
engaof	bool	107	ack_echnego_stop
conslv	bool	111	connect to slave
accin	bool	112	accept input
brkcon	bool	113	line break condition
wrutim	bool	114	"wru" timeout
errmsg	bool	115	error message
acupwi	bool	120	no power to acu
acudlo	bool	121	data line occupied
acuacr	bool	122	dial out failed
acung	bool	123	unable to dial out
linsta	bool	124	line_status signal from control tables
	rem
	endm
	ttls	macro to define alter paramaters dia mailbox codes
	rem
*++symget  alfdpx,al8out,,alterp
alterp	macro	c,m
	rem
	rem	defines alter-parameters subcodes
	rem
	rem
alfdpx	bool	03	full duplex mode
albrk	bool	04	send line break
alcrec	bool	10	crecho mode
allfec	bool	11	lfecho mode
allock	bool	12	lock and unlock keyboard
aldump	bool	15	dump output
altbec	bool	16	tab-echo mode
allisn	bool	20	listen
alquit	bool	21	handle quit
alchng	bool	22	change control string index
alwru	bool	23	read answerback
alecpx	bool	24	echoplex mode
alxhld	bool	25	transmit hold
aldpin	bool	26	dump input
alrply	bool	27	replay mode
alplit	bool	30	polite mode
alfrmi	bool	31	framei mode
alsetb	bool	32	set buffer size
albral	bool	33	breakall mode
alpfnl	bool	34	prefixnl mode
alifc	bool	35	iflow mode
alofc	bool	36	oflow mode
aloddp	bool	37	odd parity
al8in	bool	40	don't strip input parity
al8out	bool	41	don't generate output parity
	rem
	endm
	ttls	die macro
	rem
	rem	this macro is to be used to crash the fnp. it
	rem	will cause an illegal opcode fault and will contain
	rem	some coded information so that one may quickly determine
	rem	the module that caused the crash as well as the
	rem	reason for the crash.  the caller of this macro
	rem	is responsible for having defined a symbol 'modnum'
	rem	which is the module number of the module
	rem	executing the die. the macro takes one argument
	rem	which is a number which will uniquely identify
	rem	the cause for the crash within that module.
	rem
	rem	note that since 11 and 51 are both illegal opcodes,
	rem	the module number can occupy 4 bits; it doesn't
	rem	matter if the high-order bit of the opcode
	rem	is on or off.
	rem
die	macro	c,m
	vfd	4/modnum,o5/11,9/#1 *die*die*die*die*die*die*die*die*die*
	endm	die
	rem
	rem
*	macro to mark beginning of coded transferred to from master
*	dispatcher. This is used to flag the start of the code for
*	call_trace feature of debug_fnp
	rem
mdent	macro	c,m
	oct	1
	tra	2
	tra	-2,*
	endm	mdent
	rem
*	likewise for secondary dispatcher
	rem
sdent	macro	c,m
	oct	2
	tra	2
	tra	-2,*
	endm	sdent
	ttls	subroutine macro
	rem
	rem	the subr macro should be the first statement in a
	rem	subroutine. it creates a zero word to store the
	rem	address into, some register save instructions
	rem	and it contains the register restore instructions.
	rem	the first argument to the macro should be a unique
	rem	3 character (or less) string. this character string
	rem	will be used in building the names of places to store
	rem	specified registers so that the stored registers may
	rem	be referenced by the subroutine. names are of the form
	rem	xxxsn where xxx is the 3 character string, the letter
	rem	s, and n where n is the register name, x1, x2, x3, a
	rem	q, or i (indicators). the registers to be saved
	rem	are specified in parens as the second argument. if
	rem	the character string 'inh' is one of the names, a
	rem	sti followed by an inh will be the first two instr-
	rem	uctions generated and the last will be an ldi before
	rem	returning to the caller.
	rem
subr	macro	c,m
	ind	0	return location
	pmc	save,off
	pcc	save,off
macwk1	set	0
macwk2	set	0
	idrp	#2
	crsm	save,off
	ine	'a','a#2',%endm1
	ife	'#2','inh',6
	pmc	restore
	sti	#1si-*	save indicators
	inh		<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-
	pmc	save,off
macwk1	set	macwk1+2
macwk2	set	macwk2+2
	idrp
	idrp	#2
	ine	'#2','inh',5
	pmc	restore
	st#2	#1s#2-*	save #2
	pmc	save,off
macwk1	set	macwk1+1
macwk2	set	macwk2+2
	idrp
endm1	mark
	pmc	restore
	tra	macwk2+2	go to main body now
	pmc	save,off
macwk2	set	macwk1+1
	idrp	#2
	ine	'a','a#2',%endm1
	ine	'#2','inh',4
	pmc	restore
	ld#2	#1s#2-*	restore #2
	pmc	save,off
macwk2	set	macwk2+1
	idrp
	idrp	#2
	ife	'#2','inh',4
	pmc	restore
	ldi	#1si-*	reload indicators
	pmc	save,off
macwk2	set	macwk2+1
	idrp
endm1	mark
	pmc	restore
	tra	-macwk2-1,*	return to caller
	pmc	save,off
	idrp	#2
	ine	'a','a#2',%endm1
	ine	'#2','inh',3
	pmc	restore
#1s#2	bss	1
	pmc	save,off
	ife	'#2','inh',3
	pmc	restore
#1si	bss	1
	pmc	save,off
	idrp
endm1	mark
	crsm	restore
	pcc	restore
	pmc	restore
	endm	subr
	ttls	return macro
	rem
	rem	this macro is to be executed when returning
	rem	from a subroutine. it takes one argument which
	rem	is the label on the subr macro. it will transfer
	rem	into the code generated by the subr macro
	rem	which will restore the saved registers and
	rem	then return to the caller.
	rem
return	macro	c,m
	tra	1,*	go restore registers
	ind	#1+macwk1+2
	endm	return
	ttls	start macro
	rem	this macro is used immediately before the start
	rem	of executable code in a module. It reserves space
	rem	for the module chain pointer.
	rem
	rem	usage:
	rem	start           name, {mod number}, {sti}
	rem	where name is the 4-character primary symdef
	rem	name for the module
	rem
	rem	mod number is an optional field to indicate the 
	rem	module number
	rem
	rem	sti is an optional field to indicate the software
	rem	technical identifier
	rem
start	macro	c,m
	symdef	-.chain
	crsm	save,off
	even
	ine	'#2','',2
modnum	equ	#2
.chain	dec	#2
	ife	'#2','',1
.chain	dec	0
	crsm	restore
	bci	2,#1
	ind	#1
	date
	ine	'#3','',1
	bci	4,#3
	endm	start
	ttls	trace -- calling memory/printer tracing
	rem
	rem	trace macro is used to pass information to system
	rem	trace routine
	rem
	rem	usage:
	rem
	rem		trace type,switches,(args)
	rem
	rem	type            specifies type of tracing
	rem
	rem	switches        specify which processor switches
	rem		must be on for printer tracing to occur
	rem
	rem	args            specify the addresses of data to be passed
	rem		in one of the following forms:
	rem
	rem		xn -- data to be passed is in xn (n = 1,2,3)
	rem
	rem		symbol -- word to be passed is at specified addr
	rem
	rem		symbol(n) -- address of word to be passed
	rem		is specified symbol modified by xn (n = 1,2 or 3)
	rem
	rem	use of this macro destroys the
	rem	contents of the a register
	rem
trace	macro	c,m
	pmc	save,off
	pcc	save,off
	crsm	save,on
	symdef	-x#4
x#4	tra	#4-*
	crsm	off
macwk3	set	0
macwk4	set	4
	idrp	#3
	trcnt	#3
	idrp
	idrp	#3
	ine	'a','a#3',%endm1
	argt	#3
	idrp
endm1	mark
	pmc	restore
	tsy	3,*
	vfd	6/macwk3,12/#1
	vfd	6/modnum,12/#2
	ind	trace
	bss	macwk3
	crsm	on
#4	null
	crsm	restore
	pmc	save,off
	pcc	restore
	pmc	restore
	endm	trace
	ttls	trcnt macro -- counts arguments for trace
	rem
	rem
trcnt	macro	c,m
macwk3	set	macwk3+1
	ine	#1,'x1',4
	ine	#1,'x2',3
	ine	#1,'x3',2
macwk4	set	macwk4+2
	ife	1,2,1
macwk4	set	macwk4+1
	endm	trcnt
	ttls	argt macro -- used for trace args
	rem
	rem	argt is used internally by trace macro to generate loads and
	rem	stores for trace arguments
	rem
	rem
argt	macro	c,m
	ine	#1,'x1',%stx
	ine	#1,'x2',%stx
	ine	#1,'x3',%stx
macwk4	set	macwk4-1
	pmc	restore
	ife	'#2a','a',3
	lda	#1-*
	sta	macwk4
	ife	1,2,2
	lda	#1,#2
	sta	macwk4
	pmc	save,off
	ife	1,2,%endl
stx	mark
	pmc	restore
	st#1	macwk4
	pmc	save,off
endl	mark
	endm	argt
	ttls	traceb -- buffer tracing macro
	rem
	rem	traceb macro is used to invoke buffer
	rem	tracing routine
	rem
	rem	usage:
	rem
	rem		btrace bufadr,size
	rem
	rem	bufadr          is the address of a word containing the
	rem		address of the buffer. if it is xn (n = 1,2,3)
	rem		the specified index register contains the
	rem		address of the buffer.
	rem
	rem	size            is the size of the buffer in words
	rem
	rem	the buffer address is passed to the tracin routine
	rem	in x3, so that if the bufadr field is not specified as
	rem	as x3, x3 will be modified. if x1 or x2 is specified,
	rem	the a register will be modified as well.
	rem
	rem
traceb	macro	c,m
	pmc	save,off
	pcc	save,off
	crsm	save,on
	pmc	restore
	ine	#1,'x3',%x3
	ine	#1,'x1',1
	ife	#1,'x2',3
	c#1a
	cax3
	ife	1,2,1
	ldx3	#1-*
	pmc	save,off
x3	mark
	pmc	restore
	tsy	#3-*,*
	vfd	6/modnum,12/#2
#3	ind	traceb
	pmc	save,off
	crsm	restore
	pcc	restore
	pmc	restore
	endm	traceb
	ttls	metering macros
	rem
	rem	these macros are used for metering various fnp
	rem	events. they generate code to call the subroutines
	rem	in the meters module. There are 3 macros used in
	rem	system code:
	rem	   cmeter -- per-channel meters
	rem	   smeter -- system-wide meters
	rem	   mmsg -- special for metering synchronous data
	rem	           messages
	rem
	rem	all of them generate a tra around the generated code
	rem	which is replaced by a nop by bind_fnp if the
	rem	bindfile specifies metering enabled
	rem
	rem
	rem	cmeter macro
	rem
	rem	this macro does increment and update meters for
	rem	per-channel meters
	rem	
	rem	Usage:
	rem	cmeter  meter_type,meter_name,address
	rem
	rem	where meter_type is the name of the metering subroutine
	rem	      meter_name is the symbol to be incremented
	rem	      address is the address of the increment
	rem
	rem
cmeter	macro	c,m
	pmc	save,off
	pcc	save,off
	crsm	save,on
	symdef	-m#4
m#4	tra	#4-*
	pmc	restore
	lda	t.metr,1	get address of metering area
	iaa	#2
	idrp	#3
	mload	#3	get increment
	idrp
	tsy	#5-*,*
	tra	#4-*	skip data
#5	ind	#1
#4	null
	crsm	restore
	pmc	save,off
	pcc	restore
	pmc	restore
	endm	cmeter
	rem
	rem
	rem
	rem	smeter macro
	rem
	rem	this macro does increment and update meters for
	rem	system-wide meters
	rem
	rem	Usage:
	rem	smeter	meter_type,meter_name,address
	rem
	rem	where arguments are the same as for cmeter,above
	rem
	rem
smeter	macro	c,m
	pmc	save,off
	pcc	save,off
	crsm	save,on
	symdef	-m#4
m#4	tra	#4-*
	pmc	restore
	lda	#6-*	get address of system meter
	idrp	#3
	mload	#3	get increment
	idrp
	tsy	#5-*,*
	tra	#4-*
#5	ind	#1
#6	ind	#2
#4	null
	crsm	restore
	pmc	save,off
	pcc	restore
	pmc	restore
	endm	smeter
	rem
	rem
	rem	mmsg macro
	rem
	rem	this macro generates a call to mmsg, the subroutine that
	rem	keeps track of synchronous message lengths
	rem
	rem	usage:
	rem	mmsg meter_name
	rem
	rem	where meter_name is m.inm or m.outm for an input or
	rem	output message respectively
	rem
	rem
mmsg	macro	c,m
	pmc	save,off
	pcc	save,off
	crsm	save,on
	symdef	-m#4
m#4	tra	#4-*
	pmc	restore
	lda	t.metr,1
	iaa	#1
	tsy	#3-*,*
	tra	#4-*
#3	ind	mmsg
#4	null
	crsm	restore
	pmc	save,off
	pcc	restore
	pmc	restore
	endm	mmsg
	rem
	rem
	rem	mload macro allows modification in address field
	rem
mload	macro	c,m
	crsm	save,off
	ife	'#2a','a',2
	ldq	#1
	ife	1,2,1
	ldq	#1,#2
	crsm	restore
	endm	mload
	ttls	hwcm macro
	rem
	rem	this macro defines the fields in the hardware
	rem	comm region
	rem
*++symget  h.ric0,h.cnfg,hwcm
*++symlen  h.ric0,2,h.ric1,2,h.sic0,2,h.sic1,2,h.mask,2
*++symlen  h.mask,2,h.aicw,2,h.cnfg,2
*++symdef  hwcm,0
*++symrel  hwcm,hwcm
*++symlen  hwcm,16
	rem
hwcm	macro	c,m
	ttls	hardware comm. region (hwcm)
	rem
h.ric0	equ	0	primary receive icw
	rem
h.ric1	equ	2	alternate receive icw
	rem
h.sic0	equ	4	primary send icw
	rem
h.sic1	equ	6	alternate send icw
	rem
h.baw	equ	8	base address word
	rem
h.sfcm	equ	9	software comm. region address
	rem
h.mask	equ	10	mask register
	rem
h.aicw	equ	12	active status icw
	rem
h.cnfg	equ	14	configuration status
	endm	hwcm
	ttls	hslast macro - define hsla hardware status
	rem
*++symget  hs.rcs,hs.pwi,,hs.1
*++symget  hs.dsr,hs.rto,,hs.2
	rem
hslast	macro	c,m
	ttls	hsla status bits
	rem
	rem	first status word
	rem
hs.rcs	bool	400000	send/rcv status indicator(1=rcv)
hs.nms	bool	200000	normal marker status
hs.dms	bool	100000	delayed marker status
hs.trm	bool	040000	terminate character
hs.aiw	bool	020000	alternate icw active
hs.siw	bool	010000	switching icw's after status store
hs.tro	bool	004000	tally runout
hs.ptr	bool	002000	pre-tally runout
hs.per	bool	001000	parity error, rcv
hs.crj	bool	000400	command reject
hs.dss	bool	000200	data set status change
hs.isd	bool	000100	idle state detect (hdlc)
hs.xte	bool	000040	transfer timing error
hs.fce	bool	000020	frame check sequence error (hdlc)
hs.sqo	bool	000010	status queue overflow (set by software)
hs.nsb	bool	000004	no stop bit rcvd
hs.rab	bool	000004	receive abort (hdlc)
hs.dlo	bool	000002	data line occupied(acu)
hs.pwi	bool	000001	power indicator(acu)
	rem
	rem	second status word
	rem
hs.dsr	bool	400000	data set ready
hs.cts	bool	200000	clear to send
hs.cd	bool	100000	carrier detect
hs.src	bool	040000	supervisory receive
hs.acr	bool	020000	abandon call and retry(acu)
hs.ads	bool	010000	data set status(acu)
hs.ri	bool	004000	ring indicator
hs.brk	bool	002000	line break received
hs.byt	bool	002000	partial byte (hdlc)
hs.rbt	bool	001000	receive block terminate (bsc & hdlc)
hs.rcv	bool	000400	receive mode
hs.xmt	bool	000200	transmit mode
hs.wam	bool	000100	wrap around mode
hs.dtr	bool	000040	data terminal ready
hs.rts	bool	000020	request to send
hs.mby	bool	000010	make busy
hs.sxt	bool	000004	supervisory transmit
hs.crc	bool	000004	crc error (bsc)
hs.tre	bool	000004	tally runout enable (hdlc)
hs.crq	bool	000002	call request(acu)
hs.rto	bool	000002	receive time out (bsc)
	bool	000001
	rem
	endm	hslast
	ttls	sfcm macro
	rem
	rem	this macro defines software comm region for either
	rem	hsla or lsla
	rem	if both used in one module hsla must be first
	rem
*++symget  sf.hcm,sf.lln,sfcm
*++symlen  sf.cfg,2,sf.waq,80,sf.sta,24
*++symdef  sfcm,0
*++symrel  sfcm,sfcm
*++symlen  sfcm,sf.lln
*++symdel  sf.hln,sf.sln,sf.lln,sf.est
*++symgetr sffskd,sffhdl,,sf.flg
	rem
sfcm	macro	c,m
	pcc	save,off
	pmc	save,off
	ife	sfcm.0,1,%first
	ine	#1,'lsla',%second
	pmc	save,on
	seterr	#1	2nd invocation of sfcm must say lsla
	pmc	restore
	org	*-1
	ine	1,1,%exit
second	mark
	pmc	restore
	rem
	rem
	rem	sfcm fields defined for lsla only
	rem
	pmc	save,off
	ine	1,1,%part
first	mark
	ttls	sfcm for #1
	ife	#1,'hsla',%lsla
	pmc	restore
sf.hcm	equ	0	addr of hwcm
	rem
sf.nxa	equ	sf.hcm+1	addr of next available queue entry
	rem
sf.nxp	equ	sf.nxa+1	addr of next queue entry to process
	rem
sf.tly	equ	sf.nxp+1	tally of status queue
	rem
sf.tib	equ	sf.tly+1	addr of tib for this line
	rem
sf.flg	equ	sf.tib+1	flag word
	rem
sf.ib0	equ	sf.flg+1	pointer to input buffer 1
	rem
sf.ib1	equ	sf.ib0+1	pointer to input buffer 2
	rem
sf.ob0	equ	sf.ib1+1	pointer to output buffer 1
	rem
sf.ob1	equ	sf.ob0+1	pointer to output buffer 2
	rem
sf.pcw	equ	sf.ob1+1	current pcw 2nd word
	rem
sf.cct	equ	sf.pcw+1	cct addr for this line, if non-zero
	rem
sf.rct	equ	sf.cct+1	repeat count for status queue overflows
	rem
sf.hsl	equ	sf.rct+1	address of hsla table entry for this line
	rem
sf.bsz	equ	sf.hsl+1	max buffer size
	rem
sf.fbs	equ	sf.bsz+1	buffer size to be used during frame input
	rem
sf.mms	equ	sf.fbs+1	maximum synchronous message size
	rem
sf.csz	equ	sf.mms	current asynchronous buffer size
	rem
sf.rms	equ	sf.mms+1	remaining unallocated message length
	rem
sf.nic	equ	sf.rms	char. address of next asynchronous input char
	rem
sf.noc	equ	sf.nic+1	**not used** char address of next asynchronous output char
	rem
sf.ssl	equ	sf.noc+1	number of entries in software status queue
	rem
sf.cfg	equ	sf.ssl+1	2 words for config pcw
	rem
sf.sta	equ	sf.cfg+2	hardware status q, sicw here (primary)
	rem
sfhsiz	equ	5	number of entries in hardware status buf
	rem
	rem		room for 6 status words
sf.est	equ	sf.sta+sfhsiz*2+2
	rem
sf.shq	equ	sf.est	hardware status q, sicw here (secondary)
	rem
	rem		room for 6 more status word
sf.ast	equ	sf.shq+sfhsiz*2+2
	rem
sf.hln	equ	sf.ast
	rem
sf.waq	equ	sf.ast	wrap around queue, software status q
	rem
sfssq	equ	10	length of "short" software status queue
sflsq	equ	20	length of "long" software status queue
	rem		(used for hdlc and bisync lines)
	rem
sf.sln	equ	sf.hln+sfssq
sf.lln	equ	sf.hln+sflsq
	rem
	rem
	rem	sfcm flag definitions
	rem
sffskd	bool	000001	status processor is scheduled
	rem
sffcii	bool	000002	on if alternate input icw is active
	rem
sffcoi	bool	000004	on if alternate output icw is active
	rem
sffisc	bool	000010	inactive subchannel flag
	rem
sffsct	bool	000020	short cct flag
	rem
sffebd	bool	000040	ebcdic data code on this line
	rem
sffech	bool	000100	tab, cr, lf echo going on now
	rem
sffdct	bool	000200	dynamic (sharable) cct in use for channel
	rem
sffstp	bool	000400	stop channel, rxmit done
	rem
sffcai	bool	001000	on if altermate status queue is active
	rem
sffbsc	bool	002000	binary synchronous device
	rem
sffsqo	bool	004000	status queue overflow pending
	rem
sffsyn	bool	010000	any synchronous line type
	rem
sffmsp	bool	020000	marker status pending
	rem
sffofr	bool	040000	old setting of tffrmi (lines up on tffrmi)
	rem
sffnib	bool	100000	need to allocate new input buffer(s)
	rem
*unused	bool	200000
	rem
sffhdl	bool	400000	uses hdlc channel board
	rem
	rem
sfhmk	equ	2	x-or mask to switch icw addrs
sfbfmk	equ	1	x-or mask to switch i-or-ob1/2 addrs
	pmc	save,off
	ine	1,1,%exit
lsla	mark
	ife	sfcm.0,0,%part
	pmc	restore
sf.hcm	equ	0	hardware comm. region address
	rem
sf.nxa	equ	sf.hcm+1	current input status pointer
	rem
sf.nxp	equ	sf.nxa+1	status save buffer ptr
	rem
sf.ioc	equ	sf.nxp+1	i/o chain pointer
	rem
sf.bfc	equ	sf.ioc+1	current input buffer ptr
	rem
sf.flg	equ	sf.bfc+1	flag word
	pmc	save,off
	ine	1,1,%rest
part	mark
	pmc	restore
sf.ioc	equ	sf.nxp+1	i/o chain pointer
	rem
sf.bfc	equ	sf.ioc+1	current input buffer pointer
	pmc	save,off
rest	mark
	pmc	restore
	rem
sf.bfa	equ	sf.flg+1	alternate input buffer ptr
	rem
sf.bfl	equ	sf.bfa+1	output buffer length
	rem
sf.icw	equ	sf.bfl+1	ptr to current input icw
	rem
sf.ocw	equ	sf.icw+1	ptr to current output icw
	rem
sf.ltb	equ	sf.ocw+1	ptr to lsla table
	rem
sf.otb	equ	sf.ltb+1	ptr to output buffer
	rem
sf.ity	equ	sf.otb+1	tally for input icw
	rem
sf.oty	equ	sf.ity+1	tally for output icw
	rem
sf.sic	equ	sf.oty+1	standard status icw
	rem
sf.ssb	equ	sf.sic+2	status save buffer (10 words)
	rem
sf.sbf	equ	sf.ssb+10	status buffer (8 words)
	rem
	rem	bit definitions for sf.flg
	rem
sffrlm	bool	200	already sent error message about resync attempts
	rem
sffopt	bool	100	dsr and cts reported
	rem
sffrsy	bool	40	resync required
	rem
sffptr	bool	20	expecting input ptro
	rem
sffrun	bool	10	lsla running ok
	rem
sffnsx	bool	4	no stx on last input frame
	rem
sffsnd	bool	2	second output buffer current
	rem
sffslo	bool	1	short frame lsla (22 time slots)
	pmc	save,off
exit	mark
sfcm.0	set	1
	pmc	restore
	pcc	restore
	endm	sfcm
	ttls	tib macro
	rem
	rem	this macro defines the tib fields, the tib flags,
	rem	and the values in t.stat
	rem
*++symget  t.stat,t.leng,tib
*++symlen  t.time,2
*++symlen  t.itim,2
*++symtype t.cur,addr,t.reta,addr,t.dcwa,addr
*++symdef  tib,0
*++symrel  tib,tib
*++symlen  tib,t.leng
*++symdel  t.leng
*++symgetr tsfcd,tsfcrq,,t.stat
*++symgetr tfwrit,tfosus,,t.flg
*++symget  tfdlup,tfdlup,,t.flg
*++symgetr tfxhld,tfpfnl,,t.flg2
*++symgetr tfbkpt,tfinq,,t.flg3
	rem
tib	macro	c,m
	ttls	terminal information block (tib)
	rem
t.stat	equ	0	holds current line status
	rem
t.flg	equ	t.stat+1	flag word
	rem
t.flg2	equ	t.flg+1	second word of flags
	rem
t.cur	equ	t.flg2+1	current address in control table
	rem
t.line	equ	t.cur+1	10 bit line number
	rem
t.icp	equ	t.line+1	first buffer in input chain
	rem
t.ilst	equ	t.icp+1	last buffer in input chain
	rem
t.icpl	equ	t.ilst+1	count of buffers in icp chain
	rem
t.icch	equ	t.icpl+1	address of next input character
	rem
t.elnk	equ	t.icch+1	link to tib extension
	rem
t.rcp	equ	t.elnk	replay chain pointer (share t.elnk)
	rem
t.ocp	equ	t.elnk+1	addr of output chain from cs
	rem
t.ocur	equ	t.ocp+1	addr of current output buffer
	rem
t.olst	equ	t.ocur+1	addr of last buffer in output chain
	rem
t.occh	equ	t.olst+1	addr of next output character
	rem
t.ocnt	equ	t.occh+1	count of buffers in t.ocur
	rem
t.type	equ	t.ocnt+1	line type
	rem
t.time	equ	t.type+1	time at which next timeout will occur
	rem
t.reta	equ	t.time+2	return address from calsub
	rem
t.dcwa	equ	t.reta+1	addr of dcw list to 'execute'
	rem
t.dcwl	equ	t.dcwa+1	length of dcw list
	rem
t.echo	equ	t.dcwl+1	echo buffer address
	rem
t.dcp	equ	t.echo+1	addr of message chain for cs
	rem
t.dlst	equ	t.dcp+1	last buffer in messge chain for cs
	rem
t.ftse	equ	t.dlst+1	first time slot entry in lsla table
	rem
t.sfcm	equ	t.ftse	pointer to sfcm for hsla lines
	rem
t.bcnt	equ	t.ftse+1	counting temporary
	rem
t.brkp	equ	t.bcnt+1	pointer to current break list
	rem
t.pos	equ	t.brkp+1	current carriage position
	rem
t.char	equ	t.pos+1	pending line control char (lsla only)
	rem
t.ecch	equ	t.char	address of current echo char (hsla only)
	rem
t.cntr	equ	t.char+1	counter for control tables
	rem
t.flg3	equ	t.cntr+1	third word of flags
	rem
t.dtp	equ	t.flg3+1	pointer to delay table for this line
	rem
t.frmc	equ	t.dtp+1	framing chars (2 chars)
	rem
t.dcpl	equ	t.frmc+1	number of buffers in dcp chain
	rem
t.scll	equ	t.dcpl+1	screenline length left, for echo neg.
	rem
t.sncc	equ	t.scll+1	Echo negotiation sync ctr.
	rem
t.entp	equ	t.sncc+1	Echo negotiation break table ptr
	rem
t.ifch	equ	t.entp+1	input flow control characters
	rem
t.ofch	equ	t.ifch+1	output flow control characters
	rem
t.omct	equ	t.ofch+1	output message count (for flow control)
	rem
t.itim	equ	t.omct+1	time of last call to inproc (2 words)
	rem
t.metr	equ	t.itim+2	address of metering area
	rem
t.abf0	equ	t.metr+1	absolute address of first permanent buffer
	rem
t.abf1	equ	t.abf0+1	absolute address of first permanent buffer
	rem
t.leng	equ	t.abf1+1	length of a tib
	rem
	rem		********************************
	rem		* t.stat bits
	rem		********************************
	rem
	rem
tsfcd	bool	000001	carrier detect
	rem
tsfcts	bool	000002	clear to send
	rem
tsfdsr	bool	000004	data set ready
	rem
tsfsrc	bool	000010	supervisory receive
	rem
tsfst	bool	000020	store status
	rem
tsfmrk	bool	000040	send marker status
	rem
tsftrm	bool	000100	send terminate status
	rem
tsfrcv	bool	000200	receive mode
	rem
tsfxmt	bool	000400	transmit mode
	rem
tsfbrk	bool	001000	send line break
	rem
tsfdtr	bool	002000	data terminal ready
	rem
tsfsxt	bool	004000	supervisory transmit
	rem
tsftre	bool	004000	tally runout enable (hdlc)
	rem
tsfrts	bool	010000	request to send
	rem
tsfcrq	bool	020000	acu call request
	rem
	rem
	rem		********************************
	rem		* tib flags -- t.flg
	rem		********************************
	rem
	rem
tfwrit	bool	000001	output chain present
	rem
tfbel	bool	000002	send bell as next echoed character
	rem
tffdpx	bool	000004	full duplex mode
	rem
tfkybd	bool	000010	keyboard addressed
	rem
tfprtr	bool	000020	printer addressed
	rem
tfhang	bool	000040	hangup this line
	rem
tflisn	bool	000100	answer the phone
	rem
tfquit	bool	000200	send nl on line break
	rem
tfctrl	bool	000400	do kybd/printer addressing
	rem
tflfec	bool	001000	do lf echo on cr
	rem
tfcrec	bool	002000	do cr echo on lf
	rem
tftbec	bool	004000	do space echo on tab
	rem
tfwabt	bool	010000	do write abort
	rem
tfauto	bool	020000	this is hsla autobaud line
	rem
tfeotx	bool	040000	eot expected from 2741
	rem
tfisus	bool	100000	input suspended
	rem
tfecpx	bool	200000	echoplex mode
	rem
tfosus	bool	400000	output suspended
	rem
	rem		********************************
	rem		* second word of tib flags
	rem		********************************
	rem
	rem
tfxhld	bool	000001	hold transmit on
	rem
tfdild	bool	000002	terminal is dialed up
	rem
tfercv	bool	000004	enter receive mode
	rem
tfrabt	bool	000010	do read abort
	rem
tfacu	bool	000020	do dial out
	rem
tfifc	bool	000040	input flow control mode
	rem
tfofc	bool	000100	output flow control mode
	rem
tfupsf	bool	000200	terminal is upshifted now
	rem
tfrply	bool	000400	replay mode
	rem
tfrpon	bool	001000	replay is occurring now
	rem
tfplit	bool	002000	polite mode
	rem
tfblak	bool	004000	asynchronous block acknowledgement
	rem
tfcrcv	bool	010000	'control' receive mode
	rem
tfmrcv	bool	020000	'message' receive mode
	rem
tffrmi	bool	040000	frame mode
	rem
tffip	bool	100000	frame in progress
	rem
tfsftr	bool	200000	terminal is shifting device
	rem
tfpfnl	bool	400000	line is in prefixnl mode
	rem
	rem
	rem		*********************************
	rem		* third word of tib flags
	rem		*********************************
	rem
	rem
tfbkpt	bool	000001	line is stopped at breakpoint
	rem
tfitim	bool	000002	timeout if input stops
	rem
tfkpar	bool	000004	keep parity bits
	rem
tfecho	bool	000010	echoing has priority over output (lsla)
	rem
tfbral	bool	000020	break on all characters
	rem
tfsked	bool	000040	input timeout routine scheduled
	rem
tf8in	bool	000100	don't strip input parity
	rem
tf8out	bool	000200	don't strip output parity
	rem
tfoddp	bool	000400	odd parity
	rem
tfabf0	bool	001000	t.afb0 available
	rem
*unused	bool	002000
	rem
*unused	bool	004000
	rem
tfabf1	bool	010000	t.abf1 available
	rem
tfmask	bool	020000	channel has been masked for excessive interrupts
	rem
tfinq	bool	040000	input is queued for the channel
	rem
	rem
	rem		*********************************
	rem		* redefined tib flags in t.flg
	rem		*********************************
	rem
	rem
tfdlup	equ	tfprtr	line is on dialup modem
	endm	tib
	ttls	tsttib - macro which decides which word of tib flags contains a bit
	rem
tsttib	macro	c,m
	ine	'#1','tfwrit',%tfwrd1
	ine	'#1','tffdpx',%tfwrd1
	ine	'#1','tfkybd',%tfwrd1
	ine	'#1','tfprtr',%tfwrd1
	ine	'#1','tfhang',%tfwrd1
	ine	'#1','tflisn',%tfwrd1
	ine	'#1','tfquit',%tfwrd1
	ine	'#1','tfctrl',%tfwrd1
	ine	'#1','tflfec',%tfwrd1
	ine	'#1','tfcrec',%tfwrd1
	ine	'#1','tftbec',%tfwrd1
	ine	'#1','tfwabt',%tfwrd1
	ine	'#1','tfauto',%tfwrd1
	ine	'#1','tfeotx',%tfwrd1
	ine	'#1','tfbel',%tfwrd1
	ine	'#1','tfisus',%tfwrd1
	ine	'#1','tfecpx',%tfwrd1
	ine	'#1','tfosus',%tfwrd1
	ine	'#1','tfdlup',%tfwrd1
	ine	'#1','tfxhld',%tfwrd2
	ine	'#1','tfdild',%tfwrd2
	ine	'#1','tfercv',%tfwrd2
	ine	'#1','tfrabt',%tfwrd2
	ine	'#1','tfacu',%tfwrd2
	ine	'#1','tfifc',%tfwrd2
	ine	'#1','tfofc',%tfwrd2
	ine	'#1','tfupsf',%tfwrd2
	ine	'#1','tfrply',%tfwrd2
	ine	'#1','tfrpon',%tfwrd2
	ine	'#1','tfplit',%tfwrd2
	ine	'#1','tfblak',%tfwrd2
	ine	'#1','tfcrcv',%tfwrd2
	ine	'#1','tfmrcv',%tfwrd2
	ine	'#1','tffrmi',%tfwrd2
	ine	'#1','tffip',%tfwrd2
	ine	'#1','tfsftr',%tfwrd2
	ine	'#1','tfpfnl',%tfwrd2
	seterr	#1	not valid tib flag
	org	*-1
	ine	1,1,%done
tfwrd1	mark
tfwrd1	set	tfwrd1+#1
	ine	1,1,%done
tfwrd2	mark
tfwrd2	set	tfwrd2+#1
done	mark
	endm	tsttib
	ttls	meters macro - define system & channel meters
	rem
*++symget .mdilc,.mleng
*++symlen .mdilc,2,.mdilu,2,.mspav,2,.mspau,2,.mimbx,2,.mimbu,2,.mbufa,2
*++symlen .mbfpa,2,.mupab,2,.mpanf,2
*++symget m.dql,m.synl,meters
*++symlen m.dql,2,m.dqu,2,m.nst,2,m.nsu,2
*++symlen m.prex,2,m.exh,2,m.ebof,2
*++symlen m.nim,2,m.iml,2,m.nom,2,m.oml,2,m.cnt1,2,m.cnt2,2
*++symlen m.cnt3,2,m.cnt4,2,m.cnt5,2,m.cnt6,2,m.cnt7,2,m.cnt8,2
	rem
	rem	this macro defines system-wide meters kept
	rem	in low memory and per-channel meters pointed
	rem	to by t.metr
	rem
meters	macro	c,m
	ttls	system-wide meters
	rem
.mdilc	set	464	cumulative no. of channels dialed
	rem
.mdilu	set	466	updates of .mdilc
	rem
.mspav	set	468	cumulative space available
	rem
.mspau	set	470	updates of .mspav
	rem
.mimbx	set	472	cumulative number of mbxes in use
	rem
.mimbu	set	474	updates of .mimbx
	rem
.mndil	set	476	current no. of channels dialed
	rem
.malof	set	477	number of space allocation failures
	rem
.mdias	set	478	abnormal dia status
	rem
.mpool	set	479	total size of buffer pool (in words)
	rem
.mbufa	set	480	number of buffer allocations
	rem
.mbfpa	set	482	number of buffers pre-allocated
	rem
.mupab	set	484	used a pre-allocated buffer
	rem
.mpanf	set	486	no pre-allocated buffer available
	rem
.mblow	set	488	buffer allocated in low memory
	rem
.mleng	equ	.mpanf+2-.mdilc	length of system-wide meters
	ttls	per-channel meters
	rem
	rem	meters for all channels
	rem
m.dql	equ	0	cumulative length of dia request queue
	rem
m.dqu	equ	m.dql+2	updates of m.dql
	rem
m.nst	equ	m.dqu+2	cumulative no. of pending status
	rem
m.nsu	equ	m.nst+2	updates of m.nst
	rem
m.over	equ	m.nsu+2	output overlaps
	rem
m.par	equ	m.over+1	parity errors
	rem
m.ssqo	equ	m.par+1	software status queue overflows
	rem
m.hsqo	equ	m.ssqo+1	hardware status queue overflows
	rem
m.inaf	equ	m.hsqo+1	input allocation failures
	rem
m.cql	equ	m.inaf+1	current length of dia request queue
	rem
m.exh	equ	m.cql+1	exhaust status
	rem
m.xte	equ	m.exh+2	software xte status
	rem
m.leng	equ	m.xte+2	length of common meters (must be even)
	rem
	rem
	rem	additional meters for asynchronous channels
	rem
m.prex	equ	m.leng	pre-exhaust status
	rem
m.ebof	equ	m.prex+2	echo buffer overflows
	rem
m.quit	equ	m.ebof+2	bell-quits
	rem
m.asyl	equ	m.quit+2	total length of asynchronous meters
	rem		(must be even)
	rem
	rem
	rem	additional meters for synchronous channels
	rem
m.nim	equ	m.leng	number of input messages
	rem
m.iml	equ	m.nim+2	cumulative length of input
	rem
m.mini	equ	m.iml+2	minimum length of input message
	rem
m.maxi	equ	m.mini+1	maximum length of input message
	rem
m.nom	equ	m.maxi+1	number of output messages
	rem
m.oml	equ	m.nom+2	cumulative length of output
	rem
m.mino	equ	m.oml+2	minimum length of output message
	rem
m.maxo	equ	m.mino+1	maximum length of output message
	rem
m.cnt1	equ	m.maxo+1	first type of counter
	rem
m.cnt2	equ	m.cnt1+2	second type of counter
	rem
m.cnt3	equ	m.cnt2+2	third type of counter
	rem
m.cnt4	equ	m.cnt3+2	fourth type of counter
	rem
m.cnt5	equ	m.cnt4+2	fifth type of counter
	rem
m.cnt6	equ	m.cnt5+2	sixth type of counter
	rem
m.cnt7	equ	m.cnt6+2	seventh type of counter
	rem
m.cnt8	equ	m.cnt7+2	eighth type of counter
	rem
m.synl	equ	m.cnt8+2	total length of synchronous meters
	endm	meters
	ttls	intm - interrupt time meters structure
	rem
	rem
intm	macro	c,m
	rem
	rem	**********************************************
	rem	* structure describing meters of time spent in
	rem	* inhibited routines
	rem	**********************************************
	rem
it.tot	equ	0	running total of time spent
	rem
it.inc	equ	2	number of updates to it.tot
	rem
it.gt1	equ	4	number of times time spent was > 1 msec
	rem
it.max	equ	7	maximum time spent in one invocation
	rem		(right half of doubleword)
	endm	intm
	ttls	hslatb - define hsla table
	rem
	rem
hslatb	macro	c,m
	rem
	rem	********************************************
	rem	* hsla table symbol definitions
	rem	********************************************
	rem
ht.flg	equ	0	hsla tables flag bits
ht.tib	equ	1	tib ptr in hsla table
	rem
htfcc	bool	400000	concentrator channel
htfpl	bool	200000	private line modem or hardwire
htfasy	bool	100000	async channel
htfop1	bool	040000	option 1
htfop2	bool	020000	option 2
htfmdm	bool	017000	modem type, 4 bits
htflnt	bool	000760	line type, 5 bits
htfspd	bool	000017	line speed, 4 bits
	rem
	rem
	endm	hslatb
	ttls	cctdef - define symbols for cct creation
	rem
	rem	this macro setups bit for cct creation
	rem
cctdef	macro	c,m
	rem
	rem	cct control bit definitions
	rem
ct.ncs	bool	000	normal char store
ct.t1s	bool	001	store and terminate on next
ct.t2s	bool	002	store and terminate after 2 chars
ct.t0s	bool	003	store and terminate
ct.dmk	bool	004	store and marker delayed
ct.mk1	bool	005	store and marker on next
ct.ign	bool	006	ignore, no store
ct.mrk	bool	007	store and marker
ct.sw	bool	020	switch icws
ct.syn	bool	040	resync channel
ct.tb1	bool	100	switch to table 1
ct.tb2	bool	200	switch to table 2
ct.tb3	bool	300	switch to table 3
ct.tb4	bool	400	switch to table 4
	rem
ct.eol	equ	ct.sw+ct.t0s	eol for regular tty
ct.grt	equ	ct.sw+ct.syn+ct.t1s for etx plus bcc char
ct.etx	equ	ct.t1s+ct.sw+ct.tb4
ct.nak	equ	ct.t0s+ct.sw+ct.tb4
ct.itb	equ	ct.mk1
ct.stx	equ	ct.tb2+ct.dmk
ct.mtb	equ	ct.mrk+ct.tb2
	rem
	rem	** following codes are for setcct opblock
	rem
scc.dl	equ	0	delete current cct
scc.df	equ	1	set to default cct based on modes
scc.bs	equ	2	reset to base of current cct
	rem
	endm	cctdef
	ttls	csbits macro
	rem	this macro defines "control" bits and standard
	rem	stats bits
	rem
*++symgetr s.cd,s.ads,,istat
*++symget  s.rto,s.pbyt,,istat
*++symgetr c.srec,c.scmd,,cmd
*++symgetr c.scrq,c.rcrq,,cmd
	rem
csbits	macro	c,m
	ttls	control and status bits
	rem	control bits
	rem
	rem
c.srec	bool	000001	set receive mode
	rem
c.rrec	bool	000002	reset receive mode
	rem
c.sxmt	bool	000004	set transmit mode
	rem
c.rxmt	bool	000010	reset transmit mode
	rem
c.sdtr	bool	000020	set data terminal ready
	rem
c.rdtr	bool	000040	reset data terminal ready
	rem
c.ssup	bool	000100	set supervisory transmit mode
	rem
c.stre	bool	000100	set tally runout enable (hdlc)
	rem
c.rsup	bool	000200	reset supervisory transmit mode
	rem
c.rtre	bool	000200	reset tally runout enable (hdlc)
	rem
c.stat	bool	000400	store status
	rem
c.sbrk	bool	001000	send line break
	rem
c.smrk	bool	002000	store marker status
	rem
c.strm	bool	004000	store terminate status
	rem
c.srqs	bool	010000	set request to send
	rem
c.rrqs	bool	020000	reset request to send
	rem
c.pad	bool	040000	unused
	rem
c.cmd	bool	100000	indicates cmd subop
	rem
c.scmd	bool	400000	indicates supplementary cmd subop
	rem
	rem		the following must be used in the
	rem		optional fields to the cmd (or
	rem		contrl) macros in the
	rem		control_tables
	rem
	rem
c.scrq	bool	000001	set call request
	rem
c.rcrq	bool	000002	reset call request
	rem
	rem
	rem	status bits
	rem
	rem
s.cd	bool	000001	carrier detect
	rem
s.cts	bool	000002	clear to send
	rem
s.dsr	bool	000004	data set ready
	rem
s.sprc	bool	000010	supervisory receive mode
	rem
s.st	bool	000020	status requested
	rem
s.mark	bool	000040	marker status
	rem
s.term	bool	000100	terminate status
	rem
s.prex	bool	000200	pre-exhaust
	rem
s.brk	bool	000400	line break received
	rem
s.brch	bool	001000	break character received
	rem
s.ring	bool	002000	ring
	rem
s.exh	bool	004000	exhaust status
	rem
s.prty	bool	010000	parity error
	rem
s.fcse	bool	010000	frame check sequence error (hdlc)
	rem
s.xte	bool	020000	transfer timing error
	rem
s.pwi	bool	040000	acu power indicator
	rem
s.dlo	bool	100000	acu data line occupied
	rem
s.acr	bool	200000	acu abandon call and retry
	rem
s.ads	bool	400000	acu raised data set status
	rem
	rem	the following four bits share
	rem	the values of acu status but can never
	rem	be misinterpreted.
	rem
s.rto	bool	040000	receive time out (bsc)
	rem
s.isd	bool	040000	idle state detect (hdlc)
	rem
s.rbt	bool	100000	receive block termination (bsc & hdlc)
	rem
s.bmk	bool	200000	marker status (bsc)
	rem
s.rabt	bool	200000	receive abort (hdlc)
	rem
s.bdmk	bool	400000	delayed marker status (bsc)
	rem
s.pbyt	bool	400000	partial byte (hdlc)
	rem
	rem
	rem		bits in common between standard status
s.tib	bool	000177	and tib status
	rem
	rem		dataset status bits in standard status
s.dss	bool	000017	and tib status
	rem
	rem
	rem	asynchronous configuration bits
	rem
	rem
	rem
fg.icw	bool	000001	icw (two send ICW's)
	rem
fg.lpr	bool	000002	lateral parity receive
	rem
fg.lps	bool	000004	lateral parity send
	rem
fg.lpo	bool	000010	lateral parity odd
	rem
fg.5bt	bool	000020	5-bit character mode
	rem
fg.6bt	bool	000040	6-bit character mode
	rem
fg.7bt	bool	000100	7-bit character mode
	rem
fg.8bt	bool	000200	8-bit character mode
	rem
	rem
fg.beb	bool	000400	ebcdic mode (bsc)
	rem
fg.itf	bool	000400	interfame time fill (hdlc)
	rem
fg.btr	bool	001000	transparent mode (bsc)
	rem
fg.cct	bool	002000	enable cct
	rem
	endm	csbits
	ttls	devtab macro
	rem
	rem	this macro defines the fields in the device table
	rem
devtab	macro	c,m
	ttls	device table entry (devtab)
	rem		two characters used alternately for
	rem
dt.seq	equ	0	sequencing
	rem
dt.cct	equ	dt.seq+1	address of default cct (hsla only)
	rem		address of array of keyboard addressing
	rem
dt.key	equ	dt.cct+1	sequences
	rem		address of array of printer addressing
	rem
dt.prt	equ	dt.key+1	sequences
	rem
dt.flg	equ	dt.prt+1	flags(one word)
	rem
dt.cmt	equ	dt.flg+1	carriage movement table (6 chars)
	rem
dt.brk	equ	dt.cmt+3	default break list (4 words) (lsla only)
	rem
	rem		flags
	rem
dtfctl	bool	000001	default setting of tfctrl (in tib)
	rem
dtfsct	bool	000002	default setting of short cct flag
	rem
dtfsft	bool	000004	default setting of tfsftr
	endm	devtab
	ttls	dlytbl macro
	rem
	rem	this macro defines the fields in the delay table
	rem
dlytbl	macro	c,m
	ttls	delay table entry (dlytbl)
	rem
	rem
dl.fwd	equ	0	forward pointer
	rem
dl.bck	equ	1	back pointer
	rem
dl.rfc	equ	2	reference count
	rem
dl.hsz	equ	3	header size - also for echnego tables.
	rem
dl.lf	equ	3	delays for line feed
	rem
dl.cr	equ	4	per-column delay factor for carriage return
	rem
dl.tba	equ	5	initial delay for tab
	rem
dl.tbb	equ	6	per-column delay factor for tab
	rem
dl.bs	equ	7	delays for backspace
	rem
dl.ff	equ	8	delays for form feed
	rem
	rem
dl.siz	equ	9	size of table entry
	endm	dlytbl
	ttls	global macro
	rem
	rem	this macro defines the bits in the "global switches"
	rem
global	macro	c,m
	ttls	global switches
	rem
gbfup	bool	000001	cs is up
	rem
gbfhng	bool	000002	we've received "blast hangup"
	rem
gbfbla	bool	000004	doing "blast" output
	endm	global
	ttls	buffer macro
	rem
	rem	this macro defines the fields in a standard buffer
	rem
*++symget  bufsmk,bufsmk,,bf.flg
*++symget  bfflst,bffhld,,bf.flg
*++symget  buftmk,buftmk,,bf.flg
*++symtype bufsmk,octal,buftmk,octal
	rem
buffer	macro	c,m
	ttls	buffer format
	rem
bf.nxt	equ	0	address of next buffer in chain
	rem
bf.siz	equ	bf.nxt+1	size of buffer (bits0-2)
	rem
bf.flg	equ	bf.nxt+1	flags (bits3-8)
	rem
bf.tly	equ	bf.nxt+1	tally of buffer (bits9-17)
	rem
bf.dta	equ	bf.siz+1	start of data
	rem
bufsiz	equ	32	buffer size
	rem
bufnch	equ	bufsiz*2-4	number of data characters in a buffer
	rem
bufmax	equ	40	maximum number of input buffers
	rem
bufpre	equ	10	number of buffers to trigger pre-exhaust
	rem
bufshf	equ	5	number of bits shifted to divide by bufsiz
	rem
bufres	equ	20	number of reserved buffers
	rem
bufsmk	bool	700000	mask to isolate bf.siz
	rem
buffmk	bool	077000	mask to isolate bf.flg
	rem
buftmk	bool	000777	mask to isolate bf.tly
	rem
bufthr	equ	2	threshold at which to send send_output
	rem
bfmsiz	equ	256	maximum buffer size in words
	rem
	rem		********************************
	rem		* buffer flags
	rem		********************************
	rem
	rem
bfflst	bool	040000	last buffer in message
	rem
bffbrk	bool	020000	buffer contains break character
	rem
bfftra	bool	010000	throw away this buffer when done inputting
	rem
bffrpy	bool	004000	buffer is last in replay chain
	rem
bffctl	bool	002000	buffer consists of keybd/prtr control
	rem
bffhld	bool	001000	hold output buffer until dmpout
	endm	buffer
	ttls	tconst macro
	rem
	rem
	rem	this macro defines various flags, control bits,
	rem	and character constants for the control_tables
	rem	modules
	rem
	rem
tconst	macro	c,m
	ttls	flag and control bit definitions
	rem
gbf6up	bool	000001	cs up global switch
	rem
	rem	device types
	rem
ttasci	equ	1	ascii terminals, cdi, tty 33, 35, 37, etc.
tt1050	equ	2	ibm 1050
tt2741	equ	3	ibm 2741, trendata, dura, etc.
ttards	equ	4	ards, tektronix
ttsync	equ	5	general sync devices
ttg115	equ	6	remote computer interface, g115
ttbsc	equ	7	binary synchronous communications
tt202c	equ	8	ascii on 202c6 modem
ttvip	equ	9	vip terminal
ttpvip	equ	16	polled vip
ttx25l	equ	17	X.25 Link Access Procedure (LAP)
ttcolt	equ	19	colts (online t&d executive)
	rem
	rem	signal types
	rem
quit	bool	113	dia cmd, break received
dialup	bool	100	dia cmd, accept new terminal
hangup	bool	101	dia cmd, disconnected line
wrutim	bool	114	dia cmd, wru timeout
sndout	bool	105	dia cmd, send output
acupwi	bool	120	dia cmd, no power to acu
acudlo	bool	121	dia cmd, data line occupied
acuacr	bool	122	dia cmd, dial out failed
acung	bool	123	dia cmd, request for acu is invalid
	rem
	rem	control types
	rem
srec	equ	c.srec	set receive mode
rrec	equ	c.rrec	reset receive
sxmit	equ	c.sxmt	set xmit mode
rxmit	equ	c.rxmt	reset xmit
sdtr	equ	c.sdtr	set data terminal ready
rdtr	equ	c.rdtr	reset dtr
ssup	equ	c.ssup	set supervisory xmit
rsup	equ	c.rsup	reset supervisory xmit
stat	equ	c.stat	store status
sbrk	equ	c.sbrk	send line break
smark	equ	c.smrk	send marker status
sterm	equ	c.strm	send terminate status
srts	equ	c.srqs	set request to send
rrts	equ	c.rrqs	reset request to send
scrq	equ	c.scrq	set call request
rcrq	equ	c.rcrq	reset call request
stroe	equ	c.stre	set tally runout enable (hdlc)
rtroe	equ	c.rtre	reset tally runout enable (hdlc)
	rem
	rem	status bits
	rem
cd	equ	s.cd	carrier detect
cts	equ	s.cts	clear to send
dsr	equ	s.dsr	data set ready
suprec	equ	s.sprc	supervisory receive
st	equ	s.st	status requested
break	equ	s.brk	line break received
brkchr	equ	s.brch	break char received
ring	equ	s.ring	ring
term	equ	s.term	terminate status
marker	equ	s.mark	marker status
exh	equ	s.exh	exhaust status
prexh	equ	s.prex	pre-exhaust status
parity	equ	s.prty	parity error
xte	equ	s.xte	transfer timing error
pwi	equ	s.pwi	power indicator on acu
dlo	equ	s.dlo	data line occupied (acu)
ads	equ	s.ads	dialed station has answered
	rem		data set is in data mode (acu)
acr	equ	s.acr	abandon call and retry (acu)
rcvto	equ	s.rto	rcv time out
bscrcv	equ	s.rbt	bsc terminate
bscmrk	equ	s.bmk	bsc marker
bscdmk	equ	s.bdmk	bsc delayed marker
fcserr	equ	s.fcse	frame check sequence error (hdlc)
idlesd	equ	s.isd	idle state detect (hdlc)
rcvtrm	equ	s.rbt	receive terminate (hdlc)
rcvabt	equ	s.rabt	receive abort (hdlc)
parbyt	equ	s.pbyt	partial byte (hdlc)
	eject
	rem
	rem	output types
	rem
adprtr	bool	401	insert printer addr string
adkybd	bool	402	insert keyboard addr string
outmsg	bool	403	insert output msg
repeat	bool	404	insert next char n times
	rem
	rem	various characters matched and sent
	rem
eoa	bool	64	eoa from/to 2741/1050
minus	bool	1	minus char from 1050
ibmnl	bool	55	cr nl from/to 2741/1050
ibmpad	bool	75	2741/1050 pad character(idle)
ibmeot	bool	74	2741/1050 eot char
eotshf	bool	174	eot w/case shift
ibmbs	bool	35	backspace from 2741
ibmtab	bool	57	tab from 2741
ibmsl	bool	42	2741 slash
ibm0	bool	24	2741 zero
ibm9	bool	44	2741 nine
ibmprf	bool	76	2741 prefix code
ibmpls	bool	3	2741 plus sign
ibmup	bool	34	2741 upshift
ibmdwn	bool	37	2741 downshift
nl	bool	12	ascii new-line
cr	bool	15	ascii carriage return
pad	bool	0	ascii pad char
dle	bool	20	ascii data link escape
eot	bool	4	ascii end of transmission
esc	bool	33	ascii escape char
ff	bool	14	ascii form feed char
tab	bool	11	ascii tab char
bs	bool	10	ascii backspace
space	bool	40	ascii space
awru	bool	5	ascii "who are you?"
null	bool	0	nothing
ack	bool	6	ascii ack
nak	bool	25	ascii nak
soh	bool	1	ascii start of header
syn	bool	26	ascii syn character
stx	bool	2	ascii start of text char
etx	bool	3	ascii end of text char
bel	bool	007	ascii bell character
h	bool	150	ascii h (esc mtr on)
l	bool	154	ascii l (used by vip for ff)
q	bool	161	ascii q (used by vip for quit)
atchar	bool	100	ascii at sign (used to mark reset-read)
nochar	bool	777	used in cmt to match no character
	rem
	rem	scan subop types
	rem
match	bool	501	match the char exactly
search	bool	502	search until match
ignore	bool	503	skip to next char, block check unchanged
sbcc	bool	504	start the bcc computation
endchn	bool	505	point to last character in chain
cbcc	bool	506	compare current with bcc char
cmask	bool	507	compare char with mask
rescan	bool	510	reset scan position to first char in chai
strlrc	bool	511	start lrc computation
outlrc	bool	512	insert lrc into chain
cmplrc	bool	513	compare lrc accumulation vs current char
seteom	bool	514	set last buffer in message flag ( for bld
replac	bool	515	replace current char
cmplst	bool	516	compare current vs list of chars for equa
movchr	bool	517	move current char to tib extension
movmsk	bool	520	movchr with masking of current char
count	bool	521	count number of chars scanned
serch2	bool	522	search for one of two chars
setbit	bool	523	turn on bits in current char
offbit	bool	524	turn off bits in current char
chktrm	bool	525	check the sync termination char
mvlst2	bool	526	move last two chars to tib ext
nxtchr	bool	527	update block check and skip to next char
	endm	tconst
	ttls	tibex - macro for define addresses in tib extension
	rem
tibex	macro	c,m
	pmc	save,off
	ine	tibx.0,1,%exbegn
tibx.1	set	0
tibx.2	set	0
tibx.0	set	1
tibxsz	set	0
exbegn	mark
	ine	'#2','word',%exword
	ine	'#2','char',%exchar
	seterr	#2	not word or char
	ine	1,1,%exdone
exchar	mark
#1	equ	304+2*tibx.1+tibx.2
	ine	tibx.2,1,%exch2
tibx.2	set	1
tibxsz	set	tibxsz+1
	ine	1,1,%exdone
exch2	mark
tibx.1	set	tibx.1+1
tibx.2	set	0
	ine	1,1,%exdone
exword	mark
	ine	tibx.2,0,%exwrd2
tibx.1	set	tibx.1+1
tibx.2	set	0
exwrd2	mark
	crsm	save,off
tibx.3	set	1
	ine	'#3','',1
tibx.3	set	#3
	crsm	restore
#1	equ	-tibx.1-1
tibx.1	set	tibx.1+tibx.3
tibxsz	set	tibxsz+tibx.3
exdone	mark
	pmc	restore
	endm	tibex
	ttls	macro to define bisync data
	rem
bscdat	macro	c,m
	ttls	bsc symbol definitions
************************************************************************
*
*	format of tib extentsion
*
************************************************************************
	rem
	tibex	ack0,char	/* ack0 value */
	tibex	ack1,char	/* ack1 value */
	tibex	tiback,char	/* current ack value */
	tibex	enq,char	/* enq value */
	tibex	tibnak,char	/* nak value */
	tibex	tibeot,char	/* eot value */
	tibex	rvi,char	/* rvi value */
	tibex	wack,char	/* wack value */
	tibex	etb,char	/* etb value */
	tibex	wrkch1,char	/* temporary work character (HASP) */
	tibex	wrkch2,char	/* temporary work character (HASP) */
	tibex	chartb,word	/* address of table define characters for mode */
	tibex	stattb,word	/* address of state transiion table */
	tibex	nakcnt,word	/* count of naks received during write */
	tibex	naklmt,word	/* limit of naks during write */
	tibex	enqcnt,word	/* count of bad responses or timeouts during write */
	rem
	tibex	result,word	/* final answer on message scans */
	rem		/* ... possible values are: */
resinc	equ	0	/*     ... message incomplete */
resnak	equ	1	/*     ... message should be nakked */
reseot	equ	2	/*     ... message was eot */
resenq	equ	3	/*     ... message was enq */
resack	equ	4	/*     ... good message */
resnul	equ	5	/*     ... no data at all */
resntr	equ	6	/*     ... non-transparent msg in trans mode */
	rem
	tibex	ctlop,word	/* start of 4 words for linctl */
	tibex	ctlvl1,word
	tibex	ctlvl2,word
	tibex	ctlvl3,word
	tibex	bidlmt,word	/* maximum times to bid for line */
	tibex	bidcnt,word	/* count of bid tries */
	tibex	cfgrmd,word	/* rmode bits for reconfig */
	tibex	cfgsmd,word	/* smode bits for reconfig */
	tibex	ttdtim,word	/* time interval between ttds */
	tibex	ttdlmt,word	/* maxinum number to send */
	tibex	ttdcnt,word	/* number sent so far */
	tibex	polad1,word	/* 3 words for polling address */
	tibex	polad2,word
	tibex	polad3,word
	tibex	testrt,word	/* address of extra test state handler */
	rem
	tibex	exflg1,word	/* a word of flags */
dialed	bool	000001	/* set when dialup has been signalled */
naksw	bool	000002	/* nak required */
nakksw	bool	000004	/* indicates receive nakked last message */
codasc	bool	000010	/* set if using ascii code */
codebc	bool	000020	/* set if using ebcdic code */
trnon	bool	000040	/* set if tranparency is on */
trnoff	bool	000100	/* set if transparency is off */
wacksw	bool	000200	/* indicates wack sent or received on last msg */
datrcv	bool	000400	/* indicates data was read during write */
alwbid	bool	001000	/* set if line bid should be accepted */
cfgpnd	bool	002000	/* reconfiguration is pending */
cfgok	bool	004000	/* its ok to reconfigure now */
rflag	bool	010000	/* to distinguish between 'write' and 'writer' */
ttdsw	bool	020000	/* ttd was just sent */
ntrsw	bool	040000	/* set while send non-trans block in trans mode */
rvisw	bool	100000	/* rvi has been used as ack this transmission */
needrv	bool	200000	/* ack this msg with rvi if possible */
ctlmsg	bool	400000	/* indicates first output buffer is ctl msg */
	rem
	tibex	exflg2,word	/* second word of flags */
lookot	bool	000001	/* set if read subr should watch for write data */
gotot	bool	000002	/* read terminated by write call */
timout	bool	000004	/* timeout waiting for input */
ib3270	bool	000010	/* ibm 3270 protocol to be used */
polpnd	bool	000020	/* poll pending on channel */
pollok	bool	000040	/* ok to poll now */
selop	bool	000100	/* select in progress */
	bool	000200
pollsw	bool	000400	/* last message sent was poll */
autopl	bool	001000	/* automatic poll mode enabled */
haspmd	bool	002000	/* hasp protocol to be used */
master	bool	004000	/* we are master (or primary) end */
outarv	bool	010000	/* output from CS arrived while busy (HASP) */
dialos	bool	020000	/* can't send input over DIA now (HASP) */
csreqa	bool	040000	/* tell CS when current msg is sent (HASP) */
lswabs	bool	100000	/* local system wait-a-bit (HASP) */
fswabs	bool	200000	/* foreign system wait-a-bit (HASP) */
fnrcba	bool	400000	/* block arrived but foreign not ready (HASP) */
	rem
	tibex	selad1,word
	tibex	selad2,word
	tibex	selad3,word
	rem
	rem	/* HASP re-definitions */
	rem
hxmttm	equ	ttdtim	/* hasp transmit time limit */
hcontm	equ	bidlmt	/* hasp connect time limit */
hrcvtm	equ	ttdcnt	/* hasp receive time limit */
wabmsk	equ	selad1	/* array of wait-a-bit masks */
hblkno	equ	selad2	/* BCB of block CS is interested in */
wrpcnt	equ	selad3	/* sync-blocks needed before xfer resumes */
	eject
	rem	/* ascii char values */
	rem
aack0	bool	60
aack1	bool	61
aenq	bool	5
anak	bool	25
aeot	bool	4
arvi	bool	74
awack	bool	73
aetb	bool	27
	rem
	rem	/* ebcdic char values */
	rem
eack0	bool	160
eack1	bool	141
eenq	bool	55
enak	bool	75
eeot	bool	67
ervi	bool	174
ewack	bool	153
eetb	bool	46
	rem
	rem	/* common char values */
	rem
itb	bool	37
	rem
	rem
	rem	/* line status op-codes */
	rem
lstbdf	equ	1	/* bid failed */
lstbbk	equ	2	/* attempt to write bad block */
lstrvi	equ	3	/* rvi recieved */
lstnak	equ	4	/* excessive naks */
lstrwr	equ	5	/* reporting result of write status */
lstwrc	equ	6	/* write completed */
lstwkm	equ	7	/* ibm3270 wacked message */
lsteot	equ	8	/* got eot in response to output */
lstabo	equ	9	/* sent eot because too many timeouts or enq's */
lstslf	equ	10	/* select failed */
lstwck	equ	11	/* wack in response to select */
lstnko	equ	12	/* too many naks on output */
lsthin	equ	13	/* hasp initialization complete */
lsthfr	equ	14	/* foreign system wait-a-bit reset (HASP) */
	rem
	rem	/* line control op-codes */
	rem
lctbid	equ	1	/* set bid retry limit */
lctabd	equ	2	/* allow line bids now */
lctcfg	equ	3	/* reconfigure */
lctttd	equ	4	/* set ttd parameters */
lcttwr	equ	5	/* test write status */
lct327	equ	6	/* set ibm3270 mode */
lctpla	equ	7	/* set polling address */
lctpol	equ	8	/* start a polling operation */
lctsla	equ	9	/* set selection address */
lctsta	equ	10	/* stop auto polling */
lctmst	equ	11	/* set master or slave mode */
lcthsp	equ	12	/* set hasp mode */
lctnak	equ	13	/* set nak limit */
lcthtm	equ	14	/* set hasp time limits */
	rem
	endm	bscdat
	ttls	control tables op block definitions
	rem
*++opstart -- db_fnp_opblocks_.cds looks for this statement when compiled
	rem
* * * * * * * * * * * * * * * * * * * * *
*
*	goto macro
*
* * * * * * * * * * * * * * * * * * * * *
	rem
goto	macro
	oct	777001
	zero	#1
	endm	goto
	rem
* * * * * * * * * * * * * * * * * * * * *
*
*	iftype macro
*
* * * * * * * * * * * * * * * * * * * * *
	rem
iftype	macro
	oct	777002
	zero	#1
	zero	#2
	endm	iftype
	rem
* * * * * * * * * * * * * * * * * * * * *
*
*	punt macro
*
* * * * * * * * * * * * * * * * * * * * *
	rem
punt	macro
	oct	777000
	zero	#1
	endm	punt
	eject
* * * * * * * * * * * * * * * * * * * * *
*
*	wait macro
*
* * * * * * * * * * * * * * * * * * * * *
	rem
wait	macro
	oct	777003
	zero	#1
	zero	#2
	zero	#3
	endm	wait
	rem
* * * * * * * * * * * * * * * * * * * * *
*
*	status macro
*
* * * * * * * * * * * * * * * * * * * * *
	rem
status	macro
	oct	777004
	zero	#3
	vfd	o18/#1
	vfd	o18/#2
	endm	status
	eject
* * * * * * * * * * * * * * * * * * * * *
*
*	dcwlst macro
*
* * * * * * * * * * * * * * * * * * * * *
	rem
dcwlst	macro
	oct	777005
	endm	dcwlst
	rem
	rem	SUB-OPS TO DCWLST OP BLOCK
	rem	leftmost 3 bits of 18 bit word
	rem	distinguish the sub-ops.
	rem
* * * * * * * * * * * * * * * * * * * * *
*
*	cmd macro		SUB-OP 1
*			up to 15 control bits
*
*			SUB-OP 5
*			if 2nd arg, allows for
*			up to 15 more control bits
*
* * * * * * * * * * * * * * * * * * * * *
	rem
cmd	macro
	vfd	o3/1,o15/#1
	crsm	off
	ine	'#2', '', 1
	vfd	o3/5,o15/#2
	crsm	on
	endm	cmd
	eject
* * * * * * * * * * * * * * * * * * * * *
*
*	input macro	SUB-OP 2
*
* * * * * * * * * * * * * * * * * * * * *
	rem
input	macro
	vfd	o3/2,6/#1,o9/#2
	endm	input
	rem
* * * * * * * * * * * * * * * * * * * * *
*
*	output macro	SUB-OP 3
*
* * * * * * * * * * * * * * * * * * * * *
	rem
output	macro
	pmc	save,off
k	set	1
x	set	192
	idrp	#1
	ife	k,0,3
k	set	1
x	set	#1
	ife	1,2,4
k	set	0
	pmc	restore
	vfd	o9/x,o9/#1
	pmc	save,off
	idrp
	pmc	restore
	ife	k,1,1
	vfd	o9/X,o9/477
	ife	k,0,1
	vfd	o18/477000
	endm	output
	rem
* * * * * * * * * * * * * * * * * * * * *
*
*	rdtly macro	SUB-OP 4
*
* * * * * * * * * * * * * * * * * * * * *
	rem
rdtly	macro
	vfd	o3/4,6/#1,9/0
	endm	rdtly
	eject
* * * * * * * * * * * * * * * * * * * * *
*
*	setime macro
*
* * * * * * * * * * * * * * * * * * * * *
	rem
setime	macro
	oct	777006
	vfd	18/#1
	endm	setime
	rem
* * * * * * * * * * * * * * * * * * * * *
*
*	gotype macro
*
* * * * * * * * * * * * * * * * * * * * *
	rem
gotype	macro
	oct	777007
	idrp	#1
	zero	#1
	idrp
	oct	777000
	endm	gotype
	rem
* * * * * * * * * * * * * * * * * * * * *
*
*	setflg macro
*
* * * * * * * * * * * * * * * * * * * * *
	rem
setflg	macro
	oct	777010
	pmc	save,off
	crsm	save,off
	ine	'#2','',%setok
	seterr	old_style_setflg_macro
	org	*-1
setok	mark
	crsm	restore
tfwrd1	set	0
tfwrd2	set	0
	idrp	#1
	tsttib	#1
	idrp
	pmc	restore
	vfd	18/tfwrd1
	vfd	18/tfwrd2
	endm	setflg
	rem
* * * * * * * * * * * * * * * * * * * * *
*
*	clrflg macro
*
* * * * * * * * * * * * * * * * * * * * *
	rem
clrflg	macro
	oct	777011
	pmc	save,off
	crsm	save,off
	ine	'#2','',%clrok
	seterr	old_style_clrflg_macro
	org	*-1
clrok	mark
	crsm	restore
tfwrd1	set	0
tfwrd2	set	0
	idrp	#1
	tsttib	#1
	idrp
	pmc	restore
	vfd	18/tfwrd1
	vfd	18/tfwrd2
	endm
	eject
* * * * * * * * * * * * * * * * * * * * *
*
*	tstflg macro
*
* * * * * * * * * * * * * * * * * * * * *
	rem
tstflg	macro
	oct	777012
	zero	#2
	pmc	save,off
	crsm	save,off
	ine	'#3','',%tstok
	seterr	old_style_tstflg_macro
	org	*-1
tstok	mark
	crsm	restore
tfwrd1	set	0
tfwrd2	set	0
	idrp	#1
	tsttib	#1
	idrp
	pmc	restore
	vfd	18/tfwrd1
	vfd	18/tfwrd2
	endm	tstflg
	rem
* * * * * * * * * * * * * * * * * * * * *
*
*	contrl macro
*			generates a dcwlst op
*			and 1 cmd sub-op
*
* * * * * * * * * * * * * * * * * * * * *
	rem
contrl	macro
	dcwlst
	crsm	off
	cmd	#1,#2
	crsm	on
	endm	contrl
	rem
* * * * * * * * * * * * * * * * * * * * *
*
*	dmpout macro
*
* * * * * * * * * * * * * * * * * * * * *
	rem
dmpout	macro
	oct	777013
	endm	dmpout
	rem
* * * * * * * * * * * * * * * * * * * * *
*
*	signal macro
*
* * * * * * * * * * * * * * * * * * * * *
	rem
signal	macro
	oct	777014
	vfd	o18/#1
	endm	signal
	eject
* * * * * * * * * * * * * * * * * * * * *
*
*	meter macro
*
* * * * * * * * * * * * * * * * * * * * *
	rem
meter	macro
	oct	777015
	dec	#1
	endm	meter
	rem
* * * * * * * * * * * * * * * * * * * * *
*
*	waitm macro
*
* * * * * * * * * * * * * * * * * * * * *
	rem
waitm	macro
	oct	777016
	endm	waitm
	rem
* * * * * * * * * * * * * * * * * * * * *
*
*	sendin macro
*
* * * * * * * * * * * * * * * * * * * * *
	rem
sendin	macro
	oct	777017
	endm	sendin
	rem
* * * * * * * * * * * * * * * * * * * * *
*
*	tstwrt macro
*
* * * * * * * * * * * * * * * * * * * * *
	rem
tstwrt	macro
	oct	777020
	zero	#1
	endm	tstwrt
	eject
* * * * * * * * * * * * * * * * * * * * *
*
*	tstglb  macro
*
* * * * * * * * * * * * * * * * * * * * *
	rem
tstglb	macro
	oct	777021
	vfd	o18/#1
	zero	#2
	endm	tstglb
	rem
* * * * * * * * * * * * * * * * * * * * *
*
*	stpchn macro
*
* * * * * * * * * * * * * * * * * * * * *
	rem
stpchn	macro
	ine	stpchx,1,%stpbeg
stpchx	set	1
	symref	stpchn
stpbeg	mark
	calsub	stpchn
	endm	macro
	rem
* * * * * * * * * * * * * * * * * * * * *
*
*	setype macro
*
* * * * * * * * * * * * * * * * * * * * *
	rem
setype	macro
	oct	777022
	zero	#1
	endm	setype
	eject
* * * * * * * * * * * * * * * * * * * * *
*
*	scntr macro
*
* * * * * * * * * * * * * * * * * * * * *
	rem
scntr	macro
	oct	777023
	zero	#1
	endm	scntr
	rem
* * * * * * * * * * * * * * * * * * * * *
*
*	acntr macro
*
* * * * * * * * * * * * * * * * * * * * *
	rem
acntr	macro
	oct	777024
	zero	#1
	endm	acntr
	rem
* * * * * * * * * * * * * * * * * * * * *
*
*	tcntr macro
*
* * * * * * * * * * * * * * * * * * * * *
	rem
tcntr	macro
	oct	777025
	zero	#1
	zero	#2
	endm	tcntr
	eject
* * * * * * * * * * * * * * * * * * * *
*
*	getext macro
*
* * * * * * * * * * * * * * * * * * * *
	rem
getext	macro
	oct	777026
	ife	'#1','',1
	zero	tibxsz
	ine	'#1','',1
	zero	#1
	zero	#2
	endm	getext
	rem
* * * * * * * * * * * * * * * * * * * *
*
*	retext macro
*
* * * * * * * * * * * * * * * * * * * *
	rem
retext	macro
	oct	777027
	endm	retext
	rem
* * * * * * * * * * * * * * * * * * * *
*
*	inscan macro
*
* * * * * * * * * * * * * * * * * * * *
	rem
inscan	macro
	oct	777030
	zero	#1
	zero	#2
	endm	inscan
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	outscn macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
outscn	macro
	oct	777031
	zero	#1
	zero	#2
	endm	outscn
	eject
* * * * * * * * * * * * * * * * * * * * * * *
*
*	bldmsg macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
bldmsg	macro
	oct	777032
	zero	#1
	zero	#2
	endm	bldmsg
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	dumpin macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
dumpin	macro
	oct	777033
	endm	dumpin
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	setchr macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
setchr	macro
	oct	777034
	vfd	o9/#1,o9/#2
	endm	setchr
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	cmpchr macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
cmpchr	macro
	oct	777035
	vfd	o9/#1,o9/#2
	zero	#3
	endm	cmpchr
	eject
* * * * * * * * * * * * * * * * * * * * * * *
*
*	calsub macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
calsub	macro
	oct	777036
	zero	#1
	endm	calsub
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	retsub macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
retsub	macro
	oct	777037
	endm	retsub
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	holdot macro
*
* * * * * * * * * * * * * * * * * * * * * * * 
	rem
holdot	macro
	oct	777040
	endm	holdot
* * * * * * * * * * * * * * * * * * * * * * *
*
*	ifhsla macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
ifhsla	macro
	oct	777041
	zero	#1
	endm	ifhsla
	eject
* * * * * * * * * * * * * * * * * * * * * * *
*
*	config macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
config	macro
	oct	777042
	endm	config
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	smode	macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
smode	macro
	vfd	o3/1,o15/#1
	endm	smode
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	rmode	macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
rmode	macro
	vfd	o3/2,o15/#1
	endm	rmode
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	baud macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
baud	macro
	vfd	o3/3,15/#1
	endm	baud
	eject
* * * * * * * * * * * * * * * * * * * * * * *
*
*	ckinpt macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
ckinpt	macro
	oct	777043
	zero	#1
	endm	ckinpt
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	gtinpt macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
gtinpt	macro
	oct	777044
	endm	gtinpt
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	replay macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
replay	macro
	oct	777045
	endm	replay
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	dmprpy macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
dmprpy	macro
	oct	777046
	endm	dmprpy
	eject
* * * * * * * * * * * * * * * * * * * * * * *
*
*	prepnl macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
prepnl	macro
	oct	777047
	endm	prepnl
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	tstrpy macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
tstrpy	macro
	oct	777050
	zero	#1
	rem
	endm	tstrpy
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	echo macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
echo	macro
	oct	777051
	zero	#1
	endm	echo
* * * * * * * * * * * * * * * * * * * * * * *
*
*	setcct macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
setcct	macro
	oct	777052
	zero	#1
	endm	setcct
	eject
* * * * * * * * * * * * * * * * * * * * * * *
*
*	dmpmsg macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
dmpmsg	macro
	oct	777053
	endm	dmpmsg
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	setlcl macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
setlcl	macro
	oct	777054
	vfd	18/#1
	vfd	18/#2
	endm	setlcl
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	addlcl macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
addlcl	macro
	oct	777055
	vfd	18/#1
	vfd	18/#2
	endm	addlcl
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	tstlcl macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
tstlcl	macro
	oct	777056
	vfd	18/#1
	vfd	18/#2
	zero	#3
	endm	tstlcl
	eject
* * * * * * * * * * * * * * * * * * * * * * *
*
*	setlcf macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
setlcf	macro
	oct	777057
	vfd	18/#1
	vfd	o18/#2
	endm	setlcf
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	clrlcf macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
clrlcf	macro
	oct	777060
	vfd	18/#1
	vfd	o18/#2
	endm	clrlcf
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	tstlcf macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
tstlcf	macro
	oct	777061
	vfd	18/#1
	vfd	o18/#2
	vfd	18/#3
	endm	tstlcf
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	setlcv macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
setlcv	macro
	oct	777062
	vfd	18/#1
	vfd	18/#2
	endm	setlcf
	eject
* * * * * * * * * * * * * * * * * * * * * * *
*
*	calasm macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
calasm	macro
	oct	777063
	vfd	18/#1
	crsm	save,off
	pmc	save,off
	ine	'#2','',%cala.y
	crsm	on
	pmc	restore
#3	equ	*
	org	*+1
	pmc	save,off
cala.x	set	0
	idrp	#2
	pmc	restore
	vfd	18/#2
	pmc	save,off
cala.x	set	cala.x+1
	idrp
	pmc	restore
#4	equ	*
	org	#3
	vfd	18/cala.x
	org	#4
	pmc	save,off
	ine	1,1,%cala.z
cala.y	mark
	pmc	restore
	oct	0
	pmc	save,off
cala.z	mark
	pmc	restore
	crsm	restore
	endm	calasm
	eject
* * * * * * * * * * * * * * * * * * * * * * *
*
*	bkptop macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
bkptop	macro	c,m
	oct	777064
	endm	bkptop
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	linctl macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
linctl	macro	c,m
	oct	777065
	vfd	18/#1
	vfd	18/#2
	endm	linctl
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	linsta macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
linsta	macro	c,m
	oct	777066
	vfd	18/#1
	endm	linsta
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	tstlcv macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
tstlcv	macro	c,m
	oct	777067
	vfd	18/#1
	vfd	18/#2
	vfd	18/#3
	endm	tstlcv
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	nullop macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
nullop	macro	c,m
	oct	777070
	endm	nullop
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	unwind macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
unwind	macro	c,m
	oct	777071
	endm	unwind
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	setimv macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
setimv	macro	c,m
	oct	777072
	vfd	o18/#1
	endm	setimv
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	gotov macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
gotov	macro	c,m
	oct	777074
	vfd	o18/#1
	endm	gotov
	rem
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	gocase macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
gocase	macro	c,m
	oct	777075
	vfd	o9/,o9/#1	value of tib ext
	vfd	18/#2
	vfd	18/#3
	endm	gocase
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	setfld macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
setfld	macro	c,m
	oct	777076
	ind	#1,1
	vfd	18/#2
	endm	setfld
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	addfld macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
addfld	macro	c,m
	oct	777077
	ind	#1,1
	vfd	18/#2
	endm	addfld
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	tstfld macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
tstfld	macro	c,m
	oct	777100
	ind	#1,1
	vfd	18/#2
	vfd	18/#3
	endm	tstfld
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	meter1 macro (single-word increment)
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
meter1	macro	c,m
	oct	777101
	zero	#1
	zero	#2
	endm	meter1
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	meter2 macro (double-word increment)
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
meter2	macro	c,m
	oct	777102
	zero	#1
	zero	#2
	endm	meter2
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	meteru macro (update meter)
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
meteru	macro	c,m
	oct	777103
	zero	#1
	zero	#2
	endm	meteru
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	meterm macro (message meter)
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
meterm	macro	c,m
	oct	777104
	zero	#1	0=input, 1=output
	endm	meterm
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	bldims macro (build input message)
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
bldims	macro
	oct	777105
	zero	#1
	zero	#2
	endm	bldims
	eject
* * * * * * * * * * * * * * * * * * * * *
*
*	chstr macro
*
* * * * * * * * * * * * * * * * * * * * *
	rem
chstr	macro
	pmc	save,off
chk	set	0
	idrp	#1
	ife	chk,0,3
chk	set	1
chval	set	#1
	ife	1,2,2
chk	set	0
	vfd	o9/chval,o9/#1
	idrp
	ife	chk,1,1
	vfd	o9/chval,o9/777
	ife	chk,0,1
	vfd	o9/777,o9/777
	pmc	restore
	endm	chstr
	rem
	rem
* * * * * * * * * * * * * * * * * * * * * * *
*
*	adrlst macro
*
* * * * * * * * * * * * * * * * * * * * * * *
	rem
adrlst	macro	c,m
	pmc	save,off
	idrp	#1
	vfd	18/#1
	idrp
	oct	777000
	pmc	restore
	endm	adrlst
	rem
	punm
	end		1
