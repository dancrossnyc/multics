" ***********************************************************
" *                                                         *
" * Copyright, (C) Honeywell Bull Inc., 1987                *
" *                                                         *
" * Copyright, (C) Honeywell Information Systems Inc., 1982 *
" *                                                         *
" * Copyright (c) 1972 by Massachusetts Institute of        *
" * Technology and Honeywell Information Systems, Inc.      *
" *                                                         *
" ***********************************************************

" HISTORY COMMENTS:
"  1) change(1986-05-15,DGHowe), approve(1986-05-15,MCR7375),
"     audit(1986-07-15,Schroth), install(1986-08-01,MR12.0-1108):
"     add the entry points get_command_name and get_command_name_rel. Added
"     the constants fb21_mask and null.
"  2) change(1986-12-10,DGHowe), approve(1986-12-10,PBF7375),
"     audit(1986-12-10,McInnis), install(1986-12-17,MR12.0-1250):
"     Bug fix to get_command_name_common. Redefine has_command_name_mask to be
"     a full word 400000000000. Take the du modifier off of the anx0 for the
"     has_command_name_mask.
"  3) change(2017-01-06,GDixon), approve(2017-01-08,MCR10025),
"     audit(2017-01-08,Swenson), install(2017-01-08,MR12.6f-0008):
"     Repair cu_$arg_ptr(_rel) test of arg_list.desc_count, to account for new
"     arg_list.has_command_name flag.
"                                                      END HISTORY COMMENTS


" Command system utility subroutines

" Initially coded in December 1969 by R. C. Daley
" Modified by R Feiertag in 1970 to add entries arg_ptr_rel, grow_stack_frame,
"	shrink_stack_frame, get_cp, and get_cl
" Modified by V. Voydock in October 1970 as part of reworking of process environment
" Modified by C. Tavares in May 1971 to add entry caller_ptr
" Modified by V. Voydock in June 1971 to add entries "ready_proc",
"	 "get_ready_proc", and "set_ready_proc"
" Modified by V. Voydock in May 1972 to add entries get_ready_mode and set_ready_mode,
"	and to make cu_$grow_stack_frame round up to mod 16 boundaries
" Split into two pieces in May 1972 by V. Voydock as part of fast command loop 
" Modified 21 June 1972 by P. Green to fix arg_ptr not to assume descriptors are present,
"	and to handle Version 2 descriptors properly.
" Modified for follow-on by R. Snyder July 20, 1972
" Modified 11/19/76 by M. Weaver  to add entries generate_call, (get set)_command_processor,
"	and (get set)_ready_procedure
" Modified May 1977 by Larry Johnson for arg_count_rel entry.
" Modified Aug 12, 1977 by S. Webber to remerge with rest_of_cu_
" Modified: August 1980 by G. Palter to add reset_(command_processor ready_procedure
"	    cl_intermediary), make cu_$(generate_call cl cp ready_proc) work with internal
"	    procedures, add an optional second argument to cu_$arg_count, and add
"	    cu_$evaluate_active_string and cu_$(get set reset)_evaluate_active_string.
" Modified September 1982 by C. Hornig to remove reference to pl1_operators.
" Modified: 16 September 1982 by G. Palter to make cu_$stack_frame_size work (phx13864)
" Modified: 16 January 1983 by G. Palter to make cu_$arg_ptr and friends reject invalid
"    argument numbers (phx14511)
" Modified: 1 March 1984 by G. Palter to not use LDAQ/STAQ for copying pointers (phx15722)
"    and to always initialize the pointer and length arguments of cu_$*arg_ptr* to null and
"    zero, respectively (phx16016)

" 

	name	cu_

"			TABLE OF CONTENTS

	entry	af_arg_count		" return # arguments if an AF
	entry	af_arg_count_rel		" ... for given arg list
	entry	af_arg_ptr		" get ptr/lth of an argument if an AF
	entry	af_arg_ptr_rel		" ... for given arg list
	entry	af_return_arg		" return # args and ptr/lth of AF return value
	entry	af_return_arg_rel		" ... for given arg list
	entry	arg_count			" get number of arguments
	entry	arg_count_rel		" ... for given arg list
	entry	arg_list_ptr		" get ptr to argument list
	entry	arg_ptr			" get ptr to argument(n)
	entry	arg_ptr_rel		" ... for given arg list
	entry	caller_ptr		" get codeptr to invoker's caller
	entry	cl			" entry to call to re-enter environment
	entry	cp			" entry to call current command processor
	entry	decode_entry_value		" extract ptrs from pl1 entry variable
	entry	evaluate_active_string	" call to evaluate an active string
	entry	gen_call			" call, given codeptr and arg list ptr
	entry	generate_call		" call, given entry variable and arg list ptr
	entry	get_cl			" get codeptr to current command level re-entry procedure
	entry	get_cl_intermediary		" get entry variable for current command level re-entry procedure
	entry	get_command_processor	" get entry variable for current command processor
	entry	get_command_name_rel	" get command name 
	entry	get_command_name		" get command name 
	entry	get_cp			" get codeptr to current command processor
	entry	get_evaluate_active_string	" get entry variable to evaluate an active string
	entry	get_ready_mode		" get value of internal ready flags
	entry	get_ready_proc		" get codeptr to procedure to be called after each command line
	entry	get_ready_procedure		" get entry variable to be called after each command line
	entry	grow_stack_frame		" allocate space in stack frame (mod 16)
	entry	level_get			" get current validation level
	entry	level_set			" set current validation level
	entry	make_entry_value		" create pl1 entry variable from codeptr and enironmentptr
	entry	ptr_call			" call, given codeptr in arg list
	entry	ready_proc		" entry to call after each command line is processed
	entry	reset_cl_intermediary	" reset to default command level re-entry procedure
	entry	reset_command_processor	" reset to default command processor
	entry	reset_evaluate_active_string	" reset to default entry to evaluate an active string
	entry	reset_ready_procedure	" reset to default ready message printer
	entry	set_cl			" set external entry for re-entry to command level
	entry	set_cl_intermediary		" set entry for re-entry to command level
	entry	set_command_processor	" set entry for current command processor
	entry	set_cp			" set external entry for current command processor
	entry	set_evaluate_active_string	" set entry to evaluate an active string
	entry	set_ready_mode		" set value of internal ready flags
	entry	set_ready_proc		" set external entry to be called after each command line
	entry	set_ready_procedure		" set entry to be called after each command line
	entry	shrink_stack_frame		" free up space in stack frame
	entry	stack_frame_ptr		" get ptr to stack frame
	entry	stack_frame_size		" get size of stack frame

" 
	include	stack_header

	include	stack_frame

" 

	tempd	temp_ptr,temp_ptr2		" temporaries for ptr_call


" Constants

	bool	var_desc,10120		" identifies PL1 version 1 varying character string
	bool	v2_var,130000		" identifies PL1 version 2 varying character string

fb21_mask:
	oct	000017777777		" mask off fixed bin 21

descriptor_mask:
	oct	000077777777		" mask off top 12 bits

desc_mask:				" mask for PL1 version 1 descriptor (ignore sets/uses)
	vfd	15/0,21/-1

has_command_name_mask:
	oct	400000000000

v2_mask:	vfd	1/1,6/0,29/-1		" Mask for PL1 version 2 (modern style)

	even
null:	its	-1,1			" null pointer
ptrmask:	oct	077777000077,777777077077	" mask for pointer comparisons


" Variables

	use	int_stat		internal static storage
	join	/static/int_stat

cl_arg:	oct	400000000000

ready_mode:
	oct	400000000000

	even
cl_entry:	its	-1,1			" entry to re-enter command level
	its	-1,1

cl_arglist:
	vfd	18/2,18/4
	vfd	18/0,18/0
	its	-1,1

cp_entry:	its	-1,1			" entry for current command processor
	its	-1,1

ready_entry:				" entry for current ready procedure
	its	-1,1
	its	-1,1

ready_arglist:
	vfd	18/2,18/4		arglist for call to ready procedure
	dec	0
	its	-1,1

eas_entry:				" entry for current active string evalauator
	its	-1,1
	its	-1,1

	use	main
" 

" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"    cl ..... entry to re-enter command level upon receipt of error conditions
"
"	call cu_$cl (cl_modes);
"
"	dcl 1 cl_modes aligned, /* optional argument */
"	    2 resetread bit (1) unaligned, /* ON => do a resetread on user_i/o */
"	    2 pad bit (34) unaligned;
"
"	If cl_modes isn't supplied, a canned structure is passed to request a resetread
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

cl:	lda	ap|0			" pick up arg list header
	cana	=o777777,du		" any arguments passed?
	tnz	cl_with_args		" ... yes -- use supplied arglist
	eppap	pr5|cl_arglist		" ... no -- use canned arglist
	epp2	pr5|cl_arg		" ...	  which requests resetread
	spri2	pr5|cl_arglist+2

cl_with_args:
	epp1	pr5|cl_entry		" will be calling this entry variable
	ldaq	pr1|0			" is it a user specified value?
	eraq	null
	anaq	ptrmask
	tnz	generate_call_common	" ... yes -- go off and perform the call

	callsp	get_to_cl_$unclaimed_signal	" ... no -- use default (external) proc
	short_return

" 

" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"	get_cl_intermediary .... entry to retrieve entry var to re-enter command level
"
"	call cu_$get_cl_intermediary(cl_entry);
"
"	1. cl_entry (entry) - entry variable to procedure to re-enter command level
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " "" " " " " " " " " " " " "

get_cl_intermediary:
	epp2	ap|2,*			" get ptr to entry variable argument
	ldaq	pr5|cl_entry		" is it the default procedure?
	eraq	null
	anaq	ptrmask
	tnz	get_cl_intermediary_non_default    " ... no -- return the static one

	epp3	get_to_cl_$unclaimed_signal	" ... yes  -- return default value
	spri3	pr2|0
	ldaq	null			"	    (it's external)
	staq	pr2|2
	short_return

get_cl_intermediary_non_default:
	epp3	pr5|cl_entry,*		" copy from our internal static
	spri3	pr2|0
	epp3	pr5|cl_entry+2,*
	spri3	pr2|2
	short_return



" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"	get_cl .... entry to retrieve procedure ptr to re-enter command level
"
"	call cu_$get_cl(cl_ptr);
"
"	1. cl_ptr (ptr) - pointer to procedure to re-enter command level
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " "" " " " " " " " " " " " "

get_cl:	epp2	pr5|cl_entry,*		" pick up current command level proc ptr
	spri2	ap|2,*
	short_return

" 

" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"    set_cl_intermediary ..... entry to specify procedure to call to re-enter command level
"
"	call cu_$set_cl_intermediary(cl_entry)
"
"	1. cl_entry (entry) - entry to procedure to re-enter command level
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

set_cl_intermediary:
	epp2	ap|2,*			" get pointer to caller's entry var
	epp3	pr2|0,*			" copy entry variable to our static
	spri3	pr5|cl_entry
	epp3	pr2|2,*
	spri3	pr5|cl_entry+2
	short_return



" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"    set_cl ..... entry to specify external proc to call to re-enter command level
"
"	call cu_$set_cl(cl_ptr)
"
"	1. cl_ptr (ptr) - pointer to external proc to re-enter command level;
"		        if null, the default procedure is used
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

set_cl:	epp2	ap|2,*			" get ptr to the codeptr
	epp2	pr2|0,*			" copy codeptr to our static
	spri2	pr5|cl_entry
	ldaq	null			" indicate external procedure
	staq	pr5|cl_entry+2
	short_return



" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"    reset_cl_intermediary .... entry to reset to default re-enter command level proc
"
"	call cu_$reset_cl_intermediary ()
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

reset_cl_intermediary:
	ldaq	null			" set to null -- cu_$cl will special case
	staq	pr5|cl_entry
	staq	pr5|cl_entry+2
	short_return

" 

" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"    cp ..... entry to-call currently specified command processor
"
"	call cu_$cp (line_ptr, line_lth, code)
"
"	1. line_ptr (ptr) - pointer to command line to execute
"	2. line_lth (fixed bin(21)) - length of command line
"	3. code (fixed bin(35)) - standard status code (Output)
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

cp:	epp1	pr5|cp_entry		" will be calling this entry variable
	ldaq	pr1|0			" is it user supplied procedure?
	eraq	null
	anaq	ptrmask
	tnz	generate_call_common	" ... yes -- go off and perform the call

	callsp	command_processor_$command_processor_	" ... no -- use default proc
	short_return

" 

" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"	get_command_processor .... entry to retrieve entry var of current command processor
"
"	call cu_$get_command_processor (cp_entry);
"
"	1. cp_entry (entry) - entry variable of current command processor
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " "" " " " " " " " " " " " "

get_command_processor:
	epp2	ap|2,*			" get pointer to user's entry variable
	ldaq	pr5|cp_entry		" is default procedure in use?
	eraq	null
	anaq	ptrmask
	tnz	get_cp_non_default		" ... no

	epp3	command_processor_$command_processor_	" ... yes -- return it
	spri3	pr2|0
	ldaq	null
	staq	pr2|2			"    (it's external)
	short_return

get_cp_non_default:
	epp3	pr5|cp_entry,*		" copy from our internal static
	spri3	pr2|0
	epp3	pr5|cp_entry+2,*
	spri3	pr2|2
	short_return



" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"	get_cp .... entry to retrieve procedure ptr to current command processor
"
"	call cu_$get_cp (cp_ptr);
"
"	1. cp_ptr (ptr) - pointer to current command processor
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " "" " " " " " " " " " " " "

get_cp:	epp2	pr5|cp_entry,*		" pick up current command processor
	spri2	ap|2,*
	short_return

" 

" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"    set_command_processor ..... entry to specify procedure to call as the command processor
"
"	call cu_$set_command_processor (cp_entry)
"
"	1. cp_entry (entry) - entry to become the command processor
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

set_command_processor:
	epp2	ap|2,*			" get pointer to caller's entry var
	epp3	pr2|0,*			" copy entry variable to our static
	spri3	pr5|cp_entry
	epp3	pr2|2,*
	spri3	pr5|cp_entry+2
	short_return



" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"    set_cp ..... entry to specify external proc to be command processor
"
"	call cu_$set_cp (cp_ptr)
"
"	1. cp_ptr (ptr) - pointer to external proc to be the command processor;
"		        if null, the default procedure is used
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

set_cp:	epp2	ap|2,*			" get ptr to the codeptr
	epp2	pr2|0,*			" copy codeptr to our static
	spri2	pr5|cp_entry
	ldaq	null			" indicate external procedure
	staq	pr5|cp_entry+2
	short_return



" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"    reset_command_processor .... entry to reset to default command processor
"
"	call cu_$reset_command_processor ()
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

reset_command_processor:
	ldaq	null			" reset to null -- cu_$cp will then
	staq	pr5|cp_entry		" ... transfer to the default
	staq	pr5|cp_entry+2
	short_return

" 

" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"     ready_proc ..... entry to be called after each command line is processed --
"		   (default procedure prints a ready message if on)
"
"	call cu_$ready_proc (ready_modes);
"
"	dcl 1 ready_modes aligned, /* optional argument */
"	    2 ready_sw bit(1) unaligned, /* ON => print a ready message */
"	    2 pad bit(35) unaligned;
"
"	If ready_modes isn't supplied, an internal static structure is passed whose
"	contents may be changed via cu_$set_ready_mode and read via cu_$get_ready_mode;
"	the default value for ready_modes.ready_sw in the static structure is "1"b.
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

ready_proc:
	lda	ap|0			" pick up arg list header
	cana	=o777777,du		" any arguments passed?
	tnz	ready_with_args		" ... yes -- use supplied arglist
	eppap	pr5|ready_arglist		" ... no -- use current setting
	epp2	pr5|ready_mode		" ...	  controlled by ready_on/off
	spri2	pr5|ready_arglist+2

ready_with_args:
	epp1	pr5|ready_entry		" will be calling this entry variable
	ldaq	pr1|0			" user supplied procedure?
	eraq	null
	anaq	ptrmask
	tnz	generate_call_common	" ... yes -- go off and perform the call

	callsp	print_ready_message_$print_ready_message_    " ... no -- use default
	short_return

" 

" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"	get_ready_procedure .... entry to retrieve entry var of current ready procedure
"			     (procedure called after each command line normally to
"			      print a ready message)
"
"	call cu_$get_ready_procedure (ready_entry);
"
"	1. ready_entry (entry) - entry variable of current ready procedure
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " "" " " " " " " " " " " " "

get_ready_procedure:
	epp2	ap|2,*			" get ptr to entry variable argument
	ldaq	pr5|ready_entry		" using default procedure?
	eraq	null
	anaq	ptrmask
	tnz	get_ready_procedure_non_default    " ... no

	epp3	print_ready_message_$print_ready_message_    " ... yes -- return it
	spri3	pr2|0
	ldaq	null			"    (it's external)
	staq	pr2|2
	short_return

get_ready_procedure_non_default:
	epp3	pr5|ready_entry,*		" copy from our internal static
	spri3	bp|0
	epp3	pr5|ready_entry+2,*
	spri3	bp|2
	short_return



" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"	get_ready_proc .... entry to retrieve procedure ptr to current ready procedure
"
"	call cu_$get_ready_proc (ready_ptr);
"
"	1. ready_ptr (ptr) - pointer to current ready procedure
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " "" " " " " " " " " " " " "

get_ready_proc:
	epp2	pr5|ready_entry,*		" pick up current command processor
	spri2	ap|2,*
	short_return

" 

" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"    set_ready_procedure ..... entry to specify procedure to call as the command processor
"
"	call cu_$set_ready_procedure (ready_entry)
"
"	1. ready_entry (entry) - entry to become the command processor
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

set_ready_procedure:
	epp2	ap|2,*			" get pointer to caller's entry var
	epp3	pr2|0,*			" copy entry variable to our static
	spri3	pr5|ready_entry
	epp3	pr2|2,*
	spri3	pr5|ready_entry+2
	short_return



" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"    set_ready_proc ..... entry to specify external proc to be ready procedure
"
"	call cu_$set_ready_proc (ready_ptr)
"
"	1. ready_ptr (ptr) - pointer to external proc to be the ready procedure;
"		         if null, the default procedure is used
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

set_ready_proc:
	epp2	ap|2,*			" get ptr to the codeptr
	epp2	pr2|0,*			" copy codeptr to our static
	spri2	pr5|ready_entry
	ldaq	null			" indicate external procedure
	staq	pr5|ready_entry+2
	short_return



" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"    reset_ready_procedure .... entry to reset to default ready procedure
"
"	call cu_$reset_ready_procedure ()
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

reset_ready_procedure:
	ldaq	null			" reset to null -- cu_$ready_proc will
	staq	pr5|ready_entry		" transfer to the default
	staq	pr5|ready_entry+2
	short_return

" 

" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"	set_ready_mode ..... entry to set the internal ready flags for controlling ready
"			 message printing
"
"	call cu_$set_ready_mode (ready_flags);
"
"	1. ready_flags (see description of cu_$ready_proc) (INPUT)
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

set_ready_mode:
	lda	ap|2,*			" copy flags to out static
	sta	pr5|ready_mode
	short_return



" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"	get_ready_mode ..... entry to return the value of the ready flags
"
"	call cu_$get_ready_mode (ready_flags);
"
"	1. ready_flags (see description of cu_$ready_proc)  (OUTPUT)
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

get_ready_mode:
	lda	pr5|ready_mode		" copy ready flags to caller
	sta	ap|2,*
	short_return

" 

" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"    evaluate_active_string ..... entry to-call current active-string evaluator
"
"	call cu_$evaluate_active_string (info_ptr, active_string, string_type,
"				   return_value, code);
"
"	1. info_ptr (ptr) - reserved for future expansion and must be null
"	2. active_string (char (*)) - string to evaluate without outermost brackets
"	3. string_type (fixed bin) - type of active string (see cp_active_string_types.incl.pl1)
"	4. return_value (char (*) var) - result of the evaluation (Output)
"	5. code (fixed bin(35)) - standard status code (Output)
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

evaluate_active_string:
	epp1	pr5|eas_entry		" will be calling this entry variable
	ldaq	pr1|0			" user supplied procedure?
	eraq	null
	anaq	ptrmask
	tnz	generate_call_common	" ... yes -- go off and perform the call

	callsp	command_processor_$eval_string     " ... no -- use default
	short_return

" 

" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"	get_evaluate_active_string .... entry to retrieve entry var of current active
"				  string evaluator
"
"	call cu_$get_evaluate_active_string (eas_entry);
"
"	1. eas_entry (entry) - entry variable of current active-string evaluator
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " "" " " " " " " " " " " " "

get_evaluate_active_string:
	epp2	ap|2,*			" get ptr to entry variable argument
	ldaq	pr5|eas_entry		" using defaulr procedure?
	eraq	null
	anaq	ptrmask
	tnz	get_eas_non_default		" ... no

	epp3	command_processor_$eval_string     " ... yes -- return it
	spri3	pr2|0
	ldaq	null			"    (it's external)
	staq	pr2|2
	short_return

get_eas_non_default:
	epp3	pr5|eas_entry,*		" copy from our internal static
	spri3	pr2|0
	epp3	pr5|eas_entry+2,*
	spri3	pr2|2
	short_return



" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"    set_evaluate_active_string ..... entry to specify procedure to call as the active
"			        string evaluator
"
"	call cu_$set_evaluate_active_string (eas_entry)
"
"	1. eas_entry (entry) - entry to become the active-string evaluator
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

set_evaluate_active_string:
	epp2	ap|2,*			" get pointer to caller's entry var
	epp3	pr2|0,*			" copy entry variable to our static
	spri3	pr5|eas_entry
	epp3	pr2|2,*
	spri3	pr5|eas_entry+2
	short_return

" 

" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"    reset_evaluate_active_string .... entry to reset to default active-string evaluator
"
"	call cu_$reset_evaluate_active_string ()
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

reset_evaluate_active_string:
	ldaq	null			" reset to null --
	staq	pr5|eas_entry		" ... cu_$evaluate_active_string will
	staq	pr5|eas_entry+2		" ... transfer to default
	short_return

" 

" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"     generate_call ... entry to call an entry variable with the supplied argument list
"
"	call cu_$generate_call (entry_variable, arg_list_ptr);
"
"	1. entry_variable (entry) -- the entry to be called.  It may be an internal
"			         procedure;" this entry will take care of the display
"			         ptr in the argument list.
"	2. arg_list_ptr (ptr) -- pointer to the argument list to be given to the entry
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

generate_call:
	epp1	ap|2,*			" get ptr to entry variable
	eppap	ap|4,*			" get ptr to argument list for call
	eppap	ap|0,*			" ... and point to actual arglist


" Control reaches here from the cu_$cl, etc. entries to invoke their specific entry variable

generate_call_common:
	lxl0	ap|0			" pick up argument list code
	anx0	8+2,du			" check if display pointer present
	tnz	3,ic			" ... yes -- go get it
	ldaq	null			" ... no -- use null (external call)
	tra	3,ic			"	  and goto common code
	ldx2	ap|0			" ... 2*nargs
	ldaq	ap|2,2			" ... fetch display pointer

	eraq	pr1|2			" compare with entry's environmentptr
	anaq	ptrmask
	tnz	2,ic			" ... not equal -- must copy arglist

	callsp	pr1|0,*			" display ptrs agree -- make the call


" Entry variable's environmentptr is different from arglist's display ptr -- the arglist
"  must be copied and the proper display pointer inserted...

	eax1	0			" assume that entry is external
	ldaq	pr1|2			" check if entry is external or internal
	eraq	null
	anaq	ptrmask
	tze	2,ic			" ... external -- no display ptr in arglist
	eax1	2			" ... internal -- must insert display ptr

	eax7	stack_frame.min_length+17,1	" miniumum stack frame size + display
					" ... pointer (if used) + rounding
	adx7	ap|0			" ... plus argument pointers
	adx7	ap|1			" ... plus descriptor pointers

	anx7	=o777760,du		" ... round to mod 16
	tsp2	sb|stack_header.push_op_ptr,* " get a stack frame
	lda	stack_frame.support_bit,dl	" ... which is a support frame
	orsa	sp|stack_frame.flag_word

	epp2	sp|stack_frame.min_length	" arglist goes here

	ldaq	ap|0			" copy argument list header
	staq	pr2|0

	eax2	4			" assume no display pointer
	cmpx1	0,du			" putting in a display pointer?
	tze	2,ic			" ... no -- have correct code already
	eax2	8			" ... yes -- get proper code for header
	sxl2	pr2|0			" update code in arglist header

	ldx2	pr2|0			" 2*nargs
	tze	6,ic			" ... no arguments to copy
	epp3	ap|0,2*			" copy argument list pointers
	spri3	pr2|0,2
	eax2	-2,2			" ... done?
	tpnz	-3,ic			" ... ... no

	ldx2	pr2|0			" 2*nargs again
	eppap	ap|0,2			" ... ptr to last argptr in original list
	epp3	pr2|0,2			" ... ptr to last argptr in new list

	cmpx1	0,du			" copy entry's environment ptr?
	tze	4,ic			" ... no
	epp5	pr1|2,*			" ... yes
	spri5	pr3|2
	epp3	pr3|2			" ... indicate descriptors after display

	ldx2	pr2|1			" check if descriptors to copy
	tze	generate_call_call		" ... no

	cmpx0	0,du			" copy descriptors -- skip old display?
	tze	2,ic			" ... no
	eppap	ap|2			" ... yes

	ldx2	pr2|1			" 2*ndescs
	epp5	ap|0,2*			" copy descriptors
	spri5	pr3|0,2
	eax2	-2,2			" ... done?
	tpnz	-3,ic			" ... ... no

generate_call_call:
	call	pr1|0,*(pr2|0)		" make the call
	return				" ... and return

" 

" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"    gen_call ..... call specified external procedure with specified argument list
"
"	call cu_$gen_call(proc_ptr, arg_list_ptr)
"
"	1. proc_ptr (ptr) - pointer to external procedure to be called
"	2. arg_list_ptr (ptr) - pointer to argument list for procedure call
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

gen_call:	eppbp	ap|2,*		get pointer to procedure pointer
	eppap	ap|4,*		pick up argument list pointer
	eppap	ap|0,*		..
	callsp	bp|0,*		call procedure entry point

" 

" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"    ptr_call ..... call external procedure specified by first argument in call
"
"	call cu_$ptr_call (proc_ptr, arg1, ... , argN)
"
"	1. proc_ptr (ptr) - pointer to external procedure to be called
"	2. arg1 ... argN - optional - arguments to be supplied in the call
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

ptr_call:	eax7	stack_frame.min_length+19	" minimum stack frame plus 4 words
					" ... temporary storage plus rounding
	adx7	ap|0			" ... plus room for argument pointers
	adx7	ap|1			" ... plus room for descriptors

	anx7	=o777760,du		" ... round to mod 16
	tsp2	sb|stack_header.push_op_ptr,* " get a stack frame
	lda	stack_frame.support_bit,dl	" ... which is a support frame
	orsa	sp|stack_frame.flag_word

	epp2	sp|stack_frame.min_length	" start of temporaries

	epp3	ap|2,*			" save codeptr of procedure to call
	epp3	pr3|0,*
	spri3	pr2|0

	ldaq	ap|0			" copy arglist header
	staq	pr2|2

	ldx1	pr2|2			" decrement number of arguments
	eax1	-2,1
	stx1	pr2|2
	tze	5,ic			" no arguments in call ... skip copying

	epp3	ap|2,1*			" copy argument pointers
	spri3	pr2|2,1
	eax1	-2,1			" ... done?
	tpnz	-3,ic			" ... ... no

	ldx1	pr2|3			" get descriptors count
	tze	ptr_call_call		" none -- go make the call
	eax1	-2,1			" flush first descriptor
	stx1	pr2|3
	tze	ptr_call_call		" none left

	ldx2	ap|0			" move ap past argptrs and 1st
	eppap	ap|2,2			" ... descriptor
	ldx2	pr2|2			" move past argptrs in new arglist
	epp3	pr2|2,2

	epp5	ap|0,1*			" copy descriptors
	spri5	pr3|0,1
	eax1	-2,1			" ... done?
	tpnz	-3,ic			" ... ... no

ptr_call_call:
	call	pr2|0,*(pr2|2)		" make the call
	return				" ... and return

" 

" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"    arg_count ..... get number of arguments passed to caller of arg_count
"
"	call cu_$arg_count (nargs, code)
"
"	1. nargs (fixed bin(17)) - number of arguments (returned).
"	2. code (fixed bin(35)) - optional - set to one of zero, error_table_$nodescr, or
"			      error_table_$active_function.
"
"	If code is supplied, a check is made that the last argument is not char(*) varying
"	which is indicative of being invoked as an active function.  This check provides a
"	mechanism for command-only procedures to detect improper usage.
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

arg_count:
	eax0	4			" code (if present) is second argument
	epp1	sp|stack_frame.arg_ptr,*	" ptr to caller's stack frame
	tra	arg_count_common		" join main section of code



" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"    arg_count_rel ..... get number of arguments in specified argument list
"
"	call cu_$arg_count_rel (nargs, arg_list_ptr, code);
"
"	1. nargs (fixed bin(17)) - number of args in that list (output)
"	2. arg_list_ptr (ptr) - pointer to arg list in question (input)
"	3. code (fixed bin(35)) - optional - see cu_$arg_count above
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

arg_count_rel:
	eax0	6			" code (if present) is third argument
	epp1	ap|4,*			" get arglist pointer
	epp1	pr1|0,*


arg_count_common:
	lda	pr1|0			" return the argument count
	arl	18+1			" ... which was in au and was also doubled
	sta	ap|2,*

	cmpx0	ap|0			" did caller supply a code argument?
	tmoz	arg_count_hard		" ... yes
	short_return			" ... no -- all done, return to caller


" Status code is specified: check that last argument is not character(*) varying which would
"  indicate active function usage.

arg_count_hard:
	stz	ap|0,0*			" initialize return code

	ldx1	pr1|0			" any arguments?
	tnz	ach_continue		" ... yes
	short_return			" ... no -- OK for command to have no args

ach_continue:
	lda	pr1|0			" pick up argument list header
	cana	4+8,dl			" make sure its a PL1 call
	tze	ach_err_no_descs		" ... it isn't

	ldx1	pr1|0			" 2*nargs to x1
	cmpx1	pr1|1			" same number of descriptors present?
	tnz	ach_err_no_descs		" ... no -- can't determine if valid

	adx1	pr1|1			" take descriptors into account also

	lxl2	pr1|0			" check if display pointer is present
	anx2	8+2,du
	tze	2,ic			" ... no
	eax1	2,1			" ... yes -- skip past it also

	lda	pr1|0,1*			" fetch the descriptor
	tpl	ach_check_v1		" might be a version 1 descriptor

	ldq	v2_mask			" mask out all but datatype
	cmk	v2_var,du			" is it char(*) varying?
	tze	ach_err_af		" ... yes -- invoked as an active function
	short_return			" ... no -- all is OK

ach_check_v1:
	ldq	desc_mask			" pick up mask for version 1 descriptors
	cmk	var_desc,du		" is it char(*) varying?
	tze	ach_err_af		" ... yes
	short_return			" ... no


ach_err_no_descs:				" no descriptors in arglist
	lda	error_table_$nodescr
	sta	ap|0,0*
	short_return

ach_err_af:				" called as active function
	lda	error_table_$active_function
	sta	ap|0,0*
	short_return

"

" " " " " " " " " " " " " " " " " " " " "" " " " " " " " "" " "" " " "" " "" "" 
"     arg_ptr_rel ..... get nth argument of specified argument list 
"
"	call cu_$arg_ptr_rel(argno, argptr, arglen, code, arg_list_ptr);
"
"	1. argno (fixed bin(17)) - specifies the desired argument.
"	2. argptr (ptr) - pointer to specified argument (returned).
"	3. arglen (fixed bin(17)) - size of specified argument (returned).
"	4. code (fixed bin(17)) - error status code (returned).
"	5. arg_list_ptr (ptr) - pointer to desired argument list.
"
" " " " " " " " " " " " " " " "" " "" " " " " "" " " " " " " " "" "" " " "" "" "

arg_ptr_rel:
	eppbp	ap|10,*			" get the argument list pointer
	eppbp	bp|0,*			" ...
	tra	arg_ptr_common


" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"    arg_ptr ..... get ptr (and size) of caller's nth argument
"
"	call cu_$arg_ptr(argno, argptr, arglen, code)
"
"	1. argno (fixed bin(17)) - specifies the desired argument.
"	2. argptr (ptr) - pointer to specified argument (returned).
"	3. arglen (fixed bin(17)) - size of specified argument (returned).
"	4. code (fixed bin(17)) - error status code (returned).
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

arg_ptr:	eppbp	sp|stack_frame.arg_ptr,*	" get pointer to caller's argument list

arg_ptr_common:
	ldaq	null			" initialize output values
	staq	ap|4,*			" ... null argument pointer
	stz	ap|6,*			" ... zero length
	stz	ap|8,*			" ... zero error code

	lda	ap|2,*			" pick up argument number
	tmoz	arg_ptr_noarg		" ... must be positive
	als	1
	eax1	0,al			" 2*argument_idx -> X1
	cmpx1	bp|0			" check against the argument count
	tpnz	arg_ptr_noarg		" ... argument_idx is too large

	eppbb	bp|0,1*			" copy the argument pointer
	spribb	ap|4,*

	ldx2	bp|1			" get descriptor word count
	tze	arg_ptr_no_descriptors	" ... no descriptors
	adx1	bp|0			" compute offset to the descriptor
	lxl0	bp|0			" ... check for an environment pointer
	anx0	8+2,du
	tze	2,ic
	eax1	2,1			" ... skip over environment pointer

	lda	bp|0,1*			" pick up the descriptor
	tmi	*+2
	ana	=o777777,dl		" mask for version 1 descriptors
	ana	descriptor_mask		" mask for version 2 descriptors
	sta	ap|6,*			" return the argument length

arg_ptr_no_descriptors:
	short_return

arg_ptr_noarg:				" unknown argument specified
	lda	error_table_$noarg
	sta	ap|8,*
	short_return

" 

" " " " " " " " " " " " " " " " " " " " "" " " " " " " " "" " "" " " "" " "" ""
"     get_command_name_rel ..... get the command name from the passed arg list
"
"	call cu_$get_command_name_rel( command_name_ptr, command_name_length, 
"				code, arg_list_ptr);
"
"	1. command_name_ptr (pointer) - ptr to command_name (returned)
"	2. command_name_length (fixed bin (21)) - size of command_name (returned)
"	3. code (fixed bin(35)) - error status code (returned).
"	4. arg_list_ptr (pointer) - pointer to desired argument list.
"
" " " " " " " " " " " " " " " "" " "" " " " " "" " " " " " " " "" "" " " "" """

get_command_name_rel:
	eppbp	ap|8,*			" get the argument list pointer
	eppbp	bp|0,*			" ...
	tra	get_command_name_common


" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"    get_command_name ..... get command name from callers arg list
"
"	call cu_$get_command_name(command_name_ptr, command_name_length, code)
"
"	1. command_name_ptr (pointer) - ptr to command_name (returned)
"	2. command_name_length (fixed bin (21)) - size of command_name (returned)
"	3. code (fixed bin(35)) - error status code (returned).
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

get_command_name:
	eppbp	sp|stack_frame.arg_ptr,*	" get pointer to caller's argument list

get_command_name_common:
	ldaq	null			" initialize output values
	staq	ap|2,*			" ... command nm ptr = null
	stz	ap|4,*			" ... size = 0
	stz	ap|6,*			" ... zero error code


" check if has name is set

	lxl0	bp|1			" get has name flag
	anx0	has_command_name_mask	" and upper bit of 2nd half
	tze	get_command_name_no_name	" has name not set return error code

" check if non-quick internal procedure

	lxl0	bp|0			" get call type
	anx0	8,du			" compare to 000010 octal
	tnz	get_command_name_no_name	" internal call therfore don't have a command name

" get effective ptr to name and size is + 2 past

	ldx0 	bp|0			" get arg count
	eppbb	bp|2,x0			" get ptr past args
	ldx0	bp|1			" get desc count
	eppbb	bb|0,x0			" got ptr to name ptr

" set return values of name ptr and size

	epplb	bb|0,*			" get name ptr
	sprilb	ap|2,*			" store name ptr
	lda	bb|2			" get size
	ana	fb21_mask			"get fixed bin 21 value
	sta	ap|4,*			" store size

	short_return

get_command_name_no_name:		" name not available
	lda	error_table_$command_name_not_available
	sta	ap|6,*		
	short_return



" 

" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"	af_return_arg ..... returns info on active function arg lists
"
"	call cu_$af_return_arg (n_args, return_ptr, return_len, code);
"
"	1. n_args		number of args (output) (not including return arg)
"	2. return_ptr	pointer to return arg (output)
"	3. return_len	max length of return arg (output)
"	4. code		standard status code
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

af_return_arg:
	ldaq	null			" initialize output arguments
	staq	ap|4,*
	stz	ap|6,*

	eax2	8			" error code is 4th argument
	tsx1	verify_af			" check the call
	arg	af_return_arg_return	" ... error return

af_return_arg_common:
	sta	ap|6,*			" set return value's maximum length

	eppbb	bb|0,*			" get pointer to return value
	eppbb	bb|-1			" ... and adjust to its length word
	spribb	ap|4,*

af_return_arg_return:
	stq	ap|2,*			" set the argument count (from verify_af)
	short_return



" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"	af_return_arg_rel ..... like af_return arg, but the fifth argument is
"			    a pointer to the argument list to use
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

af_return_arg_rel:
	ldaq	null			" initialize output arguments
	staq	ap|4,*
	stz	ap|6,*

	eax2	8			" error code is 4th argument
	eppbp	ap|10,*			" get the real argument list pointer
	eppbp	bp|0,*			" ...

	tsx1	verify_af_rel		" verify that the call is OK
	arg	af_return_arg_return	" ... error return

	tra	af_return_arg_common

" 

" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"	af_arg_count ..... return active function arg count
"
"	call cu_$af_arg_count (n_args, code);
"
"	1. n_args		number of arguments (output)
"	2. code		standard status code
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

af_arg_count:
	eax2	4			" error code is 2nd argument
	tsx1	verify_af			" check the call
	arg	af_arg_count_return		" ... error return

af_arg_count_return:
	stq	ap|2,*			" set the argument count
	short_return



" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"	af_arg_count_rel ..... like af_arg_count but the third arg is
"			    a pointer to the argument list to use
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

af_arg_count_rel:
	eppbp	ap|6,*			" get a pointer to the argument list
	eppbp	bp|0,*			" ...

	eax2	4			" error code is 2nd argument
	tsx1	verify_af_rel		" check the call
	arg	af_arg_count_rel_return	" ... error return

af_arg_count_rel_return:
	stq	ap|2,*			" set the argument count
	short_return

" 

" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"	af_arg_ptr ..... returns pointer to an active function argument
"
"	call cu_$af_arg_ptr (arg_no, arg_ptr, arg_len, code);
"
"	1. arg_no		the number of the argument desired (input)
"	2. arg_ptr	pointer to that argument (output)
"	3. arg_len	its length (output)
"	4. code		standard status code
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

af_arg_ptr:
	ldaq	null			" initialize output arguments
	staq	ap|4,*
	stz	ap|6,*

	eax2	8			" error code is 4th argument
	tsx1	verify_af			" check the call
	arg	af_arg_ptr_return		" ... error return

af_arg_ptr_common:
	cmpq	ap|2,*			" check argument_idx against n_argument
	tmi	af_arg_ptr_noarg		" ... too large

	ldq	ap|2,*			" pick up the argument_idx
	tmoz	af_arg_ptr_noarg		" ... must be positive

	qls	18+1			" convert to pointer offset
	eppbp	bp|0,qu			" make bp -> the argument pointer

	ldq	bp|0,3*			" fetch the argument descriptor
	tmi	2,ic
	anq	-1,dl			" version 1 descriptor length mask
	anq	=o77777777		" mask all but the length
	stq	ap|6,*			" set the length

	eppbb	bp|0,*			" get the argument pointer
	spribb	ap|4,*

af_arg_ptr_return:
	short_return

af_arg_ptr_noarg:
	lda	error_table_$noarg
	sta	ap|8,*
	short_return



" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"	af_arg_ptr_rel ..... like af_arg_ptr
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

af_arg_ptr_rel:
	ldaq	null			" initialize output arguments
	staq	ap|4,*
	stz	ap|6,*

	eppbp	ap|10,*			" get the argument list pointer
	eppbp	bp|0,*			" ...

	eax2	8			" error code is 4th argument
	tsx1	verify_af_rel		" check the call
	arg	af_arg_ptr_return		" ... error return

	tra	af_arg_ptr_common		" go do the work

" 

" Verifies that the given argument list belongs to an active function.  Ie: The last
"    argument must be a varying character string

verify_af:
	eppbp	sp|stack_frame.arg_ptr,*	" use caller's argument list

verify_af_rel:				" use argument list pointer already in bp
	stz	ap|0,2*			" clear status code

	lda	bp|0			" pick up argument list header
	cana	4+8,dl			" must be a PL/I call
	tze	af_error_not_af

	eax0	0,au			" argument count to X0
	tze	af_error_not_af		" ... no arguments: can't be an AF

	cmpx0	bp|1			" last argument must have a descriptor
	tnz	af_error_nodescr

	eppbb	bp|0,0			" set to locate the descriptors
	eax3	0,0			" ... check for an environment pointer
	ana	8+2,dl
	tze	2,ic			" ... no environment pointer
	eax3	2,3			" ... skip over environment pointer

	lda	bb|0,3*			" get the descriptor
	tpl	check_v1_desc		" ... it's a version 1 descriptor

	ldq	v2_mask			" get mask to look at data type
	cmk	v2_var,du			" and check if it's a varying string
	tnz	af_error_not_af		" ... no
	ana	=o77777777		" get the return value's length
	eaq	-2,0			" compute actual argument count
	qrl	18+1			" ... which excludes the return value
	tra	1,1			" normal return

check_v1_desc:				" version 1 argument descriptor
	ldq	desc_mask			" get mask to look at data type
	cmk	var_desc,du		" and check if it's a varying string
	tnz	af_error_not_af		" ... no
	ana	-1,dl			" get the return value's length
	eaq	-2,0			" compute actual argument count
	qrl	18+1			" ... which excludes the return value
	tra	1,1			" normal return

af_error_nodescr:				" no descriptors in argument list
	lda	error_table_$nodescr
	tra	af_error_return

af_error_not_af:				" last argument isn't character(*) varying
	lda	error_table_$not_act_fnc

af_error_return:
	sta	ap|0,2*			" set return code
	eaq	0,0			" put argument count into the Q
	qrl	18+1			" ...
	tra	0,1*			" take error return

" 

" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"   caller_ptr ..... get pointer to text section of invoker's caller
"
"	call cu_$caller_ptr (pointer);
"
"	1. pointer (ptr) is the pointer to invoker's caller's text section
"	     provided he had a stack frame, or null if no caller exists.
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

caller_ptr:
	eppbp	sp|stack_frame.prev_sp,*	get pointer to previous frame
	eppbb	bp|stack_frame.return_ptr,*	pick up the caller's pointer
	spribb	ap|2,*			return pointer to caller
	short_return			return



" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"   arg_list_ptr ..... get pointer to caller's argument list
"
"	call cu_$arg_list_ptr(ap)
"
"	1. ap (ptr) - pointer to caller's argument list (OUTPUT)
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

arg_list_ptr:
	eppbp	sp|stack_frame.arg_ptr,*	" pick up caller's argument list pointer
	spribp	ap|2,*			" return it to caller
	short_return			" return control to caller



" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"    stack_frame_ptr ..... get pointer to caller's stack frame
"
"	call cu_$stack_frame_ptr(sp)
"
"	1. sp (ptr) - pointer to caller's stack frame (returned).
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

stack_frame_ptr:
	sprisp	ap|2,*		return stack frame pointer to caller
	short_return		return control to caller

" 

" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"    stack_frame_size ..... get size of caller's stack frame
"
"	call cu_$stack_frame_size(len)
"
"	1. len (fixed bin(17)) - size of caller's stack frame (returned).
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "


stack_frame_size:
	ldq	sp|stack_frame.next_sp+1	" get offset of next stack frame ...
	qrl	18			" ... into lower half of Q
	sblq	sp|0,dl			" subtract offset of our stack frame ...
	stq	ap|2,*			" ... and you have the stack frame size
	short_return
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"    grow_stack_frame ..... allocate space at end of caller's stack frame
"
"	call cu_$grow_stack_frame(len, ptr, code)
"
"	1. len (fixed bin(17)) - length (in words) by which to grow frame.
"	2. ptr (ptr) - pointer to space allocated in frame (returned).
"	3. code (fixed bin(17)) - error status code (returned).
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "


grow_stack_frame:
	eppbp	sb|stack_header.stack_end_ptr,* pick up pointer to next stack frame
	spribp	ap|4,*		return it as ptr to allocated space
	stz	ap|6,*		preset error code to zero (OK)
	lda	ap|2,*		pick up size by which to grow frame
	ada	15,dl		force size to mod 16
	ana	=o777760,dl	..
	eax1	0,al		place size (now mod 16) into index 1
	adx1	sb|stack_header.stack_end_ptr+1 add size to stack end pointer
	stx1	sp|stack_frame.next_sp+1 bump next frame pointer
	stx1	sb|stack_header.stack_end_ptr+1 update stack end pointer too
	lda	ap|0		check for call from PL/I procedure
	cana	=o14,dl		..
	tze	sb|stack_header.ret_no_pop_op_ptr,*	.. skip if not called by PL/I procedure
	stx1	sp|5		.. otherwise, correct sp|5 for PL/I
	short_return		return control to caller

" 
" " " " " " " " " "  " " " " " " "  " " " " " " " " " "  " " " " "" " " "
"
"	shrink_stack_frame .....  reduce the size of the present stack frame
"
"	call cu_$shrink_stack_frame (stack_ptr, code);
"
"	1. stack_ptr (ptr) - pointer to position in the present stack frame which
"			 will be the beginning of the next stack frame.
"			 The pointer must be sixteen word aligned.
"	2. code (fixed bin(17)) - error status code (returned).
"
" " " " " " " " " " " " " " " " " " "   " " " " " " " " " "   " "  " " " " " 


shrink_stack_frame:
	stz	ap|4,*		zero out code
	eppbp	ap|2,*		get stack pointer
	eax1	bp|0,*		..
	canx1	=o000017,du	check for sixteen aligned
	tze	aligned		..

	lda	error_table_$eight_unaligned	if not aligned return code
	sta	ap|4,*		..
	short_return		..

aligned:	eax2	sp|stack_frame.min_length check to see if before this frame
	cmpx2	bp|1		..
	tmi	inscope1		..

	lda	error_table_$frame_scope_err	if so return error code
	sta	ap|4,*		..
	short_return		..

inscope1:	cmpx1	sb|stack_header.stack_end_ptr+1 check to see if after this frame
	tmi	inscope2		..

	lda	error_table_$frame_scope_err	if so return error code
	sta	ap|4,*		..
	short_return		..

inscope2:	stx1	sp|stack_frame.next_sp+1 if all ok, set next frame pointer
	stx1	sb|stack_header.stack_end_ptr+1 set end ptr
	lda	ap|0		check for PL/1 call
	cana	=o14,dl		..
	tze	sb|stack_header.ret_no_pop_op_ptr,*	skip if not PL/1
	stx1	sp|5		correct sp|5 for PL/1
	short_return		return

" 

" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"     decode_entry_value ..... extract ptrs from PL/I entry variable
"
"	call cu_$decode_entry_value(entry_value, ep_ptr, env_ptr)
"
"	1. entry_value (entry) - entry value to be decoded
"	2. ep_ptr (ptr) - entry point pointer
"	3. env_ptr (ptr) - environment pointer
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "


decode_entry_value:
	epp5	ap|2,*		get ptr to  entry value
	epp3	pr5|0,*		pick up entry ptr from entry variable
	spri3	ap|4,*		store entry ptr in second arg
	epp3	pr5|2,*		pick up environment ptr from  entry variable
	spri3	ap|6,*		store environment ptr in third arg
	short_return



" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"     make_entry_value ..... construct PL/I entry value from input pointer
"
"	call  cu_$make_entry_value (ep_ptr, entry_var)
"
"	1. ep_ptr (ptr) - points to external entry point
"	2. entry_var (entry) - entry variable to be filled in
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "


make_entry_value:
	epp5	ap|2,*		get ptr to first arg
	epp5	pr5|0,*		pick up ep_ptr
	epp3	ap|4,*		get ptr to entrry variable
	spri5	pr3|0		store ep_ptr into  it
	ldaq	null		pick up null ptr
	staq	pr3|2		and store in entry variable
	short_return

" 

" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"    level_get ..... entry to get (return) the current validation level
"
"	call cu_$level_get (level)
"
"	1. level (fixed bin(17)) - current validation level (returned).
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

level_get:
	callsp	hcs_$level_get		" only hardcore knows for sure



" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
"    level_set ..... entry to set the current validation level
"
"	call cu_$level_set(level)
"
"	1. level (fixed bin(17)) - validation level to be set.
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

level_set:
	callsp	hcs_$level_set		" hardcore will do this

	end
