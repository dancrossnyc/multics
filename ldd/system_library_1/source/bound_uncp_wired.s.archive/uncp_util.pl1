/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(88-06-13,Berno), approve(88-07-13,MCR7928),
     audit(88-06-13,Parisek), install(88-07-19,MR12.2-1061):
     Created to implement the uncp multiplexer interface.
                                                   END HISTORY COMMENTS */

/* format: style4,delnl,insnl,^ifthendo */
uncp_util:
     procedure;

/* This procedure contains entries called through hphcs_ used to load and dump an
   *  FNP. The "wire" entry is used to wire the segment containing the core image so that
   *  DIA I/O will be possible; the "load" entry initiates the bootload I/O; the
   *  "release" entry releases the aste of the coreimage.
   *  The "fdump" entry dumps all of FNP memory into a segment supplied
   *  by the caller.
   *
   *  Written 5/19/76 by Robert S. Coren
   *  Modified 10/28/76 by Robert S. Coren to save version number and report core image name
   *  Modified 04/15/77 by Robert S. Coren to correct bug in queue buffer freeing
   *  Modified 9/27/78 by J. Stern for multiplexing changes
   *  Modified 79 May 14 by Art Beattie to get memory size and FNP type from caller for fdump entry.
   *  Modified April 1981 by Chris Jones for io_manager conversion
   *  Modified February 1982 by C. Hornig for MR10 io_manager.
   *  Modified 830714 BIM to remove the release entrypoint. abort is suffcient.
   *  Modified 83-12-20 BIM for reconfiguration.
   *  Modified 84-05-18 BIM for better maintenance of io_manager_assigned bit.
   *  Modified 1984-08-02 BIM for code return from load.
   *  Modified 1984-07-26 BIM for paged I/O on loads.
   *  Modified 1985-01-29, BIM: fix dump_mpx to leave chn unassigned.
   *  Modified 1985-03-12, E. Swenson to fix unitialized timeout flag to
   *     prevent spurious timeout errors.

   *  THE FOLLOWING HISTORY COMMENTS REFER TO UNCP IMPLEMENTATION, AS THIS
   *  WAS ORIGINALLY A COPY OF dn355_util.

   *  Modified in September 1985 for MR11.
   *  Modified in December 1986 for DSA-compact. fd
   *  Modified in January 1987 for MR12.0
   *  Modified in June and July 1987

   *  Date of the last modification  07/07/87.
*/


/* PARAMETERS */

/* Added the DN7100   */
dcl  a_data_ptr ptr;
dcl  cent fixed bin (15) unsigned init (1);		/* DN7100 address modulo 128 */
dcl  un fixed bin (12) unsigned init (1);		/* Transfer of a word */
dcl  a_devx fixed bin;				/* ioam release param */
dcl  a_fnp_no fixed bin;
dcl  a_fnp_mem_size fixed bin;			/* FNP memory size in 1024 18-bit words */
dcl  a_fnp_type fixed bin;
dcl  a_ptr ptr;
dcl  a_count fixed bin;				/* number of words to wire */
dcl  a_code fixed bin (35);				/* OUTPUT */
dcl  a_ev_chan fixed bin (71);
dcl  a_absadr fixed bin (24);				/* OUTPUT from wire and info, INPUT to load */
dcl  norm_int_cell fixed bin;				/* OUTPUT */
dcl  emergency_int_cell fixed bin;			/* OUTPUT */
dcl  a_ints bit (2) aligned;				/* OUTPUT rcvd interrupts */
dcl  a_level fixed bin (3);				/* INPUT level on which to interrupt fnp */
dcl  a_fnp_addr fixed bin (15);			/* INPUT data address in fnp */

/* AUTOMATIC */

dcl  auto_absadr fixed bin (24);
dcl  fnp_no fixed bin;
dcl  fnp_mem_size fixed bin;
dcl  fnp_type fixed bin;
dcl  fnp_addr fixed bin (15);
dcl  opcode bit (6) aligned;
dcl  temp_fnp_name char (32);
dcl  segptr ptr;
dcl  nwords fixed bin;
dcl  code fixed bin (35);
dcl  devx fixed bin;
dcl  abs_addr_string bit (24);			/* representation of absolute address as bit string */
dcl  i fixed bin;
dcl  abs_address fixed bin (26);
dcl  data_ptr ptr;
dcl  offset fixed bin;
dcl  fnp_tally fixed bin;
dcl  start_time fixed bin (71);
dcl  version char (4);
dcl  load_info_ptr ptr;
dcl  locked bit (1) aligned init ("0"b);
dcl  config_locked bit (1) aligned init ("0"b);

declare  message fixed bin (71);
declare  1 auto_fnp_msg aligned like fnp_msg;

/* Ajoute pour le DN 7100  */


/* BUILTINS */

dcl  (addr, addrel, addwordno, baseno, bin, bit, clock, divide, fixed, min,
     null, segno, string, substr, unspec) builtin;


/* ENTRIES */

dcl  config_$find_2 entry (character (4) aligned, character (4) aligned, pointer);
dcl  uncp_multiplexer$assign entry (fixed binary, fixed binary (35));
dcl  uncp_multiplexer$unassign entry (fixed binary, fixed binary (35));
dcl  uncp_multiplexer$fnp_lock entry (pointer, fixed binary (35));
dcl  uncp_multiplexer$fnp_unlock entry (pointer);
dcl  get_fnp_name_ entry (fixed bin) returns (char (32));
dcl  ioam_$assign entry (fixed bin, entry, fixed bin (35));
dcl  ioam_$unassign entry (fixed bin, fixed bin (35));
dcl  priv_channel_manager$get_devx entry (char (*), fixed bin, fixed bin (35));
dcl  dn355_util$compute_parity entry (bit (36)) returns (bit (36));
dcl  absadr entry (ptr, fixed bin (35)) returns (fixed bin (24));
dcl  ioi_page_table$get entry (fixed binary (19), fixed binary, fixed binary (35));
dcl  ioi_page_table$ptx_to_ptp entry (fixed binary) returns (pointer);
dcl  ioi_page_table$put entry (fixed binary, fixed binary (35));
dcl  pxss$notify entry (fixed bin);
dcl  pxss$addevent entry (fixed bin);
dcl  pxss$delevent entry (fixed bin);
dcl  pxss$wait entry;
dcl  pxss$ring_0_wakeup entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
dcl  get_ptrs_$given_segno entry (fixed bin) returns (ptr);
dcl  uncp$interrupt entry;
dcl  uncp$send_global_wcd entry (ptr, fixed bin (8), fixed bin, bit (*) aligned);
dcl  syserr entry options (variable);
dcl  syserr$error_code entry options (variable);
dcl  lock$wait entry (ptr, char (4) aligned, fixed bin (35));
dcl  lock$lock_fast entry (pointer);
dcl  lock$unlock_fast entry (pointer);
dcl  lock$unlock entry (ptr, char (4) aligned);
dcl  pc_abs$wire_abs_contig entry (ptr, fixed bin, fixed bin, fixed bin (35));
dcl  pc_abs$unwire_abs entry (ptr, fixed bin, fixed bin);

/* EXTERNAL STATIC */

dcl  (
     error_table_$io_no_permission,
     error_table_$invalid_state,
     error_table_$bad_mpx_load_data,
     error_table_$no_io_interrupt,
/*     error_table_$rqover,*/
     error_table_$io_configured,
     error_table_$io_not_configured,
     error_table_$io_not_assigned,
     error_table_$io_not_defined
     ) fixed bin (35) ext static;

dcl  pds$processid bit (36) ext static;
dcl  pds$process_group_id char (32) ext static;
dcl  tc_data$initializer_id bit (36) aligned external static;
dcl  tty_buf$fnp_config_flags (1:8) bit (1) unaligned external static;
dcl  tty_buf$lct_ptr pointer external static;
dcl  sst$astsize fixed bin external;
dcl  sys_info$page_size fixed bin external;


/* INTERNAL STATIC */

dcl  (
     FNP_DOWN init (2)
     ) fixed bin int static options (constant);
dcl  SIZE_1024 fixed bin int static options (constant) init (1024);
dcl  NORM_CELL fixed bin int static options (constant) init (3);
dcl  EMER_CELL fixed bin int static options (constant) init (7);
dcl  SECONDS_30 fixed bin (35) int static options (constant) init (30000000);
dcl  MIN_TALLY fixed bin int static options (constant) init (308);
dcl  BIT_75 bit (6) int static options (constant) init ("75"b3);
dcl  BIT_76 bit (6) int static options (constant) init ("76"b3);
dcl  SIZE_256 fixed bin int static options (constant) init (256);
dcl  LOW_MBX_PTW fixed bin int static options (constant) init (1);
dcl  HIGH_MBX_PTW fixed bin int static options (constant) init (3);
dcl  fdump_seg_event char (4) aligned init ("fnpd") static options (constant);
dcl  cleanup condition;


/* BASED */

dcl  tally_words (fnp_tally) bit (36) aligned based;

dcl  1 dump_355_control aligned based (data_ptr),		/* word used to supply 355 address and tally for fdump */
       2 address_mode bit (3) unaligned,		/* always 36-bit addressing ("001"b) */
       2 fnp_address bit (15) unaligned,
       2 tally fixed bin (17) unaligned;

dcl  1 dump_6670_control aligned based (data_ptr),	/* word used to supply DN6670 address and tally for fdump */
       2 fnp_address fixed bin (18) unsigned unaligned,
       2 unpaged bit (1) unaligned,
       2 mbz bit (5) unaligned,
       2 tally fixed bin (12) unsigned unaligned;

dcl  1 load_info aligned based (load_info_ptr),		/* used to assign baud rates and line types at bootload time */
       2 ev_chan fixed bin (71),
       2 no_entries fixed bin,
       2 entries (0 refer (load_info.no_entries)),
         3 devx fixed bin,
         3 baud_rate fixed bin,
         3 line_type fixed bin,
       2 version char (4),				/* version number of the DNS software */
       2 pointeur_image_dns ptr,			/* pointer to the beginning of the segment   */
       2 image fixed bin (24),			/* memory size */
       2 etape fixed bin;				/* Stages of loading */
						/* 1 - It is assumed that the Datanet is already loaded */
						/* 2 - It loads the Datanet from Multics */
				                    /* 3 - Loading the Datanet from diskette */

/* Added for the DN7100 */
dcl  1 d7100 aligned based (data_ptr),			/* To give the address and size for clearing of the DN7100. */
       2 pcw,
         3 adr_mode bit (3) unaligned init ("001"b),
         3 fnp_address fixed bin (15) unsigned unaligned,	/* DN7100 address to clear */
         3 poids_fort bit (1) unaligned init ("1"b),	/* 1 = strong points (cad X 2**7 ) */
         3 pad3 bit (5) unaligned init ("00000"b),
         3 tally fixed bin (12) unsigned unaligned,	/* Dimension of the zone to clear */
       2 working_location (7) fixed bin (35) unaligned,
       2 verrou_mot,
         3 pad bit (35) unaligned,
         3 verrou bit (1) unaligned,
       2 control_information unaligned,
         3 pad1 bit (1) unaligned,
         3 administrative_header bit (4) unaligned,
         3 node_type_ofresponder bit (4) unaligned,
         3 pad2 bit (1) unaligned,
         3 software_level_of_responder bit (8) unaligned,
         3 node_ID_of_responder bit (18) unaligned,
         3 Time_of_response bit (36) unaligned,
         3 Node_ID_of_originator bit (18) unaligned,
         3 pad3 bit (1) unaligned,
         3 Origin_type bit (8) unaligned,
         3 pad4 bit (1) unaligned,
         3 Specific_origin bit (8) unaligned,
         3 pad5 bit (1) unaligned,
         3 RFU bit (8) unaligned,
         3 pad6 bit (1) unaligned,
         3 Type bit (8) unaligned,
         3 pad7 bit (1) unaligned,
         3 Class bit (8) unaligned,
         3 pad8 bit (1) unaligned,
         3 Code bit (8) unaligned,
         3 pad8b bit (2) unaligned,
         3 Length_of_commmand bit (16) unaligned,
         3 pad9 bit (1) unaligned,
         3 Format_of_response bit (8) unaligned,
         3 pad10 bit (1) unaligned,
         3 Importance_level bit (8) unaligned,
         3 Length_of_response bit (18) unaligned,
         3 S2_link_ident bit (18) unaligned;

/* This structure is used by the commands RIM, SIM. */
/*
dcl  1 command_parameters aligned based (commandp),
       2 S2_link_identification bit (36) unaligned,
       2 Argument bit (18) unaligned,
       2 command_error unaligned,
         3 mode_4 bit (18) unaligned,
         3 error_code bit (18) unaligned;
*/
/* This structure is used by the command START NODE  */
/*
dcl  1 cmd_parameters aligned based (commandp),
       2 S2_link_identification bit (36) unaligned,
       2 Starting_address bit (36) unaligned,
       2 Option_string_length bit (18) unaligned,
       2 Option_string char (2) init ("GO") unaligned,
       2 cmd_error unaligned,
         3 mode_4 bit (18) unaligned,
         3 error_code bit (18) unaligned;

dcl  commandp pointer;

dcl  1 format_32 based,
       2 rien bit (4) unaligned,
       2 bit8_32 (4) bit (8) unaligned;

dcl  1 format_36 based,
       2 bit9 (4),
         3 bit0 bit (1) unaligned,
         3 bit8_36 bit (8) unaligned;
*/

load:
     entry (a_fnp_no, a_data_ptr, a_code);		/* For the DN7100 */



/* entry to initiate bootload I/O for loading an FNP */

	fnp_no = a_fnp_no;
	load_info_ptr = a_data_ptr;
	call validate_fnp_ret ("load");
	call validate_assigned_ret ("load");

	if datanet_info.trace
	then call syserr (ANNOUNCE, "uncp_util$load: FNP ^d ADDR ^o", fnp_no, auto_absadr);

	call assign_interrupt (uncp$interrupt, code);

	if fnp_info.bootloading
	then do;					/* we can't do it while it's already happening */
	     code = error_table_$invalid_state;
	     call syserr (ANNOUNCE, "uncp_util$load: FNP load already in progress for FNP ^a.", fnp_info.fnp_tag);
	     go to load_return;
	end;


	if fnp_info.running
	then do;
	     code = error_table_$invalid_state;
	     if datanet_info.trace
	     then call syserr (ANNOUNCE, "uncp_util$load: FNP ^a is running.", fnp_info.fnp_tag);
	     go to load_return;
	end;


/* process the load_info data */

	if load_info.no_entries ^= fnp_info.no_of_channels
	then do;

	     a_code = error_table_$bad_mpx_load_data;
	     go to load_return;
	end;
	
	n_pcbs = fnp_info.no_of_channels;

	do i = 1 to load_info.no_entries;		/* get baud rates to store in pcbs */
	     pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (i));
	     if load_info (i).devx ^= pcb.devx		/* load_info does not match pcb_array */
	     then do;
		a_code = error_table_$bad_mpx_load_data;
		go to load_return;
	     end;
	     pcb.baud_rate = load_info (i).baud_rate;
	     pcb.line_type = load_info (i).line_type;


	end;

/* it's okay to try to load */

	version = "    ";

	fnp_info.boot_ev_chan = load_info.ev_chan;
	fnp_info.boot_process_id = pds$processid;
	fnp_info.version = version;
	fnp_info.fnp_mem_size = fnp_mem_size * SIZE_1024;
	fnp_info.bootloading = "1"b;

	datanet_mbx.dia_pcw.command = ""b;		/* last command */
	datanet_mbx.mailbox_requests = 0;		/* clear fields in mbx for this load */
	datanet_mbx.term_inpt_mpx_wd = "0"b;
	datanet_mbx.last_mbx_req_count = 0;
	string (datanet_mbx.mbx_used_flags) = "0"b;

	datanet_mbx.crash_data.fault_code = 0;
	datanet_mbx.crash_data.ic = 0;
	datanet_mbx.crash_data.iom_fault_status = 0;
	datanet_mbx.crash_data.fault_word = 0;


	ttybp = addr (tty_buf$);
	fnp_dump_ptr = addr (fnp_dump_seg$);


deux_ten:					
send_wcd:

	call uncp$send_global_wcd (fnpp, init_complete, 0, ""b);

/* Sortie normale meme si l init_complete n a pas ete effective  */

	code = 0;					/* all is well so far */
	go to fin;


unwire_load_buffer:
	call unwire_dump_seg;
restore_load_interrupt:
	call assign_interrupt (uncp$interrupt, code);	/* let uncp take over interrupts again */

unlock_load_seg:
	call lock$unlock (addr (fnp_dump_seg.lock), fdump_seg_event);
ret_bad_load_code:
fin:
	a_code = code;
	return;

load_return:
	if code ^= 0 & (datanet_info.trace | datanet_info.debug_stop)
	then do;
	     call syserr$error_code (ANNOUNCE, code, "uncp_util$load: Error loading FNP ^a.", fnp_info.fnp_tag);
	     call STOP_CHECK ("load");
	end;
	a_code = code;
	return;


info:
     entry (a_fnp_no, a_absadr, norm_int_cell, emergency_int_cell, a_code);

/* entry called to return address of mailbox area and FNP interrupt cells */

	fnp_no = a_fnp_no;
	call validate_fnp_ret ("info");

	a_absadr = absadr (fnp_info.mbx_pt, code);
	if code = 0
	then do;					/* provided everything's ok */
	     norm_int_cell = NORM_CELL;		/* customary assignments */
	     emergency_int_cell = EMER_CELL;
	end;

	a_code = code;
	return;

fill_page_table:
     entry (a_fnp_no, a_code);

	fnp_no = a_fnp_no;
	call validate_fnp_ret ("fill_page_table");
	call validate_assigned_ret ("fill_page_table");
	if fnp_info.ptx ^= -1 | fnp_info.ptp ^= null ()
	then do;
	     call syserr (ANNOUNCE, "uncp_util$fill_page_table: page table already assigned for FNP ^a.",
		fnp_info.fnp_tag);
	     call STOP_CHECK ("fill_page_table");
	end;
	call get_page_table (code);
	if code ^= 0 & (datanet_info.trace | datanet_info.debug_stop)
	then do;
	     call syserr$error_code (ANNOUNCE, code, "uncp_util$fill_page_table: ioi_page_table$get failed for FNP ^a.",
		fnp_info.fnp_tag);
	     call STOP_CHECK ("fill_page_table");
	end;
	a_code = code;
	return;

free_page_table:
     entry (a_fnp_no, a_code);

	fnp_no = a_fnp_no;
	call validate_fnp_ret ("free_page_table");
	if fnp_info.ptx = -1
	then do;
	     call syserr (ANNOUNCE, "uncp_util$free_page_table: no page table assigned for FNP ^a.", fnp_info.fnp_tag);
	     go to ret_bad_code;
	end;
	call ioi_page_table$put (fnp_info.ptx, code);
	fnp_info.ptx = -1;
	fnp_info.ptp = null ();
	a_code = code;
	return;


/* RECONFIGURATION ENTRYPOINTS */

/* Configure -- add a FNP to the available collection for assignment */

/* This procedure is NOT REFERENCED by uncp software, but rather calls 
   fnp_util$configure. */

configure:
     entry (a_fnp_no, a_code);

	fnp_no = a_fnp_no;
	call validate_fnp_ret ("configure");
	call lock_fnp;
	if fnp_info.available
	then do;
	     code = error_table_$io_configured;
	     if datanet_info.trace | datanet_info.debug_stop
	     then call syserr (ANNOUNCE, "uncp_util$configure: FNP ^a already configured.", fnp_info.fnp_tag);
	     call STOP_CHECK ("configure");
	     go to configure_return;
	end;
	fnp_info.available = "1"b;
	fnp_info.io_manager_assigned = "0"b;		/* clean up */
	fnp_info.flags = "0"b;			/* state information */
configure_return:
	call unlock_fnp;
	if code = 0
	then do;
	     call config_$find_2 ("prph", "fnp" || fnp_info.fnp_tag, prph_fnp_cardp);
	     prph_fnp_card.state = "on";
	     call syserr (ANNOUNCE, "uncp_util: FNP ^a added to configuration^[ by ^a^].", fnp_info.fnp_tag,
		pds$processid ^= tc_data$initializer_id, pds$process_group_id);
	end;
	a_code = code;
	return;

/**** Deconfigure -- remove from configuration.
      This entrypoint causes a FNP crash for the selected FNP.
*/

/* This procedure is NOT REFERENCED by uncp software, but rather calls 
   fnp_util$deconfigure. */

deconfigure:
     entry (a_fnp_no, a_code);

	fnp_no = a_fnp_no;
	call validate_fnp_ret ("deconfigure");
	call lock_fnp;

	if ^fnp_info.available
	then do;
	     code = error_table_$io_not_configured;
	     go to deconfigure_return;
	end;

	fnp_info.available = "0"b;			/* throttle init_multiplexer */

	if ^fnp_info.io_manager_assigned
	then go to deconfigure_return;

	/*** here is the interesting part. What we do depends on who is active */

	if fnp_info.t_and_d_in_progress
	then do;
	     call unlock_fnp;			/* must lock in correct order */
	     call release_t_and_d;			/* unassigns channel */
	     go to deconfigure_return_unlocked;
	end;
	else do;
	     call mask_dia;				/* stop it from writing to us or sending stuff */
	     call uncp_multiplexer$unassign (fnp_no, (0));/* has to succeed, we are under lock */
	     /*** turns off io_manager_assigned for us, nailing io_manager callers */
	     auto_fnp_msg.fnp_no = fnp_info.fnp_number;
	     auto_fnp_msg.state = FNP_DOWN;
	     auto_fnp_msg.flags = "0"b;
	     auto_fnp_msg.deconfigured = "1"b;
	     unspec (message) = unspec (auto_fnp_msg);
	     call pxss$ring_0_wakeup (fnp_info.boot_process_id, fnp_info.boot_ev_chan, message, (0));
	end;

	/*** all callers of io_manager must hold LCTE lock and check io_manager_assigned */

deconfigure_return:
	call unlock_fnp;
deconfigure_return_unlocked:
	if code = 0
	then do;
	     call config_$find_2 ("prph", "fnp" || fnp_info.fnp_tag, prph_fnp_cardp);
	     prph_fnp_card.state = "off";
	     call syserr (ANNOUNCE, "uncp_util: FNP ^a deleted from configuration^[ by ^a^].", fnp_info.fnp_tag,
		pds$processid ^= tc_data$initializer_id, pds$process_group_id);
	end;
	a_code = code;
	return;

abort:
     entry (a_fnp_no, a_code);

/* entry called to abort bootload */
	fnp_no = a_fnp_no;
	call validate_fnp_ret ("abort");
	fnp_info.bootloading, fnp_info.running = "0"b;
	a_code = code;
	return;


fdump:
     entry (a_fnp_no, a_fnp_type, a_fnp_mem_size, a_ptr, a_code);

/* entry to read in contents of FNP core for fdump_fnp_.  It is passed a pointer
   *  to the segment in which the dump is supposed to be put.  The one-page fnp_dump_seg
   *  is wired down, and FNP core is read into it in chunks.
   *
   *  This entry had to be greatly modified for the clearing of the Datanet 7100.
   *  Called by the initializer command "dump_mpx" through uncp_multiplexer$hpriv_control
      froma "dump" control order passed through hphcs_$tty_order -> priv_channel_manager -> cmtv.
      This entry is currently NON-OPERATIONAL.

*/

	fnp_no = a_fnp_no;
	fnp_type = a_fnp_type;
	fnp_mem_size = a_fnp_mem_size;
	segptr = a_ptr;

	call validate_fnp_ret ("fdump");


	ttybp = addr (tty_buf$);
	fnp_dump_ptr = addr (fnp_dump_seg$);
	on cleanup
	     begin;
	     if fnp_dump_seg.lock = pds$processid
	     then call lock$unlock (addr (fnp_dump_seg.lock), fdump_seg_event);
	end;
	go to ret_bad_code;
/*
	call lock$wait (addr (fnp_dump_seg.lock), fdump_seg_event, code);
	if code ^= 0
	then go to ret_bad_code;
	call assign_interrupt (dump_interrupt, code);	/* we will handle DIA interrupts for this *
	if code ^= 0
	then go to unlock_dump_seg;

	call wire_dump_seg;
	if code ^= 0
	then go to restore_interrupt;

	data_ptr = addr (fnp_dump_seg.data);



	fnp_size = fnp_mem_size * 512;		/* size of FNP core in 36-bit words *

/* before we start, set up handler for record-quota overflow *

	on record_quota_overflow
	     begin;
	     code = error_table_$rqover;
	     go to unwire_buffer;
	end;


/* Subroutine to quiet the mmpo which we leave to clear the memory by blocks.
   We have three minutes for the job.

	call init_mmpo;
	if a_code ^= 0
	then go to unwire_buffer;


/* loop reading chunks of FNP memory *
/* Go read blocks of 768 Multics words ( 512+256 ) *

/* Address of the 7100 modulo 256.    *
	fnp_info.running = "0"b;			/* It is no longer in running state *
	fnp_addr, offset = 0;
	fnp_tally = 768;
	do while (fnp_tally > 0);
	     call setup_dump_ctl_word;
	     call fdump_seg_io ("75"b3);		/*  test data xfer *
	     if code ^= 0
	     then go to unwire_buffer;

/* Now copy the data into the permanent seg *

	     ptr (segptr, offset) -> tally_words = addr (fnp_dump_seg.data (2)) -> tally_words;
						/* word 0 and 1 are control words *
	     offset = offset + 768;
	     fnp_tally = min (768, fnp_size - offset);
	end;

/* Ajouter pour le DN 7100 ************************ *

/*  The MMPO has to safeguard the first 100 words of memory in high memory
    (address of the end of memory - 400).  It must then replace this zone in
     its place *

	offset = fnp_size - 512;			/* start of the saved zone *
	segpt1 = ptr (segptr, offset);
	segptr = a_ptr;				/* start of the segment *
	fnp_tally = SIZE_128;			/* cad 100 words hex of 16 bits expressed in L68 36 bit decimal words *
	segptr -> tally_words = segpt1 -> tally_words;	/* Yo!  It's done *

unwire_buffer:
	call unwire_dump_seg;			/* and unwire buffer *

restore_interrupt:
	call assign_interrupt (uncp$interrupt, code);
*/


unlock_dump_seg:
	call lock$unlock (addr (fnp_dump_seg.lock), fdump_seg_event);
ret_bad_code:
	a_code = code;
	return;


fdump_seg_io:
     proc (a_diaop);

dcl  a_diaop bit (6) aligned;

	start_time = clock ();
	fnp_dump_seg.fdump = "1"b;			/* so notify can be done */
	call pxss$addevent (tty_ev);
	call connect_to_dia (a_diaop);
	call pxss$wait;				/* wait for interrupt */

	do while (fnp_dump_seg.fdump);		/* when we get notify, make sure it's the right one */
	     if clock () - start_time > SECONDS_30	/* if it's been more than 30 seconds */
	     then do;				/* punt */
		code = error_table_$no_io_interrupt;
		return;
	     end;

	     call pxss$addevent (tty_ev);
	     if fnp_info.t_and_d_in_progress
	     then if fnp_info.t_and_d_lev_3_occurred | fnp_info.t_and_d_lev_7_occurred
		then do;
		     code = 0;
		     return;
		end;
	     if fnp_dump_seg.fdump			/* it wasn't */
	     then call pxss$wait;			/* wait some more */
	     else call pxss$delevent (tty_ev);		/* otherwise we needn't have added event */
	end;
	code = 0;
     end fdump_seg_io;

dump_interrupt:
     entry (a_fnp_no, a_level, a_dummy);

/* this is our temporary FNP interrupt handler while doing fdump i/o */

dcl  a_dummy bit (36) aligned parameter;

	fnp_dump_ptr = addr (fnp_dump_seg$);
	infop = addr (dn355_data$);
	if datanet_info.trace
	then call syserr (ANNOUNCE,
		"uncp_util (dump_interrupt): Interrupt for FNP ^d level ^d. fnp_dump_seg.fdump = ""^b""b", a_fnp_no,
		a_level, fnp_dump_seg.fdump);
	if fnp_dump_seg.fdump			/* if we're really interested in this one */
	then do;
	     fnp_dump_seg.fdump = "0"b;		/* so we'll recognize notify */
	     call pxss$notify (tty_ev);
	end;
	return;





/* This procedure is NOT REFERENCED by uncp software, but rather calls 
   fnp_util$fnp_tandd_setup. */

fnp_tandd_setup:
     entry (a_fnp_no, a_ev_chan, a_code);

	fnp_no = a_fnp_no;
	call validate_fnp_ret ("fnp_tandd_setup");

/* Must set up lcte ptr first if not done already, or lock
   won't work.  Chicken/egg problem notwithstanding, this will
   work, because other guy doing same thing. */

	temp_fnp_name = get_fnp_name_ (fnp_no);
	if fnp_info.lcte_ptr = null
	then do;
	     call priv_channel_manager$get_devx (temp_fnp_name, devx, code);
	     if code ^= 0
	     then go to ret_bad_code;
	     fnp_info.lcte_ptr = addr (tty_buf$lct_ptr -> lct.lcte_array (devx));
	end;

	call lock_fnp;

	if fnp_info.bootloading | fnp_info.running | fnp_info.t_and_d_in_progress
	then do;
	     code = error_table_$invalid_state;
	     go to tandd_setup_loses_unlock;
	end;

	call uncp_multiplexer$assign (fnp_no, code);
	if code ^= 0
	then do;
	     call syserr$error_code (ANNOUNCE, code, "uncp_util: channel assignment failed for FNP ^a.",
		fnp_info.fnp_tag);
	     go to tandd_setup_loses_unlock;
	end;

	call ioam_$assign ((fnp_info.io_manager_chx), fnp_tandd_release_handler, code);
	if code ^= 0
	then do;
	     call syserr$error_code (ANNOUNCE, code, "uncp_util: ioam_$assign failed for FNP ^a.", fnp_info.fnp_tag);
	     go to tandd_setup_loses_unlock;
	end;
	fnp_info.boot_process_id = pds$processid;
	fnp_info.t_and_d_lev_3_occurred, fnp_info.t_and_d_lev_7_occurred = "0"b;
	call syserr (ANNOUNCE, "uncp_util: assigned FNP ^a to ^a for T & D.", temp_fnp_name, pds$process_group_id);
	fnp_info.t_and_d_in_progress = "1"b;

tandd_setup_loses_unlock:
	if code = 0
	then fnp_info.boot_ev_chan = a_ev_chan;
	call unlock_fnp;
	a_code = code;
	return;

/* This procedure is NOT REFERENCED by uncp software, but rather calls 
   fnp_util$fnp_tandd_release_handler. */

fnp_tandd_release_handler:
     entry (a_devx, a_code);

	devx = a_devx;
	infop = addr (dn355_data$);
	fnp_dump_ptr = addr (fnp_dump_seg$);
	on cleanup
	     begin;
	     if fnp_dump_seg.lock = pds$processid
	     then call lock$unlock (addr (fnp_dump_seg.lock), fdump_seg_event);
	end;
	do fnp_no = 1 to datanet_info.no_of_355s;
	     fnpp = addr (datanet_info.per_datanet (fnp_no));
	     if devx = fnp_info.io_manager_chx
	     then if fnp_info.t_and_d_in_progress
		then call release_t_and_d;
	end;
	return;

/**** T and D does not have to worry about force deconfiguration,
      since it is completely released at deconfigure time.
      Validate_fnp_tandd_ret will generate an error code if
      deconfiguration has stolen the FNP. */


/* This procedure is NOT REFERENCED by uncp software, but rather calls 
   fnp_util$fnp_tandd_detach. */

fnp_tandd_detach:
     entry (a_fnp_no, a_code);
	fnp_no = a_fnp_no;

	call validate_fnp_tandd_ret ("fnp_tandd_detach");
	call lock_fnp;
	call validate_assigned_ret ("fnp_tandd_detach");

	call mask_dia;

	fnp_info.boot_process_id = "000000000000"b3;
	fnp_info.t_and_d_in_progress = "0"b;
	fnp_info.t_and_d_lev_3_occurred, fnp_info.t_and_d_lev_7_occurred = "0"b;
	call ioam_$unassign ((fnp_info.io_manager_chx), (0));
	call uncp_multiplexer$unassign (fnp_no, code);
	if code ^= 0
	then call syserr$error_code (ANNOUNCE, code, "uncp_util: io channel unassignment failed for FNP ^a.",
		fnp_info.fnp_tag);
	call syserr (ANNOUNCE, "uncp_util: releasing FNP ^a from ^a", fnp_info.fnp_id.fnp_tag, pds$process_group_id);
	call unlock_fnp;
	a_code = 0;
	return;

/* This procedure is NOT REFERENCED by uncp software, but rather calls 
   fnp_util$fnp_tandd_mask. */

fnp_tandd_mask:
     entry (a_fnp_no, a_code);
	fnp_no = a_fnp_no;
	call validate_fnp_tandd_ret ("fnp_tandd_mask");
	call lock_fnp;
	call validate_assigned_ret ("fnp_tandd_mask");

	call mask_dia;
	call unlock_fnp;
	a_code = 0;
	return;

/* This procedure is NOT REFERENCED by uncp software, but rather calls 
   fnp_util$fnp_tandd_send_int. */

fnp_tandd_send_int:
     entry (a_fnp_no, a_level, a_code);
	fnp_no = a_fnp_no;
	call validate_fnp_tandd_ret ("fnp_tandd_send_int");
	call lock_fnp;
	call validate_assigned_ret ("fnp_tandd_send_int");

	fnp_info.t_and_d_lev_3_occurred, fnp_info.t_and_d_lev_7_occurred = "0"b;
	call connect_to_dia ("71"b3);
	call unlock_fnp;

	a_code = 0;
	return;

/* This procedure is NOT REFERENCED by uncp software, but rather calls 
   fnp_util$fnp_tandd_get_ints. */

fnp_tandd_get_ints:
     entry (a_fnp_no, a_ints, a_code);
	fnp_no = a_fnp_no;
	call validate_fnp_tandd_ret ("fnp_tandd_get_ints");
	call lock_fnp;
	call validate_assigned_ret ("fnp_tandd_get_ints");
	a_ints = fnp_info.t_and_d_lev_3_occurred || fnp_info.t_and_d_lev_7_occurred;
	fnp_info.t_and_d_lev_3_occurred, fnp_info.t_and_d_lev_7_occurred = "0"b;
	call unlock_fnp;
	a_code = 0;
	return;

/* This procedure is NOT REFERENCED by uncp software, but rather calls 
   fnp_util$fnp_tandd_read. */

fnp_tandd_read:
     entry (a_fnp_no, a_ptr, a_count, a_fnp_addr, a_fnp_type, a_code);
	opcode = BIT_75;
	go to fnp_t_and_d_rw_merge;

/* This procedure is NOT REFERENCED by uncp software, but rather calls 
   fnp_util$fnp_tandd_write. */

fnp_tandd_write:
     entry (a_fnp_no, a_ptr, a_count, a_fnp_addr, a_fnp_type, a_code);
	opcode = BIT_76;
fnp_t_and_d_rw_merge:
/**** To avoid LONG delays in deconfiguration, this does not lock
      the LCTE lock except around the connects themselves. */
	fnp_no = a_fnp_no;
	segptr = a_ptr;
	nwords = a_count;
	fnp_type = a_fnp_type;
	fnp_addr = a_fnp_addr;
	fnp_dump_ptr = addr (fnp_dump_seg$);
	call validate_fnp_tandd_ret ("fnp_tandd_rw");

	on cleanup
	     begin;
	     if fnp_dump_seg.lock = pds$processid
	     then call lock$unlock (addr (fnp_dump_seg.lock), fdump_seg_event);
	end;

	data_ptr = addr (fnp_dump_seg.data);

	call lock$wait (addr (fnp_dump_seg.lock), fdump_seg_event, code);
	if code ^= 0
	then go to ret_bad_code;
	if fnp_type = DN6670
	then dump_6670_control.unpaged = "1"b;
	else dump_355_control.address_mode = "1"b3;
	offset = 0;
	do while (nwords > 0);
	     fnp_tally = min (MIN_TALLY, nwords);
	     nwords = nwords - fnp_tally;
	     call setup_dump_ctl_word;
	     if opcode = BIT_76			/* WRITE */
	     then addr (fnp_dump_seg.data (2)) -> tally_words = addrel (segptr, offset) -> tally_words;
	     call wire_dump_seg;
	     if code ^= 0
	     then go to unlock_dump_seg;
	     fnp_info.t_and_d_lev_3_occurred, fnp_info.t_and_d_lev_7_occurred = "0"b;
	     fnp_info.t_and_d_notify_requested = "1"b;

	     call fdump_seg_io (opcode);

	     fnp_info.t_and_d_lev_3_occurred, fnp_info.t_and_d_lev_7_occurred = "0"b;
	     call unwire_dump_seg;
	     if code ^= 0
	     then go to unlock_dump_seg;
	     if opcode = BIT_75			/* READ */
	     then addrel (segptr, offset) -> tally_words = addr (fnp_dump_seg.data (2)) -> tally_words;

	     offset = offset + fnp_tally;
	end;
	code = 0;
	go to unlock_dump_seg;


validate_assigned_ret:
     procedure (caller);

declare  caller char (32);

	if ^fnp_info.io_manager_assigned
	then do;
	     code = error_table_$io_not_assigned;
	     if datanet_info.trace | datanet_info.debug_stop
	     then call syserr$error_code (ANNOUNCE, code,
		     "uncp_util$validate_assigned_ret (^a): IO manager assignment lacking.", caller);
	     call STOP_CHECK ("validate_assigned_ret");
	     call unlock_fnp;
	     go to ret_bad_code;
	end;
	return;
     end validate_assigned_ret;


validate_fnp_ret:
     procedure (caller);

declare  caller char (32);

/* internal procedure to ensure that FNP number is reasonable */

	infop = addr (dn355_data$);

	if fnp_no <= 0 | fnp_no > max_no_355s
	then do;
	     code = error_table_$io_not_defined;
ERROR:
	     if datanet_info.trace | datanet_info.debug_stop
	     then call syserr$error_code (ANNOUNCE, code, "uncp_util$^a: Invalid call for FNP ^d.", caller, fnp_no);
	     call STOP_CHECK (caller);
	     go to ret_bad_code;
	end;

	if ^tty_buf$fnp_config_flags (fnp_no)
	then do;
	     fnpp = null;
	     code = error_table_$io_not_defined;
	     go to ERROR;
	end;

	code = 0;
	fnpp = addr (datanet_info.per_datanet (fnp_no));
	mbxp = fnp_info.mbx_pt;
	if datanet_info.trace
	then call syserr (ANNOUNCE, "uncp_util$^a: Tracing call for fnp ^a.", caller, fnp_info.fnp_tag);

	return;

     end validate_fnp_ret;



validate_fnp_tandd_ret:
     proc (caller);

declare  caller char (32);

	call validate_fnp_ret (caller);
	if ^fnp_info.t_and_d_in_progress
	then code = error_table_$invalid_state;
	else if fnp_info.boot_process_id ^= pds$processid
	then code = error_table_$io_no_permission;
	if code ^= 0
	then do;
	     if (datanet_info.trace | datanet_info.debug_stop)
	     then call syserr$error_code (ANNOUNCE, code, "uncp_util$^a: Invalid call.", caller);
	     go to ret_bad_code;
	end;
	return;					/* validate_fnp_ret did trace */
     end validate_fnp_tandd_ret;

setup_dump_ctl_word:
     proc;

	d7100.pcw.fnp_address = divide (2 * offset, SIZE_256, 14, 0);
						/* The DN7100 address is modulo 256 */
	d7100.pcw.tally = fixed (fnp_tally, 11);	/* Tally in L68 words */

     end;

wire_dump_seg:
     proc;

	astep = get_ptrs_$given_segno (fixed (baseno (fnp_dump_ptr), 17));
	call pc_abs$wire_abs_contig (astep, 0, 1, code);	/* wire a page */
	if code = 0
	then abs_address = absadr (fnp_dump_ptr, code);
	if code = 0
	then abs_addr_string = bit (fixed (abs_address + 2, 24), 24);
						/* fdump_seg_io needs this */
     end;

unwire_dump_seg:
     proc;

	astep = get_ptrs_$given_segno (fixed (baseno (fnp_dump_ptr), 17));
	call pc_abs$unwire_abs (astep, 0, 1);
	return;
     end unwire_dump_seg;


assign_interrupt:
     proc (handler, code);

/* internal procedure to set handler for IOM interrupt to our proc. */

dcl  handler entry;

dcl  iom_code fixed bin (35);
dcl  code fixed bin (35);

	call lock_fnp;				/* discourage reconfiguration */
	if ^fnp_info.io_manager_assigned		/* already deconfigured?  */
	then if ^fnp_info.available			/* already deconfigured! */
	     then do;
		code = error_table_$io_not_configured;
		return;
	     end;

/**** It may already be unassigned, as in dump of down MPX */

	if fnp_info.io_manager_assigned
	then do;
	     call io_manager$unassign (fnp_info.io_manager_chx, code);
	     if code ^= 0
	     then call syserr$error_code (CRASH, code, "uncp_util: Could not unassign FNP ^a at reassign_interrupt.",
		     fnp_info.fnp_tag);
	     fnp_info.io_manager_assigned = "0"b;
	end;					/* now make new assignment */

	call io_manager$assign (fnp_info.io_manager_chx, fnp_info.io_chanid, handler, (fnp_no), (null ()), iom_code);
	call unlock_fnp;
	if code = 0				/* if there wasn't anything more interesting to report */
	then do;
	     code = iom_code;			/* then report this */
	     fnp_info.io_manager_assigned = "1"b;
	end;

	return;

     end assign_interrupt;

/*  unassign_interrupt:
   procedure;

   call io_manager$unassign (fnp_info.io_manager_chx, (0));
   fnp_info.io_manager_assigned = "0"b;
   return;
   end unassign_interrupt;      */
connect_to_dia:
     proc (cmd);

/* internal procedure to do DIA i/o */

dcl  cmd bit (6) aligned;
dcl  1 ima aligned like io_manager_arg;

	datanet_mbx.dia_pcw.zero = substr (abs_addr_string, 7, 18);
						/* lower 18 bits of 6180 address */
	datanet_mbx.dia_pcw.mbx_no = substr (abs_addr_string, 1, 6);
						/* rest of it goes here */
	datanet_mbx.dia_pcw.command = cmd;

/* parity on pcw (probably not necessary) */

	string (datanet_mbx.dia_pcw) = dn355_util$compute_parity (string (datanet_mbx.dia_pcw));

	ima.chx = fnp_info.io_manager_chx;
	ima.ptp = null ();
	call io_manager$connect_direct (ima);

	return;
     end /* connect_to_dia */;			/*						*/
mask_dia:
     procedure;
	call io_manager$mask (fnp_info.io_manager_chx);	/* mask the channel to initialize it */
     end mask_dia;

/*   internal_unwire:
   procedure;

   declare  px fixed bin;

   /* internal procedure to undo work of wire entry */
/*
   if fnpp = null
   then return;
   if ^fnp_info.wired
   then return;

   ioptp = fnp_info.ptp;
   if ioptp ^= null ()
   then do px = FIRST_BOOTLOAD_PAGEX to FIRST_BOOTLOAD_PAGEX + fnp_info.n_pages_wired;
   unspec (page_table.ptw (px)) = ""b;	/* as of next connect, no more references */
/*	end;

   astep = fnp_info.astep;
   call pc_abs$unwire_abs (astep, 0, fnp_info.n_pages_wired);
   call grab_aste$release_io (astep);
   fnp_info.wired = "0"b;
   return;

   end internal_unwire;    */

release_t_and_d:
     procedure;

declare  unlock_dump_seg bit (1) aligned;

	call lock$wait (addr (fnp_dump_seg.lock), fdump_seg_event, code);
						/* wait for finish */
	unlock_dump_seg = (code = 0);			/* if user held lock for other reason, leave it locked ? */
	call syserr (0, "uncp_util: force detaching FNP ^a from process ^w.", fnp_info.fnp_id.fnp_tag,
	     fnp_info.boot_process_id);
	call lock_fnp;				/* hold the LCTE lock (or the config lock) */
	fnp_info.boot_process_id = "000000000000"b3;
	fnp_info.boot_ev_chan = 0;
	fnp_info.t_and_d_in_progress = "0"b;
	fnp_info.t_and_d_lev_3_occurred, fnp_info.t_and_d_lev_7_occurred = "0"b;
	call uncp_multiplexer$unassign (fnp_no, code);
	if code ^= 0
	then call syserr$error_code (ANNOUNCE, code, "uncp_util: io channel unassignment failed for FNP ^a.",
		fnp_info.fnp_tag);
	call unlock_fnp;
	if unlock_dump_seg
	then call lock$unlock (addr (fnp_dump_seg.lock), fdump_seg_event);
	return;
     end release_t_and_d;


lock_fnp:
     procedure;

declare  code fixed bin (35);

	if locked | config_locked
	then call syserr (CRASH, "uncp_util: lock_fnp called with lock locked.");
	locked, config_locked = "0"b;

	call lock$lock_fast (addr (datanet_info.configuration_lock));
	config_locked = "1"b;			/* LCTE cannot get initialized after this point */
	if fnp_info.lcte_ptr = null ()
	then return;				/* that is the whole story */
	else if ^fnp_info.lcte_ptr -> lcte.initialized	/* no mpx in the house */
	then return;				/* and the config lock locks out T&D I/O */

	/*** here, there is a multiplexer, so we have to lock against it */

	call uncp_multiplexer$fnp_lock (fnpp, code);
	if code = 0
	then do;
	     locked = "1"b;				/* lcte was initialized, and we now own it */
	     call lock$unlock_fast (addr (datanet_info.configuration_lock));
						/* if init_multiplexer finds the LCTE initialized, it aborts */
						/* so all we are protecting against is ourselves */
	     config_locked = "0"b;
	end;
	return;

unlock_fnp:
     entry;

	if locked
	then call uncp_multiplexer$fnp_unlock (fnpp);
	locked = "0"b;
	if config_locked
	then call lock$unlock_fast (addr (datanet_info.configuration_lock));
	config_locked = "0"b;
	return;
     end lock_fnp;


STOP_CHECK:
     procedure (Tracer);
declare  Tracer char (*);

	if datanet_info.debug_stop
	then call syserr (CRASH, "uncp_util$^a: Debugging stop (type go to continue).", Tracer);
	return;
     end STOP_CHECK;


get_page_table:
     procedure (code);

declare  pagex fixed bin;
declare  px fixed bin;
declare  1 seg_pt (0:255) aligned like l68_core_ptw based (ptp);
declare  ptp pointer;
declare  code fixed bin (35);

	io_page_table_size = SIZE_256;		/* always, for datanet */
	call ioi_page_table$get (io_page_table_size * sys_info$page_size, fnp_info.ptx, code);
						/* Direct channel has no bounds check so we need all 256 */
	if code ^= 0
	then return;
	fnp_info.ptp, ioptp = ioi_page_table$ptx_to_ptp (fnp_info.ptx);

	unspec (page_table) = ""b;

/**** leave page zero invalid */

/**** First, dn355_mailbox */

	do px = LOW_MBX_PTW to HIGH_MBX_PTW;
	     io_ptwp = addr (page_table.ptw (px));
	     io_ptw.address = px;			/* absolute page number */
	     io_ptw.write = "1"b;
	     io_ptw.valid = "1"b;
	end;

/**** Now, tty_buf */

	astep = get_ptrs_$given_segno (segno (addr (tty_buf$)));
	pagex = FIRST_TTY_BUF_PAGEX;
	ptp = addwordno (astep, sst$astsize);
	do px = 0 to bin (aste.csl, 9) - 1;		/* no null pages here */
	     io_ptwp = addr (page_table.ptw (pagex));
	     io_ptw.address = seg_pt (px).frame;
	     io_ptw.write = "1"b;
	     io_ptw.valid = "1"b;
	     pagex = pagex + 1;
	end;					/* tty_buf is now described to the channel */
	return;

fill_bootload_page_table:
     entry;					/* fill in io ptws for bootload segment */

/**** astep is already set to the bootload image aste */

	pagex = FIRST_BOOTLOAD_PAGEX;
	ptp = addwordno (astep, sst$astsize);
	auto_absadr = pagex * sys_info$page_size;
	ioptp = fnp_info.ptp;

	do px = 0 to fnp_info.n_pages_wired - 1;
	     io_ptwp = addr (page_table.ptw (pagex));
	     io_ptw.address = seg_pt (px).frame;
	     io_ptw.write = "0"b;
	     io_ptw.valid = "1"b;
	     pagex = pagex + 1;
	end;

	if datanet_info.trace
	then do px = 0 to 255;
	     if unspec (page_table.ptw (px)) ^= ""b
	     then call syserr (ANNOUNCE, "uncp_util: ptw at ^4o = ^w", px, unspec (page_table.ptw (px)));
	end;

	return;

     end get_page_table;


/* format: off */

/* INCLUDE FILES */
%page; %include aste;
%page; %include config_prph_fnp_card;
%page; %include dn355_mailbox;
%page; %include mailbox_ops;
%page; %include lct;
%page; %include dn355_data;
%page; %include pcb;
%page; %include fnp_dump_seg;
%page; %include fnp_types;
%page; %include io_manager_dcls;
%page; %include io_page_tables;
%page; %include io_chnl_util_dcls;
%page; %include "ptw.l68";
       declare ptp pointer;
%page; %include syserr_constants;
%page; %include tty_buf;
%include fnp_mpx_msg_;




/* Begin message documentation invisible

   This message documentation is designated "invisible" and not in the normal
   format so it will not be assigned to the released set of message
   documentation.  This software is not to be released for customer use.

   Message:
   Loading FNP X, CORE_IMAGE VERSION

   S:  $info

   T:  Answering service initialization and each subsequent FNP
   bootload.

   M:  Loading of FNP X has begun with a core image named CORE_IMAGE
   (normally "mcs") of version number VERSION.

   A:  $ignore


   Message:
   uncp_util$wire: FNP T already wired (trace)


   Message:
   uncp_util$wire: failed. REASON (trace)


   Message:
   uncp_util$load: FNP load already in progress for FNP T.


   Message:
   uncp_util$load: FNP T not wired.


   Message:
   uncp_util$load: FNP T is running. (trace)


   Message:
   uncp_util$load: FNP T is running T&D.


   Message:
   uncp_util$load: Error loading FNP T. REASON (trace)


   Message:
   uncp_util$unwire: Unwire failed for FNP T. REASON


   Message:
   uncp_util$configure: FNP T already configured.


   Message:
   uncp_util: FNP T added to configuration^[ by NAME^].


   Message:
   FNP T deleted from configuration^[ by ^a^].


   Message:
   uncp_util$fdump_seg_io: IO_OP for CALLER (trace)


   Message:
   uncp_util: channel assignment failed for FNP ^T REASON. (tandd)


   Message:
   uncp_util: ioam_$assign failed for FNP T. REASON (tandd)


   Message:
   uncp_util: assigned FNP T to NAME for T & D.



   Message:
   uncp_util: io channel unassignment failed for FNP T. (tandd)


   Message: 
   uncp_util: releasing FNP T from NAME (tandd)


   Message:
   uncp_util$validate_assigned_ret (CALLER): IO manager assignment lacking. (trace)


   Message:
   uncp_util$ENTRY: Invalid call for FNP INDEX. (not in cdeck)


   Message:
   uncp_util$ENTRY: Tracing call for fnp T.


   Message:
   uncp_util$ENTRY: Invalid call. (trace)


   Message:
   uncp_util: Could not unassign FNP T at reassign_interrupt. 


   Message:
   uncp_util: force detaching FNP T from process PID.


   Message:
   uncp_util: io channel unassignment failed for FNP T. (tandd)


   Message:
   uncp_util: lock_fnp called with lock locked.


   Message:
   uncp_util$ENTRY: Debugging stop (type go to continue).

   End message documentation invisible */


     end uncp_util;
