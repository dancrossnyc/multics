/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

/****^  HISTORY COMMENTS:
  1) change(85-02-01,RCoren), approve(), audit(), install():
     Modified to initialize the tty_access_class structure at the tty_attach
        entry.
     Modified December 1984 by Robert Coren to implement
        "(set get)_line_status_enabled" orders.
     Modified 84-12-04 by EJ Sharpe to remove protection_audit_ calls
     Modified November 1984 by Robert Coren to use tty_area_manager entries
        for allocating and freeing TCBs.
     Modified September 1984 by Robert Coren to turn off wtcb.dialing if
        dialout fails, and to zero pad fields in output_flow_control_info
        structure for set_terminal_data order.
     Modified February 1984 by Robert Coren to correct bug in access_class
        checking.
     Modified May 1983 by Robert Coren and E. N. Kittlitz for
        required_access_class.
     Modified November 1982 by Robert Coren to report wtcb.error_code.
     Modified November 1982 by Robert Coren to reset masked bit on "unmask"
        order.
     Modified June 1982 by Robert Coren to report MASKED state and to reset
        it on listen order.
     Modified June 1981 by Benson I. Margulies for error on duplicate
        attachments.
     Modified April 1981 by Robert Coren to handle dialup time
     Modified 81 January by Art Beattie to pass along 32 character phone
        numbers.
     Modified 4 December 1980 by Robert Coren to add copy_meters order
     Modified 3/6/80 by C. Hornig to pass 9-bit phone numbers
     Modified 4/10/79 by J. Stern to remove modes handling
     Modified 3/1/79 by J. Stern to add set_wakeup_table order
     Modified 10/11/78 by J. Stern for multiplexing changes
     Modified Aug 78 by J. Nicholls to implement ring 0 demuxing, some major
        changes involved
     Modified 5/17/78 by J. Stern to implement breakall mode
     Modified 4/18/78 by Robert Coren to implement blk_xfer mode and
        (set get)_framing chars orders and to fix bug that always rned off
        fulldpx with echoplex despite explicit user request
     Modified 2/6/78 by Robert Core
  2) change(86-04-23,Coren), approve(86-04-23,MCR7300),
     audit(86-05-19,Beattie), install(86-07-08,MR12.0-1089):
     To use version 2 mcs_echo_neg structure.
  3) change(86-06-19,Kissel), approve(86-07-30,MCR7475), audit(86-08-04,Coren),
     install(86-10-09,MR12.0-1181):
     Changed to support the new tty event message format declared in
     net_event_message.incl.pl1 which replaces tty_event_message.incl.pl1.
  4) change(86-09-26,Beattie), approve(86-09-22,MCR7542),
     audit(86-10-20,Brunelle), install(86-10-21,MR12.0-1190):
     Remove references to the 963 and 029 preaccess commands and remove support
     for ARDS, 202_ETX, 2741 and 1050 in system interfaces.
  5) change(87-03-10,LJAdams), approve(87-04-03,MCR7646),
     audit(87-05-06,Gilcrease), install(87-05-14,MR12.1-1029):
     Added support for ttd_version_3 which includes the protocol field.
  6) change(87-06-17,LJAdams), approve(87-06-17,MCR7584),
     audit(87-08-06,Gilcrease), install(87-08-06,MR12.1-1063):
     Changed editing_chars_version_2 to editing_chars_version_3.
  7) change(88-08-15,Parisek), approve(88-08-15,PBF7928),
     audit(88-08-15,Farley), install(88-08-16,MR12.2-1086):
     Make call to tty_write$locked for the "read_status" control order if tty
     is attached through the DSA UNCP multiplexer.  This will subsequently set
     the wtcb.turn flag ON so the tty will not remain in a blocked for output
     state.
  8) change(88-08-19,Parisek), approve(88-08-19,PBF7928),
     audit(88-08-19,Farley), install(88-08-22,MR12.2-1087):
     Correct bug in the is_parent_mpx procedure to return "0"b if parent
     multiplexer type does not match multiplexer type being checked.
  9) change(88-09-21,Brunelle), approve(88-09-21,MCR7813),
     audit(88-10-12,Blair), install(88-10-17,MR12.2-1171):
     Add code to support SPECIAL_VERSION_2 special tables in addition to
     SPECIAL_VERSION.  These are 15 & 3 char tables respectively.  Change
     set/get_special control orders to handle the old and new lengths properly.
 10) change(88-10-20,Brunelle), approve(88-10-20,PBF7813),
     audit(88-10-21,Farley), install(88-10-22,MR12.2-1181):
     Correct problem of returning invalid ptr to  structure (it was already
     freed).  Also improve copying of old/new versions of special chars tables.
                                                   END HISTORY COMMENTS */

%page;
/* format: style4,delnl,insnl,^ifthendo */
tty_index:
     proc (a_name, twx, state, ercode);			/* go get index from name, and sign onto tty */


dcl  a_name char (*);				/* tty name such as a.h102 */
dcl  a_wtcbp ptr;
dcl  a_tcbp ptr;
dcl  a_sw bit (1);
dcl  a_order char (*);				/* order name */
dcl  a_argptr ptr;					/* pointer to order data */
dcl  a_data_base_ptr ptr;				/* pointer returned of establishing wtcb */
dcl  a_event fixed bin (71);				/* event channel name */

dcl  twx fixed bin;					/* tty index (actually also device index ) */
dcl  state fixed bin;				/* tty state, 1 ignored, 2 listening, 5 dialed */
dcl  ercode fixed bin (35);				/* error code */
dcl  dflag fixed bin;				/* disposition flag */
dcl  nproc bit (36);				/* new proc process */
dcl  resetsw fixed;					/* abort code, 1 reset read, 2 reset write, 3 reset both */
dcl  name char (32);
dcl  event fixed bin (71);
dcl  order char (32);
dcl  argptr ptr;
dcl  special_ptr ptr;
dcl  esw fixed bin;
dcl  cleanup condition;
dcl  (i, j) fixed bin;
dcl  devx fixed bin (17);
dcl  (sw, rawom) bit (1) aligned;
dcl  rw_switch bit (2) aligned;			/* bit-string version of reset_read/write switch */
dcl  code fixed bin (35);
dcl  temp_ptr ptr;
dcl  table_type fixed bin;
dcl  locked bit (1) init ("0"b);
dcl  sus_count fixed bin;				/* automatic copy of output_suspend count */
dcl  res_count fixed bin;				/* likewise for resume */
dcl  uproc_attach_required_for_setup bit (1) init ("1"b);
dcl  uproc_required_for_setup bit (1) init ("1"b);
dcl  phone_data varying char (32);
dcl  aim_attributes_string char (32);
dcl  user_auth_string char (32);
dcl  echo_version_1 bit (1);
dcl  old_special_table_version bit (1);

	/*** REMOVE when Emacs, video and mowse are using version 2. ***/

dcl  1 new_waketab aligned like wakeup_table;
dcl  1 old_waketab aligned like wakeup_table;
dcl  1 sfc aligned like framing_chars;
dcl  1 auto_ifc aligned like input_flow_control_info;
dcl  1 auto_ofc aligned like output_flow_control_info;
dcl  1 l_tty_access_class aligned like tty_access_class;
dcl  1 auto_mode aligned,
       2 len fixed bin,
       2 str char (8);

dcl  ever_initialized bit (1) int static init ("0"b);	/* indicates whether init_channel ever called before */

dcl  (
     input_tr_type init (1),				/* input translation table type */
     output_tr_type init (2),				/* output translation table type */
     input_cv_type init (3),				/* input conversion table type */
     output_cv_type init (4),				/* output conversion table type */
     special_type init (5),				/* special chars table type */
     delay_type init (6)
     ) fixed bin int static options (constant);		/* delay table type */

dcl  max_special_size fixed bin int static options (constant) init (600);
						/* max special words table size in words */


dcl  IGNORE fixed bin int static options (constant) init (1);
dcl  LISTENING fixed bin int static options (constant) init (2);
dcl  DIALED_UP fixed bin int static options (constant) init (5);
dcl  MASKED_STATE fixed bin int static options (constant) init (-1);
dcl  NUL char (1) int static options (constant) init (" "); /* NUL character (\000) */

dcl  white_space char (6) int static options (constant) initial
						/* BS, CR, NL, HT, VT, FF */
	("
	");

dcl  (
     error_table_$resource_attached,
     error_table_$io_no_permission,
     error_table_$unimplemented_version,
     error_table_$device_not_usable,
     error_table_$no_connection,
     error_table_$no_operation,
     error_table_$null_info_ptr,
     error_table_$invalid_state,
     error_table_$invalid_device,
     error_table_$smallarg,
     error_table_$action_not_performed,
     error_table_$buffer_big,
     error_table_$bigarg,
     error_table_$request_pending,
     error_table_$no_wired_structure,
     error_table_$inconsistent,
     error_table_$no_table,
     error_table_$notalloc,
     error_table_$no_line_status,
     error_table_$improper_data_format,
     error_table_$line_status_pending,
     error_table_$masked_channel,
     error_table_$invalid_delay_value,
     error_table_$undefined_order_request,
     error_table_$invalid_array_size
     ) ext fixed bin (35);
dcl  pds$processid ext static bit (36);
dcl  pds$process_group_id ext static char (32) aligned;
dcl  tc_data$initializer_id ext bit (36) aligned;

dcl  1 pds$access_authorization aligned like aim_template ext static;

dcl  aim_check_$equal entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
dcl  compare_tty_name_ entry (char (*), char (*)) returns (bit (1));
dcl  display_access_class_ entry (bit (72) aligned, char (32));
dcl  pxss$ring_0_wakeup entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin);
dcl  syserr entry options (variable);
dcl  tty_area_manager$allocate entry (fixed bin, ptr);
dcl  tty_area_manager$free entry (fixed bin, ptr);
dcl  tty_interrupt$set_static entry;
dcl  tty_lock$lock_channel entry (fixed bin, fixed bin (35));
dcl  tty_lock$unlock_channel entry (fixed bin);
dcl  tty_tables_mgr$add entry (ptr, fixed bin, fixed bin, bit (18), fixed bin (35));
dcl  tty_tables_mgr$delete entry (bit (18), fixed bin (35));
dcl  tty_modes entry (ptr, ptr, fixed bin (35));
dcl  tty_modes$mpx_only entry (ptr, ptr, fixed bin (35));
dcl  tty_write$locked entry (fixed bin, ptr, fixed bin, fixed bin, fixed bin, fixed bin, fixed bin (35));

dcl  ll fixed bin (9) based (argptr);			/* for line length order */

dcl  new_line_type fixed bin based (argptr);		/* for set_line_type order */

dcl  1 info based (argptr) aligned,			/* tty information structure */
       2 id char (4) unaligned,			/* id of tty */
       2 baud_rate fixed bin (17) unal,			/* baud rate */
       2 line_type fixed bin (17) unal,			/* line type for line control */
       2 pad bit (36) unal,				/* fill */
       2 tw_type fixed;				/* type of tty (t300) */

dcl  arg_varying_char32 varying char (32) based (argptr);

dcl  1 rd_stat aligned based (argptr),			/* structure fo read_status call */
       2 ev_chan fixed bin (71),
       2 input_available bit (1);

dcl  1 wr_stat aligned based (argptr),			/* structure for write_status call */
       2 ev_chan fixed bin (71),
       2 output_pending bit (1);

dcl  bit72 bit (72) based;				/* for command data */
dcl  bit1 bit (1) based;

dcl  inid char (4) based;
dcl  based_arg fixed bin based;

dcl  1 editing_chars aligned based (argptr),
       2 version fixed bin,
       2 chars char (2) unaligned;

dcl  1 framing_chars aligned based (argptr),
       2 frame_begin char (1) unal,
       2 frame_end char (1) unal;

dcl  1 get_special_info aligned based (argptr),
       2 version char (8),
       2 area_ptr ptr,
       2 table_ptr ptr;

dcl  1 get_special_info_old aligned based (argptr),
       2 area_ptr ptr,
       2 table_ptr ptr;

dcl  two_chars char (2) based;
dcl  special_area area based;

dcl  tablerp (6) bit (18) unal based (trpp);		/* overlay for tcb.tables */
dcl  df_tablerp (6) bit (18) unal based (dftrpp);		/* overlay for tcb.default_tables */
dcl  new_tablerp (6) bit (18) unal;
dcl  new_tablep (6) ptr based (ntpp);			/* overlay for terminal_type_data.tables */
dcl  (trpp, dftrpp, ntpp) ptr;

dcl  (area, storage) condition;

dcl  (addr, abs, bit, clock, divide, fixed, length, low, max, min, null, ptr, rel, search, size, string, substr, unspec)
	builtin;
%page;

/* special chars structures to support old/new versions */
dcl  special_chars_old_ptr ptr;
dcl  1 special_chars_old aligned based (special_chars_old_ptr),
						/* table of special character sequences */
       2 nl_seq aligned like c_chars_old,		/* new-line sequence */
       2 cr_seq aligned like c_chars_old,		/* carriage-return sequence */
       2 bs_seq aligned like c_chars_old,		/* backspace sequence */
       2 tab_seq aligned like c_chars_old,		/* horizontal tab sequence */
       2 vt_seq aligned like c_chars_old,		/* vertical tab sequence */
       2 ff_seq aligned like c_chars_old,		/* form-feed sequence */
       2 printer_on aligned like c_chars_old,		/* printer-on sequence */
       2 printer_off aligned like c_chars_old,		/* printer_off sequence */
       2 red_ribbon_shift aligned like c_chars_old,	/* red ribbon shift sequence */
       2 black_ribbon_shift aligned like c_chars_old,	/* black ribbon shift sequence */
       2 end_of_page aligned like c_chars_old,		/* end-of-page warning sequence */
       2 escape_length fixed bin,			/* number of escape sequences */
       2 not_edited_escapes (sc_escape_len refer (special_chars_old.escape_length)) like c_chars_old,
						/* use in ^edited mode */
       2 edited_escapes (sc_escape_len refer (special_chars_old.escape_length)) like c_chars_old,
						/* use in edited mode */
       2 input_escapes aligned,
         3 len fixed bin (8) unaligned,			/* length of string */
         3 str char (sc_input_escape_len refer (special_chars_old.input_escapes.len)) unaligned,
						/* escape sequence characters */
       2 input_results aligned,
         3 pad bit (9) unaligned,			/* so that strings will look the same */
         3 str char (sc_input_escape_len refer (special_chars_old.input_escapes.len)) unaligned;
						/* results of escape sequences */
dcl  1 c_chars_old based (c_chars_ptr) aligned,
       2 count fixed bin (8) unaligned,
       2 chars (3) char (1) unaligned;

dcl  1 special_chars_struc_old aligned based,
       2 version fixed bin,
       2 default fixed bin,				/* non-zero indicates use default */
       2 special_chars,				/* same as level-1 above */
						/* has to be spelled out instead of using like */
						/* because of refer options */
         3 nl_seq aligned like c_chars_old,		/* new-line sequence */
         3 cr_seq aligned like c_chars_old,		/* carriage-return sequence */
         3 bs_seq aligned like c_chars_old,		/* backspace sequence */
         3 tab_seq aligned like c_chars_old,		/* horizontal tab sequence */
         3 vt_seq aligned like c_chars_old,		/* vertical tab sequence */
         3 ff_seq aligned like c_chars_old,		/* form-feed sequence */
         3 printer_on aligned like c_chars_old,		/* printer-on sequence */
         3 printer_off aligned like c_chars_old,		/* printer_off sequence */
         3 red_ribbon_shift aligned like c_chars_old,	/* red ribbon shift sequence */
         3 black_ribbon_shift aligned like c_chars_old,	/* black ribbon shift sequence */
         3 end_of_page aligned like c_chars_old,		/* end-of-page warning sequence */
         3 escape_length fixed bin,			/* number of escape sequences */
         3 not_edited_escapes (sc_escape_len refer (special_chars_struc_old.escape_length)) like c_chars_old,
						/* use in ^edited mode */
         3 edited_escapes (sc_escape_len refer (special_chars_struc_old.escape_length)) like c_chars_old,
						/* use in edited mode */
         3 input_escapes aligned,
	 4 len fixed bin (8) unaligned,		/* length of string */
	 4 str char (sc_input_escape_len refer (special_chars_struc_old.input_escapes.len)) unaligned,
						/* escape sequence characters */
         3 input_results aligned,
	 4 pad bit (9) unaligned,			/* so that strings will look the same */
	 4 str char (sc_input_escape_len refer (special_chars_struc_old.input_escapes.len)) unaligned;
						/* results of escape sequences */
%page;

	esw = 0;					/* this is index entry */
	ttybp = addr (tty_buf$);			/* get ptrs to tty_buf, tty_data */
	lctp = tty_buf.lct_ptr;			/* get system pointer to lct */
	name = a_name;
	twx, state = 0;				/* init to no information passing state */
	call get_devx (name);
	if ercode ^= 0
	then return;
	tty_access_class_ptr = addr (l_tty_access_class);
	unspec (tty_access_class) = ""b;
	go to attach;

tty_attach:
     entry (a_name, a_event, twx, state, ercode);		/* index + event */
	event = a_event;
	esw = 1;					/* attach entry */
	ttybp = addr (tty_buf$);			/* get ptrs to tty_buf, tty_data */
	lctp = tty_buf.lct_ptr;			/* get system pointer to lct */
	name = a_name;
	twx, state = 0;				/* init to no information passing state */
	call get_devx (name);
	if ercode ^= 0
	then return;
	tty_access_class_ptr = addr (l_tty_access_class);
	unspec (tty_access_class) = ""b;		/* in case the order doesn't do anything */
	call tty_order (devx, "get_required_access_class", tty_access_class_ptr, (0), ercode);
	if ercode ^= 0 & ercode ^= error_table_$undefined_order_request
	then return;

attach:
	on cleanup call cleaner;
	call tty_lock$lock_channel (devx, ercode);	/* lock the channel */
	if ercode ^= 0
	then return;
	locked = "1"b;

	lctep = addr (lct.lcte_array (devx));		/* get entry of interest */
	if lcte.channel_type ^= 0			/* has to be tty channel */
	then go to index_invalid;

	wtcbp = lcte.data_base_ptr;			/* pointer to perm per channel data */
	tcbp = wtcb.tcb_ptr;			/* get tcb pointer */
	if ^wtcb.tcb_initialized
	then call init_tcb;

	if wtcb.hproc = "0"b
	then do;					/* if up for grabs, let him have it */
	     if pds$processid ^= tc_data$initializer_id
	     then go to index_invalid;
	     wtcb.hproc = pds$processid;
	end;
	else if wtcb.hproc = pds$processid		/* if he is already boss */
	then ;					/* then he is ok */
	else if wtcb.flags.dialed			/* else if channel is dialed (has user) */
	then if wtcb.uproc = pds$processid		/* and this guy is the user */
	     then if (esw = 1) & tcb.uproc_attached	/* ATTACH & already called ATTACH */
						/* only allow one call to tty_attach */
		then do;
		     ercode = error_table_$resource_attached;
		     call tty_lock$unlock_channel (devx);
		     return;
		end;
		else do;				/* tty_index can be called as many times on a channel name as desired */
		     if ^tcb.uproc_attached
		     then do;			/* this is first attach */
			if tty_access_class.access_class_set
			then if ^aim_check_$equal (unspec (pds$access_authorization), tty_access_class.access_class)
			     then do;
				if ^pds$access_authorization.privileges.comm
				then do;		/* this shouldn't happen unless the process responsible
						   for channel assignments has failed or the user
						   process has reset comm privilege since the assignment */
				     call display_access_class_ (unspec (pds$access_authorization),
					user_auth_string);
				     call display_access_class_ (tty_access_class.access_class,
					aim_attributes_string);
				     call syserr (ANNOUNCE,
					"tty_attach: ^a (^a) attempted invalid attachment of ^a (^a)",
					pds$process_group_id, user_auth_string, name, aim_attributes_string);
				     go to index_invalid;
				end;		/* no AIM privilege */
			     end;			/* channel auth differs from process auth */
		     end;				/* first attach */
		end;				/* tty_index or first attach */
	     else go to index_invalid;		/* else he is not user, and cant do anything */
	else do;					/* else channel not dialed up, and not boss */
index_invalid:
	     ercode = error_table_$io_no_permission;	/* give him error code */
	     call tty_lock$unlock_channel (devx);	/* unlock channel now */
	     return;				/* thats all we let him do */
	end;
	if wtcb.flags.dialed			/* compute state */
	then state = DIALED_UP;			/* dialed up */
	else if wtcb.flags.masked			/* masked by FNP */
	then state = MASKED_STATE;
	else if wtcb.flags.listen
	then state = LISTENING;			/* listening for ring */
	else state = IGNORE;			/* ignoreing */

	ercode = 0;
	twx = devx;				/* return tty index */

	if wtcb.flags.dialed
	then do;					/* if dialed */
	     wtcb.uproc = pds$processid;		/* he is using process */
	     tcb.uproc_attached = "1"b;
	end;

	wtcb.qflag, wtcb.qenable = "0"b;		/* but he may not expect quits */
	wtcb.dialing, wtcb.dial_status_valid = ""b;	/* not dialing, no dial status */
	wtcb.dial_status_code = 0;
	if esw = 1
	then go to eret;				/* must also record event */
	call tty_lock$unlock_channel (devx);		/* unlock the channel */

	return;
%page;
tty_event:
     entry (twx, a_event, state, ercode);		/* to change tty events signaled */

	event = a_event;
	state = 0;

	on cleanup call cleaner;
	call setup (state);				/* set up normal variables and check access */
	if ercode ^= 0
	then return;

	if wtcb.flags.dialed
	then wtcb.uproc = pds$processid;		/* this guy gets to use it */

eret:
	wtcb.event = event;				/* copy as user event channel */
	if wtcb.hproc = pds$processid
	then					/* and if this guy is the boss */
	     wtcb.hevent = event;			/* copy as boss event too */

	call tty_lock$unlock_channel (devx);		/* unlock the channel */

	return;
%page;
tty_get_name:
     entry (twx, a_name, state, ercode);		/* to return channel name given devx */

	devx = twx;
	uproc_required_for_setup = "0"b;
	call setup (state);
	if ercode ^= 0
	then return;

	lcntp = lct.lcnt_ptr;
	a_name = lcnt.names (devx);
	call tty_lock$unlock_channel (devx);
	return;
%page;
init_channel:
     entry (twx, a_argptr, a_data_base_ptr, ercode);

	devx = twx;				/* move to internal */
	argptr = a_argptr;
	a_data_base_ptr = null;
	ercode = 0;

	if ^ever_initialized
	then do;
	     call tty_interrupt$set_static;		/* to copy error codes into wired internal static */
	     ever_initialized = "1"b;			/* so we don't do this again */
	end;

	call tty_space_man$get_space (size (wtcb), wtcbp);

	if wtcbp = null
	then do;					/* no room for it? */
	     ercode = error_table_$notalloc;
	     return;
	end;

	on area go to tcb_not_done;
	on storage go to tcb_not_done;
	call tty_area_manager$allocate (size (tcb), tcbp);
	revert area;
	revert storage;

	unspec (wtcb) = "0"b;			/* start in known state */
	wtcb.tcb_ptr = tcbp;			/* set the data base correctly */
	wtcb.devx = devx;
	unspec (tcb) = "0"b;			/* start this in known state also */
	call init_tcb;				/* start filling in the variables */
	a_data_base_ptr = wtcbp;			/* and the output arg */
	return;

tcb_not_done:
	ercode = error_table_$notalloc;		/* we had a problem */
	return;
%page;
terminate_channel:
     entry (a_data_base_ptr, ercode);

	ercode = 0;
	wtcbp = a_data_base_ptr;			/* get to internal */
	tcbp = wtcb.tcb_ptr;

	call init_tcb_tables;
	call tty_area_manager$free (size (tcb), tcbp);	/* clean out the tcb */

	call tty_space_man$free_space (size (wtcb), wtcbp);
						/* and get rid of wtcb */
	if wtcbp ^= null
	then do;					/* wtcb still around for some reason? */
	     ercode = error_table_$action_not_performed;
	     return;
	end;

	return;
%page;
tty_abort:
     entry (twx, resetsw, state, ercode);		/* to reset read or write buffers */

	state = 0;

	on cleanup call cleaner;
	call setup (state);				/* do setup */
	if ercode ^= 0
	then return;
	if wtcb.flags.dialed			/* if any buffers to reset */
	then do;
	     rw_switch = bit (fixed (resetsw, 2));	/* first bit is resetwrite, 2nd is -read */
	     if substr (rw_switch, 1, 1)		/* asking for resetwrite */
	     then do;
		if wtcb.write_first ^= 0
		then do;
		     call tty_space_man$free_chain (devx, OUTPUT, ptr (ttybp, wtcb.write_first));
		     wtcb.write_first, wtcb.write_last = 0;
		end;
		if wtcb.end_frame			/* if at end of page, reset */
		then do;
		     wtcb.actline = 0;
		     wtcb.end_frame = "0"b;
		end;

	     end;
	     if substr (rw_switch, 2, 1)		/* if read buffer to be reset */
	     then do;
		if wtcb.fblock ^= 0			/* if a chain there */
		then do;
		     call tty_space_man$free_chain (devx, INPUT, ptr (ttybp, wtcb.fblock));
		     wtcb.nramsgs = 0;
		     wtcb.fblock, wtcb.lblock = 0;	/* no more input chain */
		end;				/* tell the 355 not to send current input */
		wtcb.fchar = 0;
	     end;

	     call channel_manager$control (devx, "abort", addr (rw_switch), code);
	     if code ^= 0
	     then if code = error_table_$undefined_order_request
		then code = 0;
	     ercode = code;				/* and stop any current writes */
	end;

	call tty_lock$unlock_channel (devx);		/* unlock the channel */

	return;
%page;
tty_state:
     entry (twx, state, ercode);			/* go get state of tty */

	state = 0;

	on cleanup call cleaner;
	call setup (state);				/* get normal variables */
	call tty_lock$unlock_channel (devx);		/* unlock the channel */

	return;
%page;
tty_detach:
     entry (twx, dflag, state, ercode);			/* to detach tty */

dcl  pflag bit (1);					/* which entry switch */

	pflag = "0"b;				/* not new proc call */
	go to detcom;

new_proc:
     entry (twx, nproc, state, ercode);			/* to switch tty to new process */

	pflag = "1"b;

detcom:
	state = 0;
	on cleanup call cleaner;
	call setup (state);				/* set up */
	if ercode ^= 0
	then return;

	if pflag					/* if new process call */
	then do;
	     if wtcb.hproc = pds$processid		/* if initializer wants */
	     then do;
		wtcb.event = 0;			/* so as not to send wakeup on bogus event channel */
		wtcb.uproc = nproc;
		tcb.uproc_attached = "0"b;
	     end;
	     else go to illdet;			/* everybody to stay in assigned seat */
	end;
	else if dflag = 0				/* check disposition */
	then do;
	     if wtcb.flags.dialed			/* if a control block */
	     then do;
		if wtcb.hproc = pds$processid		/* .. and if this is the boss */
		then wtcb.uproc = "0"b;		/* place tty up for grabs */
		tcb.uproc_attached = "0"b;		/* always mark as detached */
	     end;
	end;
	else if wtcb.hproc = pds$processid		/* if boss process */
	then do;
	     wtcb.flags.listen = "0"b;		/* shut off channel */
	     call channel_manager$control (devx, "hangup", null, ercode);
	     wtcb.hproc = "0"b;			/* advertise tty looking for new boss */
	     state = IGNORE;
	end;
	else go to illdet;				/* some evil disposition and not boss */

	if wtcb.flags.dialed
	then wtcb.flags.wflag, wtcb.flags.rflag = "0"b;	/* force wakeups */

	call tty_lock$unlock_channel (devx);		/* unlock the channel */

	return;
%page;

tty_order:
     entry (twx, a_order, a_argptr, state, ercode);	/* to give tty orders */


	order = a_order;
	argptr = a_argptr;

	ttytp = addr (tty_tables$);

	on cleanup call cleaner;
	if order = "get_meters"			/* let anyone do this */
	then uproc_required_for_setup = "0"b;		/* it's initialized to "1"b */
	else if order = "get_required_access_class"
	then					/* let user do this before attach */
	     uproc_attach_required_for_setup = "0"b;

	call setup (state);				/* set up */
	if ercode ^= 0
	then return;

	if wtcb.masked				/* can't do most things to a masked channel */
	then if order ^= "unmask" & order ^= "get_meters" & order ^= "copy_meters"
	     then do;
		ercode = error_table_$masked_channel;
		go to unlock;
	     end;

	if order = "modes"
	then call tty_modes (wtcbp, argptr, ercode);

	else if order = "listen"			/* listen for dialup */
	then do;
	     call forward_order ();
	     wtcb.flags.listen = "1"b;
	     if wtcb.flags.dialed			/* get state */
	     then state = DIALED_UP;
	     else state = LISTENING;
	end;

	else if order = "copy_meters"
	then do;
	     if wtcb.hproc ^= pds$processid
	     then do;				/* only owner can do this */
		ercode = error_table_$io_no_permission;
		go to unlock;
	     end;

	     tcb.saved_meters = tcb.cumulative_meters;
	     tcb.time_dialed = clock ();
	     call forward_order ();
	end;

	else if order = "line_length"			/* set line length */
	then do;
	     if ^wtcb.flags.dialed			/* if data base exists */
	     then go to error;
	     tcb.colmax = ll;
	end;

	else if order = "terminal_info"
	then do;
	     terminal_info_ptr = argptr;
	     if terminal_info.version ^= terminal_info_version
	     then go to wrong_version;
	     if ^wtcb.flags.dialed
	     then terminal_info.id = "";
	     else terminal_info.id = tcb.id;
	     terminal_info.term_type = tcb.terminal_type;
	     terminal_info.line_type = wtcb.line_type;
	     terminal_info.baud_rate = wtcb.baud_rate;
	end;

	else if order = "info"			/* get baud rate, id and type */
	then do;
	     argptr -> info.baud_rate = wtcb.baud_rate;	/* fill in baud rate */
	     argptr -> info.line_type = wtcb.line_type;
	     if ^wtcb.flags.dialed			/* if data not there */
	     then do;
		argptr -> info.id = " ";		/* fake it */
		argptr -> info.tw_type = 0;
	     end;
	     else do;
		argptr -> info.id = tcb.id;		/* pull info from data base */
		argptr -> info.tw_type = tcb.old_type;
	     end;
	end;

	else if order = "quit_enable"			/* turn on quits? */
	then wtcb.qenable = "1"b;

	else if order = "quit_disable"		/* turn off quits? */
	then wtcb.qenable = "0"b;

	else if order = "start"			/* kick user? */
	then do;
	     if ^wtcb.flags.dialed
	     then go to error;
	     unspec (net_event_message) = "0"b;
	     net_event_message.version = NET_EVENT_MESSAGE_VERSION_1;
	     net_event_message.network_type = MCS_NETWORK_TYPE;
	     net_event_message.handle = devx;
	     net_event_message.type = MCS_UNSPECIFIED_MSG;
	     call pxss$ring_0_wakeup (wtcb.uproc, wtcb.event, net_event_message_arg, 0);
						/* wakeup the user */
	end;
%page;
	else if order = "read_status"
	then do;					/* look to see if we have any */
	     if ^wtcb.flags.dialed
	     then go to error;

	     if wtcb.flags.line_status_present
	     then do;				/* must complain about unprocessed status */
		ercode = error_table_$line_status_pending;
		go to unlock;
	     end;

	     if wtcb.error_code ^= 0
	     then do;
		ercode = wtcb.error_code;
		wtcb.error_code = 0;
		go to unlock;
	     end;

	     if wtcb.input_available | wtcb.fblock ^= 0
	     then rd_stat.input_available = "1"b;
	     else do;
		rd_stat.input_available = "0"b;
		if ^wtcb.flags.rflag & (wtcb.prompt_len > 0 | is_parent_mpx (UNCP_MPX))
		then do;				/* UNCP needs this to turn line around */
		     rawom = tcb.rawom;
		     tcb.rawom = "1"b;		/* write prompt in rawo mode */
		     call tty_write$locked (devx, addr (wtcb.prompt), 0, (wtcb.prompt_len), 0, 0, code);
		     tcb.rawom = rawom;
		end;
		wtcb.flags.rflag = "1"b;
	     end;
	end;

	else if order = "write_status"
	then do;					/* check for pending output */
	     if ^wtcb.flags.dialed
	     then go to error;
	     if wtcb.flags.line_status_present
	     then do;				/* must complain about unprocessed status */
		ercode = error_table_$line_status_pending;
		go to unlock;
	     end;

	     if wtcb.error_code ^= 0
	     then do;
		ercode = wtcb.error_code;
		wtcb.error_code = 0;
		go to unlock;
	     end;

	     code = 0;
	     if wtcb.write_first ^= 0
	     then wr_stat.output_pending = "1"b;
	     else do;
		call channel_manager$control (devx, "write_status", argptr, code);
		if code ^= 0
		then if code = error_table_$undefined_order_request
						/* multiplexer is ignorant of this */
		     then do;
			code = 0;
			wr_stat.output_pending = "0"b;
		     end;
		ercode = code;
	     end;

	     if code = 0
	     then if wr_stat.output_pending
		then wtcb.flags.wflag = "1"b;		/* get wakeup when it is gone */
	end;


	else if order = "refuse_printer_off"
	then tcb.no_printer_off = "1"b;

	else if order = "accept_printer_off"
	then tcb.no_printer_off = "0"b;

	else if order = "printer_off"			/* turn printer off */
	then do;
	     if ^wtcb.flags.dialed
	     then go to error;

	     if tcb.modes.echoplex
	     then call alter_mode ("echoplex", "0"b);	/* stop echoing to stop printing */
	     else call turn_printer_off (ercode);

	     if ercode = 0
	     then if tcb.modes.replay			/* don't want any replay while printing disabled */
		then call alter_mode ("replay", "0"b);
	end;

	else if order = "printer_on"			/* turn printer on */
	then do;
	     if ^wtcb.flags.dialed
	     then go to error;

	     if tcb.modes.echoplex
	     then call alter_mode ("echoplex", "1"b);
	     else call turn_printer_on (ercode);

	     if ercode = 0
	     then if tcb.replay			/* must reactivate this mode */
		then call alter_mode ("replay", "1"b);
	end;

	else if order = "set_terminal_data"
	then do;
	     ttdp = argptr;				/* set ptr to terminal_type_data info structure */
	     if terminal_type_data.version > ttd_version_3 | terminal_type_data.version <= 0
	     then go to wrong_version;

	     new_tablerp (*) = (18)"1"b;		/* init new table rel ptrs */
	     ntpp = addr (terminal_type_data.tables);	/* set ptr to new_tablep array */
	     code = 0;
	     do table_type = 1 to 6 while (code = 0);	/* add the new tables */
		call add_table (table_type, new_tablep (table_type), new_tablerp (table_type), code);
	     end;

	     if code ^= 0				/* could not add all the new tables */
	     then do;				/* must delete any we did add */
		do table_type = 1 to 6 while (new_tablerp (table_type) ^= (18)"1"b);
		     if new_tablerp (table_type) ^= ""b /* a real table was added */
		     then call tty_tables_mgr$delete (new_tablerp (table_type), 0);
		end;
		ercode = code;			/* give user the bad news */
		go to unlock;
	     end;

	     trpp = addr (tcb.tables);		/* set ptr to tablerp array */
	     dftrpp = addr (tcb.default_tables);	/* set ptr to df_tablerp array */
	     do table_type = 1 to 6;			/* now assign the new tables in the tcb */
		if tablerp (table_type) ^= ""b	/* dispose of any previous tables */
		then call tty_tables_mgr$delete (tablerp (table_type), 0);
		if df_tablerp (table_type) ^= (18)"1"b & df_tablerp (table_type) ^= ""b
		then call tty_tables_mgr$delete (df_tablerp (table_type), 0);
		tablerp (table_type) = new_tablerp (table_type);
						/* set the current table */
		df_tablerp (table_type) = (18)"1"b;	/* default table is same as current table */
	     end;

	     if tcb.modes.echoplex | tcb.modes.echo_cr | tcb.modes.echo_lf
	     then call send_delay_table;

	     tcb.old_type = terminal_type_data.old_type;
	     tcb.terminal_type = terminal_type_data.name;
	     tcb.erase = terminal_type_data.erase;
	     tcb.kill = terminal_type_data.kill;

	     tcb.frame_begin = terminal_type_data.frame_begin;
	     tcb.frame_end = terminal_type_data.frame_end;
	     if tcb.frame_end ^= NUL
	     then do;				/* ship framing chars to FNP */
		sfc.frame_begin = tcb.frame_begin;
		sfc.frame_end = tcb.frame_end;
		call channel_manager$control (devx, "set_framing_chars", addr (sfc), ercode);
	     end;

	     if terminal_type_data.line_delimiter ^= low (1)
	     then wtcb.line_delimiter = terminal_type_data.line_delimiter;
	     sw = terminal_type_data.keyboard_locking;
	     if sw ^= tcb.keyboard_locking		/* change to keyboard locking */
	     then if sw & wtcb.line_type ^= LINE_ASCII
		then ;				/* invalid change, ignore it */
		else do;				/* make the change */
		     tcb.keyboard_locking = sw;
		     if ^(tcb.modes.full_duplex | tcb.modes.echoplex)
						/* keyboard locking possible */
		     then call channel_manager$control (devx, "lock", addr (sw), ercode);
						/* pass it on down */
		end;

	     if terminal_type_data.version >= ttd_version_2
						/* version 2 includes flow control */
	     then do;
		if terminal_type_data.input_resume ^= NUL
		then do;
		     tcb.input_resume_seq.count = 1;
		     substr (tcb.input_resume_seq.chars, 1, 1) = terminal_type_data.input_resume;
		     if terminal_type_data.input_suspend = NUL
		     then tcb.input_suspend_seq.count = 0;
		     else do;
			tcb.input_suspend_seq.count = 1;
			substr (tcb.input_suspend_seq.chars, 1, 1) = terminal_type_data.input_suspend;
		     end;

		     unspec (auto_ifc.suspend_seq) = unspec (tcb.input_suspend_seq);
		     unspec (auto_ifc.resume_seq) = unspec (tcb.input_resume_seq);
		     auto_ifc.timeout = terminal_type_data.input_timeout;
		     call channel_manager$control (devx, "input_flow_control_chars", addr (auto_ifc), ercode);
		end;

		else if tcb.input_resume_seq.count ^= 0 /* used to have one */
		then do;				/* must turn it off now */
		     tcb.input_suspend_seq.count = 0;
		     tcb.input_resume_seq.count = 0;
		     auto_ifc.suspend_seq.count = 0;
		     auto_ifc.resume_seq.count = 0;
		     call channel_manager$control (devx, "input_flow_control_chars", addr (auto_ifc), ercode);
		end;

		if terminal_type_data.output_resume_ack ^= NUL
		then do;
		     tcb.output_suspend_etb_seq.count = 1;
		     tcb.output_resume_ack_seq.count = 1;
		     substr (tcb.output_suspend_etb_seq.chars, 1, 1) = terminal_type_data.output_suspend_etb;
		     substr (tcb.output_resume_ack_seq.chars, 1, 1) = terminal_type_data.output_resume_ack;

		     unspec (auto_ofc.suspend_or_etb_seq) = unspec (tcb.output_suspend_etb_seq);
		     unspec (auto_ofc.resume_or_ack_seq) = unspec (tcb.output_resume_ack_seq);
		     tcb.block_acknowledge, auto_ofc.block_acknowledge = terminal_type_data.output_block_acknowledge;
		     auto_ofc.suspend_resume = ^terminal_type_data.output_block_acknowledge;
		     auto_ofc.mbz = ""b;
		     auto_ofc.buffer_size = terminal_type_data.output_buffer_size;
		     tcb.max_output_block = divide (terminal_type_data.output_buffer_size, 2, 18, 0);
		     call channel_manager$control (devx, "output_flow_control_chars", addr (auto_ofc), ercode);
		end;

		else if tcb.output_resume_ack_seq.count ^= 0 | tcb.max_output_block ^= 0
		then do;				/* something to turn off */
		     tcb.output_suspend_etb_seq.count = 0;
		     tcb.output_resume_ack_seq.count = 0;
		     tcb.max_output_block = 0;
		     tcb.block_acknowledge = "0"b;

		     if tcb.oflow			/* force it off */
		     then do;
			auto_mode.len = 6;
			auto_mode.str = "^oflow";
			call tty_modes (wtcbp, addr (auto_mode), (0));
		     end;

		     auto_ofc.block_acknowledge = "0"b;
		     auto_ofc.suspend_resume = "0"b;
		     auto_ofc.mbz = ""b;
		     auto_ofc.buffer_size = 0;
		     auto_ofc.suspend_or_etb_seq.count = 0;
		     auto_ofc.resume_or_ack_seq.count = 0;
		     call channel_manager$control (devx, "output_flow_control_chars", addr (auto_ofc), ercode);
		end;
	     end;
	end;

	else if order = "store_id"			/* store answerback id for later use */
	then do;
	     if ^wtcb.flags.dialed
	     then go to error;
	     tcb.id = argptr -> inid;
	end;

	else if order = "wru"
	then if pds$processid = wtcb.hproc
	     then do;
		if ^wtcb.flags.dialed
		then go to error;

		if wtcb.flags.line_status_present
		then do;				/* must complain about unprocessed status */
		     ercode = error_table_$line_status_pending;
		     go to unlock;
		end;

		if wtcb.error_code ^= 0
		then do;
		     ercode = wtcb.error_code;
		     wtcb.error_code = 0;
		     go to unlock;
		end;

		call forward_order ();
		wtcb.flags.wru, wtcb.flags.rflag = "1"b;
	     end;
	     else go to error;

	else if order = "interrupt"
	then if wtcb.line_type = LINE_ASCII
	     then do;
		if ^wtcb.flags.dialed
		then go to error;

		if wtcb.flags.line_status_present
		then do;				/* must complain about unprocessed status */
		     ercode = error_table_$line_status_pending;
		     go to unlock;
		end;

		if wtcb.error_code ^= 0
		then do;
		     ercode = wtcb.error_code;
		     wtcb.error_code = 0;
		     go to unlock;
		end;

		call forward_order ();
	     end;
	     else go to error;

	else if order = "set_input_message_size"
	then do;
	     if ^wtcb.sync_line
	     then go to error;

	     if argptr -> based_arg > 2048
	     then do;				/* can't set message size > exhaust limit */
		ercode = error_table_$buffer_big;
		go to unlock;
	     end;

	     call forward_order ();
	     tcb.input_msg_size = argptr -> based_arg;
	end;

	else if order = "get_input_message_size"
	then do;
	     if ^wtcb.sync_line
	     then go to error;
	     argptr -> based_arg = tcb.input_msg_size;

	end;

	else if order = "start_xmit_hd"
	then do;
	     if wtcb.line_type ^= LINE_ARDS
	     then go to error;

	     call forward_order ();
	end;

	else if order = "stop_xmit_hd"
	then do;
	     if wtcb.line_type ^= LINE_ARDS
	     then go to error;

	     call forward_order ();
	end;

	else if order = "set_line_type"
	then do;
	     if argptr = null
	     then go to error;			/* you have tell us what */
	     if wtcb.flags.listen
	     then go to error;			/* it's too late to change line types */
	     if new_line_type <= 0 | new_line_type > max_line_type
						/* invalid line_type */
	     then go to error;
	     if new_line_type = LINE_1050 | new_line_type = LINE_2741 | new_line_type = LINE_ARDS
		| new_line_type = LINE_ETX		/* The 1050, 2741, ETX and ARDS line types are no longer valid. */
	     then go to error;

	     call forward_order ();
	     wtcb.line_type = new_line_type;
	     do i = 1 to n_sync_line_types while (new_line_type ^= sync_line_type (i));
	     end;
	     wtcb.sync_line = (i <= n_sync_line_types);
	end;

	else if order = "dial_out"
	then do;
	     if pds$processid ^= wtcb.hproc
	     then go to illdet;			/* wtcb must be owned by caller */
	     if argptr = null ()
	     then go to error;			/* you have to give me a phone number */
	     if wtcb.flags.dialed
	     then go to error;			/* can't dial out, line is already being used */
	     if wtcb.dialing
	     then go to error;			/* can't dial while dialing */

	     if wtcb.flags.line_status_present
	     then do;				/* must complain about unprocessed status */
		ercode = error_table_$line_status_pending;
		go to unlock;
	     end;

	     if wtcb.error_code ^= 0
	     then do;
		ercode = wtcb.error_code;
		wtcb.error_code = 0;
		go to unlock;
	     end;

	     phone_data = arg_varying_char32;

/* phone number looks ok */
	     wtcb.dialing = "1"b;			/* remember what we are doing */
	     wtcb.dial_status_valid = ""b;		/* no status yet */
	     wtcb.dial_status_code = 0;		/* zero code */
	     call channel_manager$control (devx, order, addr (phone_data), ercode);
	     if ercode ^= 0
	     then wtcb.dialing = "0"b;		/* multiplexer rejected it, so we're not really dialing */
						/* otherwise, status will be returned via interrupt when the dial_out completes */
						/* so we're all done */
	end;

	else if order = "dial_out_status"
	then do;					/* caller wants result of dial */
	     if ^wtcb.dialing
	     then goto error;			/* not dialing */
	     if wtcb.dial_status_valid
	     then do;				/* is there status yet? */
		if wtcb.dial_status_code = 0
		then ercode = 0;
		else if wtcb.dial_status_code = acu_no_power
		then ercode = error_table_$device_not_usable;
		else if wtcb.dial_status_code = acu_line_occupied
		then ercode = error_table_$invalid_state;
		else if wtcb.dial_status_code = acu_dial_failure
		then ercode = error_table_$no_connection;
		else if wtcb.dial_status_code = acu_no_good
		then ercode = error_table_$no_operation;
		else if wtcb.dial_status_code = terminal_rejected
		then ercode = error_table_$no_wired_structure;
		else ercode = wtcb.dial_status_code;
		wtcb.dial_status_valid = ""b;		/* can only get status once */
		wtcb.dialing = ""b;
		wtcb.dial_status_code = 0;
	     end;
	     else ercode = error_table_$request_pending;
	end;

	else if order = "line_status"
	then do;
	     if ^wtcb.flags.dialed
	     then go to error;
	     if wtcb.flags.line_status_present
	     then do;				/* good call */
		argptr -> bit72 = wtcb.line_status;
		wtcb.line_status = "0"b;
		wtcb.flags.line_status_present = "0"b;
	     end;
	     else ercode = error_table_$no_line_status;	/* bad call */
	end;

	else if order = "line_control"
	then do;
	     if ^wtcb.flags.dialed
	     then go to error;
	     if wtcb.flags.line_status_present
	     then do;				/* must complain about unprocessed status */
		ercode = error_table_$line_status_pending;
		go to unlock;
	     end;

	     if wtcb.error_code ^= 0
	     then do;
		ercode = wtcb.error_code;
		wtcb.error_code = 0;
		go to unlock;
	     end;

	     call forward_order ();
	end;

	else if order = "set_line_status_enabled"	/* control whether to report line_status */
	then do;
	     if argptr = null ()
	     then do;
		ercode = error_table_$null_info_ptr;
		go to unlock;
	     end;

	     wtcb.line_status_disabled = ^(argptr -> bit1);
	     if wtcb.line_status_disabled
	     then do;				/* if disabling it */
		wtcb.line_status_present = "0"b;	/* if there was one already, discard it */
		wtcb.line_status = ""b;
	     end;
	end;

	else if order = "get_line_status_enabled"	/* user wants to see if line_status is enabled */
	then do;
	     if argptr = null ()
	     then do;
		ercode = error_table_$null_info_ptr;
		go to unlock;
	     end;

	     argptr -> bit1 = ^wtcb.line_status_disabled;
	end;

	else if order = "unmask"
	then if pds$processid ^= wtcb.hproc
	     then do;
		code = error_table_$io_no_permission;
		go to unlock;
	     end;

	     else if wtcb.masked
	     then do;
		wtcb.masked = "0"b;
		state = IGNORE;			/* now it's just hung up */
	     end;
	     else ;				/* a nop if channel wasn't masked */

	else if order = "set_editing_chars"
	then do;
	     if ^wtcb.flags.dialed
	     then go to error;
	     if editing_chars.version < 2 | editing_chars.version > 3
	     then go to wrong_version;

	     if search (editing_chars.chars, white_space) ^= 0
		| substr (editing_chars.chars, 1, 1) = substr (editing_chars.chars, 2, 1)
	     then ercode = error_table_$inconsistent;

	     else do;
		if substr (editing_chars.chars, 1, 1) ^= " "
		then tcb.erase = substr (editing_chars.chars, 1, 1);

		if substr (editing_chars.chars, 2, 1) ^= " "
		then tcb.kill = substr (editing_chars.chars, 2, 1);

	     end;
	end;

	else if order = "get_editing_chars"
	then if ^wtcb.flags.dialed
	     then go to error;
	     else do;
		if editing_chars.version < 2 | editing_chars.version > 3
		then go to wrong_version;
		editing_chars.chars = addr (tcb.special_input_chars) -> two_chars;
	     end;

	else if order = "set_framing_chars"
	then do;
	     if wtcb.sync_line
	     then go to error;

	     if (framing_chars.frame_end = NUL & framing_chars.frame_begin ^= NUL)
						/* can't have begin without end */
	     then ercode = error_table_$inconsistent;

	     else do;
		call forward_order ();
		tcb.frame_begin = framing_chars.frame_begin;
		tcb.frame_end = framing_chars.frame_end;

	     end;
	end;

	else if order = "input_flow_control_chars"
	then do;
	     if ^wtcb.flags.dialed
	     then go to error;
	     if (argptr -> input_flow_control_info.resume_seq.count = 0
		& argptr -> input_flow_control_info.suspend_seq.count ^= 0)
		| (argptr -> input_flow_control_info.suspend_seq.count = 0
		& argptr -> input_flow_control_info.resume_seq.count ^= 0
		& ^argptr -> input_flow_control_info.timeout)
	     then ercode = error_table_$improper_data_format;
	     else do;
		tcb.input_suspend_seq = argptr -> input_flow_control_info.suspend_seq;
		tcb.input_resume_seq = argptr -> input_flow_control_info.resume_seq;
		call forward_order ();
	     end;
	end;

	else if order = "output_flow_control_chars"
	then do;
	     if ^wtcb.flags.dialed
	     then go to error;
	     if argptr -> output_flow_control_info.suspend_resume & argptr -> output_flow_control_info.block_acknowledge
	     then go to bad_ofc;			/* must be one or the other */

	     sus_count = argptr -> output_flow_control_info.suspend_or_etb_seq.count;
	     res_count = argptr -> output_flow_control_info.resume_or_ack_seq.count;

	     if argptr -> output_flow_control_info.block_acknowledge
	     then if argptr -> output_flow_control_info.buffer_size = 0
		then if (tcb.max_output_block = 0 & (res_count + sus_count ^= 0))
						/* not already set */
			| (res_count = 0 & sus_count ^= 0) | (sus_count = 0 & res_count ^= 0)
						/* or not setting chars */
		     then go to bad_ofc;
		     else ;

		else tcb.max_output_block = divide (argptr -> output_flow_control_info.buffer_size, 2, 18, 0);
						/* set block size to half of buffer size */

	     else if (sus_count = 0 & res_count ^= 0) | (res_count = 0 & sus_count ^= 0)
		| (sus_count ^= 0 & sus_count = res_count
		& substr (argptr -> output_flow_control_info.suspend_or_etb_seq.chars, 1, sus_count)
		= substr (argptr -> output_flow_control_info.resume_or_ack_seq.chars, 1, res_count))
						/* suspend_resume, must specify chars, and they must be different */
	     then do;
bad_ofc:
		ercode = error_table_$improper_data_format;
		go to unlock;
	     end;
	     else tcb.max_output_block = 0;

	     if sus_count ^= 0 | (sus_count = 0 & res_count = 0 & argptr -> output_flow_control_info.buffer_size = 0)
						/* setting some sequence or turning it all off */
	     then do;
		tcb.output_suspend_etb_seq = argptr -> output_flow_control_info.suspend_or_etb_seq;
		tcb.output_resume_ack_seq = argptr -> output_flow_control_info.resume_or_ack_seq;
	     end;
	     tcb.block_acknowledge = argptr -> output_flow_control_info.block_acknowledge;

	     call forward_order ();
	end;

	else if order = "get_framing_chars"
	then do;
	     framing_chars.frame_begin = tcb.frame_begin;
	     framing_chars.frame_end = tcb.frame_end;
	end;

	else if order = "get_ifc_info"
	then do;
	     argptr -> input_flow_control_info.suspend_seq = tcb.input_suspend_seq;
	     argptr -> input_flow_control_info.resume_seq = tcb.input_resume_seq;
	end;

	else if order = "get_ofc_info"
	then do;
	     argptr -> output_flow_control_info.block_acknowledge = tcb.block_acknowledge;
	     argptr -> output_flow_control_info.suspend_resume =
		(^tcb.block_acknowledge) & (tcb.output_suspend_etb_seq.count ^= 0);
	     argptr -> output_flow_control_info.buffer_size = 2 * tcb.max_output_block;
	     argptr -> output_flow_control_info.suspend_or_etb_seq = tcb.output_suspend_etb_seq;
	     argptr -> output_flow_control_info.resume_or_ack_seq = tcb.output_resume_ack_seq;
	end;

	else if order = "set_delay"
	then do;
	     call replace_table (delay_type, ercode);
	     if ercode = 0 & (tcb.modes.echoplex | tcb.modes.echo_cr | tcb.modes.echo_lf)
	     then call send_delay_table;
	end;

	else if order = "set_input_conversion"
	then call replace_table (input_cv_type, ercode);

	else if order = "set_input_translation"
	then call replace_table (input_tr_type, ercode);

	else if order = "set_output_conversion"
	then call replace_table (output_cv_type, ercode);

	else if order = "set_output_translation"
	then call replace_table (output_tr_type, ercode);

	else if order = "set_special"
	then call replace_table (special_type, ercode);

	else if order = "set_echo_break_table"
	then do;
	     echo_neg_datap = argptr;

	     /*** Code to accept version 1 structure for compatibility ***/
	     /*** To be REMOVED when Emacs, video and mowse are using  ***/
	     /*** version 2.                                           ***/

	     echo_version_1 = "0"b;
	     if echo_neg_data.version = echo_neg_data_version_1
	     then echo_version_1 = "1"b;
	     else
/**** end compatibility code ****/
		if echo_neg_data.version ^= echo_neg_data_version_2
	     then go to wrong_version;

	     if wtcb.echdp = "000000"b3
	     then do;
		call tty_space_man$get_space (size (echo_data), echo_datap);
		if echo_datap ^= null ()
		then wtcb.echdp = rel (echo_datap);
	     end;
	     else echo_datap = ptr (ttybp, wtcb.echdp);
	     if echo_datap = null
	     then ercode = error_table_$notalloc;
	     else do;
		unspec (echo_data) = ""b;		/* For good luck */

		/*** Version 1 structure ***/
		/*** REMOVE when Emacs, video and mowse are using version 2. ***/

		if echo_version_1
		then do;
		     string (echo_data.break) = string (v1_echo_neg_data.break);
		     substr (string (echo_data.break), 129, 128) = (128)"1"b;
		     echo_data.rubout_trigger_chars = v1_echo_neg_data.rubout_trigger_chars;
		     echo_data.rubout_sequence_length = v1_echo_neg_data.rubout_sequence_length;
		     echo_data.rubout_sequence = v1_echo_neg_data.rubout_sequence;
		     echo_data.rubout_pad_count = v1_echo_neg_data.rubout_pad_count;
		     echo_data.buffer_rubouts = v1_echo_neg_data.buffer_rubouts;
		end;

		else do;

		     /*** END COMPATIBILITY CODE ****/

		     string (echo_data.break) = string (echo_neg_data.break);
		     echo_data.rubout_trigger_chars = echo_neg_data.rubout_trigger_chars;
		     echo_data.rubout_sequence_length = echo_neg_data.rubout_sequence_length;
		     echo_data.rubout_sequence = echo_neg_data.rubout_sequence;
		     echo_data.rubout_pad_count = echo_neg_data.rubout_pad_count;
		     echo_data.buffer_rubouts = echo_neg_data.buffer_rubouts;
		end;				/* of else clause for version 1 */
		/*** REMOVE when Emacs, video and mowse are using version 2. ***/

		call channel_manager$control (devx, "set_echnego_break_table", addr (echo_data.break), (0));
	     end;
	end;

	else if order = "get_delay"
	then do;
	     if ^wtcb.flags.dialed
	     then go to error;			/* obviously can't get it */
	     if argptr -> delay_struc.version ^= DELAY_VERSION
	     then go to wrong_version;

	     if tcb.delayrp = ""b			/* no delays */
	     then unspec (argptr -> delay_struc.delay) = ""b;

	     else argptr -> delay_struc.delay = ptr (ttytp, tcb.delayrp) -> delay;
	end;

	else if order = "get_special"
	then do;
	     if ^wtcb.flags.dialed
	     then go to error;
	     if tcb.specialrp = ""b			/* no special chars table */
	     then do;
		ercode = error_table_$no_table;
		go to unlock;
	     end;

	     special_ptr = ptr (ttytp, tcb.specialrp);	/* prepare to allocate and copy table */
	     sc_escape_len = special_ptr -> special_chars.escape_length;
	     sc_input_escape_len = special_ptr -> special_chars.input_escapes.len;

	     if get_special_info.version = SPECIAL_INFO_STRUCT_VERSION_1
	     then old_special_table_version = "0"b;
	     else old_special_table_version = "1"b;

	     on area go to no_allocate;
	     on storage go to no_allocate;

	     if old_special_table_version
	     then allocate special_chars_struc_old in (get_special_info_old.area_ptr -> special_area) set (temp_ptr);
	     else allocate special_chars_struc in (get_special_info.area_ptr -> special_area) set (temp_ptr);

	     revert area;
	     revert storage;

	     if old_special_table_version
	     then do;
		get_special_info_old.table_ptr = temp_ptr;
		temp_ptr -> special_chars_struc_old.version = SPECIAL_VERSION;

/* call internal subroutine to transfer new table into old table.  If any of
   the sequences are too long, it will return non-zero error code */
		call copy_to_old_special_table;
		if ercode ^= 0
		then do;
		     free temp_ptr -> special_chars_struc_old in (get_special_info_old.area_ptr -> special_area);
		     get_special_info_old.table_ptr = null;
		     go to unlock;
		end;
	     end;
	     else do;
		get_special_info.table_ptr = temp_ptr;
		temp_ptr -> special_chars_struc.version = SPECIAL_VERSION_2;
		addr (temp_ptr -> special_chars_struc.special_chars) -> special_chars = special_ptr -> special_chars;
	     end;
	end;

	else if order = "get_input_conversion"
	then call get_table (tcb.input_tctrp);

	else if order = "get_input_translation"
	then call get_table (tcb.input_mvtrp);

	else if order = "get_output_conversion"
	then call get_table (tcb.output_tctrp);

	else if order = "get_output_translation"
	then call get_table (tcb.output_mvtrp);

	else if order = "get_echo_break_table"
	then do;
	     if wtcb.echdp = "000000"b3
	     then ercode = error_table_$no_table;
	     else do;
		echo_datap = ptr (ttybp, wtcb.echdp);
		echo_neg_datap = argptr;		/* User's stuff */

		/*** Accept version 1 structure for compatibility ***/
		/*** REMOVE when Emacs, video and mowse are using version 2. ***/

		if echo_neg_data.version = echo_neg_data_version_1
		then do;
		     string (v1_echo_neg_data.break) = substr (string (echo_data.break), 1, 128);
						/* Copy the bits */
		     v1_echo_neg_data.rubout_sequence = echo_data.rubout_sequence;
		     v1_echo_neg_data.rubout_sequence_length = echo_data.rubout_sequence_length;
		     v1_echo_neg_data.rubout_pad_count = echo_data.rubout_pad_count;
		     v1_echo_neg_data.buffer_rubouts = echo_data.buffer_rubouts;
		     v1_echo_neg_data.rubout_trigger_chars = echo_data.rubout_trigger_chars;
		end;

		else do;
		     /*** END OF COMPATIBILITY CODE ***/
		     if echo_neg_data.version ^= echo_neg_data_version_2
		     then go to wrong_version;
		     string (echo_neg_data.break) = string (echo_data.break);
						/* Copy the bits */
		     echo_neg_data.rubout_sequence = echo_data.rubout_sequence;
		     echo_neg_data.rubout_sequence_length = echo_data.rubout_sequence_length;
		     echo_neg_data.rubout_pad_count = echo_data.rubout_pad_count;
		     echo_neg_data.buffer_rubouts = echo_data.buffer_rubouts;
		     echo_neg_data.rubout_trigger_chars = echo_data.rubout_trigger_chars;
		end;				/* of else clause based on version */
		/*** REMOVE when Emacs, video and mowse are using version 2. ***/
	     end;
	end;

	else if order = "get_meters"
	then do;
	     tty_meterp = argptr -> get_comm_meters_info.subchan_ptr;
	     if tty_meterp ^= null ()
	     then do;
		if tty_channel_meters.version ^= TTY_CHANNEL_METERS_VERSION_1
		then go to wrong_version;
		tty_channel_meters.last_dialed_time = tcb.time_dialed;
		tty_channel_meters.baud_rate = wtcb.baud_rate;
		tty_channel_meters.user_process = wtcb.uproc;
		tty_channel_meters.breakall = tcb.modes.breakall;
		tty_channel_meters.echoplex = tcb.modes.echoplex;
		tty_channel_meters.current_meters = tcb.cumulative_meters;
		tty_channel_meters.saved_meters = tcb.saved_meters;
	     end;
	     call forward_order ();
	end;

	else if order = "set_wakeup_table"
	then do;
	     swt_infop = argptr;
	     if swt_info.version ^= swt_info_version_1
	     then go to wrong_version;
	     if tcb.modes.wake_tbl
	     then go to cant_do;

	     if wtcb.waketp = ""b			/* no current wakeup table */
	     then string (swt_info.old_table) = ""b;
	     else do;
		wakeup_tablep = ptr (ttybp, wtcb.waketp);
		old_waketab = wakeup_table;
		call untranslate_wakeup_table;
		swt_info.old_table = old_waketab;
	     end;

	     new_waketab = swt_info.new_table;
	     if string (new_waketab) = ""b		/* new table is empty */
	     then do;
		if wtcb.waketp ^= ""b
		then do;
		     call tty_space_man$free_space (size (new_waketab), ptr (ttybp, wtcb.waketp));
		     wtcb.waketp = ""b;
		end;
	     end;
	     else do;				/* new table is not empty */
		if wtcb.waketp = ""b
		then do;
		     call tty_space_man$get_space (size (new_waketab), wakeup_tablep);
		     if wakeup_tablep = null
		     then go to no_allocate;
		     wtcb.waketp = rel (wakeup_tablep);
		end;
		call translate_wakeup_table;
		wakeup_table = new_waketab;
	     end;
	end;

	else if order = "set_prompt"
	then do;
	     sp_infop = argptr;
	     if sp_info.version ^= sp_info_version_1
	     then go to wrong_version;

	     i = length (sp_info.message);
	     if i < 0
	     then do;
		ercode = error_table_$smallarg;
		go to unlock;
	     end;
	     if i > 3
	     then do;
		ercode = error_table_$bigarg;
		go to unlock;
	     end;

	     wtcb.prompt_len = i;
	     if i > 0
	     then substr (wtcb.prompt, 1, i) = substr (sp_info.message, 1, i);
	end;

	else if order = "set_required_access_class"
	then do;
	     if wtcb.hproc ^= pds$processid
	     then do;				/* only owner can do this */
		ercode = error_table_$io_no_permission;
		go to unlock;
	     end;
	     else call forward_order ();		/* we don't handle this, but multiplexer might */
	end;

	else do;					/* we didn't understand the order */
	     call channel_manager$control (devx, order, a_argptr, ercode);
						/* see if any muxes understand */
	     go to unlock;				/* if not ercode will be returned */
	end;

unlock:
	if ercode = error_table_$io_no_permission
	then state = 0;				/* keep user in the dark */
	call tty_lock$unlock_channel (devx);		/* unlock the channel */
	return;

error:
	ercode = error_table_$undefined_order_request;	/* order not understood */
	go to unlock;

cant_do:
	ercode = error_table_$action_not_performed;	/* here if order couldn't be carried out */
	go to unlock;


no_allocate:
	ercode = error_table_$notalloc;
	go to unlock;

wrong_version:
	ercode = error_table_$unimplemented_version;
	go to unlock;
%page;
/* external entry to initialize a tcb */

initialize_tcb:
     entry (a_wtcbp, a_tcbp);


	wtcbp = a_wtcbp;
	tcbp = a_tcbp;
	call init_tcb;
	return;



/* internal procedure to initialize a tcb */

init_tcb:
     proc;

dcl  save_breakall_enabled bit (1);			/* used so this switch doesnt change */

	call init_tcb_tables;

	tcb.terminal_type = "";
	tcb.special_input_chars.erase = "#";
	tcb.special_input_chars.kill = "@";
	tcb.old_type = 0;
	string (tcb.modes) = ""b;
	save_breakall_enabled = tcb.breakall_enabled;	/* dont let this be changed */
	string (tcb.flags) = ""b;
	tcb.breakall_enabled = save_breakall_enabled;	/* restore old value */
	tcb.frame_begin, tcb.frame_end = NUL;
	tcb.actshift = "00"b;
	tcb.id = "none";
	tcb.colmax = 50;
	tcb.linemax = 0;
	tcb.wrt_lchar = 0;
	tcb.max_output_block = 0;
	tcb.input_suspend_seq.count = 0;
	tcb.input_resume_seq.count = 0;
	tcb.output_suspend_etb_seq.count = 0;
	tcb.output_resume_ack_seq.count = 0;
	wtcb.tcb_initialized = "1"b;

	return;

     end init_tcb;

init_tcb_tables:
     proc;

	trpp = addr (tcb.tables);			/* set ptr to tablerp array */
	dftrpp = addr (tcb.default_tables);		/* set ptr to  df_tablerp array */
	do table_type = 1 to 6;			/* dispose of tables from previous user */
	     if tablerp (table_type) ^= ""b
	     then call tty_tables_mgr$delete (tablerp (table_type), 0);
	     tablerp (table_type) = ""b;
	     if df_tablerp (table_type) ^= (18)"1"b & df_tablerp (table_type) ^= ""b
	     then call tty_tables_mgr$delete (df_tablerp (table_type), 0);
	     df_tablerp (table_type) = (18)"1"b;
	end;
	return;

     end init_tcb_tables;
%page;
/* internal procedure to add and replace tables */
/* replace_table entry is used by the table setting orders */
/* add_table entry is used by the set_terminal_data order */

replace_table:
     proc (table_type, code);

dcl  table_type fixed bin;				/* table type number (Input) */
dcl  code fixed bin (35);				/* status code (Output) */
dcl  infop ptr;					/* ptr to info structure containing table (Input) */
dcl  add_tablerp bit (18);				/* offset of added table */

dcl  new_tablerp bit (18);
dcl  tablep ptr;
dcl  table_size fixed bin;
dcl  replace_sw bit (1) aligned;


	replace_sw = "1"b;
	if ^wtcb.flags.dialed
	then go to error;
	trpp = addr (tcb.tables);			/* set ptr to tablerp array */
	dftrpp = addr (tcb.default_tables);		/* set ptr to df_tablerp array */
	go to join;


add_table:
     entry (table_type, infop, add_tablerp, code);

	replace_sw = "0"b;
	argptr = infop;

join:
	if argptr = null				/* no info structure supplied */
	then tablep = null;				/* assume null table */
	else do;
	     if table_type = delay_type & argptr -> delay_struc.version ^= DELAY_VERSION
	     then do;
wrong_version:
		code = error_table_$unimplemented_version;
		return;
	     end;
	     else if table_type = special_type
		&
		^(argptr -> special_chars_struc.version = SPECIAL_VERSION
		| argptr -> special_chars_struc.version = SPECIAL_VERSION_2)
	     then go to wrong_version;
	     else if argptr -> cv_trans_struc.version > CV_TRANS_VERSION
	     then go to wrong_version;

	     if replace_sw & argptr -> delay_struc.default ^= 0
	     then do;				/* must set current table to default table */
		if df_tablerp (table_type) = (18)"1"b	/* current table is already same as default */
		then ;				/* nothing to do */
		else do;
		     if tablerp (table_type) ^= ""b	/* current table is allocated */
		     then call tty_tables_mgr$delete (tablerp (table_type), 0);
						/* delete it */
		     tablerp (table_type) = df_tablerp (table_type);
						/* change the current table */
		     df_tablerp (table_type) = (18)"1"b;/* indicate that default table is the same */
		end;
		return;
	     end;

	     tablep = addr (argptr -> delay_struc.delay); /* get ptr to new table */
	end;

	if tablep = null
	then new_tablerp = ""b;			/* new table is null */
	else do;					/* allocate the new table */
	     if table_type = special_type
	     then do;
		if argptr -> special_chars_struc.version = SPECIAL_VERSION_2
		then do;
		     old_special_table_version = "0"b;
		     sc_escape_len = tablep -> special_chars.escape_length;
		     sc_input_escape_len = tablep -> special_chars.input_escapes.len;
		end;
		else do;
		     old_special_table_version = "1"b;
		     sc_escape_len = tablep -> special_chars_old.escape_length;
		     sc_input_escape_len = tablep -> special_chars_old.input_escapes.len;
		end;

		if sc_escape_len < 0 | sc_input_escape_len < 0
		then do;
bad_data:
		     code = error_table_$improper_data_format;
		     return;
		end;

		begin;

/* copy of special_chars structure.  put here so begin block can allocate an
   area large enough to hold the new version ofthe data */
dcl  1 scs aligned,
       2 nl_seq aligned like c_chars,			/* new-line sequence */
       2 cr_seq aligned like c_chars,			/* carriage-return sequence */
       2 bs_seq aligned like c_chars,			/* backspace sequence */
       2 tab_seq aligned like c_chars,			/* horizontal tab sequence */
       2 vt_seq aligned like c_chars,			/* vertical tab sequence */
       2 ff_seq aligned like c_chars,			/* form-feed sequence */
       2 printer_on aligned like c_chars,		/* printer-on sequence */
       2 printer_off aligned like c_chars,		/* printer_off sequence */
       2 red_ribbon_shift aligned like c_chars,		/* red ribbon shift sequence */
       2 black_ribbon_shift aligned like c_chars,		/* black ribbon shift sequence */
       2 end_of_page aligned like c_chars,		/* end-of-page warning sequence */
       2 escape_length fixed bin,			/* number of escape sequences */
       2 not_edited_escapes (sc_escape_len) like c_chars,	/* use in ^edited mode */
       2 edited_escapes (sc_escape_len) like c_chars,	/* use in edited mode */
       2 input_escapes aligned,
         3 len fixed bin (8) unaligned,			/* length of string */
         3 str char (sc_input_escape_len) unaligned,	/* escape sequence characters */
       2 input_results aligned,
         3 pad bit (9) unaligned,			/* so that strings will look the same */
         3 str char (sc_input_escape_len) unaligned;	/* results of escape sequences */

		     table_size = size (scs);
		     if table_size > max_special_size	/* watch out for gluttons */
		     then do;
			code = error_table_$bigarg;
			return;
		     end;
		     if ^old_special_table_version
		     then addr (scs) -> special_chars = tablep -> special_chars;
		     else call copy_from_old_special_table (tablep, addr (scs));
		     tablep = addr (scs);
		     call tty_tables_mgr$add (tablep, table_size, table_type, new_tablerp, code);
		end;
	     end;
	     else do;
		if table_type = delay_type
		then table_size = size (tablep -> delay);
		else table_size = divide (CV_TRANS_SIZE (argptr -> cv_trans_struc.version) + 1, 4, 17, 0);

		call tty_tables_mgr$add (tablep, table_size, table_type, new_tablerp, code);
	     end;
	     if code ^= 0
	     then return;

	     if table_type = special_type
	     then do;				/* don't trust user, restore saved refer values */
		tablep = ptr (ttytp, new_tablerp);
		tablep -> special_chars.escape_length = sc_escape_len;
		tablep -> special_chars.input_escapes.len = sc_input_escape_len;
	     end;
	     else if table_type = delay_type
	     then do;
		call validate_delay_table (ptr (ttytp, new_tablerp), code);
		if code ^= 0
		then do;
		     call tty_tables_mgr$delete (new_tablerp, 0);
		     return;
		end;
	     end;
	end;

	if ^replace_sw
	then add_tablerp = new_tablerp;
	else do;					/* change the tcb table offsets */
	     if df_tablerp (table_type) = (18)"1"b	/* default table is same as current */
	     then df_tablerp (table_type) = tablerp (table_type);
						/* set default table before changing current table */
	     else if tablerp (table_type) ^= ""b	/* the current table is allocated */
	     then call tty_tables_mgr$delete (tablerp (table_type), 0);
						/* delete it */
	     tablerp (table_type) = new_tablerp;	/* set the new current table */
	end;
	return;


     end replace_table;
%page;
get_table:
     proc (tablerp);

/* internal procedure to copy contents of table currently in use for "get_" orders */

dcl  tablerp bit (18);
dcl  tablep ptr;

	if ^wtcb.flags.dialed
	then go to error;

	if tablerp = ""b				/* we'll have to tell him about this */
	then ercode = error_table_$no_table;

	else do;
	     tablep = ptr (ttytp, tablerp);
	     if argptr -> cv_trans_struc.version > CV_TRANS_VERSION
	     then ercode = error_table_$unimplemented_version;
	     else if argptr -> cv_trans_struc.version = CV_TRANS_VERSION
	     then argptr -> cv_trans_struc.cv_trans = tablep -> cv_trans;
	     else do i = 0 to CV_TRANS_SIZE (argptr -> cv_trans_struc.version);
		argptr -> cv_trans_struc.cv_trans.value (i) = tablep -> cv_trans.value (i);
	     end;
	end;
	return;

     end /* get_table */;
%page;
alter_mode:
     proc (mode_name, alter_sw);

dcl  mode_name char (*);
dcl  alter_sw bit (1);

dcl  1 modes_info aligned,
       2 len fixed bin,
       2 str char (20);


	if alter_sw
	then do;
	     modes_info.str = mode_name;
	     modes_info.len = length (mode_name);
	end;
	else do;
	     modes_info.str = "^" || mode_name;
	     modes_info.len = length (mode_name) + 1;
	end;

	call tty_modes$mpx_only (wtcbp, addr (modes_info), ercode);

	return;

     end;



forward_order:
     proc;					/* forwards a control order to the multiplexer */

	call channel_manager$control (devx, order, argptr, ercode);
	if ercode ^= 0				/* give up */
	then go to unlock;

     end;
%page;
/* internal proc to validate a delay table */

validate_delay_table:
     proc (dp, code);

dcl  dp ptr;
dcl  code fixed bin (35);

	if max (abs (dp -> delay.vert_nl), dp -> delay.const_tab, abs (dp -> delay.backspace)) <= 127
	then if dp -> delay.vt_ff <= 511
	     then if min (dp -> delay.const_tab, dp -> delay.vt_ff) >= 0
		then if max (dp -> delay.horz_nl, dp -> delay.var_tab) <= 1
		     then if min (dp -> delay.horz_nl, dp -> delay.var_tab) >= 0
			then do;
			     code = 0;
			     return;
			end;
	code = error_table_$invalid_delay_value;

	return;

     end validate_delay_table;


/* entry to send delay table (called by tty_modes) */

send_delays:
     entry (a_wtcbp);

	wtcbp = a_wtcbp;
	tcbp = wtcb.tcb_ptr;
	devx = wtcb.devx;
	ttytp = addr (tty_tables$);
	call send_delay_table;
	return;


/* internal proc to send delay tables for the channel to the fnp */

send_delay_table:
     proc;

dcl  code fixed bin (35);


dcl  fnp_delays (6) fixed bin (17) unal;
dcl  dp ptr;

	if tcb.delayrp = ""b			/* no delay table for this channel */
	then fnp_delays (*) = 0;			/* use default delays, i.e., all zero */
	else do;					/* fill in fnp delays from current delay table */
	     dp = ptr (ttytp, tcb.delayrp);		/* get ptr to delay table */
	     fnp_delays (1) = abs (dp -> delay.vert_nl);
	     fnp_delays (2) = fixed (dp -> delay.horz_nl * 512, 17);
	     fnp_delays (3) = dp -> delay.const_tab;
	     fnp_delays (4) = fixed (dp -> delay.var_tab * 512, 17);
	     fnp_delays (5) = abs (dp -> delay.backspace);
	     fnp_delays (6) = min (dp -> delay.vt_ff, 127);
	end;

	call channel_manager$control (devx, "set_delay", addr (fnp_delays), code);

     end send_delay_table;
%page;
/* entry to turn printer on or off (called by tty_modes) */

printer_on_off:
     entry (a_wtcbp, a_sw);

	wtcbp = a_wtcbp;
	tcbp = wtcb.tcb_ptr;
	devx = wtcb.devx;
	ttytp = addr (tty_tables$);
	if a_sw
	then call turn_printer_on (0);
	else call turn_printer_off (0);
	return;


/* internal proc to write printer_off sequence to terminal */

turn_printer_off:
     proc (code);

dcl  code fixed bin (35);

	if tcb.no_printer_off
	then do;
no_print_off:
	     code = error_table_$action_not_performed;
	     return;
	end;

	call channel_manager$control (devx, "printer_off", null, code);
	if code = 0
	then return;
	if code ^= error_table_$undefined_order_request
	then return;
	code = 0;

	if tcb.specialrp = ""b
	then go to no_print_off;
	special_ptr = ptr (ttytp, tcb.specialrp);	/* get pointer to special chars table */
	if special_ptr -> special_chars.printer_off.count = 0
	then go to no_print_off;			/* none, complain */
	rawom = tcb.modes.rawom;			/* save setting of rawom */
	tcb.modes.rawom = "1"b;			/* we shd be in rawo to do this */

	call tty_write$locked (devx, addr (special_ptr -> special_chars.printer_off.chars), 0,
	     (special_ptr -> special_chars.printer_off.count), i, (0), code);
	tcb.modes.rawom = rawom;			/* restore rawom setting */

	return;

     end turn_printer_off;




/* internal proc to write printer_on sequence to terminal */

turn_printer_on:
     proc (code);

dcl  code fixed bin (35);

	if tcb.no_printer_off
	then do;
no_print_on:
	     code = error_table_$action_not_performed;
	     return;
	end;

	call channel_manager$control (devx, "printer_on", null, code);
	if code = 0
	then return;
	if code ^= error_table_$undefined_order_request
	then return;
	code = 0;

	if tcb.specialrp = ""b
	then go to no_print_on;

	special_ptr = ptr (ttytp, tcb.specialrp);	/* get pointer to special chars table */
	if special_ptr -> special_chars.printer_on.count = 0
	then go to no_print_on;			/* none, complain */
	rawom = tcb.modes.rawom;			/* save setting of rawom */
	tcb.modes.rawom = "1"b;			/* we shd be in rawo to do this */

	call tty_write$locked (devx, addr (special_ptr -> special_chars.printer_on.chars), 0,
	     (special_ptr -> special_chars.printer_on.count), i, (0), code);
	tcb.modes.rawom = rawom;			/* reset rawom */

	return;

     end turn_printer_on;
%page;
setup:
     proc (state);

dcl  state fixed bin;
	devx = twx;				/* pull devx from user */
	ttybp = addr (tty_buf$);
	lctp = tty_buf.lct_ptr;
	if devx < 1 | devx > lct.max_no_lctes
	then do;
	     ercode = error_table_$invalid_device;
	     go to ret;				/* return error */
	end;

	call tty_lock$lock_channel (devx, ercode);	/* lock the channel */
	if ercode ^= 0
	then go to ret;
	locked = "1"b;

	lctep = addr (lct.lcte_array (devx));
	if lcte.channel_type ^= 0			/* not our cup of tea */
	then go to illdet;

	wtcbp = lcte.data_base_ptr;			/* pointer to perm info */
	tcbp = wtcb.tcb_ptr;			/* pickup pointer to tib */
	if ^wtcb.tcb_initialized
	then call init_tcb;

	if wtcb.dialed				/* compute state */
	then state = DIALED_UP;			/* dialed up */
	else if wtcb.masked				/* masked by FNP */
	then state = MASKED_STATE;
	else if wtcb.listen
	then state = LISTENING;			/* hungup but listening */
	else state = IGNORE;			/* made busy */

	ercode = 0;				/* clear error code */

	if wtcb.hproc = pds$processid			/* check access */
	then return;				/* hproc is always welcome */

	if wtcb.hproc = "0"b			/* if no one */
	then return;				/* then ok */


	if (wtcb.uproc = pds$processid & (tcb.uproc_attached | ^uproc_attach_required_for_setup))
	     | ^uproc_required_for_setup		/* if using process */
	then return;

	go to illdet;				/* return to main line at error point */
     end;

illdet:						/* illegal messing with channel */
	ercode = error_table_$io_no_permission;		/* else return error */
	call tty_lock$unlock_channel (devx);		/* unlock the channel */

ret:
	if ercode ^= 0
	then state = 0;				/* keep clean */
	return;
%page;
get_devx:
     proc (chan_name);

dcl  chan_name char (*);

	lcntp = lct.lcnt_ptr;			/* get pointer to the name table */
	do devx = 1 to lct.max_no_lctes while (lcnt.names (devx) ^= chan_name);
	end;
	if devx > lct.max_no_lctes
	then					/* not in name table, maybe it's old name? */
	     do devx = 1 to lct.max_no_lctes while (^compare_tty_name_ (chan_name, lcnt.names (devx)));
	end;

	if devx > lct.max_no_lctes			/* wasn't in that form either */
	then ercode = error_table_$invalid_device;	/* leave error code */
	else ercode = 0;
	return;					/* return to caller */

     end;


cleaner:
     proc;

	if locked
	then call tty_lock$unlock_channel (devx);

     end cleaner;
%page;
/* Subroutine to translate wakeup table from ASCII to terminal code */

translate_wakeup_table:
     proc;

dcl  1 temp_table aligned like wakeup_table;
dcl  (i, j) fixed bin;
dcl  p ptr;

	if tcb.input_mvtrp = ""b
	then return;
	string (temp_table) = ""b;
	p = ptr (ttytp, tcb.input_mvtrp);		/* get ptr to input translation table */
	do i = 0 to 127;
	     if new_waketab.wake_map (i)		/* this is a wakeup char */
	     then do j = 0 to 127;			/* find all terminal codes that translate into it */
		if p -> cv_trans.value (j) = i	/* found one */
		then temp_table.wake_map (j) = "1"b;
	     end;
	end;

	new_waketab = temp_table;
     end;



/* Subroutine to translate wakeup table from terminal code to ASCII */

untranslate_wakeup_table:
     proc;

dcl  1 temp_table aligned like wakeup_table;
dcl  i fixed bin;
dcl  p ptr;

	if tcb.input_mvtrp = ""b
	then return;
	string (temp_table) = ""b;
	p = ptr (ttytp, tcb.input_mvtrp);
	do i = 0 to 127;
	     if old_waketab.wake_map (i)		/* this is a wakeup char */
	     then do;
		j = p -> cv_trans.value (i);		/* get ASCII value */
		if j <= 127			/* don't trust table */
		then temp_table.wake_map (j) = "1"b;
	     end;
	end;

	old_waketab = temp_table;
     end;

%page;
is_parent_mpx:					/* Check match of channel's parent mpx type against input mpx type */
     proc (parent_mpx_type) returns (bit (1));

dcl  parent_mpx_type fixed bin;
dcl  temp_lctep ptr;

	if lcte.major_channel_devx ^= 0
	then do;
	     temp_lctep = addr (lct.lcte_array (lcte.major_channel_devx));
	     if temp_lctep -> lcte.channel_type = parent_mpx_type
	     then return ("1"b);
	end;
	else if lcte.channel_type = parent_mpx_type
	then return ("1"b);
	return ("0"b);
     end is_parent_mpx;
%page;
copy_to_old_special_table:
     proc;

/* Special procedure to copy a Version 2 special chars table (15 char
   sequences) to a Version 1 special chars table (3 char sequences).  It is
   broken out as a subroutine just to avoid cluttering up where it is called. */

	special_chars_old_ptr = addr (temp_ptr -> special_chars_struc_old.special_chars);

	if special_ptr -> special_chars.nl_seq.count > 3
	then do;
bad_special_size:
	     ercode = error_table_$invalid_array_size;
	     return;
	end;
	addr (special_chars_old.nl_seq) -> c_chars_old = addr (special_ptr -> special_chars.nl_seq) -> c_chars_old;

	if special_ptr -> special_chars.cr_seq.count > 3
	then go to bad_special_size;
	addr (special_chars_old.cr_seq) -> c_chars_old = addr (special_ptr -> special_chars.cr_seq) -> c_chars_old;

	if special_ptr -> special_chars.bs_seq.count > 3
	then go to bad_special_size;
	addr (special_chars_old.bs_seq) -> c_chars_old = addr (special_ptr -> special_chars.bs_seq) -> c_chars_old;

	if special_ptr -> special_chars.tab_seq.count > 3
	then go to bad_special_size;
	addr (special_chars_old.tab_seq) -> c_chars_old = addr (special_ptr -> special_chars.tab_seq) -> c_chars_old;

	if special_ptr -> special_chars.vt_seq.count > 3
	then go to bad_special_size;
	addr (special_chars_old.vt_seq) -> c_chars_old = addr (special_ptr -> special_chars.vt_seq) -> c_chars_old;

	if special_ptr -> special_chars.ff_seq.count > 3
	then go to bad_special_size;
	addr (special_chars_old.ff_seq) -> c_chars_old = addr (special_ptr -> special_chars.ff_seq) -> c_chars_old;

	if special_ptr -> special_chars.printer_on.count > 3
	then go to bad_special_size;
	addr (special_chars_old.printer_on) -> c_chars_old =
	     addr (special_ptr -> special_chars.printer_on) -> c_chars_old;

	if special_ptr -> special_chars.printer_off.count > 3
	then go to bad_special_size;
	addr (special_chars_old.printer_off) -> c_chars_old =
	     addr (special_ptr -> special_chars.printer_off) -> c_chars_old;

	if special_ptr -> special_chars.red_ribbon_shift.count > 3
	then go to bad_special_size;
	addr (special_chars_old.red_ribbon_shift) -> c_chars_old =
	     addr (special_ptr -> special_chars.red_ribbon_shift) -> c_chars_old;

	if special_ptr -> special_chars.black_ribbon_shift.count > 3
	then go to bad_special_size;
	addr (special_chars_old.black_ribbon_shift) -> c_chars_old =
	     addr (special_ptr -> special_chars.black_ribbon_shift) -> c_chars_old;

	if special_ptr -> special_chars.end_of_page.count > 3
	then go to bad_special_size;
	addr (special_chars_old.end_of_page) -> c_chars_old =
	     addr (special_ptr -> special_chars.end_of_page) -> c_chars_old;

	special_chars_old.escape_length = special_ptr -> special_chars.escape_length;

	do i = 1 to special_ptr -> special_chars.escape_length;
	     if special_ptr -> special_chars.not_edited_escapes (i).count > 3
		| special_ptr -> special_chars.edited_escapes (i).count > 3
	     then go to bad_special_size;
	     addr (special_chars_old.not_edited_escapes (i)) -> c_chars_old =
		addr (special_ptr -> special_chars.not_edited_escapes (i)) -> c_chars_old;

	     addr (special_chars_old.edited_escapes (i)) -> c_chars_old =
		addr (special_ptr -> special_chars.edited_escapes (i)) -> c_chars_old;
	end;

	special_chars_old.input_escapes.len = special_ptr -> special_chars.input_escapes.len;
	special_chars_old.input_escapes.str = special_ptr -> special_chars.input_escapes.str;

	special_chars_old.input_results.pad = special_ptr -> special_chars.input_results.pad;
	special_chars_old.input_results.str = special_ptr -> special_chars.input_results.str;

     end copy_to_old_special_table;
%page;
copy_from_old_special_table:
     proc (source_ptr, target_ptr);

/* Special procedure to copy a Version 1 special chars table (3 char sequences
   into a Version 2 special chars table (15 char sequences).  It is put here
   just to keep from cluttering up where it is called. */

dcl  target_ptr ptr;
dcl  source_ptr ptr;

	special_chars_old_ptr = source_ptr;
	addr (target_ptr -> special_chars.nl_seq) -> c_chars_old = addr (special_chars_old.nl_seq) -> c_chars_old;

	addr (target_ptr -> special_chars.cr_seq) -> c_chars_old = addr (special_chars_old.cr_seq) -> c_chars_old;

	addr (target_ptr -> special_chars.bs_seq) -> c_chars_old = addr (special_chars_old.bs_seq) -> c_chars_old;

	addr (target_ptr -> special_chars.tab_seq) -> c_chars_old = addr (special_chars_old.tab_seq) -> c_chars_old;

	addr (target_ptr -> special_chars.vt_seq) -> c_chars_old = addr (special_chars_old.vt_seq) -> c_chars_old;

	addr (target_ptr -> special_chars.ff_seq) -> c_chars_old = addr (special_chars_old.ff_seq) -> c_chars_old;

	addr (target_ptr -> special_chars.printer_on) -> c_chars_old =
	     addr (special_chars_old.printer_on) -> c_chars_old;

	addr (target_ptr -> special_chars.printer_off) -> c_chars_old =
	     addr (special_chars_old.printer_off) -> c_chars_old;

	addr (target_ptr -> special_chars.red_ribbon_shift) -> c_chars_old =
	     addr (special_chars_old.red_ribbon_shift) -> c_chars_old;

	addr (target_ptr -> special_chars.black_ribbon_shift) -> c_chars_old =
	     addr (special_chars_old.black_ribbon_shift) -> c_chars_old;

	addr (target_ptr -> special_chars.end_of_page) -> c_chars_old =
	     addr (special_chars_old.end_of_page) -> c_chars_old;

	target_ptr -> special_chars.escape_length = special_chars_old.escape_length;

	do i = 1 to special_chars_old.escape_length;
	     addr (target_ptr -> special_chars.not_edited_escapes (i)) -> c_chars_old =
		addr (special_chars_old.not_edited_escapes (i)) -> c_chars_old;
	     addr (target_ptr -> special_chars.edited_escapes (i)) -> c_chars_old =
		addr (special_chars_old.edited_escapes (i)) -> c_chars_old;
	end;

	target_ptr -> special_chars.input_escapes.len = special_chars_old.input_escapes.len;
	target_ptr -> special_chars.input_escapes.str = special_chars_old.input_escapes.str;

	target_ptr -> special_chars.input_results.pad = special_chars_old.input_results.pad;
	target_ptr -> special_chars.input_results.str = special_chars_old.input_results.str;

     end copy_from_old_special_table;

/* format: off */
%page; %include aim_template;
%page; %include tty_convert;
%page; %include tty_buf;
%page; %include wtcb;
%page; %include tcb;
%page; %include tty_buffer_block;
%page; %include lct;
%page; %include tty_tables;
%page; %include mailbox_ops;
%page; %include net_event_message;
%page; %include terminal_type_data;
dcl  ttd_version_2 fixed bin int static options (constant) init (2);
%page; %include terminal_info;
%page; %include tty_space_man_dcls;
%page; %include channel_manager_dcls;
%page; %include line_types;
%page; %include mcs_echo_neg;
%page; %include mcs_echo_neg_sys;
%page; %include set_wakeup_table_info;
%page; %include set_prompt_info;
%page; %include flow_control_info;
%page; %include get_comm_meters_info;
%page; %include tty_channel_meters;
%page; %include tty_access_class;
%page; %include syserr_constants;
%page; %include multiplexer_types;

/* format: on */
%page;
/* BEGIN MESSAGE DOCUMENTATION

   Message:
   tty_index: USER (ACCESS_CLASS) attempted invalid attachment of CHANNEL (ACCESS_CLASS)

   S:	$info

   T:	$run

   M:	A process of USER (with authorization ACCESS_CLASS) attempted to use
   a communications channel which does not correspond to the user's
   authorization and the user does not have the communications privilege
   enabled. The request was refused.  This may indicate a system error.

   A:	$inform_ssa

   END MESSAGE DOCUMENTATION */


     end;
