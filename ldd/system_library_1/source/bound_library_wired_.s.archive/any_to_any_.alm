" ***********************************************************
" *                                                         *
" * Copyright, (C) Honeywell Bull Inc., 1987                *
" *                                                         *
" * Copyright, (C) Honeywell Information Systems Inc., 1984 *
" *                                                         *
" ***********************************************************

" HISTORY COMMENTS:
"  1) change(86-04-29,Oke), approve(86-05-30,MCR7424), audit(86-05-30,Mabey),
"     install(86-06-12,MR12.0-1075):
"     flt_dec.fix_bin.zero case after mp3d or dv3d assumed length in x3 was
"     valid, it needed copy from x4.
"  2) change(86-04-29,Oke), approve(86-05-30,MCR7424), audit(86-05-30,Mabey),
"     install(86-06-12,MR12.0-1075):
"     Scan for bad characters before skipping leading blanks in
"     char_to_arithmetic_.  Otherwise we run off the blank skip table to other
"     tables, and invalidly accept some bad inputs.
"  3) change(86-07-15,Ginter), approve(86-07-15,MCR7435),
"     audit(86-07-16,Mabey), install(86-07-28,MR12.0-1104):
"     Change by M Mabey (installed by Ginter) - Conversions from fixed bin
"     numbers with negative scale factors to float decimal, character, and
"     bits would fail.
"  4) change(90-08-27,Blackmore), approve(90-08-27,MCR8194),
"     audit(90-09-14,Oke), install(90-10-01,MR12.4-1035):
"     Fix entry 40 in the arrays 'stype' and 'ttype' to fix treatment of fixed
"     decimal unsigned 4-bit values (Multics type 40).  Also fix treatment of
"     exponent to floating decimal values during conversion into a bitstring.
"                                                      END HISTORY COMMENTS


"	PL/I Conversion Package
"
"	BLW, Spring 1973
"	Re-written by T. Oke 1983. SEE MTB-672 for details.

"	Character input of "" mis-handled.  Fixed 84-03-13 by T. Oke
"	Char to bit fills "0"b to wrong target.  Fixed 84-03-14 by T. Oke
"	Flt Dec to Scaled bin forms bad on zero. Fixed 84-03-16 by T. Oke
"	Flt Dec to Bit did no offset when replacing exponent.  Fixed 84-03-16
"	     by T. Oke
"	varying char and bit target routines did not limit to source length.
"	     Fixed 84-04-16 by T. Oke
"	optimization of flt_bin_to_flt_dec omitted converting the last bit
"	     of the flt bin mantissa.  Fixed 84-04-16 by T. Oke
"	original_source_length length not saved prior to error_205 detection
"	     which calls error_xxx, which uses uninitialized
"	     original_source_length. error_205 now forces string to 256.
"	      PHX17351  Fixed 84-04-19 by T. Oke
"	Full conversion precision from flt_decimal to flt_bin.  Maintained
"	     through use of precision correction determined from upper non-0
"	     digit of flt_decimal.  We convert to flt_bin 70 to flt_bin 71.
"	Correct error_176 to become error_191.  Oncode message 376 does not
"	     exist, but 391 was correct message.
"	Correct handling of scaled fixed bin to correct the scale factor with
"	     a fixed exponent and produce the right values.
"
"     Installed into MR11 - October 1984.

"	put_bit of aligned target must pre-clear 1st and possible 2nd word to
"	     avoid padded reference bug.  Fixed 84-11-09 by T. Oke
"	load_flt_dec.target needs to validate 0.0  number to prevent size
"	     condition falsely signalled.  Fixed 84-11-09 by T. Oke
"	flt_dec.fix_bin.zero used length of flt_dec source rather than needed
"	     fix_dec target to convert causing size error.  Fixed 84-11-12 by
"	     T. Oke
"	end_get_fix_dec.normalized used X2 as length of fixed decimal
"	     generic.  X2 is invalid at this point, should use X3 instead as
"	     length of float decimal generic to fix exponent.
"	     Fixed 84-11-12 by T. Oke
"	recognize.no_sign did not skip leading 0's to prevent conversion
"	     errors indicating too many digits.  Now leading 0's don't count.
"	     Fixed 84-11-13 by T. Oke
"	move_char_to_numeric needs to recognize 0-length input.
"	     Fixed 84-11-16 by T. Oke
"	Fix minimum recognized precision to 1 in case of blank or 0 input.
"	     Fixed 84-11-19 by T. Oke
"	rtrim source string for char_to_numeric_ input.  84-11-19 by T. Oke
"	Use pl1_signal_conversion_ rather than
"	     plio2_signal_$conversion_error_.  84-11-20 by T. Oke
"	84-11-29 by T. Oke.  What is hoped to be the final fix to skipping
"	     leading zeros.  Now we remember that an integer part was seen
"	     then remove leading zeros from precision calculation.
"	85-02-07 by T. Oke.  Moved code in convert_flt_bin_to_flt_hex to
"	     correct rounding test.  Somehow mask index code got moved.
"	     Fixed rounding.

	segdef	real_to_real_
	segdef	real_to_real_round_
	segdef	real_to_real_truncate_
	segdef	any_to_any_
	segdef	any_to_any_round_
	segdef	any_to_any_truncate_
	segdef	char_to_numeric_

	include	eis_micro_ops
	include	pl1_system
	include	stack_header
	include	stack_frame
"
"	mnemonics for CSL instruction
"
	bool	move,03
"
"	description of error extension of stack
"
	equ	error_extension,128	size of extension
	equ	save_ptrs,0
	equ	save_regs,16
	equ	call_ptr,24
	equ	arglist,26
	equ	oncode,save_regs+4
	equ	onchar_index,save_regs+5
	equ	name_length,save_regs+5
	equ	onsource_ptr,save_ptrs+4	assumes s = 2
	equ	onsource,64
"	WORK AREA DESCRIPTION.
"
"     There are two work areas of:
"	 28 words - Normal numeric to numeric, bit to bit.
"	118 words - to character, character to numeric.
"     Old programs (compiled before release 24) reference two work areas,
"     of 36 and 156 words.

"     Token information for character to numeric input.  Used by recognize to
"     build token information from input stream.

	equ	sign_part,0
	equ	integer_part,1
	equ	fractional_part,2
	equ	exponent_part,3
	equ	type_part,4
	equ	prec_part,5		" precision and scale
	equ	token_size,6		" number of words in token
	equ	token_length,token_size*4	" five words of 4 chars each

	macro	token_info
	equ	&1_token,&2		" start of token
	equ	&1.sign.index,&2+0		" sign index in DL
	equ	&1.sign.length,&2+0		" sign length in DU
	equ	&1.integer.index,&2+1	" integer part index in DL
	equ	&1.integer.length,&2+1	" integer length in DU
	equ	&1.fraction.index,&2+2	" fraction index in DL
	equ	&1.fraction.length,&2+2	" fraction length in DU
	equ	&1.exponent.value,&2+3	" exponent value
	equ	&1.type,&2+4		" type in DU
	equ	&1.term,&2+4		" encoded terminator in DL
	equ	&1.scale,&2+5		" scale in DU
	equ	&1.prec,&2+5		" prec in DL
	&endm



	equ	scales,0
	equ	target_scale,0		(DU) target scale
	equ	target_precision,0		(DL) target precision
	equ	source_scale,1		(DU) source scale
	equ	source_precision,1		(DL) source precision
	equ	source_string_length,1	FULL word
	equ	original_source,2		copy of orig source ptr 

"     GENERIC storage.

	equ	fix_bin_generic,4		DOUBLE WORD

	equ	flt_bin_generic,6		DOUBLE WORD float bin
	equ	flt_bin_generic_exp,10	Exponent for float bin

	equ	flt_dec_generic_exp,11	Exponent for float decimal
	equ	flt_dec_generic,12		float decimal (64) bytes
	equ	fix_dec_generic,12		OVERLAY fix dec (64) bytes
	equ	bit_generic,12		** OVERLAY flt_dec_generic
"
"	end of short work area (28 words)

	equ	return,28			save_target return pointer
	equ	save_target_ptr,30		t ptr during binary -> char
	equ	generic_ptr,32		source ptr char_to_arithmetic_
	equ	save_pr4,34		PR4 storage if we destroy
	equ	error_return,36
	equ	save_target_precision,38
	equ	save_rounding,39
	equ	char_generic,40 		GENERIC char (256 B, 64 W)
	equ	char_flt_dec_gen,72		generic flt_dec for char
	equ	original_source_length,104
	equ	save_target_type,105

	maclist	off save
	token_info real,106
	token_info imag,106+token_size
	maclist	restore

"	end of long work area (118 words)
"	character constants

	bool	blank,040
	bool	plus_sign,053
	bool	minus_sign,055
	bool	period,056
	bool	digit_0,060
	bool	digit_1,061
	bool	letter_I,111
	bool	letter_e,145
	bool	letter_f,146
	bool	letter_i,151
"
"	character classes
"
	equ	illegal_class,0
	equ	sign_class,1
	equ	period_class,2
	equ	b_class,3
	equ	de_class,4
	equ	i_class,5
	equ	blank_class,6
	equ	digit_class,7
	equ	f_class,8

"	base register assignments

	equ	target,1		" points to user's target
	equ	generic,2		" points to current generic (char/bit)
	equ	source,3		" points to user's source
	equ	linkage,4		" destroyed in format/recognize
	equ	work,5		" points to working storage area
	equ	sp,6		" points to current caller's stack

"	text base ptr in stack frame

	equ	tbp,38

"     Indicator bits.

	bool	ind_zero,400000
	bool	ind_negative,200000
	bool	ind_carry,100000
	bool	ind_overflow,040000
	bool	ind_exp_overflow,020000
	bool	ind_exp_underflow,010000
	bool	ind_overflow_mask,004000

"     Indicator register fault mask.

	bool	mask_faults,ind_overflow_mask
	bool	unmask_faults,0

"     Length of power of two table.

	equ	two_table_limit,197

"     Type Codes for numeric to character conversion.

	equ	fix_dec_type,2*9		" real_fix_dec_9bit_ls
	equ	flt_dec_type,2*83		" real_flt_dec_gen

"     Type code for generic float decimal.

	equ	real_flt_dec_generic,83
	equ	cplx_flt_dec_generic,84

"     Error declaration and handling.
"     
"     Errors are managed by masking overflow faults throughout the code, using
"     the constants "mask_faults" and "unmask_faults".  Overflows are detected
"     through code sequences for range testing, or through the hardware
"     setting the overflow or exponent overflow bits.  Then the correct error
"     is signalled through a pl1-style call.
"     
"     At the moment all errors signalled in this manner are restartable, even
"     though a "size_error" is declared in documentation as not being
"     restartable.
"     
"     Decimal and float binary range error declaration as underflow or
"     overflow depend upon the correct sign being present in the
"     flt_dec_generic_exp and the flt_bin_generic_exp respectively.  The
"     contents can well be shifted to the upper bits, the the word sign bit
"     must be correct.
"     
"     
"     		TESTING
"     
"     This program has been tested through the test sub-system "test_a" and
"     its associated test scripts to assure correct functioning.  This test
"     sub-system should be used to pinpoint and duplicate all reported errors
"     and to verify correct functioning after error removal.
"
"     Three basic test suites are used:
"
"	fetch_tests.test_a	Tests ability to fetch values with minimum
"			converison done.
"	store_tests.test_a	Tests ability to store results with minimum
"			conversion done.  Pre-requisite is fetch_tests.
"    	c_test.rnd.test_a	Tests conversion and fixups with rounding.
"			Pre-requisites are fetch and store tests.
"
"     When you do any work on assign_ or any_to_any_ please add to these test
"     suites.

"     Work Area allocation has been done in two areas, rather than the
" previous three areas.
" 
"     The first area matches the previous smallest area, and is 28 words in
" length.  The second area is a total of 118 words in length.  The previous
" second area was 44 words in length and had a decimal temporary within it.
" This functionality has been absorbed within the first area.
" 
"     The previous third area was a total of 158 words in length, and its
" functionality has been absorbed by the new second area's 118 word length.
" 
"     The first area is used for all numeric to numeric conversions, pl1
" bit to bit, and pl1 character to character conversions.  The second area is
" used for numeric to character and character to numeric and bit conversions.
" It is also required if conversions of bit or character input, other than pl1
" type descriptors, are done, where a re-structure of the stream is needed.ANY_TO_ANY_ CALLERS as of: 84-03-19


" References to any_to_any_:  (bound_library_wired_ in HARDCORE)
"    assign_.alm		200 words
"    put_format_.alm	156 words
" References to any_to_any_$any_to_any_round_:  (bound_library_wired_ in HARDCORE)
"    assign_.alm		200 words
"    formline_.alm		160 words
"    pl1_operators_.alm	passed by user program 'convert' = 164 words
"    put_format_.alm	156 words
" References to any_to_any_$any_to_any_truncate_:  (bound_library_wired_ in HARDCORE)
"    assign_.alm		200 words
"    formline_.alm		160 words
"    pl1_operators_.alm	passed by user program 'convert' = 164 words
" References to any_to_any_$char_to_numeric_:  (bound_library_wired_ in HARDCORE)
"    assign_.alm		200 words
" References to any_to_any_$real_to_real_round_:  (bound_library_wired_ in HARDCORE)
"    pl1_operators_.alm	passed by user program 'convert' = 164 words
"    pl1_operators_.alm	passed by user program 'convert' = 164 words

" Calling sequence and register conventions:
"
" Entries:
"	any_to_any_
"	any_to_any_round_
"	any_to_any_truncate_
"	real_to_real_
"	real_to_real_round_
"	real_to_real_truncate_
"
"	(pr0)	pl1_operators_$operator_table (Not used...must not be changed)
"	pr1	points to the target. (Input)
"	pr3	points to the source. (Input)
"	pr5	caller-supplied work area.  See "WORK AREA DESCRIPTION" above.
"		(Input)
"	pr6	points to caller's stack frame. (Input)
"	a	contains the length of the target if it
"		is a string, or the scale of the target in AU
"		and the precision in AL. (Input)
"	q	contains the length of the source if it
"		is a string, or the scale of the source in QU
"		and the precision in QL. (Input)
"	x0	return offset in calling program. (Input)
"	x6	contains the type code of the target. (Input)
"	x7	contains the type code of the source. (Input)


"     NOTE.  We run with overflow faults masked.  All exit is done through
"
"	tra	unmask_exit
"
"     or by similarly doing an:
"
"	ldi	unmask_faults,dl
"
"     prior to exiting routine.  Without faults masked we can normally take
"     overflow conditions and not know to signal properly within the code.

any_to_any_truncate_:
real_to_real_truncate_:
	eax5	0			" no rounding
	tra	xfer

any_to_any_:
real_to_real_:
	eax5	0			" assume no rounding
	ldx1	target_type_map,x6		" get flags for target
	canx1	round,du			" check targetfor rounding
	tze	xfer			" no rounding, process

any_to_any_round_:
real_to_real_round_:
	eax5	1			" round


"     Dispatch

"     Scales and precision share the same word.  Scales are upper (ldxN).
"     Precision is lower (lxlN).

xfer:	staq	work|scales		" Scales in DU, precision DL
	cmpx7	source_map_size,du		" See if source convertable
	trc	error_bad_type
	cmpx6	target_map_size,du		" See if target convertable
	trc	error_bad_type

"     Find source conversion to GENERIC

	stz	work|original_source	" no stack error extension
	ldi	mask_faults,dl		" overflows noted by software
	lxl3	source_type_map,x7		" get source conversion addr
	tsp7	0,x3			" conversion
	ldi	mask_faults,dl		" reset to permit faults
"     through with conversion, check for complex target
"     (Note that char & bit targets return directly to the user,
"     not to the caller via pr7).
"
"     Source and target pointers have been updated by get and put routines
"     and are correct for imaginary parts.


	ldx1	target_type_map,x6		" get flag word for target
	canx1	complex,du		" complex?
	tze	unmask_exit		" real target, return

	lxl1	source_type_map,x7		" get source routine
	ldx2	source_type_map,x7
	canx2	simple,du			" check if source is simple
	tnz	unmask_exit
	canx2	complex,du		" check if source is complex
	tnz	convert_complex		" convert complex source

"     Source is not complex, target is, assume zero imaginary part.
"     Zero generic type of source in work area and then convert it.

	ldx3	source_type_map,x6		" Get GENERIC type
	anx3	generic_mask,du
	tra	zero_generic,x3*		" zero work area

zero_fixed_bin:				" Zero GENERIC fixed bin
	stz	work|fix_bin_generic
	stz	work|fix_bin_generic+1
	ldx1	fix_bin_generic_conversion,du
	tra	convert_complex

zero_float_bin:				" Zero GENERIC float bin
	stz	work|flt_bin_generic_exp
	stz	work|flt_bin_generic
	stz	work|flt_bin_generic+1
	ldx1	flt_bin_generic_conversion,du
	tra	convert_complex

zero_float_dec:				" Zero GENERIC float decimal
	ldx3	default_flt_dec_p,du	" length of decimal
	mvn	(),(pr,rl)
	desc9ls	dec_zero,2
	desc9fl	work|flt_dec_generic,x3
	stz	work|flt_dec_generic_exp
	ldx1	flt_dec_generic_conversion,du
"	tra	convert_complex

convert_complex:
	ldi	mask_faults,dl		" mask for conversion faults
	tsp7	0,x1			" Convert imaginary to target
				
"     Unmask faults for exit.		
				
unmask_exit:
	ldi	unmask_faults,dl
	szn	work|original_source	" was stack extended?
	tze	exit.1
	epbp7	sp|0			" get ptr to base of stack
	inhibit	on		<+><+><+><+><+><+><+><+><+><+><+>
	epp2	sb|stack_header.stack_end_ptr,*	" throw extension
	epp2	pr2|-error_extension
	spri2	sb|stack_header.stack_end_ptr
	spri2	sp|stack_frame.next_sp
	inhibit	off		<-><-><-><-><-><-><-><-><-><-><->

"     Setup A and X7 as if for char_to_numeric_

exit.1:
	lda	work|target_precision	" scale (DU), precision (DL)
	eax7	0,x6			" source type used
	tra	sp|tbp,*x0		" return to caller
"CHAR_TO_NUMERIC_

"	Externally available interface.
"
"	procedure to convert a number to its syntactic numeric form
"	and return such information to caller
"	entered with:
"		source ptr in pr3
"		target ptr in pr1	(must be double-word aligned)
"		work   ptr in pr5
"		source length in q
"		rounding called if x5 non-zero
"
"	exits with:
"		number stored in target
"		number type in x7
"		number precision in al
"		number scale in au

char_to_numeric_:
	ldi	mask_faults,dl		" mask fault on indicators
	ldx6	0,du			" flag target of opportunity
	stq	work|source_string_length
	epp	generic,source|0		" point to source
	tra	char_to_arithmetic		" convert


"     Case table used for zeroing source GENERIC work area

zero_generic:
	arg	error_bad_type
	arg	zero_fixed_bin		" fixed bin signed
	arg	zero_float_bin		" float bin
	arg	zero_float_dec		" float decimal
	arg	zero_fixed_bin		" fixed bin unsigned



"     Following is both a 2 character fixed decimal 0 and a 3 character
"     float decimal 0.0 (normalized).

dec_zero:	aci	"+0 "



"     Following instruction sets are used by execute instructions.  Double
"     pairing is typically used for no-round/round with X5 keying exec.

mvn.pr_rl.pr_rl:
	mvn	(pr,rl),(pr,rl)
	mvn	(pr,rl),(pr,rl),round

dv3d.id.pr.pr_rl:
	dv3d	(id),(pr),(pr,rl)
	dv3d	(id),(pr),(pr,rl),round

dv3d.id.pr_rl.pr_rl:
	dv3d	(id),(pr,rl),(pr,rl)
	dv3d	(id),(pr,rl),(pr,rl),round

mp3d.id.pr_rl.pr_rl:
	mp3d	(id),(pr,rl),(pr,rl)	" index 0 (truncate)
	mp3d	(id),(pr,rl),(pr,rl),round	" index 1 (round)

dv3d.id.pr_rl.pr:
	dv3d	(id),(pr,rl),(pr)
	dv3d	(id),(pr,rl),(pr),round

mp3d.id.pr_rl.pr:
	mp3d	(id),(pr,rl),(pr)
	mp3d	(id),(pr,rl),(pr),round

"Macro Definitions for table driving.

"	macros to define type tables.
"
"	arg1 - Internal routine to convert source or target.
"	arg2 - Generic internal data type.
"	arg3 - FLAGS expression.
"
	maclist	off save

"     Table for source conversion

	macro	stype
	vfd	12/(&3)/64,6/&2,18/get_&1
	vfd	12/(&3)/64,6/&2,18/get_&1_packed
	&end

"     Table for target conversion

	macro	ttype
	vfd	12/(&3)/64,6/&2,18/put_&1
	vfd	12/(&3)/64,6/&2,18/put_&1_packed
	&end


"     Following flags are used to determine what should be done with a
"     data type.
"
"	round 	indicates the default is to round the target.
"	complex	indicates the target or source is complex.
"	short	indicates the target is 1 word float bin for rounding.

	bool	round,400000		" round
	bool	complex,200000		" complex
	bool	short,100000		" single word flt bin
	bool	varying,040000		" varying bit or char string
	bool	simple,020000		" type is not complex
	bool	fix,010000		" data type is fixed

"     The following fields are used to mask out portions of the source and
"     target tables to recover fields.  DU, DL is significant.
"
"	flag_mask		recovers the field containing flags.
"	generic_mask	recovers the field indicating GENERIC type.
"	type_mask		recovers the offset to the conversion routine.

	bool	flag_mask,777700		" DU
	bool	generic_mask,000077		" DU
	bool	type_mask,777777		" DL


"     The following table contains the the GENERIC data type numbers.

	equ	FIXED_BIN,1
	equ	FLOAT_BIN,2
	equ	FLOAT_DEC,3
	equ	FIXED_BIN_UNS,4

	equ	BIT,5
	equ	CHAR,6

"     Fixed binary is divided into FIXED_BIN and FIXED_BIN_UNS because there
"     are distinct operational differences between the two, particularly since
"     a FIXED_BIN_UNS number can appear negative if viewed as a FIXED_BIN
"     number, and right shifts to normalize a FIXED_BIN_UNS number need to be
"     done with LOGICAL rather than arithmetic operations.
"		mapped	input	type

source_type_map:
"( 0);	stype ERROR,0			" FILLER of ERROR
"( 1);	stype fix_bin_1,FIXED_BIN,fix		" fixed binary short
"( 2);	stype fix_bin_2,FIXED_BIN,fix		" fixed binary long
"( 3);	stype flt_bin_1,FLOAT_BIN,round	" float binary short
"( 4);	stype flt_bin_2,FLOAT_BIN,round	" float binary long
"( 5);	stype fix_bin_1,FIXED_BIN,(complex+fix)	" complex fixed binary short
"( 6);	stype fix_bin_2,FIXED_BIN,(complex+fix)	" complex fixed binary long
"( 7);	stype flt_bin_1,FLOAT_BIN,(round+complex)" complex float binary short
"( 8);	stype flt_bin_2,FLOAT_BIN,(round+complex)" complex float binary long
"( 9);	stype fix_dec_9ls,FLOAT_DEC,fix	" fixed decimal 9-bit
"(10);	stype flt_dec_9,FLOAT_DEC,round	" float decimal 9-bit
"(11);	stype fix_dec_9ls,FLOAT_DEC,(complex+fix) " complex fixed decimal 9-bit
"(12);	stype flt_dec_9,FLOAT_DEC,(round+complex) " complex float decimal 9-bit
"(13);	stype ERROR,0			" pointer
"(14);	stype ERROR,0			" offset
"(15);	stype ERROR,0			" label
"(16);	stype ERROR,0			" entry
"(17);	stype ERROR,0			" structure
"(18);	stype ERROR,0			" area
"(19);	stype bit,BIT			" bit
"(20);	stype varying_bit,BIT,varying		" varying bit
"(21);	stype char,CHAR			" character
"(22);	stype varying_char,CHAR,varying	" varying character
"(23);	stype ERROR,0			" file
"(24);	stype ERROR,0			" label constant runtime
"(25);	stype ERROR,0			" int entry runtime
"(26);	stype ERROR,0			" ext entry runtime
"(27);	stype ERROR,0			" ext procedure runtime
"(28);	stype ERROR,0			" RESERVED (type 28)
"(29);	stype fix_dec_9ls_ovrp,FLOAT_DEC,fix	" fixed dec leading overpunch 9-bit
"(30);	stype fix_dec_9ts_ovrp,FLOAT_DEC,fix	" fixed dec trailing overpunch 9-bit
"(31);	stype ERROR,0			" RESERVED (type 31)
"(32);	stype ERROR,0			" RESERVED (type 32)
"(33);	stype fix_bin_1uns,FIXED_BIN_UNS,fix	" fixed binary unsigned short
"(34);	stype fix_bin_2uns,FIXED_BIN_UNS,fix	" fixed binary unsigned long
"(35);	stype fix_dec_9uns,FLOAT_DEC,fix	" fixed decimal unsigned 9-bit
"(36);	stype fix_dec_9ts,FLOAT_DEC,fix	" fixed decimal trailing sign 9-bit
"(37);	stype fix_dec_9ts,FLOAT_DEC,(complex+fix) " complex fixed decimal trailing sign (future??)
"(38);	stype fix_dec_4uns,FLOAT_DEC,fix	" fixed decimal unsigned 4-bit
"(39);	stype fix_dec_4ts,FLOAT_DEC,fix	" fixed decimal trailing sign 4-bit
"(40);	stype fix_dec_4uns,FLOAT_DEC,fix        " fixed decimal unsigned 4-bit byte-aligned
"(41);	stype fix_dec_4ls,FLOAT_DEC,fix	" fixed decimal leading sign 4-bit
"(42);	stype flt_dec_4,FLOAT_DEC,round	" float decimal 4-bit
"(43);	stype fix_dec_4ls,FLOAT_DEC,fix	" decimal leading sign 4-bit byte-aligned
"(44);	stype flt_dec_4,FLOAT_DEC,round	" float decimal 4-bit byte-aligned
"(45);	stype fix_dec_4ls,FLOAT_DEC,(complex+fix) " complex fixed decimal leading sign 4-bit byte-aligned
"(46);	stype flt_dec_4,FLOAT_DEC,(complex+round) " cplx float decimal 4-bit byte-aligned
"(47);	stype flt_hex_1,FLOAT_BIN,round	" float hex single
"(48);	stype flt_hex_2,FLOAT_BIN,round	" float hex double
"(49);	stype flt_hex_1,FLOAT_BIN,(round+complex) " complex float hex single
"(50);	stype flt_hex_2,FLOAT_BIN,(round+complex) " complex float hex double
"(51);	stype ERROR,0			" RESERVED (type 51)
"(52);	stype ERROR,0			" RESERVED (type 52)
"(53);	stype ERROR,0			" RESERVED (type 53)
"(54);	stype ERROR,0			" RESERVED (type 54)
"(55);	stype ERROR,0			" RESERVED (type 55)
"(56);	stype ERROR,0			" RESERVED (type 56)
"(57);	stype ERROR,0			" RESERVED (type 57)
"(58);	stype ERROR,0			" ESCAPE (type 58)
"(59);	stype ERROR,0			" algol68 straight
"(60);	stype ERROR,0			" algol68 format
"(61);	stype ERROR,0			" algol68 array descriptor
"(62);	stype ERROR,0			" algol68 union
"(63);	stype ERROR,0			" picture runtime
"(64);	stype ERROR,0			" EXTRA (64)
"(65);	stype ERROR,0			" EXTRA (65)
"(66);	stype ERROR,0			" EXTRA (66)
"(67);	stype ERROR,0			" EXTRA (67)
"(68);	stype ERROR,0			" EXTRA (68)
"(69);	stype ERROR,0			" EXTRA (69)
"(70);	stype ERROR,0			" EXTRA (70)
"(71);	stype ERROR,0			" EXTRA (71)
"(72);	stype ERROR,0			" EXTRA (72)
"(73);	stype ERROR,0			" EXTRA (73)
"(74);	stype ERROR,0			" EXTRA (74)
"(75);	stype ERROR,0			" EXTRA (75)
"(76);	stype ERROR,0			" EXTRA (76)
"(77);	stype ERROR,0			" EXTRA (77)
"(78);	stype ERROR,0			" EXTRA (78)
"(79);	stype ERROR,0			" EXTRA (79)
"(80);	stype ERROR,0			" EXTRA (80)
"(81);	stype flt_dec_ext,FLOAT_DEC,round	" float dec extended
"(82);	stype flt_dec_ext,FLOAT_DEC,(round+complex) " complex float dec extended
"(83);	stype flt_dec_gen,FLOAT_DEC,round	" float dec generic
"(84);	stype flt_dec_gen,FLOAT_DEC,(round+complex) " complex float dec generic
"(85);	stype flt_bin_gen,FLOAT_BIN,round	" float bin generic
"(86);	stype flt_bin_gen,FLOAT_BIN,(round+complex) " complex float bin generic

	equ	source_map_size,*-source_type_map
"		mapped	output	type

target_type_map:
"( 0);	ttype ERROR,0			" FILLER of ERROR
"( 1);	ttype fix_bin_1,FIXED_BIN		" fixed binary short
"( 2);	ttype fix_bin_2,FIXED_BIN		" fixed binary long
"( 3);	ttype flt_bin_1,FLOAT_BIN,(round+short)	" float binary short
"( 4);	ttype flt_bin_2,FLOAT_BIN,round	" float binary long
"( 5);	ttype fix_bin_1,FIXED_BIN,complex	" complex fixed binary short
"( 6);	ttype fix_bin_2,FIXED_BIN,complex	" complex fixed binary long
"( 7);	ttype flt_bin_1,FLOAT_BIN,(round+complex+short)" complex float binary short
"( 8);	ttype flt_bin_2,FLOAT_BIN,(round+complex)" complex float binary long
"( 9);	ttype fix_dec_9ls,FLOAT_DEC		" fixed decimal 9-bit
"(10);	ttype flt_dec_9,FLOAT_DEC,round	" float decimal 9-bit
"(11);	ttype fix_dec_9ls,FLOAT_DEC,complex	" complex fixed decimal 9-bit
"(12);	ttype flt_dec_9,FLOAT_DEC,(round+complex) " complex float decimal 9-bit
"(13);	ttype ERROR,0			" pointer
"(14);	ttype ERROR,0			" offset
"(15);	ttype ERROR,0			" label
"(16);	ttype ERROR,0			" entry
"(17);	ttype ERROR,0			" structure
"(18);	ttype ERROR,0			" area
"(19);	ttype bit,BIT			" bit
"(20);	ttype varying_bit,BIT,varying		" varying bit
"(21);	ttype char,CHAR			" character
"(22);	ttype varying_char,CHAR,varying	" varying character
"(23);	ttype ERROR,0			" file
"(24);	ttype ERROR,0			" label constant runtime
"(25);	ttype ERROR,0			" int entry runtime
"(26);	ttype ERROR,0			" ext entry runtime
"(27);	ttype ERROR,0			" ext procedure runtime
"(28);	ttype ERROR,0			" RESERVED (type 28)
"(29);	ttype fix_dec_9ls_ovrp,FLOAT_DEC	" fixed dec leading overpunch 9-bit
"(30);	ttype fix_dec_9ts_ovrp,FLOAT_DEC	" fixed dec trailing overpunch 9-bit
"(31);	ttype ERROR,0			" RESERVED (type 31)
"(32);	ttype ERROR,0			" RESERVED (type 32)
"(33);	ttype fix_bin_1uns,FIXED_BIN_UNS	" fixed binary unsigned short
"(34);	ttype fix_bin_2uns,FIXED_BIN_UNS	" fixed binary unsigned long
"(35);	ttype fix_dec_9uns,FLOAT_DEC		" fixed decimal unsigned 9-bit
"(36);	ttype fix_dec_9ts,FLOAT_DEC		" fixed decimal trailing sign 9-bit
"(37);	ttype fix_dec_9ts,FLOAT_DEC,complex	" complex fixed decimal trailing sign (future??)
"(38);	ttype fix_dec_4uns,FLOAT_DEC		" fixed decimal unsigned 4-bit
"(39);	ttype fix_dec_4ts,FLOAT_DEC		" fixed decimal trailing sign 4-bit
"(40);	ttype fix_dec_4uns,FLOAT_DEC		" fixed decimal unsigned 4-bit byte-aligned
"(41);	ttype fix_dec_4ls,FLOAT_DEC		" fixed decimal leading sign 4-bit
"(42);	ttype flt_dec_4,FLOAT_DEC,round	" float decimal 4-bit
"(43);	ttype fix_dec_4ls,FLOAT_DEC		" decimal leading sign 4-bit byte-aligned
"(44);	ttype flt_dec_4,FLOAT_DEC,round	" float decimal 4-bit byte-aligned
"(45);	ttype fix_dec_4ls,FLOAT_DEC,complex	" complex fixed decimal leading sign 4-bit byte-aligned
"(46);	ttype flt_dec_4,FLOAT_DEC,(complex+round) " cplx float decimal 4-bit byte-aligned
"(47);	ttype flt_hex_1,FLOAT_BIN,round	" float hex single
"(48);	ttype flt_hex_2,FLOAT_BIN,round	" float hex double
"(49);	ttype flt_hex_1,FLOAT_BIN,(round+complex) " complex float hex single
"(50);	ttype flt_hex_2,FLOAT_BIN,(round+complex) " complex float hex double
"(51);	ttype ERROR,0			" RESERVED (type 51)
"(52);	ttype ERROR,0			" RESERVED (type 52)
"(53);	ttype ERROR,0			" RESERVED (type 53)
"(54);	ttype ERROR,0			" RESERVED (type 54)
"(55);	ttype ERROR,0			" RESERVED (type 55)
"(56);	ttype ERROR,0			" RESERVED (type 56)
"(57);	ttype ERROR,0			" RESERVED (type 57)
"(58);	ttype ERROR,0			" ESCAPE (type 58)
"(59);	ttype ERROR,0			" algol68 straight
"(60);	ttype ERROR,0			" algol68 format
"(61);	ttype ERROR,0			" algol68 array descriptor
"(62);	ttype ERROR,0			" algol68 union
"(63);	ttype ERROR,0			" picture runtime
"(64);	ttype ERROR,0			" EXTRA (64)
"(65);	ttype ERROR,0			" EXTRA (65)
"(66);	ttype ERROR,0			" EXTRA (66)
"(67);	ttype ERROR,0			" EXTRA (67)
"(68);	ttype ERROR,0			" EXTRA (68)
"(69);	ttype ERROR,0			" EXTRA (69)
"(70);	ttype ERROR,0			" EXTRA (70)
"(71);	ttype ERROR,0			" EXTRA (71)
"(72);	ttype ERROR,0			" EXTRA (72)
"(73);	ttype ERROR,0			" EXTRA (73)
"(74);	ttype ERROR,0			" EXTRA (74)
"(75);	ttype ERROR,0			" EXTRA (75)
"(76);	ttype ERROR,0			" EXTRA (76)
"(77);	ttype ERROR,0			" EXTRA (77)
"(78);	ttype ERROR,0			" EXTRA (78)
"(79);	ttype ERROR,0			" EXTRA (79)
"(80);	ttype ERROR,0			" EXTRA (80)
"(81);	ttype flt_dec_ext,FLOAT_DEC,round	" float dec extended
"(82);	ttype flt_dec_ext,FLOAT_DEC,(round+complex) " complex float dec extended
"(83);	ttype flt_dec_gen,FLOAT_DEC,round	" float dec generic
"(84);	ttype flt_dec_gen,FLOAT_DEC,(round+complex) " complex float dec generic
"(85);	ttype flt_bin_gen,FLOAT_BIN,round	" float bin generic
"(86);	ttype flt_bin_gen,FLOAT_BIN,(round+complex) " complex float bin generic

	equ	target_map_size,*-target_type_map

	maclist	restore
" Register conventions for source GET routines.
" (all routines specified in the table below).  All registers named below,
" must be preserved by the conversion routine.
"
"	pr0	(reserved - pl1_operators_ ptr)
"	pr1	points to target.
"	pr2	points to generic data area
"	pr3	points to source.
"	pr5	points to work area.
"	pr6	(reserved - stack_frame ptr)
"	pr7	points to return location in any_to_any_.
"	x0	return offset in user program.
"	x5	0 if no round, 1 if round.
"	x6	target type.
"	x7	source type.

"	work|scales	stored scales (in upper halves)
"	work|precisions	stored precisions (in lower halves)
"
"     Decimal GET routines leave X3 as the size of the floating decimal
"     generic variable, including sign and hardware exponent.

" Conversion rules go that source and target pointers are updated by the GET
"     and PUT routines respectively, thus they are always up-to-date by the
"     end of the conversion.  This makes converting real and imaginary parts
"     quite easy.  If range errors are detected, they are signalled as
"     appropriate through the singalling routines at the end of this program.
"     Depending upon the type of error signalled, return is done to a float
"     bin or float decimal generic converison, to continue the conversion of a
"     0.0 quantity.  Fixed bin conversion errors simply return.
"
" Conditions of calling conversion routines:
"
"     Fixed Bin:	72-bit value is expected in work|fix_bin_generic.
"     Float Bin:	72-bit value is expected in work|flt_bin_generic,
"		36-bit exponent is expected in work|flt_bin_generic_exp.
"     Float Decimal:X3 has the length of the float decimal number, including
"		the sign and a byte for the hardware exponent.  The float
"		decimal number is left in work|flt_dec_generic and the
"		36-bit software exponent is in work|flt_dec_generic_exp.
"     Fixed Bin uns:72-bit value is expected in work|fix_bin_generic.
"     Bit:	Bit value is pointed to by generic|0.  If necessary the
"		area work|bit_generic can be used for internal storage, BUT
"		it overlays work|flt_dec_generic.  This conflict must be
"		remembered in conversion routines.  In a varying bit string
"		the pointer points at the start of the bit stream, which is
"		one word beyond the length word.  X3 is the length of the
"		bit string (up to 256 bits).
"     Char:	Character string is pointed to by generic|0.  If necessary
"		the area work|char_generic can be used for internal storage
"		and does not conflict with other storage.  X3 is the length
"		of the character string (up to 256 characters).  In a
"		varying character string the pointer points at the start of
"		the character stream, which is one word beyond the length
"		word.
"
" All character conversions require the large work area.Fixed Binary Source Conversion to GENERIC


"     Unsigned Cases


get_fix_bin_1uns:			" Fixed bin single word unsigned
	lda	source|0			" load value
	lrl	36			" position to Q, clear A
	staq	work|fix_bin_generic
	epp	source,source|1		" update source pointer
	tra	fix_bin_uns_generic_conversion


get_fix_bin_1uns_packed:		" Packed fixed bin single unsigned
get_fix_bin_2uns_packed:		" Packed fixed bin double unsigned
	lxl2	work|source_precision
	csl	(pr,rl),(pr,rl),bool(move)
	descb	source|0,x2
	descb	work|fix_bin_generic,x2
	abd	source|0,x2		" update source pointer
	ldaq	work|fix_bin_generic
	erx2	=o777777,du		" form 2's complement precision
	lrl	72+1,2			" position result unsigned
	staq	work|fix_bin_generic
	tra	fix_bin_uns_generic_conversion


get_fix_bin_2uns:			" Fixed bin double word to GENERIC
	ldaq	source|0			" load value
	staq	work|fix_bin_generic
	epp	source,source|2		" update source pointer
	tra	fix_bin_uns_generic_conversion




"     Signed Cases


get_fix_bin_1:			" Fixed bin single word to GENERIC
	lda	source|0			" load value
	lrs	36			" position and sign extend
	staq	work|fix_bin_generic
	epp	source,source|1
	tra	fix_bin_generic_conversion


get_fix_bin_1_packed:		" Packed fixed bin single to GENERIC
get_fix_bin_2_packed:		" Packed fixed bin double to GENERIC
	lxl2	work|source_precision
	adx2	=1,du			" account for sign
	csl	(pr,rl),(pr,rl),bool(move)
	descb	source|0,x2
	descb	work|fix_bin_generic,x2
	abd	source|0,x2		" update source pointer
	ldaq	work|fix_bin_generic
	erx2	=o777777,du		" form 2's complement precision
	lrs	72+1,2			" position result
	staq	work|fix_bin_generic
	tra	fix_bin_generic_conversion


get_fix_bin_2:			" Fixed bin double word to GENERIC fb (71)
	ldaq	source|0			" load value
	staq	work|fix_bin_generic
	epp	source,source|2		" update source pointer
	tra	fix_bin_generic_conversion
"Floating Binary Source Conversion to GENERIC


get_flt_bin_1:			" Floating binary single to generic
	fld	source|0
	epp	source,source|1		" update source pointer
	tra	end_get_flt_bin

get_flt_bin_1_packed:		" Floating binary single packed to generic
get_flt_bin_2_packed:		" Floating binary double packed to generic
	lxl2	work|source_precision
	adx2	=9,du			" account for sign and exponent
	csl	(pr,rl),(pr),bool(move),fill(0)
	descb	source|0,x2
	descb	work|flt_bin_generic,72
	dfld	work|flt_bin_generic
	abd	source|0,x2		" update source pointer
	tra	end_get_flt_bin

get_flt_bin_2:			" Floating binary double to generic
	dfld	source|0
	epp	source,source|2		" update source pointer
"	tra	end_get_flt_bin

end_get_flt_bin:
	tnz	get_flt_bin.zero		" Not zero store as indicated
	stz	work|flt_bin_generic_exp
	stz	work|flt_bin_generic
	stz	work|flt_bin_generic+1
	tra	flt_bin_generic_conversion	" Store absolute zero

get_flt_bin.zero:
	ste	work|flt_bin_generic_exp
	staq	work|flt_bin_generic
	lda	work|flt_bin_generic_exp
	ars	36-8			" position in full exponent
	sta	work|flt_bin_generic_exp
	tra	flt_bin_generic_conversion


"     Get a GENERIC floating binary value.  Storage form is:
"
"	Double word aligned.
"
"	AQ portion of EAQ.  Full 72 bits stored.
"	fixed bin (35) exponent value.
"	PAD word.

get_flt_bin_gen:			" Floating binary generic to internal
	dfld	source|0			" move mantissa, 0->exp
	staq	work|flt_bin_generic
	lde	0,du
	lda	source|2
	sta	work|flt_bin_generic_exp
	epp	source,source|4		" update source pointer
	tra	flt_bin_generic_conversion
"Floating Hexadecimal Source Conversion to GENERIC


get_flt_hex_1:			" Floating hex single to generic
	fld	source|0
	epp	source,source|1		" update source pointer
	tra	end_get_flt_hex

get_flt_hex_1_packed:		" Floating hex single packed to generic
get_flt_hex_2_packed:		" Floating hex double packed to generic
	lxl2	work|source_precision
	adx2	=9,du			" account for sign and exponent
	csl	(pr,rl),(pr),bool(move),fill(0)
	descb	source|0,x2
	descb	work|flt_bin_generic,72
	dfld	work|flt_bin_generic
	abd	source|0,x2		" update source pointer
	tra	end_get_flt_hex

get_flt_hex_2:			" Floating hex double to generic
	dfld	source|0
	epp	source,source|2		" update source pointer
"	tra	end_get_flt_hex

end_get_flt_hex:
	tnz	get_flt_hex.nz		" Not zero - store as indicated
	stz	work|flt_bin_generic_exp
	stz	work|flt_bin_generic
	stz	work|flt_bin_generic+1
	tra	flt_bin_generic_conversion	" Store absolute zero


"     Non-Zero Floating HEXADECIMAL - convert to extended floating binary

get_flt_hex.nz:			
	ste	work|flt_bin_generic_exp
	lde	=0,du			" normalize to binary from hex
	fno
	ste	work|flt_dec_generic_exp
	lde	=0,du			" save 0 exponent
	staq	work|flt_bin_generic
	lda	work|flt_bin_generic_exp	" position for full range
	ars	36-8-2			" single bit shift
	sta	work|flt_bin_generic_exp
	lda	work|flt_dec_generic_exp	" get binary correction
	ars	36-8
	asa	work|flt_bin_generic_exp	" include hex exponent
	tra	flt_bin_generic_conversion
"Fixed Decimal 9-bit Source Conversion to GENERIC

"     ****NOTE**** - X2 MUST contain the fixed decimal length at the point
"	end_get_fix_dec.normalize is called.  These initial routines leave
"	generic pointing to a 9-bit leading signed fixed decimal number.  The
"	final conversion to GENERIC float dec is done by
"	end_get_fix_dec.normalize.

"     9-bit Leading Sign Case

get_fix_dec_9ls:				" Actual work done in
get_fix_dec_9ls_packed:			" end_get_fix_dec.normalize
	lxl2	work|source_precision
	adx2	=1,du			" count sign in size
	epp	generic,source|0			" point to source
	a9bd	source|0,x2		" update source pointer
	tra	end_get_fix_dec.normalize

"     9-bit Leading Sign Overpunched Case

get_fix_dec_9ls_ovrp:
get_fix_dec_9ls_ovrp_packed:
	lxl3	work|source_precision
	eax2	1,x3			" Count sign

"     Move mantissa including overpunched sign, skip sign of generic FD

	mlr	(pr,rl),(pr,rl)
	desc9a	source|0,x3
	desc9a	work|fix_dec_generic(1),x3

"     Translate overpunched sign to sign and leading digit

	scm	(),(pr),mask(000)		" Determine index of sign
	desc9a	overpunch_9_source,20	" Conversion table
	desc9a	source|0,1		" overpunch
	arg	work|flt_dec_generic_exp	" index result
	ttn	error_bad_type		" not convertable

	lda	work|flt_dec_generic_exp
	als	1			" *2 for char index
	mlr	(al),(pr)			" Move in correct codes
	desc9a	overpunch_9_chars,2
	desc9a	work|fix_dec_generic,2
	epp	generic,work|flt_dec_generic	" point to 9bit_ls
	a9bd	source|0,x3		" update source pointer
	tra	end_get_fix_dec.normalize

"     9-bit Trailing Sign Overpunched Case

get_fix_dec_9ts_ovrp:
get_fix_dec_9ts_ovrp_packed:
	lxl3	work|source_precision
	eax2	1,x3			" Count sign

"     Move mantissa including overpunched sign, skip sign of generic FD

	mlr	(pr,rl),(pr,rl)
	desc9a	source|0,x3
	desc9a	work|fix_dec_generic(1),x3

"     Translate overpunched sign to sign and leading digit

	scm	(),(pr,x3),mask(000)	" Determine index of sign
	desc9a	overpunch_9_source,20	" Conversion table
	desc9a	source|-1(3),1		" overpunch
	arg	work|flt_dec_generic_exp	" index result
	ttn	error_bad_type		" not convertable

	lda	work|flt_dec_generic_exp
	mlr	(al),(pr)			" Move sign
	desc9a	overpunch_9_signs,1
	desc9a	work|fix_dec_generic,1
	mlr	(al),(pr,x3)		" Fixup trailing digit
	desc9a	overpunch_9_digits,1
	desc9a	work|fix_dec_generic,1
	epp	generic,work|flt_dec_generic	" point to 9bit_ls
	a9bd	source|0,x3		" update source pointer
	tra	end_get_fix_dec.normalizeFixed Decimal 9-bit Source Conversion to GENERIC


"     9-bit Unsigned Case

get_fix_dec_9uns:
get_fix_dec_9uns_packed:
	lxl4	work|source_precision
	eax2	1,x4			" length of leading sign result
	eax3	1,x2			" size of floating result
	mvn	(pr,rl),(pr,rl)
	desc9ns	source|0,x4
	desc9fl	work|flt_dec_generic,x3
	a9bd	source|0,x3		" update source pointer
	tra	end_get_fix_dec.normalized



"     9-bit Trailing Sign Case

get_fix_dec_9ts:
get_fix_dec_9ts_packed:
	lxl3	work|source_precision
	eax2	1,x3			" size of signed result
	eax3	1,x2			" size of floating result
	mvn	(pr,rl),(pr,rl)
	desc9ts	source|0,x2
	desc9fl	work|flt_dec_generic,x3
	a9bd	source|0,x2		" update source pointer
	tra	end_get_fix_dec.normalized




"     Table used to determine overpunch conversion.  Index provides
"     conversion reference to an overpunch character table.

overpunch_9_source:		" used to translate overpunch to table index
	aci /{ABCDEFGHI}JKLMNOPQR/,20
"	     ++++++++++----------
"	     01234567890123456789

overpunch_9_signs:		" overpunch sign
	aci /++++++++++----------/,20

overpunch_9_digits:		" overpunch digit
	aci /01234567890123456789/,20

overpunch_9_chars:		" index*2 to get sign and leading digit
	aci /+0+1+2+3+4+5+6+7+8+9-0-1-2-3-4-5-6-7-8-9/,40
"Fixed Decimal 4-bit Source Conversion to GENERIC

"     Fourbit source is byte aligned.  Thus we round to next byte in setting
"     the source pointer update.


"     4-bit Leading Sign Case


get_fix_dec_4ls:
get_fix_dec_4ls_packed:
	lxl2	work|source_precision
	adx2	1,du			" count sign in size
	eax3	1,x2			" size of floating result
	mvn	(pr,rl),(pr,rl)
	desc4ls	source|0,x2
	desc9fl	work|flt_dec_generic,x3
	eax2	1,x2			" byte align update
	anx2	=o777776,du
	a4bd	source|0,x2		" update source pointer
	tra	end_get_fix_dec.normalized



"     4-bit Unsigned Case

get_fix_dec_4uns:
get_fix_dec_4uns_packed:
	lxl4	work|source_precision
	eax2	1,x4			" count sign in size
	eax3	1,x2			" size of floating result
	mvn	(pr,rl),(pr,rl)
	desc4ns	source|0,x4
	desc9fl	work|flt_dec_generic,x3
	eax4	1,x4			" byte align update
	anx4	=o777776,du
	a4bd	source|0,x4		" update source pointer
	tra	end_get_fix_dec.normalized



"     4-bit Trailing Sign Case

get_fix_dec_4ts:
get_fix_dec_4ts_packed:
	lxl3	work|source_precision
	eax2	1,x3			" size of signed result
	eax3	1,x2			" size of floating result
	mvn	(pr,rl),(pr,rl)		" move unsigned mantissa
	desc4ts	source|0,x2
	desc9fl	work|flt_dec_generic,x3
	eax2	1,x2			" byte align update
	anx2	=o777776,du
	a4bd	source|0,x2		" update source pointer
	tra	end_get_fix_dec.normalized
"Normalize fixed decimal to floating decimal


"     A source decimal mantissa is currently setup with a correct
"     fixed decimal value.  This is now moved in place to a floating decimal
"     format to establish the 8-bit exponent and round as necessary.  From this
"     the full floating decimal extended exponent is formed, taking into
"     account a possible fixed decimal scale factor.
"
"     On entry generic points to source to convert.  This is simple source pointer
"	for 9bit_ls, or flt_dec_generic pre-cooked to 9bit_ls for others.
"
"     X3 is precision on exit including exponent and sign.


end_get_fix_dec.normalize:
	eax3	1,x2			" Count byte for exponent
	xec	mvn.pr_rl.pr_rl,x5		" float and ?round?
	desc9ls	generic|0,x2
	desc9fl	work|flt_dec_generic,x3

"     The rounded move may alter the exponent value.  We pick up what it
"     set to account for this possibility and integrate the fixed scale
"     factor into the 36-bit exponent.


"     Entry to this point presumes that X3 is the length of the floating
"     decimal number, and that it is already in work|flt_dec_generic.
"     At this point we take the 8-bit hardware exponent and extend it to
"     a full 35 bit signed exponent.

end_get_fix_dec.normalized:			" have floating number
	stz	work|flt_dec_generic_exp	" pre_set exponent
	mlr	(pr,x3),(pr)		" get new exponent
	desc9a	work|flt_dec_generic-1(3),1
	desc9a	work|flt_dec_generic_exp(3),1

	lda	work|source_scale
	ars	18			" full extension
	neg				" and form negative scale
	asa	work|flt_dec_generic_exp	" in full exponent
	tra	flt_dec_generic_conversion	
"Floating Decimal Source Conversion to GENERIC
"     9-bit Case

get_flt_dec_9:
get_flt_dec_9_packed:
	lxl3	work|source_precision
	adx3	1+1,du			" account for sign/exponent
	mvn	(pr,rl),(pr,rl)
	desc9fl	source|0,x3
	desc9fl	work|flt_dec_generic,x3

	mlr	(pr,x3),(pr)		" 8-bit to 36-bit exponent
	desc9a	work|flt_dec_generic-1(3),1
	desc9a	work|flt_dec_generic_exp,1
	lda	work|flt_dec_generic_exp
	alr	1			" skip pad bit in exponent
	ars	36-8			" sign extend
	sta	work|flt_dec_generic_exp
	a9bd	source|0,x3		" update source pointer
	tra	flt_dec_generic_conversion

"     4-bit Case

get_flt_dec_4:
get_flt_dec_4_packed:
	lxl3	work|source_precision
	eax2	1+2,x3			" 4-bit sign/exponent
	adx3	1+1,du			" form length 9-bit
	mvn	(pr,rl),(pr,rl)
	desc4fl	source|0,x2
	desc9fl	work|flt_dec_generic,x3
	mlr	(pr,x3),(pr)		" Expand the exponent
	desc9a	work|flt_dec_generic-1(3),1
	desc9a	work|flt_dec_generic_exp,1
	lda	work|flt_dec_generic_exp
	alr	1			" skip pad bit in exponent
	ars	36-8			" sign extend
	sta	work|flt_dec_generic_exp
	eax2	1,x2			" byte align update
	anx2	=o777776,du
	a4bd	source|0,x2		" update source pointer
	tra	flt_dec_generic_conversion

"     9-bit extended Case (has 9-bit rather than 8-bit exponent)

get_flt_dec_ext:
get_flt_dec_ext_packed:
	lxl3	work|source_precision
	adx3	1+1,du			" account for sign/exponent
	mvn	(pr,rl),(pr,rl)
	desc9fl	source|0,x3
	desc9fl	work|flt_dec_generic,x3

"     Expand the exponent (pick from source since mvn kills high bit)

	mlr	(pr,x3),(pr)		" 9-bit to 36-bit exponent
	desc9a	source|-1(3),1
	desc9a	work|flt_dec_generic_exp,1
	lda	work|flt_dec_generic_exp
	ars	36-9			" sign extend
	sta	work|flt_dec_generic_exp
	a9bd	source|0,x3		" update source pointer
	tra	flt_dec_generic_conversion

"     9-bit generic Case.  Has leading 36-bit exponent.

get_flt_dec_gen:		" move to generic to get hardware exponent.
	lda	source|0			" get exponent
	sta	work|flt_dec_generic_exp
	lxl2	work|source_precision
	adx2	1,du			" account for sign
	eax3	1,x2			" account for hard exponent
	mlr	(pr,rl),(pr,rl),fill(000)	" move and clear exp
	desc9a	source|1,x2
	desc9a	work|flt_dec_generic,x3
	eax2	3,x2			" set round of mantissa len
	a9bd	source|0,x2		" increment and round
	adwp	source,1,du
	tra	flt_dec_generic_conversionBit Source Conversion to FINA

"     Bit conversion to final target.
"
"     Conversion to numeric converts to fixed bin (71, 0) or fixed bin
"     unsigned (72, 0) and continues to final target.  A bit source is
"     non-complex, so normal conversion to 0 of the imaginary part will
"     occur.  Since we have no imaginary part for source, we do not move
"     the source pointer.  Source length is left in X3.  We use generic to 
"     point to the source to be converted.  This permits us to later add
"     other boolean types converting to a generic form.

get_varying_bit:
	lxl3	source|-1			" load length of varying
	sxl3	work|source_precision
	tra	get_bit.set_source

get_bit:
get_bit_packed:
	lxl3	work|source_precision	" get length of bits

"     Set pointer to bit source.  For now it is in true source.

get_bit.set_source:
	epp	generic,source|0			" point to source of bits.
	tra	bit_generic_conversion





"Character source conversion to TARGET

"     Character input routines convert a varying string to a fixed length
"     string, and make a pointer to the string.

"     Standard is string is pointed to by generic, and current length is in
"     work|source_precision.
"     If we are converting to a numeric form, then we take over control and
"     convert to float decimal, then continue with a float decimal to TARGET
"     conversion.  If we are converting to bit we do a simple conversion, as
"     with conversion to character.

get_varying_char:
	lda	source|-1			" get length of varying char
	sta	work|source_precision

get_char:
get_char_packed:
	epp	generic,source|0
	lxl3	work|source_precision
	eaa	0,x3			" save source length
	ars	18
	sta	work|source_string_length
	tra	char_to_generic
"Conversion Routines - Fixed bin to target GENERIC

fix_bin_generic_conversion:
	ldx1	target_type_map,x6		" determine target GENERIC
	anx1	generic_mask,du		" mask for type
	tra	fix_bin_generic_case,x1*

fix_bin_generic_case:
	arg	error_bad_type
	arg	fix_bin_to_fix_bin
	arg	fix_bin_to_flt_bin
	arg	fix_bin_to_flt_dec
	arg	fix_bin_to_fix_bin_uns
	arg	fix_bin_to_bit
	arg	fix_bin_to_char

"     Fixed bin to fixed bin unsigned differs from fixed bin to fixed bin for
"     left scaling since moving a bit into the sign position would erroneously
"     trigger a size error.  Right shift is fine since sign bit is clear.

fix_bin_to_fix_bin_uns:			" convert to unsigned target
	ldaq	work|fix_bin_generic
	tmi	size_error		" cannot convert negative
	ldx2	work|target_scale		" determine cross-scaling
	sbx2	work|source_scale
fix_bin.fix_bin_uns.flt:			" entry from flt_bin_to_fixun
	tze	generic_to_target		" scales match
	tmi	fix_bin.scale_right		" need right shift and ?round?

"     Overflow detection means generating a mask of the number of bits to
"     be shifted left to determine if this area is non-zero, if so then we
"     will overflow.

	lda	=o400000,du		" get mask bit
	ldq	=0,dl
	lrs	-1,x2			" generate mask
	anaq	work|fix_bin_generic
	tnz	size_error		" we would overflow

	ldaq	work|fix_bin_generic
	lls	0,x2
	tra	fix_bin.noscale

"     Convert fixed bin to fixed bin.  Here it is mainly a matter of scaling
"     to ensure the target scale factor is correct.

fix_bin_to_fix_bin:
	ldx2	work|target_scale		" determine cross-scaling
	sbx2	work|source_scale
fix_bin.fix_bin.flt:			" entry from flt_bin_to_fix
	tze	generic_to_target		" scales match
	tmi	fix_bin.scale_right		" need right shift and ?round?

fix_bin.scale_left:				" left shift zero fill
	ldaq	work|fix_bin_generic
	lls	0,x2
	trc	size_error		" overflow
	tra	fix_bin.noscale

"     Right scaling may require a round.  Negative rounds down, positive
"     rounds up.  Do this by determining the bit position to round at.  This
"     rounding bit will be good for both positive and negative values.

fix_bin.scale_right:			" right shift and ?round?
	erx2	=o777777,du		" form shift count-1
	eax4	0,x5			" determine if rounding
	tze	fix_bin.noround
	ldaq	one			" load mask for rounding
	lls	0,x2			" determine round bit
	anaq	work|fix_bin_generic
	tnz	fix_bin.noround
	eax4	0			" force no round
fix_bin.noround:
	ldaq	work|fix_bin_generic
	tpl	fix_bin.scale.posConversion Routines - Fixed bin to GENERIC right scaling.

"     Right scale is done by negate, scale/round and negate again, since
"     right shift is not a true arithmetic divide unless positive.
"     In the special case of 400000000000000000000000 we overflow the negate
"     and special case correct through fix_bin.right.ovfl.

	negl
	tov	fix_bin.right.ovfl		" special case overflow
	lrs	1,x2			" scale
	xec	binary_round,4		" round as appropriate
	tov	size_error
	negl				" correct result
	tra	fix_bin.noscale

"     Single special case of only high order bit set.  Positive would set
"     bit above top of register.  Do signed shift right since shift count
"     cannot be beyond end of word.  And no round can occur in this case.

"     We still are masked for overflows and cannot detect further hardware
"     overflows without clearing and resetting the indicator mask.
"     When we enter the high order bit is set by negl and is still correct
"     as signed value.

fix_bin.right.ovfl:
	lrs	1,x2			" scale
	tra	fix_bin.noscale

fix_bin.scale.pos:
	lrs	1,x2			" scale number
	xec	binary_round,4		" round positive or negative
	tov	size_error		" out-of-range
fix_bin.noscale:				" no scaling needed, no round
	staq	work|fix_bin_generic
	tra	generic_to_target

	even
one:	dec	0,1			" must be double word aligned

binary_round:
	nop	0			" no round positive (index 0)
	adl	=1,dl			" round positive	(index 1)
"Conversion Routines - Fixed bin to target GENERIC (float bin)


"     Convert fixed bin to float bin by floating the AQ, setting the
"     exponent and normalizing.  Then move the final exponent to the generic
"     float bin exponent field and set the generic float bin mantissa.

"     Rounding of short and long targets is done here since fixed bin is longer
"     than 63 bits and we would otherwise be numerically incorrect in certain
"     cases.  Since we are rounding anyway we do short at the same time.

fix_bin_to_flt_bin:
	lda	work|source_scale		" exponent including scale
	ars	18			" clip precision
	neg	0			" form -scale (b25)
	ada	=71,dl			" add integer scaling
	als	36-8
	sta	work|flt_bin_generic_exp
	ldaq	work|fix_bin_generic
	lde	work|flt_bin_generic_exp
	fno
	tze	fix_bin.flt.zero		" store extended 0.0
	ste	work|flt_bin_generic_exp	" save exponent
	staq	work|flt_bin_generic
	lda	work|flt_bin_generic_exp
	ars	36-8			" form 36-bit exp
	sta	work|flt_bin_generic_exp
	tra	generic_to_target

"     Store an exact 0.0 in internal generic.  This has exponent of 0.

fix_bin.flt.zero:			" zero float bin then convert to target
	stz	work|flt_bin_generic_exp
	stz	work|flt_bin_generic
	stz	work|flt_bin_generic+1
	tra	generic_to_target		" convert to target
"Conversion Routines - Fixed bin to target GENERIC (float decimal)


"     On exit X3 is the precision of the flt_dec_generic value.

"     Initial coding uses BTD instruction and EIS divide to provide result of
"     scaling.  This may be improved later.


fix_bin_to_flt_dec:
	ldaq	work|fix_bin_generic	" see if zero
	tze	force_zero		" which is fast conversion

"     Determine precision of conversion.

	lde	=72b25,du			" pre-set bit count
	fno				" find high bit
	ste	work|flt_bin_generic
	lda	work|flt_bin_generic	" find true precision
	ars	36-8
	ldx4	bin_prec_to_dec_prec,al	" get digits needed
	lxl2	bin_prec_to_dec_prec,al	" get size of source bytes
	eax1	-9,x2			" determine offset of source
	erx1	=o777777,du
	btd	(pr,x1,rl),(pr,rl)
	desc9a	work|fix_bin_generic,x2
	desc9ls	work|flt_dec_generic,x4
	stz	work|flt_dec_generic_exp	" kill flt dec exponent

	eax3	1,x4			" size of float decimal
	ldx2	work|source_scale		" determine power to divide
	tze	generic_to_target		" simple move
	tmi	fix_bin_to_flt_dec.neg_scale

"     Divide will provide a leading 0 in most cases.  So we divide to one
"     digit more precision.  Convert fixed decimal to float decimal.

	adx3	1,du			" one more digit for divide
	xec	dv3d.id.pr_rl.pr_rl,x5	" scale the output
	arg	two_table,x2		" power of two
	desc9ls	work|flt_dec_generic,x4
	desc9fl	work|flt_dec_generic,x3
	tra	fix_bin_to_flt_dec.common

fix_bin_to_flt_dec.neg_scale:
	erx2	=o777777,du
	adx2	=1,du			" negate x2
	xec	mp3d.id.pr_rl.pr_rl,x5	" scale the output
	arg	two_table,x2		" power of two
	desc9ls	work|flt_dec_generic,x4
	desc9fl	work|flt_dec_generic,x3

fix_bin_to_flt_dec.common:
	mlr	(pr,x3),(pr)		" pick and extend exponent
	desc9a	work|flt_dec_generic-1(3),1
	desc9a	work|flt_dec_generic_exp,1
	lda	work|flt_dec_generic_exp
	als	1
	ars	36-8
	sta	work|flt_dec_generic_exp
	tra	generic_to_target
"Conversion Routines - Fixed bin to target GENERIC (bit)

"     Entry condition is a fixed bin value in fix_bin_generic.
"     We convert the fix bin source to fixed bin (71, 0), obeying all normal
"     conversion rules.  Code highly congruent with fix_bin_to_fix_bin.


fix_bin_to_bit:
	ldx2	work|source_scale
fix_bin.bit.flt:				" entry from flt_bin_to_bit
	tze	to_bit			" scales match
	tpl	fix_bin.bit.scale_right	" need right shift and ?round?

fix_bin.bit.scale_left:			" left shift zero fill
	ldaq	work|fix_bin_generic
	erx2	=o777777,du
	adx2	=1,du			" negate x2
	lls	0,x2
	trc	size_error		" overflow
	tra	to_bit			" value is good

fix_bin.bit.scale_right:			" right shift with round
	eax4	0,x5			" determine if rounding
	tze	fix_bin.bit.noround
	ldaq	one			" load mask for rounding
	lls	-1,x2			" determine round bit
	anaq	work|fix_bin_generic
	tnz	fix_bin.bit.noround
	eax4	0			" force no round

fix_bin.bit.noround:
	ldaq	work|fix_bin_generic
	tpl	fix_bin.bit.scale.pos
	negl				" result left as positive
	tov	fix_bin.bit.right.ovfl	" special case overflow
	lrs	0,x2			" scale
	xec	binary_round,4		" round as appropriate
	tov	size_error
	tra	to_bit

fix_bin.bit.right.ovfl:
	lrs	0,x2			" scale
	tra	to_bit

fix_bin.bit.scale.pos:
	lrs	0,x2			" scale number
	xec	binary_round,4		" round positive or negative
	tov	size_error		" out-of-range

"     Convert to generic bit string.  This is done by moving bits for the
"     precision of the source, subtracting the scale factor first.
"     On entry the AQ holds a fixed bin (71, 0) number.

to_bit:
	ldi	mask_faults,dl		" reset faults
	staq	work|fix_bin_generic	" save fix bin (71, 0)
	szn	work|fix_bin_generic	" see if negative
	tpl	to_bit.pos
	negl
	tov	size_error		" won't fit in (71,0)
	staq	work|fix_bin_generic

to_bit.pos:
	epp	generic,work|bit_generic	" set generic area
	lxl2	work|source_precision	" determine start bit to move
	sbx2	work|source_scale
	eax4	-73,x2
	erx4	=o777777,du		" start = 72-precision
	tpl	fix_bin.bit.non_null	" string not null
	ldx3	0,du			" length is 0
	tra	generic_to_target		" output "0" bits

fix_bin.bit.non_null:
	lls	-1,x4			" shift out skipped part
	trc	size_error		" number is too big
	lxl3	work|target_precision
	csl	(pr,x4,rl),(pr,rl),bool(move),fill(0)
	descb	work|fix_bin_generic,x2
	descb	generic|0,x3
	tra	generic_to_target		" store resultConversion Routines - Float bin to target GENERIC


"     Entry condition is the flt_bin_generic value.  Only global register
"     assignments hold for other registers, like X6, X7, etc.

flt_bin_generic_conversion:
	ldx1	target_type_map,x6		" determine target GENERIC
	anx1	generic_mask,du		" mask for type
	tra	flt_bin_generic_case,x1*

flt_bin_generic_case:
	arg	error_bad_type
	arg	flt_bin_to_fix_bin
	arg	generic_to_target		" trivial conversion
	arg	flt_bin_to_flt_dec
	arg	flt_bin_to_fix_bin_uns
	arg	flt_bin_to_bit
	arg	flt_bin_to_char

"     Fixed bin signed and unsigned are similar conversions.  Conversion is
"     done by considering the floating point mantissa to be a scaled fixed
"     binary number.  The scale is determined to be fixed bin (71,71-exp).

flt_bin_to_fix_bin_uns:
	ldaq	work|flt_bin_generic
	tmi	size_error		" must be positive
	staq	work|fix_bin_generic

"     Form scale factor from exponent.

	lda	=72,dl			" scaling
	sba	work|flt_bin_generic_exp	" - exponent
	tmi	size_error
	sba	1,dl			" correct for ranging
	eax2	0,al
	als	36-8			" initial ranging
	trc	size_error
	cmpx2	=72,du			" unsigned limit
	tpnz	size_error		" too big

"     Form shift factor according to target scale.

	sbx2	work|target_scale
	erx2	=o777777,du		" form target-source
	adx2	1,du
	tra	fix_bin.fix_bin_uns.flt


"     Convert float binary to fixed binary signed.

flt_bin_to_fix_bin:
	ldaq	work|flt_bin_generic	" save integer bits of AQ
	staq	work|fix_bin_generic

"     Form scale factor from exponent

	lda	=71,dl			" scaling
	sba	work|flt_bin_generic_exp	" - exponent
	tmi	size_error
	eax2	0,al			" xfer for store
	als	36-8			" initial ranging
	trc	size_error
	cmpx2	=71,du			" signed limit
	tpnz	size_error		" too big

"     Form shift factor according to target scale.

	sbx2	work|target_scale
	erx2	=o777777,du		" form target-source
	adx2	1,du
	tra	fix_bin.fix_bin.flt		" enter and process
"Conversion Routines - Float Binary to Float Decimal GENERIC

"     Floating binary conversion utilizes a sectioning technique to
"     convert through the total range.  This will produce errors towards
"     the limits of the range unfortunately.  Hopefully this technique
"     will be replaced in the near future.

"     Essentially we find a corrected exponent for the float binary number
"     to account for the precision.  This will be a power of two multiplier.
"     The mantissa is converted to an integer of precision 63, by storing
"     the EAQ's AQ after shifting 8 bits.

"     We convert this to hardware float decimal with a zero exponent, and
"     store a zero exponent in the flt_dec_generic.

"     We convert from this decimal value to the final decimal value by
"     adjusting for the floating point bin's original exponent, by multiplying
"     or dividing by two as appropriate.  We section through the range of
"     the table taking into account that 2**m is equivalent to 2**(n+o) by
"     using the limit of the table as the limit of powers of two for each step.
"     Multiply has an extra digit of precision and divide has two.

"     Due to the hardware characteristic that a divide may result in a leading
"     0 on the float dec mantissa, we use extra precision and move the result
"     to normalize and round.

"     On exit, X3 is length of final floating result.
"     During operations X4 is the length of the current result.  It starts as
"     the length of the initial BTD, and continues during mult or division.

flt_bin_to_flt_dec:
	ldaq	work|flt_bin_generic
	tze	force_zero		" zero float bin

"     Form the initial decimal estimate.

	lrs	8			" clear out 8-dummy bits
	staq	work|flt_bin_generic
	lda	63,dl			" precision is flt bin (63)
	cmpq	=0,dl			" see if q is clear
	tnz	flt_bin_to_flt_dec.go	" use full precision
	lda	27,dl			" precision is flt bin (27)

"     We have precision in al.  Do the work.

flt_bin_to_flt_dec.go:
	ldx4	bin_prec_to_dec_prec+1,al	" get precision of target
	lxl1	bin_prec_to_dec_prec+1,al	" get size of source
	lxl3	work|target_precision	" setup target precision
	adx3	2,du			" sign+exp
	eax2	2,x3			" over-length for divide
	sbx4	1,du			" fixed decimal length
	stz	work|flt_dec_generic_exp	" output number exponent

"     Convert mantissa to decimal.

	btd	(pr,rl),(pr,rl)
	desc9a	work|flt_bin_generic,x1
	desc9ls	work|flt_dec_generic,x4
	adx4	1,du			" account for exponent
	mlr	(),(pr,x4),fill(000)	" clear exponent
	zero
	desc9a	work|flt_dec_generic-1(3),1

"     Correct exponent to power of two of representation.

	ldx1	two_table_limit,du		" load range limit
	neg				" -precision
	ada	work|flt_bin_generic_exp	" now power of two
	tze	flt_bin.flt_dec.to_target	" no work at all
	tpl	flt_bin.flt_dec.start_pos	" positive power of two
	neg				" correct exponent
	tra	flt_bin.flt_dec.start_neg	" -ve power of two

"     Start a section of conversion.

flt_bin.flt_dec.start_pos:
	cmpa	two_table_limit,dl		" within table range?
	tpl	flt_bin.flt_dec.set_pos	" above range
	eax1	0,al			" use exponent remainder

flt_bin.flt_dec.set_pos:
	xec	mp3d.id.pr_rl.pr_rl,x5	" power and round
	arg	two_table,x1
	desc9fl	work|flt_dec_generic,x4	" initial length
	desc9fl	work|flt_dec_generic,x3

"     Build generic float decimal exponent.

	mlr	(pr,x3),(pr)		" X4 is current fix dec len
	desc9a	work|flt_dec_generic-1(3),1	" hardware exponent
	desc9a	work|fix_bin_generic,1

	ldq	work|fix_bin_generic	" sign extend and add
	qls	1
	qrs	36-8
	asq	work|flt_dec_generic_exp

"     See if all done the binary exponent.

	sba	two_table_limit,dl
	tmoz	generic_to_target		" done
	eax4	0,x3			" flt dec length
	mlr	(),(pr,x4),fill(000)	" clear exponent
	zero
	desc9a	work|flt_dec_generic-1(3),1
	tra	flt_bin.flt_dec.start_pos

flt_bin.flt_dec.to_target:
	eax3	0,x4			" length of BTD output
	tra	generic_to_target
"Conversion Routine - Float Binary to Float Decimal GENERIC (Continued)

"     Negative power of two done by divide.  We divide overlength to
"     preserve precision and account for divide characteristic where the
"     mantissa gets a leading zero if the divisor is greater than or equal
"     to the dividend.  A later MVN collapsing the precision will fix the
"     leading zero.

flt_bin.flt_dec.start_neg:
	cmpa	two_table_limit,dl		" check range of section
	tpl	flt_bin.flt_dec.set_neg	" above range
	eax1	0,al			" get remaining exp

flt_bin.flt_dec.set_neg:
	dv3d	(id),(pr,rl),(pr,rl)
	arg	two_table,x1
	desc9fl	work|flt_dec_generic,x4
	desc9fl	work|flt_dec_generic,x2	" one byte larger
	cmpa	two_table_limit,dl		" will we continue?
	tpl	flt_bin.flt_dec.neg_continue
	eax3	0,x2			" done, finish exp move
	tra	flt_bin.flt_dec.neg_done

flt_bin.flt_dec.neg_continue:			" needs move to normalize
	xec	mvn.pr_rl.pr_rl,x5
	desc9fl	work|flt_dec_generic,x2
	desc9fl	work|flt_dec_generic,x3

"     Powering section done.  Pick up hardware exponent and add to the
"     generic exponent.  Clear hardware exponent and continue.

flt_bin.flt_dec.neg_done:
	mlr	(pr,x3),(pr)		" X4 is current fix dec len
	desc9a	work|flt_dec_generic-1(3),1	" hardware exponent
	desc9a	work|fix_bin_generic,1

	ldq	work|fix_bin_generic	" sign extend and add
	qls	1
	qrs	36-8
	asq	work|flt_dec_generic_exp

	sba	two_table_limit,dl		" account for work done
	tmoz	generic_to_target		" done
	eax4	0,x3			" float decimal length
	mlr	(),(pr,x4),fill(000)	" clear exponent
	zero
	desc9a	work|flt_dec_generic-1(3),1
	tra	flt_bin.flt_dec.start_neg
"Conversion Routines - Float bin to target GENERIC (bit)

"     Entry condition is a generic float bin value in flt_bin_generic.
"     We convert the flt bin source to fixed bin (71, 0), obeying all normal
"     conversion rules. 


flt_bin_to_bit:
	ldaq	work|flt_bin_generic	" save integer bits of AQ
	staq	work|fix_bin_generic

"     Form scale factor from exponent

	lda	=71,dl			" scaling
	sba	work|flt_bin_generic_exp	" - exponent
	tmi	size_error
	eax2	0,al			" xfer for store
	als	36-8			" initial ranging
	trc	size_error
	cmpx2	=71,du			" signed limit
	tpnz	size_error		" too big
	cmpx2	0,du			" set indicators
	tra	fix_bin.bit.flt		" continue in fixed binConversion Routines - Float decimal to target GENERIC

"     Entry condition is float decimal source in flt_dec_generic with X3
"     as the precision of this number.  Extended exponent is in
"     flt_dec_generic_exp, with the vestigial hardware float decimal exponent
"     of flt_dec_generic_exp as a don't-care value.

"     This routine ensures that the hardware float decimal exponent is set to
"     0 prior to conversion, to ensure ease of conversion.

flt_dec_generic_conversion:
	mlr	(),(pr,x3),fill(000)
	zero				" put in a 0 value
	desc9a	work|flt_dec_generic-1(3),1	" to the exponent

	ldx1	target_type_map,x6		" find target GENERIC
	anx1	generic_mask,du		" mask for type
	tra	flt_dec_generic_case,x1*

"     flt_dec_to_flt_dec is a trivial conversion since on entry X3 has the
"     precision of the flt_dec_generic and this is what the put routines use.
"     Thus we match at this point by design.

flt_dec_generic_case:
	arg	error_bad_type
	arg	flt_dec_to_fix_bin
	arg	flt_dec_to_flt_bin
	arg	generic_to_target		" trivial conversion
	arg	flt_dec_to_fix_bin_uns
	arg	flt_dec_to_bit
	arg	flt_dec_to_char

"     Convert float decimal to scaled or unscaled fixed binary.

flt_dec_to_fix_bin:
	lxl4	work|target_precision	" find conversion precision
	ldx4	bin_prec_to_dec_prec,x4
	ldx2	work|target_scale		" is bin an integer?
	tze	flt_dec.fix_bin.no_scale	" yes
	tmi	flt_dec.fix_bin.neg_scale	" negative scale

"     Scale the float decimal value by the integer's power of two scale

	mp3d	(id),(pr,rl),(pr,rl)
	arg	two_table,x2
	desc9fl	work|flt_dec_generic,x3
	desc9fl	work|flt_dec_generic,x4
	tnz	flt_dec.fix_bin.exp_change

"     flt_dec.fix_bin.zero assumes x3 is current position of exp and
"     therefore the length of the source.  Make this true in case of
"     zero value, since x4 now holds length after mp3d or dv3d.

flt_dec.fix_bin.zero_fix:
	eax3	0,x4			" mp3d or dv3d length is x4
	tra	flt_dec.fix_bin.zero

flt_dec.fix_bin.neg_scale:			" negative scale is divide
	adx4	1,du			" extra digit for hardware
	lcx2	work|target_scale		" get |scale|
	dv3d	(id),(pr,rl),(pr,rl)
	arg	two_table,x2
	desc9fl	work|flt_dec_generic,x3
	desc9fl	work|flt_dec_generic,x4
	tze	flt_dec.fix_bin.zero_fix	" zero value
"	tra	flt_dec.fix_bin.exp_change

"     Integrate possible exponent change.

flt_dec.fix_bin.exp_change:
	eax3	0,x4			" x3 is now exp offset
	mlr	(pr,x3),(pr)
	desc9a	work|flt_dec_generic-1(3),1
	desc9a	work|flt_bin_generic_exp,1
	lda	work|flt_bin_generic_exp
	als	1
	ars	36-8
	asa	work|flt_dec_generic_exp
"     See if exponent is too big.  If not, then convert to fixed decimal
"     and then to binary.  We leave it in place as correct.  Exp offset is
"     assumed to be in x3.

flt_dec.fix_bin.no_scale:
	lda	work|flt_dec_generic_exp
	als	36-8
	trc	decimal_range_error		" range outside of flt dec
	mlr	(pr),(pr,x3)		" install hardware exp
	desc9a	work|flt_dec_generic_exp(3),1
	desc9a	work|flt_dec_generic-1(3),1

flt_dec.fix_bin.zero:			" x3 is assumed source length
	eax4	-1,x4			" target leading sign length
	xec	mvn.pr_rl.pr_rl,x5		" create fixed decimal
	desc9fl	work|flt_dec_generic,x3
	desc9ls	work|flt_dec_generic,x4
	dtb	(pr,rl),(pr)
	desc9ls	work|flt_dec_generic,x4
	desc9a	work|fix_bin_generic,8
	tov	flt_dec.fix_bin.ovfl	" may be bad may be -2**71
	tra	generic_to_target

"     Check if we had the value -2361183241434822606848, if not - size_error.

flt_dec.fix_bin.ovfl:
	cmpn	(pr,rl),()
	desc9ls	work|flt_dec_generic,x4
	desc4ls	max_fix_bin.dec,23
	tnz	size_error		" was out-of-range
	fld	=1b26,du			" get high-order bit
	staq	work|fix_bin_generic
	ldi	mask_faults,dl		" clear overflow and mask
	tra	generic_to_target

max_fix_bin.dec:
	ac4 /-2361183241434822606848/,23
"Conversion Routines - Flt Decimal to target GENERIC (flt bin)

"     Convert float decimal value to an appropriate fixed decimal value
"     which will have all bits of significance for the final float bin
"     value.

"     On entry X3 contains the precision of the flt_dec_generic.

"     Algorithm finds the power of ten expressed in the float decimal, by
"     finding the leading zero's, the exponent and the precision as:
"
"	mag = precision + exponent - leading_zeros
"
"     From this and the log identity of base conversion, we determine a
"     top binary exponent which will cover this number as:
"
"	bin_exp = ceil (mag*log2(10))	- log2(10) = 3.321928095
"
"     This provides a power of two by which to scale the floating number, prior
"     to converting it to binary.  This power is adjusted by the binary point
"     position of the floating point number.

flt_dec_to_flt_bin:
	lxl3	work|source_precision
	tct	(pr,rl)			" count leading zeros
	desc9a	work|flt_dec_generic(1),x3	" miss sign and exponent
	desc9a	zero_skip
	arg	work|fix_bin_generic
	ttn	store_float_bin_zero	" all digits are "0"

"     At this point fix_bin_generic has the leading zero count.
	lda	=o177,dl			" mask for zero count
	ansa	work|fix_bin_generic
	lxl1	work|fix_bin_generic	" leading zero count
	ldq	work|flt_dec_generic_exp	" exponent in Q
	eaa	-1,x3			" precision
	ars	18
	ssa	work|fix_bin_generic	" precision - lead zero
	tmi	store_float_bin_zero

"     Setup registers for scale series.  Determine precision ceiling needed
"     from precision of both source and target.  Take the larger to govern
"     sufficient precision for operation.  Use extra digit for extension
"     precision needed for floating round.
"
"	x2 is overlength precision of divide
"	x3 is running precision (starts at flt dec input length)
"	x4 is output precision of normalize

	eax3	2,x3			" precision+sign+exp
	lxl4	work|target_precision	" form output from target
	ldx4	bin_prec_to_dec_prec,x4	" including sign/exp
	adx4	2,du			" with extra digit+extension
	eax2	1,x4			" extra again for divide
	stx3	work|flt_bin_generic	" save for max
	cmpx4	work|flt_bin_generic	" see if source or target larget
	tpnz	flt_dec.flt_bin.max_prec
	eax4	1,x3			" take precision from source
	eax2	2,x3			" overlength for divide
flt_dec.flt_bin.max_prec:
	adq	work|fix_bin_generic	" exp + prec - LZ
	mpy	log2.10
	lls	3			" scale back
	sta	work|flt_bin_generic_exp	" save initial exponent stab
"Precision correction.

"     In order to maximize conversion precision, we determine the precision
"     needed to contain the high order digit of the mantissa.  This is
"     subtracted from the precision of the EAQ to determine the power of two
"     needed to produce maximum possible conversion precision.

"     From leading zero count, determine the first non-zero digit value and
"     move to work|fix_bin_generic filling high with zero.  Determine the 
"     precision correction needed to bring us to float_bin 70 to 71.

	mrl	(pr,x1),(pr),fill(000)	" zero fill for ldx1 pickup
	desc9a	work|flt_dec_generic(1),1
	desc9a	work|fix_bin_generic,2
	ldx1	work|fix_bin_generic	" get high digit - convert
	ldx1	digit_to_prec-48,x1		" pick up precision-correct 0
	stz	work|fix_bin_generic	" clear storage
	sxl1	work|fix_bin_generic	" save precision correction
	ada	work|fix_bin_generic	" correct float_bin 71 prec
	sba	=71,dl			" correct alignment
	sta	work|fix_bin_generic	" save as final power
	tmi	flt_dec.flt_bin.scale_up

flt_dec.flt_bin.scale_dwn:			" Scale down by power of two
	cmpa	two_table_limit,dl		" within table range?
	tmoz	flt_dec.flt_bin.dwn.final	" yes final to fixed
	lda	two_table_limit,dl		" scale-down section
	dv3d	(id),(pr,rl),(pr,rl)	" down-scale mantissa
	arg	two_table,al
	desc9fl	work|flt_dec_generic,x3
	desc9fl	work|flt_dec_generic,x2	" overlength for precision
	xec	mvn.pr_rl.pr_rl,x5
	desc9fl	work|flt_dec_generic,x2
	desc9fl	work|flt_dec_generic,x4
	neg				" subtract work done
	tra	flt_dec.flt_bin.done
"     Scale up by appropriate power of two.

flt_dec.flt_bin.scale_up:
	neg				" form absolute
	cmpa	two_table_limit,dl		" within table range?
	tmoz	flt_dec.flt_bin.up.final	" yes final to fixed
	lda	two_table_limit,dl		" scale-up section
	xec	mp3d.id.pr_rl.pr_rl,x5	" up-scale mantissa ?round?
	arg	two_table,al
	desc9fl	work|flt_dec_generic,x3
	desc9fl	work|flt_dec_generic,x4	" overlength for precision
"	tra	flt_dec.flt_bin.done


"     Powering section done.  Fix up work done is scaling to bin exp.

flt_dec.flt_bin.done:
	eax3	0,x4			" expand size of flt_dec
	asa	work|fix_bin_generic	" count work done

	mlr	(pr,x4),(pr)		" update exponent
	desc9a	work|flt_dec_generic-1(3),1
	desc9a	work|fix_bin_generic+1,1
	lda	work|fix_bin_generic+1
	als	1
	ars	36-8
	asa	work|flt_dec_generic_exp

	mlr	(),(pr,x4),fill(000)	" clear decimal exponet
	zero
	desc9a	work|flt_dec_generic-1(3),1	" to avoid over/underflow
	lda	work|fix_bin_generic	" check completion.
	tmi	flt_dec.flt_bin.scale_up	" scale up
	tra	flt_dec.flt_bin.scale_dwn	" scale down

"     Final multiply to correct range.  Result goes to fixed decimal to
"     position for DTB conversion to binary.

flt_dec.flt_bin.up.final:
	mlr	(pr),(pr,x3)		" move exponent
	desc9a	work|flt_dec_generic_exp(3),1
	desc9a	work|flt_dec_generic-1(3),1

	xec	mp3d.id.pr_rl.pr,x5	" up-scale mantissa ?round?
	arg	two_table,al
	desc9fl	work|flt_dec_generic,x3
	desc9ls	work|flt_dec_generic,24	" overlength for precision
	tra	flt_dec.flt_bin.up.enter

"     Final divide to correct range.  Result goes to fixed decimal to position
"     for DTB conversion to binary.

flt_dec.flt_bin.dwn.final:
	mlr	(pr),(pr,x3)		" move exponent
	desc9a	work|flt_dec_generic_exp(3),1
	desc9a	work|flt_dec_generic-1(3),1

	xec	dv3d.id.pr_rl.pr,x5
	arg	two_table,al
	desc9fl	work|flt_dec_generic,x3
	desc9ls	work|flt_dec_generic,24

"     Convert the fixed decimal value to bits, and normalize float bin result.

flt_dec.flt_bin.up.enter:
	dtb	(pr),(pr)
	desc9ls	work|flt_dec_generic,24
	desc9a	work|flt_bin_generic,8

"     Get the precision correction for the high order decimal input digit and
"     formulate the initial binary exponent.

	eaa	0,x1
	als	18-8			" to exponent position
	sta	work|fix_bin_generic
	ldaq	work|flt_bin_generic
	lde	work|fix_bin_generic
	fno
	ste	work|fix_bin_generic
	staq	work|flt_bin_generic
	lda	work|fix_bin_generic
	ars	36-8
	asa	work|flt_bin_generic_exp
	tra	generic_to_target
"Conversion Routines - Flt Decimal to target generic (fix bin uns)

"     Convert float decimal to scaled or unscaled fixed binary unsigned.

flt_dec_to_fix_bin_uns:
	cmpc	(pr),(),fill(plus_sign)	" Ensure positive number.
	desc9a	work|flt_dec_generic,1
	zero
	tnz	size_error		" converting negative
	lxl4	work|target_precision	" determine precision needed
	ldx4	bin_prec_to_dec_prec,x4
	ldx2	work|target_scale		" is bin an integer?
	tze	flt_dec.fix_bin_uns.no_scale	" yes
	tmi	flt_dec.fix_bin_uns.neg_scale	" negative scale

"     Scale the float decimal value by the integer's power of two scale

	mp3d	(id),(pr,rl),(pr,rl)
	arg	two_table,x2
	desc9fl	work|flt_dec_generic,x3
	desc9fl	work|flt_dec_generic,x4
	tnz	flt_dec.fix_bin_uns.exp_change

"     Assumption at flt_dec.fix_bin_uns.zero is x3 is size of target, which is
"     currently held only in x4.  Copy x4 to x3 to correct for assumption.

flt_dec.fix_bin_uns.zero_fix:
	eax3	0,x4			" size of zero target
	tra	flt_dec.fix_bin_uns.zero	" zero value

flt_dec.fix_bin_uns.neg_scale:		" negative scale is divide
	lcx2	work|target_scale		" |scale|
	adx4	1,du			" extra digit for hardware
	dv3d	(id),(pr,rl),(pr,rl)
	arg	two_table,x2
	desc9fl	work|flt_dec_generic,x3
	desc9fl	work|flt_dec_generic,x4
	tze	flt_dec.fix_bin_uns.zero_fix	" zero value
"	tra	flt_dec.fix_bin_uns.exp_change

flt_dec.fix_bin_uns.exp_change:		" Add any exponent change
	eax3	0,x4
	mlr	(pr,x3),(pr)
	desc9a	work|flt_dec_generic-1(3),1
	desc9a	work|flt_bin_generic_exp,1
	lda	work|flt_bin_generic_exp
	als	1
	ars	36-8
	asa	work|flt_dec_generic_exp

"     See if exponent is too big.  If not, then convert to fixed decimal
"     and then to binary.  We leave it in place as correct.

flt_dec.fix_bin_uns.no_scale:
	lda	work|flt_dec_generic_exp
	als	36-8
	trc	decimal_range_error		" range outside of flt dec
	mlr	(pr),(pr,x3)		" install hardware exp
	desc9a	work|flt_dec_generic_exp(3),1
	desc9a	work|flt_dec_generic-1(3),1

flt_dec.fix_bin_uns.zero:
	eax4	-1,x4			" leading signed precision
	xec	mvn.pr_rl.pr_rl,x5		" create fixed decimal
	desc9fl	work|flt_dec_generic,x3
	desc9ls	work|flt_dec_generic,x4

"     Convert.  An overflow is acceptable since the bit pattern is right.

	dtb	(pr,rl),(pr)
	desc9ls	work|flt_dec_generic,x4
	desc9a	work|fix_bin_generic,8
	tov	flt_dec.fix_bin_uns.ovfl	" too big, only 71 bits done
	tra	generic_to_target

"     We got an overflow on the conversion.  Thus set the high order bit.

flt_dec.fix_bin_uns.ovfl:
	cmpn	(pr,rl),()		" See if above 72 bit limit.
	desc9ls	work|flt_dec_generic,x4
	desc4ns	two_72,22
	tmoz	size_error
	lda	=o400000,du		" include the sign bit
	orsa	work|fix_bin_generic
	ldi	mask_faults,dl		" permits overflow again
	tra	generic_to_targetConversion Routines - Flt Decimal to target GENERIC (bit)

"     Entry condition is a float decimal value in flt_dec_generic
"     We convert the flt dec source to fixed bin (71, 0), obeying all normal
"     conversion rules.


flt_dec_to_bit:
	lda	work|flt_dec_generic_exp	" incorporate exponent
	als	36-8
	trc	decimal_range_error		" range outside of flt dec
	mlr	(pr),(pr,x3)       		" install hardware exp
	desc9a	work|flt_dec_generic_exp(3),1
	desc9a	work|flt_dec_generic-1(3),1

	ldx4	23,du
	xec	mvn.pr_rl.pr_rl,x5		" create fixed decimal
	desc9fl	work|flt_dec_generic,x3
	desc9ls	work|flt_dec_generic,x4
	dtb	(pr,rl),(pr)		" convert to fixed bin (71,0)
	desc9ls	work|flt_dec_generic,x4
	desc9a	work|fix_bin_generic,8
	tov	size_error

"     Determine the precision equivalent of the result with 0 scale.

	lxl2	work|source_precision
	sbx2	work|source_scale
	eaq	0,x2
	qrs	18
	mpy	log2.10			" convert precision to bin
	lls	3
	cmpq	0,dl			" take ceiling
	tze	flt_dec.bit.ceil
	ada	1,dl
flt_dec.bit.ceil:
	cmpa	71,dl			" take min (71, a)
	tmi	flt_dec.bit.min
	lda	71,dl
flt_dec.bit.min:
	sta	work|source_precision
	ldaq	work|fix_bin_generic	" pick up value
	tra	to_bit			" convert fix bin (71, 0) to bit


"     Log conversion to convert decimal exponent into binary exponent.

log2.10:
	dec	3.321928095b2		" log2(10) at scale 34
"Conversion Routines - Fixed bin unsigned to target GENERIC

fix_bin_uns_generic_conversion:
	ldx1	target_type_map,x6		" determine target GENERIC
	anx1	generic_mask,du		" mask for type
	tra	fix_bin_uns_generic_case,x1*

fix_bin_uns_generic_case:
	arg	error_bad_type
	arg	fix_bin_uns_to_fix_bin
	arg	fix_bin_uns_to_flt_bin
	arg	fix_bin_uns_to_flt_dec
	arg	fix_bin_uns_to_fix_bin_uns
	arg	fix_bin_uns_to_bit
	arg	fix_bin_uns_to_char

"     Convert fixed bin to fixed bin.  Here it is mainly a matter of scaling
"     to ensure the target scale factor is correct.  The difference between
"     conversion to signed and unsigned targets is to assure that the output
"     value is within the range of the target, and an unsigned to signed
"     conversion must result in a positive signed result.


fix_bin_uns_to_fix_bin:			" target signed
fix_bin_uns_to_fix_bin_uns:			" target unsigned
	ldaq	work|fix_bin_generic	" load for .check_target
	ldx2	work|target_scale		" determine cross-scaling
	sbx2	work|source_scale
	tze	fix_bin_uns.check_target	" scales match
	tmi	fix_bin_uns.scale_right	" need right shift and ?round?

"     Overflow detection means generating a mask of the number of bits to
"     be shifted left to determine if this area is non-zero, if so then we
"     will overflow.

fix_bin_uns.scale_left:			" left shift zero fill
	fld	=1b26,du			" get mask bit
	lrs	-1,x2			" generate mask
	anaq	work|fix_bin_generic
	tnz	size_error		" we would overflow

	ldaq	work|fix_bin_generic
	lls	0,x2
	tra	fix_bin_uns.noscale

"     Right scaling may require a round.  Positive rounds up.  Do this by
"     determining the bit position to round at.

fix_bin_uns.scale_right:			" right shift and ?round?
	erx2	=o777777,du		" form shift count-1
	eax4	0,x5			" determine if rounding
	tze	fix_bin_uns.noround
	ldaq	one			" load mask for rounding
	lls	0,x2			" determine round bit
	anaq	work|fix_bin_generic
	tnz	fix_bin_uns.noround
	eax4	0			" force no round
fix_bin_uns.noround:
	ldaq	work|fix_bin_generic
	lrl	1,x2			" do total scale
	xec	binary_round,4		" round if necessary
fix_bin_uns.noscale:			" no scaling needed, no round
	staq	work|fix_bin_generic

"     Ensure target is big enough to hold result.  Do this through shifting.
"     Fixed bin uns to Fixed bin signed checked by precision difference.

fix_bin_uns.check_target:
	lxl2	work|target_precision	" find precision
	lrl	0,x2			" see what is above it
	tnz	size_error		" too big to fit
	tra	generic_to_target		" convert to target
"Conversion Routines - Fixed bin unsigned to target GENERIC (float bin)


"     Conversion is almost identical to normal fixed bin conversion, with
"     the additional condition that the result must be unsigned, thus if
"     the source is a full fixed bin (72) unsigned and has the upper bit set,
"     we pre-scale by one to remove an erroneous negative indication.

fix_bin_uns_to_flt_bin:
	lda	work|source_scale		" form exponent including scale
	ars	18			" clip precision
	als	36-8			" move to exp field
	neg	0			" form -scale (b25)
	ada	=71b25,du			" add integer scaling
	sta	work|flt_bin_generic_exp
	ldaq	work|fix_bin_generic
	tpl	fix_bin_uns.positive	" high bit is clear
	aos	work|flt_bin_generic_exp	" scale exponent
	lrl	1			" protect high bit
fix_bin_uns.positive:
	lde	work|flt_bin_generic_exp	" load and normalize
	fno
	tze	fix_bin_uns.flt.zero	" store extended 0.0
	ste	work|flt_bin_generic_exp	" save exponent
	staq	work|flt_bin_generic
	lda	work|flt_bin_generic_exp
	ars	36-8			" form 36-bit exp
	sta	work|flt_bin_generic_exp
	tra	generic_to_target


fix_bin_uns.flt.zero:		" zero float bin then convert to target
	stz	work|flt_bin_generic_exp
	stz	work|flt_bin_generic
	stz	work|flt_bin_generic+1
	tra	generic_to_target		" convert to target
"Conversion Routines - Fixed bin unsigned to target GENERIC (float decimal)


"     Initial coding uses BTD instruction and divides to provide result of
"     scaling.  This may be improved later.


fix_bin_uns_to_flt_dec:
	ldaq	work|fix_bin_generic	" see if high order bit set
	tze	force_zero		" total is 0.0
	cana	=o400000,du
	tze	fix_bin_uns.flt_dec.short
	ana	=o400000,du		" mask off high bit
	ersa	work|fix_bin_generic	" turn it off

	ldx4	23,du			" set length of conversion
	btd	(pr),(pr,rl)		" convert 71 bits
	desc9a	work|fix_bin_generic,8
	desc9ls	work|flt_dec_generic,x4

	ad2d	(),(pr,rl)		" correct for high bit
	desc4ns	two_71,22			" add 71's bit power
	desc9ls	work|flt_dec_generic,x4
	tra	fix_bin_uns.flt_dec.long

"     Determine length needed to convert.  Method from fix_bin_to_flt_dec.
"     At fix_bin_uns.flt_dec.long X4 has length of the fixed decimal number.

fix_bin_uns.flt_dec.short:
	lde	=72b25,du			" find true precision
	fno
	ste	work|flt_bin_generic
	lda	work|flt_bin_generic
	ars	36-8
	ldx4	bin_prec_to_dec_prec,al	" get digits needed
	lxl2	bin_prec_to_dec_prec,al	" get size of source
	eax1	-9,x2			" get offset of source
	erx1	=o777777,du
	btd	(pr,x1,rl),(pr,rl)
	desc9a	work|fix_bin_generic,x2
	desc9ls	work|flt_dec_generic,x4

fix_bin_uns.flt_dec.long:
	stz	work|flt_dec_generic_exp	" pre-set 0 exponent

	eax3	1,x4			" size of float decimal
	ldx2	work|source_scale		" determine power to divide
	tze	generic_to_target		" simple move
	tmi	fix_bin_uns.flt_dec.neg_scale

	adx3	1,du			" one extra digit for divide
	xec	dv3d.id.pr_rl.pr_rl,x5	" scale the output
	arg	two_table,x2		" power of two
	desc9ls	work|flt_dec_generic,x4
	desc9fl	work|flt_dec_generic,x3
	tra	fix_bin_uns.flt_dec.common

fix_bin_uns.flt_dec.neg_scale:
	erx2	=o777777,du
	adx2	=1,du			" negate x2
	xec	mp3d.id.pr_rl.pr_rl,x5	" scale the output
	arg	two_table,x2		" power of two
	desc9ls	work|flt_dec_generic,x4
	desc9fl	work|flt_dec_generic,x3

fix_bin_uns.flt_dec.common:
	mlr	(pr,x3),(pr)		" pick and extend exponent
	desc9a	work|flt_dec_generic-1(3),1
	desc9a	work|flt_dec_generic_exp,1
	lda	work|flt_dec_generic_exp
	als	1
	ars	36-8
	sta	work|flt_dec_generic_exp
	tra	generic_to_target
"Conversion Routines - Fixed bin unsigned to target GENERIC (bit)

"     Entry condition is a fixed bin unsigned value in fix_bin_generic.
"     We convert the fix bin uns source to fixed bin uns (72, 0), obeying
"     all normal conversion rules.

fix_bin_uns_to_bit:
	ldaq	work|fix_bin_generic	" load for to_bit
	ldx2	work|source_scale		" unscaled is (72, 0)
	tze	to_bit_uns		" convert to final bits
	tpl	fix_bin_uns.bit.scale_right	" need shift right and ?round?

fix_bin_uns.bit.scale_left:			" left shift zero fill
	erx2	=o777777,du		" negate x2
	adx2	=1,du
	lls	0,x2
	trc	size_error		" overflow
	tra	to_bit_uns		" value is good

fix_bin_uns.bit.scale_right:
	eax4	0,x5			" determine if rounding
	tze	fix_bin_uns.bit.noround
	ldaq	one			" load mask for rounding
	lls	-1,x2			" determine round bit
	anaq	work|fix_bin_generic
	tnz	fix_bin_uns.bit.noround
	eax4	0			" force no round
fix_bin_uns.bit.noround:
	ldaq	work|fix_bin_generic
	lrl	0,x2			" do total scale
	xec	binary_round,4		" round if necessary

"     Determine if it fits within the bit stream target and move to generic.

to_bit_uns:
	staq	work|fix_bin_generic	" save fix bin (71, 0)
	epp	generic,work|bit_generic	" set generic area
	lxl2	work|source_precision	" determine start bit to move
	sbx2	work|source_scale
	eax4	-73,x2
	erx4	=o777777,du		" start = 72-precision
	tpl	fix_bin_uns.bit.non_null	" string not null
	ldx3	0,du			" length is 0
	tra	generic_to_target		" output "0" bits

fix_bin_uns.bit.non_null:
	lxl1	work|target_precision	" see if fits within bits
	lrl	0,x1			" okay if "0"b left over
	tnz	size_error		" number is too big
	lxl3	work|target_precision
	csl	(pr,x4,rl),(pr,rl),bool(move),fill(0)
	descb	work|fix_bin_generic,x2
	descb	generic|0,x3
	tra	generic_to_target		" store result
"Conversion Routines - Bit to target GENERIC

"     Expects generic to point to bit source, and length to be in X3.

bit_generic_conversion:
	ldx1	target_type_map,x6		" Call to target routine
	anx1	generic_mask,du
	tra	bit_generic_case,x1*

bit_generic_case:
	arg	error_bad_type
	arg	bit_to_fix_bin
	arg	bit_to_flt_bin
	arg	bit_to_flt_dec
	arg	bit_to_fix_bin_uns
	arg	bit_to_bit
	arg	bit_to_char

"     Conversion to fixed bin is done in a simple manner, as is conversion
"     to float bin and float decimal.  For all these we convert to fixed bin
"     (71, 0), and then call the fixed bin conversion to target GENERIC.

bit_to_fix_bin:
bit_to_flt_bin:
bit_to_flt_dec:
	stz	work|fix_bin_generic	" clear sign bit

"     Copy bits reverse to get from end of string.

	csr	(pr,rl),(pr),bool(move),fill(0)
	descb	generic|0,x3
	descb	work|fix_bin_generic(1),71
	trtf	fix_bin_generic_conversion	" bit string < 71 bits
	eax3	-71,x3			" check upper bits
	cmpb	(pr,rl),(),fill(0)		" to ensure leading "0"b
	descb	generic|0,x3
	zero
	tnz	size_error		" too big
	tra	fix_bin_generic_conversion	" convert it



"     Unsigned target case.

bit_to_fix_bin_uns:				" copy clears sign bit
	csr	(pr,rl),(pr),bool(move),fill(0)
	descb	generic|0,x3
	descb	work|fix_bin_generic,72
	trtf	fix_bin_uns_generic_conversion " bit string <= 72 bits
	eax3	-72,x3			" check upper bits
	cmpb	(pr,rl),(),fill(0)		" to ensure leading "0"b
	descb	generic|0,x3
	zero
	tnz	size_error		" too big
	tra	fix_bin_uns_generic_conversion " convert it
"Converison Routine - bit to bit.

"     Bit to bit conversion is simple.  We simply determine if varying or
"     simple target, and copy sufficient bits to fill the target.  Return
"     is directly to user since we cannot be complex.  For a varying string
"     we only copy up to the length of the source, for a non-varying string,
"     we fill "0" beyond the length of the source.  Source len in X3.  Source
"     is pointed to by generic.  We leave generic pointing to bit_generic.

bit_to_bit:
	lxl2	work|target_precision
	csl	(pr,rl),(pr,rl),bool(move),fill(0)
	descb	generic|0,x3
	descb	work|bit_generic,x2		" copy all bits needed
	epp	generic,work|bit_generic	" point to generic source.
	tra	generic_to_target


"Conversion Routines - bit to character.

"     Bit to character is done by converting to the limit of the target's
"     precision the input bits in a loop.  Much of the code, except the final
"     copy is identical to the bit-to-bit situation, since the only difference
"     is that the source bits become target digits.  Source len in X3.  Source
"     is addressed by generic.  On exit we set generic to the generic
"     character, X3 is length of string.  We use fix_bin_generic to temp-store
"     the string length of output.

bit_to_char:
	lxl2	work|target_precision
	ldx4	0,du			" source bit index
	stx2	work|fix_bin_generic	" save precision
	ldx1	target_type_map,x6		" see if varying
	canx1	varying,du
	tze	bit.char.loop

"     Varying target, adjust conversion length in X2 if bit < char length.

	cmpx3	work|fix_bin_generic
	tpnz	bit.char.loop		" Source > target
	stx3	work|fix_bin_generic	" save precision
	eax2	0,x3

bit.char.loop:
	cmpb	(pr,x4),()		" check if bit 1/0
	descb	generic|0,1
	zero
	tze	bit.char.zero
	mlr	(),(pr,x4),fill(digit_1)	" fill in "1"
	zero
	desc9a	work|char_generic,1
	tra	bit.char.done_digit

bit.char.zero:
	mlr	(),(pr,x4),fill(digit_0)	" fill in "0"
	zero
	desc9a	work|char_generic,1

bit.char.done_digit:
	eax4	1,x4
	sbx3	1,du			" count source done
	tmoz	bit.char.fill_blank		" beyond the source
	sbx2	1,du			" count target done
	tpnz	bit.char.loop
	tra	bit.char.exit

"     Beyond source, fill target with " " characters.

bit.char.fill_blank:
	mlr	(),(pr,rl,x4),fill(blank)
	zero
	desc9a	work|char_generic,x2

bit.char.exit:				" setup chars and exit
	ldx3	work|fix_bin_generic	" precision of generic chars
	epp	generic,work|char_generic	" base of chars
	tra	generic_to_targetConversion Routines - Character to target GENERIC (char to bit) (char to char)

char_to_generic:
	ldx1	target_type_map,x6		" determine target GENERIC
	anx1	generic_mask,du		" mask for type
	tra	char_generic_case,x1*

char_generic_case:
	arg	error_bad_type
	arg	char_to_arithmetic		" char_to_fix_bin
	arg	char_to_arithmetic		" char_to_flt_bin
	arg	char_to_arithmetic		" char_to_flt_dec
	arg	char_to_arithmetic		" char_to_fix_bin_uns
	arg	char_to_bit
	arg	char_to_char

"     Char to bit conversion is simple.  We simply determine if varying or
"     simple target, and copy sufficient bits to fill the target.  Return
"     is directly to user since we cannot be complex.  For a varying string
"     we only copy up to the length of the source, for a non-varying string,
"     we fill "0" beyond the length of the source.  We receive generic pointing
"     to the character string, X3 as the length.  We leave generic as base of
"     bit string and X3 as length.  We use fix_bin_generic as the working
"     target length, permitting correct varying target conversion.

char_to_bit:
char.bit.restart:				" enter and restart
	lxl3	work|source_precision
	lxl2	work|target_precision
	ldx4	0,du			" save length of target
	stx2	work|fix_bin_generic	" save precision
	ldx1	target_type_map,x6		" see if varying
	canx1	varying,du
	tze	char.bit.loop.enter

"     Varying target, adjust conversion length in X2 if char < bit length.

	cmpx3	work|fix_bin_generic
	tpnz	char.bit.loop.enter		" Source > target
	stx3	work|fix_bin_generic	" save precision
	eax2	0,x3

char.bit.loop.enter:
	cmpx3	0,du
	tmoz	char.bit.fill_0		" no work - fill 0
char.bit.loop:
	scm	(),(pr,x4)
	desc9a	char.bit.01,2		" see if character is 0 or 1
	desc9a	generic|0,1
	arg	work|fix_bin_generic+1
	ttf	char.bit.good		" valid digit

"     Digit is invalid.  We correct values to declare a conversion error.

	eaq	1,x4			" index in Q
	qrs	18
	lda	191,dl			" oncode
	tsx1	conversion_error
	tra	char.bit.restart		" re-try conversion again

"     Character was good.  Fill in correct bit.

char.bit.good:
	csl	(pr),(pr,x4),bool(move)	" fill bit
	descb	work|fix_bin_generic+1(35),1	" using low order of index
	descb	work|bit_generic,1
	eax4	1,x4
	sbx3	1,du			" see if beyond source
	tmoz	char.bit.fill_0		" fill with 0 bits
	sbx2	1,du			" see if more target
	tpnz	char.bit.loop
	tra	char.bit.exit

"     Fill in "0" bits for remainder of target.

char.bit.fill_0:
	csl	(),(pr,x4,rl),bool(move),fill(0)
	zero
	descb	work|bit_generic,x2

char.bit.exit:				" setup bit info for exit
	ldx3	work|fix_bin_generic	" number of bits
	epp	generic,work|bit_generic	" location of bits
	tra	generic_to_target

"     String used to check if characters are 0 or 1.

char.bit.01:
	aci	/01/,2


"Conversion Routines - Character to Character

"     Source length is in work|source_precision.  generic points to the string.

char_to_char:
	lxl3	work|source_precision	" pick up length
	tra	generic_to_target
"Conversion Routines - Numeric to character

"     This routine utilizes the existing _to_flt_dec
"     conversion, and sets up for such a conversion.  It sets the
"     target precision according to the log conversion from the
"     precision of the incoming number.  Set X4 to conversion routine address
"     since source get for real part is already done.

fix_bin_to_char:
	ldx4	fix_bin_to_flt_dec,du	" convert to float decimal
	tra	to_char.enter

flt_bin_to_char:
	ldx4	flt_bin_to_flt_dec,du	" convert to float decimal
	tra	to_char.enter


"     At this point X3 contains the length of the float decimal GENERIC.
"     It must be preserved through to the "to_char.float_type" label.

flt_dec_to_char:
	ldx4	generic_to_target,du	" convert to float decimal
	tsx1	save_target		" save old target info
	lda	work|source_precision	" source to target prec/scale
	sta	work|target_precision
	epp	target,work|char_flt_dec_gen	" past guard band
	ldx6	flt_dec_type,du		" presume float
	ldx1	source_type_map,x7		" determine if float or fix
	canx1	fix,du
	tze	to_char.float_type
	ldx6	fix_dec_type,du		" fixed target
	tra	to_char.float_type

fix_bin_uns_to_char:
	ldx4	fix_bin_uns_to_flt_dec,du	" convert to float decimal

to_char.enter:				" common processing
	tsx1	save_target		" save old target info

"     Float decimal precision is ceil ((fixed bin precision)/3.32).
"     This considers the bin precision and the decimal precision to be
"     logarithm expressions and is simply the bin precision changed from
"     log(2) to log(10).

	ldq	work|source_precision
	anq	=o777777,dl		" mask out scale
	mpy	=.3012056b-1
	cmpq	0,dl
	tze	to_char.precision.ceil	" ceiling
	ada	1,dl			" round up

to_char.precision.ceil:
	sta	work|target_precision	" store in DL

"     Put output into work|char_flt_dec_gen.  Set target type to float decimal.

	epp	target,work|char_flt_dec_gen	" past guard band
	ldx6	flt_dec_type,du		" presume float
	ldx1	source_type_map,x7		" determine if float or fix
	canx1	fix,du
	tze	to_char.float_type
	ldx6	fix_dec_type,du		" fixed target
	aos	work|target_precision	" get additional precision
	ldq	work|source_scale		" find scale digits
	tpl	to_char.pos_scale		" don't keep neg scale
	ldq	0,dl
to_char.pos_scale:
	qrs	18
	tze	to_char.float_type
	mpy	=.301205b-1		" form scale conversion
	cmpq	0,dl			" round up
	tze	to_char.scale.ceiling
	ada	1,dl
to_char.scale.ceiling:
	als	18
	asa	work|target_scale		" integrate with precision

to_char.float_type:
	tsp7	0,x4			" Convert real part
	ldi	mask_faults,dl		" re-enable overflow detect
"Determine if source is complex.  If so convert complex part too.

	ldx1	source_type_map,x7
	canx1	complex,du
	tze	to_char.simple_source
	lxl4	source_type_map,x7
	tsp7	0,x4
	ldi	mask_faults,dl		" re-enable overflow detect

"     Restore target info for character, and CASE to data type of source
"     to get correct conversion.

to_char.simple_source:
	epp	source,work|char_flt_dec_gen	" take flt/fix dec from temp
	ldx1	source_type_map,x7		" determine source GENERIC
	anx1	generic_mask,du
	tra	to_char.formatter,x1*

to_char.formatter:
	arg	error_bad_type
	arg	format_fix
	arg	format_flt_bin
	arg	format_flt_dec
	arg	format_fix
	arg	error_bad_type		" bits grabbed earlier
	arg	error_bad_type		" characters grabbed earlier
"Conversion Routines - Formated fixed bin output.


"     Format fixed.

format_fix:
	epp4	format_integer		" presume an integer
	ldx1	work|source_scale
	tmoz	to_char.call_format		" format as integer
	epp4	format_fixed
	tra	to_char.call_format		" format as fractional


"     Format float decimal.
"
"     This requires that we determine if the original source was fixed or
"     float decimal to determine scale information.

format_flt_dec:
	ldx1	source_type_map,x7
	canx1	fix,du			" was source fixed decimal
	tze	format_flt_bin		" no - format float

	epp4	format_integer
	ldx4	work|source_scale		" if no scale, format integer
	tze	to_char.call_format

"     Format as scaled fixed decimal.

	epp4	format_scaled		" use F format
	tmi	to_char.call_format		" scale below precision

	lxl4	work|source_precision	" is scale beyond precision
	cmpx4	work|source_scale
	tmi	to_char.call_format
	epp4	format_fixed		" simple format
	tra	to_char.call_format


"     Format float binary.

format_flt_bin:
	epp4	format_float

"     Call formatter for real and possibly imaginary parts.

to_char.call_format:
	epp	generic,work|char_generic	" pointer to target w/guard
	eax4	0			" flag for real part
	lxl3	work|target_precision	" form target precision
	tsp7	pr4|0			" call formatter

"     X2 contains the number of characters output, X3 contains p+2, source
"     pointer is updated.

	ldx1	source_type_map,x7		" do imaginary if complex
	canx1	complex,du
	tze	to_char.copy_to_target	" only real part

	a9bd	generic|0,x2		" point to imaginary part
	stx2	work|save_target_precision	" save length output
	eax4	1			" flag for imaginary part
	lxl3	work|target_precision	" form target precision
	tsp7	pr4|0			" format
"     Squeeze blanks from imaginary part and add trailing "i".

	scmr	(pr,rl),(du)
	desc9a	generic|0,x2
	vfd	9/blank
	arg	work|fix_bin_generic
	eaa	0,x2			" length of field
	ars	18
	sba	work|fix_bin_generic	" form number of leading 0's
	ldq	work|fix_bin_generic	" number of non-blank chars
	eax4	1,ql			" space for "i"
	mlr	(pr,rl,al),(pr,rl),fill(letter_i)
	desc9a	generic|0,ql
	desc9a	generic|0,x4
	cmpa	0,dl			" need to fill spaces at end?
	tze	to_char.no_fill		" and skip if none
	mlr	(),(pr,rl,x4),fill(blank)	" put spaces right of field
	zero
	desc9a	generic|0,al

to_char.no_fill:
	adx2	1,du			" allow for i at end
	adx2	work|save_target_precision	" form total length of string

"     assign char temporary to final target

to_char.copy_to_target:
	tsx1	restore_target		" restore target info

	epp	generic,work|char_generic	" get ptr to characters
	eax3	0,x2			" get source length in al
	tra	generic_to_target		" and go move
"Conversion Routines - Format decimal integer.


"     entered with p in x3, x4 = 0(1) for real(imag) part,
"     generic = ptr to output buffer, pr4 = ptr to ourselves,
"     and pr7 = return loc

"     returns with p+1 in x3 and x2 = number of chars output (p+3), source
"     pointing after used portion.

format_integer:
	eax3	1,x3
	eax2	2,x3			" length of output = p + 3
	cmpn	(pr,rl),()		" is field 0
	desc9ls	source|0,x3
	desc9ls	char_zero,2
	tze	format_integer.zero
	mvne	(pr,rl),(id),(pr,rl)	" no, do editing
	desc9ls	source|0,x3
	arg	int_edit_desc,x4
	desc9a	generic|0,x2
	a9bd	source|0,x3		" update source used
	tra	pr7|0

format_integer.zero:
	mrl	(id),(pr,rl),fill(blank)	" zero field (edit would IPR)
	arg	zero_field,x4
	desc9a	generic|0,x2
	a9bd	source|0,x3		" update source used
	tra	pr7|0

int_edit_desc:
	desc9a	int_edit,7	real
	desc9a	int_edit(2),5	imag

int_edit:	vfd	9/lte+3,9/blank,9/insm+2,9/mfls,9/mfls,9/mfls,9/mfls

zero_field:
	desc9a	char_zero(1),1		real
	desc9a	char_zero,2		imag

"     Character zero forms.

char_zero:
	aci	"+0-0"
"Conversion Routines - Format Fixed scaled 0 < scale <= precision.


"     entered with p in x3, x4 = 0(1) for real(imag) part,
"     generic = ptr to output buffer, pr4 = ptr to ourselves,
"     and pr7 = return loc

"     returns with p+1 in x3 and x2 = number of chars output (p+3), source
"     points after used part.

format_fixed:
	eax3	1,x3			" form p+1
	sbx3	work|target_scale		" get p-q+1
	eax2	1,x3			" first part of field
	cmpx3	2,du			" need at least 2 digits
	tmi	format_fixed.no_lead_digits	" no, special action needed
	cmpn	(pr,rl),()		" are first p-q digits zero?
	desc9ls	source|0,x3
	desc9ls	char_zero,2
	tze	format_fixed.zero
	mvne	(pr,rl),(id),(pr,rl)	" non-zero, form Sdddd
	desc9ls	source|0,x3
	arg	fixed_edit_desc,x4
	desc9a	generic|0,x2

"     Format right hand side after decimal point.

format_fixed.right:
	ldq	work|target_scale		" q+1 digits of form .ddddd
	eaa	1,qu
	mrl	(pr,rl,x3),(pr,rl,x2),fill(period)
	desc9a	source|0,qu
	desc9a	generic|0,au
	adx3	work|target_scale		" get back p+1
	eax2	2,x3			" total size of field
	a9bd	source|0,x3		" update source pointer
	tra	pr7|0

"     Format integer part as zero.

format_fixed.zero:
	cmpc	(pr),(),fill(plus_sign)
	desc9a	source|0,1
	zero
	tze	format_fixed.zero_pos	" skip if number positive
	mrl	(),(pr,rl),fill(blank)	" move in -0
	desc9a	char_zero(2),2
	desc9a	generic|0,x2
	tra	format_fixed.right		" format fractional part

format_fixed.zero_pos:
	mrl	(id),(pr,rl),fill(blank)	" zero, edit would  IPR
	arg	zero_field,4
	desc9a	generic|0,x2
	tra	format_fixed.right		" format fractional part

format_fixed.no_lead_digits:
	mvne	(pr),(id),(pr)		" put s0 at start of field
	desc9ls	source|0,2
	arg	no_leading_edit_desc,x4
	desc9a	generic|0,2
	tra	format_fixed.right		" format fractional part

fixed_edit_desc:
	desc9a	fixed_edit,7
	desc9a	fixed_edit(2),5

fixed_edit:
	vfd	9/lte+3,9/blank,9/insm+1,9/mfls,9/mfls,9/mfls,9/mfls

no_leading_edit_desc:
	desc9a	no_leading_edit,4
	desc9a	no_leading_edit(2),2

no_leading_edit:
	vfd	9/lte+3,9/blank,9/enf,9/insb+8
"Conversion Routines - Format fixed scaled scale < 0 | precision < scale

"	Call:	x4 = 0 (1) for real (imag) part
"		generic = ptr to output buffer
"		pr4 = ptr to ourselves
"		tsp7	pr4|0
"		x2 = number of chars output (p+4, p+5 or p+6)
"		x3 = p

"	Destroys: a, q, x1
"	Updates:  source	to point after used part.


format_scaled:
	eax3	1,x3			" account for sign
	cmpn	(pr,rl),()		" Is number zero?
	desc9ls	source|0,x3
	desc9ls	char_zero,2
	tnz	format_scaled.nonzero	" No:  edit number with mvne
	mrl	(id),(pr,rl),fill(blank)	" Yes: mvne would IPR
	arg	zero_field,x4
	desc9a	generic|0,x3
	tra	format_scaled.scale_factor

"     Non-zero number.

format_scaled.nonzero:
	mvne	(pr,rl),(id),(pr,rl)	" convert pic "(p)-9vf(-q)"
	desc9ls	source|0,x3
	arg	format_scaled.edit_desc,x4
	desc9a	generic|0,x3

"     Format scale factor for number.

format_scaled.scale_factor:			" convert the scale factor
	mlr	(),(pr,x3),fill(letter_f)	" tack on "f"
	zero
	desc9a	generic|0,1
	lda	work|source_scale		" au = scale_factor
	ars	18			" a = scale_factor
	eax2	1+1			" assume 1 digit scale factor
	cmg	10,dl			" Is one digit enough?
	tmi	format_scaled.have_length	" Yes: format it
	eax2	2+1			" No:  assume 2 digit factor
	cmg	100,dl			" Are two digits enough?
	tmi	format_scaled.have_length	" Yes: format it
	eax2	3+1			" No:  three digit factor

format_scaled.have_length:			" x2 = digits in factor + 1
	neg				" a = -scale_factor
	sta	work|fix_bin_generic	" work|b = -scale_factor
	btd	(pr),(pr,rl,x3)		" convert -scale_factor
	desc9a	work|fix_bin_generic,4
	desc9ls	generic|0(1),x2
	eaa	2,x2
	ars	18
	ada	work|source_precision	" A = p+digits_in_factor+1+2
	eax2	0,al			" into X2
	a9bd	source|0,x3		" update source pointer
	tra	pr7|0

format_scaled.edit_desc:
	desc9a	format_scaled.edit,6
	desc9a	format_scaled.edit(2),4

format_scaled.edit:
	vfd	9/lte+3,9/blank,9/mfls,9/mfls,9/mfls,9/mfls
"Conversion Routines - Format Decimal float.

"     entered with:
"	source|0 -> float decimal generic
"	x3	  has precision of mantissa
"	x4	  has 0/1 for real/imag
"	generic  -> output buffer
"	pr4      -> formatting routine
"	pr7      -> return loc

"     returns with x2 = number of chars output (p+7), updates source to point
"     after used part.

format_float:
	tct	(pr,rl)			" count leading zeros
	desc9a	source|1(1),x3		" miss sign and exponent
	desc9a	zero_skip
	arg	work|fix_bin_generic
	ttn	zero_float		" all digits are "0"

	lxl2	work|fix_bin_generic	" get number of leading zeros
	eaa	0,x2
	ars	18
	neg
	ada	work|target_precision	" form # of non-zero digits
	ana	=o777777,dl
	mlr	(pr),(pr)			" copy sign into temp
	desc9a	source|1,1
	desc9a	work|fix_dec_generic,1
	mlr	(pr,rl,x2),(pr,rl),fill(digit_0) " copy sans leading zeros
	desc9a	source|1(1),al
	desc9a	work|fix_dec_generic(1),x3
	sba	1,dl			" form output exponent
	ada	source|0			" include generic exponent
	sta	work|fix_bin_generic	" save to stop overwrite
	adx3	1,du			" get p+1
	eax2	1,3			" get p+2
	mvne	(pr,rl),(id),(pr,rl)	" generate Sd.dddddddd
	desc9ls	work|fix_dec_generic,x3
	arg	float_edit_desc,4
	desc9a	generic|0,x2
	mlr	(),(pr,x2),fill(letter_e)	" move in "e"
	zero
	desc9a	generic|0,1
	btd	(pr),(pr,x2)		" convert exponent
	desc9a	work|fix_bin_generic,4
	desc9ls	generic|0(1),11
	adx2	2,du			" add length of "e+"
	tct	(pr,x2)			" count most leading zeros
	desc9a	generic|0,7
	desc9a	zero_skip
	arg	work|fix_bin_generic
	eaq	0,x2			" get index
	qrs	18
	adq	work|fix_bin_generic	" add offset
	anq	=o777777,dl		" mask for index
	lda	work|fix_bin_generic	" get length
	ana	=o777777,dl
	neg
	eax4	10,al			" length of move
	mrl	(pr,ql,rl),(pr,x2,rl)
	desc9a	generic|0,x4
	desc9a	generic|0,x4
	stx4	work|fix_bin_generic	" store exponent length
	adx2	work|fix_bin_generic	" add length of digits
	adx3	3,du			" round up
	a9bd	source|0,x3		" update source pointer
	adwp	source,1,du		" align to word
	tra	pr7|0Zero floating point value.

zero_float:
	adx3	2,du			" get p + 2
	mlr	(id),(pr,rl),fill(digit_0)	" form b0.00000 or +0.0000
	arg	zero_fl_desc,x4
	desc9a	generic|0,x3
	mlr	(),(pr,x3),fill(digit_0)	" tack on e+000
	desc9a	eplus,2
	desc9a	generic|0,5
	eax2	5,x3			" get length of field
	adx3	2,du			" sign+mantissa+3 to round
	a9bd	source|0,x3		" update source pointer
	adwp	source,1,du		" align to word
	tra	pr7|0


"     Constants and formatting descriptors

zero_fl_desc:
	desc9a	real_zero_fl,3
	desc9a	imag_zero_fl,3

real_zero_fl:
	aci	" 0."
imag_zero_fl:
	aci	"+0."
eplus:	aci	"e+"

float_edit_desc:
	desc9a	float_edit,8	real
	desc9a	float_edit(2),6	imag

float_edit:
	vfd	9/lte+3,9/blank,9/mfls+1,9/insb+7,9/mvc,9/mvc,9/mvc,9/mvc



"     Save target information and return pointer.

save_target:
	lda	work|target_precision	" combined prec(DL), scale(DU)
	sta	work|save_target_precision
	spri1	work|save_target_ptr
	spri7	work|return
	spri4	work|save_pr4
	stx6	work|save_target_type
	tra	0,1


"     Restore target information and return pointer.

restore_target:
	lda	work|save_target_precision
	sta	work|target_precision
	epp1	work|save_target_ptr,*
	epp7	work|return,*
	epp4	work|save_pr4,*
	ldx6	work|save_target_type
	tra	0,1Conversion Routines - Character to Arithmetic.

"     On entry original_source is zero'd, to indicate no stack extension.

"     We receive the input string in the character temporary and translate it
"     as we go as necessary.  One initial translate test is done to permit the
"     use of short translate/test tables.  It finds the first illegal char.
"     For this translation and the CASE tests, the code is:
"
"     0 (illegal_class) - illegal character
"     1 (sign_class)    - plus or minus sign
"     2 (period_class)  - period (as for decimal point)
"     3 (b_class)       - b or B, used to indicate binary
"     4 (de_class)      - d,D e,E, used to indicate exponential format
"     5 (i_class)       - i or I, used to indicate end of Imaginary part
"     6 (blank_class)   - Whitespace
"     7 (digit_class)   - 0 thru 9, numeric digit
"     8 (f_class)       - f or F, used to indicated fixed format

"     Recognize is used to build a token list for a numeric part, and to
"     recognize the numeric type provided.  It is first called to parse the
"     real part, and then the imaginary part of the input number.  If in
"     scanning the real part, it finds a termination of I or i, we have
"     found the imaginary part instead, and move it to the imaginary token
"     list and clear the real token list.

"     The token list is initialized to zero, which will setup exponent, type,
"     index and length.  This is used with fill in later moves to setup the
"     float decimal source number.

"     After recognize has been run on the translated token source, we determine
"     the dominant numeric type for output, and the dominant scale and
"     precision of the real and imaginary parts.
"
"     Dominant scale is: max (scale_real, scale_imaginary)
"	The scale is determined by the length of the fractional parts.
"
"     Dominant precision is: max (integer_real, integer_imaginary)+1 +
"	dominant scale.
"
"     After determining dominant scale and precision and type, we copy
"     information according to the token list into the character temporary
"     from the source string.  The sign is moved with a "+" fill, thus it
"     defaults to +.  The integer part is moved right to left with 0 fill,
"     the fractional part left to right with 0 fill.  The exponent has already
"     been parsed and determined.  We correct it by subtracting the dominant
"     scale to produce a true float decimal GENERIC form for the input real
"     and imaginary parts.
"
"     When this numeric input has been built, we simply enter any_to_any_
"     to do conversion to the target.
"
"     There are four basic types of data.

	equ	fixbin,1		" fixed binary
	equ	fltbin,2		" float binary
	equ	fixdec,3		" fixed decimal
	equ	fltdec,4		" float decimal

"     These are later converted to the true internal data type*2 by a
"     conversion table.  Float decimal will normally use real_flt_dec_9bit, but
"     if the range does not fit, then we escape to real_flt_dec_ext for a 9-bit
"     exponent.
"Converision Routines - Character to numeric

"     Uses PR4 to point to token area in current use.

char_to_arithmetic:
	stz	work|original_source	" clear extension flag
	stx5	work|save_rounding		" save rounding requested
	lda	work|source_string_length	" get length of source
	ana	=o777777,dl
	tze	char.arith.zero
	cmpa	256,dl			" check length
	tpnz	error_205			" input string too long
	tra	char.arith.save_len

"     Restart point to pick up string from "conversion" error recover routine.
"     Here we may have a different length than before.

char_to_arithmetic_restart:
	lda	work|source_string_length	" get length of source
	tze	char.arith.zero
	cmpa	256,dl			" deal with max of 256 chars
	tmi	char.arith.save_len
	lda	256,dl			" force length, no error

"     Save length of string supplied.  Length in A.

char.arith.save_len:
	sta	work|original_source_length 	" save for conversion error

" NOTE - Here it should be spri generic,work|generic_ptr, but ALM won't do it.
	spri2	work|generic_ptr		" save string pointer

	tct	(pr,rl)			" find illegal or end
	desc9a	generic|0,al
	arg	error_table
	arg	work|flt_bin_generic
	ttn	char.arith.good_string

"     Bad character seen.  Find index of it.

	ldq	work|flt_bin_generic	" get index
	anq	=o777777,dl
	tra	error_203			" illegal character

char.arith.good_string:
	tctr	(pr,rl)			" rtrim (string)
	desc9a	generic|0,al
	arg	blank_skip
	arg	work|fix_bin_generic
	lca	work|fix_bin_generic	" - blanks
	alr	9			" sign extend
	ars	9
	ada	work|original_source_length	" length - blanks
	tze	char.arith.zero		" all blank

"     Start index at first non-whitespace.
"     Build token information into imaginary token.  Will move it later.

	mlr	(),(pr),fill(000)		" init real token
	zero
	desc9a	work|real_token,token_length
	mlr	(),(pr),fill(000)		" init imag token
	zero
	desc9a	work|imag_token,token_length
	tct	(pr,rl)			" skip over leading blanks
	desc9a	generic|0,al
	arg	blank_skip
	arg	work|fix_bin_generic
	stba	work|fix_bin_generic,40	" clear high byte blank count
	sba	work|fix_bin_generic	" account for blanks
	tmoz	char.arith.zero		" all blank - is 0.0

"     Not all character input was blank.  Start on real part.

	ldq	work|fix_bin_generic	" initialize offset
	tsx2	recognize			" look for a number
	mlr	(pr),(pr)			" move imag to real
	desc9a	work|imag_token,token_length
	desc9a	work|real_token,token_length
	cmpa	0,dl			" did we reach end of input
	tpnz	char.arith.more_input	" continue
	stz	work|imag.type		" indicate no imaginary
	tra	char.arith.end_of_input

"     have some characters after the number, process as terminator.
"     Use X2 as error index for trailing blank check.

char.arith.more_input:
	ldx2	error_203,du		" indicate bad character

	lxl4	work|real.term		" get terminator class
	tra	*+1,x4			" case process terminator
	tra	error_203			" illegal
	tra	char.arith.have_real_part	" sign - imag follows
	tra	error_203			" period
	tra	error_203			" b
	tra	error_203			" d e
	tra	char.arith.got_imag_part	" i    - we saw imag part
	tra	char.arith.blank_imag	" blank
	tra	error_203			" digit (can't happen)
	tra	error_203			" f


"     Blank trailing real part.  Clear imaginary part and check blanks.

char.arith.blank_imag:
	stz	work|imag.type		" no imaginary type
	tra	char.arith.check_blank

"     We have just seen the imaginary part, and the real part is empty.
"     The imaginary token list entry is okay, clear the real token.

char.arith.got_imag_part:
	mlr	(),(pr),fill(000)		" init real
	zero
	desc9a	work|real_token,token_length
	tra	char.arith.have_imag_part	" we have imaginary

"     Capture token info in imaginary part.

char.arith.have_real_part:
	mlr	(),(pr),fill(000)		" init imag
	zero
	desc9a	work|imag_token,token_length

	tsx2	recognize			" look for a number
	cmpa	0,dl			" did we reach end of input
	tmoz	error_219			" must have the "i"

"     We have both parts of the number, real and imaginary.
"     Check if we terminate correctly.  We must have blanks.

char.arith.have_imag_part:
	lxl4	work|imag.term		" check terminator
	cmpx4	i_class,du		" must be "i"
	tnz	error_219
	adq	1,dl			" skip the blank
	sba	1,dl			" one less to check
	tmoz	char.arith.end_of_input
	ldx2	error_211,du		" bad char after "i"

char.arith.check_blank:
	tct	(pr,rl,ql)		" skip trailing blanks
	desc9a	generic|0,al
	arg	blank_skip
	arg	work|fix_bin_generic
	ttf	0,x2			" complain

"     From token list, form the generic input, using char.flt_dec_generic.

char.arith.end_of_input:			" Set dominant conversion type.
	eax6	0,x6			" target of opportunity
	tnz	char.arith.supplied

	ldx7	work|real.type
	ldx1	work|imag.type
	epp	generic,dominant_type,x7*	" select imaginary table
	ldx7	generic|0,x1		" get dominant type
	lxl2	generic|0,x1		" get precision routine

"     If we alter the precision and scale, for a decimal to binary conversion.
"     The precision will appear in AL, and the scale in X5.  We indicate the
"     modified scale/precision tokenlist word by X3 as an offset in the
"     work area.

	lda	0,dl			" preset precision
	ldx5	0,du			" preset scale
	ldx3	0,du			" preset token prec/scale mod
	tra	0,x2			" manage precision

"     Transform the precision of the real part to binary from decimal.

r_dec_to_xbin:		" Convert real part decimal prec/scale to bin
	ldx3	real.scale,du
	tra	dec_to_bin.scale

r_dec_to_bin:		" Convert real part decimal prec to bin
	ldx3	real.prec,du
	tra	dec_to_bin.prec

i_dec_to_bin:		" Convert imaginary part decimal prec/scale to bin
	ldx3	imag.prec,du
	tra	dec_to_bin.prec

i_dec_to_xbin:		" Convert imaginary part decimal prec to bin
	ldx3	imag.scale,du
"	tra	dec_to_bin.scale		" fall through to routine

"     Convert the indicated scale to X5.

dec_to_bin.scale:
	ldq	work|0,x3		" scale = ceil (log2(10)*scale)
	qrs	18			" position
	tmi	dec_to_bin.prec		" negative scale set to 0
	mpy	log2.10			" convert base
	lls	3
	cmpq	0,dl			" ceiling
	tze	dec_to_bin.prec
	ada	1,dl
"	tra	dec_to_bin.prec		" find dominant precision

dec_to_bin.prec:
	ldx3	1,du
	ldq	work|0,x3		" prec = ceil (log2(10)*prec)
	anq	=o777777,dl		" mask from DL
	mpy	log2.10			" convert base
	lls	3
	cmpq	0,dl			" ceiling
	tze	char.arith.save_prec
	ada	1,dl
	tra	char.arith.save_prec	" find dominant precision

"     Save updated precision and scale.

char.arith.save_prec:
	sta	work|0,x3			" save precision
	stx5	work|0,x3			" save scale

"     Take precisions as is:  From dominant, process precision and scale.

as_is:
	eax4	0,x7			" save type
	xec	calculate_precision,x7	" target_precision
	ldx5	work|imag.type		" determine if complex
	tze	char.arith.real_type
	eax4	4,x4			" change to complex
char.arith.real_type:			" set type of source
	ldx6	final_type,x4		" presume short
	ldx5	work|target_precision
	xec	calculate_type,x7		" compare to limit
	tmoz	char.arith.set_round	" within short
	lxl6	final_type,x4		" pick up long type

char.arith.set_round:
	stz	work|save_rounding		" presume no round
	ldx1	target_type_map,x7		" get default
	canx1	round,du
	tze	char.arith.supplied		" no round
	lda	1,dl
	sta	work|save_rounding		" round

"     Caller supplied target type and precision.  Convert input.

char.arith.supplied:
	epp	generic,work|generic_ptr,*	" get ptr to source
	tsx1	move_char_to_generic	" move and set scale/prec, type
	ldx5	work|save_rounding
	epp7	char.arith.real_return	" setup return
	lxl3	work|real.prec		" setup float dec precision
	eax3	2,x3			" extend for sign and hard exp
	ldx2	work|real.type		" get internal type
	tra	*+1,x2			" process generic
	tra	flt_dec_generic_conversion	" presume 0.0
	tra	fix_bin_generic_conversion
	tra	flt_bin_generic_conversion
	tra	flt_dec_generic_conversion
	tra	flt_dec_generic_conversion

char.arith.real_return:
	ldi	mask_faults,dl		" clear for faults again
	ldx1	target_type_map,x6		" get flag word for target
	canx1	complex,du		" complex?
	tze	unmask_exit		" real target, return

"     Convert imaginary part.

	mlr	(pr),(pr)			" move imag to real
	desc9a	work|imag_token,token_length
	desc9a	work|real_token,token_length

	epp	generic,work|generic_ptr,*	" get ptr to source
	tsx1	move_char_to_generic	" move and set scale/prec
	ldx5	work|save_rounding
	epp7	unmask_exit		" setup return
	lxl3	work|real.prec		" setup float dec precision
	eax3	2,x3			" extend for sign and hard exp
	ldx2	work|real.type		" get internal type
	tra	*+1,x2			" process generic
	tra	flt_dec_generic_conversion	" +0 already set
	tra	fix_bin_generic_conversion
	tra	flt_bin_generic_conversion
	tra	flt_dec_generic_conversion
	tra	flt_dec_generic_conversion


"     Input of real and imaginary is zero.  Use a default input.

char.arith.zero:
	epp	generic,char.arith.zero_char
	lda	1,dl			" one character long
	sta	work|source_string_length
	tra	char_to_arithmetic_restart

char.arith.zero_char:
	aci	/0/,1
"Tables for type conversion.


"     Dominant type table.  Used to convert a real and imaginary type into
"     the dominant complex type.  First table references the other four.
"     Here we have a 0 entry for a non-existant token type default of 0.

"     The following matrix provides conversions and determines precision
"     conversion.
"
"   REAL TYPE
"
"     0 type | error  | fixbin | fltbin | fixdec | fltdec |
"	   |        | as is  | as is  | as is  | as is  |
"	   ---------------------------------------------|
"     fixbin | fixbin | fixbin | fltbin | fixbin | fltbin |
"	   | as is  | as is  | as is  |dec->bin|dec->bin|
"	   ---------------------------------------------|
"     fltbin | fltbin | fltbin | fltbin | fltbin | fltbin |
"	   | as is  | as is   | as is |dec->bin|dec->bin|
"	   ---------------------------------------------|
"     fixdec | fixdec | fixbin | fltbin | fixdec | fltdec |
"	   | as is  |dec->bin|dec->bin| as is  | as is  |
"	   ---------------------------------------------|
"     fltdec | fltdec | fltbin | fltbin | fltdec | fltdec |
"	   | as is  |dec->bin|dec->bin| as is  | as is  |
"	   ---------------------------------------------|
"  IMAG TYPE   0 type   fixbin   fltbin   fixdec   fltdec


dominant_type:
	arg	fixdec_type	" use default if real is 0
	arg	fixbin_type
	arg	fltbin_type
	arg	fixdec_type
	arg	fltdec_type

"     Table element has DU type and DL conversion routine.  This conversion
"     routine is used to convert precision and scale as necessary according
"     to the output type and the real and imaginary sources.  as_is just
"     passes on the scale and precision.

fixbin_type:
	vfd	18/fixbin,18/as_is		" stay in type, use real part
	vfd	18/fixbin,18/as_is		" stay in type, prec/scale
	vfd	18/fltbin,18/as_is		" co-erce fixbin to fltbin
	vfd	18/fixbin,18/i_dec_to_xbin	" co-erce fixdec to fixbin
	vfd	18/fltbin,18/i_dec_to_bin	" co-erce fltdec to fltbin

fltbin_type:
	vfd	18/fltbin,18/as_is		" stay in type
	vfd	18/fltbin,18/as_is		" co-erce fixbin to fltbin
	vfd	18/fltbin,18/as_is		" stay in type
	vfd	18/fltbin,18/i_dec_to_bin	" co-erce fixdec to fltbin
	vfd	18/fltbin,18/i_dec_to_bin	" co-erce fltdec to fltbin

fixdec_type:
	vfd	18/fixdec,18/as_is		" stay in type
	vfd	18/fixbin,18/r_dec_to_xbin	" co-erce fixdec to fixbin
	vfd	18/fltbin,18/r_dec_to_bin	" co-erce fixdec to fltbin
	vfd	18/fixdec,18/as_is		" stay in type
	vfd	18/fltdec,18/as_is		" co-erce fixdec to fltdec

fltdec_type:
	vfd	18/fltdec,18/as_is		" stay in type
	vfd	18/fltbin,18/r_dec_to_bin	" co-erce fixbin to fltbin
	vfd	18/fltbin,18/r_dec_to_bin	" co-erce fltdec to fltbin
	vfd	18/fltdec,18/as_is		" co-erce fixdec to fltdec
	vfd	18/fltdec,18/as_is		" stay in type
"     Type table for conversion of internal to real data type.  DU is
"     short form, DL is long form.

	equ	real_fix_bin_1,1
	equ	real_fix_bin_2,2
	equ	real_flt_bin_1,3
	equ	real_flt_bin_2,4
	equ	cplx_fix_bin_1,5
	equ	cplx_fix_bin_2,6
	equ	cplx_flt_bin_1,7
	equ	cplx_flt_bin_2,8
	equ	real_fix_dec_9bit_ls,9
	equ	real_flt_dec_9bit,10
	equ	cplx_fix_dec_9bit_ls,11
	equ	cplx_flt_dec_9bit,12

final_type:
	vfd	18/real_fix_bin_2*2,18/real_fix_bin_2*2	" default 0 type
	vfd	18/real_fix_bin_1*2,18/real_fix_bin_2*2
	vfd	18/real_flt_bin_1*2,18/real_flt_bin_2*2
	vfd	18/real_fix_dec_9bit_ls*2,18/real_fix_dec_9bit_ls*2
	vfd	18/real_flt_dec_9bit*2,18/real_flt_dec_9bit*2
	vfd	18/cplx_fix_bin_1*2,18/cplx_fix_bin_2*2
	vfd	18/cplx_flt_bin_1*2,18/cplx_flt_bin_2*2
	vfd	18/cplx_fix_dec_9bit_ls*2,18/cplx_fix_dec_9bit_ls*2
	vfd	18/cplx_flt_dec_9bit*2,18/cplx_flt_dec_9bit*2
"Compute precision and scale of final result

"     scale = max(real_scale,imag_scale)
"     precision = scale + max(real_prec-real_scale, imag_prec-imag_scale)
"
"     Result left in source_scale and source_precision fields in work area.


fixed_prec_and_scale:
	ldx2	work|imag.type		" take real if no imag
	tze	fixed_prec_and_scale.real

"     Calculate precisions.

	lxl2	work|real.prec
	sbx2	work|real.scale		" real prec-scale
	lxl3	work|imag.prec
	sbx3	work|imag.scale
	stx3	work|target_precision	" imag prec-scale
	cmpx2	work|target_precision
	tpl	2,ic			" real>imag
	eax2	0,x3			" take imaginary
	adx2	1,du
	ldx3	work|real.scale		" calculate max scale
	cmpx3	work|imag.scale
	tpl	2,ic
	ldx3	work|imag.scale
	stx3	work|target_scale		" set new scale (DU)
	adx2	work|target_scale		" add max scale
	sxl2	work|target_precision	" set new precision (DL)
	tpnz	0,x1
	aos	work|target_precision	" max (prec, 1)
	tra	0,x1

fixed_prec_and_scale.real:
	lda	work|real.prec
	sta	work|target_precision
	ana	=o777777,dl		" mask for precision
	tpnz	0,x1
	aos	work|target_precision	" max (prec, 1)
	tra	0,x1

"     Calculate float precision.

"     precision = max(real_prec, imag_prec)
"
"     Result left in target_precision field in work area.  Scale set to 0.


float_prec:
	lxl2	work|real.prec
	ldx3	work|imag.type		" take real if no imag
	tze	float_prec.real
	lxl3	work|imag.prec
	cmpx2	work|imag.prec
	tpl	2,ic
	eax2	0,x3
float_prec.real:
	sxl2	work|target_precision	" set new precision (DL)
	ldx2	0,du
	stx2	work|target_precision	" zero scale
	lxl2	work|target_precision	" ensure precision >= 1
	tpnz	0,x1
	aos	work|target_precision	" max (prec, 1)
	tra	0,x1



"     Execute table used for calculation of precision and scale according to
"     the dominant target type.

calculate_precision:
	tra	error_bad_type		" must have a type by now
	tsx1	fixed_prec_and_scale
	tsx1	float_prec
	tsx1	fixed_prec_and_scale
	tsx1	float_prec

"     Execute table used for comparison of precision limit to determine
"     long/short data type.

calculate_type:
	tra	error_bad_type		" must have type by now
	cmpx5	35,du			" short limit of fixed bin
	cmpx5	27,du			" short limit of float bin
	cmpx5	59,du			" upper limit of fixed dec
	cmpx5	59,du			" upper limit of float decMove float decimal generic from source character stream.

"     Routine to move character input to float decimal generic form for
"     char_to_arithmetic.  It creates a 36-bit exponent, moves the sign
"     and moves the integer and fractional parts.

"     On entry:
"	X1	is return offset
"	generic	points to source string
"	type of numer in work|imag.type (DU)
"
"     On exit we have stored the appropriate type of float decimal generic,
"	fix_bin_generic or flt_bin_generic.
"	We have also set source_precision and source_scale and X7.

move_char_to_generic:
	ldx2	work|real.type
	tra	*+1,x2
	tra	char_to_generic.zero_dec
	tra	char_to_generic.fixbin
	tra	char_to_generic.fltbin
	tra	char_to_generic.fixdec
	tra	char_to_generic.fltdec

char_to_generic.zero_dec:
	lda	1,dl			" set source scale/prec
	sta	work|source_precision
	sta	work|real.prec		" same in token
	stz	work|flt_dec_generic_exp	" clear exponent
	lda	dec_zero			" implant +0
	sta	work|flt_dec_generic
	tra	0,x1
	
char_to_generic.fixdec:
char_to_generic.fltdec:
	stz	work|source_scale		" kill the scale
	ldx7	real_flt_dec_generic*2,du	" set type of data moved to
	ldx2	work|real.integer.length	" get precision (DU)
	adx2	work|real.fraction.length
	tmoz	char_to_generic.zero_dec	" default to 0.0
	cmpx2	max_p_dec,du		" see if too many digits
	tpnz	error_218
	sxl2	work|source_precision	" save precision
	lda	work|real.fraction.length	" get fractional length
	ars	18		
	ssa	work|real.exponent.value	" form fraction - exponent
	lca	work|real.exponent.value	" save generic's exponent
	sta	work|flt_dec_generic_exp

"     Move in sign.

	ldx2	work|real.sign.length	" length in DU
	lxl3	work|real.sign.index	" index in DL
	ldx4	1,du			" move 1 char
	mlr	(pr,rl,x3),(pr,rl),fill(plus_sign)
	desc9a	generic|0,x2		" fills "+" if no sign
	desc9a	work|flt_dec_generic,x4

"     Move integer part.

	ldx2	work|real.integer.length	" length of source DU
	lxl4	work|real.integer.index	" index in source DL
	mlr	(pr,rl,x4),(pr,rl),fill(digit_0)
	desc9a	generic|0,x2
	desc9a	work|flt_dec_generic(1),x2

"     Move fractional part.

	lxl4	work|real.fraction.index	" index in source DL
	ldx3	work|real.fraction.length	" length of source DU
	mlr	(pr,rl,x4),(pr,rl,x2),fill(digit_0)
	desc9a	generic|0,x3
	desc9a	work|flt_dec_generic(1),x3
	tra	0,x1			" return for next section
"Move fixed bin generic from source character stream.

"     Here we will receive an integer and a fractional part.  They must
"     be converted to bits and stored.  They have been pre-checked.
"
"     Number is converted from the lower bits to the higher bits.
"     Precision is set, scale was set by recognize.

char_to_generic.fixbin:
	ldx7	real_fix_bin_2*2,du		" set type of output
	ldx2	work|real.scale		" copy scale
	stx2	work|source_scale
	ldx2	work|real.fraction.length	" length of fraction
	adx2	work|real.integer.length	" plus length of integer
	cmpx2	max_p_fix_bin_2,du		" see if too many digits
	tpnz	error_218
	sxl2	work|source_precision	" gives precision
	epp	source,work|fix_bin_generic	" point to target area
	stz	source|0			" pre-set
	stz	source|1
	ldx5	71,du			" bit index of target
	ldx4	work|real.fraction.length	" get length
	tze	char.gen.fixbin.int

	lxl3	work|real.fraction.index	" get index
	adx3	work|real.fraction.length	" plus length +1
	tsx2	move_char_to_bit_right	" move right to left

"     Do integer part next.  Abbut to fraction.

char.gen.fixbin.int:
	ldx4	work|real.integer.length	" get length
	tze	char.gen.fixbin.exit_1	" set precision and exit
	lxl3	work|real.integer.index	" get index
	adx3	work|real.integer.length	" plus length+1
	tsx2	move_char_to_bit_right	" move right to left
	tra	char.gen.fixbin.exit

char.gen.fixbin.exit_1:
	ldx3	1,du
	sxl3	work|real.prec		" indicate source prec is 1

char.gen.fixbin.exit:
	ldx4	work|real.sign.length	" length of sign
	tze	0,x1			" default + sign
	lxl3	work|real.sign.index	" index of sign
	cmpc	(pr,x3),(),fill(plus_sign)
	desc9a	generic|0,1
	zero
	tze	0,x1			" + sign
	ldaq	work|fix_bin_generic	" form negative
	negl
	tov	size_error		" -2**72 won't fit
	staq	work|fix_bin_generic
	tra	0,x1
"Move float bin generic from source character stream.
"     Here we will receive an integer and a fractional part.  They must
"     be converted to bits and stored.  They have been pre-checked.
"     Number is converted from the lower bits to the higher bits, it is
"     stored starting from integer+fractional length from the top, and
"     the exponent is set to integer length + exponent.

char_to_generic.fltbin:
	ldx7	real_flt_bin_2*2,du		" set type of output
	ldx2	work|real.fraction.length	" length of fraction
	stz	work|source_scale
	adx2	work|real.integer.length	" plus length of integer
	cmpx2	max_p_flt_bin_2,du		" see if too many digits
	tpnz	error_218
	sxl2	work|source_precision	" gives precision
	lda	work|real.integer.length	" get length DU
	ars	18
	ada	work|real.exponent.value
	sta	work|flt_bin_generic_exp	" store the flt bin gen exp
	epp	source,work|flt_bin_generic	" point to target area
	stz	source|0
	stz	source|1			" pre-set mantissa
	ldx5	work|real.fraction.index	" bit index of target
	adx5	work|real.integer.length
	ldx4	work|real.fraction.length	" get length
	tze	char.gen.fltbin.int

	lxl3	work|real.fraction.index	" get index
	adx3	work|real.fraction.length
	tsx2	move_char_to_bit_right	" move right to left

"     Do integer part next.  Abbut to fraction.

char.gen.fltbin.int:
	ldx4	work|real.integer.length	" get length
	tze	char.gen.fltbin.exit_1
	lxl3	work|real.integer.index	" get index
	adx3	work|real.integer.length
	tsx2	move_char_to_bit_right	" move right to left
	tra	char.gen.fltbin.exit

char.gen.fltbin.exit_1:
	ldx3	1,du			" indicate source precision 1
	sxl3	work|real.prec

char.gen.fltbin.exit:
	ldx4	work|real.sign.length	" length of sign
	tze	0,x1			" default + sign
	lxl3	work|real.sign.index	" index of sign
	cmpc	(pr,x3),(),fill(plus_sign)
	desc9a	generic|0,1
	zero
	tze	0,x1			" + sign
	ldaq	work|flt_bin_generic	" form negative
	lde	0,du
	fneg
	staq	work|flt_bin_generic
	lda	=-1,du			" form -1 to correct exp
	ars	18
	asa	work|flt_bin_generic_exp	" account for shift in fneg
	tra	0,x1

"     x3 is index into character string and is pre-decremented.
"     x4 is length of character string and is decremented.
"     x5 is index into bit string and is decremented.

move_char_to_bit_right:
	sbx3	1,du			" move source index
	scm	(),(pr,x3),mask(000)	" check 0 or 1
	desc9a	char.bit.01,2	
	desc9a	generic|0,1
	arg	work|flt_dec_generic_exp	" lowermost bit will be good
	csl	(pr),(pr,x5),bool(move)	" as true digit value
	descb	work|flt_dec_generic_exp(35),1
	descb	source|0,1
	sbx5	1,du			" move target index
	sbx4	1,du			" count bit done
	tpnz	move_char_to_bit_right
	tra	0,x2RECOGNIZE A REAL CONSTANT

"     recognize a <real constant>
"     entered with
"	char offset in ql
"	char length in al
"	token area to use is imag_token
"	return offset in x2
"	pointer to source string in generic
"
"     exits with
"	char offset in ql
"	char length (remaining) in al
"	type in x7
"	token area filled in

recognize:
	ldx7	fixdec,du			" preset to fixed decimal

"     Check for sign.  Translate and test next character.

	mvt	(pr,ql),(pr)		" translate first character
	desc9a	generic|0,1
	desc9a	work|flt_bin_generic_exp,1
	arg	translate_table

	cmpc	(pr),(),fill(sign_class)	" test if in classification
	desc9a	work|flt_bin_generic_exp,1
	zero
	tnz	recognize.no_sign

"     Note sign index and length of 1.

	stq	work|imag.sign.index	" index in DL
	ldx3	1,du
	stx3	work|imag.sign.length	" length of 1
	sba	1,dl			" done one character
	tmoz	error_202			" error - no digits found
	adq	1,dl			" skip sign

"     Check for integer part.

recognize.no_sign:
	tct	(pr,rl,ql)		" skip over string of digits
	desc9a	generic|0,al
	arg	digit_skip
	arg	work|fix_bin_generic
	lxl3	work|fix_bin_generic	" get number of digits found
	tze	recognize.no_integer	" skip if none

"     Note that a mantissa exists by leaving a non-zero X3, and clip the
"     leading 0's from it to remove them from significance checks.

	eax4	0,x3			" remember mantissa size
	tct	(pr,rl,ql)		" skip over leading 0's
	desc9a	generic|0,x3
	arg	zero_skip
	arg	work|flt_bin_generic
	lxl5	work|flt_bin_generic
	stx5	work|flt_bin_generic	" move to upper
	eax5	0,ql			" setup index
	sbx4	work|flt_bin_generic	" length of non-zero int
	adx5	work|flt_bin_generic	" index of 1st non-zero

"     Store length of integer part, and its index.

	sxl5	work|imag.integer.index	" significance index in DL
	stx4	work|imag.integer.length	" length of sig string in DU
	stba	work|fix_bin_generic,40	" clear upper byte
	adq	work|fix_bin_generic	" move string index
	sba	work|fix_bin_generic	" count all digits done
	tmoz	recognize.no_more_input	" no chars left

"     Check for decimal point, or other situations.

recognize.no_integer:
	mvt	(pr,ql),(pr)		" translate terminator
	desc9a	generic|0,1
	desc9a	work|fix_bin_generic(1),1
	arg	translate_table
	ldx4	work|fix_bin_generic	" get character class
	anx4	=o777,du			" mask for it
	tra	*+1,4
	tra	error_203			" illegal
	tra	recognize.finish_up		" sign (start imag?)
	tra	recognize.start_fractional	" period
	tra	recognize.have_bin		" b
	tra	recognize.start_exponent_flt	" d e
	tra	recognize.finish_up		" i
	tra	recognize.finish_up		" blank
	zero	0			" digit (can't happen)
	tra	recognize.start_scaled_fix	" f

"	have "." after (possibly empty) string of digits

recognize.start_fractional:
	adq	1,dl			" account for .
	sba	1,dl
	tpnz	recognize.scan_fraction	" fractional digits
	cmpx3	0,du			" legitimate integer?
	tpnz	recognize.finish_up		" digits already seen
	sbq	1,dl			" no digits before/after "."
	tra	error_202

"     Find limits of fractional digits.

recognize.scan_fraction:
	tct	(pr,rl,ql)		" skip over string of digits
	desc9a	generic|0,al
	arg	digit_skip
	arg	work|fix_bin_generic
	lxl5	work|fix_bin_generic	" get number of digits
	tze	recognize.no_fraction

"     Fractional digits present.  Note where and how many.

	stq	work|imag.fraction.index	" save index in DL
	stx5	work|imag.fraction.length	" save length in DU
	adx3	work|imag.fraction.length	" form total precision
	stbq	work|fix_bin_generic,40	" clear high byte digit count
	adq	work|fix_bin_generic	" account for digits
	sba	work|fix_bin_generic
	tmoz	recognize.no_more_input	" exit if end reached

"     we are scanning character after string of fractional digits

recognize.no_fraction:
	mvt	(pr,ql),(pr)		" translate terminator
	desc9a	generic|0,1
	desc9a	work|fix_bin_generic(1),1
	arg	translate_table
	ldx4	work|fix_bin_generic	" get char type
	anx4	=o777,du
	tra	*+1,4
	tra	error_203			" illegal
	tra	recognize.finish_up		" sign
	tra	error_204			" period
	tra	recognize.have_bin		" b
	tra	recognize.start_exponent_flt	" d e
	tra	recognize.finish_up		" i
	tra	recognize.finish_up		" blank
	zero	0			" digit (can't happen)
	tra	recognize.start_scaled_fix	" f

"     we have "d" or "e" after mantissa

recognize.start_exponent_flt:
	eax7	fltdec			" change type

"     we have "f" after mantissa

recognize.start_scaled_fix:
	cmpx3	0,dl
	tze	error_214			" no digits before e or f
	adq	1,dl			" account for exponent start
	sba	1,dl
	tmoz	error_201
	mvt	(pr,ql),(pr)		" translate terminator
	desc9a	generic|0,1
	desc9a	work|fix_bin_generic,1
	arg	translate_table
	cmpc	(pr),(),fill(sign_class)	" check for sign
	desc9a	work|fix_bin_generic,1
	zero
	tnz	recognize.unsigned_exponent

"      have start of signed exponent

	adq	1,dl			" account for sign
	sba	1,dl
	tmoz	error_201
	tct	(pr,rl,ql)		" skip over string of digits
	desc9a	generic|0,al
	arg	digit_skip
	arg	work|fix_bin_generic
	lxl5	work|fix_bin_generic	" get number of digits
	tze	error_201			" no digits in exponent
	cmpx5	11,du			" check for max digits
	tpl	error_213			" too many digits
	adx5	1,du			" allow for sign
	dtb	(pr,rl,ql),(pr)		" convert exponent to binary
	desc9ls	source|-1(3),x5
	desc9a	work|imag.exponent.value,4
	tra	recognize.common_exponent

"     have start of unsigned exponent

recognize.unsigned_exponent:
	tct	(pr,rl,ql)		" skip over string of digits
	desc9a	generic|0,al
	arg	digit_skip
	arg	work|fix_bin_generic
	lxl5	work|fix_bin_generic	" get number of digits
	tze	error_201			" no digits
	cmpx5	11,du			" check for max digits
	tpl	error_213
	dtb	(pr,rl,ql),(pr)		" convert exponent to binary
	desc9ns	generic|0,x5
	desc9a	work|imag.exponent.value,4

recognize.common_exponent:
	stbq	work|fix_bin_generic,40	" clear high byte digit count
	adq	work|fix_bin_generic	" count exponent digits
	sba	work|fix_bin_generic
	tmoz	recognize.no_more_input

"	we are scanning character after exponent field

	mvt	(pr,ql),(pr)		" translate terminator
	desc9a	generic|0,1
	desc9a	work|fix_bin_generic(1),1
	arg	translate_table
	ldx4	work|fix_bin_generic	" get character class
	anx4	=o777,du
	tra	*+1,4
	tra	error_203			" illegal
	tra	recognize.finish_up		" sign
	tra	error_204			" period
	tra	recognize.have_bin		" b
	tra	error_207			" d e
	tra	recognize.finish_up		" i
	tra	recognize.finish_up		" blank
	zero	0			" digit (can't happen)
	tra	error_207			" f

"     have "b" at end, validate bit input form of 0 or 1.

recognize.have_bin:
	ldx3	work|imag.integer.length	" get length of integer
	tze	recognize.bin.int		" nothing to check
	lxl4	work|imag.integer.index	" get index of integer
	tct	(pr,rl,x4)		" validate integer part
	desc9a	generic|0,x3
	arg	bit_test
	arg	work|fix_bin_generic	" dummy
	ttf	error_191			" invalid digit

recognize.bin.int:
	ldx3	work|imag.fraction.length	" get length of fraction
	tze	recognize.bin.frac		" nothing to check
	lxl4	work|imag.fraction.index	" get index of fraction
	tct	(pr,rl,x4)		" validate fraction part
	desc9a	generic|0,x3
	arg	bit_test
	arg	work|fix_bin_generic	" dummy
	ttf	error_191			" invalid digit

recognize.bin.frac:
	adq	1,dl			" account for "b"
	sba	1,dl
	eax7	-2,7			" base from dec to bin

"     Entry if input scan is done.  Now fixup terminator.

recognize.end_of_input:
	mvt	(pr,ql),(pr)		" translate terminator
	desc9a	generic|0,1
	desc9a	work|fix_bin_generic(1),1
	arg	translate_table
	ldx4	work|fix_bin_generic	" get character class
	anx4	=o777,du
	tra	recognize.finish_up

"     Entry if input exhausted.

recognize.no_more_input:
	ldx4	blank_class,du		" presume ended on blank
recognize.finish_up:			" accept terminator found
	ldx3	work|imag.integer.length	" for digit count
	adx3	work|imag.fraction.length
	stx7	work|imag.type		" save internal type code
	sxl4	work|imag.term		" save termination character
	ldx3	work|imag.integer.length	" form precision
	adx3	work|imag.fraction.length
	sxl3	work|imag.prec		" save in DL
	ldx4	work|imag.fraction.length
	stx4	work|imag.scale		" save scale in DU

"     Scaled fixed numbers should have the scale corrected for any exponent
"     which may have been specified.

	cmpx7	fixbin,du
	tze	recognize.fix_scale		" fixup scale from exp
	cmpx7	fixdec,du
	tnz	0,2			" not a fixed type

recognize.fix_scale:
	ldx4	work|imag.exponent.value	" load upper part
	tze	recognize.finish_scale	" okay if clear
	tpl	error_208			" big
	cmpx4	=o777777,du		" okay if -1
	tnz	error_209			" small

recognize.finish_scale:
	lxl4	work|imag.exponent.value	" get exponent
	sbx4	work|imag.scale		" -scale
	tmi	recognize.scale_pos		" negative scale
	cmpx4	-min_scale,du
	tpnz	error_209			" scale too small
	erx4	=o777777,du		" complement
	adx4	1,du			" add one
	stx4	work|imag.scale		" save scale
	tra	0,2			" return

recognize.scale_pos:
	erx4	=o777777,du		" complement
	adx4	1,du			" add one
	cmpx4	max_scale,du
	tpnz	error_208			" scale too big
	stx4	work|imag.scale		" save scale
	tra	0,2			" returnTable of translations for errors.  Only valid info will be 0.

"     This table is used to initially check the incoming string, and is a full
"     9-bit translation.  This permits the other tables to be much smaller and
"     only encompass the contiguous zero-area of this table.

error_table:
	oct	777777777777,777777777777	000 - 007
	oct	777777777777,777777777777	010 - 017
	oct	777777777777,777777777777	020 - 027
	oct	777777777777,777777777777	030 - 037
	oct	000777777777,777777777777	040 - 047 blank
	oct	777777777000,777000000777	050 - 057 + - .
	oct	000000000000,000000000000	060 - 061 01234567
	oct	000000777777,777777777777	070 - 077 89
	oct	777777000777,000000000777	100 - 107 B D E F
	oct	777000777777,777777777777	110 - 117 I
	oct	777777777777,777777777777	120 - 127
	oct	777777777777,777777777777	130 - 137
	oct	777777000777,000000000777	140 - 147 b d e f
	oct	777000777777,777777777777	150 - 157 i
	oct	777777777777,777777777777	160 - 167
	oct	777777777777,777777777777	170 - 177
	oct	777777777777,777777777777	200 - 207
	oct	777777777777,777777777777	210 - 217
	oct	777777777777,777777777777	220 - 227
	oct	777777777777,777777777777	230 - 237
	oct	777777777777,777777777777	240 - 247
	oct	777777777777,777777777777	250 - 257
	oct	777777777777,777777777777	260 - 267
	oct	777777777777,777777777777	270 - 277
	oct	777777777777,777777777777	300 - 307
	oct	777777777777,777777777777	310 - 317
	oct	777777777777,777777777777	320 - 327
	oct	777777777777,777777777777	330 - 337
	oct	777777777777,777777777777	340 - 347
	oct	777777777777,777777777777	350 - 357
	oct	777777777777,777777777777	360 - 367
	oct	777777777777,777777777777	370 - 377
	oct	777777777777,777777777777	400 - 407
	oct	777777777777,777777777777	410 - 417
	oct	777777777777,777777777777	420 - 427
	oct	777777777777,777777777777	430 - 437
	oct	777777777777,777777777777	440 - 447
	oct	777777777777,777777777777	450 - 457
	oct	777777777777,777777777777	460 - 467
	oct	777777777777,777777777777	470 - 477
	oct	777777777777,777777777777	500 - 507
	oct	777777777777,777777777777	510 - 517
	oct	777777777777,777777777777	520 - 527
	oct	777777777777,777777777777	530 - 537
	oct	777777777777,777777777777	540 - 547
	oct	777777777777,777777777777	550 - 557
	oct	777777777777,777777777777	560 - 567
	oct	777777777777,777777777777	570 - 577
	oct	777777777777,777777777777	600 - 607
	oct	777777777777,777777777777	610 - 617
	oct	777777777777,777777777777	620 - 627
	oct	777777777777,777777777777	630 - 637
	oct	777777777777,777777777777	640 - 647
	oct	777777777777,777777777777	650 - 657
	oct	777777777777,777777777777	660 - 667
	oct	777777777777,777777777777	670 - 677
	oct	777777777777,777777777777	700 - 707
	oct	777777777777,777777777777	710 - 717
	oct	777777777777,777777777777	720 - 727
	oct	777777777777,777777777777	730 - 737
	oct	777777777777,777777777777	740 - 747
	oct	777777777777,777777777777	750 - 757
	oct	777777777777,777777777777	760 - 767
	oct	777777777777,777777777777	770 - 777Source checking tables.

"	Table used to encode the input string:
"
"       encoding  characters
"	0	(Any other characters)
"	1	+ -
"	2	.
"	3	B b
"	4	D E d e
"	5	I i
"	6	SP
"	7	0 1 2 3 4 5 6 7 8 9
"	8	F f

translate_tab:
	oct	006000000000,000000000000	040 - 047
	oct	000000000001,000001002000	050 - 057
	oct	007007007007,007007007007	060 - 061
	oct	007007000000,000000000000	070 - 077
	oct	000000003000,004004010000	100 - 107
	oct	000005000000,000000000000	110 - 117
	oct	000000000000,000000000000	120 - 127
	oct	000000000000,000000000000	130 - 137
	oct	000000003000,004004010000	140 - 147
	oct	000005000000		150 - 153

	equ	translate_table,translate_tab-8

"     Table for finding contiguous digit streams.

digit_tab:
	oct	777777777777,777777777777	040 - 047
	oct	777777777777,777777777777	050 - 057
	oct	000000000000,000000000000	060 - 067
	oct	000000777777,777777777777	070 - 077
	oct	777777777777,777777777777	100 - 107
	oct	777777777777,777777777777	110 - 117
	oct	777777777777,777777777777	120 - 127
	oct	777777777777,777777777777	130 - 137
	oct	777777777777,777777777777	140 - 147
	oct	777777777777		150 - 153

	equ	digit_skip,digit_tab-8


"     Table for finding contiguous spaces.

blank_tab:
	oct	000777777777,777777777777	040 - 047
	oct	777777777777,777777777777	050 - 057
	oct	777777777777,777777777777	060 - 067
	oct	777777777777,777777777777	070 - 077
	oct	777777777777,777777777777	100 - 107
	oct	777777777777,777777777777	110 - 117
	oct	777777777777,777777777777	120 - 127
	oct	777777777777,777777777777	130 - 137
	oct	777777777777,777777777777	140 - 147
	oct	777777777777		150 - 153

	equ	blank_skip,blank_tab-8

"     Table used to validate bit input.  Very short since we know input is
"     pre-validated numeric digits.

bit_tab:
	oct	000000777777,777777777777	060 - 061 only 0 and 1
	oct	777777777777		070 - 073

	equ	bit_test,bit_tab-8-4


"     Table of translation values to check leading zeros.
"     True beginning is offset 40(8) characters above true table.

zero_tab:
	oct	777777777777,777777777777	040 - 047
	oct	777777777777,777777777777	050 - 057
	oct	000777777777,777777777777	060 - 067
	oct	777777777777,777777777777	070 - 077
	oct	777777777777,777777777777	100 - 107
	oct	777777777777,777777777777	110 - 117
	oct	777777777777,777777777777	120 - 127
	oct	777777777777,777777777777	130 - 137
	oct	777777777777,777777777777	140 - 147
	oct	777777777777		150 - 153

	equ	zero_skip,zero_tab-8
"Call GENERIC to target conversion
" Register conventions for source PUT routines.
" (all routines specified in the table below).  All registers named below,
" must be preserved by the conversion routine.
"
"	pr0	(reserved - pl1_operators_ ptr)
"	pr1	points to target.
"	pr3	points to source.
"	pr5	points to work area.
"	pr6	(reserved - stack_frame ptr)
"	pr7	points to return location in any_to_any_.
"	x0	return offset in user program.
"	x3	for decimal target routines is size of flt_dec_generic.
"	x5	0 if no round, 1 if round.
"	x6	target type.
"	x7	source type.

"	work|scales	stored scales (in upper halves)
"	work|precisions	stored precisions (in lower halves)
"
"     Decimal PUT routines require X3 as the size of the floating decimal
"     generic variable, including sign and hardware exponent.

"     In this calling sequence x6 is the target type and the GENERIC form
"     is correctly stored in the work area.  Store in target form and update
"     target pointer.



generic_to_target:
	lxl1	target_type_map,x6
	tra	0,x1			" call for target conversion
"GENERIC to Fixed Binary Target Conversion


"     GENERIC to Fixed Binary Target Conversion
"     Unsigned Cases and some Signed Cases

put_fix_bin_1uns:
	ldaq	work|fix_bin_generic	" size the value
	stq	target|0			" and put to target
	lxl2	work|target_precision	" check overflow
	lrl	0,x2
	tnz	size_error
	epp	target,target|1		" update target pointer
	tra	pr7|0			" return

put_fix_bin_1:
	ldaq	work|fix_bin_generic
	stq	target|0			" and store
	lxl2	work|target_precision	" check precision
	erx2	=o777777,du		" -precision-1
	lls	72,x2			" 72-precision-sign
	trc	size_error		" too big
	epp	target,target|1		" update target pointer
	tra	pr7|0			" return

put_fix_bin_2uns:
	ldaq	work|fix_bin_generic
	staq	target|0			" and store
	lxl2	work|target_precision	" check overflow
	lrl	0,x2
	tnz	size_error
	epp	target,target|2		" update target pointer
	tra	pr7|0			" return

put_fix_bin_2:
	ldaq	work|fix_bin_generic
	staq	target|0			" and store
	lxl2	work|target_precision	" check overflow
	erx2	=o777777,du		" -precision-1
	lls	72,x2			" 72-precision-sign
	trc	size_error		" too big
	epp	target,target|2		" update target pointer
	tra	pr7|0			" return

"     Calculate first bit position from: -(precision-72-1)-1

put_fix_bin_1uns_packed:
put_fix_bin_2uns_packed:
	lxl3	work|target_precision
	ldaq	work|fix_bin_generic
	lrl	0,x3			" check overflow
	tnz	size_error		" leftover bits
	eax2	-73,x3			" form start bit position
	erx2	=o777777,du
	csl	(pr,rl,x2),(pr,rl),bool(move)
	descb	work|fix_bin_generic,x3
	descb	target|0,x3
	abd	target|0,x3		" update target pointer
	tra	pr7|0			" return

"     Packed Signed Cases

"     Calculate first bit position from: -((precision+1)-72-1)-1

put_fix_bin_1_packed:
put_fix_bin_2_packed:
	lxl3	work|target_precision
	eax3	1,x3			" account for sign
	ldaq	work|fix_bin_generic
	eax2	-73,x3			" form start bit position
	erx2	=o777777,du
	lls	0,x2			" check overflow
	trc	size_error		" sign change due to shift
	csl	(pr,rl,x2),(pr,rl),bool(move)
	descb	work|fix_bin_generic,x3
	descb	target|0,x3
	abd	target|0,x3		" update target pointer
	tra	pr7|0			" return
"GENERIC to Float Binary Target Conversion

"     Rounding is done to the desired precision.

put_flt_bin_1:
	ldx2	27,du			" round precision
	tsx1	load_rounded_flt_bin
	fst	target|0			" store away
	epp	target,target|1		" update target pointer
	tra	pr7|0			" return


put_flt_bin_2:			" target store double precision
	ldx2	63,du			" round precision
	tsx1	load_rounded_flt_bin
	dfst	target|0			" store away
	epp	target,target|2		" update target pointer
	tra	pr7|0			" return


put_flt_bin_1_packed:
put_flt_bin_2_packed:
	lxl2	work|target_precision	" get round precision
	tsx1	load_rounded_flt_bin
	dfst	work|flt_bin_generic

	eax2	8+1,x2			" account for sign and exp
	csl	(pr,rl),(pr,rl),bool(move)	" move to target
	descb	work|flt_bin_generic,x2
	descb	target|0,x2
	abd	target|0,x2		" update target pointer
	tra	pr7|0			" return



"     Output float binary generic form.

put_flt_bin_gen:
	lda	work|flt_bin_generic_exp	" move exponent
	sta	target|2
	stz	work|flt_bin_generic_exp	" clear for load_round
	ldaq	work|flt_bin_generic	" check for zero
	tze	put_flt_bin_gen.zero

	ldx2	63,du			" round to 63
	tsx1	load_rounded_flt_bin
	ste	work|flt_bin_generic_exp
	lde	0,du			" clear exponent
	dfst	target|0			" move mantissa
	lda	work|flt_bin_generic_exp
	ars	36-8
	asa	target|2
	epp	target,target|4		" update target pointer
	tra	pr7|0

put_flt_bin_gen.zero:
	stz	target|0			" zero output
	stz	target|1
	stz	target|2
	epp	target,target|4		" update target pointer
	tra	pr7|0
"     Load the float bin generic to a true float bin and round to the
"     precision specified.

"     Called with:
"	x1 = return address.
"	x2 = precision to round to.

load_rounded_flt_bin:
	lda	work|flt_bin_generic_exp
	als	36-8			" make short exponent
	trc	flt_range_error		" won't fit
	sta	work|flt_bin_generic_exp
	ldaq	work|flt_bin_generic	" get mantissa
	lde	work|flt_bin_generic_exp	" get exponent
	fno				" find 0.0
	tze	0,x1			" cannot round
	cmpx5	0,du
	tze	0,x1			" no round
	
	stx2	work|flt_bin_generic_exp	" two word mask entries
	eax3	0,x2
	adx3	work|flt_bin_generic_exp
	cmpa	0,du
	tmi	load_rounded_flt_bin.negative
	adaq	mask_table+2,x3		" round

"     Normalize to recover any possible overflow situation.

	fno
	ldi	mask_faults,dl		" clear possible overflow
	tra	0,x1

load_rounded_flt_bin.negative:
	fneg
	adaq	mask_table+2,x3		" round
	fno				" fix overflow
	staq	work|fix_bin_generic	" temp save
	ldi	mask_faults,dl		" clear possible overflow
	lda	=o400000,du		" generate mask
	ldq	=0,dl
	lrs	0,x2			" mask for precision+sign
	anaq	work|fix_bin_generic
	fneg
	tra	0,x1
"GENERIC to Float Hexadecimal Target Conversion

"     Here we must convert the generic flt_bin value to hexadecimal and
"     output it to the target.  We will do a round here, since hex round is
"     different that normal binary round and therefore must be an additional
"     treatment.

put_flt_hex_1:
	ldx2	27,du			" do single prec round
	tsx1	convert_flt_bin_to_flt_hex	" common conversion
	fst	target|0
	epp	target,target|1		" update target pointer
	tra	pr7|0			" return


put_flt_hex_2:
	ldx2	63,du		" do double prec round
	tsx1	convert_flt_bin_to_flt_hex	" common conversion
	dfst	target|0
	epp	target,target|2		" update target pointer
	tra	pr7|0			" return


put_flt_hex_1_packed:
put_flt_hex_2_packed:
	lxl2	work|target_precision
	tsx1	convert_flt_bin_to_flt_hex	" common conversion
	dfst	work|flt_bin_generic
	eax2	8+1,x2			" account for sign and exp
	csl	(pr,rl),(pr,rl),bool(move)
	descb	work|flt_bin_generic,x2
	descb	target|0,x2
	abd	target|0,x2		" update target pointer
	tra	pr7|0
"Convert float bin generic to rounded float hexadecimal.

"     Common conversion routine since there are four calls to convert bin to
"     hex.  Converts in place in the flt_bin_generic.  Rounding is done if
"     requested by X5^=0.  X2 has rounding precision.
"     Result after round is left normalized.
"
"     Called by:
"	tsx1	convert_flt_bin_to_flt_hex
"
"     Leaves double float hex value in EAQ.

convert_flt_bin_to_flt_hex:
	lca	work|flt_bin_generic_exp	" form shift in x3
	ana	=3,dl			" mask for count 0-3
	eax3	0,al
	lda	work|flt_bin_generic_exp	" form hex exp
	ada	=3,dl			" correct exp ceiling
	ars	2			" divide by 4
	als	36-8			" shift to check range
	trc	flt_range_error		" too big
	sta	work|flt_bin_generic_exp
	ldaq	work|flt_bin_generic	" get value
	tze	c_flt_bin_to_flt_hex.zero	" get normalized zero
	lrs	0,3			" hex normalize
	lde	work|flt_bin_generic_exp	" form full hex with exp

"     Rounding is done according to PL/I rules.  Round up for positive, round
"     down for negative.  Result is left normalized.

	cmpx5	0,du			" see if rounding
	tze	0,x1			" none - return
	stx2	work|flt_bin_generic_exp	" 2 word mask entries
	eax3	0,x2
	adx3	work|flt_bin_generic_exp
	canaq	mask_table+2,x3		" if zero bits, then won't round
	tze	0,x1
	cmpa	=0,dl			" determine sign of mantissa
	tmi	c_flt_bin_to_flt_hex.neg

	adaq	mask_table+2,x3		" round AQ
	tov	c_flt_bin_to_flt_hex.norm_pos	" normalize needed
	tra	0,x1			" return to put routine

c_flt_bin_to_flt_hex.zero:
	fld	=0.0,du			" load normalized 0.0
	tra	0,x1			" return to put routine

c_flt_bin_to_flt_hex.neg:			" round down
	negl
	adaq	mask_table+2,x3		" 1 bit higher
	tov	c_flt_bin_to_flt_hex.norm_neg	" normalize needed
	tra	c_flt_bin_to_flt_hex.normal

"     Overflow bit indicates sign changed on positive mantissa.  Thus the
"     Logical Right shift recovers the sign bit as the carry.

c_flt_bin_to_flt_hex.norm_neg:		" shift right 4 and gen sign
	lrl	4
	ade	=1b25,du			" adjust exponent
	teo	flt_range_error		" too big rounded
c_flt_bin_to_flt_hex.normal:
	staq	work|fix_bin_generic	" temp save
	lda	=o400000,du		" generate mask
	ldq	=0,dl
	lrs	0,x2			" mask for precision+sign
	anaq	work|fix_bin_generic
	negl
	tra	0,x1			" return to put routine

c_flt_bin_to_flt_hex.norm_pos:		" shift right 4 and inc exp
	lrl	4
	ade	=1b25,du
	teo	flt_range_error		" too big rounded
	tra	0,x1			" return to put routine
"GENERIC to Float Decimal 9 Target Conversion
"     On entry X3 holds the length of the floating decimal number, including
"     sign and exponent byte.

put_flt_dec_9:
put_flt_dec_9_packed:
	lxl2	work|target_precision
	eax2	2,x2			" form true target length
	lda	work|flt_dec_generic_exp	" range the exponent
	als	36-8
	trc	decimal_range_error
	mlr	(pr),(pr,x3)		" move to generic
	desc9a	work|flt_dec_generic_exp(3),1
	desc9a	work|flt_dec_generic-1(3),1
	xec	mvn.pr_rl.pr_rl,x5		" move and round mantissa
	desc9fl	work|flt_dec_generic,x3
	desc9fl	target|0,x2
	teo	decimal_overflow		" blew up
	teu	decimal_underflow		" blew up
	a9bd	target|0,x2		" update target pointer
	tra	pr7|0

put_flt_dec_ext:				" Float Decimal Extended Case
put_flt_dec_ext_packed:
	lxl2	work|target_precision
	eax2	2,x2			" form true target length
	sbx3	1,du			" form lead sign source len
	xec	mvn.pr_rl.pr_rl,x5		" move and round mantissa
	desc9ls	work|flt_dec_generic,x3
	desc9fl	target|0,x2
	tze	put_flt_dec_ext.zero_exp

"     Update the true exponent, account for target exponent changes due to
"     rounding and truncation/expansion of the mantissa.

	mlr	(pr,x2),(pr)
	desc9a	target|-1(3),1
	desc9a	work|flt_dec_generic,1	" RE-USE mantissa
	lda	work|flt_dec_generic	" sign extend exp
	als	1
	ars	36-8
	ada	work|flt_dec_generic_exp	" integrate with big exp
	als	36-9			" use 9-bit exponent
	trc	decimal_range_error		" test after exp is valid
	sta	work|flt_dec_generic_exp
	mlr	(pr),(pr,x2)		" implant exponent
	desc9a	work|flt_dec_generic_exp,1
	desc9a	target|-1(3),1
put_flt_dec_ext.zero_exp:			" take exponent planted
	a9bd	target|0,x2		" update target pointer
	tra	pr7|0

"     Float Decimal 9-bit generic Case.  Has leading 36-bit exponent.

put_flt_dec_gen:
	lxl2	work|target_precision
	adx2	2,du			" account for sign and exp
	sbx3	1,du			" form lead sign source len
	xec	mvn.pr_rl.pr_rl,x5		" move and round
	desc9ls	work|flt_dec_generic,x3	" collapse/expand to target
	desc9fl	work|flt_dec_generic,x2
	tnz	put_flt_dec_gen.non_zero
	stz	work|flt_dec_generic_exp	" zero exponent
put_flt_dec_gen.non_zero:
	mlr	(pr,x2),(pr)		" update exponent for length
	desc9a	work|flt_dec_generic-1(3),1
	desc9a	work|fix_bin_generic,1
	sbx2	1,du			" correct for no exponent
	mlr	(pr,rl),(pr,rl)		" move mantissa to target
	desc9a	work|flt_dec_generic,x2
	desc9a	target|1,x2
	lda	work|fix_bin_generic	" sign extend corrector
	als	1
	ars	36-8
	ada	work|flt_dec_generic_exp	" get exponent
	sta	target|0
	eax2	3,x2			" set round of mantissa
	a9bd	target|0,x2		" increment and round
	adwp	target,1,du
	tra	pr7|0			" return to callGENERIC to Float Decimal 4 Target Conversion

"     On entry X3 holds the length of the floating decimal number, including
"     sign and exponent byte.  The hardware exponent byte (8-bit) is 0.

put_flt_dec_4:
put_flt_dec_4_packed:
	lxl2	work|target_precision
	eax2	3,x2			" form true target length
	lda	work|flt_dec_generic_exp	" range the exponent
	als	36-8
	trc	decimal_range_error
	mlr	(pr),(pr,x3)		" move to generic
	desc9a	work|flt_dec_generic_exp(3),1
	desc9a	work|flt_dec_generic-1(3),1
	xec	mvn.pr_rl.pr_rl,x5		" move and round mantissa
	desc9fl	work|flt_dec_generic,x3
	desc4fl	target|0,x2
	teo	decimal_overflow		" blew up
	teu	decimal_overflow		" blew up
	eax2	1,x2			" byte align target
	anx2	=o777776,du
	a4bd	target|0,x2		" update target pointer
	tra	pr7|0
"GENERIC to Fixed Decimal (9-bit) Target Conversion

"     For these conversions X3 holds the length of the float decimal number,
"     including the exponent and sign.
"
"     Fixed decimal target capacity depends upon scale and precision.  
"     We preset the floating decimal exponent to account for the fixed decimal
"     scale factor then do the move.  If we overflow the move, then a
"     size is generated.

"     9-bit Leading Sign Case

put_fix_dec_9ls:
put_fix_dec_9ls_packed:
	tsx2	load_flt_dec.target		" load for conversion
	eax1	1,x1			" count in sign
	xec	mvn.pr_rl.pr_rl,x5
	desc9fl	work|flt_dec_generic,x3
	desc9ls	target|0,x1
	tov	size_error		" did not fit
	a9bd	target|0,x1		" update target pointer
	tra	pr7|0


"     9-bit Un-signed Case

put_fix_dec_9uns:
put_fix_dec_9uns_packed:
	tsx2	load_flt_dec.target		" load for conversion
	cmpc	(pr),(),fill(minus_sign)	" see if negative
	desc9a	work|flt_dec_generic,1
	zero
	tze	size_error		" cannot put -ve in uns
	xec	mvn.pr_rl.pr_rl,x5
	desc9fl	work|flt_dec_generic,x3
	desc9ns	target|0,x1
	tov	size_error		" did not fit
	a9bd	target|0,x1		" update target pointer
	tra	pr7|0



"     9-bit Trailing Sign Case

put_fix_dec_9ts:
put_fix_dec_9ts_packed:
	tsx2	load_flt_dec.target		" load for conversion

	eax1	1,x1			" length of signed result
	xec	mvn.pr_rl.pr_rl,x5
	desc9fl	work|flt_dec_generic,x3
	desc9ts	target|0,x1
	tov	size_error		" did not fit
	a9bd	target|0,x1		" update target pointer
	tra	pr7|0
"GENERIC to Fixed Decimal Target Conversion (overpunched sign 9-bit)


"     Conversion of leading sign overpunched value is done by making the float
"     decimal generic a positive, and then moving unsigned to the high part of
"     the fixed_decimal value, then moving the overpunched sign to the leading
"     character position.
"
"	NOTE.  This uses flt_dec_generic_exp to store the original sign.
"	       This uses fix_bin_generic to store the digit/sign index.

put_fix_dec_9ls_ovrp:
put_fix_dec_9ls_ovrp_packed:
	tsx2	load_flt_dec.target		" load for conversion
	mlr	(pr),(pr)			" save true sign
	desc9a	work|flt_dec_generic,1
	desc9a	work|flt_dec_generic_exp,1
	mlr	(),(pr),fill(plus_sign)	" make flt_dec positive
	zero
	desc9a	work|flt_dec_generic,1

	xec	mvn.pr_rl.pr_rl,x5
	desc9fl	work|flt_dec_generic,x3
	desc9ns	target|0,x1
	tov	size_error		" did not fit

"     Determine the leading digit and the sign.

	scm	(),(pr),mask(000)
	desc9a	overpunch_9_digits,10
	desc9a	target|0,1
	arg	work|fix_bin_generic	" holds value
	lda	work|fix_bin_generic
	cmpc	(pr),(),fill(minus_sign)	" determine sign
	desc9a	work|flt_dec_generic_exp,1
	zero
	tnz	put_fix_dec_9ls_ovrp.pos	" positive, digit as index
	ada	=10,dl			" increment index to negative
put_fix_dec_9ls_ovrp.pos:
	mlr	(al),(pr)			" move in overpunch sign
	desc9a	overpunch_9_source,1
	desc9a	target|0,1
	a9bd	target|0,x1		" update target pointer
	tra	pr7|0
"     Conversion of trailing sign overpunched value is done by making the float
"     decimal generic a positive, and then moving unsigned to the high part of
"     the fixed_decimal value, then moving the overpunched sign to the trailing
"     character position.
"
"	NOTE.  This uses flt_dec_generic_exp to store the original sign.
"	       This uses fix_bin_generic to store the digit/sign index.

put_fix_dec_9ts_ovrp:
put_fix_dec_9ts_ovrp_packed:
	tsx2	load_flt_dec.target		" load for conversion
	mlr	(pr),(pr)			" save true sign
	desc9a	work|flt_dec_generic,1
	desc9a	work|flt_dec_generic_exp,1
	mlr	(),(pr),fill(plus_sign)	" make flt_dec positive
	zero
	desc9a	work|flt_dec_generic,1

	xec	mvn.pr_rl.pr_rl,x5
	desc9fl	work|flt_dec_generic,x3
	desc9ns	target|0,x1
	tov	size_error		" did not fit

"     Determine the trailing digit and the sign.

	scm	(),(pr,x1),mask(000)
	desc9a	overpunch_9_digits,10
	desc9a	target|-1(3),1
	arg	work|fix_bin_generic	" holds value
	lda	work|fix_bin_generic
	cmpc	(pr),(),fill(minus_sign)	" determine sign
	desc9a	work|flt_dec_generic_exp,1
	zero
	tnz	put_fix_dec_9ts_ovrp.pos	" positive, digit as index
	ada	=10,dl			" increment index to negative
put_fix_dec_9ts_ovrp.pos:
	mlr	(al),(pr,x1)		" move in overpunch sign
	desc9a	overpunch_9_source,1
	desc9a	target|-1(3),1
	a9bd	target|0,x1		" update target pointer
	tra	pr7|0
"GENERIC to Fixed Decimal (4-bit) Target Conversion

"     For these conversions X3 holds the length of the float decimal number,
"     including the exponent and sign.
"
"     Fixed decimal target capacity depends upon scale and precision.  
"     We preset the floating decimal exponent to account for the fixed decimal
"     scale factor then do the move.  If we overflow the move, then a
"     size is generated.

"     4-bit Leading Sign Case

put_fix_dec_4ls:
put_fix_dec_4ls_packed:
	tsx2	load_flt_dec.target		" load for conversion
	eax1	1,x1			" count in sign
	xec	mvn.pr_rl.pr_rl,x5
	desc9fl	work|flt_dec_generic,x3
	desc4ls	target|0,x1
	tov	size_error		" did not fit
	eax1	1,x1			" byte align target
	anx1	=o777776,du
	a4bd	target|0,x1		" update target pointer
	tra	pr7|0

"     4-bit Un-signed Case

put_fix_dec_4uns:
put_fix_dec_4uns_packed:
	tsx2	load_flt_dec.target		" load for conversion
	cmpc	(pr),(),fill(minus_sign)	" see if negative
	desc9a	work|flt_dec_generic,1
	zero
	tze	size_error		" cannot put -ve in uns
	xec	mvn.pr_rl.pr_rl,x5
	desc9fl	work|flt_dec_generic,x3
	desc4ns	target|0,x1
	tov	size_error		" did not fit
	eax1	1,x1			" byte align target
	anx1	=o777776,du
	a4bd	target|0,x1		" update target pointer
	tra	pr7|0

"     4-bit Trailing Sign Case


put_fix_dec_4ts:
put_fix_dec_4ts_packed:
	tsx2	load_flt_dec.target		" load for conversion
	eax1	1,x1			" account for sign
	xec	mvn.pr_rl.pr_rl,x5
	desc9fl	work|flt_dec_generic,x3
	desc4ts	target|0,x1
	tov	size_error		" did not fit
	eax1	1,x1			" byte align target
	anx1	=o777776,du
	a4bd	target|0,x1		" update target pointer
	tra	pr7|0
"Load and start conversion of flt_dec_generic to fixed decimal target


"     Load float decimal information and setup precision of target.
"     Precurser of most float to fixed target routines.
"
"     Calling sequence:
"	tsx2	load_flt_dec.target
"
"     Returns:
"	1. True scaled exponent for floating decimal number in the hardware
"	   exponent field of the flt_dec_generic variable.  This has the
"	   exponent adjusted for the scale of the target fixed decimal.
"	2. X1 holds to target precision (does not include sign).
"	3. X3 holds length of flt_dec_generic, including sign and exponent.

load_flt_dec.target:
	lda	work|target_scale		" setup scale offset
	ars	18
	ada	work|flt_dec_generic_exp	" get exponent range
	sta	work|flt_dec_generic_exp	" save for testing
	als	36-8			" fit to normal 8-bit
	trc	load_flt_dec.range		" exponent won't fit
	arl	1
load_flt_dec.range_continue:			" re-enter with max neg exp
	sta	work|flt_dec_generic_exp
	mlr	(pr),(pr,x3)		" plant true scaled exp
	desc9a	work|flt_dec_generic_exp,1
	desc9a	work|flt_dec_generic-1(3),1	" as hardware exponent
	lxl1	work|target_precision
	tra	0,x2

"     Exponent won't fit in 7-bits, see if too big or too small.

load_flt_dec.range:
	eax1	-1,x3			" size less exponent
	cmpn	(pr,rl),()		" Is number zero?
	desc9ls	work|flt_dec_generic,x1	" If so good by definition
	desc9ls	char_zero,2
	tze	load_flt_dec.range.fix	" No:  edit number with mvne
	lda	work|flt_dec_generic_exp	" get exponent
	tpl	size_error		" it was too big
load_flt_dec.range.fix:
	lda	=o400000,du		" force max neg exponent
	tra	load_flt_dec.range_continue	
"GENERIC to Bit Target Conversion

"     Bit to target conversion.  Expects pointer to bit string in generic and
"     length in X3.
"
"     For varying bit, the target pointer is one beyond the length word,
"     so we negative index to the length word.
"

"     NOTE.  In all cases we return immediately to the user after unmasking.

put_varying_bit:
	eaa	0,x3			" get length of bits
	ars	18			" position to DL
	sta	target|-1			" save varying length
	lxl2	work|target_precision
	stx2	work|target_precision
	cmpx3	work|target_precision	" take min (length, prec)
	tmoz	put_bit			" have min
	lxl2	work|target_precision	" get min
	sxl2	target|-1			" save target length
	tra	put_bit.common.aligned	" copy all

put_bit:					" determine max copy length
	lxl2	work|target_precision

put_bit.common.aligned:			" Remove padded reference
	stz	target|0			" pre-clear 1st word
	cmpx2	36,du
	tmoz	put_bit.common		" if one word or less
	stz	target|1			" pre_clear 2nd word
	tra	put_bit.common

put_bit_packed:
	lxl2	work|target_precision
put_bit.common:
	csl	(pr,rl),(pr,rl),bool(move),fill(0)
	descb	generic|0,x3
	descb	target|0,x2
	tra	unmask_exit		" return to user
"GENERIC to Character Target Conversion

"     Character target routine.  Expects pointer to source in generic and
"     length in X3.  These routines return directly to the user.

put_varying_char:
	lda	=o777777,dl		" mask for string length
	ansa	work|target_precision
	eaa	0,x3
	ars	18
	cmpa	work|target_precision	" limit to length of target
	tmoz	put_varying_char.in_range
	lda	work|target_precision
put_varying_char.in_range:
	sta	target|-1			" save string length
	tra	put_char.common		" move and fill all

"     Put simple fixed length character string.

put_char:
put_char_packed:
	lda	work|target_precision
	ana	=o777777,dl		" mask for just length

"     Copy string to target, filling with spaces.

put_char.common:
	mlr	(pr,rl),(pr,rl),fill(blank)	" move to target
	desc9a	generic|0,x3
	desc9a	target|0,al
	tra	unmask_exit		" return direct to user
"ERROR BRANCHES

"     The following branches all signal the conversion
"     condition. On entry, the Q contains the current
"     index into the string being converted.

"     oncodes are documented and determined according to the ASCII segment
"     >sss>oncode_messages_

error_191:
	lda	191,dl		" Bin digit not 0 or 1
	tra	error_xxx

error_201:
	lda	201,dl		" no digit after d/e/f

error_xxx:
	adq	1,dl			" get pl1 index
	stz	work|source_string_length	" restore string length
	lxl2	work|original_source_length
	sxl2	work|source_string_length
	tsx1	conversion_error
	tra	char_to_arithmetic_restart

error_202:
	lda	202,dl		" no digit in a numeric field
	tra	error_xxx

error_203:
	lda	203,dl		" illegal char after numeric field
	tra	error_xxx

error_204:
	lda	204,dl		" too many decimal points
	tra	error_xxx

error_205:
	lda	256,dl		" force to 256 character limit
	sta	work|original_source_length 	" save for conversion error
	lda	205,dl		" >256 chars to convert
	tra	error_xxx

error_207:
	lda	207,dl		" too many exponents
	tra	error_xxx

error_208:
	lda	208,dl		" scale factor too big
	tra	error_xxx

error_209:
	lda	209,dl		" scale factor too small
	tra	error_xxx

error_211:
	lda	211,dl		" wrong character after "i"
	tra	error_xxx

error_213:
	lda	213,dl		" too many digits in exponent
	tra	error_xxx

error_214:
	lda	214,dl		" no digits in mantissa
	tra	error_xxx

error_218:
	lda	218,dl		" prec > dec(59) or bin(71)
	tra	error_xxx

error_219:
	lda	219,dl		" 2nd half of complex number must be imaginary
	tra	error_xxx
"SIGNALLING SUBROUTINES
"
"	subroutine to signal conversion conditions
"	calling sequence is
"		epp	generic,character_string
"		lda	oncode
"		ldq	onchar_index
"		tsx1	conversion_error
"
"     Presumes work|source_string_length is length of string of error
"     Presumes availability of work|original_source pointer area.
"     work|source_string_length is fixed bin (35) length.
"
"     When returns, source pointer is changed to point to onsource area
"     of stack extension, to permit user to change it.
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "

conversion_error:
	spri7	work|error_return		" save return ptr
	epbp7	sp|0			" so we can get ptr to stack base again
	sxl0	sp|stack_frame.operator_ret_ptr  " save x0 for default_error_handler_
	szn	work|original_source	" already extended?
	tnz	have_extension		" yes - use it
	epp4	sb|stack_header.stack_end_ptr,*
	epp4	pr4|error_extension		" extend stack
	spri4	sb|stack_header.stack_end_ptr
	spri4	sp|stack_frame.next_sp
	epp4	pr4|-error_extension
	lxl0	work|source_string_length	" make copy of source for signalling
	mlr	(pr,rl),(pr,rl)
	desc9a	generic|0,x0
	desc9a	pr4|onsource,x0
	sprp4	work|original_source	" remember ptr to extension
	epp	generic,pr4|onsource	" change onsource ptr
have_extension:
	cmpq	work|source_string_length	" make sure onindex is in range
	tmoz	conversion_error.in_range
	ldq	work|source_string_length

conversion_error.in_range:
	lprp4	work|original_source	" get ptr to old extension
	spri	pr4|save_ptrs		" now save ptrs
	sreg	pr4|save_regs		" and registers

	epp0	null			" build arg list
	spri0	pr4|arglist+2		" ARG 1 - null
	epp0	my_name
	spri0	pr4|arglist+4		" ARG 2 - ptr to "any_to_any_"
	epp0	pr4|oncode
	spri0	pr4|arglist+6		" ARG 3 - oncode
	epp0	pr4|onsource_ptr
	spri0	pr4|arglist+8		" ARG 4 - ptr to source string
	epp0	=1
	spri0	pr4|arglist+10		" ARG 5 - start character (1)
	epp0	work|source_string_length
	spri0	pr4|arglist+12		" ARG 6 - len of source string
	epp0	pr4|onchar_index
	spri0	pr4|arglist+14		" ARG 7 - index of char error

	epp0	pointer_desc		" fill in descriptors
	spri0	pr4|arglist+16		" ARG 1 - pointer
	spri0	pr4|arglist+22		" ARG 4 - pointer
	epp0	my_name_desc
	spri0	pr4|arglist+18		" ARG 2 - character (11) packed
	epp0	fixbin_15_desc
	spri0	pr4|arglist+20		" ARG 3 - fixed bin (15)
	spri0	pr4|arglist+24		" ARG 5 - fixed bin (15)
	spri0	pr4|arglist+26		" ARG 6 - fixed bin (15)
	spri0	pr4|arglist+28		" ARG 7 - fixed bin (15)
	ldaq	conversion_arg_header	" 7 arguments, 7 descriptors
	eax0	ce_link			" get routine to call
	epp2	pr4|0			" use PR2 for rest

call_it:
	ora	=4,dl
	staq	pr2|arglist		" comple arglist
	epaq	*			" get our linkage ptr
	lprplp	sb|stack_header.lot_ptr,*au
	epp0	pr2|arglist
	stcd	sp|stack_frame.return_ptr
	callsp	lp|0,0*			" call error routine
"
	epbp2	sp|tbp,*			" restore original value
	spri2	sp|stack_frame.return_ptr	" of return pointer
	epp2	sb|stack_header.stack_end_ptr,* " get ptr to extension
	epp2	pr2|-error_extension
	lreg	pr2|save_regs
	lpri	pr2|save_ptrs		" restores generic ptr
	epp7	work|error_return,*
	lxl0	sp|stack_frame.operator_ret_ptr " restore x0
	stz	sp|stack_frame.operator_ret_ptr " and clear switch
	tra	0,1
"
"	signal size error
"
size_error:
	lda	=703,dl			" size condition raised
	ldq	=4,dl
	epp4	size_name
	tsx1	signal_from_ops
	tra	7|0


"     Floating point range errors.

flt_range_error:
	lda	work|flt_bin_generic_exp	" see if positive or negative
	tmi	underflow_error		" underflow
"	tra	overflow_error		" overflow

"	signal overflow error
"
overflow_error:
	lda	=705,dl			" overflow condition raised
	ldq	=8,dl
	epp4	overflow_name
	tsx1	signal_from_ops
	tra	store_float_bin_zero
"
"	signal underflow condition
"
underflow_error:
	lda	=706,dl			" underflow condition raised
	ldq	=9,dl
	epp4	underflow_name
	tsx1	signal_from_ops
store_float_bin_zero:			" zero float bin and finish
	stz	work|flt_bin_generic_exp
	stz	work|flt_bin_generic
	stz	work|flt_bin_generic+1
	tra	flt_bin_generic_conversion



"     Decimal fixed/float range errors.

decimal_range_error:
	lda	work|flt_dec_generic_exp	" see if positive or negative
	tmi	decimal_underflow		" underflow
"	tra	decimal_overflow		" overflow

"
"	signal overflow for conversion to decimal
"
decimal_overflow:
	lda	=705,dl			" overflow condition raised
	ldq	=8,dl
	epp4	overflow_name
	tsx1	signal_from_ops
	tra	force_zero
"
"	signal underflow for conversion to decimal
"
decimal_underflow:
	lda	=706,dl		underflow condition raised
	ldq	=9,dl
	epp4	underflow_name
	tsx1	signal_from_ops
force_zero:				" Zero GENERIC float decimal
	ldx3	default_flt_dec_p,du	" length of decimal
	mvn	(),(pr,rl)
	desc9ls	dec_zero,2
	desc9fl	work|flt_dec_generic,x3
	stz	work|flt_dec_generic_exp
	tra	flt_dec_generic_conversion

"
"	signal error condition for unimplemented conversion
"
get_ERROR:
get_ERROR_packed:
put_ERROR:
put_ERROR_packed:

"     Bad data types.

get_varying_char_packed:
get_varying_bit_packed:
put_varying_char_packed:
put_varying_bit_packed:
get_flt_dec_gen_packed:
put_flt_dec_gen_packed:
get_flt_bin_gen_packed:
put_flt_bin_gen_packed:

error_bad_type:
	lda	=415,dl		attempted invalid or unimp conversion
	ldq	=5,dl		= length ("error")
	epp4	error_name
	tsx1	signal_from_ops	do it
	tra	pr7|0		standard action is to ignore conversionSignal an error condition from the operators.

"     All conditions other than conversion error come through here.
"     We do an error extension of the stack to create an argument/descriptor
"     area for the call.  Descriptors are filled in to make trace-stack
"     cleaner.

signal_from_ops:
	sxl0	sp|stack_frame.operator_ret_ptr  " x0 for default_error_handler
	spri7	work|error_return

"     Error extension of stack for ERROR_EXTENSION words.

	epbp7	sp|0			" get stack header
	epp2	sb|stack_header.stack_end_ptr,*
	epp2	pr2|error_extension
	spri2	sb|stack_header.stack_end_ptr
	spri2	sp|stack_frame.next_sp
	epp2	pr2|-error_extension	" save end of stack ptr

"     Save all registers and pick up arguments from them.

	spri	pr2|save_ptrs
	sreg	pr2|save_regs

"     Create argument list.

	spri4	pr2|arglist+2		" ARG 1 - ptr to condition name
	epp0	pr2|name_length
	spri0	pr2|arglist+4		" ARG 2 - len of condition name
	epp0	sp|tbp,*0
	epp0	0|-1
	spri0	pr2|call_ptr
	epp0	pr2|call_ptr
	spri0	pr2|arglist+6		" ARG 3 - ptr to caller
	epp0	pr2|oncode
	spri0	pr2|arglist+8		" ARG 4 - oncode value
	epp0	null
	spri0	pr2|arglist+10		" ARG 5 - null

"     Build descriptors.

	adq	string_desc		" form character descriptor
	stq	pr2|arglist+24		" store away
	epp0	pr2|arglist+24
	spri0	pr2|arglist+12		" ARG 1 - character (n)
	epp0	fixbin_17_desc
	spri0	pr2|arglist+14		" ARG 2 - condition string len
	epp0	fixbin_35_desc
	spri0	pr2|arglist+18		" ARG 4 - oncode
	epp0	pointer_desc
	spri0	pr2|arglist+16		" ARG 3 - pointer
	spri0	pr2|arglist+20		" ARG 5 - pointer
	ldaq	ops_arg_header		" 5 arguments, 5 descriptors
	eax0	fo_link			" get routine to call
	tra	call_it
"Error call tables and data.

"     Various constants required for setting up pointers, descriptors and
"     character strings for error calls.

	even
null:	its	-1,1,n
ops_arg_header:
	vfd	17/5,1/0,18/0		" 5 args, call type filled later
	vfd	17/5,19/0			" 5 descriptors
conversion_arg_header:
	vfd	17/7,1/0,18/0		" 7 args, call type filled later
	vfd	17/7,19/0			" 7 descriptors
"
my_name:	aci	"any_to_any_"
"
fixbin_15_desc:
	oct	404000000017		" fix bin 15
fixbin_17_desc:
	oct	404000000021		" fix bin 17
fixbin_35_desc:
	oct	404000000043		" fix bin 35
pointer_desc:
	oct	464000000000		" pointer
my_name_desc:
	oct	526000000013		" char 11
string_desc:
	oct	526000000000		" string (*) desc len=0
"
size_name:
	aci	"size"
overflow_name:
	aci	"overflow"
underflow_name:
	aci	"underflow"
error_name:
	aci	"error"
"
	link	ce_link,pl1_signal_conversion_$pl1_signal_conversion_
	link	fo_link,<pl1_signal_from_ops_>|[pl1_signal_from_ops_]
"Two table for fixed binary conversion.


	include	 two_table
"Table of mask constants for precision masking and generation.

	even			" table must be double aligned

mask_table:
	oct	377777777777,777777777777
	oct	177777777777,777777777777
	oct	077777777777,777777777777
	oct	037777777777,777777777777
	oct	017777777777,777777777777
	oct	007777777777,777777777777
	oct	003777777777,777777777777
	oct	001777777777,777777777777
	oct	000777777777,777777777777
	oct	000377777777,777777777777
	oct	000177777777,777777777777
	oct	000077777777,777777777777
	oct	000037777777,777777777777
	oct	000017777777,777777777777
	oct	000007777777,777777777777
	oct	000003777777,777777777777
	oct	000001777777,777777777777
	oct	000000777777,777777777777
	oct	000000377777,777777777777
	oct	000000177777,777777777777
	oct	000000077777,777777777777
	oct	000000037777,777777777777
	oct	000000017777,777777777777
	oct	000000007777,777777777777
	oct	000000003777,777777777777
	oct	000000001777,777777777777
	oct	000000000777,777777777777
	oct	000000000377,777777777777
	oct	000000000177,777777777777
	oct	000000000077,777777777777
	oct	000000000037,777777777777
	oct	000000000017,777777777777
	oct	000000000007,777777777777
	oct	000000000003,777777777777
	oct	000000000001,777777777777
	oct	000000000000,777777777777
	oct	000000000000,377777777777
	oct	000000000000,177777777777
	oct	000000000000,077777777777
	oct	000000000000,037777777777
	oct	000000000000,017777777777
	oct	000000000000,007777777777
	oct	000000000000,003777777777
	oct	000000000000,001777777777
	oct	000000000000,000777777777
	oct	000000000000,000377777777
	oct	000000000000,000177777777
	oct	000000000000,000077777777
	oct	000000000000,000037777777
	oct	000000000000,000017777777
	oct	000000000000,000007777777
	oct	000000000000,000003777777
	oct	000000000000,000001777777
	oct	000000000000,000000777777
	oct	000000000000,000000377777
	oct	000000000000,000000177777
	oct	000000000000,000000077777
	oct	000000000000,000000037777
	oct	000000000000,000000017777
	oct	000000000000,000000007777
	oct	000000000000,000000003777
	oct	000000000000,000000001777
	oct	000000000000,000000000777
	oct	000000000000,000000000377
	oct	000000000000,000000000177
	oct	000000000000,000000000077
	oct	000000000000,000000000037
	oct	000000000000,000000000017
	oct	000000000000,000000000007
	oct	000000000000,000000000003
	oct	000000000000,000000000001
"Precision Conversion Table

"     Convert binary precision to necessary decimal precision, including
"     sign and hardware exponent.  DU has decimal precision for indexed
"     binary precision.  DL has number of bytes of binary source for that
"     binary precision.

bin_prec_to_dec_prec:
	vfd	18/2,18/0		" binary prec  0
	vfd	18/3,18/1		" binary prec  1
	vfd	18/3,18/1		" binary prec  2
	vfd	18/3,18/1		" binary prec  3
	vfd	18/4,18/1		" binary prec  4
	vfd	18/4,18/1		" binary prec  5
	vfd	18/4,18/1		" binary prec  6
	vfd	18/5,18/1		" binary prec  7
	vfd	18/5,18/1		" binary prec  8
	vfd	18/5,18/1		" binary prec  9
	vfd	18/6,18/2		" binary prec 10
	vfd	18/6,18/2		" binary prec 11
	vfd	18/6,18/2		" binary prec 12
	vfd	18/6,18/2		" binary prec 13
	vfd	18/7,18/2		" binary prec 14
	vfd	18/7,18/2		" binary prec 15
	vfd	18/7,18/2		" binary prec 16
	vfd	18/8,18/2		" binary prec 17
	vfd	18/8,18/2		" binary prec 18
	vfd	18/8,18/3		" binary prec 19
	vfd	18/9,18/3		" binary prec 20
	vfd	18/9,18/3		" binary prec 21
	vfd	18/9,18/3		" binary prec 22
	vfd	18/9,18/3		" binary prec 23
	vfd	18/10,18/3	" binary prec 24
	vfd	18/10,18/3	" binary prec 25
	vfd	18/10,18/3	" binary prec 26
	vfd	18/11,18/3	" binary prec 27
	vfd	18/11,18/4	" binary prec 28
	vfd	18/11,18/4	" binary prec 29
	vfd	18/12,18/4	" binary prec 30
	vfd	18/12,18/4	" binary prec 31
	vfd	18/12,18/4	" binary prec 32
	vfd	18/12,18/4	" binary prec 33
	vfd	18/13,18/4	" binary prec 34
	vfd	18/13,18/4	" binary prec 35
	vfd	18/13,18/4	" binary prec 36
	vfd	18/14,18/5	" binary prec 37
	vfd	18/14,18/5	" binary prec 38
	vfd	18/14,18/5	" binary prec 39
	vfd	18/15,18/5	" binary prec 40
	vfd	18/15,18/5	" binary prec 41
	vfd	18/15,18/5	" binary prec 42
	vfd	18/15,18/5	" binary prec 43
	vfd	18/16,18/5	" binary prec 44
	vfd	18/16,18/5	" binary prec 45
	vfd	18/16,18/6	" binary prec 46
	vfd	18/17,18/6	" binary prec 47
	vfd	18/17,18/6	" binary prec 48
	vfd	18/17,18/6	" binary prec 49
	vfd	18/18,18/6	" binary prec 50
	vfd	18/18,18/6	" binary prec 51
	vfd	18/18,18/6	" binary prec 52
	vfd	18/18,18/6	" binary prec 53
	vfd	18/19,18/6	" binary prec 54
	vfd	18/19,18/7	" binary prec 55
	vfd	18/19,18/7	" binary prec 56
	vfd	18/20,18/7	" binary prec 57
	vfd	18/20,18/7	" binary prec 58
	vfd	18/20,18/7	" binary prec 59
	vfd	18/21,18/7	" binary prec 60
	vfd	18/21,18/7	" binary prec 61
	vfd	18/21,18/7	" binary prec 62
	vfd	18/21,18/7	" binary prec 63
	vfd	18/22,18/8	" binary prec 64
	vfd	18/22,18/8	" binary prec 65
	vfd	18/22,18/8	" binary prec 66
	vfd	18/23,18/8	" binary prec 67
	vfd	18/23,18/8	" binary prec 68
	vfd	18/23,18/8	" binary prec 69
	vfd	18/24,18/8	" binary prec 70
	vfd	18/24,18/8	" binary prec 71
	vfd	18/24,18/8	" binary prec 72


"     Convert decimal digit to binary precision needed to hold it.
"     Used by flt_dec_to_flt_bin to maintain maximum converison precision.

digit_to_prec:
	zero	1,0		" digit 0.0-0.99...
	zero	2,0		" digit 1.0-1.99...
	zero	3,0		" digit 2.0-2.99...
	zero	3,0		" digit 3.0-3.99...
	zero	4,0		" digit 4.0-4.99...
	zero	4,0		" digit 5.0-5.99...
	zero	4,0		" digit 6.0-6.99...
	zero	4,0		" digit 7.0-7.99...
	zero	5,0		" digit 8.0-8.99...
	zero	5,0		" digit 9.0-9.99...
	end
