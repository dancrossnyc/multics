" ***********************************************************
" *                                                         *
" * Copyright, (C) Honeywell Bull Inc., 1987                *
" *                                                         *
" * Copyright, (C) Honeywell Information Systems Inc., 1982 *
" *                                                         *
" * Copyright (c) 1972 by Massachusetts Institute of        *
" * Technology and Honeywell Information Systems, Inc.      *
" *                                                         *
" ***********************************************************

"	Operator  for doing format-driven conversions
"
"	Written by R.Schoeman 1975-6 to implement operators to do put-edit
"	requests in the operators, for improved performance.
"
"	Modified Oct 1976 by R.H.Schoeman to put in radix factor constants
"	Modified Mar 29, 1978 by R.A.Barnes to fix bug 1719
"	Modified August 14, 1978 by PCK to fix bug 1745
"	Modified September 1, 1978 by RAB to fix bug 1781
"
	include stack_frame
	include stack_header
	include eis_bits
"
"	The following include file describes a region of storage which is used
"	exclusively by put_format_, for internal manipulation.  It's primary
"	purpose is to hold the evaluated fields of the format constants
"	produced by the compiler(evaluated by stu_), but is also used
"	for most other storage needed by the format list processing
"	and format conversions. The program plio2_fl_ uses the same storage region,
"	there called sb, similiarly but not identically. plio_sb is 136 words long,
"	and was provided by the compiled code, and the ptr to it was placed in the ps, at
"	ps.format_area_p.
"
	include plio_sb
"
"	The following include file describes the format constants produced
"	by the compiler. A format con contain from zero (as in a put edit(foo)(a) statement)
"	to three values (as in put edit(foo)(e(11,5,2))), hence 3 value fields
"	are provided along with nval, to show how many are used. offset is the
"	relative offset to the next format constant.
"
	include plio_fb
	include pic_image
	include plio2_ps
	include plio_format_codes
	include desc_types
	equ	new_stack_size,48
	equ	max_dec_precision,59	this is system defined constant
	equ	w_temp,47		this temp is field width for e_format maniputlation
	equ	radix_fac_bits,47	this temp used in bn_format to hold bits to be index in hex_table
	equ	nval_temp,44
	equ	radix_factor,44
	equ	d_temp,54		num of decimal places for e_formats
	equ	k_temp,48
	equ	extra_bits,48
	equ	sd_temp,48
	equ	storage_taken,49
	equ	double_temp,52
	equ	temp,62
	equ	ps_ptr,42
	equ	source_val_type,44
	equ	source_val_scaleprec,45
	equ	b_temp,45
	equ	x7_stored,46	upper half of word only
	equ	int_val_type,54
	equ	int_val_scaleprec,47
"				qs_arg_list will clobber many variables if ever used from
"				pr6|, and it NEVER should be. It is to be used within the
"				region allocated as temporary workspace.
	equ	qs_arg_list,48
	equ	tbp,38
	segdef	put_edit_eis
	segdef	get_edit_eis
	segdef	put_terminate
	segdef	stream_prep
formats_mask:
	oct	000000000017
"
"	operator to prepare for an I/O operator (stream)
"
" stream_prep is executed once per put request, and as such should not
" be confused with "get_prep"
"  stream_prep sets several fields in the ps, which
" is the storage block associated with an io request, including "ps.prep",
" which when non-zero tells get_or put_ prep to do other preparatory  functions.
"
stream_prep:
	eppap	sp|ps_ptr,*	get ptr to ps
	spribp	ap|ps.abret	save label
	sprisp	ap|ps.abret+2
	sta	ap|ps.job		set job to do
	stc1	ap|ps.prep	set prep switch non-zero
	eax6	10		assume this is get prep
	cana	=o002000,du	check for put bit
	tze	<pl1_operators_>|[plio4]	go make call to get_prep_ if bit off
	eax6	11		this means its a put_prep call
	tra	<pl1_operators_>|[plio4]	and away we go
"
"	operator for get edit entered with ptr to datum in bp,
"	offset in x7, descriptor in q
"
get_edit_eis:
"	epp4	sp|ps_ptr,*	pr4 will point to ps throughout
"	sxl7	sp|ps.offset
"	tra	put_and_get_merge
"
" 	Operator to do put edits, entered with descriptor in q and pointer to value
"	in the bp, and the offset, for pictures, in the a.
"
"	The first  section of code, up to the transfer vector called
"	"action", walks the format list, evaluates any variables
"	found, and creates a secondary, pre-processed format list,
"	which is then used by the code which does the
"	format-driven conversions. The original format list is
"	pointed to by ps.special_list_p, and the structure of
"	the format items on it is described by plio_fb. The fully
"	processed format list is pointed to by pr5, and its structure
"	is plio_sb. fb is mnemonic for format block, and sb is for
"	storage block. This format list processing is used by both
"	output, in which case the format conversions are done by the
"	latter part of put_format_, and by input, in which case the
"	conversion part is done by plio2_qge_ (which stands for
"	quick_get_edit_).
put_edit_eis:
	epp4	sp|ps_ptr,*	pr4 will point to the ps throughout this code
	sta	pr4|ps.offset	since the a has the offset for the picture
put_and_get_merge:
	stq	pr4|ps.descr	since the q has the descriptor
	stq	pr4|ps.q_stored	we also must save it here, for final restoration after put_field_
	sta	pr4|ps.a_stored	same here.
	stx7	sp|x7_stored	we cannot clobber any regs but a,q,bases,x0, and x1
	spri2	pr4|ps.value_p	we were entered with ptr->value in bp
	epp5	pr4|ps.format_area_p,*	pr5 points to the original format thruout
	sxl0	sp|stack_frame.operator_ret_ptr	this needed to return from any_to_any
	ldq	240,dl
	tsx1	<pl1_operators_>|[alloc]
	spribp	pr5|plio_sb.space_ptr		this is temporary work space
	lda	pr4|ps.new_format	this flag,if not 0,means we are handling a new format list 
	tze	test_currep	not the first so  dont initialize,else
"				set up the sb format "model" from scratch, and initialize some stuff
init_format:
	stz	pr5|plio_sb.stk_index	init to zero,though plio2_fl_.pl1 inits to 1
	stz	pr5|plio_sb.cur_rep	init to zero
	stz	pr4|ps.new_format	no longer a new format since were initializing it
	epp3	null_loc,*
	spri3	pr5|plio_sb.sf1p
	spri3	pr5|plio_sb.fe1p
	spri6	pr5|plio_sb.sf2p
	epp3	pr4|ps.special_list_p,*	this is set to the beginning of the formats
	spri3	pr5|plio_sb.cur_fep	so it is the first format_ptr
	epp3	pr3|1		the 1st word is zeros to identify this as the start of a format list
	spri3	pr5|plio_sb.fe2p	so for real use set the ptr one ahead
"			if the current rep factor>0,use the current format in the sb
test_currep:
	epp7	pr5|plio_sb.cur_fep,*	else follow the ptr in the last format to the next one & load the sb
	lda	pr5|plio_sb.cur_rep	However,if this is the 1st,we get the initial values from xx2p's, set
	tze	test_offset	in init_format.
"
"	this is the format to do since the currep is > 0
"
	sba	1,dl		1st decrement currep, since we're finally using fep's fields
	sta	pr5|plio_sb.cur_rep
	lda	pr5|plio_sb.type
	cmpa	c_format,dl	if c_format we must set the real & imag formats in plio_sb.val(2) and plio_sb.val(3),
	tze	exec_c_format	else we only eval current fep's arguments and set plio_sb.val(1)'s values to them
	cmpa	picture_format,dl	and we're done. p_format's, however,get evaluated differently.
	tnz	format_decoded
	ldq	0,dl
	eax0	got_format	after decode_format,we want to go staight to got_format
"
decode_pic_format:
	lda	pr7|plio_fb.val	the picture image is at format's addr up the 1st value
	epp3	pr7|0,al		so now pr3 points to it
	mpy	5,dl		each set-of-values frame in the plio_fb structure is 5 wds long
	lda	2,dl		so skip to the frame index which was in q on entry
	sta	pr5|plio_sb.nval,ql	set fframe's nval to 3
	lda	pr3|1		pic_image.varlength is up one,leftmost f.bin.(8)
	arl	27		get pure pic_image.varlength
	sta	pr5|plio_sb.val_1,ql	which is to be the 1st  value
	sprp3	pr5|plio_sb.val_2,ql	store as val_2 a ptr to the picture_image
	tra	0,0		and return through x0, since we were tsx0'd here
"
"			Try to get the next format from the ptr in the last one. If its 0,we are
test_offset:
	lxl1	pr7|plio_fb.offset	at the end of a format list and must be in 1 of 3 cases--a)About to do
	tze	test_stk_index	the 1st format,initialized in init_format b)in a non-mainstream format list
	epp7	pr7|0,1		reached thru a r_format c)at the end of the list & should start over from top.
	spri7	pr5|plio_sb.cur_fep	we just set the format-ptr to plio_fb.offset
"				since we have a new format,eval rep factor & set currep to it
eval_rep:
	ldq	pr7|plio_fb.rep
	tpl	2,ic		if it is >0, it is a constant and needn't be evaluated
	tsx6	decode_q		else we must call stu_
	stq	pr5|plio_sb.cur_rep
	lda	pr7|0		get the num of values in the format
	arl	plio_fb.nval_shift
	ana	plio_fb.nval_mask,dl
	sta	pr5|plio_sb.nval	sb hold our present values. It stands for storage_block.
	lda	pr7|0		now get the type code of the format
	arl	plio_fb.code_shift	since we're shifting 27 we needn't mask the remaining 9 bits
	sta	pr5|plio_sb.type
	cmpa	c_format,dl	if >c_format, is a simple type.. if <, us r_format or l_paren,etc.
	tpnz	test_currep	if a_,b_,e_,f_,p_format, off we go
	cmpq	1,dl		q still has currep, if 0 we want next format
	tmi	test_offset
	cmpa	c_format,dl	if c_format there two sets of values to fill
	tze	c_format_to_sb
	aos	pr5|plio_sb.stk_index	must be a case which requires another stack frame in the sb
	ldq	pr5|plio_sb.stk_index	i.e. either r_format or l_paren
	cmpq	9,dl		check that max nesting depth is not exceeded
	tmoz	3,ic
	lda	12,dl
	tra	<put_field_>|[any_qs_error_no_ret]
	mpy	10,dl		each stack frame takes up 9 words, so this gets the offset
	epp1	pr5|plio_sb.cur_sfp,*	now set the new frame's values to the current format
	spri1	pr5|plio_sb.sf1p,ql
	spri7	pr5|plio_sb.fe1p,ql	pr7,now as always,points to the format item
	lda	pr5|plio_sb.cur_rep	we clobbered the q during multiplication,so it isn't currep like usual
	sta	pr5|plio_sb.rep,ql	set the frame's rep factor
	lda	pr5|plio_sb.type	and it's type
	cmpa	r_format,dl	r_format's values need stu_ to get them, while l_paren's are easier
	tze	r_format_to_sb
	spri1	pr5|plio_sb.sf2p,ql	this is l_paren,set sf2p to the current sfp--stack_frame_ptr
	lda	pr7|plio_fb.val	and set the fe2p to current format_ptr up its own val(1)
	epp3	pr7|0,al
	spri3	pr5|plio_sb.fe2p,ql	we used pr3 cause we didn't want to clobber pr7, which always is the fep
"			test stack index, if=1 we're at the bottom of the stack & should continue
test_stk_index:
	ldq	pr5|plio_sb.stk_index	with the xx2p ptrs, else if the frame's rep factor>0 use it over
	mpy	10,dl
	tze	use_2s		again & decrement the rep factor, else use the xx1p ptrs and decrement
	lda	pr5|plio_sb.rep,ql	the stack index
	tze	use_1s
	sba	1,dl
	sta	pr5|plio_sb.rep,ql
"				this means use the xx2p ptrs and reenter the mainstream
use_2s:
	epp7	pr5|plio_sb.fe2p,ql*	pr7 will be the format ptr, fep
	spri7	pr5|plio_sb.cur_fep	and store it
	epp3	pr5|plio_sb.sf2p,ql*
	spri3	pr5|plio_sb.cur_sfp	cur_sfp will be taken from plio_sb.sf2p
	tra	eval_rep
"
"				set the sfp, fep from the frame's xx1p's and decrement stack frame index
use_1s:
	epp3	pr5|plio_sb.sf1p,ql*
	spri3	pr5|plio_sb.cur_sfp
	epp7	pr5|plio_sb.fe1p,ql*
	spri7	pr5|plio_sb.cur_fep	q had the stck index times 10 to yield the offset, remember
	lcq	1,dl
	asq	pr5|plio_sb.stk_index
	tra	test_offset	and rejoin the mainstream
"
"
"			this is the only way to get out of this routine
"
format_decoded:
	lda	0,du		this means the format has been decoded,so start the evaluation loop
eval_loop:
	cmpa	pr5|plio_sb.nval	have we eval'd as many args as there are?
	tze	got_format	if so, the format list walk is over
	ldq	pr7|plio_fb.val,al	otherwise, load the format's value
	tpl	2,ic		if non-negative, its a constant so no stu_ call
	tsx6	decode_q		if negative, call stu_ to decode it
	stq	pr5|plio_sb.val,al	store it in the sb storage block
	ada	1,dl		add one to the value count
	tra	eval_loop		and loop over again
"
exec_c_format:
	stz	pr5|7		zero out the real, imag value fields
	stz	pr5|8
	stz	pr5|9
	stz	pr5|12
	stz	pr5|13
	stz	pr5|14
	tsx6	check_for_param	if there are no parameters it is an error
	stq	sp|nval_temp	check_for_param checks that plio_sb.nval>0 and leaves it in the q
	lda	pr5|plio_sb.val	the ptr to the real format is addrel(cur_fep,val_1)
	epp7	pr5|plio_sb.cur_fep,*al	so figure out ptr to the real format
	ldq	pr5|5		plio_sb.type(2),i.e. real format parts
	cmpq	picture_format,dl	if  its a picture format we must decode
	tnz	4,ic		otherwise we dont have to
"
	eax0	real_part_ok	after decoding the pis format we want to go here
	ldq	1,dl		since it is the second value frame in the sb for the results
	tra	decode_pic_format
"
	lda	0,dl		now eval each of the values in the format block's real part
real_loop:
	cmpa	pr5|6		plio_sb.nval(2), real part
	tpl	real_part_ok	this means they are all eval'd
	ldq	pr7|plio_fb.val,al	else get the next one
	tpl	2,ic		if its negative we must call stu_ to decode it
	tsx6	decode_q
	stq	pr5|7,al		2nd formats values start at 7
	ada	1,dl		and reloop evaluating the next value
	tra	real_loop
real_part_ok:
	ldq	sp|nval_temp
	cmpq	2,dl		if there's only 1 then only one format given for both imag & real
	tmi	imag_like_real
	epp7	pr5|plio_sb.cur_fep,*	else we must figure out imag format
	lda	pr5|plio_sb.val_2	this is offset for imag format's format item
	epp7	pr7|0,al		set up a correct ptr to it in pr7
	ldq	pr5|10		this is the format-type of imag format
	cmpq	picture_format,dl
	tnz	4,ic		if its not picture do not call decode_pic
	ldq	2,dl		this tells decode_pic which format-frame to store results in
	eax0	got_format	this is where to return to after decode_pic is done
	tra	decode_pic_format	and off we go
	lda	0,dl		now evaluate format block's values one by one
imag_loop:
	cmpa	pr5|11		this is imag format's nval,if = we've eval'd them all
	tpl	got_format	if we've eval'd them all we've finished the format-list walk!
	ldq	pr7|plio_fb.val,al	otherwise eval the next  one
	tpl	2,ic
	tsx6	decode_q
	stq	pr5|12,al		and store it into the sb block
	ada	1,dl		add one to our count
	tra	imag_loop		and continue
"
imag_like_real:
	mlr	(pr),(pr)		we're here if only one format given within c_format,so
	desc9a	pr5|7,12		just move all the sb's real values to the sb imag-values
	desc9a	pr5|12,12		section and we're done
	tra	got_format
"
c_format_to_sb:
	mlr	(pr),(pr)		move fields from format block to sb
	desc9a	pr7|plio_fb.val,12
	desc9a	pr5|plio_sb.val,12
	tsx6	check_for_param	if nval<1 there is an error
	epp7	pr5|plio_sb.cur_fep,*	get ptr to the first value in format block
	lxl0	pr7|plio_fb.val_1	use it as offset to the real format's block--real vs.cplx
	lda	pr7|0,x0
	arl	plio_fb.code_shift	get the real part of the format's type code
	ana	plio_fb.code_mask,dl

	sta	pr5|5		and store it in storage block's fields for the real part
	ldq	pr7|0,x0		now go after the real part's nval
	qrl	plio_fb.nval_shift
	anq	plio_fb.nval_mask,dl
	stq	pr5|6		and store it in plio_sb.real-part's nval
	lxl6	pr5|plio_sb.nval	now see if a separate imag format was even specified
	cmpx6	2,du		if it was nval>1,  and extract & store the imag part's type &nval
	tpl	set_imag		which is done in set_imag
store_imag:
	staq	pr5|10		else just repeat the real part's values for plio_sb.imag's type, nval
	tra	test_currep	and were finished setting the cplx format's real,imag type, nval
"
set_imag:
	lxl0	pr7|plio_fb.val_2	get offset to imag part of complex format
	lda	pr7|0,x0		load the first word, which contains the type code
	arl	plio_fb.code_shift	extract it
	ana	plio_fb.code_mask,dl
	ldq	pr7|0,x0		extrace the nval,too--number of values
	qrl	plio_fb.nval_shift
	anq	plio_fb.nval_mask,dl
	tra	store_imag	and store them in plio_sb.imag part's type,nval
"
r_format_to_sb:
	epp0	pr5|plio_sb.space_ptr,*	to evaluate remote format we must 1st call stu$remote_format
	epp4	pr7|plio_fb.val	1st arg is plio_fb.val_1, which gets eval'd to the rmote format
	spri4	pr0|2		store it in arg list
	epp4	pr5|plio_sb.cur_sfp	2nd arg is stack_frame ptr to frame of format, not necessarily ours!
	spri4	pr0|4
	epp4 	null_loc		3rd arg is null
	spri4	pr0|6
	epp4	pr0|20		4th arg is a label(4 wds) in which to store loc of value of remote format
	spri4	pr0|8
	epp4	pr0|24		last arg is return value, which is error code
	spri4	pr0|10
	sreg	sp|8		and now do the call
	fld	5*2048,dl		5 args in all
	staq	pr0|0
	tsx1	<pl1_operators_>|[get_our_lp]
	stcd	sp|stack_frame.return_ptr
	callsp	<stu_>|[remote_format]
	lreg	sp|8
	epp4	sp|ps_ptr,*	restore ptr registers
	epp5	pr4|ps.format_area_p,*
	epp7	pr5|plio_sb.cur_fep,*
	epp3	pr5|plio_sb.space_ptr,*
	ldq	pr3|24		check error code
	tze	3,ic		if zero there's no problem
	lda	11,dl		else raise an error
	tra	<put_field_>|[any_qs_error_no_ret]
	epp2	pr3|22,*		get the format value's stack frame ptr
	ldq	pr5|plio_sb.stk_index
	mpy	10,dl		store each of the 2 ptrs making  up the label figured out by stu_
	spri2	pr5|plio_sb.sf2p,ql	into the right fields in the sb
	epp2	pr3|20,*		get fe pointer
	epp2	pr2|1		since the 1st word is a flag word of all zero's
	spri2	pr5|plio_sb.fe2p,ql
	tra	test_stk_index	and we're done
"
got_format:
	lda	pr5|plio_sb.type	transfer through a table to the right type-specific action
	ldq	pr4|ps.job
	canq	=o002000,du	check the put bit
	tnz	action-3,al	the name of the table is action
	xec	get_code-3,al	sp|temp will be 0 for data's, non-zero for stls
	epp7	pr5|plio_sb.space_ptr,*
	epp4	sp|ps_ptr		else set up the call to plio2_$quick_get_edit
	spri4	pr7|qs_arg_list+2	1st arg is ps ptr
	sreg	sp|8
	fld	1*2048,dl
	staq	pr7|qs_arg_list
	eppap	pr7|qs_arg_list	the qge stands for quick_get_edit, naturellement
	tsx1	<pl1_operators_>|[get_our_lp]
	stcd	sp|stack_frame.return_ptr
	callsp	<plio2_>|[quick_get_edit_]
	lreg	sp|8
	ldq	sp|temp
	tnz	ret_from_control
	lxl0	sp|stack_frame.operator_ret_ptr
	stz	sp|stack_frame.operator_ret_ptr
	tra	<put_field_>|[restore_regs_and_frame_and_ret]
"
decode_q:
	spri7	sp|double_temp	this code calls stu_$decode_runtime_value to decode the value
	epp0	pr5|plio_sb.space_ptr,*	which is in q on entry, and leaves the decoded value in q whin it
	stq	pr0|20		returns to the location in the operator which is in x6
	epp4	pr0|22		arg8 will be return value, which will be at pr0|22
	spri4	pr0|16		so put ptr to it in arg list as arg 8
	epp4	pr0|20
	spri4	pr0|2		arg1 is the value to eval
	epp4	pr5|plio_sb.cur_sfp
	spri4	pr0|6		arg3 is the stack_frame_p for the stack frame in which the value is
	epp4 	pr0|21
	spri4	pr0|14		arg7 is the returned error code
	epp4 	null_loc
	spri4	pr0|4		arg2 is null
	spri4	pr0|8		as is arg4
	spri4	pr0|10		arg5 is also null
	spri4	pr0|12		arg6 is also null
	sreg	sp|8		now do the call
	fld	8*2048,dl		there were 8 args including the return value which is the decoded value
	staq	pr0|0
	tsx1	<pl1_operators_>|[get_our_lp]
	stcd	sp|stack_frame.return_ptr
	callsp	<stu_>|[decode_runtime_value]
	lreg	sp|8
	epp4	sp|ps_ptr,*	restore ptr registers
	epp5	pr4|ps.format_area_p,*
	epp7	sp|double_temp,*	we saved pr7 in double_temp for the duration of this call
	epp3	pr5|plio_sb.space_ptr,*
	ldq	pr3|21		check returned error code, if non-zero raise error
	tze	3,ic
	lda	11,dl
	tra	<put_field_>|[any_qs_error_no_ret]
	ldq	pr3|22		return value is here, put it in q
	tra	0,6		and return to caller with evaluated value in q
"
"	what follows is the transfer table to the format-specific action
"	dictated by the format type,See include file  plio_format_codes for
"	numeric values of the differet format types
action:
	tra	do_c_format
	tra	do_f_format
	tra	do_e_format
	tra	do_b_format
	tra	do_a_format
	tra	do_x_format
	tra	do_skip_format
	tra	do_col_format
	tra	do_page_format
	tra	do_line_format
	tra	do_pic_format
	tra	do_bn_format
"
get_code:
	stz	sp|temp
	stz	sp|temp
	stz	sp|temp
	stz	sp|temp
	stz	sp|temp
	stcd	sp|temp
	stcd	sp|temp
	stcd	sp|temp
	stcd	sp|temp
	stcd	sp|temp
	stz	sp|temp
	stz	sp|temp
"
do_x_format:
	tsx6	check_for_param	x_format requires a parameter, else it is an error
	eax6	5		this is the code understood by put_field_$put_control for x format
	ldq	pr5|plio_sb.val_1	this is the parameter, or number of spaces to skip
	tze	test_currep	if its zero, ignore the format completely
	tra	do_control	else do the control
do_page_format:
	eax6	3		this is the code for page format which takes no parameter!
	tra	do_control
"
do_col_format:
	tsx6	check_for_param	this format requires a parameter
	eax6	2
	ldq	pr5|plio_sb.val_1	x6 has the format's code for put_control, q has the parameter itself
	tpnz	do_control
	ldq	1,dl		if the param was 0,make it 1 instead
	tra	do_control
"
do_line_format:
	tsx6	check_for_param
	eax6	4
	ldq	pr5|plio_sb.val_1
	tpnz	do_control
	lda	9,dl
	tra	<put_field_>|[any_qs_error_no_ret]
"
do_skip_format:
	eax6	1
	ldq	pr5|plio_sb.nval
	tze	no_skip_arg
"
do_most_controls:
	ldq	pr5|plio_sb.val_1
do_control:
	tsp1	<put_field_>|[put_control_from_format]
ret_from_control:
	epp4	sp|ps_ptr,*,
	epp5	pr4|ps.format_area_p,*	restore ptrs and continue with format-list walk
	tra	test_currep
no_skip_arg:
	ldq	1,dl
	tra	do_control
"
"	now for the data formats
"
do_a_format:
	epp1	pr5|plio_sb.space_ptr,*	it is my convention that pr1 points to the newly-alloc'd space
	lda	pr4|ps.descr	descr=0 means its a picture
	tze	a_f_pic_source
	ana	=o374000000000	otherwise,extract the source type from the descr
	arl	28
	cmpa	char_desc,dl	a is now the source type,lets filter out superquick conversons
	tze	char_to_char	character to char conversion can be superquick
	cmpa	v_char_desc,dl	as can varying_char to char
	tze	vchar_to_char
	tsx0	set_source_wa	any other situation is guaranteed to need an any_to_any conv.
a_f_source_ok:
	lda	pr5|plio_sb.nval	set_source_wa set the source regs used by a_to_a
	tze	no_len_given	if nval=0 no length given in a format
	lda	pr5|plio_sb.val_1	otherwise use it as the target length in a_to_a
	tnz	not_zero_targ		if a(0), must be pulled out,else assumed var str
ab_null_string:
	ldq	0,dl
	epp2	0			just to be safe
	tra	superquick_return
"
not_zero_targ:
	sta	pr5|plio_sb.format_len	we need it after the a_to_a call so save it
	eax6	char_desc		this is the target descriptor for a_to_a
	tra	source_been_set	and off to any_to_any and then put_field
"
no_len_given:
	stz	pr5|plio_sb.format_len	if no len given,make the target a varying char
	lda	256,dl		of max length 256 and store a 0 in format_len as a flag
	eax6	v_char_desc
"
source_been_set:
	epp5	pr1|66		pr5 points to work area of 156 words,starting at space|66
"	code to push a stack,needed for any_to_any call
	epbp7	pr6|0		point to stack header
	epp2	pr6|stack_frame.next_sp,*	point to next frame
	spri6	pr2|stack_frame.prev_sp	link next frame
	epp6	pr2|0
	epp2	pr2|new_stack_size
	spri2	pr7|stack_header.stack_end_ptr	store ptr to end of frame
	spri2	pr6|stack_frame.next_sp
	lxl0	pr6|stack_frame.flag_word	turn support bit on
	orx0	stack_frame.support_bit,du
	sxl0	pr6|stack_frame.flag_word
	epp2	*
	spbp2	pr6|tbp		set text_base_ptr
ata_call:
	tsx0	<any_to_any_>|[any_to_any_]	separate entry point for error signalling differences
"	code to pop my stack
after_ata_call:
	epbp7	pr6|0		point to stack header
	inhibit	on
	spri6	pr7|stack_header.stack_end_ptr
	epp6	pr6|stack_frame.prev_sp,*
	inhibit	off
"
	epp0	sp|ps_ptr,*	restore pointers
	epp5	pr0|ps.format_area_p,*
	epp2	pr5|plio_sb.space_ptr,*
af_return:
	ldq	pr5|plio_sb.format_len	put_field expects the output string's length in q
	tnz	2,ic		if it was zero, that means target was a varying string
	ldq	pr2|-1		so get the length from the length word at addr|-1
superquick_return:
	lxl0	sp|stack_frame.operator_ret_ptr	restore x0 to its value on entry to put_format
	stz	sp|stack_frame.operator_ret_ptr
	tra	<put_field_>|[put_field_from_format]	and off we go
"
vchar_to_char:
	ldq	pr5|plio_sb.nval	if no length specified no move is needed
	tze	vc_no_len		use source string as output
	epp3	pr4|ps.value_p,*	else move the string with padding/truncation
	lda	pr3|-1
	ldq	pr5|plio_sb.val_1	get the target len
	tra	superquick_af_2	and merge with the move, but pr3 already set
"
vc_no_len:
	epp2	pr4|ps.value_p,*
	ldq	pr2|-1		length of output string will be len of orig source var string
	tra	superquick_return	and were done
"
char_to_char:
	lda	pr4|ps.descr	get the length from descriptor's 2nd 1/2
	ana	=o000077777777
char_to_char_len:
	ldq	pr5|plio_sb.nval	if no length specified,use source string's len & no conversion
	tze	no_move		if no target len given, no move needed,use orig string as output
	ldq	pr5|plio_sb.val_1	
superquick_af:
	epp3	pr4|ps.value_p,*
superquick_af_2:
	epp2	pr1|0
	mlr	(pr,rl),(pr,rl),fill(040),enablefault
	desc9a	pr3|0,al
	desc9a	pr2|0,ql
	tra	superquick_return
"
no_move:
	epp2	pr4|ps.value_p,*
	lrs	36
	tra	superquick_return
"
a_f_pic_source:
	ldx0	pr4|ps.top_half	top_half is offset for the picture image
	epp7	sp|tbp,*x0	get a ptr  to it
	lda	pr7|1		extract its length & leave it in the a
	arl	27		length is top 9 bits of the word
	tra	char_to_char_len	since it must be a character picture merge with char_to_char
"
do_b_format:
	epp1	pr5|plio_sb.space_ptr,*	pr1 should point to the newly alloc'd space
	tsx0	set_source_wa	set the source registers for a_to_a
	lda	pr5|plio_sb.nval	save the param for the len of the final string,not this one
	tze	2,ic		if no format param given,let lang rules determine final length
	lda	pr5|plio_sb.val_1	
merge_b_bn:
	sta	pr5|plio_sb.format_len
	lda	256,dl		b format needs 2 conversions-1st to bit string, then to character
	eax6	v_bit_desc	for bit string, make it varying bit string with only max len given
	epp5	pr1|0		pr5 points to the work space
	epp1	pr1|222		pr1 points to where to put the result of conversion
"	code to push a stack,needed for any_to_any call
	epbp7	pr6|0		point to stack header
	epp2	pr6|stack_frame.next_sp,*	point to next frame
	spri6	pr2|stack_frame.prev_sp	link next frame
	epp6	pr2|0
	epp2	pr2|new_stack_size
	spri2	pr7|stack_header.stack_end_ptr	store ptr to end of frame
	spri2	pr6|stack_frame.next_sp
	lxl0	pr6|stack_frame.flag_word	turn support bit on
	orx0	stack_frame.support_bit,du
	sxl0	pr6|stack_frame.flag_word
	spri4	sp|ps_ptr
	epp2	*
	spbp2	pr6|tbp		set text_base_ptr
	tsx0	<any_to_any_>|[any_to_any_]
	epp4	sp|ps_ptr,*	restore pointers
	epp5	pr4|ps.format_area_p,*
	epp1	pr5|plio_sb.space_ptr,*
	epp3	pr1|222		source for final conversion=target of preliminary one
	lda	pr5|plio_sb.type	if its bn format 2nd half of conversion is different
	cmpa	bn_format,dl
	tze	final_conv_for_bn	this is who does the 2nd half for bn_format
	ldq	pr3|-1		length of bit string is at addr|-1
	lda	pr5|plio_sb.format_len	we saved length of final character string here
	tnz	2,ic		but  if no length given in b_format, use length of intermediate bit string
	lda	pr3|-1
	sta	pr5|plio_sb.format_len	in any case remember the length for later use
	eax6	char_desc		and convert to a character string
	eax7	v_bit_desc	from a varying bit string
	epp5	pr1|66		this is the 156 word work space for a_to_a
	tra	ata_call		do the second conversion & go straight to put_field
"
ata_call_and_ret:
	stx0	sp|temp		we will return here later
"	code to push a stack,needed for any_to_any call
	epbp7	pr6|0		point to stack header
	epp2	pr6|stack_frame.next_sp,*	point to next frame
	spri6	pr2|stack_frame.prev_sp	link next frame
	epp6	pr2|0
	epp2	pr2|new_stack_size
	spri2	pr7|stack_header.stack_end_ptr	store ptr to end of frame
	spri2	pr6|stack_frame.next_sp
	lxl0	pr6|stack_frame.flag_word	turn support bit on
	orx0	stack_frame.support_bit,du
	sxl0	pr6|stack_frame.flag_word
	epp2	*
	spbp2	pr6|tbp		set text_base_ptr
	tsx0	0,1		call the a_to_a entry point in index reg 1
"	code to pop my stack
	epbp7	pr6|0		point to stack header
	inhibit	on
	spri6	pr7|stack_header.stack_end_ptr
	epp6	pr6|stack_frame.prev_sp,*
	inhibit	off
"
	epp4	sp|ps_ptr,*	restore pointers
	epp5	pr4|ps.format_area_p,*
	epp1	pr5|plio_sb.space_ptr,*
	ldx0	sp|temp		restore index reg 0  and return through it
	tra	0,0
"
do_bn_format:
	epp1	pr5|plio_sb.space_ptr,*	pr1 should point to the newly alloc'd space
	tsx0	set_source_wa	set the source registers for a_to_a
	lda	pr5|plio_sb.nval	save the param for the len of the final string,not this one
	cmpa	2,dl
	tze	bn_with_len	if an explicit length was given we must put it in a register
	eaa	0		otherwise a length of 0 means no length was given
	tra	merge_b_bn	join flow of vanilla b_format
bn_with_len:
	lda	pr5|plio_sb.val_2	load the output length in a
	tra	merge_b_bn	and join b_format flow
"
final_conv_for_bn:
	ldq	pr3|-1		get length of source bit string,now converted
	div	pr5|plio_sb.val_1	now divide by the radix_factor to find out how many output-chars needed
	sta	sp|extra_bits	and save the remainder for later
	cmpa	0,dl		if there was a remainder, the # of output chars will be 1 greater
	tze	2,ic		to hold the left-overs,padded on the left with 0's
	adq	1,dl
	stq	pr5|plio_sb.extra_temp	now save this "real_len", or number of chars needed to hold value
"
	eax7	0		x7 is the count of how many output chars we have put out so far
	lda	pr5|plio_sb.nval	now find out if an explicit length was given
	cmpa	1,dl		if nval=1, there was only a radix-factor, no length
	tnz	bn_len_given	else goto to this label
	stq	pr5|plio_sb.format_len	final format len will be this length, not 0, which is
	tra	use_real_len	what is in plio_sb.format_len now ,for formats with no explicit length
bn_len_given:
	lda	pr5|plio_sb.val_2	get the given format length
	tze	ab_null_string	if its zero, put out a null string without raising stringsize
	cmpq	pr5|plio_sb.val_2	is the required num of char>format len?
	tpnz	raise_stringsize	if so, we must raise stringsize
	tze	use_real_len	if they are equal, no padding is needed
"
	mlr	(),(pr,rl),fill(040)	move in the blanks
	zero	0
	desc9a	pr1|0,al		pr1 points to output string
"
use_real_len:
	lxl0	pr5|plio_sb.extra_temp	move value to upper half of word, for later cmpxning
	stx0	pr5|plio_sb.extra_temp
	lxl1	pr5|plio_sb.val_1	x1 needs radix-factor , to know how long a string to csl
	stx1	sp|radix_factor	we need radix-factor in upper half of a word for adxning
	ldq	pr3|-1
	lda	sp|extra_bits
	eax0	0
	csl	(),(pr,rl,ql),bool(clear)
	zero
	descb	pr3|0,al
	ldq	36,dl		now handle the first  digit by hand,which we must cause we must
	sbq	pr5|plio_sb.val_1	assume leading 0's.We will load it and then shift it right 36-extra_bits bits.
	eax6	0,ql		x6 is how much to right-shift all other digits,=36-radix_factor
"
bn_loop:
	csl	(pr,rl,x0),(pr),bool(move)	move x1--radix-factor--bits from pr3 up x0--offset--
	descb	pr3|0,x1		to sp|rad_fac_bits
	descb	sp|radix_fac_bits,x1
"
	lda	sp|radix_fac_bits	now load those bits in a and shift them right enough to
	arl	0,x6		leave only one digit's worth
	adx0	sp|radix_factor	increment offset in source bits for next csl. Offset is in x0.
"
first_radix_factor_bits:
	mlr	(al),(pr,x7)	now use the digit in a-reg as index into hex_table to get correct character,
	desc9a	hex_table,1	and move that char to output string at offset x7
	desc9a	pr1|0,1
"
	adx7	1,du		increment output offset
	cmpx7	pr5|plio_sb.extra_temp	did we reach end of output string?
	tmi	bn_loop		if not, loop back and do the next digit
	tra	after_ata_call	at this point were done, so go here to pop stack, restore regs,
"				and go off to put field with the newly-created string.
"
hex_table:
	aci	"0123456789abcdef"
"
raise_stringsize:
	mlr	(pr),(pr),enablefault	this is a fake move whose only purpose in life is to raise
	desc9a	pr3|0,1		a stringsize condition if a truncation was implied by the output
	desc9a	pr1|0,0		request.
	tra	use_real_len	return to main body after the stringsize was raised
"
do_c_format:
	stz	pr5|plio_sb.cplx_flags	this is 2 flags-1st  half wd is real,2nd halfword is imag
	epp1	real_part_done	pef formats return to this label variable
	ldq	64,dl		we need more storage for complex final output string
	tsx1	<pl1_operators_>|[alloc]	dont change stor_taken cause put_term uses sp|5 to reset stack
	eaq	304
	stq	sp|storage_taken
	mlr	(pr),(pr)
	desc9a	pr5|5,20
	desc9a	pr5|0,20
"				space_ptr|240  will be the loc of the final string
handle_pef:
	spri1	pr5|plio_sb.pef_finish	pef format returns through here
	lda	pr5|plio_sb.type	find out format type
	cmpa	e_format,dl	can be e,f,or p format--f_format=4,e=5,pic=13
	tze	e_format_from_cplx
	tmi	f_format_from_cplx
	tra	p_format_from_cplx
"
real_part_done:
	epp7	pr5|plio_sb.space_ptr,*	we'll move the output str for the real part here
	epp7	pr7|240
	mlr	(pr,rl),(pr,rl)
	desc9a	pr2|0,ql
	desc9a	pr7|0,ql
	stq	pr5|plio_sb.real_parts_len	we need this to know where to put imag part &how long final string is
	eax1	2		imag_flag is 2 to be added to prec of dec float num to give len in bytes
	sxl1	pr5|plio_sb.cplx_flags
	epp1	imag_part_done
	mlr	(pr),(pr)
	desc9a	pr5|10,20
	desc9a	pr5|0,20
	tra	handle_pef	this will call pef format after storing return loc & setting format ptr in sb
"
imag_part_done:
	lda	pr5|plio_sb.real_parts_len	so we know where to put imag part of output string
	epp7	pr5|plio_sb.space_ptr,*
	a9bd	pr7|240,al
	mlr	(pr,rl),(pr,rl)
	desc9a	pr2|0,ql		q is len of imag part, pr2 points to it
	desc9a	pr7|0,ql		pr7 points to cplx_output up real_part_len
	adq	pr5|plio_sb.real_parts_len	so q has the length of the final complex string
	epp2	pr5|plio_sb.space_ptr,*	pr2 must point to string to be put
	epp2	pr2|240
	tra	end_of_pef
"
"
do_e_format:
	stz	pr5|plio_sb.cplx_flags
	epp1	end_of_pef
	spri1	pr5|plio_sb.pef_finish	pr5|plio_sb.pef_finish will be where to go on completion--in this case to put_field_
e_format_from_cplx:
	lda	pr5|plio_sb.nval	if coming in this entry, pef_finish will be a location in the complx handling
"				stuff. Now get the number of args to e_format- 1,2,3, corresponding to
"				e(w[,d[,s]]).. w is field width, d is num of decimal locations, s is num sig
	cmpa	2,dl		digits.
	tmi	e_one_op		one op is w, d=w-8, s=d+1
	tze	e_two_ops		two  ops are w,d..s=d+1
"				must have 3 ops
	lda	pr5|plio_sb.val_3	get the third one
	ldq	pr5|plio_sb.val_2	get  the 2nd one and put it in the q
	stq	sp|d_temp		since the 2nd arg is d, store it in d_temp
	cmpa	sp|d_temp		we must check that s is not < d, BUGFIX!
	tpl	e_merge_for_w	where we will extract the 1st val, or "w", and continue		
	tra	raise_size
"
e_two_ops:
"				get the 2nd arg, or "d"--num of decimal digits
	lda	pr5|plio_sb.val_2
	sta	sp|d_temp		and store it
	ada	1,dl		if s is not explicit, it =d+1, so now calc it
e_merge_for_w:
	ldq	pr5|plio_sb.val_1	get the 1st val, or "w"
	tze	ef_null_string
	stq	sp|w_temp		and store it
	tra	e_merge		e_merge assumes "s" is in a reg
"
e_one_op:
	lda	pr5|plio_sb.val_1	get "w"
	tze	ef_null_string
	sta	sp|w_temp		otherwise, w_temp never gets set, this is a BUGFIX!
	sba	8,dl		s=w-7
	sta	sp|d_temp		d=w-8
	ada	1,dl		and leave "s" in the a_reg
e_merge:
	sta	pr5|plio_sb.format_len	a has "s", or prec of fl dec intermed val
	epp1	pr5|plio_sb.space_ptr,*	pr1 always should point to our work space
	tsx0	set_source_wa		set the source regs for a_to_a call
	lda	pr5|plio_sb.format_len	load a with the precision of the float dec target
	lxl6	pr5|plio_sb.cplx_flags	we want  to see if its the imag part of a c_format
	tze	not_e_imag	if it is,we must force intermed value to cplx
	eax6	D_float_cplx_desc
	tra	not_e_imag+1
zero_value:
	mlr	(),(pr),fill(000)	AG94 says if the value is zero the exponent is printed as "000"
	zero	0		even though it isn't really, so move a 0 to exponent byte of value
	desc9a	pr1|0,1		at this point pr1 points to exponent byte of float dec number
	lda	pr5|plio_sb.format_len	now set a to the number of pre-decimal digits--all zeros
	sba	sp|d_temp		d_temp is the number of post-decimal digits
	s9bd	pr1|0,al		move pr1 backwards to encompass the requisite number of ascii "0"'s
	tra	zero_merge	and merge with main flow
not_e_imag:
	eax6	D_float_real_desc	this is the type of the intermed value to  convert to
	epp1	pr5|plio_sb.space_ptr,*	set up pr's for a_to_a call
	epp5	pr1|66		pr5 points to a_to_a's workspace
	eax1	<any_to_any_>|[any_to_any_round_]	lang rules say we must round,not truncate
	tsx0	ata_call_and_ret	and do conversion to float decimal
"
	ldq	pr5|plio_sb.format_len	put precision of float dec value in q
	epp7	pr1|66		pr7 is where we'll put result of our hand-conversion
	epp2	pr7|0		put_field expects pr2 to point to output string,so set it here
	lxl0	pr5|plio_sb.cplx_flags	we must throw away real part of cplx result if imag part of c_format
	tze	e_imag_merge	otherwise skip the next 2 instructions
	a9bd	pr1|0,ql		the real part of the complex value is of len prec+2
	a9bd	pr1|0,x0		and cplx_flag has a value of 2
e_imag_merge:
	eax0	1		we will frequently need a register with a 1 in it
	mlr	(pr),(pr),fill(000)	squirrel the sign char away for later use, in x1
	desc9a	pr1|0,1		we'll have to use sp|temp as a conduit
	desc9a	sp|temp,4		zeroing the rest of sp|temp
	ldx1	sp|temp		now x1 has the sign char,as desired
	a9bd	pr1|0,x0		x0 has a 1 in it, this is to skip sign char in source
	tct	(pr,rl)		find the 1st non-zero char in the float dec value
	desc9a	pr1|0,ql		this skips leading ascii zeros
	arg	table
	arg	sp|temp		offset of 1st non-zero will appear in sp|temp
	lda	sp|temp
	ana	=o000777777777	zero out the 1st byte of it, which is the char found
	a9bd	pr1|0,al		advance the source ptr over the leading zeros
	ttn	zero_value	if they are all zero, value is zero & we must change exponent's value
	neg	0
	ada	pr5|plio_sb.format_len	otherwise let a be the number of remaining digits after the 0's
zero_merge:
	sta	pr5|plio_sb.extra_temp		extra_temp is  the number of post-leading 0's digits
	ldq	sp|w_temp		w_temp is the total output field length
	mlr	(),(pr,rl),fill(040)	blank out entire target area
	zero	0
	desc9a	pr7|0,ql		pr7 points to target area
	lda	sp|d_temp		if d=0, no decimal point printed hence an extra leading blank
	tnz	2,ic
	a9bd	pr7|0,x0		this is the extra leading blank taking the place of the "."
	sbq	pr5|plio_sb.format_len	skip field-width-prec-6 leading blanks
	sbq	6,dl
	a9bd	pr7|-1,ql		for a while pr7 points to one word before where we are in output string
	cmpa	pr5|plio_sb.format_len	if s=d we must insert a pre-"." zero to look nice
	tze	s_is_d_move
	eax6	3		x6 is offset off of pr7 to put a "-" if needed
	eax7	4		x7 is offset off pr7 to move the pre-"." string
	lda	pr5|plio_sb.format_len	calculate the number of pre-"." digits
	sba	sp|d_temp		which is s-d, or num of sig digits - num of decimal digits
	sta	sp|sd_temp	sd_temp saves the value s-d
	ldq	sp|sd_temp	q is the number of pre-"." digits to move into
	cmpa	pr5|plio_sb.extra_temp		a is the num of pre-"." digits to move from, or min(s-d,extra_temp)
	tmoz	e_move
	lda	pr5|plio_sb.extra_temp
	tra	e_move		and now perform the move
"
	equ	table,*-12
	oct	000777777777
	oct	777777777777
	oct	777777000000
"
s_is_d_move:
	eax6	2		set the offsets & lengths for the case where s=d
	lda	0,dl		a = num of pre-"." digits to move from, or 0
	ldq	1,dl		q is the num of pre-"." digits to move to, or 1 "0"
	eax7	3		x7 is the offset for the pre-"." string of digits
	stz	sp|sd_temp	s-d is obviously 0
e_move:
	sta	sp|b_temp		the num of digits we're using from the float dec string will be needed later
	mlr	(pr,rl),(pr,rl,x7),fill(060)	fill is "0"
	desc9a	pr1|0,al		pr1 points to source string
	desc9a	pr7|0,ql		pr7 is our hand-converted result string
	cmpx1	minus_char	if float dec was <0 we must move in a "-"
	tnz	not_minus
	mlr	(),(pr,x6),fill(055)	fill is "-"
	zero	0
	desc9a	pr7|0,1		we set x6 previously to the offset for the "-" if needed
not_minus:
	ldq	sp|sd_temp	advance the source & targ ptrs past the chars we just moved
	a9bd	pr7|1,ql		we can now make pr7 point to targ string, not targ string-1word
	a9bd	pr1|0,ql		which was done cause negative offsets in strings not allowed
	ldq	sp|d_temp		now move the "." 
	tze	no_dec		if there are any decimal digits
	mlr	(),(pr),fill(056)	fill char is "."
	zero	0
	desc9a	pr7|0,1		so move the "." to the target string
	a9bd	pr7|0,x0		and advance the target ptr past it, x0 having a 1 in it
no_dec:
	lda	pr5|plio_sb.extra_temp		now move the post-"." digits
	sba	sp|b_temp		taking m-b digits from the source string,b being num previously moved
	ldq	sp|d_temp		and moving them into d digits, filling with "0"'s
	mlr	(pr,rl),(pr,rl),fill(060)	fill char is "0"
	desc9a	pr1|0,al		a has num of post-leading 0's digits minus num previously moved
	desc9a	pr7|0,ql		q has d, or num of  decimal digits specified by e format
	a9bd	pr7|0,ql		advance target ptr past just-moved digits
	a9bd	pr1|0,al		and source ptr,too
	mlr	(),(pr),fill(145)	move in the "e" which precedes the exponent's value
	zero	0
	desc9a	pr7|0,1
	a9bd	pr7|0,x0		advance targ ptr 1 char past the "e" we just moved in
	mlr	(pr),(pr)		now move the value of the exponent into sp|temp
	desc9a	pr1|0,1		pr1 now points to the exponent's value in the source string
	desc9a	sp|temp,1
	lda	sp|temp		load the exponent's value
	als	1		and make it into a normal number(it was 8 bits before)
	ars	28
	ada	pr5|plio_sb.extra_temp		final exponent=exp+m-s+d,where m=num of non-leading-0 digits
	sba	sp|sd_temp
	sta	sp|temp		store the final exponent's  value since btd is storage-to-storage
	btd	(pr),(pr)		and convert it to decimal form
	desc9a	sp|temp,4		putting it directly into the output string with a sign
	desc9ls	pr7|0,4		and three digits
	ldq	sp|w_temp		put_field want's field's length in q
	tra	pr5|plio_sb.pef_finish,*	and were finished with this conversion
"
end_of_pef:
	lxl0	sp|stack_frame.operator_ret_ptr	and we must restore x0, which we clobbered
	stz	sp|stack_frame.operator_ret_ptr
	tra	<put_field_>|[put_field_from_format]	and off we go
"
"	this routine sets up the registers describing the source to be converted
"	by any_to_any_. It is tsx0'd to
set_source_wa:
	ldq	pr4|ps.descr	picture sources,which have descr=0, must be handled differently
	tze	general_pic_source
	anq	=o376000000000	extract the source type from the descriptor
	qrl	10
	epp3	pr4|ps.value_p,*	pr3 must point to the source to be converted
	eax7	0,qu		x7 must have the source's type
	cmpx7	v_char_desc,du	fixed or varying strings must be handled differently
	tze	fix_len		since there descriptor has a len field rather than scale-prec
	cmpx7	v_bit_desc,du
	tze	fix_len
	cmpx7	char_desc,du
	tze	string_desc
	cmpx7	bit_desc,du
	tze	string_desc
	sta	sp|temp		we know it is an arithmetic source, so extract scale-prec from descr
	lda	pr4|ps.descr
	ana	=o000077777777
	lrl	12
	qrl	6
	lrl	18
	lda	sp|temp		now q has scale in top 1/2, prec in lower, and a has been restored
	tra	0,0		so were done
string_desc:
	ldq	pr4|ps.descr	strings have to have only the length extracted, which is lower 2/3 of descr
	anq	=o000077777777
	tra	0,0		and return, since x7 has already been correctly set
fix_len:
	ldq	pr3|-1		for varying strings we must extract the len of the source from addr|-1
	tra	0,0		and return. The a has not  been clobbered,x7 has been set
"
ef_null_string:
	ldq	0,dl		if e_format or f_format field width =0, AG94 says output
	epp2	pr5|plio_sb.space_ptr,*	is just a null string, so set it up
	tra	pr5|plio_sb.pef_finish,*	and we're finished with the entire ccnversion.
"
do_f_format:
	stz	pr5|plio_sb.cplx_flags	we are not in the middle of a complex format, so zero this flag
	epp1	end_of_pef	we want to go here when done with the conversion
	spri1	pr5|plio_sb.pef_finish
f_format_from_cplx:
	lda	pr5|plio_sb.nval	get num of values to f(...) from processed format block
	stz	sp|k_temp		k=scaling factor, usually zero so set it now, can be reset later if one found
	ldq	pr5|plio_sb.val_1	get 1st value, or w (field width).This MUST be there
	tze	ef_null_string	e,f formats are defined as null strings if w=0
	stq	sp|w_temp
	cmpa	2,dl		reg. a still has num of args to f_format
	tmi	f_one_op
	tze	f_two_ops
	ldq	pr5|plio_sb.val_3
	stq	sp|k_temp
f_two_ops:
"				now get 2nd arg,or num of dec positions (d)
	ldq	pr5|plio_sb.val_2
	stq	sp|d_temp
	tra	f_merge		to skip next instruction
f_one_op:
	stz	sp|d_temp		by definition, d=0 if not given
f_merge:
	epp1	pr5|plio_sb.space_ptr,*
	tsx0	set_source_wa
	stq	sp|temp
	ldq	sp|w_temp
	lda	sp|d_temp
	tze	2,ic		if d=0,prec=min(max_dec_precision,w), else prec=min(max_dec_precision,w-1).
	sbq	1,dl		this gives room for decimal point
	cmpq	max_dec_precision,dl
	tmoz	2,ic
	ldq	max_dec_precision,dl	if here, max_dec_precision<other width
	stq	pr5|plio_sb.extra_temp		you want to remember prec for 2nd half of conversion process
	ada	sp|k_temp		scale of fix dec num to convert to is d+k,d is already in q
	qls	18		should have prec in lower half, scale in upper, of a reg
	lls	18		prec was in al, now in au and scale in al
	lxl0	pr5|plio_sb.cplx_flags
	tze	3,ic
	eax6	D_fixed_cplx_desc
	tra	f_call
	eax6	D_fixed_real_desc	this is target type for a_to_a
f_call:
	ldq	sp|temp
	epp5	pr1|66
	eax1	<any_to_any_>|[any_to_any_round_]
	tsx0	ata_call_and_ret
"
	ldq	pr5|plio_sb.extra_temp		1st task is to blank out target string,for possible leading blanks
	eax6	1
	mlr	(pr),(pr),fill(000)	pr1 now pts to fix dec number
	desc9a	pr1|0,1		squirrel away sign char in x0
	desc9a	sp|temp,4
	ldx0	sp|temp
	epp3	pr1|0		pr3 is source_ptr
	lxl7	pr5|plio_sb.cplx_flags
	tze	3,ic
	a9bd	pr3|0,ql
	a9bd	pr3|0,x6
	epp7	pr1|66		pr7 will be loc of final output string
	epp2	pr7|0
	mlr	(),(pr,rl),fill(040)
	zero
	desc9a	pr7|0,ql		we just provided the leading, as well as more,blanks
	a9bd	pr3|0,x6		to skip sign in source
	sbq	sp|d_temp		q still has field width in it.We want to extract pre-decimal pt.
	sbq	1,dl		digits from the f.dec number,skipping leading zeros.
	tct	(pr,rl)
	desc9a	pr3|0,ql
	arg	table
	arg	sp|k_temp		p-q-1 is max possible num of leading zeros.
"
	ldq	sp|k_temp		k_temp has number of leading zeros
	anq	=o000777777777
	stq	sp|k_temp
	a9bd	pr3|0,ql		skip them by advancing source_p past them
	a9bd	pr7|0,ql		advance targ_ptr to leave the leading blanks virgin
"
	lda	pr5|plio_sb.extra_temp		the num of pre-"." digits is prec-num of skipped zeros-scale,so calc it
	sba	sp|k_temp		k_temp being num of skipped zeros
	sba	sp|d_temp		and d_temp being scale,s
	tmoz	raise_size	there must be at least one digit before "." BUGFIX
	cmpx0	minus_char	look at sign_p->char1 to see if orig value was <0,if so insert "-"
	tze	source_lt_zero	since sign_p->"-",insert a "-"
"
sign_set:
	mlr	(pr,rl),(pr,rl)	now move the pre-"." digits
	desc9a	pr3|0,al
	desc9a	pr7|0,al		remember pr7 is target ptr
	a9bd	pr3|0,al		advance source_p past digits we just moved
	a9bd	pr7|0,al		do the same for targ_ptr
	ldq	sp|d_temp		if scale=0,there is nothing but the pre-"." stuff so were finished
	tze	f_done
"
	mlr	(),(pr),fill(056)
	zero	0		move in the "." to the target	
	desc9a	pr7|0,1		which is pr7
	a9bd	pr7|0,x6		and up the targ ptr
	mlr	(pr,rl),(pr,rl)	now move in the last post-"." digits
	desc9a	pr3|0,ql		q still has q, which serves as the numbber
	desc9a	pr7|0,ql		of digits after the dec point
"			if you didnt notice, were finished!
f_done:
	ldq	sp|w_temp		q should be length of output string
	tra	pr5|plio_sb.pef_finish,*
"
source_lt_zero:
	cmpq	0,dl		if no zeros were skipped,no room for "-"	
	tpnz	dont_raise_size	if any 0's were skipped we have room
raise_size:
	epp7	pr5|plio_sb.space_ptr,*
	epp4	sp|ps_ptr		else set up the size-condition raising call
	spri4	pr7|qs_arg_list+2	1st arg is ps ptr
	sreg	sp|8
	lxl0	sp|stack_frame.operator_ret_ptr
	fld	1*2048,dl
	staq	pr7|qs_arg_list
	eppap	pr7|qs_arg_list
	tsx1	<pl1_operators_>|[get_our_lp]
	stcd	sp|stack_frame.return_ptr
	callsp	<plio2_>|[pve_error]
	lreg	sp|8
	tra	<put_field_>|[set_no_ret_error]
dont_raise_size:
	mlr	(),(pr),fill(055)	fill char is a "-", this moves it into output string
	zero	0
	desc9a	pr7|-1(3),1	pr7 points to output string
	tra	sign_set		and remerge with mainstream code, sign having been inserted
"
do_pic_format:
	stz	pr5|plio_sb.cplx_flags	snce were not doing imag  part of cplx format
	epp1	end_of_pef	where to go when finished
	spri1	pr5|plio_sb.pef_finish
p_format_from_cplx:
	lprp1	pr5|plio_sb.val_2	get a ptr to the format's picture_image in pr1
	spri1	sp|double_temp	and save it in  double_temp
	tsx1	decode_pic_desc	now decode the picture pointed to  by pr1
	sta	sp|int_val_scaleprec	a has the scale-prec specified by the picture
	stx6	sp|int_val_type	x6 has the type to convert through specified by the picture
	lda	pr4|ps.descr	find out if the source is pic,if so must unpack picture
	tnz	not_pic_source	if it isn't a picture skip call to unpack_pic
	eax0	ass_pic_source_to_intermed	this is where to go after unpacking the picture
"
"	This routine is dropped through to in the case of p_formats, and is tsx0'd to
"	from the other formats in the case in which the source value is a picture. The
"	routine calls unpack_pic and transfers to the location  in x0.
"
general_pic_source:
	ldx1	pr4|ps.top_half
	epp1	sp|tbp,*x1	1st build  a ptr  to the picture description,*x1at base|ps.top_half
	tsx1	decode_pic_desc	this routine assumes the ptr to the pic is in pr1
	sta	sp|source_val_scaleprec	store the returned scale-prec
	sxl6	sp|source_val_type	store the returned type
	epp7	pr5|plio_sb.space_ptr,*	we need space for the result of the unpacking
	epp7	pr7|156
	epp3	pr4|ps.value_p,*
	spri7	pr7|qs_arg_list+2	1st arg is buffer in which to  place result
	spri3	pr7|qs_arg_list+6	3rd arg is ptr  to source value
	spri1	pr7|qs_arg_list+4	2nd arg is ptr to  picture description
	sreg	sp|8		and make the call
	fld	3*2048,dl
	staq	pr7|qs_arg_list
	eppap	pr7|qs_arg_list
	tsx1	<pl1_operators_>|[get_our_lp]
	stcd	sp|stack_frame.return_ptr
	callsp	<unpack_picture_>|[unpack_picture_]
	lreg	sp|8
	epp4	sp|ps_ptr,*	restore ptr registers
	epp5	pr4|ps.format_area_p,*
	epp1	pr5|plio_sb.space_ptr,*
	epp3	pr1|156		let pr3->result of unpacking,which a_to_a will use as source ptr
	ldq	sp|source_val_scaleprec	scale-prec of source in q, for a_to_a call
	lxl7	sp|source_val_type	also for  a_to_a call
	tra	0,0		and return to sender
"
decode_pic_type:
	dec	42	char
	dec	18	real fix dec
	dec	22	cmplx fix dec
	dec	20	real fl dec
	dec	24	cmplx fl dec
not_pic_source:
	lrl	12		at this point a has the descr & we must extract scale-prec
	qrl	6		scale  is in 2nd 3rd of word, prec in 3rd 3rd
	lrl	12
	qrl	6
	stq	sp|source_val_scaleprec	scale is now in top 1/2 of q,prec in lower 1/2
	als	25		now extract the type field, adding to it the "packed" bit
	arl	29
	sta	sp|source_val_type	pr3 ->source val, all  nice for a_to_a
	epp3	pr4|ps.value_p,*
ass_source_to_intermed:
	ldq	sp|source_val_scaleprec	whether or not source is original or unpacked, now we convert it
	lxl7	sp|source_val_type	to the intermediate value specified by the  picture format
ass_pic_source_to_intermed:
	epp1	pr5|plio_sb.space_ptr,*	if we come from unpack_pic, q & x7 were already set
	epp7	pr1|48		set up the rest of the registers for a_to_a
	epp1	pr1|16
	lda	sp|int_val_scaleprec
	ldx6	sp|int_val_type	these are the conversion's target's scale-prec & type
	lxl1	pr5|plio_sb.cplx_flags
	tze	2,ic
	adx6	4,du		if imag part of c_format,force interm val to cplx
	epp5	pr7|0		this is ptr to work area
	eax1	<any_to_any_>|[any_to_any_]	this is proper entry to call
	tsx0	ata_call_and_ret	and do the conversion
"
	epp2	pr1|16		set pr2->output of conversion
	lda	pr5|plio_sb.cplx_flags	if imag part of cplx we must skip real part
	tze	image_pic_merge
	eax0	1		we will  skip 1 char for the exponent byte if dec float
	ldx6	sp|int_val_type	find out type
	cmpx6	D_float_real_desc	decimal float?
	tnz	2,ic		if not, just skip 1 extra byte for sign char, must be fixed decimal
	a9bd	pr2|0,x0		skip exponent  byte
	a9bd	pr2|0,x0		skip sign byte
	lda	sp|int_val_scaleprec	skip body of real value now
	a9bd	pr2|0,al		no mask needed to elim scale cause al takes only lower
image_pic_merge:
"				now call pack_picture for the final cconversion
	spri1	pr1|qs_arg_list+2	arg1 is ptr to where to put resulting output string
	epp7	sp|double_temp,*	double temp has ptr to picture description of p_format, remember
	spri7	pr1|qs_arg_list+4	which is arg2
	spri2	pr1|qs_arg_list+6	arg3 is ptr  ot source to be packed
	sreg	sp|8		set up the 3 argument call
	fld	3*2048,dl
	staq	pr1|qs_arg_list
	eppap	pr1|qs_arg_list
	tsx1	<pl1_operators_>|[get_our_lp]
	stcd	sp|stack_frame.return_ptr
	callsp	<unpack_picture_>|[pack_picture_]
	lreg	sp|8		restore registers and pointer regs
	epp4	sp|ps_ptr,*
	epp5	pr4|ps.format_area_p,*
	epp3	pr5|plio_sb.space_ptr,*
	epp2	pr3|0		pr2 should point to output string to be put out
	epp7	sp|double_temp,*	now calculate length of output for put_field
	ldq	pr7|1		which is found in pic_image.varlength
	qrl	pic_image.varlength_shift
	tra	pr5|plio_sb.pef_finish,*	and we're done with this exercise in the sublime
"	subroutine to decode a picture's descriptor,entered with pr1->picutre's
"	image and exited with the scale-prec in a and type in x6
"
decode_pic_desc:
	ldq	pr1|0		get  the pic_image type & decode it with use of the "decode_pic_type" table
	qrl	pic_image.type_shift
	lxl6	decode_pic_type-24,ql
	cmpx6	char_desc,du	now  the decoded type is in x6, so extract the scale-prec
	tze	char_desc_decode	if its a char type there is only a length, no scale-prec
	lda	pr1|0		else extract the scale-prec
	arl	pic_image.scale_shift
	ana	=o000000000777
	ldq	pr1|1		now scale is in lowest byte  of a,get prec in  q & merge them
	qrl	pic_image.scalefactor_shift	but first must handle the scalefactor, just in case there is one
	anq	pic_image.mask,dl
	stq	sp|temp		store the scalefactor in sp|temp
	sba	sp|temp		and subtract it from the scale
	ldq	pr1|0		now get the precision, at last
	anq	=o000777,du	and move it to the a with scale in  top 1/2 of a
	lls	18
	tra	0,1		and we're done & return to he who tsx1'd  to us
char_desc_decode:
	lda	pr1|1		get the length from the pic image, leave it in the a
	arl	27
	tra	0,1		and return
"
"	This subroutine checks that plio_sb.nval>0, if not it raises an error, if it
"	is it leaves the value of it in the q. It is tsx6'd to, and clobbers only the q.
"
check_for_param:
	ldq	pr5|plio_sb.nval
	tpnz	0,6
	lda	10,dl
	tra	<put_field_>|[any_qs_error_no_ret]
"
"	operator to terminate a put
"
put_terminate:
	eax6	1		set proc to call
	tra	<pl1_operators_>|[plio4]
"
minus_char:
	oct	055000000000
"
	even
null_loc:	its	-1,1,n		this is where we get "null" for argument ptrs  which should be null
	end
