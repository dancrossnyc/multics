" ******************************************************
" *                                                    *
" * Copyright, (C) Honeywell Bull Inc., 1987           *
" *                                                    *
" * Copyright (c) 1987 by Massachusetts Institute of   *
" * Technology and Honeywell Information Systems, Inc. *
" *                                                    *
" * Copyright (c) 1972 by Massachusetts Institute of   *
" * Technology and Honeywell Information Systems, Inc. *
" *                                                    *
" ******************************************************

" Completely rewritten by B. L. Wolman on 2/3/74 to use EIS
" Modified by R. K. Kanodia on 2/27/75   so that in
" ASCII strings mlr would not move zero length sring. See the label mc.
" Modified March 75 by Larry Johnson to fix several bugs and modify iteration logic
" Modified July 75 by Larry Johnson to enable ^p to handle invalid pointers and to
"	implement array processing.
" Modified August 1976 by Larry Johnson to implement if/then/else and
"	case features.
" Modified May 1978 by Larry Johnson to support ^np, and to accept character
"	arguments for ^d,^f,^e,^o,^[,^vX etc.
" Modified September 1978 by Larry Johnson to support all new pl1 and cobol
"	data types (primarily unsigned and 4-bit decimal). All argument
"	type processing was cleaned up to remove all internal coding
"	of data types. The include file std_descriptor_types is used.
" Modified November 1978 by Larry Johnson to add ^t. The entire program was
"	changed to use a common procedure to move data to the output buffer.
" Modified July 1979 by Larry Johnson to implement formline_$switch.  This
"	allows formline_ to generate an unlimited amout of output to be
"	to be written to an I/O switch instead of using a fixed size buffer
"	supplied by the caller.
" Modified December 1983 by Keith Loepere so i/o switch write works in bce.
" Modified January 29 1984 by Tom Oke to utilize any_to_any_ re-write and
"	generic float decimal data type for extended exponent ranges.

" call formline_(control,arg,prs,lrs,pad,alp)

" control		number of control string in arg list
" arg		number of first arg to control list in arg list
" prs		pointer to return string (INPUT) aligned
" lrs		length of return string in characters
" pad		one if padding required otherwise zero
" alp		arglist ptr -- optional (default alp is taken from preceding stack frame)

" call formline_$switch(control,arg,iocbp,nl,code,alp)

" control		as above
" arg		as above
" iocbp		pointer to iocb of switch to write upon
" nl		one if newline required, otherwise 0
" code		standard error code, returned by iox_$put_chars
" alp		as above, also optional

	name	formline_

	entry	formline_		Primary entry, as called by ioa_
	entry	ge		for output in GEBCD
	entry	switch		write output directly to I/O switch

	tempd	argp,inptr,buffptr
	tempd	pal,size,sizesp
	tempd	t1,t2,t3,t4
	temp	precision,exponent	EXPONENT MUST PRECEED TEMP1
	tempd	temp1(8),temp2(9),work(80)

	tempd	save_inptr	pointer to after ^ of current cmd
	temp	save_inlen	chars remaining after save_inptr
	temp	save_x7.x5	temp storage in ext calls X7/du, X5/dl

	temp	inlen
	temp	dpd,length
	temp	entry_switch	-1 for switch, 0 for normal, 1 for ge
	temp	default_precision,cur_arg,num_args,no_more_args

	temp	movinh		if >0 output movement inhibited by ^0( or bracket
	temp	depth		combined depth of parens and brackets
	temp	iter_count(4)	count of iterations - goes from negative to 0
	temp	iter_pointer(4)	ptr to ctrl string where iteration started
	temp	iter_length(4)	chars remaining in control string at iterate start
	temp	iter_cur_arg(4)	position in argument list at start of iteration
	temp	iter_argp(4)	argument pointer when iteration started
	temp	bracket_clause(4)	current clause in brackets
	temp	bracket_search(4)	clause that should be performed
	temp	brflags(4)	flags for each level of paren and brackket
	bool	brflags.movinh,400000	setting of movinh from previouss level
	bool	brflags.iteration,200000	on means in parens, off means in brackets
	bool	brflags.indefinite,100000	indefinite iteration - no count given


	temp	array_in_progress	+ if in array, 0 if not, - if array checking inhibited
	temp	array_mult	multiplier (words or bits) to step thru array
	temp	array_packed	non-zero if packed array (array_mult in bits)
	temp	array_desc	description word is saved here
	temp	array_length	total elements in array (product of all dims)
	temp	array_position	current position in array

	temp	v_not_done	this switch is set if a ^vX was not evaluated because
"				the movinh switch prevented an arg fetch

	equ	max_depth,4	combined max depth of parens and brackets


	include	stack_frame
	include	stack_header
	include	eis_micro_ops
	include	std_descriptor_types

" Miscellaneous character definitions

	bool	blank,040
	bool	minus,055		-
	bool	nl,012		new line
	bool	ht,011		horizontal tab
	bool	ff,014		Form-feed/new-page
	bool	rs,016		redshift
	bool	bs,017		black shift
	bool	zero,60		0
	bool	.,56		period
	bool	plus,53		+
	bool	star,52		*
	bool	lp,50		(
	bool	rp,51		)
	bool	esc,136		^
	bool	bar,174		|
	bool	e,145		e
	bool	v,166		v

"	Version II descriptor types

	bool	packed,1
	even
nullptr:	its	-1,1		a null pointer
ptrmask:	oct	077777000077,777777077077 a pointer mask

ge:	save
	lda	1,dl
	tra	form

formline_:
	save
	lda	0,dl
	tra	form

switch:	save
	lca	1,dl

form:	sta	entry_switch	save setting of output switch

	ldx2	ap|0		get current arglist header
	cmpx2	12,du		six arguments?
	tnz	no_alp		No

	ldaq	ap|12,*		Yes, get arglist ptr
	eraq	nullptr		Is it null?
	anaq	ptrmask		mask out non-unique ptr bits
	tze	no_alp		it's null

	eppbp	ap|12,*		get ptr to arg 6
	eppbp	bp|0,*		get arglist ptr supplied by caller
	tra	*+3

no_alp:	eppbp	sp|stack_frame.prev_sp,* go back one stack frame
	eppbp	bp|stack_frame.arg_ptr,* get arglist ptr from this frame

	spribp	pal		pointer to arg list
	ldaq	bp|0		get header of arg list
	sta	num_args		save 2*number of args
	ldx6	num_args
	tnz	args		are there args
	szn	entry_switch	switch entry?
	tmi	setup_output
	stz	ap|8,*		return null string
	return			we are done
args:	cana	=o10,dl		account for space used for internal
	tze	*+2		procedures in computing
	eaa	2,au
	sta	dpd		displacement to descriptor pointers
"
"	get ptr to and length of control string
"
	lca	1,dl		load a -1
	sta	array_in_progress	inhibit getarg from checking for arrays
	lda	ap|2,*
	als	1
	eax6	0,al
	tsx2	getarg
	stz	array_in_progress	we care about arrays now
	eax2	cstype		we want char string
	tsx3	fillin
	tra	done		exit if not char string
	spri2	inptr		save ptr and length
	stq	inlen

	stz	no_more_args	init to "there are more args"
	lda	ap|4,*		get number of first arg
	sba	1,dl		start 1 before 1st arg so "nextarg" will be the first
	als	1		multiply by 2
	eax6	0,al		and move to x6
	stx6	cur_arg

	stz	depth		init nesting depth
	stz	movinh		output movement not inhibited
"
"	set up output string
"
setup_output:
	stz	out_moved		number of characters stored
	lda	1,dl		starting column
	sta	out_column
	stz	out_to_borrow
	szn	entry_switch	which entry?
	tpl	not_switch
	epp2	ap|6,*		ptr to switch argument
	spri2	put_chars_arglist+2	setup argument list for put_chars
	epp2	out_moved
	spri2	put_chars_arglist+6
	epp2	ap|10,*		address of error code
	spri2	put_chars_arglist+8
	stz	put_chars_arglist+8,*	zero error code
	lda	sys_info$service_system
	tnz	call_iox
	epp3	put_chars_arglist+2,*	-> bce_iocb_ptr
	epp3	pr3|0,*			-> bce_iocb
	epp3	pr3|0,*			-> io routine
	tra	2,ic
call_iox:	epp3	iox_$put_chars
	spri3	put_chars_codeptr
	lda	=o000010000004	arglist header
	sta	put_chars_arglist
	stz	put_chars_arglist+1
	ldq	256,dl		use 256 character buffer in stack
	stq	out_left
	stq	out_size
	tra	grow_stack
not_switch:
	ldq	ap|8,*		set size
	stq	out_left
	stq	out_size
	szn	entry_switch	is this 6-bit mode?
	tze	notge		no, skip
grow_stack: 
	adq	3,dl		convert char count to word count
	qrs	2
	adq	15,dl		make multiple of 16
	anq	=o777760,dl
	epp3	sb|stack_header.stack_end_ptr,*	extend stack
	epp2	3|0,ql		by enough to hold output
	spri2	sb|stack_header.stack_end_ptr
	spri2	sp|stack_frame.next_sp
	tra	setout		join common section
notge:	epp3	ap|6,*		not 6-bit, get ptr to caller's buffer
	epp3	3|0,*
setout:	spri3	out_next
	spri3	buffptr		save ptr to buffer
	ldx2	num_args
	tze	done
"
"	locate next ^ in control string
"
nextarg:	tsx2	getargptr		get ptr to next arg
loop:	epp2	inptr,*		get ptr to input

	lda	inlen
	tze	no_control	no ^ if zero length string
	scm	(pr,rl),(du)	look for a ^
	desc9a	2|0,al
	vfd	o9/esc,27/0
	arg	t1
	ttf	have_control
"
"	no ^ found in rest of string, copy rest of control string into output
"
no_control:
	ldq	inlen		remaining length
	lda	0,dl
	tsx2	move_to_outbuf
	szn	entry_switch	$switch entry?
	tmi	finish_switch	yes, nothing to return
	ldq	out_moved		total characters generated
	stq	ap|8,*		return to caller
	szn	ap|10,*		padding requested?
	tze	done		no
	lda	out_left		move blanks to rest of buffer
	ldq	0,dl
	stz	movinh		don't let this be inhibited
	tsx2	move_to_outbuf


done:	szn	entry_switch	should we convert go GEBCD?
	tze	thru		no
	tpnz	convert_ge
finish_switch:
	szn	ap|8,*		need to append nl?
	tze	skip_newline	no
	stz	movinh		in case output inhibited
	epp2	new_line_char
	lda	1,dl
	ldq	1,dl
	tsx2	move_to_outbuf
skip_newline:
	tsx2	put_chars_buffer
	tra	thru
convert_ge:
	ldq	ap|8,*		get number of chars (including padding)
	epp3	ap|6,*		get ptr to beginning of caller's buffer
	epp3	3|0,*
	epp2	buffptr,*		get ptr to 6-bit buffer
	mvt	(pr,rl),(pr,rl)	now translate to GEBCD in caller's buffer
	desc9a	2|0,ql
	desc6a	3|0,ql
	arg	ascii_to_gebcd
"
thru:	return			and exit
"
"	move string of characters before the ^
"
have_control:
	ldq	t1		get number of chars preceding the ^
	tze	hc1		no work to do if zero
	lda	0,dl
	tsx2	move_to_outbuf
	lca	t1		-number of chars moved
	asa	inlen
	s9bd	2|0,al		bump ptr

hc1:	lca	1,dl		account for the ^
	s9bd	2|0,al
	asa	inlen
"
"	pick up size(s) from field
"
	spri2	save_inptr	save current location in control string
	lda	inlen
	sta	save_inlen
	tze	bad_field		must have some
rescan_control:
	eax0	0		x0 counts chars in field
	stz	v_not_done	reset this switch
	mlr	(0),(pr),fill(0)	zero size,size+1,sizesp,sizesp+1
	vfd	36/0
	desc9a	size,4*4
	eax4	0		set for first size
	tsx5	getsize
	cmpc	(pr,x0),(),fill(.)	is char "."?
	desc9a	2|0,1
	vfd	36/0
	tnz	check_key		no, don't try for second size
	adx0	1,du		account for the period
	sba	1,dl
	tze	bad_field
	eax4	1		set for second size
	tsx5	getsize
check_key:
	scm	(0),(pr,x0)
	desc9a	keys,key_length
	desc9a	2|0,1
	arg	t1
	ttn	bad_field		error if key not known
"
"	field ok, make sure we have an arg if we need one
"
	lxl6	t1		get position in key string
	szn	movinh		is output inhibited by ^0(?
	tze	arg_start		no
	cmpx6	arg2-arg1,du	see if this op is performed
	tmi	arg_dummy		no, setup dummy one
	cmpx6	arg4-arg1,du
	tmi	argok		always perform this
arg_dummy:
	ldx6	dumtra-arg1,du	set up dummy tra
	tra	argok		and go adjust pointers
arg_start:
	cmpx6	arg3-arg1,du	do we need an arg?
	tmi	3,ic		no, skip check
	szn	no_more_args
	tnz	bad_field
argok:	adx0	1,du		account for field
	sba	1,dl
	a9bd	2|0,0
	spri2	inptr
	sta	inlen
	tra	*+1,6		dispatch
arg1:	tra	put_control	|
	tra	put_control	/
	tra	put_control	-
	tra	put_control	R
	tra	put_control	B
	tra	put_control	^
	tra	put_blanks	x
	tra	skip		s
	tra	tab_to_column	t
arg2:	tra	lp_iterate	(
	tra	rp_iterate	)
	tra	semi_colon	;
	tra	right_bracket	]
arg3:	tra	left_bracket	[
arg4:	tra	put_chars		a
	tra	put_decimal	d
	tra	put_decimal	i
	tra	put_octal		o
	tra	put_pointer	p
	tra	put_octal_word	w
	tra	put_float		f
	tra	put_exponential	e
	tra	put_acc		A
	tra	put_bits		b
dumtra:	tra	loop		dummy tra

"	The order of the above tra's obviously must correspond to the string
"	of keys below. New control types must be positioned so that
"	the following relations hold:
"	  arg1<=X<arg3  means no argument required for control op
"	  arg2<=X<arg4  means that the control op must always be performed,
"		      even if output is inhibited
"	Note that these ranges overlap.

keys:	aci	"|/-RB^xst();][adiopwfeAb"
"
	equ	key_length,24
"
"	we come here when the field is bad.  move a ^ to output
"	and then go look for another field.  when the next field
"	(or end of string) is found, the characters of this field
"	will get copied to target
"
bad_field:
	epp2	save_inptr,*	backup pointer
	spri2	inptr
	lda	save_inlen	chars left in string
	sta	inlen
	lda	1,dl		move 1 character
	ldq	1,dl
	epp2	=a^
	tsx2	move_to_outbuf
	tra	loop		go look for another field
"
"	start iteration block
"
lp_iterate:
	tsx2	get_depth_start	get current nest index
	orx5	brflags.iteration,du	this is iteration (not brackets)
	canx5	brflags.movinh,du	is output already inhibited?
	tnz	lp_iterate2	yes, go do this level once
	szn	sizesp		was iteration count given?
	tnz	lp_iterate4	yes
	orx5	brflags.indefinite,du
	tra	lp_iterate3
lp_iterate4:
	lcq	size		negative of count given
	tnz	lp_iterate3
	aos	movinh		^0( inhibits output
lp_iterate2:
	lcq	1,dl		do loop once
lp_iterate3:
	stx5	brflags,6		save flags
	stq	iter_count,6	save_count
	lda	inlen		characters remaining in control string
	sta	iter_length,6	save for end of iteration
	sprp2	iter_pointer,6	save current control string pointer
	ldx5	cur_arg		current argument list offset
	stx5	iter_cur_arg,6	needed for end of iteration test
	epp2	argp,*		need arg pointer at end too
	sprp2	iter_argp,6
	tra	loop		done

"	subroutine called at start of parens or brackets to setup current level

get_depth_start:
	ldx6	depth		current depth
	adx6	1,du
	cmpx6	max_depth,du	too many?
	tpnz	bad_field		yes
	stx6	depth
	sbx6	1,du		better index for tables
	ldx5	0,du		initialize flag register
	szn	movinh		output inhibited from previous level?
	tze	2,ic		no
	orx5	brflags.movinh,du
	tra	0,2

"	subroutine called for end of parens or brackets to setup current level

get_depth_end:
	ldx6	depth		current depth
	tmoz	bad_field		nothing in progress
	sbx6	1,du
	ldx5	brflags,6		setup flags for current level also
	tra	0,2
"
"	finish iteration block
"
rp_iterate:
	tsx2	get_depth_end	get current depth
	canx5	brflags.iteration,du	really in iteration?
	tze	bad_field
	canx5	brflags.indefinite,du	is there a count?
	tnz	rp_inf		no, use special end test
	lda	iter_count,6	get remaining count
	ada	1,dl		count another iteration
	tpl	rp1		branch if done
	tsx2	arg_used_test	see if iteration will require an argument
	tra	do_rp		no, it will not, so ok to repeat
rp_test:	szn	no_more_args	are there more arguments?
	tnz	rp1		no, dont repeat the iteration
do_rp:	sta	iter_count,6	store remaining count
	lprp2	iter_pointer,6	load input ptr again
	ldq	iter_length,6	load back length
	spri2	inptr		reset input pointer
	stq	inlen		reset input length
	tra	loop		back for next arg

rp_inf:	tsx2	arg_used_test	will iteration require an arg
	tra	rp1		no, cant loop forever
	tra	rp_test		repeat only if args remain
"
"	done with iteration block or right bracket
"
rp1:	stz	movinh		this will allow output now
	canx5	brflags.movinh,du	unless inhibited from lower lovel
	tze	2,ic
	aos	movinh
	stx6	depth
	tra	loop

"	This subroutine compares the current argument being processed with the one
"	that was current when the loop began. If they are the same, the return is
"	to 0,2. Otherwise, the return is to 1,2.

arg_used_test:
	ldx5	cur_arg		current offset in argument list
	cmpx5	iter_cur_arg,6	same as when loop started?
	tnz	1,2		no, do the skip return
"	if offset is same, the actual argument may be different because
"	an array is being scanned.
	epp2	argp,*		current argument pointer
	sprp2	t4		store in packed form
	ldq	t4		get packed pointer
	cmpq	iter_argp,6	same as beginning pointr?
	tze	0,2		yes, loop definitely did not need arg
	tra	1,2		skip return, arg was used
"
"	start if/then/else or case selection (left bracket)

left_bracket:
	ldq	0,dl
	szn	movinh		is output already inhibited?
	tnz	left_bracket4	yes, go to 0th clause (dont get arg)
	eax2	cstype		check for character arg
	tsx3	fillin
	tra	left_bracket5	no
	cmpc	(pr,rl),(),fill(blank)	check for false
	desc9a	2|0,ql
	desc9a	false,5
	tze	left_bracket6	it is, treat like zero bit string
	cmpc	(pr,rl),(),fill(blank)	check for true
	desc9a	2|0,ql
	desc9a	true,4
	tze	left_bracket3	it is, treat like non-zero bit
	tra	left_bracket2	go treat as character digits
left_bracket5:
	eax2	bstype		param to test for bit argument
	tsx3	fillin		do the test
	tra	left_bracket2	not a bit string argument
	cmpb	(pr,rl),(),fill(0)	check bit string for all zero
	descb	2|0,ql
	descb	0,0
	tnz	left_bracket3	string is non-zero
left_bracket6:
	ldq	2,dl		zero string is "else", do second clause
	tra	left_bracket4
left_bracket3:
	ldq	1,dl		non-zero string is "then", do first clause
	tra	left_bracket4
left_bracket2:
	tsx5	load_fixed_bin
	tra	bad_field		error
left_bracket4:
	tsx2	get_depth_start	setup current depth
	stx5	brflags,6		save flags in stack
	stq	bracket_search,6	save clause number to execute
	ldq	1,dl		initialize current clause number
	stq	bracket_clause,6
	cmpq	bracket_search,6	should 1st clause be executed?
	tze	2,ic		yes
	aos	movinh		inhibit output until right clause found
	canx5	brflags.movinh,du	output previously inhibited?
	tnz	loop		yes, dont advance arg pointer
	tra	nextarg

"	end of if/then/else or case section

right_bracket:
	tsx2	get_depth_end	set up currnt level
	canx5	brflags.iteration,du	is this matching a (?
	tnz	bad_field		yes, error 
	tra	rp1		terminate
true:	aci	"true"
false:	aci	"false"
"
"	clause delimiter (semi_colon)

semi_colon:
	tsx2	get_depth_end
	canx5	brflags.iteration,du	be sure not between iterations
	tnz	bad_field
	canx5	brflags.movinh,du	is output inhibited from previous level
	tnz	loop		yes, it shouldn't be changed here
	szn	v_not_done	did scan fail to get value becuase of movinh?
	tnz	semi_colon2	yes, special stuff to do
	ldq	size		number of clauses to advance
	szn	sizesp		was it specified?
	tnz	2,ic		yes
	ldq	1,dl		no, assume 1
	adq	bracket_clause,6	compute new clause number
	stq	bracket_clause,6
	stz	movinh		enable output
	cmpq	bracket_search,6	should it be enabled?
	tze	2,ic		yes, right clause has been found
	aos	movinh		disable output
	tra	loop

"	come here when given "^v;" and the and the 'v' was not evaluated
"	because the movinh switch suppressed fetching the required arg.
"	reset movinh and rescan the control op.

semi_colon2:
	stz	movinh
	lda	save_inlen	reset length
	epp2	save_inptr,*	and pointer (to after the ^)
	tra	rescan_control
"
"	skip forward over arguments
"
skip:	szn	no_more_args	any more arguments?
	tnz	loop		no, so done
	szn	sizesp		was ^_ns given?
	tnz	skip2		yes
	lda	1,dl		default is 1
	sta	size
skip2:	lda	size		this is now number of ^s to do
	tze	loop		done if 0
	szn	array_in_progress	doing an array now?
	tnz	skip_array	yes
	sba	1,dl		account for ^s about to be done
	sta	size		number remaining to do
skip3:	tsx2	getargptr		step to next argument
	szn	no_more_args	see if found last one
	tnz	loop		all done
	tra	skip2		back to do another ^s

"	here to step pointer thru ^_ns array elements

skip_array:
	ldq	array_length	length of array
	sbq	array_position	subtract current position
	adq	1,dl		this gives number of array elements
	cmpq	size		is skip small enough to stay in array
	tpnz	step_array	yes
	stq	t4		number of ^s rest of array will satisfy
	sba	t4		this is remaining ^s to do
	sta	size		save this number
	stz	array_in_progress	no longer processing array
	tra	skip3		go back for next argument
step_array:
	asa	array_position	adjust current position
	lrl	36		get elements skipped in q
	mpy	array_mult	convert to words or bits
	eppbp	argp,*		pointer to current element
	szn	array_packed	is this packed array?
	tnz	step_packed_array	yes
	eppbp	bp|0,ql		add words to pointer
	tra	2,ic		go store result
step_packed_array:
	abd	bp|0,ql		make bit adjustment in packed array
	spribp	argp		store result
	tra	loop		and done
"
"	put out special character
"
mismatch:	tsx2	getargptr		skip bad argument
	ldx6	6,du		get special code for arg mismatch
	szn	size		be sure at least one char is sent
	tnz	2,ic
	aos	size
	aos	sizesp
"
put_control:
	szn	sizesp		was size specified
	tnz	2,ic		yes, skip
	aos	size		no, use size = 1
	szn	size		check for zero
	tze	loop
	epp2	fill_chars	point at appropriate fill character
	a9bd	2|0,6
put_control_loop:
	lda	1,dl		move 1 character
	ldq	1,dl
	tsx2	move_to_outbuf
	lca	1,dl
	asa	size
	tpnz	put_control_loop	loop for count requested
	tra	loop

fill_chars:
	vfd	9/ff,9/nl,9/ht,9/rs,9/bs,9/esc,9/star
new_line_char:
	vfd	9/nl,27/0

"
"	optimized routine for blanks, with one call to move characters

put_blanks:
	ldq	0,dl		no source
	lda	size
	szn	sizesp		size given?
	tnz	2,ic		yes
	lda	1,dl		just do 1
	tsx2	move_to_outbuf
	tra	loop
"
"	tab to specified column

tab_to_column:
	szn	size		valid column specified?
	tze	bad_field		no, error
	szn	sizesp+1		minimum count secified?
	tnz	2,ic		yes
	aos	size+1		no, assume 1
	lda	size		column requested
	sba	out_column	this given number of columns short
	cmpa	size+1		put out at least minumem spaces
	tpl	2,ic
	lda	size+1
	ldq	0,dl		no source chars
	stz	out_to_borrow	we must ignore borrow and goto column
	tsx2	move_to_outbuf	insert spaces
	lda	out_column	compute overshoot
	sba	size		ideally, this is zero
	sta	out_to_borrow	but if not, steal from next field
	tra	loop
"
"	put out F format
"
put_float:
	tsx2	compute_precision	compute default precision, leave in q
	szn	sizesp		was first size specified
	tnz	nf		yes, skip
	szn	sizesp+1		no, was second size specified
	tnz	.df		yes, skip
"
"	have ^f case (or continuation of ^nf case)
"	number of digits to use is in q
"
f1:	tsx5	convert_to_float_dec
	tra	f_zero
	tpnz	e_format		positive exponent means E format needed
	ada	precision		get number of digits before decimal point
	tmi	f2		special action if negative
	eax5	1,al		count decimal point
	mlr	(pr,rl),(pr,rl),fill(.)	move ddd.
	desc9a	temp1(1),al
	desc9a	temp2,x5
	lcq	exponent		get number of digits after .
	tze	gl		skip if none
	epp3	pl1_operators_$tct_octal_060
	tctr	(pr,rl,x5)	count number of trailing zeros
	desc9a	temp1,ql
	arg	3|0
	arg	t2
	ttn	gl		skip if fractional part all zeros
	sta	work		save number of digits before .
	lda	=o177,dl		isolate number of trailing zeros
	ansa	t2
	sbq	t2		compute number of digits to move
	mlr	(pr,rl,x5),(pr,rl,x5)
	desc9a	temp1,ql
	desc9a	temp2,ql
	adq	work		get number of digits moved
	lls	36		and shift to position
gl:	ada	1,dl		get length of number string
"
prefix_sign:
	epp2	temp2		get ptr to result
	eax7	1		get 1 so we can diddle pr
	cmpc	(pr),(0),fill(.)	is first character a decimal point
	desc9a	2|0,1
	vfd	36/0
	tnz	check_sign	no, skip
	mlr	(),(pr),fill(zero)	change .ddd to 0.ddd
	vfd	36/0
	desc9a	2|-1(3),1
	ada	1,dl		adjust field length
	s9bd	2|0,x7		and ptr
check_sign:
	cmpc	(pr),(0),fill(minus)	was input negative
	desc9a	temp1,1
	vfd	36/0
	tnz	move		positive, skip
prefix_minus:
	mlr	(),(pr),fill(minus)	prefix minus sign
	vfd	36/0
	desc9a	2|-1(3),1
	ada	1,dl		adjust field length
	s9bd	2|0,x7
	tra	move		and go move number
"
"	try putting all of precision after the decimal point
"
f2:	neg	0		get number of zeros required after decimal point
	epp3	pl1_operators_$tct_octal_060
	tctr	(pr,rl)		count trailing zeros
	desc9a	temp1(1),ql
	arg	3|0
	arg	t2
	ldq	=o177,dl		isolate number of trailing zeros
	ansq	t2
	cmpa	t2		can we use f format
	tpnz	e_format		no, switch to E format
	ldq	precision		get back precision
	lca	exponent
	sba	t2		get rid of trailing zeros
	sta	size+1
	tra	.df1
"
"	have value of 0 for ^f or ^nf case
"
f_zero:	epp2	=a0.
	lda	2,dl
	tra	move
"
nf:	szn	sizesp+1		first size given, was second?
	tnz	n.df
"
"	have ^nf case, use n-1 digits
"
	ldq	size
	sbq	1,dl
	tra	f1		go join ^f case with precision in q
"
"	have ^n.df case, use n-1 digits
"
n.df:	ldq	size
	sbq	1,dl
"
"	have ^.df case or continuation of ^n.df case, number of digits is in q
"
.df:	cmpq	size+1		make sure field is big enough
	tmi	punt+1
	tsx5	convert_to_float_dec	convert
	tra	ndf_zero		special action if zero
.df1:	sti	t2+1		save indicators
	ldi	=o4000,dl		prevent overflow fault
	lda	size+1		get d
	sba	t3		adjust for exponent correction
	ana	=o377,dl		mask to 8 bits
	ora	=a+01 		make value 1ed
	sta	t2		save
	adq	1,dl		get precision+1
	eaa	1,ql		get precision+2
	mp3d	(pr),(pr,rl),(pr,rl),round	move to fixed scaled temp
	desc9fl	t2,4
	desc9fl	temp1,au
	desc9ls	temp1,ql
	tov	punt		can't use this format if overflow on move
	ldi	t2+1		restore indicators
	lda	precision		get number of digits to left of .
	sba	size+1
	eax6	0,al		remember for later
	tze	f3		and skip if none
	epp3	pl1_operators_$tct_octal_060
	tct	(pr,rl)		count leading zeros
	desc9a	temp1(1),al
	arg	3|0
	arg	t2
	ldq	=o177,dl		isolate count of zeros
	ansq	t2
	sba	t2		get number of non-zero chars
	tze	f3		skip if none
	ldq	t2		get number of zeros
	mlr	(pr,rl,ql),(pr,rl)	move non-zero chars
	desc9a	temp1(1),al
	desc9a	temp2,al
"
"	chars to left of . have been moved, number is in a
"
f3:	ldq	size+1		get number of digits after .
	eax7	1,ql		include .
	mrl	(pr,rl,x6),(pr,rl,al),fill(.)	move digits with . on left
	desc9a	temp1(1),ql
	desc9a	temp2,x7
f4:	ada	size+1		form total length of field
	ada	1,dl
	tra	prefix_sign	go put on sign
"
punt:	ldi	t2+1		can't use this format
	stz	size
	tra	put_exponential
"
"	value for .df or n.df format is zero
"
ndf_zero:	lda	0,dl		assume no zero left of decimal
	ldq	size+1		get number of digits after .
	cmpq	precision		is there room for 0 to left?
	tpl	5,ic		no, skip
	mlr	(),(pr),fill(zero)	move zero
	vfd	36/0
	desc9a	temp2,1
	ada	1,dl		account for the zero
	eax7	1,ql		get number of zeros plus .
	mlr	(),(pr,rl,al),fill(zero)	move . with zero fill
	desc9a	ec1(2),1
	desc9a	temp2,x7
	tra	f4		go finish up
"
"	put out E format
"
put_exponential:
	ldq	size		use appropriate digits if size is zero
	tnz	2,ic
	tsx2	compute_precision
e0:	tsx5	convert_to_float_dec	convert to decimal
	tra	e_zero		special case if zero
e1:	epp3	pl1_operators_$tct_octal_060
	tctr	(pr,rl)		count trailing zeros
	desc9a	temp1(1),ql
	arg	3|0
	arg	t2
	lda	=o177,dl
	ansa	t2
	sbq	t2		compute number of digits to edit
	stq	default_precision
	adq	1,dl		get precision+1
	eax4	1,ql		get precision+2
	mvne	(pr,rl),(),(pr,rl)	generate sd.ddd
	desc9ls	temp1,ql
	desc9a	float_edit,8
	desc9a	work,x4
	ldq	precision		get true exponent
	sbq	1,dl
	asq	exponent
	btd	(pr),(pr)		convert exponent to decimal
	desc9a	exponent,4
	desc9ls	temp1,11
	mvne	(pr),(),(pr)	edit to remove leading zeros
	desc9ls	temp1,11
	desc9a	exp_edit,5
	desc9a	temp2,11
	ldq	11,dl		remove leading blanks
	tsx5	strip_blanks
	eax3	1,al		get 1+number of chars in exponent
	mrl	(pr,rl),(pr,rl,x4),fill(e)	move exponent prefixed by "e"
	desc9a	2|0,al
	desc9a	work,x3
	asa	default_precision	update true char count
	ldq	default_precision	length of field is default_precision+3
	adq	3,dl
	epp2	work		get ptr to result
e2:	szn	sizesp		was size specified
	tnz	2,ic
	stq	size		no, set field size
	lda	size		get size of field to be filled
	tsx2	move_to_outbuf
	tra	nextarg
"
"	value is zero
"
e_zero:	epp2	ec1
	ldq	5,dl
	tra	e2		go output
"
ec1:	aci	" 0.e0"
"
"	can't use F format, convert to E format
"
e_format:
	stz	size		act as if size not given
	ldq	default_precision	get default precision
	cmpq	precision		check current precision
	tze	e1		save, nothing to do
	tpl	e0		current smaller, start from beginning
	adq	2,dl		get default precision+2
	lda	precision		get current precision+2
	ada	2,dl
	mvn	(pr,rl),(pr,rl),round	round to default precision
	desc9fl	temp1,al
	desc9fl	temp1,ql
	sbq	2,dl		get back default pecision
	stq	precision		save new precision
	tsx2	extract_exponent
	tra	e1		go do formatting
"
"	routine to convert input argument to float
"	decimal in temp1.  entered with desired output
"	precision in q and source type in x7.
"	return with same precision value in q
"	and exponent in a.  return is 0,5 if source value
"	is 0 and 1,5 if source not 0.
"	at return indicators correspond to exponent value.
"
convert_to_float_dec:
	sxl5	save_x7.x5	save return
	eax5	1		specify rounding
	eax6	2*real_flt_dec_generic_dtype	set target type
"
"	convert to decimal
"
convert_to_decimal:
	cmpq	59,dl		make sure max not exceeded
	tmoz	2,ic
	ldq	59,dl
	stq	precision		save precision

	tsx3	test_numeric	see if numeric
	tra	*+2		it isn't, try other stuff
	tra	cv_check_ok	good numeric, proceed
	eax2	cstype		try character
	tsx3	fillin
	tra	mismatch		not character, error
cv_check_ok:
	epp1	temp1		target ptr
	cmpx6	2*real_flt_dec_generic_dtype,du  see if generic type
	tnz	cv_not_generic	not generic type
	epp1	exponent		point to exponent of generic decimal
cv_not_generic:
	epp3	argp,*		source ptr
	epp5	work		scratch area
	epp2	*		set ptr to base of ourselves
	spbp2	sp|38		text base pptr
	lda	length		get input length & precision
	lrl	12		get scale in left of q, precision in right
	qrl	6
	lrl	12
	qrs	6
	lda	precision		target
	stx7	save_x7.x5	any_to_any_ may change this
	xec	call_any_to_any_,5	call truncate or round entry
	epbp7	sp|0
	lxl5	save_x7.x5	restore return offset
	ldx7	save_x7.x5
	ldq	precision		get target precision
	epp3	pl1_operators_$tct_octal_060
	tct	(pr,rl)		count leading zeros in decimal value
	desc9a	temp1(1),ql
	arg	3|0
	arg	t1
	ttn	0,5		special return if all zero
	cmpx6	2*real_flt_dec_generic_dtype,du d is this float
	tnz	1,5		no, exit
	lda	t1
	ana	=o77,dl
	sta	t3		save exponent correction
	tze	getexp		skip if no leading zeros
	eax2	0,al		save number of leading zeros
	neg	0		get number of chars afterward
	ada	precision
	mlr	(pr,rl,x2),(pr,rl),fill(zero)	shift number to left
	desc9a	temp1(1),al
	desc9a	temp1(1),ql

"     We require a true hardware floating representation for ^n.df format
"     determination at ".df1:".  We setup this exponent as the true exp if
"     within range of fixed bin (7), or with (2**7)-1 appropriately signed.
"     .df1: uses the overflow indication used to determine if e-format needs
"     to be used.

getexp:	lda	exponent		move in real exponent
	sta	save_x7.x5	setup for hardware exponent
	lda	=127,dl		force high hardware exp
	cmg	exponent		in range?
	tpl	getexp.in_range	in range - take normal exponent
	cmpa	exponent		see if we store negative exponent
	tmi	getexp.pos	set positive maximum exponent
	lda	=-127,dl		set negative maximum exponent
getexp.pos:
	sta	save_x7.x5

getexp.in_range:
	lda	exponent		convert exponent to signed value
	sba	t3		subtract correction
	sta	exponent
	mlr	(pr),(pr,ql)	set hardware exponent - needed in ^n.df
	desc9a	save_x7.x5(3),1
	desc9a	temp1(1),1
	tra	1,5		take normal return

"	select proper any to any call

call_any_to_any_:
	tsx0	any_to_any_$any_to_any_truncate_
	tsx0	any_to_any_$any_to_any_round_
"
"	convert input argument to fixed decimal
"	we try to do this without any_to_any_ if at all possible
"	so that wired ring0 code can use it.
"
convert_to_fixed_dec:
	sxl5	save_x7.x5	save return
	eax2	cstype		try character first
	tsx3	fillin
	tra	*+2		not character
	tra	ctfd		it is character, use any_to_any_

	tsx5	load_fixed_bin	take our best shot
	tra	ctfd		too hard, let any_to_any_ do it
	staq	temp1+6
	epp2	argp,*		get ptr to arg
	ldq	23,dl		use precision 23 in simple case
	lxl5	save_x7.x5	get return address
	btd	(pr),(pr)		convert as if input were fixed bin(71)
	desc9a	temp1+6,8
	desc9ls	temp1,24
	tze	0,5		special exit if zero
	tra	1,5		normal exit

ctfd:	eax5	0		no rounding
	eax6	2*real_fix_dec_9bit_ls_dtype	set type
	ldq	59,dl		precisison
	tra	convert_to_decimal
"
"	compute decimal_precision = ceil(binary_precision/3.32)
"
compute_precision:
	ldq	length		get length from descriptor
	anq	=o7777,dl		isolate precision
	eaa	0,7		get argument type
	arl	18+1		leave just type
	sba	1,dl
	cmpb	(al),(),fill(0)	is this binary?
	descb	binary_dtype_mask,1
	descb	0,0
	tze	set_dp		not binary use precision as is
	mpy	=.301205b-1
	cmpq	0,dl
	tze	2,ic
	ada	1,dl
	lrs	36		get decimal precision in q
set_dp:
	stq	default_precision	save default precision
	tra	0,2



"	routine to extract exponent from float dec value
"	in temp1 with precision given in q
"
extract_exponent:
	mlr	(pr,ql),(pr)	extract exponent
	desc9a	temp1(1),1
	desc9a	exponent,1
	lda	exponent		convert exponent to signed value
	als	1
	ars	28
	sba	t3		subtract correction
	sta	exponent
	tra	0,2
"
"	put out ptr
"
put_pointer:
	cmpx7	2*pointer_dtype,du	is this unpacked case
	tze	pp1		yes, do it
	cmpx7	2*label_dtype,du	is this label var
	tze	pp1		yes, dofirst pointer
	cmpx7	2*entry_dtype,du	is this entry var
	tze	pp1		yes, do first pointer
	cmpx7	2*pointer_dtype+packed,du	is this packed case
	tnz	mismatch		have mismatch if not packed

"	start here with packed pointer

	epp2	argp,*		address of the packed pointer
	csl	(pr),(pr),bool(3)	copy to a word aligned place
	descb	2|0,36
	descb	t3+1,36
	lda	t3+1
	eaq	0		zero the q
	lrl	18		word offset in q-upper
	arl	3		get bit offset in position
	ana	=o077000,dl	isolate bit offset
	sta	t3		store bit offset
	orq	t3		bit offset in right place in q
	lda	t3+1		get origional pointer
	ana	=o007777,du	keep only segment
	cmpa	=o007777,du	is in packed form of -1?
	tnz	2,ic		no
	lda	=o077777,du	use standard form of -1
	tra	pp2		join common case

"	start here with unpacked pointer

pp1:	ldaq	argp,*		get unpacked ptr
	anaq	ptrmask		remove un-important bits

"
"	common packed and unpacked pointer section

pp2:	staq	t3
	stz	t1		init output char count
	tsx2	octal_field	put out 6 digits of seg number from au
	mlr	(),(pr,al),fill(bar)	append a |
	vfd	36/0
	desc9a	work,1
	aos	t1		account for |
	lda	t3+1		put out 6 digits of word offset from au
	tsx2	octal_field
	btd	(pr),(pr)		convert bit offset to decimal
	desc9a	t3+1(2),1
	desc9ns	temp1,2
	tze	ptr_done		done if bit offset is zero
	mlr	(),(pr,al),fill(lp)	append a (
	vfd	36/0
	desc9a	work,1
	ada	1,dl		account for (
	eax6	0		assume bit offset is really 2 digits
	ldq	2,dl
	cmpc	(pr),(),fill(zero)	is first character a 0?
	desc9a	temp1,1
	vfd	36/0
	tnz	3,ic		skip if non-zero
	eax6	1		really only 1 digit
	ldq	1,dl
	eax7	1,ql		get number of digits + 1
	mlr	(pr,rl,x6),(pr,rl,al),fill(rp)	add digits followed by )
	desc9a	temp1,ql
	desc9a	work,x7
	sta	t1		get final count
	asq	t1
	aos	t1
ptr_done:
	epp2	work		and go move to target
	ldq	t1		number of characters in edited pointer
	lda	size		use field width given
	tsx2	move_to_outbuf
	tra	nextarg
"
"	routine to put out from 1 to 6 chars of octal from contents of au
"	into work area.  t1 gives numbers of chars already in work,
"	t1 is updated and left in a at exit
"
	odd			to force rpd odd
octal_field:
	eax1	3		init rpd loop
	arl	18		shift au to position
	odd
	rpd	6,0
	lrl	0,1
	qrl	0,1
	orq	=o606060606060	form 6-bit ascii
	stq	temp1		save
	mve	(pr),(),(pr)	convert to 9-bit ascii with leading blanks
	desc6a	temp1,6
	desc9a	oct_edit6,2
	desc9a	temp2,6
	ldq	6,dl		remove leading blanks
	tsx5	strip_blanks
	ldq	t1		get offset to use
	mlr	(pr,rl),(pr,rl,ql)	move to work area
	desc9a	2|0,al
	desc9a	work,al
	ada	t1		update count
	sta	t1
	tra	0,2		return to caller
"
"	put out fixed binary integer in signed octal
"
put_octal:
	tsx5	load_fixed_bin	load input
	tra	mismatch		bad data type
	staq	t1		remember whole value
	lrs	0		test sign
	tpl	2,ic		get abs value
	negl	0
	staq	t2		save abs value
	epp2	temp1		get ptr to where we want octal
	tsx5	octal		convert first word to 12 digits of octal
	epp2	temp1+3		convert 2nd word
	lda	t2+1
	tsx5	octal
	mvne	(pr),(),(pr)	edit leading zeros into blanks
	desc9ns	temp1,24
	desc9a	oct_edit24,3
	desc9a	temp2,24
	ldq	24,dl		remove leading blanks
	tsx5	strip_blanks
	szn	t1		was input negative
	tpl	move		move if positive
	eax7	1
	tra	prefix_minus	put on sign if negative
"
"	put out single word in unsigned octal
"
put_octal_word:
	lda	argp,*		get word for output
	epp2	temp1		get where to put chars
	tsx5	octal
	lda	12,dl		assume size of 12
	szn	sizesp		was size specified
	tze	move		no
	cmpa	size		size greater than 12?
	tmoz	move		yes, go move with leading spaces
"
"	size < 12, see if we can drop leading zeros
"
	epp3	pl1_operators_$tct_octal_060
	tct	(pr)		count leading zeros
	desc9a	temp1,12
	arg	3|0
	arg	t1
	ldq	=o177,dl		isolate number of leading zeros
	ansq	t1
	sba	size		get 12-size
	cmpa	t1		get min(#zeros,12-size)
	tmi	2,ic
	lda	t1
	a9bd	2|0,al		adjust ptr
	neg	0		compute new field size
	ada	12,dl
	sta	size
	tra	move
"
"	put out ascii string
"
put_chars:
	eax2	cstype		we want char info
	tsx3	fillin		go get info about string
	tra	mismatch		error if not right type
"
"	remove trailing blanks from string
"
	epp3	pl1_operators_$tct_octal_040
	tctr	(pr,rl)		scan backward over blanks
	desc9a	2|0,ql
	arg	3|0
	arg	t2
	lda	=o77777777	isolate chars skipped
	ansa	t2
	sbq	t2		adjust length
	lda	out_column	save starting columen
	sta	save_out_column
	lda	0,dl		no specifiec length
"
"	move characters pointed at by pr2 into output
"
	tsx2	move_to_outbuf
	szn	sizesp		column width specified?
	tze	nextarg		no
	szn	newline_moved	any newlines, or friends in data?
	tnz	nextarg		yes, don't try any column adjusting
	lda	save_out_column	starting column
	ada	size		target column
	sba	out_column	amount we are short
	tmoz	nextarg		at or past target
	ldq	0,dl
	tsx2	move_to_outbuf	move spaces to reach descired column
	tra	nextarg
"
"	put out ACC string
"
put_acc:
	epp2	argp,*		get ptr to acc
	epp2	2|0,*
	ldq	bp|0		extract the size
	qrl	27
	lda	0,dl
	eax6	1		adjust ptr
	a9bd	2|0,6
	tsx2	move_to_outbuf
	tra	nextarg
"
"
"	put out bit string
"
put_bits:	eax2	bstype		want info about bit strings
	tsx3	fillin		go get length in q
	tra	mismatch
	lda	size+1		do we have byte size specified
	tpnz	2,ic		yes
	lda	1,dl		no, use 1 bit byte
	cmpa	4,dl		is byte size too big?
	tmoz	2,ic
	lda	4,dl		yes, use hex
	sta	size+1		save correct byte size
	div	size+1		get number output chars to generate
	szn	sizesp		was field size specified
	tze	4,ic		no, skip
	cmpq	size		is number greater than size
	tmoz	3,ic
	ldq	size		yes, just use size specified
	stq	size		save correct field size
	lxl7	size+1		get byte size
	epp5	2|0		pointer to bit string
bit_convert:
	csr	(pr,rl),(pr),fill(0),bool(3)	move byte to right end of word
	descb	5|0,x7
	descb	temp1,36
	lxl5	temp1		load right adjusted byte
	epp2	bit_alpha		get address of converted character
	a9bd	2|0,5
	ldq	1,dl		move 1 character
	lda	1,dl		no padding
	tsx2	move_to_outbuf
	abd	5|0,7		bump bit address
	lca	1,dl
	asa	size		count bytes
	tpnz	bit_convert
	tra	nextarg
"
"	put out fixed binary number in decimal
"
put_decimal:
	tsx5	convert_to_fixed_dec	get decimal
	tra	i_zero		skip if zero
	adq	1,dl		get precision + 1
	mvne	(pr,rl),(),(pr,rl)	get rid of leading zeros and plus sign
	desc9ls	temp1,ql
	desc9a	int_edit,6
	desc9a	temp2,ql
	tsx5	strip_blanks	go remove blanks
"
"	routine to move string into output with padding on left
"	entered with pr2 pointing at string to move, length of string in a
"
move:	sta	t1		save character width
	szn	sizesp		was size specified
	tnz	2,ic		yes
	sta	size		no, set size appropriately
	cmpa	size		is actual field bigger than specified size
	tpl	movea		no leading spaces needed
	sba	size
	neg	0		count of leading spaces
	ldq	0,dl		no source characters for spaces
	tsx2	move_to_outbuf
movea:	ldq	t1		get field size
	lda	0,dl
	tsx2	move_to_outbuf
	tra	nextarg

"
"	have 0 value for i format
"
i_zero:	epp2	=a0.
	lda	1,dl
	tra	move
"
"	routine to load fixed bin input arg into aq
"
load_fixed_bin:
	tsx3	test_numeric	see if numeric value first
	tra	load_fixed_bit	go try bit
	eaa	0,7		pick up type
	arl	18+1		align and drop packed bit
	ldx3	0,du		0 here means signed
	eaq	load_single	routine for simple signed
	cmpa	real_fix_bin_1_dtype,dl
	tze	load_fixed_ok
	eaq	load_double	routine for double prec signed
	cmpa	real_fix_bin_2_dtype,dl
	tze	load_fixed_ok
	ldx3	1,du		1 here means unsigned
	eaq	load_single_uns
	cmpa	real_fix_bin_1_uns_dtype,dl
	tze	load_fixed_ok
	eaq	load_double
	cmpa	real_fix_bin_2_uns_dtype,dl
	tze	load_fixed_ok
	tra	0,5		non-skip for bad type

load_fixed_ok:
	lda	length		be sure no scale 
	arl	12
	ana	=o7777,dl
	tnz	0,5		cant handle non zero scale
	canx7	packed,du		unaligned argument?
	tnz	load_packed_fixed_bin yes
	tra	0,qu		go to handler previously set

load_single:
	lda	argp,*		arg is unpacked single precision
	lrs	36
	tra	1,5

load_single_uns:
	ldq	argp,*
	lda	0,dl
	tra	1,5

load_double:
	ldaq	argp,*
	tra	1,5
"
"	arg is packed, move to aligned temp and then load
"
load_packed_fixed_bin:
	lda	length		get length
	ana	=o7777,dl
load_fixed_bit_join: 
	xec	get_fixed_bin_size,x3 compute field width
	als	18		shift to au
	sta	t2		and save
	epp2	argp,*		load ptr to arg (including bit offset)
	csl	(pr,rl),(pr,rl),bool(3)	move to aligned temp
	descb	2|0,au
	descb	t1,au
	ldaq	t1		load the aligned value
	lcx2	t2		get -(width)
	xec	shift_fixed_bin_field,x3	shift value to position
	tra	1,5		and return

get_fixed_bin_size:
	ada	1,dl		for signed, add 1
	ada	0,dl		for unsigned, do nothing
shift_fixed_bin_field:
	lrs	72,2		for signed, use arithmetic shift
	lrl	72,2		for unsigned, use logical shift

"	try to load a bit string. If it is short enough (<= 72)
"	it is treated like unsigned binary

load_fixed_bit:
	eax2	bstype		see if bit string first
	tsx3	fillin
	tra	load_fixed_char	no, try charracter
	cmpq	72,dl		see if short enough
	tpl	0,5		cant handle it
	lls	36		get length in a
	ldx3	1,du		code for unsigned
	tra	load_fixed_bit_join
"
"
"	try arg as character
"
load_fixed_char:
	eax2	cstype		address of character codes
	tsx3	fillin		get pointer and length
	tra	0,5		not character, error
	stz	t2		0 will mean positive
	cmpq	0,dl		any chars?
	tze	load_fixed_zero	no, return 0
	cmpc	(pr),(),fill(plus)	leading +?
	desc9a	2|0,1
	oct	0
	tze	load_fixed_skip_sign yes
	cmpc	(pr),(),fill(minus)	leading -?
	desc9a	2|0,1
	oct	0
	tnz	load_fixed_digits	no
	aos	t2		flag meaning minus
load_fixed_skip_sign:
	lda	1,dl
	a9bd	2|0,al		bump pointer over sign
	sbq	1,dl		decrement length
load_fixed_digits:
	cmpq	0,dl
	tze	load_fixed_zero	no digits left
	stq	t1		copy of count
	lda	0,dl		index during loop
load_fixed_scan:
	scm	(),(pr,al)	check each char for a digit
	desc9a	digits,10
	desc9a	2|0,1
	arg	t1+1
	ttn	load_fixed_zero
	ada	1,dl		to next character
	cmpa	t1
	tmi	load_fixed_scan
	dtb	(pr,rl),(pr)	convert to binary
	desc9ns	2|0,ql,0
	desc9a	t1,8
	ldaq	t1
	szn	t2		should it be -?
	tze	*+2		no
	lcaq	t1		use complement
	tra	1,5
load_fixed_zero:
	lda	0,dl
	ldq	0,dl
	tra	1,5
"
"	routine to convert fixed bin in a into 12 digits of octal
"	in aligned storage pointed at by pr2
"
	even			to make rpd odd
octal:	eax6	3-1		init count
	eax1	6		init shifts
	eax2	3
	odd
octal1:	rpd	4,0
	lrl	0,2
	qrl	0,1
	orq	=a0000		make into ascii
	stq	2|0,6		save
	eax6	-1,6
	tpl	octal1
	tra	0,5
"
"	routine to strip leading blanks from string in temp2
"	entered with length of input string in q
"	returns with ptr to first non-blank in pr2 and length in a
"
strip_blanks:
	scmr	(pr,rl),(du)		find number of non-blank characters
	desc9a	temp2,ql
	vfd	o9/blank
	arg	t2
	sbq	t2
	epp2	temp2		get ptr to first non-blank
	a9bd	2|0,ql
	lda	t2		get number of chars to output
	tra	0,5
"
"	move characters to output buffer.
"	called with:
"	 q = length of source
"	 a = length of target (> source indicates pad with blanks)
"	 pr2 -> source

move_to_outbuf:
	szn	movinh		is output inhibited?
	tnz	0,2		yes, just return
	stx2	out_save_x2
	spri2	out_save_pr2
	stz	newline_moved
	staq	move_temp
	sba	move_temp+1	compute amount of padding requested
	tpl	2,ic
	lda	0,dl		none
	sta	move_padding	save for later
	cmpq	0,dl		any source characters?
	tze	move_source_done	no
	lda	out_to_borrow	do we need to borrow any leading spaces?
	tze	move_the_stuff		no
	cmpa	move_temp+1	need to borrow more that source length?
	tmi	2,ic		no
	lda	move_temp+1	just try for source length
	epp3	pl1_operators_$tct_octal_040
	tct	(pr,rl)
	desc9a	2|0,al
	arg	3|0
	arg	tct_result
	ttn	3,ic		source is all blank
	lda	tct_result	get blank count
	ana	=o777777777
	cmpa	0,dl		any leading blanks?
	tze	nothing_to_borrow
	sta	move_temp		amount borrowed
	sbq	move_temp		adjust source length
	a9bd	2|0,al		adjust source pointer
	neg
	asa	out_to_borrow	less to borrow now
	cmpq	0,dl		source exhausted?
	tze	move_source_done	yes
nothing_to_borrow:
	stz	out_to_borrow	tried as hard as possible
move_the_stuff:
	stq	left_to_move
	cmpq	out_left		will source fit in buffer?
	tmi	2,ic		yes
	ldq	out_left		use only what fits
	epp3	out_next,*	get current pointer
	mlr	(pr,rl),(pr,rl)
	desc9a	2|0,ql
	desc9a	3|0,ql
	a9bd	3|0,ql		adjust output pointer
	spri3	out_next
	epp3	2|0		compute adjust input pointer
	a9bd	3|0,ql
	spri3	rest_of_source
	asq	out_moved		accumulate characters moved
	stq	move_temp
	lca	move_temp
	asa	out_left		space left in output buffer
	asa	left_to_move

"	scan output to adjust column position

out_scan:
	cmpq	0,dl		any characters?
	tze	check_more_to_move	no
	tct	(pr,rl)		look for interesting characters
	desc9a	2|0,ql
	arg	out_scan_table
	arg	tct_result
	ttn	out_normal	all regular vanilla characters
	lda	tct_result	get count of plain characters before interesting one
	ana	=o777777777
	asa	out_column	update column position for normal characters
	ada	1,dl		char count including interesting one
	a9bd	2|0,al
	sta	move_temp
	sbq	move_temp		remaining characters to scan
	lda	tct_result
	arl	27		isolate tct result code
	tra	*,al		branch based on character found
	tra	out_newline
	tra	out_backspace
	tra	out_tab

out_newline:
	lda	1,dl		set column back to 1
	sta	out_column
	aos	newline_moved	remember this
	tra	out_scan
out_backspace:
	lca	1,dl		back up one column
	asa	out_column
	tra	out_scan

out_tab:	stq	move_temp
	ldq	out_column	get current column
	adq	9,dl		compute next tab stop
	div	10,dl
	mpy	10,dl
	adq	1,dl
	stq	out_column
	ldq	move_temp
	tra	out_scan

out_normal:
	asq	out_column	regular characters take 1 column each

check_more_to_move:
	szn	entry_switch	switch entry?
	tpl	move_source_done	no
	szn	left_to_move	more stuff?
	tze	move_source_done	no
	tsx2	put_chars_buffer	dump what we have
	ldq	left_to_move
	epp2	rest_of_source,*
	cmpq	out_size		very big string to write?
	tmoz	move_the_stuff	no, routine stuff
	tsx2	put_chars_string	write it all in one iox_ call
	ldqc	left_to_move	length to scan
	tra	out_scan		must scan to keep column accurate
move_source_done:
	szn	out_left		buffer full?
	tnz	check_padding	no
	szn	entry_switch
	tpl	done		not switch entry
	tsx2	put_chars_buffer
check_padding: 
	lda	move_padding	any padding needed at end?
	tze	move_output_return	no
	cmpa	out_to_borrow	see if some of these can be borrowed
	tmi	move_borrows_all	we should steal them all
	sba	out_to_borrow	reduce by needed columns
	stz	out_to_borrow
	tra	move_the_padding
move_borrows_all:
	neg
	asa	out_to_borrow	less to borrow later
	tra	move_output_return
move_the_padding:
	sta	left_to_move
	cmpa	out_left		room to do it all?
	tmi	2,ic		yes
	lda	out_left
	epp3	out_next,*
	mlr	(),(pr,rl),fill(blank)
	desc9a	0,0
	desc9a	3|0,al
	a9bd	3|0,al
	spri3	out_next
	asa	out_column	blanks take one column each
	asa	out_moved
	neg
	asa	out_left
	asa	left_to_move
	tze	move_output_return
	szn	entry_switch	pswitch entry?
	tpl	move_output_return	no
	tsx2	put_chars_buffer
	lda	left_to_move
	tra	move_the_padding
move_output_return:
	szn	out_left		is buffer fill?
	tpnz	move_output_exit	no
	szn	entry_switch	switch entry?
	tpl	done		no
	tsx2	put_chars_buffer
move_output_exit: 
	epp2	out_save_pr2,*
	ldx2	out_save_x2
	tra	0,2		return

	tempd	move_temp,out_save_pr2,rest_of_source
	temp	move_padding,tct_result,save_out_column,newline_moved
	tempd	out_next,put_chars_arglist(5),put_chars_codeptr
	temp	out_column,out_moved,out_left,out_to_borrow,out_size
	temp	out_save_x2,left_to_move
"
"	subroutine to dump and reset the buffer

put_chars_buffer:
	szn	out_moved
	tze	0,2
	epp3	buffptr
put_chars_join:
	spri3	put_chars_arglist+4
	call	put_chars_codeptr,*(put_chars_arglist)
	szn	put_chars_arglist+8,*	error?
	tnz	thru		yes, quit
	stz	out_moved		rest all buffer variables
	epp3	buffptr,*
	spri3	out_next
	ldq	out_size
	stq	out_left
	tra	0,2

"	enter here to write a long string
"	q = length
"	pr2 -> data

put_chars_string:
	stq	out_moved
	spri2	out_next
	epp3	out_next
	tra	put_chars_join
"
"	routine to get ptr to next argument
"
getargptr:
	szn	array_in_progress	are we stepping thru an array?
	tnz	get_next_array	yes
advance_cur_arg:
	ldx6	cur_arg
	adlx6	2,du		update arg counter
	stx6	cur_arg
	cmpx6	num_args		are there any more?
	tmoz	getarg		yes
	aos	no_more_args	no more, say so
	epp2	nullptr,*		set null argp so not same as last time
	spri2	argp
	tra	0,2		and return
getarg:	eppbp	pal,*6		get ptr to arg ptr
	ldx6	dpd		get descriptor offset
	lda	bp|0,6*		get the descriptor
	tmi	ga2		skip if Version 2

"	process version 1 desciriptor

	lrl	18		save length field
	arl	3		isolate type field
	cmpa	=16,dl		convert to Version 2 types
	tmoz	4,ic
	cmpa	=32,dl
	tpl	ga3
	sba	=16,dl
	anq	=o77777,du	erase "decimal" bit
	cmpa	5,dl		is this arithmetic data
	tpl	2,ic		no, skip
	ldq	v1prec-1,al	yes, get normal v1 precision
	tra	ga1
ga3:	cmpa	=514,dl
	tnz	3,ic
	lda	=17,dl
	tra	ga1
	lda	cvtype-518,al
ga1:	als	11		make it look like Version 2
	lls	18

"	process version 2 descriptor

ga2:	cana	=o001700,du	is this an array?
	tnz	begin_array	yes, special processing required
ga5:	eppbp	bp|0,*		get pointer to argument
	spribp	argp		and save
ga4:	lrl	24		save 24 bit length field
	qrl	12
	stq	length
	arl	4		isolate type field
	ana	=o177,dl
	eax7	0,al		and leave in x7
	tra	0,2		all done

"
"	come here to begin the processing or an array. The extents of the array
"	must be detemined and the increment (words or bits) to step thru the array
"	must be found.

begin_array:
	sta	array_desc	save a copy of the descriptor
	spri3	t4		save this pointer so i can use it
	epp3	bp|0,6*		this points to first word of descriptor
	ldq	3|3		get multiplier (may be words or bits)
	stq	array_mult	and save
	stz	array_packed	set switch to un-packed array
	cana	=o002000,du	test for packed array
	tze	2,ic		it is not packed
	aos	array_packed	this means array_mult is bits, not words
	arl	24		get numbers of dims in al
	ana	=o17,dl		just that number
	eax7	0,al		number of dims to x7
	lda	1,dl
	sta	array_length	initialize array length
	sta	array_position	and position
array_calc:
	ldq	3|2		upper bound of this dimension
	sbq	3|1		minus lower dimension
	adq	1,dl		+1 gives number of elements
	mpy	array_length	total length is product of dims
	stq	array_length
	epp3	3|3		step to next desc
	sblx7	1,du		count dimension processed
	tnz	array_calc	loop if more
	epp3	t4,*		restore the pointer
	lda	array_desc	restore origional descriptor
	aos	array_in_progress	now processing an array
	tra	ga5		go setup type and length

"
"	come here to step to next element of an array during array processing

get_next_array:
	lda	array_position	current loc
	ada	1,dl		advance by 1
	cmpa	array_length	check for end
	tmoz	3,ic		not past end
	stz	array_in_progress	done array processing
	tra	advance_cur_arg	go get next arg

	sta	array_position	store updated position
	lda	array_mult	increment to be added to pointer (words or bits)
	eppbp	argp,*		get current pointdr
	szn	array_packed	is this a packed array?
	tnz	3,ic		yes
	eppbp	bp|0,al		do word addition
	tra	2,ic
	abd	bp|0,al		do bit adjustment
	spribp	argp		store adjusted pointer
	lda	array_desc	get origional descriptor
	tra	ga4		go process length and type


"
"	table to convert some Version I descriptor types to Version I types
"
cvtype:	dec	18,19,21,20,22,17,18,19,21,20,22
"
"	normal precisions for v1 data
"
v1prec:	dec	35b17,71b17,27b17,63b17
"
"	routine to get ptr to and length of string in arg list
"	x2 points at table of either char types or bit types
"	return 0,3 if not bit|char and return 1,3 if ok
"
fillin:	ldq	length		get length
	epp2	argp,*		get ptr to argument
	eaa	0,7		copy type codes
	ana	=o777776,du	erase packed bit
	tze	1,3		allow 0 type because of pl1 bug in returns(char(*))
	cmpa	0,2		is it varying
	tze	fill_varying	yes, skip
	cmpa	1,2		is this non-varying
	tze	1,3		yes, return
	tra	0,3		no, error
fill_varying:
"				the Q now holds the declared max length
	cmpq	bp|-1		if the current length is greater than the max
	tmi	1,3		then return the max length
	ldq	bp|-1		otherwise pick up the current length
	tpl	1,3		check for garbage (negative number). return if ok
	ldq	length		use max length. negative number causes blowups
	tra	1,3		return
"
cstype:	vfd	17/varying_char_dtype  char varying
	vfd	17/char_dtype	char non-varying
"
bstype:	vfd	17/varying_bit_dtype  bit varying
	vfd	17/bit_dtype	bit non-varying

"	test arg for numeric. skip return if it is

test_numeric: 
	eaa	0,7		get arg type in a
	ars	18+1		align and drop packed bit
	sba	1,dl		bit offsets start at 0
	cmpb	(al),(),fill(0)	test for numeric argument
	descb	numeric_dtype_mask,1
	descb	0,0
	tnz	1,3		it is numeric
	tra	0,3		it isn't
"
"	subroutine to get size from control field
"	entered with	pr2 & x0 pointing at next char of input
"		 	remaining number of chars in input in a
"			x4 = 0 | 1
"	this routine transfers to bad_field if string ends early
"	or if arg is not available for variable size specification
"
getsize:	cmpc	(pr,x0),(),fill(v)	is this "v"
	desc9a	2|0,1
	vfd	36/0
	tze	varsize		yes, size given by variable in arglist
"
"	not variable, look for string of digits
"
	eax1	0		init digit count
	eax2	0,0		remember where string starts
nextdigit:
	scm	(),(pr,x0)	is this character a digit
	desc9a	digits,10
	desc9a	2|0,1
	arg	t1
	ttn	getsize1		not a digit, skip
	adx1	1,du		bump digit count
	adx0	1,du		account for the digit
	sba	1,dl
	tze	bad_field
	tra	nextdigit		look for another digit
"
bit_alpha:
digits:	aci	"0123456789ABCDEF"
"
"	have string of 0 or more digits
"
getsize1:	cmpx1	0,du		do we have any digits
	tze	0,5		no, return
	stc1	sizesp,4		yes, remember size specified
	dtb	(pr,rl,x2),(pr)	convert digits to binary
	desc9ns	2|0,x1,0
	desc9a	t1,4
	ldq	t1		store size
	stq	size,4
	tra	0,5		and return
"
"	size is given by variable
"
varsize:	szn	movinh		is output inhibited by ^0(?
	tze	varsize1		no
	aos	v_not_done	set flag to remember this
	tra	varsize2

varsize1:	szn	no_more_args	error if no arg to be used
	tnz	bad_field
	stc1	sizesp,4		remember size specified
	spri2	work		save some stuff during calls which follow
	sta	work+2
	stx5	work+3
	tsx5	load_fixed_bin	get value of arg
	tra	bad_field		not numeric
	lrs	0		test for negative
	tpl	2,ic		"normalize" it
	lrl	72
	qrs	0
	tpl	2,ic
	ldq	0,dl
	stq	size,4		save size for caller
	tsx2	getargptr		step to next arg
	ldx5	work+3		restore saved stuff
	lda	work+2
	epp2	work,*
varsize2:	adx0	1,du		account for the v
	sba	1,dl
	tra	0,5		and return
"

out_scan_table:
	oct	000000000000,000000000000	000 - 007
	oct	002003001001,001001000000	010 - 017
	dup	124			020 - 777
	oct	0
	dupend
"
"	table to convert ascii to gebcd
"
ascii_to_gebcd:
	oct	020020020020,020020020020 	000
	oct	020020020020,020020020020 	010
	oct	020020020020,020020020020 	020
	oct	020020020020,020020020020 	030
	oct	020020076013,053074032057 	040
	oct	035055054060,073052033061 	050
	oct	000001002003,004005006007 	060
	oct	010011015056,036075016020 	070
	oct	014021022023,024025026027 	100
	oct	030031041042,043044045046 	110
	oct	047050051062,063064065066 	120
	oct	067070071012,037034020052 	130
	oct	037021022023,024025026027 	140
	oct	030031041042,043044045046 	150
	oct	047050051062,063064065066 	160
	oct	067070071020,040020020020 	170
"
"	edit sequences
"
int_edit:	vfd	9/lte+3,9/blank,9/mfls,9/mfls,9/mfls,9/mfls
"
oct_edit6:
	vfd	9/mvzb+5,9/mvc+1
"
oct_edit24:
	vfd	9/mvzb,9/mvzb+7,9/mvc+1
"
float_edit:
	vfd	9/lte+3,9/blank,9/mfls+1,9/insb+7,9/mvc,9/mvc,9/mvc,9/mvc
"
exp_edit:	vfd	9/lte+3,9/blank,9/mfls+9,9/enf,9/mvc+1
	end
