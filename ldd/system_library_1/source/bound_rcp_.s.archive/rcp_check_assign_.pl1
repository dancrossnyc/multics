/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


/* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
rcp_check_assign_:
     procedure (arg_rcp_id, arg_device_info_ptr, arg_comment, arg_statex, arg_ecode);

/*	This program implements the rcp_$check_assign entry point.
   *	Created on 12/04/74 by Bill Silver.
   *
   *	The rcp_id is used to generate a pointer to the RCS entry that is associated
   *	with this assignment request.  We will look in this RCS entry to obtain
   *	the information that describes the results of the assignment operation.
   *	In the current implementation the assignment is actually performed by the
   *	assign call.  If everything in the RCS entry is OK we will declare the
   *	assignment to be completed and will return the device information to
   *	the caller.
*/

/*		ARGUMENT  DATA		*/

dcl	arg_comment	   char (*);		/* (O) RCP comment. */
dcl	arg_device_info_ptr	   ptr;			/* (I) Pointer to device info structure. */
dcl	arg_ecode		   fixed bin (35);		/* (O) Return error_table_ code. */
dcl	arg_rcp_id	   bit (36) aligned;	/* (I) RCP ID. */
dcl	arg_statex	   fixed bin;		/* (O) State of assignment check. */


/*		AUTOMATIC  DATA		*/

dcl	caller_level	   fixed bin;		/* Caller's validation level. */
dcl	dcode		   fixed bin (35);		/* Dummy error code. */
dcl	ecode		   fixed bin (35);		/* error_table_ code. */
dcl	rcp_id		   bit (36) aligned;	/* Used to copy rcp_id argument. */
dcl	save_ecode	   fixed bin (35);		/* Dummy error code. */


/*		EXTERNAL ENTRIES CALLED	*/

dcl	cleanup		   condition;		/* Used to set up a cleanup handler. */

dcl	(
	error_table_$bad_arg,
	error_table_$invalid_state,
	error_table_$out_of_sequence
	)		   fixed bin (35) external;

dcl	clock_		   entry returns (fixed bin (71));
dcl	cu_$level_get	   entry (fixed bin);
dcl	cu_$level_set	   entry (fixed bin);
dcl	get_ring_		   entry returns (fixed bin);
dcl	rcp_comment_	   entry (ptr);
dcl	rcp_device_info_$set   entry (ptr, ptr, fixed bin (35));
dcl	rcp_unassign_$unassign entry (bit (36) aligned, bit (*), char (*), fixed bin (35));
dcl	rcp_validate_	   entry (bit (36) aligned, fixed bin, ptr, fixed bin (35));

	call cu_$level_get (caller_level);		/* Save caller's validation level. */
	on cleanup
	     begin;				/* If trouble cleanup. */
	     call cu_$level_set (caller_level);		/* Reset validation level. */
	end;
	call cu_$level_set (get_ring_ ());		/* Set validation level to RCP level. */

	rcp_id = arg_rcp_id;			/* Copy arguments. */
	device_info_ptr = arg_device_info_ptr;
	call rcp_validate_ (rcp_id, caller_level, rcse_ptr, ecode);
	if ecode ^= 0				/* Is RCP ID OK? */
	     then
	     goto ERROR;				/* No, rcse_ptr is not valid. */

	if rcse.kind ^= 2				/* Is this a device assignment RCS entry? */
	then do;					/* No, leave attachment alone. */
	     ecode = error_table_$bad_arg;
	     goto ERROR;
	end;

	ecode = rcse.ecode;				/* Get code generated by rcp_initializer_. */
	if ecode ^= 0				/* Was there an error assigning the device? */
	     then
	     goto ERROR;

	if rcse.state ^= 2				/* We should be in the ASSIGNED state. */
	then do;					/* But we are not. */
	     ecode = error_table_$invalid_state;
	     goto ERROR;
	end;

/*	Return the information about the assigned device in the info structure.
*/
/**** Passing a copy of device_info_ptr is OK since the pointer is used to base
      a write-only structure, so nothing the caller is doing can throw us. ****/
	call rcp_device_info_$set (device_info_ptr, rcse_ptr, ecode);
	if ecode ^= 0				/* Is device info structure valid? */
	     then
	     goto ERROR;				/* Abort assignment. */

	call rcp_comment_ (rcse_ptr);			/* Type caller's comment. */

	rcse.state = 5;				/* Assignment now complete. */
	rcse.state_time = clock_ ();

	arg_comment = "";				/* No comments returned by this version of RCP. */
	arg_statex,				/* Tell caller that assignment completed OK. */
	     arg_ecode = 0;
	call cu_$level_set (caller_level);		/* Reset caller's validation level. */
	return;

ERROR:						/* Abort assignment. */
	call rcp_unassign_$unassign (rcp_id, "0"b, "", dcode);
	arg_statex = 3;				/* Tell caller there was an error. */
	arg_ecode = ecode;				/* Return error code. */
	call cu_$level_set (caller_level);		/* Reset validation level. */

%include rcp_com_seg;
%page;
%include rcp_device_info_structs;

     end rcp_check_assign_;
