/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(85-09-11,Fawcett), approve(85-09-11,MCR6979),
     audit(85-12-02,CLJones), install(86-03-21,MR12.0-1033):
     Add support for FIPS
     and IMU
  2) change(86-08-07,Farley), approve(86-08-07,MCR7448),
     audit(86-10-20,Beattie), install(86-10-28,MR12.0-1200):
     Changed DELETE_DEVICE to unload the device BEFORE deleting it. Changed
     TEST_DEVICE to set priv_gate_call to OFF, even when called through
     rcp_priv_. Changed ASSIGN to properly unassign the volume when the device
     assignment fails.
  3) change(87-01-27,Farley), approve(87-04-06,MCR7650),
     audit(87-04-15,Dickson), install(87-04-28,MR12.1-1028):
     Changed to reset device.flags.attached before unloading the volume from
     the device.  This is required when the device is still assigned.
  4) change(87-06-25,Rauschelbach), approve(87-06-29,MCR7736),
     audit(87-07-21,Farley), install(87-08-06,MR12.1-1063):
     The error error_table_$resource_unknown was replaced with a new error code
     error_table_$no_appropriate_device for the instance of mismatched device
     and volume attributes.
                                                   END HISTORY COMMENTS */

/* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
rcp_control_:
     procedure (a_operation, a_volume_offset, a_device_offset, a_device_name, a_error_count, a_process_id, a_ecode);

/*	This program is an internal interface of RCP.
   *	Created on 11/27/74 by Bill Silver
   *
   *      This routine performs the following functions:
   *	     1.	Assign a device and/or volume.
   *	     2.	Update the error count for the specified device.
   *	     3.	Unassign a device and/or volume.
   *	     4.	Forcedly unassign a device.
   *	     5.	Unassign all resources of specified process.
   *	     6.   Delete a device.
   *	     7.	Add a device.
*/
/*	Tape survey when adding drive by C. Hornig, September 1982.
   *      Modified 12/8/83 by B. Braun to correct all device requests being denined (phx12105).
   *	Modified 1/84 by Chris Jones to tell IOI what we've done about adding or deleting a device.
   *	Modified 840521 for console addition / deletion... -E. A. Ranzenbach
   *      Modified 841004 to change the name to rcp_control, to allow the
   *       routine to accept arguments instead of a 72-bit message, and
   *       perform some general cleanup...- M. M. Pozzo
   *      Modified 850131 to interface with the new rcp_access_kernel_ for the
   *       B2 effort...-M. M. Pozzo
   *      Modified 1985-03-08, BIM: check console state.
   *      Modified 1985-03-14, BIM: cleanup journals, translate "record not found" into "no such resource".
   *	Modified 03/18/85 by Chris Jones to not delete devices until after their volumes are unloaded.
   *	Modified 1985-04-3 by Paul Farley & Fawcett to add FIPS support and
   *		             add no_protect and opr_int_available code
   *      Modified 1985-04-11, BIM&MMP: Don't zero error code before testing it in TEST_DEVICE.
   *               Also audit mounts of volumes.
   *      Modified 1985-04-12, BIM: ioi delete device at unassign time
   *	   that was added at assign time due to use of rcp_priv_ to assign
   *	   a deleted device.
*/
%page;
/*		ARGUMENT  DATA		*/

dcl	a_operation	   bit (36) aligned;	/* Specifies the type of operation being requested */
dcl	a_volume_offset	   bit (18) aligned;	/* Offset to volume information */
dcl	a_device_offset	   bit (18) aligned;	/* Offset to device information */
dcl	a_device_name	   char (*);		/* Drive name */
dcl	a_error_count	   fixed bin (17);		/* Error count for device attachments */
dcl	a_process_id	   bit (36) aligned;	/* Process id for which this operation is being performed */
dcl	a_ecode		   fixed bin (35);		/* Error code */


dcl	a_add_sw		   bit (1) aligned;		/* For $ss_io_interchange, "1"b = add to RCP */
dcl	a_del_sw		   bit (1) aligned;		/* For $ss_io_interchange, "1"b to 'add' in deleted state */


/*		AUTOMATIC  DATA		*/


dcl	access		   bit (3) aligned;		/* User's access to resource. */
dcl	effmode		   bit (3);
dcl	accessible_flag	   bit (1) aligned;		/* ON => process has access to a segment. */
dcl	add_sw		   bit (1) aligned;		/* For $ss_io_interchange, "1"b => add to RCP. */
dcl	available_flag	   bit (1) aligned;		/* ON => device is available. */
dcl	console_free	   bit (1) aligned;		/* flag indicating that the ocdcm_ willlet us have the console. */
dcl	del_sw		   bit (1) aligned;		/* For $ss_io_interchange, "1"b to 'add' in deleted state */
dcl	full		   bit (1) aligned;		/* "1"b if available_list array is full */
dcl	match_flag	   bit (1) aligned;		/* ON => device matches. */
dcl	system_flag	   bit (1) aligned;		/* ON => process is a system process. */
dcl	volume_flag	   bit (1) aligned;		/* ON => we have assigned a volume. */
dcl	temp_mode		   bit (3);
dcl	dev_rcse_off	   bit (18) aligned;	/* Offset of RCS device entry. */
dcl	device_off	   bit (18) aligned;	/* Offset of RCPD device entry. */
dcl	vol_rcse_off	   bit (18) aligned;	/* Offset of RCS volume entry. */
dcl	volume_off	   bit (18) aligned;	/* Offset of RCPD volume entry. */
dcl	process_id	   bit (36) aligned;	/* Process ID. */

dcl	operation		   bit (36) aligned;	/* Operation.   */
dcl	base_op		   bit (36) aligned;	/* the basic operation */
dcl	device_name	   char (32);		/* Device name. */
dcl	volume_name	   char (32);		/* Volume name. */
dcl	who_am_i		   char (32);		/* Identifies this program. */

dcl	dtypex		   fixed bin;		/* Device type index. */
dcl	ecode		   fixed bin (35);		/* error_table_ code. */
dcl	error_count	   fixed bin (17);		/* error count for device attachments */
dcl	num_assigned	   fixed bin;		/* Number of devices assigned to a process. */
dcl	num_avail_nres	   fixed bin;		/* Number of non reservable devices available. */
dcl	num_available	   fixed bin;		/* Number of devices available for assignment. */
dcl	num_free_res	   fixed bin;		/* Number of reservable devices currently free. */
dcl	num_reserved	   fixed bin;		/* Number of devices reserved to system processes. */
dcl	num_resvd		   fixed bin;		/* Number of device reserved for this process. */
dcl	one_was_accessible	   bit (1) aligned;		/* at least one was accessible */
dcl	one_was_appropriate	   bit (1) aligned;		/* at least one was appropriate (but perhaps inaccessible or unavailable) */
/**** there is no one_was_available, since available is conditional on the other two PLUS resource limits. */
dcl	time_assigned	   fixed bin (71);		/* Used to compute metering data. */

dcl	record_ptr	   ptr;			/* Pointer to the registry resource record. */
dcl	reg_iocb_ptr	   ptr;			/* IOCB for the registry. */
dcl	save_device_ptr	   ptr;			/* Used to save pointer to assigned device. */
dcl	trans_iocb_ptr	   ptr;			/* IOCB for the transaction control file. */
dcl	available_list	   (MAX_AVAILABLE) ptr;	/* List of appropriate, accessible, and available devices. */
dcl	1 req_info	   like requestor_info automatic;
						/* Requestor information for determining RCP access */
dcl	1 res_info	   like resource_info automatic;
						/* Resource information for determining RCP access */

/*		CONSTANTS			*/


dcl	MAX_AVAILABLE	   fixed bin (17) static internal options (constant) init (128);
dcl	DEFAULT_REGISTRY_DIR   char (64) static internal options (constant) init (">sc1>rcp");

/*		CONDITIONS		*/


dcl	cleanup		   condition;		/* Used to establish a cleanup handler. */


/*		BUILTIN FUNCTIONS		*/


dcl	(addr, clock, divide, hbound, length, null, ptr, rel, string, substr, unspec)
			   builtin;


/*		ERROR CODES		*/


dcl	error_table_$no_key	   fixed bin (35) ext static;
dcl	error_table_$resource_unassigned
			   fixed bin (35) ext;
dcl	error_table_$device_deletion_deferred
			   fixed bin (35) ext;
dcl	error_table_$device_limit_exceeded
			   fixed bin (35) ext;
dcl	error_table_$invalid_state
			   fixed bin (35) ext;
dcl	error_table_$io_still_assnd
			   fixed bin (35) ext;
dcl	error_table_$notalloc  fixed bin (35) ext;
dcl	error_table_$resource_bad_access
			   fixed bin (35) ext;
dcl	error_table_$resource_unavailable
			   fixed bin (35) ext;
dcl	error_table_$resource_unknown
			   fixed bin (35) ext;
dcl       error_table_$no_appropriate_device
                                 fixed bin (35) ext;
dcl	error_table_$unsupported_operation
			   fixed bin (35) ext;

dcl	access_operations_$rcp_assign_read
			   bit (36) aligned ext static;
dcl	access_operations_$rcp_assign_write
			   bit (36) aligned ext static;
dcl	access_operations_$rcp_add_device
			   bit (36) aligned ext static;
dcl	access_operations_$rcp_delete_device
			   bit (36) aligned ext static;
dcl	access_operations_$rcp_error_count
			   bit (36) aligned ext static;
dcl	access_operations_$rcp_account
			   bit (36) aligned ext static;
dcl	access_operations_$rcp_unassign
			   bit (36) aligned ext static;

/*		EXTERNAL ENTRIES CALLED	*/


dcl	admin_gate_$console_free
			   entry (char (4) aligned, bit (1) aligned);
dcl	admin_gate_$ocdcm_reconfigure
			   entry (char (4) aligned, fixed bin, fixed bin (35));
dcl	admin_gate_$ioi_add_device
			   entry (char (*), fixed bin (35));
dcl	admin_gate_$ioi_delete_device
			   entry (char (*), fixed bin (35));
dcl	admin_gate_$syserr	   entry options (variable);
dcl	get_group_id_	   entry () returns (char (32));
dcl	get_process_id_	   entry returns (bit (36));
dcl	hcs_$wakeup	   entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
dcl	rcp_access_kernel_	   entry (bit (36) aligned, ptr, ptr, bit (3), fixed bin (35));
dcl	rcp_lock_$lock	   entry (ptr, fixed bin (35));
dcl	rcp_lock_$unlock	   entry (ptr);
dcl	rcp_match_$match	   entry (ptr, ptr) returns (bit (1));
dcl	rcp_match_$select	   entry (ptr, fixed bin, char (*) aligned, ptr);
dcl	rcp_match_user_name_   entry (char (32) aligned, char (32) aligned) returns (bit (1));
dcl	rcp_pointers_$com_seg  entry returns (ptr);
dcl	rcp_pointers_$data	   entry returns (ptr);
dcl	rcp_tape_survey_	   entry (char (*), fixed bin, bit (1) aligned, bit (1) aligned, (4) fixed bin (35),
			   fixed bin (35));
dcl	rcp_unload_$unload_device
			   entry (ptr, bit (1));
dcl	get_authorization_	   entry () returns (bit (72) aligned);
dcl	hcs_$get_authorization entry (bit (72) aligned, bit (72) aligned);
dcl	rcp_get_scratch_volume_
			   entry (ptr, char (*), bit (3) aligned, fixed bin (35));
dcl	rcp_cancel_resource_   entry (char (*), char (*), fixed bin (35));
%page;
/*        This routine has two entry points.  rcp_control_$ss_io_interchange is called by mdx.pl1.  The main entry point will determine what functions to perform from the operation argument.  RCPD will be locked while it is being manipulated. */

/**** NOTES
      device.unassign_state, device.delete, device.priv:

      These three variables overlap. device.unassign_state should always
      be the correct value for device.state after the completion of unassign.
      However, if device.delete is on, then the device must be marked
      DELETED at unassign. However, unassign_state is not changed
      when a deletion is requested for an assigned or reserved device,
      so that if the device is added back before it is unassigned
      things will work correctly.

      If device.priv is on, then unassign_state
      = DELETED implies that the device was deleted to begin with and assigned
      with rcp_priv_, rather than deleted by the operator during the
      assignment. The only implication of this is that unloads are not
      attempted at unassignment. */

	operation = a_operation;			/* Copy args */
	base_op = basic_operation (operation);
	ops_ptr = addr (addr (operation) -> encoded_access_op.detailed_operation);
	error_count = a_error_count;

	who_am_i = "rcp_control_";
	rcpd_ptr = rcp_pointers_$data ();		/* Set up pointers. */
	rcs_ptr = rcp_pointers_$com_seg ();
	reg_iocb_ptr, trans_iocb_ptr = null ();
	ecode = 0;

	on cleanup
	     begin;
	     call cleanup_kernel_call ((0));
	     call UNLOCK;				/* If trouble unlock rcp_data. */
	end;

	call rcp_lock_$lock (addr (rcpd.lock_info), ecode);
	if ecode ^= 0 then do;
	     a_ecode = ecode;
	     return;
	end;

	if (base_op = access_operations_$rcp_assign_read) | (base_op = access_operations_$rcp_assign_write) then
	     call ASSIGN;
	else if base_op = access_operations_$rcp_error_count then
	     call ERROR_COUNT;
	else if base_op = access_operations_$rcp_unassign then
	     call UNASSIGN;
	else if base_op = access_operations_$rcp_delete_device then
	     call DELETE_DEVICE;
	else if base_op = access_operations_$rcp_add_device then
	     call ADD_DEVICE;
	else if base_op = access_operations_$rcp_account then
	     call ACCOUNT_ATTACH;
	else ecode = error_table_$unsupported_operation;

	call UNLOCK;
	a_ecode = ecode;

	return;
%page;
UNLOCK:
     procedure;					/* Unlock RCPD. */
	call rcp_lock_$unlock (addr (rcpd.lock_info));
     end UNLOCK;
%page;
ASSIGN:
     procedure;

/*	This procedure is called to perform an assignment of a device
   and/or volume.
   The offsets provided as input determine what is to be assigned.
   These offsets reference RCS entries.  We will communicate the
   results of the assignment(s) by filling in these entries.
*/

	vol_rcse_off = a_volume_offset;		/* Copy args */
	dev_rcse_off = a_device_offset;

	volume_flag = "0"b;				/* Assume no volume assigned. */

	if vol_rcse_off ^= "0"b			/* Do we have to assign a volume? */
	then do;					/* Yes. */
	     call ASSIGN_VOLUME;			/* Assign one volume to this process. */
	     rcse.ecode = ecode;			/* Tell results of volume assignment. */
	     if ecode ^= 0				/* Any problems with volume? */
		then
		return;				/* Yes, abort all assignments. */
	end;

	if dev_rcse_off ^= "0"b			/* Do we have a device to assign? */
	then do;					/* Yes. */
	     base_op = access_operations_$rcp_assign_write;
						/* Always assign a device for writing. */
	     call ASSIGN_DEVICE;			/* Assign an appropriate device. */
	     rcse.ecode = ecode;			/* Tell results of device assignment. */
	end;

	if ^volume_flag				/* Device assignment done.  Was there a volume? */
	     then
	     return;				/* No, nothing else to do. */

	if ecode ^= 0				/* Was there an error assigning device? */
	then do;					/* Yes. */
	     call UNASSIGN_VOLUME ();
	     return;
	end;

	if dev_rcse_off = "0"b			/* Was a device just assigned? */
	then do;					/* No, put volume on previously assigned device. */
	     rcse_ptr = ptr (rcs_ptr, vol_rcse_off);	/* Attachment RCS entry. */
	     rcse_ptr = ptr (rcs_ptr, rcse.rcse_off);	/* Assignment RCS entry. */
	     device_ptr = ptr (rcpd_ptr, rcse.device_off);
	     dtypex = device.dtypex;			/* Get device type of this device. */
	     dtype_ptr = addr (rcpd.dtype (dtypex));
	end;

	if device.volume_name = volume_name		/* Is volume already on this device? */
	then do;					/* Yes, nothing more to do. */
	     rcse.volume_name = volume_name;		/* ASSIGNment RCSE */
	     return;
	end;

	if volume_name = "scratch"			/* Is this a scratch volume. */
	then do;					/* Yes, special case. */
	     device.volume_name = " ";		/* Scratch volumes not remembered. */
	     return;
	end;

/*	The assigned volume is being put on a new device.  We must search through
   *	all of the devices of this type to see if it is currently on any other
   *	device.  If it is we will remove it from that device.
*/
	save_device_ptr = device_ptr;			/* Save pointer to assigned device. */
	device_off = dtype.first_off;			/* Get first device of this type. */
	do while (device_off ^= "0"b);		/* Test all devices of this type. */
	     device_ptr = ptr (rcpd_ptr, device_off);
	     if device.volume_name = volume_name then do; /* We found the volume on another device. */
		device.flags.attached = "0"b;		/* Mark it as _n_o_t attached. */
		call rcp_unload_$unload_device (device_ptr, "0"b);
						/* unload the volume */
		device.volume_name = "";		/* Forget this occurance. */
		goto REMEMBER_DEVICE;		/* No need to test any more devices. */
	     end;
	     device_off = device.next_off;		/* Test next device. */
	end;

REMEMBER_DEVICE:					/* Put volume on assigned device. */
	save_device_ptr -> device.volume_name = volume_name;

     end ASSIGN;
%page;
/*	This procedure is called to assign a volume.  The assignment of a volume
   *	is independent of the assignment of a device.  A list of the currently
   *	assigned volumes is kept in RCPD.
*/


ASSIGN_VOLUME:
     procedure;

dcl	i		   fixed bin;
dcl	ignored_code	   fixed bin (35);

	rcse_ptr = ptr (rcs_ptr, vol_rcse_off);		/* Get pointer to RCS entry that => volume. */
	access = "000"b;
	if rcse.volume_name ^= "scratch" then
	     volume_name = rcse.volume_name;
	else do;
	     call rcp_get_scratch_volume_ (rcse_ptr, volume_name, access, ecode);
	     if ecode ^= 0 then
		return;
	     rcse.volume_name = volume_name;
	end;
	volume_off = "0"b;				/* Initialize volume offset. */

	do i = 1 to rcpd.last_volume;			/* Search through list of volumes. */
	     volume_ptr = addr (rcpd.volume (i));	/* Get pointer to volume entry. */
	     if volume.volume_name = volume_name then do;
		if (volume.state = FREE) | ((volume.state = RESERVED) & (volume.process_id = rcse.process_id)) then
		     volume_off = rel (volume_ptr);
		else if volume_name ^= "" then do;
		     ecode = error_table_$resource_unavailable;
		     return;
		end;
	     end;
	     else if (volume.state = FREE) & (volume.volume_name = "") then
						/* If this is a free entry in the table ... */
		if volume_off = "0"b then		/* ... and we don't have a slot to use yet ... */
		     volume_off = rel (volume_ptr);	/* ... then remember this one for later. */
	end;

	if volume_off = "0"b			/* Volume not found, room for another? */
	     then
	     if rcpd.last_volume >= rcpd.tot_volumes then do;
						/* No room. */
		ecode = error_table_$notalloc;
		return;
	     end;
	     else do;				/* Get a new entry. */
		rcpd.last_volume = rcpd.last_volume + 1;
		volume_off = rel (addr (rcpd.volume (rcpd.last_volume)));
	     end;

/*	Now we must make sure we have access to the volume requested.
*/
	if access = "000"b then do;			/* Don't know yet. */
	     call setup_kernel_call ((VOLUME_TYPE (rcse.dtypex)), rcse.volume_name, ecode);
	     if ecode ^= 0 then
		return;
	     call rcp_access_kernel_ (operation, addr (req_info), addr (res_info), effmode, ecode);
	     if ecode ^= 0 then
		if (ecode = error_table_$resource_unknown) & (rcpd.modes.auto_registration) then do;
		     rcse.flags.must_auto_register = "1"b;
		     access = REW_ACCESS;
		     ecode = 0;
		     call cleanup_kernel_call (ignored_code);
		end;
		else do;
		     call cleanup_kernel_call (ignored_code);
		     return;
		end;
	     else do;
		access = effmode;
		call cleanup_kernel_call (ignored_code);
	     end;
	end;


/*	Assign volume by filling in the free volume entry that we have found.
*/
	volume_ptr = ptr (rcpd_ptr, volume_off);	/* Get pointer to assigned volume entry. */
	volume.process_id = rcse.process_id;		/* Assign volume entry to process. */
	volume.vtypex = rcse.dtypex;
	volume.unassign_state = volume.state;
	volume.state = ASSIGNED;			/* Make it assigned. */
	volume.state_time = clock ();
	volume.volume_name = volume_name;
	volume.group_id = rcse.group_id;
	if volume.unassign_state = FREE then do;	/* if this was free ... */
	     volume.reserved_by = "";			/* no reservation */
	     volume.reservation_id = 0;
	end;
	volume.current_authorization = get_authorization_ ();
						/* Save this guy's authorization. */

	volume_name = rcse.volume_name;		/* Leave the real volume name here. */
	volume_flag = "1"b;				/* ON => a volume has been assigned. */
	rcse.state = 2;				/* State => volume now assigned. */
	rcse.volume_off = volume_off;			/* Save offset of volume entry. */

     end ASSIGN_VOLUME;
%page;
ASSIGN_DEVICE:
     procedure;

dcl	ignored_code	   fixed bin (35);
dcl	(i, j)		   fixed bin;

/*	This procedure is called to assign a device.  The following tests
   *	are made before assigning a device:
   *	     1.	There must be an appropriate device.
   *	     2.	The requesting process must have access to the device.
   *	     3.  	There must be an appropriate and accessible device that is available.
   *	     4.	The device limits must not be exceeded.
   *	     5.	If the assignment is based on a volume then we will try to
   *		find a device that has the specified volume already mounted.
   *	     6.	Otherwise we take the device that has been unassigned the longest.
*/
	rcse_ptr = ptr (rcs_ptr, dev_rcse_off);		/* Get pointer to RCS entry for device. */
	dtypex = rcse.dtypex;			/* Get device type index. */
	dtype_ptr = addr (rcpd.dtype (dtypex));		/* Get pointer to device type entry. */
	system_flag = rcse.flags.system;		/* Get system flag. */
	if rcse.group_id = "Initializer.SysDaemon.z" & rcse.caller_level = 1 then
	     system_flag = "1"b;

	num_assigned,				/* Initialize counters. */
	     num_free_res, num_reserved, num_resvd = 0;
	one_was_accessible, one_was_appropriate = "0"b;
	num_available = 0;

	device_off = dtype.first_off;			/* Start with first type of device. */
	full = "0"b;				/* available_list array is empty. */
	do while ((device_off ^= "0"b) & (^full));	/* Test all devices of this type until the available_list array is full. */
	     device_ptr = ptr (rcpd_ptr, device_off);	/* Get pointer to RCPD device entry. */
	     call TEST_DEVICE;			/* Test device to see if it can be assigned. */
	     device_off = device.next_off;		/* Get offset of next device of this type. */
	end;

	if num_available = 0			/* none to return */
	then do;					/* select the error code */
	     if ^one_was_appropriate then
		ecode = error_table_$no_appropriate_device;
	     else if ^one_was_accessible then
		ecode = error_table_$resource_bad_access;
	     else ecode = error_table_$resource_unavailable;
						/* there was one that we would have access too, but we couldn't have it */
	     return;
	end;

	call CHECK_LIMITS;				/* Check device limits. */
	if ecode ^= 0 then
	     return;				/* Find the best device that matched. */
	if num_resvd > 0 then do;
	     j = 0;
	     do i = 1 to num_available;
		if available_list (i) -> device.state = RESERVED then do;
		     j = j + 1;
		     if i ^= j then
			available_list (j) = available_list (i);
		end;
	     end;
	     num_available = j;
	end;

	call rcp_match_$select (addr (available_list), num_available, rcse.volume_name, device_ptr);
	device_off = rel (device_ptr);		/* Save offset of device entry. */

/* When searching for any device, auditing is done after selection. */
/* Call the kernel to perform the auditing since it has all the */
/* information needed to do it.  */

	if (^rcse.flags.device & rcpd.modes.resource_mgmt_enabled) then do;
	     detailed_operation.search = "0"b;
	     call setup_kernel_call ((DEVICE_TYPE (device.dtypex)), device.device_name, ecode);
	     temp_mode = ""b;
	     call rcp_access_kernel_ (operation, addr (req_info), addr (res_info), temp_mode, ecode);
	     call cleanup_kernel_call (ecode);		/* the above call was just to provoke an audit, so we can discard the error code. */
	end;

	rcse.flags.volume = "0"b;
	if device.volume_name ^= "" then do;		/* then let him know it. */
	     if rcpd.modes.resource_mgmt_enabled then do;
		call setup_kernel_call ((VOLUME_TYPE (device.dtypex)), device.volume_name, ecode);
		if ecode = 0 then do;
		     detailed_operation.search = "1"b;	/* Don't audit this since a denial is unimportant. */
		     call rcp_access_kernel_ (operation, addr (req_info), addr (res_info), effmode, ecode);
		     detailed_operation.search = "0"b;
		     if ecode = 0 then do;
			rcse.flags.volume = "1"b;
			rcse.volume_name = device.volume_name;
		     end;
		     else ecode = 0;
		end;
		else ecode = 0;			/* no such volume? ignore the problem, and just hand over the requested device. ycch. */
		call cleanup_kernel_call (ecode);
	     end;
	     else if rcp_match_user_name_ (rcse.group_id, device.group_id) then do;
		rcse.flags.volume = "1"b;
		rcse.volume_name = device.volume_name;
	     end;
	end;

	if ^rcse.flags.volume then
	     rcse.volume_name = "";
	rcse.flags.preload_allowed = ^rcpd.modes.unload_on_detach;
	rcse.flags.not_removable_media = device.flags.not_removable_media;

	device.process_id = rcse.process_id;		/* Save info about assignment. */
	device.group_id = rcse.group_id;
	if device.flags.reservable			/* Can device be reserved? */
	     then
	     device.flags.reserved = system_flag;
	else device.flags.reserved = "0"b;
	if device.state = DELETED			/* Are we assigning a deleted device? */
	then do;					/* Yes. */
	     call admin_gate_$ioi_add_device ((device.device_name), ignored_code);
	     device.flags.delete,			/* Remember to delete when unassigned. */
		device.flags.priv = "1"b;		/* Special assignment for privileged attachment. */
	end;
	device.state_time = clock ();			/* Note when assigned. */
	device.unassign_state = device.state;		/* redundant for DELETED, since flags.delete forces unassignment to delete */
						/* the curious result of this is that if the operator  */
						/* during the .priv attachment it will fail. */
	device.current_authorization = get_authorization_ ();
						/* Save this guy's authorization. */
	device.state = ASSIGNED;			/* Device is now assigned. */

	if device.unassign_state ^= RESERVED then	/* Accounting for reserved devices is done at reservation time. */
	     call ACCOUNT_WAKEUP (device_ptr, RCP_ACCTMSG_assign);

	rcse.state = 2;				/* Tell requesting process assignment complete. */
	rcse.device_off = device_off;			/* Save offset of rcp_data entry. */
	rcse.device_name = device.device_name;		/* Return info about assigned device. */
	rcse.model = device.model;
	do i = 1 to device.num_qualifiers;
	     rcse.qualifiers (i) = device.qualifiers (i);
	end;
	rcse.flags.system = system_flag;		/* Note whether assigned as a system process. */
	rcse.flags.fips = device.flags.fips;		/* pass along fips flag */
	rcse.flags.no_protect = device.flags.no_protect;	/* pass along no_protect flag */
	rcse.flags.opr_int_available = device.flags.opr_int_available;
						/* pass along opr_int_available flag */

/*	Note this assignment in the syserr log.
*/
	call admin_gate_$syserr (LOG, "RCP: Assigned ^a to ^a", device.device_name, device.group_id);

     end ASSIGN_DEVICE;
%page;
TEST_DEVICE:
     procedure;

/*	This procedure is called to test a device.  We will see if it is
   *	appropriate, accessible, and available.  If it is all three we
   *	will add it to a list of such devices.
*/

/* Test free devices and deleted devices */

	if (device.state = FREE) | (device.state = DELETED & rcse.flags.priv) then do;
	     if device.dtypex = CONSOLE_DTYPEX then
		call admin_gate_$console_free (substr (device.device_name, 1, 4), console_free);

/**** The following test is obscure. Note the following:
      if a console is RCP-DELETED, then it is in ocdcm_ unavailable.
      However, ocdcm_ does nothing different for an UNAVAILABLE device
      from an INOP or an I/O device.
      Therefore, checking the console_free flag suffices for consoles. */

	     if (device.dtypex = CONSOLE_DTYPEX & console_free) | (device.dtypex ^= CONSOLE_DTYPEX) then do;
		if device.flags.reservable then	/* Can this device be reserved? */
		     num_free_res = num_free_res + 1;	/* Yes, count free reservable devices. */
		else ;
		available_flag = "1"b;		/* Device is available. */
	     end;
	end;

/*  Test assigned devices */

	else if (device.state = ASSIGNED) then do;
	     if device.process_id = rcse.process_id then	/* Assigned to requesting process? */
		num_assigned = num_assigned + 1;	/* Yes, count number assigned to this process. */
	     if device.flags.reserved then		/* Is device reserved to a system process? */
		num_reserved = num_reserved + 1;	/* Yes, count these too. */
	     available_flag = "0"b;			/* This device is not available. */
	end;

/*  Test reserved devices */

	else if (device.state = RESERVED) then
	     if device.process_id = rcse.process_id then
		available_flag = "1"b;
	     else available_flag = "0"b;

/*  Must be a storage system device - forget it */
	else return;

/*  Make appropriate, accessible, available test */

	match_flag = rcp_match_$match (rcse_ptr, device_ptr);
	if match_flag then				/* Did it match, i.e., is it appropriate? */
	     one_was_appropriate = "1"b;
	else return;				/* No this device is not appropriate. */
	operation = access_operations_$rcp_assign_write;
	if ^rcse.flags.device then
	     detailed_operation.search = "1"b;
	call setup_kernel_call ((DEVICE_TYPE (device.dtypex)), device.device_name, ecode);
	detailed_operation.priv_gate_call = ""b;	/* Device assignment is not a privileged */
						/* gate call, even through rcp_priv_ */
	if ecode = 0 then
	     call rcp_access_kernel_ (operation, addr (req_info), addr (res_info), effmode, ecode);
	if ecode = 0 then
	     accessible_flag = "1"b;
	else do;
	     accessible_flag = "0"b;
	     ecode = 0;
	end;
	call cleanup_kernel_call (ecode);		/* don't zero code until it has been tested */

	if ^accessible_flag then
	     return;

	one_was_accessible = "1"b;

	if ^available_flag then
	     return;

	num_available = num_available + 1;
	if num_available = MAX_AVAILABLE then
	     full = "1"b;				/* available list is now full */
	available_list (num_available) = device_ptr;	/* Put this device in the available list. */
	if device.state = RESERVED then		/* a reserved device */
	     num_resvd = num_resvd + 1;
	return;					/* test passes here */
     end TEST_DEVICE;
%page;
CHECK_LIMITS:
     procedure;

dcl	i		   fixed bin;

/*	This procedure is called to check the limits imposed upon non
   *	system processes.  These limits are:
   *	     1.	Only a certain number of devices of any one type may be assigned
   *		to a process at at one time.
   *	     2.	A certain number of reservable devices of this type
   *		must be free or in use by system processes.
*/
	if system_flag				/* Is this a system process? */
	     then
	     return;				/* Yes, no need to test limits. */

	if num_resvd ^= 0 then
	     return;				/* can always use reserved device */

	if num_assigned >= dtype.max_concurrent		/* Maximum already assigned to this process? */
	then do;					/* Yes. */
	     ecode = error_table_$device_limit_exceeded;
	     return;
	end;

	if num_reserved >= dtype.num_reserved		/* Already using the quota of system drives? */
	     then
	     return;				/* Yes, don't bother the user */

	if num_free_res > (dtype.num_reserved - num_reserved) then
	     return;				/* There are enough free reservable devices. */

	num_avail_nres = 0;				/* Count number that will be available. *. */
	do i = 1 to num_available;			/* Remove reservable devices from selection list. */
	     device_ptr = available_list (i);
	     if ^device.flags.reservable		/* If non reservable keep in list. */
	     then do;
		available_list (num_avail_nres) = device_ptr;
		num_avail_nres = num_avail_nres + 1;
	     end;
	end;
	num_available = num_avail_nres;		/* Now only non reservable devices are available. */
	if num_available = 0			/* Are there any available devices left? */
	then do;					/* No, only reservable devices were available. */
	     ecode = error_table_$resource_unavailable;
	     return;
	end;

     end CHECK_LIMITS;
%page;
ERROR_COUNT:
     procedure;

/*	This procedure is called to update the error count for a device.
*/
	dev_rcse_off = a_device_offset;
	device_ptr = ptr (rcpd_ptr, dev_rcse_off);

	if device.state ^= ASSIGNED then		/* Is device assigned? */
	     ecode = error_table_$resource_unassigned;	/* No, ignore this call. */

	if device.process_id ^= get_process_id_ () then
	     ecode = error_table_$resource_unassigned;	/* Not assigned to this process. */

	if ecode = 0 then do;
	     device.error_count = device.error_count + error_count;
	     a_error_count = device.error_count;
	end;
	return;
     end ERROR_COUNT;
%page;
UNASSIGN:
     procedure;

/*	This procedure is called to unassign a device and/or volume.
   *	The volume and device offsets reference RCPD volume and
   *	and device entries.  The resources associated with these
   *	entries will be unassigned.  Before unassigning any
   *	resource we will verify that it is actually assigned to the
   *	requesting process.  We will note this unassignment in the syserr log.
*/
	if detailed_operation.force then do;
	     call FORCE_UNASSIGN;
	     return;
	end;
	if detailed_operation.process then do;
	     call PROC_UNASSIGN;
	     return;
	end;

	volume_off = a_volume_offset;
	device_off = a_device_offset;

	process_id = get_process_id_ ();		/* Get process ID of calling process. */

	if volume_off ^= "0"b			/* Is there a volume to unassign? */
	then do;					/* Yes. */
	     volume_ptr = ptr (rcpd_ptr, volume_off);
	     if volume.process_id = process_id then	/* Volume is assigned to this process. */
		call UNASSIGN_VOLUME ();
	end;

	if device_off ^= "0"b then do;		/* Is there a device to unassign? */
	     device_ptr = ptr (rcpd_ptr, device_off);	/* Yes, get a pointer to its device entry. */
	     if device.process_id = process_id then do;	/* Is it actually assigned to this process? */
		device.error_count = device.error_count + error_count;
		call UNASSIGN_DEVICE;
		call admin_gate_$syserr (LOG, "RCP: Unassigned ^a from ^a", device.device_name, device.group_id);
		a_error_count = error_count;
	     end;
	end;

     end UNASSIGN;
%page;
FORCE_UNASSIGN:
     procedure;

dcl	i		   fixed bin;

/*	This procedure is called to force the unassignment of a device.
   *	The device does not have to be assigned by the requesting process.
   *	If there is a volume mounted on this device we will unassign it.
*/
	device_name = a_device_name;

	call FIND_DEVICE;				/* Search through all devices for this one. */
	if device_off = "0"b then do;			/* Find it? */
	     ecode = error_table_$resource_unknown;	/* No */
	     return;
	end;

	if device.state = ASSIGNED then do;		/* Is device assigned? */
	     call UNASSIGN_DEVICE;			/* Just forcedly unassign it. */
	     call admin_gate_$syserr (ANNOUNCE, "RCP: Force Unassigned ^a from ^a", device_name, device.group_id);
	end;

	if device.volume_name = " "			/* Is there a volume on this device? */
	     then
	     return;				/* No, we are all done. */

	do i = 1 to rcpd.last_volume;			/* Yes, find this volume. */
	     volume_ptr = addr (rcpd.volume (i));	/* Get pointer to next volume entry. */
	     if volume.volume_name = device.volume_name then do;
						/* We found this volume. */
		call UNASSIGN_VOLUME ();
		return;
	     end;
	end;

     end FORCE_UNASSIGN;
%page;
PROC_UNASSIGN:
     procedure;

dcl	i		   fixed bin;

/*	This procedure is called to forcedly unassign all devices and volumes
   *	currently assigned to the process whose process ID has been provided
   *	by the caller of this routine.
*/

	process_id = a_process_id;

	do i = 1 to rcpd.last_volume;			/* Look at all volume entries. */
	     volume_ptr = addr (rcpd.volume (i));	/* Get pointer to volume entry. */
	     if volume.process_id = process_id		/* Does volume belong to this process? */
	     then do;				/* Yes, unassign it. */
		volume.unassign_state = FREE;
		call UNASSIGN_VOLUME ();
	     end;
	end;

	do i = 1 to rcpd.tot_devices;			/* Look at all devices. */
	     device_ptr = addr (rcpd.device (i));
	     if device.process_id = process_id		/* Does device belong to this process? */
	     then do;				/* Yes, forcedly unassign. */
		device.unassign_state = FREE;
		call UNASSIGN_DEVICE;
		call admin_gate_$syserr (LOG, "RCP: Force Unassigned ^a from ^a", device.device_name, device.group_id)
		     ;
	     end;
	end;

     end PROC_UNASSIGN;
%page;
DELETE_DEVICE:
     procedure;

dcl	local_code	   fixed bin (35);
dcl	local_effmode	   bit (3);

/*	This procedure is called to put a device in the deleted state.
   *	This means that the device cannot be assigned to any process.
   *	If the device is currently assigned will will not delete it now.
   *	We will remember to delete it when it is unassigned.
*/
	device_name = a_device_name;			/* Get name of device to delete. */

	call FIND_DEVICE;				/* Find the device with this name. */
	if device_off = "0"b then do;			/* Did we find it? */
	     ecode = error_table_$resource_unknown;
	     goto DELETE_RETURN;
	end;

	if device.state = STORAGE_SYSTEM then
	     goto DELETE_RETURN;			/* Should not be here, but check for ss drives */
	if device.state = ASSIGNED | device.state = RESERVED
						/* Is device still assigned? */
	then do;					/* Yes, we won't delete it now. */
	     device.flags.delete = "1"b;		/* Remember to delete it when unassigned. */
	     ecode = error_table_$device_deletion_deferred;
	     goto DELETE_RETURN;
	end;

	if device.volume_name ^= "" & device.dtypex = 1 then
	     call rcp_unload_$unload_device (device_ptr, "1"b);
						/* unload volume and forget it was here */

	call admin_gate_$ioi_delete_device (device_name, ecode);
	if ecode ^= 0 then
	     goto DELETE_RETURN;

	device.volume_name = " ";			/* Forget any volume on the deleted device. */
	device.process_id = "0"b;			/* Make sure it doesn't belong to any process. */
	device.state = DELETED;			/* Just change its state. */
	device.state_time = clock ();			/* And remember when. */

	if device.dtypex = CONSOLE_DTYPEX then		/* must inform console DIM of deletion... */
	     call admin_gate_$ocdcm_reconfigure (substr (device_name, 1, 4), MAKE_UNAVAILABLE, ecode);

	call admin_gate_$syserr (ANNOUNCE, "RCP: Deleted device ^a", device_name);
DELETE_RETURN:					/* Let's perform auditing. Call setup_kernel_call to set up */
						/* the resource_info and requestor_info structures although we */
						/* really don't call the kernel for this operation, it has all the */
						/* information so let it do the auditing for us. */
	local_code = 0;
	call setup_kernel_call ((DEVICE_TYPE (device.dtypex)), device.device_name, local_code);
	if local_code = 0 then do;			/* if we didn't find the resource at all ... */
	     detailed_operation.priv_gate_call = "1"b;
	     call rcp_access_kernel_ (operation, addr (req_info), addr (res_info), local_effmode, (ecode));
	end;
	call cleanup_kernel_call (local_code);
	if ecode = 0 then
	     ecode = local_code;
	return;

     end DELETE_DEVICE;





ADD_DEVICE:
     procedure;

/*	This procedure is called to take a device out of the deleted state.
   *	This will only be done if the device is already in the deleted state.
*/

dcl	local_code	   fixed bin (35);
dcl	local_effmode	   bit (3);
dcl	operational	   bit (1) aligned;
dcl	1 tape_name	   unaligned,
	  2 subsystem	   char (4),
	  2 bar		   char (1),
	  2 drive		   pic "99";

	device_name = a_device_name;			/* Get name of device to add. */

	call FIND_DEVICE;				/* Find the device with this name. */
	if device_off = "0"b			/* Did we find it? */
	     then
	     goto ADD_RETURN;

	device.flags.delete = "0"b;			/* Make sure no delete is pending. */

	if device.state ^= DELETED			/* Is device in the deleted state? */
	     then
	     goto ADD_RETURN;			/* No, leave it alone. */

	if (device.dtypex = TAPE_DRIVE_DTYPEX) & (device.qualifiers (1) = 0) then do;
						/* this is a tape drive deleted during initialization */
	     string (tape_name) = substr (device_name, 1, length (string (tape_name)));
	     call rcp_tape_survey_ (tape_name.subsystem, (tape_name.drive), (device.flags.fips), operational,
		device.qualifiers, ecode);
	     if ^operational then do;
		if ecode = 0 then
		     call admin_gate_$syserr (ANNOUNCE, "RCP: ^a is not operational and will not be added.",
			device_name);
		goto ADD_RETURN;
	     end;
	end;

	call admin_gate_$ioi_add_device (device_name, ecode);
	if ecode ^= 0 then
	     goto ADD_RETURN;

	device.state = FREE;			/* Put it into the free state. */
	device.unassign_state = FREE;			/* And keep it there. */
	device.state_time = clock ();			/* Save time device added. */

	if device.dtypex = CONSOLE_DTYPEX then		/* must inform console DIM of deletion... */
	     call admin_gate_$ocdcm_reconfigure (substr (device_name, 1, 4), MAKE_IO_DEVICE, ecode);
	call admin_gate_$syserr (ANNOUNCE, "RCP: Added device ^a", device_name);
ADD_RETURN:					/* Let's perform auditing. Call setup_kernel_call to set up */
						/* the resource_info and requestor_info structures although we */
						/* really don't call the kernel for this operation, it has all */
						/* information to do the auditing so let it do it. */
	local_code = 0;
	call setup_kernel_call ((DEVICE_TYPE (device.dtypex)), device.device_name, local_code);
	if local_code = 0 then do;			/* if we didn't find the resource at all ... */
	     detailed_operation.priv_gate_call = "1"b;
	     call rcp_access_kernel_ (operation, addr (req_info), addr (res_info), local_effmode, (ecode));
	end;
	call cleanup_kernel_call (local_code);
	if ecode = 0 then
	     ecode = local_code;
	return;

     end ADD_DEVICE;
%page;
ACCOUNT_ATTACH:
     procedure;

/*	This procedure is called when an attachment is completed.  The rcp_control_
   *	wakes the accounting process with a datum about the attachment. */

	device_off = a_device_offset;

	device_ptr = ptr (rcpd_ptr, device_off);

	call ACCOUNT_WAKEUP (device_ptr, RCP_ACCTMSG_attach);

	return;

     end ACCOUNT_ATTACH;
%page;
UNASSIGN_DEVICE:
     procedure;

dcl	ignored_code	   fixed bin (35);		/* Ignored error code. */
dcl	i		   fixed bin;
dcl	old_state		   fixed bin;

/*	This procedure is called to put a device in the state it was in
   *	at assignment time.
   *	It will also compute the metering statistics kept for each device.
   *	If the device was supposed to be deleted but was not because it was still
   *	assigned we will delete it now.
*/
	time_assigned = device.state_time;		/* Save time assigned. */

	old_state = device.state;
	if device.flags.delete			/* Are we waiting to delete this device? */
	     & (device.unassign_state = FREE | device.unassign_state = DELETED)
						/* and it won't still be reserved after this unassignment */
	then do;					/* Yes, delete it now. */
	     if ^device.flags.priv & device.volume_name ^= "" & device.dtypex <= 2 then do;
						/* Must unload this loaded device. */
		device.state = FREE;		/* do this now to permit unload */
		call rcp_unload_$unload_device (device_ptr, "1"b);
						/* unload volume and forget it was here */
	     end;
	     call admin_gate_$ioi_delete_device ((device.device_name), ignored_code);
	     device.state = DELETED;			/* Now it is deleted. */
	     device.volume_name = "";
	     if ^device.flags.priv			/* If not assigned while deleted say it is deleted now. */
		then
		call admin_gate_$syserr (ANNOUNCE, "RCP: Deleted device ^a", device.device_name);
	     device.flags.delete,			/* Turn off these flags. */
		device.flags.priv = "0"b;
	end;
	else device.state = device.unassign_state;	/* No, unassign the device. */

	device.unassign_state = FREE;

	if device.state ^= RESERVED then do;		/* Accounting for reserved devices is done at cancel time. */
						/* the only other possibilities are DELETED and FREE */
	     call ACCOUNT_WAKEUP (device_ptr, RCP_ACCTMSG_unassign);
						/* go send wakeup before clearing process_id */
	     device.process_id = "0"b;		/* No longer assigned to this process. */
	     device.reservation_id = 0;
	     device.reserved_by = "";
	end;
	device.state_time = clock ();			/* Time device made free. */

	device.num_assigns = device.num_assigns + 1;
	device.flags.mounting = "0"b;			/* Turn off mount timer for this device. */
	device.flags.attached = "0"b;

	time_assigned = device.state_time - time_assigned;
	device.tot_assign_time = device.tot_assign_time + time_assigned;
	time_assigned = divide (time_assigned, 1000000, 71, 0);
	dtype_ptr = addr (rcpd.dtype (device.dtypex));

	do i = 1 to hbound (dtype.histo_times, 1);	/* Find histogram slot. */
	     if time_assigned < dtype.histo_times (i) then do;
						/* We found the right slot. */
		device.histogram (i) = device.histogram (i) + 1;
		return;
	     end;
	end;					/* Falling through loop => use last slot. */
	device.histogram (hbound (device.histogram, 1)) = device.histogram (hbound (device.histogram, 1)) + 1;

     end UNASSIGN_DEVICE;
%page;
UNASSIGN_VOLUME:
     proc ();

dcl	ignored_code	   fixed bin (35);		/* Ignored error code. */
dcl	old_state		   fixed bin (35);

/*
   This procedure is called to put a volume in the free or reserved
   state.  The choice is made based on the volume's state at the time of
   the last assignment.
*/

	volume.state_time = clock ();			/* record the time */
	old_state = volume.state;
	volume.state = volume.unassign_state;		/* and return the volume to the proper state */
	volume.unassign_state = FREE;			/* reset the unassign state */
	if volume.state = FREE then do;		/* if we are freeing it ... */
	     volume.process_id = "0"b;		/* no process owns it now */
	     volume.reserved_by = "";
	     volume.reservation_id = 0;
	     if old_state = RESERVED then
		call rcp_cancel_resource_ (VOLUME_TYPE (volume.vtypex), (volume.volume_name), ignored_code);
						/* Tell Resource Management that this volume has been turned loose. */
	     if rcpd.unload_on_detach then do;		/* all done */
		volume.volume_name = "";		/* no need to remember the volume_name */
		volume.group_id = "";
	     end;
	end;
	return;

     end UNASSIGN_VOLUME;
%page;
FIND_DEVICE:
     procedure;

dcl	i		   fixed bin;		/*	This procedure is called to find the device entry of the device with
						   *	the specified name.  We will search by device type since tapes and
						   *	disks are the most active types.
						*/
	do i = 1 to rcpd.tot_dtypes;			/* Look at each device type. */
	     dtype_ptr = addr (rcpd.dtype (i));		/* Get pointer to device type entry. */
	     device_off = dtype.first_off;		/* Start with first device type. */
	     do while (device_off ^= "0"b);		/* Look at each device of this type. */
		device_ptr = ptr (rcpd_ptr, device_off);
		if device.device_name = device_name then
		     return;			/* This is the device.  Look no further. */
		device_off = device.next_off;
	     end;
	end;

	device_off = "0"b;				/* Let caller know we didn't find device. */

     end FIND_DEVICE;
%page;
ACCOUNT_WAKEUP:
     procedure (a_devptr, a_action);

/*	This procedure is called to format an accounting message, and send it to the
   *	accounting process.  If the accounting event channel has not been set up, no message is sent.
*/


dcl	a_devptr		   ptr;			/* Pointer to rcp_data entry */
dcl	a_action		   fixed bin;		/* Accounting action */

dcl	wakeup_buf	   fixed bin (71);
dcl	1 auto_rcpamsg	   like rcp_account_msg aligned;

	unspec (auto_rcpamsg) = "0"b;

	auto_rcpamsg.device_user_procid = a_devptr -> device.process_id;
	auto_rcpamsg.rcp_data_relp = rel (a_devptr);
	auto_rcpamsg.devtype = a_devptr -> device.dtypex;
	auto_rcpamsg.action = a_action;

	unspec (wakeup_buf) = unspec (auto_rcpamsg);
	if rcpd.accounting_chan ^= 0 then
	     call hcs_$wakeup (rcpd.accounting_pid, rcpd.accounting_chan, wakeup_buf, (0));

     end ACCOUNT_WAKEUP;
%page;
ss_io_interchange:
     entry (a_device_name, a_add_sw, a_del_sw, a_ecode);

/*	Entry to add and delete disk drives on demand, called from mdx in
   *	the initializer's process, in ring 1. a_add_sw is "1"b if drive is
   *	being given back to RCP.
*/

	device_name = a_device_name;
	add_sw = a_add_sw;
	del_sw = a_del_sw;
	ecode = 0;

	rcpd_ptr = rcp_pointers_$data ();
	rcs_ptr = rcp_pointers_$com_seg ();

	on cleanup
	     begin;
	     call cleanup_kernel_call ((0));
	     call UNLOCK;				/* If trouble unlock rcp_data. */
	end;

	call rcp_lock_$lock (addr (rcpd.lock_info), ecode);
	if ecode ^= 0 then do;
	     a_ecode = ecode;
	     return;
	end;

	call FIND_DEVICE;				/* Attempt to find the device */

	if device_off = "000000"b3 then
	     ecode = error_table_$resource_unknown;
	else if dtype.device_type ^= DEVICE_TYPE (DISK_DRIVE_DTYPEX) then
	     ecode = error_table_$invalid_state;

	if ecode = 0 then
	     if add_sw then
		if device.state = STORAGE_SYSTEM then
		     if del_sw then
			device.state = DELETED;	/* deleted */
		     else device.state = FREE;	/* free */
		else ecode = error_table_$invalid_state;
	     else if device.state = ASSIGNED then
		ecode = error_table_$io_still_assnd;
	     else device.state = STORAGE_SYSTEM;

	if ecode = 0 then do;
	     device.state_time = clock ();
	     device.volume_name = " ";
	     device.process_id = "000000000000"b3;
	     call admin_gate_$syserr (ANNOUNCE, "RCP: ^[Acquired ^a from^;Consigned ^a to^] storage system.", add_sw,
		device_name);
	end;

	a_ecode = ecode;
	call UNLOCK;
	return;
%page;
setup_kernel_call:
     proc (a_resource_type, a_resource_name, a_code);

dcl	(a_resource_type, a_resource_name)
			   char (*) aligned;
dcl	a_code		   fixed bin (35);
dcl	local_code	   fixed bin (35);

dcl	rcprm_registry_util_$grab_transaction_control_file
			   entry (ptr, char (*) aligned, fixed bin (35));
dcl	rcprm_registry_util_$grab_registry
			   entry (ptr, char (*) aligned, char (*) aligned, fixed bin (35));
dcl	rcprm_registry_util_$find_resource_record
			   entry (ptr, char (*) aligned, ptr, fixed bin (35));

	local_code = 0;
	if rcpd.modes.resource_mgmt_enabled then do;
	     res_info.registry_dir = DEFAULT_REGISTRY_DIR;
	     call rcprm_registry_util_$grab_transaction_control_file (trans_iocb_ptr, res_info.registry_dir, local_code)
		;
	     if local_code ^= 0 then
		goto SETUP_RETURN;
	     call rcprm_registry_util_$grab_registry (reg_iocb_ptr, res_info.registry_dir, a_resource_type, local_code);
	     if local_code ^= 0 then
		goto SETUP_RETURN;
	     call rcprm_registry_util_$find_resource_record (reg_iocb_ptr, a_resource_name, record_ptr, local_code);
	     if local_code ^= 0 then do;
		if local_code = error_table_$no_key then
		     local_code = error_table_$resource_unknown;
						/* well defined reason for this. */
		call cleanup_kernel_call ((0));	/* undo the above */
		goto SETUP_RETURN;
	     end;
	     res_info.registry_switch_ptr = reg_iocb_ptr;
	     res_info.registry_record_ptr = record_ptr;
	end;
	else do;
	     res_info.registry_dir = "";
	     res_info.registry_switch_ptr, res_info.registry_record_ptr = null ();
	end;
	if (basic_operation (operation) = access_operations_$rcp_unassign
	     & (detailed_operation.force | detailed_operation.process))
	     | (base_op = access_operations_$rcp_delete_device) | (base_op = access_operations_$rcp_add_device) then
	     detailed_operation.priv_gate_call = "1"b;
	else detailed_operation.priv_gate_call = "0"b;
	res_info.resource_type = a_resource_type;
	res_info.resource_name = a_resource_name;
	if base_op = access_operations_$rcp_add_device | base_op = access_operations_$rcp_delete_device then do;
	     req_info.user_id = get_group_id_ ();
	     req_info.validation_level = 1;
	end;
	else do;
	     req_info.user_id = rcse.group_id;
	     req_info.validation_level = rcse.caller_level;
	end;
	call hcs_$get_authorization (req_info.current_authorization, ""b);

SETUP_RETURN:
	a_code = local_code;
     end setup_kernel_call;
%page;
cleanup_kernel_call:
     proc (a_code);

dcl	a_code		   fixed bin (35);
dcl	local_code	   fixed bin (35);
dcl	rcprm_registry_util_$release_transaction_control_file
			   entry (ptr, fixed bin (35));
dcl	rcprm_registry_util_$release_registry
			   entry (ptr, fixed bin (35));

	local_code = 0;
	if reg_iocb_ptr ^= null () then
	     call rcprm_registry_util_$release_registry (reg_iocb_ptr, local_code);
	if trans_iocb_ptr ^= null () then
	     call rcprm_registry_util_$release_transaction_control_file (trans_iocb_ptr, local_code);

	a_code = local_code;
     end cleanup_kernel_call;

basic_operation:
     proc (oper) returns (bit (36) aligned);

dcl	oper		   bit (36) aligned;
dcl	return_arg	   bit (36) aligned;

	return_arg = oper;
	addr (return_arg) -> encoded_access_op.detailed_operation = 0;
	return (return_arg);

     end basic_operation;
%page;
%include access_mode_values;
%page;
%include rcp_data;
%page;
%include rcp_com_seg;
%page;
%include rcp_account_msg;
%page;
%include rcp_resource_states;
%page;
%include rcp_requestor_info;
%page;
%include rcp_resource_info;
%page;
%include rcp_resource_types;
%page;
%include access_audit_encoded_op;
%include rcp_ops;
%page;
%include opc_reconfig_options;
%page;
%include syserr_constants;

/* BEGIN MESSAGE DOCUMENTATION

   Message:
   RCP: Acquired DEVICE from storage system.

   S:	$info

   T:	$response

   M:	The operator has used the set_drive_usage command to make
   DRIVE an IO drive.

   A:	$ignore


   Message:
   RCP: Added device DEVICE

   S:	$info

   T:	$response

   M:	The operator has added a user I/O disk drive with adddev.

   A:	$ignore


   Message:
   RCP: Assigned DEVICE to PERSON.PROJ.T

   S:	$log

   T:	$run

   M:	DEVICE has been assigned to a user process.

   A:	$ignore


   Message:
   RCP: Consigned DEVICE to storage system.

   S:	$info

   T:	$response

   M:	The operator has used the set_drive_usage command to make DRIVE a storage system drive.

   A:	$ignore


   Message:
   RCP: Deleted device DEVICE

   S:	$info

   T:	$response

   M:	The operator has deleted user I/O disk DRIVE with deldev.

   A:	$ignore


   Message:
   RCP: Force Unassigned DEVICE from PERSON.PROJ.T

   S:	$info

   T:	$run

   M:	The user process PERSON.PROJ.T has terminated,
   and its resources have been freed.
   Or, the operator may have forced the unassignment of DRIVE.

   A:	$ignore


   Message:
   RCP: Unassigned DEVICE from PERSON.PROJ.T

   S:	$log

   T:	$run

   M:	PERSON.PROJ.T has released DRIVE normally.

   A:	$ignore


   Message:
   RCP: DEVICE is not operational and has not been added.

   S:	$info

   T:	$response

   M:	An attempt was made to add a non-operational device with adddev.

   A:	Ready the device and add it again.


   Message:
   rcp_control_: Error surveying DEVICE. MESSAGE

   S:	$info

   T:	$response

   M:	An error occurred while surveying the device.

   A:	$notify


   END MESSAGE DOCUMENTATION */

     end rcp_control_;
