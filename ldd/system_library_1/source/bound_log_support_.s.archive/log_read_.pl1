/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(85-06-11,Margulies), approve(86-02-21,MCR7344),
     audit(86-02-21,EJSharpe), install(86-04-23,MR12.0-1044):
     Update very_last_time on any time search, and very_last_sequence on any
     sequence search.
                                                   END HISTORY COMMENTS */


/* format: style4 */
log_read_:
     procedure ();

/* *	LOG_READ_
   *
   *	This is the user-ring log reading procedure. More comments to come
   *	later.
   *
   *	84-06-05, W. Olin Sibert
   *	84-10-09, E. Swenson to handle setting limits on an empty log.
   *      84-11-26, BIM: added $update for use in monitoring.
   *	84-11-28, Steve Herbst: Added $open_with_procedure, which sets
   *		entry variables in log_read_data.
   *	84-12-06, Steve Herbst: Added $hold_message, $free_message,
   *		$get_log_uid, $register, and $deregister.
   *    1984-12-15, BIM: various debugging changes to the above.
   *    1985-01-25, BIM: no zero code on null log message ptr.
   *    1985-02-18, EJ Sharpe: optimizations (binary search for message time
   *		or sequence numbers.  Use suffix_time when searching for
   *		specific message time to avoid some initiates.
   *    1985-03-15, Lindsey Spratt, Steve Herbst: Fixed to allocate held
   *		message nodes in system_area instead of caller_area.
   *    1985-03-18, Steve Herbst: Fixed $open entries to abort if current
   *		log segment is null and previous not found.
*/

declare  P_log_dname char (*) parameter;
declare  P_log_ename char (*) parameter;
declare  P_log_read_data_ptr pointer parameter;
declare  P_log_message_ptr pointer parameter;
declare  P_open_info_ptr pointer parameter;
declare  P_message_sequence fixed bin (35) parameter;
declare  P_message_time fixed bin (71) parameter;
declare  P_event_channel fixed bin (71) parameter;
declare  P_log_uid bit (36) aligned parameter;
declare  P_process_id bit (36) aligned parameter;
declare  P_search_direction bit (1) aligned parameter;
declare  P_code fixed bin (35) parameter;

declare  allocate_copies bit (1) aligned;
declare  code fixed bin (35);
declare  procedure_name char (32);
declare  caller_area_ptr pointer;
declare  good_log_read_data_ptr pointer;
declare  system_area_ptr pointer;
declare  log_in_service bit (1) aligned;
declare  log_idx fixed bin;
declare  message_sequence fixed bin (35);
declare  new_log_read_data_ptr pointer;

declare  system_area area based (system_area_ptr);

declare  error_table_$badcall fixed bin (35) external static;
declare  error_table_$fatal_error fixed bin (35) external static;
declare  error_table_$log_segment_damaged fixed bin (35) external static;
declare  error_table_$no_log_message fixed bin (35) external static;
declare  error_table_$null_info_ptr fixed bin (35) ext static;
declare  error_table_$unimplemented_version fixed bin (35) ext static;

declare  cv_entry_ entry (char (*), ptr, fixed bin (35)) returns (entry);
						/* DBG declare  date_time_$format entry (char (*), fixed bin (71), char (*), char (*)) returns (char (250) var); /* DBG */
declare  get_system_free_area_ entry () returns (pointer);
declare  hcs_$get_uid_seg entry (ptr, bit (36) aligned, fixed bin (35));
declare  hcs_$terminate_noname entry (pointer, fixed bin (35));
						/* DBG declare  ioa_ entry options (variable);			/* DBG */
declare  log_initiate_ entry (char (*), char (*), fixed bin, pointer, fixed bin (35));
declare  log_list_history_$all entry (pointer, char (*), fixed bin, pointer);
declare  log_position_$find_sequence entry (pointer, fixed bin (35), bit (1) aligned, pointer, bit (1) aligned);
declare  log_position_$find_time entry (pointer, fixed bin (71), bit (1) aligned, pointer, bit (1) aligned);
declare  log_position_$next_message entry (pointer, pointer, bit (1) aligned);
declare  log_position_$prev_message entry (pointer, pointer, bit (1) aligned);
declare  log_segment_$get_service_bit entry (pointer, bit (1) aligned, fixed binary (35));
declare  log_wakeup_$register entry (pointer, bit (36) aligned, fixed bin (71), fixed bin (35));
declare  log_wakeup_$deregister entry (pointer, bit (36) aligned, fixed bin (71), fixed bin (35));
declare  sub_err_ entry options (variable);

declare  cleanup condition;

declare  (clock, codeptr, divide, hbound, max, min, null, segno, setwordno, unspec) builtin;
%page;

log_read_$open:
     entry (P_log_dname, P_log_ename, P_log_read_data_ptr, P_code);

	P_log_read_data_ptr = null ();
	P_code = 0;

	procedure_name = "";
	caller_area_ptr = get_system_free_area_ ();
	allocate_copies = "0"b;

	go to OPEN_COMMON;

log_read_$open_long:
     entry (P_log_dname, P_log_ename, P_open_info_ptr, P_log_read_data_ptr, P_code);


	P_log_read_data_ptr = null ();
	P_code = 0;

	log_read_open_info_ptr = P_open_info_ptr;
	if log_read_open_info.version ^= LOG_READ_OPEN_INFO_VERSION_1
	then call finished (error_table_$unimplemented_version);

	procedure_name = log_read_open_info.reader_procedure;
	caller_area_ptr = log_read_open_info.allocation_area_ptr;
	allocate_copies = log_read_open_info.allocate_copies;
	if procedure_name ^= "" & allocate_copies
	then call finished (error_table_$badcall);	/* too hard to implement, it gets VERY confusing in $update */

OPEN_COMMON:
	log_read_data_ptr, good_log_read_data_ptr = null ();
	system_area_ptr = get_system_free_area_ ();

	on condition (cleanup) begin;
	     call log_read_$close (good_log_read_data_ptr, (0));
	end;

	log_read_data_n_segments = 1;
	allocate log_read_data in (system_area) set (log_read_data_ptr);
	unspec (log_read_data) = ""b;
	log_read_data.sentinel = LOG_READ_DATA_VERSION_SENTINEL;
	log_read_data.n_segments = log_read_data_n_segments;
	log_read_data.reader_data_ptr = null ();
	log_read_data.first_held_message_ptr = null ();
	log_read_data.latest_message = null ();
	log_read_data.earlier_message = null ();
	log_read_data.last_held_message_ptr = null ();
	log_read_data.ptr (*) = null ();
	log_read_data.history_complete = "0"b;
	log_read_data.call_procedures = (procedure_name ^= "");
	log_read_data.user_area_ptr = caller_area_ptr;
	log_read_data.allocate_copies = allocate_copies;

	begin;
declare  1 null_entry aligned,
	 2 code ptr,
	 2 env ptr;
declare  nulle entry variable;

	     null_entry.code = null ();
	     null_entry.env = null ();
	     unspec (nulle) = unspec (null_entry);
	     log_read_data.ev = nulle;		/* aggregate */
	end;

	if log_read_data.call_procedures then do;

	     call set_entry_variable (log_read_data.ev.open, procedure_name, "open");
	     call set_entry_variable (log_read_data.ev.close, procedure_name, "close");
	     call set_entry_variable (log_read_data.ev.prev_message, procedure_name, "prev_message");
	     call set_entry_variable (log_read_data.ev.next_message, procedure_name, "next_message");
	     call set_entry_variable (log_read_data.ev.position_time, procedure_name, "position_time");
	     call set_entry_variable (log_read_data.ev.position_sequence, procedure_name, "position_sequence");
	     call set_entry_variable (log_read_data.ev.update, procedure_name, "update");
	     call set_entry_variable (log_read_data.ev.hold_message, procedure_name, "hold_message");
	     call set_entry_variable (log_read_data.ev.free_message, procedure_name, "free_message");
	     call set_entry_variable (log_read_data.ev.get_log_uid, procedure_name, "get_log_uid");
	end;

	good_log_read_data_ptr = log_read_data_ptr;	/* can be used now by log_read_$close above */


	if log_read_data.call_procedures then do;
	     call log_read_data.ev.open (P_log_dname, P_log_ename,
		caller_area_ptr, log_read_data.reader_data_ptr, code);
	     if code ^= 0 then call finished (code);
	     go to OPEN_GOOD_RETURN;			/* The remainder is in the inner ring */
	end;

/* Try to initiate the beginning segment in the log family.  Any
   error at this stage, and we just give up. */

	log_idx = 1;
	log_read_data.dname (1) = P_log_dname;
	log_read_data.ename (1) = P_log_ename;

	call initiate_log (1);
	if (code ^= 0) then do;
	     call log_read_$close (log_read_data_ptr, (0));
	     call finished (code);
	end;

	log_read_data.suffix_time (1) = clock ();	/* A reasonable default-- logged messages will be earlier */

	call get_complete_history ();

	call look_for_log_segment (log_read_data.n_segments, 1); /* Set up the limits in the header */
	if log_segment_ptr = null () then call finished (error_table_$fatal_error);

	log_read_data.very_first_log_idx = log_idx;	/* Start with oldest (first) message */
	log_read_data.very_first_sequence = log_segment.first_sequence;
	log_read_data.very_first_time = log_segment.first_time;

	call look_for_log_segment (1, log_read_data.n_segments); /* Find newest (last) message */
	if log_segment_ptr = null () then call finished (error_table_$fatal_error);

	if log_segment.first_sequence = 0 & log_segment.last_sequence = 0 then do; /* Log is empty */
	     call look_for_log_segment (2, log_read_data.n_segments); /* Find previous log */
	     if log_segment_ptr = null then call finished (error_table_$fatal_error);
	end;

	log_read_data.very_last_log_idx = log_idx;
	log_read_data.very_last_sequence = log_segment.last_sequence;
	log_read_data.very_last_time = log_segment.last_time;
OPEN_GOOD_RETURN:
	P_log_read_data_ptr = log_read_data_ptr;

	call finished (0);
%page;

log_read_$close:
     entry (P_log_read_data_ptr, P_code);

	P_code = 0;
	if P_log_read_data_ptr = null () then return;
	call check_in_pointer;

	if log_read_data.call_procedures then do;
	     P_log_read_data_ptr = null ();
	     call log_read_data.ev.close (log_read_data.reader_data_ptr, code);
	     call finished (code);
	end;

	if log_read_data.allocate_copies then
	     call free_held_messages ();

	P_log_read_data_ptr = null ();
	system_area_ptr = get_system_free_area_ ();

	do log_idx = 1 to hbound (log_read_data.ptr, 1);
	     if (log_read_data.ptr (log_idx) ^= null ()) then
		call hcs_$terminate_noname (log_read_data.ptr (log_idx), (0));
	end;

	free log_read_data in (system_area);
	call finished (0);
%page;

log_read_$next_message:
     entry (P_log_read_data_ptr, P_log_message_ptr, P_code);

	call check_in_pointer;
	log_message_ptr = P_log_message_ptr;

	if log_read_data.call_procedures then do;
	     call log_read_data.ev.next_message (log_read_data.reader_data_ptr, P_log_message_ptr, code);
	     call finished (code);
	end;

	if log_read_data.allocate_copies then
	     log_message_ptr = lookup_message (log_message_ptr); /* turn ptr to user's copy into real msg ptr */
	if (log_message_ptr = null ()) then do;
	     call look_for_log_segment (log_read_data.n_segments, 1); /* Look through them all, backwards */
	     if (log_segment_ptr = null ()) then call finished (code); /* Couldn't find anything, punt */
	end;

	else call find_log_idx_of_message ();

	call log_position_$next_message (log_segment_ptr, log_message_ptr, log_read_data.damaged (log_idx));

	if (log_message_ptr = null ()) then do;		/* Not in that segment, try the next one */
	     call look_for_log_segment ((log_idx - 1), 1);/* Search remaining ones */
	     if (log_segment_ptr = null ()) then call finished (error_table_$no_log_message);

	     call log_position_$next_message (log_segment_ptr, log_message_ptr, log_read_data.damaged (log_idx));
	     if log_message_ptr = null ()		/* still no one home */
	     then call finished (error_table_$no_log_message); /* So say so */
	end;

/**** Arrive here with a found message in our mouth */

	if log_read_data.allocate_copies
	then call short_hold_message (log_message_ptr);	/* input-output, replaces pointer with copy */

	P_log_message_ptr = log_message_ptr;
	call finished (0);
%page;

log_read_$prev_message:
     entry (P_log_read_data_ptr, P_log_message_ptr, P_code);
	call check_in_pointer;
	log_message_ptr = P_log_message_ptr;

	if log_read_data.call_procedures then do;
	     call log_read_data.ev.prev_message (log_read_data.reader_data_ptr, P_log_message_ptr, code);
	     call finished (code);
	end;

	if log_read_data.allocate_copies then
	     log_message_ptr = lookup_message (log_message_ptr); /* turn ptr to user's copy into real msg ptr */
	if (log_message_ptr = null ()) then do;
	     call look_for_log_segment (1, log_read_data.n_segments); /* Look through them all, from the end */
	     if (log_segment_ptr = null ()) then	/* Couldn't find anything, punt */
		call finished (code);
	end;

	else call find_log_idx_of_message ();

	call log_position_$prev_message (log_segment_ptr, log_message_ptr, log_read_data.damaged (log_idx));

	if (log_message_ptr = null ()) then do;		/* Not in that segment, try the previous one */
	     call look_for_log_segment ((log_idx + 1), log_read_data.n_segments); /* Search remaining ones */
	     if (log_segment_ptr = null ()) then
		call finished (error_table_$no_log_message);

	     call log_position_$prev_message (log_segment_ptr, log_message_ptr, log_read_data.damaged (log_idx));
	     if log_message_ptr = null ()		/* Still no one home? Must be an emptr segment. */
	     then call finished (error_table_$no_log_message);
	end;

	if log_read_data.allocate_copies
	then call short_hold_message (log_message_ptr);	/* input-output, replaces pointer with copy */

	P_log_message_ptr = log_message_ptr;
	call finished (0);
%page;

log_read_$position_sequence:
     entry (P_log_read_data_ptr, P_message_sequence, P_search_direction, P_log_message_ptr, P_code);

	call check_in_pointer;
	P_log_message_ptr = null ();

	if log_read_data.call_procedures then do;
	     call log_read_data.ev.position_sequence (log_read_data.reader_data_ptr, P_message_sequence,
		P_search_direction, P_log_message_ptr, code);
	     call finished (code);
	end;

	call sequence_search (P_search_direction);

	if log_read_data.allocate_copies
	then call short_hold_message (log_message_ptr);	/* input-output, replaces pointer with copy */

	P_log_message_ptr = log_message_ptr;
	if (log_message_ptr = null ()) then
	     call finished (error_table_$no_log_message);
	else call finished (0);
%page;

log_read_$position_time:
     entry (P_log_read_data_ptr, P_message_time, P_search_direction, P_log_message_ptr, P_code);

	call check_in_pointer;
	P_log_message_ptr = null ();

	if log_read_data.call_procedures then do;
	     call log_read_data.ev.position_time (log_read_data.reader_data_ptr, P_message_time,
		P_search_direction, P_log_message_ptr, code);
	     call finished (code);
	end;
	call time_search (P_search_direction);

	if log_read_data.allocate_copies
	then call short_hold_message (log_message_ptr);	/* input-output, replaces pointer with copy */

	P_log_message_ptr = log_message_ptr;
	if (log_message_ptr = null ()) then
	     call finished (error_table_$no_log_message);
	else call finished (0);
%page;

/**** This entrypoint may close and reopen the log, resetting
      the log_read_data_ptr.

      This entrypoint checks the in_service state of the log,
      and closes and reopens if it is not in service. */


log_read_$update:
     entry (P_message_sequence, P_log_read_data_ptr, P_log_message_ptr, P_code);

	call check_in_pointer;

	call update_procedure ();
	return;
%page;

log_read_$hold_message:
     entry (P_log_read_data_ptr, P_log_message_ptr);

	call check_in_pointer;

	if log_read_data.call_procedures then do;
	     call log_read_data.ev.hold_message (log_read_data.reader_data_ptr, P_log_message_ptr);
	     return;				/* DO NOT pass through finish, we have no output code */
	end;

	if log_read_data.allocate_copies
	then do;
	     log_message_ptr = lookup_message (P_log_message_ptr); /* demand that we have it someplace */
	     call hold_message (log_message_ptr, P_log_message_ptr); /* actual, copy */
	     if log_message_ptr = log_read_data.latest_message.actual_ptr
	     then log_read_data.latest_message = null (); /* To avoid having to make sure that the ref count is set to 2 */
	     if log_message_ptr = log_read_data.earlier_message.actual_ptr
	     then log_read_data.earlier_message = null ();/* To avoid having to make sure that the ref count is set to 2 */
	end;
	return;
%page;

log_read_$free_message:
     entry (P_log_read_data_ptr, P_log_message_ptr);

	call check_in_pointer;

	if log_read_data.call_procedures then do;
	     call log_read_data.ev.free_message (log_read_data.reader_data_ptr, P_log_message_ptr);
	     return;
	end;

	if log_read_data.allocate_copies then do;
	     call free_message (P_log_message_ptr);	/* search for the COPY */
	end;
	return;
%page;

log_read_$get_log_uid:
     entry (P_log_read_data_ptr, P_log_uid, P_code);

	call check_in_pointer;
	P_code = 0;
	P_log_uid = "0"b;

	if log_read_data.call_procedures then do;
	     call log_read_data.ev.get_log_uid (log_read_data.reader_data_ptr, P_log_uid, code);
	     call finished (code);
	end;

	call hcs_$get_uid_seg (log_read_data.segments (1).ptr,
	     P_log_uid, code);
	call finished (code);
%page;

log_read_$register:
     entry (P_log_read_data_ptr, P_process_id, P_event_channel, P_code);

	call check_in_pointer;

	if log_read_data.call_procedures then do;
	     call log_read_data.ev.register (log_read_data.reader_data_ptr, P_process_id, P_event_channel, code);
	     call finished (code);
	end;

	call log_wakeup_$register (log_read_data.segments (1).ptr, P_process_id, P_event_channel, code);
	call finished (code);
%page;

log_read_$deregister:
     entry (P_log_read_data_ptr, P_process_id, P_event_channel, P_code);

	call check_in_pointer;

	if log_read_data.call_procedures then do;
	     call log_read_data.ev.deregister (log_read_data.reader_data_ptr, P_process_id, P_event_channel, code);
	     call finished (code);
	end;

	call log_wakeup_$deregister (log_read_data.segments (1).ptr, P_process_id, P_event_channel, code);
	call finished (code);
%page;

sequence_search:
     procedure (P_after_sw);

declare  P_after_sw bit (1) aligned parameter;

declare  message_sequence fixed bin (35);
declare  found bit (1);


	message_sequence = P_message_sequence;

	call set_current_log (log_read_data.very_last_log_idx); /* update the last sequence number, messages may have arrived */
	log_read_data.very_last_sequence = log_segment.last_sequence;

	if P_after_sw then do;
	     if (message_sequence <= log_read_data.very_first_sequence) then do;
		call set_current_log (log_read_data.very_first_log_idx);
		log_message_ptr = null ();		/* Force position to first message */
		call log_position_$next_message (log_segment_ptr, log_message_ptr, ("0"b));
	     end;

	     else if (message_sequence > log_read_data.very_last_sequence) then
		log_message_ptr = null ();

	     else call search_for_sequence ();
	end;

	else if ^P_after_sw then do;
	     if (message_sequence >= log_read_data.very_last_sequence) then do;
		call set_current_log (log_read_data.very_last_log_idx);
		log_message_ptr = null ();		/* Force position to last message */
		call log_position_$prev_message (log_segment_ptr, log_message_ptr, ("0"b));
	     end;

	     else if (message_sequence < log_read_data.very_first_sequence) then
		log_message_ptr = null ();

	     else call search_for_sequence ();
	end;

	return;
%page;
/* This routine implements a binary search to find the particular message
   sequence number we want.  It may turn out that that sequence does not exist
   (due to message or log segments lost).  In that case we'll find an acceptable
   substitute consistant sith P_after_sw. */

search_for_sequence: procedure ();

declare  found bit (1);
declare  test_idx fixed bin;
declare  low_idx fixed bin;
declare  high_idx fixed bin;


	     log_message_ptr = null ();

/* We'll try the newest log segment.  If the sequence we're
   interested in is there, we can avoid the binary search.  The
   newest log is already initiated, so this isn't too expensive. */

	     call look_for_log_segment (log_read_data.very_last_log_idx, log_read_data.very_first_log_idx);
	     if log_idx = 0				/* all the log segments damaged? */
	     then return;
	     else if message_sequence >= log_segment.first_sequence & message_sequence <= log_segment.last_sequence
	     then goto call_log_position;		/* found it, now position to message */

/* set up for binary search */

	     found = "0"b;

	     low_idx = log_idx + 1;			/* skip one(s) we've already looked at */
	     high_idx = log_read_data.very_first_log_idx; /* last log in list (oldest) */

/* DBG call ioa_ ("Test sequence is ^d", message_sequence); /* DBG */
	     do while ((low_idx <= high_idx) & ^found);

		test_idx = divide ((high_idx - low_idx), 2, 17, 0) + low_idx;

/* Initiate the log segment whose index is test_idx.  We'll compare the
   first and last sequence number values against the sequence we're looking
   for.
   The internal proc "look_for_log_segment" is called to perform the
   initiation.  If the desired segment can't be initiated (i.e. it's damaged)
   look_for_log_segment will try the next in sequence automatically.  We
   tell it in which direction to search based upon P_after_sw.
   It may very well happen that look_for_log_segment will hit
   the end of the partition we're working with.  It that case, we'll adjust
   the partition and try again. */

		call look_for_log_segment (test_idx, high_idx);
		if log_idx = 0			/* unable to get any log segment? */
		then high_idx = test_idx;		/* get damaged segs out of partition */

/* See if what we're looking for is in this log segment.  If not, we must
   adjust the search partition to contain the range of log segments that are
   still candidates.  This will be the upper or lower half of the current
   partition.  Note the optimization in which we ignore those indicies between
   test_idx and log_idx, these are damaged log segments and should not be
   included in this partitioning. */

		else do;
						/* DBG call ioa_ ("Partition= ^d to ^d; test= ^d^[ *Actually ^d*^;^s^] (^d to ^d)",
						   low_idx, high_idx, test_idx, (test_idx^=log_idx), log_idx,
						   log_segment.first_sequence, log_segment.last_sequence);/*DBG */

		     if message_sequence >= log_segment.first_sequence & message_sequence <= log_segment.last_sequence
		     then found = "1"b;
		     else if message_sequence < log_segment.last_sequence
		     then low_idx = log_idx + 1;	/* partition to older half */
		     else high_idx = test_idx - 1;	/* partition to younger half */
		end;
	     end;


/* If we were unable to find a log segment that contains the desired sequence
   number, we must assume that number falls between a pair of existing log segments.
   One of the pair is at the index we currently hold.  Here we'll check to see
   if we really shouldn't be looking at the other of the pair.  The value of
   P_after_sw will help us decide. */

	     if ^found
	     then if P_after_sw
		then if message_sequence > log_segment.last_sequence
		     then do;
			test_idx = max (test_idx - 1, log_read_data.very_last_log_idx);
						/* pick up next younger log segment, if there is one */
			call look_for_log_segment (test_idx, log_read_data.very_last_log_idx);
		     end;
		     else ;			/* we've got the better choice already */

		else if message_sequence < log_segment.first_sequence
		then do;
		     test_idx = min (test_idx + 1, log_read_data.very_first_log_idx);
						/* pick up next older log segment, if there is one */
		     call look_for_log_segment (test_idx, log_read_data.very_first_log_idx);
		end;
		else ;				/* we've got the better choice already */
	     else ;

	     if log_segment_ptr = null ()
	     then return;				/* couldn't find anything good */

/* And finally we can have log_position_ get us to the specific message
   within the log segment. */

	     if message_sequence >= log_segment.first_sequence & message_sequence <= log_segment.last_sequence
	     then do;
call_log_position:
		call log_position_$find_sequence (log_segment_ptr, message_sequence, P_after_sw, log_message_ptr, ("0"b));
	     end;
	     else do;
						/* We won't have an exact match, get the first message in the
						   next log or the last message in the previous log. */
		if P_after_sw
		then call log_position_$next_message (log_segment_ptr, log_message_ptr, ("0"b));
		else call log_position_$prev_message (log_segment_ptr, log_message_ptr, ("0"b));
	     end;

	end search_for_sequence;


     end sequence_search;
%page;

set_entry_variable:
     procedure (P_entry_variable, P_procedure_name, P_entry_name);

declare  P_entry_variable variable entry parameter;
declare  P_entry_name char (*) parameter;
declare  P_procedure_name char (*) parameter;

RETRY:
	P_entry_variable = cv_entry_ (P_procedure_name || "$" || P_entry_name, codeptr (log_read_), code);
	if (code = 0) then return;

	call sub_err_ (code, "log_read_", ACTION_CAN_RESTART, null (), (0), "Failed to snap link to ^a$^a.", P_procedure_name, P_entry_name);
	go to RETRY;

     end set_entry_variable;
%page;

time_search:
     procedure (P_after_sw);

declare  P_after_sw bit (1) aligned parameter;

declare  message_time fixed bin (71);


	message_time = P_message_time;


	call set_current_log (log_read_data.very_last_log_idx); /* update our notion of the last time in the family */
	log_read_data.very_last_time = log_segment.last_time; /* since messages may have arrived */

	if P_after_sw then do;
	     if (message_time <= log_read_data.very_first_time) then do;
		call set_current_log (log_read_data.very_first_log_idx);
		log_message_ptr = null ();		/* Force position to first message */
		call log_position_$next_message (log_segment_ptr, log_message_ptr, ("0"b));
	     end;

	     else if (message_time > log_read_data.very_last_time) then
		log_message_ptr = null ();

	     else call search_for_time ();
	end;

	else if ^P_after_sw then do;
	     if (message_time >= log_read_data.very_last_time) then do;
		call set_current_log (log_read_data.very_last_log_idx);
		log_message_ptr = null ();		/* Force position to last message */
		call log_position_$prev_message (log_segment_ptr, log_message_ptr, ("0"b));
	     end;

	     else if (message_time < log_read_data.very_first_time) then
		log_message_ptr = null ();

	     else call search_for_time ();
	end;

	return;
%page;

/* This routine implements a binary search to find
   a message near the desired time.  Here we attempt to initiate as few log
   segments as possible.  Rather than peek at log_segment.last_time and
   log_segment.first_time we trust the segment time suffix. */

search_for_time: procedure;

declare  found bit (1);
declare  test_idx fixed bin;
declare  low_idx fixed bin;
declare  high_idx fixed bin;
declare  first_message_time fixed bin (71);


	     log_message_ptr = null ();

/* We'll first try the newest log segment.  If the time we're
   interested in is there, we can avoid the binary search.  The
   newest log is already initiated, so this isn't too expensive. */

	     call look_for_log_segment (log_read_data.very_last_log_idx, log_read_data.very_first_log_idx);
	     if log_idx = 0				/* all log segments damaged? */
	     then return;
	     else if message_time >= log_segment.first_time & message_time <= log_segment.last_time
	     then goto call_log_position;		/* found it, now position to message */

/* set up for binary search */

	     found = "0"b;

	     low_idx = log_idx + 1;			/* skip one(s) we've already looked at */
	     high_idx = log_read_data.very_first_log_idx; /* last log in list (oldest) */

/* DBG call ioa_ ("Test time is ^a.",
   date_time_$format ("date_time", message_time, "", ""));/* DBG */

	     do while ((low_idx <= high_idx) & ^found);

		test_idx = divide ((high_idx - low_idx), 2, 17, 0) + low_idx;

/* Get the time of the first message in this log segment.  We do this
   by looking at the time of the last message in the previous log segment.
   A side effect is that we'll always find a log segment in our search (since
   all times between very_first_time and very_last_time will be included).
   This happens regardless of missing log segments.  There is a chance that
   we'll get the wrong one this way, an extra check is made later - once the
   segment we select is initiated. */

		if test_idx < log_read_data.very_first_log_idx
		then first_message_time = log_read_data.segments (test_idx + 1).suffix_time + 1; /* this may be way off */
		else first_message_time = log_read_data.very_first_time;

/* DBG call ioa_ ("Partition= ^d to ^d; test= ^d (^a to ^a)",
   low_idx, high_idx, test_idx,
   date_time_$format ("date_time", first_message_time, "", ""),
   date_time_$format ("date_time",
   log_read_data.segments(test_idx).suffix_time, "", ""));/* DBG */

/* See if what we're looking for is in this log segment.  If not, adjust
   the search partition to include only those segments which are still
   possible candidates. */

		if message_time >= first_message_time & message_time <= log_read_data.segments (test_idx).suffix_time
		then found = "1"b;
		else if message_time < log_read_data.segments (test_idx).suffix_time
		then low_idx = test_idx + 1;		/* partition to older half */
		else high_idx = test_idx - 1;		/* partition to younger half */
	     end;


	     if ^found then return;			/* must always find a log segment */


/* Now get the log segment we've selected initiated.  Note that
   "look_for_log_segment" may give us something different.  This happens if the
   log we selected is damaged.  The direction of search for an undamaged log
   segment is determined by the value of P_after_sw. */

	     if P_after_sw
	     then call look_for_log_segment (test_idx, log_read_data.very_last_log_idx);
	     else call look_for_log_segment (test_idx, log_read_data.very_first_log_idx);


/* Now that we've actually got a log segment initiated we can check to see
   if our estimate re: log_segment.first_time (see first_message_time above) was
   OK.  We're only concerned if P_after_sw is false (implying backward searching). */

	     if ^P_after_sw
	     then if log_segment.first_time > message_time
		then if test_idx < log_read_data.very_first_log_idx
		     then do;
			test_idx = test_idx + 1;	/* go to previous log segment */
			call look_for_log_segment (test_idx, log_read_data.very_first_log_idx);
		     end;
		     else ;
		else ;
	     else ;

	     if log_segment_ptr = null ()
	     then return;				/* couldn't find anything good */

/* And finally we can have log_position_ get us to the specific message
   within the log segment. */

	     if message_time >= log_segment.first_time & message_time <= log_segment.last_time
	     then do;
call_log_position:
		call log_position_$find_time (log_segment_ptr, message_time, P_after_sw, log_message_ptr, ("0"b));
	     end;
	     else do;
						/* We won't have an exact match, get the first message in the
						   next log or the last message in the previous log. */
		if P_after_sw
		then call log_position_$next_message (log_segment_ptr, log_message_ptr, ("0"b));
		else call log_position_$prev_message (log_segment_ptr, log_message_ptr, ("0"b));
	     end;


	end search_for_time;

     end time_search;
%page;

find_log_idx_of_message:
     procedure ();

/* This procedure sets log_segment_ptr and log_idx to identify the log segment
   containing the log message we were passed as an argument.  If it's not
   the most recently used segment, a linear search is performed. */


	if (log_read_data.current_idx > 0) then
	     if (log_read_data.current_ptr = log_read_data.ptr (log_read_data.current_idx)) then
		if (segno (log_read_data.current_ptr) = segno (log_message_ptr)) then do;
		     log_idx = log_read_data.current_idx;
		     log_segment_ptr = log_read_data.current_ptr;
		     return;
		end;

	do log_idx = 1 to log_read_data.n_segments;
	     if (segno (log_read_data.ptr (log_idx)) = segno (log_message_ptr)) then do;
		call set_current_log (log_idx);	/* (re-)sets global log_idx, even though we have it here */
		return;
	     end;
	end;					/* of loop through segments */

/* If it's not one of the segments we know about, then it's flat wrong.
   Probably there is a better choice for status code, but this will do for now. */

	call finished (error_table_$fatal_error);

     end find_log_idx_of_message;
%page;

look_for_log_segment:
     procedure (P_start, P_finish);

/* This procedure sets log_segment_ptr and log_idx to identify the first segment
   it can initiate in the range specified. If none can be found, log_segment_ptr
   is set to null, log_idx to zero, and the caller gets to take appropriate action. */

declare  P_start fixed bin parameter;
declare  P_finish fixed bin parameter;

declare  increment fixed bin;
declare  test_idx fixed bin;


	if (P_start > P_finish) then			/* Force loop to proceed in right direction */
	     increment = -1;
	else increment = 1;

	code = 1;					/* Simulate DO ... UNTIL */
	do test_idx = P_start to P_finish by increment while (code ^= 0);
	     call initiate_log (test_idx);
	     if (code = 0) then log_idx = test_idx;	/* Remember the one that succeeded */
	end;

	if (code ^= 0) then				/* A zero invalidates the current log pointer */
	     call set_current_log (0);
	else call set_current_log (log_idx);		/* (re-)sets global log_idx, which is OK */

	return;
     end look_for_log_segment;
%page;

set_current_log:
     procedure (P_log_idx);

/* This procedure sets the values identifying the current log in log_read_data;
   these values are used solely as an optimization for find_log_idx_of_message.
   It also sets the global log_idx (often used as input) and log_segment_ptr values. */

declare  P_log_idx fixed bin parameter;


	if (P_log_idx = 0) then
	     log_segment_ptr = null ();
	else log_segment_ptr = log_read_data.ptr (P_log_idx);

	log_read_data.current_ptr = log_segment_ptr;
	log_read_data.current_idx = P_log_idx;

	log_idx = P_log_idx;

	return;
     end set_current_log;
%page;

initiate_log:
     procedure (P_idx);

declare  P_idx fixed bin parameter;


	if (log_read_data.damaged (P_idx)) then do;
	     code = error_table_$log_segment_damaged;
	     return;
	end;

	if (log_read_data.ptr (P_idx) ^= null ()) then do;
	     code = 0;				/* Indicate success */
	     return;
	end;

	call log_initiate_
	     (log_read_data.dname (P_idx), log_read_data.ename (P_idx), 10, log_read_data.ptr (P_idx), code);

	if (code ^= 0) then log_read_data.damaged (P_idx) = "1"b;

	return;
     end initiate_log;
%page;

get_complete_history:
     procedure ();

declare  new_log_read_data_ptr pointer;
declare  new_idx fixed bin;				/* NL */ declare saved_n_segments fixed bin;

/* This procedure is responsible for listing any remaining history
   for this log family-- it must be called every time we try to position
   before the beginning of the current history. It may change the value
   of log_read_data_ptr; however, because it only adds new entries at
   the end, it will NOT invalidate the current index into the log_read_data
   log array.  It is the calling routine's responsibility to pass the
   new version of log_read_data_ptr back to the caller, but since this
   routine is now called only at open time, this is not a problem. It
   will become a problem if the optimization to initiate only the first
   segment (until others are needed) is implemented. */


	if log_read_data.history_complete then return;	/* It's already happened */

	call log_list_history_$all
	     (log_read_data.ptr (1), log_read_data.ename (1), log_read_data.n_segments, new_log_read_data_ptr);

	if (new_log_read_data_ptr ^= null ()) then do;	/* There is some history, so replace our structure with it */
	     do new_idx = 1 to log_read_data.n_segments;
		new_log_read_data_ptr -> log_read_data.segments (new_idx) = log_read_data.segments (new_idx);
	     end;

/* Can't just copy the header, because that would copy log_read_data.n_segments,
   which still has the old value */

	     saved_n_segments = new_log_read_data_ptr -> log_read_data.n_segments;
	     new_log_read_data_ptr -> log_read_data.header = log_read_data.header;
	     new_log_read_data_ptr -> log_read_data.n_segments = saved_n_segments; /* NL */
	     system_area_ptr = get_system_free_area_ ();
	     free log_read_data_ptr -> log_read_data in (system_area);

	     log_read_data_ptr = new_log_read_data_ptr;
	     new_log_read_data_ptr = null ();
	end;

	log_read_data.history_complete = "1"b;		/* So we never have to go through this again */

	return;
     end get_complete_history;
%page;

MAIN_RETURN:
	return;
%page;

update_procedure:
     procedure ();

	log_message_ptr = P_log_message_ptr;
	if log_read_data.allocate_copies then log_message_ptr = lookup_message (log_message_ptr);

	if (log_message_ptr = null ()) then
	     call finished (error_table_$fatal_error);

	if log_read_data.call_procedures then do;
	     call log_read_data.ev.update (P_message_sequence, log_read_data.reader_data_ptr,
		P_log_message_ptr, code);
	     call finished (code);
	end;

	message_sequence = P_message_sequence;
	log_segment_ptr = setwordno (log_message_ptr, 0);
	call log_segment_$get_service_bit (log_segment_ptr, log_in_service, code);
	if code ^= 0 then call finished (code);
	if message_sequence >= log_segment.limits.first_sequence
	     & message_sequence <= log_segment.limits.last_sequence
	     & log_in_service then call finished (0);

	call log_read_$open (log_read_data.segments (1).dname, log_read_data.segments (1).ename,
	     new_log_read_data_ptr, code);
	if code ^= 0 then call finished (0);		/* leave well enough alone if this fails */

	call log_read_$position_sequence (new_log_read_data_ptr, message_sequence, "1"b /* here or later */,
	     log_message_ptr, code);			/* this recursive call will short-hold the one preserved message */
	if code ^= 0 then do;
	     call log_read_$close (new_log_read_data_ptr, (0));
	     call finished (0);
	end;

	if log_read_data.allocate_copies then		/* held messages cannot be held across an update */
						/* because the copy pointers cannot be preserved */
	     call free_held_messages;

	call log_read_$close (log_read_data_ptr, (0));
	log_read_data_ptr = new_log_read_data_ptr;

	P_log_read_data_ptr = log_read_data_ptr;
	P_log_message_ptr = log_message_ptr;
	call finished (0);
	return;

     end update_procedure;
%page;

short_hold_message:
     procedure (P_message_ptr);

declare  P_message_ptr pointer;
declare  mp pointer;
declare  node_ptr pointer;
declare  prev_node_ptr pointer;

	if P_message_ptr = null () then return;

	if log_read_data.earlier_message.actual_ptr ^= null ()
	then do;
	     call lookup_node (log_read_data.earlier_message.actual_ptr, node_ptr, prev_node_ptr);
	     if node_ptr ^= null ()
	     then call dereference_node (node_ptr, prev_node_ptr);
	     else free log_read_data.earlier_message.copy_ptr -> log_message;
	     log_read_data.earlier_message = null ();	/* in aggregate */
	end;

	log_read_data.earlier_message = log_read_data.latest_message; /* roll over ! */

	mp = P_message_ptr;
	call lookup_node (mp, node_ptr, (null ()));
	if node_ptr ^= null ()
	then do;
	     node_ptr -> log_held_message_node.reference_count = node_ptr -> log_held_message_node.reference_count + 1;
	     log_read_data.latest_message = node_ptr -> log_held_message_node.message;
	end;
	else do;
	     log_read_data.latest_message.actual_ptr = mp;
	     call allocate_copy (mp, log_read_data.latest_message.copy_ptr);
	end;
	P_message_ptr = log_read_data.latest_message.copy_ptr;
	return;
     end short_hold_message;

hold_message:
     procedure (P_message_ptr, P_message_copy_ptr);

declare  P_message_ptr pointer;
declare  P_message_copy_ptr pointer;
declare  mp pointer;
declare  node_ptr pointer;

	mp = P_message_ptr;

	call lookup_node (mp, node_ptr, (null ()));
	if node_ptr = null () then do;
	     node_ptr = new_node ();
	     node_ptr -> log_held_message_node.actual_ptr = mp;
	     node_ptr -> log_held_message_node.copy_ptr = P_message_copy_ptr;
	end;
	node_ptr -> log_held_message_node.reference_count = node_ptr -> log_held_message_node.reference_count + 1;
	return;
     end hold_message;

free_message:
     procedure (P_message_ptr);
declare  P_message_ptr pointer;

declare  mp pointer;
declare  prev_node_ptr pointer;
declare  node_ptr pointer;
declare  next_node_ptr pointer;

	mp = P_message_ptr;
	prev_node_ptr = null ();
	node_ptr = log_read_data.first_held_message_ptr;
	do while (node_ptr ^= null ());
	     if node_ptr -> log_held_message_node.copy_ptr = mp
	     then go to FOUND_NODE;
	     prev_node_ptr = node_ptr;
	     node_ptr = node_ptr -> log_held_message_node.next_ptr;
	end;

	call sub_err_ (0, "log_read_", ACTION_CAN_RESTART, null (), (0), "free_message failed to find message ^p on held list.", mp);
	return;


FOUND_NODE:
DEREFERENCE_COMMON:
	if node_ptr -> log_held_message_node.reference_count > 1
	then do;
	     node_ptr -> log_held_message_node.reference_count = node_ptr -> log_held_message_node.reference_count - 1;
	     return;
	end;


	free node_ptr -> log_held_message_node.copy_ptr -> log_message;
	next_node_ptr = node_ptr -> log_held_message_node.next_ptr;

	if prev_node_ptr ^= null () then prev_node_ptr -> log_held_message_node.next_ptr = next_node_ptr;
	else log_read_data.first_held_message_ptr = prev_node_ptr;
	if log_read_data.last_held_message_ptr = node_ptr
	then log_read_data.last_held_message_ptr = prev_node_ptr;

	free node_ptr -> log_held_message_node;
	return;

dereference_node:
     entry (P_node_ptr, P_prev_node_ptr);

declare  P_node_ptr pointer;
declare  P_prev_node_ptr pointer;

	prev_node_ptr = P_prev_node_ptr;
	node_ptr = P_node_ptr;
	go to DEREFERENCE_COMMON;

     end free_message;

lookup_node: procedure (P_message_ptr, P_node_ptr, P_prev_node_ptr);

declare  (P_message_ptr, P_node_ptr, P_prev_node_ptr) pointer;
declare  (mp, node_ptr, prev_node_ptr) pointer;

	mp = P_message_ptr;
	node_ptr = log_read_data.first_held_message_ptr;
	prev_node_ptr = null ();
	do while (node_ptr ^= null ());
	     if node_ptr -> log_held_message_node.actual_ptr = mp
	     then go to FOUND_NODE;
	     prev_node_ptr = node_ptr;
	     node_ptr = node_ptr -> log_held_message_node.next_ptr;
	end;
	P_node_ptr, P_prev_node_ptr = null ();
	return;

FOUND_NODE:
	P_node_ptr = node_ptr;
	P_prev_node_ptr = prev_node_ptr;
	return;
     end lookup_node;

new_node:
     procedure returns (pointer);

declare  node_ptr pointer;

	system_area_ptr = get_system_free_area_ ();
	allocate log_held_message_node in (system_area) set (node_ptr);
	node_ptr -> log_held_message_node.next_ptr = null ();
	node_ptr -> log_held_message_node.reference_count = 0;

	if log_read_data.first_held_message_ptr = null ()
	then do;
	     log_read_data.first_held_message_ptr,
		log_read_data.last_held_message_ptr = node_ptr;
	     return (node_ptr);
	end;

	log_read_data.last_held_message_ptr -> log_held_message_node.next_ptr = node_ptr;
	log_read_data.last_held_message_ptr = node_ptr;
	return (node_ptr);
     end new_node;

lookup_message:
     procedure (P_copy_ptr) returns (pointer);

declare  node_ptr pointer;
declare  P_copy_ptr pointer;
declare  mp pointer;

	mp = P_copy_ptr;
	if mp = null () then return (null ());
	if mp = log_read_data.latest_message.copy_ptr
	then return (log_read_data.latest_message.actual_ptr);
	if mp = log_read_data.earlier_message.copy_ptr
	then return (log_read_data.earlier_message.actual_ptr);

	node_ptr = log_read_data.first_held_message_ptr;
	do while (node_ptr ^= null ());
	     if mp = node_ptr -> log_held_message_node.copy_ptr
	     then return (node_ptr -> log_held_message_node.actual_ptr);
	     node_ptr = node_ptr -> log_held_message_node.next_ptr;
	end;
	call sub_err_ (error_table_$no_log_message, "log_read_", ACTION_CANT_RESTART, null (), (0), "Invalid message pointer ^p.", mp);
     end lookup_message;

allocate_copy:
     procedure (P_message_ptr, P_copy_ptr);

declare  (P_message_ptr, P_copy_ptr) pointer;
declare  caller_area area based (log_read_data.user_area_ptr);

	log_message_text_lth = P_message_ptr -> log_message.text_lth;
	log_message_data_class_lth = P_message_ptr -> log_message.data_class_lth;
	log_message_data_lth = P_message_ptr -> log_message.data_lth;
	allocate log_message in (caller_area) set (P_copy_ptr);
	P_copy_ptr -> log_message = P_message_ptr -> log_message;
	return;
     end allocate_copy;

free_held_messages:
     procedure;

declare  smp_this pointer;
declare  smp_next pointer;

	if log_read_data.latest_message.actual_ptr ^= null ()
	then do;
	     call lookup_node (log_read_data.latest_message.actual_ptr, smp_this, (null ()));
	     if smp_this = null ()			/* its NOT in the held chain */
	     then free log_read_data.latest_message.copy_ptr -> log_message;
	     log_read_data.latest_message = null ();
	end;

	if log_read_data.earlier_message.actual_ptr ^= null ()
	then do;
	     call lookup_node (log_read_data.earlier_message.actual_ptr, smp_this, (null ()));
	     if smp_this = null ()			/* its NOT in the held chain */
	     then free log_read_data.earlier_message.copy_ptr -> log_message;
	     log_read_data.earlier_message = null ();
	end;

	smp_this = log_read_data.first_held_message_ptr;
	do while (smp_this ^= null ());
	     free smp_this -> log_held_message_node.message.copy_ptr -> log_message;
	     smp_next = smp_this -> log_held_message_node.next_ptr;
	     free smp_this -> log_held_message_node;
	     smp_this = smp_next;
	end;
	return;
     end free_held_messages;
%page;

check_in_pointer:
     procedure;

	log_read_data_ptr = P_log_read_data_ptr;
	if log_read_data_ptr = null ()
	then call sub_err_ (error_table_$null_info_ptr, "log_read_", ACTION_CANT_RESTART, null (), (0), "Null log_read_data_ptr supplied.");
	if log_read_data.sentinel ^= LOG_READ_DATA_VERSION_SENTINEL
	then call sub_err_ (error_table_$badcall, "log_read_", ACTION_CANT_RESTART, null (), (0), "Invalid log_read_data_ptr supplied in call to log_read_.");
	return;
     end check_in_pointer;

finished:
     procedure (P_return_code);

declare  P_return_code fixed bin (35) parameter;


	P_code = P_return_code;
	goto MAIN_RETURN;

     end finished;

/* format: off */
%page; %include log_read_data;
%page; %include log_read_open_info;
%page; %include log_segment;
%page; %include log_message;
%page; %include sub_err_flags;

     end log_read_;
