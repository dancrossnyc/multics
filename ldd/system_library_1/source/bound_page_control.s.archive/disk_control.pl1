/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        *********************************************************** */

/* DISK_CONTROL - Device Control Module for Disks.
   coded 12/1/70 by N. I. Morris
   revised 7/1/73 - Lee J. Scheffler to add metering
   revised 12/73 by N. I. Morris to add DSU-191 disks.
   revised 4/8/74 by S.H.Webber to change lockptl metering code
   revised for new storage system - 3/27/75 by Noel I. Morris
   test_drive entry by Bernard Greenberg 4/9/76
   improved error handling by Noel I. Morris - 6/3/76
   bad channel removal added by Noel I. Morris - 8/16/77
   disk offline waiting added by Bernard Greenberg - 9/20/77
   changed to use reset status command in test_drive 2/1/79 by Michael R. Jordan
   modified for new seek optimization for MSU0500/1 devices 4/79 by Michael R. Jordan
   modified for io_manager conversion February 1981 by Chris Jones
   Modified July, 1981, WOS, to install Mike Jordan's fix to the 501 sector number
   overflow problem (too many sectors to represent in 20 bits).
   Modified February 1982 by C. Hornig for MR10 io_manager.
   Modified March 1982 by C. Hornig to unload disks.
   Modified March 1982 by J. Bongiovanni for queue_length_given_pvtx, new PVTE
   Modified July 1982 by J. Bongiovanni for read_sectors, write_sectors
   Modified June 1983 by Chris Jones for ioi rewrite
   Modified January 1984 by Chris Jones to add add_channel entry
   Modified April 1984 by T. Oke for system wide free_q.
   Modified April 1984 by T. Oke for dynamic channel table and the use of
   dskdcl_chans_per_subsys to define channel idx/subsystem relation.
   Modified May 1984 by T. Oke to save pvtx in queue entry for AZM analysis
   of queue.

   Modified for adaptive optimizer by T. Oke May 1984.
   Modified call_run to poll all sub-systems by T. Oke May 1984,
   Lossage counters moved to chantab and renamed.
   Modified to reset quentry.used in add_free_q by T. Oke November 1984.
   Modified Nov 26, 1984 by R. A. Fawcett to support dev 0 (fips). Also include
   Chris Jones's change for IMU-type detailed status delivery.
   Stepped zealousness of esd_reset_locks from "call call_run (sx)" to
   merely "call run" to prevent running un-reinitialized sub-systems.
   by T. Oke November 1984.
   Modified February 1985 by Chris Jones to allow a channel to be usurped if
   of its devices are deleted.
   Modified July 1985 by Paul Farley to correctly handle IMU style detailed status.
*/

/****^  HISTORY COMMENTS:
  1) change(85-09-09,Fawcett), approve(85-09-09,MCR6979),
     audit(85-12-02,CLJones), install(86-03-21,MR12.0-1033):
     Add support for dev
     0 FIPS, Chris Jones's change for IMU-type detailed status delivery.
  2) change(86-04-01,Fawcett), approve(86-04-11,MCR7383),
     audit(86-05-27,Coppola), install(86-07-17,MR12.0-1097):
     Add support for subvolumes, and 512_word_io, devices 3380 and 3390.
  3) change(86-07-24,Fawcett), approve(86-10-30,PBF7383),
     audit(86-11-18,Beattie), install(86-11-21,MR12.0-1223):
     Add an optional third line to the disk error message that gives the
     subvolume name and logical record/sector for use with the
     record_to_vtocx command.
  4) change(86-10-29,Fawcett), approve(86-11-14,MCR7571),
     audit(86-11-18,Beattie), install(86-11-21,MR12.0-1223):
     Check the ioi_used bit before trying to place channels back in operation.
  5) change(87-05-22,Fawcett), approve(87-05-27,MCR7704),
     audit(87-07-08,Farley), install(87-07-17,MR12.1-1043):
     Move the check for the TEST type IO quentry. This allows the secondary
     channels to be used if the primary is down.
  6) change(87-05-27,Fawcett), approve(87-05-27,MCR7704),
     audit(87-07-08,Farley), install(87-07-17,MR12.1-1043):
     Set the "substat" variable to ANY so that matches in the disk_error_data
     segment can be found for such things as I/O system faults. Also display
     the I/O system fault word on the console.
  7) change(87-08-31,Fawcett), approve(87-08-31,PBF7704),
     audit(87-08-31,Farley), install(87-09-01,MR12.1-1095):
     Change to correct a bug in the sub-status reporting in the above fix.
  8) change(88-02-23,Farley), approve(88-02-23,MCR7759),
     audit(88-02-24,Fawcett), install(88-03-01,MR12.2-1029):
     Changed to set a new flag in the error code "all_paths_bad" and to give up
     if only one channel left and it is bad. At this time it will only be
     implemented for bootload_io. This is I/O done for BCE commands.
  9) change(88-02-23,Farley), approve(88-02-23,MCR7793),
     audit(88-02-24,Fawcett), install(88-03-01,MR12.2-1029):
     Changed the handle_error procedure to only display/retry TEST I/O errors
     when they are of the bad_path variety.  The retry will be done by removing
     the suspected bad path and re-queuing the I/O.  If bad_path error on all
     paths, set the device inoperative and post the I/O. Same during esd.
 10) change(88-03-18,Farley), approve(88-03-18,MCR7858),
     audit(88-04-11,Fawcett), install(88-04-19,MR12.2-1037):
     Changed disk_inter entry to set io_status_entry_ptr for all interrupt
     levels that will be processed.  A null ptr fault was occuring with level-1
     system faults.  Changed bad_dev error handling to set pvte inop when doing
     TEST I/O during an ESD.
 11) change(88-05-12,Farley), approve(88-06-03,MCR7906),
     audit(88-08-03,Fawcett), install(88-08-08,MR12.2-1080):
     Added a reconnect_announce_time variable to chantab to announce reconnect
     attempts the first time and every thirty seconds thereafter, until the I/O
     is successful.  All other times the messages will go only to the log as
     they normally do.  Also added I/O type to message.
 12) change(89-06-23,Farley), approve(89-07-26,MCR8122),
     audit(89-09-11,WAAnderson), install(89-09-22,MR12.3-1072):
     Added functionality to interpret_status and printerr procedures to
     seperate FIPS disk statuses from all others by checking the pvte.is_sv
     flag and using new fields in disk_error_data.  Also changed printerr to
     check the new "just_log" flag in disk_error_data.
 13) change(90-06-27,WAAnderson), approve(90-08-28,MCR8188),
     audit(90-09-21,Schroth), install(90-10-01,MR12.4-1035):
     Fix bug in esd_reset_locks and handle_error that caused ESD to fail.
                                                   END HISTORY COMMENTS */

/*
   ERROR RECOVERY STRATEGY

   When a fatal error is detected by  the  disk  DIM,  the
   drive  involved is placed in a temporarily inoperative state.  If
   the drive corrects the problem by itself within  several  seconds
   and  sends  a special interrupt, the drive will be placed back in
   operation.  If no special is received within the  several  second
   time  limit, the DIM will attempt to use the drive once more.  If
   it generates another fatal error, the drive  will  be  placed  in
   broken  state.   The DIM will attempt to use a broken drive every
   several minutes.  The  receipt  of  a  special  interrupt,  or  a
   successful  attempt  to use a broken drive, will place that drive
   back in operation.  Read requests that are queued  for  a  broken
   drive  will  be posted as errors.  Write requests will be left in
   the queue and ignored util the broken drive  becomes  operational
   again.

*/

/* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
disk_control:
     proc;

dcl	a_pvtx		   fixed bin;		/* index of PVT entry */
dcl	a_coreadd		   fixed bin (24);		/* absolute core address */
dcl	a_devadd		   bit (18) aligned;	/* secondary storage device address */
dcl	a_intrpt		   fixed bin (1);		/* non-zero if completion interrupt desired */
dcl	a_queue_length	   fixed bin;		/* current number of elements in Q */
dcl	a_sect_off	   fixed bin (4);		/* sector offset for single sector requests */
dcl	a_n_sectors	   fixed bin;		/* number of sectors for sector I/O */

dcl	pvtx		   fixed bin;		/* copied args to prevent page faults */
dcl	coreadd		   fixed bin (24);
dcl	sect_off		   fixed bin (4);
dcl	n_sectors		   fixed bin;
dcl	record_offset	   fixed bin;

/* Local Automatic storage. */

dcl	bootload_sw	   bit (1) aligned;		/* set if I/O is being done for bootload Multics */
dcl	call_run_sx	   fixed bin;		/* a_sx saved in call_run */
dcl	channel_time	   fixed bin (52);		/* time channel spent doing I/O */
dcl	command		   bit (6) aligned;		/* peripheral device command */
dcl	cylinder		   fixed bin (12);		/* cylinder heads are currently on */
dcl	dcdcwp		   ptr;			/* pointer to data xfer IDCW */
dcl	dddcwp		   ptr;			/* pointer to data xfer DCW */
dcl	dev		   unsigned fixed bin (6);	/* disk device code */
dcl	devadd		   fixed bin (18);		/* record number part of device address */
dcl	dev_count		   fixed bin;		/* counter in getwork */
dcl	entry_time	   fixed bin (52);		/* time of call */
dcl	errcd		   fixed bin (35);		/* error code to page control */
dcl	i		   fixed bin;		/* usually channel index */
dcl	intrpt		   bit (1);		/* if interrupt required */
dcl	io_type		   fixed bin;		/* type of IO */
dcl	lcp		   ptr;			/* local channel pointer in handle_error */
dcl	level		   fixed bin (3);		/* level of interrupt from IOM */
dcl	majstat		   fixed bin (5);		/* extended major status */
dcl	mask		   fixed bin (71) aligned;	/* temp for wire and mask */
dcl	masked		   bit (1);		/* running masked */
dcl	meter_start_time	   fixed bin (52);		/* time of attempt to lock */
dcl	name_rel		   fixed bin (17);		/* rel offset of the disk_error_data ascii names */
dcl	pdi		   fixed bin (6) unsigned;	/* Primary Device Index. */
dcl	post_sw		   bit (1) aligned;		/* "1"b if posting must be done */
dcl	ptp		   ptr;			/* temp for wire_and_mask */
dcl	qrp		   bit (18) aligned;	/* rel ptr to queue entry */
dcl	qx		   fixed bin (8);		/* index to queue entry */
dcl	required		   bit (1) aligned;		/* "1"b if IOI requires specific channel */
dcl	sector		   fixed bin (21);		/* physical disk sector */
dcl	sect_sw		   bit (1);		/* if sector IO */
dcl	stat		   bit (36) aligned;	/* copy of special or fault status word */
dcl	status_time	   fixed bin (52);		/* time status received */
dcl	sx		   fixed bin (8);		/* index of disk subsystem */
dcl	sysc		   fixed bin;		/* syserr report code */
dcl	substat		   bit (6) aligned;		/* substatus */
dcl	temp_time		   fixed bin (52);		/* for real time looping on inop chnl errors */
dcl	usurped		   bit (1) aligned;		/* "1"b if IOI usurped channel successfully */
dcl	wait_time		   fixed bin (52);		/* time from queuing to I/O completion */

dcl	1 msg_buf		   like io_msg aligned;	/* for syserr data */

dcl	1 stat_entry	   like io_status_entry;	/* the whole disaster */

dcl	error_table_$bad_arg   fixed bin (35) ext static;
dcl	error_table_$io_configured
			   fixed bin (35) ext static;

dcl	pds$processid	   ext bit (36);
dcl	page_fault$disk_offline_event
			   bit (36) aligned ext;
dcl	tc_data$system_shutdown
			   ext fixed bin;

dcl	ANY		   bit (6) init ("000000"b) static options (constant);
						/* used for substatus that will match on any */
dcl	(
	BOTH		   init ("1"b),
	SINGLE		   init ("0"b),
	ON		   init ("1"b),
	OFF		   init ("0"b),
	SUCCESS		   init ("1"b),
	FAILURE		   init ("0"b)
	)		   bit (1) aligned static options (constant);
dcl	IDCW		   bit (3) init ("7"b3) static options (constant);
dcl	(
	WRITE		   init ("31"b3),
	READ		   init ("25"b3),
	RESET_STATUS	   init ("40"b3),
	UNLOAD		   init ("72"b3)
	)		   bit (6) static options (constant);
dcl	UNLOCK		   bit (36) aligned init ((36)"0"b) static options (constant);
dcl	(
	ANNOUNCE_RECONNECT_DELTA
			   fixed bin (35) init (30000000),
						/* thirty seconds for reconnect announce throttling */
	DISK_POLLING_TIME	   fixed bin (35) init (2000000),
						/* two seconds for lost interrupt */
	INOP_POLLING_TIME	   fixed bin (35) init (5000000),
						/* five seconds for dropping out of ready */
	BROKEN_POLLING_TIME	   fixed bin (35) init (180000000),
						/* three minutes for standby */
	CHANNEL_POLLING_TIME   fixed bin (35) init (60000000)
						/* one minute for bad channel */
	)		   static options (constant);

dcl	bootload_disk_post	   entry (fixed bin (24), fixed bin (35));
dcl	seek_512		   bit (6) init ("30"b3) static options (constant);
dcl	syserr		   entry options (variable);
dcl	syserr$binary	   entry options (variable);
dcl	pxss$notify	   entry (bit (36) aligned);
dcl	page$done		   entry (fixed bin (24), fixed bin (35));
dcl	pmut$wire_and_mask	   entry (fixed bin (71) aligned, ptr);
dcl	pmut$unwire_unmask	   entry (fixed bin (71) aligned, ptr);
dcl	dctl$disk_inter	   entry (fixed bin (35), fixed bin (3), bit (36) aligned);
dcl	vtoc_interrupt	   entry (fixed bin (24), fixed bin (35));
dcl	ioi_masked$online_device_count
			   entry (char (*)) returns (fixed bin);
dcl	ioi_masked$interrupt   entry (fixed bin (35), fixed bin (3), bit (36) aligned);

dcl	(abs, addr, addrel, bin, bit, clock, convert, divide, fixed, float, lbound, length, hbound, max, mod, null, ptr,
	rel, stacq, string, substr, unspec)
			   builtin;

dcl	ME		   char (16) static options (constant) init ("disk_control");

dcl	dev_mask		   (0:63) bit (72) aligned static options (constant)
			   init ("100000000000000000000000000000000000000000000000000000000000000000000000"b,
			   "010000000000000000000000000000000000000000000000000000000000000000000000"b,
			   "001000000000000000000000000000000000000000000000000000000000000000000000"b,
			   "000100000000000000000000000000000000000000000000000000000000000000000000"b,
			   "000010000000000000000000000000000000000000000000000000000000000000000000"b,
			   "000001000000000000000000000000000000000000000000000000000000000000000000"b,
			   "000000100000000000000000000000000000000000000000000000000000000000000000"b,
			   "000000010000000000000000000000000000000000000000000000000000000000000000"b,
			   "000000001000000000000000000000000000000000000000000000000000000000000000"b,
			   "000000000100000000000000000000000000000000000000000000000000000000000000"b,
			   "000000000010000000000000000000000000000000000000000000000000000000000000"b,
			   "000000000001000000000000000000000000000000000000000000000000000000000000"b,
			   "000000000000100000000000000000000000000000000000000000000000000000000000"b,
			   "000000000000010000000000000000000000000000000000000000000000000000000000"b,
			   "000000000000001000000000000000000000000000000000000000000000000000000000"b,
			   "000000000000000100000000000000000000000000000000000000000000000000000000"b,
			   "000000000000000010000000000000000000000000000000000000000000000000000000"b,
			   "000000000000000001000000000000000000000000000000000000000000000000000000"b,
			   "000000000000000000100000000000000000000000000000000000000000000000000000"b,
			   "000000000000000000010000000000000000000000000000000000000000000000000000"b,
			   "000000000000000000001000000000000000000000000000000000000000000000000000"b,
			   "000000000000000000000100000000000000000000000000000000000000000000000000"b,
			   "000000000000000000000010000000000000000000000000000000000000000000000000"b,
			   "000000000000000000000001000000000000000000000000000000000000000000000000"b,
			   "000000000000000000000000100000000000000000000000000000000000000000000000"b,
			   "000000000000000000000000010000000000000000000000000000000000000000000000"b,
			   "000000000000000000000000001000000000000000000000000000000000000000000000"b,
			   "000000000000000000000000000100000000000000000000000000000000000000000000"b,
			   "000000000000000000000000000010000000000000000000000000000000000000000000"b,
			   "000000000000000000000000000001000000000000000000000000000000000000000000"b,
			   "000000000000000000000000000000100000000000000000000000000000000000000000"b,
			   "000000000000000000000000000000010000000000000000000000000000000000000000"b,
			   "000000000000000000000000000000001000000000000000000000000000000000000000"b,
			   "000000000000000000000000000000000100000000000000000000000000000000000000"b,
			   "000000000000000000000000000000000010000000000000000000000000000000000000"b,
			   "000000000000000000000000000000000001000000000000000000000000000000000000"b,
			   "000000000000000000000000000000000000100000000000000000000000000000000000"b,
			   "000000000000000000000000000000000000010000000000000000000000000000000000"b,
			   "000000000000000000000000000000000000001000000000000000000000000000000000"b,
			   "000000000000000000000000000000000000000100000000000000000000000000000000"b,
			   "000000000000000000000000000000000000000010000000000000000000000000000000"b,
			   "000000000000000000000000000000000000000001000000000000000000000000000000"b,
			   "000000000000000000000000000000000000000000100000000000000000000000000000"b,
			   "000000000000000000000000000000000000000000010000000000000000000000000000"b,
			   "000000000000000000000000000000000000000000001000000000000000000000000000"b,
			   "000000000000000000000000000000000000000000000100000000000000000000000000"b,
			   "000000000000000000000000000000000000000000000010000000000000000000000000"b,
			   "000000000000000000000000000000000000000000000001000000000000000000000000"b,
			   "000000000000000000000000000000000000000000000000100000000000000000000000"b,
			   "000000000000000000000000000000000000000000000000010000000000000000000000"b,
			   "000000000000000000000000000000000000000000000000001000000000000000000000"b,
			   "000000000000000000000000000000000000000000000000000100000000000000000000"b,
			   "000000000000000000000000000000000000000000000000000010000000000000000000"b,
			   "000000000000000000000000000000000000000000000000000001000000000000000000"b,
			   "000000000000000000000000000000000000000000000000000000100000000000000000"b,
			   "000000000000000000000000000000000000000000000000000000010000000000000000"b,
			   "000000000000000000000000000000000000000000000000000000001000000000000000"b,
			   "000000000000000000000000000000000000000000000000000000000100000000000000"b,
			   "000000000000000000000000000000000000000000000000000000000010000000000000"b,
			   "000000000000000000000000000000000000000000000000000000000001000000000000"b,
			   "000000000000000000000000000000000000000000000000000000000000100000000000"b,
			   "000000000000000000000000000000000000000000000000000000000000010000000000"b,
			   "000000000000000000000000000000000000000000000000000000000000001000000000"b,
			   "000000000000000000000000000000000000000000000000000000000000000100000000"b);

/* format: off */
/* Assumptions:

Several variables are expected to be correct through most of this program:

   dev	Device index of the devtab entry for the current device.
   dp	Devtab Pointer, indicates the current devtab to be operating upon.
	It is typically set from addr (disktab.devtab (pdi)).
   pdi	Primary Device Index of the current dev.  Found in devtab.pdi
          Used to determine primary device of shared devices.  The primary
	device will hold queue for all its shared spindles.
   sect_sw Sector switch indication for the current IO to be entered into a
	quentry (operation entry points), or when posting a completed IO.
	Major importance when posting an IO, since it must be correct for
	the coreadd being posted.
   sx	Subsystem index.  Indicates which subsystem is in use, in order of
	definition of subsystems in the config_file.

     When a disk interrupt is received, we take info on dev, pdi, coreadd,
sect_sw from the entry in check_stat.  These should not be messed with, since
check_stat will also return the queue element to the free_q and will call
getwork to start fresh IO on the channel ASAP.  Sect_sw and coreadd must still
be good at post time.

     Since on shared devices, a single pdi's queue will hold requests for more
than a single device, the dev value is recovered from the selected queue in
getwork (after xfer_join) to ensure we know who we are dealing with.

     Add_wq will add the new request to the queue of the pdi, but will do the
appropriate statistics (other than queue stats) on the device (dev).  Same with
del_q.
*/
/* format: on */

/* Entry points to generate disk requests.  Setup the type of the IO and then
   enter common code to process entry conditions.  If we are doing testing or
   VTOCE IO, then we have to wire and mask.  If doing PAGE IO, then we are
   wired and masked. */


write_sectors:
     entry (a_pvtx, a_coreadd, a_devadd, a_sect_off, a_n_sectors);

	io_type = VTOC_WRITE;
	goto go_sector;


read_sectors:
     entry (a_pvtx, a_coreadd, a_devadd, a_sect_off, a_n_sectors);

	io_type = VTOC_READ;
go_sector:
	devadd = bin (a_devadd, 18);			/* copy device address */
	coreadd = a_coreadd;			/* copy core address */

	sect_off = a_sect_off;			/* setup offset */
	n_sectors = a_n_sectors;
	goto go_masked;				/* Enter masked env */


test_drive:
     entry (a_pvtx);				/* test drive by issuing RSS */

	io_type = TEST;
	coreadd = bin (RESET_STATUS, 24);		/* Device TEST command */
	goto go_test;



unload_drive:
     entry (a_pvtx);				/* cycle down a drive */

	io_type = TEST;
	coreadd = bin (UNLOAD, 24);			/* Device UNLOAD command */
go_test:
	sect_off = 0;				/* no offset if TEST */
	n_sectors = 0;				/* no sectors if TEST */
	devadd = 0;				/* no core if TEST */

/* Sector and Test IO must be masked and have the stack wired. */

go_masked:
	call pmut$wire_and_mask (mask, ptp);		/* mask for processing */
	masked = "1"b;				/* so we unmask */
	intrpt = "0"b;
	goto go_common;


/* Write/Read a Virtual Memory Page between Disk and a Memory Frame. */

disk_write:
     entry (a_pvtx, a_coreadd, a_devadd, a_intrpt);

	io_type = PAGE_WRITE;
	goto go_page;

disk_read:
     entry (a_pvtx, a_coreadd, a_devadd, a_intrpt);

	io_type = PAGE_READ;
go_page:
	masked = "0"b;				/* run unmasked */
	devadd = bin (a_devadd, 18);			/* copy device address */
	coreadd = a_coreadd;			/* copy core address */
	sect_off = 0;				/* no sector offset */
	n_sectors = 0;
	if a_intrpt ^= 0 then
	     intrpt = "1"b;				/* completion interrupt */
	else intrpt = "0"b;

/* Initialize indices and pointers and lock database.  Then do operation. */


go_common:
	entry_time = clock ();
	sect_sw = sector_map (io_type);
	bootload_sw = bootload_map (io_type);
	pvtep = addr (addr (pvt$array) -> pvt_array (a_pvtx));
						/* Get pointer to PVT entry for this device. */
	pvtdip = addr (pvte.dim_info);		/* Get pointer to DIM info. */
	sx = pvtdi.sx;				/* Extract index for this disk subsystem. */
	call setup;				/* Get pointers to data bases. */
	call lock (addr (disktab.call_lock_meters));	/* Lock the database. */

	dev = pvte.logical_area_number;		/* Get physical device number. */
	pdi = disktab.devtab (dev).pdi;		/* Get PDI. */
	dp = addr (disktab.devtab (pdi));		/* Get pointer to info for primary device. */

/* Test for device not to be used. */

	if devtab.abandoned then do;			/* If device is hopelessly broken ... */
	     errcd = 0;				/* Clear error code. */
	     if ^write_map (io_type) then do;		/* If about to read ... */
		erfp = addr (errcd);		/* Get pointer for mismatching dcl. */
		errflags.device_inoperative = "1"b;	/* Indicate read could not succeed. */
	     end;
	     call unlock;				/* Undo the lock. */
	     call post;				/* Pretend write was successful. */
	     go to call_exit;			/* Clean up and exit. */
	end;

/* Attempt to get free queue entry to fill in. */

	disktab.alloc_wait_meters.count = disktab.alloc_wait_meters.count + 1;
	if ^get_free_q () then do;			/* Try to grab a free queue entry. */
	     call lock_meter_start (addr (disktab.alloc_wait_meters));
	     do while (^get_free_q ());		/* Try to grab a free queue entry. */
		call call_run (sx);			/* If none, wait until some free up. */
	     end;					/* Note: run destroys value of pvtep */
	     call lock_meter_stop (addr (disktab.alloc_wait_meters));
	end;

/* Compute physical sector address from input info.  Physical sector result
   accounts for unused sectors per cylinder. */

	if pvte.is_sv then do;			/* convert the subvolume devadd to the real devadd */
	     record_offset = mod (devadd, pvte.records_per_cyl);
	     devadd = ((devadd - record_offset) * pvte.num_of_svs) + pvte.record_factor + record_offset;
	end;
	sector = devadd * sect_per_rec (pvte.device_type);/* raw sector. */
	cylinder = divide (sector, pvtdi.usable_sect_per_cyl, 12, 0);
	sector = sector + cylinder * pvtdi.unused_sect_per_cyl;
	sector = sector + sect_off;			/* sector offset, if any. */

/* Fill in the queue entry. */

	quentry.intrpt = intrpt;			/* completion? */
	quentry.used = "1"b;			/* in-use */
	quentry.type = io_type;			/* Type of IO */
	quentry.coreadd = bit (coreadd, 24);		/* Insert the memory address for data xfer. */

	quentry.pvtx = a_pvtx;			/* Save for azm */
	quentry.pdi = pdi;				/* Also save PDI for this device. */
	quentry.dev = dev;				/* Place device code in queue entry. */
	quentry.cylinder = cylinder;			/* And the cylinder number. */

	quentry.n_sectors = n_sectors;		/* And the number of sectors (sector I/O only) */
	quentry.sector = bit (sector, 21);		/* Save the disk device address. */

/* Record time for AZM and stagnation testing. */

	quentry.time = entry_time;

/* If this is the only request for this device, try to start up a free channel.
   Otherwise, queue the request for processing later. */

	if ^(disktab.dev_busy | disktab.dev_queued) & dev_mask (pdi) then
	     do i = 1 to disktab.nchan;		/* If device is free with no other requests ... */
	     cp = addr (ptr (disksp, disktab.channels) -> disk_channel_table (i));
						/* Try to find a channel to run. */
	     if chantab.in_use & ^chantab.active then do; /* If free usable channel ... */
		call gotwork;			/* Let's do this request. */
		go to working;			/* And exit the loop. */
	     end;
	end;

	call add_wq;				/* Add item to end of appropriate queue. */

/* Clean up and exit. */

working:
	call unlock;				/* Unlock the data base now. */

call_exit:
	if masked then
	     call pmut$unwire_unmask (mask, ptp);	/* Restore vtoc_man's environment */

	return;

/* ESD_RESET_LOCKS - Reset data base locks on emergency shutdown. */

esd_reset_locks:
     entry;

	disksp = addr (disk_seg$);

	unspec (disk_data.free_q) = "0"b;		/* clear free_q */
	disk_data.free_q.depth = disk_data.free_q_size;	/* empty queue */

/* This form of unlocking is used because it causes a load of "0"b and
   and ANSA instruction.  This will do a read/alter/re-write cycle and
   correctly update cache.  We cannot STACQ since it may not have been locked
   to our processid. */

	unspec (disk_data.lock) = unspec (disk_data.lock) & "0"b;

	do qx = 1 to disk_data.free_q_size;		/* Look at each queue entry. */
	     qp = addr (disk_data.free_q_entries (qx));
	     qrp = rel (qp);

	     call add_free_q;			/* Free all entries at ESD time. */
	end;

	do sx = 1 to disk_data.subsystems;
	     call setup;				/* Get pointer to subsystem data. */
	     call unlock;				/* Undo the lock. */

	     call lock (addr (disktab.call_lock_meters)); /* Set the lock to us. */

	     do dev = disktab.first_dev to disktab.last_dev;
						/* Clear each device. */
		dp = addr (disktab.devtab (dev));	/* Get pointer to info for device. */
		devtab.broken, devtab.was_broken, devtab.inop = "0"b;
						/* Try to use broken device. */
		devtab.cylinder = 0;		/* Reset positional info. */
		unspec (devtab.wq) = "0"b;		/* Clear queue pointers */

/* reset optimizer queue depth to reflect empty queues. */

		do i = 0 to MAX_IO_TYPE;
		     devtab.forward = "1"b;
		     devtab.opt_info (i).depth = 0;
		end;
	     end;

	     cp = ptr (disksp, disktab.channels);	/* Get pointer to channel table. */
	     do i = 1 to disktab.nchan;		/* Iterate through all channels. */
		cp -> disk_channel_table (i).active = "0"b;
						/* Mark all channels as not busy. */
		cp -> disk_channel_table (i).inop = "0"b;
						/* Mark as operative */
		cp -> disk_channel_table (i).broken = "0"b;
						/* Mark as not broken */
                    if ^(cp -> disk_channel_table (i).ioi_use) &
                       ^(cp -> disk_channel_table (i).in_use) then do;
                        cp -> disk_channel_table (i).in_use = "1"b;
                        disktab.channels_online = disktab.channels_online+1;
		  end;     
		cp -> disk_channel_table (i).erct = 0;	/* clear error count */
	     end;

	     disktab.dev_busy = "0"b;			/* Clear busy device flags. */
	     disktab.dev_queued = "0"b;		/* Clear request queued flags. */

	     call run;				/* Start this subsystem rolling. */
	     call unlock;				/* Undo the lock. */
	end;

	return;

/* USURP_CHANNEL/CEDE_CHANNEL - Share disk channels with IOI. */

usurp_channel:
     entry (a_sx, a_chx, a_required, a_iom_chx, a_statusp); /* Entry to usurp channel for IOI use. */

dcl	a_sx		   fixed bin (8);		/* disk subsystem index */
dcl	a_chx		   fixed bin (35);		/* disk channel index */
dcl	a_required	   bit (1) aligned;		/* "1"b if specific channel required */

dcl	chx		   fixed bin (35);		/* chx as an integer */

	sx = a_sx;				/* Copy subsystem index. */
	required = a_required;			/* Copy argument. */
	chx = a_chx;				/* copy chx */
	call setup;				/* Get appropriate pointers. */
	cp = addr (ptr (disksp, disktab.channels) -> disk_channel_table (chx));
						/* Get pointer to chantab entry. */

	call pmut$wire_and_mask (mask, ptp);		/* Wire stack and mask interrupts. */
	call lock (addr (disktab.call_lock_meters));	/* Lock the disk database. */

	usurped = (required | ^(chantab.broken | chantab.inop)) &
						/* Usurp if required or not defective channel, and ... */
	     ((disktab.channels_online > 1) | ^chantab.in_use
	     | (ioi_masked$online_device_count (disk_data.name (sx)) = 0));
						/* Ensure last good channel will not be usurped. */

	if usurped then do;				/* If we may, usurp the channel. */
	     if chantab.in_use then			/* If channel is being used, count it out. */
		disktab.channels_online = disktab.channels_online - 1;
	     chantab.in_use = "0"b;			/* Take channel out of operation. */
	     chantab.broken, chantab.inop = "0"b;	/* Clear flags. */
	end;

	call unlock;				/* Unlock the disk database. */
	call pmut$unwire_unmask (mask, ptp);		/* Unwire stack and unmask interrupts now. */

	if usurped then do;				/* If channel now usurped ... */
	     do while (chantab.active);		/* Wait for I/O to stop. */
	     end;
	     a_iom_chx = chantab.chx;
	     a_statusp = chantab.statusp;
	     chantab.ioi_use = "1"b;			/* Now allow IOI to use channel. */
	end;
	else do;
	     a_iom_chx = 0;
	     a_statusp = null ();
	end;

	return;

cede_channel:
     entry (a_sx, a_chx, a_iom_chx, a_statusp);		/* Entry to cede channel from IOI use. */

dcl	a_iom_chx		   fixed bin (35) parameter;
dcl	a_statusp		   ptr parameter;

dcl	iom_chx		   fixed bin (35);
dcl	statusp		   ptr;

	sx = a_sx;				/* Copy subsystem index. */
	chx = a_chx;				/* copy chx */
	iom_chx = a_iom_chx;
	statusp = a_statusp;
	call setup;				/* Get appropriate pointers. */
	cp = addr (ptr (disksp, disktab.channels) -> disk_channel_table (chx));
						/* Get pointer to chantab entry. */

	chantab.chx = iom_chx;
	chantab.statusp = statusp;
	chantab.ioi_use = "0"b;			/* Take channel back from IOI. */
	chantab.in_use = "1"b;			/* Place channel back in operation. */
	disktab.channels_online = disktab.channels_online + 1;

	return;

/* Entry to manually add a deleted channel */

add_channel:
     entry (a_sx, a_chx, a_code);

dcl	a_code		   fixed bin (35) parameter;

	sx = a_sx;
	chx = a_chx;
	call setup;
	cp = addr (ptr (disksp, disktab.channels) -> disk_channel_table (chx));
	call pmut$wire_and_mask (mask, ptp);
	call lock (addr (disktab.call_lock_meters));
	if chantab.broken then do;
	     chantab.broken = "0"b;
	     chantab.in_use = "1"b;
	     disktab.channels_online = disktab.channels_online + 1;
	end;
	else errcd = error_table_$io_configured;
	call unlock;
	call pmut$unwire_unmask (mask, ptp);
	if errcd = 0 then
	     call syserr (ANNOUNCE, "^a: Adding channel ^a.", ME, chantab.chanid);
	a_code = errcd;
	return;

/* DISK_RUN - External entry to poll all disk subsystems. */

disk_run:
     entry;					/* here to keep going */

	entry_time = clock ();			/* get time of entry */

	disksp = addr (disk_seg$);			/* Get pointer to disk data base. */

	do sx = 1 to disk_data.subsystems;		/* Iterate through all disk subsystems. */
	     call setup;				/* Get pointers to data base. */
	     call lock (addr (disktab.run_lock_meters));	/* Lock the database. */
	     call run;				/* Now perform run operation. */
	     call unlock;				/* Unlock the data base when finished. */
	end;

	return;



/* CALL_RUN - Entry to poll a single disk subsystem. */

call_run:
     entry (a_sx);


	entry_time = clock ();

	sx = a_sx;				/* Copy the subsystem index. */
	call setup;
	call run;

/* run the other sub-systems too.  But now we have to lock them if possible. */

	call_run_sx = a_sx;				/* save sx to return to */
	do sx = 1 to disk_data.subsystems;
	     if sx ^= call_run_sx then do;
		call setup;
		if stacq (disktab.lock, pds$processid, UNLOCK) then do;
						/* locked it */
		     call run;
		     call unlock;
		end;
	     end;
	end;
	sx = call_run_sx;
	call setup;				/* restore sub-sys */
	return;

/* RUN - Internal entry to perform polling. */

run:
     proc;

/* Perform channel polling. */

	do i = 1 to disktab.nchan;			/* Iterate through all channels. */
	     cp = addr (ptr (disksp, disktab.channels) -> disk_channel_table (i));
						/* Generate pointer to channel info table. */

	     if chantab.inop & ^chantab.in_use then	/* If channel is inoperative ... */
		if clock () - chantab.connect_time > CHANNEL_POLLING_TIME then do;
		     chantab.in_use = "1"b;		/* Try once more. */
		     disktab.channels_online = disktab.channels_online + 1;
		end;

/* format: off */
/* Poll for disk completion.  This is required for allocation lock checks, and
   during run_locks from page control, since both are run masked, and this
   polling is the only way we would see disk completion.  This race hazard
   on normal 15-seconds run_locks will produce some interrupts without
   terminate status, but you can't win them all.  It may also produce some
   situations of interrupt wile not active. */
/* format: on */

	     if ^chantab.active then			/* If channel is inactive ... */
		call getwork;			/* Fire it up. */

	     else do;				/* Attempt to pick up status. */
		status_time = clock ();		/* For reconnect test, NOT race */
		io_status_entry_ptr = addr (stat_entry);
		call io_manager$get_status ((chantab.chx), io_status_entry_ptr);
						/* See if any status has come in. */
		io_status_word_ptr = addr (stat_entry.word1);
		if /* case */ io_status_word.t then do; /* If status is present ... */
		     chantab.status_from_run = chantab.status_from_run + 1;
		     level = 3;			/* Set terminate status level. */
		     call check_stat;		/* Go examine the status. */

		     if post_sw then do;		/* If previous I/O must be posted ... */
			call unlock;		/* Don't call out with our lock set. */
			call post;		/* Do the posting. */
			call lock (addr (disktab.call_lock_meters));
						/* Relock our data base now. */
		     end;
		end;

		else if chantab.connect_time + DISK_POLLING_TIME < status_time then do;
						/* If an interrupt has been lost ... */
		     idcwp = addr (chantab.scdcw);	/* Find out device in operation. */
		     dev = fixed (idcw.device, 6);	/* .. */
		     pdi = disktab.devtab (dev).pdi;	/* Get PDI for this device. */
		     if chantab.reconnect_announce_time < status_time then do;
			chantab.reconnect_announce_time = status_time + ANNOUNCE_RECONNECT_DELTA;
			sysc = ANNOUNCE;
		     end;
		     else sysc = LOG;
		     call syserr (sysc, "^a: Reconnected ^a I/O on ^a (channel ^a).", ME,
			IO_TYPE (ptr (disksp, chantab.qrp) -> quentry.type), disk_name (SINGLE), chantab.chanid);
		     call connect (idcwp);		/* Reconnect */
		end;
	     end;
	end;


/* Perform device polling. */

	do dev = disktab.first_dev to disktab.last_dev;	/* Poll all devices. */
	     pdi = disktab.devtab (dev).pdi;		/* Get PDI for this device. */
	     if pdi = dev then do;			/* This is primary device. */
		dp = addr (disktab.devtab (pdi));	/* Get pointer to primary device info. */

		if /* case */ devtab.inop then	/* If device is inoperative ... */
		     if clock () - devtab.time_inop > INOP_POLLING_TIME then do;
			disktab.dev_busy = disktab.dev_busy & ^dev_mask (pdi);
		     end;				/* Try to use device again. */
		     else ;

		else if devtab.broken then		/* If device is broken ... */
		     if clock () - devtab.time_inop > BROKEN_POLLING_TIME then do;
			devtab.inop = "1"b;		/* Mark as inoperative again. */
			devtab.was_broken = "1"b;	/* .. */
			pvtep = addr (addr (pvt$array) -> pvt_array (devtab.pvtx));
			call set_pvte_inop (OFF);
			devtab.broken = "0"b;	/* Turn off broken flag. */
		     end;
		     else ;
	     end;
	end;

	return;


     end run;

/* DISK_INTER - This is the interrupt side of the disk DIM. */

disk_inter:
     entry (idx, ilevel, istat);			/* called by io_manager at interrupt time */

dcl	idx		   fixed bin (35),		/* channel ID index */
	istat		   bit (36) aligned,	/* status for specials or faults */
	ilevel		   fixed bin (3);		/* level of interrupt */

dcl	int_idx		   fixed bin (35);		/* idx as an integer */

	int_idx = idx;
	sx = divide (int_idx, dskdcl_chans_per_subsys, 17, 0);
						/* Get index of this disk subsystem. */
	call setup;				/* Get pointer to data base. */

	i = int_idx - sx * dskdcl_chans_per_subsys + 1;	/* Compute expected channel table index. */
	cp = addr (ptr (disksp, disktab.channels) -> disk_channel_table (i));

	level = ilevel;				/* copy the level */
	stat = istat;
	if level = 7 then do;
	     call check_special_stat;
	     return;
	end;


	io_status_word_ptr = chantab.statusp;		/* point to status */

	if ^io_status_word.t then
	     if level >= 3 then do;
		chantab.no_status_terminate = chantab.no_status_terminate + 1;
		return;
	     end;


	if ^chantab.ioi_use then do;			/* If terminate, marker, or fault ... */
	     call lock (addr (disktab.int_lock_meters));	/* Lock the database. */
	     io_status_entry_ptr = addr (stat_entry);	/* point to an area to return status */
	     unspec (io_status_entry) = ""b;
	     if /* case */ level = 3 then do;		/* Reget status, under lock */
		call io_manager$get_status ((chantab.chx), io_status_entry_ptr);
		io_status_word_ptr = addr (io_status_entry.word1);
		if ^io_status_word.t then do;
		     chantab.no_io_terminate = chantab.no_io_terminate + 1;
		     call unlock;
		     return;
		end;
	     end;
	     call check_stat;			/* Go process the status. */
	     call unlock;				/* Clear data base lock. */

	     if post_sw then			/* If posting previous operation ... */
		call post;
	end;

	else					/* If status for IOI channel ... */
	     call ioi_masked$interrupt ((chantab.ioi_ctx), level, stat);

	return;					/* And return to caller. */

check_special_stat:
     proc;

	io_special_status_ptr = addr (stat);		/* base our templates */
	if ^io_special_status.t then
	     return;

	dev = fixed (io_special_status.device, 6);	/* Extract device address from status. */
	if dev = 0 & disktab.first_dev ^= 0 then	/* If special for disk controller ... */
	     go to ioi_special;			/* Perhaps IOI wants this one, but we don't. */
	if dev > disktab.last_dev then
	     return;				/* Ignore this if number out-of-bounds. */

	dp = addr (disktab.devtab (dev));		/* Get pointer to device info structure. */
	pdi = devtab.pdi;				/* Get PDI. */

	pvtx = devtab.pvtx;				/* Get index to PVT entry for device. */
	if pvtx = 0 then
	     return;				/* This will occur when an MPC broadcasts
						   a special interrupt status to all LA's attached to
						   it, and the MPC controls more than one
						   subsystem as seen by the PVT. */
	pvtep = addr (pvt_array (pvtx));		/* Get pointer to PVT entry. */

	if pvte.storage_system then do;		/* If storage system volume ... */
	     call lock (addr (disktab.int_lock_meters));	/* Lock disk database. */

	     dp = addr (disktab.devtab (pdi));
	     if /* case */ devtab.broken then do;	/* If device declared broken ... */
		call syserr (ANNOUNCE, "^a: Placing ^a in operation.", ME, disk_name (BOTH));
		call set_pvte_inop (OFF);		/* Let ops get through */
		devtab.inop = "1"b;			/* Promote to inoperative state. */
		devtab.was_broken = "1"b;		/* .. */
		devtab.broken = "0"b;		/* Attempt to use device again. */
	     end;

	     else if devtab.inop then do;		/* If device is inoperative ... */
		devtab.inop = "0"b;			/* Attempt to place back in operation. */
		disktab.dev_busy = disktab.dev_busy & ^dev_mask (pdi);
	     end;

	     call call_run (sx);			/* Force run call on special interrupt. */

	     call unlock;				/* Undo the lock now. */
	end;

	else do;					/* If not storage system volume ... */
ioi_special:
	     call ioi_masked$interrupt ((chantab.ioi_ctx), level, stat);
	end;					/* Pass on the status to IOI. */

	return;

     end check_special_stat;

/* Pick up and examine the status. */

check_stat:
     procedure;

	errcd = 0;				/* Clear the error code */
	erfp = addr (errcd);
	post_sw = "0"b;				/* Clear posting required flag. */

	if ^chantab.active then do;			/* If channel wasn't active, whisper bloody murder. */
	     chantab.terminate_not_active = chantab.terminate_not_active + 1;
	     call syserr (JUST_LOG, "^a: Unexpected IOM status ^24.3b for ^a (channel ^a).", ME,
		string (io_status_word), disk_data.name (sx), chantab.chanid);
	     return;
	end;

	status_time = clock ();

	qrp = chantab.qrp;				/* Get pointer to queue entry. */
	qp = ptr (disksp, qrp);
	dev = quentry.dev;				/* Extract device address from queue entry. */
	pdi = quentry.pdi;				/* Get PDI for this request. */
	coreadd = bin (quentry.coreadd, 24);		/* Get memory address. */
	pvtx = quentry.pvtx;			/* Get PVT index. */
	sect_sw = sector_map (quentry.type);
	bootload_sw = bootload_map (quentry.type);

	pvtep = addr (addr (pvt$array) -> pvt_array (pvtx));
						/* Get pointer to PVT entry. */
	dp = addr (disktab.devtab (pdi));		/* Get pointer to primary device info structure. */


/* Remember this queue type entry so that we do the posting correctly. */

	io_type = quentry.type;


/* Process termination status. */

	if level = 3 then do;			/* If terminate status... */
	     chantab.active = "0"b;			/* Channel is no longer active. */
	     disktab.dev_busy = disktab.dev_busy & ^dev_mask (pdi);
						/* Indicate primary device no longer busy. */

/* Process completion of detailed status read. */

	     if /* case */ chantab.rsr then do;		/* If detailed status was just read ... */
		if (string (io_status_word) & disk_data.status_mask) then
						/* Don't print bad RSR's */
		     chantab.rsr = "0"b;		/* So clear this bit now. */
		unspec (io_status_entry.detailed_status (*)) = unspec (chantab.detailed_status (*));
						/* copy detail over */

		io_status_word_ptr = addr (chantab.status);
						/* Unsave previous error status. */
		command = chantab.command;		/* And previous device command. */
		call extract_status;		/* Extract status info anew. */
		call handle_error;			/* Now handle the error. */

		chantab.rsr = "0"b;			/* Turn off the bit. */
	     end;

/* Handle abnormal termination status. */

	     else if string (io_status_word) & disk_data.status_mask then do;
		call extract_status;		/* Extract status info from status word. */
		call interpret_status;		/* Get pointer to interp data. */
		call get_disk_command;		/* Extract peripheral command. */

		if disk_error_interp.rsr & (io_status_entry.detailed_status (1) = ""b) then do;
						/* If RSR required and none available ... */
		     chantab.rsr = "1"b;		/* Do it now. */
		     chantab.status = string (io_status_word);
						/* Save status info for after RSR. */
		     chantab.action_code = io_status_entry.action_code;
		     chantab.command = command;	/* Also the device command. */

		     idcwp = addr (chantab.dscdcw);
		     idcw.device = bit (dev);
		     call connect (idcwp);		/* Connect to RSR instruction. */
		end;

		else				/* If no RSR required ... */
		     call handle_error;		/* Handle error right now. */
	     end;

/* Test for nonzero tally residue in DCW. */

	     else if io_status_entry.tally_residue ^= 0 then do;
		majstat = 20;
		substat = ANY;
		call handle_error;			/* Treat like any other error. */
	     end;

/* Handle successful termination of disk operation. */

	     else do;				/* If we got here, operation was successful. */
		post_sw = "1"b;			/* Post the results. */

		if io_status_word.sub & "010011"b then do;
						/* If controller performed EDAC or auto retry ... */
		     disktab.edac_errors = disktab.edac_errors + 1;

		     if io_status_word.sub & "010000"b then
						/* If EDAC performed ... */
			majstat = 22;
		     else				/* If auto retries performed ... */
			majstat = 21;
		     substat = ANY;
		     call interpret_status;		/* Interpret status info. */
		     call get_disk_command ();	/* Get the command */
		     call printerr;			/* Enter message in syserr log. */
		end;

		devtab.inop = "0"b;			/* Clear this flag. */

		if devtab.was_broken | devtab.broken then do;
						/* Was disk previously inoperative? */
		     devtab.was_broken = "0"b;	/* Clear flag now. */
		     devtab.broken = "0"b;
		     call set_pvte_inop (OFF);
		     call syserr (ANNOUNCE, "^a: ^a now operational.", ME, disk_name (BOTH));
		end;
		chantab.inop = "0"b;		/* Clear this flag. */
	     end;

	end;					/* level 3 */

/* Handle system fault status. */

	else if level = 1 then do;			/* If system fault word  ... */
	     chantab.active = "0"b;			/* Channel is no longer active. */
	     disktab.dev_busy = disktab.dev_busy & ^dev_mask (pdi);
						/* Indicate device no longer busy. */
	     majstat = 19;
	     substat = ANY;
	     call handle_error;			/* Use standard error handler. */
	end;


	else return;				/* Ignore anything else. */

/* If no posting to be done, don't do any of the following. */

	if post_sw then do;
	     if io_type = TEST then do;
		pvte.testing = "0"b;
		post_sw = "0"b;
	     end;					/* Perform metering on completed I/O (whether successful or not). */
	     else do;
		status_time = clock ();		/* Get time now. */
		channel_time = status_time - chantab.connect_time;
						/* Compute time channel in use. */
		wait_time = status_time - quentry.time;

		optp = addr (devtab.opt_info (quentry.type));
						/* get opt_info */

		opt_info.channel_wait = opt_info.channel_wait + channel_time;
		opt_info.queue_wait = opt_info.queue_wait + wait_time;

/* Test for error */

		if errcd ^= 0			/* count a fatal error */
		     then
		     disktab.ferrors = disktab.ferrors + 1;
	     end;

	     call add_free_q;			/* Scrap queue entry now. */
	end;

	if ^chantab.active then			/* If channel is now free ... */
	     call getwork;				/* Look for more work to do. */

	return;					/* And return to caller. */

/* EXTRACT_STATUS - Extract major and substatus. */

extract_status:
	proc;

	     if /* case */ io_status_word.power then do;
		majstat = 16;
		substat = ANY;
	     end;
	     else if io_status_word.channel_stat then do;
		majstat = 17;
		substat = io_status_word.channel_stat;
	     end;
	     else if io_status_word.central_stat then do;
		majstat = 18;
		substat = io_status_word.central_stat;
	     end;
	     else do;
		majstat = bin (io_status_word.major, 4);
		substat = io_status_word.sub;
	     end;


	end extract_status;



/* INTERPRET_STATUS - Get interpretive info for status. */

interpret_status:
	proc;


	     dedp = addr (disk_error_data$);
	     if pvte.is_sv then
		dskerap = addrel (dedp, disk_error_data (majstat).finterp);
	     else dskerap = addrel (dedp, disk_error_data (majstat).interp);

/***** find first description, which is just after last used substatus array entry */
	     name_rel = fixed (rel (addrel (dedp, disk_error_data (lbound (disk_error_data, 1)).namep)), 17);
	     dskerp = addr (disk_status_interp_array (lbound (disk_status_interp_array, 1)));
	     do i = lbound (disk_status_interp_array, 1) by 1 while (bin (rel (dskerp), 18) < name_rel);
		dskerp = addr (disk_status_interp_array (i));
		if (substat & disk_error_interp.bitmask) = disk_error_interp.bitson then
		     return;
	     end;


	end interpret_status;



/* GET_DISK_COMMAND - Find Command Causing Disk Error. */

get_disk_command:
	proc;

	     idcwp = addrel (diskp, bin (io_status_entry.next_lpw_offset, 18) - disktab.abs_mem_addr - 1);
						/* Get pointer to IDCW. */
	     do while (idcw.code ^= IDCW);		/* Search backward to IDCW. */
		idcwp = addrel (idcwp, -1);
	     end;
	     command = idcw.command;			/* Extract command from IDCW. */


	end get_disk_command;

/* PRINTERR - Print disk error message. */

printerr:
	proc;

dcl	type		   fixed bin;		/* device type */
dcl	record_address	   fixed bin (18);		/* Multics page address */
dcl	mjsdp		   ptr;			/* major status description pointer */
dcl	ssdp		   ptr;			/* substatus description pointer */
dcl	imu_detailed_status	   (0:23) bit (8) based;	/* IMU detailed status bytes */
dcl	logical_rec_addr	   fixed bin (17);		/* logical record address of subvolume */
dcl	logical_sector	   fixed bin (21);		/* logical sector of subvolume */
dcl	sector_offset	   fixed bin (17);		/* used in calculation of logical_sector */

	     if devtab.broken then
		return;				/* Keep mum about broken devices. */

	     sector = bin (chantab.select_data.sector);	/* get sector number of disk address of error */
	     type = pvte.device_type;			/* get device type */
	     pvtdip = addr (pvte.dim_info);
	     record_address =
		divide (sector - (divide (sector, sect_per_cyl (type), 17, 0) * pvtdi.unused_sect_per_cyl),
		sect_per_rec (type), 17, 0);

	     if pvte.is_sv then do;
		record_offset = mod (record_address, pvte.records_per_cyl);
		logical_rec_addr =
		     divide ((record_address - pvte.record_factor - record_offset), pvte.num_of_svs, 17)
		     + record_offset;
		sector_offset = mod (sector, sect_per_cyl (type));
		logical_sector =
		     divide ((sector - (pvte.sv_num * sect_per_cyl (type)) - sector_offset), pvte.num_of_svs, 17)
		     + sector_offset;
	     end;
	     else do;
		logical_rec_addr = record_address;
		logical_sector = sector;
	     end;


	     if pvte.is_sv then
		mjsdp = addrel (dedp, disk_error_data (majstat).fnamep);
	     else mjsdp = addrel (dedp, disk_error_data (majstat).namep);
	     ssdp = addrel (dedp, disk_error_interp.namep);

	     unspec (msg_buf) = "0"b;			/* Now build data portion of syserr message */
	     io_msgp = addr (msg_buf);
	     io_msg.level = bit (level, 3);
	     io_msg.channel = chantab.chanid;
	     io_msg.device = bit (dev);
	     io_msg.type = chantab.action_code;
	     io_msg.command = command;
	     io_msg.status = string (io_status_word);
	     io_msg.devname = disk_data.name (sx);

	     if /* case */ devtab.broken | disk_error_interp.just_log then
		sysc = JUST_LOG;
	     else if mod (chantab.erct, 5) = 1 then
		sysc = ANNOUNCE;
	     else sysc = JUST_LOG;
	     call syserr$binary (sysc, io_msgp, SB_disk_err, SBL_disk_err,
		"^a: ^a ^[^12.3b^1s^;^1s^a^] for ^a (channel ^a).^/^2-rec ^o, sect ^o, main ^o^[^/^2-subvol ^a, logical rec ^o, logical sect ^o^;^3s^]^[^/^2-detailed status:^24( ^2.4b^).^;^s^]",
		ME, mjsdp -> disk_status_descrip.chr, (level = 1), stat, ssdp -> disk_status_descrip.chr,
		disk_name (SINGLE), chantab.chanid, record_address, sector, coreadd, pvte.is_sv, pvte.sv_name,
		logical_rec_addr, logical_sector, (io_status_entry.detailed_status (1) ^= ""b),
		addr (io_status_entry.detailed_status) -> imu_detailed_status);

	     return;


	end printerr;

/* HANDLE_ERROR - Handle disk errors. */

handle_error:
	proc;


	     chantab.erct = chantab.erct + 1;
	     disktab.errors = disktab.errors + 1;

	     call interpret_status;			/* Look this error up. */
	     if io_type = TEST then
		idcwp = addr (chantab.rssdcw);
	     else idcwp = addr (chantab.scdcw);

	     if ^(io_type = TEST & ^disk_error_interp.bad_path) then
		call printerr;			/* print and log error */

	     if /* case */ chantab.erct <= disk_error_interp.max_retries & io_type ^= TEST then do;
		if disk_error_interp.reseek then do;	/* If reseek desired before retry ... */
		     idcwp = addr (chantab.rstdcw);
		     idcw.device = bit (dev);
		     call connect (idcwp);		/* Connect to restore instruction. */
		end;
		else do;				/* If retrying ... */
		     if disk_error_interp.bad_path then do;
						/* Burn real time */
			temp_time = clock ();
			do while (clock () < temp_time + 750000);
						/* 3/4 sec. */
			end;
		     end;
		     call connect (idcwp);
		end;
	     end;

	     else if disk_error_interp.bad_dev then do;	/* If error indicates a bad device ... */
		if /* case */ devtab.inop | devtab.broken | io_type = TEST then do;
						/* If device is already inoperative or broken ... */
		     if ^devtab.broken then		/* If not already broken ... */
			if quentry.type ^= TEST then
			     call syserr (BEEP, "^a: ^a requires intervention.", ME, disk_name (SINGLE));
		     devtab.broken = "1"b;		/* Break the device altogether. */
		     call set_pvte_inop (ON);
		     devtab.was_broken = "0"b;
		     devtab.inop = "0"b;		/* And clear this flag. */
		     devtab.time_inop = clock ();	/* Note the current time. */

		     errflags.device_inoperative = "1"b;/* Set error code. */
		     post_sw = "1"b;		/* Going to post this as error. */
		end;

		else if tc_data$system_shutdown = 0 then do;
						/* Device was not previously inoperative. */
		     devtab.inop = "1"b;		/* Mark it as inoperative. */
		     disktab.dev_busy = disktab.dev_busy | dev_mask (pdi);
						/* Mark as busy to prevent further use. */
		     devtab.time_inop = clock ();	/* Note the current time. */
		     call add_wq;			/* Place request at tail of queue. */
		end;

		else do;				/* If during shutdown ... */
		     if quentry.type = TEST then
			call set_pvte_inop (ON);
		     errflags.device_inoperative = "1"b;
		     post_sw = "1"b;		/* Post this fact without further ado. */
		end;
	     end;
	     else if disk_error_interp.bad_addr then do;	/* If disk address is no good ... */
		if write_map (quentry.type) then	/* If writing ... */
		     errflags.reassign_address = "1"b;	/* Try another disk address. */
		else				/* If reading ... */
		     errflags.seg_unusable = "1"b;	/* Mark segment as unusable. */
		post_sw = "1"b;			/* Post this as error. */
	     end;

	     else if disk_error_interp.bad_path then do;	/* If error indicates a bad channel or controller ... */
		if chantab.inop then do;		/* If channel previously in trouble ... */
		     chantab.broken = "1"b;
		     chantab.inop = "0"b;
		end;
		else do;				/* If channel just started to act up ... */
		     chantab.inop = "1"b;		/* Mark channel inoperative. */
		     chantab.connect_time = clock ();	/* Record the time. */
		end;

		if disktab.channels_online > 1 then do;
		     call syserr (BEEP, "^a: Removing channel ^a.", ME, chantab.chanid);
		     chantab.in_use = "0"b;
		     disktab.channels_online = disktab.channels_online - 1;
		end;
		else do;
		     if bootload_sw then do;		/* for this type I/O, give up. */
			errflags.all_paths_bad = "1"b;
			post_sw = "1"b;
		     end;
		     else if io_type = TEST then do;
			call set_pvte_inop (ON);	/* effectively inop */
                              if (tc_data$system_shutdown ^= 0) then do;
                                  post_sw = "1"b;
                                  errflags.device_inoperative = "1"b;
                                  errflags.all_paths_bad = "1"b;
                                  return;
                              end;

		     end;
		     else if tc_data$system_shutdown ^= 0 then do;
			errflags.device_inoperative = "1"b;
						/* effectively inop */
			errflags.all_paths_bad = "1"b;
			post_sw = "1"b;
		     end;
		     else do;			/* Just keep trying. */
			chantab.erct = 0;
			chantab.inop = "0"b;
			call connect (addr (chantab.scdcw));
		     end;

/* Every polling time re-ready channel entries for another try.  This way we
   are not stuck with just the last channel. */

		     do i = 1 to disktab.nchan;
			lcp = addr (ptr (disksp, disktab.channels) -> disk_channel_table (i));
			if ^(lcp -> chantab.ioi_use) then do;
						/* If channel really belongs to disk dim (not ioi or deleted) */
			     if (lcp -> chantab.connect_time + CHANNEL_POLLING_TIME < clock ())
				| post_sw /* time to give up */ then do;
						/* time to open up */

				lcp -> chantab.broken = "0"b;
						/* not broken */
				lcp -> chantab.inop = "0"b;
						/* operative */
				lcp -> chantab.erct = 0;
						/* no errors */
				lcp -> chantab.active = "0"b;
						/* not active */

				lcp -> chantab.in_use = "1"b;

/* can use */
				lcp -> chantab.connect_time = clock ();
				disktab.channels_online = disktab.channels_online + 1;

			     end;
			end;
		     end;
		     return;
		end;

		post_sw = "0"b;			/* Don't post this operation. */
		call add_wq;			/* Requeue the operation. */

/* We should like to call call_run here, but this is indefinitely recursive. */


		do i = 1 to disktab.nchan;		/* Iterate thru all channels. */
		     cp = addr (ptr (disksp, disktab.channels) -> disk_channel_table (i));
						/* Find an idle channel */
		     if chantab.in_use & ^chantab.active then do;
			call getwork;
			return;
		     end;
		end;
	     end;
	     else if disk_error_interp.bad_mem then do;	/* Too bad, core lost. */
		errflags.fatal_error = "1"b;
		errflags.memory_unusable = "1"b;
		post_sw = "1"b;
	     end;
	     else do;				/* Very random error. */
		errflags.fatal_error = "1"b;
		post_sw = "1"b;			/* Tell _s_o_m_ebody. */
	     end;

	     return;


	end handle_error;

     end check_stat;

/* GETWORK - Look for more work to keep channel busy. */

getwork:
     proc;

	if ^chantab.in_use then
	     return;				/* chnl ^in use. */

	if ^disktab.dev_busy & disktab.dev_queued = "0"b then
	     return;				/* no work to do */

/* Scan drives in sequence to determine one which needs service. */

	do dev_count = lbound (disktab.devtab, 1) to hbound (disktab.devtab, 1);
	     disktab.dev_index = disktab.dev_index + 1;	/* drive to check */
	     if disktab.dev_index > hbound (disktab.devtab, 1) then
		disktab.dev_index = lbound (disktab.devtab, 1);

	     dev = disktab.dev_index;
	     pdi = disktab.devtab (dev).pdi;

	     if ^disktab.dev_busy & dev_mask (pdi) then do;
						/* If primary device free */
		dp = addr (disktab.devtab (pdi));	/* Get pointer to primary device info table. */
		if ^devtab.broken			/* Device usable */
		     then
		     if devtab.wq.depth > 0		/* work to do */
		     then do;
			qp = ptr (disksp, devtab.wq.head);

/* If only one element in queue, then we are as optimal as you get. */
/* Stagnation control.  Head of queue is oldest request.  If it is older than
   disk_data.stagnate_time then we optimize with disk combing. */

			if devtab.wq.depth > 1 then
			     if quentry.time >= (clock () - disk_data.stagnate_time) then
				call find_shortest_seek;
			     else call comb;	/* stagnation */

			call del_q;		/* Remove from queue. */
			go to xfer_join;
		     end;
	     end;
	end;

	return;					/* Nothing to do, so just return. */

/* FIND_SHORTEST_SEEK - Procedure to Get Request Closest to Current Arm Position. */

find_shortest_seek:
	proc;

dcl	(
	best_seek,				/* best nearest seek */
	this_seek					/* seek distance for comparison */
	)		   float bin (27),
	(
	best_pos_comb,				/* best pos comb */
	best_neg_comb,				/* best neg comb */
	this_comb					/* seek distance for comparison */
	)		   fixed bin (35),
	best_qp		   ptr,			/* pointer to best request */
	best_neg_qp	   ptr,			/* best neg comb */
	type		   fixed bin;		/* type of this request */

	     cylinder = devtab.cylinder;
	     best_seek = 1.0e+30;			/* maximum */

/* Get type of queue entry to locate fraction and multipliers.  Determine
   Logical Seek Length for Nearest-Seek calculations. */

seek_loop:
	     type = quentry.type;
	     this_seek = float (abs (quentry.cylinder - cylinder) * devtab.opt_info (type).multiplier);
	     if this_seek = 0.0 then
		goto seek_on_cylinder;		/* ON-CYLINDER */

	     if this_seek < best_seek then do;		/* pick best */
		best_seek = this_seek;
		best_qp = qp;
	     end;

/* Step to next queue entry as we scan the queue. */

	     qrp = quentry.next;
	     if qrp = "0"b then
		goto seek_found;			/* we have best */

	     qp = ptr (disksp, qrp);			/* pointer to entry. */
	     goto seek_loop;


seek_found:
	     qp = best_qp;				/* pick up best .. */
seek_on_cylinder:					/* qp -> entry */
	     qrp = rel (qp);
	     return;

/* Combing optimization eliminates possible IO stagnation by moving the head
   in and out continuously in a combing motion. */

comb:
	entry;

	     devtab.comb = devtab.comb + 1;
	     cylinder = devtab.cylinder;
	     best_pos_comb = 34359738367;
	     best_neg_comb = -34359738367;

/* Attempt to maintain direction by appropriately setting comparison order
   between this cylinder and the current cylinder. */

comb_loop:
	     if devtab.forward then
		this_comb = quentry.cylinder - cylinder;
	     else this_comb = cylinder - quentry.cylinder;

	     if this_comb = 0 then			/* ON-CYLINDER */
		goto seek_on_cylinder;		/* Pick this one */
	     else if this_comb > 0			/* same direction */
	     then do;
		if this_comb < best_pos_comb then do;
		     best_pos_comb = this_comb;
		     best_qp = qp;
		end;
	     end;
	     else do;				/* reverse direction */
		if this_comb > best_neg_comb then do;
		     best_neg_comb = this_comb;
		     best_neg_qp = qp;
		end;
	     end;

	     qrp = quentry.next;
	     if qrp = "0"b then
		goto comb_found;			/* search complete */
	     qp = ptr (disksp, qrp);
	     goto comb_loop;


comb_found:
	     if best_pos_comb ^= 34359738367 then	/* if we found forward. */
		qp = best_qp;			/* pick up best .. */
	     else qp = best_neg_qp;
	     qrp = rel (qp);
	     return;
	end find_shortest_seek;

/* GOTWORK - Found queue entry.  Start the I/O. */

/* Presumes
   dp -> devtab(pdi)	Current devtab for this request's pdi.
   qp -> quentry		Quentry which has request to connect.
   cp -> chantab		Current channel table to connect request to.
*/

gotwork:
     entry;

xfer_join:
	if ^quentry.used then			/* This must never happen. */
	     call syserr (CRASH, "^a: Queuing error.", ME);

	chantab.qrp = rel (qp);			/* Save queue entry index for later. */
	chantab.erct = 0;				/* Clear the retry error count. */
	chantab.reconnect_announce_time = 0;		/* force first reconnect to be announced */

	dev = quentry.dev;				/* extract device */

	if quentry.type = TEST then do;
	     idcwp = addr (chantab.rssdcw);		/* Get pointer to RSS. */
	     idcw.command = substr (quentry.coreadd, 19, 6);
	     idcw.device = bit (dev);			/* Set device address. */

/* Count TEST or UNLOAD calls. */

	     optp = addr (disktab.devtab (dev).opt_info (quentry.type));
	     if bin (quentry.coreadd, 24) = 58 then
		opt_info.seek_sum = opt_info.seek_sum + 1;
						/* UNLOAD */
	     else opt_info.seek_count = opt_info.seek_count + 1;
						/* TEST */


	     call connect (idcwp);			/* Get device status. */
	end;

	else do;					/* Normal seek op - */
	     dcdcwp = addr (chantab.dcdcw);		/* Get pointer to data xfer IDCW. */
	     dddcwp = addr (chantab.dddcw);		/* Get pointer to data xfer DCW. */
	     idcwp = addr (chantab.scdcw);		/* Get pointer to SEEK or RSS IDCW. */

	     idcw.device = bit (dev);			/* Set device address */

	     unspec (dcdcwp -> idcw) = "0"b;		/* clear idcw */
	     dcdcwp -> idcw.code = IDCW;
	     dcdcwp -> idcw.ext_ctl = "1"b;
	     if write_map (quentry.type) then		/* set data transfer direction */
		dcdcwp -> idcw.command = WRITE;
	     else dcdcwp -> idcw.command = READ;

	     dcdcwp -> idcw.ext = substr (quentry.coreadd, 1, length (idcw.ext));
						/* Set address extension in IDCW. */
	     dddcwp -> dcw.address = substr (quentry.coreadd, 7);
						/* Set DCW address. */
	     dcdcwp -> idcw.device = bit (dev);		/* Set up device address */
						/* idcw.chan_cmd = "00"b3 is ok, = data xfer */


	     chantab.select_data.sector = quentry.sector; /* set disk sector address */
						/* At this point the check is made for the type of seek (512 or 64) */
	     if idcw.command = seek_512 then do;	/* sector size is 512 */
		if quentry.type = VTOC_READ | quentry.type = VTOC_WRITE then do;
		     dddcwp -> dcw.tally = bit (bin (192, 12));
		     chantab.select_data.limit = bit (bin (1, 12));
		end;
		else if quentry.type = PAGE_READ | quentry.type = PAGE_WRITE then do;
		     dddcwp -> dcw.tally = bit (bin (1024, 12));
		     chantab.select_data.limit = bit (bin (2, 12));
		end;
		else if sector_map (quentry.type) then do;
		     dddcwp -> dcw.tally = bit (bin ((512 * quentry.n_sectors), 12));
		     chantab.select_data.limit = bit (bin (quentry.n_sectors, 12));
		end;
	     end;
	     else do;				/* sector size must be 64 */
		if sector_map (quentry.type) then do;	/* If 64-word I/O ... */
		     dddcwp -> dcw.tally = bit (bin (64 * quentry.n_sectors, 12));
						/* Set DCW tally. */
		     chantab.select_data.limit = bit (bin (quentry.n_sectors, 12));
						/* Set sector count limit. */
		end;
		else do;				/* If 1024-word I/O ... */
		     dddcwp -> dcw.tally = bit (bin (1024, 12));
						/* Set DCW tally. */
		     chantab.select_data.limit = bit (bin (16, 12));
						/* Set sector count limit. */
		end;
	     end;

	     call connect (addr (chantab.scdcw));	/* Start up the channel. */

/* find opt_info */

	     optp = addr (disktab.devtab (dev).opt_info (quentry.type));
	     cylinder = devtab.cylinder - quentry.cylinder;
	     devtab.cylinder = quentry.cylinder;

/* Determine direction of seek.  If going low cylinder to high, then
   devtab.forward is set true, if going  high to low it is set false.  If
   we stay on-cylinder, then we leave the direction as what it was. */
/* We use this information to maintain combing. */

	     if cylinder > 0			/* Backward comb */
		then
		devtab.forward = "0"b;
	     else if cylinder < 0			/* Forward comb */
		then
		devtab.forward = "1"b;

	     opt_info.seek_sum = opt_info.seek_sum + abs (cylinder);
	     opt_info.seek_count = opt_info.seek_count + 1;
	end;
     end getwork;

/* CONNECT - Start Up the Channel. */

connect:
     procedure (listp);

dcl	listp		   ptr parameter;
dcl	1 ima		   aligned like io_manager_arg;

	ima.chx = chantab.chx;
	ima.pcw = ""b;
	ima.ptp = null ();
	ima.listp = listp;
	call io_manager$connect_abs (ima);		/* Fire up the channel. */
						/* Fire up the channel. */
	chantab.connects = chantab.connects + 1;	/* Keep count of number of connects */
	chantab.active = "1"b;			/* Indicate channel now active */
	chantab.connect_time = clock ();		/* set time of connect */

	disktab.dev_busy = disktab.dev_busy | dev_mask (pdi);
						/* Indicate primary device now busy. */

	return;


     end connect;



/* POST - Notify system of completed operation. */

post:
     proc;

	if /* case */ io_type = TEST then do;

/*  test results have been indicated by this time. */
	     post_sw = "0"b;
	     return;
	end;


	if sect_sw then				/* If 64-word I/O ... */
	     if bootload_sw then
		call bootload_disk_post (coreadd, errcd);
	     else call vtoc_interrupt (coreadd, errcd);
	else					/* If page I/O ... */
	     call page$done (coreadd, errcd);

	post_sw = "0"b;				/* Clear switch to prevent double posting. */

	return;


     end post;

/* queue_length_given_pvtx - that says it all */

queue_length_given_pvtx:
     entry (a_pvtx, a_queue_length);

	pvtep = addr (addr (pvt$array) -> pvt_array (a_pvtx));
						/* PVTE for this device */
	pvtdip = addr (pvte.dim_info);		/* Get pointer to DIM info */
	sx = pvtdi.sx;				/* Extract index for this disk subsystem */

	call setup;				/* Get pointers to databases */

	dev = pvte.logical_area_number;		/* Device number */
	pdi = disktab.devtab (dev).pdi;		/* Primary device number */
	dp = addr (disktab.devtab (pdi));		/* Get pointer to info for primary device */

	a_queue_length = devtab.wq.depth;		/* current amount queued */

	return;

/* TUNING control.  Externally accessible entry with which to setup tuning
   parameters in disk_seg.  It ensures valid parameters. */

tune:
     entry (a_op, a_ptr, reason, ec);

dcl	a_op		   char (*);		/* type of tuning */
dcl	a_ptr		   ptr;			/* pointer to structure */
dcl	reason		   char (*) varying;	/* textual description of error */
dcl	ec		   fixed bin (35);

dcl	stagnate_time	   fixed bin (35) based (cptr);
						/* for setting time */
dcl	response		   fixed bin (35);
dcl	load		   fixed bin;
dcl	cptr		   ptr;
dcl	op		   char (16);

%include disk_tune;
%page;
	disksp = addr (disk_seg$);
	cptr = a_ptr;
	op = a_op;

	if op = STAGNATE_TIME then do;		/* limit 6 min. */
	     if stagnate_time > 360000000 | stagnate_time < 0 then do;
		if stagnate_time < 0 then
		     reason = "stagnate time must be >= 0";
		else reason = "stagname time must be <= 6 minutes";
		ec = error_table_$bad_arg;
		return;
	     end;
	     else disk_data.stagnate_time = a_ptr -> stagnate_time;
	end;
	else if op = SYS_TUNE then do;
	     io_type = cptr -> sys_info_tune.type;
	     if io_type < 0 | io_type > MAX_IO_TYPE then
		goto bad_io_type;

	     sysp = addr (disk_data.sys_info (io_type));

	     if cptr -> sys_info_tune.map > MAX_IO_TYPE then
		goto bad_map_type;

/* if map is positive, then we update counter mapping. */

	     if cptr -> sys_info_tune.map >= 0 then
		sys_info.depth_map = rel (addr (disk_data.sys_info (cptr -> sys_info_tune.map)));

/* if max_depth is > 1 then we update it.  If 0 we would divide by 0. */

	     if cptr -> sys_info_tune.max_depth > 0 then
		sys_info.max_depth = float (cptr -> sys_info_tune.max_depth);
	end;
	else if op = OPT_TUNE then do;
	     io_type = cptr -> opt_info_tune.type;
	     if io_type < 0 | io_type > MAX_IO_TYPE then
		goto bad_io_type;

	     do sx = 1 to disk_data.subsystems;
		if cptr -> opt_info_tune.sub_sys = disk_data.array (sx).name then
		     goto tune_sub_sys;
	     end;
	     goto bad_io_sub_sys;

tune_sub_sys:
	     call setup;				/* locate disktab */
	     dev = cptr -> opt_info_tune.dev;
	     if dev < lbound (disktab.devtab, 1) | dev > hbound (disktab.devtab, 1) then
		goto bad_io_dev;

	     pdi = disktab.devtab (dev).pdi;		/* only tune pdi */
	     if pdi ^= dev then
		goto bad_io_dev;

	     response = cptr -> opt_info_tune.response;
	     if response < 1 then
		goto response_range;
	     load = cptr -> opt_info_tune.load;

	     optp = addr (disktab.devtab (pdi).opt_info (io_type));
	     if load > 1 then do;
		opt_info.slope = float (response - 1) / float (load - 1);
		opt_info.intercept = float ((response * load) - 1) / float (load - 1);
	     end;
	     else do;
		opt_info.slope = 0.0;
		opt_info.intercept = float (response);
	     end;
	end;
	else if op = RESET_SYS then do;
	     do i = 0 to MAX_IO_TYPE;			/* sys_info.depth's */
		disk_data.sys_info (i).depth = 0;
	     end;
	end;
	else if op = RESET_MAX then do;
	     disk_data.max_depth_reset_time = clock ();
	     disk_data.free_q.max_depth = 0;
	     do i = 1 to disk_data.subsystems;		/* each sub-sys */
		diskp = ptr (disksp, disk_data.array (i).offset);
		disktab.wq.max_depth = 0;
	     end;
	end;
	reason = "";
	ec = 0;
	return;

bad_io_type:
	reason = "invalid I/O type";
	ec = error_table_$bad_arg;
	return;

bad_map_type:
	reason = "invalid map I/O type";
	ec = error_table_$bad_arg;
	return;

bad_io_sub_sys:
	reason = "unknown subsystem";
	ec = error_table_$bad_arg;
	return;

bad_io_dev:
	reason = "invalid device number";
	ec = error_table_$bad_arg;
	return;

response_range:
	reason = "response value must be >= 1";
	ec = error_table_$bad_arg;
	return;

/* SETUP - Internal Procedure to set data base pointers. */

setup:
     proc;


	disksp = addr (disk_seg$);			/* Get a pointer to disk data segment. */
	pvt_arrayp = addr (pvt$array);		/* Get a pointer to the PVT array. */
	diskp = ptr (disksp, disk_data.offset (sx));	/* Get pointer to info for this subsystem. */

	return;


     end setup;



/* DISK_NAME - Internal Procedure to generate name of disk drive. */

disk_name:
     proc (both) returns (char (21) aligned);

dcl	both		   bit (1) aligned;
dcl	pic99		   pic "99";
dcl	this_name		   char (8);
dcl	other_name	   char (12);
dcl	other_dev		   fixed bin;


	if dev = pdi				/* If this is the priamry, we must rely on buddy */
	     then
	     other_dev = disktab.devtab (pdi).buddy;
	else other_dev = pdi;

	this_name = disk_data.name (sx) || "_" || convert (pic99, dev);
	if other_dev = 0 then
	     other_name = "";
	else other_name = " and " || disk_data.name (sx) || "_" || convert (pic99, other_dev);

	if both					/* return both device names, if appropriate */
	     then
	     return (this_name || other_name);
	else return (this_name);


     end disk_name;


/* LOCK/UNLOCK - Internal Procedures to Lock & Unlock Disk Database. */

lock:
     proc (lmp);

dcl	1 dlm		   like disk_lock_meters based (lmp) aligned,
						/* database lock meters */
	lmp		   ptr;


	dlm.count = dlm.count + 1;			/* Count locking attempt. */
	if ^stacq (disktab.lock, pds$processid, UNLOCK) then do;
						/* Attempt to lock database. */
	     call lock_meter_start (lmp);
	     do while (^stacq (disktab.lock, pds$processid, UNLOCK));
	     end;					/* Lock the disk data base. */
	     call lock_meter_stop (lmp);
	end;

	return;


unlock:
     entry;

	if ^stacq (disktab.lock, UNLOCK, disktab.lock) then
	     ;					/* Unlock the data base. */

	return;


     end lock;



/* LOCK_METER_START / LOCK_METER_STOP - Metering Procedures. */

lock_meter_start:
     proc (lmp);

dcl	1 dlm		   like disk_lock_meters based (lmp) aligned,
	lmp		   ptr;


	meter_start_time = clock ();			/* Get time now. */
	dlm.waits = dlm.waits + 1;			/* Count a wait. */

	return;


lock_meter_stop:
     entry (lmp);

	dlm.wait_time = dlm.wait_time + (clock () - meter_start_time);
						/* Meter time spent waiting. */
	return;


     end lock_meter_start;

/* GET_FREE_Q - Get a Queue Entry from the Free List. */

get_free_q:
     proc returns (bit (1) aligned);

dcl	type		   fixed bin;

/* SPIN-LOCK til queue available. */

	do while (^stacq (disk_data.lock, pds$processid, UNLOCK));
	end;

	qrp = disk_data.free_q.head;			/* Get rel ptr to head of free queue. */
	if qrp then do;				/* queue ^empty */
	     qp = ptr (disksp, qrp);			/* entry pointer */
	     disk_data.free_q.head = quentry.next;	/* new Q head */

/* if queue is now empty ground the tail, else ground our next's previous */

	     if disk_data.free_q.head = "0"b then
		disk_data.free_q.tail = "0"b;
	     else ptr (disksp, quentry.next) -> quentry.prev = "0"b;

/* Compile queue statistics.  Depth is really depth assigned from free_q. */

	     disk_data.free_q.sum = disk_data.free_q.sum + disk_data.free_q.depth;
	     disk_data.free_q.depth = disk_data.free_q.depth + 1;
	     if disk_data.free_q.depth > disk_data.free_q.max_depth then
		disk_data.free_q.max_depth = disk_data.free_q.depth;
	     disk_data.free_q.count = disk_data.free_q.count + 1;

	     if ^stacq (disk_data.lock, UNLOCK, disk_data.lock) then
		;				/* Unlock the database */
	     return (SUCCESS);
	end;
	else do;					/* If queue is empty ... */
	     if ^stacq (disk_data.lock, UNLOCK, disk_data.lock) then
		;				/* Unlock the database */
	     return (FAILURE);
	end;

/* ADD_FREE_Q - Add Entry to End of Free Queue. */

add_free_q:
     entry;

	quentry.used = "0"b;			/* Queue entry is no longer in use. */

/* SPIN-LOCK til queue is available to add free entry to it. */

	do while (^stacq (disk_data.lock, pds$processid, UNLOCK));
	end;					/* lock database */

/* If queue is ^empty, then add to tail, else create head and tail to element. */

	if disk_data.free_q.tail ^= "0"b then
	     ptr (disksp, disk_data.free_q.tail) -> quentry.next = qrp;
	else disk_data.free_q.head = qrp;

	quentry.prev = disk_data.free_q.tail;		/* link to prev */
	disk_data.free_q.tail = qrp;			/* New tail */
	quentry.next = "0"b;			/* clear next ptr. */

/* Indicate element returned from system. */

	disk_data.free_q.depth = disk_data.free_q.depth - 1;

	if ^stacq (disk_data.lock, UNLOCK, disk_data.lock) then
	     ;					/* Unlock the database */
	return;

/* ADD_WQ - Add Entry to End of Work Queue. */

add_wq:
     entry;

/* Indicate requests queued for device. */
/* If queue is not empty, then add to tail, else create queue. */

	disktab.dev_queued = disktab.dev_queued | dev_mask (pdi);
	if devtab.wq.tail ^= "0"b then
	     ptr (disksp, devtab.wq.tail) -> quentry.next = qrp;
	else devtab.wq.head = qrp;

	quentry.prev = devtab.wq.tail;
	quentry.next = "0"b;
	devtab.wq.tail = qrp;

/* Compile queue statistics. */

	devtab.wq.sum = devtab.wq.sum + devtab.wq.depth;
	devtab.wq.depth = devtab.wq.depth + 1;
	if devtab.wq.depth > devtab.wq.max_depth then
	     devtab.wq.max_depth = devtab.wq.depth;
	devtab.wq.count = devtab.wq.count + 1;

/* Compile system loading statistics.
   Find map of counter to be used. */

	type = quentry.type;
	sysp = addr (disk_data.sys_info (type));
	do while (^stacq (disk_data.lock, pds$processid, UNLOCK));
	end;
	ptr (disksp, sys_info.depth_map) -> sys_info.depth = ptr (disksp, sys_info.depth_map) -> sys_info.depth + 1.0;
	optp = addr (devtab.opt_info (type));
	opt_info.depth = opt_info.depth + 1;

/* Common processing for system IO loading and drive IO loading. */

wq_common:
	sys_info.fraction =
	     (sys_info.max_depth - ptr (disksp, sys_info.depth_map) -> sys_info.depth) / sys_info.max_depth;
	if sys_info.fraction < 0.0 then
	     sys_info.fraction = 0.0;
	if ^stacq (disk_data.lock, UNLOCK, disk_data.lock) then
	     ;					/* Unlock disk_data. */

/* Compile drive load multiplier for this IO type.  The multiplier cannot drop
   below 1.0 to give a true PHYSICAL=LOGICAL mapping.  */

	opt_info.multiplier = (opt_info.intercept - float (opt_info.depth) * opt_info.slope) * sys_info.fraction;
	if opt_info.multiplier < 1.0 then
	     opt_info.multiplier = 1.0;		/* LIMIT to 1.0 */
	return;

/* DEL_Q - Delete Item from Queue. */

del_q:
     entry;

/* Remove item from queue, fixing previous and next entries, or head or tail */

	if quentry.prev = "0"b then			/* head is prev */
	     devtab.wq.head = quentry.next;
	else ptr (disksp, quentry.prev) -> quentry.next = quentry.next;

	if quentry.next = "0"b then			/* tail is next */
	     devtab.wq.tail = quentry.prev;
	else ptr (disksp, quentry.next) -> quentry.prev = quentry.prev;

/* Fix queue statistics.  If queue is empty, indicate this for fast check. */

	devtab.wq.depth = devtab.wq.depth - 1;
	if devtab.wq.depth <= 0 then
	     disktab.dev_queued = disktab.dev_queued & ^dev_mask (pdi);

/* Do load statistics, use map of depth accumulator. */

	type = quentry.type;
	sysp = addr (disk_data.sys_info (type));
	do while (^stacq (disk_data.lock, pds$processid, UNLOCK));
	end;					/* lock disk_data */

/* prevent possible -ve depth if map is changed on the fly. */

	ptr (disksp, sys_info.depth_map) -> sys_info.depth =
	     max (0.0, ptr (disksp, sys_info.depth_map) -> sys_info.depth - 1.0);

	optp = addr (devtab.opt_info (type));
	opt_info.depth = opt_info.depth - 1;
	go to wq_common;				/* will unlock disk_data */

     end get_free_q;

/* set_pvte_inop ...  Internal procedure to deal with pvte.inoperative, notifying
   the global disk offline event as necessary.  */

set_pvte_inop:
     proc (setting);

dcl	setting		   bit (1) aligned;


/* pvtep is set */

	call set (addr (addr (pvt$array) -> pvt_array (devtab.pvtx)));
						/* Set the first one (^)inop */
	if devtab.buddy ^= 0			/* Must also do it to the buddy */
	     then
	     call set (addr (addr (pvt$array) -> pvt_array (disktab.devtab (devtab.buddy).pvtx)));

set:
	proc (pvte_ptr);

dcl	pvte_ptr		   ptr;


	     if pvte_ptr -> pvte.device_inoperative & ^setting then do;
		pvte_ptr -> pvte.device_inoperative = "0"b;
		call pxss$notify (page_fault$disk_offline_event);
	     end;
	     else pvte_ptr -> pvte.device_inoperative = setting;

	     return;


	end set;

     end set_pvte_inop;

%include device_error;
%page;
%include disk_error_interp;
%page;
%include dskdcl;
%page;
%include fs_dev_types;
%page;
%include io_manager_dcls;
%page;
%include io_special_status;
%page;
%include io_status_entry;
%page;
%include io_syserr_msg;
%page;
%include iom_dcw;
%page;
%include iom_pcw;
%page;
%include pvte;
%page;
%include syserr_binary_def;
%page;
%include syserr_constants;

/* BEGIN MESSAGE DOCUMENTATION

   Message:
   disk_control: Adding channel ICC.

   S:	$info

   T:	$run

   M:	A message to confirm that channel ICC has been added to the system
   in response to a reconfigure command.

   A:	$ignore

   Message:
   disk_control: Reconnected IO_TYPE I/O on dskX_NN (channel ICC).

   S:	$info and/or $log

   T:	$run

   M:	A disk interrupt was apparently lost.
   Status for the disk did not arrive within the expected time.
   This may be an indication of a channel or controller malfunction.
   The system restarts the disk operation.

   A:	$ignore Unless these messages persist, which may indicate
   a hardware malfunction that needs investigation.  Some types of
   channel adapters and/or disk controllers can be "reset" in an attempt
   to correct the condition.

   Message:
   disk_control: Placing dskX_NN in operation.

   S:	$info

   T:	$run

   M:	A special interrupt has been received for a disk drive marked as
   broken. The system will attempt to use the device.

   A:	$ignore

   Message:
   disk_control: Unexpected IOM status SSSS for dskX_NN (channel ICC).

   S:	$info

   T:	$run

   M:	Status has been received from a channel which was not marked active.
   This is due to a disk subsystem or IOM problem,
   or to a logic error in the supervisor.
   See manual AN87, System Formats, for an interpretation
   of the status SSSS.
   The system ignores the status and attempts to continue operation.

   A:	$ignore

   Message:
   disk_control: dskX_NN now operational.

   S:	$info

   T:	$run

   M:	A disk drive which required intervention has successfully completed
   an I/O operation. The system will again use its contents.

   A:	$ignore

   Message:
   disk_control: MAJOR_STAT SUBSTAT for dskX_NN (channel ICC).
   .br
   rec RRRR, sect SSSS, main AAAA
   .br
   detailed status: XX XX XX XX XX XX XX XX

   S:	$info

   T:	$run

   M:	A disk error has occurred on drive dskX_NN.
   The major status and substatus are interpreted as character strings.
   The disk address is given both as a Multics record address in octal,
   and as an absolute sector number in octal.
   The main store address being used was AAAA octal.
   The third line gives the hexadecimal value of the detailed status
   in cases where this data is useful.
   See manual AN87, System Formats, for interpretation of this information.

   A:	Note for Customer Service action.
   The segment involved in a disk error can often be identified by
   an application of the "record_to_vtocx" tool to the Multics
   record number given in the message.

   Message:
   disk_control: MAJOR_STAT SUBSTAT for dskX_NN (channel ICC).
   .br
   rec RRRR, sect SSSS, main AAAA
   .br
   subvol V, logical rec OOOO, logical sect TTTT
   .br
   detailed status: XX XX XX XX XX XX XX XX

   S:	$info

   T:	$run

   M:	A disk error has occurred on drive dskX_NN.
   The major status and substatus are interpreted as character strings.
   The disk address is given both as a Multics record address in octal,
   and as an absolute sector number in octal.
   The main store address being used was AAAA octal.
   The subvolume name is V (the logical device name is dskX_NNV),
   the logical record address is OOOO octal
   and the logical sector number is TTTT octal.
   The fourth line gives the hexadecimal value of the detailed status
   in cases where this data is useful.
   See manual AN87, System Formats, for interpretation of this information.

   A:	Note for Customer Service action.
   The segment involved in a disk error can often be identified by
   an application of the "record_to_vtocx" tool to the Multics
   logical record number given in the message.

   Message:
   disk_control: dskX_NN requires intervention.

   S:	$beep

   T:	$run

   M:	A disk error has occurred which
   could have been caused by the pack or drive being broken
   or requiring operator attention.
   The system has retried the operation an appropriate number of times
   without success.
   The system will try the device
   periodically to check if it has been repaired.

   A:	Inspect the device.
   If it is not ready, ready it.
   If it is ready, try unreadying and re-readying it.
   If the drive cannot be made ready, contact Customer Service personnel.

   Message:
   disk_control: Removing channel ICC.

   S:	$beep

   T:	$run

   M:	Errors occurred indicative of a defective disk channel or MPC.
   The channel receiving the errors is placed offline.

   A:	$inform
   Also inform Customer Service personnel.

   Message:
   disk_control: Queuing error.

   S:	$crash

   T:	$run

   M:	$err

   A:	$recover

   END MESSAGE DOCUMENTATION */

     end disk_control;
