/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(86-06-05,GJohnson), approve(86-06-05,MCR7387),
     audit(86-06-10,Martinson), install(86-07-11,MR12.0-1091):
     Correct error message documentation.
                                                   END HISTORY COMMENTS */


/* format: style4,delnl,insnl,^ifthendo */
fnp_util:
     procedure;

/* This procedure contains entries called through hphcs_ used to load and dump an
   *  FNP. The "wire" entry is used to wire the segment containing the core image so that
   *  DIA I/O will be possible; the "load" entry initiates the bootload I/O; the
   *  "release" entry releases the aste of the coreimage.
   *  The "fdump" entry dumps all of FNP memory into a segment supplied
   *  by the caller.
   *
   *  Written 5/19/76 by Robert S. Coren
   *  Modified 10/28/76 by Robert S. Coren to save version number and report core image name
   *  Modified 04/15/77 by Robert S. Coren to correct bug in queue buffer freeing
   *  Modified 9/27/78 by J. Stern for multiplexing changes
   *  Modified 79 May 14 by Art Beattie to get memory size and FNP type from caller for fdump entry.
   *  Modified April 1981 by Chris Jones for io_manager conversion
   *  Modified February 1982 by C. Hornig for MR10 io_manager.
   *  Modified 830714 BIM to remove the release entrypoint. abort is suffcient.
   *  Modified 83-12-20 BIM for reconfiguration.
   *  Modified 84-05-18 BIM for better maintenance of io_manager_assigned bit.
   *  Modified 1984-08-02 BIM for code return from load.
   *  Modified 1984-07-26 BIM for paged I/O on loads.
   *  Modified 1985-01-29, BIM: fix dump_mpx to leave chn unassigned.
   *  Modified 1985-03-12, E. Swenson to fix unitialized timeout flag to 
   *     prevent spurious timeout errors.
*/


/* PARAMETERS */

dcl  a_devx fixed bin;				/* ioam release param */
dcl  a_fnp_no fixed bin;
dcl  a_fnp_mem_size fixed bin;			/* FNP memory size in 1024 18-bit words */
dcl  a_fnp_type fixed bin;
dcl  a_ptr ptr;
dcl  a_load_info_ptr ptr;
dcl  a_count fixed bin;				/* number of words to wire */
dcl  a_code fixed bin (35);				/* OUTPUT */
dcl  a_ev_chan fixed bin (71);
dcl  a_absadr fixed bin (24);				/* OUTPUT from wire and info, INPUT to load */
dcl  a_version char (4);				/* INPUT MCS version number */
dcl  a_image_name char (168);				/* INPUT core image name */
dcl  norm_int_cell fixed bin;				/* OUTPUT */
dcl  emergency_int_cell fixed bin;			/* OUTPUT */
dcl  a_ints bit (2) aligned;				/* OUTPUT rcvd interrupts */
dcl  a_level fixed bin (3);				/* INPUT level on which to interrupt fnp */
dcl  a_fnp_addr fixed bin (15);			/* INPUT data address in fnp */

/* AUTOMATIC */

dcl  auto_absadr fixed bin (24);
dcl  dia_timeout bit (1) aligned;
dcl  fnp_no fixed bin;
dcl  fnp_mem_size fixed bin;
dcl  fnp_type fixed bin;
dcl  fnp_addr fixed bin (15);
dcl  chanid char (8) aligned;
dcl  opcode bit (6) aligned;
dcl  temp_fnp_name char (32);
dcl  fnp_size fixed bin;
dcl  segptr ptr;
dcl  nwords fixed bin;
dcl  code fixed bin (35);
dcl  iom_channel_number fixed bin (7);
dcl  devx fixed bin;
dcl  i fixed bin;
dcl  data_ptr ptr;
dcl  offset fixed bin;
dcl  fnp_tally fixed bin;
dcl  start_time fixed bin (71);
dcl  version char (4);
dcl  cur_la_no bit (3);
dcl  cur_slot_no fixed bin (6);
dcl  load_info_ptr ptr;
dcl  locked bit (1) aligned init ("0"b);
dcl  config_locked bit (1) aligned init ("0"b);

declare  message fixed bin (71);
declare  1 auto_fnp_msg aligned like fnp_msg;

/* BUILTINS */

dcl  (addr, addrel, baseno, bit, clock, fixed, min, null, ptr, string, substr) builtin;


/* ENTRIES */

dcl  config_$find_2 entry (character (4) aligned, character (4) aligned, pointer);
dcl  fnp_multiplexer$assign entry (fixed binary, fixed binary (35));
dcl  fnp_multiplexer$unassign entry (fixed binary, fixed binary (35));
dcl  fnp_multiplexer$fnp_lock entry (pointer, fixed binary (35));
dcl  fnp_multiplexer$fnp_unlock entry (pointer);
dcl  get_fnp_name_ entry (fixed bin) returns (char (32));
dcl  grab_aste$grab_aste_io entry (ptr, fixed bin, fixed bin (35)) returns (ptr);
dcl  grab_aste$release_io entry (ptr);
dcl  ioam_$assign entry (fixed bin, entry, fixed bin (35));
dcl  ioam_$unassign entry (fixed bin, fixed bin (35));
dcl  priv_channel_manager$get_devx entry (char (*), fixed bin, fixed bin (35));
dcl  dn355_util$compute_parity entry (bit (36)) returns (bit (36));
dcl  absadr entry (ptr, fixed bin (35)) returns (fixed bin (24));
dcl  ioi_page_table$get entry (fixed binary (19), fixed binary, fixed binary (35));
dcl  ioi_page_table$fill entry (fixed binary, pointer, fixed binary (35));
dcl  ioi_page_table$ptx_to_ptp entry (fixed binary) returns (pointer);
dcl  ioi_page_table$put entry (fixed binary, fixed binary (35));
dcl  pxss$notify entry (fixed bin);
dcl  pxss$addevent entry (fixed bin);
dcl  pxss$delevent entry (fixed bin);
dcl  pxss$wait entry;
dcl  pxss$ring_0_wakeup entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
dcl  get_ptrs_$given_segno entry (fixed bin) returns (ptr);
dcl  dn355$interrupt entry;
dcl  syserr entry options (variable);
dcl  syserr$error_code entry options (variable);
dcl  lock$wait entry (ptr, char (4) aligned, fixed bin (35));
dcl  lock$lock_fast entry (pointer);
dcl  lock$unlock_fast entry (pointer);
dcl  lock$unlock entry (ptr, char (4) aligned);
dcl  (
     pc_abs$wire_abs,
     pc_abs$wire_abs_contig
     ) entry (ptr, fixed bin, fixed bin, fixed bin (35));
dcl  pc_abs$unwire_abs entry (ptr, fixed bin, fixed bin);

/* EXTERNAL STATIC */

dcl  (
     error_table_$io_no_permission,
     error_table_$invalid_state,
     error_table_$bad_mpx_load_data,
     error_table_$no_io_interrupt,
     error_table_$rqover,
     error_table_$bad_segment,
     error_table_$noalloc,
     error_table_$action_not_performed,
     error_table_$io_configured,
     error_table_$io_not_configured,
     error_table_$io_assigned,
     error_table_$io_not_assigned,
     error_table_$io_not_defined
     ) fixed bin (35) ext static;

dcl  pds$processid bit (36) ext static;
dcl  pds$process_group_id char (32) ext static;
dcl  tc_data$initializer_id bit (36) aligned external static;
dcl  tty_buf$fnp_config_flags (1:8) bit (1) unaligned external static;
dcl  tty_buf$lct_ptr pointer external static;
dcl  sst$astsize fixed bin external;
dcl  sys_info$page_size fixed bin external;
dcl  sys_info$seg_size_256K fixed bin (19) external;

/* INTERNAL STATIC */

dcl  (
     FNP_DOWN init (2)
     ) fixed bin int static options (constant);

dcl  fdump_seg_event char (4) aligned init ("fnpd") static options (constant);
dcl  cleanup condition;
dcl  record_quota_overflow condition;


/* BASED */

dcl  tally_words (fnp_tally) bit (36) aligned based;

dcl  1 dump_355_control aligned based (data_ptr),		/* word used to supply 355 address and tally for fdump */
       2 address_mode bit (3) unaligned,		/* always 36-bit addressing ("001"b) */
       2 fnp_address bit (15) unaligned,
       2 tally fixed bin (17) unaligned;

dcl  1 dump_6670_control aligned based (data_ptr),	/* word used to supply DN6670 address and tally for fdump */
       2 fnp_address fixed bin (18) unsigned unaligned,
       2 unpaged bit (1) unaligned,
       2 mbz bit (5) unaligned,
       2 tally fixed bin (12) unsigned unaligned;

dcl  1 load_info aligned based (load_info_ptr),		/* used to assign baud rates and line types at bootload time */
       2 no_entries fixed bin,
       2 entries (0 refer (load_info.no_entries)),
         3 devx fixed bin,
         3 baud_rate fixed bin,
         3 line_type fixed bin;



wire:
     entry (a_fnp_no, a_ptr, a_absadr, a_count, a_code);

/* entry called to wire a_count words for segment at a_ptr */
/* This does not require lock protection. If we miss a deconfig, tough */

	fnp_no = a_fnp_no;				/* copy args */
	segptr = a_ptr;
	nwords = a_count;

	call validate_fnp_ret ("wire");
	call validate_assigned_ret ("wire");

	if fnp_info.wired				/* Someone did it already? */
	then do;
	     a_code = 0;				/* be gracious */
	     if datanet_info.trace
	     then call syserr (ANNOUNCE, "fnp_util$wire: FNP ^a already wired.", fnp_info.fnp_tag);
						/* but note for debugging */
	     return;
	end;

	astep = grab_aste$grab_aste_io (segptr, nwords, code);
						/* make segment stay active */

	if code ^= 0
	then go to wire_error_return;

	fnp_info.astep = astep;
	fnp_info.n_pages_wired = divide (nwords + sys_info$page_size - 1, sys_info$page_size, 17, 0);

	call pc_abs$wire_abs (astep, 0, fnp_info.n_pages_wired, code);
						/* no contig -- we will use a page table! */
	if code ^= 0
	then do;
	     call grab_aste$release_io (astep);		/* couldn't wire, so let aste go */
	     go to wire_error_return;
	end;
	call fill_bootload_page_table;		/* sets the variable absadr */
	if datanet_info.trace
	then call syserr (ANNOUNCE, "fnp_util$wire: seg: ^p n_pages: ^d astep ^p", segptr, fnp_info.n_pages_wired,
		astep);

	a_absadr = auto_absadr;			/* relative to page table its 0 */
	fnp_info.wired = "1"b;

wire_error_return:
	if code ^= 0 & (datanet_info.trace | datanet_info.debug_stop)
	then do;
	     call syserr$error_code (ANNOUNCE, code, "fnp_util$wire: failed.");
	     call STOP_CHECK ("wire");
	end;
	a_code = code;
	return;


load:
     entry (a_fnp_no, a_absadr, a_ev_chan, a_version, a_image_name, a_fnp_mem_size, a_load_info_ptr, a_code);

/* entry to initiate bootload I/O for loading an FNP */
/* This cannot lock until it has the dump seg wired */

	fnp_no = a_fnp_no;
	fnp_mem_size = a_fnp_mem_size;
	auto_absadr = a_absadr;
	call validate_fnp_ret ("load");
	call validate_assigned_ret ("load");

	if datanet_info.trace
	then call syserr (ANNOUNCE, "fnp_util$load: FNP ^d ADDR ^o", fnp_no, auto_absadr);

	if fnp_info.bootloading
	then do;					/* we can't do it while it's already happening */
	     code = error_table_$invalid_state;
	     call syserr (ANNOUNCE, "fnp_util$load: FNP load already in progress for FNP ^a.", fnp_info.fnp_tag);
	     go to load_return;
	end;

	if ^fnp_info.wired
	then do;
	     code = error_table_$invalid_state;
	     if datanet_info.trace
	     then call syserr (ANNOUNCE, "fnp_util$load: FNP ^a not wired.", fnp_info.fnp_tag);
	     go to load_return;
	end;

	if fnp_info.running
	then do;
	     code = error_table_$invalid_state;
	     if datanet_info.trace
	     then call syserr (ANNOUNCE, "fnp_util$load: FNP ^a is running.", fnp_info.fnp_tag);
	     go to load_return;
	end;

	if fnp_info.t_and_d_in_progress
	then do;
	     code = error_table_$invalid_state;
	     if datanet_info.trace
	     then call syserr (ANNOUNCE, "fnp_util$load: FNP ^a is running T&D.", fnp_info.fnp_tag);
	     go to load_return;
	end;

/* process the load_info data */

	load_info_ptr = a_load_info_ptr;
	if load_info.no_entries ^= fnp_info.no_of_channels
	then do;
	     code = error_table_$bad_mpx_load_data;
	     go to load_return;
	end;

	cur_la_no = "7"b3;				/* no current line adaptor */
	n_pcbs = load_info.no_entries;
	do i = 1 to load_info.no_entries;		/* get baud rates to store in pcbs */
	     pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (i));
	     if load_info (i).devx ^= pcb.devx		/* load_info does not match pcb_array */
	     then do;
		code = error_table_$bad_mpx_load_data;
		go to load_return;
	     end;
	     pcb.baud_rate = load_info (i).baud_rate;
	     pcb.line_type = load_info (i).line_type;

	     if ^pcb.is_hsla			/* this pcb is for an lsla subchannel */
	     then do;				/* must figure out its slot number */
		if pcb.la_no ^= cur_la_no		/* starting a new line adaptor */
		then do;
		     cur_la_no = pcb.la_no;
		     cur_slot_no = 1;
		end;

		pcb.slot_no = bit (cur_slot_no, 6);
		if pcb.baud_rate <= 110
		then cur_slot_no = cur_slot_no + 1;	/* this subchan uses 1 time slot */
		else if pcb.baud_rate <= 150
		then cur_slot_no = cur_slot_no + 2;	/* this subchan uses 2 time slots */
		else cur_slot_no = cur_slot_no + 3;	/* this subchan uses 3 time slots */
	     end;
	end;

/* it's okay to try to load */

	call lock_fnp;
	if ^fnp_info.io_manager_assigned		/* lost race with deconfig */
	then do;					/* or even T&D */
	     call unlock_fnp;
	     code = error_table_$io_not_assigned;	/* perhaps deconfigured, but ... */
	     go to load_return;
	end;
	version = a_version;
	call syserr (ANNOUNCE, "Loading FNP ^a, ^a ^a", fnp_info.fnp_tag, a_image_name, version);

	fnp_info.boot_ev_chan = a_ev_chan;
	fnp_info.boot_process_id = pds$processid;
	fnp_info.version = version;
	fnp_info.fnp_mem_size = fnp_mem_size * 1024;
	fnp_info.bootloading = "1"b;
	datanet_mbx.mailbox_requests = 0;		/* clear fields in mbx for this load */
	datanet_mbx.term_inpt_mpx_wd = "0"b;
	datanet_mbx.last_mbx_req_count = 0;
	string (datanet_mbx.mbx_used_flags) = "0"b;

	datanet_mbx.crash_data.fault_code = 0;
	datanet_mbx.crash_data.ic = 0;
	datanet_mbx.crash_data.iom_fault_status = 0;
	datanet_mbx.crash_data.fault_word = 0;

	auto_absadr = sys_info$page_size * FIRST_BOOTLOAD_PAGEX;

	call mask_dia;				/* Mask the IOM channel  to initialize it */
	call connect_to_dia_paged (auto_absadr, 0, "72"b3, dia_timeout);
						/* 72 (8), bootload command */

	if dia_timeout
	then code = error_table_$no_io_interrupt;
	else code = 0;				/* all is well so far */
	call unlock_fnp;				/* however, deconfigure has a problem if bootloading is on! */

load_return:
	if code ^= 0 & (datanet_info.trace | datanet_info.debug_stop)
	then do;
	     call syserr$error_code (ANNOUNCE, code, "fnp_util$load: Error loading FNP ^a.", fnp_info.fnp_tag);
	     call STOP_CHECK ("load");
	end;
	a_code = code;
	return;


info:
     entry (a_fnp_no, a_absadr, norm_int_cell, emergency_int_cell, a_code);

/* entry called to return address of mailbox area and FNP interrupt cells */

	fnp_no = a_fnp_no;
	call validate_fnp_ret ("info");

	a_absadr = absadr (fnp_info.mbx_pt, code);
	if code = 0
	then do;					/* provided everything's ok */
	     norm_int_cell = 3;			/* customary assignments */
	     emergency_int_cell = 7;
	end;

	a_code = code;
	return;

fill_page_table:
     entry (a_fnp_no, a_code);

	fnp_no = a_fnp_no;
	call validate_fnp_ret ("fill_page_table");
	call validate_assigned_ret ("fill_page_table");
	if fnp_info.ptx ^= -1 | fnp_info.ptp ^= null ()
	then do;
	     call syserr (ANNOUNCE, "fnp_util$fill_page_table: page table already assigned for FNP ^a.",
		fnp_info.fnp_tag);
	     call STOP_CHECK ("fill_page_table");
	end;
	call get_page_table (code);
	if code ^= 0 & (datanet_info.trace | datanet_info.debug_stop)
	then do;
	     call syserr$error_code (ANNOUNCE, code, "fnp_util$fill_page_table: ioi_page_table$get failed for FNP ^a.",
		fnp_info.fnp_tag);
	     call STOP_CHECK ("fill_page_table");
	end;
	a_code = code;
	return;

free_page_table:
     entry (a_fnp_no, a_code);

	fnp_no = a_fnp_no;
	call validate_fnp_ret ("free_page_table");
	if fnp_info.ptx = -1
	then do;
	     call syserr (ANNOUNCE, "fnp_util$free_page_table: no page table assigned for FNP ^a.", fnp_info.fnp_tag);
	     go to ret_bad_code;
	end;
	call ioi_page_table$put (fnp_info.ptx, code);
	fnp_info.ptx = -1;
	fnp_info.ptp = null ();
	a_code = code;
	return;


unwire:
     entry (a_fnp_no, a_code);

/* entry called to abort bootload or cleanup from successful bootload */
/* no locking for same reason as wire */

	fnp_no = a_fnp_no;
	call validate_fnp_ret ("unwire");

/* Don't demand assigned so that loads aborted by deconfig can unwire */

	call internal_unwire;
	fnp_info.bootloading = "0"b;

	if code ^= 0 & (datanet_info.trace | datanet_info.debug_stop)
	then do;
	     call syserr$error_code (ANNOUNCE, code, "fnp_util$unwire: Unwire failed for FNP ^a.", fnp_info.fnp_tag);
	     call STOP_CHECK ("unwire");
	end;
	a_code = code;
	return;


/* RECONFIGURATION ENTRYPOINTS */

/* Configure -- add a FNP to the available collection for assignment */

configure:
     entry (a_fnp_no, a_code);

	fnp_no = a_fnp_no;
	call validate_fnp_ret ("configure");
	call lock_fnp;
	if fnp_info.available
	then do;
	     code = error_table_$io_configured;
	     if datanet_info.trace | datanet_info.debug_stop
	     then call syserr (ANNOUNCE, "fnp_util$configure: FNP ^a already configured.", fnp_info.fnp_tag);
	     call STOP_CHECK ("configure");
	     go to configure_return;
	end;
	fnp_info.available = "1"b;
	fnp_info.io_manager_assigned = "0"b;		/* clean up */
	fnp_info.flags = "0"b;			/* state information */
configure_return:
	call unlock_fnp;
	if code = 0
	then do;
	     call config_$find_2 ("prph", "fnp" || fnp_info.fnp_tag, prph_fnp_cardp);
	     prph_fnp_card.state = "on";
	     call syserr (ANNOUNCE, "fnp_util: FNP ^a added to configuration^[ by ^a^].", fnp_info.fnp_tag,
		pds$processid ^= tc_data$initializer_id, pds$process_group_id);
	end;
	a_code = code;
	return;

/**** Deconfigure -- remove from configuration.
      This entrypoint causes a FNP crash for the selected FNP.
*/

deconfigure:
     entry (a_fnp_no, a_code);

	fnp_no = a_fnp_no;
	call validate_fnp_ret ("deconfigure");
	call lock_fnp;

	if ^fnp_info.available
	then do;
	     code = error_table_$io_not_configured;
	     go to deconfigure_return;
	end;

	fnp_info.available = "0"b;			/* throttle init_multiplexer */

	if ^fnp_info.io_manager_assigned
	then go to deconfigure_return;

	/*** here is the interesting part. What we do depends on who is active */

	if fnp_info.t_and_d_in_progress
	then do;
	     call unlock_fnp;			/* must lock in correct order */
	     call release_t_and_d;			/* unassigns channel */
	     go to deconfigure_return_unlocked;
	end;
	else do;
	     call mask_dia;				/* stop it from writing to us or sending stuff */
	     call fnp_multiplexer$unassign (fnp_no, (0)); /* has to succeed, we are under lock */
	     /*** turns off io_manager_assigned for us, nailing io_manager callers */
	     auto_fnp_msg.fnp_no = fnp_info.fnp_number;
	     auto_fnp_msg.state = FNP_DOWN;
	     auto_fnp_msg.flags = "0"b;
	     auto_fnp_msg.deconfigured = "1"b;
	     unspec (message) = unspec (auto_fnp_msg);
	     call pxss$ring_0_wakeup (fnp_info.boot_process_id, fnp_info.boot_ev_chan, message, (0));
	end;

	/*** all callers of io_manager must hold LCTE lock and check io_manager_assigned */

deconfigure_return:
	call unlock_fnp;
deconfigure_return_unlocked:
	if code = 0
	then do;
	     call config_$find_2 ("prph", "fnp" || fnp_info.fnp_tag, prph_fnp_cardp);
	     prph_fnp_card.state = "off";
	     call syserr (ANNOUNCE, "fnp_util: FNP ^a deleted from configuration^[ by ^a^].", fnp_info.fnp_tag,
		pds$processid ^= tc_data$initializer_id, pds$process_group_id);
	end;
	a_code = code;
	return;




fdump:
     entry (a_fnp_no, a_fnp_type, a_fnp_mem_size, a_ptr, a_code);

/* entry to read in contents of FNP core for fdump_fnp_.  It is passed a pointer
   *  to the segment in which the dump is supposed to be put.  The one-page fnp_dump_seg
   *  is wired down, and FNP core is read into it in chunks.
*/

/* Like load, locking must follow wiring of fnp dump seg */

	fnp_no = a_fnp_no;
	fnp_type = a_fnp_type;
	fnp_mem_size = a_fnp_mem_size;
	segptr = a_ptr;

	call validate_fnp_ret ("fdump");

	if fnp_info.running | fnp_info.bootloading | fnp_info.t_and_d_in_progress
	then do;
	     code = error_table_$invalid_state;		/* nope */
	     go to ret_bad_code;
	end;

	fnp_dump_ptr = addr (fnp_dump_seg$);
	on cleanup
	     begin;
	     if fnp_dump_seg.lock = pds$processid
	     then call lock$unlock (addr (fnp_dump_seg.lock), fdump_seg_event);
	end;
	call lock$wait (addr (fnp_dump_seg.lock), fdump_seg_event, code);
	if code ^= 0
	then go to ret_bad_code;

	call wire_dump_seg;
	if code ^= 0
	then go to unlock_dump_seg;

	fnp_dump_seg.flags = "0"b;			/* aggregately */
	call assign_interrupt (dump_interrupt, code);	/* we will handle DIA interrupts for this */
	if code ^= 0				/* checks to make sure we haven't been forcible unassigned */
	then go to unwire_buffer;

	data_ptr = addr (fnp_dump_seg.data);
	if fnp_type = DN6670
	then dump_6670_control.unpaged = "1"b;		/* absolute 36-bit addressing for DIA */
	else dump_355_control.address_mode = "001"b;	/* 36-bit addressing for DIA */
	fnp_size = fnp_mem_size * 512;		/* size of FNP core in 36-bit words */

/* before we start, set up handler for record-quota overflow */

	on record_quota_overflow
	     begin;
	     code = error_table_$rqover;
	     go to restore_interrupts;
	end;

/* loop reading chunks of FNP memory */

	fnp_addr = 0;
	do offset = 0 to fnp_size by 1021;		/* 3 words less than a page */
	     fnp_tally = min (1021, fnp_size - offset);
	     call setup_dump_ctl_word;
	     call fdump_seg_io ("fdump", "75"b3, code);	/*  test data xfer */
	     if code ^= 0
	     then go to restore_interrupts;

/* Now copy the data into the permanent seg */

	     ptr (segptr, offset) -> tally_words = addr (fnp_dump_seg.data (2)) -> tally_words;
						/* word 0 and 1 are control words */
	end;

restore_interrupts:
	call unassign_interrupt;
unwire_buffer:
	call unwire_dump_seg;			/* and unwire buffer */
unlock_dump_seg:
	call lock$unlock (addr (fnp_dump_seg.lock), fdump_seg_event);
ret_bad_code:
	a_code = code;
	return;


fdump_seg_io:
     proc (caller, a_diaop, code);

dcl  caller char (32);
dcl  a_diaop bit (6) aligned;
dcl  code fixed bin (35);

	start_time = clock ();
	if datanet_info.trace
	then call syserr (ANNOUNCE, "fnp_util$fdump_seg_io: ^2.3b for ^a.", a_diaop, caller);
	call lock_fnp;				/* must be locked to connect */
	if ^fnp_info.io_manager_assigned
	then do;
	     call unlock_fnp;
	     code = error_table_$io_not_assigned;
	     return;
	end;

	fnp_dump_seg.fdump = "1"b;			/* so notify can be done */
	call pxss$addevent (tty_ev);
	call connect_to_dia (auto_absadr, 0, a_diaop, dia_timeout);
	call unlock_fnp;
	if ^dia_timeout
	then do;
	     call pxss$wait;			/* wait for interrupt */
	     if datanet_info.trace
	     then call syserr (ANNOUNCE, "fnp_util (fdump_seg_io): returned from first wait.");
	end;
	else do;
	     call pxss$delevent (tty_ev);
	     if datanet_info.trace
	     then call syserr (ANNOUNCE, "fnp_util (fdump_seg_io): DIA timeout.");
	     code = error_table_$no_io_interrupt;
	     return;
	end;

	do while (fnp_dump_seg.fdump);		/* when we get notify, make sure it's the right one */
	     if clock () - start_time > 5 * 1000 * 1000	/* if it's been more than 5 seconds */
	     then do;				/* punt */
		if datanet_info.trace
		then call syserr (ANNOUNCE, "fnp_util (fdump_seg_io): FNP timeout.");
		code = error_table_$no_io_interrupt;
		return;
	     end;

	     call pxss$addevent (tty_ev);
	     if fnp_info.t_and_d_in_progress
	     then if fnp_info.t_and_d_lev_3_occurred | fnp_info.t_and_d_lev_7_occurred
		then do;
		     code = 0;
		     return;
		end;
	     if fnp_dump_seg.fdump			/* it wasn't */
	     then call pxss$wait;			/* wait some more */
	     else call pxss$delevent (tty_ev);		/* otherwise we needn't have added event */
	end;
	code = 0;
     end fdump_seg_io;

dump_interrupt:
     entry (a_fnp_no, a_level, a_dummy);

/* this is our temporary FNP interrupt handler while doing fdump i/o */

dcl  a_dummy bit (36) aligned parameter;

	fnp_dump_ptr = addr (fnp_dump_seg$);
	infop = addr (dn355_data$);
	if datanet_info.trace
	then call syserr (ANNOUNCE,
		"fnp_util (dump_interrupt): Interrupt for FNP ^d level ^d. fnp_dump_seg.fdump = ""^b""b", a_fnp_no,
		a_level, fnp_dump_seg.fdump);
	if fnp_dump_seg.fdump			/* if we're really interested in this one */
	then do;
	     fnp_dump_seg.fdump = "0"b;		/* so we'll recognize notify */
	     call pxss$notify (tty_ev);
	end;
	return;

fnp_tandd_setup:
     entry (a_fnp_no, a_ev_chan, a_code);

	fnp_no = a_fnp_no;
	call validate_fnp_ret ("fnp_tandd_setup");

/* Must set up lcte ptr first if not done already, or lock
   won't work.  Chicken/egg problem notwithstanding, this will
   work, because other guy doing same thing. */

	temp_fnp_name = get_fnp_name_ (fnp_no);
	if fnp_info.lcte_ptr = null
	then do;
	     call priv_channel_manager$get_devx (temp_fnp_name, devx, code);
	     if code ^= 0
	     then go to ret_bad_code;
	     fnp_info.lcte_ptr = addr (tty_buf$lct_ptr -> lct.lcte_array (devx));
	end;

	call lock_fnp;

	if fnp_info.bootloading | fnp_info.running | fnp_info.t_and_d_in_progress
	then do;
	     code = error_table_$invalid_state;
	     go to tandd_setup_loses_unlock;
	end;

	call fnp_multiplexer$assign (fnp_no, code);
	if code ^= 0
	then do;
	     call syserr$error_code (ANNOUNCE, code, "fnp_util: channel assignment failed for FNP ^a.",
		fnp_info.fnp_tag);
	     go to tandd_setup_loses_unlock;
	end;

	call ioam_$assign ((fnp_info.io_manager_chx), fnp_tandd_release_handler, code);
	if code ^= 0
	then do;
	     call syserr$error_code (ANNOUNCE, code, "fnp_util: ioam_$assign failed for FNP ^a.", fnp_info.fnp_tag);
	     go to tandd_setup_loses_unlock;
	end;
	fnp_info.boot_process_id = pds$processid;
	fnp_info.t_and_d_lev_3_occurred, fnp_info.t_and_d_lev_7_occurred = "0"b;
	call syserr (ANNOUNCE, "fnp_util: assigned FNP ^a to ^a for T & D.", temp_fnp_name, pds$process_group_id);
	fnp_info.t_and_d_in_progress = "1"b;

tandd_setup_loses_unlock:
	if code = 0
	then fnp_info.boot_ev_chan = a_ev_chan;
	call unlock_fnp;
	a_code = code;
	return;

fnp_tandd_release_handler:
     entry (a_devx, a_code);

	devx = a_devx;
	infop = addr (dn355_data$);
	fnp_dump_ptr = addr (fnp_dump_seg$);
	on cleanup
	     begin;
	     if fnp_dump_seg.lock = pds$processid
	     then call lock$unlock (addr (fnp_dump_seg.lock), fdump_seg_event);
	end;
	do fnp_no = 1 to datanet_info.no_of_355s;
	     fnpp = addr (datanet_info.per_datanet (fnp_no));
	     if devx = fnp_info.io_manager_chx
	     then if fnp_info.t_and_d_in_progress
		then call release_t_and_d;
	end;
	return;

/**** T and D does not have to worry about force deconfiguration,
      since it is completely released at deconfigure time.
      Validate_fnp_tandd_ret will generate an error code if
      deconfiguration has stolen the FNP. */


fnp_tandd_detach:
     entry (a_fnp_no, a_code);
	fnp_no = a_fnp_no;

	call validate_fnp_tandd_ret ("fnp_tandd_detach");
	call lock_fnp;
	call validate_assigned_ret ("fnp_tandd_detach");

	call mask_dia;

	fnp_info.boot_process_id = "000000000000"b3;
	fnp_info.t_and_d_in_progress = "0"b;
	fnp_info.t_and_d_lev_3_occurred, fnp_info.t_and_d_lev_7_occurred = "0"b;
	call ioam_$unassign ((fnp_info.io_manager_chx), (0));
	call fnp_multiplexer$unassign (fnp_no, code);
	if code ^= 0
	then call syserr$error_code (ANNOUNCE, code, "fnp_util: io channel unassignment failed for FNP ^a.",
		fnp_info.fnp_tag);
	call syserr (ANNOUNCE, "fnp_util: releasing FNP ^a from ^a", fnp_info.fnp_id.fnp_tag, pds$process_group_id);
	call unlock_fnp;
	a_code = 0;
	return;

fnp_tandd_mask:
     entry (a_fnp_no, a_code);
	fnp_no = a_fnp_no;
	call validate_fnp_tandd_ret ("fnp_tandd_mask");
	call lock_fnp;
	call validate_assigned_ret ("fnp_tandd_mask");

	call mask_dia;
	call unlock_fnp;
	a_code = 0;
	return;

fnp_tandd_send_int:
     entry (a_fnp_no, a_level, a_code);
	fnp_no = a_fnp_no;
	call validate_fnp_tandd_ret ("fnp_tandd_send_int");
	call lock_fnp;
	call validate_assigned_ret ("fnp_tandd_send_int");

	fnp_info.t_and_d_lev_3_occurred, fnp_info.t_and_d_lev_7_occurred = "0"b;
	call connect_to_dia (0, a_level, "71"b3, dia_timeout);
	call unlock_fnp;
	if dia_timeout
	then a_code = error_table_$no_io_interrupt;
	a_code = 0;
	return;

fnp_tandd_get_ints:
     entry (a_fnp_no, a_ints, a_code);
	fnp_no = a_fnp_no;
	call validate_fnp_tandd_ret ("fnp_tandd_get_ints");
	call lock_fnp;
	call validate_assigned_ret ("fnp_tandd_get_ints");
	a_ints = fnp_info.t_and_d_lev_3_occurred || fnp_info.t_and_d_lev_7_occurred;
	fnp_info.t_and_d_lev_3_occurred, fnp_info.t_and_d_lev_7_occurred = "0"b;
	call unlock_fnp;
	a_code = 0;
	return;

fnp_tandd_read:
     entry (a_fnp_no, a_ptr, a_count, a_fnp_addr, a_fnp_type, a_code);
	opcode = "75"b3;
	go to fnp_t_and_d_rw_merge;

fnp_tandd_write:
     entry (a_fnp_no, a_ptr, a_count, a_fnp_addr, a_fnp_type, a_code);
	opcode = "76"b3;
fnp_t_and_d_rw_merge:
/**** To avoid LONG delays in deconfiguration, this does not lock
      the LCTE lock except around the connects themselves. */
	fnp_no = a_fnp_no;
	segptr = a_ptr;
	nwords = a_count;
	fnp_type = a_fnp_type;
	fnp_addr = a_fnp_addr;
	fnp_dump_ptr = addr (fnp_dump_seg$);
	call validate_fnp_tandd_ret ("fnp_tandd_rw");

	on cleanup
	     begin;
	     if fnp_dump_seg.lock = pds$processid
	     then call lock$unlock (addr (fnp_dump_seg.lock), fdump_seg_event);
	end;

	data_ptr = addr (fnp_dump_seg.data);

	call lock$wait (addr (fnp_dump_seg.lock), fdump_seg_event, code);
	if code ^= 0
	then go to ret_bad_code;
	if fnp_type = DN6670
	then dump_6670_control.unpaged = "1"b;
	else dump_355_control.address_mode = "1"b3;
	offset = 0;
	do while (nwords > 0);
	     fnp_tally = min (308, nwords);
	     nwords = nwords - fnp_tally;
	     call setup_dump_ctl_word;
	     if opcode = "76"b3			/* WRITE */
	     then addr (fnp_dump_seg.data (2)) -> tally_words = addrel (segptr, offset) -> tally_words;
	     call wire_dump_seg;
	     if code ^= 0
	     then go to unlock_dump_seg;
	     fnp_info.t_and_d_lev_3_occurred, fnp_info.t_and_d_lev_7_occurred = "0"b;
	     fnp_info.t_and_d_notify_requested = "1"b;

	     call fdump_seg_io ("fnp_tandd_rw", opcode, code);

	     fnp_info.t_and_d_lev_3_occurred, fnp_info.t_and_d_lev_7_occurred = "0"b;
	     call unwire_dump_seg;
	     if code ^= 0
	     then go to unlock_dump_seg;
	     if opcode = "75"b3			/* READ */
	     then addrel (segptr, offset) -> tally_words = addr (fnp_dump_seg.data (2)) -> tally_words;

	     offset = offset + fnp_tally;
	end;
	code = 0;
	go to unlock_dump_seg;


validate_assigned_ret:
     procedure (caller);

declare  caller char (32);

	if ^fnp_info.io_manager_assigned
	then do;
	     code = error_table_$io_not_assigned;
	     if datanet_info.trace | datanet_info.debug_stop
	     then call syserr$error_code (ANNOUNCE, code,
		     "fnp_util$validate_assigned_ret (^a): IO manager assignment lacking.", caller);
	     call STOP_CHECK ("validate_assigned_ret");
	     call unlock_fnp;
	     go to ret_bad_code;
	end;
	return;
     end validate_assigned_ret;


validate_fnp_ret:
     procedure (caller);

declare  caller char (32);

/* internal procedure to ensure that FNP number is reasonable */

	infop = addr (dn355_data$);

	if fnp_no <= 0 | fnp_no > max_no_355s
	then do;
	     code = error_table_$io_not_defined;
ERROR:
	     if datanet_info.trace | datanet_info.debug_stop
	     then call syserr$error_code (ANNOUNCE, code, "fnp_util$^a: Invalid call for FNP ^d.", caller, fnp_no);
	     call STOP_CHECK (caller);
	     go to ret_bad_code;
	end;

	if ^tty_buf$fnp_config_flags (fnp_no)
	then do;
	     fnpp = null;
	     code = error_table_$io_not_defined;
	     go to ERROR;
	end;

	code = 0;
	fnpp = addr (datanet_info.per_datanet (fnp_no));
	mbxp = fnp_info.mbx_pt;
	if datanet_info.trace
	then call syserr (ANNOUNCE, "fnp_util$^a: Tracing call for fnp ^a.", caller, fnp_info.fnp_tag);

	return;

     end validate_fnp_ret;



validate_fnp_tandd_ret:
     proc (caller);

declare  caller char (32);

	call validate_fnp_ret (caller);
	if ^fnp_info.t_and_d_in_progress
	then code = error_table_$invalid_state;
	else if fnp_info.boot_process_id ^= pds$processid
	then code = error_table_$io_no_permission;
	if code ^= 0
	then do;
	     if (datanet_info.trace | datanet_info.debug_stop)
	     then call syserr$error_code (ANNOUNCE, code, "fnp_util$^a: Invalid call.", caller);
	     go to ret_bad_code;
	end;
	return;					/* validate_fnp_ret did trace */
     end validate_fnp_tandd_ret;

setup_dump_ctl_word:
     proc;

	if fnp_type = DN6670
	then do;
	     dump_6670_control.fnp_address = fnp_addr + 2 * offset;
	     dump_6670_control.tally = fnp_tally;
	end;
	else do;
	     dump_355_control.fnp_address = bit (fixed (fnp_addr + 2 * offset, 15), 15);
	     dump_355_control.tally = fnp_tally;
	end;
     end;

wire_dump_seg:
     proc;

	astep = get_ptrs_$given_segno (fixed (baseno (fnp_dump_ptr), 17));
	call pc_abs$wire_abs_contig (astep, 0, 1, code);	/* wire a page */
	if code = 0
	then auto_absadr = absadr (addr (fnp_dump_seg.data), code);
						/* fdump_seg_io needs this */
     end;

unwire_dump_seg:
     proc;

	astep = get_ptrs_$given_segno (fixed (baseno (fnp_dump_ptr), 17));
	call pc_abs$unwire_abs (astep, 0, 1);
	return;
     end unwire_dump_seg;


assign_interrupt:
     proc (handler, code);

/* internal procedure to set handler for IOM interrupt to our proc. */

dcl  handler entry;

dcl  iom_code fixed bin (35);
dcl  code fixed bin (35);

	call lock_fnp;				/* discourage reconfiguration */
	if ^fnp_info.io_manager_assigned		/* already deconfigured?  */
	then if ^fnp_info.available			/* already deconfigured! */
	     then do;
		code = error_table_$io_not_configured;
		return;
	     end;

/**** It may already be unassigned, as in dump of down MPX */

	if fnp_info.io_manager_assigned
	then do;
	     call io_manager$unassign (fnp_info.io_manager_chx, code);
	     if code ^= 0
	     then call syserr$error_code (CRASH, code, "fnp_util: Could not unassign FNP ^a at reassign_interrupt.",
		     fnp_info.fnp_tag);
	     fnp_info.io_manager_assigned = "0"b;
	end;					/* now make new assignment */

	call io_manager$assign (fnp_info.io_manager_chx, fnp_info.io_chanid, handler, (fnp_no), (null ()), iom_code);
	call unlock_fnp;
	if code = 0				/* if there wasn't anything more interesting to report */
	then do;
	     code = iom_code;			/* then report this */
	     fnp_info.io_manager_assigned = "1"b;
	end;

	return;

     end assign_interrupt;

unassign_interrupt:
     procedure;

	call io_manager$unassign (fnp_info.io_manager_chx, (0));
	fnp_info.io_manager_assigned = "0"b;
	return;
     end unassign_interrupt;



connect_to_dia:
     proc (address, level, cmd, timeout);

/* internal procedure to do DIA i/o */

dcl  old_pcw bit (36) aligned;
dcl  timeout bit (1) aligned;
dcl  address fixed bin (24);
dcl  level fixed bin (3);
dcl  cmd bit (6) aligned;
dcl  1 ima aligned like io_manager_arg;
dcl  paged bit (1) aligned;
dcl  1 a_dia_pcw aligned based (mbxp),			/* better declaration than the one used when MCS is running */
       2 address fixed bin (18) unsigned unaligned,
       2 error bit (1) unaligned,
       2 pad1 bit (3) unaligned,
       2 parity bit (1) unaligned,
       2 pad2 bit (1) unaligned,
       2 pad3 bit (3) unaligned,			/* if we used address extension this would be important */
       2 interrupt_level fixed bin (3) unsigned unaligned,
       2 command bit (6) unaligned;

	paged = "0"b;
	go to common;

connect_to_dia_paged:
     entry (address, level, cmd, timeout);

	paged = "1"b;

common:
	unspec (a_dia_pcw) = ""b;
	if address > sys_info$seg_size_256K
	then call syserr (CRASH, "fnp_util (connect_to_dia): address > 256K");
	a_dia_pcw.address = address;
	a_dia_pcw.interrupt_level = level;
	a_dia_pcw.command = cmd;
	if datanet_info.trace | datanet_info.debug_stop
	then call syserr (ANNOUNCE, "fnp_util (connect): ^[ paged PTP ^p^;^s^] PCW ^w", paged, fnp_info.ptp,
		unspec (datanet_mbx.dia_pcw));
	if datanet_info.debug_stop
	then do;
	     call syserr (ANNOUNCE, "fnp_util: stop before connect.");
	     call syserr (CRASH, "  ptp: ^p astep: ^p", fnp_info.ptp, fnp_info.astep);
	end;

/* parity on pcw REQUIRED */

	string (datanet_mbx.dia_pcw) = dn355_util$compute_parity (string (datanet_mbx.dia_pcw));

	ima.chx = fnp_info.io_manager_chx;
	if paged
	then ima.ptp = fnp_info.ptp;
	else ima.ptp = null ();
	old_pcw = unspec (a_dia_pcw);
	call io_manager$connect_direct (ima);
	do i = 1 to 100000 while (unspec (a_dia_pcw) = old_pcw);
	end;
	if a_dia_pcw.error | old_pcw = unspec (a_dia_pcw)
	then do;
	     call syserr (ANNOUNCE,
		"fnp_util (connect_to_dia): DIA mailbox PCW ^[error^;timeout^] for channel ^a, FNP ^a. PCW was ^w.",
		a_dia_pcw.error, fnp_info.io_chanid, fnp_info.fnp_tag, old_pcw);
	     timeout = "1"b;
	end;
	else timeout = "0"b;
	return;
     end connect_to_dia;


mask_dia:
     procedure;
	call io_manager$mask (fnp_info.io_manager_chx);	/* mask the channel to initialize it */
     end mask_dia;

internal_unwire:
     procedure;

declare  px fixed bin;

/* internal procedure to undo work of wire entry */

	if fnpp = null
	then return;
	if ^fnp_info.wired
	then return;

	ioptp = fnp_info.ptp;
	if ioptp ^= null ()
	then do px = FIRST_BOOTLOAD_PAGEX to FIRST_BOOTLOAD_PAGEX + fnp_info.n_pages_wired;
	     unspec (page_table.ptw (px)) = ""b;	/* as of next connect, no more references */
	end;

	astep = fnp_info.astep;
	call pc_abs$unwire_abs (astep, 0, fnp_info.n_pages_wired);
	call grab_aste$release_io (astep);
	fnp_info.wired = "0"b;
	return;

     end internal_unwire;

release_t_and_d:
     procedure;

declare  unlock_dump_seg bit (1) aligned;

	call lock$wait (addr (fnp_dump_seg.lock), fdump_seg_event, code);
						/* wait for finish */
	unlock_dump_seg = (code = 0);			/* if user held lock for other reason, leave it locked ? */
	call syserr (0, "fnp_util: force detaching FNP ^a from process ^w.", fnp_info.fnp_id.fnp_tag,
	     fnp_info.boot_process_id);
	call lock_fnp;				/* hold the LCTE lock (or the config lock) */
	fnp_info.boot_process_id = "000000000000"b3;
	fnp_info.boot_ev_chan = 0;
	fnp_info.t_and_d_in_progress = "0"b;
	fnp_info.t_and_d_lev_3_occurred, fnp_info.t_and_d_lev_7_occurred = "0"b;
	call fnp_multiplexer$unassign (fnp_no, code);
	if code ^= 0
	then call syserr$error_code (ANNOUNCE, code, "fnp_util: io channel unassignment failed for FNP ^a.",
		fnp_info.fnp_tag);
	call unlock_fnp;
	if unlock_dump_seg
	then call lock$unlock (addr (fnp_dump_seg.lock), fdump_seg_event);
	return;
     end release_t_and_d;


lock_fnp:
     procedure;

declare  code fixed bin (35);

	if locked | config_locked
	then call syserr (CRASH, "fnp_util: lock_fnp called with lock locked.");
	locked, config_locked = "0"b;

	call lock$lock_fast (addr (datanet_info.configuration_lock));
	config_locked = "1"b;			/* LCTE cannot get initialized after this point */
	if fnp_info.lcte_ptr = null ()
	then return;				/* that is the whole story */
	else if ^fnp_info.lcte_ptr -> lcte.initialized	/* no mpx in the house */
	then return;				/* and the config lock locks out T&D I/O */

	/*** here, there is a multiplexer, so we have to lock against it */

	call fnp_multiplexer$fnp_lock (fnpp, code);
	if code = 0
	then do;
	     locked = "1"b;				/* lcte was initialized, and we now own it */
	     call lock$unlock_fast (addr (datanet_info.configuration_lock));
						/* if init_multiplexer finds the LCTE initialized, it aborts */
						/* so all we are protecting against is ourselves */
	     config_locked = "0"b;
	end;
	return;

unlock_fnp:
     entry;

	if locked
	then call fnp_multiplexer$fnp_unlock (fnpp);
	locked = "0"b;
	if config_locked
	then call lock$unlock_fast (addr (datanet_info.configuration_lock));
	config_locked = "0"b;
	return;
     end lock_fnp;


STOP_CHECK:
     procedure (Tracer);
declare  Tracer char (*);

	if datanet_info.debug_stop
	then call syserr (CRASH, "fnp_util$^a: Debugging stop (type go to continue).", Tracer);
	return;
     end STOP_CHECK;


get_page_table:
     procedure (code);

declare  pagex fixed bin;
declare  px fixed bin;
declare  1 seg_pt (0:255) aligned like l68_core_ptw based (ptp);
declare  ptp pointer;
declare  code fixed bin (35);

	io_page_table_size = 256;			/* always, for datanet */
	call ioi_page_table$get (io_page_table_size * sys_info$page_size, fnp_info.ptx, code);
						/* Direct channel has no bounds check so we need all 256 */
	if code ^= 0
	then return;
	fnp_info.ptp, ioptp = ioi_page_table$ptx_to_ptp (fnp_info.ptx);

	unspec (page_table) = ""b;

/**** leave page zero invalid */

/**** First, dn355_mailbox */

	do px = 1 to 3;
	     io_ptwp = addr (page_table.ptw (px));
	     io_ptw.address = px;			/* absolute page number */
	     io_ptw.write = "1"b;
	     io_ptw.valid = "1"b;
	end;

/**** Now, tty_buf */

	astep = get_ptrs_$given_segno (segno (addr (tty_buf$)));
	pagex = FIRST_TTY_BUF_PAGEX;
	ptp = addwordno (astep, sst$astsize);
	do px = 0 to bin (aste.csl, 9) - 1;		/* no null pages here */
	     io_ptwp = addr (page_table.ptw (pagex));
	     io_ptw.address = seg_pt (px).frame;
	     io_ptw.write = "1"b;
	     io_ptw.valid = "1"b;
	     pagex = pagex + 1;
	end;					/* tty_buf is now described to the channel */
	return;

fill_bootload_page_table:
     entry;					/* fill in io ptws for bootload segment */

/**** astep is already set to the bootload image aste */

	pagex = FIRST_BOOTLOAD_PAGEX;
	ptp = addwordno (astep, sst$astsize);
	auto_absadr = pagex * sys_info$page_size;
	ioptp = fnp_info.ptp;

	do px = 0 to fnp_info.n_pages_wired - 1;
	     io_ptwp = addr (page_table.ptw (pagex));
	     io_ptw.address = seg_pt (px).frame;
	     io_ptw.write = "0"b;
	     io_ptw.valid = "1"b;
	     pagex = pagex + 1;
	end;

	if datanet_info.trace
	then do px = 0 to 255;
	     if unspec (page_table.ptw (px)) ^= ""b
	     then call syserr (ANNOUNCE, "     ^4o ^w", px, unspec (page_table.ptw (px)));
	end;

	return;

     end get_page_table;


/* format: off */

/* INCLUDE FILES */
%page; %include aste;
%page; %include config_prph_fnp_card;
%page; %include dn355_mailbox;
%page; %include lct;
%page; %include dn355_data;
%page; %include pcb;
%page; %include fnp_dump_seg;
%page; %include fnp_types;
%page; %include io_manager_dcls;
%page; %include io_page_tables;
%page; %include io_chnl_util_dcls;
%page; %include "ptw.l68";
       declare ptp pointer;
%page; %include syserr_constants;
%page; %include tty_buf;
%include fnp_mpx_msg_;




/* BEGIN MESSAGE DOCUMENTATION

   Message:
   Loading FNP X, CORE_IMAGE VERSION

   S:  $info

   T:  Answering service initialization and each subsequent FNP
   bootload.

   M:  Loading of FNP X has begun with a core image named CORE_IMAGE
   (normally "mcs") of version number VERSION.

   A:  $ignore


   Message:
   fnp_util$wire: FNP T already wired (trace)


   Message:
   fnp_util$wire: failed. REASON (trace)


   Message:
   fnp_util$load: FNP load already in progress for FNP T.


   Message:
   fnp_util$load: FNP T not wired.


   Message:
   fnp_util$load: FNP T is running. (trace)


   Message:
   fnp_util$load: FNP T is running T&D.


   Message:
   fnp_util$load: Error loading FNP T. REASON (trace)


   Message:
   fnp_util$unwire: Unwire failed for FNP T. REASON


   Message:
   fnp_util$configure: FNP T already configured.


   Message:
   fnp_util: FNP T added to configuration^[ by NAME^].


   Message:
   FNP T deleted from configuration^[ by ^a^].


   Message:
   fnp_util$fdump_seg_io: IO_OP for CALLER (trace)


   Message:
   fnp_util: channel assignment failed for FNP ^T REASON. (tandd)


   Message:
   fnp_util: ioam_$assign failed for FNP T. REASON (tandd)


   Message:
   fnp_util: assigned FNP T to NAME for T & D.


   Message:
   fnp_util: io channel unassignment failed for FNP T. (tandd)


   Message: 
   fnp_util: releasing FNP T from NAME (tandd)


   Message:
   fnp_util$validate_assigned_ret (CALLER): IO manager assignment lacking. (trace)


   Message:
   fnp_util$ENTRY: Invalid call for FNP INDEX. (not in cdeck)


   Message:
   fnp_util$ENTRY: Tracing call for fnp T.


   Message:
   fnp_util$ENTRY: Invalid call. (trace)


   Message:
   fnp_util: Could not unassign FNP T at reassign_interrupt. 


   Message:
   fnp_util: force detaching FNP T from process PID.


   Message:
   fnp_util: io channel unassignment failed for FNP T. (tandd)


   Message:
   fnp_util: lock_fnp called with lock locked.


   Message:
   fnp_util$ENTRY: Debugging stop (type go to continue).

   END MESSAGE DOCUMENTATION */


     end fnp_util;
