/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1985 *
   *                                                         *
   *********************************************************** */

/* Utilities used by the message segment primitive operations (mseg_) */

/* Created:  April 1985 by G. Palter based upon mseg_, mseg_error_, mseg_convert_, ms_salvager_, and ms_salv_util_ */
/* Modified: 20 May 1985 by G. Palter to avoid spurious RQOs while salvaging */

/* format: style3,linecom */

mseg_utils_:
     procedure ();

	return;					/* not an entrypoint */


/* Parameters */

dcl	P_mseg_operation_ptr
			pointer parameter;

dcl	P_code		fixed binary (35) parameter;	/* begin_operation: indicates whether we setup OK (Output);
						   salvage_for_cause: why we must salvage (Input) */

dcl	P_operation_id	bit (36) aligned parameter;	/* begin_operation: the operation to be started */
dcl	P_operation_name	character (*) parameter;	/* begin_operation: set to the name of the operation */
dcl	P_mseg_dir_name	character (*) parameter;	/* begin_operation: set to segment's parent if known */
dcl	P_mseg_entryname	character (*) parameter;	/* begin_operation: set to segment' entryname if known */
dcl	P_mseg_ptr	pointer parameter;		/* begin_operation: set -> the segment if available */
dcl	P_rqo_detected	bit (1) aligned parameter;	/* begin_operation: set ON => an RQO occured while locking */


/* Local copies of parameters */

dcl	operation_name	character (64);

dcl	mseg_dir_name	character (168);
dcl	mseg_entryname	character (32);

dcl	rqo_detected	bit (1) aligned;

dcl	code		fixed binary (35);


/* Remaining declarations */

dcl	1 mseg_segment_header
			aligned based (mseg_ptr) like mseg_segment.header;

dcl	1 long_status	aligned like status_branch;

dcl	test_lock		bit (36) aligned;

dcl	salvage_for_cause_arguments
			pointer;

dcl	path_code		fixed binary (35);
dcl	(salvage_report_text_lth, callers_report_text_lth)
			fixed binary (21);
dcl	(mseg_max_length, mseg_cur_length)
			fixed binary (19);
dcl	(n_header_blocks, n_possible_messages, n_messages_recovered)
			fixed binary (18);
dcl	(n_arguments, prefix_lth)
			fixed binary;

dcl	MSEG_UTILS_	character (32) static options (constant) initial ("mseg_utils_");

/* format: off */

dcl	SALVAGER_AND_UPGRADING_ACTIONS
	     (0:9) character (64) varying static options (constant) initial ("",
		"Call to hcs_$get_access_info_seg failed",
		"Call to hcs_$get_max_length_seg failed",
		"Unable to compute size for allocating message blocks",
		"Trying to locate upgrade support procedure",
		"Unable to salvage the segment prior to upgrading it",
		"Initializing the temporary upgraded segment in [pd]",
		"Copying messages into the temporary upgraded segment in [pd]",
		"Call to hcs_$status_long failed",
		"Rebuilding the contents of the message segment");

dcl      (CALL_GET_ACCESS_INFO	initial (1),
	CALL_GET_MAX_LENGTH		initial (2),
	COMPUTING_BLOCK_SIZE	initial (3),
	FINDING_SUPPORT_PROCEDURE	initial (4),
	SALVAGING_ORIGINAL_SEGMENT	initial (5),
	PREPARING_UPGRADED_TEMPORARY	initial (6),
	CREATING_UPGRADED_TEMPORARY	initial (7),
	CALL_STATUS_LONG		initial (8),
	REBUILDING_SEGMENT		initial (9)
	)		fixed binary static options (constant);

dcl      (error_table_$bad_segment, error_table_$bad_subr_arg, error_table_$bigarg, error_table_$improper_data_format,
	error_table_$invalid_max_length, error_table_$lock_wait_time_exceeded, error_table_$no_message,
	error_table_$no_s_permission, error_table_$not_seg_type, error_table_$notalloc, error_table_$null_info_ptr,
	error_table_$rqover, error_table_$seg_busted, error_table_$segfault, error_table_$unimplemented_version)
			fixed binary (35) external;

/* format: on */

dcl	sys_info$ring1_privilege
			bit (36) aligned external;

dcl	admin_gate_$guaranteed_eligibility_off
			entry ();
dcl	admin_gate_$guaranteed_eligibility_on
			entry ();
dcl	admin_gate_$syserr_error_code
			entry (/* fixed binary, fixed binary (35), character (*) */) options (variable);
dcl	aim_check_$greater_or_equal
			entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
dcl	aim_check_$in_range entry (bit (72) aligned, (2) bit (72) aligned) returns (bit (1) aligned);
dcl	aim_util_$get_privileges
			entry (bit (72) aligned) returns (bit (36) aligned);
dcl	cu_$arg_count	entry (fixed binary, fixed binary (35));
dcl	cu_$arg_list_ptr	entry () returns (pointer);
dcl	find_condition_info_
			entry (pointer, pointer, fixed binary (35));
dcl	get_group_id_	entry () returns (character (32));
dcl	get_lock_id_	entry () returns (bit (36) aligned);
dcl	get_process_max_authorization_
			entry () returns (bit (72) aligned);
dcl	get_ring_		entry () returns (fixed binary (3));
dcl	get_system_free_area_
			entry () returns (pointer);
dcl	get_temp_segment_	entry (character (*), pointer, fixed binary (35));
dcl	hcs_$fs_get_path_name
			entry (pointer, character (*), fixed binary, character (*), fixed binary (35));
dcl	hcs_$get_access_info_seg
			entry (pointer, pointer, fixed binary (35));
dcl	hcs_$get_max_length_seg
			entry (pointer, fixed binary (19), fixed binary (35));
dcl	hcs_$make_entry	entry (pointer, character (*), character (*), entry, fixed binary (35));
dcl	hcs_$set_damaged_sw_seg
			entry (pointer, bit (1) aligned, fixed binary (35));
dcl	hcs_$status_long	entry (character (*), character (*), fixed binary (1), pointer, pointer, fixed binary (35));
dcl	hcs_$truncate_seg	entry (ptr, fixed bin (19), fixed bin (35));
dcl	ioa_$general_rs	entry (pointer, fixed binary, fixed binary, character (*), fixed binary (21),
			bit (1) aligned, bit (1) aligned);
dcl	ioa_$rsnpnnl	entry () options (variable);
dcl	mseg_message_$add_message_for_mseg
			entry (pointer, character (*), fixed binary (35));
dcl	mseg_utils_$salvage_for_cause
			entry (/* pointer, fixed binary (35) */) options (variable);
dcl	pathname_		entry (character (*), character (*)) returns (character (168));
dcl	release_temp_segment_
			entry (character (*), pointer, fixed binary (35));
dcl	set_lock_$lock	entry (bit (36) aligned, fixed binary, fixed binary (35));
dcl	set_lock_$unlock	entry (bit (36) aligned, fixed binary (35));
dcl	sort_items_indirect_$bit
			entry (pointer, pointer, fixed binary (24));
dcl	sub_err_		entry () options (variable);

dcl	(addr, clock, codeptr, copy, convert, currentsize, divide, fixed, hbound, index, lbound, length, max, mod, null,
	rtrim, setwordno, stacq, string, substr, unspec, wordno)
			builtin;

dcl	(cleanup, record_quota_overflow, seg_fault_error)
			condition;
%page;
/* Initialize the perprocess values in mseg_data_ */

mseg_utils_$initialize:
     entry ();

	mseg_data_$group_id = get_group_id_ ();
	mseg_data_$lock_id = get_lock_id_ ();
	mseg_data_$process_max_authorization = get_process_max_authorization_ ();

	mseg_data_$execution_ring = get_ring_ ();	/* this is OK as static data is per ring ... */

	return;
%page;
/* Begin an operation -- First, we verify that the supplied mseg_operation includes the fields required for the operation.
   We then guarantee elibility, if possible, and perform the actions requested by the operation's begin flags, if any. */

mseg_utils_$begin_operation:
     entry (P_operation_id, P_mseg_operation_ptr, P_operation_name, P_mseg_dir_name, P_mseg_entryname, P_mseg_ptr,
	P_rqo_detected, P_code);

	mseg_operation_data_ptr = addr (P_operation_id);
	if (mseg_operation_data.operation_id < lbound (mseg_operations_$names, 1))
	     | (mseg_operation_data.operation_id > hbound (mseg_operations_$names, 1))
	then call sub_err_ (error_table_$bad_subr_arg, MSEG_UTILS_, ACTION_CANT_RESTART, null (), 0,
		"Operation ID = ^12.3b", P_operation_id);

	operation_name = mseg_operations_$names (mseg_operation_data.operation_id);

	mseg_operation_ptr = P_mseg_operation_ptr;

	if mseg_operation_ptr = null ()
	then call sub_err_ (error_table_$null_info_ptr, operation_name, ACTION_CANT_RESTART, null (), 0);

	if mseg_operation.version ^= MSEG_OPERATION_VERSION_1
	then call sub_err_ (error_table_$unimplemented_version, operation_name, ACTION_CANT_RESTART, null (), 0,
		"mseg_operation.version = ^d.", mseg_operation.version);

	mseg_operation.operation = P_operation_id;	/* set the operation code */
	mseg_operation_data_ptr = addr (mseg_operation.operation);

	mseg_dir_name = "";				/* initialize output values */
	mseg_entryname = "";
	mseg_ptr = null ();
	rqo_detected = "0"b;
	code = 0;

	mseg_operation_data.already_salvaged,		/* for cleanup handlers and the like */
	     mseg_operation_data.unlock_segment = "0"b;


	/*** Check that required data is present -- In the current implementation, all operations require either the
	     pathname or mseg_ptr.  Of the remaining fields in an mseg_operation, the primitives will only occasionally
	     use the access_info, message_info, and wakeup_state structures.  */

	if mseg_operation_data.required_data.pathname & mseg_operation_data.required_data.mseg_ptr
	then do;	/*** Either the pathname or mseg_ptr or both may be used */
		if ^mseg_operation.mseg_pathname_valid & ^mseg_operation.mseg_ptr_valid
		then call sub_err_ (error_table_$bad_subr_arg, operation_name, ACTION_CANT_RESTART, null (), 0,
			"The mseg_operation does not include either a valid pathname or a valid mseg_ptr.");
		if mseg_operation.access_info_valid
		then do;				/* always give preference to the pathname derived in ring 0 */
			mseg_dir_name = mseg_operation.access_info.dir_name;
			mseg_entryname = mseg_operation.access_info.entryname;
		     end;
		else if mseg_operation.mseg_pathname_valid
		then do;				/* caller has supplied the pathname */
			mseg_dir_name = mseg_operation.dir_name;
			mseg_entryname = mseg_operation.entryname;
		     end;
		if mseg_operation.mseg_ptr_valid	/* caller has also supplied an mseg_ptr */
		then mseg_ptr = mseg_operation.mseg_ptr;
	     end;

	else if mseg_operation_data.required_data.pathname
	then /*** This operation requires a valid pathname */
	     if mseg_operation.access_info_valid
	     then do;				/* always give preference to the pathname derived in ring 0 */
		     mseg_dir_name = mseg_operation.access_info.dir_name;
		     mseg_entryname = mseg_operation.access_info.entryname;
		end;
	     else if mseg_operation.mseg_pathname_valid
	     then do;				/* caller has supplied the pathname */
		     mseg_dir_name = mseg_operation.dir_name;
		     mseg_entryname = mseg_operation.entryname;
		end;
	     else call sub_err_ (error_table_$bad_subr_arg, operation_name, ACTION_CANT_RESTART, null (), 0,
		     "The mseg_operation does not include a valid pathname.");

	else if mseg_operation_data.required_data.mseg_ptr
	then /*** This operation requires a valid mseg_ptr */
	     if mseg_operation.mseg_ptr_valid
	     then mseg_ptr = mseg_operation.mseg_ptr;
	     else call sub_err_ (error_table_$bad_subr_arg, operation_name, ACTION_CANT_RESTART, null (), 0,
		     "The mseg_operation does not include a valid mseg_ptr.");

	else call sub_err_ (error_table_$bad_subr_arg, operation_name, ACTION_CANT_RESTART, null (), 0,
		"mseg_operation.operation does not request either the pathname or mseg_ptr.");

	if mseg_operation_data.required_data.access_info
	then if ^mseg_operation.suppress_access_checks	/* we'll only actually need it if checking access */
	     then if mseg_operation.access_info_valid
		then if mseg_operation.access_info.version ^= ENTRY_ACCESS_INFO_VERSION_1
		     then call sub_err_ (error_table_$unimplemented_version, operation_name, ACTION_CANT_RESTART,
			     null (), 0, "mseg_operation.access_info.version = ""^a"".",
			     mseg_operation.access_info.version);
		     else ;
		else call sub_err_ (error_table_$bad_subr_arg, operation_name, ACTION_CANT_RESTART, null (), 0,
			"The mseg_operation does not include a valid access_info structure.");

	if mseg_operation_data.required_data.message_info
	then if mseg_operation.message_info_valid
	     then if mseg_operation.message_info.version ^= MSEG_MESSAGE_INFO_V1
		then call sub_err_ (error_table_$unimplemented_version, operation_name, ACTION_CANT_RESTART, null (),
			0, "mseg_operation.message_info.version = ""^a"".", mseg_operation.message_info.version);
		else ;
	     else call sub_err_ (error_table_$bad_subr_arg, operation_name, ACTION_CANT_RESTART, null (), 0,
		     "The mseg_operation does not include a valid message_info structure.");

	if mseg_operation_data.required_data.wakeup_state
	then if mseg_operation.wakeup_state_valid
	     then if mseg_operation.wakeup_state.version ^= MSEG_WAKEUP_STATE_VERSION_1
		then call sub_err_ (error_table_$unimplemented_version, operation_name, ACTION_CANT_RESTART, null (),
			0, "mseg_operation.wakeup_state.version = ""^a"".", mseg_operation.message_info.version);
		else ;
	     else call sub_err_ (error_table_$bad_subr_arg, operation_name, ACTION_CANT_RESTART, null (), 0,
		     "The mseg_operation does not include a valid wakeup_state structure.");

	if mseg_operation_data.required_data.wakeup_state_version
	then if mseg_operation.wakeup_state.version ^= MSEG_WAKEUP_STATE_VERSION_1
	     then call sub_err_ (error_table_$unimplemented_version, operation_name, ACTION_CANT_RESTART, null (), 0,
		     "mseg_operation.wakeup_state.version = ""^a"".", mseg_operation.message_info.version);


	/*** Guarantee eligibility if running in the admin ring (ring 1) */

	if mseg_operation.call_admin_gate
	then call admin_gate_$guaranteed_eligibility_on ();


	/*** Lock the segment if requested */

	if mseg_operation_data.begin_flags.lock_segment
	then do;

		on seg_fault_error call seg_fault_handler ();
		on record_quota_overflow
		     begin;
			rqo_detected = "1"b;	/* let the caller handle RQOs */
			go to RETURN_FROM_BEGIN_OPERATION;
		     end;				/* ... avoids making return_from_begin_operation nonquick */

		if stacq (mseg_segment.lock, mseg_data_$lock_id, (36)"0"b)
		then code = 0;
		else call set_lock_$lock (mseg_segment.lock, 20, code);

		revert record_quota_overflow;
		revert seg_fault_error;

		if mseg_operation_data.begin_flags.dont_check_lock_results
		then call return_from_begin_operation (code);
						/* our caller handles the lock non-standardly */

		else if code = 0			/* we've locked it */
		then mseg_operation_data.finish_flags.unlock_segment = "1"b;

		else if code = error_table_$lock_wait_time_exceeded
		then call return_from_begin_operation (code);
						/* some other process is using the segment */

		else call salvage_and_return_from_begin (code);
	     end;					/* invalid_lock_reset or locked_by_this_process */


	else call return_from_begin_operation (0);	/* don't try anything else if we can't lock the segment */


	/*** Check the header for consistency and initialize it if requested */

	if mseg_operation_data.begin_flags.check_header_consistency
	then if (mseg_segment.sentinel = ""b) & (mseg_segment.header.version = 0)
	     then if mseg_operation_data.begin_flags.initialize_header
		then do;	/*** This segment does not have a header -- However, the operation about to be performed
			     needs the header to behave properly.  Therefore, we must initialize the header now. */

			mseg_segment.sentinel = MSEG_SEGMENT_SENTINEL;
			mseg_segment.header.version = MSEG_SEGMENT_VERSION_5;

			call hcs_$get_max_length_seg (mseg_ptr, mseg_max_length, code);
			if code ^= 0
			then call return_from_begin_operation (code);

			/*** Compute the number of available blocks in the segment based on its max length. */
			mseg_segment.block_size = mseg_data_$block_size;
			mseg_segment.n_blocks_allocated = divide (mseg_max_length, mseg_segment.block_size, 18, 0);
						/* format: off */
			n_header_blocks =
			     divide ((currentsize (mseg_segment_header)
				    + divide ((mseg_segment.n_blocks_allocated + 35), 36, 18, 0)
				    + mseg_segment.block_size - 1),
				   mseg_segment.block_size, 18, 0);
						/* format: on */
			if mseg_segment.n_blocks_allocated <= n_header_blocks
			then /*** The segment doesn't have room for any messages. */
			     call return_from_begin_operation (error_table_$invalid_max_length);
			mseg_segment.n_blocks_unused = mseg_segment.n_blocks_allocated - n_header_blocks;

			/*** Record that the header has been allocated. */
			mseg_segment.block_map.map = copy ("1"b, n_header_blocks);
		     end;


		else /*** This segment does not have a header -- Fortunately, the operation about to be performed
			doesn't require the header for to behave properly so we needn't do anything more. */
		     ;


	     else do;  /*** This segment appears to have a header -- Perform automatic conversion if necessary and then
			make the minimal consistency checks on the header. */

		     if mseg_segment.header.version ^= MSEG_SEGMENT_VERSION_5
		     then if (mseg_segment.header.version >= 2)
			     & (mseg_segment.header.version < MSEG_SEGMENT_VERSION_5)
			then call upgrade_seg ();
			else call salvage_and_return_from_begin (mseg_format_errors_$bad_mseg_version);

		     if mseg_segment.sentinel ^= MSEG_SEGMENT_SENTINEL
		     then call salvage_and_return_from_begin (mseg_format_errors_$bad_mseg_sentinel);

		     if mseg_segment.modification_in_progress
		     then call salvage_and_return_from_begin (mseg_format_errors_$modification_in_progress);

		     if mseg_segment.salvage_in_progress
		     then call salvage_and_return_from_begin (mseg_format_errors_$salvage_in_progress);
		end;


	else call return_from_begin_operation (0);	/* don't check count&chains without checking the header */


	/*** Check the message count and message chain for consistency if requested */

	if mseg_operation_data.begin_flags.check_count_consistency
	then if mseg_segment.n_messages = 0
	     then if (mseg_segment.message_chain.first_message ^= 0) | (mseg_segment.message_chain.last_message ^= 0)
		then call salvage_and_return_from_begin (mseg_format_errors_$inconsistent_message_count);
		else ;				/* no messages and no message chain */

	     else if mseg_segment.n_messages < 0
	     then call salvage_and_return_from_begin (mseg_format_errors_$negative_message_count);

	     else /*** if mseg_segment.n_messages > 0 then */
		if (mseg_segment.message_chain.first_message = 0) | (mseg_segment.message_chain.last_message = 0)
	     then call salvage_and_return_from_begin (mseg_format_errors_$inconsistent_message_count);


	/*** All done */

RETURN_FROM_BEGIN_OPERATION:
	P_operation_name = operation_name;
	P_mseg_dir_name = mseg_dir_name;
	P_mseg_entryname = mseg_entryname;
	P_mseg_ptr = mseg_ptr;
	P_rqo_detected = rqo_detected;

	P_code = code;

	return;



/* Return upon completion of the begin_operation entrypoint */

return_from_begin_operation:
     procedure (p_code);

dcl	p_code		fixed binary (35) parameter;

	code = p_code;				/* set the result code */
	go to RETURN_FROM_BEGIN_OPERATION;

     end return_from_begin_operation;



/* Salvage the message segment due to internal inconsistencies and return error_table_$bad_segment to our caller */

salvage_and_return_from_begin:
     procedure (p_format_error);

dcl	p_format_error	fixed binary (35) parameter;

	call mseg_utils_$salvage_for_cause (mseg_operation_ptr, p_format_error);

	call return_from_begin_operation (error_table_$bad_segment);

     end salvage_and_return_from_begin;
%page;
/* Finish an operation -- This entrypoint completes the normal processing of an operation whether or not said operation
   will return a non-zero status code to its caller.  This entrypoint will, under control of the finish flags embedded in
   mseg_operation.operation, truncate the segment if its empty and then unlock it.  However, if this operation doesn't
   hold the lock on the segment, this entrypoint will not even perform these actions as some other process may be using
   the segment or it may have been deleted if this is the delete_seg operation.  In any case, however, we turn off
   guaranteed eligibility if we had turned it on earlier.

   WARNING -- Do not call this entrypoint in a cleanup handler.  A cleanup handler must call abort_operation, instead. */

mseg_utils_$finish_operation:
     entry (P_mseg_operation_ptr);

	mseg_operation_ptr = P_mseg_operation_ptr;
	mseg_operation_data_ptr = addr (mseg_operation.operation);

	if ^mseg_operation_data.finish_flags.unlock_segment
	then return;

	mseg_ptr = mseg_operation.mseg_ptr;

	if mseg_operation_data.finish_flags.truncate_if_possible
	then if (mseg_segment.n_messages = 0)		/* truncate only if no messages ... */
		& ^mseg_segment.flags.wakeup_state_set	/* ... and no one is accepting wakeups ... */
		& ^mseg_segment.flags.salvaged	/* ... and it wasn't salvaged */
	     then call hcs_$truncate_seg (mseg_ptr, 1, (0));

	if ^stacq (mseg_segment.lock, (36)"0"b, mseg_data_$lock_id)
	then call set_lock_$unlock (mseg_segment.lock, (0));

	mseg_operation_data.finish_flags.unlock_segment = "0"b;

	if mseg_operation.call_admin_gate
	then call admin_gate_$guaranteed_eligibility_off ();

	return;
%page;
/* Abort an operation -- This entrypoint aborts the currently running operation.  If the operation had locked the message
   segment, this entrypoint will salvage and unlock the segment as it is possible that it has been left in an inconsistent
   state by whatever event has caused the operation to be unwound.  However, this entrypoint will not take these actions
   unless the current operation actually locked the segment; otherwise, we might salvage the segment while it was being
   used by another process.  In any case, however, we turn off guaranteed eligibility if we had turned it on earlier.

   WARNING -- Do not call this entrypoint except in a cleanup handler.  Use finish_operation, instead, for all other
   circumstances. */

mseg_utils_$abort_operation:
     entry (P_mseg_operation_ptr);

	mseg_operation_ptr = P_mseg_operation_ptr;

	if mseg_operation_ptr = null ()		/* caller hasn't even got an mseg_operation yet */
	then return;

	if ^mseg_operation.mseg_ptr_valid		/* no mseg_ptr -- a file system operation, no doubt */
	then return;

	if mseg_operation.mseg_ptr = null ()		/* delete_seg operation will null pointer if successful */
	then return;

	mseg_ptr = mseg_operation.mseg_ptr;
	mseg_operation_data_ptr = addr (mseg_operation.operation);

	if ^mseg_operation_data.finish_flags.unlock_segment
	then return;				/* we dare not do anything if we don't have it locked */

	if ^mseg_operation_data.finish_flags.already_salvaged
	then call mseg_utils_$salvage_for_cause (mseg_operation_ptr, 0, "The operation was terminated abnormally.");

	if ^stacq (mseg_segment.lock, (36)"0"b, mseg_data_$lock_id)
	then call set_lock_$unlock (mseg_segment.lock, (0));

	mseg_operation_data.finish_flags.unlock_segment = "0"b;

	if mseg_operation.call_admin_gate
	then call admin_gate_$guaranteed_eligibility_off ();

	return;
%page;
/* "Queue" to unlock the segment -- This entrypoint is used by those operations which manage the message segment's lock on
   their own when said operation determines that it has locked the segment and that it should, therefore, be unlocked when
   the operation finishes.  (At present, the only operation which uses this protocol is delete_seg.) */

mseg_utils_$request_unlock_on_finish:
     entry (P_mseg_operation_ptr);

	mseg_operation_ptr = P_mseg_operation_ptr;
	mseg_operation_data_ptr = addr (mseg_operation.operation);

	if mseg_operation_data.finish_flags.unlock_segment
	then return;				/* it's already going to be unlocked */

	mseg_ptr = mseg_operation.mseg_ptr;

	/*** Don't bother to "queue" to unlock the segment unless we already hold the lock */

	test_lock = mseg_segment.lock;
	if stacq (test_lock, (36)"0"b, mseg_data_$lock_id)
	then mseg_operation_data.finish_flags.unlock_segment = "1"b;

	return;
%page;
/* Salvage a message segment due to inconsistencies detected by our caller -- Before salvaging, an error report is
   constructed from our caller's error code and, optional, ioa_ control string and arguments.  If we are running in the
   adminitrative ring (ring 1), the report is placed in the SYSERR log; otherwise, it is displayed via sub_err_. */

mseg_utils_$salvage_for_cause:
     entry (P_mseg_operation_ptr, P_code) options (variable);

	mseg_operation_ptr = P_mseg_operation_ptr;
	mseg_operation_data_ptr = addr (mseg_operation.operation);

	if mseg_operation_data.finish_flags.already_salvaged
	then return;				/* don't try to salvage more than once per operation */

	mseg_operation_data.finish_flags.already_salvaged = "1"b;

	mseg_ptr = mseg_operation.mseg_ptr;

	if (mseg_operation_data.operation_id < lbound (mseg_operations_$names, 1))
	     | (mseg_operation_data.operation_id > hbound (mseg_operations_$names, 1))
	then operation_name = "mseg_$unknown_operation";
	else operation_name = mseg_operations_$names (mseg_operation_data.operation_id);


	/*** Determine the segment's pathname, minimum and maximum access classes, max length, and current length --
	     These data are required for proper operation of the salvager.  (Actually, the pathname isn't required but
	     is determined by the same call used to get the access classes.) */

	if mseg_operation.access_info_valid
	then do;					/* we already have the pathname and access classes */
		mseg_dir_name = mseg_operation.access_info.dir_name;
		mseg_entryname = mseg_operation.access_info.entryname;
	     end;

	else do;					/* we must get the pathname and access classes from ring-0 */
		mseg_operation.access_info.version = ENTRY_ACCESS_INFO_VERSION_1;
		call hcs_$get_access_info_seg (mseg_ptr, addr (mseg_operation.access_info), code);
		if code ^= 0			/* can't get the info we need: try for pathname for error */
		then do;
			call hcs_$fs_get_path_name (mseg_ptr, mseg_dir_name, (0), mseg_entryname, path_code);
			call abort_salvage_for_cause ((path_code = 0), CALL_GET_ACCESS_INFO);
		     end;
		mseg_operation.access_info_valid = "1"b;
		mseg_dir_name = mseg_operation.access_info.dir_name;
		mseg_entryname = mseg_operation.access_info.entryname;
	     end;

	call hcs_$get_max_length_seg (mseg_ptr, mseg_max_length, code);
	if code ^= 0
	then call abort_salvage_for_cause ("1"b, CALL_GET_MAX_LENGTH);

	call hcs_$status_long (mseg_dir_name, mseg_entryname, 0b, addr (long_status), null (), code);
	if (code ^= 0) & (code ^= error_table_$no_s_permission)
	then call abort_salvage_for_cause ("1"b, CALL_STATUS_LONG);
	if long_status.type ^= Segment
	then do;
		code = error_table_$not_seg_type;
		call abort_salvage_for_cause ("1"b, CALL_STATUS_LONG);
	     end;
	mseg_cur_length = min ((1024 * long_status.current_length), mseg_max_length);


	/*** Format and log/print the error report */

	prefix_lth = length (rtrim (operation_name)) + length (": ");

	call cu_$arg_count (n_arguments, (0));
	salvage_for_cause_arguments = cu_$arg_list_ptr ();

	begin options (non_quick);

dcl	1 salvage_report	unaligned,
	  2 prefix	character (prefix_lth) unaligned,
	  2 text		character (1024 - prefix_lth) unaligned;

	     salvage_report.prefix = rtrim (operation_name) || ": ";

	     call ioa_$rsnpnnl ("Beginning salvage of ^a for ^a.^[^/^5x^]", salvage_report.text,
		salvage_report_text_lth, pathname_ (mseg_dir_name, mseg_entryname), mseg_operation.caller.group_id,
		(n_arguments > 2));

	     if n_arguments > 2			/* caller has supplied additional information */
	     then do;
		     begin;
dcl	rest_of_salvage_report_text
			character (length (salvage_report.text) - salvage_report_text_lth) unaligned
			defined (salvage_report.text) position (salvage_report_text_lth + 1);
			call ioa_$general_rs (salvage_for_cause_arguments, 3, 4, rest_of_salvage_report_text,
			     callers_report_text_lth, "0"b, "0"b);
		     end;
		     salvage_report_text_lth = salvage_report_text_lth + callers_report_text_lth;
		end;

	     if mseg_operation.call_admin_gate
	     then begin;				/* report via SYSERR -- include entrypoint name in the text */
dcl	salvage_report_text character (prefix_lth + salvage_report_text_lth) unaligned defined (salvage_report)
			position (1);
		     call admin_gate_$syserr_error_code ((SYSERR_LOG_OR_DISCARD + SYSERR_RING1_ERROR), P_code,
			"^a^[^/^5x^]", salvage_report_text, (P_code ^= 0));
		end;

	     else begin;
dcl	salvage_report_text character (salvage_report_text_lth) unaligned defined (salvage_report.text);
		     call sub_err_ (P_code, operation_name, ACTION_DEFAULT_RESTART, null (), 0, "^[^/^]^a",
			(P_code ^= 0), salvage_report_text);
		end;
	end;


	/*** Actually salvage the segment and report the results */

	code = 0;

	call salvage_seg (n_possible_messages, n_messages_recovered);

	if mseg_operation.call_admin_gate
	then call admin_gate_$syserr_error_code ((SYSERR_LOG_OR_DISCARD + SYSERR_RING1_ERROR), 0,
		"^a: Completed salvage of ^a for ^a.^/^5x^d^[ out of ^d possible^;^s^] message^[s^] recovered.",
		operation_name, pathname_ (mseg_dir_name, mseg_entryname), mseg_operation.caller.group_id,
		n_messages_recovered, (n_messages_recovered ^= n_possible_messages), n_possible_messages,
		((n_messages_recovered ^= 1) | (n_possible_messages ^= 1)));

	else call sub_err_ (0, operation_name, ACTION_DEFAULT_RESTART, null (), 0,
		"Completed salvage of ^a for ^a.^/^5x^d^[ out of ^d possible^;^s^] message^[s^] recovered.",
		pathname_ (mseg_dir_name, mseg_entryname), mseg_operation.caller.group_id, n_messages_recovered,
		(n_messages_recovered ^= n_possible_messages), n_possible_messages,
		((n_messages_recovered ^= 1) | (n_possible_messages ^= 1)));

RETURN_FROM_SALVAGE_FOR_CAUSE:
	return;



/* Report our failure to salvage the segment and return to our caller */

abort_salvage_for_cause:
     procedure (p_have_pathname, p_failed_action);

dcl	p_have_pathname	bit (1) aligned parameter;
dcl	p_failed_action	fixed binary parameter;

	if mseg_operation.call_admin_gate
	then call admin_gate_$syserr_error_code ((SYSERR_LOG_OR_DISCARD + SYSERR_RING1_ERROR), code,
		"^a: Unable to salvage ^[^a^s^;^s^p (pathname unknown)^] for ^a.^/^5x^a^[ --^/^5x^]", operation_name,
		p_have_pathname, pathname_ (mseg_dir_name, mseg_entryname), mseg_ptr, mseg_operation.caller.group_id,
		SALVAGER_AND_UPGRADING_ACTIONS (p_failed_action), (code ^= 0));

	else call sub_err_ (code, operation_name, ACTION_DEFAULT_RESTART, null (), 0,
		"^[^/^5x^]^a.^/^5xUnable to salvage ^[^a^s^;^s^p (pathname unknown)^] for ^a.", (code ^= 0),
		SALVAGER_AND_UPGRADING_ACTIONS (p_failed_action), p_have_pathname,
		pathname_ (mseg_dir_name, mseg_entryname), mseg_ptr, mseg_operation.caller.group_id);

	go to RETURN_FROM_SALVAGE_FOR_CAUSE;

     end abort_salvage_for_cause;
%page;
/* Handle a segment fault while trying to lock the message segment -- If the fault occured because the segment is damaged,
   reset the damaged switch, salvage, and retry the locking operation.  If the fault occured for some other reason (e.g.,
   a connection failure), simply abort the attempt to lock the segment and return the reason to our caller. */

seg_fault_handler:
     procedure ();

dcl	1 local_ci	aligned like condition_info;
dcl	local_code	fixed binary (35);

	code = error_table_$segfault;			/* in case we can't determine the actual reason */

	unspec (local_ci) = ""b;
	local_ci.version = condition_info_version_1;

	call find_condition_info_ (null (), addr (local_ci), local_code);

	if local_code = 0				/* found the fault frame ... */
	then if local_ci.mc_ptr ^= null ()		/* ... and the machine conditions ... */
	     then if local_ci.mc_ptr -> mc.errcode ^= 0	/* ... and they provide specific details */
		then code = local_ci.mc_ptr -> mc.errcode;

	if (code = error_table_$seg_busted) & ^mseg_operation_data.begin_flags.dont_check_lock_results
	     & ^mseg_operation_data.finish_flags.already_salvaged
	then do;	/*** The segment is damaged and we haven't already tried to salvage it. */
		call hcs_$set_damaged_sw_seg (mseg_ptr, "0"b, (0));
		call mseg_utils_$salvage_for_cause (mseg_operation_ptr, code);
		if ^stacq (mseg_segment.lock, (36)"0"b, mseg_data_$lock_id)
		then call set_lock_$unlock (mseg_segment.lock, (0));
		return;				/* retry */
	     end;

	else do;	/*** Either it's some other form of segfault or we've already tried to fix it once -- Inform the user
		     that we can't access the segment.  He can either try to fix the segment or delete it. */
		mseg_operation_data.unlock_segment = "0"b;
		mseg_operation_data.truncate_if_possible = "0"b;
		go to RETURN_FROM_BEGIN_OPERATION;
	     end;

     end seg_fault_handler;
%page;
/* Upgrade an old format message segment to the current format -- We are always called with the segment locked. */

upgrade_seg:
     procedure () options (non_quick);

dcl	1 original_mseg_segment_header
			aligned based (original_mseg_ptr) like mseg_segment.header;
dcl	original_mseg_ptr	pointer;

dcl	1 upgraded_mseg_segment_header
			aligned based (upgraded_mseg_ptr) like mseg_segment.header;
dcl	upgraded_mseg_ptr	pointer;

dcl	original_mseg_message_bits
			bit (original_operation.message_info.ms_len) aligned
			based (original_operation.message_info.ms_ptr);

dcl	upgraded_segment	(upgraded_size) bit (36) aligned based;

dcl	system_area	area based (system_area_ptr);
dcl	system_area_ptr	pointer;

dcl	1 original_operation
			aligned like mseg_operation;
dcl	1 upgraded_operation
			aligned like mseg_operation;

dcl	upgrade_procedure_name
			character (32);
dcl	salvage_old_segment entry (pointer, bit (1) aligned) variable;
dcl	get_old_wakeup_state
			entry (pointer) variable;
dcl	read_old_message	entry (pointer, pointer, fixed binary (35)) variable;

dcl	(original_mseg_dir_name, upgraded_mseg_dir_name)
			character (168);
dcl	(original_mseg_entryname, upgraded_mseg_entryname)
			character (32);
dcl	original_version_picture
			picture "9";

dcl	(salvage_completed, rqo_detected)
			bit (1) aligned;

dcl	path_code		fixed binary (35);
dcl	upgraded_size	fixed binary (19);
dcl	(n_upgraded_blocks_allocated, n_upgraded_header_blocks, n_messages_discarded)
			fixed binary (18);
dcl	original_version	fixed binary;


	mseg_operation_data.finish_flags.already_salvaged = "1"b;
						/* prevent the current salvager from destroying the segment */

	original_operation.message_info.ms_ptr,		/* for cleanup handler */
	     upgraded_mseg_ptr = null ();

	on cleanup call cleanup_after_upgrade_seg ();

	code = 0;


	/*** Determine the segment's pathname, minimum and maximum access classes, and max length -- These data are
	     required for proper upgrading of the segment.  (Actually, the pathname isn't required but is determined by
	     the same call used to get the access classes.) */

	original_operation = mseg_operation;		/* we dare not change our caller's operation */
	original_mseg_ptr = original_operation.mseg_ptr;

	if original_operation.access_info_valid
	then do;					/* we already have the pathname and access classes */
		original_mseg_dir_name = original_operation.access_info.dir_name;
		original_mseg_entryname = original_operation.access_info.entryname;
	     end;

	else do;					/* we must get the pathname and access classes from ring-0 */
		original_operation.access_info.version = ENTRY_ACCESS_INFO_VERSION_1;
		call hcs_$get_access_info_seg (original_mseg_ptr, addr (original_operation.access_info), code);
		if code ^= 0			/* can't get the info we need: try for pathname for error */
		then do;
			call hcs_$fs_get_path_name (original_mseg_ptr, original_mseg_dir_name, (0),
			     original_mseg_entryname, path_code);
			call abort_upgrade_seg ((path_code = 0), CALL_GET_ACCESS_INFO);
		     end;
		original_operation.access_info_valid = "1"b;
		original_mseg_dir_name = original_operation.access_info.dir_name;
		original_mseg_entryname = original_operation.access_info.entryname;
	     end;

	call hcs_$get_max_length_seg (original_mseg_ptr, mseg_max_length, code);
	if code ^= 0
	then call abort_upgrade_seg ("1"b, CALL_GET_MAX_LENGTH);


	/*** Compute the size of the upgraded segment's header and block map and verify that there will be room in the
	     segment for at least one message */

	n_upgraded_blocks_allocated = divide (mseg_max_length, mseg_data_$block_size, 18, 0);

	n_upgraded_header_blocks =
	     divide
	     ((currentsize (upgraded_mseg_segment_header) + divide ((n_upgraded_blocks_allocated + 35), 36, 18, 0)
	     + mseg_data_$block_size - 1), mseg_data_$block_size, 18, 0);

	if n_upgraded_blocks_allocated < n_upgraded_header_blocks
	then do;
		code = error_table_$invalid_max_length;
		call abort_upgrade_seg ("1"b, 0);
	     end;


	/*** Find the proper support procedure -- A procedure named "mseg_upgrade_from_vN_", where N is a version
	     number, exists for any older version of message segment which can be upgraded to the current version.  This
	     procedure contains the three entrypoints which are required to upgrade that version of message segment --
	     salvage, get_wakeup_state, and read_message. */

	original_version = original_mseg_segment_header.version;

	upgrade_procedure_name = "mseg_upgrade_from_v" || convert (original_version_picture, original_version) || "_";

	call hcs_$make_entry (codeptr (upgrade_seg), upgrade_procedure_name, "salvage", salvage_old_segment, code);
	if code ^= 0
	then call abort_upgrade_seg ("1"b, FINDING_SUPPORT_PROCEDURE);

	call hcs_$make_entry (codeptr (upgrade_seg), upgrade_procedure_name, "get_wakeup_state", get_old_wakeup_state,
	     code);
	if code ^= 0
	then call abort_upgrade_seg ("1"b, FINDING_SUPPORT_PROCEDURE);

	call hcs_$make_entry (codeptr (upgrade_seg), upgrade_procedure_name, "read_message", read_old_message, code);
	if code ^= 0
	then call abort_upgrade_seg ("1"b, FINDING_SUPPORT_PROCEDURE);


	/*** Salvage the segment using its version's salvager */

	call salvage_old_segment (addr (original_operation), salvage_completed);

	if ^salvage_completed
	then do;
		code = 0;				/* the salvager hasalready given a detailed accouting ... */
		call abort_upgrade_seg ("1"b, SALVAGING_ORIGINAL_SEGMENT);
	     end;


	/*** Initialize the upgraded message segment -- This message segment is actually a temporary in the process
	     directory with an associated mseg_operation that will satisfy mseg_message_$add_message_for_mseg. */

	on record_quota_overflow
	     begin;
		/*** Any RQO that occurs between now and the completion of the message copying loop is considered
		     fatal to the conversion process.  This decision is proper as the only possible RQOs are either
		     while reading the original segment or writing into the upgraded segment.  As the upgraded segment
		     is in the process directory, an RQO writing into it is clearly fatal.  An RQO while reading the
		     original segment is fatal as, after the above salvaging, the original can not contain any message
		     which tries to reference a block which is in a page of zeroes because only a zero page can cause
		     an RQO while reading. */
		code = error_table_$rqover;
		call abort_upgrade_seg ("1"b, CREATING_UPGRADED_TEMPORARY);
	     end;

	upgraded_operation = original_operation;
	upgraded_operation.mseg_ptr_valid,		/* the original segment is never the upgraded one ... */
	     upgraded_operation.access_info_valid = "0"b; /* ... and its access info doesn't apply either */
	upgraded_operation.suppress_access_checks = "1"b; /* must be able to copy all messages */

	call get_temp_segment_ (operation_name, upgraded_mseg_ptr, code);
	if code ^= 0
	then call abort_upgrade_seg ("1"b, PREPARING_UPGRADED_TEMPORARY);

	upgraded_operation.mseg_ptr = upgraded_mseg_ptr;
	upgraded_operation.mseg_ptr_valid = "1"b;

	call mseg_utils_$begin_operation (mseg_operations_$copy_seg_target, addr (upgraded_operation), ((64)" "),
	     upgraded_mseg_dir_name, upgraded_mseg_entryname, upgraded_mseg_ptr, rqo_detected, code);
	if rqo_detected
	then code = error_table_$rqover;
	if code ^= 0
	then call abort_upgrade_seg ("1"b, PREPARING_UPGRADED_TEMPORARY);

	upgraded_mseg_segment_header.n_messages, upgraded_mseg_segment_header.date_time_last_salvaged = 0;
	unspec (upgraded_mseg_segment_header.message_chain) = ""b;
	string (upgraded_mseg_segment_header.flags) = ""b;
	unspec (upgraded_mseg_segment_header.hash_table) = ""b;

	upgraded_mseg_segment_header.sentinel = MSEG_SEGMENT_SENTINEL;
	upgraded_mseg_segment_header.version = MSEG_SEGMENT_VERSION_5;

	upgraded_mseg_segment_header.block_size = mseg_data_$block_size;
	upgraded_mseg_segment_header.n_blocks_allocated = n_upgraded_blocks_allocated;
	upgraded_mseg_segment_header.n_blocks_unused = n_upgraded_blocks_allocated - n_upgraded_header_blocks;

	upgraded_mseg_ptr -> mseg_segment.block_map.map = copy ("1"b, n_upgraded_header_blocks);


	/*** Upgrade the segment's wakeup acceptance state */

	unspec (upgraded_mseg_segment_header.wakeup_state) = ""b;

	call get_old_wakeup_state (addr (original_operation));

	if original_operation.wakeup_state_valid
	then do;
		upgraded_mseg_segment_header.wakeup_state_set = "1"b;
		upgraded_mseg_segment_header.wakeup_state.state = original_operation.wakeup_state;
	     end;


	/*** Upgrade the messages -- A message is upgraded by reading it from the original segment and adding it to the
	     upgraded segment in the process directory.  If we can't read a message, we consider this to be a fatal
	     error in the conversion process.  If we can't add a message because it's too large, we remember the event
	     but continue copying.  We must continue copying because subsequent messages may be small enough to fit in
	     the upgraded segment.  Our final report when the upgrade is complete will report any lost messages. */

	original_operation.suppress_access_checks,	/* insure that all messages are copied */
	     upgraded_operation.suppress_access_checks = "1"b;
	upgraded_operation.add_message_info_all_valid = "1"b;

	n_messages_discarded = 0;

	original_operation.message_info.version = MSEG_MESSAGE_INFO_V1;
	string (original_operation.message_info.control_flags) = ""b;
	original_operation.message_info.ms_ptr = null ();

	system_area_ptr = get_system_free_area_ ();

	original_operation.message_info.message_code = MSEG_READ_FIRST;
	call read_old_message (addr (original_operation), system_area_ptr, code);

	do while (code = 0);

	     upgraded_operation.message_info = original_operation.message_info;
	     substr (upgraded_operation.message_info.ms_id, 1, 18) = ""b;

	     call mseg_message_$add_message_for_mseg (addr (upgraded_operation), operation_name, code);
	     if (code = error_table_$bigarg) | (code = error_table_$notalloc)
	     then n_messages_discarded = n_messages_discarded + 1;
	     else if code ^= 0
	     then call abort_upgrade_seg ("1"b, CREATING_UPGRADED_TEMPORARY);

	     if original_operation.message_info.ms_ptr ^= null ()
	     then do;
		     free original_mseg_message_bits in (system_area);
		     original_operation.message_info.ms_ptr = null ();
		end;

	     original_operation.message_info.message_code = MSEG_READ_AFTER_SPECIFIED;
	     call read_old_message (addr (original_operation), system_area_ptr, code);
	end;

	if code ^= error_table_$no_message		/* we were unable to read a message */
	then call abort_upgrade_seg ("1"b, CREATING_UPGRADED_TEMPORARY);

	revert record_quota_overflow;

	code = 0;					/* message copying succeeded! */


	/*** Copy the upgraded segment into place -- If an RQO occurs while moving the segment back into place, we will
	     consider the conversion completed but we will also salvage the segment with the current salvager to discard
	     any incomplete messages. */

	upgraded_size =
	     upgraded_mseg_segment_header.block_size
	     * (upgraded_mseg_segment_header.n_blocks_allocated - upgraded_mseg_segment_header.n_blocks_unused);

	call hcs_$truncate_seg (original_mseg_ptr, upgraded_size, (0));

	on record_quota_overflow
	     begin;
		mseg_operation_data.finish_flags.already_salvaged = "0"b;
		call mseg_utils_$salvage_for_cause (mseg_operation_ptr, error_table_$rqover,
		     "Some messages will be lost as a result of upgrading this segment.");
		go to COMPLETE_UPGRADE_AFTER_RQO;
	     end;

	original_mseg_ptr -> upgraded_segment = upgraded_mseg_ptr -> upgraded_segment;

	revert record_quota_overflow;

COMPLETE_UPGRADE_AFTER_RQO:
	call cleanup_after_upgrade_seg ();


	/*** The segment has been upgraded -- Display a report only if we were forced to discard any messages */

	if n_messages_discarded > 0
	then if original_operation.call_admin_gate
	     then call admin_gate_$syserr_error_code ((SYSERR_LOG_OR_DISCARD + SYSERR_RING1_ERROR), 0,
		     "^a: Upgraded ^a from version ^d to version ^d for ^a.^/^5x^d message^[s^] were deleted.",
		     operation_name, pathname_ (original_mseg_dir_name, original_mseg_entryname), original_version,
		     MSEG_SEGMENT_VERSION_5, original_operation.caller.group_id, n_messages_discarded,
		     (n_messages_discarded ^= 1));

	     else call sub_err_ (0, operation_name, ACTION_DEFAULT_RESTART, null (), 0,
		     "Upgraded ^a from version ^d to version ^d for ^a.^/^5x^d message^[s^] were deleted.",
		     pathname_ (original_mseg_dir_name, original_mseg_entryname), original_version,
		     MSEG_SEGMENT_VERSION_5, original_operation.caller.group_id, n_messages_discarded,
		     (n_messages_discarded ^= 1));

	mseg_operation_data.finish_flags.already_salvaged = "0"b;
						/* new problems during the operation should force a salvage */

	return;



/* Cleanup after upgrading a message segment */

cleanup_after_upgrade_seg:
     procedure ();

	if original_operation.message_info.ms_ptr ^= null ()
	then do;
		free original_mseg_message_bits in (system_area);
		original_operation.message_info.ms_ptr = null ();
	     end;

	if upgraded_mseg_ptr ^= null ()
	then do;
		call release_temp_segment_ (operation_name, upgraded_mseg_ptr, (0));
		upgraded_mseg_ptr = null ();
	     end;

	return;

     end cleanup_after_upgrade_seg;



/* Abort the attempt to upgrade a message segment -- We must report the failure and then return
   error_table_$improper_data_format to the caller of mseg_utils_$begin_operation. */

abort_upgrade_seg:
     procedure (p_have_pathname, p_failed_action);

dcl	p_have_pathname	bit (1) aligned parameter;
dcl	p_failed_action	fixed binary parameter;

	if original_operation.call_admin_gate
	then call admin_gate_$syserr_error_code ((SYSERR_LOG_OR_DISCARD + SYSERR_RING1_ERROR), code,
		"^a: Unable to upgrade ^[^a^s^;^s^p (pathname unknown)^] from version ^d to version ^d for ^a.^/^5x^[^a^[ --^/^5x^]^;^s^[^/^5x^]^]",
		operation_name, p_have_pathname, pathname_ (original_mseg_dir_name, original_mseg_entryname),
		original_mseg_ptr, original_version, MSEG_SEGMENT_VERSION_5, original_operation.caller.group_id,
		(p_failed_action ^= 0), SALVAGER_AND_UPGRADING_ACTIONS (p_failed_action), (code ^= 0));

	else call sub_err_ (code, operation_name, ACTION_DEFAULT_RESTART, null (), 0,
		"^[^[^/^5x^]^a.^;^s^s^]^/^5xUnable to upgrade ^[^a^s^;^s^p (pathname unknown)^] from version ^d to version ^d for ^a.",
		(p_failed_action ^= 0), (code ^= 0), SALVAGER_AND_UPGRADING_ACTIONS (p_failed_action),
		p_have_pathname, pathname_ (original_mseg_dir_name, original_mseg_entryname), original_mseg_ptr,
		original_version, MSEG_SEGMENT_VERSION_5, original_operation.caller.group_id);

	code = error_table_$improper_data_format;

	go to RETURN_FROM_BEGIN_OPERATION;

     end abort_upgrade_seg;

     end upgrade_seg;
%page;
/* Salvage a message segment */

salvage_seg:
     procedure (p_n_possible_messages, p_n_messages_recovered) options (non_quick);

dcl	(p_n_possible_messages, p_n_messages_recovered)
			fixed binary (18);
dcl	(n_possible_messages, n_messages_recovered)
			fixed binary (18);

/* format: idind30 */

dcl	1 local_mseg_segment_header	aligned like mseg_segment.header;

dcl	1 local_message_block	aligned,
	  2 header		aligned like message_block_header,
	  2 data_space,
	    3 data		bit (324) unaligned,
	  2 descriptor		aligned like message_descriptor;

dcl	1 local_wakeup_state	aligned like mseg_wakeup_state;

dcl	1 old_wakeup_state		aligned,
	  2 state,
	    3 switches		aligned,
	      4 allow_normal	bit (1) unaligned,
	      4 allow_urgent	bit (1) unaligned,
	      4 pad		bit (34) unaligned,
	    3 lock_id		bit (36) aligned,
	    3 event_channel		fixed bin (71),
	    3 process_id		bit (36) aligned,
	  2 pad			(64 - 5) bit (36) aligned;

/* format: idind20 */

dcl	mseg_segment_blocks (n_blocks_available) bit (36 * probable_block_size) aligned based (mseg_ptr);

dcl	prev_md_ptr	pointer;

dcl	mseg_segment_aim_range
			(2) bit (72) aligned;

dcl	block_size_unknown	bit (1) aligned;

dcl	(probable_block_size, n_blocks_available, n_header_blocks, last_used_block, max_blocks_per_message,
	n_blocks_recovered, last_recovered_block, block_id, n_message_blocks, message_block_idx, message_block_id,
	last_block_checked, next_unused_block, message_index)
			fixed binary (18);
dcl	(max_bits_in_first_block, max_bits_in_other_blocks)
			fixed binary;
dcl	hash_idx		fixed binary (9);


	/*** All RQOs are fatal -- Clearly any RQO while touching a page with data in it will prevent us from
	     successully salvaging the segment.  Further, if we touch a zero page that causes an RQO, we will have
	     increased the records used value and, as a result, we'll loop with an RQO until that page is flushed which
	     may be a very long time.  Therefore, we'll abort the salvage rather than loop. */

	on record_quota_overflow
	     begin;
		code = error_table_$rqover;
		call abort_salvage_for_cause ("1"b, REBUILDING_SEGMENT);
	     end;


	/*** Force the segment lock to insure that no one can get at the segment while we salvage it */

	mseg_segment.lock = mseg_data_$lock_id;
	mseg_operation_data.finish_flags.unlock_segment = "1"b;

	mseg_segment.salvage_in_progress = "1"b;

	mseg_segment_aim_range (1) = mseg_operation.access_info.parent_access_class;
	mseg_segment_aim_range (2) = mseg_operation.access_info.access_class;


	/*** Determine the block size used for this segment -- If the block size in the header does not yield the
	     correct number of available blocks (i.e., more blocks than are occupied by the header and block map), we
	     will assume that the segment uses the default block size.  If the default block size also fails, we will
	     abort our attempts at salvaging the segment. */

	block_size_unknown = "1"b;			/* ... really need do until */

	do probable_block_size = mseg_segment.block_size repeat (mseg_data_$block_size) while (block_size_unknown);

	     if (probable_block_size > (currentsize (message_block_header) + currentsize (message_descriptor)))
		& (probable_block_size < mseg_max_length)
	     then do;				/* this block size is large enough for proper operation */

		     n_blocks_available = divide (mseg_max_length, probable_block_size, 18, 0);
						/* format: off */
		     n_header_blocks =
			divide ((currentsize (mseg_segment_header) + divide ((n_blocks_available + 35), 36, 18, 0)
			         + probable_block_size - 1),
			        probable_block_size, 18, 0);
						/* format: on */
		     if (n_blocks_available > n_header_blocks) | (probable_block_size = mseg_data_$block_size)
		     then block_size_unknown = "0"b;	/* stop when the blocksize is OK or the default */
		end;
	end;

	if n_blocks_available <= n_header_blocks	/* couldn't get a workable block size */
	then call abort_salvage_for_cause ("1"b, COMPUTING_BLOCK_SIZE);

	max_blocks_per_message = divide (mseg_data_$max_message_size, probable_block_size, 18, 0);


	/*** Find the last non-zero block in the segment -- By definition, the messages in a correctly formatted message
	     segment will never contain a block which is entirely zeroes.  Therefore, the last non-zero block in the
	     segment is the upper bound of the blocks which we must examine for valid messages.  (The lower bound, of
	     course, is the first block after the block map.) */

	last_used_block = divide (mseg_cur_length, probable_block_size, 18, 0);
						/* hcs_$status_long has told us in which page to find it */


	/*** Compute the maximum amount of data which will fit into the first block and all subsequent blocks of a
	     message -- PL/I can perform this computation for us provided that we have valid values for
	     mseg_segment.block_size and message_block_header.data_lth.  Because we don't want to actually change the
	     segment until we've completed recovering messages, we temporarily use automatic copies of a message segment
	     header and a message block to perform these computations. */

	mseg_ptr = addr (local_mseg_segment_header);
	mseg_segment.block_size = probable_block_size;

	mb_ptr = addr (local_message_block);
	message_block_header.data_lth = 0;

	max_bits_in_first_block = length (first_message_block.pad);
	max_bits_in_other_blocks = length (other_message_block.pad);

	mseg_ptr = mseg_operation.mseg_ptr;


/* Begin the actual reconstruction of the segment */

RECONSTRUCT_THE_SEGMENT:
	begin;

dcl	1 new_block_map	aligned,
	  2 map		bit (n_blocks_available) unaligned;

dcl	1 nonzero_block_map aligned,
	  2 map		bit (n_blocks_available) unaligned;

dcl	1 message_id_ptrs	aligned,
	  2 n_ptrs	fixed binary (18),
	  2 ptrs		(n_blocks_available) pointer unaligned;

dcl	1 sorted_message_indeces
			aligned,
	  2 n_indeces	fixed binary (18),
	  2 indeces	(n_blocks_available) fixed binary (18);

dcl	message_offsets	(n_blocks_available) fixed binary (18) unsigned;
dcl	message_ids	(n_blocks_available) bit (72) aligned;
dcl	block_offsets	(max_blocks_per_message) fixed binary (18) unsigned;

	     new_block_map.map = copy ("1"b, n_header_blocks);
	     nonzero_block_map.map = copy ("1"b, n_header_blocks);

	     n_blocks_recovered, last_recovered_block = n_header_blocks;


	     /*** Examine the message blocks -- We check each message block individually to see if it might be the first
		block of a message.  If it passes the preliminary test, we assume it is the beginning of a message and
		we then carefully check the entire possible message for validity.  If it passes all of our checks, we
		record it as a recovered message and mark all of its blocks allocated. */

	     n_possible_messages, n_messages_recovered = 0;

	     do block_id = (n_header_blocks + 1) to last_used_block;

		substr (nonzero_block_map.map, block_id, 1) = (mseg_segment_blocks (block_id) ^= ""b);

		if possible_message (block_id)
		then do;

			n_possible_messages = n_possible_messages + 1;

			if valid_message (block_id)
			then do;

				n_messages_recovered = n_messages_recovered + 1;

				message_offsets (n_messages_recovered) = block_offsets (1);
				message_ids (n_messages_recovered) = message_descriptor.ms_id;

				do message_block_idx = 1 to n_message_blocks;
				     message_block_id =
					divide (block_offsets (message_block_idx), probable_block_size, 18, 0)
					+ 1;
				     substr (new_block_map.map, message_block_id, 1) = "1"b;
				     n_blocks_recovered = n_blocks_recovered + 1;
				     last_recovered_block = max (last_recovered_block, message_block_id);
				end;
			     end;
		     end;
	     end;


	     /*** Zero the unused blocks -- We can easily zero those unused blocks beyond the last block recovered by
		truncation.  The intervening unused blocks, however, must be zeroed individually. */

	     call hcs_$truncate_seg (mseg_ptr, (last_recovered_block * probable_block_size), (0));

	     last_block_checked = n_header_blocks;	/* nothing in the header/block map is unused */

	     do while (last_block_checked < last_recovered_block);

		begin;
dcl	rest_of_block_map	bit (last_recovered_block - last_block_checked) unaligned
			defined (new_block_map.map) position (last_block_checked + 1);
		     next_unused_block = index (rest_of_block_map, "0"b);
		end;

		if next_unused_block = 0
		then last_block_checked = last_recovered_block;

		else do;
			last_block_checked = last_block_checked + next_unused_block;
			begin;
dcl	nonzero_indicator	bit (1) unaligned defined (nonzero_block_map.map) position (last_block_checked);
dcl	the_block		bit (36 * probable_block_size) aligned defined (mseg_segment_blocks (last_block_checked));
			     if nonzero_indicator
			     then the_block = ""b;
			end;
		     end;
	     end;


	     /*** Reconstruct the message chains -- Sort the recovered messages by their IDs before building the chains
		to insure that reading forward/backward will work properly. */

	     message_id_ptrs.n_ptrs, sorted_message_indeces.n_indeces = n_messages_recovered;

	     do message_index = 1 to n_messages_recovered;
		message_id_ptrs.ptrs (message_index) = addr (message_ids (message_index));
		sorted_message_indeces.indeces (message_index) = message_index;
	     end;

	     call sort_items_indirect_$bit (addr (message_id_ptrs), addr (sorted_message_indeces),
		length (message_ids (1)));

	     unspec (mseg_segment.message_chain) = ""b;
	     unspec (mseg_segment.hash_table) = ""b;

	     prev_md_ptr = null ();

	     do message_index = 1 to n_messages_recovered;

		mb_ptr = setwordno (mseg_ptr, message_offsets (sorted_message_indeces.indeces (message_index)));
		md_ptr = addr (first_message_block.descriptor);

		message_descriptor.message_chain.prev_message = mseg_segment.message_chain.last_message;
		message_descriptor.message_chain.next_message = 0;

		if mseg_segment.message_chain.first_message = 0
		then mseg_segment.message_chain.first_message = wordno (mb_ptr);
		else prev_md_ptr -> message_descriptor.message_chain.next_message = wordno (mb_ptr);

		mseg_segment.message_chain.last_message = wordno (mb_ptr);

		hash_idx = fixed (substr (message_descriptor.ms_id, 64, 9), 9, 0);
		message_descriptor.prev_message_in_hash_chain = mseg_segment.hash_table.last_message (hash_idx);
		mseg_segment.hash_table.last_message (hash_idx) = wordno (mb_ptr);

		prev_md_ptr = md_ptr;
	     end;


	     /*** Reconstruct the wakeup state */

	     if mseg_segment.wakeup_state_set		/* segment claims to have a wakeup state */
	     then if mseg_segment.wakeup_state.version = MSEG_WAKEUP_STATE_VERSION_1
		then				/* ... which appears to be the new style */
		     local_wakeup_state = mseg_segment.wakeup_state.state;

		else do;				/* ... which appears to be the old style */
			unspec (old_wakeup_state) = unspec (header_msg);
			local_wakeup_state.version = MSEG_WAKEUP_STATE_VERSION_1;
			string (local_wakeup_state.flags) = string (old_wakeup_state.switches);
			local_wakeup_state.event_channel = old_wakeup_state.event_channel;
			local_wakeup_state.access_class = header_msg_access_class;
			local_wakeup_state.process_id = old_wakeup_state.process_id;
			local_wakeup_state.lock_id = old_wakeup_state.lock_id;
		     end;

	     else local_wakeup_state.version = "";	/* no wakeup state is present */

	     if local_wakeup_state.version ^= MSEG_WAKEUP_STATE_VERSION_1
	     then do;
RESET_SEGMENT_WAKEUP_STATE:
		     mseg_segment.wakeup_state_set = "0"b;
		     unspec (mseg_segment.wakeup_state) = ""b;
		end;

	     else if (local_wakeup_state.process_id = ""b) | (local_wakeup_state.lock_id = ""b)
	     then go to RESET_SEGMENT_WAKEUP_STATE;

	     else if ^aim_check_$in_range (local_wakeup_state.access_class, mseg_segment_aim_range)
	     then go to RESET_SEGMENT_WAKEUP_STATE;

	     else do;				/* wakeup state looks OK: put it back into the segment */
		     mseg_segment.wakeup_state_set = "1"b;
		     mseg_segment.wakeup_state.state = local_wakeup_state;
		     mseg_segment.header.wakeup_state.pad = ""b;
		end;


/* Complete reconstruction of the header and block map and then return to our caller */

	     p_n_possible_messages = max (n_possible_messages, mseg_segment.n_messages);
	     p_n_messages_recovered = n_messages_recovered;

	     mseg_segment.n_messages = n_messages_recovered;

	     mseg_segment.block_size = probable_block_size;
	     mseg_segment.n_blocks_allocated = n_blocks_available;
	     mseg_segment.n_blocks_unused = n_blocks_available - n_blocks_recovered;

	     mseg_segment.block_map.map = new_block_map.map;

	     mseg_segment.modification_in_progress, mseg_segment.salvage_in_progress = "0"b;
	     mseg_segment.salvaged = "1"b;

	     mseg_segment.sentinel = MSEG_SEGMENT_SENTINEL;
	     mseg_segment.header.version = MSEG_SEGMENT_VERSION_5;

	     mseg_segment.date_time_last_salvaged = clock ();

	     return;
%page;
/* Determine if the specified block might be the first block of a message */

possible_message:
     procedure (p_block_id) returns (bit (1) aligned);

dcl	p_block_id	fixed binary (18) parameter;

	if substr (new_block_map.map, p_block_id, 1) = "1"b
	then call not_a_message ();			/* this block is already used by another message */

	mb_ptr = setwordno (mseg_ptr, (p_block_id - 1) * probable_block_size);

	if ^first_message_block.descriptor_present	/* there's no descriptor in this block */
	then call not_a_message ();

	md_ptr = addr (first_message_block.descriptor);

	if message_descriptor.sentinel ^= MESSAGE_DESCRIPTOR_SENTINEL
	then call not_a_message ();			/* the descriptor isn't properly formatted */

	if message_descriptor.ms_id = ""b		/* the "message" doesn't have a valid message ID */
	then call not_a_message ();

	do message_index = 1 to n_messages_recovered;
	     if message_ids (message_index) = message_descriptor.ms_id
	     then call not_a_message ();		/* the "message" has a duplicate message ID */
	end;

	if (message_descriptor.ms_len < 0) | (message_descriptor.ms_len > (36 * mseg_data_$max_message_size))
	then call not_a_message ();			/* the "message" is too small or too large to be real */

	if ^aim_check_$in_range (message_descriptor.ms_access_class, mseg_segment_aim_range)
	then call not_a_message ();			/* message with this access class can't be in this segment */

	if ^aim_check_$greater_or_equal (message_descriptor.ms_access_class, message_descriptor.sender_authorization)
	then if (aim_util_$get_privileges (message_descriptor.sender_authorization) & sys_info$ring1_privilege) = ""b
	     then call not_a_message ();		/* sender couldn't add it without privileges he didn't have */

	/*** Control arrives here only if this block contains a plausible message */

	return ("1"b);


/* Control arrives here if the block does not contain a plausible message */

not_a_message:
     procedure ();

	go to RETURN_NOT_A_MESSAGE;

     end not_a_message;

RETURN_NOT_A_MESSAGE:
	return ("0"b);

     end possible_message;
%page;
/* Validate that a probable message is, in fact, a real message -- We must check all the blocks which are claimed to be
   part of this message for validity.  We don't have to check the message descriptor itself, however, as that has already
   been done for us by the possible_message internal procedure and, in fact, md_ptr still locates the descriptor. */

valid_message:
     procedure (p_block_id) returns (bit (1) aligned);

dcl	p_block_id	fixed binary (18) parameter;

dcl	first_block	bit (1) aligned;
dcl	actual_ms_len	fixed binary (24);
dcl	block_offset	fixed binary (18) unsigned;

	block_offset = (p_block_id - 1) * probable_block_size;

	first_block = "1"b;				/* this is the first block */
	n_message_blocks = 0;			/* nothing valid yet */
	actual_ms_len = 0;

	do while (block_offset ^= 0);

	     if mod (block_offset, probable_block_size) ^= 0
	     then call not_a_message ();		/* it's not a valid block offset */

	     message_block_id = divide (block_offset, probable_block_size, 18, 0) + 1;

	     if (message_block_id <= n_header_blocks) | (message_block_id > n_blocks_available)
	     then call not_a_message ();		/* this block is not within the segment */

	     if substr (new_block_map.map, message_block_id, 1) = "1"b
	     then call not_a_message ();		/* this block is already in use in another message */

	     do message_block_idx = 1 to n_message_blocks;
		if block_offsets (message_block_idx) = block_offset
		then call not_a_message ();		/* this block is already in this message */
	     end;

	     if n_message_blocks = max_blocks_per_message
	     then call not_a_message ();		/* this "message" has too many blocks */

	     n_message_blocks = n_message_blocks + 1;
	     block_offsets (n_message_blocks) = block_offset;

	     mb_ptr = setwordno (mseg_ptr, block_offset);

	     if message_block_header.data_lth < 0	/* a block can't have a negative length! */
	     then call not_a_message ();

	     if first_block
	     then do;				/* the first block -- just check its length */
		     if message_block_header.data_lth > max_bits_in_first_block
		     then call not_a_message ();	/* too many bits to fit in the block */
		     if message_block_header.next_block ^= 0
		     then if message_block_header.data_lth ^= max_bits_in_first_block
			then call not_a_message ();	/* there's more to come but this block's not full */
		end;

	     else do;				/* all other blocks ... */
		     if message_block_header.descriptor_present
		     then call not_a_message ();	/* a descriptor when there shouldn't be one */
		     if message_block_header.data_lth > max_bits_in_other_blocks
		     then call not_a_message ();	/* too many bits to fit in the block */
		     if message_block_header.next_block ^= 0
		     then if message_block_header.data_lth ^= max_bits_in_other_blocks
			then call not_a_message ();	/* there's more to come but this block's not full */
		end;

	     actual_ms_len = actual_ms_len + message_block_header.data_lth;
	     if actual_ms_len > message_descriptor.ms_len
	     then call not_a_message ();		/* we've found more bits than supposedly are in the message */

	     block_offset = message_block_header.next_block;
	     first_block = "0"b;
	end;

	if actual_ms_len < message_descriptor.ms_len
	then call not_a_message ();			/* the message isn't as long as it should be */

	/*** Control arrives here only if the message is valid */

	return ("1"b);


/* Control arrives here if the message is not valid */

not_a_message:
     procedure ();

	go to RETURN_NOT_A_MESSAGE;

     end not_a_message;

RETURN_NOT_A_MESSAGE:
	return ("0"b);

     end valid_message;

	end RECONSTRUCT_THE_SEGMENT;

/* format: off */
%page; %include mseg_message;
/* format: on */

     end salvage_seg;

/* format: off */
%page; %include mseg_data_;
%page; %include mseg_segment;
%page; %include mseg_wakeup_state;
%page; %include mseg_operation;
%page; %include mseg_operation_data;
%page; %include mseg_operations_;
%page; %include mseg_message_info;
%page; %include entry_access_info;
%page; %include mseg_format_errors_;
%page; %include sub_err_flags;
%page; %include syserr_constants;
%page; %include condition_info;
%skip; %include mc;
%page; %include status_structures;
%page;

/* BEGIN MESSAGE DOCUMENTATION


   Message:
   mseg_$OPERATION: Beginning salvage of PATH for USER_ID.  REASON

   S:	$log

   T:	$run

   M:	The message segment primitives operation OPERATION detected an
	internal inconsistency in the message segment or mailbox PATH and
	has requested that the segment be salvaged.  REASON provides an
	explanation of why the operation invoked the salvager.

   A:	$ignore


   Message:
   mseg_$OPERATION: Completed salvage of PATH for USER_ID.
	N {out of M possible} messages recovered.

   S:	$log

   T:	$run

   M:	The salvage of the message segment or mailbox PATH requested by the
	message segment primitives operation OPERATION has been completed.
	Of the M messages which might have been in the segment, only N could
	be recovered; the others have been deleted.  If all possible
	messages were recovered, the "out of M possible" phrase is omitted
	from the message.

   A:	$inform_sa
	The administrator may wish to notify the owner of the segment that
	some of his messages have been lost.


   Message:
   mseg_$OPERATION: Unable to salvage PTR (pathname unknown) for USER_ID.
	Call to hcs_$get_access_info_seg failed.  REASON

   S:	$log

   T:	$run

   M:	$err
	OPERATION identifies the message segment primitives operation which
	provoked the attempted salvage.  PTR is USER_ID's pointer to the
	message segment or mailbox which could not be salvaged.  REASON
	provides additional information about the failure of the call to
	hcs_$get_access_info_seg.

   A:	$inform


   Message:
   mseg_$OPERATION: Unable to salvage PATH for USER_ID.  Rebuilding the
	contents of the message segment -- Record quota overflow.

   S:	$log

   T:	$run

   M:	The salvage of the message segment or mailbox PATH requested by the
	message segment primitives operation OPERATION failed due to a lack
	of quota.  The segment in question will remain inaccessible until
	the salvage can be successfully completed.

   A:	$inform_sa
	In order to make the message segment or mailbox accessible again,
	the administrator must increase the quota available to the segment
	to any value greater than the current length of the segment.  The
	administrator should then attempt to use the segment to allow the
	salvager to be run to completion.


   Message:
   mseg_$OPERATION: Unable to salvage PATH for USER_ID.  REASON

   S:	$log

   T:	$run

   M:	$err
	OPERATION identifies the message segment primitives operation which
	provoked the attempted salvage.  PATH is the pathname of the message
	segment or mailbox which could not be salvaged.  REASON provides
	additional information about the failure of the attempted salvage.

   A:	$inform


   Message:
   mseg_$OPERATION: Upgraded PATH from version N to version 5 for USER_ID.
	M messages were deleted.

   S:	$log

   T:	$run

   M:	The format of the message segment or mailbox PATH was upgraded from
	the old format known as "version N" to the latest format.  However,
	M messages in the segment could not be upgraded to the current
	format because there was no room for them in the segment.  As a
	consequence, these messages were deleted.  OPERATION identifies the
	message segment primitives operation which required that the segment
	be upgraded.

   A:	$inform_sa
	The administrator may wish to notify the owner of the segment that
	some of his messages have been lost.


   Message:
   mseg_$OPERATION: Unable to upgrade PTR (pathname unknown) from version N
	to version 5 for USER_ID.  Call to hcs_$get_access_info_seg failed.
	REASON

   S:	$log

   T:	$run

   M:	$err
	OPERATION identifies the message segment primitives operation which
	required that the segment be upgraded.  PTR is USER_ID's pointer to
	the message segment or mailbox which could not be upgraded.  REASON
	provides additional information about the failure of the call to
	hcs_$get_access_info_seg.

   A:	$inform


   Message:
   mseg_$OPERATION: Unable to upgrade PATH from version N to version 5 for
	USER_ID.  REASON

   S:	$log

   T:	$run

   M:	$err
	OPERATION identifies the message segment primitives operation which
	required that the segment be upgraded.  PATH is the pathname of the
	message segment or mailbox which could not be upgraded.  REASON
	provides additional information about the failure of the attempted
	upgrade.

   A:	$inform


   END MESSAGE DOCUMENTATION */

/* format: on */

     end mseg_utils_;
