/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(86-09-30,Oke), approve(86-09-30,MCR7543), audit(86-09-30,JRGray),
     install(86-10-08,MR12.0-1180):
     Allow ALM to support double word constants.
  2) change(86-10-01,JRGray), approve(86-10-01,MCR7507),
     audit(86-10-27,RWaters), install(86-11-12,MR12.0-1202):
     Modified to support severity, *heap references, and the "init_link"
     pseudo.
  3) change(86-11-14,JRGray), approve(86-11-14,MCR7568),
     audit(86-11-21,RWaters), install(86-11-26,MR12.0-1228):
     Also MCR7572. Modified to add support for the three new pseudo-ops:
     ext_extry, oct_unal, and dec_unal.
  4) change(88-08-02,JRGray), approve(88-08-05,MCR7952),
     audit(88-09-30,WAAnderson), install(88-10-17,MR12.2-1169):
     Modified to support new Symbol Table Pseudo-Ops.
                                                   END HISTORY COMMENTS */


pass2_: 
     procedure( decor,target_value,no_target_given,first_time_thru );  /* decor is passed in from alm_6180_, set in pass1_ ; 
                                                                          target_value and no_target_given come from alm
							    via alm_6180_; first_time_thru comes from alm_6180_ */


/*  pass2 second pass of the Multics assembler for the GE - 645 and Honeywell 6180.  */


/*  pass2 is primarily concerned with generating binary output.
   pass2 processes all operations and pseudo-operations for
   the binary  (text) output that they produce. All such output
   is generated and put out in the output file along with an
   assembly listing. Some pseudo-operations are only concerned
   the generating information about the linkage and are
   treated accordingly. The post - processor will handle the
   external reference information and put out the linkage and symbol
   segments and the linkage part of the text segment.

	Modified to support *heap links by R Gray and W Anderson on 2/05/86.
	Modified for changes requested by MTR 175 on 3/25/81 by EBush
	Modified to implement -target on 2/5/81 by EBush
	Modified for decor pseudo-op on 12/30/80 by E Bush
	Modified for "vfd" pseudo-op on 12/15/75 by Eugene E Wiatrowski
          Modified for prelinking on 06/15/75 by Eugene E Wiatrowski
	Modified on 08/07/73 at 23:58:43 by R F Mabee.
	by RFM in June 1973 to add EIS instructions, etc.
	by RFM on 2 May 1972 adding getlp, short_call, and include pseudo-ops.
	by RFM on 24 March 1972 for new object segment format.
	by RFM on 5 March 1972 to add new call/save/return operators.
	by RHG on 4 June 1971 to fix "rem" pseudo-op
	by RHG 0n 3 June 1971 to fix clearing of flags (upkflg does orsa not sta)
	by RHG on 2 June 1971 to produce "N" flag for "file" pseudo-op
	by RHG on 25 May 1971 to clear flags in rem pseudo-op
	by RHG on 2 May 1971 to fix bug in last_p2pcl initialization
	by RHG on 2 April 1971 to have "eight,sixtyfour,mod" all produce nop's rather than 0's
			   to allow bss ,x where no label is specified before the ,
			   to cause r error when save is given a relocatable arg
			   to clean up the processing of the rem pseudo-op
   R H Campbell, 29 October 1970, for inhibit bit in ITS/ITB pseudo-ops.
   by RHG on 17 Sept 1970 for new listing package
   by RHG on 6 August 1970 at 2321 to not set sthedr from name pseudo-op
   by NA on June 28, 1970 at 2123 for the new CODTAB.
	  */					/*  INCLUDE FILES  */



% include varcom;

% include concom;

% include erflgs;

% include codtab;

% include alm_prototypes;

% include relbit;

% include labarg;

% include alm_lc;

% include sthedr;

% include alm_options;

% include alm_data;

	/*  END OF THE INCLUDE FILES  */		/*    */

/*  PARAMETERS */

dcl       decor fixed bin(35); /* passed from  alm_6180_, set in pass1_ */
dcl	target_value  fixed bin(17);
dcl	(no_target_given,first_time_thru) bit(1);


/* CONDITIONS */

dcl	cleanup condition;


/*  BASED STORAGE DECLARATIONS  */

 dcl	long_int_based fixed bin(71) based unaligned;

 dcl	1 word based aligned,
	  2 (left, right) bit (18) unaligned;

 dcl	1 glpl_words (0:262143) based (eb_data_$lavptr) aligned,
	  2 left bit (18) unaligned,
	  2 right bit (18) unaligned;

 dcl	1 acc_string based ( addr (sym (1))) aligned,
	  2 length fixed bin (9) unsigned unaligned,
	  2 chars char (acc_string.length) unaligned;

 dcl	1 opcode_overlay based aligned,
	  2 filler bit (18) unaligned,
	  2 opcode bit (10) unaligned,
	  2 flags bit (4) unaligned,		/*  Any value pass2_ might need.  */
	  2 iclass bit (4) unaligned;		/*  Intersection of decors in which it is valid */

 dcl      1 descop_overlay based aligned,
            2 filler bit(24) unaligned,
	  2 format bit(4)  unaligned,
	  2 flags  bit(4)  unaligned,
	  2 decor  bit(4)  unaligned;

/*  EXTERNAL ENTRIES USED BY PASS2  */

dcl  alm_symtab_$block entry(char(*)),
     alm_symtab_$cleanup entry,
     alm_symtab_$end_block entry,
     alm_symtab_$end_enum entry,
     alm_symtab_$end_source entry,
     alm_symtab_$end_structure entry,
     alm_symtab_$end_union entry,
     alm_symtab_$enum entry(char(*)),
     alm_symtab_$initialize entry,
     alm_symtab_$source entry(char(*), bit(36) aligned, fixed bin(71)),
     alm_symtab_$statement entry(fixed bin(26), fixed bin(26), fixed bin(26), fixed bin(26), fixed bin(26)),
     alm_symtab_$structure entry(char(*)),
     alm_symtab_$symbol entry(char(*), char(*), fixed bin(26), fixed bin(26), fixed bin(26), fixed bin(26), fixed bin(26), fixed bin(26)),
     alm_symtab_$union entry(char(*)),
     getid_$getid_ ext entry,
     getid_$getnam ext entry,
     getid_$setid ext entry (fixed bin (26)),
     getbit_$getbit_ ext entry (fixed bin (26), fixed bin (26), fixed bin (26), fixed bin (26)),
     inputs_$next ext entry,
     inputs_$nxtnb ext entry,
     inputs_$next_statement ext entry,
     inputs_$next_statement_nolist ext entry,
     litevl_$itbevl ext entry (fixed bin (26), fixed bin (26)),
     utils_$upkflg ext entry (fixed bin),
     utils_$abort ext entry,
     litevl_$itsevl ext entry (fixed bin (26), fixed bin (26)),
     litevl_$litasn ext entry (fixed bin (26), fixed bin (26), fixed bin (26), fixed bin (26)),
     prwrd_$source_only ext entry,
     prnter_$prnter_ ext entry (char (*)),
     putout_$putwrd ext entry (fixed bin (26), fixed bin (26), fixed bin (26), fixed bin (26)),
     prwrd_$prwrd_ ext entry (fixed bin (26), fixed bin (26), fixed bin (26)),
     putout_$putlst ext entry (fixed bin (26), fixed bin (26), fixed bin (26),
     fixed bin (26), fixed bin (26)),
     glpl_$slwrd ext entry (fixed bin (26), fixed bin (26), fixed bin (26)),
     glpl_$storl ext entry (fixed bin (26), fixed bin (26)),
     glpl_$storr ext entry (fixed bin (26), fixed bin (26));
 dcl	alm_include_file_$pass2 ext entry,
	alm_include_file_$insert ext entry (ptr, fixed bin (26), fixed bin (26)),
	alm_include_file_$pop ext entry,
	expand_pathname_$component entry(char(*), char(*), char(*), char(*), fixed bin(35)),
	initiate_file_$component entry(char(*), char(*), char(*), bit(*), ptr, fixed bin(24), fixed bin(35)),
	inputs_$get_ptr entry (ptr, fixed bin (26), fixed bin (26), bit (1) aligned),
	mexp_	 ext entry (char (*), fixed bin (17), fixed bin(17), bit(1), bit(1)),
	mexp_$define_macro ext entry (char (*)),
	oplook_$reset ext entry,
	oplook_$redefine  entry,
	system_type_   entry (char(*), char(*), fixed bin, fixed bin(35)),
	terminate_file_ entry(ptr, fixed bin(24), bit(*), fixed bin(35)),
	translator_info_$component_get_source_info entry(ptr, char(*), char(*), char(*), fixed bin(71), bit(36) aligned, fixed bin(35));

/*  EXTERNAL FUNCTIONS CALLED BY PASS2  */

dcl (ascevl_$accevl ext entry (fixed bin (26)),
     ascevl_$acievl ext entry (fixed bin (26)),
     ascevl_$ac4evl ext entry (fixed bin (26)),
     ascevl_$bcdevl ext entry (fixed bin (26)),
     expevl_$expevl_ ext entry (fixed bin (26), fixed bin (26), fixed bin (26)),
     lstman_$blkasn ext entry (fixed bin (26), fixed bin (26), fixed bin (26), fixed bin (26)),
     glpl_$cwrd ext entry (fixed bin (26)),
     glpl_$glwrd ext entry (fixed bin (26), fixed bin (26)),
     decevl_$decevl_ ext entry (fixed bin (26), fixed bin (26)),
     lstman_$eptasn ext entry (fixed bin (26), fixed bin (26), fixed bin (26), fixed bin (26),
     fixed bin (26), fixed bin (26)),
     utils_$exadrs ext entry (fixed bin (26), fixed bin (26)),
     lstman_$lnkasn ext entry (fixed bin (26), fixed bin (26), fixed bin (26), fixed bin (26)),
     lstman_$outasn ext entry (fixed bin (26), fixed bin (26), fixed bin (26)),
     lstman_$calser ext entry (fixed bin (26), fixed bin (26)),
     lstman_$sdfasn ext entry (fixed bin (26), fixed bin (26), fixed bin (26),
     fixed bin (26), fixed bin (26)),
     lstman_$namasn ext entry (fixed bin (26)),
     utils_$rs ext entry (fixed bin (26), fixed bin (26)),
     utils_$and ext entry (fixed bin (26), fixed bin (26)),
     utils_$makins ext entry (fixed bin (26), fixed bin (26), fixed bin (26),
     fixed bin (26), fixed bin (26)),
     octevl_$octevl_ ext entry (fixed bin (26)),
     oplook_$oplook_ ext entry (fixed bin, fixed bin (26)),
     table_$table_ ext entry (fixed bin (26), fixed bin (26), fixed bin (26), fixed bin (26),
     fixed bin (26)),
     lstman_$trpasn ext entry (fixed bin (26), fixed bin (26)),
     varevl_$varevl_ ext entry (fixed bin (26), fixed bin (26), fixed bin (26), fixed bin (26),
     fixed bin (26), fixed bin (26)),
     vfdevl_$vfdevl_ ext entry (fixed bin (26), fixed bin (26)),
     vfdevl_$vfdcnt ext entry (fixed bin (26), fixed bin (26))
     ) returns (fixed bin (26));
 dcl	alm_eis_parse_$descriptor ext entry (fixed bin (26), fixed bin (26), fixed bin (26), fixed bin (26)) returns (fixed bin  (26)),
	alm_eis_parse_$instruction ext entry (fixed bin (26), fixed bin (26), fixed bin (26)) returns (fixed bin  (26));

/*  AUTOMATIC VARIABLES  */

dcl (rleft, rright, rslts (128), binop, flags, basno, value, b29, admod, class, instruction_class,
     type, xnlnk, ptrarg, ptrcal, trplnk, blklnk, symlnk, zleft, zright, rrslts (128), option,
     argout, traout, tderr, tbss, tlc, i, iaddr, ik, iloc, irtblk, itemp, itype, j, junk,
     k, lcl, lcloc, lcr, link, lnkorg, lpaswd, n, name, nobits, nowrds, last_p2pcl) fixed bin (26);

 dcl	link_not_found bit(1);
 dcl	termination_conditions bit (7);
 dcl	full_word_temp fixed bin (26);
 dcl	stkclst fixed bin(26);	/* used to remember calculated stackframe sizes */
 dcl	dup_ptr ptr init (null ()),
	temp_ptr ptr,
	dup_count fixed bin (26),
	dup_start fixed bin (26),
	dup_string (0:262143) char (1) unal based (dup_ptr),
	tmacl bit (2) aligned,
	operand char(32) varying,
	canonical_operand char(24),
	code	fixed bin(35),
	unique_id	bit(36) aligned,
	dtcm fixed bin(71),
	(path, var_name, var_type) char(256) varying,
	(st_offset, st_length, st_line, st_num) fixed bin(26);

dcl  trprtn label local;

dcl	label_flag bit (1) aligned;
dcl	end_statement_flag bit (1) aligned;

/*  EXTERNAL STATIC VARIABLES IN THE ASSEMBLER'S DATA SEGMENT  */

dcl (eb_data_$unwind (3), eb_data_$atext (2), eb_data_$alink (2), eb_data_$asym (2), eb_data_$astat (2), eb_data_$asys (2),
     eb_data_$aheap (2),
     eb_data_$mstaq, eb_data_$ion, eb_data_$ioff, eb_data_$mx7, eb_data_$ib6,
     eb_data_$isave, eb_data_$irestore, eb_data_$iobject,
     eb_data_$nmxsav, eb_data_$tsym, eb_data_$anl) ext fixed bin (26),
     eb_data_$rpt_terminators (7) external fixed bin (35);		/*  Contain three-letter ACC names.  */
 dcl	eb_data_$lavptr external pointer;
dcl	eb_data_$entry_bound ext fixed bin(26);
dcl	eb_data_$macro_depth ext fixed bin (26),
	eb_data_$macro_listing_control bit (36) aligned ext;

	/* fixed bin sym code for 'function' */
dcl	(ifun1 init(1100540526), ifun2 init(13318017647), ifun3 init(14763950080))
	     int static options(constant) fixed bin(35);




/*  entry to subroutine, set up variables before main loop.  */

label_100: 
	pc = 0;








/*  clear buffer for relocation bits  */

label_110: 

	rrslts (*) = 0;	/*initialize*/
	curlc = lptext;
	tvorg = fixed (glpl_words (lptv + 3).left, 18);
	lnkorg = fixed (glpl_words (lpsect + 3).left, 18);
	call glpl_$storr (lplit + 1, litc);
on	cleanup	call alm_symtab_$cleanup;
	call alm_symtab_$initialize;
	litorg = fixed (glpl_words (lplit + 3).left, 18);
	lreter = fixed (glpl_words (lpcall + 3).left, 18);

	/* retrieve remembered value of stackframe size */
	stkclst = stkc;	/* stkc is used to pass this value from pass1 */
	stkc = fixed(glpl_words(stkclst).left);
	stkclst = fixed(glpl_words(stkclst).right);

	stkc = 16 * (divide (stkc + 15, 16, 17, 0));
	p2pcl = pclst;
	binlin = 1;
	eb_data_$macro_listing_control = (36)"0"b;
	call oplook_$reset;

/*  main loop re - entry, setup flags and check symbol assignment.  */

label_200: 
	spc = pc;
	tpc = fixed (glpl_words (p2pcl).left, 18);
	tlc = fixed (glpl_words (p2pcl + 2).left, 18);
	call utils_$upkflg (glpl_$cwrd (p2pcl + 1));
	last_p2pcl = p2pcl;
	p2pcl = fixed (glpl_words (p2pcl).right, 18);
	value = 0;

	label_flag = ""b;
label_220: 
	brk (1) = isp;
	call getid_$getid_;
	if (brk (1) ^= icol) then go to label_300;
	if (eb_data_$tsym ^= 0) then if (table_$table_ (iassgn, sym (1), pc, flocrf, curlc) = 0) then prnts = 1;
	label_flag = "1"b;
	go to label_220;

/*  get operator and test for pseudo operation.  */

label_300: 
	if eb_data_$tsym ^= 0 then go to label_301;
	if brk (1) = inl then go to label_870;
	if brk (1) = iquot then go to label_870;
label_301: 
	binop = oplook_$oplook_ (prnto, itype);
	if prnto ^= 0 then do;
	     call mexp_ (addr (sym (1)) -> acc_string.chars, prnto, target_value, no_target_given,first_time_thru);
	     if prnto ^= 0 then go to label_3200;
	     else go to label_200;
	end;
	if (brk (1) = isp | brk (1) = inl) then go to label_305;

/*  there was an illegal character after the op or pseudo-op  */
	prnto = 1;
	go to label_3200;

label_305:
	instruction_class = fixed (addr (binop) -> opcode_overlay.iclass, 4);
	if ^data2.compatible(instruction_class,decor)
	    then prntb = 1;
 
	go to label_vector (itype);



/*  control group of pseudo operations.  */

/*  end pseudo-operation, scan to end of card, and return to caller.  */


label_vector (1):		/*  end  */
label_450: 

	if label_flag then call prwrd_$prwrd_(spc+fixed (glpl_words(curlc+3).left, 18),0,ibb); else call prwrd_$source_only;
	return;

/*  include statement, use new source file.  */

label_vector (50):		/*  include  */
label_include:
	call getid_$getid_ ();
	if eb_data_$tsym = 0 then goto label_3100;
	call prwrd_$source_only ();
	call inputs_$next_statement ();
	call alm_include_file_$pass2 ();
	goto label_220;

/*  use pseudo-operation, use another location counter.  */

label_vector (2):		/*  use  */
label_500: 

	call getid_$getid_;
	if (eb_data_$tsym = 0) then go to label_3100;

/*  save current value of old location counter.  */
	call glpl_$storr (curlc + 1, pc);

/*  use new lc as the current lc.  */
	if (table_$table_ (iserch, sym (1), pc, fmlcrf, curlc) ^= 0) then go to label_3010;
	call prnter_$prnter_ ("fatal error in PASS2 in symbol table search for USE lc");
	call utils_$abort;


/*  org pseudo-operation. set the value of the pc.  */

label_vector (3):		/*  org  */
label_525: 

	if (varevl_$varevl_ (invrvl, basno, value, admod, b29, iaddr) = 0) then go to label_3110;
	if (iaddr ^= 0) then go to label_3300;
	pc = value;
	go to label_3200;

/*  join pseudo-op. ignored in pass2.  */

label_vector (4):		/*  join  */
label_550: 

	go to label_3010;

/*  even pseudo-operation, force pc to even location.  */

label_vector (5):		/*  even  */
label_600: 

	if (mod (spc, 2) ^= 0) then
	call putout_$putwrd (pc, (mnopdu), i642, 0);
	go to label_3010;

/*  odd pseudo-operation, force pc to odd location.  */

label_vector (6):		/*  odd  */
label_630: 

	if (mod (spc, 2) = 0) then
	call putout_$putwrd (pc, (mnopdu), i642, 0);
	go to label_3010;

/*  eight pseudo-operation, force pc to zero mod eight.  */

label_vector (7):		/*  eight  */
label_660: 

	if (mod (pc, 8) = 0) then go to label_3010;
	call putout_$putwrd (pc, (mnopdu), i642, 0);
	go to label_660;

/*  sixtyfour pseudo-operation, force pc to zero mod 64.  */

label_vector (8):		/*  sixtyfour  */
label_680: 

	if (mod (pc, 64) = 0) then go to label_3010;
	call putout_$putwrd (pc, (mnopdu), i642, 0);
	go to label_680;

/*  movdef pseudo-operation. ignored in pass two.  */

label_vector (11):		/*  movdef  */
label_755: 
label_vector (61):		/* ppstatic */

	go to label_3300;



/* decor pseudo-operation:  just like pass1_ */

label_vector (62):             /* decor */
label_decor:

          call getid_$getid_();
	operand = addr(sym(1)) -> acc_string.chars;
	call system_type_((operand),canonical_operand,(0),code);
	if code ^=0
	   then prntf = 1;
	else do;
	          do n = 1 to hbound(data1.decor,1) while(rtrim(canonical_operand) ^= data1.decor(n).name);
	          end;
		decor = data1.decor(n).number;
	     end;

	goto label_3300;


/* error pseudo-operation, sets fatal error flag, causing "Translation failed" message. */

label_vector (63):		/* error */
label_error:
	tfatal = 3;	/* severity 3 error */
	goto label_3300;



/*  firstref pseudo-operation, first reference trap procedure specified.  */

label_vector (48):		/*  firstref  */
label_firstref:
	if tfirstreftrap ^= 1 then prntp = 1;
	if varevl_$varevl_ (ixvrvl, basno, value, admod, b29, iaddr) = 0 then goto label_3120;
	if b29 = 0 then value = lstman_$lnkasn (myblk, value, admod, iaddr);
	if first_ref_trap_proc_linkno ^= value then prntu = 1;
	first_ref_trap_proc_linkno = first_ref_trap_proc_linkno + fixed (glpl_words (lpsect + 3).left, 18);
	if brk (1) = ilpar then do;
		if varevl_$varevl_ (ixvrvl, basno, value, admod, b29, iaddr) = 0 then goto label_3120;
		if b29 = 0 then value = lstman_$lnkasn (myblk, value, admod, iaddr);
		if first_ref_trap_arg_linkno ^= value then prntu = 1;
		first_ref_trap_arg_linkno = first_ref_trap_arg_linkno + fixed (glpl_words (lpsect + 3).left, 18);
		end;
	else if first_ref_trap_arg_linkno ^= 0 then prntu = 1;
	goto label_3300;

/*  inhibit pseudo-operation, set inhibit mode on or off.  */

label_vector (12):		/*  inhibit  */
label_760: 

	call getid_$getid_;
	if (eb_data_$tsym = 0) then go to label_765;
	if (sym (1) = eb_data_$ion) then go to label_770;
	if (sym (1) = eb_data_$ioff) then go to label_775;
	prntf = 1;
	go to label_3300;


label_765: 

	if tinhib = 1 then
	tinhib = 0;
	else tinhib = 1;
	go to label_3300;


label_770: 

	tinhib = 1;
	go to label_3300;


label_775: 

	tinhib = 0;
	go to label_3300;

/*  name pseudo-operation, ignored in pass2.  */

label_vector (14):		/*  name  */
label_820: 

	goto label_3300;

/*  null pseudo-operation, print location only.  */

label_vector (15):		/*  null  */
label_850: 

	go to label_3300;

/*  rem pseudo-operation, print no octal listing.  */

label_vector (16):		/*  rem  */
label_870: 

	if label_flag then goto label_850;
	do i = 1 to 36;	/*  clear all the flags  */
	     flgvec(i) = 0;
	end;
	p2pcl = last_p2pcl;
	go to label_3040;


/*  symbol defining pseudo-operations.  */

/*  basref pseudo-operation, check definitions of pass1.  */

label_vector (17):		/*  basref  */
label_900: 

	call getid_$getid_;
	if (eb_data_$tsym = 0) then go to label_910;
	if (table_$table_ (iserch, sym (1), value, clbas, junk) ^= 0) then go to label_915;

label_905: 

	do i = 1 to 8;
	     if (sym (1) ^= symbas (i)) then
	     go to label_905a;
	     value = i - 1;
	     go to label_915;

label_905a:    

	end label_905;
	if (table_$table_ (iserch, sym (1), basno, clint, junk) ^= 0) then go to label_915;
	go to label_3130;


label_910: 

	if (varevl_$varevl_ (invrvp, basno, value, admod, b29, iaddr) = 0) then go to label_3120;
	if (iaddr ^= 0) then go to label_3300;


label_915: 

	link = utils_$exadrs (value, 0);
	type = 2;
	class = fbasrf;

/*  re - entry from segref pseudo-operation.  */

label_920: 

	call getid_$getid_;
	xnlnk = lstman_$namasn (sym (1));

label_930: 

	trprtn = label_970;
	tderr = 0;
	trplnk = 0;

label_933: 

	if (brk (1) ^= ilpar) then go to label_970;
	ptrcal = 0;
	ptrarg = 0;
	if (varevl_$varevl_ (ixvrvl, basno, ptrcal, admod, b29, iaddr) ^= 0) then go to label_935;
	tderr = 1;
	go to label_945;

label_935: 

	if (b29 ^= 0) then go to label_945;
	if tprot = 1 then go to label_940;
	ptrcal = lstman_$lnkasn (myblk, ptrcal, admod, iaddr);
	go to label_945;

label_940: 

	ptrcal = lstman_$eptasn (ptrcal, 0, mylnk, curlc, 0, 1);

label_945: 

	if (brk (1) ^= ilpar) then go to label_960;
	if (varevl_$varevl_ (ixvrvl, basno, ptrarg, admod, b29, iaddr) ^= 0) then go to label_950;
	tderr = 1;
	go to label_955;

label_950: 

	if (b29 = 0) then
	ptrarg = lstman_$lnkasn (myblk, ptrarg, admod, iaddr);

label_955: 

	if (brk (1) = irpar) then
	call inputs_$next;

label_960: 

	if (brk (1) = irpar) then go to label_965;
	tderr = 1;
	go to trprtn;

label_965: 

	call inputs_$next;
	if (tderr ^= 0) then go to trprtn;
	trplnk = lstman_$trpasn (ptrcal, ptrarg);
	go to trprtn;


label_970: 

	if (tderr = 0) then go to label_975;
	prntf = 1;
	go to label_980;

label_975: 

	if (table_$table_ (iassgn, fixed (glpl_words (xnlnk).left, 18), lstman_$blkasn (type, link, xnlnk, trplnk), class,
	junk) = 0) then
	prnts = 1;

label_980: 

	if (brk (1) = icomma) then go to label_920;
	go to label_3300;

/*  bool pseudo-operation, check boolean symbol assignment.  */

label_vector (18):		/*  bool  */
label_1000: 

	call getid_$setid (symlnk);
	if (brk (1) ^= icomma | symlnk = 0) then go to label_3100;
	if (varevl_$varevl_ (ibvrvl, basno, value, admod, b29, iaddr) = 0) then go to label_3120;
	if (iaddr ^= 0) then go to label_3300;
	if (table_$table_ (iassgn, symlnk, value, fbolrf, junk) = 0) then go to label_3120;
	go to label_3200;

/*  equ pseudo-operation, check arithmetic symbol assignment.  */

label_vector (19):		/*  equ  */
label_1100: 

	call getid_$setid (symlnk);
	if (brk (1) ^= icomma | symlnk = 0) then go to label_3100;
	if (varevl_$varevl_ (invrvl, basno, value, admod, b29, iaddr) = 0) then go to label_3120;
	class = fequrf;
	if (iaddr ^= 0) then
	class = flocrf;
	if (table_$table_ (iassgn, symlnk, value, class, iaddr) = 0) then go to label_3120;
	if (iaddr = 0) then go to label_3200;

/*  set value to absolute value.  */
	value = value + fixed (glpl_words (iaddr + 3).left, 18);
	go to label_3200;

/*  link pseudo-operation, check link number assignment.  */

label_vector (20):		/*  link  */
label_1200: 

	call getid_$setid (symlnk);
	if (brk (1) ^= icomma | symlnk = 0) then go to label_3100;
	if (varevl_$varevl_ (ixvrvl, basno, value, admod, b29, iaddr) = 0) then go to label_3120;
	if (b29 = 0) then
	value = lstman_$lnkasn (myblk, value, admod, iaddr);
	if (table_$table_ (iassgn, symlnk, value, flocrf, lpsect) = 0) then go to label_3120;

/*  set value to its absolute value for printing.  */
	value = value + fixed (glpl_words (lpsect + 3).left, 18);
	go to label_3200;

/*  init_link pseudo-operation, associate init info with link.  */

label_vector (65):		/*  init_link	name, extexpression  */

	call getid_$getid_;
          if (eb_data_$tsym = 0) then go to label_3100;
	if (table_$table_ (iserch, sym(1), value, flocrf, lcloc) = 0) then go to label_3130;
          if (brk(1) ^= icomma) then go to label_3100;
	itemp = value + fixed(glpl_words(lcloc+3).left,18);
	if (varevl_$varevl_ (ixvrvl, basno, value, admod, b29, iaddr) = 0) then go to label_3120;
	j = lnklst; /* search for the appropriate link */
          link_not_found = "1"b;
          i = 1;
          do while (link_not_found);
             if (fixed(glpl_words(j).left,18) = 2) then 
     	      j = fixed(glpl_words(j).right, 18);
             else do;
                if (i <= value/2) then do;
        	         j = fixed(glpl_words(j).right, 18);
                   i = i + 1;
                   end;
                else link_not_found = "0"b; 
                end;
             end;
	j = fixed(glpl_words(j+1).left, 18); /* find expression word */
	j = fixed(glpl_words(j+1).left, 18); /* find type pair */
	glpl_words(j+1).right = bit(fixed(itemp+1, 18), 18); /* set init label to loc + 1 */
          
	go to label_3200;

/*  set pseudo-operation, assign resettable equivalence.  */

label_vector (21):		/*  set  */
label_1250: 

	call getid_$setid (symlnk);
	if (brk (1) ^= icomma | symlnk = 0) then go to label_3100;
	if (varevl_$varevl_ (invrvl, basno, value, admod, b29, iaddr) = 0) then go to label_3120;
	if (iaddr ^= 0) then go to label_3300;
	if (table_$table_ (iassgn, symlnk, value, fsetrf, junk) = 0) then go to label_3120;
	go to label_3200;

/*  segref pseudo-operation, check definitions of pass1.  */

label_vector (22):		/*  segref  */
label_1300: 

	call getid_$getnam;
	if (brk (1) ^= icomma) then go to label_3100;
	class = fsegrf;
	if (sym (1) ^= eb_data_$atext (1) | sym (2) ^= eb_data_$atext (2)) then go to label_1310;
	type = 5;
	link = 0;
	go to label_920;

label_1310: 

	if (sym (1) ^= eb_data_$alink (1) | sym (2) ^= eb_data_$alink (2)) then go to label_1320;
	type = 5;
	link = 1;
	go to label_920;

label_1320: 

	if (sym (1) ^= eb_data_$asym (1) | sym (2) ^= eb_data_$asym (2)) then go to label_1330;
	type = 5;
	link = 2;
	go to label_920;

label_1330: 

	if (sym (1) ^= eb_data_$astat (1) | sym (2) ^= eb_data_$astat (2)) then go to label_1340;
	type = 5;
	link = 4;
	go to label_920;

label_1340: 

	if (sym (1) ^= eb_data_$asys (1) | sym (2) ^= eb_data_$asys (2)) then go to label_1350;
	type = 5;
	link = 5;
	go to label_920;

label_1350: 
	if (sym (1) ^= eb_data_$aheap (1) | sym (2) ^= eb_data_$aheap (2)) then go to label_1360;
	type = 5;
	link = 6;
	go to label_920;

label_1360: 

	type = 4;
	link = lstman_$namasn (sym (1));
	go to label_920;

/*  temp and tempd pseudo-operations, ignored in pass2.  */

label_vector (23):		/*  temp  */
label_1400: 


label_vector (24):		/*  tempd  */
label_1500: 

	go to label_3010;

label_vector (25):		/*  temp8  */
label_1505: 

	go to label_3010;


/*  generative class of pseudo-operations.  */

/*  acc and aci pseudo-operations, ascii code generators.  */
/*  also bci pseudo-operation to generate 6-bit character codes.  */
/*  absolute relocation bits always  */

label_vector (26):		/*  acc  */
label_1600: 
	n = ascevl_$accevl (rslts (1));
	go to label_1710;

label_vector (27):		/*  aci  */
label_1700: 
	n = ascevl_$acievl (rslts (1));
	goto label_1710;

label_vector (13):		/*  bci  */
label_bci:
	n = ascevl_$bcdevl (rslts (1));
	go to label_1710;

label_vector (59):
label_ac4:
	n = ascevl_$ac4evl (rslts (1));

label_1710: 
	do i = 1 to n;
	     rrslts (i) = 0;
	end label_1710;
	call putout_$putlst (pc, rslts (1), i3333, n, rrslts (1));
	go to label_3010;

/*  dec pseudo-operation, integer, fixed, and floating point.  */
/*  absolute relocation bits always.  */

label_vector (28):		/*  dec  */
label_1800: 

	n = decevl_$decevl_ (rslts (1), type);
	if (n >= 2 & mod (pc, 2) ^= 0) then
	call putout_$putwrd (pc, 0, i66, 0);
	rrslts (1) = 0;
	rrslts (2) = 0;
	call putout_$putlst (pc, rslts (1), i66, n, rrslts (1));
	if (brk (1) = icomma) then go to label_1800;
	go to label_3010;

/*  dec_unal pseudo-operation, integer, fixed, and floating point unaligned.  */
/*  absolute relocation bits always.  */

label_vector (66):		/*  dec_unal  */
label_1801: 

	n = decevl_$decevl_ (rslts (1), type);
	rrslts (1) = 0;
	rrslts (2) = 0;
	call putout_$putlst (pc, rslts (1), i66, n, rrslts (1));
	if (brk (1) = icomma) then go to label_1801;
	go to label_3010;

/*  oct pseudo-operation, octal number generator.  */
/*  absolute relocation bits always.  */

label_vector (29):		/*  oct  */
label_1900: 

	n = octevl_$octevl_ (rslts (1));
	if (n >= 2 & mod (pc, 2) ^= 0) then
	call putout_$putwrd (pc, 0, i66, 0);
	rrslts (1) = 0;
	rrslts (2) = 0;
	call putout_$putlst (pc, rslts (1), i66, n, rrslts (1));
	if (brk (1) = icomma) then go to label_1900;
	go to label_3010;

/* oct_unal pseudo-operation, unaligned octal number generator.  */
/*  absolute relocation bits always.  */

label_vector (67):		/* oct_unal  */
label_1901: 

	n = octevl_$octevl_ (rslts (1));
	rrslts (1) = 0;
	rrslts (2) = 0;
	call putout_$putlst (pc, rslts (1), i66, n, rrslts (1));
	if (brk (1) = icomma) then go to label_1901;
	go to label_3010;

/*  vfd pseudo-operation, variable field data generator.  */

label_vector (30):		/*  vfd  */
label_2000: 

	prnte = 0;

label_2001: 

          rrslts(*) = 0;
	n = vfdevl_$vfdevl_ (rslts (1), flags);
	if (flags = 0) then go to label_2015;

label_2010: 

	do k = 1 to n;
	     lcl = fixed (glpl_words (flags + k - 1).left, 18);
	     lcr = fixed (glpl_words (flags + k - 1).right, 18);
	     zleft = utils_$rs (rslts (k), 18);
	     zright = utils_$and (rslts (k), sixsev);
	     rleft = 0;
	     rright = 0;
	     if (lcl = 0) then
	     go to label_2003;
	     zleft = zleft + fixed (glpl_words (lcl + 3).left, 18);
	     call getbit_$getbit_ (lcl, 0, 0, rleft);

label_2003:    

	     if (lcr = 0) then
	     go to label_2005;
	     zright = zright + fixed (glpl_words (lcr + 3).left, 18);
	     call getbit_$getbit_ (lcr, 0, 0, rright);

label_2005:    

	     rslts (k) = glpl_$glwrd (zleft, zright);
	     rrslts (k) = glpl_$glwrd (rleft, rright);
	end label_2010;

label_2015: 

	call putout_$putlst (pc, rslts (1), i66, n, rrslts (1));
	go to label_3010;

/*  mod pseudo-operation. force the location counter mod expression.  */

label_vector (31):		/*  mod  */
label_2020: 

	call getid_$getid_;
	junk = expevl_$expevl_ (0, value, iaddr);
	if iaddr ^= 0 then prntr = 1;

label_2025: 

	if (mod (pc, value) = 0) then go to label_3010;
	call putout_$putwrd (pc, (mnopdu), i642, 0);
	go to label_2025;


/*  storage allocating pseudo-operations.  */

/*  bfs pseudo-operation, block followed by symbol.  */

label_vector (32):		/*  bfs  */
label_2100: 

	tbss = 0;
	go to label_2210;

/*  bss pseudo-operation, block started by symbol.  */

label_vector (33):		/*  bss  */
label_2200: 

	tbss = 1;

label_2210: 

	call getid_$setid (symlnk);
	if (brk (1) ^= icomma) then go to label_3100;
	if (varevl_$varevl_ (invrvl, basno, value, admod, b29, iaddr) = 0) then go to label_3110;
	if (iaddr = 0) then go to label_2220;
	prntr = 1;
	go to label_3120;

label_2220: 

	pc = spc + value;
	if (b29 ^= 0 ) then prntf = 1;
	value = pc;
	if (tbss = 1) then
	value = spc;
	if symlnk ^= 0 then if (table_$table_ (iassgn, symlnk, value, flocrf, curlc) = 0) then prnts = 1;
	call prwrd_$prwrd_ (value + fixed (glpl_words (curlc + 3).left, 18), 0, ibb);
	go to label_3010;

/*  zero pseudo-operation, generate double address word.  */

label_vector (34):		/*  zero  */
label_2350: 

	junk = varevl_$varevl_ (invrvl, basno, zleft, admod, b29, iaddr);
	call getbit_$getbit_ (iaddr, basno, b29, rleft);
	if (iaddr ^= 0) then
	zleft = zleft + fixed (glpl_words (iaddr + 3).left, 18);
	rright, zright = 0;
	if (brk (1) = icomma) then
	do;
	     junk = varevl_$varevl_ (invrvl, basno, zright, admod, b29, iaddr);
	     call getbit_$getbit_ (iaddr, basno, b29, rright);
	     if (iaddr ^= 0) then
	     zright = zright + fixed (glpl_words (iaddr + 3).left, 18);
	end;
	call putout_$putwrd (pc, glpl_$glwrd (zleft, zright), i66, glpl_$glwrd (rleft, rright));
	go to label_3010;

/*  itb pseudo-operation, generate link pair.  */

label_vector (35):		/*  itb  */
label_2400: 

	call litevl_$itbevl (rslts (1), rrslts (1));
	go to label_2455;

/*  its pseudo-operation, generate link pair.  */

label_vector (36):		/*  its  */
label_2450: 

	call litevl_$itsevl (rslts (1), rrslts (1));

label_2455: 

	if (mod (spc, 2) ^= 0) then
	call putout_$putwrd (pc, (mnopdu), i642, 0);
	call putout_$putlst (pc, rslts (1), i66, 2, rrslts (1)); /*  I66 format is fudge to avoid inhibit bit.  */
	go to label_3010;


/*  subroutine linkage pseudo-operations.  */

/*  call pseudo-operation, call subroutine with args and returns.  */

label_vector (37):		/*  call  */
label_2500: 

	junk = varevl_$varevl_ (ixvrvl, basno, value, admod, b29, iaddr);
	call getbit_$getbit_ (iaddr, basno, b29, rleft);

	addr (nslbit (5)) -> word.left , addr (new_nslbit (3)) -> word.left = addr (rleft) -> word.right;

	if (iaddr ^= 0) then
	value = value + fixed (glpl_words (iaddr + 3).left, 18);
	traout = utils_$makins (basno, value, mtra, b29, admod);
	new_slcall (3) = utils_$makins (basno, value, new_slcall (3), b29, admod);
	if (brk (1) = ilpar) then go to label_2510;
	call litevl_$litasn (value, dzero (1), 2, 0);
	argout = utils_$makins (0, value + fixed (glpl_words (lplit + 3).left, 18), meapap, 0, 0);
	nslbit (3), new_nslbit (2) = iltext;
	go to label_2520;

label_2505: 


/*  mm/xo call with no args  */
/*  ap points to  */
	argout = utils_$makins (6, 30, meapap, 1, 0);
	nslbit (3), new_nslbit (2) = iltext;
	go to label_2520;

label_2510: 

	junk = varevl_$varevl_ (ixvrvl, basno, value, admod, b29, iaddr);
	call getbit_$getbit_ (iaddr, basno, b29, rleft);

	addr (nslbit (3)) -> word.left, addr (new_nslbit (2)) -> word.left = addr (rleft) -> word.right;

	if (iaddr ^= 0) then
	value = value + fixed (glpl_words (iaddr + 3).left, 18);
	argout = utils_$makins (basno, value, meapap, b29, admod);

label_2520: 

	if (tstsw (1) ^= 0) then go to label_2550;
	slcall (3), new_slcall (2) = argout;
	slcall (5) = traout;
	if tnewcall ^= 0 then call putout_$putlst (pc, new_slcall (1), i642, new_nslcal, new_nslbit (1));
	else call putout_$putlst (pc, slcall (1), i642, nslcal, nslbit (1));
	go to label_3140;

/*  mastermode calls changed per bd.7.03, july 14, 1967.  */
/*  lpaswd is simply the transfer vector number as a literal.  */
/*  the call is made from text segment.  */
/*  return is made to the link segment.  */
/*  j.d.mills 12 july 67  (please compare dates.)  */


label_2550: 

	j = lstman_$calser (spc, link);
	link = link + fixed (glpl_words (lpsect + 3).left, 18);
	call litevl_$litasn (lpaswd, fixed (glpl_words (j + 2).right, 18), 1, 0);
	mxcall (3) = utils_$makins (lp, link, meapap, 1, 0);
	mxcall (5) = argout;
	mxcbit (5) = nslbit (3);
	mxcall (7) = utils_$makins (0, lpaswd + fixed (glpl_words (lplit + 3).left, 18), mldq, 0, 0);
	mxcall (11) = traout;
	mxcbit (11) = nslbit (5);
	call putout_$putlst (pc, mxcall (1), i642, nmxcal, mxcbit (1));

	mxclbk (2) = utils_$makins (0, lpaswd + fixed (glpl_words (lplit + 3).left, 18), mcmpq, 0, 0);
	mxlbit (2) = iltext;
	mxclbk (3) = utils_$makins (0, lreter, mtnz, 0, 0);
	mxlbit (3) = iltext;
	call putout_$putlst (pc, mxclbk (1), i642, nmxclb, mxlbit (1));
	go to label_3140;

/*  short_call pseudo-operation, call without saving any registers.  */

label_vector (51):		/*  short_call  */
label_short_call:	/*  AP already set to arg list.  */
	junk = varevl_$varevl_ (ixvrvl, basno, value, admod, b29, iaddr);
	call getbit_$getbit_ (iaddr, basno, b29, rleft);
	addr (short_nslbit (1)) -> word.left = addr (rleft) -> word.right;
	if iaddr ^= 0 then value = value + fixed (glpl_words (iaddr + 3).left, 18);
	short_slcall (1) = utils_$makins (basno, value, short_slcall (1), b29, admod);
	call putout_$putlst (pc, short_slcall (1), i642, short_nslcal, short_nslbit (1));
	goto label_3140;

/*  entry pseudo-operation, enter symbol into entry point table.  */

label_vector (38):		/*  entry  */
label_2600: 

	call getid_$getid_;
	if (eb_data_$tsym = 0) then go to label_3100;
	if (table_$table_ (iserch, sym (1), value, flocrf, lcloc) = 0) then go to label_3130;
	link = mylnk;
	name = lstman_$namasn (sym (1));

/*  ft2 has xr7 modif.  -  int expr. word has  */
/*  absol 0  (no location counter) for a value.  */
	if (tprot = 0) then if tnewobject = 0 then
	link = lstman_$lnkasn (lstman_$blkasn (1, fixed (glpl_words (lcloc + 4).right, 18), 0, 0), 0, eb_data_$mx7, 0);
	else link = 0;
	trplnk = 0;
	if (brk (1) ^= ilpar) then go to label_2620;
	tmvdef = 1;
	tderr = 0;
	trprtn = label_2610;
	go to label_933;

label_2610: 

	if (tderr ^= 0) then
	prntf = 1;

label_2620: 

	class = 1;
	if (brk (1) ^= ilsb) then go to label_2640;
	call getid_$getid_;
	if (expevl_$expevl_ (0, class, iaddr) = 0) then
	prntr,prntf = 1;
	if (iaddr ^= 0) then
	prntr = 1;
	if (brk (1) = irsb) then go to label_2630;
	prntf = 1;
	go to label_2640;

label_2630: 

	call inputs_$next;

label_2640: 

	junk = lstman_$eptasn (value, name, link, lcloc, trplnk, class);
	if (brk (1) = icomma) then go to label_2600;
	if (lcloc = 0) then go to label_3200;
	value = value + fixed (glpl_words (lcloc + 3).left, 18);
	go to label_3200;

/* ext_entry pseudo_operation Usage: ext_entry elabel,stackframe_size,clabel,dlabel,function */

label_vector (64):
label_2641:
	call getid_$getid_;
	if eb_data_$tsym = 0 then goto label_3100;	/* field error */
	j = bin("000240000"b3, 26);	/* default entry seq flags: rev1, variable */

	/* retrieve calculated stackframe size */
	stkc = fixed(glpl_words(stkclst).left);
	stkclst = fixed(glpl_words(stkclst).right);
	i = stkc;	/* use calculated value as default stackframe size */

	if table_$table_(iserch, sym(1), value, flocrf, lcloc) = 0 then goto label_3130; /* undefined error */
	if lcloc = 0 then goto label_3200;
	value = value + fixed(glpl_words(lcloc+3).left, 18); /* addr(elabel) */
	name = lstman_$namasn(sym(1));
	if brk(1) ^= icomma then goto label_2642;	/* emit code */
	/* second arg stackframe size */
	junk = varevl_$varevl_(invrvl, basno, k, admod, b29, iaddr);
	if junk ^= 0 & k ^= 0 then i = k;
	if iaddr ^= 0 then prntr = 1;
	if brk(1) ^= icomma then goto label_2642;	/* emit code */
	call getid_$getid_;
	/* third argument clabel, skip in this pass */
	if brk(1) ^= icomma then goto label_2642;	/* emit code */
	call getid_$getid_;
	/* fourth argument descriptor label */
	if sym(1) ^= 0 then do;
	     if table_$table_(iserch, sym(1), j, flocrf, iaddr) = 0 then goto label_3130;	/* undefined */
	     if iaddr^=0 then j = j + fixed(glpl_words(iaddr+3).left, 18);
	     call putout_$putlst(pc, 262144 * j, i66, 1, iltext);
	     j = bin("000300000"b3, 26);	/* entry seq flags rev1, has_descriptors */
	  end;
	if brk(1) ^= icomma then goto label_2642;	/* emit code */
	call getid_$getid_;
	/* fifth argument, function */
	if sym(1) ^= 0 then do;
	     if (sym(1) ^= ifun1) | (sym(2) ^= ifun2) | (sym(3) ^= ifun3) then goto label_3130; /* undefined symbol */
	     else  j = j + bin("000020000"b3, 26); /* entry seq flags function */
	  end;

label_2642:	/* emit structures and code for entry sequence */
	class = fixed(glpl_words(curlc + 4).right, 18) + fixed("100000"b3, 18);	/* entry flag */
	junk = lstman_$sdfasn (pc + 1 + fixed(glpl_words(curlc+3).left, 18), name, curlc, 0, class);

	/*	def_relp(filled in later), flags	*/
	call putout_$putlst(pc, j, i66, 1, ildefs);

	/*	eax7	stack_size	*/
	i = 16 * divide(i + 15, 16, 18, 0);	/* mod 16 boundary */
	call putout_$putlst(pc, i*262144 + bin("627000"b3, 19), i66, 1, 0);

	/*	epp2	pr7|28,*	*/
	call putout_$putlst(pc, bin("700034352120"b3, 36), i66, 1, 0);

	/*	tsp2	pr2|549	*/
	call putout_$putlst(pc, bin("201045272100"b3, 36), i66, 1, 0);

	/*	offset sequence	*/
	call putout_$putlst(pc, 0, i66, 1, 0);
	call putout_$putlst(pc, 0, i66, 1, isymbl);

	/*	tra	label (value)	*/
	call putout_$putlst(pc, value * 262144 + bin("710000"b3, 26), i66, 1, iltext);
	goto label_3010;    /* done */


/*  return pseudo-operation, return control to caller.  */

label_vector (39):		/*  return  */
label_2700: 

	call getid_$getid_;
	if (brk (1) ^= iques) then go to label_2720;
	junk = varevl_$varevl_ (invrvl, basno, value, admod, b29, iaddr);
	if (iaddr = 0) then go to label_2710;
	pc = spc + nertls;
	go to label_3300;


label_2710: 

	ertlst (5) = utils_$makins (ap, 2 * value, mldaq, 1, 0);
	ertlst (6) = utils_$makins (sp, labarg + 2, eb_data_$mstaq, 1, 0);
	ertlst (7) = utils_$makins (sp, labarg, meapap, 1, 0);
	irtblk = lstman_$blkasn (4, lstman_$namasn (eb_data_$unwind (1)), lstman_$namasn (eb_data_$unwind (1)), 0);
	ertlst (11) = utils_$makins (lp, lstman_$lnkasn (irtblk, 0, 0, 0) + fixed (glpl_words (lpsect + 3).left, 18),
								mtra, 1, mri);
	call putout_$putlst (pc, ertlst (1), i642, nertls, merbit (1));
	go to label_3140;

/*  normal return sequence.  */

label_2720: 

	if tnewcall ^= 0 then call putout_$putlst (pc, new_retlst (1), i642, new_nretls, new_mrtbit (1));
	else call putout_$putlst (pc, retlst (1), i642, nretls, mrtbit (1));
	go to label_3140;

/*  short_return pseudo-operation, return with no previous save.  */

label_vector (46):		/*  short_return  */
label_short_return:
	if tnewcall = 0 then prnto = 1;
	call putout_$putlst (pc, short_retlst (1), i642, short_nretls, short_mrtbit (1));
	goto label_3140;

/*  save pseudo-operation, stack setup for subroutine call.  */

label_vector (41):		/*  save/push  */
label_2800: 

	junk = varevl_$varevl_ (invrvl, basno, value, admod, b29, iaddr);
	if (value = 0) then go to label_2810;
	if (iaddr = 0) then go to label_2805;
	prntr = 1;
	if tnewcall ^= 0 then pc = spc + new_nslsav;
	else pc = spc + nslsav;
	if tprot = 1 then
	pc = pc + eb_data_$nmxsav;
	go to label_3300;

label_2805: 

	value = 8 * (divide (value + 7, 8, 17, 0));
	go to label_2820;

label_2810: 

	value = stkc;
	basno, admod, b29 = 0;

label_2820: 

	if tnewcall ^= 0 then if tprot = 0 then do;
		value = 16 * divide (value + 15, 16, 17, 0);
		new_slsave (1) = utils_$makins (basno, value, new_slsave (1), b29, admod);
		call putout_$putlst (pc, new_slsave (1), i642, new_nslsav, new_mslbit (1));
		goto label_3140;
		end;

	slsave (3) = utils_$makins (bp, value, meapbp, 1, 0);
	slsave (4) = utils_$makins (bp, 18 - value, mstpbp, 1, 0);
	slsave (5) = utils_$makins (bp, - value, meabsp, 1, 0);
	if tprot = 1 then
	call putout_$putlst (pc, mxsave (1), i642, eb_data_$nmxsav, mxsbit (1));
	call putout_$putlst (pc, slsave (1), i642, nslsav, mslbit (1));
	go to label_3140;

/*  segdef pseudo-operation, put symbol on external definition list.  */

label_vector (42):		/*  segdef  */
label_2900: 

	call getid_$getid_;
	if (eb_data_$tsym = 0) then go to label_3100;
	if (table_$table_ (iserch, sym (1), value, flocrf, lcloc) = 0) then go to label_3130;
	name = lstman_$namasn (sym (1));
	trplnk = 0;
	if (brk (1) ^= ilpar) then go to label_2920;
	tmvdef = 1;
	tderr = 0;
	trprtn = label_2910;
	go to label_933;

label_2910: 

	if (tderr = 1) then
	prntf = 1;

label_2920: 

	class = fixed (glpl_words (lcloc + 4).right, 18);
	if (brk (1) ^= ilsb) then go to label_2940;
	call getid_$getid_;
	if (expevl_$expevl_ (0, class, iaddr) = 0) then
	prntr,prntf = 1;
	if (iaddr ^= 0) then
	prntr = 1;
	if (brk (1) = irsb) then go to label_2930;
	prntf = 1;
	go to label_2940;

label_2930: 

	call inputs_$next;

label_2940: 

	junk = lstman_$sdfasn (value, name, lcloc, trplnk, class);
	if (brk (1) = icomma) then go to label_2900;
	if (lcloc = 0) then go to label_3200;
	value = value + fixed (glpl_words (lcloc + 3).left, 18);
	go to label_3200;


	/* block	indicate the start of a program block for statement map */
label_vector (68):	/* block	{block_name} */
	call getid_$getid_;
	if eb_data_$tsym = 0 then call alm_symtab_$block("");
	else call alm_symtab_$block( addr(sym(1)) -> acc_string.chars );
	goto label_3140;	/* all done */

	/* end_block	indicate the end of a program block for statement map */
label_vector (69):	/* end_block */
	call alm_symtab_$end_block;
	goto label_3140;	/* all done */

	/* enum	indicate start of enumerated-type symbol table dcls */
label_vector (70):	/* enum */
	call getid_$getid_;
	var_name = addr(sym(1)) -> acc_string.chars;
	do while(brk(1) ^= icomma & brk(1) ^= inl & brk(1) ^= iquot);
	     var_name = var_name || addr(brk(2)) -> dup_string(3);
	     call getid_$getid_;
	     var_name = var_name || addr(sym(1)) -> acc_string.chars;
	  end;
	if var_name = "" then goto label_3100;	/* field error */
	else call alm_symtab_$enum( (var_name) );
	goto label_3140;	/* all done */

	/* end_enum	indicate end of enum symbol table dcls */
label_vector (71):	/* end_enum */
	call alm_symtab_$end_enum;
	goto label_3140;	/* all done */

	/* source	indicate the current source for statement map */
label_vector (72):	/* source	<source_path> */
	unique_id = "0"b;
	dtcm = 0;
	call getid_$getid_;	/* get first part of path */
	path = addr(sym(1)) -> acc_string.chars;
	do while(brk(1) ^= icomma & brk(1) ^= inl & brk(1) ^= iquot);	/* get rest of path */
	     path = path || addr(brk(2)) -> dup_string(3);	/* add break char */
	     call getid_$getid_;
	     path = path || addr(sym(1)) -> acc_string.chars;	     /* add next word */
	  end;
	if path = "" then goto label_3100;	/* field error */
	if brk(1) = icomma then do;	/* get unique id and dtcm */
	     n = octevl_$octevl_ (rslts (1));
	     if n >=2 then goto label_3100; /* number too big, field error */
	     unique_id = unspec(rslts(1));
	     if brk(1) ^= icomma then goto label_3100; /* missing dtcm, field error */
	     n = decevl_$decevl_(rslts(1), type);
	     if n = 1 then dtcm = rslts(1);
	     else dtcm = addr(rslts(1)) -> long_int_based;
	  end;
	else begin;	/* no dtcm & unique_id figure it out ourselves */
	dcl	(dirname char(256), entryname char(32), compname char(32)) automatic;
	dcl	seg_ptr ptr;
	dcl	code fixed bin(35);

	     seg_ptr = null();
	     call expand_pathname_$component((path), dirname, entryname, compname, code);
	     if code ^= 0 then goto label_2950;	     /* forget it */
	on     cleanup call terminate_file_(seg_ptr, 0, "001"b, 0);
	     call initiate_file_$component(dirname, entryname, compname, "100"b, seg_ptr, 0, code);
	     if code ^= 0 then goto label_2950;	     /* forget it */
	     call translator_info_$component_get_source_info(seg_ptr, dirname, entryname, compname, dtcm, unique_id, code);
	     if code ^= 0 then goto label_2950;	     /* can't figure it out */
	     call terminate_file_(seg_ptr, 0, "001"b, code);
	     path = rtrim(dirname, "> ") || ">" || rtrim(entryname, " ");
	     if compname ^= "" then path = path || "::" || compname;
	  end;
label_2950:
	call alm_symtab_$source((path), unique_id, dtcm);
	goto label_3140;	/* all done */

	/* end_source	indicate end of source segment for statement map */
label_vector (73):	/* end_source */
	call alm_symtab_$end_source;
	goto label_3140;	/* all done */

	/* statement	<st_offset>,<len>,<line_no>{,<stmnt_no>} */
label_vector (74):	/* statement */
	junk = varevl_$varevl_(invrvl, basno, st_offset, admod, b29, iaddr);
	if iaddr ^= 0 then prntr = 1;
	if brk(1) ^= icomma then goto label_3100;	/* field error */
	junk = varevl_$varevl_(invrvl, basno, st_length, admod, b29, iaddr);
	if iaddr ^= 0 then prntr = 1;
	if brk(1) ^= icomma then goto label_3100;	/* field error */
	junk = varevl_$varevl_(invrvl, basno, st_line, admod, b29, iaddr);
	if iaddr ^= 0 then prntr = 1;
	if brk(1) = icomma then do;	/* optional statement num */
	     junk = varevl_$varevl_(invrvl, basno, st_num, admod, b29, iaddr);
	     if iaddr ^= 0 then prntr = 1;
	  end;
	else st_num = 1;	/* if not specified, then statement num = 1 */
	call alm_symtab_$statement(pc + fixed(glpl_words(curlc+3).left, 18),
	     st_offset, st_length, st_line, st_num);
	goto label_3140;

	/* structure	indicate start of structure symbol table dcls */
label_vector (75):	/* structure	<structure_name> */
	call getid_$getid_;
	var_name = addr(sym(1)) -> acc_string.chars;
	do while(brk(1) ^= icomma & brk(1) ^= inl & brk(1) ^= iquot);
	     var_name = var_name || addr(brk(2)) -> dup_string(3);
	     call getid_$getid_;
	     var_name = var_name || addr(sym(1)) -> acc_string.chars;
	  end;
	if var_name = "" then goto label_3100;	/* field error */
	else call alm_symtab_$structure( (var_name) );
	goto label_3140;	/* all done */

	/* end_structure	indicate end of structure symbol table dcls */
label_vector (76):	/* end_structure */
	call alm_symtab_$end_structure;
	goto label_3140;	/* all done */

label_vector (77):	/* symbol	<symbol_name>,<symbol_type>{,location} */
	call getid_$getid_;	/* name */
	var_name = addr(sym(1)) -> acc_string.chars;
	do while(brk(1) ^= icomma & brk(1) ^= inl & brk(1) ^= iquot);
	     var_name = var_name || addr(brk(2)) -> dup_string(3);
	     call getid_$getid_;
	     var_name = var_name || addr(sym(1)) -> acc_string.chars;
	  end;
	if var_name = "" then goto label_3100;	/* field error */

	call getid_$getid_;	/* type */
	var_type = addr(sym(1)) -> acc_string.chars;
	i = 0;	/* nesting level for '[' ... ']' pairs */
	do while(brk(1) ^= inl & (brk(1) ^= icomma | i > 0) & brk(1) ^= iquot);
	     if brk(1) = ilsb then i = i + 1;	/* another '[' */
	     else if brk(1) = irsb then i = i - 1;	/* matching ']' */
	     var_type = var_type || addr(brk(2)) -> dup_string(3);
	     if brk(1) ^= ilsb & brk(1) ^= icomma & brk(1) ^= icol then do;
		call getid_$getid_;
		var_type = var_type || addr(sym(1)) -> acc_string.chars;
	       end;
	     else do;
		call getid_$getid_;
		/* if the identifier has a symbolic value use it */
		junk = table_$table_(iserch, sym(1), value, flocrf, lcloc);
		if junk=0 then var_type = var_type || addr(sym(1)) -> acc_string.chars;
		else do;
		     if lcloc ^= 0 then value = value + fixed(glpl_words(lcloc+3).left, 18);
		     var_type = var_type || ltrim(char(value));
		  end;
	       end;
	  end;
	if var_type = "" | i > 0 then goto label_3100;	/* field error */

	/* location {optional} */
	i = 0;	/* initial offset = 0 bits */
	if brk(1) = icomma then do;
	     if varevl_$varevl_(ixvrvl, basno, value, admod, b29, iaddr) = 0 then goto label_3120; /* S error */
	     if brk(1) = ilpar then do;	/* bit offset */
		if varevl_$varevl_(invrvp, 0, i, 0, 0, 0) = 0 then goto label_3120;	/* S error */
	       end;
	     if basno = 0 & value = 0 & admod = 0 & b29 = 0 & iaddr = 0 & i = 0 then goto label_3100; /* F error */
	     call alm_symtab_$symbol((var_name), (var_type), basno, value, admod, b29, iaddr, i);
	  end;
	else call alm_symtab_$symbol((var_name), (var_type), 0, 0, 0, 0, 0, 0);
	goto label_3140;	/* all done */


	/* union	indicate start of union symbol table dcls */
label_vector (78):	/* union	<union_name> */
	call getid_$getid_;
	var_name = addr(sym(1)) -> acc_string.chars;
	do while(brk(1) ^= icomma & brk(1) ^= inl & brk(1) ^= iquot);
	     var_name = var_name || addr(brk(2)) -> dup_string(3);
	     call getid_$getid_;
	     var_name = var_name || addr(sym(1)) -> acc_string.chars;
	  end;
	if var_name = "" then goto label_3100;	/* field error */
	else call alm_symtab_$union( (var_name) );
	goto label_3140;	/* all done */

	/* end_union	indicate end of union symbol table dcls */
label_vector (79):	/* end_union */
	call alm_symtab_$end_union;
	goto label_3140;	/* all done */


/*  setlp pseudo - op.  */
/*  generate eaplp -*, ic with 3a relocation bits.  */

label_vector (45):		/*  setlp  */
label_2970: 

	call putout_$putwrd (pc, utils_$makins (0, - fixed (glpl_words (curlc + 3).left, 18) - pc, meaplp, 0, mpc),
								i642, glpl_$glwrd (imlink, 0));
	go to label_3010;

/*  getlp pseudo-operation, set LP from lot.  */

label_vector (49):		/*  getlp  */
label_getlp:
	call putout_$putlst (pc, new_getlp (1), i642, new_ngetlp, new_getbit (1));
	goto label_3140;



/*  EIS multi-word instruction operand descriptors are generated by these pseudo-ops.  */

label_vector (55):		/*  desc9a, desc6a, desc4a  */
label_eis_desca:
	type = 1;
	goto desc_common;

label_vector (56):		/*  descb  */
label_eis_descb:
	type = 2;
	goto desc_common;

label_vector (57):		/*  desc9fl, desc4us, etc.  */
label_eis_descn:
	type = 3;

desc_common:
	nobits = fixed (addr (binop) -> descop_overlay.flags, 4);	/*  9, 6, 4, or 1  */
	class = fixed (addr (binop) -> descop_overlay.format, 4);	/*  Numeric operand format (fixed vs. float, etc.).  */
	full_word_temp = alm_eis_parse_$descriptor (type, nobits, class, rleft);
	call putout_$putwrd (pc, full_word_temp, i66, rleft);
	goto label_3015;


label_vector (52):		/*  rpt, rpd, rpl  */
label_repeat:		/*  repeat type instructions rpt, rpd, and rpl.  Format is:
				RPT	tally,delta,term1,term2,...
			   where term_i are the names of the conditional transfer instructions
			   that test the states to be terminated on.  The A, B, and C bits are
			   kept in the opcode_overlay.flags field (viz. RPD, RPDA, RPTX).  */

	call getid_$getid_;
	if expevl_$expevl_ (0, zleft, iaddr) = 0 then prnte = 1;
	if iaddr ^= 0 then prntr = 1;
	if brk (1) = icomma then do;
		call getid_$getid_;
		if expevl_$expevl_ (0, zright, iaddr) = 0 then prnte = 1;
		if iaddr ^= 0 then prntr = 1;
		if zright < 0 | zright > 63 then prnte = 1;
		end;
	else zright = 1;			/*  delta defaults to 1.  */

	termination_conditions = ""b;
	do i = 1 to 7 while (brk (1) = icomma);
		call getid_$getid_;
		do j = 1 to 7;
			if sym (1) = eb_data_$rpt_terminators (j) then do;
				substr (termination_conditions, j, 1) = "1"b;
				goto rpt_out;
				end;
			end;
		prntu = 1;
	rpt_out:	end;

	zleft = zleft * 1024 + fixed (addr (binop) -> opcode_overlay.flags || termination_conditions, 11);
	itemp = tinhib;		/*  Processor manual calls for RPT to have inhibit flag on always.  */
	tinhib = 1;
	call putout_$putwrd (pc, utils_$makins (0, zleft, binop, 0, zright), i642, 0);
	tinhib = itemp;
	goto label_3015;


label_vector (53):		/*  awd, swd, abd, sbd, etc.  */
label_eis_single:		/*  single word EIS instructions awd, abd, etc.  Format is:
				AWD	base|offset,tag
			   where base is required, in order to select a target register.
			   For AWDX, etc., the opcode_overlay.flags field is non-zero to indicate
			   that bit 29 should be turned off.  (This makes add into clear-and-add, etc.)  */

	if varevl_$varevl_ (ixvrvl, basno, value, admod, b29, iaddr) = 0 then prnte = 1;
	if b29 = 0 then do;		/*  Base number _m_u_s_t be specified.  */
		prnte = 1;
		b29 = 1;
		end;
	if iaddr = 0 then rleft = 0;		/*  calculate relocation bits.  */
	else do;
		value = value + fixed (glpl_words (iaddr + 3).left, 18);
		call getbit_$getbit_ (iaddr, basno, b29, rleft);
		rleft = rleft * 262144;
		end;

	full_word_temp = utils_$makins (basno, value, binop, b29, admod);
	if addr (binop) -> opcode_overlay.flags then full_word_temp = full_word_temp - 64;	/*  turn b29 OFF  */
	call putout_$putwrd (pc, full_word_temp, i642, rleft);
	goto label_3015;

label_vector (54):		/*  mvn, cmpb, ad2d, etc.  */
label_eis_multiple:		/*  EIS instructions with multi-word operand descriptors, MLR, CMPB, etc.
			   The instruction word contains up to three tags for the operands
			   and several kinds of flags and numeric values.  */

	flags = fixed (addr (binop) -> opcode_overlay.flags, 4);		/*  Non-zero if FILL field is only one bit wide.  */
	full_word_temp = alm_eis_parse_$instruction (binop, flags, rleft);
	call putout_$putwrd (pc, full_word_temp, i642, rleft);
	goto label_3015;


label_vector (44):		/*  eap, sprp, etc.  */
label_get_base:		/*  normal base register instructions written as:
				EAP	bp,ap|2,*
			   This is so symbolic names can be used for base registers.  */

	rslts (1) = sym (1); rslts (2) = sym (2);	/*  Save opcode name.  */
	call getid_$getid_;
	do itemp = 0 to 7;		/*  Search for predefined base register name first.  */
		if sym (1) = symbas (itemp + 1) then goto got_index;
		end;
	goto get_index;		/*  join common code.  */

label_vector (43):		/*  eax, canx, etc.  */
label_get_index:		/*  normal index register instructions written with separate register name as above.  */
	rslts (1) = sym (1); rslts (2) = sym (2);	/*  As above. */
	call getid_$getid_;

get_index:
	if expevl_$expevl_ (0, itemp, iaddr) = 0 then prnte = 1;
	if iaddr ^= 0 then prntr = 1;

got_index:
	if itemp < 0 | itemp > 7 then do;
		prnte = 1;
		itemp = 0;
		end;
	sym (1) = rslts (1); sym (2) = rslts (2);	/*  Put opcode name back.  */
		/*  Fudge opcode name to contain register number.  */
	j = addr (sym) -> acc_string.length + 1;
	addr (sym) -> acc_string.length = j;
	substr (addr (sym) -> acc_string.chars, j, 1) = substr ("01234567", itemp + 1, 1);
	if brk (1) = icomma then brk (1) = isp;/*fix equ bug*/
	goto label_301;			/*  Go re-evaluate opcode.  */

label_vector (58):
label_entrybound:
	eb_data_$entry_bound = spc + fixed(glpl_words(curlc + 3).left, 18);
	goto label_3010;


/*  NORMAL INSTRUCTIONS  */

label_vector (0):		/*  Normal instruction.  */
label_3000: 
	if (varevl_$varevl_ (ixvrvl, basno, value, admod, b29, iaddr) = 0) then prnte = 1;
	rleft = 0;
	if (iaddr = 0) then go to label_3008;
	value = value + fixed (glpl_words (iaddr + 3).left, 18);

/*  determine the proper relocation bits  */

	call getbit_$getbit_ (iaddr, basno, b29, rleft);

/*  the following statement left justifies the reloc. bits  */
/*  and avoids a call to glpl_$glwrd (rleft, 0) for each instruction.  */

	rleft = rleft * 262144;

label_3008: 

	call putout_$putwrd (pc, utils_$makins (basno, value, binop, b29, admod), i642, rleft);
	goto label_3015;

/*  re - entry from pseudo-operation processing.  */

label_3010: 
	call prwrd_$source_only;
label_3015: 

	if (pc = tpc & curlc = tlc) then go to label_3040;
	call prnter_$prnter_ ("fatal phase error in pass2.");
	call utils_$abort;



/*  skip over comment portion of card  */

label_3040: 

	call inputs_$next_statement;
	go to label_200;


/*  error return for pseudo-operations.  */

/*  field (f) error.  */

label_3100: 

	prntf = 1;
	go to label_3200;

/*  phase (p) error.  */

label_3110: 

	prntp = 1;
	go to label_3200;

/*  symbol (s) definition error.  */

label_3120: 

	prnts = 1;
	go to label_3200;

/*  undefined (u) symbol error.  */

label_3130: 

	prntu = 1;
	go to label_3200;

/*  variable length macro phase error.  */

label_3140: 

	if curlc = tlc then go to label_3150;
	call prnter_$prnter_ ("fatal multiple location counter mismatch in pass2.");
	call utils_$abort;

label_3150: 

	if pc = tpc then go to label_3040;
	prntp = 1;
	pc = tpc;
	go to label_3040;


label_vector (9):		/* dup */
label_dup:
	if dup_ptr ^= null () then go to label_3120;
	if varevl_$varevl_ (invrvl, basno, value, admod, b29, iaddr) = 0 then go to label_3120;
	if iaddr ^= 0 then go to label_3300;
	if value <= 0 then go to label_3120;
	dup_count = value - 1;
	call prwrd_$prwrd_ (spc + fixed (glpl_words (curlc + 3).left, 18), value, eb_data_$ib6);
	call inputs_$next_statement;
	call inputs_$get_ptr (dup_ptr, dup_start, junk, end_statement_flag);
	go to label_200;

label_vector (10):		/* dupend */
label_dupend:
	if dup_ptr = null () then go to label_3120;
	call inputs_$get_ptr (temp_ptr, i, j, end_statement_flag);
	if temp_ptr ^= dup_ptr then go to label_3100;
	i = begin_line;			/* Really want beginning of line. */
	call inputs_$next_statement;
	if dup_count > 0 then
	     call alm_include_file_$insert (addr (dup_string (dup_start)), i - dup_start, dup_count);
	dup_ptr = null ();
	go to label_200;

label_vector (60):
label_macro:
	call getid_$getid_;
	if eb_data_$tsym = 0 then goto label_3100;
	call oplook_$redefine;
	call inputs_$next_statement;
	call mexp_$define_macro (addr (sym (1)) -> acc_string.chars);
	go to label_200;

label_vector (40):
label_maclist:
	call getid_$getid_;
	if eb_data_$tsym = eb_data_$ion then
	     tmacl = "00"b;
	else if eb_data_$tsym = eb_data_$ioff then
	     tmacl = "11"b;
	else if eb_data_$tsym = eb_data_$iobject then
	     tmacl = "10"b;
	else if eb_data_$tsym = eb_data_$irestore then do;
	     eb_data_$macro_listing_control = substr (eb_data_$macro_listing_control, 3);
	     go to end_maclist;
	end;
	else go to label_3100;

	if brk (1) = icomma then do;
	     call getid_$getid_;
	     if eb_data_$tsym = eb_data_$isave then
		eb_data_$macro_listing_control = tmacl || eb_data_$macro_listing_control;
	     else go to label_3100;
	end;

	else substr (eb_data_$macro_listing_control, 1, 2) = tmacl;

end_maclist:
	if eb_data_$macro_depth > 0 then do;
	     call inputs_$next_statement_nolist;
	     go to label_200;
	end;
	else go to label_3300;



/*  possible phase error, print flags, loc, and value.  */

label_3200: 

	if (pc = tpc) then go to label_3210;
	prntp = 1;
	pc = tpc;

label_3210: 

	call prwrd_$prwrd_ (spc + fixed (glpl_words (curlc + 3).left, 18), value, eb_data_$ib6);
	go to label_3040;

/*  printer for no-valued pseudo-operations, print flags and loc.  */

label_3300: 

	call prwrd_$prwrd_ (spc + fixed (glpl_words (curlc + 3).left, 18), 0, ibb);
	go to label_3015;


     end pass2_;
