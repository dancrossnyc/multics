/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(86-09-30,Oke), approve(86-09-30,MCR7543), audit(86-09-30,JRGray),
     install(86-10-08,MR12.0-1180):
     Allow ALM to support double word constants.
  2) change(86-10-01,JRGray), approve(86-10-01,MCR7507),
     audit(86-10-27,RWaters), install(86-11-12,MR12.0-1202):
     Modified to support severity, *heap references, the "init_link" pseudo,
     and joining to the symbol section.
  3) change(86-11-14,JRGray), approve(86-11-14,MCR7568),
     audit(86-11-21,RWaters), install(86-11-26,MR12.0-1228):
     Also MCR7572. Modified to add support for the three new pseudo-ops: ext_entry,
     oct_unal, and dec_unal.
  4) change(88-03-21,JRGray), approve(88-08-05,MCR7952),
     audit(88-09-30,WAAnderson), install(88-10-17,MR12.2-1169):
     Changed for symbol table support. Add labels for 12 new pseudos that are
     ignored in pass1.
                                                   END HISTORY COMMENTS */


pass1_: 
     procedure(decor,target_value,no_target_given,first_time_thru); /* decor is initialized and passed from alm_6180_ ; 
					     target_value, no_target_given come from alm_ via alm_6180_ */

		/* 
		   pass1 is the first pass of the Multics assembler .

		   pass1 is primarily concerned with assigning symbol definitions
		   so that pass2 of the assembler can generate the binary output.
		   pass1 causes several tables to be generated and maintained,
		   including the assignment table (for internal symbols) and
		   the external name table, segment name table, trap word
		   table, link table, literal table, etc. no collation tape
		   is written, but the pc at the end of each statement is
		   recorded in a list for comparison in pass2, any discrepancy
		   is a phase error.
		   multiple location counters added
		   by J. D. Mills, 1 June 1967.


	Modified to support *heap links by R Gray and W Anderson on 2/05/86.
	Modified for changes to decor processing requested by MTR 175  on 3/25/81 by EBush.
	Modified to implement -target on 2/5/81 by EBush.
	Modified for decor processing 12/30/80 by E Bush
	Modified for macro processing 3/23/77 by Noel I. Morris
          Modified for prelinking on 06/15/75 by Eugene E Wiatrowski
	Modified 740905 by PG and ARD to extend ACC/ACI/BCI to 167/168/252 characters.
	Modified on 07/28/73 at 23:48:28 by R F Mabee.
	by RFM in June 1973 to add EIS instructions including multi-word operands.
	by RFM on 9 November 1972 to avoid reserving space for text entry sequence in old object format.
	by RFM on 21 July 1972 to fix R error on call to internal symbol.
	by RFM on 21 March 1972 for new object segment format.
	by RFM on 4 March to add new call/save/return operators.
	by RHG on 2 June 1971 to suppress "N" flag for undefined op code (should be "O")
	by RHG on 2 April 1971 to make rem=null if there was a label
			   to allow "bss ,exp" with no label specified
	by RHG on 17 Sept 1970 for new listing package
	by RHG on 7 August 1970 at 0545 for new sthead (name pseudo-op)
	by NA on July 14, 1970 at 1710 for the proper use of search_return
			and to call expevl_ as a function not a regular subroutine
		    */

/* "Common" variables initialized in eb_data_ */


%include varcom;
%include concom;
%include erflgs;
%include codtab;
%include sthedr;
%include mxpro;
%include lstcom;
%include labarg;
%include alm_lc;
%include alm_options;
%include alm_data;
/**/
/* EXTERNAL ENTRIES CALLED BY PASS1 */

 dcl		getid_		ext entry,
		getid_$getnam	ext entry,
		inputs_$next	ext entry,
		inputs_$next_statement	ext entry,
		inputs_$nxtnb	ext entry,
		utils_$pckflg	ext entry ( fixed bin (26) ),
		alm_include_file_$pass1 ext entry,
		alm_include_file_$insert ext entry (ptr, fixed bin (26), fixed bin (26)),
		alm_include_file_$pop ext entry,
		inputs_$get_ptr ext entry (ptr, fixed bin (26), fixed bin (26), bit (1) aligned),
		mexp_		ext entry (char (*), fixed bin (26), fixed bin(17), bit(1), bit(1)),
		mexp_$define_macro	ext entry (char (*)),
		oplook_$reset	ext entry,
		oplook_$redefine	ext entry,
		getid_$setid	ext entry ( fixed bin (26)),
		glpl_$slwrd	ext entry ( fixed bin (26), fixed bin (26), fixed bin (26)),
		glpl_$storl	ext entry ( fixed bin (26), fixed bin (26)),
		glpl_$storr	ext entry ( fixed bin (26), fixed bin (26)),
		system_type_	ext entry ( char(*), char(*), fixed bin, fixed bin(35));

/* EXTERNAL FUNCTIONS CALLED BY PASS1 */

 dcl	(	ascevl_$accevl	ext entry (fixed bin (26)),
		ascevl_$acievl	ext entry (fixed bin (26)),
		ascevl_$ac4evl	ext entry (fixed bin (26)),
		ascevl_$bcdevl	ext entry (fixed bin (26)),
		expevl_		ext entry ( fixed bin (26), fixed bin (26), fixed bin (26)),
		lstman_$blkasn	ext entry ( fixed bin (26), fixed bin (26), fixed bin (26), fixed bin (26)),
		glpl_$cwrd	ext entry ( fixed bin (26)),
		glpl_$glwrd	ext entry ( fixed bin (26), fixed bin(26)),
		decevl_		ext entry ( fixed bin (26), fixed bin (26))) returns (fixed bin (26));
dcl	(	utils_$exadrs	ext entry ( fixed bin (26), fixed bin (26)),
		lstman_$lnkasn	ext entry ( fixed bin (26), fixed bin (26), fixed bin (26), fixed bin (26)),
		lstman_$outasn	ext entry ( fixed bin (26), fixed bin (26), fixed bin (26)),
		utils_$ls ext entry (fixed bin (26), fixed bin (26)),
		utils_$rs		ext entry ( fixed bin (26), fixed bin (26)),
		lstman_$namasn	ext entry ( fixed bin (26)),
		utils_$nswrds	ext entry ( fixed bin )) returns (fixed bin (26));
dcl	(	octevl_		ext entry ( fixed bin (26)),
		oplook_$oplook_	ext entry ( fixed bin (26), fixed bin (26)),
		glpl_$setblk	ext entry ( fixed bin (26), fixed bin (26) ),
		table_		ext entry ( fixed bin (26), fixed bin (26), fixed bin (26), fixed bin (26),
					  fixed bin (26)),
		lstman_$trpasn	ext entry ( fixed bin (26), fixed bin (26)),
		varevl_		ext entry ( fixed bin (26), fixed bin (26), fixed bin (26), fixed bin (26),
					  fixed bin (26), fixed bin (26)),
		vfdevl_$vfdcnt	ext entry ( fixed bin (26), fixed bin (26))
			) returns ( fixed bin (26));



/* AUTOMATIC VARIABLES USED BY PASS1 */
 dcl	(binop, flags, i, iaddr, iflag, itype, iwhat, j, junk, k, link, mul, n, newrho, nwrds, option,
	basno, value, b29, admod, pcblk (3), class, type, xnlnk, ptrcal, ptrarg, trplnk, blklnk, symlnk,
	rslts (42), newval, oldval, tbss, tderr, stat_or_link ) fixed bin (26);
dcl	label_flag	bit (1) aligned;
dcl	end_statement_flag 	bit (1) aligned;
dcl	dup_ptr ptr init (null ()),
	temp_ptr ptr,
	dup_count fixed bin (26),
	dup_start fixed bin (26),
	dup_string (0:262143) char (1) unal based (dup_ptr);
dcl       operand    char(32) varying;
dcl	canonical_operand char(24);
dcl	code	fixed bin(35);
dcl	(stkclst, stkctop) fixed bin(26);		/* used to remember stackframe sizes */
dcl	ext_entry_count fixed bin;
dcl	remember_sym(8) fixed bin(26);	/* used to remember sym */

/* LABEL VARIABLE */
 dcl	search_return label local;

 dcl	static_in_linkage bit(1) initial("0"b);
 


 

/* EXTERNAL DATA USED BY PASS1 */
 dcl	(eb_data_$itext, eb_data_$ilink, eb_data_$isym, eb_data_$istatic, eb_data_$idefs, eb_data_$ioff, eb_data_$ion,
	eb_data_$nertls, eb_data_$nmxcal, eb_data_$nmxclb, eb_data_$nmxsav, eb_data_$nretls,
	eb_data_$nslcal, eb_data_$nslsav,
	eb_data_$new_nslcal, eb_data_$new_nslsav, eb_data_$new_nretls, eb_data_$short_nretls,
	eb_data_$new_nentls, eb_data_$short_nslcal, eb_data_$new_ngetlp,
	eb_data_$atext2 (2), eb_data_$alink2 (2), eb_data_$asym2 (2), eb_data_$astatic2 (2), eb_data_$asystem2 (2),
	eb_data_$adef2 (2),
	eb_data_$tsym, eb_data_$atext (2), eb_data_$alink (2), eb_data_$asym (2), eb_data_$asys (2), eb_data_$aheap(2),
	eb_data_$astat (2)) ext fixed bin (26);

 dcl	eb_data_$separate_static ext bit(1);
dcl	eb_data_$entrybound_bit ext bit(1);
dcl	eb_data_$macro_depth fixed bin (26) ext;


/* PARAMETERS */

dcl       decor fixed bin(35); /* passed from alm_6180_ */
dcl	target_value fixed bin(17); /* ditto */
dcl	(no_target_given,first_time_thru) bit(1); /* likewise */



/* OVERLAY FOR SETTING HALF WORDS */

 dcl	1 word based aligned,
	  2 (left,right) bit (18) unaligned;

 dcl	1 glpl_words (0:262143) based (eb_data_$lavptr) aligned,
	  2 left bit (18) unaligned,
	  2 right bit (18) unaligned;

 dcl	1 acc aligned based,
	  2 length bit (9) unaligned,
	  2 string char (32) unaligned;

 dcl	eb_data_$lavptr external pointer;
 dcl	eb_data_$per_process_static_sw fixed bin external;



/* entry to subroutine, set up variables before main loop. */


label_100: 
	pc = 0;
	labarg = 0;
	tfirstreftrap = 0;
	ext_entry_count = 0;
	eb_data_$separate_static,
	eb_data_$entrybound_bit,
	static_in_linkage = "0"b;
 
 

/* Initialize system location counters. */

	junk = table_ (iassgn, lctext (1), 0, fmlcrf, iaddr);
	ulclst, ulcend, curlc, lptext = iaddr;

	junk = table_ (iassgn, lcst (1), 0, fmlcrf, iaddr);
	call glpl_$storr (iaddr+2, ulclst);
	call glpl_$storl (ulclst+2, iaddr);
	ulclst, lpst = iaddr;
	call glpl_$storr (lpst+4, eb_data_$isym);

	junk = table_ (iassgn, lcdefs (1), 0, fmlcrf, iaddr);
	tlclst, dlclst, lpdefs = iaddr;

	junk = table_ (iassgn, lclit (1), 0, fmlcrf, iaddr);
	call glpl_$storr (iaddr+2, tlclst);
	call glpl_$storl (tlclst+2, iaddr);
	tlclst, lplit = iaddr;
	call glpl_$storl (lplit+4, 2);

	junk = table_ (iassgn, lcentries (1), 0, fmlcrf, iaddr);
	call glpl_$storr (iaddr + 2, tlclst);
	call glpl_$storl (tlclst + 2, iaddr);
	tlclst, lpentries = iaddr;

	junk = table_ (iassgn, lccall (1), 0, fmlcrf, iaddr);
	call glpl_$storr (iaddr+2, tlclst);
	call glpl_$storl (tlclst+2, iaddr);
	tlclst, lpcall = iaddr;

	junk = table_ (iassgn, lctv (1), 0, fmlcrf, iaddr);
	call glpl_$storr (iaddr+2, tlclst);
	call glpl_$storl (tlclst+2, iaddr);
	tlclst, lptv = iaddr;

	junk = table_ (iassgn, lcsect (1), 0, fmlcrf, iaddr);
	llclst, lpsect = iaddr;
	call glpl_$slwrd (lpsect+4, 2, eb_data_$ilink);

	junk = table_ (iassgn, lchead (1), 0, fmlcrf, iaddr);
	call glpl_$storr (iaddr+2, llclst);
	call glpl_$storl (llclst+2, iaddr);
	llclst, lphead = iaddr;
	call glpl_$storr (lphead+4, eb_data_$ilink);

	junk = table_ (iassgn, lcrst (1), 0, fmlcrf, iaddr);
	slclst, lprst = iaddr;
	call glpl_$storr (lprst+4, eb_data_$isym);

	junk = table_ (iassgn, lcrlk (1), 0, fmlcrf, iaddr);
	call glpl_$storr (iaddr+2, slclst);
	call glpl_$storl (slclst+2, iaddr);
	slclst, lprlk = iaddr;
	call glpl_$storr (lprlk+4, eb_data_$isym);

	junk = table_ (iassgn, lcrtx (1), 0, fmlcrf, iaddr);
	call glpl_$storr (iaddr+2, slclst);
	call glpl_$storl (slclst+2, iaddr);
	slclst, lprtx = iaddr;
	call glpl_$storr (lprtx+4, eb_data_$isym);

	/* make stackframe_size list */
	stkctop = glpl_$setblk(0, 1);
	stkclst = stkctop;

	binlin = 1;
	call oplook_$reset;

/* main loop re-entry, assign any symbols in location field. */

label_200: 
	label_flag = "0"b;
label_210:
	spc = pc;
	brk (1) = isp;
	call getid_;
	if (brk (1) ^= icol) then goto label_300;
	if (eb_data_$tsym ^= 0) then junk = table_ (iassgn,sym (1),spc,flocrf,curlc);
	label_flag = "1"b;
	goto label_210;

/* get operator and test for pseudo-operation. */

label_300: 
	if sym (1) ^= 0 then goto label_302;
	if brk (1) = inl then goto label_870;
	if brk (1) = iquot then goto label_870;
label_302:
	binop = oplook_$oplook_ ( iflag, itype );
	if iflag ^= 0 then do;
	     call mexp_ (substr (addr (sym (1)) -> acc.string, 1, bin (addr (sym (1)) -> acc.length, 9)), iflag, target_value, no_target_given,first_time_thru);
	     if iflag ^= 0 then go to label_3200;
	     else go to label_3030;
	end;
	if (brk (1) = isp /*iht ditto*/	|	brk (1) =inl /* icr and isc ditto*/ )  then goto label_305;

/* then there is an error in this statement. */
	goto label_3200;

label_305: 

	goto label_vector (itype);


/* control group of pseudo operations. */

/* end card, simply return to caller of pass1.
   reset inhibit flag for pass2 first. */


label_vector (1):		/* end */
label_450: 
	tinhib = 0;				/* FALSE */

/* check for lpst at head of unjoined lc list. if there, move
   to head of symbol segment lc list. */
	if (ulclst ^= lpst) then goto label_460;
	ulclst = fixed (glpl_words (ulclst + 2).right, 18);
	if (ulclst ^= 0) then call glpl_$storl (ulclst + 2,0);
	call glpl_$storr (lpst + 2,slclst);
	call glpl_$storl (slclst + 2,lpst);
	slclst = lpst;

/* set up system location counter maximum lengths for
   absolutizing in postp1. */

label_460: 

	if (tprot ^= 0 ) then call glpl_$storr (lptv + 3,tvlth);
	if (tcall ^= 0 ) then call glpl_$storr (lpcall + 3,eb_data_$nslcal + 1);

/* length of header is 8. */
	call glpl_$storr (lphead + 3, 8);

/* Likewise update entry count into entries section. */
	if tnewobject ^= 0 then call glpl_$storr (lpentries + 3, (tvlth - ext_entry_count) * eb_data_$new_nentls);
		/* ext_entry already adjusts text section length */

	/* remember amount of stack space currently allocated */
	call glpl_$slwrd(stkclst, stkc, 0);
	stkc = stkctop;	/* stkc is used to transmit top of stkclst to pass2 */

/* save the current value of pc in curlc. */
	call glpl_$storr (curlc + 1,pc);

	return;


/* include statement, use new source file. */

label_vector (50):		/* include */
label_include:
	if dup_ptr ^= null () then go to label_3100;
	call getid_ ();
	if eb_data_$tsym = 0 then goto label_3100;
	call inputs_$next_statement ();
	call alm_include_file_$pass1 ();
	goto label_200;

/* use pseudo-operation, use new location counter. */

label_vector (2):		/* use */
label_500: 
	call getid_;
	if ( eb_data_$tsym = 0) then goto label_3100;

/* save current value of old location counter. */
	call glpl_$storr (curlc + 1,pc);

/* use new lc as the current lc. */
	if (table_ (iserch,sym (1),pc,fmlcrf,curlc) ^= 0) then goto label_3010;


/* not found so initialize a new location counter. */
	pc = 0;
	junk = table_ (iassgn,sym (1),pc,fmlcrf,curlc);


/* put new lc at end of ulclst. no problems with empty
   list since list initialized with some system lc's. */
	call glpl_$storr (ulcend + 2,curlc);
	call glpl_$storl (curlc + 2,ulcend);
	ulcend = curlc;
	goto label_3010;

/* org pseudo-operation. set the pc to the value of the expression. */

label_vector (3):		/* org */
label_525: 
	if varevl_ (invrvl,basno,value,admod,b29,iaddr) = 0 then goto label_3110;
	if (iaddr ^= 0) then goto label_3300;
	if pc > fixed (glpl_words (curlc + 3).right, 18) then call glpl_$storr (curlc + 3, pc);
	pc = value;
	goto label_3010;

/* join pseudo-op. move lc nodes from unjoined
   lc list to one of the joined lc lists. */

label_vector (4):		/* join */
label_550: 
	call inputs_$nxtnb;
	if (brk (1) ^= islash) then goto label_3100;

label_555: 
	call getid_;
	if (brk (1) ^= islash | eb_data_$tsym = 0) then goto label_3100;
	if (sym (1) = eb_data_$atext2 (1) & sym (2) = eb_data_$atext2 (2)) then goto label_565;
	if (sym (1) = eb_data_$alink2 (1) & sym (2) = eb_data_$alink2 (2)) 
	   then do;
	        static_in_linkage = "1"b;
	        goto label_570;
	        end;
	if (sym (1) = eb_data_$asym2 (1) & sym (2) = eb_data_$asym2 (2)) then goto label_575;
	if (sym (1) = eb_data_$astatic2 (1) & sym (2) = eb_data_$astatic2 (2)) 
	   then do;
	        eb_data_$separate_static = "1"b;
	        goto label_570;
	        end;
	if (sym (1) = eb_data_$adef2 (1) & sym (2) = eb_data_$adef2 (2)) then goto label_593;

	prntu = 1;				/* TRUE */

label_560: 
	call inputs_$next;
	if (brk (1) = islash) then goto label_555; /* parse join */
	if (brk (1) = isp | brk (1) = inl) then goto label_3020; /* next statement */
	goto label_560;

/* join text location counters. */

label_565: 
	call getid_;
	search_return = label_566;
	goto label_580;

label_566: 
	if (iaddr = 0) then goto label_569;
	call glpl_$storr (iaddr + 4,eb_data_$itext);
	call glpl_$storl (iaddr + 2, fixed (glpl_words (lptv + 2).left, 18));
	call glpl_$storr (iaddr + 2,lptv);
	if (tlclst ^= lptv) then goto label_567;
	tlclst = iaddr;
	goto label_568;

label_567: 

	call glpl_$storr (fixed (glpl_words (lptv + 2).left, 18) + 2, iaddr);

label_568: 

	call glpl_$storl (lptv + 2,iaddr);

label_569: 
	if (brk (1) = icomma) then goto label_565;
	if (brk (1) = islash) then goto label_555; /* parse join */
	goto label_3020; /* next statement */

/* join link location counters. */

label_570: 
	call getid_;
	search_return = label_571;
	goto label_580;

label_571: 
	if (iaddr = 0) then goto label_574;
	if eb_data_$separate_static
	   then stat_or_link = eb_data_$istatic;
	   else stat_or_link = eb_data_$ilink;
	call glpl_$storr (iaddr + 4,stat_or_link);
	call glpl_$storl (iaddr + 2, fixed (glpl_words (lpsect + 2).left, 18));
	call glpl_$storr (iaddr + 2,lpsect);

/* since lphead is alsays left of lpsect we
   do not need to test for llclst = lpsect. */
	call glpl_$storr (fixed (glpl_words (lpsect + 2).left, 18) + 2, iaddr);
	call glpl_$storl (lpsect + 2,iaddr);

label_574: 
	if (brk (1) = icomma) then goto label_570;
	if (brk (1) = islash) then goto label_555; /* parse join */
	goto label_3020; /* next statement */

/* join symbol location counters. */

label_575: 
	call getid_;
	search_return = label_576;
	goto label_580;

label_576: 
	if (iaddr = 0) then goto label_579;
	call glpl_$storr (iaddr + 4,eb_data_$isym);
	call glpl_$storl (iaddr + 2, fixed (glpl_words (lprtx + 2).left, 18));
	call glpl_$storr (iaddr + 2,lprtx);
	if (slclst ^= lprtx) then goto label_577;
	slclst = iaddr;
	goto label_578;

label_577: 

	call glpl_$storr (fixed (glpl_words (lprtx + 2).left, 18) + 2, iaddr);

label_578: 

	call glpl_$storl (lprtx + 2,iaddr);

label_579: 
	if (brk (1) = icomma) then goto label_575;
	if (brk (1) = islash) then goto label_555; /* parse join */
	goto label_3020; /* next statement */

/* join definition location counters. */

label_593: 
	call getid_;
	search_return = label_594;
	goto label_580;

label_594: 
	if (iaddr = 0) then goto label_597;
	call glpl_$storr (iaddr + 4,eb_data_$idefs);
	call glpl_$storl (iaddr + 2, fixed (glpl_words (lpdefs + 2).left, 18));
	call glpl_$storr (iaddr + 2,lpdefs);
	if (dlclst ^= lpdefs) then goto label_595;
	dlclst = iaddr;
	goto label_596;

label_595: 

	call glpl_$storr (fixed (glpl_words (lpdefs + 2).left, 18) + 2, iaddr);

label_596: 

	call glpl_$storl (lpdefs + 2,iaddr);

label_597: 
	if (brk (1) = icomma) then goto label_593;
	if (brk (1) = islash) then goto label_555; /* parse join */
	goto label_3020; /* next statement */
				/* internal routine to search for a lc on the
				   unjoined location counter list. if found it is
				   disconnected from ulclst and a ptr (iaddr) to
				   it is returned. if not found iaddr = 1; TRUE, and prntu = 1; TRUE. */

label_580: 
	j = ulclst;
	if table_ (iserch, sym (1), junk, fmlcrf, i) = 0 then goto label_583;

label_582: 
	if (j ^= 0) then goto label_584;
label_583:
	prntu = 1;				/* TRUE */
	iaddr = 0;
	goto search_return;

label_584: 
	if j ^= i then goto label_592;

	iaddr = j;
	if (iaddr = ulcend) then ulcend = fixed (glpl_words (iaddr + 2).left, 18);
	if (j ^= ulclst) then goto label_588;
	ulclst = fixed (glpl_words (j + 2).right, 18);
	goto label_590;

label_588: 

	call glpl_$storr (fixed (glpl_words (j + 2).left, 18) + 2, fixed (glpl_words (j + 2).right, 18));

label_590: 

	if fixed (glpl_words (j + 2).right, 18) = 0 then goto search_return;
	call glpl_$storl (fixed (glpl_words (j + 2).right, 18) + 2, fixed (glpl_words (j + 2).left, 18));
	goto search_return;


label_592: 
	j = fixed (glpl_words (j + 2).right, 18);
	goto label_582;

/* even pseudo-operation, force pc to even location. */

label_vector (5):		/* even */
label_600: 
	pc = spc + mod (spc,2);
	iflag = 2;
	goto label_690;

/* odd pseudo-operation, force pc to odd location. */

label_vector (6):		/* odd */
label_630: 
	pc = spc + mod (spc + 1,2);
	iflag = 2;
	goto label_690;

/* eight pseudo-operation, force pc to zero mod eight. */

label_vector (7):		/* eight */
label_660: 
	pc = 8*divide ( (spc + 7),8,26,0);		/* originally ==> pc = 8* ( (spc+7)/8); */
	iflag = 8;
	goto label_690;

/* sixty-four pseudo-operation. set the pc to zero mod 64. */

label_vector (8):		/* sixtyfour */
label_680: 
	pc = 64*divide ( (spc + 63),64,26,0);		/* originally ==> pc = 64* ( (spc+63)/64); */
	iflag = 64;

label_690: 
	oldval = fixed (glpl_words (curlc + 4).left, 18);
	newval = iflag;
	if (oldval = 0) then goto label_699;
	if (mod (newval,oldval) = 0) then goto label_699;
	newval = oldval;
	if (mod (newval,iflag) = 0) then goto label_699;
	newval = oldval*iflag;

label_699: 
	call glpl_$storl (curlc + 4,newval);
	goto label_3010;

/* movdef pseudo-operation. move the definitions to the link segment */

label_vector (11):		/* movdef */
label_755: 
	tmvdef = 1;				/* TRUE */
	tnewobject = 0;				/* Can't move defs in new format. */
	goto label_3010;



/* decor pseudo-operation:  claims that all intructions are compatible with the decor named by its operand */

label_vector (62):             /* decor */
label_decor:
          call getid_;
	operand = substr(addr(sym(1)) -> acc.string,1,bin(addr(sym(1)) -> acc.length,9));
	call system_type_((operand),canonical_operand,(0),code);
	if code ^=0
	    then prntf = 1;
	else do;
		   /* a match is assured in this following lookup routine
		    only if the operand names supplied to alm_table_tool
		    (when it created the "data1" array) are a subset of
		    the canonical strings for system_type_. Alm_table_tool
		    will check for this correspondence for you. */

		   
          	do n = 1 to hbound(data1.decor,1) while(rtrim(canonical_operand) ^= data1.decor(n).name);
          	end;
		decor = data1.decor(n).number;
	     end;

	goto label_3010;


/* error pseudo-operation, sets fatal error flag, causing "Translation failed" message. */

label_vector (63):		/* error */
label_error:
	tfatal = 3;	/* severity 3 error */
	goto label_3010;


/* firstref pseudo-operation, specifies trap procedure on first entry reference. */

label_vector (48):		/* firstref */
label_firstref:
	if tfirstreftrap ^= 0 then prntm = 1;
	tfirstreftrap = 1;
	if varevl_ (ixvrvl, basno, value, admod, b29, iaddr) = 0 then goto label_3120;
	if b29 = 0 then value = lstman_$lnkasn (myblk, value, admod, iaddr);
	first_ref_trap_proc_linkno = value;
	if brk (1) = ilpar then do;
		if varevl_ (ixvrvl, basno, value, admod, b29, iaddr) = 0 then goto label_3120;
		if b29 = 0 then value = lstman_$lnkasn (myblk, value, admod, iaddr);
		first_ref_trap_arg_linkno = value;
		if brk (1) ^= irpar then goto label_3100;
		end;
	else first_ref_trap_arg_linkno = 0;
	goto label_3010;

/* inhibit pseudo-operation, set inhibit mode on or off. */

label_vector (12):		/* inhibit */
label_760: 
	call getid_;
	if ( eb_data_$tsym = 0) then goto label_765;
	if (sym (1) = eb_data_$ion) then goto label_770;
	if (sym (1) = eb_data_$ioff) then goto label_775;
	goto label_3010;


label_765: 
	tinhib = 1 - tinhib;	/* tinhib = ^tinhib */
	goto label_3010;


label_770: 
	tinhib = 1;				/* TRUE */
	goto label_3010;


label_775: 
	tinhib = 0;				/* FALSE */
	goto label_3010;

/* name pseudo-operation, record the name of this segment. */

label_vector (14):		/* name */
label_820: 
	if (mynam ^= 0) then goto label_3100;
	call getid_$getnam;
	if ( eb_data_$tsym = 0) then goto label_3100;
	sthedr_$seg_name = substr (addr (sym (1)) -> acc.string, 1, fixed (addr (sym (1)) -> acc.length, 9));
	goto label_3010;

/* null pseudo-operation, do nothing. */

label_vector (15):		/* null */
label_850: 
	goto label_3010;

/* rem pseudo-operation, same as null, if there was a label on the statement */

label_vector (16):		/* rem */
label_870: 
	if label_flag then goto label_850;
	call inputs_$next_statement;
	goto label_200;


/* symbol defining pseudo-operations. */

/* basref pseudo-operation, define external symbols. */


label_vector (17):		/* basref */
label_900: 
	if ( eb_data_$tsym = 0) then goto label_910;
	if (table_ (iserch,sym (1),value,clbas,junk) ^= 0) then goto label_915;
	do i = 1 to 8;				/* To label_905 */
	     if (sym (1) ^= symbas (i)) then goto label_905;
	     value = i-1;
	     goto label_915;

label_905:     
	end;					/* the do-group */
	if (table_ (iserch,sym (1),basno,clint,junk) ^= 0) then goto label_915;
	goto label_3130;


label_910: 
	if (varevl_ (invrvp,basno,value,admod,b29,iaddr) = 0) then goto label_3120;
	if (iaddr ^= 0) then goto label_3300;


label_915: 
	link = utils_$exadrs (value,0);
	type = 2;
	class = fbasrf;

/* re-entry from segref pseudo-operation. */

label_920: 
	call getid_;
	xnlnk = lstman_$namasn (sym (1));

label_930: 
	ptrcal = 0;
	ptrarg = 0;
	trplnk = 0;
	tderr = 0;				/* FALSE */
	if (brk (1) ^= ilpar) then goto label_970;
	if (varevl_ (ixvrvl,basno,ptrcal,admod,b29,iaddr) ^= 0) then goto label_935;
	if (tprot = 1 & b29 = 0) then tvlth = tvlth + 1;
	tderr = 1;				/* TRUE */
	goto label_945;

label_935: 
	if (b29 ^= 0) then goto label_945;
	if (tprot = 1 ) then goto label_940;
	ptrcal = lstman_$lnkasn (myblk,ptrcal,admod,iaddr);
	goto label_945;

label_940: 

	tvlth = tvlth + 1;
	tderr = 1;				/* TRUE */

label_945: 
	if (brk (1) ^= ilpar) then goto label_960;
	if (varevl_ (ixvrvl,basno,ptrarg,admod,b29,iaddr) ^= 0) then goto label_950;
	tderr = 1;				/* TRUE */
	goto label_955;

label_950: 

	if (b29 = 0) then ptrarg = lstman_$lnkasn (myblk,ptrarg,admod,iaddr);


label_955: 
	if (brk (1) = irpar) then call inputs_$next;


label_960: 
	if (brk (1) = irpar) then goto label_965;
	tderr = 1;				/* TRUE */
	goto label_980;


label_965: 
	call inputs_$next;
	if (tderr = 1) then goto label_980;
	trplnk = lstman_$trpasn (ptrcal,ptrarg);

label_970: 
	junk = table_ (iassgn, fixed (glpl_words (xnlnk).left, 18), lstman_$blkasn (type, link, xnlnk, trplnk),
							class, junk);


label_980: 
	if (brk (1) = icomma) then goto label_920;
	goto label_3010;

/* bool pseudo-operation, assign boolean equivalence to symbol. */

label_vector (18):		/* bool */
label_1000: 
	call getid_$setid (symlnk);
	if (brk (1) ^= icomma | symlnk = 0) then goto label_3100;
	if (varevl_ (ibvrvl,basno,value,admod,b29,iaddr) = 0) then goto label_3120;
	if (iaddr ^= 0) then goto label_3300;
	junk = table_ (iassgn,symlnk,value,fbolrf,junk);
	goto label_3010;

/* equ pseudo-operation, assign arithmetic equivalence to symbol. */

label_vector (19):		/* equ */
label_1100: 
	call getid_$setid (symlnk);
	if (brk (1) ^= icomma | symlnk = 0) then goto label_3100;

label_1110: 
	if (varevl_ (invrvl,basno,value,admod,b29,iaddr) = 0) then goto label_3120;
	class = flocrf;
	if (iaddr = 0) then class = fequrf;
	junk = table_ (iassgn,symlnk,value,class,iaddr);
	goto label_3010;

/* link pseudo-operation, define link number of external reference. */

label_vector (20):		/* link */
label_1200: 
	call getid_$setid (symlnk);
	if (brk (1) ^= icomma | symlnk = 0) then goto label_3100;
	if (varevl_ (ixvrvl,basno,value,admod,b29,iaddr) = 0) then goto label_3120;
	if (b29 = 0) then value = lstman_$lnkasn (myblk,value,admod,iaddr);
	junk = table_ (iassgn,symlnk,value,flocrf,lpsect);
	goto label_3010;

		/* associate init info with link */
label_vector (65):		/* init_link */
	goto label_3010;	/* skip in pass1 */

/* set pseudo-operation, assign resettable_ equ type symbol. */

label_vector (21):		/* set */
label_1250: 
	call getid_$setid (symlnk);
	if (brk (1) ^= icomma | symlnk = 0) then goto label_3100;
	if (varevl_ (invrvl,basno,value,admod,b29,iaddr) = 0) then goto label_3120;
	if (iaddr ^= 0) then goto label_3300;
	junk = table_ (iassgn,symlnk,value,fsetrf,junk);
	goto label_3010;

/* segref pseudo-operation, define external symbols with pointers. */

label_vector (22):		/* segref */
label_1300: 
	call getid_$getnam;
	if (brk (1) ^= icomma) then goto label_3100;
	class = fsegrf;
	if (sym (1) ^= eb_data_$atext (1) | sym (2) ^= eb_data_$atext (2)) then goto label_1310;
	type = 5;
	link = 0;
	goto label_920;

label_1310: 
	if (sym (1) ^= eb_data_$alink (1) | sym (2) ^= eb_data_$alink (2)) then goto label_1320;
	type = 5;
	link = 1;
	goto label_920;

label_1320: 
	if (sym (1) ^= eb_data_$asym (1) | sym (2) ^= eb_data_$asym (2)) then goto label_1330;
	type = 5;
	link = 2;
	goto label_920;

label_1330: 
	if (sym (1) ^= eb_data_$astat (1) | sym (2) ^= eb_data_$astat (2)) then goto label_1340;
	type = 5;
	link = 4;
	goto label_920;

label_1340: 
	if (sym (1) ^= eb_data_$asys (1) | sym (2) ^= eb_data_$asys (2)) then goto label_1350;
	type = 5;
	link = 5;
	goto label_920;

label_1350: 
	if (sym (1) ^= eb_data_$aheap (1) | sym (2) ^= eb_data_$aheap (2)) then goto label_1360;
	type = 5;
	link = 6;
	goto label_920;

label_1360: 
	type = 4;
	link = lstman_$namasn (sym (1));
	goto label_920;

/* temp and tempd pseudo-operations, define symbols in stack. */

label_vector (23):		/* temp */
label_1400: 
	mul = 1;
	goto label_1510;


label_vector (24):		/* tempd */
label_1500: 
	mul = 2;
	stkc = stkc + mod (stkc,2);
	goto label_1510;


label_vector (25):		/* temp8 */
label_1505: 
	mul = 8;
	stkc = 8*divide ( (stkc + 7),8,26,0);		/* originally ==> stkc = 8* ( (stkc + 7)/8); */


label_1510: 
	call getid_$setid (symlnk);
	if (symlnk ^= 0) then goto label_1520;
	prntf = 1;				/* TRUE */
	goto label_1550;

label_1520: 
	value = 1;
	if (brk (1) ^= ilpar) then goto label_1540;
	if (varevl_ (invrvp,basno,value,admod,b29,iaddr) = 0) then goto label_1525;
	if (iaddr = 0) then goto label_1530;
	prntr = 1;				/* TRUE */

label_1525: 
	prnts = 1;				/* TRUE */
	goto label_1550;

label_1530: 
	if (brk (1) = irpar) then call inputs_$next;

label_1540: 
	if (table_ (iassgn,symlnk,stkc,fstkrf,junk) = 0) then prnts = 1; /* TRUE */
	stkc = stkc + value*mul;

label_1550: 
	if (brk (1) = icomma) then goto label_1510;
	goto label_3010;



/* generative class of pseudo-operations. */

/* acc and aci pseudo-operations, ascii code generators. */
/* also bci pseudo-operation to generate 6-bit codes. */

label_vector (26):		/* acc */
label_1600: 
	n = ascevl_$accevl (rslts (1));
	goto label_1710;

label_vector (27):		/* aci */
label_1700: 
	n = ascevl_$acievl (rslts (1));
	goto label_1710;


label_vector (13):		/* bci */
label_bci:
	n = ascevl_$bcdevl (rslts (1));
	go to label_1710;


label_vector (59):		/* ac4 */
label_ac4:
	n = ascevl_$ac4evl (rslts (1));


label_1710: 
	pc = pc + n;
	goto label_3010;

/* dec pseudo-operation, integer, fixed, and floating point. */

label_vector (28):		/* dec */
label_1800: 
	n = decevl_ (rslts (1),type);
	if (n >= 2) then pc = pc + mod (pc,2);
	pc = pc + n;
	if (brk (1) = icomma) then goto label_1800;
						/* verify the break character for dec pseudo-op */
	goto label_1920;

/* dec_unal pseudo-operation, integer, fixed, and floating point unaligned. */

label_vector (66):		/* dec_unal */
label_1801:
	n = decevl_ (rslts (1),type);
	pc = pc + n;
	if (brk (1) = icomma) then goto label_1801;
						/* verify the break character for dec pseudo-op */
	goto label_1920;

/* oct pseudo-operation, octal number generator. */

label_vector (29):		/* oct */
label_1900: 
	n = octevl_ (rslts (1));
	if (n >= 2) then pc = pc + mod (pc,2);
	pc = pc + n;
	if (brk (1) = icomma) then goto label_1900;
						/* verify the break characters */
	goto label_1920;

/* oct_unal pseudo-operation, unaligned octal number generator. */

label_vector (67):		/* oct_unal */
label_1901: 
	n = octevl_ (rslts (1));
	pc = pc + n;
	if (brk (1) = icomma) then goto label_1901;
						/* verify that the break characters for dec and oct
						   are legitimate at this point */

label_1920: 
	if ( brk (1) = inl | brk (1) = isp ) then goto label_3010;
	goto label_3100;

/* vfd pseudo-operation, variable field data generator. */

label_vector (30):		/* vfd */
label_2000: 
	pc = pc + vfdevl_$vfdcnt (rslts (1),flags);
	goto label_3010;

/* mod pseudo-operation. force location counter mod expression. */

label_vector (31):		/* mod */
label_2020: 
	call getid_;
	junk =  expevl_ (0,value,iaddr);			/* 0 ==> FALSE */
	if (iaddr ^= 0) then prntr = 1;		/* TRUE */
	iflag = value;
	pc = value*divide ( (spc + value-1),value,26,0);	/* originally ==> pc = value* ( (spc + value-1)/value); */
	goto label_690;


/* storage allocating pseudo-operations. */

/* bfs pseudo-operation, block followed by symbol. */

label_vector (32):		/* bfs */
label_2100: 
	tbss = 0;					/* FALSE */
	goto label_2210;

/* bss pseudo-operation, block started by symbol. */

label_vector (33):		/* bss */
label_2200: 
	tbss = 1;					/* TRUE */

label_2210: 
	call getid_$setid (symlnk);
	if (brk (1) ^= icomma) then goto label_3100;
	if (varevl_ (invrvl,basno,value,admod,b29,iaddr) = 0) then goto label_3110;
	if (iaddr = 0) then goto label_2220;
	prntr = 1;				/* TRUE */
	goto label_3120;

label_2220: 
	pc = pc + value;
	if (b29 ^= 0 ) then goto label_3100;
	if symlnk = 0 then goto label_3010;		/* allow bss ,exp with no symbol specified */
	value = pc;
	if (tbss = 1) then value = spc;
	junk = table_ (iassgn,symlnk,value,flocrf,curlc);
	goto label_3010;

/* zero pseudo-operation, ignore in pass1. */

label_vector (34):		/* zero */
label_2350: 
	pc = spc + 1;
	goto label_3010;

/* its and itb pseudo-operations, set pc even, and add two. */

label_vector (35):		/* itb */
label_2400: 


label_vector (36):		/* its */
label_2450: 
	pc = (spc + mod (spc,2)) + 2;

/* correction here 3/12/69 */
	iflag = 2;
	goto label_690;


/* subroutine linkage pseudo-operations. */

/* call pseudo-operation, call subroutine with args and returns. */

label_vector (37):		/* call */
label_2500: 
	junk = varevl_ (ixvrvl,basno,value,admod,b29,iaddr);
	prntr = 0;
	if (tprot = 1 & b29 ^= 0) then goto label_2510;
	if tnewcall ^= 0 then pc = spc + eb_data_$new_nslcal;
	else pc = spc + eb_data_$nslcal;
	goto label_3010;

label_2510: 
	junk = lstman_$outasn (spc,spc + eb_data_$nmxcal,curlc);
	tcall = 1;				/* TRUE */
	tstsw (1) = 1;				/* TRUE */
	tvlth = tvlth + 1;
	pc = spc + eb_data_$nmxcal + eb_data_$nmxclb;
	goto label_3010;

/* short_call pseudo-operation, call without save. */

label_vector (51):		/* short_call */
label_short_call:
	pc = spc + eb_data_$short_nslcal;
	goto label_3010;

/* entry pseudo-operation, count symbols in pass1. */

label_vector (38):		/* entry */
label_2600: 
	call getid_;
	if ( eb_data_$tsym = 0) then goto label_3100;
	tvlth = tvlth + 1;
	if (brk (1) = icomma) then goto label_2600;
						/* this entry statement is processed. */
	goto label_3010;

/* ext_entry pseudo_operation Usage: ext_entry elabel,stackframe_size,clabel,dlabel,function */

label_vector (64):
label_2610:
/* first arg, entrypoint label */
	call getid_;
	if eb_data_$tsym = 0 then goto label_3100;	/* field error */

	/* remember amount of stack space currently allocated */
	i = stkclst;
	stkclst = glpl_$setblk(0, 1);
	call glpl_$slwrd(i, stkc, stkclst);

	stkc = 64;	/* initial ext_entry stackframe size */
	ext_entry_count = ext_entry_count + 1;
	tvlth = tvlth + 1;
	pc = pc + 7;	/* leave room for entry seq and entry code */
	if brk(1) ^= icomma then goto label_3010;
/* second arg stacksize */
	junk = varevl_(invrvl, basno, i, admod, b29, iaddr);
	if brk(1) ^= icomma then goto label_3010;
/* third arg code_sequence label */
	call getid_;
	remember_sym = sym;
	if brk(1) = icomma then do;
/* fourth argument dlabel */
	     call getid_;
	     if sym(1) ^= 0 then pc = pc + 1;	     /* has descriptors */
	  end;
	/* set value of optional internal label */
	if remember_sym(1) > 0 then junk = table_(iassgn, remember_sym(1), pc-6, flocrf, curlc);
	goto label_3010;    /* done */

/* return pseudo-operation, return control to caller. */

label_vector (39):		/* return */
label_2700: 
	if tnewcall ^= 0 then pc = spc + eb_data_$new_nretls;
	else pc = spc + eb_data_$nretls;
	call inputs_$nxtnb;
	if (brk (1) ^= iques) then goto label_3010;
	pc = spc + eb_data_$nertls;
	if (labarg ^= 0) then goto label_3010;
	stkc = stkc + mod (stkc,2);
	labarg = stkc;
	stkc = stkc + 4;
	goto label_3010;

/* short_return pseudo-operation, return from entry that did no save. */

label_vector (46):		/* short_return */
label_short_return:
	if tnewcall = 0 then prnto = 1;
	pc = spc + eb_data_$short_nretls;
	goto label_3010;

/* save pseudo-operation, stack setup for subroutine call. */

label_vector (41):		/* save/push */
label_2800: 
	if tnewcall ^= 0 then pc = spc + eb_data_$new_nslsav;
	else pc = spc + eb_data_$nslsav;
	if (tprot = 1) then pc = pc + eb_data_$nmxsav;
	goto label_3010;

/* segdef pseudo-operation, ignored in pass1. */

label_vector (42):		/* segdef */
label_2900: 
	goto label_3010;

/* setlp pseudo-op.... ignored in pass1. */

label_vector (45):		/* setlp */
label_2970: 
	pc = pc + 1;
	goto label_3010;

/* getlp pseudo-operation, calculate linkage pointer using lot (new call/save/return). */

label_vector (49):		/* getlp */
label_getlp:
	pc = spc + eb_data_$new_ngetlp;
	goto label_3010;

label_vector (58):
label_entrybound:
	eb_data_$entrybound_bit = "1"b;
	goto label_3010;

label_vector (9):		/* dup */
label_dup:
	if dup_ptr ^= null () then go to label_3120;
	if varevl_ (invrvl, basno, value, admod, b29, iaddr) = 0 then go to label_3120;
	if iaddr ^= 0 then go to label_3300;
	if value <= 0 then go to label_3120;
	dup_count = value - 1;
	call inputs_$next_statement;
	call inputs_$get_ptr (dup_ptr, dup_start, junk, end_statement_flag);
	go to label_3030;

label_vector (10):		/* dupend */
label_dupend:
	if dup_ptr = null () then go to label_3120;
	call inputs_$get_ptr (temp_ptr, i, j, end_statement_flag);
	if temp_ptr ^= dup_ptr then go to label_3100;
	i = begin_line;			/* Really want beginning of line. */
	call inputs_$next_statement;
	if dup_count > 0 then
	     call alm_include_file_$insert (addr (dup_string (dup_start)), i - dup_start, dup_count);
	dup_ptr = null ();
	go to label_3020;

label_vector (61):
label_ppstatic:
	eb_data_$per_process_static_sw = 1;
	go to label_3020;

label_vector (68):	/* block */
label_vector (69):	/* end_block */
label_vector (70):	/* enum */
label_vector (71):	/* end_enum */
label_vector (72):	/* source */
label_vector (73):	/* end_source */
label_vector (74):	/* statement */
label_vector (75):	/* structure */
label_vector (76):	/* end_structure */
label_vector (77):	/* symbol */
label_vector (78):	/* union */
label_vector (79):	/* end_union */

	goto label_3010;	/* ignored in pass1_ */


label_vector (60):
label_macro:
	call getid_;
	if eb_data_$tsym = 0 then goto label_3100;
	call oplook_$redefine;
	call inputs_$next_statement;
	call mexp_$define_macro (substr (addr (sym (1)) -> acc.string, 1, bin (addr (sym (1)) -> acc.length, 9)));
	go to label_3030;

label_vector (40):
label_maclist:
	go to label_3020;


/* INSTRUCTION PROCESSING BEGINS HERE. */

label_vector (52):		/* rpt, rpd, rpl */
label_repeat:
label_vector (53):		/* awd, swd, abd, sbd, etc. */
label_eis_single:
label_vector (54):		/* mvn, cmpb, ad2d, etc. */
label_eis_multiple:
label_vector (55):		/* desc9a, desc6a, desc4a */
label_eis_desca:
label_vector (56):		/* descb */
label_eis_descb:
label_vector (57):		/* desc9ts, desc4ls, etc. */
label_eis_descn:
label_vector (43):		/* eax, canx, etc. */
label_get_index:
label_vector (44):		/* eap, sprp, etc. */
label_get_base:

/* normal instructions. */

label_vector (0):		/* Normal instruction. */
label_3000: 
	pc = spc + 1;
						/* pseudo-operation re-entry to reset u flag. */

label_3010: 
	prntu = 0;				/* FALSE */
						/* pseudo-operation re-entry with u flag not reset. */

label_3020: 
	call inputs_$next_statement;

label_3030:
	pcblk (1) = utils_$ls (pc,18);
	call utils_$pckflg (pcblk (2));
	pcblk (3) = utils_$ls (curlc,18);
	link = glpl_$setblk (pcblk (1),3);
	ndpcls -> word.right = addr (link) -> word.right;
	ndpcls = ptr (eb_data_$lavptr,link);

	goto label_200;


/* error return for pseudo-operations. */

/* field (f) error. */

label_3100: 
	prntf = 1;				/* TRUE */
	goto label_3010;

/* phase (p) error. */

label_3110: 
	prntp = 1;				/* TRUE */
	goto label_3010;

/* symbol (s) definition error. */

label_3120: 
	prnts = 1;				/* TRUE */
	goto label_3010;

/* undefined (u) symbol error. */

label_3130: 
	prntu = 1;				/* TRUE */
	goto label_3020;	/* next statement */


/* re-entry for undefined pseudo-operations. */

label_3200: 
	prnto = 1;				/* TRUE */
	goto label_3010;

/* re-entry for relocation (r) error. */

label_3300: 
	prntr = 1;				/* TRUE */
	goto label_3010;

     end pass1_;
