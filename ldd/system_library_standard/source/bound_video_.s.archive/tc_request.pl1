/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(81-06-01,Margulies), approve(), audit(), install():
     There is a temporary crock in place here, for handling
     error_table_$bigarg returned from hcs_$tty_write_whole_string. See the
     call to it for details IT MUST BE REMOVED when hardcore is fixed.
  2) change(82-05-01,York), approve(), audit(), install():
     There is another temporary crock in the insert_text procedure, relating
     to the two different types of insert-char sequences supported by various
     terminals.  See the comment in place for more Info.
     
     Change the pad character from DEL to NUL (or high to low for you PL/I
     builtin fans).  This fixes padding problems with the Heath/Zenith-19,
     but probably breaks some other terminal...
  3) change(82-05-01,York), approve(), audit(), install():
     Initialize cost_of_cha_cha in the position_cursor optimzation routine,
     avoiding weird usuless motion.
  4) change(82-07-16,York), approve(), audit(), install():
     Position the cursor correctly and send the correct output to the terminal
     when simulating insert-chars on terminals lacking the capability.
  5) change(82-07-16,York), approve(), audit(), install():
     Insert a crock in insert_text to keep the screen image updated when
     doing insert-chars operations on the Teleray 1061 and related terminals.
  6) change(82-07-16,York), approve(), audit(), install():
     Fix the delete_chars routine so that it does not try to do an actual
     delete_chars terminal operation on terminals that don't have it.
  7) change(82-07-30,York), approve(), audit(), install():
     Buffer all output to the terminal generated by one call to tc_request
     and send it in one call to hcs_
  8) change(82-08-12,York), approve(), audit(), install():
     Extend this buffering to work across calls to tc_request, and only send
     to ring 0 when the buffer fills or an input request is received.
  9) change(82-08-30,York), approve(), audit(), install():
     Dump the output buffer before raw output is sent to ring 0 and before
     input is re-echoed, and to send raw output via tty_write_whole_string.
 10) change(82-09-10,York), approve(), audit(), install():
     Add the send_buffered_output entrypoint as an external interface to
     write_global_buffer.  This is used by the send_buffered_output control
     order.
 11) change(82-09-20,York), approve(), audit(), install():
     Remove the send_buffered_output entrypoint, since a call to
     window_$sync does the right thing. Also changed to pass
     tc_input$check_echnego the request_ptr as an argument.
 12) change(83-01-01,York), approve(), audit(), install():
     Not position the cursor on calls that don't modify the screen
     (e.g. unechoed reads).
 13) change(83-09-07,Rochlis), approve(), audit(), install():
     Remove  the special casing of error_table_$bigarg in the
     hcs_$tty_write_whole_string call. Now we will get a wakeup and bigarg
     means  we really have problems.
 14) change(83-10-09,Rochlis), approve(), audit(), install():
     Support partial screen width windows.
 15) change(85-09-14,Rochlis), approve(86-05-15,MCR7276),
     audit(86-05-28,Gilcrease), install(86-06-04,MR12.0-1070):
     Fix unitialized variable bug in position cursor.  Goodbye to the insert
     mode bug, thanks to Allen Grider.
 16) change(86-05-21,LJAdams), approve(86-05-27,MCR7428),
     audit(86-05-28,Gilcrease), install(86-06-04,MR12.0-1070):
     The "encode" procedure has an alignment problem.  value is declared as
     fixed bin which equates to 36 bits;  bits is declared as (6) bit (3)
     unaligned which equates to 18 bits.  When an unspec (value) = unspec
     (bits) is done a stringsize condition occurs and only the upper half of
     the word was being stored.  Solution change the declaration of bits to:
     dcl bits (-5:6) bit (3) unaligned.
 17) change(86-11-11,LJAdams), approve(86-11-11,MCR7485),
     audit(86-12-16,Margolin), install(87-01-06,MR12.0-1255):
     Modified to support MOWSE.
 18) change(86-11-26,LJAdams), approve(86-11-26,MCR7584),
     audit(86-12-16,Margolin), install(87-01-06,MR12.0-1255):
     Initial DSA coding has been maintained in a non-executable form.
                                                   END HISTORY COMMENTS */

/* Terminal Control
   Request Processing level

   This program is the interpreter of terminal operations.
   For input side (save read status) we position the cursor, and pass
   the batton to tc_input. All else is done here, including the grokking
   of the ttt video tables. */

/* format: style2,linecom,^indnoniterdo,indcomtxt,^inditerdo,dclind5,idind25 */

tc_request:
     procedure (TC_data_ptr, Request_ptr, Last_column, Code);
	go to do_output;

	declare (
	        (TC_data_ptr, Request_ptr)
				   pointer,
	        Last_column		   fixed bin,
	        Code		   fixed bin (35)
	        )			   parameter;


	declare hcs_$tty_write_whole_string
				   entry (fixed bin, character (*), bit (1) aligned, fixed bin (21), fixed bin,
				   fixed bin (35));
	declare hcs_$tty_write	   entry (fixed bin, pointer, fixed bin (21), fixed bin (21), fixed bin (21),
				   fixed bin, fixed bin (35));
	declare ws_tty_$write_whole_string
				   entry (ptr, char (*), bit (1), fixed bin (21), fixed bin, fixed bin (35));
	declare ws_tty_$write	   entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (21), fixed bin,
				   fixed bin (35));
	declare dsa_tty_$write_whole_string
				   entry (fixed bin (35), character (*), bit (1) aligned, fixed bin (21),
				   fixed bin, fixed bin (35));
	declare dsa_tty_$write	   entry (fixed bin (35), pointer, fixed bin (21), fixed bin (21), fixed bin (21),
				   fixed bin, fixed bin (35));

	declare tc_screen$operation	   entry (pointer, fixed bin, fixed bin, fixed bin, fixed bin);
	declare tc_screen$get_in_line	   entry (pointer, fixed bin, fixed bin, character (*));
	declare tc_screen$text	   entry (pointer, fixed bin, fixed bin, bit (1) aligned, character (*));
	declare tc_screen$is_region_clear
				   entry (pointer, fixed binary, fixed binary, fixed binary, fixed binary)
				   returns (bit (1) aligned);

	declare tc_input		   entry (pointer, pointer, fixed bin (35));
	declare tc_disconnect$check	   entry (pointer, fixed bin (35));
	declare tc_input$check_echnego   entry (pointer, pointer);
	declare tc_error		   entry (fixed binary (35), character (*));
	declare tc_block		   entry (pointer, pointer, bit (36) aligned);

	declare (
	        video_et_$capability_lacking,
	        video_et_$tc_illegal_request,
	        video_et_$tc_cannot_position,
	        video_et_$tc_missing_operation,
	        video_et_$tc_tty_error
	        )			   fixed bin (35) ext static;

	declare OMEGA		   fixed bin init (100000) internal static options (constant);
						/* compiler limitation of 256 chars, should be bigger. */
	declare MANY_SPACES		   char (256) static options (constant) init ("");

	declare last_column		   fixed bin;
	declare (request_row, request_col)
				   fixed bin;
	declare request_row_count	   fixed bin;
	declare request_column_count	   fixed bin;
	declare request_string_ptr	   pointer;
	declare request_string_length	   fixed bin (21);
	declare request_count	   fixed bin;
	declare tty_state		   fixed bin;
	declare save_row		   character (200); /* pretty big terminal */
	declare code		   fixed bin (35);

	declare (addr, bin, byte, divide, hbound, lbound, length, min, rank, rtrim, substr, unspec, verify)
				   builtin;

	declare 1 new_state		   aligned based,
		2 pay_attention	   aligned,	/* use these to see those below */
		  3 insert	   bit (1) unaligned,
						/* flags.insert_mode is useful */
		  3 cursor	   bit (1) unaligned,
						/* flags.cursor_valid */
		  3 position	   bit (1) unaligned,
						/* cursor_position */
		2 flags		   aligned,
		  3 insert_mode	   bit (1) unaligned,
		  3 cursor_valid	   bit (1) unaligned,
		2 cursor_position	   aligned,
		  3 row		   fixed bin,
		  3 col		   fixed bin;

init:
     entry (TC_data_ptr);

	tc_data_ptr = TC_data_ptr;
	state.pending.count = 0;
	state.cursor_valid = "0"b;
	state.current_mark = 0;
	state.last_mark_back = 0;
	tc_data.global_buffer_index = 0;		/* the buffer length should be based on line speed or something */
						/* this won't be so important after tty_write_whole_string is
						   changed to send a wakeup when space is available. */
	tc_data.global_buffer_limit = 256;
	return;

shut:
     entry (TC_data_ptr, Code);

/* Since we are usually in tc_request on behalf of some window, we need
   a fabricated window operation structure for tc_block to play with. */

/*
   The following code commented out since it breaks reconnection.
   Fix it to not cause the terminal_control_disconnection_ signal if
   we are shutting.  Removed for 10.1 installation deadline.

   dcl  1 dummy_request_header	aligned like request_header;

   Code = 0;
   tc_data_ptr = TC_data_ptr;
   request_ptr = addr (dummy_request_header);

   dummy_request_header.sentinel = REQUEST_SENTINEL;
   dummy_request_header.request_id = 0;
   dummy_request_header.window_id = ""b;
   dummy_request_header.operation = 5;

   call write_global_buffer ();
*/
	return;

/* ASSERT: this entrypoint is called MASKED!! */

do_output:
	tc_data_ptr = TC_data_ptr;
	request_ptr = Request_ptr;
	last_column = Last_column;
	ttyvtblp = tc_data.ttt_video_ptr;

	request_header.async_interruption, request_header.this_window = "0"b;

/* The following test is performed to avoid unnecessary external
   calls to tc_input for each output operation.  Modularity has been
   sacrificed in the name of efficiency. */

	if state.echnego_outstanding | (state.pending.count > 0)
	then call tc_input$check_echnego (tc_data_ptr, request_ptr);

	if tc_data.pending.count > 0
	then begin;				/* Note window hits */
		declare wx		   fixed bin;
		do wx = 1 to tc_data.pending.count;
		     if request_header.window_id = tc_data.state.pending.blocked_windows (wx)
		     then state_async_same_window (wx) = "1"b;
		end;
	     end;

	tc_data.change_pclock = tc_data.change_pclock + 1;

	if request_header.operation < lbound (REQUEST, 1) | request_header.operation > hbound (REQUEST, 1)
	then do;
REQUEST (5):
	     call tc_error (video_et_$tc_illegal_request, "");
	     go to request_done;
	end;

/* Come Here if something happened while we blocked and
   we have to try again */


recompute_operation_here:				/* Make automatic copies of coords for faster procedure calls.
						   This means that any routine that wants to set the coord values
						   had better be called with request_header.row and .col, not
						   the copies. */
	request_row = request_header.row;
	request_col = request_header.col;

	go to REQUEST (request_header.operation);

/* We should check for insert-mode on certain echoed-input calls,
   but that will be a limitation for now */
REQUEST (9):					/* GET CHARS */
	call position_cursor (request_row, request_col);

/* Don't position the cursor for calls that will not echo.  This makes
   "raw" input work way back up at the iox_ level. */
REQUEST (16):					/* READ_ONE */
REQUEST (10):					/* GET CHARS NO ECHO */
REQUEST (13):					/* READ STATUS */
	call write_global_buffer;			/* Must do this before input */
	call tc_input (tc_data_ptr, request_ptr, code);	/* do input req */
	go to request_done;


REQUEST (11):					/* WRITE SYNC READ */
	request_string_ptr = request_read.prompt_ptr;
	request_string_length = request_read.prompt_length;

	call overwrite_text (request_row, request_col, request_string_ptr, request_string_length);

	call write_global_buffer;			/* must dump output before input */
	call tc_input (tc_data_ptr, request_ptr, code);

	go to request_done;
REQUEST (1):					/* POSITION CURSOR */
	call position_cursor (request_row, request_col);
	go to request_done;


REQUEST (2):					/* CLEAR REGION */
	request_row_count = request_clear_region.rows;
	request_column_count = request_clear_region.columns;

	call clear_region (request_row, request_col, request_row_count, request_column_count);
	go to request_done;

REQUEST (4):					/* CLEAR SCREEN NO OPT */
	call clear_screen;
	go to request_done;

REQUEST (3):					/* INSERT_TEXT */
	request_string_ptr = request_text.text_ptr;
	request_string_length = request_text.text_length;

	call insert_text (request_row, request_col, request_string_ptr, request_string_length, last_column);
	go to request_done;

REQUEST (14):					/* OVERWRITE_TEXT */
	request_string_ptr = request_text.text_ptr;
	request_string_length = request_text.text_length;

	call overwrite_text (request_row, request_col, request_string_ptr, request_string_length);
	go to request_done;

REQUEST (15):					/* RAW TEXT */
	call write_raw_text (request_row, request_col, request_text_string);
	go to request_done;

REQUEST (6):					/* DELETE CHARS */
	call delete_chars (request_row, request_col, request_delete_chars.count, last_column);
	go to request_done;

REQUEST (7):					/* SCROLL REGION */
	request_row = request_scroll_region.start_line;
	request_row_count = request_scroll_region.n_lines;
	request_count = request_scroll_region.distance;

	call scroll_region (request_scroll_region.start_line, request_scroll_region.n_lines,
	     request_scroll_region.distance);
	go to request_done;

REQUEST (8):					/* BELL */
	call bell (request_row, request_col);
	go to request_done;

REQUEST (12):					/* GET POSITION */
	request_header.row = state.row;
	request_header.col = state.col;		/* output */
	go to request_done;


/* Here begins the hard work */

position_cursor:
     procedure (a_row, a_col);

	declare (a_row, a_col)	   fixed bin;

	declare (row, col)		   fixed bin;
	declare (least_cost, cost_of_abs, cost_of_home, cost_of_cha_cha, cost_of_home_cha_cha)
				   fixed bin;
	declare 1 ns		   aligned like new_state;

/* Put the cursor THERE, in absolute screen coords */

	row = a_row;
	col = a_col;

	unspec (ns) = ""b;

	if state.cursor_valid
	then if state.cursor_position.row = row
	     then if state.cursor_position.col = col
		then return;

/* Perhaps we are heading for home? */
/* DUMP ASSUMPTION: HOME is cheaper than anything else. Boy do we need
   an expense metric. Perhaps weights in the ttt? */

	ns.pay_attention.position, ns.pay_attention.cursor = "1"b;
	ns.row = row;
	ns.col = col;
	ns.cursor_valid = "1"b;

	if (row = 1) & (col = 1) & available (HOME)
	then do;					/* Lassie come ... */
	     call do_operation (HOME, 1, 1, 1, ns);
	     return;
	end;

/* What follows is a fair, and no better, chooser of method to do
   an arbitrary position. The faster the terminal, the less important
   it is to get the least characters. Instead, CPU time should be
   held down. This approach is middling for both costs */


/* ASSUME: we can at least do cha-cha (up down right left) or abs pos */


	cost_of_abs = cost (ABS_POS);			/* n characters */
	cost_of_home = cost (HOME);			/* OMEGA if not available  */

	cost_of_cha_cha = OMEGA;			/* don't want to do this if we can avoid it */

	cost_of_home_cha_cha = cost_of_home + cost_repeat (CURSOR_DOWN, row - 1) + cost_repeat (CURSOR_RIGHT, col - 1);

	if state.cursor_valid
	then do;					/* we can only compute a real cha-cha cost if the cursor is valid */
	     cost_of_cha_cha = 0;
	     if row > state.row
	     then cost_of_cha_cha = cost_of_cha_cha + cost_repeat (CURSOR_DOWN, (row - state.row));
	     else if row < state.row
	     then cost_of_cha_cha = cost_of_cha_cha + cost_repeat (CURSOR_UP, (state.row - row));


	     if col > state.col
	     then cost_of_cha_cha = cost_of_cha_cha + cost_repeat (CURSOR_RIGHT, (col - state.col));
	     else if col < state.col
	     then cost_of_cha_cha = cost_of_cha_cha + cost_repeat (CURSOR_LEFT, (state.col - col));
	end;

/* cost of cha cha is less than OMEGA iff the required functions were there */

	least_cost = min (cost_of_abs, cost_of_cha_cha, cost_of_home_cha_cha);
	if least_cost >= OMEGA
	then call tc_error (video_et_$tc_cannot_position, "");

	if cost_of_abs = least_cost
	then call do_operation (ABS_POS, row, col, (1), ns);
						/* ns is already correct for atomic position call */

	else if cost_of_home_cha_cha = least_cost
	then do;
	     ns.row, ns.col = 1;			/* state reflects home call */
	     call do_operation (HOME, 1, 1, (1), ns);
	     if row > 1
	     then do;
		ns.row = row;			/* now we do just the row */
		call do_operation (CURSOR_DOWN, (0), (0), row - 1, ns);
	     end;
	     if col > 1
	     then do;
		ns.col = col;			/* and the col here ... ns.row is correct */
		call do_operation (CURSOR_RIGHT, (0), (0), col - 1, ns);
	     end;
	end;

	else do;					/* cha-cha from current cursor position */
	     ns.cursor_position = state.cursor_position;	/* wherever we are */
	     if row > state.row
	     then do;
		ns.row = row;			/* twiddle row */
		call do_operation (CURSOR_DOWN, (0), (0), row - state.row, ns);
	     end;
	     else if row < state.row
	     then do;
		ns.row = row;
		call do_operation (CURSOR_UP, (0), (0), state.row - row, ns);
	     end;
	     if col > state.col
	     then do;
		ns.col = col;
		call do_operation (CURSOR_RIGHT, (0), (0), col - state.col, ns);
	     end;
	     else if state.col > col
	     then do;
		ns.col = col;
		call do_operation (CURSOR_LEFT, (0), (0), state.col - col, ns);
	     end;
	end;
     end position_cursor;


clear_screen:
     procedure;
	call clear_region_noopt (1, 1, tc_data.terminal.rows, tc_data.terminal.columns);
     end clear_screen;

clear_region:
     procedure (a_row, a_col, a_n_rows, a_n_cols);
	declare (a_row, a_col, a_n_rows, a_n_cols)
				   fixed bin;
	declare (row, col, n_rows, n_cols)
				   fixed bin;
	declare i			   fixed bin;
	declare 1 ns		   aligned like new_state;
	declare noopt		   bit (1) aligned;

	noopt = "0"b;
	go to opt_common;

clear_region_noopt:
     entry (a_row, a_col, a_n_rows, a_n_cols);
	noopt = "1"b;

opt_common:
	unspec (ns) = ""b;				/* hopefully, we do nuthin */

/* copy for call efficiency */
	row = a_row;
	col = a_col;
	n_rows = a_n_rows;
	n_cols = a_n_cols;

/* anything to clear? */
	if n_cols = 0
	then do;
	     call position_cursor (row, col);
	     return;
	end;

/* Check for whole screen case. */
	if row = 1 & col = 1 & n_rows = tc_data.rows & n_cols = tc_data.columns
	then if available (CLEAR_SCREEN)
	     then do;
		call do_operation (CLEAR_SCREEN, (0), (0), (1), ns);
		return;
	     end;

/* Check to see if the whole region is already clear. */
	if ^noopt & tc_screen$is_region_clear (tc_data.screen_data_ptr, row, col, n_rows, n_cols)
	then return;

	if (-1 + row + n_rows = tc_data.rows)		/* all the rows from here */
	     & (col = 1)				/* starting in first col */
	     & (n_cols = tc_data.columns)		/* full width */
	then do;					/* EOS */
	     if available (CLEAR_TO_EOS)
	     then do;
		call position_cursor (row, col);	/* hacks state */
		call do_operation (CLEAR_TO_EOS, (0), (0), (1), ns);
		call position_cursor (row, col);
		return;
	     end;
	end;

	if (-1 + col + n_cols = tc_data.columns)	/* Full width */
	     & available (CLEAR_TO_EOL)
	then do;					/* CLEOL assumed better than delete-lines, insert lines */


	     do i = row to row + n_rows - 1;
		if noopt | ^tc_screen$is_region_clear (tc_data.screen_data_ptr, i, col, 1, n_cols)
		then do;
		     call position_cursor (i, col);
		     call do_operation (CLEAR_TO_EOL, (0), (0), (1), ns);
		end;
	     end;
	     call position_cursor (row, col);
	     return;
	end;

/* But if we cant tell easily that CLEOL is correct, we prefer
   i-del-lines */

	if col = 1 & n_cols = tc_data.columns & available (DELETE_LINES) & available (INSERT_LINES)
	then do;
	     call position_cursor (row, 1);
	     call do_operation (DELETE_LINES, (0), (0), n_rows, ns);
	     if -1 + row + n_rows < tc_data.rows
	     then do;
		call do_operation (INSERT_LINES, (0), (0), n_rows, ns);
		call position_cursor (row, col);
	     end;
	     return;
	end;


/* This is still pretty primitive. I/DEL chars might be
   faster sometimes */

	begin;
	     declare n_after	        fixed bin;
	     declare first_after	        fixed bin;
	     declare have_cleol	        bit (1) aligned;

	     have_cleol = available (CLEAR_TO_EOL);
	     first_after = col + n_cols;
	     n_after = tc_data.columns - (first_after - 1);

	     do i = row to -1 + row + n_rows;
		if noopt | ^tc_screen$is_region_clear (tc_data.screen_data_ptr, i, col, 1, n_cols)
		then do;
		     if have_cleol
			& (noopt | tc_screen$is_region_clear (tc_data.screen_data_ptr, i, first_after, 1, n_after))
		     then do;
			call position_cursor (i, col);
			call do_operation (CLEAR_TO_EOL, (0), (0), (1), ns);
		     end;
		     else do;
			call position_cursor (i, col);/* erase only as many chars as necessary */
			if have_cleol & n_after + cost (CLEAR_TO_EOL) < n_cols
						/* cheaper to CEOL and repaint stuff to the right? */
			then do;			/* CEOL and repaint */
			     call tc_screen$get_in_line (tc_data.screen_data_ptr, i, first_after, save_row);
			     call do_operation (CLEAR_TO_EOL, (0), (0), (1), ns);
			     call position_cursor (i, first_after);
			     call write_text (i, first_after, addr (save_row), length (rtrim (save_row)));
			end;
			else do;			/* erase with spaces and leave other windows to the right alone */
			     call tc_screen$get_in_line (tc_data.screen_data_ptr, i, col, save_row);
			     call write_text (i, col, addr (MANY_SPACES),
				length (rtrim (substr (save_row, 1, n_cols))));
						/* write as few spaces as possible */
			end;
		     end;
		end;
	     end;
	end;
	call position_cursor (row, col);
     end clear_region;


insert_text:
     procedure (a_row, a_col, text_ptr, text_length, last_column);

	declare (a_row, a_col, last_column)
				   fixed bin;

	declare (row, col)		   fixed bin;
	declare text_ptr		   pointer;
	declare text_length		   fixed bin (21);
	declare overwrite		   bit (1);
	declare 1 ns		   aligned like new_state;
	declare clear_start		   fixed bin;

	overwrite = "0"b;
	go to common;

overwrite_text:
     entry (a_row, a_col, text_ptr, text_length);

	overwrite = "1"b;

common:
	unspec (ns) = ""b;

	row = a_row;
	col = a_col;

	if overwrite
	then if state.insert_mode			/* could only happen if END avail */
	     then do;
		ns.pay_attention.insert = "1"b;
		ns.insert_mode = "0"b;
		call do_operation (END_INSERT_CHARS, (0), (0), (1), ns);
		unspec (ns) = ""b;
	     end;
	     else ;
	else do;					/* request to insert */
	     if available (END_INSERT_CHARS) & tc_data.columns = last_column
	     then if ^state.insert_mode
		then do;
		     ns.pay_attention.insert = "1"b;
		     ns.insert_mode = "1"b;
		     call do_operation (INSERT_CHARS, (0), (0), (1), ns);
		     unspec (ns) = ""b;
		end;
		else ;
	     else do;				/* At this point we know that the terminal does not have
						   an insert-character mode.  It may have an "open up
						   some space" insert chars operation, a la the Teleray
						   1061. If so, we have to call do_operation with the
						   INSERT_CHARS op to get the sequences to the terminal,
						   and then we have to call tc_screen again to update the
						   screen image, since it knows that the INSERT_CHARS op
						   doesn't change the screen on terminals with an insert
						   char mode.  The two different types of INSERT_CHARS
						   should have been made two different ops when the TTF
						   video stuff was set up, and should be split when the
						   TTF is upgraded (MR 10.2?).  -WMY 7/16/82. */

		if available (INSERT_CHARS) & tc_data.columns = last_column
		then do;
		     call do_operation (INSERT_CHARS, (0), (0), (text_length), ns);
						/* assume no cursor motion */
		     begin;
			dcl  some_spaces		char (text_length) defined (MANY_SPACES) position (1);
			call tc_screen$text (tc_data.screen_data_ptr, row, col, "1"b /* fake insert mode */,
			     some_spaces);
		     end;
		end;
		else do;				/* we get here if the terminal doesn't have i-chars
						   or if we aren't the rightmost window */
						/* we have no real insert chars operation, so
						   we have to replay the part of the line past
						   the inserted text, so get it from the screen image */
		     call tc_screen$get_in_line (tc_data.screen_data_ptr, row, col, save_row);
		     call position_cursor (row, col);
		     call write_text (row, col, text_ptr, text_length);

/* shorten to fit in what's left of the line. */
		     save_row = substr (save_row, 1, last_column - (col + text_length) + 1);

/* now strip any trailing whitespace from this new
   string and write it. */

		     call write_text (row, col + text_length, addr (save_row), length (rtrim (save_row)));
						/* now clear the rest of the line */
		     clear_start = col + text_length + length (rtrim (save_row));
		     call clear_region (row, clear_start, 1, last_column - clear_start + 1);
		     call position_cursor (row, col + text_length);
		     return;
		end;
	     end;
	end;

	call position_cursor (row, col);
	call write_text (row, col, text_ptr, text_length);
     end insert_text;


delete_chars:
     procedure (a_row, a_col, a_count, last_column);

	declare (a_row, a_col, a_count, last_column)
				   fixed bin;

	declare (row, col, count)	   fixed bin;
	declare 1 ns		   aligned like new_state;
	declare clear_start		   fixed bin;
	declare write_length	   fixed bin (21);

	unspec (ns) = ""b;

	row = a_row;
	col = a_col;
	count = a_count;

	call position_cursor (row, col);
	if available (DELETE_CHARS) & last_column = tc_data.columns
	then call do_operation (DELETE_CHARS, (0), (0), count, ns);
	else do;					/* nasty simulation */
	     call tc_screen$get_in_line (tc_data.screen_data_ptr, row, col + count, save_row);

	     write_length = length (rtrim (substr (save_row, 1, last_column - col - count + 1)));
						/* be sure not to write in the next window */
	     call write_text (row, col, addr (save_row), write_length);

/* now clear the rest of the line. this should help with
   whitespace optomization. */
	     clear_start = col + write_length;
	     call clear_region (row, clear_start, 1, last_column - clear_start + 1);
	     call position_cursor (row, col);
	end;

     end delete_chars;


scroll_region:
     procedure (a_row, n_rows, a_distance);

	declare (a_row, n_rows, a_distance)
				   fixed bin;

	declare (row, distance)	   fixed bin;

	declare save_row		   fixed bin;
	declare save_col		   fixed bin;

	declare 1 ns		   aligned like new_state;

	if ^(available (INSERT_LINES) & available (DELETE_LINES))
	then go to capabilities_lacking;		/* too hard to simulate */

	row = a_row;
	distance = a_distance;

	if distance = 0
	then return;				/* ??? */

	unspec (ns) = ""b;

	save_row = state.row;
	save_col = state.col;

	if distance > 0				/* down */
	then do;
	     if (row + n_rows - 1) = tc_data.rows
	     then do;				/* insert is all we need */
		call position_cursor (row, 1);
		call do_operation (INSERT_LINES, (0), (0), distance, ns);
	     end;
	     else do;
		call position_cursor (row + n_rows - distance, 1);
		call do_operation (DELETE_LINES, (0), (0), distance, ns);
		call position_cursor (row, 1);
		call do_operation (INSERT_LINES, (0), (0), distance, ns);
	     end;
	end;
	else do;					/* up */
	     call position_cursor (row, 1);
	     call do_operation (DELETE_LINES, (0), (0), -distance, ns);
	     if (row + n_rows - 1) ^= tc_data.rows	/* bottom region */
	     then do;
		call position_cursor (row + n_rows + distance, 1);
						/* it is negative */
		call do_operation (INSERT_LINES, (0), (0), -distance, ns);
	     end;
	end;

	call position_cursor (save_row, save_col);
     end scroll_region;


bell:
     procedure (a_row, a_col);

	declare (a_row, a_col)	   fixed bin;

	declare (row, col)		   fixed bin;

	row = a_row;
	col = a_col;

	call position_cursor (row, col);		/* visual effect too */
	call write_bell;				/* knows it 0 length on screen */
     end bell;


cost:
     procedure (op) returns (fixed bin);
	declare op		   fixed bin;

	declare count		   fixed bin;

	count = 1;
	go to cost_common;

cost_repeat:
     entry (op, a_count) returns (fixed bin);
	declare a_count		   fixed bin;


	count = a_count;

cost_common:
	ttyvseqp = addr (tty_video_table.sequences (op));
	if ^tty_video_seq.present
	then return (OMEGA);			/* Quite expensive */
	if tty_video_seq.able_to_repeat
	then return (tty_video_seq.len);
	else return (count * tty_video_seq.len);

available:
     entry (op) returns (bit (1) aligned);

	ttyvseqp = addr (tty_video_table.sequences (op));
	return (tty_video_seq.present);

     end cost;


do_operation:
     procedure (op, a_op_row, a_op_col, op_n, a_new_state);

/* If op_row or op_col is zero we use current position, if something
   demands coords. This makes for redundant positions, but so be it for now */

/* ASSERT: that even a line's worth of text will fit into
   the hardcore's take it or leave it buffer. */

/* This program manages state. For each operation, it makes
   the character string for the terminal, and calculates the net
   effect on the cursor position, updating the state structure,
   and the screen image via tc_screen. */


	declare (op, op_row, op_col, op_n, a_op_row, a_op_col)
				   fixed binary;

	declare 1 a_new_state	   aligned like new_state;
	declare 1 ns		   aligned like new_state;

	declare 1 seq		   aligned like tty_video_seq based (ttyvseqp);
	declare chars		   character (seq.len) based (chars_ptr);
	declare chars_ptr		   pointer;


	ttyvseqp = addr (tty_video_table.sequences (op)); /* Do this first do avoid faults in the begin block prologue. */

	ns = state, by name;
	if a_new_state.pay_attention.cursor
	then ns.cursor_valid = a_new_state.cursor_valid;
	if a_new_state.pay_attention.insert
	then ns.insert_mode = a_new_state.insert_mode;
	if a_new_state.pay_attention.position
	then ns.cursor_position = a_new_state.cursor_position;

	begin;
	     declare i		        fixed bin;
	     declare loop		        fixed bin;
	     declare cx		        fixed bin;
	     declare vchars		        character (seq.len) defined (tty_video_table.video_chars)
				        position (seq.seq_index);

	     op_row = a_op_row;
	     if op_row = 0
	     then op_row = state.row;
	     op_col = a_op_col;
	     if op_col = 0
	     then op_col = state.col;

/* HOME is a bit magic */

	     if op = HOME
	     then op_row, op_col = 1;
	     if ^seq.present
	     then call tc_error (video_et_$tc_missing_operation, "");

	     chars_ptr = addr (vchars);		/* so we can see chars in probe */

	     if ^seq.interpret			/* easy */
	     then do;
		do i = 1 to op_n;			/* supply repeats */
		     call add_to_buffer (chars);
		     call pad;
		end;
		go to update_state;
	     end;

/* don't bother if nothing is going to happen */
	     else if (op_n > 0)
	     then do;
		if seq.able_to_repeat
		then loop = 1;
		else loop = op_n;
		do i = 1 to loop;

		     do cx = 1 to seq.len;
			begin;
			     declare the_char	        character (1) defined (chars) position (cx);
			     declare 1 encoded	        unaligned like tty_numeric_encoding based (enc_ptr);
			     declare enc_ptr	        pointer;


			     enc_ptr = addr (the_char);

			     if ^encoded.must_be_on
			     then call add_to_buffer (the_char);
			     else cx = cx + encode (encoded);
			end;			/* begin */
		     end;				/* do over chars in seq */
		     call pad;
		end;				/* over repeat count */
	     end;					/* was nontrivial */
update_state:
	     state = ns, by name;

	     if op_n > 0
	     then call tc_screen$operation (tc_data.screen_data_ptr, op, op_row, op_col, op_n);
	end;					/* simulated terminal */
	return;


pad:
     procedure;
	if seq.cpad_present
	then do;
	     if seq.cpad_in_chars
	     then call add_pad_to_buffer ((seq.cpad));
	     else call add_pad_to_buffer (divide (seq.cpad /* .0001 secs */ * tc_data.line_speed, 10000, 21, 0));
	end;
     end pad;


encode:
     procedure (thing) returns (fixed bin);

/* ASSERT that n is positive. what should negatives look like? */

	declare 1 thing		   unaligned like tty_numeric_encoding;
	declare value		   fixed bin;
	declare skip		   fixed bin;

	skip = 0;
	go to VALUE (thing.l_c_or_n);

VALUE (0):					/* LINE */
	value = op_row;
	go to got_value;

VALUE (1):					/* COLUMN */
	value = op_col;
	go to got_value;
VALUE (2):					/* N */
	value = op_n;

got_value:
	if ^thing.offset_is_0
	then do;
	     value = value + thing.offset;
	     skip = 1;
	end;


	if thing.express_in_decimal
	then do;
	     if thing.num_digits = 0
	     then call add_to_buffer_ltrim_char (value);

	     else call add_to_buffer_last_n (value, (thing.num_digits));
	end;
	else if thing.express_in_octal
	then do;					/* this is a mess, cause pl1 do not grok octal */
	     begin;
		declare bits		   (-5:6) bit (3) unaligned;
		declare ib		   fixed bin;
		declare saw_nonzero		   bit (1);
		declare start		   fixed bin;

		saw_nonzero = "0"b;
		unspec (bits) = unspec (value);
		if thing.num_digits = 0
		then start = 1;
		else start = 6 - thing.num_digits + 1;

		do ib = start to 6;
		     if bits (ib) = "000"b
		     then if saw_nonzero | start > 1
			then call add_to_buffer ("0");
			else ;			/* suppress */
		     else do;
			call add_to_buffer (byte (bin (bits (ib), 3) + rank ("0")));
			saw_nonzero = "1"b;
		     end;
		end;
	     end;					/* begin */
	end;					/* octalness */

	else call add_to_buffer (byte (value));
	return (skip);
     end encode;

     end do_operation;

/* parallel routine to do_operation for writing text to the terminal and
   updating the screen image. */

write_text:
     procedure (op_row, op_col, text_ptr, text_length);

	dcl  (op_row, op_col)	fixed bin;
	dcl  text_ptr		pointer;
	dcl  text_length		fixed bin (21);

	dcl  text			char (text_length) based (text_ptr);

/* Can not be called with 0 values for row and col. */

	call add_to_buffer_splittable (text_ptr, text_length);

	state.row = op_row;
	state.col = op_col + text_length;

	call tc_screen$text (tc_data.screen_data_ptr, op_row, op_col, (state.insert_mode), text);
	return;

write_bell:
     entry;

	call add_to_buffer (byte (7));
	return;

     end write_text;

/* Internal procedures for handling the buffering and sending
   of data to ring 0 tty routines. */

add_to_buffer:
     procedure (string);

/* Entry to add a string to the output buffer.  Always ensures that the
   entire string is added without breaks, so tty sequences won't get broken */

	dcl  string		character (*);
	dcl  chunk_length		fixed bin;
	dcl  stuff_idx		fixed bin;
	dcl  ok_to_split		bit (1) aligned;

	dcl  a_stuff_ptr		pointer;
	dcl  a_stuff_length		fixed bin (21);

	dcl  stuff_ptr		pointer;
	dcl  stuff_length		fixed bin (21);

	dcl  stuff		char (stuff_length) based (stuff_ptr);

	stuff_ptr = addr (string);
	stuff_length = length (string);

	ok_to_split = "0"b;
	goto add_to_buffer_common;

add_to_buffer_splittable:
     entry (a_stuff_ptr, a_stuff_length);

/* Entry to write potentially large strings, which can be split up
   arbitrarily among different calls to ring 0. */

	stuff_ptr = a_stuff_ptr;
	stuff_length = a_stuff_length;

	ok_to_split = "1"b;
	goto add_to_buffer_common;

add_to_buffer_common:				/* Make sure that there is room in the buffer, and flush it
						   out if it is full. */
	if (tc_data.global_buffer_index + length (stuff)) > tc_data.global_buffer_limit
	then if ok_to_split
	     then do;				/* first fill the buffer completely and write it */
		stuff_idx = 1;

		do while ((length (stuff) - stuff_idx + 1) > tc_data.global_buffer_limit);
		     chunk_length = tc_data.global_buffer_limit - tc_data.global_buffer_index;
		     substr (tc_data.global_output_buffer, tc_data.global_buffer_index + 1, chunk_length) =
			substr (stuff, stuff_idx, chunk_length);
		     tc_data.global_buffer_index = tc_data.global_buffer_limit;
		     call write_global_buffer;
		     stuff_idx = stuff_idx + chunk_length;
		end;

/* now put the remaining stuff in the buffer */
		chunk_length = length (stuff) - stuff_idx + 1;
		substr (tc_data.global_output_buffer, tc_data.global_buffer_index + 1, chunk_length) =
		     substr (stuff, stuff_idx);
		tc_data.global_buffer_index = tc_data.global_buffer_index + chunk_length;
		return;
	     end;

	     else call write_global_buffer;		/* not OK to split */

/* Add entire string. This better not be bigger than the buffer */

	substr (tc_data.global_output_buffer, tc_data.global_buffer_index + 1, length (stuff)) = stuff;
	tc_data.global_buffer_index = tc_data.global_buffer_index + length (stuff);
	return;

     end add_to_buffer;

add_pad_to_buffer:
     procedure (number);
	declare number		   fixed bin;

	declare pad_length		   fixed bin;	/* the 254 here is due to a compiler limitation in init clauses */
	declare pad_string		   char (254) static options (constant) init ((254)" ");

	pad_length = min (number, length (pad_string));
	begin;
	     dcl	defined_pad	     char (pad_length) defined (pad_string) pos (1);
	     call add_to_buffer (defined_pad);
	end;
	return;
     end add_pad_to_buffer;

add_to_buffer_ltrim_char:
     procedure (number);
	declare number		   fixed bin;
	declare pic_		   picture "9999";
	declare char_temp		   char (4);
	declare first_nonspace	   fixed bin;

	pic_ = number;
	first_nonspace = verify (pic_, "0");		/* digits start here, there must be 1 */
	if first_nonspace = 0
	then first_nonspace = 4;

add_in_number:
	char_temp = pic_;
	begin;
	     dcl	defined_pic	     char (length (char_temp) - first_nonspace + 1) defined (char_temp)
				     pos (first_nonspace);
	     call add_to_buffer (defined_pic);
	end;
	return;

add_to_buffer_last_n:
     entry (number, digits);
	declare digits		   fixed bin;

	pic_ = number;
	first_nonspace = 5 - digits;			/* first digit we want */
	go to add_in_number;

     end add_to_buffer_ltrim_char;

/* Internal routine to write the buffered output to the terminal */

write_global_buffer:
     procedure;

	declare to_write		   character (tc_data.global_buffer_index)
				   defined (tc_data.global_output_buffer) position (1);
	declare n_wrote		   fixed bin (21);

	if length (to_write) = 0
	then return;

	tc_data.change_pclock = tc_data.change_pclock + 1;

write:
	n_wrote = 0;

	if tc_data.network_type = DSA_NETWORK_TYPE
	then					/* DSA */
	     call dsa_tty_$write_whole_string (tc_data.tty_handle, to_write, "1"b /* MARK */, n_wrote, tty_state, code);
	else if tc_data.network_type = MOWSE_NETWORK_TYPE
	then					/* MOWSE */
	     call ws_tty_$write_whole_string (tc_data.mowse_terminal_iocb_ptr, to_write, "1"b, n_wrote, tty_state, code)
		;
	else					/* MCS */
	     call hcs_$tty_write_whole_string (tc_data.devx, to_write, "1"b /* MARK */, n_wrote, tty_state, code);

	if code ^= 0
	then call tc_disconnect$check (TC_data_ptr, code);

	if code ^= 0
	then do;					/* If the stuff couldn't be written, all our assumptions about
						   the cursor position on the actual terminal are wrong. */
	     tc_data.state.cursor_valid = "0"b;
	     call tty_write_error (code);
	end;

	if length (to_write) > 0 & n_wrote = 0		/* did not happen */
	then do;
	     if tc_data.network_type ^= MOWSE_NETWORK_TYPE
	     then call block;
	     go to write;
	end;
	call bump_mark;

	tc_data.global_buffer_index = 0;		/* indicate buffer empty */

     end write_global_buffer;


write_no_mark:
     procedure (text);
	declare text		   character (*);
	declare n_wrote		   fixed bin (21);	/* ASSERT text_to_echo is aligned */
	declare buffer_ptr		   pointer;
	declare offset		   fixed bin (21);
	declare n_left		   fixed bin (21);
	declare char_offset_	   entry (ptr) returns (fixed bin (21)) reducible;
	declare add_char_offset_	   entry (ptr, fixed bin (21)) returns (ptr) reducible;

	if length (text) = 0
	then return;

	n_left = length (text);

	buffer_ptr = addr (text);
	offset = char_offset_ (buffer_ptr);

/**** The hardcore demands a word aligned buffer ****/

	if offset > 0
	then buffer_ptr = add_char_offset_ (buffer_ptr, -offset);

/* first write out any buffered stuff to get in sync */
	call write_global_buffer;

echo_write:
	if tc_data.network_type = DSA_NETWORK_TYPE
	then					/* DSA */
	     call dsa_tty_$write (tc_data.tty_handle, buffer_ptr, offset, n_left, n_wrote, tty_state, code);
	else if tc_data.network_type = MOWSE_NETWORK_TYPE
	then					/* MOWSE */
	     call ws_tty_$write (tc_data.mowse_terminal_iocb_ptr, buffer_ptr, offset, n_left, n_wrote, tty_state, code);
	else					/* MCS */
	     call hcs_$tty_write (tc_data.devx, buffer_ptr, offset, n_left, n_wrote, tty_state, code);

	if code ^= 0
	then call tc_disconnect$check (tc_data_ptr, code);
	if code ^= 0
	then call tty_write_error (code);
	if n_wrote < n_left
	then do;					/* Lets try it again */

/* This should NEVER happen. */

	     if tc_data.network_type ^= MOWSE_NETWORK_TYPE
	     then call block;
	     n_left = n_left - n_wrote;
	     offset = offset + n_wrote;
	     go to echo_write;
	end;
	return;
     end write_no_mark;

/* This should be the only non-error return point from tc_request. */

request_done:
	Code = 0;
	return;

capabilities_lacking:
	Code = video_et_$capability_lacking;
	go to request_done;


block:
     procedure;

	declare UNMASK_NOTHING	   bit (36) aligned initial ("01"b) internal static options (constant);

	call tc_block (tc_data_ptr, request_ptr, UNMASK_NOTHING);

     end block;


tty_write_error:
     procedure (code);
	declare code		   fixed bin (35);
	declare msg		   character (100) aligned;
	declare convert_status_code_	   entry (fixed binary (35), character (8) aligned, character (100) aligned);

	call convert_status_code_ (code, (8)" ", msg);
	call tc_error (video_et_$tc_tty_error, rtrim (msg));
     end tty_write_error;


write_raw_text:
     procedure (row, col, text);
	declare (row, col)		   fixed bin;
	declare text		   character (*);
	declare n_wrote		   fixed bin (21);
	declare code		   fixed bin (35);
	declare tty_state		   fixed bin;
	declare offset		   fixed bin (21);
	declare text_length		   fixed bin (21);

	if length (text) = 0
	then return;

	offset = 0;
	text_length = length (text);

	tc_data.change_pclock = tc_data.change_pclock + 1;

/* first write out any buffered stuff */
	call write_global_buffer;

write:
	begin;
	     declare to_write	        character (text_length) defined (text) position (1 + offset);

	     n_wrote = 0;

/* write the whole string at once, with mark */

	     if tc_data.network_type = DSA_NETWORK_TYPE
	     then					/* DSA */
		call dsa_tty_$write_whole_string (tc_data.tty_handle, to_write, "1"b /* with mark */, n_wrote,
		     tty_state, code);
	     else if tc_data.network_type = MOWSE_NETWORK_TYPE
	     then					/* MOWSE */
		call ws_tty_$write_whole_string (tc_data.mowse_terminal_iocb_ptr, to_write, "1"b, n_wrote, tty_state,
		     code);
	     else					/* MCS */
		call hcs_$tty_write_whole_string (tc_data.devx, to_write, "1"b /* with mark */, n_wrote, tty_state,
		     code);

	     if code ^= 0
	     then call tc_disconnect$check (tc_data_ptr, code);
	     if code ^= 0
	     then call tty_write_error (code);
	end;

	if n_wrote < text_length
	then do;
	     if tc_data.network_type ^= MOWSE_NETWORK_TYPE
	     then call block;
	     text_length = text_length - n_wrote;
	     offset = offset + n_wrote;
	     go to write;
	end;
	state.cursor_valid = "0"b;			/* who knows what it did ? */
	call bump_mark;
     end write_raw_text;


RECOMPUTE_OPERATION:
	if request_header.this_window			/* it happened in the same window */
	then go to request_done;
	else go to recompute_operation_here;		/* was not this window */



bump_mark:
     procedure;
	if state.current_mark = 511			/* using the size condition is expensive */
	then do;
	     state.current_mark = 1;
	     state.last_mark_back = 0;
	end;
	state.current_mark = state.current_mark + 1;
     end bump_mark;

write_echo:
     entry (TC_data_ptr, text_to_echo);

	declare text_to_echo	   character (*) parameter;

	tc_data_ptr = TC_data_ptr;
	call write_no_mark (text_to_echo);
	call tc_screen$text (tc_data.screen_data_ptr, state.row, state.col, "0"b, text_to_echo);
	state.col = state.col + length (text_to_echo);
	return;
%page;
%include net_event_message;
%page;
%include tc_data_;
%page;
%include tc_operations_;
%page;
%include condition_info_header;
%page;
%include tc_asyncronity_info;
%page;
%include tty_video_tables;

     end tc_request;
