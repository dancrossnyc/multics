/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(86-05-23,LJAdams), approve(86-11-11,MCR7485),
     audit(87-01-06,Margolin), install(87-01-06,MR12.0-1255):
     Modified to support MOWSE.
  2) change(86-11-26,LJAdams), approve(86-11-26,MCR7584),
     audit(87-01-06,Margolin), install(87-01-06,MR12.0-1255):
     Initial DSA coding has been maintained in a non-executable form.
  3) change(87-01-14,LJAdams), approve(87-01-14,PBF7485),
     audit(87-01-14,Gilcrease), install(87-01-14,MR12.0-1280):
     Do not create video_data_$terminal_iocb until we are sure MOWSE is
     present.
  4) change(87-01-16,LJAdams), approve(87-01-16,PBF7485),
     audit(87-01-16,Gilcrease), install(87-01-19,MR12.0-1287):
     If an errors executing control order initialize_mowse_terminal return.
  5) change(87-05-20,LJAdams), approve(87-05-20,MCR7699),
     audit(87-07-23,Gilcrease), install(87-08-04,MR12.1-1055):
     Added support for MOWSE_FANSI protocol.
     Made sure all ips signals are UNMASKED prior to starting video.
  6) change(87-06-16,LJAdams), approve(87-06-16,MCR7584),
     audit(87-07-23,Gilcrease), install(87-08-04,MR12.1-1055):
     Change editing_chars_version_2 to editing_chars_version_3 which includes
     the redisplay character.
  7) change(88-09-19,Brunelle), approve(88-09-19,MCR7813),
     audit(88-10-05,Blair), install(88-10-17,MR12.2-1171):
     Change get_special control order to add version number in structure so we
     get new format of the special chars structure.
  8) change(89-02-27,Lee), approve(89-03-14,MCR8075), audit(89-04-20,Flegel),
     install(89-05-10,MR12.3-1041):
     phx19064 (Video 87) - modified to use the current editing char values
     rather than the default erase/kill (#@) values when video is invoked.
                                                   END HISTORY COMMENTS */


/* format: style4,delnl,insnl,indattr,ifthen,dclind9 */

/* various useful things in the video system. */

/* BIM June 1981 */
/* Modified 14 December 1981 by Chris Jones to copy modes in common with tty_
   on invocation */
/* Modified 16 December 1981 by Chris Jones to copy editing chars on
   invocation, and restore modes and editing_chars on exit. */
/* Modified January 1883 by William York to call window_$sync before shutting
   down. */
/* Modified ? by Barry Margolin to find the -login_channel switch instead of
   assuming user_i/o. */
/* Modified 18 May 1983 by WMY to save all the tty_ state there is upon
   invocation and to restore it on revocation. */
/* Modified August 1983 by Jon A. Rochlis to add ssu usage recording. */
/* Modified 26 January 1984 by JR to set the output conversion and special
   tables in use by tty_ via control orders to terminal control, which will
   be passed to ring0.  Window_io_ can get them back and use them as defaults
   by asking terminal control. */
/* Modified 24 May 1984 by JR to remove the sus_signal_handler stuff,
   since the reconnection control order doesn't need it, and it
   will actually break things in one case (reconnection on an unsupported
   terminal). */
/* Modified 30 May 1984 by JR to put in the conditional calls to
   use_exl_video_system$(setup cleanup) */
/* Modified 01 September 1984 by JR to add edited mode to the list of common
   modes. */
/* Modified 22 November 1984 by JR to explicity reset
   video_data_$terminal_iocb if we fail to invoke the video system.  This is
   needed since  turn_off_login_channel (among others) relies on
   terminal_iocb ^= null() ==> video is on. */
/* Modified 27 December 1984 by JR to make get_tty_state use version number
   constants from tty_convert.incl.pl1 instead of hardcoding the constants. */
/* Modified June 1985 by Roger Negaret to support DSA networks. */

video_utils_:
     procedure;
	return;
%page;

dcl      user_io_modes	  char (512);

dcl      saved_ips_mask	  bit (36) aligned;

dcl      ips_mask_name          (1) char (32) aligned init ("-all");

dcl      sci_ptr		  ptr;

dcl      complete_tty_state_ptr pointer internal static;

/* Structure in which to save all interesting tty_ state information. */

dcl      1 complete_tty_state	  aligned based (complete_tty_state_ptr),
	 2 modes_string	  char (512) unaligned,
	 2 editing_chars_ptr  pointer,
	 2 delay_ptr	  pointer,
	 2 framing_chars_ptr  pointer,
	 2 ifc_ptr	  pointer,
	 2 ofc_ptr	  pointer,
	 2 input_translation_ptr
			  pointer,
	 2 input_conversion_ptr
			  pointer,
	 2 output_conversion_ptr
			  pointer,
	 2 output_translation_ptr
			  pointer,
	 2 special_ptr	  pointer;


dcl      1 fsc_info		  like mowse_io_flush_subchannel_info;

dcl      common_modes	  (7) char (8) init ("vertsp", "can", "erkl", "esc", "red", "ctl_char", "edited")
			  static options (constant);

dcl      create_ips_mask_	  entry (ptr, fixed bin, bit(36) aligned);
dcl      hcs_$set_ips_mask	  entry (bit(36) aligned, bit(36) aligned);
dcl      hcs_$reset_ips_mask	  entry (bit (36) aligned, bit (36) aligned);
dcl      ipc_$mask_ev_calls	  entry (fixed bin (35));
dcl      ipc_$unmask_ev_calls	  entry (fixed bin (35));
dcl      mode_string_$get	  entry (ptr, char (*), fixed bin (35));
dcl      mode_string_$get_mode  entry (char (*), char (*), ptr, fixed bin (35));
dcl      ssu_$standalone_invocation
			  entry (ptr, char (*), char (*), ptr, entry, fixed bin (35));
dcl      ssu_$destroy_invocation
			  entry (ptr);
dcl      ssu_$record_usage	  entry (ptr, ptr, fixed bin (35));

dcl      use_exl_video_system$cleanup
			  entry (fixed bin (35));
dcl      window_$destroy_all	  entry (pointer);

dcl      video_data_$terminal_switch
			  character (32) external;
dcl      video_data_$terminal_iocb
			  pointer external;
dcl      video_data_$exl_video_system
			  bit (1) external static;
dcl      video_data_$exl_initialized
			  bit (1) external;

dcl      error_table_$action_not_performed
			  external fixed bin (35);
dcl      error_table_$no_table  external fixed bin (35);
dcl      error_table_$undefined_order_request
			  fixed bin (35) ext static;

dcl      video_et_$wsys_invoked fixed bin (35) ext static;
dcl      video_data_$version	  external char (12);

dcl      any_other		  condition;
dcl      sub_error_		  condition;
dcl      cleanup_label	  label variable;

dcl      mowse_terminal_switch  char (15) internal static options (constant) init ("mowse_terminal_");
dcl      mowse_iocb_ptr	  pointer static;		/* remember where mowse_terminal_ was		*/
dcl      network_type	  fixed bin (4) unsigned static;
						/* remember on which network we are */
dcl      target_iocb	  pointer static;		/* remember what switch to use */

dcl      (addr, codeptr, hbound, lbound, index, length, ltrim, min, null, rtrim, substr)
			  builtin;
%page;

turn_on_login_channel:
     entry (error_code, reason);

declare  error_code		  fixed bin (35);
declare  reason		  character (*);

declare  acode		  fixed bin (35);

declare  use_exl_video_system$setup
			  entry (fixed bin (35));

	error_code = 0;
	if video_data_$terminal_iocb ^= null () then do;
	     error_code = video_et_$wsys_invoked;
	     reason = "";
	     return;
	end;

	/*** set the network id:      */
	call network_login_channel (target_iocb, network_type, error_code);
	if error_code ^= 0 then do;
	     reason = "Could not find a tty_ or mowse attachment.";
	     return;
	end;

          call create_ips_mask_ (addr(ips_mask_name), hbound(ips_mask_name,1), saved_ips_mask);
						/* everthing masked				*/
          saved_ips_mask = ^saved_ips_mask;                 /* unmask everything to start			*/
          call hcs_$set_ips_mask (saved_ips_mask, ""b);	/* initially there is no old mask value		*/

	if network_type = MOWSE_NETWORK_TYPE then
	     goto mowse_network;
	else if network_type = DSA_NETWORK_TYPE then
	     goto dsa_network;
	else goto mcs_network;
%page;

dsa_network:
	network_type = DSA_NETWORK_TYPE;

	reason = "Creating switch " || video_data_$terminal_switch;
	call iox_$find_iocb (video_data_$terminal_switch, video_data_$terminal_iocb, error_code);
	if error_code ^= 0 then
	     return;

	cleanup_label = UNDO_DSA_$mask;
	on any_other call handle_any_other (cleanup_label);
						/* we could be cl_intermediary, but they get called without any state */

/* Before we close the channel, copy any tty_ state information that we want
   to preserve across the attachment. */

	call get_tty_state;

	call hcs_$set_ips_mask (""b, saved_ips_mask);
	call ipc_$mask_ev_calls ((0));		/* in case some joker blocks */
	reason = "Closing terminal switch.";
	call iox_$close (target_iocb, error_code);

	if error_code ^= 0 then
	     goto UNDO_DSA_$mask;

	cleanup_label = DSA_REOPEN;
	reason = "Detaching terminal switch.";
	call iox_$detach_iocb (target_iocb, error_code);
	if error_code ^= 0 then
	     goto DSA_REOPEN;

/* Old attachment gone, attach the tc_io_ switch. */

	cleanup_label = DSA_REATTACH;
	reason = "Attaching switch " || rtrim (video_data_$terminal_switch) || " as tc_io_ -login_channel .";
	on sub_error_ call attach_handler (cleanup_label);

	call iox_$attach_ptr (video_data_$terminal_iocb, "tc_io_ -login_channel", codeptr (video_utils_), error_code);

	revert sub_error_;

	if error_code ^= 0 then
	     go to DSA_REATTACH;

	cleanup_label = UNDO_DSA_$video;

	reason = "Opening switch " || video_data_$terminal_switch;
	call iox_$open (video_data_$terminal_iocb, Stream_input_output, ""b, error_code);

	if error_code ^= 0 then
	     go to UNDO_DSA_$video;

	call iox_$control (video_data_$terminal_iocb, "set_output_conversion", complete_tty_state.output_conversion_ptr,
	     (0));

	call iox_$control (video_data_$terminal_iocb, "set_special", complete_tty_state.special_ptr, (0));

/* RL: phx19064 - use editing chars which are current set */
	call iox_$control (video_data_$terminal_iocb, "set_editing_chars", complete_tty_state.editing_chars_ptr, (0));

	reason = "attaching ""window_io_ " || rtrim (video_data_$terminal_switch) || """";

	on sub_error_ call attach_handler (cleanup_label);

	call iox_$attach_ptr (target_iocb, "window_io_ " || rtrim (video_data_$terminal_switch), codeptr (video_utils_),
	     error_code);

	if error_code ^= 0 then
	     goto UNDO_DSA_$video;

	revert sub_error_;

	cleanup_label = UNDO_DSA_$attach;

	reason = "opening terminal switch.";
	call iox_$open (target_iocb, Stream_input_output, ""b, error_code);
	if error_code ^= 0 then
	     goto UNDO_DSA_$attach;

	cleanup_label = UNDO_DSA;

	reason = "Initializing EXL video system.";
	if video_data_$exl_video_system & ^video_data_$exl_initialized then do;
	     call use_exl_video_system$setup (error_code);
	     if error_code ^= 0 then
		goto UNDO_DSA;
	     video_data_$exl_initialized = "1"b;
	end;

	goto finished;
%page;

UNDO_DSA:
	call close_switch;
UNDO_DSA_$attach:
	call detach_switch;
UNDO_DSA_$video:
	call close_video;
DSA_REATTACH:
	call reattach;
DSA_REOPEN:
	call reopen;
UNDO_DSA_$mask:
	goto unmask_return;
%page;

mcs_network:
	network_type = MCS_NETWORK_TYPE;

	reason = "Creating switch " || video_data_$terminal_switch;
	call iox_$find_iocb (video_data_$terminal_switch, video_data_$terminal_iocb, error_code);
	if error_code ^= 0 then
	     return;

/* Before we close the channel, copy any tty_ state information that we want
   to preserve across the attachment. */

	cleanup_label = UNDO_MCS_$mask;
	on any_other call handle_any_other (cleanup_label);
						/* we could be cl_intermediary, but they get called without any state */

	call get_tty_state;

	call hcs_$set_ips_mask (""b, saved_ips_mask);
	call ipc_$mask_ev_calls ((0));		/* in case some joker blocks */

	reason = "Closing terminal switch.";
	call iox_$close (target_iocb, error_code);

	if error_code ^= 0 then
	     go to UNDO_MCS_$mask;

	cleanup_label = MCS_REOPEN;
	reason = "Detaching terminal switch.";
	call iox_$detach_iocb (target_iocb, error_code);
	if error_code ^= 0 then
	     go to MCS_REOPEN;

/* Old attachment gone, attach the tc_io_ switch. */

	cleanup_label = MCS_REATTACH;
	reason = "Attaching switch " || rtrim (video_data_$terminal_switch) || " as tc_io_ -login_channel .";
	on sub_error_ call attach_handler (cleanup_label);

	call iox_$attach_ptr (video_data_$terminal_iocb, "tc_io_ -login_channel", codeptr (video_utils_), error_code);

	revert sub_error_;

	if error_code ^= 0 then
	     go to MCS_REATTACH;

	cleanup_label = UNDO_MCS_$video;

	reason = "Opening switch " || video_data_$terminal_switch;
	call iox_$open (video_data_$terminal_iocb, Stream_input_output, ""b, error_code);

	if error_code ^= 0 then
	     go to UNDO_MCS_$video;
	call iox_$control (video_data_$terminal_iocb, "set_output_conversion", complete_tty_state.output_conversion_ptr,
	     (0));

	call iox_$control (video_data_$terminal_iocb, "set_special", complete_tty_state.special_ptr, (0));

/* RL: phx19064 - use editing chars which are current set */
	call iox_$control (video_data_$terminal_iocb, "set_editing_chars", complete_tty_state.editing_chars_ptr, (0));

	reason = "attaching ""window_io_ " || rtrim (video_data_$terminal_switch) || """";

	on sub_error_ call attach_handler (cleanup_label);

	call iox_$attach_ptr (target_iocb, "window_io_ " || rtrim (video_data_$terminal_switch), codeptr (video_utils_),
	     error_code);

	if error_code ^= 0 then
	     goto UNDO_MCS_$video;

	revert sub_error_;

	cleanup_label = UNDO_MCS_$attach;

	reason = "opening terminal switch.";
	call iox_$open (target_iocb, Stream_input_output, ""b, error_code);
	if error_code ^= 0 then
	     goto UNDO_MCS_$attach;

	cleanup_label = UNDO_MCS;

	reason = "Initializing EXL video system.";
	if video_data_$exl_video_system & ^video_data_$exl_initialized then do;
	     call use_exl_video_system$setup (error_code);
	     if error_code ^= 0 then
		goto UNDO_MCS;
	     video_data_$exl_initialized = "1"b;
	end;

	goto finished;
%page;

UNDO_MCS:
	call close_switch;
UNDO_MCS_$attach:
	call detach_switch;
UNDO_MCS_$video:
	call close_video;
MCS_REATTACH:
	call reattach;
MCS_REOPEN:
	call reopen;
UNDO_MCS_$mask:
	goto unmask_return;

%page;

mowse_network:
dcl      1 mowse_io_term_state  like mowse_io_terminal_state,
         mowse_io_term_ptr	  ptr;

	network_type = MOWSE_NETWORK_TYPE;

	mowse_io_term_ptr = addr (mowse_io_term_state);
	mowse_io_term_state.version = mowse_io_info_version_1;
	call iox_$control (target_iocb, "get_terminal_emulator_state", mowse_io_term_ptr, error_code);

	if error_code ^= 0 then do;
	     error_code = error_table_$action_not_performed;
	     reason = "Control order not performed.";
	     return;
	end;
	else if ^mowse_io_term_state.state then do;	/* MOWSE not attached			*/
	     error_code = error_table_$action_not_performed;
	     reason = "MOWSE not active.";
	     return;
	end;

	reason = "Creating switch " || video_data_$terminal_switch;
	call iox_$find_iocb (video_data_$terminal_switch, video_data_$terminal_iocb, error_code);
	if error_code ^= 0 then
	     return;

	call get_tty_state;

	call hcs_$set_ips_mask (""b, saved_ips_mask);
	call ipc_$mask_ev_calls ((0));

	cleanup_label = UNDO_MOWSE_$mask;
	on any_other call handle_any_other (cleanup_label);
						/* we could be cl_intermediary, but they get called without any state */

	reason = "Creating switch " || mowse_terminal_switch;
	call iox_$find_iocb (mowse_terminal_switch, mowse_iocb_ptr, error_code);
						/* iocb.name = mowse_terminal_		*/
	if error_code ^= 0 then
	     goto UNDO_MOWSE_$mask;

	reason = "Moving mowse attachment.";
	call iox_$move_attach (target_iocb, mowse_iocb_ptr, error_code);
						/* moving user_i/o to mowse_terminal_		*/
	if error_code ^= 0 then
	     goto UNDO_MOWSE_$mask;

	cleanup_label = UNDO_MOWSE_$move_attach;
	reason = "Attaching switch " || mowse_terminal_switch || " as tc_io_ -mowse";
	on sub_error_ call attach_handler (cleanup_label);

	call iox_$attach_ptr (video_data_$terminal_iocb, "tc_io_ -mowse " || mowse_terminal_switch,
	     codeptr (video_utils_), error_code);	/* iocb.name = user_terminal_ 		*/

	revert sub_error_;

	if error_code ^= 0 then
	     goto UNDO_MOWSE_$move_attach;

	cleanup_label = UNDO_MOWSE_$video;

	reason = "Opening switch " || video_data_$terminal_switch;
	call iox_$open (video_data_$terminal_iocb, Stream_input_output, ""b, error_code);
	if error_code ^= 0 then
	     goto UNDO_MOWSE_$video;

	call iox_$control (video_data_$terminal_iocb, "set_output_conversion", complete_tty_state.output_conversion_ptr,
	     (0));

	call iox_$control (video_data_$terminal_iocb, "set_special", complete_tty_state.special_ptr, error_code);

/* RL: phx19064 - use editing chars which are current set */
	call iox_$control (video_data_$terminal_iocb, "set_editing_chars", complete_tty_state.editing_chars_ptr, (0));

	if error_code ^= 0 then
	     goto UNDO_MOWSE_$video;

	reason = "attaching ""window_io_ " || rtrim (video_data_$terminal_switch) || """";

	on sub_error_ call attach_handler (cleanup_label);

	call iox_$attach_ptr (target_iocb, "window_io_ " || rtrim (video_data_$terminal_switch), codeptr (video_utils_),
	     error_code);				/* iocb.name = user_i/o			*/

	if error_code ^= 0 then
	     goto UNDO_MOWSE_$video;

	revert sub_error_;

	cleanup_label = UNDO_MOWSE_$attach;

	reason = "opening terminal switch.";
	call iox_$open (target_iocb, Stream_input_output, ""b, error_code);
	if error_code ^= 0 then
	     goto UNDO_MOWSE_$attach;

	cleanup_label = UNDO_MOWSE;

	reason = "Initializing EXL video system.";
	if video_data_$exl_video_system & ^video_data_$exl_initialized then do;
	     call use_exl_video_system$setup (error_code);
	     if error_code ^= 0 then
		goto UNDO_MOWSE;
	     video_data_$exl_initialized = "1"b;
	end;
	goto finished;
%page;

UNDO_MOWSE:
	call close_switch;
UNDO_MOWSE_$attach:
	call detach_switch;
UNDO_MOWSE_$video:
	call close_video;
UNDO_MOWSE_$move_attach:
	call move_attach;
	mowse_iocb_ptr = null;
UNDO_MOWSE_$mask:
	goto unmask_return;

%page;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

finished:
	revert any_other;

/* Wheeeee. we did it. */

	reason = "";
	error_code = 0;
	call iox_$modes (target_iocb, user_io_modes, "", (0));

unmask_return:
	call hcs_$reset_ips_mask (saved_ips_mask, ""b);
	call ipc_$unmask_ev_calls ((0));

	if network_type = MOWSE_NETWORK_TYPE then do;
	     call iox_$control (video_data_$terminal_iocb, "initialize_mowse_terminal", null (), error_code);
	     if error_code ^= 0 then do;
		reason = "Executing control order initialize_mowse_terminal.";
		call close_switch;
		call detach_switch;
		call close_video;
		call move_attach;
		mowse_iocb_ptr = null;
	     end;
	end;

	call iox_$control (video_data_$terminal_iocb, "quit_enable", null (), (0));

record_usage:
	call ssu_$standalone_invocation (sci_ptr, "video", video_data_$version, null (), video_utils_, (0));
	call ssu_$record_usage (sci_ptr, codeptr (video_utils_), (0));
	call ssu_$destroy_invocation (sci_ptr);



simple_error_return:
	if error_code ^= 0 then
	     video_data_$terminal_iocb = null ();	/* We may have set this, but it shouldn't be left that way if we failed to invoke video */

	return;

%page;

/* Routines that perform the basic switch operations needed */

close_switch:
     proc;

	call iox_$close (target_iocb, acode);
	if acode ^= 0 then
	     call must_kill_process (acode, "Can't close terminal switch.");

	return;

     end close_switch;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

detach_switch:
     proc;

	call iox_$detach_iocb (target_iocb, acode);
	if acode ^= 0 then
	     call must_kill_process (acode, "Can't detach terminal switch.");

	return;

     end detach_switch;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

close_video:
     proc;

	call iox_$close (video_data_$terminal_iocb, (0));
	call iox_$detach_iocb (video_data_$terminal_iocb, (0));
	call iox_$destroy_iocb (video_data_$terminal_iocb, (0));

	return;

     end close_video;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

move_attach:
     proc;

	call iox_$move_attach (mowse_iocb_ptr, target_iocb, acode);
	if acode ^= 0 then
	     call must_kill_process (acode, "Can't move attachment.");

	return;

     end move_attach;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
reattach:
     proc;

	call iox_$attach_ptr (target_iocb, "tty_ -login_channel", codeptr (video_utils_), acode);
	if acode ^= 0 then
	     call must_kill_process (acode, "Can't attach tty_");

	return;

     end reattach;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

reopen:
     proc;

	call iox_$open (target_iocb, Stream_input_output, ""b, acode);
	if acode ^= 0 then
	     call must_kill_process (acode, "Can't open terminal switch.");
	call iox_$control (target_iocb, "quit_enable", null (), (0));
	call iox_$modes (target_iocb, "default", "", (0));

	return;

     end reopen;

%page;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


turn_off_login_channel:
     entry (error_code);

/* this entry is less careful, but much more brutal ..... */

	error_code = 0;

	if video_data_$terminal_iocb = null () then
	     return;

/* Make sure that all buffered output is sent. */
	call window_$sync (iox_$user_io, (0));

	if network_type = MOWSE_NETWORK_TYPE then do;
	     fsc_info.subchannel = FG;
	     fsc_info.version = mowse_io_info_version_1;
	     call iox_$control (video_data_$terminal_iocb, "flush_subchannel", addr (fsc_info), error_code);
	end;

	saved_ips_mask = ""b;

	call hcs_$set_ips_mask (""b, saved_ips_mask);
	call ipc_$mask_ev_calls ((0));

	call window_$destroy_all (video_data_$terminal_iocb);

	if network_type = MOWSE_NETWORK_TYPE then
	     call mowse_turn_off;
	else if network_type = DSA_NETWORK_TYPE then
	     call dsa_turn_off;
	else call mcs_turn_off;

	return;

%page;

dsa_turn_off:
     proc;

	call iox_$close (target_iocb, (0));

	call iox_$detach_iocb (target_iocb, (0));

	call iox_$close (video_data_$terminal_iocb, (0));
	call iox_$detach_iocb (video_data_$terminal_iocb, (0));
	call iox_$destroy_iocb (video_data_$terminal_iocb, (0));
	video_data_$terminal_iocb = null ();
	call force_detach_hcs;

	error_code = 0;

	call iox_$attach_ptr (target_iocb, "tty_ -login_channel", codeptr (video_utils_), error_code);
	if error_code ^= 0 then
	     call must_kill_process (error_code, "Can't attach tty_");
	call iox_$open (target_iocb, Stream_input_output, ""b, error_code);
	if error_code ^= 0 then
	     call must_kill_process (error_code, "Can't open terminal switch");

	call hcs_$reset_ips_mask (saved_ips_mask, ""b);
	call ipc_$unmask_ev_calls ((0));

	if video_data_$exl_video_system & video_data_$exl_initialized then do;
	     call use_exl_video_system$cleanup ((0));
	     video_data_$exl_initialized = "0"b;
	end;

	call iox_$control (target_iocb, "quit_enable", null (), (0));

	call set_tty_state;

	return;

     end dsa_turn_off;

%page;

mcs_turn_off:
     proc;

	call iox_$close (target_iocb, (0));

	call iox_$detach_iocb (target_iocb, (0));

	call iox_$close (video_data_$terminal_iocb, (0));
	call iox_$detach_iocb (video_data_$terminal_iocb, (0));
	call iox_$destroy_iocb (video_data_$terminal_iocb, (0));
	video_data_$terminal_iocb = null ();
	call force_detach_hcs;

	error_code = 0;

	call iox_$attach_ptr (target_iocb, "tty_ -login_channel", codeptr (video_utils_), error_code);
	if error_code ^= 0 then
	     call must_kill_process (error_code, "Can't attach tty_");

	call iox_$open (target_iocb, Stream_input_output, ""b, error_code);
	if error_code ^= 0 then
	     call must_kill_process (error_code, "Can't open terminal switch");

	call hcs_$reset_ips_mask (saved_ips_mask, ""b);
	call ipc_$unmask_ev_calls ((0));

	if video_data_$exl_video_system & video_data_$exl_initialized then do;
	     call use_exl_video_system$cleanup ((0));
	     video_data_$exl_initialized = "0"b;
	end;

	call iox_$control (target_iocb, "quit_enable", null (), (0));

	call set_tty_state;

	return;

     end mcs_turn_off;

%page;

mowse_turn_off:
     proc;

	error_code = 0;

	call iox_$close (target_iocb, error_code);	/* iocb.name = user_i/o			*/
	call iox_$detach_iocb (target_iocb, error_code);
	if error_code ^= 0 then
	     call must_kill_process (error_code, "Can't detach user_terminal");

	call iox_$close (video_data_$terminal_iocb, (0));
	call iox_$detach_iocb (video_data_$terminal_iocb, (0));
	call iox_$destroy_iocb (video_data_$terminal_iocb, (0));
	video_data_$terminal_iocb = null ();

	call iox_$move_attach (mowse_iocb_ptr, target_iocb, error_code);
						/* move mowse_terminal_ to user_i/o		*/
	if error_code ^= 0 then
	     call must_kill_process (error_code, "Can't move attach mowse_terminal_");

	call hcs_$reset_ips_mask (saved_ips_mask, ""b);
	call ipc_$unmask_ev_calls ((0));

	if video_data_$exl_video_system & video_data_$exl_initialized then do;
	     call use_exl_video_system$cleanup ((0));
	     video_data_$exl_initialized = "0"b;
	end;

	return;

     end mowse_turn_off;

%page;

turn_off_for_debug:
     entry;

declare  iox_$init_standard_iocbs
			  entry;


	call hcs_$set_ips_mask (""b, ""b);		/* we will force open */

declare  unique_chars_	  entry (bit (*)) returns (character (15));
declare  u		  character (15);
declare  iocbp		  pointer;

	u = unique_chars_ (""b);
	call iox_$find_iocb (rtrim (u) || ".user_output", iocbp, (0));
	call iox_$move_attach (iox_$user_output, iocbp, (0));
	call iox_$find_iocb (rtrim (u) || ".user_input", iocbp, (0));
	call iox_$move_attach (iox_$user_input, iocbp, (0));
	call iox_$find_iocb (rtrim (u) || ".error_output", iocbp, (0));
	call iox_$move_attach (iox_$error_output, iocbp, (0));
	call iox_$find_iocb (rtrim (u) || ".user_i/o", iocbp, (0));
	call iox_$move_attach (iox_$user_io, iocbp, (0));
	call iox_$init_standard_iocbs;

	error_code = 0;

	if network_type = MOWSE_NETWORK_TYPE then do;
	     call iox_$move_attach (mowse_iocb_ptr, iox_$user_io, error_code);
	     if error_code ^= 0 then
		call must_kill_process (error_code, "Can't attach mowse_io_.");
	end;
	else do;
	     call force_detach_hcs;
	     call iox_$attach_ptr (iox_$user_io, "tty_ -login_channel", codeptr (video_utils_), error_code);
	     if error_code ^= 0 then
		call must_kill_process (error_code, "Can't attach tty_.");
	     call iox_$open (iox_$user_io, Stream_input_output, ""b, error_code);
	     if error_code ^= 0 then
		call must_kill_process (error_code, "Can't open user_io.");
	end;
	call hcs_$reset_ips_mask ((36)"1"b, ""b);
	return;

%page;

force_detach_hcs:
     procedure;

declare  user_info_$terminal_data
			  entry (char (*), char (*), char (*), fixed bin, char (*));
declare  target		  character (32);
declare  hcs_$tty_index	  entry (character (*), fixed bin, fixed bin, fixed bin (35));
declare  hcs_$tty_detach	  entry (fixed bin, fixed bin, fixed bin, fixed bin (35));
declare  dsa_tty_$index	  entry (character (*), fixed bin (35), fixed bin, fixed bin (35));
declare  dsa_tty_$detach	  entry (fixed bin (35), fixed bin, fixed bin, fixed bin (35));
declare  tty_handle		  fixed bin (35);
declare  devx		  fixed bin;

/* Now make sure we can attach tty, by cheating.
   this error_code should go away when things get more stable */

	call user_info_$terminal_data ("", "", target, (0), "");

	if network_type = DSA_NETWORK_TYPE then do;
	     call dsa_tty_$index (target, tty_handle, (0), (0));
	     call dsa_tty_$detach (tty_handle, (0), (0), (0));
	end;
	else do;					/* MCS_NETWORK_TYPE */
	     call hcs_$tty_index (target, devx, (0), (0));
	     call hcs_$tty_detach (devx, (0), (0), (0));
	end;

/* Now attaching tty_ is pretty certain to work */

     end force_detach_hcs;

%page;

must_kill_process:
     procedure (reason, why) options (non_quick);

declare  why		  character (*);
declare  reason		  fixed bin (35);

declare  terminate_process_	  entry (character (*), pointer);

declare  1 ti		  aligned,
	 2 version	  fixed bin,
	 2 status		  fixed bin (35);

	ti.version = 0;
	ti.status = reason;
	call terminate_process_ ("fatal_error", addr (ti));
     end;

%page;

attach_handler:
handle_any_other:
     procedure (return_label);

dcl      return_label	  label variable;

%include condition_info_header;
%include sub_error_info;
%include condition_info;

declare  1 ci		  aligned like condition_info;

declare  find_condition_info_	  entry (pointer, pointer, fixed binary (35));
declare  trace_stack_	  entry (pointer, fixed binary, fixed binary, character (32) aligned);

	on any_other call must_kill_process (0, "Error in error handler.");
	ci.version = 1;
	call find_condition_info_ (null (), addr (ci), (0));

	if ci.condition_name = "cleanup" then
	     return;

	begin;
declare  sw		  character (32) aligned;
declare  iocbp		  pointer;
declare  unique_chars_	  entry (bit (*)) returns (character (15));

	     sw = unique_chars_ (""b);
	     call iox_$attach_name ((sw), iocbp, "vfile_ video_dump_." || rtrim (sw), null (), (0));
	     call iox_$open (iocbp, Stream_output, ""b, (0));
	     call trace_stack_ (null (), 1 /* not -bf, but not -lg */, -1 /* all the way back */, sw);
	     call iox_$close (iocbp, (0));
	     call iox_$detach_iocb (iocbp, (0));
	     call iox_$destroy_iocb (iocbp, (0));
	end;

	if ci.condition_name = "sub_error_" then do;
	     sub_error_info_ptr = ci.info_ptr;
	     reason = rtrim (reason) || " " || rtrim (sub_error_info.name) || ": " || sub_error_info.info_string;
	     error_code = sub_error_info.status_code;
	end;
	else if ci.info_ptr ^= null then do;
	     condition_info_header_ptr = ci.info_ptr;
	     reason =
		"Unexpected " || ci.condition_name || " occured; " || condition_info_header.info_string
		|| " while " || rtrim (ltrim (reason));
	     error_code = condition_info_header.status_code;
	end;
	go to cleanup_label;
     end attach_handler;
%page;

/* This routine extracts all the useful information from the tty_ attachment
   and builds a structure which we save for later.
   When video is revoked, this data will be used to restore
   the user's former state. */

get_tty_state:
     procedure;

dcl      mode_idx		  fixed bin;
dcl      tty_modes		  char (512);
dcl      temp_ptr		  pointer;
dcl      (no_input_conversion, no_input_translation, no_output_conversion, no_output_translation)
			  bit (1) aligned;

dcl      1 auto_mode_value	  like mode_value;
dcl      1 auto_mode_string_info
			  aligned,
	 2 version	  fixed bin,
	 2 number		  fixed bin,
	 2 modes		  (8) like mode_value;	/* must be one greater than common_modes (for pl=>more) */

dcl      1 auto_editing_chars	  aligned like editing_chars;
dcl      1 auto_delay_struc	  aligned like delay_struc;
dcl      1 auto_framing_chars	  aligned like framing_chars;
dcl      1 auto_input_flow_control_info
			  aligned like input_flow_control_info;
dcl      1 auto_output_flow_control_info
			  aligned like output_flow_control_info;
dcl      1 auto_input_conversion
			  aligned like cv_trans_struc;
dcl      1 auto_input_translation
			  aligned like cv_trans_struc;
dcl      1 auto_output_conversion
			  aligned like cv_trans_struc;
dcl      1 auto_output_translation
			  aligned like cv_trans_struc;
dcl      1 auto_get_special_info_struc
			  aligned like get_special_info_struc;

/* this structure isn't in any include file */
dcl      1 framing_chars	  aligned based,
	 2 frame_begin	  char (1) unaligned,
	 2 frame_end	  char (1) unaligned;

dcl      get_system_free_area_  entry () returns (ptr);

%include tty_editing_chars;
%include tty_convert;
%include flow_control_info;

	reason = "Getting modes.";
	call iox_$modes (target_iocb, "", tty_modes, error_code);
	if error_code ^= 0 then
	     goto simple_error_return;

/* Parse the mode string to set initial values for the video
   modes that have tty_ equivalents. */

	auto_mode_string_info.version = mode_string_info_version_2;
	auto_mode_string_info.number = 0;

	mode_value_ptr = addr (auto_mode_value);
	mode_value.version = mode_value_version_3;

	do mode_idx = lbound (common_modes, 1) to hbound (common_modes, 1);
	     call mode_string_$get_mode (tty_modes, common_modes (mode_idx), mode_value_ptr, error_code);
	     if error_code = 0 then do;
		auto_mode_string_info.number = auto_mode_string_info.number + 1;
		auto_mode_string_info.modes (auto_mode_string_info.number) = mode_value;
	     end;
	end;

/* Special case more mode.  If ^pl is set, ^more will be too. */

	call mode_string_$get_mode (tty_modes, "pl", mode_value_ptr, error_code);
	if error_code = 0 then
	     if mode_value.boolean_valuep & ^mode_value.boolean_value then do;
		mode_value.mode_name = "more";
		auto_mode_string_info.number = auto_mode_string_info.number + 1;
		auto_mode_string_info.modes (auto_mode_string_info.number) = mode_value;
	     end;

/* Now build the mode string for later. */

	reason = "Building mode string.";
	call mode_string_$get (addr (auto_mode_string_info), user_io_modes, error_code);
	if error_code ^= 0 then
	     goto simple_error_return;

	auto_editing_chars.version = editing_chars_version_3;

	if network_type ^= MOWSE_NETWORK_TYPE then do;
	     reason = "Getting editing chars.";
	     call iox_$control (target_iocb, "get_editing_chars", addr (auto_editing_chars), error_code);
	     if error_code ^= 0 then
		goto simple_error_return;

	     if network_type = MCS_NETWORK_TYPE then do;
		auto_delay_struc.version = DELAY_VERSION;
		reason = "Getting delays.";
		call iox_$control (target_iocb, "get_delay", addr (auto_delay_struc), error_code);
		if error_code ^= 0 then
		     goto simple_error_return;	/* set default field to zero for later set_delay call */
		auto_delay_struc.default = 0;

		reason = "Getting framing characters.";
		call iox_$control (target_iocb, "get_framing_chars", addr (auto_framing_chars), error_code);
		if error_code ^= 0 then
		     goto simple_error_return;

		reason = "Getting input flow control characters.";
		call iox_$control (target_iocb, "get_ifc_info", addr (auto_input_flow_control_info), error_code);
		if error_code ^= 0 then
		     goto simple_error_return;

		reason = "Getting output flow control characters.";
		call iox_$control (target_iocb, "get_ofc_info", addr (auto_output_flow_control_info), error_code);
		if error_code ^= 0 then
		     goto simple_error_return;
	     end;
	end;

	auto_input_conversion.version = CV_TRANS_VERSION;
	auto_input_translation.version = CV_TRANS_VERSION;
	auto_output_conversion.version = CV_TRANS_VERSION;
	auto_output_translation.version = CV_TRANS_VERSION;

	auto_input_conversion.default = 0;
	auto_input_translation.default = 0;
	auto_output_conversion.default = 0;
	auto_output_translation.default = 0;

	no_input_conversion = "0"b;
	no_input_translation = "0"b;
	no_output_conversion = "0"b;
	no_output_translation = "0"b;

	if network_type ^= MOWSE_NETWORK_TYPE then do;
	     reason = "Getting input conversions.";
	     call iox_$control (target_iocb, "get_input_conversion", addr (auto_input_conversion), error_code);
	     if error_code ^= 0 then
		if error_code = error_table_$no_table then
		     no_input_conversion = "1"b;
		else goto simple_error_return;

	     reason = "Getting input translations.";
	     call iox_$control (target_iocb, "get_input_translation", addr (auto_input_translation), error_code);
	     if error_code ^= 0 then
		if error_code = error_table_$no_table then
		     no_input_translation = "1"b;
		else goto simple_error_return;
	end;

	reason = "Getting output conversions.";
	call iox_$control (target_iocb, "get_output_conversion", addr (auto_output_conversion), error_code);
	if error_code ^= 0 then
	     if error_code = error_table_$no_table then
		no_output_conversion = "1"b;
	     else goto simple_error_return;

	reason = "Getting output translations.";
	call iox_$control (target_iocb, "get_output_translation", addr (auto_output_translation), error_code);
	if error_code ^= 0 then
	     if error_code = error_table_$no_table then
		no_output_translation = "1"b;
	     else goto simple_error_return;

	reason = "Getting special table.";
	auto_get_special_info_struc.version = SPECIAL_INFO_STRUCT_VERSION_1;
	auto_get_special_info_struc.area_ptr = get_system_free_area_ ();
	call iox_$control (target_iocb, "get_special", addr (auto_get_special_info_struc), error_code);
	if error_code ^= 0 then
	     goto simple_error_return;

/* Now that all state has been read out of tty_, save it. */

	allocate complete_tty_state set (complete_tty_state_ptr);

	complete_tty_state.modes_string = tty_modes;

	allocate editing_chars set (temp_ptr);
	temp_ptr -> editing_chars = auto_editing_chars;
	complete_tty_state.editing_chars_ptr = temp_ptr;

	if network_type = MCS_NETWORK_TYPE then do;

	     allocate delay_struc set (temp_ptr);
	     temp_ptr -> delay_struc = auto_delay_struc;
	     complete_tty_state.delay_ptr = temp_ptr;

	     allocate framing_chars set (temp_ptr);
	     temp_ptr -> framing_chars = auto_framing_chars;
	     complete_tty_state.framing_chars_ptr = temp_ptr;

	     allocate input_flow_control_info set (temp_ptr);
	     temp_ptr -> input_flow_control_info = auto_input_flow_control_info;
	     complete_tty_state.ifc_ptr = temp_ptr;

	     allocate output_flow_control_info set (temp_ptr);
	     temp_ptr -> output_flow_control_info = auto_output_flow_control_info;
	     complete_tty_state.ofc_ptr = temp_ptr;
	end;

	if no_input_conversion then
	     complete_tty_state.input_conversion_ptr = null ();
	else do;
	     allocate cv_trans_struc set (temp_ptr);
	     temp_ptr -> cv_trans_struc = auto_input_conversion;
	     complete_tty_state.input_conversion_ptr = temp_ptr;
	end;

	if no_input_translation then
	     complete_tty_state.input_translation_ptr = null ();
	else do;
	     allocate cv_trans_struc set (temp_ptr);
	     temp_ptr -> cv_trans_struc = auto_input_translation;
	     complete_tty_state.input_translation_ptr = temp_ptr;
	end;

	if no_output_conversion then
	     complete_tty_state.output_conversion_ptr = null ();
	else do;
	     allocate cv_trans_struc set (temp_ptr);
	     temp_ptr -> cv_trans_struc = auto_output_conversion;
	     complete_tty_state.output_conversion_ptr = temp_ptr;
	end;

	if no_output_translation then
	     complete_tty_state.output_translation_ptr = null ();
	else do;
	     allocate cv_trans_struc set (temp_ptr);
	     temp_ptr -> cv_trans_struc = auto_output_translation;
	     complete_tty_state.output_translation_ptr = temp_ptr;
	end;

/* The special structure was allocated earlier. */
	complete_tty_state.special_ptr = auto_get_special_info_struc.table_ptr;

	return;

set_tty_state:
     entry;

/* This entry counts on not getting this far unless video has been
   invoked by turn_on_login_channel. */

	call iox_$modes (target_iocb, complete_tty_state.modes_string, (""), (0));

	call iox_$control (target_iocb, "set_editing_chars", complete_tty_state.editing_chars_ptr, (0));
	free complete_tty_state.editing_chars_ptr -> editing_chars;

	if network_type = MCS_NETWORK_TYPE then do;

	     call iox_$control (target_iocb, "set_delay", complete_tty_state.delay_ptr, (0));
	     free complete_tty_state.delay_ptr -> delay_struc;

	     call iox_$control (target_iocb, "set_framing_chars", complete_tty_state.framing_chars_ptr, (0));
	     free complete_tty_state.framing_chars_ptr -> framing_chars;

	     call iox_$control (target_iocb, "input_flow_control_chars", complete_tty_state.ifc_ptr, (0));
	     free complete_tty_state.ifc_ptr -> input_flow_control_info;

	     call iox_$control (target_iocb, "output_flow_control_chars", complete_tty_state.ofc_ptr, (0));
	     free complete_tty_state.ofc_ptr -> output_flow_control_info;
	end;

	if complete_tty_state.input_conversion_ptr ^= null () then do;
	     call iox_$control (target_iocb, "set_input_conversion", complete_tty_state.input_conversion_ptr, (0));
	     free complete_tty_state.input_conversion_ptr -> cv_trans_struc;
	end;

	if complete_tty_state.input_translation_ptr ^= null () then do;
	     call iox_$control (target_iocb, "set_input_translation", complete_tty_state.input_translation_ptr, (0));
	     free complete_tty_state.input_translation_ptr -> cv_trans_struc;
	end;

	if complete_tty_state.output_conversion_ptr ^= null () then do;
	     call iox_$control (target_iocb, "set_output_conversion", complete_tty_state.output_conversion_ptr, (0));
	     free complete_tty_state.output_conversion_ptr -> cv_trans_struc;
	end;

	if complete_tty_state.output_translation_ptr ^= null () then do;
	     call iox_$control (target_iocb, "set_output_translation", complete_tty_state.output_translation_ptr, (0));
	     free complete_tty_state.output_translation_ptr -> cv_trans_struc;
	end;

	call iox_$control (target_iocb, "set_special", complete_tty_state.special_ptr, (0));
	free complete_tty_state.special_ptr -> special_chars_struc;

	free complete_tty_state_ptr -> complete_tty_state;

	return;
     end get_tty_state;

%page;

network_login_channel:
     entry (targetp, networkp, codep);

dcl      targetp		  ptr parm,
         networkp		  fixed bin (4) unsigned parm,
         codep		  fixed bin (35) parm;

dcl      Pmowse		  ptr;

	targetp = null;
	networkp = 0;
	codep = 0;

	targetp = find_appropriate_iocb ("mowse_io_", "mowse_tty");
						/* iocb.name = mowse_i/o			*/
	if targetp ^= null then do;			/* determine if its attached on login_channel	*/
	     targetp = targetp -> iocb.syn_son;		/* syned iocb; iocb.name = user_i/o		*/

	     Pmowse = find_appropriate_iocb ("tty_", "-login_channel");
						/* iocb.name = mowse_tty			*/
	     if Pmowse ^= null then do;
		networkp = MOWSE_NETWORK_TYPE;
		return;
	     end;
	end;

	targetp = find_appropriate_iocb ("tty_", "-login_channel");
	if targetp = null () then do;
	     codep = error_table_$action_not_performed;
	     reason = "No tty_ attachment found.";
	     return;
	end;
	call iox_$control (targetp, "get_network_type", addr (networkp), codep);
	if codep = error_table_$undefined_order_request then do;
	     networkp = MCS_NETWORK_TYPE;		/* MCS doesn't support this operation */
	     codep = 0;
	end;
	else if codep = 0 then do;
	     if networkp ^= MCS_NETWORK_TYPE & networkp ^= DSA_NETWORK_TYPE & networkp ^= MOWSE_NETWORK_TYPE then do;
		codep = error_table_$action_not_performed;
		reason = "Invalid network type.";
		return;
	     end;
	end;
	else do;
	     reason = "Unable to get network type.";
	     return;
	end;

	return;

%page;

find_appropriate_iocb:
     procedure (dim_name, dim_arg) returns (pointer);

%include iocb;

declare  dim_name		  char (*) parameter,
         dim_arg		  char (*) parameter,
         iocb_ptr		  pointer,
         n		  fixed binary,
         based_vcs		  char (256) varying based,
         descrip		  char (256) varying,
         dim_lth		  fixed bin,
         error		  fixed bin (35);

	dim_lth = length (dim_name) + 1;
	error = 0;
	do n = 1 by 1 while (error = 0);
	     call iox_$find_iocb_n (n, iocb_ptr, error);
	     if error = 0 then do;
		if iocb_ptr -> iocb.attach_descrip_ptr ^= null () then do;
		     descrip = iocb_ptr -> iocb.attach_descrip_ptr -> based_vcs;
		     if substr (descrip, 1, min (length (descrip), dim_lth)) = dim_name
			& index (descrip, dim_arg) ^= 0 then
			return (iocb_ptr);
		end;
	     end;
	end;

	return (null ());

     end find_appropriate_iocb;
%page;
%include iocbx;
%page;
%include tty_attach_data_;
%page;
%include net_event_message;
%page;
%include iox_entries;
%page;
%include iox_modes;
%page;
%include window_dcls;
%page;
%include mode_string_info;
%page;
%include tty_editing_chars;
%page;
%include mowse_io_control_info;
%page;
%include mowse_messages;
%page;
%include mowse;


     end video_utils_;
