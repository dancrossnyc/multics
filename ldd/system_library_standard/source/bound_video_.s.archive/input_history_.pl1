
/****^  HISTORY COMMENTS:
  1) change(2016-03-27,GDixon), approve(2016-06-12,MCR10013),
     audit(2016-06-12,Swenson), install(2017-02-19,MR12.6f-0017):
     Initial version of I/O module, patterned after audit_.pl1.
  2) change(2016-05-09,GDixon), approve(2016-06-12,MCR10013),
     audit(2016-06-12,Swenson), install(2017-02-19,MR12.6f-0017):
     Version 2 adds line editor request for reverse and forward incremental
     searching through history segment lines.
  3) change(2016-05-16,GDixon), approve(2016-06-12,MCR10013),
     audit(2016-06-12,Swenson), install(2017-02-19,MR12.6f-0017):
     Version 3 adds -perprocess and -permanent attach options.
  4) change(2017-02-19,GDixon), approve(2017-02-19,MCR10032),
     audit(2017-02-19,Swenson), install(2017-02-19,MR12.6f-0017):
     Version 4 corrects a problem in counting lines in the USER_NAME.history
     segment when the segment ends with an incomplete line (one not ending in
     NL char).  For details, see:
       http://multics-trac.swenson.org/ticket/49
                                                   END HISTORY COMMENTS */

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name: input_history_							        */
	/*									        */
	/* Function: An I/O module that captures each input line in a history file (USER_NAME.history).   */
	/* When used in conjunction with the video system (window_io_ I/O module), it adds key bindings   */
	/* to the window_io_ line editor to select a prior input line for editing and reinput.	        */
	/*									        */
	/* Functions for selecting a prior input line are bound to the traditional Emacs keystrokes:      */
	/*   ^P    selects the previous input line from the history file.			        */
	/*   ^N    selects the next input line from the history file.			        */
	/*   ^R    reverse-search (a backward incremental search) through the history file looking for    */
	/*	 an input line matching a given search string.				        */
	/*   ^S    forward-search (an increment search) through the history file looking for an input     */
	/*	 line matching a given search string.					        */
	/*   ^G    abort selection of a prior input line; redisplay original window_io_ line editor       */
	/*	 buffer.								        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

input_history_:
     proc;

  /* Constants */
  dcl  DEBUG_BANNER char(19) int static options(constant) init(" ==> INPUT_HISTORY_");
  dcl  INFO_DIR char(9) int static options(constant) init(">doc>info");
  dcl  INFO_SEG char(16) int static options(constant) init("video_editing.gi");
  dcl  PROC char(14) int static options(constant) init("input_history_");
  dcl  SEG_SUFFIX      char(7) int static options(constant) init("history");
  dcl  SEG_LOCK_SUFFIX char(7) int static options(constant) init("hisLock");
  dcl  VERSION char(8) int static options(constant) init("ih_04.00");
  dcl  ZEROb bit(1) aligned options(constant) int static init("0"b);

  /* Collate Char Constants */
  dcl  BEL char(1) int static options(constant) init("");
  dcl  DEL char(1) int static options(constant) init("");
  dcl  HT  char(1) int static options(constant) init("	");
  dcl  NL  char(1) int static options(constant) init("
");
  dcl  SP  char(1) int static options(constant) init(" ");

  /* Flag Constants */
  dcl  BLOCK bit(1) aligned int static options(constant) init("1"b);
  dcl (FALSE init("0"b), TRUE init("1"b)) bit(1) aligned int static options(constant);
  dcl (FORWARD init(1), REVERSE init(-1)) fixed bin(1) int static options(constant);  
  dcl (OFF init("0"b), ON init("1"b)) bit(1) int static options(constant);  
  dcl (PERMANENT init("0"b), TEMPORARY init("1"b)) bit(1) int static options(constant);  

  /* Subroutines used in multiple sections of code */
  dcl  com_err_ entry() options(variable);
  dcl  hcs_$reset_ips_mask entry (bit(36) aligned, bit(36) aligned);
  dcl  hcs_$set_ips_mask entry (bit(36) aligned, bit(36) aligned);
  dcl  ioa_ entry() options(variable);
  dcl  ioa_$ioa_switch entry() options(variable);
  dcl  iox_$propagate entry (ptr);

  /* External Variables */
  dcl (error_table_$action_not_performed,
       error_table_$bad_arg,
       error_table_$bad_conversion,
       error_table_$empty_file,
       error_table_$inconsistent,
       error_table_$invalid_lock_reset, 
       error_table_$locked_by_this_process, 
       error_table_$lock_not_locked,
       error_table_$no_iocb,
       error_table_$noalloc,
       error_table_$noarg,
       error_table_$not_attached,
       error_table_$not_detached,
       error_table_$noentry,
       error_table_$too_many_args,
       error_table_$unimplemented_version
		     ) fixed bin(35) ext static;

  dcl (iox_$err_no_operation
                         ) entry() options(variable);
  dcl  iox_$user_io ptr ext static;
     
  /* Builtins */
  dcl (addcharno, before, binary, char, charno, dimension, hbound, index, lbound, length,
       ltrim, min, null, onsource, rtrim, size, substr, rank, verify) builtin;
%page;
%include input_history_data;
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name: input_history_$input_history_attach					        */
	/*									        */
	/* Attach Description:							        */
	/*									        */
	/*    input_history_ monitored_switch_name {-control_args}				        */
	/*									        */
	/* Arguments:								        */
	/*									        */
	/* monitored_switch_name							        */
	/*    is the name of an I/O switch whose input lines are captured.  It		        */
	/*    must be attached to an I/O module open with an opening mode of			        */
	/*    stream_input or stream_input_output.					        */
	/*									        */
	/* Control Arguments:							        */
	/*									        */
	/* -pathname PATH, -pn PATH							        */
	/*    use PATH as the location of the history file.  The default PATH is:		        */
	/*      [homedir]>[user name].history						        */
	/* -perprocess, -pp								        */
	/*    use a temporary history file created in the process directory.			        */
	/* -permanent, -perm							        */
	/*    use only a permanent the history file.  See "Notes on the pathname arguments" in the        */
	/*    parms_from_attach_options procedure (below).				        */
	/*									        */
	/* -lines N, -ln N								        */
	/*    recommends a size for the history segment, in lines.  The default N is 200 lines	        */
	/*    (about 2 pages long, if input lines are 40 characters long, on average).		        */
	/* -truncate, -tc								        */
	/*    truncates the history file, if it already exists.  The default is to extend an existing     */
	/*    file.								        */
	/* -debug, -db								        */
	/*    traces operations on the history file.  (See also control op: set_input_history_debug)      */
	/*									        */
	/* For more details, see: input_history_.info					        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

input_history_attach:
     entry (p_iocbP, p_options, com_err_S, p_code);

  dcl  p_iocbP ptr;					/* Attach the I/O module to this target IOCB.	        */
  dcl  p_options (*) char(*) var;			/* Attachment options for the I/O module.	        */
  dcl  com_err_S bit(1) aligned;			/* Diagnose attach errors through com_err_.	        */
  dcl  p_code fixed bin(35);				/* Return code diagnosing problem(s) with attach attempt. */

  dcl  iocbP ptr;
     iocbP = p_iocbP;				/* Get local copy of pointer to our IOCB	        */

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Initialize variables, to permit proper cleanup in case of attach error.		        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

     p_code = 0;					/* Initialize our status code.		        */
     ihDataP = null();				/* Pointer to attach data used by input_history_ module.  */
						/*  (Declared in: input_history_.incl.pl1)	        */


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* input_history_ uses two methods for obtaining its attach options:			        */
	/*  1) The normal method involves use of iox_$attach_ptr or iox_$attach_loud, both of which call  */
	/*     this input_history_attach entrypoint: the first with com_err_S off; the second with it on. */
	/*  2) The pre-validation method involves a prior call directly to			        */
	/*     input_history_$validate_attach_options before calling with the normal method (1).	        */
	/*									        */
	/* The pre-validation method is needed because input_history_ is designed to be attached to the   */
	/* user_i/o switch.  The input_history command coordinates this attach operation.  Prior to the   */
	/* iox_$attach_ptr operation, this command has moved the attachment from user_i/o to the	        */
	/* monitored_switch; and user_i/o is unattached.  This prevents the input_history_ attach	        */
	/* operation from displaying detailed errors or warnings encountered during attachment.	        */
	/*									        */
	/* input_history command circumvents this problem by using method 2 before it moves the user_i/o  */
	/* attachment to the monitored_switch.						        */
	/*									        */
	/* It calls input_history_$validate_attach_options to check attributes of an existing, permanent  */
	/* history segment; and to create a new (permanent or per-process) history segment, if needed.    */
	/* Since user_i/o is still attached through window_io_ to the terminal, explicit error messages   */
	/* are possible to diagnose problems, or to warn the user of a locked permanent history segment,  */
	/* or of creation of a temporary history segment, etc.				        */
	/*									        */
	/* validate_attach_options ends by storing the attach_data (ihData structure) in the iocb_dict    */
	/* cache, before returning to the input_history_ command.				        */
	/*									        */
	/* After a successful validation, the input_history command knows the attachment will succeed;    */
	/* so it can safely move the user_i/o attachment to the monitored_switch, and call	        */
	/* iox_$attach_ptr to complete attachment of input_history_ to the user_i/o switch in the normal  */
	/* (method 1) way.								        */
	/*									        */
	/* When input_history calls iox_$attach_ptr call, the input_history_attach operation extracts the */
	/* cached ihData structure from its iocb_dict cache, instead of reparsing the attach options;     */
          /* it then completes the attachment to user_i/o.					        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

     if dimension(p_options,1) = 0 then do;		/* Make sure at least monitored_switch_name attach option */
	p_code = error_table_$noarg;			/*  is given.				        */
	if com_err_S then call com_err_ (p_code, PROC, "Missing monitored_switch_name attach argument." );
	go to EXIT_attach;
	end;
     if iocbP->iocb.name = "user_i/o" then do;		/* input_history command is attaching user_i/o?	        */
	ihDataP = iocb_dict_get (iox_$user_io);		/*  - If so, we will find attach data from its earlier    */
	if ihDataP ^= null() then do;	 		/*    call to input_history_$validate_attach_options.     */
	     call iocb_dict_clear (iox_$user_io);	/*     - Remove the found attach data from cache.	        */
	     ihData.history_iocbP = iocbP;		/*     - Set history_iocbP to the correct value, which    */
	     end;					/*       was not known for certain by 		        */
	end;					/*       validate_attach_options.		        */

     if ihDataP = null() then				/* Otherwise, parse attach options to get attach data.    */
	call ihData_from_attach_options (PROC, iocbP, "", p_options, com_err_S, ihDataP, p_code);
     if ihDataP = null() then go to EXIT_attach;		/*  - Exit if attach data is not available.	        */

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* CRITICAL SECTION of CODE: Prevent interrupts while we setup attachments.  This follows	        */
	/*                           guidelines in "Writing an I/O Module", MPM Subsystem Writer's Guide  */
	/*  - Ensure our iocb is not already attached.					        */
	/*  - Set our iocb attach data and I/O operations.				        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

  dcl  mask bit(36) aligned;				/* Saved ips mask, so we can restore later.	        */
     
     call hcs_$set_ips_mask (""b, mask);		/* Mask interrupts to protect critical section.	        */
     if iocbP -> iocb.attach_descrip_ptr ^= null() then do;
	call hcs_$reset_ips_mask (mask, mask);		/* If our I/O switch is attached, we cannot alter that    */
						/*  attachment.  Unmask and report error.	        */
	p_code = error_table_$not_detached;
	if com_err_S then
	     call com_err_ (p_code, PROC, "Cannot attach ^a module to switch: ^a", PROC, iocbP->iocb.name);
	go to EXIT_attach;
	end;
     
     iocbP->iocb.attach_descrip_ptr = addr(ihData.attach_descrip);
     iocbP->iocb.attach_data_ptr = ihDataP;
     iocbP->iocb.detach_iocb = ih_detach;
     iocbP->iocb.open = iox_$err_no_operation;
     iocbP->iocb.close = ih_close;
     

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* CRITICAL SECTION (continues):						        */
	/*  - Open the I/O switch now.						        */
	/*      RULE:  iox_$open is not called for switches that monitor another switch.	        */
	/*             Like syn_ attachments, they insert themselves into I/O switch hierarchy in a       */
	/*             stealthy fashion.						        */
	/*  - Fill in open portion of our ihData structure, and our IOCB.  input_history_:	        */
	/*     - monitors get_line to capture input lines.				        */
	/*     - fields control, to handle its own controls; other control operations are pass-thru.      */
	/*     - pass-thru get_chars, put_chars, position, modes				        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

     iocbP->iocb.open_descrip_ptr = addr(ihData.open_descrip);
     iocbP->iocb.get_line  = ih_get_line;
     iocbP->iocb.get_chars = ih_get_chars;
     iocbP->iocb.control   = ih_control;
     iocbP->iocb.modes     = ih_modes;
     iocbP->iocb.position  = ih_position;

     if ihData.open_descrip = "stream_input_output" then
	iocbP->iocb.put_chars = ih_put_chars;
     else iocbP->iocb.put_chars = iox_$err_no_operation;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* CRITICAL SECTION (ends):							        */
	/*  - Propagate changes made to our IOCB.					        */
	/*  - Unmask interrupts.							        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

     call iox_$propagate (iocbP);
     call hcs_$reset_ips_mask (mask, mask);		/* Unmask interrupts.			        */

     if ihData.hist.debug then
	call ioa_$ioa_switch(ihData.source_iocbP,
	     "^a: attach operation complete.", DEBUG_BANNER);


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* If we are monitoring an IOCB attached to window_io_, then install keybindings for our input    */
	/* line editor requests.							        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

  dcl 1 lekbi aligned like line_editor_key_binding_info based(lekbiP);
  dcl  lekbiP ptr;

     if ihData.source_is_window_io_ then do;

  dcl  ihLineEditorKeySeqs (5) char(4) var int static options(constant) 
	init("", "", "", "", "");			
	/*     ^P      ^N      ^R      ^S      ^G              Edit Key Sequences implemented by input_history_       */

	ihData.savedKeyBindingsP = lineEditorKeyBindings_get (source_iocbP, ihLineEditorKeySeqs);

	lekbiP = lineEditorKeyBindings_alloc(ihLineEditorKeySeqs);
	
	lekbi.bindings(1).editor_routine = ih_previous_line;
	lekbi.bindings(1).name	   = "PREVIOUS_LINE";
	lekbi.bindings(1).description	   = "Replaces the input line with the previous line from the input history.";

	lekbi.bindings(2).editor_routine = ih_next_line;
	lekbi.bindings(2).name	   = "NEXT_LINE";
	lekbi.bindings(2).description	   = "Replaces the input line with the next line from the input history.";

	lekbi.bindings(3).editor_routine = ih_reverse_search;
	lekbi.bindings(3).name	   = "REVERSE_SEARCH";
	lekbi.bindings(3).description	   = 
	     "Incrementally searches backward through input history for the search string that follows ^R.";
	lekbi.bindings(3).numarg_action  = IGNORE;
	
	lekbi.bindings(4).editor_routine = ih_forward_search;
	lekbi.bindings(4).name	   = "FORWARD_SEARCH";
	lekbi.bindings(4).description	   = 
	     "Incrementally searches forward through input history for the search string that follows ^S.";
	lekbi.bindings(4).numarg_action  = IGNORE;

	lekbi.bindings(5).editor_routine = ih_selection_abort;
	lekbi.bindings(5).name	   = "HISTORY_LINE_ABORT";
	lekbi.bindings(5).description	   = 
	     "Aborts selection of an input history line for re-input.";
	lekbi.bindings(5).numarg_action  = IGNORE;
	
	call lineEditorKeyBindings_set (source_iocbP, lekbiP);
	free lekbi in (ihArea);

	call iocb_dict_set(source_iocbP->iocb.actual_iocb_ptr, addr(ihData));
						/* Save association of this source_iocbP with ihDataP     */
						/*  from this attachment in the iocb_dict cache.	        */
						/*  Edit routines will get their ihDataP from the cache.  */
	if ihData.hist.debug then
	     call ioa_$ioa_switch(ihData.source_iocbP,
	          "^a:   window_io_ line editor requests installed.", DEBUG_BANNER);
	end;

     return;					/* Attach operation ends successfully.		        */
     

EXIT_attach:					/* Attach exits after error was encountered.	        */
						/*  - p_code already set before getting here.	        */
     if ihDataP ^= null then				/*  - Free any allocated data.		        */
	free ihData in (ihArea);
     return;
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Names: lineEditorKeyBindings_get, _alloc, _set; lineEditorMaxSeqL			        */
	/*									        */
	/* Functions: These are routines to get current window_io_ line editor key bindings for keys to   */
	/* which we want to tie our history line selection editing functions; allocate a structure to     */
	/* define our key bindings; setup those key bindings (and restore the original key bindings when  */
	/* this I/O module is detached); and determine number of key bindings we are actually replacing.  */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

lineEditorKeyBindings_get:
     proc (iocbP, keySeqs) returns(ptr);

  dcl  iocbP ptr;					/* Pointer to window_io_ IOCB.		        */
  dcl  keySeqs (*) char(4) var;			/* Array of key sequences whose bindings (to functions)   */
						/*  is to be saved (or set, in other entrypoints).        */
  dcl  save_locationP ptr;				/* Pointer to prior editor request key bindings which we  */
						/*  save, so they can be restored at detach time.	        */

  dcl 1 gekbi aligned like get_editor_key_bindings_info;	/* Get current key bindings for our requests.  (Most are  */
						/*  mapped to SELF_INSERT.			        */
     gekbi.version = get_editor_key_bindings_info_version_1;
     unspec(gekbi.flags) = ZEROb;
     gekbi.key_binding_info_ptr = lineEditorKeyBindings_alloc(keySeqs);
     gekbi.entire_state_ptr = null();


  dcl  ignoreCode fixed bin(35);

     call iox_$control (iocbP, "get_editor_key_bindings", addr(gekbi), ignoreCode);

     return (gekbi.key_binding_info_ptr);		/* Caller should eventually free storage pointed to.      */

     end lineEditorKeyBindings_get;


lineEditorKeyBindings_alloc:
     proc (keySeqs) returns(ptr);
     
  dcl  keySeqs (*) char(4) var;			/* Array of key sequences whose bindings (to functions)   */
						/*  is to be saved (or set, in other entrypoints).        */

  dcl 1 lekbi aligned like line_editor_key_binding_info based(lekbiP);
  dcl  lekbiP ptr;

     line_editor_binding_count = dimension(keySeqs,1);
     line_editor_longest_sequence = lineEditorMaxSeqL(keySeqs);
     
     allocate lekbi in (ihArea);
     lekbi.version = line_editor_key_binding_info_version_3;
     lekbi.bindings(*).sequence = keySeqs(*);
     lekbi.bindings(*).action   = EXTERNAL_ROUTINE;
     lekbi.bindings(*).numarg_action = PASS;
     lekbi.bindings(*).name = "";
     lekbi.bindings(*).description = "";
     lekbi.bindings(*).info_dir = INFO_DIR;
     lekbi.bindings(*).info_entry = INFO_SEG;
     return(lekbiP);

     end lineEditorKeyBindings_alloc;


lineEditorMaxSeqL:
     proc (keySeqs) returns(fixed bin);
     
  dcl  keySeqs (*) char(4) var;			/* Array of key sequences whose bindings (to functions)   */
						/*  is to be saved (or set, in other entrypoints).        */

  dcl  l fixed bin init(1);				/* Minimum sequence length.			        */
  dcl  i fixed bin;
  
     do i = lbound(keySeqs,1) to hbound(keySeqs,1);
	l = max(l, length(keySeqs(i)));
	end;
     return (l);

     end lineEditorMaxSeqL;

%page;
lineEditorKeyBindings_set:
     proc (iocbP, keyBindingInfoP);

  dcl  iocbP ptr;					/* Pointer to window_io_ IOCB.		        */
  dcl  keyBindingInfoP ptr;				/* ptr to line_editor_key_binding_info structure 	        */
						/*  describing the key sequences to be bound, and their   */
						/*  target editor requests.			        */
  dcl  ignoreCode fixed bin(35);

  dcl 1 sekbi aligned like set_editor_key_bindings_info;
     
     sekbi.version = set_editor_key_bindings_info_version_1;
     unspec(sekbi.flags) = ZEROb;
     sekbi.update = TRUE;
     sekbi.key_binding_info_ptr = keyBindingInfoP;
     
     call iox_$control (iocbP, "set_editor_key_bindings", addr(sekbi), ignoreCode);

     end lineEditorKeyBindings_set;

%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name: input_history_$ih_get_line						        */
	/*									        */
	/* Function: This is mostly a pass-thru routine.  However, each line (or line fragment) read      */
	/* from the source_iocb is appended to the History Segment, as well as being returned to our      */
	/* caller.  Our editing routines must worry about whether final line in History Segment is a      */
	/* complete line (ends with NL), or just a fragment of a long line that is being read via	        */
	/* iox_$get_line in pieces.							        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

ih_get_line:
    entry (p_iocbP, p_bufferP, p_bufferL, p_readL, p_code);

  dcl  p_bufferP ptr;
  dcl  p_bufferL fixed bin(21);
  dcl  p_readL fixed bin(21);
    
  dcl  p_read char(p_readL) based(p_bufferP);

  dcl  iox_$get_line entry (ptr, ptr, fixed bin(21), fixed bin(21), fixed bin(35));

     iocbP   = p_iocbP->iocb.actual_iocb_ptr;
     ihDataP = iocbP->iocb.attach_data_ptr;
     source_iocbP = ihData.source_iocbP;

     call iox_$get_line (source_iocbP, p_bufferP, p_bufferL, p_readL, p_code);
     if p_readL > 0 then do;
	call hSeg_get (ihData, p_code);
	if p_code = 0 then do;
	     call hSeg_append_chars (ihData.hist.segmentData, p_read, PERMANENT);
	     call hSeg_set_length   (ihData.hist.segmentData, ihData.segL);
	     end;
	ihData.edit.currentLine = END_OF_HISTORY;	/* We start out positioned after last line of History     */
	end;					/*  Segment each time get_line is called.  That way, a    */
						/*  previous_line request would position to the line just */
						/*  appended to the History Segment.		        */
     return;

%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name: input_history_$ih_get_chars						        */
	/*									        */
	/* Function:  This is a pass-thru entry directly to our source_iocb.			        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

ih_get_chars:
    entry (p_iocbP, p_bufferP, p_bufferL, p_readL, p_code);

  dcl  iox_$get_chars entry (ptr, ptr, fixed bin(21), fixed bin(21), fixed bin(35));
    
     iocbP   = p_iocbP->iocb.actual_iocb_ptr;
     ihDataP = iocbP->iocb.attach_data_ptr;
     source_iocbP = ihData.source_iocbP;

     call iox_$get_chars (source_iocbP, p_bufferP, p_bufferL, p_readL, p_code);
     return;


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name: input_history_$ih_put_chars						        */
	/*									        */
	/* Function:  This is a pass-thru entry directly to our source_iocb.			        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

ih_put_chars:
    entry (p_iocbP, p_bufferP, p_bufferL, p_code);

  dcl  iox_$put_chars entry (ptr, ptr, fixed bin(21), fixed bin(35));

     iocbP   = p_iocbP->iocb.actual_iocb_ptr;
     ihDataP = iocbP->iocb.attach_data_ptr;
     source_iocbP = ihData.source_iocbP;

     call iox_$put_chars (source_iocbP, p_bufferP, p_bufferL, p_code);
     return;
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name: input_history_$ih_control						        */
	/*									        */
	/* Function:  Implement control operations defined by the input_history_ I/O module, or else      */
	/* pass them along to the monitored I/O switch for its implementation.		        */
	/*									        */
	/* Control Operations:							        */
	/*									        */
	/* The following operations are implemented by input_history_.  All other operations are passed   */
	/* through to the monitored I/O switch (presumably window_io_).			        */
	/*									        */
	/* get_input_history_lines							        */
	/*   returns the recommended size of the history segment, in lines.  This was set originally to   */
	/*   the value given in the -lines N attach option.  It may subsequently be changed by the        */
	/*   set_input_history_lines control order.  info_ptr points to the following variable:	        */
	/*									        */
	/*      dcl linesN fixed bin(21) based(info_ptr);					        */
	/*									        */
	/* set_input_history_lines							        */
	/*   provides a new value for the recommended size of the history segment, in lines.  info_ptr    */
	/*   points to the following variable:						        */
	/*									        */
	/*      dcl linesN fixed bin(21) based(info_ptr);					        */
	/*									        */
	/* get_input_history_data							        */
	/*   returns a copy of the internal data used by the input_history_ I/O module for this	        */
	/*   attachment.  info_ptr points to the structure declared in input_history_data.incl.pl1 file.  */
	/*									        */
	/* set_input_history_debug							        */
	/*   changes setting of (hidden) -debug attach option while the I/O module is attached.	        */
	/*   info_ptr points to the following variable:					        */
	/*									        */
	/*      dcl debug_setting bit(1) aligned based(info_ptr);				        */
	/*									        */
	/* get_input_history_version							        */
	/*   gets current version identifier for this I/O module.  info_ptr points to the following       */
	/*   variable:								        */
	/*									        */
	/*      dcl version char(20) varying based(info_ptr);				        */
	/*									        */
	/* All of these controls may be invoked programmatically, or via the io_call command/active       */
	/* function.								        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

ih_control:
     entry (p_iocbP, p_order, p_infoP, p_code);
     
  dcl  p_order char(*);
  dcl  p_infoP ptr;
  
  dcl  based_linesN fixed bin(21) based(p_infoP);
  dcl  based_bool bit(1) aligned based(p_infoP);
  dcl  based_version char(20) varying based(p_infoP);

  dcl  iox_$control entry (ptr, char(*), ptr, fixed bin(35));

     iocbP   = p_iocbP->iocb.actual_iocb_ptr;
     ihDataP = iocbP->iocb.attach_data_ptr;
     source_iocbP = ihData.source_iocbP;

     if p_order = "get_input_history_lines" then
	based_linesN = ihData.limit_linesN;

     else if p_order = "set_input_history_lines" then
	ihData.limit_linesN = based_linesN;
     
     else if p_order = "get_input_history_data" then
	p_infoP -> ihData = ihData;

     else if p_order = "set_input_history_debug" then
	ihData.hist.segmentData.debug = based_bool;
     
     else if p_order = "get_input_history_version" then
	based_version = VERSION;

     else if p_order = "io_call" | p_order = "io_call_af" then
	call ih_control_cmd_af (p_iocbP, source_iocbP, p_order, p_infoP, p_code);

     else call iox_$control (source_iocbP, p_order, p_infoP, p_code);

     return;
%page;
ih_control_cmd_af:
     proc (p_iocbP, source_iocbP, p_order, p_infoP, p_code);

  dcl  p_iocbP ptr;
  dcl  source_iocbP ptr;
  dcl  p_order char(*);
  dcl  p_infoP ptr;
  dcl  p_code fixed bin(35);

  dcl  auto_linesN fixed bin(21);
  dcl 1 auto_ihData aligned like ihData;
  dcl  auto_version char(20) varying;

  dcl (conversion, size) condition;

     io_call_infop = p_infoP;				/* Guess that p_infoP might point to io_call_info struct. */
						/*  See io_call_info.incl.pl1.  This is used for the      */
						/*  special io_call and io_call_af control orders.        */

     if p_order = "io_call_af" then do;
	if io_call_info.order_name = "get_input_history_lines" then do;
	     io_call_af_ret = "";
	     call iox_$control (p_iocbP, (io_call_info.order_name), addr(auto_linesN), p_code);
	     if p_code = 0 then 
		io_call_af_ret = ltrim(char(auto_linesN));
	     else call io_call_info.error (p_code, io_call_info.caller_name, "Error from ^a control order.",
		     io_call_info.order_name);
	     end;
	else call iox_$control (source_iocbP, p_order, p_infoP, p_code);
	end;

     else if p_order = "io_call" then do;
	if io_call_info.order_name = "get_input_history_lines" then do;
	     call iox_$control (p_iocbP, (io_call_info.order_name), addr(auto_linesN), p_code);
	     if p_code = 0 then 
		call io_call_info.report ("limit_lines: ^d", auto_linesN);
	     else call io_call_info.error (p_code, io_call_info.caller_name, "Error from ^a control order.",
		io_call_info.order_name);
	     end;

	else if io_call_info.order_name = "set_input_history_lines" then do;
	     if io_call_info.nargs = 1 then do;
		on conversion, size begin;
		     p_code = error_table_$bad_conversion;
		     call io_call_info.error (p_code, io_call_info.caller_name, 
			"Error converting input history line limit: ^a", io_call_info.args(1));
		     go to EXIT_control;
		     end;
		auto_linesN = binary(io_call_info.args(1), 21, 0);
		revert conversion, size;

		call iox_$control (p_iocbP, (io_call_info.order_name), addr(auto_linesN), p_code);
		if p_code ^= 0 then
		     call io_call_info.error (p_code, io_call_info.caller_name, 
		          "Error from ^a control order with: -lines ^d",
		          io_call_info.order_name, auto_linesN);
		end;
	     else if io_call_info.nargs = 0 then do;
		p_code = error_table_$noarg;
		call io_call_info.error (p_code, io_call_info.caller_name, 
		     "Expecting operand giving input history line limit.");
		go to EXIT_control;
		end;
	     else if io_call_info.nargs > 1 then do;
		p_code = error_table_$too_many_args;
		call io_call_info.error (p_code, io_call_info.caller_name, 
		     "expecting one operand giving input history line limit; received ^d operands.",
		     io_call_info.nargs);
		go to EXIT_control;
		end;
	     end;

	else if io_call_info.order_name = "set_input_history_debug" then do;
	     if io_call_info.nargs = 1 then do;
  dcl  operandChar1 char(1);
  dcl  auto_hist_debug bit(1) aligned;
		operandChar1 = io_call_info.args(1);
		auto_hist_debug = ( verify(operandChar1, "1tT") = 0 );
		call iox_$control (p_iocbP, (io_call_info.order_name), addr(auto_hist_debug), p_code);
		if p_code ^= 0 then
		     call io_call_info.error (p_code, io_call_info.caller_name, 
		          "Error from ^a control order with: -debug",
		          io_call_info.order_name, auto_hist_debug);
		end;
	     else if io_call_info.nargs = 0 then do;
		p_code = error_table_$noarg;
		call io_call_info.error (p_code, io_call_info.caller_name, 
		     "Expecting operand giving input history debug bool value.");
		go to EXIT_control;
		end;
	     else if io_call_info.nargs > 1 then do;
		p_code = error_table_$too_many_args;
		call io_call_info.error (p_code, io_call_info.caller_name, 
		     "expecting one operand giving input history debug bool value; received ^d operands.",
		     io_call_info.nargs);
		go to EXIT_control;
		end;
	     end;

	else if io_call_info.order_name = "get_input_history_data" then do;
	     call iox_$control (p_iocbP, (io_call_info.order_name), addr(auto_ihData), p_code);
	     if p_code = 0 then call ihData_display (io_call_info.report, addr(auto_ihData));
	     else call io_call_info.error (p_code, io_call_info.caller_name, "Error from ^a control order.",
		io_call_info.order_name);
	     end;

	else if io_call_info.order_name = "get_input_history_version" then do;
	     call iox_$control (p_iocbP, (io_call_info.order_name), addr(auto_version), p_code);
	     if p_code = 0 then call io_call_info.report ("input_history_ version: ^a", auto_version);
	     else call io_call_info.error (p_code, io_call_info.caller_name, "Error from ^a control order.",
		io_call_info.order_name);
	     end;

	else call iox_$control (source_iocbP, p_order, p_infoP, p_code);
	end;

EXIT_control:
     end ih_control_cmd_af;
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name: input_history_$ih_modes						        */
	/*									        */
	/* Function:  This is a pass-thru interface.					        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

ih_modes:
     entry (p_iocbP, p_newmodes, p_oldmodes, p_code);

  dcl (p_newmodes, p_oldmodes) char(*);

  dcl  iox_$modes entry (ptr, char(*), char(*), fixed bin(35));

     iocbP   = p_iocbP->iocb.actual_iocb_ptr;
     ihDataP = iocbP->iocb.attach_data_ptr;
     source_iocbP = ihData.source_iocbP;

     call iox_$modes (source_iocbP, p_newmodes, p_oldmodes, p_code);
     return;


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name:  input_history_$ih_position						        */
	/*									        */
	/* Function:  This is a pass-thru interface.					        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

ih_position:
     entry (p_iocbP, p_position_type, p_n, p_code);

  dcl  p_position_type fixed bin;
  dcl  p_n fixed bin(21);

  dcl  iox_$position entry (ptr, fixed bin, fixed bin(21), fixed bin(35));

     iocbP   = p_iocbP->iocb.actual_iocb_ptr;
     ihDataP = iocbP->iocb.attach_data_ptr;
     source_iocbP = ihData.source_iocbP;

     call iox_$position (source_iocbP, p_position_type, p_n, p_code);
     return;
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name: input_history_$ih_close						        */
	/*									        */
	/* Function: Stops further I/O operations through this module.			        */
	/*  Note: since this I/O module does not use the open operation, the only action possible after
	/*	a close operation is to detach the I/O module.				        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

ih_close:
     entry (p_iocbP, p_code);
     
     p_code = 0;

     iocbP = p_iocbP -> iocb.actual_iocb_ptr;
     ihDataP = iocbP -> iocb.attach_data_ptr;

     ihData.open_descrip = "";

     if ihData.source_is_window_io_ then do;

	source_iocbP = ihData.source_iocbP;		/* Deconfigure key bindings we added, using saved kb info */
	lekbiP = ihData.savedKeyBindingsP;

	call lineEditorKeyBindings_set (source_iocbP, lekbiP);
	free lekbi in (ihArea);			/* Free key binding structure storage.		        */

	call iocb_dict_clear(source_iocbP->iocb.actual_iocb_ptr);
						/* Remove this source_iocbP from iocb_dict cache.	        */
	if ihData.hist.debug then
	     call ioa_$ioa_switch(ihData.source_iocbP,
	          "^a:   window_io_ line editor requests removed.", DEBUG_BANNER);
	end;


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* CRITICAL SECTION of CODE:  Prevent interrupts while I/O switch is being configured.	        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

     call hcs_$set_ips_mask (""b, mask);
     iocbP -> iocb.open_descrip_ptr = null();
     iocbP -> iocb.detach_iocb = ih_detach;
     iocbP -> iocb.open        = iox_$err_no_operation;
     iocbP -> iocb.control     = iox_$err_no_operation;
     iocbP -> iocb.modes       = iox_$err_no_operation;
     call iox_$propagate (iocbP);
     call hcs_$reset_ips_mask(mask, mask);

     if ihData.hist.debug then
	call ioa_$ioa_switch(ihData.source_iocbP,
	     "^a: close operation complete.", DEBUG_BANNER);
     return;
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name: input_history_$ih_detach						        */
	/*									        */
	/* Function: Detach the I/O module, freeing up its internal data.			        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

ih_detach:
     entry (p_iocbP, p_code);
     
     p_code = 0;

     iocbP = p_iocbP -> iocb.actual_iocb_ptr;
     ihDataP = iocbP -> iocb.attach_data_ptr;

     iocbP -> iocb.attach_descrip_ptr = null;
     iocbP -> iocb.attach_data_ptr = null;

  dcl  detach_debug bit(1) aligned;
     detach_debug = ihData.hist.debug;			/* Preserve debug setting before freeing data.	        */
  dcl  db_iocbP ptr;
     db_iocbP = ihData.source_iocbP;

  dcl  hcs_$terminate_noname entry (ptr, fixed bin(35));	/* Terminate the History Segment.		        */
     if ihData.segP ^= null() then
	call hcs_$terminate_noname (ihData.segP, p_code);

  dcl  ignoreCode fixed bin(35);
     call hSeg_unlock(ihData.hist.segmentData, ignoreCode); /* Unlock and terminate any History Lock Segment	        */
     if ihData.segLockP ^= null then
	call hcs_$terminate_noname (ihData.segLockP, ignoreCode);

     free ihData in (ihArea);				/* Free the attach data.			        */

     if detach_debug then				/* Tell users debugging this I/O module.	        */
	call ioa_$ioa_switch(db_iocbP,
	     "^a: detach operation complete.", DEBUG_BANNER);

     return;
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name: lineEditorRequest_setup						        */
	/*									        */
	/* Function: standard setup actions performed each time an ih line editor request is called.      */
	/*									        */
	/* Notes:									        */
	/*  1) ihData.edit.currentLine maintains line cursor position within the history file between     */
	/*     editing requests for one invocation of the window_io_ line editor.  Thus, each call to     */
	/*     iox_$get_line to read an input line resets the cursor position back to END_OF_HISTORY      */
	/*     segment.								        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

lineEditorRequest_setup:
     proc (su_leiP, su_ihDataP, su_iocbP, code);

  dcl  su_leiP ptr;					/* ptr to line_editor_info structure. (in)	        */
  dcl  su_ihDataP ptr;				/* ptr to data passed to input_history_ line editor       */
						/*  requests.  This is the input_history_ ihDataP. (out)  */
  dcl  su_iocbP ptr;				/* ptr to the window_io_ target IOCB. (out)	        */
  dcl  code fixed bin(35);				/* status code, which might explain setup failure.        */

  dcl 1 lei aligned like line_editor_info based(su_leiP);
  dcl  lei_input_buffer char(lei.line_length) based(addr(lei.input_buffer));

     su_ihDataP, su_iocbP = null;			/* We don't have output pointers when starting.	        */

     if lei.version ^= line_editor_info_version_3 then do;	/* Verify line_editor_info structure format.	        */
          code = error_table_$unimplemented_version;
          go to EXIT_edit_req_with_Bell;
          end;

  dcl 1 ih aligned like ihData based (su_ihDataP);	/* Get our data pointer from line_editor_info.  It was    */
						/*  cached when our editor requests were added to the     */
     su_ihDataP = iocb_dict_get(lei.iocb_ptr);		/*  target IOCB (at attach time).		        */
     if su_ihDataP = null() then do;
          code = error_table_$no_iocb;			/* lei.iocb_ptr not being monitored by input_history_     */
          go to EXIT_edit_req_with_Bell;
          end;

     su_iocbP = ih.source_iocbP -> iocb.actual_iocb_ptr;	/* Get the target IOCB from our data.		        */

     call hSeg_get(ih, code);				/* Does History Segment still exist?		        */
     if code ^= 0 then go to EXIT_edit_req_with_Bell;

     if ih.hist.segL = 0 then do;			/* History Segment empty ==> no lines to edit.	        */
          code = error_table_$empty_file;
          go to EXIT_edit_req_with_Bell;
          end;
     
     if historyLinePositions_equal(ih.currentLine, END_OF_HISTORY) then do;
						/* If this is first time a history request is used in     */
	ih.edit.origEditorBuffer = lei_input_buffer;	/*  this invocation of the window_io_ line editor (in     */
						/*  this call to iox_$get_line), then capture the line    */
	ih.edit.origCursorI = lei.cursor_index;	/*  editor's input line content (if any) for later reuse. */
	end;

     end lineEditorRequest_setup;			/* Setup complete.				        */
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name: input_history_$ih_previous_line					        */
	/*									        */
	/* Function: select Nth previous history line; return it in the window_io_ line editor buffer,    */
	/* for editing/re-input.							        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

ih_previous_line:
     entry (p_leiP, p_code);

  dcl  p_leiP ptr;					/* Ptr to window_io_ line editor's info structure. (in)   */

     call lineEditorRequest_setup (p_leiP, ihDataP, iocbP, p_code);

  dcl 1 lei aligned like line_editor_info based(p_leiP);

  dcl  linesBack fixed bin(21);			/* Value of N, when selecting Nth previous input line.    */
     if lei.numarg_given then
	linesBack = lei.repetition_count;
     else linesBack = 1;

     ihData.workingLine = hSeg_editPosition(ihData.segmentData, ihData.currentLine, -linesBack);
						/* Position workingLine backward from currentLine.        */
EXIT_edit_req_with_WorkingLine:
     call workingLine_to_lei (ihData, p_leiP);
     p_code = 0;
     return;

EXIT_edit_req_with_Bell:				/* Ring bell to indicate a request setup error.	        */
						/*  Transferer sets p_code before going here, to 	        */
						/*  diagnose the error.			        */
     call wBellRing();				/* Ring window_ bell.			        */
     return;     


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name: input_history_$ih_next_line						        */
	/*									        */
	/* Function: select Nth next history line; return it in the window_io_ line editor buffer, for    */
	/* editing/re-entry.							        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

ih_next_line:
     entry (p_leiP, p_code);

     call lineEditorRequest_setup (p_leiP, ihDataP, iocbP, p_code);

  dcl  linesForward fixed bin(21);			/* Value of N, when selecting Nth next input line.        */
     if lei.numarg_given then
	linesForward = lei.repetition_count;
     else linesForward = 1;

     ihData.workingLine = hSeg_editPosition(ihData.segmentData, ihData.currentLine, linesForward);
						/* Position workingLine forward from currentLine.	        */
     go to EXIT_edit_req_with_WorkingLine;		/* Assign this workingLine to editor buffer.	        */
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name: input_history_$ih_selection_abort					        */
	/*									        */
	/* Function: discontinue selection of an input history line for re-edit.  Return to the	        */
	/* window_io_ line editor with the original line that began its invocation.		        */
	/*									        */
	/* Notes:  This request is needed because the basic window_io_ line editor keybinding for ^G      */
	/* does nothing; whereas during incremental search of prior input lines, ^G aborts the	        */
	/* selection.  So for consistency, this ^G aborts selections performed by prior ^P or ^N	        */
	/* requests.								        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

ih_selection_abort:
     entry (p_leiP, p_code);
     
     call lineEditorRequest_setup (p_leiP, ihDataP, iocbP, p_code);
     
     call wBellRing();
     ihData.edit.workingLine = END_OF_HISTORY;
     call workingLine_to_lei (ihData, p_leiP);
     return;
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name: workingLine_to_lei							        */
	/*									        */
	/* Function: assign either ihData.workingLine or ihData.origEditorBuffer to the lei	        */
	/* (line_editor_info) structure passed by the window_io_ line editor to external edit functions.  */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

workingLine_to_lei:
     proc (ih, line_editor_info_ptr);

  dcl 1 ih aligned like ihData;
  dcl  ih_currentLine char(ih.edit.currentLine.lineL) based(ih.edit.currentLine.lineP);

%include window_line_editor;

     ih.edit.currentLine = ih.edit.workingLine;		/* Record workingLine as the new currentLine.	        */
     if ih.edit.currentLine.linesFromEnd = 0 then
	go to origEdBuff_to_lei;

     line_editor_info.line_length = length(ih_currentLine);
     line_editor_input_line = ih_currentLine;
     line_editor_info.cursor_index = ih.edit.currentLine.cursorI;
     return;
     
origEdBuff_to_lei:
     line_editor_info.line_length = length(ih.edit.origEditorBuffer);
     line_editor_input_line = ih.edit.origEditorBuffer;
     line_editor_info.cursor_index = min(ih.edit.origCursorI, line_editor_info.line_length+1);

     ih.edit.currentLine = END_OF_HISTORY;		/* Since we are returning original line to the editor,    */
						/*  act like we are starting new edit invocation.	        */
     end workingLine_to_lei;
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name:  input_history_$ih_reverse_search					        */
	/*									        */
	/* Function: search backward in history for a line matching a given searchString.	        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* -------------------------------------------------------------------------------------------------------------------
   Model for Incremental Searching:  Multics Emacs, then GNU readline
     This is the model actually implemented by input_history_.pl1.

   - Repetition count: ignored
   - Source when (re-)starting a search:
      1) partial input line in lei.input_buffer (ihData.OrigEditorBuffer); then
      2) continue searching backward in history.
   - Each incremental search operation reads an incremental searchCh (the user's instructions to search engine).
     Each possible searchCh value is associated with a searching action to perform, as shown in the table below.

    |   searchCh is     |           Action To Perform
    | ----------------- | --------------------------------------------------------------------------------------
      printing-char	    : add searchCh to searchString; restart search from location of last successful search.
		      If no match is found, ring bell and remain positioned at location found by last
		         successful increment, with searchCh NOT added to searchString.  (Includes SP and HT.)
      erase(#), kill(@) : see description later in this table.  (If user has changed his erase/kill chars, those
                          chars are used instead of # and @ characters.)
    | ----------------- | --------------------------------------------------------------------------------------

      non-printing chars
    | ----------------- | --------------------------------------------------------------------------------------
             ^L	    : redisplay incremental search status line; read next searchCh.
    ^Q-erase,  ^Q-kill  : Conceal special meaning of erase and kill editing chars, using the ^Q-<X> mechanism...
           ^Q-<X>       : where <X> is any printing-char (including erase and kill characters)...
		      Ignore ^Q; add next searchCh to searchString; restart search from beginning.
		      If no match is found, ring bell and remain positioned at location found by last
		         successful increment, with <X> NOT added to searchString.
             ^R         : if prior search operation was a reverse-search...
		       If no match has been found in current edit invocation, then ring bell;
                           otherwise, search again for current searchString from most recent searchResult.
		      If prior search operation was a forward_search...
		       Invert search direction (moving cursor from end of matching string to its beginning);
		       then reverse-search for the current searchString from that location.
             ^S         : if prior search operation was a forward-search...
		       If no match has been found in current edit invocation, then ring bell;
		       otherwise, search again for current searchString from the more recent searchResult.
                          If prior search operation was a reverse-search...
		       Invert search direction (moving cursor from beginning of matching string to its end);
		       then forward-search for the current searchString from that location.
       DEL,  BS,  erase : remove one character from end of searchString; restart search.

     Searching ends (in various fashions) when one of the following searchCh values is given:
    | ----------------- | --------------------------------------------------------------------------------------
             ESC        : Set lei.input_buffer to line containing current searchResult.
		      Set lei.cursor_index to start of searchResult in this line.
		      Return to window_io_ line editor, allowing further editing on this line.
	   ^G	    : abort the search by ringing tty_ bell, then returning to window_io_ line editor 
		      with lei.input_buffer unchanged.

       other ctl chars  : set lei.input_buffer to line containing searchResult.
        and kill char     Set lei.cursor_index to start (for reverse-search) or end (for forward-search)
        (includes          of searchResult in this line.
         RETURN (^M),     Set lei.new_break_character to this "other ctl char", to let window_io_ line editor
             NL (^J) )     evaluate/implement this as a further editing request.
		      Return to window_io_ line editor.

NB: ESC is one of the characters that can end the incremental search.  Thus, this code does not have to
    implement the entire ESC-x break table in input_history_; or learn window_io_ defs for word-oriented requests 
    (e.g., ESC-F, ESC-B); or teach window_io_ line editor how to handle multi-character breaks returned from
    input_history_.  As suggested above, GNU readline uses a subsequent control sequence to end the reverse search, 
    and allow further editing of the searchResult.  We do this too; but also follow the Multics Emacs implementation
    of incremental-search, which ends searching with an ESC char (or with other control char sequence).  The ESC is 
    treated as a single ending indicator, not as a key binding prefix char.

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

ih_reverse_search:
     entry (p_leiP, p_code);
     
  dcl  searchDirectionAtEntry fixed bin(1);
     searchDirectionAtEntry = REVERSE;
     go to SEARCH_JOIN;

ih_forward_search:
     entry (p_leiP, p_code);

     searchDirectionAtEntry = FORWARD;
     go to SEARCH_JOIN;
%page;

SEARCH_JOIN:
     call lineEditorRequest_setup (p_leiP, ihDataP, iocbP, p_code);

  dcl (erase, kill) char(1);				/* Get current window_io_ line editor erase/kill chars.   */
     erase = window_io_attach_data.erase_char;		/*  NB: Cheat by accessing another I/O module's attach    */
     kill  = window_io_attach_data.kill_char;		/*      data.  The control call to access this data is    */
						/*      very expensive.  Only get to this code if we are  */
						/*      attached through window_io_, so cheat is safe-ish.*/

     searchStack.D = 0;				/* Setup stack to track each segment of search operation. */
						/*  This permits undoing the search if chars are removed  */
						/*  from the incremental search string.		        */
  dcl  1 ss aligned like searchStackItem;
     ss.dir = searchDirectionAtEntry;			/* Setup search starting location and direction.	        */
     ss.search = "";				/* Start with an empty search string.		        */

     if length(ihData.edit.origEditorBuffer) = 0 then	/* Ensure there is some data representing the partial     */
	ihData.edit.origEditorBuffer = " ";		/*  line given to us by window_io_ line editor.	        */

     call hSeg_append_chars(ihData.hist.segmentData, (ihData.edit.origEditorBuffer), TEMPORARY);
						/* Temporarily add partial line editor input to the       */
						/*  History Segment, so we can do a single search.        */

     if historyLinePositions_equal (ihData.edit.currentLine, END_OF_HISTORY) then do;
	ss.pos = hSeg_editPosition(ihData.hist.segmentData, END_OF_HISTORY, -1);
	ss.cursorI = ihData.edit.origCursorI;		/*  If positioned at end of History Segment, then make    */
	ss.matchL = 0;				/*   ss.pos be the partial line editor input.	        */
	end;
     else do;					/*  For some other starting position, add 1 more line from*/
	ss.pos = ihData.edit.currentLine;		/*   end for partial window_io_ line editor input, which  */
						/*   was appended to History Segment temporarily.	        */
	ss.pos.linesFromEnd = ss.pos.linesFromEnd - 1;	/*  (linesFromEnd begin at 0, proceed with negative number*/
	end;					/*   of lines from end of History Segment.	        */

     call searchStackPush (ss);			/* Save this location as starting position of search.     */

SEARCH_LOOP:					/* Incremental search; searchCh gives search op.          */
     call wLineDisplay(p_leiP, ss);			/*  - Display search status in current line.	        */

  dcl  searchCh char(1) varying;
     searchCh = wGetOneChar();			/*  - Get incremental searchCh.		        */

     if searchCh = erase then go to BACKWARD_DELETE_SEARCH_CHAR;
						/* SL( 35): # (often)  BACKWARD_DELETE_SEARCH_CHARACTER   */

     if searchCh = kill  then go to END_SEARCH_WITH_BREAK_CHAR;
						/* SL( 64): @ (often)  KILL_TO_BEGINNING_OF_LINE          */

						/*  - Handle printing chars.			        */
     if searchCh =  HT |				/*     HT            	        SL(  9)	        */
       (searchCh >= SP  & searchCh < DEL) then		/*     SP ... ~		        SL( 32) - SL(126)   */
	ss = hSeg_editSearch (ihData.hist.segmentData, ss, ss.dir, searchCh);

     else if searchCh <= DEL then 			/*  - Handle other chars below SP, and DEL.	        */
	go to SL(rank (char(searchCh,1)));

     else ;					/*  - Ignore chars above rank(DEL) = 127	        */

     go to SEARCH_LOOP;				/*  - Continue searching.			        */

						/*  - Handle control chars bound to functions that        */
						/*    continue the incremental search operation.	        */
SL(  8): /* BS,  ^H, BACKWARD_DELETE_SEARCH_CHARACTER */
SL(127): /* DEL,     BACKWARD_DELETE_SEARCH_CHARACTER */

BACKWARD_DELETE_SEARCH_CHAR:
     ss = searchShorten (ss);				/* Pop back to an earlier search with shorter .search str.*/
     go to SEARCH_LOOP;

SL( 12): /* FF,  ^L, CLEAR_SEARCH_STATUS       */     
     go to SEARCH_LOOP;

SL( 17): /* DC1, ^Q, QUOTE_CHARACTER           */

  dcl  quotedCh char(1) var;
     quotedCh = wGetOneChar();
     if quotedCh =  HT | (quotedCh >= SP & quotedCh < DEL) then do;
	searchCh = quotedCh;
	ss = hSeg_editSearch (ihData.hist.segmentData, ss, ss.dir, searchCh);
	end;
     else call wBellRing();
     go to SEARCH_LOOP;

SL( 18): /* DC2, ^R, REVERSE_SEARCH_HISTORY    */
     ss = hSeg_editSearch (ihData.hist.segmentData, ss, REVERSE, "");
     go to SEARCH_LOOP;

SL( 19): /* DC3, ^S, FORWARD_SEARCH_HISTORY    */
     ss = hSeg_editSearch (ihData.hist.segmentData, ss, FORWARD, "");
     go to SEARCH_LOOP;


SEARCH_ABORT:
SL(  7): /* BEL, ^G, ABORT_HISTORY_SEARCH      */
     call wBellRing();				/* Abort editing of history segment, and	        */
     ss.pos = END_OF_HISTORY;				/*  return to window_io_ with original line editor buffer.*/
     call endSearch_with_WorkingLine (ihData, p_leiP, ss, p_code);
     return;

SL( 27): /* ESC, ^[, END_SEARCH                */     
     call endSearch_with_WorkingLine (ihData, p_leiP, ss, p_code);
     return;


SL(  0): /* NUL, ^@ */				/* Let window_io_ line editor handle all other chars.     */
SL(  1): /* SOH, ^A, MOVE_TO_BEGINNING_OF_LINE */
SL(  2): /* STX, ^B, BACKWARD_CHARACTER        */
SL(  3): /* ETX, ^C */	  
SL(  4): /* EOT, ^D, FORWARD_DELETE_CHARACTER  */
SL(  5): /* ENQ, ^E, MOVE_TO_END_OF_LINE       */
SL(  6): /* ACK, ^F, FORWARD_CHARACTER         */
SL( 10): /* NL,  ^J, TERMINATE_INPUT_LINE      */
SL( 11): /* VT,  ^K, KILL_TO_END_OF_LINE       */
SL( 13): /* CR,  ^M, TERMINATE_INPUT_LINE      */
SL( 14): /* SO,  ^N, NEXT_HISTORY_LINE         */
SL( 15): /* SI,  ^O */     
SL( 16): /* DLE, ^P, PREVIOUS_HISTORY_LINE     */
SL( 20): /* DC4, ^T, TWIDDLE_CHARACTERS        */
SL( 21): /* NAK, ^U */		          SL( 22): /* SYN, ^V */     SL( 23): /* ETB, ^W */
SL( 24): /* CAN, ^X */			SL( 25): /* EM,  ^Y */     SL( 26): /* SUB, ^Z */     
SL( 28): /* FS,  ^\ */			SL( 29): /* GS,  ^] */     SL( 30): /* RS,  ^^ */
SL( 31): /* US,  ^_ */

END_SEARCH_WITH_BREAK_CHAR:
     call endSearch_with_WorkingLine (ihData, p_leiP, ss, p_code);
     lei.break_given = TRUE;
     lei.new_break_character = searchCh;
     return;
%page;

endSearch_with_WorkingLine:
     proc (ih, leiP, ss, code);

  dcl 1 ih aligned like ihData;
  dcl  leiP ptr;
  dcl 1 ss aligned like searchStackItem;
  dcl  code fixed bin(35);

     if ih.hist.extraLineL > 0 then do;			/* Search started by appending line editor buffer to      */
	if ss.pos.linesFromEnd = -1 then do;		/*  History Segment temporarily.  Now remove it.	        */
	     ih.edit.origCursorI = ss.pos.cursorI;
	     ih.edit.workingLine = END_OF_HISTORY;
	     end;
	else do;
	     ss.pos.linesFromEnd = ss.pos.linesFromEnd + 1;
	     ih.edit.workingLine = ss.pos;
	     end;
	call hSeg_unappendExtraLine (ih.hist.segmentData);
	end;
     else ih.edit.workingLine = ss.pos;
     call workingLine_to_lei (ih, leiP);		/* Copy match in searchStackItem into line editor buffer. */
     code = 0;
     end endSearch_with_WorkingLine;
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Names: searchStackPush, searchStackPop, searchShorten				        */
	/*									        */
	/* Function: the searchStack is a push-down stack of searchStackItem structures.  Each	        */
	/* searchStackItem gives a search direction, searchString, and location of a history line	        */
	/* containing a match for the searchString.  These items permit undo-ing search operations if     */
	/* characters are removed from the searchString.					        */
	/*									        */
	/* NB: Rule is that the searchStackItem currently in use is also the one atop the stack.  When    */
	/* popping an item off the stack, we discard that item and return the item at the new	        */
	/* top-of-stack location.							        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

  dcl 1 searchStack aligned,				/* Stack for backtracking search operations.	        */
      2 D fixed bin,				/*  - depth of the stack			        */
      2 sk(40) like searchStackItem;			/*  - room for 40 stack items.  If stack fills up, old    */
						/*    items are shifted off bottom of the stack.	        */

searchStackPush:					/* Push a new searchStackItem onto the searchStack.       */
     proc (ss);

  dcl 1 ss aligned like searchStackItem;

  dcl  i fixed bin;

     if searchStack.D < dimension(searchStack.sk,1) then do;
	searchStack.D = searchStack.D + 1;		/* Push new ss item on top of the stack.	        */
	searchStack.sk(searchStack.D) = ss;
	end;
     else do;					/* Stack full; shift an old item off bottom of stack.     */
	do i = 2 to dimension(searchStack.sk,1);
	     searchStack.sk(i-1) = searchStack.sk(i);
	     end;
	searchStack.sk(searchStack.D) = ss;		/* Push new ss item on top of the stack.	        */
	end;
     end searchStackPush;


searchStackPop:					/* Remove top item from searchStack, and return the new   */
     proc() returns (1 aligned like searchStackItem);	/*  top-of-stack item.			        */

     if searchStack.D > 1 then 
	searchStack.D = searchStack.D - 1;
     return (searchStack.sk(searchStack.D));
     end searchStackPop;

searchShorten:					/* Return prio searchStack item, having shorter .search   */
     proc (ss) returns (1 aligned like searchStackItem);	/*  string.				        */

  dcl 1 ss aligned like searchStackItem;

  dcl 1 prior_ss aligned like searchStackItem;
     
     prior_ss = searchStackPop();
     do while ( length(ss.search) = length(prior_ss.search) & searchStack.D > 1 );
	prior_ss = searchStackPop();
	end;
     return (prior_ss);

     end searchShorten;

%page;     
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Names:  wBellRing, wLineDisplay, wGetOneChar					        */
	/*									        */
	/* Functions: support routines used by edit functions to interface with window_ and window_io_    */
	/* functions in the window_io_ line editor, or in its support routine repertoire.	        */
	/*									        */
	/* Notes: Before the window_io_ line editor calls one of these external editor requests, it       */
	/* runs in a complex environment in which redisplay_input_buffer (window_io_iox_.pl1) draws on    */
	/* variables set in its containing procedures.  So when wLineDisplay calls lei.redisplay, it is   */
	/* really calling back into window_io_ in a way that permits the lei.redisplay (the	        */
	/* redisplay_input_buffer) routine to access its containing procedure's environment.  (The entry  */
	/* variable, lei.redisplay includes an environmentptr pointing to stack frame of procedures that  */
	/* contain redisplay_input_buffer.)						        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

wBellRing:					/* Ring the tty bell.			        */
     proc;
     
  dcl  ignoreCode fixed bin(35);

     if iocbP ^= null then
	call window_$bell (iocbP, ignoreCode);

     end wBellRing;


wLineDisplay:					/* Display search status line on the line used by the     */
     proc(leiP, ss);				/* window_io_ line editor.			        */

  dcl  leiP ptr;
  dcl 1 ss aligned like searchStackItem;

  dcl 1 lei aligned like line_editor_info based(leiP);
  dcl  ssPosLine char(ss.pos.lineL) based(ss.pos.lineP);

  dcl  ignoreCode fixed bin(35);

  dcl  line char(512) var init("");
  dcl  cursorI fixed bin(21);

     if ss.dir = FORWARD then
	line = "(forward-search)`";
     else line = "(reverse-search)`";
     line = line || ss.search;
     line = line ||  "': ";
     
     if length(ssPosLine) > 0 then do;
	cursorI = length(line) + ss.pos.cursorI;
	line = line || ssPosLine;
	end;
     else cursorI = length(line);

     lei.line_length = length (line);
     lei.input_buffer = line;
     lei.cursor_index = cursorI;

     call lei.redisplay (leiP);

     end wLineDisplay;


wGetOneChar:					/* Read one un-echoed character from user_i/o.	        */
     proc() returns(char(1) var);

  dcl  one char(1) varying init("");
  dcl  ignoreCode fixed bin(35);

     if iocbP = null() then return(BEL);

     call window_$get_one_unechoed_char (iocbP, one, BLOCK, ignoreCode);
     return (one);

     end wGetOneChar;
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name:	hSeg_editPosition							        */
	/*									        */
	/* Function:  Fills in a historyLinePosition structure, to point to an offset number of lines     */
	/* from a given historyLinePosition.						        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

hSeg_editPosition:
     proc (hs, linePos, offset) returns(1 aligned like historyLinePosition);
     
  dcl 1 hs aligned like ihData.hist.segmentData;		/* data describing the entire History Segment.	        */
  dcl 1 linePos aligned like historyLinePosition;		/* line position to which offset is applied.	        */
  dcl  offset fixed bin(21);				/* offset (neg or pos, in lines) from linePos.	        */
     
  dcl 1 newPos aligned like historyLinePosition;		/* Result from this function: a new position within       */
  dcl  newPosLine char(newPos.lineL) based(newPos.lineP);	/*  history segment.			        */

						/* Overlay some of History Segment:		        */
  dcl  s_data char(s_dataL) based(s_dataP);		/*   -- as a string.			        */
  dcl  s_char (s_dataL) char(1) based(s_dataP);		/*   -- as a array of characters.		        */
  dcl  s_dataP ptr;
  dcl  s_dataL fixed bin(21);

  dcl  nlH fixed bin(21);				/* Character index within entire History Segment.	        */

  dcl  nlI fixed bin(21);				/* Index of NL within part of History Segment.	        */
  dcl  nlRI fixed bin(21);				/* Reverse index of NL within part of History Segment.    */

  dcl  off fixed bin(21);				/* offset loop increment variable.		        */

     if hs.segL = 0 then go to RETURN_with_END_OF_HISTORY;	/* If History Segment empty, return END_OF_HISTORY.       */

     newPos = linePos;				/* Start by setting our new history line position to the  */
						/*   current line.				        */

     if offset < 0 then do;				/* Move backward through history by -offset lines.        */

	s_dataP = hs.segP;				/*  - For backward searching, partial string overlaying   */
						/*    History Segment always starts at top of that seg.   */

	if newPos.linesFromEnd < 0 then		/* Get length of partial History Segment preceding the    */
	     s_dataL = charno(newPos.lineP)-length(NL);	/*  current historyLinePosition.		        */

	else if newPos.linesFromEnd >= 0 then do;	/* Special case handling of final (possibly incomplete)   */
						/*  line of the History Segment as start position.        */
	     s_dataL = hs.segL;			/*   - Normally, setup to search backward thru entire     */
						/*      History Segment.			        */
	     if s_char(s_dataL) = NL then		/*      Don't include final line's NL (if any) in the     */
		s_dataL = s_dataL - length(NL);	/*       historyLinePosition.			        */
	     end;

	do off = 1 to -offset;			/* Start of offset repetition loop...		        */

	     if newPos.lineP = hs.segP then		/*  - Already at first line of file?  Cannot backup more. */
		go to RETURN_from_editPosition;

	     nlRI = index(reverse(s_data),NL);		/*  - Search backward in partial string for earlier NL    */
	     if nlRI = 0 then do;			/*     - If we reach first history line:	        */
		newPos.linesFromEnd = -hs.linesN;	/*        - Return first line in History Segment.	        */
		newPos.lineP = addr(s_data);
		newPos.lineL = length(s_data);
		newPos.cursorI = newPos.lineL+1;
		newPos.matchL = 0;
		go to RETURN_from_editPosition;
		end;

	     newPos.linesFromEnd = newPos.linesFromEnd - 1;
	     nlH = (length(s_data)+1) - nlRI;
	     newPos.lineP = addr(s_char(nlH+1));	/*  - Set newPos to the line we just found (in case       */
	     newPos.lineL = nlRI-1;			/*    search stops).			        */
	     newPos.cursorI = newPos.lineL+1;		/*     - For line-by-line positioning, cursor is after    */
	     newPos.matchL = 0;			/*       last character of the line just found.	        */

	     s_dataL = s_dataL - nlRI;		/*  - Set new length for partial History Segment (in case */
						/*    search continues).  As usual, NL separating this    */
						/*    partial string from history line we just found is   */
						/*    removed from end of partial string.	        */

	     end;					/* End of the offset repetition loop.		        */

	go to RETURN_from_editPosition;
	end;
     
     else if offset > 0 then do;			/* Move forward through history by offset lines.	        */

	do off = 1 to offset;			/* Start of offset repetition loop...		        */

	     if newPos.linesFromEnd >= 0 then		/* If asked to move beyond END_OF_HISTORY, then return to */
		go to RETURN_with_END_OF_HISTORY;	/*  window_io_ editor with the origEditorBuffer	        */
						/*  (captured by first history edit request called in     */
						/*   current window_io_ line editor invocation).	        */

	     s_dataP = addcharno(newPos.lineP, newPos.lineL);
	     s_dataL = hs.segL - charno(s_dataP);	/* Point to partial History Segment after current line.   */
	     if length(s_data) > 0  & s_char(1) = NL then do;
		s_dataP = addcharno(s_dataP,  length(NL));
		s_dataL = s_dataL - length(NL);	/*  - Skip any NL which ended the preceding line.	        */
		end;

	     if s_dataL <= 0 then			/* If no data remains in History Segment after moving     */
		go to RETURN_with_END_OF_HISTORY;	/*  forward, then return to window_io_ editor with the    */
						/*  origEditorBuffer.			        */

	     newPos.lineP = addr(s_data);		/* Next line begins at start of s_data.		        */

	     nlI = index(s_data,NL);			/* Determine length of the new history line position.     */
	     if nlI = 0 then do;			/*  - If new history line does not end in NL, then it is  */
						/*    final history line.			        */
		newPos.linesFromEnd = -1;		/*     - Position to final line in History Segment.       */
		newPos.lineL = length(s_data);
		end;
	     else do;
		newPos.linesFromEnd = newPos.linesFromEnd + 1;
		newPos.lineL = nlI-1;		
		end;
	     newPos.cursorI = newPos.lineL+1;		/* For line-by-line positioning, cursor is after	        */
	     newPos.matchL = 0;			/*       last character of the line just found.	        */
		
	     end;					/* End of the offset repetition loop.		        */

	go to RETURN_from_editPosition;
	end;
     
     else ;					/* Make no adjustment when offset = 0.		        */

RETURN_from_editPosition:
     if newPos.linesFromEnd < 0 then
	return (newPos);

RETURN_with_END_OF_HISTORY:
     newPos = END_OF_HISTORY;			
     newPos.lineP = hs.segP;			
     return (newPos);			

%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name: hSeg_editSearch							        */
	/*									        */
	/* Function: perform incremental search, possibly after adding a new char to .search, or after    */
	/*           changing the direction of the search.				        */
	/*  1) Begin searching at location of last successful search (searchStackItem input).	        */
	/*  2) Copy incoming searchStackItem to a new searchStackItem.			        */
	/*  3) Append any incremental searchCh (input) to .search element of new searchStackItem.	        */
	/*  4) Incrementally search backward/forward within History Segment for match to this .search     */
	/*  5) If search succeeds, push new searchStackItem onto the searchStack; otherwise, discard it.  */
	/*  6) Return either the original (input) searchStackItem or new searchStackItem as our result.   */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

hSeg_editSearch:
     entry (hs, ss, newSearchDir, newSearchCh) returns(1 aligned like searchStackItem);

  dcl 1 ss aligned like searchStackItem;		/* Incremental search status, including: 	        */
						/*   - our direction of searching		        */
						/*   - our searchString, and 			        */
						/*   - our starting position for the search.	        */
  dcl  newSearchDir fixed bin(1);			/* = FORWARD or REVERSE			        */
  dcl  newSearchCh char(1) varying;			/* Character to be added to searchString, only if the     */
						/*  search succeeds.			        */

  dcl 1 nss aligned like searchStackItem;
     nss = ss;
     nss.search = nss.search || newSearchCh;		/* Temporarily add new character to the searchString.     */
     nss.matchL = 0;
     nss.dir = newSearchDir;

     if hs.segL = 0 then				/*  - Abnormal case: empty History Segment; no partial    */
	go to SEARCH_ABORT;				/*    input from window_io_ line editor.  SEARCH FAILS!   */


  dcl 1 lPos aligned like historyLinePosition;		/* Line position within History Segment.	        */
  dcl (lineStartH, matchStartH, matchEndH) fixed bin(21);	/* Indexes into entire History Segment.		        */
  dcl (cursorI, matchEndI, matchStartI, searchI) fixed bin(21);
						/* Forward indexes into REMAINDER of History Segment.     */
  dcl  searchRI fixed bin(21);			/* Reverse index into leading part of History Segment.    */
  dcl  searchPriorLocation bit(1) aligned init(FALSE);	/* See if nss.search found at prior matching location.    */

     if newSearchDir = REVERSE then do;			/* Search backward through History Segment?	        */
	if newSearchDir ^= ss.dir & ss.matchL > 0 then do;/*  - If changing search direction, adjust cursorI to     */
	     searchPriorLocation = TRUE;		/*    point at first char of matched string.              */
	     nss.pos.cursorI = ss.pos.cursorI - ss.matchL;
	     end;
	else if ss.pos.matchL > 0 & length(newSearchCh) > 0  then
	     searchPriorLocation = TRUE;

	if searchPriorLocation then do;
	     s_dataP = nss.pos.lineP;			/* If there was a prior match for the search, see if we   */
	     s_dataL = nss.pos.lineL;			/*  are looking at the new search string.	        */
	     s_dataP = addr(s_char(nss.pos.cursorI));
	     s_dataL = min(length(nss.search), length(s_data)-(nss.pos.cursorI-1));
	     if length(s_data) = length(nss.search) & s_data = nss.search then do;
		nss.pos.matchL = length(nss.search);	/*  A match!				        */
		call searchStackPush (nss);
		return (nss);
		end;
	     end;

	s_dataP = hs.segP;				/* Reverse search up to beginning of History Segment.     */
	s_dataL = min( charno(nss.pos.lineP) + (nss.pos.cursorI-1) + length(ss.search) - 1, hs.segL );
						/*  - Include prior match - last char in search candidate.*/
	searchRI = index (reverse(s_data), reverse(nss.search));
	if searchRI > 0 then do;			/* A match!  searchRI is index from end of s_data.        */
	     matchEndH = (length(s_data)+1) - searchRI;	/*   Index of match within leading part of History.       */
	     matchStartH = matchEndH - (length(nss.search)-1);

	     s_dataL = matchStartH-1;			/*   Search backward for start of line.		        */
	     nlRI = index (reverse(s_data), NL);		
	     if nlRI = 0 then
		lineStartH = 1;			/*   Match found in first line History Segment.	        */
	     else lineStartH = (length(s_data)+1) - (nlRI-length(NL));
						/*   Match found elsewhere in History Seg.  Index is char */
						/*    after the NL.				        */

	     lPos = END_OF_HISTORY;		/*   Get historyLinePosition for this lineStartI.	        */
	     do while ( (lPos.lineP ^= addr(s_char(lineStartH))) & (lPos.lineP ^= hs.segP) );
		lPos = hSeg_editPosition(hs, lPos, -1);
		end;
	     nss.pos = lPos;
	     nss.pos.cursorI = matchStartH - (lineStartH-1);
	     nss.pos.matchL = length(nss.search);
	     call searchStackPush (nss);
	     return (nss);
	     end;
	else do;					/* Failure.  Return prior search position.	        */
	     call wBellRing();
	     return (ss);
	     end;
	end;
     
     else if newSearchDir = FORWARD then do;		/* Search forward through History Segment?	        */
	if newSearchDir ^= ss.dir & ss.matchL > 0 then do;/*  - If changing search direction, adjust cursorI to     */
	     searchPriorLocation = TRUE;		/*    point after last char of matched string.	        */
	     nss.pos.cursorI = ss.pos.cursorI + ss.matchL;
	     end;
	else if ss.pos.matchL > 0 & length(newSearchCh) > 0 then
	     searchPriorLocation = TRUE;

	cursorI = nss.pos.cursorI - ss.pos.matchL;
	if searchPriorLocation then do;
	     s_dataP = nss.pos.lineP;			/* If there was a prior match for the search, see if we   */
	     s_dataL = nss.pos.lineL;			/*  are looking back at the new search string.	        */
	     s_dataP = addr(s_char(cursorI));
	     s_dataL = min(length(nss.search), length(s_data)-(cursorI-1));
	     if length(s_data) = length(nss.search) & s_data = nss.search then do;
		nss.pos.matchL = length(nss.search);	/*  A match!				        */
		nss.pos.cursorI = nss.pos.cursorI + length(newSearchCh);
		call searchStackPush (nss);
		return (nss);
		end;
	     end;

	s_dataP = nss.pos.lineP;			/* Start by overlaying History from working line to end.  */
	s_dataL = hs.segL - charno(nss.pos.lineP);
	s_dataP = addr(s_char(cursorI+1));
	s_dataL = s_dataL - cursorI;			/*  - Include prior match - first char in search candidate*/

	searchI = index (s_data, nss.search);		/*  NB: searchI is index within REMAINDER of History Seg. */
	if searchI > 0 then do;			/*  Search succeeded.			        */
	     matchStartI = searchI;
	     matchEndI = (matchStartI-1) + length(nss.search);
						/*  NB: matchStartI, matchEndI are indexes within the     */
						/*   REMAINDER of the History Segment, not entire HS.     */

	     s_dataL = charno(s_dataP) + (searchI-1);	/*  Look backward to find start of line containing match. */
	     s_dataP = hs.segP;
	     nlRI = index (reverse(s_data), NL);	/*   nlRI is reverse index into leading part of History.  */
	     if nlRI = 0 then
		lineStartH = 1;			/*   Match found in first History Seg line.	        */
	     else lineStartH = (length(s_data)+1) - (nlRI-length(NL));
						/*   Match found elsewhere in History Seg.  Index char    */
						/*    after the NL.				        */

	     lPos = END_OF_HISTORY;			/*   Get historyLinePosition for this lineStartH.	        */
	     do while ( (lPos.lineP ^= addr(s_char(lineStartH))) & (lPos.lineP ^= hs.segP) );
		lPos = hSeg_editPosition(hs, lPos, -1);
		end;
	     nss.pos = lPos;
	     nss.pos.cursorI = nlRI + length(nss.search); /*   For FORWARD search, cursor after last char of match. */
	     nss.matchL = length(nss.search);
	     call searchStackPush (nss);
	     return (nss);
	     end;
	else do;					/*   Failure.  Remove newSearchCh from searchString.      */
	     call wBellRing();
	     return (ss);
	     end;
	end;

     end hSeg_editPosition;
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name:  hSeg_append_chars							        */
	/*									        */
	/* Function:  Appends characters to end of History Segment.				        */
	/* 	     - Increment hs.linesN if last line of History Segment already ends in NL char.     */
	/*	     - Adjust bc of History Segment file.				        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

hSeg_append_chars:
     proc (hs, lineFragment, temporary);
  
  dcl 1 hs aligned like ihData.hist.segmentData;		/* History Segment data.			        */
  dcl  lineFragment char(*);				/* Partial line of to added to History Segment.	        */
  dcl  temporary bit(1);				/* Append chars only for life of this editor request.     */

						/* View History Segment data:			        */
  dcl  hs_data char(hs.segL) based(hs.segP);		/*   -- as a string.			        */
  dcl  hs_char (hs.segL) char(1) based(hs.segP);		/*   -- as an array of characters.		        */

  dcl  hs_new char(hs_newL) based(hs_newP);		/* An overlay pointing beyond end of current data.        */
  dcl  hs_newP ptr;
  dcl  hs_newL fixed bin(21);

  dcl  nlI fixed bin(21);				/* Index (from end of History Segment data) of last NL.   */

     if length(lineFragment) + hs.segL > CHARS_PER_SEGMENT then do;
						/* Will new data cause segment out-of-bounds?	        */
	if temporary then return;			/*  - Don't do temporary append in this case.	        */
	if length(lineFragment) + hs.segL - hs.scrollableL > CHARS_PER_SEGMENT then do;
						/*  - Even with scrolling data off front, the new data    */
						/*    won't fit into the History Segment.  	        */
						/*     - Don't capture this lineFragment.	        */
						/*     - If the fragment is part of a partial line at end */
						/*       of History Segment, get rid of that earlier      */
						/*       remnant too.			        */
	     if hs.debug then
		call ioa_ ("^a: hs.segL (^d) + new chars (^d) would max-out History Segment.  Ignoring new chars.",
		     DEBUG_BANNER, hs.segL, length(lineFragment));

	     nlI = index(reverse(hs_data), NL);		/*     - Find last NL in the History Segment.	        */
	     if nlI = 0 then nlI = hs.segL+1;		/*     - No NL anywhere in History Segment?  Unlikely,    */
						/*       but get rid of all data in the segment.	        */
	     hs.segL = hs.segL-(nlI-1);		/*     - Remove all line-frag data following this NL.     */
	     call hSeg_append_chars(hs, " [Long Data Line Skipped]...", PERMANENT);
						/*     - Indicate that data was skipped in History Seg.   */
	     call hSeg_set_length (hs, hs.segL);
	     return;
	     end;
	call hSeg_scroll_lines (hs);			/*  - Scroll old lines off top of History Segment.        */
	end;					/*    The new fragment should fit now.		        */

     if hs.segL = 0 then do;				/* Are we appending to empty History Segment? 	        */
	hs.linesN = 1;				/*  - Count first line			        */
	hs_newP = hs.segP;
	end;
     else if temporary then do;			/* Terminate any partial line at end of History Segment   */
	if hs_char(hs.segL) ^= NL then do;		/*  before adding the temporary partial line.	        */
	     hs.segL = hs.segL+1;
	     hs_char(hs.segL) = NL;
	     hs.extraLineL = length(NL) + length(lineFragment);
	     end;
	else hs.extraLineL = length(lineFragment);
	hs.linesN = hs.linesN + 1;

	hs_newP = addcharno(hs.segP, hs.segL);
	end;
     else do;
	if hs_char(hs.segL) = NL then			/* Existing data ends in NL?  Means starting a new line.  */
	     hs.linesN = hs.linesN + 1;		/*   Add it to count.			        */
	else ;					/* Else just appending to an incomplete line at end of    */
						/*  History Segment.			        */
	hs_newP = addcharno(hs.segP, hs.segL);	
	end;

     hs.segL = hs.segL + length(lineFragment);		/* Add room for appending data to History Segment.        */
     hs_newL = length(lineFragment);			/* Overlay enough chars to hold appended data.	        */
     hs_new  = lineFragment;				/* Copy line fragment into History Segment.	        */
						/*   Touch any new page added to seg before set length.   */
     return;


hSeg_unappendExtraLine:				/* Remove temporarily appended chars.		        */
     entry (hs);

     if hs.extraLineL > 0 then do;
	hs.segL = hs.segL - hs.extraLineL;
	hs.linesN = hs.linesN - 1;
	end;
     return;

     end hSeg_append_chars;
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name:  hSeg_get								        */
	/*									        */
	/* Function:  Fills in ihData.hist.segmentData information for History Seg		        */
	/*  - Check history segment bit count (see if user changed bit count without telling us).         */
	/*  - Set its (possible new) length from bit count.				        */
	/*     - Recount lines in file, etc if unseen changes were made.			        */
	/*  - Check for overly-full History Segment (more than -lines N lines in the file).	        */
	/*     - While there is a fudge-factor (to reduce amount of scrolling), we occasionally must      */
	/*       scroll some lines off top of the History Segment.				        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

hSeg_get:
     proc (ih, code);
     
  dcl 1 ih aligned like ihData;
  dcl  code fixed bin(35);

  dcl  bcNow fixed bin(24);
  dcl  ignoreType fixed bin(2);

  dcl  hcs_$status_mins entry (ptr, fixed bin(2), fixed bin(24), fixed bin(35));

     call hcs_$status_mins (ih.hist.segP, ignoreType, bcNow, code);
     if code ^= 0 then return;

     if bcNow > 0 & bcNow ^= ih.hist.bc then do;		/* If bit count changed since last call, need to rescan   */
	ih.hist.bc = bcNow;				/*  the History Segment for line counts, etc.	        */
	ih.hist.segL = divide(ih.hist.bc, bits_per_character, 24, 0);
	call hSeg_count_lines (ih.hist.segmentData);
	end;

     if (ih.hist.linesN - ih.hist.scrollable_linesN) > ih.hist.limit_linesN then do;
	call hSeg_scroll_lines (ih.hist.segmentData);	/* If too full, History Segment is scrolled off top.      */
	end;

     ih.hist.extraLineL = 0;

     end hSeg_get;
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name: hSeg_scroll_lines							        */
	/*									        */
	/* Function: Given a History Segment (all hs values are set):			        */
	/* 	   - Overwrite scrollable lines of History Segment with remaining data.	        */
	/*	   - Adjust bc and segL accordingly.					        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

hSeg_scroll_lines:
     proc (hs);
  
  dcl 1 hs aligned like ihData.hist.segmentData;

						/* View History Segment data:			        */
  dcl  hs_data char(hs.segL) based(hs.segP);		/*   -- as a string.			        */
  dcl  hs_char (hs.segL) char(1) based(hs.segP);		/*   -- as an array of characters.		        */

  dcl  hs_data_moving char(hs_data_movingL) based(hs_data_movingP);
  dcl  hs_data_movingP ptr;
  dcl  hs_data_movingL fixed bin(21);
	
  dcl  hs_new_loc char(hs_data_movingL) based(hs.segP);

  dcl  scrolled_linesN fixed bin(24) init(hs.scrollable_linesN);

     if hs.scrollableL = 0 then return;			/* No scrollable data designated, yet.	Do nothing.       */

     if hs.scrollableL >= hs.segL then do;		/* If entire History Segment is to be scrolled off,       */
	call hSeg_set_length (hs, 0);			/*   there is no data to move; truncate the segment.      */
	return;
	end;
     
     hs_data_movingP = addr(hs_char(hs.scrollableL+1));	/* Overlay data to be moved.			        */
     hs_data_movingL = hs.segL - hs.scrollableL;

     hs_new_loc = hs_data_moving;			/* Move the data.				        */

     call hSeg_set_length (hs, hs_data_movingL);		/* Shorten the History Segment.		        */

     call hSeg_count_lines (hs);			/* re-do line counts (especially to find new scrollable)  */

     if hs.debug then
	call ioa_("^a: Scrolled ^d lines from history segment; it now has ^d lines", 
	     DEBUG_BANNER, scrolled_linesN, hs.linesN);

     end hSeg_scroll_lines;


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name:  hSeg_set_length							        */
	/*									        */
	/* Function: Given a History Segment (with hs.segL set):				        */
	/*	    - Adjust hs.bc and truncate the seg to its proper length.		        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

hSeg_set_length:
     proc (hs, new_segL);

  dcl 1 hs aligned like ihData.hist.segmentData;
  dcl  new_segL fixed bin(21);

  dcl  ignoreCode fixed bin(35);
  dcl  new_bc fixed bin(24);

  dcl  hcs_$set_bc_seg entry (ptr, fixed bin(24), fixed bin(35));
  dcl  hcs_$truncate_seg entry (ptr, fixed bin(19), fixed bin(35));

     if new_segL = 0 then do;				/* Truncating to 0-length is special case.	        */
	new_bc, hs.bc, hs.segL, hs.linesN, hs.scrollableL, hs.scrollable_linesN = 0;
	call hcs_$truncate_seg (hs.segP, 0, ignoreCode);	
	call hcs_$set_bc_seg (hs.segP, new_bc, ignoreCode);     
	return;
	end;

     new_bc = new_segL * bits_per_character;
     hs.segL = new_segL;

     if (new_bc < hs.bc) & (new_bc < hs.bc - BITS_PER_PAGE) then do;
  dcl  words fixed bin(19);				/* Only truncate History Segment if it shrinks a page.    */
	words = divide (new_segL + characters_per_word - 1, characters_per_word, 19, 0);
	call hcs_$truncate_seg (hs.segP, words, ignoreCode);
	end;

     hs.bc = new_bc;				/* Set bit count.				        */
     call hcs_$set_bc_seg (hs.segP, new_bc, ignoreCode);     

     end hSeg_set_length;
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name: hSeg_count_lines							        */
	/*									        */
	/* Function: Given a History Segment (hs.segP, hs.segL are set):			        */
	/*           Calculate: 	hs.linesN,					        */
	/* 			hs.scrollableL, and					        */
	/* 			hs.scrollable_linesN.				        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

hSeg_count_lines:
     proc ( hs );
  
  dcl 1 hs aligned like ihData.hist.segmentData;
     
  dcl  hs_rest char(hs_restL) based(hs_restP);
  dcl  hs_restP ptr;
  dcl  hs_restL fixed bin(21);

  dcl  lineL fixed bin(21);

     hs.linesN = 0;					/* Initialize return results.			        */
     hs.scrollable_linesN = 0;
     hs.scrollableL = 0;

     hs_restP = hs.segP;				/* First possible line overlays entire History Segment.   */
     hs_restL = hs.segL;

     do while (length(hs_rest) > 0);			/* Loop while lines remain to be found.		        */
	lineL = index(hs_rest, NL);
	if lineL > 0 then do;			/*  - End of line found?			        */
	     hs.linesN = hs.linesN + 1;		/*     - Increment line count.		        */
	     
	     if lineL = hs_restL then			/*  - Found last line in History Segment?  Stop loop.     */
		hs_restL = 0;
	     else do;
		hs_restP = addcharno(hs_restP, lineL);	/*  - Otherwise, move rest beyond end of just-found line. */
		hs_restL = hs_restL - lineL;
		end;

	     if hs.scrollableL = 0 & charno(hs_restP) >= CHARS_PER_PAGE then do;
		hs.scrollable_linesN = hs.linesN;	/*  - Haven't set scrollable region yet, but rest is now  */
		hs.scrollableL = charno(hs_restP);	/*    in second page of History Segment?  Set to lines    */
		end;				/*    and History Segment length examined so far.	        */
	     end;
          else do;
	     hs_restL = 0;
	     hs.linesN = hs.linesN + 1;
	     end;
	end;

     end hSeg_count_lines;
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name:  hSeg_copy								        */
	/*									        */
	/* Function:  If permanent History Segment exists but is locked, copy it into a temporary	        */
	/* History Segment (created in process directory) if possible.			        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

hSeg_copy:
     proc (pn, caller, errS);

  dcl 1 pn aligned like path;
  dcl  caller char(*);
  dcl  errS bit(1) aligned;

  dcl  bc fixed bin(24);
  dcl 1 co aligned like copy_options;
  dcl  code fixed bin(35);
  dcl  type fixed bin(2);

  dcl  NO_CHASE fixed bin(1) int static options(constant) init(0);
  dcl  SEGMENT fixed bin(2) int static options(constant) init(1);

  dcl  copy_ entry (ptr);
  dcl  hcs_$status_minf entry (char(*), char(*), fixed bin(1), fixed bin(2), fixed bin(24), fixed bin(35));
     
     call hcs_$status_minf (pn.pp_dir, pn.ename, NO_CHASE, type, bc, code);
     if code = error_table_$noentry then do;		/* If process_dir segment does not already exist, then    */
	co.version = COPY_OPTIONS_VERSION_1;		/*  copy permanent History Segment to process dir.        */
	co.caller_name = caller;
	co.source_dir = pn.dir;
	co.source_name = pn.ename;
	co.target_dir = pn.pp_dir;
	co.target_name = pn.ename;
	unspec(co.flags) = ZEROb;
	unspec(co.copy_items) = ZEROb;		/*  - Don't copy names, ACL, or ring brackets.	        */
	call copy_ (addr(co));
	end;
     call hcs_$status_minf (pn.pp_dir, pn.ename, NO_CHASE, type, bc, code);
     if errS then
	call com_err_ (0, caller, "Using per-process ^[copy of ^;^]History Segment: ^a", 
	     (code = 0 & bc > 0), pn.ename);

     end hSeg_copy;
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Names:  hSeg_lock, hSeg_unlock						        */
	/*									        */
	/* Function: routines to lock and unlock a permanent History Lock Segment, the segment	        */
	/* associated with a permanent history segment.					        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

hSeg_lock:
     proc (hs, hs_path, code) returns (bit(1));
     
  dcl 1 hs aligned like ihData.hist.segmentData;
  dcl  hs_path char(168);
  dcl  code fixed bin(35);
    
  dcl 1 hl aligned like hLockSeg based(hs.segLockP);

  dcl  UNSET bit(36) aligned int static options(constant) init(""b);

  dcl  static_lock_id bit(36) aligned int static init(UNSET);


     if hs.segLockP = null() then return(FALSE);		/* Return false if History Lock Segment was not created   */
						/*  or initiated successfully.		        */

  dcl  get_lock_id_ entry (bit(36) aligned);
  dcl  set_lock_$lock entry (bit(36) aligned, fixed bin, fixed bin(35));
  dcl  stacq builtin;				/* Hardware locking operator.			        */

     if static_lock_id = UNSET then call get_lock_id_ (static_lock_id);
     if stacq (hl.lock_word, static_lock_id, UNSET) then
	code = 0;
     else do;
	call set_lock_$lock (hl.lock_word, 0, code);
	if code = error_table_$invalid_lock_reset | code = error_table_$locked_by_this_process then
	     code = 0;
	else return (FALSE);
	end;

     hl.lock_descriptor = hLockSegDESCRIPTOR;		/* Set contents of History Lock Segment		        */
     hl.history_path = hs_path;
     hl.lock_sentinel = hLockSegSENTINEL_LOCKED;
     hl.lock_terminator = hLockSegTERMINATOR;
						/* Protect contents of History Lock Segment	        */
  dcl  hcs_$set_bc_seg entry (ptr, fixed bin(24), fixed bin(35));
  dcl  hcs_$set_safety_sw_seg entry (ptr, bit(1), fixed bin(35));
  dcl  size builtin;

     call hcs_$set_bc_seg (hs.segLockP, bits_per_word * size(hl), ignoreCode);
     call hcs_$set_safety_sw_seg (hs.segLockP, ON, ignoreCode);

     return (TRUE);
     
hSeg_unlock:
     entry (hs, code);

  dcl  set_lock_$unlock entry (bit(36) aligned, fixed bin(35));

     if static_lock_id = UNSET then call get_lock_id_ (static_lock_id);
     if hs.segLockP ^= null() then do;
	if stacq (hl.lock_word, UNSET, static_lock_id) then
	     code = 0;
	else call set_lock_$unlock (hl.lock_word, code);
	hl.lock_sentinel = hLockSegSENTINEL_UNLOCKED;
	end;
     else code = error_table_$lock_not_locked;

     end hSeg_lock;
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name:  historyLinePositions_equal						        */
	/*									        */
	/* Function:  Compare two historyLinePosition structure elements; return TRUE if corresponding    */
	/* elements are equal.							        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

historyLinePositions_equal:
     proc (posA, posB) returns(bit(1) aligned);
     
  dcl 1 (posA, posB) aligned like historyLinePosition;

     if posA.linesFromEnd ^= posB.linesFromEnd then return(FALSE);
     if posA.cursorI ^= posB.cursorI then return(FALSE);
     if posA.matchL  ^= posB.matchL  then return(FALSE);
     if posA.lineP   ^= posB.lineP   then return(FALSE);
     if posA.lineL   ^= posB.lineL   then return(FALSE);
     return(TRUE);

     end historyLinePositions_equal;


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name: historyLinePosition_to_str						        */
	/*									        */
	/* Function: return a string representation of a historyLinePosition structure.		        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

historyLinePosition_to_str:
     proc (pos) returns(char(500) var);
     
  dcl 1 pos aligned like historyLinePosition;
  dcl  posLine char(pos.lineL) based(pos.lineP);
  dcl ret char(500) var init("");
  dcl ioa_$rsnnl entry() options(variable);
     
     if pos.linesFromEnd = 0 then
	return("END_OF_HISTORY");

     call ioa_$rsnnl ("[linesFromEnd: ^d,   line: ^p (^d chars),   cursor index: ^d^[,  matchL: ^d^;^s^]]: ^a^24x'^a'", 
	ret, (0), 
	pos.linesFromEnd, pos.lineP, pos.lineL, pos.cursorI, pos.matchL>0, pos.matchL, NL, posLine);

     return(ret);
     
     end historyLinePosition_to_str;
%page;
ihData_display:
     proc (report, ihP);

  dcl  report entry options(variable);
  dcl  ihP ptr;

  dcl 1 ih aligned like ihData based(ihP);

     call report ("input_history_data:");
     call report (" i/o module --");
     call report ("  history_iocbP:        ^p ^[(^a)^]", ih.history_iocbP, 
	ih.history_iocbP ^= null(), ih.history_iocbP->iocb.name);
     call report ("  source_iocbP:         ^p ^[(^a)^]", ih.source_iocbP,  
	ih.source_iocbP ^= null(), ih.source_iocbP->iocb.name);
    if ih.source_iocbP ^= null() & ih.source_iocbP ^= ih.source_iocbP->iocb.actual_iocb_ptr then
     call report ("    actual_iocbP:       ^p (^a)", ih.source_iocbP->iocb.actual_iocb_ptr,
	ih.source_iocbP->iocb.actual_iocb_ptr->iocb.name);
     call report ("  source_is_window_io_: ^[true^;false^]", ih.source_is_window_io_);
     call report ("  attach_descrip:       ^a", ih.attach_descrip);
     call report ("  open_descrip:         ^a", ih.open_descrip);
     call report (" attach options --");
     call report ("  history path:         ^a>^a", ih.path_dir, ih.path_ename);
     call report ("  recommended lines:    ^d", ih.limit_linesN);
     call report (" history file --");
     call report ("  segP:                 ^p", ih.segP);
    if ih.segLockP ^= null() then
     call report ("  lockP:                ^p", ih.segLockP);
     call report ("  length (bits):        ^d", ih.bc);
     call report ("  length (chars):       ^d", ih.segL);
     call report ("  length (lines):       ^d", ih.linesN);
     call report ("  permanent:            ^[true^;false^]", ih.permanent);
     call report ("  debug:                ^[true^;false^]", ih.debug);
     call report (" scrollable history --");
     call report ("  length (chars):       ^d", ih.scrollableL);
     call report ("  length (lines):       ^d", ih.scrollable_linesN);
     call report (" editing function --");
     call report ("  currentLine           ^a", historyLinePosition_to_str(ih.currentLine));

     end ihData_display;
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name: ihData_from_attach_options						        */
	/*									        */
	/* Function: From input_history_ attach description options, allocate and initialize the ihData   */
	/* structure.  Return a pointer to the allocated structure.				        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Structure and constants to summarize intent of attach options:			        */
	/*   -pathname, -permanent, -perprocess, -truncate				        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

  dcl 1 path aligned,
      2 dir char(168) unal,				/*  - Expanded pathname (dir, and ename with suffix)      */
      2 ename char(32) unal,
      2 pp_dir char(168) unal,			/*  - Directory to use if accessing perprocess file.      */
      2 truncate bit(1) aligned,			/*  - Permanent file should be truncated to zero length   */
						/*    when attached.			        */
      2 trans_type fixed bin(2);			/*  - Transient nature of the given path, as expressed by */
						/*    one of the following constants.		        */
  dcl (transPERMANENT init(1),			/*     - File must be permanent; dir cannot be altered.   */
       transPERMANENT_or_PERPROCESS init(2),		/*     - Try for a permanent file; if not accessible,     */
						/*       then use a perprocess file. 		        */
       transPERPROCESS init(3))			/*     - File must be perprocess only.		        */
            fixed bin(2) int static options(constant);


ihData_from_attach_options:
     proc (caller, iocbP, premoved_iocb_name, opts, errS, ihP, code);

  dcl  caller char(*);				/* Caller on whose behalf attach options are processed.   */
						/*  This could be input_history_, or the input_history    */
						/*  command (an argument from $validate_attach_options).  */
  dcl  iocbP ptr;					/* Ptr to our IOCB.				        */
  dcl  premoved_iocb_name char(*);			/* Alternate source_iocb_name passed during validation.   */
						/*  See input_history_$validate_attach_options. (in)      */
  dcl  opts (*) char(*) var;				/* Attach description options. (in)		        */
  dcl  errS bit(1) aligned;				/* iox_$attach_loud com_err_ switch (in)	        */
  dcl  ihP ptr;					/* Ptr to ihData created herein. (out)		        */
  dcl  code fixed bin(35);				/* Status code, set before we branch to EXIT_attach if    */
						/*  any error is detected. (out)		        */

     ihP = null();					/* Initialize our output parms.		        */
     code = 0;


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Get parameters from our attach description.					        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

  dcl  source_iocb_name char (32);			/* First positional parm: switch_name		        */
						/*  This is listed as the monitored_switch attach option. */
						/*  But other I/O operations consider this to be the      */
						/*  source_iocbP, from which data is read/logged.	        */
  dcl  linesN fixed bin(35) unsigned;			/* Operand of -lines option.			        */
  dcl 1 pn aligned like path;				/* Summation of -pathname, -perm, -perprocess, -truncate  */
  dcl  dbS bit(1) aligned;				/* BOOL value of -debug option (out)		        */

     call parms_from_attach_options (caller, opts, errS,	/* Input args.				        */
	code, source_iocb_name, linesN, pn, dbS);	/* Output args, set by callee.		        */
						/*  If an error is found in attach options, callee        */
						/*  reports error, sets code, goes to EXIT_ihData.        */
						/*  Only successful option evaluations return here.       */

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Get our source IOCB, whose iox_$get_line results are to be captured.		        */
	/*  - Ideally, it is attached to the window_io_ module.  This is the only module we know how to   */
	/*    augment with history-searching keystroke functions (provided by this I/O module).	        */
	/*    If it is attached to another I/O module, we can still log input lines in history segment.   */
	/*  - Since this I/O module captures input lines, source IOCB must be open for:		        */
	/* 	stream_input  or  stream_input_output.					        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

  dcl (premoved_iocbP, source_iocbP, validate_iocbP) ptr;
  dcl  validate_iocb_name char(32);
  dcl  iox_$find_iocb entry (char(*), ptr, fixed bin(35));

     call iox_$find_iocb (source_iocb_name, source_iocbP, code);
     if code ^= 0 then do;
	if errS then
	     call com_err_ (code, caller, "Looking for monitored_switch: ^a", source_iocb_name);
	go to EXIT_ihData;				/* Both input_history command and input_history_ attach   */
	end;					/*  description refer to this as the monitored_switch     */

     validate_iocbP = source_iocbP;			/* In a normal attach operation, we validate the source   */
     validate_iocb_name = source_iocb_name;		/*  IOCB, which has already been moved to monitored_switch*/

     if premoved_iocb_name ^= "" then do;		/* In an attach by input_history command, it wants us to  */
						/*  validate what will become the monitored_switch before */
						/*  it has been moved.  Name of this switch is passed as  */
						/*  preremoved_iocb_name.			        */
	call iox_$find_iocb (premoved_iocb_name, premoved_iocbP, code);
	if code ^= 0 then do;
	     if errS then
		call com_err_ (code, caller, "Looking for source_switch: ^a", premoved_iocb_name);
						/* input_history calls the premoved_iocb_name its         */
	     go to EXIT_ihData;			/*  source_switch.				        */
	     end;
	validate_iocbP = premoved_iocbP;		/* Validate the premoved_iocb			        */
	validate_iocb_name = premoved_iocb_name;
	end;


  dcl attach_module char(128) var init("");		/* Our eventual source switch's I/O module...	        */
  dcl 1 attach_descrip aligned based,			/*  whose module name is extracted from source switch's   */
      2 length fixed bin,				/*  attach description.			        */
      2 string char (0 refer(attach_descrip.length));

     if validate_iocbP -> iocb.actual_iocb_ptr -> iocb.attach_descrip_ptr ^= null() then
	attach_module = validate_iocbP -> iocb.actual_iocb_ptr -> iocb.attach_descrip_ptr -> attach_descrip.string;
     attach_module = before(attach_module, " ");		/*  - Get I/O module name from its attach description.    */

     if attach_module = "" then do;			/* Error if eventual source switch is not attached.       */
	code = error_table_$bad_arg;
	if errS then 
	     call com_err_ (code, caller, "I/O switch ^a must be attached and open.", validate_iocb_name);
	go to EXIT_ihData;
	end;

  dcl source_open_mode char(32) var init("");		/* Our eventual source switch's opening mode...	        */
  dcl 1 open_descrip aligned based,			/*  whose mode name is extracted from source switch's     */
      2 length fixed bin,				/*  open description.			        */
      2 string char (0 refer (open_descrip.length));

     if validate_iocbP -> iocb.actual_iocb_ptr -> iocb.open_descrip_ptr ^= null() then
	source_open_mode = validate_iocbP -> iocb.actual_iocb_ptr -> iocb.open_descrip_ptr -> open_descrip.string;
     source_open_mode = before(source_open_mode, " ");	/* Get just opening mode from its open description.       */

     if source_open_mode ^= "stream_input" & source_open_mode ^= "stream_input_output" then do;
	code = error_table_$bad_arg;
	if errS then 
	     call com_err_ (code, caller, 
	          "I/O switch ^a must be open for stream_input or stream_input_output.", validate_iocb_name);
	go to EXIT_ihData;
	end;
						/* For syn_ attachment, open description comes from the   */
						/*  eventual target IOCB.  So we must see which I/O ops   */
						/*  are enabled to determine the effective syn_ open mode.*/
     if validate_iocbP -> iocb.put_chars = iox_$err_no_operation then
	source_open_mode = "stream_input";

     if validate_iocbP -> iocb.get_line = iox_$err_no_operation then do;
	code = error_table_$bad_arg;			/* Complain if we have nothing to monitor/log.	        */
	if errS then 
	     call com_err_ (code, caller, "I/O switch ^a must support stream_input operations.", validate_iocb_name);
	go to EXIT_ihData;
	end;


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Get information about the history segment.					        */
	/*  - For transPERMANENT, transPERMANENT_or_PERPROCESS:				        */
	/*     - Attempt to lock the permanent history segment (XXXX.hisLock file)		        */
	/*        - If locked, access the permanent history segment.			        */
	/*           - If accessible, use that history segment.				        */
	/*           - Else								        */
	/*              - If transPERMANENT_or_PERPROCESS, unlock the history segment and use a	        */
	/*	        per-process history segment.					        */
	/*              - Else report transPERMANENT segment is not accessible.		        */
	/*        - Else								        */
	/*           - If transPERMANENT_or_PERPROCESS, unlock the history segment and use a	        */
	/*	     per-process history segment.					        */
	/*           - Else report transPERMANENT segment is not accessible.			        */
	/*    - If segment was created, turn on safety switch for history segment and lock seg.	        */
	/*  - For transPERPROCESS:							        */
	/*     - Create (or initiate and reuse) history segment in the process directory.	        */
	/*  - For whatever type history segment:					        */
	/*     - Truncate the history segment if -truncate attach option was given.		        */
	/*     - Call hSeg_get to fill in basic information about the history segment.		        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

  dcl  hcs_$set_bc_seg entry (ptr, fixed bin(24), fixed bin(35));
  dcl  hcs_$set_safety_sw entry (char(*), char(*), bit(1), fixed bin(35));
  dcl  hcs_$status_mins entry (ptr, fixed bin(2), fixed bin(24), fixed bin(35));
  dcl  initiate_file_$create entry (char(*), char(*), bit(*), ptr, bit(1) aligned, fixed bin(24), fixed bin(35));

  dcl  bcNow fixed bin(24);
  dcl  ignoreCode fixed bin(35);
  dcl  lockEname char(32);
  dcl  madeSeg bit(1) aligned init(FALSE);

  dcl 1 hs aligned like ihData.segmentData;		/* Initialize segmentData portion of attach data.	        */
     hs.segLockP, hs.segP = null();
     hs.bc, hs.segL, hs.linesN, hs.scrollable_linesN, hs.scrollableL, hs.extraLineL = 0;
     unspec(hs.flags) = ZEROb;
     hs.debug = dbS;

     if pn.trans_type < transPERPROCESS then do;		/* For transPERMANENT, transPERMANENT_or_PERPROCESS       */
	lockEname = reverse (after (reverse(pn.ename), reverse(SEG_SUFFIX))) || SEG_LOCK_SUFFIX;
	call initiate_file_$create (pn.dir, lockEname, RW_ACCESS, 
	     hs.segLockP, madeSeg, bcNow, code);	/*  - Initiate or create the History Lock Segment.        */

	if hSeg_lock(hs, rtrim(pn.dir) || ">" || pn.ename, code) then do;
						/*  - Created/initiated, and Locked!		        */
	     call initiate_file_$create (pn.dir, pn.ename, RW_ACCESS,
		hs.segP, madeSeg, bcNow, code);	/*     - Initiate or create History Segment.	        */
	     if hs.segP = null() then do;
		call hSeg_unlock(hs, ignoreCode);	/* Then unlock the history segment.		        */
		if errS then 
		     call com_err_ (code, caller, "Cannot access: ^a>^a", pn.dir, pn.ename);
						/* Report error with initiate status 		        */
		if pn.trans_type = transPERMANENT then go to EXIT_ihData;
		end;				/* Only a permanent segment accepted?  Then fatal error   */
	     hs.permanent = TRUE;
	     end;
	else if pn.trans_type = transPERMANENT then do;	/* Creation, initiation, or locking failed for permanent  */
	     if errS then				/*  History Segment.			        */
		call com_err_ (code, caller, "Cannot lock: ^a>^a", pn.dir, lockEname);
	     go to EXIT_ihData;			/* Report error with initiate or locking status	        */
	     end;
	else call hSeg_copy (pn, caller, errS);		/* Try to copy locked History Segment to pdir.	        */
	end;
     
     if hs.segP = null() then do;			/* Need a temporary History Segment.		        */
	call initiate_file_$create (pn.pp_dir, pn.ename, RW_ACCESS,
	     hs.segP, madeSeg, bcNow, code);		/*  - Initiate or create History Segment.	        */
	if hs.segP = null() then do;
	     if errS then 
		call com_err_ (code, caller, "Cannot access: ^a>^a", pn.pp_dir, pn.ename);
	     go to EXIT_ihData;			/*  - Report error with initiate status		        */
	     end;					/*     This  error stops the attachment.	        */
	hs.permanent = FALSE;
	pn.dir = pn.pp_dir;
	end;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Normal chores:								        */
	/*  - Set safety switch on History Segment.					        */
	/*  - Truncate History Segment, if requested.					        */
	/*  - Calculate line counts, set bit count.					        */
	/*  - See if lines should be scrolled off top of History Segment.			        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

     call hcs_$set_safety_sw (pn.dir, pn.ename, ON, ignoreCode);
     if ^madeSeg then do;
	if pn.truncate then do;			/* Truncate existing History Segment, if requested.       */
	     call hSeg_set_length (hs, 0);
	     bcNow = 0;
	     if dbS then
		call ioa_$ioa_switch(validate_iocbP,
		     "   - truncating history segment: ^a>^a^a", pn.dir, pn.ename);
	     end;

	hs.bc = bcNow;
	hs.segL = divide(hs.bc, bits_per_character, 24, 0);
	call hSeg_count_lines (hs);
	end;

     if (hs.linesN - hs.scrollable_linesN) > linesN then	/* If too full, scroll lines off top of History Segment.  */
	call hSeg_scroll_lines (hs);		


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Allocate storage to hold our attach/open data.					        */
	/*  - Initialize ihData							        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

  dcl 1 ih aligned like ihData based(ihP);

     allocate ih in (ihArea);
     if ihP = null() then do;				/* Get storage for our attach data.		        */
	call hSeg_unlock(hs, ignoreCode);
	code = error_table_$noalloc;
	if errS then
	     call com_err_ (code, caller, "Cannot get storage for ^a attach data.", PROC);
	go to EXIT_ihData;
	end;
     unspec(ih) = ZEROb;				/* Initialize attach data to zeros.  		        */

     ih.hist.attachOpt.path_dir = pn.dir;		/* Copy attach option settings into attach_data.	        */
     ih.hist.attachOpt.path_ename = pn.ename;
     ih.hist.attachOpt.limit_linesN = linesN;
     ih.hist.segmentData = hs;			

     ih.history_iocbP = iocbP;			/* Set elements appropriate for an attached I/O module.   */
     ih.source_iocbP = source_iocbP;
     ih.source_is_window_io_ = (attach_module = "window_io_");
     ih.attach_descrip = PROC || " " || rtrim(source_iocb_name) || 
	" -pn " || rtrim(ih.hist.path_dir) || ">" || rtrim(ih.hist.path_ename) ||
	" -ln " || ltrim(char(linesN));

     ih.open_descrip = source_open_mode;		/* Set elements appropriate for an open I/O module.       */
						/*  (The attach operation for a monitoring I/O module     */
						/*   also opens the IOCB.)			        */

     ih.edit.currentLine = END_OF_HISTORY;		/* We start out positioned after last line of History.    */

     ih.savedKeyBindingsP = null();			/* No window_io_ line editor key bindings have been added */
						/*  so far, so nothing needs to be restored at close time.*/
     return;

EXIT_ihData:					/* Exit after error encountered.		        */
						/*  - code already set before getting here.	        */
     if ihP ^= null then do;				/*  - Free any allocated data.		        */
	call hSeg_unlock (ih.hist.segmentData, ignoreCode);
	free ih in (ihArea);
	ihP = null;
	end;
     return;
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name:  parms_from_attach_options						        */
	/*									        */
	/* Function: Parse p_options to determine attach input values.  Assign defaults as needed.        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

parms_from_attach_options:
	proc (caller, opts, errS, 
	      code, source_iocb_name, linesN, pn, debugS);

  dcl  caller char(*);				/* Caller's name. (in)			        */
  dcl  opts (*) char(*) var;				/* Caller's options array parameter. (in)	        */
  dcl  errS bit(1) aligned;				/* Caller wants us to call com_err_ to diagnose. (in)     */

  dcl  code fixed bin(35);				/* Caller's status parameter.  We set it before exiting   */
						/*  if an error is found. (out)		        */
  dcl  source_iocb_name char (32);			/* First positional parm: switch_name (out)	        */
  dcl  linesN fixed bin(35) unsigned;			/* Operand of -lines option. (out)		        */
  dcl 1 pn aligned like path;				/* History path after applying -pn, -pp, -perm, and -tc   */
						/*  options. (out)				        */
  dcl  debugS bit(1) aligned;				/* BOOL value of -debug option (out)		        */

  dcl (permanentS, perprocessS, truncateS)		/* BOOL value of -permanent and -perprocess options.      */
           bit(1) aligned init(FALSE);
  dcl  optI fixed bin init(1);			/* Index of opts element being examined.	        */
  dcl (optSourceName, optLines) bit(1) aligned init(FALSE); /* Flag indicating next option is a control arg operand.  */
  dcl  pathnameOperand fixed bin init(0);		/* Index of -pathname operand option.		        */

  dcl (conversion, size) condition;

	optSourceName = TRUE;			/* source_iocb_name is required, must be given first.     */

	linesN = 200;				/* Assign default values to other parameters.	        */
	debugS = FALSE;

attach_arg_loop:
	do while (optI <= hbound(opts,1));
	     if optSourceName then do;		/* opts element is source_iocb_name		        */
		source_iocb_name = opts(optI);
		optSourceName = FALSE;
		end;

	     else if optLines then do;		/* opts element is operand of -lines		        */
		on conversion, size begin;
		     code = error_table_$bad_conversion;
		     if errS then 
			call com_err_ (code, caller, "Converting -lines ^a", onsource());
		     go to EXIT_ihData;
		     end;
		linesN = binary(opts(optI), 35, 0);
		optLines = FALSE;
		end;
	
	     else if opts(optI) = "-pathname" | opts(optI) = "-pn" then 
		pathnameOperand, optI = optI + 1;

	     else if opts(optI) = "-lines"    | opts(optI) = "-ln" then
		optLines = TRUE;
	
	     else if opts(optI) = "-debug" | opts(optI) = "-db" then
		debugS = TRUE;
	
	     else if opts(optI) = "-permanent" | opts(optI) = "-perm" then
		permanentS = TRUE;
	
	     else if opts(optI) = "-perprocess" | opts(optI) = "-pp" then
		perprocessS = TRUE;
	
	     else if opts(optI) = "-truncate" | opts(optI) = "-tc" then
		truncateS = TRUE;
	
	     else do;				/* Unknown opts element value.		        */
		code = error_table_$bad_arg;
		if errS then
		     call com_err_ (code, caller, "Unsupported attach argument: ^a", opts(optI));
		go to EXIT_ihData;			
		end;

	     optI = optI + 1;			/* Examine the next opts element.		        */
	     end attach_arg_loop;


	if optSourceName then do;			/* Diagnose error if source_iocb_name is not given.       */
	     code = error_table_$noarg;
	     if errS then 
		call com_err_ (code, caller, "Missing switch_name attach argument." );
	     go to EXIT_ihData;
	     end;
	if optLines then do;			/* -pathname or -lines given without an operand.	        */
	     code = error_table_$noarg;
	     if errS then
		call com_err_ (code, caller, "Missing operand for lines attach argument.");
	     go to EXIT_ihData;
	     end;


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Notes on the History path arguments:						        */
	/*									        */
	/* -pathname, -permanent, and -perprocess control arguments may be used in combination, according */
	/* to the following table:							        */
	/*									        */
	/*   -pathname	-permanent	-perprocess   CASE	MEANING			        */
	/*     GIVEN	  GIVEN		  GIVEN	      7	Invalid combination of control args   */
	/*									        */
	/*     GIVEN	  GIVEN		    -	      6	-pathname must be accessible or else  */
	/*						  the attach operation fails.	        */
	/*     GIVEN	    -		  GIVEN	      5	If -pathname not accessible, use a    */
	/*						  per-process history segment.        */
	/*     GIVEN	    -		    -	      4	If -pathname not accessible, use a    */
	/*						  per-process history segment.        */
	/*       -	  GIVEN		  GIVEN	      3	Invalid combination of control args   */
	/*									        */
	/*       -	  GIVEN		    -	      2	If default -pn value not accessible,  */
	/*						  the attach operation fails.	        */
	/*       -	    -		  GIVEN	      1	Use a per-process history segment.    */
	/*									        */
	/*       -	    -		    -	      0	If default -pn value not accessible,  */
	/*						  use a per-process history segment.  */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

	if (permanentS & perprocessS & pathnameOperand>0 )
	 | (permanentS & perprocessS ) then do;		/* Case 7, 3 are errors			        */
	     code = error_table_$inconsistent;
	     if errS then
		call com_err_ (code, caller, "-permanent^[, ^; and ^]-perprocess^[, and -pathname^]", 
		     pathnameOperand>0, pathnameOperand>0);
	     go to EXIT_ihData;
	     end;

	if permanentS then				/* Case 6, 2				        */
	     pn.trans_type = transPERMANENT;
	else if (perprocessS & pathnameOperand=0) then	/* Case 1					        */
	     pn.trans_type = transPERPROCESS;
	else pn.trans_type = transPERMANENT_or_PERPROCESS;/* Case 5, 4, 0				        */
	     
	pn.truncate = truncateS;

  dcl  person_id char(22);
  dcl  expand_pathname_$add_suffix entry (char(*), char(*), char(*), char(*), fixed bin(35));
  dcl  get_pdir_ entry() returns(char(168));		
  dcl  user_info_ entry (char(*), char(*), char(*));
  dcl  user_info_$homedir entry (char(*));

	pn.pp_dir = get_pdir_();
	if pathnameOperand > 0 then do;		/* Case 6, 5, 4				        */
	     call expand_pathname_$add_suffix ((opts(pathnameOperand)), SEG_SUFFIX, pn.dir, pn.ename, code);
	     if code ^= 0 then do;
		if errS then 
		     call com_err_ (code, caller, "Expanding -pathname ^a", opts(pathnameOperand));
		go to EXIT_ihData;
		end;
	     end;
	else do;					/* Case 2, 1, 0				        */
	     if pn.trans_type = transPERPROCESS then
		pn.dir = "";
	     else call user_info_$homedir (pn.dir);		
	     call user_info_ (person_id, "", "");
	     pn.ename = rtrim(person_id) || "." || SEG_SUFFIX;
	     end;

	end parms_from_attach_options;

     end ihData_from_attach_options;
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name:  validate_attach_options						        */
	/*									        */
	/* Function:  ih and ihtest call this entry with an array of input_history_ attach options.  The  */
	/* input_history_ internal routines construct an attach data structure (ihData) using these       */
	/* attach options.  This ihData is returned without actually attaching input_history_ to its      */
	/* usual source IOCB (iox_$user_i/o, which is attached to window_io_).		        */
	/*									        */
	/* input_history command calls this entry, only before it moves the user_i/o switch to a new      */
	/* monitored_switch, so input_history_ can subsequently be attached to user_i/o.	        */
	/*   p_preremoved_iocb_name = "user_i/o",  p_options(1) = monitored_switch		        */
	/*									        */
	/* ihtest calls this entry only to simulate monitoring of the user_i/o switch.  The user_i/o      */
	/* attachment is not moved by ihtest, nor is input_history_$input_history_attach ever called.     */
	/* Instead, the cached ihDataP is used by line editor functions provided by input_history_ to     */
	/* peruse a specified history segment without input_history_ ever being attached.  This allows    */
	/* the user to set breakpoints in input_history_ code for these editor functions, etc.	        */
	/*   p_preremoved_iocb_name = "user_i/o",  p_options(1) = "user_i/o"			        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

validate_attach_options:
     entry (caller, p_premoved_iocb_name, p_options, p_code);

  dcl  caller char(*);				/* Name of calling command.  Errors printed on its behalf.*/
  dcl  p_premoved_iocb_name char(*);			/* Name of IOCB to be validated.  This attachment will    */
						/*  eventually be moved to monitored IOCB.	        */
     
     call ihData_from_attach_options(caller, null(), p_premoved_iocb_name, p_options, TRUE, ihDataP, p_code);
     if ihDataP = null then do;			/* Return if attach failed.			        */
	if p_code = 0 then p_code = error_table_$not_attached;
	return;
	end;

     if p_premoved_iocb_name = "user_i/o" then		/* Save ihData in cache if attach succeeds for user_i/o.  */
	call iocb_dict_set (iox_$user_io, ihDataP);
     return;
%page;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Names: iocb_dict_get, iocb_dict_set, iocb_dict_clear				        */
	/*									        */
	/* Functions: the iocb dictionary provides an associative memory for linking the iocb pointer     */
	/* for a source I/O attachment to the user I/O module's attach data.  The key_iocbP is (usually)  */
	/* the monitored_switch, attached to window_io_.					        */
	/*									        */
	/* This is needed because the window_io_ line_editor_info data structure only provides an	        */
	/* iocb_ptr to the source_iocbP (the window_io_ attachment being monitored); this does not give   */
	/* any access of the our iocbP (user_io) or its attach data.  So as part of installing our        */
	/* editing requests in the window_io_ line editor, we also store our attach data pointer in this  */
	/* memory, associated with the source_iocbP pointer (which window_io_ then provides in its        */
	/* line_editor_info (lei) structure, passed to each external editor request.		        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

  dcl 1 iocb_dict (10) aligned int static,		/*  - Each entry contains:			        */
      2 in_use bit(1) aligned init((10)FALSE),		/*     - Flag:  is this entry valid (populated)	        */
      2 pad bit(1) aligned,
      2 actual_iocbP ptr,				/*     - Key:   an iocb.actual_iocb_ptr value	        */
      2 ihDataP ptr;				/*     - Value: ptr to associated ihData structure.       */

iocb_dict_get:					/* Get associated attach data out of the memory.	        */
     proc (key_iocbP) returns(ptr);

  dcl  key_iocbP ptr;				/* Possible key value to search for.		        */

  dcl  i fixed bin;
     
     do i = lbound(iocb_dict,1) to hbound(iocb_dict,1);
	if iocb_dict(i).in_use then
	     if key_iocbP = iocb_dict(i).actual_iocbP then
	          return(iocb_dict(i).ihDataP);
	end;
     return(null());

iocb_dict_set:					/* Store attach data in the memory, associated with a     */
     entry (key_iocbP, value_ihDataP);			/*  source IOCB pointer.			        */

  dcl  value_ihDataP ptr;
     
  dcl  ih_iocb_dict_overflow condition;

     do i = lbound(iocb_dict,1) to hbound(iocb_dict,1);
	if ^iocb_dict(i).in_use then do;
	     iocb_dict(i).in_use = TRUE;
	     iocb_dict(i).actual_iocbP = key_iocbP;
	     iocb_dict(i).ihDataP = value_ihDataP;
	     return;
	     end;
	end;
     signal ih_iocb_dict_overflow;
     return;


iocb_dict_clear:					/* Remove an associated from the memory.	        */
     entry (key_iocbP);

     do i = lbound(iocb_dict,1) to hbound(iocb_dict,1);
	if iocb_dict(i).in_use & key_iocbP = iocb_dict(i).actual_iocbP then do;
	     iocb_dict(i).actual_iocbP = null();
	     iocb_dict(i).ihDataP = null();
	     iocb_dict(i).in_use = FALSE;
	     return;
	     end;
	end;
     
     end iocb_dict_get;
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name:  test_iocb_dict_display						        */
	/*									        */
	/* Function:  display all associations in the iocb_dict memory.			        */
	/*									        */
	/* Notes:  This entrypoint is called by the ihtest command.  That command tests input_history_    */
	/* edit functions without adding those functions to the window_io_ line editor.  This permits     */
	/* debugging the functions using probe while still funneling input and output through window_io_. */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

test_iocb_dict_display:				/* Display all associations in the memory.	        */
     entry();

  dcl 1 ioc aligned like io_call_info based(iocP);
  dcl  iocP ptr;
     allocate ioc in (ihArea);
     ioc.caller_name = PROC;
     ioc.order_name = "get_input_history_data";
     ioc.report = ioa_;
     ioc.error = com_err_;
     ioc.af_returnp = null();
     ioc.af_returnl = 0;
     unspec(ioc.fill) = FALSE;

  dcl  testI fixed bin;

     call ioa_ ("^a: iocb_dict:", DEBUG_BANNER);
     do testI = lbound(iocb_dict,1) to hbound(iocb_dict,1);
	if iocb_dict(testI).in_use then do;
	     call ioa_("^a: iocbP: ^p (^a), ihDataP: ^p", DEBUG_BANNER, 
		iocb_dict(testI).actual_iocbP, iocb_dict(testI).actual_iocbP->iocb.name,
		iocb_dict(testI).ihDataP);
	     ihDataP = iocb_dict(testI).ihDataP;
	     call ihData_display (ioa_, ihDataP);
	     call ioa_("  origEditorLine        '^a',   cursor index: ^d", 
		ihData.origEditorBuffer, ihData.origCursorI);
	     end;
	end;

     return;
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name: test_iocb_dict_set, test_iocb_dict_get, test_iocb_dict_clear			        */
	/*									        */
	/* Function:  ihtest calls these entrypoints to test and use the IOCB-to-attach-data associative  */
	/* memory functions.  In this fashion, it can establish a test environment for the	        */
	/* input_history_ edit functions without actually attaching to the input_history_ I/O module.     */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

test_iocb_dict_set:
     entry (test_iocbP, test_ihDataP);

  dcl test_iocbP ptr;
  dcl test_ihDataP ptr;

     call iocb_dict_set (test_iocbP, test_ihDataP);
     return;

test_iocb_dict_get:
     entry (test_iocbP) returns(ptr);

     return (iocb_dict_get(test_iocbP));

test_iocb_dict_clear:
     entry (test_iocbP);

     call iocb_dict_clear (test_iocbP);
     return;
%page;
%include access_mode_values;
%page;
%include copy_options;
%include copy_flags;
%page;
%include io_call_info;
%page;
%include window_io_attach_data_;

  dcl 1 window_io_attach_data aligned like attach_data based(iocbP->iocb.attach_data_ptr);

  dcl  ihArea area based(get_system_free_area_());	/* Area in which input_history_ attach data is allocated. */
						/* It is declared here, because it depends upon 	        */
						/* get_system_free_area_, which is declared in the        */
						/* window_io_attach_data_ include file.	 This follows the */
						/* mechanism used within window_io_ for its allocations.  */
%page;
%include window_control_info;
%page;
%include window_dcls;
%page;
%include window_line_editor;
%page;
%include system;
%page;
%include system_constants;
%page;
%include iocb;

     end input_history_;
