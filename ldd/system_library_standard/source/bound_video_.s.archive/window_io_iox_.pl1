/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        *                                                         *
        *********************************************************** */

/* Window_io_iox_ ... line editor and output converter for video */
/* format: style4,delnl,insnl,indattr,ifthen,dclind9 */

window_io_iox_:
     procedure;

	return;

/* BIM June 1981 */
/* Modified by Chris Jones, December 1981, to add more_mode=fold processing
   and to remove beep from empty kill */
/* Modified January 1982 by Chris Jones to finish input escape processing
   and make BS act as an erase character */
/* Modified 26 January 1982 by William York to add user-settable more
   handlers */
/* Modified 28 April 1982 by WMY to fix a bug in async handling during
   raw output requests. Added the REPUT_RAW label. */
/* Modified 7 May 1982 by WMY to fix a bug where the call for the second
   half of a long_record input line reads a new input line from the user
   instead, and to stop flushing the entire kill ring when CR is typed. */
/* Modified 16 May 1982 by WMY to stop more_mode=fold from crawling up
   the screen one line at a time, and to make ^L clear the screen before
   redisplaying the input line (just like ESC ^L), and to put a limit
   on growth of the kill ring. */
/* Modified 10 September 1982 by WMY to perform a send_buffered_output control
   order after reading an input line and after processing each put_chars call.
   This makes tc_ level output buffering less visible to the iox_ caller. */
/* Modified 20 September 1982 by WMY to change the send_buffered_output
   control order to a window_$sync call. */
/* Modified 1 October 1982 by WMY to make QUIT during more breaks work. */
/* Modified 4 October 1982 by WMY for a complete re-write. Implemented
   mid-line editing, input line redisplay, etc. */
/* Modified January 1983 by WMY to reset the window status when exiting
   raw mode. */
/* Modified Februrary 1983 by WMY to add user-settable key bindings. */
/* Modified April 1983 by WMY to fix bugs (no rtrim of output lines and
   kill merging across CR) and add input conversion support. */
/* Modified April 1983 by WMY to add window_util_ entrypoints for use by
   external editor routines. */
/* Modified April 1983 by WMY to restructure code so that calls from external
   editor routines will work correctly. */
/* Modified 6 June 1983 by WMY to try re-sizing the window if a call to
   window_ gets a out_of_window_bounds error code. The assumption here is
   that the terminal's screen has shrunk due to reconnection. */
/* Modified 23-24 June 1983 by Jon A. Rochlis to implement numeric arguments
   to editor routines, stop non-echoed input from being saved on the kill
   ring, and to give user routines the keysequences which invoked them. */
/* Modified 25 June 1983 by JR to add ESC-L, ESC-U, ESC-C, and ESC-T builtin
   requests. */
/* Modified 9 October 1983 by JR to add first cut at edit_line */
/* Modified December 1983 by JR to add support for vertical windows. */
/* Modified 1 February 1984 by JR to make the deffault bindings for builtins
   be case-insensitive.  I.e. ESC-f and ESC-F will be bound at init time
   to FORWARD_WORD.  This should make CLJ happy. */
/* Modified 29 February 1984 by Barmar to make free_dispatch_tables
   externally available */
/* Modified 22 March 1984 by Barmar to make get_line initialize user_data_ptr
   to null, and to be better at cleaning up. */
/* Modified 29 April 1984 by JR to add LEI.suppress_redisplay. */
/* Modified 27 May 1984 by JR to make async_or_error deal with reconnection
   and ttp_change status. */
/* Modified 01 September 1984 by JR to support edited mode. */


/****^  HISTORY COMMENTS:
  1) change(1986-05-17,GDixon), approve(1986-05-17,MCR7357),
     audit(1986-07-10,Farley), install(1986-07-18,MR12.0-1098):
     Change call from tct_$translate to find_char_$translate_first_in_table.
     The tct_ subroutine was renamed.
  2) change(1988-09-19,Brunelle), approve(1988-09-19,MCR7813),
     audit(1988-10-05,Blair), install(1988-10-17,MR12.2-1171):
     Change convert_special_sequence to return a special char sequence of up to
     15 chars instead of 3.  This implements special chars version 2 data
     structure.
  3) change(2016-05-09,GDixon), approve(2016-06-12,MCR10013),
     audit(2016-06-12,Swenson):
     Enhance window_io_ line editor with new features to support external
     editing functions.
      a) Support line_editor_info_version_3 structure, passed to external
         editing functions.  This include post-processing of any
         new_break_character returned by an external editing function; and
         including a redisplay entry variable in the structure.
      b) Adding get_top_kill_ring_string_ entrypoint, which returns kill ring
         text as a varying string, so caller may determine the exact text atop
         the ring.
      c) Changing redisplay_input_buffer to properly declare the
         line_editor_info structure passed to it as an argument, rather than
         using the structure pointer setup by its caller.  This is essential
         when passing redisplay_input_buffer as the lei.redisplay value (change
         3a above).
                                                   END HISTORY COMMENTS */


/* Simulate standard tty stuff in a window */

/* Parameters */

dcl      Iocb_ptr		  pointer parameter;
dcl      Buffer_ptr		  pointer parameter;
dcl      Buffer_len		  fixed bin (21) parameter;
dcl      Code		  fixed bin (35) parameter;
dcl      N_returned		  fixed bin (21) parameter;

/* Parameters for utility entrypoints */

dcl      a_lei_ptr		  pointer parameter;
dcl      a_count		  fixed bin (21) parameter;
dcl      a_kill_direction	  bit (1) aligned parameter;
dcl      a_text		  char (*) parameter;
dcl      a_text_var		  char (*) varying parameter;
dcl      a_code		  fixed bin (35) parameter;
dcl      a_table_ptr	  pointer parameter;

/* Based */

dcl      Buffer		  character (Buffer_len) based (Buffer_ptr);

/* Automatic */

dcl      temp_ptr		  pointer;
dcl      key_idx		  fixed bin;
dcl      get_line_entry_line	  fixed bin;
dcl      get_line_entry_column  fixed bin;
dcl      iocb_ptr		  pointer;
dcl      number_to_save	  fixed bin (21);
dcl      char_varying	  char (1) varying;
dcl      char_nonvarying	  char (1);
dcl      char_count		  fixed bin;
dcl      code		  fixed bin (35);

dcl      redisplay_buffer_ptr	  pointer;		/* This buffer is made to be 4 times longer than the input buffer  in
						   line_editor_info. */
dcl      redisplay_buffer	  char (2048) based (redisplay_buffer_ptr);

dcl      window_line_used_ptr	  pointer;
dcl      WINDOW_LINE_USED	  (attach_data.current.rows) bit (1) based (window_line_used_ptr);

dcl      lei_ptr		  pointer;

dcl      1 LEI		  aligned like line_editor_info based (lei_ptr);

dcl      1 automatic_line_editor_info
			  aligned like line_editor_info;

dcl      saved_buffer_length	  fixed bin;

dcl      1 saved_buffer	  aligned based (attach_data.saved_buffer_ptr),
	 2 saved_length	  fixed bin,
	 2 text		  char (saved_buffer_length refer (saved_buffer.saved_length)) varying;

/* Global variables. */

dcl      REAL_CL_INTERMEDIARY	  entry (1 structure aligned, 2 bit (1) unaligned, 2 bit (35) unaligned) variable;
dcl      BREAKS_CHANGED	  bit (1);
dcl      SAVED_BREAKS	  bit (128) unaligned;
dcl      ASYNC_EVENT	  label variable local;
dcl      ERROR_COUNT	  fixed bin;
dcl      PROCESSED_SO_FAR	  fixed bin;

dcl      cleanup		  condition;

/* Constants */

dcl      TEN_SPACES		  char (10) static options (constant) init ("          ");
dcl      CONTINUATION_CHARS	  char (2) static options (constant) init ("\c");
dcl      FORWARD_KILL	  bit (1) aligned static options (constant) init ("0"b);
dcl      BACKWARD_KILL	  bit (1) aligned static options (constant) init ("1"b);
dcl      NL		  char (1) static options (constant) init ("
");
dcl      DEL		  char (1) static options (constant) init ("");
dcl      BELL		  char (1) static options (constant) init ("");
dcl      uppercase		  char (26) static options (constant) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
dcl      lowercase		  char (26) static options (constant) init ("abcdefghijklmnopqrstuvwxyz");

/* External */

dcl      (
         error_table_$long_record,
         error_table_$action_not_performed,
         error_table_$unimplemented_version,
         error_table_$bad_subr_arg,
         video_et_$window_status_pending,
         video_et_$out_of_window_bounds,
         video_et_$cursor_position_undefined,
         video_et_$capability_lacking
         )		  ext static fixed bin (35);

/* Builtins */

dcl      (addcharno, addr, bin, byte, copy, divide, fixed, hbound, index, lbound,
	length, max, maxlength, min, mod, null, rank, reverse,
	rtrim, search, sign, string, substr, translate, unspec, verify)
			  builtin;

/* Entries */

dcl      cu_$get_cl_intermediary
			  entry (entry);
dcl      cu_$set_cl_intermediary
			  entry (entry);

nulle:						/* borrow as reference entry variable */
init:
     entry (Iocb_ptr);

	iocb_ptr = Iocb_ptr -> iocb.actual_iocb_ptr;
	attach_data_ptr = iocb_ptr -> iocb.attach_data_ptr;

	attach_data.saved_buffer_ptr = null ();

	allocate dispatch_table set (dispatch_table_ptr);

/* First make all non-printing keys unbound. */
	dispatch_table.key (*).type = UNDEFINED;
	dispatch_table.key (127).type = UNDEFINED;

/* Now get the self-inserts. */
	do key_idx = 32 to 126;
	     dispatch_table.key (key_idx).type = SELF_INSERT;
	end;

	dispatch_table.key (1).type = MOVE_TO_BEGINNING_OF_LINE;
						/* ^A */
	dispatch_table.key (2).type = BACKWARD_CHARACTER; /* ^B */
	dispatch_table.key (4).type = FORWARD_DELETE_CHARACTER;
						/* ^D */
	dispatch_table.key (5).type = MOVE_TO_END_OF_LINE;/* ^E */
	dispatch_table.key (6).type = FORWARD_CHARACTER;	/* ^F */
	dispatch_table.key (8).type = BACKWARD_DELETE_CHARACTER;
						/* ^H */
	dispatch_table.key (9).type = SELF_INSERT;	/* ^I */
	dispatch_table.key (10).type = TERMINATE_INPUT_LINE;
						/* ^J */
	dispatch_table.key (11).type = KILL_TO_END_OF_LINE;
						/* ^K */
	dispatch_table.key (12).type = CLEAR_WINDOW;	/* ^L */
	dispatch_table.key (13).type = TERMINATE_INPUT_LINE;
						/* ^M */
	dispatch_table.key (17).type = QUOTE_CHARACTER;	/* ^Q */
	dispatch_table.key (20).type = TWIDDLE_CHARACTERS;/* ^T */
	dispatch_table.key (21).type = MULTIPLIER;	/* ^U */
	dispatch_table.key (25).type = YANK_FROM_KILL_RING;
						/* ^Y */
	dispatch_table.key (31).type = DISPLAY_EDITOR_DOCUMENTATION;
						/* ^_ */
	dispatch_table.key (127).type = BACKWARD_DELETE_CHARACTER;
						/* DEL */

	dispatch_table.key (rank (attach_data.kill_char)).type = KILL_TO_BEGINNING_OF_LINE;
	dispatch_table.key (rank (attach_data.erase_char)).type = BACKWARD_DELETE_CHARACTER;
	dispatch_table.key (rank (attach_data.input_escape_char)).type = PROCESS_INPUT_ESCAPE;

	dispatch_table.name (*), dispatch_table.description (*), dispatch_table.info_dir (*),
	     dispatch_table.info_entry (*) = "";

	attach_data.dispatch_table_ptr = dispatch_table_ptr;

/* Allocate a second-level dispatch table for ESC prefix */
	allocate dispatch_table set (temp_ptr);

/* Start out with all unbound. */
	temp_ptr -> dispatch_table.key (*).type = UNDEFINED;

	dispatch_table.key (27).next_table = temp_ptr;
	dispatch_table.key (27).type = -1;

	dispatch_table_ptr = temp_ptr;

/* Fill in ESC prefix values. */

	dispatch_table.key (rank ("0")).type = NUMBER_READER_0;
	dispatch_table.key (rank ("1")).type = NUMBER_READER_1;
	dispatch_table.key (rank ("2")).type = NUMBER_READER_2;
	dispatch_table.key (rank ("3")).type = NUMBER_READER_3;
	dispatch_table.key (rank ("4")).type = NUMBER_READER_4;
	dispatch_table.key (rank ("5")).type = NUMBER_READER_5;
	dispatch_table.key (rank ("6")).type = NUMBER_READER_6;
	dispatch_table.key (rank ("7")).type = NUMBER_READER_7;
	dispatch_table.key (rank ("8")).type = NUMBER_READER_8;
	dispatch_table.key (rank ("9")).type = NUMBER_READER_9;
	dispatch_table.key (rank ("-")).type = NEGATIVE_NUMBER_READER;

	dispatch_table.key (rank ("b")).type = BACKWARD_WORD;
	dispatch_table.key (rank ("c")).type = INITIAL_CAPITAL;
	dispatch_table.key (rank ("d")).type = FORWARD_DELETE_WORD;
	dispatch_table.key (rank ("f")).type = FORWARD_WORD;
	dispatch_table.key (rank ("l")).type = LOWERCASE_WORD;
	dispatch_table.key (rank ("t")).type = TWIDDLE_WORDS;
	dispatch_table.key (rank ("u")).type = UPPERCASE_WORD;
	dispatch_table.key (rank ("y")).type = YANK_PREVIOUS_FROM_KILL_RING;

	dispatch_table.key (rank ("B")).type = BACKWARD_WORD;
	dispatch_table.key (rank ("C")).type = INITIAL_CAPITAL;
	dispatch_table.key (rank ("D")).type = FORWARD_DELETE_WORD;
	dispatch_table.key (rank ("F")).type = FORWARD_WORD;
	dispatch_table.key (rank ("L")).type = LOWERCASE_WORD;
	dispatch_table.key (rank ("T")).type = TWIDDLE_WORDS;
	dispatch_table.key (rank ("U")).type = UPPERCASE_WORD;
	dispatch_table.key (rank ("Y")).type = YANK_PREVIOUS_FROM_KILL_RING;

	dispatch_table.key (rank ("?")).type = DISPLAY_EDITOR_DOCUMENTATION;
	dispatch_table.key (rank ("")).type = BACKWARD_DELETE_WORD;
	dispatch_table.key (rank (attach_data.erase_char)).type = BACKWARD_DELETE_WORD;

	dispatch_table.name (*), dispatch_table.description (*), dispatch_table.info_dir (*),
	     dispatch_table.info_entry (*) = "";

	return;

shut:
     entry (Iocb_ptr);

	iocb_ptr = Iocb_ptr -> iocb.actual_iocb_ptr;
	attach_data_ptr = iocb_ptr -> iocb.attach_data_ptr;

	call free_dispatch_tables (attach_data.dispatch_table_ptr);

	if attach_data.saved_buffer_ptr ^= null () then
	     free attach_data.saved_buffer_ptr -> saved_buffer;

	return;

free_dispatch_tables:
     entry (a_table_ptr);

	do key_idx = 0 to 127;
	     if a_table_ptr -> dispatch_table.key (key_idx).type = -1 then
		call free_dispatch_tables (a_table_ptr -> dispatch_table.key (key_idx).next_table);
	end;

	free a_table_ptr -> dispatch_table;

	return;


/* So much for the easy stuff */

edit_line:
     entry (Iocb_ptr, Window_edit_line_info_ptr, Buffer_ptr, Buffer_len, N_returned, Code);

declare  Window_edit_line_info_ptr
			  pointer parameter;

	window_edit_line_info_ptr = Window_edit_line_info_ptr;

	if window_edit_line_info.version ^= window_edit_line_info_version_1 then do;
	     Code = error_table_$unimplemented_version;
	     return;
	end;

	if window_edit_line_info.line_length < 0 then do;
	     Code = error_table_$bad_subr_arg;
	     return;
	end;

	goto GET_LINE_COMMON;

get_line:
     entry (Iocb_ptr, Buffer_ptr, Buffer_len, N_returned, Code);

	window_edit_line_info_ptr = null ();

GET_LINE_COMMON:
	iocb_ptr = Iocb_ptr -> iocb.actual_iocb_ptr;
	attach_data_ptr = iocb_ptr -> iocb.attach_data_ptr;

	Code = 0;
	N_returned = 0;

/* Perform a reset_more. */
	attach_data.discard_output = "0"b;

/* Now make sure that the next async output won't more break once
   the user has entered the input line editor. */
	attach_data.lines_written_since_read = 0;

	if Buffer_len = 0 | Buffer_ptr = null () then
	     return;

/* Is there stuff left over from last time?  If so, just
   return the old stuff.  This call must have occurred after one
   which returned error_table_$long_record. */

	if attach_data.saved_buffer_ptr ^= null () then do;
	     N_returned = min (Buffer_len, length (saved_buffer.text));
	     substr (Buffer, 1, N_returned) = substr (saved_buffer.text, 1, N_returned);

/* Still couldn't take it all? */
	     if Buffer_len < length (saved_buffer.text) then do;
		saved_buffer.text = substr (saved_buffer.text, N_returned + 1);
		Code = error_table_$long_record;
	     end;
	     else do;
		free attach_data.saved_buffer_ptr -> saved_buffer;
		attach_data.saved_buffer_ptr = null ();
	     end;
	     return;
	end;

/* Get pointer to automatic storage copy of editor state. */
	lei_ptr = addr (automatic_line_editor_info);

	LEI.version = line_editor_info_version_3;
	LEI.iocb_ptr = iocb_ptr;
	LEI.repetition_count = 1;
	LEI.numarg_given = "0"b;
	LEI.return_from_editor = "0"b;
	LEI.suppress_redisplay = "0"b; /* redisplay unless the editor routine says otherwise */
	LEI.pad = "0"b;
	LEI.line_length = 0;
	LEI.cursor_index = 1;
	LEI.input_buffer = "";
	LEI.merge_next_kill = "0"b;
	LEI.old_merge_next_kill = "0"b;
	LEI.last_kill_direction = "0"b;
	LEI.user_data_ptr = null ();
	LEI.break_given = "0"b;
	LEI.new_break_character = "";
	LEI.pad2 = "";
	LEI.redisplay = redisplay_input_line;

/* Put the initial text in the buffer if we were called
   via edit_line */

	if window_edit_line_info_ptr ^= null () then do;
	     if window_edit_line_info.line_length ^= 0 then do;
		begin;
dcl      initial_text	  char (window_edit_line_info.line_length) based (window_edit_line_info.line_ptr);
		     call insert_in_buffer (lei_ptr, initial_text, Code);
		     if Code ^= 0 then
			return;
		     LEI.cursor_index = 1;		/* back to the start of the line */
		     window_edit_line_info_ptr = null ();
						/* don't do this again */
		end;				/* begin */
	     end;
	end;

/* Set up the global state variables. */
	get_line_entry_line = attach_data.line;
	get_line_entry_column = attach_data.col;

	ERROR_COUNT = 0;
	BREAKS_CHANGED = "0"b;
	SAVED_BREAKS = attach_data.breaks;
	REAL_CL_INTERMEDIARY = nulle;

	redisplay_buffer_ptr = null ();
	window_line_used_ptr = null ();

	on cleanup call get_line_cleanup ();

/* the cleanup handler is established, allocate storage */
	alloc WINDOW_LINE_USED set (window_line_used_ptr);
	alloc redisplay_buffer set (redisplay_buffer_ptr);

/* when something async happens in this window, go to this label */

	ASYNC_EVENT = RESTART_GET_LINE;

/* We change the cl_intermediary so that we can detect screen
   changes caused by pushing new levels. */

	call cu_$get_cl_intermediary (REAL_CL_INTERMEDIARY);
	call cu_$set_cl_intermediary (cl_pusher);

/* Check for window status or undefined cursor. */

	call window_$position_cursor_rel (iocb_ptr, 0, 0, code);
	if code = video_et_$window_status_pending then do;
	     if attach_data.status.reconnection | attach_data.status.ttp_change then call resize_window(); 
	     attach_data.status_pending = "0"b;
	     string (attach_data.status) = ""b;
	end;
	else if code = video_et_$cursor_position_undefined/* define it -- assume we did rawo mode */
	then do;
	     call window_$position_cursor (iocb_ptr, attach_data.row_at_rawo, attach_data.col_at_rawo, code);
	     call async_or_error (code);
	end;
	else if code ^= 0 then do;			/* who knows what happened? */
	     Code = code;
	     go to return_from_get_line;		/* So we free everything */
	end;

/* Read and buffer an input line.  The buffer always end with a linefeed,
   since we talk to the user till we get one */

get_input_line:
	call read_input_line (lei_ptr);

/* Now we have a whole input line.  Save it in the kill ring. */

	number_to_save = LEI.line_length;
	if substr (LEI.input_buffer, LEI.line_length, 1) = NL then
	     number_to_save = number_to_save - 1;

	if number_to_save > 0 then do;
	     LEI.old_merge_next_kill = "0"b;
	     if ^attach_data.suppress_echo then
		call add_to_kill_ring (lei_ptr, 1, number_to_save, FORWARD_KILL);
	end;

/* Return entire line or until caller's buffer fills. */

	N_returned = min (Buffer_len, LEI.line_length);

	substr (Buffer, 1, N_returned) = substr (LEI.input_buffer, 1, N_returned);
	LEI.line_length = LEI.line_length - N_returned;

	if LEI.line_length > 0 then do;		/* Caller can't take all the input available, so save the
						   rest until he calls in again. */

	     saved_buffer_length = LEI.line_length;
	     allocate saved_buffer set (attach_data.saved_buffer_ptr);

	     saved_buffer.text = substr (LEI.input_buffer, N_returned + 1, LEI.line_length);
	     Code = error_table_$long_record;
	end;

/* Start counting output lines from here. */
	attach_data.lines_written_since_read = 0;

	call window_$sync (iocb_ptr, code);		/* don't check code, we're on the way out anyway. */

return_from_get_line:
	call get_line_cleanup ();
	return;

get_line_cleanup:
	procedure;

declare  1 b		  aligned like break_table_info;

	if redisplay_buffer_ptr ^= null () then
	     free redisplay_buffer;
	
	if window_line_used_ptr ^= null () then
	     free WINDOW_LINE_USED;

	if REAL_CL_INTERMEDIARY ^= nulle then
	     call cu_$set_cl_intermediary (REAL_CL_INTERMEDIARY);

	if BREAKS_CHANGED then do;
	     b.version = break_table_info_version;
	     string(b.breaks) = SAVED_BREAKS;
	     call iox_$control (iocb_ptr, "set_break_table", addr (b), (0));
	     BREAKS_CHANGED = "0"b;
	end;

	if LEI.user_data_ptr ^= null then
	     call free_user_data (LEI.user_data_ptr);

	return;

end get_line_cleanup;


RESTART_GET_LINE:					/* Prepnl */
	if attach_data.col ^= 1 then
	     call get_to_next_line;

/* reset the origin to current position */

	get_line_entry_line = attach_data.line;
	get_line_entry_column = attach_data.col;

	goto get_input_line;


free_user_data:
     procedure (leud_ptr);

dcl      leud_ptr		  pointer parameter;	/* always non-null */

dcl      temp_ptr		  ptr;
dcl      freen_		  entry (ptr);		/* Since we only have a pointers to structure headers */
dcl      1 LEUDH		  aligned like line_editor_user_data_header based (leud_ptr);

	do while (leud_ptr ^= null ());
	     temp_ptr = LEUDH.next_user_data_ptr;
	     call freen_ (leud_ptr);
	     leud_ptr = temp_ptr;
	end;

	return;
     end free_user_data;

/* Routine to set the screen image to the current stuff on the screen. */
initialize_window_image:
     procedure;

dcl      line_idx		  fixed bin;
dcl      code		  fixed bin (35);

	call iox_$control (attach_data.target_iocb_ptr, "get_screen_image_ptr", screen_ptr, code);
	call async_or_error (code);

	do line_idx = 1 to attach_data.current.rows;
	     window_image (line_idx) =
		substr (screen.lines (line_idx + attach_data.current.line_origin - 1), attach_data.column_origin,
		attach_data.current.columns);		/* be sure to only get the stuff that is in our window */
	end;

	WINDOW_LINE_USED = "0"b;			/* Clear whole array. */
	return;
     end initialize_window_image;

/* Routine to read input, processing editor requests, until a newline is
   typed.  May be called with a partially filled buffer if an async event
   occurrs. */

read_input_line:
     procedure (lei_ptr);

dcl      lei_ptr		  pointer parameter;

dcl      break_char		  character (1) varying;
dcl      number_returned	  fixed bin (21);
dcl      number_to_read	  fixed bin (21);
dcl      (read_start_line, read_start_column)
			  fixed bin;
dcl      code		  fixed bin (35);

/* this dcl limits us to terminals with screens narrower than 1024 chars */
dcl      read_buffer	  char (1024);

dcl      1 LEI		  aligned like line_editor_info based (lei_ptr);


/* First include whatever async output may be on the screen. */
	call initialize_window_image ();

	if LEI.line_length > 0			/* if there is old stuff, redisplay */
	then call redisplay_input_line (lei_ptr);

	do while ("1"b);				/* process_break will exit us */

/* How much screen left on this line?  (and in the window!) */
	     number_to_read = attach_data.current.columns - attach_data.col + 1;
	     number_returned = 0;
	     break_char = "";

	     read_start_line = attach_data.line;
	     read_start_column = attach_data.col;

/* If buffer is full, do not echo negotiate. We will eventually
   execute a request that deletes some stuff from the buffer. */
	     if LEI.line_length >= length (LEI.input_buffer) then do;
		call window_$get_one_unechoed (iocb_ptr, break_char, "1"b, code);
		call async_or_error (code);
	     end;

	     else do;				/* If buffer is almost full, read fewer chars. */
		number_to_read = min (number_to_read, length (LEI.input_buffer) - LEI.line_length);

/* If we are in the middle of the line or up against
   the right edge of the window, or echoing is off,
   read single chars */

		if (LEI.cursor_index <= LEI.line_length) | (number_to_read <= 0) | attach_data.suppress_echo then
		     call window_$get_one_unechoed (iocb_ptr, break_char, "1"b, code);
		else do;				/* Put line editor breaks in effect. */
		     BREAKS_CHANGED = "1"b;
		     SAVED_BREAKS = attach_data.breaks;
		     attach_data.breaks = attach_data.line_editor_breaks;
		     call window_$get_echoed_chars (iocb_ptr, number_to_read, read_buffer, number_returned,
			break_char, code);

		     attach_data.breaks = SAVED_BREAKS;
		     BREAKS_CHANGED = "0"b;
		end;
	     end;

	     call async_or_error (code);

/* Process any echoed characters. */

	     if number_returned > 0 then do;

		LEI.merge_next_kill = "0"b;

/* Add negotiated characters to input buffer. */

		begin;
dcl      echoed_chars	  char (number_returned) defined (read_buffer) position (1);
		     call insert_in_buffer (lei_ptr, echoed_chars, code);

		     if code ^= 0 then
			call ring ();

		     call add_to_window_image (echoed_chars, read_start_line, read_start_column);
		end;
	     end;

/* Check length, since a char(1) varying containing a space
   compares equal to "" */

	     if length (break_char) > 0 then do;
NEXT_BREAK_CHARACTER:
		LEI.repetition_count = 1;
		LEI.numarg_given = "0"b;
		LEI.break_given = "0"b;
		LEI.redisplay = redisplay_input_line;	/* Ensure proper environment ptr is set in this entry var */
		call process_break (lei_ptr, break_char);
		if LEI.return_from_editor then do;
		     if ^LEI.suppress_redisplay then do;
			call redisplay_input_line (lei_ptr);
			call get_to_next_line;	/* should this always be done?  We really need	        */
						/*  window_editor_utils_$redisplay_input_line	        */
						/*   ... sigh --- JR 5/3/84			        */
		     end;
		     return;
		end;
	          if LEI.break_given & 
		   rank(LEI.new_break_character) >= lbound(line_editor_breaks_array,1) &
		   rank(LEI.new_break_character) <= hbound(line_editor_breaks_array,1) &
		   line_editor_breaks_array(rank(LEI.new_break_character)) then do;
		     break_char = LEI.new_break_character;
		     LEI.new_break_character = "";
		     LEI.break_given = "0"b;
		     go to NEXT_BREAK_CHARACTER;
		end;
	     end;

	     call redisplay_input_line (lei_ptr);

	end;					/* do while */

	return;
     end read_input_line;

/* The guts of the editor.  This routine interprets editor requests. */

process_break:
     procedure (lei_ptr, break_char);

dcl      lei_ptr		  pointer parameter;
dcl      break_char		  char (1) varying parameter;

dcl      break		  char (1);
dcl      temp_char_varying	  char (1) varying;
dcl      code		  fixed bin (35);

dcl      (i, repeat_count)	  fixed bin;
dcl      numarg_action	  fixed bin;
dcl      editor_routine	  entry (pointer /* lei_ptr */, fixed bin (35) /* code */) variable;

dcl      1 LEI		  aligned like line_editor_info based (lei_ptr);

	break = break_char;

	dispatch_table_ptr = attach_data.dispatch_table_ptr;

	LEI.key_sequence = break;

/* Hack META characters. For now we will define META characters
   to simply look up the dispatch table hanging off the ESC key.
   If there is none, you lose. */

	if (break > DEL) then do;			/* Make sure that there is a META table */
	     if dispatch_table.key (27).type < 0 then
		dispatch_table_ptr = dispatch_table.key (27).next_table;
	     else do;
		call window_$bell (iocb_ptr, code);
		call async_or_error (code);
		return;
	     end;

/* Turn off META bit. */
	     break = byte (rank (break) - 128);
	end;

/* chase through prefix sequences to terminal character */
	do while (dispatch_table.key (rank (break)).type < 0);
	     dispatch_table_ptr = dispatch_table.key (rank (break)).next_table;
	     call window_$get_one_unechoed (iocb_ptr, temp_char_varying, "1"b, code);
	     call async_or_error (code);
	     break = temp_char_varying;
	     LEI.key_sequence = rtrim (LEI.key_sequence) || break;
	end;

	if dispatch_table.key (rank (break)).type ^= 0 then
	     goto builtin_requests (dispatch_table.key (rank (break)).type);
	else do;
	     editor_routine = dispatch_table.key (rank (break)).routine;
	     numarg_action = dispatch_table.key (rank (break)).numarg_action;
	end;

do_editor_request:
	repeat_count = 1;

	if numarg_action = REPEAT & LEI.numarg_given & LEI.repetition_count < 0 then do;
	     code = error_table_$action_not_performed;
	     goto editor_request_finish;
	end;

	if numarg_action = REPEAT & LEI.numarg_given then
	     repeat_count = LEI.repetition_count;

	if numarg_action = REJECT & LEI.numarg_given then do;
	     code = error_table_$action_not_performed;
	     goto editor_request_finish;
	end;


	do i = 1 to repeat_count;

	     LEI.old_merge_next_kill = LEI.merge_next_kill;
	     LEI.merge_next_kill = "0"b;

	     call editor_routine (lei_ptr, code);
	     if code ^= 0 then
		goto editor_request_finish;

	     if dispatch_table.key (rank (break)).type = 0 then do;
						/* Try to ensure consistent state */
		if LEI.line_length < 0 then
		     LEI.line_length = 0;
		if LEI.line_length > length (LEI.input_buffer) then
		     LEI.line_length = length (LEI.input_buffer);
		if LEI.cursor_index < 1 then
		     LEI.cursor_index = 1;
		if LEI.cursor_index > LEI.line_length + 1 then
		     LEI.cursor_index = LEI.line_length + 1;
	     end;
	end;					/* do loop */

editor_request_finish:
	if code = error_table_$action_not_performed then
	     call ring ();

	return;

/* This label array defines the values of the type field of the dispatch
   table */

builtin_requests (1):
	editor_routine = forward_character;
	numarg_action = REPEAT;
	goto do_editor_request;

builtin_requests (2):
	editor_routine = backward_character;
	numarg_action = REPEAT;
	goto do_editor_request;

builtin_requests (3):
	editor_routine = forward_delete_character;
	numarg_action = REPEAT;
	goto do_editor_request;

builtin_requests (4):
	editor_routine = backward_delete_character;
	numarg_action = REPEAT;
	goto do_editor_request;

builtin_requests (5):
	editor_routine = move_to_end_of_line;
	numarg_action = IGNORE;
	goto do_editor_request;

builtin_requests (6):
	editor_routine = move_to_beginning_of_line;
	numarg_action = IGNORE;
	goto do_editor_request;

builtin_requests (7):
	editor_routine = kill_to_end_of_line;
	numarg_action = IGNORE;
	goto do_editor_request;

builtin_requests (8):
	editor_routine = kill_to_beginning_of_line;
	numarg_action = IGNORE;
	goto do_editor_request;

builtin_requests (9):
	editor_routine = forward_word;
	numarg_action = REPEAT;
	goto do_editor_request;

builtin_requests (10):
	editor_routine = backward_word;
	numarg_action = REPEAT;
	goto do_editor_request;

builtin_requests (11):
	editor_routine = forward_delete_word;
	numarg_action = REPEAT;
	goto do_editor_request;

builtin_requests (12):
	editor_routine = backward_delete_word;
	numarg_action = REPEAT;
	goto do_editor_request;

builtin_requests (13):
	editor_routine = quote_character;
	numarg_action = PASS;
	goto do_editor_request;

builtin_requests (14):
	editor_routine = clear_window;
	numarg_action = IGNORE;
	goto do_editor_request;

builtin_requests (15):
	editor_routine = twiddle_characters;
	numarg_action = IGNORE;
	goto do_editor_request;

builtin_requests (16):
	editor_routine = display_editor_documentation;
	numarg_action = IGNORE;
	goto do_editor_request;

builtin_requests (17):
	editor_routine = self_insert;
	numarg_action = REPEAT;
	goto do_editor_request;

builtin_requests (18):
	editor_routine = yank_from_kill_ring;
	numarg_action = IGNORE;
	goto do_editor_request;

builtin_requests (19):
	editor_routine = yank_previous_from_kill_ring;
	numarg_action = IGNORE;
	goto do_editor_request;

builtin_requests (20):
	editor_routine = terminate_input_line;
	numarg_action = IGNORE;
	goto do_editor_request;

builtin_requests (21):				/* Unimplemented requests, etc. */
	editor_routine = ring;
	numarg_action = IGNORE;
	goto do_editor_request;

builtin_requests (22):
	editor_routine = process_input_escape;
	numarg_action = IGNORE;
	goto do_editor_request;

builtin_requests (23):
	editor_routine = number_reader_0;
	numarg_action = PASS;
	goto do_editor_request;

builtin_requests (24):
	editor_routine = number_reader_1;
	numarg_action = PASS;
	goto do_editor_request;

builtin_requests (25):
	editor_routine = number_reader_2;
	numarg_action = PASS;
	goto do_editor_request;

builtin_requests (26):
	editor_routine = number_reader_3;
	numarg_action = PASS;
	goto do_editor_request;

builtin_requests (27):
	editor_routine = number_reader_4;
	numarg_action = PASS;
	goto do_editor_request;

builtin_requests (28):
	editor_routine = number_reader_5;
	numarg_action = PASS;
	goto do_editor_request;

builtin_requests (29):
	editor_routine = number_reader_6;
	numarg_action = PASS;
	goto do_editor_request;

builtin_requests (30):
	editor_routine = number_reader_7;
	numarg_action = PASS;
	goto do_editor_request;

builtin_requests (31):
	editor_routine = number_reader_8;
	numarg_action = PASS;
	goto do_editor_request;

builtin_requests (32):
	editor_routine = number_reader_9;
	numarg_action = PASS;
	goto do_editor_request;

builtin_requests (33):
	editor_routine = multiplier;
	numarg_action = PASS;
	goto do_editor_request;

builtin_requests (34):
	editor_routine = lowercase_word;
	numarg_action = PASS;
	goto do_editor_request;

builtin_requests (35):
	editor_routine = uppercase_word;
	numarg_action = PASS;
	goto do_editor_request;

builtin_requests (36):
	editor_routine = initial_capital;
	numarg_action = PASS;
	goto do_editor_request;

builtin_requests (37):
	editor_routine = twiddle_words;
	numarg_action = IGNORE;
	goto do_editor_request;

builtin_requests (38):
	editor_routine = negative_number_reader;
	numarg_action = PASS;
	goto do_editor_request;

     end process_break;

/* External entrypoints for user-defined editor routines. */

insert_text_:
     entry (a_lei_ptr, a_text, a_code);

	call setup_util_call;

	call insert_in_buffer (a_lei_ptr, a_text, a_code);
	return;

delete_text_:
     entry (a_lei_ptr, a_count, a_code);

	call setup_util_call;

	call delete_from_buffer (a_lei_ptr, a_count, a_code);
	return;

delete_text_save_:
     entry (a_lei_ptr, a_count, a_kill_direction, a_code);

	call setup_util_call;

	call delete_from_buffer_save (a_lei_ptr, a_count, a_kill_direction, a_code);
	return;

move_forward_:
     entry (a_lei_ptr, a_count, a_code);

	a_code = 0;
	call setup_util_call;

	if (a_lei_ptr -> line_editor_info.cursor_index + a_count) > a_lei_ptr -> line_editor_info.line_length + 1 then
	     a_code = error_table_$action_not_performed;
	else a_lei_ptr -> line_editor_info.cursor_index = a_lei_ptr -> line_editor_info.cursor_index + a_count;

	return;

move_backward_:
     entry (a_lei_ptr, a_count, a_code);

	a_code = 0;
	call setup_util_call;

	if (a_lei_ptr -> line_editor_info.cursor_index - a_count) < 1 then
	     a_code = error_table_$action_not_performed;
	else a_lei_ptr -> line_editor_info.cursor_index = a_lei_ptr -> line_editor_info.cursor_index - a_count;

	return;

move_forward_word_:
     entry (a_lei_ptr, a_code);

	call setup_util_call;

	call forward_word (a_lei_ptr, a_code);
	return;

move_backward_word_:
     entry (a_lei_ptr, a_code);

	call setup_util_call;

	call backward_word (a_lei_ptr, a_code);
	return;

get_top_kill_ring_element_:
     entry (a_lei_ptr, a_text, a_code);

	call setup_util_call;

	a_text = killer.words;
	return;

get_top_kill_ring_string_:
     entry (a_lei_ptr, a_text_var, a_code);

	call setup_util_call;

	if length(killer.words) > maxlength(a_text_var) then
	     a_code = error_table_$long_record;
	else a_code = 0;
	a_text_var = killer.words;
	return;

rotate_kill_ring_:
     entry (a_lei_ptr, a_code);

	call setup_util_call;

	call rotate_kill_ring ();

util_call_return:
	return;

/* Routine to setup data pointers for external routine utility entrypoints.
   Callers must have a_lei_ptr and a_code as parameters. */

setup_util_call:
     procedure;

dcl      error_table_$null_info_ptr
			  fixed bin (35) ext static;
dcl      error_table_$unimplemented_version
			  fixed bin (35) external static;

	if a_lei_ptr = null () then do;
	     a_code = error_table_$null_info_ptr;
	     goto util_call_return;
	end;

	if a_lei_ptr -> line_editor_info.version ^= line_editor_info_version_2 &
             a_lei_ptr -> line_editor_info.version ^= line_editor_info_version_3
          then do;
	     a_code = error_table_$unimplemented_version;
	     goto util_call_return;
	end;

	iocb_ptr = a_lei_ptr -> line_editor_info.iocb_ptr -> iocb.actual_iocb_ptr;

	attach_data_ptr = iocb_ptr -> iocb.attach_data_ptr;

	return;

     end setup_util_call;

/* Utilities that actually implement the editor routines */

self_insert:					/* this will work for more than one char! But is it the right thing??? */
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      1 LEI		  aligned like line_editor_info based (lei_ptr);
dcl      code		  fixed bin (35);

	code = 0;
	if LEI.key_sequence = ""			/* spaces? */
	then call insert_in_buffer (lei_ptr, " ", code);
	else call insert_in_buffer (lei_ptr, rtrim (LEI.key_sequence), code);

     end self_insert;

backward_delete_character:
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed bin (35);

dcl      1 LEI		  aligned like line_editor_info based (lei_ptr);

	code = 0;
	if LEI.cursor_index > 1 then do;
	     LEI.cursor_index = LEI.cursor_index - 1;
	     call delete_from_buffer (lei_ptr, 1, code);
	end;
	else code = error_table_$action_not_performed;

     end backward_delete_character;

kill_to_beginning_of_line:
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed bin (35);

dcl      1 LEI		  aligned like line_editor_info based (lei_ptr);

dcl      old_cursor		  fixed bin (21);

	code = 0;
	old_cursor = LEI.cursor_index;
	LEI.cursor_index = 1;
	call delete_from_buffer_save (lei_ptr, old_cursor - 1, BACKWARD_KILL, code);
	return;

     end kill_to_beginning_of_line;

backward_character:
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed bin (35) parameter;

dcl      1 LEI		  aligned like line_editor_info based (lei_ptr);

	code = 0;
	if LEI.cursor_index > 1 then
	     LEI.cursor_index = LEI.cursor_index - 1;

     end backward_character;

forward_character:
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed bin (35) parameter;

dcl      1 LEI		  aligned like line_editor_info based (lei_ptr);

	code = 0;
	if LEI.cursor_index < (LEI.line_length + 1) then
	     LEI.cursor_index = LEI.cursor_index + 1;

     end forward_character;

move_to_beginning_of_line:
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed bin (35) parameter;

dcl      1 LEI		  aligned like line_editor_info based (lei_ptr);

	code = 0;
	LEI.cursor_index = 1;

     end move_to_beginning_of_line;

move_to_end_of_line:
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed bin (35);

dcl      1 LEI		  aligned like line_editor_info based (lei_ptr);

	code = 0;
	LEI.cursor_index = LEI.line_length + 1;

     end move_to_end_of_line;

forward_delete_character:
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed bin (35);

	code = 0;
	call delete_from_buffer (lei_ptr, 1, code);

     end forward_delete_character;

kill_to_end_of_line:
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed bin (35);

dcl      1 LEI		  aligned like line_editor_info based (lei_ptr);

	code = 0;
	call delete_from_buffer_save (lei_ptr, LEI.line_length - LEI.cursor_index + 1, FORWARD_KILL, code);

     end kill_to_end_of_line;

twiddle_characters:
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed bin (35);

dcl      1 LEI		  aligned like line_editor_info based (lei_ptr);

dcl      temp_char		  char (1);

	code = 0;
	if LEI.cursor_index > 2 then do;
	     temp_char = substr (LEI.input_buffer, LEI.cursor_index - 2, 1);
	     substr (LEI.input_buffer, LEI.cursor_index - 2, 1) = substr (LEI.input_buffer, LEI.cursor_index - 1, 1);
	     substr (LEI.input_buffer, LEI.cursor_index - 1, 1) = temp_char;
	end;
	else code = error_table_$action_not_performed;

     end twiddle_characters;

terminate_input_line:
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed bin (35);

dcl      1 LEI		  aligned like line_editor_info based (lei_ptr);

	code = 0;
	LEI.return_from_editor = "1"b;
	LEI.suppress_redisplay = "1"b;		/* we will do redisplay ourselves, so the NL is hidden */
	LEI.merge_next_kill = "0"b;
	LEI.cursor_index = LEI.line_length + 1;
	call redisplay_input_line (lei_ptr);		/* to set cursor */
	call insert_in_buffer (lei_ptr, NL, code);
	call get_to_next_line ();

     end terminate_input_line;

clear_window:
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed bin (35);

	code = 0;
	call clear_window_image ();
	get_line_entry_line = 1;
	get_line_entry_column = 1;

     end clear_window;

quote_character:
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed bin (35);

dcl      1 LEI		  aligned like line_editor_info based (lei_ptr);

dcl      temp_char_varying	  char (1) varying;
dcl      temp_index		  fixed bin;
dcl      repeat_count	  fixed bin;

	code = 0;
	call window_$get_one_unechoed (iocb_ptr, temp_char_varying, "1"b, code);
	call async_or_error (code);
	if LEI.numarg_given then
	     repeat_count = LEI.repetition_count;
	else repeat_count = 1;

	do temp_index = 1 to repeat_count;
	     call insert_in_buffer (lei_ptr, (temp_char_varying), code);
	end;

     end quote_character;

yank_from_kill_ring:
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed bin (35);

dcl      1 LEI		  aligned like line_editor_info based (lei_ptr);

	code = 0;
	call insert_in_buffer (lei_ptr, (killer.words), code);
	LEI.merge_next_kill = "0"b;

     end yank_from_kill_ring;

process_input_escape:
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed bin (35);

dcl      1 LEI		  aligned like line_editor_info based (lei_ptr);

dcl      input_char		  char (1) varying;
dcl      unprocessed_char	  char (1) varying;
dcl      count		  fixed bin (21);
dcl      escape_index	  fixed bin (21);
dcl      translation_idx	  fixed bin (21);
dcl      result		  fixed bin;

	code = 0;

/* Remember where we started. */
	escape_index = LEI.cursor_index;

/* Echo the \ immediately. */
	call insert_in_buffer (lei_ptr, (attach_data.input_escape_char), code);
	if code ^= 0 then
	     return;

	call redisplay_input_line (lei_ptr);

	call window_$get_one_unechoed (iocb_ptr, input_char, "1"b, code);
	call async_or_error (code);

/* Check for \nnn case. */
	if (input_char >= "0") & (input_char <= "7") then do;
	     result = fixed (input_char);		/* calculate number */
	     call insert_in_buffer (lei_ptr, (input_char), code);
	     if code ^= 0 then
		return;
	     call redisplay_input_line (lei_ptr);

	     unprocessed_char = "";
	     do count = 2 to 3 while (length (unprocessed_char) = 0);
		call window_$get_one_unechoed (iocb_ptr, input_char, "1"b, code);
		call async_or_error (code);
		if (input_char >= "0") & (input_char <= "7") then do;
		     result = result * 8;
		     result = result + fixed (input_char);
		     call insert_in_buffer (lei_ptr, (input_char), code);
		     if code ^= 0 then
			return;

		     call redisplay_input_line (lei_ptr);
		end;				/* got unwanted char, save it for later */
		else unprocessed_char = input_char;
	     end;

/* Get rid of "\nnn" and insert the char. */
	     count = LEI.cursor_index - escape_index;
	     LEI.cursor_index = escape_index;
	     call delete_from_buffer (lei_ptr, count, code);
	     if code ^= 0 then
		return;
	     call insert_in_buffer (lei_ptr, byte (result), code);
	     if code ^= 0 then
		return;

/* See if recursive call is necessary.  */
	     if length (unprocessed_char) > 0 then
		call process_break (lei_ptr, unprocessed_char);
	     return;
	end;

	if input_char = BELL then do;
	     call window_$bell (iocb_ptr, code);
	     call async_or_error (code);		/* flush the \ */
	     LEI.cursor_index = escape_index;
	     call delete_from_buffer (lei_ptr, 1, code);
	     return;
	end;

	if (input_char = attach_data.erase_char) | (input_char = attach_data.kill_char)
	     | (input_char = attach_data.input_escape_char) then do;
						/* flush the \ */
	     LEI.cursor_index = escape_index;
	     call delete_from_buffer (lei_ptr, 1, code);
	     if code ^= 0 then
		return;				/* add the char */
	     call insert_in_buffer (lei_ptr, (input_char), code);
	     return;
	end;

/* If there are input escape sequences defined, use them. */

	if attach_data.special_ptr -> special_chars.input_escapes.len ^= 0 then do;
	     translation_idx = index (attach_data.special_ptr -> special_chars.input_escapes.str, input_char);
	     if translation_idx > 0 then do;		/* flush \ */
		LEI.cursor_index = escape_index;
		call delete_from_buffer (lei_ptr, 1, code);
		if code ^= 0 then
		     return;
		call insert_in_buffer (lei_ptr,
		     substr (attach_data.special_ptr -> special_chars.input_results.str, translation_idx, 1), code);
		return;
	     end;
	end;

/* Otherwise result is \<char> */
	call insert_in_buffer (lei_ptr, (input_char), code);

	return;

     end process_input_escape;

number_reader_0:
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed binary (35);

	call number_reader_common (lei_ptr, 0, code);
	return;

     end number_reader_0;

number_reader_1:
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed binary (35);

	call number_reader_common (lei_ptr, 1, code);
	return;

     end number_reader_1;

number_reader_2:
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed binary (35);

	call number_reader_common (lei_ptr, 2, code);
	return;

     end number_reader_2;

number_reader_3:
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed binary (35);

	call number_reader_common (lei_ptr, 3, code);
	return;

     end number_reader_3;

number_reader_4:
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed binary (35);

	call number_reader_common (lei_ptr, 4, code);
	return;

     end number_reader_4;

number_reader_5:
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed binary (35);

	call number_reader_common (lei_ptr, 5, code);
	return;

     end number_reader_5;

number_reader_6:
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed binary (35);

	call number_reader_common (lei_ptr, 6, code);
	return;

     end number_reader_6;

number_reader_7:
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed binary (35);

	call number_reader_common (lei_ptr, 7, code);
	return;

     end number_reader_7;

number_reader_8:
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed binary (35);

	call number_reader_common (lei_ptr, 8, code);
	return;

     end number_reader_8;

number_reader_9:
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed binary (35);

	call number_reader_common (lei_ptr, 9, code);
	return;

     end number_reader_9;

number_reader_common:
     procedure (lei_ptr, number, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed binary (35);
dcl      number		  fixed binary;

	code = 0;
	if LEI.numarg_given then
	     LEI.repetition_count = LEI.repetition_count * 10 + number;
	else LEI.repetition_count = number;

	call read_numbers_then_dispatch (lei_ptr, "0"b /* not multiplier */, "0"b /* accummulate digits */, code);

	return;

     end number_reader_common;

multiplier:
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed binary (35);

dcl      1 LEI		  aligned like line_editor_info based (lei_ptr);

	code = 0;
	if LEI.numarg_given then
	     LEI.repetition_count = LEI.repetition_count * 4;
	else LEI.repetition_count = 4;


	call read_numbers_then_dispatch (lei_ptr, "1"b /* multiplier */, "1"b /* don't accummulate digits */, code);
	return;

     end multiplier;

negative_number_reader:
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed binary (35);

dcl      1 LEI		  aligned like line_editor_info based (lei_ptr);

	code = 0;
	LEI.repetition_count = -1;
	call read_numbers_then_dispatch (lei_ptr, "0"b /* not multiplier */, "1"b /* don't accumulate digits */, code);
	return;

     end negative_number_reader;

read_numbers_then_dispatch:
     procedure (lei_ptr, multiplier_flag, replace_count_flag, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed binary (35);
dcl      multiplier_flag	  bit (1);
dcl      replace_count_flag	  bit (1);		/* replace LEI.repetition_count if we get a digit, instead of adding to it */

dcl      next_char		  char (1) varying;

dcl      1 LEI		  aligned like line_editor_info based (lei_ptr);

	LEI.numarg_given = "1"b;

get_more:
	call window_$get_one_unechoed (iocb_ptr, next_char, "1"b, code);
	call async_or_error (code);

	if multiplier_flag & next_char = "-" then	/* let the multiplier enter negative numeric args */
	     do;
	     LEI.repetition_count = -4;
	     replace_count_flag = "1"b;
	     multiplier_flag = "0"b;
	     goto get_more;
	end;

	if next_char >= "0" & next_char <= "9" then do;
	     if replace_count_flag then do;
		LEI.repetition_count = fixed (next_char) * sign (LEI.repetition_count);
		replace_count_flag = "0"b;
	     end;
	     else if LEI.repetition_count = 0 then
		LEI.repetition_count = fixed (next_char);
						/* handle leading zero */
	     else LEI.repetition_count = LEI.repetition_count * 10 + fixed (next_char) * sign (LEI.repetition_count);
	     goto get_more;
	end;
	else do;
	     call process_break (lei_ptr, (next_char));
	     return;
	end;

     end read_numbers_then_dispatch;

backward_word:
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed bin (35);

	code = 0;
	call move_backward_word (lei_ptr);

     end backward_word;

forward_word:
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed bin (35);

	code = 0;
	call move_forward_word (lei_ptr);

     end forward_word;

forward_delete_word:
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed bin (35);

dcl      1 LEI		  aligned like line_editor_info based (lei_ptr);

dcl      count		  fixed bin (21);
dcl      old_cursor		  fixed bin (21);

	code = 0;
	old_cursor = LEI.cursor_index;
	call move_forward_word (lei_ptr);
	count = LEI.cursor_index - old_cursor;
	LEI.cursor_index = old_cursor;
	call delete_from_buffer_save (lei_ptr, count, FORWARD_KILL, code);
	return;

     end forward_delete_word;

backward_delete_word:
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed bin (35);

dcl      1 LEI		  aligned like line_editor_info based (lei_ptr);

dcl      count		  fixed bin (21);
dcl      old_cursor		  fixed bin (21);

	code = 0;
	old_cursor = LEI.cursor_index;
	call move_backward_word (lei_ptr);
	count = old_cursor - LEI.cursor_index;
	call delete_from_buffer_save (lei_ptr, count, BACKWARD_KILL, code);

     end backward_delete_word;

yank_previous_from_kill_ring:
     procedure (lei_ptr, code);

dcl      lei_ptr		  pointer parameter;
dcl      code		  fixed bin (35);

dcl      1 LEI		  aligned like line_editor_info based (lei_ptr);

	code = 0;

/* Make sure that we don't subscript out of bounds */
	if (LEI.cursor_index > length (killer.words))	/* Are we sitting after contents of top kill ring element? */
	then if substr (LEI.input_buffer, LEI.cursor_index - length (killer.words), length (killer.words))
		= killer.words then do;
		LEI.cursor_index = LEI.cursor_index - length (killer.words);
		call delete_from_buffer (lei_ptr, length (killer.words), code);
		if code ^= 0 then
		     return;

		call rotate_kill_ring ();
		call insert_in_buffer (lei_ptr, (killer.words), code);
		return;
	     end;

	code = error_table_$action_not_performed;
	return;

     end yank_previous_from_kill_ring;

display_editor_documentation:
     procedure (lei_ptr, code);

dcl      lei_ptr		  parameter pointer;
dcl      code		  fixed bin;

dcl      ioa_		  entry options (variable);

	/*** This needs to be clevered up about key bindings */

	call ioa_ (
	     "^/^^A, ^^E, ^^F, ^^B, ^^D, DEL, ^a, ^^K, ^^Y, ^^L, ^^T, ESC-F, ESC-B,^/ESC-D, ESC-DEL, ESC-Y, ESC-C, ESC-L, ESC-U, ESC-T, ESC-?"
	     , attach_data.kill_char);

/* Now do the awful things necessary to incorporate the output
   from the ioa_ call into the screen image and  redisplay the
   input line in the correct location. */

	get_line_entry_line = attach_data.line;
	get_line_entry_column = attach_data.col;
	call initialize_window_image ();		/* include stuff in redisplay */
	return;

     end display_editor_documentation;

lowercase_word:
     procedure (lei_ptr, code);

dcl      lei_ptr		  parameter pointer;
dcl      code		  fixed binary (35);

dcl      (start, end)	  fixed binary;
dcl      (i, repeat_count)	  fixed binary;
dcl      uppercase_flag	  bit (1);

dcl      1 LEI		  like line_editor_info based (lei_ptr);

	uppercase_flag = "0"b;
	goto case_common;

uppercase_word:
     entry (lei_ptr, code);

	uppercase_flag = "1"b;

case_common:
	code = 0;
	repeat_count = 1;

	if LEI.numarg_given & LEI.repetition_count < 0 then do;
						/* no negative args for now */
	     call ring ();
	     return;
	end;

	if LEI.numarg_given then
	     repeat_count = LEI.repetition_count;

	do i = 1 to repeat_count;

	     call get_current_word_info (lei_ptr, start, end);

	     begin;
dcl      word		  char (end - start) defined (LEI.input_buffer) position (start);

		if uppercase_flag then
		     word = translate (word, uppercase, lowercase);
		else word = translate (word, lowercase, uppercase);

	     end;					/* begin */

	     call move_forward_word (lei_ptr);		/* get to end of current word */
	     call move_forward_word (lei_ptr);		/* get to end of next word for the repeat case */

	     if LEI.cursor_index = end		/* end of input buffer, the last forward_word did nothing */
	     then do;
		if LEI.numarg_given & i < repeat_count then
		     call ring ();			/* only ring if user gave a numaric arg which is too big */
		return;
	     end;

	end;					/* do loop */

	call move_backward_word (lei_ptr);		/* undo the extra forward_word */
	call move_backward_word (lei_ptr);		/* must do twice */
	call move_forward_word (lei_ptr);

	return;

/* end uppercase_word; */

     end lowercase_word;

initial_capital:
     procedure (lei_ptr, code);

dcl      lei_ptr		  parameter pointer;
dcl      code		  fixed binary (35);

dcl      (start, end)	  fixed binary;
dcl      (i, repeat_count)	  fixed binary;

dcl      1 LEI		  like line_editor_info based (lei_ptr);

	code = 0;
	repeat_count = 1;

	if LEI.numarg_given & LEI.repetition_count < 0 then do;
						/* no negative args for now */
	     call ring ();
	     return;
	end;

	if LEI.numarg_given then
	     repeat_count = LEI.repetition_count;

	LEI.numarg_given = "0"b;			/* fool lowercase_word */

	do i = 1 to repeat_count;

	     call lowercase_word (lei_ptr, code);
	     if code ^= 0 then
		return;

	     call get_current_word_info (lei_ptr, start, end);

	     begin;
dcl      first_letter	  char (1) defined (LEI.input_buffer) position (start);
		first_letter = translate (first_letter, uppercase, lowercase);
	     end;					/* begin */

	     call move_forward_word (lei_ptr);		/* get to end of current word */
	     call move_forward_word (lei_ptr);		/* get to end of next word for the repeat case */

	     if LEI.cursor_index = end		/* end of input buffer, the last forward_word did nothing */
	     then do;
		if repeat_count > 1 & i < repeat_count	/* we bashed LEI.numarg_given above */
		then call ring ();			/* only ring if user gave a numaric arg which is too big */
		return;
	     end;

	end;					/* do loop */

	call move_backward_word (lei_ptr);		/* undo the extra forward_word */
	call move_backward_word (lei_ptr);		/* must do twice */
	call move_forward_word (lei_ptr);

	return;

     end initial_capital;

twiddle_words:
     procedure (lei_ptr, code);

dcl      lei_ptr		  parameter pointer;
dcl      code		  fixed binary (35);

dcl      (start, end)	  fixed binary;
dcl      (start2, end2)	  fixed binary;

dcl      1 LEI		  like line_editor_info based (lei_ptr);

	code = 0;
	call get_current_word_info (lei_ptr, start, end);

	if start = 1 then do;			/* we are in the first word on the line, let's try to twiddle the first two
						   words (if there are two of them) */
	     call move_forward_word (lei_ptr);
	     call move_forward_word (lei_ptr);
	     call get_current_word_info (lei_ptr, start, end);
	end;

	begin;
dcl      word		  char (end - start);
	     word = substr (LEI.input_buffer, LEI.cursor_index, end - start);

	     call delete_from_buffer (lei_ptr, end - start, code);
	     if code ^= 0 then
		return;

	     call move_backward_word (lei_ptr);
	     if code ^= 0 then
		return;

	     start2 = LEI.cursor_index;

	     call move_forward_word (lei_ptr);
	     if code ^= 0 then
		return;

	     end2 = LEI.cursor_index;

	     begin;
dcl      word2		  char (end2 - start2);
		word2 = substr (LEI.input_buffer, start2, end2 - start2);

		LEI.cursor_index = start;
		call insert_in_buffer (lei_ptr, rtrim (word2), code);
		if code ^= 0 then
		     return;
	     end;

	     LEI.cursor_index = start2;
	     call delete_from_buffer (lei_ptr, end2 - start2, code);
	     if code ^= 0 then
		return;
	     call insert_in_buffer (lei_ptr, rtrim (word), code);
	     if code ^= 0 then
		return;

	     call move_forward_word (lei_ptr);

	end;

	return;

     end twiddle_words;

get_current_word_info:
     procedure (lei_ptr, start, end);

/* return the start and end postions and the "current" word.  Do
   something reasonable if we are in the middle of words */

/* leaves line_editor_info.cursor_index set to the start of the word */

dcl      (start, end)	  fixed binary;

dcl      lei_ptr		  parameter pointer;
dcl      1 LEI		  like line_editor_info based (lei_ptr);

	start = LEI.cursor_index;
	call move_forward_word (lei_ptr);
	end = LEI.cursor_index;

	call move_backward_word (lei_ptr);

	if LEI.cursor_index <= start then do;		/* start is in the middle of the word */
	     start = LEI.cursor_index;
	     call move_forward_word (lei_ptr);
	     end = LEI.cursor_index;
	     LEI.cursor_index = start;
	end;
	else do;					/* we were at the end of a word, the foward word has screwed us */
	     call move_backward_word (lei_ptr);
	     start = LEI.cursor_index;
	     call move_forward_word (lei_ptr);
	     end = LEI.cursor_index;
	     LEI.cursor_index = start;
	end;

     end get_current_word_info;

/* Routine to clear the internal window image.  Called from ^L, etc. */
clear_window_image:
     procedure ();

	window_image = "";
	WINDOW_LINE_USED = "0"b;

	return;

     end clear_window_image;

/* Utilities for manipulating words within the buffer. */

move_forward_word:
     procedure (lei_ptr);

dcl      lei_ptr		  pointer parameter;

dcl      token_start_index	  fixed bin;
dcl      token_end_index	  fixed bin;

dcl      1 LEI		  aligned like line_editor_info based (lei_ptr);

	begin;

dcl      buffer_chunk	  char (LEI.line_length - LEI.cursor_index + 1) defined (LEI.input_buffer)
			  position (LEI.cursor_index);

/* First skip to beginning of word. */

	     token_start_index = search (buffer_chunk, valid_token_characters);

	     if token_start_index = 0 then
		return;				/* No more words. */

/* Now skip over token itself. */
	     token_end_index = verify (substr (buffer_chunk, token_start_index), valid_token_characters);

	     if token_end_index = 0			/* word at end of line */
	     then LEI.cursor_index = LEI.line_length + 1;
	     else LEI.cursor_index = LEI.cursor_index + token_start_index + token_end_index - 2;

	     return;

	end;
     end move_forward_word;

move_backward_word:
     procedure (lei_ptr);

dcl      lei_ptr		  pointer parameter;

dcl      token_start_index	  fixed bin;
dcl      token_end_index	  fixed bin;

dcl      1 LEI		  aligned like line_editor_info based (lei_ptr);

	begin;

dcl      buffer_chunk	  char (LEI.cursor_index - 1) defined (LEI.input_buffer) position (1);

/* First skip to end of previous word. */

	     token_start_index = search (reverse (buffer_chunk), valid_token_characters);

	     if token_start_index = 0 then
		return;				/* No more words. */

/* Now skip over token itself. */
	     token_end_index = verify (substr (reverse (buffer_chunk), token_start_index), valid_token_characters);

	     if token_end_index = 0			/* word at beginning of line */
	     then LEI.cursor_index = 1;
	     else LEI.cursor_index = LEI.cursor_index - token_start_index - token_end_index + 2;

	     return;
	end;
     end move_backward_word;

/* Utility routines to manage the editor's input buffer. */

insert_in_buffer:
     procedure (lei_ptr, text, code);

dcl      lei_ptr		  pointer parameter;
dcl      text		  char (*) parameter;
dcl      code		  fixed bin (35) parameter;

dcl      1 LEI		  aligned like line_editor_info based (lei_ptr);

dcl      copy_count		  fixed bin;

	code = 0;

/* If there isn't enough room in the buffer for the entire string,
   don't insert any of it. */

	if length (text) > (length (LEI.input_buffer) - LEI.line_length) then
	     code = error_table_$action_not_performed;
	else do;					/* Open up space for the text and insert it. */
	     copy_count = LEI.line_length - LEI.cursor_index + 1;
						/* must use copy builtin to avoid MLR screw. */
	     substr (LEI.input_buffer, LEI.cursor_index + length (text), copy_count) =
		copy (substr (LEI.input_buffer, LEI.cursor_index, copy_count), 1);
	     substr (LEI.input_buffer, LEI.cursor_index, length (text)) = text;
	     LEI.line_length = LEI.line_length + length (text);
	     LEI.cursor_index = LEI.cursor_index + length (text);
	end;
	return;

     end insert_in_buffer;

delete_from_buffer:
     procedure (lei_ptr, delete_count, code);

dcl      lei_ptr		  pointer parameter;
dcl      delete_count	  fixed bin (21) parameter;
dcl      kill_direction	  bit (1) aligned parameter;
dcl      code		  fixed bin (35) parameter;

dcl      1 LEI		  aligned like line_editor_info based (lei_ptr);

dcl      save_on_kill_ring	  bit (1);
dcl      move_count		  fixed bin;

	save_on_kill_ring = "0"b;
	goto common_delete;

delete_from_buffer_save:
     entry (lei_ptr, delete_count, kill_direction, code);

	save_on_kill_ring = "1"b;

common_delete:
	code = 0;

/* If there aren't enough caracters in the buffer, do nothing. */

	if (delete_count + LEI.cursor_index - 1) > LEI.line_length then
	     code = error_table_$action_not_performed;
	else do;
	     if save_on_kill_ring then
		call add_to_kill_ring (lei_ptr, LEI.cursor_index, delete_count, kill_direction);

	     move_count = LEI.line_length - LEI.cursor_index - delete_count + 1;
	     substr (LEI.input_buffer, LEI.cursor_index, move_count) =
		substr (LEI.input_buffer, LEI.cursor_index + delete_count, move_count);
	     LEI.line_length = LEI.line_length - delete_count;
	end;
	return;

     end delete_from_buffer;

/* Routines for managing the window image and performing redsiplay.

   The basic idea is that most changes will be reflected through the
   regular redisplay process.  However, some editor requests deal with the
   screen image instead of the editor buffer, so we need routines to modify
   the image directly. */

/* Routine to add to the window image text that has already been echoed to
   the screen by a call to window_$get_echoed_chars. */

add_to_window_image:
     procedure (text, line, column);

dcl      text		  char (*) parameter;
dcl      line		  fixed bin parameter;
dcl      column		  fixed bin parameter;


	substr (window_image (line), column, length (text)) = text;
	WINDOW_LINE_USED (line) = "1"b;
	return;
     end add_to_window_image;

/* Main redisplay routine.  Performs output conversions on all characters in
   the input buffer, and then splits up the converted string into lines
   as wide as the screen and writes them into the window image.  We rely on
   window_display_ to perform redisplay optimizations. */

redisplay_input_line:
     procedure (lei_ptr);

dcl      lei_ptr		  ptr parameter;

dcl      converted_cursor	  fixed bin (21);
dcl      converted_length	  fixed bin (21);
dcl      last_character_line	  fixed bin;
dcl      last_character_column  fixed bin;
dcl      cursor_line	  fixed bin;
dcl      cursor_column	  fixed bin;
dcl      line		  fixed bin;
dcl      window_width	  fixed bin;
dcl      processed		  fixed bin (21);
dcl      line_offset	  fixed bin;

dcl      1 LEI aligned like line_editor_info based(lei_ptr);
dcl      input_buffer	  char (LEI.line_length) defined (LEI.input_buffer) position (1);

dcl      window_display_	  entry (ptr, (*) char (*), fixed bin (35));

	if attach_data.suppress_echo then do;
	     redisplay_buffer = "";
	     converted_length = length (input_buffer);
	     converted_cursor = LEI.cursor_index;
	end;

	else call perform_output_conversions (input_buffer, 1, redisplay_buffer, converted_length, LEI.cursor_index,
		converted_cursor);

	window_width = attach_data.current.columns;
	processed = 0;

/* First clear old input redisplay. */
	substr (window_image (get_line_entry_line), get_line_entry_column) = "";
	WINDOW_LINE_USED (get_line_entry_line) = "0"b;

	do line = (get_line_entry_line + 1) to attach_data.current.rows, 1 to (get_line_entry_line - 1);
	     if WINDOW_LINE_USED (line) then do;
		window_image (line) = "";
		WINDOW_LINE_USED (line) = "0"b;
	     end;
	end;

/* Then fill in first line. */

	line = get_line_entry_line;			/* Take one window line or as much as there is. */
	processed = min (converted_length, window_width - get_line_entry_column + 1);
	substr (window_image (line), get_line_entry_column) = substr (redisplay_buffer, 1, processed);
	WINDOW_LINE_USED (line) = "1"b;
	last_character_line = line;
	last_character_column = get_line_entry_column + processed - 1;

/* Now loop through filling in entire screen lines. */

	window_width = window_width - length (CONTINUATION_CHARS);

	do while ((converted_length - processed) > window_width);
	     line = line + 1;
	     if line > attach_data.current.rows then
		if attach_data.more_mode = MORE_MODE_SCROLL then do;
		     call scroll_window_image;
		     line = attach_data.current.rows;
		end;
		else line = 1;

	     window_image (line) = CONTINUATION_CHARS || substr (redisplay_buffer, processed + 1, window_width);
	     WINDOW_LINE_USED (line) = "1"b;
	     processed = processed + window_width;
	     last_character_line = line;
	     last_character_column = attach_data.current.columns;
	end;

/* Now finish up with last line. */

	if (converted_length > processed) then do;
	     line = line + 1;
	     if line > attach_data.current.rows then
		if attach_data.more_mode = MORE_MODE_SCROLL then do;
		     call scroll_window_image;
		     line = attach_data.current.rows;
		end;
		else line = 1;

	     window_image (line) =
		CONTINUATION_CHARS || substr (redisplay_buffer, processed + 1, converted_length - processed);
	     WINDOW_LINE_USED (line) = "1"b;
	     last_character_line = line;
	     last_character_column = (converted_length - processed) + length (CONTINUATION_CHARS);
	end;

	call window_display_ (iocb_ptr, window_image, code);
	call async_or_error (code);

	if (LEI.cursor_index > LEI.line_length) then do;	/* We know right where to put cursor. */
	     cursor_line = last_character_line;
	     cursor_column = last_character_column + 1;
	end;
	else do;					/* We need to calculate an arbitrary cursor position. */
						/* fudge here to get phantom col to work right. */
	     line_offset =
		divide (converted_cursor + (get_line_entry_column - 1) - length (CONTINUATION_CHARS) - 1,
		window_width, 17, 0);
	     line_offset = max (0, line_offset);

	     cursor_line = get_line_entry_line + line_offset;

/* Now see if we went over bottom window boundary. */
	     if cursor_line > attach_data.current.rows then
		cursor_line = cursor_line - attach_data.current.rows;

/* Compute the cursor column, allowing for continuation chars. */
	     cursor_column =
		mod (converted_cursor + (get_line_entry_column - 1) + (line_offset * length (CONTINUATION_CHARS)),
		attach_data.current.columns);

	     if cursor_column = 0 then
		cursor_column = attach_data.current.columns;
	end;

	call window_$position_cursor (iocb_ptr, cursor_line, cursor_column, code);
	call async_or_error (code);
	return;

scroll_window_image:
	procedure;

dcl      line		  fixed bin;

	     do line = 1 to (attach_data.current.rows - 1);
		window_image (line) = window_image (line + 1);
		WINDOW_LINE_USED (line) = WINDOW_LINE_USED (line + 1);
	     end;

	     call window_$scroll_region (iocb_ptr, 1, attach_data.current.rows, -1, code);
	     call async_or_error (code);

/* Update our entry line for redisplay.  If the first line of input
   display scrolls off the top, who knows what to do? */
	     if (get_line_entry_line > 1) then
		get_line_entry_line = get_line_entry_line - 1;
	     else get_line_entry_column = 1;		/* have lost 1st line */

	     return;
	end scroll_window_image;

     end redisplay_input_line;

/* Utility to perform actual output conversions.

   Called by input side to convert the entire input buffer.  Any character in
   it must be ordinary or have been explicitly quoted to get there.  Returns
   the index in the output string of the char that the cursor points at in the
   input string.  */

perform_output_conversions:
     procedure (input_string, start_index, output_string, chars_returned, cursor_index, converted_cursor_index);


dcl      input_string	  char (*) parameter;
dcl      start_index	  fixed bin (21) parameter;
dcl      output_string	  char (*) parameter;
dcl      chars_returned	  fixed bin (21) parameter;
dcl      cursor_index	  fixed bin (21) parameter;
dcl      converted_cursor_index fixed bin (21) parameter;

dcl      char_index		  fixed bin (21);
dcl      char_type		  fixed bin;
dcl      start		  fixed bin (21);
dcl      chars_seen		  fixed bin (21);
dcl      converted_length	  fixed bin;

	converted_cursor_index = 0;
	output_string = "";
	chars_returned = 0;

	start = start_index;

	do while (start <= length (input_string));

/* define a substring of input_string containing the chars
   that haven't been processed yet. */
	     begin;
dcl      new_input		  char (length (input_string) - start + 1) defined (input_string) position (start);

		call scan_for_interesting_char (new_input, 1, char_index, char_type);

/* Find the index in the output string of the cursor
   specified in the input string. */

		if char_index = 0 then
		     chars_seen = length (input_string) + 1;
		else chars_seen = start + char_index - 1;

/* Find out if cursor_index is in chunk we just processed */
		if (converted_cursor_index = 0) & (cursor_index >= start) & (cursor_index <= chars_seen) then
		     converted_cursor_index = chars_returned + cursor_index - start + 1;

		if char_index = 0			/* no more odd chars */
		then do;
		     substr (output_string, chars_returned + 1) = new_input;
		     chars_returned = chars_returned + length (new_input);
		     start = length (input_string) + 1;
		end;

		else do;
		     substr (output_string, chars_returned + 1) = substr (new_input, 1, char_index - 1);
		     chars_returned = chars_returned + char_index - 1;

/* Make sure no wierd chars get through. */
		     if (char_type = OUTPUT_CONVERT_RRS) | (char_type = OUTPUT_CONVERT_BRS) then
			char_type = OUTPUT_CONVERT_OCTAL;

/* Output convert the interesting char. */
		     substr (output_string, chars_returned + 1) =
			convert_char (substr (new_input, char_index, 1), char_type, chars_returned + 1,
			converted_length);
		     chars_returned = chars_returned + converted_length;
		     start = start + char_index;
		end;

	     end;					/* begin block */
	end;					/* do while */

/* The cursor_index should never be zero, even for a zero length
   input buffer. */
	if (converted_cursor_index = 0) then
	     converted_cursor_index = chars_returned + 1;

	return;

     end perform_output_conversions;

scan_for_interesting_char:
     procedure (text, start_index, char_index, char_type);

dcl      text		  char (*) parameter;
dcl      start_index	  fixed bin (21) parameter;
dcl      char_index		  fixed bin (21) parameter;
dcl      char_type		  fixed bin parameter;

dcl      temp_char		  char (1);

dcl      find_char_$translate_first_in_table
			  entry (char(*), char(512) aligned, fixed bin(21)) returns (char(1));

dcl      defined_text	  char (length (text) - start_index + 1) defined (text) position (start_index);

	temp_char = find_char_$translate_first_in_table (defined_text, attach_data.conversion_tct_table, char_index);

	char_type = rank (temp_char);

	return;

output_convert_one_character:
     entry (char) returns (fixed bin);

dcl      char		  char (1) parameter;

	temp_char = substr (attach_data.conversion_tct_table, rank (char) + 1, 1);
	return (rank (temp_char));

     end scan_for_interesting_char;

convert_char:
     procedure (char, char_type, current_hpos, converted_length) returns (char (32) varying);

dcl      char		  char (1) parameter;
dcl      char_type		  fixed bin parameter;
dcl      current_hpos	  fixed bin parameter;
dcl      converted_length	  fixed bin parameter;


	converted_length = 0;

	if char_type = OUTPUT_CONVERT_HT then do;
	     converted_length = 10 - mod (current_hpos - 1, 10);
	     return (substr (TEN_SPACES, 1, converted_length));
	end;

	if (char_type = OUTPUT_CONVERT_OCTAL) | (char_type = OUTPUT_CONVERT_CR) | (char_type = OUTPUT_CONVERT_BS)
	then do;

/* quickest, dirtiest octal converter we could think of */

convert_octal_rep:
	     begin;

dcl      octal_rep		  char (4);

dcl      1 decomp		  unaligned,
	 2 digit_1	  fixed bin (3) unsigned,
	 2 digit_2	  fixed bin (3) unsigned,
	 2 digit_3	  fixed bin (3) unsigned;

dcl      digit_table	  (0:7) char (1) static options (constant) init ("0", "1", "2", "3", "4", "5", "6", "7");

		if attach_data.flags.edited then return(""); /* punt if we are in edited mode */

		unspec (decomp) = unspec (char);

		substr (octal_rep, 1, 1) = attach_data.input_escape_char;

		substr (octal_rep, 2, 1) = digit_table (decomp.digit_1);
		substr (octal_rep, 3, 1) = digit_table (decomp.digit_2);
		substr (octal_rep, 4, 1) = digit_table (decomp.digit_3);

		converted_length = 4;
		return (octal_rep);
	     end;					/* begin */
	end;					/* do */

	if char_type = OUTPUT_CONVERT_ORDINARY then do;
	     converted_length = 1;
	     return (char);
	end;

	if (char_type = OUTPUT_CONVERT_RRS) then
	     return (
		convert_special_sequence (attach_data.special_ptr -> special_chars.red_ribbon_shift, converted_length)
		);

	if (char_type = OUTPUT_CONVERT_BRS) then
	     return (
		convert_special_sequence (attach_data.special_ptr -> special_chars.black_ribbon_shift,
		converted_length));

	if (char_type >= OUTPUT_CONVERT_FIRST_SPECIAL)	/* assume that the special translations always consist
						   of regular printing characters. */
	     then if ^attach_data.flags.edited
		then return (
		convert_special_sequence (attach_data.special_ptr
		-> special_chars.not_edited_escapes (char_type - OUTPUT_CONVERT_FIRST_SPECIAL + 1), converted_length));
		else return (
		convert_special_sequence (attach_data.special_ptr
		-> special_chars.edited_escapes (char_type - OUTPUT_CONVERT_FIRST_SPECIAL + 1), converted_length));

/* Otherwise, assume octal coversion. */

	goto convert_octal_rep;

convert_special_sequence:
	procedure (c_chars_struc, special_length) returns (char (15) varying);

dcl      1 c_chars_struc	  aligned like c_chars parameter;
dcl      special_length	  fixed bin;

dcl      special_string	  char (c_chars_struc.count) defined (c_chars_struc.chars) position (1);

	     special_length = length (special_string);
	     return (special_string);

	end convert_special_sequence;

     end convert_char;

get_to_next_line:
     procedure;

/* Used on put_chars side to get to next line. */

	attach_data.lines_written_since_read = attach_data.lines_written_since_read + 1;

	if attach_data.line < attach_data.current.rows then do;
	     call window_$position_cursor (iocb_ptr, attach_data.line + 1, 1, code);
						/* simple case */
	     call async_or_error (code);
	     call clear_to_end_of_line;		/* comes out neater this way */
	end;

	else do;

	     goto more_type (attach_data.more_mode);

more_type (1):					/* MORE_MODE_SCROLL */
	     call window_$scroll_region (iocb_ptr, 1, attach_data.current.rows, -1, code);
	     if code = video_et_$capability_lacking  /* this shouldn't happen, but just in case */
		then goto more_type (MORE_MODE_WRAP);
	     call async_or_error (code);
	     call window_$position_cursor (iocb_ptr, attach_data.line, 1, code);
	     call async_or_error (code);
	     go to moved;

more_type (2):					/* MORE_MODE_CLEAR */
	     call window_$clear_window (iocb_ptr, code);
	     call async_or_error (code);
	     go to moved;

more_type (3):					/* MORE_MODE_WRAP */
more_type (4):					/* MORE_MODE_FOLD */
	     call window_$position_cursor (iocb_ptr, 1, 1, code);
	     call async_or_error (code);
	     call clear_to_end_of_line;

moved:
	end;
     end get_to_next_line;

/* Routine to actually do output conversion on text and send it on to
   window_. */

put_out_chars:
     procedure (text);

dcl      text		  char (*) parameter;

dcl      text_ptr		  pointer;
dcl      line_left		  fixed bin;
dcl      ordinary_count	  fixed bin (21);
dcl      temp_count		  fixed bin (21);
dcl      interesting_char_index fixed bin (21);
dcl      interesting_char_type  fixed bin;
dcl      interesting_char	  char (1);
dcl      char_rep		  char (32) varying;
dcl      char_temp		  char (32);
dcl      char_rep_length	  fixed bin;
dcl      (saved_line, saved_column)
			  fixed bin;


	text_ptr = addr (text);
	PROCESSED_SO_FAR = 0;			/* kept globally for async restart */
	line_left = attach_data.current.columns - attach_data.col + 1;

	do while (PROCESSED_SO_FAR < length (text));

/* search for the first non-vanilla character */
	     call scan_for_interesting_char (text, PROCESSED_SO_FAR + 1, interesting_char_index, interesting_char_type);

	     if interesting_char_index = 0 then
		ordinary_count = length (text) - PROCESSED_SO_FAR;
	     else do;
		ordinary_count = (interesting_char_index - 1);
		interesting_char_index = interesting_char_index + PROCESSED_SO_FAR;
	     end;

/* Process ordinary characters. */

/* If this is the end of a line, rtrim the text. */
	     if (interesting_char_type = OUTPUT_CONVERT_NEWLINE) then do;
		temp_count = length (rtrim (substr (text, PROCESSED_SO_FAR + 1, ordinary_count)));

		call write_with_continuation (text_ptr, temp_count, line_left);
	     end;

	     else call write_with_continuation (text_ptr, ordinary_count, line_left);

	     PROCESSED_SO_FAR = PROCESSED_SO_FAR + ordinary_count;
	     text_ptr = addcharno (text_ptr, ordinary_count);

/* now handle the special character, if any */
	     if interesting_char_index ^= 0 then do;
		PROCESSED_SO_FAR = PROCESSED_SO_FAR + 1;
		text_ptr = addcharno (text_ptr, 1);

		interesting_char = substr (text, interesting_char_index, 1);
		char_rep =
		     convert_char (interesting_char, interesting_char_type,
		     attach_data.current.columns - line_left + 1, char_rep_length);

		if (interesting_char_type = OUTPUT_CONVERT_NEWLINE) then do;
		     call get_to_next_line;
		     line_left = attach_data.current.columns;
		end;

/* Eliminate CR from the output stream for now. */
		else if (interesting_char_type = OUTPUT_CONVERT_CR) then
		     ;

/* Special case BELL to beep. */
		else if (interesting_char = BELL) then
		     call ring ();

/* Handle FF in vertsp mode. */
		else if ((interesting_char_type = OUTPUT_CONVERT_FF) | (interesting_char_type = OUTPUT_CONVERT_VT))
			& attach_data.vertsp then do; /* What does vertsp mean in video?  For now,
						   cause a more break. */
		     if (attach_data.more_mode = MORE_MODE_SCROLL) | (attach_data.more_mode = MORE_MODE_FOLD) then do;
			call get_to_next_line ();
			attach_data.lines_written_since_read = attach_data.current.rows + 1;
		     end;
		     else do;			/* WRAP or CLEAR */
			call window_$clear_to_end_of_window (iocb_ptr, code);
			call async_or_error (code);
			call window_$position_cursor (iocb_ptr, attach_data.current.rows, 1, code);
			call async_or_error (code);
		     end;
		end;

/* Handle red/black shifts. */
		else if (interesting_char_type = OUTPUT_CONVERT_RRS) | (interesting_char_type = OUTPUT_CONVERT_BRS)
		then if attach_data.red then do;
			saved_line = attach_data.line;
			saved_column = attach_data.col;
			call raw_write ((char_rep));
			call window_$position_cursor (iocb_ptr, saved_line, saved_column, code);
			call async_or_error (code);
		     end;
		     else ;

/* Assume that anything else has been handled by
   convert_char and can be printed. */
		else do;
		     char_temp = char_rep;
		     call write_with_continuation (addr (char_temp), length (char_rep), line_left);
		end;

	     end;					/* if interesting chars */
	end;					/* main do loop */


write_with_continuation:
	procedure (text_ptr, text_length, line_left);

dcl      text_ptr		  pointer parameter;
dcl      text_length	  fixed bin (21) parameter;
dcl      line_left		  fixed bin parameter;

dcl      chars_left_to_write	  fixed bin;
dcl      start_idx		  fixed bin (21);
dcl      start_ptr		  pointer;

	     start_idx = 1;
	     start_ptr = text_ptr;

/* Write out chunks as long as the screen is wide. */
	     do while ((text_length - start_idx + 1) > line_left);
		call write_string (start_ptr, line_left);
		call get_to_next_line;
		call write_string (addr (CONTINUATION_CHARS), length (CONTINUATION_CHARS));
		start_idx = start_idx + line_left;
		start_ptr = addcharno (start_ptr, line_left);
		line_left = attach_data.current.columns - length (CONTINUATION_CHARS);
	     end;

/* Now write out the remaining short line. */
	     chars_left_to_write = text_length - start_idx + 1;
	     call write_string (start_ptr, chars_left_to_write);
	     line_left = line_left - chars_left_to_write;
	     return;

	end write_with_continuation;

write_string:
	procedure (text_ptr, text_length);

dcl      text_ptr		  pointer parameter;
dcl      text_length	  fixed bin parameter;

dcl      text		  char (text_length) based (text_ptr);

	     call check_more ();
	     call window_$overwrite_text (iocb_ptr, text, code);
	     call async_or_error (code);

	     return;
	end write_string;

     end put_out_chars;

/* ***** Kill Ring Management *****

   Contiguous killed text is saved in a single buffer.  We try to
   look like Emacs.  Killed buffers are linked in a ring.  The top
   item on the ring is given by attach_data.top_killer.  The ring
   rotates towards killer.next.  A new item is added before the top,
   and the old top is the new second.  Killers are either in the
   ring or on the free list (attach_data.army).  If the last request
   was also a kill, we add the new killed stuff to the existing kill
   ring element.
*/

add_to_kill_ring:
     procedure (lei_ptr, start_idx, char_count, kill_direction);

dcl      lei_ptr		  pointer parameter;
dcl      start_idx		  fixed bin (21) parameter;
dcl      char_count		  fixed bin (21) parameter;
dcl      kill_direction	  bit (1) aligned parameter;

dcl      killer_count	  fixed bin;
dcl      current_killer	  pointer;

dcl      KILL_RING_SIZE	  fixed bin static options (constant) init (10);

dcl      text_to_add	  char (char_count) defined (LEI.input_buffer) position (start_idx);

dcl      1 LEI		  like line_editor_info based (lei_ptr);

	current_killer = attach_data.top_killer;

/* If what we are adding is already in the ring, and we are
   not merging this kill, punt. */

	if ^LEI.old_merge_next_kill & (text_to_add = killer.words) then
	     return;

/* The size of the kill ring is managed here. The length should
   be kept somewhere so we don't have to count each time. */

	current_killer = current_killer -> killer.next;

	do killer_count = 1 by 1 while (current_killer ^= attach_data.top_killer);
	     current_killer = current_killer -> killer.next;
	end;

	if killer_count > KILL_RING_SIZE then do;
	     current_killer = current_killer -> killer.prev;
	     call free_killer (current_killer);
	end;

/* now go on with the actual killing */

/* If we aren't merging this kill with another and the top kill
   ring element is not empty, allocate a new one. */
	if ^LEI.old_merge_next_kill & (killer.words ^= "") then
	     call insert_new_kill_ring_element ();

	LEI.merge_next_kill = "1"b;
	LEI.last_kill_direction = kill_direction;

	do while (length (text_to_add) + length (killer.words) > maxlength (killer.words));
	     call expand_kill_ring_element ();
	end;

	if kill_direction = FORWARD_KILL then
	     killer.words = killer.words || text_to_add;
	else killer.words = text_to_add || killer.words;

	return;

     end add_to_kill_ring;

rotate_kill_ring:
     procedure ();

	attach_data.top_killer = killer.next;
	return;

     end rotate_kill_ring;

/*  The following are utilities used by above kill ring routines. */

insert_new_kill_ring_element:
     procedure ();

dcl      k		  ptr;

	k = attach_data.top_killer;			/* old top */

	attach_data.top_killer = get_free_killer ();	/* from free list */
	if attach_data.top_killer = null ()		/* were none */
	then attach_data.top_killer = alloc_killer ();

	killer.next = k;				/* old top */
	killer.prev = k -> killer.prev;
	k -> killer.prev = attach_data.top_killer;
	killer.prev -> killer.next = attach_data.top_killer;

	killer.words = "";
	return;
     end insert_new_kill_ring_element;

get_free_killer:
     procedure returns (ptr);

declare  t		  ptr;

/* the free list (army) is only forward threaded through
   killer.next */

	t = attach_data.army;			/* first on free list */
	if t ^= null () then
	     attach_data.army = t -> killer.next;

	return (t);
     end get_free_killer;

alloc_killer:
     procedure returns (pointer);

dcl      new		  pointer;

	killer_alloc_size = killer_initial_alloc_size;
	allocate killer in (attach_data_area) set (new);
	new -> killer.next, new -> killer.prev = null ();
	new -> killer.words = "";
	return (new);
     end alloc_killer;

free_killer:
     procedure (killer_ptr);

declare  killer_ptr		  pointer;

/* adds a killer to the free list, unchaining it from the ring */

	killer_ptr -> killer.prev -> killer.next = killer_ptr -> killer.next;
	killer_ptr -> killer.next -> killer.prev = killer_ptr -> killer.prev;

	killer_ptr -> killer.next = attach_data.army;
	attach_data.army = killer_ptr;

	return;
     end free_killer;

expand_kill_ring_element:
     procedure;

declare  k		  ptr;

	killer_alloc_size = killer.max_size * 2;
	allocate killer in (attach_data_area) set (k);
	k -> killer.words = killer.words;

	if killer.next = addr (killer)		/* self-ref */
	then k -> killer.next = k;
	else do;
	     k -> killer.next = killer.next;
	     killer.next -> killer.prev = k;
	end;

	if killer.prev = addr (killer) then
	     k -> killer.prev = k;
	else do;
	     k -> killer.prev = killer.prev;
	     killer.prev -> killer.next = k;
	end;

	free attach_data.top_killer -> killer in (attach_data_area);
	attach_data.top_killer = k;

     end expand_kill_ring_element;

async_or_error:
Error_Detector:
     procedure (code);
declare  code		  fixed bin (35);

	if code = 0 then
	     return;

	if code = video_et_$window_status_pending then do;

/* can only be async event or screen invalid. If screen invalid,
   we clear the window and signal to restart what we were doing.
   if just an async event, we need only signal */
	     
/* now it can also be reconnection or ttp_change */

	     if attach_data.status.reconnection | attach_data.status.ttp_change
		then call resize_window();  /* this is the *right* way to deal with reconnection */

	     attach_data.status_pending = "0"b;
	     if attach_data.status.screen_invalid then
		call window_$clear_window (iocb_ptr, (0));
						/* who knows whats there ? */
	     string (attach_data.status) = ""b;

	     go to ASYNC_EVENT;
	end;

/* If we get window_out_of_bounds, assume that it is due to
   reconnecting to a video process on a terminal with a smaller
   screen. */

/* This is no longer true, and should not be called, but it is safer to 
   leave the  check in, and shouldn't do any harm */

	else if code = video_et_$out_of_window_bounds then
	     do;
		call resize_window();
		goto ASYNC_EVENT;
	     end;

	else if code ^= 0 then
	     begin;
declare  sub_err_action	  bit(36) aligned;

declare  sub_err_		  entry () options (variable);

/* We only tolerate one blow-out per call, avoids looping
   printing these error messages */

	     if attach_data.debug | ERROR_COUNT > 0 then
		sub_err_action = ACTION_CANT_RESTART;
	     else sub_err_action = ACTION_DEFAULT_RESTART;

	     ERROR_COUNT = ERROR_COUNT + 1;

	     call window_$clear_window (iocb_ptr, (0));
	     call sub_err_ (code, "window_io_iox_", sub_err_action, null (), (0), "");
	     go to ASYNC_EVENT;

	end;

     end async_or_error;


RETURN:
	return;
resize_window: proc();

dcl      1 auto_window_position_info
			  aligned like window_position_info;
dcl      1 auto_capabilities_info
			  aligned like capabilities_info;

/* Try to resize the window to fit on the screen.  We may
   have been reconnected to a smaller terminal */

	     auto_capabilities_info.version = capabilities_info_version_1;
	     call iox_$control (attach_data.target_iocb_ptr, "get_capabilities", addr (auto_capabilities_info), code);
	     call async_or_error (code);

/* Start out with the old values. Since we got an error,
   one of these values is wrong. */
	     auto_window_position_info.extent.width = attach_data.current.columns;
	     auto_window_position_info.extent.height = attach_data.current.rows;
	     auto_window_position_info.origin.line = attach_data.line_origin;
	     auto_window_position_info.origin.column = attach_data.column_origin;
	     auto_window_position_info.version = window_position_info_version_1;

/* If the window is wider than the screen, knock off the
   rightmost columns. */
	     if attach_data.current.columns + attach_data.column_origin - 1 > auto_capabilities_info.screensize.columns then
		auto_window_position_info.extent.width = auto_capabilities_info.screensize.columns - attach_data.column_origin + 1;

/* If the top of the window is within two lines of the
   bottom of the screen (or is off the bottom), make the
   window take over the entire screen. */
	     if attach_data.current.line_origin > (auto_capabilities_info.screensize.rows - 2) then
		auto_window_position_info.origin.line = 1;

/* otherwise shorten the window if it runs off the
   bottom of the screen */
	     else if (attach_data.current.line_origin + attach_data.current.rows - 1)
		     > auto_capabilities_info.screensize.rows then
		auto_window_position_info.extent.height =
		     (auto_capabilities_info.screensize.rows - attach_data.line_origin + 1);

	     call iox_$control (iocb_ptr, "set_window_info", addr (auto_window_position_info), code);
	     call async_or_error (code);

end resize_window;

raw_write:
     procedure (t);

dcl      t		  char (*);

dcl      code		  fixed bin (35);

/* Calling window_$write_raw_text sets the screen_invalid status
   bit and the status_pending bit, but no status code is returned.
   The next call to some other window_ entrypoint will return
   the status_pending code.  The iox_ interface assumes that the
   user of rawo mode knows what he is doing and resets the status
   generated by write_raw_text calls. */

	call window_$write_raw_text (iocb_ptr, t, code);
	call async_or_error (code);			/* If there was no code, then any status remaining is a result
						   of the raw output.  Reset the status so the next non-raw
						   window_ call won't error out. */
	attach_data.status_pending = "0"b;
	attach_data.status.screen_invalid = "0"b;
	attach_data.cursor_valid = "1"b;
	return;

     end raw_write;

clear_to_end_of_line:
     procedure;

dcl      code		  fixed bin (35);

	call window_$clear_to_end_of_line (iocb_ptr, code);
	call async_or_error (code);
	return;

     end clear_to_end_of_line;

ring:
     procedure;

declare  code		  fixed bin (35);

	call window_$bell (iocb_ptr, code);
	call async_or_error (code);
     end ring;

/* More processing routine. */

check_more:
     procedure;

recheck_more:
	if ^attach_data.more_processing then
	     return;

	if (attach_data.more_mode = MORE_MODE_SCROLL) | (attach_data.more_mode = MORE_MODE_FOLD) then
	     if lines_written_since_read >= (attach_data.current.rows - 1) then
		;
	     else return;

	else if ^((attach_data.line = attach_data.current.rows) & (attach_data.col = 1)) then
	     return;

	call perform_more_break ();

perform_more_break:
	procedure;

dcl      continue_output	  bit (1) aligned;
dcl      prompt		  character (80) varying;
dcl      (yesses_string, noes_string)
			  character (40) varying;
dcl      i		  fixed bin;
dcl      got_response	  bit (1) aligned;
dcl      response		  character (1);
dcl      r		  character (1);
dcl      break		  character (1) varying;
dcl      1 more_data	  like more_info;

dcl      quit		  condition;

dcl      ioa_$rsnnl		  entry () options (variable);
dcl      continue_to_signal_	  entry (fixed bin (35));


/* Check to see if the user has supplied his own more handler. */
	     if attach_data.more_handler_in_use then do;
		continue_output = "1"b;

		more_data.version = more_info_version;
		more_data.window_iocb_ptr = iocb_ptr;
		more_data.more_mode = attach_data.more_mode;
		more_data.more_prompt = attach_data.more_prompt;
		more_data.more_responses.n_yeses = attach_data.more_responses.n_yeses;
		more_data.more_responses.n_noes = attach_data.more_responses.n_noes;
		more_data.more_responses.more_yeses = attach_data.more_responses.more_yeses;
		more_data.more_responses.more_noes = attach_data.more_responses.more_noes;

/* make sure that QUIT during more break will be seen */
		on quit
		     begin;
			attach_data.lines_written_since_read = 0;
			call get_to_next_line ();
			call continue_to_signal_ ((0));
		     end;

		call attach_data.more_handler (addr (more_data), continue_output, code);

		revert quit;

		if code = video_et_$window_status_pending then do;
		     attach_data.status_pending = "0"b;
		     string (attach_data.status) = ""b;
		     go to recheck_more;
		end;
		call async_or_error (code);

		if continue_output then
		     goto CONTINUE_OUTPUT;
		else goto ABORT_OUTPUT;
	     end;

/* No user supplied more handle, so do it ourselves. */

	     yesses_string = "";
	     do i = 1 to attach_data.n_yeses;
		yesses_string = yesses_string || flat_rep (substr (attach_data.more_yeses, i, 1));
		yesses_string = yesses_string || " ";
	     end;

	     noes_string = "";
	     do i = 1 to attach_data.n_noes;
		noes_string = noes_string || flat_rep (substr (attach_data.more_noes, i, 1));
		noes_string = noes_string || " ";
	     end;

	     call ioa_$rsnnl (attach_data.more_prompt, prompt, (0), yesses_string, noes_string);

	     do while ("1"b);

/* Make sure that QUIT during more break will get seen */
		on quit
		     begin;
			attach_data.lines_written_since_read = 0;
			call get_to_next_line;
			call continue_to_signal_ ((0));
		     end;

/* What should be done if the more prompt is bigger than the
   window?  For now we will just truncate it. */

		if length (rtrim (prompt)) > attach_data.current.columns then
		     prompt = substr (prompt, 1, attach_data.current.columns);

		call window_$write_sync_read (iocb_ptr, rtrim (prompt), (1), response, (0), break, code);

		revert quit;

/* Already printed prompt once, don't again. */
		prompt = "";

		if code = video_et_$window_status_pending then do;
						/* something in this window went off */
		     attach_data.status_pending = "0"b;
		     string (attach_data.status) = ""b;
		     go to recheck_more;
		end;
		call async_or_error (code);

		if length (break) = 1 then
		     r = break;
		else r = response;

		got_response = "1"b;

verify_response:
		begin;

dcl      the_yeas		  character (attach_data.n_yeses) defined (attach_data.more_yeses) position (1);
dcl      the_nays		  character (attach_data.n_noes) defined (attach_data.more_noes) position (1);

		     if index (the_yeas, r) > 0 then
			continue_output = "1"b;

		     else if index (the_nays, r) > 0 then
			continue_output = "0"b;

		     else do;
			got_response = "0"b;
			call ring;
		     end;

		end verify_response;

		if got_response then
		     if continue_output then
			goto CONTINUE_OUTPUT;
		     else goto ABORT_OUTPUT;

	     end;					/* do while */

ABORT_OUTPUT:
	     if attach_data.more_mode = MORE_MODE_SCROLL then do;
		call window_$position_cursor (iocb_ptr, attach_data.current.rows, 1, code);
		call async_or_error (code);
		call clear_to_end_of_line;
	     end;
	     else if attach_data.more_mode = MORE_MODE_FOLD then do;
		call window_$position_cursor (iocb_ptr, attach_data.cursor_position.line, 1, code);
		call async_or_error (code);
		call clear_to_end_of_line;
	     end;
	     else do;				/* WRAP or CLEAR, so get to top of window. */
		if attach_data.more_mode = MORE_MODE_WRAP then do;
		     call window_$position_cursor (iocb_ptr, attach_data.current.rows, 1, code);
		     call async_or_error (code);
		     call clear_to_end_of_line;
		     call window_$overwrite_text (iocb_ptr, "(output discarded)", code);
		     call async_or_error (code);
		end;
		call get_to_next_line;
	     end;

	     attach_data.lines_written_since_read = 0;

	     call window_$sync (iocb_ptr, code);
	     call async_or_error (code);

	     call abort_output ();			/* does not return */

CONTINUE_OUTPUT:
	     if (attach_data.more_mode = MORE_MODE_SCROLL) then do;
		call window_$position_cursor (iocb_ptr, attach_data.line, 1, code);
		call async_or_error (code);
		call clear_to_end_of_line;
	     end;

	     else if (attach_data.more_mode = MORE_MODE_FOLD) then do;
		call window_$position_cursor (iocb_ptr, attach_data.line, 1, code);
		call async_or_error (code);
		call clear_to_end_of_line;
		call window_$overwrite_text (iocb_ptr, "--continuing--", code);
		call async_or_error (code);
		call get_to_next_line;
	     end;

	     else if (attach_data.more_mode = MORE_MODE_WRAP) then do;
		call window_$position_cursor (iocb_ptr, attach_data.line, 1, code);
		call async_or_error (code);
		call clear_to_end_of_line;
		call window_$overwrite_text (iocb_ptr, "--continuing--", code);
		call async_or_error (code);
		call get_to_next_line;
	     end;

	     else call get_to_next_line;

	     attach_data.lines_written_since_read = 0;

	     return;

flat_rep:
	     procedure (c) returns (char (32) varying);

dcl      c		  character (1);

		if c = byte (bin ("015"b3)) then
		     return ("RETURN");
		if c < " " then
		     return ("^" || byte (rank (c) + rank ("@")));
		if c = " " then
		     return ("SPACE");
		if c = byte (bin ("177"b3)) then
		     return ("DEL");
		return (c);

	     end flat_rep;

	end perform_more_break;

     end check_more;

abort_output:
     procedure;

	attach_data.discard_output = "1"b;
	Code = 0;
	go to RETURN;

     end abort_output;

reset_more_entry:
     entry (Iocb_ptr);

	iocb_ptr = Iocb_ptr -> iocb.actual_iocb_ptr;
	attach_data_ptr = iocb_ptr -> iocb.attach_data_ptr;

	attach_data.discard_output = "0"b;

	return;

put_chars:
     entry (Iocb_ptr, Buffer_ptr, Buffer_len, Code);

	iocb_ptr = Iocb_ptr -> iocb.actual_iocb_ptr;
	attach_data_ptr = iocb_ptr -> iocb.attach_data_ptr;

	Code = 0;
	ERROR_COUNT = 0;
	PROCESSED_SO_FAR = 0;   /* as soon as ASYNC_EVENT is set this must be valid.  stack garbage won't do. */

	if attach_data.discard_output then
	     return;

	if attach_data.rawo then do;
RESTART_PUT_RAW_CHARS:
	     ASYNC_EVENT = RESTART_PUT_RAW_CHARS;
	     call raw_write (Buffer);
	     goto put_chars_return;
	end;

	ASYNC_EVENT = RESTART_PUT_CHARS;

/* Cover our ass against funny (ha ha) cursor positions */

	if attach_data.line > attach_data.current.rows	/* IMPOSSIBLE */
	then do;
	     call window_$position_cursor (iocb_ptr, attach_data.current.rows, 1, code);
	     call async_or_error (code);
	end;

	call clear_to_end_of_line;			/* neater displays */
	call put_out_chars (Buffer);

put_chars_return:
	call window_$sync (iocb_ptr, (0));
	return;

RESTART_PUT_CHARS:
	begin;

dcl      reput_str		  character (length (Buffer) - PROCESSED_SO_FAR) defined (Buffer)
			  position (PROCESSED_SO_FAR + 1);
	     if length (reput_str) > 0 then
		call put_out_chars (reput_str);
	     go to put_chars_return;
	end;

get_chars:
     entry (Iocb_ptr, Buffer_ptr, Buffer_len, N_returned, Code);

	Code = 0;
	N_returned = 0;

	iocb_ptr = Iocb_ptr -> iocb.actual_iocb_ptr;
	attach_data_ptr = iocb_ptr -> iocb.attach_data_ptr;

	attach_data.discard_output = "0"b;
	attach_data.lines_written_since_read = 0;

	if Buffer_len = 0 | Buffer_ptr = null () then
	     return;

/* Read all the characters the user has typed so far. */
	do char_count = 1 by 1;
	     call window_$get_one_unechoed_char (iocb_ptr, char_varying, "0"b /* don't block */, Code);
	     if Code ^= 0 then
		return;

/* No more characters. */
	     if length (char_varying) = 0 then do;
		N_returned = char_count - 1;
		return;
	     end;

	     substr (Buffer, char_count, 1) = char_varying;

/* If we are supposed to echo, try echoing through put_chars.
   This is pretty weird, but gets output conversions done. */

	     if ^attach_data.suppress_echo then do;
		char_nonvarying = char_varying;
		call iox_$put_chars (iocb_ptr, addr (char_nonvarying), 1, Code);
		if Code ^= 0 then
		     return;
	     end;
	end;

	return;

cl_pusher:
     procedure (cl_arg);
declare  1 cl_arg		  aligned,
	 2 resetread	  bit (1) unaligned,
	 2 pad		  bit (35) unaligned;

/* We want to call the usual cl_intermediary, but when it returns,
   we want to pretend something asynchronous has happened, which it has. */

	call REAL_CL_INTERMEDIARY (cl_arg);

	go to ASYNC_EVENT;

     end cl_pusher;

%page;
%include window_io_attach_data_;
%page;
%include window_line_editor;
%page;
%include window_dcls;
%page;
%include window_control_info;
%page;
%include window_more_info;
%page;
%include tc_screen_image;
%page;
%include tty_convert;
%page;
%include iox_entries;
%page;
%include iocb;
%page;
%include sub_err_flags;

     end window_io_iox_;
