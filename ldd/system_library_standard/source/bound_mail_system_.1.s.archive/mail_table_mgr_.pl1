/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(1988-09-13,Blair), approve(1988-09-13,MCR7990),
     audit(1988-09-21,Dupuis), install(1988-09-26,MR12.2-1121):
     Change mail_table_priv_$salvage to unlock the original mail-table before
     it is closed and to base the like header for the new table on its ptr.
     Mail error_list #510.
  2) change(1988-12-14,Parisek), approve(1989-01-11,MCR8044),
     audit(1989-01-16,Farley), install(1989-01-19,MR12.3-1006):
     Added the get_name_by_index non privileged entry for returning the
     mail-table name based on an index into the mail-table.  Useful for
     scanning the mail-table while matching starnames (ie, dsmla <starname>).
  3) change(1989-08-02,Lee), approve(1989-08-22,MCR8128),
     audit(1989-09-25,LZimmerman), install(1989-10-02,MR12.3-1079):
     phx20967 (Mail 445) - added entry delete_alias_case_ins to allow the
     update_mail_table_entry command to delete alias entries
     case-insensitively; phx17774, phx21076 (Mail 445) - modified
     mail_table_mgr_$put to search for entries case-insensitively.
  4) change(2016-01-15,Swenson), approve(2016-01-15,MCR10003):
     Fix to support 4-character time zone abbreviations.
                                                   END HISTORY COMMENTS */


/* format: style2,ifthenstmt,ifthendo,ifthen,^indnoniterdo,indcomtxt,^inditerdo,idind22 */

/* mail_table_mgr_: this program manipulates the system Mail
   Table, which is used to find out the electronic mail address of
   users when you don't know the project, or for non-user objects
   that you wish to address mail to as if they were users (i.e.  not
   by pathname).  Users may update their own mailing addresses,
   privileged users may update any mail table entry, and ACS may be
   set up by privileged users to control who may update particular
   addresses. */

/* Written: June/July 1983 by B. Margolin */
/* Modified: 15 August 1984 by E. Swenson for V3 MSTBs */
/* Modified: 17 December 1984 by E. Swenson and Gary M. Palter to properly
   ignore error_table_$checksum_error, to properly update entries, and to
   rechain aliases correctly when deleting an alias */

mail_table_mgr_:
     proc ();

	/*** Parameters ***/

	dcl     P_acs_path		char (*) parameter; /* ACS pathname */
	dcl     P_address_ptr	ptr parameter;	/* -> Mail system address */
	dcl     P_alias		char (*) varying parameter;
						/* Alias */
	dcl     P_area_ptr		ptr parameter;	/* -> area */
	dcl     P_code		fixed bin (35) parameter;
	dcl     P_count		fixed bin parameter;/* Number of entries */
	dcl     P_dft_proj		char (*) parameter; /* Default project */
	dcl     P_id		char (*) varying parameter;
						/* Name or alias */
	dcl     P_index		fixed bin parameter;/* Index into mail table */
	dcl     P_message		char (*) parameter; /* More detailed error message for salvage */
	dcl     P_mta_ptr		ptr parameter;	/* -> mail_table_aliases */
	dcl     P_mte_ptr		ptr parameter;	/* -> mail_table_entry */
	dcl     P_mtre_ptr		ptr parameter;	/* -> mail_table_raw_entry */
	dcl     P_pnt		bit (1) parameter;	/* Manipulate entries which correspond to PNT entries */
	dcl     P_return_id		char (*) varying parameter;
						/* Name or alias returned by get_name_by_index */
	dcl     P_test_dir		char (*) parameter; /* Directory containing mil table for testing */
	dcl     P_version		char (*) parameter; /* Version string */

	/*** Automatic ***/

	dcl     address		char (256) varying; /* Formatted address */
	dcl     alias		char (32) varying;
	dcl     already_in_fatal_error
				bit (1);
	dcl     anon		fixed bin;	/* For all you Shakespeare lovers */
	dcl     by_name_number	bit (1);		/* For name_by_index entrypoint */
	dcl     by_number		bit (1);		/* Which get_raw entrypoint? */
	dcl     case_insensitive_sw	bit (1);		/* Perform case-insensitive search */
	dcl     cur_mtep		ptr;		/* -> mail table entry */
	dcl     day		fixed bin;
	dcl     (disp_day, disp_hour, disp_minute, disp_month)
				pic "99";
	dcl     entry_num		fixed bin (35);
	dcl     hour		fixed bin;
	dcl     i			fixed bin;
	dcl     ignore_code		fixed bin (35);
	dcl     ignore_rs		fixed bin (35);
	dcl     index		fixed bin;
	dcl     initial_ring	fixed bin;
	dcl     key		char (32);
	dcl     mail_table_locked	bit (1);
	dcl     minute		fixed bin;
	dcl     month		fixed bin;
	dcl     1 msti		aligned like ms_table_info;
	dcl     my_area		area based (my_area_ptr);
	dcl     my_area_ptr		ptr;		/* -> my_area */
	dcl     new		bit (1);		/* New entry or updating? */
	dcl     new_mtep		ptr;		/* -> New mail table entry */
	dcl     new_name		char (32);
	dcl     new_new_name	char (32);
	dcl     next_name		char (32) varying;
	dcl     original_time	fixed bin (71);	/* Used by reader locking */
	dcl     original_write_count	fixed bin;	/* ditto */
	dcl     person_id		char (32) varying;	/* Name of entry */
	dcl     pnt		bit (1);		/* Does entry correspond to PNT entry? */
	dcl     real_mtep		ptr;		/* -> real_mte */
	dcl     theres_more		bit (1);

	/*** Based ***/

	dcl     1 mail_table_header	aligned based (mthp),
		2 write_lock	bit (36),
		2 write_count	fixed bin,
		2 entry_count	fixed bin;	/* Count of mail table entries */
	dcl     1 real_mte				/** In case we ever want non-external data (like locks) **/
				aligned based (real_mtep),
		2 raw_entry	aligned like mail_table_raw_entry;

	/*** Entries ***/

	dcl     (
	        cu_$level_get,
	        cu_$level_set
	        )			entry (fixed bin);
	dcl     decode_clock_value_$date_time
				entry (fixed bin (71), fixed bin, fixed bin, fixed bin (35), fixed bin, fixed bin,
				fixed bin (35), fixed bin (35), fixed bin (35), char (4), fixed bin (35));
	dcl     get_ring_		entry () returns (fixed bin (3));
	dcl     hcs_$chname_file	entry (char (*), char (*), char (*), char (*), fixed bin (35));
	dcl     ms_table_mgr_$close	entry (ptr, fixed bin (35));
	dcl     ms_table_mgr_$abs_entry
				entry (ptr, fixed bin (35), char (*), bit (1) aligned, ptr, fixed bin (35),
				fixed bin (35));
	dcl     ms_table_mgr_$create	entry (char (*), char (*), ptr, fixed bin (35));
	dcl     ms_table_mgr_$delete_entry
				entry (ptr, char (*), fixed bin (35));
	dcl     ms_table_mgr_$find_entry
				entry (ptr, char (*), ptr, bit (1) aligned, fixed bin (35), fixed bin (35));
	dcl     ms_table_mgr_$find_entry_case_ins
				entry (ptr, char (*), ptr, bit (1) aligned, fixed bin (35), fixed bin (35));
	dcl     ms_table_mgr_$new_entry
				entry (ptr, char (*), ptr, fixed bin (35));
	dcl     ms_table_mgr_$open	entry (char (*), char (*), char (*) aligned, ptr, ptr, fixed bin (35));
	dcl     ms_table_mgr_$update_entry
				entry (ptr, ptr, fixed bin (35));
	dcl     pathname_		entry (char (*), char (*)) returns (char (168));
	dcl     probe		entry options (variable);
	dcl     set_lock_$lock	entry (bit (36) aligned, fixed bin, fixed bin (35));
	dcl     set_lock_$unlock	entry (bit (36) aligned, fixed bin (35));
	dcl     timer_manager_$sleep	entry (fixed bin (71), bit (2));
	dcl     unique_chars_	entry (bit (*)) returns (char (15));
	dcl     user_info_$login_data entry (char (*), char (*), char (*), fixed bin);

	/*** Constants and Static ***/

	dcl     already_inited	bit (1) int static init ("0"b);
	dcl     anonymous_user	bit (1) int static; /* This is an anonymous process */
	dcl     BIG_NUMBER		fixed bin (17) int static options (constant) init (32767);
	dcl     DEBUGGING		bit (1) int static options (constant) init ("0"b);
	dcl     (
	        error_table_$action_not_performed,
	        error_table_$argerr,
	        error_table_$bad_index,
	        error_table_$bad_subr_arg,
	        error_table_$bigarg,
	        error_table_$checksum_failure,
	        error_table_$id_already_exists,
	        error_table_$id_not_found,
	        error_table_$insufficient_access,
	        error_table_$invalid_lock_reset,
	        error_table_$lock_wait_time_exceeded,
	        error_table_$locked_by_other_process,
	        error_table_$no_record,
	        error_table_$null_info_ptr,
	        error_table_$request_id_ambiguous,
	        error_table_$smallarg,
	        error_table_$unexpected_condition,
	        error_table_$unimplemented_version,
	        mlsys_et_$ambiguous_address,
	        mlsys_et_$bad_mail_table
	        )			fixed bin (35) ext static;
	dcl     LOCK_WAIT_TIME	fixed bin int static options (constant) init (30);
	dcl     MAIL_TABLE_DIR	char (168) int static init ("");
						/* Not constant */
	dcl     MAIL_TABLE_NAME	char (32) int static options (constant) init ("MAIL_TABLE");
	dcl     MAIL_TABLE_TYPE_STRING
				char (32) aligned int static options (constant) init ("mail_table");
	dcl     mlsys_data_$system_directory
				char (168) ext static;
	dcl     mt_ptr		ptr int static init (null ());
						/* -> Mail table structure */
	dcl     mthp		ptr int static init (null ());
						/* -> mail_table_header */
	dcl     my_person_id	char (32) internal static;
	dcl     NO_WRITE		bit (1) aligned internal static options (constant) initial ("0"b);
	dcl     sys_info$max_seg_size fixed bin (19) external static;

	/*** Builtins and Conditions ***/

	dcl     (addr, bool, character, clock, length, maxlength, null, rtrim, size, string, substr)
				builtin;
	dcl     (any_other, cleanup)	condition;
%page;
%include access_mode_values;
%page;
%include acl_structures;
%page;
%include mail_table_entry;
%page;
%include ms_table_info;

/**** Get the user-accessible information from a mail table entry.
      This is the target of the gate mail_table_$get
****/

mail_table_mgr_$get:
     entry (P_id, P_address_ptr, P_acs_path, P_code);

	on cleanup call cleanup_proc ();
	on any_other call any_other_proc ();
	call setup ();
	if length (P_id) = 0 then
	     person_id = my_person_id;
	else person_id = P_id;
GET_TRY_AGAIN:
	call get_write_count ();
	call retrieve_real_mte (person_id, "1"b, "1"b, real_mtep);
	call get_address (real_mte, P_address_ptr);
	if real_mte.acs_path.dir = "" then
	     P_acs_path = "";
	else P_acs_path = pathname_ ((real_mte.acs_path.dir), (real_mte.acs_path.entry));
	if mt_modified () then go to GET_TRY_AGAIN;
	call exit_proc ();

/**** This entrypoint is used by normal users to change their mail
      table information.  This is the target of the gate mail_table_$set.
****/

mail_table_mgr_$put:
     entry (P_id, P_address_ptr, P_code);

	on cleanup call cleanup_proc ();
	on any_other call any_other_proc ();
	call setup ();
	if P_id = "" then				/* Null-string means self */
	     if anonymous_user then
		call fatal_error (error_table_$action_not_performed);
						/* Anonymous users have no mail table entries */
	     else person_id = my_person_id;
	else person_id = P_id;
	if length (P_id) > maxlength (mail_table_entry.name) then call fatal_error (error_table_$bigarg);
	if P_address_ptr = null () then
	     address = "";				/* Revert to default project */
	else call format_address (P_address_ptr, address);
	call lock_mail_table ();
	call retrieve_real_mte (person_id, "1"b, "1"b, real_mtep);
						/* phx17774, phx21076 RL: get it case-insensitively */
	if real_mte.name ^= my_person_id then call check_acs_access (real_mte.acs_path);
	if ^real_mte.registered_user & P_address_ptr = null () then call fatal_error (error_table_$bad_subr_arg);
						/* Non-users have no default project */
	real_mte.mailing_address = address;
	call update_new_entry (real_mtep);
	call unlock_mail_table ();
	call exit_proc ();

/**** This entrypoint just sets the default project in a mail table
      entry.  It is the target of mail_table_initializer_$set_dft_proj.
****/

mail_table_mgr_$set_dft_proj:
     entry (P_id, P_dft_proj, P_code);

	person_id = P_id;
	on cleanup call cleanup_proc ();
	on any_other call any_other_proc ();
	call setup ();
	call lock_mail_table ();
	call retrieve_real_mte (person_id, "0"b, "0"b, real_mtep);
	real_mte.default_project = P_dft_proj;
	call update_new_entry (real_mtep);
	call unlock_mail_table ();
	call exit_proc ();

/**** This entrypoint adds a new entry to the mail table.  It is the
      target of mail_table_priv_$add.
****/

mail_table_mgr_$add:
     entry (P_mte_ptr, P_pnt, P_code);

	new = "1"b;
	go to ADD_UPDATE_COMMON;

/**** This entrypoint updates an existing entry in the mail table.  It is the
      target of mail_table_priv_$update.
****/

mail_table_mgr_$update:
     entry (P_mte_ptr, P_pnt, P_code);

	new = "0"b;

ADD_UPDATE_COMMON:
	pnt = P_pnt;
	on cleanup call cleanup_proc ();
	on any_other call any_other_proc ();
	call setup ();
	call check_mtep (P_mte_ptr);
	mail_table_entry_ptr = P_mte_ptr;
	/*** Check for inconsistency ***/
	if
	/*** (pnt & mail_table_entry.default_project = "") |
	     Taken out because there are PNT entries with blank
	     default projects, damn - barmar 9/2/83 ***/
	     (new & ^pnt & mail_table_entry.default_project ^= "") then
	     call fatal_error (error_table_$bad_subr_arg);
	real_mtep = null ();
	call lock_mail_table ();
	if new then do;
	     call make_new_entry (mail_table_entry.name, real_mtep);
	     string (real_mte.flags) = ""b;
	     real_mte.version = MAIL_TABLE_RAW_ENTRY_VERSION_1;
	     real_mte.name, real_mte.primary_name = mail_table_entry.name;
	     real_mte.registered_user = pnt;
	     real_mte.n_names = 1;
	     real_mte.next_name, real_mte.prev_name = "";
	end;
	else do;
	     call retrieve_real_mte (mail_table_entry.name, "1"b, "0"b, real_mtep);
	     if (^pnt & mail_table_entry.default_project ^= real_mte.default_project)
		| (pnt & ^real_mte.registered_user) then
		call fatal_error (error_table_$bad_subr_arg);
	end;
	real_mte.acs_path = mail_table_entry.acs_path;
	real_mte.default_project = mail_table_entry.default_project;
	real_mte.mailing_address = mail_table_entry.mailing_address;
	call update_new_entry (real_mtep);
	call unlock_mail_table ();
	call exit_proc ();

/**** This entrypoint deletes a mail table entry.  It is the target of
      mail_table_priv_$delete.
****/

mail_table_mgr_$delete:
     entry (P_id, P_pnt, P_code);

	pnt = P_pnt;
	person_id = P_id;
	on cleanup call cleanup_proc ();
	on any_other call any_other_proc ();
	call setup ();
	call lock_mail_table ();
	call retrieve_real_mte (person_id, "1"b, "0"b, real_mtep);
	if pnt ^= real_mte.registered_user then call fatal_error (error_table_$bad_subr_arg);
	do while (real_mte.next_name ^= "");
	     next_name = real_mte.next_name;
	     call delete_real_mte (real_mte);
	     call retrieve_real_mte (next_name, "0"b, "1"b, real_mtep);
	end;
	call delete_real_mte (real_mte);
	call unlock_mail_table ();
	call exit_proc ();

/**** This entrypoint gets most of the information from a mail table entry,
      in the same structure that is acceptible to mail_table_mgr_$update.
      It is the target of the gate mail_table_priv_$get.
****/

mail_table_mgr_$priv_get:
     entry (P_id, P_mte_ptr, P_code);

	person_id = P_id;
	on cleanup call cleanup_proc ();
	on any_other call any_other_proc ();
	call setup ();
	call check_mtep (P_mte_ptr);
	mail_table_entry_ptr = P_mte_ptr;
TRY_PRIV_GET_AGAIN:
	call get_write_count ();
	call retrieve_real_mte (person_id, "1"b, "1"b, real_mtep);
	mail_table_entry.name = real_mte.name;
	mail_table_entry.mailing_address = real_mte.mailing_address;
	mail_table_entry.default_project = real_mte.default_project;
	mail_table_entry.acs_path = real_mte.acs_path;
	if mt_modified () then go to TRY_PRIV_GET_AGAIN;
	call exit_proc ();

/**** This entrypoint returns a copy of the actual structure stored in the
      mail table, after chasing alias links.  It is the target of the gate
      mail_table_priv_$get_raw_by_name.
****/

mail_table_mgr_$get_raw_by_name:
     entry (P_id, P_mtre_ptr, P_code);

	by_number = "0"b;
	by_name_number = "0"b;
	person_id = P_id;
	go to GET_RAW_COMMON;

/**** This is the same as get_raw_by_name, except that it takes an
      index into the mail table array and it does not chase links.
      It is the target of the gate mail_table_priv_$get_raw_by_index.
****/

mail_table_mgr_$get_raw_by_index:
     entry (P_index, P_mtre_ptr, P_code);

	by_number = "1"b;
	by_name_number = "0"b;
	index = P_index;
	go to GET_RAW_COMMON;


/**** This is the same as get_raw_by_index, except that it returns
      only the mail table name without chasing links.  It is the
      target of the gate mail_table_$get_name_by_index.
****/

mail_table_mgr_$get_name_by_index:
     entry (P_index, P_version, P_return_id, P_code);

	by_number = "0"b;
	by_name_number = "1"b;
	index = P_index;

GET_RAW_COMMON:
	on cleanup call cleanup_proc ();
	on any_other call any_other_proc ();
	call setup ();
	if by_name_number then do;
	     if P_version ^= MAIL_TABLE_RAW_ENTRY_VERSION_1 then call fatal_error (error_table_$unimplemented_version);
	end;
	else do;
	     call check_mtrep (P_mtre_ptr);
	     mail_table_raw_entry_ptr = P_mtre_ptr;
	end;
TRY_GET_RAW_AGAIN:
	call get_write_count ();
	if by_number | by_name_number then do;
	     call retrieve_real_mte_n (index, real_mtep);
	     if by_name_number then P_return_id = real_mtep -> real_mte.name;
	end;
	else call retrieve_real_mte (person_id, "1"b, "0"b, real_mtep);
	if ^by_name_number then mail_table_raw_entry = real_mte.raw_entry;
	if mt_modified () then go to TRY_GET_RAW_AGAIN;
	call exit_proc ();

/**** This entrypoint adds an alias to an existing entry.
      This is the target of the gate mail_table_priv_$add_alias.
****/

mail_table_mgr_$add_alias:
     entry (P_id, P_alias, P_pnt, P_code);

	pnt = P_pnt;
	person_id = P_id;
	alias = P_alias;
	on cleanup call cleanup_proc ();
	on any_other call any_other_proc ();
	call setup ();
	if alias = "" then call fatal_error (error_table_$bad_subr_arg);
	if length (alias) > maxlength (mail_table_entry.name) then call fatal_error (error_table_$bigarg);
	on cleanup call cleanup_proc ();
	call setup ();
	real_mtep, new_mtep = null ();
	call lock_mail_table ();
	call retrieve_real_mte (person_id, "1"b, "1"b, real_mtep);
	if pnt & ^real_mte.registered_user then call fatal_error (error_table_$bad_subr_arg);
	cur_mtep = real_mtep;
	if pnt then
	     do next_name = real_mte.next_name /* If setting the login alias */
		repeat cur_mtep -> real_mte.next_name while (cur_mtep -> real_mte.next_name ^= "");
	     call retrieve_real_mte (next_name, "0"b, "0"b, cur_mtep);
	     if cur_mtep -> real_mte.registered_user then do;
		cur_mtep -> real_mte.registered_user = "0"b;
						/* then turn off the old one */
		go to ADD_THE_ALIAS;
	     end;
	end;
	cur_mtep = null ();				/* Didn't find one */

ADD_THE_ALIAS:
	begin;					/* for on unit */
	     on cleanup
		begin;
		     if new_mtep ^= null () then do;
			call delete_real_mte (new_mtep -> real_mte);
			if pnt & cur_mtep ^= null () /* Fix the old login alias */ then
			     cur_mtep -> real_mte.registered_user = "1"b;
		     end;
		end;
	     call make_new_entry (alias, new_mtep);
	     new_mtep -> real_mte.version = MAIL_TABLE_RAW_ENTRY_VERSION_1;
	     new_mtep -> real_mte.name = alias;
	     new_mtep -> real_mte.primary_name = real_mte.name;
	     string (new_mtep -> real_mte.flags) = "0"b;
	     new_mtep -> real_mte.registered_user = pnt;
	     new_mtep -> real_mte.alias_entry = "1"b;
	     new_mtep -> real_mte.prev_name = "";
	     new_mtep -> real_mte.next_name = real_mte.next_name;
	     /*** Null out the unused components ***/
	     new_mtep -> real_mte.acs_path.dir, new_mtep -> real_mte.acs_path.entry,
		new_mtep -> real_mte.default_project, new_mtep -> real_mte.mailing_address = "";
	     call update_new_entry (new_mtep);
	end;
	if cur_mtep ^= null then call update_new_entry (cur_mtep);
	real_mte.n_names = real_mte.n_names + 1;
	real_mte.next_name = alias;
	call update_new_entry (real_mtep);
	call unlock_mail_table ();
	call exit_proc ();

/**** This entrypoint deletes a specified alias entry.  It is the target
      of the gate mail_table_priv_$delete_alias.
****/

mail_table_mgr_$delete_alias:
     entry (P_alias, P_pnt, P_code);

	pnt = P_pnt;
	alias = P_alias;
	case_insensitive_sw = "0"b;
	go to DELETE_ALIAS_COMMON;

/**** This entrypoint deletes a specified alias entry case-insensitively.
      It is the target of the gate mail_table_priv_$delete_alias_case_ins.
****/

mail_table_mgr_$delete_alias_case_ins:
     entry (P_alias, P_pnt, P_code);

	pnt = P_pnt;
	alias = P_alias;
	case_insensitive_sw = "1"b;

DELETE_ALIAS_COMMON:
	on cleanup call cleanup_proc ();
	on any_other call any_other_proc ();
	call setup ();
	call lock_mail_table ();
	call retrieve_real_mte (alias, "0"b, case_insensitive_sw, real_mtep);
	if ^real_mte.alias_entry /* it's not an alias */ | pnt ^= real_mte.registered_user /* wrong entrypoint */ then
	     call fatal_error (error_table_$bad_subr_arg);
	/*** Remove this alias from the chain: only the "forward" chain is maintained */
	call retrieve_real_mte (real_mte.primary_name, "0"b, "0"b, cur_mtep);
	do while (cur_mtep ^= null ());
	     if cur_mtep -> real_mte.next_name = real_mtep -> real_mte.name then do;
		cur_mtep -> real_mte.next_name = real_mtep -> real_mte.next_name;
		call update_new_entry (cur_mtep);
		cur_mtep = null ();			/* rechaining complete */
	     end;
	     else if cur_mtep -> real_mte.next_name = "" then cur_mtep = null ();
						/* chain was broken by an earlier bug */
	     else call retrieve_real_mte (cur_mtep -> real_mte.next_name, "0"b, "0"b, cur_mtep);
	end;
	/*** Now delete the alias' entry */
	person_id = real_mte.primary_name;
	call delete_real_mte (real_mte);
	call retrieve_real_mte (person_id, "0"b, "0"b, real_mtep);
	real_mte.n_names = real_mte.n_names - 1;
	call update_new_entry (real_mtep);
	call unlock_mail_table ();
	call exit_proc ();

/**** This entrypoint lists the aliases for a specified entry.
      It is the target of the gate mail_table_$get_aliases.
****/

mail_table_mgr_$get_aliases:
     entry (P_id, P_version, P_area_ptr, P_mta_ptr, P_code);

	on cleanup call cleanup_proc ();
	on any_other call any_other_proc ();
	call setup ();
	if P_version ^= MAIL_TABLE_ALIASES_VERSION_1 then call fatal_error (error_table_$unimplemented_version);
	person_id = P_id;
	if P_area_ptr = null () then call fatal_error (error_table_$null_info_ptr);
TRY_GET_ALIASES_AGAIN:
	call get_write_count ();
	my_area_ptr = P_area_ptr;
	call retrieve_real_mte (person_id, "1"b, "1"b, real_mtep);
	mail_table_aliases_extent = real_mte.n_names;
	call raise_validation ();			/* In case area extends */
	allocate mail_table_aliases in (my_area);
	call lower_validation ();
	mail_table_aliases.version = MAIL_TABLE_ALIASES_VERSION_1;
	do i = 1 to mail_table_aliases.n_names;
	     mail_table_aliases.names (i) = real_mte.name;
	     if real_mte.next_name ^= "" then call retrieve_real_mte (real_mte.next_name, "0"b, "0"b, real_mtep);
	end;
	if mt_modified () then do;
	     free mail_table_aliases in (my_area);
	     go to TRY_GET_ALIASES_AGAIN;
	end;
	P_mta_ptr = mail_table_aliases_ptr;
	call exit_proc ();

/**** This entrypoint just returns the number of mail table entries,
      both primary names and aliases.  It is the target of
      mail_table_priv_$count_entries.
****/

mail_table_mgr_$count_entries:
     entry (P_count, P_code);

	on cleanup call cleanup_proc ();
	on any_other call any_other_proc ();
	call setup ();
	P_count = mail_table_header.entry_count;
	call exit_proc ();

/**** This entrypoint creates a mail table of the specified size.
      It is the target of the gate mail_table_priv_$create.
****/

mail_table_mgr_$create_table:
     entry (P_count, P_code);

	dcl     code		fixed bin (35);

	P_code = 0;
	code = 0;
	msti.version = MS_TABLE_INFO_VERSION_3;
	msti.type = MAIL_TABLE_TYPE_STRING;
	msti.header_size = size (mail_table_header);
	msti.entry_size = size (real_mte);
	msti.max_entries = P_count;
	msti.max_size = sys_info$max_seg_size;
	msti.keep_meters = "0"b;			/* Do not keep meters */
	mt_ptr = null ();
	call cu_$level_get (initial_ring);
	on cleanup
	     begin;
		call close_mail_table ();
		call raise_validation ();
	     end;
	on any_other call fatal_create_error (error_table_$unexpected_condition);
	call lower_validation ();
	if MAIL_TABLE_DIR = "" then MAIL_TABLE_DIR = mlsys_data_$system_directory;
	call ms_table_mgr_$create (MAIL_TABLE_DIR, MAIL_TABLE_NAME, addr (msti), code);
	if code ^= 0 then call fatal_create_error (code);
	call open_mail_table ();
	mail_table_header.entry_count = 0;
	mail_table_header.write_lock = ""b;
	mail_table_header.write_count = 0;
	call close_mail_table ();
	call set_mail_table_acl ();
	call raise_validation ();
	revert cleanup;
	go to JUST_EXIT;

/**** This entrypoint sets the directory in which the mail table will be
      found, for use in testing.
      It is the target of the gate mail_table_priv_$test.
****/

mail_table_mgr_$test:
     entry (P_test_dir);

	call close_mail_table ();
	MAIL_TABLE_DIR = P_test_dir;
	return;

/**** This entrypoint copies the mail table, thus freeing up the
      wasted space left from deleted entries.  The code is mostly ripped
      off from the salvage_mstb command.  This is the target of the
      gate mail_table_priv_$salvage.
****/

mail_table_mgr_$salvage:
     entry (P_count, P_message, P_code);

	P_message = "";
	on cleanup call cleanup_proc ();
	on any_other call any_other_proc ();
	call setup ();
	if P_count < mail_table_header.entry_count then do;
	     P_message = "The specified Mail Table size is smaller than the existing number of entries.";
	     call fatal_error (error_table_$smallarg);
	end;
	msti.version = MS_TABLE_INFO_VERSION_3;
	msti.type = MAIL_TABLE_TYPE_STRING;
	msti.header_size = size (mail_table_header);
	msti.entry_size = size (real_mte);
	msti.max_entries = P_count;
	msti.max_size = sys_info$max_seg_size;
	msti.keep_meters = "0"b;			/* Don't keep meters */
	new_name = rtrim (MAIL_TABLE_NAME) || "." || unique_chars_ (""b);
	call ms_table_mgr_$create (MAIL_TABLE_DIR, new_name, addr (msti), code);
	if code ^= 0 then do;
	     P_message = "Creating the new MSTB: " || pathname_ (MAIL_TABLE_DIR, new_name);
	     call fatal_error (code);
	end;
	begin;					/* For on unit */
	     dcl	   nmt_ptr	     ptr;
	     dcl	   nmth_ptr	     ptr;
	     dcl	   1 nmth		     aligned like mail_table_header based (nmth_ptr);

	     nmt_ptr = null ();
	     on cleanup
		begin;
		     if nmt_ptr ^= null () then call ms_table_mgr_$close (nmt_ptr, ignore_code);
		end;
	     call ms_table_mgr_$open (MAIL_TABLE_DIR, new_name, MAIL_TABLE_TYPE_STRING, nmt_ptr, nmth_ptr, code);
	     if code ^= 0 then do;
		P_message = "Opening the new Mail Table: " || pathname_ (MAIL_TABLE_DIR, new_name);
		call fatal_error (code);
	     end;
	     nmth.entry_count = 0;
	     nmth.write_lock = "0"b;
	     nmth.write_count = 0;
	     P_message = "Locking the old Mail Table.";	/* In case the next call gets an error. */
	     call lock_mail_table ();
	     theres_more = "1"b;
	     do entry_num = 1 by 1 while (theres_more);
		call ms_table_mgr_$abs_entry (mt_ptr, entry_num, key, NO_WRITE, real_mtep, ignore_rs, code);
		if code = 0 then do;
		     call ms_table_mgr_$new_entry (nmt_ptr, key, new_mtep, code);
		     if code = 0 then do;
			new_mtep -> real_mte = real_mte;
			nmth.entry_count = nmth.entry_count + 1;
			call ms_table_mgr_$update_entry (nmt_ptr, new_mtep, code);
			if code ^= 0 then goto CREATE_ERROR;
		     end;
		     else if code = error_table_$id_already_exists /* Ignore this */ then code = 0;
		     else do;
CREATE_ERROR:
			P_message = "Creating new entry for the name """ || rtrim (key) || """.";
			call fatal_error (code);
		     end;
		end;
		else if code = error_table_$no_record then code = 0;
						/* Skip unused or deleted entries */
		else if code = error_table_$bad_index then do;
		     theres_more = "0"b;
		     code = 0;
		end;
		else do;
		     P_message = "Reading entry #" || character (entry_num);
		     call fatal_error (code);
		end;
	     end;
	     call ms_table_mgr_$close (nmt_ptr, ignore_code);
	end;					/* of begin block */
	/*** Rename the old and new tables ***/
	call decode_clock_value_$date_time (clock (), month, day, ignore_rs, hour, minute, ignore_rs, ignore_rs,
	     ignore_rs, (""), ignore_code);
	disp_month = month;				/* These are pic(99) vars */
	disp_day = day;
	disp_hour = hour;
	disp_minute = minute;
	new_new_name =
	     /* MAIL_TABLE.MMDDYY.HHMM */ rtrim (MAIL_TABLE_NAME) || "." || disp_month || "/" || disp_day || "."
	     || disp_hour || disp_minute;
	call hcs_$chname_file (MAIL_TABLE_DIR, MAIL_TABLE_NAME, "", new_new_name, code);
	if code ^= 0 then do;
	     P_message =
		"Adding the name " || rtrim (new_new_name) || " to " || pathname_ (MAIL_TABLE_DIR, MAIL_TABLE_NAME);
	     call fatal_error (code);
	end;
	call hcs_$chname_file (MAIL_TABLE_DIR, MAIL_TABLE_NAME, MAIL_TABLE_NAME, "", code);
						/* Get rid of old name */
	if code ^= 0 then do;
	     P_message = "Removing the name " || pathname_ (MAIL_TABLE_DIR, MAIL_TABLE_NAME);
	     call fatal_error (code);
	end;
	call unlock_mail_table ();
	call close_mail_table ();			/* Close the old one */
	call hcs_$chname_file (MAIL_TABLE_DIR, new_name, new_name, MAIL_TABLE_NAME, code);
						/* and put it on new table */
	if code ^= 0 then do;
	     P_message = "Renaming " || pathname_ (MAIL_TABLE_DIR, new_name) || " to " || MAIL_TABLE_NAME;
	     call fatal_error (code);
	end;
	call set_mail_table_acl ();
	call exit_proc ();

%skip (10);
/**** Come to this page when exiting (either through exit_proc or fatal_error)
****/

GLOBAL_EXIT:
	call cleanup_proc ();
JUST_EXIT:					/* For when we die during error handling */
	return;

	/*** INTERNAL SUBROUTINES ***/

raise_validation:
     proc ();

	call cu_$level_set (initial_ring);
	return;

     end raise_validation;

lower_validation:
     proc ();

	call cu_$level_get (initial_ring);
	call cu_$level_set ((get_ring_ ()));
	return;

     end lower_validation;

setup:
     proc ();

	mail_table_locked = "0"b;
	already_in_fatal_error = "0"b;
	call lower_validation ();
	if ^already_inited then do;
	     call user_info_$login_data (my_person_id, (""), (""), anon);
	     if anon = 1 then
		anonymous_user = "1"b;
	     else anonymous_user = "0"b;
	     if MAIL_TABLE_DIR = "" then MAIL_TABLE_DIR = mlsys_data_$system_directory;
	     call open_mail_table ();
	     already_inited = "1"b;
	end;
	return;

     end setup;

cleanup_proc:
     proc ();

	call unlock_mail_table ();
	call raise_validation ();
	return;

     end cleanup_proc;

any_other_proc:
     proc ();

	call fatal_error (mlsys_et_$bad_mail_table);

     end any_other_proc;

/**** Use this for normal exit ***/
exit_proc:
     proc ();

	P_code = 0;
	go to GLOBAL_EXIT;

     end exit_proc;

fatal_create_error:
     proc (P_fe_code);

	dcl     P_fe_code		fixed bin (35);

	P_code = P_fe_code;
	if DEBUGGING then call probe ();
	go to JUST_EXIT;

     end fatal_create_error;

fatal_error:
     proc (P_fe_code);

	dcl     P_fe_code		fixed bin (35);

	P_code = P_fe_code;
	if DEBUGGING then call probe ();
	if already_in_fatal_error /* recursive error */ then
	     go to JUST_EXIT;			/* ... and don't do anything else */
	else do;
	     already_in_fatal_error = "1"b;
	     go to GLOBAL_EXIT;
	end;

     end fatal_error;

open_mail_table:
     proc ();

	dcl     code		fixed bin (35);

	code = 0;
	if mt_ptr ^= null () then return;
	call ms_table_mgr_$open (MAIL_TABLE_DIR, MAIL_TABLE_NAME, MAIL_TABLE_TYPE_STRING, mt_ptr, mthp, code);
	if code ^= 0 then call fatal_error (code);

	return;

     end open_mail_table;

close_mail_table:
     proc ();

	dcl     code		fixed bin (35);

	code = 0;
	already_inited = "0"b;
	if mt_ptr = null () then return;		/* Already closed */
	call ms_table_mgr_$close (mt_ptr, code);
	if code ^= 0 then call fatal_error (code);
	mt_ptr = null ();
	return;

     end close_mail_table;

lock_mail_table:
     proc ();

	dcl     code		fixed bin (35);

	mail_table_locked = "1"b;
	code = 0;
	call set_lock_$lock (mail_table_header.write_lock, LOCK_WAIT_TIME, code);
	if code ^= 0 then
	     if code ^= error_table_$invalid_lock_reset then do;
		mail_table_locked = "0"b;
		call fatal_error (code);
	     end;
	if mail_table_header.write_count = BIG_NUMBER then
	     mail_table_header.write_count = 0;
	else mail_table_header.write_count = mail_table_header.write_count + 1;
	return;

     end lock_mail_table;

unlock_mail_table:
     proc ();

	dcl     code		fixed bin (35);

	if ^mail_table_locked then return;
	code = 0;
	call set_lock_$unlock (mail_table_header.write_lock, code);
	if code ^= 0 & code ^= error_table_$locked_by_other_process then call fatal_error (code);
	mail_table_locked = "0"b;
	return;

     end unlock_mail_table;

get_write_count:
     proc ();

	dcl     code		fixed bin (35);
	dcl     temp_lock		bit (36) aligned;

	original_time = clock ();
GET_COUNT_AGAIN:
	code = 0;
	original_write_count = mail_table_header.write_count;
	temp_lock = mail_table_header.write_lock;	/* We may not be able to modify the real lock */
	call set_lock_$lock (temp_lock, 0, code);
	if code ^= 0 then
	     if code = error_table_$lock_wait_time_exceeded then do;
						/* It was locked, so wait */
		if too_long () then call fatal_error (error_table_$lock_wait_time_exceeded);
		call timer_manager_$sleep (1, "11"b);	/* Sleep for 1 second */
		go to GET_COUNT_AGAIN;
	     end;
	     else if code ^= error_table_$invalid_lock_reset then call fatal_error (code);
	if mt_modified () then go to GET_COUNT_AGAIN;
	return;

     end get_write_count;

mt_modified:
     proc () returns (bit (1));

	if mail_table_header.write_count = original_write_count then return ("0"b);
	else if too_long () then			/* We've been trying for too long */
	     call fatal_error (error_table_$lock_wait_time_exceeded);
	else return ("1"b);

     end mt_modified;

too_long:
     proc () returns (bit (1));

	return (clock () - original_time > LOCK_WAIT_TIME * 1e6);

     end too_long;

make_new_entry:
     proc (P_id, P_real_mtep);

	dcl     P_id		char (*) varying;
	dcl     P_real_mtep		ptr;		/* Output -> real_mte */

	dcl     code		fixed bin (35);
	dcl     person_id		char (32);
	dcl     rmte_ptr		ptr;		/* -> new entry */

	code = 0;
	person_id = P_id;
	rmte_ptr = null ();
	call ms_table_mgr_$new_entry (mt_ptr, person_id, rmte_ptr, code);
	if code ^= 0 then call fatal_error (code);
	mail_table_header.entry_count = mail_table_header.entry_count + 1;
	P_real_mtep = rmte_ptr;
	return;

     end make_new_entry;

update_new_entry:
     procedure (P_real_mtep);

	dcl     P_real_mtep		ptr parameter;
	dcl     rmte_ptr		ptr;
	dcl     code		fixed bin (35);

	rmte_ptr = P_real_mtep;
	call ms_table_mgr_$update_entry (mt_ptr, rmte_ptr, code);
	if code ^= 0 then call fatal_error (code);
	P_real_mtep = null ();			/* Just to make sure no one updates without telling ms_table_mgr_ */
	return;
     end update_new_entry;

delete_real_mte:
     proc (P_real_mte);

	dcl     1 P_real_mte	aligned like real_mte;

	dcl     code		fixed bin (35);
	dcl     person_id		char (32);

	code = 0;
	person_id = P_real_mte.name;
	call ms_table_mgr_$delete_entry (mt_ptr, person_id, code);
	if code ^= 0 then call fatal_error (code);
	mail_table_header.entry_count = mail_table_header.entry_count - 1;
	return;

     end delete_real_mte;

retrieve_real_mte:
     proc (P_id, P_chase, P_case_ins, P_real_mtep);

	dcl     P_case_ins		bit (1) parameter;	/* Try case insensitive */
	dcl     P_chase		bit (1) parameter;	/* Chase alias links */
	dcl     P_id		char (*) varying parameter;
						/* Name of entry to retrieve */
	dcl     P_real_mtep		ptr parameter;	/* Output ptr to entry */
	dcl     code		fixed bin (35);
	dcl     name		char (32);
	dcl     person_id		char (32);	/* Non-varying name */
	dcl     1 rmte		aligned like real_mte based (rmtep);
	dcl     rmtep		ptr;

	code = 0;
	P_real_mtep = null ();
	person_id = P_id;
	call ms_table_mgr_$find_entry (mt_ptr, person_id, rmtep, NO_WRITE, ignore_rs, code);
	if code = error_table_$checksum_failure then code = 0;
	if code ^= 0 then
	     /*** Look for case insensitive match ***/
	     if P_case_ins & code = error_table_$id_not_found then do;
		code = 0;
		call ms_table_mgr_$find_entry_case_ins (mt_ptr, person_id, rmtep, NO_WRITE, ignore_rs, code);
		if code = error_table_$checksum_failure then code = 0;
		if code = error_table_$request_id_ambiguous then call fatal_error (mlsys_et_$ambiguous_address);
		if code ^= 0 then call fatal_error (code);
	     end;
	     else call fatal_error (code);
	if P_chase & rmte.alias_entry then do;
	     name = rmte.primary_name;
	     call ms_table_mgr_$find_entry (mt_ptr, name, rmtep, NO_WRITE, ignore_rs, code);
	     if code = error_table_$checksum_failure then code = 0;
	     if code ^= 0 then call fatal_error (code);
	end;
	P_real_mtep = rmtep;
	return;

     end retrieve_real_mte;

retrieve_real_mte_n:
     proc (P_index, P_real_mtep);

	dcl     P_index		fixed bin parameter;
	dcl     P_real_mtep		ptr parameter;

	dcl     index		fixed bin (35);
	dcl     rmtep		ptr;

	code = 0;
	P_real_mtep = null ();
	index = P_index;
	call ms_table_mgr_$abs_entry (mt_ptr, index, (""), NO_WRITE, rmtep, ignore_rs, code);
	if code ^= 0 then call fatal_error (code);
	P_real_mtep = rmtep;
	return;

     end retrieve_real_mte_n;

get_address:
     proc (P_mte, P_address);

	dcl     1 P_mte		aligned like real_mte;
	dcl     P_address		ptr;

	dcl     code		fixed bin (35);
	dcl     mail_system_$create_user_mailbox_address
				entry (char (*) var, char (*) var, char (*) var, ptr, fixed bin (35));
	dcl     mlsys_utils_$parse_address_text
				entry (char (*), ptr, fixed bin (35));

	code = 0;
	P_address = null ();
	if P_mte.registered_user & P_mte.mailing_address = "" then
	     call mail_system_$create_user_mailbox_address (P_mte.name || "." || P_mte.default_project, "", "",
		P_address, code);

	else call mlsys_utils_$parse_address_text ((P_mte.mailing_address), P_address, code);
	if code ^= 0 then call fatal_error (code);
	return;
     end get_address;

format_address:
     proc (P_address, P_string);

	dcl     P_address		ptr;
	dcl     P_string		char (*) varying;

	dcl     buffer		char (256);
	dcl     buffer_used		fixed bin (21);
	dcl     code		fixed bin (35);

	dcl     mlsys_utils_$format_address_field
				entry (char (*) var, ptr, fixed bin, ptr, fixed bin (21), fixed bin (21),
				fixed bin (35));

	code = 0;
	P_string = "";
	buffer_used = 0;
	call mlsys_utils_$format_address_field ("", P_address, -1, addr (buffer), length (buffer), buffer_used, code);
	if code = error_table_$smallarg then /* buffer is not large enough */ call fatal_error (error_table_$bigarg);
						/* means address is too big */
	if code ^= 0 then call fatal_error (code);
	P_string = substr (buffer, 1, buffer_used);
	return;
     end format_address;

check_acs_access:
     proc (P_path);

	dcl     1 P_path		aligned like mail_table_raw_entry.acs_path;
	dcl     hcs_$get_user_access_modes
				entry (char (*), char (*), char (*), fixed bin, bit (36) aligned,
				bit (36) aligned, fixed bin (35));
	dcl     code		fixed bin (35);
	dcl     modes		bit (36) aligned;

	code = 0;
	if P_path.dir = "" then call fatal_error (error_table_$insufficient_access);
						/* Noone has access to nonexistent ACS */
	call hcs_$get_user_access_modes ((P_path.dir), (P_path.entry), "", initial_ring, modes, (""b), code);
	if code ^= 0 | bool (modes, RW_ACCESS, "0100"b) then call fatal_error (error_table_$insufficient_access);
	return;

     end check_acs_access;

check_mtep:
     proc (P_mtep);

	dcl     P_mtep		ptr parameter;

	if P_mtep = null () then call fatal_error (error_table_$null_info_ptr);
	if P_mtep -> mail_table_entry.version ^= MAIL_TABLE_ENTRY_VERSION_1 then
	     call fatal_error (error_table_$unimplemented_version);
	return;

     end check_mtep;

check_mtrep:
     proc (P_mtrep);

	dcl     P_mtrep		ptr parameter;

	if P_mtrep = null () then call fatal_error (error_table_$null_info_ptr);
	if P_mtrep -> mail_table_raw_entry.version ^= MAIL_TABLE_RAW_ENTRY_VERSION_1 then
	     call fatal_error (error_table_$unimplemented_version);
	if P_mtrep -> mail_table_raw_entry.mbz ^= ""b /* MUST be zero */ then
	     call fatal_error (error_table_$bad_subr_arg);
	return;

     end check_mtrep;

set_mail_table_acl:
     proc ();

	dcl     code		fixed bin (35);
	dcl     fcb_ptr		ptr;
	dcl     1 mt_acl		aligned like segment_acl_entry;
	dcl     msf_manager_$open	entry (char (*), char (*), ptr, fixed bin (35));
	dcl     msf_manager_$close	entry (ptr);
	dcl     msf_manager_$acl_replace
				entry (ptr, ptr, fixed bin, bit (1), fixed bin (35));

	fcb_ptr = null ();
	code = 0;
	on cleanup
	     begin;
		if fcb_ptr ^= null () then call msf_manager_$close (fcb_ptr);
	     end;
	call msf_manager_$open (MAIL_TABLE_DIR, MAIL_TABLE_NAME, fcb_ptr, code);
	if code ^= 0 then call fatal_create_error (code);
	mt_acl.access_name = "*.*.*";
	mt_acl.mode = RW_ACCESS;
	mt_acl.extended_mode = ""b;
	mt_acl.status_code = 0;
	call msf_manager_$acl_replace (fcb_ptr, addr (mt_acl), 1, "1"b, code);
	if code ^= 0 & code ^= error_table_$argerr then call fatal_create_error (code);
	if mt_acl.status_code ^= 0 then call fatal_create_error (mt_acl.status_code);
	call msf_manager_$close (fcb_ptr);
	return;

     end set_mail_table_acl;

     end mail_table_mgr_;
