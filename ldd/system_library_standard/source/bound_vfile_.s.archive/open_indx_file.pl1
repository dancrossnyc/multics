/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1990   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */






/****^  HISTORY COMMENTS:
  1) change(90-10-12,Zimmerman), approve(90-10-12,MCR8216),
     audit(90-10-15,Zwick), install(90-10-16,MR12.4-1043):
     Data_Mgt 63 (phx21194): Raise the max number of components in an MSF to
     1250.
                                                   END HISTORY COMMENTS */




/* The initial design and implementation of this program was by M. D. MacLaren (1974) */
/* All extensions, optimizations, and bug fixes since 1975 designed and implemented by M. Asherman */
/* The above was true up through 1978.  Major modifications have been made by Jim Paradise prior to the first listed modification.
   Modified:
   05/31/79  by  Lindsey L. Spratt; fix "delete" bug by correcting a check seeing if the key
   associated with branch_num is the same as the key in automatic storage.( a tip of the hat to
   Chris D. Tavares for figuring out this fix)
   Also, added code to check for improperly converted files, since check_file_version
   was not doing the comp_table reformatting it should have been doing.
   Modified by Jim Paradise on January 16, 1980 to correctly handle
   modifiers of stationary records; problems due to interaction
   of tp code and redefinition meaning of stationary header variable: modifier
   04/29/80 by Jim Paradise to add fix to select/exclude logic to not try to
   free at times there is not anything to free in returned descrip list,
   Found and fix provided by Jim Gray.
   Modified by Jim Paradise on June 27, 1980 to fix a performance bug, when inserting
   duplicate keys search for them on the right.  Based on
   the fix provided by Ed Brunnell.
   12/18/80  by  Lindsey L. Spratt: add the ability to delete old subsets from
   the "subset" vfile built for holding the results of selection and exclusion.
   This also involved adding a new bit to the common_sl_info structure,
   common_sl_info.delete_old_subsets.
06/29/81 by Lindsey Spratt: Changed to use the iocb.incl.pl1 include file
	  instead of the (now obsolete) iocbv.incl.pl1 include file.  This
	  required explicitly qualifying with a locator value (iocb_ptr) all
	  references to elements of the iocb structure.  Also, moved
	  (nearly) all include files to the end of the source.
01/20/82 by Lindsey Spratt:  Changed rewrite_indx_file entry point to only
            reference the "current" node when indx_cb.outside_index is off.
            This was causing a null pointer fault when no valid position had
            established (e.g., the only kind of positioning done since the 
            opening of the file was via the record_status control order.)
01/21/82 by Lindsey Spratt:  Changed the declaration of the error_info structure
            from fixed to fixed bin (35).  There was a size mis-match between
            indx_cb.requested (fixed bin(34)) and error_info.requested (fixed 
            bin(17)).
03/31/82 by Lindsey Spratt: Changed close_indx_file to re-initialize the
	  file_state pointers (fs_ptr, o_s_ptr, os_ptr, and
	  indx_cb.file_state_ptr) when entered. (vfile bug 23.)
04/05/82 by Lindsey Spratt: Changed the select control order to not allocate a
	  descriptor array when the caller's selection gets an
	  error_table_$no_record (i.e., when flag = select_flag, and
	  indx_cb.subset_selected = "00"b, indicating that no selection has
	  taken place).  This is checked in get_subset_status.
*/
/* format: style2,ind3 */
open_indx_file:
   proc (iocb_ptr, fcb_ptr_arg, first_seg_ptr, is_new_file, mode_arg, close_x, first_seg_bitcount, component_size_arg,
      code);

      go to open_file;

init_down_up:					/* prologue for ops which must first lock file */
      indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
      passive = "0"b;
      go to init_body;
init_up_down:					/* prologue for semi-passive operations */
      indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
      passive = indx_cb.stat;				/* lock file first if non-stationary */
      go to init_body;
initialize:					/* prologue for all passive index operations */
      indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
      passive = "1"b;				/* will never lock on this operation */
init_body:
      code = 0;
      cleanup_flags = "000000"b;			/* nothing locked */
      if ^indx_cb.shared				/* unshared opening */
      then
         do;
	  saved_state.shared = "0"b;
	  timeout = 0;
	  go to retry_loc (current_retry_loc);		/* back to mainline with handler established */
         end;
      saved_state_block = current_state_block;		/* for cleanup */
						/* continue initialization for a shared operation */
      pos_ptr = file_position_ptr;
      f_b_ptr = file_base_ptr;
      fs_ptr = indx_cb.file_state_ptr;
      if indx_cb.wait_time < 0			/* will wait indefinitely */
      then timeout = eternity;			/* may wait forever */
      else timeout = clock () + indx_cb.wait_time;	/* microseconds */
      on cleanup call restore_abort;
      if current_retry_loc = rs_retry_2
      then go to retry_loc (rs_retry_2);
      if leave_locked				/* file left locked by me */
      then go to retry_loc (current_retry_loc);
      if ^passive
      then
         do;					/* insist on first locking the file */
	  call lock_file_check;
	  go to retry_loc (current_retry_loc);
         end;
      fault_ok = "0"b;				/* set when possible asynch file change errors should be handled */

      on any_other
         begin;					/* asynch change handler */
	  if fault_ok				/* fault may be due to asynch change to the file */
	  then
	     do;					/* see if this is the case */
	        fault_ok = "0"b;			/* suppress recursive any_other handling */
	        call find_condition_info_ (null, addr (cond_info), er_code);
						/* gets condition name */
	        if asynch_change_condition (cond_name)	/* OK to handle */
	        then if iocb_ptr -> iocb.open_data_ptr -> indx_cb.file_base_ptr -> file_base.change_count
		      ^= iocb_ptr -> iocb.open_data_ptr -> indx_cb.last_change_count
						/* file has changed--note indx_cb_ptr may not be valid now */
		   then go to try_again;		/* reattempt operation or abort */
	        fault_ok = "1"b;			/* pass on this fault, but resume handling others */
	     end;
	  call continue_to_signal_ (er_code);		/* quit or file not changed--must be an error */

asynch_change_condition:
   proc (cond_name) returns (bit (1) aligned);		/*
						   returns "1"b if condition may have arisen from asynch file change */
      if length (cond_name) > length ("simfault_")
      then if substr (cond_name, 1, length ("simfault_")) = "simfault_"
	 then return ("1"b);
      if cond_name = "sub_err_"
      then if sub_err_info.name = "vfile_"
	 then return ("1"b);			/* OK to handle vfile_'s own sub_err_ only */
	 else return ("0"b);

      do i = 1 to num_conds;				/* check each possible condition known */
         if cond_name = as_cond_names (i)		/* match */
         then return ("1"b);
      end;					/* try each name in loop */

      return ("0"b);				/* not a condition which should be handled */

      dcl	    1 sub_err_info	       based (cond_info.infop),
	      2 pad	       (70),
	      2 name	       char (32);
      dcl	    cond_name	       char (32) var;
      dcl	    i		       fixed;
      dcl	    num_conds	       static internal fixed options (constant) init (21);
      dcl	    as_cond_names	       (1:21) static options (constant) char (32) var internal
			       init ("fault_tag_1", "fault_tag_3", "fixedoverflow", "illegal_modifier",
			       "linkage_error", "lockup", "no_execute_permission", "no_read_permission",
			       "no_write_permission", "not_in_read_bracket", "not_in_write_bracket",
			       "out_of_bounds", "overflow", "seg_fault_error", "size", "storage", "stringrange",
			       "stringsize", "subscriptrange", "truncation", "underflow");
   end asynch_change_condition;

	  dcl	find_condition_info_   entry (ptr, ptr, fixed (35));
	  dcl	1 cond_info	   aligned,
		  2 words1	   (3) fixed,
		  2 cond_name	   char (32) var,	/* all that interests us */
		  2 infop		   ptr,
		  2 words2	   (12) fixed init ((12) 0);
	  dcl	er_code		   fixed (35);
         end;					/* end of any_other handler */

      call prepare_process;
      go to retry_loc (current_retry_loc);		/* end of initialization pseudo-proc */

try_again:					/* reattempt a passive operation if time enough */
      indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
      call restore_state;
      call prepare_process;				/* may wait on file lock */
      go to retry_loc (current_retry_loc);		/* back to mainline */

verify_done:
      if indx_cb.shared
      then if cleanup_flags ^= "000000"b		/* not passive */
	 then go to unlock_exit;			/* don't leave things locked */
	 else
	    do;
	       call save_correct_pos;
	       if ^indx_cb.leave_locked
	       then
		do;				/* verify a passive operation */
		   if indx_cb.last_change_count = file_base.change_count
						/* file unchanged during operation */
		   then return;			/* result is therefore verified--done */
		   call restore_state;		/* resets process vars to their former values */
		   if clock () > timeout		/* time limit exhausted */
		   then
		      do;				/* abort */
		         code = error_table_$file_busy;
		         return;
		      end;
		   call prepare_process;
		   go to retry_loc (current_retry_loc);
		end;
	    end;
      return;					/* external exit */

passive_abort:
      indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
      if saved_state.shared				/* state has been saved */
      then call restore_state;
      return;

/* seek_key routine for openings with mode keyed_sequential_output */
seek_key_ks_out:
   entry (iocb_ptr, key, rec_len, code);
      current_retry_loc = seek_kso_retry;
      go to initialize;
retry_loc (1):
      if indx_cb.pos_incorrect
      then
         do;					/* position correctly to end of file */
	  call position_eof;
	  indx_cb.pos_incorrect = "0"b;
         end;
      else
         do;
	  pos_ptr = file_position_ptr;
	  indx_cb.outside_index = "0"b;		/* current pos moves into index */
	  branch_num = last_branch_num;
	  call set_at_eof;				/* sets indx_cb vars */
         end;
      indx_cb.new_key = key;				/* save key for insertion */
      call compare_last_key (indx_cb.new_key);		/* sets code and key_is_dup */
      if code = 0					/* indx_cb.new_key larger than last key in file */
      then
         do;
	  code = error_table_$no_record;
	  indx_cb.ready_to_write = "1"b;
         end;
      else indx_cb.ready_to_write = (key_is_dup & dup_ok);	/* write will succeed if
						   key exists and duplications are allowed */
      go to verify_done;				/* end seek_key for keyed sequential output */

seek_key_indx_file:
   entry (iocb_ptr, key, rec_len, code);
      current_retry_loc = seek_retry;
      go to initialize;
retry_loc (2):
      indx_cb.at_bof, indx_cb.at_eof = "0"b;
      file_position_ptr = root_position_ptr;
      indx_cb.outside_index = "0"b;
      indx_cb.skip_state = 0;				/* revert to forward scanning over deletions */
      call find_key (indx_cb_ptr, (addr (key)), search_code);
						/* 2nd arg is destroyed */
      pos_ptr = file_position_ptr;
      indx_cb.pos_incorrect = "0"b;			/* Now set file position and code */
      if search_code = 0				/* means not found */
      then code = error_table_$no_record;
      else
         do;					/* try to get ptr and len */
	  call find_from_leaf;			/* in case match was in upper node */
	  indx_cb.current_descrip = record_designator (branch_num);
	  call set_next_reclp_seek (block_ptr, lock_ptr); /* sets ptr and length */
						/* limits scanning to entries for this key */
						/* also sets the code to indicate failure */
         end;					/* either len is known or error code set */
      if (code = 0) | (code ^= error_table_$no_record)
      then
         do;					/* set position indicators and recl arg */
	  rec_len = record_len;
	  indx_cb.current_record_is_valid = "1"b;
	  indx_cb.next_record_position = 1;
	  indx_cb.ready_to_write = dup_ok;
         end;
      else
         do;					/* set indicators for unsuccessful seek */
	  rec_len = 0;
	  indx_cb.current_record_is_valid = "0"b;
	  indx_cb.next_record_position = 0;
	  if ^is_read_only
	  then
	     do;
	        indx_cb.ready_to_write = "1"b;
	        indx_cb.new_key = key;
	     end;
         end;
      go to verify_done;				/* end of seek_key routine */

      dcl	    search_code	       fixed (35);

read_length_indx_file:
   entry (iocb_ptr, rec_len, code);
      current_retry_loc = read_len_retry;
      go to initialize;
retry_loc (3):
      call find_next_record;
      if code = 0					/* next record exists */
      then
         do;					/* get its length */
	  call set_next_reclp (block_ptr, lock_ptr);
	  rec_len = record_len;
         end;
      go to verify_done;				/* end of read_length routine */

read_key_indx_file:
   entry (iocb_ptr, key, rec_len, code);
      current_retry_loc = read_key_retry;
      go to initialize;
retry_loc (4):
      call find_next_record;
      if code = 0					/* next position exists */
      then
         do;
	  call set_next_reclp (block_ptr, lock_ptr);
	  rec_len = record_len;
	  len = get_key_length ();
	  if len > 0
	  then key = substr (keys, key_pos (branch_num), len);
	  else key = "";
         end;
      go to verify_done;				/* end of read_key routine */

read_indx_file:
   entry (iocb_ptr, buff_ptr, buff_len, rec_len, code);
      current_retry_loc = read_retry;
      go to initialize;
retry_loc (5):
      call find_next_record;
      if code = 0					/* next position exists */
      then
         do;
	  call set_next_reclp_and_contents (block_ptr, lock_ptr);
	  rec_len = record_len;
	  if is_sequential_open & ((code = 0) | ((code ^= error_table_$end_of_info) & (code ^= error_table_$no_record)))
	  then indx_cb.next_record_position = 2;	/* next record follows that just read */
	  else indx_cb.next_record_position = 0;
         end;
      go to verify_done;				/* end of read routine */

position_indx_file:
   entry (iocb_ptr, pos_type, skip, code);
      if pos_type = 0
      then
         do;
	  current_retry_loc = skip_retry;
	  saved_error_info = iocb_ptr -> iocb.open_data_ptr -> indx_cb.error;
	  go to initialize;
retry_loc (6):
	  if indx_cb.next_record_position = 0		/* position may be undefined */
	  then
	     do;
	        call find_next_record;		/* sets position indicators */
	        if code ^= 0			/* really is an error */
	        then return;
	     end;
	  indx_cb.outside_index = "0"b;		/* current pos moves back into index */
	  if pos_incorrect
	  then
	     do;
	        call restore_position;
	        if code ^= 0
	        then go to verify_done;
	     end;
	  else pos_ptr = file_position_ptr;
	  indx_cb.at_bof, indx_cb.at_eof = "0"b;
	  indx_cb.skip_state = 0;
	  if skip >= 0				/* forward skip */
	  then
	     do;
	        count = skip + indx_cb.next_record_position - 1;
	        indx_cb.current_record_is_valid, indx_cb.ready_to_write = "0"b;

	        do while (count > 0);			/* advance until count zero or eof reached */
		 branches_left = last_branch_num - branch_num;
						/* branches in current node */
		 if branches_left > 0
		 then if (indx_cb.subset_selected = "00"b) & (branch (branch_num) = 0)
						/* leaf node */
		      then
		         do;			/* skip over a chunk of branches in one node */
			  chunk_size = min (count, branches_left);
						/* as many as possible */
			  branch_num = branch_num + chunk_size;
						/* will be last if more to skip */
			  count = count - chunk_size; /* remainder to be skipped */
		         end;
		      else
		         do;			/*  skip one from upper to leaf */
			  if indx_cb.subset_selected ^= "00"b
			  then
			     do;			/* see if this entry is being masked */
			        call check_subset (record_designator (branch_num));
			        if ^rec_deleted	/* this one counts */
			        then count = count - 1;
			     end;
			  else count = count - 1;	/* none are being masked */
			  branch_num = branch_num + 1;/* next non-leaf branch */
			  call find_leftmost_descendent;
		         end;
		 else
		    do;				/* move to entry from last branch in a node */
		       call find_this_entry;
		       if pos_ptr = root_position_ptr	/* at end of file */
		       then
			do;
			   count = -count;		/* causes exit from loop */
			   code = error_table_$end_of_info;
			end;
		    end;
	        end;

	        if code ^= 0			/* attempted to pass eof */
	        then
		 do;
		    call position_eof;		/* set position properly */
		    indx_cb.error.type = skip_error;	/* error -- attempt to pass end of file on position skip */
		    indx_cb.error.requested = skip;	/* number of skips specified in call */
		    indx_cb.error.received = skip + count;
						/* number of records actually skipped */
		 end;
	        else indx_cb.next_record_position = 1;
	     end;					/* end of forward skip case */
	  else
	     do;					/* backward skip */
	        count = 1 - skip - indx_cb.next_record_position;

	        do while (count > 0);
		 if count = 1
		 then
		    do;				/* backspace by a single branch */
back_1:
		       call find_prev_entry;		/* handles exceptions */
		       if branch_num = 1		/* beginning of file */
		       then
			do;
			   code = error_table_$end_of_info;
			   count = -count;		/* causes exit from loop */
			end;
		       else
			do;
			   branch_num = branch_num - 1;
			   if indx_cb.subset_selected ^= "00"b
			   then
			      do;
			         call check_subset (record_designator (branch_num));
			         if ^rec_deleted
			         then count = count - 1;
			      end;
			   else count = count - 1;
			end;
		    end;
		 else if branch_num > 1		/* not at first branch in node */
		 then if (indx_cb.subset_selected = "00"b) & (branch (branch_num) = 0)
		      then
		         do;			/* skip over a bunch of leaf branches */
			  chunk_size = min (count, branch_num - 1);
			  count = count - chunk_size;
			  branch_num = branch_num - chunk_size;
						/* does the backspacing */
		         end;
		      else go to back_1;
		 else go to back_1;
	        end;

	        if code ^= 0
	        then
		 do;				/* set position properly and save error info */
		    call position_bof;
		    indx_cb.error.type = skip_error;
		    indx_cb.error.requested = skip;
		    indx_cb.error.received = skip - count;
						/* actual number successfully skipped */
		 end;
	        else
		 do;
		    indx_cb.next_record_position = 1;
		    indx_cb.current_record_is_valid = "1"b;
		    indx_cb.ready_to_write = dup_ok;
		    indx_cb.skip_state = -1;		/* causes reverse scanning over deleted records */
		 end;
	     end;					/* end of backward skip case */
         end;					/* end of position skip case */
      else if abs (pos_type) = 1			/* valid type */
      then
         do;
	  current_retry_loc = pos_bof_or_eof_retry;
	  go to initialize;
retry_loc (7):
	  if pos_type = 1
	  then call position_eof;
	  else call position_bof;
	  indx_cb.outside_index = "0"b;
	  pos_incorrect = "0"b;
         end;
      else
         do;
	  code = error_table_$bad_arg;
	  return;
         end;
      go to verify_done;				/* end of position routine */

control_indx_file:
   entry (iocb_ptr, order, info_ptr_arg, code);
      info_ptr = info_ptr_arg;
      code = 0;

      if order = "get_key"
      then
         do;
	  current_retry_loc = gk_retry;
	  go to initialize;
retry_loc (8):					/* first validate arguments in info structure */
	  if ^gk_inf.input_key & (gk_inf.current = "1"b) & (gk_inf.input_desc)
	  then
	     do;
	        code = error_table_$bad_arg;
	        go to exit;				/* abort */
	     end;
	  if (gk_inf.current & ^gk_inf.input_key) | (^gk_inf.input_desc & (gk_inf.desc_code = 1))
						/* current position required */
	  then
	     do;
	        call check_current;
	        if code ^= 0
	        then go to verify_done;		/* abort--no current position */
	        if ^gk_inf.input_key & gk_inf.current	/* current key required */
	        then if indx_cb.outside_index		/* no current key is defined */
		   then
		      do;
		         code = error_table_$no_key;
		         gk_inf.descrip = indx_cb.current_descrip;
		         gk_inf.key_len = 0;
		         go to verify_done;		/* abort this operation */
		      end;
	        if gk_inf.reset_pos & (^indx_cb.shared | ^saved_state.current_record_is_valid)
	        then
		 do;
		    saved_state.skip_state = indx_cb.skip_state;
		    call save_correct_pos;
		 end;
	     end;
	  else if gk_inf.reset_pos & ^indx_cb.shared
	  then
	     do;
	        saved_state.skip_state = indx_cb.skip_state;
	        call save_correct_pos;
	     end;
	  if ^gk_inf.input_key			/* current or next position */
	  then if gk_inf.current			/* current position */
	       then if indx_cb.subset_selected ^= "00"b	/* must see if this record is being masked */
		  then
		     do;
		        call check_subset (indx_cb.current_descrip);
		        if rec_deleted
		        then code = error_table_$no_record;
		     end;
		  else ;				/* just set gk_info and return now */
	       else
		do;				/* find next entry, possibly scanning over unwanted descriptors */
		   if pos_incorrect
		   then
		      do;
		         call restore_position;
		         if code ^= 0
		         then go to verify_done;
		      end;
		   else pos_ptr = indx_cb.file_position_ptr;
		   if indx_cb.next_record_position = 1
		   then if branch_num < last_branch_num
		        then go to next_found;
		        else ;			/* will have to handle special case */
		   else if indx_cb.next_record_position = 2
		   then branch_num = branch_num + 1;
		   else
		      do;
		         code = error_table_$no_record;
		         go to next_found;		/* abort */
		      end;
		   call find_this_entry;
		   if pos_ptr = root_position_ptr	/* eof */
		   then
		      do;
		         code = error_table_$end_of_info;
		         if ^gk_inf.reset_pos
		         then call position_eof;
		      end;
next_found:
		   if code = 0
		   then
		      do;
		         pad_key_ptr = addr (indx_cb.new_key);
						/* in case previous seek_head applies */
		         call gk_scan;		/* find valid entry by scanning if necessary */
		      end;
		end;
	  else
	     do;					/* seek to proper location in index */
	        pad_key_ptr = addr (gk_pad_key);
	        pad_key_len = 256;			/* must pad with 0's for proper seek */
	        len = min (fixed (gk_inf.head_size), gk_inf.key_len);
	        unspec (substr (pad_key, len + 1, 256 - len)) = "0"b;
						/* pad with 0's */
	        substr (pad_key, 1, len) = substr (gk_inf.key, 1, len);
	        indx_cb.pos_incorrect = "0"b;
	        call seek_head ((gk_inf.rel_type), addr (pad_key_info), (fixed (gk_inf.head_size)));
	        if pos_ptr = root_position_ptr		/* no luck */
	        then
		 do;
		    if ^gk_inf.reset_pos
		    then indx_cb.at_bof, indx_cb.at_eof = "0"b;
		    code = error_table_$no_key;
		 end;
	        else
		 do;
		    if gk_inf.rel_type = 0
		    then indx_cb.skip_state = fixed (gk_inf.head_size);
						/* indicates scanning after head match */
		    else indx_cb.skip_state = 0;	/* just scan forward */
		    call gk_scan;			/* finds satisfactory descriptor */
		    if ^indx_cb.shared & ^gk_inf.reset_pos
		    then call save_correct_pos;	/* in case of scan */
		 end;
	     end;
	  if code = 0
	  then
	     do;
	        gk_inf.key_len = get_key_length ();
	        gk_inf.key = substr (keys, key_pos (branch_num), key_length (branch_num));
	        gk_inf.descrip = record_designator (branch_num);
	        if ^gk_inf.reset_pos			/* leave position here */
	        then
		 do;
		    indx_cb.ready_to_write = indx_cb.dup_ok;
		    indx_cb.outside_index, indx_cb.at_eof, indx_cb.at_bof = "0"b;
		    indx_cb.current_record_is_valid = "1"b;
		    indx_cb.next_record_position = 1;
		 end;
	        else
		 do;
		    indx_cb.skip_state = saved_state.skip_state;
		    indx_cb.pos_incorrect = "1"b;
		 end;
	     end;
	  else if ^gk_inf.reset_pos			/* leave next position undefined */
	  then
	     do;
	        indx_cb.ready_to_write, indx_cb.current_record_is_valid, indx_cb.outside_index = "0"b;
	        if ^(indx_cb.at_bof | indx_cb.at_eof)
	        then indx_cb.next_record_position = 0;
	     end;
	  else
	     do;
	        indx_cb.skip_state = saved_state.skip_state;
	        indx_cb.pos_incorrect = "1"b;
	     end;
	  go to verify_done;
         end;

      indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
      code = 0;

      if order = "record_status"
      then
         do;
	  call check_rs_args;			/* aborts on error */
	  if code ^= 0				/* fatal error detected by arg checking */
	  then return;				/* abort--don't bother looking at file */
	  current_retry_loc = rs_retry_1;
	  if indx_cb.shared
	  then if ^passive_op & (^indx_cb.stat | rs_info.create_sw)
						/* first must lock file */
	       then go to init_down_up;
	       else if ^(indx_cb.outside_index | rs_info.locate_sw)
	       then go to initialize;
	       else
		do;				/* get file's change count, but synch at record level */
		   current_retry_loc = rs_retry_2;
		   go to initialize;
retry_loc (9):
		   new_change_count = file_base.change_count;
		   if new_change_count ^= indx_cb.last_change_count
						/* asynch change */
		   then
		      do;				/* bring process vars up to date */
		         call initialize_ptrs;
		         indx_cb.pos_incorrect = "1"b;
		         indx_cb.last_change_count = new_change_count;
		      end;			/* open data consistent with last change count now */
		end;				/* file level verification will occur if non-stationary */
	  else go to init_up_down;
retry_loc (10):
	  call record_status;			/* may create rec or alter lock, as well as returning info
						   and setting current current record pos outside index */
	  if rs_info.unlock_sw & ^rs_info.lock_sw	/* explicit unlocking without locking */
	  then if code = 0
	       then code = error_table_$lock_not_locked;	/* complain if not already locked by me */
	       else if code = error_table_$locked_by_this_process
						/* expected */
	       then
		do;
		   i_locked_rec = "1"b;		/* cause unlocking to be done */
		   code = 0;
		end;
	  if ^passive_op				/* file modification */
	  then go to unlock_exit;			/* unlock after shared file alteration */
	  else if rs_info.unlock_sw
	  then go to unlock_exit;			/* unlock the record only */
	  else if ^indx_cb.outside_index		/* file level synchronization */
	  then go to verify_done;			/* will re-attempt operation if asynch changes detected */
	  else if block_ptr ^= null
	  then if ^block_ptr -> record_block.stationary	/* non-stationary */
	       then go to verify_done;		/* may have to retry to get snapshot */
	  return;					/* may have already made external exit */
         end;					/* record_status proc does external exit */

      if order = "seek_head"
      then if is_sequential_open & ^is_ks_out & (mode > 7 /* keyed */)
	 then
	    do;					/* won't be no_operation */
	       if (info.rel_type < 0) | (info.rel_type > 2) | (n < 0)
	       then
		do;				/* bag arg--abort */
		   code = error_table_$bad_arg;
		   return;
		end;
	       else
		do;
		   current_retry_loc = sh_retry;
		   go to initialize;
retry_loc (11):
		   indx_cb.at_bof, indx_cb.at_eof = "0"b;
		   indx_cb.outside_index = "0"b;
		   pad_key_ptr = addr (indx_cb.new_key);
		   pad_key_len = 256;
		   unspec (substr (pad_key, n + 1, 256 - n)) = "0"b;
						/* pad with zeroes, not blanks */
		   substr (pad_key, 1, n) = search_key;
		   call seek_head (info.rel_type, addr (pad_key_info), info.n);
		   if pos_ptr = indx_cb.root_position_ptr
						/* not found */
		   then code = error_table_$no_record;
		   if code = 0
		   then
		      do;
		         if indx_cb.dup_ok
		         then indx_cb.ready_to_write = "1"b;
		         else indx_cb.ready_to_write = "0"b;
		         indx_cb.current_record_is_valid = "1"b;
		         indx_cb.next_record_position = 1;
		         if info.rel_type = 0		/* exact match was required */
		         then indx_cb.skip_state = n;	/* will only scan while head condition is met */
		         else indx_cb.skip_state = 0;	/* any subsequent entry will do on detection of deletion */
		         if indx_cb.subset_selected ^= "00"b
						/* select or exclude in effect */
		         then call sh_scan;		/* scan for entry in the current subset */
		      end;
		   else
		      do;
		         indx_cb.ready_to_write = "0"b;
		         indx_cb.current_record_is_valid = "0"b;
		         indx_cb.next_record_position = 0;
		      end;
		   pos_incorrect = "0"b;
		   go to verify_done;		/* will save key if shared */
		end;
	    end;

      if ^is_read_only				/* must have modify access */
      then
         do;
	  if (order = "add_key")
	  then go to add_key;

	  else if (order = "delete_key")
	  then go to delete_key;			/* does the work */

	  else if (order = "reassign_key")
	  then go to reassign_key;
         end;

      if order = "select"
      then go to select;

      if order = "exclude"
      then go to exclude;

      if order = "error_status"
      then
         do;
	  if error_info.version ^= 1
	  then code = error_table_$bad_arg;
	  else
	     do;
	        error_info.type = indx_cb.error.type;
	        error_info.requested = indx_cb.error.requested;
	        error_info.received = indx_cb.error.received;
	     end;
	  return;
         end;

      if order = "min_block_size"
      then
         do;
	  indx_cb.min_res = max (0, mbs_info.min_residue);
	  indx_cb.min_cap = max (0, mbs_info.min_capacity);
	  return;
         end;

      if indx_cb.shared
      then
         do;
	  if (order = "set_wait_time")
	  then
	     do;					/* change setting of max wait time */
	        if new_wait_time = -2			/* collection delay version */
	        then if wt_info.collection_delay_time < 0
		   then code = error_table_$bad_arg;
		   else indx_cb.collection_delay_time = 1000000 * wt_info.collection_delay_time;
	        else if new_wait_time < -1
	        then code = error_table_$bad_arg;
	        else indx_cb.wait_time = 1000000 * new_wait_time;
	        return;				/* that's all there is to it */
	     end;

	  if (order = "set_file_lock") & ^indx_cb.is_read_only
	  then
	     do;					/* attempt to lock or unlock the file */
	        if info_ptr -> set_lock_flag		/* wants to set the lock */
	        then if indx_cb.leave_locked
		   then code = error_table_$locked_by_this_process;
		   else
		      do;				/* lock and restore process vars */
		         current_retry_loc = lock_file_retry;
		         go to init_down_up;		/* setup handler */
retry_loc (24):
		         if set_lock_info.exclusive
		         then file_action = read_exclude;
						/* stops readers */
		         indx_cb.read_exclu = info_ptr -> exclusive;
		         indx_cb.leave_locked = "1"b;	/* remember locked */
		      end;
	        else if ^indx_cb.leave_locked
	        then
		 do;
		    code = error_table_$lock_not_locked;
		    if indx_cb.file_base_ptr -> file_base.lock_word = indx_cb.saved_lock_copy
						/* my lock */
		    then call check_code (code, "File lock set by another opening in this
process.  This opening can't clear the lock.  Either
unlock from the opening that locked, of force unlocking
with the vfile_adjust command.");
		 end;
	        else
		 do;				/* OK to unlock */
		    saved_state_block = current_state_block;
		    cleanup_flags = "100000"b;	/* OK to unlock file */
		    on cleanup call restore_abort;
		    leave_locked = "0"b;		/* remember I unlocked */
		    f_b_ptr = file_base_ptr;
		    pos_ptr = file_position_ptr;
		    fs_ptr = indx_cb.file_state_ptr;
		    if file_action = read_exclude
		    then file_action = 0;		/* clear read lock */
		    indx_cb.read_exclu = "0"b;
		    go to unlock_exit;		/* sets last_change_count */
		 end;
	        return;				/* finished with operation */
	     end;
         end;

      if order = "file_status"
      then
         do;
	  call vfile_status_$seg (iocb_ptr, file_base_ptr, info_ptr, code);
	  return;
         end;

      if order = "io_call"
      then
         do;
	  call vfile_io_control (iocb_ptr, file_base_ptr, info_ptr, code);
	  return;					/* work done on recursive call */
         end;

      if order = "io_call_af"
      then
         do;
	  call vfile_io_control$af (iocb_ptr, file_base_ptr, info_ptr, code);
	  return;					/* return from call for active function */
         end;

      code = error_table_$no_operation;
      return;					/* end of control routine */

get_ptr:
   proc (designator_arg) returns (ptr);
      return (addr (seg_ptr_array (des_arg.comp_num) -> seg_array (fixed (des_arg.offset))));
      dcl	    designator_arg	       fixed (35);
      dcl	    1 des_arg	       like designator_struct aligned based (addr (designator_arg));
   end;

lock_current_record:
   proc (block_ptr, lock_ptr, i_locked_mask, ref_count_change);
						/* non-passive, non-scanning */
						/* delete_record suppresses cleanup by setting input_only flag */
      if indx_cb.repeating				/* recovery in progress */
      then
         do;					/* reconstruct pointers */
	  f_b_ptr = indx_cb.file_base_ptr;
	  fs_ptr = indx_cb.file_state_ptr;
	  block_ptr = get_pointer (indx_cb.current_descrip);
	  lock_ptr = null;
	  cleanup_flags = cleanup_flags | (i_locked_mask & rec_lock_mask);
	  if file_base.was_stat			/* record may have been stationary type */
	  then
	     do;					/* get correct lock_ptr */
	        if (file_action = reassigning_key)	/* maybe non-stat */
	        then if ^block_ptr -> record_block.stationary
		   then return;			/* suppress unlocking */
	        lock_ptr = addr (block_ptr -> stat_struct.record_lock);
	     end;
	  return;
         end;
      passive = "0"b;
      scan = "0"b;					/* treats logical deletion as error without scanning */
      go to get_reclp;				/* main body of record access synch routine */
set_next_reclp_and_contents:				/* for read_record op */
set_next_reclp_seek:				/* passive with restricted
						   scanning, i.e. scanning of duplicate keys matching seek arg */
set_next_reclp:
   entry (block_ptr, lock_ptr);			/* passive with scanning */
      passive = "1"b;				/* never modify via this entry */
      scan = "1"b;					/* means scan over absent entries, if found */
      go to get_reclp;
set_current_reclp:
   entry (block_ptr, lock_ptr);			/* passive, non-scanning */
      passive = "1"b;
      scan = "0"b;					/* will not scan if record is logically absent */
get_reclp:
      code = 0;
      block_ptr = null;				/* loop condition */
      lock_ptr = null;
      record_ptr = null;
      record_len = 0;
      max_rec_wds = 0;				/* allocated block size minus header size */
      ref_cnt = 0;					/* reference count--stationary records only */

      do while (block_ptr = null);			/* may loop over logically absent records */
         if indx_cb.subset_selected ^= "00"b		/* may be masked */
         then call check_subset (indx_cb.current_descrip);	/* sets rec_deleted flag */
						/* will know whether or not to clean up by nullness of block_ptr */
         else rec_deleted = "0"b;			/* entry not masked so far */
         if ^rec_deleted				/* OK to look for allocation */
         then
	  do;					/* look at the record block allocation */
	     if indx_cb.current_descrip <= 0		/* no allocation possible for this descriptor */
	     then
	        do;				/* check for error and return */
		 if ^passive			/* only attempt to lock may regard as an error */
		 then if indx_cb.trans
		      then code = error_table_$no_room_for_lock;
						/* must support null descriptor special case */
		 return;				/* nothing more to do in this routine */
	        end;				/* will exit loop with non-null block_ptr */
	     if indx_cb.shared & ^indx_cb.leave_locked & ^i_locked_file & ^indx_cb.outside_index
						/* possible asynch file change errors */
	     then if indx_cb.last_change_count ^= file_base.change_count
						/* asynch change
						   has occurred--descriptor may not be valid--reobtain */
		then go to verify_done;		/* will abort if no time left */
	     block_ptr = get_pointer (indx_cb.current_descrip);
						/* ptr to block header */
	     if block_ptr = null			/* should never happer */
	     then call check_code (error_table_$no_record, "Can't obtain record pointer--reason unknown.");
	     if ^block_ptr -> record_block.stationary	/* non-stationary record */
	     then call inspect_non_stat_rec;		/* gets lock ptr if room */
	     else call inspect_stat_record;		/* sees if logically deleted */
	  end;					/* rec_deleted flag set if logically absent */
         if rec_deleted				/* user can't see this entry */
         then
	  do;					/* see if OK to scan and/or garbage-collect */
	     call mask_entry;			/* OK to scan if returned code = 0 */
						/* no refl entry required, since deletion is irreversible */
						/* until index changes supported under TP, however, there is still
						   the reversible deletion of pre-created records to be considered */
	     if code ^= 0				/* can't scan--just return with error */
	     then return;				/* abort */
						/* otherwise block_ptr will necessarily be null */
	  end;					/* fall through case scans next entry */
      end;					/* scan over logically masked or deleted entries */

      return;					/* end of main get_reclp routine */

mask_entry:
   proc;						/* takes care of scanning and cleanup */
						/* returns either with a non-zero code or null block_ptr */
      if ^scan					/* don't scan--return no_record error */
      then
         do;					/* still may clean up one entry, though */
	  if ^indx_cb.is_read_only & indx_cb.stat & (block_ptr ^= null)
						/* OK to collect */
	  then
	     do;
	        if indx_cb.outside_index
	        then if (ref_cnt > 0) | passive		/* nothing can be collected now */
		   then
		      do;				/* return immediately */
		         code = error_table_$no_record;
		         return;
		      end;
		   else threshold = 0;		/* garbage collection threshold */
	        else threshold = 1;			/* can delete one key along with the record */
	        call collect_item;			/* may delete key and/or record */
	     end;
	  code = error_table_$no_record;		/* warn user record is absent */
	  return;					/* done with non-scanning case */
         end;
      if block_ptr ^= null				/* may have to clean up */
      then
         do;					/* end up with null block_ptr */
	  if ^indx_cb.is_read_only & indx_cb.stat	/* may collect item */
	  then
	     do;
	        threshold = 1;			/* only delete key for larger ref counts */
	        call collect_item;
	        indx_cb.outside_index = "0"b;		/* in case only the key was deleted */
	     end;
	  else if indx_cb.skip_state >= 0
	  then indx_cb.next_record_position = 2;
	  block_ptr = null;				/* allow scanning to continue if final code is zero */
	  lock_ptr = null;
         end;
      else if indx_cb.skip_state >= 0
      then indx_cb.next_record_position = 2;		/* advance */
      if (indx_cb.skip_state < 0)			/* scan backwards */
      then if indx_cb.next_record_position = 2		/* staggerred next and current */
	 then
	    do;					/* reset next to current--must exist */
	       indx_cb.next_record_position = 1;
	       indx_cb.current_descrip = record_designator (branch_num);
	       code = 0;				/* clear any old code */
	       return;				/* backward scan continues successfully */
	    end;
	 else call backspace;			/* also sets code */
      else call find_next_record;			/* scan forward--also sets code */
      if code = 0					/* did not run into either end of file */
      then
         do;					/* see if code must be set */
	  if current_retry_loc = seek_retry
	  then if key = substr (keys, key_pos (branch_num), get_key_length ())
	       then return;				/* OK to check this entry--key matches */
	       else ;				/* fall through complains about no_record error */
	  else if indx_cb.skip_state > 0		/* follows seek_head */
	  then if substr (indx_cb.new_key, 1, indx_cb.skip_state)
		= substr (keys, key_pos (branch_num), min (get_key_length (), indx_cb.skip_state))
						/* head still matches that of prior seek_head */
	       then return;				/* OK to continue search for record with this descrip */
	       else ;				/* fall through and complain */
	  else return;				/* previous entry obtained without eof error */
	  code = error_table_$no_record;		/* complain */
         end;					/* fall through resets skip state */
      else if (current_retry_loc = seek_retry) /* called by seek_key */ & (code = error_table_$end_of_info)
      then code = error_table_$no_record;		/* suitable code */
						/* unable to continue scanning, although permitted */
      indx_cb.skip_state = 0;				/* resume normal scanning forward */
      return;					/* done masking one entry */

collect_item:
   proc;						/* garbage collection routine */
      if indx_cb.trans
      then if (mod > 0) & (mod = current_t_code)		/* locked by this transaction */
	 then go to handle_pos;			/* don't garbage collect yet */
      if cur_mod = -3				/* special case--means creation in progress */
      then
         do;
	  call get_lock_status (lock_ptr, er_code);
	  if er_code ^= error_table_$lock_is_invalid
	  then go to handle_pos;			/* maybe skip over this entry */
         end;
      if ref_cnt <= threshold				/* record can be removed */
						/* ref count obtained in set_current_image_info logic */
      then if indx_cb.shared
	 then if time_stamp + indx_cb.collection_delay_time > clock ()
	      then go to handle_pos;			/* just skip over entry if scanning */
      if indx_cb.shared
      then indx_cb.shared = ^indx_cb.leave_locked & ^i_locked_file;
      else saved_state.skip_state = indx_cb.skip_state;
      indx_cb.is_sequential_open = "1"b;
      if ref_cnt <= threshold				/* OK to dispose of stationary header */
      then call delete_indx_file (iocb_ptr, er_code);
      else call control_indx_file (iocb_ptr, "delete_key", null, er_code);
      if indx_cb.mode < 11
      then indx_cb.is_sequential_open = "1"b;
      else indx_cb.is_sequential_open = "0"b;
      indx_cb.skip_state = saved_state.skip_state;
      indx_cb.shared = saved_state.shared;
      pos_ptr = indx_cb.file_position_ptr;		/* because of intervening external vfile_ calls */
      return;					/* item collected */
handle_pos:
      if scan & (indx_cb.skip_state >= 0)
      then indx_cb.next_record_position = 2;		/* skip over entry */
      dcl	    er_code	       fixed (35);
   end collect_item;

      dcl	    threshold	       fixed (34);
   end mask_entry;

inspect_non_stat_rec:
   proc;						/* examines a non-stationary record */
      blksz = block_ptr -> record_block.block_size;
      max_rec_wds = blksz - 2;
      if (blksz > divide (length (block_ptr -> record_block.record) + 11, 4, 19, 0))
      then lock_ptr = addr (block_ptr -> non_stat_struct.record_lock);
						/* room for lock at tail of block */
      else lock_ptr = null;				/* no room for separate record lock */
      if indx_cb.trans				/* transaction mode--error--record must be stationary */
      then code = error_table_$no_room_for_lock;		/* rec header too small */
      else if lock_ptr = null				/* can't touch lock */
      then if passive
	 then if block_ptr -> record_block.lock_flag
	      then call get_lock_status (addr (file_base_ptr -> file_base.lock_word), code);
	      else code = 0;
	 else code = 0;				/* no lock to set--treat as successful */
      else if ^passive				/* wants to lock--file must first be locked */
      then if indx_cb.shared & ^indx_cb.leave_locked & ^i_locked_file
						/* I haven't locked */
	 then
	    do;					/* file must first be locked to lock non-stat record */
	       call lock_file_check;			/* may adjust the file */
						/* aborts if file busy or unrecoverable */
	       go to retry_loc (current_retry_loc);	/* try again with file locked */
	    end;					/* never lock non-stationary record without first locking file */
	 else
	    do;					/* try to lock the record */
	       call compute_time_left;
	       if ^(lock_ptr -> based_lock = indx_cb.saved_lock_copy)
	       then cleanup_flags = cleanup_flags | (i_locked_mask & rec_lock_mask);
	       call set_lock (lock_ptr, time_left, code); /* really shouldn't
						   wait with file locked in all cases */
	       if code ^= 0				/* lock was set */
	       then if (code = error_table_$locked_by_this_process) | (code = error_table_$invalid_lock_reset)
						/* not fatal */
		  then if ^block_ptr -> record_block.lock_flag
						/* record is valid */
		       then
			do;
			   code = 0;
			   cleanup_flags = cleanup_flags | (i_locked_mask & rec_lock_mask);
			end;
		       else ;			/* locking was complete */
		  else if code = error_table_$lock_wait_time_exceeded
		  then code = error_table_$record_busy; /* appropriate code */
	    end;					/* done with locking attempt */
      else if block_ptr -> record_block.lock_flag		/* may be busy */
      then call get_lock_status (lock_ptr, code);		/* sets code without locking */
      else code = 0;				/* contents must be valid */
      record_ptr = addr (block_ptr -> record_block.record);
      record_len = length (record_ptr -> based_vstring);
      if current_retry_loc = read_retry			/* contents also wanted */
      then call return_contents;
      dcl	    blksz		       fixed (19);
   end inspect_non_stat_rec;

inspect_stat_record:
   proc;						/* looks at a stationary record */
      lock_ptr = addr (block_ptr -> stat_struct.record_lock);
      if passive					/* just obtaining status--not locking */
      then
         do while ("1"b);				/* loop for asynch changes */
keep_loopin:
	  call get_current_image_info;
	  if code ^= 0				/* fatal error at this point */
	  then if code ^= error_table_$higher_inconsistency
	       then return;				/* abort immediately */
	       else
		do;				/* maybe waiting will help */
		   call get_lock_status (lock_ptr, code);
		   if code ^= error_table_$record_busy	/* not other
						   live process--no point waiting */
		   then
		      do;
		         code = error_table_$higher_inconsistency;
		         return;			/* warn user that he can't get valid image */
		      end;
		   mics_left = timeout - clock ();
		   if mics_left <= 0		/* no time to wait */
		   then return;
		   call timer_manager_$sleep (min (50000, mics_left), "10"b);
		   code = 0;			/* set up for another try */
		   go to keep_loopin;
		end;
	  if ind_desc = -1				/* logically deleted */
	  then
	     do;					/* return immediately */
	        rec_deleted = "1"b;
	        if cur_mod ^= -3			/* still must take care or ref list */
	        then return;			/* may continue scanning */
	     end;
	  else if ind_desc = -2			/* means that before image applies */
	  then if block_ptr -> record_block.indirect
	       then ind_desc = block_ptr -> ind_struct.prev_desc;
	       else ind_desc = indx_cb.current_descrip;	/* compact case */
	  if mod = 0				/* may need lock status to warn user */
	  then if block_ptr -> record_block.lock_flag
	       then call get_lock_status (lock_ptr, code);
	  if indx_cb.shared & indx_cb.trans /* reference within a transaction */
	     & ((code = 0) | (code = error_table_$locked_by_this_process) | (code = error_table_$lock_is_invalid))
	  then
	     do;					/* take care of reference list */
	        if current_t_code = 0			/* no transaction number assigned yet */
	        then call get_t_code;			/* assigns a code or aborts if unable */
	        if (mod ^= current_t_code)		/* not already locked by this transaction */
	        then call set_ref_list_entry (block_ptr); /* detects invalid prior ref */
	     end;
	  call set_stat_reclp;			/* ptr to stationary rec contents */
	  if current_retry_loc = read_retry
	  then call return_contents;
	  if fixed (time_stamp_struct.time_last_modified) = time_stamp
	  then return;
	  if clock () > timeout
	  then
	     do;
	        code = error_table_$record_busy;
	        return;
	     end;
         end;					/* loop until record snapshot passively obtained */
      else
         do;					/* lock the record and look at its header */
reattempt:					/* retry point for post-adjustment case */
	  call compute_time_left;
	  if ^(lock_ptr -> based_lock = indx_cb.saved_lock_copy)
	  then cleanup_flags = cleanup_flags | (i_locked_mask & rec_lock_mask);
	  call set_lock (lock_ptr, time_left, code);
	  er_code = code;				/* save returned code giving lock status */
	  call get_current_image_info;
	  if code ^= 0				/* lock was non-zero */
	  then if code = error_table_$higher_inconsistency
	       then
		do;
		   if er_code = error_table_$locked_by_this_process
		   then code = error_table_$record_busy;/* suppress attempt to unlock record */
		   else if stacq (lock_ptr -> based_lock, (36)"1"b, indx_cb.saved_lock_copy)
		   then ;				/* invalidate the lock again */
		   return;			/* abort--fatal error */
		end;
	       else if code = error_table_$lock_wait_time_exceeded
	       then
		do;				/* abort with suitable code */
		   code = error_table_$record_busy;
		   return;
		end;
	       else if mod = 0			/* see if warning required */
	       then if block_ptr -> record_block.lock_flag
		  then ;				/* leave code non-zero as a warning */
		  else
		     do;
		        code = 0;
		        cleanup_flags = cleanup_flags | (i_locked_mask & rec_lock_mask);
						/* permit unlocking */
		     end;
	       else if code = error_table_$locked_by_this_process
	       then if ^(indx_cb.trans)
		  then
		     do;				/* abort with suitable code */
		        code = error_table_$record_busy;/* fatal error */
		        return;			/* not locked by own transaction */
		     end;
		  else if (mod = current_t_code)
		  then code = 0;			/* suppress warning--already locked by this trans */
		  else
		     do;				/* abort with suitable code */
		        code = error_table_$record_busy;/* fatal error */
		        return;			/* not locked by own transaction */
		     end;
	       else
		do;				/* adjust record left locked by dead process */
		   call adjust_record (iocb_ptr, indx_cb.current_descrip, cur_mod, code);
		   call check_code (code, "Can't adjust a record locked by dead process.");
		   go to reattempt;			/* adjustment ends by unlocking--do again */
		end;
	  if ind_desc = -1				/* logically deleted record */
	  then if cur_mod = -3			/* new record this transaction */
	       then if mod = 0			/* this operation is creating */
		  then ind_desc = indx_cb.current_descrip;
		  else rec_deleted = "1"b;
	       else
		do;				/* not a pre-creation case */
		   rec_deleted = "1"b;
		   if block_ptr -> stat_struct.modifier = 0
		   then
		      do;				/* mark vfile_ operation in progress */
		         cleanup_flags = cleanup_flags | (i_locked_mask & negmod_mask);
						/* set bit indicating modifier set */
		         block_ptr -> stat_struct.modifier = -1;
		      end;
		   go to adjust_ref_count;		/* suppress ref list manipulation */
		end;
	  if indx_cb.trans				/* modification inside a transaction */
	  then
	     do;
	        if current_t_code = 0
	        then call get_t_code;
	        if mod ^= current_t_code		/* not already locked by this transaction */
	        then
		 do;				/* take care of ref list */
		    if block_ptr -> stat_struct.prev_mod = -3
						/* new record */
		    then call add_lock_list_entry (block_ptr, cleanup_flags & passive_ref_bit_mask);
						/* no need to verify this reference */
		    else
		       do;
			call set_lock_list_entry (block_ptr, cleanup_flags & passive_ref_bit_mask);
						/* check for prior passive ref */
			if (code ^= 0) & (code ^= error_table_$locked_by_this_process)
			   & (code ^= error_table_$invalid_lock_reset)
						/* fatal error */
			then return;		/* abort */
			block_ptr -> stat_struct.ind_comp = -1;
			time_stamp_struct.ind_offset = (17)"1"b;
						/* after descrip= -2 */
			block_ptr -> stat_struct.ref_count_after = ref_cnt;
						/* indicates after image initially same as before--special case */
		       end;
		    block_ptr -> stat_struct.modifier = current_t_code;
		    call set_stat_reclp;
		    ind_desc = -2;
		 end;
	        else if ind_desc = -2			/* before image applies */
	        then
		 do;
		    if block_ptr -> record_block.indirect
		    then ind_desc = block_ptr -> ind_struct.prev_desc;
		    else ind_desc = indx_cb.current_descrip;
		    call set_stat_reclp;
		    ind_desc = -2;
		 end;
	        else call set_stat_reclp;
	     end;
	  else
	     do;					/* initialize header for non-TP modification */
	        cleanup_flags = cleanup_flags | (i_locked_mask & negmod_mask);
						/* leave record locked but still need to zero modifier */
	        block_ptr -> stat_struct.modifier = -1;	/* non-TP operation in progress */
	        call set_stat_reclp;
	     end;
adjust_ref_count:
	  if ref_count_change < 0			/* decrementing */
	  then
	     do;					/* check lower limit constraint */
	        if rec_deleted			/* logically absent */
	        then min_ref_count = 0;		/* zero references permitted--can clean up */
	        else min_ref_count = 1;		/* not deleted--at least one ref must remain */
	        if ref_cnt + ref_count_change < min_ref_count
	        then
		 do;				/* abort */
		    code = error_table_$last_reference;
		    return;			/* suppress changing ref count below minimum */
		 end;
	     end;
	  else if ref_cnt + ref_count_change > max_ref_count
	  then
	     do;
	        code = error_table_$too_many_refs;
	        return;
	     end;
	  ref_cnt = ref_cnt + ref_count_change;
	  if rec_deleted & ^is_read_only & (ref_count_change ^= 0) & (block_ptr -> stat_struct.modifier = -1)
						/* record_status ref_count
						   change on a deleted record */
	  then
	     do;
	        block_ptr -> stat_struct.ref_count_after = ref_cnt;
	        block_ptr -> stat_struct.ref_count = ref_cnt;
	     end;					/* permits garbage collection of unkeyed records */
         end;					/* lock is now set */
      return;					/* end of main stat rec inspection routine */

get_current_image_info:
   proc;						/* same as set_current_image_info, except
						   that it checks for the case of an item that may have already been modified by this transaction */
      mod = block_ptr -> stat_struct.modifier;
      if (mod <= 0) | ^indx_cb.trans
      then call set_current_image_info;
      else if (mod = current_t_code)			/* own transaction */
      then
         do;					/* get after image info */
	  time_stamp = fixed (time_stamp_struct.time_last_modified);
	  cur_mod = mod;
	  ind_des.comp = stat_struct.ind_comp;
	  ind_des.offset = time_stamp_struct.ind_offset;
	  ref_cnt = stat_struct.ref_count_after;
         end;
      else call set_current_image_info;			/* handle any other case but own transaction */
   end get_current_image_info;

set_stat_reclp:
   proc;
      if ind_desc > 0				/* record allocation exists */
      then
         do;
	  if ind_desc = indx_cb.current_descrip		/* compact case */
	  then
	     do;
	        max_rec_wds = block_ptr -> record_block.block_size - stat_header_size;
	        record_ptr = addr (block_ptr -> stat_struct.record);
	     end;
	  else
	     do;
	        p = get_pointer (ind_desc);
	        max_rec_wds = p -> record_block.block_size - 2;
	        record_ptr = addr (p -> record_block.record);
	     end;
	  record_len = length (record_ptr -> based_vstring);
         end;
      dcl	    p		       ptr;
   end set_stat_reclp;

      dcl	    er_code	       fixed (35);
      dcl	    min_ref_count	       fixed;
      dcl	    mics_left	       fixed (71);
   end inspect_stat_record;

return_contents:
   proc;						/* gets record contents for read_record */
      if record_len > 0
      then if record_len <= buff_len
	 then buffer = substr (record_ptr -> based_vstring, 1, record_len);
	 else
	    do;
	       if buff_len > 0
	       then substr (buffer, 1, buff_len) = substr (record_ptr -> based_vstring, 1, buff_len);
	       code = error_table_$long_record;
	    end;
   end return_contents;

get_t_code:
   proc;						/* initializes the current transaction */
      call transaction_call_$assign (indx_cb.tcfp, 0, er_code);
						/* creates
						   a unique tcf entry for this transaction */
      call check_code (er_code, "Unable to assign a transaction number to the current transaction.");
      dcl	    er_code	       fixed (35);
   end get_t_code;

get_lock_status:
   proc (lockp, er_code);
      lock_copy = lockp -> based_lock;
      call set_lock (addr (lock_copy), 0, er_code);
      if er_code = 0
      then return;
      if er_code = error_table_$lock_wait_time_exceeded
      then er_code = error_table_$record_busy;
      else if er_code = error_table_$invalid_lock_reset
      then er_code = error_table_$lock_is_invalid;
      dcl	    lockp		       ptr;
      dcl	    er_code	       fixed (35);
      dcl	    lock_copy	       bit (36) aligned;
   end get_lock_status;

%include set_current_image_info;
      dcl	    1 non_stat_struct      based (block_ptr),
	      2 words	       (record_block.block_size - 1),
	      2 record_lock	       bit (36) aligned;
      dcl	    scan		       bit (1) aligned;
      dcl	    passive	       bit (1) aligned;
      dcl	    ref_count_change       fixed;
      dcl	    (lock_ptr, block_ptr)  ptr;
      dcl	    i_locked_mask	       bit (36) aligned;
   end lock_current_record;

check_subset:
   proc (descrip);					/* sees if descriptor has been excluded */
      temp_cbp = indx_cb.temp_iocbp -> iocb.open_data_ptr;
      temp_cbp -> indx_cb.file_position_ptr = temp_cbp -> indx_cb.root_position_ptr;
      subset_key = current_subset_bytes || descrip_bytes;
      call find_key (temp_cbp, (addr (subset_key)), search_code);
      if indx_cb.subset_selected = "10"b
      then if search_code = 0
	 then rec_deleted = "1"b;
	 else rec_deleted = "0"b;
      else if search_code ^= 0
      then rec_deleted = "1"b;
      else rec_deleted = "0"b;			/* verbose form to avoid operator call */
      dcl	    descrip	       fixed (35);
      dcl	    descrip_bytes	       char (4) based (addr (descrip));
      dcl	    temp_cbp	       ptr;
      dcl	    current_subset_bytes   char (4) based (addr (indx_cb.current_subset));
      dcl	    search_code	       fixed (35);
      dcl	    subset_key	       char (8) var;
   end check_subset;

gk_scan:
   proc;						/* called by get_key to find satisfactory descriptor */
      if ^gk_inf.input_desc
      then if gk_inf.desc_code = 0
	 then desc_known = "0"b;
	 else desc_known = "1"b;
      else desc_known = "1"b;
      if desc_known
      then
         do;
	  if gk_inf.input_desc
	  then wanted_desc = gk_inf.descrip;
	  else wanted_desc = indx_cb.current_descrip;
	  if indx_cb.subset_selected ^= "00"b
	  then
	     do;
	        call check_subset (wanted_desc);
	        if rec_deleted
	        then
		 do;
		    if ^gk_inf.reset_pos
		    then indx_cb.at_bof, indx_cb.at_eof = "0"b;
		    go to norec;			/* logically absent record */
		 end;
	     end;
         end;
      else if indx_cb.subset_selected = "00"b		/* any entry will do */
      then return;					/* current position is satisfactory */
      reset_position = gk_inf.reset_pos;
      go to scan_loop;				/* skip setup code for seek_head scan */

sh_scan:
   entry;						/* handles scanning for seek_head */
      desc_known = "0"b;
      reset_position = "0"b;

scan_loop:
      do while ("1"b);
         descrip = record_designator (branch_num);
         if desc_known
         then if descrip = wanted_desc
	    then return;				/* desired descriptor found */
	    else ;				/* must keep looking--scan */
         else
	  do;
	     call check_subset (descrip);
	     if ^rec_deleted			/* not logically masked by current subset */
	     then
	        do;
		 if ^reset_position
		 then indx_cb.current_descrip = descrip;/* must be valid for check_current */
		 return;				/* done with scanning */
	        end;
	  end;
         if indx_cb.skip_state < 0			/* scanning backward */
         then
	  do;
	     call find_prev_entry;
	     if branch_num = 1			/* bof */
	     then
	        do;
		 if ^reset_position
		 then call position_bof;
norec:
		 code = error_table_$no_record;	/* abort */
		 indx_cb.skip_state = 0;		/* resume default forward scanning */
		 return;				/* stop scanning */
	        end;
	     branch_num = branch_num - 1;
	  end;
         else
	  do;
	     branch_num = branch_num + 1;		/* advance one index entry */
	     call find_this_entry;
	     if pos_ptr = indx_cb.root_position_ptr	/* eof */
	     then
	        do;
		 if ^reset_position
		 then call position_eof;
		 go to norec;
	        end;
	     if indx_cb.skip_state > 0
	     then if substr (keys, key_pos (branch_num), min (key_length (branch_num), indx_cb.skip_state))
		   > substr (pad_key, 1, indx_cb.skip_state)
						/* key out of range */
		then
		   do;
		      if ^reset_position
		      then
		         do;
			  indx_cb.next_record_position = 0;
			  indx_cb.current_record_is_valid = "0"b;
		         end;
		      go to norec;
		   end;
	  end;
      end;

      dcl	    desc_known	       bit (1) aligned;
      dcl	    (wanted_desc, descrip) fixed (35);
      dcl	    reset_position	       bit (1) aligned;
   end gk_scan;

find_next_record:
   proc;
      code = 0;
      if pos_incorrect				/* must restore index pos */
      then
         do;
	  call restore_position;
	  if code ^= 0
	  then return;				/* asynch deletion */
         end;
      else pos_ptr = file_position_ptr;
      indx_cb.ready_to_write = indx_cb.dup_ok;
      indx_cb.outside_index, indx_cb.at_eof, indx_cb.at_bof = "0"b;
						/* reset if outside */
      indx_cb.current_record_is_valid = "1"b;
      if indx_cb.next_record_position = 1
      then
         do;
	  if branch_num < last_branch_num
	  then go to set_current;
         end;
      else if indx_cb.next_record_position = 2
      then
         do;					/* next record follows current position */
	  branch_num = branch_num + 1;
	  indx_cb.next_record_position = 1;
         end;
      else
         do;					/* next record is undefined */
	  code = error_table_$no_record;
	  indx_cb.current_record_is_valid = "0"b;
	  indx_cb.ready_to_write = "0"b;
	  return;
         end;
      call find_this_entry;
      if pos_ptr = root_position_ptr			/* end of file */
      then
         do;
	  call position_eof;			/* set process info and position */
	  code = error_table_$end_of_info;
         end;
      else
         do;
set_current:
	  indx_cb.current_descrip = record_designator (branch_num);
         end;
   end find_next_record;

find_this_entry:
   proc;						/* routine gets position of following index proc */
      call find_leftmost_descendent;			/* in case we are not at a leaf */
find_from_leaf:
   entry;

loop:
      if branch_num = last_branch_num
      then if last_branch_num > 1
	 then
	    do;
	       pos_ptr = parent_position_ptr;
	       go to loop;
	    end;

      file_position_ptr = pos_ptr;
   end find_this_entry;

find_prev_entry:
   proc;						/* routine finds position of preceding index entry */
      call find_rightmost_descendent;			/* in case non-leaf */

loop:
      if branch_num = 1
      then if last_branch_num > 1
	 then
	    do;
	       pos_ptr = parent_position_ptr;		/* position moves to parent node */
	       go to loop;
	    end;

      file_position_ptr = pos_ptr;
   end find_prev_entry;

backspace:
   proc;						/* moves index position back one, setting code if end of info */
      code = 0;
      if indx_cb.pos_incorrect
      then
         do;
	  call restore_position;
	  if code ^= 0
	  then return;				/* asynch deletion */
         end;
      else pos_ptr = indx_cb.file_position_ptr;
      indx_cb.outside_index = "0"b;
      call find_prev_entry;
      if branch_num = 1				/* beginning of file */
      then
         do;
	  code = error_table_$end_of_info;
	  call position_bof;
	  return;
         end;
      branch_num = branch_num - 1;
      indx_cb.current_descrip = record_designator (branch_num);
   end backspace;

seek_head:
   proc (rel_type, key_ptr, head_len);
      indx_cb.file_position_ptr = indx_cb.root_position_ptr;/* prepare for descent */
      call find_key (indx_cb_ptr, (key_ptr), foo);
      pos_ptr = indx_cb.file_position_ptr;
      call find_from_leaf;				/* in case of match in upper node */

      do while (pos_ptr ^= root_position_ptr);
         if substr (key_ptr -> based_vstring, 1, head_len)
	  = substr (keys, key_pos (branch_num), min (key_length (branch_num), head_len))
						/* heads match */
         then if rel_type ^= 2			/* that's fine */
	    then return;				/* satisfactory entry found */
	    else
	       do;				/* keep searching forward */
		branch_num = branch_num + 1;
		call find_this_entry;		/* handles exceptional cases */
	       end;
         else if rel_type > 0				/* looking for larger head--fine */
         then return;				/* search done */
         else pos_ptr = root_position_ptr;		/* causes exit from loop */
      end;

      dcl	    rel_type	       fixed;
      dcl	    key_ptr	       ptr;
      dcl	    head_len	       fixed;
   end seek_head;

get_pointer:
   proc (descrip) returns (ptr);
      if descrip < 4096
      then return (null);
      if (desc.comp_num >= 0) & (desc.comp_num <= indx_cb.old_last_comp_num)
						/* in case shared and unlocked */
      then if seg_ptr_array (desc.comp_num) = null
	 then p = get_seg_ptr (iocb_ptr, (desc.comp_num));
	 else ;					/* fall through */
      else call check_code (error_table_$bad_arg, "Invalid msf component.");
      return (get_ptr (descrip));
      dcl	    p		       ptr;
      dcl	    descrip	       fixed (35);
      dcl	    1 desc	       aligned based (addr (descrip)),
	      2 comp_num	       fixed (17) unal,
	      2 offset	       bit (18) unal;
   end get_pointer;

get_key_length:
   proc returns (fixed);
      len = key_length (branch_num);
      if indx_cb.min_key_len <= 0			/* keys never padded with blanks */
      then return (len);
      if len = indx_cb.min_key_len
      then
         do;
	  tail_len = verify (reverse (substr (keys, key_pos (branch_num), len)), " ") - 1;
	  if tail_len < 0
	  then tail_len = len;
	  len = len - tail_len;
         end;
      return (len);

      dcl	    len		       fixed;
      dcl	    tail_len	       fixed;
   end;						/* end get_key_length */

compare_last_key:
   proc (key);					/* used to verify key order in kso openings */
      key_is_dup = "0"b;				/* will be set if user seeks last key in file */
      if last_branch_num > 1				/* file not empty */
      then if key <= substr (keys, key_pos (last_branch_num - 1), key_length (last_branch_num - 1))
	 then
	    do;					/* key not larger--maybe dup */
	       code = error_table_$key_order;
	       if key = substr (keys, key_pos (last_branch_num - 1), key_length (last_branch_num - 1))
	       then key_is_dup = "1"b;
	    end;
      dcl	    key		       char (256) var;
   end compare_last_key;

check_rs_args:
   proc;						/* routine validates args to the "record_status" order */
      rs_info_ptr = info_ptr;
      if (rs_info.version < rs_info_version_1) | (rs_info.version > rs_info_version_2)
						/* only versions currently supported */
      then code = error_table_$unimplemented_version;
      else if indx_cb.trans & rs_info.unlock_sw & ^rs_info.unlock_sw
						/* no unlocking under -trans */
      then code = error_table_$no_operation;
      else
         do;					/* keep checking */
						/* unlocking is treated passively, as far as synchronization is concerned */
	  passive_op = ^(rs_info.create_sw | rs_info.lock_sw | rs_info.inc_ref_count | rs_info.dec_ref_count);
	  if (^passive_op | rs_info.unlock_sw) & is_read_only
						/* need write access */
	  then code = error_table_$no_operation;
	  else
	     do;
	        if rs_info.create_sw
	        then if max (rs_info.max_rec_len, rs_info.record_length) > max_record_size
		   then code = error_table_$long_record;
		   else if indx_cb.subset_selected = "10"b
						/* pure selection in effect */
		   then code = error_table_$no_record;
		   else if rs_info.dec_ref_count & ^rs_info.inc_ref_count
		   then code = error_table_$last_reference;
						/* error--ref count too small */
		   else if ^rs_info.lock_sw
		   then if rs_info.unlock_sw
		        then code = error_table_$lock_not_locked;
		        else ;
		   else if ^indx_cb.shared
		   then if ^indx_cb.stat & ^rs_info.inc_ref_count & ^rs_info.dec_ref_count
		        then
			 do;
			    recl = max (0, rs_info.record_length);
			    capacity = max (min_max_rec_len, recl, rs_info.max_rec_len);
			    if rs_info.max_rec_len <= 0
			    then capacity = max (capacity, indx_cb.min_cap, recl + indx_cb.min_res);
			    if capacity - recl < 4
			    then code = error_table_$no_room_for_lock;
			 end;
		        else ;
		   else ;
	        else
		 do;				/* non-creation case */
		    if rs_info.locate_sw		/* descriptor is input arg */
		    then if (addr (rs_info.descriptor) -> rs_desc.comp_num <= 0)
						/* invalid component number */
		         then code = error_table_$no_record;
		         else /* use input descrip to set current record position */
			    call make_current (rs_info.descriptor);
		    if rs_info.inc_ref_count
		    then if rs_info.dec_ref_count
		         then delta_ref_count = 0;
		         else delta_ref_count = 1;
		    else if rs_info.dec_ref_count
		    then delta_ref_count = -1;
		    else delta_ref_count = 0;
		 end;
	     end;
         end;
      dcl	    (recl, capacity)       fixed (21);
   end check_rs_args;

record_status:
   proc;						/* routine supports record_status order except for arg checking */
      if rs_info.create_sw				/* create a new record */
      then
         do;
	  call initialize_substate;			/* prepare file state block */
	  file_base.new_record_length = max (rs_info.record_length, 0);
						/* save args for crash recovery */
	  if rs_info.max_rec_len > 0			/* override default min_block_size settings */
	  then
	     do;
	        file_base.saved_min_cap = max (rs_info.max_rec_len, min_max_rec_len);
	        file_base.saved_min_res = 0;
	     end;
	  else call save_min_blksz_inf;		/* in case of crash */
	  file_base.out_of_index = rs_info.locate_sw;
	  if rs_info.locate_sw & ^indx_cb.repeating	/* new rec won't be entered into index with key */
	  then call set_add_rec_stats;
	  else call set_add_ent_info ("1"b);		/* prepare to add index entry and new record */
	  file_base.old_ref_count =
	     fixed (rs_info.inc_ref_count) - fixed (rs_info.dec_ref_count) + fixed (^rs_info.locate_sw);
						/* initial ref count desired */
	  file_base.was_stat = indx_cb.stat | rs_info.inc_ref_count | rs_info.dec_ref_count;
	  file_action = adding_record;		/* necessary info saved, now alter file */
	  call change_record_list (iocb_ptr, insert_action, (null), abort_exit);
						/* create empty record */
	  file_base.change_count = file_base.old_file_ch_count + 1;
	  if rs_info.locate_sw			/* don't add index entry */
	  then call make_current (new_descriptor);	/* set current position to new record */
	  else
	     do;					/* place entry into the index */
	        indx_cb.current_descrip = new_descriptor;
	        call set_new_record_designator;
	        call change_index (iocb_ptr, abort_exit); /* does the work */
	        pos_ptr = file_position_ptr;
	        call set_post_write_pos;
	     end;
	  call lock_current_record (block_ptr, lock_ptr, i_locked_rec_mask, 0);
						/* no ref count change */
	  call set_rs_return_info;			/* fills in info structure */
	  if (code = 0) | (code = error_table_$locked_by_this_process) /* in case of recovery--can't hurt */
	     | (code = error_table_$invalid_lock_reset)
	  then if ^rs_info.lock_sw			/* nothing more to do */
	       then go to switch_file_state;
	       else if lock_ptr = null		/* small non-stationary allocation */
	       then code = error_table_$no_room_for_lock;
	       else if rs_info.unlock_sw		/* also immediately unlock--silly request when creating */
	       then go to switch_file_state;
	       else if indx_cb.trans			/* TP case--leave locked, but no need to set flag */
	       then go to switch_file_state;
	       else
		do;
		   block_ptr -> record_block.lock_flag = "1"b;
						/* warn others about image change */
		   i_locked_rec = "0"b;		/* suppress unlocking this record in unlock_exit */
		   go to switch_file_state;
		end;
	  aborting = "1"b;				/* unexpected error -- file will be adjusted later */
         end;					/* new record created and made current */
      else
         do;					/* non-creation case */
	  if ^rs_info.locate_sw
	  then
	     do;					/* make sure current record is defined */
	        call check_current;			/* may find next rec if not at current */
	        if code ^= 0			/* error--current record must be defined */
	        then return;
	     end;
	  if passive_op
	  then call set_current_reclp (block_ptr, lock_ptr);
	  else
	     do;					/* obtain record_ptr non-passively */
	        call lock_current_record (block_ptr, lock_ptr, i_locked_rec_mask, delta_ref_count);
						/* may wait up to wait time limit */
	        if (code = 0) | (code = error_table_$locked_by_this_process) | (code = error_table_$invalid_lock_reset)
						/* no fatal errors occurred */
	        then
		 do;
		    if rs_info.lock_sw & ^rs_info.unlock_sw
		    then if indx_cb.trans		/* transaction case */
		         then if ind_desc = -2	/* means first modification--after=before */
			    then
			       do;		/* initialize after image as copy of before */
				if indx_cb.shared
				then indx_cb.shared = ^indx_cb.leave_locked & ^i_locked_file;
				else saved_state.outside_index = indx_cb.outside_index;
				indx_cb.outside_index = "1"b;
						/* prevent rewrite from changing position */
				call rewrite_indx_file (iocb_ptr, addrel (record_ptr, 1), record_len, er_code);
						/* should have internal procedure for efficiency */
				indx_cb.outside_index = saved_state.outside_index;
						/* restore to prior state */
				indx_cb.shared = saved_state.shared;
				if er_code ^= 0
				then
				   do;
				      code = er_code;
				      call set_rs_return_info;
				      return;
				   end;
				ind_des.comp = stat_struct.ind_comp;
				ind_des.offset = time_stamp_struct.ind_offset;
				record_ptr = addrel (get_ptr (ind_desc), 1);
						/* comp must be known */
			       end;
			    else ;		/* already have initialized after image */
		         else if lock_ptr = null	/* allocation too small for lock in tail */
		         then code = error_table_$no_room_for_lock;
		         else
			  do;			/* just locking, non-TP case */
			     block_ptr -> record_block.lock_flag = "1"b;
						/* warn others */
			     if block_ptr -> record_block.stationary
						/* record has time_stamp */
			     then time_stamp_struct.time_last_modified = clock ();
			     else file_base_ptr -> file_base.change_count =
				   file_base_ptr -> file_base.change_count + 1;
			     i_locked_rec = "0"b;	/* suppress unlocking */
			  end;
		    if rs_info.inc_ref_count | rs_info.dec_ref_count
		    then if ^block_ptr -> record_block.stationary
		         then code = error_table_$no_room_for_lock;
						/* error really is that rec is non-stationary */
		         else if indx_cb.trans
		         then block_ptr -> stat_struct.ref_count_after = ref_cnt;
		         else block_ptr -> stat_struct.ref_count = ref_cnt;
		 end;
	     end;					/* pointer obtained non-passively */
	  call set_rs_return_info;
         end;					/* end of non-creation case logic */

set_rs_return_info:
   proc;						/* fills in user-supplied info structure */
      rs_info.record_length = record_len;
      rs_info.descriptor = indx_cb.current_descrip;
      if record_ptr = null				/* no record allocation */
      then
         do;
	  rs_info.record_ptr = null;
	  rs_info.max_rec_len = 0;
         end;
      else rs_info.record_ptr = addrel (record_ptr, 1);	/* point to contents,
						   not length word */
      if block_ptr ^= null				/* allocation exists */
      then
         do;					/* get info about block */
	  if block_ptr -> record_block.stationary
	  then
	     do;					/* give stationary record info */
	        rs_info.ref_count = ref_cnt;
	        if rs_info.version = rs_info_version_2	/* larger info structure than old one */
	        then
		 do;
		    rs_info.modifier = mod;
		    rs_info.time_last_modified = time_stamp;
		    rs_info.last_image_modifier = cur_mod;
		 end;
	     end;
	  if rs_info.version = rs_info_version_2	/* see comment above */
	  then rs_info.block_ptr = block_ptr;
	  rs_info.max_rec_len = 4 * max_rec_wds;
         end;
   end set_rs_return_info;

      dcl	    er_code	       fixed (35);
   end record_status;

save_correct_pos:
   proc;						/* routine remembers current info so positions can be restored */
      if ^indx_cb.pos_incorrect & (string (indx_cb.at_eof_or_bof) = "00"b) & ^(indx_cb.next_record_position = 0)
      then
         do;
	  pos_ptr = indx_cb.file_position_ptr;
	  if branch_num = last_branch_num		/* key may not exist */
	  then
	     do;
	        call find_this_entry;
	        if pos_ptr = root_position_ptr		/* at end of file */
	        then
		 do;				/* set position vars */
		    call set_at_eof;		/* no need to actually descend now */
		    indx_cb.current_record_is_valid = indx_cb.outside_index;
		    pos_incorrect = "1"b;
		    return;
		 end;
	     end;
	  indx_cb.new_key = substr (keys, key_pos (branch_num), key_length (branch_num));
	  indx_cb.saved_descrip = record_designator (branch_num);
         end;
   end save_correct_pos;

make_current:
   proc (descrip);					/* routine sets current pos outside index */
      indx_cb.ready_to_write = "0"b;
      indx_cb.current_descrip = descrip;
      indx_cb.outside_index = "1"b;			/* current record moves outside index */
      indx_cb.current_record_is_valid = "1"b;
      dcl	    descrip	       fixed (35);
   end make_current;

set_add_rec_stats:
   proc;						/* prepares statistics indicating successful creation of new record */
      if indx_cb.trans				/* transaction case */
      then return;					/* stats not changed until checkpoint */
      os_ptr -> number_of_records = number_of_records + 1;
      os_ptr -> total_record_length = total_record_length + new_record_length;
   end set_add_rec_stats;

prepare_process:
   proc;						/* used by passive shared operations to set up process vars
						   and wait for opportunity to look at file */
      if ^i_locked_file & ^leave_locked			/* unlocked between operations */
      then
         do;					/* check for asynch activity */
	  call check_file_lock;			/* waits till unlocked or time exhausted */
	  fault_ok = "1"b;				/* fault may reasonably occur because of asynch changes */
	  if last_change_count ^= new_change_count	/* asynch changes--restore process info */
	  then
	     do;
	        call initialize_ptrs;
	        pos_incorrect = "1"b;			/* will reseek before attempting index ref */
	        last_change_count = new_change_count;
	     end;
         end;
      else code = 0;
   end prepare_process;

check_file_lock:
   proc;						/* waits for lock to be clear until time left is exhausted */
      code = 0;
      if indx_cb.wait_time < 0			/* will wait indefinitely */
      then timeout = eternity;			/* may wait forever */
      else timeout = clock () + indx_cb.wait_time;	/* microseconds */

      do while (code = 0);				/* wait loop */
         new_change_count = change_count;		/* must save this before checking lock */
         fs_ptr = addr (file_state_blocks (file_state));
         if file_action = 0				/* not busy with alteration */
         then if new_change_count = change_count		/* in case state has flipped */
	    then return;
         lock_copy = file_base.lock_word;		/* copy the lock--can't alter file itself */
         call set_lock (addr (lock_copy), 0, code);
         if code = 0
         then return;				/* lock was clear */
         mics_left = timeout - clock ();
         if (code = error_table_$lock_wait_time_exceeded) /* really busy */ & (mics_left > 0)
						/* OK to wait longer */
         then
	  do;
	     call timer_manager_$sleep (min (50000, mics_left), "10"b);
						/* wait .05 seconds */
	     code = 0;
	  end;
         else if (code = error_table_$invalid_lock_reset) & ^indx_cb.is_read_only
         then call adjust_file (iocb_ptr, code);
         else code = error_table_$file_busy;
      end;					/* end of wait loop */

      go to exit;					/* abort */
      dcl	    mics_left	       fixed (71);
   end check_file_lock;

position_eof:
   proc;
      pos_ptr = root_position_ptr;
      call find_rightmost_descendent;
set_at_eof:
   entry;						/* avoids cost of descent when not needed */
      indx_cb.next_record_position = 1;
      indx_cb.ready_to_write = "0"b;
      indx_cb.current_record_is_valid = "0"b;
      indx_cb.at_eof = "1"b;				/* causes re-seek to eof if shared and asynch changes */
   end;

position_bof:
   proc;
      pos_ptr = root_position_ptr;
      call find_leftmost_descendent;
      indx_cb.next_record_position = 1;
      if last_branch_num > 1
      then indx_cb.current_record_is_valid = "1"b;
      else indx_cb.current_record_is_valid = "0"b;
      indx_cb.ready_to_write = indx_cb.current_record_is_valid & dup_ok;
      indx_cb.at_bof = "1"b;				/* shared re-seek will be to bof */
   end;

find_rightmost_descendent:
   proc;
      do while (branch (branch_num) ^= 0);
         son_position_ptr -> node = branch (branch_num);
         son_position_ptr -> node_ptr = get_ptr (branch (branch_num));
         pos_ptr = son_position_ptr;
         branch_num = last_branch_num;
      end;
      file_position_ptr = pos_ptr;
   end;						/* end find_rightmost_descendent */

find_leftmost_descendent:
   proc;
      do while (branch (branch_num) ^= 0);
         son_position_ptr -> node = branch (branch_num);
         son_position_ptr -> node_ptr = get_ptr (branch (branch_num));
         pos_ptr = son_position_ptr;
         branch_num = 1;
      end;
      file_position_ptr = pos_ptr;
   end;						/* end find_leftmost_descendent */

set_lock:
   proc (lockp, wtime, er_code);			/* internal equivalent of system set_lock_$lock */
      if stac (lockp, indx_cb.saved_lock_copy)		/* sets if zero */
      then er_code = 0;				/* done */
      else if lockp -> based_lock = indx_cb.saved_lock_copy
      then er_code = error_table_$locked_by_this_process;
      else call set_lock_$lock (lockp -> based_lock, wtime, er_code);
						/* must resort
						   to expensive call */
      dcl	    lockp		       ptr;
      dcl	    wtime		       fixed;
      dcl	    er_code	       fixed (35);
   end set_lock;

compute_time_left:
   proc;
(nosize):
      time_left = divide (fixed (timeout - clock () + 999999, 35, 0), 1000000, 17, 0);
   end compute_time_left;

lock_file_check:
   proc;						/* locks & re-seeks previously located position if file has changed */
      pos_ptr = file_position_ptr;
      f_b_ptr = file_base_ptr;
      fs_ptr = indx_cb.file_state_ptr;
      if indx_cb.leave_locked | i_locked_file		/* already locked */
      then return;					/* no need to lock again */
      fault_ok = "0"b;				/* no more asynch change errors allowed */
      call compute_time_left;
      if (file_base.lock_word = indx_cb.saved_lock_copy)
      then i_locked_file = "0"b;			/* this op is not first to lock */
      else i_locked_file = "1"b;			/* if lock becomes set, this op did it */
      call set_lock (addr (file_base.lock_word), time_left, er_code);
      if er_code ^= 0				/* lock was non-zero */
      then if er_code = error_table_$invalid_lock_reset
	 then er_code = 0;
	 else
	    do;					/* abort */
	       code = error_table_$file_busy;
	       indx_cb.state_vars = saved_state;	/* quick state restore */
	       go to unlock_exit;
	    end;
      if change_count ^= last_change_count
      then call initialize_ptrs;
      if (file_action ^= 0) & (file_action ^= read_exclude)
      then
         do;
	  call restart (iocb_ptr, er_code);		/* try to complete interrupted operation */
	  fs_ptr = indx_cb.file_state_ptr;
	  call check_code (er_code, "Unable to adjust a vfile_ operation in progress.");
         end;
      if change_count ^= last_change_count
      then pos_incorrect = "1"b;			/* will force re-seek if index is referenced */
      dcl	    er_code	       fixed (35);
   end lock_file_check;

initialize_substate:
   proc;						/* prepares recovery vars */
      f_b_ptr = file_base_ptr;
      if indx_cb.shared
      then call lock_file_check;
      fs_ptr = indx_cb.file_state_ptr;
      os_ptr = indx_cb.o_s_ptr;
      if repeating					/* recovery is in progress */
      then if file_substate = 0			/* died before finishing first block */
	 then repeating = "0"b;			/* switch to normal execution */
	 else next_substate = 0;			/* this count will keep track of recovery execution */
      else
         do;					/* normal execution */
	  file_substate = 0;			/* first block not yet completed */
	  file_base.old_file_ch_count = file_base.change_count;
	  file_base.was_transaction = indx_cb.trans;
	  os_ptr -> file_state_words = fs_ptr -> file_state_words;
	  if indx_cb.read_exclu			/* leave read lock set */
	  then os_ptr -> file_action = read_exclude;	/* locks out readers */
	  else os_ptr -> file_action = 0;
         end;
      dcl	    1 fsb		       based,		/* file state block */
	      2 word	       fixed,		/* file action slot */
	      2 file_state_words   (9) fixed;		/* avoids unused portion of fsb */
   end initialize_substate;

check_current:
   proc;						/* routine aborts if current record is undefined */
      pos_ptr = file_position_ptr;
      code = 0;
      if ^indx_cb.outside_index			/* current record located via index */
      then
         do;
	  if pos_incorrect
	  then
	     do;
	        call restore_position;
	        if code ^= 0
	        then return;
	     end;
	  if indx_cb.current_record_is_valid
	  then
	     do;
	        indx_cb.at_bof = "0"b;		/* reposition to record now that reference has occurred */
	        indx_cb.current_descrip = record_designator (branch_num);
	        return;
	     end;
	  else if indx_cb.next_record_position ^= 0
	  then
	     do;					/* current is next--find it */
	        call find_next_record;		/* detects eof */
	        if indx_cb.subset_selected ^= "00"b	/* may have to scan */
	        then if code = 0			/* index entry exists, but may be masked */
		   then call sh_scan;		/* does subset checking and scanning */
	     end;
         end;
      if ^indx_cb.current_record_is_valid
      then code = error_table_$no_record;
   end check_current;

save_min_blksz_inf:
   proc;						/* save info set by "min_block_size" order, in case
						   of crash while rewriting or inserting */
      file_base.saved_min_res = indx_cb.min_res;
      file_base.saved_min_cap = indx_cb.min_cap;
   end save_min_blksz_inf;

initialize_ptrs:
   proc;						/* resets process vars invalidated by asynch changes */
      if old_last_comp_num ^= last_comp_num
      then
         do;					/* recreate seg_ptr_array */
	  call free_seg_ptrs (iocb_ptr);
	  call create_seg_ptrs (iocb_ptr);
         end;
      else
         do;					/* these initialized by createseg_ptrs */
	  if old_rover_comp_num ^= rover_comp_num
	  then
	     do;					/* initialize rover */
	        rover_seg_ptr = get_seg_ptr (iocb_ptr, rover_comp_num);
	        old_rover_comp_num = rover_comp_num;
	     end;
	  index_state_ptr = addr (index_state_blocks (index_state));
         end;
      if old_index_height < index_state_ptr -> index_height /* no sweat if height decreases */
      then
         do;					/* recreate position stack */
	  call free_position_stack (indx_cb_ptr);
	  call create_position_stack (indx_cb_ptr);
	  pos_ptr = file_position_ptr;
         end;
      file_state_ptr = addr (file_state_blocks (file_state));
      fs_ptr = indx_cb.file_state_ptr;
      o_s_ptr = addr (file_state_blocks (1 - file_state));
      if ^indx_cb.dup_ok
      then if duplicate_keys ^= 0
	 then indx_cb.dup_ok = "1"b;
   end initialize_ptrs;

restore_position:
   proc;						/* re-establishes index position which may have become
						   invalid because of asynch changes */
      code = 0;
      if indx_cb.is_ks_out & indx_cb.ready_to_write	/* must keep track of key order constraint */
      then
         do;					/* position to end of file and test order */
	  file_position_ptr = root_position_ptr;	/* prepare for descent */
	  call find_rightmost_descendent;		/* end of file */
	  call compare_last_key (indx_cb.new_key);	/* sets code and key_is_dup */
	  if code ^= 0				/* not larger than last key in file */
	  then
	     do;
	        code = 0;				/* don't flag key_order error now */
	        if ^key_is_dup			/* no longer at last key */
	        then indx_cb.ready_to_write = "0"b;	/* asynch insertions leave indx_cb.new_key out of order */
	        else if ^dup_ok			/* key exists but no duplications allowed */
	        then
		 do;
		    indx_cb.ready_to_write = "0"b;	/* stop illegal duplications */
		    if indx_cb.at_eof		/* must have just done unsuccessful seek */
		    then code = error_table_$asynch_insertion;
						/* signal this error */
		 end;
	     end;
	  if indx_cb.at_eof				/* position fully restored and checked */
	  then return;				/* no more work necessary */
         end;					/* now indx_cb.ready_to_write reflects asynch changes if mode is kso */
      if indx_cb.at_bof
      then call position_bof;
      else if indx_cb.at_eof
      then call position_eof;
      else if ^dup_ok				/* no duplications allowed */
      then
         do;
	  file_position_ptr = root_position_ptr;
	  call find_key (indx_cb_ptr, (addr (indx_cb.new_key)), search_code);
	  pos_ptr = file_position_ptr;
	  if search_code ^= 0			/* key found */
	  then
	     do;
	        call find_from_leaf;
	        if indx_cb.ready_to_write		/* key should be absent */
	        then
		 do;
		    code = error_table_$asynch_insertion;
		    indx_cb.ready_to_write = "0"b;
		    indx_cb.current_record_is_valid = "1"b;
		    indx_cb.next_record_position = 1;
		 end;
	     end;
	  else
	     do;
as_del:
	        if (indx_cb.next_record_position ^= 0) | (indx_cb.current_record_is_valid & ^indx_cb.outside_index)
	        then
		 do;				/* previously located record has been deleted by another process */
		    code = error_table_$asynch_deletion;
		    indx_cb.ready_to_write = (^is_read_only & ^is_ks_out);
		    indx_cb.current_record_is_valid = "0"b;
		    indx_cb.next_record_position = 0;
		 end;
	     end;
         end;
      else
         do;
	  call find_entry (indx_cb.new_key, indx_cb.saved_descrip);
	  if search_code = 0			/* no asynch insertions when dup keys allowed */
	  then if first_code = 0			/* key not found */
	       then go to as_del;			/* check for possible asynch deletion */
	       else if indx_cb.stat			/* insist on same descriptor */
	       then go to as_del;
	       else
		do;				/* key was found, but not current descrip */
		   call find_prev_entry;		/* set pos to last matching key */
		   branch_num = branch_num - 1;	/* does the backspace */
		end;
         end;
      pos_incorrect = "0"b;				/* index position correctly restored */
   end restore_position;

find_entry:
   proc (key, descrip);				/* routine finds pos for given key and record descriptor */
      file_position_ptr = root_position_ptr;		/* search starts at base of index */
      call find_key (indx_cb_ptr, (addr (key)), search_code);
      pos_ptr = file_position_ptr;
      if search_code ^= 0				/* key found */
      then call find_from_leaf;			/* in case match is non-leaf */
      first_code = search_code;			/* will be non-zero if key was found */
      key_is_dup = "0"b;				/* will be set in loop if key is not unique */

      do while (search_code ^= 0);			/* advance until descrip is found or key changes */
         if record_designator (branch_num) = descrip	/* descrip found */
         then return;				/* done--position set properly */
         branch_num = branch_num + 1;			/* advance position */
         call find_this_entry;			/* takes care of exceptional cases */
         if pos_ptr = root_position_ptr			/* end of file */
         then search_code = 0;			/* stop searching */
         else if substr (keys, key_pos (branch_num), key_length (branch_num)) = key
         then key_is_dup = "1"b;
         else search_code = 0;			/* key has changed--stop searching */
      end;

      dcl	    key		       char (256) var;
      dcl	    descrip	       fixed (35);
   end find_entry;

abort_exit:
      code = error_table_$file_is_full;
      aborting = "1"b;
      file_base_ptr -> file_base.max_comp_num = true_max_comp_num + 2;
      go to unlock_exit;

switch_file_state:
      file_state = 1 - file_state;
      file_state_ptr = os_ptr;
      o_s_ptr = fs_ptr;
unlock_exit:
      if indx_cb.shared
      then if ^indx_cb.leave_locked & i_locked_file
	 then if ^aborting
	      then
	         do;				/* OK to clear the file lock */
		  call save_correct_pos;
		  last_change_count = change_count;
		  if stacq (lock_word, "0"b, indx_cb.saved_lock_copy)
						/* unlock */
		  then ;
	         end;
	      else
	         do;
		  call restore_state;
		  if stacq (lock_word, (36)"1"b, indx_cb.saved_lock_copy)
		  then ;				/* invalidate the lock */
	         end;
	 else if aborting
	 then call restore_state;
	 else call save_correct_pos;
      if i_locked_rec
      then call unlock_record (block_ptr, lock_ptr, old_passive_ref_mask);
      else if i_set_negmod & ^aborting & (block_ptr ^= null)/* modifier set to -1 */
      then block_ptr -> stat_struct.modifier = 0;		/* clear it */
      if i_locked_new
      then call unlock_record (new_block_ptr, new_lock_ptr, new_passive_ref_mask);
						/*
						   in case of reassign_key operation */
      else if i_set_new_negmod & ^aborting & (new_block_ptr ^= null)
      then new_block_ptr -> stat_struct.modifier = 0;
exit:
      return;					/* external exit point */

rewrite_indx_file:
   entry (iocb_ptr, buff_ptr, buff_len, code);
      current_retry_loc = rew_retry;
      go to init_up_down;
retry_loc (12):
      call check_buff_len;
      call check_current;
      if code ^= 0
      then go to verify_done;
      call lock_current_record (block_ptr, lock_ptr, i_locked_rec_mask, 0);
						/* handles deleted record case */
      if code ^= 0
      then if (code ^= error_table_$locked_by_this_process) & (code ^= error_table_$invalid_lock_reset)
	 then go to verify_done;
      if indx_cb.outside_index			/* not using index */
      then if ^block_ptr -> record_block.stationary	/* see if non-stationary */
	 then if buff_len + indx_cb.min_res > 4 * (block_ptr -> record_block.block_size - 2)
	      then
	         do;				/* don't permit reallocation from outside index */
		  if code = error_table_$locked_by_this_process
		  then i_locked_rec = "0"b;		/* suppress unlocking of the record */
		  code = error_table_$long_record;
		  go to unlock_exit;		/* abort--no need to verify, since indx_cb.outside_index */
	         end;
	      else ;
	 else ;
      else if is_sequential_open
      then indx_cb.next_record_position = 2;
      else indx_cb.next_record_position = 0;		/* OK to lock file now that record is locked */
      call initialize_substate;			/* prepare for file state change after locking file, if not already locked */
      file_base.old_record_designator = indx_cb.current_descrip;
      if ^indx_cb.outside_index
      then
         do;					/*Only need to save current node when using index.*/
	  first_branch = node;			/* just a convenient place to save current node */
	  file_base.count = branch_num;		/* convenient place to save current branch_num */
         end;
      call save_min_blksz_inf;
      file_base.out_of_index = indx_cb.outside_index;	/* remember in case of crash */
      call save_old_record_length;
      new_record_length = max (0, buff_len);
      file_action = replace_action;
      if file_base.was_stat				/* record is stationary type */
      then
         do;
	  if (new_record_length > 0) | (indx_cb.min_cap > 0) | (indx_cb.min_res > 0)
	  then /* always save buffer contents before rewriting */
	       call change_record_list (iocb_ptr, allocate_action, buff_ptr, abort_exit);
	  else file_base.new_descriptor = 0;		/* no allocation required */
	  stat_struct.ind_comp = new_rec_des.comp;
	  time_stamp_struct.ind_offset = new_rec_des.offset;
	  change_count = file_base.old_file_ch_count + 1; /* must be bumped before body of operation */
	  if file_base.was_transaction		/* in transaction mode */
	  then
	     do;					/* transaction case--retain before image */
	        if (file_base.old_ind_desc > 0)		/* current allocation exists--replace it */
	        then call change_record_list (iocb_ptr, replace_action, buff_ptr, abort_exit);
	        os_ptr -> number_of_allocated_records = number_of_allocated_records;
						/*
						   this statistic not changed until checkpoint occurs */
	     end;					/* done with rewrite for transaction case */
	  else
	     do;					/* non-TP case */
	        os_ptr -> total_record_length = total_record_length + buff_len - old_record_length;
	        call change_record_list (iocb_ptr, replace_action, null, abort_exit);
	     end;
         end;					/* end of stationary replacement logic */
      else
         do;					/* non-stationary case */
	  file_base.change_count = file_base.old_file_ch_count + 1;
	  os_ptr -> total_record_length = total_record_length + buff_len - old_record_length;
	  if (new_record_length > 0) | (indx_cb.min_cap > 0) | (indx_cb.min_res > 0)
	  then
	     do;					/* insert or replace record */
	        if old_record_designator ^= 0
	        then record_action = replace_action;
	        else
		 do;
		    record_action = insert_action;
		    i_locked_rec = "1"b;		/* unlock when done */
		 end;
	        call change_record_list (iocb_ptr, record_action, buff_ptr, abort_exit);
	        if file_base.new_descriptor = file_base.old_record_designator
						/* allocation hasn't moved */
	        then if i_locked_rec			/* lock set by this operation */
		   then block_ptr -> record_block.lock_flag = "0"b;
						/*
						   not leaving locked, so clear the flag */
		   else if (code ^= 0) & (code = error_table_$locked_by_this_process)
						/* lock was already set by my process before rewriting */
		   then ;				/* will leave lock set, if room remains */
		   else
		      do;				/* won't leave lock set */
		         block_ptr -> record_block.lock_flag = "0"b;
		         go to end_ns_rew;		/* didn't set lock anyway */
		      end;
	        else if (code ^= 0) & (code = error_table_$locked_by_this_process)
	        then
		 do;				/* leave new allocation locked, if room */
		    block_ptr = get_ptr (file_base.new_descriptor);
		    block_ptr -> record_block.lock_flag = "1"b;
		 end;
	        else
		 do;
		    i_locked_rec = "0"b;		/* suppress unlocking rec */
		    go to end_ns_rew;
		 end;
	        if block_ptr -> record_block.block_size > divide (file_base.new_record_length + 11, 4, 19, 0)
	        then
		 do;				/* room for lock--be sure it is still set */
		    lock_ptr = addr (block_with_lock.record_lock);
		    lock_ptr -> based_lock = indx_cb.saved_lock_copy;
						/*
						   in case location of the lock has moved */
		 end;
	        else
		 do;				/* no more room for record lock */
		    block_ptr -> record_block.lock_flag = "0"b;
		    i_locked_rec = "0"b;		/* suppress attempt to unlock */
		 end;
	     end;					/* done with new allocation case */
	  else
	     do;					/* don't create or leave a record */
	        if old_record_designator ^= 0
	        then /* delete the old record */
		   call change_record_list (iocb_ptr, delete_action, (null), abort_exit);
	        new_descriptor = 0;
	        i_locked_rec = "0"b;
	     end;
end_ns_rew:
	  if ^indx_cb.outside_index			/* index position being used */
	  then record_descrip (branch_num) = new_descriptor;
						/* put new
						   record descriptor into current index position */
	  else indx_cb.current_descrip = new_descriptor;
         end;					/* done with non-stationary logic */
      go to switch_file_state;			/* unlocks file and record--end of rewrite logic */

unlock_record:
   proc (block_ptr_arg, lock_ptr_arg, passive_ref_mask);	/* by convention, the record is always unlocked last when independent synch levels are involved */
      if block_ptr_arg = null				/* no record allocation to unlock */
      then return;
      if lock_ptr_arg = null
      then return;
      if aborting
      then
         do;					/* invalidate the record lock, if room */
	  if indx_cb.trans
	  then if block_ptr_arg -> record_block.stationary
	       then if (block_ptr_arg -> stat_struct.modifier > 0)
		     & (block_ptr_arg -> stat_struct.modifier = current_t_code)
		  then return;			/* leave locked -- refl entry must exist */
		  else if cleanup_flags & passive_ref_mask ^= "000000"b
						/* passive refl entry exists */
		  then return;			/* don't invalidate if in ref list */
	  if lock_ptr_arg ^= null
	  then if stacq (lock_ptr_arg -> based_lock, (36)"1"b, indx_cb.saved_lock_copy)
	       then ;				/* clobber record lock */
	  return;
         end;
      if block_ptr_arg -> record_block.stationary
      then if block_ptr_arg -> stat_struct.modifier > 0
	 then return;				/* leave locked until checkpoint or rollback */
      if ^(lock_ptr_arg -> based_lock = indx_cb.saved_lock_copy)
      then return;
      block_ptr_arg -> record_block.lock_flag = "0"b;
      if block_ptr_arg -> record_block.stationary
      then
         do;
	  stat_struct.ind_comp = 0;
	  time_stamp_struct.ind_offset = "0"b;
	  stat_struct.modifier = 0;
         end;
      if stacq (lock_ptr_arg -> based_lock, "0"b, indx_cb.saved_lock_copy)
      then ;
      dcl	    (block_ptr_arg, lock_ptr_arg)
			       ptr;
      dcl	    1 time_stamp_struct    like time_stamp_structure based (addr (stat_struct.time_stamp_words));
      dcl	    passive_ref_mask       bit (36) aligned;
      dcl	    1 record_block	       like record_block_structure based (block_ptr_arg);
      dcl	    1 stat_struct	       like stat_structure based (block_ptr_arg);
   end unlock_record;

save_old_record_length:
   proc;
      if repeating
      then
         do;
	  call check_file_substate;
	  return;
         end;
      file_base.old_record_length = record_len;
      call save_stat_info;
      file_substate = file_substate + 1;
   end save_old_record_length;

save_stat_info:
   proc;						/* saves info about current record for recovery */
      if file_base.old_record_designator <= 0		/* no allocated record */
      then file_base.was_stat = "0"b;			/* stationary record is always allocated */
      else
         do;					/* save info about record block */
	  file_base.prior_block_size = block_ptr -> record_block.block_size;
	  file_base.was_stat = block_ptr -> record_block.stationary;
	  file_base.was_ind = block_ptr -> record_block.indirect;
	  file_base.old_prev_mod = block_ptr -> stat_struct.prev_mod;
	  file_base.old_ind_desc = ind_desc;		/* indirect descriptor */
	  file_base.old_modifier = max (0, stat_struct.modifier);
         end;
   end save_stat_info;

prepare_key:
   proc (new_key);
      new_key_length = max (length (new_key), indx_cb.min_key_len);
      substr (new_key_string, 1, new_key_length) = new_key;

      dcl	    new_key	       char (256) varying;
   end;						/* end prepare key */

write_indx_file:
   entry (iocb_ptr, buff_ptr, buff_len, code);		/* ref6 */
      current_retry_loc = write_retry;
      go to init_down_up;
retry_loc (13):
      call check_buff_len;
      if indx_cb.subset_selected = "10"b		/* pure selection */
      then
         do;
	  code = error_table_$no_record;
	  go to unlock_exit;
         end;
      call initialize_substate;
      call save_min_blksz_inf;
      new_record_length = max (buff_len, 0);
      call set_add_ent_info ("1"b);			/* prepare to add key and rec */
      file_base.old_ref_count = 1;			/* initial ref count will be for key entered with record, if -stat */
      file_action = insert_action;
      if (file_base.new_record_length > 0) | file_base.was_stat | (indx_cb.min_cap > 0) | (indx_cb.min_res > 0)
      then
         do;					/* allocate space for record and copy buffer */
	  call change_record_list (iocb_ptr, insert_action, buff_ptr, abort_exit);
	  if file_base.was_transaction		/* creating record in a transaction */
	  then
	     do;					/* mask presence to others until checkpoint */
	        indx_cb.current_descrip = file_base.new_descriptor;
	        call lock_current_record (block_ptr, lock_ptr, i_locked_rec_mask, 0);
						/* also creates refl entry */
	     end;					/* only my transaction will see this record */
         end;
      else new_descriptor = 0;
      file_base.change_count = file_base.old_file_ch_count + 1;
      call set_new_record_designator;
      call change_index (iocb_ptr, abort_exit);
      pos_ptr = file_position_ptr;
      call set_post_write_pos;
      go to switch_file_state;			/* end of write routine */

check_buff_len:
   proc;						/* sets code non-zero if buffer is too big */
      if buff_len > indx_cb.max_record_size
      then
         do;
	  code = error_table_$long_record;
	  go to unlock_exit;
         end;
   end check_buff_len;

set_post_write_pos:
   proc;						/* also used by record_status when creating with locate_sw clear */
      indx_cb.current_record_is_valid = "1"b;
      indx_cb.at_bof, indx_cb.at_eof = "0"b;
      indx_cb.ready_to_write = dup_ok;
      indx_cb.skip_state = 0;
      if is_sequential_open
      then indx_cb.next_record_position = 2;
      else
         do;
	  indx_cb.next_record_position = 0;
	  indx_cb.saved_descrip = file_base.new_descriptor;
						/* save now
						   because save correct pos logic won't handle next_rec_pos=0 case */
         end;
   end set_post_write_pos;

set_add_ent_info:
   proc (add_rec_sw);				/* routine prepares for adding index entry
						   and record if add_rec_sw="1"b */
      is_ptr = indx_cb.index_state_ptr;
      if repeating					/* recovery in progress */
      then
         do;
	  call check_file_substate;
	  return;
         end;
      file_base.new_desc_val = 0;			/* used by change_index */
      file_base.saved_ks_out = indx_cb.is_ks_out;		/* in case of crash */
      if ^add_rec_sw				/* add_key operation */
      then
         do;					/* will not create record */
	  if (block_ptr = null)
	  then file_base.was_stat = "0"b;
	  else if block_ptr -> record_block.stationary
	  then
	     do;
	        file_base.was_stat = "1"b;
	        file_base.new_ref_count = ref_cnt;
	     end;
	  else file_base.was_stat = "0"b;
	  if ak_inf.input_key			/* get new key from info structure */
	  then
	     do;
	        call prepare_key (ak_info_key);
	        new_key_len = ak_inf.key_len;
	     end;
	  else call prepare_key_for_insertion;
	  new_record_designator = indx_cb.current_descrip;
	  file_base.new_descriptor = new_record_designator;
         end;
      else
         do;					/* prepare for write_record or record_status(**10) */
	  file_base.was_stat = indx_cb.stat;		/* -stat option used--default record
						   type is stationary */
	  call check_key_for_insertion;
	  call prepare_key_for_insertion;
	  call set_add_rec_stats;
         end;
      os_ptr -> number_of_keys = number_of_keys + 1;
      os_ptr -> total_key_length = total_key_length + new_key_len;
      if key_is_dup
      then
         do;					/* change duplicate key stats */
	  os_ptr -> duplicate_keys = duplicate_keys + 1;
	  os_ptr -> dup_key_bytes = dup_key_bytes + new_key_len;
	  call find_rightmost_descendent;		/* sets pos properly in case at non-leaf entry */
         end;
      change_position_ptr = pos_ptr;
      change_node = node;
      call save_position_info;
      new_branch = 0;
      index_action = insert_action;
      file_substate = file_substate + 1;
      return;					/* end of main routine for set_add_ent_info */

prepare_key_for_insertion:
   proc;
      key_is_dup = indx_cb.current_record_is_valid;
      if key_is_dup
      then
         do;
	  new_key_len = get_key_length ();		/* length of current key */
	  new_key_length = key_length (branch_num);
	  substr (new_key_string, 1, new_key_length) = substr (keys, key_pos (branch_num), key_length (branch_num));
						/* set up key for insertion */
	  if ^add_rec_sw				/* add_key operation */
	  then
	     do;
	        indx_cb.saved_descrip = record_designator (branch_num);
						/*
						   remember current descriptor */
	        pos_incorrect = "1"b;
	     end;
	  call find_next_key;			/* advance position beyond last dup key */
         end;
      else
         do;
	  call prepare_key (indx_cb.new_key);		/* key for insertion */
	  new_key_len = length (indx_cb.new_key);
         end;
   end prepare_key_for_insertion;

      dcl	    new_key_len	       fixed;
      dcl	    add_rec_sw	       bit (1) aligned;
   end set_add_ent_info;

check_key_for_insertion:
   proc;						/* makes sure current key is defined */

      do while ("1"b);				/* may loop once */
         if ^indx_cb.ready_to_write
         then if dup_ok & ^is_ks_out			/* may be ready to write anyway */
	    then
	       do;
		call check_current;			/* sets code to zero if current really exists */
		if code ^= 0			/* really is no key for insertion */
		then
		   do;				/* forget the whole thing */
no_key:
		      code = error_table_$no_key;	/* set proper code */
		      go to verify_done;
		   end;
	       end;
	    else go to no_key;
         if pos_incorrect
         then
	  do;
	     call restore_position;
	     if code ^= 0
	     then go to verify_done;
	  end;
         else
	  do;
	     pos_ptr = indx_cb.file_position_ptr;
	     return;
	  end;
      end;

   end check_key_for_insertion;

find_next_key:
   proc;						/* routine used to advance pos beyond set of dup keys */
      init_key_len = key_length (branch_num);
      init_key_ptr = addr (node_ptr -> bytes (key_pos (branch_num)));
						/* keep track of prev key */

      do while ("1"b);
         branch_num = branch_num + 1;
         call find_this_entry;			/* takes care of exceptional cases */
         if pos_ptr = root_position_ptr			/* at eof */
         then return;
         if substr (keys, key_pos (branch_num), key_length (branch_num)) ^= init_key_ptr -> initial_key
						/* key no longer matches */
         then return;				/* found different key--done */
      end;

      dcl	    init_key_len	       fixed;
      dcl	    init_key_ptr	       ptr;
      dcl	    initial_key	       char (init_key_len) based (init_key_ptr);
      dcl	    bytes		       (1:4096) char (1) based;
   end find_next_key;

set_new_record_designator:
   proc;
      if repeating
      then
         do;
	  call check_file_substate;
	  return;
         end;
      new_record_designator = new_descriptor;
      file_substate = file_substate + 1;
   end set_new_record_designator;

delete_indx_file:
   entry (iocb_ptr, code);				/* ref7 */
      current_retry_loc = del_retry;
      go to init_up_down;
retry_loc (14):
      del_cur = "1"b;
      call check_current;
      if code ^= 0
      then go to verify_done;				/* file may not be locked yet */
      indx_cb.is_read_only = "1"b;			/* to suppress recursive cleanup attempt */
      call lock_current_record (block_ptr, lock_ptr, i_locked_rec_mask, 0);
						/* must restore read_only status if abort is made */
      indx_cb.is_read_only = "0"b;
      if code ^= 0
      then if code = error_table_$no_record & (block_ptr ^= null)
	 then ;					/* collect a garbage item--leave non-zero code as warning */
	 else if (code ^= error_table_$locked_by_this_process) & (code ^= error_table_$invalid_lock_reset)
	 then go to unlock_exit;			/* abort */
      call delete_entry ("1"b);			/* delete index entry and current record */
      return;

adjust_record:
   entry (iocb_ptr, descrip_arg, modifier_arg, code);	/*
						   used by transaction_call_ to unlock a record */
      current_retry_loc = adj_retry;
      go to init_down_up;
retry_loc (15):
      call initialize_substate;			/* prepare for file modification */
      file_base.old_record_designator = descrip_arg;
      block_ptr = get_pointer (descrip_arg);
      lock_ptr = addr (block_ptr -> stat_struct.record_lock);
      i_locked_rec = "1"b;
      if indx_cb.repeating
      then
         do;
	  rollback_sw = (file_action = rollback_action);
	  if file_base.was_ind & (file_base.old_ind_desc > 0)
	  then p = get_pointer (file_base.old_ind_desc);	/* be sure initiated */
         end;
      else
         do;
	  if (block_ptr -> stat_struct.modifier <= 0)
	  then go to unlock_exit;
	  if ^(lock_ptr -> based_lock = indx_cb.saved_lock_copy)
	  then go to unlock_exit;			/* already adjusted */
	  if modifier_arg = block_ptr -> stat_struct.prev_mod
	  then rollback_sw = "1"b;			/* adjust to before image */
	  else if modifier_arg = block_ptr -> stat_struct.modifier
	  then
	     do;
	        rollback_sw = "0"b;			/* adjust to after image */
	        if block_ptr -> stat_struct.prev_mod = -3 /* pre-created record
						   which previous to this transaction did not exist */
	        then
		 do;				/* use null before image */
		    record_len = 0;			/* used only in following protected procedure */
		    ind_desc = -1;
		 end;
	        else if block_ptr -> record_block.indirect/* separate allocation of before */
	        then
		 do;
		    ind_desc = ind_struct.prev_desc;	/* before image */
		    if ind_struct.prev_desc <= 0	/* no allocation--special case */
		    then record_len = 0;
		    else record_len = length (get_pointer (ind_desc) -> record_block.record);
		 end;
	        else
		 do;
		    ind_desc = descrip_arg;
		    record_len = length (stat_struct.record);
						/* compact case */
		 end;
	     end;
	  else rollback_sw = "1"b;			/* roll back by default */
	  file_base.old_ref_count = block_ptr -> stat_struct.ref_count;
         end;
      if ^rollback_sw				/* checkpoint case */
      then
         do;					/* retain after and discard before image */
	  call save_old_record_length;		/* saves before-image info */
	  ind_des.comp = stat_struct.ind_comp;
	  ind_des.offset = time_stamp_struct.ind_offset;
	  call set_after_image_info;
	  if file_base.old_prev_mod = -3		/* new record created this trans */
	  then os_ptr -> number_of_records = number_of_records + 1;
	  else os_ptr -> number_of_records = number_of_records;
						/* note that this is only nec because of recovery */
	  if ind_desc = -1				/* deletion case */
	  then os_ptr -> number_of_records = os_ptr -> number_of_records - 1;
	  os_ptr -> total_record_length =
	     total_record_length + file_base.new_record_length - file_base.old_record_length;
	  file_action = adjust_action;
	  file_base.change_count = file_base.old_file_ch_count + 1;
	  block_ptr -> stat_struct.ref_count = block_ptr -> stat_struct.ref_count_after;
	  if ind_desc = -2				/* no change to the record image */
	  then
	     do;
	        block_ptr -> stat_struct.modifier = -1;	/* allow unlocking */
	        file_action = o_s_ptr -> file_action;	/* fast state switch */
	        go to unlock_exit;			/* don't change time stamp */
	     end;
	  if file_base.was_ind
	  then
	     do;
	        time_stamp_struct.time_last_modified = clock ();
	        ind_struct.prev_mod = file_base.old_modifier;
	        ind_struct.prev_desc = file_base.after_desc;
	        if file_base.old_ind_desc > 0
	        then
		 do;
		    file_base.new_descriptor = file_base.old_ind_desc;
						/* block to be freed */
		    call change_record_list (iocb_ptr, free_action, null, abort_exit);
		 end;
	     end;
	  else if file_base.old_prev_mod ^= -3		/* old record */
	  then
	     do;					/* overrite tail or convert into an indirect record */
	        file_base.new_descriptor = file_base.after_desc;
						/* after image descriptor */
	        file_base.was_transaction = "0"b;
	        call change_record_list (iocb_ptr, replace_action, null, abort_exit);
						/* tries to overrite in place if room */
	     end;
	  else
	     do;
	        time_stamp_struct.time_last_modified = clock ();
	        stat_struct.prev_mod = file_base.old_modifier;
	     end;
         end;					/* end of forward adjustment logic */
      else
         do;					/* rollback case */
	  ind_des.comp = stat_struct.ind_comp;		/* after image info */
	  ind_des.offset = time_stamp_struct.ind_offset;
	  call save_old_record_length;		/* protected procedure for recovery */
	  file_base.new_descriptor = file_base.old_ind_desc;
						/* block to free */
	  file_base.was_transaction = "1"b;
	  file_action = rollback_action;		/* can't stop this operation now */
	  file_base.change_count = file_base.old_file_ch_count + 1;
						/* must bump since file's substate will be switched */
	  if file_base.old_prev_mod = -3
	  then
	     do;
	        if file_base.old_ref_count <= 0
	        then
		 do;
		    file_base.out_of_index = "1"b;	/* not deleting key */
		    call change_record_list (iocb_ptr, delete_action, null, abort_exit);
		    os_ptr -> number_of_allocated_records = number_of_allocated_records;
		    i_locked_rec = "0"b;		/* suppress unlocking */
		    go to switch_file_state;
		 end;
	        else
		 do;
		    if ^file_base.was_ind
		    then
		       do;
			file_base.new_descriptor = -1;
			call change_record_list (iocb_ptr, replace_action, null, abort_exit);
						/* leave only a logically deleted indirect header */
		       end;
		    else
		       do;
			if file_base.old_ind_desc > 0
			then call change_record_list (iocb_ptr, free_action, null, abort_exit);
			ind_struct.prev_desc = -1;
		       end;
		    stat_struct.prev_mod = 0;
		 end;
	     end;
	  else if file_base.old_ind_desc > 0		/* allocation exists */
	  then call change_record_list (iocb_ptr, free_action, null, abort_exit);
         end;
      os_ptr -> number_of_allocated_records = number_of_allocated_records;
      block_ptr -> stat_struct.modifier = -1;		/* allow unlocking now */
      go to switch_file_state;			/* end of adjust_record logic */

adjust_file:
   entry (iocb_ptr, code);				/* called if file found locked by dead
						   process in passive file lock checking */
      current_retry_loc = adj_file_retry;
      go to init_down_up;				/* tries to lock the file */
retry_loc (25):
      go to unlock_exit;				/* that's all there is to it */

set_after_image_info:
   proc;
      if indx_cb.repeating				/* recovery in progress */
      then
         do;
	  if file_base.after_desc > 0
	  then p = get_pointer (file_base.after_desc);
	  call check_file_substate;
	  return;					/* skip protected body of procedure */
         end;
      file_base.after_desc = ind_desc;
      if ind_desc <= 0
      then file_base.new_record_length = 0;
      else if (block_ptr -> stat_struct.prev_mod = -3) & ^block_ptr -> record_block.indirect
						/* new compact */
      then file_base.new_record_length = length (stat_struct.record);
      else file_base.new_record_length = length (get_pointer (ind_desc) -> record_block.record);
      file_substate = file_substate + 1;		/* mark completion of this step */
   end set_after_image_info;

delete_entry:
   proc (del_rec_sw);				/* routine to delete index entry and rec if switch set */
      call initialize_substate;
      file_base.out_of_index = indx_cb.outside_index;	/* in case of crash */
      call set_del_ent_info;
      if del_cur
      then if is_sequential_open
	 then
	    do;
	       indx_cb.skip_state = 0;		/* scanning of deletions is forward */
	       indx_cb.next_record_position = 1;
	    end;
	 else indx_cb.next_record_position = 0;
      if del_rec_sw					/* delete_record operation */
      then
         do;
	  file_action = delete_action;
	  if del_cur				/* not delete_key case */
	  then
	     do;
	        indx_cb.current_record_is_valid = "0"b;	/* in case at eof or direct opening */
	        indx_cb.ready_to_write = "0"b;		/* may actually be ready if current exists */
	     end;
	  else if saved_state.current_record_is_valid
	  then indx_cb.current_descrip = saved_state.current_descrip;
	  else indx_cb.current_descrip = indx_cb.saved_descrip;
	  file_base.change_count = file_base.old_file_ch_count + 1;
	  if file_base.was_stat
	  then
	     do;					/* delete a stationary record */
	        if file_base.old_modifier > 0		/* TP case */
	        then
		 do;
		    file_base.new_descriptor = -1;
		    if file_base.old_ind_desc > 0	/* non-null after image */
		    then call change_record_list (iocb_ptr, replace_action, null, abort_exit);
						/* discard indirect after image allocation */
		    indx_cb.outside_index = "0"b;
		    if indx_cb.next_record_position = 1
		    then indx_cb.next_record_position = 2;
						/* skip over this key */
		    go to switch_file_state;		/* nothing more to do until checkpoint */
		 end;
	        call change_record_list (iocb_ptr, delete_action, null, abort_exit);
	        if indx_cb.outside_index
	        then
		 do;
		    indx_cb.outside_index = "0"b;
		    go to switch_file_state;
		 end;
	        if file_base.is_partial_deletion
	        then
		 do;
		    if indx_cb.next_record_position = 1
		    then indx_cb.next_record_position = 2;
		    go to switch_file_state;		/* don't delete last key */
		 end;
	        if ^del_cur				/* delete_key case */
	        then indx_cb.outside_index = saved_state.outside_index;
	     end;
	  else
	     do;
	        if old_record_designator ^= 0
	        then call change_record_list (iocb_ptr, delete_action, (null), abort_exit);
	        if indx_cb.outside_index		/* no key to delete */
	        then
		 do;
		    indx_cb.outside_index = "0"b;
		    go to switch_file_state;		/* just deleted the current record */
		 end;
	     end;
         end;
      else
         do;					/* operation is delete_key */
	  file_action = deleting_key;			/* all info necessary for recovery is saved */
	  if del_cur /* key to delete is at the current file position */ & ^indx_cb.outside_index
						/* deleting key of current record */
	  then call make_current (old_record_designator); /* current pos moves out of index */
	  else if saved_state.current_record_is_valid
	  then indx_cb.current_descrip = saved_state.current_descrip;
	  else indx_cb.current_descrip = indx_cb.saved_descrip;
	  file_base.change_count = file_base.old_file_ch_count + 1;
	  if file_base.was_stat
	  then
	     do;
	        block_ptr -> stat_struct.ref_count_after = file_base.old_ref_count;
	        block_ptr -> stat_struct.ref_count = file_base.old_ref_count;
	     end;
         end;
      if new_desc_val ^= 0				/* non-leaf node */
      then
         do;					/* replace key with highest preceding one */
	  call replace_non_leaf_key;
	  call reset_change_position;
	  if is_sequential_open & del_cur
	  then indx_cb.next_record_position = 2;
         end;
      call change_index (iocb_ptr, abort_exit);		/* deletes the key */
      pos_ptr = file_position_ptr;
      if new_desc_val ^= 0
      then if del_cur				/* pos belongs upstairs */
	 then call find_from_leaf;			/* climbs up tree */
      go to switch_file_state;			/* end of delete routine */

set_del_ent_info:
   proc;						/* saves vars necessary for deletion */
      is_ptr = indx_cb.index_state_ptr;
      if repeating
      then
         do;
	  i_locked_rec =
	     (file_action ^= delete_action)
	     | ((file_action = delete_action) & file_base.was_stat
	     & (file_base.is_partial_deletion | (file_base.old_modifier > 0)
	     | (file_base.old_ref_count > fixed (^file_base.out_of_index))));
	  call check_file_substate;
	  return;
         end;
      file_base.old_record_designator = indx_cb.current_descrip;
      if del_rec_sw					/* delete_record operation */
      then
         do;					/* prepare to remove old record */
	  call save_stat_info;			/* save more info if record is stationary */
	  file_base.is_partial_deletion = "0"b;
	  if file_base.was_stat			/* stationary record case */
	  then
	     do;
	        stat_struct.ind_comp = -1;
	        time_stamp_struct.ind_offset = (18)"1"b;	/* -1 */
	        file_base.old_ref_count = ref_cnt;
	        if file_base.old_modifier > 0		/* won't alter index at this time */
	        then go to bump_substate;		/* no more info to save for recoverability */
	        if indx_cb.shared
	        then if ^indx_cb.outside_index		/* key exists */
		   then if ref_cnt <= 1		/* at last reference */
		        then if time_stamp + indx_cb.collection_delay_time > clock ()
			   then file_base.is_partial_deletion = "1"b;
			   else i_locked_rec, i_set_negmod = "0"b;
						/* suppress unlocking */
		        else ;			/* will unlock record when done */
		   else if ref_cnt <= 0		/* no more refs--can collect */
		   then i_locked_rec, i_set_negmod = "0"b;
						/* block will be zeroed */
		   else ;				/* won't collect entire block--unlock */
	        else if ref_cnt <= fixed (^indx_cb.outside_index)
	        then i_locked_rec, i_set_negmod = "0"b;
	     end;
	  else i_locked_rec = "0"b;			/* always collect storage completely */
	  if ^rec_deleted				/* statistics must be adjusted */
	  then os_ptr -> number_of_records = number_of_records - 1;
	  os_ptr -> total_record_length = total_record_length - record_len;
	  if file_base.is_partial_deletion | indx_cb.outside_index
	  then go to bump_substate;
         end;
      else if (block_ptr = null)
      then file_base.was_stat = "0"b;
      else if block_ptr -> record_block.stationary
      then
         do;
	  file_base.was_stat = "1"b;
	  file_base.old_ref_count = ref_cnt;
         end;
      else file_base.was_stat = "0"b;
      os_ptr -> number_of_keys = number_of_keys - 1;
      os_ptr -> total_key_length = total_key_length - get_key_length ();
      change_position_ptr = pos_ptr;
      change_node = node;
      file_base.new_desc_val = branch (branch_num + 1);
      if dup_ok
      then if deleting_dup ()
	 then
	    do;					/* duplicate key stats must change */
	       os_ptr -> duplicate_keys = duplicate_keys - 1;
	       os_ptr -> dup_key_bytes = dup_key_bytes - get_key_length ();
	    end;
      if new_desc_val ^= 0				/* non-leaf node */
      then
         do;					/* prepare to delete preceding key */
	  call find_rightmost_descendent;
	  branch_num = branch_num - 1;
	  call prepare_key (substr (keys, key_pos (branch_num), key_length (branch_num)));
	  new_record_designator = record_designator (branch_num);
	  index_action = replace_action;		/* first replace key with copy of predecessor */
         end;
      else index_action = delete_action;
      call save_position_info;			/* remember index location */
bump_substate:
      file_substate = file_substate + 1;
   end set_del_ent_info;

deleting_dup:
   proc returns (bit (1) aligned);			/* routine checks whether key to delete is a duplicate */
      change_branch = branch_num;			/* remember current branch num */
      return (next_is_dup () | prev_is_dup ());		/* compares key with neighbors */

next_is_dup:
   proc returns (bit (1) aligned);			/* sees if next key matches current */
      branch_num = branch_num + 1;			/* advance position */
      call find_this_entry;				/* in case non-leaf or at last branch */
      new_branch_num = branch_num;
set_result:
      if pos_ptr = root_position_ptr			/* end of file */
      then keys_match = "0"b;				/* no prev or next key exists */
      else if (
	    substr (change_position_ptr -> node_ptr -> keys, change_position_ptr -> node_ptr -> key_pos (change_branch),
	    change_position_ptr -> node_ptr -> key_length (change_branch))
	    = substr (keys, key_pos (branch_num), key_length (branch_num)))
      then keys_match = "1"b;
      else keys_match = "0"b;
      branch_num = new_branch_num;			/* in case checking prev of first in node */
      pos_ptr = change_position_ptr;			/* restore file position */
      file_position_ptr = pos_ptr;
      branch_num = change_branch;
      return (keys_match);				/* return result */

prev_is_dup:
   entry returns (bit (1) aligned);			/* sees if preceding key matches current */
      call find_prev_entry;				/* in case non-leaf or at first branch */
      new_branch_num = branch_num;			/* in case this node is parent */
      branch_num = branch_num - 1;			/* does the backspace */
      go to set_result;				/* finish up */

   end next_is_dup;
      dcl	    keys_match	       bit (1) aligned;
      dcl	    new_branch_num	       fixed (35);
      dcl	    change_branch	       fixed (35);
   end deleting_dup;

      dcl	    del_rec_sw	       bit (1) aligned;
   end delete_entry;

replace_non_leaf_key:
   proc;
      if repeating
      then
         do;
	  next_substate = next_substate + 1;		/* file_substate is bumped by change_index */
	  call check_file_substate;
	  if file_substate >= next_substate
	  then return;
         end;
      call change_index (iocb_ptr, abort_exit);
      pos_ptr = file_position_ptr;
      file_substate = file_substate + 1;
   end replace_non_leaf_key;

reset_change_position:
   proc;
      is_ptr = indx_cb.index_state_ptr;
      if repeating
      then
         do;
	  call check_file_substate;
	  return;
         end;
      change_position_ptr = pos_ptr;
      change_node = node;
      index_action = delete_action;
      file_substate = file_substate + 1;
   end reset_change_position;

save_position_info:
   proc;						/* saves process variables required for recovery mechanism */
      current_node = node;
      p = root_position_ptr;
      do i = 1 to index_height;
         p = p -> son_position_ptr;
         saved_node (i) = p -> node;
         saved_branch_num (i) = p -> branch_num;
      end;
      dcl	    i		       fixed;
      dcl	    p		       ptr;
   end save_position_info;

add_key:						/* routine adds specified key to current record */
      if indx_cb.mode = 7				/* unkeyed update opening */
      then
         do;					/* abort */
	  code = error_table_$no_operation;
	  go to exit;
         end;
      current_retry_loc = ak_retry;
      go to init_up_down;
retry_loc (16):
      saved_state.current_record_is_valid = indx_cb.current_record_is_valid;
      saved_state.current_descrip = indx_cb.current_descrip;
      if ak_inf.input_key				/* get new key from info structure */
      then
         do;
	  if ^ak_inf.input_desc			/* using current record's descrip */
	  then
	     do;
	        call check_current;			/* checks if current rec is not defined */
	        if code ^= 0			/* error */
	        then go to verify_done;		/* abort or retry */
	        if ^indx_cb.shared | ^saved_state.current_record_is_valid
	        then call save_correct_pos;
	     end;
	  else if ^indx_cb.shared
	  then call save_correct_pos;
	  pos_incorrect = "1"b;			/* index position will not be current pos */
	  file_position_ptr = root_position_ptr;	/* start search from root */
	  if ^is_ks_out				/* update opening */
	  then
	     do;
	        call find_key$last (indx_cb_ptr, (addr (ak_info_key)), search_code);
						/* look for key */
	        pos_ptr = file_position_ptr;
	        if search_code = 0			/* key not found */
	        then key_is_dup = "0"b;		/* not a duplication */
	        else
		 do;				/* key already exists--set position properly */
		    key_is_dup = "1"b;
		    call find_from_leaf;		/* in case match was non-leaf */
						/*				call find_next_key; /* advance to beyond last duplication, */
		 end;
	     end;
	  else
	     do;					/* verify key order */
	        pos_ptr = indx_cb.file_position_ptr;
	        call find_rightmost_descendent;		/* position to end of file */
	        call compare_last_key (ak_info_key);	/* test key order */
	        if code ^= 0			/* key not larger than last in file */
	        then if ^key_is_dup			/* error--key out of order */
		   then go to verify_done;
		   else code = 0;			/* may be permitted */
	     end;
	  if key_is_dup & ^dup_ok			/* illegal key duplication */
	  then
	     do;					/* abort */
	        code = error_table_$key_duplication;
	        go to verify_done;
	     end;
         end;
      else if ^indx_cb.repeating
      then
         do;
	  if ak_inf.input_desc
	  then
	     do;
	        call check_current;
	        if code ^= 0
	        then go to verify_done;
	     end;
	  call check_key_for_insertion;
         end;
      if ak_inf.input_desc				/* descriptor in info structure */
      then indx_cb.current_descrip = ak_inf.descrip;
      if indx_cb.stat				/* record must be adjusted in this case */
      then
         do;
	  call lock_current_record (block_ptr, lock_ptr, i_locked_rec_mask, 1);
						/* bump the ref count */
	  if code ^= 0
	  then if (code ^= error_table_$locked_by_this_process) & (code ^= error_table_$invalid_lock_reset)
						/* fatal */
	       then
		do;
		   if saved_state.current_record_is_valid
		   then indx_cb.current_descrip = saved_state.current_descrip;
		   else indx_cb.current_descrip = indx_cb.saved_descrip;
		   go to verify_done;
		end;
	       else code = 0;
         end;
      else block_ptr = null;				/* won't have to unlock the record */
      call initialize_substate;
      call set_add_ent_info ("0"b);			/* just add key, no record */
      if saved_state.current_record_is_valid
      then indx_cb.current_descrip = saved_state.current_descrip;
      else indx_cb.current_descrip = indx_cb.saved_descrip;
      file_action = adding_key;			/* no turning back now */
      file_base.change_count = file_base.old_file_ch_count + 1;
      if file_base.was_stat
      then
         do;
	  block_ptr -> stat_struct.ref_count_after = file_base.new_ref_count;
	  block_ptr -> stat_struct.ref_count = file_base.new_ref_count;
         end;
      call change_index (iocb_ptr, abort_exit);		/* inserts the new key */
      pos_ptr = file_position_ptr;
      go to switch_file_state;			/* end of add_key routine */

delete_key:					/* contains logic for the delete_key control order */
      call verify_keyed_update;			/* check opening mode */
      current_retry_loc = dk_retry;
      go to init_up_down;
retry_loc (17):
      saved_state.current_record_is_valid = indx_cb.current_record_is_valid;
      saved_state.current_descrip = indx_cb.current_descrip;
      if info_ptr = null				/* delete current entry for current rec */
      then
         do;
	  if indx_cb.outside_index			/* no key is associated with current record */
	  then code = error_table_$no_key;
	  else call check_current;			/* sets code */
	  if code ^= 0				/* error has occurred--abort */
	  then go to verify_done;
	  del_cur = "1"b;				/* indicates deleted entry is at current file position */
         end;
      else if ak_inf.input_key			/* use key in info structure */
      then
         do;
	  if ^ak_inf.input_desc
	  then
	     do;					/* use current record's descriptor */
	        call check_current;
	        if code ^= 0
	        then go to verify_done;		/* error */
	        if ^indx_cb.shared | ^saved_state.current_record_is_valid
						/* may not have saved current descriptor */
	        then call save_correct_pos;		/* don't lose your place */
	     end;
	  else
	     do;
	        if ^indx_cb.shared
	        then call save_correct_pos;
	        indx_cb.current_descrip = ak_inf.descrip; /* temporarily call this the current descriptor */
	     end;
	  if ^indx_cb.at_bof & ^indx_cb.at_eof
	     & ((indx_cb.next_record_position ^= 0) | (indx_cb.current_record_is_valid & ^indx_cb.outside_index))
	     & (indx_cb.current_descrip = indx_cb.saved_descrip) & (ak_info_key = indx_cb.new_key)
	  then
	     do;
	        del_cur = "1"b;
	        if indx_cb.pos_incorrect
	        then go to find_input_key;
	        else first_code, search_code = 1;	/* fake successful finding--already there */
	     end;
	  else
	     do;
	        del_cur = "0"b;
	        indx_cb.pos_incorrect = "1"b;
find_input_key:
	        call find_entry (ak_info_key, indx_cb.current_descrip);
						/* look for old entry */
	     end;
check_codes:
	  if first_code = 0				/* key not found--error */
	  then code = error_table_$no_key;
	  else if search_code = 0			/* old descrip not found--error */
	  then code = error_table_$no_record;
	  if code ^= 0				/* error has occurred */
	  then
	     do;
	        if saved_state.current_record_is_valid
	        then indx_cb.current_descrip = saved_state.current_descrip;
	        else indx_cb.current_descrip = indx_cb.saved_descrip;
	        go to verify_done;
	     end;
	  if del_cur				/* deleting current_key */
	  then indx_cb.pos_incorrect = "0"b;		/* save new current key */
         end;
      else if indx_cb.outside_index			/* no key for insertion */
      then
         do;					/* signal error */
	  code = error_table_$no_key;
	  go to verify_done;
         end;
      else
         do;
	  call check_current;			/* need current record's key */
	  if code ^= 0				/* error */
	  then
	     do;
	        if ak_inf.input_desc & (code = error_table_$no_record)
	        then code = error_table_$no_key;
	        go to verify_done;
	     end;
	  if ^ak_inf.input_desc			/* current key of current record */
	  then del_cur = "1"b;
	  else
	     do;
	        if ^indx_cb.shared | ^saved_state.current_record_is_valid
	        then call save_correct_pos;
	        indx_cb.current_descrip = ak_inf.descrip;
	        if indx_cb.current_descrip = indx_cb.saved_descrip
	        then
		 do;
		    del_cur = "1"b;
		    if indx_cb.pos_incorrect
		    then go to find_cur_key;
		 end;
	        else
		 do;
		    del_cur = "0"b;
		    indx_cb.pos_incorrect = "1"b;
find_cur_key:
		    call find_entry (indx_cb.new_key, indx_cb.current_descrip);
		    go to check_codes;
		 end;
	     end;
         end;
      if indx_cb.stat
      then
         do;					/* the ref count must be decremented */
	  indx_cb.is_read_only = "1"b;		/* suppress recursive garbage collection */
	  call lock_current_record (block_ptr, lock_ptr, i_locked_rec_mask, -1);
						/* decrement the ref count */
	  indx_cb.is_read_only = "0"b;		/* restore opening state properly */
	  if code ^= 0
	  then if (code = error_table_$no_record) & (block_ptr ^= null)
	       then
		do;				/* handle logically deleted record */
		   if (ref_cnt <= 0) & (block_ptr -> stat_struct.modifier <= 0)
		   then
		      do;				/* setup delete_record case */
		         saved_state.outside_index = indx_cb.outside_index;
		         indx_cb.outside_index = "0"b;	/* signal remove key with record */
		         ref_cnt = ref_cnt + 1;	/* undo decrementing, not done by delete_record */
		         call delete_entry ("1"b);
		         return;			/* not supposed to get here */
		      end;
		end;
	       else if (code ^= error_table_$locked_by_this_process) & (code ^= error_table_$invalid_lock_reset)
	       then
		do;
		   if saved_state.current_record_is_valid
		   then indx_cb.current_descrip = saved_state.current_descrip;
		   else indx_cb.current_descrip = indx_cb.saved_descrip;
		   go to verify_done;
		end;
	       else code = 0;
         end;
      else block_ptr = null;				/* don't unlock record */
      call delete_entry ("0"b);			/* don't delete the record, just the key */
      return;					/* end of delete_key */

verify_keyed_update:
   proc;						/* makes sure opening is valid for delete_key
						   or reassign_key */
      if (mode ^= 10) & (mode ^= 13)			/* not a valid mode */
      then
         do;					/* set error code and abort */
	  code = error_table_$no_operation;
	  go to exit;
         end;
   end verify_keyed_update;

select:						/* selects specified subset of records in the file */
      flag = select_flag;
      if ^common_sl_info.status_only			/* current subset will be reset or changed */
      then if common_sl_info.list_type = 0		/* no list specification--reselect given subset */
	 then
	    do;
	       if (common_sl_info.subset_no < 0) | (common_sl_info.subset_no > indx_cb.last_subset)
	       then
		do;
bad_arg:
		   code = error_table_$bad_arg;	/* invalid subset number */
		   go to exit;			/* abort */
		end;
	       indx_cb.current_subset = common_sl_info.subset_no;
	       if indx_cb.current_subset = 0		/* the identity subset */
	       then
		do;
		   indx_cb.subset_selected = "00"b;	/* convention means default subset */
		   if common_sl_info.output_descriptors /* must do more work */
		   then go to generate_subset;
		end;
	       else indx_cb.subset_selected = "10"b;
	       call count_subset;
	    end;
	 else go to generate_subset;
      else if common_sl_info.output_descriptors & (indx_cb.subset_selected = "00"b)
      then go to generate_subset;
      call get_subset_status;
      return;					/* end of select routine */

exclude:						/* creates temporary exclude list or removes entries from current subset */
      flag = exclude_flag;
      if common_sl_info.list_type = 0			/* reset to previous subset */
      then if (common_sl_info.subset_no <= 0) | (common_sl_info.subset_no > indx_cb.last_subset)
	 then go to bad_arg;
	 else
	    do;
	       indx_cb.current_subset = common_sl_info.subset_no;
	       indx_cb.subset_selected = "01"b;		/* pure exclusion */
	       call count_subset;			/* return subset count to user */
	    end;
      else go to generate_subset;
      call get_subset_status;
      return;					/* end of exclude routine */

get_subset_status:
   proc;						/* returns subset info into common_sl_info structure */
      if indx_cb.subset_selected = "00"b		/* nothing excluded or explicitly selected */
      then
         do;
	  if ^(common_sl_info.status_only & common_sl_info.output_descriptors)
	  then
	     do;					/* trust number of allocations as the count */
	        f_b_ptr = indx_cb.file_base_ptr;
	        indx_cb.subset_count = addr (file_state_blocks (file_base.file_state)) -> number_of_allocated_records;
	     end;
	  common_sl_info.subset_no = 0;
         end;
      else if indx_cb.subset_selected = "10"b		/* pure selection */
      then common_sl_info.subset_no = indx_cb.current_subset;
      else common_sl_info.subset_no = -1 * indx_cb.current_subset;
						/* pure exclusion */
      common_sl_info.count = indx_cb.subset_count;	/* count of items in temporary file for this subset */

      if common_sl_info.output_descriptors & ^(indx_cb.subset_selected = "00"b & flag = select_flag)
      then
         do;
	  if common_sl_info.desc_arrayp = null & common_sl_info.count > 0
						/* wants me to make allocation */
	  then
	     do;
	        if system_freep = null		/* first time this process */
	        then system_freep = get_system_free_area_ ();
	        allocate desc_array in (system_freep -> based_area) set (common_sl_info.desc_arrayp);
	     end;
	  call list_subset;
         end;
   end get_subset_status;

count_subset:
   proc;						/* sets subset_count for current subset */
      if indx_cb.subset_selected = "00"b
      then
         do;					/* treat identity subset as a special case */
	  f_b_ptr = indx_cb.file_base_ptr;
	  indx_cb.subset_count = addr (file_state_blocks (file_base.file_state)) -> number_of_allocated_records;
	  return;
         end;
      count = 0;
      unspec (zero_word_bytes) = "0"b;
      subset_key = current_subset_bytes || zero_word_bytes; /* head for desired portion of temp index */
      indx_cb_ptr = indx_cb.temp_iocbp -> iocb.open_data_ptr;
      call seek_head (1, addr (subset_key), 8);		/* position to start of range in temp file */

      do while (pos_ptr ^= root_position_ptr);		/* loop steps until beyond current subset's range */
         if substr (subset_key, 1, 4) = substr (keys, key_pos (branch_num), 4)
						/* in current subset */
         then
	  do;
	     count = count + 1;
	     branch_num = branch_num + 1;
	     call find_this_entry;			/* in case last branch in node or non-leaf */
	  end;
         else pos_ptr = root_position_ptr;		/* force exit from loop */
      end;

      indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
      pos_ptr = indx_cb.file_position_ptr;
      indx_cb.subset_count = count;
      return;					/* end of count_subset logic */

list_subset:
   entry;						/* fills descriptor array with entries for current subset */
      unspec (zero_word_bytes) = "0"b;
      subset_key = current_subset_bytes || zero_word_bytes;
      count = indx_cb.subset_count;
      i = 0;
      indx_cb_ptr = indx_cb.temp_iocbp -> iocb.open_data_ptr;
      call seek_head (1, addr (subset_key), 8);		/* find start of current subset in temp file */

      do while ((i < count) & (pos_ptr ^= root_position_ptr));
         i = i + 1;
         common_sl_info.desc_arrayp -> desc_array_bytes (i) = substr (keys, key_pos (branch_num) + 4, 4);
						/* descriptor in lower word of temp key */
         branch_num = branch_num + 1;			/* advance to next */
         call find_this_entry;			/* handles exceptions */
      end;

      indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;	/* restore stuff for current file */
      pos_ptr = indx_cb.file_position_ptr;
      indx_cb.subset_count = i;
      common_sl_info.count = i;			/* in case count was wrong */
      return;					/* end of list_subset logic */

      dcl	    subset_key	       char (8) var;
      dcl	    desc_array_bytes       (1:common_sl_info.count) char (4) based (common_sl_info.desc_arrayp);
      dcl	    current_subset_bytes   char (4) based (addr (indx_cb.current_subset));
      dcl	    zero_word_bytes	       char (4) aligned;
      dcl	    count		       fixed;
      dcl	    i		       fixed;
   end count_subset;

generate_subset:					/* flag indicates whether select or exclude */
      if common_sl_info.list_type > max_list_type
      then go to bad_arg;
      else
         do;
	  if flag = select_flag
	  then next_subset = indx_cb.last_subset + 1;	/* select creates a new subset */
	  else if indx_cb.subset_selected = "00"b
	  then next_subset = indx_cb.last_subset + 1;
	  else next_subset = indx_cb.current_subset;	/* modify current subset */
	  if indx_cb.temp_iocbp = null		/* have not yet used temp switch */
	  then call get_temp_switch;
	  else if common_sl_info.delete_old_subsets
	  then if indx_cb.current_subset = 0
	       then call delete_old_subsets (indx_cb.temp_iocbp);
	       else
		do;
		   code = error_table_$bad_arg;
		   return;
		end;

	  count = 0;				/* will accumulate total count of descriptors */
	  temp_ak_inf.flags = "11"b;
	  temp_ak_inf.descriptor = 0;
	  temp_ak_inf.key_len = 8;
	  if (common_sl_info.list_type = 1) | (common_sl_info.status_only)
						/* array of intervals */
	  then
	     do;
	        current_retry_loc = init_retry;
	        saved_subset_selected = indx_cb.subset_selected;
	        saved_current_subset = indx_cb.current_subset;
	        go to initialize;
retry_loc (18):
	        call save_correct_pos;		/* in order to restore initial position */
	        indx_cb.pos_incorrect = "1"b;
	        if common_sl_info.status_only
	        then n_int = 1;
	        else n_int = common_sl_info.array_limit;
	        pad_key_ptr = addr (gk_pad_key);
	        last_info_ptr = addr (last_info_block (0));
	        last_info.new_last_info_ptr = addr (last_info_block (1));
	        new_last_info.new_last_info_ptr = last_info_ptr;

	        do i = 1 to n_int;			/* for each interval accumulate descriptors */
		 current_retry_loc = outer_retry;
outer_loop:
		 if common_sl_info.status_only
		 then
		    do;
		       last_head = "";
		       call position_bof;
		       if last_branch_num = 1		/* file is empty */
		       then go to next_interval;
		    end;
		 else
		    do;
		       if ((hi_sl_info.last_head.length (i) < 0)
			& (hi_sl_info.first_head.kptr (i) = hi_sl_info.last_head.kptr (i)))
						/* else exact match required */
		       then head_spec = "0"b;
		       else head_spec = "1"b;
		       if head_spec			/* interval defined in terms of first and last head */
		       then
			do;
			   pad_key_len = 256;	/* must pad with zeroes for valid seek_head */
			   unspec (
			      substr (pad_key, hi_sl_info.first_head.length (i) + 1,
			      256 - hi_sl_info.first_head.length (i))) = "0"b;
						/* pad with zeroes */
			   substr (pad_key, 1, hi_sl_info.first_head.length (i)) =
			      substr (hi_sl_info.first_head.kptr (i) -> bstring, 1,
			      hi_sl_info.first_head.length (i));
			   call seek_head (1, addr (pad_key_info), hi_sl_info.first_head.length (i));
			   if pos_ptr = indx_cb.root_position_ptr
						/* head not found */
			   then go to next_interval;
			   last_head =
			      substr (hi_sl_info.last_head.kptr (i) -> bstring, 1,
			      abs (hi_sl_info.last_head.length (i)));
			   if (hi_sl_info.last_head.length (i) < 0)
			   then open_ended = "1"b;
			   else open_ended = "0"b;
			end;
		       else
			do;			/* force exact match with given key */
			   open_ended = "0"b;
			   vpad_key =
			      substr (hi_sl_info.first_head.kptr (i) -> bstring, 1,
			      hi_sl_info.first_head.length (i));
			   file_position_ptr = root_position_ptr;
						/* prepare for descent */
			   call find_key (indx_cb_ptr, (addr (vpad_key)), search_code);
			   pos_ptr = file_position_ptr;
			   if search_code = 0	/* not found */
			   then go to next_interval;
			   call find_from_leaf;	/* in case match in upper node */
			   last_head_len = 256;
			   substr (last_head, 1, length (vpad_key)) = vpad_key;
			   substr (last_head, length (vpad_key) + 1, 256 - length (vpad_key)) =
			      substr (blanks, 1, 256 - length (vpad_key));
			end;
		    end;
		 last_key = substr (keys, key_pos (branch_num), key_length (branch_num));
		 last_descrip = record_designator (branch_num);

inner_loop:
		 do while (substr (last_key, 1, min (length (last_head), length (last_key))) <= last_head);
						/* pick up each index entry in this interval */
		    if substr (last_key, 1, min (length (last_head), length (last_key))) = last_head
						/*
						   exact match of head */
		    then if open_ended
		         then go to next_interval;	/* done with this interval */
		    if indx_cb.shared & ^indx_cb.leave_locked
						/* may have undergone asynch changes */
		    then if file_base.change_count ^= indx_cb.last_change_count
						/* has changed */
		         then
			  do;
			     call note_last_subset;
			     call prepare_process;
			     if current_retry_loc ^= inner_retry
			     then go to retry_loc (current_retry_loc);
retry_loc (19):
			     call find_entry (last_key, last_descrip);
			     if search_code = 0	/* prev entry not found */
			     then
			        do;		/* abort--can't find previous position */
				 call note_last_subset;
				 code = error_table_$asynch_deletion;
				 go to verify_done; /* may retry again if another asynch change */
			        end;
			     go to inner_loop;	/* resume inner loop scan from last position */
			  end;
		         else current_retry_loc = inner_retry;
		    if indx_cb.subset_selected ^= "00"b
		    then
		       do;
			call check_subset (last_descrip);
			if rec_deleted		/* this descriptor has been masked */
			then go to next_entry;	/* just skip to next */
		       end;
		    temp_key_words (1) = next_subset;
		    temp_key_words (2) = last_descrip;
		    call enter_temp_key;
next_entry:
		    branch_num = branch_num + 1;
		    call find_this_entry;
		    new_last_key = substr (keys, key_pos (branch_num), key_length (branch_num));
		    new_last_descrip = record_designator (branch_num);
		    last_info_ptr = last_info.new_last_info_ptr;
		    if pos_ptr = root_position_ptr	/* at eof */
		    then go to next_interval;		/* done with this interval */
		 end;

next_interval:
		 if indx_cb.shared & ^indx_cb.leave_locked
		 then if indx_cb.last_change_count ^= file_base.change_count
		      then
		         do;
			  if current_retry_loc ^= outer_retry
			  then go to retry_loc (current_retry_loc);
retry_loc (20):
			  call note_last_subset;
			  call prepare_process;
			  go to outer_loop;
		         end;
	        end;				/* end of outer loop */

	     end;					/* end of interval list case */
	  else if common_sl_info.list_type = 2		/* descriptor array specification */
	  then
	     do i = 1 to common_sl_info.array_limit;	/* use descriptors from list */
	        if indx_cb.subset_selected ^= "00"b
	        then call check_subset (da_sl_info.desc_array (i));
	        else rec_deleted = "0"b;
	        if ^rec_deleted
	        then
		 do;
		    temp_key_words (1) = next_subset;
		    temp_key_words (2) = da_sl_info.desc_array (i);
		    call enter_temp_key;
		 end;
	     end;

         end;					/* count is now known */
      if count = 0					/* no records found */
      then code = error_table_$no_record;
      else
         do;
	  code = 0;
	  if (flag = select_flag) | ((flag ^= select_flag) & (indx_cb.subset_selected = "00"b))
	  then indx_cb.subset_count = count;
	  else if indx_cb.subset_selected = "10"b
	  then indx_cb.subset_count = indx_cb.subset_count - count;
						/* entries removed from subset */
	  else indx_cb.subset_count = indx_cb.subset_count + count;
						/* entries added to exclude list */
	  indx_cb.current_subset = next_subset;
	  call note_last_subset;

	  if common_sl_info.status_only
	  then go to get_status;
	  if (flag = select_flag) | ((flag ^= select_flag) & (indx_cb.subset_selected = "10"b))
	  then indx_cb.subset_selected = "10"b;		/* pure selection */
	  else indx_cb.subset_selected = "01"b;		/* pure exclusion */
         end;
get_status:
      call get_subset_status;
      return;					/* end of generate subset--done with select or exclude */

get_temp_switch:
   proc;						/* obtains temp file for sorting descriptors */
      unique_name = unique_chars_ ("0"b) || ".temp.vfile_";
      proc_dir_string = get_pdir_ ();

      pd_path_len = index (proc_dir_string, " ") - 1;
      call iox_$attach_name (unique_name, iocbp, "vfile_ " || proc_dir_path || ">" || unique_name, null, code);
      call iox_$open (iocbp, 10, "0"b, code);
      call check_code (code, "Cannot open temporary subset file.");
      indx_cb.temp_iocbp = iocbp;
      dcl	    unique_chars_	       entry (bit (*)) returns (char (15));
      dcl	    1 proc_dirp_overlay,
	      2 pd_path_len	       fixed,
	      2 proc_dir_string    char (168);
      dcl	    proc_dir_path	       char (168) var based (addr (pd_path_len));
      dcl	    iocbp		       ptr;
   end get_temp_switch;

enter_temp_key:
   proc;						/* adds entry to temp file or removes entry and adjusts count */
      if (flag = select_flag) | ((flag ^= select_flag) & (indx_cb.subset_selected ^= "10"b))
      then
         do;
	  call control_indx_file (indx_cb.temp_iocbp, "add_key", addr (temp_ak_inf), code);
	  if code = 0
	  then count = count + 1;
	  else if code ^= error_table_$key_duplication
	  then
	     do;
	        call note_last_subset;
	        call check_code (code, "Can't add descriptor into current subset.");
	     end;
         end;
      else
         do;
	  call control_indx_file (indx_cb.temp_iocbp, "delete_key", addr (temp_ak_inf), code);
	  if code = 0
	  then count = count + 1;
	  else if code ^= error_table_$no_key
	  then
	     do;
	        call note_last_subset;
	        call check_code (code, "Can't remove descriptor from current subset.");
	     end;
         end;
   end enter_temp_key;

note_last_subset:
   proc;						/* keeps track of highest used subset number */
      if count = 0					/* no entries in new subset */
      then return;					/* no adjustment needed */
      indx_cb.last_subset = max (indx_cb.last_subset, next_subset);
   end note_last_subset;

reassign_key:					/* routine swaps record descrip for spec key */
      call verify_keyed_update;			/* checks opening mode */
      current_retry_loc = rk_retry;
      go to init_up_down;
retry_loc (21):
      saved_state.current_record_is_valid = indx_cb.current_record_is_valid;
      saved_state.current_descrip = indx_cb.current_descrip;
      pos_unchanged = "0"b;
      if ^rk_inf.input_key & indx_cb.outside_index	/* error--no key associated with current rec */
      then code = error_table_$no_key;
      else if ^rk_inf.input_old_desc | ^rk_inf.input_new_desc
						/* need current descrip */
      then call check_current;
      else if ^rk_inf.input_key			/* using current record's key */
      then
         do;
	  call check_current;			/* need current record to be defined */
	  if code ^= 0				/* error */
	  then code = error_table_$no_key;		/* set proper code */
         end;
      if code ^= 0
      then go to verify_done;				/* abort on error */
      if rk_inf.input_old_desc
      then old_des = rk_inf.old_descrip;
      else old_des = indx_cb.current_descrip;
      if rk_inf.input_new_desc
      then new_des = rk_inf.new_descrip;
      else new_des = indx_cb.current_descrip;
      if rk_inf.input_key
      then
         do;
	  if ^indx_cb.shared | ^saved_state.current_record_is_valid
	  then call save_correct_pos;
	  if ^indx_cb.at_bof & ^indx_cb.at_eof
	     & ((indx_cb.next_record_position ^= 0) | (indx_cb.current_record_is_valid & ^indx_cb.outside_index))
	     & (old_des = indx_cb.saved_descrip) & (indx_cb.new_key = key_to_reassign)
	  then
	     do;
	        if indx_cb.pos_incorrect
	        then
		 do;
		    call restore_position;
		    if (code = 0) & (record_designator (branch_num) ^= indx_cb.saved_descrip)
		    then code = error_table_$asynch_deletion;
						/* insist on same
						   descriptor */
		 end;
	        else pos_ptr = indx_cb.file_position_ptr;
	        pos_unchanged = "1"b;
	        first_code = 1;			/* anything non-zero indicates key was found */
	        search_code = 1;			/* indicates descriptor was found */
	     end;
	  else call find_entry (key_to_reassign, old_des);/* look for entry */
         end;
      else if rk_inf.input_old_desc			/* key is same, but entry may be different */
      then
         do;
	  if ^indx_cb.shared | ^saved_state.current_record_is_valid
	  then call save_correct_pos;
	  if old_des = indx_cb.saved_descrip
	  then
	     do;
	        pos_unchanged = "1"b;
	        first_code = 1;
	        search_code = 1;
	     end;
	  else call find_entry (indx_cb.new_key, old_des);
         end;
      else
         do;					/* file position is already correct */
	  first_code = 1;
	  search_code = 1;
	  pos_unchanged = "1"b;
         end;
      if ^pos_unchanged
      then indx_cb.pos_incorrect = "1"b;
      if first_code = 0				/* key not found */
      then code = error_table_$no_key;
      else if search_code = 0				/* key found, but not specified descrip */
      then code = error_table_$no_record;
      if code ^= 0
      then go to verify_done;
      indx_cb.current_descrip = old_des;
      if indx_cb.stat				/* look for ref counts */
      then
         do;
	  saved_state.outside_index = indx_cb.outside_index;
	  indx_cb.outside_index = "0"b;		/* in case of garbage collection */
	  call lock_current_record (block_ptr, lock_ptr, i_locked_rec_mask, -1);
						/* decrement old record ref count */
	  indx_cb.outside_index = saved_state.outside_index;
						/* restore */
	  if code ^= 0
	  then if (code ^= error_table_$locked_by_this_process) & (code ^= error_table_$invalid_lock_reset)
	       then
		do;
		   if saved_state.current_record_is_valid
		   then indx_cb.current_descrip = saved_state.current_descrip;
		   else indx_cb.current_descrip = indx_cb.saved_descrip;
		   go to verify_done;
		end;
	  old_ref_cnt = ref_cnt;
	  current_retry_loc = reass_key_retry_2;
	  indx_cb.current_descrip = new_des;
retry_loc (22):
	  indx_cb.outside_index = "0"b;
	  call lock_current_record (new_block_ptr, new_lock_ptr, i_locked_new_mask, 1);
	  indx_cb.outside_index = saved_state.outside_index;
	  if (code ^= 0)
	  then if (code ^= error_table_$locked_by_this_process) & (code ^= error_table_$invalid_lock_reset)
	       then
		do;				/* undo any change and abort */
		   if saved_state.current_record_is_valid
		   then indx_cb.current_descrip = saved_state.current_descrip;
		   else indx_cb.current_descrip = indx_cb.saved_descrip;
		   go to unlock_exit;
		end;
	       else code = 0;			/* suppress non-fatal warning */
         end;
      else
         do;
	  block_ptr = null;
	  new_block_ptr = null;
         end;
      if saved_state.current_record_is_valid
      then indx_cb.current_descrip = saved_state.current_descrip;
      else indx_cb.current_descrip = indx_cb.saved_descrip;
      call initialize_substate;
      call set_rk_info;				/* saves info for recovery */
      file_action = reassigning_key;
      file_base.change_count = file_base.old_file_ch_count + 1;
      if block_ptr ^= null
      then if block_ptr -> record_block.stationary
	 then
	    do;
	       block_ptr -> stat_struct.ref_count_after = file_base.old_ref_count;
	       block_ptr -> stat_struct.ref_count = file_base.old_ref_count;
	    end;
      if new_block_ptr ^= null
      then if new_block_ptr -> record_block.stationary
	 then
	    do;
	       new_block_ptr -> stat_struct.ref_count_after = file_base.new_ref_count;
	       new_block_ptr -> stat_struct.ref_count = file_base.new_ref_count;
	    end;
      record_descrip (branch_num) = file_base.new_descriptor;
      go to switch_file_state;			/* end of reassign key routine */

set_rk_info:
   proc;						/* saves reassign key info for recovery */
      if repeating
      then
         do;
	  pos_ptr = indx_cb.file_position_ptr;		/* reconstruct during recovery */
	  call check_file_substate;
	  return;
         end;
      if (block_ptr = null)
      then file_base.was_stat = "0"b;
      else if block_ptr -> record_block.stationary
      then
         do;
	  file_base.was_stat = "1"b;
	  file_base.old_ref_count = old_ref_cnt;
         end;
      else file_base.was_stat = "0"b;
      if (new_block_ptr ^= null)
      then if new_block_ptr -> record_block.stationary
	 then
	    do;
	       file_base.was_stat = "1"b;
	       file_base.new_ref_count = ref_cnt;
	    end;
      file_base.new_descriptor = new_des;
      file_base.old_record_designator = old_des;		/* now save index location in convenient header variables */
      file_base.first_branch = node;			/* same protected variable used by rewrite */
      file_base.count = branch_num;
      file_substate = file_substate + 1;		/* note this block of code has been completed */
   end set_rk_info;

set_lock_list_entry:
   proc (block_ptr_arg, passive_ref_mask);		/* add non-passive reference list entry after
						   verifying any prior reference */
      passive = "0"b;
      must_verify = indx_cb.shared;
      go to main;
add_lock_list_entry:
   entry (block_ptr_arg, passive_ref_mask);		/* create entry for new record */
      passive = "0"b;
      must_verify = "0"b;
      go to main;
set_ref_list_entry:
   entry (block_ptr_arg);				/* adds item to passive ref list */
      passive = "1"b;				/* not locking an item */
      must_verify = "1"b;
main:
      if indx_cb.tcfp -> iocb.open_data_ptr -> indx_cb.reflp = null
      then
         do;					/* initialize ref list */
	  call transaction_call_$setup_ref_list (indx_cb.tcfp, er_code);
	  call check_code (er_code, "Unable to initialize a transaction reference list.");
         end;
      refp = indx_cb.tcfp -> iocb.open_data_ptr -> indx_cb.reflp;
      if indx_cb.uid = "0"b				/* comp 0 uid has not yet been obtained */
      then call init_uid_info;			/* gets uid--by now file will be an msf */
      temp_key.transaction_number = current_t_code;
      temp_key.file_id = indx_cb.uid;			/* for process independent record locator */
      temp_key.rec_id = indx_cb.current_descrip;
      temp_key.blockp = block_ptr_arg;			/* this shouldn't really be necessary when right */
      if ^must_verify				/* just add lock list entry for new record */
      then
         do;					/* don't bother to verify */
	  temp_ak_inf.flags = "11"b;
	  temp_ak_inf.key_len = 16;			/* short form */
	  temp_ak_inf.descrip = -1;			/* non-passive reference */
	  call iox_$control (refp, "add_key", addr (temp_ak_inf), er_code);
	  if (er_code ^= 0) & (er_code ^= error_table_$key_duplication)
						/* avoid cost of calling check_code if not needed */
	  then call check_code (er_code, "Can't create a ref list entry for the new record.");
	  return;
         end;
      temp_key.time = 0;				/* pad with 0's */
      temp_rk_inf.key_len = 22;
      indx_cb_ptr = refp -> iocb.open_data_ptr;		/* set up for seek_head */
      call seek_head (0, addr (temp_rk_inf.key_len), 12);	/* sets pos_ptr to root if fails */
      if (passive & ((cur_mod = 0) | (cur_mod = -1))) /* modifier isn't enough to uniquely
						   identify this record's image */
         | (^passive & (block_ptr_arg -> stat_struct.prev_mod = 0))
						/* prev image requires
						   long form verification */
      then
         do;
	  temp_key.time = time_stamp;
	  temp_rk_inf.old_descrip = ind_desc;
	  if passive				/* record modifier will be non-positive */
	  then temp_rk_inf.new_descrip = ind_desc;	/* also setting add_key's
						   descriptor in info structure */
	  else temp_rk_inf.new_descrip = -1;
         end;
      else
         do;					/* short form ref list entry */
	  temp_rk_inf.key_len = 16;
	  temp_rk_inf.old_descrip = cur_mod;		/* current image id */
	  if ^passive
	  then temp_rk_inf.new_descrip = -1;		/* this value means ref is to lock */
	  else temp_rk_inf.new_descrip = cur_mod;
         end;
      if pos_ptr ^= indx_cb.root_position_ptr		/* not first ref */
      then if (record_designator (branch_num) = temp_rk_inf.old_descrip)
	    & (substr (keys, key_pos (branch_num), key_length (branch_num)) = rk_key)
	 then
	    do;					/* prev ref is verified */
	       indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
	       pos_ptr = indx_cb.file_position_ptr;	/* restore local environment */
	       if ^passive				/* verified ref was to lock */
	       then
		do;
		   cleanup_flags = cleanup_flags | passive_ref_mask;
						/* remember that refl entry exists */
		   if temp_rk_inf.key_len = 16	/* old ref in short form */
		   then
		      do;				/* just reassign--already short form */
		         temp_rk_inf.flags = "111"b;	/* input all params */
		         call iox_$control (refp, "reassign_key", addr (temp_rk_inf), er_code);
		         if er_code ^= 0		/* optimization */
		         then call
			       check_code (er_code,
			       "Can't convert a short form passive ref list entry into a non-passive one.");
		      end;			/* end of simple reassignment case */
		   else
		      do;				/* convert long form passive entry into
						   short form non-passive ref list entry */
		         temp_ak_inf.key_len = 16;
		         temp_ak_inf.flags = "11"b;	/* input key and desc */
		         call iox_$control (refp, "add_key", addr (temp_ak_inf), er_code);
						/* add new entry before removing old one */
		         if (er_code ^= 0) & (er_code ^= error_table_$key_duplication)
		         then call
			       check_code (er_code,
			       "Can't add a non-passive ref list entry for a previous long form passive reference.")
			       ;
		         temp_ak_inf.key_len = 22;	/* set up to delete
						   long form entry */
		         temp_ak_inf.descrip = ind_desc;
		         call iox_$control (refp, "delete_key", addr (temp_ak_inf), er_code);
		         if er_code ^= 0
		         then call
			       check_code (er_code,
			       "Can't delete the old long form passive ref list entry for a subsequently modified item."
			       );
		      end;
		end;
	    end;					/* end of verified ref case */
	 else
	    do;					/* error--prev reference invalid */
	       indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
	       pos_ptr = indx_cb.file_position_ptr;
	       if key_length (branch_num) = 16
	       then if record_designator (branch_num) = -1/* thought I locked it--maybe interrupted */
		  then if block_ptr_arg -> stat_struct.record_lock = indx_cb.saved_lock_copy
		       then return;			/* suppress error message */
	       code = error_table_$asynch_change;
	    end;
      else
         do;					/* add a ref list entry for first ref this transaction */
	  indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
	  pos_ptr = indx_cb.file_position_ptr;
	  temp_ak_inf.flags = "11"b;
	  if ^passive
	  then temp_ak_inf.key_len = 16;		/* create short form entry */
	  call iox_$control (refp, "add_key", addr (temp_ak_inf), er_code);
	  if er_code ^= 0
	  then call check_code (er_code, "Can't create a new ref list entry for this item.");
         end;					/* end of no previous reference case */
      return;					/* done with ref list manipulation */

init_uid_info:
   proc;						/* gets uid for this file from component 0 */
						/* also may create a ref list entry to remember iocb_ptr, if no such entry
						   already exists for this file in this process */
      call hcs_$get_uid_seg (indx_cb.file_base_ptr, uid_val, er_code);
      call check_code (er_code, "Cannot get a uid for the file.");
      unspec (gk_inf.flags) = "0"b;
      gk_inf.input_key = "1"b;
      gk_inf.head_size = 12;
      gk_inf.key_len = 12;
      gk_key.zero = 0;
      gk_key.proc_id = indx_cb.saved_lock_copy;
      gk_key.file_id = uid_val;
      refp = indx_cb.tcfp -> iocb.open_data_ptr -> indx_cb.reflp;
      call iox_$control (refp, "get_key", addr (gk_inf), er_code);
      if er_code = 0				/* file is known to this ref list */
      then if gk_desc = iocb_ptr			/* this I/O switch */
	 then return;				/* nothing more to do--refl entry is fine */
	 else
	    do;					/* set refl entry to use this iocb_ptr */
	       string (rk_inf.flags) = "111"b;
	       rk_inf.old_descrip = rk_inf.new_descrip;	/* set by gk */
	       gk_desc = iocb_ptr;			/* new descrip for reassign_key */
	       call iox_$control (refp, "reassign_key", addr (rk_inf), er_code);
	       call
		check_code (er_code, "Can't reset default iocb_ptr for this file in the transaction reference list.");
	    end;
      else
         do;					/* attempt to create new refl entry */
	  string (ak_inf.flags) = "11"b;		/* input key and desc */
	  gk_desc = iocb_ptr;
	  call iox_$control (refp, "add_key", addr (ak_inf), er_code);
	  call check_code (er_code, "Can't save the iocb_ptr for this file in the transaction reference list.");
         end;
      indx_cb.uid = uid_val;
      dcl	    refp		       ptr;
      dcl	    uid_val	       bit (36) aligned;
      dcl	    er_code	       fixed (35);
      dcl	    1 rk_inf,
	      2 header	       like rk_header,
	      2 key	       char (12);
      dcl	    1 gk_inf	       based (addr (rk_inf.old_descrip)),
	      2 header	       like gk_header,
	      2 key	       char (12);
      dcl	    1 ak_inf	       based (addr (rk_inf.old_descrip)),
	      2 header	       like ak_header,
	      2 key	       char (12);
      dcl	    gk_desc	       ptr unal based (addr (gk_inf.descrip));
      dcl	    1 gk_key	       based (addr (gk_inf.key)),
	      2 zero	       fixed (35),
	      2 proc_id	       bit (36) aligned,
	      2 file_id	       bit (36) aligned;
   end init_uid_info;

      dcl	    passive	       bit (1) aligned;
      dcl	    must_verify	       bit (1) aligned;
      dcl	    er_code	       fixed (35);
      dcl	    1 temp_rk_inf,
	      2 flags	       bit (36) aligned,
	      2 old_descrip	       fixed (35),
	      2 new_descrip	       fixed (35),
	      2 key_len	       fixed,
	      2 key	       char (22);
      dcl	    1 temp_ak_inf	       based (addr (temp_rk_inf.old_descrip)),
	      2 flags	       bit (36) aligned,
	      2 descrip	       fixed (35),
	      2 key_len	       fixed,
	      2 key	       char (22);
      dcl	    refp		       ptr;
      dcl	    1 temp_key	       based (addr (temp_rk_inf.key)),
	      2 transaction_number fixed (35),
	      2 file_id	       bit (36) aligned,
	      2 rec_id	       fixed (35),
	      2 blockp	       ptr unal,		/* should not be needed when done right */
	      2 time	       fixed (53) unal;	/* long form only */
      dcl	    rk_key	       char (22) var based (addr (temp_rk_inf.key_len));
      dcl	    block_ptr_arg	       ptr;
      dcl	    passive_ref_mask       bit (36) aligned;
   end set_lock_list_entry;

restore_abort:
   proc;						/* cleans up after unusual abort */
      indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
      indx_cb.pos_incorrect = "1"b;			/* restore indx_cb state */
      call restore_state;
      if cleanup_flags = "000000"b
      then return;					/* nothing to unlock */
      aborting = "1"b;
      if i_locked_file
      then if stacq (file_base.lock_word, (36)"1"b, indx_cb.saved_lock_copy)
	 then ;					/* invalidate file lock */
      if i_locked_rec & (block_ptr ^= null) & (lock_ptr ^= null)
      then if indx_cb.trans
	 then if block_ptr -> record_block.stationary
	      then if (block_ptr -> stat_struct.modifier > 0) & (block_ptr -> stat_struct.modifier = current_t_code)
		 then ;				/* leave old record locked--has a lock list entry */
		 else if old_passive_ref
		 then ;
		 else go to inv_old;
	      else go to inv_old;
	 else
	    do;
inv_old:
	       if stacq (lock_ptr -> based_lock, (36)"1"b, indx_cb.saved_lock_copy)
	       then ;
	    end;
      if i_locked_new & (new_block_ptr ^= null) & (new_lock_ptr ^= null)
      then if indx_cb.trans
	 then if new_block_ptr -> record_block.stationary
	      then if (new_block_ptr -> stat_struct.modifier > 0)
		    & (new_block_ptr -> stat_struct.modifier = current_t_code)
		 then ;
		 else if new_passive_ref
		 then ;
		 else go to inv_new;
	      else go to inv_new;
	 else
	    do;
inv_new:
	       if stacq (new_lock_ptr -> based_lock, (36)"1"b, indx_cb.saved_lock_copy)
	       then ;
	    end;
   end restore_abort;

restore_state:
   proc;						/* re-establishes initial values of process vars which may have been clobbered */
      indx_cb.mode = atb.opening_mode;
      indx_cb.is_sequential_open = (indx_cb.mode < 11);
      indx_cb.is_read_only = substr ("0001000100100"b, indx_cb.mode, 1);
      indx_cb.is_ks_out = (indx_cb.mode = 9);
      if current_retry_loc = skip_retry			/* position skip attempt */
      then indx_cb.error = saved_error_info;
      else if (current_retry_loc = init_retry) | (current_retry_loc = inner_retry) | (current_retry_loc = outer_retry)
						/* select or exclude */
      then
         do;					/* restore subset state */
	  indx_cb.subset_selected = saved_subset_selected;
	  indx_cb.current_subset = saved_current_subset;
         end;
      indx_cb.state_vars = saved_state;
   end restore_state;

open_file:
      call create_indx_cb;
      if is_new_file
      then call initialize_new_file;
      else if file_version ^= current_file_version
      then
         do;
	  call check_file_version (indx_cb_ptr, code);	/* checks for pre-crashproof version */
	  if code ^= 0
	  then
	     do;
	        saved_state.shared = indx_cb.shared;
	        call free_cb_file (size (indx_cb), indx_cb_ptr);
	        if ^substr ("0001000100100"b, atb.opening_mode, 1) & saved_state.shared
	        then call set_lock_$unlock (lock_word, foo);
	        return;
	     end;
         end;
      else call check_comp_array_table;			/* To catch bad tables produced by bug in */
						/* check_file_version . */
      call create_seg_ptrs (iocb_ptr);
      call create_position_stack (indx_cb_ptr);
      if (file_action ^= 0) & ^is_read_only & (file_action ^= read_exclude)
      then if file_base.program_version > current_program_version
	 then
	    do;
	       code = error_table_$unimplemented_version;
	       call
		sub_err_ (code, "vfile_", "c", null, code,
		"Can't adjust operation in progress with this version of vfile_.");
	    end;
	 else
	    do;
	       call restart (iocb_ptr, code);
	       fs_ptr = indx_cb.file_state_ptr;
	    end;
      if (file_base.program_version < current_program_version_2) & indx_cb.stat & ^indx_cb.is_read_only & (code = 0)
      then
         do;
	  code = error_table_$unimplemented_version;
	  call
	     sub_err_ (code, "vfile_", "c", null, code, "Old version file does not support -stationary attach option.");
         end;
      foo = 0;					/* in case of cleanup */
      if code = 0
      then call set_entries_and_positions;
      else go to cleanup_exit;
      if is_read_only
      then return;
      if indx_cb.read_exclu
      then file_action = read_exclude;
      cleanup_flags = "100000"b;			/* just unlock the file */
      current_retry_loc = cleanup_retry;		/* initialize this variable */
      go to unlock_exit;

close_indx_file:
   entry (iocb_ptr);
      indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
      f_b_ptr = file_base_ptr;
      indx_cb.file_state_ptr = addr (file_state_blocks (file_state));
      fs_ptr = indx_cb.file_state_ptr;
      o_s_ptr = addr (file_state_blocks (1 - file_state));
      os_ptr = o_s_ptr;

      foo = 0;
      on seg_fault_error
         begin;
	  foo = error_table_$lock_wait_time_exceeded;
	  go to cleanup_exit;
         end;
      if indx_cb.shared & ^is_read_only & ^leave_locked
      then
         do;					/* prepare to set bit counts */
	  call set_lock (addr (file_base.lock_word), 0, foo);
	  if foo = error_table_$lock_wait_time_exceeded
	  then go to cleanup_exit;
	  if old_last_comp_num ^= last_comp_num		/* new component */
	  then
	     do;					/* recreate the seg_ptr_array */
	        call free_seg_ptrs (iocb_ptr);
	        call create_seg_ptrs (iocb_ptr);
	     end;
         end;
      if ^is_read_only
      then call set_bitcounts (iocb_ptr);
retry_loc (23):
cleanup_exit:
      revert seg_fault_error;
      call free_seg_ptrs (iocb_ptr);
      call free_position_stack (indx_cb_ptr);
      call discard_temp_file (indx_cb.temp_iocbp);	/* subset file
						   can be thrown away, if one exists */
      call discard_temp_file (indx_cb.reflp);		/* for transaction
						   control file only--throw away temporary reference list */
      lock_copy = indx_cb.saved_lock_copy;
      call free_cb_file (size (indx_cb), indx_cb_ptr);
      if substr ("0001000100100"b, atb.opening_mode, 1) | (foo = error_table_$locked_by_this_process)
         | (foo = error_table_$lock_wait_time_exceeded)
      then return;					/* don't unlock in this case */
      if file_action = read_exclude
      then file_action = 0;				/* clear read lock */
      if file_action = 0
      then
         do;
	  unspec (spare_node) = "0"b;			/* free unneeded storage */
	  if stacq (file_base.lock_word, "0"b, lock_copy) /* unlock */
	  then ;
         end;
      else if stacq (file_base.lock_word, (36)"1"b, lock_copy)
      then ;					/* make it look like I died */
      return;					/* end of close routine */

set_entries_and_positions:
   proc;
      close_x = close_indx_file;
      iocb_ptr -> iocb.control = control_indx_file;
      go to open_case (mode);
open_case (4):					/* sequential input */
      indx_cb.at_bof = "1"b;
      iocb_ptr -> iocb.read_record = read_indx_file;
      iocb_ptr -> iocb.read_length = read_length_indx_file;
      iocb_ptr -> iocb.position = position_indx_file;
      return;
open_case (7):					/* sequential update */
      indx_cb.at_bof = "1"b;
      iocb_ptr -> iocb.read_record = read_indx_file;
      iocb_ptr -> iocb.read_length = read_length_indx_file;
      iocb_ptr -> iocb.position = position_indx_file;
      iocb_ptr -> iocb.rewrite_record = rewrite_indx_file;
      iocb_ptr -> iocb.delete_record = delete_indx_file;
      return;
open_case (8):					/* keyed sequential input */
      indx_cb.at_bof = "1"b;
      iocb_ptr -> iocb.read_record = read_indx_file;
      iocb_ptr -> iocb.read_length = read_length_indx_file;
      iocb_ptr -> iocb.read_key = read_key_indx_file;
      iocb_ptr -> iocb.position = position_indx_file;
      iocb_ptr -> iocb.seek_key = seek_key_indx_file;
      return;
open_case (9):					/* keyed sequential output */
      indx_cb.at_eof = "1"b;
      iocb_ptr -> iocb.seek_key = seek_key_ks_out;
      iocb_ptr -> iocb.write_record = write_indx_file;
      return;
open_case (10):					/* keyed sequential update */
      indx_cb.at_bof = "1"b;
      iocb_ptr -> iocb.read_record = read_indx_file;
      iocb_ptr -> iocb.read_length = read_length_indx_file;
      iocb_ptr -> iocb.read_key = read_key_indx_file;
      iocb_ptr -> iocb.position = position_indx_file;
      iocb_ptr -> iocb.seek_key = seek_key_indx_file;
      iocb_ptr -> iocb.control = control_indx_file;
      iocb_ptr -> iocb.write_record = write_indx_file;
      iocb_ptr -> iocb.rewrite_record = rewrite_indx_file;
      iocb_ptr -> iocb.delete_record = delete_indx_file;
      return;
open_case (11):					/* direct input */
      iocb_ptr -> iocb.read_record = read_indx_file;
      iocb_ptr -> iocb.read_length = read_length_indx_file;
      iocb_ptr -> iocb.seek_key = seek_key_indx_file;
      return;
open_case (12):					/* direct output */
      iocb_ptr -> iocb.seek_key = seek_key_indx_file;
      iocb_ptr -> iocb.write_record = write_indx_file;
      return;
open_case (13):					/* direct update */
      iocb_ptr -> iocb.read_record = read_indx_file;
      iocb_ptr -> iocb.read_length = read_length_indx_file;
      iocb_ptr -> iocb.seek_key = seek_key_indx_file;
      iocb_ptr -> iocb.write_record = write_indx_file;
      iocb_ptr -> iocb.rewrite_record = rewrite_indx_file;
      iocb_ptr -> iocb.delete_record = delete_indx_file;
   end set_entries_and_positions;

create_indx_cb:
   proc;						/* creates open data structure */
      code = 0;
      call alloc_cb_file (size (indx_cb), iocb_ptr -> iocb.open_data_ptr);
      indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
      fcb_ptr = fcb_ptr_arg;
      file_base_ptr = first_seg_ptr;
      f_b_ptr = file_base_ptr;
      last_change_count = change_count;			/* must be saved before referencing file_state */
      mode = mode_arg;
      is_sequential_open = (mode < 11);
      is_read_only = substr ("0001000100100"b, mode, 1);
      is_ks_out = (mode = 9);
      indx_cb.next_record_position = 0;
      indx_cb.current_record_is_valid = "0"b;
      indx_cb.ready_to_write = "0"b;
      indx_cb.shared = atb.shared;
      indx_cb.wait_time = atb.wait_time;
      repeating = "0"b;
      file_state_ptr = addr (file_state_blocks (file_state));
      fs_ptr = file_state_ptr;
      o_s_ptr = addr (file_state_blocks (1 - file_state));
      indx_cb.error.type = 0;				/* used by "error_status" control order */
      indx_cb.at_bof = "0"b;				/* used in shared openings for asynch re-seeks */
      indx_cb.at_eof = "0"b;
      indx_cb.min_res = 0;				/* default is no spare space allocated with records */
      indx_cb.min_cap = 0;				/* default is not to allocate null recs */
      leave_locked = "0"b;				/* if shared, will leave unlocked between operations */
      indx_cb.outside_index = "0"b;			/* may be set by "record_status" */
      dup_ok = atb.dup_ok_sw | (duplicate_keys ^= 0);
      indx_cb.stat = atb.stat_sw;			/* -stat option used */
      indx_cb.read_exclu = atb.exclu_sw;		/* may be set by "set_file_lock" order */
      indx_cb.pos_incorrect = "1"b;			/* may be set by "add_key", etc. */
      indx_cb.saved_lock_copy = "0"b;			/* in case happens to contain a valid lock */
      call set_lock_$lock (indx_cb.saved_lock_copy, 0, foo);
      indx_cb.new_key = "";
      file_position_ptr = null;
      indx_cb.min_key_len = file_base.minimum_key_length;	/* non-zero for old files */
      indx_cb.skip_state = 0;				/* default is to scan forward over deletions */
      indx_cb.current_subset = 0;
      indx_cb.last_subset = 0;
      indx_cb.subset_selected = "00"b;
      indx_cb.temp_iocbp = null;
      indx_cb.trans = atb.trans_sw;			/* set if -transaction attachment */
      if indx_cb.trans
      then indx_cb.tcfp = atb.tcf_iocbp;		/* ptr to transaction control iocb */
      else indx_cb.tcfp = null;
      indx_cb.transaction_code = 0;
      indx_cb.reflp = null;				/* used in transaction control file only */
      indx_cb.collection_delay_time = 0;
   end create_indx_cb;
check_comp_array_table:
   proc;

/*  This  looks  through  the comp_table comp_links for any component which is
   greater  than  the  maximum  component in use, identified by last_comp_num.
   Should  such a bogus comp_link be found, sub_err_ is signaled and vfile_ is
   ground to an unrestartable stop.  */

      dcl	    table_idx	       fixed bin (35);
      do table_idx = lbound (comp_table, 1) to hbound (comp_table, 1);
         if comp_table.comp_link (table_idx) > file_base.last_comp_num
         then if is_read_only
	    then call
		  sub_err_ (error_table_$bad_file, "vfile_", "c", null, code,
		  "Previous modifications to this file may have resulted 
in lost data, due to incorrect information in the file_base 
of this file.  Type ""help damaged_keyed_files"" for more information.
  Processing will continue.");
	    else
	       do;
		if stacq (file_base.common_header.lock_word, "0"b, indx_cb.saved_lock_copy)
		then ;
		call
		   sub_err_ (error_table_$bad_file, "vfile_", "s", null, error_table_$bad_file,
		   "This file cannot safely be 
updated due to incorrect information in its 
file_base.  Type ""help damaged_keyed_files"" 
for more information.");
	       end;
      end;
   end;

discard_temp_file:
   proc (iocbp);					/* cleanup routine for subsets and ref lists */
      if iocbp = null
      then return;					/* nothing to discard */
      call iox_$close (iocbp, foo);
      unique_name =
         substr (iocbp -> iocb.attach_descrip_ptr -> based_vstring,
         length (iocbp -> iocb.attach_descrip_ptr -> based_vstring) + 1 - length (unique_name), length (unique_name));
						/* unique name of temp file from attach description */
      call hcs_$delentry_file (get_pdir_ (), unique_name, foo);
						/* delete temporary index */
      call iox_$detach_iocb (iocbp, foo);
      call iox_$destroy_iocb (iocbp, foo);
      iocbp = null;
      dcl	    iocbp		       ptr;
      dcl	    foo		       fixed (35);
   end discard_temp_file;

initialize_new_file:
   proc;						/* At this point all words except the common header are zero. This routine sets the nonzero values */
      program_version = current_program_version;
      max_seg_limit = component_size_arg;
      minimum_block_size = minimum_block_size_val;
      node_size = node_size_val;
      last_branch_num_root = 1;
      do foo = 0, 1;
         addr (index_state_blocks (foo)) -> new_key_pos = node_head_length + branch_and_descrip_length + 1;
      end;
      max_comp_num = true_max_comp_num;
      seg_limit (0) = node_size * (1 + divide (size (file_base) + node_size - 1, node_size, 17, 0));
      call hcs_$set_bc_seg (file_base_ptr, 36 * size (file_base), foo);
      file_version = current_file_version;		/* creation is thus atomic */
      return;
      dcl	    hcs_$set_bc_seg	       entry (ptr,		/* pointer to seg, input */
			       fixed bin (24),	/* bit count to be set */
			       fixed bin (35));	/* status code */
   end initialize_new_file;

check_file_substate:
   proc;						/* keeps track of logical block during recovery execution */
      next_substate = next_substate + 1;
      if file_substate = next_substate
      then repeating = "0"b;				/* execution resumes normally */
   end check_file_substate;

check_code:
   proc (er_code, message);				/* unusual abort detector */
      if er_code = 0
      then return;
      code = er_code;				/* give code back to caller after warning */
      call sub_err_ (code, "vfile_", "c", null, code, message);
      indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
      indx_cb.pos_incorrect = "1"b;
      if cleanup_flags = "000000"b
      then go to passive_abort;
      aborting = "1"b;
      go to unlock_exit;
      dcl	    er_code	       fixed (35);
      dcl	    message	       char (*);
   end check_code;

/* DECLARATIONS */
      dcl	    i_locked_rec_mask      static internal options (constant) bit (36) aligned
			       init ("010101000000000000000000000000000000"b);
      dcl	    i_locked_new_mask      static internal options (constant) bit (36) aligned
			       init ("001010100000000000000000000000000000"b);
      dcl	    rec_lock_mask	       static internal options (constant) bit (36) aligned
			       init ("011000000000000000000000000000000000"b);
      dcl	    negmod_mask	       static internal options (constant) bit (36) aligned
			       init ("000001100000000000000000000000000000"b);
      dcl	    passive_ref_bit_mask   static internal options (constant) bit (36) aligned
			       init ("000110000000000000000000000000000000"b);
      dcl	    old_passive_ref_mask   static internal options (constant) bit (36) aligned
			       init ("000100000000000000000000000000000000"b);
      dcl	    new_passive_ref_mask   static internal options (constant) bit (36) aligned
			       init ("000010000000000000000000000000000000"b);
      dcl	    seek_kso_retry	       static internal options (constant) init (1);
      dcl	    seek_retry	       static internal options (constant) init (2);
      dcl	    read_len_retry	       static internal options (constant) init (3);
      dcl	    read_key_retry	       static internal options (constant) init (4);
      dcl	    read_retry	       static internal options (constant) init (5);
      dcl	    skip_retry	       static internal options (constant) init (6);
      dcl	    pos_bof_or_eof_retry   static internal options (constant) init (7);
      dcl	    gk_retry	       static internal options (constant) init (8);
      dcl	    rs_retry_2	       static internal options (constant) init (9);
      dcl	    rs_retry_1	       static internal options (constant) init (10);
      dcl	    sh_retry	       static internal options (constant) init (11);
      dcl	    rew_retry	       static internal options (constant) init (12);
      dcl	    write_retry	       static internal options (constant) init (13);
      dcl	    del_retry	       static internal options (constant) init (14);
      dcl	    adj_retry	       static internal options (constant) init (15);
      dcl	    ak_retry	       static internal options (constant) init (16);
      dcl	    dk_retry	       static internal options (constant) init (17);
      dcl	    init_retry	       static internal options (constant) init (18);
      dcl	    inner_retry	       static internal options (constant) init (19);
      dcl	    outer_retry	       static internal options (constant) init (20);
      dcl	    rk_retry	       static internal options (constant) init (21);
      dcl	    reass_key_retry_2      static internal options (constant) init (22);
      dcl	    cleanup_retry	       static internal options (constant) init (23);
      dcl	    lock_file_retry	       static internal options (constant) init (24);
      dcl	    adj_file_retry	       static internal options (constant) init (25);
      dcl	    based_area	       area based;
      dcl	    system_freep	       ptr static internal init (null);
      dcl	    get_system_free_area_  entry returns (ptr);
      dcl	    delete_old_subsets     entry (ptr);
      dcl	    rec_deleted	       bit (1) aligned;
      dcl	    (stacq, string, clock, addrel, hbound,index,lbound,stac)
			       builtin;
      dcl	    len		       fixed;
      dcl	    1 saved_state	       like indx_cb.state_vars;
      dcl	    saved_state_block      char (length (current_state_block)) based (addr (saved_state));
      dcl	    saved_subset_selected  bit (2) aligned;
      dcl	    saved_current_subset   fixed (34);
      dcl	    1 saved_error_info     like indx_cb.error;
      dcl	    current_state_block    char (4 * size (fixed_state_block) + 4 + length (indx_cb.new_key))
			       based (addr (indx_cb.state_vars));
      dcl	    1 fixed_state_block    like indx_cb.fixed_state_part based;
      dcl	    os_ptr	       ptr;
      dcl	    branches_left	       fixed;
      dcl	    count		       fixed (34);
      dcl	    chunk_size	       fixed (34);
      dcl	    first_code	       fixed (35);
      dcl	    key_is_dup	       bit (1) aligned;
      dcl	    passive_op	       bit (1) aligned;
      dcl	    del_cur	       bit (1) aligned;
      dcl	    fault_ok	       bit (1) aligned;
      dcl	    (any_other, seg_fault_error)
			       condition;
      dcl	    cleanup	       condition;
      dcl	    current_retry_loc      fixed;
      dcl	    need_pos	       fixed static options (constant) internal init (5);
      dcl	    time_left	       fixed;
      dcl	    timeout	       fixed (71);
      dcl	    eternity	       static internal options (constant) fixed (71) init (1f70b);
      dcl	    new_change_count       fixed (35);
      dcl	    continue_to_signal_    entry (fixed (35));
      dcl	    branch_and_descrip_length
			       static options (constant) fixed init (12);
      dcl	    node_head_length       static options (constant) fixed init (16);
      dcl	    restart	       entry (ptr, fixed (35));
      dcl	    check_file_version     entry (ptr, fixed (35));
      dcl	    find_key	       entry (ptr, ptr, fixed (35));
      dcl	    find_key$last	       entry (ptr, ptr, fixed bin (35));
      dcl	    set_lock_$lock	       entry (bit (36) aligned, fixed, fixed (35));
      dcl	    set_lock_$unlock       entry (bit (36) aligned, fixed (35));
						/* Arguments */

      dcl	    buff_len	       fixed (21);
      dcl	    buff_ptr	       ptr;
      dcl	    close_x	       entry;
      dcl	    code		       fixed (35);
      dcl	    component_size_arg     fixed (19);
      dcl	    fcb_ptr_arg	       ptr;
      dcl	    first_seg_bitcount     fixed (24);
      dcl	    first_seg_ptr	       ptr;
      dcl	    iocb_ptr	       ptr;
      dcl	    is_new_file	       bit (1) aligned;
      dcl	    key		       char (256) varying;
      dcl	    mode_arg	       fixed;
      dcl	    pos_type	       fixed;
      dcl	    skip		       fixed;
      dcl	    rec_len	       fixed (21);

/* Local Variables */

      dcl	    1 current_des	       like designator_struct aligned based (addr (indx_cb.current_descrip));
      dcl	    record_action	       fixed;
      dcl	    record_len	       fixed (21);
      dcl	    record_ptr	       ptr;
      dcl	    foo		       fixed (35);
      dcl	    pos_ptr	       ptr;
      dcl	    buffer	       char (record_len) based (buff_ptr);
      dcl	    block_ptr	       ptr;
      dcl	    1 block_with_lock      based (block_ptr),
	      2 words	       (record_block.block_size - 1) fixed,
						/* body of block */
	      2 record_lock	       bit (36) aligned;	/* set/cleared by "record_status" order */
      dcl	    1 temp_ts_words	       aligned,
	      2 ind_offset	       bit (18) unal,
	      2 time_last_modified bit (54) unal;
      dcl	    1 new_rec_des	       based (addr (file_base.new_descriptor)),
	      2 comp	       fixed (17) unal,
	      2 offset	       bit (18) unal;
      dcl	    lock_ptr	       ptr;
      dcl	    based_vstring	       char (1000000) var based;
      dcl	    bstring	       char (1000000) based;
      dcl	    based_lock	       bit (36) aligned based;

      dcl	    1 ak_inf	       based (info_ptr),
	      2 header	       like ak_header,
	      2 key	       char (ak_inf.key_len);
      dcl	    1 rk_inf	       based (info_ptr),
	      2 header	       like rk_header,
	      2 key	       char (rk_inf.key_len);
      dcl	    1 gk_inf	       based (info_ptr),
	      2 header	       like gk_header,
	      2 key	       char (gk_inf.key_len);
      dcl	    ak_info_key	       char (256) var based (addr (ak_inf.key_len));
      dcl	    key_to_reassign	       char (256) var based (addr (rk_inf.key_len));
						/* File Parameter Values */
      dcl	    current_file_version   static options (constant) fixed init (40);
      dcl	    current_program_version
			       static options (constant) fixed init (41);
      dcl	    current_program_version_1
			       static options (constant) fixed init (32);
      dcl	    current_program_version_2
			       static options (constant) fixed init (33);
      dcl	    node_size_val	       static options (constant) fixed init (1024);
      dcl	    minimum_block_size_val static options (constant) fixed init (8);
      dcl	    msf_manager_$get_ptr   entry (ptr, fixed, bit (1), ptr, fixed (24), fixed (35));
      dcl	    1 record_block	       like record_block_structure based (block_ptr);
      dcl	    1 stat_struct	       like stat_structure based (block_ptr);
      dcl	    1 ind_struct	       like ind_structure based (block_ptr);
      dcl	    1 time_stamp_struct    like time_stamp_structure based (addr (stat_struct.time_stamp_words));
      dcl	    1 ind_des	       like ind_des_structure based (addr (ind_desc));

      dcl	    hcs_$delentry_file     entry (char (*), char (*), fixed (35));
      dcl	    hcs_$get_uid_seg       entry (ptr, bit (36) aligned, fixed (35));
      dcl	    unique_name	       char (27);
      dcl	    get_pdir_	       entry returns (char (168));
      dcl	    lock_copy	       bit (36) aligned;
      dcl	    ind_desc	       fixed (35);
      dcl	    cur_mod	       fixed (35);
      dcl	    transaction_call_$assign
			       entry (ptr, fixed (35), fixed (35));
      dcl	    transaction_call_$setup_ref_list
			       entry (ptr, fixed (35));
      dcl	    descrip_arg	       fixed (35);
      dcl	    rollback_sw	       bit (1) aligned;
      dcl	    p		       ptr;
      dcl	    modifier_arg	       fixed (35);
      dcl	    time_stamp	       fixed (71) aligned;
      dcl	    mod		       fixed (35);
      dcl	    cleanup_flags	       bit (36) aligned;
      dcl	    1 cleanup_flag_struct  based (addr (cleanup_flags)),
	      2 i_locked_file      bit (1) unal,
	      2 i_locked_rec       bit (1) unal,
	      2 i_locked_new       bit (1) unal,
	      2 old_passive_ref    bit (1) unal,
	      2 new_passive_ref    bit (1) unal,
	      2 i_set_negmod       bit (1) unal,
	      2 i_set_new_negmod   bit (1) unal,
	      2 aborting	       bit (1) unal,
	      2 pad	       bit (28) unal;
      dcl	    order		       char (*);
      dcl	    (
	    vfile_io_control,
	    vfile_io_control$af
	    )		       entry (ptr, ptr, ptr, fixed (35));
      dcl	    vfile_status_$seg      entry (ptr, ptr, ptr, fixed (35));
      dcl	    (info_ptr, info_ptr_arg)
			       ptr;
      dcl	    blanks	       char (256) aligned static internal options (constant) init ("");
      dcl	    1 gk_pad_key,
	      2 len	       fixed,
	      2 string	       char (256);
      dcl	    1 pad_key_info	       based (pad_key_ptr),
	      2 pad_key_len	       fixed,
	      2 pad_key	       char (256);
      dcl	    pad_key_ptr	       ptr;
      dcl	    1 info	       based (info_ptr),
	      2 rel_type	       fixed,
	      2 n		       fixed,
	      2 search_key	       char (0 refer (n));

      dcl	    1 mbs_info	       based (info_ptr),
	      2 min_residue	       fixed (21),		/* min unused capacity in bytes */
	      2 min_capacity       fixed (21);		/* minimum bytes which will be allocated */

      dcl	    1 error_info	       based (info_ptr),
	      2 version	       fixed bin (35),	/* must =1 (Input) */
	      2 type	       fixed bin (35),	/* identifies type of error--only one currently exists */
	      2 requested	       fixed bin (35),	/* skip arg passed to vfile_ for positioning */
	      2 received	       fixed bin (35);	/* skips completed successfully */
      dcl	    skip_error	       fixed static options (constant) internal init (1);
      dcl	    1 set_lock_info	       based (info_ptr) aligned,
	      2 set_lock_flag      bit (1) unal,	/* "1"b means lock, "0"b means unlock */
	      2 exclusive	       bit (1) unal;	/* "1"b means lock out readers too */
      dcl	    new_wait_time	       float based (info_ptr);
      dcl	    1 wt_info	       based (info_ptr),
	      2 version	       float,		/* -2 indicates collection delay, not new_wait_time */
	      2 collection_delay_time
			       float;
      dcl	    max_rec_wds	       fixed (19);
      dcl	    ref_cnt	       fixed;
      dcl	    delta_ref_count	       fixed;
      dcl	    new_block_ptr	       ptr;
      dcl	    new_lock_ptr	       ptr;
      dcl	    transaction	       defined indx_cb_ptr -> indx_cb.trans bit (1) aligned;
      dcl	    passive	       bit (1) aligned;
      dcl	    max_ref_count	       static internal options (constant) init (65535);
						/* 2**16 -1 */
      dcl	    sub_err_	       entry options (variable);
      dcl	    current_descrip	       fixed (35) defined indx_cb.current_descrip;
      dcl	    old_ref_cnt	       fixed;
      dcl	    new_des	       fixed (35);
      dcl	    old_des	       fixed (35);
      dcl	    pos_unchanged	       bit (1) aligned;
      dcl	    next_subset	       fixed (34);
      dcl	    i		       fixed;
      dcl	    last_head	       char (256) var;
      dcl	    last_head_len	       fixed based (addr (last_head));
      dcl	    temp_key_words	       (1:2) fixed bin (35) based (addr (temp_key));
      dcl	    vpad_key	       char (256) var based (addr (pad_key_info));
      dcl	    1 temp_ak_inf,
	      2 flags	       bit (36) aligned,
	      2 descriptor	       fixed (35),
	      2 key_len	       fixed,
	      2 temp_key	       char (8);
      dcl	    flag		       bit (1) aligned;
      dcl	    head_spec	       bit (1) aligned;
      dcl	    open_ended	       bit (1) aligned;
      dcl	    max_list_type	       static fixed options (constant) init (2) internal;
      dcl	    n_int		       fixed;
      dcl	    last_info_ptr	       ptr;
      dcl	    1 last_info_block      (0:1),
	      2 new_ptr	       ptr,
	      2 des	       fixed (35),
	      2 lkey	       char (256) var;
      dcl	    1 last_info	       based (last_info_ptr),
	      2 new_last_info_ptr  ptr,
	      2 last_descrip       fixed (35),
	      2 last_key	       char (256) var;
      dcl	    1 new_last_info	       based (last_info.new_last_info_ptr),
	      2 new_last_info_ptr  ptr,
	      2 new_last_descrip   fixed (35),
	      2 new_last_key       char (256) var;
      dcl	    select_flag	       static internal bit (1) aligned init ("0"b) options (constant);
      dcl	    exclude_flag	       static internal bit (1) aligned init ("1"b) options (constant);
      dcl	    timer_manager_$sleep   entry (fixed (71), bit (2));
      dcl	    min_max_rec_len	       static options (constant) internal fixed (21) init (24);
%page;
%include vf_attach_block;
%page;
%include iox_entries;
%page;
%include rs_info;
%page;
%include ak_info;
%page;
%include select_info;
%page;
%include vfile_error_codes;
%page;
%include vfile_indx;
%page;
%include iocb;
   end /* end open_indx_file */;
