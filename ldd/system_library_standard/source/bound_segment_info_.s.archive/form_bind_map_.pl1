/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   * Copyright (c) 1972 by Massachusetts Institute of        *
   * Technology and Honeywell Information Systems, Inc.      *
   *                                                         *
   *********************************************************** */


/* Form Bind Map - subroutine to produce a printable bind_map segment from the
   information stored in a bound object's symbol table.
Designed and Initially coded by Michael J. Spier, May 3, 1971	*/
/* modified 5/26/75 by M. Weaver  to use version 2 object_info_ structure */
/* modified 1/22/81 by E. N. Kittlitz for page_offset option */

form_bind_map_:	procedure(arg_pointer, code);

declare	arg_pointer pointer, code fixed bin(35);


	/* DECLARATION OF EXTERNAL ENTRIES */

declare	date_time_ external entry(fixed bin(71), char(*) aligned);
declare	get_bound_seg_info_ entry(ptr, fixed bin(24), ptr, ptr, ptr, fixed bin(35));
declare	(error_table_$oldobj, error_table_$bad_segment) external fixed bin(35);
declare	hcs_$fs_get_path_name external entry(ptr, char(*) aligned, fixed bin,
	char(*) aligned, fixed bin(35));
declare	hcs_$status_mins entry (ptr, fixed bin(2), fixed bin(24), fixed bin(35));
declare	ioa_$rs external entry options(variable);

	/* DECLARATION OF AUTOMATIC STORAGE VARIABLES */

declare	(j,k,lng,count,bfx,n_extra_bfs) fixed bin;
declare   i fixed bin (21);
declare   (tx_lng,tx_pg1,tx_pg2,tx_start) fixed bin (18);
declare	extra_bfs (20) fixed bin;
declare	trel fixed bin(18);
declare	bitcount fixed bin(24);
declare	(bm_lng,l1) fixed bin;
declare	(p,bmp,sblkp,mapp,listp,argp) pointer;
declare	wst char(256) aligned;
declare	(objname char(32), dirname char(168)) aligned;
declare	address char(12) aligned;
declare	bf_name char(32) aligned;
declare	short_date char(15) aligned;
declare	date char(24) aligned;
declare	maker char(40) aligned;
declare	(nl char(1), bnl char(2)) aligned;
declare	print bit(1) aligned;

declare	1 dd aligned,
	2 next_def pointer,
	2 last_def pointer,
	2 block_ptr pointer,
	2 section char(4) aligned,
	2 offset fixed bin,
	2 entrypoint fixed bin,
	2 defname char(32) aligned;

	/* DECLARATION OF BUILTIN FUNCTIONS */

declare	(addr,addrel,divide,fixed,index,rel,substr,unspec) builtin;

	/* DECLARATION OF BASED STRUCTURES */

declare	1 x aligned based(argp),
	2 objp pointer,			/* pointer to base of object segment */
	2 list_ptr pointer,			/* pointer to base of listing segment */
	2 list_bc fixed bin(21),		/* list segment bitcount */
	2 flags aligned,			/* option indicators */
	  3 pad bit(33) unaligned,		/* this field used to be fixed bin */
	  3 page_offset bit (1) unaligned,	/* "1"b->show text page number */
	  3 no_header bit(1) unaligned,	/* "1"b->do not print header */
	  3 long bit(1) unaligned,		/* 1 -> long option; 0 -> brief option */
	2 nopts fixed bin,			/* size of following option array */
	2 op(1000) aligned,
	  3 opt_name char(32) aligned,	/* name of option component */
	  3 opt_offset fixed bin,		/* desired option offset */
	  3 name_sw bit(1) unaligned,		/* 1 -> option name; 0 -> offset */
	  3 found bit(1) unaligned;		/* 1 -> option found; 0 -> not found */

declare	1 link_header aligned based(linkp),
	2 dum(3) pointer,
	2 link_begin bit(18) unaligned;

declare	1 map aligned based(mapp),
	2 decl_vers fixed bin,
	2 size fixed bin,
	2 entry(1000) aligned,
	  3 name_offset bit(18) unaligned,
	  3 name_length bit(18) unaligned,
	  3 uid fixed bin,
	  3 dtm fixed bin(71);

declare	1 omap(1000) aligned based(mapp),
	2 inp_ptr bit(18) unaligned,
	2 inp_lng bit(18) unaligned;

declare	string char(1000) aligned based(oi.symbp);
declare	bind_map char(10000) based(listp);


/*  */

declare	1 oi aligned like object_info;

%include object_info;

/*  */

% include symbol_block;

/*  */

	/* Declaration of obsolete symbol block temporarily
	   generated by the binder			*/

declare	1 symblk_head aligned based(sblkp),

	2 block_id char(8) aligned,		/* identifier of this symbol block */
	2 dcl_version fixed bin,		/* version number of this structure = 1 */
	2 comp_version_number fixed bin,	/* generator's version number */
	2 comp_creation_time fixed bin(71),	/* compiler creation time (compatible with old symb table) */
	2 object_creation_time fixed bin(71),	/* clock reading (compatible with old symb table) */
	2 comp_id char(8) aligned,		/* identifier of object generator */
	2 comp_version_name,
	  3 name_ptr bit(18) unaligned,	/* pointer to string */
	  3 name_lng bit(18) unaligned,	/* length of string */
	2 userid,
	  3 id_ptr bit(18) unaligned,		/* pointer to userid string */
	  3 id_lng bit(18) unaligned,		/* lng of userid string */
	2 comment,
	  3 com_ptr bit(18) unaligned,	/* pointer to comment string */
	  3 com_lng bit(18) unaligned,	/* length of comment string */
	2 source_map_ptr bit(18) unaligned,	/* pointer to array of sourcefile specifiers */
	2 source_map_size bit(18) unaligned,	/* dimension of source map */
	2 block_ptr bit(18) unaligned,	/* pointer to beginning of symbol block */
	2 section_base bit(18) unaligned,	/* backpointer to symbol section base */
	2 block_size bit(18) unaligned,	/* size of symbol block (incl header) */
	2 next_block bit(18) unaligned,	/* thread to next symbol block */
	2 rel_text bit(18) unaligned,		/* pointer to text relocation bits */
	2 rel_link bit(18) unaligned,		/* pointer to linkage relocation bits */
	2 rel_symbol bit(18) unaligned,	/* pointer to symbol relocation bits */
	2 mini_truncate bit(18) unaligned,	/* minimum truncate value */
	2 maxi_truncate bit(18) unaligned;	/* maximum truncate value */

/*  */

% include bind_map;

/*  */

	argp = arg_pointer;			/* copy for efficiency */
	listp = list_ptr;			/* ... */
	bm_lng = divide(list_bc,9,21,0);	/* convert bitcount into character count */
	code = 0;				/* preset error code */
	count = 0;			/* preset count to see how many opts were processed */
	bfx, n_extra_bfs = 0;	/* preset counts for bindfile names */
	unspec(nl) = "000001010"b;
	unspec(bnl) = "000001111000001010"b;

	call hcs_$fs_get_path_name(objp,dirname,lng,objname,code);
	if code ^= 0 then goto return_noline;
	call hcs_$status_mins(objp,(0),bitcount,code);
	if code ^= 0 then goto return_noline;

	oi.version_number = object_info_version_2;
	call get_bound_seg_info_(objp, bitcount, addr(oi), bmp, sblkp, code);
	if code ^= 0 then goto return_noline;

	if bindmap.dcl_version = 1 then bf_name = " ";	/* no bindfile info */
	else do;		/* extract name for comparisons */
	     p = addrel(sblkp, bindmap.bf_name_ptr);
	     lng =fixed(bindmap.bf_name_lng, 18);
	     bf_name = substr(p -> string, 1, lng);
	end;

print_bind_map:
	if no_header then go to print_components;
	if nopts > 0 then goto print_header;
	maker = " ";
	if oi.userid ^= " " then
	do;
	     substr(maker,1,5) = ", by ";
	     substr(maker,6,32) = oi.userid;
	end;
	call date_time_(oi.compile_time, date);
	call ioa_$rs("^2/Bindmap for ^a>^a^/Created on ^a^a",wst,l1,dirname,objname,date,maker);
	substr(bind_map,bm_lng+1,l1) = substr(wst,1,l1);	/* copy into bind_map area */
	bm_lng = bm_lng + l1;		/* update length */
	i = fixed(oi.cvers.offset, 18)*4 +1;
	lng = fixed(oi.cvers.length, 18);
	if ^oi.format.separate_static
	then call ioa_$rs("using ^a",wst,l1,substr(string,i,lng));
	else call ioa_$rs("using ^a^/with separate static",wst,l1,substr(string,i,lng));
	substr(bind_map,bm_lng+1,l1) = substr(wst,1,l1);	/* copy into bind_map area */
	bm_lng = bm_lng + l1;		/* update length */
	if oi.source_map ^= 0 then
	do;			/* there is a source map */
	     mapp = addrel(sblkp, oi.source_map);
	     if oi.format.old_format = "0"b
	     then j = map.size;
	     else j = fixed(source_map_size, 18);
	     do i = 1 to j;		/* print out source map */
		if oi.format.old_format = "0"b then
		do;
		     p = addrel(sblkp,map.entry(i).name_offset);
		     lng = fixed(map.entry(i).name_length, 18);
		end;
		else do;
		     p = addrel(sblkp, omap(i).inp_ptr);
		     lng = fixed(omap(i).inp_lng, 18);
		end;
		call ioa_$rs("^a",wst,l1,substr(p->string,1,lng));
		substr(bind_map,bm_lng+1,l1) = substr(wst,1,l1);	/* copy into bind_map area */
		bm_lng = bm_lng + l1;		/* update length */
	     end;
	end;


	call ioa_$rs("^/^8xObject    Text    Defs    Link    Symb  Static",wst,l1);
	substr(bind_map,bm_lng+1,l1) = substr(wst,1,l1);	/* copy into bind_map area */
	bm_lng = bm_lng + l1;		/* update length */
	trel = fixed(rel(oi.textp), 18); 		/* Find offset of text (eg, for component of archive) */
	call ioa_$rs("Start   ^6o  ^6o  ^6o  ^6o  ^6o  ^6o",wst,l1,
		     fixed(rel(oi.textp), 18) - trel, fixed(rel(oi.textp), 18) - trel, fixed(rel(oi.defp), 18) - trel,
		     fixed(rel(oi.linkp), 18) - trel, fixed(rel(oi.symbp), 18) - trel, fixed(rel(oi.statp), 18) - trel);

	substr(bind_map,bm_lng+1,l1) = substr(wst,1,l1);	/* copy into bind_map area */
	bm_lng = bm_lng + l1;		/* update length */
	call ioa_$rs("Length  ^6o  ^6o  ^6o  ^6o  ^6o  ^6o",wst,l1,divide(bitcount,36,18,0),oi.tlng,
		     oi.dlng, oi.llng, oi.slng, oi.ilng);
	substr(bind_map,bm_lng+1,l1) = substr(wst,1,l1);	/* copy into bind_map area */
	bm_lng = bm_lng + l1;		/* update length */

print_header:
	call ioa_$rs("^2/Component^28x^[^3xText^2x^;Text^]^8xInt-Stat^7xSymbol^[^9xDate^6xSource^]",wst,l1,page_offset,long);
	substr(bind_map,bm_lng+1,l1) = substr(wst,1,l1);	/* copy into bind_map area */
	bm_lng = bm_lng + l1;		/* update length */
	call ioa_$rs("^33xStart Length^[ Page^]  Start Length  Start Length^[^3xCompiled^4xLanguage^]^/",wst,l1,page_offset,long);
	substr(bind_map,bm_lng+1,l1) = substr(wst,1,l1);	/* copy into bind_map area */
	bm_lng = bm_lng + l1;		/* update length */
print_components:
	do i = 1 to n_components;
	     print = "1"b;			/* assume line will be printed */
	     p = addrel(sblkp, component(i).name_ptr);
	     lng = fixed(component(i).name_lng, 18);
	     tx_start = fixed(component(i).text_start, 18);
	     tx_lng = fixed(component(i).text_lng, 18);
	     tx_pg1 = divide (tx_start, 1024, 18, 0);
	     tx_pg2 = divide (tx_start + tx_lng - 1, 1024, 18, 0);
	     if nopts > 0 then		/* there are options */
	     do;
		print = "0"b;		/* assume line won't be printed */
		do j = 1 to nopts;		/* lookup option table */
		     if op(j).name_sw = "1"b then
		     do;
			if op(j).opt_name = substr(p->string,1,lng) then
			do;
display:
			     op(j).found = "1"b;
			     k = k + 1;
			     print = "1"b;
			     count = count + 1;
			end;
		     end;
		     else do;
			if op(j).opt_offset >= tx_start then
			if op(j).opt_offset < tx_start + tx_lng then goto display;
		     end;
		end;
	     end;

	     if print = "0"b then goto skip;
	     j = fixed(component(i).symb_start,18);	/* get symbol table offset */
	     mapp = addrel(oi.symbp, j);		/* pointer to component's symbol table */
	     call date_time_(mapp->sb.obj_creation_time, date);
	     substr(short_date,1,8) = substr(date,1,8);
	     substr(short_date,9,7) = substr(date,10,7);
	     call ioa_$rs("^32a^6o ^6o^[^x^3o^[+^; ^]^;^2s^] ^6o ^6o ^6o ^6o^[ ^15a ^a^;^2s^]",wst, l1, 
		     substr(p->string,1,lng),
		     tx_start,tx_lng,
		     page_offset, tx_pg1, (tx_pg2 ^= tx_pg1),
		     fixed(component(i).stat_start,18),fixed(component(i).stat_lng,18),
		     j,fixed(component(i).symb_lng,18),
		     long,short_date,component(i).comp_name);
	     substr(bind_map,bm_lng+1,l1) = substr(wst,1,l1);	/* copy into bind_map area */
	     bm_lng = bm_lng + l1;		/* update length */
skip:
	end;

return:
	if nopts > 0 & count < nopts then do;	/* had errors */
	     if count = 0 then do;		/* had only errors */
		listp = list_ptr;		/* re-initialize; don't print any header */
		bm_lng = divide(list_bc, 9, 21, 0);
	     end;
	     else do;			/* separate map fram errors */
		substr(bind_map, bm_lng+1, 1) = nl;
		bm_lng = bm_lng + 1;
	     end;
	     do i = 1 to nopts;		/* rescan option table */
		if op(i).found = "0"b then
		do;
		if op(i).name_sw then do;
		     if index(op(i).opt_name, ".bind") > 0 then do;	/* special case bindfiles */
			if op(i).opt_name = bf_name then bfx = i;	/* real name was requested */
			else do;			/* just guessing; print error */
			     n_extra_bfs = n_extra_bfs + 1;
			     extra_bfs(n_extra_bfs) = i;
			end;
			l1 = 0;		/* nothing to add to output yet */
		     end;
		     else call ioa_$rs("Component ^a not found",wst,l1,op(i).opt_name);
		end;
		     else call ioa_$rs("Offset ^o out of bounds",wst,l1,op(i).opt_offset);
		     substr(bind_map,bm_lng+1,l1) = substr(wst,1,l1);	/* copy into bind_map area */
		     bm_lng = bm_lng + l1;		/* update length */
		end;
	     end;
	end;

	if bf_name = " " then do;		/* no bindfile info exists */
	     if n_extra_bfs = 0 then go to return_noline;	/* no bf info requested */
	     else do;
		call ioa_$rs("^/There is no bindfile information", wst, l1);
		substr(bind_map,bm_lng+1,l1) = substr(wst,1,l1);
		bm_lng = bm_lng + l1;
	     end;
	end;

	else do;			/* there is bindfile info */
		     if (nopts > 0) & (bfx = 0) & (n_extra_bfs = 0) then go to return_noline;
					/* but none was requested */
	     if (nopts = 0) | (bfx > 0) then do;	/* print bindfile info */
		if ^no_header then do;
		     call ioa_$rs("^2/Bindfile^[^28xDate Updated^8xDate Modified^]",wst,l1,long);
		     substr(bind_map, bm_lng+1, l1) = substr(wst,1,l1);
		     bm_lng = bm_lng + l1;
		end;
		call ioa_$rs("^/^34a^[^16a^4x^16a^;^2s^]",wst,l1,
		bf_name, long, bindmap.bf_date_up, bindmap.bf_date_mod);
		substr(bind_map, bm_lng+1, l1) = substr(wst, 1, l1);
		bm_lng = bm_lng + l1;
	     end;
	     if n_extra_bfs > 0 then do;
		substr(bind_map, bm_lng+1,1) = nl;	/* separate errors */
		bm_lng = bm_lng + 1;
		do i = 1 to n_extra_bfs;
		     call ioa_$rs("^a not found",wst,l1,op(extra_bfs(i)).opt_name);
		     substr(bind_map, bm_lng+1, l1) = substr(wst, 1, l1);
		     bm_lng = bm_lng + l1;
		end;
	     end;
	end;

return_noline:
	if (nopts > 0) & (count = 0) & (bfx = 0) then no_header = "1"b;
					/* had only errors; don't want title */
	list_bc = bm_lng * 9;		/* return new listing bitcount */

end	form_bind_map_;
