/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   * Copyright (c) 1972 by Massachusetts Institute of        *
   * Technology and Honeywell Information Systems, Inc.      *
   *                                                         *
   *********************************************************** */


get_bound_seg_info_: proc (objp, bitcount, oip, bmp, sblkp, code);

/*
   This procedure looks through the defs of an object segment to find the bindmap.

   Modified: 17 July 1981 by Jeff Ives to use decode_definition_$full which has no memory between calls
*/

	declare (objp, oip, bmp, sblkp) pointer;
	declare bitcount		 fixed bin (24);
	declare code		 fixed bin (35);

	declare (error_table_$not_bound, error_table_$bad_segment, error_table_$oldobj, error_table_$unimplemented_version) ext fixed bin (35);
	declare (addr, addrel, null, substr, unspec) builtin;
	declare eof		 bit aligned;
	declare decode_definition_$full entry (pointer, pointer, pointer, bit aligned);
	declare object_info_$display	 external entry (pointer, fixed bin (24), pointer, fixed bin (35));


	declare 1 dd		 aligned,		/* structure filled in by full entry */
		2 next_def	 ptr,		/* ptr to next definition in list */
		2 last_def	 ptr,		/* ptr to previous definition in list */
		2 block_ptr	 ptr,		/* ptr to either defblock or segname block */
		2 section		 char (4) aligned,	/* "text", "link", "symb" or "segn" */
		2 offset		 fixed bin,	/* offset within class (if ^= "segn") */
		2 entrypoint	 fixed bin,	/* value of entrypoint in text if ^= 0 */
		2 symbol		 char (256) aligned,/* the symbolic name of the definition */
		2 symbol_lng	 fixed bin,	/* the actual length of symbol */
		2 flags,				/* same flags as in std def */
		  3 a_new_format	 bit (1) unaligned, /* def is in new format */
		  3 a_ignore	 bit (1) unaligned, /* linker should ignore this def */
		  3 a_entrypoint	 bit (1) unaligned, /* def is for entrypoint */
		  3 a_retain	 bit (1) unaligned,
		  3 a_arg_count	 bit (1) unaligned, /* there is an arg count for entry */
		  3 a_descr_sw	 bit (1) unaligned, /* there are valid descriptors for entry */
		  3 unused	 bit (12) unaligned,
		2 n_args		 fixed bin,	/* # of args entry expects */
		2 descr_ptr	 ptr;		/* ptr to array of rel ptrs to descriptors for entry */

/*  */
	declare 1 oi		 aligned based (oip) like object_info;

%include object_info;

/*  */

%include symbol_block;

/*  */

%include symbol_block_header;

/*  */
	bmp, sblkp = null ();			/* initialize */

/* ASSUME THE USER HAS ALREADY SET THE VERSION NUMBER */
	call object_info_$display (objp, bitcount, oip, code); /* get basic object info (for caller too) */
	if code ^= 0 then return;			/* couldn't find bind map if there was one */

	if oi.version_number = object_info_version_2 then do; /* have new structure */
		if ^oi.format.standard then if ^oi.format.old_format then do;
			     code = error_table_$bad_segment; /* have non-standard new format seg; don't process */
			     return;
			end;

		unspec (dd) = ""b;			/* safety first! */
		dd.next_def = oi.defp;		/* initialize definition lookup */

lookup_defs:
		call decode_definition_$full ((dd.next_def), addr (dd), addr (oi), eof);

		if eof then do;			/* have looked at all the definitions */
			if oi.compiler = "binder  " then code = error_table_$oldobj; /* bound but has no bindmap */
			else code = error_table_$not_bound; /* assume anything not generated by binder is not bound */
			return;
		     end;

		if dd.flags.a_ignore
		then go to lookup_defs;

		if substr (dd.symbol, 1, dd.symbol_lng) = "bind_map" then if dd.section = "symb" then do; /* should have real bindmap */
			     sblkp = addrel (oi.symbp, dd.offset); /* get ptr to binder's symbol block */
			     if oi.format.standard then bmp = addrel (sblkp, sb.area_ptr);
			     else bmp = addrel (sblkp, symblk_head.block_ptr);
			     return;
			end;

		goto lookup_defs;			/* get next definition */
	     end;
	else code = error_table_$unimplemented_version;

     end get_bound_seg_info_;
