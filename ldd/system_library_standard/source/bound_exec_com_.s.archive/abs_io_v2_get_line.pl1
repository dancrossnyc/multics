/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(86-03-13,Herbst), approve(86-04-17,MCR7376),
     audit(86-04-17,Kissel), install(86-04-22,MR12.0-1041):
     Fixed bug where null &else failed to close an &if-&then-&else.
  2) change(87-06-04,Parisek), approve(87-07-23,MCR7716),
     audit(87-08-07,Fawcett), install(87-08-11,MR12.1-1080):
     Continue execution with next exec_com line when abs_io_data.noabort
     is ON.
  3) change(87-09-18,Parisek), approve(87-09-18,PBF7716),
     audit(87-09-21,Farley), install(87-09-21,MR12.1-1111):
     Set end_ec & goto ERROR_RETURN label when noabort is ON if error
     occurs on the last line of the exec_com.
  4) change(88-08-08,TLNguyen), approve(88-08-08,MCR7934),
     audit(88-09-15,Parisek), install(88-09-16,MR12.2-1111):
     Make the &exit statement and the &goto LABEL statement constructed within
     the &on unit work as documented.  Also fixed a size condition and
     stringrange condition raised while fixing errors.
  5) change(88-09-29,TLNguyen), approve(88-09-29,PBF7934),
     audit(88-09-30,Parisek), install(88-10-04,MR12.2-1128):
     Remove unnessesary label searching within the &label block, and
     make more extensive checks for the value of goto_entry_sw and
     abs_data.label_search_sw in determining what action to take when
     inside an &on unit block in the exec_com/absin.
                                                   END HISTORY COMMENTS */


/* format: off */

abs_io_v2_get_line:  proc (A_iocb_ptr, A_buffer_ptr, A_buffer_len, A_return_len) returns (fixed (35));


/* Implements &version 2 exec_com language; reads and executes control lines from an input file
   until it encounters a non-control line, then returns this expanded line. */

/* Added &print_switch{_nnl} 10/20/81 Steve Herbst */
/* Modified: 15 February 1982 by G. Palter for new calling sequence of ec_data.eval_string */
/* Fixed &if-&then-&else to be impervious to imbedded get_line 04/20/82 Steve Herbst */
/* Fixed to detect all cases of null &then and &else clauses 07/19/82 Steve Herbst */
/* Fixed to detect missing &quit statement 07/28/82 Steve Herbst */
/* Changed to zero xd.label_search_values to be filled in by abs_io_expand_ 10/06/82 Steve Herbst */
/* Fixed &label inside &do group to not destroy block info 11/15/82 Steve Herbst */
/* Fixed &is_af and "Missing &quit statement" line number 12/07/82 Steve Herbst */
/* Fixed &goto to position correctly to 1st char in target line 02/24/83 Steve Herbst */
/* Added &on, &begin, &revert, etc., also added $goto for handler's nonlocal &goto 04/07/83 Steve Herbst */
/* Added &attach &trim on/off 06/02/83 Steve Herbst */
/* Added &list_variables (&lsv) 06/07/83 Steve Herbst */
/* Fixed &if...&then...BLANK LINE&else... 07/22/83 Steve Herbst */
/* Fixed bug causing &on unit to screw up later &if's 10/13/83 Steve Herbst */
/* Fixed &else<NL>&if to be a null &else rather than an &else &if 10/13/83 Steve Herbst */
/* Changed to set abs_data.goto_pl1_label for absentee_listen_, doing &goto from an &on unit 11/17/83 Steve Herbst */
/* Fixed not to wait until non-ctl line to set abs_data.(position limit) 11/30/83 Steve Herbst */
/* Removed useless and undocumented "Missing &quit statement" warning 11/30/83 Steve Herbst */
/* Made &on accept commas as well as white space between condition names 01/25/84 Steve Herbst */
/* Made ec -trace, -no_trace override &trace statements 03/20/84 Steve Herbst */
/* Added &all_types, &all_expansions keywords to &trace 05/03/84 Steve Herbst */
/* Fixed &revert, &signal, &trace to parse result of expansion yielding "token1 token2" 07/18/84 Steve Herbst */
/* Fixed bug that stopped skipping while inside skipped &do-&end 08/03/84 Steve Herbst */
/* Fixed bug where a handler's &end fouled up later &if-&then skipping 08/10/84 Steve Herbst */
/* Fixed &list_variables bug that used default value seg if no variables set 08/10/84 Steve Herbst */
/* Fixed end-of-file processing to log out an absentee only if not executing an &on unit 09/17/84 Steve Herbst */
/* Fixed $goto to record found label in hash table 01/02/85 Steve Herbst */
/* Fixed &on-&end to not require the &end to be followed by a newline character 01/03/85 Steve Herbst */
/* Fixed &goto not to allocate storage if label has already been parsed 02/15/85 Steve Herbst */
/* Fixed to free parsed_args structure allocated by abs_io_expand_ 02/19/85 Steve Herbst */


/* Parameters */

dcl A_goto_label char (*);
dcl (A_iocb_ptr, iocb_ptr) ptr;			/* ptr to IOCB of abs_io_ or syn_ attached to abs_io_ */
dcl (A_abs_data_ptr, A_ec_data_ptr) ptr;			/* ptr to caller's info structures (for $goto) */
dcl (A_buffer_ptr, buffer_ptr) ptr;			/* ptr to caller's input buffer */
dcl (A_buffer_len, buffer_len) fixed bin (21);		/* max length (in chars) of caller's buffer */
dcl (A_return_len, actual_len) fixed bin (21);		/* length of data actually returned */
dcl A_code fixed bin (35);				/* standard status code */
%page;
/* Constants */

/* NOTE: These next five values depend on the values of the STMTS array in abs_io_expand_ */

dcl BEGIN_ACTION fixed bin int static options (constant) init (2);
dcl DO_ACTION fixed bin int static options (constant) init (6);
dcl ELSE_ACTION fixed bin int static options (constant) init (7);
dcl IF_ACTION fixed bin int static options (constant) init (13);
dcl THEN_ACTION fixed bin int static options (constant) init (35);



dcl DO_TYPE fixed bin int static options (constant) init (0);
dcl BEGIN_TYPE fixed bin int static options (constant) init (1);
dcl THEN_TYPE fixed bin int static options (constant) init (2);
dcl ELSE_TYPE fixed bin int static options (constant) init (3);

dcl NO_UPDATE bit (1) int static options (constant) init ("0"b);

dcl ALPHA char (52) int static options (constant) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");
dcl DIGITS char (10) int static options (constant) init ("0123456789");
dcl LABEL fixed bin int static options (constant) init (1);
dcl NL char (1) int static options (constant) init ("
");
dcl WHITE_SPACE char (4) int static options (constant) init (" 	");  /* SP HT VT FF */


/* Based */

dcl condition_array (condition_count) char (32) based (condition_array_ptr);

dcl 1 saved_if_info aligned like abs_data.if_info based;

dcl 1 default_args (abs_data.default_arg_count) based (abs_data.default_arg_ptr),
   2 ptr ptr,
   2 len fixed bin (21),
   2 quote_count fixed bin (21);

dcl default_values_ptr ptr;
dcl default_values (abs_data.default_arg_count) char (max_default_len) based (default_values_ptr);

dcl allocated_chars char (abs_data.allocated_chars_len) based (abs_data.allocated_chars_ptr);
dcl ec_path char (arg_info.ec_path_len) based (arg_info.ec_path_ptr);

dcl allocated_buffer char (alloc_len) based (xd.allocated_ptr);
dcl arg char (xd.arg_len) based (xd.arg_ptr);
dcl buffer char (buffer_len) based (buffer_ptr);
dcl goto_name char (goto_name_len) based (goto_name_ptr);
dcl input_string char (input_string.len) based (input_string.ptr);
dcl label_val char (label_val_len) based (label_val_ptr);
dcl remainder char (abs_data.chars_len) based (abs_data.chars_ptr);
dcl return_arg char (ec_data.return_len) varying based (ec_data.return_ptr);
dcl val_string char (val_len) based (val_ptr);
dcl var_string char (var_len) based (var_ptr);

dcl based_area area based (area_ptr);
dcl xd_area area based (xd.area_ptr);


/* Automatic */

dcl 1 xd aligned like expand_data;

dcl (message, switch_name) char (168);
dcl token char (128) varying;
dcl token32 char (32);

dcl (begin_line_sw, goto_entry_sw, nnl_sw, skipping_handler_sw, some_left_sw) bit (1);

dcl area_ptr ptr init (null);
dcl (condition_array_ptr, goto_name_ptr, handler_ptr, label_val_ptr, last_node_ptr, lastp) ptr;
dcl (on_saved_if_ptr, p, saved_if_ptr, saved_label_ptr, test_ptr, val_ptr, var_ptr) ptr;

dcl (active_string_pos, alloc_len, cond_string_len, goto_name_len, handler_len, handler_start) fixed bin (21);
dcl (label_val_len, max_default_len, name_len, saved_goto_pos) fixed bin (21);
dcl (saved_statement_len, saved_statement_pos, tpos, val_len, var_len) fixed bin (21);
dcl (condition_count, hash, i, saved_hash, saved_skip_block_level, search_type) fixed bin;
dcl code fixed bin (35);

dcl (area, bad_area_format, bad_area_initialization, cleanup) condition;


/* External */

dcl error_table_$badsyntax fixed bin (35) ext;
dcl error_table_$command_line_overflow fixed bin (35) ext;
dcl error_table_$end_of_info fixed bin (35) ext;
dcl error_table_$long_record fixed bin (35) ext;
dcl error_table_$noalloc fixed bin (35);
dcl error_table_$notalloc fixed bin (35) ext;

dcl abs_io_control$attach entry (ptr, ptr, fixed bin (35));
dcl abs_io_control$detach entry (ptr, ptr, fixed bin (35));
dcl abs_io_expand_ entry (1 aligned like expand_data, fixed bin (35));
dcl abs_io_expand_$expand_label entry (1 aligned like expand_data, fixed (21), fixed (21), ptr, fixed (21), fixed (35));
dcl (abs_io_expand_$delete, abs_io_expand_$set) entry (ptr, char (*), char (*), fixed bin (35));
dcl abs_io_expand_$label_search entry (1 aligned like expand_data, fixed bin (35));
dcl abs_io_expand_$skip entry (1 aligned like expand_data, fixed bin (35));
dcl abs_io_list_vars entry (ptr, ptr, char (*), fixed bin (35));
dcl (active_fnc_err_, com_err_) entry options (variable);
dcl cu_$evaluate_active_string entry (ptr, char (*), fixed bin, char (*) varying, fixed bin (35));
dcl cu_$arg_list_ptr entry returns (ptr);
dcl cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
dcl cu_$set_ready_mode entry (1 aligned like ready_mode);
dcl get_system_free_area_ entry returns (ptr);
dcl (ioa_, ioa_$nnl, ioa_$general_rs, ioa_$ioa_switch, ioa_$ioa_switch_nnl) entry options (variable);
dcl iox_$find_iocb entry (char (*), ptr, fixed bin (35));
dcl iox_$get_line entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
dcl iox_$look_iocb entry (char (*), ptr, fixed bin (35));
dcl iox_$user_input ptr ext;
dcl logout entry;
dcl signal_ entry options (variable);
dcl signal_io_error_ entry (char (*), ptr, fixed bin (35));

dcl 1 ready_mode aligned,
    2 flag bit (1) unaligned,
    2 pad bit (35) unaligned;

dcl input_linep bit (1) aligned;

dcl (addcharno, addr, binary, char, charno, codeptr, index, length, max, mod, null) builtin;
dcl (reverse, rtrim, search, substr, translate, unspec, verify) builtin;
%page;
START:
	goto_entry_sw, skipping_handler_sw = "0"b;

	A_code = 0;

	call get_data_ptrs (NO_UPDATE);

	if abs_data.active then
	     if abs_data.attach.save_ptr ^= null then do;	/* use previous attachment */
		call iox_$get_line (abs_data.attach.save_ptr, A_buffer_ptr, A_buffer_len, A_return_len, A_code);
		return (A_code);
	     end;
	     else call recurse_error;
	abs_data.active = "1"b;

	if ^abs_data.in_handler_sw then abs_data.get_line_pl1_label = START;
				/* target for &goto from inside &on unit invoked while inside this program */

	if abs_data.ec_data_ptr = null () then input_linep = "0"b;
	else input_linep = abs_data.ec_data_ptr -> ec_data.input_line;

	if abs_data.chars_len > 0 then do;		/* pending chars to return */

	     if input_linep ^= abs_data.last_input_line_sw then do;  /* changed input/command mode in mid-line */
		abs_data.chars_len = 0;
		free allocated_chars;
		go to EXPAND_NEXT_STMT;			/* flush the rest of the old line */
	     end;

	     if abs_data.chars_len > A_buffer_len then do;  /* return as much as will fit */
		some_left_sw = "1"b;
		actual_len = buffer_len;
	     end;
	     else do;				/* return it all */
		some_left_sw = "0"b;
		actual_len = abs_data.chars_len;
	     end;

	     substr (buffer, 1, actual_len) = substr (remainder, 1, actual_len);

	     if some_left_sw then do;
		abs_data.chars_ptr = addr (substr (remainder, actual_len + 1));
		abs_data.chars_len = abs_data.chars_len - actual_len;
		A_code = error_table_$long_record;
	     end;
	     else do;
		abs_data.chars_len = 0;
		free allocated_chars;
	     end;

RETURN:	     abs_data.last_input_line_sw = input_linep;
	     abs_data.active = "0"b;

	     if ^goto_entry_sw then A_return_len = actual_len;

	     return (A_code);
	end;

/* Initialize local expand_data */

	call init_xd ();

EXPAND_NEXT_STMT:
	if ^goto_entry_sw then do;
	     xd.caller_buffer_ptr = A_buffer_ptr;	/* expanded line will be returned in caller's buffer */
	     xd.caller_buffer_len = A_buffer_len;
	end;

	xd.allocated_ptr = null;
	xd.allocated_len = 0;

	if input_linep then xd.trace_lines = abs_data.input_line;
	else xd.trace_lines = abs_data.command_line;

	if abs_data.if_sw then call test_end_of_if ();

MIGHT_SKIP:
	if xd.parsed_args_ptr ^= null then free xd.parsed_args_ptr -> parsed_args in (xd_area);
	unspec (xd.expander_output) = "0"b;
	xd.arg_ptr, xd.parsed_args_ptr = null;

/* Call the expander */

	saved_statement_pos = xd.this_statement.pos;	/* in case we run off end with no &quit */

	i = 0;                                            /* in case it doesn't get set below we can avoid stringrange error */
	if xd.input_pos > 1 then                          /* to avoid stringrange condition raised when finding the substring */
						/* does the input substring characters begin with NL? */
	     i = verify (substr (input_string, xd.input_pos - 1), NL || WHITE_SPACE);

	if i < 2 then begin_line_sw = "0"b;               /* no, the input substring characters does not start with NL */
	else begin_line_sw = (index (substr (input_string, xd.input_pos - 1, i - 1), NL) ^= 0);

	if begin_line_sw & abs_data.next_action = IF_ACTION then do;  /* <NL>&if always starts a new &if statement */
	     abs_data.if_sw = "0"b;
	     if ^skipping_handler_sw & abs_data.skip_block_level = 0 then abs_data.skip_sw = "0"b;
	end;

	if abs_data.label_search_sw then do;
	     call abs_io_expand_$label_search (xd, code);
	     if code ^= 0 then
		if code = error_table_$end_of_info then go to END_OF_FILE;  /* label not found */
		else call error (code, xd.error_msg);
	end;

	else if abs_data.skip_sw then			/* after &if FALSE &then, skip to &else */
	     call abs_io_expand_$skip (xd, code);

	else call abs_io_expand_ (xd, code);

	if code ^= 0 then
	     if code = error_table_$end_of_info then do;
		if saved_statement_pos ^= 0 then xd.this_statement.pos = saved_statement_pos;
		else if xd.this_statement.pos = 0 then xd.this_statement.pos = abs_data.input_string.len - 1;
		go to END_OF_FILE;
	     end;
	     else call error (code, xd.error_msg);

	input_string.limit = max (input_string.limit, xd.input_pos - 1);  /* how far parsed by abs_io_expand_ */
	input_string.position = xd.input_pos;

	parsed_args_ptr = xd.parsed_args_ptr;

	if abs_data.if_sw & begin_line_sw &		/* previous &then or &else clause */
	     abs_data.this_action ^= THEN_ACTION &	/* and current stmt is neither &then nor &else */
	     abs_data.this_action ^= ELSE_ACTION then
		if abs_data.this_action = 0 &		/* except for blank line followed by &then or &else */
		     (abs_data.next_action = THEN_ACTION | abs_data.next_action = ELSE_ACTION) then;
		else do;				/* force end of &if construct */
		     abs_data.if_sw = "0"b;
		     if abs_data.skip_block_level = 0 then abs_data.skip_sw = "0"b;
		end;

	if abs_data.skip_sw then go to SKIP (abs_data.this_action);

	if abs_data.this_action = 0 then do;

	     if abs_data.label_search_sw then
		go to END_OF_FILE;			/* label search failed (no more &label stmts) */

RETURN_LINE:   if xd.caller_actual_len >= xd.caller_buffer_len then do;  /* no room to append NL */
		if xd.allocated_ptr = null then do;
		     alloc_len = 1;

		     allocate allocated_buffer in (abs_data.work_area) set (xd.allocated_ptr);

		     xd.allocated_buffer_len = 1;
		     xd.allocated_len = 0;
		end;
		xd.allocated_len = xd.allocated_len + 1;  /* append NL */
		substr (allocated_buffer, xd.allocated_len, 1) = NL;
		actual_len = xd.caller_actual_len;
		abs_data.allocated_chars_ptr, abs_data.chars_ptr = xd.allocated_ptr;
		abs_data.allocated_chars_len, abs_data.chars_len = xd.allocated_len;
		A_code = error_table_$long_record;
	     end;
	     else do;				/* fits in caller's buffer */
		substr (buffer, xd.caller_actual_len + 1, 1) = NL;
		actual_len = xd.caller_actual_len + 1;
		A_code = 0;
	     end;

	     go to RETURN;
	end;

	else go to ACTION (abs_data.this_action);
%page;
goto: entry (A_abs_data_ptr, A_ec_data_ptr, A_goto_label) returns (fixed bin (35));

/* Called by absentee_listen_$execute_handler if the handler did a nonlocal &goto */

	goto_entry_sw = "1"b;

	abs_data_ptr = A_abs_data_ptr;
	ec_data_ptr = A_ec_data_ptr;

	call init_xd ();
	xd.caller_buffer_ptr, xd.allocated_ptr = null;
	unspec (xd.trace_lines) = "0"b;
                                                            /* save the location and the length of the line containing "&goto LABEL_NAME" */
                                                            /* for later referenced in the error message when LABEL_NAME not found */
	xd.this_statement.pos = abs_data.goto_statement_pos;
	xd.this_statement.len = abs_data.goto_statement_len;

	goto_name_len = length (rtrim (A_goto_label, WHITE_SPACE));
	allocate goto_name in (abs_data.work_area) set (goto_name_ptr);
	goto_name = A_goto_label;

	go to GOTO_STMT;
%page;
ACTION (0):					/* end of the input file */

END_OF_FILE:
	call reset_input ();			/* implicit &detach at end of file */

	if abs_data.label_search_sw then do;

	     if abs_data.in_handler_sw & ^goto_entry_sw then do;
						/* nonlocal &goto out of &on unit */
		if abs_data.condition_name = "cleanup" then
		     call error (0, "Attempted nonlocal &goto from inside cleanup handler.");
		abs_data.goto_sw, abs_data.exit_sw = "1"b;
		abs_data.goto_label_ptr = addr (saved_label_ptr -> label.name);
		abs_data.goto_label_len = saved_label_ptr -> label.len;
		go to ERROR_RETURN;
	     end;

	     xd.this_statement.pos = saved_goto_pos;
	     xd.this_statement.len = saved_statement_len;

	     if search_type = LABEL then message = "Label ""^a"" not found.";
	     else message = "Search failed for ""^a"".";

	     call error (0, message, saved_label_ptr -> label.name);
	end;

ERROR_RETURN:
	abs_data.eof = "1"b;
	if ^goto_entry_sw then A_return_len = 0;

	if abs_data.absentee & ^abs_data.in_handler_sw then call logout;

	else return (error_table_$end_of_info);
%page;
/* NOTE: These labels correspond to the STMTS array in abs_io_expand_ */

ACTION (1):					/* &attach */
	if ec_data_ptr ^= null & ^attachedp () then do;
	     call abs_io_control$attach (abs_data_ptr, null, code);
	     if code ^= 0 then call error (code, "Error while performing &attach.");
	end;

	if parsed_args_ptr = null then abs_data.trim_whitespace_sw = "1"b;
	else if parsed_args.count = 0 then abs_data.trim_whitespace_sw = "1"b;
	else do;
	     xd.arg_ptr = parsed_args.ptr (1);
	     xd.arg_len = parsed_args.len (1);
	     if arg ^= "&trim" then call error (0, "Invalid &attach control argument " || arg || ".");
	     if parsed_args.count = 1 then abs_data.trim_whitespace_sw = "1"b;
	     else if parsed_args.count > 2 then call error (0, "Too many arguments for &attach.");
	     else do;
		xd.arg_ptr = parsed_args.ptr (2);
		xd.arg_len = parsed_args.len (2);
		if arg = "on" | arg = "true" then abs_data.trim_whitespace_sw = "1"b;
		else if arg = "off" | arg = "false" then abs_data.trim_whitespace_sw = "0"b;
		else call error (0, "Invalid argument to &attach &trim: " || arg);
	     end;
	end;

SET_INPUT_LIMIT:					/* done expanding and executing this control stmt */
	input_string.limit = max (input_string.limit, xd.input_pos - 1);  /* how far parsed by abs_io_expand_ */
	go to EXPAND_NEXT_STMT;


ACTION (2):					/* &begin */
	if abs_data.label_search_sw then do;

	     call execute_begin ();

	     go to SET_INPUT_LIMIT;
	end;
	else call error (0, "&begin not preceded by &on.");


ACTION (3):					/* &call (UNIMPLEMENTED) */
BAD_KEY:	call error (0, "Invalid keyword ^a",
	     substr (input_string, xd.this_statement.pos, xd.this_statement.keyword_len));


ACTION (4):					/* &default */
	call set_defaults (xd.parsed_args_ptr);
	go to SET_INPUT_LIMIT;


ACTION (5):					/* &detach */
	call reset_input ();
	go to SET_INPUT_LIMIT;


ACTION (6):					/* &do */
	call execute_do ();

	go to EXPAND_NEXT_STMT;


ACTION (7):					/* &else */
	abs_data.clause_type = ELSE_TYPE;

	call execute_else ();

	go to SET_INPUT_LIMIT;


ACTION (8):					/* &end */
END_STMT:
	call execute_end ();

	go to SET_INPUT_LIMIT;


ACTION (9):					/* &exit */
	if ^abs_data.in_handler_sw then call error (0, "&exit is allowed only inside an &on unit.");
	if parsed_args_ptr ^= null then do;
	     do i = 1 to parsed_args.count;
		xd.arg_ptr = parsed_args.ptr (i);
		xd.arg_len = parsed_args.len (i);
		if arg = "&continue" then abs_data.on_info.continue_to_signal_sw = "1"b;
		else call error (0, "Invalid &exit control argument " || arg || ".");
	     end;
	end;
	go to END_OF_FILE;


ACTION (10):					/* &entry (UNIMPLEMENTED) */
	go to BAD_KEY;


ACTION (11):					/* &function (UNIMPLEMENTED) */
/*
	block_ptr = allocate_block ();

	block.containing_lex_block_ptr = null;
	block.containing_proc_block_ptr = current_proc_block_ptr;
	block.args_ptr = xd.parsed_args_ptr;
	block.identifier = FUNCTION_TYPE;

	current_proc_block_ptr = block_ptr;
	current_lex_block_ptr = null;
	go to EXPAND_NEXT_STMT;
*/
	go to BAD_KEY;


ACTION (12):					/* &goto */
	abs_data.goto_statement_pos = xd.this_statement.pos;
	abs_data.goto_statement_len = xd.this_statement.len;

	goto_name_len, xd.arg_len = length (rtrim (arg, WHITE_SPACE));
	allocate goto_name in (abs_data.work_area) set (goto_name_ptr);
	goto_name = arg;

GOTO_STMT:
	label_ptr = lookup_label (abs_data.labels_ptr, goto_name, hash);  /* see if the right &label was seen */

	if label_ptr ^= null then do;			/* already compiled label */
	     xd.input_pos = label.statement_pos + label.statement_len + 1;
	     if label.lex_block_ptr ^= null then do;	/* target is inside a &do group */
		abs_data.if_info = label.lex_block_ptr -> block.if_info;

/* Check for &goto into a &do group (not allowed).
   When &proc's are added, check for &goto's into &proc's too. */

		do test_ptr = abs_data.current_lex_block_ptr
		  repeat (test_ptr -> block.containing_lex_block_ptr)
		  while (test_ptr ^= label.lex_block_ptr);
		     if test_ptr = null then call error (0, "&goto into a &do group");
		end;
	     end;
	     abs_data.current_lex_block_ptr = label.lex_block_ptr;
	     free goto_name in (abs_data.work_area);
	     if goto_entry_sw then do;
		input_string.limit = max (input_string.limit, xd.input_pos - 1);
		input_string.position = xd.input_pos;
		return (0);			/* return from $goto */
	     end;
	     else go to EXPAND_NEXT_STMT;		/* start executing after the label stmt */
	end;

	saved_label_ptr = allocate_label (goto_name);	/* create a node for the &label when found */
	saved_hash = hash;				/* save everything */
	saved_goto_pos = xd.this_statement.pos;
	saved_statement_len = xd.this_statement.len;

	abs_data.label_search_sw = "1"b;
	unspec (xd.label_search_values) = "0"b;		/* next &do, &end, etc. for searching */
	xd.searching_for = goto_name;			/* for error message */
	search_type = LABEL;
	free goto_name in (abs_data.work_area);
	go to EXPAND_NEXT_STMT;


ACTION (13):					/* &if */
	call execute_if ();

	go to SET_INPUT_LIMIT;


ACTION (14):					/* &label */
	xd.arg_len = length (rtrim (arg, WHITE_SPACE));
	if abs_data.label_search_sw & search_type = LABEL then
	     if arg = saved_label_ptr -> label.name then do;  /* the one we want */
		label_ptr = saved_label_ptr;
		hash = saved_hash;
		xd.input_pos = xd.this_statement.pos + xd.this_statement.len + 1;  /* begin executing from here */
		abs_data.label_search_sw = "0"b;
		go to GOT_LABEL;
	     end;

	label_ptr = allocate_label (arg);
	hash = mod (binary (unspec (char (arg, 2)), 18) + length (arg), 61);
GOT_LABEL:					/* compile label for finding later */
	label.lex_block_ptr = abs_data.current_lex_block_ptr;  /* &goto to here restores all of this stuff */
	label.statement_pos = xd.this_statement.pos;
	label.statement_len = xd.this_statement.len;

	if goto_entry_sw & ^abs_data.label_search_sw then do;
	     input_string.limit = max (input_string.limit, xd.input_pos - 1);
	     input_string.position = xd.input_pos;
	end;
	else input_string.limit = xd.input_pos;

	if xd.expanded_sw then do;			/* was an expandable label */
						/* thread into xlabel chain */
	     if abs_data.first_xlabel_ptr = null then abs_data.first_xlabel_ptr = label_ptr;
	     if abs_data.last_xlabel_ptr ^= null then
		abs_data.last_xlabel_ptr -> label.next_ptr = label_ptr;
	     abs_data.last_xlabel_ptr = label_ptr;
	     label.next_ptr = null;			/* last in chain */
	end;

	else do;
						/* else thread into hash tree of constant labels */
	     if abs_data.labels_ptr = null then abs_data.labels_ptr = allocate_hash_table ();

	     label.next_ptr = abs_data.labels_ptr -> hash_table (hash);
	     abs_data.labels_ptr -> hash_table (hash) = label_ptr;  /* thread in as first node for hash */
	end;

	if goto_entry_sw & ^abs_data.label_search_sw then return (0);
						/* return from $goto */
	else go to EXPAND_NEXT_STMT;


ACTION (15):					/* &leave (UNIMPLEMENTED) */
	go to BAD_KEY;


ACTION (16):					/* &list_variables */
LIST_VARIABLES_STMT:
	if abs_data.variables_ptr = null then call ioa_ ("No variables set.");
	else do;
	     call abs_io_list_vars (abs_data_ptr, parsed_args_ptr, message, code);
	     if code ^= 0 then call error (code, message);
	end;

	go to SET_INPUT_LIMIT;


ACTION (17):					/* &lsv (synonym for &list_variables) */
	go to LIST_VARIABLES_STMT;


ACTION (18):					/* &on */
	if parsed_args_ptr = null then
NO_ON_ARGS:    call error (0, "No condition names specified for &on statement.");
	if parsed_args.count = 0 then go to NO_ON_ARGS;

	if abs_data.next_action ^= BEGIN_ACTION then
NO_BEGIN:	     call error (0, "&on statement not followed by &begin");

	cond_string_len = 0;
	do i = 1 to parsed_args.count;
	     cond_string_len = cond_string_len + parsed_args.len (i) + 1;
	end;
begin;
dcl cond_string char (cond_string_len) varying;
	cond_string = "";
	do i = 1 to parsed_args.count;
	     xd.arg_ptr = parsed_args.ptr (i);
	     xd.arg_len = parsed_args.len (i);
	     cond_string = cond_string || arg || " ";
	end;
	cond_string = translate (cond_string, " ", ",");

	condition_count = 0;
	i = verify (cond_string, " ");
	do while (i > 0 & i < cond_string_len);
	     condition_count = condition_count + 1;
	     i = i + index (substr (cond_string, i), " ") - 1;
	     if verify (substr (cond_string, i), " ") = 0 then i = cond_string_len;
	     else i = i + verify (substr (cond_string, i), " ") - 1;
	end;


	allocate condition_array in (abs_data.work_area) set (condition_array_ptr);

	condition_count = 0;
	i = verify (cond_string, " ");
	do while (i > 0 & i < cond_string_len);
	     name_len = index (substr (cond_string, i), " ") - 1;
	     if name_len > 32 then call error (0, "Condition name ^a longer than 32 characters.",
		substr (cond_string, i, name_len));
	     condition_count = condition_count + 1;
	     condition_array (condition_count) = substr (cond_string, i, name_len);
	     i = i + name_len;
	     if verify (substr (cond_string, i), " ") = 0 then i = cond_string_len;
	     else i = i + verify (substr (cond_string, i), " ") - 1;
	end;
end;

	i = index (substr (input_string, xd.input_pos), "&begin");
	if i = 0 then go to NO_BEGIN;
	xd.input_pos = xd.input_pos + i + length ("&begin") - 1;  /* position past &begin */
	if substr (input_string, xd.input_pos, 1) = NL then xd.input_pos = xd.input_pos + 1;  /* and newline */

	handler_start = xd.input_pos;
	handler_ptr = addcharno (input_string.ptr, xd.input_pos - 1);
	
	call execute_begin ();

	allocate saved_if_info in (abs_data.work_area) set (on_saved_if_ptr);
	on_saved_if_ptr -> saved_if_info = abs_data.if_info;

	saved_skip_block_level = abs_data.skip_block_level;
	abs_data.skip_block_level = 1;
	abs_data.skip_sw, skipping_handler_sw = "1"b;

	go to SET_INPUT_LIMIT;

GOT_HANDLER:
	do i = xd.input_pos by -1 to 1 while (substr (input_string, i, 4) ^= "&end"); end;
	if i = 0 then
NO_ON_END:     call error (0, "Missing &end following &on...&begin.");
	else if index (ALPHA, substr (input_string, i + 4, 1)) ^= 0 then go to NO_ON_END;
	handler_len = i - handler_start;		/* length of handler text not including &end */
	if substr (input_string,xd.input_pos, 1) = NL then xd.input_pos = xd.input_pos + 1;  /* and trailing newline */

	do i = 1 to condition_count;

	     if condition_array (i) = "cleanup" then do;	/* treat cleanup special */
		if abs_data.cleanup_handler_ptr = null then do;
		     allocate handler_node in (abs_data.work_area) set (abs_data.cleanup_handler_ptr);
		     abs_data.cleanup_handler_ptr -> handler_node.condition_name = "cleanup";
		     abs_data.cleanup_handler_ptr -> handler_node.next_ptr = null;
		end;
		abs_data.cleanup_handler_ptr -> handler_node.ptr = handler_ptr;
		abs_data.cleanup_handler_ptr -> handler_node.len = handler_len;
	     end;
	     else do;

/* Is there already a handler for this condition? */

		if abs_data.first_handler_ptr = null then do;  /* no handlers at all */
		     allocate handler_node in (abs_data.work_area) set (handler_node_ptr);
		     handler_node.condition_name = condition_array (i);
		     handler_node.next_ptr = null;
		     abs_data.first_handler_ptr = handler_node_ptr;
		end;

		else do;
		     do handler_node_ptr = abs_data.first_handler_ptr repeat (handler_node.next_ptr)
			while (handler_node_ptr ^= null);
			     if handler_node.condition_name = condition_array (i) then go to SET_HANDLER;
			     last_node_ptr = handler_node_ptr;
		     end;

		     allocate handler_node in (abs_data.work_area) set (handler_node_ptr);
		     handler_node.condition_name = condition_array (i);
		     handler_node.next_ptr = null;
		     last_node_ptr -> handler_node.next_ptr = handler_node_ptr;
		end;

SET_HANDLER:	handler_node.ptr = handler_ptr;
		handler_node.len = handler_len;
	     end;
	end;

	abs_data.if_info = on_saved_if_ptr -> saved_if_info;
	free on_saved_if_ptr -> saved_if_info in (abs_data.work_area);

	go to SET_INPUT_LIMIT;
	     

ACTION (19):					/* &print */
	call ioa_ ("^a", arg);
	go to SET_INPUT_LIMIT;


ACTION (20):					/* &print_nnl */
	call ioa_$nnl ("^a", arg);
	go to SET_INPUT_LIMIT;


ACTION (21):					/* &print_switch */
	nnl_sw = "0"b;
PRINT_SWITCH:
	i = search (arg, WHITE_SPACE);
	if i = 0 then i = xd.arg_len + 1;
	switch_name = substr (arg, 1, i - 1);

	call iox_$look_iocb (switch_name, iocb_ptr, code);
	if code ^= 0 then call error (code, "^a", switch_name);

	if nnl_sw then call ioa_$ioa_switch_nnl (iocb_ptr, "^a", substr (arg, i + 1));
	else call ioa_$ioa_switch (iocb_ptr, "^a", substr (arg, i + 1));
	go to SET_INPUT_LIMIT;


ACTION (22):					/* &print_switch_nnl */
	nnl_sw = "1"b;
	go to PRINT_SWITCH;


ACTION (23):					/* &procedure (UNIMPLEMENTED)*/
PROC_STMT:
/*
	block_ptr = allocate_block ();

	block.containing_lex_block_ptr = null;
	block.containing_proc_block_ptr = current_proc_block_ptr;
	block.args_ptr = xd.parsed_args_ptr;
	block.identifier = PROC_TYPE;

	current_proc_block_ptr = block_ptr;
	current_lex_block_ptr = null;
	go to EXPAND_NEXT_STMT;
*/
	go to BAD_KEY;


ACTION (24):					/* &proc (synonym for &procedure) */
	go to PROC_STMT;


ACTION (25):					/* &quit */
	if xd.caller_actual_len ^= 0 then
	     call warning (0, "&quit accepts no arguments.");
	go to END_OF_FILE;


ACTION (26):					/* &ready */
READY_STMT:
	ready_mode.flag = get_ready_mode ();
	ready_mode.pad = "0"b;
	if ec_data_ptr ^= null then
	     if codeptr (ec_data.set_ready_mode) ^= null then do;  /* ready proc specified (e.g., by absentee) */
		call ec_data.set_ready_mode (ready_mode);
		go to SET_INPUT_LIMIT;
	     end;

	call cu_$set_ready_mode (ready_mode);
	go to SET_INPUT_LIMIT;


ACTION (27):					/* &ready_mode (synonym for &ready) */
	go to READY_STMT;


ACTION (28):					/* &ready_proc */
	if ec_data_ptr ^= null then ec_data.call_ready_proc = get_ready_mode ();
	go to SET_INPUT_LIMIT;


ACTION (29):					/* &repeat (UNIMPLEMENTED) */
	go to BAD_KEY;


ACTION (30):					/* &resignal */
/*
   THIS IS THE WRONG IMPLEMENTATION BECAUSE IT RE-INVOKES HANDLERS ABOVE THIS ONE.

	if ^abs_data.in_handler_sw then call error (0, "&resignal is allowed only inside an &on unit.");

	saved_condition_name = abs_data.handler_node_ptr -> handler_node.condition_name;
	abs_data.handler_node_ptr -> handler_node.condition_name = "";   temp. disable handler for this cond 

	call signal_ ((abs_data.condition_name), abs_data.mc_ptr, abs_data.info_ptr, abs_data.wc_ptr);

	abs_data.handler_node_ptr -> handler_node.condition_name = saved_condition_name;
*/
	go to BAD_KEY;


ACTION (31):					/* &return */
	if functionp () then do;			/* called as [exec_com] */
	     if xd.arg_len > ec_data.return_len then
		call warning (error_table_$command_line_overflow,
		     "Expanded value length of ^d characters exceeds return argument length of ^d characters.",
		     xd.arg_len, ec_data.return_len);

	     return_arg = arg;
	end;

	else call ioa_ ("^a", arg);			/* called as a command */
	go to END_OF_FILE;

ACTION (32):					/* &revert */
	if abs_data.in_handler_sw then call error (0, "Cannot execute &revert inside an &on unit.");
	if parsed_args_ptr = null then call error (0, "No argument specified for &revert.");

	do i = 1 to parsed_args.count;
	     xd.arg_ptr = parsed_args.ptr (i);
	     xd.arg_len = parsed_args.len (i);

	     do token = first_token (arg, tpos) repeat (next_token (arg, tpos)) while (token ^= "");

		if token = "cleanup" then
		     if abs_data.cleanup_handler_ptr = null then
NO_HANDLER:
			call warning (0, "(&revert) No &on unit for " || arg);
		     else abs_data.cleanup_handler_ptr = null;

		else do;
		     p = abs_data.first_handler_ptr;
		     lastp = null;
		     do while (p ^= null);
			if p -> handler_node.condition_name = token then do;
						/* free the node */
			     if lastp = null then abs_data.first_handler_ptr = p -> handler_node.next_ptr;
			     else lastp -> handler_node.next_ptr = p -> handler_node.next_ptr;
			     free p -> handler_node in (abs_data.work_area);
			     go to END_REVERT_LOOP;
			end;
			else do;
			     lastp = p;
			     p = p -> handler_node.next_ptr;
			end;
		     end;
		end;
END_REVERT_LOOP:
	     end;
	end;
	go to SET_INPUT_LIMIT;


ACTION (33):					/* &set */
	if parsed_args_ptr = null then
NO_SET_ARGS:   call error (0, "No arguments specified for &set.");
	if parsed_args.count = 0 then go to NO_SET_ARGS;

	if mod (parsed_args.count, 2) ^= 0 then do;	/* odd number of args */
	     var_ptr = parsed_args.ptr (parsed_args.count);
	     var_len = parsed_args.len (parsed_args.count);
	     call error (0, "Missing last value; no value set for ""^a"".", var_string);
	end;

	do i = 1 by 2 to parsed_args.count - 1;		/* test all args first to rule out integers */
	     var_ptr = parsed_args.ptr (i);
	     var_len = parsed_args.len (i);
	     if verify (var_string, DIGITS || WHITE_SPACE) = 0 then
		call error (0, "Invalid syntax in var name ""^a""; all white space and digits.", var_string);
	end;

	do i = 1 by 2 to parsed_args.count - 1;
	     var_ptr = parsed_args.ptr (i);
	     var_len = parsed_args.len (i);
	     val_ptr = parsed_args.ptr (i + 1);
	     val_len = parsed_args.len (i + 1);

	     if val_string = "&undefined" | val_string = "&undef" then
		call abs_io_expand_$delete (abs_data.variables_ptr, var_string, "", code);

	     else call abs_io_expand_$set (abs_data.variables_ptr, var_string, val_string, code);
	     if code ^= 0 then call error (code, xd.error_msg);
	end;
	go to SET_INPUT_LIMIT;


ACTION (34):					/* &signal */
	token = first_token (arg, tpos);
	if next_token (arg, tpos) ^= "" then
	     call error (0, "&signal accepts only one condition name: " || rtrim (arg));

	if abs_data.in_handler_sw & token = abs_data.condition_name then
	     call error (0, "Attempt to &signal " || rtrim (token) || " from within "
		|| rtrim (token) || " &on unit.");

	abs_data.input_string.position = xd.input_pos;

	token32 = token;
	call signal_ (token32);

	xd.input_pos = abs_data.input_string.position;	/* a handler's &goto may have changed it */
	go to SET_INPUT_LIMIT;


ACTION (35):					/* &then */
	abs_data.clause_type = THEN_TYPE;

	call execute_then ();

	go to SET_INPUT_LIMIT;


ACTION (36):					/* &trace */
	call set_trace;
	go to SET_INPUT_LIMIT;


ACTION (37):					/* &until (UNIMPLEMENTED) */
	go to BAD_KEY;


ACTION (38):					/* &version */
	call error (0, "The ""&version"" statement can only be the first line of the program.");


ACTION (39):					/* &while (UNIMPLEMENTED) */
	go to BAD_KEY;
%page;
/* NOTE: These labels (except 0) correspond to the STMTS array in abs_io_expand_ */

SKIP (0):						/* non-control stmt */

SKIP_TEST:
	if abs_data.if_sw then call test_end_of_if ();	/* done skipping? */

	else if abs_data.skip_block_level = 0 then abs_data.skip_sw = "0"b;

	if ^abs_data.skip_sw & skipping_handler_sw then do;
	     skipping_handler_sw = "0"b;
	     abs_data.skip_block_level = saved_skip_block_level;
	     go to GOT_HANDLER;
	end;

	else go to MIGHT_SKIP;			/* loop to call abs_io_expand_ again */

SKIP (1):
	go to SKIP_TEST;

SKIP (2):						/* &begin */
	call execute_begin ();

	abs_data.skip_block_level = abs_data.skip_block_level + 1;
	go to SKIP_TEST;

SKIP (3): SKIP (4): SKIP (5):
	go to SKIP_TEST;

SKIP (6):						/* &do */
	call execute_do ();

	abs_data.skip_block_level = abs_data.skip_block_level + 1;
	go to SKIP_TEST;

SKIP (7):						/* &else */
	abs_data.clause_type = ELSE_TYPE;

	call execute_else ();

	go to SKIP_TEST;

SKIP (8):						/* &end */
	call execute_end ();

	go to SKIP_TEST;

SKIP (9): SKIP (10): SKIP (11): SKIP (12):
	go to SKIP_TEST;

SKIP (13):					/* &if */
	call execute_if ();

	go to SKIP_TEST;

SKIP (14): SKIP (15):
SKIP (16): SKIP (17): SKIP (18): SKIP (19):
SKIP (20): SKIP (21): SKIP (22): SKIP (23):
SKIP (24): SKIP (25): SKIP (26): SKIP (27):
SKIP (28): SKIP (29): SKIP (30): SKIP (31):
SKIP (32): SKIP (33): SKIP (34):
	go to SKIP_TEST;

SKIP (35):					/* &then */
	abs_data.clause_type = THEN_TYPE;
	call execute_then ();
	go to SKIP_TEST;

SKIP (36): SKIP (37): SKIP (38): SKIP (39):
	go to SKIP_TEST;
%page;
/**/
allocate_block: proc returns (ptr);

dcl block_ptr ptr;

	on area call error (error_table_$noalloc, "Allocating program block.");
	on bad_area_format call error (error_table_$notalloc, "Allocating program block.");
	on bad_area_initialization call error (error_table_$notalloc, "Allocating program block.");

	allocate block in (abs_data.work_area) set (block_ptr);

	block_ptr -> block.prev_block_ptr = abs_data.last_block_ptr;
	abs_data.last_block_ptr = block_ptr;

	block_ptr -> block.keyword_pos = xd.this_statement.pos;
	block_ptr -> block.if_info = abs_data.if_info;
	block_ptr -> block.statement_end_pos = 0;

	return (block_ptr);

end allocate_block;
/**/
%page;
allocate_hash_table: proc returns (ptr);

/* Allocates a labels hash table for use by lookup_label */

dcl labels_ptr ptr;

	on area call error (error_table_$noalloc, "Allocating label hash table.");
	on bad_area_format call error (error_table_$notalloc, "Allocating label hash table.");
	on bad_area_initialization call error (error_table_$notalloc, "Allocating label hash table.");

	allocate hash_table in (abs_data.work_area) set (labels_ptr);

	revert area;
	revert bad_area_format;
	revert bad_area_initialization;

	return (labels_ptr);

end allocate_hash_table;
%page;
allocate_label: proc (P_label_name) returns (ptr);

/* allocates a single label node to be threaded by the caller */

dcl P_label_name char (*);
dcl label_ptr ptr;

	on area call error (error_table_$noalloc, "Allocating label ""^a""", P_label_name);
	on bad_area_format call error (error_table_$notalloc,
	     "Allocating label ""^a""", P_label_name);
	on bad_area_initialization call error (error_table_$notalloc,
	     "Allocating label ""^a""", P_label_name);

	current_label_ptr = addr (P_label_name);
	current_label_len = length (P_label_name);

	allocate label in (abs_data.work_area) set (label_ptr);

	revert area;
	revert bad_area_format;
	revert bad_area_initialization;

	label_ptr -> label.name = P_label_name;
	label_ptr -> label.statement_pos = input_string.position;
	label_ptr -> label.statement_len = 0;		/* until set by caller */
	label_ptr -> label.next_ptr = null;

	return (label_ptr);

end allocate_label;
%page;
attachedp: proc returns (bit (1) aligned);

/* TRUE if input is being read from the file (&attach) */

	if abs_data_ptr = null then return ("0"b);
	else return (abs_data.attach.target_ptr ^= null);

end attachedp;
%page;
conditional: proc returns (bit (1) aligned);

/* TRUE if expanded string = "true", FALSE if "false", otherwise strip off brackets and
   evaluate by calling the command processor to expand an active string */

dcl active_string char (active_string_len) based (active_string_ptr);
dcl (active_string_len, temp_len) fixed bin (21);
dcl (active_string_ptr, saved_ptr, temp_ptr) ptr;
dcl bars_len fixed bin (21);
dcl free_sw bit (1);
dcl temp_string char (temp_len) based (temp_ptr);
dcl value char (8) varying;

	if xd.allocated_ptr ^= null then do;	/* rest-of-line allocated, have to copy */

	     active_string_len = xd.caller_actual_len + xd.allocated_len;
	     if area_ptr = null then area_ptr = get_system_free_area_ ();
	     free_sw = "1"b;
	     on cleanup free active_string in (area_ptr -> based_area);

	     allocate active_string in (area_ptr -> based_area) set (active_string_ptr);

	     temp_ptr = xd.caller_buffer_ptr;
	     temp_len = xd.caller_actual_len;
	     substr (active_string, 1, temp_len) = temp_string;

	     temp_ptr = xd.allocated_ptr;
	     temp_len = xd.allocated_len;
	     substr (active_string, xd.caller_actual_len + 1, temp_len) = temp_string;
	end;
	else do;
	     free_sw = "0"b;
	     active_string_ptr = xd.arg_ptr;
	     active_string_len = xd.arg_len;
	end;

	active_string_pos = verify (active_string, WHITE_SPACE);
	active_string_len = active_string_len - verify (reverse (active_string), WHITE_SPACE) + 1;

	if active_string = "true" then return ("1"b);

	else if active_string = "false" then return ("0"b);

/* Also accept [...], |[...], ||[...] for compatibility */

	if substr (active_string, active_string_pos, 1) = "|" then
	     if substr (active_string, active_string_pos + 1, 1) = "|" then bars_len = 2;  /* ||[ */
	     else bars_len = 1;			/* |[ */
	else bars_len = 0;

	if substr (active_string, active_string_pos + bars_len, 1) ^= "[" |
	     substr (active_string, active_string_len, 1) ^= "]" then
		call error (0, "Malformed conditional in ""&if"" statement.");

	saved_ptr = active_string_ptr;
	active_string_ptr = addr (substr (active_string, active_string_pos + bars_len + 1));
	active_string_len = active_string_len - bars_len - 2;
	if ec_data_ptr ^= null then
	     if codeptr (ec_data.eval_string) ^= null then do;  /* an af evaluation routine was specified */
		call ec_data.eval_string (null, active_string, bars_len + 1, value, code);
		go to EVALUATED;
	     end;

	call cu_$evaluate_active_string (null, active_string, bars_len + 1, value, code);
EVALUATED:
	if free_sw then do;
	     active_string_ptr = saved_ptr;
	     free active_string in (area_ptr -> based_area);
	end;

	if code ^= 0 then call error (code, "Evaluating ""&if"" clause.");

	if value = "true" then return ("1"b);
	else if value = "false" then return ("0"b);
	else call error (0, "Invalid ""&if"" value ""^a""; must be true or false.", value);

end conditional;
%page;
error: proc options (variable);

/* Prints an error message (ec syntax or whatever) and skips to end of file */

dcl based_ec_string char (based_ec_len) based (based_ec_ptr);
dcl based_ec_ptr ptr;
dcl based_ec_len fixed bin (21);
dcl (error_pos, line_len, line_number, line_start) fixed bin (21);
dcl complain entry variable options (variable);
dcl statement_ptr ptr;
dcl statement char (xd.this_statement.len) based (statement_ptr);
dcl message char (4096);
dcl who char (72) varying;
dcl severity_sw bit (1);				/* ON for skip to end of file, OFF for warning only */
dcl end_ec bit (1);					/* Note end of file */
dcl status_ptr ptr;
dcl status fixed bin (25) based (status_ptr);

	severity_sw = "1"b;				/* skip to end of file after printing error */
	go to ERROR_COMMON;


warning: entry options (variable);

/* Prints a warning message and returns */

	severity_sw = "0"b;

ERROR_COMMON:
	end_ec = "0"b;
	call cu_$arg_ptr (1, status_ptr, (0), (0));
	call ioa_$general_rs (cu_$arg_list_ptr (), 2, 3, message, (0), "1"b, "0"b);

	if abs_data.in_handler_sw & ^goto_entry_sw then do;
						/* count line numbers in parent ec if inside &on unit */
	     based_ec_ptr = abs_data.parent_abs_data_ptr -> abs_data.input_string.ptr;
	     based_ec_len = abs_data.parent_abs_data_ptr -> abs_data.input_string.len;
	     error_pos = xd.this_statement.pos + charno (abs_data.handler_node_ptr -> handler_node.ptr)
		- charno (based_ec_ptr);
	end;
	else do;
	     based_ec_ptr = abs_data.input_string.ptr;
	     based_ec_len = abs_data.input_string.len;
	     error_pos = xd.this_statement.pos;
	end;

	line_number = 0;				/* calculate line number of error */
	do line_start = 0 repeat (line_start + line_len + 1) while (line_start <= error_pos);
	     line_len = index (substr (based_ec_string, line_start + 1), NL) - 1;
	     if line_len < 0 then do;
		end_ec = "1"b;
		line_len = error_pos - line_start;
	     end;
	     line_number = line_number + 1;
	end;

	if ec_data_ptr = null then do;
	     complain = com_err_;
	     who = rtrim (abs_data.io_module_name);
	end;
	else do;
	     if codeptr (ec_data.error) = null then
		if ec_data.active_function then complain = active_fnc_err_;
		else complain = com_err_;
	     else complain = ec_data.error;
	     who = ec_data.who_am_i;
	end;

	if status = error_table_$badsyntax then status = 0;

	statement_ptr = addr (substr (input_string, xd.this_statement.pos));

	call complain (status, who, "^[^/^]^[Error^;Warning^] on line #^d of ^a:^/^a^/SOURCE:^-^a",
	     status ^= 0, severity_sw, line_number, ec_path, message, statement);

	if severity_sw then do;
	     if end_ec then go to ERROR_RETURN;
	     if abs_data.noabort then do;
		actual_len = 0;
		A_code = 0;
		go to RETURN;
	     end;
	     else go to ERROR_RETURN;
	end;

end error;
%page;
execute_begin: proc;

	block_ptr = allocate_block ();

	block.containing_lex_block_ptr = abs_data.current_lex_block_ptr;
	block.containing_proc_block_ptr = abs_data.current_proc_block_ptr;
	block.args_ptr = null;
	block.identifier = BEGIN_TYPE;

	block.if_info = abs_data.if_info;
	abs_data.if_sw = "0"b;
	abs_data.prev_if_ptr = null;	

	abs_data.current_lex_block_ptr = block_ptr;

end execute_begin;
%page;
execute_do: proc;

	block_ptr = allocate_block ();

	block.containing_lex_block_ptr = abs_data.current_lex_block_ptr;
	block.containing_proc_block_ptr = abs_data.current_proc_block_ptr;
	block.args_ptr = null;
	if abs_data.clause_type = THEN_TYPE | abs_data.clause_type = ELSE_TYPE then
	     block.identifier = abs_data.clause_type;
	else block.identifier = DO_TYPE;

	block.if_info = abs_data.if_info;
	abs_data.if_sw = "0"b;
	abs_data.prev_if_ptr = null;

	abs_data.current_lex_block_ptr = block_ptr;

end execute_do;
%page;
execute_else: proc;

	if ^abs_data.if_sw | abs_data.got_else_sw then call error (0, "&else not preceded by &if");

	abs_data.got_else_sw = "1"b;

	if abs_data.skip_block_level = 0 then

/* Unless inside an &if being skipped in its entirety (abs_data.prev_if_ptr -> saved_if_info.skip_sw is ON),
   or inside a &do-&end block being skipped (abs_data.skip_block_level > 0),
   decide whether to skip this &else clause depending on value of the &if conditional. */

	     if abs_data.prev_if_ptr = null then call set_skip (abs_data.true_sw);
	     else if ^abs_data.prev_if_ptr -> saved_if_info.skip_sw then call set_skip (abs_data.true_sw);

end execute_else;
%page;
execute_end: proc;

dcl (saved_this_action, saved_next_action) fixed bin;

	block_ptr = abs_data.current_lex_block_ptr;
	if block_ptr = null then call error (0, "&end not preceded by &do or &on...&begin");

	saved_this_action = abs_data.this_action;	/* don't restore these from block */
	saved_next_action = abs_data.next_action;

	abs_data.if_info = block.if_info;

	abs_data.this_action = saved_this_action;
	abs_data.next_action = saved_next_action;

	if abs_data.current_lex_block_ptr = null then call error (0, "&end not preceded by &do");

	block.statement_end_pos = xd.this_statement.pos;
	if abs_data.next_action = ELSE_ACTION then
	     block.else_clause_pos = xd.next_statement.pos;
	else block.else_clause_pos = 0; 

	abs_data.current_lex_block_ptr = block.containing_lex_block_ptr;

end execute_end;
%page;
execute_if: proc;

	if abs_data.next_action ^= THEN_ACTION & abs_data.next_action ^= ELSE_ACTION then
	     call error (0, "Missing &then or &else following &if");

	if abs_data.if_sw then do;			/* already inside an &if */

	     on area call error (error_table_$noalloc, "Allocating &if statement information.");
	     on bad_area_format call error (error_table_$notalloc, "Allocating &if statement information.");
	     on bad_area_initialization call error (error_table_$notalloc, "Allocating &if statement information.");

	     allocate saved_if_info in (abs_data.work_area) set (saved_if_ptr);

	     saved_if_ptr -> saved_if_info = abs_data.if_info;
	     abs_data.prev_if_ptr = saved_if_ptr;
	end;

	abs_data.if_sw = "1"b;
	abs_data.got_then_sw, abs_data.got_else_sw = "0"b;

	if abs_data.skip_sw then abs_data.true_sw = "1"b;

	else abs_data.true_sw = conditional ();

end execute_if;
%page;
execute_then: proc;

	if ^abs_data.if_sw | abs_data.got_then_sw | abs_data.got_else_sw then
	     call error (0, "&then not preceded by &if");

	abs_data.got_then_sw = "1"b;

/* Unless inside an &if being skipped in its entirety (abs_data.prev_if_ptr -> saved_if_info.skip_sw is ON),
   or inside a &do-&end block being skipped (abs_data.skip_block_level > 0),
   decide whether to skip this &then clause based on the value of the &if conditional. */

	if abs_data.skip_block_level = 0 then
	     if abs_data.prev_if_ptr = null then call set_skip (^abs_data.true_sw);
	     else if ^abs_data.prev_if_ptr -> saved_if_info.skip_sw then call set_skip (^abs_data.true_sw);

end execute_then;
%page;
first_token: proc (P_str, P_pos) returns (char (128) varying);

dcl P_str char (*);
dcl (P_pos, i, j) fixed bin (21);

	if length (P_str) = 0 then return ("");
	i = search (P_str, WHITE_SPACE);
	if i = 0 then do;
	     P_pos = length (P_str) + 1;
	     return (P_str);
	end;
	j = verify (substr (P_str, i + 1), WHITE_SPACE);
	if i = 1 then do;
	     if j = 0 then return ("");
	     P_pos = j + 1;
	     return (next_token (P_str, P_pos));
	end;
	if j = 0 then do;
	     P_pos = length (P_str) + 1;
	     return (substr (P_str, 1));
	end;
	else do;
	     P_pos = i + j;
	     return (substr (P_str, 1, i - 1));
	end;

end first_token;
%page;
functionp: proc returns (bit (1) aligned);

/* TRUE if exec_com was invoked as an active function */

	if ec_data_ptr = null then return ("0"b);	/* unusual case */
	else return (ec_data.active_function);

end functionp;
%page;
get_data_ptrs: proc (P_update_sw);

/* Copies parameters and gets pointers to the various databases. It is called with P_update_sw = "0"b when
   abs_io_v2_get_line is entered, and with P_update_sw = "1"b after calling signal_io_error_ to make sure
   that nothing has changed that we care about. */

dcl P_update_sw bit (1);

	iocb_ptr = A_iocb_ptr -> iocb.actual_iocb_ptr;	/* chase syn's */

	if P_update_sw then do;
	     do while (abs_data_ptr ^= iocb_ptr -> iocb.attach_data_ptr);  /* something's wrong */
		call signal_io_error_ ("Attachment of " || abs_data.io_module_name || " has been moved.",
		     A_iocb_ptr, 0);
		iocb_ptr = A_iocb_ptr -> iocb.actual_iocb_ptr;
	     end;
	     return;
	end;

	buffer_ptr = A_buffer_ptr;
	buffer_len = A_buffer_len;

	abs_data_ptr = iocb_ptr -> iocb.attach_data_ptr;
	ec_data_ptr = abs_data.ec_data_ptr;


end get_data_ptrs;
%page;
get_ready_mode: proc returns (bit (1));

/* TRUE if "on" or "true" is the argument, FALSE if "off" or "false" */

dcl arg char (arg_len) based (arg_ptr);
dcl arg_ptr ptr;
dcl arg_len fixed bin (21);
dcl mode_sw bit (1);

	if parsed_args_ptr = null then
NO_READY_ARGS: call warning (0, "Missing argument to &ready; ""on"" assumed.");
	if parsed_args.count = 0 then go to NO_READY_ARGS;

	arg_ptr = parsed_args.ptr (1);
	arg_len = parsed_args.len (1);
	if arg = "on" | arg = "true" then mode_sw = "1"b;
	else if arg = "off" | arg = "false" then mode_sw = "0"b;
	else do;
	     call warning (0, "Invalid argument ""^a"" to ready statement; ""on"" assumed.", arg);
	     mode_sw = "1"b;
	end;

	if parsed_args.count > 1 then
	     call warning (0, "Ready statement accepts only one argument; extra args ignored.");

	return (mode_sw);

end get_ready_mode;
%page;
init_xd: proc;

/* Initializes much of the auto (in the external proc) xd structure. */

	unspec (xd) = "0"b;
	xd.version = expand_data_version_2;
	xd.abs_data_ptr = abs_data_ptr;
	xd.expand_data_ptr = addr (xd);
	xd.area_ptr = addr (abs_data.work_area);
	xd.parsed_args_ptr = null;
	xd.next_expand_data_ptr, xd.last_expand_data_ptr, xd.allocated_ptr = null;
	xd.first_loop_ptr, xd.first_block_ptr = null;
	xd.is_absin = abs_data.absentee;
	xd.is_af = functionp ();
	xd.is_input = input_linep;

	xd.input_pos = input_string.position;

end init_xd;
%page;
lookup_label: proc (P_labels_ptr, P_name, P_hash) returns (ptr);

/* Sets P_last_node_info from tree of defined labels and returns either ptr to requested label node or null */

dcl P_labels_ptr ptr;
dcl P_name char (*);
dcl P_hash fixed bin;

dcl (found_label_ptr, label_ptr) ptr;
dcl limit_pos fixed bin (21);

	if P_labels_ptr = null then P_labels_ptr = allocate_hash_table ();  /* no tree of labels allocated yet */

	P_hash = mod (binary (unspec (char (P_name, 2)), 18) + length (P_name), 61);

	do label_ptr = P_labels_ptr -> hash_table (P_hash)
	     repeat (label_ptr -> label.next_ptr) while (label_ptr ^= null);

		if label_ptr -> label.name = P_name then do;
		     found_label_ptr = label_ptr;
		     limit_pos = label_ptr -> label.statement_pos + label_ptr -> label.statement_len;
		     go to CHECK_EXPANDABLES;
		end;
	end;

	found_label_ptr = null;			/* no matching constant label in table */
	limit_pos = xd.this_statement.pos;

CHECK_EXPANDABLES:
						/* loop through expandables (e.g., &label &(foo)) */
	if abs_data.first_xlabel_ptr ^= null & unspec (abs_data.first_xlabel_ptr) ^= "0"b then
	     do label_ptr = abs_data.first_xlabel_ptr repeat (label_ptr -> label.next_ptr)
		while (label_ptr ^= null);

		     if label_ptr -> label.statement_pos >= limit_pos then return (found_label_ptr);

		     call abs_io_expand_$expand_label (xd, label_ptr -> label.statement_pos,
			label_ptr -> label.statement_len, label_val_ptr, label_val_len, 0);

		     if label_val = P_name then return (label_ptr);
	     end;

	return (found_label_ptr);

end lookup_label;
%page;
next_token: proc (P_str, P_pos) returns (char (128) varying);

dcl P_str char (*);
dcl (P_pos, i, j, start_pos) fixed (21);

	start_pos = P_pos;
	if start_pos > length (P_str) then return ("");
	i = search (substr (P_str, start_pos), WHITE_SPACE);
	if i = 0 then do;
	     P_pos = length (P_str) + 1;
	     return (substr (P_str, start_pos));
	end;
	j = verify (substr (P_str, start_pos + i), WHITE_SPACE);
	if j = 0 then do;
	     P_pos = length (P_str) + 1;
	     return (substr (P_str, start_pos));
	end;
	else do;
	     P_pos = start_pos + i + j - 1;
	     return (substr (P_str, start_pos, i - 1));
	end;

end next_token;
%page;
recurse_error: proc;

/* Aborts recursive $get_line invocation since there's no previous attachment to use */

dcl complain entry variable options (variable);
dcl who char (72) varying;

	if ec_data_ptr = null then do;
	     complain = com_err_;
	     who = rtrim (abs_data.io_module_name);
	end;
	else do;
	     if codeptr (ec_data.error) = null then
		if ec_data.active_function then complain = active_fnc_err_;
		else complain = com_err_;
	     else complain = ec_data.error;
	     who = ec_data.who_am_i;
	end;

	call complain (0, who, "Attempt to read recursively from the exec_com.");

	go to END_OF_FILE;

end recurse_error;
%page;
reset_input: proc;

/* Performs &detach */

	if attachedp () then do;

	     call abs_io_control$detach (abs_data_ptr, null, code);
	     if code ^= 0 then call error (code, "Error while performing ""&detach"".");
	     if input_linep then do;
						/* return a line from the prior user_input instead */
		call iox_$get_line (iox_$user_input, buffer_ptr, buffer_len, actual_len, A_code);
		input_string.limit = max (input_string.limit, xd.input_pos - 1);
		go to RETURN;
	     end;
	end;

end reset_input;
%page;
set_defaults: proc (P_args_ptr);

/* Sets default values for the first N arguments to exec_com */

dcl P_args_ptr ptr;
dcl i fixed bin;

	if unspec (P_args_ptr) = "0"b then return;
	else if P_args_ptr = null then return;
	else parsed_args_ptr = P_args_ptr;
	abs_data.default_arg_count = parsed_args.count;

	max_default_len = 0;
	do i = 1 to parsed_args.count;		/* compute max string len to allocate values */
	     max_default_len = max (max_default_len, parsed_args.len (i));
	end;

	on area call error (error_table_$noalloc, "Allocating &default args.");
	on bad_area_format call error (error_table_$notalloc, "Allocating &default args.");
	on bad_area_initialization call error (error_table_$notalloc, "Allocating &default args.");

	allocate default_values in (abs_data.work_area) set (default_values_ptr);
	allocate default_args in (abs_data.work_area) set (abs_data.default_arg_ptr);

	revert area;
	revert bad_area_format;
	revert bad_area_initialization;

	do i = 1 to parsed_args.count;		/* copy &default statement args */
	     val_ptr = parsed_args.ptr (i);
	     val_len = parsed_args.len (i);
	     if val_string = "&undefined" | val_string = "&undef" then default_args (i).ptr = null;
	     else do;
		default_values (i) = val_string;
		default_args (i).ptr = addr (default_values (i));
		default_args (i).len = val_len;
		default_args (i).quote_count = parsed_args.quote_count (i);
	     end;
	end;

end set_defaults;
%page;
set_skip: proc (P_sw);

dcl P_sw bit (1) aligned;

	if substr (input_string, xd.input_pos - 1, 1) = NL &  /* &then or &else ends line and */
	     abs_data.next_action ^= IF_ACTION then	/* not nested &if means */
		abs_data.skip_sw =			/* null &then or &else, hence end of &if construct */
		     (abs_data.skip_block_level > 0);

	else abs_data.skip_sw = P_sw;

end set_skip;
%page;
set_trace: proc;

/* Reads arguments to &trace and decides how and what to trace */

dcl 1 tracing,
   2 types,
    3 (command, input, control, comment) bit (1),
   2 (on, off, output_switch, prefix_sw) bit (1),
   2 expand fixed bin,
   2 prefix char (32) varying,
   2 iocb ptr;
dcl arg char (arg_len) based (arg_ptr);
dcl switch_name char (32);
dcl token char (128) varying;
dcl arg_ptr ptr;
dcl arg_len fixed bin (21);
dcl i fixed bin;
dcl pos fixed bin (21);

	unspec (tracing) = "0"b;

	if unspec (xd.parsed_args_ptr) = "0"b then go to NO_TRACE_ARG;
	else if xd.parsed_args_ptr = null then go to NO_TRACE_ARG;
	else parsed_args_ptr = xd.parsed_args_ptr;

	if parsed_args.count = 0 then do;
NO_TRACE_ARG:  call warning (0, "Missing &trace keyword; ""&command on"" assumed.");
	     tracing.command, tracing.on = "1"b;
	end;

	else do i = 1 to parsed_args.count;

	     arg_ptr = parsed_args.ptr (i);
	     arg_len = parsed_args.len (i);

	     do token = first_token (arg, pos) repeat (next_token (arg, pos)) while (token ^= "");

		if token = "&command" then tracing.command = "1"b;
		else if token = "&input" then tracing.input = "1"b;
		else if token = "&control" then tracing.control = "1"b;
		else if token = "&comment" then tracing.comment = "1"b;
		else if token = "&all_types" then
		     tracing.command, tracing.comment, tracing.control, tracing.input = "1"b;

		else if token = "on" | token = "true" then do;
		     tracing.on = "1"b;
		     tracing.off = "0"b;
		end;
		else if token = "off" | token = "false" then do;
		     tracing.off = "1"b;
		     tracing.on = "0"b;
		end;

		else if token = "&unexpanded" then do;
		     tracing.on = "1"b;
		     tracing.expand = UNEXPANDED;
		end;
		else if token = "&expanded" then do;
		     tracing.on = "1"b;
		     tracing.expand = EXPANDED;
		end;
		else if token = "&all" | token = "&all_expansions" then do;
		     tracing.on = "1"b;
		     tracing.expand = ALL;
		end;

		else if token = "&both" then do;
		     tracing.on = "1"b;
		     tracing.expand = BOTH;
		end;

		else if token = "&prefix" then do;
		     tracing.prefix_sw = "1"b;
		     tracing.prefix = get_value ("&prefix");
		end;

		else if token = "&output_switch" | token = "&osw" then do;
		     switch_name = get_value ("&output_switch");
		     call iox_$find_iocb (switch_name, tracing.iocb, code);
		     if code ^= 0 then call error (code, "Finding I/O switch ""^a""", switch_name);
		     tracing.output_switch = "1"b;
		end;

		else call error (0, "Invalid &trace keyword ^a", token);
	     end;
	end;

	if ^tracing.on & ^tracing.off then tracing.on = "1"b;

	if unspec (tracing.types) = "0"b then unspec (tracing.types) = "1111"b;

	if tracing.command then call set_one_trace (abs_data.command_line, "COMMAND");

	if tracing.input then call set_one_trace (abs_data.input_line, "INPUT");

	if tracing.control then call set_one_trace (abs_data.control_line, "CONTROL");

	if tracing.comment then call set_one_trace (abs_data.comment_line, "COMMENT");


get_value: proc (P_arg_name) returns (char (128) varying);

dcl P_arg_name char (*);

	token = next_token (arg, pos);
	do while (token = "");
	     i = i + 1;
	     if i > parsed_args.count then
		call error (0, "No value specified for &trace " || P_arg_name);
	     arg_ptr = parsed_args (i).ptr;
	     arg_len = parsed_args (i).len;
	     token = first_token (arg, pos);
	end;
	return (token);

end get_value;


set_one_trace: proc (P_line, P_type);

dcl 1 P_line aligned like abs_data.command_line;
dcl P_type char (*);

	if P_line.by_control_arg then return;		/* ec control args override &trace */

	if tracing.on then do;
	     P_line.on = "1"b;
	     if P_line.expand = 0 then	/* apply defaults for tracing mode */
		if xd.is_absin then P_line.expand = EXPANDED;  /* expanded for absentee */
		else if P_type = "COMMENT" | P_type = "CONTROL" then P_line.expand = UNEXPANDED;
		else P_line.expand = EXPANDED;	/* expanded for comand and input lines */
	end;
	if tracing.off then P_line.on = "0"b;
	if tracing.expand ^= 0 then P_line.expand = tracing.expand;
	if tracing.prefix_sw then P_line.prefix = tracing.prefix;
	if tracing.output_switch then P_line.iocb = tracing.iocb;

end set_one_trace;

end set_trace;
%page;
test_end_of_if: proc;

dcl (saved_this_action, saved_next_action) fixed bin;

	saved_this_action = abs_data.this_action;
	saved_next_action = abs_data.next_action;
TEST:
	if (abs_data.clause_type = ELSE_TYPE &
	     (saved_this_action ^= ELSE_ACTION | saved_next_action = ELSE_ACTION))
						/* statement following an &else */
	  | (abs_data.clause_type = THEN_TYPE & saved_this_action ^= THEN_ACTION &
	     saved_next_action ^= ELSE_ACTION) then do;
						/* or stmt following &then, not followed by &else */
		if saved_this_action = IF_ACTION | saved_this_action = DO_ACTION then return;
						/* More nesting: &then &if, &then &do, same for &else */
/* End of the &if-&then-&else compound statement */

		if abs_data.prev_if_ptr ^= null then do;  /* nested inside another &if */
		     abs_data.if_info = abs_data.prev_if_ptr -> saved_if_info;
		     go to TEST;			/* see if the outer &if is ended too, and so on */
		end;

		else do;
		     abs_data.if_sw = "0"b;		/* back to normal text */
		     abs_data.clause_type = 0;	/* we have seen the stmt after the &then or &else */

		     if abs_data.skip_block_level = 0 then abs_data.skip_sw = "0"b;
						/* stop skipping unless inside a &do being skipped */
		end;
	     end;

end test_end_of_if;

%page;
%include abs_io_block;
%page;
%include abs_io_data;
%page;
%include abs_io_expand;
%page;
%include abs_io_handler_node;
%page;
%include abs_io_hash;
%page;
%include ec_data;
%page;
%include iocbx;

end abs_io_v2_get_line;
