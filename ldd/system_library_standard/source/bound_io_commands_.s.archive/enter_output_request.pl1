/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */



/* format: style4,delnl,insnl,^ifthendo */

/* format: off */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/*  NAMES:  enter_output_request, eor						*/
/*									*/
/*      This command submits requests to print or punch files via calls to dprint_.	*/
/*									*/
/*  STATUS								*/
/*									*/
/* 1) Created:  May, 1973 by G. C. Dixon					*/
/* 2) Modified: July, 1974 by G. C. Dixon					*/
/*    a) added -device_class control argument.					*/
/*    b) call dprint_$access_check to check IO Daemon's access to output segments.	*/
/* 3) Modified: September, 1974 by G. C. Dixon					*/
/*    a) support the new control arguments:  -endpage (-ep), -no_endpage (-nep),	*/
/*       -line_length (-ll), -page_length (-pl), -indent (-in).			*/
/* 4) Modified: August, 1978 by Thomas McGary					*/
/*    a) add -label, -top_label, -bottom_label, & check vs -nep.			*/
/*    b) rename -dvc to -rqt.							*/
/*    c) convert to version 5 of dprint_arg struc.				*/
/* 5) Modified: October 12, 1981 by Roger Roach					*/
/*    a) modified to accept 24 character request types and convert to version 6		*/
/*       dprint_arg structure.						*/
/* 6) Modified: October, 21, 1981 by Gary Dixon					*/
/*    a) Major upgrade, including new argument parsing scheme,			*/
/*    b) named, user-settable defaults on a per-request_type basis			*/
/*    c) elimination of (print change)_daemon_defaults entry points in favor of		*/
/*       -print_defaults and -set_defaults					*/
/*    d) implementation of the -forms and -plot control arguments.			*/
/*    e) store default values in Person_id.value seg in [home_dir].			*/
/* 7) Modified: December 12, 1981 by Gary Dixon					*/
/*    a) implement -active_string as operand for -he -ds -lbl -tlbl -blbl.  De-implement	*/
/*       -ehe								*/
/* 8) Modified: June 1, 1982 by Gary Dixon - fix minor bugs, warn when using request	*/
/*	      types for which no user defaults are defined.			*/
/* 9) Modified: June, 1982 by Rick Kovalcik to add support for -dupt			*/
/* 10) Modified: November 1983 by C. Marker to add support for -nsep		          */
/* 11) Modified: January 1984 by C. Marker to make it possible to have a default request  */
/*               type which has no user defined defaults but instead uses the system      */
/*               defaults.							*/
/* 12) Modified: May 1984 by C. Marker to make the system defaults for the heading and    */
/*	       destination be null strings.  This will allow the IO Daemon drivers      */
/*               to take care of the defaults. 
             */
/* 13) Modified: Nov 1, 1984 by EJ Sharpe to change mdc_$get_lv_access arg list		*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


/****^  HISTORY COMMENTS:
  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
     audit(86-07-18,DGHowe), install(86-11-20,MR12.0-1222):
     Modified to call object_lib_$initiate to check if a file is an object
     segment or MSF instead of calling object_info_.
  2) change(87-05-10,Gilcrease), approve(87-05-15,MCR7686),
     audit(88-02-01,Farley), install(88-02-02,MR12.2-1019):
     Implement -nb for line-numbered printouts.
  3) change(88-08-25,Farley), approve(88-09-16,MCR7911),
     audit(88-10-25,Wallman), install(88-10-28,MR12.2-1199):
     Modified to use new version 10 dprint_arg and to call the new iod_info
     forms validation routine.
                                                   END HISTORY COMMENTS */


/* format: on */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


enter_output_request:
eor:
     procedure;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* This is the entry point used for submission of print and punch requests and to	*/
/* set/reset/delete/print user-defined groups of defaults.				*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


dcl  Idft fixed bin,
     Nargs fixed bin,				/* number of input arguments.			*/
     Nqueued fixed bin,				/* number of entries submitted for operation.	*/
     Ntype fixed bin,				/* type of operation: 			*/
						/*   0 = UNDEFINED				*/
						/*   1 = DP_PRINT				*/
						/*   2 = DP_PUNCH				*/
						/*   3 = DP_PLOT				*/
     Ntypes_set fixed bin,				/* if >1, then conflicting control args were given */
     Parg_list ptr,
     Pdefault_temp ptr,
     Pfcb ptr,					/* ptr to MSF opening info.			*/
     Pseg ptr,					/* ptr to segment being submitted.		*/
     Sdefault_is_stored bit (1),			/* on if user default is stored in value seg.	*/
     Sgive_label_warning bit (1),			/* on if user should be warned about -nep/-label	*/
     Sgive_nep_warning bit (1),			/* on if user should be warned about -label/-nep	*/
     Sdefault bit (1),				/* use default values for -he and -ds */
     code fixed bin (35),				/* a status code.				*/
     gen_type char (32),
     (line_length_error, line_length_query) fixed bin init (0),
     max_q fixed bin,
     value_seg_path char (168),
     warn_count fixed bin;

dcl  area area based (Parea);

dcl  (after, addr, bit, convert, currentsize, index, length, null, rtrim, search, string, substr, sum, unspec) builtin;

dcl  (cleanup, conversion) condition;

dcl  adjust_bit_count_ entry (char (168) aligned, char (32) aligned, bit (1) aligned, fixed bin (35), fixed bin (35)),
     check_star_name_$entry entry (char (*), fixed bin (35)),
     com_err_ entry () options (variable),
     command_query_$yes_no entry () options (variable),
     convert_authorization_$to_string entry (bit (72) aligned, char (*), fixed bin (35)),
     cu_$arg_count entry (fixed bin, fixed bin (35)),
     cu_$arg_list_ptr entry returns (ptr),
     cu_$arg_ptr_rel entry (fixed bin, ptr, fixed bin (21), fixed bin (35), ptr),
     cu_$evaluate_active_string entry (ptr, char (*), fixed bin, char (*) var, fixed bin (35)),
     dprint_ entry (char (*), char (*), ptr, fixed bin (35)),
     dprint_$check_daemon_access
	entry (char (*), char (*), char (*), bit (1) aligned, bit (1) aligned, bit (1) aligned, char (*),
	fixed bin (35)),
     dprint_$queue_contents entry (char (*), fixed bin, fixed bin, fixed bin (35)),
     eor_cv5_6_ entry (ptr, fixed bin (35)),
     eor_cv6_7_ entry (ptr, fixed bin (35)),
     eor_cv7_8_ entry (ptr, fixed bin (35)),
     eor_cv8_9_ entry (ptr, fixed bin (35)),
     eor_cv9_10_ entry (ptr, fixed bin (35)),
     expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35)),
     get_equal_name_ entry (char (*), char (*), char (32), fixed bin (35)),
     get_group_id_$tag_star entry () returns (char (32)),
     get_line_length_$switch entry (ptr, fixed bin (35)) returns (fixed bin),
     get_system_free_area_ entry () returns (ptr),
     hcs_$add_acl_entries entry (char (*), char (*), ptr, fixed bin, fixed bin (35)),
     hcs_$add_dir_acl_entries entry (char (*), char (*), ptr, fixed bin, fixed bin (35)),
     hcs_$get_access_class entry (char (*), char (*), bit (72) aligned, fixed bin (35)),
     hcs_$star_ entry (char (*), char (*), fixed bin (2), ptr, fixed bin, ptr, ptr, fixed bin (35)),
     hcs_$status_long entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35)),
     hcs_$terminate_noname entry (ptr, fixed bin (35)),
     ioa_ entry () options (variable),
     iod_info_$generic_type entry (char (*), char (32), fixed bin (35)),
     iod_info_$queue_data entry (char (*), fixed bin, fixed bin, fixed bin (35)),
     iod_info_$validate_forms_info entry (ptr, ptr, fixed bin (35)),
     mdc_$find_lvname entry (bit (36), char (*), fixed bin (35)),
     mdc_$get_lv_access entry (char (*), fixed bin (3), bit (36) aligned, bit (1) aligned, fixed bin (35)),
     msf_manager_$acl_add entry (ptr, ptr, fixed bin, fixed bin (35)),
     msf_manager_$close entry (ptr),
     msf_manager_$get_ptr entry (ptr, fixed bin, bit (1), ptr, fixed bin (24), fixed bin (35)),
     msf_manager_$open entry (char (*), char (*), ptr, fixed bin (35)),
     object_lib_$initiate entry (char (*), char (*), char (*), bit (1), ptr, fixed bin (24), bit (1), fixed bin (35)),
     requote_string_ entry (char (*)) returns (char (*)),
     user_info_ entry (char (*), char (*), char (*)),
     value_$get_data entry (ptr, bit (36) aligned, char (*), ptr, ptr, fixed bin (18), fixed bin (35)),
     value_$get_path entry (char (*), fixed bin (35)),
     value_$list_data_names entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
     value_$set_data
	entry (ptr, bit (36) aligned, char (*), ptr, fixed bin (18), ptr, ptr, fixed bin (18), fixed bin (35)),
     value_$set_path entry (char (*), bit (1), fixed bin (35));

dcl  DEFAULT_RQT (3) char (24) int static options (constant) init ("printer", "punch", "plotter"),
     DEFAULT_VALUE_SEG ptr int static options (constant) init (null),
     (
     FALSE init ("0"b),
     TRUE init ("1"b)
     ) bit (1) int static options (constant),
     PERM bit (36) aligned int static options (constant) init ("01"b),
     Parea ptr int static,				/* ptr to an allocation area.			*/
     MAX_COPIES fixed bin int static options (constant) init (30),
     MAX_LINE_LENGTH fixed bin int static options (constant) init (250),
     NL char (1) int static options (constant) init ("
"),
     (
     PRINT init (1),
     PUNCH init (2),
     MCC init (3),
     RAW init (4),
     PLOT init (5)
     ) fixed bin int static options (constant),
     UNDEFINED fixed bin int static options (constant) init (0),
     (
     error_table_$bad_arg,
     error_table_$bad_segment,
     error_table_$badopt,
     error_table_$badstar,
     error_table_$bigarg,
     error_table_$command_line_overflow,
     error_table_$dirseg,
     error_table_$improper_data_format,
     error_table_$inconsistent,
     error_table_$inconsistent_msf,
     error_table_$lock_wait_time_exceeded,
     error_table_$moderr,
     error_table_$no_s_permission,
     error_table_$noarg,
     error_table_$noentry,
     error_table_$nomatch,
     error_table_$nostars,
     error_table_$notalloc,
     error_table_$oldnamerr,
     error_table_$out_of_bounds,
     error_table_$private_volume,
     error_table_$too_many_names,
     error_table_$typename_not_found,
     error_table_$unimplemented_version,
     error_table_$zero_length_seg,
     error_table_$bad_forms_option,
     error_table_$no_forms_table_defined
     ) fixed bin (35) ext static,
     iox_$error_output ptr ext static,
     iox_$user_io ptr ext static,
     person char (22) int static init (""),
     proc char (24) aligned int static options (constant) init ("enter_output_request"),
     proj char (9) int static;





dcl  1 S aligned,					/* The structures on this page hold all of the	*/
       2 processing_control,				/*   information supplied by the user via	*/
         3 brief bit (1),				/*   control arguments.  The S structure holds	*/
         3 force bit (1),				/*   binary switches.			*/
       2 carriage_control,
         3 nep bit (1),
         3 single bit (1),
         3 non_edited bit (1),
         3 truncate bit (1),
         3 no_separator bit (1),
         3 line_nbrs bit (1),
       2 default_control,
         3 set_default bit (1),
         3 print_default bit (1),
         3 all bit (1),
         3 delete_default bit (1),
         3 replace_default bit (1),
         3 list_defaults bit (1),
       2 label,
         3 top bit (1),
         3 bottom bit (1),
         3 access bit (1),
       2 arg_type,
         3 pathnames bit (1),
         3 non_path_ctl_args bit (1),
         3 error bit (1),
         3 dnm_or_rqt_omitted bit (1),
     1 N aligned,					/* The N structure holds numeric switches, 	*/
       2 pt_pch fixed bin,				/* lengths, and other numeric selectors.	*/
       2 delete fixed bin,
       2 notify fixed bin,
       2 copies fixed bin,
       2 queue fixed bin,
       2 output_module fixed bin,
       2 lmargin fixed bin,
       2 line_lth fixed bin,
       2 page_lth fixed bin,
       2 defer_until_process_termination fixed bin,
     1 O aligned,					/* The O structure holds character operands for	*/
       2 request_type char (24) unal,			/*   various control arguments.		*/
       2 default_request_type char (24) unal,
       2 name_of_default char (24) unal,
       2 forms_name char (128) unal,
     1 PLS_struc aligned,
       2 heading like PLS,
       2 destination like PLS,
       2 top_label like PLS,
       2 bottom_label like PLS,
     1 PLS (4) aligned based (addr (PLS_struc)),		/* The PLS array of structures holds user-supplied */
       2 P ptr,					/*   arguments, stored as ptr/length with	*/
       2 L fixed bin (21),				/*   modifying switches.			*/
       2 S,					/*   The 4 array elements contain:		*/
         3 equal_name bit (1) unal,			/*       (1) heading			*/
         3 active_string bit (1) unal,			/*       (2) destination			*/
         3 center bit (1) unal,			/*       (3) top_label			*/
         3 pad bit (33) unal,				/*       (4) bottom_label			*/
     (
     HEADING init (1),
     DESTINATION init (2),
     TOP_LABEL init (3),
     BOTTOM_LABEL init (4)
     ) fixed bin int static options (constant),
     PLS_heading char (PLS.L (HEADING)) based (PLS.P (HEADING)),
     PLS_destination char (PLS.L (DESTINATION)) based (PLS.P (DESTINATION)),
     PLS_top_label char (PLS.L (TOP_LABEL)) based (PLS.P (TOP_LABEL)),
     PLS_bottom_label char (PLS.L (BOTTOM_LABEL)) based (PLS.P (BOTTOM_LABEL)),
     switch_array (21) bit (1) aligned based (addr (S)),
     number_array (10) fixed bin aligned based (addr (N));

dcl  1 default_print aligned based (Pdefault),
       2 header,
         3 Ntype fixed bin,				/* This structure holds information corresponding */
         3 name char (24) unal,			/*   to the O, S, N and PLS structures above, in	*/
         3 size fixed bin (18),			/*   the form in which it is stored as 		*/
       2 Odft,					/*   user-defined groups of default control	*/
         3 request_type char (24) unal init (""),		/*   argument settings for PRINTING.		*/
         3 forms_name char (64) unal init (""),
       2 Sdft,
         3 processing_control,
	 4 brief bit (1) init ("0"b),
	 4 force bit (1) init ("0"b),
         3 carriage_control,
	 4 nep bit (1) init ("0"b),
	 4 single bit (1) init ("0"b),
	 4 non_edited bit (1) init ("0"b),
	 4 truncate bit (1) init ("0"b),
	 4 no_separator bit (1) init ("0"b),
	 4 line_nbrs bit (1) init ("0"b),
         3 label,
	 4 top bit (1) init ("0"b),
	 4 bottom bit (1) init ("0"b),
	 4 access bit (1) init ("1"b),
       2 Ndft,
         3 pt_pch fixed bin init (0),
         3 delete fixed bin init (0),
         3 notify fixed bin init (0),
         3 copies fixed bin init (1),
         3 queue fixed bin init (0),
         3 output_module fixed bin init (PRINT),
         3 lmargin fixed bin init (0),
         3 line_lth fixed bin init (-1),
         3 page_lth fixed bin init (-1),
         3 defer_until_process_termination fixed bin init (0),
       2 LSV,					/* info from PLS converted to form storable	*/
         3 fixed_part,				/*   across process boundaries.		*/
	 4 heading,
	   5 L fixed bin (21),
	   5 S like PLS.S,
	 4 destination like default_print.LSV.fixed_part.heading,
	 4 top_label like default_print.LSV.fixed_part.heading,
	 4 bottom_label like default_print.LSV.fixed_part.heading,
         3 V,
	 4 heading char (PLS_struc.heading.L refer (default_print.LSV.heading.L)) unal,
	 4 destination char (PLS_struc.destination.L refer (default_print.LSV.destination.L)) unal,
	 4 top_label char (PLS_struc.top_label.L refer (default_print.LSV.top_label.L)) unal,
	 4 bottom_label char (PLS_struc.bottom_label.L refer (default_print.LSV.bottom_label.L)) unal,
     1 auto_default aligned,
       2 header like default_print.header,
       2 Odft like default_print.Odft,
       2 Sdft like default_print.Sdft,
       2 Ndft like default_print.Ndft,
       2 LSV,
         3 fixed_part like default_print.LSV.fixed_part,
         3 V,
	 4 heading char (59),
	 4 destination char (24),
	 4 top_label char (136),
	 4 bottom_label char (136);




dcl  1 default_punch aligned based (Pdefault),
       2 header,
         3 Ntype fixed bin,				/* PUNCH and PLOT DEFAULTS			*/
         3 name char (24) unal,
         3 size fixed bin (18),
       2 Odft,
         3 request_type char (24) unal init (""),
       2 Sdft,
         3 processing_control,
	 4 equal_header bit (1) init ("0"b),
	 4 brief bit (1) init ("0"b),
	 4 force bit (1) init ("0"b),
       2 Ndft,
         3 pt_pch fixed bin init (0),
         3 delete fixed bin init (0),
         3 notify fixed bin init (0),
         3 copies fixed bin init (1),
         3 queue fixed bin init (0),
         3 output_module fixed bin init (MCC),
         3 defer_until_process_termination fixed bin init (0),
       2 LSV,					/* info from PLS converted to form storable	*/
         3 fixed_part,				/*   across process boundaries.		*/
	 4 heading like default_print.LSV.fixed_part.heading,
	 4 destination like default_print.LSV.fixed_part.heading,
         3 V,
	 4 heading char (PLS_struc.heading.L refer (default_punch.LSV.heading.L)) unal,
	 4 destination char (PLS_struc.destination.L refer (default_punch.LSV.destination.L)) unal,
     Pdefault ptr,
     Pnew_default ptr;


dcl  1 default_header aligned based (Pdefault_header),
       2 version fixed bin,				/* structure containing default request types and */
       2 default_request_type (3) char (24) unal,		/* defining version of default_(print punch)	*/
						/* structures above.  The default_request_type	*/
						/* array elements are for printing, punching and	*/
     Pdefault_header ptr,				/* plotting, respectively.			*/
     Vdefault_header_5 fixed bin int static options (constant) init (5),
						/* Version 5 supports -astr in -he, -ds, -lbl	*/
     Vdefault_header_6 fixed bin int static options (constant) init (6),
						/* Version 6 de-supports default names beginning	*/
						/*   with hyphen or including ? or * chars.	*/
     Vdefault_header_7 fixed bin int static options (constant) init (7),
						/* Version 7 supports -dupt			*/
     Vdefault_header_8 fixed bin int static options (constant) init (8),
						/* Version 8 supports -nsep */
     Vdefault_header_9 fixed bin int static options (constant) init (9),
						/* Version 9, -nb */
     Vdefault_header_10 fixed bin int static options (constant) init (10),
						/* Version 10, larger forms_name */
     1 auto_default_header aligned like default_header;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* The following table describes the control arguments accepted by eor.  Each		*/
/* argument is preceded by a descriptor (eg, S^ 04) which describes the type of argument	*/
/* [char(2)] (eg, switch or arg with numeric operand, etc), argument value [pic"9"]	*/
/* field, and argument number [pic "99"] within each type.				*/
/*									*/
/* Types are:								*/
/* 	S+ = switch argument, value of switch is on				*/
/*	S^ = switch argument, value of switch is off				*/
/* 	Nb = argument which is followed by a numeric operand			*/
/*	N  = numeric switch argument.  The switch is set to the desc.arg_val.		*/
/*	Ch = argument which is followed by a character operand			*/
/*	Sp = special argument which is not followed by an operand (ie, which is a	*/
/*	     switch), but which requires special processing in addition to setting the	*/
/*	     switch.							*/
/*	PL = argument which is followed by an arbitrarily long character string	*/
/*	     operand.  The operand is stored in the PLS structure as a ptr/length pair. */
/*									*/
/* For switches (S^ or S+) and args with numeric operands (Nb),			*/
/*   the argument number (desc.arg_no) is an index into an array of switches		*/
/*   (switch_array) or numeric operands (number_array).  These arrays overlay structures	*/
/*   (S and N) which identify the switches or numeric operand values by name.		*/
/* For numeric switches (N ),							*/
/*   the argument number (desc.arg_no) is an index into number_array, and desc.arg_val	*/
/*   is the value to be stored in the array element.				*/
/* For special args (Sp) or args with character operands (Ch),			*/
/*   the desc.arg_no identifies a label value to which control is transferred in 	*/
/*   order to process the argument (and its operand).				*/
/* For ptr/length args (PL),							*/
/*   the desc.arg_val identifies which element of the PLS structure should be set, and	*/
/*   desc.arg_no identifies a label value to which control is transferred for further	*/
/*   processing after the structure element is set.				*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

dcl  1 desc unal based (Pdesc),			/* This is the descriptor referred to above.	*/
       2 type char (2),
       2 arg_val pic "9",
       2 arg_no pic "99",
     Pdesc ptr;




/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* 		The table itself is on the next 2 pages.			*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

dcl  arg_tbl (8) char (250) int static options (constant) init ("
S+ 01-brief
S+ 01-bf
S^ 01-long
S^ 01-lg
S+ 02-force
S+ 02-fc
S^ 02-no_force
S^ 02-nfc
S^ 03-end_page
S^ 03-ep
S+ 04-no_vertical_space
S+ 04-nvertsp
S^ 04-vertical_space
S^ 04-vertsp
                ", "
S+ 05-non_edited
S+ 05-ned
S^ 05-edited
S^ 05-ed
S+ 06-truncate
S+ 06-tc
S^ 06-fold
S+ 07-no_separator
S+ 07-nsep
S^ 07-separator
S^ 07-sep
S^ 08-no_number
S^ 08-nnb
S+ 08-number
S+ 08-nb
S+ 09-set_defaults
S+ 09-set_default
S+ 09-sdft
           ", "
S+ 10-print_defaults
S+ 10-print_default
S+ 10-prdft
S+ 10-pdft
S+ 12-delete_defaults
S+ 12-delete_default
S+ 12-dldft
S+ 12-ddft
S+ 13-replace_defaults
S+ 13-replace_default
S+ 13-rpdft
            ", "
S+ 13-rdft
S+ 14-list_defaults
S+ 14-list_default
S+ 14-lsdft
S+ 14-ldft
N 101-print
N 101-pr
N 201-punch
N 201-pch
N 301-plot
N 102-delete
N 102-dl
N 002-no_delete
N 002-ndl
N 103-notify
N 103-nt
  ", "
N 003-no_notify
N 003-nnt
Nb 04-copies
Nb 04-copy
Nb 04-cp
Nb 05-queue
Nb 05-q
N 306-mcc_punch
N 306-mcc
N 406-raw_punch
N 406-raw
N 206-7punch
N 206-7p
Nb 07-indent
Nb 07-ind
Nb 07-in
              ", "
Nb 08-line_length
Nb 08-ll
Nb 09-page_length
Nb 09-pl
N 110-defer_until_process_termination
N 110-dupt
N 010-no_defer_until_process_termination
N 010-ndupt
PL101-header
PL101-he
PL202-destination
   ", "
PL202-ds
PL303-label
PL303-lbl
PL304-top_label
PL304-tlbl
PL405-bottom_label
PL405-blbl
Sp 06-access_label
Sp 06-albl
Sp 07-no_label
Sp 07-nlbl
Sp 08-no_end_page
Sp 08-nep
Sp 09-all
Sp 09-a
         ", "
Ch 10-request_type
Ch 10-rqt
Ch 11-set_default_request_type
Ch 11-sdftrqt
Ch 11-sdrqt
Ch 12-name
Ch 12-nm
Ch 13-default_name
Ch 13-dftnm
Ch 13-dnm
Ch 14-forms
"),
     arg_table char (2000) based (addr (arg_tbl)),
     arg_tbl_array (2000) char (1) based (addr (arg_tbl));

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */



/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* This is the entry point for the enter_output_request command.			*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


	call init ();
	on cleanup call janitor ();			/* free space in system free area during cleanup. */

	call cu_$arg_count (Nargs, code);		/* find out how many arguments we were called with */
	if code ^= 0
	then go to NOT_AF;				/* This command doesn't work as an active function */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* The following code parses arguments in 3 passes.				*/
/* 1) Find out whether we are printing, punching, or plotting.  This information is needed */
/*    to determine which set of defaults (print/punch/plot) to apply.  During this	*/
/*    pass, we also detect and diagnose bad control args.  Any bad args abort all	*/
/*    processing.								*/
/* 2) Apply proper set of defaults, and then process args to allow user to override the	*/
/*    defaults.  Argument processing can be skipped if pass 1 determines there are no	*/
/*    non-pathname args.  However, any control arguments values (given with control	*/
/*    arguments or obtained from defaults) must still be validated.  This validation is	*/
/*    part of pass 2.							*/
/* 3) Process pathname args, submitting requests as appropriate.  Also change settings	*/
/*    for defaults, if necessary.						*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	S = FALSE;				/* Initialize argument-holding structures.	*/
	N = 0;
	O = "";
	PLS (*).P = null;
	PLS (*).L = 0;
	PLS (*).S = FALSE;

	call find_default_header ();			/* get user's default request types.		*/
	if Pdefault_header = null
	then go to FINISH;

	Sgive_label_warning = TRUE;			/* Initialize flags for PASS 1.		*/
	Sgive_nep_warning = TRUE;
	Parg_list = cu_$arg_list_ptr ();
	call proc_args (FALSE, Nqueued);
	if S.error
	then return;

	S.dnm_or_rqt_omitted = (O.request_type = "" | O.name_of_default = "");
						/* Set flag which indicates that either		*/
						/*   -default_name or -request_type control arg	*/
						/*   was NOT given in this invocation.		*/
	if O.name_of_default = ""
	then					/* Use user-supplied operand of -request_type name */
	     O.name_of_default = O.request_type;	/*   for default name if -default_name not given.	*/
	Ntype = UNDEFINED;
	if O.name_of_default ^= ""
	then do;					/* If default name given, look for user-defined	*/
						/*   set of default control arguments in value seg */
	     call find_default (O.name_of_default, "", UNDEFINED, FALSE, FALSE, warn_count, Pdefault);
	     if Pdefault ^= null
	     then do;
		O.request_type = default_print.request_type;
		Ntype = default_print.Ntype;
	     end;
	end;

	if Ntype ^= UNDEFINED
	then ;					/* If no user-defined defaults, look for generic	*/
	else if O.request_type ^= ""
	then do;					/*   type of request type in iod_tables		*/
	     call iod_info_$generic_type (O.request_type, gen_type, code);
	     if code ^= 0
	     then go to UNDEFINED_REQUEST_TYPE;
	     do Ntype = DP_PRINT to DP_PLOT while (gen_type ^= DEFAULT_RQT (Ntype));
	     end;
	     if Ntype > DP_PLOT
	     then go to UNDEFINED_GENERIC_TYPE;
	end;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* At this point in PASS 1, we may or may not know the generic type, depending upon	*/
/* whether or not the user gave a -default_name or -request_type control argument.  If	*/
/* we know the generic type, we must examine other control args to be sure they are	*/
/* consistent with that generic type.  If we don't know the generic type, we must	*/
/* examine other control args to see if any specific to a particular type were given	*/
/* (eg, -print, -punch, -plot, -end_page, etc).  If all else fails, assume -print.	*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	Ntypes_set = 0;
	if N.output_module > PRINT |			/* -7punch, -mcc, -raw given.			*/
	     N.pt_pch = DP_PUNCH |			/* -punch given				*/
	     Ntype = DP_PUNCH
	then do;					/* punch generic type found from -request_type	*/
	     Ntype = DP_PUNCH;
	     Ntypes_set = Ntypes_set + 1;
	end;
	if N.pt_pch = DP_PRINT |			/* -print given.				*/
	     Ntype = DP_PRINT |			/* print generic type found from -request_type	*/
	     S.nep | S.single | S.non_edited | S.truncate |
						/* other printer-oriented control args.		*/
	     S.label.top | S.label.bottom | S.label.access | N.lmargin > 0 | N.line_lth > 0 | N.page_lth > 0
	     | O.forms_name ^= ""
	then do;
	     Ntype = DP_PRINT;
	     Ntypes_set = Ntypes_set + 1;
	end;
	if N.pt_pch = DP_PLOT |			/* -plot given.				*/
	     Ntype = DP_PLOT
	then do;					/* plotter generic type found from -request_type	*/
	     Ntype = DP_PLOT;
	     Ntypes_set = Ntypes_set + 1;
	end;

	if Ntypes_set = 0
	then					/* If all else fails, assume -print.		*/
	     Ntype = DP_PRINT;
	else if Ntypes_set = 1
	then ;
	else					/* If some inconsistency found, abort.		*/
	     go to INCONSISTENT_PRINT_PUNCH_PLOT;	/* END OF PASS 1.  Generic type of request has now */
	N.pt_pch = Ntype;				/* been determined, and is stored in Ntype.	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* If caller gave -set_default_request_type, then set the default request type name in	*/
/* the header, being sure that defaults for that request type are actually defined.	*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if O.default_request_type ^= ""
	then do;
	     call find_default (O.default_request_type, "", Ntype, FALSE, FALSE, warn_count, Pdefault);

	     if Pdefault = null & (O.name_of_default ^= O.request_type | O.default_request_type ^= O.request_type)
	     then go to DEFAULT_RQT_NOT_DEFINED;

	     default_header.default_request_type (Ntype) = O.default_request_type;
	     call value_$set_data (DEFAULT_VALUE_SEG, PERM, "eor._", Pdefault_header, currentsize (default_header),
		null, null, 0, code);
	     if code ^= 0
	     then go to STORE_FAILURE;
	end;

	if O.request_type = ""
	then					/* Use default request type if -rqt not given.	*/
	     O.request_type = default_header.default_request_type (Ntype);

	if O.name_of_default = ""
	then					/* If -default_name not given, use request type 	*/
	     O.name_of_default = O.request_type;	/*   as the name.				*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* At this point, we definitely have the name of the request type to be used.  Find	*/
/* defaults for this request type.  The defaults can be user-defined or (if the user has	*/
/* not defined defaults for this request type) they may have to be built just for this	*/
/* invocation.								*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	Sdefault_is_stored = TRUE;
	call find_default (O.name_of_default, O.request_type, N.pt_pch, S.set_default | S.replace_default,
	     (S.pathnames), warn_count, Pdefault);
	if Pdefault = null
	then do;					/* User default not set.  Get system values.	*/
	     Pdefault = addr (auto_default);
	     call init_default (Pdefault, O.name_of_default, O.request_type, N.pt_pch);
	     Sdefault_is_stored = FALSE;
	end;

	if S.replace_default
	then do;					/* For -replace_defaults, reinitialize defaults.	*/
	     call init_default (Pdefault, O.name_of_default, O.request_type, N.pt_pch);
	     S.set_default = TRUE;
	end;

	if Ntype = DP_PRINT
	then do;					/* Apply user-defined defaults to argument 	*/
	     S = default_print.Sdft, by name;		/*   structures.				*/
	     N = default_print.Ndft, by name;
	     O = default_print.Odft, by name;
	     PLS_struc = default_print.LSV.fixed_part, by name;
	     PLS_struc.heading.P = addr (default_print.LSV.V.heading);
	     PLS_struc.destination.P = addr (default_print.LSV.V.destination);
	     PLS_struc.top_label.P = addr (default_print.LSV.V.top_label);
	     PLS_struc.bottom_label.P = addr (default_print.LSV.V.bottom_label);
	end;
	else do;
	     S = default_punch.Sdft, by name;
	     N = default_punch.Ndft, by name;
	     O = default_punch.Odft, by name;
	     PLS_struc = default_punch.LSV.fixed_part, by name;
	     PLS_struc.heading.P = addr (default_punch.LSV.V.heading);
	     PLS_struc.destination.P = addr (default_punch.LSV.V.destination);
	end;

	Sgive_label_warning = FALSE;			/* MIDDLE OF PASS 2.  Apply user-specified 	*/
	Sgive_nep_warning = FALSE;			/*   control args to override the defaults.	*/

	if S.non_path_ctl_args
	then					/* Parse arguments for PASS 2.		*/
	     call proc_args (FALSE, Nqueued);


	if O.request_type = default_print.name
	then					/* If the -default_name control arg was omitted,	*/
						/*   then its value came from -rqt control arg	*/
						/*   (or from default_header).  The same is true	*/
						/*   if -request_type was omitted.  In both cases, */
	     if S.dnm_or_rqt_omitted
	     then					/*   use real request type associated with this 	*/
		O.request_type = default_print.request_type;
						/*   group of user-defined defaults.		*/

	if ^S.dnm_or_rqt_omitted
	then					/* If both -request_type and -default_name were	*/
	     if O.request_type ^= default_print.request_type & ^(S.set_default | S.replace_default)
	     then					/*   given and we're not setting/replacing the	*/
		go to INCONSISTENT_DNM_RQT_ARGS;	/*   defaults, and the given request type differs */
						/*   from the one stored with the defaults assoc. */
						/*   with the group identified by -default_name,	*/
						/*   then complain about the inconsistency.	*/

	if N.queue = 0
	then do;					/* Make sure request type is defined.		*/
	     call iod_info_$queue_data (O.request_type, 0, 0, code);
	     if code ^= 0
	     then do;
		if (S.print_default | S.list_defaults | S.delete_default) & ^S.pathnames
		then ;
		else go to DEFAULT_QUEUE_UNDEFINED;
	     end;
	end;
	else do;					/* If user gave a queue, make sure this request	*/
	     call iod_info_$queue_data (O.request_type, 0, max_q, code);
	     if code ^= 0
	     then do;				/*   type defines that queue.			*/
		if (S.print_default | S.list_defaults | S.delete_default) & ^S.pathnames
		then ;
		else go to MAX_QUEUE_UNDEFINED;
	     end;
	     else if N.queue > max_q
	     then go to MAX_QUEUE_EXCEEDED;
	end;

	if N.copies = 0
	then					/* Set default copy count.			*/
	     N.copies = 1;
	else if N.copies > MAX_COPIES
	then do;
	     call ioa_ ("Warning: -copies ^d is too large.  -copies ^d will be used instead.", N.copies, MAX_COPIES);
	     N.copies = MAX_COPIES;
	end;

	if Ntype = DP_PRINT
	then do;					/* Check printer-related items.		*/
	     N.output_module = PRINT;
	     if N.line_lth > MAX_LINE_LENGTH
	     then go to MAX_LINE_LENGTH_EXCEEDED;
	     if N.line_lth > 0
	     then if N.lmargin >= N.line_lth
		then go to INDENT_INCONSISTENT_WITH_LINE_LENGTH;
	     if N.lmargin >= MAX_LINE_LENGTH
	     then go to MAX_INDENT_EXCEEDED;

	     input_forms_string_length = length (rtrim (O.forms_name));
	     allocate validate_forms_info_input in (area);
	     validate_forms_info_input.version = VALIDATE_FORMS_INFO_INPUT_VERSION_1;
	     validate_forms_info_input.request_type = O.request_type;
	     validate_forms_info_input.user_area_ptr = Parea;
	     validate_forms_info_input.max_forms_string_length = 64;
	     validate_forms_info_input.forms_string = rtrim (O.forms_name);
	     call iod_info_$validate_forms_info (validate_forms_info_input_ptr, validate_forms_info_output_ptr, code);
	     if code ^= 0
	     then if code ^= error_table_$no_forms_table_defined
		then go to ERROR_VALIDATING_FORM;
	     if N.line_lth > validate_forms_info_output.chars_per_line
	     then call ioa_ ("Warning: Specified line length (^d) is greater than request type maximum of ^d.",
		     N.line_lth, validate_forms_info_output.chars_per_line);
	     if N.page_lth > validate_forms_info_output.lines_per_page
	     then call ioa_ ("Warning: Specified page length (^d) is greater than request type maximum of ^d.",
		     N.page_lth, validate_forms_info_output.lines_per_page);
	     if O.forms_name ^= "" & ^validate_forms_info_output.forms_allowed
	     then call ioa_ (
		     "Warning:^-The ^a request type does not support user specified forms.^/^-The forms specified may be ignored.",
		     O.request_type);
	     if validate_forms_info_output.forms_length ^= 0
	     then if validate_forms_info_output.returned_forms ^= O.forms_name
		then O.forms_name = validate_forms_info_output.returned_forms;
	end;					/* END OF PASS 2.				*/


	if S.set_default
	then do;					/* Set user-defined group of defaults, based upon */
	     if Ntype = DP_PRINT
	     then do;				/*   current control arguments.		*/
		allocate default_print in (area) set (Pnew_default);
		Pnew_default -> default_print.header = default_print.header;
		Pnew_default -> default_print.size = currentsize (Pnew_default -> default_print);
		Pnew_default -> default_print.Sdft = S, by name;
		Pnew_default -> default_print.Ndft = N, by name;
		Pnew_default -> default_print.Odft.request_type = O.request_type;
		Pnew_default -> default_print.Odft.forms_name =
		     substr (O.forms_name, 1, length (Pnew_default -> default_print.Odft.forms_name));
		Pnew_default -> default_print.LSV.fixed_part = PLS_struc, by name;
		Pnew_default -> default_print.LSV.V.heading = PLS_heading;
		Pnew_default -> default_print.LSV.V.destination = PLS_destination;
		Pnew_default -> default_print.LSV.V.top_label = PLS_top_label;
		Pnew_default -> default_print.LSV.V.bottom_label = PLS_bottom_label;
	     end;
	     else do;
		allocate default_punch in (area) set (Pnew_default);
		Pnew_default -> default_punch.header = default_punch.header;
		Pnew_default -> default_punch.size = currentsize (Pnew_default -> default_punch);
		Pnew_default -> default_punch.Sdft = S, by name;
		Pnew_default -> default_punch.Ndft = N, by name;
		Pnew_default -> default_punch.Odft = O, by name;
		Pnew_default -> default_punch.LSV.fixed_part = PLS_struc, by name;
		Pnew_default -> default_punch.LSV.V.heading = PLS_heading;
		Pnew_default -> default_punch.LSV.V.destination = PLS_destination;
	     end;
	     call free_default (Pdefault);		/* small window here where cleanup would not free	*/
	     Pdefault_temp = Pnew_default;		/*   new defaults storage.  This is better then	*/
	     Pnew_default = null;			/*   trying to free same storage twice.		*/
	     Pdefault = Pdefault_temp;

	     call value_$set_data (DEFAULT_VALUE_SEG, PERM, dft_name$given_ptr (Pdefault), Pdefault, default_print.size,
		null, null, 0, code);
	     if code ^= 0
	     then go to STORE_FAILURE;
	end;

	if N.queue = 0
	then do;					/* Get default queue for request type, if needed.	*/
	     call iod_info_$queue_data (O.request_type, N.queue, 0, code);
	end;

	if S.pathnames
	then do;
	     if warn_count > 0
	     then call ioa_ ("^/Warning: no eor defaults are defined for the ^a request type.", O.request_type);
	     dpap = addr (dprint_arg_buf);		/* overlay storage space with dprint arg structure */
	     dprint_arg.version = dprint_arg_version_10;	/* initialize the structure.			*/
	     dprint_arg.dest = "";
	     dprint_arg.carriage_control = FALSE;
	     dprint_arg.pad (*) = 0;
	     dprint_arg.forms, dprint_arg.form_name, dprint_arg.forms_name = "";
	     dprint_arg.class = "";
	     dprint_arg.bit_count = 0;
	     dprint_arg.chan_stop_path = "";
	     dprint_arg.carriage_control = S.carriage_control, by name;
	     dprint_arg = N, by name;
	     dprint_arg.request_type = O.request_type;
	     dprint_arg.forms_name = substr (O.forms_name, 1, length (dprint_arg.forms_name));
	     Nqueued = 0;				/* initialize operand counter.		*/
	     call proc_args (TRUE, Nqueued);
EXIT:
	     call print_totals (Nqueued);
	end;
	else if S.set_default | S.print_default | S.list_defaults | S.delete_default | O.default_request_type ^= ""
	then ;
	else do;
	     Nqueued = 0;
	     call print_totals (Nqueued);		/* END OF PASS 3.				*/
	end;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* The following code handles -print_defaults, -delete_defaults, -list_defaults and -all. */
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if S.delete_default
	then do;
	     if Sdefault_is_stored
	     then do;
		if S.print_default & ^S.all
		then do;				/* For some reason, user wants to print the 	*/
		     call print_defaults (Pdefault, Sdefault_is_stored);
		     S.print_default = FALSE;		/*   defaults he is deleting.			*/
		end;
		call delete_default (Pdefault);
	     end;
	     else call ioa_ ("^/^a user defaults are not defined.", default_print.name);
	end;

	if S.print_default
	then do;
	     if S.all
	     then do;
		if ^Sdefault_is_stored
		then call print_defaults (Pdefault, Sdefault_is_stored);
		call list_defaults (TRUE);
	     end;
	     else do;
		call print_defaults (Pdefault, Sdefault_is_stored);
		call ioa_ ("");
	     end;
	end;
	if S.list_defaults
	then do;
	     call list_defaults (FALSE);
	     call ioa_ ("");
	end;

FINISH:
	call janitor ();
	return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/*		O  T  H  E  R        E  N  T  R  Y        P  O  I  N  T  S		*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

default_count:
     entry (ANrequest_types);


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* This entry point returns a count of the user-defined request types known to		*/
/* enter_output_request.  It is an internal interface called by print_request_types	*/
/* command to all prt to factor user-defined request types into its output.		*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


dcl  ANrequest_types fixed bin;			/* number of user-defined groups of default eor	*/
						/*   control arg settings.			*/

	ANrequest_types = 0;
	call init ();
	on cleanup call janitor ();

	call find_default_header ();
	if Pdefault_header = null
	then go to FINISH;

	mi.name (1) = dft_name$given_name ("**.*");
	call value_$list_data_names (DEFAULT_VALUE_SEG, PERM, addr (mi), Parea, value_list_info_ptr, code);
	do Idft = 1 to value_list_info.pair_count;
	     call free_default (Pdefault);
	     call value_$get_data (DEFAULT_VALUE_SEG, PERM,
		substr (value_list_info.chars, value_list_info.pairs (Idft).name_index,
		value_list_info.pairs (Idft).name_len), Parea, Pdefault, 0, code);
	     if default_print.Ntype ^= UNDEFINED
	     then ANrequest_types = ANrequest_types + 1;
	end;
	go to FINISH;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


default_request_type:
     entry (Agen_type, Arequest_type, Adefault_q, Amax_q, Acode);

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* This entry point is called by cor/lor/mor to get the user-defined default request	*/
/* type (actually the system-defined target for a user request type) for a particular	*/
/* generic type of I/O Daemon queue, along with the user-defined default queue and	*/
/* system-defined max queue numbers for that request type.				*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

dcl  Agen_type char (*),				/* Generic type for which default is wanted. (In) */
     Arequest_type char (*),				/* Default request type for that gen type. (Out)	*/
     Adefault_q fixed bin,				/* User-defined default queue for that rqt. (Out) */
     Amax_q fixed bin;				/* System-defined max queue for that rqt. (Out)	*/

	Acode = 0;				/* Provide defaults when all else fails.	*/
	Adefault_q = 3;
	Amax_q = 4;
	Arequest_type = Agen_type;

	call init ();
	do Ntype = DP_PRINT to DP_PLOT		/* Convert generic type string to a number.	*/
	     while (Agen_type ^= DEFAULT_RQT (Ntype));
	end;
	if Ntype <= DP_PLOT
	then do;					/* if printer/punch/plotter, get user-defined	*/
	     on cleanup call janitor ();		/*   default request type info.		*/
	     call find_default_header ();
	     if Pdefault_header = null
	     then go to FINISH;
	     O.name_of_default = default_header.default_request_type (Ntype);
	     call find_default (O.name_of_default, "", Ntype, FALSE, FALSE, warn_count, Pdefault);
	     if Pdefault = null
	     then do;				/* user-defined default info does not exist.	*/
		O.request_type = O.name_of_default;	/*   This is probably an inconsistency in user's	*/
		call iod_info_$queue_data (O.request_type, Adefault_q, Amax_q, Acode);
						/*   eor values in the value segment.		*/
	     end;
	     else do;				/* user-defined default info does exist.	*/
		O.request_type = default_print.Odft.request_type;
		if default_print.Ntype = DP_PRINT
		then Adefault_q = default_print.Ndft.queue;
		else Adefault_q = default_punch.Ndft.queue;
		if Adefault_q = 0
		then call iod_info_$queue_data (O.request_type, Adefault_q, Amax_q, Acode);
		else call iod_info_$queue_data (O.request_type, 0, Amax_q, Acode);
	     end;
	     Arequest_type = O.request_type;
	end;
	else					/* Not a generic type handled by eor.		*/
	     call iod_info_$queue_data (Arequest_type, Adefault_q, Amax_q, Acode);
	go to FINISH;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


list_defaults:
     entry (AParea, APeor_defaults, Acode);

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* This entry point fills in the eor_defaults structure (shown below) with information	*/
/* about the user-defined default groups of control arg settings known to eor.  It is	*/
/* called by print_request_types to factor user-defined requests into prt output.	*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

dcl  AParea ptr,
     APeor_defaults ptr,
     Acode fixed bin (35);

%include eor_defaults;

	Acode = 0;
	call init ();
	on cleanup call janitor ();

	call find_default_header ();
	if Pdefault_header = null
	then go to FINISH;

	mi.name (1) = dft_name$given_name ("**.*");
	call value_$list_data_names (DEFAULT_VALUE_SEG, PERM, addr (mi), Parea, value_list_info_ptr, code);

	if AParea ^= null
	then do;					/* Allocate structure in user-supplied area.	*/
	     call default_count (Nrequest_types);
	     allocate eor_defaults in (AParea -> area) set (APeor_defaults);
	     Peor_defaults = APeor_defaults;
	     eor_defaults.version = Veor_defaults_1;
	end;
	else do;					/* Use user-supplied automatic storage for struc. */
	     Peor_defaults = APeor_defaults;
	     if eor_defaults.version ^= Veor_defaults_1
	     then do;
		Acode = error_table_$unimplemented_version;
		go to FINISH;
	     end;
	     call default_count (Nrequest_types);
	     if eor_defaults.N < Nrequest_types
	     then do;
		Acode = error_table_$too_many_names;
		go to FINISH;
	     end;
	     eor_defaults.N = 0;
	end;

	do Idft = 1 to value_list_info.pair_count;	/* Fill in the structure.			*/
	     call free_default (Pdefault);
	     call value_$get_data (DEFAULT_VALUE_SEG, PERM,
		substr (value_list_info.chars, value_list_info.pairs (Idft).name_index,
		value_list_info.pairs (Idft).name_len), Parea, Pdefault, 0, code);
	     if default_print.Ntype ^= UNDEFINED
	     then do;
		eor_defaults.N = eor_defaults.N + 1;
		eor_defaults.request_type (eor_defaults.N).name = default_print.name;
		eor_defaults.request_type (eor_defaults.N).generic_type = DEFAULT_RQT (default_print.Ntype);
		eor_defaults.request_type (eor_defaults.N).Sdefault =
		     default_print.name = default_header.default_request_type (default_print.Ntype);
		eor_defaults.request_type (eor_defaults.N).target_request_type_name = default_print.Odft.request_type;
	     end;
	end;
	go to FINISH;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


request_type:
     entry (Arqt_in, Agen_type, Arequest_type, Adefault_q, Amax_q, Acode);

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* This entry point is called by cor/lor/mor to convert a user-specified request type	*/
/* name into a system request type with appropriate user-defined default queue number,	*/
/* system-defined max queue number and generic type.				*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

dcl  Arqt_in char (*);

	Acode = 0;
	Adefault_q = 3;
	Amax_q = 4;

	call init ();
	on cleanup call janitor ();
	call find_default_header ();
	if Pdefault_header = null
	then go to FINISH;

	call find_default (Arqt_in, "", 0, FALSE, FALSE, warn_count, Pdefault);
	if Pdefault = null
	then do;					/* Not a user-defined request type.  Give system	*/
	     Arequest_type = Arqt_in;			/*   values for gen_type, default_q, max_q.	*/
	     call iod_info_$generic_type (Arequest_type, gen_type, Acode);
	     if Acode ^= 0
	     then go to FINISH;
	     Agen_type = gen_type;
	     call iod_info_$queue_data (Arequest_type, Adefault_q, Amax_q, Acode);
	end;
	else do;					/* Use user-defined values for gen_type, 	*/
	     Agen_type = DEFAULT_RQT (default_print.Ntype);
						/*   default_q, and system value for max_q.	*/
	     Arequest_type = default_print.Odft.request_type;
	     if default_print.Ntype = DP_PRINT
	     then Adefault_q = default_print.Ndft.queue;
	     else Adefault_q = default_punch.Ndft.queue;
	     if Adefault_q = 0
	     then call iod_info_$queue_data (default_print.Odft.request_type, Adefault_q, Amax_q, Acode);
	     else call iod_info_$queue_data (default_print.Odft.request_type, 0, Amax_q, Acode);
	end;
	go to FINISH;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* 		I  N  T  E  R  N  A  L        P  R  O  C  E  D  U  R  E  S		*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


dft_name$given_ptr:
     proc (Pd) returns (char (30));

dcl  Pd ptr;

dcl  1 d aligned like default_print.header based (Pd),
     name char (30) varying;

	name = "eor.";
	name = name || rtrim (d.name);
	name = name || "._";
	return (name);


dft_name$given_name:
     entry (Aname) returns (char (30));

dcl  Aname char (*);

	name = "eor.";
	name = name || rtrim (Aname);
	name = name || "._";
	return (name);

     end dft_name$given_ptr;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


delete_default:
     proc (Pd);

dcl  Pd ptr;

dcl  Pnew_default ptr,
     1 d aligned like default_print.header based (Pd);

	if default_header.default_request_type (Ntype) = d.name
	then do;
	     default_header.default_request_type (Ntype) = DEFAULT_RQT (Ntype);
	     Pnew_default = null;
	     on cleanup call free_default (Pnew_default);
	     call find_default (DEFAULT_RQT (Ntype), DEFAULT_RQT (Ntype), Ntype, TRUE, FALSE, warn_count, Pnew_default);
	     call free_default (Pnew_default);		/* Make sure defaults exist for this generic type. */
	     call value_$set_data (DEFAULT_VALUE_SEG, PERM, "eor._", Pdefault_header, currentsize (default_header),
		null, null, 0, code);
	     if code ^= 0
	     then go to STORE_FAILURE;		/* Store new default_header.			*/
	end;

	call value_$set_data (DEFAULT_VALUE_SEG, PERM, dft_name$given_ptr (Pd), null, 0, null, null, 0, code);
	if code ^= 0
	then go to DELETE_FAILURE;

     end delete_default;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


find_default:
     proc (name, rqt, Ntype, Screate, Sset_warn_count, warn_count, Pd);

dcl  name char (*),
     rqt char (*),
     Ntype fixed bin,
     Screate bit (1),
     Sset_warn_count bit (1),
     warn_count fixed bin,
     Pd ptr;

dcl  Syes bit (1),
     1 d aligned like default_print.header based (Pd),
     size builtin;

	warn_count = 0;
	if Pd ^= null
	then if d.name ^= name
	     then call free_default (Pd);
	if Pd = null
	then call value_$get_data (DEFAULT_VALUE_SEG, PERM, dft_name$given_name (name), Parea, Pd, 0, code);
	else code = 0;

	if code = 0
	then do;
	     if d.Ntype = UNDEFINED
	     then do;
		if Screate | ^Sset_warn_count
		then do;
		     call free_default (Pd);
		     code = error_table_$noentry;
		end;
		else do;				/* Issue warning that no user defaults defined.	*/
		     warn_count, d.size = d.size + 1;
		     if d.size > 3
		     then do;
			call free_default (Pd);
			code = error_table_$out_of_bounds;
			warn_count = 0;
			call ioa_ ("^/Setting user defaults for ^a request type to system default values.
No more warnings will be issued.", name);
		     end;
		     else do;
			call value_$set_data (DEFAULT_VALUE_SEG, PERM, dft_name$given_ptr (Pd), Pd, size (d), null,
			     null, 0, code);
			if code ^= 0
			then go to STORE_FAILURE;
			call free_default (Pd);
			code = error_table_$noentry;
		     end;
		end;
	     end;
	end;
	else if code ^= 0 & Sset_warn_count & ^Screate
	then do;
	     Pd = addr (auto_default);
	     d.name = name;
	     d.Ntype = UNDEFINED;
	     d.size = 1;
	     call value_$set_data (DEFAULT_VALUE_SEG, PERM, dft_name$given_ptr (Pd), Pd, size (d), null, null, 0, code);
	     if code ^= 0
	     then go to STORE_FAILURE;
	     code = error_table_$noentry;
	     warn_count = 1;
	     Pd = null;
	end;

	if code ^= 0
	then do;
	     if ^Screate & code ^= error_table_$out_of_bounds
	     then do;
		Pd = null;
		return;
	     end;
	     Pd = addr (auto_default);
	     call init_default (Pd, name, rqt, Ntype);
	     call value_$set_data (DEFAULT_VALUE_SEG, PERM, dft_name$given_ptr (Pd), Pd, d.size, null, null, 0, code);
	     if code ^= 0
	     then go to STORE_FAILURE;
	end;
	else do;
	     if Ntype ^= UNDEFINED & d.Ntype ^= Ntype
	     then do;
		if Screate
		then do;
		     call command_query_$yes_no (Syes, 0, proc, "yes, y
   change the generic type of ^a to ^3s^[printer^;punch^;plotter^]
no, n
   do not change the generic type of ^a to ^[printer^;punch^;plotter^].
   Instead, exit the eor command without doing anything.

Change the generic type?", "The ^a eor default already exists, and is a^[
^; ^]^[printer^;punch^;plotter^] generic type.^[
^;  ^]Do you want to change its generic type to ^[printer^;punch^;plotter^]?", name, ll_query () < 90, d.Ntype,
			ll_query () >= 90, Ntype, name, Ntype);
		     if Syes
		     then do;
			call free_default (Pd);
			Pd = addr (auto_default);
			call init_default (Pd, name, rqt, Ntype);
			call value_$set_data (DEFAULT_VALUE_SEG, PERM, dft_name$given_ptr (Pd), Pd, d.size, null,
			     null, 0, code);
			if code ^= 0
			then go to STORE_FAILURE;
		     end;
		     else go to FINISH;
		end;
		else do;
		     call com_err_ (error_table_$inconsistent, proc, "^[-print^;-punch^;-plot^]
cannot be used with the ^a eor defaults, which are ^[printer^;punch^;plotter^] defaults.", Ntype, name, d.Ntype);
		     go to FINISH;
		end;
	     end;
	end;

     end find_default;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


find_default_header:
     proc;

dcl  Idft fixed bin,
     header char (6),
     old_header char (28);

	header = "eor._";				/* Name of default_header structure value.	*/

REFIND_HEADER:
	call value_$get_data (DEFAULT_VALUE_SEG, PERM, header, Parea, Pdefault_header, 0, code);
	if code = error_table_$oldnamerr
	then do;
	     old_header = rtrim (person) || ".eor._";
	     call value_$get_data (DEFAULT_VALUE_SEG, PERM, old_header, Parea, Pdefault_header, 0, code);
	end;
	if code = error_table_$oldnamerr
	then do;
	     Pdefault_header = addr (auto_default_header);
	     default_header.version = Vdefault_header_10;
	     do Idft = DP_PRINT to DP_PLOT;
		default_header.default_request_type (Idft) = DEFAULT_RQT (Idft);
		Pdefault = addr (auto_default);
		call init_default (Pdefault, DEFAULT_RQT (Idft), DEFAULT_RQT (Idft), Idft);
		call value_$set_data (DEFAULT_VALUE_SEG, PERM, dft_name$given_ptr (Pdefault), Pdefault,
		     default_print.size, null, null, 0, code);
		if code ^= 0
		then go to STORE_FAILURE;
	     end;
	     call value_$set_data (DEFAULT_VALUE_SEG, PERM, header, Pdefault_header, currentsize (default_header), null,
		null, 0, code);
	     if code ^= 0
	     then go to STORE_FAILURE;
	end;

	else if code = error_table_$noentry
	then do;
	     call value_$set_path (value_seg_path, TRUE, code);
	     if code = 0
	     then go to REFIND_HEADER;
	     else do;
		call com_err_ (code, proc, "Creating default value segment
(^a).", value_seg_path);
		go to FINISH;
	     end;
	end;

	else if code ^= 0
	then do;
	     call com_err_ (code, proc, "^[^/^]Getting defaults from value segment
(^a).", ll_err () < 100, value_seg_path);
	     Pdefault_header = null;
	     return;
	end;

	if default_header.version = Vdefault_header_5
	then do;
	     call eor_cv5_6_ (addr (default_header), code);
	     if code ^= 0
	     then do;
		call com_err_ (code, proc, "
Converting eor defaults in value segment from version 5 to 6.
(^a).", value_seg_path);
		go to FINISH;
	     end;
	end;

	if default_header.version = Vdefault_header_6
	then do;
	     call eor_cv6_7_ (addr (default_header), code);
	     if code ^= 0
	     then do;
		call com_err_ (code, proc, "
Converting eor defaults in value segment from version 6 to 7.
(^a).", value_seg_path);
		go to FINISH;
	     end;
	end;


	if default_header.version = Vdefault_header_7
	then do;
	     call eor_cv7_8_ (addr (default_header), code);
	     if code ^= 0
	     then do;
		call com_err_ (code, proc, "
Converting eor defaults in value segment from version 7 to 8.
(^a).", value_seg_path);
		go to FINISH;
	     end;
	end;

	if default_header.version = Vdefault_header_8
	then do;
	     call eor_cv8_9_ (addr (default_header), code);
	     if code ^= 0
	     then do;
		call com_err_ (code, proc, "
Converting eor defaults in value segment from version 8 to 9.
(^a).", value_seg_path);
		go to FINISH;
	     end;
	end;

	if default_header.version = Vdefault_header_9
	then do;
	     call eor_cv9_10_ (addr (default_header), code);
	     if code ^= 0
	     then do;
		call com_err_ (code, proc, "
Converting eor defaults in value segment from version 9 to 10.
(^a).", value_seg_path);
		go to FINISH;
	     end;
	end;

	if default_header.version = Vdefault_header_10
	then ;
	else do;
	     call com_err_ (error_table_$unimplemented_version, proc, "
eor defaults are structured as version ^d defaults.  eor has never supported
this version.  Evidently, your value segment has been damaged
(^a).", default_header.version, value_seg_path);
	     free default_header in (area);
	     Pdefault_header = null;
	end;

     end find_default_header;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


free_default:
     proc (Pd);

dcl  1 dwarn aligned like default_print.header based (Pd);

	if Pd ^= null
	then if Pd ^= addr (auto_default)
	     then if dprint.Ntype = DP_PRINT
		then free dprint in (area);
		else if dprint.Ntype = UNDEFINED
		then free dwarn in (area);
		else free dpunch in (area);
	Pd = null;
	return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


init_default:
     entry (Pd, name, rqt, Ntype);

dcl  Pd ptr,
     name char (*),
     rqt char (*),
     Ntype fixed bin;

dcl  1 dprint aligned based (Pd),
       2 header like default_print.header,
       2 Odft like default_print.Odft,
       2 Sdft like default_print.Sdft,
       2 Ndft like default_print.Ndft,
       2 LSV,
         3 fixed_part like default_print.LSV.fixed_part,
         3 V,
	 4 heading char (0 refer (dprint.LSV.heading.L)) unal,
	 4 destination char (0 refer (dprint.LSV.destination.L)) unal,
	 4 top_label char (0 refer (dprint.LSV.top_label.L)) unal,
	 4 bottom_label char (0 refer (dprint.LSV.bottom_label.L)) unal,
     1 dpunch aligned based (Pd),
       2 header like default_punch.header,
       2 Odft like default_punch.Odft,
       2 Sdft like default_punch.Sdft,
       2 Ndft like default_punch.Ndft,
       2 LSV,
         3 fixed_part like default_punch.LSV.fixed_part,
         3 V,
	 4 heading char (0 refer (dpunch.LSV.heading.L)) unal,
	 4 destination char (0 refer (dpunch.LSV.destination.L)) unal;

	dprint.Ntype = Ntype;
	dprint.name = name;
	if Ntype = DP_PRINT
	then do;					/* Initialize printer defaults.		*/
	     dprint.Odft = "";
	     dprint.Odft.request_type = rqt;
	     dprint.Sdft = FALSE;
	     dprint.Sdft.label.access = TRUE;
	     dprint.Ndft = 0;
	     dprint.Ndft.pt_pch = DP_PRINT;
	     dprint.Ndft.copies = 1;
	     dprint.Ndft.output_module = PRINT;
	     dprint.Ndft.line_lth = -1;
	     dprint.Ndft.page_lth = -1;
	     dprint.Ndft.queue = 0;			/*   Use default queue for this request type.	*/
	     dprint.LSV.heading.S = FALSE;
	     dprint.LSV.heading.L = 0;
	     dprint.LSV.destination.S = FALSE;
	     dprint.LSV.destination.L = 0;
	     dprint.LSV.top_label.S = FALSE;
	     dprint.LSV.top_label.L = 0;
	     dprint.LSV.bottom_label.S = FALSE;
	     dprint.LSV.bottom_label.L = 0;
	     dprint.LSV.V.heading = "";
	     dprint.LSV.V.destination = "";
	     dprint.size = currentsize (dprint);
	end;
	else do;					/* Initialize punch/plotter defaults.		*/
	     dpunch.Odft.request_type = rqt;
	     dpunch.Sdft = FALSE;
	     dpunch.Ndft = 0;
	     dpunch.Ndft.pt_pch = Ntype;
	     dpunch.Ndft.copies = 1;
	     if Ntype = DP_PUNCH
	     then dpunch.Ndft.output_module = MCC;
	     else dpunch.Ndft.output_module = PLOT;
	     dpunch.Ndft.queue = 0;			/*   Use default queue for this request type.	*/
	     dpunch.LSV.heading.S = FALSE;
	     dpunch.LSV.heading.L = 0;
	     dpunch.LSV.destination.S = FALSE;
	     dpunch.LSV.destination.L = 0;
	     dpunch.LSV.V.heading = "";
	     dpunch.LSV.V.destination = "";
	     dpunch.size = currentsize (dpunch);
	end;

     end free_default;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


init:
     proc ();

	if person = ""
	then do;					/* Get per-process values.			*/
	     call user_info_ (person, proj, "");
	     Parea = get_system_free_area_ ();
	end;

	call value_$get_path (value_seg_path, code);	/* Get path of default value seg for error msgs.	*/
	if code ^= 0
	then do;
	     call com_err_ (code, proc, "Getting default value segment pathname.");
	     go to FINISH;
	end;

	Pdefault_header = null;			/* Establish cleanup on unit.			*/
	Pdefault = null;
	Pnew_default = null;
	value_list_info_ptr = null;
	Pfcb = null;
	Pseg = null;
	star_entry_ptr = null;

	validate_forms_info_input_ptr, validate_forms_info_output_ptr = null;

     end init;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


janitor:
     proc ();

	if star_entry_ptr ^= null
	then free star_names in (area), star_entries in (area);
						/* free structures.				*/
	if value_list_info_ptr ^= null
	then free value_list_info in (area);
	if Pseg ^= null
	then call hcs_$terminate_noname (Pseg, 0);
	if Pfcb ^= null
	then call msf_manager_$close (Pfcb);
	if Pdefault_header ^= null
	then if Pdefault_header ^= addr (auto_default_header)
	     then free default_header in (area);
	call free_default (Pdefault);
	call free_default (Pnew_default);
	if validate_forms_info_input_ptr ^= null
	then free validate_forms_info_input in (area);
	if validate_forms_info_output_ptr ^= null
	then free validate_forms_info_output in (area);

     end janitor;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


list_defaults:
     proc (Sprint_defaults);

dcl  Sprint_defaults bit (1);

dcl  Idft fixed bin,
     Ntype fixed bin,
     Sfirst bit (1);

	mi.name (1) = dft_name$given_name ("**.*");
	if value_list_info_ptr ^= null
	then free value_list_info in (area);
	call value_$list_data_names (DEFAULT_VALUE_SEG, PERM, addr (mi), Parea, value_list_info_ptr, code);
	do Ntype = DP_PRINT to DP_PLOT;
	     Sfirst = TRUE;
	     do Idft = 1 to value_list_info.pair_count;
		if substr (value_list_info.chars, value_list_info.pairs (Idft).name_index, 1) ^= " "
		then do;
		     call free_default (Pdefault);
		     call value_$get_data (DEFAULT_VALUE_SEG, PERM,
			substr (value_list_info.chars, value_list_info.pairs (Idft).name_index,
			value_list_info.pairs (Idft).name_len), Parea, Pdefault, 0, code);
		     if Pdefault = null
		     then ;			/* Do nothing for warn_count structures.	*/
		     else if default_print.Ntype = Ntype
		     then do;
			if Sprint_defaults
			then do;
			     call print_defaults (Pdefault, TRUE);
			     call ioa_ ("");
			     Sfirst = FALSE;
			end;
			else do;
			     call ioa_ ("^[Defaults for ^[print^;punch^;plott^]ing:
^;^s^]  ^a^[  -rqt ^a^;^s^]^[  (default)^]", Sfirst, Ntype, default_print.name,
				default_print.request_type ^= default_print.name, default_print.request_type,
				default_print.name = default_header.default_request_type (Ntype));
			     Sfirst = FALSE;
			end;
			substr (value_list_info.chars, value_list_info.pairs (Idft).name_index, 1) = " ";
		     end;
		end;
	     end;

	     if Sfirst
	     then do;
		if Sprint_defaults
		then do;
		     call free_default (Pdefault);
		     Pdefault = addr (auto_default);
		     call init_default (Pdefault, default_header.default_request_type (Ntype),
			default_header.default_request_type (Ntype), Ntype);
		     call print_defaults (Pdefault, TRUE);
		     call ioa_ ("");
		end;
		else do;
		     call ioa_ ("Defaults for ^[print^;punch^;plott^]ing:
  ^a  (default)", Ntype, default_header.default_request_type (Ntype));
		end;
	     end;
	end;

     end list_defaults;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


ll_err:
     proc returns (fixed bin) reducible;

	if line_length_error = 0
	then line_length_error = get_line_length_$switch (iox_$error_output, 0);
	return (line_length_error);

ll_query:
     entry returns (fixed bin) reducible;

	if line_length_query = 0
	then line_length_query = get_line_length_$switch (iox_$user_io, 0);
	return (line_length_query);

     end ll_err;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


path:
     proc (dir, ent) returns (char (168) varying);

dcl  dir char (*),
     ent char (*);

	if dir = ">"
	then return (rtrim (dir) || rtrim (ent));
	else return (rtrim (dir) || ">" || rtrim (ent));

     end path;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


print_defaults:
     proc (Pd, Sdefault_is_stored);

dcl  Pd ptr,
     Sdefault_is_stored bit (1);

dcl  Srqt_defined bit (1),
     code fixed bin (35),
     default_queue fixed bin;

dcl  1 dprint aligned based (Pd),
       2 header like default_print.header,
       2 Odft like default_print.Odft,
       2 Sdft like default_print.Sdft,
       2 Ndft like default_print.Ndft,
       2 LSV,
         3 fixed_part like default_print.LSV.fixed_part,
         3 V,
	 4 heading char (0 refer (dprint.LSV.heading.L)) unal,
	 4 destination char (0 refer (dprint.LSV.destination.L)) unal,
	 4 top_label char (0 refer (dprint.LSV.top_label.L)) unal,
	 4 bottom_label char (0 refer (dprint.LSV.bottom_label.L)) unal,
     1 dpunch aligned based (Pd),
       2 header like default_punch.header,
       2 Odft like default_punch.Odft,
       2 Sdft like default_punch.Sdft,
       2 Ndft like default_punch.Ndft,
       2 LSV,
         3 fixed_part like default_punch.LSV.fixed_part,
         3 V,
	 4 heading char (0 refer (dpunch.LSV.heading.L)) unal,
	 4 destination char (0 refer (dpunch.LSV.destination.L)) unal;

	if ^Sdefault_is_stored
	then call ioa_ ("^/^a user defaults are not defined.  System defaults are:", dprint.name);
	if dprint.Ntype = DP_PRINT
	then do;
	     default_queue = 0;
	     call iod_info_$queue_data (dprint.request_type, default_queue, 0, code);
	     Srqt_defined = (code = 0);
	     call ioa_ ("^a:^[ (default for printing)^]
  -rqt ^a^[^; (undefined)^]  -print
  -he^[ -astr^]^[ -enm^] ^[^a (default)^s^;^s^a^]
  -ds^[ -astr^]^[ -enm^] ^[^a (default)^s^;^s^a^]" || "
^[  -dl^]^[  -nt^]^[  -dupt^]  -q ^[^d (default)^s^;^s^d^]^[  -cp ^d^;^s^]^[  -ll ^d^;^s^]^[  -pl ^d^;^s^]"
		|| "^[  -ind ^d^;^s^]^[  -bf^]^[  -fc^]^[  -albl^]^[
^]^[  -nep^]^[  -nvertsp^]^[  -ned^]^[  -tc^]^[  -nsep^]^[  -nb^]^[^[" || "
  -label^[ -astr^]^[ -enm^]^[ -center^] ^a^10s^;^4s^[
  -tlbl^[ -astr^]^[ -enm^]^[ -center^] ^a^;^4s^]^[
  -blbl^[ -astr^]^[ -enm^]^[ -center^] ^a^;^4s^]^]^;^15s^]^[
  -forms ^a^;^s^]", dprint.name, dprint.name = default_header.default_request_type (DP_PRINT), dprint.Odft.request_type,
		Srqt_defined, dprint.LSV.heading.S.active_string, dprint.LSV.heading.S.equal_name,
		dprint.LSV.V.heading = "", person, requote_string_ (dprint.LSV.V.heading),
		dprint.LSV.destination.S.active_string, dprint.LSV.destination.S.equal_name,
		dprint.LSV.V.destination = "", proj, requote_string_ (dprint.LSV.V.destination),
		dprint.Ndft.delete = 1, dprint.Ndft.notify = 1, dprint.Ndft.defer_until_process_termination = 1,
		dprint.Ndft.queue = 0, default_queue, dprint.Ndft.queue, dprint.Ndft.copies > 1, dprint.Ndft.copies,
		dprint.Ndft.line_lth > 0, dprint.Ndft.line_lth, dprint.Ndft.page_lth > 0, dprint.Ndft.page_lth,
		dprint.Ndft.lmargin > 0, dprint.Ndft.lmargin, dprint.Sdft.brief, dprint.Sdft.force,
		dprint.Sdft.label.access,
		(dprint.Sdft.nep | dprint.Sdft.single | dprint.Sdft.non_edited | dprint.Sdft.truncate),
		dprint.Sdft.nep, dprint.Sdft.single, dprint.Sdft.non_edited, dprint.Sdft.truncate,
		dprint.Sdft.no_separator, dprint.Sdft.line_nbrs, (dprint.Sdft.label.top | dprint.Sdft.label.bottom),
		(dprint.LSV.V.top_label = dprint.LSV.V.bottom_label
		& unspec (dprint.LSV.top_label.S) = unspec (dprint.LSV.bottom_label.S)),
		dprint.LSV.top_label.S.active_string, dprint.LSV.top_label.S.equal_name,
		dprint.LSV.top_label.S.center, requote_string_ (dprint.LSV.V.top_label), dprint.Sdft.label.top,
		dprint.LSV.top_label.S.active_string, dprint.LSV.top_label.S.equal_name,
		dprint.LSV.top_label.S.center, requote_string_ (dprint.LSV.V.top_label), dprint.Sdft.label.bottom,
		dprint.LSV.bottom_label.S.active_string, dprint.LSV.bottom_label.S.equal_name,
		dprint.LSV.bottom_label.S.center, requote_string_ (dprint.LSV.V.bottom_label),
		(dprint.Odft.forms_name ^= ""), requote_string_ (rtrim (dprint.Odft.forms_name)));
	end;


	else do;
	     default_queue = 0;
	     call iod_info_$queue_data (dpunch.request_type, default_queue, 0, code);
	     Srqt_defined = (code = 0);
	     call ioa_ ("^a:^[ (default for ^[^;punch^;plott^]ing)^;^s^]
  -rqt ^a^[^; (undefined)^]  ^[^;-punch^;-plot^]
  -he^[ -astr^]^[ -enm^] ^[^a (default)^s^;^s^a^]"
		||
		"
  -ds^[ -astr^]^[ -enm^] ^[^a (default)^s^;^s^a^]
^[  -dl^]^[  -nt^]^[  -dupt^]  -q ^[^d (default)^s^;^s^d^]^[  -cp ^d^;^s^]^[  -bf^]^[  -fc^]^[^;  -7punch^;  -mcc^;  -raw^]",
		dpunch.name, dpunch.name = default_header.default_request_type (dpunch.Ntype), dpunch.Ntype,
		dpunch.Odft.request_type, Srqt_defined, dpunch.Ntype, dpunch.LSV.heading.S.active_string,
		dpunch.LSV.heading.S.equal_name, dpunch.LSV.V.heading = "", person,
		requote_string_ (dpunch.LSV.V.heading), dpunch.LSV.destination.S.active_string,
		dpunch.LSV.destination.S.equal_name, dpunch.LSV.V.destination = "", proj,
		requote_string_ (dpunch.LSV.V.destination), dpunch.Ndft.delete = 1, dpunch.Ndft.notify = 1,
		dpunch.Ndft.defer_until_process_termination = 1, dpunch.Ndft.queue = 0, default_queue,
		dpunch.Ndft.queue, dpunch.Ndft.copies > 1, dpunch.Ndft.copies, dpunch.Sdft.brief, dpunch.Sdft.force,
		dpunch.Ndft.output_module);
	end;

     end print_defaults;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


print_totals:
     proc (Nqueued);

dcl  Nqueued fixed bin;

dcl  Nalready_in_queue fixed bin,			/* number of entries queued.			*/
     code fixed bin (35);

	if S.brief
	then ;					/* if in brief mode, don't report queue statistics */
	else do;
	     call dprint_$queue_contents (O.request_type, N.queue, Nalready_in_queue, code);
	     if code = error_table_$noentry
	     then Nalready_in_queue = 0;
	     else Nalready_in_queue = Nalready_in_queue - Nqueued;
						/* compute how many were queued before we added	*/
	     if Nalready_in_queue < 0
	     then					/* ours.  Make sure total doesn't come out	*/
		Nalready_in_queue = 0;		/* negative (one of ours already printed).	*/
	     call ioa_ ("^[^d request^[s^] submitted; ^d already^s^;^2s^d request^[s^]^] in ^a queue ^d.", Nqueued > 0,
		Nqueued, Nqueued > 1, Nalready_in_queue, Nalready_in_queue ^= 1, O.request_type, N.queue);
	end;

     end print_totals;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


proc_args:
     proc (Ssubmit, Nqueued);

dcl  Ssubmit bit (1),
     Nqueued fixed bin;

dcl  IPLS fixed bin,
     Iarg fixed bin,
     Isearch fixed bin,
     Larg fixed bin (21),
     Lop fixed bin (21),
     Parg ptr,
     Pop ptr,
     Snon_path_ctl_arg bit (1),
     Sstring bit (1),
     arg char (Larg) based (Parg),
     argv char (32) varying,
     arg_no fixed bin,
     op char (Lop) based (Pop),
     op_no fixed bin unsigned;

	do Iarg = 1 to Nargs;
	     call cu_$arg_ptr_rel (Iarg, Parg, Larg, code, Parg_list);
	     if index (arg, "-") ^= 1
	     then do;
		S.pathnames = TRUE;
		if Ssubmit
		then call proc_path (arg, FALSE, Nqueued);
	     end;
	     else do;
		Snon_path_ctl_arg = TRUE;
		argv = arg || NL;			/* add a NL to user-supplied control arg to 	*/
		Isearch = index (arg_table, argv);	/*   that search through arg_table finds exactly	*/
		if Isearch = 0
		then do;				/*   the control arg user specified.		*/
		     S.error = TRUE;
		     call com_err_ (error_table_$badopt, proc, "^a", arg);
		end;
		else do;
		     Pdesc = addr (Pdesc);
		     Pdesc = addr (arg_tbl_array (Isearch - length (string (desc))));
		     arg_no = desc.arg_no;
		     if desc.type = "S+" & ^Ssubmit
		     then switch_array (arg_no) = TRUE;
		     else if desc.type = "S^" & ^Ssubmit
		     then switch_array (arg_no) = FALSE;
		     else if desc.type = "N " & ^Ssubmit
		     then number_array (arg_no) = desc.arg_val;

		     else if desc.type = "Nb" | desc.type = "Ch" | desc.type = "PL" | desc.type = "Sp"
		     then do;
			if desc.type = "Nb" | desc.type = "Ch" | desc.type = "PL"
			then do;
			     if Iarg = Nargs
			     then do;
				S.error = TRUE;
				call com_err_ (error_table_$noarg, proc, "^a requires an operand.", arg);
				Pop = addr (Pop);
				Lop = 0;
			     end;
			     else do;
				Iarg = Iarg + 1;
				call cu_$arg_ptr_rel (Iarg, Pop, Lop, code, Parg_list);
			     end;
			end;

			if desc.type = "Nb" & ^Ssubmit
			then do;
			     if op = "default" | op = "dft" | op = "-default" | op = "-dft"
			     then op_no = 0;
			     else do;
				on conversion, size
				     begin;
				     S.error = TRUE;
				     call com_err_ (error_table_$bad_arg, proc, "^a ^a
^a requires a nonnegative integer operand.", arg, op, arg);
				     op_no = 0;
				     go to IGNORE_OPERAND;
				end;
				op_no = convert (op_no, op);
IGNORE_OPERAND:
				revert conversion, size;
			     end;
			     number_array (arg_no) = op_no;
			end;

			else do;
			     if desc.type = "PL"
			     then do;
				IPLS = desc.arg_val;
				if ^Ssubmit
				then PLS.S (IPLS) = FALSE;
				Sstring = FALSE;
				Sdefault = FALSE;
				do while (index (op, "-") = 1 & ^Sstring & Iarg <= Nargs);
				     if op = "-active_string" | op = "-astr"
				     then if Ssubmit
					then ;
					else PLS.S (IPLS).active_string = TRUE;
				     else if op = "-equal_name" | op = "-enm" | op = "-eqnm" | op = "-equal"
					| op = "-eq"
				     then if Ssubmit
					then ;
					else PLS.S (IPLS).equal_name = TRUE;
				     else if op = "-center" & (IPLS > 2)
						/* -center cannot be used with -ds or -he. */
				     then if Ssubmit
					then ;
					else PLS.S (IPLS).center = TRUE;
				     else if op = "-string" | op = "-str"
				     then Sstring = TRUE;

				     else if (op = "-default" | op = "-dft") & (IPLS <= 2)
				     then do;
					Sdefault = TRUE;
					Iarg = Iarg + 1;
					op = "";
					if PLS.S (IPLS).center | PLS.S (IPLS).active_string
					     | PLS.S (IPLS).equal_name
					then do;
					     S.error = TRUE;
					     call com_err_ (error_table_$badopt, proc,
						"^a^[ -astr^]^[ -enm^] -default." || "
The only control arguments which can follow^[ -astr^]^[ -enm^] are:
  -string, -str     ^[-active_string, -astr^]" || "^[^/  -equal_name, -enm^]
If you want -default as a literal ^[heading^;destination^], use: ^a^[ -astr^]^[ -enm^] -string -default", arg,
						PLS.S (IPLS).active_string, PLS.S (IPLS).equal_name,
						PLS.S (IPLS).active_string, PLS.S (IPLS).equal_name,
						PLS.S (IPLS).equal_name, PLS.S (IPLS).active_string, IPLS,
						arg, PLS.S (IPLS).active_string, PLS.S (IPLS).equal_name);
					end;
				     end;

				     else do;
					S.error = TRUE;
					call com_err_ (error_table_$badopt, proc, "^a ^a.
The only control arguments which can follow ^a are:
  -string, -str	-active_string, -astr
  -equal_name, -enm ^[-center^;-default, -dft^]
If you want ^a as a literal ^[heading^;destination^;label^;label^;label^], use:  ^a -string ^a", arg, op, arg,
					     (arg ^= "-ds" & arg ^= "-destination" & arg ^= "-he"
					     & arg ^= "-header"), op, IPLS, arg, op);
					Pop = addr (Pop);
					Lop = 0;
				     end;
				     if Pop = addr (Pop)
				     then ;	/* got an error above.  */
				     else if Sdefault
				     then ;

				     else if Iarg = Nargs
				     then do;
					S.error = TRUE;
					call com_err_ (error_table_$noarg, proc, "^[
^]^a^[ -center^]^[ -active_string^]^[ -equal_name^]^[ -string^] requires an operand.", ll_err () < 85, arg,
					     PLS.S (IPLS).center, PLS.S (IPLS).active_string,
					     PLS.S (IPLS).equal_name, Sstring);
					Pop = addr (Pop);
					Lop = 0;
				     end;
				     else do;
					Iarg = Iarg + 1;
					call cu_$arg_ptr_rel (Iarg, Pop, Lop, code, Parg_list);
				     end;
				end;
				if ^Ssubmit
				then do;
				     PLS.P (IPLS) = addr (op);
				     PLS.L (IPLS) = length (rtrim (op));
				     if ^Sstring
				     then if search (op, "=%") > 0
					then PLS.S (IPLS).equal_name = TRUE;
				end;
			     end;

			     if Ssubmit
			     then if arg_no ^= 12	/* check for -name */
				then go to END_OP;
			     go to PROC_OP (arg_no);

PROC_OP (01):
PROC_OP (02):
			     go to END_OP;

PROC_OP (03):
			     S.label.top, S.label.bottom = TRUE;
			     S.label.access = FALSE;
			     PLS_struc.bottom_label = PLS_struc.top_label;
GIVE_LABEL_WARNING:
			     if Sgive_nep_warning
			     then do;
				if S.nep
				then do;
				     call ioa_ ("Warning: -no_end_page is ignored when ^a is given.", arg);
				     Sgive_nep_warning = FALSE;
				end;
			     end;
			     S.nep = FALSE;
			     go to END_OP;

PROC_OP (04):
			     S.label.top = TRUE;
			     if S.label.access
			     then S.label.access = ^S.label.bottom;
			     go to GIVE_LABEL_WARNING;

PROC_OP (05):
			     S.label.bottom = TRUE;
			     if S.label.access
			     then S.label.access = ^S.label.top;
			     go to GIVE_LABEL_WARNING;

PROC_OP (06):
			     S.label.access = TRUE;
			     S.label.top, S.label.bottom = FALSE;
			     go to GIVE_LABEL_WARNING;

PROC_OP (07):
			     S.label.access, S.label.top, S.label.bottom = FALSE;
			     go to END_OP;

PROC_OP (08):
			     S.nep = TRUE;
			     if Sgive_label_warning
			     then do;
				if (S.label.access | S.label.top | S.label.bottom)
				then do;
				     call ioa_ ("Warning: labels are ignored when -no_end_page is given.");
				     Sgive_label_warning = FALSE;
				end;
			     end;
			     S.label = FALSE;
			     go to END_OP;

PROC_OP (09):
			     S.all = TRUE;
			     S.print_default = TRUE;
			     go to END_OP;

PROC_OP (10):
			     O.request_type = op;
			     if length (op) > length (O.request_type)
			     then do;
				call com_err_ (error_table_$bigarg, proc, "^a ^a
A request type name must be less than ^d characters long.", arg, op, length (O.request_type) + 1);
				S.error = TRUE;
			     end;
			     else if index (op, "-") = 1 | search (op, "*?") > 0
			     then do;
				if op = "-all" | op = "-a"
				then call com_err_ (error_table_$badopt, proc, "^a ^a
A request type name cannot begin with a hyphen.  To change all sets of^[
^; ^]user-defined defaults, use:^[^/^]  eor -dnm ([prt ** -udf]) -sdft {-control_args}", arg, op, ll_err () < 132,
					ll_err () >= 132);
				else if index (op, "-") = 1
				then call com_err_ (error_table_$badopt, proc, "^a ^a^[
^;   ^]A request type name cannot begin with a hyphen.", arg, op, ll_err () < 118);
				else call com_err_ (error_table_$nostars, proc, "^a ^a
To change several sets of user-defined defaults, use:^[
^]  eor -dnm ([prt ^a -udf]) -sdft {-control_args}", arg, op, ll_err () < 118, op);
				S.error = TRUE;
			     end;
			     go to END_OP;

PROC_OP (11):
			     O.default_request_type = op;
			     if O.request_type = ""
			     then O.request_type = op;
			     go to END_OP;

PROC_OP (12):
			     if Ssubmit
			     then call proc_path (op, TRUE, Nqueued);
			     Snon_path_ctl_arg = FALSE;
			     S.pathnames = TRUE;
			     go to END_OP;

PROC_OP (13):
			     O.name_of_default = op;
			     if length (op) > length (O.name_of_default)
			     then do;
				call com_err_ (error_table_$bigarg, proc, "^a ^a
A default name must be less than ^d characters long.", arg, op, length (O.name_of_default) + 1);
				S.error = TRUE;
			     end;
			     else if index (op, "-") = 1 | search (op, "*?") > 0
			     then do;
				if op = "-all" | op = "-a"
				then call com_err_ (error_table_$badopt, proc, "^a ^a
A default name cannot begin with a hyphen.  To change all sets of user-defined^[
^; ^]defaults, use:^[^/^]  eor -dnm ([prt ** -udf]) -sdft {-control_args}", arg, op, ll_err () < 132, ll_err () >= 132);
				else if index (op, "-") = 1
				then call com_err_ (error_table_$badopt, proc, "^a ^a^[
^;   ^]A default name cannot begin with a hyphen.", arg, op, ll_err () < 125);
				else call com_err_ (error_table_$nostars, proc, "^a ^a
To change several sets of user-defined defaults, use:^[
^]  eor -dnm ([prt ^a -udf]) -sdft {-control_args}", arg, op, ll_err () < 118, op);
				S.error = TRUE;
			     end;
			     go to END_OP;

PROC_OP (14):
			     O.forms_name = op;
			     go to END_OP;

END_OP:
			end;
		     end;
		end;
		if Snon_path_ctl_arg
		then S.non_path_ctl_args = TRUE;
	     end;
	end;

     end proc_args;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


proc_label:
     proc (Ipls, pls, pls_string, dir, ent, Scenter) returns (char (136) varying);

	Scenter = pls.S.center;


proc_heading:
     entry (Ipls, pls, pls_string, dir, ent) returns (char (136) varying);

dcl  Ipls fixed bin,
     1 pls aligned like PLS,
     pls_string char (*),
     dir char (*),
     ent char (*),
     Scenter bit (1);

dcl  equal char (32),				/* name returned by get_equal_name_ for heading.	*/
     result char (136) varying;


	if pls.S.active_string
	then do;
	     result = "";
	     call cu_$evaluate_active_string (null,
		"do " || requote_string_ ("[" || pls_string || "]") || " " || path (dir, ent), NORMAL_ACTIVE_STRING,
		result, code);
	     if code = error_table_$command_line_overflow
	     then ;
	     else if code ^= 0
	     then do;
		call cp_for_error_msg ("string [do " || requote_string_ ("[" || pls_string || "]") || " "
		     || path (dir, ent) || "]");
		go to EXIT;
	     end;
	end;
	else result = pls_string;

	if pls.S.equal_name
	then do;
	     call get_equal_name_ (ent, (result), equal, code);
	     if code ^= 0
	     then do;
		call com_err_ (code, proc, "
Applying equal convention to construct ^[heading^;destination^;top_label^;bottom_label^] field.
equal_name = ^a, entryname = ^a", Ipls, requote_string_ ((result)), requote_string_ (ent));
		go to EXIT;
	     end;
	     else result = equal;
	end;

	return (result);

cp_for_error_msg:
	proc (active_string);

dcl  active_string char (*);

dcl  cu_$cp entry (ptr, fixed bin (21), fixed bin (35)),
     ioa_$ioa_switch entry () options (variable);

	     call cu_$cp (addr (active_string), length (active_string), code);
	     call ioa_$ioa_switch (iox_$error_output,
		"^a: While constructing ^[heading^;destination^;top_label^;bottom_label^] field using the active string:",
		proc, Ipls);			/* Let command processor report the error code.	*/
	     call ioa_$ioa_switch (iox_$error_output, "^a", after (active_string, "string "));

	end cp_for_error_msg;


     end proc_label;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


proc_path:
     proc (path, Signore_stars, Nqueued);

dcl  path char (*),
     Signore_stars bit (1),
     Nqueued fixed bin;

dcl  ERROR_LABEL label variable,			/* variable error branch point label.		*/
     Ientry fixed bin,				/* do-group index for entries from hcs_$star_	*/
     Nmatches fixed bin,				/* number of entries matching a star name that	*/
						/* have been submitted for operation.		*/
     Ssuppress_errors bit (1),
     code fixed bin (35),
     dir char (168),				/* dir part of a path name.			*/
     ent char (32),					/* entry part of a path name.			*/
     name char (32);				/* a name temporary.			*/

	call expand_pathname_ (path, dir, ent, code);	/* expand it into an absolute path.		*/
	if code ^= 0
	then go to BAD_EXPAND;
	if Signore_stars
	then do;
	     ERROR_LABEL = BAD_PATH;
	     call submit (dir, ent, FALSE, ERROR_LABEL, Nqueued, 0, code);
	end;
	else do;
	     call check_star_name_$entry (ent, code);	/* see if name has *'s, or is a bad star name.	*/
	     if code = error_table_$badstar
	     then go to BAD_EXPAND;
	     else if code = 0
	     then do;				/* name contains no *'s.			*/
		ERROR_LABEL = BAD_PATH;		/* error exit to print a message, and skip operand */
		call submit (dir, ent, FALSE, ERROR_LABEL, Nqueued, 0, code);
						/* submit entry; never suppress errors.		*/
	     end;
	     else do;				/* name contains stars.			*/
		ERROR_LABEL = IGNORE_ENTRY;		/* error exit to print message, and ignore entry	*/
						/* whose name matches operand.		*/
		Nmatches = 0;			/* initialize count of matching branches which are */
						/* submitted successfully.			*/
		call hcs_$star_ (dir, ent, star_ALL_ENTRIES, addr (area), star_entry_count, star_entry_ptr,
		     star_names_ptr, code);
		if code ^= 0
		then				/* find branches which match starred operand.	*/
		     go to BAD_PATH;		/* Report any errors to user.			*/
		do Ientry = 1 to star_entry_count;	/* handle matching entries, one by one.		*/
		     name = star_names (star_entries (Ientry).nindex);
						/* copy name for efficiency.			*/
		     if star_entries (Ientry).type = Segment
		     then				/* report all errors occurring for segments.	*/
			Ssuppress_errors = FALSE;
		     else				/* suppress entry not found for link targets, and	*/
			Ssuppress_errors = TRUE;	/* attempt to print a directory errors.		*/
		     call submit (dir, name, Ssuppress_errors, ERROR_LABEL, Nqueued, Nmatches, code);
						/* submit the entry to the queue.		*/
		     go to NEXT_ENTRY;		/* handle the next entry.			*/

IGNORE_ENTRY:
		     call com_err_ (code, proc, "Entry will not be submitted
(^a^[>^]^a).", dir, dir ^= ">", name);

NEXT_ENTRY:
		end;

		free star_names in (area), star_entries in (area);
		if Nmatches = 0
		then do;				/* if no matching entries were queued, complain.	*/
		     code = error_table_$nomatch;
		     go to BAD_PATH;
		end;
	     end;
	end;
	return;


BAD_EXPAND:
	call com_err_ (code, proc, " ^a", path);
	return;

BAD_PATH:
	call com_err_ (code, proc, "^[^/^]Entry will not be submitted
(^a^[>^]^a).", ll_err () < 100, dir, dir ^= ">", ent);
	return;

     end proc_path;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


submit:
     procedure (dir, ent, Ssuppress_errors, ERROR_LABEL, Nqueued, Nmatches, code);
						/* An internal procedure to validate and submit	*/
						/* requests to operate on operand dir>ent.	*/

dcl  dir char (*),
     ent char (*),
     Ssuppress_errors bit (1),
     ERROR_LABEL label variable,
     Nqueued fixed bin,
     Nmatches fixed bin,
     code fixed bin (35);

dcl  COORD_ACCESS_NAME char (32) int static options (constant) init ("IO.SysDaemon.z"),
     Icomp fixed bin,				/* do-group index for MSF components.		*/
     Sdelete bit (1) aligned,				/* on if IO Daemon has access to delete entry.	*/
     Sread bit (1) aligned,				/* on if IO Daemon has access to read entry.	*/
     Sstatus bit (1) aligned,				/* on if IO Daemon has status access to entry.	*/
     Syes bit (1),					/* user's yes-or-no answer to my queries.	*/
     access_class bit (72) aligned,
     access_label char (136),
     adjusted_bit_count fixed bin (35),
     1 acl aligned,					/* acl structure passed to hcs_$add_acl_entries	*/
       2 name char (32) aligned,			/* access control process identifier to be added.	*/
       2 mode bit (36),				/* "rewa"b access mode.			*/
       2 pad bit (36),
       2 code fixed bin (35),				/* status code.				*/
     bit_count fixed bin (24),
     daemon_name char (24),				/* name of IO Daemon for our device class.	*/
     1 dir_acl aligned,				/* struc for hcs_$add_dir_acl_entries.		*/
       2 name char (32),
       2 mode bit (36),
       2 code fixed bin (35),
     explain_array (2) char (158) int static options (constant) init ("yes, y
   the request will be submitted, in spite of the problem reported above.
   The caller can take corrective action after the request is submitted,
   o", "r can do nothing in the hope that the IO Daemon will not encounter
   an error.
no, n
   do not submit the request.

Do you still wish to submit the request?"),
     explanation char (315) based (addr (explain_array)),
     lv_mode bit (36) aligned,
     lv_pub_bit bit (1) aligned,
     lv_name char (32),
     question char (41) int static options (constant) init ("
Do you still wish to submit the request?");

	call hcs_$status_long (dir, ent, 1, addr (branch), null, code);
						/* get status for entry. (chase links)		*/
	if (code ^= 0) & (code ^= error_table_$no_s_permission)
	then					/* check for errors besides no status permission.	*/
						/* for that error, we get all info we need.	*/
	     if code = error_table_$noentry
	     then					/* if branch linked to was not found, then	*/
		if Ssuppress_errors
		then				/* just ignore the entry if errors are suppressed. */
		     return;
		else go to ERROR_LABEL;
	     else					/* for all other errors, report the error, and	*/
		go to ERROR_LABEL;			/* ignore the entry.			*/

	if branch.type = Directory
	then do;
	     if branch.bit_count > 0
	     then					/* An MSF					*/
		branch.type = Msf;
	     else if Ssuppress_errors
	     then return;				/* A plain directory.  Can't dprint that.	*/
	     else do;
		code = error_table_$dirseg;
		go to ERROR_LABEL;
	     end;
	end;

	if branch.mode & bit (R_ACCESS_BIN, 5)
	then ;					/* make sure user has read access on entry.	*/
	else if S.force
	then do;
	     acl.name = get_group_id_$tag_star ();
	     acl.mode = R_ACCESS;
	     acl.pad = ""b;
	     if branch.type = Segment
	     then do;
		call hcs_$add_acl_entries (dir, ent, addr (acl), 1, code);
		if code ^= 0
		then do;
		     if acl.code ^= 0
		     then code = acl.code;
FORCE_READ_FAIL:
		     call com_err_ (code, proc, "Unable to force
read access for ^a to the entry.  Entry not submitted
(^a^[>^]^a).", acl.name, dir, dir ^= ">", ent);
		     return;
		end;
	     end;
	     else do;
		call msf_manager_$open (dir, ent, Pfcb, code);
		if code ^= 0
		then go to FORCE_READ_FAIL;
		call msf_manager_$acl_add (Pfcb, addr (acl), 1, code);
		call msf_manager_$close (Pfcb);
		Pfcb = null;
		if code ^= 0
		then do;
		     code = acl.code;
		     go to FORCE_READ_FAIL;
		end;
	     end;
	end;
	else do;
	     code = error_table_$moderr;
	     call command_query_$yes_no (Syes, code, proc, explanation, "^[
^]You do not have access to read the entry.
(^a^[>^]^a)." || question, ll_query () < 90, dir, dir ^= ">", ent);
	     if ^Syes
	     then return;
	end;

	if N.pt_pch ^= DP_PUNCH
	then do;					/* Don't print or plot an object segment.	*/
	     call object_lib_$initiate (dir, ent, "", "1"b, Pseg, (0), (""b), code);
	     if Pseg ^= null
	     then do;
		call hcs_$terminate_noname (Pseg, 0);
		Pseg = null;
		call com_err_ (error_table_$improper_data_format, proc, "Entry is an object segment
(^a^[>^]^a).
It will not be ^[print^;^;plott^]ed.", dir, dir ^= ">", ent, N.pt_pch);
		return;
	     end;
	end;

	call mdc_$find_lvname (branch.lvid, lv_name, code);
	if code ^= 0
	then go to ERROR_LABEL;
	call mdc_$get_lv_access (lv_name, 1, lv_mode, lv_pub_bit, code);
	if code ^= 0
	then go to ERROR_LABEL;
	if ^lv_pub_bit
	then do;					/* Make sure seg is on a public lv.		*/
	     call com_err_ (error_table_$private_volume, proc, "Entry cannot be ^[print^;punch^;plott^]ed
(^a^[>^]^a).", N.pt_pch, dir, dir ^= ">", ent);
	     return;
	end;

	if branch.type = Msf
	then do;					/* Compute bit count of MSF.			*/
	     dprint_arg.bit_count = 0;
	     call msf_manager_$open (dir, ent, Pfcb, code);
	     if code ^= 0
	     then do;
		call command_query_$yes_no (Syes, code, proc, explanation, "
(^a^[>^]^a)." || question, dir, dir ^= ">", ent);
		if ^Syes
		then return;
	     end;
	     else do;
		do Icomp = 0 to branch.bit_count - 1;
		     call msf_manager_$get_ptr (Pfcb, Icomp, FALSE, null, bit_count, code);
		     if code ^= 0
		     then do;
			call msf_manager_$close (Pfcb);
			code = error_table_$inconsistent_msf;
			go to ERROR_LABEL;
		     end;
		     dprint_arg.bit_count = dprint_arg.bit_count + bit_count;
		end;
		call msf_manager_$close (Pfcb);
	     end;
	end;
	else dprint_arg.bit_count = branch.bit_count;	/* Segment bit count comes from hcs_$status_long	*/

	if dprint_arg.bit_count = 0 & branch.type = Segment & S.force
	then do;
	     call adjust_bit_count_ ((dir), (ent), (TRUE), adjusted_bit_count, code);
	     if code = 0
	     then dprint_arg.bit_count, branch.bit_count = adjusted_bit_count;
	     else do;
		call com_err_ (code, proc, "Unable to adjust bit count^[
^; ^]on entry.  Entry not submitted
(^a^[>^]^a).", ll_err () < 100, dir, dir ^= ">", ent);
		return;
	     end;
	end;

	if dprint_arg.bit_count > 0
	then ;					/* ask user if he wants to print a segment with	*/

	else do;					/* a zero bit count.			*/
	     code = error_table_$zero_length_seg;
	     call command_query_$yes_no (Syes, code, proc, explanation, "Entry has a zero bit count
(^a^[>^]^a)." || question, dir, dir ^= ">", ent);
	     if ^Syes
	     then return;
	end;

	call dprint_$check_daemon_access (dir, ent, dprint_arg.request_type, Sdelete, Sread, Sstatus, daemon_name, code)
	     ;
	if code ^= 0
	then do;
	     call command_query_$yes_no (Syes, code, proc, explanation, "^[
^]Unable to determine access of IO Daemon (^a) to the entry
(^a^[>^]^a)." || question, ll_query () < 100, daemon_name, dir, dir ^= ">", ent);
	     if ^Syes
	     then return;
	     go to QUEUE_ENTRY;
	end;

	if ^Sread
	then do;					/* If IO Daemon has no read access:		*/
	     if S.force
	     then do;				/*    force access for IO Daemon.		*/
		acl.name = daemon_name;
		acl.mode = R_ACCESS;
		acl.pad = ""b;
		if branch.type = Segment
		then do;
		     call hcs_$add_acl_entries (dir, ent, addr (acl), 1, code);
		     if code ^= 0
		     then do;
			if acl.code ^= 0
			then code = acl.code;
FORCE_DAEMON_READ_FAIL:
			call com_err_ (code, proc, "Unable to^[
^; ^]force read access to entry for IO Daemon (^a).  Entry not submitted
(^a^[>^]^a).", ll_err () < 132, daemon_name, dir, dir ^= ">", ent);
			return;
		     end;
		end;
		else do;
		     call msf_manager_$open (dir, ent, Pfcb, code);
		     if code ^= 0
		     then go to FORCE_DAEMON_READ_FAIL;
		     call msf_manager_$acl_add (Pfcb, addr (acl), 1, code);
		     call msf_manager_$close (Pfcb);
		     Pfcb = null;
		     if code ^= 0
		     then do;
			code = acl.code;
			go to FORCE_DAEMON_READ_FAIL;
		     end;
		end;
	     end;
	     else do;
		code = error_table_$moderr;
		call command_query_$yes_no (Syes, code, proc, explanation, "^[
^]IO Daemon (^a) do not have access to read the entry.
(^a^[>^]^a)." || question, ll_query () < 100, daemon_name, dir, dir ^= ">", ent);
		if ^Syes
		then return;
	     end;
	end;

	if ^Sstatus
	then do;
	     if S.force
	     then do;				/*    force access for IO Daemon.		*/
		dir_acl.name = daemon_name;
		dir_acl.mode = S_ACCESS;
		call hcs_$add_dir_acl_entries (dir, "", addr (dir_acl), 1, code);
		if code ^= 0
		then do;
		     if dir_acl.code ^= 0
		     then code = dir_acl.code;
		     call com_err_ (code, proc, "Unable to^[
^; ^]force status access for IO Daemon (^a)
to directory containing entry.  Entry not submitted
(^a^[>^]^a).", ll_err () < 132, daemon_name, dir, dir ^= ">", ent);
		     return;
		end;
	     end;
	     else do;
		code = error_table_$moderr;
		call command_query_$yes_no (Syes, code, proc, explanation, "^[
^]IO Daemon (^a) does not have status access
to directory containing entry
(^a^[>^]^a)." || question, ll_query () < 100, daemon_name, dir, dir ^= ">", ent);
		if ^Syes
		then return;
	     end;
	end;

	if ^Sdelete & N.delete = 1
	then do;
	     call ioa_ ("Warning:  IO Coordinator process (normally ^a)
does not have sufficient access to delete entry
(^a^[>^]^a).
The entry will be submitted anyway.", COORD_ACCESS_NAME, dir, dir ^= ">", ent);
	end;

QUEUE_ENTRY:
	dprint_arg.heading = " for " || proc_heading (HEADING, PLS_struc.heading, PLS_heading, dir, ent);
	if dprint_arg.heading = " for "
	then dprint_arg.heading = "";			/* If the heading was null don't add the " for " */
	dprint_arg.destination = proc_heading (DESTINATION, PLS_struc.destination, PLS_destination, dir, ent);

	if S.label.access
	then do;
	     call hcs_$get_access_class (dir, ent, access_class, code);
	     if code ^= 0
	     then go to ERROR_LABEL;
	     call convert_authorization_$to_string (access_class, access_label, code);
	     if ^S.label.top
	     then do;
		dprint_arg.top_label = access_label;
		dprint_arg.center_top_label = TRUE;
	     end;
	     if ^S.label.bottom
	     then do;
		dprint_arg.bottom_label = access_label;
		dprint_arg.center_bottom_label = TRUE;
	     end;
	end;

	if S.label.top
	then dprint_arg.top_label =
		proc_label (TOP_LABEL, PLS_struc.top_label, PLS_top_label, dir, ent, dprint_arg.center_top_label);
	else if ^S.label.access
	then dprint_arg.top_label = "";

	if S.label.bottom
	then dprint_arg.bottom_label =
		proc_label (BOTTOM_LABEL, PLS_struc.bottom_label, PLS_bottom_label, dir, ent,
		dprint_arg.center_bottom_label);
	else if ^S.label.access
	then dprint_arg.bottom_label = "";

REQUEUE:
	call dprint_ (dir, ent, addr (dprint_arg), code); /* add request for operation to the queue.	*/
	if code ^= 0
	then if code = error_table_$notalloc
	     then go to QUEUE_FULL;
	     else if code = error_table_$noentry
	     then go to QUEUE_MISSING;
	     else if code = error_table_$bad_segment
	     then go to QUEUE_BAD;
	     else if code = error_table_$lock_wait_time_exceeded
	     then do;
		call command_query_$yes_no (Syes, code, proc, "yes, y
   reattempt to submit the request.  The same error may occur again.
no, n
   skip this request and those which follow.", "(^a^[>^]^a)
Do you want to try submitting the request again?", dir, dir ^= ">", ent);
		if Syes
		then go to REQUEUE;
		go to EXIT;
	     end;
	     else go to QUEUE_ERROR;
	Nqueued = Nqueued + 1;
	Nmatches = Nmatches + 1;
	return;

QUEUE_BAD:
QUEUE_ERROR:
QUEUE_MISSING:
	call com_err_ (code, proc, "Queue ^d of the ^a request type.
Entry ^a^[>^]^a
and requests following it have not been submitted.", dprint_arg.queue, dprint_arg.request_type, dir, dir ^= ">", ent);
	go to EXIT;

QUEUE_FULL:
	call com_err_ (error_table_$notalloc, proc, "Queue ^d of the ^a request type is full.
Entry ^a^[>^]^a
and requests following it have not been submitted.", dprint_arg.queue, dprint_arg.request_type, dir, dir ^= ">", ent);
	go to EXIT;

     end submit;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


DEFAULT_QUEUE_UNDEFINED:
	call com_err_ (code, proc, "
Getting default queue number for ^a request type.", O.request_type);
	go to FINISH;

DEFAULT_RQT_NOT_DEFINED:
	call com_err_ (error_table_$typename_not_found, proc, "-set_default_request_type ^a 
^a does not have system defined eor defaults.  Use -set_defaults to set it.", O.default_request_type,
	     O.default_request_type);
	go to FINISH;

DELETE_FAILURE:
	call com_err_ (code, proc, "^[
^]Attempting to delete an eor default in the value segment
(^a)", ll_err () < 118, value_seg_path);
	go to FINISH;

ERROR_VALIDATING_FORM:
	if code = error_table_$bad_forms_option
	then if validate_forms_info_output.error_length ^= 0
	     then call com_err_ (code, proc, "^a", validate_forms_info_output.error_string);
	     else go to display_general_forms_error;
	else do;
display_general_forms_error:
	     call com_err_ (code, proc, "Validating forms string ""^a"" for ^a request type.", O.forms_name,
		O.request_type);
	end;
	go to FINISH;

INCONSISTENT_DNM_RQT_ARGS:
	call com_err_ (error_table_$inconsistent, proc, "-request_type ^a -default_name ^a.
The ^a group of defaults uses the ^a request type.", O.request_type, O.name_of_default, O.name_of_default,
	     default_print.request_type);
	go to FINISH;

INCONSISTENT_PRINT_PUNCH_PLOT:
	if O.request_type ^= ""
	then do;
	     call iod_info_$generic_type (O.request_type, gen_type, code);
	     if gen_type = "printer"
	     then Ntype = DP_PRINT;
	     else if gen_type = "punch"
	     then Ntype = DP_PUNCH;
	     else Ntype = DP_PLOT;
	     if Ntype = DP_PRINT
	     then call com_err_ (error_table_$inconsistent, proc, "
Request type ^a is a ^a generic type.
The following arguments are inconsistent with printing:^[^; -7punch^; -mcc^; -raw^]^[^; -punch^; -plot^]",
		     O.request_type, gen_type, N.output_module, N.pt_pch);
	     else call com_err_ (error_table_$inconsistent, proc, "
Request type ^a is a ^a generic type.
The following are inconsistent with ^[^;punch^;plott^]ing:^[
  -access_label^]^[
  -forms^]^[
  -indent^]^[
  -label, -top_label, or -bottom_label^]^[
  -line_length^]^[
  -no_end_page^]^[" || "
  -no_vertical_space^]^[
  -non_edited^]^[
  -page_length^]^[
  ^[-print^;-punch^;-plot^]^;^s^]^[
  -truncate^]^[
  ^[^;-7punch^;-mcc^;-raw^]^;^s^]", O.request_type, gen_type, Ntype, S.label.access, O.forms_name ^= "", N.lmargin > 0,
		     S.label.top | S.label.bottom, N.line_lth > 0, S.nep, S.single, S.non_edited, N.page_lth > 0,
		     (N.pt_pch ^= UNDEFINED & N.pt_pch ^= Ntype), N.pt_pch, S.truncate,
		     (Ntype = DP_PLOT & PUNCH <= N.output_module & N.output_module <= RAW), N.output_module);
	end;
	else call com_err_ (error_table_$inconsistent, proc, "^[
Punching arguments:^[^; -7punch^; -mcc^; -raw^]^[ -punch^]^;^2s^]^[
Plotting arguments: -plot^]
Printing arguments:^[
  -access_label^]^[
  -forms^]^[
  -indent^]^[
  -label, -top_label, or -bottom_label^]^[
  -line_length^]^[
  -no_end_page^]^[" || "
  -no_vertical_space^]^[
  -non_edited^]^[
  -page_length^]^[
  -print^]^[
  -truncate^]", ((PUNCH <= N.output_module & N.output_module <= RAW) | N.pt_pch = DP_PUNCH), N.output_module,
		N.pt_pch = DP_PUNCH, N.pt_pch = DP_PLOT, S.label.access, O.forms_name ^= "", N.lmargin > 0,
		S.label.top | S.label.bottom, N.line_lth > 0, S.nep, S.single, S.non_edited, N.page_lth > 0,
		N.pt_pch = DP_PRINT, S.truncate);
	go to FINISH;

INDENT_INCONSISTENT_WITH_LINE_LENGTH:
	call com_err_ (error_table_$inconsistent, proc, "-indent ^d -line_length ^d.", N.lmargin, N.line_lth);
	go to FINISH;

MAX_INDENT_EXCEEDED:
	call com_err_ (error_table_$out_of_bounds, proc, "-indent ^d
The line length must be <= ^d.", N.lmargin, MAX_LINE_LENGTH);
	go to FINISH;

MAX_LINE_LENGTH_EXCEEDED:
	call com_err_ (error_table_$out_of_bounds, proc, "-line_length ^d
The line length must be <= ^d.", N.line_lth, MAX_LINE_LENGTH);
	go to FINISH;

MAX_QUEUE_EXCEEDED:
	call com_err_ (error_table_$out_of_bounds, proc, "-queue ^d
The ^a request type has only ^d queue^[s^].", N.queue, O.request_type, max_q, max_q > 1);
	go to FINISH;

MAX_QUEUE_UNDEFINED:
	call com_err_ (code, proc, "^[
^]Getting highest queue number for ^a request type.", ll_err () < 120, O.request_type);
	go to FINISH;

NOT_AF:
	call com_err_ (code, proc);
	go to FINISH;

STORE_FAILURE:
	call com_err_ (code, proc, "^[
^]Attempting to store an eor default in the value segment
(^a).", ll_err () < 118, value_seg_path);
	go to FINISH;

UNDEFINED_GENERIC_TYPE:
	call com_err_ (error_table_$typename_not_found, proc, "Request type ^a is of
^a generic type.  ^a cannot handle this generic type.", O.request_type, gen_type, proc);
	go to FINISH;

UNDEFINED_REQUEST_TYPE:
	call com_err_ (code, proc, "^[
^]The ^a request type is not defined.", ll_err () < 118, O.request_type);
	go to FINISH;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

%include access_mode_values;

%include cp_active_string_types;

%include dprint_arg;

%include star_structures;

%include status_structures;

dcl  Msf fixed bin int static options (constant) init (3),
     1 branch aligned like status_branch;

%include value_structures;

dcl  1 mi aligned,					/* automatic copy of match_info		*/
       2 version fixed bin init (1),
       2 name_count fixed bin init (1),
       2 max_name_length fixed bin init (30),
       2 name_array (1),
         3 exclude_sw bit (1) unal init ("0"b),
         3 regexp_sw bit (1) unal init ("0"b),
         3 pad bit (34) unal init ("0"b),
         3 name char (30) varying;
%include user_forms_info;
     end enter_output_request;
