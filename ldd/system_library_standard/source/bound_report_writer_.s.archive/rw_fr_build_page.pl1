/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   *********************************************************** */
/* format: off */
%skip(1);
/*

     This module is the report_writer_ page building subroutine called by
     rw_display. Description and usage follows.

     Description:

     This module is called to build a single page and return to its caller.
     In the case of unpaginated reports it builds a buffer (a portion of the
     single page an unpaginated report is made up of). In the case of multiple
     pass reports this module formats the report the number of passes minus
     one, then formats the first page or buffer of the last pass and returns
     to its caller.

     Usage:

     See the parameter list for usage.

     Known Bugs:
 
     Other Problems:

     History:

     Written - Al Dupuis - August 1983

     Modified: Al Dupuis - October 26, 1983. Added lines in internal procedure
     check_for_outlining to make sure that the column being outlined isn't
     excluded from the page.

     Changed - Al Dupuis - October 1984 - Became report_writer_.
*/
%page;
/*

	   Formatted Page		Mainline Processing Overview

     ________________________________
     |         PAGE HEADER          |	1. Format the page header.
     |______________________________|
     |         TITLE BLOCK          |	2. Format the title block.
     |______________________________|
     |        DETAIL BLOCK          |	3. Format N detail blocks (see below).
     |______________________________|
     |         PAGE FOOTER          |	4. Format the page footer.
     |______________________________|



	   Detail Block		Detail Block Processing Overview

     --------------------------------
     |      GROUP HEADER	      |   1. Format the group header.
     |______________________________|
     |        ROW HEADER            |	2. Format the row header.
     |______________________________|
     |        ROW VALUE             |	3. Format the row value.
     |______________________________|
     |      SUBTOTAL BLOCK          |	4. Format the subtotal block.
     |______________________________|
     |      SUBCOUNT BLOCK          |   5. Format the subcount block.
     |______________________________|
     |       TOTAL BLOCK            |	6. Format the total block.
     |______________________________|
     |       COUNT BLOCK	      |   7. Format the count block.
     |______________________________|
     |        ROW FOOTER            |	8. Format the row footer.
     |______________________________|
     |      GROUP FOOTER            |   9. Format the group footer.
     |______________________________|


     The above mainline is done once per page for every page of the report.
     A return is done to the caller after every page is built. If the
     multi-pass feature is being used, no output is produced until the last
     pass. This means that the entire report is done "n" times without
     returning to the caller, where "n" is one less than the requested
     number of passes. On the final pass it returns to the caller after each
     page is built.

*/
%page;
rw_fr_build_page: proc (

	report_cip_parm,	/* input: points to report_control_info */
	page_info_ptr_parm,	/* output: description of the page */
	code_parm		/* output: success or failure */
		      );
%skip(1);
dcl code_parm fixed bin (35) parm;
dcl page_info_ptr_parm ptr parm;
dcl report_cip_parm ptr parm;
%skip(3);
	report_cip = report_cip_parm;
	call housekeeping;
	call setup_for_a_page;
	call make_rows_available;
	on sub_error_ call sub_error_handler;
%skip(1);
	if ^report_control_info.flags.multi_pass_mode
	then do;
	     call build_page;
	     return;
	end;
%skip(1);
	status.flags.last_pass = OFF;
	do status.current_pass_number = 1 to report_control_info.number_of_passes - 1;
	     do while (^report_control_info.flags.report_has_just_been_completed);
		call build_page;
		if ^report_control_info.flags.report_has_just_been_completed
		then call setup_for_a_page;
	     end;
	     call adjust_multi_pass_execution_control_info;
	     call setup_for_a_page;
	end;
%skip(1);
	report_control_info.flags.multi_pass_mode = OFF;
	status.flags.last_pass = ON;
	call build_page;
%skip(1);
	return;
%page;
adjust_multi_pass_execution_control_info: proc;
%skip(3);
     /* Just completed one pass of the report, set up for the next pass.  */
%skip(1);
	status.current_row_ptr = null ();
	status.previous_row_ptr = null ();
	status.next_row_ptr = make_ptr (1);
%skip(1);
	status.last_page_number = status.current_page_number;
	status.last_row_number = report_control_info.no_of_rows_retrieved;
	status.highest_row_formatted = 0;
%skip(1);
	if format_report_info.flags.subtotal_is_defined
	then do;
	     subtotal_info.columns.subtotal (*) = 0;
	     subtotal_generation_info.current_generation_block = -1;
	end;
	if format_report_info.flags.total_is_defined
	then total_info.columns.total (*) = 0;
%skip(1);
	if format_report_info.flags.subcount_is_defined
	then do;
	     subcount_info.columns.subtotal (*) = 0;
	     subcount_generation_info.current_generation_block = -1;
	end;
	if format_report_info.flags.count_is_defined
	then count_info.columns.total (*) = 0;
%skip(1);
	report_control_info.flags.report_is_formatted = OFF;
	report_control_info.flags.report_has_just_been_completed = OFF;
	report_control_info.no_of_formatted_pages = 0;
%skip(1);
	format_report_info.number_of_formatted_rows = 0;
%skip(1);
	return;
%skip(1);
     end adjust_multi_pass_execution_control_info;
%page;
backout_detail_block: proc (

	bdb_object_doing_the_back_out_parm /* input: the caller */
		       );
%skip(1);
dcl bdb_object_doing_the_back_out_parm char (*) varying parm;
%skip(1);
     /* Remove one detail block from the page, make sure it isn't the first. */
%skip(1);
	if status.total_number_of_rows_used ^> 0
	then call ssu_$abort_line (sci_ptr, rw_error_$bad_report_format,
	     "^/There isn't enough room to place the ^a on page number ^d."
	     || "^/The current row number is ^d.",
	     bdb_object_doing_the_back_out_parm,
	     status.current_page_number, status.current_row_number);
%skip(1);
	status.flags.page_overflow = ON;
	status.flags.last_row_of_report = OFF;
	status.current_line_on_page = formatted_page_info.detail_blocks
	     (formatted_page_info.number_of_detail_blocks).beginning_line_number;
	status.remaining_lines_on_page = template_map_number_of_bits - status.current_line_on_page + 1;
	status.flags.still_formatting_detail_blocks = OFF;
	if page_info.page_overstrike_info_ptr ^= null ()
	then substr (page_overstrike_info_redefined.bit_map, ((status.current_line_on_page - 1) * page_info.width) + 1) = OFF;
%skip(1);
	status.next_row_ptr = status.current_row_ptr;
	status.current_row_ptr = status.previous_row_ptr;
	if status.current_row_number < 3
	then status.previous_row_ptr = null ();
	else status.previous_row_ptr = make_ptr (status.current_row_number - 2);
%skip(1);
	if format_report_info.flags.subtotal_is_defined
	then call backout_subtotal_block;
	status.flags.totals_ejection_in_progress = OFF;
	status.flags.subtotals_ejection_in_progress = OFF;
%skip(1);
	if format_report_info.flags.subcount_is_defined
	then call backout_subcount_block;
	status.flags.counts_ejection_in_progress = OFF;
	status.flags.subcounts_ejection_in_progress = OFF;
%skip(1);
	substr (template_map_defined_as_a_string, status.current_line_on_page) = OFF;
	formatted_page_info.number_of_detail_blocks = formatted_page_info.number_of_detail_blocks - 1;
%skip(1);
	return;
%skip(1);
     end backout_detail_block;
%page;
backout_subcount_block: proc;
%skip(1);
dcl bsb_loop fixed bin;
%skip(1);
     /* Back out the subtotal block if we've generated it or are in the process of generating it.  */
%skip(1);
	if formatted_page_info.detail_blocks (formatted_page_info.number_of_detail_blocks).subcount_length ^= 0
	| status.flags.subcounts_ejection_in_progress
	then do;
	     subcount_generation_info.current_generation_block
		= mod (subcount_generation_info.current_generation_block,
		subcount_generation_info.maximum_number_of_generation_blocks);
	     do bsb_loop = 1 to subcount_generation_info.number_of_subtotals;
		subcount_info.columns (bsb_loop).subtotal
		     = subcount_generation_info.generations
		     (subcount_generation_info.current_generation_block).subtotals (bsb_loop);
	     end;
	end;
%skip(1);
	do bsb_loop = 1 to subcount_info.number_of_columns_to_subtotal;
	     subcount_info.columns (bsb_loop).subtotal
		= subcount_info.columns (bsb_loop).subtotal - 1;
	end;
%skip(1);
	return;
%skip(1);
     end backout_subcount_block;
%page;
backout_subtotal_block: proc;
%skip(1);
dcl bsb_loop fixed bin;
%skip(1);
     /* Back out the subcount block if we've generated it or are in the process of generating it.  */
%skip(1);
	if formatted_page_info.detail_blocks (formatted_page_info.number_of_detail_blocks).subtotal_length ^= 0
	| status.flags.subtotals_ejection_in_progress
	then do;
	     subtotal_generation_info.current_generation_block
		= mod (subtotal_generation_info.current_generation_block,
		subtotal_generation_info.maximum_number_of_generation_blocks);
	     do bsb_loop = 1 to subtotal_generation_info.number_of_subtotals;
		subtotal_info.columns (bsb_loop).subtotal
		     = subtotal_generation_info.generations
		     (subtotal_generation_info.current_generation_block).subtotals (bsb_loop);
	     end;
	end;
%skip(1);
	do bsb_loop = 1 to subtotal_info.number_of_columns_to_subtotal;
	     subtotal_info.columns (bsb_loop).subtotal
		= subtotal_info.columns (bsb_loop).subtotal
		- float (substr (next_row_value,
		table_info.columns.column_index (subtotal_info.columns (bsb_loop).input_column),
		table_info.columns.column_length (subtotal_info.columns (bsb_loop).input_column)));
	end;
%skip(1);
	return;
%skip(1);
     end backout_subtotal_block;
%page;
build_page: proc;
%skip(1);
/*
     Make the pointers to the rows. Do the page header, the title block,
     as many detail blocks as will fit, and the page footer. Use
     the alogorithm as described back in the picture at the beginning of this
     module. Close the page. Optionally save a copy of it.
*/
%skip(1);
	call make_row_ptrs;
	if format_report_info.flags.page_header_is_defined
	then call format_page_header;
	if format_report_info.flags.title_block_is_defined
	then call format_title_block;
	first_time_through_the_detail_block_loop = ON;
	status.still_formatting_detail_blocks = ON;
%skip(1);
	do while (status.still_formatting_detail_blocks);
	     if ^first_time_through_the_detail_block_loop
	     then call make_row_ptrs;
	     call format_detail_block;
	     first_time_through_the_detail_block_loop = OFF;
	     call make_rows_available;
	end;
%skip(1);
	if format_report_info.flags.page_footer_is_defined
	then call format_page_footer;
	call close_page;
	if report_control_info.flags.permanent_report & ^report_control_info.flags.multi_pass_mode
	then call save_copy_of_page;
%skip(1);
	page_info_ptr_parm = page_ip;
	code_parm = code;
%skip(1);
	return;
%skip(1);
     end build_page;
%page;
check_for_group_break: proc (

	cfgb_group_info_ptr_parm,	  /* input: ptr to group_info structure */
	cfgb_look_ahead_flag_parm,	  /* input: on if current should be compared to next */
	cfgb_column_changed_flag_parm	  /* output: on if a column changed */
			      );
%skip(1);
dcl cfgb_column_changed_flag_parm bit (1) aligned parm;
dcl cfgb_column_number fixed bin;
dcl 1 cfgb_group_info like group_info based (cfgb_group_info_ptr_parm);
dcl cfgb_group_info_ptr_parm ptr parm;
dcl cfgb_look_ahead_flag_parm bit (1) aligned parm;
dcl cfgb_loop fixed bin;
%skip(1);
     /* Check the value of the named columns against the previous or next row and set the parm accordingly. */
%skip(1);
	cfgb_column_changed_flag_parm = ON;
	if (status.flags.last_row_of_report & cfgb_look_ahead_flag_parm)
	| (status.flags.first_row_of_report & ^cfgb_look_ahead_flag_parm)
	then return;
%skip(1);
	do cfgb_loop = 1 to cfgb_group_info.number_of_columns_to_group;
	     cfgb_column_number = cfgb_group_info.column_number (cfgb_loop);
	     if cfgb_look_ahead_flag_parm
	     then if substr (current_row_value,
		table_info.columns.column_index (cfgb_column_number),
		table_info.columns.column_length (cfgb_column_number))
		^=  substr (next_row_value,
		table_info.columns.column_index (cfgb_column_number),
		table_info.columns.column_length (cfgb_column_number))
		then return;
	          else;
	     else if substr (current_row_value,
		table_info.columns.column_index (cfgb_column_number),
		table_info.columns.column_length (cfgb_column_number))
		^=  substr (previous_row_value,
		table_info.columns.column_index (cfgb_column_number),
		table_info.columns.column_length (cfgb_column_number))
		then return;
	          else;
	end;
%skip(1);
	cfgb_column_changed_flag_parm = OFF;
%skip(1);
	return;
%skip(1);
     end check_for_group_break;
%page;
check_for_outlining: proc;
%skip(1);
dcl cfo_inner_loop fixed bin;
dcl cfo_loop fixed bin;
dcl cfo_most_major_column_changed bit (1) aligned;
dcl cfo_still_within_the_group bit (1) aligned;
%skip(3);
/*
     Never do outlining on the first row of the report or the first row on a
     page. Do the single columns first (columns who are not a member of the
     "group" of rows). Grab the column number and use it as an index into the
     input_columns_info array, which gives us the number of the output column.
*/
%skip(1);
	if status.flags.first_row_of_report | status.flags.first_row_on_page
	then do;
	     output_columns_info.columns (*).flags.outline = OFF;
	     return;
	end;
%skip(1);
	if outline_info.number_of_single_columns ^= 0
	then do cfo_loop = 1 to outline_info.number_of_single_columns;
	     if input_columns_info.columns.output_column (outline_info.single_columns (cfo_loop)) ^= 0
	     then do;
		column_ip = addr (output_columns_info.columns (input_columns_info.columns.output_column (
		     outline_info.single_columns (cfo_loop))));
		if substr (current_row_value,
		table_info.columns.column_index (outline_info.single_columns (cfo_loop)),
		table_info.columns.column_length (outline_info.single_columns (cfo_loop)))
		= substr (previous_row_value,
		table_info.columns.column_index (outline_info.single_columns (cfo_loop)),
		table_info.columns.column_length (outline_info.single_columns (cfo_loop)))
		then column_info.flags.outline = ON;
		else column_info.flags.outline = OFF;
	     end;
	end;
%page;
/*
     Do the grouping columns next. A change in any member of the group who is
     more major than our target column causes a change in all columns down to
     our target column. Repeat the following sequence for each of our target
     columns. Use the group column number as an index into the
     input_columns_info array, which gives us the number of the output column.
     If it has changed, or a more major member has changed, then it isn't
     outlined.
*/
%skip(1);
	if outline_info.number_of_grouping_columns ^= 0
	then do cfo_loop = 1 to outline_info.number_of_grouping_columns;
%skip(1);
	     cfo_most_major_column_changed = OFF;
	     cfo_still_within_the_group = ON;
%skip(1);
	     do cfo_inner_loop = 1 to group_info.number_of_columns_to_group
		while (cfo_still_within_the_group);
%skip(1);
		if input_columns_info.columns.output_column (group_info.column_number (cfo_inner_loop)) ^= 0
		then do;
		     column_ip = addr (output_columns_info.columns (input_columns_info.columns.output_column (
			group_info.column_number (cfo_inner_loop))));
		     if cfo_most_major_column_changed
		     then column_info.flags.outline = OFF;
		     else do;
			if substr (current_row_value,
			table_info.columns.column_index (group_info.column_number (cfo_inner_loop)),
			table_info.columns.column_length (group_info.column_number (cfo_inner_loop)))
			= substr (previous_row_value,
			table_info.columns.column_index (group_info.column_number (cfo_inner_loop)),
			table_info.columns.column_length (group_info.column_number (cfo_inner_loop)))
			then column_info.flags.outline = ON;
			else do;
			     cfo_most_major_column_changed = ON;
			     column_info.flags.outline = OFF;
			end;
		     end;
		end;
%skip(1);
		if group_info.column_number (cfo_inner_loop) = outline_info.grouping_columns (cfo_loop)
		then cfo_still_within_the_group = OFF;
%skip(1);
	     end;
%skip(1);
	end;
%skip(1);
	return;
%skip(1);
     end check_for_outlining;
%page;
check_for_page_break: proc;
%skip(1);
dcl cfpb_loop fixed bin;
%skip(3);
/*
     If we're on the last row then don't check for a page break. If the value
     of any column being watched is about to change with the next row then
     generate a page break.
*/
%skip(1);
	if ^status.flags.still_formatting_detail_blocks
	then return;
%skip(1);
	status.still_formatting_detail_blocks = OFF;
%skip(1);
	do cfpb_loop = 1 to input_columns_info.number_of_columns;
	     if page_break_info.columns (cfpb_loop)
	     then do;
		if substr (current_row_value,
		table_info.columns.column_index (cfpb_loop),
		table_info.columns.column_length (cfpb_loop))
		^= substr (next_row_value,
		table_info.columns.column_index (cfpb_loop),
		table_info.columns.column_length (cfpb_loop))
		then return;
	     end;
	end;
%skip(1);
	status.still_formatting_detail_blocks = ON;
%skip(1);
	return;
%skip(1);
     end check_for_page_break;
%page;
check_for_subtotal_break: proc (

	cfsb_subtotal_info_ptr_parm,	       /* input: ptr to subtotal_info structure */
	cfsb_subtotal_columns_info_ptr_parm, /* input: ptr to subtotal_columns_info structure */
	cfsb_level_number_parm,	       /* input: which level of subtotals we're on */
	cfsb_column_changed_flag_parm	       /* output: on means it's time for a subtotal break */
			 );
%skip(1);
dcl cfsb_column_changed_flag_parm bit (1) aligned parm;
dcl cfsb_column_number fixed bin;
dcl cfsb_inner_loop fixed bin;
dcl cfsb_level_number fixed bin;
dcl cfsb_level_number_parm fixed bin parm;
dcl cfsb_loop fixed bin;
dcl cfsb_most_major_column_changed bit (1) aligned;
dcl cfsb_still_within_the_group bit (1) aligned;
dcl 1 cfsb_subtotal_columns_info like subtotal_columns_info based (cfsb_subtotal_columns_info_ptr_parm);
dcl cfsb_subtotal_columns_info_ptr_parm ptr parm;
dcl 1 cfsb_subtotal_info like subtotal_info based (cfsb_subtotal_info_ptr_parm);
dcl cfsb_subtotal_info_ptr_parm ptr parm;
%skip(3);
/*
     This subroutine walks through one level of subtotals looking at the watch
     column to see if it has changed. A change means it is time to generate
     the subtotal. If the watch column is a member of the "group" list of
     columns, then it and any more major in the group are also watched. A 
     change in any member of the group causes all members lower to change also
     (down to the watch column).

     Start off by outlining every column. Walk through all of the subtotal
     columns processing only those that are at the current level. Grab the
     number of the watch column. Use the subtotal_info array to index into
     the input_columns_info array, which gives us the number of the
     subtotal_columns_info output column. If it is the last row of the report,
     or the watch column has changed, or the watch column is a group member
     and a more major column has changed, then generate a subtotal break. The
     column that changed can be excluded from the page; if it isn't then set
     the outline bit off for it (and possibly more minor columns). Set the
     outline bit off for the subtotal output column if we got a hit, and if
     the parent column has an editing request associated with it then set
     the pointer and length to the result of the editing request.
*/
%skip(1);
	cfsb_column_changed_flag_parm = OFF;
	cfsb_level_number = cfsb_level_number_parm;
	cfsb_subtotal_columns_info.columns (*).flags.outline = ON;
%page;
	do cfsb_loop = 1 to cfsb_subtotal_info.number_of_columns_to_subtotal;
	     if cfsb_subtotal_info.columns (cfsb_loop).level = cfsb_level_number
	     then do;
		cfsb_column_number = cfsb_subtotal_info.columns (cfsb_loop).watch_column;
		column_ip = addr (cfsb_subtotal_columns_info.columns (input_columns_info.columns (
		     cfsb_subtotal_info.columns (cfsb_loop).input_column).output_column));
		if ^cfsb_subtotal_info.columns (cfsb_loop).flags.group_column
		then do;
		     if status.flags.last_row_of_report
		     then call subtotal_break (input_columns_info.columns (cfsb_column_number).output_column);
		     else if substr (current_row_value,
			table_info.columns.column_index (cfsb_column_number),
			table_info.columns.column_length (cfsb_column_number))
			^= substr (next_row_value,
			table_info.columns.column_index (cfsb_column_number),
			table_info.columns.column_length (cfsb_column_number))
			then call subtotal_break (input_columns_info.columns (cfsb_column_number).output_column);
		          else;
		end;
		else do;
		     if status.flags.last_row_of_report
		     then cfsb_most_major_column_changed = ON;
		     else cfsb_most_major_column_changed = OFF;
		     cfsb_still_within_the_group = ON;
		     do cfsb_inner_loop = 1 to group_info.number_of_columns_to_group
			while (cfsb_still_within_the_group);
			if cfsb_most_major_column_changed
			then call subtotal_break (input_columns_info.columns (
			     group_info.column_number (cfsb_inner_loop)).output_column);
			else if substr (current_row_value,
			     table_info.columns.column_index (group_info.column_number (cfsb_inner_loop)),
			     table_info.columns.column_length (group_info.column_number (cfsb_inner_loop)))
			     ^= substr (next_row_value,
			     table_info.columns.column_index (group_info.column_number (cfsb_inner_loop)),
			     table_info.columns.column_length (group_info.column_number (cfsb_inner_loop)))
			     then call subtotal_break (input_columns_info.columns
			          (group_info.column_number (cfsb_inner_loop)).output_column);
			     else;
			if group_info.column_number (cfsb_inner_loop) = cfsb_column_number
			then cfsb_still_within_the_group = OFF;
		     end;
		end;
	     end;
	end;
%skip(1);
	return;
%page;
subtotal_break: proc (

	sb_output_column_number_parm	/* input: number of column that changed */
		 );
%skip(1);
dcl sb_output_column_number_parm fixed bin parm;
%skip(3);
/*
     This subroutine is called when a watch column has changed and it is time 
     to generate a subtotal break. Set the parm to indicate a column has 
     changed. Set the subtotal/subcount output column's editing flag off. If
     the column that changed isn't being excluded from the page, then set it's
     editing bit off and if it has an editing request associated with it, set
     the pointer and length so that the edited result is displayed in that
     column.
*/
%skip(1);
	cfsb_column_changed_flag_parm = ON;
	column_info.flags.outline = OFF;
	if sb_output_column_number_parm = 0
	then return;
%skip(1);
	cfsb_subtotal_columns_info.columns (sb_output_column_number_parm).flags.outline = OFF;
	if cfsb_subtotal_columns_info.columns (sb_output_column_number_parm).flags.editing
	then do;
	     cfsb_subtotal_columns_info.columns (sb_output_column_number_parm).editing_string_result_ptr
		= output_columns_info.columns (sb_output_column_number_parm).editing_string_result_ptr;
	     cfsb_subtotal_columns_info.columns (sb_output_column_number_parm).editing_string_result_length
		= output_columns_info.columns (sb_output_column_number_parm).editing_string_result_length;
	end;
%skip(1);
	return;
%skip(1);
     end subtotal_break;
%skip(1);
     end check_for_subtotal_break;
%page;
close_page: proc;
%skip(3);
/*
     This subroutine closes a page. Increment the number of rows and pages 
     we've already formatted. Check for end of report and set flags 
     accordingly. If the whole page wasn't used then set page_info to reflect
     the space used. Check for a zero length page, and set the last character
     to a form feed if it's a paginated report or the last buffer of an
     unpaginated report.
*/
%skip(1);
	format_report_info.number_of_formatted_rows
	     = format_report_info.number_of_formatted_rows + status.total_number_of_rows_used;
%skip(1);
	report_control_info.no_of_formatted_pages = report_control_info.no_of_formatted_pages + 1;
%skip(1);
	if format_report_info.number_of_formatted_rows >= report_control_info.no_of_rows_retrieved
	then do;
	     report_control_info.flags.report_is_formatted = ON;
	     report_control_info.flags.report_has_just_been_completed = ON;
	end;
%skip(1);
	if status.remaining_lines_on_page ^= 0
	then do;
	     page_info.length = index (template_map_defined_as_a_string, OFF) - 1;
	     page_info.total_characters = page_info.length * page_info.width;
	end;
%skip(1);
	if page_info.total_characters = 0
	then call ssu_$abort_line (sci_ptr, rw_error_$bad_report_format,
	     "The report description resulted in a zero length page.");
%skip(1);
	if paginated_report
	then substr (page_defined_as_lines (page_info.length), page_info.width, 1) = FORM_FEED;
%skip(1);
	return;
%skip(1);
     end close_page;
%page;
evaluate_active_string: proc (

	eas_active_string_parm,	  /* input: the active string */
	eas_result_string_parm	  /* output: resultant string */
		      );
%skip(1);
dcl eas_active_string_parm char (*) varying parm;
dcl eas_active_string_parm_length fixed bin (21);
dcl eas_active_string_type fixed bin;
dcl eas_code fixed bin (35);
dcl eas_current_position fixed bin (21);
dcl eas_current_inner_position fixed bin (21);
dcl eas_left_bracket_count fixed bin;
dcl eas_left_bracket_position fixed bin (21);
dcl eas_looking_for_matching_right_bracket bit (1) aligned;
dcl eas_next_bracket fixed bin (21);
dcl eas_result_string_parm char (*) varying parm;
dcl eas_right_bracket_count fixed bin;
dcl eas_right_bracket_position fixed bin (21);
dcl eas_still_evaluating bit (1) aligned;
dcl eas_string char (eas_string_length) based (eas_string_ptr);
dcl eas_string_length fixed bin (21);
dcl eas_string_ptr ptr;
dcl eas_string_start fixed bin (21);
%skip(3);
/*
     If there are no active requests return to caller.  Find the left bracket.
     Check for "|[" and "||[" constructs and set flag accordingly.  Move any
     user text before the left bracket into the result string.  Find the
     matching right bracket.  Have ssu_$evaluate_active_string evaluate
     everything between the left and matching right bracket.  Move the result
     into the result string.  Repeat these operations until no more active
     requests are left. Move any remaining user text into the result string.
*/
%skip(1);
	eas_next_bracket = search (eas_active_string_parm, LEFT_OR_RIGHT_BRACKET);
	if eas_next_bracket = 0
	then do;
	     eas_result_string_parm = eas_active_string_parm;
	     return;
	end;
%skip(1);
	eas_result_string_parm = "";
	eas_current_position = 1;
	eas_active_string_parm_length = length (eas_active_string_parm);
	eas_still_evaluating = ON;
%page;
	do while (eas_still_evaluating);
%skip(1);
	     eas_left_bracket_count = 0;
	     eas_right_bracket_count = 0;
	     eas_left_bracket_position = index (substr (eas_active_string_parm, eas_current_position), LEFT_BRACKET);
	     if eas_left_bracket_position = 0
	     then call ssu_$abort_line (sci_ptr, error_table_$unbalanced_brackets,
		"^a", eas_active_string_parm);
	     eas_left_bracket_count = eas_left_bracket_count + 1;
%skip(1);
	     if eas_left_bracket_position >= 3
	     then if substr (eas_active_string_parm,
		eas_current_position + eas_left_bracket_position - 3, 2) = BAR_BAR
		then eas_active_string_type = ATOMIC_ACTIVE_STRING;
	          else if substr (eas_active_string_parm,
		     eas_current_position + eas_left_bracket_position - 2, 1) = BAR
		     then eas_active_string_type = TOKENS_ONLY_ACTIVE_STRING;
		     else eas_active_string_type = NORMAL_ACTIVE_STRING;
	     else if eas_left_bracket_position >= 2
		then if substr (eas_active_string_parm,
		     eas_current_position + eas_left_bracket_position - 2, 1) = BAR
		     then eas_active_string_type = TOKENS_ONLY_ACTIVE_STRING;
	               else eas_active_string_type = NORMAL_ACTIVE_STRING;
		else eas_active_string_type = NORMAL_ACTIVE_STRING;
%skip(1);
	     if eas_active_string_type = NORMAL_ACTIVE_STRING
	     then eas_result_string_parm = eas_result_string_parm || substr (eas_active_string_parm,
		eas_current_position, eas_left_bracket_position - 1);
	     else if eas_active_string_type = TOKENS_ONLY_ACTIVE_STRING
		then eas_result_string_parm = eas_result_string_parm || substr (eas_active_string_parm,
		     eas_current_position, eas_left_bracket_position - 2);
		else eas_result_string_parm = eas_result_string_parm || substr (eas_active_string_parm,
		     eas_current_position, eas_left_bracket_position - 3);
%skip(1);
	     eas_current_inner_position = eas_current_position + eas_left_bracket_position;
	     eas_string_start = eas_current_inner_position;
	     eas_looking_for_matching_right_bracket = ON;
%skip(1);
	     do while (eas_looking_for_matching_right_bracket);
		if eas_current_inner_position > eas_active_string_parm_length
		then call ssu_$abort_line (sci_ptr, error_table_$unbalanced_brackets,
		     "^a", eas_active_string_parm);
		eas_next_bracket = search (substr (eas_active_string_parm,
		     eas_current_inner_position), LEFT_OR_RIGHT_BRACKET);
		if eas_next_bracket = 0
		then call ssu_$abort_line (sci_ptr, error_table_$unbalanced_brackets,
		     "^a", eas_active_string_parm);
		if substr (eas_active_string_parm, eas_current_inner_position + eas_next_bracket - 1, 1) = LEFT_BRACKET
		then eas_left_bracket_count = eas_left_bracket_count + 1;
		else eas_right_bracket_count = eas_right_bracket_count + 1;
		if eas_left_bracket_count = eas_right_bracket_count
		then eas_looking_for_matching_right_bracket = OFF;
		else eas_current_inner_position = eas_current_inner_position + eas_next_bracket;
	     end;
%skip(1);
	     eas_right_bracket_position = eas_current_inner_position + eas_next_bracket - 1;
	     eas_string_length = eas_right_bracket_position - eas_string_start;
	     eas_string_ptr = addr (substr (eas_active_string_parm, eas_string_start, 1));
	     time1 = vclock;
	     call ssu_$evaluate_active_string (sci_ptr, null (), eas_string,
		eas_active_string_type, eas_spare_string, eas_code);
	     time2 = vclock;
	     report_control_info.ssu_evaluate_active_string_time
		= report_control_info.ssu_evaluate_active_string_time + time2 - time1;
	     if eas_code ^= 0
	     then call ssu_$abort_line (sci_ptr, eas_code);
%skip(1);
	     eas_result_string_parm = eas_result_string_parm || eas_spare_string;
	     eas_current_position = eas_right_bracket_position + 1;
%skip(1);
	     if eas_current_position > eas_active_string_parm_length
	     then eas_still_evaluating = OFF;
	     else if search (substr (eas_active_string_parm, eas_current_position), LEFT_OR_RIGHT_BRACKET) = 0
		then do;
		     eas_result_string_parm = eas_result_string_parm
			|| substr (eas_active_string_parm, eas_current_position);
		     eas_still_evaluating = OFF;
		end;
		else;
%skip(1);
	end;
%skip(1);
	return;
%skip(1);
     end evaluate_active_string;
%page;
execute_editing_strings: proc;
%skip(1);
dcl ees_loop fixed bin;
%skip(3);
/*
     Walk through the list of input columns in the column order specified
     by the user. If the column has an editing request associated with it,
     pick up the pointer and length to the original editing request from the
     input_columns_info array. Have it evaluated. If the column isn't being
     excluded from the page, then set the editing string ptr and length for
     it's output column to the result string; if it is then set the same
     information for the input column. Stash the result string in the temp
     segment and advance the next available byte index.
*/
%skip(1);
	editing_strings_next_byte = format_report_info.editing_strings_next_available_byte;
%skip(1);
	do ees_loop = 1 to input_columns_info.number_of_columns;
	     column_ip = addr (input_columns_info.columns (input_columns_order (ees_loop)));
	     if column_info.editing
	     then do;
		editing_string_rl = column_info.editing_string_length;
		editing_string_rp = column_info.editing_string_ptr;
		input_string = editing_string_result;
		call evaluate_active_string (input_string, output_string);
		if column_info.output_column ^= 0
		then column_ip = addr (output_columns_info.columns (column_info.output_column));
		column_info.editing_string_result_length = length (output_string);
		column_info.editing_string_result_ptr
		     = addr (editing_strings_temp_seg_as_an_array (editing_strings_next_byte));
		substr (editing_strings_temp_seg, editing_strings_next_byte, 
		     column_info.editing_string_result_length) = output_string;
		editing_strings_next_byte
		     = editing_strings_next_byte + column_info.editing_string_result_length;
	     end;
	end;
%skip(1);
	return;
%skip(1);
     end execute_editing_strings;
%page;
fit_column: proc (

	fc_column_value_parm,     /* input: actual column value */
	fc_output_width_parm,     /* input: width to place it into */
	fc_output_position_parm,  /* input: starting position in template */
	fc_alignment_mode_parm,   /* input: left, right, center, or both */
	fc_decimal_position_parm, /* input: decimal position within width */
	fc_template_parm,	      /* input: template to lay down */
	fc_fill_parm,	      /* input: fill or truncate */
	fc_line_number_parm,      /* input: beginning line number on page */
	fc_code_parm	      /* output: success or failure */
	);
%skip(1);
dcl fc_additional_alignment bit (1) aligned;
dcl fc_alignment_mode_parm fixed bin parm;
dcl fc_code fixed bin (35);
dcl fc_code_parm fixed bin (35) parm;
dcl fc_column_value_parm char (*) varying parm;
dcl fc_current_line_on_page fixed bin;
dcl fc_current_position fixed bin;
dcl fc_decimal_position_parm fixed bin;
dcl fc_fill_parm bit (1) unaligned parm;
dcl fc_line_number_parm fixed bin parm;
dcl fc_new_line_position fixed bin;
dcl fc_output_column char (fc_output_width_parm) based (fc_output_column_ptr);
dcl fc_output_column_ptr ptr;
dcl fc_output_width_parm fixed bin parm;
dcl fc_output_position_parm fixed bin parm;
dcl fc_returned_string_length fixed bin (21);
dcl fc_spare_string_length fixed bin;
dcl fc_still_filling bit (1) aligned;
dcl fc_string_end fixed bin;
dcl fc_template_parm char (*) parm;
%skip(3);
/*
     Make sure we're not starting past the end of the page. Set our current
     line on the page to where the parm says we're supposed to start. If a
     template hasn't been laid down yet on that line then lay one down and
     mark it as laid down. If the value contains hardcopy mechanical device
     motion control codes, or it is overlength, or the alignment is set to
     both, then have the value filled; else have the value placed.
*/
%skip(1);
	fc_code_parm = 0;
	if fc_line_number_parm > template_map_number_of_bits
	then do;
	     fc_code_parm = PAGE_OVERFLOW_ERROR_CODE;
	     return;
	end;
	else fc_current_line_on_page = fc_line_number_parm;
%skip(1);
	if ^template_map (fc_current_line_on_page)
	then do;
	     page_defined_as_lines (fc_current_line_on_page) = fc_template_parm;
	     template_map (fc_current_line_on_page) = ON;
	end;
%skip(1);
	if (search (fc_column_value_parm, BACKSPACE_OR_VERTICAL_TAB_OR_HORIZONTAL_TAB_OR_NL) ^= 0)
	| (length (fc_column_value_parm) > fc_output_width_parm)
	| (fc_alignment_mode_parm = BOTH_ALIGNMENT)
	then call fill_the_column;
	else call place_column (fc_column_value_parm);
%skip(1);
	return;
%page;
fill_the_column: proc;
%skip(3);
/*
     The variable output_string is based on a segment, and the variable
     input_string is artificially constructed to look like a char (N) where
     N is the length of the meaninful portion of our parm. We do this because
     format_document_ doesn't want a varying char string, and because
     format_document_ will start out by doing a 
     "length (rtrim (input_string))" of input_string, which could be an entire
     segment. Set the adj_sw and call format_document_. Artifically set the
     length of output_string based on how long format_document_ says it is.
     Strings filled by format_document_ may still have to be additionally
     aligned to center or right as they are being placed on the page. If the
     alignment mode is truncate then call the subroutine to do it, else do
     it here.
*/
%skip(1);
	input_string_non_varying_length = length (fc_column_value_parm);
	input_string_non_varying_ptr = addrel (addr (fc_column_value_parm), 1);
	format_document_options.line_length = fc_output_width_parm;
	if fc_alignment_mode_parm = BOTH_ALIGNMENT
	then format_document_options.switches.adj_sw = ON;
	else format_document_options.switches.adj_sw = OFF;
%skip(1);
	call format_document_$string (input_string_non_varying, output_string_non_varying,
	     fc_returned_string_length, format_document_options_ptr, fc_code);
	if fc_code ^= 0
	then if fc_code ^= error_table_$recoverable_error
	     then call ssu_$abort_line (sci_ptr, fc_code);
	if fc_returned_string_length = 0
	then return;
%skip(1);
	output_string_redefined.length_word = fc_returned_string_length;
%skip(1);
	if fc_alignment_mode_parm = CENTER_ALIGNMENT | fc_alignment_mode_parm = RIGHT_ALIGNMENT
	then fc_additional_alignment = ON;
	else fc_additional_alignment = OFF;
%skip(1);
	if ^fc_fill_parm
	then do;
	     call truncate_the_column;
	     return;
	end;
%page;
/*
     Walk through the filled string. Find the newline. If the found portion
     contains any backspaces then send it off to the hardcopy terminal
     alignment routine. If it doesn't and there is additional alignment then
     have it done. If it doesn't and there isn't additional alignment then just
     place it on the page. If we're still filling then advance our current
     line on the page, check for template already laid down, lay it down and
     mark it if it hasn't been laid down.
*/
%skip(1);
	fc_still_filling = ON;
	fc_current_position = 1;
%skip(1);
	do while (fc_still_filling);
	     fc_new_line_position = index (substr (output_string, fc_current_position), NEWLINE);
	     if index (substr (output_string, fc_current_position, fc_new_line_position - 1), BACKSPACE) ^= 0
	     then do;
		fc_spare_string = substr (output_string, fc_current_position, fc_new_line_position - 1);
		call align_hardcopy_dependent_string (fc_spare_string);
	     end;
	     else if fc_additional_alignment
		then do;
		     fc_spare_string = substr (output_string, fc_current_position, fc_new_line_position - 1);
		     call place_column (fc_spare_string);
		end;
		else substr (page_defined_as_lines (fc_current_line_on_page),
		     fc_output_position_parm, fc_new_line_position - 1)
		     = substr (output_string, fc_current_position, fc_new_line_position - 1);
	     fc_current_position = fc_current_position + fc_new_line_position;
	     if fc_current_position > output_string_redefined.length_word
	     then fc_still_filling = OFF;
	     else do;
		fc_current_line_on_page = fc_current_line_on_page + 1;
		if fc_current_line_on_page > template_map_number_of_bits
		then do;
		     fc_code_parm = PAGE_OVERFLOW_ERROR_CODE;
		     return;
		end;
		if ^template_map (fc_current_line_on_page)
		then do;
		     page_defined_as_lines (fc_current_line_on_page) = fc_template_parm;
		     template_map (fc_current_line_on_page) = ON;
		end;
	     end;
	end;
%skip(1);
	return;
%skip(1);
     end fill_the_column;
%page;
place_column: proc (

	pc_column_value_parm     /* input: actual column value */
	         );
%skip(1);
dcl pc_column_value_parm char (*) varying parm;
dcl pc_column_width fixed bin;
dcl pc_decimal_position fixed bin;
dcl pc_no_of_digits_to_the_left fixed bin;
dcl pc_no_of_digits_to_the_right fixed bin;
dcl pc_remaining_digits fixed bin;
dcl pc_starting_position fixed bin;
dcl pc_the_actual_decimal fixed bin;
%skip(3);
/*
     Set the pointer to the output column to the desired spot on the page.
     Have the value aligned within the output column based on what the
     parm says.
*/
%skip(1);
	fc_output_column_ptr = addr (page_defined_as_chars (
	     ((fc_current_line_on_page - 1) * page_info.width + fc_output_position_parm)));
%skip(1);
          if fc_alignment_mode_parm = DECIMAL_ALIGNMENT
	then call align_decimal_value;
	else if fc_alignment_mode_parm = LEFT_ALIGNMENT
	     then call align_left_value;
	     else if fc_alignment_mode_parm = RIGHT_ALIGNMENT
		then call align_right_value;
	          else if fc_alignment_mode_parm = CENTER_ALIGNMENT
		     then call align_center_value;
		     else call ssu_$abort_line (sci_ptr, error_table_$badcall,
			"Unknown alignment mode ^d.", fc_alignment_mode_parm);
%skip(1);
          return;
%page;
align_center_value: proc;
%skip(3);
/*
     Center the value in the output column. (Centre it for the Canadian users.
     This subroutine speaks American and Canadian.) Figure out where it should
     start and substring it into place.
*/
%skip(1);
	pc_column_width = length (pc_column_value_parm);
%skip(1);
	if (pc_column_width = fc_output_width_parm) | (fc_output_width_parm - pc_column_width) = 1
	then pc_starting_position = 1;
	else if fc_output_width_parm - pc_column_width = 2
	     then pc_starting_position = 2;
	     else do;
		pc_starting_position = fc_output_width_parm - pc_column_width;
		pc_starting_position = divide (pc_starting_position, 2, 17) + 1;
	     end;
%skip(1);
	substr (fc_output_column, pc_starting_position, pc_column_width) = pc_column_value_parm;
%skip(1);
          return;
%skip(1);
     end align_center_value;
%page;
align_decimal_value: proc;
%skip(1);
/* Decimal align it within the output column width, adding the decimal if necessary. */
%skip(1);
          pc_column_value = pc_column_value_parm;
	pc_column_width = length (pc_column_value);
	if fc_decimal_position_parm > fc_output_width_parm
	then pc_decimal_position = fc_output_width_parm;
	else pc_decimal_position = fc_decimal_position_parm;
	pc_no_of_digits_to_the_left = pc_decimal_position - 1;
	pc_no_of_digits_to_the_right = fc_output_width_parm - pc_decimal_position;
%skip(1);
	substr (fc_output_column, pc_decimal_position, 1) = ".";
	pc_the_actual_decimal = index (pc_column_value, ".");
	if pc_the_actual_decimal = 0
	then do;
	     if pc_column_width = pc_decimal_position
	     then pc_column_value = substr (pc_column_value, 2) || ".";
	     else pc_column_value = pc_column_value || ".";
	     pc_column_width = length (pc_column_value);
	     pc_the_actual_decimal = pc_column_width;
	end;
%skip(1);
	if pc_the_actual_decimal = pc_decimal_position
	then substr (fc_output_column, 1, pc_no_of_digits_to_the_left)
	     = substr (pc_column_value, 1, pc_no_of_digits_to_the_left);
	else if pc_the_actual_decimal - 1 > pc_no_of_digits_to_the_left
	     then substr (fc_output_column, 1, pc_no_of_digits_to_the_left)
		= substr (pc_column_value, pc_the_actual_decimal
	          - pc_no_of_digits_to_the_left, pc_no_of_digits_to_the_left);
	     else substr (fc_output_column, pc_no_of_digits_to_the_left
		- pc_the_actual_decimal + 2, pc_the_actual_decimal - 1)
		= substr (pc_column_value, 1, pc_the_actual_decimal - 1);
%skip(1);
	if pc_no_of_digits_to_the_right = 0 | pc_the_actual_decimal = pc_column_width
	then return;
%skip(1);
	pc_remaining_digits = pc_column_width - pc_the_actual_decimal;
	if pc_no_of_digits_to_the_right = pc_remaining_digits
	then substr (fc_output_column, pc_decimal_position + 1)
	     = substr (pc_column_value, pc_the_actual_decimal + 1);
	else if pc_no_of_digits_to_the_right > pc_remaining_digits
	     then substr (fc_output_column, pc_decimal_position + 1)
	          = substr (pc_column_value, pc_the_actual_decimal + 1);
	     else substr (fc_output_column, pc_decimal_position + 1)
		= substr (pc_column_value, pc_the_actual_decimal + 1, pc_no_of_digits_to_the_right);
%skip(1);
          return;
%skip(1);
     end align_decimal_value;
%page;
align_left_value: proc;
%skip(3);
/*
     An easy alignment task, but probably the most often used. Note that only
     the exact number of characters in the parm are what's moved. The template
     that was laid down already blanked the rest of the output column.
*/
%skip(1);
          substr (fc_output_column, 1, length (pc_column_value_parm)) = pc_column_value_parm;
%skip(1);
          return;
%skip(1);
     end align_left_value;
%page;
align_right_value: proc;
%skip(3);
/*
     Once again, only the characters in the parm are moved.
*/
%skip(1);
          substr (fc_output_column, fc_output_width_parm - length (pc_column_value_parm) + 1)
	     = pc_column_value_parm;
%skip(1);
          return;
%skip(1);
     end align_right_value;
%skip(3);
     end place_column;
%page;
align_hardcopy_dependent_string: proc (

	ahds_column_value_parm	/* input: actual column value */
		     );
%skip(1);
dcl ahds_column_value_parm char (*) varying parm;
dcl ahds_current_input_position fixed bin;
dcl ahds_current_output_position fixed bin;
dcl ahds_loop fixed bin;
dcl ahds_number_of_chars_to_move fixed bin;
dcl ahds_overstrike_index fixed bin;
dcl ahds_still_overstriking bit (1) aligned;
dcl ahds_string_length fixed bin;
dcl ahds_truncate_the_column bit (1) aligned;
dcl ahds_virtual_length fixed bin;
%skip(3);
/*
     Hopefully all of the hardcopy device support will one day be moved out
     of the operating system and applications forever. In the meantime we
     continue to bake it into everything written on Multics because that's
     the way it was done back in 1965 when Multics was first started.
     Fortunately the video system has said "I don't support ugly backspaces,
     and if you give me any to write I will refuse and hand you back an error
     code." This subroutine pre-processes the data so that the video system
     will not give us any error codes, and we can do things more rationally
     than they were done back in 1965 and are still being done today many
     places in Multics. This is also the key to why this formatter runs *so*
     fast when compared with others like compose. It never has to try to
     figure out where it really is on a page, because it doesn't have 
     imbedded hardcopy device motion control characters stuck in the formatted
     page. Instead they are moved off to a separate overstrike array, and the
     formatter only runs slower for the people who continue to bake hardcopy
     device motion control characters in their formatted data. When the page is
     being displayed through the video system the page is displayed without
     any of the overstruck sequences; when it is being displayed in hardcopy
     dependent fashion the overstruck characters are put back in at display
     time.
*/
%skip(1);
	ahds_string_length = length (ahds_column_value_parm);
	if ahds_string_length = 0
	then return;
%skip(1);
	ahds_overstrike_index = ((fc_current_line_on_page - 1) * page_info.width)
	     + fc_output_position_parm;
	fc_output_column_ptr = addr (page_defined_as_chars (ahds_overstrike_index));
%skip(1);
	ahds_virtual_length = 0;
	do ahds_loop = 1 to ahds_string_length;
	     if substr (ahds_column_value_parm, ahds_loop, 1) ^= BACKSPACE
	     then ahds_virtual_length = ahds_virtual_length + 1;
	     else ahds_virtual_length = ahds_virtual_length - 1;
	end;
%skip(1);
	if ^fc_fill_parm
	then do;
	     if ahds_virtual_length > fc_output_width_parm
	     then do;
		ahds_number_of_chars_to_move = fc_output_width_parm - truncation_indicator_length;
		ahds_truncate_the_column = ON;
	     end;
	     else do;
		ahds_number_of_chars_to_move = ahds_virtual_length;
		ahds_truncate_the_column = OFF;
	     end;
	     if ahds_truncate_the_column
	     then if fc_output_width_parm <= truncation_indicator_length
		then do;
		     if fc_output_width_parm < truncation_indicator_length
		     then fc_output_column = substr (format_report_info.truncation_indicator, 1, fc_output_width_parm);
		     else fc_output_column = format_report_info.truncation_indicator;
		     return;
		end;
		else;
	     else;
	end;
	else ahds_number_of_chars_to_move = ahds_virtual_length;
%skip(1);
	if page_info.page_overstrike_info_ptr = null ()
	then do;
	     page_info.page_overstrike_info_ptr = page_overstrike_ip;
	     unspec (page_overstrike_info.bit_map) = OFF;
	end;
%skip(1);
	if ^fc_additional_alignment
	then ahds_current_output_position = 1;
	else do;
	     if fc_alignment_mode_parm = RIGHT_ALIGNMENT
	     then ahds_current_output_position = fc_output_width_parm - ahds_virtual_length + 1;
	     else do;
		if fc_output_width_parm = ahds_virtual_length | fc_output_width_parm - ahds_virtual_length = 1
		then ahds_current_output_position = 1;
		else if fc_output_width_parm - ahds_virtual_length = 2
		     then ahds_current_output_position = 2;
		     else do;
			ahds_current_output_position = fc_output_width_parm - ahds_virtual_length;
			ahds_current_output_position = divide (ahds_current_output_position, 2, 17) + 1;
		     end;
	     end;
	end;
	ahds_current_input_position = 1;
%page;
	do ahds_loop = 1 to ahds_number_of_chars_to_move;
	     substr (fc_output_column, ahds_current_output_position, 1)
		= substr (ahds_column_value_parm, ahds_current_input_position, 1);
	     ahds_current_input_position = ahds_current_input_position + 1;
	     ahds_still_overstriking = ON;
	     do while (ahds_still_overstriking);
		if ahds_current_input_position < ahds_string_length
		then if substr (ahds_column_value_parm, ahds_current_input_position, 1) ^= BACKSPACE
		     then ahds_still_overstriking = OFF;
		     else do;
			ahds_current_input_position = ahds_current_input_position + 1;
			page_overstrike_info.bit_map (ahds_overstrike_index + ahds_current_output_position - 1) = ON;
			page_overstrike_info.chars (ahds_overstrike_index + ahds_current_output_position - 1)
			     =  substr (ahds_column_value_parm, ahds_current_input_position, 1);
			ahds_current_input_position = ahds_current_input_position + 1;
		     end;
		else ahds_still_overstriking = OFF;
	     end;
	     ahds_current_output_position = ahds_current_output_position + 1;
	end;
%skip(1);
	if ^fc_fill_parm
	then if ahds_truncate_the_column
	     then substr (fc_output_column, fc_output_width_parm - truncation_indicator_length + 1)
	          = format_report_info.truncation_indicator;
	     else;
	else;
%skip(1);
	return;
%skip(1);
     end align_hardcopy_dependent_string;
%page;
truncate_the_column: proc;
%skip(3);
/*
     Find out if the character string or the output width is smallest.
     Translate any newlines format_document_ may have put in into blanks.
     If it contains overstruck characters then have the subroutine which
     specializes in that type of stuff do it; else just place the portion
     of the character string that fits into the output position. If this
     results in truncation then place the truncation indicator to show the
     user this has happened.
*/
%skip(1);
	fc_string_end = min (output_string_redefined.length_word, fc_output_width_parm);
	if fc_string_end = 0
	then return;
%skip(1);
	fc_spare_string = substr (output_string, 1, fc_string_end);
	fc_spare_string = translate (fc_spare_string, BLANK, NEWLINE);
	if search (fc_spare_string, BACKSPACE) ^= 0
	then do;
	     call align_hardcopy_dependent_string (fc_spare_string);
	     return;
	end;
%skip(1);
	fc_spare_string_length = length (fc_spare_string);
	substr (page_defined_as_lines (fc_line_number_parm), fc_output_position_parm,
	     fc_spare_string_length) = fc_spare_string;
	if output_string_redefined.length_word ^> fc_output_width_parm
	then return;
%skip(1);
	if fc_output_width_parm > truncation_indicator_length
	then substr (page_defined_as_lines (fc_line_number_parm),
	     fc_output_position_parm + fc_output_width_parm - truncation_indicator_length, truncation_indicator_length)
	     = format_report_info.truncation_indicator;
	else substr (page_defined_as_lines (fc_line_number_parm),
	     fc_output_position_parm, fc_output_width_parm)
	     = substr (format_report_info.truncation_indicator, 1, fc_output_width_parm);
%skip(1);
	return;
%skip(1);
     end truncate_the_column;
%skip(3);
     end fit_column;
%page;
format_detail_block: proc;
%skip(1);
dcl fdb_code fixed bin (35);
dcl fdb_column_changed_flag bit (1) aligned;
%skip(1);
/*
     If the detail block won't fit on the page then we are done. Check to make
     sure that at least one detail block has been placed on the page.
*/
%skip(1);
	if (status.number_of_lines_needed_for_detail_block > status.remaining_lines_on_page)
	| (format_report_info.flags.page_footer_is_defined & status.remaining_lines_on_page
	< status.number_of_lines_needed_for_page_footer + status.number_of_lines_needed_for_detail_block)
	then do;
	     if status.total_number_of_rows_used ^> 0
	     then call ssu_$abort_line (sci_ptr, rw_error_$bad_report_format,
		"^/There isn't enough room to place the first row on the page."
		|| "^/It was row number ^d on page number ^d.",
		status.current_row_number, status.current_page_number);
	     else do;
		still_formatting_detail_blocks = OFF;
		return;
	     end;
	end;
%skip(1);
/*
     Check to see if this row has been processed before and backed off the 
     page. Flag appropriately. If the previous detail block used some lines
     then setup the detail_block information so this one can be backed out
     properly.
*/
%skip(1);
	if status.current_row_number > status.highest_row_formatted
	then do;
	     status.highest_row_formatted = status.current_row_number;
	     status.flags.row_has_been_processed_before = OFF;
	end;
	else status.flags.row_has_been_processed_before = ON;
%skip(1);
	if status.flags.detail_block_used_some_lines
	then do;
	     formatted_page_info.number_of_detail_blocks = formatted_page_info.number_of_detail_blocks + 1;
	     formatted_page_info.detail_blocks (formatted_page_info.number_of_detail_blocks) = 0;
	     formatted_page_info.detail_blocks (formatted_page_info.number_of_detail_blocks).row_number
		= status.current_row_number;
	     formatted_page_info.detail_blocks (formatted_page_info.number_of_detail_blocks).beginning_line_number
		= status.current_line_on_page;
	end;
%page;
/*
     Mark this block initially as using no lines. Execute the editing requests,
     and gather the subtotals, subcounts, totals and counts before formatting
     anything.
*/
%skip(1);
	status.flags.detail_block_used_some_lines = OFF;
%skip(1);
	if format_report_info.flags.editing_is_defined
	then call execute_editing_strings;
%skip(1);
	if format_report_info.flags.subtotal_is_defined
	then call gather_subtotals;
%skip(1);
	if format_report_info.flags.subcount_is_defined
	then call gather_subcounts;
%skip(1);
	if format_report_info.flags.total_is_defined
	then call gather_totals;
%skip(1);
	if format_report_info.flags.count_is_defined
	then call gather_counts;
%skip(1);
/*
     If a group header and trigger are defined then check to see if it is time
     to process it. If one of the trigger columns changed then format the
     header, backing it out if necessary.
*/
%skip(1);
	if format_report_info.flags.group_header_is_defined
	& format_report_info.flags.group_header_trigger_is_defined
	then do;
	     call check_for_group_break (format_report_info.group_header_trigger_info_ptr, 
		LOOK_BEHIND, fdb_column_changed_flag);
	     if fdb_column_changed_flag
	     then do;
		call format_header (format_report_info.group_header_info_ptr, GROUP_HEADER,
		     status.current_line_on_page, status.remaining_lines_on_page,
		     formatted_page_info.detail_blocks (formatted_page_info.number_of_detail_blocks)
		     .group_header_length, fdb_code);
		if fdb_code ^= 0
		then do;
		     call backout_detail_block (GROUP_HEADER);
		     return;
		end;
		else status.flags.detail_block_used_some_lines = ON;
	     end;
	end;
%page;
/*
     Next the row header. If it's defined then format it, backing it out if
     necessary.
*/
%skip(1);
	if format_report_info.flags.row_header_is_defined
	then do;
	     call format_header (format_report_info.row_header_info_ptr, ROW_HEADER,
		status.current_line_on_page, status.remaining_lines_on_page,
		formatted_page_info.detail_blocks (formatted_page_info
		.number_of_detail_blocks).row_header_length, fdb_code);
	     if fdb_code ^= 0
	     then do;
		call backout_detail_block (ROW_HEADER);
		return;
	     end;
	     else status.flags.detail_block_used_some_lines = ON;
	end;
%skip(1);
/*
     If outlining is defined then outline the columns as appropriate.
*/
%skip(1);
	if format_report_info.flags.outline_is_defined
	then call check_for_outlining;
%skip(1);
/*
     If all columns haven't been excluded then format the row, backing it out
     if necessary.
*/
%skip(1);
	if format_report_info.flags.row_value_is_defined
	then do;
	     call format_row (ROW_VALUE, output_columns_ip, 
		row_value_template_ip, GENERATE_ZERO_BLANK_LINES_TRAILER,
		status.current_line_on_page, status.remaining_lines_on_page,
		formatted_page_info.detail_blocks (formatted_page_info
		.number_of_detail_blocks).row_length, fdb_code);
	     if fdb_code ^= 0
	     then do;
		call backout_detail_block (ROW_VALUE);
		return;
	     end;
	     else status.flags.detail_block_used_some_lines = ON;
	end;
%page;
/*
     If subtotals are defined then format them if it's time for any of them
     to be generated, backing out the block if necessary.
*/
%skip(1);
	if format_report_info.flags.subtotal_is_defined
	then do;
	     call format_subtotals (subtotal_ip, subtotal_columns_ip, subtotal_generation_ip, ROW_SUBTOTAL,
		formatted_page_info.detail_blocks.subtotal_length
		(formatted_page_info.number_of_detail_blocks), 
		status.flags.subtotals_ejection_in_progress, fdb_code);
	     if fdb_code ^= 0
	     then do;
		call backout_detail_block (ROW_SUBTOTAL);
		return;
	     end;
	end;
%skip(1);
/*
     If subcounts are defined then format them if it's time for any of them
     to be generated, backing out the block if necessary.
*/
%skip(1);
	if format_report_info.flags.subcount_is_defined
	then do;
	     call format_subtotals (subcount_ip, subcount_columns_ip, subcount_generation_ip, ROW_SUBCOUNT,
		formatted_page_info.detail_blocks.subcount_length
		(formatted_page_info.number_of_detail_blocks), 
		status.flags.subcounts_ejection_in_progress, fdb_code);
	     if fdb_code ^= 0
	     then do;
		call backout_detail_block (ROW_SUBCOUNT);
		return;
	     end;
	end;
%skip(1);
/*
     If totals are defined and this is the last row of the report then format 
     them, backing them out if necessary.
*/
%skip(1);
	if format_report_info.flags.total_is_defined & status.flags.last_row_of_report
	then do;
	     call format_totals (total_ip, total_columns_ip, ROW_TOTAL,
		formatted_page_info.detail_blocks.total_length
		(formatted_page_info.number_of_detail_blocks),
		status.flags.totals_ejection_in_progress, fdb_code);
	     if fdb_code ^= 0
	     then do;
		call backout_detail_block (ROW_TOTAL);
		return;
	     end;
	end;
%page;
/*
     If counts are defined and this is the last row of the report then format 
     them, backing them out if necessary.
*/
%skip(1);
	if format_report_info.flags.count_is_defined & status.flags.last_row_of_report
	then do;
	     call format_totals (count_ip, count_columns_ip, ROW_COUNT,
		formatted_page_info.detail_blocks.count_length
		(formatted_page_info.number_of_detail_blocks),
		status.flags.counts_ejection_in_progress, fdb_code);
	     if fdb_code ^= 0
	     then do;
		call backout_detail_block (ROW_COUNT);
		return;
	     end;
	end;
%skip(1);
/*
     If the row footer is defined then format it, backing it out if necessary.
*/
%skip(1);
	if format_report_info.flags.row_footer_is_defined
	then do;
	     call format_header (format_report_info.row_footer_info_ptr, ROW_FOOTER,
		status.current_line_on_page, status.remaining_lines_on_page,
		formatted_page_info.detail_blocks (formatted_page_info
		.number_of_detail_blocks).row_footer_length, fdb_code);
	     if fdb_code ^= 0
	     then do;
		call backout_detail_block (ROW_FOOTER);
		return;
	     end;
	     else status.flags.detail_block_used_some_lines = ON;
	end;
%page;
/*
     If a group footer and trigger are defined then check to see if it is time
     to process it. If one of the trigger columns changed then format the
     footer, backing it out if necessary.
*/
%skip(1);
	if format_report_info.flags.group_footer_is_defined
	& format_report_info.flags.group_footer_trigger_is_defined
	then do;
	     call check_for_group_break (format_report_info.group_footer_trigger_info_ptr,
		LOOK_AHEAD, fdb_column_changed_flag);
	     if fdb_column_changed_flag
	     then do;
		call format_header (format_report_info.group_footer_info_ptr, GROUP_FOOTER,
		     status.current_line_on_page, status.remaining_lines_on_page,
		     formatted_page_info.detail_blocks (formatted_page_info.number_of_detail_blocks).group_footer_length, fdb_code);
		if fdb_code ^= 0
		then do;
		     call backout_detail_block (GROUP_FOOTER);
		     return;
		end;
		else status.flags.detail_block_used_some_lines = ON;
	     end;
	end;
%skip(1);
/*
     If we've just formatted the last row, or there isn't enough space 
     remaining on the page to attempt the next row, then quit formatting
     detail blocks.
     
*/
%skip(1);
	status.total_number_of_rows_used = status.total_number_of_rows_used + 1;
	status.current_row_number = status.current_row_number + 1;
%skip(1);
	if (status.current_row_number	> report_control_info.no_of_rows_retrieved)
	| (status.number_of_lines_needed_for_detail_block	> status.remaining_lines_on_page)
	| (format_report_info.flags.page_footer_is_defined & status.remaining_lines_on_page
	< status.number_of_lines_needed_for_page_footer + status.number_of_lines_needed_for_detail_block)
	then status.still_formatting_detail_blocks = OFF;
%page;
/*
     Adjust status flags and check to see if it's time for a page break.
*/
%skip(1);
	if report_control_info.table_is_full & status.current_row_number = report_control_info.no_of_rows_retrieved
	then status.flags.last_row_of_report = ON;
%skip(1);
	status.flags.first_row_of_report = OFF;
	status.flags.first_row_on_page = OFF;
%skip(1);
	if format_report_info.flags.page_break_is_defined
	then call check_for_page_break;
%skip(1);
	return;
%skip(1);
     end format_detail_block;
%page;
format_header: proc (

	fh_header_info_ptr_parm,	   /* input: ptr to header info */
	fh_executing_object_parm,	   /* input: who's calling */
	fh_current_line_number_parm,	   /* input/output: current line on page */
 	fh_remaining_lines_on_page_parm, /* input/output: number left on page  */
	fh_number_of_lines_used_parm,    /* output: number of lines used */
	fh_code_parm		   /* output: success or failure */
		);
%skip(1);
dcl fh_current_line_number fixed bin;
dcl fh_current_line_number_parm fixed bin parm;
dcl fh_code_parm fixed bin (35) parm;
dcl fh_executing_object_parm char (*) varying parm;
dcl fh_header_info_ptr_parm ptr parm;
dcl fh_loop fixed bin;
dcl fh_next_line_number fixed bin;
dcl fh_number_of_lines_used fixed bin;
dcl fh_number_of_lines_used_parm fixed bin parm;
dcl fh_remaining_lines_on_page_parm fixed bin parm;
dcl fh_still_counting_lines bit (1) aligned;
%skip(3);
/*
     Check to make sure we aren't about to exceed the page length. Repeat the
     following sequence for each line of the header/footer. Lay down a template
     on the current line and mark it as laid down. For each portion of the
     header that's present, have any active requests evaluated and fit the
     header portion into it assigned slot on the page. If we've still got
     another header line to do then find out where on the page it will begin,
     and repeat the loop. When we've evaluated all lines then count how many
     we've used, fill in the parms, and return to caller.
*/
%skip(1);
	header_ip = fh_header_info_ptr_parm;
	fh_current_line_number = fh_current_line_number_parm;
	fh_number_of_lines_used_parm = 0;
	fh_code_parm = 0;
	status.flags.header_being_evaluated = ON;
	status.object_being_evaluated = fh_executing_object_parm;
%skip(1);
	if fh_current_line_number > template_map_number_of_bits
	then do;
	     fh_code_parm = PAGE_OVERFLOW_ERROR_CODE;
	     return;
	end;
%page;
	do status.current_header_line = 1 to header_info.number_of_lines;
%skip(1);
	     page_defined_as_lines (fh_current_line_number) = generic_template;
	     template_map (fh_current_line_number) = ON;
%skip(1);
	     do status.current_header_part = 1 to header_info.maximum_number_of_parts;
%skip(1);
		if header_info.lines (status.current_header_line).parts (status.current_header_part).flags.present
		then do;
		     if header_info.lines (status.current_header_line).parts (status.current_header_part).flags.active
		     then do;
			output_string = substr (headers_temp_seg,
			     header_info.lines (status.current_header_line).parts (status.current_header_part).index,
			     header_info.lines (status.current_header_line).parts (status.current_header_part).length);
			call evaluate_active_string (output_string, input_string);
		     end;
		     else input_string = substr (headers_temp_seg,
			header_info.lines (status.current_header_line).parts (status.current_header_part).index,
			header_info.lines (status.current_header_line).parts (status.current_header_part).length);
		     call fit_column (input_string, 
			header_info.lines (status.current_header_line).parts (status.current_header_part).width,
			header_info.lines (status.current_header_line).parts (status.current_header_part).starting_position,
			header_info.lines (status.current_header_line).parts (status.current_header_part).alignment,
			0, generic_template, FILL, fh_current_line_number, fh_code_parm);
		     if fh_code_parm ^= 0
		     then return;
		end;
%skip(1);
	     end;
%skip(1);
	     if status.current_header_line < header_info.number_of_lines
	     then do;
		if fh_current_line_number < template_map_number_of_bits
		then fh_next_line_number = index (substr (template_map_defined_as_a_string, 
		     fh_current_line_number + 1), OFF);
		else fh_next_line_number = 0;
		if fh_next_line_number = 0
		then do;
		     fh_code_parm = PAGE_OVERFLOW_ERROR_CODE;
		     return;
		end;
		else fh_current_line_number = fh_current_line_number + fh_next_line_number;
	     end;
%skip(1);
	end;
%page;
	fh_still_counting_lines = ON;
	fh_number_of_lines_used = 0;
%skip(1);
	do fh_loop = fh_current_line_number_parm to template_map_number_of_bits
	     while (fh_still_counting_lines);
	     if template_map (fh_loop)
	     then fh_number_of_lines_used = fh_number_of_lines_used + 1;
	     else fh_still_counting_lines = OFF;
	end;
%skip(1);
	fh_number_of_lines_used_parm = fh_number_of_lines_used;
	fh_current_line_number_parm = fh_current_line_number_parm + fh_number_of_lines_used;
	fh_remaining_lines_on_page_parm = template_map_number_of_bits - fh_current_line_number_parm + 1;
	status.flags.header_being_evaluated = OFF;
%skip(1);
	return;
%skip(1);
     end format_header;
%page;
format_page_footer: proc;
%skip(1);
dcl fpf_beginning_line_number fixed bin;
dcl fpf_code fixed bin (35);
dcl fpf_loop fixed bin;
dcl fpf_overstrike_index_1 fixed bin;
dcl fpf_overstrike_index_2 fixed bin;
dcl fpf_overstruck_page bit (1) aligned;
dcl fpf_page_footer_doesnt_fit bit (1) aligned;
%skip(1);
/*
     Unpaginated reports only have a page footer placed after the last row
     of the report. Repeat the following sequence while the footer doesn't
     fit. Decrement the current row number so the last row on the page is
     available for the footer. Format the footer. If it doesn't fit then
     decrement the number of rows used on this page, back out the last
     detail block, and repeat the loop. If it does fit then kick out of the
     loop. (The proc that does the backing out never allows the first row
     of a page to be removed, so it is the governing mechanism in this loop.)
*/
%skip(1);
	if ^paginated_report & ^status.flags.last_row_of_report
	then return;
%skip(1);
	fpf_page_footer_doesnt_fit = ON;
%skip(1);
	do while (fpf_page_footer_doesnt_fit);
	     status.current_row_number = status.current_row_number - 1;
	     fpf_beginning_line_number = status.current_line_on_page;
	     call format_header (format_report_info.page_footer_info_ptr, PAGE_FOOTER,
		status.current_line_on_page, status.remaining_lines_on_page,
		formatted_page_info.page_footer_length, fpf_code);
	     if fpf_code ^= 0
	     then do;
		status.total_number_of_rows_used = status.total_number_of_rows_used - 1;
		call backout_detail_block (PAGE_FOOTER);
	     end;
	     else fpf_page_footer_doesnt_fit = OFF;
	end;
%skip(1);
/*
     Adjust the current row number to compensate for when we decremented
     it. If there are remaining lines on the page and it's a paginated
     report do the following steps. Work the loop from the last line of the
     page back up to where we placed the last line of the footer. If we've
     just moved up to the point where we originally placed the footer lines
     then lay down a generic template to blank out the footer line, mark
     the template map, and if it's an overstruck page then show the line
     as having no overstrikes. If we haven't arrived at this point yet, then
     move the footer line down the page to where it belongs, mark the template
     map, and move any overstrike info if it's an overstruck page.
*/
%page;
	status.current_row_number = status.current_row_number + 1;
%skip(1);
	if status.remaining_lines_on_page > 0
	then if paginated_report
	     then do;
		fpf_overstruck_page = (page_info.page_overstrike_info_ptr ^= null ());
		do fpf_loop = template_map_number_of_bits to fpf_beginning_line_number by -1;
		     if fpf_loop < template_map_number_of_bits - formatted_page_info.page_footer_length + 1
		     then do;
			page_defined_as_lines (fpf_loop) = generic_template;
			template_map (fpf_loop) = ON;
			if fpf_overstruck_page
			then substr (page_overstrike_info_redefined.bit_map,
			     ((fpf_loop - 1) * page_info.width) + 1, page_info.width) = OFF;
			else;
		     end;
		     else do;
			page_defined_as_lines (fpf_loop)
			     = page_defined_as_lines (fpf_loop - status.remaining_lines_on_page);
			template_map (fpf_loop) = ON;
			if fpf_overstruck_page
			then do;
			     fpf_overstrike_index_1 = ((fpf_loop - 1) * page_info.width) + 1;
			     fpf_overstrike_index_2 = ((fpf_loop - status.remaining_lines_on_page - 1) * page_info.width) + 1;
			     substr (page_overstrike_info_redefined.bit_map,
				fpf_overstrike_index_1, page_info.width)
				= substr (page_overstrike_info_redefined.bit_map, 
				fpf_overstrike_index_2, page_info.width);
			     substr (page_overstrike_info_redefined.chars, 
				fpf_overstrike_index_1, page_info.width)
				= substr (page_overstrike_info_redefined.chars, 
				fpf_overstrike_index_2, page_info.width);
			end;
		     end;
		end;
		status.current_line_on_page = template_map_number_of_bits;
		status.remaining_lines_on_page = 0;
	     end;
	     else;
	else;
%skip(1);
	return;
%skip(1);
     end format_page_footer;
%page;
format_page_header: proc;
%skip(1);
dcl fph_code fixed bin (35);
%skip(3);
/*
     Unpaginated reports only have the header placed before the first row.
     Format the header and if it doesn't fit shut things down.
*/
%skip(1);
	if ^paginated_report & ^status.flags.first_row_of_report
	then return;
%skip(1);
	call format_header (format_report_info.page_header_info_ptr, PAGE_HEADER,
	     status.current_line_on_page, status.remaining_lines_on_page,
	     formatted_page_info.page_header_length, fph_code);
	if fph_code ^= 0
	then call ssu_$abort_line (sci_ptr, rw_error_$bad_report_format,
	     "^/There isn't enough room to place the page header on page number ^d.",
	     status.current_page_number);
%skip(1);
	return;
%skip(1);
     end format_page_header;
%page;
format_row: proc (

	fr_executing_object_parm,	    /* input: who's calling */
	fr_output_columns_info_ptr_parm,  /* input: ptr to output_columns_info */
	fr_row_template_info_ptr_parm,    /* input: ptr to template_info */
	fr_number_of_blank_lines_parm,    /* input: # of blank lines after row */
	fr_current_line_number_parm,	    /* input/output: current line on page */
	fr_remaining_lines_on_page_parm,  /* input/output: number left on page  */
	fr_number_of_lines_used_parm,     /* output: number of lines used */
	fr_code_parm		    /* output: success or failure */
		);
%skip(1);
dcl fr_current_line_number_parm fixed bin parm;
dcl fr_code_parm fixed bin (35) parm;
dcl fr_current_detail_line fixed bin;
dcl fr_current_line_number fixed bin;
dcl fr_executing_object_parm char (*) varying parm;
dcl fr_loop fixed bin;
dcl fr_next_line_number fixed bin;
dcl fr_number_of_blank_lines_parm fixed bin;
dcl fr_number_of_lines_used fixed bin;
dcl fr_number_of_lines_used_by_prefix fixed bin;
dcl fr_number_of_lines_used_parm fixed bin parm;
dcl 1 fr_output_columns_info like output_columns_info based (fr_output_columns_info_ptr);
dcl fr_output_columns_info_ptr ptr;
dcl fr_output_columns_info_ptr_parm ptr parm;
dcl fr_remaining_lines_on_page_parm fixed bin parm;
dcl 1 fr_row_template_info like template_info based (fr_row_template_info_ptr);
dcl fr_row_template_info_ptr ptr;
dcl fr_row_template_info_ptr_parm ptr parm;
dcl fr_still_counting_lines bit (1) aligned;
%skip(1);
/*
     Move parms into automatic variables, check to make sure we aren't
     about to run off the page, lay down a template on the first line and
     mark it.
*/
%skip(1);
	status.object_being_evaluated = fr_executing_object_parm;
	fr_output_columns_info_ptr = fr_output_columns_info_ptr_parm;
	fr_row_template_info_ptr = fr_row_template_info_ptr_parm;
	fr_current_line_number = fr_current_line_number_parm;
	fr_number_of_lines_used_parm = 0;
	fr_code_parm = 0;
%skip(1);
	fr_current_detail_line = 1;
	template_ptr = addr (fr_row_template_info.templates (fr_current_detail_line));
	if fr_current_line_number > template_map_number_of_bits
	then do;
	     fr_code_parm = PAGE_OVERFLOW_ERROR_CODE;
	     return;
	end;
	page_defined_as_lines (fr_current_line_number) = template;
	template_map (fr_current_line_number) = ON;
%page;
/*
     Repeat the following sequence for each column that isn't being outlined.
     If it has a prefix character then expand it to full column width and
     have it fit into the output column. If it has an editing request then use
     it; else rtrim character column values and rtrim and ltrim all other 
     column values. Fit the column into the output column. If we're not on
     the last column and the next column goes onto a different output line,
     then find out where the next output line is and lay down a template also
     marking it (making sure it doesn't place us past the end of the page).
*/
%skip(1);
	do status.current_column_number = 1 to fr_output_columns_info.number_of_columns;
	     column_ip = addr (fr_output_columns_info.columns (status.current_column_number));
	     if ^column_info.flags.outline
	     then do;
		if length (column_info.prefix_character) > 0
		then do;
		     fr_spare_string = copy (column_info.prefix_character, column_info.width);
		     call fit_column (fr_spare_string, column_info.width,
			column_info.starting_position, LEFT_ALIGNMENT,
			0, template, FILL, fr_current_line_number, fr_code_parm);
		     if fr_code_parm ^= 0
		     then return;
		     else fr_number_of_lines_used_by_prefix = 1;
		end;
		else fr_number_of_lines_used_by_prefix = 0;
		if column_info.flags.editing
		then do;
		     editing_string_rl = column_info.editing_string_result_length;
		     editing_string_rp = column_info.editing_string_result_ptr;
		     input_string = editing_string_result;
		end;
		else do;
		     if column_info.subsystem_data_type ^= CHAR_DATA_TYPE
		     then input_string = ltrim (rtrim (substr (current_row_value,
			table_info.columns.column_index (column_info.input_column),
			table_info.columns.column_length (column_info.input_column))));
		     else input_string = rtrim (substr (current_row_value,
			table_info.columns.column_index (column_info.input_column),
			table_info.columns.column_length (column_info.input_column)));
		end;
		call fit_column (input_string, column_info.width,
		     column_info.starting_position, column_info.alignment,
		     column_info.decimal_position, template, column_info.folding_is_fill, 
		     fr_current_line_number + fr_number_of_lines_used_by_prefix, fr_code_parm);
		if fr_code_parm ^= 0
		then return;
	     end;
	     else;
	     if status.current_column_number ^= fr_output_columns_info.number_of_columns
	     then if fr_output_columns_info.columns (status.current_column_number).output_line
		^= fr_output_columns_info.columns (status.current_column_number + 1).output_line
		then do;
		     if fr_current_line_number < template_map_number_of_bits
		     then fr_next_line_number = index (substr (template_map_defined_as_a_string,
			fr_current_line_number + 1), OFF);
		     else fr_next_line_number = 0;
		     if fr_next_line_number = 0
		     then do;
			fr_code_parm = PAGE_OVERFLOW_ERROR_CODE;
			return;
		     end;
		     fr_current_line_number = fr_current_line_number + fr_next_line_number;
		     fr_current_detail_line = fr_current_detail_line + 1;
		     template_ptr = addr (fr_row_template_info.templates (fr_current_detail_line));
		     page_defined_as_lines (fr_current_line_number) = template;
		     template_map (fr_current_line_number) = ON;
		end;
	end;
%skip(1);
/*
     Find out how many lines we've used. Add any blank trailer lines requested
     by the caller. Set the parms and return to caller.
*/
%skip(1);
	fr_still_counting_lines = ON;
	fr_number_of_lines_used = 0;
%skip(1);
	do fr_loop = fr_current_line_number_parm to template_map_number_of_bits
	     while (fr_still_counting_lines);
	     if template_map (fr_loop)
	     then fr_number_of_lines_used = fr_number_of_lines_used + 1;
	     else fr_still_counting_lines = OFF;
	end;
%skip(1);
	if fr_number_of_blank_lines_parm ^= 0
	then do;
	     fr_current_line_number = fr_current_line_number_parm + fr_number_of_lines_used;
	     do fr_loop = 1 to fr_number_of_blank_lines_parm;
		if fr_current_line_number ^> template_map_number_of_bits
		then do;
		     page_defined_as_lines (fr_current_line_number) = generic_template;
		     template_map (fr_current_line_number) = ON;
		     fr_current_line_number = fr_current_line_number + 1;
		     fr_number_of_lines_used = fr_number_of_lines_used + 1;
		end;
		else do;
		     fr_code_parm = PAGE_OVERFLOW_ERROR_CODE;
		     return;
		end;
	     end;
	end;
%skip(1);
	fr_number_of_lines_used_parm = fr_number_of_lines_used;
	fr_current_line_number_parm = fr_current_line_number_parm + fr_number_of_lines_used;
	fr_remaining_lines_on_page_parm = template_map_number_of_bits - fr_current_line_number_parm + 1;
%skip(1);
	return;
%skip(1);
     end format_row;
%page;
format_title_block: proc;
%skip(1);
dcl ftb_code fixed bin (35);
dcl ftb_current_line_number fixed bin;
dcl ftb_loop fixed bin;
%skip(3);
/*
     Unpaginated reports only have the title block placed before the first
     row of the report. Create the title block if it's our first time and
     save it away for future use if it's a paginated report. If it isn't our
     first time then just place the title block we've already created. If the
     title block contains overstruck characters then they loose this 
     optimization (the title block is formatted every time it's needed). If
     the title block doesn't fit then shut things down.
*/
%skip(1);
	if (^paginated_report & ^status.flags.first_row_of_report)
	then  return;
%skip(1);
	if format_report_info.title_block_info_ptr = null ()
	then call create_title_block (ftb_code);
	else call place_title_block (ftb_code);
%skip(1);
	if ftb_code ^= 0
	then call ssu_$abort_line (sci_ptr, rw_error_$bad_report_format,
	     "^/There isn't enough room to place the titles on page number ^d.",
	     status.current_page_number);
%skip(1);
	return;
%page;
create_title_block: proc (ctb_code_parm);
%skip(1);
dcl ctb_code_parm fixed bin (35) parm;
%skip(3);
/*
     Format the title block onto the page. If it's not a paginated report or
     it contains overstruck characters then return to caller. Allocate the
     title_block_info structure and save away our formatted lines for future
     placement on the coming pages.
*/
%skip(1);
	title_block_columns_ip = format_report_info.title_block_columns_info_ptr;
	ftb_current_line_number = status.current_line_on_page;
	call format_row (ROW_TITLES, title_block_columns_ip,
	     row_value_template_ip, GENERATE_ONE_BLANK_LINE_TRAILER,
	     status.current_line_on_page, status.remaining_lines_on_page,
	     formatted_page_info.title_block_length, ctb_code_parm);
	if ctb_code_parm ^= 0
	then return;
%skip(1);
	if ^paginated_report
	then return;
	else if page_info.page_overstrike_info_ptr ^= null ()
	     then if index (substr (page_overstrike_info_redefined.bit_map,
	          ((ftb_current_line_number - 1) * page_info.width) + 1,
	          page_info.width * formatted_page_info.title_block_length), ON) ^= 0
	          then return;
%skip(1);
	tbi_init_line_length = page_info.width;
	tbi_init_number_of_lines = formatted_page_info.title_block_length;
	allocate title_block_info in (work_area) set (title_block_ip);
%skip(1);
	do ftb_loop = 1 to formatted_page_info.title_block_length;
	     title_block_info.lines (ftb_loop) = page_defined_as_lines (ftb_current_line_number);
	     ftb_current_line_number = ftb_current_line_number + 1;
	end;
%skip(1);
	format_report_info.title_block_info_ptr = title_block_ip;
%skip(1);
	return;
%skip(1);
     end create_title_block;
%page;
place_title_block: proc (ptb_code_parm);
%skip(1);
dcl ptb_code_parm fixed bin (35) parm;
%skip(3);
/*
     Place the saved away title lines onto the page. Lay down a title line
     and mark the template map. Repeat while we have more title lines. Set
     the title block length, current line on page, and remaining lines on
     page.
*/
%skip(1);
	ptb_code_parm = 0;
	title_block_ip = format_report_info.title_block_info_ptr;
	ftb_current_line_number = status.current_line_on_page;
%skip(1);
	do ftb_loop = 1 to title_block_info.number_of_lines;
	     if ftb_current_line_number > template_map_number_of_bits
	     then do;
		ptb_code_parm = PAGE_OVERFLOW_ERROR_CODE;
		return;
	     end;
	     page_defined_as_lines (ftb_current_line_number) = title_block_info.lines (ftb_loop);
	     template_map (ftb_current_line_number) = ON;
	     ftb_current_line_number = ftb_current_line_number + 1;
	end;
%skip(1);
	formatted_page_info.title_block_length = title_block_info.number_of_lines;
	status.current_line_on_page = status.current_line_on_page + title_block_info.number_of_lines;
	status.remaining_lines_on_page = template_map_number_of_bits - status.current_line_on_page + 1;
%skip(1);
	return;
%skip(1);
     end place_title_block;
%skip(3);
     end format_title_block;
%page;
format_subtotals: proc (

	fst_subtotal_info_ptr_parm,		 /* input: ptr to subtotal_info structure */
	fst_subtotal_columns_info_ptr_parm,	 /* input: ptr to subtotal_columns_info structure */
	fst_subtotal_generation_info_ptr_parm,	 /* input: ptr to subtotal_generation_info structure */
	fst_caller_parm,			 /* input: "row subtotal" or "row subcount" */
	fst_number_of_lines_used_parm,	 /* output: how many lines the block used */
	fst_subtotals_ejection_in_progress_parm, /* output: on when ejection starts, off after ejection complete */
	fst_code_parm			 /* output: success or failure */
		   );
%skip(1);
dcl fst_caller_parm char (*) varying;
dcl fst_code_parm fixed bin (35) parm;
dcl fst_number_of_lines_used fixed bin;
dcl fst_number_of_lines_used_parm fixed bin;
dcl fst_some_column_changed bit (1) aligned;
dcl 1 fst_subtotal_columns_info like subtotal_columns_info based (fst_subtotal_columns_info_ptr_parm);
dcl fst_subtotal_columns_info_ptr_parm ptr parm;
dcl 1 fst_subtotal_generation_info like subtotal_generation_info based (fst_subtotal_generation_info_ptr_parm);
dcl fst_subtotal_generation_info_ptr_parm ptr parm;
dcl 1 fst_subtotal_info like subtotal_info based (fst_subtotal_info_ptr_parm);
dcl fst_subtotal_info_ptr_parm ptr parm;
dcl fst_subtotals_ejection_in_progress_parm bit (1) aligned parm;
dcl fst_subtotals_have_been_backed_up bit (1) aligned;
dcl fst_total_lines_used fixed bin;
%skip(1);
/*
     Walk through the subtotals level by level. Check the watch columns to see
     if any at the current level have changed. If any have, then back up the
     subtotals if they haven't been backed up already. Generate subtotals 
     whose watch columns have changed, returning to caller if they don't fit.
     Set our number of lines used parm and return to caller.
*/
%skip(1);
	fst_code_parm = 0;
	fst_number_of_lines_used_parm = 0;
	fst_total_lines_used = 0;
	fst_subtotals_have_been_backed_up = OFF;
%skip(1);
	do fst_subtotal_info.current_level = 1 to fst_subtotal_info.highest_level;
	     call check_for_subtotal_break (fst_subtotal_info_ptr_parm, fst_subtotal_columns_info_ptr_parm,
		fst_subtotal_info.current_level, fst_some_column_changed);
	     if fst_some_column_changed
	     then do;
		if ^fst_subtotals_have_been_backed_up
		then call make_backup_of_subtotals;
		fst_subtotals_have_been_backed_up = ON;
		call generate_subtotals (fst_subtotal_info.current_level,
		     fst_number_of_lines_used, fst_code_parm);
		if fst_code_parm ^= 0
		then return;
		fst_total_lines_used = fst_total_lines_used + fst_number_of_lines_used;
	     end;
	end;
%skip(1);
	fst_number_of_lines_used_parm = fst_total_lines_used;
	fst_subtotals_ejection_in_progress_parm = OFF;
%skip(1);
	return;
%page;
generate_subtotals: proc (

	gs_level_number_parm,	/* input: current subtotal level number */
	gs_number_of_lines_used_parm,	/* output: number of lines used */
	gs_code_parm		/* output: success or failure */
		     );
%skip(1);
dcl gs_code_parm fixed bin (35) parm;
dcl gs_level_number_parm fixed bin;
dcl gs_loop fixed bin;
dcl gs_number_of_lines_used_parm fixed bin parm;
%skip(3);
/*
     Use the headers temp seg for temporary storage. Walk through all of the
     subtotals. For each one at the current level number that isn't being
     outlined, format the float dec (59) into character format. Then format
     the row. Walk through all of the subtotals again, and for each one at
     the current level, restore it's editing flag to what it used to be and
     zero any reset subtotals.
*/
%skip(1);
	headers_next_byte = format_report_info.headers_next_available_byte;
	fst_subtotals_ejection_in_progress_parm = ON;
%skip(1);
	do gs_loop = 1 to fst_subtotal_info.number_of_columns_to_subtotal;
	     if gs_level_number_parm = fst_subtotal_info.columns (gs_loop).level
	     then do;
		column_ip = addr (fst_subtotal_columns_info.columns
		     (input_columns_info.columns (fst_subtotal_info.columns (gs_loop).input_column).output_column));
		if ^column_info.flags.outline
		then call format_total_or_subtotal_into_character_format (
		     fst_subtotal_info.columns.subtotal (gs_loop), fst_subtotal_info.columns.ioa_string (gs_loop));
	     end;
	end;
%skip(1);
	call format_row (fst_caller_parm, fst_subtotal_columns_info_ptr_parm,
	     row_value_template_ip, GENERATE_ONE_BLANK_LINE_TRAILER,
	     status.current_line_on_page, status.remaining_lines_on_page,
	     gs_number_of_lines_used_parm, gs_code_parm);
%skip(1);
	if gs_code_parm = 0
	then status.flags.detail_block_used_some_lines = ON;
%page;
	do gs_loop = 1 to fst_subtotal_info.number_of_columns_to_subtotal;
	     if gs_level_number_parm = fst_subtotal_info.columns (gs_loop).level
	     then do;
		column_ip = addr (fst_subtotal_columns_info.columns (input_columns_info.columns (
		     fst_subtotal_info.columns (gs_loop).input_column).output_column));
		column_info.flags.editing = column_info.flags.restore_editing;
		if ^column_info.flags.outline & fst_subtotal_info.columns (gs_loop).flags.reset
		then fst_subtotal_info.columns (gs_loop).subtotal = 0;
	     end;
	end;
%skip(1);
	return;
%skip(1);
     end generate_subtotals;
%page;
make_backup_of_subtotals: proc;
%skip(1);
dcl mbos_loop fixed bin;
%skip(3);
/*
     Advance the current generation block in our circular table. Backup each subtotal.
*/
%skip(1);
	fst_subtotal_generation_info.current_generation_block
	     = mod (fst_subtotal_generation_info.current_generation_block + 1, 
	     fst_subtotal_generation_info.maximum_number_of_generation_blocks);
%skip(1);
	do mbos_loop = 1 to fst_subtotal_generation_info.number_of_subtotals;
	     fst_subtotal_generation_info.generations
		(fst_subtotal_generation_info.current_generation_block).subtotals (mbos_loop)
		= fst_subtotal_info.columns (mbos_loop).subtotal;
	end;
%skip(1);
	return;
%skip(1);
     end make_backup_of_subtotals;
%skip(1);
     end format_subtotals;
%page;
format_total_or_subtotal_into_character_format: proc (

	ftosicf_subtotal_or_total_parm, /* input: the total or subtotal */
	ftosicf_ioa_string_parm	  /* input: ioa_ string for editing */
					   );
%skip(1);
dcl ftosicf_ioa_string_parm char (*) varying parm;
dcl ftosicf_length_doesnt_matter fixed bin (21);
dcl ftosicf_subtotal_or_total_parm float dec (59) parm;
%skip(3);
/*
     If the subtotal has an editing request then it's already been edited
     through it's parent column's editing request be the column_value request.
     Pick it up, or in the case of ones that don't have an editing request,
     edit them through ioa_ with the supplied string. Set the pointer and
     length to this result string, and stash the result string into the headers
     temp seg. Advance the next byte index, save the editing bit value, and 
     turn on the editing bit for this column.
*/
%skip(1);
	if column_info.flags.editing
	then do;
	     editing_string_rl = column_info.editing_string_length;
	     editing_string_rp = column_info.editing_string_ptr;
	     input_string = editing_string_result;
	     call evaluate_active_string (input_string, output_string);
	end;
	else call ioa_$rsnnl (ftosicf_ioa_string_parm, output_string,
	     ftosicf_length_doesnt_matter, ftosicf_subtotal_or_total_parm);
%skip(1);
	column_info.editing_string_result_length = length (output_string);
	column_info.editing_string_result_ptr
	     = addr (headers_temp_seg_as_an_array (headers_next_byte));
	substr (headers_temp_seg, headers_next_byte,
	     column_info.editing_string_result_length) = output_string;
	headers_next_byte = headers_next_byte + column_info.editing_string_result_length;
	column_info.flags.restore_editing = column_info.flags.editing;
	column_info.flags.editing = ON;
%skip(1);
	return;
%skip(1);
     end format_total_or_subtotal_into_character_format;
%page;
format_totals: proc (

	ft_total_info_ptr_parm,	       /* input: ptr to total_info structure */
	ft_total_columns_info_ptr_parm,      /* input: ptr to total_columns_info structure */
	ft_caller_parm,		       /* input: "row total" or "row count" */
	ft_number_of_lines_used_parm,	       /* output: number of lines used */
	ft_totals_ejection_in_progress_parm, /* output: on when ejection starts, off after ejection complete */
	ft_code_parm		       /* output: success or failure */
		);
%skip(1);
dcl ft_caller_parm char (*) varying parm;
dcl ft_code_parm fixed bin (35) parm;
dcl ft_loop fixed bin;
dcl ft_number_of_lines_used_parm fixed bin parm;
dcl 1 ft_total_columns_info like total_columns_info based (ft_total_columns_info_ptr_parm);
dcl ft_total_columns_info_ptr_parm ptr parm;
dcl 1 ft_total_info like total_info based (ft_total_info_ptr_parm);
dcl ft_total_info_ptr_parm ptr parm;
dcl ft_totals_ejection_in_progress_parm bit (1) aligned parm;
%skip(3);
/*
     Use the headers temp segment for temporary storage. For each total reach
     into the total_info array picking up the index to it's input column,
     which gives us the index into the input_columns_info array to pick up
     the index for the total_columns_info output column. Set the prefix to
     "=", turn off the outline bit, and format the total into character format.
     Then format the row and restore the editing bit for the columns.
*/
%skip(1);
	ft_code_parm = 0;
	ft_number_of_lines_used_parm = 0;
	ft_totals_ejection_in_progress_parm = ON;
%skip(1);
	headers_next_byte = format_report_info.headers_next_available_byte;
%skip(1);
	do ft_loop = 1 to ft_total_info.number_of_columns_to_total;
	     column_ip = addr (ft_total_columns_info.columns (input_columns_info.columns.output_column
		(ft_total_info.columns.input_column (ft_loop))));
	     column_info.prefix_character = "=";
	     column_info.flags.outline = OFF;
	     call format_total_or_subtotal_into_character_format (
		ft_total_info.columns.total (ft_loop), ft_total_info.columns.ioa_string (ft_loop));
	end;
%skip(1);
	call format_row (ft_caller_parm, ft_total_columns_info_ptr_parm,
	     row_value_template_ip, GENERATE_ZERO_BLANK_LINES_TRAILER,
	     status.current_line_on_page, status.remaining_lines_on_page,
	     ft_number_of_lines_used_parm, ft_code_parm);
%page;
	if ft_code_parm = 0
	then status.flags.detail_block_used_some_lines = ON;
%skip(1);
	do ft_loop = 1 to ft_total_columns_info.number_of_columns;
	     ft_total_columns_info.columns (ft_loop).flags.editing
		= ft_total_columns_info.columns (ft_loop).flags.restore_editing;
	end;
%skip(1);
	ft_totals_ejection_in_progress_parm = OFF;
%skip(1);
	return;
%skip(1);
     end format_totals;
%page;
gather_counts: proc;
%skip(1);
dcl gc_loop fixed bin;
%skip(3);
/*
     If the row hasn't been processed before then add one to the count.
*/
%skip(1);
	if status.flags.row_has_been_processed_before
	then return;
%skip(1);
	do gc_loop = 1 to count_info.number_of_columns_to_total;
	     count_info.columns (gc_loop).total
		= count_info.columns (gc_loop).total + 1;
	end;
%skip(1);
	return;
%skip(1);
     end gather_counts;
%page;
gather_subcounts: proc;
%skip(1);
dcl gs_loop fixed bin;
%skip(3);
/*
     Add one to the subcount.
*/
%skip(1);
	do gs_loop = 1 to subcount_info.number_of_columns_to_subtotal;
	     subcount_info.columns.subtotal (gs_loop)
		= subcount_info.columns.subtotal (gs_loop) + 1;
	end;
%skip(1);
	return;
%skip(1);
     end gather_subcounts;
%page;
gather_subtotals: proc;
%skip(1);
dcl gs_loop fixed bin;
%skip(3);
/*
     Add in the value of the current column to the subtotal.
*/
%skip(1);
	do gs_loop = 1 to subtotal_info.number_of_columns_to_subtotal;
	     subtotal_info.columns (gs_loop).subtotal
		= subtotal_info.columns (gs_loop).subtotal
		+ float (substr (current_row_value,
		table_info.columns.column_index (subtotal_info.columns.input_column (gs_loop)),
		table_info.columns.column_length (subtotal_info.columns.input_column (gs_loop))));
	end;
%skip(1);
	return;
%skip(1);
     end gather_subtotals;
%page;
gather_totals: proc;
%skip(1);
dcl gt_loop fixed bin;
%skip(3);
/*
     If the row hasn't been processed before then add the current column's
     value into the total.
*/
%skip(1);
	if status.flags.row_has_been_processed_before
	then return;
%skip(1);
	do gt_loop = 1 to total_info.number_of_columns_to_total;
	     total_info.columns (gt_loop).total
		= total_info.columns (gt_loop).total
		+ float (substr (current_row_value,
		table_info.columns.column_index (total_info.columns.input_column (gt_loop)),
		table_info.columns.column_length (total_info.columns.input_column (gt_loop))));
	end;
%skip(1);
	return;
%skip(1);
     end gather_totals;
%page;
housekeeping: proc;
%skip(3);
/*
     Move everything we need into automatic variables.
*/
%skip(1);
          sci_ptr = report_control_info.subsystem_control_info_ptr;
	maximum_segment_size = sys_info$max_seg_size * 4;
%skip(1);
	work_area_ptr = report_control_info.report_work_area_ptr;
	temp_seg_ptr = report_control_info.report_temp_seg_ptr;
%skip(1);
	format_report_ip = report_control_info.format_report_info_ptr;
	table_ip = format_report_info.table_info_ptr;
	table_control_ip = report_control_info.table_control_info_ptr;
	table_segments_ip = table_control_info.table_segments_info_ptr;
%skip(1);
	input_columns_ip = format_report_info.input_columns_info_ptr;
	input_columns_op = format_report_info.input_columns_order_ptr;
	output_columns_ip = format_report_info.output_columns_info_ptr;
%skip(1);
	input_string_ptr = report_control_info.input_string_temp_seg_ptr;
	input_string_length = maximum_segment_size - 4;
	input_string = "";
	input_string_non_varying_ptr = addrel (input_string_ptr, 1);
	input_string_non_varying_length = 0;
%skip(1);
	output_string_ptr = report_control_info.output_string_temp_seg_ptr;
	output_string_length = maximum_segment_size - 4;
	output_string = "";
	output_string_non_varying_ptr = addrel (output_string_ptr, 1);
	output_string_non_varying_length = output_string_length;
%skip(1);
	editing_strings_tsp = report_control_info.editing_strings_temp_seg_ptr;
	headers_tsp = report_control_info.headers_temp_seg_ptr;
%skip(1);
	group_ip = format_report_info.group_info_ptr;
	outline_ip = format_report_info.outline_info_ptr;
	page_break_ip = format_report_info.page_break_info_ptr;
%skip(1);
	if format_report_info.flags.subtotal_is_defined
	then do;
	     subtotal_ip = format_report_info.subtotal_info_ptr;
	     subtotal_columns_ip = subtotal_info.columns_info_ptr;
	     subtotal_generation_ip = subtotal_info.subtotal_generation_info_ptr;
	end;
%page;
	if format_report_info.flags.subcount_is_defined
	then do;
	     subcount_ip = format_report_info.subcount_info_ptr;
	     subcount_columns_ip = subcount_info.columns_info_ptr;
	     subcount_generation_ip = subcount_info.subtotal_generation_info_ptr;
	end;
%skip(1);
	if format_report_info.flags.total_is_defined
	then do;
	     total_ip = format_report_info.total_info_ptr;
	     total_columns_ip = total_info.columns_info_ptr;
	end;
%skip(1);
	if format_report_info.flags.count_is_defined
	then do;
	     count_ip = format_report_info.count_info_ptr;
	     count_columns_ip = count_info.columns_info_ptr;
	end;
%skip(1);
	format_document_options_ptr = format_report_info.format_document_op;
%skip(1);
	paginated_report = report_control_info.report_is_paginated;
	page_ip = format_report_info.copy_of_page_info_ptr;
	page_info = format_report_info.page_info_ptr -> page_info;
	page_info.page_overstrike_info_ptr = null ();
	page_overstrike_ip = format_report_info.overstrike_info_ptr;
%skip(1);
	formatted_page_ip = format_report_info.formatted_page_info_ptr;
	row_value_template_ip = format_report_info.row_value_template_info_ptr;
	template_length = page_info.width;
	generic_template_length = template_length;
	generic_tp = format_report_info.generic_template_ptr;
%skip(1);
	template_map_number_of_bits = page_info.length;
	template_mp = format_report_info.template_map_ptr;
%skip(1);
	truncation_indicator_length = length (format_report_info.truncation_indicator);
	status_pointer = format_report_info.status_ptr;
%skip(1);
          code = 0;
%skip(1);
          return;
%skip(1);
     end housekeeping;
%page;
make_ptr: proc (mp_row_number_parm) returns (ptr);
%skip(1);
dcl mp_row_number_parm fixed bin (35) parm;
dcl mp_segment_ptr_index fixed bin (21);
dcl mp_row_ptr_index fixed bin (21);
%skip(3);
/*
     Make an index for the segment that the row pointer lives in. Make an
     index for the row pointer within the segment. Make a pointer to the
     segment. Return the pointer for the row.
*/
%skip(1);
	mp_segment_ptr_index = divide (mp_row_number_parm,
	     table_segments_info.maximum_number_of_ptrs_per_segment, 21);
	if mod (mp_row_number_parm, table_segments_info.maximum_number_of_ptrs_per_segment) ^= 0
	then mp_segment_ptr_index = mp_segment_ptr_index + 1;
%skip(1);
	mp_row_ptr_index = mod (mp_row_number_parm, table_segments_info.maximum_number_of_ptrs_per_segment);
	if mp_row_ptr_index = 0
	then mp_row_ptr_index = table_segments_info.maximum_number_of_ptrs_per_segment;
%skip(1);
	row_ptrs_ptr = table_segments_info.segment_ptrs (mp_segment_ptr_index);
%skip(1);
	return (row_ptrs.row_value_ptr (mp_row_ptr_index));
%skip(1);
     end make_ptr;
%page;
make_rows_available: proc;
%skip(3);
dcl mra_code fixed bin (35);
dcl mra_number_of_rows_needed fixed bin (35);
dcl mra_number_of_rows_retrieved fixed bin (35);
%skip(1);
/*
     If the table is full, or we have enough rows to do this page then return.
     Have the rows loaded and time the operation, removing this time from our
     formatting time so the timers are accurate. Bump the number of rows 
     retrieved and check for end of file on the data base setting appropriate
     flags. Shut things down if anything went wrong.
*/
%skip(1);
	if report_control_info.flags.table_is_full
	then return;
%skip(1);
	mra_number_of_rows_needed = page_info.length + 1;
	if report_control_info.no_of_rows_retrieved - status.current_row_number > mra_number_of_rows_needed
	then return;
%skip(1);
	time1 = vclock;
	call rw_table_manager$load_rows (report_cip,
	     mra_number_of_rows_needed, mra_number_of_rows_retrieved, mra_code);
	time2 = vclock;
	report_control_info.table_loading_time
	     = report_control_info.table_loading_time + (time2 - time1);
	report_control_info.report_formatting_time
	     = report_control_info.report_formatting_time - (time2 - time1);
%skip(1);
	if mra_number_of_rows_retrieved ^= 0
	then report_control_info.no_of_rows_retrieved
	     = report_control_info.no_of_rows_retrieved + mra_number_of_rows_retrieved;
	if mra_code ^= 0
	then if mra_code = error_table_$end_of_info
	     then do;
		report_control_info.flags.table_is_full = ON;
		report_control_info.flags.table_has_just_been_loaded = ON;
		if status.current_row_number = report_control_info.no_of_rows_retrieved
		then status.flags.last_row_of_report = ON;
	     end;
	     else call ssu_$abort_line (sci_ptr, mra_code,
		"While trying to retrieve ^d rows.", mra_number_of_rows_needed);
	else;
%skip(1);
	return;
%skip(1);
     end make_rows_available;
%page;
make_row_ptrs: proc;
%skip(3);
/*
     Make pointers to the previous, current and next rows.
*/
%skip(1);
	status.previous_row_ptr = status.current_row_ptr;
%skip(1);
	status.current_row_ptr = status.next_row_ptr;
	if status.current_row_ptr = null ()
	then status.current_row_ptr = make_ptr (status.current_row_number);
%skip(1);
	if status.flags.last_row_of_report
	then status.next_row_ptr = null ();
	else status.next_row_ptr = make_ptr (status.current_row_number + 1);
%skip(1);
	return;
%skip(1);
     end make_row_ptrs;
%page;
save_copy_of_page: proc;
%skip(3);
dcl scop_code fixed bin (35);
dcl scop_record_key char (256) varying;
dcl scop_record_length fixed bin (21);
dcl scop_record_number fixed bin (21);
%skip(1);
/*
     Use the page or buffer number as the key for the record. Save a copy
     of the formatted page. Append ".page_info" to the page number and save the
     page_info structure under that key. Append ".formatted_page_info" to
     the page number and save the formatted_page_info structure under that
     key. If the page contains overstrikes then append ".page_overstrike_info"
     to the page number and save the page_overstrike_info structure under
     that key.
*/
%skip(1);
	scop_record_number = report_control_info.no_of_formatted_pages;
	scop_record_key = ltrim (convert (scop_record_key, scop_record_number));
	call iox_$seek_key (format_report_info.report_iocb_ptr,
	     scop_record_key, scop_record_length, scop_code);
	if scop_code ^= error_table_$no_record
	then call ssu_$abort_line (sci_ptr, scop_code,
	     "Logic error while trying to save a copy of page ^a.", scop_record_key);
%skip(1);
	call iox_$write_record (format_report_info.report_iocb_ptr,
	     page_info.page_ptr, page_info.total_characters, scop_code);
	if scop_code ^= 0
	then call ssu_$abort_line (sci_ptr, scop_code,
	     "Unable to save a copy of page ^d.", scop_record_key);
%skip(1);
	scop_record_key = scop_record_key || ".page_info";
	call iox_$seek_key (format_report_info.report_iocb_ptr,
	     scop_record_key, scop_record_length, scop_code);
	if scop_code ^= error_table_$no_record
	then call ssu_$abort_line (sci_ptr, scop_code,
	     "Logic error while trying to save a copy of page ^a.", scop_record_key);
%skip(1);
	call iox_$write_record (format_report_info.report_iocb_ptr,
	     page_ip, page_info.page_info_size * 4, scop_code);
	if scop_code ^= 0
	then call ssu_$abort_line (sci_ptr, scop_code,
	     "Unable to save a copy of page ^d.", scop_record_key);
%page;
	scop_record_key = before (scop_record_key, ".") || ".formatted_page_info";
	call iox_$seek_key (format_report_info.report_iocb_ptr,
	     scop_record_key, scop_record_length, scop_code);
	if scop_code ^= error_table_$no_record
	then call ssu_$abort_line (sci_ptr, scop_code,
	     "Logic error while trying to save a copy of page ^a.", scop_record_key);
%skip(1);
	call iox_$write_record (format_report_info.report_iocb_ptr,
	     formatted_page_ip, currentsize (formatted_page_info) * 4, scop_code);
	if scop_code ^= 0
	then call ssu_$abort_line (sci_ptr, scop_code,
	     "Unable to save a copy of page ^d.", scop_record_key);
%skip(1);
	if page_info.page_overstrike_info_ptr = null ()
	then return;
%skip(1);
	scop_record_key = before (scop_record_key, ".") || ".page_overstrike_info";
	call iox_$seek_key (format_report_info.report_iocb_ptr,
	     scop_record_key, scop_record_length, scop_code);
	if scop_code ^= error_table_$no_record
	then call ssu_$abort_line (sci_ptr, scop_code,
	     "Logic error while trying to save a copy of page ^a.", scop_record_key);
%skip(1);
	call iox_$write_record (format_report_info.report_iocb_ptr,
	     page_overstrike_ip, currentsize (page_overstrike_info) * 4, scop_code);
	if scop_code ^= 0
	then call ssu_$abort_line (sci_ptr, scop_code,
	     "Unable to save a copy of page ^d.", scop_record_key);
%skip(1);
	return;
%skip(1);
     end save_copy_of_page;
%page;
setup_for_a_page: proc;	
%skip(3);
/*
     Set all of the info needed to begin a new page.
*/
%skip(1);
	page_ip = format_report_info.copy_of_page_info_ptr;
	page_info = format_report_info.page_info_ptr -> page_info;
	page_info.page_overstrike_info_ptr = null ();
	page_overstrike_ip = format_report_info.overstrike_info_ptr;
%skip(1);
	formatted_page_info.page_header_length = 0;
	formatted_page_info.title_block_length = 0;
	formatted_page_info.page_footer_length = 0;
	formatted_page_info.number_of_detail_blocks = 0;
	unspec (formatted_page_info.detail_blocks) = OFF;
%skip(1);
	template_map (*) = OFF;
%skip(1);
	if format_report_info.number_of_formatted_rows = 0
	then status.flags.first_row_of_report = ON;
	else status.flags.first_row_of_report = OFF;
	status.current_row_number = format_report_info.number_of_formatted_rows + 1;
	if report_control_info.flags.table_is_full
	& report_control_info.no_of_rows_retrieved = status.current_row_number
	then status.flags.last_row_of_report = ON;
	else status.flags.last_row_of_report = OFF;
	status.flags.first_row_on_page = ON;
	status.flags.page_overflow = OFF;
	status.flags.subtotals_ejection_in_progress = OFF;
	status.flags.totals_ejection_in_progress = OFF;
	status.flags.header_being_evaluated = OFF;
	status.flags.detail_block_used_some_lines = ON;
%skip(1);
	status.total_number_of_rows_used = 0;
	if paginated_report
	then status.current_page_number = report_control_info.no_of_formatted_pages + 1;
	else status.current_page_number = 1;
	status.current_line_on_page = 1;
	status.remaining_lines_on_page = page_info.length;
	if status.current_row_number ^> status.highest_row_formatted
	then status.flags.row_has_been_processed_before = ON;
	else status.flags.row_has_been_processed_before = OFF;
%skip(1);
	return;
%skip(1);
     end setup_for_a_page;
%page;
sub_error_handler: proc;
%skip(1);
dcl seh_code fixed bin (35);
%skip(3);
/*
     Find the sub_error_info structure and if it wasn't format_document_ that
     signalled it then continue to signal. Set the ptr to the 
     format_document_error structure and print the error message with added
     information to identify where in the report the error occured.
*/
%skip(1);
	condition_info_ptr = addr (local_condition_info);
	condition_info.version = condition_info_version_1;
	call find_condition_info_ (null (), condition_info_ptr, seh_code);
	if seh_code ^= 0
	then call ssu_$abort_line (sci_ptr, seh_code);
	sub_error_info_ptr = condition_info.info_ptr;
	if sub_error_info.name ^= "format_document_"
	then do;
	     call continue_to_signal_ (seh_code);
	     return;
	end;
%skip(1);
	format_document_error_ptr = sub_error_info.info_ptr;
	if status.flags.header_being_evaluated
	then call ssu_$print_message (sci_ptr, rw_error_$bad_report_format,
	     "^/Page ^d, ^a (line ^d, ^a).^/^a^x""^a""",
	     status.current_page_number, status.object_being_evaluated,
	     status.current_header_line, HEADER_PARTS_LABELS (status.current_header_part),
	     sub_error_info.header.info_string, format_document_error.text_line);
	else call ssu_$print_message (sci_ptr, rw_error_$bad_report_format,
	     "^/Page ^d, ^a (row ^d, ^a column).^/^a^x""^a""",
	     status.current_page_number, status.object_being_evaluated, status.current_row_number,
	     table_info.columns.column_name (output_columns_info.columns.input_column (status.current_column_number)),
	     sub_error_info.header.info_string, format_document_error.text_line);
%skip(1);
	return;
%skip(1);
     end sub_error_handler;
%page;
dcl BACKSPACE char (1) static int options (constant) init ("");
dcl BACKSPACE_OR_VERTICAL_TAB_OR_HORIZONTAL_TAB_OR_NL char (4) static int options (constant) init ("	
");
dcl BAR char (1) static int options (constant) init ("|");
dcl BAR_BAR char (2) static int options (constant) init ("||");
dcl BLANK char (1) static int options (constant) init (" ");
dcl FILL bit (1) unaligned static int options (constant) init ("1"b);
dcl FORM_FEED char (1) static int options (constant) init ("");
dcl GENERATE_ONE_BLANK_LINE_TRAILER fixed bin static int options (constant) init (1);
dcl GENERATE_ZERO_BLANK_LINES_TRAILER fixed bin static int options (constant) init (0);
dcl GROUP_FOOTER char (16) varying static int options (constant) init ("group footer");
dcl GROUP_HEADER char (16) varying static int options (constant) init ("group header");
dcl HEADER_PARTS_LABELS (3) char (11) varying static int options (constant) init
("left part", "center part", "right part");
dcl LEFT_BRACKET char (1) static int options (constant) init ("[");
dcl LEFT_OR_RIGHT_BRACKET char (2) static int options (constant) init ("[]");
dcl LOOK_AHEAD bit (1) aligned static int options (constant) init ("1"b);
dcl LOOK_BEHIND bit (1) aligned static int options (constant) init ("0"b);
dcl NEWLINE char (1) static int options (constant) init ("
");
dcl OFF bit (1) aligned int static options (constant) init ("0"b);
dcl ON bit (1) aligned int static options (constant) init ("1"b);
dcl PAGE_FOOTER char (16) varying static int options (constant) init ("page footer");
dcl PAGE_HEADER char (16) varying static int options (constant) init ("page header");
dcl PAGE_OVERFLOW_ERROR_CODE fixed bin (35) static int options (constant) init (1);
dcl ROW_COUNT char (16) varying static int options (constant) init ("row count");
dcl ROW_FOOTER char (16) varying static int options (constant) init ("row footer");
dcl ROW_HEADER char (16) varying static int options (constant) init ("row header");
dcl ROW_SUBCOUNT char (16) varying static int options (constant) init ("row subcount");
dcl ROW_SUBTOTAL char (16) varying static int options (constant) init ("row subtotal");
dcl ROW_TITLES char (16) varying static int options (constant) init ("row titles");
dcl ROW_TOTAL char (16) varying static int options (constant) init ("row total");
dcl ROW_VALUE char (16) varying static int options (constant) init ("row value");
%page;
dcl addr builtin;
dcl addrel builtin;
%skip(1);
dcl before builtin;
%skip(1);
dcl code fixed bin (35);
dcl copy builtin;
dcl continue_to_signal_ entry (fixed bin(35));
dcl convert builtin;
dcl currentsize builtin;
%skip(1);
dcl divide builtin;
%skip(1);
dcl eas_spare_string char (MAXIMUM_OPTION_VALUE_LENGTH) varying;
dcl error_table_$badcall fixed bin(35) ext static;
dcl error_table_$end_of_info fixed bin(35) ext static;
dcl error_table_$no_record fixed bin(35) ext static;
dcl error_table_$recoverable_error fixed bin(35) ext static;
dcl error_table_$unbalanced_brackets fixed bin(35) ext static;
%skip(1);
dcl fc_spare_string char (MAXIMUM_OPTION_VALUE_LENGTH) varying;
dcl find_condition_info_ entry (ptr, ptr, fixed bin(35));
dcl first_time_through_the_detail_block_loop bit (1) aligned;
dcl float builtin;
dcl format_document_$string entry (char(*), char(*), fixed bin(21), ptr, fixed bin(35));
dcl fr_spare_string char (MAXIMUM_OPTION_VALUE_LENGTH) varying;
%skip(1);
dcl index builtin;
dcl input_string char (input_string_length) varying based (input_string_ptr);
dcl input_string_length fixed bin (21);
dcl input_string_ptr ptr;
dcl input_string_non_varying char (input_string_non_varying_length) based (input_string_non_varying_ptr);
dcl input_string_non_varying_length fixed bin (21);
dcl input_string_non_varying_ptr ptr;
dcl ioa_$rsnnl entry() options(variable);
dcl iox_$write_record entry (ptr, ptr, fixed bin(21), fixed bin(35));
dcl iox_$seek_key entry (ptr, char(256) var, fixed bin(21), fixed bin(35));
%skip(1);
dcl length builtin;
dcl 1 local_condition_info like condition_info;
dcl ltrim builtin;
%skip(1);
dcl min builtin;
dcl mod builtin;
%skip(1);
dcl null builtin;
%skip(1);
dcl output_string char (output_string_length) varying based (output_string_ptr);
dcl output_string_length fixed bin (21);
dcl output_string_ptr ptr;
dcl output_string_non_varying char (output_string_non_varying_length) based (output_string_non_varying_ptr);
dcl output_string_non_varying_length fixed bin (21);
dcl output_string_non_varying_ptr ptr;
dcl 1 output_string_redefined based (output_string_ptr),
      2 length_word fixed bin (35) aligned,
      2 frobus char (output_string_non_varying_length) unaligned;
%skip(1);
dcl paginated_report bit (1) aligned;
dcl pc_column_value char (MAXIMUM_OPTION_VALUE_LENGTH) varying;
%skip(1);
dcl rtrim builtin;
dcl rw_error_$bad_report_format fixed bin(35) ext static;
dcl rw_table_manager$load_rows entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35));
%skip(1);
dcl search builtin;
dcl sci_ptr ptr;
dcl ssu_$abort_line entry() options(variable);
dcl ssu_$evaluate_active_string entry (ptr, ptr, char(*), fixed bin, char(*) var, fixed bin(35));
dcl ssu_$print_message entry() options(variable);
dcl sub_error_ condition;
dcl substr builtin;
dcl sys_info$max_seg_size fixed bin(35) ext static;
%skip(1);
dcl temp_seg_ptr ptr;
dcl time1 float bin (63);
dcl time2 float bin (63);
dcl translate builtin;
dcl truncation_indicator_length fixed bin;
%skip(1);
dcl unspec builtin;
%skip(1);
dcl vclock builtin;
%skip(1);
dcl work_area area (sys_info$max_seg_size) based (work_area_ptr);
dcl work_area_ptr ptr;
%page;
%include arg_descriptor;
%page;
%include arg_list;
%page;
%include condition_info;
%page;
%include condition_info_header;
%page;
%include cp_active_string_types;
%page;
%include format_document_error;
%page;
%include format_document_options;
%page;
%include rw_options_extents;
%page;
%include rw_page_info;
%page;
%include rw_report_info;
%page;
%include rw_report_structures;
%page;
%include rw_table_info;
%page;
%include rw_table_control_info;
%page;
%include sub_error_info;
%skip(3);
     end rw_fr_build_page;
