/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   *********************************************************** */
/* format: off */
%skip(3);
/*   This is the subroutine called by the display request to implement the
     report writer display scrolling feature. Description and usage follows.

     Description:
     
     This module provides for the display of paginated and unpaginated
     reports through the video system. It also provides the function of
     setting a scroll function to a provided key sequence. This program
     operates in conjunction with rw_display_process_args (initial
     setup of the scroll_info structure) and rw_display (the caller of
     this subroutine).

     Usage:

     See the entrypoints for parameter descriptions.  The entrypoint set_fkey
     is called by rw_display_process_args to set any functions to key
     sequences provided on the request line when the display request is given.
     The start, continue, and stop entrypoints are called by the rw_display
     module for setup, scrolling, and termination respectively.

     Known Bugs:

     Other Problems:

     History:

     Written - Al Dupuis - August 1983
     Changed - Al Dupuis - October 1984 - Became report_writer_.

*/
%page;
rw_display_scroll: proc;
%skip(3);
	/* These parameters are described at each entry where they are used. */
%skip(1);
dcl code_parm fixed bin (35) parm;
dcl display_arg_results_ptr_parm ptr parm;
dcl function_name_parm char (*) parm;
dcl function_key_sequence_parm char (*) parm;
dcl rci_ptr_parm ptr parm;
dcl sci_ptr_parm ptr parm;
dcl scroll_info_ptr_parm ptr parm;
dcl work_area_ptr_parm ptr parm;
%skip(3);
RETURN_TO_CALLING_PROGRAM:
%skip(1);
	return;
%page;
continue: entry (

	scroll_info_ptr_parm,	/* input: ptr to the scroll_info structure */
	code_parm			/* output: success, failure, or user quit (error_table_$end_of_info) */
	 );
%skip(3);
/*

	Mainline Processing Overview

	(1) Perform initialization.

	(2) Display a portion of the current page or buffer. Signal 
	    display_buffer_empty if we cross a buffer boundary in the
	    middle of the display (unpaginated reports only).

	(3) Read a key sequence which tells us what to do next.

	(4) Perform the function the user has requested (e.g. forward).

	(5) Repeat 2 through 4 if we're still in the current page or buffer.
	    Return to caller if we're outside of it, or if we crossed a
	    buffer boundary during the display.

*/
%skip(3);
	scroll_ip = scroll_info_ptr_parm;
	code_parm = 0;
	call housekeeping;
	call scroll_the_report;
	code_parm = code;
%skip(1);
	return;
%page;
set_fkey: entry (

	scroll_info_ptr_parm,	/* input: ptr to the scroll_info strucure */
	function_name_parm,		/* input: function to set the key to */
	function_key_sequence_parm,	/* input: the key sequence */
	code_parm			/* output: success or failure */
	     );
%skip(3);
/*

	Mainline Processing Overview

	(1) Translate any mnemonic key sequences into the characters
	    the terminal generates ("escape-", "esc-", "control-" and
	    "ctl-" are translated).

	(2) Translate key sequences given as mnemonics into the characters
	    the terminal generates (i.e. translate "up_arrow" into whatever
	    the particular terminal generates when the up arrow is pressed).

	(3) Assign the translated key sequence to the table entry for that
	    particular function.

*/
%skip(3);
	scroll_ip = scroll_info_ptr_parm;
	function_key_data_ptr = scroll_info.function_key_data_pointer;
	function_name = function_name_parm;
	function_key_sequence = function_key_sequence_parm;
	call set_function_key (function_name, function_key_sequence, code);
	code_parm = code;
%skip(1);
	return;
%page;
start: entry (

	sci_ptr_parm,		/* input: ptr to the subsystem control info structure */
	rci_ptr_parm,		/* input: ptr to the report_control_info structure */
	display_arg_results_ptr_parm,	/* input: ptr to the display_arg_results structure */
	work_area_ptr_parm		/* input: ptr to a work area */
	  );
%skip(3);
/*

	Mainline Processing Overview

	(1) Allocate various structures needed for the video system.

	(2) Turn on the video system if it's not already on.

	(3) If window was specified by the user check it out to make sure it 
	    meets the requirements. If window wasn't  specified, then set
	    one up and shrink user_i/o.

	(4) Setup the format_document_options structure for filling of help
	    strings to the window width.

*/
%skip(3);
	sci_ptr = sci_ptr_parm;
	report_cip = rci_ptr_parm;
	display_results_ptr = display_arg_results_ptr_parm;
	work_area_ptr = work_area_ptr_parm;
	call setup_scroll;
%skip(1);
	return;
%page;
stop: entry (

	scroll_info_ptr_parm	/* input: ptr to the scroll_info structure */
	 );
%skip(3);
/*

	Mainline Processing Overview

	(1) If window wasn't specified by the user then destroy the
	    window we created and put back user_i/o to the same state
	    as we found it.

	(2) Turn off the video system if we turned it on.

*/
%skip(3);
	if scroll_info_ptr_parm = null ()
	then return;
	scroll_ip = scroll_info_ptr_parm;
	call housekeeping;
	call terminate_scroll;
%skip(1);
	return;
%page;
abort_line: proc (

	code_parm,	/* input: the code that caused the error */
	message_parm	/* input: additional information */
	       );
%skip(1);
dcl code_parm fixed bin (35) parm;
dcl message_parm_length fixed bin;
dcl message_parm char (*) parm;
%skip(3);
	if code_parm ^= 0
	then do;
	     call convert_status_code_ (code_parm, short_message, long_message);
	     error_message = "^/" || rtrim (long_message);
	end;
	else error_message = "";
%skip(1);
	message_parm_length = length (rtrim (message_parm));
	if message_parm_length > 0
	then error_message = error_message || "^/" || rtrim (message_parm);
%skip(1);
	call ssu_$abort_line (sci_ptr, rw_error_$bad_report_display, error_message);
%skip(1);
     end abort_line;
%page;
check_code: proc;
%skip(3);
/*

	It is only valid to call this proc if the entrypoint "continue" 
	was called. This proc takes care of the details of hiding the
	"window_status_pending" error code returned by any of the many,
	many different window_ entrypoints this subroutine calls. When this
	ugly error code is returned there is not enough information that
	can be gotten to do anything reasonable. For example, if we could
	determine from the video system where in the window the asyncronous
	output was written to, we could at least write around it or prompt
	the user to see if she has read it. But there isn't anything like
	that. Instead we get two bits, saying if there was asyncronous
	output or that the screen is invalid. This proc does a 
	get_window_status control order, returns to rw_display, who 
	immediately calls back here, resulting in a redisplay of the window.
	Invalid screens are the only thing we get in the default case, so 
	this is always the correct action. In the case of the experienced
	user who has set up her own windows, if she has missed a message
	through this redisplay she can see them again with the multics_mode
	function or set up her windows more intelligently next time.

*/
%skip(1);
	if code = 0
	then return;
%skip(1);
	if code = video_et_$window_status_pending
	then call iox_$control (window_iocb_ptr, "get_window_status",
	     window_status_info_ptr, code);
%skip(1);
	code_parm = code;
	goto RETURN_TO_CALLING_PROGRAM;
%skip(1);
     end check_code;
%page;
display_chunk_of_page: proc;
%skip(1);
dcl dcop_buffer_empty_pending bit (1) aligned;
dcl dcop_current_line_on_page fixed bin;
dcl dcop_current_line_on_screen fixed bin;
dcl dcop_number_of_chars_to_write fixed bin;
dcl dcop_loop fixed bin;
dcl dcop_loop_limit fixed bin;
dcl display_buffer_empty condition;
%skip(1);
	dcop_buffer_empty_pending = OFF;
	call window_$clear_window (window_iocb_ptr, code);
	call check_code;
%skip(1);
	/* Set the width so we don't exceed the portion of the page left or the window width. */
%skip(1);
	if page_info.width - 1 <= report_output_window_position_info.width
	then;
	else if scroll_info.left_vertical_position + report_output_window_position_info.width > page_info.width
	     then scroll_info.left_vertical_position = page_info.width - report_output_window_position_info.width;
	dcop_number_of_chars_to_write = min (page_info.width - scroll_info.left_vertical_position,
	     report_output_window_position_info.width);
%skip(1);
	/* target_line_number can be less than 1 or greater than the page length. Adjust accordingly. */
%skip(1);
	if scroll_info.target_line_number < 1
	then scroll_info.target_line_number = 1;
	else if report_control_info.flags.report_is_paginated
	     then if scroll_info.target_line_number > page_info.length
	          then scroll_info.target_line_number
	               = max (1, page_info.length - scroll_info.vertical_scroll_distance);
	          else;
	     else;
%skip(1);
	/* Simulate the line printer software's 3 blank lines if appropriate. */
%skip(1);
	if scroll_info.target_line_number = 1
	& (report_control_info.flags.report_is_paginated	| scroll_info.target_page_number = 1)
	then scroll_info.top_margin_offset = 3;
	else scroll_info.top_margin_offset = 0;
%skip(1);
	/* Set limits, prepare to hit a buffer boundary for unpaginated reports in the middle of the display. */
%skip(1);
	dcop_current_line_on_page = scroll_info.target_line_number;
	dcop_current_line_on_screen = scroll_info.top_margin_offset + 1;
	dcop_loop_limit = min (
	     report_output_window_position_info.height - dcop_current_line_on_screen + 1,
	     page_info.length - dcop_current_line_on_page + 1);
%skip(1);
	if ^report_control_info.flags.report_is_paginated
	then if (page_info.length - dcop_current_line_on_page + 1 
	     < report_output_window_position_info.height - dcop_current_line_on_screen + 1)
	     & (^report_control_info.flags.report_is_formatted
	     | (report_control_info.flags.report_is_formatted
	     & scroll_info.target_page_number ^= report_control_info.no_of_formatted_pages))
	     then do;
		dcop_loop_limit = report_output_window_position_info.height - dcop_current_line_on_screen + 1;
		dcop_buffer_empty_pending = ON;
	     end;
	     else;
	else;
%skip(1);
	/* Do the display, don't bother to write blank lines. */
%skip(1);
	do dcop_loop = 1 to dcop_loop_limit;
	     call window_$position_cursor (window_iocb_ptr, dcop_current_line_on_screen, 1, code);
	     call check_code;
	     if substr (page_defined_as_lines (dcop_current_line_on_page),
	     scroll_info.left_vertical_position, dcop_number_of_chars_to_write) = BLANK
	     then;
	     else do;
		call window_$overwrite_text (window_iocb_ptr,
		     substr (page_defined_as_lines (dcop_current_line_on_page),
		     scroll_info.left_vertical_position, dcop_number_of_chars_to_write), code);
		call check_code;
	     end;
	     dcop_current_line_on_screen = dcop_current_line_on_screen + 1;
	     dcop_current_line_on_page = dcop_current_line_on_page + 1;
	     if dcop_buffer_empty_pending
	     then if dcop_current_line_on_page > page_info.length
		then do;
		     scroll_info.target_page_number = scroll_info.target_page_number + 1;
		     scroll_info.last_line_number_in_previous_buffer = page_info.length;
		     signal display_buffer_empty;
		     scroll_info.flags.buffer_boundary_just_crossed = ON;
		     scroll_info.target_page_number = scroll_info.target_page_number - 1;
		     dcop_current_line_on_page = 1;
		     page_ip = scroll_info.page_info_pointer;
		end;
		else;
	     else;
	end;
%skip(1);
	/* Position cursor to bottom right hand side of window. */
%skip(1);
	call window_$position_cursor (window_iocb_ptr,
	     report_output_window_position_info.height,
	     report_output_window_position_info.width, code);
	call check_code;
%skip(1);
	return;
%skip(1);
     end display_chunk_of_page;
%page;
get_users_response: proc (gur_buffer_parm);
%skip(1);
dcl gur_buffer_parm char (*) parm;
dcl gur_character_read char (1) varying;
dcl gur_loop fixed bin;
dcl gur_partial_match bit (1) aligned;
%skip(1);
	/* Keep reading characters until we get a match, get a mis-match, or fill the buffer. */
%skip(1);
	gur_buffer_parm = "";
	gur_partial_match = ON;
%skip(1);
	do gur_loop = 1 to length (gur_buffer_parm)
	     while (gur_partial_match);
	     call window_$get_one_unechoed_char (window_iocb_ptr, gur_character_read, ON, code);
	     call check_code;
	     substr (gur_buffer_parm, gur_loop, 1) = gur_character_read;
	     if (gur_buffer_parm = scroll_info.keys.forward)
	     | (gur_buffer_parm = scroll_info.keys.backward)
	     | (gur_buffer_parm = scroll_info.keys.left)
	     | (gur_buffer_parm = scroll_info.keys.right)
	     | (gur_buffer_parm = scroll_info.keys.help)
	     | (gur_buffer_parm = scroll_info.keys.set_key)
	     | (gur_buffer_parm = scroll_info.keys.set_scroll_increment)
	     | (gur_buffer_parm = scroll_info.keys.quit)
	     | (gur_buffer_parm = scroll_info.keys.redisplay)
	     | (gur_buffer_parm = scroll_info.keys.start_of_report)
	     | (gur_buffer_parm = scroll_info.keys.end_of_report)
	     | (gur_buffer_parm = scroll_info.keys.multics_mode)
	     | (gur_buffer_parm = scroll_info.keys.goto)
	     then return;
	     gur_partial_match
		= (substr (gur_buffer_parm, 1, gur_loop) = substr (scroll_info.keys.forward, 1, gur_loop))
		| (substr (gur_buffer_parm, 1, gur_loop) = substr (scroll_info.keys.backward, 1, gur_loop))
		| (substr (gur_buffer_parm, 1, gur_loop) = substr (scroll_info.keys.left, 1, gur_loop))
		| (substr (gur_buffer_parm, 1, gur_loop) = substr (scroll_info.keys.right, 1, gur_loop))
		| (substr (gur_buffer_parm, 1, gur_loop) = substr (scroll_info.keys.help, 1, gur_loop))
		| (substr (gur_buffer_parm, 1, gur_loop) = substr (scroll_info.keys.set_key, 1, gur_loop))
		| (substr (gur_buffer_parm, 1, gur_loop) = substr (scroll_info.keys.set_scroll_increment, 1, gur_loop))
		| (substr (gur_buffer_parm, 1, gur_loop) = substr (scroll_info.keys.quit, 1, gur_loop))
		| (substr (gur_buffer_parm, 1, gur_loop) = substr (scroll_info.keys.redisplay, 1, gur_loop))
		| (substr (gur_buffer_parm, 1, gur_loop) = substr (scroll_info.keys.start_of_report, 1, gur_loop))
		| (substr (gur_buffer_parm, 1, gur_loop) = substr (scroll_info.keys.end_of_report, 1, gur_loop))
		| (substr (gur_buffer_parm, 1, gur_loop) = substr (scroll_info.keys.multics_mode, 1, gur_loop))
		| (substr (gur_buffer_parm, 1, gur_loop) = substr (scroll_info.keys.goto, 1, gur_loop));
	end;
%skip(1);
	return;
%skip(1);
     end get_users_response;
%page;
housekeeping: proc;
%skip(3);
	/* Move the pointers for our needed structures. */
%skip(1);
	display_results_ptr = scroll_info.display_arg_results_ptr;
	report_cip = scroll_info.report_control_info_ptr;
	work_area_ptr = scroll_info.area_ptr;
	user_io_window_position_ip = scroll_info.user_io_window_position_info_ptr;
	report_output_window_position_ip = scroll_info.report_output_window_position_info_ptr;
	sci_ptr = scroll_info.ssu_info_ptr;
	window_iocb_ptr = report_control_info.display_iocb_ptr;
	page_ip = scroll_info.page_info_pointer;
	window_status_info_ptr = scroll_info.window_status_info_pointer;
	function_key_data_ptr = scroll_info.function_key_data_pointer;
	format_document_options_ptr = scroll_info.format_document_op;
%skip(1);
	return;
%skip(1);
     end housekeeping;
%page;
prompt_for_more: proc (

	pfm_line_in_window_parm,	/* input: where to write the prompt */
	pfm_user_wants_more_parm	/* output: on if user wants more */
		  );
%skip(3);
dcl pfm_break_character char (1) varying;
dcl pfm_buffer char (1);
dcl pfm_line_in_window_parm fixed bin parm;
dcl pfm_number_of_chars_read fixed bin (21);
dcl pfm_still_looking_for_a_valid_response bit (1) aligned;
dcl pfm_user_wants_more_parm bit (1) aligned parm;
%skip(1);
	/* Write the more prompt on caller designated line. Accept CR and DEL and mark parm accordingly. */
%skip(1);
	pfm_still_looking_for_a_valid_response = ON;
%skip(1);
	do while (pfm_still_looking_for_a_valid_response);
	     pfm_still_looking_for_a_valid_response = OFF;
	     call window_$position_cursor (window_iocb_ptr, pfm_line_in_window_parm, 1, code);
	     call check_code;
	     call window_$clear_to_end_of_line (window_iocb_ptr, code);
	     call check_code;
	     call window_$write_sync_read (window_iocb_ptr, MORE_PROMPT, 1,
		pfm_buffer, pfm_number_of_chars_read, pfm_break_character, code);
	     call check_code;
	     if pfm_number_of_chars_read = 0
	     then if pfm_break_character = CARRIAGE_RETURN
		then pfm_user_wants_more_parm = ON;
	          else if pfm_break_character = DEL
		     then pfm_user_wants_more_parm = OFF;
		     else pfm_still_looking_for_a_valid_response = ON;
	     else pfm_still_looking_for_a_valid_response = ON;
	     if pfm_still_looking_for_a_valid_response
	     then do;
		call window_$bell (window_iocb_ptr, code);
		call check_code;
	     end;
	end;
%skip(1);
	return;
%skip(1);
     end prompt_for_more;
%page;
prompt_user: proc (

	pu_prompt_parm,	/* input: the prompt */
	pu_number_parm,	/* output: the numeric response, or, */
	pu_response_parm,	/* output: the character response */
          pu_numeric_parm	/* input: if on a numeric response is required */
	        );
%skip(1);
dcl pu_number_of_chars_read fixed bin (21);
dcl pu_number_parm fixed bin (35) parm;
dcl pu_numeric_parm bit (1) aligned parm;
dcl pu_prompt_parm char (*) parm;
dcl pu_response_buffer char (256);
dcl pu_response_line fixed bin;
dcl pu_response_parm char (*) parm;
dcl pu_still_looking_for_a_valid_response bit (1) aligned;
dcl pu_window_status_pending condition;
dcl pu_window_status_pending_flag bit (1) aligned;
%skip(3);
/*
	Prompt the user with the supplied prompt in the last line of the 
	window. Accept a numeric or character response depending on the
	setting of pu_numeric_parm. Keep prompting until we get a valid
	response. If we get a window_status_pending then re-write prompt
	on the first line of the window after doing a get_window_status
	control order. Use the iox_ entry point rather than a window_
	entrypoint because the window_ system still doesn't have an
	equivalent. Note that the horrid window_status_pending never
	comes back from the iox_ entrypoint.
*/
%skip(1);
	pu_window_status_pending_flag = OFF;
%skip(1);
	on pu_window_status_pending begin;
	     pu_window_status_pending_flag = ON;
	     pu_response_line = 1;	     
	     call write_prompt;
	end;
%skip(1);
	pu_number_parm = 0;
	pu_response_parm = "";
	pu_still_looking_for_a_valid_response = ON;
	pu_response_line = report_output_window_position_info.height;
%page;
	do while (pu_still_looking_for_a_valid_response);
	     call write_prompt;
	     call iox_$get_line (window_iocb_ptr, addr (pu_response_buffer),
		length (pu_response_buffer), pu_number_of_chars_read, code);
	     if code ^= 0
	     then if code = error_table_$long_record
		then;
	          else call abort_line (code, "Unable to read prompt response.");
	     else do;
		pu_number_of_chars_read = pu_number_of_chars_read - 1;
		if pu_numeric_parm
		then if pu_number_of_chars_read > 0 & pu_number_of_chars_read < 10
		     then pu_still_looking_for_a_valid_response
			= (verify (substr (pu_response_buffer, 1, pu_number_of_chars_read), DIGITS) ^= 0);
		     else;
		else pu_still_looking_for_a_valid_response = OFF;
	     end;
	     if pu_still_looking_for_a_valid_response
	     then do;
		call window_$bell (window_iocb_ptr, code);
		if code ^= 0
		then signal pu_window_status_pending;
		else;
	     end;
	end;
%skip(1);
	if pu_numeric_parm
	then pu_number_parm = convert (pu_number_parm,
	     substr (pu_response_buffer, 1, pu_number_of_chars_read));
	else pu_response_parm = substr (pu_response_buffer, 1, pu_number_of_chars_read);
%skip(1);
	return;
%page;
write_prompt: proc;
%skip(3);
	/* Repeat the sequence until we correctly write the prompt. */
%skip(1);
	if pu_window_status_pending_flag
	then do;
	     call iox_$control (window_iocb_ptr, "get_window_status",
		window_status_info_ptr, code);
	     if code ^= 0
	     then call abort_line (code, "Unable to peform a get_window_status control order.");
	     pu_window_status_pending_flag = OFF;
	end;
%skip(1);
	call window_$position_cursor (window_iocb_ptr, pu_response_line, 1, code);
	call window_$clear_to_end_of_line (window_iocb_ptr, code);
	call window_$overwrite_text (window_iocb_ptr,
	     rtrim (pu_prompt_parm) || " (end with RETURN) ->", code);
%skip(1);
	if code ^= 0
	then if code = video_et_$window_status_pending
	     then signal pu_window_status_pending;
	     else call abort_line (code, "Unable to write the prompt.");
	else;
%skip(1);
	return;
%skip(1);
     end write_prompt;
%skip(1);
     end prompt_user;
%page;
scroll_the_report: proc;
%skip(3);
/*
	Display a chunk of the page or buffer. Perform the scrolling
	function requested by the user. Return to the caller if we're
	outside of the current page, or if we just crossed a buffer boundary.
*/
%skip(1);
	still_in_the_scrolling_business = ON;
%skip(1);
	do while (still_in_the_scrolling_business);
	     call display_chunk_of_page;
	     call setup_for_next_chunk;
	end;
%skip(1);
          return;
%skip(1);
     end scroll_the_report;
%page;
set_function_key: proc (

	sfk_function_name_parm,	  /* input: function to set key to */
	sfk_function_key_sequence_parm, /* input: key sequence to set */
	sfk_code_parm		  /* output: success or failure */
		   );
%skip(3);
dcl sfk_char_10 char (10);
dcl sfk_character_loop char (length (CONTROL_HYPHEN));
dcl sfk_code_parm fixed bin (35) parm;
dcl sfk_function_name_parm char (*) parm;
dcl sfk_function_key_sequence_parm char (*) parm;
dcl sfk_function_key_sequence char (32);
dcl sfk_function_key_sequence_buffer char (32);
dcl sfk_loop fixed bin;
dcl sfk_no_match bit (1) aligned;
%skip(3);
/*
	Translate "escape-", "esc-", "control-X", "ctl-X", to the sequence
	the terminal generates, where X is the character following the
	"control-" or "ctl-" mnemonic. Next translate any of the recognized
	mnemonics in the provided key sequence to what the terminal generates
	(i.e. translate "down_arrow" into whatever the terminal generates).
	Look up the supplied scrolling function name and assign the key
	sequence to the slot in the table. Assign the mnemonic key sequence
	to the slot in another table for it's display when help is invoked.
*/
%skip(1);
	sfk_code_parm = 0;
	if index (sfk_function_key_sequence_parm, ESCAPE_HYPHEN) = 0
	&  index (sfk_function_key_sequence_parm, ESC_HYPHEN) = 0
	&  index (sfk_function_key_sequence_parm, CONTROL_HYPHEN) = 0
	&  index (sfk_function_key_sequence_parm, CTL_HYPHEN) = 0
	then sfk_function_key_sequence = sfk_function_key_sequence_parm;
	else do;
	     sfk_function_key_sequence = sfk_function_key_sequence_parm;
	     do sfk_character_loop = ESCAPE_HYPHEN, ESC_HYPHEN, CONTROL_HYPHEN, CTL_HYPHEN;
		call translate_mnemonics (sfk_function_key_sequence,
		     sfk_character_loop, sfk_function_key_sequence_buffer, sfk_code_parm);
		if sfk_code_parm ^= 0
		then return;
		sfk_function_key_sequence = sfk_function_key_sequence_buffer;
	     end;
	end;
%page;
	if sfk_function_key_sequence = KEY_MNEMONICS.FORWARD
	then sfk_function_key_sequence = substr (function_key_seqs,
	     function_key_data.cursor_motion_keys.down (KEY_PLAIN).sequence_index,
	     function_key_data.cursor_motion_keys.down (KEY_PLAIN).sequence_length);
	else if sfk_function_key_sequence = KEY_MNEMONICS.BACKWARD
	then sfk_function_key_sequence = substr (function_key_seqs,
	     function_key_data.cursor_motion_keys.up (KEY_PLAIN).sequence_index,
	     function_key_data.cursor_motion_keys.up (KEY_PLAIN).sequence_length);
	else if sfk_function_key_sequence = KEY_MNEMONICS.LEFT
	then sfk_function_key_sequence = substr (function_key_seqs,
	     function_key_data.cursor_motion_keys.left (KEY_PLAIN).sequence_index,
	     function_key_data.cursor_motion_keys.left (KEY_PLAIN).sequence_length);
	else if sfk_function_key_sequence = KEY_MNEMONICS.RIGHT
	then sfk_function_key_sequence = substr (function_key_seqs,
	     function_key_data.cursor_motion_keys.right (KEY_PLAIN).sequence_index,
	     function_key_data.cursor_motion_keys.right (KEY_PLAIN).sequence_length);
	else if sfk_function_key_sequence = HOME
	then sfk_function_key_sequence = substr (function_key_seqs,
	     function_key_data.cursor_motion_keys.home (KEY_PLAIN).sequence_index,
	     function_key_data.cursor_motion_keys.home (KEY_PLAIN).sequence_length);
	else do;
	     sfk_no_match = ON;
	     do sfk_loop = 0 to hbound (function_key_data.function_keys, 1)
		while (sfk_no_match);
		if sfk_function_key_sequence
		= "f" || ltrim (convert (sfk_char_10, sfk_loop))
		then do;
		     sfk_function_key_sequence = substr (function_key_seqs,
			function_key_data.function_keys (sfk_loop, KEY_PLAIN).sequence_index,
			function_key_data.function_keys (sfk_loop, KEY_PLAIN).sequence_length);
		     sfk_no_match = OFF;
		end;
	     end;
	end;
%skip(1);
	do sfk_loop = 1 to HIGHEST_DISPLAY_FUNCTION_NUMBER;
	     if sfk_function_name_parm = FUNCTION_NAMES_AS_A_TABLE (sfk_loop)
	     then do;
		keys_as_a_table (sfk_loop) = sfk_function_key_sequence;
		mnemonic_key_sequences_as_a_table (sfk_loop)
		     = sfk_function_key_sequence_parm;
		return;
	     end;
	end;
%skip(1);
	sfk_code_parm = rw_error_$bad_fkey_name;
%skip(1);
	return;
%page;
translate_mnemonics: proc (

	tm_string_in_parm,	/* input: string to be translated */
	tm_mnemonic_parm,   /* input: the mnemonic to be translated */
	tm_string_out_parm, /* output: the translated string */
	tm_code_parm	/* output: success or failure */
		      );
%skip(1);
dcl tm_code_parm fixed bin (35) parm;
dcl tm_current_position fixed bin;
dcl tm_escape_is_replacement_char bit (1) aligned;
dcl tm_mnemonic_length fixed bin;
dcl tm_mnemonic char (32) varying;
dcl tm_mnemonic_parm char (*) parm;
dcl tm_still_translating bit (1) aligned;
dcl tm_string_in_parm char (*) parm;
dcl tm_string_index fixed bin;
dcl tm_string_length fixed bin;
dcl tm_string_out_parm char (*) parm;
dcl tm_string_varying char (32) varying;
dcl tm_target_character_index fixed bin;
dcl tm_translation_index fixed bin;
%skip(3);
/*
	Translate "escape-", "esc-", "control-X", and "ctl-X" into the
	sequence the terminal generates. The "control-" or "ctl-"
	mnemonic has to be followed by another character, as a terminal
	can't generate control without pressing some other key.
*/
%skip(1);
	tm_code_parm = 0;
	tm_mnemonic = rtrim (tm_mnemonic_parm);
%skip(1);
	if index (tm_string_in_parm, tm_mnemonic) = 0
	then do;
	     tm_string_out_parm = tm_string_in_parm;
	     return;
	end;
%skip(1);
	tm_mnemonic_length = length (tm_mnemonic);
	tm_escape_is_replacement_char = (tm_mnemonic = ESCAPE_HYPHEN | tm_mnemonic = ESC_HYPHEN);
	tm_string_varying = "";
	tm_still_translating = ON;
	tm_string_length = length (rtrim (tm_string_in_parm));
	tm_current_position = 1;
%page;
	do while (tm_still_translating);
	     tm_string_index = index (substr (tm_string_in_parm, tm_current_position), tm_mnemonic);
	     if tm_string_index ^= 0
	     then do;
		if tm_current_position < tm_string_index
		then tm_string_varying = tm_string_varying || substr (tm_string_in_parm,
		     tm_current_position, tm_string_index - tm_current_position);
		if tm_escape_is_replacement_char
		then do;
		     tm_string_varying = tm_string_varying || ESCAPE;
		     tm_current_position = tm_current_position + tm_string_index + tm_mnemonic_length - 1;
		end;
		else do;
		     tm_target_character_index = tm_current_position + tm_string_index + tm_mnemonic_length - 1;
		     if tm_target_character_index > tm_string_length
		     then do;
			tm_code_parm = rw_error_$bad_fkey_sequence;
			return;
		     end;
		     tm_translation_index = index (TRANSLATION_TABLE,
			substr (tm_string_in_parm, tm_target_character_index, 1));
		     if tm_translation_index = 0
		     then do;
			tm_code_parm = rw_error_$bad_fkey_sequence;
			return;
		     end;
		     if tm_translation_index > 32
		     then tm_translation_index = tm_translation_index - 32;
		     tm_string_varying = tm_string_varying || byte (tm_translation_index - 1);
		     tm_current_position = tm_target_character_index + 1;
		end;
		if tm_current_position > tm_string_length
		then tm_still_translating = OFF;
	     end;
	     else do;
		if tm_string_length >= tm_current_position
		then tm_string_varying = tm_string_varying
		     || substr (tm_string_in_parm, tm_current_position);
		tm_still_translating = OFF;
	     end;
	end;
%skip(1);
	tm_string_out_parm = tm_string_varying;
%skip(1);
	return;
%skip(1);
     end translate_mnemonics;
%skip(1);
     end set_function_key;
%page;
setup_for_next_chunk: proc;
%skip(1);
dcl sfnc_function_key_procs (HIGHEST_DISPLAY_FUNCTION_NUMBER) entry init (
	fkp_forward,
	fkp_backward,
	fkp_left,
	fkp_right,
	fkp_help,
	fkp_set_key,
	fkp_set_scroll_increment,
	fkp_quit,
	fkp_redisplay,
	fkp_start_of_report,
	fkp_end_of_report,
	fkp_multics_mode,
	fkp_goto);
dcl sfnc_function_number fixed bin;
dcl sfnc_loop fixed bin;
dcl sfnc_still_looking_for_a_valid_response bit (1) aligned;
dcl sfnc_users_response char (32);
%skip(1);
	/* Get a valid user response for a scroll function. Perform the function. */
%skip(1);
	sfnc_still_looking_for_a_valid_response = ON;
%skip(1);
	do while (sfnc_still_looking_for_a_valid_response);
	     call get_users_response (sfnc_users_response);
%skip(1);
	     do sfnc_loop = 1 to HIGHEST_DISPLAY_FUNCTION_NUMBER
		while (sfnc_still_looking_for_a_valid_response);
		if sfnc_users_response = keys_as_a_table (sfnc_loop)
		then do;
		     sfnc_function_number = sfnc_loop;
		     sfnc_still_looking_for_a_valid_response = OFF;
		end;
	     end;
%skip(1);
	     if ^sfnc_still_looking_for_a_valid_response
	     then call sfnc_function_key_procs (sfnc_function_number);
	     if sfnc_still_looking_for_a_valid_response
	     then do;
		call window_$bell (window_iocb_ptr, code);
		call check_code;
	     end;
%skip(1);
	end;
%skip(1);
	return;
%page;
fkp_backward: proc;
%skip(1);
dcl fb_beginning_line_number fixed bin;
%skip(3);
/*
	Make sure we don't try to go backward if we're at the beginning
	of the report. If we're at the first line of a page then set the
	page number back one and return to rw_display, and set the line
	number very large so display_chunk_of_page can determine what the
	last line of the previous page is once that information is available
	(when we are called again). If we're not on the first line of a page
	then decrement the current line number and return.
*/
%skip(1);
	if scroll_info.target_line_number = 1
	then if scroll_info.target_page_number = 1
	     then do;
		sfnc_still_looking_for_a_valid_response = ON;
		return;
	     end;
	     else if report_control_info.flags.report_is_paginated
		then do;
		     scroll_info.target_page_number = scroll_info.target_page_number - 1;
		     scroll_info.target_line_number = 99999;
		     still_in_the_scrolling_business = OFF;
		     return;
		end;
		else;
	else if report_control_info.flags.report_is_paginated
	     then do;
		scroll_info.target_line_number
		     = scroll_info.target_line_number - scroll_info.vertical_scroll_distance;
		return;
	     end;
%skip(1);
/*
	We only make it this far if it's an unpaginated report. If the
	beginning line number is less than 1 then return to rw_display
	so it can get us the previous buffer.
*/
%skip(1);
	fb_beginning_line_number
	     = scroll_info.target_line_number - scroll_info.vertical_scroll_distance;
	if fb_beginning_line_number < 1
	then if scroll_info.target_page_number = 1
	     then do;
		scroll_info.target_line_number = 1;
		return;
	     end;
	     else do;
		scroll_info.target_line_number
		     = scroll_info.last_line_number_in_previous_buffer
		     + scroll_info.target_line_number - scroll_info.vertical_scroll_distance;
		still_in_the_scrolling_business = OFF;
		scroll_info.target_page_number = scroll_info.target_page_number - 1;
		return;
	     end;
	else;
%skip(1);
/*
	Return to rw_display to get us the previous buffer if we
	used two buffers for the previous display.
*/
%skip(1);
	scroll_info.target_line_number = fb_beginning_line_number;
	if scroll_info.flags.buffer_boundary_just_crossed
	then do;
	     scroll_info.flags.buffer_boundary_just_crossed = OFF;
	     still_in_the_scrolling_business = OFF;
	end;
%skip(1);
	return;
%skip(1);
     end fkp_backward;
%page;
fkp_end_of_report: proc;
%skip(3);
/*
	If the report is paginated then set the page number very large. If
	the report is unpaginated then set the goto_line_number_pending
	flag and set the line number very large. Return to rw_display.
*/
%skip(1);
	still_in_the_scrolling_business = OFF;
%skip(1);
	if report_control_info.flags.report_is_paginated
	then do;
	     scroll_info.target_page_number = LARGEST_PAGE_NUMBER;
	     scroll_info.target_line_number = 1;
	end;
	else do;
	     scroll_info.flags.goto_line_number_pending = ON;
	     scroll_info.target_line_number = LARGEST_LINE_NUMBER;
	end;
%skip(1);
	return;
%skip(1);
     end fkp_end_of_report;
%page;
fkp_forward: proc;
%skip(1);
dcl ff_beginning_line_number fixed bin;
dcl ff_number_of_left_over_lines fixed bin;
%skip(1);
/*
	Handle unpaginated reports first. If we just crossed a buffer
	boundary and the first line to be displayed is in the first
	buffer then return to rw_display so it can get it. Otherwise
	we have just moved to the buffer we currently have.
*/
%skip(1);
	if scroll_info.flags.buffer_boundary_just_crossed
	then do;
	     scroll_info.flags.buffer_boundary_just_crossed = OFF;
	     ff_number_of_left_over_lines
		= scroll_info.last_line_number_in_previous_buffer - scroll_info.target_line_number + 1;
	     if ff_number_of_left_over_lines > scroll_info.vertical_scroll_distance
	     then do;
		scroll_info.target_line_number = scroll_info.target_line_number
		     + scroll_info.vertical_scroll_distance;
		still_in_the_scrolling_business = OFF;
		return;
	     end;
	     scroll_info.target_line_number = scroll_info.vertical_scroll_distance - ff_number_of_left_over_lines + 1;
	     scroll_info.target_page_number = scroll_info.target_page_number + 1;
	     return;
	end;
%skip(1);
/*
	This code does paginated reports. Advance line number. Make sure
	we don't move off the end of the report. Return to rw_display
	if we move off the current page.
*/
%skip(1);
	ff_beginning_line_number = scroll_info.target_line_number
	     + scroll_info.vertical_scroll_distance - scroll_info.top_margin_offset;
	if ff_beginning_line_number > page_info.length
	then if report_control_info.flags.report_is_formatted
	     & scroll_info.target_page_number = report_control_info.no_of_formatted_pages
	     then sfnc_still_looking_for_a_valid_response = ON;
	     else do;
		scroll_info.target_page_number = scroll_info.target_page_number + 1;
		scroll_info.target_line_number = 1;
		still_in_the_scrolling_business = OFF;
	     end;
	else scroll_info.target_line_number = ff_beginning_line_number;
%skip(1);
	return;
%skip(1);
     end fkp_forward;
%page;
fkp_goto: proc;
%skip(1);
dcl fg_prompt char (11);
dcl fg_line_or_page_number fixed bin (35);
dcl fg_still_looking_for_a_valid_response bit (1) aligned;
%skip(3);
/*
	Prompt for page or line number. Accept only a positive integer.
	Return to rw_display to get the page or buffer.
*/
%skip(1);
	if report_control_info.flags.report_is_paginated
	then fg_prompt = "Page number";
	else fg_prompt = "Line number";
%skip(1);
	fg_still_looking_for_a_valid_response = ON;
	do while (fg_still_looking_for_a_valid_response);
	     call prompt_user (fg_prompt, fg_line_or_page_number,
		users_response, NUMERIC_RESPONSE);
	     if fg_line_or_page_number ^= 0
	     then do;
		if report_control_info.flags.report_is_paginated
		then do;
		     scroll_info.target_page_number = fg_line_or_page_number;
		     scroll_info.target_line_number = 1;
		end;
		else do;
		     scroll_info.flags.goto_line_number_pending = ON;
		     scroll_info.target_line_number = fg_line_or_page_number;
		end;
		fg_still_looking_for_a_valid_response = OFF;
		still_in_the_scrolling_business = OFF;
	     end;
	     else do;
		call window_$bell (window_iocb_ptr, code);
		call check_code;
	     end;
	end;
%skip(1);
	return;
%skip(1);
     end fkp_goto;
%page;
fkp_help: proc;
%skip(3);
dcl fh_character_read char (1) varying;
dcl fh_help_string char (1024);
dcl fh_help_string_length fixed bin (21);
dcl fh_number_of_chars_read fixed bin (21);
dcl fh_still_looking_for_a_valid_response bit (1) aligned;
dcl fh_returned_help_list char (512);
dcl fh_still_helpful bit (1) aligned;
dcl fh_users_response char (256);
%skip(1);
/*
	Format and write the general help message. Format and write the
	mnemonic key sequences and function names list, or, the specific
	help string for one of the functions. Repeat if user wants more help.
*/
%skip(1);
	fh_still_helpful = ON;
%skip(1);
	do while (fh_still_helpful);
	     call format_document_$string (GENERAL_HELP_MESSAGE, fh_help_string,
		fh_help_string_length, format_document_options_ptr, code);
	     if code ^= 0
	     then call abort_line (code, "");
	     fh_still_looking_for_a_valid_response = ON;
%skip(1);
	     do while (fh_still_looking_for_a_valid_response);
		fh_still_looking_for_a_valid_response = OFF;
		call write_help_string (NO_PROMPT, fh_character_read);
		call iox_$get_line (window_iocb_ptr, addr (fh_users_response),
		     length (fh_users_response), fh_number_of_chars_read, code);
		if code ^= 0
		then call abort_line (code, "");
		if fh_number_of_chars_read ^> 1
		then fh_still_looking_for_a_valid_response = ON;
		else do;
		     fh_number_of_chars_read = fh_number_of_chars_read - 1;
		     if substr (fh_users_response, 1, fh_number_of_chars_read) = GENERAL_HELP_LIST
		     then do;
			call ioa_$rsnnl (GENERAL_HELP_LIST_MESSAGE, fh_help_string,
			     fh_help_string_length, mnemonic_key_sequences.forward, 
			     mnemonic_key_sequences.backward, mnemonic_key_sequences.left,
			     mnemonic_key_sequences.right, mnemonic_key_sequences.help,
			     mnemonic_key_sequences.set_key, mnemonic_key_sequences.set_scroll_increment,
			     mnemonic_key_sequences.quit, mnemonic_key_sequences.redisplay,
			     mnemonic_key_sequences.start_of_report, mnemonic_key_sequences.end_of_report,
			     mnemonic_key_sequences.multics_mode, mnemonic_key_sequences.goto);
			call write_help_string (PROMPT, fh_character_read);
		     end;
		     else call help_for_function (fh_still_looking_for_a_valid_response);
		end;
		if fh_still_looking_for_a_valid_response
		then do;
		     call window_$bell (window_iocb_ptr, code);
		     call check_code;
		end;
	     end;
%skip(1);
	     if fh_character_read ^= "h"
	     then fh_still_helpful = OFF;
%skip(1);
	end;
%skip(1);
	return;
%page;
help_for_function: proc (

	hff_invalid_function_parm	/* output: off if it was a valid function */
		    );
%skip(1);
dcl hff_function_number fixed bin;
dcl hff_invalid_function_parm bit (1) aligned parm;
dcl hff_loop fixed bin;
dcl hff_target_function char (32);
%skip(1);
/*
	Find the scroll function by name or mnemonic key sequence. Write
	the help string for it.
*/
%skip(1);
	hff_invalid_function_parm = ON;
	hff_target_function = substr (fh_users_response, 1, fh_number_of_chars_read);
%skip(1);
	do hff_loop = 1 to HIGHEST_DISPLAY_FUNCTION_NUMBER
	     while (hff_invalid_function_parm);
	     if hff_target_function = FUNCTION_NAMES_AS_A_TABLE (hff_loop)
	     | hff_target_function = mnemonic_key_sequences_as_a_table (hff_loop)
	     then do;
		hff_invalid_function_parm = OFF;
		hff_function_number = hff_loop;
	     end;
	end;
%skip(1);
	if hff_invalid_function_parm
	then return;
%skip(1);
	call ioa_$rsnnl (HELP_HEADER_CONTROL_STRING, fh_returned_help_list,
	     fh_number_of_chars_read, FUNCTION_NAMES_AS_A_TABLE (hff_function_number),
	     mnemonic_key_sequences_as_a_table (hff_function_number), HELP_MESSAGES (hff_function_number));
	call format_document_$string (fh_returned_help_list, fh_help_string,
	     fh_help_string_length, format_document_options_ptr, code);
	if code ^= 0
	then call abort_line (code, "");
	call write_help_string (PROMPT, fh_character_read);
%skip(1);
	return;
%skip(1);
     end help_for_function;
%page;
write_help_string: proc (

	whs_prompt_parm,	/* input: on means prompt to make sure user has seen it */
	whs_char_read_parm  /* output: the char read if above bit is on */
		    );
%skip(1);
dcl whs_char_read_parm char (1) varying parm;
dcl whs_current_position fixed bin;
dcl whs_current_line_on_screen fixed bin;
dcl whs_new_line_position fixed bin;
dcl whs_prompt_parm bit (1) aligned parm;
dcl whs_still_filling bit (1) aligned;
dcl whs_wants_more bit (1) aligned;
%skip(1);
	/* Fill and write the help string with optional prompt. */
%skip(1);
	whs_still_filling = ON;
	whs_current_position = 1;
	whs_current_line_on_screen = 1;
	if whs_prompt_parm
	then do;
	     substr (fh_help_string, fh_help_string_length + 1) = HOW_TO_END_DISPLAY_MESSAGE;
	     fh_help_string_length = fh_help_string_length + length (HOW_TO_END_DISPLAY_MESSAGE) + 1;
	end;
	else whs_char_read_parm = "";
	call window_$clear_window (window_iocb_ptr, code);
	call check_code;
%skip(1);
	do while (whs_still_filling);
	     whs_new_line_position = index (substr (fh_help_string, whs_current_position), NEWLINE);
	     if whs_new_line_position = 0
	     then whs_still_filling = OFF;
	     else do;
		if whs_current_line_on_screen = report_output_window_position_info.height
		then do;
		     call prompt_for_more (whs_current_line_on_screen, whs_wants_more);
		     if ^whs_wants_more
		     then do;
			call fkp_redisplay;
			return;
		     end;
		     else whs_current_line_on_screen = 1;
		end;
		call window_$position_cursor (window_iocb_ptr, whs_current_line_on_screen, 1, code);
		call check_code;
		call window_$clear_to_end_of_line (window_iocb_ptr, code);
		call check_code;
		call window_$overwrite_text (window_iocb_ptr,
		     substr (fh_help_string, whs_current_position, whs_new_line_position - 1), code);
		call check_code;
		whs_current_line_on_screen = whs_current_line_on_screen + 1;
		whs_current_position = whs_current_position + whs_new_line_position;
		if whs_current_position > fh_help_string_length
		then whs_still_filling = OFF;
	     end;
	end;
%skip(1);
	if whs_prompt_parm
	then do;
	     call window_$get_one_unechoed_char (window_iocb_ptr, whs_char_read_parm, ON, code);
	     call check_code;
	end;
%skip(1);
	return;
%skip(1);
     end write_help_string;
%skip(1);
     end fkp_help;
%page;
fkp_left: proc;
%skip(3);
/*
	Make sure we don't go left if we're at character position 1. Move
	left and adjust if we're too far left. If we've used two buffers
	in the previous display return to rw_display so it can get us
	back to the first.
*/
%skip(1);
	if scroll_info.left_vertical_position = 1
	then do;
	     sfnc_still_looking_for_a_valid_response = ON;
	     return;
	end;
%skip(1);
	scroll_info.left_vertical_position = max (
	     scroll_info.left_vertical_position - scroll_info.horizontal_scroll_distance, 1);
%skip(1);
	if scroll_info.flags.buffer_boundary_just_crossed
	then do;
	     still_in_the_scrolling_business = OFF;
	     scroll_info.flags.buffer_boundary_just_crossed = OFF;
	end;
%skip(1);
	return;
%skip(1);
     end fkp_left;
%page;
fkp_multics_mode: proc;
%skip(3);
/*
	If window is user_i/o then clear it. Write message telling user how
	to get back to display. Get to Multics level. Do a redisplay.
*/
%skip(1);
	if window_iocb_ptr = iox_$user_io | window_iocb_ptr = iox_$user_output
	then call window_$clear_window (window_iocb_ptr, code);
	call check_code;
	call window_$position_cursor (window_iocb_ptr, 1, 1, code);
	call check_code;
	call window_$clear_to_end_of_line (window_iocb_ptr, code);
	call check_code;
	call window_$overwrite_text (window_iocb_ptr, HOW_TO_GET_BACK_MESSAGE, code);
	call check_code;
	if window_iocb_ptr = iox_$user_io | window_iocb_ptr = iox_$user_output
	then do;
	     call window_$position_cursor (window_iocb_ptr, 2, 1, code);
	     call check_code;
	end;
%skip(1);
	unspec (command_level_flags) = OFF;
	call cu_$cl (command_level_flags);
	call fkp_redisplay;
%skip(1);
	return;
%skip(1);
     end fkp_multics_mode;
%page;
fkp_quit: proc;
%skip(3);
	/* Thank you for using this product. Come back y'all. */
%skip(1);
	code = error_table_$end_of_info;
	still_in_the_scrolling_business = OFF;
%skip(1);
	return;
%skip(1);
     end fkp_quit;
%page;
fkp_redisplay: proc;
%skip(3);
	/* This is all it takes to get a redisplay. Pretty simple huh? */
%skip(1);
	still_in_the_scrolling_business = OFF;
%skip(1);
	return;
%skip(1);
     end fkp_redisplay;
%page;
fkp_right: proc;
%skip(3);
/*
	Make sure we son't go too far right. If we used two buffers during 
	the last display then return to rw_display so it can get us
	back the first one.
*/
%skip(1);
	if scroll_info.left_vertical_position + report_output_window_position_info.width >= page_info.width
	then do;
	     sfnc_still_looking_for_a_valid_response = ON;
	     return;
	end;
%skip(1);
	scroll_info.left_vertical_position
	     = scroll_info.left_vertical_position + scroll_info.horizontal_scroll_distance;
%skip(1);
	if scroll_info.flags.buffer_boundary_just_crossed
	then do;
	     still_in_the_scrolling_business = OFF;
	     scroll_info.flags.buffer_boundary_just_crossed = OFF;
	end;
%skip(1);
	return;
%skip(1);
     end fkp_right;
%page;
fkp_set_key: proc;
%skip(3);
dcl fkp_valid_response bit (1) aligned;
dcl fkp_prompt char (21);
%skip(1);
/*
	Prompt for function name and mnemonic key sequence. Assign the
	key sequence to the function.
*/
%skip(1);
	fkp_prompt = "Function name";
	fkp_valid_response = OFF;
%skip(1);
	do while (^fkp_valid_response);
	     call prompt_user (fkp_prompt, 0, users_response, NON_NUMERIC_RESPONSE);
	     function_name = users_response;
	     fkp_valid_response = valid_function_name (function_name);
	     if ^fkp_valid_response
	     then call window_$bell (window_iocb_ptr, code);
	     call check_code;
	end;
%skip(1);
	fkp_prompt = "Mnemonic key sequence";
	fkp_valid_response = OFF;
%skip(1);
	do while (^fkp_valid_response);
	     call prompt_user (fkp_prompt, 0,
		users_response, NON_NUMERIC_RESPONSE);
	     call set_function_key (function_name, users_response, code);
	     fkp_valid_response = (code = 0);
	     if ^fkp_valid_response
	     then call window_$bell (window_iocb_ptr, code);
	     call check_code;
	end;
%skip(1);
	return;
%skip(1);
     end fkp_set_key;
%page;
fkp_set_scroll_increment: proc;
%skip(3);
	call set_scroll_height_or_width;
%skip(1);
	return;
%skip(1);
     end fkp_set_scroll_increment;
%page;
fkp_start_of_report: proc;
%skip(3);
	/* Return to rw_display so it can get us page 1 or buffer 1. */
%skip(1);
	still_in_the_scrolling_business = OFF;
	scroll_info.target_page_number = 1;
	scroll_info.target_line_number = 1;
%skip(1);
	return;
%skip(1);
     end fkp_start_of_report;
%page;
set_scroll_height_or_width: proc;
%skip(1);
dcl sshow_height bit (1) aligned;
dcl sshow_prompt char (42);
dcl sshow_scroll_height_or_width fixed bin (35);
dcl sshow_still_looking_for_a_valid_response bit (1) aligned;
%skip(1);
	/* Set the scroll increment for height or width. */
%skip(1);
	sshow_prompt = """h"" for height, anything else for width";
	call prompt_user (sshow_prompt, sshow_scroll_height_or_width,
	     users_response, NON_NUMERIC_RESPONSE);
	sshow_height = (users_response = "h");
	if sshow_height
	then sshow_prompt = "New scroll height";
	else sshow_prompt = "New scroll width";
%skip(1);
	sshow_still_looking_for_a_valid_response = ON;
%skip(1);
	do while (sshow_still_looking_for_a_valid_response);
	     sshow_still_looking_for_a_valid_response = OFF;
	     call prompt_user (sshow_prompt, sshow_scroll_height_or_width,
		users_response, NUMERIC_RESPONSE);
	     if sshow_height
	     then if sshow_scroll_height_or_width > page_info.length
		| sshow_scroll_height_or_width < TOP_MARGIN_HEIGHT
		then sshow_still_looking_for_a_valid_response = ON;
	          else;
	     else if sshow_scroll_height_or_width > page_info.width
		then sshow_still_looking_for_a_valid_response = ON;
	          else;
	     if ^sshow_still_looking_for_a_valid_response
	     then if sshow_height
		then scroll_info.vertical_scroll_distance = sshow_scroll_height_or_width;
	          else scroll_info.horizontal_scroll_distance = sshow_scroll_height_or_width;
	     else;
	     if ^sshow_still_looking_for_a_valid_response
	     then call fkp_redisplay;
	     else do;
		call window_$bell (window_iocb_ptr, code);
		call check_code;
	     end;
	end;
%skip(1);
	return;
%skip(1);
     end set_scroll_height_or_width;
%skip(1);
     end setup_for_next_chunk;
%page;
setup_scroll: proc;
%skip(3);
	/* Set the pointers we will need. */
%skip(1);
	scroll_ip = display_results.scroll_info_ptr;
	scroll_info.display_arg_results_ptr = display_results_ptr;
	scroll_info.report_control_info_ptr = report_cip;
	scroll_info.area_ptr = work_area_ptr;
	scroll_info.ssu_info_ptr = sci_ptr;
%skip(1);
	/* Allocate the structures for the user_i/o and report windows, and the window_status_info. */
%skip(1);
	allocate user_io_window_position_info in (work_area)
	     set (user_io_window_position_ip);
	scroll_info.user_io_window_position_info_ptr
	     = user_io_window_position_ip;
	unspec (user_io_window_position_info) = OFF;
	user_io_window_position_info.version = window_position_info_version_1;
%skip(1);
	allocate report_output_window_position_info in (work_area)
	     set (report_output_window_position_ip);
	scroll_info.report_output_window_position_info_ptr
	     = report_output_window_position_ip;
	report_output_window_position_info = user_io_window_position_info;
%skip(1);
	allocate window_status_info in (work_area) set (window_status_info_ptr);
	window_status_info.version = window_status_version_1;
	scroll_info.window_status_info_pointer = window_status_info_ptr;
%skip(1);
	/* Turn on the video system if it's not already on. */
%skip(1);
	if video_data_$terminal_iocb = null ()
	then do;
	     scroll_info.flags.video_was_already_on = OFF;
	     call video_utils_$turn_on_login_channel (code, reason);
	     if code ^= 0
	     then call abort_line (code, reason);
	end;
	else scroll_info.flags.video_was_already_on = ON;
%page;
/*
	If -window was specified by the user make sure it meets the 
	requirements. If it wasn't setup a shriek named window and
	shrink user_i/o.
*/
%skip(1);
	if display_results.window_flag
	then do;
	     call iox_$look_iocb (display_results.window_name, window_iocb_ptr, code);
	     if code ^= 0
	     then call abort_line (code, "The window " || rtrim (display_results.window_name) || " doesn't exist.");
	     if window_iocb_ptr -> iocb.attach_descrip_ptr ^= null ()
	     then if window_iocb_ptr -> iocb.open_descrip_ptr = null ()
		then call abort_line (0, "The output switch "
		     || rtrim (display_results.window_name) || " is attached but not open.");
	          else;
	     else call abort_line (0, "The output switch "
		|| rtrim (display_results.window_name) || " is not attached.");
	     scroll_info.flags.user_io_was_shrunk = OFF;
	     call iox_$control (window_iocb_ptr, "get_window_info", 
		report_output_window_position_ip, code);
	     if code ^= 0
	     then call abort_line (code, "Unable to get the window information.");
	     if report_output_window_position_info.height < MINIMUM_WINDOW_SIZE
	     then call abort_line (0, MINIMUM_WINDOW_SIZE_ERROR_MESSAGE);
	end;
	else do;
	     scroll_info.flags.user_io_was_shrunk = ON;
	     call iox_$control (iox_$user_io, "get_window_info", 
		user_io_window_position_ip, code);
	     if code ^= 0
	     then call abort_line (code, "Unable to get the window information.");
	     if user_io_window_position_info.height < MINIMUM_LINES_NEEDED
	     then call abort_line (video_et_$insuff_room_for_window,
		MINIMUM_LINES_NEEDED_ERROR_MESSAGE);
	     call window_$clear_window (iox_$user_io, code);
	     if code ^= 0
	     then call abort_line (code, "Unable to clear the user_i/o window.");
	     report_output_window_position_info = user_io_window_position_info;
	     user_io_window_position_info.line = user_io_window_position_info.line
		+ user_io_window_position_info.height - USER_IO_WINDOW_HEIGHT;
	     user_io_window_position_info.height = USER_IO_WINDOW_HEIGHT;
	     call iox_$control (iox_$user_io, "set_window_info",
		user_io_window_position_ip, code);
	     if code ^= 0
	     then call abort_line (code, "Unable to set the window info for user_i/o.");
	     switch_name =  unique_chars_ ("0"b) || ".rw_display";
	     call iox_$find_iocb (switch_name, window_iocb_ptr, code);
	     if code ^= 0
	     then call abort_line (code, "Unable to find the io control block for "
		|| rtrim (switch_name) || ".");
	     report_output_window_position_info.height
		= report_output_window_position_info.height - USER_IO_WINDOW_HEIGHT;
	     call window_$create (video_data_$terminal_iocb,
		report_output_window_position_ip, window_iocb_ptr, code);
	     if code ^= 0
	     then call abort_line (code, "Unable to create the window for the report.");
	end;
%skip(1);
	/* Fill in the scroll_info and format_document_options structures. */
%skip(1);
	report_control_info.display_iocb_ptr = window_iocb_ptr;
%skip(1);
	scroll_info.number_of_lines_for_report_display = report_output_window_position_info.height;
	scroll_info.vertical_scroll_distance = report_output_window_position_info.height - 1;
	scroll_info.horizontal_scroll_distance = report_output_window_position_info.width - 10;
	scroll_info.target_page_number = 1;
	scroll_info.target_line_number = 1;
	scroll_info.left_vertical_position = 1;
%skip(1);
	allocate format_document_options in (work_area) set (format_document_options_ptr);
	unspec (format_document_options) = OFF;
	format_document_options.version_number = format_document_version_2;
	format_document_options.switches.galley_sw = ON;
	format_document_options.switches.break_word_sw = ON;
	format_document_options.switches.max_line_length_sw = ON;
	format_document_options.switches.sub_err_sw = ON;
	format_document_options.switches.literal_sw = ON;
	format_document_options.switches.dont_compress_sw = ON;
	format_document_options.line_length = report_output_window_position_info.width;
	format_document_options.switches.adj_sw = OFF;
	scroll_info.format_document_op = format_document_options_ptr;
%skip(1);
	return;
%skip(1);
     end setup_scroll;
%page;
terminate_scroll: proc;
%skip(3);
/*
	Clear the window. Destroy the window and restore user_i/o back to
	it's original size if -window wasn't given by the user. Turn off
	the video system if we turned it on.
*/
%skip(1);
	call window_$clear_window (window_iocb_ptr, code);
	if code ^= 0
	then call ssu_$print_message (sci_ptr, code);
%skip(1);
	if ^display_results.window_flag
	then do;
	     call window_$destroy (window_iocb_ptr, code);
	     if code ^= 0
	     then call ssu_$print_message (sci_ptr, code);
	     user_io_window_position_info.line
		= report_output_window_position_info.line;
	     user_io_window_position_info.height 
		= report_output_window_position_info.height
		+ user_io_window_position_info.height;
	     call iox_$control (iox_$user_io, "set_window_info",
		user_io_window_position_info_ptr, code);
	     if code ^= 0
	     then call ssu_$print_message (sci_ptr, code);
	     call iox_$destroy_iocb (window_iocb_ptr, code);
	     if code ^= 0
	     then call ssu_$print_message (sci_ptr, code);
	end;
%skip(1);
	if ^scroll_info.flags.video_was_already_on
	then do;
	     call video_utils_$turn_off_login_channel (code);
	     if code ^= 0
	     then call ssu_$print_message (sci_ptr, code);
	end;
%skip(1);
	if user_io_window_position_ip ^= null
	then free user_io_window_position_info;
	if report_output_window_position_ip ^= null
	then free report_output_window_position_info;
	if window_status_info_ptr ^= null
	then free window_status_info;
	if format_document_options_ptr ^= null
	then free format_document_options;
%skip(1);
	return;
%skip(1);
     end terminate_scroll;
%page;
valid_function_name: proc (

	vfn_function_name_parm)	/* input: function name */

	returns (bit (1) aligned);
%skip(3);
dcl vfn_function_name_parm char (*) parm;
%skip(1);
	/* Return true if it's a valid function name. */
%skip(3);
	return ((vfn_function_name_parm = FUNCTION_NAMES.FORWARD)
	     | (vfn_function_name_parm = FUNCTION_NAMES.BACKWARD)
	     | (vfn_function_name_parm = FUNCTION_NAMES.LEFT)
	     | (vfn_function_name_parm = FUNCTION_NAMES.RIGHT)
	     | (vfn_function_name_parm = FUNCTION_NAMES.HELP)
	     | (vfn_function_name_parm = FUNCTION_NAMES.SET_KEY)
	     | (vfn_function_name_parm = FUNCTION_NAMES.SET_SCROLL_INCREMENT)
	     | (vfn_function_name_parm = FUNCTION_NAMES.QUIT)
	     | (vfn_function_name_parm = FUNCTION_NAMES.REDISPLAY)
	     | (vfn_function_name_parm = FUNCTION_NAMES.START_OF_REPORT)
	     | (vfn_function_name_parm = FUNCTION_NAMES.END_OF_REPORT)
	     | (vfn_function_name_parm = FUNCTION_NAMES.MULTICS_MODE)
	     | (vfn_function_name_parm = FUNCTION_NAMES.GOTO));
%skip(1);
     end valid_function_name;
%page;
dcl BLANK char (1) static internal options (constant) init (" ");
%skip(1);
dcl CARRIAGE_RETURN char (1) static internal options (constant) init ("");
dcl CONTROL_HYPHEN char (8) static internal options (constant) init ("control-");
dcl CTL_HYPHEN char (4) static internal options (constant) init ("ctl-");
%skip(1);
dcl DEL char (1) static internal options (constant) init ("");
dcl DIGITS char (10) static int options (constant) init ("0123456789");
%skip(1);
dcl ESCAPE char (1) static internal options (constant) init ("");
dcl ESC_HYPHEN char (4) static internal options (constant) init ("esc-");
dcl ESCAPE_HYPHEN char (7) static internal options (constant) init ("escape-");
%skip(1);
dcl GENERAL_HELP_MESSAGE char (128) static internal options (constant) init (
"Type the function name or mnemonic key sequence, or type ?? for a list of function names and key sequences. (end with RETURN) ->");
dcl GENERAL_HELP_LIST char (2) static internal options (constant) init ("??");
dcl GENERAL_HELP_LIST_MESSAGE char (203) static internal options (constant) init (
"forward (^a)^/backward (^a)^/left (^a)^/right (^a)^/help (^a)^/set_key (^a)^/set_scroll_increment (^a)^/quit (^a)^/redisplay (^a)^/start_of_report (^a)^/end_of_report (^a)^/multics_mode (^a)^/goto (^a)^/");
%skip(1);
dcl HOME char (4) static internal options (constant) init ("home");
dcl HELP_HEADER_CONTROL_STRING char (15) internal static options (constant) init ("^a^x(^a)^2/^a^/");
dcl HELP_MESSAGES (13) char (254) internal static options (constant) init (

"The forward function moves the window forward into the report. The scroll height controls how many lines forward the window moves. The set_scroll_increment function can be used to change the scroll height.",

"The backward function moves the window backward into the report. The scroll height controls how many lines backward the window moves. The set_scroll_increment function can be used to change the scroll height.",

"The left function moves the window left in the report. The scroll width controls how many characters left the window moves. The set_scroll_increment function can be used to change the scroll width.",

"The right function moves the window right in the report. The scroll width controls how many characters right the window moves. The set_scroll_increment function can be used to change the scroll width.",

"The help function provides general information on the display function names and key sequences used to invoke the functions, or, more detailed help on any specific display function.",

"The set_key function provides a way to associate key sequences with display functions. The function name and mnemonic key sequences are prompted for.",

"The set_scroll_increment function provides a way to change the scroll height and width. Height is the number of lines forward or backward that the window will move; width is the number of characters left or right that the window will move.",

"The quit function terminates the current invocation of the display request.",

"The redisplay function redisplays the contents of the window. This is useful after the window contents have become invalid due to line noise, interactive messages, etc.",

"The start_of_report function provides a way to get back to the start of the report from any arbitrary place in the report.",

"The end_of_report function provides a way to get to the end of the report from any arbitrary place in the report.",

"The multics_mode function provides a way to suspend the current invocation of display and use other Multics facilities. Typing ""start"" resumes the suspended invocation of display.",

"The goto function provides a means to go directly to any page within a paginated report, or, directly to any line number within an unpaginated report."
);
dcl HOW_TO_END_DISPLAY_MESSAGE char (62) static internal options (constant) init ("Type any single character for redisplay or h for more help ->
");
dcl HOW_TO_GET_BACK_MESSAGE char (38) static internal options (constant) init (
"Type ""start"" to get back to display.");
%skip(1);
dcl LARGEST_LINE_NUMBER fixed bin (35) static internal options (constant) init (34359738365);
dcl LARGEST_PAGE_NUMBER fixed bin (21) static internal options (constant) init (2097151);
%skip(1);
dcl MINIMUM_LINES_NEEDED fixed bin static internal options (constant) init (9);
dcl MINIMUM_LINES_NEEDED_ERROR_MESSAGE char (45) static internal options (constant) init ("The user_i/o window must be at least 9 lines.");
dcl MINIMUM_WINDOW_SIZE fixed bin static internal options (constant) init (5);
dcl MINIMUM_WINDOW_SIZE_ERROR_MESSAGE char (45) static internal options (constant) init (
"The provided window must be at least 5 lines.");
dcl MORE_PROMPT char (47) static internal options (constant) init (
"More? (RETURN for more; DEL to discard output.)");
%skip(1);
dcl NEWLINE char (1) static internal options (constant) init ("
");
dcl NO_PROMPT bit (1) aligned internal static options (constant) init ("0"b);
dcl NON_NUMERIC_RESPONSE bit (1) aligned static int options (constant) init ("0"b);
dcl NUMERIC_RESPONSE bit (1) aligned static int options (constant) init ("1"b);
%skip(1);
dcl OFF bit (1) aligned static internal options (constant) init ("0"b);
dcl ON bit (1) aligned static internal options (constant) init ("1"b);
%skip(1);
dcl PROMPT bit (1) aligned internal static options (constant) init ("1"b);
%skip(1);
dcl TRANSLATION_TABLE char (63) internal static options (constant) init (
"@ABCDEFGHIJKLMNOPQRSTUVWXYZ1\]^_`abcdefghijklmnopqrstuvwxyz{|}~");
dcl TOP_MARGIN_HEIGHT fixed bin static int options (constant) init (4);
%skip(1);
dcl USER_IO_WINDOW_HEIGHT fixed bin static int options (constant) init (4);
%page;
dcl addr builtin;
%skip(1);
dcl byte builtin;
%skip(1);
dcl code fixed bin (35);
dcl 1 command_level_flags aligned,
      2 reset_sw bit (1) unaligned,
      2 mbx bit (35) unaligned;
dcl convert builtin;
dcl convert_status_code_ entry (fixed bin(35), char(8) aligned, char(100) aligned);
dcl cu_$cl entry (1 aligned, 2 bit(1) unal, 2 bit(35) unal);
%skip(1);
dcl 1 display_results like display_arg_results based (display_results_ptr);
dcl display_results_ptr ptr;
%skip(1);
dcl error_message char (256) varying;
dcl error_table_$end_of_info fixed bin(35) ext static;
dcl error_table_$long_record fixed bin(35) ext static;
%skip(1);
dcl format_document_$string entry (char(*), char(*), fixed bin(21), ptr, fixed bin(35));
dcl function_name char (32);
dcl function_key_sequence char (32);
%skip(1);
dcl hbound builtin;
%skip(1);
dcl index builtin;
dcl ioa_$rsnnl entry() options(variable);
%skip(1);
dcl length builtin;
dcl long_message char (100) aligned;
dcl ltrim builtin;
%skip(1);
dcl max builtin;
dcl min builtin;
%skip(1);
dcl null builtin;
%skip(1);
dcl reason char (64);
dcl 1 report_output_window_position_info like window_position_info based (report_output_window_position_ip);
dcl report_output_window_position_ip ptr;
dcl rtrim builtin;
dcl rw_error_$bad_fkey_name fixed bin(35) ext static;
dcl rw_error_$bad_fkey_sequence fixed bin(35) ext static;
dcl rw_error_$bad_report_display fixed bin(35) ext static;
%skip(1);
dcl sci_ptr ptr;
dcl short_message char (8) aligned;
dcl ssu_$abort_line entry() options(variable);
dcl ssu_$print_message entry() options(variable);
dcl still_in_the_scrolling_business bit (1) aligned;
dcl substr builtin;
dcl switch_name char (42);
dcl sys_info$max_seg_size fixed bin(35) ext static;
%skip(1);
dcl unique_chars_ entry (bit(*)) returns(char(15));
dcl unspec builtin;
dcl 1 user_io_window_position_info like window_position_info based (user_io_window_position_ip);
dcl user_io_window_position_ip ptr;
dcl users_response char (32);
%skip(1);
dcl verify builtin;
dcl video_data_$terminal_iocb ptr static external;
dcl video_et_$insuff_room_for_window fixed bin(35) ext static;
dcl video_et_$window_status_pending fixed bin(35) ext static;
dcl video_utils_$turn_on_login_channel entry (fixed bin(35), char(*));
dcl video_utils_$turn_off_login_channel entry (fixed bin(35));
%skip(1);
dcl window_iocb_ptr ptr;
dcl work_area area (sys_info$max_seg_size) based (work_area_ptr);
dcl work_area_ptr ptr;
%page;
%include format_document_options;
%page;
%include function_key_data;
%page;
%include iocb;
%page;
%include iox_dcls;
%page;
%include rw_display_arg_list;
%page;
%include rw_options_extents;
%page;
%include rw_page_info;
%page;
%include rw_report_info;
%page;
%include rw_scroll_info;
%page;
%include window_control_info;
%page;
%include window_dcls;
%skip(1);
     end rw_display_scroll;
