/****^  ********************************************
        *                                          *
        * Copyright, (C) Honeywell Bull Inc., 1988 *
        *                                          *
        ******************************************** */

/****^  HISTORY COMMENTS:
  1) change(88-09-17,GDixon), approve(88-09-17,MCR7987),
     audit(88-10-03,Beattie), install(88-10-06,MR12.2-1139):
      A) Implement fs_star_, phases 1, as described in MTB781-01.
  2) change(88-09-19,GDixon), approve(88-09-20,MCR8007),
     audit(88-10-03,Beattie), install(88-10-06,MR12.2-1139):
      A) Implement remainder of phase 1, and implement phase 2, as described
         in MTB781-02.
                                                   END HISTORY COMMENTS */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* fs_star_:									 */
/*    The fs_star_ subroutine provides for uniform selection of file system entries, using star	 */
/* names to select and exclude entries with additional selection by entry type.  Multisegment files	 */
/* and archives can be expanded to allow component-by-component processing; directories can be	 */
/* expanded to allow processing of a directory subtree.  Selected entries can be sorted in several	 */
/* different ways, and then passed to a caller-provided handler routine for processing (subtree	 */
/* listing or file initiation, etc).							 */
/*										 */
/* Implementation Notes:								 */
/*    fs_star_ is being implemented in several phases.  For MR12.2, directory star names, and	 */
/* sorting of entries are not yet implemented.  .data_desired = DATA_INITIATE and .entry_type =	 */
/* ENTRY_DONT_SELECT_NULL, ENTRY_DONT_SELECT_NONNULL, ENTRY_DONT_SELECT_OBJECTS,		 */
/* ENTRY_DONT_SELECT_NONOBJECTS, ENTRY_DONT_SELECT_MDIRS, and ENTRY_DONT_SELECT_NONMDIRS are not	 */
/* implemented either.								 */
/*										 */
/*    A decision was made not to document this subroutine for external use by customers until all	 */
/* features were complete.  As a result, the only documentation for the subroutine exists in	 */
/* MTB781-02.  Refer to that MTB for complete details.					 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

fs_star_: 
    procedure();
    return;
	
 						/* PARAMETERS			 */
dcl  Pcaller_name			char(*) parm;	/* caller's name, if we create ssu_.	 */
						/*  (In)				 */
dcl  Pcaller_version		char(*) parm;	/* caller's version, if we create ssu_.	 */
						/*  (In)				 */
dcl  Pcode			fixed bin(35) parm; /* status code. (Out)		 */
dcl  Pssu_sciP			ptr parm;		/* ptr to ssu sci_ptr for this group	 */
						/*  of fs_star_ activations.  If null,	 */
						/*  we will create standalone ssu_	 */
						/*  for the caller. (In)		 */
dcl  Pstar_dataP			ptr parm;		/* ptr to star_data structure. 	 */
						/*  (Out points to star_data.matched)	 */
dcl  Pstar_optionsP			ptr parm;		/* ptr to star_options structure.	 */
						/*  (Out from $init, In to all other eps)*/
dcl  Pstar_options_version		char(8) parm;	/* version of star_options the caller	 */
						/*  is prepared to handle. (In)	 */
dcl  Pstructure_name		char(*) parm;	/* name of structure whose size is to be */
						/*  adjusted. (In)			 */
dcl  Pstructure_version		char(8) parm;	/* name/version of structure for which	 */
						/*  $adjust_structure_size must get	 */
						/*  space.  (In)			 */
dcl  Pnew_size			fixed bin parm;	/* number of elements desired in adjusted*/
						/*  structure.array. (In) 		 */
						/*  =0 ==> make structure array as large */
						/*	 as possible.		 */

						/* AUTOMATIC SCALARS		 */
dcl  code				fixed bin(35) auto;
dcl  ssu_sciP			ptr auto;		/* ssu sci_ptr for our use.		 */
dcl  standalone_invocationS		bit(1) auto;	/* true => fs_star_ had to create a	 */
						/*  standalone invocation of ssu_	 */

dcl  1 struct_header		aligned auto,	/* standard header beginning all structs */
       2 version			char(8),		/*  in fs_star_.incl.pl1, except for	 */
       2 max_count			fixed bin,	/*  star_options.			 */
       2 count			fixed bin;

						/* BASED				 */
dcl  1 epath			aligned based (epathP),
       2 version			char(8),
       2 max_count			fixed bin,
       2 count			fixed bin,
       2 value			(epath_size refer (epath.max_count)),
         3 dir			char(168) unal,
         3 dir_type			fixed bin(2),
         3 dir_uid			bit(36) aligned,
         3 ent			(1) char(32) unal,
         3 ent_type			fixed bin(2),
         3 comp			char(32) unal,
         3 comp_type		fixed bin(2),
     epathP			ptr auto,
     epath_size			fixed bin auto,
     EPATH_VERSION_1		init("EPATH_V1") char(8) int static options(constant);

dcl  1 exn			aligned based (fsd.exnP),
       2 version			char(8),
       2 count			fixed bin,	/* copy of exclude_names structure with	 */
       2 array			(exclude_names.count refer (exn.count)),
         3 value			char(32) unal,	/*  star_type added.		 */
         3 type			fixed bin(2),
     EXN_VERSION_1			init("EXN_VER1") char(8) int static options(constant);

dcl  1 fsd			aligned based(fsdP),/* fs_star_data			 */
       2 version			char(8),		/* = FSD_VERSION_1			 */
       2 next_spaceP		ptr,		/* next free space in star_options seg.	 */
						/*  Used by $select and		 */
						/*  $adjust_structure_size to determine  */
						/*  where to get space for next allocate.*/
       2 we_created_ssuS		bit(1),		/* $init called			 */
						/*  ssu_$standalone_invocation.	 */
       2 fsd_pad			fixed bin,	/* pad to even word boundary.		 */
       2 star_dataP			ptr,		/* ptr to working star_data structure.	 */
       2 archP			ptr,		/* ptr to an archive being read.	 */
       2 epathP			ptr,		/* ptr to epath structure.		 */
       2 mnP			ptr,		/* ptr to mn structure.		 */
       2 exnP			ptr,		/* ptr to exn structure.		 */
       2 temp_segsP			(10) ptr,		/* ptrs to temp segs obtained from ssu_	 */
						/*  that must be released.		 */
       2 areasP			(1) ptr;		/* ptrs to areas obtained from ssu_	 */
						/*  that must be released.		 */
dcl  fsdP				ptr;
dcl  FSD_VERSION_1			init("FSD_VER1") char(8) int static options(constant);

dcl  1 mn				aligned based (fsd.mnP),
       2 version			char(8),
       2 count			fixed bin,	/* copy of match_names structure with	 */
       2 array			(match_names.count refer (mn.count)),
         3 value			char(32) unal,	/*  star_type added for each value.	 */
         3 type			fixed bin(2),
     MN_VERSION_1			init("MN_VER1") char(8) int static options(constant);

dcl  1 sd				aligned like star_data based(star_dataP);

dcl  1 so				aligned like star_options based(star_optionsP);

						/* BUILTINS and CONDITIONS		 */
dcl (addr, addwordno, currentsize, dimension, divide, hbound, lbound, length, ltrim, max, mod, null, 
     pointer, rtrim, search, size, substr, sum, wordno)	
				builtin;
dcl  cleanup			condition;

						/* ENTRIES			 */
dcl  archive_$next_component		entry (ptr, fixed bin(24), ptr, fixed bin(24), char(*),
				     fixed bin(35));
dcl  check_star_name_		entry (char(*), bit(36), fixed bin(2), fixed bin(35));
dcl  cu_$arg_count			entry (fixed bin, fixed bin(35));
dcl  cu_$arg_list_ptr		entry returns(ptr); 
dcl  cu_$arg_ptr			entry (fixed bin, ptr, fixed bin(21), fixed bin(35));
dcl  cu_$generate_call		entry (entry, ptr);
dcl  expand_pathname_$component	entry (char(*), char(*), char(*), char(*), fixed bin(35));
dcl  fs_util_$get_type		entry (char(*), char(*), char(*), fixed bin(35));
dcl  hcs_$get_uid_file		entry (char(*), char(*), bit(36) aligned, fixed bin(35));
dcl  hcs_$star_			entry (char(*), char(*), fixed bin(2), ptr, fixed bin, ptr,
				     ptr, fixed bin(35));
dcl  hcs_$status_			entry (char(*), char(*), fixed bin(1), ptr, ptr,
				     fixed bin(35));
dcl  hcs_$status_minf		entry (char(*), char(*), fixed bin(1), fixed bin(2),
				     fixed bin(24), fixed bin(35));
dcl  hcs_$truncate_seg		entry (ptr, fixed bin(19), fixed bin(35));
dcl  initiate_file_			entry (char(*), char(*), bit(*), ptr, fixed bin(24),
				     fixed bin(35));
dcl  ioa_$general_rs		entry (ptr, fixed bin, fixed bin, char(*), fixed bin(21),
				     bit(1) aligned, bit(1) aligned);
dcl  ioa_$rsnpnnl			entry() options(variable);
dcl  match_star_name_		entry (char(*), char(*), fixed bin(35));
dcl  pathname_			entry (char(*), char(*)) returns(char(168));
dcl  pathname_$component		entry (char(*), char(*), char(*)) returns(char(194));
dcl  ssu_$destroy_invocation		entry (ptr);
dcl  ssu_$get_area			entry (ptr, ptr, char(*), ptr);
dcl  ssu_$get_temp_segment		entry (ptr, char(*), ptr);
dcl  ssu_$null_entry		entry ();
dcl  ssu_$print_message		entry() options(variable);
dcl  ssu_$release_area		entry (ptr, ptr);
dcl  ssu_$release_temp_segment	entry (ptr, ptr);
dcl  ssu_$standalone_invocation	entry (ptr, char(*), char(*), ptr, entry, fixed bin(35));
dcl  sub_err_			entry() options(variable);
dcl  terminate_file_		entry (ptr, fixed bin(24), bit(*), fixed bin(35));

						/* NAMED CONSTANTS			 */
dcl (EP_ADJUST			init(1),
     EP_INIT			init(2),
     EP_REINIT			init(3),
     EP_SELECT			init(4),
     EP_TERM			init(5)) fixed bin int static options(constant);
dcl  EP_NAME			(5) char(32) int static options(constant) init(
				"fs_star_$adjust_structure_size",
				"fs_star_$init",
				"fs_star_$reinit",
				"fs_star_$select",
				"fs_star_$term");
dcl (FALSE			init("0"b),
     TRUE				init("1"b)) bit(1) int static options(constant);
dcl  NO_CHASE			init(0) fixed bin(1) int static options(constant);
dcl  NO_NAMES			init(-1) fixed bin(2) int static options(constant);
dcl (NOT_MSF			init("0"b),
     IS_MSF			init("1"b)) bit(1) int static options(constant);

						/* EXTERNAL STATIC			 */
dcl (error_table_$archive_pathname,
     error_table_$argerr,
     error_table_$fatal_error,
     error_table_$improper_data_format,
     error_table_$inconsistent,
     error_table_$noalloc,
     error_table_$noentry,
     error_table_$nomatch,
     error_table_$nostars,
     error_table_$null_name_component,
     error_table_$root,
     error_table_$smallarg,
     error_table_$too_many_names,
     error_table_$unimplemented_version,
     error_table_$unsupported_operation)
				fixed bin(35) ext static;
dcl  sys_info$max_seg_size		fixed bin(35) ext static;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* check_star_name.incl.pl1								 */
/*   must appear before ARCHIVE_PATH_expand, which uses its constants in label array references.	 */
/*   It is being placed at the beginning of the program for this reason, rather than with the other	 */
/*   include files at the end of the program.						 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

%include check_star_name;

dcl  STAR_TYPE_UNSET		init(-1) fixed bin int static options(constant);

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* ENTRY POINT: adjust_structure_size							 */
/*   $init allocates space only for the star_paths structure.  This entrypoint allocates space for	 */
/*   the exclude_names, extended_entry_types, and match_names structures.  It can also enlarge any	 */
/*   of these structures beyond their current extents.					 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

adjust_structure_size:
    entry (Pstar_optionsP, Pstructure_name, Pstructure_version, Pnew_size, Pcode);

    Pcode = 0;					/* initialize output parm.		 */

    call ENTRY_POINT_setup (EP_ADJUST);			/* access fsd structure.		 */

    call STRUCT_name_version_size_check (Pstructure_name, Pstructure_version, Pnew_size);
						/* make sure structure name and version	 */
						/*  parms match up correctly.		 */

    call STRUCT_allocate (Pstructure_name, Pstructure_version, Pnew_size, EP_ADJUST);
						/* allocate starting location for	 */
						/*  structure we are getting.		 */

ADJUST_EXIT:
    return;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *	 */
/*										 */
/* SUPPORT PROCEDURES for $adjust_structure_size entrypoint					 */
/*										 */
/* SUPPORT PROCEDURE: ADJUST_error							 */
/*   Set Pcode parm and do nonlocal transfer to exit immediately from fs_star_.			 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *	 */

ADJUST_error:
    procedure (Pcode_in);
    
dcl  Pcode_in			fixed bin(35) parm;
    
    if Pcode_in = 0 then return;
    if Pcode = 0 then
       Pcode = Pcode_in;
    go to ADJUST_EXIT;
    end ADJUST_error;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* SUPPORT PROCEDURE: STRUCT_name_version_size_check					 */
/*   Validates that Pstructure_name and Pstructure_version parms correspond with one another.	 */
/*   Checks for a negative structure size.  $adjust_structure_size returns with error codes if	 */
/*   either check fails its criteria.							 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

STRUCT_name_version_size_check:
    procedure (Pstruct_name, Pstruct_version, Pstruct_size);

dcl  Pstruct_name			char(*) parm,
     Pstruct_version		char(8) parm,
     Pstruct_size			fixed bin parm;

    if      Pstruct_name = "exclude_names"	& Pstruct_version = STAR_EXCLUDE_NAMES_VERSION_1 then;
    else if Pstruct_name = "extended_entry_types" & Pstruct_version = STAR_EXTENDED_ENTRY_VERSION_1 then;
    else if Pstruct_name = "match_names"	& Pstruct_version = STAR_MATCH_NAMES_VERSION_1 then;
    else if Pstruct_name = "star_paths"           & Pstruct_version = STAR_PATHS_VERSION_1 then;
    else call ADJUST_error (error_table_$argerr);

    if Pstruct_size < 0 then
       call ADJUST_error (error_table_$smallarg);

    if Pstruct_version = STAR_EXCLUDE_NAMES_VERSION_1 then do;
       if star_options.exclude_namesP ^= null then
	if exclude_names.count > Pstruct_size then
	   call ADJUST_error (error_table_$inconsistent);
       end;
    else if Pstruct_version = STAR_EXTENDED_ENTRY_VERSION_1 then do;
       if star_options.extended_entry_typesP ^= null then
	if extended_entry_types.count > Pstruct_size then
	   call ADJUST_error (error_table_$inconsistent);
       end;
    else if Pstruct_version = STAR_MATCH_NAMES_VERSION_1 then do;
       if star_options.match_namesP ^= null then
	if match_names.count > Pstruct_size then
	   call ADJUST_error (error_table_$inconsistent);
       end;
    else if Pstruct_version = STAR_PATHS_VERSION_1 then do;
       if star_options.star_pathsP ^= null then
	if star_paths.count > Pstruct_size then
	   call ADJUST_error (error_table_$inconsistent);
       end;

    end STRUCT_name_version_size_check;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* ENTRY POINT: init								 */
/*   Initializes storage and functions needed to use fs_star_.  This includes the following steps:	 */
/*										 */
/* 1) Validate the caller-requested version ID.						 */
/* 2) If the caller did not already have an ssu_ invocation, then create one on his behalf for use	 */
/*    by fs_star_.									 */
/* 3) Get the first temporary segment used by fs_star_.  This one will hold the star_options, fsd,	 */
/*    and star_paths structures.							 */
/* 4) Initialize these structures and return them to the caller.				 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

init:
    entry (Pssu_sciP, Pcaller_name, Pcaller_version, Pstar_options_version, Pstar_optionsP, Pcode);

    Pstar_optionsP = null;				/* set output arguments		 */
    Pcode = 0;

    call INIT_cleanup_setup();
    on cleanup call INIT_cleanup();			/* establish cleanup handler.		 */

    if Pstar_options_version = STAR_OPTIONS_VERSION_1 then; /* check for known star_options version	 */
    else call INIT_error (error_table_$unimplemented_version);

    if ssu_sciP = null then do;			/* caller doesn't have its own ssu_	 */
       standalone_invocationS = TRUE;			/*  invocation?  We'll create one.	 */
       call ssu_$standalone_invocation (ssu_sciP, Pcaller_name, Pcaller_version, null, ERROR_unexpected,
	code);
       call INIT_error (code);
       end;

    call ssu_$get_temp_segment (ssu_sciP, "star_options", star_optionsP);
    so.version = STAR_OPTIONS_VERSION_1;		/* create, initialize star_options	 */
    so.caller.ssu_sciP = ssu_sciP;

    call FSD_init();

    so.star_pathsP = null;
    call STRUCT_allocate ("star_paths", STAR_PATHS_VERSION_1, 10, EP_INIT);

    so.selection.path_allow = PATH_ALLOW_ENTRY_STAR_NAMES;	/* continue initialization of		 */
    so.selection.entry_type = ENTRY_RETURN;		/*  star_options structure.		 */
    so.selection.extended_entry_typesP = null;
    so.selection.match_namesP = null;
    so.selection.exclude_namesP = null;

    so.per_entry.sorting = SORT_OFF;
    so.per_entry.handler = ssu_$null_entry;
    so.per_entry.error = ssu_$null_entry;
    so.per_entry.handler_dataP = null;
    so.per_entry.data_desired = DATA_TYPE;
    so.per_entry.data_version = STAR_DATA_VERSION_1;
    so.mbz = ""b;

    Pstar_optionsP = star_optionsP;
    return;

INIT_EXIT:
    call INIT_cleanup();
    Pstar_optionsP = null;
    return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *	 */
/*										 */
/* SUPPORT PROCEDURES for the $init entrypoint:						 */
/*										 */
/* SUPPORT PROCEDURE: INIT_cleanup							 */
/*   cleans up changes which $init made to the runtime environment, in case when $init failed or	 */
/*   was aborted (its activation was released by a nonlocal goto).				 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *	 */

INIT_cleanup:
    procedure;
    if standalone_invocationS then
       call ssu_$destroy_invocation (ssu_sciP);
    else if star_optionsP ^= null then
       call ssu_$release_temp_segment (ssu_sciP, star_optionsP);
    end INIT_cleanup;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* SUPPORT PROCEDURE: INIT_cleanup_setup						 */
/*   initializes variables referenced by the INIT_cleanup routine.				 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

INIT_cleanup_setup:
    procedure;
    standalone_invocationS = FALSE;
    ssu_sciP = Pssu_sciP;
    star_optionsP = null;
    end INIT_cleanup_setup;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* SUPPORT PROCEDURE: INIT_error							 */
/*   routine to check error codes.  If zero, the routine returns.  If nonzero, it sets $init's	 */
/*   Pcode output parm and exits from $init.						 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *	 */

INIT_error:
    procedure (Pcode_in);

dcl  Pcode_in			fixed bin(35) parm;

    if Pcode_in = 0 then return;
    if Pcode = 0 then
       Pcode = Pcode_in;
    go to INIT_EXIT;
    end INIT_error;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* ENTRY POINT: reinit								 */
/*   Frees all allocated space, plus structures associated with star_options (eg, star_paths,	 */
/*   match_names, exclude_names and extended_entry_types structures).  A new star_paths structure	 */
/*   (with 10-element array) is allocated.  All other elements of star_options remain as they were	 */
/*   set prior to the call to $reinit.							 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

reinit:
    entry (Pstar_optionsP);
    
    call ENTRY_POINT_setup (EP_REINIT);

    call FSD_reinit();				/* Reinitialize fs_star_ data.	 */

    star_options.star_pathsP = null;
    call STRUCT_allocate ("star_paths", STAR_PATHS_VERSION_1, 10, EP_REINIT);
    so.selection.extended_entry_typesP = null;		/* Reinitialize star_paths, and get rid	 */
    so.selection.match_namesP = null;			/*  of any other structures associated	 */
    so.selection.exclude_namesP = null;			/*  with the previous selection.	 */
    so.mbz = ""b;

    return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* ENTRY POINT: select								 */
/*   Does the actual section of entries matching the star_options selection criteria.		 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

select:
    entry (Pstar_optionsP, Pstar_dataP, Pcode);

    call ENTRY_POINT_setup (EP_SELECT);			/* access data from input parms.	 */
    Pstar_dataP = null;
    Pcode = 0;					/* set output parms.		 */

    if so.data_version ^= STAR_DATA_VERSION_1 then	/* validate star_options.		 */
       call SELECT_error (error_table_$unimplemented_version,
       "star_options.data_version (=""^a"") must be set to the constant STAR_DATA_VERSION_1 (=""^a"").",
       so.data_version, STAR_DATA_VERSION_1);
    if so.data_desired ^= DATA_TYPE then
       call SELECT_error (error_table_$unsupported_operation,
       "star_options.data_desired (=^d) must be set to the constant DATA_TYPE (=^d).",
       so.data_desired, DATA_TYPE);

    call STRUCT_allocate ("star_data", so.per_entry.data_version, so.per_entry.data_desired, EP_SELECT);
    Pstar_dataP = addr(star_data);			/* allocate space for output structure.	 */

    call STAR_PATHS_evaluate();			/* divide caller-supplied paths into	 */
						/*  dir/ent/arch_comp parts.		 */
						/*  Eliminate duplicate paths too.	 */

    call SELECT_further_init();			/* check out match_names and 		 */
						/*  exclude_names structures.		 */

    call EVAL_PATHS_sort();				/* do an initial sort of the evaluated	 */
						/*  input paths.			 */
    call EVAL_PATHS_expand();				/* expand stars in pathnames and invoke	 */
						/*  caller's handler routine for each 	 */
						/*  entry.			 */

SELECT_EXIT:
    sd.matched.total = sd.matched.current;
    sd.entry_data.type = "";
    sd.entry_data.length = 0;
    sd.entry_data.count = 0;
    sd.entry_data.entryP = null;
    if sd.matched.total = 0 then
       if Pcode = 0 then
	Pcode = error_table_$nomatch;

    return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* SUPPORT PROCEDURES for $select entrypoint:						 */
/*										 */
/* SUPPORT PROCEDURE:  ARCHIVE_PATH_expand						 */
/*   This procedure expands archive segments into components.  The procedure must:		 */
/* 1) Initiate the archive segment.  If the user does not have access to the archive, the caller's	 */
/*    error routine is called to report the error, and expansion stops.			 */
/* 2) Uses archive_$next_component to scan through all components of the archive.		 */
/* 3) For each component, the component name is compared with the user's archive component starname, */
/*    using match_star_name_ when necessary.  Matching components are counted and passed to the	 */
/*    caller's handler routine.  Nonmatching components are skipped.				 */
/* 4) Finally, the archive is terminate.  Note that this procedure does not need its own cleanup on	 */
/*    unit, because fs_star_$term acts as a cleanup on unit (established by the caller), and it will */
/*    terminate the segment if it finds fsd.archP nonnull.					 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

ARCHIVE_PATH_expand:
    procedure (Pdepth, Pfree_areaP, Ppath, Pent, Psort_order);
    
dcl  Pdepth			fixed bin parm;	/* INPUT PARAMETERS			 */
dcl  Pfree_areaP			ptr parm;
dcl  1 Ppath			aligned like epath.value parm;
dcl  Pent				(*) char(32) unal parm;
dcl  Psort_order			fixed bin parm;

						/* AUTOMATIC			 */
dcl  archL			fixed bin(24) auto; /* length of an archive.		 */
dcl  code				fixed bin(35) auto;
dcl  compL			fixed bin(24) auto; /* length of a component		 */
dcl  compP			ptr auto;		/* ptr to a component.		 */
dcl  comp_name			char(32) auto;	/* name of a component.		 */
dcl  snN				fixed bin auto;
dcl  snP				ptr auto;
dcl  sn				(snN) char(32) based (snP);

    fsd.archP = null;
    if Ppath.ent_type ^= STAR_TYPE_MATCHES_EVERYTHING then do;
       status_area_ptr = TEMP_AREA_get();		/* hcs_$star_ returns only entry names 	 */
       status_ptr = addr(auto_status);			/*  which match the star name.  We must	 */
       call hcs_$status_ (Ppath.dir, Pent(1), NO_CHASE,	/*  return all names, so get them now.	 */
	status_ptr, status_area_ptr, code);
       if code = 0 then do;
	snP = addr(status_names);
	snN = dimension(status_names,1);
	end;
       else do;
	snP = addr(Pent);
	snN = dimension(Pent,1);
	end;
       end;
    else do;
       snP = addr(Pent);
       snN = dimension(Pent,1);
       end;

    sd.entry_data.type = ENTRY_TYPE_ARCHIVE;
    call initiate_file_ (Ppath.dir, Pent(1), R_ACCESS, fsd.archP, archL, code);
    call ARCHIVE_PATH_error (Pdepth-1, code, Ppath.dir, sn, "", "initiating archive");
    compP = null;

    if archL = 0 then;
    else do while (TRUE);
       call archive_$next_component (fsd.archP, archL, compP, compL, comp_name, code);
       call ARCHIVE_PATH_error (Pdepth, code, Ppath.dir, sn, "", "reading archive");
       if compP = null then
	go to FINAL_ARCH_ENTRY;
       go to ARCH_NAME (Ppath.comp_type);

ARCH_NAME (STAR_TYPE_USE_PL1_COMPARE):
       if comp_name = Ppath.comp then
	go to MATCHING_ARCH_ENTRY;
       else
	go to NEXT_ARCH_ENTRY;
    
ARCH_NAME (STAR_TYPE_USE_MATCH_PROCEDURE):
       call match_star_name_ (comp_name, Ppath.comp, code);
       if code = 0 then
	go to MATCHING_ARCH_ENTRY;
       else
	go to NEXT_ARCH_ENTRY;

ARCH_NAME (STAR_TYPE_MATCHES_EVERYTHING):
MATCHING_ARCH_ENTRY:
       if ((so.entry_type.arch_comps & ENTRY_DONT_RETURN) = ENTRY_DONT_RETURN) then;
       else do;
	call PATH_MATCH_ENTRY_add (ENTRY_TYPE_ARCHIVE_COMP, Pdepth);
	call ARCHIVE_PATH_handler (Ppath.dir, sn, comp_name);
	end;
       go to NEXT_ARCH_ENTRY;

REMOVE_ARCH_ENTRY:
       call PATH_MATCH_ENTRY_remove();
       go to NEXT_ARCH_ENTRY;

NEXT_ARCH_ENTRY:
       end;

FINAL_ARCH_ENTRY:
    if snP ^= addr(Pent) then
       free status_entry_names in (status_area);
    if fsd.archP ^= null then
       call terminate_file_ (fsd.archP, archL, TERM_FILE_TERM, code);
    return;

REMOVE_ARCH_ENTRY_AND_EXIT:
    call PATH_MATCH_ENTRY_remove();
    go to SELECT_EXIT;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *	 */
/*										 */
/* SUPPORT PROCEDURE: ARCHIVE_PATH_error						 */
/*   If Pcode_in = 0, then return.							 */
/*   Otherwise, expand error message and invoke caller's error handler.			 */
/*   If caller did not provide an error handler, then print error ourselves.			 */
/*   If caller's action code is ERROR_OK or ERROR_REJECT, then continue by processing the next	 */
/*     pathname.									 */
/*   If his action code is ERROR_STOP or ERROR_ABORT, then set Pcode parm of $select and do nonlocal */
/*     transfer to exit immediately from fs_star_.					 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *	 */

ARCHIVE_PATH_error:
    procedure (Pdepth, Pcode_in, Pdir, Pent, Pcomp, Pmessage);

dcl  Pdepth			fixed bin parm;
dcl  Pcode_in			fixed bin(35) parm;
dcl  Pdir				char(*) parm;
dcl  Pent				(*) char(32) unal parm;
dcl  Pcomp			char(32) parm;
dcl  Pmessage			char(*) parm;

dcl  action			fixed bin auto;

    if Pcode_in = 0 then return;

    star_data.entry_data.depth = Pdepth;
    if so.error = ssu_$null_entry then do;		/* caller did NOT provide an error	 */
       call ssu_$print_message (ssu_sciP, Pcode_in, "^[ in ^a ^;^s^]^[^a^s^;^s^a^]^[^/(^a)^;^s^]",
	sd.entry_data.type ^= ENTRY_TYPE_UNKNOWN, ltrim(sd.entry_data.type,"-"),
	Pent(lbound(Pent,1))="", Pdir, pathname_$component (Pdir, Pent(lbound(Pent,1)), Pcomp),
	Pmessage^="", Pmessage);
       action = ERROR_REJECT;
       end;
    else
       call so.error (addr(star_data), Pdir, Pent, Pcomp, Pcode_in, Pmessage, action);

    if sd.entry_data.type = ENTRY_TYPE_ARCHIVE then do;	/* Caller has not begun processing	 */
						/*   archive components.		 */
       if action = ERROR_STOP | action = ERROR_ABORT then	/* Only honor STOP/ABORT action, by 	 */
	go to SELECT_EXIT;				/*  existing fs_star_$select; otherwise	 */
       else go to FINAL_ARCH_ENTRY;			/*  just return to caller, who will 	 */
       end;					/*  continue with next input path.	 */
    
    else do;					/* Caller has begun processing comps.	 */
       if action = ERROR_OK then			/*  Count errant entry.		 */
	go to NEXT_ARCH_ENTRY;
       else if action = ERROR_REJECT then		/*  Remove errant entry from count.	 */
	go to REMOVE_ARCH_ENTRY;
       else if action = ERROR_STOP then			/*  Exit fs_star_$select immediately.	 */
	go to SELECT_EXIT;
       else if action = ERROR_ABORT then		/*  Remove errant entry from count, then */
	go to REMOVE_ARCH_ENTRY_AND_EXIT;		/*   exit fs_star_$select.		 */
       else do;					/*  Unknown action code value.	 */
	call ssu_$print_message (ssu_sciP, error_table_$unsupported_operation,
	   "fs_star_ error routine returned unknown action code (=^d).", action);
	if Pcode = 0 then
	   Pcode = error_table_$unsupported_operation;
	go to SELECT_EXIT;
	end;
       end;
    end ARCHIVE_PATH_error;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* SUPPORT PROCEDURE: ARCHIVE_PATH_handler						 */
/*   This procedure calls the caller-supplied star_options.handler procedure for each selected	 */
/*   entry.  The caller's handler may return an action code which controls how fs_star_ continues	 */
/*   in its processing of the entry.  							 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

ARCHIVE_PATH_handler:
    procedure (Pdir, Pents, Pcomp);

dcl  Pdir				char(168) parm;
dcl  Pents			(*) char(32) unal parm;
dcl  Pcomp			char(32) parm;

dcl  action			fixed bin auto;

    if ^SELECT_further (star_data.entry_data.type, (Pcomp)) then
       go to REMOVE_ARCH_ENTRY;

    call so.handler (addr(star_data), Pdir, Pents, Pcomp, action);

    if action = HANDLER_OK then;
    else if action = HANDLER_REJECT then
       go to REMOVE_ARCH_ENTRY;
    else if action = HANDLER_DONT_EXPAND then;
    else if action = HANDLER_EXPAND then;	
    else if action = HANDLER_EXPAND_DONT_COUNT then
       go to REMOVE_ARCH_ENTRY;
    else if action = HANDLER_DONT_COUNT then
       go to REMOVE_ARCH_ENTRY;
    else if action = HANDLER_STOP then
       go to SELECT_EXIT;
    else if action = HANDLER_ABORT then
       go to REMOVE_ARCH_ENTRY_AND_EXIT;
    else
       call SELECT_error (error_table_$unsupported_operation,
       "fs_star_ handler routine returned unknown action code (=^d).", action);

    end ARCHIVE_PATH_handler;

    end ARCHIVE_PATH_expand;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *	 */
/*										 */
/* SUPPORT PROCEDURE: EVAL_PATHS_expand							 */
/*   For each evaluated, sorted input path, this procedure calls PATH_expand to expand the entry.	 */
/*   It first gets an area pointer from ssu_ for use in calls to hcs_$star_ and			 */
/*   archive_$list_components.							 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *	 */

EVAL_PATHS_expand:
    procedure();

dcl  code				fixed bin(35) auto;
dcl  free_areaP			ptr auto;
dcl  matched_before			fixed bin auto;
dcl  pathX			fixed bin auto;

    free_areaP = TEMP_AREA_get();

    do pathX = lbound (epath.value,1) to epath.count;
       matched_before = sd.matched.current;
       call PATH_expand (1, NOT_MSF, free_areaP, epath.value(pathX), so.sorting.dir_ents(1));
       if sd.matched.current - matched_before = 0 then do;	/* Report nomatch errors only for paths	 */
						/*  caller specified.		 */
	if epath.ent_type(pathX) = STAR_TYPE_USE_PL1_COMPARE then do;
	   call hcs_$status_minf (epath.dir(pathX), epath.ent(pathX,1), NO_CHASE, 0, 0, code);
	   if code = 0 | code = error_table_$root then
	      call PATH_expand_error (1, error_table_$nomatch, epath.value(pathX), NO_NAMES, "", 0);
	   else
	      call PATH_expand_error (1, error_table_$noentry, epath.value(pathX), NO_NAMES, "", 0);
	   end;
	else
	   call PATH_expand_error (1, error_table_$nomatch, epath.value(pathX), NO_NAMES, "", 0);
	end;					/* Only use error_table_$nomatch if	 */
       end;					/*  entry really exists.		 */

    end EVAL_PATHS_expand;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* SUPPORT PROCEDURE: EVAL_PATHS_sort							 */
/*   Sort the input paths, which have been broken in directory/entry/component parts.		 */
/*										 */
/*   This procedure is NOT implemented in phase 1 fs_star_.					 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

EVAL_PATHS_sort:
    procedure();

    end EVAL_PATHS_sort;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* SUPPORT PROCEDURE: PATH_expand							 */
/* 1) expands starnames in the final entry name of a path.  Note that it leaves archive component	 */
/*    starname expansion to ARCHIVE_PATH_expand.						 */
/* 2) For each directory entry selected by the starname, it determines its true type.  For phase 1,	 */
/*    this is usually the standard entry type; if the standard type is a directory, it calls	 */
/*    fs_util_$get_type to determine if the dir is really an MSF or a DM file.			 */
/* 3) It further determines whether that type of entry should be passed along to our caller's	 */
/*    handler routine, should be expanded, etc, based upon star_options, match_names, etc.	 */
/* 4) It calls PATH_handler to pass it to the caller, ARCHIVE_PATH_expand to deal with		 */
/*    archive expansion, and PATH_expand (recursively) to expand directories.			 */
/* 5) Along the way, it counts selected entries.						 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

PATH_expand:
    procedure (Pdepth, Pparent_is_msf, Pfree_areaP, Ppath, Psort_order);
    
dcl  Pdepth			fixed bin parm;	/* INPUT PARAMETERS			 */
dcl  Pparent_is_msf			bit(1) parm;
dcl  Pfree_areaP			ptr parm;
dcl  1 Ppath			aligned like epath.value parm;
dcl  Psort_order			fixed bin parm;

dcl  action			fixed bin auto,	/* AUTOMATIC			 */
     bc				fixed bin(24) auto,
     code				fixed bin(35) auto,
     fs_util_type			char(32),
     nameX			fixed bin auto,
     1 path			aligned like epath.value auto,
     seP				ptr auto,
     snN				fixed bin auto,
     snP				ptr auto,
     starX			fixed bin auto,
     type				fixed bin(2) auto;

						/* BASED				 */
dcl  free_area			area based (Pfree_areaP);
dcl  1 se				aligned like star_entries based(seP);
dcl  sn				(snN) char(32) unal based (snP);

						/* NAMED CONSTANTS			 */
dcl  CHASE			init(1) fixed bin(1) int static options(constant);
dcl  NO_CHASE			init(0) fixed bin(1) int static options(constant);

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* star_structures.incl.pl1								 */
/*   must be included in PATH_expand because PATH_expand is called recursively, and each recursion	 */
/*   needs copies of automatic variables declared in this include file.  It must be included before	 */
/*   the TYPE labels so those label array constants can include named constants declared in this	 */
/*   include file.  For example,  TYPE(star_SEGMENT):					 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

%include star_structures;

dcl (fs_star_ARCHIVE		init(3),		/* NAMED CONSTANTS which add to the dir	 */
     fs_star_MSF			init(4),		/*  entry types defined in the above	 */
     fs_star_MSF_COMP		init(5),		/*  star_structures.incl.pl1, used in 	 */
     fs_star_DM_FILE		init(6),		/*  TYPE label array constants below.	 */
     fs_star_EXTENDED_ENTRY		init(7)
     )				fixed bin int static options(constant);

dcl  1 ROOT_ENTRY			aligned int static options(constant),
       2 type			fixed bin(2) uns unal init(star_DIRECTORY),
       2 nnames			fixed bin(16) uns unal init(1),
       2 nindex			fixed bin(18) uns unal init(1),
     ROOT_NAME			char(32) int static options(constant) init("");
						/* This is information that hcs_$star_   */
						/*  should return about the root (>).    */

    sd.entry_data.type = ENTRY_TYPE_DIRECTORY;		/* Set for use by PATH_error for errors	 */
						/*  reported prior to entering do-group. */

    call hcs_$star_ (Ppath.dir, Ppath.ent(1), star_ALL_ENTRIES, addr(free_area), star_entry_count,
       star_entry_ptr, star_names_ptr, code);		/* Expansion of starname.		 */


    if code = error_table_$nomatch then do;		/* Don't report no_match errors but check*/
       if (Ppath.dir = ">") & (Ppath.ent(1) = "") then do;	/*  for searching the root dir (>)	 */
	star_entry_count = 1;			/* Must fake root dir (>); hcs_$star_	 */
	star_entry_ptr = addr(ROOT_ENTRY);		/*  doesn't understand it as a directory.*/
	star_names_ptr = addr(ROOT_NAME);
	code = 0;
	go to PROCESS_STAR_ENTRIES;
	end;
       end;

    else if code ^= 0 then				/* Report other errors against dir itself*/
       call PATH_error (Pdepth, code, Ppath.dir, "", NO_NAMES, "", "", 0);

    else do;					/* Process entries selected by starname. */
PROCESS_STAR_ENTRIES:
       do starX = 1 to star_entry_count while (Psort_order = SORT_REVERSE),
	  	   star_entry_count to 1 by -1 while (Psort_order ^= SORT_REVERSE);
	seP = addr(star_entries(starX));		/* Overlay entry names MATCHING starname,*/
	snP = addr(star_names(se.nindex));		/*  and data returned by hcs_$star_.	 */
	snN = se.nnames;
	if star_LINK <= se.type | se.type <= star_DIRECTORY then;
	else call PATH_error (Pdepth, error_table_$improper_data_format, Ppath.dir, sn,
	   Ppath.ent_type, "", "hcs_$star_ returned unknown dir entry type (=^d)", (se.type));
	go to TYPE (se.type);			/* Process entries by standard entry type*/
						/*  returned by hcs_$star_, and by	 */
						/*  extended entry types...		 */

TYPE (star_LINK):
	if (so.entry_type.links & ENTRY_DONT_RETURN) = ENTRY_DONT_RETURN then;
	else do;
	   call PATH_MATCH_ENTRY_add (ENTRY_TYPE_LINK, Pdepth);
	   if ((so.entry_type.links & ENTRY_CHASE_ALL_LINKS) = ENTRY_CHASE_ALL_LINKS) then do;
CHASE_LINKS:    call hcs_$status_minf (Ppath.dir, sn(1), CHASE, type, bc, code);
	      call PATH_error (Pdepth, code, Ppath.dir, sn, Ppath.ent_type, "",
	         "calling hcs_$status_minf", 0);
	      if (type = star_LINK) &
	         ((so.entry_type.links & ENTRY_DONT_SELECT_NULL) = ENTRY_DONT_SELECT_NULL) then
	         go to REMOVE_ENTRY;
	      else if (type ^= star_LINK) &
		    ((so.links & ENTRY_DONT_SELECT_NONNULL) = ENTRY_DONT_SELECT_NONNULL) then
	         go to REMOVE_ENTRY;
	      call PATH_MATCH_ENTRY_remove();
	      if star_LINK <= type | type <= star_DIRECTORY then;
	      else call PATH_error (Pdepth, error_table_$improper_data_format, Ppath.dir, sn,
	         Ppath.ent_type, "", "hcs_$status_minf returned unknown dir entry type (=^d)", type);
	      go to TYPE (type);
	      end;
	   else if ((so.entry_type.links & ENTRY_CHASE_NONSTAR_LINKS) = ENTRY_CHASE_NONSTAR_LINKS) &
		 (Ppath.ent_type = STAR_TYPE_USE_PL1_COMPARE) then
	      go to CHASE_LINKS;
	   else do;
	      call PATH_handler (Ppath.dir, sn, Ppath.ent_type, "", action);
	      if action = HANDLER_EXPAND_DONT_COUNT | action = HANDLER_DONT_COUNT then
	         call PATH_MATCH_ENTRY_remove();
	      end;
	   end;
	go to NEXT_ENTRY;
       
TYPE (star_SEGMENT):
	do nameX = lbound(sn,1) to hbound(sn, 1);	/* Is segment an archive?		 */
	   if PATH_suffix (sn(nameX), ".archive") then
	      go to TYPE (fs_star_ARCHIVE);
	   end;
	if Pparent_is_msf then			/* Is is an MSF component?		 */
	   go to TYPE (fs_star_MSF_COMP);
	if ((so.entry_type.segs & ENTRY_INAEE) = ENTRY_INAEE) then do;
	   call fs_util_$get_type (Ppath.dir, sn(1), fs_util_type, code);
	   if code = 0 then
	      if fs_util_type ^= ENTRY_TYPE_SEGMENT then
	         go to TYPE (fs_star_EXTENDED_ENTRY);	/* Only report extended entries if caller*/
	   end;					/*  asked for these.		 */
	if ((so.entry_type.segs & ENTRY_DONT_RETURN) = ENTRY_DONT_RETURN) then;
	else do;
	   call PATH_MATCH_ENTRY_add (ENTRY_TYPE_SEGMENT, Pdepth);
	   call PATH_handler (Ppath.dir, sn, Ppath.ent_type, "", action);
	   if action = HANDLER_EXPAND_DONT_COUNT | action = HANDLER_DONT_COUNT then
	      call PATH_MATCH_ENTRY_remove();
	   end;
	go to NEXT_ENTRY;

TYPE (fs_star_MSF_COMP):
	if ((so.entry_type.msf_comps & ENTRY_DONT_RETURN) = ENTRY_DONT_RETURN) then;
	else do;
	   call PATH_MATCH_ENTRY_add (ENTRY_TYPE_MSF_COMP, Pdepth);
	   call PATH_handler (Ppath.dir, sn, Ppath.ent_type, "", action);
	   if action = HANDLER_EXPAND_DONT_COUNT | action = HANDLER_DONT_COUNT then
	      call PATH_MATCH_ENTRY_remove();
	   end;
	go to NEXT_ENTRY;

TYPE (fs_star_ARCHIVE):
	if ((so.entry_type.archives & ENTRY_DONT_RETURN) = ENTRY_DONT_RETURN) then
	   action = HANDLER_OK;
	else do;
	   call PATH_MATCH_ENTRY_add (ENTRY_TYPE_ARCHIVE, Pdepth);
	   call PATH_handler (Ppath.dir, sn, Ppath.ent_type, "", action);
	   if action = HANDLER_EXPAND_DONT_COUNT | action = HANDLER_DONT_COUNT then
	      call PATH_MATCH_ENTRY_remove();
	   end;
	if (((so.entry_type.archives & ENTRY_LIST_SUBENTRIES) = ENTRY_LIST_SUBENTRIES) &
	   (action ^= HANDLER_DONT_EXPAND)) |
	   (action = HANDLER_EXPAND) | (action = HANDLER_EXPAND_DONT_COUNT) then do;
	   path = Ppath;
	   path.ent(1) = sn(nameX);
	   path.ent_type = STAR_TYPE_USE_PL1_COMPARE;
	   if path.comp = "" then do;
	      path.comp = "**";
	      path.comp_type = STAR_TYPE_MATCHES_EVERYTHING;
	      end;
	   call ARCHIVE_PATH_expand (Pdepth+1, addr(free_area), path, sn, Psort_order);
	   end;
	go to NEXT_ENTRY;

TYPE (star_DIRECTORY):
	call fs_util_$get_type (Ppath.dir, sn(1), fs_util_type, code);
	if code = 0 then do;			/* We could determine if a dir is really */
	   if fs_util_type = ENTRY_TYPE_MSF then	/*  an MSF or DM file, but fs_util_ does */
	      go to TYPE (fs_star_MSF);		/*  it better.  Don't reinvent the wheel.*/
	   if fs_util_type = ENTRY_TYPE_DM_FILE then
	      go to TYPE (fs_star_DM_FILE);
	   if ((so.entry_type.dirs & ENTRY_INAEE) = ENTRY_INAEE) then
	      if fs_util_type ^= ENTRY_TYPE_DIRECTORY then
	         go to TYPE (fs_star_EXTENDED_ENTRY);	/* Only report extended entries if caller*/
	   end;					/*  asked for these.		 */
	if ((so.entry_type.dirs & ENTRY_DONT_RETURN) = ENTRY_DONT_RETURN) then
	   action = HANDLER_OK;			/* Report directory to caller.	 */
	else do;
	   call PATH_MATCH_ENTRY_add (ENTRY_TYPE_DIRECTORY, Pdepth);
	   call PATH_handler (Ppath.dir, sn, Ppath.ent_type, "", action);
	   if action = HANDLER_EXPAND_DONT_COUNT | action = HANDLER_DONT_COUNT then
	      call PATH_MATCH_ENTRY_remove();
	   end;
	if (((so.entry_type.dirs & ENTRY_LIST_SUBENTRIES) = ENTRY_LIST_SUBENTRIES) &
	   (action ^= HANDLER_DONT_EXPAND)) |		/* Expand, if caller asked us to.	 */
	   (action = HANDLER_EXPAND) | (action = HANDLER_EXPAND_DONT_COUNT) then do;
	   path.dir =  rtrim(pathname_(Ppath.dir, sn(1)));
	   path.dir_type = STAR_TYPE_USE_PL1_COMPARE;
	   path.dir_uid = ""b;
	   path.ent(1) = "**";
	   path.ent_type = STAR_TYPE_MATCHES_EVERYTHING;
	   path.comp = "";
	   path.comp_type = STAR_TYPE_USE_PL1_COMPARE;
	   call PATH_expand (Pdepth+1, NOT_MSF, Pfree_areaP, path, Psort_order);
	   end;
	go to NEXT_ENTRY;

TYPE (fs_star_MSF):
	if ((so.entry_type.msfs & ENTRY_DONT_RETURN) = ENTRY_DONT_RETURN) then 
	   action = HANDLER_OK;
	else do;
	   call PATH_MATCH_ENTRY_add (ENTRY_TYPE_MSF, Pdepth);
	   call PATH_handler (Ppath.dir, sn, Ppath.ent_type, "", action);
	   if action = HANDLER_EXPAND_DONT_COUNT | action = HANDLER_DONT_COUNT then
	      call PATH_MATCH_ENTRY_remove();
	   end;
	if (((so.entry_type.msfs & ENTRY_LIST_SUBENTRIES) = ENTRY_LIST_SUBENTRIES) &
	   (action ^= HANDLER_DONT_EXPAND)) |
	   (action = HANDLER_EXPAND) | (action = HANDLER_EXPAND_DONT_COUNT) then do;
	   path.dir =  rtrim(pathname_(Ppath.dir, sn(1)));
	   path.dir_type = STAR_TYPE_USE_PL1_COMPARE;
	   path.dir_uid = ""b;
	   path.ent(1) = "**";
	   path.ent_type = STAR_TYPE_MATCHES_EVERYTHING;
	   path.comp = "";
	   path.comp_type = STAR_TYPE_USE_PL1_COMPARE;
	   call PATH_expand (Pdepth+1, IS_MSF, Pfree_areaP, path, Psort_order);
	   end;
	go to NEXT_ENTRY;

TYPE (fs_star_DM_FILE):
	if ((so.entry_type.dm_files & ENTRY_DONT_RETURN) = ENTRY_DONT_RETURN) then 
	   go to NEXT_ENTRY;
	call PATH_MATCH_ENTRY_add (ENTRY_TYPE_DM_FILE, Pdepth);
	call PATH_handler (Ppath.dir, sn, Ppath.ent_type, "", action);
	if action = HANDLER_EXPAND_DONT_COUNT | action = HANDLER_DONT_COUNT then
	   call PATH_MATCH_ENTRY_remove();
	go to NEXT_ENTRY;

TYPE (fs_star_EXTENDED_ENTRY):
	if ((so.entry_type.extended_entries & ENTRY_DONT_RETURN) = ENTRY_DONT_RETURN) then 
	   go to NEXT_ENTRY;
	call PATH_MATCH_ENTRY_add (fs_util_type, Pdepth);
	call PATH_handler (Ppath.dir, sn, Ppath.ent_type, "", action);
	if action = HANDLER_EXPAND_DONT_COUNT | action = HANDLER_DONT_COUNT then
	   call PATH_MATCH_ENTRY_remove();
	go to NEXT_ENTRY;	

REMOVE_ENTRY:
	call PATH_MATCH_ENTRY_remove();

NEXT_ENTRY:
	end;

       if star_names_ptr ^= addr(ROOT_NAME) then do;
	if star_names_ptr ^= null then
	   free star_names in (free_area);
	if star_entry_ptr ^= null then
	   free star_entries in (free_area);
	end;
       end;
    return;

REMOVE_ENTRY_AND_EXIT:
    call PATH_MATCH_ENTRY_remove();
    go to SELECT_EXIT;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

PATH_expand_error:
    entry (Pdepth, Pcode_in, Ppath, Pent_type, Pmessage, Pioa_arg);

dcl  Pcode_in			fixed bin(35) parm;
dcl  Pent_type			fixed bin(2) parm;
dcl  Pmessage			char(*) parm;
dcl  Pioa_arg			fixed bin(2) parm;

    call PATH_error (Pdepth, Pcode_in, Ppath.dir, Ppath.ent, Pent_type, Ppath.comp, Pmessage, Pioa_arg);
    return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *	 */
/*										 */
/* SUPPORT PROCEDURE: PATH_error							 */
/*   If Pcode_in = 0, then return.							 */
/*   Otherwise, expand error message and invoke caller's error handler.			 */
/*   If caller did not provide an error handler, then print error ourselves.			 */
/*   If caller's action code is ERROR_OK or ERROR_REJECT, then continue by processing the next	 */
/*     pathname.									 */
/*   If his action code is ERROR_STOP or ERROR_ABORT, then set Pcode parm of $select and do nonlocal */
/*     transfer to exit immediately from fs_star_.					 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *	 */

PATH_error:
    procedure (Pdepth, Pcode_in, Pdir, Pent, Pent_type, Pcomp, Pmessage, Pioa_arg);

dcl  Pdepth			fixed bin parm;
dcl  Pcode_in			fixed bin(35) parm;
dcl  Pdir				char(*) parm;
dcl  Pent				(*) char(32) unal parm;
dcl  Pent_type			fixed bin(2) parm;
dcl  Pcomp			char(32) parm;
dcl  Pmessage			char(*) parm;
dcl  Pioa_arg			fixed bin(2) parm;

dcl  action			fixed bin auto;
dcl  code				fixed bin(35) auto;
dcl  expanded_message		char(200) varying;

    if Pcode_in = 0 then return;

    star_data.entry_data.depth = Pdepth;
    call ioa_$rsnpnnl (Pmessage, expanded_message, 0, Pioa_arg);

    if so.error = ssu_$null_entry then do;		/* caller did NOT provide an error	 */
       call ssu_$print_message (ssu_sciP, Pcode_in, "^[ in ^a ^;^s^]^[^a^s^;^s^a^]^[^/(^a)^;^s^]",
	sd.entry_data.type ^= ENTRY_TYPE_UNKNOWN, ltrim(sd.entry_data.type,"-"),
	Pent(lbound(Pent,1))="", Pdir, pathname_$component (Pdir, Pent(lbound(Pent,1)), Pcomp),
	expanded_message^="", expanded_message);
       action = ERROR_REJECT;
       end;
    else do; 
       if Pent_type = NO_NAMES | Pent_type = STAR_TYPE_MATCHES_EVERYTHING then do;
	call so.error (addr(star_data), Pdir, Pent, Pcomp, Pcode_in, (expanded_message), action);
	end;
       else do;					/* hcs_$star_ returns only entry names 	 */
	status_area_ptr = TEMP_AREA_get();		/*  which match the star name.  We must	 */
	status_ptr = addr(auto_status);		/*  return all names, so get them now.	 */
	call hcs_$status_ (Pdir, Pent(1), NO_CHASE, status_ptr, status_area_ptr, code);
	if code = 0 then do;
	   call so.error (addr(star_data), Pdir, status_names, Pcomp, Pcode_in,
	      (expanded_message), action);
	   free status_entry_names in (status_area);
	   end;
	else
	   call so.error (addr(star_data), Pdir, Pent, Pcomp, Pcode_in, (expanded_message), action);
	end;
       end;

    if Pent_type = NO_NAMES then do;			/* Caller has not entered do-group to	 */
						/*  process entries from hcs_$star_.	 */
       if action = ERROR_STOP | action = ERROR_ABORT then	/* Only honor STOP/ABORT action, by 	 */
	go to SELECT_EXIT;				/*  exiting fs_star_$select; otherwise	 */
       else return;					/*  just return to caller, who will 	 */
       end;					/*  continue with next input path.	 */
    
    else do;					/* Caller has entered do-group.	 */
       if action = ERROR_OK then			/*  Count errant entry.		 */
	go to NEXT_ENTRY;
       else if action = ERROR_REJECT then		/*  Remove errant entry from count.	 */
	go to REMOVE_ENTRY;
       else if action = ERROR_STOP then			/*  Exit fs_star_$select immediately.	 */
	go to SELECT_EXIT;
       else if action = ERROR_ABORT then		/*  Remove errant entry from count, then */
	go to REMOVE_ENTRY_AND_EXIT;			/*   exit fs_star_$select.		 */
       else do;					/*  Unknown action code value.	 */
	call ssu_$print_message (ssu_sciP, error_table_$unsupported_operation,
	   "fs_star_ error routine returned unknown action code (=^d).", action);
	if Pcode = 0 then
	   Pcode = error_table_$unsupported_operation;
	go to SELECT_EXIT;
	end;
       end;
    end PATH_error;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* SUPPORT PROCEDURE: PATH_handler							 */
/*   This procedure calls the caller-supplied star_options.handler procedure for each selected	 */
/*   entry.  The caller's handler may return an action code which controls how fs_star_ continues	 */
/*   in its processing of the entry.  Every PATH_handler caller must handle the following actions	 */
/*   in a manner appropriate to the type of entry:					 */
/*      HANDLER_DONT_EXPAND								 */
/*        no error, but handler does not want dir/archive/msf expanded.			 */
/*      HANDLER_EXPAND								 */
/*        no error, but expand dir/archive/msf even if this is contrary to what			 */
/*	star_options.entry_type says for this type of entry.				 */
/*      HANDLER_EXPAND_DONT_COUNT							 */
/*        no error, but handler does not accept the entry.  It should not be counted but should be	 */
/*	expanded.									 */
/*      HANDLER_DONT_COUNT								 */
/*        no error, but handler does not want entry counted.  Expansion depends upon what		 */
/*	star_options.entry_type says for this type of entry.				 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

PATH_handler:
    procedure (Pdir, Pents, Pent_type, Pcomp, Paction);

dcl  Pdir				char(168) parm;
dcl  Pents			(*) char(32) unal parm;
dcl  Pent_type			fixed bin(2) parm;
dcl  Pcomp			char(32) parm;
dcl  Paction			fixed bin parm;
dcl  code				fixed bin(35) auto;

    if Pent_type = NO_NAMES | Pent_type = STAR_TYPE_MATCHES_EVERYTHING then do;
       if ^SELECT_further (star_data.entry_data.type, Pents) then
	Paction = HANDLER_DONT_COUNT;
       else
	call so.handler (addr(star_data), Pdir, Pents, Pcomp, Paction);
       end;
    else do;					/* hcs_$star_ returns only names which	 */
       status_area_ptr = TEMP_AREA_get();		/*  match the star name.  We must return */
       status_ptr = addr(auto_status);			/*  all names, so get them now.	 */
       call hcs_$status_ (Pdir, Pents(1), NO_CHASE, status_ptr, status_area_ptr, code);
       if code = 0 then do;
	if ^SELECT_further (star_data.entry_data.type, status_names) then
	   Paction = HANDLER_DONT_COUNT;
	else 
	   call so.handler (addr(star_data), Pdir, status_names, Pcomp, Paction);
	free status_entry_names in (status_area);
	end;
       else do;
	if ^SELECT_further (star_data.entry_data.type, Pents) then
	   Paction = HANDLER_DONT_COUNT;
	else
	   call so.handler (addr(star_data), Pdir, Pents, Pcomp, Paction);
	end;
       end;

    if Paction = HANDLER_OK then
       return;
    else if Paction = HANDLER_REJECT then
       go to REMOVE_ENTRY;
    else if Paction = HANDLER_DONT_EXPAND then;		/* These 4 action codes must be 	 */
    else if Paction = HANDLER_EXPAND then;		/*  handled by			 */
    else if Paction = HANDLER_EXPAND_DONT_COUNT then;	/*  each caller of			 */
    else if Paction = HANDLER_DONT_COUNT then;		/*  PATH_handler.			 */
    else if Paction = HANDLER_STOP then
       go to SELECT_EXIT;
    else if Paction = HANDLER_ABORT then
       go to REMOVE_ENTRY_AND_EXIT;
    else
       call SELECT_error (error_table_$unsupported_operation,
       "fs_star_ handler routine returned unknown action code (=^d).", Paction);

    end PATH_handler;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* SUPPORT PROCEDURE:  PATH_suffix							 */
/*   This procedure determines whether a given entry name ends in a given suffix (eg, .archive).	 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

PATH_suffix:
    procedure (Pname, Psuffix) returns (bit(1) aligned);

dcl  Pname			char(32) unal parm;
dcl  Psuffix			char(*) parm;
    
dcl  nameL			fixed bin auto;
dcl  suffixL			fixed bin auto;
dcl  suffixI			fixed bin auto;

    nameL = length (rtrim (Pname));
    suffixL = length (rtrim (Psuffix));
    suffixI = max(1, nameL - suffixL + 1);
    if substr(Pname, suffixI) = substr(Psuffix, 1, suffixL) then
       return (TRUE);
    else
       return (FALSE);
    end PATH_suffix;

    end PATH_expand;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* SUPPORT PROCEDURES:  PATH_MATCH_ENTRY_add, PATH_MATCH_ENTRY_remove				 */
/*   These procedure entry points add/remove the current entry to the entry counts in		 */
/* star_data.matched.  _add takes an Pentry_type parameter, stores it in star_data.entry_data.type,	 */
/* and then increments the corresponding element of star_data.matched.  _remove uses		 */
/* star_data.entry_data.type to decrement the corresponding element of star_data.matched.		 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

PATH_MATCH_ENTRY_add:
    procedure (Pentry_type, Pdepth);
    
dcl  Pentry_type			char(32) unal parm;
dcl  Pdepth			fixed bin parm;

dcl  addend			fixed bin auto;
dcl  entry_type			char(32) auto;

    entry_type, sd.entry_data.type = Pentry_type;
    sd.entry_data.depth = Pdepth;
    addend = +1;
    go to SET_MATCHED;
    
PATH_MATCH_ENTRY_remove:
    entry;
    
    entry_type = sd.entry_data.type;
    sd.entry_data.type = ENTRY_TYPE_UNSET;
    addend = -1;
    go to SET_MATCHED;

SET_MATCHED:
    sd.matched.current = sd.matched.current + addend;
    if entry_type = ENTRY_TYPE_LINK then
       sd.matched.links = sd.matched.links + addend;
    else if entry_type = ENTRY_TYPE_SEGMENT then
       sd.matched.segs = sd.matched.segs + addend;
    else if entry_type = ENTRY_TYPE_DIRECTORY then
       sd.matched.dirs = sd.matched.dirs + addend;
    else if entry_type = ENTRY_TYPE_MSF then
       sd.matched.msfs = sd.matched.msfs + addend;
    else if entry_type = ENTRY_TYPE_MSF_COMP then
       sd.matched.msf_comps = sd.matched.msf_comps + addend;
    else if entry_type = ENTRY_TYPE_DM_FILE then
       sd.matched.dm_files = sd.matched.dm_files + addend;
    else if entry_type = ENTRY_TYPE_ARCHIVE then
       sd.matched.archives = sd.matched.archives + addend;
    else if entry_type = ENTRY_TYPE_ARCHIVE_COMP then
       sd.matched.arch_comps = sd.matched.arch_comps + addend;
    else
       sd.matched.extended_entries = sd.matched.extended_entries + addend;

    end PATH_MATCH_ENTRY_add;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* SUPPORT PROCEDURE: SELECT_error							 */
/*   If Pcode_in = 0, then return.							 */
/*   Otherwise, expand error message and invoke caller's error handler.  Ignore his action code,	 */
/*     since calls to SELECT_error are always immediately fatal.				 */
/*   If caller did not provide an error handler, then print error ourselves.			 */
/*   Set Pcode parm of $select and do nonlocal transfer to exit immediately from fs_star_.	 */
/*										 */
/* Syntax:  call SELECT_error (code, IOA_CTL_STR, args);					 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

SELECT_error:
    procedure options(variable);

dcl  Pcode_inP			ptr auto;		/* AUTOMATIC			 */
dcl  action			fixed bin auto;
dcl  code				fixed bin(35) auto;
dcl  message_space			char(500);
dcl  message_len			fixed bin(21);

						/* BASED				 */
dcl  Pcode_in			fixed bin(35) based (Pcode_inP);
dcl  message			char (message_len) based (addr(message_space));

						/* NAMED CONSTANTS			 */
dcl (DONT_PAD, DONT_NL)		init ("0"b) bit(1) aligned int static options(constant);

    call cu_$arg_ptr (1, Pcode_inP, 0, code);
    if Pcode_in = 0 then return;

    call ioa_$general_rs (cu_$arg_list_ptr(), 2, 3, message_space, message_len, DONT_PAD, DONT_NL);

    if so.error = ssu_$null_entry then 
       call ssu_$print_message (ssu_sciP, Pcode_in, message);
    else
       call so.error (addr(star_data), "", "", "", Pcode_in, message, action);
						/* Ignore action here, since all calls	 */
						/* to this procedure are fatal if 	 */
						/* Pcode_in is nonzero.		 */
   if Pcode = 0 then
       Pcode = Pcode_in;
    go to SELECT_EXIT;
    end SELECT_error;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* SUPPORT PROCEDURE: SELECT_further							 */
/*   This function makes further checks on selected entries to determine whether they are selected	 */
/* by values in the match_names structure, excluded by values in the exclude_names structure, and	 */
/* selected by values in the extended_entry_types structure.				 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

SELECT_further:
    procedure (Pentry_type, Pnames) returns(bit(1) aligned);

dcl  Pentry_type			char(32) unal parm;
dcl  Pnames			(*) char(32) unal parm;

dcl (nameX, matchX)			fixed bin auto;

    if fsd.mnP ^= null then do;
       do nameX = lbound(Pnames,1) to hbound(Pnames,1);
	do matchX = lbound(mn.value,1) to hbound(mn.value,1);
	   go to MATCH(mn.type(matchX));
	   
MATCH (STAR_TYPE_USE_PL1_COMPARE):
	   if Pnames(nameX) = mn.value(matchX) then
	      go to MATCH_FOUND;
	   go to MATCH_NEXT;

MATCH (STAR_TYPE_USE_MATCH_PROCEDURE):
	   call match_star_name_ (Pnames(nameX), mn.value(matchX), code);
	   if code = 0 then
	      go to MATCH_FOUND;
	   go to MATCH_NEXT;
	   
MATCH_NEXT:  end;
	end;
       return (FALSE);
       end;
MATCH_FOUND:
MATCH (STAR_TYPE_MATCHES_EVERYTHING):

    if fsd.exnP ^= null then do;
       do nameX = lbound(Pnames,1) to hbound(Pnames,1);
	do matchX = lbound(exn.value,1) to hbound(exn.value,1);
	   go to EXCL(exn.type(matchX));
	   
EXCL (STAR_TYPE_USE_PL1_COMPARE):
	   if Pnames(nameX) = exn.value(matchX) then
	      go to EXCL_FOUND;
	   go to EXCL_NEXT;

EXCL (STAR_TYPE_USE_MATCH_PROCEDURE):
	   call match_star_name_ (Pnames(nameX), exn.value(matchX), code);
	   if code = 0 then
	      go to EXCL_FOUND;
	   go to EXCL_NEXT;
	   
EXCL_NEXT:   end;
	end;
       go to EXCL_NOT_FOUND;
EXCL_FOUND:
EXCL (STAR_TYPE_MATCHES_EVERYTHING):
       return (FALSE);
       end;
EXCL_NOT_FOUND:

    if so.extended_entry_typesP ^= null then do;
       if extended_entry_types.count > 0 then do;
	do matchX = lbound(extended_entry_types.value,1) to extended_entry_types.count;
	   if Pentry_type = extended_entry_types.value(matchX) then
	      go to ET_OK;
	   end;
	return (FALSE);
	end;
       end;
ET_OK:
    return (TRUE);

    end SELECT_further;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* SELECT_further_init:								 */
/*   This procedure copies match_names.value and exclude_names.value arrays into mn and exn	 */
/* structures, in order to associate a starname type with each array element.  Any errors in format	 */
/* of the star names are reported via SELECT_error.					 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

SELECT_further_init:
    procedure();

dcl  code				fixed bin(35) auto;
dcl  matchX			fixed bin auto;

    if so.exclude_namesP ^= null then do;
       if exclude_names.version ^= STAR_EXCLUDE_NAMES_VERSION_1 then
	call SELECT_error (error_table_$unimplemented_version,
	   "exclude_names.version (=""^a"") must be STAR_EXCLUDE_NAMES_VERSION_1 (=""^a"").",
	   exclude_names.version, STAR_EXCLUDE_NAMES_VERSION_1);
       if exclude_names.count > 0 then do;
	call STRUCT_allocate ("exn", EXN_VERSION_1, exclude_names.count, EP_SELECT);
	do matchX = lbound(exn.array,1) to hbound(exn.array,1);
	   exn.value(matchX) = exclude_names.value(matchX);
	   call check_star_name_ (exn.value(matchX), CHECK_STAR_ENTRY_DEFAULT, exn.type(matchX),code);
	   call SELECT_error (code, "Invalid exclude_names.value ^a", exn.value(matchX));
	   end;
	end;
       end;

    if so.match_namesP ^= null then do;
       if match_names.version ^= STAR_MATCH_NAMES_VERSION_1 then
	call SELECT_error (error_table_$unimplemented_version,
	   "match_names.version (=""^a"") must be STAR_MATCH_NAMES_VERSION_1 (=""^a"").",
	   match_names.version, STAR_MATCH_NAMES_VERSION_1);
       if match_names.count > 0 then do;
	call STRUCT_allocate ("mn", MN_VERSION_1, match_names.count, EP_SELECT);
	do matchX = lbound(mn.array,1) to hbound(mn.array,1);
	   mn.value(matchX) = match_names.value(matchX);
	   call check_star_name_ (mn.value(matchX), CHECK_STAR_ENTRY_DEFAULT, mn.type(matchX), code);
	   call SELECT_error (code, "Invalid match_names.value ^a", mn.value(matchX));
	   end;
	end;
       end;

    if so.extended_entry_typesP ^= null then do;
       if extended_entry_types.version ^= STAR_EXTENDED_ENTRY_VERSION_1 then
	call SELECT_error (error_table_$unimplemented_version,
	   "extended_entry_types.version (=""^a"") must be STAR_EXTENDED_ENTRY_VERSION_1(=""^a"").",
	   extended_entry_types.version, STAR_EXTENDED_ENTRY_VERSION_1);
       end;

    end SELECT_further_init;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* SUPPORT PROCEDURE: STAR_PATHS_evaluate						 */
/*   Procedure which analyzes incoming star_paths.value array, expanding each pathname, breaking it	 */
/*   down into dir/ent/arch_comp parts, determining the star-type of each part, etc.  Directory star */
/*   names are not fully supported; archive component names are rejected, though full analysis	 */
/*   support for archive component names IS provided below.  (It is missing in other internal	 */
/*   procedures, however.)  Duplicate pathnames are eliminated, as final step in the evaluation.	 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

STAR_PATHS_evaluate:
    procedure();

dcl  code				fixed bin(35) auto,
    (pathX, prevX, star_pathX)	fixed bin auto;

    if ((so.path_allow & PATH_ALLOW_DIR_STAR_NAMES) = PATH_ALLOW_DIR_STAR_NAMES) then
						/* diagnose path support not implemented */
						/* in phase 1.			 */
       call SELECT_error (error_table_$unsupported_operation,
	"star_options.path_allow does not support directory star names.");

    if so.star_pathsP = null then			/* diagnose input pathname errors	 */
       call SELECT_error (error_table_$argerr, "star_options.star_pathsP is a null pointer.");
    if star_paths.count > star_paths.max_count then
       call SELECT_error (error_table_$inconsistent,
         "star_paths.count (=^d) > star_paths.max_count (=^d)", star_paths.count, star_paths.max_count);
    if star_paths.count <= 0 then
       call SELECT_error (error_table_$argerr,
         "star_paths.count (=^d) must be positive.", star_paths.count);

    call STRUCT_allocate ("evaluated_paths", EPATH_VERSION_1, star_paths.count, EP_SELECT);

    call STAR_PATHS_error_init();
    
    pathX = 0;
    do star_pathX = lbound(star_paths.value,1) to star_paths.count;
       epath.count, pathX = pathX + 1;
       call expand_pathname_$component (star_paths.value(star_pathX), epath.dir(pathX),
	epath.ent(pathX,1), epath.comp(pathX), code);
       call STAR_PATHS_error (code, ENTRY_TYPE_UNKNOWN, star_paths.value(star_pathX), "", "", "");


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* Directory star names (ie, stars in any directory entry name except the last) are not fully	 */
/* implemented in phase 1 of fs_star_.  When implemented, dir stars should probably be expanded	 */
/* here.  This would mean the epath.value array could be larger than star_path.value.  Its size will */
/* have to be increased (to full seg) above, epath.count will have to be compared to		 */
/* epath.max_count, and structure size will have to be adjusted downward once all epath entries are	 */
/* set.										 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

       if (search(epath.dir(pathX), "*?") > 0) &
	^((so.path_allow & PATH_ALLOW_DIR_STAR_NAMES) = PATH_ALLOW_DIR_STAR_NAMES) then do;
	epath.dir_type(pathX) = STAR_TYPE_USE_MATCH_PROCEDURE;
	call STAR_PATHS_error (error_table_$nostars, ENTRY_TYPE_UNKNOWN,
	   epath.dir(pathX), epath.ent(pathX,*), epath.comp(pathX), "invalid directory star name");
	end;
       else
	epath.dir_type(pathX) = STAR_TYPE_USE_PL1_COMPARE;
       call hcs_$get_uid_file (epath.dir(pathX), "", epath.dir_uid(pathX), code);
       if code = error_table_$root then
	epath.dir_uid(pathX) = "777777777777"b3;
       else 
	call STAR_PATHS_error (code, ENTRY_TYPE_UNKNOWN, epath.dir(pathX), "", "", "");

       call check_star_name_ (epath.ent(pathX,1), CHECK_STAR_ENTRY_DEFAULT, epath.ent_type(pathX),
	code);
       if (code = error_table_$null_name_component) & (epath.dir(pathX) = ">") then
	epath.ent_type(pathX) = STAR_TYPE_USE_PL1_COMPARE;
       else
	call STAR_PATHS_error (code, ENTRY_TYPE_UNKNOWN, epath.dir(pathX), epath.ent(pathX,*),
	   epath.comp(pathX), "invalid entryname");
       if (epath.ent_type(pathX) ^= STAR_TYPE_USE_PL1_COMPARE) &
	^((so.path_allow & PATH_ALLOW_ENTRY_STAR_NAMES) = PATH_ALLOW_ENTRY_STAR_NAMES) then
	   call STAR_PATHS_error (error_table_$nostars, ENTRY_TYPE_UNKNOWN,
	      epath.dir(pathX), epath.ent(pathX,*), epath.comp(pathX), "invalid entryname");

       if epath.comp(pathX) ^= "" then do;
	if ^((so.path_allow & PATH_ALLOW_ARCHIVE_COMPONENTS) = PATH_ALLOW_ARCHIVE_COMPONENTS) then
	   call STAR_PATHS_error (error_table_$archive_pathname, ENTRY_TYPE_UNKNOWN,
	      epath.dir(pathX), epath.ent(pathX,*), epath.comp(pathX), "");
	call check_star_name_ (epath.comp(pathX), CHECK_STAR_ENTRY_DEFAULT,
	   epath.comp_type(pathX), code);
	call STAR_PATHS_error (code, ENTRY_TYPE_UNKNOWN, epath.dir(pathX),
	   epath.ent(pathX,*), epath.comp(pathX), "invalid archive component name");
	if (epath.comp_type(pathX) ^= STAR_TYPE_USE_PL1_COMPARE) &
	   ^((so.path_allow & PATH_ALLOW_ARCHIVE_COMP_STAR_NAMES) = PATH_ALLOW_ARCHIVE_COMP_STAR_NAMES) then
	   call STAR_PATHS_error (code, ENTRY_TYPE_UNKNOWN, epath.dir(pathX), epath.ent(pathX,*),
	      epath.comp(pathX), "invalid archive star name");
	end;
       else
	epath.comp_type(pathX) = STAR_TYPE_USE_PL1_COMPARE;

       do prevX = lbound(epath.value,1) to pathX-1;	/* eliminate dup dir/ent/comp names	 */
	if epath.dir_uid(prevX) = epath.dir_uid(pathX) then do;
	   if epath.ent(prevX,1)  = epath.ent(pathX,1) |
	     (epath.ent_type(prevX) = STAR_TYPE_MATCHES_EVERYTHING &
	      epath.ent_type(pathX) = STAR_TYPE_MATCHES_EVERYTHING) then do;
	      if epath.comp(prevX) = epath.comp(pathX) |
	        (epath.comp_type(prevX) = STAR_TYPE_MATCHES_EVERYTHING &
	         epath.comp_type(pathX) = STAR_TYPE_MATCHES_EVERYTHING) then do;
	         epath.count, pathX = pathX - 1;
	         end;
	      end;
	   end;
	end;

NEXT_PATH:
       end;

    call STAR_PATHS_error_conditional_exit();
    return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *	 */
/*										 */
/* SUPPORT PROCEDURE: STAR_PATHS_error							 */
/*   If Pcode_in = 0, then return.							 */
/*   Otherwise, expand error message and invoke caller's error handler.			 */
/*   If caller did not provide an error handler, then print error ourselves.			 */
/*   If caller's action code is ERROR_OK or ERROR_REJECT, then continue by processing the next	 */
/*     pathname.									 */
/*   If his action code is ERROR_STOP or ERROR_ABORT, then set Pcode parm of $select and do nonlocal */
/*     transfer to exit immediately from fs_star_.					 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *	 */

dcl  star_paths_error		bit(1);

STAR_PATHS_error:
    procedure (Pcode_in, Pentry_type, Pdir, Pent, Pcomp, Pmessage);

dcl  Pcode_in			fixed bin(35) parm;
dcl  Pentry_type			char(32) parm;
dcl  Pdir				char(*) parm;
dcl  Pent				(1) char(32) unal parm;
dcl  Pcomp			char(32) parm;
dcl  Pmessage			char(*) parm;

dcl  action			fixed bin auto;
dcl  saved_entry_type		char(32) auto;

    if Pcode_in = 0 then return;
    if Pcode = 0 then
       Pcode = Pcode_in;

    star_paths_error = TRUE;
    if so.error = ssu_$null_entry then do;		/* caller did NOT provide an error	 */
       call ssu_$print_message (ssu_sciP, Pcode_in, "^[^a^s^;^s^a^]^[^/(^a)^]",
	Pent(1)="", Pdir, pathname_$component (Pdir, Pent(1), Pcomp), Pmessage^="", Pmessage);
       go to NEXT_PATH;       			/* routine. We will report all errors	 */
       end;					/* before exiting.			 */

    saved_entry_type = sd.entry_data.type;
    sd.entry_data.type = Pentry_type;
    call so.error (addr(star_data), Pdir, Pent, Pcomp, Pcode_in, Pmessage, action);
    sd.entry_data.type = saved_entry_type;

    if action = ERROR_OK | action = ERROR_REJECT then
       go to NEXT_PATH;
    go to SELECT_EXIT;
    end STAR_PATHS_error;

STAR_PATHS_error_init:
    procedure();
    star_paths_error = FALSE;
    return;
    
STAR_PATHS_error_conditional_exit:
    entry();
    if star_paths_error then
       go to SELECT_EXIT;
    return;
    end STAR_PATHS_error_init;

    end STAR_PATHS_evaluate;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* ENTRY POINT: term								 */
/*   Cleans up from the fs_star_ operations by releasing all associated storage created by ssu_, and */
/*   by destroying the ssu_ invocation use by fs_star_ (if fs_star_ created it on the caller's	 */
/*   behalf).									 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

term:
    entry (Pstar_optionsP);
    
    if Pstar_optionsP = null then return;

    call ENTRY_POINT_setup (EP_TERM);
    
    call FSD_reinit();
    if fsd.we_created_ssuS then
       call ssu_$destroy_invocation (ssu_sciP);
    else 
       call ssu_$release_temp_segment (ssu_sciP, star_optionsP);
    return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *	 */
/*										 */
/* SUPPORT PROCEDURES for all entrypoints:						 */
/*										 */
/* SUPPORT PROCEDURE: ENTRY_POINT_setup							 */
/*   initialize pointers to all important structures.					 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *	 */

ENTRY_POINT_setup:
    procedure (Pcalling_ep);

dcl  Pcalling_ep			fixed bin parm;

    star_optionsP = Pstar_optionsP;			/* access fixed structures		 */
    if star_optionsP = null then do;
       if Pcalling_ep = EP_ADJUST then
	call ADJUST_error (error_table_$argerr);
       else if Pcalling_ep = EP_SELECT then
	call SELECT_error (error_table_$argerr, "star_optionsP parameter is a null pointer.");
       else
	call ERROR_unexpected (error_table_$argerr, EP_NAME(Pcalling_ep), ACTION_CANT_RESTART,
	   null, 0, "star_optionsP parameter is a null pointer.");
       end;
    else if star_options.version ^= STAR_OPTIONS_VERSION_1 then do;
       if Pcalling_ep = EP_ADJUST then
	call ADJUST_error (error_table_$unimplemented_version);
       else if Pcalling_ep = EP_SELECT then
	call SELECT_error (error_table_$unimplemented_version,
	   "star_options.version (=^a) must be STAR_OPTIONS_VERSION_1 (=^a).",
	   star_options.version, STAR_OPTIONS_VERSION_1);
       else
	call ERROR_unexpected (error_table_$unimplemented_version, EP_NAME(Pcalling_ep),
	   ACTION_CANT_RESTART, null, 0,
	   "star_options.version (=^a) must be STAR_OPTIONS_VERSION_1 (=^a).",
	   star_options.version, STAR_OPTIONS_VERSION_1);	   
       end;

    ssu_sciP = so.ssu_sciP;
    fsdP = so.fs_star_dataP;

    end ENTRY_POINT_setup;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* SUPPORT PROCEDURE:  ERROR_unexpected							 */
/*   This procedure makes a final effort to abort in a meaningful way, when all else fails.  It	 */
/*   calls sub_err_ to report an unexpected condition to the user.  Its calling sequence is the same */
/*   as sub_err_.									 */
/*										 */
/* Syntax: call ERROR_unexpected (code, name, sub_err_flag, info_ptr, retal, ioa_ctl_str, ioa_args); */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

ERROR_unexpected:
    procedure options (variable);
    
dcl  argsN			fixed bin auto;
dcl  code				fixed bin(35) auto;

    call cu_$arg_count (argsN, code);
    if argsN = 0 then				/* ssu_$standalone_invocation abort.	 */
       call sub_err_ (error_table_$fatal_error, "fs_star_", ACTION_CANT_RESTART, null, 0,
          "fs_star_'s ssu_ standalone invocation aborted.");
    else
       call cu_$generate_call (sub_err_, cu_$arg_list_ptr());
    end ERROR_unexpected;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* SUPPORT PROCEDURE:  FSD_init							 */
/*   This procedure initializes the fs_star_ internal data structure, fsd.			 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

FSD_init:
    procedure();

    so.caller.fs_star_dataP,
    fsdP = STRUCT_get_space ("fsd", size(fsd), EP_INIT);	/* create fs_star_ data structure in	 */
    fsd.version = FSD_VERSION_1;			/*  temp seg following star_options.	 */
    call STRUCT_get_next_space (addr(fsd), currentsize(fsd));
    fsd.we_created_ssuS = standalone_invocationS;		/* initialize the structure so	 */
    fsd.fsd_pad = 0;				/*  $adjust_structure_size will work.	 */
    fsd.star_dataP = null;
    fsd.archP = null;
    fsd.epathP = null;
    fsd.mnP = null;
    fsd.exnP = null;
    fsd.temp_segsP(*) = null;
    fsd.areasP(*) = null;
    return;
    

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* SUPPORT PROCEDURE:  FSD_reinit							 */
/*   This support procedure entry point resets the fs_star_ internal data structure, fsd, to the	 */
/*   state it was set to by fs_star_$init.						 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

FSD_reinit:
    entry();

    fsd.version = FSD_VERSION_1;
    call STRUCT_get_next_space (addr(fsd), currentsize(fsd));
/*  fsd.we_created_ssuS 				   remains unchanged by $reinit.	 */
    fsd.fsd_pad = 0;
    fsd.star_dataP = null;
    if fsd.archP ^= null then				/* if an archive segment was initiated	 */
       call terminate_file_ (fsd.archP, 0,		/*  and not terminated (due to nonlocal	 */
	TERM_FILE_TERM, code);			/*  goto, then terminate it now.	 */
    fsd.epathP = null;
    fsd.mnP = null;
    fsd.exnP = null;
    call TEMP_SEGS_AREAS_term();			/* reset .temp_segsP and .areasP	 */
    call hcs_$truncate_seg (fsd.next_spaceP, wordno(fsd.next_spaceP), code);
						/* get rid of extra pages at end of temp */
    return;					/*  seg containing star_options structure*/
    end FSD_init;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* SUPPORT PROCEDURE: STRUCT_allocate							 */
/*   Initializes space for a given structure, setting structure refer extents to maximum size if the */
/*   caller gives an array_size of 0.							 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

STRUCT_allocate:
    procedure (Pstruct_name, Pstruct_version, Pstruct_array_size, Pcalling_ep);

dcl  Pstruct_name			char(*) parm,
     Pstruct_version		char(8) parm,
     Pstruct_array_size		fixed bin parm,
     Pcalling_ep			fixed bin parm;

dcl  Pnew_struct			ptr auto,
     struct_elem_size		fixed bin auto;

    if Pstruct_version = EPATH_VERSION_1 then do;
       epath_size = Pstruct_array_size;
       if epath_size = 0 then do;
	epath_size = 1;
	struct_elem_size = size(epath) - size(struct_header);
	epath_size =
	   divide (sys_info$max_seg_size - currentsize(struct_header), struct_elem_size, 17, 0);
	end;
       if fsd.epathP = null then do;
	fsd.epathP, epathP = STRUCT_get_space (Pstruct_name, size(epath), Pcalling_ep);
	epath.version = Pstruct_version;
	epath.max_count = epath_size;
	epath.count = 0;
	call STRUCT_get_next_space (addr(epath), currentsize(epath));
	end;
       else do;
	epathP = fsd.epathP;
	Pnew_struct = STRUCT_get_space (Pstruct_name, size(epath), Pcalling_ep);
	Pnew_struct -> epath.version = Pstruct_version;
	Pnew_struct -> epath.max_count = epath.max_count;
	Pnew_struct -> epath.count = epath.count;
	if epath.count > 0 then
	   Pnew_struct -> epath.value = epath.value;
	Pnew_struct -> epath.max_count = epath_size;
	fsd.epathP, epathP = Pnew_struct;
	call STRUCT_get_next_space (addr(epath), currentsize(epath));
	end;
       end;

    else if Pstruct_version = STAR_EXCLUDE_NAMES_VERSION_1 then do;
       exclude_names_size = Pstruct_array_size;
       if exclude_names_size = 0 then do;
	exclude_names_size = 1;
	struct_elem_size = size(exclude_names) - size(struct_header);
	exclude_names_size =
	   divide (sys_info$max_seg_size - currentsize(struct_header), struct_elem_size, 17, 0);
	end;
       if so.exclude_namesP = null then do;
	so.exclude_namesP = STRUCT_get_space (Pstruct_name, size(exclude_names), Pcalling_ep);
	exclude_names.version = Pstruct_version;
	exclude_names.max_count = exclude_names_size;
	exclude_names.count = 0;
	call STRUCT_get_next_space (addr(exclude_names), currentsize(exclude_names));
	end;
       else do;
	Pnew_struct = STRUCT_get_space (Pstruct_name, size(exclude_names), Pcalling_ep);
	Pnew_struct -> exclude_names.version = Pstruct_version;
	Pnew_struct -> exclude_names.max_count = exclude_names.max_count;
	Pnew_struct -> exclude_names.count = exclude_names.count;
	if exclude_names.count > 0 then
	   Pnew_struct -> exclude_names.value = exclude_names.value;
	Pnew_struct -> exclude_names.max_count = exclude_names_size;
	so.exclude_namesP = Pnew_struct;
	call STRUCT_get_next_space (addr(exclude_names), currentsize(exclude_names));
	end;
       end;

    else if Pstruct_version = EXN_VERSION_1 then do;
       fsd.exnP = STRUCT_get_space (Pstruct_name, size(exn), Pcalling_ep);
       exn.version = Pstruct_version;
       exn.count = Pstruct_array_size;
       call STRUCT_get_next_space (addr(exn), currentsize(exn));
       exn.value(*) = "";
       exn.type(*) = STAR_TYPE_UNSET;
       end;

    else if Pstruct_version = STAR_EXTENDED_ENTRY_VERSION_1 then do;
       extended_entry_types_size = Pstruct_array_size;
       if extended_entry_types_size = 0 then do;
	extended_entry_types_size = 1;
	struct_elem_size = size(extended_entry_types) - size(struct_header);
	extended_entry_types_size =
	   divide (sys_info$max_seg_size - currentsize(struct_header), struct_elem_size, 17, 0);
	end;
       if so.extended_entry_typesP = null then do;
	so.extended_entry_typesP =
	   STRUCT_get_space (Pstruct_name, size(extended_entry_types), Pcalling_ep);
	extended_entry_types.version = Pstruct_version;
	extended_entry_types.max_count = extended_entry_types_size;
	extended_entry_types.count = 0;
	call STRUCT_get_next_space (addr(extended_entry_types), currentsize(extended_entry_types));
	end;
       else do;
	Pnew_struct =
	   STRUCT_get_space (Pstruct_name, size(extended_entry_types), Pcalling_ep);
	Pnew_struct -> extended_entry_types.version = Pstruct_version;
	Pnew_struct -> extended_entry_types.max_count = extended_entry_types.max_count;
	Pnew_struct -> extended_entry_types.count = extended_entry_types.count;
	if extended_entry_types.count > 0 then
	   Pnew_struct -> extended_entry_types.value = extended_entry_types.value;
	Pnew_struct -> extended_entry_types.max_count = extended_entry_types_size;
	so.extended_entry_typesP = Pnew_struct;
	call STRUCT_get_next_space (addr(extended_entry_types), currentsize(extended_entry_types));
	end;
       end;

    else if Pstruct_version = STAR_MATCH_NAMES_VERSION_1 then do;
       match_names_size = Pstruct_array_size;
       if match_names_size = 0 then do;
	match_names_size = 1;
	struct_elem_size = size(match_names) - size(struct_header);
	match_names_size =
	   divide (sys_info$max_seg_size - currentsize(struct_header), struct_elem_size, 17, 0);
	end;
       if so.match_namesP = null then do;
	so.match_namesP = STRUCT_get_space (Pstruct_name, size(match_names), Pcalling_ep);
	match_names.version = Pstruct_version;
	match_names.max_count = match_names_size;
	match_names.count = 0;
	call STRUCT_get_next_space (addr(match_names), currentsize(match_names));
	end;
       else do;
	Pnew_struct = STRUCT_get_space (Pstruct_name, size(match_names), Pcalling_ep);
	Pnew_struct -> match_names.version = Pstruct_version;
	Pnew_struct -> match_names.max_count = match_names.max_count;
	Pnew_struct -> match_names.count = match_names.count;
	if match_names.count > 0 then
	   Pnew_struct -> match_names.value = match_names.value;
	Pnew_struct -> match_names.max_count = match_names_size;
	so.match_namesP = Pnew_struct;
	call STRUCT_get_next_space (addr(match_names), currentsize(match_names));
	end;
       end;

    else if Pstruct_version = MN_VERSION_1 then do;
       fsd.mnP = STRUCT_get_space (Pstruct_name, size(mn), Pcalling_ep);
       mn.version = Pstruct_version;
       mn.count = Pstruct_array_size;
       call STRUCT_get_next_space (addr(mn), currentsize(mn));
       mn.value(*) = "";
       mn.type(*) = STAR_TYPE_UNSET;
       end;

    else if Pstruct_version = STAR_DATA_VERSION_1 then do;
       if fsd.star_dataP = null then do;
	fsd.star_dataP = STRUCT_get_space (Pstruct_name, size(star_data), Pcalling_ep);
	star_dataP = fsd.star_dataP;
	call STRUCT_get_next_space (addr(star_data), currentsize(star_data));
	end;
       else do;
	star_dataP = fsd.star_dataP;
	end;
       star_data.version = Pstruct_version;
       star_data.star_optionsP = addr(so);
       star_data.matched = 0;
       star_data.mbz_matched = 0;
       star_data.entry_data.data_desired = Pstruct_array_size;
						/* This is a slight misuse of the parm	 */
						/* but is close enough to make some sense*/
       star_data.entry_data.depth = 0;
       star_data.entry_data.type = ENTRY_TYPE_UNSET;
       star_data.entry_data.length = 0;
       star_data.entry_data.count = 0;
       star_data.entry_data.entryP = null;
       end;

    else if Pstruct_version = STAR_PATHS_VERSION_1 then do;
       star_paths_size = Pstruct_array_size;
       if star_paths_size = 0 then do;
	star_paths_size = 1;
	struct_elem_size = size(star_paths) - size(struct_header);
	star_paths_size =
	   divide (sys_info$max_seg_size - currentsize(struct_header), struct_elem_size, 17, 0);
	end;
       if so.star_pathsP = null then do;
	so.star_pathsP = STRUCT_get_space (Pstruct_name, size(star_paths), Pcalling_ep);
	star_paths.version = Pstruct_version;
	star_paths.max_count = star_paths_size;
	star_paths.count = 0;
	call STRUCT_get_next_space (addr(star_paths), currentsize(star_paths));
	end;
       else do;
	Pnew_struct = STRUCT_get_space (Pstruct_name, size(star_paths), Pcalling_ep);
	Pnew_struct -> star_paths.version = Pstruct_version;
	Pnew_struct -> star_paths.max_count = star_paths.max_count;
	Pnew_struct -> star_paths.count = star_paths.count;
	if star_paths.count > 0 then
	   Pnew_struct -> star_paths.value = star_paths.value;
	Pnew_struct -> star_paths.max_count = star_paths_size;
	so.star_pathsP = Pnew_struct;
	call STRUCT_get_next_space (addr(star_paths), currentsize(star_paths));
	end;
       end;

    else do;
       if Pcalling_ep = EP_SELECT then
	call SELECT_error (error_table_$fatal_error, 
	   "Attempt to allocate an unknown structure ^a.", Pstruct_name);
       else if Pcalling_ep = EP_REINIT | Pcalling_ep = EP_TERM then
	call ERROR_unexpected (error_table_$fatal_error, EP_NAME(Pcalling_ep), ACTION_CANT_RESTART,
	   null, 0, "Attempt to allocate an unknown structure ^a.", Pstruct_name);
       else do;
	call ERROR_unexpected (error_table_$fatal_error, EP_NAME(Pcalling_ep), ACTION_CAN_RESTART,
	   null, 0, "Attempt to allocate an unknown structure ^a.", Pstruct_name);
	if Pcalling_ep = EP_ADJUST then
	   call ADJUST_error (error_table_$fatal_error);
	else if Pcalling_ep = EP_INIT then
	   call INIT_error (error_table_$fatal_error);
	end;
       end;

    end STRUCT_allocate;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* SUPPORT PROCEDURE: STRUCT_get_space							 */
/*   Returns a pointer to a space large enough to hold a structure of a given size.  Normally, the	 */
/*   structure is allocated at fsd.next_spaceP.  But the space remaining in the temp seg it points	 */
/*   to may be insufficient to hold the new structure.  Or the last allocation in that temp seg may	 */
/*   have used all remaining space, causing fsd.next_spaceP to have been set to null.  These cases	 */
/*   are handled by getting a new temp seg.  If the new structure won't fit in its own segment,	 */
/*   then $adjust_structure_size returns an error code.  Finally, space for the fsd structure itself */
/*   always goes in the star_options temp seg, immediately following that structure.		 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

STRUCT_get_space:
    procedure (Pstruct_name, Pstruct_size, Pcalling_ep) returns (ptr);
    
dcl  Pstruct_name			char(*) parm,	/* name of structure being allocated.(In)*/
     Pstruct_size			fixed bin(18) parm, /* structure size in words. (In)	 */
     Pcalling_ep			fixed bin parm;	/* entrypoint ID for error handling. (In)*/
dcl  structP			ptr auto;

    if Pstruct_name = "fsd" then			/* Special-case the fsd structure itself.*/
       structP = addwordno(addr(star_options), size(star_options));
    else						/* Otherwise, look in fsd to see where 	 */
       structP = fsd.next_spaceP;			/*  to put other structures.		 */

    if structP = null then				/* prev temp seg was full, get a new one */
       structP = TEMP_SEG_get (Pstruct_name, Pcalling_ep);

    if wordno (structP) + Pstruct_size <= sys_info$max_seg_size then
       return (structP);				/* space fits in current temp segment.	 */

    structP = TEMP_SEG_get (Pstruct_name, Pcalling_ep);
    if wordno (structP) + Pstruct_size <= sys_info$max_seg_size then
       return (structP);				/* space fits in a new temp segment.	 */

    else do;					/* space won't fit in ANY segment. Error */
       if Pcalling_ep = EP_SELECT then
	call SELECT_error (error_table_$too_many_names, 
	   "^a structure is too large to be allocated (^d) words).", Pstruct_name, Pstruct_size);
       else if Pcalling_ep = EP_REINIT | Pcalling_ep = EP_TERM then
	call ERROR_unexpected (error_table_$too_many_names, EP_NAME(Pcalling_ep), ACTION_CANT_RESTART,
	   null, 0, "^a structure is too large to be allocated (^d) words).", Pstruct_name, 
	   Pstruct_size);
       else do;
	call ERROR_unexpected (error_table_$too_many_names, EP_NAME(Pcalling_ep), ACTION_CAN_RESTART,
	   null, 0, "^a structure is too large to be allocated (^d) words).", Pstruct_name, 
	   Pstruct_size);
	if Pcalling_ep = EP_ADJUST then
	   call ADJUST_error (error_table_$too_many_names);
	else if Pcalling_ep = EP_INIT then
	   call INIT_error (error_table_$too_many_names);
	end;
       end;

    end STRUCT_get_space;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* SUPPORT PROCEDURE: STRUCT_get_next_space						 */
/*   adjusts fsd.next_spaceP beyond the current structure being allocated or adjusted.  If there is	 */
/*   no more room in the current temp segment, the pointer is null.				 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

STRUCT_get_next_space:
    procedure (PstructP, Pstruct_size);

dcl  PstructP			ptr parm,
     Pstruct_size			fixed bin(18) parm;

dcl  space_size			fixed bin(18) auto;

    space_size = Pstruct_size + mod(Pstruct_size, 2);
    if wordno (PstructP) + space_size > sys_info$max_seg_size then
       fsd.next_spaceP = null;
    else
       fsd.next_spaceP = addwordno(PstructP, space_size);
    end STRUCT_get_next_space;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *	 */
/*										 */
/* SUPPORT PROCEDURE: TEMP_AREA_get							 */
/*   get an extensible area from ssu_ and store a pointer to it in fs_star_data for later release.	 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *	 */

TEMP_AREA_get:
    procedure () returns (ptr);

    if fsd.areasP(1) = null then 
       call ssu_$get_area (ssu_sciP, null, "star expand area", fsd.areasP(1));
    return (fsd.areasP(1));
    end TEMP_AREA_get;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *	 */
/*										 */
/* SUPPORT PROCEDURE: TEMP_SEG_get							 */
/*   get a temporary segment from ssu_ and store pointer to it in fs_star_data for later release.	 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *	 */

TEMP_SEG_get:
    procedure (Pstruct_name, Pcalling_ep) returns(ptr);
    
dcl  Pstruct_name			char(*) parm,
     Pcalling_ep			fixed bin parm;

dcl  temp_segX			fixed bin auto;

    do temp_segX = lbound(fsd.temp_segsP,1) to hbound(fsd.temp_segsP,1)
       while (fsd.temp_segsP(temp_segX) ^= null);
       end;

    if temp_segX > hbound(fsd.temp_segsP,1) then do;
       if Pcalling_ep = EP_SELECT then
	call SELECT_error (error_table_$noalloc, 
	   "Cannot use more than ^d temporary segments.", hbound(fsd.temp_segsP,1));
       else if Pcalling_ep = EP_REINIT | Pcalling_ep = EP_TERM then
	call ERROR_unexpected (error_table_$noalloc, EP_NAME(Pcalling_ep), ACTION_CANT_RESTART,
	   null, 0, "Cannot use more than ^d temporary segments.", hbound(fsd.temp_segsP,1));
       else do;
	call ERROR_unexpected (error_table_$noalloc, EP_NAME(Pcalling_ep), ACTION_CAN_RESTART,
	   null, 0, "Cannot use more than ^d temporary segments.", hbound(fsd.temp_segsP,1));
	if Pcalling_ep = EP_ADJUST then
	   call ADJUST_error (error_table_$noalloc);
	else if Pcalling_ep = EP_INIT then
	   call INIT_error (error_table_$noalloc);
	end;
       return (null);
       end;

    call ssu_$get_temp_segment (ssu_sciP, Pstruct_name, fsd.temp_segsP(temp_segX));

    return (fsd.temp_segsP(temp_segX));
    end TEMP_SEG_get;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* SUPPORT PROCEDURE: TEMP_SEGS_AREAS_term						 */
/*   Releases any temp segments and areas acquired by fs_star_, other than the temp segment holding	 */
/*   the star_options and fsd structures.						 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

TEMP_SEGS_AREAS_term:
    procedure();

dcl  Itemp			fixed bin;

    do Itemp = lbound(fsd.temp_segsP,1) to hbound(fsd.temp_segsP,1);
       if fsd.temp_segsP(Itemp) ^= null then do;
	call ssu_$release_temp_segment (ssu_sciP, fsd.temp_segsP(Itemp));
	fsd.temp_segsP(Itemp) = null;
	end;
       end;
    do Itemp = lbound(fsd.areasP,1) to hbound(fsd.areasP,1);
       if fsd.areasP(Itemp) ^= null then do;
	call ssu_$release_area (ssu_sciP, fsd.areasP(Itemp));
	fsd.areasP(Itemp) = null;
	end;
       end;
    end TEMP_SEGS_AREAS_term;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

%include access_mode_values;

%include fs_star_;

%include status_structures;

dcl  1 auto_status			aligned like status_branch.short;
dcl  status_area			area based (status_area_ptr);
dcl  status_names			(status_branch.nnames) character (32)
				based (pointer (status_area_ptr, status_branch.names_relp));
						/* status_entry_names array in include	 */
						/*  file is aligned.  That is a mistake	 */
						/*  but it is too late to correct now.	 */

%include sub_err_flags;

%include terminate_file;

    end fs_star_;
