/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1990   *
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

/* format: style4,delnl,insnl,^ifthendo */

/* format: off */

lar_util_: procedure (a_info_ptr, a_code);

/* This procedure is called by the queue-listing commands lar, ldr, and lrr (entry points in the same command procedure).
   It formats information about absentee, I/O daemon, and retrieval requests, and places its output in a printable segment.
   It leaves room for a totals line at the beginning, and then goes back and fills it in after it has scanned all the
   pertinent requests and knows what the totals are. It operates on only one queue message segment at a time.
   If the user specified that all queues (of a certain kind) be listed, the command procedure calls this one once for
   each queue. The offset in the printable segment at which to start placing output is specified in the argument structure.

   All input and output arguments (except the error code) are passed in an argument structure, lar_info, a pointer to
   which is the first argument in the call. The structure is defined in lar_info.incl.pl1, and comments in that
   include file describe the meaning of each variable in the structure.

   There is one implicit convention observed between this procedure and its caller: this procedure avoids outputting
   totals lines that contain only zeros, when the -all argument was given, and it avoids outputting totals lines for
   queues from which no requests are selected, when the -search_all argument is given (or is in effect by default).
   The calling procedure, realizing this, must check whether anything is in the output segment, and, if not, print a
   message saying  "No requests in any queue", or "No requests selected from any queue".
*/

/****^  HISTORY COMMENTS:
  1) change(86-03-01,Gilcrease), approve(86-03-27,MCR7370),
     audit(86-07-07,Fawcett), install(86-06-30,MR12.0-1082):
     Dummy comment for hcom.
     
     Modified by E. Stone 10/06/71
     Modified by Dennis Capps 3/20/72
     Modified by Robert Coren 4/17/73 to handle io_daemon requests
     Modified by J. Stern 4/4/75 to print access classes in long mode
     Modified by D. Vinograd 5/77 to return info about retrieval queues
     Modified by J.Whitmore and T. Casey, April 1978, for new daemon and absentee queue entry formats
     Modified by T. Casey, November 1978, for MR7.0, to list absentee queues zero and foreground, and other absentee changes.
     Modified by T. Casey, April 1979, for MR7.0a, to identify deferred absentee requests that have not yet been processed.
     Modified by R. Brinegar, Summer 1979 to fix output format problems.
     Modified by S. Herbst, Fall 1979 to print request type in header.
     Modified by T. Casey, November 1979 to print 8 digits of request ID and to identify bumped absentee jobs properly.
     Modified by J. C. Whitmore, April 1980 for new retrieval request format using queue_msg_hdr
     Modified by G. Palter, 8 September 1981 to print the I/O daemon forms if given
     Modified by G. C. Dixon, Jan 1982 to support lor command.
     Modified by R. Kovalcik, June 1982 to understand dprint -dupt.
     Modified by C. Marker, November 1983 to add support for -no_separator
     Modified by JAFalksen, August 1984 to use new time facilities
     Modified by C. Marker, February 23, 1985 to use version 5 message segments
  2) change(86-03-27,Gilcrease), approve(86-03-27,MCR7370),
     audit(86-07-07,Fawcett), install(86-06-30,MR12.0-1082):
     Add handling of truncate absout & restarted bits. SCP 6297.
  3) change(87-07-07,GDixon), approve(87-07-07,MCR7741),
     audit(87-07-07,Hartogs), install(87-08-04,MR12.1-1055):
     Include user_abs_attributes.incl.pl1 as part of splitting
     abs_message_format.incl.pl1.
  4) change(87-08-06,Gilcrease), approve(87-08-06,MCR7686),
     audit(88-02-01,Farley), install(88-02-02,MR12.2-1019):
     Add -nb message to lor/ldr -long.
  5) change(87-11-11,Parisek), approve(88-02-11,MCR7849),
     audit(88-03-07,Lippard), install(88-07-13,MR12.2-1047):
     Reference version 6 abs_message_format structure, and if version 6
     format output for the structure's new data.
  6) change(87-11-13,Parisek), approve(88-02-11,MCR7849),
     audit(88-03-07,Lippard), install(88-07-13,MR12.2-1047):
     Display the request version 6 elements; no_start_up, home_dir, init_proc.
     SCP 6367.
  7) change(88-04-20,Parisek), approve(88-06-13,MCR7913),
     audit(88-08-16,Farley), install(88-08-22,MR12.2-1089):
     Added the request_info entrypoint which called by the
     request_info command/active_function to return specific queue
     information about absentee, output, io, retrieval, and file transfer
     requests.  Added the internal procedures, buffer_abs_element,
     buffer_com_element, buffer_out_element, buffer_retv_element, and
     buffer_imft_element to format the return information for the caller.
     Alter the flow of code execution at various points when the rqi_sw switch
     is ON.  The rqi_sw informs lar_util_ that it was called by the
     request_info command/AF.
     Added checks for selecting OUTPUT requests with special forms only.
  8) change(88-09-01,Parisek), approve(88-09-01,PBF7913),
     audit(88-09-07,Farley), install(88-09-09,MR12.2-1101):
     Removed the displaying of the "delete" and "dupt" request flags for
     request types they do not pertain to.  Also check imft's
     "remote_transfer" flag before displaying the "files" and "subtrees"
     flags for the imft request type.  "files" and "subtrees" do not pertain
     to imft requests coming from the remote system.
  9) change(88-09-13,Beattie), approve(88-08-01,MCR7948),
     audit(88-10-11,Farley), install(88-10-14,MR12.2-1165):
     Add support for displaying extend, update and delete for IMFT requests.
 10) change(88-09-13,Farley), approve(88-09-16,MCR7911),
     audit(88-10-25,Wallman), install(88-10-28,MR12.2-1199):
     Updated to use version 5 dprint_msg.  Also added "plotter" as one of the
     valid output_modules.
 11) change(90-12-10,Vu), approve(90-12-10,MCR8231), audit(92-09-25,Zimmerman),
     install(92-10-06,MR12.5-1021):
     Header for list_absentee_request has garbage total.
                                                   END HISTORY COMMENTS */

/* format: on */

/* Arguments */

dcl  a_info_ptr ptr;
dcl  a_code fixed bin (35);

/* Automatic variables, in alphabetic order */


dcl  abs_name char (32);
dcl  access_class bit (72) aligned;
dcl  aclass_string char (170);
dcl  af_flag_str char (512) varying;
dcl  afsw bit (1) aligned;				/* active function call */
dcl  agdd char (168);				/* argument directory, directory portion */
dcl  agde char (32);				/* argument directory, entry portion */
dcl  aguid bit (36);				/* argument directory, UID */
dcl  allsw bit (1) aligned;				/* print all for request_info */
dcl  areap ptr;
dcl  argl fixed bin;
dcl  argx fixed bin;				/* argument string index */
dcl  auto_forms_name char (forms_max_lth) varying;
dcl  buffer char (512) aligned;
dcl  check_abs_name bit (1) aligned;
dcl  check_user bit (1) aligned;
dcl  code fixed bin (35);
dcl  curarg_start fixed bin;
dcl  deferred_abs bit (1) aligned;
dcl  deferred_count fixed bin;
dcl  dirname char (168);
dcl  ename char (32);
dcl  expandedlen fixed bin;
dcl  expandlen fixed bin;
dcl  expandp ptr;
dcl  header_position fixed bin;
dcl  i fixed bin;
dcl  j fixed bin;
dcl  last_comma fixed bin;
dcl  len fixed bin;
dcl  len_offset fixed bin;
dcl  ll fixed bin;
dcl  1 local_mseg_message_info like mseg_message_info aligned;
dcl  long_id bit (1) aligned;
dcl  messcount fixed bin;
dcl  modes char (100) var;
dcl  msg_time fixed bin (71);
dcl  n_bad_vrsn fixed bin;
dcl  no_totals bit (1) aligned;
dcl  offs char (256) varying;
dcl  offslen fixed bin (21);
dcl  old_ms_id bit (72) aligned;
dcl  ons char (256) varying;
dcl  onslen fixed bin (21);
dcl  pass1 bit (1) aligned;
dcl  person char (32);
dcl  position fixed bin;
dcl  print_requests bit (1) aligned;
dcl  print_user_column bit (1) aligned;
dcl  project char (32);
dcl  psn_ll fixed bin;
dcl  psn_s fixed bin;
dcl  queue_string char (32);
dcl  read_all bit (1) aligned;
dcl  reqp ptr;
dcl  retrying bit (1) aligned;
dcl  rqdd char (168);				/* request directory, directory portion */
dcl  rqde char (32);				/* request directory, entry portion */
dcl  rqid char (19);				/* request directory, UID */
dcl  rqi_buffered bit (1) aligned;			/* ON if output buffered for rqi */
dcl  rqi_sw bit (1) aligned;				/* command/active function entry point */
dcl  rs_len fixed bin;
dcl  s char (1) aligned;
dcl  scrunchedp ptr;
dcl  select_sw bit (1) aligned;
dcl  sender_id char (32);
dcl  state fixed bin;
dcl  str char (32) varying;
dcl  tbf char (32) var;
dcl  time char (64) var;
dcl  time_now fixed bin (71);
dcl  total_for_user fixed bin;
dcl  total_selected fixed bin;
dcl  user_matches bit (1) aligned;

/* Based */

dcl  region area (1000) based (areap);
dcl  cstrng char (info.output_count) aligned based (info.temptr);
dcl  args_con_blanks char (expandlen) aligned based (expandp);
dcl  args_sans_blanks char (expandlen) aligned based (scrunchedp);
dcl  based_dummy fixed bin based;			/* for freeing requests without computing their extents */

/* Conditions */

dcl  cleanup condition;

/* Internal Static */

dcl  header_length int static options (constant) fixed bin init (74);
dcl  ABS_VER_5 fixed bin (17) init (5) static options (constant);
dcl  ABS_VER_4 fixed bin (17) init (4) static options (constant);
						/* a request_version of 4 means that this abs was queued under MR11. */
						/* Any abs queued under MR12 will be version 5. */
dcl  DEFAULT_LINE_LTH int static options (constant) fixed bin init (79);
dcl  DEFAULT_OUTPUT_LTH int static options (constant) fixed bin init (-1);
dcl  IMFT fixed bin (17) int static options (constant) init (5);
dcl  TAB_39 int static options (constant) fixed bin init (39);
dcl  TAB_44 int static options (constant) fixed bin init (44);
dcl  TOO_SMALL_LINE_LTH int static options (constant) fixed bin init (50);
dcl  Notify_msg char (13) static options (constant) init ("Notify:		yes
");
dcl  Restarted_msg char (16) int static options (constant) init ("Restarted:		yes
");
dcl  Truncate_msg char (15) int static options (constant) init ("Truncate:		yes
");
dcl  line_nbrs_msg char (18) static options (constant) init ("Line numbers:	yes
");
dcl  DUPT_msg char (11) static options (constant) init ("DUPT:		yes
");
dcl  NL char (1) int static options (constant) init ("
");
dcl  pp_request_type (2:4) char (9) aligned int static options (constant) init ("7punch", "mcc_punch", "raw_punch");

dcl  state_names (-1:6) char (48) int static options (constant) init ("state undefined",
						/* -1 */
	"unprocessed",				/* 0 */
	"deferred",				/* 1 */
	"state changing",				/* 2 */
	"eligible",				/* 3 */
	"running",				/* 4 */
	"bumped",					/* 5 */
	"deferred until process termination");		/* 6 */

dcl  static_psn_s fixed bin int static;
dcl  static_ll fixed bin int static;
dcl  static_header_position fixed bin int static;
dcl  static_total_selected fixed bin int static;
dcl  static_messcount fixed bin int static;
dcl  static_deferred_count fixed bin int static;
dcl  static_position fixed bin int static;

/* Ext Entries */

dcl  aim_check_$greater entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
dcl  convert_authorization_$to_string_short ext entry (bit (72) aligned, char (*), fixed bin (35));
dcl  date_time_$format entry (char (*), fixed bin (71), char (*), char (*)) returns (char (250) var);
dcl  expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35));
dcl  get_group_id_ entry returns (char (32));
dcl  hcs_$status_long entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35));
dcl  ioa_$rs entry options (variable);
dcl  ioa_$rsnnl entry options (variable);
dcl  get_line_length_ entry (char (*), fixed bin, fixed bin (35));
dcl  get_system_free_area_ entry (ptr);
dcl  match_request_id_ entry (fixed bin (71), char (*)) returns (bit (1) aligned);
dcl  match_star_name_ entry (char (*), char (*), fixed bin (35));
dcl  message_segment_$get_message_count_index entry (fixed bin, fixed bin, fixed bin (35));
dcl  message_segment_$read_message_index entry (fixed bin, pointer, pointer, fixed bin (35));
dcl  request_id_ entry (fixed bin (71)) returns (char (19));


/* Builtins */

dcl  (addr, after, before, clock, hbound, length, index, lbound, null, reverse, rtrim, substr, unspec) builtin;

/* Error table */

dcl  error_table_$moderr ext fixed bin;
dcl  error_table_$no_message ext fixed bin;
dcl  error_table_$bad_segment ext fixed bin (35);


	afsw = "0"b;
	rqi_sw = "0"b;
	goto COMMON_INIT;

request_info:
     entry (a_info_ptr, a_afsw, a_code);

dcl  a_afsw bit (1) aligned;				/* On if rqi called as AF */

/* This entry is called by the queue-info command/active function request_info.
   It produces output in a simple formatted line by line format.  It does not produce
   any header or totals information in its output.
*/

	afsw = a_afsw;
	rqi_sw = "1"b;

COMMON_INIT:					/* Initialize */
	info_ptr = a_info_ptr;
	a_code = 0;
	reqp = null;
	total_selected, total_for_user, deferred_count, n_bad_vrsn, position, code = 0;

	time_now = clock ();

/* Set some local switches, based on combinations of input switches */

	if info.long_id_sw | info.long_sw
	then					/* if -long or -long_id */
	     long_id = "1"b;			/* print the long form of request IDs */
	else long_id = ""b;				/* else print the short form */

	check_user = info.user_sw;			/* see if a user name was specified by the caller */
	if info.person = "*" & info.project = "*"
	then					/* if caller said -user *.* */
	     check_user = ""b;			/* pretend user was not specified */

	if info.abs_q_1 & info.queue = 0
	then					/* if running Qs 0 and 1 together and this is Q 0 */
	     static_header_position = 0;		/* indicate that we have no Q 0 output yet */

/* Decide whether to print the user column */

	if info.admin_sw				/* if we are in admin mode */
	     & (^check_user				/* and we don't have a user name */
	     | (check_user				/* or we have a user name */
	     & (info.person = "*" | info.project = "*")))
	then					/* but it could match several users */
	     print_user_column = "1"b;		/* then print the user name for each request */
	else print_user_column = ""b;			/* else they're all from the same user so don't print the name */

/* See if we have to read all requests, or just those for the user whose process we're running in */

	if info.admin_sw | info.position_sw
	then read_all = "1"b;
	else read_all = ""b;

/* See if we have to look at the contents of a request to decide whether to select it */

	if info.user_sw | info.immediate | info.resource_sw | info.dirname_sw | info.ename_sw | info.id_sw
	     | info.deferred_indefinitely | info.sender_sw | info.forms_sw
	then select_sw = "1"b;			/* we do */
	else select_sw = ""b;			/* we don't */

/* Initialize some variables used for checking the user ID of each request */

	if check_user
	then do;					/* if we have to check the user, copy the name and project */
	     person = info.person;
	     project = info.project;
	end;					/* but if user not specified */
	else if info.position_sw			/* and we can't use the "own" primitives because we have to read
						   every request to get the positions of the ones we select */
	     & ^info.admin_sw
	then do;					/* and we're not listing all users' requests */
	     person = get_group_id_ ();		/* get the ID of this user so we can pick out his requests */
	     project = before (after (person, "."), ".");
	     person = before (person, ".");
	     check_user = "1"b;			/* and remember to check each request for a matching user name */
	end;

/* If directory name supplied, get its UID, so we can try UID matching to get around the multiply-named directory problem */

	if info.dirname_sw
	then do;
	     call expand_pathname_ ((info.dirname), agdd, agde, code);
	     if code ^= 0
	     then goto return_code;			/* can't happen since caller already expanded it ok */
	     call hcs_$status_long (agdd, agde, (1), addr (branch_status), null, code);
	     if code = 0
	     then aguid = branch_status.unique_id;
	     else aguid = ""b;			/* ""b means don't try UID matching */
	end;

/* If listing absentee requests, see if we have to append the .absin suffix to a name given by the user */

	check_abs_name = ""b;
	if info.request_type = ABS
	then if index (info.ename, ".absin") = 0 & length (rtrim (info.ename)) <= 26
	     then do;
		abs_name = rtrim (info.ename) || ".absin";
		check_abs_name = "1"b;
	     end;

/* Figure out where in the output segment to start putting our output lines . This gets complicated because
   we list absentee queues 0 and 1 as if they were one queue. Queue zero exists only so the operator can
   move requests "to the head of queue 1", even though it is impossible to add messages to the head
   of a message segment.

   So here, we have to adjust some variables to run the Q 0 and Q 1 listings together,
   instead of separating them by a header. */

	info.output_count = info.input_count + 1;	/* point output_count at first vacant char */

	if rqi_sw
	then goto message_count;

	if info.output_count = 1
	then					/* if nothing in segment yet */
	     call put_message (NL);			/* skip a line */

	if (info.abs_q_1 & static_header_position > 0 & info.queue = 1)
	then do;					/* if running Qs 0 and 1 together */
	     header_position = static_header_position;	/* get position of header that's already there */
	     position = static_position;		/* and Q position of last request in Q 0 */
	     deferred_count = static_deferred_count;	/* and count of deferred requests */


	     if substr (cstrng, info.output_count - 2, 2) = NL || NL
	     then					/* if output seg ends in double newline */
		info.output_count = info.output_count - 1;
						/* get rid of one of them */

	     if info.total_sw & info.position_sw & static_total_selected > 0
	     then do;				/* continue position list from Q 0 */
		psn_s = static_psn_s;		/* position of the "s" in "Positions" */
		ll = static_ll;			/* terminal's line length */
		psn_ll = 0;			/* too difficult to append to current line, so start a new one */
		if substr (cstrng, info.output_count - 2, 1) = "."
		then				/* but if we can find the trailing period */
		     substr (cstrng, info.output_count - 2, 1) = ",";
						/* change it back to a comma */
		substr (cstrng, psn_s, 2) = "s:";	/* and be sure it says "Positions:" */
	     end;					/* end continue position list */
	end;

	else do;					/* else reserve a place for the header */
	     header_position = info.output_count;	/* remember where it starts */
	     info.output_count = info.output_count + header_length;
						/* move vacant char index past space for header */
	     substr (cstrng, header_position, header_length) = "";
						/* clear it, so we don't print lots of \000's if we
						   exit with an error before getting around to filling it in */
	     static_total_selected = 0;		/* and make sure there's no garbage in this variable */
	end;


/* See if we can get the total number of requests in the queue */

message_count:
	no_totals = ""b;				/* assume we can */
	call message_segment_$get_message_count_index (info.mseg_idx, messcount, code);
	if code ^= 0
	then do;					/* user might have read or own permission, but not status */
               messcount = 0;
	     if code ^= error_table_$moderr
	     then goto return_code;			/* if that is not the case, give up immediately */
	     else do;				/* that was the case */
		code = 0;
		no_totals = "1"b;			/* remember not to print the total requests */
		info.no_total_sw = "1"b;		/* tell caller not to print "No requests in any queue"  */
	     end;
          end;
	else if messcount = 0
	then go to fin;				/* if no requests then we are done */

	if info.admin_sw				/* if reading all requests */
	     & info.total_sw			/* just to count them */
	     & ^select_sw				/* and not being selective about it */
	     & ^info.position_sw			/* and not printing their positions */
	     & ^no_totals				/* and we were able to get the count */
	then do;					/* save lots of time */
	     total_for_user = messcount;
	     total_selected = messcount;		/* don't bother reading thru the queue */
	     goto fin;				/* just go print the total */
	end;

/* Set up to read requests from the queue */

	call get_system_free_area_ (areap);		/* get area in which to place request */
	mseg_message_info_ptr = addr (local_mseg_message_info);
	reqp, expandp, scrunchedp = null ();		/* init for cleanup handler */
	on cleanup call cleaner_up;			/* establish cleanup handler */

/* Get started through the queue by reading either the first message in the queue, or the first message for this user */

	retrying = ""b;
retry_1:
	reqp, requestp, dmp = null;			/* init these to avoid faults */
	unspec (local_mseg_message_info) = ""b;
	local_mseg_message_info.version = MSEG_MESSAGE_INFO_V1;
	local_mseg_message_info.own = ^read_all;
	local_mseg_message_info.message_code = MSEG_READ_FIRST;
	call message_segment_$read_message_index (info.mseg_idx, areap, mseg_message_info_ptr, code);

	if ^retrying
	then					/* retry the read once, if queue has been salvaged */
	     if code = error_table_$bad_segment
	     then do;
		retrying = "1"b;
		goto retry_1;
	     end;

/* Top of loop through all requests in queue. The bottom of this loop, at the
   label "skip", does an incremental read and then comes here. We exit the loop
   by going to mess_err if code is nonzero. This is for both normal and abnormal exits. */

loop:
	if code ^= 0
	then go to mess_err;			/* exit loop if no message or real error */
	reqp, requestp, dmp, ft_request_ptr = mseg_message_info.ms_ptr;
						/* set ptrs to all of the request structures */
	sender_id = mseg_message_info.sender_id;
	access_class = mseg_message_info.ms_access_class;

/* Check version of request, and complain if not current. It is worthwhile to diagnose this error, since it is
   likely to occur often now. We are changing the request versions, and there are lots of private
   versions of the ear and dprint commands around to put old version requests into the queues. */

	if request.hdr_version ^= queue_msg_hdr_version_1
	then goto vrsn_ng;

	if info.request_type = RETV
	then if retv_request.version = retv_request_version_2
	     then goto vrsn_ok;
	     else goto vrsn_ng;
	else if info.request_type = ABS
	then if (request.request_version = abs_message_version_6 | request.request_version = ABS_VER_5
		| request.request_version = ABS_VER_4)	/* Allow old versions */
	     then goto vrsn_ok;
	     else goto vrsn_ng;
	else if info.request_type = IO | info.request_type = OUTPUT
	then if dprint_msg.version = dprint_msg_version_5 | dprint_msg.version = dprint_msg_version_4
		| dprint_msg.version = dprint_msg_version_3
	     then goto vrsn_ok;
	     else goto vrsn_ng;
	else if (rqi_sw & info.request_type = IMFT)	/* We only deal with IMFT in this module if invoked as request_info */
	then if ft_request.version = FT_REQUEST_VERSION_1
	     then goto vrsn_ok;

vrsn_ng:
	if rqi_sw & afsw
	then goto skip;				/* simply ignore */
	n_bad_vrsn = n_bad_vrsn + 1;			/* count bad ones for printing in totals at end */

	if check_user
	then do;					/* don't complain to one user about another's bad requests */
	     if person ^= "*"
	     then if person ^= before (sender_id, ".")
		then goto skip;
	     if project ^= "*"
	     then if project ^= before (after (sender_id, "."), ".")
		then goto skip;
	end;

	total_selected = total_selected + 1;		/* we have "selected" this one, to complain about it */
	total_for_user = total_for_user + 1;		/* also count it among this user's requests */

	if ^info.total_sw
	then do;					/* long or normal mode; print stuff in mseg return args */
	     unspec (msg_time) = mseg_message_info.ms_id; /* this tells us when it was entered */
	     time = date_time_$format ("date_time", msg_time, "", "");
						/* format it so we can show it to the user */
	     if info.long_sw
	     then do;				/* might as well make it look pretty */
		call put_message (NL);
		call ioa_$rs ("User:^21t^a", buffer, len, sender_id);
		call put_buffer;
		call ioa_$rs ("Time queued:^21t^a", buffer, len, time);
		call put_buffer;
		call put_message_nl ("Request has obsolete or incorrect format");
	     end;
	     else do;				/* normal format */
		if print_user_column
		then do;
		     call ioa_$rsnnl ("^30a", buffer, len, sender_id);
		     call put_buffer;
		end;
		call ioa_$rs ("Request has obsolete or incorrect format. Time queued: ^a", buffer, len, time);
		call put_buffer;
	     end;
	end;					/* end not totals */

	goto skip;

vrsn_ok:						/* See if the user matches */
	user_matches = ""b;				/* start out being pessimistic */
	if check_user
	then do;					/* if user name was given, see if it matches */
	     if person ^= "*"
	     then do;				/* require matching person ID */
		if person ^= before (sender_id, ".")
		then do;				/* user does not match */
		     if info.request_type ^= ABS
		     then goto wrong_user;
		     if ^request.proxy
		     then goto wrong_user;		/* wrong_user unless proxy request */
		     if person ^= before (request.proxy_name, ".")
		     then goto wrong_user;		/* proxy user doesn't match */
		end;
	     end;

	     if project ^= "*"
	     then do;				/* require matching project ID */
		if project ^= before (after (sender_id, "."), ".")
		then do;				/* project does not match */
		     if info.request_type ^= ABS
		     then goto wrong_user;
		     if ^request.proxy
		     then goto wrong_user;		/* wrong_user unless proxy request */
		     if project ^= before (after (request.proxy_name, "."), ".")
		     then goto wrong_user;
		end;
	     end;

	end;					/* end check user */

	user_matches = "1"b;			/* true if we fell thru ok or if ^check_user */
wrong_user:					/* come here from above as soon as user is found not to match */
	if user_matches
	then total_for_user = total_for_user + 1;	/* count requests belonging to the specified user */


/* Now see if the request is deferred or not, and update the request position counter.
   If printing position, we count the request even if we are not listing it, so we will
   know the positions of subsequent requests that we do list. So we make this check before
   eliminating the request by going to skip.

   But, if -immediate was given, we not only don't list deferred requests, but we don't count
   them when computing the positions of other requests.  We assume the deferred requests will
   be passed by the other requests whose positions we will print. */

	if info.immediate | read_all
	then do;					/* check for immediate first */
	     if info.request_type = IO | info.request_type = OUTPUT
	     then					/* for I/O requests */
		if request.state = STATE_DEFERRED
		then goto deferred_request;		/* the decision is very simple */
	     if info.request_type = ABS
	     then do;				/* for absentee, it is a bit more complicated */
		if request.state < STATE_ELIGIBLE
		then do;
		     if request.user_deferred_until_time
		     then if request.deferred_time > time_now
			then goto deferred_request;
		     if request.user_deferred_indefinitely
		     then goto deferred_request;
		     if request.operator_deferred_until_time
		     then if request.deferred_time > time_now
			then goto deferred_request;
		     if request.operator_deferred_indefinitely
		     then goto deferred_request;
		     if request.cpu_time_limit
		     then goto deferred_request;
		end;
	     end;					/* retrieval requests do not have a non-immediate mode */
	     goto immediate_request;

deferred_request:
	     deferred_count = deferred_count + 1;	/* count deferred requests for totals line */
	     if info.immediate
	     then goto skip;

immediate_request:
	end;					/* end immediate checking */

	position = position + 1;			/* this request counts for position computation */

/* Now start checking whether we want to list this request or count it in the totals */

/* First, check the user match switch that we set above */

	if ^user_matches
	then goto skip;

/* Copy a few variables out of the queue_msg_hdr part of the request structure */

	dirname = request.dirname;
	ename = request.ename;
	msg_time = request.msg_time;
	state = request.state;
	if state > hbound (state_names, 1) | state < lbound (state_names, 1)
	then state = -1;

/* See if the ID, dirname, and entry name match */

	if info.id_sw
	then if ^match_request_id_ (msg_time, (info.request_id))
	     then goto skip;

	if info.dirname_sw
	then if dirname ^= info.dirname
	     then do;
		if aguid = ""b
		then goto skip;			/* if we don't have UID of info.dirname, don't try UID match */
		call expand_pathname_ (dirname, rqdd, rqde, code);
		if code ^= 0
		then goto skip;
		call hcs_$status_long (rqdd, rqde, (1), addr (branch_status), null, code);
		if code ^= 0
		then goto skip;
		if aguid ^= branch_status.unique_id
		then goto skip;
	     end;

	if info.ename_sw
	then if ename ^= info.ename
	     then do;
		call match_star_name_ (ename, (info.ename), code);
		if code ^= 0
		then if ^check_abs_name
		     then goto skip;
		     else do;			/* user left off the .absin */
			if ename ^= abs_name
			then do;
			     call match_star_name_ (ename, abs_name, code);
			     if code ^= 0
			     then goto skip;
			end;
		     end;
	     end;

/* These checks just apply to absentee requests */

	if info.request_type = ABS
	then do;
	     if info.resource_sw
	     then do;
		if request.len_resource = 0
		then goto skip;
		if index (request.resource, info.resource_name) = 0
		then goto skip;
	     end;
	     if info.deferred_indefinitely
	     then if ^request.user_deferred_indefinitely & ^request.operator_deferred_indefinitely
		then goto skip;
	     if info.sender_sw
	     then					/* check sender (RJE station) */
		if request.sender ^= info.sender
		then do;
		     call match_star_name_ ((request.sender), (info.sender), code);
		     if code ^= 0
		     then goto skip;
		end;

/* Later, add more checks to select absentee requests by their state, and
   by their cpu time and resource requirements, mainly for the operator's use. */

	end;					/* end absentee only checks */

	if info.request_type = OUTPUT
	then do;
	     if info.forms_sw
	     then do;
		if dprint_msg.version < dprint_msg_version_5
		then auto_forms_name = rtrim (dprint_msg.forms);
		else auto_forms_name = dprint_msg.forms_name;
		if length (auto_forms_name) = 0
		then goto skip;
		if info.forms_name ^= ""
		then if index (auto_forms_name, rtrim (info.forms_name)) = 0
		     then goto skip;
	     end;
	end;					/* end output only checks */

/* Arriving here, we have selected this request, either for printing or counting in the totals */

	total_selected = total_selected + 1;		/* increment number of requests */

/* The following loops apply to request_info data */

	allsw = "0"b;
	offs, ons, af_flag_str = "";
	if rqi_sw
	then do;					/* request_info */
	     if substr (info.com_rqi, 1, 1) = "1"b
	     then do;				/* bit 1 means "all" */
		allsw = "1"b;
		info.com_rqi = "11111111111"b;
	     end;
	     do i = 1 to length (info.com_rqi);
		if substr (info.com_rqi, i, 1) = "1"b
		then do;
		     call buffer_com_element (i);
		     rqi_buffered = "1"b;
		end;
	     end;
	     if info.request_type = ABS
	     then do;
		if allsw
		then info.abs_rqi = "1111111111111"b;
		do i = 1 to length (info.abs_rqi);
		     if substr (info.abs_rqi, i, 1) = "1"b
		     then do;
			call buffer_abs_element (i);
			rqi_buffered = "1"b;
		     end;
		end;
		goto skip;
	     end;
	     if info.request_type = IO | info.request_type = OUTPUT
	     then do;
		if allsw
		then info.output_rqi = "11111111111"b;
		do i = 1 to length (info.output_rqi);
		     if substr (info.output_rqi, i, 1) = "1"b
		     then do;
			call buffer_output_element (i);
			rqi_buffered = "1"b;
		     end;
		end;
		goto skip;
	     end;
	     if info.request_type = RETV
	     then do;
		if allsw
		then info.retv_rqi = "1111"b;
		do i = 1 to length (info.retv_rqi);
		     if substr (info.retv_rqi, i, 1) = "1"b
		     then do;
			call buffer_retv_element (i);
			rqi_buffered = "1"b;
		     end;
		end;
		goto skip;
	     end;
	     if info.request_type = IMFT
	     then do;
		if allsw
		then info.imft_rqi = "111"b;
		do i = 1 to length (info.imft_rqi);
		     if substr (info.imft_rqi, i, 1) = "1"b
		     then do;
			call buffer_imft_element (i);
			rqi_buffered = "1"b;
		     end;
		end;
		goto skip;
	     end;
	end;

	if info.total_sw
	then do;
	     if info.position_sw
	     then do;				/* print positions of selected requests */
		if total_selected + static_total_selected = 1
		then do;				/* if first one */
		     psn_s = info.output_count + 8;	/* remember where the s in Positions is */
		     call ioa_$rsnnl ("Positions:^2x^d,", buffer, len, position);
		     call put_buffer;
		     psn_ll = len;			/* the position string could get extremely long */
		     call get_line_length_ ("user_output", ll, code);
						/* so split it into terminal-sized sections */
		     if code ^= 0
		     then ll = DEFAULT_LINE_LTH;	/* guess low */
		     if ll < TOO_SMALL_LINE_LTH
		     then ll = DEFAULT_LINE_LTH;
		end;
		else do;
		     call ioa_$rsnnl ("^x^d,", buffer, len, position);
		     if psn_ll + len > ll
		     then do;			/* output lines split by the tty dim look sloppy */
			call put_message (NL);
			psn_ll = 0;
		     end;
		     call put_buffer;
		     psn_ll = psn_ll + len;
		end;
	     end;					/* end print positions */
	     goto skip;				/* just totals, so don't print anything more about the request */
	end;

/* Not just totals. We will list this request, so start formatting some of its parameters. */

	rqid = request_id_ (msg_time);
	if ^long_id
	then rqid = substr (rqid, 7, 8);

/* If normal (not long) output form specified, summarize the request in a single line */

	if ^info.long_sw
	then do;

	     if total_selected + static_total_selected = 1
	     then do;				/* if we are about to list our first request */
		call put_message (NL);		/* put blank line after totals line */
		if print_user_column
		then do;				/* if admin, for all users, print heading */
		     call ioa_$rs ("User^31t^[^7x^]ID^[^18x^;^7x^]^[Input segment^s^;^[Pathname^;Entry name^]^]",
			buffer, len, info.position_sw, long_id, (info.request_type = ABS), info.path_sw);
		     call put_buffer;
		end;
	     end;

/* Build up the line one field at a time. Some fields are optional, depending
   on arguments given by user and passed in info.switches */

	     if print_user_column
	     then do;				/* if listing more than one user's requests */
		call ioa_$rsnnl ("^30a", buffer, len, sender_id);
						/* say who this one is from */
		call put_buffer;
	     end;

	     if info.position_sw
	     then do;
		call ioa_$rsnnl ("^3d)^x", buffer, len, position);
		call put_buffer;
	     end;

	     call ioa_$rsnnl ("^a", buffer, len, rqid);
	     call put_buffer;

	     if info.path_sw
	     then call ioa_$rsnnl ("^x^a^[>^]^a", buffer, len, dirname, (dirname ^= ">"), ename);
	     else call ioa_$rsnnl ("^x^a", buffer, len, ename);
	     call put_buffer;

	     deferred_abs = ""b;
	     if ^info.brief_sw
	     then do;				/* don't print request state if -brief given */
		if info.request_type = ABS & state = 0
		then do;				/* check for deferred but unprocessed abs jobs */
		     if request.user_deferred_indefinitely
		     then deferred_abs = "1"b;
		     else if request.user_deferred_until_time
		     then if request.deferred_time > time_now
			then deferred_abs = "1"b;
		     if deferred_abs
		     then call put_message (" (unprocessed, deferred");
		end;

		if state > 0
		then do;				/* print state, if nonzero */
		     if state > hbound (state_names, 1)
		     then state = -1;		/* avoid fault if bad state */
		     call ioa_$rsnnl ("^x(^a^[^;)^]", buffer, len, state_names (state),
			(info.request_type = ABS & state = STATE_DEFERRED));
		     call put_buffer;
		end;
	     end;

/* The rest of these only apply to absentee requests */

	     if info.request_type = ABS
	     then do;
		if ^info.brief_sw
		then do;
		     if state = STATE_DEFERRED | deferred_abs
		     then do;
			call explain_abs_deferral;
			call put_message (")");
		     end;

		     if request.len_comment > 0
		     then do;
			call ioa_$rsnnl ("^x""^a""", buffer, len, request.comment);
			call put_buffer;
		     end;


		     if info.resource_sw
		     then do;			/* print resources even in normal mode */
			i = index (request.resource, " ");
						/* if blanks in resource string, quote it */
			call ioa_$rsnnl ("^x-rsc ^[""^]^a^[""^]", buffer, len, (i > 0), request.resource, (i > 0));
			call put_buffer;
		     end;
		end;				/* end not -brief */

	     end;					/* end absentee */

	     if info.request_type = OUTPUT
	     then do;
		if ^info.brief_sw
		then do;
		     if info.forms_sw
		     then do;
			if dprint_msg.version < dprint_msg_version_5
			then auto_forms_name = rtrim (dprint_msg.forms);
			else auto_forms_name = dprint_msg.forms_name;
			i = index (auto_forms_name, " ");
			call ioa_$rsnnl ("^x-forms ^[""^]^a^[""^]", buffer, len, (i > 0), auto_forms_name, (i > 0));
			call put_buffer;
		     end;
		end;
	     end;					/* end output */

	     call put_message (NL);			/* we finally got to the end of that line */

	end;					/* end normal (not long) output mode */

/* Long form. Print each variable in the request in a separate line.
   The first few variables are common to all request types. */

	else do;					/* long form */
	     call put_message (NL);			/* insert leading NL */
	     if print_user_column
	     then do;				/* if more than one user's requests are being listed */
		call ioa_$rs ("User:^21t^a", buffer, len, sender_id);
		call put_buffer;
	     end;
	     aclass_string = "";
	     call convert_authorization_$to_string_short (access_class, aclass_string, code);
	     if aclass_string ^= ""
	     then do;				/* print access class */
		call ioa_$rs ("Access class:^21t^a", buffer, len, aclass_string);
		call put_buffer;
	     end;
	     if info.position_sw
	     then do;
		call ioa_$rs ("Position in queue:^21t^d", buffer, len, position);
		call put_buffer;
	     end;
	     call ioa_$rs ("Request ID:^21t^a", buffer, len, rqid);
	     call put_buffer;
	     time = date_time_$format ("date_time", msg_time, "", "");
	     call ioa_$rs ("Time queued:^21t^a", buffer, len, time);
	     call put_buffer;
	     call ioa_$rs ("^[Input segment:^;Pathname:^]^21t^a^[>^]^a", buffer, len, (info.request_type = ABS),
		dirname, (dirname ^= ">"), ename);
	     call put_buffer;
	     call ioa_$rsnnl ("State:^21t^a", buffer, len, state_names (state));
	     call put_buffer;
	     if state = STATE_DEFERRED & info.request_type = ABS
	     then call explain_abs_deferral;
	     call put_message (NL);

/* Now print per-request-type information */

/* Absentee request */

	     if info.request_type = ABS
	     then do;

/* First print information that's always there */

		if request.restartable
		then str = "yes";
		else str = "no";
		call ioa_$rs ("Restartable:^21t^a", buffer, len, str);
		call put_buffer;

/* Then print values of optional items, but only if they were specified in the request */

		if request.notify
		then call put_message (Notify_msg);
		if request_version > ABS_VER_4
		then do;

/* The Following two messages only apply to newer request_version */

		     if request.restarted
		     then call put_message (Restarted_msg);
		     if request.truncate_absout
		     then call put_message (Truncate_msg);
		end;
		if request.user_deferred_until_time
		then do;
		     time = date_time_$format ("date_time", request.deferred_time, "", "");
		     call ioa_$rs ("Deferred time:^21t^a", buffer, len, time);
		     call put_buffer;
		end;
		if request.user_deferred_indefinitely
		then call put_message_nl ("Deferred:		indefinitely");
		if request.arg_count > 0
		then do;
		     expandlen = request.len_args + 25;
		     allocate args_con_blanks in (region) set (expandp);
		     allocate args_sans_blanks in (region) set (scrunchedp);
		     argl = request.arg_lengths (1);
		     curarg_start = 1;
		     args_sans_blanks = substr (request.args, 1, argl);
		     call ioa_$rs ("Argument string:^21t""^a""", args_con_blanks, expandedlen, args_sans_blanks);
		     info.output_count = info.output_count + expandedlen;
		     substr (cstrng, info.output_count - expandedlen) = substr (args_con_blanks, 1, expandedlen);
		     curarg_start = curarg_start + argl;
		     do argx = 2 to request.arg_count;
			argl = request.arg_lengths (argx);
			args_sans_blanks = substr (request.args, curarg_start, argl);
			call ioa_$rs ("^21t""^a""", args_con_blanks, expandedlen, args_sans_blanks);
			info.output_count = info.output_count + expandedlen;
			substr (cstrng, info.output_count - expandedlen) = substr (args_con_blanks, 1, expandedlen);
			curarg_start = curarg_start + argl;
		     end;
		     free scrunchedp -> args_sans_blanks in (region);
		     free expandp -> args_con_blanks in (region);
		end;
		if request.max_cpu_time > 0
		then do;
		     call ioa_$rs ("CPU limit:^21t^d seconds", buffer, len, request.max_cpu_time);
		     call put_buffer;
		end;
		if request.len_output > 0
		then do;
		     call ioa_$rs ("Output file:^21t^a", buffer, len, request.output_file);
		     call put_buffer;
		end;
		if aim_check_$greater (request.requested_authorization, access_class)
		then do;
		     aclass_string = "";
		     call convert_authorization_$to_string_short (request.requested_authorization, aclass_string,
			code);
		     if aclass_string ^= ""
		     then do;
			call ioa_$rs ("Requested auth:^21t^a", buffer, len, aclass_string);
			call put_buffer;
		     end;
		end;
		if request.len_proxy > 0
		then do;
		     call ioa_$rs ("Proxy user:^21t^a", buffer, len, request.proxy_name);
		     call put_buffer;
		end;
		if request.len_resource > 0
		then do;
		     call ioa_$rs ("Resources required:^21t^a", buffer, len, request.resource);
		     call put_buffer;
		end;
		if request.len_sender > 0
		then do;
		     call ioa_$rs ("Sender:^21t^a", buffer, len, request.sender);
		     call put_buffer;
		end;
		if request.len_comment > 0
		then do;
		     call ioa_$rs ("Comment:^21t^a", buffer, len, request.comment);
		     call put_buffer;
		end;
		if request.request_version > ABS_VER_5	/* version 6 elements */
		then do;
		     if request.no_start_up
		     then do;
			str = "yes";
			call ioa_$rs ("No start_up:^21t^a", buffer, len, str);
			call put_buffer;
		     end;
		     if request.initial_ring ^= -1
		     then do;
			call ioa_$rs ("Initial ring:^21t^d", buffer, len, request.initial_ring);
			call put_buffer;
		     end;
		     if request.len_homedir > 0
		     then do;
			call ioa_$rs ("Home dir:^21t^a", buffer, len, request.home_dir);
			call put_buffer;
		     end;
		     if request.len_initproc > 0
		     then do;
			call ioa_$rs ("Initial proc:^21t^a", buffer, len,
			     substr (request.init_proc, 1, request.len_initproc));
			call put_buffer;
		     end;
		end;
	     end;

/* I/O daemon request */

	     else if info.request_type = IO | info.request_type = OUTPUT
	     then do;

/* Print stuff that's always given */

		if lbound (pp_request_type, 1) <= dprint_msg.output_module
		     & dprint_msg.output_module <= hbound (pp_request_type, 1)
		then do;
		     call ioa_$rs ("Punch format:^21t^a", buffer, len, pp_request_type (dprint_msg.output_module));
		     call put_buffer;
		end;
		call ioa_$rs ("Copies:^21t^d", buffer, len, dprint_msg.copies);
		call put_buffer;
		if dprint_msg.delete_sw
		then str = "yes";
		else str = "no";
		call ioa_$rs ("Delete:^21t^a", buffer, len, str);
		call put_buffer;

/* Then print optional stuff, but only if it was given */

		if dprint_msg.heading ^= ""
		then do;
		     if substr (dprint_msg.heading, 1, 5) = " for "
		     then i = 6;
		     else i = 1;			/* start at char one if dprint added " for" */
		     call ioa_$rs ("Heading:^21t^a", buffer, len, substr (dprint_msg.heading, i));
		     call put_buffer;
		end;
		if dprint_msg.destination ^= ""
		then do;
		     call ioa_$rs ("Destination:^21t^a", buffer, len, dprint_msg.destination);
		     call put_buffer;
		end;
		if dprint_msg.top_label = dprint_msg.bottom_label & dprint_msg.top_label_lth > 0
		then do;
		     call ioa_$rs ("Labels:^21t^a", buffer, len, dprint_msg.top_label);
		     call put_buffer;
		end;
		else do;
		     if dprint_msg.top_label_lth > 0
		     then do;
			call ioa_$rs ("Top label:^21t^a", buffer, len, dprint_msg.top_label);
			call put_buffer;
		     end;
		     if dprint_msg.bottom_label_lth > 0
		     then do;
			call ioa_$rs ("Bottom label:^21t^a", buffer, len, dprint_msg.bottom_label);
			call put_buffer;
		     end;
		end;
		if dprint_msg.version < dprint_msg_version_5
		then auto_forms_name = rtrim (dprint_msg.forms);
		else auto_forms_name = dprint_msg.forms_name;
		if auto_forms_name ^= ""
		then do;
		     call ioa_$rs ("Forms:^21t^a", buffer, len, auto_forms_name);
		     call put_buffer;
		end;
		if dprint_msg.notify
		then call put_message (Notify_msg);
		if dprint_msg.line_nbrs
		then if dprint_msg.version > dprint_msg_version_3
		     then call put_message (line_nbrs_msg);
		if dprint_msg.defer_until_process_termination
		then call put_message (DUPT_msg);
		modes = "";
		if dprint_msg.nep
		then modes = modes || "-no_endpage ";
		if dprint_msg.non_edited
		then modes = modes || "-non_edited ";
		if dprint_msg.single
		then modes = modes || "-single ";
		if dprint_msg.truncate
		then modes = modes || "-truncate ";
		if dprint_msg.no_separator
		then modes = modes || "-no_separator ";
		if dprint_msg.esc
		then modes = modes || "-esc ";
		if dprint_msg.lmargin > 0
		then do;
		     call ioa_$rsnnl ("^a ^d ", tbf, j, "-indent", dprint_msg.lmargin);
		     modes = modes || tbf;
		end;
		if dprint_msg.line_lth > 0
		then do;
		     call ioa_$rsnnl ("^a ^d ", tbf, j, "-line_length", dprint_msg.line_lth);
		     modes = modes || tbf;
		end;
		if dprint_msg.page_lth > 0
		then do;
		     call ioa_$rsnnl ("^a ^d ", tbf, j, "-page_length", dprint_msg.page_lth);
		     modes = modes || tbf;
		end;
		if modes ^= ""
		then do;
		     call ioa_$rs ("Options:^21t^a", buffer, len, modes);
		     call put_buffer;
		end;
		if dprint_msg.chan_stop_path_lth > 0
		then do;
		     call ioa_$rs ("Channel stops:^21t^a", buffer, len, dprint_msg.chan_stop_path);
		     call put_buffer;
		end;
	     end;

/* Retrieval request */

	     else if info.request_type = RETV
	     then do;
		if retv_request.new_dirname ^= ""
		then do;
		     call ioa_$rs ("New pathname:^21t^a^[>^]^a", buffer, len, retv_request.new_dirname,
			(retv_request.new_dirname ^= ">"), retv_request.new_ename);
		     call put_buffer;
		end;
		if retv_request.from_time ^= 0
		then do;
		     time = date_time_$format ("date_time", retv_request.from_time, "", "");
		     call ioa_$rs ("From Time:^21t^a", buffer, len, time);
		     call put_buffer;
		end;
		if retv_request.to_time ^= 0 & ^retv_request.previous
		then do;
		     time = date_time_$format ("date_time", retv_request.to_time, "", "");
		     call ioa_$rs ("To Time:^21t^a", buffer, len, time);
		     call put_buffer;
		end;
		modes = "";
		if retv_request.subtree
		then modes = modes || "subtree ";
		if retv_request.notify
		then modes = modes || "notify ";
		if retv_request.previous
		then modes = modes || "previous ";
		if modes ^= ""
		then do;
		     call ioa_$rs ("Options:^21t^a", buffer, len, modes);
		     call put_buffer;
		end;
	     end;					/* end retrieval request */
	end;					/* end long output mode */

/* As the label suggests, we come here to skip a request that does not meet the user-specified criteria */

skip:						/* Free the storage occupied by this request */
	free reqp -> based_dummy in (region);		/* This will correctly free any one of the request types */

/* Read another request from the queue */

	old_ms_id = mseg_message_info.ms_id;		/* copy message id of last request, for use in incremental read */

	retrying = ""b;
retry_2:
	reqp, requestp, dmp = null;			/* init these to avoid faults */
	local_mseg_message_info.ms_id = old_ms_id;
	local_mseg_message_info.message_code = MSEG_READ_AFTER_SPECIFIED;
	local_mseg_message_info.own = ^read_all;

	call message_segment_$read_message_index (info.mseg_idx, areap, mseg_message_info_ptr, code);

	if ^retrying
	then					/* retry the read once, if queue has been salvaged */
	     if code = error_table_$bad_segment
	     then do;
		retrying = "1"b;
		goto retry_2;
	     end;

	if (rqi_sw & rqi_buffered & allsw)
	then do;
	     rqi_buffered = "0"b;
	     call put_message (NL);			/* insert NL after each request entity */
	end;

	go to loop;

/* End of loop through all requests. The statement at label "loop" checks
   code and comes right back here if it is nonzero. We exit the loop normally
   if code = error_table_$no_message, and abnormally if it is any other nonzero value. */

mess_err:
	if reqp ^= null
	then					/* free up allocated space if necessary */
	     free reqp -> request in (region);		/* This will correctly free any one of the request types */
	if code ^= 0
	then					/* if encounter no message - not an error */
	     if code ^= error_table_$no_message
	     then					/* otherwise return code to caller */
return_code:
		a_code = code;

/* Normal exit.  Put totals figures into the header line that we left room for at the top of the temp segment. */

fin:						/* But first, add totals for this queue to cumulative totals */
	if rqi_sw
	then do;					/* no more formatting neccessary for rqi */
	     info.output_count = info.output_count - 1;	/* reflect actual output count */
	     return;
	end;

	info.user_select_count = info.user_select_count + total_for_user;
						/* tell caller how many he had in the queue */
	info.select_count = info.select_count + total_selected;
						/* and how many we listed */
	info.message_count = info.message_count + messcount;
						/* and how many total requests were in the queue */

/* End a partial "positions" line, if there is one */

	if info.total_sw & info.position_sw & total_selected > 0
	then do;					/* if printing positions, end the line */
	     if total_selected = 1
	     then substr (cstrng, psn_s, 2) = ": ";	/* make Positions: into Position: */
	     substr (cstrng, info.output_count - 1, 1) = ".";
						/* make trailing , into . */
	     call put_message (NL);			/* end the line */
	end;

/* Report on bad requests in this queue, if any */

	if n_bad_vrsn > 0 & (info.total_sw | n_bad_vrsn ^= total_selected)
	then do;
	     call ioa_$rs ("^12x^d requests had obsolete or incorrect formats", buffer, len, n_bad_vrsn);
	     call put_buffer;
	end;

/* And finally, add up totals for queues 0 and 1 if appropriate */

	if (info.abs_q_1 & info.queue = 1 & static_header_position > 0)
	then do;					/* if this is Q 1 and there is Q 0 data */
	     messcount = messcount + static_messcount;	/* add Q 0 total messages to those for Q 1 */
	     total_selected = total_selected + static_total_selected;
						/* likewise for total selected */
	end;

/* Now, if -all (or search_all) was given, eliminate any heading lines that have only zeros in them */

	if (info.all_opt_sw				/* if -all was given */
	     & (messcount = 0 & ^no_totals))		/* and we know this queue is empty */
	     | (info.search_all			/* or if the search_all option is in effect */
	     & total_selected = 0)			/* and we selected no requests from this queue */
	then info.output_count = info.output_count - header_length - 1;
						/* then omit the heading */

/* Otherwise, fill in the header */

	else do;
	     if (info.queue = 0 & info.abs_q_1)
	     then do;				/* if treating abs Q 0 as Q 1 */
		static_header_position = header_position;
						/* save some stuff for use when we list Q 1 */
		static_total_selected = total_selected;
		static_messcount = messcount;
		static_deferred_count = deferred_count;
		static_position = position;
		static_psn_s = psn_s;
		static_ll = ll;
	     end;

	     if ^((info.all_opt_sw | info.search_all) & info.total_sw)
	     then					/* single space the totals lines for -a -tt */
		substr (cstrng, info.output_count, 1) = NL;
						/* put new line at end of information for this queue */
	     else info.output_count = info.output_count - 1;
						/* this is where the NL would have gone */

/* Decide if we want to print Queue N:  R requests. T total requests.
   or			Queue N:  R requests.
   or			Queue N:  T total requests.
*/

	     print_requests = "1"b;			/* start by assuming we will print R requests */
	     if ^no_totals
	     then					/* if we are going to print T total requests,
						   we might want to leave out R requests */
		if messcount = 0			/* 0 requests. 0 total requests. looks dumb */
		     | (messcount = total_selected	/* as does N requests. N total requests (N the same) */
		     & info.admin_sw		/* when you said -admin */
		     & ^select_sw)			/* and didn't give any other selection arguments */
		then print_requests = ""b;		/* so leave out R requests in those cases */

	     if total_selected = 1
	     then s = "";
	     else s = "s";				/* place queue number + number of requests found in header */
	     if info.request_type = ABS
	     then queue_string = "Absentee";
	     else if info.request_type = RETV
	     then queue_string = "Retriever";
	     else do;
		queue_string = info.queue_name;
	     end;
	     i = info.queue;			/* get queue priority number */
	     if i = 0 & info.abs_q_1
	     then i = 1;				/* fake queue number if necessary */
	     call ioa_$rsnnl ("^[Foreground:^x^2s^;^a queue ^d:^4x^]^[^d request^a.^]", buffer, len, (i = -1),
		queue_string, i, print_requests, total_selected, s);
	     i = header_length - 1;			/* and pad remainder of header with blanks */
	     substr (cstrng, header_position, i) = substr (buffer, 1, len);
	     substr (cstrng, header_position + i, 1) = NL;/* place a new line at end of header */
	     if ^no_totals
	     then do;				/* if caller has correct access put total number in header */
		header_position = header_position + len;
		if messcount = 1
		then s = "";
		else s = "s";
		call ioa_$rsnnl (" ^d total request^a^[^x(^d deferred)^].", buffer, len, messcount, s,
		     (deferred_count > 0), deferred_count);
		substr (cstrng, header_position, len) = substr (buffer, 1, len);
	     end;
	end;					/* end fill in header */

	return;


/* ********** INTERNAL PROCEDURES ********** */

put_buffer:
     proc;					/* replaces about 35 instances of these two statements */
	info.output_count = info.output_count + len;
	substr (cstrng, info.output_count - len) = substr (buffer, 1, len);
	return;

     end put_buffer;

/* ********** */

put_message:
     proc (message);

dcl  message char (*);

	nlsw = ""b;
putmsg:
	info.output_count = info.output_count + length (message);
	substr (cstrng, info.output_count - length (message)) = message;
	if nlsw
	then do;
	     info.output_count = info.output_count + 1;
	     substr (cstrng, info.output_count - 1) = NL;
	end;
	return;

put_message_nl:
     entry (message);

dcl  nlsw bit (1) aligned;

	nlsw = "1"b;
	goto putmsg;

     end put_message;


/* ********** */

cleaner_up:
     proc;
	if reqp ^= null
	then free reqp -> request in (region);
	if expandp ^= null
	then free expandp -> args_con_blanks in (region);
	if expandp ^= null
	then free scrunchedp -> args_sans_blanks in (region);

	return;
     end cleaner_up;

/* ********** */

explain_abs_deferral:
     proc;

	if request.operator_deferred_indefinitely
	then call put_message (" indefinitely by operator");
	else if request.cpu_time_limit
	then call put_message (" because of cpu time limit");
	else if request.resources_unavailable
	then call put_message (" - requested resources unavailable");
	else if request.queue_limit
	then call put_message (" because of queue limit");
	else if request.user_limit
	then call put_message (" because of user limit");
	else if request.load_control
	then call put_message (" because of load control group limits");
	else if request.user_deferred_until_time
	then do;
	     call put_message (" by user");
	     if ^info.long_sw
	     then do;				/* if summarizing it on one line, append deferred time */
		time = date_time_$format ("^<date> ^<time>", request.deferred_time, "", "");
						/* format the time */
		call put_message (" to ");
		call put_message ((time));		/* use just mm/dd/yy hhmm.t */
	     end;
	end;
	else if request.user_deferred_indefinitely
	then call put_message (" indefinitely by user");

	return;

     end explain_abs_deferral;

/* ********** */

put_flag:
     proc (the_flag, the_flag_str);

dcl  the_flag bit (1) unal parm;
dcl  the_flag_str char (*) parm;

	if afsw
	then call ioa_$rsnnl ("^a^[^^^]^a,", af_flag_str, rs_len, af_flag_str, ^the_flag, the_flag_str);
	else if the_flag
	then ons = ons || the_flag_str || ", ";
	else offs = offs || the_flag_str || ", ";
	return;
     end put_flag;
%page;

buffer_abs_element:
     proc (abx);

dcl  abx fixed bin;

	goto abs_case (abx);

abs_case (1):					/* max_cpu_time */
	call ioa_$rsnnl ("^[cpu limit:^34t^d^/^;^d^x^]", buffer, len, ^afsw, request.max_cpu_time);
	goto abs_buffer;

abs_case (2):					/* output_file */
	if request.output_file = ""
	then call ioa_$rsnnl ("^[output file:^34t""""^/^;""""^x^]", buffer, len, ^afsw);
	else call ioa_$rsnnl ("^[output file:^34t^a^/^;^a^x^]", buffer, len, ^afsw, request.output_file);
	goto abs_buffer;

abs_case (3):					/* proxy_name */
	if request.proxy_name = ""
	then call ioa_$rsnnl ("^[proxy name:^34t""""^/^;""""^x^]", buffer, len, ^afsw);
	else call ioa_$rsnnl ("^[proxy name:^34t^a^/^;^a^x^]", buffer, len, ^afsw, request.proxy_name);
	goto abs_buffer;

abs_case (4):					/* resource */
	if request.resource = ""
	then call ioa_$rsnnl ("^[resource:^34t""""^/^;""""^x^]", buffer, len, ^afsw);
	else call ioa_$rsnnl ("^[resource:^34t^a^/^;^a^x^]", buffer, len, ^afsw, request.resource);
	goto abs_buffer;

abs_case (5):					/* sender */
	if request.sender = ""
	then call ioa_$rsnnl ("^[sender:^34t""""^/^;""""^x^]", buffer, len, ^afsw);
	else call ioa_$rsnnl ("^[sender:^34t^a^/^;^a^x^]", buffer, len, ^afsw, request.sender);
	goto abs_buffer;

abs_case (6):					/* comment */
	if request.comment = ""
	then call ioa_$rsnnl ("^[comment:^34t""""^/^;""""^x^]", buffer, len, ^afsw);
	else call ioa_$rsnnl ("^[comment:^34t^a^/^;^a^x^]", buffer, len, ^afsw, request.comment);
	goto abs_buffer;

abs_case (7):					/* args */
	if request.arg_count <= 0
	then do;
	     call ioa_$rsnnl ("^[args:^34t""""^/^;""""^x^]", buffer, len, ^afsw);
	     goto abs_buffer;
	end;
	else do;
	     curarg_start = 1;
	     do argx = 1 to request.arg_count;
		argl = request.arg_lengths (argx);
		call ioa_$rsnnl ("^[^[args:^]^34t""^a""^/^;^s""^a""^x^]", buffer, len, ^afsw, (argx = 1),
		     substr (request.args, curarg_start, argl));
		call put_buffer;
		curarg_start = curarg_start + argl;
	     end;
	end;
	return;					/* we already buffered output, so return here */

abs_case (8):					/* home_dir */
	if request.home_dir = ""
	then call ioa_$rsnnl ("^[home dir:^34t""""^/^;""""^x^]", buffer, len, ^afsw);
	else call ioa_$rsnnl ("^[home dir:^34t^a^/^;^a^x^]", buffer, len, ^afsw, request.home_dir);
	goto abs_buffer;

abs_case (9):					/* init_proc */
	if request.init_proc = ""
	then call ioa_$rsnnl ("^[init proc:^34t""""^/^;""""^x^]", buffer, len, ^afsw);
	else call ioa_$rsnnl ("^[init proc:^34t^a^/^;^a^x^]", buffer, len, ^afsw, request.init_proc);
	goto abs_buffer;

abs_case (10):					/* initial_ring */
	call ioa_$rsnnl ("^[initial ring:^34t^d^/^;^d^x^]", buffer, len, ^afsw, request.initial_ring);
	goto abs_buffer;

abs_case (11):					/* authorization */
	aclass_string = "";
	call convert_authorization_$to_string_short (request.requested_authorization, aclass_string, code);
	if aclass_string ^= ""
	then call ioa_$rsnnl ("^[authorization:^34t^a^/^;^a^x^]", buffer, len, ^afsw, aclass_string);
	else call ioa_$rsnnl ("^[authorization:^34t""""^/^;""""^x^]", buffer, len, ^afsw);
	goto abs_buffer;

abs_case (12):					/* deferred_time */
	time = date_time_$format ("date_time", request.deferred_time, "", "");
	call ioa_$rsnnl ("^[deferred time:^34t^a^/^;^a^x^]", buffer, len, ^afsw, time);
	goto abs_buffer;

abs_case (13):					/* deferred_by */
	if request.user_deferred_until_time
	then str = request.name;
	else if request.operator_deferred_until_time
	then str = "Operator";
	else str = """";
	call ioa_$rsnnl ("^[deferred by:^34t^a^/^;^a^x^]", buffer, len, ^afsw, str);

abs_buffer:
	call put_buffer;
	return;

     end buffer_abs_element;

%page;
buffer_com_element:
     proc (cbx);

dcl  cbx fixed bin;

	goto com_case (cbx);

com_case (1):					/* all */
	allsw = "1"b;
	return;

com_case (2):					/* request_id */
	rqid = request_id_ (msg_time);
	call ioa_$rsnnl ("^[message ident:^34t^a^/^;^a^x^]", buffer, len, ^afsw, rqid);
	goto com_buffer;

com_case (3):					/* submitter */
	call ioa_$rsnnl ("^[submitter:^34t^a^/^;^a^x^]", buffer, len, ^afsw, sender_id);
	goto com_buffer;

com_case (4):					/* position */
	call ioa_$rsnnl ("^[position:^34t^d^/^;^d^x^]", buffer, len, ^afsw, position);
	goto com_buffer;

com_case (5):					/* directory */
	call ioa_$rsnnl ("^[directory:^34t^a^/^;^a^x^]", buffer, len, ^afsw, request.dirname);
	goto com_buffer;

com_case (6):					/* entry */
	call ioa_$rsnnl ("^[entry:^34t^a^/^;^a^x^]", buffer, len, ^afsw, request.ename);
	goto com_buffer;

com_case (7):					/* enter_time */
	time = date_time_$format ("date_time", request.msg_time, "", "");
	call ioa_$rsnnl ("^[enter time:^34t^a^/^;^a^x^]", buffer, len, ^afsw, time);
	goto com_buffer;


com_case (8):					/* message_type */
	str = "Unknown type";
	if request.message_type = 0
	then str = "absentee";
	else if request.message_type = 1
	then str = "print";
	else if request.message_type = 2
	then str = "punch";
	else if request.message_type = 3
	then str = "tape";
	else if request.message_type = 4
	then str = "retrieval";
	else if request.message_type = 5
	then str = "imft";
	call ioa_$rsnnl ("^[message type:^34t^a^/^;^a^x^]", buffer, len, ^afsw, str);
	goto com_buffer;

com_case (9):					/* queue */
	call ioa_$rsnnl ("^[queue:^34t^d^/^;^d^x^]", buffer, len, ^afsw, request.orig_queue);
	goto com_buffer;

com_case (10):					/* state */
	call ioa_$rsnnl ("^[state:^34t^a^/^;^a^x^]", buffer, len, ^afsw, state_names (request.state));
	goto com_buffer;

com_case (11):					/* request_flags */
	call put_flag (request.notify, "notify");
	if info.request_type = ABS
	then do;
	     call put_flag (request.delete_sw, "delete");
	     call put_flag (request.defer_until_process_termination, "dupt");
	     call put_flag (request.restartable, "restartable");
	     call put_flag (request.proxy, "proxy");
	     call put_flag (request.set_bit_cnt, "set_bit_cnt");
	     call put_flag (request.operator_deferred_indefinitely, "dfi");
	     call put_flag (request.secondary_ok, "secondary");
	     call put_flag (request.truncate_absout, "truncate");
	     call put_flag (request.restarted, "restarted");
	     call put_flag (request.no_start_up, "nostartup");
	     call put_flag (request.resources_unavailable, "noresources");
	end;
	else if info.request_type = OUTPUT | info.request_type = IO
	then do;
	     call put_flag (request.delete_sw, "delete");
	     call put_flag (request.defer_until_process_termination, "dupt");
	     call put_flag (dprint_msg.nep, "noendpage");
	     call put_flag (dprint_msg.single, "single");
	     call put_flag (dprint_msg.non_edited, "nonedited");
	     call put_flag (dprint_msg.truncate, "truncate_lines");
	     call put_flag (dprint_msg.esc, "escapes");
	     call put_flag (dprint_msg.center_top_label, "center_top_lbl");
	     call put_flag (dprint_msg.center_bottom_label, "center_bot_lbl");
	     call put_flag (dprint_msg.no_separator, "noseparator");
	     if dprint_msg.version > dprint_msg_version_3
	     then call put_flag (dprint_msg.line_nbrs, "line_nbrs");
	end;
	else if info.request_type = RETV
	then do;
	     call put_flag (substr (retv_request.subtree, 1, 1), "subtree");
	     call put_flag (substr (retv_request.dirs, 1, 1), "dirs");
	     call put_flag (substr (retv_request.segs, 1, 1), "segs");
	     call put_flag (substr (retv_request.previous, 1, 1), "prev");
	end;
	else if info.request_type = IMFT
	then do;
	     call put_flag (ft_request.delete, "delete");
	     call put_flag (ft_request.foreign_user_given, "foreign_user_given");
	     call put_flag (ft_request.foreign_path_given, "foreign_path_given");
	     call put_flag (ft_request.remote_transfer, "remote_trans");
	     call put_flag (ft_request.include_files, "files");
	     call put_flag (ft_request.include_subtrees, "subtrees");

	     if ft_request.directory_creation_mode = REPLACE_DIRECTORIES
	     then do;
		call put_flag ("1"b, "replace_dirs");
		call put_flag ("0"b, "merge_dirs");
	     end;
	     else if ft_request.directory_creation_mode = MERGE_DIRECTORIES
	     then do;
		call put_flag ("0"b, "replace_dirs");
		call put_flag ("1"b, "merge_dirs");
	     end;
	     else do;
		call put_flag ("0"b, "replace_dirs");
		call put_flag ("0"b, "merge_dirs");
	     end;

	     call put_flag (ft_request.extend, "extend");
	     call put_flag (ft_request.update, "update");

	     if (ft_request.extend | ft_request.update)
	     then call put_flag ("0"b, "replace");
	     else call put_flag ("1"b, "replace");

	     if ft_request.chase_control = ALWAYS_CHASE
	     then do;
		call put_flag ("1"b, "always_chase");
		call put_flag ("0"b, "default_chase");
		call put_flag ("0"b, "never_chase");
	     end;
	     else if ft_request.chase_control = DEFAULT_CHASE
	     then do;
		call put_flag ("0"b, "always_chase");
		call put_flag ("1"b, "default_chase");
		call put_flag ("0"b, "never_chase");
	     end;
	     else if ft_request.chase_control = NEVER_CHASE
	     then do;
		call put_flag ("0"b, "always_chase");
		call put_flag ("0"b, "default_chase");
		call put_flag ("1"b, "never_chase");
	     end;
	end;
	if afsw
	then do;
	     len = length (af_flag_str);
	     buffer = substr (af_flag_str, 1, len);
	     goto com_buffer;
	end;
	call get_line_length_ ("user_output", ll, code);
	if code ^= 0
	then ll = DEFAULT_LINE_LTH;
	if ll < TOO_SMALL_LINE_LTH
	then ll = DEFAULT_LINE_LTH;
	pass1 = "1"b;
	psn_ll = 0;
	if ons ^= ""
	then do;
	     onslen = length (rtrim (ons)) - 1;		/* remove last comma */
frag_ons:
	     call ioa_$rsnnl ("^[request flags: ^]^[^34t^]^[^39t^]^[ON:  ^]", buffer, len, (^afsw & pass1),
		(^afsw & pass1), (^afsw & ^pass1), pass1);
	     if len > 0
	     then do;
		if (^afsw & pass1)
		then len_offset = TAB_39;
		else if (^afsw & ^pass1)
		then len_offset = TAB_44;
		call put_buffer;
	     end;
	     call ioa_$rsnnl ("^a", buffer, len, substr (ons, psn_ll + 1, onslen - psn_ll));
	     if len > (ll - len_offset)
	     then do;
		last_comma = (ll - len_offset) - (index (reverse (substr (buffer, 1, (ll - len_offset))), " ,"));
		len = last_comma + 1;
		buffer = substr (buffer, 1, len);
		call put_buffer;
		call put_message_nl ("");		/* NL */
		psn_ll = psn_ll + len;
		pass1 = "0"b;			/* dont reprint the ON/OFF */
		goto frag_ons;
	     end;
	     else call put_buffer;
	     call put_message_nl ("");
	end;

format_off_flags:
	pass1 = "1"b;				/* reset for offs */
	psn_ll = 0;
	if offs ^= ""
	then do;					/* now for the offs */
	     offslen = length (rtrim (offs)) - 1;	/* remove last comma */
frag_offs:
	     call ioa_$rsnnl ("^[request flags: ^]^[^34t^]^[^39t^]^[OFF: ^]", buffer, len, (ons = "" & ^afsw & pass1),
		(^afsw & pass1), (^afsw & ^pass1), pass1);
	     if len > 0
	     then do;
		if (^afsw & pass1)
		then len_offset = TAB_39;
		else if (^afsw & ^pass1)
		then len_offset = TAB_44;
		call put_buffer;
	     end;
	     call ioa_$rsnnl ("^a", buffer, len, substr (offs, psn_ll + 1, offslen - psn_ll));
	     if len > (ll - len_offset)
	     then do;
		last_comma = (ll - len_offset) - (index (reverse (substr (buffer, 1, (ll - len_offset))), " ,"));
		len = last_comma + 1;
		buffer = substr (buffer, 1, len);
		call put_buffer;
		call put_message_nl ("");		/* NL */
		psn_ll = psn_ll + len;
		pass1 = "0"b;			/* dont reprint the ON/OFF */
		goto frag_offs;
	     end;
	     else call put_buffer;
	     call put_message_nl ("");
	end;
	return;

com_buffer:
	call put_buffer;
	return;

     end buffer_com_element;

%page;

buffer_output_element:
     proc (ocx);

dcl  ocx fixed bin;

	goto out_case (ocx);

out_case (1):					/* bit_count */
	call ioa_$rsnnl ("^[bit count:^34t^d^/^;^d^x^]", buffer, len, ^afsw, dprint_msg.bit_count);
	goto out_buffer;

out_case (2):					/* copies */
	call ioa_$rsnnl ("^[copies:^34t^d^/^;^d^x^]", buffer, len, ^afsw, dprint_msg.copies);
	goto out_buffer;

out_case (3):					/* destination */
	if dprint_msg.destination = ""
	then call ioa_$rsnnl ("^[destination:^34t""""^/^;""""^x^]", buffer, len, ^afsw);
	else call ioa_$rsnnl ("^[destination:^34t^a^/^;^a^x^]", buffer, len, ^afsw, dprint_msg.destination);
	goto out_buffer;

out_case (4):					/* heading */
	if dprint_msg.heading = ""
	then call ioa_$rsnnl ("^[heading:^34t""""^/^;""""^x^]", buffer, len, ^afsw);
	else call ioa_$rsnnl ("^[heading:^34t^a^/^;^a^x^]", buffer, len, ^afsw, dprint_msg.heading);
	goto out_buffer;

out_case (5):					/* indent */
	call ioa_$rsnnl ("^[indent:^34t^d^/^;^d^x^]", buffer, len, ^afsw, dprint_msg.lmargin);
	goto out_buffer;

out_case (6):					/* line_length */
	if dprint_msg.line_lth = DEFAULT_OUTPUT_LTH
	then str = "default";
	else call ioa_$rsnnl ("^d", str, len, dprint_msg.line_lth);
	call ioa_$rsnnl ("^[line length:^34t^a^/^;^a^x^]", buffer, len, ^afsw, str);
	goto out_buffer;

out_case (7):					/* page_length */
	if dprint_msg.page_lth = DEFAULT_OUTPUT_LTH
	then str = "default";
	else call ioa_$rsnnl ("^d", str, len, dprint_msg.page_lth);
	call ioa_$rsnnl ("^[page length:^34t^a^/^;^a^x^]", buffer, len, ^afsw, str);
	goto out_buffer;

out_case (8):					/* top_label */
	if dprint_msg.top_label = ""
	then call ioa_$rsnnl ("^[top label:^34t""""^/^;""""^x^]", buffer, len, ^afsw);
	else call ioa_$rsnnl ("^[top label:^34t^a^/^;^a^x^]", buffer, len, ^afsw, dprint_msg.top_label);
	goto out_buffer;

out_case (9):					/* bottom_label */
	if dprint_msg.bottom_label = ""
	then call ioa_$rsnnl ("^[bottom label:^34t""""^/^;""""^x^]", buffer, len, ^afsw);
	else call ioa_$rsnnl ("^[bottom label:^34t^a^/^;^a^x^]", buffer, len, ^afsw, dprint_msg.bottom_label);
	goto out_buffer;

out_case (10):					/* output_conversion */
	str = "Unknown value";
	if dprint_msg.output_module = 1
	then str = "print";
	else if dprint_msg.output_module = 2
	then str = pp_request_type (2);
	else if dprint_msg.output_module = 3
	then str = pp_request_type (3);
	else if dprint_msg.output_module = 4
	then str = pp_request_type (4);
	else if dprint_msg.output_module = 5
	then str = "plotter";
	call ioa_$rsnnl ("^[output conversion:^34t^a^/^;^a^x^]", buffer, len, ^afsw, str);
	goto out_buffer;

out_case (11):					/* forms */
	if dprint_msg.version < dprint_msg_version_5
	then auto_forms_name = rtrim (dprint_msg.forms);
	else auto_forms_name = dprint_msg.forms_name;
	if auto_forms_name = ""
	then call ioa_$rsnnl ("^[forms:^34t""""^/^;""""^x^]", buffer, len, ^afsw);
	else call ioa_$rsnnl ("^[forms:^34t^a^/^;^a^x^]", buffer, len, ^afsw, auto_forms_name);

out_buffer:
	call put_buffer;
	return;

     end buffer_output_element;

%page;
buffer_retv_element:
     proc (rcx);

dcl  rcx fixed bin;

	goto retv_case (rcx);

retv_case (1):					/* from_time */
	time = date_time_$format ("date_time", retv_request.from_time, "", "");
	call ioa_$rsnnl ("^[from time:^34t^a^/^;^a^x^]", buffer, len, ^afsw, time);
	goto retv_buffer;

retv_case (2):					/* new_dir */
	if retv_request.new_dirname = ""
	then call ioa_$rsnnl ("^[new directory:^34t""""^/^;""""^x^]", buffer, len, ^afsw);
	else call ioa_$rsnnl ("^[new directory:^34t^a^/^;^a^x^]", buffer, len, ^afsw, retv_request.new_dirname);
	goto retv_buffer;

retv_case (3):					/* new_entry */
	if retv_request.new_ename = ""
	then call ioa_$rsnnl ("^[new entryname:^34t""""^/^;""""^x^]", buffer, len, ^afsw);
	else call ioa_$rsnnl ("^[new entryname:^34t^a^/^;^a^x^]", buffer, len, ^afsw, retv_request.new_ename);
	goto retv_buffer;

retv_case (4):					/* to_time */
	time = date_time_$format ("date_time", retv_request.to_time, "", "");
	call ioa_$rsnnl ("^[to time:^34t^a^/^;^a^x^]", buffer, len, ^afsw, time);

retv_buffer:
	call put_buffer;
	return;

     end buffer_retv_element;

%page;
buffer_imft_element:
     proc (icx);

dcl  icx fixed bin;

	goto imft_case (icx);

imft_case (1):					/* foreign_dir */
	if ft_request.foreign_dirname = "" | ^ft_request.foreign_path_given
	then call ioa_$rsnnl ("^[foreign directory:^34t""""^/^;""""^x^]", buffer, len, ^afsw);
	else call ioa_$rsnnl ("^[foreign directory:^34t^a^/^;^a^x^]", buffer, len, ^afsw, ft_request.foreign_dirname);
	goto imft_buffer;

imft_case (2):					/* foreign_entry */
	if ft_request.foreign_ename = "" | ^ft_request.foreign_path_given
	then call ioa_$rsnnl ("^[foreign entryname:^34t""""^/^;""""^x^]", buffer, len, ^afsw);
	else call ioa_$rsnnl ("^[foreign entryname:^34t^a^/^;^a^x^]", buffer, len, ^afsw, ft_request.foreign_ename);
	goto imft_buffer;

imft_case (3):					/* foreign_user */
	if ft_request.foreign_user = "" | ^ft_request.foreign_user_given
	then call ioa_$rsnnl ("^[foreign user:^34t""""^/^;""""^x^]", buffer, len, ^afsw);
	else call ioa_$rsnnl ("^[foreign user:^34t^a^/^;^a^x^]", buffer, len, ^afsw, ft_request.foreign_user);

imft_buffer:
	call put_buffer;
	return;

     end buffer_imft_element;

%page;
%include abs_message_format;
%page;
%include branch_status;
%page;
%include dprint_msg;
%page;
%include "_imft_ft_request";
%page;
%include lar_info;
%page;
%include mseg_message_info;
%page;
%include queue_msg_hdr;
%page;
%include retv_request;
%page;
%include user_abs_attributes;

     end lar_util_;
