/* ******************************************************
   *                                                    *
   *                                                    *
   * Copyright (c) 1972 by Massachusetts Institute of   *
   * Technology and Honeywell Information Systems, Inc. *
   *                                                    *
   *                                                    *
   ****************************************************** */

/* format: style3 */

/* program to compile expressions

   Initial Version:  9 April 1971 by BLW for Version II
	Modified: 25 January 1973 by BLW
	Modified:	16 February 1973 by RAB
	Modified:	27 June 1973 by RAB for EIS
	Modified:	10 Sept 1975 by RAB to fix 1417
	Modified:	25 Sept 1975 by RAB to fix 1423
	Modified:	5 Oct 1975 for repeat_fun optimization
	Modified:	1 Feb 1976 by RAB for reverse_fun optimization
	Modified:	1 Feb 1976 by RAB to fix 1458
	Modified:	10 Feb 1976 by RAB to fix 1464
	Modified:	15 June 1976 by RAB to fix 1501
	Modified:	23 June 1976 by RAB to centralize use of cg_stat$last_call
	Modified:	7 Dec 1976 by RAB to fix 1559
	Modified:	23 Dec 1976 by RAB for after,before,ltrim,rtrim
	Modified:	30 Dec 1976 by RAB for 9-bit translate, search, verify	
	Modified 770619 by PG for clock, vclock, and stacq
	Modified:	12 July 1977 by RAB to change stacq definition
	Modified:	7 August 1978 by RAB to partially fix 1731
	Modified 780828 by PG to fix 1744 and remove pos_diff_fun
	Modified:	16 July 1979 by RAB to fix 1852 (abs(unal_auto) fails)
		and to remove use of absfx1_atm for faster code.
	Modified: 25 July 1979 by PCK to implement rank and byte builtins
	Modified: 29 August 1979 by PCK to fix bug 1853
	Modified 791023 by PG to recognize substr(string_const,const,1) in several contexts by inventing
		is_string_constant.
	Modified 791023 by PG to fix 1857 in which rank and byte didn't accept expressions.
	Modified 791026 by PG to use TCT tables in pl1_operators_ when possible.
	Modified December 1979 by BSG for reverse index, verify, search, 2 char reverse, and reverse bugs.
	Modified 800218 by PG to have math builtins update machine_state.indicators.
	Modified: 29 Feb 1980 to fix 1921
	Modified:	30 March 1980 by RAB for reference.(aligned padded)_for_store_ref.
		See prepare_operand for details.
	Modified: 15 August 1980 by M. N. Davidoff to fix 2005.
	Modified: 16 September 1980 by M. N. Davidoff to fix 1985.
*/
/* format: style3 */
compile_exp:
     proc (pt);

/* parameters */

dcl	pt		ptr;			/* points at operator node */

/* external static */

dcl	(
	cg_stat$cur_node,
	cg_stat$temp_ref,
	cg_stat$eis_temp,
	cg_stat$complex_ac,
	cg_stat$text_base
	)		ptr ext,
	(
	cg_stat$text_pos,
	cg_stat$offset_null_value
	)		fixed bin ext,
	(
	cg_stat$save_exp_called,
	cg_stat$for_test_called,
	cg_stat$extended_stack
	)		bit (1) ext;

dcl	(
	opcode_info$opcode_info
			(0:118),
	opcode_info$last_opcode,
	opcode_info$table	(0:18)
	)		fixed bin ext;

/* automatic */

dcl	(
	p,
	q,
	pa,
	ref1,
	save_cur_node,
	ref		(5),
	sym		(5),
	rand		(5)
	)		ptr,
	(
	sec,
	ftc,
	in_storage,				/* Conjecture: means result is in ref1 */
	inline,
	load_it,
	atom		(5),
	update_long,
	constant_rands,
	save_it,
	scaled,
	update_ref,
	atomic,
	is_string,
	check_type,
	check_aligned
	)		bit (1) aligned,
	c_offset		fixed bin (24),
	drop		bit (1) aligned init ("0"b),
	op_code		bit (9),
	b3		bit (3) aligned;
dcl	double		bit (72) aligned;
dcl	(mvt_table, result_string)
			char (512) aligned,
	op_class		bit (5) defined (op_code) pos (1),
	op_relative	bit (4) defined (op_code) pos (6),
	(
	i,
	j,
	k,
	n,
	action,
	op_rel,
	delta,
	call_code,
	code,
	type		(5),
	bump,
	orig_count,
	rlength,
	scale,
	array		(2)
	)		fixed bin,
	(save_l1, save_l2)	fixed bin (24),
	save_mwif		bit (1),
	save_coff		fixed bin (24),
	save_units	fixed bin (3),
	(macro, m)	fixed bin (15);

/* entries */

dcl	(
	load,
	load$for_test,
	load$for_save
	)		entry (ptr, fixed bin),
	load$long_string	entry (ptr),
	(assign_op, load_size)
			entry (ptr),
	aq_man$fix_scale	entry (ptr, fixed bin, fixed bin),
	aq_man$check_strings
			entry (fixed bin (8)),
	aq_man$left_shift	entry (fixed bin (8), bit (1) aligned),
	aq_man$right_shift	entry (fixed bin (8), bit (1) aligned),
	min_max		entry (ptr),
	compile_exp	entry (ptr),
	gen_arithmetic_builtin
			entry (ptr, (5) ptr, (5) bit (1) aligned, fixed bin),
	gen_arithmetic_call entry (ptr, (5) ptr, (5) aligned bit (1)),
	xr_man$load_const	entry (fixed bin, fixed bin),
	(
	compile_exp$save,
	compile_exp$save_exp
	)		entry (ptr) returns (ptr),
	c_a		entry (fixed bin (18), fixed bin) returns (ptr),
	base_man$load_var	entry (fixed bin, ptr, fixed bin),
	(
	base_man$load_a_var,
	base_man$load_q_var,
	base_man$load_aq_var
	)		entry (ptr),
	base_to_core	entry (fixed bin, ptr),
	expmac		entry (fixed bin (15), ptr),
	expmac$many_eis	entry (fixed bin (15), ptr, fixed bin),
	expmac$conditional	entry (fixed bin (15), ptr, (5) ptr, (5) bit (1) aligned),
	(
	expmac$eis,
	expmac$one_eis
	)		entry (fixed bin (15), ptr),
	expmac$two_eis	entry (fixed bin (15), ptr, ptr),
	expmac$abs	entry (ptr, fixed bin),
	long_op$eis_operator
			entry (ptr, ptr, fixed bin (15)),
	cg_error		entry (fixed bin, fixed bin),
	prepare_operand	entry (ptr, fixed bin, bit (1) aligned) returns (ptr),
	eval_exp		entry (ptr, bit (1) aligned) returns (ptr),
	(arith_op, decimal_op, exp_op)
			entry (ptr, (5) ptr, (5) bit (1) aligned),
	(string_op, cat_op) entry (ptr, (5) ptr, fixed bin),
	pointer_builtins	entry (ptr, bit (1) aligned),
	get_reference	entry returns (ptr),
	inline_operation	entry (ptr, (5) ptr, (5) bit (1) aligned) returns (bit (1) aligned),
	set_indicators	entry (ptr, ptr, ptr, fixed bin) returns (fixed bin),
	expmac$zero	entry (fixed bin (15)),
	(
	store$save_string_temp,
	store$force,
	state_man$update_ref
	)		entry (ptr),
	state_man$set_aliasables
			entry (ptr),
	stack_temp$assign_block
			entry (ptr, fixed bin),
	state_man$erase_temps
			entry,
	(
	long_op,
	long_op$c_or_b
	)		entry (ptr, fixed bin, fixed bin (15));
dcl	generate_constant$bit_string
			entry (bit (*) aligned, fixed bin) returns (ptr);
dcl	generate_constant$real_fix_bin_1
			entry (fixed bin) returns (ptr),
	generate_constant$char_string
			entry (char (*) aligned, fixed bin (24)) returns (ptr),
	state_man$erase_reg entry (bit (19) aligned),
	state_man$flush	entry,
	string_temp	entry (ptr, ptr, ptr) returns (ptr),
	aq_man$lock	entry (ptr, fixed bin),
	adjust_ref_count	entry (ptr, fixed bin),
	copy_temp		entry (ptr) returns (ptr),
	share_expression	entry (ptr) returns (ptr);

/* builtins */

dcl	(addr, addrel, collate9, copy, fixed, hbound, index, length, min, mod, null, rank, string, substr)
			builtin;

/* based */

dcl	1 bit_table_structure
			based (addr (mvt_table)) aligned,
	  2 bit_table	(0:511) bit (9) unaligned;

dcl	fixed_bin_single	fixed bin based,
	fixed_bin_double	fixed bin (71) based,
	word		bit (36) aligned based;

dcl	based_cs		char (1) aligned based;
dcl	based_bs		bit (1) aligned based;

dcl	1 mlr_instruction	based aligned,
	  2 fill		char (1) unal,		/* fill character -- can be set by compile_exp */
	  2 enablefault	bit (1) unal,
	  2 pad1		bit (1) unal,
	  2 mf2		bit (7) unal,
	  2 opcode	bit (10) unal,
	  2 inhibit	bit (1) unal,
	  2 mf1		bit (7) unal;

dcl	1 csl_instruction	based aligned,
	  2 fill		bit (1) unal,
	  2 pad1		bit (4) unal,
	  2 bool		bit (4) unal,
	  2 enablefault	bit (1) unal,
	  2 pad2		bit (1) unal,
	  2 mf2		bit (7) unal,
	  2 opcode	bit (10) unal,
	  2 inhibit	bit (1) unal,
	  2 mf1		bit (7) unal;

dcl	bit4		bit (4) based aligned;

dcl	1 op_info		aligned based,
	  2 act1		unal bit (6),
	  2 act2		unal bit (6),
	  2 macro		unal bit (18),
	  2 delta		unal bit (2),
	  2 call_code	unal bit (4);

/* internal static */


dcl	(
	zero_bs		init (468),
	one_bs		init (469),
	blank_cs		init (472),
	inline_verify	init (207),
	inline_search	init (199),
	inline_translate	init (111),
	test_translate	init (157),
	test_translate_rev	init (158),
	verify_ltrim_inline init (712),
	verify_rtrim_inline init (713),
	absfx1		init (126),
	testfx1		init (508),
	ldfx1		init (7),
	ldfx2		init (8),
	als		init (134),
	arl		init (245),
	qrs		init (514),
	anq		init (688),
	ana		init (40),
	llr		init (372),
	scaled_mdfx1	init (549),
	mdfl1		init (269),
	mdfl2		init (270),
	stfl2		init (18),
	stfx1		init (15),
	offset_mac_easy	init (242),
	offset_mac_hard	init (600),
	chars_move	init (420),
	move_bits		init (99),
	test_bits		init (96),
	fetch_chars_eis	init (588),
	index_chars	(4) init (452, 700, 702, 256),
	index_chars_1	(4) init (460, 704, 706, 256),
	index_mac		(3, 2) init (460, 462, 704, 708, 706, 709),
	index_rev_mac	(2) init (463, 464),
	round_fl		init (531),
	atan2_mac		init (504),
	atan2d_mac	init (557),
	a_to_x0		init (306),
	rank_eis_mac	init (740),
	qrl		init (418),
	trunc_mac		(0:1) init (124, 384)
	)		fixed bin (15) int static options (constant);

dcl	rel_table		(4:9 /* op */, 0:1 /* string? */, 0:1 /* reversed? */) fixed bin (15) int static
			init (159, 161, 160, 162,	/* < */
			161, 159, 162, 160,		/* > */
			163, 163, 163, 163,		/* = */
			164, 164, 164, 164,		/* ^= */
			165, 167, 166, 168,		/* <= */
			167, 165, 168, 166);	/* >= */

dcl	exp_table		(4, 4) fixed bin (15) int static init (592, 0, 559, 560,
						/* fb1 */
			0, 0, 0, 0,		/* fb2 */
			591, 0, 565, 562,		/* flb1 */
			564, 0, 561, 562);		/* flb2 */


/* include files */

%include cgsystem;
%include reference;
%include symbol;
%include operator;
%include machine_state;
%include nodes;
%include data_types;
%include boundary;
%include op_codes;
%include mask;
%include bases;

/* program */

	ftc = cg_stat$for_test_called;
	cg_stat$for_test_called = "0"b;

start:
	sec = cg_stat$save_exp_called;
	cg_stat$save_exp_called = "0"b;

	p = pt;

	if p -> node.type ^= operator_node
	then do;
is_atom:
		i = p -> reference.data_type;
		call load (p, fixed (i = char_string | i = bit_string, 1));
		save_cur_node = cg_stat$cur_node;
		goto return_1;
	     end;

	ref (1) = p -> operand (1);
	if ^ref (1) -> reference.shared
	then do;

		if ref (1) -> reference.evaluated
		then do;
			p = ref (1);
			goto is_atom;
		     end;

		if ref (1) -> reference.temp_ref & ^ref (1) -> reference.long_ref & ^ref (1) -> reference.aggregate
		     & ref (1) -> reference.data_type ^= complex_flt_bin_1
		then drop = "1"b;
		else drop = "0"b;

	     end;

work:
	save_cur_node = cg_stat$cur_node;
	cg_stat$cur_node = p;

	save_it = cg_stat$save_exp_called;
	update_ref = "1"b;

	update_long, in_storage = "0"b;
	op_code = p -> operator.op_code;

	do i = 1 to min (p -> operator.number, hbound (rand, 1));
	     rand (i) = p -> operand (i);
	end;

	op_rel = fixed (op_relative, 4);
	k = opcode_info$table (fixed (op_class, 5)) + op_rel;
	if k > opcode_info$last_opcode
	then goto not_yet;

	q = addr (opcode_info$opcode_info (k));
	action = fixed (q -> op_info.act1, 6);

	goto switch_a (action);

/* assignment and picture operators */

switch_a (1):
	call assign_op (pt);
	ref1 = cg_stat$temp_ref;
	goto return;

/* min and max builtins */

switch_a (2):
	call min_max (pt);
	ref1 = cg_stat$temp_ref;

	if ref1 -> reference.symbol -> symbol.decimal
	then goto return;

	inline = "1"b;
	goto done_1;

/* error conditions */

switch_a (4):
	call cg_error (300, fixed (op_code, 9));	/* operator in wrong context */
	goto return;

switch_a (5):
not_yet:
	call cg_error (301, fixed (op_code, 9));	/* operator not yet implemented */
	goto return;

/* pointer valued builtin functions */

switch_a (6):
	call pointer_builtins (p, ^drop);

/* This used to avoid references that were shared. Now that shared */
/* temps are no longer permitted on the output side of pointer expressions, */
/* we set evaluated. This sets evaluated for non-tems in particular */
/* So any non-temp, or any non-shared temp is set evaluated */

	ref1 = p -> operator.operand (1);
	if ^ref1 -> reference.temp_ref | ^ref1 -> reference.shared
	then ref1 -> reference.evaluated = "1"b;
					         
	goto return;

/* most op codes come here */

switch_a (3):
	action = fixed (q -> op_info.act2, 6);
	macro = fixed (q -> op_info.macro, 18);
	delta = fixed (q -> op_info.delta, 2);
	call_code = fixed (q -> op_info.call_code, 4);

	n = p -> operator.number;
	do i = n by -1 to 2;
	     q = prepare_operand (rand (i), 1, atom (i));
	     ref (i) = q;
	     sym (i) = q -> reference.symbol;
	     type (i) = q -> reference.data_type;
	end;

/* There appears to be a convention that the size expression must be evaluated
   before m_a is called.  So, we evaluate the size expression here for those
   optimizations that would otherwise call m_a before evaluating the size
   expression. This fixes 1985. */

/* This fix referenced ref (2) for operators with only one operand. oops */

	if op_code = repeat_fun
	then if ref (2) -> reference.c_length = 1 & is_string_constant (2)
	     then ref1 = prepare_operand (rand (1), 1, atom (1));
	     else go to prepare_minus_1;
	else
prepare_minus_1:
	     ref1 = prepare_operand (rand (1), -1, atom (1));

	ref (1) = ref1;
	sym (1) = ref (1) -> reference.symbol;
	type (1) = ref (1) -> reference.data_type;

/* we can't use the "for_test" code sequences if result is needed elsewhere */

	cg_stat$for_test_called = cg_stat$for_test_called & ref1 -> reference.ref_count <= 1;

	if sym (1) -> symbol.decimal
	then inline = "0"b;

	else if sym (1) -> symbol.complex | action = 7 | action = 30
	then inline = inline_operation (p, ref, atom);

	else /* operations with real results are done inline */
	     inline = "1"b;

/* compute context code */

	if n = 2
	then code = fixed (atom (2), 1);
	else if n = 3
	then code = fixed (atom (2) || atom (3), 2);

	if sym (1) -> symbol.complex & inline
	then do;

		if ^ref (1) -> reference.allocate
		then do;

use_cpx:
			q = get_reference ();
			q -> reference = ref (1) -> reference;
			ref (1) = q;

			ref (1) -> reference.offset, ref (1) -> reference.qualifier = null;
			string (ref (1) -> reference.address) = string (cg_stat$complex_ac -> reference.address);
			ref (1) -> reference.relocation = cg_stat$complex_ac -> reference.relocation;
			ref (1) -> reference.perm_address = "1"b;
			goto branch;
		     end;

		else if ref (1) -> reference.temp_ref
		then do;
			ref (1) -> reference.value_in.storage = "1"b;
			if ^cg_stat$save_exp_called
			then do;
				save_it = "1"b;
				ref (1) -> reference.ref_count = ref (1) -> reference.ref_count + 1;
			     end;
		     end;

		if op_code = mult
		then if min (type (2), type (3)) = complex_flt_bin_1
		     then goto use_cpx;
		     else ;
		else if op_code = div
		then if type (3) = complex_flt_bin_1
		     then goto use_cpx;

		if ref (1) -> reference.offset ^= null
		then goto use_cpx;

		q = ref (1) -> reference.symbol;
		if q -> symbol.static & q -> symbol.external
		then goto use_cpx;
		if q -> symbol.parameter
		then goto use_cpx;

		in_storage = "1"b;
		update_ref = "0"b;
	     end;

branch:
	goto switch_b (action);

/* arithmetic operators */

switch_b (1):
	if ^inline
	then if sym (1) -> symbol.decimal
	     then call decimal_op (pt, ref, atom);

/* cannot do arithmetic operation inline, generate procedure call */

	     else call gen_arithmetic_call (p, ref, atom);

	else call arith_op (pt, ref, atom);

/* check to see if result should be stored */

done:
	cg_stat$temp_ref = ref1;

done_1:
	if ^ref1 -> reference.shared
	then ref1 -> reference.evaluated = "1"b;

	if ^inline
	then goto return;

	if cg_stat$for_test_called
	then goto return;

	if update_ref & (^ref1 -> reference.long_ref | update_long)
	then do;
		k = ref1 -> reference.c_offset;
		ref1 -> reference.c_offset = 0;

		call state_man$update_ref (ref1);

		ref1 -> reference.c_offset = k;
	     end;

	if ref1 -> reference.allocate
	then do;

		if ref1 -> reference.temp_ref
		then if ^save_it
		     then if ^ref1 -> reference.aggregate
			then go to return;

		if ref1 -> reference.long_ref
		then do;
			if ref1 -> reference.temp_ref & ^ref1 -> reference.aggregate
			then if ref1 -> reference.address_in.storage
			     then call store$save_string_temp (ref1);
			     else ;
			else if ref1 ^= cg_stat$eis_temp
			then call expmac$two_eis (chars_move + type (1) - char_string, ref1, cg_stat$eis_temp);
			goto return;
		     end;

		if in_storage
		then goto return;

		if ref1 -> reference.data_type = complex_flt_bin_1
		then call expmac ((ldfx2), cg_stat$complex_ac);

		call store$force (ref1);
	     end;

return:
	if cg_stat$save_exp_called
	then do;
		ref_pt = cg_stat$temp_ref;
		ref_pt -> reference.ref_count = orig_count;
	     end;
	else if drop
	then call adjust_ref_count (ref1, -1);

return_1:
	cg_stat$save_exp_called = sec;
	cg_stat$for_test_called = ftc;
	cg_stat$cur_node = save_cur_node;
	return;

/* exponentiation operator */

switch_b (2):
	if type (3) = real_fix_bin_1
	then if is_constant (3)
	     then if sym (3) -> symbol.initial -> fixed_bin_single > 1
		then do;
			call exp_op (pt, ref, atom);
			go to done;
		     end;
		else if sym (3) -> symbol.initial -> fixed_bin_single = 1
		then go to switch_a (1);

	check_type = "0"b;
	macro = exp_table (type (2), type (3));
	call math_op;
	goto done;

/* string operators */

switch_b (3):
	cg_stat$for_test_called = cg_stat$for_test_called & ref1 -> reference.ref_count <= 1;

	call string_op (pt, ref, code);

	goto done;

/* relational operators */

switch_b (4):
	call state_man$erase_temps;
	k = set_indicators (pt, ref (2), ref (3), code);

	if type (2) <= real_flt_bin_2
	then j = 0;
	else do;
		q = ref (2) -> reference.symbol;
		j = fixed (q -> symbol.bit | q -> symbol.char, 1);
	     end;

	call expmac$zero ((rel_table (op_rel, j, k)));
	a_reg.size = 1;
	goto bnf1;

/* rel, baseno, wordno, charno, bitno, (set, add)x(word bit char)no */


declare	charno_mac	fixed bin (15) init (691) int static options (constant);
declare	bitno_mac		fixed bin (15) init (692) int static options (constant);
declare	baseno_mac	fixed bin (15) init (241) int static options (constant);
declare	segno_mac		fixed bin (15) init (240) int static options (constant);
declare	packed_pointer	bit (1) aligned;

switch_b (5):
	if ref (2) -> reference.data_type = packed_ptr
	then do;
		packed_pointer = "1"b;
		if ^ref (2) -> reference.value_in.storage
						/* if it happens to be in a PR from use, use it there! */
		then if ^ref (2) -> reference.value_in.q/* in a PR */
		     then if string (ref (2) -> reference.value_in.b) ^= ""b
			then packed_pointer = "0"b;	/* treat as unpacked */
	     end;
	else do;
		packed_pointer = "0"b;

		if ^atom (2)			/* first operand (other than output) */
		then if rand (2) -> node.type = operator_node
						/* certain packed pointers can be ^atom */
		     then do;			/* must be turned into a pointer */
			     call pointer_builtins (rand (2), "0"b);
			     ref (2) = rand (2) -> operand (1);
			     if ^ref (2) -> reference.shared
			     then ref (2) -> reference.evaluated = "1"b;
			end;
	     end;

	if packed_pointer
	then go to PACKED_POINTER_BIFS (macro);
	else go to POINTER_BIFS (macro);		/* macro contains 1...highest of these */


PACKED_POINTER_BIFS (1):				/* rel */
PACKED_POINTER_BIFS (10):				/* baseno */
	ref (2) -> reference.data_type = bit_string;
	go to LOAD_PP_COMMON;
PACKED_POINTER_BIFS (2):				/* wordno */
PACKED_POINTER_BIFS (3):
PACKED_POINTER_BIFS (4):
PACKED_POINTER_BIFS (9):				/* segno */
	ref (2) -> reference.data_type = real_fix_bin_1;

LOAD_PP_COMMON:
	call load (ref (2), 0);
	ref (2) -> reference.data_type = packed_ptr;

	go to PACKED_POINTER_BIFS_2 (macro);		/* do the work */

PACKED_POINTER_BIFS_2 (1):				/* rel */
	q = c_a ((bits_per_half), 1);			/* no MOD */
	call expmac (als, q);
	go to RETURN_18_BITS;

PACKED_POINTER_BIFS_2 (2):				/* wordno */
	q = c_a (-1, 2);				/* DL */
	call expmac (anq, q);
	go to done;

declare	charno_packed_mac	init (377) fixed bin (15) int static options (constant);
PACKED_POINTER_BIFS_2 (3):				/* charno */
	call expmac$zero (charno_packed_mac);		/* uses table */
	go to done;

PACKED_POINTER_BIFS_2 (4):				/* bitno */
	q = c_a (12 + 18, 1);			/* top 6 bits */
	call expmac (qrl, q);			/* are the bit number */
	go to done;

declare	baseno_mask	init (4095) fixed bin (18) static options (constant);

PACKED_POINTER_BIFS_2 (9):				/* segno */
	q = c_a ((bits_per_half), 1);
	call expmac (qrl, q);
	q = c_a (baseno_mask, 2);			/* DL */
	call expmac (anq, q);
	go to done;

PACKED_POINTER_BIFS_2 (10):				/* baseno */
	q = c_a (baseno_mask, 3);			/* DU */
	call expmac (ana, q);
	go to RETURN_18_BITS;


POINTER_BIFS (1):					/* rel */
	call base_man$load_a_var (ref (2));
	go to RETURN_18_BITS;


POINTER_BIFS (2):					/* wordno */
	call base_man$load_q_var (ref (2));
	macro = qrl;				/* to QL */
	q = c_a ((bits_per_half), 1);			/* NO MOD */
	call expmac (macro, q);
	go to done;


POINTER_BIFS (3):					/* charno */
	call base_man$load_aq_var (ref (2));
	call expmac$zero (charno_mac);
	go to done;

POINTER_BIFS (4):					/* bitno */
	call base_man$load_aq_var (ref (2));
	call expmac$zero (bitno_mac);
	go to done;


POINTER_BIFS (9):					/* segno */
POINTER_BIFS (10):					/* baseno */
	call base_man$load_aq_var (ref (2));
	if op_code = segno_fun
	then do;
		call expmac$zero (segno_mac);
		go to done;
	     end;
	call expmac$zero (baseno_mac);		/* fall through */

RETURN_18_BITS:
l9a:
	a_reg.size = bits_per_half;

bnf1:
	a_reg.length = bits_per_word;
	a_reg.offset = 0;
	goto done;


/* bit_to_char, bit_to_word, char_to_word, half_to_word, word_to_mod2, word_to_mod4, word_to_mod8 operators */

switch_b (6):
	if ^inline
	then goto ext_call;

l2:
	if atom (2)
	then call load (ref (2), 0);
	else call compile_exp (rand (2));

	if delta = 1
	then macro = macro + fixed (type (1) ^= real_fix_bin_1, 1);

switch_b (23):					/* not used by opcode_info */
l2a:
	if macro ^= 0
	then call expmac$zero (macro);
	goto done;

/* abs function */

switch_b (7):
	if ^inline
	then do;

ext_call:
		load_it = "0"b;
		if ref (1) -> reference.temp_ref & ^cg_stat$save_exp_called
		then do;
			if sym (1) -> symbol.binary & sym (1) -> symbol.real
			then if sym (2) -> symbol.decimal
			     then do;
				     load_it = "0"b;
				     bump = 0;
				     inline = "1"b;
				end;
			     else do;
				     load_it = "1"b;
				     bump = 2;
				end;
			else bump = 1;

			if ^ref (1) -> reference.shared
			then ref (1) -> reference.ref_count = ref (1) -> reference.ref_count + bump;
		     end;

		if sym (2) -> symbol.decimal
		then call decimal_op (p, ref, atom);
		else call gen_arithmetic_builtin (p, ref, atom, call_code);

		if load_it
		then call load (ref (1), 0);

		goto done;
	     end;

	if atom (2)
	then call load$for_test (ref (2), 0);
	else call compile_exp_and_set_indicators (rand (2), type (2));

	macro = absfx1 - real_fix_bin_1 + type (2);
	goto l2a;

/* trunc function */

switch_b (8):
	if ^inline
	then goto ext_call;

	if sym (2) -> symbol.float
	then do;
		macro = trunc_mac (fixed (type (1) ^= real_fix_bin_1, 1));
		goto l2;
	     end;

/* the operation has no meaning for non-positive scales */

l7:
	if sym (2) -> symbol.scale <= 0
	then do;
		macro = 0;
		goto l2;
	     end;

	scale = sym (2) -> symbol.scale;
	if atom (2)
	then call load (ref (2), 0);
	else call compile_exp (rand (2));

	k = type (2) - real_fix_bin_1;
	macro = macro + k;

	call xr_man$load_const (scale, 2);

	if k > 0
	then if action ^= 8
	     then call xr_man$load_const (-2 * scale, 3);
	goto l2a;

/* trans_sign and mod functions */

switch_b (9):
	if ^atom (3)
	then ref (3) = compile_exp$save (rand (3));
	if atom (2)
	then call load (ref (2), 0);
	else call compile_exp (rand (2));

	if delta = 1
	then macro = macro + fixed (type (1) ^= real_fix_bin_1, 1);

	call expmac (macro, ref (3));

	if action = 21
	then if scaled
	     then do;
		     array (1) = sym (2) -> symbol.scale;
		     array (2) = sym (3) -> symbol.scale;
		     call expmac$abs (addr (array), 2);
		end;
	goto done;

/* bound_ck and range_ck operators */

switch_b (10):
	call expmac$conditional (macro, pt, ref, atom);
	goto done;

/* concatenation operator */

switch_b (14):
	cg_stat$for_test_called = "0"b;
	call cat_op (pt, ref, code);
	goto done;

/* index operator */

switch_b (15):
	if op_code = index_fun
	then m = 1;
	else if op_code = index_before_fun
	then m = 2;
	else m = 3;

	if type (2) = char_string
	then do;
		rlength = ref (3) -> reference.c_length;
		if rlength = 1 | rlength = 2
		then do;
			if op_code = index_rev_fun
			then macro = index_rev_mac (rlength);
			else macro = index_mac (m, rlength);
			if ^atom (2)
			then ref (2) = compile_exp$save_exp (rand (2));
			if ^atom (3)
			then ref (3) = compile_exp$save_exp (rand (3));
			call expmac$two_eis (macro, ref (2), ref (3));
			go to done;
		     end;
		else if op_code = index_rev_fun
		then m = 4;
	     end;

	else if ref (3) -> reference.c_length = 1	/* Must be bit string */
	then do;
		if ^atom (2)
		then if rand (2) -> node.type = operator_node
		     then if rand (2) -> operator.op_code = reverse_fun
			then goto ind0;
			else ref (2) = compile_exp$save (rand (2));

		call compile_exp (rand (3));

/* protect rand(3) in a, if necessary by getting ref(2)'s address early */

		if ref (2) -> reference.big_offset
		then do;
			call aq_man$lock (null, 1);
			if ^ref (2) -> reference.shared
			then ref (2) -> reference.ref_count = ref (2) -> reference.ref_count + 1;
			call base_man$load_var (2, ref (2), 1);
		     end;

		call long_op$c_or_b (ref (2), 0, (index_chars_1 (m)));
		goto done;
	     end;

/* not single char|bit case */

ind0:
	if ^atom (3)
	then ref (3) = compile_exp$save_exp (rand (3));

	if ^atom (2)
	then call compile_string;

	call load$long_string (ref (2));
	call long_op$c_or_b (ref (3), 0, (index_chars (m)));
	goto done;

/* length function as top operand of tree */

switch_b (16):
	call load_size (ref (2));
	if ^ref (2) -> reference.shared
	then call adjust_ref_count (ref (2), -1);
	goto done;

/* offset function */

switch_b (17):
	if ^atom (2)
	then ref (2) = compile_exp$save (rand (2));

	pa = ref (2) -> reference.symbol;
	if pa -> symbol.constant
	then do;

/* must be null pointer on right */

		call load (generate_constant$real_fix_bin_1 (cg_stat$offset_null_value), 0);
		goto done;
	     end;

	call check_ptr;

	call load (ref (2), 0);
	k = ref (2) -> reference.data_type - unpacked_ptr;

	pa = ref (3) -> reference.symbol;
	if pa -> symbol.internal & (pa -> symbol.auto | pa -> symbol.static)
	then macro = offset_mac_easy;
	else macro = offset_mac_hard;

	call expmac (macro + k, ref (3));
	goto done;

/* assign_zero and stack_ptr operators */

switch_b (18):
	call expmac (macro, ref (1));
	cg_stat$temp_ref = ref (1);
	goto return;

/* desc_size operator */

switch_b (19):
	call expmac (macro, ref (2));
	goto done;

/* floor and ceiling functions */

switch_b (20):
	if ^inline
	then goto ext_call;

	if sym (2) -> symbol.float
	then do;
		macro = macro + 2;
		goto l2;
	     end;

	goto l7;

/* pl1 mod function */

switch_b (21):
	if ^inline
	then goto ext_call;

	scaled = "0"b;

	if sym (1) -> symbol.float
	then do;
		if type (1) = real_flt_bin_1
		then macro = mdfl1;
		else do;
			macro = mdfl2;

			if type (3) = real_flt_bin_1
			then do;

				if atom (3) & is_constant (3)
				then do;
					double = sym (3) -> symbol.initial -> word;
					ref (3) = generate_constant$bit_string (double, (bits_per_two_words));
					ref (3) -> reference.symbol -> symbol.boundary = mod2_;
				     end;
				else do;
					call compile_exp (rand (3));
					call save_ref_3;
				     end;

				atom (3) = "1"b;
			     end;
		     end;

		goto switch_b (9);
	     end;

	k = 2 * type (2) + type (3) - 3;

	if sym (2) -> symbol.scale = 0 & sym (3) -> symbol.scale = 0
	then macro = macro + k;
	else do;
		macro = scaled_mdfx1 + k;
		scaled = "1"b;
	     end;

	go to switch_b (9);

/* round function */

switch_b (22):
	if ^inline
	then goto ext_call;
	if sym (1) -> symbol.complex
	then goto ext_call;

	if atom (2)
	then call load (ref (2), 0);
	else call compile_exp (rand (2));

	if type (3) = real_fix_bin_1
	then k = sym (3) -> symbol.initial -> fixed_bin_single;
	else k = sym (3) -> symbol.initial -> fixed_bin_double;

	if sym (2) -> symbol.float
	then do;
		call expmac ((round_fl), c_a ((k), 1));
		goto done;
	     end;

	macro = macro + type (2) - real_fix_bin_1;

	j = sym (2) -> symbol.scale - k;

	if j > 0
	then do;
		call xr_man$load_const (j, 7);
		goto l2a;
	     end;
	else do;
		call aq_man$fix_scale (ref (2), k, type (1));
		go to done;
	     end;

/* repeat and reverse operator */

switch_b (24):
	if (op_code = repeat_fun) & (ref (2) -> reference.c_length = 1) & is_string_constant (2)
	then do;

/* we can just emit an mlr or csl with fill to compile this operator

   NOTE: For this optimization, prepare_operand was called on rand (1) to
   evaluate the size expression as well as the offset expression.  This
   ensures that the size expression is evaluated before m_a gets called.  It
   gets called during the call to expmac$one_eis.  This fixes 1985. */

		cg_stat$for_test_called = "0"b;

		call adjust_ref_count (rand (3), -1);

		ref (1) = string_temp (p, ref (2), null);

		if type (1) = char_string
		then macro = blank_cs;
		else do;
			if ref (2) -> reference.units = word_
			then c_offset = ref (2) -> reference.c_offset * bits_per_word;
			else c_offset = ref (2) -> reference.c_offset;
						/* must be in bits already */

			if substr (sym (2) -> symbol.initial -> based_bs, c_offset + 1, 1)
			then macro = one_bs;
			else macro = zero_bs;
		     end;

		call expmac$one_eis (macro, ref (1));

		if type (1) = char_string
		then do;
			if ref (2) -> reference.units = word_
			then c_offset = ref (2) -> reference.c_offset * chars_per_word;
			else c_offset = ref (2) -> reference.c_offset;
						/* units must already be chars */

			addrel (cg_stat$text_base, cg_stat$text_pos - 3) -> mlr_instruction.fill =
			     substr (sym (2) -> symbol.initial -> based_cs, c_offset + 1, 1);
		     end;

		go to eis_done;
	     end;

	if op_code = reverse_fun
	then if ref (2) -> reference.c_length = 2
	     then if ref1 -> reference.temp_ref & ^ref1 -> reference.aggregate
		then do;

/* reverse 2 chars- to make better code for reverse index */

			if type (1) = char_string
			then macro = chars_move;
			else macro = move_bits;
			call adjust_ref_count (ref (2), 1);
						/* Gonna use twice */
			if ^atom (2)
			then ref (2) = compile_exp$save_exp (rand (2));
			ref (1) = string_temp (p, ref (2), null);
			if ^(^ref (1) -> reference.aggregate & ref (1) -> reference.temp_ref)
			then call adjust_ref_count (ref (1), 1);
			save_l1 = ref (1) -> reference.c_length;
			save_l2 = ref (2) -> reference.c_length;
			ref (1) -> reference.c_length, ref (2) -> reference.c_length = 1;
			call adjust_c_offset (ref (1), +1);
			call expmac$two_eis (macro, ref (1), ref (2));
			call restore_c_offset (ref (1));
			call adjust_c_offset (ref (2), +1);
			call expmac$two_eis (macro, ref (1), ref (2));
			call restore_c_offset (ref (2));
			ref (1) -> reference.c_length = save_l1;
			ref (2) -> reference.c_length = save_l2;

			goto eis_done;
		     end;

	if atom (2)
	then do;
l10:
		call load$long_string (ref (2));

		if op_code = repeat_fun
		then if atom (3)
		     then call load (ref (3), 0);
		     else call compile_exp (rand (3));
		else macro = macro + type (1) - char_string;

		call expmac$zero (macro);

		if type (1) = bit_string
		then do;
			machine_state.indicators = ind_invalid;
			cg_stat$for_test_called = "0"b;
		     end;

l10a:
		if ref (1) -> reference.length ^= null
		then do;

/* for reverse or repeat the length may be considered
		   evaluated and in the q reg; for translate the length
		   is either already evaluated or is the length_fun op
		   which needs processing */

			if action = 24
			then do;
				pa = prepare_operand ((ref (1) -> reference.length), 0, atomic);

				if atomic
				then if ^pa -> reference.temp_ref
				     then ref (1) -> reference.length = pa;
				     else ;
				else do;
					if pa -> reference.shared
					then pa, ref (1) -> reference.length -> operand (1) = copy_temp (pa);
					pa -> reference.evaluated = "1"b;
				     end;

				call state_man$update_ref (pa);
			     end;
			else ref (1) -> reference.length = eval_exp ((ref (1) -> reference.length), "1"b);
		     end;
		else if ref (1) -> reference.c_length <= max_short_size (type (1))
		then call expmac$zero (fetch_chars_eis - char_string + type (1));

		if ref (1) -> reference.long_ref
		then do;
			update_long = ref (1) -> reference.temp_ref & ^ref (1) -> reference.aggregate;
			if update_long
			then if ref (1) -> reference.length = null
			     then if ref (1) -> reference.ref_count - fixed (cg_stat$save_exp_called, 1) > 1
				then do;
					update_long = "0"b;
					q = copy_temp (ref (1));
					call state_man$update_ref (q);
					call expmac$two_eis (chars_move + type (1) - char_string, ref (1), q);
				     end;
				else ;
			     else ;
			else do;
				q, cg_stat$eis_temp = COPY (ref (1));
				if ref (1) -> reference.length ^= null
				then q -> reference.length = share_expression ((ref (1) -> reference.length));
				q -> reference.ref_count = 1;
				call state_man$update_ref (q);
			     end;
		     end;

		cg_stat$extended_stack = "1"b;

		goto done;
	     end;

	call compile_string;
	goto l10;

/* verify and search functions */

switch_b (25):
	if ^atom (3)
	then ref (3) = compile_exp$save_exp (rand (3));

	if ref (2) -> reference.c_length = 1
	then do;
		if ^atom (2)
		then call compile_string;
		if op_code = verify_fun | op_code = verify_rev_fun
		then macro = inline_verify;
		else macro = inline_search;
		call expmac$two_eis (macro, ref (2), ref (3));
	     end;

	else if is_constant (3)
	then do;
		if op_code = verify_ltrim_fun
		then macro = verify_ltrim_inline;
		else if op_code = verify_rtrim_fun
		then macro = verify_rtrim_inline;
		else if op_code = verify_rev_fun | op_code = search_rev_fun
		then macro = test_translate_rev;
		else macro = test_translate;
		if ^atom (2)
		then ref (2) = compile_exp$save_exp (rand (2));
		if op_code = search_rev_fun
		then op_code = search_fun;		/* Make tests below easier */
		q = sym (3) -> symbol.initial;

		if (ref (3) -> reference.c_length = 1) & (op_code ^= search_fun)
		then q = c_a (rank (substr (q -> based_cs, 1, 1)), 16);
						/* use the table in pl1_operators_ */
		else do;
			string (bit_table) = "0"b;
			do i = 1 to ref (3) -> reference.c_length;
			     j = rank (substr (q -> based_cs, i, 1));
			     bit_table (j) = "777"b3;
			end;

			if op_code ^= search_fun
			then string (bit_table) = ^string (bit_table);

			q = generate_constant$char_string (mvt_table, length (mvt_table));
		     end;

		call expmac$two_eis (macro, ref (2), q);
	     end;

	else do;
		if ^atom (2)
		then call compile_string;
		call long_op$eis_operator (ref (2), ref (3), macro);
	     end;

	go to done;

/* translate function */

switch_b (26):
	if n = 4
	then macro = macro + 1;

	constant_rands = "1"b;

	do i = 3 to n;
	     if ^atom (i)
	     then do;
		     ref (i) = compile_exp$save_exp (rand (i));
		     constant_rands = "0"b;
		end;
	     else constant_rands = constant_rands & is_constant (i);
	end;

	if constant_rands
	then do;

/* The second and third args to the translate bif are constant, so we
	        can generate an inline translate sequence */

		if ^atom (2)
		then ref (2) = compile_exp$save_exp (rand (2));
		if ref (2) -> reference.value_in.string_aq
						/* We must make sure string_temp */
		then call state_man$erase_reg ("001"b); /* doesn't attempt to reuse space used foor ref(2) */

		ref (1) = string_temp (p, ref (2), null);

/* We must generate a translate table for use with an mvt instruction */

		mvt_table = collate9 ();

		q = sym (3) -> symbol.initial;

		if n = 3
		then mvt_table = substr (q -> based_cs, 1, ref (3) -> reference.c_length);
		else do;
			result_string = substr (q -> based_cs, 1, ref (3) -> reference.c_length);
			q = sym (4) -> symbol.initial;
			do i = ref (4) -> reference.c_length to 1 by -1;
			     j = rank (substr (q -> based_cs, i, 1));
			     substr (mvt_table, j + 1, 1) = substr (result_string, i, 1);
			end;
		     end;

		ref (3) = generate_constant$char_string (mvt_table, length (mvt_table));

		call expmac$many_eis ((inline_translate), addr (ref), 3);
eis_done:
		if ^ref (1) -> reference.long_ref
		then if ^cg_stat$for_test_called
		     then do;
			     update_ref = "0"b;
			     in_storage = ref1 = ref (1);
			     if ^(cg_stat$save_exp_called & in_storage) & ref (1) -> reference.temp_ref
				& ^ref (1) -> reference.aggregate
			     then do;
				     if in_storage
				     then if ^ref (1) -> reference.shared
					then ref (1) -> reference.ref_count =
						ref (1) -> reference.ref_count + 1;
				     call load (ref (1), 1);
				end;
			end;
		go to done;
	     end;

	else do;

/* generate operator call */

		if ^atom (2)
		then call compile_string;

		call load$long_string (ref (2));

		if n = 3
		then call long_op (ref (3), 0, macro);
		else call long_op$eis_operator (ref (3), ref (4), macro);

/* Since operator allocates own temp, we must branch for special handling */

		go to l10a;
	     end;

/* lock_fun (stac) function */

switch_b (27):
	if ^atom (2)
	then ref (2) = compile_exp$save (rand (2));

	call compile_exp (rand (3));

	call base_man$load_var (1, ref (2), 1);
	call state_man$set_aliasables (null);
	call expmac$zero (macro);

	a_reg.size = 1;
	goto bnf1;

switch_b (29):					/* complex and conjg functions */
switch_b (30):					/* real and imag functions */
	if inline
	then goto switch_b (10);
	else goto ext_call;

/* sign function */

switch_b (31):
	if sym (2) -> symbol.decimal
	then go to ext_call;

	if atom (2)
	then call load$for_test (ref (2), 0);
	else call compile_exp_and_set_indicators (rand (2), type (2));

	goto l2a;

/* allocation function */

switch_b (32):
	if sym (2) -> symbol.internal
	then n = 13;
	else n = 9;

	ref (2) = c_a ((sym (2) -> symbol.location), n);
	goto switch_b (19);

/* bool function */

switch_b (33):
	if ^atom (2)
	then ref (2) = compile_exp$save_exp (rand (2));

	if ^atom (3)
	then if rand (3) -> node.type = operator_node
	     then if ref (3) -> reference.long_ref & atom (4)
		then call compile_exp (rand (3));
		else ref (3) = compile_exp$save (rand (3));

	cg_stat$for_test_called =
	     cg_stat$for_test_called & is_constant (4) & ref (2) -> reference.length = ref (3) -> reference.length
	     & ref (2) -> reference.c_length <= ref (3) -> reference.c_length;

	ref (1) = string_temp (p, ref (3), ref (2));

	if is_constant (4)
	then do;
		if cg_stat$for_test_called
		then m = test_bits;
		else m = move_bits;
		call expmac$eis (m, ref (2));
		addrel (cg_stat$text_base, cg_stat$text_pos - 3) -> csl_instruction.bool =
		     sym (4) -> symbol.initial -> bit4;
	     end;

	else do;
		call compile_exp (rand (4));
		call state_man$erase_reg ("1"b);
		call expmac ((arl), c_a (32, 1));

		if need_areg ()
		then do;
			call expmac$zero ((a_to_x0));
			macro = macro + 1;
		     end;
		else call aq_man$lock (null, 1);

		call expmac$eis (macro, ref (2));
	     end;

	go to eis_done;

/* math builtins */

switch_b (34):
	if n = 3
	then do;
		check_type = "1"b;
		if op_code = atan_fun
		then macro = atan2_mac;
		else macro = atan2d_mac;
	     end;

	if type (1) = real_flt_bin_2
	then macro = macro + 1;

	call math_op;
	go to done;

/* stacq function.  we will generate the following code:
		lda	ref3
		epp2	ref2
		ldq	ref4
		tsx0	ap|stacq_op	*/

switch_b (35):
	if ^atom (2)
	then ref (2) = compile_exp$save (rand (2));

	if ^atom (4)
	then ref (4) = compile_exp$save (rand (4));

	call compile_exp (rand (3));
	call base_man$load_var (2, ref (2), 1 /* pr2 */);
	if ref (2) -> reference.aliasable
	then call state_man$set_aliasables (ref (2));
	call expmac (macro, ref (4));
	a_reg.size = 1;
	go to bnf1;

/* clock and vclock functions.  we will generate the following code:
		tsx0	ap|clock_op
	or	tsx0	ap|vclock_op	*/

switch_b (36):
	call state_man$erase_reg ((18)"0"b || "1"b);	/* erase pr7 */
	call expmac$zero (macro);
	go to done;

/* byte builtin function. we generate the following code:
		ldq	ref2
		lls	63	*/

switch_b (37):
	if ^atom (2)
	then call compile_exp (rand (2));
	else call load (ref (2), 0);

	call aq_man$check_strings (0);
	a_reg.offset = 63;
	a_reg.length = 9;
	a_reg.size = 72;
	call aq_man$left_shift (63, "1"b);
	go to done;

/* rank builtin function. we generate the following code:
	   hard_to_load case:
		mrl	(...),(pr),fill(000)
		desc9a	ref2,1
		desc9a	sp|46,4
		ldq	sp|46

	   everything else:
		lda	ref2
		lrl	63	*/

switch_b (38):
	if ref (2) -> reference.hard_to_load
	then do;

/* hard_to_load implies operand is a reference, not an expression */

		if ^ref (1) -> reference.temp_ref | ref (1) -> reference.ref_count > 1
		then q = ref (1);
		else q = c_a (46, 4);		/* sp|46 (double temp) */

		if q -> reference.temp_ref
		then q -> reference.value_in.storage = "1"b;

		call expmac$two_eis (rank_eis_mac, q, ref (2));
		in_storage = "1"b;

		if ^save_it & ref (1) -> reference.temp_ref
		then do;
			if ^ref (1) -> reference.shared
			then ref (1) -> reference.ref_count = ref (1) -> reference.ref_count + 1;

			call expmac (ldfx1, q);
		     end;
		else update_ref = "0"b;
	     end;
	else do;
		if atom (2)
		then call load (ref (2), 1);
		else call compile_exp (rand (2));

		call aq_man$right_shift (63, "1"b);
		a_reg.offset, a_reg.size, a_reg.length = 0;
	     end;
	go to done;

compile_exp$for_test:
     entry (pt);

	ftc = cg_stat$for_test_called;
	cg_stat$for_test_called = "1"b;
	goto start;

compile_exp$save:
     entry (pt, ref_pt);

dcl	ref_pt		ptr;			/* will be set to reference node for result */

	p = pt;
	if p -> node.type ^= operator_node
	then do;

		if ^p -> reference.aligned_ref
		then do;

l4:
			i = p -> reference.data_type;
			is_string = i = char_string | i = bit_string;

			if p -> reference.hard_to_load
			then if substr (string (p -> reference.value_in), 1, 2) = "00"b
						/* not in a or q */
			     then if p -> reference.ref_count > 0
				then do;
					if is_string | mod (p -> reference.c_length, bits_per_word) = 0
					then do;
						call load$for_save (p, 0);
						go to l5;
					     end;
				     end;

			call load (p, fixed (is_string, 1));

/* if the reference is now aligned, it was converted to a temporary
		   because its ref_count was greater than one */

			if p -> reference.aligned_ref
			then p -> reference.ref_count = p -> reference.ref_count + 2;
			else p = COPY (p);

			call store$force (p);
		     end;

l5:
		ref_pt = p;
		return;
	     end;

	check_aligned = "1"b;

l6:
	ref (1) = p -> operand (1);
	if ref (1) -> reference.evaluated
	then do;
		if check_aligned
		then if ^ref (1) -> reference.aligned_ref
		     then if ^ref (1) -> reference.long_ref
			then if ^ref (1) -> reference.varying_ref
			     then if ^ref (1) -> reference.symbol -> symbol.decimal
				then do;
					p = ref (1);
					go to l4;
				     end;
		ref_pt = ref (1);
		return;
	     end;

	if ^ref (1) -> reference.allocate
	then do;

		p -> operand (1) = copy_temp (ref (1));
		orig_count = 1;
		p -> operand (1) -> reference.ref_count = 2;
	     end;
	else if ^ref (1) -> reference.shared
	then do;
		orig_count = ref (1) -> reference.ref_count;
		ref (1) -> reference.ref_count = orig_count + 1;
	     end;

	ftc = cg_stat$for_test_called;
	cg_stat$for_test_called = "0"b;

	sec = cg_stat$save_exp_called;
	cg_stat$save_exp_called = "1"b;

	goto work;

compile_exp$save_exp:
     entry (pt, ref_pt);

	p = pt;
	if p -> node.type ^= operator_node
	then goto l5;

	check_aligned = "0"b;
	goto l6;

compile_exp$save_fix_scaled:
     entry (pt, target_scale, targ_type) returns (ptr);

dcl	target_scale	fixed bin,
	target_type	fixed bin,
	targ_type		fixed bin;

	target_type = targ_type;
save_join:
	p = pt;
	if p -> node.type ^= operator_node
	then call load (p, 0);
	else do;
		call compile_exp (p);
		p = p -> operand (1);
	     end;

	if target_type <= real_fix_bin_2
	then call aq_man$fix_scale (p, target_scale, target_type);

	q = COPY (p);
	q -> reference.data_type = target_type;

	call stack_temp$assign_block (q, min (target_type, 2));
						/* NOTE: size = type for real_fix_bin_1 or 2 */

	call expmac (stfx1 - real_fix_bin_1 + target_type, q);

	q -> reference.value_in.storage = "1"b;

	return (q);

compile_exp$save_float_2:
     entry (pt) returns (ptr);

	target_type = real_flt_bin_2;
	goto save_join;

/* INTERNAL PROCEDURES */

COPY:
     proc (pt) returns (ptr);

dcl	(pt, p)		ptr;

	p = copy_temp (pt);
	p -> reference.units = word_;
	p -> reference.aligned_ref, p -> reference.padded_ref, p -> reference.aligned_for_store_ref,
	     p -> reference.padded_for_store_ref = "1"b;
	p -> reference.aggregate = "0"b;
	p -> reference.c_offset = 0;
	p -> reference.ref_count = 2;
	p -> reference.length, p -> reference.offset, p -> reference.qualifier = null;
	return (p);

     end;

check_ptr:
     proc;

	if ref (2) -> reference.temp_ref
	then if ^ref (2) -> reference.value_in.storage
	     then if ^ref (2) -> reference.value_in.q
		then do;
			i = index (string (ref (2) -> reference.value_in.b), "1"b) - 1;
			if i >= 0
			then do;
				ref (2) -> reference.ref_count = ref (2) -> reference.ref_count + 1;
				call base_to_core (i, ref (2));
			     end;
		     end;

     end;

compile_exp_and_set_indicators:
     procedure (bv_ref, bv_type);

/* compiles an ARITHMETIC expression and sets the indicators for testing */

/* parameters */

dcl	(
	bv_ref		ptr,
	bv_type		fixed bin
	)		parameter;

/* program */

	call compile_exp (bv_ref);
	if (machine_state.indicators ^= ind_arithmetic)
	then do;
		call expmac$zero (testfx1 - real_fix_bin_1 + bv_type);
		machine_state.indicators = ind_arithmetic;
	     end;

     end /* compile_exp_and_set_indicators */;

compile_string:
     proc;

	if rand (2) -> node.type = operator_node
	then if ref (2) -> reference.long_ref
	     then call compile_exp (rand (2));
	     else ref (2) = compile_exp$save (rand (2));

     end;

need_areg:
     proc returns (bit (1) aligned);

	if ref (1) -> reference.big_length
	then if ref (3) -> reference.big_length
	     then if ref (1) -> reference.length ^= ref (3) -> reference.length
		     | ref (1) -> reference.c_length ^= ref (3) -> reference.c_length
		then return ("1"b);

	return ("0"b);
     end;

is_constant:
     proc (i) reducible returns (bit (1) aligned);

dcl	i		fixed bin;

	if sym (i) -> symbol.constant
	then if ^ref (i) -> reference.varying_ref
	     then if ref (i) -> reference.offset = null
		then if ref (i) -> reference.c_offset = 0
		     then if ref (i) -> reference.length = null
			then return ("1"b);

	return ("0"b);
     end;

is_string_constant:
     proc (i) reducible returns (bit (1) aligned);

dcl	i		fixed bin;

	if sym (i) -> symbol.constant
	then if ^ref (i) -> reference.varying_ref
	     then if ref (i) -> reference.offset = null
		then if ref (i) -> reference.length = null
		     then return ("1"b);

	return ("0"b);
     end /* is_string_constant */;

save_ref_3:
     proc;

	ref (3) = c_a (2, 12);
	ref (3) -> reference.ref_count = 2;
	call expmac ((stfl2), ref (3));

     end;


math_op:
     proc;

/*	     procedure to issue calls to math operators	*/

dcl	adjust		bit (1) aligned;

	adjust = "0"b;

	if n = 3
	then if type (1) > type (3) & check_type
	     then ref (3) = compile_exp$save_float_2 (rand (3));
	     else if ^atom (3)
	     then ref (3) = compile_exp$save (rand (3));

/* load operand 2 into the q */

	if atom (2)
	then call load (ref (2), 0);
	else call compile_exp (rand (2));

	if n = 3
	then do;
		if ref (3) -> reference.temp_ref
		then do;

/* protect operand(3) from being clobbered when temps are saved */

			adjust = "1"b;
			ref (3) -> reference.ref_count = ref (3) -> reference.ref_count + 1;
		     end;

/* get a ptr to operand(3) into the ab */

		call base_man$load_var (2, ref (3), 3);
	     end;

/*  get a ptr to the workspace into the bp */

	q = c_a (32, 12);
	q -> reference.ref_count = 2;
	call base_man$load_var (2, q, 1);

/* we must flush all the registers because the math operators can make external calls */

	call state_man$flush;

	call expmac$zero (macro);
	machine_state.indicators = ind_arithmetic;

	if adjust
	then call adjust_ref_count (ref (3), -1);
	call adjust_ref_count (q, -1);

     end;

adjust_c_offset:
     proc (p, delta);

dcl	p		ptr,
	delta		fixed bin;

	save_mwif = p -> reference.modword_in_offset;
	save_coff = p -> reference.c_offset;
	save_units = p -> reference.units;
	if save_mwif
	then p -> reference.c_offset = save_coff + delta;
	else if save_units < word_
	then p -> reference.c_offset = save_coff + delta;
	else do;
		p -> reference.modword_in_offset = "1"b;
		if p -> reference.data_type = bit_string
		then do;
			p -> reference.units = bit_;
			p -> reference.c_offset = save_coff * bits_per_word + delta;
		     end;
		else do;
			p -> reference.units = character_;
			p -> reference.c_offset = save_coff * chars_per_word + delta;
		     end;
	     end;
     end;

restore_c_offset:
     proc (p);

dcl	p		ptr;

	p -> reference.c_offset = save_coff;
	p -> reference.modword_in_offset = save_mwif;
	p -> reference.units = save_units;
     end;


     end compile_exp;
