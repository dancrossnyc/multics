/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(86-02-27,Pierret), approve(86-02-27,MCR7340),
     audit(86-04-28,Newcomb), install(86-05-06,MR12.0-1054):
     Changed to not log a message when attempting to open a file which does not
     exist.
  2) change(86-04-22,Pierret), approve(86-04-22,MCR7340),
     audit(86-04-28,Newcomb), install(86-05-06,MR12.0-1054):
     Removed NO, YES, NO_OID_NEEDED as they were not used.  Added ltrim, string
     builtins as they were used but not declared.  Changed all occurences fo
     dir>entry to pathname (dir, entry).  Removed the unnecessary rtrim in
     pathname_(rtrim(dir),entry).
  3) change(86-11-18,Blair), approve(86-11-18,PBF7311), audit(86-11-26,Dupuis),
     install(86-12-09,MR12.0-1237):
     Set the file access blocking_factor to the file_attributes value that was
     used to create the file rather than the hard-coded value of 255.  This
     ensures that our process access table is consistent with the relation
     header value.
                                                   END HISTORY COMMENTS */


/* DESCRIPTION: 

          This module handles the creation and opening of DM files.  Two entry
     points exist: create_open and open.
     
     create_open:  This entry creates a DM file, then opens it.
     
     open:  This entry opens a DM file.     
*/

/* HISTORY: 
Written by Jeffrey D. Ives, 10/xx/82.
           (Designed in January 1982 by Andre Bensoussan.)
Modified:
04/13/83 by JDI: Add protection_enabled, locking_enabled,
            & before_journalization_enabled.
06/01/83 by BIM: Changed lock_manager_ to take fb 27 ci's.
08/05/83 by Lee A. Newcomb: Removed obsolete status codes from
            per_system_ calls.
10/17/83 by JDI: Cleared flush list before calling msf_manager_$close.
12/14/83 by Lee Baldwin:  Moved ACL primitives to fm_attribute_.  Added
            CREATE_MSF & DONT_CREATE_MSF constants.  Changed file creation to
            place a special add-name on component zero.  This identifies the
            MSF as a DM file, and is used by fm_validate_ to validate files.
            Changed the open operation to call fm_validate_ to validate a file,
            removing the explicit CHECK_RING_BRACKETS code.  Also removed 
            explicit setting of 's' to *.*.* on the MSF directory, as 
            msf_manager_ has been changed to do that automatically.
            Changed the history section to the canonical format.
12/22/83 by Matthew Pierret: Added $acl_add back, which is used by bj_mgr_.
02/13/84 by Matthew Pierret:  Changed to reset the ring brackets on component
            0 to <validation level>,5,5 after creating a file.  This required
            closing and then opening the msf so that the file-control-block
            reflects the correct ring brackets (fcb.rbs).
02/14/84 by Matthew Pierret:  Changed to also reset the dir ring brackets
            on the DM file dir (MSF dir) to <DM ring>,<validation level>.
03/16/84 by Matthew Pierret:  Changed to translate error_table_$not_seg_type
            into dm_error_$file_not_dm_type upon return from fm_validate_
            instead of translating all non-zero error codes.
06/07/84 by Lee Baldwin:  Renamed a bunch of dm_error_ codes.
06/21/84 by Matthew Pierret: Changed to set the MSF dir ring brackets to
            <current validation level>,<current validation level> and the 
            component ring brackets to <current validation level>,
            <caller validation level>,<caller validation level>.
            Changed to use FILE_ATTRIBUTES_VERSION_2, moving the 
            file_attributes structure from the main procedure to the include
            file dm_fm_file_attributes.incl.pl1.  This version supports
            extended ring brackets.  Changed the create code to set the
            extended ring brackets to 
            <caller validation level>,<caller validation level>.  The 
            extended ring brackets are not checked anywhere, but are set so 
            that there will be no imcompatible change necessary when they 
            are fully supported.  Also changed to set the bit count on
            component 0 to be an encoded value representing the extended
            ring brackets.
            Also, changed the limit on the full file pathname to 168 chars
            (from 163).  Removed the un-used $acl_add.
            Made protected the default for create.
06/28/84 by Matthew Pierret:  Moved the entry per_process_init to its own
            module, fm_per_process_init. Moved delete_close, close, 
            post_commit and post_txn to fm_delete_close.
            Added extended ring brackets.
            Removed prepare_to_copy, and with it GET_PATH_NAME and 
            GET_LAST_CI_NUM.  They all live now in fm_prepare_to_copy_.
            Changed to use fm_error_util_.
            Changed name of module from fm_open_ to fm_create_open_.
08/27/84 by Matthew Pierret:  Changed the error code returned when
            my_file_access_info.opens > 1 from dm_error_$file_not_dm_type
            to dm_error_$file_already_open.
09/12/84 by Matthew C. Pierret:  Moved the call to
            fm_validate_$get_ring_brackets to the common code so that both
            create_open and open execute it.  create_open needs the ring
            brackets in the case where the file already exists, as the
            contract of create_open is to open the file if it already exists.
10/09/84 by Matthew Pierret:  Added the LEVEL_NOT_SET constant, to which
            (current saved)_validation_level are initialized.  The FINISH
            procedure checks that saved_validation_level is not equal to 
            LEVEL_NOT_SET before reseting the validation level.  This means 
            that the level had not yet been set, so should not be reset.
10/25/84 by Matthew Pierret:  To answer audit comments, in particular:
            Changed to use acl_structures.incl.pl1 and dm_ci_parts.incl.pl1,
            liking local structures to structures in those include files
            instead of imitating their declarations. Removed all use of 
            fm_data_. Made check of input ring brackets more exhaustive.
            Increased limit on number of openings from 255 to the max that
            can be held in fixed bin (17), and changed the case of exceeding
            that limit to be an error. Changed to use LOG_SV in 
            dm_log_sv_modes.icl.pl1.  Changed 
            GIVE_DAEMON_ACESS_TO_CONTAINING_DIR to use parameter and variable
            naming conventions.
10/29/84 by Matthew Pierret:  Added protection of file creation.  Moved
            many descriptive comments from in-line to a description section
            at the beginning of the create_open entry.
12/06/84 by Matthew Pierret:  Changed to explicitly set acl term for creator
            to avoid an msf_manager_ bug.  msf_manager_ should be fixed for
            MR11, so this can be removed once it is fixed.  Also changed
            to log fact that ring brackets have been resynched.
12/07/84 by Matthew Pierret:  Added must_be_zero field to my_attr_ci_parts.
12/17/84 by Matthew Pierret:  Changed to return error_table_$namedup if we are
            creating and there already exists a non-DM file object with the
            same name (instead of error_table_$not_seg_type).  Changed the
            file_access_info structure to have entry_state and file_state
            components.  Changed to pass the file_oid to the bjm_
            write_fm_rollback_handler entry, and so to move code which sets
            my_file_oid to before that bjm_ call.
            Changed to reset the entry_state to NOT_IN_USE if an error occurs.
            Changed to dm_error_$no_current_tranasction instead of 
            dm_error_$fm_no_current_txn.
02/28/85 by Steve Herbst:  Replace nonexistent error code
	  dm_error_$bad_file_cr_ring_brackets with
	  error_table_$invalid_ring_brackets.
03/05/85 by Steve Herbst: Replaced dm_log_ with dm_misc_util_$log.
03/08/85 by S. Cox: Added TRANSACTION_BJ_FULL_HANDLER. 
03/21/85 by S. Cox: TRANSACTION_BJ_FULL_HANDLER: Add revert of txn_bj_full_
04/18/85 by Lindsey L. Spratt:  Fixed to check the iacl terms applied at
            creation (by the msf_manager_), and to "adjust" them to not have
            the "e" bit on (if any do).  This removes the only known source of
            invalid ACL entries for DM files.  Thsi is accomplished by the
            ADJUST_IACL proc.
05/03/85 by Matthew C. Pierret:  Changed to not log a message when attempting
            to open a file which does not exist.
*/

/* format: style2,ind3 */
/* format: ll79,comcol50,indnoniterend,^indnoniterdo,^indprocbody */
%page;
fm_create_open_$create_open:
   procedure (p_dir_path, p_entry_name, p_file_create_info_ptr,
        p_output_file_oid, p_code);


/* START OF DECLARATIONS */

/* Parameters */

   dcl	 p_code		    fixed bin (35) parm;
   dcl	 p_dir_path	    char (*) parm;
   dcl	 p_entry_name	    char (*) parm;
   dcl	 p_output_file_oid	    bit (36) aligned parm;
   dcl	 p_file_create_info_ptr ptr parm;

/* Automatic */

   dcl	 code		    fixed bin (35) init (0);
   dcl	 create_sw	    bit aligned init ("0"b);
   dcl	 current_validation_level
			    fixed bin init (LEVEL_NOT_SET);
   dcl	 dir_path		    char (168) unal init ("");
   dcl	 dir_ring_brackets	    (2) fixed bin (3);
   dcl	 encoded_ring_brackets  fixed bin (24) init (0);
   dcl	 entry_name	    char (32);
   dcl	 extended_ring_brackets (2) fixed bin (3) init (-1, -1);
   dcl	 file_access_table_idx  fixed bin init (0);
   dcl	 file_already_exists    bit aligned init ("0"b);
   dcl	 file_pathname	    char (168);
   dcl	 idx		    fixed bin init (0);
   dcl	 lowest_ring_bracket    fixed bin (3) init (7);
   dcl	 msf_acl_list_idx	    fixed bin init (0);
   dcl	 msf_fcb_ptr	    ptr init (null ());
				         /* cleanup */
   dcl	 number_of_msf_acl_terms
			    fixed bin init (0);
   dcl	 ring_brackets	    (3) fixed bin (3);
   dcl	 saved_validation_level fixed bin init (LEVEL_NOT_SET);
   dcl	 seg_0_ptr	    ptr init (null ());
   dcl	 seg_0_uid	    bit (36) aligned init (""b);
   dcl	 sys_pn_tbl_index	    fixed bin init (-1);
   dcl	 time_stamp	    fixed bin (71);/* dummy variable */

   dcl	 1 my_create_info	    like file_create_info aligned;

   dcl	 1 my_create_rollback_info
			    aligned like create_rollback_info;

   dcl	 1 my_ci_header	    like ci_header aligned;

   dcl	 1 my_file_oid	    aligned like file_oid;

   dcl	 1 my_msf_acl_list	    (2) aligned like general_extended_acl_entry;

   dcl	 1 my_attr_ci_parts	    aligned,
	   2 number_of_parts    fixed bin init (1),
	   2 must_be_zero	    fixed bin init (0),
	   2 part		    (1) like ci_parts.part;

   dcl	 1 my_file_access_info  aligned like file_access_info;

   dcl	 1 my_file_attributes   aligned like file_attributes;
   dcl	 1 my_signal_structure  aligned like condition_info_header;

/* Builtin */

   dcl	 (addr, baseno, char, clock, dim, hbound, lbound, ltrim, max, null,
	 rtrim, size, string, substr, unspec)
			    builtin;

/* Conditions */

   dcl	 cleanup		    condition;
   dcl	 fm_sub_error_	    condition;
   dcl	 transaction_bj_full_   condition;

/* Constants */

   dcl	 MYNAME		    init ("fm_create_open_") char (32)
			    varying internal static options (constant);
   dcl	 (
	 BYTES_PER_WORD	    init (4) fixed bin,
	 CREATE_MSF	    init ("1"b) bit (1),
	 DONT_CREATE_MSF	    init ("0"b) bit (1),
	 FIRST_COMPONENT_NAME   init ("0") char (1),
	 LEVEL_NOT_SET	    init (-1) fixed bin,
	 DEFAULT_CI_SIZE_IN_BYTES
			    init (4096) fixed bin,
	 MAXIMUM_NUMBER_OF_FILE_OPENINGS
			    init (131071) fixed bin (17),
	 NO_CI_HELD	    init (0) fixed bin (27),
	 WITH_NO_ERRORS	    init (0) fixed bin (35)
	 )		    internal static options (constant);

/* Based */

   dcl	 dm_area		    area based (dm_data_$area_ptr);

/* External Variables */


   dcl	 dm_data_$current_txn_id
			    bit (36) aligned ext;
   dcl	 dm_data_$area_ptr	    ptr ext;

   dcl	 dm_system_data_$initializer_name
			    char (32) ext;

   dcl	 dm_error_$bad_file_atrs_length
			    fixed bin (35) ext;
   dcl	 dm_error_$bad_file_atrs_uid
			    fixed bin (35) ext;
   dcl	 dm_error_$bad_file_atrs_ver
			    fixed bin (35) ext;
   dcl	 dm_error_$bad_file_cr_blocking_factor
			    fixed bin (35) ext;
   dcl	 dm_error_$bad_file_cr_ci_size
			    fixed bin (35) ext;
   dcl	 dm_error_$bad_file_cr_info_ver
			    fixed bin (35) ext;
   dcl	 dm_error_$bj_journal_full
			    fixed bin (35) ext;
   dcl	 dm_error_$file_already_exists
			    fixed bin (35) ext;
   dcl	 dm_error_$file_already_open
			    fixed bin (35) ext;
   dcl	 dm_error_$file_not_dm_type
			    fixed bin (35) ext;
   dcl	 dm_error_$file_cr_info_mbz_nz
			    fixed bin (35) ext;
   dcl	 dm_error_$no_current_transaction
			    fixed bin (35) ext;
   dcl	 dm_error_$fm_proc_tbl_full
			    fixed bin (35) ext;
   dcl	 dm_error_$fm_too_many_openings
			    fixed bin (35) ext;
   dcl	 dm_error_$fm_xring_brackets_mismatch
			    fixed bin (35) ext;
   dcl	 dm_error_$programming_error
			    fixed bin (35) ext;
   dcl	 error_table_$bigarg    fixed bin (35) ext;
   dcl	 error_table_$invalid_ring_brackets
			    fixed bin (35) ext;
   dcl	 error_table_$namedup   fixed bin (35) ext;
   dcl	 error_table_$noentry   fixed bin (35) ext;
   dcl	 error_table_$not_dm_ring
			    fixed bin (35) ext;
   dcl	 error_table_$not_seg_type
			    fixed bin (35) ext;
   dcl	 error_table_$no_r_permission
			    fixed bin (35) ext;

   dcl	 sys_info$data_management_ringno
			    fixed bin ext;


/* External Entries */

   dcl	 before_journal_manager_$write_fm_rollback_handler
			    entry (bit (36) aligned, bit (36) aligned,
			    ptr, fixed bin, fixed bin (27),
			    fixed bin (71), fixed bin (35));
   dcl	 cu_$level_get	    entry (fixed bin);
   dcl	 cu_$level_set	    entry (fixed bin);
   dcl	 dm_misc_util_$log	    entry options (variable);
   dcl	 expand_pathname_	    entry (char (*), char (*), char (*),
			    fixed bin (35));
   dcl	 fm_error_util_$signal  entry options (variable);
   dcl	 fm_error_util_$get_code
			    entry () returns (fixed bin (35));
   dcl	 fm_get_$internal_get   entry (bit (36) aligned, uns fixed bin (24),
			    ptr, fixed bin (35));
   dcl	 fm_put_$internal_put   entry (bit (36) aligned, uns fixed bin (24),
			    ptr, fixed bin (35));
   dcl	 fm_sys_pn_tbl_util_$insert
			    entry (bit (36) aligned, char (*), ptr,
			    fixed bin (17));
   dcl	 fm_validate_$get_ring_brackets
			    entry (char (*), char (*), (2) fixed bin (3),
			    fixed bin (35));
   dcl	 get_group_id_$tag_star entry () returns (char (32));
   dcl	 get_ring_	    entry () returns (fixed bin (3));
   dcl	 hcs_$add_dir_acl_entries
			    entry (char (*), char (*), ptr, fixed bin,
			    fixed bin (35));
   dcl	 hcs_$chname_seg	    entry (ptr, char (*), char (*),
			    fixed bin (35));
   dcl	 hcs_$get_uid_seg	    entry (ptr, bit (36) aligned, fixed bin (35))
			    ;
   dcl	 hcs_$list_inacl	    entry (char (*), char (*), ptr, ptr, ptr,
			    fixed bin, fixed bin (3), fixed bin (35));
   dcl	 hcs_$set_bc	    entry (char (*), char (*), fixed bin (24),
			    fixed bin (35));
   dcl	 hcs_$set_bc_seg	    entry (ptr, fixed bin (24), fixed bin (35));
   dcl	 hcs_$set_dir_ring_brackets
			    entry (char (*), char (*), (2) fixed bin (3),
			    fixed bin (35));
   dcl	 hcs_$set_ring_brackets entry (char (*), char (*), (3) fixed bin (3),
			    fixed bin (35));
   dcl	 hcs_$set_safety_sw	    entry (char (*), char (*), bit (1),
			    fixed bin (35));
   dcl	 hcs_$set_synchronized_sw
			    entry (char (*), char (*), bit aligned,
			    fixed bin (35));
   dcl	 ioa_$rsnnl	    entry () options (variable);
   dcl	 lock_manager_$lock	    entry (bit (36) aligned, fixed bin (27),
			    fixed bin, fixed bin (71), fixed bin,
			    fixed bin (35));
   dcl	 msf_manager_$acl_add   entry (ptr, ptr, fixed bin, fixed bin (35));
   dcl	 msf_manager_$acl_delete
			    entry (ptr, ptr, fixed bin, fixed bin (35));
   dcl	 msf_manager_$close	    entry (ptr);
   dcl	 msf_manager_$msf_get_ptr
			    entry (ptr, fixed bin, bit (1), ptr,
			    fixed bin (24), fixed bin (35));
   dcl	 msf_manager_$open	    entry (char (*), char (*), ptr,
			    fixed bin (35));
   dcl	 pathname_	    entry (char (*), char (*))
			    returns (char (168));
   dcl	 signal_		    entry () options (variable);
   dcl	 transaction_manager_$abort_txn
			    entry (bit (36) aligned, fixed bin (35));

/* END OF DECLARATIONS */
%page;
/* DESCRIPTION OF fm_create_open_$create_open:

        This entry creates a Data Management file and opens that file,
   returing the opening id of the file to the caller.  The file is
   identified by pathname, p_dir_path and p_entry_name.  Attributes of
   the file are specified in the file_create_info structure, pointed to
   by the p_file_create_info_ptr parameter.  This parameter may be null,
   in which case a series of default values are used.
      
        Data Management files are MSFs with special values for two storage
   system attributes: an add-name on component 0 and the bit count on
   component 0.  The add-name on component has the canonical value held in the
   constant DM_FILE_VALIDATION_NAME.  This is used to validate that an
   apparent MSF is in reality a DM file without having to access the file or
   invoke any code which would cause Data Management to be initialized in the
   process.  The bit count on component has a value which is the encoded
   representation of the extended ring brackets of the file.  The bit count is
   used for the same reasons as the add-name.  The extended ring brackets are
   also stored in the file attributes for verification, and always takes
   precedence over the encoded ring brackets, should they differ. The
   encoding function is contained in the internal subroutine 
   ENCODE_RING_BRACKETS.  The encoded ring brackets in the bit count are
   preserved as long as msf_manager_$adjust is not called to adjust the
   file MSF, and the Data Management system does not do so. The extended
   ring brackets must satisfy the constraints:
    max(DM-ring, caller-validation-level) <= write bracket <= read bracket
   
        The actual ring brackets recognized by the file system are set so
   that only code in the DM ring can manipulate the contents of a file.
   The file's MSF directory ring brackets are both set to the DM ring, which
   is also the current ring of execution.  In this module, the DM ring, the
   ring fo excution and the current validation level (CVL) are all the same.
   So the file's MSF directory has ring brackets CVL, CVL.  The ring brackets
   on component 0 of the file's MSF are CVL, RB, RB, where RB is the specified
   or default extended read bracket.  This is to allow processes to directly
   read the contents of a file rather than obtaining local copies of file data.
   The ring brackets on component 0 are propogated to all components.

        Data Management files are uniquely indentified by the file system
   unique id of component 0 of the file's MSF.
   
        If the file is to be protected (the default case), some special 
   conditions exist.  First, a transaction must be in progress. If not, 
   dm_error_$no_current_transaction is returned.  Second, rw access to the
   file is granted to Data_Management.Daemon.  This allows the daemon to
   rollback modifications to the file if a transaction does not complete
   successfully.  Third, the creation of the file is also protected.

*/
/*
create_open:
   entry (p_dir_path, p_entry_name, p_file_create_info_ptr, p_output_file_oid, p_code);
*/

   call INIT;
   create_sw = "1"b;

   go to CREATE_OPEN_JOIN;
%page;
/* DESCRIPTION OF fm_create_open_$open:

          This entry opens a DM file, returning an opening id for the file.
     The file is identified by pathname, p_dir_path and p_entry_name.  The
     opening id is in p_output_file_oid.  Opening a file consists of inserting
     its pathname in the sys_pn_tbl so that, if necessary, a different process
     can find it during a rollback, and setting up a file_access_info
     structure as an entry in the file_access_table.  This is per-process
     information, the information for it retrieved from the file_attributes
     stored in control interval 0 of the file.  
*/

open:
   entry (p_dir_path, p_entry_name, p_output_file_oid, p_code);

   call INIT;
   create_sw = "0"b;

   go to CREATE_OPEN_JOIN;
%page;
CREATE_OPEN_JOIN:
   unspec (my_file_oid) = ""b;	         /* set for FINISH */

   on fm_sub_error_ call RETURN (fm_error_util_$get_code ());

   p_output_file_oid = ""b;
   dir_path = p_dir_path;
   entry_name = rtrim (p_entry_name);
   if entry_name ^= p_entry_name
   then call ERROR_RETURN (error_table_$bigarg,
	   "  The entry name argument is longer than 32 characters.  ^a^s",
	   p_entry_name, "");	         /* Subroutines will check the length of file_pathname */
   file_pathname = pathname_ (dir_path, entry_name);

   unspec (my_file_access_info) = ""b;
   my_file_access_info.msf_ptr = null ();

/* Validate the file and get its extended ring brackets.  If we are      */
/* are creating the file we expect to get the code error_table_$noentry. */
/* However, if the file already exists, (code = 0), do not abort as we   */
/* still have to open the file.  The extended ring brackets are those    */
/* that are encoded in the bit count of the first component of the file. */
/* We get them so that we can verify their correctness later when we get */
/* the file attributes. The call is made now because fm_validate_ expects*/
/* the validation level to be the caller's validation level.  The        */
/* validation level will be changed to the data management ring shortly. */

   call fm_validate_$get_ring_brackets (dir_path, entry_name,
        extended_ring_brackets, code);
   if create_sw
   then if code ^= 0
        then
	 do;
	 if code = error_table_$noentry
	 then code = 0;
	 else if code = error_table_$not_seg_type
	 then call ERROR_RETURN (error_table_$namedup, " ^a^s",
		 file_pathname, "");
	 else call ERROR_RETURN (code, "  ^a^s.", file_pathname, "");
	 end;
        else /* code already equal to 0 */
	   ;
   else if code ^= 0
   then if code = error_table_$noentry
        then call RETURN (code);
        else call ERROR_RETURN (code, "  ^a^s.", file_pathname, "");
   else /* code = 0 */
        ;

/* Save the caller's validation level.  It will be needed later to restore */
/* the validation level to the caller's.  Set the validation level to the  */
/* current ring of execution, i.e., the data management ring, so that      */
/* the process is in an appropriately priviledged state.                   */

   call cu_$level_get (saved_validation_level);
   on cleanup call FINISH ();
   current_validation_level = get_ring_ ();
   call cu_$level_set (current_validation_level);

   call msf_manager_$open (dir_path, entry_name, msf_fcb_ptr, code);
   if msf_fcb_ptr = null ()
   then call ERROR_RETURN (code, "  Returned by msf_manager_$open (^a).",
	   pathname_ (dir_path, entry_name), "");

%page;

   if create_sw & code = error_table_$noentry
   then
CREATE:
      do;
      file_already_exists = "0"b;

/* Set up and verify the local my_file_create_info. A local copy is  */
/* used for efficiency.  If the caller supplied a file_create_info   */
/* it is copied; otherwise a default my_create_info is used.  The    */
/* non-zero default value is the protected flag, which defaults to   */
/* on. */

      if p_file_create_info_ptr ^= null ()
      then my_create_info = p_file_create_info_ptr -> file_create_info;
      else
         do;
         unspec (my_create_info) = ""b;
         my_create_info.version = FILE_CREATE_INFO_VERSION_2;
         my_create_info.protected = "1"b;
         end;

      if my_create_info.version ^= FILE_CREATE_INFO_VERSION_2
      then call ERROR_RETURN (dm_error_$bad_file_cr_info_ver,
	      "  Supplied version was ^a.  It should have been ^a.",
	      (my_create_info.version), (FILE_CREATE_INFO_VERSION_2));

      if my_create_info.mbz_1 ^= ""b | unspec (my_create_info.mbz_2) ^= ""b
	 | unspec (my_create_info.mbz_3) ^= ""b
      then call ERROR_RETURN (dm_error_$file_cr_info_mbz_nz, "", "", "");

      if my_create_info.ci_size_in_bytes = 0
      then my_create_info.ci_size_in_bytes = DEFAULT_CI_SIZE_IN_BYTES;

      if my_create_info.ci_size_in_bytes ^= DEFAULT_CI_SIZE_IN_BYTES
      then call ERROR_RETURN (dm_error_$bad_file_cr_ci_size,
	      "  File_create_info.ci_size_in_bytes was ^a.  It should have been ^a.",
	      char (my_create_info.ci_size_in_bytes),
	      char (DEFAULT_CI_SIZE_IN_BYTES));

      if my_create_info.blocking_factor = 0
      then my_create_info.blocking_factor = 255;

      if my_create_info.blocking_factor ^= 64
	 & my_create_info.blocking_factor ^= 255
      then call ERROR_RETURN (dm_error_$bad_file_cr_blocking_factor,
	      "  Supplied blocking_factor was ^a.  It should have been 64 or 255.",
	      char (my_create_info.blocking_factor), "");

      if my_create_info.ring_brackets (FCI_WRITE_BRACKET_IDX) = 0
      then my_create_info.ring_brackets (FCI_WRITE_BRACKET_IDX) =
	      max (current_validation_level, saved_validation_level);
      if my_create_info.ring_brackets (FCI_READ_BRACKET_IDX) = 0
      then my_create_info.ring_brackets (FCI_READ_BRACKET_IDX) =
	      max (current_validation_level, saved_validation_level);
      lowest_ring_bracket =
	 max (current_validation_level, saved_validation_level);
      if my_create_info.ring_brackets (FCI_WRITE_BRACKET_IDX)
	 < lowest_ring_bracket
	 | my_create_info.ring_brackets (FCI_WRITE_BRACKET_IDX) > 7
	 | my_create_info.ring_brackets (FCI_READ_BRACKET_IDX)
	 < lowest_ring_bracket
	 | my_create_info.ring_brackets (FCI_READ_BRACKET_IDX) > 7
	 | my_create_info.ring_brackets (FCI_READ_BRACKET_IDX)
	 < my_create_info.ring_brackets (FCI_WRITE_BRACKET_IDX)
      then call ERROR_RETURN (error_table_$invalid_ring_brackets,
	      "  The supplied ring_brackets were ^a,^a.",
	      char (my_create_info.ring_brackets (FCI_WRITE_BRACKET_IDX)),
	      char (my_create_info.ring_brackets (FCI_READ_BRACKET_IDX)));

/* Now set the values in file_attributes from those in my_create_info.  */

      file_attributes_ptr = addr (my_file_attributes);
      unspec (file_attributes) = ""b;
      file_attributes.version = FILE_ATTRIBUTES_VERSION_2;
      file_attributes.ci_size_in_bytes = my_create_info.ci_size_in_bytes;
      file_attributes.blocking_factor = my_create_info.blocking_factor;
      file_attributes.flags.protected = my_create_info.protected;
      if my_create_info.protected
      then
         do;
         file_attributes.no_concurrency = my_create_info.no_concurrency;
         file_attributes.no_rollback = my_create_info.no_rollback;
         end;
      file_attributes.ring_brackets.write =
	 my_create_info.ring_brackets (FCI_WRITE_BRACKET_IDX);
      file_attributes.ring_brackets.read =
	 my_create_info.ring_brackets (FCI_READ_BRACKET_IDX);


/* If the file is to be protected, verify that a transaction is in progress. */
/* Also, give Data_Management.Daemon access to the containing directory if   */
/* the containing directory is not the process directory.                    */

      if file_attributes.flags.protected
      then
         do;
         if dm_data_$current_txn_id = ""b
         then call RETURN (dm_error_$no_current_transaction);

         if substr (dir_path, 1, 4) ^= ">pdd"
	    & substr (dir_path, 1, 16) ^= ">process_dir_dir"
         then call GIVE_DAEMON_ACCESS_TO_CONTAINING_DIR (dir_path);
         end;

/* Now create the MSF by getting a pointer to the first component. */

      call msf_manager_$msf_get_ptr (msf_fcb_ptr, 0, CREATE_MSF, seg_0_ptr,
	 (0), code);
      if seg_0_ptr = null ()
      then call ERROR_RETURN (code,
	      "  Returned by msf_manager_$msf_get_ptr for component 0 of ^a.",
	      pathname_ (dir_path, entry_name), "");

/* Get the uid of the file, the same as the uid of the first component. */

      call hcs_$get_uid_seg (seg_0_ptr, seg_0_uid, code);
      if code ^= 0
      then call ERROR_RETURN (code,
	      "  Unable to get the Multics file system uid of ^a.",
	      pathname_ (pathname_ (dir_path, entry_name), "0"), "");

      file_attributes.unique_id = seg_0_uid;
      my_file_access_info.uid = seg_0_uid;

/* Reserve an entry in the file_access_table. */

      my_file_access_info.state.entry_state = FILE_ACCESS_INFO_IN_USE;
      my_file_access_info.state.file_state = FILE_EXISTS;

      call ADD_FILE_ACCESS_TABLE_ENTRY ();       /* This sets my_file_oid */

/* Setup for possible rollback of the file creation. */
/* The rollback handler requires the unique id of the file, its pathame and */
/* index in the sys_pn_tbl and its opening id. */

      if file_attributes.flags.protected & ^file_attributes.flags.no_rollback
      then
         do;
         on transaction_bj_full_ goto TRANSACTION_BJ_FULL_HANDLER;
         call fm_sys_pn_tbl_util_$insert (seg_0_uid, file_pathname, seg_0_ptr,
	    sys_pn_tbl_index);
         my_create_rollback_info.header.version = ROLLBACK_INFO_VERSION_1;
         my_create_rollback_info.header.operation = CREATE_ROLLBACK_OPERATION;
         my_create_rollback_info.sys_pn_tbl_index = sys_pn_tbl_index;
         my_create_rollback_info.dir_path = dir_path;
         my_create_rollback_info.file_name = entry_name;
         call before_journal_manager_$write_fm_rollback_handler (seg_0_uid,
	    unspec (my_file_oid), addr (my_create_rollback_info),
	    size (my_create_rollback_info) * BYTES_PER_WORD, NO_CI_HELD,
	    time_stamp, code);
         if code ^= 0
         then call ERROR_RETURN (code,
	         " Unable to write rollback handler while creating ^a.",
	         pathname_ (dir_path, entry_name), "");
         end;

/* Convert MSF into a Data Management file */

/* Add a canonical name to the first component of the MSF to indicate */
/* that this is a Data Management file.                               */

      call hcs_$chname_seg (seg_0_ptr, "" /* don't remove a name */,
	 DM_FILE_VALIDATION_NAME, code);
      if code ^= 0
      then call ERROR_RETURN (code, " Unable to add ^a to ^a.",
	      DM_FILE_VALIDATION_NAME, pathname_ (file_pathname, "0"));

/* Set the extended ring brackets on the file.  This is done by encoding the */
/* specified ring brackets into one value, and setting the bit count of the  */
/* first component to that value. */

      encoded_ring_brackets =
	 ENCODE_RING_BRACKETS ((file_attributes.ring_brackets.write),
	 (file_attributes.ring_brackets.read));

      call hcs_$set_bc_seg (seg_0_ptr, encoded_ring_brackets, code);
      if code ^= 0
      then call ERROR_RETURN (code, "  Could not set the bit count on ^a.",
	      pathname_ (file_pathname, "0"), "");

/* Set the actual ring brackets on the MSF directory and first MSF component.*/

      dir_ring_brackets (1) = current_validation_level;
      dir_ring_brackets (2) = current_validation_level;

      call hcs_$set_dir_ring_brackets (dir_path, entry_name, dir_ring_brackets,
	 code);
      if code ^= 0
      then call ERROR_RETURN (code, " Attempting to set ring brackets on ^a.",
	      pathname_ (dir_path, entry_name), "");

      ring_brackets (1) = current_validation_level;
      ring_brackets (2) = file_attributes.ring_brackets.read;
      ring_brackets (3) = file_attributes.ring_brackets.read;

      call hcs_$set_ring_brackets (file_pathname, FIRST_COMPONENT_NAME,
	 ring_brackets, code);
      if code ^= 0
      then call ERROR_RETURN (code, " Attempting to set ring brackets on ^a.",
	      pathname_ (file_pathname, FIRST_COMPONENT_NAME), "");

/* Ensure that future components' ring brackets will be set correctly by     */
/* closing and re-opening the MSF.  This resets fcb.rbs to the new values.   */

      call msf_manager_$close (msf_fcb_ptr);     /* Reset fcb.rbs */
      call msf_manager_$open (dir_path, entry_name, msf_fcb_ptr, code);
      if code ^= 0
      then call ERROR_RETURN (code,
	      " Unable to re-open ^a after setting ring_brackets.",
	      pathname_ (dir_path, entry_name), "");
      seg_0_ptr = null;		         /* Reset the seg_0_ptr - it was terminated by msf_manager_$close */
      call msf_manager_$msf_get_ptr (msf_fcb_ptr, 0, DONT_CREATE_MSF,
	 seg_0_ptr, (0), code);
      if seg_0_ptr = null ()
      then call ERROR_RETURN (code,
	      "  Unable to get pointer for component 0 of ^a.",
	      pathname_ (dir_path, entry_name), "");

/* Set the safety switch on the file (MSF directory). */

      call hcs_$set_safety_sw (dir_path, entry_name, "1"b, code);
      if code ^= 0
      then call ERROR_RETURN (code,
	      "  Unable to turn on the safety switch of ^a.",
	      pathname_ (dir_path, entry_name), "");

      call ADJUST_IACL (dir_path, entry_name, (current_validation_level),
	 (file_attributes.ring_brackets.write), msf_fcb_ptr);

/* Because of a bug in the msf_manager_, we must explicitly add an ACL     */
/* term for the creator in order to carry the term to new components. Also,*/
/* if the protected attribute is in force, add the Data Management daemon  */
/* to the access control list such that it is able to access the file for  */
/* rollback.                                                               */

      unspec (my_msf_acl_list) = ""b;
      number_of_msf_acl_terms = 1;
      my_msf_acl_list (1).access_name = get_group_id_$tag_star ();
      my_msf_acl_list (1).mode = RW_ACCESS;
      if file_attributes.flags.protected
      then
         do;
         number_of_msf_acl_terms = 2;
         my_msf_acl_list (2).access_name = dm_system_data_$initializer_name;
         my_msf_acl_list (2).mode = RW_ACCESS;
         end;
      call msf_manager_$acl_add (msf_fcb_ptr, addr (my_msf_acl_list),
	 number_of_msf_acl_terms, code);
      if code ^= 0
      then
         do msf_acl_list_idx = 1 to number_of_msf_acl_terms;
	  if my_msf_acl_list (msf_acl_list_idx).status_code ^= 0
	  then code = my_msf_acl_list (msf_acl_list_idx).status_code;
	  call ERROR_RETURN (code,
	       "  Unable to add 'rw' acl term to ^a for ^a.", file_pathname,
	       (my_msf_acl_list (msf_acl_list_idx).access_name));
         end;


/* Fill in the file_access_info entry for this file for this process and add */
/* it to the file_access_table. The file_access_info is roughly similar      */
/* to opening information or an MSF fcb.                                     */

      my_file_access_info.seg_0_num = baseno (seg_0_ptr);
      my_file_access_info.blocking_factor = file_attributes.blocking_factor;
      my_file_access_info.msf_ptr = msf_fcb_ptr;
      msf_fcb_ptr = null ();
      my_file_access_info.ring_brackets.write =
	 file_attributes.ring_brackets.write;
      my_file_access_info.ring_brackets.read =
	 file_attributes.ring_brackets.read;

      do file_access_table_idx = lbound (file_access_table.e, 1)
	 to file_access_table.h.last_entry;
         if file_access_table.e (file_access_table_idx).seg_0_num
	    = my_file_access_info.seg_0_num
	    & file_access_table.e (file_access_table_idx).state.entry_state
	    ^= 0
         then
	  do;			         /* unexpected dl */
	  unspec (file_access_table.e (file_access_table_idx).seg_0_num) =
	       ""b;
	  file_access_table.e (file_access_table_idx).msf_ptr = null ();
	  do idx = lbound (my_file_access_info.seg_nums, 1)
	       to hbound (my_file_access_info.seg_nums, 1);
	     unspec (file_access_table.e (file_access_table_idx)
		.seg_nums (idx)) = ""b;
	  end;
	  end;
      end;

      my_file_access_info.integrity_switches.record_time_modified = "1"b;
      my_file_access_info.integrity_switches.transaction =
	 file_attributes.flags.protected;
      my_file_access_info.integrity_switches.lock =
	 my_file_access_info.integrity_switches.transaction
	 & ^file_attributes.flags.no_concurrency;
      my_file_access_info.integrity_switches.bj =
	 my_file_access_info.integrity_switches.transaction
	 & ^file_attributes.flags.no_rollback;

      if my_file_access_info.integrity_switches.lock
      then
         do;
         call lock_manager_$lock (my_file_access_info.uid, LOCK_ENTIRE_FILE,
	    LOCK_MODE_X, 1e9, (0), code);
         if code ^= 0
         then call ERROR_RETURN (code,
	         "  Unable to lock file ^a, with file uid ^a, exclusively.",
	         file_pathname, char (my_file_access_info.uid));
         end;

      if my_file_access_info.integrity_switches.bj
      then
         do;
         call hcs_$set_synchronized_sw (file_pathname, "0", "1"b, code);
         if code ^= 0
         then
	  do;
	  if code = error_table_$not_dm_ring
	       & sys_info$data_management_ringno ^= get_ring_ ()
	  then code = 0;
	  else call ERROR_RETURN (code,
		  "  Unable to turn on the synchronized switch of ^a.",
		  pathname_ (pathname_ (dir_path, entry_name), "0"), "");
	  end;
         end;

      file_attributes.date_time_created = clock ();
      file_attributes.length_of_attributes = 4 * size (file_attributes) - 2;

      call INIT_ATTR_CI_PARTS (addr (my_attr_ci_parts), file_attributes_ptr);

      if my_attr_ci_parts.part (1).length_in_bytes
	 ^= file_attributes.length_of_attributes + 2
      then call ERROR_RETURN (dm_error_$programming_error,
	      "  The length of the file attributes, ^a, and the length of the ci_part, ^a, used to store the attributes differ.",
	      char (file_attributes.length_of_attributes + 2),
	      char (my_attr_ci_parts.part (1).length_in_bytes));

      my_file_access_info.pn_tbl_idx = sys_pn_tbl_index;
      my_file_access_info.opens = 1;

      file_access_table.e (my_file_oid.file_access_table_idx) =
	 my_file_access_info;

      call fm_put_$internal_put (unspec (my_file_oid), 0,
	 addr (my_attr_ci_parts), code);
      if code ^= 0
      then call RETURN (code);

      p_output_file_oid = unspec (my_file_oid);
      unspec (my_file_oid) = ""b;	         /* must be set for FINISH */

      call RETURN (WITH_NO_ERRORS);

      end CREATE;
%page;
/* if create_sw & code = error_table_$noentry */
/* then CREATE: ...                           */

   else if code ^= 0
   then call ERROR_RETURN (code, "  ^a^s.", file_pathname, "");
   else
OPEN:
      do;
      if create_sw
      then file_already_exists = "1"b;
      else file_already_exists = "0"b;

      call msf_manager_$msf_get_ptr (msf_fcb_ptr, 0, DONT_CREATE_MSF,
	 seg_0_ptr, (0), code);
      if seg_0_ptr = null ()
      then call ERROR_RETURN (code, "  Unable to get pointer to ^a.^s",
	      pathname_ (file_pathname, "0"), "");

/* Make sure that CI zero looks reasonable. */

      my_ci_header = seg_0_ptr -> ci_header;

      if my_ci_header.stamp.version ^= CI_HEADER_STAMP_VERSION_1
	 | unspec (my_ci_header.id.size_code) ^= CI_SIZE_CODE_1024_WORDS
	 | my_ci_header.id.num ^= 0 | my_ci_header.id.uid = ""b
      then call RETURN (dm_error_$file_not_dm_type);

      my_file_access_info.blocking_factor = 255;
      my_file_access_info.uid = my_ci_header.id.uid;
      my_file_access_info.seg_0_num = baseno (seg_0_ptr);

/* SEE IF IT IS ALREADY IN THE PROCESS TABLE */

      do file_access_table_idx = lbound (file_access_table.e, 1)
	 to file_access_table.h.last_entry
	 while (file_access_table.e (file_access_table_idx).seg_0_num
	 ^= my_file_access_info.seg_0_num
	 | file_access_table.e (file_access_table_idx).state.entry_state = 0)
	 ;
      end;

      if file_access_table_idx <= file_access_table.h.last_entry
      then
         do;
         if file_access_table.e (file_access_table_idx).uid
	    ^= my_file_access_info.uid
         then
	  do;			         /* unexpected dl */
	  unspec (file_access_table.e (file_access_table_idx).seg_0_num) =
	       ""b;
	  file_access_table.e (file_access_table_idx).msf_ptr = null ();
	  do idx = lbound (my_file_access_info.seg_nums, 1)
	       to hbound (my_file_access_info.seg_nums, 1);
	     unspec (file_access_table.e (file_access_table_idx)
		.seg_nums (idx)) = ""b;
	  end;
	  end;
         else
	  do;
	  call msf_manager_$close (msf_fcb_ptr);
	  msf_fcb_ptr = null ();

	  my_file_access_info = file_access_table.e (file_access_table_idx);

	  if my_file_access_info.opens >= MAXIMUM_NUMBER_OF_FILE_OPENINGS
	  then call ERROR_RETURN (dm_error_$fm_too_many_openings,
		  "For ^a^s.", file_pathname, "");
	  else my_file_access_info.opens = my_file_access_info.opens + 1;

	  file_access_table.e (file_access_table_idx) = my_file_access_info;

	  my_file_oid.file_access_table_idx = file_access_table_idx;
	  my_file_oid.uid_tail = substr (my_file_access_info.uid, 19, 18);

	  p_output_file_oid = unspec (my_file_oid);
	  unspec (my_file_oid) = ""b;	         /* must be set for FINISH */

	  if my_file_access_info.opens > 1
	  then call RETURN (dm_error_$file_already_open);

	  call RETURN (WITH_NO_ERRORS);
	  end;
         end;

      my_file_access_info.msf_ptr = msf_fcb_ptr;
      msf_fcb_ptr = null ();		         /* don't cleanup */

/* We will soon get the file_attributes by calling fm_get_$internal_get,   */
/* which relies on the information in file_access_info.  All of the info   */
/* upon which it relies has already been set with the exception of the     */
/* read ring bracket, the value of which is not yet known.  So that we can */
/* get the file_attributes, set the read ring bracket to the current ring  */
/* of execution.  Afterward, we will be able to set the ring bracket in    */
/* file_access_info to its true value.                                     */

      my_file_access_info.ring_brackets.read = get_ring_ ();

/* Insert the file access info in the file_access_table, where it can be   */
/* found by fm_get_$internal_get.  The entry in which the file access info */
/* is placed is recorded in file_oid.file_access_table_idx.                */

      my_file_access_info.state.entry_state = FILE_ACCESS_INFO_IN_USE;
      my_file_access_info.state.file_state = FILE_EXISTS;
      call ADD_FILE_ACCESS_TABLE_ENTRY ();

/* Now, actually get the file_attributes from control interval 0. */

      unspec (my_file_attributes) = ""b;
      file_attributes_ptr = addr (my_file_attributes);

      call INIT_ATTR_CI_PARTS (addr (my_attr_ci_parts), file_attributes_ptr);

      call fm_get_$internal_get (unspec (my_file_oid), 0,
	 addr (my_attr_ci_parts), code);
      if code ^= 0
      then call RETURN (code);

/* Verify the consistency of the values in the file_attributes structure. */

      if file_attributes.length_of_attributes
	 ^= CI_ADDRESSABLE_LENGTH - CI_0_ADDRESSABLE_LENGTH - 2
      then call ERROR_RETURN (dm_error_$bad_file_atrs_length,
	      "  The file_attributes length " || rtrim (file_pathname)
	      || " is ^a.  It should be ^a.",
	      char (file_attributes.length_of_attributes),
	      char (CI_ADDRESSABLE_LENGTH - CI_0_ADDRESSABLE_LENGTH - 2));

      if file_attributes.version ^= FILE_ATTRIBUTES_VERSION_2
      then call ERROR_RETURN (dm_error_$bad_file_atrs_ver,
	      "  The version of the file attributes is ^a.  It should be ^a.",
	      (file_attributes.version), (FILE_ATTRIBUTES_VERSION_2));

      if file_attributes.unique_id ^= my_file_access_info.uid
      then call ERROR_RETURN (dm_error_$bad_file_atrs_uid,
	      "  The unique identifier in the file attributes of "
	      || rtrim (file_pathname) || " is ^a.  The UID in CI 0 is ^a.",
	      char (file_attributes.unique_id),
	      char (my_file_access_info.uid));

      if file_attributes.ring_brackets.write
	 ^= extended_ring_brackets (FCI_WRITE_BRACKET_IDX)
	 | file_attributes.ring_brackets.read
	 ^= extended_ring_brackets (FCI_READ_BRACKET_IDX)
      then
         do;			         /* Stored and encoded ring brackets are out of synch.  Try to */
				         /* resynch them. If unsuccessful, it is safe to continue.     */
         call dm_misc_util_$log (LOG_SV, dm_error_$fm_xring_brackets_mismatch,
	    MYNAME,
	    "  The stored ring brackets for ^a are ^d,^d, the encoded are ^d,^d.",
	    file_pathname, file_attributes.ring_brackets.write,
	    file_attributes.ring_brackets.read,
	    extended_ring_brackets (FCI_WRITE_BRACKET_IDX),
	    extended_ring_brackets (FCI_READ_BRACKET_IDX));

         encoded_ring_brackets =
	    ENCODE_RING_BRACKETS ((file_attributes.ring_brackets.write),
	    (file_attributes.ring_brackets.read));
         call hcs_$set_bc (dir_path, entry_name, encoded_ring_brackets, code);
         if code ^= 0
         then call dm_misc_util_$log (LOG_SV, code, MYNAME,
	         "  Could not resynch extended ring brackets for ^a.",
	         file_pathname);
         else call dm_misc_util_$log (INFORM_SV, 0, MYNAME,
	         " Resynched ring brackets for ^a.", file_pathname);
         end;

      my_file_access_info.ring_brackets.write =
	 file_attributes.ring_brackets.write;
      my_file_access_info.ring_brackets.read =
	 file_attributes.ring_brackets.read;

      if my_file_access_info.ring_brackets.read < saved_validation_level
      then call RETURN (error_table_$no_r_permission);

      if file_attributes.flags.protected & ^file_attributes.flags.no_rollback
      then call fm_sys_pn_tbl_util_$insert (file_attributes.unique_id,
	      file_pathname, seg_0_ptr, sys_pn_tbl_index);

      my_file_access_info.blocking_factor = file_attributes.blocking_factor;
      my_file_access_info.integrity_switches.record_time_modified = "1"b;
      my_file_access_info.integrity_switches.transaction =
	 file_attributes.flags.protected;
      my_file_access_info.integrity_switches.lock =
	 my_file_access_info.integrity_switches.transaction
	 & ^file_attributes.flags.no_concurrency;
      my_file_access_info.integrity_switches.bj =
	 my_file_access_info.integrity_switches.transaction
	 & ^file_attributes.flags.no_rollback;
      my_file_access_info.pn_tbl_idx = sys_pn_tbl_index;
      my_file_access_info.opens = 1;

      file_access_table.e (file_access_table_idx) = my_file_access_info;

      p_output_file_oid = unspec (my_file_oid);
      unspec (my_file_oid) = ""b;	         /* must be set for FINISH */

      if file_already_exists
      then call RETURN (dm_error_$file_already_exists);
      else call RETURN (WITH_NO_ERRORS);

      end OPEN;

/* All returns from the main procedure go through this statement. */

MAIN_RETURN:
   return;
%skip;
TRANSACTION_BJ_FULL_HANDLER:
/**** Cannot call bj_report_err_ to do this since BJ cannot be called recursively. */
/**** See also fm_(delete_close put), which need to handle this condition. */
   revert transaction_bj_full_;
   my_signal_structure.length = size (my_signal_structure);
   my_signal_structure.version = 1;
   string (my_signal_structure.action_flags) = "0"b;
   call ioa_$rsnnl ("Creating DM file UID ^w ^a",
        my_signal_structure.info_string, (0), seg_0_uid,
        pathname_ (dir_path, entry_name));
   my_signal_structure.status_code = dm_error_$bj_journal_full;

   call transaction_manager_$abort_txn (dm_data_$current_txn_id, code);
   call signal_ ("transaction_bj_full_", null (), addr (my_signal_structure));
   call RETURN (dm_error_$bj_journal_full);      /* should never get here */
%page;
/* SUBROUTINES */

RETURN:
   proc (r_p_code);

/* DESCRIPTION of RETURN:
   This routine is called to exit the main procedure.  It is called in
   three cases: to return without errors, to return with a minor error
   which should not be logged, and to return from the fm_sub_error_
   condition handler.
*/

   dcl	 r_p_code		    fixed bin (35);

   p_code = r_p_code;
   call FINISH ();
   go to MAIN_RETURN;

   end RETURN;


ERROR_RETURN:
   proc (er_p_code, er_p_error_message, er_p_error_message_argument_1,
        er_p_error_message_argument_2);

/* DESCRIPTION of ERROR_RETURN:
   This routine is called to exit the main procedure when a major error
   has occurred requiring logging.  It call fm_error_util_$signal,
   which logs the error message and signals fm_sub_error_.  The condition
   is caught by fm_create_open_'s fm_sub_error_ handler, which returns
   by calling RETURN.
*/

   dcl	 er_p_code	    fixed bin (35) parameter;
   dcl	 (er_p_error_message, er_p_error_message_argument_1,
	 er_p_error_message_argument_2)
			    char (*) parameter;

   call fm_error_util_$signal (er_p_code, MYNAME,
        (FM_ACTION_CANT_RESTART | FM_ACTION_LOG), LOG_SV, er_p_error_message,
        er_p_error_message_argument_1, er_p_error_message_argument_2);

   end ERROR_RETURN;


FINISH:
   proc;


   if msf_fcb_ptr ^= null ()
   then call msf_manager_$close (msf_fcb_ptr);
   if saved_validation_level ^= -1
   then call cu_$level_set (saved_validation_level);
   if my_file_oid.file_access_table_idx > 0
   then file_access_table.e (my_file_oid.file_access_table_idx).state
	   .entry_state = FILE_ACCESS_INFO_NOT_IN_USE;

   end FINISH;
%page;
INIT:
   proc;

/* THE LOGIC DOES NOT DEPEND ON THE INITIALIZATIONS BELOW */

   ci_header_ptr = null ();
   ci_trailer_ptr = null ();
   file_create_info_ptr = null ();

   unspec (my_ci_header) = ""b;
   unspec (my_create_info) = ""b;
   unspec (my_file_attributes) = ""b;

/* THE LOGIC DOES NOT DEPEND ON THE INITIALIZATIONS ABOVE */

   end INIT;

INIT_ATTR_CI_PARTS:
   proc (iacp_p_ci_parts_ptr, iacp_p_local_ptr);

/* DESCRIPTION of INIT_ATTR_CI_PARTS:
   Initializes the ci_parts structure pointed to by iacp_p_ci_parts_ptr
   such that it has the correct offset and length for accessing the 
   file_attributes in control interval 0. Sets the local_ptr in the
   ci_parts structure to iacp_p_local_ptr.  This can be used to 
   initialize the ci_parts structure for read or write.
*/

   dcl	 iacp_p_ci_parts_ptr    ptr parameter;
   dcl	 iacp_p_local_ptr	    ptr parameter;

   iacp_p_ci_parts_ptr -> ci_parts.number_of_parts = 1;
   iacp_p_ci_parts_ptr -> ci_parts.part (1).offset_in_bytes =
        CI_0_ADDRESSABLE_LENGTH;
   iacp_p_ci_parts_ptr -> ci_parts.part (1).length_in_bytes =
        CI_ADDRESSABLE_LENGTH - CI_0_ADDRESSABLE_LENGTH;
   iacp_p_ci_parts_ptr -> ci_parts.part (1).local_ptr = iacp_p_local_ptr;

   return;

   end INIT_ATTR_CI_PARTS;
%page;
ENCODE_RING_BRACKETS:
   proc (erb_p_write_bracket, erb_p_read_bracket) returns (fixed bin);

   dcl	 erb_p_write_bracket    fixed bin (3);
   dcl	 erb_p_read_bracket	    fixed bin (3);

   return ((8 * erb_p_write_bracket + erb_p_read_bracket));

   end ENCODE_RING_BRACKETS;
%page;
ADD_FILE_ACCESS_TABLE_ENTRY:
   proc ();


   do file_access_table_idx = lbound (file_access_table.e, 1)
        to file_access_table.h.last_entry
        while (file_access_table.e (file_access_table_idx).state.entry_state
        ^= 0);
   end;

   if file_access_table_idx > file_access_table.h.last_entry
   then
      do;
      if file_access_table.h.last_entry = hbound (file_access_table.e, 1)
      then call RETURN (dm_error_$fm_proc_tbl_full);
      file_access_table.h.last_entry = file_access_table_idx;
      end;

   file_access_table.e (file_access_table_idx) = my_file_access_info;

   my_file_oid.file_access_table_idx = file_access_table_idx;
   my_file_oid.uid_tail = substr (my_file_access_info.uid, 19, 18);

   end ADD_FILE_ACCESS_TABLE_ENTRY;
%page;
GIVE_DAEMON_ACCESS_TO_CONTAINING_DIR:
   proc (gda_p_path);

   dcl	 gda_p_path	    char (168) parm;

   dcl	 gda_dir_path	    char (168);
   dcl	 gda_effective_mode	    fixed bin (5);
   dcl	 gda_entry_name	    char (32);

   dcl	 1 gda_dir_acl_list	    (1) aligned like general_acl_entry;

   dcl	 hcs_$get_user_effmode  entry (char (*), char (*), char (*),
			    fixed bin, fixed bin (5), fixed bin (35));


   call expand_pathname_ (gda_p_path, gda_dir_path, gda_entry_name, code);
   if code ^= 0
   then call ERROR_RETURN (code, "  Unable to expand pathname ^a.^s.",
	   gda_p_path, "");

   call hcs_$get_user_effmode (gda_dir_path, gda_entry_name,
        dm_system_data_$initializer_name, get_ring_ (), gda_effective_mode,
        code);
   if code ^= 0
   then call ERROR_RETURN (code,
	   "  Unable to determine the access of ^a to ^a.",
	   dm_system_data_$initializer_name,
	   pathname_ (gda_dir_path, gda_entry_name));

   if gda_effective_mode ^= SMA_ACCESS_BIN
   then
      do;
      unspec (gda_dir_acl_list) = ""b;
      gda_dir_acl_list (1).access_name = dm_system_data_$initializer_name;
      gda_dir_acl_list (1).mode = SMA_ACCESS;

      call hcs_$add_dir_acl_entries (gda_dir_path, gda_entry_name,
	 addr (gda_dir_acl_list), dim (gda_dir_acl_list, 1), code);
      if code ^= 0
      then
         do;
         if gda_dir_acl_list (1).status_code ^= 0
         then code = gda_dir_acl_list (1).status_code;
         call ERROR_RETURN (code,
	    "  Unable to add 'sma' directory acl term to ^a for ^a.",
	    pathname_ (gda_dir_path, gda_entry_name),
	    (gda_dir_acl_list (1).access_name));
         end;
      end;

   return;


   end GIVE_DAEMON_ACCESS_TO_CONTAINING_DIR;
%page;
ADJUST_IACL:
   proc (ai_p_dir_path, ai_p_entry, ai_p_validation_level, ai_p_write_bracket,
        ai_p_msf_fcb_ptr);
   dcl	 ai_p_dir_path	    char (*) parm;
   dcl	 ai_p_entry	    char (*) parm;
   dcl	 ai_p_validation_level  fixed bin (3) parm;
   dcl	 ai_p_write_bracket	    fixed bin (3) parm;
   dcl	 ai_p_msf_fcb_ptr	    ptr parm;

   dcl	 ai_acl_idx	    fixed bin init (0);
   dcl	 ai_code		    fixed bin (35) init (0);
   dcl	 1 ai_delete_acl_array  (ai_delete_acl_count) aligned
			    based (ai_delete_acl_array_ptr)
			    like general_delete_acl_entry;
   dcl	 ai_delete_acl_count    fixed bin init (0);
   dcl	 ai_delete_acl_array_ptr
			    ptr init (null ());
   dcl	 ai_dir_dir	    char (168);
   dcl	 ai_dir_entry	    char (32);
   dcl	 ai_iacl_count	    fixed bin init (0);
   dcl	 1 ai_iacl_array	    (ai_iacl_count) aligned
			    based (ai_iacl_array_ptr)
			    like segment_acl_entry;
   dcl	 ai_iacl_array_ptr	    ptr init (null ());

   on cleanup call AI_FINISH ();

   call expand_pathname_ (ai_p_dir_path, ai_dir_dir, ai_dir_entry, ai_code);
   if ai_code ^= 0
   then call ERROR_RETURN (ai_code,
	   "^/Unable to expand the pathname of the directory, ^a, which is to contain the new DM file.",
	   ai_p_dir_path, "");


/* The IACLs applied by msf_manager_ at creation time are those for the ring
of the validation level.  However, the IACLs which should be applied are those
for the ring of the write_bracket.  Hence, it's necessary to delete the IACLs
for the validation level, then apply the (adjusted) IACLs for the
write_bracket ring.
*/

   call hcs_$list_inacl (ai_dir_dir, ai_dir_entry, dm_data_$area_ptr,
        ai_iacl_array_ptr, null (), ai_iacl_count, ai_p_validation_level,
        ai_code);
   if ai_code ^= 0
   then call ERROR_RETURN (ai_code,
	   "^/Unable to list the initial segment ACL for ^a for the validation level ^a.",
	   pathname_ (ai_dir_dir, ai_dir_entry),
	   ltrim (char (ai_p_validation_level)));
   if ai_iacl_count > 0
   then
      do;
      ai_delete_acl_count = ai_iacl_count;
      alloc ai_delete_acl_array in (dm_area);
      do ai_acl_idx = 1 to ai_delete_acl_count;
         ai_delete_acl_array (ai_acl_idx).access_name =
	    ai_iacl_array (ai_acl_idx).access_name;
         ai_delete_acl_array (ai_acl_idx).status_code = 0;
      end;

      free ai_iacl_array;
      ai_iacl_array_ptr = null ();

      call msf_manager_$acl_delete (ai_p_msf_fcb_ptr, ai_delete_acl_array_ptr,
	 ai_delete_acl_count, ai_code);
      if ai_code ^= 0
      then call ERROR_RETURN (ai_code,
	      "^/Unable to delete the IACLs for the validation level (^a) while creating ^a.",
	      ltrim (char (ai_p_validation_level)),
	      pathname_ (ai_p_dir_path, ai_p_entry));
      free ai_delete_acl_array;
      ai_delete_acl_array_ptr = null ();
      end;

/* Add the IACL for the write_bracket ring, after first turning off any use of the "e"
access bit.
*/

   call hcs_$list_inacl (ai_dir_dir, ai_dir_entry, dm_data_$area_ptr,
        ai_iacl_array_ptr, null (), ai_iacl_count, ai_p_write_bracket, ai_code)
        ;
   if ai_code ^= 0
   then call ERROR_RETURN (ai_code,
	   "^/Unable to list the initial segment ACL for ^a for the write_bracket ring ^a.",
	   pathname_ (ai_dir_dir, ai_dir_entry),
	   ltrim (char (ai_p_write_bracket)));

   do ai_acl_idx = 1 to ai_iacl_count;
      if (ai_iacl_array (ai_acl_idx).mode & E_ACCESS)
      then ai_iacl_array (ai_acl_idx).mode =
	      ai_iacl_array (ai_acl_idx).mode & RW_ACCESS;
   end;

   if ai_iacl_count > 0
   then
      do;
      call msf_manager_$acl_add (ai_p_msf_fcb_ptr, ai_iacl_array_ptr,
	 ai_iacl_count, ai_code);
      if ai_code ^= 0
      then call ERROR_RETURN (ai_code,
	      "^/Unable to add the ACL entries developed from the seg IACL with a set of those ACL terms with the ""e"" access removed while attempting to create ^a.",
	      pathname_ (ai_p_dir_path, ai_p_entry), "");
      end;

   call AI_FINISH ();
   return;

AI_FINISH:
   proc ();
   if ai_iacl_array_ptr ^= null ()
   then free ai_iacl_array;
   if ai_delete_acl_array_ptr ^= null ()
   then free ai_delete_acl_array;
   end AI_FINISH;
   end ADJUST_IACL;
%page;

/* ***************** START OF INCLUDE FILES ********************** */


%include access_mode_values;
%page;
%include acl_structures;
%page;
%include dm_ci_header;
%page;
%include dm_ci_lengths;


%include dm_ci_constants;
%page;
%include dm_ci_parts;
%page;
%include dm_lock_modes;
%page;
%include dm_file_create_info;
%page;
%include dm_file_validation_name;
%page;
%include dm_fm_file_attributes;
%page;
%include dm_fm_file_access_info;
%page;
%include dm_fm_file_access_tbl;
%page;
%include dm_fm_file_oid;
%page;
%include dm_fm_rollback_info;
%page;
%include dm_fm_sub_error_flags;
%page;
%include dm_log_sv_codes;
%page;
%include condition_info_header;

   end fm_create_open_$create_open;
