/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        *********************************************************** */

/* DESCRIPTION

   This module implements the control interval update operations of the
   file manager.


NON-FAILING AUDIT COMMENTS NOT YET ADDRESSED:
   
   This module should be re-written.
*/

/* HISTORY:

Written by Bensoussan-Ives, 06/22/82.
   01/28/82 by Andre Bensoussan: Specification and design.
   06/22/82 by Jeffery D. Ives: Design and coding.
Modified:
10/05/83 by Jeffrey D. Ives: Added initial implementation of lock advice.
01/25/84 by Jeffrey D. Ives: Fixed lock advice to make sure that, when the
	  advice is changed, the new advice is passed on to the lock manager.
05/23/84 by R. Michael Tague:  Added simple_put and fm_put_.
06/07/84 by Lee Baldwin:  Renamed a bunch of dm_error_ codes.
07/26/84 by Matthew Pierret:  Changed to check extended ring brackets.
            Also, as an aside, made extensive re-modularizations, name changes,
            added RETURN procedure instead of all of those go to statements.
11/01/84 by Matthew Pierret: Answered audit comments: removed unnecessary
            copy of p_file_oid after PUT_JOIN label; removed the un-used entry
            internal_get_uid ; removed "signal error" - the cases in which
            the signal was attempted were not possible ; changed to use
            dm_error_$no_current_transaction instead of $fm_no_current_txn ;
            moved external entry declarations two the main procedure ; liked
            my_ci_parts.part and single_ci_part.part to ci_parts.part.
            Removed the un-used undo entry. It is now in fm_do_$undo.
            Removed declared but un-used variables. Removed dm_fm_file_oid
            from GET_ACCESS_INFO, instead declaring gai_my_file_oid liked to
            the file_oid in dm_fm_file_oid.incl.pl1 in the main procedure.
            Made to use dm_ci_header.incl.pl1 and dm_ci_constants.incl.pl1.
12/06/84 by Matthew C. Pierret:  Added must_be_zero component to my_ci_parts
            and single_ci_part structures.  Fixed to not inadvertently re-read
            the p_file_oid parameter in the free entry.  Changed local
            flush_consec structure to fc_flush_consec, liked on flush_consec
            in the include file flush_structures.  Removed comment surrounding
            form-feed.
12/17/84 by Matthew C. Pierret:  Changed to use new file_access_info state
            variables. 
02/01/85 by Matthew C. Pierret:  Changed to return dm_error_$file_was_deleted
            instead of error_table_$invalidsegno if the latter is returned
            from one the hcs_$flush_* entries.
02/06/85 by S. Cox: Added transaction_bj_full_ handler for the put entries.
03/08/85 by S. Cox: Added TRANSACTION_BJ_FULL_HANDLER invoked by nonlocal goto.
03/14/85 by R. Michael Tague: Added $postcommit_increment.
03/21/85 by S. Cox: TRANSACTION_BJ_FULL_HANDLER: Add revert of txn_bj_full_
03/21/85 by R. Michael Tague: Added protected file check to
            $postcommit_increment.
04/11/85 by Lindsey L. Spratt:  Fixed to normally complete in FLUSH and
            FLUSH_MOD_PAGES (when error_table_$invalidsegno is encountered)
            before calling RETURN(dm_error_$file_was_deleted).
04/24/85 by Matthew Pierret:  Changed FLUSH_MOD_PAGES to not return
            dm_error_$file_was_deleted (or any error code) if the operation
            is an unput operation and error_table_$invalid_segno is
            encountered.
05/03/85 by Matthew Pierret:  Changed the proc_txn_tbl version to char (8) from
            bit(36)aligned with the value PROC_TXN_TBL_VERSION_2. Changed
            proc_txn to maintain parallel arrays of modified pages and file
            uids of the files to which the modified pages belong. Also changed
            to insertion algorithm to do a binary search, changing
            proc_txn.low_idx and proc_txn.high_idx to simply
            proc_txn.last_entry.
            Added fm_put_$discard_file_flush_list, which is to be called when
            deleting a file to "forget" modified pages in the file.  This
            should eliminate error_table_$invalidsegno and $dirseg errors.
*/


/****^  HISTORY COMMENTS:
  1) change(87-01-15,Hergert), approve(87-04-01,MCR7632),
     audit(87-02-02,Dupuis), install(87-04-02,MR12.1-1020):
     For TR phx20754, arranged to pass along the element_id of the
     key_count_array that we saved in cm_postcommit_increment so that we can
     use it at post_commit time if necessary. We save it in my_postcommit_info.
                                                   END HISTORY COMMENTS */



/* format: style2,ind3 */

fm_put_$init_txn_tbl:
   proc (p_code);

/* START OF DECLARATIONS */

/* Parameters */

      dcl	    p_ci_num	       fixed bin (27) parm;
      dcl	    p_ci_parts_ptr	       ptr parm;
      dcl	    p_single_part_length   fixed bin (17) parm;
      dcl	    p_single_part_offset   fixed bin (17) parm;
      dcl	    p_single_part_ptr      ptr parm;
      dcl	    p_code	       fixed bin (35) parm;
      dcl	    p_first_ci	       fixed bin (27) parm;
      dcl	    p_lock_mode	       fixed bin parm;
      dcl	    p_number_of_ci	       fixed bin (27) parm;
      dcl	    p_file_oid	       bit (36) aligned parm;
      dcl	    p_increment_info_ptr   ptr parm;
      dcl	    p_transaction_id       bit (36) aligned parm;
      dcl	    p_transaction_index    fixed bin parm;
      dcl	    p_file_uid	       bit (36) aligned parm;


/* Automatic */

      dcl	    ci_num	       fixed bin (27);
      dcl	    code		       fixed bin (35);
      dcl	    component_num	       fixed bin;
      dcl	    first_ci	       fixed bin (27);
      dcl	    last_ci	       fixed bin (28);
      dcl	    lock_mode	       fixed bin;
      dcl	    my_file_oid	       aligned bit (36);
      dcl	    my_part_idx	       fixed bin;
      dcl	    n_ci		       fixed bin (27);
      dcl	    number_of_addressable_bytes
			       fixed bin;
      dcl	    operation_is_unput     bit aligned init ("0"b);
      dcl	    page_num	       fixed bin (8);
      dcl	    part_idx	       fixed bin;
      dcl	    part_length	       fixed bin;
      dcl	    part_offset	       fixed bin;
      dcl	    some_ci_already_allocated
			       bit aligned;
      dcl	    some_ci_already_free   bit aligned;
      dcl	    transaction_id	       bit (36) aligned;
      dcl	    transaction_index      fixed bin;

      dcl	    dtcm		       fixed bin (71);
      dcl	    my_ci_id	       fixed bin (71);
      dcl	    my_ci_stamp	       fixed bin (71);
      dcl	    part_ptr	       ptr;


      dcl	    1 seg		       aligned based,
	      2 pages	       (0:254),
	        3 double_words     (512) fixed bin (71);

      dcl	    part_buffer	       char (part_length) based (part_ptr);

      dcl	    my_part_ptrs	       (8) ptr;

      dcl	    1 my_ci_parts	       aligned,
	      2 number_of_parts    fixed bin init (0),
	      2 must_be_zero       fixed bin init (0),
	      2 part	       (8) like ci_parts.part;

      dcl	    1 single_ci_part       aligned,
	      2 number_of_parts    fixed bin (17) init (1),
	      2 must_be_zero       fixed bin init (0),
	      2 part	       (1) like ci_parts.part;

      dcl	    1 effective_integrity_switches
			       aligned like file_access_info.integrity_switches;

      dcl	    1 my_postcommit_info   aligned like increment_postcommit_info;
      dcl	    1 my_file_access_info  aligned like file_access_info;
      dcl	    1 my_signal_structure  aligned like condition_info_header;

/* Based */
/* Builtin */

      dcl	    (addr, baseno, baseptr, bin, clock, divide, hbound, lbound, max, min, multiply, null, string, substr,
	    unspec)	       builtin;

/* Conditions */

      dcl	    (cleanup, transaction_bj_full_)
			       condition;

/* Constants */

      dcl	    BYTES_PER_WORD	       init (4) fixed bin internal static options (constant);
      dcl	    FOR_UNPUT	       init ("1"b) bit (1) aligned internal static options (constant);
      dcl	    NOT_FOR_UNPUT	       init ("0"b) bit (1) aligned internal static options (constant);
      dcl	    ERROR_FREE	       init (0) fixed bin (35) internal static options (constant);
      dcl	    NO_TRANSACTION	       init (""b) bit (36) aligned internal static options (constant);
      dcl	    (
	    NULL_INTEGRITY_SWITCHES
			       init (1),
	    VANILLA_WRITE_INTEGRITY_SWITCHES
			       init (2),
	    UNPUT_INTEGRITY_SWITCHES
			       init (3),
	    UNPROTECTED_INTEGRITY_SWITCHES
			       init (4)
	    )		       fixed bin internal static options (constant);
      dcl	    LOCK_WAIT_TIME	       init (1e9) fixed bin (71) internal static options (constant);

/* External Variables */

      dcl	    dm_data_$current_txn_id
			       bit (36) aligned ext;
      dcl	    dm_data_$current_txn_index
			       fixed bin ext;
      dcl	    sys_info$data_management_ringno
			       fixed bin ext;
      dcl	    error_table_$bad_subr_arg
			       fixed bin (35) ext;
      dcl	    error_table_$invalidsegno
			       fixed bin (35) ext;
      dcl	    error_table_$no_w_permission
			       fixed bin (35) ext;
      dcl	    error_table_$noentry   fixed bin (35) ext;
      dcl	    error_table_$not_dm_ring
			       fixed bin (35) ext;
      dcl	    dm_error_$bad_file_oid fixed bin (35) ext;
      dcl	    dm_error_$bj_journal_full
			       fixed bin (35) ext;
      dcl	    dm_error_$ci_already_allocated
			       fixed bin (35) ext;
      dcl	    dm_error_$ci_already_free
			       fixed bin (35) ext;
      dcl	    dm_error_$ci_bad_hdr_id_num
			       fixed bin (35) ext;
      dcl	    dm_error_$ci_bad_hdr_size_code
			       fixed bin (35) ext;
      dcl	    dm_error_$ci_bad_hdr_uid
			       fixed bin (35) ext;
      dcl	    dm_error_$ci_bad_stamp_ver
			       fixed bin (35) ext;
      dcl	    dm_error_$ci_num_oob   fixed bin (35) ext;
      dcl	    dm_error_$ci_num_parts_neg
			       fixed bin (35) ext;
      dcl	    dm_error_$ci_parts_oob fixed bin (35) ext;
      dcl	    dm_error_$file_doesnt_exist
			       fixed bin (35) ext;
      dcl	    dm_error_$file_must_be_protected
			       fixed bin (35) ext;
      dcl	    dm_error_$file_was_deleted
			       fixed bin (35) ext;
      dcl	    dm_error_$fm_bad_inc_info_ver
			       fixed bin (35) ext;
      dcl	    dm_error_$fm_bad_proc_txn_tbl_ver
			       fixed bin (35) ext;
      dcl	    dm_error_$fm_cant_free_ci_0
			       fixed bin (35) ext;
      dcl	    dm_error_$fm_first_ci_neg
			       fixed bin (35) ext;
      dcl	    dm_error_$fm_num_ci_neg
			       fixed bin (35) ext;
      dcl	    dm_error_$fm_old_txn_not_flushed
			       fixed bin (35) ext;
      dcl	    dm_error_$lock_invalid_mode
			       fixed bin (35) ext;
      dcl	    dm_error_$no_current_transaction
			       fixed bin (35) ext;



/* Entry */

      dcl	    continue_to_signal_    entry (fixed bin (35));
      dcl	    cu_$level_get	       entry (fixed bin);
      dcl	    cu_$level_set	       entry (fixed bin);
      dcl	    dm_hcs_$set_force_write_limit
			       entry (fixed bin, fixed bin (35));
      dcl	    get_ring_	       entry () returns (fixed bin (3));
      dcl	    hcs_$flush_consecutive_pages
			       entry (ptr, fixed bin (35));
      dcl	    hcs_$flush_pages       entry (ptr, fixed bin (35));

      dcl	    before_journal_manager_$flush_transaction
			       entry (bit (36) aligned, fixed bin, fixed bin (35));
      dcl	    before_journal_manager_$write_before_image
			       entry (bit (36) aligned, bit (36) aligned, fixed bin (27), ptr, fixed bin (71),
			       fixed bin (35));
      dcl	    before_journal_manager_$write_fm_postcommit_handler
			       entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (21), fixed bin (35));
      dcl	    hcs_$fs_get_path_name  entry (ptr, char (*), fixed bin, char (*), fixed bin (35));
      dcl	    hcs_$set_synchronized_sw
			       entry (char (*), char (*), bit aligned, fixed bin (35));
      dcl	    ioa_$rsnnl	       entry () options (variable);
      dcl	    lock_manager_$lock     entry (bit (36) aligned, fixed bin (27), fixed bin, fixed bin (71), fixed bin,
			       fixed bin (35));
      dcl	    msf_manager_$msf_get_ptr
			       entry (ptr, fixed bin, bit (1), ptr, fixed bin (24), fixed bin (35));
      dcl	    signal_	       entry () options (variable);
      dcl	    transaction_manager_$abort_txn
			       entry (bit (36) aligned, fixed bin (35));

/* END OF DECLARATIONS */
%page;

/*
init_txn_tbl:
     entry (p_code);
*/

      call INIT;

      call TXN_INIT_PROC_DATA;

      call RETURN (ERROR_FREE);

/* Effective end of fm_put_$init_txn_tbl */


get_uid:
   entry (p_file_oid, p_file_uid, p_code);

      call INIT;
      my_file_oid = p_file_oid;
      file_access_info_ptr = addr (my_file_access_info);
      call GET_ACCESS_INFO (my_file_oid, NOT_FOR_UNPUT, file_access_info_ptr);

      if file_access_info.opens = 0
      then call RETURN (dm_error_$bad_file_oid);

      p_file_uid = file_access_info.uid;

      call RETURN (ERROR_FREE);

/* Effective end of fm_put_$get_uid */
%page;
allocate:
   entry (p_file_oid, p_first_ci, p_number_of_ci, p_code);

      call INIT;
      my_file_oid = p_file_oid;
      file_access_info_ptr = addr (my_file_access_info);
      call GET_ACCESS_INFO (my_file_oid, NOT_FOR_UNPUT, file_access_info_ptr);
      call CHECK_RING_ACCESS ((file_access_info.ring_brackets.write));
      call GET_INTEGRITY_SWITCHES (VANILLA_WRITE_INTEGRITY_SWITCHES, (file_access_info.integrity_switches),
	 effective_integrity_switches);
      call GET_TRANSACTION_INFO (effective_integrity_switches.transaction, transaction_id, transaction_index);

      if file_access_info.opens = 0
      then call RETURN (dm_error_$bad_file_oid);

      first_ci = p_first_ci;
      n_ci = p_number_of_ci;

      call CHECK_CI_RANGE (first_ci, n_ci, last_ci);

      if effective_integrity_switches.lock
      then
         do;
	  do ci_num = first_ci to last_ci;
	     call LOCK_EXCLUSIVELY (ci_num, transaction_id, addr (my_file_oid) -> file_oid.file_access_table_idx);
	  end;
         end;

      some_ci_already_allocated = "0"b;

      do ci_num = first_ci to last_ci;
         component_num = divide (ci_num, file_access_info.blocking_factor, 27);

         call MAKE_SEG_PTR (component_num, ci_ptr, addr (my_file_oid) -> file_oid.file_access_table_idx,
	    (effective_integrity_switches.bj));

         page_num = ci_num - multiply (component_num, file_access_info.blocking_factor, 27);
         ci_ptr = addr (ci_ptr -> pages (page_num));

         if ci.trailer.stamp ^= 0
         then some_ci_already_allocated = "1"b;
         else
	  do;
	     call BASIC_ALLOCATE;

	     if effective_integrity_switches.transaction
	     then call TXN_REMEMBER_MOD_PAGE;

	     if effective_integrity_switches.aj
	     then
	        do;
	        end;
	  end;
      end;

      if some_ci_already_allocated
      then call RETURN (dm_error_$ci_already_allocated);

      call RETURN (ERROR_FREE);


/* Effective end of fm_put_$allocate */
%page;
free:
   entry (p_file_oid, p_first_ci, p_number_of_ci, p_code);

      call INIT;
      my_file_oid = p_file_oid;
      file_access_info_ptr = addr (my_file_access_info);
      call GET_ACCESS_INFO (my_file_oid, NOT_FOR_UNPUT, file_access_info_ptr);
      call CHECK_RING_ACCESS ((file_access_info.ring_brackets.write));
      call GET_INTEGRITY_SWITCHES (VANILLA_WRITE_INTEGRITY_SWITCHES, (file_access_info.integrity_switches),
	 effective_integrity_switches);
      call GET_TRANSACTION_INFO (effective_integrity_switches.transaction, transaction_id, transaction_index);

      if file_access_info.opens = 0
      then call RETURN (dm_error_$bad_file_oid);

      first_ci = p_first_ci;
      n_ci = p_number_of_ci;

      if first_ci = 0
      then call RETURN (dm_error_$fm_cant_free_ci_0);

      call CHECK_CI_RANGE (first_ci, n_ci, last_ci);

      if effective_integrity_switches.lock
      then
         do;
	  do ci_num = first_ci to last_ci;
	     call LOCK_EXCLUSIVELY (ci_num, transaction_id, addr (my_file_oid) -> file_oid.file_access_table_idx);
	  end;
         end;

      if effective_integrity_switches.bj
      then
         do;
	  single_ci_part.part (1).offset_in_bytes = 0;
	  single_ci_part.part (1).length_in_bytes = CI_ADDRESSABLE_LENGTH;

	  do ci_num = last_ci to first_ci by -1;
	     component_num = divide (ci_num, file_access_info.blocking_factor, 27);

	     call GET_SEG_PTR (component_num, ci_ptr, addr (my_file_oid) -> file_oid.file_access_table_idx);

	     if ci_ptr ^= null ()
	     then
	        do;
		 page_num = ci_num - multiply (component_num, file_access_info.blocking_factor, 27);
		 ci_ptr = addr (ci_ptr -> seg.pages (page_num));

		 if ci.trailer.stamp ^= 0 & unspec (ci.addressable_bytes) ^= ""b
		 then
		    do;
		       on transaction_bj_full_ goto TRANSACTION_BJ_FULL_HANDLER;
		       single_ci_part.part (1).local_ptr = addr (ci.addressable_bytes);
		       call before_journal_manager_$write_before_image (file_access_info.uid, my_file_oid, ci_num,
			  addr (single_ci_part), dtcm, code);
		       if code ^= 0
		       then call RETURN (code);
		    end;
	        end;
	  end;

	  call before_journal_manager_$flush_transaction (transaction_id, transaction_index, code);
	  if code ^= 0
	  then call RETURN (code);
         end;

      some_ci_already_free = "0"b;

      do ci_num = last_ci to first_ci by -1;
         component_num = divide (ci_num, file_access_info.blocking_factor, 27);

         call GET_SEG_PTR (component_num, ci_ptr, addr (my_file_oid) -> file_oid.file_access_table_idx);

         if ci_ptr = null ()
         then some_ci_already_free = "1"b;
         else
	  do;
	     page_num = ci_num - multiply (component_num, file_access_info.blocking_factor, 27);
	     ci_ptr = addr (ci_ptr -> seg.pages (page_num));

	     if ci.trailer.stamp = 0
	     then some_ci_already_free = "1"b;

	     if unspec (ci) ^= ""b
	     then
	        do;
		 ci.trailer.stamp = 0;
		 unspec (ci) = ""b;

		 if effective_integrity_switches.transaction
		 then call TXN_REMEMBER_MOD_PAGE;

		 if effective_integrity_switches.aj
		 then
		    do;
		    end;
	        end;
	  end;
      end;

      if some_ci_already_free
      then call RETURN (dm_error_$ci_already_free);
      else call RETURN (ERROR_FREE);


/* Effective end of fm_put_$free */
%page;
internal_put:
   entry (p_file_oid, p_ci_num, p_ci_parts_ptr, p_code);

      call INIT;
      my_file_oid = p_file_oid;
      file_access_info_ptr = addr (my_file_access_info);
      call GET_ACCESS_INFO (my_file_oid, NOT_FOR_UNPUT, file_access_info_ptr);
      call CHECK_RING_ACCESS ((file_access_info.ring_brackets.write));
      call GET_INTEGRITY_SWITCHES (VANILLA_WRITE_INTEGRITY_SWITCHES, (file_access_info.integrity_switches),
	 effective_integrity_switches);
      call GET_TRANSACTION_INFO (effective_integrity_switches.transaction, transaction_id, transaction_index);

      ci_parts_ptr = p_ci_parts_ptr;
      ci_num = p_ci_num;

      number_of_addressable_bytes = CI_ADDRESSABLE_LENGTH;

      go to PUT_JOIN;



unput:
   entry (p_file_oid, p_ci_num, p_ci_parts_ptr, p_code);

      operation_is_unput = "1"b;

      call INIT;
      my_file_oid = p_file_oid;
      file_access_info_ptr = addr (my_file_access_info);
      call GET_ACCESS_INFO (my_file_oid, FOR_UNPUT, file_access_info_ptr);
      call CHECK_RING_ACCESS ((file_access_info.ring_brackets.write));
      call GET_INTEGRITY_SWITCHES (UNPUT_INTEGRITY_SWITCHES, (file_access_info.integrity_switches),
	 effective_integrity_switches);
      call GET_TRANSACTION_INFO (effective_integrity_switches.transaction, transaction_id, transaction_index);

      call TXN_DONT_FLUSH_BJ;

      ci_parts_ptr = p_ci_parts_ptr;
      ci_num = p_ci_num;

      number_of_addressable_bytes = CI_ADDRESSABLE_LENGTH;

      go to PUT_JOIN;



put_journal:
   entry (p_file_oid, p_ci_num, p_ci_parts_ptr, p_code);

      call INIT;
      my_file_oid = p_file_oid;
      file_access_info_ptr = addr (my_file_access_info);
      call GET_ACCESS_INFO (my_file_oid, NOT_FOR_UNPUT, file_access_info_ptr);
      call CHECK_RING_ACCESS ((file_access_info.ring_brackets.write));
      call GET_INTEGRITY_SWITCHES (UNPROTECTED_INTEGRITY_SWITCHES, (file_access_info.integrity_switches),
	 effective_integrity_switches);
      call GET_TRANSACTION_INFO (effective_integrity_switches.transaction, transaction_id, transaction_index);

      if file_access_info.opens = 0
      then call RETURN (dm_error_$bad_file_oid);

      ci_parts_ptr = p_ci_parts_ptr;
      ci_num = p_ci_num;

      if ci_num = 0
      then number_of_addressable_bytes = CI_0_ADDRESSABLE_LENGTH;
      else number_of_addressable_bytes = CI_ADDRESSABLE_LENGTH;

      go to PUT_JOIN;


raw_put:
   entry (p_file_oid, p_ci_num, p_ci_parts_ptr, p_code);

      call INIT;
      my_file_oid = p_file_oid;
      file_access_info_ptr = addr (my_file_access_info);
      call GET_ACCESS_INFO (my_file_oid, NOT_FOR_UNPUT, file_access_info_ptr);
      call CHECK_RING_ACCESS ((file_access_info.ring_brackets.write));
      call GET_INTEGRITY_SWITCHES (NULL_INTEGRITY_SWITCHES, (file_access_info.integrity_switches),
	 effective_integrity_switches);
      call GET_TRANSACTION_INFO (effective_integrity_switches.transaction, transaction_id, transaction_index);

      if file_access_info.opens = 0
      then call RETURN (dm_error_$bad_file_oid);

      ci_parts_ptr = p_ci_parts_ptr;
      ci_num = p_ci_num;

      if ci_num = 0
      then number_of_addressable_bytes = CI_0_ADDRESSABLE_LENGTH;
      else number_of_addressable_bytes = CI_ADDRESSABLE_LENGTH;

      go to PUT_JOIN;




put:
   entry (p_file_oid, p_ci_num, p_ci_parts_ptr, p_code);

      call INIT;
      my_file_oid = p_file_oid;
      file_access_info_ptr = addr (my_file_access_info);
      call GET_ACCESS_INFO (my_file_oid, NOT_FOR_UNPUT, file_access_info_ptr);
      call CHECK_RING_ACCESS ((file_access_info.ring_brackets.write));
      call GET_INTEGRITY_SWITCHES (VANILLA_WRITE_INTEGRITY_SWITCHES, (file_access_info.integrity_switches),
	 effective_integrity_switches);
      call GET_TRANSACTION_INFO (effective_integrity_switches.transaction, transaction_id, transaction_index);

      if file_access_info.opens = 0
      then call RETURN (dm_error_$bad_file_oid);

      ci_parts_ptr = p_ci_parts_ptr;
      ci_num = p_ci_num;

      if ci_num = 0
      then number_of_addressable_bytes = CI_0_ADDRESSABLE_LENGTH;
      else number_of_addressable_bytes = CI_ADDRESSABLE_LENGTH;

      go to PUT_JOIN;

simple_put:
   entry (p_file_oid, p_ci_num, p_single_part_offset, p_single_part_ptr, p_single_part_length, p_code);

      call INIT;
      my_file_oid = p_file_oid;
      file_access_info_ptr = addr (my_file_access_info);
      call GET_ACCESS_INFO (my_file_oid, NOT_FOR_UNPUT, file_access_info_ptr);
      call CHECK_RING_ACCESS ((file_access_info.ring_brackets.write));
      call GET_INTEGRITY_SWITCHES (VANILLA_WRITE_INTEGRITY_SWITCHES, (file_access_info.integrity_switches),
	 effective_integrity_switches);
      call GET_TRANSACTION_INFO (effective_integrity_switches.transaction, transaction_id, transaction_index);

      if file_access_info.opens = 0
      then call RETURN (dm_error_$bad_file_oid);
      ci_parts_ptr = addr (single_ci_part);
      ci_parts.part (1).offset_in_bytes = p_single_part_offset;
      ci_parts.part (1).length_in_bytes = p_single_part_length;
      ci_parts.part (1).local_ptr = p_single_part_ptr;
      ci_num = p_ci_num;
      if ci_num = 0
      then number_of_addressable_bytes = CI_0_ADDRESSABLE_LENGTH;
      else number_of_addressable_bytes = CI_ADDRESSABLE_LENGTH;
      go to PUT_JOIN;

%page;
PUT_JOIN:
      if ci_parts.number_of_parts < 0
      then call RETURN (dm_error_$ci_num_parts_neg);

      if ci_num < 0 | ci_num > MAX_CI_NUM
      then call RETURN (dm_error_$ci_num_oob);

      if effective_integrity_switches.lock
      then call LOCK_EXCLUSIVELY (ci_num, transaction_id, addr (my_file_oid) -> file_oid.file_access_table_idx);

      component_num = divide (ci_num, file_access_info.blocking_factor, 27);

      call MAKE_SEG_PTR (component_num, ci_ptr, addr (my_file_oid) -> file_oid.file_access_table_idx,
	 (effective_integrity_switches.bj));

      page_num = ci_num - multiply (component_num, file_access_info.blocking_factor, 27);
      ci_ptr = addr (ci_ptr -> seg.pages (page_num));

      my_ci_stamp = ci.trailer.stamp;
      my_ci_id = ci.header.id;

      if my_ci_stamp = 0
      then call BASIC_ALLOCATE;
      else
         do;
	  if addr (my_ci_stamp) -> ci_stamp.version ^= CI_STAMP_VERSION_1
	  then call RETURN (dm_error_$ci_bad_stamp_ver);

	  if addr (my_ci_id) -> ci_id.size_code ^= SIZE_CODE_1024_WORDS
	  then call RETURN (dm_error_$ci_bad_hdr_size_code);

	  if addr (my_ci_id) -> ci_id.uid ^= file_access_info.uid
	  then call RETURN (dm_error_$ci_bad_hdr_uid);

	  if addr (my_ci_id) -> ci_id.num ^= ci_num
	  then call RETURN (dm_error_$ci_bad_hdr_id_num);
         end;

      unspec (my_ci_parts) = ""b;
      my_part_ptrs (*) = null ();
      my_part_idx = 0;

      do part_idx = lbound (ci_parts.part, 1) to ci_parts.number_of_parts;
         part_length = ci_parts.part (part_idx).length_in_bytes;

         if part_length < 0
         then call RETURN (dm_error_$ci_parts_oob);

         if part_length > 0
         then
	  do;
	     part_offset = ci_parts.part (part_idx).offset_in_bytes;

	     if part_offset < 0 | part_offset + part_length > number_of_addressable_bytes
	     then call RETURN (dm_error_$ci_parts_oob);

	     my_part_idx = my_part_idx + 1;

	     my_ci_parts.part (my_part_idx).offset_in_bytes = part_offset;
	     my_ci_parts.part (my_part_idx).length_in_bytes = part_length;
	     my_ci_parts.part (my_part_idx).local_ptr = addr (substr (ci.addressable_bytes, part_offset + 1));

	     my_part_ptrs (my_part_idx) = ci_parts.part (part_idx).local_ptr;

	     if my_part_idx = hbound (my_ci_parts.part, 1)
	     then call PUT_MY_PARTS;
	  end;
      end;

      if my_part_idx > 0
      then call PUT_MY_PARTS;

      call RETURN (ERROR_FREE);


/* Effective end of all put entries */


MAIN_RETURN:
      return;

RETURN:
   proc (r_p_code);

      dcl	    r_p_code	       fixed bin (35);

      p_code = r_p_code;
      go to MAIN_RETURN;

   end RETURN;

TRANSACTION_BJ_FULL_HANDLER:
/**** Cannot call bj_report_err_ to do this since BJ cannot be called recursively. */
/**** See also fm_(create_open delete_close), which need to handle this condition. */
      revert transaction_bj_full_;
      my_signal_structure.length = size (my_signal_structure);
      my_signal_structure.version = 1;
      string (my_signal_structure.action_flags) = "0"b;
      call ioa_$rsnnl ("Writing a before image for UID ^w OID ^w CI ^d", my_signal_structure.info_string, (0),
	 file_access_info.uid, my_file_oid, ci_num);
      my_signal_structure.status_code = dm_error_$bj_journal_full;

      call transaction_manager_$abort_txn (dm_data_$current_txn_id, code);
      call signal_ ("transaction_bj_full_", null (), addr (my_signal_structure));
      call RETURN (dm_error_$bj_journal_full);		/* should never get here */
%page;
PUT_MY_PARTS:
   proc;
      my_ci_parts.number_of_parts = my_part_idx;

      if effective_integrity_switches.bj
      then
         do;
	  on transaction_bj_full_ goto TRANSACTION_BJ_FULL_HANDLER;
	  call before_journal_manager_$write_before_image (file_access_info.uid, my_file_oid, ci_num,
	       addr (my_ci_parts), dtcm, code);
	  if code ^= 0
	  then call RETURN (code);

	  my_ci_stamp = TEMPLATE_CI_STAMP_1 + dtcm;
         end;
      else my_ci_stamp = TEMPLATE_CI_STAMP_1 + clock ();

      if effective_integrity_switches.record_time_modified
      then ci.header.stamp = my_ci_stamp;

      do my_part_idx = 1 to my_ci_parts.number_of_parts;
         part_length = my_ci_parts.part (my_part_idx).length_in_bytes;
         part_offset = my_ci_parts.part (my_part_idx).offset_in_bytes;
         part_ptr = my_part_ptrs (my_part_idx);

         substr (ci.addressable_bytes, part_offset + 1, part_length) = part_buffer;
      end;

      if effective_integrity_switches.record_time_modified
      then ci.trailer.stamp = my_ci_stamp;

      if effective_integrity_switches.transaction
      then call TXN_REMEMBER_MOD_PAGE;

      if effective_integrity_switches.aj
      then
         do;
         end;

      unspec (my_ci_parts) = ""b;
      my_part_ptrs (*) = null ();
      my_part_idx = 0;
   end PUT_MY_PARTS;
%page;
postcommit_increment:
   entry (p_file_oid, p_ci_num, p_increment_info_ptr, p_code);

      call INIT;
      my_file_oid = p_file_oid;
      ci_num = p_ci_num;
      file_access_info_ptr = addr (my_file_access_info);
      call GET_ACCESS_INFO (my_file_oid, NOT_FOR_UNPUT, file_access_info_ptr);
      call CHECK_RING_ACCESS ((file_access_info.ring_brackets.write));
      call GET_INTEGRITY_SWITCHES (VANILLA_WRITE_INTEGRITY_SWITCHES, (file_access_info.integrity_switches),
	 effective_integrity_switches);
      call GET_TRANSACTION_INFO (effective_integrity_switches.transaction, transaction_id, transaction_index);

      if file_access_info.opens = 0
      then call RETURN (dm_error_$bad_file_oid);

      if ci_num < 0 | ci_num > MAX_CI_NUM
      then call RETURN (dm_error_$ci_num_oob);

      if effective_integrity_switches.bj
      then
         do;
	  on transaction_bj_full_ goto TRANSACTION_BJ_FULL_HANDLER;
	  fm_increment_info_ptr = p_increment_info_ptr;
	  if fm_increment_info.version ^= FM_INCREMENT_INFO_VERSION_1
	  then call RETURN (dm_error_$fm_bad_inc_info_ver);
	  my_postcommit_info.header.version = POSTCOMMIT_INFO_VERSION_1;
	  my_postcommit_info.header.operation = INCREMENT_POSTCOMMIT_OPERATION;
	  my_postcommit_info.increments_ptr = fm_increment_info.increments_ptr;
	  my_postcommit_info.number_of_words = fm_increment_info.number_of_words;
	  my_postcommit_info.ci_number = p_ci_num;
	  my_postcommit_info.offset_in_bytes = fm_increment_info.offset_in_bytes;
	  my_postcommit_info.element_id = fm_increment_info.element_id;

	  code = 0;
	  call before_journal_manager_$write_fm_postcommit_handler (file_access_info.uid, my_file_oid,
	       addr (my_postcommit_info), size (my_postcommit_info) * BYTES_PER_WORD, code);
	  if code ^= 0
	  then call RETURN (code);
         end;
      else call RETURN (dm_error_$file_must_be_protected);

      call RETURN (ERROR_FREE);

/* Effective end of fm_put_$postcommit_increment */
%page;
lock_advice:
   entry (p_file_oid, p_lock_mode, p_code);

      call INIT;
      my_file_oid = p_file_oid;
      file_access_info_ptr = addr (my_file_access_info);
      call GET_ACCESS_INFO (my_file_oid, NOT_FOR_UNPUT, file_access_info_ptr);
      call GET_INTEGRITY_SWITCHES (NULL_INTEGRITY_SWITCHES, (file_access_info.integrity_switches),
	 effective_integrity_switches);
      call GET_TRANSACTION_INFO (effective_integrity_switches.transaction, transaction_id, transaction_index);

      if file_access_info.opens = 0
      then call RETURN (dm_error_$bad_file_oid);

      lock_mode = p_lock_mode;

      if ^(lock_mode = 0 | lock_mode = LOCK_MODE_S | lock_mode = LOCK_MODE_X | lock_mode = LOCK_MODE_IS
	 | lock_mode = LOCK_MODE_IX | lock_mode = LOCK_MODE_SIX)
      then call RETURN (dm_error_$lock_invalid_mode);


      file_access_info.lock_advice = lock_mode;
      file_access_info.last_transaction_id = ""b;
      file_access_table.e (addr (my_file_oid) -> file_oid.file_access_table_idx) = file_access_info;

      call RETURN (ERROR_FREE);


/* Effective end of fm_put_$lock_advice */
%page;
flush_consecutive_ci:
   entry (p_file_oid, p_first_ci, p_number_of_ci, p_code);

      call INIT;
      my_file_oid = p_file_oid;
      file_access_info_ptr = addr (my_file_access_info);
      call GET_ACCESS_INFO (my_file_oid, NOT_FOR_UNPUT, file_access_info_ptr);
      call CHECK_RING_ACCESS ((file_access_info.ring_brackets.write));
      call GET_INTEGRITY_SWITCHES (NULL_INTEGRITY_SWITCHES, (file_access_info.integrity_switches),
	 effective_integrity_switches);
      call GET_TRANSACTION_INFO (effective_integrity_switches.transaction, transaction_id, transaction_index);

      if file_access_info.opens = 0
      then call RETURN (dm_error_$bad_file_oid);

      first_ci = p_first_ci;
      n_ci = p_number_of_ci;

      call CHECK_CI_RANGE (first_ci, n_ci, last_ci);

FLUSH_CONSECUTIVE:
      begin;

         dcl     1 fc_flush_consec	aligned,
	         2 version		fixed bin,
	         2 n_segs		fixed bin,
	         2 seg		(8) like flush_consec.seg;

         unspec (fc_flush_consec) = ""b;
         fc_flush_consec.version = 1;

         do ci_num = first_ci to last_ci by file_access_info.blocking_factor;
	  component_num = divide (ci_num, file_access_info.blocking_factor, 27);

	  call GET_SEG_PTR (component_num, ci_ptr, addr (my_file_oid) -> file_oid.file_access_table_idx);

	  if ci_ptr ^= null ()
	  then
	     do;
	        fc_flush_consec.n_segs = fc_flush_consec.n_segs + 1;

	        fc_flush_consec.seg (fc_flush_consec.n_segs).segno = bin (baseno (ci_ptr), 18);

	        fc_flush_consec.seg (fc_flush_consec.n_segs).first_page =
		   max (0, first_ci - multiply (component_num, file_access_info.blocking_factor, 27));

	        fc_flush_consec.seg (fc_flush_consec.n_segs).n_pages =
		   min (file_access_info.blocking_factor - 1,
		   last_ci - multiply (component_num, file_access_info.blocking_factor, 27))
		   - fc_flush_consec.seg (fc_flush_consec.n_segs).first_page + 1;

	        if fc_flush_consec.n_segs = hbound (fc_flush_consec.seg, 1)
	        then call FLUSH;
	     end;
         end;

         if fc_flush_consec.n_segs > 0
         then call FLUSH;



FLUSH:
   proc;

      dcl	    f_callers_validation_level
			       fixed bin;

      call cu_$level_get (f_callers_validation_level);
      on cleanup call cu_$level_set (f_callers_validation_level);
      call cu_$level_set (get_ring_ ());

      call hcs_$flush_consecutive_pages (addr (fc_flush_consec), code);
      if code ^= 0
      then if code = error_table_$invalidsegno
	 then code = dm_error_$file_was_deleted;
	 else call RETURN (code);

      call cu_$level_set (f_callers_validation_level);

      unspec (fc_flush_consec) = ""b;
      fc_flush_consec.version = 1;

      if code = dm_error_$file_was_deleted
      then call RETURN (code);

      return;

   end FLUSH;


      end FLUSH_CONSECUTIVE;

      call RETURN (ERROR_FREE);


/* Effective end of fm_put_$flush_consective_ci */
%page;
flush_modified_ci:
   entry (p_transaction_id, p_transaction_index, p_code);

      call INIT;

      transaction_id = p_transaction_id;
      transaction_index = p_transaction_index;

      call TXN_FLUSH_MOD_PAGES;

      call RETURN (ERROR_FREE);

/* Effective end of fm_put_$flush_modified_ci */


adopt:
   entry (p_transaction_id, p_transaction_index, p_code);

      call INIT;

      transaction_id = p_transaction_id;
      transaction_index = p_transaction_index;

      call TXN_DISCARD_FLUSH_LIST;

      call RETURN (ERROR_FREE);

/* Effective end of fm_put_$adopt */


clear_flush_list:
   entry (p_code);

      call INIT;

      transaction_id = dm_data_$current_txn_id;
      transaction_index = dm_data_$current_txn_index;

      call TXN_CLEAR_FLUSH_LIST;

      call RETURN (ERROR_FREE);

/* Effective end of fm_put_$clear_flush_list */

discard_file_flush_list:
   entry (p_file_uid, p_code);

      call INIT;

      transaction_id = dm_data_$current_txn_id;
      transaction_index = dm_data_$current_txn_index;

      call TXN_DISCARD_FILE_FLUSH_LIST (p_file_uid);

      call RETURN (ERROR_FREE);

/* Effective end of fm_put_$discard_file_flush_list */

/* THIS IS THE END OF THE MAIN LINE CODE */
%page;
/* SUBROUTINES */


INIT:
   proc;

/* THE LOGIC OF fm_put_ DOES NOT DEPEND ON THE INITIALIZATIONS BELOW */

      ci_parts_ptr = null ();
      ci_ptr = null ();
      part_ptr = null ();

      ci_num = -1;
      code = -1;
      component_num = -1;
      first_ci = -1;
      my_ci_id = -1;
      my_ci_stamp = -1;
      n_ci = -1;
      number_of_addressable_bytes = -1;
      page_num = -1;
      part_idx = -1;
      part_length = -1;
      part_offset = -1;
      transaction_id = ""b;
      transaction_index = -1;

/* THE LOGIC OF fm_put_ DOES NOT DEPEND ON THE INITIALIZATIONS ABOVE */

   end INIT;
%page;
CHECK_CI_RANGE:
   proc (ccr_p_first_ci, ccr_p_n_ci, ccr_p_last_ci);

      dcl	    ccr_p_first_ci	       fixed bin (27) parameter;
      dcl	    ccr_p_n_ci	       fixed bin (27) parameter;
      dcl	    ccr_p_last_ci	       fixed bin (28) parameter;

      if ccr_p_first_ci < 0
      then call RETURN (dm_error_$fm_first_ci_neg);

      if ccr_p_n_ci < 0
      then call RETURN (dm_error_$fm_num_ci_neg);

      ccr_p_last_ci = ccr_p_first_ci + ccr_p_n_ci - 1;

      if ccr_p_last_ci > MAX_CI_NUM
      then call RETURN (dm_error_$ci_num_oob);
      else return;

   end CHECK_CI_RANGE;


BASIC_ALLOCATE:
   proc;
      my_ci_stamp = TEMPLATE_CI_STAMP_1 + clock ();

      addr (my_ci_id) -> ci_id.uid = file_access_info.uid;
      addr (my_ci_id) -> ci_id.size_code = SIZE_CODE_1024_WORDS;
      addr (my_ci_id) -> ci_id.num = ci_num;

      ci.header.stamp = my_ci_stamp;
      ci.header.id = my_ci_id;
      ci.trailer.stamp = my_ci_stamp;
   end BASIC_ALLOCATE;
%page;
GET_ACCESS_INFO:
   proc (gai_p_file_oid, gai_p_for_unput_operation, gai_p_file_access_info_ptr);

      dcl	    gai_p_file_oid	       bit (36) aligned;
      dcl	    gai_p_for_unput_operation
			       bit (1) aligned;
      dcl	    gai_p_file_access_info_ptr
			       ptr;

      dcl	    1 gai_my_file_oid      aligned like file_oid;

      unspec (gai_my_file_oid) = gai_p_file_oid;

      if gai_my_file_oid.file_access_table_idx < lbound (file_access_table.e, 1)
	 | gai_my_file_oid.file_access_table_idx > file_access_table.h.last_entry
      then call RETURN (dm_error_$bad_file_oid);

      file_access_info_ptr = gai_p_file_access_info_ptr;
      file_access_info = file_access_table.e (gai_my_file_oid.file_access_table_idx);

      if file_access_info.state.entry_state = FILE_ACCESS_INFO_NOT_IN_USE
      then call RETURN (dm_error_$bad_file_oid);

      if file_access_info.state.file_state ^= FILE_EXISTS
      then
         do;
	  if file_access_info.state.file_state = FILE_LOGICALLY_DELETED
	  then if gai_p_for_unput_operation
	       then /* okay */
		  ;
	       else call RETURN (dm_error_$file_doesnt_exist);
	  else call RETURN (dm_error_$file_doesnt_exist);
         end;

      if gai_my_file_oid.uid_tail ^= substr (file_access_info.uid, 19, 18)
      then call RETURN (dm_error_$bad_file_oid);

      if file_access_info.seg_0_num = ""b
      then if gai_p_for_unput_operation
	 then call RETURN (ERROR_FREE);
	 else call RETURN (dm_error_$file_doesnt_exist);

      return;


   end GET_ACCESS_INFO;
%page;
GET_INTEGRITY_SWITCHES:
   proc (gis_p_type, gis_p_file_integrity_switches, gis_p_effective_integrity_switches);

/* This subroutine determines the effective integrity switches to be
   used by this operation.  Three sets of integrity switches are taken
   into account while determing the effective switches: the switches
   in the file's attributes, the switches that are to be forced
   (currently no switches are forced), and the switches permitted by
   the current operation.
*/

      dcl	    gis_p_type	       fixed bin parameter;	/* Type of operation */
      dcl	    1 gis_p_file_integrity_switches
			       aligned like file_access_info.integrity_switches parameter;
						/* the switches in the file attributes */
      dcl	    1 gis_p_effective_integrity_switches
			       aligned like file_access_info.integrity_switches parameter;
						/* the resulting effective integrity switches */

      dcl	    1 gis_permit_integrity_switches
			       aligned like file_access_info.integrity_switches;
						/* the switches permitted by this operation */
      dcl	    1 gis_force_integrity_switches
			       aligned like file_access_info.integrity_switches;
						/* the switches that are to be forced regardless of */
						/* attributes and operation                          */
      string (gis_permit_integrity_switches) = "0"b;
      string (gis_force_integrity_switches) = "0"b;

      go to GIS_TYPE (gis_p_type);

GIS_TYPE (1):					/* Null */
      go to GIS_RETURN;
GIS_TYPE (2):					/* Vanilla write */
      gis_permit_integrity_switches.record_time_modified = "1"b;
      gis_permit_integrity_switches.transaction = "1"b;
      gis_permit_integrity_switches.lock = "1"b;
      gis_permit_integrity_switches.bj = "1"b;
      gis_permit_integrity_switches.aj = "1"b;
      go to GIS_RETURN;
GIS_TYPE (3):					/* Unput */
      gis_permit_integrity_switches.transaction = "1"b;
      gis_permit_integrity_switches.aj = "1"b;
      go to GIS_RETURN;
GIS_TYPE (4):					/* Unprotected */
      gis_permit_integrity_switches.record_time_modified = "1"b;
      go to GIS_RETURN;

GIS_RETURN:
      gis_p_effective_integrity_switches =
	 (gis_p_file_integrity_switches & gis_permit_integrity_switches) | gis_force_integrity_switches;
      return;


   end GET_INTEGRITY_SWITCHES;
%page;
GET_TRANSACTION_INFO:
   proc (gti_p_requires_transaction, gti_p_transaction_id, gti_p_transaction_index);

      dcl	    gti_p_requires_transaction
			       bit (1) parameter;
      dcl	    gti_p_transaction_id   bit (36) aligned parameter;
      dcl	    gti_p_transaction_index
			       fixed bin (17) parameter;

      if gti_p_requires_transaction
      then
         do;
	  gti_p_transaction_index = dm_data_$current_txn_index;
	  gti_p_transaction_id = dm_data_$current_txn_id;
	  if gti_p_transaction_id = ""b
	  then call RETURN (dm_error_$no_current_transaction);
         end;
      else
         do;
	  gti_p_transaction_index = -1;
	  gti_p_transaction_id = ""b;
         end;

      return;

   end GET_TRANSACTION_INFO;



CHECK_RING_ACCESS:
   proc (cra_p_write_bracket);

      dcl	    cra_p_write_bracket    fixed bin (3) uns unal parameter;

      dcl	    cra_caller_validation_level
			       fixed bin;

      call cu_$level_get (cra_caller_validation_level);

      if cra_caller_validation_level > cra_p_write_bracket
      then call RETURN (error_table_$no_w_permission);
      else return;

   end CHECK_RING_ACCESS;
%page;
LOCK_EXCLUSIVELY:
   proc (le_p_ci_num, le_p_transaction_id, le_p_file_access_table_idx);

      dcl	    le_p_ci_num	       fixed bin (27) parameter;
      dcl	    le_p_transaction_id    bit (36) aligned parameter;
      dcl	    le_p_file_access_table_idx
			       fixed bin (17) unal;
      dcl	    le_code	       fixed bin (35) init (0);

      if file_access_info.lock_advice ^= 0
      then
         do;
	  if file_access_info.last_transaction_id ^= le_p_transaction_id
	  then
	     do;
	        file_access_info.last_transaction_id = le_p_transaction_id;
	        file_access_table.e (le_p_file_access_table_idx) = file_access_info;

	        call lock_manager_$lock (file_access_info.uid, LOCK_ENTIRE_FILE, (file_access_info.lock_advice),
		   LOCK_WAIT_TIME, (0), le_code);
	        if le_code ^= 0
	        then call RETURN (le_code);
	     end;
         end;

      if ^(file_access_info.lock_advice = LOCK_MODE_X)
      then
         do;
	  call lock_manager_$lock (file_access_info.uid, le_p_ci_num, LOCK_MODE_X, LOCK_WAIT_TIME, (0), le_code);
	  if le_code ^= 0
	  then call RETURN (le_code);
         end;

      return;

   end LOCK_EXCLUSIVELY;
%page;
TXN_FLUSH_MOD_PAGES:
   proc;

      if proc_txn_tbl.h.version ^= PROC_TXN_TBL_VERSION_2
      then call RETURN (dm_error_$fm_bad_proc_txn_tbl_ver);

      proc_txn_ptr = addr (proc_txn_tbl.e (1));

      if proc_txn.tid = ""b
      then return;

      if transaction_id ^= proc_txn.tid
      then call RETURN (dm_error_$fm_old_txn_not_flushed);

      proc_txn.flush_bj_first = "0"b;

      call FLUSH_MOD_PAGES;

      return;


TXN_CLEAR_FLUSH_LIST:
   entry;
      if proc_txn_tbl.h.version ^= PROC_TXN_TBL_VERSION_2
      then call RETURN (dm_error_$fm_bad_proc_txn_tbl_ver);

      proc_txn_ptr = addr (proc_txn_tbl.e (1));

      if proc_txn.tid = ""b
      then return;

      if transaction_id ^= proc_txn.tid
      then call RETURN (dm_error_$fm_old_txn_not_flushed);

      call FLUSH_MOD_PAGES;

      return;


TXN_DISCARD_FLUSH_LIST:
   entry;
      if proc_txn_tbl.h.version ^= PROC_TXN_TBL_VERSION_2
      then call RETURN (dm_error_$fm_bad_proc_txn_tbl_ver);

      proc_txn_ptr = addr (proc_txn_tbl.e (1));

      unspec (proc_txn) = ""b;

      return;

TXN_DISCARD_FILE_FLUSH_LIST:
   entry (txn_discard_file_uid);
      if proc_txn_tbl.h.version ^= PROC_TXN_TBL_VERSION_2
      then call RETURN (dm_error_$fm_bad_proc_txn_tbl_ver);

      proc_txn_ptr = addr (proc_txn_tbl.e (1));

      do txn_discard_idx = lbound (proc_txn.mod_pages, 1) to proc_txn.last_entry
	 while (proc_txn.file_uids (txn_discard_idx) ^= txn_discard_file_uid);
      end;
      txn_discard_delta = 0;
      do txn_discard_idx = txn_discard_idx to proc_txn.last_entry;
         if proc_txn.file_uids (txn_discard_idx) = txn_discard_file_uid
         then txn_discard_delta = txn_discard_delta + 1;
         else
	  do;
	     proc_txn.file_uids (txn_discard_idx - txn_discard_delta) = proc_txn.file_uids (txn_discard_idx);
	     proc_txn.mod_pages (txn_discard_idx - txn_discard_delta) = proc_txn.mod_pages (txn_discard_idx);
	  end;
      end;
      do txn_discard_idx = proc_txn.last_entry by -1 to proc_txn.last_entry - txn_discard_delta + 1;
         proc_txn.mod_pages (txn_discard_idx) = 0;
         proc_txn.file_uids (txn_discard_idx) = ""b;
      end;
      proc_txn.last_entry = proc_txn.last_entry - txn_discard_delta;

      return;

TXN_DONT_FLUSH_BJ:
   entry;

      proc_txn_ptr = addr (proc_txn_tbl.e (1));

      if proc_txn.tid = ""b
      then return;

      if transaction_id ^= proc_txn.tid
      then call RETURN (dm_error_$fm_old_txn_not_flushed);

      proc_txn.flush_bj_first = "0"b;

      return;



TXN_REMEMBER_MOD_PAGE:
   entry;

/*   DESCRIPTION of TXN_FLUSH_MOD_PAGES$TXN_REMEMBER_MOD_PAGE

          This entry in TXN_FLUSH_MOD_PAGES manages the insertion of a
     modified page in proc_txn.mod_pages, the list of pages modified by a
     transaction.  Before the transaction can commit or abort, these pages
     must be flushed to disk.  As a process can have only one transaction in
     progress, there is only one entry in proc_txn_tbl (per-process
     transaction table).

          Each entry in proc_txn.mod_pages is a segment number and page
     number, and has a corresponding file uid in proc_txn.file_uids.  mod_pages
     is kept as a sorted list and is searched via a binary search.  */


      proc_txn_ptr = addr (proc_txn_tbl.e (1));

      if proc_txn.tid = NO_TRANSACTION
      then
         do;
	  proc_txn.version = 1;
	  proc_txn.tid = transaction_id;
         end;
      else if transaction_id ^= proc_txn.tid
      then call RETURN (dm_error_$fm_old_txn_not_flushed);

      txn_remember_mod_page_breakout.segment_number = baseno (ci_ptr);
      txn_remember_mod_page_breakout.page_number = page_num;
      unspec (txn_remember_mod_page) = unspec (txn_remember_mod_page_breakout);

      txn_remember_low_idx = 0;
      txn_remember_high_idx = proc_txn.last_entry + 1;
      txn_remember_delta = txn_remember_high_idx - txn_remember_low_idx;
      if txn_remember_delta = 1
      then txn_remember_current_idx = txn_remember_high_idx;
      else
         do;
	  do while (txn_remember_delta > 1);
	     txn_remember_current_idx = divide (txn_remember_delta, 2, 17, 0) + txn_remember_low_idx;
	     if txn_remember_mod_page = proc_txn.mod_pages (txn_remember_current_idx)
	     then return /* already here, nothing to do */;
	     if txn_remember_mod_page < proc_txn.mod_pages (txn_remember_current_idx)
	     then txn_remember_high_idx = txn_remember_current_idx;
	     else txn_remember_low_idx = txn_remember_current_idx;
	     txn_remember_delta = txn_remember_high_idx - txn_remember_low_idx;
	  end;
	  txn_remember_current_idx = txn_remember_high_idx;
	  if proc_txn.last_entry >= hbound (proc_txn.mod_pages, 1)
	  then
	     do;
	        call FLUSH_MOD_PAGES ();		/* Resets proc_txn to ""b */
	        proc_txn.version = 1;
	        proc_txn.tid = transaction_id;
	        txn_remember_current_idx = 1;
	     end;
         end;
      do txn_remember_shift_idx = proc_txn.last_entry by -1 to txn_remember_current_idx;
         proc_txn.mod_pages (txn_remember_shift_idx + 1) = proc_txn.mod_pages (txn_remember_shift_idx);
         proc_txn.file_uids (txn_remember_shift_idx + 1) = proc_txn.file_uids (txn_remember_shift_idx);
      end;
      proc_txn.last_entry = proc_txn.last_entry + 1;
      proc_txn.mod_pages (txn_remember_current_idx) = txn_remember_mod_page;
      proc_txn.file_uids (txn_remember_current_idx) = file_access_info.uid;
      if effective_integrity_switches.bj
      then proc_txn.flush_bj_first = "1"b;

      return;

TXN_INIT_PROC_DATA:
   entry;

      allocate proc_txn_tbl;

      unspec (proc_txn_tbl) = ""b;
      proc_txn_tbl.h.version = PROC_TXN_TBL_VERSION_2;

      begin;
         call cu_$level_get (callers_validation_level);
         on cleanup call cu_$level_set (callers_validation_level);
         call cu_$level_set (get_ring_ ());

         code = 0;
         call dm_hcs_$set_force_write_limit (10, code);
         if code ^= 0
         then call RETURN (code);

         call cu_$level_set (callers_validation_level);

         dcl     callers_validation_level
				fixed bin;

      end;

      return;


FLUSH_MOD_PAGES:
   proc;

      proc_txn.n_pages = proc_txn.last_entry;

      if proc_txn.n_pages > 0
      then
         do;
	  if proc_txn.flush_bj_first
	  then
	     do;
	        call before_journal_manager_$flush_transaction (transaction_id, transaction_index, code);
	        if code ^= 0
	        then call RETURN (code);
	     end;

	  call cu_$level_get (callers_validation_level);
	  on cleanup call cu_$level_set (callers_validation_level);
	  call cu_$level_set (get_ring_ ());

	  call hcs_$flush_pages (addr (proc_txn.version), code);
	  if code ^= 0
	  then if code = error_table_$invalidsegno
	       then code = dm_error_$file_was_deleted;
	       else call RETURN (code);

	  call cu_$level_set (callers_validation_level);
         end;

      unspec (proc_txn) = ""b;

      if code = dm_error_$file_was_deleted
      then if operation_is_unput
	 then code = 0 /* For unput - deleted file is not unexpected */;
	 else call RETURN (code);

      return;

      dcl	    callers_validation_level
			       fixed bin;

   end FLUSH_MOD_PAGES;

/* Declarations for TXN_FLUSH_MOD_PAGES entries */

      dcl	    (
	    txn_discard_file_uid   bit (36) aligned,
	    txn_discard_delta      fixed bin,
	    txn_discard_idx	       fixed bin
	    );
      dcl	    (
	    txn_remember_low_idx   fixed bin,
	    txn_remember_high_idx  fixed bin,
	    txn_remember_current_idx
			       fixed bin,
	    txn_remember_delta     fixed bin,
	    txn_remember_shift_idx fixed bin,
	    txn_remember_mod_page  fixed bin (33)
	    );
      dcl	    1 txn_remember_mod_page_breakout
			       aligned,
	      2 segment_number     bit (18) unal,
	      2 page_number	       fixed bin unal;

      dcl	    proc_txn_ptr	       ptr;
      dcl	    1 proc_txn	       aligned based (proc_txn_ptr),
	      2 tid	       bit (36),
	      2 flush_bj_first     bit,
	      2 last_entry	       fixed bin,
	      2 mbz	       fixed bin,
	      2 version	       fixed bin,
	      2 n_pages	       fixed bin,
	      2 mod_pages	       (250) fixed bin (33),
	      2 file_uids	       (250) bit (36) aligned;

      dcl	    fm_data_$proc_txn_tbl_ptr
			       ptr ext;
      dcl	    1 proc_txn_tbl	       aligned based (fm_data_$proc_txn_tbl_ptr),
	      2 h,
	        3 version	       char (8) aligned,
	        3 mbz	       fixed bin (71),
	      2 e		       (1) like proc_txn;

      dcl	    PROC_TXN_TBL_VERSION_2 char (8) aligned static options (constant) init ("FM-PTT 2");


   end TXN_FLUSH_MOD_PAGES;
%page;
/* Make_seg means if you can't get a pointer, don't come back. */

MAKE_SEG_PTR:
   proc (msp_p_component_num, msp_p_ci_ptr, msp_p_file_access_table_idx, msp_p_bj_on);



      dcl	    msp_p_component_num    fixed bin parameter;
      dcl	    msp_p_ci_ptr	       ptr parameter;
      dcl	    msp_p_file_access_table_idx
			       fixed bin (17) unal parameter;
      dcl	    msp_p_bj_on	       bit (1) parameter;

      dcl	    msp_make_seg	       bit (1) aligned;
      dcl	    msp_code	       init (0) fixed bin (35);

      msp_make_seg = "1"b;
      go to MSP_JOIN;

GET_SEG_PTR:
   entry (msp_p_component_num, msp_p_ci_ptr, msp_p_file_access_table_idx);

      msp_make_seg = "0"b;
      go to MSP_JOIN;

MSP_JOIN:
      if msp_p_component_num = 0
      then
         do;
	  msp_p_ci_ptr = baseptr (file_access_info.seg_0_num);
	  return;
         end;
      else if msp_p_component_num <= hbound (file_access_info.seg_nums, 1)
      then
         do;
	  if file_access_info.seg_nums (msp_p_component_num) ^= 0
	  then
	     do;
	        msp_p_ci_ptr = baseptr (file_access_info.seg_nums (msp_p_component_num));
	        return;
	     end;
         end;

CALL_RING_0:
      begin;

         dcl     msp_dir_name		char (168);
         dcl     msp_entry_name	char (32);
         dcl     msp_callers_validation_level
				fixed bin;

         call cu_$level_get (msp_callers_validation_level);
         on cleanup call cu_$level_set (msp_callers_validation_level);
         call cu_$level_set (get_ring_ ());

         call msf_manager_$msf_get_ptr ((file_access_info.msf_ptr), msp_p_component_num, "0"b, msp_p_ci_ptr, (0),
	    msp_code);

         if msp_p_ci_ptr = null ()
         then
	  do;
	     if msp_code ^= error_table_$noentry
	     then call RETURN (msp_code);

	     if msp_make_seg
	     then
	        do;
		 call msf_manager_$msf_get_ptr ((file_access_info.msf_ptr), msp_p_component_num, "1"b, msp_p_ci_ptr,
		      (0), msp_code);
		 if msp_p_ci_ptr = null ()
		 then call RETURN (msp_code);

		 if msp_p_bj_on
		 then
		    do;
		       call hcs_$fs_get_path_name (msp_p_ci_ptr, msp_dir_name, (0), msp_entry_name, msp_code);
		       if msp_code ^= 0
		       then call RETURN (msp_code);

		       call hcs_$set_synchronized_sw (msp_dir_name, msp_entry_name, "1"b, msp_code);
		       if msp_code ^= 0
		       then
			do;
			   if msp_code = error_table_$not_dm_ring & sys_info$data_management_ringno ^= get_ring_ ()
			   then msp_code = 0;
			   else call RETURN (msp_code);
			end;
		    end;
	        end;
	  end;

         call cu_$level_set (msp_callers_validation_level);


      end CALL_RING_0;

      if msp_p_ci_ptr ^= null () & msp_p_component_num <= hbound (file_access_info.seg_nums, 1)
      then
         do;
	  file_access_info.seg_nums (msp_p_component_num) = bin (baseno (msp_p_ci_ptr), 18);
	  file_access_table.e (msp_p_file_access_table_idx) = file_access_info;
         end;

      return;

   end MAKE_SEG_PTR;
%page;
%include dm_ci;
%page;
%include dm_ci_header;
%page;
%include dm_ci_lengths;

%include dm_ci_constants;
%page;
%include dm_ci_parts;
%page;
%include dm_lock_modes;
%page;
%include dm_fm_file_oid;
%page;
%include dm_fm_file_access_info;
%page;
%include dm_fm_file_access_tbl;
%page;
%include dm_fm_increment_info;
%page;
%include dm_fm_postcommit_info;
%page;
%include flush_structures;
%page;
%include condition_info_header;

   end fm_put_$init_txn_tbl;
