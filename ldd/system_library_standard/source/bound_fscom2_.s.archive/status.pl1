/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(87-02-17,TLNguyen), approve(87-02-17,MCR7622),
     audit(87-02-25,Gilcrease), install(87-03-23,MR12.1-1008):
     - Make "status" active function returns the current length when the
       "-length" control argument is specified.
     - Add the "-nonstandard_names" (-nsn) control argument to the status
       command or active function.
  2) change(87-02-24,TLNguyen), approve(87-02-24,MCR7620),
     audit(87-02-25,Gilcrease), install(87-03-23,MR12.1-1008):
     - Change "status" command to always display an appropriate error message
       if "-chase" control argument is specified and the entry is a null link.
     - Change "status" command to always skip printing an error message if the
       code received from "file_manager_$status" is "A transaction is currently
       in progress."
     - Change "status" to always display an error message if specified paths
       are directories, MSFs, DM files, and links and the "-synchronized_
       switch" is specified.
     - Change "status" to always call "msf_manager_$close" when it finishes for
       an MSF and to always call "cleanup" internal procedure when it finishes.
     - Change "status" to always not display a specified MSF's contents which
       appeared at the end of the error message.
  3) change(87-03-25,TLNguyen), approve(87-03-25,MCR7620),
     audit(87-03-25,Gilcrease), install(87-03-25,MR12.1-1015):
               PBF to last installation, status with no arguments ok now.
  4) change(87-09-04,TLNguyen), approve(87-09-04,PBF7620),
     audit(87-09-04,Farley), install(87-09-09,MR12.1-1099):
     status with MSFs and -all control argument work ok now.
  5) change(88-01-29,TLNguyen), approve(88-01-29,MCR7833),
     audit(88-02-02,Lippard), install(88-02-02,MR12.2-1020):
     Make status with -length work as documented when it is used as a command.
  6) change(88-05-12,Lippard), approve(88-05-02,MCR7881),
     audit(88-06-09,Fawcett), install(88-08-02,MR12.2-1074):
     Add -audit_switch, -asw.
  7) change(89-04-06,Vu), approve(89-04-06,MCR8096), audit(89-04-26,Lee),
     install(89-05-10,MR12.3-1040):
     status -switch SW_NAME yields bogus error for link and the date returned
     by status for the root does not use the user's default date/time format.
     Reformatted status.pl1
                                                   END HISTORY COMMENTS */



/* format: style4,ifthenstmt,^indproc */

status: st: procedure options (variable);

/* WARNING: Some hcs_ entries are mis-declared with char (*) aligned */

/* This command and active function returns selected
   attributes of storage system entries. */

/* Written 5/20/76 by Steve Herbst */
/* Control args -dr, -lk, -sm added and [st -nm] names quoted 09/28/79 S. Herbst */
/* Changed to print damaged switch (if on) by default 03/19/80 S. Herbst */
/* Fix dates reported for MSF's (most recent date of all components) 01/06/81 S. Herbst */
/* Chasing fixed, -chase_if_possible added, -records_used -> -records 01/12/81 S. Herbst */
/* Fixed bug in MSF processing 10/01/81 S. Herbst */
/* fixed not to assume 168 char link pathname BIM 3/82 */
/* Added printing of synchronized switch, J. Bongiovanni, September 1982 */
/* Fixed to handle et_$vtoce_connection_fail like et_$logical_volume_not_connected 11/23/82 S. Herbst */
/* Changed back again to treat VTOCE errors as errors, since no info can be trusted. 12/07/82 S. Herbst */
/* Simple support for object_type_ 2/24/83 Jay Pattin */
/* Added entry_bound, -switch, changed behavior of -all w/switches 6/2/83 Jay Pattin */
/* 830924 object_type_ --> fs_util_, BIM */
/* Modified 11/21/83 by C Spitzer. fix lots of bugs */
/* Fixed to not free switch_list when switch_list_ptr is null, 1984.02.16, MAP */
/* Modified 07/18/84 by Jim Lippard to only allocate names when they're
   asked for and to free them properly */
/* Modified 84-09-17 by JAFalksen. Utilize date_time_$format("date_time",... */
/* Modified 01/11/84 by C Spitzer. work on root (changes adapted by Steve Herbst) */
/* Changed to work on DM files 10/23/84 Steve Herbst */
/* Added extended entry type control args -select_entry_type, changed -force_no_type to -inase 11/20/84 M. Pandolf */
/* Changed -no_(concurrency rollback)_sw to -(concurrency rollback)_sw 12/04/84 Steve Herbst */
/* Fixed mode value for DM files 01/11/85 Steve Herbst */
/* Modified 02/05/85 by M. Sharpe to implement -slet correctly and to complain
   about unsupported operation when type does not have ring brackets, extended
   mode, max length, etc. */
/* Fixed to print DM file switches without a transaction in effect 02/26/85 Steve Herbst */


/* DECLARATIONS */

/* Options structure. Various settings for it are at the back of the listing. */

dcl  1 opt,					/* attributes to be requested */
       (2 primary_name,				/* -primary, -pri */
       2 names,					/* -name, -names, -nm */
       2 type,					/* -type, -tp */
       2 link_path,					/* -link_path, -lp */
       2 unique_id,					/* -unique_id, -uid */
       2 dtu,					/* -date_time_used, -dtu */
       2 dtcm,					/* -date_time_contents_modified, -dtcm */
       2 dtem,					/* -date_time_entry_modified, -dtem */
       2 dtd,					/* -date_time_dumped, -dtd */
       2 dtvd,					/* -date_time_volume_dumped, -dtvd */
       2 author,					/* -author, -at */
       2 bc_author,					/* -bc_author, -bca */
       2 logical_volume,				/* -logical_volume, -lv, -device, -dv */
       2 bit_count,					/* -bit_count, -bc */
       2 records_used,				/* -records, -rec */
       2 current_length,				/* -current_length, -cl */
       2 max_length,				/* -max_length, -ml */
       2 mode,					/* -mode, -md */
       2 access_class,				/* -access_class, -acc */
       2 ring_brackets,				/* -ring_brackets, -rb */
       2 safety_switch,				/* -safety_switch, -ssw */
       2 copy_switch,				/* -copy_switch, -csw */
       2 audit_switch,				/* -audit_switch, -asw */
       2 ivds,					/* -incr_volume_dump_switch, -ivds */
       2 cvds,					/* -comp_volume_dump_switch , -cvds */
       2 usage_count,				/* -usage_count, -use */
       2 damaged_switch,				/* -damaged_switch, -dsw */
       2 synchronized_switch,				/* -synchronized_switch, -synch */
       2 entry_bound				/* -entry_bound, -eb */
       ) bit (1) unaligned,
       2 dm_files_only,
         (3 highest_ci,				/* -highest_control_interval, -hci */
         3 concurrency_switch,			/* -concurrency_sw, -concsw */
         3 rollback_switch,				/* -rollback_sw, -rlbsw */
         3 protected_switch				/* -protected_sw, -psw */
         ) bit (1) unaligned;


dcl  1 explicit_opt like opt;				/* attributes explicitly requested */

dcl  1 saved_options like opt;			/* saved copy of opt */

dcl  ALL_OPTIONS bit (33) aligned int static options (constant) init ((33)"1"b); /* for -all */

dcl  LONG_OPTION (33) char (64) int static options (constant) init
	("-primary", "-name", "-type", "-link_path", "-unique_id",
	"-date_time_used", "-date_time_contents_modified", "-date_time_entry_modified",
	"-date_time_dumped", "-date_time_volume_dumped", "-author", "-bc_author",
	"-logical_volume", "-bit_count", "-records", "-current_length", "-max_length",
	"-mode", "-access_class", "-ring_brackets", "-safety_switch", "-copy_switch",
	"-audit_switch", "-incr_volume_dump_switch", "-comp_volume_dump_switch", "-usage_count",
	"-damaged_switch", "-synchronized_switch", "-entry_bound",
						/* (DM file options:) */
	"-highest_control_interval", "-concurrency_sw", "-rollback_sw", "-protected_sw");

dcl  SHORT_OPTION (33) char (8) int static options (constant) init
	("-pri", "-nm", "-tp", "-lp", "-uid",
	"-dtu", "-dtcm", "-dtem", "-dtd", "-dtvd", "-at", "-bca",
	"-lv", "-bc", "-rec", "-cl", "-ml",
	"-md", "-acc", "-rb", "-ssw", "-csw", "-asw",
	"-ivds", "-cvds", "-use",
	"-dsw", "-synch", "-eb",
	"-hci", "-concsw", "-rlbsw", "-psw");


dcl  1 bks aligned like status_for_backup;

dcl  1 link_status aligned based (addr (branch_status)),	/* status for link entries */
       2 type bit (2) unaligned,
       2 nnames bit (16) unaligned,
       2 nrp bit (18) unaligned,
       2 dtlm bit (36) unaligned,
       2 dtd bit (36) unaligned,
       2 pnl fixed bin (18) uns unaligned,
       2 pnrp bit (18) unaligned;

dcl  1 msf_info aligned,				/* status for MSF components */
       2 type bit (2) unaligned,
       2 nnames bit (16) unaligned,
       2 names_offset bit (18) unaligned,
       2 dtcm bit (36) unaligned,
       2 dtu bit (36) unaligned,
       2 mode bit (5) unaligned,
       2 pad bit (13) unaligned,
       2 records fixed bin (17) unaligned,
       2 dtd bit (36) unaligned,
       2 dtem bit (36) unaligned,
       2 pad3 bit (36) unaligned,
       2 current_length fixed bin (11) unaligned,
       2 bit_count bit (24) unaligned,
       2 pad2 bit (18) unaligned,
       2 rbs (0:2) fixed bin (5) unaligned,
       2 pad4 bit (36) unaligned;

dcl  branch_names (0:99) char (32) based (branch_names_ptr);/* names from hcs_$status_long */

dcl  ROOT_NAMES (1) char (32) int static options (constant) init (">");

dcl  1 si aligned like suffix_info;

dcl  1 auto_dm_file_status aligned like dm_file_status;

dcl  1 path_array (path_array_size) aligned based (path_array_ptr),
       2 path_ptr ptr,
       2 path_len fixed bin,
       2 nonstandard_names_flag bit (1) aligned;
dcl  1 slet_path_array (slet_path_array_size) aligned based (slet_path_array_ptr) like path_array;
dcl  1 path_array_space (25) like path_array;

dcl  dates_array (5) bit (36);

dcl  1 combined_options,
       (2 access,					/* -access */
       2 all,					/* -all */
       2 dates,					/* -date */
       2 lengths					/* -length */
       ) bit (1) unaligned;

dcl  1 fs_entry_type aligned based (fs_entry_type_ptr),
       2 count fixed bin,
       2 suffix char (32) unaligned dim (fs_entry_type_count refer (fs_entry_type.count));

dcl  1 fs_time_value aligned based,
       2 pad1 bit (20) unal,
       2 time bit (36) unal,
       2 pad2 bit (16) unal;

dcl  temp_clock fixed bin (71);
dcl  stime bit (36);
dcl  switch_names (10) char (32);			/* for -switch */
dcl  mode_bits (5) bit (1) unaligned;
dcl  ring_brackets (8) fixed bin (3);

/* Constants */

dcl  ME char (32) int static options (constant) init ("status");
dcl  INITIALIZER_ID char (32) int static options (constant) init ("Initializer.SysDaemon.z");
dcl  EXTENDED_type fixed bin int static options (constant) init (5);
dcl  (CHASE init (1), NO_CHASE init (0)) fixed bin int static options (constant);

/* Based */

dcl  area area based (area_ptr);
dcl  arg char (arg_len) based (arg_ptr);
dcl  return_string char (return_len) varying based (return_ptr);
dcl  slet_path char (slet_path_len) based (slet_path_ptr);
dcl  target_path char (target_len) based (target_ptr);

/* Automatic */

dcl  slet_area area;

dcl  date_string char (64) varying;
dcl  mode_string char (36) varying;

dcl  (class, temp_string) char (336);			/* ASCII access class */
dcl  (dn, msf_path, saved_dn, target_dn) char (168);
dcl  (author_string, bc_author_string, comp_name, en, fs_type, fs_util_type) char (32);
dcl  (lv_string, saved_en, star_en, target_en) char (32);
dcl  type_string char (32);				/* avoid string size condition while compiling. */

dcl  access_class bit (72) aligned;
dcl  (exmodes, local_unique_id, modes) bit (36) aligned;
dcl  (bc36, msf_dtcm, msf_dtd, msf_dtem, msf_dtu) bit (36);
dcl  switch_mask bit (10) aligned;
dcl  (active_function, chase, chase_if_possible, chased, dir_sw, dm_file_sw, interpret_as_standard_entry) bit (1) aligned;
dcl  (link_sw, matched, msf, msf_error, one_item, printed_pathname, printed_something) bit (1) aligned;
dcl  (root_sw, safety_switch, seg_sw, selecting_by_entry_type, star_sw) bit (1) aligned;

dcl  (area_ptr, arg_ptr, branch_names_ptr, comp_ptr, fs_entry_type_ptr, msf_ptr) ptr;
dcl  (path_array_ptr, return_ptr, slet_path_array_ptr, slet_path_ptr, target_ptr) ptr;

dcl  status_chase fixed bin (1);
dcl  entry_type fixed bin (3);
dcl  (arg_count, arg_len, class_len, cvds, entry_type_index, extended_type_count, fs_entry_type_count, i, ivds) fixed bin;
dcl  (j, k, kk, path_array_size, path_count, return_len, slet_path_array_size, slet_path_len) fixed bin;
dcl  (switch_count, switch_length, target_len, total_length, total_records) fixed bin;
dcl  max_length fixed bin (19);
dcl  total_bit_count fixed bin (24);
dcl  (bc35, code, usage_count) fixed bin (35);

/* External */

dcl  dm_error_$transaction_in_progress fixed bin (35) ext;
dcl  error_table_$badopt fixed bin (35) ext;
dcl  error_table_$inconsistent fixed bin (35) ext;
dcl  error_table_$incorrect_access fixed bin (35) ext;
dcl  error_table_$logical_volume_not_connected fixed bin (35) ext;
dcl  error_table_$logical_volume_not_defined fixed bin (35) ext;
dcl  error_table_$moderr fixed bin (35) ext;
dcl  error_table_$no_s_permission fixed bin (35) ext;
dcl  error_table_$noarg fixed bin (35) ext;
dcl  error_table_$noentry fixed bin (35) ext;
dcl  error_table_$nomatch fixed bin (35) ext;
dcl  error_table_$not_act_fnc fixed bin (35) ext;
dcl  error_table_$root fixed bin (35) ext;
dcl  error_table_$segknown fixed bin (35) ext;
dcl  error_table_$unsupported_operation fixed bin (35) ext;

/* Entries */

dcl  complain entry variable options (variable);

dcl  active_fnc_err_ entry options (variable);
dcl  check_star_name_$entry entry (char (*), fixed bin (35));
dcl  com_err_ entry options (variable);
dcl  convert_authorization_$to_string_short entry (bit (72) aligned, char (*), fixed bin (35));
dcl  cu_$af_return_arg entry (fixed bin, ptr, fixed bin, fixed bin (35));
dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
dcl  expand_path_ entry (ptr, fixed bin, ptr, ptr, fixed bin (35));
dcl  expand_pathname_$add_suffix entry (char (*), char (*), char (*), char (*), fixed bin (35));
dcl  get_group_id_ entry () returns (char (32));
dcl  get_system_free_area_ entry returns (ptr);
dcl  get_wdir_ entry returns (char (168));
dcl  file_manager_$status entry (char (*), char (*), ptr, fixed bin (35));
dcl  fs_util_$get_type entry (char (*), char (*), char (*), fixed bin (35));
dcl  fs_util_$get_max_length entry (char (*), char (*), fixed bin (19), fixed bin (35));
dcl  fs_util_$get_ring_brackets entry (char (*), char (*), (*) fixed bin (3), fixed bin (35));
dcl  fs_util_$get_switch entry (char (*), char (*), char (*), bit (1) aligned, fixed bin (35));
dcl  fs_util_$get_user_access_modes entry (char (*), char (*), char (*), fixed bin, bit (36) aligned,
	bit (36) aligned, fixed bin (35));
dcl  fs_util_$list_switches_for_type entry (char (*), char (*), ptr, ptr, fixed bin (35));
dcl  fs_util_$suffix_info_for_type entry (char (*), ptr, fixed bin (35));
dcl  hcs_$get_access_class entry (char (*), char (*), bit (72) aligned, fixed bin (35));
dcl  hcs_$get_dates entry (char (*), char (*), (5) bit (36), fixed bin (35));
dcl  hcs_$get_author entry (char (*), char (*), fixed bin, char (*), fixed bin (35));
dcl  hcs_$get_bc_author entry (char (*), char (*), char (*), fixed bin (35));
dcl  hcs_$get_link_target entry (char (*), char (*), char (*), char (*), fixed bin (35));
dcl  hcs_$get_max_length entry (char (*), char (*), fixed bin (19), fixed bin (35));
dcl  hcs_$get_safety_sw entry (char (*), char (*), bit (1) aligned, fixed bin (35));
dcl  hcs_$get_volume_dump_switches entry (char (*), char (*), fixed bin, fixed bin, fixed bin (35));
dcl  hcs_$star_dir_list_ entry (char (*), char (*), fixed bin (3), ptr, fixed bin, fixed bin, ptr, ptr, fixed bin (35));
dcl  hcs_$status_for_backup entry (char (*), char (*), ptr, fixed bin (35));
dcl  hcs_$status_long entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35));
dcl  ioa_ entry options (variable);
dcl  ioa_$nnl entry options (variable);
dcl  ioa_$rsnnl entry options (variable);
dcl  mdc_$find_lvname entry (bit (36), char (*), fixed bin (35));
dcl  mhcs_$get_seg_usage entry (char (*), char (*), fixed bin (35), fixed bin (35));
dcl  msf_manager_$close entry (ptr);
dcl  msf_manager_$get_ptr entry (ptr, fixed bin, bit (1), ptr, fixed bin (24), fixed bin (35));
dcl  msf_manager_$open entry (char (*), char (*), ptr, fixed bin (35));
dcl  pathname_ entry (char (*), char (*)) returns (char (168));
dcl  requote_string_ entry (char (*)) returns (char (*));

/* Builtins */

dcl  (addr, after, before, bin, binary, clock, convert, divide, fixed, hbound, index, null) builtin;
dcl  (length, max, ptr, reverse, rtrim, string, substr, unspec, verify, empty) builtin;

/* Conditions */

dcl  (cleanup, linkage_error) condition;

/* END OF DECLARATIONS */
%page;
	call cu_$af_return_arg (arg_count, return_ptr, return_len, code);
	if code = error_table_$not_act_fnc then do;
	     active_function = "0"b;
	     complain = com_err_;
	end;
	else do;
	     active_function = "1"b;
	     complain = active_fnc_err_;
	end;

	code = 0;					/* must reset code to 0 */
	string (opt) = "0"b;
	string (combined_options) = "0"b;
	chase, chase_if_possible, dir_sw, dm_file_sw, interpret_as_standard_entry, link_sw, root_sw, seg_sw = "0"b;
	area_ptr = get_system_free_area_ ();

	path_array_ptr = addr (path_array_space);
	fs_entry_type_ptr, star_list_branch_ptr, star_list_names_ptr = null;
	selecting_by_entry_type = ""b;

	on cleanup call CLEAN_UP ();

	path_array_size = arg_count;
	if path_array_size > hbound (path_array_space, 1) then
	     allocate path_array in (area) set (path_array_ptr);

	path_count, switch_count = 0;
	switch_length = 13;

	do i = 1 to arg_count;

	     call cu_$arg_ptr (i, arg_ptr, arg_len, code);

	     if substr (arg, 1, 1) ^= "-" then do;
		path_count = path_count + 1;
		path_array.path_ptr (path_count) = arg_ptr;
		path_array.path_len (path_count) = arg_len;
		path_array.nonstandard_names_flag (path_count) = "0"b;
	     end;

	     else if arg = "-working_dir" | arg = "-wd" then do;
		path_count = path_count + 1;
		path_array.path_len (path_count) = 0;	/* use expand_path_'s working dir feature */
		path_array.nonstandard_names_flag (path_count) = "0"b;
	     end;

	     else if arg = "-chase" then chase = "1"b;
	     else if arg = "-no_chase" then chase = "0"b;
	     else if arg = "-chase_if_possible" | arg = "-cip" then chase_if_possible = "1"b;
	     else if arg = "-no_chase_if_possible" | arg = "-ncip" then chase_if_possible = "0"b;
	     else if arg = "-directory" | arg = "-dr" then dir_sw = "1"b;
	     else if arg = "-link" | arg = "-lk" then link_sw = "1"b;
	     else if arg = "-segment" | arg = "-sm" then seg_sw = "1"b;
	     else if arg = "-switch" then do;
		i = i + 1;
		if i > arg_count then do;
		     call complain (error_table_$noarg, ME, "Following -switch.");
		     return;
		end;
		if switch_count = 10 then do;
		     call complain (0, ME, "Only 10 switch names allowed.");
		     return;
		end;
		call cu_$arg_ptr (i, arg_ptr, arg_len, code);
		switch_count = switch_count + 1;
		switch_names (switch_count) = arg;
		switch_length = max (switch_length, arg_len);
	     end;

	     else do;
		do j = hbound (LONG_OPTION, 1) by -1 to 1
		     while (arg ^= LONG_OPTION (j) & arg ^= SHORT_OPTION (j));
		end;
		if j ^= 0 then substr (string (opt), j, 1) = "1"b;
		else if arg = "-device" | arg = "-dv" then opt.logical_volume = "1"b;
		else if arg = "-entry_type" | arg = "-ettp" then opt.type = "1"b;
		else if arg = "-interpret_as_extended_entry" | arg = "-inaee" then interpret_as_standard_entry = "0"b;
		else if arg = "-interpret_as_standard_entry" | arg = "-inase" then interpret_as_standard_entry = "1"b;
		else if arg = "-names" then opt.names = "1"b; /* synonym for -name and -nm */
		else if arg = "-nonstandard_names" | arg = "-nsn" then do;
		     i = i + 1;
		     if i > arg_count then do;
			call complain (error_table_$noarg, ME, "Need an argument for ^a.", arg);
			return;
		     end;
		     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
		     path_count = path_count + 1;
		     path_array.path_ptr (path_count) = arg_ptr;
		     path_array.path_len (path_count) = arg_len;
		     path_array.nonstandard_names_flag (path_count) = "1"b;
		end;
		else if arg = "-records_used" | arg = "-ru" then opt.records_used = "1"b; /* syn for -records */
		else if arg = "-select_entry_type" | arg = "-slet" then do;
		     i = i + 1;
		     if i > arg_count then do;
			call complain (error_table_$noarg, ME, "Following ^a", arg);
			return;
		     end;
		     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
		     call BUILD_ENTRY_TYPE_LIST (arg, fs_entry_type_ptr, selecting_by_entry_type);
		end;
		else if arg = "-length" | arg = "-lengths" | arg = "-ln" then lengths = "1"b;
		else if active_function then do;	/* not any control arg acceptable to status af */
		     call complain (0, ME,
			"Specified control argument is not implemented by this active function.   ^a", arg);
		     return;
		end;
		else if arg = "-access" | arg = "-ac" then access = "1"b;
						/* -all, -a are undocumented synonyms of -long to be retained for compatibility. */
		else if arg = "-all" | arg = "-a" | arg = "-long" | arg = "-lg" then all = "1"b;
		else if arg = "-date" | arg = "-dt" then dates = "1"b;
		else do;
		     call complain (error_table_$badopt, ME, "^a", arg);
		     return;
		end;
	     end;
	end;

/* Adjust the environment for slet processing, if any requested */

	if selecting_by_entry_type then do;

	     if link_sw | seg_sw | dir_sw then do;
		call complain (error_table_$inconsistent, ME,
		     "-select_entry_type is an alternative to -directory, -segment, or -link.");
		return;
	     end;
	     dir_sw, link_sw, seg_sw = "1"b;

	     extended_type_count = 0;
	     do entry_type_index = 1 to fs_entry_type.count;
		if substr (fs_entry_type.suffix (entry_type_index), 1, 1) ^= "-" then
		     extended_type_count = extended_type_count + 1;
	     end;

	     if extended_type_count = fs_entry_type.count then slet_path_array_size = path_count * extended_type_count;
	     else slet_path_array_size = path_count * (extended_type_count + 1);

	     if slet_path_array_size > hbound (path_array_space, 1) then
		allocate slet_path_array in (area) set (slet_path_array_ptr);
	     else slet_path_array_ptr = addr (path_array_space);

	     i = slet_path_array_size;
	     do j = path_count by -1 to 1;

		do entry_type_index = 1 to fs_entry_type.count;
		     if substr (fs_entry_type.suffix (entry_type_index), 1, 1) ^= "-" then do;
			slet_path_len = path_array.path_len (j) + 1 +
			     length (rtrim (fs_entry_type.suffix (entry_type_index)));
			allocate slet_path in (slet_area) set (slet_path_ptr);
			target_len = path_array.path_len (j);
			if ^path_array.nonstandard_names_flag (j) then
			     call expand_pathname_$add_suffix (path_array.path_ptr (j) -> target_path,
				fs_entry_type.suffix (entry_type_index), target_dn,
				slet_path_ptr -> slet_path, code);
			else do;
			     target_dn = get_wdir_ ();
			     arg_len = path_array.path_len (j);
			     arg_ptr = path_array.path_ptr (j);
			     slet_path_ptr -> slet_path = arg;
			end;
			slet_path_array.path_ptr (i) = slet_path_ptr;
			slet_path_array.path_len (i) = slet_path_len;
			i = i - 1;
		     end;
		end;
		if fs_entry_type.count > extended_type_count then do;
		     slet_path_array.path_ptr (i) = path_array.path_ptr (j);
		     slet_path_array.path_len (i) = path_array.path_len (j);
		     i = i - 1;
		end;
	     end;

	     if path_array_ptr ^= addr (path_array_space) then do;
		free path_array in (area);
		path_array_ptr = slet_path_array_ptr;
	     end;

	     path_count = slet_path_array_size;
	end;

/* Set star selection variables */

	if ^dir_sw & ^link_sw & ^seg_sw then dir_sw, link_sw, seg_sw = "1"b; /* default */

	if ^link_sw then star_select_sw = star_BRANCHES_ONLY;
	else if ^dir_sw & ^seg_sw then star_select_sw = star_LINKS_ONLY;
	else star_select_sw = star_ALL_ENTRIES;

	k = 0;
	switch_mask = ""b;
	do i = 1 to switch_count;			/* check for standards */
	     if switch_names (i) = "damaged" then opt.damaged_switch = "1"b;
	     else if switch_names (i) = "safety" then opt.safety_switch = "1"b;
	     else if switch_names (i) = "copy" then opt.copy_switch = "1"b;
	     else if switch_names (i) = "audit" then opt.audit_switch = "1"b;
	     else if switch_names (i) = "synchronized" then opt.synchronized_switch = "1"b;
	     else if switch_names (i) = "complete_volume_dump" then opt.cvds = "1"b;
	     else if switch_names (i) = "incremental_volume_dump" then opt.ivds = "1"b;
	     else substr (switch_mask, i, 1) = "1"b;

	     if ^(substr (switch_mask, i, 1)) then k = k + 1; /* was a standard switch */
	end;

	explicit_opt = opt;

	if all then string (opt) = ALL_OPTIONS;

	if access then string (opt) = string (opt) | string (access_options);
	if dates then string (opt) = string (opt) | string (date_options);
	if lengths then do;
	     if active_function then
		string (opt) = string (opt) | string (active_function_length_options);
	     else string (opt) = string (opt) | string (length_options);
	end;
	if switch_count = 0 & string (opt) = "0"b then
	     if active_function then do;		/* control arg must be supplied to active function */
AF_USAGE:
		call active_fnc_err_ (0, ME, "Usage:  [status path control_arg {-chase}]");
		return;
	     end;
	     else unspec (opt) = unspec (default_options);

/* Shorter output format if only one item of information is requested. */

	j = switch_count - k;
	do i = 1 to hbound (LONG_OPTION, 1);
	     if substr (string (opt), i, 1) then j = j + 1;
	end;
	if j = 1 then one_item = "1"b;
	else if active_function & ^lengths then go to AF_USAGE;
	else one_item = "0"b;

	if path_count = 0 then do;			/* assume working directory */
	     if active_function & arg_count = 2 then go to AF_USAGE;
	     path_count = 1;
	     path_array.path_len (1) = 0;		/* use expand_path_'s working dir feature */
	     path_array.path_ptr (1) = null ();
	end;
	else if active_function & path_count > 1 then go to AF_USAGE;

	saved_options = opt;
%page;
	printed_something = "0"b;			/* haven't output anything yet */

	do i = 1 to path_count;
	     if path_array.nonstandard_names_flag (i) then do;
		dn = get_wdir_ ();
		arg_len = path_array.path_len (i);
		arg_ptr = path_array.path_ptr (i);
		en = arg;
	     end;
	     else do;
		call expand_path_ (path_array.path_ptr (i), path_array.path_len (i), addr (dn), addr (en), code);
		if code ^= 0 then do;
		     arg_ptr = path_array.path_ptr (i);
		     arg_len = path_array.path_len (i);
		     call complain (code, ME, "^a", arg);
		     go to NEXT_PATH;
		end;
		if en ^= "" then call check_star_name_$entry (en, code); /* star convention? */
	     end;
	     if code = 0 then do;
		star_sw = "0"b;
		j, star_entry_count = 1;
		printed_pathname = "0"b;
		msf = "0"b;
		msf_ptr = null ();

		call ENTRY_STATUS ();		/* do the work */

		if msf then
		     if msf_ptr ^= null then call msf_manager_$close (msf_ptr);
		if branch_names_ptr ^= null & ^root_sw then free branch_names in (area);
	     end;
	     else if code > 2 then do;		/* invalid entry name */
		arg_ptr = path_array.path_ptr (i);
		arg_len = path_array.path_len (i);
		call complain (code, ME, "^a", arg);
		go to NEXT_PATH;
	     end;
	     else if active_function then do;
		call active_fnc_err_ (0, ME, "Star convention is not allowed.");
RETURN:
		return;
	     end;
	     else
star_loop:
		begin;
		star_sw = "1"b;
		star_list_branch_ptr, star_list_names_ptr = null;

		on condition (cleanup) call CLEAN_UP ();

		call hcs_$star_dir_list_ (dn, en, star_select_sw, area_ptr, star_branch_count, star_link_count,
		     star_list_branch_ptr, star_list_names_ptr, code);
		if code ^= 0 then do;
		     call complain (code, ME, "^a", pathname_ (dn, en));
		     go to NEXT_PATH;
		end;
		star_en = en;
		matched = "0"b;
		star_entry_count = star_branch_count + star_link_count;
		do j = 1 to star_entry_count;
		     entry_type = star_dir_list_branch (j).type;
		     if entry_type = star_SEGMENT then do;
			if ^seg_sw then go to NEXT_MATCH;
		     end;
		     else if entry_type = star_LINK then do;
			if ^link_sw then go to NEXT_MATCH;
		     end;
		     else do;			/* directory type: dir or MSF */
			if star_dir_list_branch (j).bit_count = 0 then do;
			     if ^dir_sw then go to NEXT_MATCH;
			end;
			else if ^seg_sw then go to NEXT_MATCH;
		     end;
		     matched = "1"b;
		     en = star_list_names (star_dir_list_branch (j).nindex);
		     printed_pathname = "0"b;
		     msf = "0"b;
		     msf_ptr = null ();

		     call ENTRY_STATUS ();		/* do the work */

		     if ^printed_something then	/* if we haven't output anything yet, */
			printed_something = printed_pathname; /* then if we printed the pathname, */
						/* well that's something */

		     if chased | msf_error then dn = saved_dn;
		     if msf then
			if msf_ptr ^= null then call msf_manager_$close (msf_ptr);
		     if branch_names_ptr ^= null & ^root_sw then free branch_names in (area);
NEXT_MATCH:
		end;
		if ^matched | (matched & ^printed_something) then
		     call complain (error_table_$nomatch, ME, "^a", pathname_ (dn, star_en));
		call CLEAN_UP ();
	     end star_loop;

NEXT_PATH:
	end;
STATUS_EXIT:
	call CLEAN_UP ();
	return;
%page;
ENTRY_STATUS: proc;

/* This internal procedure returns the requested attributes of dn>en */
/* It uses a number of global values declared in the external procedure. */
/* It allocates branch names and sets branch_names_ptr. */
/* For multisegment files, it turns on the flag msf. */

dcl  max_switch_length fixed bin;
dcl  not_mounted fixed bin (35);
dcl  msf_mode bit (5) aligned;
dcl  msf_rbs (0:2) fixed bin (5) unaligned;

	max_switch_length = switch_length;
	branch_status.number_names = "0"b;
	opt = saved_options;
	chased, dm_file_sw, msf_error, root_sw = "0"b;
	not_mounted = 0;

	status_chase = NO_CHASE;			/* get info on entry */

/* If it's a link, we'll be coming back here with status_chase = CHASE */

STATUS:
	branch_status.names_rel_pointer = "0"b;

	if opt.names | opt.primary_name | opt.link_path then
	     call hcs_$status_long (dn, en, status_chase, addr (branch_status), area_ptr, code);
	else call hcs_$status_long (dn, en, status_chase, addr (branch_status), null, code);
	branch_names_ptr = null;

	if branch_status.names_rel_pointer ^= "0"b then
	     branch_names_ptr = ptr (area_ptr, branch_status.names_rel_pointer);

	on condition (cleanup) begin;
	     if branch_names_ptr ^= null & ^root_sw then free branch_names in (area);
	end;

	if code ^= 0 then
	     if code = error_table_$no_s_permission then do;
NO_S:
		string (opt) = string (opt) & string (no_s_options);
		if string (opt) = "0"b then call ENTRY_ERROR (code, dn, en);
	     end;
	     else if code = error_table_$logical_volume_not_connected |
		code = error_table_$logical_volume_not_defined then do;
		not_mounted = code;
		string (opt) = string (opt) & string (off_line_options);
		if branch_status.number_names = "0"b then string (opt) = string (opt) & string (no_s_options);
		if string (opt) = "0"b then call ENTRY_ERROR (code, dn, en);
	     end;
	     else if code = error_table_$root then do;	/* now it works on the root */
		root_sw = "1"b;
		string (opt) = string (opt) & string (root_options);
		if string (opt) = "0"b then call ENTRY_WRONG_TYPE ("the root");
		dn = ">";
		en = "";
		branch_names_ptr = addr (ROOT_NAMES);	/* fake hcs_$status info */
		unspec (branch_status) = "0"b;
		branch_status.type = directory_type;
		branch_status.unique_id = (36)"1"b;
		branch_status.number_names = "0001"b4;
		if get_group_id_ () = INITIALIZER_ID then branch_status.mode = "01011"b; /* sma */
		else branch_status.mode = "01"b;	/* s for everybody else */
		branch_status.ring_brackets (*) = "000111"b; /* 7,7,7 */
	     end;
	     else call ENTRY_ERROR (code, dn, en);

/* Check the fs type when we are -inase with -slet, and fake out status if wrong type */

	if selecting_by_entry_type then do;
	     call fs_util_$get_type (dn, en, fs_type, code);
	     if code ^= 0 then do;
		call complain (code, ME, "Getting type of ^a", pathname_ (dn, en));
		return;
	     end;
	     if ^ENTRY_TYPE_SELECTED (fs_type, fs_entry_type_ptr) then do;
		matched = "1"b;
		return;
	     end;
	     else if substr (fs_type, 1, 1) = "-" then ;	/* standard type, no faking necessary */
	     else if star_sw then
		if before (reverse (rtrim (en)), ".") ^= before (reverse (rtrim (star_en)), ".") then do;
		     matched = "1"b;
		     return;
		end;
	end;

/* See if the entry is a special type */

	entry_type = fixed (branch_status.type);
	msf = (entry_type = star_DIRECTORY & branch_status.bit_count ^= "0"b);

	if ^interpret_as_standard_entry & entry_type ^= star_LINK & ^root_sw then
	     if msf | switch_count > 0 | (string (opt) & string (typed_options)) then do;
		call fs_util_$get_type (dn, en, fs_util_type, code);
		dm_file_sw = (code = 0 & fs_util_type = FS_OBJECT_TYPE_DM_FILE);
		if code = 0 & substr (fs_util_type, 1, 1) ^= "-" then do;
						/* for now, handle segs, dirs, DM files, and MSF's by hand */
		     entry_type = EXTENDED_type;
		     msf = "0"b;
		     si.version = SUFFIX_INFO_VERSION_1;
		     call fs_util_$suffix_info_for_type (fs_util_type, addr (si), (0));
		end;
	     end;

	if branch_status.type = link_type then do;	/* process link for -chase or -chase_if_possible */
	     if chase & chased then do;		/* null link */
		call complain (0, ME, "Null link with -chase.  ^a", pathname_ (dn, en));
		return;
	     end;
	     else if (chase_if_possible | chase) then
		if ^chased then do;
		     call hcs_$get_link_target (dn, en, target_dn, target_en, code);
		     if code = 0 & dn ^= "" then do;
			chased = "1"b;
			saved_dn = dn;
			saved_en = en;
			dn = target_dn;
			en = target_en;
			status_chase = CHASE;	/* chase the link this time */
			go to STATUS;		/* go back to get link info */
		     end;
		     else if code = error_table_$noentry then
			if chase then do;		/* null link */
			     call complain (code, ME,
				"Target:  ^a.  Link to a null link with -chase.  Source:  ^a",
				pathname_ (target_dn, target_en), pathname_ (dn, en));
			     return;
			end;
		end;				/* if ^chase */

	     string (opt) = string (opt) & string (link_options);
	     if string (opt) = "0"b & switch_count = 0 then /* no applicable control args */
		call ENTRY_WRONG_TYPE ("a link");
	end;					/* if branch_status.type = link_type */

	else do;					/* non-link */
	     if ^star_sw then
		if branch_status.type = directory_type & ^dm_file_sw then do;
		     if (seg_sw | link_sw) & ^dir_sw then call ENTRY_WRONG_TYPE ("a directory");
		end;
		else if (link_sw | dir_sw) & ^seg_sw then
		     if dm_file_sw then call ENTRY_WRONG_TYPE ("a Data Management file");
		     else call ENTRY_WRONG_TYPE ("a segment");

	     string (opt) = string (opt) & string (nonlink_options);
	     if string (opt) = "0"b & switch_count = 0 then do; /* no applicable control args */
		if ^star_sw then call ENTRY_WRONG_TYPE ("not a link");
		return;
	     end;
	end;

	if lengths & active_function then		/* set up the return value for -length only when status acts as an active function */
	     if branch_status.type = directory_type & branch_status.bit_count = "0"b then opt.current_length = "0"b; /* for directory type -- status active function returns bit count for -length */
	     else opt.bit_count = "0"b;		/* for other types -- status active function returns current length for -length */
	else ;

	if dm_file_sw | root_sw then msf = "0"b;	/* root's not, can't look inside a DM file */

	if dm_file_sw then do;
	     string (opt) = string (opt) & string (dm_file_options);
	     if string (opt) = "0"b & switch_count = 0 then call ENTRY_WRONG_TYPE ("a Data Management file");
	end;
	else do;					/* not DM file; make sure some control args apply */
	     unspec (opt.dm_files_only) = "0"b;

/**** vp: phx20203 ; case when string (opt) = "0"b and switch_count > 0 for a link ****/
	     if string (opt) = "0"b then do;
		if branch_status.type = link_type then call ENTRY_WRONG_TYPE ("a link");
		else call ENTRY_WRONG_TYPE ("not a Data Management file");
	     end;
	end;
%page;
/* Now we know we can proceed to print or return some info */

	if ^active_function & ^one_item then do;	/* multiple entries; print pathname */
	     call PRINT_PATHNAME ();
	     call ioa_ ("");
	end;

	if dm_file_sw then do;
	     if (string (opt) & string (fm_status_options)) ^= "0"b then do;
		unspec (auto_dm_file_status) = "0"b;
		auto_dm_file_status.version = DM_FILE_STATUS_VERSION_1;
		call file_manager_$status (dn, en, addr (auto_dm_file_status), code);
		if code ^= 0 & code ^= dm_error_$transaction_in_progress then do;
		     call complain (code, ME, "^a", pathname_ (dn, en));
		     return;
		end;
	     end;
	end;
%page;
/* Format each item of status info */

	if opt.names | opt.primary_name then do;	/* -name or -primary */
	     if active_function then do;
		return_string = requote_string_ (rtrim (branch_names (0)));
		if opt.names then
		     do k = 1 to bin (branch_status.number_names) - 1;
		     return_string = return_string || " " || requote_string_ (rtrim (branch_names (k)));
		end;
		return;
	     end;
	     call PRINT_PATHNAME ();
	     if opt.names then do;
		if one_item then call ioa_ ("^a", branch_names (0));
		else call ioa_ ("names:^4x^a", branch_names (0));
		do k = 1 to bin (branch_status.number_names) - 1;
		     if one_item then call ioa_ ("^a", branch_names (k));
		     else call ioa_ ("^10x^a", branch_names (k));
		end;
	     end;
	     else if one_item then call ioa_ ("^a", branch_names (0));
	     else call ioa_ ("primary name:^7x^a", branch_names (0));
	end;

	if opt.type then do;			/* -type */
	     if root_sw then type_string = "directory";
	     else if dm_file_sw then type_string = "Data Management file";
	     else if entry_type = EXTENDED_type then type_string = si.type_name;
	     else if entry_type = star_LINK then type_string = "link";
	     else if entry_type = star_SEGMENT then type_string = "segment";
	     else if entry_type = star_DIRECTORY then
		if branch_status.bit_count ^= "0"b then type_string = "multisegment file";
		else if branch_status.mdir then type_string = "master directory";
		else type_string = "directory";

	     if active_function then do;
		return_string = """" || rtrim (type_string) || """";
		return;
	     end;
	     call PRINT_PATHNAME ();
	     if one_item then call ioa_ ("^a", type_string);
	     else call ioa_ ("type:^15x^a", type_string);
	end;

	if opt.link_path then do;			/* -link_path */
	     target_ptr = ptr (area_ptr, link_status.pnrp);
	     target_len = link_status.pnl;
	     if active_function then do;
		return_string = rtrim (target_path);
		return;
	     end;
	     call PRINT_PATHNAME ();
	     if one_item then call ioa_ ("^a", target_ptr -> target_path);
	     else call ioa_ ("links to:^11x^a", target_ptr -> target_path);
	end;

	if opt.unique_id then do;			/* -unique_id */
	     if dm_file_sw then local_unique_id = auto_dm_file_status.fm_unique_id;
	     else local_unique_id = branch_status.unique_id;
	     if active_function then do;
		call ioa_$rsnnl ("^w", return_string, k, local_unique_id);
		return;
	     end;
	     else do;
		call PRINT_PATHNAME ();
		if one_item then call ioa_ ("^w", local_unique_id);
		else call ioa_ ("^[fm unique id:^7x^;unique id:^10x^]^w", dm_file_sw, local_unique_id);
	     end;
	end;

/* Get MSF information */

	if opt.dtu | opt.dtcm | opt.dtem | opt.dtd | opt.bit_count | opt.records_used | opt.current_length |
	     opt.mode | opt.ring_brackets then do;

	     call PRINT_PATHNAME ();

	     if msf then
get_msf_info:
		begin;
		on cleanup begin;
		     if msf_ptr ^= null then call msf_manager_$close (msf_ptr);
		end;

		call msf_manager_$open (dn, en, msf_ptr, code);
		if msf_ptr = null then do;
		     call complain (code, ME, "Unable to open multisegment file ^a>^a", dn, en);
		     msf = "0"b;
		     return;
		end;

		msf_dtu, msf_dtcm, msf_dtem, msf_dtd = "0"b;
		total_records = bin (branch_status.records, 17);
		total_length = bin (branch_status.current_length, 11);
		total_bit_count = 0;
		msf_path = rtrim (dn) || ">" || en;
						/* initialize in case no components */
		msf_mode = branch_status.mode & "01010"b;
		unspec (msf_rbs) = unspec (branch_status.ring_brackets);

		do k = 0 by 1 while (code = 0);	/* look at all components */
		     call msf_manager_$get_ptr (msf_ptr, k, "0"b, comp_ptr, 0, code);
		     if code = 0 | code = error_table_$segknown then do;
			comp_name = convert (comp_name, k);
			comp_name = substr (comp_name, verify (comp_name, " "));
			call hcs_$status_long (msf_path, comp_name, 1, addr (msf_info), null, code);
			if code ^= 0 then
			     if code = error_table_$no_s_permission then do;
				opt.ring_brackets = "0"b;
				if string (opt) = "0"b then do;
				     saved_dn = dn;
				     msf_error = "1"b;
				     call ENTRY_ERROR (code, msf_path, comp_name);
				end;
			     end;
			     else do;
				call complain (code, ME, "^a>^a", msf_path, comp_name);
				return;
			     end;
			code = 0;
			if fixed (msf_info.dtu) > fixed (msf_dtu) then msf_dtu = msf_info.dtu;
			if fixed (msf_info.dtcm) > fixed (msf_dtcm) then msf_dtcm = msf_info.dtcm;
			if fixed (msf_info.dtem) > fixed (msf_dtem) then msf_dtem = msf_info.dtem;
			if fixed (msf_info.dtd) > fixed (msf_dtd) then msf_dtd = msf_info.dtd;
			if k = 0 then do;		/* first component */
			     msf_mode = msf_info.mode;
			     unspec (msf_rbs) = unspec (msf_info.rbs);
			end;
			total_records = total_records + msf_info.records;
			total_bit_count = total_bit_count + bin (msf_info.bit_count);
			total_length = total_length + msf_info.current_length;
		     end;
		     else if code ^= error_table_$noentry then do;
			opt.bit_count, opt.records_used, opt.current_length, opt.dtu, opt.dtcm,
			     opt.dtem, opt.dtd, opt.mode, opt.ring_brackets = "0"b;
			if string (opt) = "0"b then do;
			     saved_dn = dn;
			     msf_error = "1"b;
			     comp_name = convert (comp_name, k);
			     call ENTRY_ERROR (error_table_$moderr,
				dn, en);
			end;
		     end;
		end;
	     end get_msf_info;
	end;

	if opt.dtu then do;				/* -date_time_used */

/**** vp: phx20897; convert the system clock to 36 bits then make use of
      the internal procedure CONVERT_DATE to convert a 36 bits clock time
      into an ASCII date string.  This will effectively check for active
      function as well.                                                  ****/

	     if root_sw then do;
		temp_clock = clock ();		/* This conversion method was taken from date_time_.pl1 routine */
		stime = addr (temp_clock) -> fs_time_value.time;
		call CONVERT_DATE (stime);
	     end;
	     else if msf & msf_dtu ^= "0"b then call CONVERT_DATE (msf_dtu);
	     else call CONVERT_DATE (branch_status.date_time_used);
	     call PRINT_PATHNAME ();
	     if one_item then call ioa_ ("^a", date_string);
	     else if date_string ^= "ZERO" | explicit_opt.dtu then call ioa_ ("date used:^10x^a", date_string);
	end;

	if opt.dtcm then do;			/* -date_time_contents_modified */
	     if msf & msf_dtcm ^= "0"b then call CONVERT_DATE (msf_dtcm);
	     else call CONVERT_DATE (branch_status.date_time_modified);
	     call PRINT_PATHNAME ();
	     if one_item then call ioa_ ("^a", date_string);
	     else if date_string ^= "ZERO" | explicit_opt.dtcm then call ioa_ ("date modified:^6x^a", date_string);
	end;

	if opt.dtem then do;			/* -date_time_entry_modified */
	     call PRINT_PATHNAME ();
	     if entry_type = star_LINK then do;
		call CONVERT_DATE (link_status.dtlm);
		if one_item then call ioa_ ("^a", date_string);
		else if date_string ^= "ZERO" | explicit_opt.dtem then
		     call ioa_ ("date link modified: ^a", date_string);
	     end;
	     else do;
		if msf & msf_dtem ^= "0"b then call CONVERT_DATE (msf_dtem);
		else call CONVERT_DATE (branch_status.date_time_entry_modified);
		if one_item then call ioa_ ("^a", date_string);
		else if date_string ^= "ZERO" | explicit_opt.dtem then
		     call ioa_ ("branch modified:^4x^a", date_string);
	     end;
	end;

	if opt.dtvd then do;			/* -date_time_volume_dumped */
	     call PRINT_PATHNAME ();
	     if entry_type = star_LINK then do;
		call hcs_$get_dates (dn, "", dates_array, code);
		call CONVERT_DATE (dates_array (5));
		if one_item then call ioa_ ("link dtvd: ^a", date_string);
		else if date_string ^= "ZERO" | explicit_opt.dtd then
		     call ioa_ ("link volume dumped:^1x^a", date_string);
	     end;
	     else do;
		call hcs_$get_dates (dn, en, dates_array, code);
		call CONVERT_DATE (dates_array (5));
		if one_item then call ioa_ ("dtvd: ^a", date_string);
		else if date_string ^= "ZERO" | explicit_opt.dtd then
		     call ioa_ ("date volume dumped:^1x^a", date_string);
	     end;
	end;

	if opt.dtd then do;				/* -date_time_dumped */
	     call PRINT_PATHNAME ();
	     if entry_type = star_LINK then do;
		call CONVERT_DATE (link_status.dtd);
		if one_item then call ioa_ ("dtd: ^a", date_string);
		else if date_string ^= "ZERO" | explicit_opt.dtd then
		     call ioa_ ("link dumped:^8x^a", date_string);
	     end;
	     else do;
		if msf & msf_dtd ^= "0"b then call CONVERT_DATE (msf_dtd);
		else call CONVERT_DATE (branch_status.date_time_dumped);
		if one_item then call ioa_ ("br dtd: ^a", date_string);
		else if date_string ^= "ZERO" | explicit_opt.dtd then
		     call ioa_ ("date branch dumped:^1x^a", date_string);
	     end;
	end;

	if opt.author then do;			/* -author */
	     call PRINT_PATHNAME ();
	     if root_sw then do;
		author_string = INITIALIZER_ID;
		code = 0;
	     end;
	     else call hcs_$get_author (dn, en, 0, author_string, code);
	     if active_function then do;
		if code = 0 then return_string = rtrim (author_string);
		else call active_fnc_err_ (code, ME);
		return;
	     end;
	     if code = 0 then do;
		if one_item then call ioa_ ("^a", author_string);
		else call ioa_ ("author:^13x^a", author_string);
	     end;
	     else if one_item then call complain (code, ME);
	     else if explicit_opt.author then call complain (code, ME, "Unable to get author.");
	end;

	if opt.bc_author then do;			/* -bc_author */
	     call PRINT_PATHNAME ();
	     if root_sw then do;
		bc_author_string = INITIALIZER_ID;
		code = 0;
	     end;
	     else call hcs_$get_bc_author (dn, en, bc_author_string, code);
	     if active_function then do;
		if code = 0 then return_string = rtrim (bc_author_string);
		else call active_fnc_err_ (code, ME);
		return;
	     end;
	     if code = 0 then do;
		if one_item then call ioa_ ("^a", bc_author_string);
		else if explicit_opt.bc_author | bc_author_string ^= author_string then
		     call ioa_ ("bit count author:^3x^a", bc_author_string);
	     end;
	     else if one_item then call complain (code, ME);
	     else if explicit_opt.bc_author then call complain (code, ME, "Unable to get bit count author.");
	end;

	if opt.logical_volume then do;		/* -logical_volume */
	     call PRINT_PATHNAME ();
	     if root_sw then do;
		lv_string = "root";
		code = 0;
	     end;
	     else call mdc_$find_lvname (branch_status.lvid, lv_string, code);
	     if active_function then do;
		if code = 0 then return_string = rtrim (lv_string);
		else call active_fnc_err_ (code, ME);
		return;
	     end;
	     else if code = 0 then do;
		if one_item then call ioa_ ("^a", lv_string);
		else if entry_type = star_SEGMENT then call ioa_ ("volume name:^8x^a", lv_string);
		else call ioa_ ("sons volume:^8x^a", lv_string);
	     end;
	     else if one_item then call complain (code, ME);
	     else if explicit_opt.logical_volume then call complain (code, ME, "Unable to get logical volume.");
	end;

	if opt.bit_count then do;			/* -bit_count */
	     call PRINT_PATHNAME ();
	     if root_sw then bc35 = 0;
	     else do;
		bc36 = "0000"b3 || branch_status.bit_count;
		unspec (bc35) = bc36;		/* convert to fixed bin (35) */
	     end;
	     if msf then
		if active_function then do;
		     call ioa_$rsnnl ("^d", return_string, k, total_bit_count);
		     return;
		end;
		else do;
		     call ioa_ ("number of components:^9x^d", k - 1);
		     if k - 1 ^= bin (branch_status.bit_count) then
			call ioa_ ("msf indicator:^6x^d   (inconsistent with number of components)", bc35);
		     call ioa_ ("total bit count:^4x^d", total_bit_count);
		end;
	     else if active_function then do;
		call ioa_$rsnnl ("^d", return_string, k, bc35);
		return;
	     end;
	     else if one_item then call ioa_ ("^d", bc35);
	     else call ioa_ ("bit count:^10x^d", bc35);
	end;

	if opt.records_used then do;			/* -records_used */
	     call PRINT_PATHNAME ();
	     if msf then
		if active_function then do;
		     call ioa_$rsnnl ("^d", return_string, k, total_records);
		     return;
		end;
		else do;
		     if one_item then call ioa_ ("^d", total_records);
		     else call ioa_ ("total records used:^x^d", total_records);
		end;
	     else if active_function then do;
		call ioa_$rsnnl ("^d", return_string, k, fixed (branch_status.records, 18));
		return;
	     end;
	     else do;
		if one_item then call ioa_ ("^d", fixed (branch_status.records, 18));
		else call ioa_ ("records used:^7x^d", fixed (branch_status.records, 18));
	     end;
	end;

	if opt.current_length then do;		/* -current_length */
	     call PRINT_PATHNAME ();
	     if msf then
		if active_function then do;
		     call ioa_$rsnnl ("^d", return_string, k, total_length);
		     return;
		end;
		else do;
		     if one_item then call ioa_ ("^d", total_length);
		     else if explicit_opt.current_length | total_length ^= total_records then
			call ioa_ ("total length:^7x^d", total_length);
		end;
	     else if active_function then do;
		call ioa_$rsnnl ("^d", return_string, k, fixed (branch_status.current_length, 12));
		return;
	     end;
	     else do;
		if one_item then call ioa_ ("^d", fixed (branch_status.current_length, 12));
		else if explicit_opt.current_length |
		     branch_status.current_length ^= substr (branch_status.records, 7, 12) then
		     call ioa_ ("current length:^5x^d", fixed (branch_status.current_length, 12));
	     end;
	end;

	if opt.max_length then do;			/* -max_length */
	     call PRINT_PATHNAME ();
	     if entry_type ^= star_DIRECTORY then do;
		if msf then call hcs_$get_max_length (msf_path, "0", max_length, code);
		else if entry_type = EXTENDED_type then call fs_util_$get_max_length (dn, en, max_length, code);
		else call hcs_$get_max_length (dn, en, max_length, code);
		if active_function then do;
		     if code = 0 then call ioa_$rsnnl ("^d", return_string, k, max_length);
		     else call active_fnc_err_ (code, ME);
		     return;
		end;
		if code = 0 then
		     if one_item then call ioa_ ("^d", max_length);
		     else call ioa_ ("max length:^9x^d", max_length);
		else if code = error_table_$unsupported_operation & ^explicit_opt.max_length then ;
						/* ignore if this type has no max length */
		else if one_item then call complain (code, ME);
		else if explicit_opt.max_length then call complain (code, ME, "Unable to get max length.");
	     end;
	     else if active_function then do;
		call active_fnc_err_ (0, ME, "Unable to get the max length of a directory.  ^a>^a", dn, en);
		return;
	     end;
	     else if explicit_opt.max_length then
		call complain (0, ME, "Unable to get the max length of a directory.  ^a>^a", dn, en);
	end;

	if opt.mode then do;			/* -mode */
	     call PRINT_PATHNAME ();
	     if dm_file_sw then string (mode_bits) = "0"b || substr (auto_dm_file_status.mode, 1, 4); /* prevent string size condition while compiling. */
	     else if msf then string (mode_bits) = msf_mode;
	     else string (mode_bits) = branch_status.mode;
	     mode_string = "";
	     if entry_type = EXTENDED_type then do;
		call fs_util_$get_user_access_modes (dn, en, "", -1, modes, exmodes, code);
		if code ^= 0 then
		     if code = error_table_$unsupported_operation & ^explicit_opt.mode then ;
						/* ignore if this type has no extended mode */
		     else call complain (code, ME, "Unable to get extended mode.");
		else do;
		     do k = 1 to length (rtrim (si.modes));
			if substr (modes, k, 1) then mode_string = mode_string || substr (si.modes, k, 1);
		     end;
		end;
	     end;
	     else if dm_file_sw | msf | entry_type = star_SEGMENT then do;
		if mode_bits (2) then mode_string = "r";
		if mode_bits (3) then mode_string = mode_string || "e";
		if mode_bits (4) then mode_string = mode_string || "w";
	     end;
	     else do;				/* directory */
		if mode_bits (2) then mode_string = "s";
		if mode_bits (4) then mode_string = mode_string || "m";
		if mode_bits (5) then mode_string = mode_string || "a";
	     end;
	     if code = 0 then do;
		if mode_string = "" then mode_string = "null";
		if active_function then do;
		     return_string = mode_string;
		     return;
		end;
		if one_item then call ioa_ ("^a", mode_string);
		else call ioa_ ("mode:^15x^a", mode_string);
	     end;
	end;

	if opt.access_class then do;			/* -access_class */
	     call PRINT_PATHNAME ();
	     call hcs_$get_access_class (dn, en, access_class, code);
	     if code = 0 then do;
		call convert_authorization_$to_string_short (access_class, class, code);
		if code ^= 0 then call complain (code, ME, "Unable to convert access class.");
		else if active_function then do;
		     if class = "" then class = "system_low";
		     return_string = rtrim (class);
		     return;
		end;
		else if class ^= "" then do;		/* format access class in lines of 50 chars */
		     class_len = index (class, " ") - 1;
		     if class_len = -1 then class_len = 336;
		     k = 1;
		     if ^one_item then call ioa_$nnl ("access class:^7x");
		     do while ((class_len - k + 1) > 50);
			temp_string = substr (class, k, 50);
			kk = length (temp_string) + 1 - index (reverse (temp_string), ",");
			call ioa_$nnl ("^a", substr (class, k, kk));
			if ^one_item then call ioa_$nnl ("^/^20x");
			k = k + kk;
		     end;
		     call ioa_ ("^a", substr (class, k));
		end;
		else if explicit_opt.access_class then
		     if one_item then call ioa_ ("system_low");
		     else call ioa_ ("access class:^7xsystem_low");
	     end;
	     else if active_function | explicit_opt.access_class then do;
		call complain (code, ME, "Unable to get access class.");
		return;
	     end;
	end;

	if opt.ring_brackets then do;			/* -ring_brackets */
	     call PRINT_PATHNAME ();
	     if entry_type = EXTENDED_type then do;
		if si.num_ring_brackets = 0 then
		     if explicit_opt.ring_brackets then
			call complain (0, ME, "The ^a object type does not support ring brackets.",
			     si.type_name);
		     else ;
		else do;
		     call fs_util_$get_ring_brackets (dn, en, ring_brackets, code);
		     if code ^= 0 then
			if code = error_table_$unsupported_operation & ^explicit_opt.ring_brackets then ;
						/* ignore if this type has no ring brackets */
			else call complain (code, ME, "Unable to get ring brackets.");
		     else if active_function then call ioa_$rsnnl ("^v(^d ^)", return_string, k,
			     si.num_ring_brackets, ring_brackets);
		     else call ioa_ ("^[ring brackets:^6x^]^v(^d, ^)^d", ^one_item,
			     si.num_ring_brackets - 1, ring_brackets);
		end;
	     end;
	     else if active_function then do;
		if dm_file_sw then
		     call ioa_$rsnnl ("^d ^d", return_string, k, auto_dm_file_status.ring_brackets);
		else if msf then call ioa_$rsnnl ("^d ^d ^d", return_string, k, msf_rbs);
		else if entry_type ^= star_DIRECTORY then
		     call ioa_$rsnnl ("^d ^d ^d", return_string, k, fixed (branch_status.ring_brackets, 5));
		else call ioa_$rsnnl ("^d ^d", return_string, k, fixed (branch_status.ring_brackets (0), 5),
			fixed (branch_status.ring_brackets (1), 5));
		return;
	     end;
	     else if dm_file_sw then
		if one_item then call ioa_ ("^d, ^d", auto_dm_file_status.ring_brackets);
		else call ioa_ ("extended ring brackets:^2x^d, ^d", auto_dm_file_status.ring_brackets);
	     else if msf then
		if one_item then call ioa_ ("^d, ^d, ^d", msf_rbs);
		else call ioa_ ("ring brackets:^6x^d, ^d, ^d", msf_rbs);
	     else if entry_type ^= star_DIRECTORY then
		if one_item then call ioa_ ("^d, ^d, ^d", fixed (branch_status.ring_brackets, 5));
		else call ioa_ ("ring brackets:^6x^d, ^d, ^d", fixed (branch_status.ring_brackets, 5));
	     else if one_item then call ioa_ ("^d, ^d", fixed (branch_status.ring_brackets (0), 5),
		     fixed (branch_status.ring_brackets (1), 5));
	     else call ioa_ ("ring brackets:^6x^d, ^d", fixed (branch_status.ring_brackets (0), 5),
		     fixed (branch_status.ring_brackets (1), 5));
	end;

	if opt.usage_count then do;			/* -usage_count */
	     call PRINT_PATHNAME ();
	     if entry_type = star_DIRECTORY then
		if explicit_opt.usage_count & ^star_sw then
		     call complain (0, ME, "Cannot determine the usage count of a directory.");
		else ;
	     else do;
		usage_count = 0;
		on linkage_error begin;
		     usage_count = -1;
		     go to flurp;
		end;
		call mhcs_$get_seg_usage (dn, en, usage_count, code);
flurp:
		revert linkage_error;
		if usage_count < 0 then code = error_table_$incorrect_access;
		if active_function then do;
		     if code = 0 then call ioa_$rsnnl ("^d", return_string, k, usage_count);
		     else call active_fnc_err_ (code, ME);
		     return;
		end;
		if code = 0 then
		     if one_item then call ioa_ ("^d", usage_count);
		     else call ioa_ ("usage count:^8x^d", usage_count);
		else if explicit_opt.usage_count then
		     call complain (code, ME, "Unable to get usage count.");
	     end;
	end;

	if entry_type = EXTENDED_type | dm_file_sw then do;
	     call PRINT_PATHNAME ();
	     switch_list_ptr = null ();
	     on cleanup begin;
		if switch_list_ptr ^= null ()
		then free switch_list;
	     end;

	     call fs_util_$list_switches_for_type (fs_util_type, SWITCH_LIST_VERSION_1, area_ptr,
		switch_list_ptr, code);
	     if code = error_table_$unsupported_operation &
		^(explicit_opt.safety_switch | explicit_opt.ivds | explicit_opt.copy_switch | explicit_opt.audit_switch | explicit_opt.cvds |
		explicit_opt.synchronized_switch | explicit_opt.damaged_switch | explicit_opt.concurrency_switch |
		explicit_opt.rollback_switch | explicit_opt.protected_switch) then
		goto SKIP_SWITCHES;			/* WARNING, this ain't too modular */
	     if code ^= 0 then do;
		call complain (code, ME, "Listing switches.");
		return;
	     end;
	     if all then do k = 1 to switch_list.switch_count;
		max_switch_length = max (max_switch_length,
		     length (rtrim (switch_list.names (switch_list.name_index (k)))));
	     end;
	end;
	max_switch_length = max_switch_length + 8;	/* " switch: " */

	if opt.safety_switch then do;			/* -safety_switch */
	     call PRINT_PATHNAME ();
	     if entry_type = EXTENDED_type | dm_file_sw then call STATUS_SWITCH ("safety", explicit_opt.safety_switch);
	     else do;
		if root_sw then safety_switch = "0"b;
		else call hcs_$get_safety_sw (dn, en, safety_switch, code);
		call PRINT_SWITCH ("safety", explicit_opt.safety_switch, safety_switch, "0"b);
	     end;
	end;

	if opt.ivds then do;			/* -ivds */
	     call PRINT_PATHNAME ();
	     if entry_type = star_DIRECTORY & ^root_sw then
		if explicit_opt.ivds then call ENTRY_WRONG_TYPE ("a directory");
		else ;				/* not valid for dirs */
	     else do;
		if entry_type = EXTENDED_type | dm_file_sw then
		     call STATUS_SWITCH ("ivds", explicit_opt.ivds);
		else do;
		     if root_sw then ivds = 1;
		     else call hcs_$get_volume_dump_switches (dn, en, ivds, cvds, code);
		     call PRINT_SWITCH ("ivds", explicit_opt.ivds, (ivds = -1), "1"b);
		end;
	     end;
	end;

	if opt.cvds then do;			/* -cvds */
	     call PRINT_PATHNAME ();
	     if entry_type = star_DIRECTORY & ^root_sw then
		if explicit_opt.cvds then call ENTRY_WRONG_TYPE ("a directory");
		else ;				/* not valid for dirs */
	     else do;
		if entry_type = EXTENDED_type | dm_file_sw then call STATUS_SWITCH ("cvds", explicit_opt.cvds);
		else do;
		     if root_sw then cvds = 1;
		     else call hcs_$get_volume_dump_switches (dn, en, ivds, cvds, code);
		     call PRINT_SWITCH ("cvds", explicit_opt.cvds, (cvds = -1), "1"b);
		end;
	     end;
	end;

	if opt.audit_switch then do;			/* -audit_switch */
	     call PRINT_PATHNAME ();
	     if entry_type = EXTENDED_type | dm_file_sw then call STATUS_SWITCH ("audit", explicit_opt.audit_switch);
	     else do;
		bks.version = status_for_backup_version_2;
		call hcs_$status_for_backup (dn, en, addr (bks), code);
		call PRINT_SWITCH ("audit", explicit_opt.audit_switch, (bks.audit_flag), "0"b);
	     end;
	end;

	if opt.copy_switch then do;			/* -copy_switch */
	     call PRINT_PATHNAME ();
	     if entry_type = EXTENDED_type | dm_file_sw then call STATUS_SWITCH ("copy", explicit_opt.copy_switch);
	     else do;
		code = 0;
		call PRINT_SWITCH ("copy", explicit_opt.copy_switch, (branch_status.copy_switch), "0"b);
	     end;
	end;

	if opt.damaged_switch then do;		/* -damaged_switch */
	     call PRINT_PATHNAME ();
	     if entry_type = EXTENDED_type | dm_file_sw then
		call STATUS_SWITCH ("damaged", explicit_opt.damaged_switch);
	     else do;
		code = 0;
		call PRINT_SWITCH ("damaged", explicit_opt.damaged_switch, (branch_status.damaged_switch), "0"b);
	     end;
	end;

	if opt.synchronized_switch then do;		/* -synchronized_switch */
	     call PRINT_PATHNAME ();
	     if entry_type = EXTENDED_type | dm_file_sw then
		call STATUS_SWITCH ("synchronized", explicit_opt.synchronized_switch);
	     else do;
		code = 0;
		if fixed (branch_status.bit_count) = 0 & branch_status.type = directory_type then do;
		     if ^all then
			call complain (0, ME, "Directories do not support the synch switch.  ^a.", pathname_ (dn, en));
		end;
		else call PRINT_SWITCH ("synchronized", explicit_opt.synchronized_switch,
			(branch_status.synchronized_switch), "0"b);
	     end;
	end;

	call PRINT_PATHNAME ();
	if entry_type = EXTENDED_type then do;
	     if all then do;
		do k = 1 to switch_list.switch_count;
		     if switch_list.name_index (k) > 0 then
			call STATUS_SWITCH_QUICK ((switch_list.names (switch_list.name_index (k))), "0"b);
		end;
		do k = 1 to switch_count;
		     do kk = 1 to switch_list.switch_name_count;
			if switch_names (k) = switch_list.names (kk) then go to FOUND;
		     end;
		     call complain (0, ME, "The ^a switch is not supported by ^a.", switch_names (k),
			si.plural_name);
FOUND:
		end;
	     end;

	     else if switch_mask ^= "0"b then do kk = 1 to switch_count;
		call STATUS_SWITCH (switch_names (kk), "1"b);
	     end;
	end;
	else if switch_mask ^= "0"b then do k = 1 to switch_count;
	     if substr (switch_mask, k, 1) then
		call complain (0, ME, "Standard objects do not support the ^a switch.", switch_names (k));
	end;

SKIP_SWITCHES:
	if opt.entry_bound then do;
	     call PRINT_PATHNAME ();
	     if entry_type ^= star_SEGMENT then
		if explicit_opt.entry_bound then
		     call complain (0, ME, "The entry is not a gate.  ^a", pathname_ (dn, en));
		else ;
	     else do;
		bks.version = status_for_backup_version_2;
		call hcs_$status_for_backup (dn, en, addr (bks), code);
		if code ^= 0 then call complain (code, ME, "Unable to obtain entrybound.");
		else if ^bks.entrypt then
NOT_GATE:
		     if explicit_opt.entry_bound then call complain (0, ME, "The entry is not a gate.");
		     else ;
		else if active_function then call ioa_$rsnnl ("^d", return_string, k, fixed (bks.entrypt_bound));
		else if one_item then call ioa_ ("^d", fixed (bks.entrypt_bound));
		else call ioa_ ("entry bound:^8x^d", fixed (bks.entrypt_bound));
	     end;
	end;

	if opt.highest_ci then do;
	     call PRINT_PATHNAME ();
	     if active_function then call ioa_$rsnnl ("^d", return_string, k, auto_dm_file_status.highest_ci);
	     else if one_item then call ioa_ ("^d", auto_dm_file_status.highest_ci);
	     else call ioa_ ("highest control interval:  ^d", auto_dm_file_status.highest_ci);
	end;

	if opt.concurrency_switch then do;
	     call PRINT_PATHNAME ();
	     call PRINT_SWITCH ("concurrency", explicit_opt.concurrency_switch,
		^auto_dm_file_status.no_concurrency_sw, "1"b);
	end;

	if opt.rollback_switch then do;
	     call PRINT_PATHNAME ();
	     call PRINT_SWITCH ("rollback", explicit_opt.rollback_switch,
		^auto_dm_file_status.no_rollback_sw, "1"b);
	end;

	if opt.protected_switch then do;
	     call PRINT_PATHNAME ();
	     call PRINT_SWITCH ("protected", explicit_opt.protected_switch,
		(auto_dm_file_status.protected_sw), "1"b);
	end;

	if not_mounted ^= 0 & all & ^active_function then
	     call complain (not_mounted, ME,
		"Unable to determine: date used, date modified, date volume dumped, records used, max length or usage count.");

	if j = star_entry_count & ^active_function & ^one_item then call ioa_ ("");
	if (entry_type = EXTENDED_type) & (switch_list_ptr ^= null ()) then free switch_list;

ENTRY_RETURN:
	return;
%page;
CONVERT_DATE: proc (date_time);

/* This internal procedure converts a bit(36) clock time into an ASCII date string.
   If status was called as an active function, the string is returned. */

dcl  date_time bit (36);
dcl  date_time_$format entry (char (*), fixed bin (71), char (*), char (*)) returns (char (250) var);
dcl  cv_fstime_ entry (bit (36) aligned) returns (fixed bin (71));

	if date_time = "0"b then date_string = "ZERO";
	else date_string = date_time_$format ("date_time", cv_fstime_ ((date_time)), "", "");
	if active_function then do;
	     return_string = """" || rtrim (date_string) || """";
	     go to ENTRY_RETURN;			/* "status" active function must call normal cleanup handler before it finishes. */
	end;

     end CONVERT_DATE;
%page;
ENTRY_ERROR: proc (P_code, P_dn, P_en);

dcl  P_code fixed bin (35);
dcl  (P_dn, P_en) char (*);

	if active_function then do;
	     if msf_ptr ^= null then
		call msf_manager_$close (msf_ptr);
	     call CLEAN_UP;
	end;
	call complain (P_code, ME, "^a", pathname_ (P_dn, P_en));
	go to ENTRY_RETURN;

     end ENTRY_ERROR;
%page;
ENTRY_WRONG_TYPE: proc (P_string);

dcl  P_string char (*);

	if ^star_sw then
	     call complain (0, ME, "^a is ^[the root^;^a^]. Control arguments given do not apply.",
		pathname_ (dn, en), root_sw, P_string);
	go to ENTRY_RETURN;

     end ENTRY_WRONG_TYPE;
%page;
PRINT_PATHNAME: proc;

/* This internal procedure merely prints out the pathname if it hasn't been
   printed yet. */

	if printed_pathname | active_function then return;

	if star_sw | (path_count > 1) then
	     if one_item then call ioa_ ("^5x^a", pathname_ (dn, en));
	     else call ioa_ ("^/^10x^a", pathname_ (dn, en));
	else ;					/* don't print header for only 1 path on command line */

	printed_pathname = "1"b;
	return;

     end PRINT_PATHNAME;
%page;
STATUS_SWITCH: proc (switch, explicit);

dcl  switch char (*);
dcl  temp_switch char (32);
dcl  explicit bit (1) unaligned;
dcl  default bit (1) aligned;
dcl  value bit (1) aligned;
dcl  x fixed bin;

	if switch = "cvds" then temp_switch = "complete_volume_dump";
	else if switch = "ivds" then temp_switch = "incremental_volume_dump";
	else temp_switch = switch;

	do k = 1 to switch_list.switch_count;
	     do x = 0 to switch_list.name_count (k) - 1;
		if switch_list.name_index (k) > 0 then
		     if switch = switch_list.names (switch_list.name_index (k) + x) then go to JOIN;
	     end;
	end;

	if explicit then
	     call complain (0, ME, "The ^a switch is not supported by ^a.", switch, si.plural_name);

	return;

STATUS_SWITCH_QUICK: entry (switch, explicit);

	temp_switch = switch;
JOIN:
	if switch_list.name_index (k) = 0 then return;	/* already printed */
	switch_list.name_index (k) = 0;		/* so we don't come back */
	default = switch_list.default_value (k);

	call fs_util_$get_switch (dn, en, temp_switch, value, code);
	goto PRINT;

PRINT_SWITCH: entry (switch, explicit, switch_value, default_value);

dcl  switch_value bit (1) aligned;
dcl  default_value bit (1) aligned;

	value = switch_value;
	default = default_value;
	code = 0;
PRINT:
	if code ^= 0 then call complain (code, ME, "Unable to get ^a switch.", switch);

	if active_function then do;
	     if value then return_string = "true";
	     else return_string = "false";
	     return;
	end;
	else if all | (value ^= default) then
	     if one_item then call ioa_ ("^[on^;off^]", value);
	     else call ioa_ ("^a switch:^vt^[on^;off^] (default^[ = ^[off^;on^]^])", switch, max_switch_length, value,
		     value ^= default, value);
	else if explicit then
	     if one_item then call ioa_ ("^[on^;off^]", value);
	     else call ioa_ ("^a switch:^vt^[on^;off^]", switch, max_switch_length, value);

	return;

     end STATUS_SWITCH;

     end ENTRY_STATUS;
%page;
BUILD_ENTRY_TYPE_LIST: proc (P_entry_type_list, P_fs_entry_type_ptr, P_slet_enabled_sw);

dcl  P_entry_type_list char (*);
dcl  P_fs_entry_type_ptr ptr;
dcl  P_slet_enabled_sw bit (1) aligned;
dcl  1 entry_type_info aligned like suffix_info;
dcl  types char (types_len) based (types_ptr);
dcl  types_len fixed bin (24);
dcl  types_ptr ptr;
dcl  this_type char (32);

/* Copy the entry type list parameter into locally managed storage */

	types_ptr = null;
	on cleanup begin;
	     if types_ptr ^= null then free types in (area);
	end;

	types_len = length (P_entry_type_list);
	allocate types set (types_ptr) in (area);
	types = P_entry_type_list;

/* Count the number of entry types and allocate the entry type array */

	do fs_entry_type_count = 1
	     repeat (fs_entry_type_count + 1)
	     while (index (types, ",") ^= 0);
	     types = after (types, ",");
	end;

	allocate fs_entry_type in (area) set (P_fs_entry_type_ptr);

	entry_type_info.version = SUFFIX_INFO_VERSION_1;
	P_fs_entry_type_ptr -> fs_entry_type.suffix (*) = "";

/* For each potential entry type, validate it and add it to the structure */

	types = P_entry_type_list;
	entry_type_index = 1;

	do while (types ^= "");

	     this_type = before (types, ",");
	     if substr (this_type, 1, 1) ^= "-" then do;
		if this_type = "link" then this_type = FS_OBJECT_TYPE_LINK;
		else if this_type = "segment" then this_type = FS_OBJECT_TYPE_SEGMENT;
		else if this_type = "directory" then this_type = FS_OBJECT_TYPE_DIRECTORY;
		else if this_type = "multisegment_file" then this_type = FS_OBJECT_TYPE_MSF;
		else if this_type = "data_management_file" then this_type = FS_OBJECT_TYPE_DM_FILE;

		P_fs_entry_type_ptr -> fs_entry_type.suffix (entry_type_index) = this_type;

		if this_type = FS_OBJECT_TYPE_LINK then entry_type_index = entry_type_index + 1;
						/* fs_util_ does not handle links */
		else do;
		     call fs_util_$suffix_info_for_type (this_type, addr (entry_type_info), code);
		     if code = 0 then entry_type_index = entry_type_index + 1;
		end;
	     end;

	     types = after (types, ",");
	end;

/* Free the types variable and set P_slet_enabled_sw */

	free types_ptr -> types in (area);

	P_fs_entry_type_ptr -> fs_entry_type.count = entry_type_index - 1;
	if P_fs_entry_type_ptr -> fs_entry_type.count > 0 then P_slet_enabled_sw = "1"b;
	else do;
	     call complain (0, ME,
		"^[None of the specified entry types is valid^;The specified entry type is not valid^]: ^a",
		P_fs_entry_type_ptr -> fs_entry_type.count > 1, P_entry_type_list);
	     go to STATUS_EXIT;
	end;

	return;

     end BUILD_ENTRY_TYPE_LIST;
%page;
ENTRY_TYPE_SELECTED: proc (P_fs_type, P_fs_entry_type_ptr) returns (bit (1) aligned);

dcl  P_fs_type char (*);
dcl  P_fs_entry_type_ptr ptr;
dcl  entry_type_index fixed bin;

	do entry_type_index = 1 to P_fs_entry_type_ptr -> fs_entry_type.count;
	     if P_fs_type = P_fs_entry_type_ptr -> fs_entry_type.suffix (entry_type_index) then return ("1"b);
	end;

	return ("0"b);

     end ENTRY_TYPE_SELECTED;
%page;
CLEAN_UP: proc;

	if star_list_names_ptr ^= null then free star_list_names in (area);
	if star_list_branch_ptr ^= null then free star_dir_list_branch in (area);
	if fs_entry_type_ptr ^= null then free fs_entry_type in (area);
	if path_array_ptr ^= null & path_array_ptr ^= addr (path_array_space) then free path_array in (area);

     end CLEAN_UP;
%page;
dcl  1 access_options int static,			/* for -access */

       (2 primary_name init ("0"b),
       2 names init ("0"b),
       2 type init ("0"b),
       2 link_path init ("0"b),
       2 unique_id init ("0"b),
       2 dtu init ("0"b),
       2 dtcm init ("0"b),
       2 dtem init ("0"b),
       2 dtd init ("0"b),
       2 dtvd init ("0"b),
       2 author init ("0"b),
       2 bc_author init ("0"b),
       2 logical_volume init ("0"b),
       2 bit_count init ("0"b),
       2 records_used init ("0"b),
       2 current_length init ("0"b),
       2 max_length init ("0"b),
       2 mode init ("1"b),
       2 access_class init ("1"b),
       2 ring_brackets init ("1"b),
       2 safety_switch init ("1"b),
       2 copy_switch init ("0"b),
       2 audit_switch init ("0"b),
       2 ivds init ("0"b),
       2 cvds init ("0"b),
       2 usage_count init ("0"b),
       2 damaged_switch init ("0"b),
       2 synchronized_switch init ("0"b),
       2 entry_bound init ("0"b),
       2 highest_ci init ("0"b),
       2 concurrency_switch init ("0"b),
       2 rollback_switch init ("0"b),
       2 protected_switch init ("0"b)
       ) bit (1) unaligned;
%page;
dcl  1 date_options int static,			/* for -date */
       (2 primary_name init ("0"b),
       2 names init ("0"b),
       2 type init ("0"b),
       2 link_path init ("0"b),
       2 unique_id init ("0"b),
       2 dtu init ("1"b),
       2 dtcm init ("1"b),
       2 dtem init ("1"b),
       2 dtd init ("1"b),
       2 dtvd init ("1"b),
       2 author init ("0"b),
       2 bc_author init ("0"b),
       2 logical_volume init ("0"b),
       2 bit_count init ("0"b),
       2 records_used init ("0"b),
       2 current_length init ("0"b),
       2 max_length init ("0"b),
       2 mode init ("0"b),
       2 access_class init ("0"b),
       2 ring_brackets init ("0"b),
       2 safety_switch init ("0"b),
       2 copy_switch init ("0"b),
       2 audit_switch init ("0"b),
       2 ivds init ("0"b),
       2 cvds init ("0"b),
       2 usage_count init ("0"b),
       2 damaged_switch init ("0"b),
       2 synchronized_switch init ("0"b),
       2 entry_bound init ("0"b),
       2 highest_ci init ("0"b),
       2 concurrency_switch init ("0"b),
       2 rollback_switch init ("0"b),
       2 protected_switch init ("0"b)
       ) bit (1) unaligned;
%page;
dcl  1 length_options int static,			/* for -length */
       (2 primary_name init ("0"b),
       2 names init ("0"b),
       2 type init ("0"b),
       2 link_path init ("0"b),
       2 unique_id init ("0"b),
       2 dtu init ("0"b),
       2 dtcm init ("0"b),
       2 dtem init ("0"b),
       2 dtd init ("0"b),
       2 dtvd init ("0"b),
       2 author init ("0"b),
       2 bc_author init ("0"b),
       2 logical_volume init ("0"b),
       2 bit_count init ("1"b),
       2 records_used init ("1"b),
       2 current_length init ("1"b),
       2 max_length init ("1"b),
       2 mode init ("0"b),
       2 access_class init ("0"b),
       2 ring_brackets init ("0"b),
       2 safety_switch init ("0"b),
       2 copy_switch init ("0"b),
       2 audit_switch init ("0"b),
       2 ivds init ("0"b),
       2 cvds init ("0"b),
       2 usage_count init ("0"b),
       2 damaged_switch init ("0"b),
       2 synchronized_switch init ("0"b),
       2 entry_bound init ("0"b),
       2 highest_ci init ("0"b),
       2 concurrency_switch init ("0"b),
       2 rollback_switch init ("0"b),
       2 protected_sw init ("0"b)
       ) bit (1) unaligned;
%page;
dcl  1 active_function_length_options int static,		/* for -length */
       (2 primary_name init ("0"b),
       2 names init ("0"b),
       2 type init ("0"b),
       2 link_path init ("0"b),
       2 unique_id init ("0"b),
       2 dtu init ("0"b),
       2 dtcm init ("0"b),
       2 dtem init ("0"b),
       2 dtd init ("0"b),
       2 dtvd init ("0"b),
       2 author init ("0"b),
       2 bc_author init ("0"b),
       2 logical_volume init ("0"b),
       2 bit_count init ("1"b),			/* for directory type only */
       2 records_used init ("0"b),
       2 current_length init ("1"b),			/* for other types such as segment or MSF or DM file */
       2 max_length init ("0"b),
       2 mode init ("0"b),
       2 access_class init ("0"b),
       2 ring_brackets init ("0"b),
       2 safety_switch init ("0"b),
       2 copy_switch init ("0"b),
       2 audit_switch init ("0"b),
       2 ivds init ("0"b),
       2 cvds init ("0"b),
       2 usage_count init ("0"b),
       2 damaged_switch init ("0"b),
       2 synchronized_switch init ("0"b),
       2 entry_bound init ("0"b),
       2 highest_ci init ("0"b),
       2 concurrency_switch init ("0"b),
       2 rollback_switch init ("0"b),
       2 protected_sw init ("0"b)
       ) bit (1) unaligned;
%page;
dcl  1 default_options int static,			/* no control arguments specified */
       (2 primary_name init ("0"b),
       2 names init ("1"b),
       2 type init ("1"b),
       2 link_path init ("1"b),
       2 unique_id init ("0"b),
       2 dtu init ("1"b),
       2 dtcm init ("1"b),
       2 dtem init ("1"b),
       2 dtd init ("0"b),
       2 dtvd init ("0"b),
       2 author init ("0"b),
       2 bc_author init ("0"b),
       2 logical_volume init ("0"b),
       2 bit_count init ("1"b),
       2 records_used init ("1"b),
       2 current_length init ("0"b),
       2 max_length init ("0"b),
       2 mode init ("1"b),
       2 access_class init ("0"b),
       2 ring_brackets init ("0"b),
       2 safety_switch init ("0"b),
       2 copy_switch init ("0"b),
       2 audit_switch init ("0"b),
       2 ivds init ("0"b),
       2 cvds init ("0"b),
       2 usage_count init ("0"b),
       2 damaged_switch init ("1"b),
       2 synchronized_switch init ("0"b),
       2 entry_bound init ("0"b),
       2 highest_ci init ("1"b),
       2 concurrency_switch init ("1"b),
       2 rollback_switch init ("1"b),
       2 protected_switch init ("1"b)
       ) bit (1) unaligned;
%page;
dcl  1 no_s_options int static,			/* attributes available without s access */
       (2 primary_name init ("0"b),
       2 names init ("0"b),
       2 type init ("1"b),
       2 link_path init ("1"b),
       2 unique_id init ("1"b),
       2 dtu init ("1"b),
       2 dtcm init ("1"b),
       2 dtem init ("1"b),
       2 dtd init ("1"b),
       2 dtvd init ("1"b),
       2 author init ("1"b),
       2 bc_author init ("1"b),
       2 logical_volume init ("1"b),
       2 bit_count init ("1"b),
       2 records_used init ("1"b),
       2 current_length init ("1"b),
       2 max_length init ("1"b),
       2 mode init ("1"b),
       2 access_class init ("1"b),
       2 ring_brackets init ("1"b),
       2 safety_switch init ("1"b),
       2 copy_switch init ("1"b),
       2 audit_switch init ("1"b),
       2 ivds init ("1"b),
       2 cvds init ("1"b),
       2 usage_count init ("1"b),
       2 damaged_switch init ("1"b),
       2 synchronized_switch init ("1"b),
       2 entry_bound init ("1"b),
       2 highest_ci init ("1"b),
       2 concurrency_switch init ("1"b),
       2 rollback_switch init ("1"b),
       2 protected_switch init ("1"b)
       ) bit (1) unaligned;
%page;
dcl  1 off_line_options int static,			/* attributes available without VTOC */
       (2 primary_name init ("1"b),
       2 names init ("1"b),
       2 type init ("1"b),
       2 link_path init ("1"b),
       2 unique_id init ("1"b),
       2 dtu init ("0"b),
       2 dtcm init ("0"b),
       2 dtem init ("1"b),
       2 dtd init ("1"b),
       2 dtvd init ("0"b),
       2 author init ("1"b),
       2 bc_author init ("1"b),
       2 logical_volume init ("1"b),
       2 bit_count init ("1"b),
       2 records_used init ("0"b),
       2 current_length init ("0"b),
       2 max_length init ("1"b),
       2 mode init ("1"b),
       2 access_class init ("1"b),
       2 ring_brackets init ("1"b),
       2 safety_switch init ("1"b),
       2 copy_switch init ("1"b),
       2 audit_switch init ("1"b),
       2 ivds init ("0"b),
       2 cvds init ("0"b),
       2 usage_count init ("0"b),
       2 damaged_switch init ("0"b),
       2 synchronized_switch init ("0"b),
       2 entry_bound init ("1"b),
       2 highest_ci init ("0"b),
       2 concurrency_switch init ("0"b),
       2 rollback_switch init ("0"b),
       2 protected_switch init ("0"b)
       ) bit (1) unaligned;
%page;
dcl  1 link_options int static,			/* attributes valid for links */
       (2 primary_name init ("1"b),
       2 names init ("1"b),
       2 type init ("1"b),
       2 link_path init ("1"b),
       2 unique_id init ("0"b),
       2 dtu init ("0"b),
       2 dtcm init ("0"b),
       2 dtem init ("1"b),
       2 dtd init ("1"b),
       2 dtvd init ("1"b),
       2 author init ("1"b),
       2 bc_author init ("0"b),
       2 logical_volume init ("0"b),
       2 bit_count init ("0"b),
       2 records_used init ("0"b),
       2 current_length init ("0"b),
       2 max_length init ("0"b),
       2 mode init ("0"b),
       2 access_class init ("0"b),
       2 ring_brackets init ("0"b),
       2 safety_switch init ("0"b),
       2 copy_switch init ("0"b),
       2 audit_switch init ("0"b),
       2 ivds init ("0"b),
       2 cvds init ("0"b),
       2 usage_count init ("0"b),
       2 damaged_switch init ("0"b),
       2 synchronized_switch init ("0"b),
       2 entry_bound init ("0"b),
       2 highest_ci init ("0"b),
       2 concurrency_switch init ("0"b),
       2 rollback_switch init ("0"b),
       2 protected_switch init ("0"b)
       ) bit (1) unaligned;
%page;
dcl  1 nonlink_options int static,			/* attributes valid for non-links */
       (2 primary_name init ("1"b),
       2 names init ("1"b),
       2 type init ("1"b),
       2 link_path init ("0"b),
       2 unique_id init ("1"b),
       2 dtu init ("1"b),
       2 dtcm init ("1"b),
       2 dtem init ("1"b),
       2 dtd init ("1"b),
       2 dtvd init ("1"b),
       2 author init ("1"b),
       2 bc_author init ("1"b),
       2 logical_volume init ("1"b),
       2 bit_count init ("1"b),
       2 records_used init ("1"b),
       2 current_length init ("1"b),
       2 max_length init ("1"b),
       2 mode init ("1"b),
       2 access_class init ("1"b),
       2 ring_brackets init ("1"b),
       2 safety_switch init ("1"b),
       2 copy_switch init ("1"b),
       2 audit_switch init ("1"b),
       2 ivds init ("1"b),
       2 cvds init ("1"b),
       2 usage_count init ("1"b),
       2 damaged_switch init ("1"b),
       2 synchronized_switch init ("1"b),
       2 entry_bound init ("1"b),
       2 highest_ci init ("1"b),
       2 concurrency_switch init ("1"b),
       2 rollback_switch init ("1"b),
       2 protected_switch init ("1"b)
       ) bit (1) unaligned;
%page;
dcl  1 dm_file_options int static,			/* attributes valid for DM files */
       (2 primary_name init ("1"b),
       2 names init ("1"b),
       2 type init ("1"b),
       2 link_path init ("0"b),
       2 unique_id init ("1"b),
       2 dtu init ("1"b),
       2 dtcm init ("1"b),
       2 dtem init ("1"b),
       2 dtd init ("1"b),
       2 dtvd init ("1"b),
       2 author init ("1"b),
       2 bc_author init ("0"b),
       2 logical_volume init ("1"b),
       2 bit_count init ("0"b),
       2 records_used init ("1"b),
       2 current_length init ("1"b),
       2 max_length init ("1"b),
       2 mode init ("1"b),
       2 access_class init ("1"b),
       2 ring_brackets init ("1"b),
       2 safety_switch init ("0"b),
       2 copy_switch init ("0"b),
       2 audit_switch init ("0"b),
       2 ivds init ("0"b),
       2 cvds init ("0"b),
       2 usage_count init ("0"b),
       2 damaged_switch init ("0"b),
       2 synchronized_switch init ("0"b),
       2 entry_bound init ("0"b),
       2 highest_ci init ("1"b),
       2 concurrency_switch init ("1"b),
       2 rollback_switch init ("1"b),
       2 protected_switch init ("1"b)
       ) bit (1) unaligned;
%page;
dcl  1 fm_status_options int static,			/* DM file attr's requiring file_manager_$status */
       (2 primary_name init ("0"b),
       2 names init ("0"b),
       2 type init ("0"b),
       2 link_path init ("0"b),
       2 unique_id init ("1"b),
       2 dtu init ("0"b),
       2 dtcm init ("0"b),
       2 dtem init ("0"b),
       2 dtd init ("0"b),
       2 dtvd init ("0"b),
       2 author init ("0"b),
       2 bc_author init ("0"b),
       2 logical_volume init ("0"b),
       2 bit_count init ("0"b),
       2 records_used init ("0"b),
       2 current_length init ("0"b),
       2 max_length init ("0"b),
       2 mode init ("1"b),
       2 access_class init ("0"b),
       2 ring_brackets init ("1"b),
       2 safety_switch init ("0"b),
       2 copy_switch init ("0"b),
       2 audit_switch init ("0"b),
       2 ivds init ("0"b),
       2 cvds init ("0"b),
       2 usage_count init ("0"b),
       2 damaged_switch init ("0"b),
       2 synchronized_switch init ("0"b),
       2 entry_bound init ("0"b),
       2 highest_ci init ("1"b),
       2 concurrency_switch init ("1"b),
       2 rollback_switch init ("1"b),
       2 protected_switch init ("1"b)
       ) bit (1) unaligned;
%page;
dcl  1 root_options int static,			/* attributes available for the root */
       (2 primary_name init ("1"b),
       2 names init ("1"b),
       2 type init ("1"b),
       2 link_path init ("0"b),
       2 unique_id init ("1"b),
       2 dtu init ("1"b),
       2 dtcm init ("0"b),
       2 dtem init ("0"b),
       2 dtd init ("0"b),
       2 dtvd init ("0"b),
       2 author init ("1"b),
       2 bc_author init ("1"b),
       2 logical_volume init ("1"b),
       2 bit_count init ("1"b),
       2 records_used init ("0"b),
       2 current_length init ("0"b),
       2 max_length init ("0"b),
       2 mode init ("1"b),
       2 access_class init ("0"b),
       2 ring_brackets init ("1"b),
       2 safety_switch init ("1"b),
       2 copy_switch init ("0"b),
       2 audit_switch init ("0"b),
       2 ivds init ("0"b),
       2 cvds init ("0"b),
       2 usage_count init ("0"b),
       2 damaged_switch init ("1"b),
       2 synchronized_switch init ("0"b),
       2 entry_bound init ("0"b),
       2 highest_ci init ("0"b),
       2 concurrency_switch init ("0"b),
       2 rollback_switch init ("0"b),
       2 protected_switch init ("0"b)
       ) bit (1) unaligned;
%page;
dcl  1 typed_options int static,			/* attributes that must come from fs_util_ */
       (2 primary_name init ("0"b),
       2 names init ("0"b),
       2 type init ("1"b),
       2 link_path init ("0"b),
       2 unique_id init ("0"b),
       2 dtu init ("0"b),
       2 dtcm init ("0"b),
       2 dtem init ("0"b),
       2 dtd init ("0"b),
       2 dtvd init ("0"b),
       2 author init ("0"b),
       2 bc_author init ("0"b),
       2 logical_volume init ("0"b),
       2 bit_count init ("0"b),
       2 records_used init ("0"b),
       2 current_length init ("0"b),
       2 max_length init ("1"b),
       2 mode init ("1"b),
       2 access_class init ("0"b),
       2 ring_brackets init ("1"b),
       2 safety_switch init ("1"b),
       2 copy_switch init ("1"b),
       2 audit_switch init ("1"b),
       2 ivds init ("1"b),
       2 cvds init ("1"b),
       2 usage_count init ("0"b),
       2 damaged_switch init ("1"b),
       2 synchronized_switch init ("1"b),
       2 entry_bound init ("0"b),
       2 highest_ci init ("1"b),
       2 concurrency_switch init ("1"b),
       2 no_rollback_sw init ("1"b),
       2 protected_switch init ("1"b)
       ) bit (1) unaligned;
%page;
%include branch_status;
%page;
%include copy_flags;
%page;
%include dm_file_status;
%page;
%include star_structures;
%page;
%include status_for_backup;
%page;
%include suffix_info;


     end status;
