/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(88-01-13,Blair), approve(88-03-22,MCR7842),
     audit(88-07-08,Lippard), install(88-07-26,MR12.2-1069):
     Make the parse use the mlsys search list to resolve pathnames for
     saveboxes, mailboxes and mailing lists (free standing).  SCP 6349.
  2) change(89-05-11,Lee), approve(89-05-30,MCR8111),
     audit(89-07-12,LZimmerman), install(89-10-02,MR12.3-1079):
     phx21283 (Mail 534) - Modified internal procedure get_mailbox_pathname to
     fix a problem when the entry parse_mailbox_control_args is called; it was
     aborting when the -mbx arg contains a .mbx suffix.
                                                   END HISTORY COMMENTS */


/* format: off */

/* Mail System Utilities which parse the control argument representations of addresses, address lists, and mailboxes */

/* Created:  June 1983 by G. Palter */
/* Modified: March 1984 by G. Palter to fix the following mail system errors:
      #0415 -- read_mail, print_mail, and have_mail do not reject starnames as invalid mailbox specifications
      #0430 -- when parsing command/request line control arguments, use of "-log", "-save", or "-mailbox" followed by
         "-at" should create a foreign address whose address string is "{mbx PATH}".  Otherwise, when the message reaches
         the foreign Multics, the address could be incorrectly interpreted as a savebox belonging to the mailer daemon
      #0433 -- the send_mail command and all send_mail/read_mail requests which accept multiple addresses as arguments do
         not properly parse "-log -at HOST"
      #0435 -- the error message displayed by send_mail when the target address of a mail table entry is invalid only
         includes the name of the mail table entry.  The actual invalid address (eg: mailbox pathname) is not included
      #0436 -- if a forum meeting is not found in the "forum" search list, the mail system will treat it as a version 1
         forum in the working directory */

/* format: on,style4,delnl,insnl,ifthenstmt,ifthen */


mlsys_parse_control_args_:
     procedure ();

	return;					/* not an entrypoint */


/* Common parameters */

dcl  P_sci_ptr pointer parameter;			/* -> definition of subsystem for whom we are parsing */
dcl  P_argument_idx fixed binary parameter;		/* identifies first command/request argument to be parsed;
						   set to identify first argument we didn't use in parsing */
dcl  P_parse_ca_options_ptr pointer parameter;		/* -> options describing how to parse */
dcl  P_code fixed binary (35) parameter;


/* parse_address_control_args Parameters */

dcl  P_address_ptr pointer parameter;			/* set -> the address parsed from the command/request line */


/* parse_address_list_control_args Parameters */

dcl  P_address_list_version character (8) parameter;	/* version of address_list structures desired */
dcl  P_normal_address_list_ptr pointer parameter;		/* -> list where all but logbox/savebox addresses are added */
dcl  P_logsave_address_list_ptr pointer parameter;	/* -> list where logbox/savebox addresses are added */


/* parse_mailbox_control_args and parse_mailbox_text Parameters */

dcl  P_mailbox_dirname character (*) parameter;		/* set to the mailbox pathname found on the command line */
dcl  P_mailbox_ename character (*) parameter;		/* ... */


/* parse_mailbox_text Parameters */

dcl  P_mailbox_text character (*) parameter;		/* the text to be converted to a pathname */


/* Local copies of parameters */

dcl  sci_ptr pointer;
dcl  argument_idx fixed binary;
dcl  code fixed binary (35);

dcl  creation_mode fixed binary;			/* extracted from parse_ca_options ... */

dcl  address_ptr pointer;

dcl  mbx_dirname character (168);
dcl  mbx_ename character (32);


/* Remaining declarations */

dcl  argument character (argument_lth) unaligned based (argument_ptr);
dcl  argument_ptr pointer;
dcl  argument_lth fixed binary (21);
dcl  n_arguments fixed binary;

dcl  system_area area based (system_area_ptr);
dcl  system_area_ptr pointer;

dcl  abort_the_parse label variable;			/* used by abort_parse internal procedure */

dcl  address_type fixed binary;

dcl  (mailbox_type, mailbox_idx) fixed binary;

dcl  (person_id, project_id) character (32) varying;
dcl  (mte_address_ptr, target_address_ptr) pointer;
dcl  (errors_detected, is_mte_name) bit (1) aligned;
dcl  try_to_create bit (1) unaligned;

dcl  forum_search_list_ptr pointer;

dcl  STACK_EXTENSION fixed binary (18) static options (constant) initial (128);

dcl  NULL_STRING character (1) static options (constant) initial (" ");

/* format: off */
dcl (USER_OR_MTE_ADDRESS	initial (-1),		/* either a User_id or a mail-table entry name */
     MBX_USER_OR_MTE_ADDRESS	initial (-2))		/* either a mailbox pathname, User_id, or mail-table name */
	fixed binary static options (constant);

dcl (OTHER_MAILBOX		initial (1),		/* not a logbox or savebox */
     USER_LOGBOX		initial (2),
     SAVEBOX		initial (3))
	fixed binary static options (constant);

dcl (error_table_$bad_subr_arg, error_table_$badopt, error_table_$entlong, error_table_$moderr, error_table_$noarg,
     error_table_$noentry, error_table_$nostars, error_table_$no_dir, error_table_$unimplemented_version,
     error_table_$smallarg, mlsys_et_$ca_parse_failed, mlsys_et_$mailbox_exists, mlsys_et_$mte_not_found,
     mlsys_et_$mte_not_mailbox, mlsys_et_$no_mailbox)
	fixed binary (35) external;
/* format: on */

dcl  check_star_name_$entry entry (character (*), fixed binary (35));
dcl  command_query_$yes_no entry () options (variable);
dcl  cu_$arg_list_ptr entry () returns (pointer);
dcl  cu_$arg_ptr entry (fixed binary, pointer, fixed binary (21), fixed binary (35));
dcl  cu_$generate_call entry (entry, pointer);
dcl  cu_$grow_stack_frame entry (fixed binary (18), pointer, fixed binary (35));
dcl  cu_$shrink_stack_frame entry (pointer, fixed binary (35));
dcl  expand_pathname_ entry (character (*), character (*), character (*), fixed binary (35));
dcl  expand_pathname_$add_suffix entry (character (*), character (*), character (*), character (*), fixed binary (35));
dcl  expand_pathname_$component_add_suffix
	entry (character (*), character (*), character (*), character (*), character (*), fixed binary (35));
dcl  forum_$get_forum_path entry (character (*), character (*), character (*), character (*), fixed binary (35));
dcl  get_system_free_area_ entry () returns (pointer);
dcl  mail_system_$add_address entry (pointer, pointer, character (8), fixed binary (35));
dcl  mail_system_$create_foreign_address
	entry (character (*) varying, character (256) varying, pointer, character (*) varying, character (*) varying,
	pointer, fixed binary (35));
dcl  mail_system_$create_forum_address
	entry (character (*), character (*), character (*) varying, character (*) varying, pointer, fixed binary (35));
dcl  mail_system_$create_logbox_address
	entry (character (*) varying, character (*) varying, character (*) varying, pointer, fixed binary (35));
dcl  mail_system_$create_mail_table_address
	entry (character (*) varying, character (*) varying, character (*) varying, pointer, fixed binary (35));
dcl  mail_system_$create_mailbox_address
	entry (character (*), character (*), character (*) varying, character (*) varying, pointer, fixed binary (35));
dcl  mail_system_$create_mailing_list_address
	entry (character (*), character (*), character (*), character (*) varying, character (*) varying, pointer,
	fixed binary (35));
dcl  mail_system_$create_savebox_address
	entry (character (*) varying, character (*), character (*), character (*) varying, character (*) varying,
	pointer, fixed binary (35));
dcl  mail_system_$create_user_mailbox_address
	entry (character (*) varying, character (*) varying, character (*) varying, pointer, fixed binary (35));
dcl  mail_system_$free_address entry (pointer, fixed binary (35));
dcl  mail_system_$get_address_pathname entry (pointer, character (*), character (*), character (*), fixed binary (35));
dcl  mail_system_$get_address_type entry (pointer, fixed binary, fixed binary (35));
dcl  mail_system_$get_mail_table_address entry (pointer, pointer, fixed binary (35));
dcl  mail_system_$validate_address entry (pointer, bit (1) aligned, fixed binary (35));
dcl  mailbox_$close entry (fixed binary, fixed binary (35));
dcl  mailbox_$open entry (character (*), character (*), fixed binary, fixed binary (35));
dcl  mlsys_psp_$forum_not_available entry () returns (bit (1) aligned);
dcl  mlsys_user_mte_syntax_$classify_and_validate
	entry (character (*) varying, bit (1) aligned, character (*) varying, character (*) varying, fixed binary (35));
dcl  mlsys_utils_$create_logbox entry (fixed binary (35));
dcl  mlsys_utils_$create_savebox entry (character (*), character (*), fixed binary (35));
dcl  mlsys_utils_$format_address_field
	entry (character (*) varying, pointer, fixed binary, pointer, fixed binary (21), fixed binary (21),
	fixed binary (35));
dcl  mlsys_utils_$print_validate_results entry (pointer, pointer, fixed binary (35));
dcl  pathname_ entry (character (*), character (*)) returns (character (168));
dcl  pathname_$component entry (character (*), character (*), character (*)) returns (character (194));
dcl  search_paths_$find_dir 
	entry (char(*), ptr, char(*), char(*), char(*), fixed bin(35));
dcl  search_paths_$get
	entry (character (*), bit (36), character (*), pointer, pointer, fixed binary, pointer, fixed binary (35));
dcl  ssu_$abort_line entry () options (variable);
dcl  ssu_$arg_ptr entry (pointer, fixed binary, pointer, fixed binary (21));
dcl  ssu_$get_subsystem_and_request_name entry (pointer) returns (character (72) var);
dcl  ssu_$print_message entry () options (variable);
dcl  ssu_$return_arg entry (pointer, fixed binary, bit (1) aligned, pointer, fixed binary (21));
dcl  suffixed_name_$make entry (char(*), char(*), char(32), fixed bin(35));
	

dcl  (addr, index, length, min, null, reverse, rtrim, search) builtin;

dcl  cleanup condition;
%page;
/* Converts the control argument representation of an address into its internal form */

parse_address_control_args:
     entry (P_sci_ptr, P_argument_idx, P_parse_ca_options_ptr, P_address_ptr, P_code);

	sci_ptr = P_sci_ptr;
	argument_idx = P_argument_idx;

	parse_ca_options_ptr = P_parse_ca_options_ptr;
	if parse_ca_options.version ^= PARSE_CA_OPTIONS_VERSION_1 then do;
	     P_code = error_table_$unimplemented_version;
	     return;
	end;

	if (parse_ca_options.logbox_creation_mode < DONT_CREATE_MAILBOX)
	     | (parse_ca_options.logbox_creation_mode > SILENTLY_CREATE_MAILBOX)
	     | (parse_ca_options.savebox_creation_mode < DONT_CREATE_MAILBOX)
	     | (parse_ca_options.savebox_creation_mode > SILENTLY_CREATE_MAILBOX) | (parse_ca_options.mbz ^= ""b)
	then do;
	     P_code = error_table_$bad_subr_arg;
	     return;
	end;

	address_ptr, forum_search_list_ptr = null ();	/* for cleanup handler */
	system_area_ptr = get_system_free_area_ ();

	on condition (cleanup)
	     begin;
		if address_ptr ^= null () then call mail_system_$free_address (address_ptr, (0));
		if forum_search_list_ptr ^= null () then free forum_search_list_ptr -> sl_info in (system_area);
		forum_search_list_ptr = null ();
	     end;

	abort_the_parse = RETURN_FROM_PARSE_ADDRESS_CONTROL_ARGS_WITH_ERRORS;

	call ssu_$return_arg (sci_ptr, n_arguments, ("0"b), (null ()), (0));

	begin;					/* need a list of possible address modifiers */

dcl  host_indeces (n_arguments) fixed binary;

	     call parse_single_address (addr (host_indeces), RETURN_BADOPT_FROM_PARSE_ADDRESS_CONTROL_ARGS);
	end;

	code = 0;					/* success */


RETURN_FROM_PARSE_ADDRESS_CONTROL_ARGS:
	if forum_search_list_ptr ^= null () then free forum_search_list_ptr -> sl_info in (system_area);
	forum_search_list_ptr = null ();

	P_address_ptr = address_ptr;			/* might have an address even after error (^abort&validate) */
	P_argument_idx = argument_idx + 1;		/* to whatever's after the address (or error) */
	P_code = code;

	return;


/* Control arrives here after printing error messages when unable to parse an address control argument representation */

RETURN_FROM_PARSE_ADDRESS_CONTROL_ARGS_WITH_ERRORS:
	code = mlsys_et_$ca_parse_failed;
	go to RETURN_FROM_PARSE_ADDRESS_CONTROL_ARGS;


/* Control arrives here if an unrecognized control argument is encountered while parsing the address representation */

RETURN_BADOPT_FROM_PARSE_ADDRESS_CONTROL_ARGS:
	call abort_parse (sci_ptr, error_table_$badopt, """^a""", argument);
%page;
/* Converts the control argument representation of an address list into its internal form */

parse_address_list_control_args:
     entry (P_sci_ptr, P_argument_idx, P_parse_ca_options_ptr, P_address_list_version, P_normal_address_list_ptr,
	P_logsave_address_list_ptr, P_code);

	sci_ptr = P_sci_ptr;
	argument_idx = P_argument_idx;

	parse_ca_options_ptr = P_parse_ca_options_ptr;
	if parse_ca_options.version ^= PARSE_CA_OPTIONS_VERSION_1 then do;
	     P_code = error_table_$unimplemented_version;
	     return;
	end;

	if (parse_ca_options.logbox_creation_mode < DONT_CREATE_MAILBOX)
	     | (parse_ca_options.logbox_creation_mode > SILENTLY_CREATE_MAILBOX)
	     | (parse_ca_options.savebox_creation_mode < DONT_CREATE_MAILBOX)
	     | (parse_ca_options.savebox_creation_mode > SILENTLY_CREATE_MAILBOX) | (parse_ca_options.mbz ^= ""b)
	then do;
	     P_code = error_table_$bad_subr_arg;
	     return;
	end;

	if addr (P_normal_address_list_ptr) ^= addr (P_logsave_address_list_ptr) then
	     if (P_normal_address_list_ptr = P_logsave_address_list_ptr) & (P_normal_address_list_ptr ^= null ())
	     then do;
		/*** The two lists can't be the same list unless the actual parameters are identical; otherwise, when
		     the list is expanded, only one of the two parameters will be properly updated */
		P_code = error_table_$bad_subr_arg;
		return;
	     end;

	address_ptr, forum_search_list_ptr = null ();	/* for cleanup handler */
	system_area_ptr = get_system_free_area_ ();

	on condition (cleanup)
	     begin;
		if address_ptr ^= null () then call mail_system_$free_address (address_ptr, (0));
		if forum_search_list_ptr ^= null () then free forum_search_list_ptr -> sl_info in (system_area);
		forum_search_list_ptr = null ();
	     end;

	abort_the_parse = RETURN_FROM_PARSE_ADDRESS_LIST_CONTROL_ARGS_WITH_ERRORS;

	errors_detected = "0"b;			/* everything's OK so far */
	code = 0;

	call ssu_$return_arg (sci_ptr, n_arguments, ("0"b), (null ()), (0));

CONTINUE_ADDRESS_LIST_PARSE:
	begin;

dcl  host_indeces (n_arguments) fixed binary;

	     do while (argument_idx <= n_arguments);	/* while there's something left on the command/request line */
		call parse_single_address (addr (host_indeces), RETURN_FROM_PARSE_ADDRESS_LIST_CONTROL_ARGS);
		argument_idx = argument_idx + 1;	/* ... to first argument after the address */

		call mail_system_$get_address_type (address_ptr, address_type, (0));
		if (address_type = LOGBOX_ADDRESS) | (address_type = SAVEBOX_ADDRESS) then
		     call mail_system_$add_address (P_logsave_address_list_ptr, address_ptr, P_address_list_version,
			code);
		else call mail_system_$add_address (P_normal_address_list_ptr, address_ptr, P_address_list_version,
			code);
		if code ^= 0 then do;		/* ... can't add the address */
		     call mail_system_$free_address (address_ptr, (0));
		     go to RETURN_FROM_PARSE_ADDRESS_LIST_CONTROL_ARGS;
		end;
	     end;
	end;


RETURN_FROM_PARSE_ADDRESS_LIST_CONTROL_ARGS:
	if forum_search_list_ptr ^= null () then free forum_search_list_ptr -> sl_info in (system_area);
	forum_search_list_ptr = null ();

	P_argument_idx = argument_idx;		/* to whatever's after the address (or error) */

	if code ^= 0 then				/* some fatal error that the caller should hear about */
	     P_code = code;
	else if errors_detected then			/* let the caller know something wasn't quite right ... */
	     P_code = mlsys_et_$ca_parse_failed;
	else P_code = 0;				/* success */

	return;


/* Control arrives here after printing error messages when unable to parse an address control argument representation */

RETURN_FROM_PARSE_ADDRESS_LIST_CONTROL_ARGS_WITH_ERRORS:
	errors_detected = "1"b;			/* remember to set appropriate error code on return ... */
	code = 0;					/* ... and don't return this one if its the last address */

	argument_idx = argument_idx + 1;		/* to first argument after the error */

	if parse_ca_options.abort_on_errors then	/* give up right now (shouldn't ever actually get here) */
	     go to RETURN_FROM_PARSE_ADDRESS_LIST_CONTROL_ARGS;

	else do;					/* otherwise, keep looking */
	     if address_ptr ^= null () then do;
		call mail_system_$get_address_type (address_ptr, address_type, (0));
		if (address_type = LOGBOX_ADDRESS) | (address_type = SAVEBOX_ADDRESS) then
		     call mail_system_$add_address (P_logsave_address_list_ptr, address_ptr, P_address_list_version,
			(0));
		else call mail_system_$add_address (P_normal_address_list_ptr, address_ptr, P_address_list_version,
			(0));
		call mail_system_$free_address (address_ptr, (0));
	     end;					/* ... above free is a no-op if the add_address succeeds */
	     go to CONTINUE_ADDRESS_LIST_PARSE;
	end;
%page;
/* Actually converts the control argument representation of a single address into its internal representation */

parse_single_address:
     procedure (p_host_indeces_ptr, p_badopt_handler);

dcl  p_host_indeces_ptr pointer parameter;
dcl  p_badopt_handler label variable parameter;

dcl  host_indeces (n_arguments) fixed binary based (p_host_indeces_ptr);
dcl  n_hosts fixed binary;

dcl  address_string character (address_string_lth) unaligned based (address_string_ptr);
dcl  address_name character (address_name_lth) unaligned based (address_name_ptr);
dcl  address_comment character (address_comment_lth) unaligned based (address_comment_ptr);
dcl  (address_string_ptr, address_name_ptr, address_comment_ptr) pointer;
dcl  (address_string_lth, address_name_lth, address_comment_lth) fixed binary (21);

dcl  address_buffer_ptr pointer;
dcl  (address_buffer_lth, address_buffer_used) fixed binary (21);

dcl  foreign_system_name character (256) varying;
dcl  address_dirname character (168);
dcl  (address_ename, address_component) character (32);
dcl  trimmed_address_ename character (32) varying;

dcl  (continue_to_peek, include_name_and_comment) bit (1) aligned;
dcl  try_to_create bit (1) unaligned;

dcl  (preliminary_type, address_type, idx) fixed binary;


/**** format: ^indcomtxt */
/* Determine the probable type of address:  The true type can not be determined until after a check is made for host name
   qualification.  By first determining the probably type, sequences such as
	-save PATH -at HOST
   are permitted */
/**** format: indcomtxt */

	call ssu_$arg_ptr (sci_ptr, argument_idx, argument_ptr, argument_lth);

	if index (argument, "-") = 1 then		/* control argument representations ... */
	     if argument = "-user" then do;
		call get_next_argument ("A user name");
		preliminary_type = USER_OR_MTE_ADDRESS;
		address_string_ptr = argument_ptr;
		address_string_lth = argument_lth;
	     end;

	     else if argument = "-log" then do;
		preliminary_type = LOGBOX_ADDRESS;
		address_string_ptr = null ();		/* no explicit string associated with this type of address */
		address_string_lth = 0;
	     end;

	     else if (argument = "-save") | (argument = "-sv") then do;
		call get_next_argument ("A savebox pathname");
		preliminary_type = SAVEBOX_ADDRESS;
		address_string_ptr = argument_ptr;
		address_string_lth = argument_lth;
	     end;

	     else if (argument = "-mailbox") | (argument = "-mbx") then do;
		call get_next_argument ("A mailbox pathname");
		preliminary_type = MAILBOX_ADDRESS;
		address_string_ptr = argument_ptr;
		address_string_lth = argument_lth;
	     end;

	     else if (argument = "-meeting") | (argument = "-mtg") then do;
		call get_next_argument ("A forum meeting pathname");
		preliminary_type = FORUM_ADDRESS;
		address_string_ptr = argument_ptr;
		address_string_lth = argument_lth;
	     end;

	     else if (argument = "-mailing_list") | (argument = "-mls") then do;
		call get_next_argument ("A mailing list pathname");
		preliminary_type = MAILING_LIST_ADDRESS;
		address_string_ptr = argument_ptr;
		address_string_lth = argument_lth;
	     end;

	     else go to p_badopt_handler;		/* no other control arguments are legal at this point */

	else do;					/* non-control argument */
	     preliminary_type = MBX_USER_OR_MTE_ADDRESS;
	     address_string_ptr = argument_ptr;
	     address_string_lth = argument_lth;
	end;


/* Preliminary address type has been determined: check for qualifiers such as host names, address names, and address
   comments.  If multiple names or comments appear after an address, the last one provided will be used */

	n_hosts = 0;				/* no host names yet */

	address_name_ptr,				/* no address name or comment yet */
	     address_comment_ptr = addr (NULL_STRING);
	address_comment_lth, address_name_lth = 0;

	continue_to_peek = (argument_idx < n_arguments);	/* don't bother if there's nothing after the address */

	do while (continue_to_peek);

	     call ssu_$arg_ptr (sci_ptr, (argument_idx + 1), argument_ptr, argument_lth);

	     if (argument = "-at") | (argument = "-via") | (argument = "-name") | (argument = "-nm")
		| (argument = "-comment") | (argument = "-com") then do;

		/*** A recognized qualifier */
		argument_idx = argument_idx + 1;	/* we hereby claim this argument */

		if (argument = "-at") | (argument = "-via") then do;
		     call get_next_argument ("A host name");
		     n_hosts = n_hosts + 1;
		     host_indeces (n_hosts) = argument_idx;
		end;

		else if (argument = "-name") | (argument = "-nm") then do;
		     call get_next_argument ("A character string");
		     address_name_ptr = argument_ptr;
		     address_name_lth = argument_lth;
		end;

		else if (argument = "-comment") | (argument = "-com") then do;
		     call get_next_argument ("A character string");
		     address_comment_ptr = argument_ptr;
		     address_comment_lth = argument_lth;
		end;

		continue_to_peek = (argument_idx < n_arguments);
	     end;

	     else continue_to_peek = "0"b;		/* either the next address or something ... */
	end;


/* Have all address qualifiers: determine the actual address type assuming that the address were local ... */

	if n_hosts = 0 then				/* truly local */
	     if preliminary_type = USER_OR_MTE_ADDRESS then do;
		call mlsys_user_mte_syntax_$classify_and_validate ((address_string), is_mte_name, (""), (""), code);
		if code ^= 0 then			/* ... bad syntax */
		     call abort_parse (sci_ptr, code, "-user ^a", address_string);
		if is_mte_name then
		     preliminary_type = MAIL_TABLE_ADDRESS;
		else preliminary_type = USER_MAILBOX_ADDRESS;
	     end;

	     else if preliminary_type = MBX_USER_OR_MTE_ADDRESS then
		if search (address_string, "<>") ^= 0 then
		     preliminary_type = MAILBOX_ADDRESS;
		else do;
		     call mlsys_user_mte_syntax_$classify_and_validate ((address_string), is_mte_name, (""), (""),
			code);
		     if code ^= 0 then		/* ... bad syntax */
			call abort_parse (sci_ptr, code, "^a", address_string);
		     if is_mte_name then
			preliminary_type = MAIL_TABLE_ADDRESS;
		     else preliminary_type = USER_MAILBOX_ADDRESS;
		end;

	     else ;				/* a known type of local address */

	else /*** if n_hosts > 0 then */
	     if (preliminary_type = USER_OR_MTE_ADDRESS) | (preliminary_type = MBX_USER_OR_MTE_ADDRESS) then
	     preliminary_type = FOREIGN_ADDRESS;


/* Construct the address assuming that it's local:  If it's actually foreign, the address name and comment will be
   ommitted as they'll be included later in the actual foreign address */

	if (preliminary_type ^= FOREIGN_ADDRESS) then do;

	     include_name_and_comment = (n_hosts = 0);	/* don't include these unless this is the real address */

	     if preliminary_type = USER_MAILBOX_ADDRESS then do;
		if include_name_and_comment then
		     call mail_system_$create_user_mailbox_address ((address_string), (address_name),
			(address_comment), address_ptr, code);
		else call mail_system_$create_user_mailbox_address ((address_string), "", "", address_ptr, code);
		if code ^= 0 then call abort_parse (sci_ptr, code, "-user ^a", address_string);
	     end;

	     else if preliminary_type = LOGBOX_ADDRESS then do;
		if include_name_and_comment then
		     call mail_system_$create_logbox_address (mlsys_data_$user_id, (address_name), (address_comment),
			address_ptr, code);
		else call mail_system_$create_logbox_address (mlsys_data_$user_id, "", "", address_ptr, code);
		if code ^= 0 then call abort_parse (sci_ptr, code, "-log");
	     end;

	     else if preliminary_type = SAVEBOX_ADDRESS then do;
		if has_suffix (address_string, ".sv") then address_string_lth = address_string_lth - length (".sv");
		if search (address_string, "<>") = 0 then do;
		     call suffixed_name_$make (address_string, "sv.mbx", address_ename, code);
		     call search_paths_$find_dir ("mlsys", null(), address_ename, "", address_dirname, code);
		     if code = error_table_$noentry then
			call expand_pathname_$add_suffix (address_string, "sv.mbx", address_dirname, address_ename, code);
		     if code ^= 0 then call abort_parse (sci_ptr, code, "Searching the ""mlsys"" search list for ^a", address_ename);
		     end;
		else do;
		     call expand_pathname_$add_suffix (address_string, "sv.mbx", address_dirname, address_ename, code);
		     if code ^= 0 then call abort_parse (sci_ptr, code, "-save ^a", address_string);
		     end;

		call reject_starnames ("-save", address_dirname, address_ename, "");
		if include_name_and_comment then
		     call mail_system_$create_savebox_address (mlsys_data_$user_id, address_dirname, address_ename,
			(address_name), (address_comment), address_ptr, code);
		else call mail_system_$create_savebox_address (mlsys_data_$user_id, address_dirname, address_ename,
			"", "", address_ptr, code);
		if code ^= 0 then
		     call abort_parse (sci_ptr, code, "-save ^a", pathname_ (address_dirname, address_ename));
	     end;

	     else if preliminary_type = MAILBOX_ADDRESS then do;
		if search (address_string, "<>") = 0 then do;
		     call suffixed_name_$make (address_string, "mbx", address_ename, code);
		     if code ^= 0 then call abort_parse (sci_ptr, code, "^a", address_string);
		     call search_paths_$find_dir ("mlsys", null(), address_ename, "", address_dirname, code);
		     if code = error_table_$noentry then
			call expand_pathname_$add_suffix (address_string, "mbx", address_dirname, address_ename, code);
		     if code ^= 0 then call abort_parse (sci_ptr, code, "Searching the ""mlsys"" search list for ^a", address_ename);
		     end;
		else do;
		     call expand_pathname_$add_suffix (address_string, "mbx", address_dirname, address_ename, code);
		     if code ^= 0 then call abort_parse (sci_ptr, code, "-mailbox ^a", address_string);
		     end;
		call reject_starnames ("-mailbox", address_dirname, address_ename, "");
		if include_name_and_comment then
		     call mail_system_$create_mailbox_address (address_dirname, address_ename, (address_name),
			(address_comment), address_ptr, code);
		else call mail_system_$create_mailbox_address (address_dirname, address_ename, "", "", address_ptr,
			code);
		if code ^= 0 then
		     call abort_parse (sci_ptr, code, "-mailbox ^a", pathname_ (address_dirname, address_ename));
	     end;

	     else if preliminary_type = FORUM_ADDRESS then do;
		if search (address_string, "<>") = 0 then do;
		     /*** ... not a pathname: must find the meeting by search list */
		     if length (rtrim (address_string)) > length (address_ename) then
			call abort_parse (sci_ptr, error_table_$entlong, "-meeting ^a", address_string);
		     address_ename = address_string;
		     if ^(has_suffix (address_ename, ".forum") | has_suffix (address_ename, ".control")) then
			if length (rtrim (address_ename)) > (length (address_ename) - length (".forum")) then
			     call abort_parse (sci_ptr, error_table_$entlong, "-meeting ^a", address_ename);
		     call reject_starnames ("-meeting", "", address_ename, "");
		     if mlsys_psp_$forum_not_available () then
			/*** ... Forum PSP not here: we've done all we can; mlsys_transmit_ will do the rest */
			address_dirname = "";
		     else do;
			/*** ... time to scan the search list */
			if forum_search_list_ptr = null () then do;
			     call search_paths_$get ("forum", sl_control_default, "", null (), system_area_ptr,
				sl_info_version_1, forum_search_list_ptr, code);
			     if code ^= 0 then
				call abort_parse (sci_ptr, code, "Listing the ""forum"" search list.");
			end;
			if has_suffix (address_ename, ".forum") | has_suffix (address_ename, ".control") then
			     call search_forum_list (address_ename, address_dirname, code);
			else do;			/* ... try version 2 then version 1 meetings ... */
			     trimmed_address_ename = rtrim (address_ename);
			     call search_forum_list ((trimmed_address_ename || ".forum"), address_dirname, code);
			     if code = 0 then
				address_ename = trimmed_address_ename || ".forum";
			     else do;
				call search_forum_list ((trimmed_address_ename || ".control"), address_dirname,
				     code);
				if code = 0 then address_ename = trimmed_address_ename || ".control";
			     end;
			end;
			if code ^= 0 then		/* ... couldn't be found */
			     address_dirname = "";
		     end;
		end;
		else do;
		     /*** ... user has supplied a pathname */
		     call expand_pathname_ (address_string, address_dirname, address_ename, code);
		     if code ^= 0 then call abort_parse (sci_ptr, code, "-meeting ^a", address_string);
		     if ^(has_suffix (address_ename, ".forum") | has_suffix (address_ename, ".control")) then
			if length (rtrim (address_ename)) > (length (address_ename) - length (".forum")) then
			     call abort_parse (sci_ptr, error_table_$entlong, "-meeting ^a",
				pathname_ (address_dirname, address_ename));
		     call reject_starnames ("-meeting", address_dirname, address_ename, "");
		     if mlsys_psp_$forum_not_available () then
			;			/* ... no Forum PSP: we've done all we can */
		     else do;
			if ^(has_suffix (address_ename, ".forum") | has_suffix (address_ename, ".control")) then do;
			     /*** ... must determine the meeting version */
			     trimmed_address_ename = rtrim (address_ename);
			     address_ename = trimmed_address_ename || ".forum";
			     call forum_$get_forum_path (address_dirname, address_ename, ((168)" "), ((32)" "),
				code);
			     if code ^= 0 then	/* ... not version 2 */
				if (length (trimmed_address_ename) + length (".control"))
				     <= length (address_ename) then
				     address_ename = trimmed_address_ename || ".control";
			end;
		     end;
		end;
		if include_name_and_comment then
		     call mail_system_$create_forum_address (address_dirname, address_ename, (address_name),
			(address_comment), address_ptr, code);
		else call mail_system_$create_forum_address (address_dirname, address_ename, "", "", address_ptr,
			code);
		if code ^= 0 then
		     call abort_parse (sci_ptr, code, "-meeting ^[^a^s^;^s^a^]", (address_dirname = ""),
			address_ename, pathname_ (address_dirname, address_ename));
	     end;

	     else if preliminary_type = MAIL_TABLE_ADDRESS then do;
		if include_name_and_comment then
		     call mail_system_$create_mail_table_address ((address_string), (address_name), (address_comment),
			address_ptr, code);
		else call mail_system_$create_mail_table_address ((address_string), "", "", address_ptr, code);
		if code ^= 0 then call abort_parse (sci_ptr, code, "-user ^a", address_string);
	     end;

	     else /*** if preliminary_type = MAILING_LIST_ADDRESS then */
		do;
		call expand_pathname_$component_add_suffix (address_string, "mls", address_dirname, address_ename,
		     address_component, code);
		if code ^= 0 then call abort_parse (sci_ptr, code, "-mailing_list ^a", address_string);
		if search (address_string, "<>") = 0 then do;
		     address_dirname = "";
		     call search_paths_$find_dir ("mlsys", null(), address_ename, "", address_dirname, code);
		     if code = error_table_$noentry then
		         call expand_pathname_$component_add_suffix (address_string, "mls", address_dirname, address_ename,
		         address_component, code);
		     if code ^= 0 then call abort_parse (sci_ptr, code, "Searching the ""mlsys"" search list for ^a", address_ename);
		     end;
		call reject_starnames ("-mailing_list", address_dirname, address_ename, address_component);
		if include_name_and_comment then
		     call mail_system_$create_mailing_list_address (address_dirname, address_ename, address_component,
			(address_name), (address_comment), address_ptr, code);
		else call mail_system_$create_mailing_list_address (address_dirname, address_ename, address_component,
			"", "", address_ptr, code);
		if code ^= 0 then
		     call abort_parse (sci_ptr, code, "-mailing_list ^a",
			pathname_$component (address_dirname, address_ename, address_component));
	     end;
	end;


/* Construct the foreign "mailbox" name of the address from the printed representation of the above local address ... */

	address_buffer_ptr = null ();

	if n_hosts > 0 then do;			/* only if it's foreign ... */
	     if (preliminary_type = LOGBOX_ADDRESS) | (preliminary_type = SAVEBOX_ADDRESS) then do;
		call mail_system_$get_address_pathname (address_ptr, address_dirname, address_ename, ((32)" "), (0));
		call mail_system_$free_address (address_ptr, (0));
		call mail_system_$create_mailbox_address (address_dirname, address_ename, "", "", address_ptr, code);
		if code ^= 0 then
		     call abort_parse (sci_ptr, code, "Converting ^[-log^s^;-save ^a^] into a mailbox address.",
			(preliminary_type = LOGBOX_ADDRESS), pathname_ (address_dirname, address_ename));
	     end;

	     if preliminary_type ^= FOREIGN_ADDRESS then do;
		call cu_$grow_stack_frame (STACK_EXTENSION, address_buffer_ptr, (0));
		address_buffer_lth = 4 * STACK_EXTENSION;
						/* get an initial buffer */
		code = error_table_$smallarg;		/* need do until ... */
		do while (code = error_table_$smallarg);/* ... until the buffer's large enough to hold it */
		     address_buffer_used = 0;
		     call mlsys_utils_$format_address_field ("", address_ptr, -1, address_buffer_ptr,
			address_buffer_lth, address_buffer_used, code);
		     if code = error_table_$smallarg then do;
						/* ... not large enough yet */
			call cu_$grow_stack_frame (STACK_EXTENSION, (null ()), (0));
			address_buffer_lth = address_buffer_lth + (4 * STACK_EXTENSION);
		     end;
		end;
		address_string_ptr = address_buffer_ptr;/* have the "real" mailbox name now */
		address_string_lth = address_buffer_used;
		call mail_system_$free_address (address_ptr, (0));
	     end;					/* ... no longer need the local address */
	end;


/* Construct the true address if it's a foreign address */

	if (preliminary_type = FOREIGN_ADDRESS) | (n_hosts > 0) then do;

	     call ssu_$arg_ptr (sci_ptr, host_indeces (1), argument_ptr, argument_lth);
	     foreign_system_name = argument;		/* first host name is where the address resides */

	     begin;				/* build the explicit route (if any) */

dcl  1 local_address_route aligned,
       2 header like address_route.header,
       2 relays (min (1, (n_hosts - 1))) character (256) varying;

		local_address_route.version = ADDRESS_ROUTE_VERSION_1;
		local_address_route.n_relays = n_hosts - 1;
		do idx = 1 to local_address_route.n_relays;
		     call ssu_$arg_ptr (sci_ptr, host_indeces (idx + 1), argument_ptr, argument_lth);
		     local_address_route.relays (idx) = argument;
		end;

		if n_hosts > 1 then
		     call mail_system_$create_foreign_address ((address_string), foreign_system_name,
			addr (local_address_route), (address_name), (address_comment), address_ptr, code);
		else call mail_system_$create_foreign_address ((address_string), foreign_system_name, null (),
			(address_name), (address_comment), address_ptr, code);
	     end;

	     if code ^= 0 then call abort_parse (sci_ptr, code, "^a -at ^a", address_string, foreign_system_name);
	end;

	if address_buffer_ptr ^= null () then call cu_$shrink_stack_frame (address_buffer_ptr, (0));


/* Finally, if requested, verify that mail can be sent to the given address */

	if parse_ca_options.validate_addresses then do;

	     call mail_system_$validate_address (address_ptr, "0"b, code);

	     if code = mlsys_et_$no_mailbox then do;
		/*** Mailbox not found: check if logbox/savebox and create if necessary */
		call mail_system_$get_address_type (address_ptr, address_type, (0));
		if address_type = LOGBOX_ADDRESS then creation_mode = parse_ca_options.logbox_creation_mode;
		else if address_type = SAVEBOX_ADDRESS then creation_mode = parse_ca_options.savebox_creation_mode;
		else creation_mode = DONT_CREATE_MAILBOX;
		if creation_mode ^= DONT_CREATE_MAILBOX then do;
		     call mail_system_$get_address_pathname (address_ptr, address_dirname, address_ename, ((32)" "),
			(0));
		     if creation_mode = QUERY_TO_CREATE_MAILBOX then do;
			call command_query_$yes_no (try_to_create, 0, ssu_$get_subsystem_and_request_name (sci_ptr),
			     "", "Do you wish to create ^[your logbox^;the savebox ^a^]?",
			     (address_type = LOGBOX_ADDRESS), pathname_ (address_dirname, address_ename));
			if ^try_to_create then call abort_parse (sci_ptr, 0);
		     end;
		     if address_type = LOGBOX_ADDRESS then
			call mlsys_utils_$create_logbox (code);
		     else /*** if address_type = SAVEBOX_ADDRESS then */
			call mlsys_utils_$create_savebox (address_dirname, address_ename, code);
		     if code = 0 then
			if creation_mode = CREATE_AND_ANNOUNCE_MAILBOX then
			     call ssu_$print_message (sci_ptr, 0, "Created ^a.",
				pathname_ (address_dirname, address_ename));
		     if code = mlsys_et_$mailbox_exists then code = 0;
		end;
	     end;

	     if code ^= 0 then do;			/* the address is invalid ... */
		call mlsys_utils_$print_validate_results (sci_ptr, address_ptr, code);
		call abort_parse (sci_ptr, 0);
	     end;
	end;

	return;



/* Internal to parse_single_address: rejects pathnames containing starnames */

reject_starnames:
	procedure (p_control_argument, p_dirname, p_ename, p_component);

dcl  p_control_argument character (*) parameter;
dcl  p_dirname character (168);
dcl  (p_ename, p_component) character (32) parameter;
dcl  code fixed binary (35);

	     call check_star_name_$entry (p_ename, code); /* first check the entryname */
	     if code = 0 then			/* ... entryname OK: check the component name (if present) */
		if p_component ^= "" then call check_star_name_$entry (p_component, code);

	     if (code = 1) | (code = 2) then code = error_table_$nostars;

	     if code ^= 0 then			/* either a starname or invalid syntax */
		if p_dirname = "" then		/* ... no directory: pathname_ does the wrong thing here */
		     call abort_parse (sci_ptr, code, "^a ^a", p_control_argument, p_ename);
		else call abort_parse (sci_ptr, code, "^a ^a", p_control_argument,
			pathname_$component (p_dirname, p_ename, p_component));

	     return;

	end reject_starnames;



/* Internal to parse_single_address: scans the forum search list (already obtained above) for the given entryname */

search_forum_list:
	procedure (p_ename, p_dirname, p_code);

dcl  (p_ename, p_dirname) character (*) parameter;
dcl  p_code fixed binary (35) parameter;

dcl  ename character (32) initial ("");
dcl  idx fixed binary;

	     if length (rtrim (p_ename)) > length (ename) then do;
		p_code = error_table_$entlong;	/* ... constructed entry name is too long */
		return;
	     end;

	     p_code = 1;				/* need do until ... */

	     do idx = 1 to forum_search_list_ptr -> sl_info.num_paths while (p_code ^= 0);
		if forum_search_list_ptr -> sl_info.paths (idx).code = 0 then
		     call forum_$get_forum_path (forum_search_list_ptr -> sl_info.paths (idx).pathname, p_ename,
			((168)" "), ((32)" "), p_code);
		if p_code = 0 then p_dirname = forum_search_list_ptr -> sl_info.paths (idx).pathname;
	     end;

	     return;

	end search_forum_list;

     end parse_single_address;
%page;
/* Converts the control argument representation of a mailbox into the pathname of the mailbox */

parse_mailbox_control_args:
     entry (P_sci_ptr, P_argument_idx, P_parse_ca_options_ptr, P_mailbox_dirname, P_mailbox_ename, P_code);

	sci_ptr = P_sci_ptr;
	argument_idx = P_argument_idx;

	parse_ca_options_ptr = P_parse_ca_options_ptr;
	if parse_ca_options.version ^= PARSE_CA_OPTIONS_VERSION_1 then do;
	     P_code = error_table_$unimplemented_version;
	     return;
	end;

	if (parse_ca_options.logbox_creation_mode < DONT_CREATE_MAILBOX)
	     | (parse_ca_options.logbox_creation_mode > SILENTLY_CREATE_MAILBOX)
	     | (parse_ca_options.savebox_creation_mode < DONT_CREATE_MAILBOX)
	     | (parse_ca_options.savebox_creation_mode > SILENTLY_CREATE_MAILBOX) | (parse_ca_options.mbz ^= ""b)
	then do;
	     P_code = error_table_$bad_subr_arg;
	     return;
	end;

	mte_address_ptr, target_address_ptr = null ();	/* for cleanup handler */
	mailbox_idx = 0;

	mbx_ename = "";				/* indicates that we have no pathname */

	on condition (cleanup)
	     begin;
		if mte_address_ptr ^= null () then call mail_system_$free_address (mte_address_ptr, (0));
		if target_address_ptr ^= null () then call mail_system_$free_address (target_address_ptr, (0));
		if mailbox_idx ^= 0 then call mailbox_$close (mailbox_idx, (0));
		mailbox_idx = 0;
	     end;

	abort_the_parse = RETURN_FROM_PARSE_MAILBOX_CONTROL_ARGS_WITH_ERRORS;

	call ssu_$return_arg (sci_ptr, n_arguments, ("0"b), (null ()), (0));

	call ssu_$arg_ptr (sci_ptr, argument_idx, argument_ptr, argument_lth);


	if index (argument, "-") = 1 then		/* control argument representations ... */
	     if (argument = "-mailbox") | (argument = "-mbx") then do;
		call get_next_argument ("A mailbox pathname");
		call get_mailbox_pathname (argument);
	     end;

	     else if argument = "-user" then do;
		call get_next_argument ("A user name");
		call get_user_mailbox_pathname (argument, "0"b, ("0"b));
	     end;					/* ... non-null sci_ptr causes above to not return on error */

	     else if argument = "-log" then do;
		mailbox_type = USER_LOGBOX;
		/*** following call must work as the "constant" address is always correct */
		call mail_system_$get_address_pathname (mlsys_data_$user_logbox_address, mbx_dirname, mbx_ename,
		     ((32)" "), (0));
	     end;

	     else if (argument = "-save") | (argument = "-sv") then do;
		call get_next_argument ("A savebox pathname");
		call get_savebox_pathname (argument);
	     end;					/* ... non-null sci_ptr causes above to not return on error */

	     else call abort_parse (sci_ptr, error_table_$badopt, """^a""", argument);
						/* unrecognized control argument */

	else call parse_mailbox_text_internal (argument); /* not a control argument: specifies pathname somehow */


/* Here iff we have a mailbox pathname: verify its existence if requested by the caller */

	if mailbox_type = OTHER_MAILBOX then creation_mode = DONT_CREATE_MAILBOX;
	else if mailbox_type = USER_LOGBOX then creation_mode = parse_ca_options.logbox_creation_mode;
	else /*** if mailbox_type = SAVEBOX then */
	     creation_mode = parse_ca_options.savebox_creation_mode;

	if parse_ca_options.validate_addresses then do;
	     call mailbox_$open (mbx_dirname, mbx_ename, mailbox_idx, code);
	     if code = error_table_$moderr then code = 0; /* ... it's there although we can't access it */

	     if (code = error_table_$noentry) & (creation_mode ^= DONT_CREATE_MAILBOX) then do;
		if creation_mode = QUERY_TO_CREATE_MAILBOX then do;
		     call command_query_$yes_no (try_to_create, 0, ssu_$get_subsystem_and_request_name (sci_ptr), "",
			"Do you wish to create ^[your logbox^;the savebox ^a^]?", (mailbox_type = USER_LOGBOX),
			pathname_ (mbx_dirname, mbx_ename));
		     if ^try_to_create then call abort_parse (sci_ptr, 0);
		end;
		if mailbox_type = USER_LOGBOX then
		     call mlsys_utils_$create_logbox (code);
		else /*** if mailbox_type = SAVEBOX then */
		     call mlsys_utils_$create_savebox (mbx_dirname, mbx_ename, code);
		if code = 0 then			/* ... just created it ... */
		     if creation_mode = CREATE_AND_ANNOUNCE_MAILBOX then
			call ssu_$print_message (sci_ptr, 0, "Created ^a.", pathname_ (mbx_dirname, mbx_ename));
		if code = mlsys_et_$mailbox_exists then code = 0;
	     end;

	     if code ^= 0 then			/* ... can't find or create it */
		call abort_parse (sci_ptr, code, "^a", pathname_ (mbx_dirname, mbx_ename));
	end;

	code = 0;					/* success! */


RETURN_FROM_PARSE_MAILBOX_CONTROL_ARGS:			/* ... error case will transfer here */
	if mte_address_ptr ^= null () then call mail_system_$free_address (mte_address_ptr, (0));
	if target_address_ptr ^= null () then call mail_system_$free_address (target_address_ptr, (0));
	if mailbox_idx ^= 0 then call mailbox_$close (mailbox_idx, (0));
	mailbox_idx = 0;

	if mbx_ename ^= "" then do;			/* got a pathname (even after an error (^abort&validate)) */
	     P_mailbox_dirname = mbx_dirname;
	     P_mailbox_ename = mbx_ename;
	end;

	P_argument_idx = argument_idx + 1;		/* to first argument after the mailbox argument(s) */
	P_code = code;

	return;


/* Control arrives here after printing error messages when unable to parse a mailbox control argument representation */

RETURN_FROM_PARSE_MAILBOX_CONTROL_ARGS_WITH_ERRORS:
	code = mlsys_et_$ca_parse_failed;
	go to RETURN_FROM_PARSE_MAILBOX_CONTROL_ARGS;
%page;
/* Converts the printed representation of a mailbox pathname into the actual pathname:  This printed representation is
   equivalent to the non-control argument case of the control argument representation.  If the text contains either a "<"
   or ">", it is interpreted as a pathname.  If it ends in either ".sv.mbx" or ".mbx", it is interpreted as a savebox or
   mailbox pathname, respectively.  Otherwise, the text is an entryname, and a check is made for a mailbox in the working
   directory with that name; if no mailbox is found, a check is made for a savebox; if no savebox is found, the text is
   interpreted as a user name and the corresponding default mailbox or mail table entry is used */

parse_mailbox_text:
     entry (P_mailbox_text, P_mailbox_dirname, P_mailbox_ename, P_code);

	sci_ptr = null ();				/* don't print anything: just return a code */

	mte_address_ptr, target_address_ptr = null ();	/* for cleanup handler */
	mailbox_idx = 0;

	on condition (cleanup)
	     begin;
		if mte_address_ptr ^= null () then call mail_system_$free_address (mte_address_ptr, (0));
		if target_address_ptr ^= null () then call mail_system_$free_address (target_address_ptr, (0));
		if mailbox_idx ^= 0 then call mailbox_$close (mailbox_idx, (0));
		mailbox_idx = 0;
	     end;

	abort_the_parse = RETURN_FROM_PARSE_MAILBOX_TEXT;

	call parse_mailbox_text_internal (P_mailbox_text);/* do it */

	P_mailbox_dirname = mbx_dirname;		/* here iff all was OK */
	P_mailbox_ename = mbx_ename;
	P_code = 0;

RETURN_FROM_PARSE_MAILBOX_TEXT:
	if mte_address_ptr ^= null () then call mail_system_$free_address (mte_address_ptr, (0));
	if target_address_ptr ^= null () then call mail_system_$free_address (target_address_ptr, (0));
	if mailbox_idx ^= 0 then call mailbox_$close (mailbox_idx, (0));
	mailbox_idx = 0;

	return;



/* Actually parses the printed representation of a mailbox pathname: called by several entrypoints */

parse_mailbox_text_internal:
     procedure (p_text);

dcl  p_text character (*) parameter;

dcl  saved_mbx_dirname character (168);
dcl  saved_mbx_ename character (32);
dcl  saved_code fixed binary (35);

dcl  trimmed_ename character (32) varying;
dcl  not_user_name bit (1) aligned;
dcl  use_search_paths bit (1) aligned;
dcl  search_paths_$get entry (char(*), bit(36), char(*), ptr, ptr, fixed bin, ptr, fixed bin(35));
dcl  loop_idx fixed bin;
dcl  idx fixed bin;
dcl  mlsys_search_list_ptr ptr;

          use_search_paths = "0"b;
	system_area_ptr = get_system_free_area_ ();
          if search (p_text, "<>") = 0 then do;
	     call search_paths_$get ("mlsys", sl_control_default, "", null(), system_area_ptr, sl_info_version_1, mlsys_search_list_ptr, code);
	     loop_idx = mlsys_search_list_ptr -> sl_info.num_paths;
	     use_search_paths = "1"b;
	     mbx_ename = p_text;
	end;
          else do;
	     loop_idx = 1;
	     call expand_pathname_ (p_text, mbx_dirname, mbx_ename, code);
	     if code ^= 0 then do;			/* bad pathname ... */
		saved_code = code;
		call get_user_mailbox_pathname (p_text, "1"b, not_user_name);
		if not_user_name then call abort_parse (sci_ptr, saved_code, "^a", p_text);
		else if mailbox_exists () then return;	/* ... but it was a valid User_id/MTE name */
		else if ^is_mte_name & (code = error_table_$no_dir) then
		     call abort_parse (sci_ptr, saved_code, "^a", p_text);
		else call abort_parse (sci_ptr, code, "^a", pathname_ (mbx_dirname, mbx_ename));
		end;
	     end;                                         /* looked like a pathname */
	saved_mbx_ename = mbx_ename;
	if code = 0 then do;
	     code =1;
	     do idx = 1 to loop_idx while (code ^= 0);
		if use_search_paths then mbx_dirname = mlsys_search_list_ptr -> sl_info.paths(idx).pathname;
		
		     

	saved_mbx_dirname = mbx_dirname;		/* needed in case nothing works */
	saved_code = 0;				/* this will be set later to describe first failure */

	trimmed_ename = rtrim (mbx_ename);		/* needed for suffix checking */

	call check_star_name_$entry (mbx_ename, code);
	if (code = 1) | (code = 2) then code = error_table_$nostars;
	if code ^= 0 then do;			/* bad entry name ... */
	     saved_code = code;
	     go to TRY_USER_NAME_OR_MTE_HUERISTIC;	/* ... is OK for now: might be an MTE name */
	end;

	if has_suffix (trimmed_ename, ".sv.mbx") | has_suffix (trimmed_ename, ".sv") then go to TRY_SAVEBOX_HUERISTIC;
						/* ends with ".sv" or ".sv.mbx": try first as a savebox */


/* Try it as an ordinary mailbox */

	mailbox_type = OTHER_MAILBOX;

	if ^has_suffix (trimmed_ename, ".mbx") then do;	/* need to add "mbx" suffix */
	     if (length (trimmed_ename) + length (".mbx")) > length (mbx_ename) then do;
		saved_code = error_table_$entlong;
		go to TRY_USER_NAME_OR_MTE_HUERISTIC;
	     end;
	     else mbx_ename = trimmed_ename || ".mbx";
	end;

	if mailbox_exists () then
	     return;				/* found it! */
	else do;					/* something went wrong */
	     saved_code = code;
	     if trimmed_ename = mbx_ename then		/* ... ends with ".mbx": don't try as a savebox */
		go to TRY_USER_NAME_OR_MTE_HUERISTIC;
	end;


/* Try it as a savebox */

TRY_SAVEBOX_HUERISTIC:
	mailbox_type = SAVEBOX;

	if has_suffix (trimmed_ename, ".sv.mbx") then ;
	else if has_suffix (trimmed_ename, ".sv") then do;/* need to add just ".mbx" suffix */
	     if (length (trimmed_ename) + length (".mbx")) > length (mbx_ename) then do;
		saved_code = error_table_$entlong;
		go to TRY_USER_NAME_OR_MTE_HUERISTIC;
	     end;
	     else mbx_ename = trimmed_ename || ".mbx";
	end;
	else do;					/* no suffix: have already tried it as a mailbox */
	     if (length (trimmed_ename) + length (".sv.mbx")) > length (mbx_ename) then
		go to TRY_USER_NAME_OR_MTE_HUERISTIC;
	     mbx_ename = trimmed_ename || ".sv.mbx";
	end;

	if mailbox_exists () then
	     return;				/* found it! */
	else do;					/* something went wrong */
	     if saved_code = 0 then saved_code = code;
	end;


/* Try it as a User_id or mail table entry (MTE) name */

TRY_USER_NAME_OR_MTE_HUERISTIC:
	call get_user_mailbox_pathname (p_text, "1"b, not_user_name);
	if not_user_name & (idx = loop_idx) then do;	/* doesn't look like a User_id or MTE name */
	     if use_search_paths then
		call abort_parse (sci_ptr, saved_code, "Looking in mlsys search paths for ^a^[.mbx^]",
		saved_mbx_ename, ^has_suffix (saved_mbx_ename, ".mbx"));		
	     else call abort_parse (sci_ptr, saved_code, "^a^[.mbx^]", pathname_ (saved_mbx_dirname, saved_mbx_ename),
		^has_suffix (saved_mbx_ename, ".mbx"));
	     end;
	

	if mailbox_exists () then return;		/* found it! */
	else if idx = loop_idx then
	     if ^is_mte_name & (code = error_table_$no_dir) then
	     call abort_parse (sci_ptr, saved_code, "^a^[.mbx^]", pathname_ (saved_mbx_dirname, saved_mbx_ename),
		^has_suffix (saved_mbx_ename, ".mbx"));
	     else call abort_parse (sci_ptr, code, "^a", pathname_ (mbx_dirname, mbx_ename));
	mbx_ename = saved_mbx_ename;             /* In case we go round again */
	end;
     end;


/* Internal to parse_mailbox_text_internal: checks if a given mailbox exists */

mailbox_exists:
	procedure () returns (bit (1) aligned);

	     call mailbox_$open (mbx_dirname, mbx_ename, mailbox_idx, code);
	     if code = error_table_$moderr then code = 0;

	     if mailbox_idx ^= 0 then call mailbox_$close (mailbox_idx, (0));

	     return ((code = 0));

	end mailbox_exists;

     end parse_mailbox_text_internal;
%page;
/* Get the pathname of an ordinary mailbox */

get_mailbox_pathname:
     procedure (p_text);

dcl  p_text character (*) parameter;

     if search (p_text, "<>") > 0 then do;
	call expand_pathname_$add_suffix (p_text, "mbx", mbx_dirname, mbx_ename, code);
	if code ^= 0 then call abort_parse (sci_ptr, code, "^a", p_text);
	end;
     else do;
	/* phx21283, RL - modified following if/else statement to handle .mbx suffix correctly */
	if ^has_suffix (p_text, ".mbx") then do;
	     call suffixed_name_$make (p_text, "mbx", mbx_ename, code);
	     if code ^= 0 then call abort_parse (sci_ptr, code, "^a", p_text);
          end;
	else
	     mbx_ename = p_text;
          call search_paths_$find_dir ("mlsys", null(), mbx_ename, "", mbx_dirname, code);
	if code = error_table_$noentry then
	     call expand_pathname_$add_suffix (p_text, "mbx", mbx_dirname, mbx_ename, code);
	if code ^= 0 then call abort_parse (sci_ptr, code, "Searching the ""mlsys"" searchlist for ^a.", mbx_ename);
	     end;
	call check_star_name_$entry (mbx_ename, code);
	if code ^= 0 then
	     if (code = 1) | (code = 2) then
		call abort_parse (sci_ptr, error_table_$nostars, "^a", pathname_ (mbx_dirname, mbx_ename));
	     else call abort_parse (sci_ptr, code, "^a", pathname_ (mbx_dirname, mbx_ename));	

	mailbox_type = OTHER_MAILBOX;			/* success */

	return;

     end get_mailbox_pathname;




/* Get the pathname of a savebox */

get_savebox_pathname:
     procedure (p_text);

dcl  p_text character (*) parameter;
     
	if has_suffix (p_text, ".sv") then
	     call expand_pathname_$add_suffix (p_text, "mbx", mbx_dirname, mbx_ename, code);
	else call expand_pathname_$add_suffix (p_text, "sv.mbx", mbx_dirname, mbx_ename, code);
	if code ^= 0 then call abort_parse (sci_ptr, code, "^a", p_text);

          if search (p_text, "<>") = 0 then do;             /* ... we were given a pathname */
	     mbx_dirname = "";
	     call search_paths_$find_dir ("mlsys", null(), mbx_ename, "", mbx_dirname, code);
	     if code = error_table_$noentry then
		if has_suffix (p_text, ".sv") then
		     call expand_pathname_$add_suffix (p_text, "mbx", mbx_dirname, mbx_ename, code);
		else call expand_pathname_$add_suffix (p_text, "sv.mbx", mbx_dirname, mbx_ename, code);
	     if code ^= 0 then call abort_parse (sci_ptr, code, "Searching the ""mlsys"" searchlist for ^a.", mbx_ename);
	     end;

	 call check_star_name_$entry (mbx_ename, code);
	 if code ^= 0 then
	      if (code = 1) | (code = 2) then
		call abort_parse (sci_ptr, error_table_$nostars, "^a", pathname_ (mbx_dirname, mbx_ename));
	      else call abort_parse (sci_ptr, code, "^a", pathname_ (mbx_dirname, mbx_ename));

	mailbox_type = SAVEBOX;			/* success */

	return;

     end get_savebox_pathname;
%page;
/* Get the pathname of the mailbox for the given user name which might be a mail table entry (MTE) name */

get_user_mailbox_pathname:
     procedure (p_name, p_ok_if_not_user_name, p_not_user_name);

dcl  p_name character (*) parameter;
dcl  p_ok_if_not_user_name bit (1) aligned parameter;	/* ON => don't abort if given name isn't a User_id/MTE name */
dcl  p_not_user_name bit (1) aligned parameter;		/* set ON => supplied name isn't User_id/MTE name */

	call mlsys_user_mte_syntax_$classify_and_validate ((p_name), is_mte_name, person_id, project_id, code);
	if code ^= 0 then				/* bad syntax ... */
	     if p_ok_if_not_user_name then do;		/* ... is OK when doing pathname hueristic */
		p_not_user_name = "1"b;
		return;
	     end;
	     else call abort_parse (sci_ptr, code, "^a", p_name);

	if is_mte_name then do;			/* a mail table entry */
	     /*** following call won't fail because the syntax has already been verified */
	     call mail_system_$create_mail_table_address ((p_name), "", "", mte_address_ptr, (0));
	     call mail_system_$get_mail_table_address (mte_address_ptr, target_address_ptr, code);
	     if code = mlsys_et_$mte_not_found then	/* ... no entry in the mail table ... */
		if p_ok_if_not_user_name then do;	/* ... is OK when doing pathname hueristic */
		     p_not_user_name = "1"b;
		     return;
		end;
	     if code ^= 0 then call abort_parse (sci_ptr, code, "^a", p_name);
	     call mail_system_$get_address_type (target_address_ptr, address_type, (0));
	     if (address_type ^= USER_MAILBOX_ADDRESS) & (address_type ^= LOGBOX_ADDRESS)
		& (address_type ^= SAVEBOX_ADDRESS) & (address_type ^= MAILBOX_ADDRESS) then
		call abort_parse (sci_ptr, mlsys_et_$mte_not_mailbox, "^a", p_name);
	     call mail_system_$get_address_pathname (target_address_ptr, mbx_dirname, mbx_ename, ((32)" "), (0));
	     if (address_type = USER_MAILBOX_ADDRESS) | (address_type = MAILBOX_ADDRESS) then
		mailbox_type = OTHER_MAILBOX;
	     else if address_type = LOGBOX_ADDRESS then mailbox_type = USER_LOGBOX;
	     else /*** if address_type = SAVEBOX_ADDRESS then */
		mailbox_type = SAVEBOX;
	end;

	else do;					/* a User_id (Person_id.Project_id) */
	     mailbox_type = OTHER_MAILBOX;		/* ... don't try to create it */
	     mbx_dirname = ">udd>" || rtrim (project_id) || ">" || person_id;
	     mbx_ename = rtrim (person_id) || ".mbx";
	end;

	p_not_user_name = "0"b;			/* get here iff all is OK */

	return;

     end get_user_mailbox_pathname;
%page;
/* Aborts the parse:  For the parse_mailbox_text entrypoint, it sets the return code; for all other entrpyoints, it prints
   the given message */

abort_parse:
     procedure () options (variable);

dcl  code fixed binary (35) based (code_ptr);
dcl  code_ptr pointer;

	if sci_ptr = null () then do;			/* return the error code to the caller */
	     call cu_$arg_ptr (2, code_ptr, (0), (0));
	     P_code = code;
	end;

	else do;					/* print the error message */
	     if parse_ca_options.abort_on_errors then
		call cu_$generate_call (ssu_$abort_line, cu_$arg_list_ptr ());
	     else call cu_$generate_call (ssu_$print_message, cu_$arg_list_ptr ());
	end;

	go to abort_the_parse;			/* go perform appropriate cleanup */

     end abort_parse;



/* Fetch the next argument */

get_next_argument:
     procedure (p_string);

dcl  p_string character (*) parameter;			/* for error messages if not present */

	if (argument_idx = n_arguments) then
	     call abort_parse (sci_ptr, error_table_$noarg, "^a must be given after ""^a"".", p_string, argument);

	argument_idx = argument_idx + 1;

	call ssu_$arg_ptr (sci_ptr, argument_idx, argument_ptr, argument_lth);

	return;

     end get_next_argument;
%page;
/* Returns "1"b if the given suffix is present on the supplied name */

dcl  has_suffix
	generic (has_suffix_varying when (character (*) varying, character (*)),
	has_suffix_nonvarying when (character (*), character (*)));


has_suffix_nonvarying:
     procedure (p_name, p_suffix) returns (bit (1) aligned);

dcl  (p_name, p_suffix) character (*) parameter;

	return ((index (reverse (rtrim (p_name)), reverse (p_suffix)) = 1));

     end has_suffix_nonvarying;


has_suffix_varying:
     procedure (p_name, p_suffix) returns (bit (1) aligned);

dcl  p_name character (*) varying parameter;
dcl  p_suffix character (*) parameter;

	return ((index (reverse (p_name), reverse (p_suffix)) = 1));

     end has_suffix_varying;
%page;
%include mlsys_parse_ca_options;
%page;
%include mlsys_address_list;
%page;
%include mlsys_address_types;
%page;
%include mlsys_address_route;
%page;
%include mlsys_data;
%page;
%include mlsys_internal_data;
%page;
%include sl_info;

%include sl_control_s;

     end mlsys_parse_control_args_;
