/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(86-01-09,Herbst), approve(86-03-25,MCR7367),
     audit(86-04-28,Margolin), install(86-05-22,MR12.0-1059):
     Added $set_message_switch.
  2) change(86-02-27,Herbst), approve(86-03-25,MCR7367),
     audit(86-04-28,Margolin), install(86-05-22,MR12.0-1059):
     Changed $set_message_switch to work only if the caller has "d" extended
     access to the mailbox.
  3) change(86-03-25,Herbst), approve(86-03-25,MCR7367),
     audit(86-04-28,Margolin), install(86-05-22,MR12.0-1059):
     Changed P_switch_type from fixed bin to char (4) aligned.
  4) change(86-03-25,Herbst), approve(86-03-25,MCR7367),
     audit(86-04-28,Margolin), install(86-05-22,MR12.0-1059):
     Changed $set_message_switch to return error code from
     mailbox_$update_message without conversion; fixed to copy input args.
  5) change(86-04-28,Herbst), approve(86-04-28,MCR7367),
     audit(86-04-28,Margolin), install(86-05-22,MR12.0-1059):
     Fixed $set_message_switch to return error code if no access to set switch.
  6) change(86-06-03,Herbst), approve(86-06-03,MCR7432), audit(86-06-30,Wong),
     install(86-06-30,MR12.0-1080):
     Fixed to zero unused portions of mail_format.
  7) change(87-03-09,Lippard), approve(87-03-18,MECR0001),
     audit(87-03-12,Fawcett), install(87-03-19,MR12.1-1002):
     Modified to strip control characters from message comment field.
  8) change(87-05-08,Lippard), approve(87-04-20,MCR7669),
     audit(87-05-11,Fawcett), install(87-05-20,MR12.1-1032):
     Formal installation to close out MECR0001.
  9) change(89-09-12,Lee), approve(89-09-12,MCR8131),
     audit(89-09-25,LZimmerman), install(89-10-02,MR12.3-1079):
     phx20316, phx19688 (Mail 491) - modified the entry deliver_acknowledgement
     to try using the sender_id (delivery_by id) instead of giving up if the
     acknowledge_to field refers to a mail table entry which does not expand to
     a local mailbox; reformatting.
                                                   END HISTORY COMMENTS */


/* format: off */

/* Mailbox management for the Multics Mail System */

/* Created:  June 1983 by G. Palter from parts of mlsys_user_interface_ */
/* Modified: 12 April 1984 by G. Palter to fix error #0441 -- when mail_system_$read_new_messages must grow the mailbox
      structure to accomodate the new messages, it properly frees the old structure but does not update its internal
      records to reflect this fact.  Subsequently, when mail_system_$close_mailbox is called, it will attempt to free the
      storage occupied by the old mailbox structure again resulting in damage to the mail system's area */

/* format: on,style4,delnl,insnl,ifthenstmt,ifthen */


mlsys_mailbox_mgr_:
     procedure () options (rename ((alloc_, mlsys_storage_mgr_$allocate)));

	return;					/* not an entrypoint */


/* Common Parameters */

dcl  P_code fixed binary (35) parameter;

dcl  P_mailbox_dirname character (*) parameter;		/* pathname of directory containing the mailbox */
dcl  P_mailbox_ename character (*) parameter;		/* entryname of the mailbox: suffix is optional */
dcl  P_mailbox_ptr pointer parameter;			/* -> user-visible mailbox structure (input/output) */
dcl  P_message_ptr pointer parameter;			/* -> user-visible message structure */


/* get_message_counts Parameters */

dcl  P_include_by_type bit (1) aligned parameter;		/* ON => include breakdown by type (ordinary/interactive) */
dcl  P_n_messages fixed binary parameter;		/* set to # of messages in the mailbox */
dcl  P_n_ordinary_messages fixed binary parameter;	/*     ...     ordinary messages in the mailbox */
dcl  P_n_interactive_messages fixed binary parameter;	/*     ...     interactive messages in the mailbox */


/* open_mailbox Parameters */

dcl  P_open_options_ptr pointer parameter;		/* -> options describing how to open the mailbox */
dcl  P_mailbox_version character (8) parameter;		/* identifies the version of the mailbox structure expected to
						   be returned to the caller */


/* read_new_messages Parameters */

dcl  P_n_new_messages fixed binary parameter;		/* set to # of newly arrived messages in the mailbox */
dcl  P_n_new_ordinary_messages fixed binary parameter;	/* ... etc. ... */
dcl  P_n_new_interactive_messages fixed binary parameter;	/* ... */


/* read_message and read_message_canonical_form Parameters */

dcl  P_message_idx fixed binary parameter;		/* identifies which message is to be read */


/* read_message_canonical_form and read_message_canonical_form_p Parameters */

dcl  P_message_canonical_form_ptr pointer parameter;	/* set -> the canonical representation of the message */
dcl  P_message_canonical_form_lth fixed binary (21) parameter;


/* get_message_mf_if_canonical Parameters */

dcl  P_message_mf_ptr pointer parameter;		/* set -> the mail_format containing the canonical message */
dcl  P_message_mf_extension_ptr pointer parameter;	/* set -> the mf_extension for the above mail_format */

/* close_mailbox Parameters */

dcl  P_close_options_ptr pointer parameter;		/* defines options for closing the mailbox */

/* set_message_switch Parameters */

dcl  P_switch_type char (4) aligned;			/* seen switch, etc.; in rdm_switch_types.incl.pl1 */
dcl  P_switch_value bit (1) aligned;			/* value to set it to */


/* Local copies of parameters */

dcl  code fixed binary (35);

dcl  mailbox_dirname character (168);
dcl  mailbox_ename character (32);

dcl  (n_messages, n_new_messages) fixed binary;
dcl  (n_messages_by_type, n_new_messages_by_type) fixed binary dimension (ORDINARY_MESSAGES:INTERACTIVE_MESSAGES);

dcl  message_idx fixed binary;
dcl  switch_type char (4) aligned;
dcl  switch_value bit (1) aligned;

/* Internal description of a mailbox opened by the Multics mail system */

dcl  1 mailbox_info aligned based (mailbox_info_ptr),
       2 dirname character (168) unaligned,		/* pathname of directory containing the mailbox */
       2 ename character (32) unaligned,		/* entryname of mailbox */
       2 address_ptr pointer,				/* -> address of this mailbox */
       2 mailbox_ptr pointer,				/* -> user-visible mailbox description */
       2 delete_error_info_ptr pointer,			/* -> delete_error_info currently signalled to the user */
       2 type fixed binary,				/* type of mailbox: default, logbox, savebox, etc. */
       2 index fixed binary,				/* ring-1 mailbox index */
       2 mode_flags,				/* current effective access */
         3 add bit (1) unaligned,
         3 delete bit (1) unaligned,
         3 read bit (1) unaligned,
         3 own bit (1) unaligned,
         3 status bit (1) unaligned,			/* provides access to message count, salvaged bit */
         3 wakeup bit (1) unaligned,			/* permits sending of interactive and mail notifications */
         3 urgent bit (1) unaligned,			/* not used by present mail system ... */
         3 pad bit (29) unaligned,
       2 message_selection_mode fixed binary,		/* types of messages returned (ordinary, interactive) */
       2 sender_selection_mode fixed binary,		/* sender of messages returned (all, own, not-own) */
       2 message_reading_level fixed binary,		/* how much of message to read from mailbox */
       2 n_messages fixed binary,			/* total # of messages read from the mailbox */
       2 n_messages_by_type (ORDINARY_MESSAGES:INTERACTIVE_MESSAGES) fixed binary,
						/* ... and by message type */
       2 n_deleted_messages fixed binary,		/* # of messages marked for deletion on closing */
       2 flags,
         3 salvaged bit (1) unaligned,			/* ON => mailbox has been salvaged */
         3 use_own_mode bit (1) unaligned,		/* ON => mailbox_$own* entries needed to read from mailbox */
         3 pending_deletion bit (1) unaligned,		/* ON => there is an interrupted deletion in progress */
         3 ring1_privilege bit (1) unaligned,		/* ON => user had ring-1 privilege when computing
						   the can_be_deleted flags of the messages in the mailbox */
         3 pad bit (32) unaligned,
       2 last_message_key bit (72) aligned,		/* identifies last message read from the mailbox (if any) */
       2 last_message_area_ptr pointer,			/* -> last segment (least full) used to hold the messages */
       2 message_blocks,				/* chain of messages which are read in blocks (see below) */
         3 first pointer,
         3 last pointer;

dcl  mailbox_info_ptr pointer;


/* Message area temporary segment definition:  Due to a mis-feature of the area package, the area passed to the ring-1
   primitives can not be an extensible area.  Thus, to read a mailbox, the mail system uses a set of non-extensible areas
   each of which resides in a separate temporary segment */

dcl  1 mailbox_message_area aligned based (mailbox_message_area_ptr),
       2 previous pointer,				/* -> previous temporary segment in the list */
       2 flags,
         3 virgin_area bit (1) unaligned,		/* ON => nothing has been allocated in this segment yet */
         3 pad bit (71) unaligned,			/* force even-word boundary */
       2 area area;					/* the actual area */

dcl  mailbox_message_area_ptr pointer;


/* Message block definition: contains the description of up to 32 messages in the mailbox and is used to minimize
   allocations */

dcl  1 message_block aligned based (message_block_ptr),
       2 chain,					/* chain of message blocks for this mailbox */
         3 previous pointer,
         3 next pointer,
       2 n_used fixed binary,				/* # of slots used in this block */
       2 pad bit (36),
       2 messages (32) like im_message_info;		/* the messages in this block */

dcl  (message_block_ptr, next_message_block_ptr) pointer;


/* Definition of the reserved data in the user-visible description of a mailbox */

dcl  1 mailbox_reserved_data aligned based (addr (mailbox.reserved)),
       2 info_ptr pointer,				/* -> the corresponding mailbox_info structure */
       2 n_messages_allocated fixed binary,		/* actual size of the messages array */
       2 pad bit (36);


/* Internal description of an in-mailbox message maintained by the Multics mail system */

dcl  1 im_message_info aligned based (im_message_info_ptr),
       2 mailbox_info_ptr pointer,			/* -> the description of mailbox where this message resides */
       2 area_ptr pointer,				/* -> area into which the message was read from ring-1 */
       2 key bit (72) aligned,			/* ring-1 key for this message */
       2 format fixed binary,				/* format of the message as stored in ring-1 */
       2 type fixed binary,				/* type of message: ordinary or interactive */
       2 flags,
         3 mra_valid bit (1) unaligned,			/* ON => message has been read from ring-1 */
         3 can_be_deleted bit (1) unaligned,		/* ON => user has sufficient access to delete this message */
         3 to_be_deleted bit (1) unaligned,		/* ON => user has requested that this message be deleted */
         3 already_deleted bit (1) unaligned,		/* ON => this message is deleted: this is an empty slot now */
         3 requests_acknowledgement bit (1) unaligned,	/* ON => acknowledgement requested and user has access */
         3 pad bit (31) unaligned,
       2 message_ptr pointer,				/* -> user-visible description of the message */
       2 mra like mseg_return_args;			/* ring-1 information about this message */

dcl  im_message_info_ptr pointer;


/* Possible formats of a message when it is stored in a ring-1 mailbox */

/* format: off */
dcl (FIPS98_FORMAT_MESSAGE	     initial (1),		/* FIPS-98 encoded message (binary format) */
     MAIL_FORMAT_MESSAGE	     initial (2),		/* mail_format (old ASCII format) */
     UNKNOWN_FORMAT_MESSAGE	     initial (3))		/* unrecognized format (neither of the above) */
	fixed binary static options (constant);
/* format: on */


/* Remaining declarations */

dcl  1 local_mra aligned like mseg_return_args;

dcl  1 mra aligned based (mra_ptr) like mseg_return_args;
dcl  mra_ptr pointer;

dcl  message_bits bit (mra.ms_len) aligned based (mra.ms_ptr);

dcl  system_area area based (system_area_ptr);
dcl  system_area_ptr pointer;

dcl  1 user_privileges aligned,
       2 privileges unaligned like aim_template.privileges,
       2 pad bit (18) unaligned;

dcl  mailbox_idx fixed binary;
dcl  mailbox_mode bit (36) aligned;
dcl  mailbox_salvaged_bit bit (1) aligned;

dcl  (new_mailbox_ptr, saved_message_block_ptr) pointer;
dcl  saved_message_block_n_used fixed binary;

dcl  (message_format, message_type) fixed binary;

dcl  (first_idx, idx) fixed binary;

dcl  deletion_failed bit (1) aligned;

dcl  (author_is_ack_recipient, multiple_authors, is_redistributed) bit (1) aligned;

dcl  MAIL_SYSTEM_ character (32) static options (constant) initial ("mail_system_");

dcl  NUL character (1) static options (constant) initial (" ");
dcl  NL character (1) static options (constant) initial ("
");

dcl  MAIL_FORMAT_VERSION_2 fixed binary static options (constant) initial (2);
dcl  MAIL_FORMAT_VERSION_3 fixed binary static options (constant) initial (3);

/* format: off */
dcl (error_table_$bad_index,
     error_table_$bad_segment, error_table_$bad_subr_arg, error_table_$entlong,
     error_table_$messages_deferred, error_table_$messages_off, error_table_$moderr, error_table_$noalloc,
     error_table_$no_info, error_table_$no_message, error_table_$seg_unknown, error_table_$unimplemented_version,
     error_table_$wakeup_denied, mlsys_et_$all_messages_deleted, mlsys_et_$already_marked_for_deletion,
     mlsys_et_$bad_acknowledge_to, mlsys_et_$cant_be_deleted, mlsys_et_$cant_send_acknowledgement,
     mlsys_et_$cant_update_message, mlsys_et_$deletion_pending, mlsys_et_$message_already_read,
     mlsys_et_$missing_acknowledge_to, mlsys_et_$no_ack_needed, mlsys_et_$no_message_canonical_form,
     mlsys_et_$no_more_messages, mlsys_et_$no_o_permission, mlsys_et_$no_pending_deletion, mlsys_et_$no_r_permission,
     mlsys_et_$no_s_permission, mlsys_et_$not_mailbox, mlsys_et_$not_marked_for_deletion,
     mlsys_et_$some_messages_not_deleted)
	fixed binary (35) external;
/* format: on */

dcl  sys_info$max_seg_size fixed binary (19) external;

dcl  aim_check_$equal entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
dcl  define_area_ entry (pointer, fixed binary (35));
dcl  get_authorization_ entry () returns (bit (72) aligned);
dcl  get_privileges_ entry () returns (bit (36) aligned);
dcl  get_system_free_area_ entry () returns (pointer);
dcl  mailbox_$check_salv_bit_index entry (fixed binary, bit (1) aligned, bit (1) aligned, fixed binary (35));
dcl  mailbox_$close entry (fixed binary, fixed binary (35));
dcl  mailbox_$compact_index entry (fixed binary, float binary, fixed binary (35));
dcl  mailbox_$delete_index entry (fixed binary, bit (72) aligned, fixed binary (35));
dcl  mailbox_$get_mode_index entry (fixed binary, bit (36) aligned, fixed binary (35));
dcl  mailbox_$incremental_read_index entry (fixed binary, pointer, bit (2), bit (72) aligned, pointer, fixed binary (35));
dcl  mailbox_$open entry (character (*), character (*), fixed binary, fixed binary (35));
dcl  mailbox_$open_if_full
	entry (character (*), character (*), bit (1) aligned, fixed binary, fixed binary, fixed binary (35));
dcl  mailbox_$own_incremental_read_index
	entry (fixed binary, pointer, bit (2), bit (72) aligned, pointer, fixed binary (35));
dcl  mailbox_$own_read_index entry (fixed binary, pointer, bit (1), pointer, fixed binary (35));
dcl  mailbox_$read_index entry (fixed binary, pointer, bit (1), pointer, fixed binary (35));
dcl  mailbox_$update_message_index entry (fixed binary, fixed binary (24), bit (72) aligned, pointer, fixed binary (35));
dcl  mailbox_$wakeup_add_index
	entry (fixed binary, pointer, fixed binary (24), bit (36) aligned, bit (72) aligned, fixed binary (35));
dcl  mlsys_address_list_mgr_$add_address entry (pointer, pointer, character (8), fixed binary (35));
dcl  mlsys_address_mgr_$compare_addresses entry (pointer, pointer, fixed binary (35)) returns (bit (1) aligned);
dcl  mlsys_address_mgr_$create_mailbox_address
	entry (character (*), character (*), character (*) varying, character (*) varying, pointer, fixed binary (35));
dcl  mlsys_address_mgr_$create_user_mailbox_address
	entry (character (*) varying, character (*) varying, character (*) varying, pointer, fixed binary (35));
dcl  mlsys_address_mgr_$decrement_reference_count entry (pointer);
dcl  mlsys_address_mgr_$free_address entry (pointer, fixed binary (35));
dcl  mlsys_address_mgr_$get_address_pathname
	entry (pointer, character (*), character (*), character (*), fixed binary (35));
dcl  mlsys_address_mgr_$get_address_type entry (pointer, fixed binary, fixed binary (35));
dcl  mlsys_address_mgr_$get_mail_table_address entry (pointer, pointer, fixed binary (35));
dcl  mlsys_address_mgr_$increment_reference_count entry (pointer);
dcl  mlsys_fips98_$decode_message
	entry ((*) bit (9) unaligned, character (8), pointer, pointer, fixed binary (71), bit (1) aligned, pointer,
	fixed binary (35));
dcl  mlsys_format_$format_date_time_field
	entry (character (*) varying, fixed binary (71), bit (1) aligned, fixed binary, pointer, fixed binary (21),
	fixed binary (21), fixed binary (35));
dcl  mlsys_mailbox_utils_$classify_mailbox_address entry (pointer, fixed binary, fixed binary (35));
dcl  mlsys_message_id_mgr_$encode_local_id entry (fixed binary (71), bit (72) aligned);
dcl  mlsys_message_mgr_$add_body_section_no_copy entry (pointer, pointer, fixed binary, fixed binary (35));
dcl  mlsys_message_mgr_$create_im_message entry (character (8), pointer, pointer, fixed binary (35));
dcl  mlsys_message_mgr_$free_message entry (pointer, fixed binary (35));
dcl  mlsys_message_mgr_$verify_im_message entry (pointer, pointer, fixed binary (35)) returns (bit (1) aligned);
dcl  mlsys_misc_utils_$get_best_address_name entry (pointer, character (*) varying, fixed binary (35));
dcl  mlsys_parse_text_$parse_im_message_text
	entry (character (*) aligned, character (8), pointer, pointer, fixed binary (71), bit (1) aligned,
	bit (1) aligned, pointer, fixed binary (35));
dcl  mlsys_storage_mgr_$get_temp_segment entry (pointer, fixed binary (35));
dcl  mlsys_storage_mgr_$release_temp_segment entry (pointer, fixed binary (35));
dcl  sub_err_ entry () options (variable);

dcl  (area, cleanup, record_quota_overflow) condition;

dcl  (addr, addwordno, baseno, binary, before, copy, currentsize, divide, hbound, index, length, maxlength, mod, null,
     rel, reverse, rtrim, string, substr, unspec) builtin;
%page;
/* Determine the number of messages in a mailbox including a breakdown by type if requested */

get_message_counts:
     entry (P_mailbox_dirname, P_mailbox_ename, P_include_by_type, P_n_messages, P_n_ordinary_messages,
	P_n_interactive_messages, P_code);

	mailbox_dirname = P_mailbox_dirname;		/* copy inputs */
	call add_suffix (P_mailbox_ename, "mbx", mailbox_ename, P_code);
	if P_code ^= 0 then return;			/* won't fit */

	system_area_ptr = get_system_free_area_ ();

	mra_ptr = addr (local_mra);			/* to make references to message_bits valid */

	mailbox_idx = 0;				/* for cleanup handler */
	local_mra.ms_ptr = null ();

	on condition (cleanup)
	     begin;
	     if mailbox_idx ^= 0 then do;
		call mailbox_$close (mailbox_idx, (0));
		mailbox_idx = 0;
	     end;
	     if local_mra.ms_ptr ^= null () then do;
		free message_bits in (system_area);
		local_mra.ms_ptr = null ();
	     end;
	end;


	call mailbox_$open_if_full (mailbox_dirname, mailbox_ename, ("0"b), n_messages, mailbox_idx, code);
	if code ^= 0 then do;			/* couldn't open the mailbox */
	     if code = error_table_$moderr then		/* translate to more specific explanation */
		code = mlsys_et_$no_s_permission;
	     go to RETURN_FROM_GET_MESSAGE_COUNTS;
	end;

	P_n_messages = n_messages;			/* always return this value */

	if ^P_include_by_type then go to RETURN_FROM_GET_MESSAGE_COUNTS;
						/* only wanted the total */

	if n_messages = 0 then do;			/* mailbox is empty */
	     P_n_ordinary_messages, P_n_interactive_messages = 0;
	     go to RETURN_FROM_GET_MESSAGE_COUNTS;
	end;


/* Count by message type is requested: verify that the caller has read access to the mailbox and, if they do, read each
   message in the mailbox, determine its type, and increment the appropriate counter */

	call mailbox_$get_mode_index (mailbox_idx, mailbox_mode, code);
	if code ^= 0 then go to RETURN_FROM_GET_MESSAGE_COUNTS;

	if (mailbox_mode & R_MBX_ACCESS) ^= R_MBX_ACCESS then do;
	     code = mlsys_et_$no_r_permission;
	     go to RETURN_FROM_GET_MESSAGE_COUNTS;
	end;

	n_messages_by_type (*) = 0;			/* an array is easier to use */

	call mailbox_$read_index (mailbox_idx, system_area_ptr, "0"b, addr (local_mra), code);
	if code ^= 0 then go to RETURN_FROM_GET_MESSAGE_COUNTS;
						/* must be at least one from above */

	do while (code ^= error_table_$no_message);	/* read all the messages */
	     call classify_message (local_mra.ms_ptr, local_mra.ms_len, message_format, message_type);
	     n_messages_by_type (message_type) = n_messages_by_type (message_type) + 1;
	     free message_bits in (system_area);	/* done with this one: now get next message (if any) */
	     call mailbox_$incremental_read_index (mailbox_idx, system_area_ptr, "01"b, local_mra.ms_id,
		addr (local_mra), code);
	     if (code ^= 0) & (code ^= error_table_$no_message) then go to RETURN_FROM_GET_MESSAGE_COUNTS;
	end;

	P_n_ordinary_messages = n_messages_by_type (ORDINARY_MESSAGES);
	P_n_interactive_messages = n_messages_by_type (INTERACTIVE_MESSAGES);

	code = 0;					/* entire operation was successfull */


/* Cleanup */

RETURN_FROM_GET_MESSAGE_COUNTS:
	if mailbox_idx ^= 0 then call mailbox_$close (mailbox_idx, (0));

	if local_mra.ms_ptr ^= null () then free message_bits in (system_area);

	P_code = code;				/* other output parameters have already been set */

	return;
%page;
/* Open a mailbox */

open_mailbox:
     entry (P_mailbox_dirname, P_mailbox_ename, P_open_options_ptr, P_mailbox_version, P_mailbox_ptr, P_code);

	if P_mailbox_version ^= MAILBOX_VERSION_2 then do;
	     P_code = error_table_$unimplemented_version;
	     return;
	end;

	open_options_ptr = P_open_options_ptr;

	if open_options.version ^= OPEN_OPTIONS_VERSION_2 then do;
	     P_code = error_table_$unimplemented_version;
	     return;
	end;

	if ((open_options.message_selection_mode < ALL_MESSAGES)
	     | (open_options.message_selection_mode > INTERACTIVE_MESSAGES))
	     | ((open_options.sender_selection_mode < ACCESSIBLE_MESSAGES)
	     | (open_options.sender_selection_mode > NOT_OWN_MESSAGES))
	     | ((open_options.message_reading_level < READ_KEYS) | (open_options.message_reading_level > READ_MESSAGES))
	then do;					/* incorrectly specified option */
	     P_code = error_table_$bad_subr_arg;
	     return;
	end;

	mailbox_dirname = P_mailbox_dirname;
	call add_suffix (P_mailbox_ename, "mbx", mailbox_ename, P_code);
	if P_code ^= 0 then return;			/* entryname is too long */

	mailbox_info_ptr = null ();			/* for cleanup handler */

	on condition (cleanup)
	     begin;
	     if mailbox_info_ptr ^= null () then call release_mailbox_info ();
	end;


/* Setup the internal data structure describing the mailbox, open the mailbox, and verify that the caller has the
   appropriate access to the mailbox to read the requested messages */

	allocate mailbox_info in (mlsys_area) set (mailbox_info_ptr);

	mailbox_info.dirname = mailbox_dirname;		/* fill in minimal information about the mailbox */
	mailbox_info.ename = mailbox_ename;

	mailbox_info.index = 0;			/* the following assignments keep the cleanup handler happy */
	mailbox_info.mailbox_ptr,			/* ... */
	     mailbox_info.address_ptr, mailbox_info.last_message_area_ptr, mailbox_info.delete_error_info_ptr,
	     mailbox_info.message_blocks = null ();

	call mailbox_$open (mailbox_info.dirname, mailbox_info.ename, mailbox_info.index, code);
	if code ^= 0 then go to ERROR_RETURN_FROM_OPEN_MAILBOX;
						/* couldn't open the mailbox (sigh) */

	call mailbox_$get_mode_index (mailbox_info.index, mailbox_mode, code);
	if code ^= 0 then go to ERROR_RETURN_FROM_OPEN_MAILBOX;

	string (mailbox_info.mode_flags) = mailbox_mode;	/* simpler to reference this way */

	string (user_privileges) = get_privileges_ ();	/* determine if the user has ring-1 privilege */
	mailbox_info.ring1_privilege = user_privileges.ring1;

	if (open_options.sender_selection_mode = ACCESSIBLE_MESSAGES) then
	     if mailbox_info.mode_flags.read then do;	/* can get all messages */
		mailbox_info.sender_selection_mode = ALL_MESSAGES;
		mailbox_info.use_own_mode = "0"b;
	     end;
	     else if mailbox_info.mode_flags.own then do; /* can only get our messages */
		mailbox_info.sender_selection_mode = OWN_MESSAGES;
		mailbox_info.use_own_mode = "1"b;
	     end;
	     else do;				/* can't get at anything */
		code = error_table_$moderr;
		go to ERROR_RETURN_FROM_OPEN_MAILBOX;
	     end;

	else do;					/* specific type of mode requested */
	     mailbox_info.sender_selection_mode = open_options.sender_selection_mode;
	     if (open_options.sender_selection_mode = ALL_MESSAGES)
		| (open_options.sender_selection_mode = NOT_OWN_MESSAGES) then
		if mailbox_info.mode_flags.read then	/* have appropriate access */
		     mailbox_info.use_own_mode = "0"b;
		else do;
		     code = mlsys_et_$no_r_permission;
		     go to ERROR_RETURN_FROM_OPEN_MAILBOX;
		end;
	     else if (open_options.sender_selection_mode = OWN_MESSAGES) then
		if mailbox_info.mode_flags.own then	/* have appropriate access */
		     mailbox_info.use_own_mode = "1"b;
		else do;
		     code = mlsys_et_$no_o_permission;
		     go to ERROR_RETURN_FROM_OPEN_MAILBOX;
		end;
	end;

	mailbox_info.message_selection_mode = open_options.message_selection_mode;
	mailbox_info.message_reading_level = open_options.message_reading_level;

	on condition (area)
	     begin;
	     code = error_table_$noalloc;		/* ran out of room (shouldn't happen, but...) */
	     go to ERROR_RETURN_FROM_OPEN_MAILBOX;
	end;

	call mlsys_address_mgr_$create_mailbox_address (mailbox_dirname, mailbox_ename, "", "",
	     mailbox_info.address_ptr, (0));
	call mlsys_address_mgr_$increment_reference_count (mailbox_info.address_ptr);
						/* prevent user accidently freeing it */
	call mlsys_mailbox_utils_$classify_mailbox_address (mailbox_info.address_ptr, mailbox_info.type, (0));

	if mailbox_info.mode_flags.status then do;	/* have proper permission to get salvaged bit ... */
	     call mailbox_$check_salv_bit_index (mailbox_info.index, (mailbox_info.mode_flags.delete),
		mailbox_salvaged_bit, code);		/* ... turn it off if user "owns" mbx */
	     if code ^= 0 then go to ERROR_RETURN_FROM_OPEN_MAILBOX;
						/* ... shouldn't happen, but ... */
	     mailbox_info.salvaged = mailbox_salvaged_bit;
	end;
	else mailbox_info.salvaged = "0"b;		/* don't have access to get this bit: non-fatal error */


/* Read the messages from the mailbox: classify each message by type and determine if it meets the caller's selection
   criteria */

	mailbox_info.n_messages,			/* haven't read any messages yet */
	     mailbox_info.n_messages_by_type (*), mailbox_info.n_deleted_messages = 0;
	mailbox_info.last_message_key = ""b;
	mailbox_info.message_blocks = null ();

	do while ("1"b);				/* loop is exited by other means ... */

	     call read_next_message ();		/* sets im_message_info_ptr for us ... */
	     if code ^= 0 then			/* message wasn't read because ...  */
		if code = error_table_$no_message then
		     go to ALL_MESSAGES_HAVE_BEEN_READ; /* ... reached the end of the mailbox OK */
		else go to ERROR_RETURN_FROM_OPEN_MAILBOX;
						/* ... unexpected problem */

	     if mailbox_info.message_selection_mode ^= ALL_MESSAGES then
		if im_message_info.type ^= mailbox_info.message_selection_mode then do;
EXCLUDE_CURRENT_MESSAGE:				/* this message is the wrong type */
		     free message_bits in (mailbox_message_area.area);
		     message_block.n_used = message_block.n_used - 1;
		     go to READ_NEXT_MESSAGE;		/* zap! this slot is no longer in use */
		end;

	     if mailbox_info.sender_selection_mode = NOT_OWN_MESSAGES then
		if message_from_self (im_message_info.mra.sender_id) then go to EXCLUDE_CURRENT_MESSAGE;
						/* "own" messages ignore project distinctions */

	     mailbox_info.n_messages = mailbox_info.n_messages + 1;
						/* this message is OK */
	     mailbox_info.n_messages_by_type (im_message_info.type) =
		mailbox_info.n_messages_by_type (im_message_info.type) + 1;

READ_NEXT_MESSAGE:
	end;


/* All messages have been read: create the mailbox structure to be returned to the caller */

ALL_MESSAGES_HAVE_BEEN_READ:
	mailbox_n_messages =			/* allow for late arrivals */
	     mlsys_data_$mailbox_allocation
	     *
	     divide ((mailbox_info.n_messages + mlsys_data_$mailbox_allocation), mlsys_data_$mailbox_allocation, 17, 0);

	allocate mailbox in (mlsys_area) set (mailbox_ptr);
	mailbox_info.mailbox_ptr = mailbox_ptr;		/* need to remember where it is */

	mailbox.version = MAILBOX_VERSION_2;		/* fill it in ... */

	mailbox_reserved_data.info_ptr = mailbox_info_ptr;/* given caller's mailbox_ptr need to find our data */
	mailbox_reserved_data.n_messages_allocated = mailbox_n_messages;

	mailbox.mailbox_type = mailbox_info.type;	/* just copy data from internal structure ... */
	mailbox.mailbox_address = mailbox_info.address_ptr;
	mailbox.mailbox_dirname = mailbox_info.dirname;
	mailbox.mailbox_ename = mailbox_info.ename;
	mailbox.message_selection_mode = mailbox_info.message_selection_mode;
	mailbox.sender_selection_mode = mailbox_info.sender_selection_mode;
	mailbox.message_reading_level = mailbox_info.message_reading_level;
	mailbox.mode = string (mailbox_info.mode_flags);

	string (mailbox.flags) = ""b;
	mailbox.salvaged = mailbox_info.salvaged;

	mailbox.n_messages = mailbox_info.n_messages;	/* user visible message count */
	mailbox.n_ordinary_messages = mailbox_info.n_messages_by_type (ORDINARY_MESSAGES);
	mailbox.n_interactive_messages = mailbox_info.n_messages_by_type (INTERACTIVE_MESSAGES);
	mailbox.n_deleted_messages = mailbox_info.n_deleted_messages;
						/* even though it's zero, be safe */


/* And now fill in the data for the messages ... */

	message_idx = 0;

	do message_block_ptr = mailbox_info.message_blocks.first repeat (next_message_block_ptr)
	     while (message_block_ptr ^= null ());
	     next_message_block_ptr = message_block.next;

	     do idx = 1 to message_block.n_used;
		im_message_info_ptr = addr (message_block.messages (idx));
		message_idx = message_idx + 1;	/* next slot in the user's structure */

		mailbox.messages (message_idx).key = im_message_info.key;

		if mailbox_info.message_reading_level = READ_KEYS then
		     mailbox.messages (message_idx).message_ptr = null ();

		else /*** if mailbox_info.message_reading_level = READ_MESSAGES then */
		     do;
		     call construct_user_message ();	/* construct the user-visible message structure */
		     mailbox.messages (message_idx).message_ptr = im_message_info.message_ptr;
		end;
	     end;
	end;


/* Success: return the mailbox structure to the caller */

	P_mailbox_ptr = mailbox_ptr;

	P_code = 0;

	return;


/* Control transfers here if an error is detected while opening the mailbox */

ERROR_RETURN_FROM_OPEN_MAILBOX:
	if mailbox_info_ptr ^= null () then call release_mailbox_info ();

	P_code = code;

	return;
%page;
/* Check an open mailbox to see if any new messages have arrived and, if so, read them from the mailbox and return them to
   the caller in the (possibly reallocated) user-visible mailbox structure */

read_new_messages:
     entry (P_mailbox_ptr, P_n_new_messages, P_n_new_ordinary_messages, P_n_new_interactive_messages, P_code);

	mailbox_ptr = copy_ptr (P_mailbox_ptr);

	if ^verify_mailbox () then do;		/* caller didn't supply a mailbox structure */
	     P_code = mlsys_et_$not_mailbox;
	     return;
	end;

	mailbox_info_ptr = mailbox_reserved_data.info_ptr;/* need our internal description */

	if mailbox_info.pending_deletion then do;	/* caller must complete the previous operation */
	     P_code = mlsys_et_$deletion_pending;
	     return;
	end;

	im_message_info_ptr = null ();		/* for the internal procedure ... */
	call recompute_mailbox_access (code);		/* revalidate our access to the mailbox */
	if code ^= 0 then do;			/* ... failed (mailbox deleted?) */
	     P_code = code;
	     return;
	end;

	if mailbox_info.use_own_mode then		/* check if the user still has proper access */
	     if ^mailbox_info.mode_flags.own then do;	/* no longer have permission to read our messages */
		P_code = mlsys_et_$no_o_permission;
		return;
	     end;
	     else ;				/* still has the access */
	else if ^mailbox_info.mode_flags.read then do;	/* no longer have permission to read messages */
	     P_code = mlsys_et_$no_r_permission;
	     return;
	end;


/* Read and classify the new messages in the mailbox: discard any new messages that are not of the proper type */

	new_mailbox_ptr = null ();			/* for cleanup handler */
	n_new_messages = 0;

	on condition (cleanup) call release_new_mailbox_info ();

	on condition (area)
	     begin;				/* in case there isn't enough room */
	     code = error_table_$noalloc;
	     go to ERROR_RETURN_FROM_READ_NEW_MESSAGES;
	end;

	n_new_messages = 0;				/* haven't found any new messages yet */
	n_new_messages_by_type (*) = 0;

	saved_message_block_ptr = mailbox_info.message_blocks.last;
	saved_message_block_n_used = saved_message_block_ptr -> message_block.n_used;
						/* record where last old message lives */

	do while ("1"b);				/* loop is exited by other means ... */

	     call read_next_message ();		/* sets im_message_info_ptr for us ... */
	     if code ^= 0 then			/* message wasn't read because ... */
		if code = error_table_$no_message then
		     go to READ_ALL_NEW_MESSAGES;	/* ... reached the end of the mailbox OK */
		else go to ERROR_RETURN_FROM_READ_NEW_MESSAGES;

	     if mailbox_info.message_selection_mode ^= ALL_MESSAGES then
		if im_message_info.type ^= mailbox_info.message_selection_mode then do;
EXCLUDE_NEW_MESSAGE:				/* this message is the wrong type */
		     free message_bits in (mailbox_message_area.area);
		     message_block.n_used = message_block.n_used - 1;
		     go to READ_NEXT_NEW_MESSAGE;	/* zap! this slot is no longer in use */
		end;

	     if mailbox_info.sender_selection_mode = NOT_OWN_MESSAGES then
		if message_from_self (im_message_info.mra.sender_id) then go to EXCLUDE_NEW_MESSAGE;
						/* "own" messages ignore project distinctions */

	     n_new_messages = n_new_messages + 1;	/* another new message */
	     n_new_messages_by_type (im_message_info.type) = n_new_messages_by_type (im_message_info.type) + 1;

READ_NEXT_NEW_MESSAGE:
	end;


/* All new messages have been read: reallocate the user-visible mailbox structure if necessary */

READ_ALL_NEW_MESSAGES:
	message_idx = 0;				/* for cleanup handler */

	if (mailbox_info.n_messages + n_new_messages) <= mailbox_reserved_data.n_messages_allocated then
	     new_mailbox_ptr = mailbox_ptr;		/* old structure has enough room */

	else do;					/* need a new structure */
	     mailbox_n_messages = mailbox_info.n_messages + n_new_messages;
	     mailbox_n_messages =			/* ... allow room for later growth */
		mailbox_n_messages + mlsys_data_$mailbox_allocation
		- mod (mailbox_n_messages, mlsys_data_$mailbox_allocation);

	     allocate mailbox in (mlsys_area) set (new_mailbox_ptr);

	     new_mailbox_ptr -> mailbox.version = MAILBOX_VERSION_2;
						/* fill it in ... */

	     addr (new_mailbox_ptr -> mailbox.reserved) -> mailbox_reserved_data.info_ptr = mailbox_info_ptr;
	     addr (new_mailbox_ptr -> mailbox.reserved) -> mailbox_reserved_data.n_messages_allocated =
		mailbox_n_messages;

	     new_mailbox_ptr -> mailbox.mailbox_type = mailbox_info.type;
	     new_mailbox_ptr -> mailbox.mailbox_address = mailbox_info.address_ptr;
	     new_mailbox_ptr -> mailbox.mailbox_dirname = mailbox_info.dirname;
	     new_mailbox_ptr -> mailbox.mailbox_ename = mailbox_info.ename;
	     new_mailbox_ptr -> mailbox.message_selection_mode = mailbox_info.message_selection_mode;
	     new_mailbox_ptr -> mailbox.sender_selection_mode = mailbox_info.sender_selection_mode;
	     new_mailbox_ptr -> mailbox.message_reading_level = mailbox_info.message_reading_level;
	     new_mailbox_ptr -> mailbox.mode = string (mailbox_info.mode_flags);

	     string (new_mailbox_ptr -> mailbox.flags) = ""b;
	     new_mailbox_ptr -> mailbox.salvaged = mailbox_info.salvaged;

	     new_mailbox_ptr -> mailbox.n_deleted_messages = mailbox_info.n_deleted_messages;
						/* only this one isn't going to be changed here */

	     do message_idx = 1 to mailbox.n_messages;
		new_mailbox_ptr -> mailbox.messages (message_idx) = mailbox.messages (message_idx);
	     end;					/* copy old messages' data */
	end;


/* And now fill in the data for the new messages ... */

	message_idx = mailbox_info.n_messages;		/* # of messages already present in user's structure */

	do message_block_ptr = saved_message_block_ptr repeat (next_message_block_ptr)
	     while (message_block_ptr ^= null ());
	     next_message_block_ptr = message_block.next;

	     if message_block_ptr = saved_message_block_ptr then
		first_idx = saved_message_block_n_used + 1;
						/* first block starts in the middle */
	     else first_idx = 1;

	     do idx = first_idx to message_block.n_used;
		im_message_info_ptr = addr (message_block.messages (idx));
		message_idx = message_idx + 1;	/* get appropriate slot in user's structure */

		new_mailbox_ptr -> mailbox.messages (message_idx).key = im_message_info.key;

		if mailbox_info.message_reading_level = READ_KEYS then
		     new_mailbox_ptr -> mailbox.messages (message_idx).message_ptr = null ();

		else /*** if mailbox_info.message_reading_level = READ_MESSAGES then */
		     do;
		     call construct_user_message ();	/* create the user-visible message structure */
		     mailbox.messages (message_idx).message_ptr = im_message_info.message_ptr;
		end;
	     end;
	end;


/* Success: update message counts, release old mailbox structure (if needed) and return */

	mailbox_info.n_messages = mailbox_info.n_messages + n_new_messages;
	mailbox_info.n_messages_by_type (*) = mailbox_info.n_messages_by_type (*) + n_new_messages_by_type (*);

	if mailbox_ptr ^= new_mailbox_ptr then do;
	     free mailbox_ptr -> mailbox in (mlsys_area);
	     mailbox_info.mailbox_ptr, mailbox_ptr = new_mailbox_ptr;
	end;

	mailbox.n_messages = mailbox_info.n_messages;
	mailbox.n_ordinary_messages = mailbox_info.n_messages_by_type (ORDINARY_MESSAGES);
	mailbox.n_interactive_messages = mailbox_info.n_messages_by_type (INTERACTIVE_MESSAGES);

	P_n_new_messages = n_new_messages;		/* let caller know how much is new */
	P_n_new_ordinary_messages = n_new_messages_by_type (ORDINARY_MESSAGES);
	P_n_new_interactive_messages = n_new_messages_by_type (INTERACTIVE_MESSAGES);

	P_mailbox_ptr = mailbox_ptr;			/* reflect changes */

	if n_new_messages > 0 then
	     P_code = 0;				/* something new alright */
	else P_code = mlsys_et_$no_more_messages;

	return;


/* Control transfers here if an error is detected while checking for new messages */

ERROR_RETURN_FROM_READ_NEW_MESSAGES:
	call release_new_mailbox_info ();		/* cleanup */

	P_code = code;

	return;
%page;
/* "Read" the requested message:  Actually all appropriate messages in the mailbox are read by open_mailbox or
   read_new_messages due to the lack of appropriate ring-1 mailbox primitives.  However, an application program should
   specify a message_reading_level of READ_KEYS to avoid the overhead of converting all messages in the mailbox when it
   may actually only examine a few messages in the mailbox.  To this end, this entrypoint simply converts the data read
   from ring-1 into the corresponding message structure */

read_message:
     entry (P_mailbox_ptr, P_message_idx, P_code);

	mailbox_ptr = copy_ptr (P_mailbox_ptr);

	if ^verify_mailbox () then do;
	     P_code = mlsys_et_$not_mailbox;
	     return;
	end;

	mailbox_info_ptr = mailbox_reserved_data.info_ptr;/* need our internal description */

	if mailbox_info.pending_deletion then do;	/* data structures are inconsistent */
	     P_code = mlsys_et_$deletion_pending;
	     return;
	end;

	message_idx = 0;				/* find the requested message */

	do message_block_ptr = mailbox_info.message_blocks.first repeat (next_message_block_ptr)
	     while (message_block_ptr ^= null ());
	     next_message_block_ptr = message_block.next;
	     do idx = 1 to message_block.n_used;
		im_message_info_ptr = addr (message_block.messages (idx));
		if ^im_message_info.already_deleted then do;
		     message_idx = message_idx + 1;	/* ... a message that still counts */
		     if message_idx = P_message_idx then go to FOUND_REQUESTED_MESSAGE;
		end;
	     end;
	end;

	P_code = error_table_$bad_index;		/* no such message */
	return;

FOUND_REQUESTED_MESSAGE:
	if im_message_info.message_ptr ^= null () then do;/* already been "read" */
	     P_code = mlsys_et_$message_already_read;
	     return;
	end;

	call construct_user_message ();		/* create the user-visible message structure */

	mailbox.messages (message_idx).message_ptr = im_message_info.message_ptr;

	P_code = 0;				/* success */

	return;
%page;
/* "Read" the canonical form of the requested message:  The canonical form of a message is the text used by the mail
   system when it stores the message in a mailbox using the mail_format structure */

read_message_canonical_form_p:			/* ...given the message itself: target of user-ring gate */
     entry (P_message_ptr, P_message_canonical_form_ptr, P_message_canonical_form_lth, P_code);

	if ^mlsys_message_mgr_$verify_im_message (P_message_ptr, im_message_info_ptr, P_code) then return;

	mailbox_info_ptr = im_message_info.mailbox_info_ptr;
	if mailbox_info.pending_deletion then do;	/* data structures are inconsistent */
	     P_code = mlsys_et_$deletion_pending;
	     return;
	end;

	go to CHECK_FOR_CANONICAL_FORM;


read_message_canonical_form:				/* ... given the mailbox and message number */
     entry (P_mailbox_ptr, P_message_idx, P_message_canonical_form_ptr, P_message_canonical_form_lth, P_code);

	mailbox_ptr = copy_ptr (P_mailbox_ptr);
	if ^verify_mailbox () then do;
	     P_code = mlsys_et_$not_mailbox;
	     return;
	end;

	mailbox_info_ptr = mailbox_reserved_data.info_ptr;/* need our internal description */

	if mailbox_info.pending_deletion then do;	/* data structures are inconsistent */
	     P_code = mlsys_et_$deletion_pending;
	     return;
	end;

	message_idx = 0;				/* find the requested message */

	do message_block_ptr = mailbox_info.message_blocks.first repeat (next_message_block_ptr)
	     while (message_block_ptr ^= null ());
	     next_message_block_ptr = message_block.next;
	     do idx = 1 to message_block.n_used;
		im_message_info_ptr = addr (message_block.messages (idx));
		if ^im_message_info.already_deleted then do;
		     message_idx = message_idx + 1;	/* ... a message that still counts */
		     if message_idx = P_message_idx then go to CHECK_FOR_CANONICAL_FORM;
		end;
	     end;
	end;

	P_code = error_table_$bad_index;		/* no such message */
	return;


/* Found the message: check that it has a canonical form.  Ie: it must be a mail_format message and the
   mail_format.canonical flag must be ON */

CHECK_FOR_CANONICAL_FORM:
	if im_message_info.format = MAIL_FORMAT_MESSAGE then do;
	     mail_format_ptr = im_message_info.mra.ms_ptr;
	     if mail_format.canonical then do;		/* it's the right type of message */
		P_message_canonical_form_ptr = addr (mail_format.text);
		P_message_canonical_form_lth = mail_format.text_len;
		code = 0;				/* ... success */
	     end;
	     else code = mlsys_et_$no_message_canonical_form;
	end;

	else code = mlsys_et_$no_message_canonical_form;	/* not a mail_format */

	P_code = code;				/* let caller know how he did */

	return;
%page;
/* Return the actual mail_format and mf_extension structures stored in ring-1 for the given message if and only if said
   message was stored in canonical form */

get_message_mf_if_canonical:
     entry (P_message_ptr, P_message_mf_ptr, P_message_mf_extension_ptr, P_code);

	if ^mlsys_message_mgr_$verify_im_message (P_message_ptr, im_message_info_ptr, P_code) then return;

	if im_message_info.format = MAIL_FORMAT_MESSAGE then
	     if im_message_info.mra.ms_ptr -> mail_format.canonical then do;
		P_message_mf_ptr, mail_format_ptr = im_message_info.mra.ms_ptr;
		P_message_mf_extension_ptr = addwordno (mail_format_ptr, currentsize (mail_format));
		code = 0;				/* success */
	     end;

	     else code = mlsys_et_$no_message_canonical_form;
						/* not canonical */

	else code = mlsys_et_$no_message_canonical_form;	/* not a mail_format */

	P_code = code;

	return;
%page;
/* Close a mailbox:  If caller requests, all messages previously marked for deletion will actually be deleted; see the
   notes for the mail_system_$expunge_messages entrypoint for further information */

close_mailbox:
     entry (P_mailbox_ptr, P_close_options_ptr, P_code);

	mailbox_ptr = copy_ptr (P_mailbox_ptr);
	close_options_ptr = P_close_options_ptr;

	if ^verify_mailbox () then do;		/* make sure caller passed us a mailbox */
	     P_code = mlsys_et_$not_mailbox;
	     return;
	end;

	if close_options.version ^= CLOSE_OPTIONS_VERSION_2 then do;
	     P_code = error_table_$unimplemented_version;
	     return;
	end;

	if close_options.mbz ^= ""b then do;		/* it's supposed to be zeroes */
	     P_code = error_table_$bad_subr_arg;
	     return;
	end;

	mailbox_info_ptr = mailbox_reserved_data.info_ptr;/* get pointer to our internal data */

	im_message_info_ptr = null ();		/* avoid problems in the internal procedure */
	call recompute_mailbox_access (code);		/* revalidate access to this mailbox */
	if code ^= 0 then do;			/* ... failed (mailbox deleted?) */
	     P_code = code;
	     return;
	end;

	if close_options.perform_deletions then		/* delete messages awaiting deletion */
	     call perform_deletions ((close_options.report_deletion_errors), deletion_failed);
	else deletion_failed = "0"b;

	call release_mailbox_info ();			/* cleanup storage and close the mailbox */

	P_mailbox_ptr = null ();			/* make sure the caller can't reference it anymore */

	if deletion_failed then
	     P_code = mlsys_et_$some_messages_not_deleted;/* warn caller all is not perfect */
	else P_code = 0;				/* everything went perfectly */

	return;
%page;
/* Expunge the messages in a mailbox which are scheduled for deletion:  If a message being deleted is waiting for
   acknowledgement, a special acknowledgement will be delivered to inform the author that this user never read the
   message.  If any marked message can not be deleted, a sub_error_ condition will be signalled and the operation aborted;
   the caller will then be required either to complete the operation by calling this entrypoint again or to abort the
   operation by calling mail_system_$abort_delete_operation */

expunge_messages:
     entry (P_mailbox_ptr, P_code);

	mailbox_ptr = copy_ptr (P_mailbox_ptr);

	if ^verify_mailbox () then do;		/* make sure caller passed us a mailbox */
	     P_code = mlsys_et_$not_mailbox;
	     return;
	end;

	mailbox_info_ptr = mailbox_reserved_data.info_ptr;/* need our internal description */

	call perform_deletions ("1"b, deletion_failed);	/* do the deletions */
	call reconstruct_mailbox ();			/* make the mailbox structure reflect what is left */

	if deletion_failed then			/* couldn't get rid of some messages for whatever reason */
	     P_code = mlsys_et_$some_messages_not_deleted;
	else if mailbox_info.n_messages = 0 then	/* nothing left in the mailbox */
	     P_code = mlsys_et_$all_messages_deleted;
	else P_code = 0;

	return;


/* This procedure removes control characters (except backspace, tab,
   red ribbon shift, and black ribbon shift) and canonicalizes strings
   to prevent backspacing past the front of the string. */
canon:
     procedure (P_string, P_string_len) returns (char (*));
dcl  P_string char (*) parm;
dcl  P_string_len fixed bin (21) parm;
dcl  output_string char (P_string_len);

dcl  canonicalize_ entry (ptr, fixed bin (21), ptr, fixed bin (21), fixed bin (35));

dcl  (collate, translate) builtin;

dcl  ALPHABET char (256) init ((8)" " || "	" || (4)" " || "" || (16)" " || substr (collate (), 33));
						/* space, BSHT, space, RRSBRS, space, alphanumerics */
dcl  BS char (1) internal static options (constant) init ("");

	P_string = translate (P_string, ALPHABET);
	if index (P_string, BS) ^= 0 then do;
	     output_string = "";
	     call canonicalize_ (addr (P_string), length (P_string), addr (output_string), P_string_len, (0));
	     return (output_string);
	end;
	else return (P_string);
     end canon;


/* Actually delete the marked messages (called by several entrypoints) */

perform_deletions:
     procedure (p_report_errors, p_deletion_failed);

dcl  (p_report_errors, p_deletion_failed) bit (1) aligned parameter;
dcl  next_message_block_ptr pointer;
dcl  (message_idx, idx) fixed binary;

	p_deletion_failed = "0"b;			/* assume everything works OK */

	message_idx = 0;				/* will need the index in the user visible structure */

	do message_block_ptr = mailbox_info.message_blocks.first repeat (next_message_block_ptr)
	     while (message_block_ptr ^= null ());
	     next_message_block_ptr = message_block.next;

	     do idx = 1 to message_block.n_used;
		im_message_info_ptr = addr (message_block.messages (idx));
		message_ptr = im_message_info.message_ptr;

		if ^im_message_info.already_deleted then do;
		     message_idx = message_idx + 1;	/* this message hasn't been deleted yet */

		     if im_message_info.to_be_deleted then do;
			/*** caller has asked to delete this message */

			if im_message_info.can_be_deleted then do;
			     /*** ... and it appears that the user still has sufficient access */

			     if im_message_info.requests_acknowledgement then
				/*** ... let the sender know that this user never did read it */
				call acknowledge_for_deletion ();

			     /*** ... now delete it */
			     call mailbox_$delete_index (mailbox_info.index, im_message_info.key, code);
			     if (code = 0) | (code = error_table_$no_message) then
				im_message_info.already_deleted = "1"b;
			     else call deletion_failure (code);
			end;			/* ... it should have worked */

			else call deletion_failure (mlsys_et_$cant_be_deleted);
		     end;				/* can no longer delete it: let caller know */
		end;
	     end;
	end;

	call mailbox_$compact_index (mailbox_info.index, 0.25e0, (0));
						/* compact if more than 25% unused space */

	return;



/* Internal to perform_deletion: reflects the failure to delete a message by changing the appropriate data structures to
   indicate that said message can not be deleted; this change is required to allow future expunge or close operations to
   succeed.  If requested, this procedure also signals the sub_error_ condition to inform the caller as to why this
   particular message could not be deleted; as mail_system_ is a ring-2 gate, this condition is not restartable */

deletion_failure:
	procedure (p_code);

dcl  p_code fixed binary (35);

	     p_deletion_failed = "1"b;		/* so we can set the appropriate error code */

	     im_message_info.can_be_deleted,		/* can't delete it: record this and unmark it ... */
		im_message_info.to_be_deleted,	/* ... so that future expunge/close operations will work */
		im_message_info.message_ptr -> message.can_be_deleted,
		im_message_info.message_ptr -> message.marked_for_deletion = "0"b;

	     mailbox_info.n_deleted_messages = mailbox_info.n_deleted_messages - 1;
	     mailbox.n_deleted_messages = mailbox_info.n_deleted_messages;
						/* one less message marked for deletion */

	     if p_report_errors then do;		/* let the caller know about it ... */
		mailbox_info.pending_deletion = "1"b;	/* ... data structures are inconsistent */

		allocate delete_error_info in (mlsys_area) set (delete_error_info_ptr);
		mailbox_info.delete_error_info_ptr = delete_error_info_ptr;

		delete_error_info.version = DELETE_ERROR_INFO_VERSION_1;
		delete_error_info.message_number = message_idx;
		delete_error_info.code = p_code;
		delete_error_info.additional_info = "";

RESIGNAL_DELETION_FAILURE:
		call sub_err_ (p_code, MAIL_SYSTEM_, ACTION_CANT_RESTART, delete_error_info_ptr, (0),
		     "Unable to delete message #^d.", message_idx);

		go to RESIGNAL_DELETION_FAILURE;	/* ... not restartable: this will never be reached, but ... */
	     end;

	     return;

	end deletion_failure;

     end perform_deletions;
%page;
/* Abort a suspended call to mail_system_$expunge_messages or mail_system_$close_mailbox: by simply reconstructing the
   user-visible mailbox data structure to indicate which messages have already been deleted */

abort_delete_operation:
     entry (P_mailbox_ptr, P_code);

	mailbox_ptr = copy_ptr (P_mailbox_ptr);

	if ^verify_mailbox () then do;		/* make sure caller passed us a mailbox */
	     P_code = mlsys_et_$not_mailbox;
	     return;
	end;

	mailbox_info_ptr = mailbox_reserved_data.info_ptr;/* need our internal description */

	if mailbox_info.pending_deletion then do;	/* there were deletions in progress */
	     call reconstruct_mailbox ();
	     P_code = 0;
	end;

	else P_code = mlsys_et_$no_pending_deletion;	/* there were no deletions in progress */

	return;



/* Actually reconstructs the mailbox structure (used by several entrypoints) */

reconstruct_mailbox:
     procedure ();

dcl  next_message_block_ptr pointer;
dcl  idx fixed binary;

	mailbox_info.n_messages,			/* must recompute all message counts */
	     mailbox_info.n_messages_by_type (*), mailbox_info.n_deleted_messages = 0;

	do message_block_ptr = mailbox_info.message_blocks.first repeat (next_message_block_ptr)
	     while (message_block_ptr ^= null ());
	     next_message_block_ptr = message_block.next;

	     do idx = 1 to message_block.n_used;
		im_message_info_ptr = addr (message_block.messages (idx));

		if ^im_message_info.already_deleted then do;
		     mailbox_info.n_messages = mailbox_info.n_messages + 1;

		     mailbox.messages (mailbox_info.n_messages).key = im_message_info.key;
		     mailbox.messages (mailbox_info.n_messages).message_ptr = im_message_info.message_ptr;

		     mailbox_info.n_messages_by_type (im_message_info.type) =
			mailbox_info.n_messages_by_type (im_message_info.type) + 1;

		     if im_message_info.to_be_deleted then
						/* record that it will be deleted later ... */
			mailbox_info.n_deleted_messages = mailbox_info.n_deleted_messages + 1;
		end;
	     end;
	end;

	mailbox.n_messages = mailbox_info.n_messages;	/* update the user-visible counts */
	mailbox.n_ordinary_messages = mailbox_info.n_messages_by_type (ORDINARY_MESSAGES);
	mailbox.n_interactive_messages = mailbox_info.n_messages_by_type (INTERACTIVE_MESSAGES);
	mailbox.n_deleted_messages = mailbox_info.n_deleted_messages;

	mailbox_info.pending_deletion = "0"b;		/* no longer any deletions in progress */

	if mailbox_info.delete_error_info_ptr ^= null () then do;
	     free mailbox_info.delete_error_info_ptr -> delete_error_info in (mlsys_area);
	     mailbox_info.delete_error_info_ptr = null ();
	end;

     end reconstruct_mailbox;
%page;
/* Mark the given message for subsequent deletion */

mark_message_for_deletion:
     entry (P_message_ptr, P_code);

	if ^mlsys_message_mgr_$verify_im_message (P_message_ptr, im_message_info_ptr, P_code) then return;

	message_ptr = copy_ptr (P_message_ptr);		/* get pointers to all approrpriate data structures */
	mailbox_info_ptr = im_message_info.mailbox_info_ptr;
	mailbox_ptr = mailbox_info.mailbox_ptr;

	if mailbox_info.pending_deletion then do;	/* data structures are inconsistent */
	     P_code = mlsys_et_$deletion_pending;
	     return;
	end;

	call recompute_mailbox_access (code);		/* revalidate our access to the mailbox */
	if code ^= 0 then do;			/* ... failed: mailbox deleted? */
	     P_code = code;
	     return;
	end;

	if im_message_info.can_be_deleted then		/* it seems we can delete this message ... */
	     if im_message_info.to_be_deleted then	/* ... but it was already marked */
		code = mlsys_et_$already_marked_for_deletion;
	     else do;				/* ... and it wasn't marked earlier */
		mailbox_info.n_deleted_messages, mailbox.n_deleted_messages = mailbox_info.n_deleted_messages + 1;
		im_message_info.to_be_deleted, message.marked_for_deletion = "1"b;
		code = 0;				/* ... success */
	     end;

	else code = mlsys_et_$cant_be_deleted;		/* it isn't possible to delete this message */

	P_code = code;

	return;
%page;
/* Remove the given message from the list of messages marked for subsequent deletion */

unmark_message_for_deletion:
     entry (P_message_ptr, P_code);

	if ^mlsys_message_mgr_$verify_im_message (P_message_ptr, im_message_info_ptr, P_code) then return;

	message_ptr = copy_ptr (P_message_ptr);		/* get pointers to all approrpriate data structures */
	mailbox_info_ptr = im_message_info.mailbox_info_ptr;
	mailbox_ptr = mailbox_info.mailbox_ptr;

	if mailbox_info.pending_deletion then do;	/* data structures are inconsistent */
	     P_code = mlsys_et_$deletion_pending;
	     return;
	end;

	if im_message_info.to_be_deleted then do;	/* it's marked for deletion all right ... */
	     mailbox_info.n_deleted_messages, mailbox.n_deleted_messages = mailbox_info.n_deleted_messages - 1;
	     im_message_info.to_be_deleted, message.marked_for_deletion = "0"b;
	     code = 0;				/* ... success */
	end;

	else code = mlsys_et_$not_marked_for_deletion;	/* it isn't possible to delete this message */

	P_code = code;

	return;
%page;
/* Set a switch on an individual message */

set_message_switch:
     entry (P_message_ptr, P_switch_type, P_switch_value, P_code);


	P_code = 0;
	if ^mlsys_message_mgr_$verify_im_message (P_message_ptr, im_message_info_ptr, P_code) then return;

	message_ptr = copy_ptr (P_message_ptr);
	mailbox_info_ptr = im_message_info.mailbox_info_ptr;
	if ^mailbox_info.mode_flags.delete then do;	/* only the mailbox "owner" can set a switch */
	     P_code = mlsys_et_$cant_update_message;
	     return;
	end;

	switch_type = P_switch_type;
	switch_value = P_switch_value;

	if switch_type = PER_MESSAGE_SEEN_SWITCH_TYPE then do;
	     if im_message_info.format = FIPS98_FORMAT_MESSAGE then
		im_message_info.mra.ms_ptr -> fips98_message.seen = switch_value;
	     else if im_message_info.format = MAIL_FORMAT_MESSAGE then
		im_message_info.mra.ms_ptr -> mail_format.seen = switch_value;
	end;
	else do;
	     P_code = error_table_$bad_subr_arg;	/* only "seen" switch supported */
	     return;
	end;

	call mailbox_$update_message_index (mailbox_info.index, im_message_info.mra.ms_len, im_message_info.key,
	     im_message_info.mra.ms_ptr, code);

/* Having marked the message in the mailbox, mark the local copy */

	if switch_type = PER_MESSAGE_SEEN_SWITCH_TYPE then message.seen = switch_value;

	P_code = code;

	return;
%page;
/* Generate an acknowledgement for the given message if appropriate */

acknowledge_message:
     entry (P_message_ptr, P_code);

	if ^mlsys_message_mgr_$verify_im_message (P_message_ptr, im_message_info_ptr, P_code) then return;

	message_ptr = copy_ptr (P_message_ptr);		/* get pointers to all approrpriate data structures */
	mailbox_info_ptr = im_message_info.mailbox_info_ptr;
	mailbox_ptr = mailbox_info.mailbox_ptr;

	if mailbox_info.pending_deletion then do;	/* data structures are inconsistent */
	     P_code = mlsys_et_$deletion_pending;
	     return;
	end;

	call recompute_mailbox_access (code);		/* revalidate our access to the mailbox */
	if code ^= 0 then do;			/* ... failed: mailbox deleted? */
	     P_code = code;
	     return;
	end;

	if ^im_message_info.requests_acknowledgement then do;
	     P_code = mlsys_et_$no_ack_needed;		/* the message hasn't asked to be acknowledged */
	     return;
	end;

	call determine_acknowledgement_recipient (code);	/* determine who gets the acknowledgement */

	if code = 0 then				/* have the recipient ... */
	     call deliver_acknowledgement ("0"b, code);	/* ... send a standard acknowledgement message */

	if code = 0 then do;			/* successfully sent the acknowledgement ... */
	     if im_message_info.format = FIPS98_FORMAT_MESSAGE then
		im_message_info.mra.ms_ptr -> fips98_message.acknowledge = "0"b;
	     else if im_message_info.format = MAIL_FORMAT_MESSAGE then
		im_message_info.mra.ms_ptr -> mail_format.acknowledge = "0"b;
	     call mailbox_$update_message_index (mailbox_info.index, im_message_info.mra.ms_len, im_message_info.key,
		im_message_info.mra.ms_ptr, code);
	     if code ^= 0 then code = mlsys_et_$cant_update_message;
	end;

	call delete_acknowledge_to_fields ();		/* delete all Acknowledge-To fields */
	im_message_info.requests_acknowledgement, message.must_be_acknowledged = "0"b;
						/* if it failed, it won't help to let them call back */

	P_code = code;				/* reflect success/failure to the caller */

	return;
%page;
/* Generate a special acknowledgement message for a message which has been deleted without being "read" */

acknowledge_for_deletion:
     procedure ();

dcl  code fixed binary (35);

	call determine_acknowledgement_recipient (code);	/* determine who gets the acknowledgement */

	if code = 0 then				/* have the recipient ... */
	     call deliver_acknowledgement ("1"b, code);	/* ... send the non-standard acknowledgement message */

	return;

     end acknowledge_for_deletion;



/* Delete any and all Acknowledge-To fields in the message (there should only be one, but...) */

delete_acknowledge_to_fields:
     procedure ();

dcl  idx fixed binary;

	if message.envelope.acknowledge_to ^= null () then
	     call mlsys_address_mgr_$decrement_reference_count (message.envelope.acknowledge_to);

	do idx = 1 to message.n_redistributions;
	     if message_redistributions_list.redistributions (idx).acknowledge_to ^= null () then
		call mlsys_address_mgr_$decrement_reference_count (message_redistributions_list.redistributions (idx)
		     .acknowledge_to);
	end;

	return;

     end delete_acknowledge_to_fields;
%page;
/* Determine who is to receive the acknowledgement:  In this implementation, the recipient must have a local mailbox */

determine_acknowledgement_recipient:
     procedure (p_code);

dcl  p_code fixed binary (35) parameter;

dcl  (acknowledge_to, mte_address) pointer;
dcl  code fixed binary (35);
dcl  address_type fixed binary;
dcl  delivery_by_person_id char (32) var;


	if message.n_redistributions > 0 then do;	/* redistributed: it's in the last Acknowledge-To field */
	     acknowledge_to = message_redistributions_list.redistributions (message.n_redistributions).acknowledge_to;
	     is_redistributed = "1"b;			/* ... we may need to mention this in the message */
	end;
	else do;
	     acknowledge_to = message.envelope.acknowledge_to;
	     is_redistributed = "0"b;
	end;

	if acknowledge_to = null () then do;		/* no Acknowledge-To field(?) */
	     p_code = mlsys_et_$missing_acknowledge_to;
	     return;
	end;

	if message.from -> address_list.n_addresses = 1 then do;
	     multiple_authors = "0"b;			/* only one author */
	     author_is_ack_recipient =
		mlsys_address_mgr_$compare_addresses (acknowledge_to, message.from -> address_list.addresses (1), (0))
		;
	end;
	else do;					/* several authors will affect the message format */
	     multiple_authors = "1"b;
	     author_is_ack_recipient = "0"b;
	end;

	mte_address = null ();			/* for cleanup handler */
	on condition (cleanup)
	     begin;
	     if mte_address ^= null () then call mlsys_address_mgr_$free_address (mte_address, (0));
	end;

	call mlsys_address_mgr_$get_address_type (acknowledge_to, address_type, code);
	if code ^= 0 then call bad_acknowledge_to ();	/* huh? */

	if address_type = MAIL_TABLE_ADDRESS then do;	/* mail-table address: look it up to get the target */
	     call mlsys_address_mgr_$get_mail_table_address (acknowledge_to, mte_address, code);
	     if code ^= 0 then call bad_acknowledge_to ();
	     acknowledge_to = mte_address;		/* ... rest of the procedure uses acknowledge_to value */
	     call mlsys_address_mgr_$get_address_type (acknowledge_to, address_type, code);
	     if code ^= 0 then call bad_acknowledge_to ();

	     if (address_type ^= USER_MAILBOX_ADDRESS) & (address_type ^= LOGBOX_ADDRESS)
		& (address_type ^= SAVEBOX_ADDRESS) & (address_type ^= MAILBOX_ADDRESS) then do;
						/* RL: mail table entry refers to non-mailbox, try using sender_id */
		delivery_by_person_id = rtrim (im_message_info.mra.sender_id);
		if (length (delivery_by_person_id) > 1)
		     & (substr (reverse (delivery_by_person_id), 1, 2) = reverse (".a")) then
		     delivery_by_person_id = substr (delivery_by_person_id, 1, length (delivery_by_person_id) - 2);
						/* RL: remove ".a" suffix for person_id */

		if mte_address ^= null () then call mlsys_address_mgr_$free_address (mte_address, (0));
						/* RL: free old address */
		call mlsys_address_mgr_$create_user_mailbox_address (delivery_by_person_id, "", "", mte_address, code)
		     ;

		if code ^= 0 then call bad_acknowledge_to ();
		address_type = USER_MAILBOX_ADDRESS;
	     end;

	end;

	if (address_type ^= USER_MAILBOX_ADDRESS) & (address_type ^= LOGBOX_ADDRESS)
	     & (address_type ^= SAVEBOX_ADDRESS) & (address_type ^= MAILBOX_ADDRESS) then
	     call bad_acknowledge_to ();		/* the address doesn't reference a mailbox */

	call mlsys_address_mgr_$get_address_pathname (acknowledge_to, mailbox_dirname, mailbox_ename, ((32)" "), code);
	if code ^= 0 then call bad_acknowledge_to ();	/* huh? */

	p_code = 0;				/* success */


RETURN_FROM_DETERMINE_ACKNOWLEDGEMENT_RECIPIENT:
	if mte_address ^= null () then call mlsys_address_mgr_$free_address (mte_address, (0));
	return;



/* Internal to determine_acknowledgement_recipient: returns mlsys_et_$bad_acknowledge_to to our caller */

bad_acknowledge_to:
	procedure ();

	     p_code = mlsys_et_$bad_acknowledge_to;
	     go to RETURN_FROM_DETERMINE_ACKNOWLEDGEMENT_RECIPIENT;

	end bad_acknowledge_to;

     end determine_acknowledgement_recipient;
%page;
/* Deliver the acknowledgement message */

deliver_acknowledgement:
     procedure (p_send_delete_ack, p_code);

dcl  p_send_delete_ack bit (1) aligned parameter;
dcl  p_code fixed binary (35) parameter;

dcl  date_time_string character (64) varying;
dcl  1 date_time_string_fixed aligned based (addr (date_time_string)),
       2 lth fixed binary (21),
       2 text character (64);

dcl  author_string character (256) varying;
dcl  an_author pointer;

dcl  subject character (subject_lth) unaligned based (subject_ptr);
dcl  subject_lth fixed binary (21);
dcl  subject_ptr pointer;
dcl  include_subject bit (1) aligned;

dcl  message_lth fixed binary (21);

/* format: off */

dcl (DELETION_PREFIX	initial ("Deleted, possibly without reading, "),
     READING_PREFIX		initial ("Acknowledging "),
     YOUR_MESSAGE		initial ("your message of "),
     THE_MESSAGE		initial ("the message of "),
     FROM			initial (" from "),
     ET_AL		initial (" et al"),
     FORWARDED_SUFFIX	initial (" which you forwarded"),
     SUBJECT_PREFIX		initial (";  Subject: "))
	character (48) varying static options (constant);
/* format: on */


/* Compute the length of the acknowledgement */

	if p_send_delete_ack then
	     message_lth = length (DELETION_PREFIX);
	else message_lth = length (READING_PREFIX);

	if author_is_ack_recipient then
	     message_lth = message_lth + length (YOUR_MESSAGE);
	else do;
	     message_lth = message_lth + length (THE_MESSAGE) + length (FROM);
	     an_author = message.from -> address_list.addresses (1);
	     call mlsys_misc_utils_$get_best_address_name (an_author, author_string, p_code);
	     if p_code ^= 0 then do;			/* fatal error */
		p_code = mlsys_et_$cant_send_acknowledgement;
		return;
	     end;
	     message_lth = message_lth + length (author_string);
	     if multiple_authors then message_lth = message_lth + length (ET_AL);
	end;

	if is_redistributed then			/* see if we should mention it was forwarded ... */
	     if ^author_is_ack_recipient then message_lth = message_lth + length (FORWARDED_SUFFIX);

	date_time_string_fixed.lth = 0;		/* this is an input/output parameter */
	call mlsys_format_$format_date_time_field ("", message.date_time_created, "0"b, -1,
	     addr (date_time_string_fixed.text), maxlength (date_time_string), date_time_string_fixed.lth, (0));
	message_lth = message_lth + length (date_time_string);

	if length (message_subject) > 0 then do;	/* there's a subject to be included */
	     include_subject = "1"b;
	     subject_ptr = message.subject.text_ptr;
	     subject_lth = message.subject.text_lth;	/* ... guarenteed to be only one line */
	end;

	else if message.interactive & (message.total_lines > 0) then
	     if message.body_sections (1).section_type = MESSAGE_PREFORMATTED_BODY_SECTION then do;
		include_subject = "1"b;		/* interactive: use first line of text as "subject" */
		message_body_section_ptr = addr (message.body_sections (1));
		subject_ptr = addr (message_preformatted_body_section_text);
		subject_lth = index (message_preformatted_body_section_text, NL) - 1;
		if subject_lth = -1 then subject_lth = length (message_preformatted_body_section_text);
	     end;
	     else include_subject = "0"b;		/* interactive but not composed of text */

	else include_subject = "0"b;			/* nothing to be used the subject */

	if include_subject then message_lth = message_lth + length (SUBJECT_PREFIX) + subject_lth;


/* Construct the acknowledgement */

	begin;

dcl  1 ack_message aligned,				/* use a mail_format style message */
       2 header like mail_format.header,
       2 text character (message_lth);
dcl  text_used fixed binary (21);

dcl  1 wakeup_switches aligned,			/* control switches for mailbox_$wakeup_add_index */
       2 normal_wakeup bit (1) unaligned,		/* ON => send a normal wakeup */
       2 urgent_wakeup bit (1) unaligned,		/* ON => send an urgent wakeup (requires "u" access) */
       2 always_add bit (1) unaligned,			/* ON => always add the message even if wakeup fails */
       2 never_add bit (1) unaligned,			/* ON => never add the message; test if wakeup can be sent */
       2 pad bit (32) unaligned;

	     text_used = 0;				/* nothing in the acknowledgement yet */

	     if p_send_delete_ack then		/* either "Acknowledging" or "Deleted without reading" */
		call add_to_text (DELETION_PREFIX);
	     else call add_to_text (READING_PREFIX);

	     if author_is_ack_recipient then		/* either "your message of" or "the message of" */
		call add_to_text (YOUR_MESSAGE);
	     else call add_to_text (THE_MESSAGE);

	     call add_to_text (date_time_string);

	     if ^author_is_ack_recipient then do;
		call add_to_text (FROM);
		call add_to_text (author_string);
		if multiple_authors then call add_to_text (ET_AL);
	     end;

	     if is_redistributed then			/* see if we should mention it was forwarded ... */
		if ^author_is_ack_recipient then call add_to_text (FORWARDED_SUFFIX);

	     if include_subject then do;
		call add_to_text (SUBJECT_PREFIX);
		substr (ack_message.text, (text_used + 1), subject_lth) = subject;
		text_used = text_used + subject_lth;
	     end;


/* Attempt to send the acknowledgement */

	     ack_message.version = MAIL_FORMAT_VERSION_4;
	     ack_message.sent_from = "";
	     ack_message.lines = 1;			/* guaranteed */
	     ack_message.text_len = text_used;

	     unspec (ack_message.switches) = "0"b;
	     ack_message.wakeup = "1"b;		/* acknowledgements are interactive */

	     mailbox_idx = 0;			/* for cleanup handler */

	     on condition (cleanup)
		begin;
		if mailbox_idx ^= 0 then do;
		     call mailbox_$close (mailbox_idx, (0));
		     mailbox_idx = 0;
		end;
	     end;

	     on condition (record_quota_overflow)
		begin;				/* no room in the mailbox */
		p_code = mlsys_et_$cant_send_acknowledgement;
		go to CLOSE_THE_ACK_MAILBOX;
	     end;

	     call mailbox_$open (mailbox_dirname, mailbox_ename, mailbox_idx, p_code);

	     if p_code = 0 then do;			/* have the mailbox */
		string (wakeup_switches) = ""b;
		wakeup_switches.normal_wakeup = "1"b;	/* ... send a normal wakeup (if possible) ... */
		wakeup_switches.always_add = "1"b;	/* ... and always leave it in the mailbox */
		call mailbox_$wakeup_add_index (mailbox_idx, addr (ack_message),
		     (36 * currentsize (ack_message) - 9 * (message_lth - text_used)), string (wakeup_switches),
		     ((72)"0"b), p_code);
		if (p_code = error_table_$wakeup_denied) | (p_code = error_table_$messages_deferred)
		     | (p_code = error_table_$messages_off) | (p_code = error_table_$no_info) then
		     p_code = 0;
		if p_code ^= 0 then p_code = mlsys_et_$cant_send_acknowledgement;
CLOSE_THE_ACK_MAILBOX:
		call mailbox_$close (mailbox_idx, (0));
		mailbox_idx = 0;			/* ... be sure to close the mailbox anwyay */
	     end;

	     else p_code = mlsys_et_$cant_send_acknowledgement;


/* Internal to deliver_acknowledgement begin block: add a piece of text to the message */

add_to_text:
     procedure (p_string);

dcl  p_string character (*) varying parameter;

	substr (ack_message.text, (text_used + 1), length (p_string)) = p_string;
	text_used = text_used + length (p_string);

	return;

     end add_to_text;

	end;

	return;

     end deliver_acknowledgement;
%page;
/* Verify that the caller supplied a pointer to a properly constructed mailbox structure */

verify_mailbox:
     procedure () returns (bit (1) aligned);

	if mailbox_ptr = null () then return ("0"b);

	if ^mlsys_data_$valid_segments (binary (baseno (mailbox_ptr), 18, 0)) then return ("0"b);
						/* supplied structure wasn't allocated by us */

	if mailbox.version ^= MAILBOX_VERSION_2 then	/* supplied structure isn't a mailbox structure */
	     return ("0"b);

	return ("1"b);				/* supplied mailbox structure passes */

     end verify_mailbox;



/* Add the specified suffix to an entryname if possible */

add_suffix:
     procedure (p_ename, p_suffix, p_new_ename, p_code);

dcl  (p_ename, p_suffix) character (*) parameter;
dcl  p_new_ename character (32) parameter;
dcl  p_code fixed binary (35) parameter;

dcl  (trimmed_ename, trimmed_suffix) character (33) varying;

	trimmed_ename = rtrim (p_ename);
	trimmed_suffix = "." || rtrim (p_suffix);

	if length (trimmed_ename) > length (p_new_ename) then do;
	     p_code = error_table_$entlong;
	     return;
	end;

	if length (trimmed_ename) > length (trimmed_suffix) then
						/* original name has room for the suffix */
	     if substr (trimmed_ename, (length (trimmed_ename) - length (trimmed_suffix) + 1)) = trimmed_suffix then
		;				/* proper suffix is already present */
	     else trimmed_ename = trimmed_ename || trimmed_suffix;
	else trimmed_ename = trimmed_ename || trimmed_suffix;

	p_new_ename = trimmed_ename;			/* return it */

	if length (trimmed_ename) <= length (p_new_ename) then
	     p_code = 0;				/* it fit */
	else p_code = error_table_$entlong;		/* sorry */

	return;

     end add_suffix;
%page;
/* Classify a message: determines the format (FIPS98, mail_format, unknown) and type (ordinary, interactive) */

classify_message:
     procedure (p_message_ptr, p_message_lth, p_message_format, p_message_type);

dcl  p_message_ptr pointer parameter;
dcl  p_message_lth fixed binary (24) parameter;
dcl  (p_message_format, p_message_type) fixed binary;

	fips98_message_ptr, mail_format_ptr = p_message_ptr;
						/* allow following references to work OK */

	if fips98_message.version = FIPS98_MESSAGE_VERSION_1 then do;
	     p_message_format = FIPS98_FORMAT_MESSAGE;
	     if fips98_message.interactive then
		p_message_type = INTERACTIVE_MESSAGES;
	     else p_message_type = ORDINARY_MESSAGES;
	end;

	else if ((mail_format.version = MAIL_FORMAT_VERSION_2) | (mail_format.version = MAIL_FORMAT_VERSION_3)
	     | (mail_format.version = MAIL_FORMAT_VERSION_4)) & (mail_format.lines <= mail_format.text_len) then do;
	     p_message_format = MAIL_FORMAT_MESSAGE;
	     if mail_format.wakeup | mail_format.urgent | mail_format.notify then
		p_message_type = INTERACTIVE_MESSAGES;
	     else p_message_type = ORDINARY_MESSAGES;
	end;

	else do;					/* not recognizable */
	     p_message_format = UNKNOWN_FORMAT_MESSAGE;
	     p_message_type = ORDINARY_MESSAGES;	/* ... as we don't know where to look in the message */
	end;

	return;

     end classify_message;



/* Returns "1"b if a message's sender_id (from ring-1) matches the criteria for "own" messages */

message_from_self:
     procedure (p_sender_id) returns (bit (1) aligned);

dcl  p_sender_id character (32) parameter;

	if before (p_sender_id, ".") = "anonymous" then	/* for anonymous users, project is important */
	     return (substr (p_sender_id, 1, length (rtrim (p_sender_id)) - 2) = mlsys_data_$user_id);

	else return (before (p_sender_id, ".") = mlsys_data_$person_id);

     end message_from_self;
%page;
/* Read the next message from a mailbox */

read_next_message:
     procedure ();

dcl  retry_count fixed binary;
dcl  retried bit (1) aligned;

	im_message_info_ptr = find_next_message_block_slot ();
	mra_ptr = addr (im_message_info.mra);		/* a place to store the data */

	mailbox_message_area_ptr = find_mailbox_message_area ("0"b);
						/* a place to allocate the mail_format */

	retry_count = 1;				/* may retry because of mailbox salvaging or ... */
	retried = "0"b;				/* ... another program closing the mailbox too many times */


/* Try to read the message */

RETRY_READ_MESSAGE:
	if mailbox_info.last_message_key = ""b then	/* read the first message ... */
	     if mailbox_info.use_own_mode then		/* ... from ourselves */
		call mailbox_$own_read_index (mailbox_info.index, addr (mailbox_message_area.area), "0"b, mra_ptr,
		     code);
	     else					/* ... in the mailbox period */
		call mailbox_$read_index (mailbox_info.index, addr (mailbox_message_area.area), "0"b, mra_ptr, code);

	else					/* read the next message ... */
	     if mailbox_info.use_own_mode then		/* ... from ourselves */
	     call mailbox_$own_incremental_read_index (mailbox_info.index, addr (mailbox_message_area.area), "01"b,
		mailbox_info.last_message_key, mra_ptr, code);
	else					/* ... in the mailbox period */
	     call mailbox_$incremental_read_index (mailbox_info.index, addr (mailbox_message_area.area),
		"01"b /* next forward */, mailbox_info.last_message_key, mra_ptr, code);

	if code ^= 0 then				/* something went wrong ... */
	     if code = error_table_$noalloc then	/* ... message won't fit in current area */
		if mailbox_message_area.virgin_area then
		     go to CANT_READ_MESSAGE;		/* ... already tried empty area: can't ever read it */
		else do;				/* ... try again with an empty area */
		     mailbox_message_area_ptr = find_mailbox_message_area ("1"b);
		     go to RETRY_READ_MESSAGE;
		end;

	     else if code = error_table_$bad_segment then do;
		mailbox_info.flags.salvaged = "1"b;	/* ... mailbox was salvaged */
		retry_count = retry_count + 1;
		if retry_count > mlsys_data_$max_opening_retries then go to CANT_READ_MESSAGE;
						/* mailbox seems permanently damaged */
		call mailbox_$close (mailbox_info.index, (0));
		mailbox_info.index = 0;		/* in case following open call fails ... */
		call mailbox_$open (mailbox_info.dirname, mailbox_info.ename, mailbox_info.index, code);
		if code = 0 then			/* it opened again OK: try reading again */
		     go to RETRY_READ_MESSAGE;
		else go to CANT_READ_MESSAGE;
	     end;

	     else if code = error_table_$seg_unknown then do;
						/* ... some other buggy program closed mailbox too often */
		if retried then go to CANT_READ_MESSAGE;/* one try at this one, please ... */
		retried = "1"b;
		call mailbox_$close (mailbox_info.index, (0));
		mailbox_info.index = 0;		/* in case the open fails ... */
		call mailbox_$open (mailbox_info.dirname, mailbox_info.ename, mailbox_info.index, code);
		if code = 0 then			/* mailbox opened OK: try again */
		     go to RETRY_READ_MESSAGE;
		else go to CANT_READ_MESSAGE;		/* something is really amiss */
	     end;

	     else go to CANT_READ_MESSAGE;		/* ... anything else is fatal */


/* Message has been successfully read */

	im_message_info.area_ptr = addr (mailbox_message_area.area);
	im_message_info.mailbox_info_ptr = mailbox_info_ptr;
	im_message_info.key = im_message_info.mra.ms_id;
	call classify_message (im_message_info.mra.ms_ptr, im_message_info.mra.ms_len, im_message_info.format,
	     im_message_info.type);
	string (im_message_info.flags) = ""b;
	im_message_info.flags.mra_valid = "1"b;		/* have data from ring-1 */

	if im_message_info.format = MAIL_FORMAT_MESSAGE then
	     if im_message_info.mra.ms_len <= 36 * currentsize (mail_format) then do;
		/*** Ring-1 message isn't long enough to hold the mf_extension structure:  The message must be treated
		     as a non-canonical message; otherwise, retransmission of the message would fail horribly */
		mail_format.obsolete = mail_format.obsolete | mail_format.canonical;
		mail_format.canonical = "0"b;
	     end;

	im_message_info.flags.can_be_deleted =		/* determine if the user can delete this message */
	     (mailbox_info.ring1_privilege | aim_check_$equal (im_message_info.mra.access_class, get_authorization_ ()))
	     & (mailbox_info.mode_flags.delete
	     | (message_from_self (im_message_info.mra.sender_id) & mailbox_info.mode_flags.own));

	if im_message_info.format = FIPS98_FORMAT_MESSAGE then
	     im_message_info.flags.requests_acknowledgement = fips98_message.acknowledge;
	else if im_message_info.format = MAIL_FORMAT_MESSAGE then
	     im_message_info.flags.requests_acknowledgement = mail_format.acknowledge;
	else /*** if im_message_info.format = UNKNOWN_FORMAT_MESSAGE then */
	     im_message_info.flags.requests_acknowledgement = "0"b;

	im_message_info.flags.requests_acknowledgement =	/* only allow acknowledgements if user "owns" the mailbox */
	     im_message_info.flags.requests_acknowledgement & mailbox_info.mode_flags.delete
	     & aim_check_$equal (im_message_info.mra.access_class, get_authorization_ ());

	im_message_info.message_ptr = null ();		/* no user-visible data yet */

	mailbox_info.last_message_key = im_message_info.key;
						/* next call will do incremental read */
	mailbox_message_area.virgin_area = "0"b;	/* something's there now */

	code = 0;					/* indicate success to caller */

	return;


/* Fatal errors during reading transfer here */

CANT_READ_MESSAGE:
	message_block.n_used = message_block.n_used - 1;	/* back to before this message */
	return;
%page;
/* Internal to read_next_message: finds the next available im_message_info datum, allocating a new message_block if
   necessary */

find_next_message_block_slot:
	procedure () returns (pointer);

	     message_block_ptr = mailbox_info.message_blocks.last;

	     if message_block_ptr = null () then	/* no previous message blocks */
		call allocate_new_message_block ();
	     else if message_block.n_used = hbound (message_block.messages, 1) then call allocate_new_message_block ();
						/* last message_block is full */

	     message_block.n_used = message_block.n_used + 1;
						/* pick the next one */

	     return (addr (message_block.messages (message_block.n_used)));



allocate_new_message_block:
	     procedure ();

dcl  new_message_block_ptr pointer;

		allocate message_block in (mlsys_area) set (new_message_block_ptr);

		new_message_block_ptr -> message_block.chain = null ();
		new_message_block_ptr -> message_block.n_used = 0;
						/* it's empty */

		if mailbox_info.message_blocks.last = null () then
		     mailbox_info.message_blocks = new_message_block_ptr;
						/* first message_block for this mailbox */

		else do;				/* chain it onto the end */
		     mailbox_info.message_blocks.last -> message_block.chain.next = new_message_block_ptr;
		     new_message_block_ptr -> message_block.chain.previous = mailbox_info.message_blocks.last;
		     mailbox_info.message_blocks.last = new_message_block_ptr;
		end;

		message_block_ptr = new_message_block_ptr;
						/* and it's now the current one */

		return;

	     end allocate_new_message_block;

	end find_next_message_block_slot;
%page;
/* Internal to read_next_message: find an area into which the mail_format for this message is to be read */

find_mailbox_message_area:
	procedure (p_force_new_segment) returns (pointer);

dcl  p_force_new_segment bit (1) aligned parameter;

dcl  1 local_area_info aligned like area_info;
dcl  new_mma_ptr pointer;

	     if p_force_new_segment | (mailbox_info.last_message_area_ptr = null ()) then do;
		call mlsys_storage_mgr_$get_temp_segment (new_mma_ptr, code);
		if code ^= 0 then go to CANT_READ_MESSAGE;
		unspec (local_area_info) = ""b;	/* setup the area: not extensible */
		local_area_info.version = area_info_version_1;
		local_area_info.areap = addr (new_mma_ptr -> mailbox_message_area.area);
		local_area_info.owner = MAIL_SYSTEM_;
		local_area_info.size =
		     sys_info$max_seg_size - binary (rel (addr (new_mma_ptr -> mailbox_message_area.area)), 18);
		call define_area_ (addr (local_area_info), code);
		if code ^= 0 then do;
		     call mlsys_storage_mgr_$release_temp_segment (new_mma_ptr, (0));
		     go to CANT_READ_MESSAGE;
		end;
		new_mma_ptr -> mailbox_message_area.previous = mailbox_info.last_message_area_ptr;
		new_mma_ptr -> mailbox_message_area.virgin_area = "1"b;
						/* not yet used */
		mailbox_info.last_message_area_ptr = new_mma_ptr;
						/* it's the latest one now */
	     end;

	     return (mailbox_info.last_message_area_ptr);

	end find_mailbox_message_area;

     end read_next_message;
%page;
/* Create the user-visible message structure describing the selected message */

construct_user_message:
     procedure ();

dcl  1 local_mbsp aligned like message_body_section_parameter;
dcl  ring_1_delivered_by pointer;
dcl  ring_1_delivered_by_comment character (32) varying;
dcl  ring_1_date_time_delivered fixed binary (71);

	unspec (ring_1_date_time_delivered) = (18)"0"b || substr (im_message_info.key, 19);

	if im_message_info.format = MAIL_FORMAT_MESSAGE then do;
	     mail_format_ptr = im_message_info.mra.ms_ptr;/* there might be a "comment" */
	     if (before (im_message_info.mra.sender_id, ".") ^= mail_format.sent_from)
		& ((mail_format.sent_from ^= "")
		& (mail_format.sent_from ^= copy (NUL, length (mail_format.sent_from)))) then
		ring_1_delivered_by_comment =
		     rtrim (canon (rtrim (mail_format.sent_from), length (rtrim (mail_format.sent_from))));
	     else ring_1_delivered_by_comment = "";
	end;
	else ring_1_delivered_by_comment = "";		/* not for any other format */

	call mlsys_address_mgr_$create_user_mailbox_address
	     ((
	     substr (im_message_info.mra.sender_id, 1, (length (rtrim (im_message_info.mra.sender_id)) - length (".a")))
	     ), "", ring_1_delivered_by_comment, ring_1_delivered_by, (0));
	call mlsys_address_mgr_$increment_reference_count (ring_1_delivered_by);

	if im_message_info.format = FIPS98_FORMAT_MESSAGE then do;
	     fips98_message_ptr = im_message_info.mra.ms_ptr;
	     call mlsys_fips98_$decode_message (fips98_message.data.bytes (*), MESSAGE_VERSION_2, im_message_info_ptr,
		ring_1_delivered_by, ring_1_date_time_delivered, (im_message_info.requests_acknowledgement),
		message_ptr, code);
	     if code ^= 0 then do;			/* couldn't decode it: act like it's a bit string */
		call create_message ();
		local_mbsp.version = MESSAGE_BODY_SECTION_PARAMETER_VERSION_2;
		message_body_section_ptr = addr (local_mbsp.section);
		message_bit_string_body_section.section_type = MESSAGE_BIT_STRING_BODY_SECTION;
		message_bit_string_body_section.bit_string_ptr = addr (fips98_message.data);
		message_bit_string_body_section.bit_string_lth = 9 * fips98_message.n_bytes;
		call mlsys_message_mgr_$add_body_section_no_copy (message_ptr, addr (local_mbsp), (-1), (0));
	     end;
	end;

	else if im_message_info.format = MAIL_FORMAT_MESSAGE then do;
	     mail_format_ptr = im_message_info.mra.ms_ptr;
	     call mlsys_parse_text_$parse_im_message_text (mail_format.text, MESSAGE_VERSION_2, im_message_info_ptr,
		ring_1_delivered_by, ring_1_date_time_delivered, (im_message_info.requests_acknowledgement),
		(mail_format.canonical | mail_format.obsolete /* formerly "new_quoting" */), message_ptr, code);
	     if code ^= 0 then do;			/* couldn't parse it: act like it has no header */
		call create_message ();
		local_mbsp.version = MESSAGE_BODY_SECTION_PARAMETER_VERSION_2;
		message_body_section_ptr = addr (local_mbsp.section);
		message_preformatted_body_section.section_type = MESSAGE_PREFORMATTED_BODY_SECTION;
		message_preformatted_body_section.text_ptr = addr (mail_format.text);
		message_preformatted_body_section.text_lth = length (mail_format.text);
		call mlsys_message_mgr_$add_body_section_no_copy (message_ptr, addr (local_mbsp), (-1), (0));
	     end;
	end;

	else do;					/* unknown format: make it all a bit string */
	     call create_message ();
	     local_mbsp.version = MESSAGE_BODY_SECTION_PARAMETER_VERSION_2;
	     message_body_section_ptr = addr (local_mbsp.section);
	     message_bit_string_body_section.section_type = MESSAGE_BIT_STRING_BODY_SECTION;
	     message_bit_string_body_section.bit_string_ptr = im_message_info.mra.ms_ptr;
	     message_bit_string_body_section.bit_string_lth = im_message_info.mra.ms_len;
	     call mlsys_message_mgr_$add_body_section_no_copy (message_ptr, addr (local_mbsp), (-1), (0));
	end;

	im_message_info.message_ptr = message_ptr;
	message.interactive = (im_message_info.type = INTERACTIVE_MESSAGES);
	message.can_be_deleted = im_message_info.can_be_deleted;
	message.must_be_acknowledged = im_message_info.requests_acknowledgement;
	message.access_class = im_message_info.mra.access_class;

	if im_message_info.format = FIPS98_FORMAT_MESSAGE then
	     message.seen = im_message_info.mra.ms_ptr -> fips98_message.seen;
	else if im_message_info.format = MAIL_FORMAT_MESSAGE then
	     message.seen = im_message_info.mra.ms_ptr -> mail_format.seen;
	else message.seen = "0"b;

	call mlsys_address_mgr_$decrement_reference_count (ring_1_delivered_by);

	return;



/* Internal to construct_user_message: creates the message structure for unknown format or unparseable messages */

create_message:
	procedure ();

	     call mlsys_message_mgr_$create_im_message (MESSAGE_VERSION_2, im_message_info_ptr, message_ptr, (0));

	     message.envelope.date_time_delivered, message.envelope.date_time_mailed, message.header.date_time_created =
		ring_1_date_time_delivered;

	     call mlsys_message_id_mgr_$encode_local_id (ring_1_date_time_delivered, message.message_id);

	     call mlsys_address_list_mgr_$add_address (message.from, ring_1_delivered_by, ADDRESS_LIST_VERSION_2, (0));

	     if im_message_info.requests_acknowledgement then do;
		message.envelope.acknowledge_to = ring_1_delivered_by;
		call mlsys_address_mgr_$increment_reference_count (message.envelope.acknowledge_to);
	     end;

	     return;

	end create_message;

     end construct_user_message;
%page;
/* Recompute user's access to a mailbox and update any information about the mailbox which changes such as which messages
   can be deleted or acknowledged */

/* Note: A change in access may prevent the user from reading desired messages in the future; this problem will be
   detected by the read_new_messages entrypoint */

recompute_mailbox_access:
     procedure (p_code);

dcl  p_code fixed binary (35) parameter;

dcl  saved_im_message_info_ptr pointer;
dcl  code fixed binary (35);
dcl  retry_count fixed binary;
dcl  retried bit (1) aligned;

dcl  next_message_block_ptr pointer;
dcl  idx fixed binary;

	saved_im_message_info_ptr = im_message_info_ptr;	/* might be needed by calling procedure */

	retry_count = 1;				/* may retry because of mailbox salvaging or ... */
	retried = "0"b;				/* ... another program closing the mailbox too many times */

RETRY_GET_MAILBOX_ACCESS:
	call mailbox_$get_mode_index (mailbox_info.index, mailbox_mode, code);
	if code ^= 0 then				/* something went wrong ... */
	     if code = error_table_$moderr then ;	/* ... user no longer has access to the mailbox */

	     else if code = error_table_$bad_segment then do;
		mailbox_info.flags.salvaged = "1"b;	/* ... mailbox was salvaged */
		retry_count = retry_count + 1;
		if retry_count > mlsys_data_$max_opening_retries then go to CANT_RECOMPUTE_MAILBOX_ACCESS;
						/* mailbox seems permanently damaged */
		call mailbox_$close (mailbox_info.index, (0));
		mailbox_info.index = 0;		/* in case following open call fails ... */
		call mailbox_$open (mailbox_info.dirname, mailbox_info.ename, mailbox_info.index, code);
		if code = 0 then			/* it opened again OK: try to get access again */
		     go to RETRY_GET_MAILBOX_ACCESS;
		else if code = error_table_$moderr then ;
						/* user no longer has access to the mailbox */
		else go to CANT_RECOMPUTE_MAILBOX_ACCESS;
	     end;

	     else if code = error_table_$seg_unknown then do;
						/* ... some other buggy program closed mailbox too often */
		if retried then go to CANT_RECOMPUTE_MAILBOX_ACCESS;
		retried = "1"b;			/* one try at this one, please ... */
		call mailbox_$close (mailbox_info.index, (0));
		mailbox_info.index = 0;		/* in case the open fails ... */
		call mailbox_$open (mailbox_info.dirname, mailbox_info.ename, mailbox_info.index, code);
		if code = 0 then			/* mailbox opened OK: try again */
		     go to RETRY_GET_MAILBOX_ACCESS;
		else if code = error_table_$moderr then ;
						/* user no longer has access */
		else go to CANT_RECOMPUTE_MAILBOX_ACCESS;
	     end;

	     else do;				/* ... anything else is fatal */
CANT_RECOMPUTE_MAILBOX_ACCESS:
		p_code = code;
		return;
	     end;

	if code = error_table_$moderr then mailbox_mode = ""b;
						/* user no longer has any access to the mailbox */

	string (user_privileges) = get_privileges_ ();	/* must also check if ring-1 privilege changed */

	if (string (mailbox_info.mode_flags) = mailbox_mode) & (mailbox_info.ring1_privilege = user_privileges.ring1)
	then do;					/* access hasn't changed */
	     p_code = 0;
	     return;
	end;

	string (mailbox_info.mode_flags) = mailbox_mode;
	if mailbox_info.mailbox_ptr ^= null () then	/* reflect change to user */
	     mailbox_info.mailbox_ptr -> mailbox.mode = mailbox_mode;

	mailbox_info.ring1_privilege = user_privileges.ring1;

	message_idx = 0;				/* index into user-visible structure */

	do message_block_ptr = mailbox_info.message_blocks.first repeat (next_message_block_ptr)
	     while (message_block_ptr ^= null ());
	     next_message_block_ptr = message_block.next;

	     do idx = 1 to message_block.n_used;
		im_message_info_ptr = addr (message_block.messages (idx));

		im_message_info.flags.can_be_deleted =
		     (mailbox_info.ring1_privilege
		     | aim_check_$equal (im_message_info.mra.access_class, get_authorization_ ()))
		     & (mailbox_info.mode_flags.delete
		     | (message_from_self (im_message_info.mra.sender_id) & mailbox_info.mode_flags.own));

		if im_message_info.format = FIPS98_FORMAT_MESSAGE then
		     im_message_info.flags.requests_acknowledgement = fips98_message.acknowledge;
		else if im_message_info.format = MAIL_FORMAT_MESSAGE then
		     im_message_info.flags.requests_acknowledgement = mail_format.acknowledge;
		else /*** if im_message_info.format = UNKNOWN_FORMAT_MESSAGE then */
		     im_message_info.flags.requests_acknowledgement = "0"b;

		im_message_info.flags.requests_acknowledgement =
		     im_message_info.flags.requests_acknowledgement & mailbox_info.mode_flags.delete
		     & aim_check_$equal (im_message_info.mra.access_class, get_authorization_ ());

		if im_message_info.message_ptr ^= null () then do;
		     im_message_info.message_ptr -> message.flags.can_be_deleted =
			im_message_info.flags.can_be_deleted;
		     im_message_info.message_ptr -> message.flags.must_be_acknowledged =
			im_message_info.flags.requests_acknowledgement;
		end;
	     end;
	end;

	im_message_info_ptr = saved_im_message_info_ptr;	/* keep the caller happy */

	p_code = 0;

	return;

     end recompute_mailbox_access;
%page;
/* Release all storage associated with a mailbox and close the mailbox in ring-1 */

release_mailbox_info:
     procedure ();

dcl  (next_message_block_ptr, next_mma_ptr) pointer;
dcl  idx fixed binary;

	if mailbox_info.index ^= 0 then do;		/* there's a mailbox open in ring-1 ... */
	     call mailbox_$close (mailbox_info.index, (0));
	     mailbox_info.index = 0;			/* in case cleanup handler gets called before we're done */
	end;

	if mailbox_info.address_ptr ^= null () then	/* we don't care anymore */
	     call mlsys_address_mgr_$decrement_reference_count (mailbox_info.address_ptr);

	do mailbox_message_area_ptr = mailbox_info.last_message_area_ptr repeat (next_mma_ptr)
	     while (mailbox_message_area_ptr ^= null ());
	     next_mma_ptr = mailbox_message_area.previous;
	     call mlsys_storage_mgr_$release_temp_segment (mailbox_message_area_ptr, (0));
	end;

	if mailbox_info.delete_error_info_ptr ^= null () then do;
	     free mailbox_info.delete_error_info_ptr -> delete_error_info in (mlsys_area);
	     mailbox_info.delete_error_info_ptr = null ();
	end;

	if mailbox_info.mailbox_ptr ^= null () then do;	/* free the user-visible data structure */
	     free mailbox_info.mailbox_ptr -> mailbox in (mlsys_area);
	     mailbox_info.mailbox_ptr = null ();
	end;

	do message_block_ptr = mailbox_info.message_blocks.first repeat (next_message_block_ptr)
	     while (message_block_ptr ^= null ());
	     next_message_block_ptr = message_block.next;
	     do idx = 1 to message_block.n_used;
		im_message_info_ptr = addr (message_block.messages (idx));
		if im_message_info.message_ptr ^= null () then
		     call mlsys_message_mgr_$free_message (im_message_info.message_ptr, (0));
	     end;
	     free message_block in (mlsys_area);
	end;

	free mailbox_info in (mlsys_area);
	mailbox_info_ptr = null ();			/* just to be safe */

	return;

     end release_mailbox_info;
%page;
/* Release all storage associated with any new messages processed by read_new_messages before a fatal error occured */

release_new_mailbox_info:
     procedure ();

dcl  the_area area based;
dcl  next_message_block_ptr pointer;
dcl  (first_idx, idx) fixed binary;

	if n_new_messages > 0 then do;		/* some new messages were read ... */

	     do message_block_ptr = saved_message_block_ptr repeat (next_message_block_ptr)
		while (message_block_ptr ^= null ());
		next_message_block_ptr = message_block.next;

		if message_block_ptr = saved_message_block_ptr then
		     first_idx = saved_message_block_n_used + 1;
		else first_idx = 1;

		do idx = first_idx to message_block.n_used;
		     im_message_info_ptr = addr (message_block.messages (idx));
		     mra_ptr = addr (im_message_info.mra);
		     if mra.ms_ptr ^= null () then do;	/* ... release the message itself */
			free message_bits in (im_message_info.area_ptr -> the_area);
			mra.ms_ptr = null ();
		     end;
		     if im_message_info.message_ptr ^= null () then
			call mlsys_message_mgr_$free_message (im_message_info.message_ptr, (0));
		end;				/* ... release any user visible structures */

		if message_block_ptr ^= saved_message_block_ptr then free message_block in (mlsys_area);
	     end;

	     mailbox_info.message_blocks.last = saved_message_block_ptr;
	     saved_message_block_ptr -> message_block.next = null ();
	     saved_message_block_ptr -> message_block.n_used = saved_message_block_n_used;

	     n_new_messages = 0;			/* done with that part */
	end;

	if new_mailbox_ptr ^= null () then do;		/* started to create new mailbox ... */
	     if new_mailbox_ptr ^= mailbox_ptr then	/* ... it was different */
		free new_mailbox_ptr -> mailbox in (mlsys_area);
	     new_mailbox_ptr = null ();
	end;

	return;

     end release_new_mailbox_info;
%page;
%include mlsys_copy_ptr;
%page;
%include mlsys_mailbox;
%page;
%include mlsys_mailbox_modes;
%page;
%include mlsys_open_options;
%page;
%include mlsys_close_options;
%page;
%include mlsys_delete_error_info;
%page;
%include mlsys_internal_data;
%page;
%include mlsys_fips98_message;
%page;
%include mail_format;
%page;
%include mseg_return_args;
%page;
%include mlsys_message;
%page;
%include mlsys_address_list;
%page;
%include mlsys_address_types;
%page;
%include aim_template;
%page;
%include area_info;
%page;
%include rdm_switch_types;
%page;
%include sub_err_flags;

     end mlsys_mailbox_mgr_;
