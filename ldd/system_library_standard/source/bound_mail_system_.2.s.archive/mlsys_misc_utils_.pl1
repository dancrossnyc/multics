/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(1985-12-19,Herbst), approve(1986-03-25,MCR7367),
     audit(1986-04-28,Margolin), install(1986-05-22,MR12.0-1059):
     Changed $print_message_summary to include "S" column for seen messages.
  2) change(1989-03-16,Vu), approve(1989-03-16,MCR8071),
     audit(1989-03-31,Flegel), install(1989-04-24,MR12.3-1032):
     Changed $print_message_summary to display proper line counter for a
     piece of mail containing more than 9999 lines.
  3) change(1989-06-26,Lee), approve(1989-07-11,MCR8119),
     audit(1989-08-03,LZimmerman), install(1989-10-02,MR12.3-1079):
     phx19187 (Mail 458) - modified print_message_summary/
     print_message_summary_header to drop subject and lines fields if
     necessary to properly handle short lines; it fixes out_of_bounds
     condition for line_lengths less than 15.
  4) change(1999-12-31,Schroth), approve(1999-12-31,MECR-Y2K),
     install(2016-04-10,MR12.6e-0005):
     Correct size condition in year formating for message list.
  5) change(2016-02-24,Swenson), approve(2016-02-24,MCR10009),
     audit(2016-04-10,GDixon), install(2016-04-10,MR12.6e-0005):
     Fix references to (en de)code_clock_value_ to use 4-character time zone.
                                                   END HISTORY COMMENTS */


/* format: off */

/* Miscellaneous Mail System Utilities */

/* Created:  July 1983 by G. Palter */
/* Modified: March 1984 by G. Palter to fix the following mail system errors:
      #0435 -- the error message displayed by send_mail when the target address of a mail table entry is invalid only
         includes the name of the mail table entry.  The actual invalid address (eg: mailbox pathname) is not included
      #0436 -- if a forum meeting is not found in the "forum" search list, the mail system will treat it as a version 1
         forum in the working directory
      #0438 -- the primitives which allow a user to replace the address list portions of a message
         (eg: mail_system_$replace_from, mail_system_$replace_user_field) should not make the user's copy of the address
         list read-only.  Instead, they should copy the user's list to allow the user to continue to modify the list if
         desired for later additional use */

/* format: on,style4,delnl,insnl,ifthenstmt,ifthen,^indcomtxt */


mlsys_misc_utils_:
     procedure ();

	return;


/* Parameters */

dcl  P_code fixed binary (35) parameter;

dcl  P_message_ptr pointer parameter;			/* print_message_summary, search_message: -> the message;
						   create_reply_message: set -> the newly created message */

dcl  P_address_ptr pointer parameter;			/* get_best_address_name, summarize_address,
						   print_validate_results: -> the address */

dcl  P_address_string character (*) varying parameter;	/* get_best_address_name: set to the best possible name;
						   summarize_address: set to the address summary suitable for
						      use in sentences */

dcl  P_is_start_of_sentence bit (1) aligned parameter;	/* summarize_address: ON => format the output assuming it will
						      be at the beginning of a sentence */

dcl  P_line_length fixed binary parameter;		/* print_message_summary_*: line length used for truncation */
dcl  P_output_switch pointer parameter;			/* print_message_summary_*: the I/O switch for printing */

dcl  P_message_number fixed binary parameter;		/* print_message_summary: # to be printed for this message */
dcl  P_is_current_message bit (1) aligned parameter;	/* print_message_summary: ON => mark as the current message */

dcl  P_recipients_info_ptr pointer parameter;		/* print_delivery_results, free_delivery_recipients: -> the
						      recipients_info structure to be printed/freed */

dcl  P_sci_ptr pointer parameter;			/* print_delivery_results, print_validate_results:
						      -> description of subsystem on whose behalf we are
						      printing the results */

dcl  P_errors_only bit (1) aligned parameter;		/* print_delivery_results: ON => print only error messages */

dcl  P_original_message_ptr pointer parameter;		/* create_reply_message: -> message for which a reply message
						      is to be constructed */
dcl  P_reply_options_ptr pointer parameter;		/* create_reply_message: -> options describing how the message
						      is to be created */

dcl  P_search_string character (*) parameter;		/* search_message: the text to look for in the message */
dcl  P_search_options_ptr pointer parameter;		/* search_message: -> structure defining what/how to search */

dcl  P_author_name character (*) parameter;		/* send_message_to_recipient: optional name to be given to the
						      author of the message instead of the default (if any) */
dcl  P_recipient character (*) parameter;		/* send_message_to_recipient: printed representation of the
						      single recipient's address */
dcl  P_delivery_mode fixed binary parameter;		/* send_message_to_recipient: ordinary/interactive/express */
dcl  P_message_subject character (*) parameter;		/* send_message_to_recipient: optional subject */
dcl  P_message_body character (*) parameter;		/* send_message_to_recipient: the text of the message body */
dcl  P_message_access_class bit (72) aligned parameter;	/* send_message_to_recipient: AIM access class of message */
dcl  P_explanation character (*) varying parameter;	/* send_message_to_recipient: set to any explanation returned
						      by the mail system */
/**** format: indcomtxt */


/* Local copies of parameters */

dcl  code fixed binary (35);

dcl  address_ptr pointer;

dcl  line_length fixed binary;
dcl  output_switch pointer;

dcl  sci_ptr pointer;

dcl  original_message_ptr pointer;


/* Remaining declarations */

dcl  1 result aligned based (result_ptr) like recipients_result_list.results;
dcl  1 other_result aligned based (other_result_ptr) like recipients_result_list.results;
dcl  1 expanded_result aligned based (expanded_result_ptr) like expanded_recipients_result_list.entries;
dcl  (result_ptr, other_result_ptr, expanded_result_ptr) pointer;

dcl  original_subject character (original_subject_lth) unaligned based (original_subject_ptr);
dcl  original_subject_ptr pointer;
dcl  original_subject_lth fixed binary (21);

dcl  the_subject character (the_subject_lth) unaligned based (the_subject_ptr);
dcl  the_subject_ptr pointer;
dcl  the_subject_lth fixed binary (21);

dcl  buffer character (buffer_max_lth) unaligned based (buffer_ptr);
dcl  (buffer_ptr, stack_buffer_ptr, segment_buffer_ptr) pointer;
dcl  (buffer_max_lth, stack_buffer_max_lth, segment_buffer_max_lth, buffer_used, buffer_printed) fixed binary (21);

dcl  address_local_variable character (256) varying;
dcl  address_variable character (address_variable_max_lth) varying based (address_variable_ptr);
dcl  address_variable_ptr pointer;
dcl  address_variable_max_lth fixed binary (21);

dcl  users_area area aligned based (users_area_ptr);
dcl  users_area_ptr pointer;

dcl  message_text character (message_lth) unaligned based (message_buffer_ptr);
dcl  message_lth fixed binary (21);
dcl  message_lth_in_words fixed binary (18);
dcl  (message_buffer_ptr, message_canonical_text_ptr, stack_truncation_ptr) pointer;

dcl  search_string character (length (P_search_string)) unaligned based (search_string_ptr);
dcl  (search_string_ptr, translated_search_string_ptr) pointer;

dcl  1 reply_lists aligned,				/* local address lists used to construct the reply message */
       2 to pointer,
       2 cc pointer,
       2 bcc pointer;
dcl  reply_lists_array (3) pointer aligned based (addr (reply_lists));

dcl  1 local_fmo aligned like format_message_options;

dcl  1 local_mbsp aligned like message_body_section_parameter;
dcl  1 local_do aligned like deliver_options;

dcl  1 local_ri aligned,				/* describes one list for send_message_to_recipient */
       2 header like recipients_info.header,
       2 list like recipients_info.lists;

dcl  foreign_system_name character (256) varying;
dcl  address_pathname character (194);
dcl  address_pathname_varying character (194) varying;
dcl  address_dirname character (168);
dcl  (address_ename, address_component) character (32);
dcl  address_type fixed binary;

dcl  (include_author, include_date, include_time, include_subject, include_lines) bit (1) aligned;

dcl  (month, day_of_month, year, hour, minute) fixed binary;
dcl  ten_digits_picture picture "zzzzzzzzz9";
dcl  two_digits_picture picture "99";

dcl  (address_name_max_lth, subject_string_lth) fixed binary (21);

dcl  author_string character (17) varying;
dcl  date_string character (8);
dcl  n_lines_string character (10) varying;
dcl  time_string character (5);
dcl  (ack_flag, current_message_flag, delete_flag, forwarded_flag, seen_flag) character (1);

dcl  use_original_subject bit (1) aligned;
dcl  (list_idx, address_idx, n_duplicates, n_duplicates_processed, expanded_idx, idx) fixed binary;

dcl  compare_against_both bit (1) aligned;

dcl  translation_table character (512) aligned;
dcl  search_succeeds bit (1) aligned;

dcl  person_id character (32);
dcl  anonymous_flag fixed binary;

dcl  MAIL_SYSTEM_ character (32) static options (constant) initial ("mail_system_");

/* format: off */
dcl (SPACE	initial (" "),
     COMMA	initial (","),
     PERIOD	initial ("."),
     NL		initial ("
"))
	character (1) static options (constant);
/* format: on */

dcl  NULL_STRING character (1) static options (constant) initial ("");

dcl  THREE_SPACES character (3) static options (constant) initial ("   ");
dcl  AND_SPACE character (4) static options (constant) initial ("and ");
dcl  ET_AL character (6) static options (constant) initial (" et al");

dcl  REPLY_SUBJECT_PREFIX character (4) static options (constant) initial ("Re: ");

dcl  STACK_EXTENSION fixed binary (18) static options (constant) initial (128);
dcl  BUFFER_STACK_EXTENSION fixed binary (18) static options (constant) initial (1024);

/* format: off */
dcl (LOWERCASE	initial ("abcdefghijklmnopqrstuvwxyz"),
     UPPERCASE	initial ("ABCDEFGHIJKLMNOPQRSTUVWXYZ"))
	character (26) static options (constant);
/* format: on */

dcl  sys_info$max_seg_size fixed binary (19) external;

dcl  iox_$error_output pointer external;
dcl  iox_$user_output pointer external;

/* format: off */
dcl (error_table_$area_too_small, error_table_$bad_subr_arg, error_table_$inconsistent, error_table_$nomatch,
     error_table_$null_info_ptr, error_table_$smallarg, error_table_$unimplemented_version,
     forum_error_table_$no_such_forum, forum_error_table_$not_eligible, forum_error_table_$read_only,
     mlsys_et_$duplicate_address, mlsys_et_$errors_in_list_address, mlsys_et_$invalid_address,
     mlsys_et_$list_address_is_all_duplicates, mlsys_et_$message_delivered, mlsys_et_$message_not_sent,
     mlsys_et_$message_partially_sent, mlsys_et_$message_queued, mlsys_et_$message_queued_and_delivered,
     mlsys_et_$message_too_large, mlsys_et_$mte_not_found, mlsys_et_$no_mailbox, mlsys_et_$no_mailing_list,
     mlsys_et_$no_message_canonical_form, mlsys_et_$not_in_mailbox_message, mlsys_et_$not_message,
     mlsys_et_$null_search_string, mlsys_et_$rejected_by_foreign_system)
	fixed binary (35) external;
/* format: on */

dcl  aim_check_$equal entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
dcl  assign_ entry (pointer, fixed binary, fixed binary (35), pointer, fixed binary, fixed binary (35));
dcl  convert_status_code_ entry (fixed binary (35), character (8) aligned, character (100) aligned);
dcl  cu_$arg_list_ptr entry () returns (pointer);
dcl  cu_$arg_ptr entry (fixed binary, pointer, fixed binary (21), fixed binary (35));
dcl  cu_$grow_stack_frame entry (fixed binary (18), pointer, fixed binary (35));
dcl  cu_$shrink_stack_frame entry (pointer, fixed binary (35));
dcl  decode_clock_value_$date_time
	entry (fixed binary (71), fixed binary, fixed binary, fixed binary, fixed binary, fixed binary, fixed binary,
	fixed binary (71), fixed binary, character (4), fixed binary (35));
dcl  decode_descriptor_
	entry (pointer, fixed binary, fixed binary, bit (1) aligned, fixed binary, fixed binary, fixed binary);
dcl  find_condition_info_ entry (pointer, pointer, fixed binary (35));
dcl  get_authorization_ entry () returns (bit (72) aligned);
dcl  get_line_length_$switch entry (pointer, fixed binary (35)) returns (fixed binary);
dcl  get_system_free_area_ entry () returns (pointer);
dcl  get_temp_segment_ entry (character (*), pointer, fixed binary (35));
dcl  ioa_$general_rs
	entry (pointer, fixed binary, fixed binary, character (*), fixed binary (21), bit (1) aligned, bit (1) aligned);
dcl  ioa_$ioa_switch entry () options (variable);
dcl  iox_$put_chars entry (pointer, pointer, fixed binary (21), fixed binary (35));
dcl  mail_system_$add_address entry (pointer, pointer, character (8), fixed binary (35));
dcl  mail_system_$add_reply_reference entry (pointer, pointer, fixed binary, fixed binary (35));
dcl  mail_system_$compare_addresses entry (pointer, pointer, fixed binary (35)) returns (bit (1) aligned);
dcl  mail_system_$create_mail_table_address
	entry (character (*) varying, character (*) varying, character (*) varying, pointer, fixed binary (35));
dcl  mail_system_$create_message entry (character (8), pointer, fixed binary (35));
dcl  mail_system_$delete_address entry (pointer, fixed binary, fixed binary (35));
dcl  mail_system_$deliver_message entry (pointer, pointer, pointer, fixed binary (35));
dcl  mail_system_$eliminate_duplicate_addresses entry ((*) pointer, fixed binary (35));
dcl  mail_system_$free_address entry (pointer, fixed binary (35));
dcl  mail_system_$free_address_list entry (pointer, fixed binary (35));
dcl  mail_system_$free_message entry (pointer, fixed binary (35));
dcl  mail_system_$get_address_name entry (pointer, character (*) varying, fixed binary (35));
dcl  mail_system_$get_address_pathname entry (pointer, character (*), character (*), character (*), fixed binary (35));
dcl  mail_system_$get_address_string entry (pointer, character (*) varying, fixed binary (35));
dcl  mail_system_$get_address_system entry (pointer, character (256) varying, fixed binary (35));
dcl  mail_system_$get_address_type entry (pointer, fixed binary, fixed binary (35));
dcl  mail_system_$get_mail_table_address entry (pointer, pointer, fixed binary (35));
dcl  mail_system_$merge_address_lists entry (pointer, pointer, bit (1) aligned, pointer, fixed binary (35));
dcl  mail_system_$read_message_canonical_form_p entry (pointer, pointer, fixed binary (21), fixed binary (35));
dcl  mail_system_$replace_bcc entry (pointer, pointer, fixed binary (35));
dcl  mail_system_$replace_body entry (pointer, pointer, fixed binary (35));
dcl  mail_system_$replace_cc entry (pointer, pointer, fixed binary (35));
dcl  mail_system_$replace_from entry (pointer, pointer, fixed binary (35));
dcl  mail_system_$replace_subject entry (pointer, character (*), fixed binary (35));
dcl  mail_system_$replace_to entry (pointer, pointer, fixed binary (35));
dcl  mail_system_$set_access_class entry (pointer, bit (72) aligned, fixed binary (35));
dcl  mlsys_psp_$forum_not_available entry () returns (bit (1) aligned);
dcl  mlsys_utils_$format_address_field
	entry (character (*) varying, pointer, fixed binary, pointer, fixed binary (21), fixed binary (21),
	fixed binary (35));
dcl  mlsys_utils_$format_message_canonical_form
	entry (pointer, pointer, pointer, fixed binary (21), fixed binary (21), fixed binary (35));
dcl  mlsys_utils_$parse_address_text entry (character (*), pointer, fixed binary (35));
dcl  mvt_ entry (pointer, pointer, fixed binary (21), character (512) aligned);
dcl  mvt_$make_translation_table entry (character (*), character (*), character (512) aligned);
dcl  pathname_ entry (character (*), character (*)) returns (character (168));
dcl  pathname_$component entry (character (*), character (*), character (*)) returns (character (194));
dcl  release_temp_segment_ entry (character (*), pointer, fixed binary (35));
dcl  requote_string_ entry (character (*)) returns (character (*));
dcl  search_file_$silent
	entry (pointer, fixed binary (21), fixed binary (21), pointer, fixed binary (21), fixed binary (21),
	fixed binary (21), fixed binary (21), fixed binary (35));
dcl  ssu_$print_message entry () options (variable);
dcl  sub_err_ entry () options (variable);
dcl  user_info_$login_data entry (character (*), character (*), character (*), fixed binary);

dcl  (cleanup, io_error) condition;

dcl  (addr, addwordno, after, baseno, binary, convert, copy, divide, index, length, ltrim, maxlength, min, mod, null,
     reverse, rtrim, stackframeptr, string, substr, translate, verify) builtin;
%page;
/* Obtain the address name or the best possible substitute:  If there is no address name, use the printed representation
   of the address.  If whatever is to be returned is too long for the caller's buffer, indicate this by changing the last
   three characters of the text into an ellipsis */

get_best_address_name:
     entry (P_address_ptr, P_address_string, P_code);

	address_ptr = P_address_ptr;
	address_name_max_lth = maxlength (P_address_string);

	begin;					/* need a local copy (sigh) */

dcl  local_address_name character (address_name_max_lth) varying;

dcl  address_name character (address_name_max_lth) varying based (address_name_ptr);
dcl  address_name_ptr pointer;

dcl  1 fixed_address_name aligned based (address_name_ptr),
       2 lth fixed binary (21),
       2 string character (address_name_max_lth) unaligned;

	     address_name_ptr = addr (local_address_name);

	     call mail_system_$get_address_name (address_ptr, address_name, code);
	     if (code ^= 0) & (code ^= error_table_$smallarg) then do;
		P_code = code;			/* not an address? */
		return;
	     end;

	     if code = error_table_$smallarg then do;	/* too large for the preallocated space ... */
		call cu_$grow_stack_frame (STACK_EXTENSION, address_name_ptr, (0));
		address_name_max_lth = 4 * (STACK_EXTENSION - 1);

		call mail_system_$get_address_name (address_ptr, address_name, code);
						/* try again using space at the end of the stack ... */

		do while (code = error_table_$smallarg);/* ... and keep trying 'till it fits */
		     call cu_$grow_stack_frame (STACK_EXTENSION, (null ()), (0));
		     address_name_max_lth = address_name_max_lth + (4 * STACK_EXTENSION);
		     call mail_system_$get_address_name (address_ptr, address_name, code);
		end;
	     end;

	     if length (address_name) = 0 then do;	/* no name: use printed representation */
		fixed_address_name.lth = 0;
		call mlsys_utils_$format_address_field ("", address_ptr, -1, addr (fixed_address_name.string),
		     address_name_max_lth, fixed_address_name.lth, code);
		if code = error_table_$smallarg then do;/* ... as much as would is actually there */
		     fixed_address_name.lth = address_name_max_lth;
		     substr (fixed_address_name.string, (address_name_max_lth - 2), 3) = "...";
		end;
	     end;

	     if length (address_name) > maxlength (P_address_string) then
		P_address_string = substr (address_name, 1, (maxlength (P_address_string) - 3)) || "...";
	     else P_address_string = address_name;
	end;

	P_code = 0;				/* success */

	return;
%page;
/**** format: ^indcomtxt */
/* Returns a description of the given address suitable for use in error messages, etc:  Examples of the output produced by
   this entrypoint include:
		Palter.Multics
		your logbox
		the mailing list >udd>m>gmp>mail_project
		the group named Mail System Maintainers */
/**** format: indcomtxt */

summarize_address:
     entry (P_address_ptr, P_is_start_of_sentence, P_address_string, P_code);

	address_ptr = P_address_ptr;

	call mail_system_$get_address_type (address_ptr, address_type, code);
	if code ^= 0 then do;			/* not an address? */
	     P_code = code;
	     return;
	end;

	begin;					/* temporary is 1 larger than caller's to detect truncation */

dcl  address_string character (maxlength (P_address_string) + 1) varying;

	     go to SUMMARIZE_ADDRESS (address_type);

SUMMARIZE_ADDRESS (0):				/* invalid address */
	     call get_address_variable (mail_system_$get_address_string);
	     if P_is_start_of_sentence then
		address_string = "The invalid address ";
	     else address_string = "the invalid address ";
	     address_string = address_string || requote_string_ ((address_variable));
	     go to END_SUMMARIZE_ADDRESS_CASE;


SUMMARIZE_ADDRESS (1):				/* user mailbox address */
	     call get_address_variable (mail_system_$get_address_string);
	     address_string = address_variable;
	     go to END_SUMMARIZE_ADDRESS_CASE;


SUMMARIZE_ADDRESS (2):				/* logbox address */
	     if mail_system_$compare_addresses (address_ptr, mlsys_data_$user_logbox_address, (0)) then do;
		if P_is_start_of_sentence then
		     address_string = "Your logbox";
		else address_string = "your logbox";
		go to END_SUMMARIZE_ADDRESS_CASE;
	     end;
	     /*** Not the user's logbox: treat it as a random savebox */


SUMMARIZE_ADDRESS (3):				/* savebox address */
	     call mail_system_$get_address_pathname (address_ptr, address_dirname, address_ename, ((32)" "), (0));
	     address_pathname = pathname_ (address_dirname, address_ename);
	     if P_is_start_of_sentence then
		address_string = "The savebox ";
	     else address_string = "the savebox ";
	     address_string = address_string || reverse (after (reverse (address_pathname), reverse (".sv.mbx")));
	     go to END_SUMMARIZE_ADDRESS_CASE;


SUMMARIZE_ADDRESS (4):				/* mailbox address */
	     call mail_system_$get_address_pathname (address_ptr, address_dirname, address_ename, ((32)" "), (0));
	     address_pathname = pathname_ (address_dirname, address_ename);
	     if P_is_start_of_sentence then
		address_string = "The mailbox ";
	     else address_string = "the mailbox ";
	     address_string = address_string || reverse (after (reverse (address_pathname), reverse (".mbx")));
	     go to END_SUMMARIZE_ADDRESS_CASE;


SUMMARIZE_ADDRESS (5):				/* forum address */
	     if P_is_start_of_sentence then
		address_string = "The forum meeting ";
	     else address_string = "the forum meeting ";
	     call mail_system_$get_address_pathname (address_ptr, address_dirname, address_ename, ((32)" "), (0));
	     if address_dirname = "" then		/* ... a meeting which couldn't be found by search list */
		address_pathname_varying = rtrim (address_ename);
	     else address_pathname_varying = rtrim (pathname_ (address_dirname, address_ename));
	     if index (reverse (address_pathname_varying), reverse (".forum")) = 1 then
		address_pathname_varying =
		     substr (address_pathname_varying, 1, (length (address_pathname_varying) - length (".forum")));
	     else if index (reverse (address_pathname_varying), reverse (".control")) = 1 then
		address_pathname_varying =
		     substr (address_pathname_varying, 1, (length (address_pathname_varying) - length (".control")));
	     address_string = address_string || address_pathname_varying;
	     go to END_SUMMARIZE_ADDRESS_CASE;


SUMMARIZE_ADDRESS (6):				/* foreign address */
	     call get_address_variable (mail_system_$get_address_string);
	     call mail_system_$get_address_system (address_ptr, foreign_system_name, (0));
	     address_string = address_variable;
	     address_string = address_string || " at ";
	     address_string = address_string || foreign_system_name;
	     go to END_SUMMARIZE_ADDRESS_CASE;


SUMMARIZE_ADDRESS (7):				/* mail table address */
	     call get_address_variable (mail_system_$get_address_string);
	     address_string = address_variable;
	     go to END_SUMMARIZE_ADDRESS_CASE;


SUMMARIZE_ADDRESS (8):				/* mailing list address */
	     call mail_system_$get_address_pathname (address_ptr, address_dirname, address_ename, address_component,
		(0));
	     address_pathname = pathname_$component (address_dirname, address_ename, address_component);
	     if P_is_start_of_sentence then
		address_string = "The mailing list ";
	     else address_string = "the mailing list ";
	     address_string = address_string || reverse (after (reverse (address_pathname), reverse (".mls")));
	     go to END_SUMMARIZE_ADDRESS_CASE;


SUMMARIZE_ADDRESS (9):				/* named group address */
	     call get_address_variable (mail_system_$get_address_name);
	     if P_is_start_of_sentence then
		address_string = "The group named ";
	     else address_string = "the group named ";
	     address_string = address_string || address_variable;
	     go to END_SUMMARIZE_ADDRESS_CASE;


END_SUMMARIZE_ADDRESS_CASE:
	     if length (address_string) <= maxlength (P_address_string) then do;
		P_address_string = address_string;
		P_code = 0;
	     end;
	     else P_code = error_table_$smallarg;

	     return;



/* Internal to summarize_address begin block: gets one of the variables (string, name, comment) associated with an
   address; it will grow the begin block's stack frame as necessary */

get_address_variable:
     procedure (p_get_primitive) /* options (quick) */;

dcl  p_get_primitive entry (pointer, character (*) varying, fixed binary (35));
dcl  code fixed binary (35);

	address_variable_ptr = addr (address_local_variable);
	address_variable_max_lth = maxlength (address_local_variable);
						/* assume it will fit in the local copy */

	call p_get_primitive (address_ptr, address_variable, code);

	if code = error_table_$smallarg then do;	/* too large for the preallocated space ... */
	     call cu_$grow_stack_frame (STACK_EXTENSION, address_variable_ptr, (0));
	     address_variable_max_lth = 4 * (STACK_EXTENSION - 1);

	     call p_get_primitive (address_ptr, address_variable, code);
						/* try again using space at the end of the stack ... */

	     do while (code = error_table_$smallarg);	/* ... and keep trying 'till it fits */
		call cu_$grow_stack_frame (STACK_EXTENSION, (null ()), (0));
		address_variable_max_lth = address_variable_max_lth + (4 * STACK_EXTENSION);
		call p_get_primitive (address_ptr, address_variable, code);
	     end;
	end;

	return;

     end get_address_variable;

	end;
%page;
/* Print the header line for a subsequent message summary */

print_message_summary_header:
     entry (P_line_length, P_output_switch, P_code);

	line_length = P_line_length;
	if (line_length < -1) | ((line_length > 0) & (line_length ^> 30)) then do;
	     P_code = error_table_$bad_subr_arg;
	     return;
	end;

	if P_output_switch = null () then		/* default to the terminal if not specified */
	     output_switch = iox_$user_output;
	else output_switch = P_output_switch;

	if line_length = 0 then			/* default to line length of switch if not specified */
	     line_length = get_line_length_$switch (output_switch, (0));

	include_author, include_date, include_time, include_subject, include_lines = "1"b; /* assume nothing is truncated */

	if line_length > 0 then do;			/* only if we're asked to truncate if necessary */
	     if line_length < 72 then include_time = "0"b;/* not enough room to insure 22 characters of subject */
	     if line_length < 66 then include_date = "0"b;
	     if line_length < 56 then include_author = "0"b;
	     if line_length < 22 then include_subject = "0"b;
	     if line_length < 14 then include_lines = "0"b;
						/* phx19187 RL: handle line lengths < 22 as well */
	end;

	on condition (io_error)
	     begin;				/* I/O failed for some reason */
	     call get_ioa_error_code (P_code);
	     go to RETURN_FROM_PRINT_MESSAGE_SUMMARY_HEADER;
	end;

	call ioa_$ioa_switch (output_switch,
	     "^/Msg#^[^5xLines^2x^]^[^2xDate^[^3x^;^4x^]^;^s^]^[Time^3x^]^[From^15x^]^[Subject^]", include_lines, include_date, include_time,
	     include_time, include_author, include_subject);

	P_code = 0;

RETURN_FROM_PRINT_MESSAGE_SUMMARY_HEADER:
	return;
%page;
/* Print a one/two line summary of a message */

print_message_summary:
     entry (P_message_ptr, P_message_number, P_is_current_message, P_line_length, P_output_switch, P_code);

	message_ptr = P_message_ptr;
	if message.version ^= MESSAGE_VERSION_2 then do;
	     P_code = mlsys_et_$not_message;
	     return;
	end;

	line_length = P_line_length;
	if (line_length < -1) | ((line_length > 0) & (line_length ^> 30)) then do;
	     P_code = error_table_$bad_subr_arg;
	     return;
	end;

	if P_output_switch = null () then		/* default to the terminal if not specified */
	     output_switch = iox_$user_output;
	else output_switch = P_output_switch;

	if line_length = 0 then			/* default to line length of switch if not specified */
	     line_length = get_line_length_$switch (output_switch, (0));

	include_author, include_date, include_time, include_subject, include_lines = "1"b; /* until we're told otherwise */

	if line_length > 0 then do;			/* only if we're asked to truncate if necessary */
	     if line_length < 72 then include_time = "0"b;/* not enough room to insure 22 characters of subject */
	     if line_length < 66 then include_date = "0"b;
	     if line_length < 56 then include_author = "0"b;
	     if line_length < 22 then include_subject = "0"b;
	     if line_length < 14 then include_lines = "0"b;
	end;

	if P_is_current_message then current_message_flag = "*";
	else if message.marked_for_deletion then current_message_flag = "!";
	else current_message_flag = " ";

	if message.seen then
	     seen_flag = "S";
	else seen_flag = " ";

	if message.must_be_acknowledged then
	     ack_flag = "A";
	else ack_flag = " ";

	if message.can_be_deleted then		/* it can be deleted */
	     delete_flag = " ";
	else if ^aim_check_$equal (message.access_class, get_authorization_ ()) then delete_flag = "&";
						/* can't be deleted because of AIM (at least) */
	else delete_flag = " ";			/* can't be deleted but cause isn't AIM */

	if message.total_lines = -1 then		/* can't say how long this message will be when printed now */
	     n_lines_string = "   (?)";

/**** vp: phx21245, changed four_digits_picture to ten_digits_picture
      and changed n_lines_string from char(6) to char(10) ****/
	else do;
	     n_lines_string = "(" || ltrim (convert (ten_digits_picture, message.total_lines)) || ")";
	     if length (n_lines_string) < 6 then	/* padded blanks to make up six characters */
		n_lines_string = copy (SPACE, (6 - length (n_lines_string))) || n_lines_string;
	end;

	if message.n_redistributions > 0 then
	     forwarded_flag = "F";
	else forwarded_flag = " ";

	if include_date then do;			/* won't include time unless the date is also */
	     call decode_clock_value_$date_time (message.date_time_created, month, day_of_month, year, hour, minute,
		(0), (0), (0), ((4)" "), (0));
	     date_string =
		convert (two_digits_picture, month) || "/" || convert (two_digits_picture, day_of_month) || "/"
		|| convert (two_digits_picture, mod(year, 100));
	     time_string = convert (two_digits_picture, hour) || ":" || convert (two_digits_picture, minute);
	end;

	call get_best_address_name (message.from -> address_list.addresses (1), author_string, (0));
						/* guarenteed to have at least one author */

	if message.from -> address_list.n_addresses > 1 then
	     if length (author_string) < (maxlength (author_string) - length (ET_AL)) then
		author_string = author_string || ET_AL;

	the_subject_ptr = addr (SPACE);		/* assume no subject 'till proven otherwise */
	the_subject_lth = 0;

	if length (message_subject) > 0 then do;	/* there's a subject all right */
	     the_subject_ptr = message.subject.text_ptr;
	     the_subject_lth = message.subject.text_lth;
	end;

	else					/* check for interactive message */
	     if message.interactive & (message.total_lines > 0) then
	     if message.body_sections (1).section_type = MESSAGE_PREFORMATTED_BODY_SECTION then do;
		message_body_section_ptr = addr (message.body_sections (1));
		the_subject_ptr = addr (message_preformatted_body_section_text);
		the_subject_lth = index (message_preformatted_body_section_text, NL) - 1;
		if the_subject_lth = -1 then the_subject_lth = length (message_preformatted_body_section_text);
	     end;

	if line_length = -1 then			/* want the entire subject no matter what ... */
	     subject_string_lth = the_subject_lth;

	else if include_time then			/* all other fields are present */
	     subject_string_lth = min (the_subject_lth, (line_length - 51));
	else if include_date then subject_string_lth = min (the_subject_lth, (line_length - 45));
	else if include_author then subject_string_lth = min (the_subject_lth, (line_length - 35));
	else do;
	     if line_length < 17 then
		subject_string_lth = 0;
	     else
		subject_string_lth = min (the_subject_lth, (line_length - 16));
						/* phx19187 RL: no subject field if line short enough */
	end;

	begin;
dcl  subject_string character (subject_string_lth);

	     subject_string = substr (the_subject, 1, length (subject_string));
	     if subject_string_lth < the_subject_lth then /* subject was truncated ... */
		substr (subject_string, (subject_string_lth - 5), 6) = "<MORE>";

	     on condition (io_error)
		begin;				/* in case the I/O fails */
		call get_ioa_error_code (P_code);
		go to RETURN_FROM_PRINT_MESSAGE_SUMMARY;
	     end;

	     call ioa_$ioa_switch (output_switch,
		"^4d^1a^1a^1a^1a^[^a^1a^x^;^2s^]^[^a^[^x^;^2x^]^;^2s^]^[^a^2x^;^s^]^[^17a^2x^;^s^]^[^a^]",
		P_message_number, current_message_flag, seen_flag, ack_flag, delete_flag,
		include_lines, n_lines_string, forwarded_flag, include_date, date_string,
		include_time, include_time, time_string, include_author, author_string,
		include_subject, subject_string);

	end;

	P_code = 0;				/* success */

RETURN_FROM_PRINT_MESSAGE_SUMMARY:
	return;
%page;
/* Display the results of a message transmission operation as described by the data structures created by
   mail_system_$deliver_message or mail_system_$redistribute_message */

print_delivery_results:
     entry (P_sci_ptr, P_errors_only, P_recipients_info_ptr, P_code);

	sci_ptr = P_sci_ptr;

	recipients_info_ptr = P_recipients_info_ptr;
	if recipients_info.version ^= RECIPIENTS_INFO_VERSION_2 then do;
	     P_code = error_table_$unimplemented_version;
	     return;
	end;

	call cu_$grow_stack_frame (BUFFER_STACK_EXTENSION, stack_buffer_ptr, (0));
	stack_buffer_max_lth = 4 * BUFFER_STACK_EXTENSION;

	segment_buffer_ptr = null ();			/* for cleanup handler */

	on condition (cleanup) call cleanup_print_delivery_results ();


/* Print a list of all duplicated recipients and mailing lists/named groups whose entire content is duplicate addresses
   with an indication that said recipients received only a single copy of the message */

	n_duplicates = 0;

	do list_idx = 1 to recipients_info.n_lists;
	     recipients_result_list_ptr = recipients_info.lists (list_idx).recipients_result_list_ptr;
	     if recipients_result_list_ptr ^= null () then do;
		do address_idx = 1 to recipients_result_list.n_addresses;
		     result_ptr = addr (recipients_result_list.results (address_idx));
		     if result.code = mlsys_et_$duplicate_address then do;
			other_result_ptr =
			     addr (recipients_info.lists (result.list_idx).recipients_result_list_ptr
			     -> recipients_result_list.results (result.address_idx));
			if other_result.list_idx = 0 then do;
			     n_duplicates = n_duplicates + 1;
			     other_result.list_idx = recipients_info.n_lists + 1;
			end;
		     end;
		     else if result.code = mlsys_et_$list_address_is_all_duplicates then
			n_duplicates = n_duplicates + 1;
		end;
	     end;
	end;

	if n_duplicates ^= 0 then do;			/* there are duplicates ... */
	     call start_new_output ();		/* initialize the output buffer */
	     call add_to_buffer_fixed (THREE_SPACES);

	     n_duplicates_processed = 0;

	     do list_idx = 1 to recipients_info.n_lists;
		address_list_ptr = recipients_info.lists (list_idx).address_list_ptr;
		recipients_result_list_ptr = recipients_info.lists (list_idx).recipients_result_list_ptr;
		if recipients_result_list_ptr ^= null () then do;
		     do address_idx = 1 to recipients_result_list.n_addresses;
			result_ptr = addr (recipients_result_list.results (address_idx));
			if (result.list_idx = (recipients_info.n_lists + 1))
			     | (result.code = mlsys_et_$list_address_is_all_duplicates) then do;
			     n_duplicates_processed = n_duplicates_processed + 1;
			     if (n_duplicates > 2) & (n_duplicates_processed > 1) then
				call add_to_buffer_fixed (COMMA);
			     call add_to_buffer_fixed (SPACE);
			     if (n_duplicates > 1) & (n_duplicates_processed = n_duplicates) then
				call add_to_buffer_fixed (AND_SPACE);
			     call get_address_summary (address_list.addresses (address_idx), "0"b);
			     call add_to_buffer_varying (address_variable);
			end;
		     end;
		end;
	     end;
	     call add_to_buffer_fixed (PERIOD);
	     call add_to_buffer_fixed (NL);

	     call ssu_$print_message (sci_ptr, mlsys_et_$duplicate_address,
		"Only one copy of this message was sent to the following address^[es^]:", (n_duplicates > 1));
	     call print_the_buffer ();		/* print it neatly */
	end;


/* Print appropriate error messages for all recipients for which delivery failed or for which transient errors caused the
   message to be queued */

	expanded_recipients_result_list_ptr = recipients_info.expanded_recipients_result_list_ptr;

	do list_idx = 1 to recipients_info.n_lists;
	     address_list_ptr = recipients_info.lists (list_idx).address_list_ptr;
	     recipients_result_list_ptr = recipients_info (list_idx).recipients_result_list_ptr;

	     if recipients_result_list_ptr ^= null () then do;

		do address_idx = 1 to recipients_result_list.n_addresses;
		     address_ptr = address_list.addresses (address_idx);
		     result_ptr = addr (recipients_result_list.results (address_idx));

		     if (result.code = mlsys_et_$duplicate_address)
			| (result.code = mlsys_et_$list_address_is_all_duplicates) | (result.code = 0)
			| (result.code = mlsys_et_$message_delivered)
			| ((result.code = mlsys_et_$message_queued) & (length (result.explanation) = 0)
			& (result.first_entry_idx = 0))
			| ((result.code = mlsys_et_$message_queued_and_delivered) & (result.first_entry_idx = 0))
			then
			;			/* delivery was OK or already described for this recipient */

		     else if (result.code = mlsys_et_$errors_in_list_address)
			|
			(((result.code = mlsys_et_$message_queued)
			| (result.code = mlsys_et_$message_queued_and_delivered)) & (result.first_entry_idx ^= 0))
		     then do;
			/*** Mailing list/named group which experienced some form of problems */
			call get_true_address_summary (address_ptr, "0"b);
			if result.code = mlsys_et_$errors_in_list_address then
			     call ssu_$print_message (sci_ptr, 0, "Mail not delivered to all addresses in ^a:",
				address_variable);
			else call ssu_$print_message (sci_ptr, 0,
				"Mail could not be delivered immediately to some addresses in ^a:",
				address_variable);
			if address_variable_ptr ^= addr (address_local_variable) then
			     call cu_$shrink_stack_frame (address_variable_ptr, (0));
			do expanded_idx = result.first_entry_idx to (result.first_entry_idx + result.n_entries - 1);
			     expanded_result_ptr = addr (expanded_recipients_result_list.entries (expanded_idx));
			     call print_single_recipient_error (expanded_result.address_ptr, expanded_result.code,
				expanded_result.explanation, print_expansion_error);
			end;
		     end;

		     else call print_single_recipient_error (address_ptr, result.code, result.explanation,
			     ssu_$print_message);
		end;
	     end;
	end;

	if P_errors_only then go to RETURN_FROM_PRINT_DELIVERY_RESULTS;


/* Print the list of recipients to whom the mail was delivered, for whom the mail was queued on explicit request, and the
   mailing lists/named groups for whom the mail was both delivered and queued */

	if is_a_recipient_with_code (mlsys_et_$message_delivered) then
	     call print_recipient_list (mlsys_et_$message_delivered, "Mail delivered to");

	if is_a_recipient_with_code (mlsys_et_$message_queued) then
	     call print_recipient_list (mlsys_et_$message_queued, "Mail queued for");

	if is_a_recipient_with_code (mlsys_et_$message_queued_and_delivered) then
	     call print_recipient_list (mlsys_et_$message_queued_and_delivered,
		"Mail delivered to or queued for all recipients in");


/* Clean up */

	P_code = 0;				/* success */

RETURN_FROM_PRINT_DELIVERY_RESULTS:
	call cleanup_print_delivery_results ();

	return;


ERROR_RETURN_FROM_PRINT_DELIVERY_RESULTS:
	P_code = code;
	go to RETURN_FROM_PRINT_DELIVERY_RESULTS;



/* Release temporary buffers and restore the recipients_info data structures to their original state */

cleanup_print_delivery_results:
     procedure ();

dcl  (list_idx, address_idx) fixed binary;

	if segment_buffer_ptr ^= null () then call release_temp_segment_ (MAIL_SYSTEM_, segment_buffer_ptr, (0));
	segment_buffer_ptr = null ();

	do list_idx = 1 to recipients_info.n_lists;
	     recipients_result_list_ptr = recipients_info.lists (list_idx).recipients_result_list_ptr;
	     if recipients_result_list_ptr ^= null () then do;
		do address_idx = 1 to recipients_result_list.n_addresses;
		     result_ptr = addr (recipients_result_list.results (address_idx));
		     if result.list_idx = (recipients_info.n_lists + 1) then result.list_idx = 0;
		end;
	     end;
	end;

	return;

     end cleanup_print_delivery_results;
%page;
/* Free the data structures created by mail_system_$deliver_message or mail_system_$redistribute_message to describe the
   results of the transmission */

free_delivery_results:
     entry (P_recipients_info_ptr, P_code);

	recipients_info_ptr = P_recipients_info_ptr;

	if recipients_info_ptr = null () then do;	/* allow a null recipients_info for cleanup handlers */
	     P_code = 0;
	     return;
	end;

	if recipients_info.version ^= RECIPIENTS_INFO_VERSION_2 then do;
	     P_code = error_table_$unimplemented_version;
	     return;
	end;

	users_area_ptr = recipients_info.area_ptr;

	if recipients_info.expanded_recipients_result_list_ptr ^= null () then do;
	     expanded_recipients_result_list_ptr = recipients_info.expanded_recipients_result_list_ptr;
	     do idx = 1 to expanded_recipients_result_list.n_entries;
		if expanded_recipients_result_list.entries (idx).address_ptr ^= null () then
		     call mail_system_$free_address (expanded_recipients_result_list.entries (idx).address_ptr, (0));
	     end;
	     free expanded_recipients_result_list in (users_area);
	     recipients_info.expanded_recipients_result_list_ptr = null ();
	end;

	do idx = 1 to recipients_info.n_lists;
	     if recipients_info.lists (idx).recipients_result_list_ptr ^= null () then do;
		recipients_result_list_ptr = recipients_info.lists (idx).recipients_result_list_ptr;
		free recipients_result_list in (users_area);
		recipients_info.lists (idx).recipients_result_list_ptr = null ();
	     end;
	end;

	P_code = 0;				/* success */

	return;
%page;
/* Display an appropriate error message for a failing call to mail_system_$validate_address */

print_validate_results:
     entry (P_sci_ptr, P_address_ptr, P_code);

	if P_code = 0 then return;			/* validation was OK */

	call mail_system_$get_address_type (P_address_ptr, (0), code);
	if code ^= 0 then do;			/* invalid input? */
RESIGNAL_NOT_AN_ADDRESS:
	     call sub_err_ (code, MAIL_SYSTEM_, ACTION_CANT_RESTART, null (), (0), "^p", P_address_ptr);
	     go to RESIGNAL_NOT_AN_ADDRESS;
	end;

	sci_ptr = P_sci_ptr;
	call print_single_recipient_error (P_address_ptr, P_code, "", ssu_$print_message);

	return;
%page;
/* Create a new message which is to be a reply to the supplied in-mailbox message */

create_reply_message:
     entry (P_original_message_ptr, P_reply_options_ptr, P_message_ptr, P_code);

	original_message_ptr = P_original_message_ptr;
	reply_options_ptr = P_reply_options_ptr;

	if reply_options.version ^= REPLY_OPTIONS_VERSION_2 then do;
	     P_code = error_table_$unimplemented_version;
	     return;
	end;
	if reply_options.mbz ^= ""b then do;		/* must-be-zero */
	     P_code = error_table_$bad_subr_arg;
	     return;
	end;


/* Create the message and setup its reference to the original message */

	message_ptr,				/* for cleanup handler */
	     reply_lists, segment_buffer_ptr = null ();

	on condition (cleanup) call cleanup_create_reply_message ("1"b);

	call mail_system_$create_message (original_message_ptr -> message.version, message_ptr, code);
	if code ^= 0 then call abort_create_reply_message (code);

	call mail_system_$add_reply_reference (message_ptr, original_message_ptr, (1), code);
	if code ^= 0 then call abort_create_reply_message (code);


/* Create the subject for the reply by prefixing the original subject (or body for interactive messages) with the prefix
   "Re:" if it isn't already present */

	original_subject_ptr = addr (SPACE);		/* assume no original subject 'till proven otherwise */
	original_subject_lth = 0;

	if original_message_ptr -> message.subject.text_lth > 0 then do;
	     original_subject_ptr = original_message_ptr -> message.subject.text_ptr;
	     original_subject_lth = original_message_ptr -> message.subject.text_lth;
	end;					/* there's a subject */

	else					/* check for interactive message ... */
	     if original_message_ptr -> message.interactive & (original_message_ptr -> message.total_lines > 0) then
	     if original_message_ptr -> message.body_sections (1).section_type = MESSAGE_PREFORMATTED_BODY_SECTION
	     then do;				/* ... which starts with a piece of text */
		message_body_section_ptr = addr (original_message_ptr -> message.body_sections (1));
		original_subject_ptr = addr (message_preformatted_body_section_text);
		original_subject_lth = index (message_preformatted_body_section_text, NL) - 1;
		if original_subject_lth = -1 then
		     original_subject_lth = length (message_preformatted_body_section_text);
	     end;

	if original_subject_lth > 0 then do;		/* there's something from which we can construct a subject */
	     use_original_subject = "0"b;		/* ... assume we will have to add the "Re: " */
	     if (original_subject_lth > length (REPLY_SUBJECT_PREFIX)) then
		if (translate (substr (original_subject, 1, length (REPLY_SUBJECT_PREFIX)), LOWERCASE, UPPERCASE)
		     = translate (REPLY_SUBJECT_PREFIX, LOWERCASE, UPPERCASE)) then
		     use_original_subject = "1"b;	/* subject is already OK */
	     if use_original_subject then
		call mail_system_$replace_subject (message_ptr, original_subject, code);
	     else do;				/* ... necessary to add the "Re: " */
		if (original_subject_lth + length (REPLY_SUBJECT_PREFIX)) <= (4 * BUFFER_STACK_EXTENSION) then
		     begin;			/* ... it'll fit on the stack */
dcl  new_subject character (original_subject_lth + length (REPLY_SUBJECT_PREFIX));
		     new_subject = REPLY_SUBJECT_PREFIX || original_subject;
		     call mail_system_$replace_subject (message_ptr, new_subject, code);
		end;
		else if (original_subject_lth + length (REPLY_SUBJECT_PREFIX)) <= (4 * sys_info$max_seg_size) then do;
						/* ... too long: use a temporary segment */
		     call get_temp_segment_ (MAIL_SYSTEM_, segment_buffer_ptr, code);
		     if code ^= 0 then call abort_create_reply_message (code);
		     the_subject_ptr = segment_buffer_ptr;
		     the_subject_lth = original_subject_lth + length (REPLY_SUBJECT_PREFIX);
		     the_subject = REPLY_SUBJECT_PREFIX || original_subject;
		     call mail_system_$replace_subject (message_ptr, the_subject, code);
		end;
		else code = mlsys_et_$message_too_large;/* ... how'd it ever get this large? */
	     end;
	     if code ^= 0 then call abort_create_reply_message (code);
	end;


/* Include the authors and recipients of the message as recipients of the reply if requested; remove any occurences of the
   user from these lists if the user does not want to receive a copy of the reply except by explicit request in one of the
   address lists passed to this entrypoint */

	if reply_options.include_authors then do;	/* authors are to be primary recipients */
	     if ^is_empty_list (original_message_ptr -> message.reply_to) then
		call mail_system_$merge_address_lists (reply_lists.to, original_message_ptr -> message.reply_to, "0"b,
		     reply_lists.to, code);
	     else call mail_system_$merge_address_lists (reply_lists.to, original_message_ptr -> message.from, "0"b,
		     reply_lists.to, code);
	     if code ^= 0 then call abort_create_reply_message (code);
	end;

	if reply_options.include_recipients then do;	/* original message's recipients should see this */
	     if ^is_empty_list (original_message_ptr -> message.to) then do;
		call mail_system_$merge_address_lists (reply_lists.cc, original_message_ptr -> message.to, "0"b,
		     reply_lists.cc, code);
		if code ^= 0 then call abort_create_reply_message (code);
	     end;
	     if ^is_empty_list (original_message_ptr -> message.cc) then do;
		call mail_system_$merge_address_lists (reply_lists.cc, original_message_ptr -> message.cc, "0"b,
		     reply_lists.cc, code);
		if code ^= 0 then call abort_create_reply_message (code);
	     end;
	     if ^is_empty_list (original_message_ptr -> message.bcc) then do;
		call mail_system_$merge_address_lists (reply_lists.bcc, original_message_ptr -> message.bcc, "0"b,
		     reply_lists.bcc, code);
		if code ^= 0 then call abort_create_reply_message (code);
	     end;
	end;

	if ^reply_options.include_self then do;		/* remove the user from the "automatic" recipients */
	     compare_against_both =			/* ... if they're equal we only need to compare against one */
		^
		mail_system_$compare_addresses (mlsys_data_$user_default_mailbox_address,
		mlsys_data_$user_mail_table_address, (0));
	     do address_list_ptr = reply_lists.to, reply_lists.cc, reply_lists.bcc;
		if ^is_empty_list (address_list_ptr) then do;
		     /*** ... checking backwards allows us to use an indexed do-loop */
		     do address_idx = address_list.n_addresses to 1 by -1;
			code = 0;			/* ... we check the code only once so it needs to be set */
			if mail_system_$compare_addresses (address_list.addresses (address_idx),
			     mlsys_data_$user_default_mailbox_address, (0)) then
			     call mail_system_$delete_address (address_list_ptr, address_idx, code);
			else if compare_against_both then
			     if mail_system_$compare_addresses (address_list.addresses (address_idx),
				mlsys_data_$user_mail_table_address, (0)) then
				call mail_system_$delete_address (address_list_ptr, address_idx, code);
			if code ^= 0 then call abort_create_reply_message (code);
		     end;
		end;
	     end;
	end;


/* Add any recipients explicitly requested by the caller */

	if ^is_empty_list (reply_options.to) then do;
	     call mail_system_$merge_address_lists (reply_lists.to, reply_options.to, "0"b, reply_lists.to, code);
	     if code ^= 0 then call abort_create_reply_message (code);
	end;

	if ^is_empty_list (reply_options.cc) then do;
	     call mail_system_$merge_address_lists (reply_lists.cc, reply_options.cc, "0"b, reply_lists.cc, code);
	     if code ^= 0 then call abort_create_reply_message (code);
	end;

	if ^is_empty_list (reply_options.bcc) then do;
	     call mail_system_$merge_address_lists (reply_lists.bcc, reply_options.bcc, "0"b, reply_lists.bcc, code);
	     if code ^= 0 then call abort_create_reply_message (code);
	end;


/* Eliminate any duplicate addresses from the lists: when done, only one copy of each unique address will remain in the
   lists of recipients */

	call mail_system_$eliminate_duplicate_addresses (reply_lists_array, code);
	if code ^= 0 then call abort_create_reply_message (code);


/* Finally, place the just constructed lists of recipients into the message */

	if ^is_empty_list (reply_lists.to) then do;
	     call mail_system_$replace_to (message_ptr, reply_lists.to, code);
	     if code ^= 0 then call abort_create_reply_message (code);
	end;

	if ^is_empty_list (reply_lists.cc) then do;
	     call mail_system_$replace_cc (message_ptr, reply_lists.cc, code);
	     if code ^= 0 then call abort_create_reply_message (code);
	end;

	if ^is_empty_list (reply_lists.bcc) then do;
	     call mail_system_$replace_bcc (message_ptr, reply_lists.bcc, code);
	     if code ^= 0 then call abort_create_reply_message (code);
	end;


/* Control arrives here iff we have succesfully created the reply message */

	call cleanup_create_reply_message ("0"b);	/* keep the message */

	P_message_ptr = message_ptr;
	P_code = 0;

	return;



/* Aborts an invocation of the create_reply_message entrypoint after an error */

abort_create_reply_message:
     procedure (p_code);

dcl  p_code fixed binary (35) parameter;

	P_code = p_code;
	go to ERROR_RETURN_FROM_CREATE_REPLY_MESSAGE;

     end abort_create_reply_message;

ERROR_RETURN_FROM_CREATE_REPLY_MESSAGE:
	call cleanup_create_reply_message ("1"b);
	return;



/* Releases temporary buffers and address lists used by create_reply_message */

cleanup_create_reply_message:
     procedure (p_free_message);

dcl  p_free_message bit (1) aligned parameter;

	if reply_lists.to ^= null () then call mail_system_$free_address_list (reply_lists.to, (0));
	if reply_lists.cc ^= null () then call mail_system_$free_address_list (reply_lists.cc, (0));
	if reply_lists.bcc ^= null () then call mail_system_$free_address_list (reply_lists.bcc, (0));

	if segment_buffer_ptr ^= null () then do;
	     call release_temp_segment_ (MAIL_SYSTEM_, segment_buffer_ptr, (0));
	     segment_buffer_ptr = null ();
	end;

	if p_free_message then call mail_system_$free_message (message_ptr, (0));

	return;

     end cleanup_create_reply_message;
%page;
/* Searches the canonical form of a message for the given character string which may be a qedx regular expression:  The
   canonical form of a message is the text used by the mail system when it stores the message in a mailbox */

search_message:
     entry (P_message_ptr, P_search_string, P_search_options_ptr, P_code) returns (bit (1) aligned);

	message_ptr = P_message_ptr;
	search_options_ptr = P_search_options_ptr;

	message_canonical_text_ptr,			/* for cleanup handler */
	     message_buffer_ptr, translated_search_string_ptr = null ();

	on condition (cleanup) call cleanup_search_message ();

	if message.version ^= MESSAGE_VERSION_2 then	/* perform a simple validity check */
	     call abort_search_message (mlsys_et_$not_message);

	if search_options.version ^= SEARCH_OPTIONS_VERSION_2 then
	     call abort_search_message (error_table_$unimplemented_version);

	if ^(search_options.search_envelope | search_options.search_header
	     | search_options.search_redistributions_list | search_options.search_body) then
	     call abort_search_message (error_table_$inconsistent);
						/* asked us to not search anything */

	if search_options.mbz ^= ""b then		/* mbz => must be zero */
	     call abort_search_message (error_table_$bad_subr_arg);

	if verify (P_search_string, WHITESPACE) = 0 then	/* can't search for just whitespace */
	     call abort_search_message (mlsys_et_$null_search_string);

	if search_options.regexp_search then do;	/* check the string for syntactic validity */
	     call search_file_$silent (addr (P_search_string), 1, length (P_search_string), addr (NULL_STRING), 1, 0,
		(0), (0), code);
	     if code = error_table_$nomatch then	/* ... only happens if the string has valid syntax */
		code = 0;
	     if code ^= 0 then call abort_search_message (code);
	end;					/* ... something's wrong with the string */


/* Create the canonical form of the message */

	local_fmo.version = FORMAT_MESSAGE_OPTIONS_VERSION_1;
	local_fmo.line_length = -1;			/* no folding */

	if search_options.search_envelope then
	     local_fmo.envelope_formatting_mode = DEFAULT_FORMATTING_MODE;
	else local_fmo.envelope_formatting_mode = NONE_FORMATTING_MODE;

	if search_options.search_header then
	     local_fmo.header_formatting_mode = DEFAULT_FORMATTING_MODE;
	else local_fmo.header_formatting_mode = NONE_FORMATTING_MODE;

	if search_options.search_redistributions_list then
	     local_fmo.redistributions_list_formatting_mode = DEFAULT_FORMATTING_MODE;
	else local_fmo.redistributions_list_formatting_mode = NONE_FORMATTING_MODE;

	local_fmo.include_body = search_options.search_body;

	if ^(search_options.search_envelope & search_options.search_header
	     & search_options.search_redistributions_list & search_options.search_body) then
	     go to MUST_FORMAT_THE_MESSAGE;		/* don't search entire message: can't use ring-2's help */

	/*** First check with ring-2 to see if it already has the canonical form available */
	call mail_system_$read_message_canonical_form_p (message_ptr, message_canonical_text_ptr, message_lth, code);
	if code = 0 then				/* ... ring-2 has the canonical form already */
	     message_buffer_ptr = message_canonical_text_ptr;

	else if (code = mlsys_et_$not_in_mailbox_message) | (code = mlsys_et_$no_message_canonical_form) then do;
	     /*** Ring-2 has no canonical form so we must create it here: Try the stack first ... */
MUST_FORMAT_THE_MESSAGE:
	     call cu_$grow_stack_frame (BUFFER_STACK_EXTENSION, message_buffer_ptr, (0));
	     message_lth = 0;
	     call mlsys_utils_$format_message_canonical_form (message_ptr, addr (local_fmo), message_buffer_ptr,
		(4 * BUFFER_STACK_EXTENSION), message_lth, code);
	     if code = 0 then do;			/* ... the message fits: cleanup unused portion ... */
		message_lth_in_words = divide ((message_lth + 3), 4, 18, 0);
		stack_truncation_ptr =
		     addwordno (message_buffer_ptr, (message_lth_in_words + 16 - mod (message_lth_in_words, 16)));
		call cu_$shrink_stack_frame (stack_truncation_ptr, (0));
	     end;

	     else if code = error_table_$smallarg then do;
		/*** Won't fit on the stack: try a temporary segment */
		call cu_$shrink_stack_frame (message_buffer_ptr, (0));
		call get_temp_segment_ (MAIL_SYSTEM_, message_buffer_ptr, code);
		if code ^= 0 then call abort_search_message (code);
		message_lth = 0;			/* just to be sure */
		call mlsys_utils_$format_message_canonical_form (message_ptr, addr (local_fmo), message_buffer_ptr,
		     (4 * sys_info$max_seg_size), message_lth, code);
		if code = error_table_$smallarg then code = mlsys_et_$message_too_large;
		if code ^= 0 then call abort_search_message (code);
	     end;

	     else call abort_search_message (code);	/* fatal error from the formatter */
	end;

	else call abort_search_message (code);		/* fatal error from ring-2 */


/* Translate the message and search string to uppercase if the caller has requested a case-insensitive search:  We'll use
   mvt_ to perform the translation as the PL/I compiler may generate temporaries which could overflow the stack */

	if search_options.case_insensitive then do;
	     call mvt_$make_translation_table (UPPERCASE, LOWERCASE, translation_table);

	     if message_buffer_ptr = message_canonical_text_ptr then do;
		/*** Text is in ring-2: we'll have to copy it */
		if message_lth <= (4 * BUFFER_STACK_EXTENSION) then
		     call cu_$grow_stack_frame (divide ((message_lth + 3), 4, 18, 0), message_buffer_ptr, (0));
		else do;
		     call get_temp_segment_ (MAIL_SYSTEM_, message_buffer_ptr, code);
		     if code ^= 0 then call abort_search_message (code);
		end;
		call mvt_ (message_canonical_text_ptr, message_buffer_ptr, message_lth, translation_table);
	     end;
	     else call mvt_ (message_buffer_ptr, message_buffer_ptr, message_lth, translation_table);

	     if length (P_search_string) <= (4 * BUFFER_STACK_EXTENSION) then
		call cu_$grow_stack_frame (divide ((length (P_search_string) + 3), 4, 18, 0),
		     translated_search_string_ptr, (0));
	     else do;
		call get_temp_segment_ (MAIL_SYSTEM_, translated_search_string_ptr, code);
		if code ^= 0 then call abort_search_message (code);
	     end;
	     call mvt_ (addr (P_search_string), translated_search_string_ptr, length (P_search_string),
		translation_table);
	end;


/* Perform the search */

	if search_options.case_insensitive then
	     search_string_ptr = translated_search_string_ptr;
	else search_string_ptr = addr (P_search_string);

	if search_options.regexp_search then do;
	     call search_file_$silent (search_string_ptr, 1, length (P_search_string), message_buffer_ptr, 1,
		message_lth, (0), (0), code);
	     search_succeeds = (code = 0);
	end;

	else search_succeeds = (index (message_text, search_string) ^= 0);

	P_code = 0;				/* success */


/* Cleanup and return the result */

RETURN_FROM_SEARCH_MESSAGE:
	call cleanup_search_message ();

	return (search_succeeds);



/* Aborts the current search_message operation after a fatal error */

abort_search_message:
     procedure (p_code);

dcl  p_code fixed binary (35) parameter;

	P_code = p_code;				/* reflect the results to our caller */
	search_succeeds = "0"b;			/* the search fials by definition */

	go to RETURN_FROM_SEARCH_MESSAGE;

     end abort_search_message;



/* Releases temporary buffers used by the search_message entrypoint */

cleanup_search_message:
     procedure ();

	if message_buffer_ptr ^= null () then
	     if (message_buffer_ptr ^= message_canonical_text_ptr)
		& (baseno (message_buffer_ptr) ^= baseno (stackframeptr ())) then
		call release_temp_segment_ (MAIL_SYSTEM_, message_buffer_ptr, (0));
	message_buffer_ptr = null ();

	if translated_search_string_ptr ^= null () then
	     if baseno (translated_search_string_ptr) ^= baseno (stackframeptr ()) then
		call release_temp_segment_ (MAIL_SYSTEM_, translated_search_string_ptr, (0));
	translated_search_string_ptr = null ();

	return;

     end cleanup_search_message;
%page;
/* Sends the given message to the address whose printed representation is supplied by the caller */

send_message_to_recipient:
     entry (P_author_name, P_recipient, P_delivery_mode, P_message_subject, P_message_body, P_message_access_class,
	P_explanation, P_code);

	message_ptr,				/* for cleanup handler */
	     address_ptr, address_list_ptr = null ();
	local_ri.version = "";			/* invalid version will stop free_delivery_results */

	on condition (cleanup) call cleanup_send_message ();


/* Create the message: sets the subject, access class, and body to the values supplied by the caller */

	call mail_system_$create_message (MESSAGE_VERSION_2, message_ptr, code);
	if code ^= 0 then call abort_send_message (code);

	if verify (P_message_subject, WHITESPACE) ^= 0 then do;
	     call mail_system_$replace_subject (message_ptr, P_message_subject, code);
	     if code ^= 0 then call abort_send_message (code);
	end;

	if ^aim_check_$equal (P_message_access_class, get_authorization_ ()) then do;
	     call mail_system_$set_access_class (message_ptr, P_message_access_class, code);
	     if code ^= 0 then call abort_send_message (code);
	end;

	local_mbsp.version = MESSAGE_BODY_SECTION_PARAMETER_VERSION_2;
	message_body_section_ptr = addr (local_mbsp.section);
	message_body_section.section_type = MESSAGE_PREFORMATTED_BODY_SECTION;
	message_preformatted_body_section.text_ptr = addr (P_message_body);
	message_preformatted_body_section.text_lth = length (P_message_body);
	call mail_system_$replace_body (message_ptr, addr (local_mbsp), code);
	if code ^= 0 then call abort_send_message (code);


/* Setup a non-default From field using the supplied address name */

	if verify (P_author_name, WHITESPACE) ^= 0 then do;

	     call user_info_$login_data (person_id, ((32)" "), ((32)" "), anonymous_flag);
	     if anonymous_flag = 0 then do;		/* can only do this if not an anonymous user, however */

		call mail_system_$create_mail_table_address (rtrim (person_id), rtrim (P_author_name), "",
		     address_ptr, code);
		if code ^= 0 then call abort_send_message (code);

		address_list_ptr = null ();
		call mail_system_$add_address (address_list_ptr, address_ptr, ADDRESS_LIST_VERSION_2, code);
		if code ^= 0 then call abort_send_message (code);
		address_ptr = null ();		/* the address is now safely in the list */

		call mail_system_$replace_from (message_ptr, address_list_ptr, code);
		if code ^= 0 then call abort_send_message (code);
		call mail_system_$free_address_list (address_list_ptr, (0));
	     end;
	end;


/* Setup the To field to be the supplied recipient */

	call mlsys_utils_$parse_address_text (P_recipient, address_ptr, code);
	if code ^= 0 then call abort_send_message (code);

	address_list_ptr = null ();
	call mail_system_$add_address (address_list_ptr, address_ptr, ADDRESS_LIST_VERSION_2, code);
	if code ^= 0 then call abort_send_message (code);
	address_ptr = null ();			/* the address is now safely in the list */

	call mail_system_$replace_to (message_ptr, address_list_ptr, code);
	if code ^= 0 then call abort_send_message (code);
	call mail_system_$free_address_list (address_list_ptr, (0));


/* Deliver the message */

	local_do.version = DELIVER_OPTIONS_VERSION_2;
	local_do.delivery_mode = P_delivery_mode;
	local_do.queueing_mode = ALWAYS_QUEUE_FOREIGN;
	local_do.queued_notification_mode = NOTIFY_ON_ERROR;
	string (local_do.flags) = ""b;
	local_do.recipient_notification = "1"b;		/* notify if not interactive or express */

	local_ri.area_ptr = get_system_free_area_ ();
	local_ri.n_lists = 1;
	local_ri.list.address_list_ptr = message.to;	/* the recipient was added to the To field */
	local_ri.expanded_recipients_result_list_ptr, local_ri.list.recipients_result_list_ptr = null ();
	local_ri.version = RECIPIENTS_INFO_VERSION_2;

	call mail_system_$deliver_message (message_ptr, addr (local_ri), addr (local_do), code);


/* Determine the appropriate return code */

	P_explanation = "";				/* until proven otherwise */

	if (code = 0) | (code = mlsys_et_$message_not_sent) | (code = mlsys_et_$message_partially_sent) then do;
	     recipients_result_list_ptr = local_ri.list.recipients_result_list_ptr;
	     code = recipients_result_list.results (1).code;
	     P_explanation = recipients_result_list.results (1).explanation;
	end;

	else ;					/* anything other global code is serious */

	P_code = code;				/* set the return code */


/* Cleanup */

RETURN_FROM_SEND_MESSAGE_TO_RECIPIENT:
	call cleanup_send_message ();

	return;



/* Aborts the send_message_to_recipient operation */

abort_send_message:
     procedure (p_code);

dcl  p_code fixed binary (35) parameter;

	P_code = p_code;				/* reflect results to our caller */

	go to RETURN_FROM_SEND_MESSAGE_TO_RECIPIENT;

     end abort_send_message;



/* Releases all temporary data used by this entrypoint */

cleanup_send_message:
     procedure ();

	call free_delivery_results (addr (local_ri), (0));

	if address_list_ptr ^= null () then call mail_system_$free_address_list (address_list_ptr, (0));

	if address_ptr ^= null () then call mail_system_$free_address (address_ptr, (0));

	if message_ptr ^= null () then call mail_system_$free_message (message_ptr, (0));

	return;

     end cleanup_send_message;
%page;
/* Obtains the error code associated with a failed attempt to do I/O through ioa_ */

get_ioa_error_code:
     procedure (p_code);

dcl  p_code fixed binary (35) parameter;

dcl  1 local_ci aligned like condition_info;

	local_ci.version = condition_info_version_1;

	call find_condition_info_ (null (), addr (local_ci), p_code);
	if p_code ^= 0 then return;

	if local_ci.info_ptr ^= null () then		/* there's a status code out there */
	     p_code = local_ci.info_ptr -> io_error_info.status.code;
	else p_code = error_table_$null_info_ptr;	/* have to return something ... */

	return;

     end get_ioa_error_code;
%page;
/* Gets the address summary of the specified address (see summarize_address, above); it will grow the caller's stack frame
   as necessary */

get_address_summary:
     procedure (p_address_ptr, p_is_start_of_sentence) /* options (quick) */;

dcl  p_address_ptr pointer parameter;
dcl  p_is_start_of_sentence bit (1) aligned parameter;
dcl  code fixed binary (35);

	address_variable_ptr = addr (address_local_variable);
	address_variable_max_lth = maxlength (address_local_variable);
						/* assume it will fit in the local copy */

	call summarize_address (p_address_ptr, p_is_start_of_sentence, address_variable, code);

	if code = error_table_$smallarg then do;	/* too large for the preallocated space ... */
	     call cu_$grow_stack_frame (STACK_EXTENSION, address_variable_ptr, (0));
	     address_variable_max_lth = 4 * (STACK_EXTENSION - 1);

	     call summarize_address (p_address_ptr, p_is_start_of_sentence, address_variable, code);
						/* try again using space at the end of the stack ... */

	     do while (code = error_table_$smallarg);	/* ... and keep trying 'till it fits */
		call cu_$grow_stack_frame (STACK_EXTENSION, (null ()), (0));
		address_variable_max_lth = address_variable_max_lth + (4 * STACK_EXTENSION);
		call summarize_address (p_address_ptr, p_is_start_of_sentence, address_variable, code);
	     end;
	end;

	return;

     end get_address_summary;
%page;
/**** format: ^indcomtxt */
/* Gets the "true" description of the specified address.  The true description of all addresses expect mail table
   addresses is returned by the summarize_address entrypoint; for mail table addresses it is:
	<target-summary> for the address NAME
   where "<target-summary>" is the description of the address actually in the mail table and "NAME" is the name of the
   entry in the mail table */
/**** format: indcomtxt */

get_true_address_summary:
     procedure (p_address_ptr, p_is_start_of_sentence) /* options (quick) */;

dcl  p_address_ptr pointer parameter;
dcl  p_is_start_of_sentence bit (1) aligned parameter;

dcl  address_ptr pointer;
dcl  address_pathname character (194);
dcl  address_dirname character (168);
dcl  address_ename character (32);
dcl  mte_name character (32) varying;
dcl  code fixed binary (35);
dcl  address_type fixed binary;

	call mail_system_$get_address_type (p_address_ptr, address_type, (0));
	if address_type = MAIL_TABLE_ADDRESS then do;
	     call mail_system_$get_mail_table_address (p_address_ptr, address_ptr, code);
	     if code ^= 0 then			/* lookup failed: stick with the original address */
		address_ptr = p_address_ptr;
	end;
	else address_ptr = p_address_ptr;

	call get_address_summary (address_ptr, p_is_start_of_sentence);

	if address_ptr ^= p_address_ptr then do;	/* picked up an expansion from the mail table ... */
	     call mail_system_$get_address_string (p_address_ptr, mte_name, (0));
	     call mail_system_$get_address_type (address_ptr, address_type, (0));
	     if address_type = USER_MAILBOX_ADDRESS then do;
		call mail_system_$get_address_pathname (address_ptr, address_dirname, address_ename, ((32)" "), (0));
		address_pathname = pathname_ (address_dirname, address_ename);
		if p_is_start_of_sentence then
		     address_variable = "The mailbox ";
		else address_variable = "the mailbox ";
		address_variable = address_variable || reverse (after (reverse (address_pathname), reverse (".mbx")));
	     end;
	     if (length (address_variable) + length (mte_name) + length (" for the address "))
		> maxlength (address_variable) then
		if addr (address_variable) = addr (address_local_variable) then do;
		     call cu_$grow_stack_frame (STACK_EXTENSION, address_variable_ptr, (0));
		     address_variable_max_lth = 4 * (STACK_EXTENSION - 1);
		     address_variable = address_local_variable;
		end;
		else do;
		     call cu_$grow_stack_frame (STACK_EXTENSION, (null ()), (0));
		     address_variable_max_lth = address_variable_max_lth + (4 * STACK_EXTENSION);
		end;
	     address_variable = address_variable || " for the address ";
	     address_variable = address_variable || mte_name;
	     call mail_system_$free_address (address_ptr, (0));
	end;

	return;

     end get_true_address_summary;
%page;
/* Displays the reason why the message could not be transmitted to the given address or had to be queued instead of
   delivered immediately */

print_single_recipient_error:
     procedure (p_address_ptr, p_code, p_explanation, p_display_message);

dcl  p_address_ptr pointer parameter;
dcl  p_code fixed binary (35) parameter;
dcl  p_explanation character (128) varying parameter;
dcl  p_display_message entry () options (variable) variable parameter;

dcl  (address_pathname, address_dirname) character (168);
dcl  user_name character (64) varying;
dcl  address_ename character (32);
dcl  address_type fixed binary;

	address_variable_ptr = addr (address_local_variable);
	address_variable_max_lth = maxlength (address_local_variable);
	address_variable = "";			/* insures everything will work OK */

	call mail_system_$get_address_type (p_address_ptr, address_type, (0));

	if p_code = mlsys_et_$message_queued then do;	/* only if it was a transient error that caused queueing */
	     call get_true_address_summary (p_address_ptr, "0"b);
	     call p_display_message (sci_ptr, 0, "Mail queued for ^a because ^a.", address_variable, p_explanation);
	end;

	else if p_code = mlsys_et_$rejected_by_foreign_system then do;
	     call get_true_address_summary (p_address_ptr, "0"b);
	     call p_display_message (sci_ptr, 0, "Mail for ^a was rejected by a foreign system.  ^a", address_variable,
		p_explanation);
	end;

	else if p_code = mlsys_et_$invalid_address then do;
	     call get_true_address_summary (p_address_ptr, "0"b);
	     call p_display_message (sci_ptr, p_code, "^a", after (address_variable, "the invalid address "));
	end;

	else if p_code = mlsys_et_$no_mailbox then do;
	     call get_true_address_summary (p_address_ptr, "1"b);
	     call p_display_message (sci_ptr, 0, "^a does not exist.", address_variable);
	end;

	else if mlsys_psp_$forum_not_available () then go to FORUM_NOT_ON_SYSTEM;

	else if p_code = forum_error_table_$no_such_forum then do;
	     call get_true_address_summary (p_address_ptr, "1"b);
	     call p_display_message (sci_ptr, 0, "^a does not exist.", address_variable);
	end;

	else if p_code = forum_error_table_$not_eligible then do;
	     call get_true_address_summary (p_address_ptr, "0"b);
	     call p_display_message (sci_ptr, 0, "You are not a participant of ^a.", address_variable);
	end;

	else if p_code = forum_error_table_$read_only then do;
	     call get_true_address_summary (p_address_ptr, "0"b);
	     call p_display_message (sci_ptr, 0, "You may not enter transactions into ^a.", address_variable);
	end;

	else
FORUM_NOT_ON_SYSTEM:
	     if p_code = mlsys_et_$mte_not_found then do;
	     call get_address_summary (p_address_ptr, "1"b);
	     call p_display_message (sci_ptr, p_code, "^a", address_variable);
	end;

	else if p_code = mlsys_et_$no_mailing_list then do;
	     call get_true_address_summary (p_address_ptr, "1"b);
	     call p_display_message (sci_ptr, 0, "^a does not exist.", address_variable);
	end;

	else do;					/* everything else */
	     if address_type = USER_MAILBOX_ADDRESS then do;
		call mail_system_$get_address_string (p_address_ptr, user_name, (0));
		call mail_system_$get_address_pathname (p_address_ptr, address_dirname, address_ename, ((32)" "), (0))
		     ;
		address_pathname = pathname_ (address_dirname, address_ename);
		address_variable = "The mailbox ";
		address_variable = address_variable || reverse (after (reverse (address_pathname), reverse (".mbx")));
		address_variable = address_variable || " for the address ";
		address_variable = address_variable || user_name;
	     end;
	     else call get_true_address_summary (p_address_ptr, "1"b);
	     call p_display_message (sci_ptr, p_code, "^a", address_variable);
	end;

	if address_variable_ptr ^= addr (address_local_variable) then
	     call cu_$shrink_stack_frame (address_variable_ptr, (0));

	return;

     end print_single_recipient_error;
%page;
/* Formats and prints an error message for a recipient which is part of the expansion of a mailing list or named group */

print_expansion_error:
     procedure () options (variable) options (non_quick);

dcl  based_fb35 fixed binary (35) based;
dcl  arg_ptr pointer;

dcl  error_message character (100) aligned;
dcl  arg_packed bit (1) aligned;
dcl  (error_code, from_size, to_size) fixed binary (35);
dcl  output_message_lth fixed binary (21);
dcl  (arg_type, arg_ndims, arg_size, arg_scale) fixed binary;

	buffer_ptr = stack_buffer_ptr;		/* always use the in-stack buffer */
	buffer_max_lth = stack_buffer_max_lth;

	call cu_$arg_ptr (2, arg_ptr, (0), (0));
	call decode_descriptor_ (cu_$arg_list_ptr (), 2, arg_type, arg_packed, arg_ndims, arg_size, arg_scale);

	if (arg_type = real_fix_bin_1_dtype) & (arg_packed = "0"b) then
	     error_code = arg_ptr -> based_fb35;	/* caller's code is a single-word fixed binary value */

	else do;					/* caller's code is something else: try to convert it */
	     if (arg_type >= bit_dtype) & (arg_type <= varying_char_dtype) then
		from_size = arg_size;
	     else from_size = (262144 * arg_scale) + arg_size;
	     to_size = 35;				/* target is fixed binary (35) */
	     call assign_ (addr (error_code), (2 * real_fix_bin_1_dtype), to_size, arg_ptr,
		(2 * arg_type + binary (arg_packed, 1)), from_size);
	end;

	buffer_used = 3;				/* we indent these messages 3 space s */
	substr (buffer, 1, buffer_used) = "";

	if error_code ^= 0 then do;			/* get the error message */
	     call convert_status_code_ (error_code, (""), error_message);
	     substr (buffer, (buffer_used + 1), (length (rtrim (error_message)) + 1)) = rtrim (error_message);
	     buffer_used = buffer_used + length (rtrim (error_message)) + 1;
	end;

	begin;					/* always have more than just the code */
dcl  output_message character (buffer_max_lth - buffer_used) unaligned defined (buffer) position (buffer_used + 1);
	     call ioa_$general_rs (cu_$arg_list_ptr (), 3, 4, output_message, output_message_lth, "0"b, "1"b);
	     buffer_used = buffer_used + output_message_lth;
	end;

	call iox_$put_chars (iox_$error_output, buffer_ptr, buffer_used, (0));

	return;

     end print_expansion_error;
%page;
/* Determine if there is at least one address in the list of recipients whose result code is the specified value and which
   was not earlier reported as an error */

is_a_recipient_with_code:
     procedure (p_code) returns (bit (1) aligned);

dcl  p_code fixed binary (35) parameter;
dcl  (list_idx, address_idx) fixed binary;

	do list_idx = 1 to recipients_info.n_lists;
	     recipients_result_list_ptr = recipients_info.lists (list_idx).recipients_result_list_ptr;

	     if recipients_result_list_ptr ^= null () then do;

		do address_idx = 1 to recipients_result_list.n_addresses;
		     result_ptr = addr (recipients_result_list.results (address_idx));

		     if (result.code = p_code) & (length (result.explanation) = 0) & (result.first_entry_idx = 0) then
			return ("1"b);
		end;
	     end;
	end;

	/*** Control arrives here iff there are no recipients with the indicated result code */
	return ("0"b);

     end is_a_recipient_with_code;
%page;
/* Print the list of recipients with the indicated result code */

print_recipient_list:
     procedure (p_code, p_prefix);

dcl  p_code fixed binary (35) parameter;
dcl  p_prefix character (*) parameter;

dcl  (n_recipients, n_recipients_processed, list_idx, address_idx) fixed binary;

	call start_new_output ();			/* initialize the output buffer */
	call add_to_buffer_fixed (p_prefix);

	n_recipients = 0;				/* count the number of interesting recipients first */

	do list_idx = 1 to recipients_info.n_lists;
	     recipients_result_list_ptr = recipients_info.lists (list_idx).recipients_result_list_ptr;
	     if recipients_result_list_ptr ^= null () then do;
		do address_idx = 1 to recipients_result_list.n_addresses;
		     result_ptr = addr (recipients_result_list.results (address_idx));
		     if (result.code = p_code) & (length (result.explanation) = 0) & (result.first_entry_idx = 0) then
			n_recipients = n_recipients + 1;
		end;
	     end;
	end;

	n_recipients_processed = 0;

	do list_idx = 1 to recipients_info.n_lists;
	     address_list_ptr = recipients_info.lists (list_idx).address_list_ptr;
	     recipients_result_list_ptr = recipients_info.lists (list_idx).recipients_result_list_ptr;
	     if recipients_result_list_ptr ^= null () then do;
		do address_idx = 1 to recipients_result_list.n_addresses;
		     result_ptr = addr (recipients_result_list.results (address_idx));
		     if (result.code = p_code) & (length (result.explanation) = 0) & (result.first_entry_idx = 0)
		     then do;
			n_recipients_processed = n_recipients_processed + 1;
			if (n_recipients > 2) & (n_recipients_processed > 1) then call add_to_buffer_fixed (COMMA);
			call add_to_buffer_fixed (SPACE);
			if (n_recipients > 1) & (n_recipients_processed = n_recipients) then
			     call add_to_buffer_fixed (AND_SPACE);
			call get_address_summary (address_list.addresses (address_idx), "0"b);
			call add_to_buffer_varying (address_variable);
		     end;
		end;
	     end;
	end;

	call add_to_buffer_fixed (PERIOD);
	call add_to_buffer_fixed (NL);

	call print_the_buffer ();			/* print it neatly */

	return;

     end print_recipient_list;
%page;
/* Prepare to format a new recipient list in the output buffer */

start_new_output:
     procedure ();

	buffer_ptr = stack_buffer_ptr;		/* start over in the stack */
	buffer_max_lth = stack_buffer_max_lth;
	buffer_used = 0;

	return;

     end start_new_output;



/* Prints the recipient list previously constructed:  The list is folded to the line length of the terminal whenever
   possible */

print_the_buffer:
     procedure ();

dcl  (last_comma, next_comma) fixed binary (21);
dcl  offset fixed binary;

	line_length = get_line_length_$switch (iox_$user_output, (0));

	buffer_printed = 0;
	offset = 0;

	do while (buffer_printed < buffer_used);	/* while there's something left to print */
	     begin;
dcl  rest_of_buffer character (buffer_used - buffer_printed) unaligned defined (buffer) position (buffer_printed + 1);

		last_comma = 0;
		next_comma = index (rest_of_buffer, COMMA);
		if next_comma = 0 then next_comma = length (rest_of_buffer);

		do while (((next_comma + offset) < line_length) & (next_comma < length (rest_of_buffer)));
		     last_comma = next_comma;
		     begin;
dcl  rest_of_rest_of_buffer character (buffer_used - buffer_printed - last_comma) unaligned defined (buffer)
	position (buffer_printed + last_comma + 1);
			next_comma = index (rest_of_rest_of_buffer, COMMA);
			if next_comma = 0 then next_comma = length (rest_of_rest_of_buffer);
			next_comma = last_comma + next_comma;
		     end;
		end;

		if (last_comma ^= 0) & ((next_comma + offset) > line_length) then next_comma = last_comma;

		begin;
dcl  section_to_print character (next_comma) unaligned defined (buffer) position (buffer_printed + 1);
		     call iox_$put_chars (iox_$user_output, addr (section_to_print), length (section_to_print), (0));
		end;

		if next_comma < length (rest_of_buffer) then do;
		     call iox_$put_chars (iox_$user_output, addr (NL), length (NL), (0));
		     call iox_$put_chars (iox_$user_output, addr (THREE_SPACES), length (THREE_SPACES), (0));
		     offset = 3;
		end;

		buffer_printed = buffer_printed + next_comma + 1;
	     end;					/* past the comma and the space after it */
	end;

	return;

     end print_the_buffer;
%page;
/* Add a string to the output buffer: switches to a temporary segment if necessary */

add_to_buffer:
     procedure ();

dcl  p_text character (*) parameter;
dcl  p_varying_text character (*) varying parameter;

dcl  text character (text_lth) unaligned based (text_ptr);
dcl  text_ptr pointer;
dcl  text_lth fixed binary (21);

dcl  buffer_in_use character (buffer_used) unaligned based;


add_to_buffer_fixed:				/* ... from a fixed length string */
     entry (p_text);

	text_ptr = addr (p_text);
	text_lth = length (p_text);
	go to ADD_TO_BUFFER_COMMON;


add_to_buffer_varying:				/* ... from a varying string */
     entry (p_varying_text);

	text_ptr = addwordno (addr (p_varying_text), 1);
	text_lth = length (p_varying_text);


ADD_TO_BUFFER_COMMON:
	if (buffer_used + text_lth) > buffer_max_lth then
	     if buffer_ptr = stack_buffer_ptr then do;	/* switch to a temporary segment */
		if segment_buffer_ptr = null () then do;/* ... haven't gotten one already */
		     call get_temp_segment_ (MAIL_SYSTEM_, segment_buffer_ptr, code);
		     if code ^= 0 then go to ERROR_RETURN_FROM_PRINT_DELIVERY_RESULTS;
		     segment_buffer_max_lth = 4 * sys_info$max_seg_size;
		end;
		segment_buffer_ptr -> buffer_in_use = stack_buffer_ptr -> buffer_in_use;
		buffer_ptr = segment_buffer_ptr;
		buffer_max_lth = segment_buffer_max_lth;
	     end;
	     else do;				/* overflowed the temporary segment */
		code = error_table_$area_too_small;
		go to ERROR_RETURN_FROM_PRINT_DELIVERY_RESULTS;
	     end;

	begin;
dcl  new_part character (text_lth) unaligned defined (buffer) position (buffer_used + 1);
	     new_part = text;
	end;

	buffer_used = buffer_used + text_lth;

	return;

     end add_to_buffer;
%page;
/* Tests if an address list is empty */

is_empty_list:
     procedure (p_address_list_ptr) returns (bit (1) aligned);

dcl  p_address_list_ptr pointer parameter;

	if p_address_list_ptr = null () then		/* nothing there at all */
	     return ("1"b);

	else return (p_address_list_ptr -> address_list.n_addresses = 0);

     end is_empty_list;
%page;
%include mlsys_data;
%page;
%include mlsys_message;
%page;
%include mlsys_address_types;
%page;
%include mlsys_address_list;
%page;
%include mlsys_deliver_info;
%page;
%include mlsys_reply_options;
%page;
%include mlsys_search_options;
%page;
%include mlsys_format_options;
%page;
%include condition_info;
%page;
%include condition_info_header;

%include io_error_info;
%page;
%include std_descriptor_types;
%page;
%include sub_err_flags;
%page;
/* Definition of whitespace is given here as it generates several blank pages in the listing */

dcl  WHITESPACE character (5) static options (constant) initial ("	
 ");						/* HT NL VT FF SP */

     end mlsys_misc_utils_;
