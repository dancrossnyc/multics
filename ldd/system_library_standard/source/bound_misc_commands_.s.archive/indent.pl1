/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(69-06-01,VanVleck), approve(), audit(), install():
     created from a
     MAD (Michigan Algorithmic Decode) Stan Dutton's CTSS program.
  2) change(73-06-01,Morris), approve(), audit(), install():
     modified to know
     about IF statements.
  3) change(73-12-01,VanVleck), approve(), audit(), install():
     heavily
     modified to take advantage of EIS instruction set.
  4) change(74-08-01,Casey), approve(), audit(), install():
     modified to -
     check for missing quotes and other errors that are really caused by
     missing quotes; and - refuse to replace the original segment when such
     errors are detected; - rewrite argument processing to use less code and
     allow control arguments anywhere on the line.
  5) change(76-03-01,LJohnson), approve(), audit(), install():
     modified to fix
     bugs in indenting multiple line strings, to improve <NP> character
     handling, and to support .cds suffix.
  6) change(77-06-14,May), approve(), audit(), install():
     modified to add
     processing of source for the reduction_compiler, to generalize somewhat
     for other possible dialects, and to fix a bug indenting factored structure
     entries.
  7) change(85-08-02,GDixon), approve(85-09-27,MCR7261), audit(85-09-27,GWMay),
     install(85-12-16,MR12.0-1001):
     support format_pl1's unchangeable comment syntax, which is a comment
     beginning with /****^.  This is needed to prevent indent from messing up
     history comments.
                                                   END HISTORY COMMENTS */


indent: ind: proc;

/* The INDENT command indents PL1 programs to make them more readable.

   Each DO, BEGIN, or PROCEDURE statement causes an additional level of indentation
   until a corresponding END is encountered. (Multiple closure is not permitted.)
   An IF statement or ELSE statement which is continued over multiple lines will also
   indent its subsequent lines.

   Comments are lined up in a standard column. A comment will be placed in column 1 if
   it is the first thing on the line and if the preceding line was blank or another such comment.

   Declaration statements are indented in a standard form, so that factoring and
   structure nesting are exhibited.

   Multiple spaces or tabs are replaced by a single space, except for the content of strings
   and for non-leading spaces and tabs in comments.
   Spaces are inserted around the operators = -> ^= >= and <=, after commas,
   and before left parentheses and after right parentheses.
   Spaces are removed if found before a comma or right paren, or after a left paren.
   Tabs are used wherever possible to conserve space in the segment.

   Parentheses are counted, and must balance at every semicolon. A warning will be printed.
   Lines longer than 350 characters will be split with a warning message.
   Illegal characters or non-pl1 characters not contained in a string will be commented upon.

   Some uses of the identifiers begin, end, proc, procedure, do, if, then, and else
   as variable names may cause the command to become confused. This is bad programming anyway.
   The command knows when a new statement may begin and can complain about some obvious syntax errors.
   */

dcl  suffixes (3) char (4) init (".pl1", ".cds", ".rd"),	/* all the known dialects */
     suffix_lengths (3) fixed bin init (4, 4, 3),		/* and their lengths */
     suffix_len fixed bin;				/* one of the preceding */

dcl  rd_source_sw bit (1),				/* flag for source to the reduction_compiler */
     copy_this_comment_unchanged bit (1);		/* flag to copy current comment without change */

dcl (n1, n2) char (168) aligned,			/* input and output segment pathnames */
     dn char (168) aligned,				/* directory name */
     en char (32) aligned,				/* entry name */
     temp_en char (32) aligned,			/* entry name of temp seg. */
     ap ptr,					/* ptr to argument */
     al fixed bin,					/* lth of argument */
     an fixed bin,					/* current arg number */
     nargs fixed bin,				/* number of arguments */
     expecting fixed bin init (0),			/* ^=0 if expecting a numeric arg following a control arg */
     bchr char (al) based (ap) unaligned,		/* based char string */
    (linno, indent, ntab) fixed bin,			/* misc counters */
     ec fixed bin (35) init (0),			/* error code */
     offset fixed bin (24),				/* char offset in input */
    (string_offset, line_offset) fixed bin (24),		/* offsets where current string and line started */
     string_len fixed bin,				/* length of current string, for error checking */
    (p, p1) ptr,					/* pointers to input, output */
    (icb, ice, icol) fixed bin,			/* indices in line */
    (chars, temchars) char (400),			/* Working storage */
     char char (1),					/* temp */
     n fixed bin,					/* length of working line */
     lth fixed bin (24),				/* number of chars in input */
    (lth1, lth2) fixed bin,				/* length of args */
     end_count fixed bin,				/* number of END on this line */
     if_count fixed bin,				/* count of IF's encountered */
     old_if_count fixed bin,				/* previous value. */
    (scolsw,					/* TRUE if semicolon on line */
     dclfnd,					/* TRUE if DECLARE statement on line. */
     dclsw,					/* TRUE if in a declaration */
     condsw,					/* TRUE if now in if statement. */
     ifsw,					/* TRUE for if but not for else. */
     begin_ok,					/* TRUE if in an ON statement. */
     else_ok,					/* TRUE if else is now permitted. */
     strut,					/* TRUE if in structure */
     sixty,					/* TRUE if comment is to be pushed to col. 60 */
     bos,						/* TRUE if current char could be beginning of stmnt */
     blsw,					/* TRUE if preceding line blank */
     comment,					/* TRUE if currently in comment. */
     newpage,					/* TRUE if line contains newpage character */
     string,					/* TRUE if currently in string */
     pstring) bit (1) aligned,			/* TRUE if previous line ended in string */
     bfsw bit (1) aligned init ("0"b),			/* Brief mode switch */
     string_error bit (1) aligned init ("0"b),
    (false init ("0"b), true init ("1"b)) int static options (constant) bit (1) aligned, /* named bit values */
    (in, dent, dclind) fixed bin,			/* indentation */
     LMARGIN fixed bin init (11),			/* left margin */
     IN fixed bin init (5),				/* subsequent indent */
     CMC fixed bin init (61),				/* comment column */
     TABCOL fixed bin init (60),			/* nearest mult of 10 < CMC */
     NTAB fixed bin init (6),				/* number of tabs to get to TABCOL */
     nout fixed bin (24),				/* number of chars in output */
     colpos fixed bin,				/* Column pointer in output line. (last filled col) */
     parct fixed bin init (0),			/* paren count. must be 0 at semicolon */
     pdlx fixed bin,
     ifdent fixed bin,
     suffix char (4),
     suffix_assumed bit (1) init ("0"b),		/* set if indent is assuming the suffix */
    (i, j, k, kk, m) fixed bin (24);

dcl 1 pdl (1024) aligned,				/* Pushdown list. */
    2 nif fixed bin (33) unal,			/* IF count. */
    2 swc bit (1) unal,				/* Conditional switch. IF and ELSE */
    2 sw bit (1) unal;				/* IF switch. */

dcl  NP_NL_SP char (3) init static init ("
 ");
dcl  SP char (1) int static init (" ");			/* Single space. */
dcl  SP_TAB char (2) int static init ("	 ");		/* Tab and space, for verify etc. */
dcl  SP_LP_NOT char (3) int static init (" (^");
dcl  NOT_LES_GRT char (3) int static init ("^<>");
dcl  SP_TAB_COM_SEMI char (4) int static init (" ,;	");
dcl  SP_TAB_SEMI_NL char (4) int static init ("	 ;
");
dcl  SP_TAB_SEMI_LP_NL char (5) int static init (" ;	(
");
dcl  NL char (1) int static init ("
");
dcl  TABS char (40) int static init ((40)"	");

dcl  bcs char (lth) based (p) aligned;
dcl  bcso char (1048576) based (p1) aligned;

dcl  cv_dec_check_ entry (char (*) aligned, fixed bin (35)) returns (fixed bin),
     ioa_ entry options (variable),
     com_err_ entry options (variable),
     cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35)),
     cu_$arg_count entry (fixed bin),
     expand_path_ entry (ptr, fixed bin, ptr, ptr, fixed bin (35)),
     hcs_$delentry_seg entry (ptr, fixed bin (35)),
     hcs_$truncate_seg entry (ptr, fixed bin, fixed bin (35)),
     hcs_$terminate_noname entry (ptr, fixed bin (35)),
     hcs_$make_seg entry (char (*) aligned, char (*) aligned, char (*) aligned, fixed bin (5),
     ptr, fixed bin (35)),
     hcs_$initiate_count entry (char (*) aligned, char (*) aligned, char (*) aligned, fixed bin (24),
     fixed bin (2), ptr, fixed bin (35)),
     get_pdir_ entry () returns (char (168) aligned),
     hcs_$set_bc_seg entry (ptr, fixed bin (24), fixed bin (35));

dcl (output_path_given, error_occurred) bit (1) aligned init ("0"b);



dcl  moveseg char (nout) based aligned;			/* For copy of whole segment. */

dcl  err_msg char (100) varying;

dcl  error_table_$bad_arg fixed bin (35) ext;		/* Illegal command argument */
dcl  error_table_$badopt fixed bin (35) ext;		/* Specified control arg not implemented by this command */
dcl  error_table_$noarg fixed bin (35) ext;		/* Expected argument missing */
dcl  error_table_$noentry fixed bin (35) ext;

dcl (addr, divide, fixed, length, mod, min, null, substr, index, reverse,
     search, verify, unspec) builtin;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


	call cu_$arg_count (nargs);			/* get number of args */
	if nargs = 0 then do;			/* gripe if no args */
	     call com_err_ (0, "indent", "Usage: indent n1 -n2- -lm nn -in mm -cm kk -brief");
	     return;
	end;

	lth1, lth2 = 0;				/* so we can tell if we have the pathnames yet */
arg_loop:	do an = 1 to nargs;
	     call cu_$arg_ptr (an, ap, al, ec);		/* pick off next arg */

	     if ec ^= 0 then do;
print_bad_arg:	err_msg = "^a";			/* control string to just print argument */
arg_error:	call com_err_ (ec, "indent", err_msg, bchr);
		return;
	     end;

	     if expecting ^= 0 then do;

		en = bchr;			/* cv_dec_check_ needs aligned arg */
		i = cv_dec_check_ (en, ec);

		if expecting = 1 then do;		/* expecting left margin */
		     expecting = 0;
		     if ec ^= 0 then do;
blm:			err_msg = "illegal left margin arg ^a";
cv_dec_error:		ec = 0;			/* cv_dec_check_ does not return an error_table_ code */
			goto arg_error;		/* go call com_err_ */
		     end;
		     if i < 1 then goto blm;
		     if i > 100 then goto blm;
		     LMARGIN = i;
		end;

		else if expecting = 2 then do;	/* expecting indent spaces */
		     expecting = 0;
		     if ec ^= 0 then do;
bint:			err_msg = "illegal indent arg ^a";
			goto cv_dec_error;
		     end;
		     if i < 0 then goto bint;
		     if i > 100 then goto bint;
		     IN = i;
		end;

		else do;				/* must be expecting comment column */
		     expecting = 0;
		     if ec ^= 0 then do;
bcmc:			err_msg = "illegal comment column arg ^a";
			goto cv_dec_error;
		     end;
		     if i < 1 then goto bcmc;
		     if i > 350 then goto bcmc;
		     CMC = i;
		     TABCOL = 10 * divide (CMC-1, 10, 17, 0);
		     NTAB = divide (TABCOL, 10, 17, 0);
		end;

	     end;					/* end of expecting argument do group */

	     else do;				/* not-expected-argument */

		if substr (bchr, 1, 1) = "-" then do;	/* Control argument? */
		     if bchr = "-brief" then bfsw = true;
		     else if bchr = "-bf" then bfsw = true;
		     else if bchr = "-lmargin" then expecting = 1;
		     else if bchr = "-lm" then expecting = 1;
		     else if bchr = "-indent" then expecting = 2;
		     else if bchr = "-ind" then expecting = 2;
		     else if bchr = "-in" then expecting = 2;
		     else if bchr = "-comment" then expecting = 3;
		     else if bchr = "-cm" then expecting = 3;
		     else do;
			ec = error_table_$badopt;
			goto print_bad_arg;
		     end;
		end;

		else do;				/* Not control arg, must be filename */
		     if lth1 = 0 then do;		/* if we don't have input filename then this is it */
			n1 = bchr;		/* Pick up arg 1, input name */
			lth1 = al;		/* Remember length for expand path */
		     end;
		     else if lth2 = 0 then do;	/* if we don't have output filename, this is it */
			n2 = bchr;		/* User gave second name. Set it up. */
			lth2 = al;		/* Set length of second arg. */
			output_path_given = "1"b;
		     end;
		     else do;
			ec = error_table_$bad_arg;	/* "Illegal command argument" */
			goto print_bad_arg;		/* go call com_err_ to print the bad arg */
		     end;
		end;
	     end;					/* end of not-expected-argument do group */
	end arg_loop;				/* end of argument processing do group */

	if lth1 = 0 then do;			/* if input filename not given */
	     err_msg = "pathname of input file";
noarg_err:     ec = error_table_$noarg;
	     goto arg_error;
	end;

	if expecting ^= 0 then do;
	     err_msg = "after ^a";
	     goto noarg_err;
	end;

	if lth2 = 0 then do;			/* if output path not given, use input path */
	     n2 = n1;
	     lth2 = lth1;
	end;


/* END OF ARGUMENT PROCESSING */

/* Initialization */

	rd_source_sw, copy_this_comment_unchanged = false; /* flags for source to reduction_compiler */
						/* and for unchangable comments. */
	in, ifdent, if_count, old_if_count = 0;
	strut, dclsw, condsw, ifsw, begin_ok, else_ok, comment, sixty, string, pstring = false;
	bos, blsw = true;				/* Pretend line zero was empty. */
	pdlx = 1;					/* Set pushdown list to empty. */
	linno = 1;				/* This is line 1. */
	offset, nout = 1;				/* read and write pointers */

	i = index (reverse (substr (n1, 1, lth1)), ".");	/* get last component */
	if i = 0 | i > 4 then go to in_suffix;		/* wrong size, don't bother */
	suffix = substr (n1, lth1 - i + 1, i);		/* includes "." */
	do j = 1 to 3;				/* .pl1, .cds, .rd */
	     if suffix = suffixes (j)
	     then do;
		suffix_len = suffix_lengths (j);	/* for later suffix processing */
		go to good_suffix;
	     end;
	end;

/* Didn't match list of good suffices */

in_suffix: suffix = ".pl1";				/* a good guess */
	suffix_len = 4;
	substr (n1, lth1+1, suffix_len) = suffix;	/* add to name */
	lth1 = lth1+suffix_len;			/* adjust length */
	suffix_assumed = "1"b;			/* remember, this was only a guess */

good_suffix:
	if suffix = ".rd" then rd_source_sw = "1"b;	/* remember to check for rd parse in comments */

	call expand_path_ (addr (n1), lth1, addr (dn), addr (en), ec);
	if ec ^= 0 then go to error;
	call hcs_$initiate_count (dn, en, "", lth, 0, p, ec);
	if p = null then do;			/* didn't find input seg */
	     if ^suffix_assumed then go to error;	/* user gave suffix. Nothing more to try */
	     if ec ^= error_table_$noentry then go to error; /* foo.pl1 not found is the only reason to continue */
	     i = 34 - suffix_len - verify (reverse (en), " "); /* find suffix in entry name */
	     suffix = ".cds";			/* try new suffix */
	     suffix_len = 4;
	     substr (en, i, suffix_len) = substr (suffix, 1, suffix_len);
	     call hcs_$initiate_count (dn, en, "", lth, 0, p, ec);
	     if p = null then do;			/* trouble with foo.cds too */
		if ec = error_table_$noentry then
		     go to error;			/* if foo.cds not found, print error about foo.pl1 */
		substr (n1, lth1 - (suffix_len-1), suffix_len) = substr (suffix, 1, suffix_len);
						/* for other errors, print message aboout foo.cds */
		go to error;
	     end;
	end;
	if lth2 < 4 then go to out_suffix;		/* out name shorter than x.rd, need suffix */
	else if substr (n2, lth2 - (suffix_len-1), suffix_len) ^= substr (suffix, 1, suffix_len)
	then do;					/* output suffix must match input */
out_suffix:    substr (n2, lth2+1, suffix_len) = substr (suffix, 1, suffix_len);
	     lth2 = lth2+suffix_len;
	end;
	lth = divide (lth+8, 9, 17, 0);		/* compute bit count of input seg */

	temp_en = en;				/* Generate name of temp file. */
	i = 34 -suffix_len - verify (reverse (temp_en), " "); /* Locate end. */
	substr (temp_en, i, 4) = ".ind";
	call hcs_$make_seg ((get_pdir_ ()), temp_en, "", 1010b, p1, ec);
	if p1 = null then go to error;
	call expand_path_ (addr (n2), lth2, addr (dn), addr (en), ec);
	if ec ^= 0 then go to error;

/* This is the loop for each line in the input segment. Starting at "offset" a line of "n" chars
   is moved to the temporary buffer "chars". Trailing tabs and blanks are trimmed. */

loop:	pstring = string;				/* remember if previous line ended inside quotes */
	if offset > lth then go to eof;
	i = index (substr (bcs, offset), NL);		/* Find length of line. */
	if i = 0 then i = lth - offset + 1;		/* .. in case did not end in NL */
	else if i = 1 then do;			/* Check for empty line. */
	     substr (bcso, nout, 1) = NL;		/* insert in output */
	     nout = nout + 1;
	     linno = linno + 1;
	     offset = offset + 1;
	     blsw = true;
	     go to loop;
	end;
	k = i - 1;
	if k > 385 then do;				/* Line too big? */
	     k, i = 385;				/* Take first 385 chars. */
	     call ioa_ ("indent: line ^d of ""^a"" was too long & has been split.", linno, en);
	     error_occurred = "1"b;
	end;
	chars = substr (bcs, offset, k);		/* Pick up line. */
	substr (chars, k+1, 1) = NL;			/* Put in NL */
	line_offset = offset;			/* remember where line started */
	offset = offset + i;			/* Increase index. */
	n = k + 1;				/* Set up length of line. */
	if n = 1 then go to lemp;			/* Empty line? */
	if ^pstring then				/* if not in string */
	     if substr (chars, 1, 1) = "%" then do;	/* Is this an "include" line? */
lemp:		blsw = true;			/* Yes, set switch. */
		go to cpy;			/* And just copy line. */
	     end;

	icb, ice, icol, dent, end_count = 0;		/* Set up for loop. */
	scolsw, dclfnd, newpage = false;

/* The following section examines each character in the current line in "chars".
   In this section, "i" is the character index which may be from 1 to "n". */

	if pstring then do;				/* If we are now in a string, */
	     kk = index (substr (chars, 1, n-1), """");	/* .. See if it ends on this line. */
	     if kk = 0 then go to cpy;		/* Nope. Can't touch line at all. */
	     else i = kk;				/* Yes. Skip string content. */
	end;
	else i = 1;				/* Examine each character in line. */
l2s:	char = substr (chars, i, 1);			/* Pick up a character. */
	if string then do;				/* Now in a string ? */
	     if char = """" then do;			/* Watch for end */
		string = false;			/* not any more */
						/* While this ignoring of possible double quotes within a
						   string works ok for indenting, it throws off string
						   length checking. However, since this checking is to
						   help locate missing quotes, it is not really necessary
						   to check for double quotes here. */
		string_len = line_offset+i-string_offset-1; /* compute length, excluding the quotes */
		if string_len > 254 then		/* if string is too long, report line number
						   to aid user in finding missing quote */
		     if ^bfsw then			/* but only if user wants to be warned */
			if ^string_error then do;	/* report only the first one - if there is a missing quote,
						   there are probably a lot more long strings */
			     call ioa_
				("indent: possible syntax error in line ^d of ^a: string length (^d) > pl1 max.",
				linno, en, string_len);
			     string_error = "1"b;	/* remember not to report any more of these */
			     error_occurred = "1"b;
			end;
	     end;
	     go to l2e;				/* ... leaving all other chars */
	end;
	if comment then do;				/* are we now in a comment? */
	     if substr (chars, i, 2) = "*/" then do;	/* Comment ends? */
		comment = false;			/* Turn off switch. */
		if copy_this_comment_unchanged then	/* Are we in rd reductions or in unchangable	*/
						/* comment?  Then we are done with the comment.	*/
		     copy_this_comment_unchanged = false;
		else do;				/* Not in unchangable comment?		*/
		     if i > 1 then if index (SP_TAB, substr (chars, i-1, 1)) = 0
						/* chars on line prior to comment end delimiter?	*/
			then call inb (i);		/* insert blank prior to comment end delimiter	*/
		     if i < n-2 then		/* Chars on line after comment end delimiter?	*/
			if index (SP_TAB_COM_SEMI, substr (chars, i+2, 1)) = 0 then
			     call inb (i+2);	/* Nice blank after comment */
		end;
		ice = i;				/* save index of end of comment. */
		i = i + 1;			/* Don't scan slash again. */
		go to l2e;			/* Comment leaves state unchanged. */
	     end;
	     if i = 1 then do;			/* Continue comment. Trim leading blanks and tabs. */
		k = verify (substr (chars, 1, n-1), SP_TAB) - 1;
		if k = -1 then do;			/* if line of just white space inside comment */
		     chars = "";			/* replace it wich just a newline */
		     substr (chars, 1, 1) = NL;
		     n = 1;
		     go to cpy;
		end;
		if ^copy_this_comment_unchanged	/* don't disturb rd parse controls */
		then do;
		     substr (temchars, 1, n-k) = substr (chars, k+1, n-k);
		     substr (chars, 1, 3) = "";	/* Stick in three blanks. */
		     substr (chars, 4, n-k) = substr (temchars, 1, n-k);
		     i = 4;
		     n = n - k + 3;
		end;
	     end;
	     kk = index (substr (chars, i, n-i), "*/");	/* Character inside comment. Skip out to end. */
	     if kk = 0 then i = n-1;
	     else i = i + kk - 2;			/* Set so we scan the comment end next. */
	     go to l2e;
	end;
	k = fixed (unspec (char), 9);			/* See if char is ASCII */
	if k < 0 then go to ilchr;
	if k > 126 then go to ilchr;
	go to case (k);				/* Dispatch on character. */

/* Handlers for each character. */

/* Punctuation. */

case (009):					/* HT, octal 011 */
	substr (chars, i, 1) = SP;
case (032):					/* blank, octal 040 */
	if i = 1 then go to squidge;
	if substr (chars, i-1, 1) = SP then do;
squidge:	     k = verify (substr (chars, i, n-i), SP_TAB) - 1;
	     if k > 0 then call outb (i, k);		/* Remove multiple blanks and tabs. */
	end;
	go to l2e;				/* Ignore blank */
case (034):					/* quote, octal 042 */
	string = true;				/* now in string */
	string_offset = line_offset+i;		/* remember where it started, for length checking */
	kk = index (substr (chars, i+1, n-i), """");	/* Does string end on this line? */
	if kk > 0 then i = i + kk - 1;		/* Yes. Skip string contents. */
	else i = n-1;				/* No. Skip rest of line. */
	go to cbs;
case (040):					/* "(", octal 050 */
	parct = parct + 1;				/* Increase count. */
	if i > 1 then if index (SP_LP_NOT, substr (chars, i-1, 1)) = 0 then call inb (i);
	if i < n-1 then if index (SP_TAB, substr (chars, i+1, 1)) ^= 0 then call outb (i+1, 1);
	go to nxchr;				/* Condition prefix begins with paren. */
case (041):					/* ")", octal 051 */
	if i > 1 then if substr (chars, i-1, 1) = SP then call outb (i-1, 1);
	parct = parct - 1;				/* decrease parenthesis count. */
	if parct < 0 then do;			/* Check for more closes than opens. */
	     call ioa_ ("indent: line ^d of ""^a"" has an extra "")"".", linno, en);
	     error_occurred = "1"b;
	     parct = 0;
	end;
	go to cbs;
case (044):					/* ",", octal 054 */
	if i > 1 then if substr (chars, i-1, 1) = SP then call outb (i-1, 1);
	if i < n-1 then if substr (chars, i+1, 1) ^= SP then call inb (i+1);
	go to cbs;
case (045):					/* "-", octal 055 */
	if substr (chars, i+1, 1) = ">" then do;	/* Is this a pointer digraph? */
	     if i > 1 then if substr (chars, i-1, 1) ^= SP then call inb (i);
	     if i < n-2 then if substr (chars, i+2, 1) ^= SP then call inb (i+2);
	end;
	go to cbs;
case (047):					/* "/", octal 057 */
	if substr (chars, i+1, 1) = "*" then do;	/* Comment begins? */
	     comment = true;			/* Now in comment. */
	     if i - length ("/") + length ("/****^") + length (NL) <= n
	     then if substr (chars, i, length ("/****^")) = "/****^" then
		     copy_this_comment_unchanged = true; /* check for comments which cannot be changed. */
	     if ^copy_this_comment_unchanged then do;
		if i > 1 then if substr (chars, i-1, 1) ^= SP then call inb (i);
		if i < n - length ("/") - length (NL)
		then if index (SP_TAB, substr (chars, i+2, 1)) = 0 /* need a blank? */
		     then if ^rd_source_sw		/* check first for rd parse control */
			then call inb (i+2);
			else if substr (chars, i+2, 2) = "++"
						/* beginning of rd parse specification? */
			then copy_this_comment_unchanged = true;
						/* yes. remember, and don't insert blank */
			else call inb (i+2);	/* just a normal comment */
	     end;
	     icb = i;				/* Remember where comment began. */
	     kk = index (substr (chars, i+2, n-i-2), "*/"); /* Search for end of comment. */
	     if kk = 0 then i = n-1;			/* Not scanning content of comment. */
	     else i = i + kk;			/* ... */
	     go to l2e;				/* Leave "bos" as it was when comment began. */
	end;
	go to cbs;				/* Statement don't begin with slash */
case (058):					/* ":", octal 072 */
	if parct > 0 then go to nxchr;		/* Label can't be in parentheses. */
	if bos then go to cbs;			/* Null label ? */
	bos = true;				/* This is label. keyword ok */
	icol = i + 1;				/* Save index. */
	if i < n-1 then if index (SP_TAB, substr (chars, i+1, 1)) = 0 then call inb (i+1);
	go to l2e;
case (059):					/* ";", octal 073 */
	scolsw, bos = true;				/* Semicolon. End of statement. */
	begin_ok = false;
	if condsw then do;				/* Does this end an IF? */
	     old_if_count = if_count;			/* Save proper indent level for ELSE */
	     if pdlx = 1 then if_count = 0;		/* Reset if_count */
	     else if_count = pdl (pdlx-1).nif;		/* Set back to base for this level. */
	     condsw = false;			/* Not now in conditional */
	     else_ok = true;
	end;
	else old_if_count = 0;			/* End of some other statement. */
	ifsw = false;				/* Not in IF now. */
	if parct > 0 then do;			/* Parenthesis count should be zero. */
	     call ioa_ ("indent: ^d extra ""(""s at line ^d of ""^a"".",
		parct, linno, en);			/* Complain. */
	     error_occurred = "1"b;
	     parct = 0;				/* Start over on count. */
	end;
	go to l2e;
case (061):					/* "=", octal 075 */
	if i < n-1 then if substr (chars, i+1, 1) ^= SP then call inb (i+1);
	m = 1;
	if i > 1 then if index (NOT_LES_GRT, substr (chars, i-1, 1)) ^= 0 then m = 2;
	if i > m then if substr (chars, i-m, 1) ^= SP then call inb (i-m+1);
	go to cbs;

/* This section checks for reserved words by looking at the first letter. */

case (098):					/* letter "b", octal 142 */
	if ^bos then if ^begin_ok then go to nxchr;	/* Must be at begin of statement or in ON */
	if parct > 0 then go to nxchr;		/* ignore begins in parens */
	if i <= n-5 then if substr (chars, i, 5) = "begin" then
		if search (substr (chars, i, n-i+1), SP_TAB_SEMI_NL) = 6 then do;
		     i = i + 4;			/* Skip over rest of word. */
in_found:		     if ifsw then if_count = if_count - 1; /* Don't do extra indent. */
		     pdl (pdlx).sw = ifsw;		/* Push down current if switch. */
		     pdl (pdlx).swc = condsw;		/* .. and conditional switch. */
		     pdl (pdlx).nif = if_count;	/* .. and if indentation. */
		     pdlx = pdlx + 1;		/* .. */
		     if pdlx = 1024 then do;		/* If nesting depth too great, die. */
			call com_err_ (0, "indent", "FATAL ERROR. Line ^d of ""^a"" nesting depth > 1024",
			     linno, en);
			return;
		     end;
		     condsw = false;		/* Now not in IF */
		     ifsw = false;
		     dent = dent + 1;		/* Increase indentation level. */
		end;
	go to nxchr;
case (100):					/* letter "d", octal 144 */
	if parct > 0 then go to nxchr;		/* reserved word not in parens */
	if ^bos then go to nxchr;			/* Must be at beginning of statement. */
	kk = search (substr (chars, i, n-i+1), SP_TAB_SEMI_NL);
	if kk = 3 then if substr (chars, i, 2) = "do" then do;
		i = i + 1;			/* Found DO statement. */
		go to in_found;
	     end;
	if condsw then go to nxchr;			/* Declaration cannot be inside an IF */
	if i = 1 then do;				/* declare stm must start in col 1 ... */
	     if kk = 4 then if substr (chars, i, 3) = "dcl" then do;
		     dclfnd = true;			/* Found DCL statement. */
		     i = i + 2;
		     dclind = 4;
		     go to nxchr;
		end;
	     if kk = 8 then if substr (chars, i, 7) = "declare" then do;
		     dclfnd = true;			/* Found DECLARE statement. */
		     i = i + 6;
		     dclind = 8;
		     go to nxchr;
		end;
	end;
	go to nxchr;
case (101):					/* letter "e", octal 145 */
	if parct > 0 then go to nxchr;		/* keyword not appear in parens. */
	if ^bos then go to nxchr;			/* Must be in beginning-of-statment state. */
	kk = search (substr (chars, i, n-i+1), SP_TAB_SEMI_NL);
	if else_ok then if kk = 5 then if substr (chars, i, 4) = "else" then do;
		     if_count = old_if_count - 1;	/* Restore old IF indentation. */
		     ifdent = old_if_count - 1;	/* Outdent the ELSE to the corresponding IF */
		     else_ok = false;		/* ELSE may not follow ELSE. */
		     if if_count > 0 then condsw = true; /* But may follow after semi. */
		     bos = true;			/* Statement may follow ELSE. */
		     i = i + 3;
		     go to l2e;
		end;
	if condsw then go to nxchr;			/* Cannot say "then end" */
	if kk = 4 then if substr (chars, i, 3) = "end" then do;
		end_count = end_count + 1;		/* Found END statement. */
		if pdlx > 1 then do;		/* Unstack IF state. */
		     pdlx = pdlx - 1;		/* .. */
		     ifsw = pdl (pdlx).sw;		/* .. */
		     condsw = pdl (pdlx).swc;		/* ... */
		     if_count = pdl (pdlx).nif;	/* .. */
		     if ifsw then if_count = if_count + 1;
		end;
		if (in - end_count + dent) < 0 then do; /* Too many END's? */
		     call ioa_ ("indent: line ^d of ""^a"" has an extra ""end"".", linno, en);
		     dent, in, end_count = 0;		/* Start over on indents */
		     error_occurred = "1"b;
		end;
		i = i + 2;
	     end;
	go to nxchr;
case (105):					/* letter "i", octal 151 */
	if parct > 0 then go to nxchr;
	if ^bos then go to nxchr;
	if i <= n-2 then if substr (chars, i, 2) = "if" then
		if search (substr (chars, i, n-i+1), SP_TAB_SEMI_LP_NL) = 3 then do;
		     condsw = true;			/* Set IF encountered flag. */
		     ifsw = true;
		     i = i + 1;
		end;
	go to nxchr;
case (116):					/* letter "t", octal 164 */
	if parct > 0 then go to nxchr;		/* Look for THEN keyword. */
	if bos then go to nxchr;			/* THEN cannot begin a statement. */
	if ^ifsw then go to nxchr;			/* and some IF must have come up. */
	if i ^= 1 then if substr (chars, i-1, 1) ^= SP then go to nxchr;
	if i <= n-4 then if substr (chars, i, 4) = "then" then
		if search (substr (chars, i, n-i+1), SP_TAB_SEMI_NL) = 5 then do;
		     bos = true;			/* Found THEN. Statement may follow. */
		     i = i + 3;
		     if_count = if_count + 1;
		     go to l2e;
		end;
	go to nxchr;
case (111):					/* letter "o", octal 157 */
	if ^bos then go to nxchr;			/* Check for ON statement. */
	if parct > 0 then go to nxchr;
	if i <= n-2 then if substr (chars, i, 2) = "on" then
		if search (substr (chars, i, n-i+1), SP_TAB_SEMI_NL) = 3 then do;
		     begin_ok = true;		/* ON statement may contain BEGIN */
		     i = i + 1;
		end;
	go to nxchr;
case (112):					/* letter "p", octal 160 */
	if parct > 0 then go to nxchr;
	if ^bos then go to nxchr;
	if condsw then go to nxchr;			/* Cannot say "then proc" */
	k = 3;
	kk = search (substr (chars, i, n-i+1), SP_TAB_SEMI_LP_NL);
	if kk = 5 then if substr (chars, i, 4) = "proc" then go to procfnd;
	k = 8;
	if kk = 10 then if substr (chars, i, 9) = "procedure" then do;
procfnd:		i = i + k;			/* Skip scan of keyword. */
		go to in_found;			/* Increase indentation level */
	     end;
	go to nxchr;

/* Illegal characters. Squawk and continue. */

case (000):					/* NUL, octal 000 */
case (001):					/* undefined, octal 001 */
case (002):					/* undefined, octal 002 */
case (003):					/* undefined, octal 003 */
case (004):					/* undefined, octal 004 */
case (005):					/* undefined, octal 005 */
case (006):					/* undefined, octal 006 */
case (007):					/* BEL, octal 007 */
case (008):					/* BS, octal 010 */
case (013):					/* CR, octal 015 */
case (014):					/* RRS, octal 016 */
case (015):					/* BRS, octal 017 */
case (016):					/* undefined, octal 020 */
case (017):					/* undefined, octal 021 */
case (018):					/* undefined, octal 022 */
case (019):					/* undefined, octal 023 */
case (020):					/* undefined, octal 024 */
case (021):					/* undefined, octal 025 */
case (022):					/* undefined, octal 026 */
case (023):					/* undefined, octal 027 */
case (024):					/* undefined, octal 030 */
case (025):					/* undefined, octal 031 */
case (026):					/* undefined, octal 032 */
case (027):					/* undefined, octal 033 */
case (028):					/* undefined, octal 034 */
case (029):					/* undefined, octal 035 */
case (030):					/* undefined, octal 036 */
case (031):					/* EGM, octal 037 */
ilchr:	call ioa_ ("indent: warning: illegal character (octal ^3.3b) in line ^d of ""^a""",
	     unspec (substr (chars, i, 1)), linno, en);
	error_occurred = "1"b;
	go to l2e;

case (033):					/* "!", octal 041 */
case (035):					/* sharp, octal 043 */
case (039):					/* "'", octal 047 */
case (063):					/* "?", octal 077 */
case (064):					/* at-sign, octal 100 */
case (091):					/* "[", octal 133 */
case (092):					/* escape (backslash), octal 134 */
case (093):					/* "]", octal 135 */
case (096):					/* "`", octal 140 */
case (123):					/* "{", octal 173 */
case (125):					/* "}", octal 175 */
case (126):					/* tilde, octal 176 */
	if ^bfsw then do;				/* Unless brief mode, gripe */
	     call ioa_ ("indent: warning: non-pl1 char ""^a"" outside string in line ^d of ""^a""",
		substr (chars, i, 1), linno, en);
	     error_occurred = "1"b;
	end;
	go to l2e;

/* Chars which are legal but cannot begin a statement. */

case (036):					/* "$", octal 044 */
case (038):					/* "&", octal 046 */
case (042):					/* "*", octal 052 */
case (043):					/* "+", octal 053 */
case (046):					/* ".", octal 056 */
case (048):					/* digit "0", octal 060 */
case (049):					/* digit "1", octal 061 */
case (050):					/* digit "2", octal 062 */
case (051):					/* digit "3", octal 063 */
case (052):					/* digit "4", octal 064 */
case (053):					/* digit "5", octal 065 */
case (054):					/* digit "6", octal 066 */
case (055):					/* digit "7", octal 067 */
case (056):					/* digit "8", octal 070 */
case (057):					/* digit "9", octal 071 */
case (060):					/* "<", octal 074 */
case (062):					/* ">", octal 076 */
case (094):					/* circumflex, octal 136 */
case (095):					/* underscore, octal 137 */
case (124):					/* "|", octal 174 */
cbs:	if bos then if ^bfsw then do;
		call ioa_ ("indent: possible syntax error in line ^d of ^a detected at char ""^a""",
		     linno, en, substr (chars, i, 1));
		error_occurred = "1"b;
	     end;

/* Chars which are legal beginnings of statement. */

case (037):					/* "%", octal 045 */
case (065):					/* letter "A", octal 101 */
case (066):					/* letter "B", octal 102 */
case (067):					/* letter "C", octal 103 */
case (068):					/* letter "D", octal 104 */
case (069):					/* letter "E", octal 105 */
case (070):					/* letter "F", octal 106 */
case (071):					/* letter "G", octal 107 */
case (072):					/* letter "H", octal 110 */
case (073):					/* letter "I", octal 111 */
case (074):					/* letter "J", octal 112 */
case (075):					/* letter "K", octal 113 */
case (076):					/* letter "L", octal 114 */
case (077):					/* letter "M", octal 115 */
case (078):					/* letter "N", octal 116 */
case (079):					/* letter "O", octal 117 */
case (080):					/* letter "P", octal 120 */
case (081):					/* letter "Q", octal 121 */
case (082):					/* letter "R", octal 122 */
case (083):					/* letter "S", octal 123 */
case (084):					/* letter "T", octal 124 */
case (085):					/* letter "U", octal 125 */
case (086):					/* letter "V", octal 126 */
case (087):					/* letter "W", octal 127 */
case (088):					/* letter "X", octal 130 */
case (089):					/* letter "Y", octal 131 */
case (090):					/* letter "Z", octal 132 */
case (097):					/* letter "a", octal 141 */
case (099):					/* letter "c", octal 143 */
case (102):					/* letter "f", octal 146 */
case (103):					/* letter "g", octal 147 */
case (104):					/* letter "h", octal 150 */
case (106):					/* letter "j", octal 152 */
case (107):					/* letter "k", octal 153 */
case (108):					/* letter "l", octal 154 */
case (109):					/* letter "m", octal 155 */
case (110):					/* letter "n", octal 156 */
case (113):					/* letter "q", octal 161 */
case (114):					/* letter "r", octal 162 */
case (115):					/* letter "s", octal 163 */
case (117):					/* letter "u", octal 165 */
case (118):					/* letter "v", octal 166 */
case (119):					/* letter "w", octal 167 */
case (120):					/* letter "x", octal 170 */
case (121):					/* letter "y", octal 171 */
case (122):					/* letter "z", octal 172 */
nxchr:	bos = false;				/* No longer at beginning of statement. */
	else_ok = false;				/* ELSE no longer legal. */
	go to l2e;

/* Chars which do not preclude beginning of statement. */

case (012):					/* NP, octal 014 */
	newpage = "1"b;				/* remember line contained NP */
case (010):					/* NL, octal 012 */
case (011):					/* VT, octal 013 */
l2e:	i = i + 1;				/* Increase index in working array. */
	if i < n then go to l2s;			/* If any chars left, go thru again. */

/* come here when all characters in line examined */

	i = 1;					/* "i" will be the index in the "chars" buffer. */
	if newpage then do;				/* special test if newpage encountered */
	     if verify (substr (chars, 1, n), NP_NL_SP) = 0 then do; /* if line is all spaces, newpages, and newlines */
		n = 2;				/* make new short line */
		chars = substr (NP_NL_SP, 1, 2);	/* of newpage and newline */
		blsw = true;			/* this is a blank line */
		go to cpy;
	     end;
	end;
	if icb = 1 then do;				/* Does line start with comment? */
	     if blsw then do;			/* Yes. Previous line empty? */
		sixty = false;			/* Yes, start in column 1. */
		go to cpy;			/* Just copy line. */
	     end;
push:	     sixty = true;				/* Comment goes in column 60. */
	     ntab = NTAB;
	     i = 1;
	     go to nimcom;
	end;
	if icb = 0 then if (comment | ice > 0) then do;	/* Continuation of comment? */
		if sixty then go to push;		/* Do we indent it? */
cpy:		substr (bcso, nout, n) = substr (chars, 1, n); /* Copy whole line. */
		nout = nout + n;
		go to finish_line;
	     end;

/* This section computes the left margin for each line. */

	blsw = false;				/* Not empty line. */
	if pstring then do;
	     indent = 0;				/* don't indent inside quoted string */
	     icol = 0;
	end;
	else if dclfnd then do;			/* Does line begin with DCL? */
	     dclfnd = false;			/* Yes. */
	     dclsw = true;				/* We are in a declaration now. */
	     if index ("0123456789", substr (chars, dclind+1, 1)) ^= 0 then strut = true; else strut = false;
	     icol = dclind;				/* Copy first dclind chars without indent. */
	     if strut then indent = dclind+1;		/* Indent dclind+1 in structure */
	     else if substr (chars, dclind+1, 1) = "(" then indent = dclind+1;
						/* ... or in factored dcl, */
	     else indent = dclind+2;			/* ... otherwise dclind+2. */
	end;
	else if dclsw then do;			/* Are we in old declaration? */
	     icol = 0;				/* Yes. */
	     kk = index ("0123456789", substr (chars, 1, 1)) - 1;
	     if strut & kk >= 0 then do;		/* If structure, use level number. */
		k = kk;				/* Convert to number. */
		kk = index ("0123456789", substr (chars, 2, 1)) - 1;
		if kk >= 0 then k = k*10 + kk;
		indent = dclind + k + k - 3;		/* calculate proper indentation */
	     end;					/* typically, this yields
						   .	dcl 1 s,
						   .	    2 l1,
						   .	    2 l2,
						   .	      3 l3; etc.	 */

	     else if substr (chars, 1, 1) = "("
	     then do;
		if strut
		then do;				/* we have factored level declarations */
		     k = index ("0123456789", substr (chars, 2, 1)) - 1;
		     if k > 0			/* better be */
		     then do;
			kk = index ("0123456789", substr (chars, 3, 1)) - 1; /* look for level > 9 */
			if kk > 0 then k = 10 * k + kk;
			indent = dclind + k + k - 4;	/* subtract 1 more to allow for paren */
		     end;

/* should report the following, but can't tell the difference between missing level number and just initialize...
   else call ioa_ ("indent: No level number follows ""("" in structure. Line ^d in ""^a"". Continuing.", linno, en); */
		end;
		else indent = dclind + 1;		/* no structure */
	     end;

	     else indent = dclind+2;			/* No. */
	end;
	else do;					/* Normal statement. */
	     k = min (end_count, dent);		/* May be both do and end on same line. */
	     end_count = end_count - k;		/* If so, do not "outdent" */
	     dent = dent - k;			/* ... */
	     indent = (in + ifdent - end_count - 1) * IN + LMARGIN; /* Compute indentation. */
	     if indent < 0 then indent = 0;		/* No negative indent. */
	end;

/* This section copies the line into the output seg, inserting blanks and tabs. */

	if icol >= n then go to cpy;			/* If line is just a label, do it the easy way. */
	colpos = 0;				/* Remember where started. */
	if icol ^= 0 then do;
	     substr (bcso, nout, icol) = substr (chars, 1, icol); /* Copy label section if any. */
	     nout = nout + icol;			/* Increase offset. */
	     colpos = colpos + icol;			/* and column. */
	end;
	i = icol + 1;
	if i ^= icb then				/* Handle case of just label and comment. */
	     if indent > icol then do;		/* Must insert blanks. */
		if substr (chars, icol, 1) = SP then do; /* a blank was included in icol for labels */
		     icol = icol - 1;		/* Back up by one char, to prevent space-tab. */
		     colpos = colpos - 1;
		     nout = nout - 1;
		end;
		k = indent - icol - 1;		/* Calculate number of blanks required. */
		colpos = colpos + k;		/* Calculate new column position in output. */
		if colpos >= 10 then do;		/* Replace blanks by tabs if possible. */
		     kk = divide (colpos, 10, 17, 0) - divide (icol, 10, 17, 0);
		     if kk > 0 then do;
			substr (bcso, nout, kk) = substr (TABS, 1, kk);
			nout = nout + kk;
			k = mod (colpos, 10);	/* Tab column might not be multiple of 10 */
		     end;
		end;
		if k ^= 0 then do;
		     substr (bcso, nout, k) = "";	/* Run in blanks. */
		     nout = nout + k;
		end;
	     end;
	if ice ^= 0 then if ice = n-2 then go to havcom;	/* If comment is last thing on line, */
	if ice ^= 0 then if ice = n-3 then if substr (chars, n-1, 1) = ";" then go to havcom;
						/* or if comment is last on line except end of statement, */
	if ice = 0 then if icb > 0 then do;		/* or if comment starts on this line and doesn't end.. */
havcom:		sixty = true;			/* Yes, move comment to column 60. */
		k = icb-i;			/* Copy statement part. */
		if k ^= 0 then do;
		     substr (bcso, nout, k) = substr (chars, i, k);
		     nout = nout + k;
		     colpos = colpos + k;		/* Keep track of column. */
		     i = i + k;
		end;
		if colpos < TABCOL then do;		/* If statement does not reach to col. 60, */
		     if substr (bcso, nout-1, 1) = SP then do; /* Avoid space-tab sequence. */
			nout = nout - 1;
			colpos = colpos - 1;
		     end;
		     if substr (chars, i, 1) = SP then i = i + 1; /* ... */
		     ntab = divide (TABCOL-colpos-1, 10, 17, 0) + 1; /* Compute number of tabs to get there. */
nimcom:		     if ntab ^= 0 then do;
			substr (bcso, nout, ntab) = substr (TABS, 1, ntab);
			nout = nout + ntab;
		     end;
		     colpos = TABCOL;
		end;
		k = CMC - colpos - 1;		/* In case tab column not 10 * x + 1 */
		if k > 0 then do;
		     substr (bcso, nout, k) = "";	/* Run in blanks */
		     nout = nout + k;
		end;
	     end;
	k = n - i + 1;
	if k ^= 0 then do;
	     substr (bcso, nout, k) = substr (chars, i, k); /* Copy remainder of line. */
	     nout = nout + k;
	end;

	in = in - end_count + dent;			/* Adjust indentation base for next line. */
	ifdent = if_count;				/* Set IF's to indent. */
	if ^bos then if ^ifsw then ifdent = ifdent + 1;	/* .. if statement is continued, indent 5 more. */
	dclsw = dclsw & ^ scolsw;			/* In declaration if were in and no semicolon. */

/* Finished with the line. Go get another. */

finish_line:
	linno = linno + 1;				/* Count line. */
	if nout ^> 2 then go to loop;			/* too short to check */
	i = verify (reverse (substr (bcso, 1, nout-2)), SP_TAB); /* check for trailing white space in line copied */
	if i = 1 then go to loop;			/* there was none */
	if i = 0 then i = nout - 2;			/* there was a lot */
	else i = i - 1;				/* there was some */
	if string then do;				/* if in a string, bad news because its invisible */
	     if ^bfsw then call ioa_
		("indent: Line ^d of ""^a"" contains trailing white space that is part of a string.",
		linno - 1, en);
	     go to loop;				/* Don't change */
	end;
	nout = nout - i;				/* back up end over white space */
	substr (bcso, nout-1, 1) = NL;		/* put in a new newline */
	unspec (substr (bcso, nout, i)) = "0"b;		/* clean out the extra stuff that was moved in */
	go to loop;

/* Control comes here when the input segment is exhausted. */

eof:	if in > 0
	then if ^(rd_source_sw & in = 1)		/* rd source should be missing one "end" */
	     then do;
		call ioa_ ("indent: ""^a"" has ^d too few ""end""s.", en, in);
		error_occurred = "1"b;
	     end;
	     else;
	else if rd_source_sw
	then do;
	     call ioa_ ("indent: The reduction_compiler source ""^a"" has one too many ""end""s.", en);
	     error_occurred = "1"b;
	end;
	if string then do;
	     call ioa_ ("indent: ""^a"" ends in a string.", en);
	     error_occurred = "1"b;
	end;
	if comment then do;
	     call ioa_ ("indent: ""^a"" ends in a comment.", en);
	     error_occurred = "1"b;
	end;
	if parct > 0 then do;
	     call ioa_ ("indent: ""^a"" has ^d extra ""(""s.", en, parct);
	     error_occurred = "1"b;
	end;

	call hcs_$terminate_noname (p, ec);		/* Terminate input segment. */

	lth = 9 * (nout-1);				/* Compute bit count. */
	call hcs_$set_bc_seg (p1, lth, ec);		/* Set bit count on temp, in case of error. */

	if error_occurred then
	     if ^output_path_given then do;
		call com_err_ (0, "indent", "Input segment not replaced. Indented copy is in [pd]>^a", temp_en);
		return;
	     end;

	call hcs_$make_seg (dn, en, "", 1011b, p, ec);	/* Get ptr to final output. Make if necessary */
	if p = null then go to error1;
	call hcs_$truncate_seg (p, 0, ec);		/* Truncate target. */
	if ec ^= 0 then do;
error1:	     call com_err_ (ec, "indent", "Cannot copy ^a from [pd]>^a", en, temp_en);
	     return;
	end;
	p -> moveseg = p1 -> moveseg;			/* Zap. */
	call hcs_$set_bc_seg (p, lth, ec);		/* Set bit count. */
	call hcs_$terminate_noname (p, ec);		/* Terminate output. */
	call hcs_$delentry_seg (p1, ec);		/* Delete scratch segment. */
	return;					/* Happy return. */

error:	call com_err_ (ec, "indent", n1);		/* Here to gripe to user */
	return;					/* And give up */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* Insert a blank at "ix" */

inb:	proc (ix);
dcl  ix fixed bin (24);				/* Index in work array where blank goes. */
	     substr (temchars, 1, n-ix+1) = substr (chars, ix, n-ix+1);
	     substr (chars, ix+1, n-ix+1) = substr (temchars, 1, n-ix+1);
	     substr (chars, ix, 1) = SP;		/* Insert blank. */
	     n = n + 1;				/* Up the line length. */
	     if ix <= i then i = i + 1;		/* did we change the character looked at? */
	end inb;

/* This procedure removes "nn" blanks starting at "ix" */

outb:	proc (ix, nn);
dcl  ix fixed bin (24);
dcl  nn fixed bin (24);

	     substr (temchars, 1, n-ix-nn+1) = substr (chars, ix+nn, n-ix-nn+1);
	     substr (chars, ix, n-ix-nn+1) = substr (temchars, 1, n-ix-nn+1);
	     n = n - nn;
	     if ix = i then i = i - 1;		/* Back up one if now looking at new char. */
	     else if ix < i then i = i - nn;
	end outb;

     end indent;
