/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(88-05-16,Huen), approve(88-05-16,MCR7841), audit(88-05-25,RWaters),
     install(88-07-05,MR12.2-1054):
     Fix kermit 15, 16, 17, and 18.
  2) change(89-01-02,Huen), approve(89-01-02,MCR8036), audit(89-01-25,Lee),
     install(89-03-01,MR12.3-1020):
     Fix kermit bug: PC_File_Transfer 24 - kermit is being changed to correctly
     handle links to multisegment files.
                                                   END HISTORY COMMENTS */


kermit_receive_:
     proc;

/**********************************************************************/
/*							*/
/*n	kermit_receive_					*/
/*							*/
/*d	This routine is responsible for receiving files from a	*/
/*d	remote kermit.					*/
/*							*/
/*l	Written:	84-11-01	by Maureen Mallmes			*/
/*l	Modified:	85-01-23	by Maureen Mallmes 			*/
/*l			modified the routine, find_file, to get	*/
/*l			a proper suffixed name when given an	*/
/*l			absolute path.			*/
/*l       Modified: 87-06-19  by Don Kozlowski - Move CR and NL       */
/*l	                    constant definitions to include file.   */
/*l                           (kermit 15)                             */
/*l	Modified:	87-07-22	by Don Kozlowski - Support msf file	*/
/*l			and be more strict with lost packets	*/
/*l                           (kermit 17)                             */
/*							*/
/**********************************************************************/

/*  Not an entry  */
	return;



/* parameters  */

	dcl     ec		 fixed bin (35);
	dcl     file_sw		 bit (1);
	dcl     files_received	 fixed bin;
	dcl     first_filename	 char (*);
	dcl     infop		 ptr;
	dcl     initial_seq_n	 fixed bin;
	dcl     initial_state	 fixed bin;

/*  automatic  */

	dcl     abnormal_termination	 bit (1);
	dcl     abort_sent		 bit (1);
	dcl     discard_sw		 bit (1);
	dcl     fw_sw		 bit (1);
	dcl     ktip		 ptr;
	dcl     01 path		 aligned,
		02 dir_name	 char (168) unal,
		02 entry_name	 char (32) unal;
	dcl     receive_file_modes	 (3) fixed bin (8) unal;
	dcl     receive_file_select	 (3) fixed bin;
	dcl     state		 fixed bin;

/*  based */

	dcl     01 kermit_stats	 aligned like kermit_stats_info;
	dcl     01 kti		 like kermit_transfer_info;

/*  labels  */

	dcl     receive_state	 (0:5) label init (Rec_Init, Rec_File, Rec_Data, Rec_File_Abort, Rec_Abort, Rec_Complete);

/*  constants  */

	dcl     Discard		 char (1) internal static options (constant) init ("D");
	dcl     False		 bit (1) internal static options (constant) init ("0"b);
	dcl     Max_packet_size	 fixed bin (21) internal static options (constant) init (94);
	dcl     Max_remote_packet_size fixed bin (21) internal static options (constant) init (10000);

	dcl     Mod_64		 fixed bin internal static options (constant) init (64);
	dcl     True		 bit (1) internal static options (constant) init ("1"b);
	dcl     Whoami		 char (7) internal static options (constant) init ("receive");
	dcl     Yes		 char (1) internal static options (constant) init ("Y");

/*  builtin  */

	dcl     (addr, byte, char, index, length, ltrim, min, mod, rtrim, substr, null) builtin;

/*  conditions */

	dcl     (cleanup, record_quota_overflow) condition;

/*  external  */

	dcl     error_table_$rqover	 fixed bin (35) ext static;
	dcl     kermit_et_$fatal_error fixed bin (35) ext static;
	dcl     kermit_et_$no_file_abort fixed bin (35) ext static;
	dcl     kermit_et_$no_initialization fixed bin (35) ext static;
	dcl     kermit_et_$no_rename	 fixed bin (35) ext static;
	dcl     kermit_et_$remote_file_abort fixed bin (35) ext static;
	dcl     kermit_et_$too_many_retries fixed bin (35) ext static;

/*  procedures  */

	dcl     clock_		 entry () returns (fixed bin (71));
	dcl     delete_$path	 entry (char (*), char (*), bit (6), char (*), fixed bin (35));
	dcl     expand_pathname_	 entry (char (*), char (*), char (*), fixed bin (35));
	dcl     hcs_$status_minf	 entry (char (*), char (*), fixed bin (1), fixed bin (2), fixed bin (24), fixed bin (35));
	dcl     iox_$attach_name	 entry (char (*), ptr, char (*), ptr, fixed bin (35));
	dcl     iox_$close		 entry (ptr, fixed bin (35));
	dcl     iox_$detach_iocb	 entry (ptr, fixed bin (35));
	dcl     iox_$open		 entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
	dcl     iox_$put_chars	 entry (ptr, ptr, fixed bin (21), fixed bin (35));
	dcl     pathname_		 entry (char (*), char (*)) returns (char (168));
	dcl     suffixed_name_$make	 entry (char (*), char (*), char (32), fixed bin (35));
	dcl     terminate_file_	 entry (ptr, fixed bin (24), bit (*), fixed bin (35));
	dcl     unique_chars_	 entry (bit (*)) returns (char (15));
	

/* include files  */
%include access_mode_values;

%include kermit_dcls;

%include kermit_info;

%include kermit_mode_info;

%include kermit_transfer_info;

%include iox_modes;


receive_from_remote:
     entry (infop, initial_state, initial_seq_n, first_filename, file_sw, files_received, ec);

/**********************************************************************/
/*							*/
/*n 	Name:	kermit_receive_$receive_from_remote	external	*/
/*i 	Input:	infop, initial_state, first_filename,		*/
/*i		file_sw					*/
/*f 	Function: Receives a file or file group from the 		*/
/*f		remote.  Provides a state-switching mechanism	*/
/*f		and data interface via calls to receive_init	*/
/*f		receive_filename, receive_data, abort_receive	*/
/*f		and complete.  Updates the log		*/
/*o 	Output:	files_received, ec				*/
/*							*/
/**********************************************************************/


/*  initialize file transfer data  */

	ktip = addr (kti);
	kti.statisticsp = addr (kermit_stats);

/*  In case we can't get past the Send-Init  */
	path.dir_name = " ";
	if file_sw then
	     path.entry_name = first_filename;
	else path.entry_name = "????";

	kti.filenamesp = addr (path);
	kti.retry_count = 0;
	kti.sequence_n = initial_seq_n;
	kti.filenames_idx = 0;
	kti.filep = null ();
	kti.buffp = null ();
	kti.iocb_ptr = null ();
	kti.msf = False;
	kti.file_count = 0;
	kti.statisticsp = addr (kermit_stats);

	kermit_stats.caller = Whoami;
	call init_file_stats (ktip);

	receive_file_select (1) = Retry_threshold;
	receive_file_select (2) = File_warning;
	receive_file_select (3) = Incomplete;

	call kermit_mode_mgr_$retrieve (infop, Permanent, receive_file_select, addr (receive_file_modes), ec);

	kti.retry_threshold = receive_file_modes (1);
	fw_sw = (byte (receive_file_modes (2)) = Yes);
	discard_sw = (byte (receive_file_modes (3)) = Discard);



/*  Handlers  */
	on cleanup begin;
		abnormal_termination = True;
		call terminate_file (ktip, discard_sw, abnormal_termination);
	     end;

	on record_quota_overflow
	     begin;
		abnormal_termination = True;
		call terminate_file (ktip, discard_sw, abnormal_termination);
		call kermit_pad_$send (infop, Error_packet, null (), 0, kti.sequence_n, 0, 0, ec);
		ec = error_table_$rqover;
		goto Rec_Complete;
	     end;

	abort_sent = False;
	files_received = 0;
	state = initial_state;

/*  State switcher  */

	do while ("1"b);

	     goto receive_state (state);

Rec_Init:
	     call receive_init (infop, ktip, state);
	     goto exit_state;

Rec_File:
	     call receive_filename (infop, ktip, first_filename, file_sw, fw_sw, state);
	     goto exit_state;
Rec_Data:
	     call receive_data (infop, ktip, discard_sw, abort_sent, state);
	     goto exit_state;

Rec_File_Abort:
	     call receive_file_abort (infop, ktip, discard_sw, abort_sent, state);
	     goto exit_state;

Rec_Abort:					/*  Are we here because we couldn't abort a single file?  */
	     if abort_sent then
		ec = kermit_et_$no_file_abort;	/* yes */
	     else ec = kermit_stats.status;		/* no */
	     call update_log (infop, ktip, discard_sw);

Rec_Complete:
	     files_received = kti.file_count;
	     return;

exit_state:
	end;

	return;



receive_data:
     proc (infop, ktip, discard_sw, abort_sent, state);


/**********************************************************************/
/*							*/
/*n 	Name:	kermit_receive_$receive_data		internal	*/
/*i 	Input:	infop, ktip, discard_sw			*/
/*f 	Function: Waits for File-Data Packet.			*/
/*f		If data cannot be stored (segment too big), then	*/
/*f		an attempt is made to abort the receipt of the	*/
/*f		single file by placing an "X" in the data portion */
/*f		of the Ack packet.				*/
/*o 	Output:	state, abort_sent				*/
/*							*/
/**********************************************************************/

/* parameters  */

	dcl     abort_sent		 bit (1);
	dcl     discard_sw		 bit (1);
	dcl     infop		 ptr;
	dcl     ktip		 ptr;
	dcl     state		 fixed bin;

/*  automatic  */

	dcl     abort_char		 char (1);
	dcl     abort_char_lth	 fixed bin (21);
	dcl     chars_received	 fixed bin (21);
	dcl     chars_sent		 fixed bin (21);
	dcl     ec		 fixed bin (35);
	dcl     eol_split		 bit (1);
	dcl     idx		 fixed bin;
	dcl     packet_n		 fixed bin;
	dcl     packet_size		 fixed bin (21);
	dcl     packet_type		 char (1);
	dcl     r_packet_size	 fixed bin (21);
	dcl     remote_data		 char (Max_remote_packet_size);
	dcl     remote_datap	 ptr;


/*  based  */

	dcl     01 kermit_stats	 aligned like kermit_stats_info based (kti.statisticsp);
	dcl     01 kti		 like kermit_transfer_info based (ktip);

/*  labels  */

	dcl     packet		 (0:4) label init (Other, File_header, Data, Eof, Error);

/*  constants  */
	dcl     False		 bit (1) internal static options (constant) init ("0"b);
	dcl     True		 bit (1) internal static options (constant) init ("1"b);
	dcl     Discard_char	 char (1) internal static options (constant) init ("X");
	dcl     Packet_string	 char (4) internal static options (constant) init ("FDZE");
	dcl     Remote_discard	 char (1) internal static options (constant) init ("D");


	ec = 0;
	abort_sent = False;
	abort_char_lth = 0;
	remote_datap = addr (remote_data);
	kti.retry_count = kti.retry_count + 1;

/*  Should we give up?? */
	if kti.retry_count > kti.retry_threshold then do;
		call kermit_pad_$send (infop, Error_packet, null (), 0, kti.sequence_n, 0, 0, ec);
		kermit_stats.status = kermit_et_$too_many_retries;
		state = Rec_abort;
		return;
	     end;

/*  Get a packet  */
	call kermit_pad_$receive (infop, packet_type, remote_datap, Max_remote_packet_size, packet_n, chars_received,
	     r_packet_size, eol_split, ec);

	if ec ^= 0 then goto Retry_packet;

/*  Respond to remote packet  */
	idx = index (Packet_string, packet_type);
	goto packet (idx);


Data:						/*  Received remote DATA packet  */
	if kti.sequence_n ^= packet_n then do;		/*  Remote lost a previous ack?  */
		call check_lost_packet (infop, ktip, packet_n);
		return;
	     end;

	if chars_received ^= 0 then call store_data (ktip, eol_split, remote_data, chars_received, r_packet_size, ec);
	if ec ^= 0 then do;				/*  Have to abort receipt of this file  */
		kermit_stats.status = ec;
		abort_char = Discard_char;
		abort_char_lth = 1;
		abort_sent = True;			/* Record the attempted abort  */
	     end;

	call kermit_pad_$send (infop, Ack_packet, addr (abort_char), abort_char_lth, kti.sequence_n, chars_sent, packet_size, ec);

	kti.retry_count = 0;
	kti.sequence_n = mod (kti.sequence_n + 1, Mod_64);
	if abort_sent then state = Rec_file_abort;
	return;



File_header:					/*  Received FILE-HEADER packet  */
						/*  Remote may have lost our previous ACK  */
	call check_lost_packet (infop, ktip, packet_n);
	return;



Eof:						/*  Received EOF packet  */
	if kti.sequence_n ^= packet_n then goto Retry_packet;

/*  Otherwise, we have a valid eof packet.  Check to see if the remote
	   wants to abort it or terminate it normally  */
	if chars_received ^= 0 then do;
		if substr (remote_data, 1, chars_received) = Remote_discard then
		     kermit_stats.status = kermit_et_$remote_file_abort;
	     end;


	call kermit_pad_$send (infop, Ack_packet, null (), 0, kti.sequence_n, chars_sent, packet_size, ec);
	kermit_stats.end_time = clock_ ();
	call update_log (infop, ktip, discard_sw);
	kti.retry_count = 0;
	kti.sequence_n = mod (kti.sequence_n + 1, Mod_64);
	state = Rec_file_header;
	return;



Error:						/*  Received ERROR packet  */
	kermit_stats.status = kermit_et_$fatal_error;
	kermit_stats.error_message = substr (remote_data, 1, chars_received);
	state = Rec_abort;
	return;

Other:						/*  Received unexpected packet  */
Retry_packet:
	call kermit_pad_$send (infop, Nak_packet, null (), 0, kti.sequence_n, chars_sent, packet_size, ec);
	kermit_stats.packet_retries = kermit_stats.packet_retries + 1;
	return;

     end receive_data;

receive_filename:
     proc (infop, ktip, user_filename, user_file_sw, file_warning_sw, state);


/**********************************************************************/
/*							*/
/*n 	Name:	kermit_receive_$receive_filename	internal	*/
/*i 	Input:	infop, ktip, user_filename, user_file_sw	*/
/*i		file_warning_sw				*/
/*f 	Function: Waits for File-Header Packet.			*/
/*f		If there is data in the data portion of the	*/
/*f		packet, i.e. remote has supplied a filename, an	*/
/*f		Ack packet is sent to the remote.		*/
/*f		Verification of the filename now occurs:	*/
/*f		If the data can be stored under the supplied 	*/
/*f		filename, all is okay.   If the data cannot be	*/
/*f		stored under the given filename, an attempt will	*/
/*f		later be made to abort receipt of the file, (next	*/
/*f		state = receive_file_abort).			*/
/*o 	Output:	state					*/
/*							*/
/**********************************************************************/

/* parameters  */

	dcl     infop		 ptr;
	dcl     file_warning_sw	 bit (1);
	dcl     ktip		 ptr;
	dcl     state		 fixed bin;
	dcl     user_file_sw	 bit (1);
	dcl     user_filename	 char (*);

/*  automatic  */

	dcl     ack_init_data	 char (Max_packet_size);
	dcl     ack_init_data_lth	 fixed bin (21);
	dcl     ack_init_datap	 ptr;
	dcl     ack_init_packet	 char (Max_packet_size);
	dcl     ack_init_packet_lth	 fixed bin (21);
	dcl     ack_init_packetp	 ptr;
	dcl     chars_received	 fixed bin (21);
	dcl     chars_sent		 fixed bin (21);
	dcl     ec		 fixed bin (35);
	dcl     eol_split		 bit (1);
	dcl     idx		 fixed bin;
	dcl     file_ptr		 ptr;
	dcl     packet_n		 fixed bin;
	dcl     packet_size		 fixed bin (21);
	dcl     packet_type		 char (1);
	dcl     rec_filename	 char (168);
	dcl     remote_data		 char (Max_remote_packet_size);
	dcl     remote_datap	 ptr;
	dcl     source_dir		 char (168);
	dcl     source_ename	 char (32);


/*  based  */

	dcl     01 kermit_stats	 aligned like kermit_stats_info based (kti.statisticsp);
	dcl     01 kti		 like kermit_transfer_info based (ktip);
	dcl     01 path		 aligned based (kti.filenamesp),
		02 dir_name	 char (168) unal,
		02 entry_name	 char (32) unal;

/*  labels  */

	dcl     packet		 (0:5) label init (Other, File_header, Send_init, Eof, Break, Error);

/*  constants  */

	dcl     False		 bit (1) internal static options (constant) init ("0"b);
	dcl     Packet_string	 char (5) internal static options (constant) init ("FSZBE");

	ec = 0;
	remote_datap = addr (remote_data);
	kti.retry_count = kti.retry_count + 1;

/*  Should we give up??  */
	if kti.retry_count > kti.retry_threshold then do;
		call kermit_pad_$send (infop, Error_packet, null (), 0, kti.sequence_n, 0, 0, ec);
		kermit_stats.status = kermit_et_$too_many_retries;
		state = Rec_abort;
		return;
	     end;

/*  Get the remote's packet  */
	call kermit_pad_$receive (infop, packet_type, remote_datap, Max_remote_packet_size, packet_n, chars_received,
	     packet_size, eol_split, ec);

	if ec ^= 0 then goto Retry_packet;

/*  Respond to the remote's packet  */
	idx = index (Packet_string, packet_type);
	goto packet (idx);


File_header:					/*  Received FILE-HEADER packet  */
	if kti.sequence_n ^= packet_n then goto Retry_packet;

/* make sure there's something that can be used as a filename  */
	if chars_received = 0 then goto Retry_packet;

/*  Acknowledge receipt of filename  */
	call kermit_pad_$send (infop, Ack_packet, null (), 0, kti.sequence_n, chars_sent, packet_size, ec);

	kti.retry_count = 0;
	kti.sequence_n = mod (kti.sequence_n + 1, Mod_64);

/*  Have we already set up the file  */
	if kti.iocb_ptr = null then do;    /* no */
		kermit_stats.status = 0;		/*  Are we using the user-supplied filename?  */
		if user_file_sw then do;
			rec_filename = user_filename;
			user_file_sw = False;
		     end;

		else do;
			rec_filename = substr (remote_data, 1, chars_received);
						/*  delete all trailing '.' on the remote-supplied filename  */
			rec_filename = rtrim (rtrim (rec_filename), ".");
		     end;

		call find_file (rec_filename, file_warning_sw, source_dir, source_ename, file_ptr, ec);

		kti.iocb_ptr = file_ptr;
		path.dir_name = source_dir;
		path.entry_name = source_ename;
		kermit_stats.start_time = clock_ ();

		if ec ^= 0 then do;			/*  can't receive this file  */
			kermit_stats.status = ec;
			kermit_stats.end_time = kermit_stats.start_time;
			state = Rec_file_abort;	/* where we'll tell the remote we can't receive it  */
			return;
		     end;

/* otherwise, we have sucessfully initiated the file for receiving  */

	     end;

	state = Rec_data;
	return;


Send_init:					/* Receive SEND-INIT packet  */
						/*  The remote may have lost our ACK to his send_init so send the parameters
						   again.  */
	kermit_stats.packet_retries = kermit_stats.packet_retries + 1;
	if mod (packet_n + 1, 64) = kti.sequence_n then do;
		ack_init_datap = addr (ack_init_data);
		ack_init_packetp = addr (ack_init_packet);
		call kermit_xfer_modes_$get_local_params (infop, ack_init_datap, ack_init_data_lth, ack_init_packetp,
		     ack_init_packet_lth, ec);

/*  this should never happen  */
		if ec ^= 0 then goto Retry_packet;
		call kermit_pad_$send (infop, Ack_packet, ack_init_packetp, ack_init_packet_lth, packet_n, chars_sent, packet_size, ec);
	     end;

	else goto Retry_packet;
	return;


Eof:						/*  Received EOF packet  */
						/*  Remote may have lost our previous ACK  */
	call check_lost_packet (infop, ktip, packet_n);
	return;

Break:						/*  Received a BREAK packet  */
	if kti.sequence_n ^= packet_n then goto Retry_packet;

	call kermit_pad_$send (infop, Ack_packet, null (), 0, kti.sequence_n, chars_sent, packet_size, ec);

	call verify_receipt (infop, ktip);
	state = Rec_complete;			/* change state  */
	return;

Error:						/*  Received ERROR packet  */
	kermit_stats.status = kermit_et_$fatal_error;
	kermit_stats.error_message = substr (remote_data, 1, chars_received);
	state = Rec_abort;
	return;

Other:						/*  Received unexpected packet  */
Retry_packet:
	call kermit_pad_$send (infop, Nak_packet, null (), 0, kti.sequence_n, chars_sent, packet_size, ec);
	kermit_stats.packet_retries = kermit_stats.packet_retries + 1;
	return;
     end receive_filename;


receive_init:
     proc (infop, ktip, state);


/**********************************************************************/
/*							*/
/*n 	Name:	kermit_receive_$receive_init		internal	*/
/*i 	Input:	infop, ktip				*/
/*f 	Function: Performs the initialization of the required modes */
/*f		for communicating with the remote system.	*/
/*f		Waits for a Send-Initiate (S) packet specifying	*/
/*f		the remote's parameters.			*/
/*f		Responds with its own parameters via an ACK	*/
/*f		(Y) packet.  The results of this negotiation are	*/
/*f		recorded in New-Modes.			*/
/*o 	Output:	state					*/
/*							*/
/**********************************************************************/

/* parameters  */

	dcl     infop		 ptr;
	dcl     ktip		 ptr;
	dcl     state		 fixed bin;

/*  automatic  */

	dcl     chars_received	 fixed bin (21);
	dcl     chars_sent		 fixed bin (21);
	dcl     ec		 fixed bin (35);
	dcl     eol_split		 bit (1);
	dcl     idx		 fixed bin;
	dcl     packet_n		 fixed bin;
	dcl     packet_size		 fixed bin (21);
	dcl     packet_type		 char (1);
	dcl     remote_data		 char (Max_remote_packet_size);
	dcl     remote_datap	 ptr;
	dcl     ack_init_data	 char (Max_packet_size);
	dcl     ack_init_datap	 ptr;
	dcl     ack_init_data_lth	 fixed bin (21);
	dcl     ack_init_packet	 char (Max_packet_size);
	dcl     ack_init_packet_lth	 fixed bin (21);
	dcl     ack_init_packetp	 ptr;

/*  based  */

	dcl     01 kermit_stats	 aligned like kermit_stats_info based (kti.statisticsp);
	dcl     01 kti		 like kermit_transfer_info based (ktip);

/*  labels  */

	dcl     packet		 (0:2) label init (Other, Send_init, Error);

/*  constants  */

	dcl     Packet_string	 char (2) internal static options (constant) init ("SE");

	ec = 0;
	ack_init_datap = addr (ack_init_data);
	ack_init_packetp = addr (ack_init_packet);
	remote_datap = addr (remote_data);
	kti.retry_count = kti.retry_count + 1;

/*  Should we give up?  */
	if kti.retry_count > kti.retry_threshold then do;
		call kermit_pad_$send (infop, Error_packet, null (), 0, kti.sequence_n, 0, 0, ec);
		kermit_stats.status = kermit_et_$no_initialization;
		state = Rec_abort;
		return;
	     end;

/*  Get remote send-init data  */
	call kermit_pad_$receive (infop, packet_type, remote_datap, Max_remote_packet_size, packet_n, chars_received,
	     packet_size, eol_split, ec);
	if ec ^= 0 then goto Retry_packet;

	idx = index (Packet_string, packet_type);
	goto packet (idx);



Send_init:					/* Received SEND-INIT packet  */
	if packet_n ^= kti.sequence_n then goto Retry_packet;

/* Have the remote init data, so set the modes  database  */
	call kermit_xfer_modes_$get_local_params (infop, ack_init_datap, ack_init_data_lth, ack_init_packetp, ack_init_packet_lth, ec);
	if ec ^= 0 then goto Retry_packet;

	call kermit_xfer_modes_$check_params (infop, remote_datap, chars_received, ack_init_datap, ec);
	if ec ^= 0 then
	     goto Retry_packet;

/* else all is fine, so give the remote kermit the local modes  */
	call kermit_pad_$send (infop, Ack_packet, ack_init_packetp, ack_init_packet_lth, kti.sequence_n, chars_sent,
	     packet_size, ec);
	if ec ^= 0 then
	     goto Retry_packet;


/* All okay, so set the tty_ line to the new modes  */
	call kermit_xfer_modes_$process_params (infop, remote_datap, chars_received, ack_init_datap, ec);
	if ec ^= 0 then
	     goto Retry_packet;

	call kermit_comm_mgr_$reset_line_modes (infop, ec);
	call kermit_comm_mgr_$set_line_modes (infop, ec);

	kti.retry_count = 0;
	kti.sequence_n = mod (kti.sequence_n + 1, Mod_64);
	state = Rec_file_header;
	return;

Error:						/*  Received ERROR packet  */
	kermit_stats.status = kermit_et_$fatal_error;
	kermit_stats.error_message = substr (remote_data, 1, chars_received);
	state = Rec_abort;
	return;

Other:						/*  Received unexpected packet  */
Retry_packet:
	call kermit_pad_$send (infop, Nak_packet, null (), 0, kti.sequence_n, chars_sent, packet_size, ec);
	kermit_stats.packet_retries = kermit_stats.packet_retries + 1;
	return;
     end receive_init;


receive_file_abort:
     proc (infop, ktip, discard_sw, abort_sent, state);


/**********************************************************************/
/*							*/
/*n 	Name:	kermit_receive_$receive_file_abort	internal	*/
/*i 	Input:	infop, ktip, discard_sw, abort_sent		*/
/*f 	Function: Responsible for handling the abort of a single	*/
/*f		file initiated by the local kermit.		*/
/*f		To abort a single file, put an "X" in the data	*/
/*f		portion of the Ack to a DATA packet.  If the	*/
/*f		remote understands 'single file aborts', it will	*/
/*f		respond with a "D" in the data field of an EOF	*/
/*f		packet.					*/
/*f		Kermits that do not understand a single file	*/
/*f		abort will continue sending Data packets.  If this */
/*f		occurs, the local kermit must abort the whole	*/
/*f		transaction.				*/
/*f		If abort_sent = True then an abortive Ack packet	*/
/*f		has already been sent.  Receiving a data packet	*/
/*f		then means that the remote does not understand.	*/
/*f		If abort_sent = False then we have yet to send	*/
/*f		out the abortive Ack.  As soon as we get a Data	*/
/*f		packet, send out the abortive Ack, and return to	*/
/*f		this state.				*/
/*o 	Output:	abort_sent, state				*/
/*							*/
/**********************************************************************/

/* parameters  */

	dcl     infop		 ptr;
	dcl     ktip		 ptr;
	dcl     abort_sent		 bit (1);
	dcl     discard_sw		 bit (1);
	dcl     state		 fixed bin;

/*  automatic  */

	dcl     abort_char		 char (1);
	dcl     abort_charp		 ptr;
	dcl     chars_received	 fixed bin (21);
	dcl     chars_sent		 fixed bin (21);
	dcl     ec		 fixed bin (35);
	dcl     eol_split		 bit (1);
	dcl     idx		 fixed bin;
	dcl     packet_n		 fixed bin;
	dcl     packet_size		 fixed bin (21);
	dcl     packet_type		 char (1);
	dcl     r_packet_size	 fixed bin (21);
	dcl     remote_data		 char (Max_remote_packet_size);
	dcl     remote_datap	 ptr;


/*  based  */

	dcl     01 kermit_stats	 aligned like kermit_stats_info based (kti.statisticsp);
	dcl     01 kti		 like kermit_transfer_info based (ktip);

/*  labels  */

	dcl     packet		 (0:4) label init (Other, File_header, Data, Eof, Error);

/*  constants  */

	dcl     Discard_char	 char (1) internal static options (constant) init ("X");
	dcl     False		 bit (1) internal static options (constant) init ("0"b);
	dcl     Packet_string	 char (4) internal static options (constant) init ("FDZE");
	dcl     True		 bit (1) internal static options (constant) init ("1"b);

	ec = 0;
	abort_char = Discard_char;
	abort_charp = addr (abort_char);
	remote_datap = addr (remote_data);

	kti.retry_count = kti.retry_count + 1;

/*  Should we give up??  */
	if kti.retry_count > kti.retry_threshold then do;
		call kermit_pad_$send (infop, Error_packet, null (), 0, kti.sequence_n, 0, 0, ec);
		kermit_stats.status = kermit_et_$too_many_retries;
		state = Rec_abort;
		return;
	     end;

/*  Get the remote's packet */
	call kermit_pad_$receive (infop, packet_type, remote_datap, Max_remote_packet_size, packet_n, chars_received,
	     r_packet_size, eol_split, ec);

	if ec ^= 0 then goto Retry_packet;

/*  Respond to remote's packet  */
	idx = index (Packet_string, packet_type);
	goto packet (idx);



Data:						/*  Received remote DATA packet  */
	if kti.sequence_n ^= packet_n then do;		/*  Remote lost a previous ack?  */
						/*  yes  */
		if mod (packet_n + 1, 64) = kti.sequence_n then do;
			call kermit_pad_$send (infop, Ack_packet, abort_charp, 1, packet_n, chars_sent, packet_size, ec);
			kermit_stats.packet_retries = kermit_stats.packet_retries + 1;
			abort_sent = "1"b;
			return;
		     end;
		else goto Retry_packet;		/*  No  */
	     end;

/*  We are trying to abort a single file */
/*  If we haven't signalled the abort yet, do so now  */
	if ^abort_sent then do;
		call kermit_pad_$send (infop, Ack_packet, abort_charp, 1, kti.sequence_n, chars_sent, packet_size, ec);
		kti.retry_count = 0;
		kti.sequence_n = mod (kti.sequence_n + 1, Mod_64);
		abort_sent = True;
		return;
	     end;					/*  We already sent the abort, but remote obviously doesn't understand, so
						   kill the transaction  */
	else if abort_sent then do;
		call kermit_pad_$send (infop, Error_packet, null (), 0, kti.sequence_n, 0, 0, ec);

		state = Rec_abort;
		return;
	     end;

File_header:					/*  Received FILE-HEADER packet  */
						/*  Remote may have lost our previous ACK  */
	call check_lost_packet (infop, ktip, packet_n);
	return;


Eof:						/*  Received EOF packet  */
	if kti.sequence_n ^= packet_n then goto Retry_packet;


/*  Well, we got an eof.  Doesn't matter whether the remote
	   understood the file abort or not, because it's finished sending.  */
	call kermit_pad_$send (infop, Ack_packet, null (), 0, kti.sequence_n, chars_sent, packet_size, ec);
	abort_sent = False;
	kermit_stats.end_time = clock_ ();
	call update_log (infop, ktip, discard_sw);
	kti.retry_count = 0;
	kti.sequence_n = mod (kti.sequence_n + 1, Mod_64);
	state = Rec_file_header;
	return;



Error:						/*  Received ERROR packet  */
	kermit_stats.status = kermit_et_$fatal_error;
	kermit_stats.error_message = substr (remote_data, 1, chars_received);
	state = Rec_abort;
	return;

Other:						/*  Received unexpected packet  */
Retry_packet:
	call kermit_pad_$send (infop, Nak_packet, null (), 0, kti.sequence_n, chars_sent, packet_size, ec);
	kermit_stats.packet_retries = kermit_stats.packet_retries + 1;
	return;

     end receive_file_abort;

update_log:
     proc (infop, ktip, discard_sw);

/**********************************************************************/
/*							*/
/*n 	Name:	kermit_receive_$update_log		internal	*/
/*i 	Input:	infop, ktip, discard_sw			*/
/*f	Function:	Calls the log_mgr_ to updates the log-file and	*/
/*f		statistics database.  Re-initializes all file 	*/
/*f		associated variables.			*/
/*o	Output:	none					*/
/*							*/
/**********************************************************************/

/* parameters  */

	dcl     discard_sw		 bit (1);
	dcl     infop		 ptr;
	dcl     ktip		 ptr;

/*  automatic  */

	dcl     abnormal_termination	 bit (1);

/*  based  */

	dcl     01 path		 aligned based (kti.filenamesp),
		02 dir_name	 char (168) unal,
		02 entry_name	 char (32) unal;
	dcl     01 kermit_stats	 aligned like kermit_stats_info based (kti.statisticsp);
	dcl     01 kti		 like kermit_transfer_info based (ktip);


	kermit_stats.file_len = kermit_stats.char_count;
	kermit_stats.filename = pathname_ (rtrim (path.dir_name), rtrim (path.entry_name));
	call kermit_log_mgr_$log_message (infop, kti.statisticsp);

	if kermit_stats.status = 0 then kti.file_count = kti.file_count + 1;
	abnormal_termination = (kermit_stats.status ^= 0);
	call terminate_file (ktip, discard_sw, abnormal_termination);

	kti.buffp = null ();

	path.dir_name, path.entry_name = " ";

	call init_file_stats (ktip);

	return;
     end update_log;

find_file:
     proc (filename, file_warning_sw, source_dir, source_ename, file_ptr, ec);

/**********************************************************************/
/*							*/
/*n 	Name:	kermit_receive_$find_file		internal	*/
/*i 	Input:	filename, file_warning_sw			*/
/*f 	Function: Gets a pointer to the file to be received, 	*/
/*f	renaming if necessary.				*/
/*o 	Output:	source_dir, source_ename, file_ptr, ec		*/
/*l       Modified: 89-01-02 by S Huen - Handle links to multisegment */
/*l                 files correctly. (pc_24)                          */
/*							*/
/**********************************************************************/

/*  parameters   */
	dcl     ec		 fixed bin (35);
	dcl     file_ptr		 ptr;
	dcl     file_warning_sw	 bit (1);
	dcl     filename		 char (*);
	dcl     source_dir		 char (168);
	dcl     source_ename	 char (32);

/*  automatic  */

	dcl     abs_max_suffix	 fixed bin;
	dcl     bit_count		 fixed bin (24);
	dcl     file_suffix		 fixed bin;
	dcl     max_suffix_lth	 fixed bin;
	dcl     max_suffix		 fixed bin;
	dcl     name_dup		 bit (1);
	dcl     suffixed_filename	 char (32);

/*  Constants  */

	dcl     Max_entry_lth	 fixed bin internal static options (constant) init (32);
	dcl     True		 bit (1) internal static options (constant) init ("1"b);

	ec = 0;
	source_dir = " ";
	source_ename = " ";
	file_ptr = null ();
	name_dup = True;

	call expand_pathname_ (filename, source_dir, source_ename, ec);
	if ec ^= 0 then return;

	suffixed_filename = source_ename;

/*  Calculate the maximum suffix, where suffix = "1" to "9..."  */

	abs_max_suffix = 2 ** 17;
	max_suffix_lth = (Max_entry_lth - length (rtrim (suffixed_filename))) - 1;
						/*  allow for '.' */
	max_suffix = min (10 ** max_suffix_lth - 1, abs_max_suffix);

	do file_suffix = 1 to max_suffix while (name_dup);

	     call hcs_$status_minf (rtrim (source_dir), rtrim (suffixed_filename), (1), (0), bit_count, ec);
	     if ec = 0 
		then do;		/*  The file is already there, so either...  */
		     if ^file_warning_sw then /*  delete it (file warning is off)  */
			call delete_$path (
			rtrim (source_dir), rtrim (suffixed_filename),
			"000111"b, "kermit", ec);
		     else do;			/*  find a new name for the segment  */
			call suffixed_name_$make (source_ename, ltrim (char (file_suffix)), suffixed_filename, ec);
			     if ec ^= 0 then do;
				     ec = kermit_et_$no_rename;
				     return;
				end;
			end;
		end;
	     else name_dup = False;			/*  Successfully created new file  */


	end;					/* while  */

	if name_dup then do;
		ec = kermit_et_$no_rename;
		return;
	     end;


/*  If we get this far we have a file for receiving  */

	source_ename = suffixed_filename;
	call iox_$attach_name ("kermit." || unique_chars_ (False),
	     file_ptr, "vfile_ " || pathname_ (source_dir, source_ename),
	     null(), ec);
	call iox_$open (file_ptr, Stream_output, "0"b, ec);
	
	return;
     end find_file;

terminate_file:
     proc (ktip, discard_sw, abnormal_termination);

/**********************************************************************/
/*							*/
/*n 	Name:	kermit_receive_$terminate_file		internal	*/
/*i 	Input:	ktip, discard_sw, abnormal_termination		*/
/*f 	Function: Terminates a file, deleting if discard_sw is true	*/
/*f		and the file could not be received normally.	*/
/*o 	Output:	none                          		*/
/*							*/
/**********************************************************************/

/* parameters */

	dcl     abnormal_termination	 bit (1);
	dcl     discard_sw		 bit (1);
	dcl     ktip		 ptr;

	dcl     01 kti		 like kermit_transfer_info based (ktip);
						/* automatic */

	if kti.iocb_ptr ^= null () then do;
	     call iox_$close (kti.iocb_ptr, ec);
	     call iox_$detach_iocb (kti.iocb_ptr, ec);
	     if discard_sw & abnormal_termination then
		call delete_$path (
	kti.filenamesp -> kermit_filenames(kti.filenames_idx).directory,
	kti.filenamesp -> kermit_filenames(kti.filenames_idx).entry_name,
		"000111"b, "kermit", ec);
	     kti.iocb_ptr = null ();
	     end;
	return;
     end terminate_file;

check_lost_packet:
     proc (infop, ktip, packet_n);

/**********************************************************************/
/*							*/
/*n 	Name:	kermit_receive_$check_lost_packet	internal	*/
/*i 	Input:	infop, ktip, packet_n                             */
/*f 	Function: If we have a previous packet (previous ack was    */
/*f                 lost), retransmits the lost ack.  Otherwise naks  */
/*f                 the packet.                                       */
/*o 	Output:	none                                              */
/*							*/
/**********************************************************************/

/*  parameters  */

	dcl     infop		 ptr;
	dcl     ktip		 ptr;
	dcl     packet_n		 fixed bin;
/* static  */

          dcl     last_lost_packet	 fixed bin static internal init (-1);
/*  based  */

	dcl     01 kermit_stats	 aligned like kermit_stats_info based (kti.statisticsp);
	dcl     01 kti		 like kermit_transfer_info based (ktip);

          
	if mod (packet_n + 1, 64) = kti.sequence_n then do;
	     if mod (last_lost_packet + 1, 64) ^= packet_n then
		call kermit_pad_$send (infop, Ack_packet, null (), 0, packet_n, 0, 0, ec);
	     last_lost_packet = packet_n;
	     end;		         /*  No  */
	else do;
	     call kermit_pad_$send (infop, Nak_packet, null (), 0, kti.sequence_n, 0, 0, ec);
	     last_lost_packet = -1;
	     end;
	kermit_stats.packet_retries = kermit_stats.packet_retries + 1;
	return;
     end check_lost_packet;

store_data: proc (ktip, eol_split, data, data_lth, packet_size, ec);

/**********************************************************************/
/*							*/
/*n 	Name:	kermit_receive_$store_data      	internal	*/
/*i 	Input:	ktip, eol_split, data, data_lth, packet_size      */
/*f 	Function: Writes the data to the file.                      */
/*o 	Output:	ec                                                */
/*							*/
/**********************************************************************/

/*  parameters  */

	dcl     data		 char (*);
	dcl     data_lth		 fixed bin (21);
	dcl     eol_split		 bit (1);
	dcl     ec		 fixed bin (35);
	dcl     ktip		 ptr;
	dcl     packet_size		 fixed bin (21);


/*  based  */

	dcl     01 kermit_stats	 aligned like kermit_stats_info based (kti.statisticsp);
	dcl     01 kti		 like kermit_transfer_info based (ktip);

	ec = 0;

/*  Account for CR-LF being split across two packets  */
	if eol_split & kti.owe_a_cr then
	     kti.owe_a_cr = False;

/*  All okay, so write it out  */

	if kti.owe_a_cr
	     then do;
	     call iox_$put_chars (kti.iocb_ptr, addr (CR), 1, ec);
	     kermit_stats.char_count = kermit_stats.char_count + 1;
	     kti.owe_a_cr = False;
	     end;

	if substr (data, data_lth, 1) = CR
	     then do;
	     kti.owe_a_cr = True;
	     data_lth = data_lth - 1;
	     end;
	call iox_$put_chars (kti.iocb_ptr, addr (data), data_lth, ec);
	kermit_stats.char_count = kermit_stats.char_count + data_lth;
	kermit_stats.packet_count = kermit_stats.packet_count + 1;
	kermit_stats.packet_chars = kermit_stats.packet_chars + packet_size;
	return;
     end store_data;

init_file_stats:
     proc (ktip);

/**********************************************************************/
/*							*/
/*n 	Name:	kermit_receive_$init_file_stats      	internal	*/
/*i 	Input:	ktip                                              */
/*f 	Function: Initializes file statistics.                      */
/*o 	Output:	none                                              */
/*							*/
/**********************************************************************/

/*  parameters  */

	dcl     ktip		 ptr;

/*  based  */

	dcl     01 kermit_stats	 aligned like kermit_stats_info based (kti.statisticsp);
	dcl     01 kti		 like kermit_transfer_info based (ktip);



	kermit_stats.filename = " ";
	kermit_stats.file_len = 0;
	kermit_stats.char_count = 0;
	kermit_stats.packet_chars = 0;
	kermit_stats.packet_count = 0;
	kermit_stats.packet_retries = 0;
	kermit_stats.start_time = 0;
	kermit_stats.end_time = 0;
	kermit_stats.error_message = " ";

	return;
     end init_file_stats;

verify_receipt:
     proc (infop, ktip);

/**********************************************************************/
/*							*/
/*n 	Name:	kermit_receive_$verify_receipt      	internal	*/
/*i 	Input:	infop, ktip                                       */
/*f 	Function: This routine tries to ensure that the remote      */
/*f 	          system received the ack to its EOT packet.        */
/*o 	Output:	none                                              */
/*							*/
/**********************************************************************/

/*  parameters  */

	dcl     ktip		 ptr;
	dcl     infop		 ptr;

/*  automatic  */

	dcl     chars_received	 fixed bin (21);
	dcl     chars_sent		 fixed bin (21);
	dcl     ec		 fixed bin (35);
	dcl     eol_split		 bit (1);
	dcl     packet_n		 fixed bin;
	dcl     packet_size		 fixed bin (21);
	dcl     packet_type		 char (1);
	dcl     packet_timeout	 fixed bin (8) unal;
	dcl     r_packet_size	 fixed bin (21);
	dcl     remote_data		 char (Max_remote_packet_size);
	dcl     remote_datap	 ptr;
	dcl     timeout_select	 (1) fixed bin;

/*  based  */

	dcl     01 kti		 like kermit_transfer_info based (ktip);

/*  constants  */

	dcl     Five_seconds	 fixed bin (8) unal internal static options (constant) init (5);


/*  Make sure the remote got the ack, because if it didn't it will hang  */

/*  Make the timeout interval reasonable for this state  */
	timeout_select (1) = I_timeout;
	packet_timeout = Five_seconds;

	call kermit_mode_mgr_$store (infop, Temporary, timeout_select, addr (packet_timeout), ec);

	packet_type = "";
	remote_datap = addr (remote_data);

	call kermit_pad_$receive (infop, packet_type, remote_datap, Max_remote_packet_size, packet_n, chars_received,
	     r_packet_size, eol_split, ec);

	do while (packet_type = Eot_packet);
	     call kermit_pad_$send (infop, Ack_packet, null (), 0, kti.sequence_n, chars_sent, packet_size, ec);
	     packet_type = "";
	     call kermit_pad_$receive (infop, packet_type, remote_datap, Max_remote_packet_size, packet_n, chars_received,
		packet_size, eol_split, ec);
	end;
	return;
     end verify_receipt;

     end kermit_receive_;
