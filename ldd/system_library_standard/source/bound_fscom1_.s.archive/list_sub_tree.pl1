/****^  ********************************************
        *                                          *
        * Copyright, (C) Honeywell Bull Inc., 1988 *
        *                                          *
        ******************************************** */


/****^  HISTORY COMMENTS:
  1) change(88-09-20,GDixon), approve(88-09-20,MCR8008),
     audit(88-10-07,Beattie), install(88-10-10,MR12.2-1159):
      A) Rewritten to use fs_star_ for searching/selecting of entries to be
         listed.
      B) Added many new control arguments.
                                                   END HISTORY COMMENTS */


list_sub_tree:
lst:
    procedure;

dcl  1 auto_hd			aligned auto,	/* AUTOMATIC			 */
       2 args,
         3 archive			bit(1) aligned,
         3 debug			bit(1) aligned,
         3 depth			fixed bin,
         3 inaee			bit(1) aligned,
         3 length			bit(1) aligned,
         3 names			bit(1) aligned,
         3 selection		bit(1) aligned,
         3 total			bit(1) aligned,
         3 total_only		bit(1) aligned,
         3 type			bit(1) aligned,
       2 subtree,
         3 error			bit(1) aligned,
         3 lengths			fixed bin(35),
       2 last_ent,
         3 depth			fixed bin,
         3 path			char(168),
         3 type			char(32),
         3 uids			(15) bit(36) aligned,
       2 ext_ent,
         3 type			(19) char(32) unal,
         3 count			(19) fixed bin,
         3 lengths			(19) fixed bin(35);

dcl  code				fixed bin(35) auto;
dcl  hdP				ptr auto;
dcl  max_lineL			fixed bin auto;
dcl  pathX			fixed bin auto;
dcl  typeX			fixed bin auto;

						/* BASED				 */
dcl  1 hd				aligned like auto_hd based (hdP);

						/* BUILTINS			 */
dcl (addr, after, before, bin, char, copy, divide, hbound, index, lbound, length, ltrim, max, min, 
     null, rtrim, search, substr, sum)
				builtin;

dcl  cleanup			condition;	/* CONDITIONS			 */

						/* CONSTANTS			 */
dcl  ALT_ENTRY_TYPES		(9) char(12) int static options(constant) init(
				"lk", "seg", "dir", "ms_file", "ms_comp", "dm_file",
				"arch", "arch_comp", "unkn");
dcl (TYPE_LINK			init(1),
     TYPE_SEGMENT			init(2),
     TYPE_DIRECTORY			init(3),
     TYPE_MSF			init(4),
     TYPE_MSF_COMP			init(5),
     TYPE_DM_FILE			init(6),
     TYPE_ARCHIVE			init(7),
     TYPE_ARCHIVE_COMP		init(8)) fixed bin int static options(constant);
dcl (FALSE			init("0"b),
     TRUE				init("1"b)) bit(1) int static options(constant);
dcl  LST_ENTRY_TYPES		(9) char(8) int static options(constant) init(
				"lk", "sm", "dr", "msf", "msf_comp", "dmf",
				"ac", "ac_comp", "unkn");
dcl  ME				init("list_sub_tree") char(13) int static options(constant);
dcl  PRINT_ENTRY_TYPES		(9) char(9) int static options(constant) init(
				"      lk", "      sm", "      dr", "     msf", "msf_comp", 
				"     dmf", "      ac", " ac_comp", "    unkn");
dcl  SPACES			char(100) int static options(constant) init("");

						/* ENTRIES			 */
dcl  convert_status_code_		entry (fixed bin(35), char(8) aligned, char(100) aligned);
dcl  fs_star_$adjust_structure_size	entry (ptr, char(*), char(8), fixed bin, fixed bin(35));
dcl  fs_star_$init			entry (ptr, char(*), char(*), char(8), ptr, fixed bin(35));
dcl  fs_star_$select		entry (ptr, ptr, fixed bin(35));
dcl  fs_star_$term			entry (ptr);
dcl  expand_pathname_		entry (char(*), char(*), char(*), fixed bin(35));
dcl  get_line_length_$switch		entry (ptr, fixed bin(35)) returns(fixed bin);
dcl  get_wdir_			entry() returns(char(168));
dcl  hcs_$get_uid_file		entry (char(*), char(*), bit(36) aligned, fixed bin(35));
dcl  hcs_$quota_read		entry (char(*), fixed bin(18), fixed bin(71), bit(36) aligned,
				     bit(36), fixed bin(1), fixed bin(18), fixed bin(35));
dcl  hcs_$status_			entry (char(*), char(*), fixed bin(1), ptr, ptr,
				     fixed bin(35));
dcl  ioa_				entry() options(variable);
dcl  pathname_			entry (char(*), char(*)) returns(char(168));
dcl  pathname_$component		entry (char(*), char(*), char(*)) returns(char(194));

						/* EXTERNAL STATIC			 */
dcl (error_table_$bad_opt,
     error_table_$no_s_permission,
     error_table_$root
     )				fixed bin(35) ext static;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* OVERVIEW of OPERATION:								 */
/* 1) Establish cleanup handler.							 */
/* 2) Initialize command interface and argument processing.					 */
/* 3) Process input arguments.  Call fs_star_$init to obtain place to store input arguments.	 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

    call CLEANUP_init();
    on cleanup call CLEANUP();

    call ARG_initialization (ME, "1.0", ALLOW_COMMAND, exit_proc);
    call ARGS_init();

    call ARGS_process();
    star_options.path_allow = PATH_ALLOW_NONDIR_STAR_NAMES;
    if hd.args.depth ^= 1 then
       star_options.entry_type.dirs, star_options.entry_type.msfs =
	ENTRY_RETURN | ENTRY_LIST_SUBENTRIES;
    if hd.args.archive then do;
       do pathX = lbound(star_paths.value,1) to star_paths.count
	while  (index (star_paths.value(pathX), "::") > 0);
	end;
       if EXTENDED_TYPE_archive_given() then		/* -slet ac given; return archives.	 */
	star_options.entry_type.archives = ENTRY_RETURN | ENTRY_LIST_SUBENTRIES;
       else if pathX > star_paths.count then do;		/* all paths are archive pathnames	 */
						/*  so only return the components.	 */
	star_options.entry_type.archives = ENTRY_DONT_RETURN | ENTRY_LIST_SUBENTRIES;
	hd.args.selection = TRUE;
	end;
       else					/* otherwise return both archives & comps*/
	star_options.entry_type.archives = ENTRY_RETURN | ENTRY_LIST_SUBENTRIES;
       end;
    if hd.args.inaee then do;
       star_options.entry_type.dirs = star_options.entry_type.dirs | ENTRY_INAEE;
       star_options.entry_type.segs = star_options.entry_type.segs | ENTRY_INAEE;
       end;
    star_options.handler = HANDLER;
    star_options.error = ERROR_ROUTINE;
    star_options.handler_dataP = addr(hd);

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* OVERVIEW of OPERATION (continued):							 */
/* 4) Call fs_star_$select to perform processing of subtrees.				 */
/* 5) If processing was successful, summarize its results briefly or in detail.			 */
/* 6) Cleanup and exit.								 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

    call fs_star_$select (star_optionsP, star_dataP, code);

    if code = 0 then do;
       if (hd.last_ent.type = ENTRY_TYPE_DIRECTORY |	/* If prior entry was a dir, and it is	 */
						/*  empty, say that.  Same for archives	 */
						/*  if we are searching them.		 */
         ((hd.last_ent.type = ENTRY_TYPE_ARCHIVE) & hd.args.archive)) & 
         (hd.args.depth>hd.last_ent.depth) & ^hd.args.selection then
	call ioa_ ("^[^vt^;^s^]^[^vt^;^s^]^v(   ^)<EMPTY>", hd.args.type, length(typ)+1,
	   hd.args.length, length(len)+1+bin(hd.args.type,1)*length(typ), hd.last_ent.depth);

       if (star_data.matched.total > 0) & (hd.args.total | hd.args.total_only) then do;
	call ioa_("");
	call TOTAL_print_init ("      ", "count:", "pages:");
	call TOTAL_print	  ("      ", "count:", "pages:",
	   "TOTAL",      star_data.matched.total,      hd.subtree.lengths);
	call TOTAL_print	  ("      ", "count:", "pages:",
	   "SEGMENTS",   star_data.matched.segs,       hd.ext_ent.lengths(TYPE_SEGMENT));
	call TOTAL_print	  ("      ", "count:", "pages:",
	   "ARCHIVES",   star_data.matched.archives,   hd.ext_ent.lengths(TYPE_ARCHIVE));
	call TOTAL_print	  ("      ", "count:", "pages:",
	   "ARCH_COMPS", star_data.matched.arch_comps, hd.ext_ent.lengths(TYPE_ARCHIVE_COMP));
	call TOTAL_print	  ("      ", "count:", "pages:",
	   "LINKS",      star_data.matched.links,      hd.ext_ent.lengths(TYPE_LINK));
	call TOTAL_print	  ("      ", "count:", "pages:",
	   "DIRS",       star_data.matched.dirs,       hd.ext_ent.lengths(TYPE_DIRECTORY));
	call TOTAL_print	  ("      ", "count:", "pages:",
	   "MSFS",       star_data.matched.msfs,       hd.ext_ent.lengths(TYPE_MSF));
	call TOTAL_print	  ("      ", "count:", "pages:",
	   "MSF_COMPS",  star_data.matched.msf_comps,  hd.ext_ent.lengths(TYPE_MSF_COMP));
	call TOTAL_print	  ("      ", "count:", "pages:",
	   "DM_FILES", star_data.matched.dm_files,     hd.ext_ent.lengths(TYPE_DM_FILE));
	if hd.ext_ent.type(hbound(STANDARD_ENTRY_TYPES,1)+1) ^= "" then do;
	   do typeX = hbound(STANDARD_ENTRY_TYPES,1)+1 to hbound(hd.ext_ent.type,1)
	      while (hd.ext_ent.type(typeX) ^= "");
	      call TOTAL_print  ("EXTENDED", "ENTRIES ", " pages: ",
	         hd.ext_ent.type(typeX), hd.ext_ent.count(typeX), hd.ext_ent.lengths(typeX));
	      end;
	   call TOTAL_print_end ("EXTENDED", "ENTRIES ", " pages: ");
	   end;
	else
	   call TOTAL_print_end ("      ", "count:", "pages:");
	end;
       else
	call ioa_ ("^[^/^]^d ^[entries^;entry^] found^[, ^d total pages^;^s^].",
	   star_data.matched.total > 0, star_data.matched.total, star_data.matched.total ^= 1,
	   (star_data.matched.total > 0) & hd.args.length, hd.subtree.lengths);
       end;

EXIT:
    call CLEANUP();
    return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* EXIT PROCEDURE:									 */
/* 1) This procedure is called by ssu_$abort_subsystem when ERR_fatal is called to report a fatal	 */
/*    error.									 */
/* 2) It does a non-local goto to the EXIT label to stop execution of the command.		 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

exit_proc:
    proc;
    go to EXIT;
    end exit_proc;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* ARGUMENT PROCESSING:								 */
/*   Declare variables and subroutines needed for argument processing.  This is a general argument	 */
/*   processing package that can be shared among many programs.				 */
/*										 */
/* SEE ARGUMENT PROCESSING PROGRAMS:							 */
/*   ARG_initialization, ARG_get, ARG_get_numeric_operand, ARG_get_extra_operand, ARG_get_operand,	 */
/*   ARG_remaining_arg_count								 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

dcl (afS				bit(1) aligned,	/* on: called as an active function	 */
     argL				fixed bin(21),	/* current argument length		 */
     argN				fixed bin,	/* arg count			 */
     argP				ptr,
     argX				fixed bin,	/* arg index			 */
     opL				fixed bin(21),	/* control argument operand		 */
     opP				ptr,
     retL				fixed bin(21),	/* af return value			 */
     retP				ptr,
     sciP				ptr) auto;	/* ssu_ info ptr			 */

dcl  arg				char(argL) based(argP),
     op				char(opL) based(opP),
     ret				char(retL) varying based(retP);

dcl  ssu_$abort_subsystem		entry() options(variable),
     ssu_$arg_ptr			entry (ptr, fixed bin, ptr,
				     fixed bin(21)),
     ssu_$destroy_invocation		entry (ptr),
     ssu_$print_message		entry() options(variable),
     ssu_$return_arg		entry (ptr, fixed bin, bit(1) aligned,
				     ptr, fixed bin(21)),
     ssu_$standalone_invocation	entry (ptr, char(*), char(*), ptr,
				     entry, fixed bin(35));

dcl (ALLOW_COMMAND			init(1),
     ALLOW_AF			init(2),
     ALLOW_COMMAND_AF		init(3)) fixed bin int static
				     options(constant);

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* ARG_initialization:								 */
/* 1) Initialize error handling subroutines.						 */
/* 2) Determine whether invoked as command or af.						 */
/* 3) Is this type of invocation allowed?						 */
/* 4) Initialize af return argument, and index of current argument.				 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

ARG_initialization:
    proc (caller, version, allowed, exit_procedure);

dcl  caller			char(*) parm,
     version			char(*) parm,
     allowed			fixed bin parm,
     exit_procedure			entry parm;

dcl  code				fixed bin(35) auto;

dcl  com_err_			entry() options(variable),
     cu_$arg_list_ptr		entry returns(ptr);

dcl (error_table_$active_function,
     error_table_$not_act_fnc)	fixed bin(35) ext static;

    call ssu_$standalone_invocation (sciP, caller, version,
       cu_$arg_list_ptr(), exit_procedure, code);
    if code ^= 0 then do;
       call com_err_ (code, caller,
	"Error creating standalone ssu_ invocation.");
       call exit_procedure();
       end;

    call ERR_init();
    call ssu_$return_arg (sciP, argN, afS, retP, retL);
    if allowed = ALLOW_COMMAND & afS then
       call ERR_fatal (sciP, error_table_$active_function);
    else if allowed = ALLOW_AF & ^afS then
       call ERR_fatal (sciP, error_table_$not_act_fnc);
    else if allowed = ALLOW_COMMAND_AF then;
    if afS then
       ret = "";
    argX = 0;
    end ARG_initialization;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* ARG_get:									 */
/*   Gets the next argument from arg list.  Returns TRUE if an argument is available, FALSE if the	 */
/*   argument list is exhausted.							 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

ARG_get:
    proc returns (bit(1));

dcl (FALSE			init("0"b),
     TRUE				init("1"b))
				bit(1) int static options(constant);

    if argX < argN then do;
       argX = argX + 1;
       call ssu_$arg_ptr (sciP, argX, argP, argL);
       return (TRUE);
       end;
    else
       return (FALSE);
    end ARG_get;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* ARG_get_extra_operand:								 */
/* 1) Get an optional control arg operand.  An argument beginning with a minus (-) or contains       */
/*    < or > chars is assumed to be a subsequent control argument or a positional pathname, rather	 */
/*    than an operand.								 */
/* 2) Returns TRUE if an extra operand is found.						 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

ARG_get_extra_operand:
    proc () returns (bit(1));

dcl (FALSE			init("0"b),
     TRUE				init("1"b))
				bit(1) int static options(constant);

    if argX < argN then do;
       argX = argX + 1;
       call ssu_$arg_ptr (sciP, argX, opP, opL);
       if (index(op, "-") = 1) | (search(op,"<>") > 0) then do;
	argX = argX - 1;				/* Exclude control args and pathnames	 */
	return (FALSE);				/*  from being treated as extra operands.*/
	end;
       else
	return (TRUE);
       end;
    else
       return (FALSE);

    end ARG_get_extra_operand;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* ARG_get_numeric_operand:								 */
/* 1) Parg is name of control argument whose operand is to be obtained.			 */
/* 2) If operand is optional, Pdescription is a null string.				 */
/*    If operand is required, Pdescription is used in an error message to describe missing operand.	 */
/* 3) If operand is optional, default_value is the default value that will be returned.  The	 */
/*    constant NO_DEFAULT_VALUE can be used to specify that there is no default value.		 */
/* 4) allowed_values is an array of accepted values.  It can be NO_ALLOWED_VALUES to specify that	 */
/*    there is no restriction on the acceptable value; POSITIVE_VALUES to specify values > 0; or	 */
/*    NONNEGATIVE_VALUES to specify values >= 0.						 */
/* 5) Returns TRUE if a numeric operand was found, with operand value in num_op integer.		 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

dcl  num_op			fixed bin(35);
dcl  NO_DEFAULT_VALUE		fixed bin(35) int static options(constant) init(-34359738368);
dcl  NO_ALLOWED_VALUES		(1) fixed bin(35) int static options(constant) init(
				-34359738368);	/* -34359738368 is -2**35, the largest 	 */
						/*  negative integer.		 */
dcl  POSITIVE_VALUES		(2) fixed bin(35) int static options(constant) init(
				1, 34359738367);	/*  34359738367 is 2**35-1, the largest	 */
						/*  positive integer.		 */
dcl  NONNEGATIVE_VALUES		(2) fixed bin(35) int static options(constant) init(
				0, 34359738367);

ARG_get_numeric_operand:
    proc (Parg, Pdescription, Pdefault_value, Pallowed_values) returns (bit(1));

dcl  Parg				char(*) parm,
     Pdescription			char(*) parm,
     Pdefault_value			fixed bin(35) parm,
     Pallowed_values		(*) fixed bin(35) parm;

dcl  valX				fixed bin auto;

dcl (convert, dim, hbound, lbound)	builtin;

dcl (conversion, size)		condition;

dcl (FALSE			init("0"b),
     TRUE				init("1"b)) bit(1) int static options(constant),
    (error_table_$bad_arg,
     error_table_$noarg)		fixed bin(35) ext static;

    if Pdefault_value ^= NO_DEFAULT_VALUE & Pdescription = "" then
       num_op = Pdefault_value;

    if argX < argN then do;
       argX = argX + 1;
       call ssu_$arg_ptr (sciP, argX, opP, opL);
       on conversion, size begin;
	if index(op,"-") = 1 & Pdescription = "" then do;	/* If operand optional and it begins	 */
	   argX = argX - 1;				/*  with -, assume it is ctl arg.  Save	 */
	   num_op = Pdefault_value;			/*  it for later, and return the default */
	   go to USE_DEFAULT_VALUE;			/*  value.			 */
	   end;
	else if dim(Pallowed_values,1) = dim(POSITIVE_VALUES,1) then 
	   if Pallowed_values(hbound(Pallowed_values,1)) = NONNEGATIVE_VALUES(2) then
	      go to BAD_RANGE;
	   else
	      go to BAD_OPT;
	else
	   go to BAD_OPT;
	end;
       num_op = convert (num_op, op);
       revert conversion, size;

       if dim(Pallowed_values,1) = 1 & Pallowed_values(1) = NO_ALLOWED_VALUES(1) then;
       else if dim(Pallowed_values,1) = dim(POSITIVE_VALUES,1) then do;
	if Pallowed_values(hbound(Pallowed_values,1)) = POSITIVE_VALUES(2) then do;
	   if Pallowed_values(1) <= num_op & num_op <= Pallowed_values(2) then;
	   else do;
BAD_RANGE:      call ERR (sciP, error_table_$bad_arg, "^a ^a
^a must be followed by a ^[positive^;nonnegative^] ^a.^[
Default value is:^- ^d^;^s^]",
	         Parg, op, Parg, Pallowed_values(1)=1, Pdescription, 
	         Pdefault_value ^= NO_DEFAULT_VALUE, Pdefault_value);
	      return (FALSE);
	      end;
	   end;
	else go to TEST_ARRAY;
	end;
       else do;					/* Compare with allowed values, if any.	 */
TEST_ARRAY:
	do valX = lbound(Pallowed_values,1)
	       to hbound(Pallowed_values,1)
	   while (num_op ^= Pallowed_values(valX));
	   end;
	if valX > hbound(Pallowed_values,1) then do;
BAD_OPT:	   call ERR (sciP, error_table_$bad_arg,
	      "^a ^a
^a must be followed by a^[n^] ^a.^[
Default value is:^- ^d^;^s^]^[
Allowed ^[value is^;values are^]:^-^( ^d^)^]",
	      Parg, op, Parg, ARG_vowel(Pdescription), Pdescription, 
	      Pdefault_value ^= NO_DEFAULT_VALUE, Pdefault_value,
	      ^(dim(Pallowed_values,1)=1 & Pallowed_values(1)=NO_ALLOWED_VALUES(1)),
	      dim(Pallowed_values,1)=1, Pallowed_values);
	   return (FALSE);
	   end;
	end;
       end;

    else if Pdescription ^= "" then do;
       call ERR (sciP, error_table_$noarg,
	"^/^a must be followed by a^[n^] ^a.^[
Default value is:^- ^d^;^s^]^[
Allowed ^[value is^;values are^]:^-^( ^d^)^]", Parg,
	ARG_vowel(Pdescription), Pdescription,
	Pdefault_value ^= -1, Pdefault_value,
	^(dim(Pallowed_values,1)=1 & Pdefault_value=Pallowed_values(1)),
	dim(Pallowed_values,1)=1, Pallowed_values);
       return (FALSE);
       end;

USE_DEFAULT_VALUE:
    return (TRUE);
    end ARG_get_numeric_operand;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* ARG_get_operand:									 */
/* 1) ctl_arg is name of control argument whose operand is to be obtained.			 */
/* 2) If operand is optional, description is a null string.					 */
/*    If operand is required, description is used in error message to describe the missing operand.	 */
/* 3) Returns TRUE if an operand is found, with the value in op.				 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

ARG_get_operand:
    proc (ctl_arg, description) returns (bit(1));

dcl  ctl_arg			char(*) parm,
     description			char(*) parm;

dcl  error_table_$noarg		fixed bin(35) ext static;

dcl (FALSE			init("0"b),
     TRUE				init("1"b))
				bit(1) int static options(constant);

    if argX < argN then do;
       argX = argX + 1;
       call ssu_$arg_ptr (sciP, argX, opP, opL);
       return (TRUE);
       end;
    else do;
       if description ^= "" then
	call ERR (sciP, error_table_$noarg,
	"^a requires a^[n^] ^a operand.", ctl_arg, ARG_vowel(description),
	description);
       return (FALSE);
       end;

    end ARG_get_operand;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* ARG_remaining_arg_count:								 */
/*   Returns the number of unprocessed arguments.						 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

ARG_remaining_arg_count:
    procedure returns (fixed bin);
    return (max(0, argN - argX));
    end ARG_remaining_arg_count;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* ARG_vowel:									 */
/* 1) returns true if str begins with a vowel, false otherwise.				 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

ARG_vowel:
    proc (str) returns (bit(1));

dcl  str				char(*) parm;

dcl (search, substr)		builtin;

dcl (FALSE			init("0"b),
     TRUE				init("1"b))
				bit(1) int static options(constant);

    if search ("aeiouAEIOU", substr(str,1,1)) > 0 then
       return (TRUE);
    else
       return (FALSE);

    end ARG_vowel;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */










/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* ARGUMENT PROCESSING FOR list_sub_tree:						 */
/*   Routines with the ARGS_ prefix process the particular arguments accepted by the lst command.	 */
/*   Routines involved include:							 */
/*										 */
/*     ARGS_init, ARGS_process							 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* ARGS_init:									 */
/* 1) Call fs_star_$init to initialize fs_star_.						 */
/* 2) Initialize argument-holding handler data structure, hd.				 */
/* 3) Get terminal line length for use in formatting output.				 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

ARGS_init:
    proc;

dcl  code				fixed bin(35) auto;
dcl  typeX			fixed bin auto;

    call fs_star_$init (sciP, "", "", STAR_OPTIONS_VERSION_1, star_optionsP, code);
    call ERR_fatal (sciP, code, "Calling fs_star_$init.");

    hdP = addr(auto_hd);
    hd.args.archive = FALSE;
    hd.args.debug = FALSE;
    hd.args.depth = 99;
    hd.args.inaee = FALSE;
    hd.args.length = TRUE;
    hd.args.names = FALSE;
    hd.args.selection = FALSE;
    hd.args.total = TRUE;
    hd.args.total_only = FALSE;
    hd.args.type = TRUE;

    hd.subtree.error = FALSE;
    hd.subtree.lengths = 0;

    hd.last_ent.depth = 0;
    hd.last_ent.path = "";
    hd.last_ent.type = ENTRY_TYPE_UNSET;
    hd.last_ent.uids(*) = "0"b;

    hd.ext_ent.type(*) = "";
    hd.ext_ent.count(*) = 0;
    hd.ext_ent.lengths(*) = 0;
    do typeX = lbound(STANDARD_ENTRY_TYPES,1) to hbound(STANDARD_ENTRY_TYPES,1);
       hd.ext_ent.type(typeX) = STANDARD_ENTRY_TYPES(typeX);
       end;

    max_lineL = get_line_length_$switch (null, code);
    call EXTENDED_TYPE_init();
    end ARGS_init;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
										 
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* ARGS_process:									 */
/* 1) Loop through all input arguments, storing them in the handler data structure (hd),		 */
/*    star_options and star_paths structures, etc.					 */
/* 2) Apply argument defaults.							 */
/* 3) If errors occur, diagnose them and exit lst.					 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

ARGS_process:
    proc;

dcl  archive_set			bit(1) aligned auto;
dcl  inaee_set			bit(1) aligned auto;
dcl  pathX			fixed bin auto;

    archive_set = FALSE;
    inaee_set = FALSE;
    do while (ARG_get());
       if index(arg, "-") = 1 then do;
	if arg = "-archives" | arg = "-archive" | arg = "-ac" then do;
	   hd.args.archive = TRUE;
	   archive_set = TRUE;
	   end;
	else if arg = "-no_archives" | arg = "-no_archive" | arg = "-nac" then do;
	   hd.args.archive = FALSE;
	   archive_set = TRUE;
	   end;

	else if arg = "-debug" | arg = "-db" then
	   hd.args.debug = TRUE;
	else if arg = "-no_debug" | arg = "-ndb" then
	   hd.args.debug = FALSE;

	else if arg = "-depth" | arg = "-dh" then do;
	   if ARG_get_numeric_operand (arg, "maximum subtree depth to scan",
	      NO_DEFAULT_VALUE, POSITIVE_VALUES) then
	      hd.args.depth = num_op + 1;
	   end;

	else if arg = "-exclude" | arg = "-ex" then do;
	   if ARG_get_operand (arg, "star name") then do;
	      if star_options.exclude_namesP = null then do;
	         exclude_names_size = ARG_remaining_arg_count() + 1;
	         call fs_star_$adjust_structure_size (star_optionsP, "exclude_names",
		  STAR_EXCLUDE_NAMES_VERSION_1, exclude_names_size, code);
	         call ERR_fatal (sciP, code, "^/Allocating exclude_names structure with ^d elements.",
		  exclude_names_size);
	         end;
	      exclude_names.count = exclude_names.count + 1;
	      exclude_names.value (exclude_names.count) = op;
	      do while (ARG_get_extra_operand());
	         exclude_names.count = exclude_names.count + 1;
	         exclude_names.value (exclude_names.count) = op;
	         end;
	      end;
	   end;
	else if arg = "-no_exclude" | arg = "-nex" then do;
	   if star_options.exclude_namesP ^= null then
	      exclude_names.count = 0;
	   end;

	else if arg = "-interpret_as_extended_entry" | arg = "-inaee" then do;
	   hd.args.inaee = TRUE;
	   inaee_set = TRUE;
	   end;
	else if arg = "-interpret_as_standard_entry" | arg = "-inase" then do;
	   hd.args.inaee = FALSE;
	   inaee_set = TRUE;
	   end;

	else if arg = "-length" | arg = "-ln" then 
	   hd.args.length = TRUE;
	else if arg = "-no_length" | arg = "-nln" then 
	   hd.args.length = FALSE;

	else if arg = "-match" then do;
	   if ARG_get_operand (arg, "star name") then do;
	      if star_options.match_namesP = null then do;
	         match_names_size = ARG_remaining_arg_count() + 1;
	         call fs_star_$adjust_structure_size (star_optionsP, "match_names",
		  STAR_MATCH_NAMES_VERSION_1, match_names_size, code);
	         call ERR_fatal (sciP, code, "^/Allocating match_names structure with ^d elements.",
		  match_names_size);
	         end;
	      match_names.count = match_names.count + 1;
	      match_names.value (match_names.count) = op;
	      do while (ARG_get_extra_operand());
	         match_names.count = match_names.count + 1;
	         match_names.value (match_names.count) = op;
	         end;
	      end;
	   end;
	else if arg = "-no_match" | arg = "-nmatch" then do;
	   if star_options.match_namesP ^= null then
	      match_names.count = 0;
	   end;

	else if arg = "-names" | arg = "-name" | arg = "-nm" | arg = "-all" | arg = "-a" then
	   hd.args.names = TRUE;
	else if arg = "-no_names" | arg = "-no_name" | arg = "-nnm" then
	   hd.args.names = FALSE;

	else if arg = "-select_entry_type" | arg = "-slet" then do;
	   if ARG_get_operand (arg, "entry type selector") then do;
	      if star_options.extended_entry_typesP = null then do;
	         extended_entry_types_size = ARG_remaining_arg_count() + 1;
	         call fs_star_$adjust_structure_size (star_optionsP, "extended_entry_types",
		  STAR_EXTENDED_ENTRY_VERSION_1, extended_entry_types_size, code);
	         call ERR_fatal (sciP, code,
		  "^/Allocating extended_entry_types structure with ^d elements.",
		  extended_entry_types_size);
	         end;
	      call EXTENDED_TYPE(op);
	      do while (ARG_get_extra_operand());
	         call EXTENDED_TYPE(op);
	         end;
	      end;
	   end;
	else if arg = "-no_select_entry_type" | arg = "-nslet" then do;
	   if star_options.extended_entry_typesP ^= null then
	      extended_entry_types.count = 0;
	   call EXTENDED_TYPE_init();
	   end;

	else if arg = "-totals" | arg = "-total" | arg = "-tt" then
	   hd.args.total = TRUE;
	else if arg = "-no_totals" | arg = "-no_total" | arg = "-ntt" then
	   hd.args.total = FALSE;

	else if arg = "-totals_only" | arg = "-total_only" | arg = "-tto" then
	   hd.args.total_only = TRUE;
	else if arg = "-no_totals_only" | arg = "-no_total_only" | arg = "-ntto" then
	   hd.args.total_only = FALSE;

	else if arg = "-types" | arg = "-type" | arg = "-tp" then 
	   hd.args.type = TRUE;
	else if arg = "-no_types" | arg = "-no_type" | arg = "-ntp" then 
	   hd.args.type = FALSE;

	else
	   call ERR (sciP, error_table_$bad_opt, arg);
	end;

       else do;
	if star_paths.count >= hbound(star_paths.value,1) then do;
	   call fs_star_$adjust_structure_size (star_optionsP, "star_paths", STAR_PATHS_VERSION_1,
	      hbound(star_paths.value,1) + 10, code);
	   call ERR (sciP, code,
	      "Calling fs_star_$adjust_structure_size to increase star_paths array size to ^d.",
	      hbound(star_paths.value,1) + 10);
	   end;
	star_paths.count = star_paths.count + 1;
	star_paths.value (star_paths.count) = arg;
	end;
       end;

    if star_paths.count = 0 then do;
       star_paths.count = 1;
       star_paths.value(1) = get_wdir_();
       end;

    if ^archive_set then do;
       do pathX = lbound(star_paths.value,1) to star_paths.count;
	if index (star_paths.value(pathX), "::") > 0 then
	   hd.args.archive = TRUE;
	end;
       if EXTENDED_TYPE_archive_comp_given() then
	hd.args.archive = TRUE;
       end;
    if ^inaee_set then
       hd.args.inaee = EXTENDED_TYPE_given();

    if star_options.exclude_namesP ^= null then
       if exclude_names.count > 0 then
          hd.args.selection = TRUE;
    if star_options.match_namesP ^= null then
       if match_names.count > 0 then
          hd.args.selection = TRUE;
    if star_options.extended_entry_typesP ^= null then
       if extended_entry_types.count > 0 then
          hd.args.selection = TRUE;

    if ERR_occurred() then
       go to EXIT;
    end ARGS_process;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* CLEANUP:									 */
/* 1) Terminate fs_star_ processing.							 */
/* 2) Destroy ssu_ invocation created to process arguments.					 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

CLEANUP:
    proc;

    call fs_star_$term (star_optionsP);
    call ssu_$destroy_invocation (sciP);

    end CLEANUP;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* CLEANUP_init:									 */
/* 1) Initialize variables referenced by CLEANUP handler above.				 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

CLEANUP_init:
    proc;

    star_optionsP = null;
    sciP = null;

    end CLEANUP_init;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* EXTENDED_TYPE:									 */
/*   This procedure converts traditional entry types (eg, directory or dr) to fs_star_		 */
/*   STANDARD_ENTRY_TYPES and stores them in the extended_entry_types structure.		 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

EXTENDED_TYPE:
    procedure (Ptypes);
    
dcl  Ptypes			char(*) parm;

dcl  standard_type			bit(1) aligned auto;
dcl  type				char(32) auto;
dcl  types			char(1000) varying auto;

    types = ltrim(rtrim(Ptypes));
    do while (types ^= "");
       standard_type = FALSE;
       type = before(types, ",");
       types = after(types, ",");

       do typeX = lbound(STANDARD_ENTRY_TYPES,1) to hbound(STANDARD_ENTRY_TYPES,1);
	if substr(STANDARD_ENTRY_TYPES(typeX),2) = type &
	   substr(STANDARD_ENTRY_TYPES(typeX),1,length("-")) = "-" then do;
	   type = STANDARD_ENTRY_TYPES(typeX);
	   standard_type = TRUE;
	   if typeX = TYPE_ARCHIVE then
	      archive_type_found = TRUE;
	   else if typeX = TYPE_ARCHIVE_COMP then
	      archive_comp_type_found = TRUE;
	   end;
	end;

       do typeX = lbound(LST_ENTRY_TYPES,1) to hbound(LST_ENTRY_TYPES,1);
	if LST_ENTRY_TYPES(typeX) = type then do;
	   type = STANDARD_ENTRY_TYPES(typeX);
	   standard_type = TRUE;
	   if typeX = TYPE_ARCHIVE then
	      archive_type_found = TRUE;
	   else if typeX = TYPE_ARCHIVE_COMP then
	      archive_comp_type_found = TRUE;
	   end;
	end;

       do typeX = lbound(ALT_ENTRY_TYPES,1) to hbound(ALT_ENTRY_TYPES,1);
	if ALT_ENTRY_TYPES(typeX) = type then do;
	   type = STANDARD_ENTRY_TYPES(typeX);
	   standard_type = TRUE;
	   if typeX = TYPE_ARCHIVE then
	      archive_type_found = TRUE;
	   else if typeX = TYPE_ARCHIVE_COMP then
	      archive_comp_type_found = TRUE;
	   end;
	end;

       if ^standard_type then
	extended_types_found = TRUE;

       if extended_entry_types.count >= extended_entry_types.max_count then do;
	extended_entry_types_size = extended_entry_types.max_count + 10;
	call fs_star_$adjust_structure_size (star_optionsP, "extended_entry_types",
	   STAR_EXTENDED_ENTRY_VERSION_1, extended_entry_types_size, code);
	call ERR_fatal (sciP, code, "^/Allocating extended_entry_types structure with ^d elements.",
	   extended_entry_types_size);
	end;
       extended_entry_types.count = extended_entry_types.count + 1;
       extended_entry_types.value (extended_entry_types.count) = type;
       end;
    end EXTENDED_TYPE;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* EXTENDED_TYPE_init:								 */
/*    This procedure initializes the flags which record whether any of the types given to -slet are	 */
/* not standard entry types.								 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

dcl  archive_comp_type_found		bit(1) aligned auto;
dcl  archive_type_found		bit(1) aligned auto;
dcl  extended_types_found		bit(1) aligned auto;

EXTENDED_TYPE_init:
    procedure();

    archive_comp_type_found = FALSE;
    archive_type_found = FALSE;
    extended_types_found = FALSE;

    return;
    


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* EXTENDED_TYPE_archive_comp_given:							 */
/*    This functions returns TRUE is any of the types given to -slet are not standard entry types..	 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

EXTENDED_TYPE_archive_comp_given:
    entry() returns (bit(1) aligned);

    return (archive_comp_type_found);


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* EXTENDED_TYPE_archive_given:							 */
/*    This functions returns TRUE is any of the types given to -slet are not standard entry types..	 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

EXTENDED_TYPE_archive_given:
    entry() returns (bit(1) aligned);

    return (archive_type_found);


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* EXTENDED_TYPE_given:								 */
/*    This functions returns TRUE is any of the types given to -slet are not standard entry types..	 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

EXTENDED_TYPE_given:
    entry() returns (bit(1) aligned);

    return (extended_types_found);

    end EXTENDED_TYPE_init;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* ERROR REPORTING ROUTINES:								 */
/* 1) Nonfatal errors set a switch, which can be tested via error_occurred function.		 */
/* 2) Fatal errors abort the subsystem by calling ssu_$abort_subsystem, which calls the main	 */
/*    procedure's exit procedure, which branches to the EXIT label to exit the command.		 */
/*										 */
/* Syntax:  call ERR (sciP, code, ioa_ctl, args);						 */
/*	  call ERR_fatal (sciP, code, ioa_ctl, args);					 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

dcl  error_occurred_sw		bit(1) auto;

ERR:
    proc options (variable);

dcl  code				fixed bin(35) based (codeP),
     codeP			ptr auto;

dcl  cu_$arg_list_ptr		entry returns(ptr),
     cu_$arg_ptr			entry (fixed bin, ptr, fixed bin(21),
				     fixed bin(35)),
     cu_$generate_call		entry (entry, ptr),
     ioa_				entry() options(variable);

dcl  CODE_ARG			fixed bin
				int static options(constant) init(2),
     TRUE				init("1"b) bit(1)
				int static options(constant);

    call cu_$arg_ptr (CODE_ARG, codeP, 0, 0);
    if code = 0 then return;
    if code = -1 then code = 0;
    error_occurred_sw = TRUE;
    call cu_$generate_call (ssu_$print_message, cu_$arg_list_ptr());
    return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

ERR_fatal:
    entry options(variable);

    call cu_$arg_ptr (CODE_ARG, codeP, 0, 0);
    if code = 0 then return;
    if code = -1 then code = 0;
    error_occurred_sw = TRUE;
    call ioa_ ("");
    call cu_$generate_call (ssu_$abort_subsystem, cu_$arg_list_ptr());

    end ERR;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* ERR_init:									 */
/*   Initialize nonfatal error processing routine flag, which records whether such an error has	 */
/*   occurred.									 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

ERR_init:
    proc;

    error_occurred_sw = FALSE;
    return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* ERR_occurred:									 */
/*   Returns TRUE if a nonfatal error has occurred.					 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

ERR_occurred:
    entry returns (bit(1));

    return (error_occurred_sw);
    end ERR_init;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* ERROR_ROUTINE:									 */
/*   This is the fs_star_ error handler, which is called whenever an error occurs while processing	 */
/*   entries in the subtree being listed.						 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

ERROR_ROUTINE:
    procedure (Pstar_dataP, Pdir, Pent, Pcomp, Pcode, Pmessage, Paction);
    
dcl  Pstar_dataP			ptr parm;		/* ptr to star_data. (In)		 */
dcl  Pdir				char(*) parm;	/* dir part of entry's pathname. (In)	 */
dcl  Pent				(*) char(32) parm;	/* entry names on entry. (In)		 */
dcl  Pcomp			char(*) parm;	/* archive component name. (In)	 */
dcl  Pcode			fixed bin(35) parm; /* status code. (In)		 */
dcl  Pmessage			char(*) parm;	/* error message. (In)		 */
dcl  Paction			fixed bin parm;	/* entry action code. (Out)		 */

dcl  action			fixed bin auto;
dcl  code				fixed bin(35) auto;
dcl  dir				char(168) auto;
dcl  ent				(1) char(32) auto;
dcl  long				char(100) aligned auto;
dcl  short			char(8) aligned auto;

    Paction = ERROR_REJECT;				/* Errant entries are rejected.	 */

    star_dataP = Pstar_dataP;				/* Access data structures, including our */
    star_optionsP = star_data.star_optionsP;		/*  handler data structure.		 */
    sciP = star_options.ssu_sciP;
    hdP = star_options.handler_dataP;

    if (hd.args.depth < star_data.entry_data.depth) then	/* -depth control arg limits error msgs	 */
       return;					/*  which get printed.		 */

    if star_data.entry_data.depth <= 1 then do;		/* error occurred prior to calling 	 */
       if star_data.matched.current > 1 then		/*  hcs_$star_ to list subtree entries.	 */
	call ioa_ ("");
       call ssu_$print_message (sciP, Pcode, "^[^a^s^;^s^a^]^[^/(^a)^]",
	  Pent(1)="", Pdir, pathname_$component (Pdir, Pent(1), Pcomp), Pmessage^="", Pmessage);
       end;

    else do;					/* error occurred on a subtree entry.	 */
       if hd.args.total_only then return;		/*  Don't report if -total_only given.	 */
       hd.subtree.error = TRUE;			/*  Let HANDLER report where we are in	 */
       if Pent(1) = "" then do;			/*   the subtree before reporting the 	 */
	if hd.last_ent.path ^= Pdir then do;		/*   error.  The .error flag tells the	 */
	   call expand_pathname_ (Pdir, dir, ent(1),code);/*   HANDLER not to put lengths in the	 */
	   star_data.depth = star_data.depth - 1;	/*   subtree location.		 */
	   call HANDLER (Pstar_dataP, dir, ent, "", action);
	   star_data.depth = star_data.depth + 1;
	   end;
	end;
       else if hd.last_ent.path ^= pathname_(Pdir, Pent(1)) then
	call HANDLER (Pstar_dataP, Pdir, Pent, Pcomp, action);
       hd.subtree.error = FALSE;

       call convert_status_code_ (Pcode, short, long);	/*  Report error against subtree entry.	 */
       call ioa_ ("^[^vt^;^s^]^[^vt^;^s^]^v(   ^)^a^[^/^[^vt^;^s^]^[^vt^;^s^]^v(   ^)(^a)^]",
	hd.args.type, length(typ)+1, hd.args.length, length(len)+1+bin(hd.args.type,1)*length(typ),
	star_data.depth-1, long, Pmessage^="", hd.args.type, length(typ)+1,
	hd.args.length, length(len)+1+bin(hd.args.type,1)*length(typ), star_data.depth-1,
	Pmessage);
       end;

    hd.last_ent.depth = star_data.entry_data.depth;	/* Avoid marking errant entries as 	 */
    hd.last_ent.type = ENTRY_TYPE_UNSET;		/* <EMPTY>.			 */

    end ERROR_ROUTINE;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* HANDLER:									 */
/*    This is the fs_star_ handler routine.  It is called to process each selected entry.		 */
/* 1) Access fs_star_ and handler data structures.					 */
/* 2) Don't print location info for entries below max hierarchy level given in -depth control arg.	 */
/* 3) Figure out entry pathname, type (as lst will report it), its entry length (in pages).	 */
/* 4) If -total_only was given, return without printing information about the entry.  Only entry	 */
/*    length has been accumulated in handler data structure.				 */
/* 5) If -match, -exclude or -slet was given, then HANDLER won't be called for every subtree level,	 */
/*    but only entries which match these selection criteria.  hd.args.selection will be TRUE in such */
/*    cases.  We must call HANDLER_depth to report missing levels before printing info about the	 */
/*    selected entry.								 */
/* 6) Then call HANDLER_depth to report information about the selected entry.			 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

dcl  len				char(5) auto;	/* length of these vars is referenced	 */
dcl  typ				char(9) auto;	/*  in one place outside HANDLER>	 */

HANDLER:
    procedure (Pstar_dataP, Pdir, Pent, Pcomp, Paction);
    
dcl  Pstar_dataP			ptr parm;		/* ptr to star_data. (In)		 */
dcl  Pdir				char(*) parm;	/* dir part of entry's pathname. (In)	 */
dcl  Pent				(*) char(32) parm;	/* entry names on entry. (In)		 */
dcl  Pcomp			char(*) parm;	/* archive component name. (In)	 */
dcl  Paction			fixed bin parm;	/* entry action code. (Out)		 */

dcl  code				fixed bin(35) auto;
dcl (common_depthI, depthI, depthN)	fixed bin auto;
dcl  dir				char(168) auto;
dcl  ent				(1) char(32) auto;
dcl  1 last_ent			aligned like auto_hd.last_ent auto;
dcl  typeX			fixed bin auto;

    Paction = HANDLER_OK;

    star_optionsP = star_data.star_optionsP;
    hdP = star_options.handler_dataP;
    if (hd.args.depth < star_data.entry_data.depth) then do;
       Paction = HANDLER_REJECT;
       return;
       end;

    do typeX = lbound(STANDARD_ENTRY_TYPES,1) to hbound(STANDARD_ENTRY_TYPES,1)
       while (star_data.entry_data.type ^= STANDARD_ENTRY_TYPES(typeX));
       end;
    if typeX > hbound(STANDARD_ENTRY_TYPES,1) then do;
       if star_data.entry_data.type = ENTRY_TYPE_UNSET then
          typ = "    ^set";
       else if length(rtrim(star_data.entry_data.type)) <= length(typ)-1 then
	typ = copy(" ",max(length(typ)-1-length(rtrim(star_data.entry_data.type)),0)) ||
	   rtrim(star_data.entry_data.type);
       else
	typ = "     ext";
       end;
    else
       typ = PRINT_ENTRY_TYPES(typeX);

    do typeX = lbound(hd.ext_ent.type,1) to hbound(hd.ext_ent.type,1)
       while (hd.ext_ent.type(typeX) ^= "" & hd.ext_ent.type(typeX) ^= star_data.entry_data.type);
       end;					/* count occurrences of each type of	 */
    if typeX <= hbound(hd.ext_ent.type,1) then do;	/*  extended entry.			 */
       hd.ext_ent.type (typeX) = star_data.entry_data.type;
       hd.ext_ent.count(typeX) = hd.ext_ent.count(typeX) + 1;
       end;

    last_ent = hd.last_ent;

    hd.last_ent.depth = star_data.entry_data.depth;
    hd.last_ent.path = pathname_ (Pdir, Pent(1));
    hd.last_ent.type = star_data.entry_data.type;
    hd.last_ent.uids(*) = ""b; 

    if hd.last_ent.type = ENTRY_TYPE_ARCHIVE_COMP then do;
       depthN = hd.last_ent.depth-1;
       dir = Pdir;
       ent = Pent(1);
       end;
    else if (hd.last_ent.type = ENTRY_TYPE_DIRECTORY) |
            (hd.last_ent.type = ENTRY_TYPE_MSF) |
            (hd.last_ent.type = ENTRY_TYPE_ARCHIVE) then do;
       depthN = hd.last_ent.depth;
       dir = Pdir;
       ent = Pent(1);
       end;
    else do;
       depthN = hd.last_ent.depth-1;
       call expand_pathname_ (Pdir, dir, ent(1), code);
       end;

    common_depthI = 0;
    do depthI = depthN to 1 by -1;
       call hcs_$get_uid_file (dir, ent(1), hd.last_ent.uids(depthI), code);
       if code = error_table_$root then
	hd.last_ent.uids(depthI) = "777777777777"b3;
       if hd.last_ent.uids(depthI) = last_ent.uids(depthI) then do;
	common_depthI = depthI;
	do depthI = depthI-1 to 1 by -1;
	   hd.last_ent.uids(depthI) = last_ent.uids(depthI);
	   end;
	end;
       else 
	call expand_pathname_ (dir, dir, ent(1), code);
       end;

    if hd.args.length then				/* If -length given, replace type with	 */
       if hd.subtree.error then			/*  an entry length (in pages).	 */
	len = "";					/* Don't report length if processing	 */
       else					/*  subtree location for an error msg.	 */
	len = ENTRY_length(typeX);
    else len = "";
    if hd.args.total_only then return;			/* For -total_only, don't print info 	 */
						/*  about specific entries.		 */

    if ^hd.args.selection then			/* We're called for EVERY subtree entry	 */
						/*  so don't have to worry about missing */
						/*  locations in the subtree.		 */
       call HANDLER_depth (hd.last_ent.depth, typ, len, Pdir, Pent, Pcomp, last_ent);
    else if hd.last_ent.depth = 1 then			/* This entry is at TOP of a subtree, 	 */
       call HANDLER_depth (1, typ, len, Pdir, Pent, Pcomp,	/*  so don't have to worry about missing */
	last_ent);				/*  locations in the subtree.		 */

    else do;					/* Call HANDLER_depth to report missing	 */
       depthN = hd.last_ent.depth;			/*  (nonselected) subtree levels prior	 */
       if Pcomp ^= "" then depthN = depthN - 1;		/*  to reporting selected entry HANDLER	 */
       do depthI = common_depthI+1 to depthN-1;		/*  was called with.		 */
	dir = pathname_ (dir, ent(1));
	ent(1) = before (after (hd.last_ent.path, rtrim(dir)||">"), ">");
	call HANDLER_depth (depthI, PRINT_ENTRY_TYPES(TYPE_DIRECTORY), "", dir, ent, "", last_ent);
	last_ent.depth = depthI;
	last_ent.type = ENTRY_TYPE_DIRECTORY;
	end;
       if (Pcomp ^= "") & (depthI < hd.last_ent.depth) then do;
	call HANDLER_depth (depthI, PRINT_ENTRY_TYPES(TYPE_ARCHIVE), "", Pdir, Pent, "", last_ent);
	last_ent.depth = depthI;
	last_ent.type = ENTRY_TYPE_ARCHIVE;
	end;
       call HANDLER_depth (star_data.entry_data.depth, typ, len, Pdir, Pent, Pcomp, last_ent);
       end;					/* Report the selected entry.		 */
    return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* HANDLER_depth:									 */
/*    Report information about a single entry in the subtree.  Before reporting about the current	 */
/*    entry, it figures out whether the prior (directory/archive) entry was empty and reports if it	 */
/*    was.  Most of the complexity comes from this Emptiness reporting.			 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

HANDLER_depth:
    procedure (Pdepth, Ptyp, Plen, Pdir, Pent, Pcomp, Plast_ent);
    
dcl  Pdepth			fixed bin parm;	/* depth below star_paths dir. (In)	 */
dcl  Ptyp				char(9) parm;	/* printable type of entry. (In)	 */
dcl  Plen				char(5) parm;	/* printable length of entry. (In)	 */
dcl  Pdir				char(*) parm;	/* dir part of entry's pathname. (In)	 */
dcl  Pent				(*) char(32) parm;	/* entry names on entry. (In)		 */
dcl  Pcomp			char(*) parm;	/* archive component name. (In)	 */
dcl  1 Plast_ent			aligned like last_ent;
						/* info about prior entry. (In)	 */

dcl (STARTING			init(1),
     NEW_SUBTREE			init(2),
     DOWN_DIR			init(3),
     ANOTHER_ENTRY			init(4),
     UP_DIR			init(5),
     NEW_ARCHIVE			init(6),
     ANOTHER_COMP			init(7)
     )				fixed bin int static options(constant);

    if Pdepth <= 1 then
       if star_data.matched.current <= 1 then
	go to PROCESS (STARTING);			/* Begin the first subtree.		 */
       else
	go to PROCESS (NEW_SUBTREE);			/* Begin another subtree.		 */

    else if Pdepth < Plast_ent.depth then
       go to PROCESS (UP_DIR);			/* End reporting on a subdir.		 */

    else if (Pdepth > Plast_ent.depth) then
       if (Pcomp = "") then
	go to PROCESS (DOWN_DIR);			/* Begin reporting on a subdir.	 */
       else
	go to PROCESS (NEW_ARCHIVE);			/* Begin reporting on archive components.*/

    else if Pcomp = "" then
       go to PROCESS (ANOTHER_ENTRY);			/* Process another subdir entry.	 */
    else
       go to PROCESS (ANOTHER_COMP);


PROCESS (NEW_SUBTREE):				/* If prior entry was a dir, and it is	 */
    if (Plast_ent.type = ENTRY_TYPE_DIRECTORY |		/*  empty, say that.  Same for archives	 */
      ((Plast_ent.type = ENTRY_TYPE_ARCHIVE) & hd.args.archive)) & (hd.args.depth>Pdepth) & 
     ^hd.args.selection then				/*  if we are searching them.		 */
       call ioa_ ("^[^vt^;^s^]^[^vt^;^s^]^v(   ^)<EMPTY>^[ NEW_SUBTREE^]",
          hd.args.type, length(typ)+1, hd.args.length, length(len)+1+bin(hd.args.type,1)*length(typ),
          Plast_ent.depth, hd.args.debug);
    call ioa_ ("");

PROCESS (STARTING):
    call ioa_ ("^[^a^vt^;^2s^]^[^a^vt^;^2s^]^a", hd.args.type, Ptyp, length(typ)+1,
       hd.args.length, Plen, length(len)+1+bin(hd.args.type,1)*length(typ),
       NAMES_output (Pdepth, pathname_ (Pdir,Pent(1))));
    return;

PROCESS (UP_DIR):
PROCESS (ANOTHER_ENTRY):				/* If prior entry was a dir, and it is	 */
    if (Plast_ent.type = ENTRY_TYPE_DIRECTORY |		/*  empty, say that.  Same for archives	 */
						/*  if we are searching them.		 */
      ((Plast_ent.type = ENTRY_TYPE_ARCHIVE) & hd.args.archive)) & (hd.args.depth>Pdepth) & 
     ^hd.args.selection then
       call ioa_ ("^[^vt^;^s^]^[^vt^;^s^]^v(   ^)<EMPTY>^[ ANOTHER_ENTRY^]",
	hd.args.type, length(typ)+1, hd.args.length, length(len)+1+bin(hd.args.type,1)*length(typ),
          Pdepth, hd.args.debug);

PROCESS (DOWN_DIR):
    call ioa_ ("^[^a^vt^;^2s^]^[^a^vt^;^2s^]^v(   ^)^a", hd.args.type, Ptyp, length(typ)+1,
       hd.args.length, Plen, length(len)+1+bin(hd.args.type,1)*length(typ), Pdepth-1, 
       NAMES_output(Pdepth, Pent(1)));
    return;

PROCESS (NEW_ARCHIVE):
PROCESS (ANOTHER_COMP):
    call ioa_ ("^[^a^vt^;^2s^]^[^a^vt^;^2s^]^v(   ^)^a", hd.args.type, Ptyp, length(typ)+1,
       hd.args.length, Plen, length(len)+1+bin(hd.args.type,1)*length(typ), Pdepth-1, Pcomp);
    return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* NAMES_output:									 */
/* 1) When -names was given, return a string containing the first name on an entry (or starting path */
/*    of a subtree), followed by comma-separated list of the other names.			 */
/* 2) When -no_names was given, just return the first name (subtree path).			 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

NAMES_output:
    procedure (Pdepth, first_name) returns (char(1000) varying);
    
dcl  Pdepth			fixed bin parm;	/* depth below star_paths dir. (In)	 */
dcl  first_name			char(*) parm;

dcl  indentL			fixed bin auto;
dcl  lineL			fixed bin auto;
dcl  name				char(32) varying auto;
dcl  names			char(1000) varying auto;
dcl  nameX			fixed bin auto;

dcl  NL				char(1) int static options(constant) init("
");

    names = rtrim(first_name);
    if ^hd.args.names then return(names);

    indentL = min(100, (length(Ptyp) * bin(hd.args.type,1)) + (length(Plen) * bin(hd.args.length,1))
       +  (3 * (Pdepth-1)) + length(" "));		/* multiple names are put as many as 	 */
    lineL = indentL + length(names);			/*  will fit on a terminal line.  	 */
    do nameX = 2 to hbound(Pent,1);			/* Subsequent lines are indented at 	 */
       name = rtrim(Pent(nameX));			/*  subtree level + 1.		 */
       if length(name) + length(", ") + lineL > max_lineL then do;
	names = names || ",";
	names = names || NL;
	names = names || substr(SPACES,1,indentL);
	lineL = indentL;
	end;
       else
	names = names || ", ";
       names = names || name;
       lineL = lineL + length(name) + length(", ");
       end;
    return (names);

    end NAMES_output;

    end HANDLER_depth;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* ENTRY_length:									 */
/* 1) Call hcs_$status_ to get length (in pages) of a particular entry.  This cannot get the length	 */
/*    of inner ring entries (eg, .mbx or .ms segments), so 0 is returned for such entries.	 */
/* 2) Also accumulate length of all entries in handler data structure.			 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

ENTRY_length:
    procedure (PtypeX) returns(char(4));
    
dcl  PtypeX			fixed bin parm;

dcl  code				fixed bin(35) auto;
dcl  digits			pic"zzz9" auto;
dcl  pages			fixed bin(35) auto;
dcl (quota, quota_used)		fixed bin(18) auto;
dcl  NO_CHASE			fixed bin(1) int static options(constant) init(0);

    if star_data.entry_data.type = ENTRY_TYPE_LINK |
       star_data.entry_data.type = ENTRY_TYPE_ARCHIVE_COMP |
       star_data.entry_data.type = ENTRY_TYPE_UNKNOWN |
       star_data.entry_data.type = ENTRY_TYPE_UNSET then
       return ("");
    call hcs_$status_ (Pdir, Pent(1), NO_CHASE, addr(status), null, code);
    if (code ^= 0) & (code ^= error_table_$no_s_permission) then
       return("");
    pages = status.records_used;
    if star_data.entry_data.type = "forum" then do;
       call hcs_$quota_read (pathname_ (Pdir, Pent(1)), quota, 0, ""b, ""b, 0, quota_used, code);
       if code = 0 then
	pages = pages + quota_used;
       end;
    hd.subtree.lengths = hd.subtree.lengths + pages;
    hd.ext_ent.lengths(PtypeX) = hd.ext_ent.lengths(PtypeX) + pages;
    digits = pages;
    return (digits);

    end ENTRY_length;

    end HANDLER;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* TOTAL_print:									 */
/*   Adds totals information about particular entry types to the pending output lines.  If the lines */
/*   overflow terminal line length, they are printed and new lines are started.			 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

dcl (line1, line2, line3)		char(160) varying auto;

TOTAL_print:
    procedure (Pprefix1, Pprefix2, Pprefix3, Ptype, Pcount, Plength);
    
dcl (Pprefix1, Pprefix2, Pprefix3)	char(*) parm;
dcl  Ptype			char(*) parm;
dcl  Pcount			fixed bin parm;
dcl  Plength			fixed bin(35) parm;

dcl  1 field			aligned auto,
       2 (type,  count, length)	char(32) varying,
       2 L			fixed bin,
       2 (typeI, countI, lengthI)	fixed bin;

dcl  length			builtin;

    if Pcount <= 0 then return;

    field.type  = rtrim (Ptype);			/* get length of field label and value.	 */
    field.count = ltrim (char(Pcount));			/* center label/value with entire field. */
    field.length = ltrim (char(Plength), " 0");
    if length(field.count) < length(field.length) then
       field.count = substr(SPACES, 1, length(field.length)-length(field.count)) || field.count;
    else if length(field.count) > length(field.length) then
       field.length = substr(SPACES, 1, length(field.count)-length(field.length)) || field.length;
    if hd.args.length then
       field.L = max (length(field.type), length(field.count), length(field.length));
    else
       field.L = max (length(field.type), length(field.count));
    field.typeI  = divide (field.L-length(field.type)+1, 2, 17, 0);
    field.countI = divide (field.L-length(field.count)+1, 2, 17, 0);
    field.lengthI = divide (field.L-length(field.length)+1, 2, 17, 0);

    if (index(line2, Pprefix2) = 0) & (length(Pprefix2) > 0) then do;
       if length(line2) + field.L + length((4)" ") + length(Pprefix2) > max_lineL then
	call TOTAL_print_end (Pprefix1, Pprefix2, Pprefix3);
       else do;					/* Put EXTENDED ENTRIES id in current	 */
	line1 = line1 || (4)" ";			/*  output lines, if not already there.	 */
	line2 = line2 || (4)" ";
	line3 = line3 || (4)" ";
	line1 = line1 || Pprefix1;
	line2 = line2 || Pprefix2;
	line3 = line3 || Pprefix3;
	end;
       end;
    else if length(line1) + field.L + length((2)" ") > max_lineL then
       call TOTAL_print_end (Pprefix1, Pprefix2, Pprefix3);	/* Emit output lines if they are about 	 */
						/*  to overflow.			 */

    if length(line1) > 0 then do;			/* Put label and value into output lines.*/
       line1 = line1 || (2)" ";
       line2 = line2 || (2)" ";
       line3 = line3 || (2)" ";
       end;
    line1 = line1 || substr(SPACES,1,field.typeI);
    line2 = line2 || substr(SPACES,1,field.countI);
    line3 = line3 || substr(SPACES,1,field.lengthI);
    line1 = line1 || field.type;
    line2 = line2 || field.count;
    line3 = line3 || field.length;
    line1 = line1 || substr(SPACES,1,field.L - field.typeI - length(field.type));
    line2 = line2 || substr(SPACES,1,field.L - field.countI - length(field.count));
    line3 = line3 || substr(SPACES,1,field.L - field.lengthI - length(field.length));

    end TOTAL_print;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* TOTAL_print_end:									 */
/*   Print current output lines.  Put prefix on a new set of output lines.			 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

TOTAL_print_end:
    procedure (Pprefix1, Pprefix2, Pprefix3);

dcl (Pprefix1, Pprefix2, Pprefix3)	char(*) parm;

    if length(line2) > length(Pprefix2) then 
       call ioa_ ("^a^/^a^/^[^a^/^]", line1, line2,
	hd.args.length & (sum(hd.ext_ent.lengths)>0), line3);


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */
/*										 */
/* TOTAL_print_init:								 */
/*   Put prefix on a new set of output lines.						 */
/*										 */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

TOTAL_print_init:
    entry (Pprefix1, Pprefix2, Pprefix3);

    line1 = Pprefix1;
    line2 = Pprefix2;
    line3 = Pprefix3;
    return;

    end TOTAL_print_end;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	 */

%include fs_star_;

%include status_structures;

dcl  1 status			aligned auto like status_branch;

    end list_sub_tree;
