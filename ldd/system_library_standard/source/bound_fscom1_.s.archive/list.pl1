/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1989                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
     audit(86-09-04,DGHowe), install(86-11-20,MR12.0-1222):
     Modified to extract the mode on a multisegment file from the mode on
     component 0.
  2) change(89-01-31,TLNguyen), approve(89-01-31,MCR8045),
     audit(89-02-23,RBarstad), install(89-03-01,MR12.3-1018):
     1. Remove trailing white spaces in the pathname that gets printed in the
        error message "Directory empty.".
     2. The returned error message now includes specified invalid control
        argument that a user typed in on the command line.
     3. For the case of no entries matching a starname, list prints out
        "Use of star convention resulted in no match.  STARNAME."
     4. Modify the existing internal procedure "check_for_msf" to return
        correct information of a specified multisegment-file (MSF).
                                                   END HISTORY COMMENTS */


/* list (ls) ... Standard Service System directory-listing command */

/* Completely rewritten by T. Casey, March 1975, replacing the 1969 version by R.C.Daley
   Modified for NSS by T. Casey, January 1976. (Rev 33)
   Modified by T. Casey April 1976 to fix bugs. (Rev 36)
   Modified by T. Casey November 1976 to fix bugs and add ability to give pathnames without -pn. (Rev 37)
   Modified by T. Casey August 1977 to fix bugs in msf access, listing the root, and allow 4 cols for records. (Rev 38)
   Modified by C. Hornig June 1981 to pay attention to link pathname length.
   Modified by M. Pandolf August 1984 to support DM files by special casing MSFs.
   Modified by M. Pandolf September 1984 to support DM file control args.
   Modified by JAFalksen 1984-09-18 to use date_time_$format("^<date> ^<time>",...
   Modified by M. Pandolf October 1984 to let inner ring MSFs be...
   Modified by M. Pandolf November 1984 to die when invoked as an AF.
   Modified by Steve Herbst 11/20/84 to assume -all if no other type args and all nonstarnames.
   Modified by M. Sharpe 2/21/85 to indent addnames by 2 if only names are listed-- bug introduced by the date_time changes
*/

ls:
list:
     procedure options (variable);

/* system_free_area - used by directory listing primitives to return information,
   and by list to allocate the starnames and sort_ix arrays */

dcl  system_free_area area based (system_free_ptr);
dcl  system_free_ptr ptr;

dcl  aloc_ptr (6) ptr;				/* pointers to storage allocated in system_free_area,
						   which must be freed by the cleanup handler */
dcl  ep ptr defined (aloc_ptr (1));
dcl  np ptr defined (aloc_ptr (2));
dcl  msf_ep ptr defined (aloc_ptr (3));
dcl  msf_np ptr defined (aloc_ptr (4));
dcl  starptr ptr defined (aloc_ptr (5));
dcl  sort_index_ptr ptr defined (aloc_ptr (6));

/* Misc. pointers, init (null) */

dcl  lp ptr init (null);				/* link pathname pointer */

/* Misc. fixed bin init (0) */

dcl  (bc, ec, err_opt, first, from_to_date_ix, lc, ni, n_listed, nn, nnames, not_found_count, pathl, records, tpix, tx, dmf_count, dmf_rec_count)
	fixed bin init (0);

/* Misc. fixed bin not initialized */

dcl  (dir_bc, dir_ec, dir_lc, first_br, first_et, first_lk, hdng_index, i, ia, ib, ix, last_br, last_et, last_lk, msf_count, msf_rec_count)
	fixed bin;

dcl msf_bc fixed bin;

/* Variables related to the four entry types: segs, dirs, msfs, and links */

dcl  (
     tcount (0:3),
     trecs (0:3)
     ) fixed bin;					/* tcount holds no. of links,segs,dirs,msfs while
						   trecs contains page totals */
						/* trecs(0) is unused, and is declared only to make
						   tcount(i),trecs(i) legal for i = 0,1,2,3 */
dcl  tsws (0:3) bit (1) aligned;			/* switches saying which types are to be listed */
dcl  (
     linksw defined tsws (0),				/* give a name to each element in the array of switches */
     segsw defined tsws (1),
     dirsw defined tsws (2),
     multisegsw defined tsws (3)
     ) bit (1) aligned;

dcl  type_ix (5) fixed bin static options (constant) init (1, 3, 3, 2, 0);
						/* since the order of entry types in the listing is: */
dcl  LINK fixed bin static options (constant) init (0);	/* segs, msfs, dirs, links */
dcl  SEG fixed bin static options (constant) init (1);	/* the do loop would read do i = 1,3,2,0 */
dcl  DIR fixed bin static options (constant) init (2);	/* which generates messy code */
dcl  MSF fixed bin static options (constant) init (3);	/* so we use this array of entry types instead */

/* switches, init ("1"b) */

dcl  (default_col, default_type, lnsw) bit (1) aligned init ("1"b);

/* switches init ("0"b) - see also the two arrays of switches: tsws(0:3) and colsw(7) */

dcl  (allsw, bfsw, branchsort, branchsw, dtem_arg_sw, excludesw, filesw, fromsw, got_all_branch_info, got_branch_info,
     includesw, length_arg_sw, link_path_arg, matchsw, error_flag, noheadsw, pathsw, pbranchsw, 
     pdmfilesw, pmultisegsw, prisw, read_vtoc_sw,
     real_dtm_sw, real_record_sw, revsw, shortsw, sort_vtoc_sw, sortsw, tosw, totalsw) bit (1) aligned init ("0"b);

dcl  colsw (7) bit (1) aligned;
dcl  dtmsw bit (1) aligned defined (colsw (1));
dcl  dtusw bit (1) aligned defined (colsw (2));
dcl  modesw bit (1) aligned defined (colsw (3));
dcl  recordsw bit (1) aligned defined (colsw (4));
dcl  namesw bit (1) aligned defined (colsw (5));
dcl  countsw bit (1) aligned defined (colsw (6));
dcl  lkpathsw bit (1) aligned defined (colsw (7));

dcl  msf_pass2 bit (1) aligned;

/* Variables used in argument processing */

dcl  argptr ptr;
dcl  (argno, arglen, nargs) fixed bin;
dcl  targ char (arglen) based (argptr);

dcl  ch8 char (8) aligned;				/* place to put short control args, for best
						   comparison code generation (ldaq, cmpaq) */
dcl  ch4 char (4) aligned based (addr (ch8));		/* overlay to get lda, cmpa for
						   arguments of 4 chars or less */

dcl  ch20 char (20) aligned;				/* for args > 8 chars, at least put it in the stack and
						   avoid page faults during comparisons */
dcl  (
     ch12 char (12),
     ch16 char (16)
     ) aligned based (addr (ch20));

dcl  (path, dirname) char (168);

/* Control arguments.  Look them up in arrays, instead of having a separate
   CMPC instruction for each one (there are 74) */

dcl  c4arg (40) char (4) aligned static options (constant) init ("-a",
						/* 1 */
	"-all",					/* 2 */
	"-b",					/* 3 */
	"-bf",					/* 4 */
	"-br",					/* 5 */
	"-d",					/* 6 */
	"-dr",					/* 7 */
	"-dtm",					/* 8 */
	"-dtu",					/* 9 */
	"-f",					/* 10 */
	"-fi",					/* 11 */
	"-l",					/* 12 */
	"-lk",					/* 13 */
	"-lks",					/* 14 */
	"-msf",					/* 15 */
	"-nm",					/* 16 */
	"-p",					/* 17 */
	"-pn",					/* 18 */
	"-pri",					/* 19 */
	"-prn",					/* 20 */
	"-rec",					/* 21 */
	"-rev",					/* 22 */
	"-rv",					/* 23 */
	"-s",					/* 24 */
	"-sh",					/* 25 */
	"-sm",					/* 26 */
						/* new ones - out of order */
	"-ct",					/* 27 */
	"-ex",					/* 28 */
	"-fm",					/* 29 */
	"-md",					/* 30 */
	"-nhe",					/* 31 */
	"-nh",					/* 32 */
	"-sr",					/* 33 */
	"-to",					/* 34 */
	"-tt",					/* 35 */
	"-ft",					/* 36 */
	"-lp",					/* 37 */
	"-dir",					/* 38 */
	"-ln",					/* 39 */
          "-dmf");					/* 40 */

dcl  c8arg (26) char (8) aligned static options (constant) init ("-branch",
						/* 1 */
	"-brief",					/* 2 */
	"-file",					/* 3 */
	"-files",					/* 4 */
	"-link",					/* 5 */
	"-name",					/* 6 */
	"-names",					/* 7 */
	"-primary",				/* 8 */
	"-record",				/* 9 */
	"-records",				/* 10 */
	"-reverse",				/* 11 */
	"-segment",				/* 12 */
	"-short",					/* 13 */
						/* new ones - out of order */
	"-count",					/* 14 */
	"-exclude",				/* 15 */
	"-from",					/* 16 */
	"-match",					/* 17 */
	"-mode",					/* 18 */
	"-sort",					/* 19 */
	"-total",					/* 20 */
	"-totals",				/* 21 */
	"-links",					/* 22 */
	"-first",					/* 23 */
	"-dtcm",					/* 24 */
	"-dtem",					/* 25 */
	"-length");				/* 26 */

dcl  c12arg (5) char (12) aligned static options (constant) init ("-directory",
						/* 1 */
	"-pathname",				/* 2 */
	"-no_header",				/* 3 */
	"-link_path",				/* 4 */
	"-link_paths");				/* 5 */

dcl  c16arg (1) char (16) aligned static options (constant) init ("-date_time_used");
						/* 1 */

dcl  c20arg (2) char (20) aligned static options (constant) init ("-date_time_modified",
						/* 1 */
	"-multisegment_file");			/* 2 */

dcl  c28arg (3) char (28) aligned static options (constant) init ("-date_time_contents_modified",
						/* 1 */
	"-date_time_entry_modified",			/* 2 */
          "-data_management_file");			/* 3 */

/* Variables connected with sort argument processing, and sorting */

dcl  c4key (11) char (4) aligned static options (constant) init (
						/* sort keys */
	"ct",					/* 6 */
	"md",					/* 3 */
	"mode",					/* 3 */
	"name",					/* 5 */
	"nm",					/* 5 */
						/* first 5 are not involved in VTOC-or-directory question */
	"dtm",					/* 1 */
	"dtem",					/* 1 */
	"ln",					/* 4 */
						/* numbers 6, 7, and 8 are directory items */
	"dtu",					/* 2 */
	"dtcm",					/* 1 */
	"rec");					/* 4 */
						/* numbers 9, 10, and 11 are VTOC items */

dcl  c4key_value (11) fixed bin static options (constant) init (6, 3, 3, 5, 5, 1, 1, 4, 2, 1, 4);
dcl  sort_key fixed bin init (0);			/* remember the given sort key as a code number */

dcl  DEFAULT fixed bin static options (constant) init (0);

/* The following named values are used for two purposes:
   1) values of sort_key, to determine which column to sort on;
   2) references to the colsw array, to determine which columns to print (and to set up format strings for).
*/

dcl  DTM fixed bin static options (constant) init (1);
dcl  DTU fixed bin static options (constant) init (2);
dcl  REC fixed bin static options (constant) init (4);
dcl  NAME fixed bin static options (constant) init (5);
dcl  CT fixed bin static options (constant) init (6);

/* This array holds indices of entries. It is allocated large enough to hold indices of all entries in the directory,
   but only the indices of entries selected (by star matching, etc.) for listing are actually placed in it.
   Sorting, if specified by the user, is accomplished by reordering the indices, rather than the entries themselves. */

dcl  sort_ix (dir_ec) fixed bin aligned based (sort_index_ptr);

/* Variables connected with starname argument processing and star matching */

dcl  1 starnames (alloc_len) aligned based (starptr),	/* this structure has one entry per starname */
       2 type fixed bin,				/* see below */
       2 action fixed bin,				/* for possible values of these two variables */
       2 length fixed bin,				/* length in characters of the starname */
       2 matched bit (1) aligned,			/* = "1"b after star matching, if any entries matched this name */
       2 name char (32) unaligned;			/* the starname itself */

dcl  1 stack_starnames (4) like starnames aligned automatic;/* the starnames structure usually overlays this */
dcl  alloc_len fixed bin;				/* but if there are > 4, we allocate enough room for them */
dcl  starname_idx fixed bin;
dcl  all_nonstarred_sw bit (1);

/* Here are the values that starnames.type can have */

dcl  ENTRY_NAME fixed bin static options (constant) init (0);
dcl  DOUBLE_STAR fixed bin static options (constant) init (2);

/* Here are the values that starnames.action can have */

dcl  INCLUDE fixed bin static options (constant) init (10);
dcl  EXCLUDE fixed bin static options (constant) init (11);

dcl  starname_count fixed bin init (0);			/* number of starnames given on command line */

/* Variables used in accessing information returned by the directory listing primitives */

dcl  type bit (2);

dcl  lkpath char (168) based (lp);

dcl  mode char (4);					/* for printing "sma" or "rew" */
dcl  mode_array (3) char (1) unaligned based (addr (mode)); /* for storing mode letters in mode */
dcl  file_mode char (4) static options (constant) init ("rew ");
						/* mode letters for files */
dcl  dir_mode char (4) static options (constant) init ("s ma");
						/* mode letters for directories */
dcl  mode_ptr ptr;					/* points to one of the mode letter strings */
dcl  et_mode (4) char (1) unaligned based (mode_ptr);	/* for picking up mode letters from one of the strings */
dcl  mode_bits (4) bit (1) unaligned;			/* copy of the "rewa" mode bits, from the branch */

/* This should use star_structures.incl.pl1 */

dcl  name (16384) char (32) based (np);			/* name array as returned from star_list */
						/* 16384 is the longest array that could be allocated
						   in system_free_area */

dcl  1 br (dir_ec) based (ep) aligned,			/* branch array */
       2 type bit (2) unaligned,
       2 nname fixed bin (15) unaligned,
       2 nindex fixed bin (17) unaligned,
       2 (dtm, dtu) bit (36) aligned,			/* really bit (36) - all 36 bits are data - no sign bit */
       2 mode unaligned,				/* see explanation in the get_date internal procedure */
         3 (t, r, e, w, a) bit (1) unaligned,
       2 pad bit (6) unaligned,
       2 records fixed bin (24) unaligned;

dcl  1 branch automatic aligned,
       2 type bit (2) unaligned,
       2 nname fixed bin (15) unaligned,
       2 nindex fixed bin (17) unaligned,
       2 (dtm, dtu) bit (36) aligned,			/* really bit (36) - all 36 bits are data - no sign bit */
       2 mode unaligned,				/* see explanation in the get_date internal procedure */
         3 (t, r, e, w, a) bit (1) unaligned,
       2 pad bit (13) unaligned,
       2 records fixed bin (17) unaligned;

dcl  1 et (dir_ec) based (ep) aligned,			/* overlay for br and lk structures, to pick up date and mode */
       2 et_pad1 fixed bin,				/* pick up the dates out of an array, in a do loop */
       2 date (2) bit (36) aligned,			/* really bit 36 ... */
       2 et_pad2 bit (1) unaligned,			/* ignore "t" mode */
       2 mode bit (4) unaligned,			/* "rewa" */
       2 et_pad3 bit (31) unaligned;

dcl  1 lk (dir_ec) based (ep) aligned,			/* link entry array */
       2 type bit (2) unaligned,
       2 nname fixed bin (15) unaligned,
       2 nindex fixed bin (17) unaligned,
       2 (dtm, dtd) bit (36) aligned,			/* really bit 36 ... */
       2 (pln, pnindex) fixed bin (17) unaligned;

/* Variables used in accessing and formatting date information */

dcl  (from_date, to_date) bit (36) aligned;
dcl  fb71 fixed bin (71);
dcl  cdate (2) char (64)var;                               /* hold dtm value (either dtcm or dtem) and dtu value */
dcl  cdtm char (64)var defined (cdate (1));                /* either dtcm value (for -dtcm) or dtem value (for -dtem).
                                                              But not both values because of inconsitency */
dcl  cdtu char (64)var defined (cdate (2));                /* dtu value for -dtu */
     

/* Variables used for formatting and printing output */

dcl  ioa_control_string char (256) varying;		/* used for all ioa_ calls */

/* ioa_ control string values for printing headings */

dcl  1 hdng aligned int static options (constant),	/* pack headings into unaligned strings: 423 chars (106 words) */
       (
       2 lkbfze char (8) init ("Links=0."),		/* The length and offset arrays occupy a total of 44 words. */
       2 smbfze char (7) init ("Segs=0;"),		/* The (single) statement that copies the right heading into */
	  2 drbfze char (7) init ("Dirs=0;"),		/* ioa_control_string generates 10 words of code. */
       2 msbfze char (7) init ("Msfs=0;"),		/* Total: 160 words used by this method. */
						/* An array of char(44) strings would use 242 words (no good). */
	  2 lkbfnz char (9) init ("Links=^d."),		/* Stored as aligned strings (generated for literal constants) */
	  2 smbfnz char (16) init ("Segs=^d,recs=^d;"),	/* the headings would use 111 words. */
       2 drbfnz char (16) init ("Dirs=^d,recs=^d;"),	/* The code to assign the strings as constants would be */
       2 msbfnz char (16) init ("Msfs=^d,recs=^d;"),	/* 7 words per string: 3-word mlr, ldq-stq to set the length */
	  2 lklgze char (12) init ("^/Links = 0."),	/* of the varying string, tra around the other assignments, */
       2 smlgze char (15) init ("^/Segments = 0."),	/* and one word in a transfer vector to get to */
       2 drlgze char (18) init ("^/Directories = 0."),	/* the right assignment. Total: 7*22=154, */
       2 mslgze char (25) init ("^/Multisegment-files = 0."),
						/* plus the 111 words to store the strings, totaling 265 words. */
	  2 lklgnz char (16) init ("^/Links = ^d.^2/"),	/* Saving: 265-160=105 words. */
       2 smlgnz char (33) init ("^/Segments = ^d, Records = ^d.^2/"),
       2 drlgnz char (36) init ("^/Directories = ^d, Records = ^d.^2/"),
       2 mslgnz char (43) init ("^/Multisegment-files = ^d, Records = ^d.^2/"),
       2 smbfxx char (16) init ("Segs=^d,lths=^d;"),
       2 drbfxx char (8) init ("Dirs=^d;"),
       2 msbfxx char (16) init ("Msfs=^d,lths=^d;"),
       2 smlgxx char (33) init ("^/Segments = ^d, Lengths = ^d.^2/"),
       2 drlgxx char (22) init ("^/Directories = ^d.^2/"),
       2 mslgxx char (43) init ("^/Multisegment-files = ^d, Lengths = ^d.^2/")
       ) unaligned;

dcl  hdng_len (0:21) fixed bin unaligned static options (constant)
	init (8, 7, 7, 7, 9, 16, 16, 16, 12, 15, 18, 25, 16, 33, 36, 43, 16, 8, 16, 33, 22, 43);
dcl  hdng_offset (0:21) fixed bin unaligned static options (constant)
	init (1, 9, 16, 23, 30, 39, 55, 71, 87, 99, 114, 132, 157, 173, 206, 242, 285, 301, 309, 325, 358, 380);
						/* 380+43=423 */

dcl  dmf_control_string dim (0:21) char (64) internal static options (constant)
     init ("", "", "", "Dmfs=0;", "", "", "", "Dmfs=^d,recs=^d;",
           "", "", "", "^/Data Management files = 0.", "", "", "", "^/Data Management files = ^d, Records = ^d.^2/",
           "", "", "Dmfs=^d,cis=^d;", "", "", "^/Data Management files = ^d, Control Intervals = ^d.^2/");

/* Variables used in constructing ioa_ format strings */

/* max_day is "1999-12-31  23:59:59.999999 gmt Fri"		       */
/* None of the component values have leading or trailing zeroes, so no       */
/*  matter what kind of space or zero suppression has been called for in a   */
/*  user's default formats, this value will cause a max-length result from   */
/*  date_time_$format.					       */
dcl max_day fixed bin (71) int static options (constant) init (3124137599999999);
dcl date_format char (15) int static options (constant) init ("^<date> ^<time>");
dcl  dt_len fixed bin;
dcl  dt_len_pic pic"99";


dcl  col_fmt (6) char (8) int static options (constant) init (
     	"^2x^__a",				/* dtm */
	"^2x^__a",				/* dtu */
	"^2x^3a",					/* mode */
	"^1x^4d",					/* records */
	"^2x^a",					/* name */
	"^2x(^d)");				/* count */

dcl  col_fmt_ln (6) fixed bin static options (constant) init (7, 7, 6, 6, 5, 7);
dcl  branch_fmt (2) char (35);			/* for files and directories, respectively */
dcl  branch_fmt_ln (2) fixed bin init ((2) 0);
dcl  branch_fmt_ix fixed bin;


dcl  name_indent fixed bin init (0);			/* how far to indent addnames */

dcl  name_fmt (0:2) char (8);				/* name formats for links, files, and dirs, respectively */
dcl  name_fmt_ln (0:2) fixed bin;			/* their lengths */

dcl  link_fmt (2) char (24);				/* two link formats, for singly- and multiply-named links */
dcl  link_fmt_ln (2) fixed bin;			/* their lengths */

/* Variables used in error message printing */

dcl  (
     code,
     (
     error_table_$nomatch,				/* no match error for star name (or entry name) */
     error_table_$bigarg,				/* arg too long */
     error_table_$logical_volume_not_connected,		/* tried to read VTOC but the volume is not available */
     error_table_$logical_volume_not_defined,		/* unavailable for a different reason */
     error_table_$null_dir,				/* Directory is empty */
     error_table_$root,				/* can't list the root as a dir itself */
     error_table_$inconsistent,			/* inconsistent combination of args */
     error_table_$badopt
     ) ext
     ) fixed bin (35);				/* unrecognized option error */

dcl  message char (68) varying;			/* ioa_ control string for com_err_ calls */
dcl  errname char (168) aligned init ("");		/* path name variable for com_err_ calls */

/* External Entries */

dcl  iox_$error_output ext ptr;

dcl  absolute_pathname_ entry (char (*), char(*), fixed bin (35));
dcl  (
     com_err_,
     ioa_,
     ioa_$nnl,
     ioa_$ioa_switch
     ) entry options (variable);
dcl  cu_$arg_count entry (fixed bin, fixed bin(35));
dcl  cu_$arg_ptr entry (fixed bin (17), ptr, fixed bin (17), fixed bin (35));
dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin);
dcl  cv_fstime_ entry (bit (36) aligned) returns (fixed bin (71));
dcl  expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35));
dcl  date_time_$format entry (char(*), fixed bin(71), char(*), char(*)) returns(char(250) var);
dcl  file_manager_$validate entry (char(*), char(*), fixed bin(35));
dcl  fs_util_$get_user_access_modes entry (char(*), char(*), char(*), fixed bin, bit(36) aligned,
	bit(36) aligned, fixed bin(35));
dcl hcs_$get_user_access_modes entry (char(*), char(*), char(*), fixed bin, bit(36) aligned,
	bit(36) aligned, fixed bin(35));
dcl  hcs_$star_dir_list_
	entry (char (*), char (*) aligned, fixed bin (3), ptr, fixed bin, fixed bin, ptr, ptr, fixed bin (35));
dcl  hcs_$status_ entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35));
dcl  hcs_$status_minf entry (char(*), char(*), fixed bin(1), fixed bin(2), fixed bin(24), fixed bin(35));
dcl  get_system_free_area_ entry returns (ptr);
dcl  check_star_name_$entry ext entry (char (*), fixed bin (35));
dcl  match_star_name_ ext entry (char (*), char (*), fixed bin (35));
dcl  convert_date_to_binary_ ext entry (char (*), fixed bin (71), fixed bin (35));

/* Conditions and builtins */

dcl  cleanup condition;

dcl  (addr, bin, bit, convert, divide, fixed, hbound, index, length, mod, null, rtrim, search, string, substr) builtin;

/**/
                                                            /* set variables to initial values to avoid unexpected values */
          msf_bc = 0;
          dirname = "";

	system_free_ptr = get_system_free_area_ ();	/* get pointer to free storage area */

	tcount (1), tcount (2), tcount (3), tcount (0) = 0;
						/* inits of automatic arrays compile inefficiently */
	trecs (1), trecs (2), trecs (3), trecs (0) = 0;
	tsws (1), tsws (2), tsws (3), tsws (0) = "0"b;
	name_fmt_ln (0), name_fmt_ln (1) = 0;
	link_fmt_ln (1), link_fmt_ln (2) = 0;

	colsw (1), colsw (2), colsw (3), colsw (4), colsw (6) = "0"b;
	namesw = "1"b;				/* turn on colsw (5) - the names column is always printed */
	lkpathsw = "1"b;				/* turn on colsw (7) - link paths are printed, by default */

	aloc_ptr (1), aloc_ptr (2), aloc_ptr (3), aloc_ptr (4), aloc_ptr (6) = null;
	starptr = addr (stack_starnames);		/* aloc_ptr (5) starts out pointing at a small stack array */

/* All allocation pointers must be initialized or nulled before we establish the cleanup handler */

	on condition (cleanup) call cleanup_proc;

	call cu_$arg_count (nargs, code);		/* pick up command argument count */
	if code ^= 0 then do;
	     call com_err_ (code, "list");
	     return;                                      /* quit */
	     end;
	do argno = 1 to nargs;			/* begin option processing loop */
	     call get_arg_ptr;			/* call cu_$arg_ptr to pick up next argument */
	     if arglen = 0 then go to endopt;		/* ignore null strings */
	     if substr (targ, 1, 1) = "-" then do;	/* check for control argument */
ctl_arg:
		if arglen > 8 then goto arglong;	/* arg <= 8 chars gets special treatment */
		ch8 = targ;			/* copy into double-word-aligned string */
		if arglen > 4 then goto argl8;	/* go compare using ldaq, cmpaq */
						/* else fall thru and compare using lda, cmpa */
		do i = 1 to hbound (c4arg, 1);
		     if ch4 = c4arg (i) then goto c4lab (i);
		end;
		goto badopt;			/* if no match */

argl8:
		do i = 1 to hbound (c8arg, 1);
		     if ch8 = c8arg (i) then goto c8lab (i);
		end;
		goto badopt;

arglong:
		if arglen > 20 then goto arglong2;
		ch20 = targ;			/* at least avoid page faults during comparisons */

		if arglen <= 12 then do;
		     do i = 1 to hbound (c12lab, 1);
			if ch12 = c12arg (i) then goto c12lab (i);
		     end;
		     goto badopt;
		     end;

/* for the 5 arguments longer than 12 characters, individual cmpb's occupy less space than do loops would */

		if ch20 = c20arg (1) then goto c20lab1;
		if ch20 = c20arg (2) then goto c20lab2;
		if ch16 = c16arg (1) then goto c16lab1;
		goto badopt;

arglong2:
		if targ = c28arg (1) then goto c28lab1;
		if targ = c28arg (2) then goto c28lab2;
		goto badopt;


/* Set switches as specified by control arguments */


c4lab (1):					/* -a */
c4lab (2):					/* -all */
		pbranchsw, allsw, segsw, dirsw, multisegsw, pmultisegsw, pdmfilesw, linksw = "1"b;
reset_default_type:
		default_type = "0"b;
		goto endopt;

c4lab (3):					/* -b */
c4lab (5):					/* -br */
c8lab (1):					/* -branch */
		branchsw, pbranchsw, segsw, dirsw, multisegsw, pmultisegsw, pdmfilesw = "1"b;
		goto reset_default_type;

c4lab (4):					/* -bf */
c8lab (2):					/* -brief */
		bfsw = "1"b;
		lkpathsw = "0"b;			/* -brief suppresses link pathnames */
reset_default_col:
		default_col = "0"b;
		goto endopt;

c4lab (27):					/* -ct */
c8lab (14):					/* -count */
		countsw = "1"b;
		goto endopt;

c4lab (6):					/* -d */
c4lab (7):					/* -dr */
c4lab (38):					/* -dir */
c12lab (1):					/* -directory */
		dirsw, pbranchsw = "1"b;
		goto reset_default_type;

c4lab (40):					/* -dmf */
c28lab3:						/* -data_management_file */
		pdmfilesw, multisegsw, pbranchsw = "1"b;
		goto reset_default_type;

c8lab (24):					/* -dtcm */
c28lab1:						/* -date_time_contents_modified */
		if dtem_arg_sw then goto vtoc_conflict;
		real_dtm_sw, read_vtoc_sw = "1"b;
		goto set_dtm_sw;

c8lab (25):					/* -dtem */
c28lab2:						/* -date_time_entry_modified */
c4lab (8):					/* -dtm */
c20lab1:						/* -date_time_modified */
		if real_dtm_sw then goto vtoc_conflict;
		dtem_arg_sw = "1"b;
set_dtm_sw:
		dtmsw = "1"b;
		lnsw = "0"b;
		goto endopt;

c4lab (9):					/* -dtu */
c16lab1:						/* -date_time_used */
		dtusw = "1"b;
		read_vtoc_sw = "1"b;
		lnsw = "0"b;
		goto endopt;

c4lab (28):					/* -ex */
c8lab (15):					/* -exclude */
		argno = argno + 1;
		call get_arg_ptr;
		call get_starname;
		starnames (starname_count).action = EXCLUDE;
						/* remember to exclude entries that match this one */
		excludesw = "1"b;
		goto endopt;

c4lab (10):					/* -f */
c4lab (11):					/* -fi */
c8lab (3):					/* -file */
c8lab (4):					/* -files */
		filesw, segsw, multisegsw, pmultisegsw, pdmfilesw, pbranchsw = "1"b;
		goto reset_default_type;

c4lab (36):					/* -ft */
c8lab (23):					/* -first */
		argno = argno + 1;			/* get next arg, which must be decimal number */
		call get_arg_ptr;			/* if none there, get_arg_ptr calls com_err_ */
		first = cv_dec_check_ (targ, code);
		if code ^= 0 then do;		/* bad char in decimal arg */
		     code = 0;			/* not error_table_ code - com_err_ dislikes it */
		     call com_err_ (code, "list", "Illegal character in decimal argument: ^a.", targ);

		     err_opt = err_opt + 1;             /* indicate that errors in options */
		     end;
		goto endopt;

c4lab (15):					/* -msf */
c20lab2:						/* -multisegment_file */
		multisegsw, pmultisegsw, pbranchsw = "1"b;
		goto reset_default_type;

c4lab (29):					/* -fm */
c8lab (16):					/* -from */
		fromsw = "1"b;
		call get_date (from_date, "from");	/* internal procedure used by -from and -to */
		goto endopt;

c4lab (39):					/* -ln */
c8lab (26):					/* -length */
		if real_record_sw then goto vtoc_conflict;
		length_arg_sw, recordsw = "1"b;
		lnsw = "0"b;
		goto reset_default_col;

c4lab (14):					/* -lks */
		shortsw = "1"b;			/* fall thru to set link switch */

c4lab (12):					/* -l */
c4lab (13):					/* -lk */
c8lab (5):					/* -link */
c8lab (22):					/* -links */
		linksw = "1"b;
		goto reset_default_type;

c4lab (37):					/* -lp */
c12lab (4):					/* -link_path */
c12lab (5):					/* -link_paths */
		link_path_arg = "1"b;
		goto endopt;

c8lab (17):					/* -match */
		matchsw = "1"b;
		goto endopt;

c4lab (30):					/* -md */
c8lab (18):					/* -mode */
		modesw = "1"b;
		lnsw = "0"b;
		goto reset_default_col;

c4lab (16):					/* -nm */
c8lab (6):					/* -name */
c8lab (7):					/* -names */
		namesw = "1"b;
		goto reset_default_col;

c4lab (31):					/* -nh */
c4lab (32):					/* -nhe */
c12lab (3):					/* -no_header */
		noheadsw = "1"b;
		goto endopt;

c4lab (17):					/* -p */
c4lab (18):					/* -pn */
c12lab (2):					/* -pathname */
		argno = argno + 1;			/* next arg is the directory pathname */
		call get_arg_ptr;			/* get ptr to it */
		dirname = targ;			/* copy it into temp */
		if pathsw
		then				/* if a directory path already given */
		     if path ^= dirname then do;	/* and this one is different */
two_pn_error:
			code = 0;			/* complain */
			call com_err_ (code, "list", "More than one directory specified: ^a and ^a.",
			     rtrim (path), rtrim (dirname));		/* print the earlier pathname too */

			err_opt = err_opt + 1;        /* indicate that errors in options */
			goto endopt;
			end;
		path = dirname;			/* save directory path */
		path = targ;			/* copy it into char (168) */
		pathl = arglen;			/* remember its actual length */
		pathsw = "1"b;			/* remember to print it if not found or null dir errors occur */
		goto endopt;

c4lab (20):					/* -prn */
		countsw = "1"b;			/* fall thru to set primary switch */

c4lab (19):					/* -pri */
c8lab (8):					/* -primary */
		prisw = "1"b;
		goto endopt;

c4lab (21):					/* -rec */
c8lab (9):					/* -record */
c8lab (10):					/* -records */
		if length_arg_sw then goto vtoc_conflict;
		recordsw = "1"b;
		real_record_sw, read_vtoc_sw = "1"b;
		lnsw = "0"b;
		goto reset_default_col;

c4lab (22):					/* -rev */
c4lab (23):					/* -rv */
c8lab (11):					/* -reverse */
		revsw = "1"b;
		goto endopt;

c4lab (24):					/* -s */
c4lab (26):					/* -sm */
c8lab (12):					/* -segment */
		segsw, pbranchsw = "1"b;
		goto reset_default_type;

c4lab (25):					/* -sh */
c8lab (13):					/* -short */
		shortsw = "1"b;
		goto endopt;

c4lab (33):					/* -sr */
c8lab (19):					/* -sort */
		sortsw = "1"b;
		argno = argno + 1;			/* look at next arg, which MIGHT be a sort key */
		if argno > nargs then goto endopt;	/* but only if there is a next arg */
		call get_arg_ptr;
		if substr (targ, 1, 1) = "-" then goto ctl_arg;
						/* not sort key */
		if arglen <= 4 then do;		/* look up short keys in array, for efficiency */
		     ch4 = targ;			/* copy it into stack var */
		     do i = 1 to hbound (c4key, 1) while (ch4 ^= c4key (i));
		     end;
		     if i = 1 + hbound (c4key, 1) then goto star_arg;
						/* not sort key - must be starname */
		     sort_key = c4key_value (i);	/* remember the sort key number corresponding to this key */

		     if i > 5
		     then				/* this is a VTOC-or-directory item */
			goto sort_lab (i - 5);	/* check consistency and set switches */
		     goto endopt;

sort_lab (1):					/* dtm */
sort_lab (2):					/* dtem */
		     if real_dtm_sw then goto vtoc_conflict;
		     dtem_arg_sw = "1"b;
		     goto endopt;

sort_lab (3):					/* ln */
		     if real_record_sw then goto vtoc_conflict;
		     length_arg_sw = "1"b;
		     goto endopt;

sort_lab (4):					/* dtu */
		     read_vtoc_sw, sort_vtoc_sw = "1"b;
		     goto endopt;

sort_lab (5):					/* dtcm */
		     if dtem_arg_sw then goto vtoc_conflict;
		     real_dtm_sw = "1"b;
		     goto sort_lab (4);

sort_lab (6):					/* rec */
		     if length_arg_sw then goto vtoc_conflict;
		     real_record_sw = "1"b;
		     goto sort_lab (4);

		     end;

		else if arglen <= 20 then do;		/* arg longer than 4 chars */
			ch20 = targ;		/* copy into 20-char stack variable */
			if ch20 = "date_time_modified" then do;
			     sort_key = DTM;
			     goto sort_lab (1);
			     end;
			else if ch20 = "date_time_used" then do;
				sort_key = DTU;
				goto sort_lab (4);
				end;
			     else if substr (ch20, 1, 6) = "record" then do;
						/* match "record" or "records" */
				     sort_key = REC;
				     goto sort_lab (6);
				     end;
				else if ch20 = "length" then do;
					sort_key = REC;
					goto sort_lab (3);
					end;
				     else if ch20 = "count"
					then sort_key = CT;
					else if ch20 = "names"
					     then sort_key = NAME;
					     else goto star_arg;
						/* not sort key - must be starname */
			end;			/* end of <= 20 char do group */

		     else if arglen <= 28 then do;
			     if targ = "date_time_contents_modified" then do;
				sort_key = DTM;
				goto sort_lab (5);
				end;
			     else if targ = "date_time_entry_modified" then do;
				     sort_key = DTM;
				     goto sort_lab (1);
				     end;
				else goto star_arg;
			     end;

			else goto star_arg;		/* too long to be sort key - must be starname */

		goto endopt;			/* exit after picking up sort key and falling thru to here */

c4lab (34):					/* -to */
		tosw = "1"b;
		call get_date (to_date, "to");	/* share code with -from */
		goto endopt;

c4lab (35):					/* -tt */
c8lab (20):					/* -total */
c8lab (21):					/* -totals */
		totalsw = "1"b;
		goto endopt;

/* Come here for inconsistent arguments: VTOC and directory */

vtoc_conflict:
		code = error_table_$inconsistent;
		call com_err_ (code, "list", "^a and a previous sort or column argument.", targ);

		err_opt = err_opt + 1;                  /* indicate errors in options. */
		goto endopt;

/* Come here for unrecognized control args */

badopt:
		code = error_table_$badopt;		/* unrecognized control argument */
badarg:
		call com_err_ (code, "list", "^a", targ);

		err_opt = err_opt + 1;		/* indicate errors in options */
		end;

	     else do;				/* arg does not begin with "-" so it must be a starname */
star_arg:
		call get_starname;			/* internal procedure */
		if starnames (starname_count).action = 0 then do;
						/* unless it was set by get_starname */
		     starnames (starname_count).action = INCLUDE;
						/* starname not preceeded by one of the special */
		     includesw = "1"b;		/* control args gets matching entries included in the listing */
		     end;
		end;

endopt:
	end;					/* end of option handling section */

	if err_opt ^= 0				/* If errors in options, leave now */
	then go to error_return;

/* If no errors, set up for processing: examine results of argument processing, set some defaults,
   go get information out of directory, and then set up ioa_ control strings needed to print it */

	if default_type then do;			/* if no entry type arguments were given */

	     if starname_count > 0 then do;		/* check if all specified names are non-starnames */
		all_nonstarred_sw = "1"b;
		do starname_idx = 1 to starname_count while (all_nonstarred_sw);
		     call check_star_name_$entry (starnames.name (starname_idx), code);
		     if code ^= 0 then all_nonstarred_sw = "0"b;
		end;
	     end;
	     else all_nonstarred_sw = "0"b;

	     if all_nonstarred_sw then		/* enforce -all in this case */
		pbranchsw, allsw, segsw, dirsw, multisegsw, pmultisegsw, pdmfilesw, linksw = "1"b;
	     else filesw, segsw, multisegsw, pmultisegsw, pdmfilesw, pbranchsw = "1"b; /* the default is -file */
	end;

	if default_col then do;			/* if no arguments were given to override the default columns */
	     namesw, modesw, recordsw = "1"b;		/* default is names, mode, and records */
	     lnsw = "0"b;
	     end;

	if sortsw then do;				/* if -sort was given */
	     if sort_key = DEFAULT then do;		/* but not followed by a keyword */
		if dtmsw then do;			/* if dtm being printed */
		     sort_key = DTM;		/* then sort on it */
		     if real_dtm_sw then sort_vtoc_sw = "1"b;
						/* remember to read VTOCs before sorting */
		     end;
		else if dtusw then do;		/* otherwise if dtu is being printed */
			sort_key = DTU;		/* then sort on it */
			sort_vtoc_sw = "1"b;
			end;
		     else sort_key = NAME;		/* otherwise sort on primary names */
		end;

	     if linksw
	     then					/* if printing links */
		if sort_key < NAME
		then				/* and sorting on something that only a branch has */
		     if sort_key > DTM
		     then				/* we don't want to sort links on garbage */
			branchsort = "1"b;		/* so remember to sort only branches */
	     end;

	if fromsw | tosw then do;			/* figure out which date to use for from-to comparisons */
	     if dtmsw | sort_key = DTM
	     then					/* if dtm being printed or sorted on */
		from_to_date_ix = DTM;		/* use it for from-to comparison */
	     else if dtusw | sort_key = DTU
		then				/* otherwise, if dtu being printed or sorted on */
		     from_to_date_ix = DTU;		/* use that for from-to comparison */
		else				/* but if neither date being printed or sorted on */
		     from_to_date_ix = DTM;		/* use dtm for from-to comparison */
	     end;

	if fromsw
	then if tosw
	     then					/* if both given */
		if from_date >= to_date then do;	/* from must be before to */
		     call com_err_ (error_table_$inconsistent, "list", "from-date must be BEFORE to-date.");
		     goto error_return;                 /* call cleanup_proc internal procedure and quit */
		     end;

	if lnsw
	then					/* if printing only names (like old ln command) */
	     lkpathsw = "0"b;			/* then don't print link pathnames */
						/* (-brief also suppresses linkpaths; that is checked above) */

	if link_path_arg
	then					/* but if -link_path given */
	     lkpathsw = "1"b;			/* print link paths no matter what else */

/* All the information related to selection of entries to be printed has now been analyzed.
   Go get the information out of the directory now, so that, knowing what we do and
   do not have to print, we can omit construction of unneeded format strings. */

	call get_list;				/* internal procedure, for historical reasons;
						   also to make the main procedure shorter and more readable */

	if error_flag
	then					/* if get_list returned nothing, and told user why */
	     goto error_return;			/* don't rub it in with lots of "<thing>s = 0" messages */

/* Set up ioa_ format strings for printing branch information, link information, and secondary names.
   All of these formats are a function of which columns the user wants printed, and what was found in the directory. */

	if ^totalsw then do;			/* don't waste time if only totals being printed */
	     if dtmsw | dtusw
	     then dt_len = length (date_time_$format (date_format, max_day, "", ""));
	     else dt_len = 1;


/* Set up branch format */

	     if pbranchsw & bc > 0 then do;		/* only if at least one branch type is to be printed */

		call set_branch_fmt (1);		/* set up format string for files */

		if dirsw
		then				/* if listing directories */
		     if recordsw
		     then				/* and printing the records column */
			if ^real_record_sw then do;	/* but not real records */
			     recordsw = ""b;	/* turn off the records column switch */
			     call set_branch_fmt (2); /* and build a format string without the records column */
			     recordsw = "1"b;	/* and turn it back on again */
			     end;			/* but don't bother if the file format will be ok for dirs */

		end;

/* Set up link format. The possible items to be printed are:
   dtm, name, count, and linkpath. In addition, the presence or absence
   of the -short argument determines how linkpath is lined up. We must build
   two format strings (only when both linkpaths and counts are being printed),
   to be used for singly- and multiply-named links, since count is not printed
   when it is = 1. We did not have to do this for branches, because count is the
   last column, for branches, and we just chop the format item for count off
   the end of (a copy of) the format string, when count = 1. */

	     if linksw & lc > 0 then do;		/* only if links are to be printed */

		if dtmsw then do;			/* if dtm to be printed for links */
		     link_fmt (1) = "^__a^2x";
		     substr (link_fmt (1), 2, 2) = convert (dt_len_pic, dt_len);
		     link_fmt_ln (1) = 7;
		     end;
		else do;
		     link_fmt (1) = "^s";
		     link_fmt_ln (1) = 2;
		     end;

		if ^lkpathsw
		then				/* if not printing linkpaths */
		     goto lkshort1;			/* then don't bother with the long format */
		if shortsw then do;
lkshort1:
		     substr (link_fmt (1), link_fmt_ln (1) + 1) = "^a";
						/* save printing time by not padding names to 32 char */
		     link_fmt_ln (1) = link_fmt_ln (1) + 2;
		     end;
		else do;
		     substr (link_fmt (1), link_fmt_ln (1) + 1) = "^32a";
						/* pad names, to line up link paths */
		     link_fmt_ln (1) = link_fmt_ln (1) + 4;
		     end;

		if countsw then do;			/* if printing counts, we have to have two format strings */
		     link_fmt (2) = link_fmt (1);	/* the second one is for when there are no secondary names */
		     link_fmt_ln (2) = link_fmt_ln (1); /* its left half is just like the first one */

		     if ^lkpathsw
		     then				/* if linkpaths not to be printed */
			goto lkshort2;		/* don't pad count to constant length */
		     if shortsw then do;		/* if -short given */
lkshort2:						/* also don't pad count to constant length */
			substr (link_fmt (1), link_fmt_ln (1) + 1) = "^2x(^d)";
			link_fmt_ln (1) = link_fmt_ln (1) + 7;
			end;
		     else do;			/* pad count to constant length, to keep linkpaths lined up */
			substr (link_fmt (1), link_fmt_ln (1) + 1) = "^2x(^3d)";
			link_fmt_ln (1) = link_fmt_ln (1) + 8;
			end;

		     if lkpathsw then do;		/* if lkpaths to be printed, put a ^s in the second format,
						   preceeding the ^a for the linkpath */
			if shortsw
			then			/* if -short, don't bother lining things up */
			     substr (link_fmt (2), link_fmt_ln (2) + 1) = "^2x^s";
			else			/* otherwise, line up linkpaths */
			     substr (link_fmt (2), link_fmt_ln (2) + 1) = "^9x^s";
			link_fmt_ln (2) = link_fmt_ln (2) + 5;
						/* in either case, 5 chars were added to the format string */
			end;
		     end;				/* end of if countsw do group */

		if lkpathsw then do;		/* if linkpaths to be printed, set up their formats */
		     if countsw then do;		/* if counts being printed, there is a second format string */
			substr (link_fmt (2), link_fmt_ln (2) + 1) = "^a";
						/* so put format for linkpaths into it */
			link_fmt_ln (2) = link_fmt_ln (2) + 2;
			end;
		     else do;			/* but if counts not being printed */
			substr (link_fmt (1), link_fmt_ln (1) + 1) = "^s";
						/* skip over the count argument */
			link_fmt_ln (1) = link_fmt_ln (1) + 2;
						/* in the first (and only) string */
			end;

		     substr (link_fmt (1), link_fmt_ln (1) + 1) = "^2x^a";
						/* in either case, */
		     link_fmt_ln (1) = link_fmt_ln (1) + 5;
						/* put the link path format into the first string */
		     end;				/* end of if lkpathsw do group */

/* Set up format for secondary names of links */

		if ^prisw then do;			/* only if they will be printed */
		     if dtmsw then do;		/* if dtm being printed */
			name_fmt (0) = "^18x^a";	/* indent secondary names 18 spaces */
			name_fmt_ln (0) = 6;
			end;
		     else do;
			name_fmt (0) = "^2x^a";	/* otherwise, indent 2 spaces, just for readability */
			name_fmt_ln (0) = 5;
			end;
		     end;				/* end of if ^prisw do group */
		end;				/* end of if linksw do group */
	     end;					/* end of if ^totalsw do group */

/* End of setting up of formats */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


/* Make adjustments for MSF/DMF ambiguity */

	msf_count = tcount (MSF) - dmf_count;
	tcount (MSF) = msf_count;
	msf_rec_count = trecs (MSF) + dmf_rec_count;
	trecs (MSF) = msf_rec_count;

/* Finished setting up. Now start printing the stuff */

	if totalsw then do;				/* if only totals being printed */
	     if noheadsw
	     then goto brief_totals;			/* inconsistent - but why quibble? */
	     else if bfsw
		then				/* this is the correct way to say it */
brief_totals:
		     do;				/* ls -tt -bf gets a very brief (one line) answer */
			do tx = 1 to 5;

			     msf_pass2 = (tx=3);
			     if msf_pass2 then do;
				tcount (MSF) = dmf_count;
				trecs (MSF) = dmf_rec_count;
				end;

			     tpix = type_ix (tx);	/* segs, dirs, msfs, links */
			     if tsws (tpix) then do;	/* if user wants info on this entry type */
				if tcount (tpix) = 0
				then hdng_index = tpix;
						/* "<entry type>=0;" */
				else do;
				     hdng_index = tpix + 4;
						/* "<entry type>=^d,recs=^d;" */
				     if ^real_record_sw
				     then		/* if printing lengths rather than records */
					if hdng_index >= 5
					then	/* and this is a branch (5, 6, or 7) */
					     hdng_index = hdng_index + 11;
						/* use one of the "lths=" headings (16, 17, or 18) */
						/* but note that 17 is just "Dirs=^d;" */
				     end;
				call print_heading;
				end;		/* end this type wanted do group */
			end;			/* end do loop on tpix */
			ioa_control_string = "";
			call print_message;		/* put newline onto end of brief total line */
			goto return;		/* all done */
		     end brief_totals;
		else goto start_list;		/* go print normal totals */
	     end;

	else if (noheadsw				/* if headers are not to be printed */
		| default_type) then do;		/* or if user did not specify type */
						/* make sure we are going to print some entries,
						   rather than nothing, or "<thing>s = 0" */
		do i = 0 to 3;
		     if tsws (i)
		     then				/* if user wants info on this type */
			if tcount (i) > 0
			then			/* and there are entries of this type */
			     goto start_list;	/* then something will be printed */
		end;
		if dmf_count > 0			/* special case DMFs here */
		then goto start_list;

		if default_type
		then				/* if user did not say "ls -<entry type>" */
		     tsws (0), tsws (1), tsws (2), tsws (3) = "1"b;
						/* simulate "ls -tt -a -bf" */
		goto brief_totals;			/* we were about to print nothing, or "<thing>s = 0" */
		end;

start_list:
	if branchsw then do;
	     if bc = 0 then do;
		ioa_control_string = "^/Branches = 0.";
		call print_message;
		end;
	     end;
	else if filesw then do;
		if tcount (SEG) + tcount (MSF) + dmf_count = 0 then do;
		     ioa_control_string = "^/Files = 0.";
		     call print_message;
		     end;
		end;

/* Readjust MSF count for next loop */

	tcount (MSF) = msf_count;
	trecs (MSF) = msf_rec_count;

/* Start outer loop on entry types */

type_loop:
	do tx = 1 to 5;
	     msf_pass2 = (tx=3);			/* second msf pass is for DMFs */
	     tpix = type_ix (tx);			/* list segs, msfs, dirs, and links, in that order */
	     if ^tsws (tpix) then goto end_type_loop;	/* if user does not want this entry type listed */
	     if tpix = MSF
	     then if msf_pass2
		then if ^pdmfilesw
		     then goto end_type_loop;
		     else;
		else if ^pmultisegsw
		     then goto end_type_loop;
		     else;
	     else;

	     type = bit (fixed (tpix, 2));

	     if msf_pass2 then do;
		tcount (MSF) = dmf_count;
		trecs (MSF) = dmf_rec_count;
		end;

	     if noheadsw then goto no_heading;
	     if tcount (tpix) = 0 then do;
		if allsw then goto no_heading;	/* don't print ...=0 when -all given */
		if tpix > 0 then do;		/* branches */
		     if branchsw then goto no_heading;	/* don't print ...=0 when -branch given */
		     if tpix ^= DIR
		     then				/* if not directories */
			if filesw then goto no_heading;
						/* don't print ...=0 when -files given */
		     end;				/* end branches */
		hdng_index = tpix + 8;		/* "^/<entry type> = 0." */
		call print_heading;
		end;				/* end count = 0 do group */

	     else do;				/* count ^= 0 */
		hdng_index = tpix + 12;		/* "^/<entry type> = ^d, Records = ^d.^2/" */
		if ^real_record_sw |		/* if printing lengths rather than records, or */
		     first > 0
		then				/* if just reading VTOCs of first N entries */
		     if hdng_index >= 13
		     then				/* and this is a branch (13, 14, or 15) */
			hdng_index = hdng_index + 6;	/* use the "Lengths =" headings (19, 20, or 21) */
						/* but note that 20 is just "Directories = ^d." */
		call print_heading;
		end;				/* end count ^= 0 */

no_heading:					/* come here to skip printing of heading */
						/* Decide whether we have to go through the entries, on this pass. */
	     if totalsw then goto end_type_loop;	/* if -totals given, don't print entries */

	     if tcount (tpix) = 0 then goto end_type_loop;/* if no entries of this type,
						   skip the inner loop to save time */

/* We will go through all the entries. Initialize for it. */

	     if branchsort then do;			/* if we sorted only on branches */
		if tpix = LINK then do;		/* links got put at the other end of the array */
		     first_et = first_lk;		/* so pick up indices of where they are */
		     last_et = last_lk;
		     end;
		else do;				/* this is a branch */
		     first_et = first_br;		/* pick up branch indices */
		     last_et = last_br;
		     end;
		end;				/* first_et and last_et are already set,
						   unless we sorted by branch only */

	     n_listed = 0;				/* this makes "-first N" list first N of each type */

/* Start inner loop on entries. Only those of the type specified in the outer loop will be listed. */

list_entries:
	     do i = first_et to last_et;
		ix = sort_ix (i);			/* pick up index of entry to be listed in position "i" */

		if br (ix).type ^= type
		then				/* if this entry is not the type we are listing now */
		     goto end_list_entries;		/* skip it */

		if tpix = MSF
		then if msf_pass2
		     then				/* we are reporting DMFs */
			if br (ix).records >= 0	/* so skip MSFs */
			then
			     goto  end_list_entries;
			else br (ix).records = -br (ix).records;
		     else				/* we are reporting MSFs */
			if br (ix).records < 0	/* so skip DMFs */
			then
			     goto end_list_entries;
			else;
		else;

		if first > 0
		then				/* if -first given */
		     if n_listed >= first
		     then				/* and we have already printed the first N of this type */
			goto end_type_loop;		/* get out of inner loop and start on next type */
		     else n_listed = n_listed + 1;

		ni = br (ix).nindex;		/* get index to start of name array for this entry */
		nnames = br (ix).nname;		/* pick up count of names for this entry */
		nn = ni + nnames - 1;		/* compute index of last name for this entry */

		if lnsw then do;			/* if listing nothing but names, special-case it */
		     if countsw
		     then				/* but if printing counts */
			if nnames > 1
			then			/* and count is nonzero */
			     goto not_just_names;	/* we can't special-case it */
		     ioa_control_string = "^a";
		     call print_name;
		     branch_fmt_ix = 1;		/* to select format for additional names */
		     goto additional_names;
		     end;

not_just_names:					/* Format date(s) for both branches and links, if they are to be printed */
		ia = 1;				/* dtm is valid for branches and links */
		if tpix ^= LINK then do;
		     ia = 2;			/* dtu is valid only for branches */
		     if read_vtoc_sw
		     then				/* if we have to read the VTOC */
			if ^got_all_branch_info
			then			/* and we did not do it in get_list */
			     if tpix ^= MSF
			     then			/* (which we definitely did for an MSF) */
				call get_branch_info (ix);
						/* do it now */
		     end;

		do ib = 1 to ia;
		     if colsw (ib)
		     then                               /* if this date is to be printed */
			cdate (ib) = date_time_$format (date_format, cv_fstime_ (et (ix).date (ib)), "", "");
		end;

/* If this is a branch, print branch info */

		if tpix ^= LINK then do;

		     if modesw then do;		/* if printing modes, format them */
			if (type = "10"b) & (msf_bc = 0)
			then			/* if directory */
			     mode_ptr = addr (dir_mode);
						/* use "sma" */
			else mode_ptr = addr (file_mode);
						/* else use "rew" */
			mode = "";		/* blank out the mode string */
			ia, ib = 1;		/* input, output indices start at 1 */
			string (mode_bits) = et (ix).mode;
						/* copy mode bits into word in stack */

mode_loop:
			if mode_bits (ia)
			then			/* if entry has this mode */
			     mode_array (ib) = et_mode (ia);
						/* put its character into the string */
next_col:
			ib = ib + 1;		/* move output column index */
			if ib = 4 then goto end_mode_loop;
						/* done, if we filled in 3 cols */
next_bit:
			ia = ia + 1;		/* move input bit index */
			if ia = 2 then do;		/* if bit 2 (e) */
			     if type = "10"b
			     then			/* if directory, e mode is not used */
				goto next_bit;	/* skip bit but not column */
			     end;
			goto mode_loop;		/* go back for next one */
end_mode_loop:
			end;

		     if recordsw
		     then				/* if records to be printed */
			records = br (ix).records;	/* pick up record count */

/* Pick up the format string for branches, built above. If printing counts,
   but this branch has only one name, chop the trailing "^2x(^d)" off the format,
   to avoid printing "(1)" after the primary name */

		     branch_fmt_ix = 1;		/* use the format string for files */
		     if tpix = DIR
		     then				/* unless this is a directory */
			if recordsw
			then			/* and the records column is in the file format string */
			     if ^real_record_sw
			     then			/* but real records are not being printed */
				branch_fmt_ix = 2;	/* then use format string that omits records column for dirs */

		     ia = branch_fmt_ln (branch_fmt_ix);/* don't chop off anything, by default */
		     if countsw
		     then				/* if printing counts */
			if nnames = 1
			then			/* but count = 1 */
			     ia = ia - 7;		/* chop off last 7 chars of format */

		     ioa_control_string = substr (branch_fmt (branch_fmt_ix), 1, ia);

		     call print_branch;		/* now go print the selected branch information */
		     end;				/* end of list branch information */

/* Otherwise it is a link, so print link info */

		else do;
		     if lkpathsw
		     then				/* if printing linkpaths */
			lp = addr (name (lk (ix).pnindex));
						/* get pointer to link pathname */

/* Pick up the format string for links. Choose one of the two that were built above,
   depending on whether name count is being printed, and how many names the link has */

		     ia = 1;			/* use the first format string */
		     if countsw
		     then				/* except when printing counts */
			if nnames = 1
			then			/* and the count = 1 */
			     ia = 2;		/* when the second format string must be used */
		     ioa_control_string = substr (link_fmt (ia), 1, link_fmt_ln (ia));

		     call ioa_ (ioa_control_string, cdtm, name (ni), nnames, substr (lkpath, 1, lk (ix).pln));
		     end;				/* end list link info */

additional_names:					/* do we want to print additional names ? */
		if ^prisw
		then				/* if user wants to see them */
		     if nnames > 1 then do;		/* and there are some, print them */

/* Pick up the name format constructed above */

			if tpix = LINK
			then			/* if this is a link */
			     ia = 0;		/* then use format (0) */
			else ia = branch_fmt_ix;	/* else use format (1) or format (2) */
			ioa_control_string = substr (name_fmt (ia), 1, name_fmt_ln (ia));
			do ni = (ni + 1) to nn;	/* ni is index of primary name, set above */
			     call print_name;
			end;
			end;

end_list_entries:
	     end list_entries;			/* end inner loop (on i) over all entries */

end_type_loop:
	end type_loop;				/* end outer loop (on tx) over the 4 entry types */

return:
	if ^totalsw
	then					/* if we printed some entries (not just totals) */
	     if ^noheadsw then do;			/* and user did not say -no_header */
		ioa_control_string = "";		/* print an extra blank line at the end */
		call print_message;
		end;

error_return:
	call cleanup_proc;				/* go free any allocated storage */

	return;					/* return to caller */

/* ****************************************************************************************************************** */
/**/


/* INTERNAL PROCEDURES, IN ALPHABETIC ORDER */
%page;

cleanup_proc:
     proc;					/* Cleanup handler */
dcl  dummy based;
dcl  i fixed bin;

	do i = 1 to hbound (aloc_ptr, 1);
	     if aloc_ptr (i) ^= null
	     then if aloc_ptr (i) ^= addr (stack_starnames) then free aloc_ptr (i) -> dummy in (system_free_area);
	end;

     end cleanup_proc;

/* ****************************************************************************************************************** */
%page;

get_arg_ptr:
     proc;					/* replaces 7 cu_$arg_ptr calls (105 words) */

	if argno > 1
	then					/* if there was a previous argument */
	     errname = targ;			/* save it for possible error message */

	call cu_$arg_ptr (argno, argptr, arglen, code);
	if code ^= 0 then do;			/* it can only be "expected argument missing" */
	     if argno > 1
	     then call com_err_ (code, "list", "after ""^a""", rtrim (errname));
	     else call com_err_ (code, "list");

	     goto error_return;                          /* call cleanup_proc internal procedure and quit. */
	     end;

	return;

     end get_arg_ptr;

/* ****************************************************************************************************************** */
%page;

get_branch_info:
     proc (ix);

dcl  ix fixed bin;
dcl  (temp_ep, temp_np) ptr;

	if ep -> br (ix).type = "00"b
	then					/* some times we get called for a link, by accident */
	     goto say_we_got_it;			/* when that happens, just return, to avoid clobbering anything */
	temp_ep = ep;				/* get pointer to array of directory entries */
	temp_np = np;				/* and their entry names */

get_info_common:
	call hcs_$status_ (dirname, temp_np -> name (temp_ep -> br (ix).nindex), (0), addr (branch), null (), code);
	if code ^= 0 then do;

	     if code = error_table_$logical_volume_not_connected | code = error_table_$logical_volume_not_defined
	     then	do;			          /* give up if pack not mounted */
		call com_err_ (code, "list", "^a", rtrim (dirname));
		goto error_return;                      /* call cleanup_proc internal procedure and quit */
		end;

	     errname = temp_np -> name (temp_ep -> br (ix).nindex);
	     call com_err_ (code, "list", "^a in ^a", rtrim (errname), rtrim (dirname));

	     code = 0;
	     goto say_we_got_it;			/* to avoid trying again later */
	     end;

	if real_record_sw then temp_ep -> br (ix).records = branch.records;

	if real_dtm_sw then temp_ep -> br (ix).dtm = branch.dtm;
						/* dtu is always the real thing */
	temp_ep -> br (ix).dtu = branch.dtu;

say_we_got_it:
	got_branch_info = "1"b;

	return;                                           /* return from get_branch_info */

/* ********** */

get_msf_records:
     entry (ix);

	temp_ep = msf_ep;				/* get pointer to array of msf components */
	temp_np = msf_np;				/* and their entry names */

	goto get_info_common;

     end get_branch_info;

/* ****************************************************************************************************************** */
%page;

get_date:
     proc (date, from_to);				/* procedure to pick up and convert -from and -to dates */
dcl  date bit (36) aligned;
dcl  from_to char (*);

dcl  1 clock aligned based,				/* the calendar clock is a 52-bit unsigned integer */
       2 pad bit (20) unaligned,			/* only the high-order 36 bits are kept in the file system */
       2 fstime bit (36) unaligned,			/* the truncation is 2**16 (=64K) microseconds (0.064 sec) */
       2 pad2 bit (16) unaligned;			/* leaving a value that is accurate within about 0.1 second */


	argno = argno + 1;
	call get_arg_ptr;
	call convert_date_to_binary_ (targ, fb71, code);
	if code ^= 0 then goto badarg;

/* The following code adjusts the from or to date as necessary, to make the
   date matching appear to be exact, to within the 0.1 minute accuracy with which
   file system date-times are printed. The problem is that every date-time value typed
   by the user will, if not adjusted somehow, be rounded down to the next lower
   tenth of a minute, by the truncation of its low order 16 bits during conversion
   to an fstime.

   The from date is adjusted upward to produce the smallest fstime that will convert
   to its corresponding date-time string (e.g. a date-time ending in 1800.0 might
   be adjusted upward to 1800.0271828, so that it still converts to 1800.0 after
   being truncated, instead of converting to 1759.9).

   The to date is adjusted upward to produce the largest fstime that will convert
   to its corresponding date-time string (e.g. 1800.0 might be adjusted upward
   to 1800.0999999, so that all date_times less than 1800.1 will compare <= to it,
   and be included in the listing). */

	fb71 = fb71 - mod (fb71, 6000000);		/* first, round down to an exact 0.1 minute */

	if from_to = "to" then do;			/* adjust to-date upward to next tenth of a minute */
	     fb71 = fb71 + 6000000;			/* in the unlikely event that this leaves 16 trailing zero bits */
	     fb71 = fb71 - 10000000000000000b;		/* truncation will not decrease its value  */
	     end;					/* so subtract 1 from fstime, and fall thru, to add it */
						/* back again, except when value ends in 16 zero bits. */
						/* ... */
						/* For both from and to dates, */
	if string (addr (fb71) -> clock.pad2) ^= ""b
	then					/* if there are any nonzero bits that will be truncated, */
	     fb71 = fb71 + 10000000000000000b;		/* add 1 to fstime. */

	date = addr (fb71) -> clock.fstime;		/* convert 52-bit date to 36-bit date */

	return;
     end get_date;

/* ****************************************************************************************************************** */
%page;
get_list:
     procedure;					/* procedure to list directory, do star matching, and sorting */

dcl  type fixed bin;
dcl  pbl fixed bin (3);

dcl  bitcnt fixed bin (24);
dcl  dirname_len fixed bin;
dcl  msename char (32);

dcl  dir_ix fixed bin;
dcl  name_ix fixed bin;
dcl  star_ix fixed bin;

dcl  br_ix fixed bin;
dcl  lk_ix fixed bin based (lk_ix_ptr);
dcl  lk_ix_ptr ptr;
dcl  lk_ix_automatic fixed bin;
dcl  ix_inc fixed bin;
dcl  f_t_ix fixed bin;
dcl  match_ix fixed bin;
dcl  action fixed bin;
dcl  (first_name, last_name) fixed bin;

dcl  include_match bit (1) aligned;
dcl  matched bit (1) aligned;
dcl  count_other_types bit (1) aligned;
dcl  check_msf_sw bit (1) aligned;
dcl  skip_it bit (1) aligned;
dcl  all_starnames_matched bit (1) aligned;
dcl  from_to_found bit (1) aligned;

/* Get full pathname of directory to be listed */

	call absolute_pathname_ (substr (path, 1, pathl), dirname, code);
						/* if -pn not given, pathl=0, which implies working_dir */
						/* arg4 = null means put full path in dirname */
	if code ^= 0 then do;
	     error_flag = "1"b;                           /* set error flag before return to the caller */

	     call com_err_ (code, "list", "^a", rtrim (path));
	     return;
	     end;

	dirname_len = index (dirname, " ");		/* find first vacant char */

/* Set up for, and call, hcs_$star_list */
	pbl = 3;					/* request branches and links no matter what user wants, so we
						   can handle "not found" and "directory empty" consistently. */
	if linksw
	then					/* check for link option */
	     if lkpathsw
	     then					/* if linkpaths wanted */
		if ^totalsw
		then				/* and they really will be printed */
		     pbl = pbl + 4;			/* ask star_list to return them */
	call star_list (dir_bc, dir_lc, ep, np);	/* go call hcs_$star_list */

	if code ^= 0 then do;
	     error_flag = "1"b;			/* set error flag before return to the caller */

	     if code = error_table_$nomatch then do;	/* since we said "**" this is an empty directory */
		ioa_control_string = "Directory empty: " || rtrim (dirname);

		call print_message;			/* write on user_output, not error_output */
		end;
	     else call com_err_ (code, "list", "^a", rtrim (dirname));

	     return;
	     end;					/* end code ^= 0 */

	dir_ec = dir_bc + dir_lc;			/* compute total entries (branches + links) */

/* Allocate array in which to put indices that select entries. It can hold all the entries (it is dir_ec elements long) */
	allocate sort_ix in (system_free_area) set (sort_index_ptr);

/* Initialize for pass through all entries in directory, selecting those to be listed */

	if branchsort then do;			/* if we will sort by a branch-only item */
	     lk_ix_ptr = addr (lk_ix_automatic);	/* put links out of the way, at the other end of the array */
	     first_br, first_et = 1;			/* first_et and last_et specify the entries to be sorted */
	     last_br, last_et = dir_bc;		/* later, they will be set to specify the entries to be printed */
	     first_lk = last_br + 1;
	     last_lk = dir_ec;
	     end;

	else do;					/* otherwise intermix branches and links */
	     lk_ix_ptr = addr (br_ix);		/* by having br_ix and lk_ix actually be the same word */
	     first_br, first_lk, first_et = 1;
	     last_br, last_lk, last_et = dir_ec;
	     end;

/* hcs_$star_list returns entries in the order created, oldest first.
   By default, we want to list them in the reverse of that order, newest first.
   Therefore we fill in the sort_ix array from right to left (reverse order),
   unless the user said -reverse, in which case we fill it in from left to right. */

	if revsw then do;				/* if reverse, fill it in left to right */
	     br_ix = first_br - 1;			/* set indices to left of first entry */
	     lk_ix = first_lk - 1;
	     ix_inc = 1;				/* and increment to the right */
	     end;

	else do;					/* fill it in from right to left */
	     br_ix = last_br + 1;			/* set indices to right of last entry */
	     lk_ix = last_lk + 1;
	     ix_inc = -1;				/* and increment to the left */
	     end;

/* Set some switches */
	if default_type
	then					/* if user did not give any entry type arguments */
	     count_other_types = "1"b;		/* we want to be able to say "Files = 0. Links = N" */
	else count_other_types = "0"b;		/* if that happens. (Suggested by Jerry Saltzer) */

	check_msf_sw = "1"b;			/* usually have to check all dirs to see if really msfs */
	if ^tsws (DIR)
	then					/* but if not listing dirs */
	     if ^tsws (MSF)
	     then					/* or msfs */
		check_msf_sw = "0"b;		/* we don't care, so skip it and save time */

	if from_to_date_ix > 0
	then from_to_found = "0"b;			/* this is analogous to the matched switch for each starname */
	else from_to_found = "1"b;			/* it lets us say why nothing is being listed, if that happens */

	if starname_count > 0
	then					/* if any starnames were given, we will check later */
	     all_starnames_matched = ""b;		/* to be sure they were all matched */
	else all_starnames_matched = "1"b;		/* if none given, skip over those checks */

/* Go thru all entries in directory, doing star matching and other testing, to determine which ones will be listed */

	do dir_ix = 1 to dir_ec;
	     type = bin (br (dir_ix).type);		/* pick up entry type */

/* Note that we have not yet separated msfs from directories. We put that off as long as possible */

/* Try to eliminate each entry as early as possible. Start with cheapest tests. */

	     skip_it = "0"b;			/* assume entry will be listed, until we find a reason not to */
	     got_branch_info = ""b;			/* we have not read the VTOC for this branch yet */

/* First, try to eliminate on basis of type */

	     if ^check_msf_sw
	     then					/* if not listing dirs or msfs */
		if ^count_other_types
		then				/* and not counting them either */
		     goto check_type;		/* we could eliminate dirs without making msf check */
	     if type ^= DIR
	     then					/* otherwise we can't eliminate dirs, 'cause they might be msfs */
check_type:
		if ^tsws (type)
		then				/* if we are not listing this type */
		     if ^count_other_types
		     then				/* and not counting unlisted types */
			skip_it = "1"b;		/* we can probably skip the rest of the tests */

/* Next, try from-to dates, if given */

	     if skip_it
	     then					/* but get out of it if we can */
		if from_to_found
		then				/* if entries within given dates found (or none were given) */
		     goto skip_date_check;		/* then we can get out of it */
						/* otherwise we must check, to be able to print right err. msg. */

	     if from_to_date_ix > 0 then do;		/* if either from or to was given */
		if type = LINK
		then				/* links have only DTM */
		     f_t_ix = DTM;
		else				/* branches have both */
		     f_t_ix = from_to_date_ix;	/* and which one to use was decided earlier */

		if type ^= LINK
		then				/* if a branch */
		     if f_t_ix = 2 | real_dtm_sw then do;
						/* if using a date from the VTOC */
			call get_branch_info (dir_ix);
			got_all_branch_info = "1"b;	/* we will have, by the time we're through */
			end;

		if fromsw
		then if et (dir_ix).date (f_t_ix) < from_date then do;
			skip_it = "1"b;
			goto skip_date_check;
			end;
		if tosw
		then if et (dir_ix).date (f_t_ix) > to_date then do;
			skip_it = "1"b;
			goto skip_date_check;
			end;
		from_to_found = "1"b;		/* at least one entry fell within the from-to dates */
		end;
skip_date_check:					/* Finally, try star matching */
	     if starname_count = 0
	     then					/* get out of it if we can */
		if skip_it
		then goto skip_entry;
		else goto keep_entry;

	     if skip_it
	     then					/* if we already know we are skipping this entry */
		if all_starnames_matched
		then				/* and  we don't need to check for starnames not found */
		     goto skip_entry;		/* skip over star matching to save time */

	     all_starnames_matched = "1"b;		/* gets turned off if we fail to match an unmatched starname */

/* We will start comparing all the names of the entry with all the given starnames,
   but stop as soon as we know whether or not to list this entry. */

	     if includesw
	     then					/* if any INCLUDE starnames were given */
		include_match = "0"b;		/* we have to turn this on by matching one of them */
	     else include_match = "1"b;		/* else pretend we matched one */

/* Make starnames the outer loop for efficiency, in case the plan to optimize
   match_star_name_ for repeated calls using the same starname is ever implemented. */

	     do star_ix = 1 to starname_count;		/* go thru all starnames */
		action = starnames (star_ix).action;	/* code might not be that much better */
		matched = starnames (star_ix).matched;	/* but "action" and "matched" are easier to type */

		if action = EXCLUDE
		then				/* if this is an exclude starname */
		     if skip_it
		     then				/* and we already know we are skipping this entry */
			goto next_starname;		/* save time by skipping inner loop */

/* Inner loop on names of entry */

		first_name = br (dir_ix).nindex;
		last_name = first_name + br (dir_ix).nname - 1;

		do name_ix = first_name to last_name;
		     if action = EXCLUDE then do;
			if names_match ()
			then			/* internal procedure to match the various types of starname */
			     skip_it = "1"b;	/* if they match, exclude this entry */
			end;

		     else do;			/* action must = INCLUDE */
			if ^matched then goto try_include_match;
						/* if starname never been matched, keep trying */
			if ^skip_it
			then			/* if we have not already decided to skip this entry */
			     if ^include_match
			     then			/* but it hasn't matched any INCLUDE starname yet */
try_include_match:
				if names_match () then do;
						/* go see if this one matches */
				     include_match = "1"b;
						/* and remember it, if it matches */
				     starnames (star_ix).matched = "1"b;
						/* some entry matched this starname */
				     goto next_starname;
						/* no need to look at rest of entrynames */
				     end;
			end;
		end;				/* end inner loop on names of entry */

		if ^starnames (star_ix).matched
		then				/* if this starname has never been matched */
		     all_starnames_matched = "0"b;	/* remember to keep trying to find a match for it */

next_starname:
	     end;					/* end outer loop on starnames */

	     if skip_it then goto skip_entry;		/* if we found a positive reason for skipping it */
	     if ^include_match then goto skip_entry;	/* or if it just did not match any of the INCLUDE starnames */

/* come here if we THINK we want to keep the entry (still not completely sure) */

keep_entry:
	     if type = DIR
	     then				          /* if a directory made it through all the above */
		call check_for_msf (type);		/* we can't get out of checking to see if it's an msf */

	     if ^tsws (type)
	     then					/* if not listing this type */
		if ^count_other_types
		then				/* and not counting other types */
		     goto skip_entry;		/* skip the following to save time */

/* This entry will be listed (or maybe just counted). Increment counts, and put its index into sort_ix array */

	     tcount (type) = tcount (type) + 1;		/* count entries of this type */

	     if tsws (type) then do;			/* if we are really going to list it */
		count_other_types = "0"b;		/* we no longer have to count other types (if we were doing so) */
		ec = ec + 1;			/* count number of entries really being listed */

/* This do group implements -match */

		if matchsw
		then				/* if only matching names are to be printed */
		     if br (dir_ix).nname > 1 then do;	/* and this entry has multiple names */
			match_ix = br (dir_ix).nindex;/* get index of its first name */
			do name_ix = match_ix to match_ix + br (dir_ix).nname - 1;
						/* go thru entry names */
			     do star_ix = 1 to starname_count;
						/* go thru starnames */
				if starnames (star_ix).action ^= EXCLUDE
				then		/* except for EXCLUDE names */
				     if names_match () then do;
						/* if name matches, keep it */
					if match_ix < name_ix
					then	/* if we removed any previous names */
					     name (match_ix) = name (name_ix);
						/* move this one up */
					match_ix = match_ix + 1;
						/* move index to next vacant position */
					goto kept_name;
						/* get out of loop on starnames */
					end;	/* end of "keep this name" do group */
			     end;			/* end loop on starnames */
kept_name:
			end;			/* end loop on entry names */
			br (dir_ix).nname = match_ix - br (dir_ix).nindex;
						/* save new name count */
			end;			/* end implementation of -match */
		end;				/* end of "really going to list it" do group */

/* Increment counters, and store index, for branch or link, whichever this is */

	     if type = LINK then do;
		if tsws (LINK) then do;		/* if we are really listing links and not just counting them */
		     lk_ix = lk_ix + ix_inc;
		     sort_ix (lk_ix) = dir_ix;	/* then store the index of this one */
		     lc = lc + 1;			/* and increment the really-being-listed counter for links */
		     end;
		end;

	     else do;				/* branch */

/* We want to avoid unnecessary VTOC reading. If a VTOC item is to be printed but -first N was given,
   we can sometimes get away with reading the VTOCEs of only the first N entries. If real records are to
   be printed, we can compute the total lengths from the bitcounts, for printing in the header, to avoid
   reading all the VTOCEs. Although this makes the figure printed in the header inconsistent, in a sense, with
   the figures printed for each entry, the saving is worth it - and the total length figure printed when
   -first N is given is not very useful anyway - only the total entries figure is interesting in that case.

   However, if we have to sort by a VTOC item before we can determine which are the first N entries
   to be listed, we might as well read the VTOCEs now, and print a correct total records figure in the heading.

*/

		if first = 0 | sort_vtoc_sw
		then				/* if -first not given, or sorting by VTOC item */
		     if real_record_sw
		     then				/* and real records are to be printed */
			if ^got_branch_info then do;	/* if we haven't already read the vtoc, do it now */
			     call get_branch_info (dir_ix);
						/* before updating total records */
			     got_all_branch_info = "1"b;
						/* we will have, before we're through */
			     end;

		trecs (type) = trecs (type) + br (dir_ix).records;
						/* count records even if just counting */
		if tsws (type) then do;		/* but if really listing this type */
		     br_ix = br_ix + ix_inc;
		     sort_ix (br_ix) = dir_ix;	/* then store the index of this one */
		     bc = bc + 1;			/* and increment the really-being-listed counter for branches */
		     end;
		end;
skip_entry:
	end;					/* end loop on all entries */

/* Tell user if anything was not found. */

	if ^from_to_found then do;
	     error_flag = "1"b;                           /* set error flag before return to the caller */

	     errname = "Entries within given dates";	/* "Entries within given dates not found" */
	     call print_not_found;
	     return;
	     end;


	if ^all_starnames_matched then do;		/* if there were any unmatched starnames */
						/* tell user, and check for nothing to list */

	     if includesw
	     then					/* if any include starnames were given */
		include_match = "0"b;		/* assume none matched, until we find one that did */
	     else include_match = "1"b;		/* else pretend "**" was given, which always matches */

	     do star_ix = 1 to starname_count;		/* look at all starnames */
		if starnames (star_ix).action ^= EXCLUDE then do;
						/* except EXCLUDE names */
		     if ^starnames (star_ix).matched then do;
						/* if it was never matched */
			errname = starnames (star_ix).name;

			if starnames (star_ix).type = 0
			     then starname_count = 0; /* because no starname is specified */

			call print_not_found;	/* "<starname> not found" */
			end;
		     else				/* if an INCLUDE name was matched */
			include_match = "1"b;	/* remember that we found one that was */
		     end;
	     end;

	     if ^include_match then do;		/* if no INCLUDE names were matched */
		error_flag = "1"b;			/* nothing will be printed */
		return;
		end;
	     end;

	if error_flag then return;			/* quit now if nothing to list */
	if ec = 0 then return;			/* or if only "<thing>s = 0" messages to print */

/* Compute and store positions of the sets: branches, and links, in the sort_ix array,
   for use by sort, and by main printing loop */

	if branchsort then do;			/* if we put links at the other end of the array */
	     if revsw then do;			/* if array was filled in left to right */
		last_et, last_br = br_ix;
		last_lk = lk_ix;
		end;
	     else do;				/* it was filled in right to left */
		first_et, first_br = br_ix;
		first_lk = lk_ix;
		end;
	     end;

	else do;					/* links and branches mixed */
	     if revsw
	     then last_et, last_br, last_lk = br_ix;	/* left to right */
	     else first_et, first_br, first_lk = br_ix;	/* right to left */
	     end;

	if sort_vtoc_sw
	then					/* if sorting by a vtoc item */
	     if ^got_all_branch_info then do;		/* and we have not read the VTOCs yet */
		do dir_ix = first_br to last_br;	/* do so now */
		     call get_branch_info (sort_ix (dir_ix));
		end;
		got_all_branch_info = "1"b;		/* remember not to do it again */
		end;
	if sortsw then call shell_sort;		/* default */

	return;					/* normal return from get_list */

/* ********** */
%page;

/* Note that these internal procedures are internal to get_list */

check_for_msf: proc (para_type);

/* procedure to see if a dir is really an msf, and if it is, count up     */
/* records used by its components, msf_ep and msf_np are declared in      */
/* the main procedure, so the cleanup handler can access them.            */

dcl para_type fixed bin parameter;

dcl MSF_COMPONENT_ZERO fixed bin static options (constant) init (0);

dcl  msf_lc fixed bin;
dcl  xcode fixed bin (35);				/* for local status processing */
dcl  msf_dir_count fixed bin init (0);
dcl  msf_rec_count fixed bin;				/* no need to init this - it starts out = rec count of dir */
dcl  k fixed bin;
dcl (raw_mode, ex_mode) bit (36) aligned;
dcl temp_dir_ec fixed bin;                                  /* for MSF, this variable temporarily holds the dir_ec value to avoid */
                                                            /* subcriptrange in et array after updating dir_ec in star_list */

dcl component_name char (32) varying;
dcl msf_last_component fixed bin;
dcl msf_index fixed bin;

dcl 1 msf_info aligned,				/* status for MSF components */
     2 type bit (2) unaligned,
     2 nnames bit (16) unaligned,
     2 names_offset bit (18) unaligned,
     2 dtcm bit (36) unaligned,
     2 dtu bit (36) unaligned,
     2 mode bit (5) unaligned,
     2 pad bit (13) unaligned,
     2 records fixed bin (17) unaligned,
     2 dtd bit (36) unaligned,
     2 dtem bit (36) unaligned,
     2 pad3 bit (36) unaligned,
     2 current_length fixed bin (11) unaligned,
     2 bit_count bit (24) unaligned,
     2 pad2 bit (18) unaligned,
     2 rbs (0:2) fixed bin (5) unaligned,
     2 pad4 bit (36) unaligned;

dcl hcs_$status_long entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35));

dcl (convert, ltrim) builtin;
	
                                                            /* set variables to initial values to avoid unexpected values */
	     temp_dir_ec = 0;
	     msf_bc = 0;

	     msename = name (br (dir_ix).nindex);	/* pick up its name, for status_minf call */

	     call hcs_$status_minf (dirname, msename, 0, (0), bitcnt, xcode);
	     if xcode = 0
	     then					/* Could have disappeared, if so say it's a dir */
		if bitcnt ^= 0 then do;		/* non-zero bit-count indicates multi-segment-file */

		     if ^tsws (MSF) then goto set_msftype;
						/* if not listing msfs, don't count recs, just set type */

		     if read_vtoc_sw
		     then				/* if using anything from vtoc, possibly including records */
			if ^got_branch_info
			then			/* and we have not already read the VTOC */
			     call get_branch_info (dir_ix);
						/* do it, before computing msf size */
		     msf_rec_count = br (dir_ix).records;
						/* get size of msf directory */

						/* build pathname of msf dir for star_list call */
		     substr (dirname, dirname_len, 1) = ">";
		     substr (dirname, dirname_len + 1, 32) = msename;
		     pbl = 2;			/* branches only */
		     temp_dir_ec = dir_ec;
		     
		     call star_list (msf_bc, msf_lc, msf_ep, msf_np);
		     if code ^= 0 then do;		/* Check for errors */
			if code ^= error_table_$nomatch
			then if code ^= error_table_$null_dir then do;
				call file_manager_$validate (substr (dirname, 1, dirname_len-1), msename, xcode);
				if xcode ^= 0
				then do;
				     msf_rec_count = 0;
				     code = 0;
				     end;
				else do;
				     dmf_count = dmf_count + 1;
				     dmf_rec_count = dmf_rec_count + br (dir_ix).records;
				     msf_rec_count = -br (dir_ix).records;
				     call fs_util_$get_user_access_modes (substr (dirname, 1, dirname_len-1), msename, "",
					- 1, raw_mode, ex_mode, xcode);
				     if xcode = 0 then et (dir_ix).mode = substr (raw_mode, 1, 3);
				     end;
				end;
			goto msfempty;
			end;
		     else do;
			                              /* extract the mode of a MSF from the mode of MSF component 0 */
		          call hcs_$get_user_access_modes (dirname, "0", "", -1,
			     raw_mode, ex_mode, xcode);
			if xcode = 0 then do;
			     dir_ec = temp_dir_ec;    /* restore the limit index of et array which was saved earlier */

			     et (dir_ix).mode = substr (raw_mode, 1, 3);
			     end;

			if msf_bc > 0 then do;
                                                            /* currently, got MSF directory's dtm and dtu values. */
                                                            /* But we want MSF component's dtm and dtu information. */
                                                            /* So, must reset these flags before loading MSF component's dtm and dtu */
			     br (dir_ix).dtm = "0"b;
			     br (dir_ix).dtu = "0"b;

			     msf_last_component = msf_bc - 1;
			     do msf_index = MSF_COMPONENT_ZERO to msf_last_component;

                                                           /* call hcs_$status_long to get most user_accessible informattion */
                                                           /* about a specified MSF component */
			                             /* if the returned code is not zero in value then go get */
                                                           /* the next msf component.  Do not return to the caller. */
				component_name = convert (component_name, msf_index);
				component_name = ltrim (component_name);

				call hcs_$status_long (dirname, (component_name), 1, addr (msf_info), null, code);
				if code = 0
				then do;
				     if real_dtm_sw
				     then do;
					if fixed (msf_info.dtcm) > fixed (br (dir_ix).dtm)
					then br (dir_ix).dtm = msf_info.dtcm;
					end;

				     if dtem_arg_sw
				     then do;
					if fixed (msf_info.dtem) > fixed (br (dir_ix).dtm)
					then br (dir_ix).dtm = msf_info.dtem;
					end;

				     if fixed (msf_info.dtu) > fixed (br (dir_ix).dtm)
				     then br (dir_ix).dtu = msf_info.dtu;
				     end;
				end;               /* go get the next MSF component */
			     end;                    /* specified entryname is a MSF */
			end;                         /* else do */

		     do k = 1 to msf_bc;
                                                           /* if msf contains director(y ies) then count how many */
			if msf_ep -> br (k).type = "10"b
			then msf_dir_count = msf_dir_count + 1;

				                   /* if using real records then go read vtoc of msf component */
			if real_record_sw
			then call get_msf_records (k);

					        /* add up length of this msf component */
			msf_rec_count = msf_rec_count + msf_ep -> br (k).records;
	               end;

		     if msf_dir_count > 0 then do;	/* if msf contained director(y ies) */
			code = 0;
			call com_err_ (code, "list", "Multisegment-file: ^a contains director^[y^;ies^].", rtrim (msename), msf_dir_count = 1);
			end;

		     free msf_ep -> br in (system_free_area);
		     free msf_np -> name in (system_free_area);

msfempty:
		     substr (dirname, dirname_len, 33) = "";
						/* blank out msf name */
		     br (dir_ix).records = msf_rec_count;
						/* store total msf length */

set_msftype:
                                                            /* set type to msf in the branch array entry for this branch */
		     br (dir_ix).type = bit (fixed (MSF, 2));
		     para_type = 3;			/* also set the variable used by the caller (get_list) */
		     end;				/* end it-was-an-msf do group */

	     return;
	end check_for_msf;

/* ********** */
%page;

in_order:
	proc (ix1, ix2) returns (bit (1) aligned);

dcl  (ix1, ix2) fixed bin;

	     goto comparison (sort_key);		/* go compare the thing to be sorted on */

comparison (1):					/* dtm */
						/* normal order for dates is high to low (newest to oldest) */
	     if br (ix2).dtm > br (ix1).dtm
	     then					/* if they are reversed */
		goto items_reversed;
	     else goto items_in_order;

comparison (2):					/* dtu */
						/* normal order for dates is high to low (newest to oldest) */
	     if br (ix2).dtu > br (ix1).dtu
	     then goto items_reversed;
	     else goto items_in_order;

comparison (3):					/* mode */
						/* it is not clear what the right order for modes is */
	     if string (br (ix1).mode) > string (br (ix2).mode)
	     then					/* but this puts null (blank) first */
		goto items_reversed;		/* rew or sma last */
	     else if string (br (ix2).mode) = string (br (ix1).mode)
		then				/* and rw before re */
		     goto return_in_order;		/* if equal, do not reorder */
		else goto items_in_order;

comparison (4):					/* records */
						/* normal order for records is high to low (large to small) */
	     if br (ix2).records > br (ix1).records
	     then					/* if they are out of order */
		goto items_reversed;		/* go see if we want them that way */
	     else if br (ix2).records = br (ix1).records
		then				/* check for equality (which is likely with records) */
		     goto return_in_order;		/* if equal, do not reorder */
		else goto items_in_order;

comparison (5):					/* name */
						/* normal order for names is low to high (a to z) */
	     if name (br (ix1).nindex) > name (br (ix2).nindex)
	     then					/* if they are reversed */
		goto items_reversed;		/* go see if we want them that way */
	     else goto items_in_order;		/* names will never be equal */

comparison (6):					/* count */
						/* normal order for count is high to low (most names to fewest) */
	     if br (ix2).nname > br (ix1).nname
	     then					/* if they are reversed */
		goto items_reversed;
	     else if br (ix2).nname = br (ix1).nname
		then				/* if they are equal */
		     goto return_in_order;		/* if equal, do not reorder */
		else goto items_in_order;


items_reversed:
	     if revsw
	     then goto return_in_order;
	     else goto return_out_of_order;

items_in_order:
	     if revsw
	     then
return_out_of_order:
		return ("0"b);
	     else
return_in_order:
		return ("1"b);

	end in_order;

/* ********** */
%page;

/* The code in this internal procedure could be written more compactly as something like
   the following, which more closely resembles the Knuth algorithm (see comments in shell_sort).
   However, the generated code would waste a lot of time doing bookkeeping, as
   noted in the comments, and that overhead has been avoided by the hand-coded
   logic that has been used.
*/

/*     do j = first_et+h to last_et;			/* add h to first_et to get j */
/*	ix2 = sort_ix (j);				/* */
/*	do i = j-h repeat i-h			/* subtract h each time around the loop */
/*	   while (i >= first_et			/* if i<first_et, sort_ix(i) is garbage, but pl1 keeps */
/*						/* evaluating "and" expressions after finding a false term */
/*	   & ^in_order (sort_ix (i), ix2));		/* if in order on first try, all the do loop bookkeeping */
/*						/* was a waste of time */
/*	   sort_ix (i+h) = sort_ix (i);		/* add h back again */
/*	end;					/* */
/*	sort_ix (i+h) = ix2;			/* add h back again */
/*     end;					/* */

%page;
insertion_sort:
	proc (h);

dcl  h fixed bin;					/* >1 for early shell sort passes */

dcl  (i, j, k) fixed bin;
dcl  (ix1, ix2) fixed bin;

	     i = first_et;				/* position of first entry in sort_ix */
	     ix1 = sort_ix (i);			/* index of first entry */

	     do j = first_et + h to last_et;		/* look at each entry to right of first */
		k = j;				/* remember its (soon to be vacant) position */
		ix2 = sort_ix (j);			/* pick up its index */

compare:
		if ^in_order (ix1, ix2) then do;	/* if it's not in order with the one on its left */
		     sort_ix (k) = ix1;		/* move the latter to the right, into the vacant position */
		     k = i;			/* the vacant position is now where we moved it from */
		     i = i - h;			/* look further to the left */
		     if i >= first_et then do;	/* if not past left end of array, keep going */
			ix1 = sort_ix (i);		/* pick up index of new entry */
			goto compare;		/* and go compare it with one we're trying to find a place for */
			end;			/* fall thru if at left end of array */
		     end;				/* fall thru if it's in order with the one on the left */

		if j ^= k then do;			/* save time by doing this only if we moved something */
		     sort_ix (k) = ix2;		/* store it in the vacant spot */
		     ix1 = sort_ix (j);		/* index of entry to left of next sort_ix(j) */
						/* (if at top of loop, would be "ix1=sort_ix(j-h)") */
		     end;
		else ix1 = ix2;			/* if we did not move anything */
		i = j;				/* index of entry to left of next sort_ix(j) */
						/* (if at top of loop, would be "i=j-1") */
	     end;					/* end loop on j. go back for next one to the right */

	     return;
	end insertion_sort;

/* ********** */
%page;
names_match:
	proc returns (bit (1) aligned);		/* procedure to see if one starname matches one entry name */
						/* implicit arguments are star_ix and name_ix */
dcl  star_code fixed bin (35);

	     if starnames (star_ix).type = DOUBLE_STAR
	     then goto match;

	     else if starnames (star_ix).type = ENTRY_NAME then do;
		     if starnames (star_ix).name = name (name_ix) then goto match;
		     end;


		else do;				/* must be regular starname */
		     call match_star_name_ (name (name_ix), starnames (star_ix).name, star_code);
		     if star_code = 0 then goto match;
		     end;

nomatch:
	     return ("0"b);				/* no match */
match:
	     return ("1"b);
	end names_match;

/* ********** */
%page;
shell_sort:
	proc;

dcl  (n, incr, next_incr) fixed bin;

/* This sorting algorithm is taken from Knuth, The Art of Computer Programming,
   Volume 3, "Sorting and Searching", pp. 80-95 and p. 379.
   The Shell sort is Algorithm 5.2.1D (Diminishing increment sort) on p. 85.
   The internal procedure, insertion_sort (see above) is the inner loop of 5.2.1D,
   which also happens to be Algorithm 5.2.1S (Straight insertion sort),
   generalized for use as the inner loop of the Shell sort.

   The increment computation is taken from equation (8) on p 95:

   "Let h(1)=1, h(s+1) = 3*h(s)+1, and stop with h(t) when h(t+2) >= N. (8)"

   we use incr for h(s),
   next_incr for h(s+1),
   and we stop with next_incr=h(t+2) and incr=h(t+1),
   but then we decrement from h(t+1) to h(t) before the first call to insertion_sort.

*/

	     n = last_et - first_et + 1;		/* compute number of entries to be sorted */
	     incr = 4;				/* compute initial increment */
	     next_incr = 13;			/* the first few are: 1,4,13,40,121,364,1092,3820,9841 */
	     do while (next_incr < n);		/* Knuth recommends the Shell sort for up to 1000 items (p.379) */
		incr = next_incr;			/* directories with more than 1000 items are very rare */
		next_incr = 3 * next_incr + 1;	/* (if not completely non-existent) */
	     end;					/* so 121 will be the largest increment used */

	     do while (incr > 1);			/* the last insertion sort is done with incr = 1 */
		incr = divide (incr - 1, 3, 17, 0);	/* decrease incr from h(s) to h(s-1) */
		call insertion_sort (incr);		/* do an insertion sort using that increment */
	     end;					/* if we just sorted with incr = 1, the array is in order */
	     return;
	end shell_sort;

/* ********** */
%page;
star_list:
	proc (star_bc, star_lc, star_ep, star_np);	/* replaces 2 hcs_$star_list calls (80 words) */

dcl  (star_bc, star_lc) fixed bin;
dcl  (star_ep, star_np) ptr;
dcl  i fixed bin;

	     call hcs_$star_dir_list_ (dirname, "**", pbl, system_free_ptr, star_bc, star_lc, star_ep, star_np, code);
	     if code = 0
	     then do;				/* caller checks code so just avoid referencing bad ptrs here */
	          dir_ec = star_bc + star_lc;
		do i = 1 to star_bc + star_lc;
		     if star_ep -> br (i).type ^= "00"b
		     then				/* if not link */
			star_ep -> br (i).records = divide (star_ep -> br (i).records + 36863, 36864, 24, 0);
		     end;
		end;
	     return;
	end star_list;

     end get_list;

/* ****************************************************************************************************************** */
%page;

get_starname:
     proc;					/* procedure to pick up, interpret, and store, a starname */


	if starptr = addr (stack_starnames)
	then					/* if we are still using the stack starnames array */
	     if starname_count = hbound (stack_starnames, 1) then do;
						/* but we have run out of room in it */
		alloc_len = nargs - argno + 5;	/* allocate a bigger one - with enough room for this arg, the
						   first 4, and all the rest, in case they are all starnames */

		allocate starnames in (system_free_area) set (starptr);
		do i = 1 to hbound (stack_starnames, 1);
		     starnames (i) = addr (stack_starnames) -> starnames (i);
		end;
		end;

	starname_count = starname_count + 1;
	starnames (starname_count).type = 0;
	starnames (starname_count).action = 0;
	starnames (starname_count).matched = "0"b;

	if search (targ, "<>") > 0 then do;		/* see if it is a pathname */
	     call expand_pathname_ (targ, dirname, starnames (starname_count).name, code);
	     if code ^= 0 then goto badarg;
	     if pathsw
	     then					/* if a directory path already given */
		if path ^= dirname
		then				/* and this one is different */
		     goto two_pn_error;		/* go complain */
	     path = dirname;			/* save directory path */
	     pathsw = "1"b;				/* remember that we got one */
	     pathl = length (rtrim (path, " "));
	     starnames (starname_count).length = length (rtrim (starnames (starname_count).name, " "));
	     if path = ">" & starnames (starname_count).length = 0 then do;
		code = error_table_$root;
		goto badarg;
		end;
	     end;

	else do;
	     starnames (starname_count).name = targ;
	     starnames (starname_count).length = arglen;
	     end;

	if starnames (starname_count).length > 32 then do;
	     code = error_table_$bigarg;
	     goto badarg;
	     end;

	call check_star_name_$entry (starnames (starname_count).name, code);
	if code > DOUBLE_STAR then goto badarg;		/* bad starname - code will produce message */
	starnames (starname_count).type = code;

	return;
     end get_starname;

/* ****************************************************************************************************************** */
%page;

print_branch:
     proc;					/* replaces 4 ioa_ calls (122 words) */
	call ioa_ (ioa_control_string, cdtm, cdtu, mode, records, np -> name (ni), nnames);

	return;
     end print_branch;

/* ****************************************************************************************************************** */
%page;

print_heading:
     proc;					/* replaces 12 ioa_ calls (200 words) */
	if msf_pass2
	then
	     ioa_control_string = rtrim (dmf_control_string (hdng_index));
	else
	     ioa_control_string = substr (string (hdng), hdng_offset (hdng_index), hdng_len (hdng_index));
	if hdng_index >= 8 & hdng_index < 12
	then					/* if heading is ... = 0. */
	     call print_message;			/* don't bother passing count and recs args */
	else call ioa_$nnl (ioa_control_string, tcount (tpix), trecs (tpix));

	return;
     end print_heading;

/* ****************************************************************************************************************** */
%page;

print_message:
     proc;					/* replaces 11 ioa_ calls (140 words) */
	call ioa_ (ioa_control_string);

	return;
     end print_message;

/* ****************************************************************************************************************** */
%page;

print_name:
     proc;					/* replaces 5 ioa_ calls (85 words) */
	call ioa_ (ioa_control_string, name (ni));

	return;
     end print_name;

/* ****************************************************************************************************************** */
%page;

print_not_found:
     proc;					/* procedure to print "<starname> not found [in <dirname>]" */

	not_found_count = not_found_count + 1;

	if starname_count > 0
	then message = "Use of star convention resulted in no match.  ^a";
	else message = """^a"" not found";

	if not_found_count = 1 then do;		/* only call com_err_ and print dir for first one */
	     if pathsw
	     then do;				/* if user gave -pn arg */
		message = message || " in ^a";	/* put dir in message (user might have typed wrong dir) */
		call com_err_ (code, "list", message, rtrim (errname), rtrim (dirname));
		end;
	     else do;
		if message ="""^a"" not found"
		then message = message || ".";          /* for readable purpose, this error message is terminated by a period. */

		call com_err_ (code, "list", message, rtrim (errname));
		end;
	     end;

	else do;
	     if message = """^a"" not found"
	     then message = message || ".";               /* for readable purpose, this error message is terminated by a period. */

	     call ioa_$ioa_switch (iox_$error_output, message, rtrim (errname));
						/* put all "not found" messages on same stream - error_output */
	     end;

	return;
     end print_not_found;

/* ****************************************************************************************************************** */
%page;

set_branch_fmt:
     proc (ix);

dcl  ix fixed bin;
dcl  fmtx fixed bin;

	fmtx = 4;					/* skip leading ^Nx of 1st col fmt to not indent whole thing */
	name_indent = 0;				/* initialize */
	do i = 1 to CT;				/* check switch for each column, up to count column */
	     if colsw (i) then do;			/* if we will print it, put its format into the string */
		substr (branch_fmt (ix), branch_fmt_ln (ix) + 1) = substr (col_fmt (i), fmtx);
		branch_fmt_ln (ix) = branch_fmt_ln (ix) + col_fmt_ln (i) + 1 - fmtx;
		if i < 3				/* plug in the current date/time width */
		then do;
		     substr (branch_fmt (ix), branch_fmt_ln (ix) -2, 2) = convert (dt_len_pic, dt_len);
		     name_indent = name_indent + dt_len + 2;
	          end;
		else if i=3
		then name_indent = name_indent + 5;
		else if i=4
		then name_indent = name_indent + 5;
		fmtx = 1;				/* pick up leading ^Nx of subsequent col fmts to separate cols */
		end;
	     else do;				/* if we will not print it, use "^s" to skip it */
		substr (branch_fmt (ix), branch_fmt_ln (ix) + 1) = "^s";
		branch_fmt_ln (ix) = branch_fmt_ln (ix) + 2;
		end;
	end;

/* Set up format for printing secondary names of branches, lined up under
   the primary name, or indented 2 spaces if only names are being printed */

	if ^prisw then do;				/* skip it if only primary names are to be printed */
	     if name_indent=5
	     then if modesw				/* if it is just mode, indent by 2 so user can distinguish */
	        then name_indent = 7;			/* secondary names from segments with null access */
	        else name_indent = 6;			/* for just records, adjust slightly */

	else if name_indent = 0 then name_indent = 2;	/* when only names are printed, indent addnames */

	     substr (name_fmt (ix), 1) = "^__x";
	     substr (name_fmt (ix), 2, 2) = convert (dt_len_pic, name_indent);
						/* how many spaces to indent */
	     name_fmt_ln (ix) = 4;			/* all of the format strings are 4 chars */
	     substr (name_fmt (ix), name_fmt_ln (ix) + 1) = "^a";
						/* to print the name */
	     name_fmt_ln (ix) = name_fmt_ln (ix) + 2;
	     end;

	return;

     end set_branch_fmt;

/* ****************************************************************************************************************** */

     end list;
