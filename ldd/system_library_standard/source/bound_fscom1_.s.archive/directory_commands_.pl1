/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1990   *
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(88-04-28,TLNguyen), approve(88-04-28,MCR7839),
     audit(88-06-02,Lippard), install(88-07-05,MR12.2-1054):
     SCP6361 requested to add new functions to change_wdir (cwd), print_dir
     (pwd) and working_dir (wd).  For details, see the MTB 775.
  2) change(90-01-25,Vu), approve(90-01-25,MCR8153), audit(90-06-21,Huen),
     install(90-09-04,MR12.4-1032):
     The active function for working_dir will now return quoted string.
  3) change(90-01-25,Vu), approve(90-01-25,MCR8154), audit(90-06-21,Huen),
     install(90-09-04,MR12.4-1032):
     The wd command with an argument of 0 should return the current directory.
                                                   END HISTORY COMMENTS */

directory_commands_:
	proc options (variable);

/* *	Commands and subroutines for manipulating the working directory and default working directory. */
/* *	Completely rewritten, 05/24/79 W. Olin Sibert */
/* Fix bugs, remove checks before calling hcs_$fs_search_set_wdir */

/* constants */
dcl ALLOWED_DIGITS char (10) internal static options (constant) init ("0123456789");
dcl MAX_LENGTH_LABEL_NAME fixed bin (17) internal static options (constant) init (32);     

/*  automatic variables */
dcl  (LOCATION_after_colon, LOCATION_before_colon) char (32) varying;
dcl  active_function bit (1) aligned;
dcl  ap ptr;
dcl  al fixed bin;
dcl  arg_index fixed bin;
dcl  array_index fixed bin;
dcl  clear_entire_stack_flag bit (1) aligned;
dcl  clear_wdir_flag bit (1) aligned;
dcl  code fixed bin (35);
dcl  current_wdir char (168);
dcl  current_wdir_length fixed bin;
dcl  given_label_name char (32);
dcl  error_count fixed bin;
dcl  label_current_wdir_for_rotation bit (1) aligned;
dcl  labels_the_current_wdir char (32);
dcl  location_array (0:9999) fixed bin (35);
dcl  match bit (1) aligned;
dcl  max_array_index fixed bin;
dcl  nargs fixed bin;
dcl  pathname char (168);
dcl  pathname_count fixed bin;
dcl  pop_wdir_flag bit (1) aligned;
dcl  push_wdir_flag bit (1) aligned;
dcl  rotate_wdir_flag bit (1) aligned;
dcl  stack_location fixed bin (35);
dcl  temp_ptr ptr;
dcl  whoami char (32);

/*  static variables */
dcl  area_ptr ptr internal static init (null);
dcl  total_number_of_pushes fixed bin (35) internal static init (0);  /* total number of prior wdirs */
dcl  default_wdir_set bit (1) aligned internal static initial ("0"b); /* turned on after we've been called once */
dcl  default_wdir_pathname char (168) aligned internal static init (""); /* the static default wdir pathname */
dcl  first_node_ptr ptr internal static init (null);
dcl  last_node_ptr ptr internal static init (null);
dcl  label_name_of_current_wdir char (32) varying internal static init ("");
dcl  current_wdir_pathname char (168) varying internal static init ("");
     
/* based */
dcl  arg char (al) based (ap);

dcl 1 stack_linked_list aligned based,
      2 back_ptr ptr,
      2 label_name char (32) varying,
      2 wdir_name char (168) varying;

dcl system_area area based (area_ptr);
	

/* external entries */
dcl  active_fnc_err_ entry options (variable);
dcl  com_err_ entry options (variable);
dcl  cu_$af_return_arg entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
dcl  cu_$arg_count entry (fixed bin, fixed bin (35));
dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
dcl  expand_path_ entry (ptr, fixed bin, ptr, ptr, fixed bin (35));
dcl  get_system_free_area_ entry returns (ptr);
dcl  hcs_$fs_search_get_wdir entry (ptr, fixed bin);
dcl  hcs_$fs_search_set_wdir entry (char (*), fixed bin (35));
dcl  ioa_ entry options (variable);
dcl  requote_string_ entry (char (*)) returns (char (*));
dcl  sub_err_ entry options (variable);
dcl  user_info_$homedir entry (char (*) aligned);

dcl  (error_table_$argerr,
      error_table_$bad_arg,
      error_table_$badopt,
      error_table_$bigarg,
      error_table_$no_wdir,
      error_table_$not_act_fnc) fixed bin (35) ext static;
/* builtin */
dcl (abs, after, addr, before, char, index, ltrim, length, null, rtrim, substr, verify) builtin;

/*--------------------------------------------------------------------------*/
%page;
change_wdir:
cwd: entry options (variable);

/* The following internal procedures are belonged to change_wdir entry.     */
/* They are listed first before you can reach the main program of           */
/* change_wdir entry.  There are other internal procedures which belong to  */
/* this entry are listed at the end of directory_commands_.pl1 since they   */
/* are also called by working_dir entry.                                    */
/*                                                                          */
/* This entry is documented in the MTB 775 and approved in MCR7839.         */
/* It syntax: cwd {path} {-control_args}                                    */
/* control arguments: -push {LABEL}; -pop {LOCATION}  default is stack      */
/* location 1; -rotate {LOCATION {LABEL}}  default is the top stack at      */
/* stack location 1; -clear {LOCATIONs}  default is the entire stack.       */
/* LOCATION can be either stack location N or a text string LABEL.          */
/*                                                                          */
/* The design of data structure: singlely linked circular list to implement */
/* a stack of prior working directory that you have been visited.           */
/*                                                                          */
/* first_node_ptr : points to the node containing the least recent wdir.    */
/* last_node_ptr  : points to the node containing the most recent_wdir.     */
/* total_number_of_pushes: indicates the number of nodes currently on the   */
/* stack of prior working directories.                                      */
/*                                                                          */
/* for an empty linked list:                                                */
/*   first_node_ptr = null                                                  */
/*   last_node_ptr  = null                                                  */
/*   total_number_of_pushes = 0                                             */
/*                                                                          */
/* for a linked list of one node:                                           */
/*      total_number_of_pushes = 1                                          */
/*                                                                          */
/*      first_node_ptr  last_node_ptr                                       */
/*            |           |                                                 */
/*      ______|___________|_________                                        */
/*      |  |       |                |                                       */
/*   <____ | LABEL |  PRIOR WDIR    |                                       */
/*   |  |__|_______|________________|                                       */
/*   |                  |                                                   */
/*   |________>_________|
/*                                                                          */
/*                                                                          */
/* for a linked list of n nodes:                                            */
/*      total_number_of_pushes = n  (where n is a numeric digit)            */
/*                                                                          */
/*      first_node_ptr                                      last_node_ptr   */
/*         |                                                   |            */
/*     ____|______   ___________    ___________            ____|______      */
/*     |  |  |   |   |  |  |   |    |  |  |   |            |  |  |   |      */
/*   <___ |  |   |<____ |  |   |<_____ |  |   |<___ ... <____ |  |   |      */
/*   | |__|__|___|   |__|__|___|    |__|__|___|            |__|__|___|      */
/*   |                                                             |        */
/*   |______________>______________________________>_______________|        */
/*                                                                          */
            /*----------------------------------------------*/
%page;
LOCATION_validation: proc (P_arg, P_stack_position, P_label_name, P_label_current_wdir_for_rotation, P_labels_the_cur_wdir,
		        P_clear_flag, P_push_flag);

/* verify that LOCATION specified is valid, where LOCATION can be a stack   */
/* position N or a text string LABEL.                                       */
/* N must be within a stack of prior wdirs.  LABEL's max. lenghth is 32     */
/* characters and it cannot begin with a minus sign or a numeric digit.     */
/* LABEL cannot include a colon since a colon indicates a range.            */
/* LABEL cannot be a reserved word such as first (f), last (l), all (a).    */

                                                               /* parameters */
     dcl P_arg char (*);
     dcl P_clear_flag bit (1) aligned;
     dcl P_labels_the_cur_wdir char (*);
     dcl P_label_current_wdir_for_rotation bit (1) aligned;
     dcl P_label_name char (*);
     dcl P_push_flag bit (1) aligned;
     dcl P_stack_position fixed bin (35);
                                                               /* local */
     dcl err_count fixed bin;
		   
/* begin coding */
     code = 0;
     LOCATION_before_colon = "";
     LOCATION_after_colon  = "";
     err_count = 0;

     if index (P_arg, "-") = 1 then do;
	code = error_table_$badopt;
	return;
     end;

     if index (P_arg, ":") ^= 0 then do;                      /* a range is specified */
	if ^P_clear_flag then do;                           /* only -clear allowed a range */
ERR_RET:
	     code = error_table_$bad_arg;
	     return;
	end;

          else do;                                            /* prepare for parsing a range */
	     LOCATION_before_colon = before (P_arg, ":");
	     LOCATION_after_colon  = after (P_arg, ":");

	     if (LOCATION_before_colon = "") | (LOCATION_after_colon = "") then
		goto ERR_RET;
	end;
     end;

     if verify (substr (P_arg, 1, 1), ALLOWED_DIGITS) = 0 then do;
                                                               /* LOCATION is a stack position N. */
	if ^P_clear_flag then do;
	     if P_push_flag then                             /* -push allowed only LABEL */
		goto ERR_RET;

                                                               /* -pop, -rotate allow both LABEL and stack location N */
	     P_stack_position = cv_dec_check_ (P_arg, code);
	     if code ^= 0 then goto ERR_RET;

	     if (P_stack_position < 1) | (P_stack_position > total_number_of_pushes) then
		goto ERR_RET;                           /* the specified stack position N is without the stack of prior wdirs */

	     P_stack_position = abs (P_stack_position);
	end;
          else do;                                             /* -clear */
	     if index (P_arg, ":") > 1 then do;              /* LOCATION is a range (e.g. 10:l  15:LABEL  8:12) */
		P_stack_position = cv_dec_check_ ((LOCATION_before_colon), code);
		if code ^= 0 then goto ERR_RET;

		if P_stack_position = 0 then               /* stack position N must begin at 1 and end at total_number_of_pushes */
		     goto ERR_RET;

		P_stack_position = abs (P_stack_position);
                                                               /* save it */
		call save_a_valid_LOCATION (max_array_index, P_stack_position);

		call LOCATION_continue_validation ((LOCATION_after_colon), max_array_index, P_stack_position, code);
               end;
	     else do;                                        /* LOCATION is a stack location N */
		P_stack_position = cv_dec_check_ (P_arg, code);
		if code ^= 0 then goto ERR_RET;

                                                               /* make sure a specified stack position N is within the stack of prior wdirs */
		if P_stack_position = 0 | P_stack_position > total_number_of_pushes then
		     goto ERR_RET;
		
		P_stack_position = abs (P_stack_position);
		call save_a_valid_LOCATION (max_array_index, P_stack_position);
	     end;
          end;
     end;

     else if P_clear_flag then do;
	     if P_arg = "first" | P_arg = "f" then do;
		P_stack_position = 1;
		call save_a_valid_LOCATION (max_array_index, P_stack_position);
	     end;

	     else if P_arg = "last" | P_arg = "l"  then do;
		     P_stack_position = total_number_of_pushes;
		     call save_a_valid_LOCATION (max_array_index, P_stack_position);
	     end;

	     else if P_arg = "all" | P_arg = "a" then do;
		     P_stack_position = 1;
		     call save_a_valid_LOCATION (max_array_index, P_stack_position);
		     P_stack_position = total_number_of_pushes;
		     call CONTINUE_save_good_data (max_array_index, P_stack_position, code);
	     end;

	     else if index (P_arg, ":") = 0 then
		call LABEL_validation (P_arg, max_array_index, P_stack_position, code);

               else do;
		if LOCATION_before_colon = "first" | LOCATION_before_colon = "f" then do;
		     P_stack_position = 1;
		     call save_a_valid_LOCATION (max_array_index, P_stack_position);
	          end;

	          else if LOCATION_before_colon = "last" | LOCATION_before_colon = "l" then
		     goto ERR_RET;

		else if LOCATION_before_colon = "all" | LOCATION_before_colon = "a" then
		     goto ERR_RET;

		else call LABEL_validation ((LOCATION_before_colon), max_array_index, P_stack_position, code);
	         
		call LOCATION_continue_validation ((LOCATION_after_colon), max_array_index, P_stack_position, code);
	     end;
     end;

     else do;
	if P_arg = "all" | P_arg = "a" then err_count = err_count + 1;
	if P_arg = "first" | P_arg = "f" then err_count = err_count + 1;
	if P_arg = "last" | P_arg = "l"  then err_count = err_count + 1;

	if err_count > 0 then do;
	     error_count = -1;                           /* mark that an error encountered */
	     goto ERR_RET;
	end;

          if length (P_arg) > MAX_LENGTH_LABEL_NAME then do;
	     code = error_table_$bigarg;
	     return;
	end;

          if P_label_current_wdir_for_rotation then        /* want to label the current wdir before rotation begins */
	     P_labels_the_cur_wdir = P_arg;
	else P_label_name = P_arg;
     end;

     return;                                               /* return to change_wdir entry */

     end LOCATION_validation;

            /*---------------------------------------------*/
%page;
array_selection_sort: proc;
			    
/* sort the contents of location_array from array index 1 through            */
/* max_array_index in an ascending order (increasing value).   All duplicate */
/* stack locations containing in an array are eliminated so that the array   */
/* only contains unique stack location values.                               */
/*                                                                           */
/* Currently, all LOCATIONs containing in an array are not in order and      */
/* may be duplicated.   For example:                                         */
/*                                                                           */
/*    Before sorting: max_array_index = 6, location_array contains stack     */
/* locations 1, 6, 7, 3, 5, and 3.                                           */
/*                                                                           */
/*    After sorting, max_arry_index = 5, the contents of location_array are  */
/* 1, 3, 5, 6, and 7.                                                        */
/*                                                                           */
/*              before sorting               after sorting                   */
/*                                                                           */
/*              ________                     ________                        */
/*          1   |  1   |                1    |  1   |                        */
/*              |______|                     |______|                        */
/*          2   |  6   |                2    |  3   |                        */
/*              |______|                     |______|                        */
/*          3   |  7   |   =====>       3    |  5   |                        */
/*              |______|                     |______|                        */
/*          4   |  3   |                4    |  6   |                        */
/*              |______|                     |______|                        */
/*          5   |  5   |                5    |  7   |                        */
/*              |______|                     |______|                        */
/*          6   |  3   |                6    | -1   |                        */
/*              |______|                     |______|                        */
/*                                                                           */
                                                          /* local */
     dcl (i_index, j_index, k_index) fixed bin;
     dcl smallest_index_for_unsorted_array fixed bin;
     dcl  temp_data fixed bin (35);
			    
			    
/* begin coding */
     i_index = 1;
     temp_data = 0;
     
     do while (i_index < max_array_index);
                                                         /* prepare for the inner loop */
	smallest_index_for_unsorted_array = i_index;
	j_index = i_index + 1;

	do while (j_index <= max_array_index);         /* find the minimum location (which stored early) so far */
	     if location_array (j_index) < location_array (smallest_index_for_unsorted_array) then
		smallest_index_for_unsorted_array = j_index;

               else if location_array (j_index) = location_array (smallest_index_for_unsorted_array) then do;
                                                         /* duplicate stack location value is found, so get rid of it */
                                                         /* by move the contents of an array underneath of the duplicate value up to 1 level */
		     do k_index = j_index to (max_array_index - 1);
			location_array (k_index) = location_array (k_index + 1);
		     end;
                                                         /* re-initialize the contents of location_array at subcript max_array_index */
		     location_array (max_array_index) = - 1;
                                                         /* update the actual maximum array index value after overwritten the duplicate */
		     max_array_index = max_array_index - 1;
                                                         /* forget about the duplicate, assume that no duplication found at subcript j_index */
		     j_index = j_index - 1;
	     end;

	     j_index = j_index + 1;
          end;
                                                         /* swapping: move the smaller location found into a temp. place */
          temp_data = location_array (smallest_index_for_unsorted_array);
                                                         /* move the larger location into the place where the smaller location used to live */
	location_array (smallest_index_for_unsorted_array) = location_array (i_index);

	location_array (i_index) = temp_data;
	
	i_index = i_index + 1;
     end;

     return;                                              /* return to do_clear internal procedure of change_wdir entry */
     
     end array_selection_sort;

             /*--------------------------------------------*/
%page;
move_to_top_stack_dir: proc (p_travel_ptr, p_temp_ptr, p_dir_pathname);

/* set the most recent prior wdir at the top stack to become the current     */
/* wdir.  Since all prior wdirs are stored in a singlely circular linked     */
/* list, links such as first_node_ptr which points to the least recent wdir  */
/* at the bottom stack and temp_ptr which points to the current wdir must be */
/* updated after appended the current wdir to the bottom stack.              */
                                                       /* parameters */
     dcl p_dir_pathname char (*);
     dcl p_temp_ptr ptr;
     dcl p_travel_ptr ptr;
			
/* begin coding */
                                                        /* update pointers */
     p_temp_ptr -> stack_linked_list.back_ptr = p_travel_ptr -> stack_linked_list.back_ptr;
     first_node_ptr -> stack_linked_list.back_ptr = p_temp_ptr;

     first_node_ptr = p_temp_ptr;
     last_node_ptr = p_travel_ptr -> stack_linked_list.back_ptr;

                                                        /* get the most recent wdir and its associated label name */
     p_dir_pathname = p_travel_ptr -> stack_linked_list.wdir_name;
     label_name_of_current_wdir = p_travel_ptr -> stack_linked_list.label_name;

                                                        /* remove the node containing most recent wdir and label from the list */
     free p_travel_ptr -> stack_linked_list in (system_area);
     p_temp_ptr = null;
     p_travel_ptr = null;

     return;                                            /* return to do_rotate internal procedure of change_wdir entry */
     end move_to_top_stack_dir;

          /*--------------------------------------------*/
%page;
move_to_a_specified_dir: proc (para_travel_ptr, para_previous_ptr, para_temp_ptr, para_pathname);
			    
/* set the prior wdir at a specified LOCATION to become the current wdir.    */
/* Since all prior wdirs are stored in a singlely circular linked list,      */
/* links (pointers) must be updated depending on which LOCATION you want     */
/* to move to (e.g. middle, end, or any LOCATION on the stack).              */

     dcl para_travel_ptr ptr;
     dcl para_pathname char (*);
     dcl para_previous_ptr ptr;
     dcl para_temp_ptr ptr;
			    
/* begin coding */
                                                        /* update links */
     para_temp_ptr -> stack_linked_list.back_ptr = last_node_ptr;
     first_node_ptr -> stack_linked_list.back_ptr = para_temp_ptr;

     para_previous_ptr -> stack_linked_list.back_ptr = para_travel_ptr -> stack_linked_list.back_ptr;
     
     first_node_ptr = para_previous_ptr;
     last_node_ptr = para_travel_ptr -> stack_linked_list.back_ptr;

                                                        /* get a prior wdir and its associated label name at that specified LOCATION */
     para_pathname = para_travel_ptr -> stack_linked_list.wdir_name;
     label_name_of_current_wdir = para_travel_ptr -> stack_linked_list.label_name;
     
                                                        /* remove the node at that specified LOCATION from the linked list */
     free para_travel_ptr -> stack_linked_list in (system_area);

     para_previous_ptr = null;
     para_temp_ptr = null;
     para_travel_ptr = null;
     
     return;                                            /* return to do_rotate internal procedure of change_wdir entry */
     end move_to_a_specified_dir;     

               /*------------------------------------------*/
%page;
do_clear: proc (p_total_numb_of_pushes, p_err_cnt);

/* remove working directories from the stack without changing the current    */
/* wdir.  Assume that specified LOCATIONs or reserved words are valid at     */
/* at this point.  All stack locations where prior wdirs will be cleared out */
/* are stored earlier in an array.                                           */
/* The array containing stack locations must be sorted in increasing order   */
/* before removing prior wdirs from the stack.                               */
/* Start the linked list from the node containing the most recent wdir and   */
/* stop at the node containing the prior wdir to be cleared out.  Remove it  */
/* from the linked list after taken care of links (pointers).                */
/* If there are more prior wdirs to be cleared out then continue walk on the */
/* linked list from previous stop, since stack locations where prior wdirs   */
/* to be deleted are already sorted, until specified prior wdirs are removed */
/* from the stack.                                                           */

                                                               /* parameters */
     dcl p_err_cnt fixed bin;
     dcl p_total_numb_of_pushes fixed bin (35);
                                                               /* local */
     dcl clear_index fixed bin (35);
     dcl previous_pointer pointer;
     dcl skip_node_index fixed bin (35);

/* begin coding */	
     array_index = 0;
     p_err_cnt = 0;
     clear_index = 0;
     previous_pointer = null;
     skip_node_index = 0;

     if last_node_ptr = null & p_total_numb_of_pushes = 0 then do;
	if rtrim (pathname) ^= "" then                        /* allows to change to the NEW current wdir instead of return as an error */
	     call ioa_ ("Warning: the stack of prior wdirs is empty.");
	else do;
	     p_err_cnt = p_err_cnt + 1;                       /* the stack is empty */
	     call com_err_ (0, whoami, "Empty stack.");
	end;
	return;
     end;

     if clear_entire_stack_flag then do;                        /* wanted to clear the entire stack of prior wdirs */
	do clear_index = 1 to p_total_numb_of_pushes;
	     temp_ptr = last_node_ptr;
	     last_node_ptr = temp_ptr -> stack_linked_list.back_ptr;
	     first_node_ptr -> stack_linked_list.back_ptr = last_node_ptr;

	     free temp_ptr -> stack_linked_list in (system_area);
	end;
        
          p_total_numb_of_pushes = 0;
          last_node_ptr = null;
          first_node_ptr = null;
	return;
     end;

     if max_array_index > 1 then
	call array_selection_sort;                       /* sort given stack locations in ascending order */
	
     temp_ptr = last_node_ptr;                             /* prepare for looking a target */

     if max_array_index = 1 then do;                       /* want to clear out only a single prior wdir from the stack */

	if location_array (max_array_index) = 1 then do; /* want to clear out the most recent wdir from the stack */
	     last_node_ptr = temp_ptr -> stack_linked_list.back_ptr;
	     first_node_ptr -> stack_linked_list.back_ptr = last_node_ptr;

	     if p_total_numb_of_pushes = 1 then do;      /* the linked list contains only one node to be cleared out */
		last_node_ptr = null;
		first_node_ptr = null;
	     end;
	end;
	else do;
                                                           /* walk on the linked list from the node containing the most recent wdir */
                                                           /* and stop at the node located at (n-1)th before reaching the */
                                                           /* node containing the prior wdir to be deleted at stack position n */
	     do skip_node_index = 1 to (location_array (max_array_index) - 1);
		previous_pointer = temp_ptr;
		temp_ptr = temp_ptr -> stack_linked_list.back_ptr;
	     end;
                                                           /* prepare to clear out the least recent wdir at bottom stack */
               if location_array (max_array_index) = p_total_numb_of_pushes then do;
		first_node_ptr = previous_pointer;
		first_node_ptr -> stack_linked_list.back_ptr = last_node_ptr;
	     end;
                                                           /* prepare to clear out a prior wdir at a specified stack location */
	     else previous_pointer -> stack_linked_list.back_ptr = temp_ptr -> stack_linked_list.back_ptr;
	end;
                                                           /* remove a prior wdir from the stack */
          free temp_ptr -> stack_linked_list in (system_area);
                                                           /* update the total number of nodes currently in the linked list */
	p_total_numb_of_pushes = p_total_numb_of_pushes - 1;
     end;                                                  /* remove only a single prior wdir from the stack */
     else do;                                              /* remove at least two prior wdirs from the stack of prior wdirs */
	do array_index = 1 to max_array_index;
                                                           /* prepare to clear out the most recent wdir from the stack */
	     if location_array (array_index) = 1 then do;
		last_node_ptr = temp_ptr -> stack_linked_list.back_ptr;
		first_node_ptr -> stack_linked_list.back_ptr = last_node_ptr;
	     end;
                                                           /* prepare to remove several consective prior wdirs (e.g. 1 2 3; 7 8 9) */
	     if (location_array (array_index)) = (location_array (array_index - 1) + 1) then do;

		if previous_pointer ^= null then do;
		     temp_ptr = previous_pointer -> stack_linked_list.back_ptr;
		     previous_pointer -> stack_linked_list.back_ptr = temp_ptr -> stack_linked_list.back_ptr;

                                                          /* prepare to clear out the least recent wdir */
		     if location_array (array_index) = p_total_numb_of_pushes then
			first_node_ptr = previous_pointer;
		end;
		else do;                              /* update pointer pointing to the node containing the most recent wdir and */
                                                          /* back pointer of the bottom stack node which contains the least recent wdir */
		     last_node_ptr = temp_ptr -> stack_linked_list.back_ptr;
		     first_node_ptr -> stack_linked_list.back_ptr = last_node_ptr;
		end;
	     end;
	     else do;                                   /* clear out several prior wdirs at NON consective stack locations */
		if array_index = 1 then do;           /* prepare to clear a prior wdir FOR THE FIRST TIME looping */
                                                          /* skip the node containing the most recent wdir at stack location 1 to */
                                                          /* the node at stack location (n -1) before reaching the node containing */
                                                          /* the prior wdir to be deleted at stack location n */
		     do skip_node_index = 1 to (location_array (array_index) - 1);
			previous_pointer = temp_ptr;
			temp_ptr = temp_ptr -> stack_linked_list.back_ptr;
		     end;
		end;                                  /* prepare to clear out a prior wdir FOR THE FIRST TIME looping */
		else do;                              /* prepare to clear out ANOTHER prior wdir from the stack */
		     if previous_pointer ^= null then /* continue to walk on the linked list from the previous stop */
			temp_ptr = previous_pointer -> stack_linked_list.back_ptr;

                                                          /* continue to skip nodes before reaching the node to be cleared out */
		     do skip_node_index = (location_array (array_index - 1) + 1) to (location_array (array_index) - 1);
			previous_pointer = temp_ptr;
			temp_ptr = temp_ptr -> stack_linked_list.back_ptr;
		     end;
	          end;                                  /* prepare to clear out ANOTHER prior wdir from the stack */
                                                          /* prepare to clear out the least recent prior wdir at the bottom linked list */
	          if location_array (array_index) = p_total_numb_of_pushes then do;
		     first_node_ptr = previous_pointer;
		     first_node_ptr -> stack_linked_list.back_ptr = last_node_ptr;
		end;
                                                           /* prepare to clear out another prior wdir at a specified stack location */
		else if previous_pointer ^= null then
		     previous_pointer -> stack_linked_list.back_ptr =  temp_ptr -> stack_linked_list.back_ptr;
	     end;                                        /* clear out several prior wdirs at NON-consective stack locations */
                                                           /* finally, remove a prior wdir at a specified stack location from the stack */
	     free temp_ptr -> stack_linked_list in (system_area);

	     temp_ptr = last_node_ptr;                  /* prepare to walk on the linked list again */
	end;                                            /* do loop */
                                                          /* update the total number of nodes left over on the linked list */
          p_total_numb_of_pushes = p_total_numb_of_pushes - max_array_index;
     end;                                                 /* complete the request of removing prior wdirs from the stack */

     if p_total_numb_of_pushes = 0 then do;               /* become empty after complete the request of removing prior wdir(s) from the stack */
	last_node_ptr = null;
	first_node_ptr = null;
     end;     

     return;                                              /* return to change_wdir entry */

     end do_clear;

           /*--------------------------------------------*/
%page;
do_pop: proc (para_npushes, para_pathname, para_error_count);
        
/* pop to the wdir identified by LOCATION, where LOCATION can be a stack   */
/* location N or a LABEL associated with a prior wdir.  The prior wdir     */
/* popped to becomes the NEW current wdir.  Prior directories ABOVE the    */
/* the selected directory are REMOVED from the stack.  However,            */
/* directories BELOW the selected prior wdir REMAIN on the stack.          */

                                                             /* parameters */
     dcl para_error_count fixed bin;                         /*   input    */
     dcl para_npushes fixed bin (35);                        /*   in/out   */
     dcl para_pathname char (*);                             /*   output   */
        
     dcl pop_index fixed bin;                           /* local */
     dcl remove_index fixed bin;
     dcl dispose_node_ptr ptr;
        

/* begin coding */
     dispose_node_ptr = null;                                /* initialized local variables */
     pop_index = 0;
     remove_index = 0;

     match = "0"b;                                           /* for double check */
     temp_ptr = null;
        
     if last_node_ptr = null & para_npushes = 0 then do;     /* case of an EMPTY stack */
	para_error_count = para_error_count + 1;
	call com_err_ (0, whoami, "An empty stack of prior wdirs.");
	return;
     end;

     temp_ptr = last_node_ptr;

     if stack_location ^= - 1 then do;                       /* LOCATION is N */
	do pop_index = 1 to (stack_location - 1);          /* remove all directories ABOVE the selected directory at stack location N */
	     last_node_ptr = temp_ptr -> stack_linked_list.back_ptr;
	     first_node_ptr -> stack_linked_list.back_ptr = last_node_ptr;

	     free temp_ptr -> stack_linked_list in (system_area);

	     temp_ptr = last_node_ptr;
	end;
     
          para_npushes = para_npushes - stack_location;
     end;

     if given_label_name ^= " " then do;                    /* LOCATION is LABEL */
	do pop_index = 1 to para_npushes while (^match);  /* scan the entire singely circular linked list to find a match of label name */
	     if temp_ptr -> stack_linked_list.label_name = given_label_name then
		match = "1"b;
	     else temp_ptr = temp_ptr -> stack_linked_list.back_ptr;
	end;
     
          if (pop_index > para_npushes) & (^match) then do; /* for the case of no matched label name, cwd treats as an error */
	     para_error_count = para_error_count + 1;
	     call com_err_ (0, whoami, "No match ^a.  Directory not popped.", given_label_name);
	     return;
	end;

          pop_index = pop_index - 1;                        /* correct the pop_index value after left the above do loop. */

	do remove_index = 1 to (pop_index - 1);           /* remove all directories ABOVE the matched labelled directory. */
	     dispose_node_ptr = last_node_ptr;
	     last_node_ptr = dispose_node_ptr -> stack_linked_list.back_ptr;
	     first_node_ptr -> stack_linked_list.back_ptr = last_node_ptr;
	     
	     free dispose_node_ptr -> stack_linked_list in (system_area);
	end;
     
          para_npushes = para_npushes - pop_index;
     end;

	                                                       /* get the selected prior wdir and its associated label name */
     para_pathname = temp_ptr -> stack_linked_list.wdir_name;
     label_name_of_current_wdir = temp_ptr -> stack_linked_list.label_name;

                                                                 /* finally, remove this selected directory from the stack of prior wdirs. */
     if para_npushes = 0 then do;
	last_node_ptr = null;
	first_node_ptr = null;
     end;
     else do;
	first_node_ptr -> stack_linked_list.back_ptr = temp_ptr -> stack_linked_list.back_ptr;
	last_node_ptr = temp_ptr -> stack_linked_list.back_ptr;
     end;
     
     free temp_ptr -> stack_linked_list in (system_area);
	
     return;                                         /* return to change_wdir entry */
	
     end do_pop;

             /*-------------------------------------------*/
%page;
do_push: proc (parameter_npushes);
         
/* push the current wdir into a stack of prior wdirs.  If LABEL is         */
/* specified, it is attached to the current wdir.  Note that the stack is  */
/* a singely circular linked  list.  No finite limit to the total number   */
/* of wdirs to be pushed on the stack.  The only limit will be the amount  */
/* of available spae in the system free area.                              */

     dcl parameter_npushes fixed bin (35);
         
/* begin coding */
                                                            /* create a new node in system_area and set temp_ptr points to it */
     allocate stack_linked_list in (system_area) set (temp_ptr);

     if last_node_ptr = null then do;                       /* empty singlely linked CIRCULAR list */
                                                            /* statics pointers point to the newly created node since it is */
                                                            /* only node in the list */
	first_node_ptr = temp_ptr;
	last_node_ptr = temp_ptr;
                                                            /* back pointer of the newly created node points to itself because of circular */
	temp_ptr -> stack_linked_list.back_ptr = temp_ptr;
     end;
     else do;                                               /* at least one node in the singely circular linked list */
	temp_ptr -> stack_linked_list.back_ptr = last_node_ptr;
	first_node_ptr -> stack_linked_list.back_ptr = temp_ptr;
	last_node_ptr = temp_ptr;
     end;

                                                            /* fill in the current wdir and the value of label_name_of_current_wdir */
/* example: ! print_wdir all
              LOC LABEL PATHNAME

                0 x     >udd>m>TLNguyen>cwd_dev
                1       >udd>m>TLNguyen>canon_dev
                2 y     >udd>m>TLNguyen>meetings
 
            ! cwd subcwd_dev -push

                               temp_ptr
                                  |
                   _______________|___________________________
                   | |   |                                   |
                <--- | x | >udd>m>TLNguyen>cwd_dev>subcwd_dev|
                   |_|___|___________________________________|
*/

     temp_ptr -> stack_linked_list.wdir_name = rtrim (current_wdir);
     temp_ptr -> stack_linked_list.label_name = label_name_of_current_wdir;


                                                            /* this is time to RE-label the label name of the current wdir */
     if given_label_name ^= "" then                         /* wanted to label the current wdir */
	temp_ptr -> stack_linked_list.label_name = rtrim (given_label_name);

     label_name_of_current_wdir = "";                       /* must reinitialize this static variable after pushed the current wdir */
                                                            /* and either its existing associated label or the newly given label onto the stack */

     parameter_npushes = parameter_npushes + 1;             /* update the total number of nodes currently in the linked list */

     return;                                                /* return to change_wdir entry */
     
     end do_push;
         
              /*---------------------------------------------*/
%page;
do_rotate: proc (p_pathname, p_error_count);
	 
/* move to the prior wdir indentified by LOCATION, where LOCATION can be   */
/* either stack location N or a LABEL.  Rotation occurs by placing the     */
/* current wdir at the BOTTOM of the stack and set the NEW current wdir    */
/* from the top stack identified by a given LOCATION.  For a specified N,  */
/* rotate Nth times, the wdir at the Nth location becomes the NEW current  */
/* wdir.  For a specified LABEL, rotate until a matched label name is      */
/* is found, the wdir associated with a matched LABEL becomes the NEW      */
/* current wdir.                                                           */
                                                       /* output parameters */
     dcl p_error_count fixed bin;
     dcl p_pathname char (*);                          /* prior wdir at a specified LOCCATION */
                                                       /* local */
     dcl rotate_index fixed bin;
     dcl travel_ptr ptr;
     dcl prev_travel_ptr ptr;
	 
/* begin coding */
     rotate_index = 0;
     travel_ptr = null;
     prev_travel_ptr = null;

     match = "0"b;                                     /* for double check */

     if last_node_ptr = null & total_number_of_pushes = 0 then do;  /* an empty stack */
	p_error_count = p_error_count + 1;
	call com_err_ (0, whoami, "Empty stack.");
	return;
     end;
		                                   /* APPEND the current wdir to the stack.  Labels it if requested. */
     allocate stack_linked_list in (system_area) set (temp_ptr);

     temp_ptr -> stack_linked_list.wdir_name = current_wdir;
     temp_ptr -> stack_linked_list.label_name = label_name_of_current_wdir;

     if labels_the_current_wdir ^= "" then             /* either -rotate N LABEL or -rotate LABEL LABEL;  The second LABEL */
	temp_ptr -> stack_linked_list.label_name = rtrim (labels_the_current_wdir);

                                                       /* prepare for moving to a prior wdir at a specified LOCATION */
     travel_ptr = last_node_ptr;
     
     if stack_location ^= - 1 then do;                 /* LOCATION is a stack location N */
	if stack_location = 1 then
	     call move_to_top_stack_dir (travel_ptr, temp_ptr, p_pathname);
	else do;
	     do rotate_index = 1 to (stack_location - 1);
		prev_travel_ptr = travel_ptr;
		travel_ptr = travel_ptr -> stack_linked_list.back_ptr;
	     end;
	
	     call move_to_a_specified_dir (travel_ptr, prev_travel_ptr, temp_ptr, p_pathname);
	end;
     end;

     if given_label_name ^= " " then do;                    /* -rotate LABEL */
	if travel_ptr -> stack_linked_list.label_name = rtrim (given_label_name) then
	     call move_to_top_stack_dir (travel_ptr, temp_ptr, p_pathname);
	else do;
	     do rotate_index = 2 to total_number_of_pushes while (^match);
		prev_travel_ptr = travel_ptr;
		travel_ptr = travel_ptr -> stack_linked_list.back_ptr;
		
		if travel_ptr -> stack_linked_list.label_name = rtrim (given_label_name) then
		     match = "1"b;
	     end;
	
               if (rotate_index > total_number_of_pushes) & (^match) then do;
		p_error_count = p_error_count + 1;

		free temp_ptr -> stack_linked_list in (system_area);
		
		call com_err_ (0, whoami, "No matched ^a.  Directory not rotated.", given_label_name);
		return;
	     end;
	
               call move_to_a_specified_dir (travel_ptr, prev_travel_ptr, temp_ptr, p_pathname);
	end;
     end;

     return;                                                    /* return to change_wdir entry */
     
     end do_rotate;

               /*-----------------------------------------------*/
%page;
initialization: proc ();

     max_array_index = 0;
     location_array (*) = - 1;
     current_wdir = "";
     labels_the_current_wdir = "";
     label_current_wdir_for_rotation = "0"b;
     clear_entire_stack_flag = "0"b;
     clear_wdir_flag = "0"b;
     code = 0;
     given_label_name = "";
     error_count = 0;
     match = "0"b;
     rotate_wdir_flag = "0"b;
     pathname = "";
     pathname_count = 0;
     pop_wdir_flag = "0"b;
     push_wdir_flag = "0"b;
     stack_location = - 1;
     temp_ptr = null;
	
     return;                                                  /* return to change_wdir entry */
     
     end initialization;

           /*-------------------------------------------------*/
%page;
/* main program of change_wdir entry */

     whoami = "change_wdir";                                  /* my name is change_wdir */

     call initialization;                                     /* initialize automatic variables */

     if area_ptr = null then                                  /* get system free area */
	area_ptr = get_system_free_area_ ();

     call cu_$arg_count (nargs, code);                        /* get the total number of input arguments specified on the command line. */
     if code ^= 0 then do;
	call com_err_ (code, whoami);
	return;
     end;

     if nargs = 0 then do;
	label_name_of_current_wdir = "";                    /* must re-initialized */
	pathname = get_default_wdir_ ();                    /* set pathname to default wdir */
     end;
     else do;
	do arg_index = 1 to nargs;                          /* validate input arguments */
	     call cu_$arg_ptr (arg_index, ap, al, code);
	     if code ^= 0 then do;
		call com_err_ (code, whoami);
		return;
	     end;
	
	     if index (arg, "-") = 1 then do;
		if arg = "-clear" | arg = "-cl" then do; 
		     clear_wdir_flag = "1"b;

		     if arg_index = nargs then            /* clear out the entire stack */
			clear_entire_stack_flag = "1"b;
		     else do;                             /* LOCATION specifier for -clear */
			do arg_index = (arg_index + 1) to nargs while (code = 0);
			     call cu_$arg_ptr (arg_index, ap, al, code);
			     if code ^= 0 then do;
				call com_err_ (code, whoami);
				return;
			     end;

			     if arg = "0" then do;
				call com_err_ (0, whoami, "^a is not in the stack of prior wdirs.", arg);
				return;
			     end;

			     call LOCATION_validation (arg, stack_location, given_label_name, label_current_wdir_for_rotation,
			     labels_the_current_wdir, clear_wdir_flag, push_wdir_flag);
			     if code ^= 0 then do;
				if arg = "-pop" | arg = "-push" | arg = "-rotate" then
				     call com_err_ (0, whoami, "-clear is mutually exclusive with ^a.", arg);
				else call com_err_ (code, whoami, "^a", arg);
				return;
			     end;
			end;
		     end;
		end;

	          else if arg = "-pop" then do;
			pop_wdir_flag = "1"b;

			if arg_index = nargs then
			     stack_location = 1;        /* by default */
			else do;
			     arg_index = arg_index + 1;
			     call cu_$arg_ptr (arg_index, ap, al, code);
			     if code ^= 0 then do;
				call com_err_ (code, whoami);
				return;
			     end;

			     if arg = "0" then do;
				call com_err_ (0, whoami, "^a is not in the stack of prior wdirs.", arg);
				return;
			     end;

			     call LOCATION_validation (arg, stack_location, given_label_name, label_current_wdir_for_rotation,
				labels_the_current_wdir, clear_wdir_flag, push_wdir_flag);
			     if code ^= 0 then do;
				if arg = "-clear" | arg = "-push" | arg = "-rotate" then
				     call com_err_ (0, whoami, "-pop is mutually exclusive with ^a.", arg);
				else do;
				     call com_err_ (code, whoami, "^a", arg);
				     if error_count ^= 0 then
					call ioa_ ("A label cannot be a reserved word (all, a, first, f, last, l).");

				     return;
				end;
			     end;
			end;
		end;

	          else if arg = "-push" then do;
			push_wdir_flag = "1"b;

			if arg_index = nargs then;      /* -push */
			else do;                        /* -push LABEL */
			     arg_index = arg_index + 1;
			     call cu_$arg_ptr (arg_index, ap, al, code);
			     if code ^= 0 then do;
				call com_err_ (code, whoami);
				return;
			     end;

			     call LOCATION_validation (arg, stack_location, given_label_name, label_current_wdir_for_rotation,
				labels_the_current_wdir, clear_wdir_flag, push_wdir_flag);
			     if code ^= 0 then do;
				if arg = "-clear" | arg = "-pop" | arg = "-rotate" then
				     call com_err_ (0, whoami, "-push is mutually exclusive with ^a", arg);
				else do;
				     call com_err_ (code, whoami, "^a", arg);
				     if error_count ^= 0 then
					call ioa_ ("A label cannot be a reserved word (all, a, first, f, last, l).");

				     return;
				end;
			     end;				
			end;
		end;

	          else if arg = "-rotate" then do;
			rotate_wdir_flag = "1"b;

			if arg_index = nargs then
			     stack_location = 1;        /* by default */
			else do;                        /* LOCATION is specified for -rotate */
			     arg_index = arg_index + 1;
			     call cu_$arg_ptr (arg_index, ap, al, code);
			     if code ^= 0 then do;
				call com_err_ (code, whoami);
				return;
			     end;

			     call LOCATION_validation (arg, stack_location, given_label_name, label_current_wdir_for_rotation,
				labels_the_current_wdir, clear_wdir_flag, push_wdir_flag);
			     if code ^= 0 then do;
				if arg = "-clear" | arg = "-pop" | arg = "-push" then
				     call com_err_ (0, whoami, "-rotate is mutually exclusive with ^a.", arg);
				else do;
				     call com_err_ (code, whoami, "^a", arg);
				     if error_count ^= 0 then
					call ioa_ ("A label cannot be a reserved word (all, a, first, f, last, l).");

				     return;
				end;
			     end;

			     if (arg_index + 1) <= nargs then do;
                                                              /* want to label the current wdir (e.g. cwd -rotate 2 label_the_current_wdir) */
				label_current_wdir_for_rotation = "1"b;

				arg_index = arg_index + 1;
				call cu_$arg_ptr (arg_index, ap, al, code);
				if code ^= 0 then do;
				     call com_err_ (code, whoami);
				     return;
				end;

				call LOCATION_validation (arg, stack_location, given_label_name, label_current_wdir_for_rotation,
				     labels_the_current_wdir, clear_wdir_flag, push_wdir_flag);
				if code ^= 0 then do;
				     call com_err_ (code, whoami, "^a", arg);
				     if error_count ^= 0 then
					call ioa_ ("A label cannot be a reserved word (all, a, first, f, last, l).");

				     return;
				end;
			     end;
			end;
	          end;

	          else do;
		     call com_err_ (error_table_$bad_arg, whoami, "^a", arg);
		     return;
		end;
	     end;
	     else do;                                       /* PATH is specified */
		if (rotate_wdir_flag | pop_wdir_flag) then do;
                                                              /* examples: cwd -rotate 2 lable_current_wdir error; cwd -pop 2 error */
		     call com_err_ (error_table_$bad_arg, whoami, "^a", arg);
		     return;
		end;

		pathname_count = pathname_count + 1;      /* trying to protect cwd when more than one PATH is specified */
		if pathname_count > 1 then do;            /* for example: cwd change_wdir_directory canonicalize_directory */
		     call com_err_ (0, whoami, "Only one PATH is allowed.   ^a  ^a", rtrim (pathname), arg);
		     return;
		end;

		call expand_path_ (ap, al, addr (pathname), null, code);
		if code ^= 0 then do;
		     call com_err_ (code, whoami, "^a", arg);
		     return;
		end;
	     end;
	end;
     end;                                                     /* complete validating all input arguments specified on the command level. */

     error_count = 0;                                         /* for double check */

     if nargs > 2 then do;                                    /* for violating syntax, display an usage message */
	if pop_wdir_flag then
	     error_count = error_count + 1;
	
	if (rotate_wdir_flag | push_wdir_flag) & (nargs > 3) then
	     error_count = error_count + 1;
	     
	if error_count > 0 then do;
	     call com_err_ (0, whoami, "Usage:  cwd {PATH} {-control_args}");
	     call ioa_ (" ");
	     call ioa_ ("Optional control arguments:^/-clear {N;LABEL}  Default: the entire stack^/-pop {N;LABEL}  Default: 1^/-push {LABEL}^/-rotate {LABEL; N {LABEL}}  Default: 1");
               call ioa_ (" ");
	     call ioa_ ("Note that -push, -pop, -rotate, and -clear are exclusive to each other.  PATH is exclusive to -pop or -rotate");
	     return;
	end;
     end;
                                                              /* for inconsistent combination of optional arguments, cwd treats as an error */
     if (pathname ^= "") & (pop_wdir_flag | rotate_wdir_flag) then do;
	call com_err_ (error_table_$argerr, whoami);
	return;
     end;

/* do cwd */
                                                              /* The following three lines of coding is needed instead of calling the */
                                                              /* existing get_wdir internal procedure because don't want the current */
                                                              /* pathname value which contains user's specified PATH to be altered */

     call hcs_$fs_search_get_wdir (addr (current_wdir), current_wdir_length);
     if current_wdir_length = 0 then
	current_wdir = "";                                  /* to indicate there is no current wdir */
     else substr (current_wdir, current_wdir_length + 1) = "";/* fill out the rest with white spaces */
     
     if current_wdir ^= "" then                               /* save it for displaying purpose only when it will be deleted later */
	current_wdir_pathname = current_wdir;               /* the current wdir is stored in a static variable */

     if pathname ^= "" then do;                               /* PATH is specified */
	if push_wdir_flag then do;
	     if current_wdir ^= "" then                     /* push the current wdir onto the stack */
		call do_push (total_number_of_pushes);
	                                                    /* allow to change wdir to PATH even if could not find the current wdir */
	     else call ioa_ ("Warning: current wdir not pushed.  It has been deleted.  ^a", rtrim (current_wdir_pathname));
	end;

	if clear_wdir_flag then do;
	     call do_clear (total_number_of_pushes, error_count);
	     if error_count > 0 then return;
	end;
     end;
     else do;                                                 /* PATH is omitted */
	if push_wdir_flag then do;
	     call get_default_wdir ();                   /* for -push, if PATH is omitted, then sets pathname to the default wdir */

	     if current_wdir ^= "" then                  /* push the current wdir onto the stack */
		call do_push (total_number_of_pushes);

	     else if pathname = "" then do;                     /* no current wdir and no default wdir */
		     call com_err_ (0, whoami, "No default wdir set for this process.");
		     return;
	     end;
                                                                   /* allow to change to the default wdir even if there is no current wdir */
	     else call ioa_ ("Warning: current wdir not pushed.  It has been deleted.  ^a", rtrim (current_wdir_pathname));
	end;

	if pop_wdir_flag then                                    /* pop the prior wdir at a specified LOCATION out the stack */
	     call do_pop (total_number_of_pushes, pathname, error_count);

	if rotate_wdir_flag then do;
	     if current_wdir ^= "" then
		call do_rotate (pathname, error_count);        /* get the prior wdir at a specified LOCATION */
	     else do;
		call com_err_ (error_table_$no_wdir, whoami);
		return;
	     end;
	end;
          
          if clear_wdir_flag then
	     call do_clear (total_number_of_pushes, error_count);

	if error_count > 0 then 
	     return;
     end;

     if pathname ^= "" then do;  
	call hcs_$fs_search_set_wdir (pathname, code);         /* set pathname value to be the NEW current wdir. */
	if code ^= 0 then do;
	     if push_wdir_flag then do;
		if current_wdir ^= "" then
		     call com_err_ (code, whoami, "^a.  Directory ^a already pushed for you.", rtrim (pathname), rtrim (current_wdir));
		else call com_err_ (code, whoami, "^a.  Directory not pushed.", rtrim (pathname));
	     end;
	     else call com_err_ (code, whoami, "^a", rtrim (pathname));
	end;
     end;

     return;                                                /* finish cwd */

/*------------------------------------------------------------------------*/
%page;
change_default_wdir:
cdwd: entry options (variable);

/* Get the number of arguments by calling the cu_$arg_count entrypoint.   */
/* Since this entry only allows one optional argument, if more than one   */
/* argument is given, treats as an error.  If no optional argument, the   */
/* get_wdir internal procedure is called to get the pathname of the       */
/* current working directory.  Othewise it calls the expand_path_ to get  */
/* the address of the pathname of the PATH specified.                     */
/* Stores the pathname value into the default_wdir_pathname and sets      */
/* the default_wdir_set flag before terminating normality.                */

/* begin coding */
	whoami = "change_default_wdir";

	call cu_$arg_count (nargs, code);
	if code ^= 0 then do;
	     call com_err_ (code, whoami);
	     return;
	end;
          if nargs > 1 then do;
	     call com_err_ (0, whoami,
		"More than one optional argument supplied.^/Usage:  ^a {PATH}", whoami);
	     return;
	end;
          else if nargs = 0 then do;                        /* get the default wdir */
		call get_wdir ();
		if pathname = "" then do;
		     call com_err_ (error_table_$no_wdir, whoami);
		     return;
		end;
	end;
	else do;
	     call cu_$arg_ptr (1, ap, al, code);
	     if code ^= 0 then do;
		call com_err_ (code, whoami);
		return;
	     end;
	
               call expand_path_ (ap, al, addr (pathname), null, code);
	     if code ^= 0 then do;
		call com_err_ (code, whoami, "^a", arg);
		return;
	     end;
	end;
     
          default_wdir_pathname = pathname;
	default_wdir_set = "1"b;

	return;
	
/*-------------------------------------------------------------------------*/
%page;
working_dir:
wd:
print_wdir:
pwd: entry options (variable);

/* This entry is documented in the MTB 775 and approved in MCR7839.        */
/*                                                                         */
/* Its syntax either "wd {LOCATIONs} {-he; -nhe}" or "[wd {LOCATIONs}]".   */
/*                                                                         */
/* LOCATION can be either stack location N within a stack of prior wdirs   */
/* or a text string LABEL associated with a stack entry or can be one of   */
/* the following reserved words:                                           */
/*   first (f) indicates the current wdir at location 0.                   */
/*   last  (l) indicates the least recent wdir at stack location N.        */
/*   all   (a) indicates the current wdir at location 0 and all prior      */
/*             wdirs begin at stack location 1 and end at location N.      */
/*                                                                         */
/*   Note that the most recent wdir is located at stack location 1 and in  */
/*   the stack of prior wdirs.  The current wdir is NOT in the stack.      */

/* automatic variables */
     dcl control_string char (45) varying;
     dcl header_control_string char (25) varying;
     dcl comments char (31);
     dcl longest_label_length fixed bin (35);
     dcl no_header bit (1) aligned;
     dcl print_index fixed bin;
     dcl ret_ptr pointer;
     dcl ret_len fixed bin (21);
     dcl want_header bit (1) aligned;

/* based */
     dcl  ret_arg char (ret_len) varying based (ret_ptr);

     /*--------------------------------------------------------*/
%page;
wd_input_argument_validation: proc;

/* This internal procedure called by working_dir entry is self documented.  */
/* Several lines of documentation are followed by primary lines of coding.  */
			
/* begin coding */
   code = 0;
   LOCATION_before_colon = "";
   LOCATION_after_colon = "";

   do arg_index = 1 to nargs;                               /* scan through all input arguments specified on the command level */

        call cu_$arg_ptr (arg_index, ap, al, code);         /* get an input argument specified on the command level */
        if code ^= 0 then do;
	   if active_function then
	        call active_fnc_err_ (code, whoami);
	   else call com_err_ (code, whoami);
             return;
        end;

        if index (arg, "-") = 1 then do;                    /* the first character of a specified input argument is a minus sign */
	   
	   if arg = "-header" | arg = "-he" then do;
	        want_header = "1"b;

	        error_count = error_count + 1;            /* prepare for the case of -he and -nhe are both specified */
	   end;
             else if arg = "-no_header" | arg = "-nhe" then do;
		   no_header = "1"b;

		   error_count = error_count + 1;       /* prepare for the case of both -he and -nhe are specified */
	   end;
             else do;                                        /* neither -header (-he) nor -no_header (-nhe) specified, wd reports an error */
	        code = error_table_$badopt;
RETURN:
	        if active_function then
		   call active_fnc_err_ (code, whoami, "^a", arg);
	        else call com_err_ (code, whoami, "^a", arg);
	        return;
	   end;
        end;                                                /* the first character of a specified input argument is a minus sign */

        else do;                                             /* the specified input argument is a LOCATION */
	   if index (arg, ":") > 0 then do;
                                                             /* LOCATION is a stack range identified by a given colon in it */
	        LOCATION_before_colon = before (arg, ":");
	        LOCATION_after_colon  = after (arg, ":");
	        
	        if LOCATION_before_colon = "" | LOCATION_after_colon = "" then do;
		   code = error_table_$bad_arg;
		   goto RETURN;
	        end;
	   end;
        
             if arg = "first" | arg = "f" then do;           /* LOCATION is a reserved word named first (f) */
	        stack_location = 0;
	        call save_a_valid_LOCATION (max_array_index, stack_location);
	   end;
        
             else if arg = "last" | arg = "l" then do;       /* LOCATION is a reerved word named last (l) */
		   if total_number_of_pushes > 0 then do;
		        stack_location = total_number_of_pushes;
		        call save_a_valid_LOCATION (max_array_index, stack_location);
		   end;
	             else do;
		        if active_function then
			   call active_fnc_err_ (0, whoami, "Empty stack of prior wdir.");
		        else call com_err_ (0, whoami, "Empty stack of prior wdir.");
		        return;
		   end;
	   end;
        
             else if arg = "all" | arg = "a" then do;        /* LOCATION is a reserved word named last (l) */
		   stack_location = 0;
		   call save_a_valid_LOCATION (max_array_index, stack_location);
		   
		   if total_number_of_pushes > 0 then do;
		        stack_location = total_number_of_pushes;
		        call CONTINUE_save_good_data (max_array_index, stack_location, code);
		   end;
	             else;                                 /* do not treat as an error.  Let print or return the current wdir */
	   end;
        
             else if verify (substr (arg, 1, 1), ALLOWED_DIGITS) = 0 then do;
                                                             /* the first character of LOCATION is specified as a decimal digit */

		   if index (arg, ":") = 0 then do;
                                                             /* it is considered as a stack position N */
		        stack_location = cv_dec_check_ (arg, code);
		        if code ^= 0 then
			   goto RETURN;

		        if stack_location > total_number_of_pushes then do;
			   code = error_table_$bad_arg;
			   goto RETURN;
		        end;

		        stack_location = abs (stack_location);
		        call save_a_valid_LOCATION (max_array_index, stack_location);
		   end;
	             else do;                               /* it is a mix range of N and one of the following: N, LABEL, or a reserved word */
		        stack_location = cv_dec_check_ ((LOCATION_before_colon), code);
		        if code ^= 0 then
			   goto RETURN;
                                                              /* save the first part of a range which is a stack position N into an array */
		        if stack_location > total_number_of_pushes then do;
			   code = error_table_$bad_arg;
			   goto RETURN;
		        end;

		        stack_location = abs (stack_location);
		        call save_a_valid_LOCATION (max_array_index, stack_location);
		                                          /* continue to validate the second part of the range */
		        call LOCATION_continue_validation ((LOCATION_after_colon), max_array_index, stack_location, code);
		   end;
             end;                                             /* the first character of LOCATION is a decimal digit */

             else do;                                         /* LOCATION is specified a text string */
	        if index (arg, ":") = 0 then
		   call LABEL_validation (arg, max_array_index, stack_location, code);
	        else do;                                    /* the text string specified is a stack range */
		   if LOCATION_before_colon = "first" | LOCATION_before_colon = "f" then do;
		        stack_location = 0;
		        call save_a_valid_LOCATION (max_array_index, stack_location);
		   end;
	        
	             else if LOCATION_before_colon = "last" | LOCATION_before_colon = "l" then do;
			   code = error_table_$bad_arg;
			   goto RETURN;
		   end;
	        
	             else if LOCATION_before_colon = "all" | LOCATION_before_colon = "a" then do;
			   code = error_table_$bad_arg;
			   goto RETURN;
		   end;
	        
	             else do;
		        call LABEL_validation ((LOCATION_before_colon), max_array_index, stack_location, code);
		        if code ^= 0 then goto RETURN;
		   end;
		   
		   call LOCATION_continue_validation ((LOCATION_after_colon), max_array_index, stack_location, code);
		   if code ^= 0 then do;
		        if (LOCATION_after_colon = "last" | LOCATION_after_colon = "l") & total_number_of_pushes = 0 then
			   code = 0;                      /* let pwd print the first portion of the range (e.g. pwd f:l) */
		   end;
	        end;                                   /* the text string specified is a range */
	   end;                                        /* LOCATION is specified as a text string */

             if code ^= 0 then goto RETURN;              /* an error found during parsing a specified LOCATION */             
        end;                                             /* the specified input argument is a LOCATION */
   end;                                                  /* validate each input argument given on the command level */

   return;                                               /* return to working_dir entry */
   
   end wd_input_argument_validation;

               /*---------------------------------------------*/
%page;
/* main program of working_dir */
     temp_ptr = null;
     max_array_index = 0;
     stack_location = - 1;
     location_array (*) = - 1;
     longest_label_length = 0;
     want_header = "0"b;
     no_header = "0"b;
     error_count = 0;

     call get_wdir ();                                    /* sets pathname to current working dir */

     whoami = "working_dir";                               /* my primary name is working_dir */

     call cu_$af_return_arg (nargs, ret_ptr, ret_len, code);
     if code ^= 0 then do;
	if code = error_table_$not_act_fnc then          /* i was specified as a command */
	     active_function = "0"b;
	else do;
	     call active_fnc_err_ (code, whoami);
	     return;
	end;
     end;
     else do;                                              /* i was specified as an active function */
	active_function = "1"b;
	ret_arg = "";
     end;

     if nargs = 0 then do;                                 /* users interest on the current wdir only */
	if pathname = " " then do;                       /* the current wdir has been deleted */
	     code = error_table_$no_wdir;
	     if active_function then
		call active_fnc_err_ (code, whoami);
	     else call com_err_ (code, whoami);
	     return;
	end;
     
	if active_function then                           /* return the current wdir */
	     ret_arg = requote_string_ (rtrim(pathname));
	else call ioa_ ("^a", rtrim (pathname));          /* print out the current wdir */
     end;


     call wd_input_argument_validation;                     /* validate each input argument given on the command level */
     if code ^= 0 then return;

     if error_count > 1 then do;
	call com_err_ (0, whoami, "Both -header (-he) and -no_header (-nhe) are specified.");
	return;
     end;
     else error_count = 0;

     if (want_header | no_header) & active_function then do;
	call active_fnc_err_ (0, whoami, "Usage: [wd {LOCATIONs}]");
	return;
     end;


                                                            /* case only a valid control argument is specified on the command level */
     if nargs = 1 then do;
	if arg = "-header" | arg = "-he" | arg = "-no_header" | arg = "-nhe"  then do;
	     if pathname = " " then do;
		call com_err_ (error_table_$no_wdir, whoami);
		return;
	     end;
	
	     if arg = "-header" | arg = "-he" then do;
		call ioa_ ("LOC LABEL PATHNAME");
		call ioa_ (" ");
	     end;

	     call ioa_ ("^10x^a", rtrim (pathname));
	end;
     end;


                                                            /* for indentation, find the longest length of label name, given LOCATIONS */
     do array_index = 1 to max_array_index;                 /* loop through the entire array which contains one or more LOCATIONs to be printed */

	if location_array (array_index) = 0 then do;      /* indicate the current wdir */
	     if length (label_name_of_current_wdir) > longest_label_length then
		longest_label_length = length (label_name_of_current_wdir);
	end;

	temp_ptr = last_node_ptr;
	                                                  /* scan the linked list of prior wdirs from index 1 to a specified LOCATION */
	do print_index = 1 to location_array (array_index);

                                                            /* have i reached a specified LOCATION yet? */
	     if print_index = location_array (array_index) then do;
                                                            /* is the label length at that specified LOCATION longest length? */
		if length (temp_ptr -> stack_linked_list.label_name) > longest_label_length then
		     longest_label_length = length (temp_ptr -> stack_linked_list.label_name);
	     end;
	     else temp_ptr = temp_ptr -> stack_linked_list.back_ptr;
	end;
     end;

                                                            /* then build control string for ioa_ calls later.  Indentation purpose only */
     if want_header | ^no_header then do;                   /* either users want header when only a single LOCATION is printed or */
                                                            /* pwd only prints a header when more than one LOCATIONs are printed (by default) */
	if longest_label_length < 5 then
	     longest_label_length = 5;                    /* 5 indicates the total number of characters of "LABEL" */
     end;
                                                            /* for stack entry, adjust the distance between associated label and a wdir */
     control_string = "^4d ^" || ltrim (char (longest_label_length));
     control_string = control_string || "a ^a";
                                                            /* for the header, adjust the distance between "LABEL" and "PATHNAME" */
     header_control_string = " LOC LABEL^" || ltrim (char (longest_label_length - 5));
     header_control_string = header_control_string || "x PATHNAME";

     if pathname ^= "" then
	current_wdir_pathname = pathname;                 /* save the current wdir for printting only if it is deleted and want to print it */

                                                            /* print or return wdir(s) at specified LOCATION(s) */
     do array_index = 1 to max_array_index;

	temp_ptr = last_node_ptr;

	if (array_index = 1) & (max_array_index > 1) & (^active_function) then do;
                                                            /* as a command, print out the header once when more than one LOCATION is asked */
	     if ^no_header then do;                       /* by default */
		call ioa_ (header_control_string);
		call ioa_ (" ");
	     end;
	end;

	if location_array (array_index) = 0 then do;      /* is it the current wdir? */
	     print_index = 0;                             /* to indicate the current wdir */

	     if max_array_index = 1 then do;              /* case of only the current wdir is printed or returned */
		if pathname = " " then do;              /* the current wdir has been deleted */
		     if active_function then
			call active_fnc_err_ (error_table_$no_wdir, whoami);
		     else call com_err_ (error_table_$no_wdir, whoami);
		     return;
		end;
	          else do;                                /* the current wdir still exists */
		     if active_function then
			ret_arg = rtrim (pathname);   /* return the current wdir */
		     else do;                           /* print out the current wdir on the terminal */
			if want_header then do;       /* users also want the header to be printed */
			     call ioa_ (header_control_string);
			     call ioa_ (" ");
			end;

		          call ioa_ (control_string, print_index, label_name_of_current_wdir, rtrim (pathname));
		     end;
		end;
	     end;                                         /* case of printing or returning only the current wdir */
               else do;                                     /* print or return the current wdir and AT LEAST one prior wdir */
		if active_function then do;            /* as an active function, needs to find out whether the current wdir exists or not */
		     if array_index ^= 1 then          /* not the first time go into the do loop */
			ret_arg = ret_arg || " ";    /* prepare to return the next prior wdir pathname */
		     
		     if pathname ^= "" then            /* the current wdir exists.  Return it to an user */
			ret_arg = ret_arg || rtrim (pathname);
                                                            /* the current wdir has been deleted, returns it, its value was saved earlier */
		     else ret_arg = ret_arg || rtrim (current_wdir_pathname);
		end;                                    /* as an active function */
		else do;                                /* as a command, must find out whether the current wdir exist or not */
		     if pathname ^= " " then            /* if the current wdir still exists, print it out */
			call ioa_ (control_string, print_index, rtrim (label_name_of_current_wdir), rtrim (pathname));
		     else do;                           /* the current wdir has been deleted */
			comments = "[current wdir has been deleted]";

			call ioa_ (control_string, print_index, rtrim (label_name_of_current_wdir),
			     rtrim (current_wdir_pathname) || " " || comments);
		     end;                               /* the current wdir has been deleted */
		end;                                    /* as a command, must find out whether the current wdir exists or not */
               end;                                         /* case of the current wdir and AT LEAST ONE MORE stack entry are printed or returned */
	end;                                              /* finish to print or return the current wdir */

                                                            /* scan the linked list of prior wdirs from index 1 to a specified LOCATION */
          do print_index = 1 to location_array (array_index);

	     if (print_index = 1) & (max_array_index = 1) & (^active_function) then do;
		if want_header then do;                 /* users want to print the header when only one LOCATION is printed out */
		     call ioa_ (header_control_string);
		     call ioa_ (" ");
		end;
	     end;

	     if print_index = location_array (array_index) then do;

		if active_function then do;            /* return a prior wdir at a specified LOCATION */
		     if print_index ^= 1 | ret_arg ^= " " then
			ret_arg = ret_arg || " ";    /* for returning several stack entries, separated by a white space */
		     ret_arg = ret_arg || temp_ptr -> stack_linked_list.wdir_name;
		end;
                                                           /* print out a prior wdir at a specified LOCATION */
		else call ioa_ (control_string, print_index, temp_ptr -> stack_linked_list.label_name, temp_ptr -> stack_linked_list.wdir_name);
	     end;
                                                          /* have not reached a specified LOCATION yet */
	     else temp_ptr = temp_ptr -> stack_linked_list.back_ptr;
	end;                                            /* complete printed or returned a single wdir at a specified LOCATION */
     end;                                                 /* complete printed or returned wdir(s) at specified LOCATION(s) */
     
     return;                                              /* complete working_dir */

/*---------------------------------------------------------------------------*/
%page;
print_default_wdir:
pdwd: entry options (variable);

/* begin coding */
     whoami = "print_default_wdir";

     call cu_$arg_count (nargs, code);
     if code ^= 0 then do;
	call com_err_ (code, whoami);
	return;
     end;

     if nargs > 0 then do;                                  /* no arguments allowed at all ... */
	call com_err_ (0, whoami, "This command takes no arguments.^/Usage:^_^a", whoami);
	return;
     end;

     call get_default_wdir ();                              /* get the default wdir */

     if pathname = "" then                                  /* no default wdir */
	call com_err_ (error_table_$no_wdir, whoami);
     else call ioa_ ("^a", rtrim (pathname));               /* prints it out */
     
     return;                                                /* all done with print_default_wdir */

/*-------------------------------------------------------------------------- */
%page;
get_wdir_: entry () returns (char (168));

     call get_wdir ();				/* sets pathname */

     if pathname = "" then do;			/* no wdir, warn the user */
	call sub_err_ (error_table_$no_wdir, "get_wdir_", "h", null (), (0), "");
	return ("");				/* return nothing */
     end;

     return (pathname);                                     /* all done with get_wdir_ */

/*---------------------------------------------------------------------------*/
%page;
get_default_wdir_: entry () returns (char (168));

/* begin coding */
     call get_default_wdir ();                              /* sets pathname to the default wdir */

     return (pathname);                                     /* all done with get_default_wdir_ */

/*--------------------------------------------------------------------------*/
%page;
change_wdir_: entry (P_pathname, P_code);

     dcl (P_pathname char (168),
          P_code fixed bin (35)) parameter;

     call hcs_$fs_search_set_wdir (P_pathname, P_code);     /* set it, and just return the code */

     return;                                                /* all done with change_wdir_ */

/*---------------------------------------------------------------------------*/
%page;
change_default_wdir_: entry (P_pathname, P_code);

     default_wdir_pathname = P_pathname;
     default_wdir_set = "1"b;

     P_code = 0;

     return;                                               /* all done with change_default_wdir_ */

/*--------------------------------------------------------------------------*/
%page;
get_wdir: proc ();

/* sets pathname to the current wdir pathname.  If there is no current wdir */
/* pathname is set to a null string.                                        */

     call hcs_$fs_search_get_wdir (addr (pathname), current_wdir_length);

     if current_wdir_length = 0 then
	pathname = "";	                              /* set it to the null string to indicate no wdir */

     else substr (pathname, current_wdir_length + 1) = "";  /* otherwise, fill the rest with spaces */

     return;

     end get_wdir;

/*-------------------------------------------------------------------------*/
%page;
get_default_wdir: proc ();

     if ^default_wdir_set then do; 		/* first call, sets the default wdir to home_dir */
	call user_info_$homedir (default_wdir_pathname);

	default_wdir_set = "1"b;                /* indicate this has been done */
     end;

     pathname = default_wdir_pathname;            /* sets pathname */

     return;

     end get_default_wdir;
/*-------------------------------------------------------------------------*/
%page;
CONTINUE_save_good_data: proc (p_max_array_index, p_stack_pos, p_ec);

/* Several consective stack locations are saved in an array.               */
/* Note that a specified LOCATION was identified as a range of either a    */
/* stack location range (e.g. 3:7), a label range (e.g. x:y), or a mixed   */
/* range (e.g. x:5; 3:z; first:z; first:3, ect.).  This range of a certain */
/* kind will be stored in an array as numeric digits.                      */

                                                            /* parameter   */
     dcl p_max_array_index fixed bin;
     dcl p_ec fixed bin (35);
     dcl p_stack_pos fixed bin (35);
                                                            /* local */
     dcl next_stack_position fixed bin (35);
     dcl next_stack_pos fixed bin (35);

/* begin coding */
     if p_stack_pos <= location_array (p_max_array_index) then do;
	p_ec = error_table_$bad_arg;                      /* for examples: 10:10 10:4 */
	return;
     end;
     else do;
	next_stack_pos = location_array (p_max_array_index) + 1;

	do next_stack_position = next_stack_pos to p_stack_pos;
	     p_max_array_index = p_max_array_index + 1;
	     location_array (p_max_array_index) = next_stack_position;
	end;
     end;

     return;
     
     end CONTINUE_save_good_data;

/*---------------------------------------------------------------------------*/
%page;
LOCATION_continue_validation: proc (p_LOCATION_after_colon, p_max_arr_indx, p_stack_loctn, p_ecode);

/* continue to validate the remaining character string after a colon         */
/* character was found. (e.g. 3:7, 5:label_x, first:y, z:w, ect) when        */
/* LOCATION was specified as a range which known by a colon character.       */

                                                        /* parameters */
     dcl p_LOCATION_after_colon char (*);
     dcl p_ecode fixed bin (35);
     dcl p_max_arr_indx fixed bin;
     dcl p_stack_loctn fixed bin (35);
                                                        /* local */
     dcl found bit (1) aligned;
     dcl search_index fixed bin (35);
     dcl search_ptr ptr;
     dcl skip_index fixed bin (35);

/* begin coding */
     found = "0"b;
     skip_index = 0;
     search_index = 0;
     search_ptr = null;

     if verify (substr (p_LOCATION_after_colon, 1, 1), ALLOWED_DIGITS) = 0 then do;
		                                            /* LOCATION is a range of stack positions (e.g. 10:16) */
	p_stack_loctn = cv_dec_check_ (p_LOCATION_after_colon, p_ecode);
	if p_ecode ^= 0 then return;

	if p_stack_loctn > total_number_of_pushes then do;
	     p_ecode = error_table_$bad_arg;
	     return;
	end;

	p_stack_loctn = abs (p_stack_loctn);
                                                                /* save them */
	call CONTINUE_save_good_data (p_max_arr_indx, p_stack_loctn, p_ecode);
     end;

     else if p_LOCATION_after_colon = "first" | p_LOCATION_after_colon = "f" then 
	p_ecode = error_table_$bad_arg;                  /* e.g. 10:first */

     else if p_LOCATION_after_colon = "all" | p_LOCATION_after_colon = "a" then
	p_ecode = error_table_$bad_arg;
		
     else if p_LOCATION_after_colon = "last" | p_LOCATION_after_colon = "l" then do;
	     p_stack_loctn = total_number_of_pushes;     /* e.g. 10:last */

	     call CONTINUE_save_good_data (p_max_arr_indx, p_stack_loctn, p_ecode);
      end;

      else do;
	 if index (p_LOCATION_after_colon, "-") = 1 then do;
	      p_ecode = error_table_$badopt;
	      return;
	 end;
		     
           if index (p_LOCATION_after_colon, ":") > 0 then do;
	      p_ecode = error_table_$bad_arg;
	      return;
	 end;

	 if length (p_LOCATION_after_colon) > MAX_LENGTH_LABEL_NAME then do;
	      p_ecode = error_table_$bigarg;
	      return;
	 end;
                                                           /* search for a matched label name */
           search_ptr = last_node_ptr;
	 do skip_index = 1 to p_stack_loctn;
	      search_ptr = search_ptr -> stack_linked_list.back_ptr;
	 end;

	 do search_index = (p_stack_loctn + 1) to total_number_of_pushes while (^found);
	      if p_LOCATION_after_colon = search_ptr -> stack_linked_list.label_name then
		 found = "1"b;
	      else search_ptr = search_ptr -> stack_linked_list.back_ptr;
	 end;
		
	 if (search_index > total_number_of_pushes) & (^found) then do;
	      p_ecode = error_table_$bad_arg;
	      return;
	 end;
		     
	 search_index = search_index - 1;                     /* calculate the correct value of search_index after leaving do loop */
	 p_stack_loctn = abs (search_index);

	 call CONTINUE_save_good_data (p_max_arr_indx, p_stack_loctn, p_ecode);
      end;

      return;
      
      end LOCATION_continue_validation;

/*---------------------------------------------------------------------------*/
%page;
save_a_valid_LOCATION: proc (p_max_arr_index, p_stack_loc);

/* save a valid stack location into an array.                                */
		                                           /* parameter  */
     dcl p_max_arr_index fixed bin;
     dcl p_stack_loc fixed bin (35);
		 
/* begin coding */
     p_max_arr_index = p_max_arr_index + 1;
     location_array (p_max_arr_index) = p_stack_loc;

     return;
      
     end save_a_valid_LOCATION;

/*---------------------------------------------------------------------------*/
%page;
LABEL_validation: proc (para_arg, para_max_array_index, para_stack_pos, para_ec);

/* validate that a given LABEL length is less or equal the maximum length    */
/* allowed, 32 characters.  Also it must be defined that means it must be    */
/* attached to a prior wdir in some earlier time.                            */

                                                             /* parameter    */
     dcl para_arg char (*);
     dcl para_ec fixed bin (35);
     dcl para_max_array_index fixed bin;
     dcl para_stack_pos fixed bin (35);
	                                                   /* local */
     dcl match_label_name bit (1) aligned;
     dcl searching_index fixed bin (35);
     dcl searching_ptr ptr;

/* begin coding */
     match_label_name = "0"b;
     searching_ptr = null;
     
     if length (para_arg) > MAX_LENGTH_LABEL_NAME then do;
	para_ec = error_table_$bigarg;
	return;
     end;

     searching_ptr = last_node_ptr;
     do searching_index = 1 to total_number_of_pushes while (^match_label_name);
	if searching_ptr -> stack_linked_list.label_name = para_arg then
	     match_label_name = "1"b;
	else searching_ptr = searching_ptr -> stack_linked_list.back_ptr;
     end;

     if searching_index > total_number_of_pushes & ^match_label_name then do;
	para_ec = error_table_$bad_arg;
	return;
     end;

     searching_index = searching_index - 1;                         /* calculate the correct value of search_index after leaving the do loop */
     para_stack_pos = abs (searching_index);

     call save_a_valid_LOCATION (para_max_array_index, para_stack_pos);
     
     return;
     
     end LABEL_validation;

/*--------------------------------------------------------------------------*/

     end directory_commands_;
