/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   * Copyright (c) 1972 by Massachusetts Institute of        *
   * Technology and Honeywell Information Systems, Inc.      *
   *                                                         *
   *********************************************************** */


/* format: style4,delnl,insnl,indattr,ifthen,dclind9 */
tdcm_:
     procedure;

/*	This is the non-ring 0 version of the tape DCM.
   *	Recoded from ring 0 version by Bill Silver on 09/30/74.
   *	Modified for preloaded volumes by Michael R. Jordan on 04/28/78.
   *	Modified 7/79 by R.J.C. Kissel to user version 1 tseg.
   *	Modified 03/82 by Chris Jones for version 2 tseg.
   *	Modified 3/82 by J. A. Bush for Marker interrupt processing
   *	Modified 7/13/82 by J. A. Bush to fix some interrupt processing bugs
   *
   *	This version of this program is part of the initial "dummy"
   *	installation of RCP.
   *
   *	tdcm_ interfaces with RCP in order to perform device management
   *	functions.  It interfaces with IOI in order to perform the
   *	actual tape I/O. Notes about this procedure:
   *	1.  In general all entry points function in the same way.
   *	2.  The caller of tdcm_ must be aware that the first tseg buffer
   *	    and tseg.drive_number are not valid between the call to
   *	    tdcm_$tdcm_attach and the first call to tdcm_$tdcm_message.
   *	3.  tdcm_$tdcm_message must be called after the call to tdcm_attach or
   *	    after a call to tdcm_$tdcm_detach in which the drive assignment has
   *	    been retained.  Subsequent calls to tdcm_$tdcm_message will temporarily
   *	    still type a mount message on the operator's console.
   *	4.  I/O modules no longer need to check that the tape drive is ready or
   *	    that the volume is at BOT or that the write ring is set correctly.
   *	    RCP does all of this checking.
   *	5.  tdcm_$tdcm_priv_attach is no longer supported.  RCP checks to see
   *	    if a process is privileged.
   *	6.  tdcm_$tdcm_mount_bit_set and tdcm_$tdcm_mount_bit_get are no
   *	    longer supported.
   *	7.  A new entry point, tdcm_set_disposition, is available.
   *	    It allows the user to specify a disposition value to be given
   *	    to RCP when the tape drive is detached.
   *	8.  Two new entry points are now available: tdcm_set_buf_size and
   *	    tdcm_get_buf_size;  They allow the caller to adjust the size of
   *	    the tdcm_ I/O buffer.
*/

/*		ARGUMENT  DATA		*/

dcl      arg_buf_size	  fixed bin;		/* (I/O) Size of tdcm_ I/O buffer. */
dcl      arg_call_data_ptr	  ptr;			/* (I) Pointer to event call data structure. */
dcl      arg_disposition	  bit (*);		/* (I) Disposition value given to RCP. */
dcl      arg_ecode		  fixed bin (35);		/* (O) Standard error_table_ code. */
dcl      arg_reel_name	  char (*);		/* (I) Tape reel ID name plus qualifiers. */
dcl      arg_tsegp		  ptr;			/* (I) Pointer to user's tseg. */
dcl      arg_val_level	  fixed bin;		/* (I) Validation level to be set. */
dcl      arg_write_sw	  fixed bin (1);		/* (I) 1 => write, 0 => read. */


/*		AUTOMATIC  DATA		*/

dcl      1 event_data	  like call_data;		/* Not really used. */

dcl      call_data_ptr	  ptr;			/* Pointer to event call data structure. */
dcl      wbuf_ptr		  ptr;			/* Pointer to buffer in IOIworkspace. */

dcl      buf_size		  fixed bin;		/* Used to copy buffer size argument. */
dcl      data_size		  fixed bin;		/* Number of words to be moved by based_data. */
dcl      dcw_tally		  fixed bin (18);		/* Number of words to be move by single DCW. */
dcl      ecode		  fixed bin (35);		/* Temporary error code. */
dcl      fix		  fixed bin;		/* Used to correct read count. */
dcl      tmr		  bit (1) aligned;
dcl      ck_level		  fixed bin (3);		/* interrupt level returned by CK_STATQ */
dcl      (i, sqx)		  fixed bin;
dcl      listx		  fixed bin;		/* Index to last IDCW that was executed. */
dcl      new_val_level	  fixed bin;		/* Used to copy validation level argument. */
dcl      op_count		  fixed bin;		/* Number of commands or buffers in I/O. */
dcl      (tbuf_num, wbuf_num)	  fixed bin;		/* Number of tseg buffer. */
dcl      tot_data_size	  fixed bin;		/* Tot num of words written with 1 connect. */
dcl      special_flag	  bit (1) aligned;		/* ON => we have special status. */
dcl      special_status_word	  bit (36) aligned;		/* Status word for special interrupts. */
dcl      data_idcw		  bit (36) aligned;		/* to copy current data xfer idcw into */
dcl      (io_time, delta)	  fixed bin (71);
dcl      (pfs, pf_code)	  fixed bin (35);

/*		BASED  DATA		*/

dcl      based_data		  (data_size) fixed bin (35) aligned based;
						/* Used to move data. */

dcl      based_idcw		  bit (36) aligned based (idcwp);

dcl      1 call_data	  based (call_data_ptr) aligned,
						/* Data structure for event calls. */
	 2 channel_id	  fixed bin (71),
	 2 message	  fixed bin (71),
	 2 sender		  bit (36),
	 2 orgin,
	 ( 3 dev_signal	  bit (18),
	   3 ring		  bit (18)
	   )		  unaligned,
	 2 data_ptr	  ptr;			/* Points to IOIworkspace. */


/*		EXTERNAL ENTRIES CALLED	*/

dcl      (addr, addrel, baseptr, bin, bit, clock, divide, hbound, min, ptr, rel, string, substr)
			  builtin;

dcl      (
         error_table_$bad_arg,
         error_table_$buffer_big,
         error_table_$invalid_state,
         error_table_$out_of_main_memory,
         error_table_$unimplemented_version,
         error_table_$net_timeout,
         error_table_$too_many_buffers
         )		  fixed bin (35) external;

dcl      display_meters	  bit (1) aligned static options (constant) init ("0"b);
						/* if meters are to be displayed at detach time, set to ("1"b) */

dcl      convert_ipc_code_	  entry (fixed bin (35));
dcl      hcs_$wakeup	  entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
dcl      ioi_$connect	  entry (fixed bin, fixed bin, fixed bin (35));
dcl      ioi_$set_event	  entry (fixed bin, fixed bin (71), fixed bin (35));
dcl      ioi_$get_special_status
			  entry (fixed bin, bit (1) aligned, bit (36) aligned, fixed bin (35));
dcl      ipc_$drain_chn	  entry (fixed bin (71), fixed bin (35));
dcl      ipc_$block		  entry (ptr, ptr, fixed bin (35));
dcl      rcp_$promote	  entry (bit (36) aligned, fixed bin, fixed bin (35));
dcl      tdcm_$tdcm_reset_signal
			  entry (ptr, fixed bin (35));
dcl      tdcm_attach_	  entry (ptr, fixed bin (35));
dcl      tdcm_detach_	  entry (ptr, fixed bin (35));
dcl      tdcm_message_	  entry (ptr, ptr, char (*), fixed bin (1), fixed bin (35));
dcl      mhcs_$get_seg_usage_ptr
			  entry (ptr, fixed bin (35), fixed bin (35));
dcl      ioa_		  entry options (variable);
%page;
%include tseg;
%page;
%include tdcm_info;
%page;
%include ioi_stat;
%page;
%include iom_stat;
%page;
%include iom_pcw;
%include iom_dcw;
%page;
tdcm_attach:
     entry (arg_tsegp, arg_ecode);

/*	The following entry points will be implemented as external procedures.
   *	This is done in order to reduce the size of tdcm_.pl1.
*/
	call tdcm_attach_ (arg_tsegp, arg_ecode);
	return;




tdcm_message:
     entry (arg_tsegp, arg_reel_name, arg_write_sw, arg_ecode);

	call SETUP;				/* Initialize and validate. */
	ws.info.subset_size = divide (hbound (ws.rw_list, 1), 2, 17, 0);
						/* set up max subset size */
	call tdcm_message_ (tsegp, ws_ptr, arg_reel_name, arg_write_sw, arg_ecode);
	return;




tdcm_detach:
     entry (arg_tsegp, arg_ecode);

	call SETUP;				/* Initialize and validate. */

	if ws.info.flags.good_ws then do;
	     call REWIND_TAPE;			/* TERMPORARY for DUMMY RCP. */
	     call tdcm_$tdcm_reset_signal (tsegp, ecode); /* set up to ignore special interrupt */
	     if display_meters then do;		/* this will normally be shut off */
		call mhcs_$get_seg_usage_ptr (tsegp, pfs, pf_code);
		call ioa_ ("^/Total number of data xfer I/O calls:^2-^d", ws.number_ios + 1);
		call ioa_ ("Highest number of blocks/data xfer I/O call:^-^d", ws.info.block_count);
		call ioa_ ("Average Time between data xfer I/O calls:^-^.3f MS",
		     float (ws.io_delta / ws.number_ios) / 1000);
		call ioa_ ("Longest time between data xfer I/O calls:^-^.3f MS", float (ws.high_delta) / 1000);
		call ioa_ ("Shortest time between data xfer I/O calls:^-^.3f MS", float (ws.low_delta) / 1000);
		call ioa_ ("Number of calls to ipc_$block:^2-^d", ws.info.block);
		call ioa_ ("Times status queue processed w/o going blocked:^-^d", ws.info.no_block);
		call ioa_ ("Total number of terminate interrupts:^2-^d", ws.info.term_st);
		call ioa_ ("Number of terminate interrupts without errors:^-^d", ws.info.term_ne);
		call ioa_ ("Total number of marker interrupts:^2-^d", ws.info.mark_st);
		call ioa_ ("Most consecutive number of marker interrupts:^-^d", ws.most_consec_mark);
		call ioa_ ("Number of page faults taken on tseg:^2-^d", pfs);
		call mhcs_$get_seg_usage_ptr (ws_ptr, pfs, pf_code);
		call ioa_ ("Number of page faults taken on workspace:^-^d^/", pfs);
	     end;
	end;
	call tdcm_detach_ (ws_ptr, arg_ecode);
	return;
%page;
tdcm_set_signal:
     entry (arg_tsegp, arg_ecode);

/*	This entry point is called whenever the caller wants to be waked
   *	up when a special interrupt is received from the tape drive.
   *	Until this entry is called all special interrupts will be ignored.
   *	In order to implement this feature we must change the event
   *	channel that IOIis using to communicate with us.  We will
   *	use an event call channel instead of the fast event channel.
   *	This means that when IOI sends a wakeup we will enter the call
   *	handler tdcm_$special_handler rather than being waked up in
   *	WAIT_FOR_STATUS.  If the tape drive is not yet attached we will save
   *	the ID of the event channel we want to use.  It will be set up with
   *	IOIafter the attachment is made.
*/
	call SETUP;				/* Initialize and validate. */

	if ws.info.flags.attached			/* If attached switch, else save. */
	then call ioi_$set_event (ws.info.ioix, ws.info.special_echan, ecode);
	else ws.info.init_echan = ws.info.special_echan;

	arg_ecode = ecode;
	return;





tdcm_reset_signal:
     entry (arg_tsegp, arg_ecode);

/*	This entry point is called when the caller is no longer
   *	interrested in special interrupts.  We will swap back the
   *	the event channels that we changed in tdcm_set_signal.
   *	We will use the fast event channel again.
*/
	call SETUP;				/* Initialize and validate. */

	if ws.info.flags.attached			/* If attached switch back, else save. */
	then call ioi_$set_event (ws.info.ioix, ws.info.fast_echan, ecode);
	else ws.info.init_echan = ws.info.fast_echan;

	arg_ecode = ecode;
	return;
%page;
tdcm_promote:
     entry (arg_tsegp, arg_val_level, arg_ecode);

/*	This entry point is called to promote the validation level of the
   *	specified tape drive.  The validation level will already be set
   *	to the caller's validation level.  If this entry point is called
   *	before this drive is attached we will get an error from IOI.
*/
	call SETUP;				/* Initialize and validate. */

	new_val_level = arg_val_level;		/* Copy validation level caller wants to set. */
	call rcp_$promote (ws.info.rcp_id, new_val_level, ecode);

	arg_ecode = ecode;
	return;





tdcm_set_disposition:
     entry (arg_tsegp, arg_disposition, arg_ecode);

/*	This entry is called to specify a disposition to be passed to RCP
   *	when this drive is detached.  If this entry point is called
   *	before this drive is attached we will return an error.
*/
	call SETUP;

	if ^ws.info.flags.attached			/* Make sure tape drive is attached. */
	then do;					/* Not attached, return error. */
	     arg_ecode = error_table_$invalid_state;
	     return;
	end;

	ws.info.disposition = arg_disposition;		/* Save caller's disposition. */

	arg_ecode = ecode;
	return;
%page;
tdcm_set_buf_size:
     entry (arg_tsegp, arg_buf_size, arg_ecode);

/*	This entry point is called to set the size of the tdcm_ I/O buffer.
   *	The default tdcm_ I/O buffer size is 2080 words.  The actual buffer size
   *	used is also a function of the maximum workspace size available from IOI.
   *	This entry point must be called before the first call to tdcm_$tdcm_message.
*/
	call SETUP;

	buf_size = arg_buf_size;			/* Copy argument. */

	if ws.info.flags.attached then do;		/* Is tape drive already attached? */
	     arg_ecode = error_table_$invalid_state;	/* Yes, buffer size already established. */
	     return;
	end;

	if buf_size < 1 then do;			/* Is buffer size too small? */
	     arg_ecode = error_table_$bad_arg;		/* Yes, don't change the buffer size. */

	     return;
	end;
	if buf_size = 1040 * 6 then do;		/* tape_mult_ with "-sys" option? */
	     ws.info.flags.allow_marker = "1"b;		/* yes, do marker interrupt processing */
	     buf_size = hbound (ws.rw_list, 1) * 1040;	/* set wks to mak size allowed */
	end;
	ws.info.buf_size = buf_size;			/* Set buffer size. */

	arg_ecode = 0;
	return;



tdcm_get_buf_size:
     entry (tsegp, arg_buf_size, arg_ecode);

	call SETUP;

	if ^ws.info.flags.attached then do;		/* Is tape drive attached? */
	     arg_buf_size = 0;			/* No, buffer size value not valid yet. */
	     arg_ecode = error_table_$invalid_state;
	     return;
	end;

	if ws.info.flags.allow_marker then		/* if we phonied up buffer size.. */
	     arg_buf_size = ws.info.subset_size * 1040;	/* don't tell user */
	else arg_buf_size = ws.info.buf_size;		/* Return actual buffer size. */
	arg_ecode = 0;
	return;
%page;
tdcm_iocall:
     entry (arg_tsegp, arg_ecode);

/*	This entry point is called to perform actual I/O operations on the
   *	specified tape drive.  There are two main types of I/O operations
   *	performed:  non-data transfer commands, and reads or writes.
   *	If this entry point is called before the tape drive is attached
   *	we will get an error from IOI.
*/
	call SETUP;				/* Initialize and verify. */

	tseg.completion_status = 0;			/* Initialize to imply no  status. */

IOCALL_LOOP:					/* Check status and perform I/O. */
	if ws.info.flags.connected then		/* Are _w_e currently performing I/O? */
	     if ^ws.info.flags.allow_marker then	/* and not doing marker processing? */
		call CHECK_STATUS;			/* Yes, wait for it to complete. */
	     else if tseg.command_count > 0 |		/* allowing markers, but non-data xfer or */
		     tseg.command_count + tseg.buffer_count <= 0 then
						/* if no I/O to perform */
		call CHECK_STATUS;			/* then wait for terminate status */
	if tseg.command_count + tseg.buffer_count <= 0 then
	     goto IOCALL_RETURN;			/* No I/O to perform. */

/* Write switch in tseg => error type. */
	if tseg.command_count > 0 then		/* Are there any non-data transfer commands? */
	     call NON_DATA_TRANSFER;			/* Yes, do them first. */
	else if ws.info.flags.allow_marker then		/* if doing marker interrupt processing... */
	     call MARKER_READ_WRITE;			/* go to that routine */
	else call READ_WRITE;			/* No, caller must want to read or write. */

	if tseg.sync ^= 0 then			/* Does caller want us to wait? */
	     goto IOCALL_LOOP;			/* Yes, wait until operation complete. */

IOCALL_RETURN:
	arg_ecode = ecode;
	return;
%page;
special_handler:
     entry (arg_call_data_ptr);

/*	This entry point is called to handle wakeups on the event call
   *	channel, special_echan.  This event channel is given to IOI when
   *	the user calls tdcm_set_signal.  We will call IOI to get the
   *	status for the current interrupt.
*/
	call_data_ptr = arg_call_data_ptr;		/* Get pointer to event call data. */
	ws_ptr = call_data.data_ptr;			/* The event data ptr is the workspace ptr. */

	isp = addr (ws.statq (ws.info.statqx));		/* Get pointer to current IOI status queue entry. */
	if ^istat.completion.st then			/* If no status then ignore status queue. */
	     goto GET_SPECIAL_STATUS;			/* Go see if there is special status. */

	goto SLEVEL (istat.level);			/* Go process according to level. */

SLEVEL (7):					/* Should not get special status in queue. */
	if ws.info.statqx = hbound (ws.statq, 1) then	/* Get index of next status queue entry. */
	     ws.info.statqx = 1;			/* If at end wraparound. */
	else ws.info.statqx = ws.info.statqx + 1;

	istat.completion.st = "0"b;			/* Free this status queue entry. */

	goto GET_SPECIAL_STATUS;

/*	This is a terminate of system fault interrupt.  Either of these
   *	interrupts signals the completion of a connect.  tdcm_iocall will
   *	always wait on the wait list event channel for the completion
   *	of a connect.  Therefore we must send a wakeup over that channel.
   *	We will not actually process the status from this interrupt.
   *	It will be processed by WAIT_FOR_STATUS when it wakes up.
*/
SLEVEL (1):					/* System fault or terminate interrupt. */
SLEVEL (3):					/* Send a wakeup to WAIT_FOR_STATUS. */
SLEVEL (5):					/* Marker, treat like terminate */
	call hcs_$wakeup (ws.info.process_id, ws.info.wait_list.wait_echan, 0, ecode);

/*	One way or another we have processed any status in the queue.
   *	Now we must look for a special interrupt.  Since this entry
   *	was called we know that the caller wants to be signalled
   *	when there is a special interrupt.  We will send a wakeup to him
   *	over the user event channel.  The caller should be blocked himself
   *	waiting for this wakeup.
*/
GET_SPECIAL_STATUS:
	call ioi_$get_special_status (ws.info.ioix, special_flag, special_status_word, ecode);
	if ecode ^= 0 then
	     return;
	if special_flag then			/* If we got a special signal user. */
	     call hcs_$wakeup (ws.info.process_id, ws.info.user_echan, 0, ecode);
	return;
%page;
/*	This label defines the location where all internal procedures will
   *	return if they encounter a fatal error.  This non-structured bit
   *	of programming is done for the sake of efficiency.  It means that
   *	there does not have to be a check for errors after each call to
   *	an internal procedure.
*/

INTERNAL_PROC_RETURN:
	arg_ecode = ecode;				/* Return error code. */
	return;





SETUP:
     procedure;

/*	This procedure is called by all entry points except tdcm_attach.
   *	It gets a pointer to the IOI workspace that we are using.
   *	If we don't have a real IOI workspace yet we will temporarily
   *	use part of the tseg.
*/
	tsegp = arg_tsegp;				/* Copy argument. */

	if tseg.version_num ^= tseg_version_2 then do;
	     ecode = error_table_$unimplemented_version;
	     goto INTERNAL_PROC_RETURN;
	end;

	ecode = 0;

	if tseg.ws_segno = "0"b			/* Do we have a real IOI workspace yet? */
	then ws_ptr = addr (tseg.buffer (1));		/* No, use temporary workspace area. */
	else ws_ptr = baseptr (tseg.ws_segno);

     end SETUP;
%page;
WAIT_FOR_STATUS:
     procedure;

/*	This procedure is called when we must wait for a connect to terminate.
   *	We will always block on the status_echan event channel.  This is the
   *	event channel that we try to initiate as a fast channel.  If the
   *	interrupt which caused IOI to send this wakeup is not a terminate
   *	or system fault we will ignore the wakeup and go blocked again.
   *	When we return all the necessary processing of the interrupt will have
   *	been performed.  Then the connect will be considered complete.
*/
WAIT_LOOP:					/* Come here if we have to block again. */
	ws.info.meters.block = ws.info.meters.block + 1;	/* increment meter */
	call ipc_$block (addr (ws.info.wait_list), addr (event_data), ecode);
	if ecode ^= 0 then do;
	     call convert_ipc_code_ (ecode);
	     goto INTERNAL_PROC_RETURN;
	end;
	go to PROC_QUEUE;

PROCESS_QUEUE:
     entry;					/* entry called when we know a status queue entry is full */
	ws.info.meters.no_block = ws.info.meters.no_block + 1;
						/* increment meter */
PROC_QUEUE:
	isp = addr (ws.statq (ws.info.statqx));		/* Get pointer to current IOI status queue entry. */
	if ^istat.completion.st then			/* If no status then we got an extra wakeup. */
	     goto WAIT_LOOP;			/* Wait again. */

	if ws.info.statqx = hbound (ws.statq, 1) then	/* Get index of next status queue entry. */
	     ws.info.statqx = 1;			/* If at end wraparound. */
	else ws.info.statqx = ws.info.statqx + 1;

	istat.completion.st = "0"b;			/* Free this status queue entry. */
	statp = addr (istat.iom_stat);		/* Get pointer to IOM status. */
	listx = istat.offset;			/* Get absolute listx from IOI. */
	if ws.info.flags.ndtrans then			/* Convert listx depending upon type of DCW list. */
	     op_count = listx - ws.info.ndt_offsetx + 1;
	else if ws.info.flags.large_rec then		/* One record longer than 4096 words? */
	     op_count = 1;
	else op_count = divide ((listx - ws.info.rw_offsetx + 2), 2, 17, 0);
	goto WLEVEL (istat.level);			/* Go process according to level. */

WLEVEL (7):					/* Should not get special status in queue. */
	goto WAIT_LOOP;				/* Ignore, wait for real status. */

WLEVEL (1):					/* System fault. */
	istat.iom_stat = "0"b;			/* Clear IOM status. */
	status.major = "1111"b;			/* This denotes a system fault. */

WLEVEL (3):					/* Terminate interrupt.  Process together. */
	ws.info.term_st = ws.info.term_st + 1;		/* increment meter */
	ws.info.consec_mark = 0;			/* reset this meter */
	if op_count > ws.info.subset_size then do;	/* if doing marker processing, must be on second half */
	     op_count = op_count - ws.info.subset_size;	/* set for only number of buffers since last marker */
	     ws.info.mark_offset = ws.info.subset_size;	/* set base buffer */
	end;
	else ws.info.mark_offset = 0;			/* first buffer subset */
	ws.info.flags.connected = "0"b;		/* Connect has now completed. */
	if ws.info.flags.reading then			/* Was this connect for a read? */
	     call PROCESS_INPUT;			/* Yes, extra processing needed for input. */

	tseg.hardware_status = istat.iom_stat;		/* Return iom status to user. */

	if ^istat.completion.er then do;		/* Was there an error? */
	     tseg.completion_status = 1;		/* No, tell user everything is OK. */
	     ws.info.term_ne = ws.info.term_ne + 1;	/* increment meter */
	end;
	else do;					/* Yes, there was an error. */
	     tseg.completion_status = 2;		/* Tell user that he got bad status. */
	     tseg.error_buffer = op_count;		/* Tell him how far he got. */
	     if (status.major = "0011"b) | (status.major = "1011"b) then
						/* Count data alert errors. */
						/* And MPC data alert errors. */
		ws.info.error_count = ws.info.error_count + 1;
	     if istat.completion.time_out then		/* IF time-out set error code. */
		ecode = error_table_$net_timeout;
	     goto INTERNAL_PROC_RETURN;		/* Return directly to user. */
	end;
	return;

WLEVEL (5):					/* Marker interrupt */
	ws.info.mark_st = ws.info.mark_st + 1;		/* increment meter */
	ws.consec_mark = ws.consec_mark + 1;		/* increment meter */
	if ws.consec_mark > ws.most_consec_mark then	/* if this is bigger than previous high */
	     ws.most_consec_mark = ws.consec_mark;	/* change the value */
	if ws.info.flags.reading then do;		/* if reading extra processing required */
	     tmr = "0"b;				/* reset terminate condition */
	     do i = op_count by -1 while (^tmr);	/* find the real marker index */
		if i = 0 then			/* if we got to the beginning of the list.. */
		     i = hbound (ws.rw_list, 1);	/* reset back to the end */
		idcwp = addr (ws.rw_list (i).idcw);
		if idcw.control = "11"b then do;	/* if true, we found the marker */
		     tmr = "1"b;			/* set terminate conditon */
		     op_count = i;			/* adjust  op_count to corrected value */
		end;
	     end;
	     if op_count > ws.info.subset_size then do;	/* if doing marker processing, must be on second half */
		op_count = op_count - ws.info.subset_size;
						/* set for only number of buffers since last marker */
		ws.info.mark_offset = ws.info.subset_size;
						/* set base buffer */
	     end;
	     else ws.info.mark_offset = 0;		/* first buffer subset */
	     call PROCESS_INPUT;			/* Yes, extra processing needed for input. */
	end;
	tseg.hardware_status = istat.iom_stat;		/* copy marker status to return to user */
	tseg.completion_status = 1;			/* indicate no error */

     end WAIT_FOR_STATUS;
%page;
PROCESS_INPUT:
     procedure;

/*	This procedure is called to process input data found in the IOI workspace.
   *	We will copy the input data from the workspace into the tseg buffers.
   *	We must copy the input buffers one at a time since the size of each tseg
   *	buffer may be much larger than the number of words that are actually used
   *	in each buffer.
*/
	if ws.info.flags.allow_marker then		/* if doing marker processing */
	     tbuf_num = ws.info.mark_offset + 1;	/* 1 to 1 relation between tseg buf and ws buf */
	else tbuf_num = ws.info.read_start;		/* otherwise start where he told us */

	if ws.info.flags.get_size then do;		/* Does caller want actual read count? */
						/* Yes, special case. */
	     fix = 0;				/* We may have to fix the read count. */
	     if (status.char_pos = "1"b3) & (^istat.completion.er) then
						/* NZ char count & no error? */
		if (status.sub & "04"b3) = "04"b3 then
		     if addr (ws.rw_list (1).idcw) -> idcw.command ^= addr (ws.read_idcws (2)) -> idcw.command then
			fix = 1;			/* Fix, 9 track _a_n_d _n_o_t read tape 9. */
		     else ;
		else if (^status.eo) & ((status.sub & "60"b3) = "40"b3) then
		     fix = 1;			/* Fix, 7 track _a_n_d even _a_n_d 4 bit fill. */
	     dcw_tally = bin (status.tally, 12) + fix;	/* Compute correct tally residue. */
						/* Now return read count of first buffer. */
	     if (listx - ws.info.rw_offsetx) >= (divide (ws.info.buffer_size (1) + 4095, 4096, 17)) then
		data_size = ws.info.buffer_size (1) - dcw_tally;
	     else data_size = (listx - ws.info.rw_offsetx) * 4096 - dcw_tally;
	     tseg.buffer_size (ws.info.read_start) = data_size;
	end;

	do i = ws.info.mark_offset + 1 to ws.info.mark_offset + op_count;
						/* Copy buffers from workspace to tseg. */
	     data_size = ws.info.buffer_size (i);	/* Get size of this input buffer. */
	     dcwp = addr (ws.rw_list (i).dcw);		/* get correct dcw */
	     wbuf_ptr = ptr (addr (ws.buffer), dcw.address);
						/* and get ptr to data */
						/* Copy one input buffer into tseg. */
	     ptr (tsegp, tseg.bufferptr (tbuf_num)) -> based_data = wbuf_ptr -> based_data;
	     tbuf_num = tbuf_num + 1;			/* Move to next tseg buffer. */
	end;

     end PROCESS_INPUT;
%page;
NON_DATA_TRANSFER:
     procedure;

/*	This procedure is called to set up non-data transfer IDCWs.
   *	Most fields in these non-data transfer IDCWs were set up when the
   *	the tape drive was attached.  We just have to fill in the actual
   *	device command codes and turn OFF the continue bits in the last
   *	IDCW.  We get the device commands from the tseg command queue.
*/
	op_count = tseg.command_count;		/* Get number of non-data transfer operations. */
	if op_count > hbound (ws.ndt_list, 1)		/* Make sure there are not too many. */
	then do;
	     ecode = error_table_$too_many_buffers;
	     goto INTERNAL_PROC_RETURN;
	end;

	do i = 1 to op_count;			/* Set up specified number of IDCWs. */
	     idcwp = addr (ws.ndt_list (i).idcw);	/* Get pointer to non-data transfer IDCW. */
	     idcw.command = bit (tseg.command_queue (i), 6);
						/* Copy device command. */
	     idcw.control = "10"b;			/* Turn ON continue in each IDCW. */
	end;

	idcw.control = "00"b;			/* Terminate list with last IDCW. */

	tseg.command_count = 0;			/* Tell caller we have picked up all commands. */
	ws.info.flags.reading = "0"b;			/* Not reading or writing. */
	ws.info.flags.ndtrans = "1"b;			/* Non-data transfer commands. */

	call TRY_TO_CONNECT (ws.info.ndt_offsetx);
	if ecode ^= 0 then
	     goto INTERNAL_PROC_RETURN;
	ws.info.flags.connected = "1"b;		/* Connect has been made. */

     end NON_DATA_TRANSFER;

/* CK_STATQ - subroutine to check if any status queue entry is full */

CK_STATQ:
     proc returns (bit (1) aligned);

	if ws.statq (ws.info.statqx).completion.st then	/* if status stored in this queue entry */
	     return ("1"b);				/* return true */
	else return ("0"b);				/* no status stored */

     end CK_STATQ;
%page;
MARKER_READ_WRITE:
     procedure;

/*	This procedure is called to set up the IDCWs and DCWs used to read
   *	or write data.  The write switch in the tseg tells us which type
   *	of operation is to be performed.
*/
	op_count = tseg.buffer_count;			/* Get number of buffers to read or write. */
	if op_count > ws.info.subset_size then do;	/* Did caller specify too many buffers? */
	     ecode = error_table_$too_many_buffers;
	     goto INTERNAL_PROC_RETURN;
	end;

	wbuf_ptr = addr (ws.buffer);			/* Get pointer to buffer area in IOI workspace. */
	tbuf_num = tseg.buffer_offset + 1;		/* Get number of first tseg buffer. */
	if tbuf_num > ws.info.subset_size then do;	/* if setting up second subset of buffers */
	     wbuf_num = ws.info.subset_size + 1;
	     wbuf_ptr = addrel (wbuf_ptr, ws.info.subset_size * 1040);
						/* start at end of first subset */
	end;
	else wbuf_num = 1;				/* no set up for first subset */
	if tseg.write_sw ^= 0 then do;		/* Are we reading or writing? */
	     ws.info.flags.reading = "0"b;		/* Writing not reading. */
	     data_idcw = ws.info.write_idcws (tseg.mode (tbuf_num));
						/* Writing. */
	end;
	else do;					/* Reading. */
	     ws.info.flags.reading = "1"b;
	     ws.info.read_start = tbuf_num;		/* Save number of first tseg buffer read into. */
	     data_idcw = ws.info.read_idcws (tseg.mode (tbuf_num));
						/* Reading. */
	end;
	if substr (ws.rw_list (1).idcw, 1, 12) ^= substr (data_idcw, 1, 12) then do;
						/* set up DCW list, 1st time */
	     ws.info.flags.large_rec = "0"b;
	     data_size = tseg.buffer_size (tbuf_num);	/* set physical record size */
	     do i = 1 to hbound (ws.rw_list, 1);
		idcwp = addr (ws.rw_list (i).idcw);	/* set up IDCW */
		based_idcw = data_idcw;
		dcwp = addr (ws.rw_list (i).dcw);	/* set up DCW */
		string (dcw) = "0"b;		/* make sure its zero first */
		dcw.address = rel (wbuf_ptr);		/* set relative workspace address */
		dcw.tally = bit (bin (data_size, 12));	/* set tally */
		wbuf_ptr = addrel (wbuf_ptr, data_size);/* increment workspace ptr */
		ws.info.buffer_size (i) = data_size;	/* set up buffer size for reads */
	     end;
	     wbuf_ptr = addr (ws.buffer);		/* reset workspace buffer ptr */
	     tdcwp = addr (ws.mark_tdcw);		/* set up tdcw to chain list */
	     tdcw.address = rel (addr (ws.rw_list (1).idcw));
	     tdcw.type = "10"b;			/* make it a tdcw */
	     tdcw.rel = "1"b;			/* and set relative mode */
	end;
	call METER_IO;				/* go meter the IO time */
	do i = wbuf_num to wbuf_num + op_count - 1;	/* Set up IDCW and and copy data if writing */
	     if tseg.write_sw ^= 0 then do;		/* if writing... */
		data_size = tseg.buffer_size (tbuf_num);/* get buffer size */
		wbuf_ptr -> based_data = ptr (tsegp, tseg.bufferptr (tbuf_num)) -> based_data;
		wbuf_ptr = addrel (wbuf_ptr, data_size);/* go to next buffer */
		tbuf_num = tbuf_num + 1;		/* increment tseg buffer number */
	     end;
	     idcwp = addr (ws.rw_list (i).idcw);	/* set idcw ptr */
	     idcw.control = "10"b;			/* set all idcws to continue */
	end;
	idcw.control = "00"b;			/* Terminate list with last IDCW. */

	tseg.buffer_count = 0;			/* Tell caller that we picked up all buffers. */
	ws.info.flags.ndtrans = "0"b;			/* These are not non-data transfer commands. */

	if ^ws.info.flags.connected then do;		/* if no I/O in progress, get it going now */
	     call TRY_TO_CONNECT (ws.info.rw_offsetx + ((wbuf_num - 1) * 2));
	     ws.info.flags.connected = "1"b;		/* Connect has been made. */
	end;
	else do;					/* I/O in progress, must be processing markers */
	     if op_count = ws.info.subset_size then do;	/* if we can, set up marker to keep I/O going */
		if tseg.buffer_offset = 0 then	/* if this I/O was for first subset */
		     idcwp = addr (ws.rw_list (hbound (ws.rw_list, 1)).idcw);
						/* set idcw ptr for last idcw */
		else idcwp = addr (ws.rw_list (tseg.buffer_offset).idcw);
						/* otherwise set for middle idcw */
		idcw.control = "11"b;		/* set marker control bits in appropriate idcw */
	     end;
	     call CHECK_STATUS;			/* wait for status to come in */
	     if ^ws.info.flags.connected &		/* if no I/O in progress */
		tseg.completion_status = 1 then do;	/* and no error, get I/O going */
		call TRY_TO_CONNECT (ws.info.rw_offsetx + ((wbuf_num - 1) * 2));
		ws.info.flags.connected = "1"b;	/* Connect has been made. */
	     end;
	end;

     end MARKER_READ_WRITE;
%page;
READ_WRITE:
     procedure;

/*	This procedure is called to set up the IDCWs and DCWs used to read
   *	or write data.  The write switch in the tseg tells us which type
   *	of operation is to be performed.
*/
	op_count = tseg.buffer_count;			/* Get number of buffers to read or write. */
	if op_count > ws.info.subset_size then do;	/* Did caller specify too many buffers? */
	     ecode = error_table_$too_many_buffers;
	     goto INTERNAL_PROC_RETURN;
	end;

	wbuf_ptr = addr (ws.buffer);			/* Get pointer to buffer area in IOI workspace. */
	tbuf_num = tseg.buffer_offset + 1;		/* Get number of first tseg buffer. */
						/* tseg buffer offset starts with 0. */

	if tseg.write_sw ^= 0 then			/* Are we reading or writing? */
	     ws.info.flags.reading = "0"b;		/* Writing not reading. */
	else do;					/* Reading. */
	     ws.info.flags.reading = "1"b;
	     ws.info.read_start = tbuf_num;		/* Save number of first tseg buffer read into. */
	     if tseg.get_size ^= 1 then		/* Does caller want actual data size read? */
		ws.info.flags.get_size = "0"b;	/* No. */
	     else do;				/* Yes. */
		ws.info.flags.get_size = "1"b;
		if op_count > 1 then do;		/* Only works if reading one buffer. */
		     ecode = error_table_$too_many_buffers;
		     goto INTERNAL_PROC_RETURN;
		end;
	     end;
	end;
	call METER_IO;				/* go meter this I/O */
	tot_data_size = 0;				/* Keep count of combined buffer sizes. */
	do i = 1 to op_count;			/* Set up IDCW and DCW for each buffer. */
	     data_size = tseg.buffer_size (tbuf_num);	/* Num of words to process in this buf. */
	     tot_data_size = tot_data_size + data_size;	/* Get total num of words to process. */
	     if (tot_data_size > ws.info.buf_size) | (data_size <= 0) then do;
						/* Is total  more than we can handle? */
						/* Or is number for this buffer invalid? */
		ecode = error_table_$buffer_big;
		goto INTERNAL_PROC_RETURN;
	     end;
	     if data_size > 4096 then			/* If more than one DCW needed ... */
		if op_count > 1 then do;		/* Can only allow one operation. */
		     ecode = error_table_$too_many_buffers;
		     go to INTERNAL_PROC_RETURN;
		end;
		else ws.info.flags.large_rec = "1"b;
	     else ws.info.flags.large_rec = "0"b;

	     idcwp = addr (ws.rw_list (i).idcw);	/* Now set up IDCW. */
	     if tseg.write_sw ^= 0 then do;		/* Are we writing or reading? */
		based_idcw = ws.info.write_idcws (tseg.mode (tbuf_num));
						/* Writing, copy data from tseg to workspace. */
		wbuf_ptr -> based_data = ptr (tsegp, tseg.bufferptr (tbuf_num)) -> based_data;
	     end;
	     else do;				/* Reading. */
		based_idcw = ws.info.read_idcws (tseg.mode (tbuf_num));
		ws.info.buffer_size (i) = data_size;	/* Remember how many words we are to read. */
	     end;

	     dcwp = addr (ws.rw_list (i).dcw);		/* Set up DCW first. */
	     do while (data_size > 0);		/* Make as many DCWs as needed. */
		string (dcw) = "0"b;
		dcw.address = rel (wbuf_ptr);
		dcw_tally = min (data_size, 4096);
		dcw.tally = bit (bin (dcw_tally, 12));
		if data_size > 4096 then
		     dcw.type = "01"b;
		dcwp = addrel (dcwp, 1);
		wbuf_ptr = addrel (wbuf_ptr, dcw_tally);
		data_size = data_size - dcw_tally;
	     end;

	     tbuf_num = tbuf_num + 1;			/* Move to next tseg buffer. */
	end;
	idcw.control = "00"b;			/* Terminate list with last IDCW. */

	tseg.buffer_count = 0;			/* Tell caller that we picked up all buffers. */
	ws.info.flags.ndtrans = "0"b;			/* These are not non-data transfer commands. */

	call TRY_TO_CONNECT (ws.info.rw_offsetx);
	ws.info.flags.connected = "1"b;		/* Connect has been made. */

     end READ_WRITE;
%page;
/* METER_IO - subroutine to meter time of each I/O */

METER_IO:
     proc;

	if ^display_meters then
	     return;				/* if not doing metering, forget it */
	if ws.last_io_time = 0 then			/* if first I/O... */
	     ws.last_io_time, ws.low_delta = clock ();	/* initialize meters */
	else do;					/* do some metering */
	     io_time = clock ();			/* get the current clock reading */
	     delta = io_time - ws.last_io_time;		/* get time between ios */
	     ws.last_io_time = io_time;		/* save current time */
	     ws.io_delta = ws.io_delta + delta;		/* add in current increment */
	     if delta > ws.high_delta then		/* if this increment is larger than previous.. */
		ws.high_delta = delta;		/* save this one */
	     if delta < ws.low_delta then		/* if this icrement is smaller than previous */
		ws.low_delta = delta;		/* save this one */
	     if tseg.buffer_count > ws.info.block_count then
						/* if block count > whats saved */
		ws.info.block_count = tseg.buffer_count;/* change it */
	     ws.number_ios = ws.number_ios + 1;		/* increment number of data xfer ios */
	end;

     end METER_IO;

/* CHECK_STATUS - subroutine to check status queue. If status queue entry full,
   we will process it without going blocked. */

CHECK_STATUS:
     proc;

	if CK_STATQ () then				/* if there is status to process.. */
	     call PROCESS_QUEUE;			/* go do it, don't wait for it */
	else do;					/* currently no status, drain the channel... */
	     call ipc_$drain_chn (ws.info.wait_list.wait_echan, ecode);
						/* get ride of any pending wakeups */
	     if ecode ^= 0 then do;
		call convert_ipc_code_ (ecode);
		goto INTERNAL_PROC_RETURN;
	     end;
	     if CK_STATQ () then			/* if there is status to process.. */
		call PROCESS_QUEUE;			/* go do it, don't wait for it */
	     else call WAIT_FOR_STATUS;		/* go wait for marker or terminate status */
	end;

     end CHECK_STATUS;
%page;
TRY_TO_CONNECT:
     proc (P_idx);

/* *	This procedure is used to perform connects; if there is insufficient
   *	main memory for a buffer when it is called, it waits for one half second,
   *	and tries again. If it fails after 25 tries, or encounters some other
   *	error, it aborts and goes to INTERNAL_PROC_RETURN. This is done in
   *	tdcm_ because it is necessary to go blocked while waiting; the error
   *	of not having sufficient memory used to crash the system. */

dcl      P_idx		  fixed bin parameter;
dcl      connect_retries	  fixed bin;
dcl      MAX_CONNECT_RETRIES	  fixed bin internal static options (constant) init (25);

	connect_retries = 0;			/* haven't tried at all yet */

TRY_AGAIN_TO_CONNECT:
	call ioi_$connect (ws.info.ioix, P_idx, ecode);

	if ecode = 0 then
	     return;				/* successfully accomplished */
	else if ecode ^= error_table_$out_of_main_memory then
						/* lossage, some unexpected error */
	     goto INTERNAL_PROC_RETURN;
	else do;					/* not enough room now, wait a while */
	     if connect_retries > MAX_CONNECT_RETRIES then/* we've tried too often, let's just give up */
		goto INTERNAL_PROC_RETURN;
	     connect_retries = connect_retries + 1;

	     call WAIT_FOR_A_MOMENT ();

	     goto TRY_AGAIN_TO_CONNECT;
	end;					/* end of loop trying to connect */

     end TRY_TO_CONNECT;
%page;
WAIT_FOR_A_MOMENT:
     proc ();

/* *	This procedure is used to sleep for a short period of time, while
   *	waiting for more buffer space to become available. It is stolen
   *	more or less bodily from set_lock_. */

dcl      ALRM_STRING	  (1) char (32) internal static options (constant) init ("alrm");
dcl      A_BRIEF_MOMENT	  fixed bin (71) internal static options (constant) init (500000);
						/* half a second, really */
dcl      RELATIVE_MICROSECONDS  bit (2) aligned internal static options (constant) init ("10"b);

dcl      initialized_for_waiting
			  bit (1) aligned internal static init ("0"b);
dcl      this_is_initial_ring	  bit (1) aligned internal static;
dcl      alrm_mask		  bit (36) aligned internal static;
dcl      1 wait_list	  aligned internal static,
	 2 count		  fixed bin,
	 2 channel	  fixed bin (71);
dcl      saved_alarm_channel	  fixed bin (71);
dcl      saved_alarm_time	  fixed bin (71);
dcl      ignore_message	  fixed bin (71);
dcl      saved_mask		  bit (36) aligned;

dcl      create_ips_mask_	  entry (ptr, fixed bin, bit (36) aligned);
dcl      get_lock_id_	  ext entry (bit (36) aligned);
dcl      get_ring_		  ext entry returns (fixed bin (3));
dcl      get_initial_ring_	  ext entry returns (fixed bin (3));
dcl      hcs_$get_alarm_timer	  ext entry (fixed bin (71), fixed bin (71));
dcl      hcs_$get_ips_mask	  entry (bit (36) aligned);
dcl      hcs_$set_alarm_timer	  ext entry (fixed bin (71), fixed bin, fixed bin (71));
dcl      ipc_$create_ev_chn	  ext entry (fixed bin (71), fixed bin (35));
dcl      ipc_$block		  ext entry (ptr, ptr, fixed bin (35));
dcl      timer_manager_$sleep	  ext entry (fixed bin (71), bit (2) aligned);


	if ^initialized_for_waiting then do;		/* prepare to wait for a moment */
	     call create_ips_mask_ (addr (ALRM_STRING), 1, alrm_mask);
	     alrm_mask = substr (^alrm_mask, 1, 35);	/* complement it for later tests */
	     this_is_initial_ring = (get_ring_ () = get_initial_ring_ ());
	     call ipc_$create_ev_chn (wait_list.channel, (0));
	     wait_list.count = 1;
	     initialized_for_waiting = "1"b;
	end;

	call hcs_$get_ips_mask (saved_mask);		/* See if IPS are masked. */
	if this_is_initial_ring & ((substr (saved_mask, 1, 35) & alrm_mask) = alrm_mask) then do;
						/* we can call timer_manager_ */
	     call timer_manager_$sleep (A_BRIEF_MOMENT, RELATIVE_MICROSECONDS);
	end;					/* sleep for a moment */

	else do;					/* we cannot call timer_manager_ */
	     call hcs_$get_alarm_timer (saved_alarm_time, saved_alarm_channel);
						/* remember current alarm settings */
	     call hcs_$set_alarm_timer (A_BRIEF_MOMENT, 1, wait_list.channel);
						/* get awakened later */
	     call ipc_$block (addr (wait_list), addr (ignore_message), ecode);
						/* wait for wakeup */
	     call hcs_$set_alarm_timer (saved_alarm_time, 2, saved_alarm_channel);
						/* reset original timer settings */
	     if ecode ^= 0 then			/* if trouble then give up */
		goto INTERNAL_PROC_RETURN;
	end;

	return;					/* we have waited */
     end;						/* internal procedure WAIT_FOR_A_MOMENT */
%page;
REWIND_TAPE:
     procedure;

/*	Temporary procedure used with the dummy version of RCP.
*/
dcl      tdcm_$tdcm_iocall	  entry (ptr, fixed bin (35));

	tseg.sync = 1;
	tseg.get_size = 0;
	tseg.buffer_count = 0;
	tseg.command_count = 1;
	tseg.command_queue (1) = 111000b;		/* REWIND */

	call tdcm_$tdcm_iocall (tsegp, ecode);

     end REWIND_TAPE;

     end tdcm_;
