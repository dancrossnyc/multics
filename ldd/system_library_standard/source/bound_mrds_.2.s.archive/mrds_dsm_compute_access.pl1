/* ***********************************************************
   *                                                         *
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
   *                                                         *
   *                                                         *
   *********************************************************** */

mrds_dsm_compute_access: proc (p_caller_name, p_submodel_path, p_listing_iocb_ptr, p_data_model_ptr, p_code);

/*
   where:
   .   p_caller_name	char (*)		(input)
   .     name of the module calling this  routine,  used  for  error
   .     reporting
   .   p_submodel_path	char (*)		(input)
   .     path of submodel access bits are to be computed for
   .   p_listing_iocb_ptr     ptr                 (input)
   .     pointer to the listing iocb or null if no listing is  being
   .     produced
   .   p_data_model_ptr       ptr                 (input)
   .     pointer to the data_model used for verifing relation access
   .   p_code		fixed bin (35)	(output)
   .     stand error code

   Takes a  submodel  vfile  as  produced  by  create_mrds_dsm  (via
   mrds_dsm_parse,  et.al.)  and  fills  in  the  access bits in the
   relation records.

   The  processing  of  the  dsm   is   done   via   two   switches,
   relation_records_iocb_ptr  and  access_records_iocb_ptr. A select
   control order is done on the relation_records_iocb_ptr switch  to
   get  only the relation records. These are then processed one at a
   time.

   First calc_relation_access is called for  the  current  relation,
   then calc_attr_access is called for each attribute in the current
   relation. calc_relation_access and  calc_attr_access  operate  by
   looking  around  in  the  dsm for various kinds of access records
   which relate to the current object. The basic algorithm  is  that
   the  access  records  are  looked  for  in  decreasing  order  of
   specificity. Whenever an access record  is  found,  get_(relation
   attribute)_access  is  called  to decode the access mode names in
   the access record and set the appropriate bits in a bit string.

   The access_records_iocb_ptr switch is used by the calc_* routines
   so  that  their  poking  around  in the dsm won't through off the
   positioning of the walk through all of  relations.  Also,  having
   the  two  allows  the  use of a select order to find the relation
   records and use read_record to sequence through them  instead  of
   doing successive searches via get_key control orders.

   When all the relations and their attributes have  been  processed
   the access records are checked to be sure that they were all used
   at least once. If a record is not  used  it  is  assumed  that  a
   problem  exists  in  the  source  (possibly  a typo in the access
   specification statement or the relation statement) and  an  error
   is reported.

   Internal procedures do not return error codes. If an error occurs
   that  cannot  be  recovered from while in an internal procedure a
   call to program_logic_error is made which will report the  error,
   cleanup,   set  the  return  code,  and  do  a  non-local  go  to
   exit_compute_access to exit this routine. If an error occurs that
   can  be  recovered  from (semantic error based on incorrect cmdsm
   source) it is reported and the error code  set  (via  a  call  to
   report error) and processing is continued like it never happened.



   Known Bugs:

   Other Problems:
   
   HISTORY:

   79-11-30 Spratt: Written

   80-02-21 Spratt: to convert from  compute_dsm_access  command  to
   .        mrds_dsm_compute_access subroutine.

   80-12-05  Spratt:  the  p_caller_name  argument  added  to  allow
   .        reporting of errors as though the calling  program  were
   .        doing the reporting.

   .        The get_access routine was changed  to  have  its  input
   .        mode_name_array  argument  be  0  based so that it could
   .        catch "null" modes  properly  (now  declared  (0:*)  was
   .        declared (*)).

   .        Added the null mode for relations,  removed  the  status
   .        mode.

   .        Changed all error messages to have initial newlines.

   80-12-08 Spratt: Added a cleanup_handler routine, which is called
   .        before any return  and  on  the  cleanup  condition.  It
   .        primarily  ensures  that  the  iox_ switches against the
   .        submodel are closed and detached.

   .        Made the names of the dsm switches unique.

   .        Changed myname from internal static options(constant) to
   .        automatic, to allow it to be set.

   81-01-23 Davids: modified the calls to iox_$read_record  so  that
   .        they used as a buffer  size  sys_info$max_seg_size  *  4
   .        rather  than 261120 which aside from being a constant is
   .        just the number of words in a segment not the number  of
   .        bytes.

   81-05-01 Davids: reformated and remodulated - many, many changes.

   81-05-04 Davids: added checks for  unused  access  specifications
   .        and for continuing checking after the first  combination
   .        of  null  and non-null access is found. Also if an error
   .        is found it now returns a non-zero error code.

   81-05-11  Davids  added  the  parameter  p_listing_iocb_ptr   and
   .        changed report error  to  report  errors  via  ioa  over
   .        iox_$error_output   and   the  listing_iocb_ptr  if  its
   .        non-null.

   81-05-12     Davids:     changed     error_table_$bad_arg      to
   .        mrds_error_$inconsistent_submodel. The error  code  does
   .        not have to be all that informative since each error has
   .        an expanatory message associated with it.

   81-05-22 Davids:  added  a check to be sure that keys of the form
   .        model relation: are not used to read in access records.

   .        added  the  data_model_ptr to the parameter list and the
   .        internal procedure validate_relation_access

   81-05-27 Davids: changed the action for  a  non-zero  error  code
   .        returned      from       mrds_dm_get_attributes       in
   .        validate_relation_access      from     a     call     to
   .        program_logic_error to a simple return  statement.  this
   .        is  because  the  failure  of mrds_dm_get_attributes has
   .        already been reported in mrds_dsm_semantics.  processing
   .        continues  (both  here  and in semantics) so the maximum
   .        number of errors can be reported.

   81-09-17  Davids:  added  a  local_key_string  variable  to   the
   .        internal  procedure  verify_access_record_use  which  is
   .        char   (256)   non-varying.   this   is  because  substr
   .        (key_string, 1, 15) would cause a  stringsize  error  is
   .        key_string  was  not  at  least  15  characters long. by
   .        assigning key_string to local_key_string it  is  assured
   .        that  the  string will be long enough - just padded with
   .        blanks.

   83-06-13 Harvey: changed references to addrel (addr (REL_HEAD), 1)
   .        to  be  addrel (temp_ptr, 1)  instead.  This is due to  a
   .	  compiler bug (TR 15402).

*/

/* PARAMETER */

	dcl     p_caller_name	 char (*);	/* (input) name of the module calling this
						   routine - used for error reporting */
	dcl     p_submodel_path	 char (*);	/* (input) path of submodel - including the .dsm suffix */
	dcl     p_listing_iocb_ptr	 ptr;		/* (input) pointer to the listing iocb or */
						/* null if no listing is being produced */
	dcl     p_data_model_ptr	 ptr;		/* (input) pointer th the data_model, used
						   to verify that the specified relation access is ok */
	dcl     p_code		 fixed bin (35);	/* standard error code */

/* AUTOMATIC */

	dcl     access_record_len	 fixed bin (21);	/* length of the access record read */
	dcl     access_records_iocb_ptr ptr init (null ()); /* iocb pointer used to reference the
						   access records in the submodel */
	dcl     attr_idx		 fixed bin;	/* index of attributes within a relation */
	dcl     code		 fixed bin (35);	/* internal error code */
	dcl     have_sought_default_attribute_access bit (1) /* "1"b if default attribute access has been determined */
				 init ("0"b);
	dcl     have_sought_default_relation_access bit (1) /* "1"b if default relation access has been determined */
				 init ("0"b);
	dcl     info_ptr		 ptr init (null ());/* pointer to the hi_sl_info structure used for
						   setting up the subset of relation records */
	dcl     key_string		 char (256) varying;/* used for submodel record keys */
	dcl     last_rel_attr_access_sought_for char (32) varying; /* name of relation that the current
						   rel_attr_access is setup for */
	dcl     local_area_ptr	 ptr;		/* pointer to the local area */
	dcl     rel_rec_5_len	 fixed bin (21);	/* length of the rel_rec_5 record read */
	dcl     rel_rec_5_ptr	 ptr init (null ());/* pointer to the buffer used to store
						   rel_rec_5 records after reading */
	dcl     relation_name	 char (64) varying; /* name of relation access is currently being calculated for */
	dcl     relation_records_iocb_ptr ptr init (null ()); /* pointer to the iocb used to read the relation records */
	dcl     temp_ptr		 ptr;		/* becomes addr (REL_HEAD) */
	dcl     temp_seg_ptrs	 (3) ptr init (null (), null (), null ());
						/* pointers to three temporary segments
						   - set by get_temp_segments_ */
	dcl     01 default_attribute_access like attribute_access; /* the default attribute access */
	dcl     01 default_relation_access like relation_access; /* the default relation access */
	dcl     01 implicit_default_attribute_access /* default attribute access values used if the */
				 like attribute_access; /* cmdsm source does not specify any other values */
	dcl     01 implicit_default_relation_access /* default relation access values used if the */
				 like relation_access; /* cmdsm source does not specify any other values */
	dcl     01 rel_attr_access	 like attribute_access; /* default attribute access values for the current relation */

/* BASED */

	dcl     local_area		 area (sys_info$max_seg_size) based (local_area_ptr);
						/* area for allocations */

/* BUILTIN */

	dcl     addr		 builtin;
	dcl     addrel		 builtin;
	dcl     empty		 builtin;
	dcl     length		 builtin;
	dcl     null		 builtin;
	dcl     substr		 builtin;
	dcl     unspec		 builtin;

/* CONDITION */

	dcl     cleanup		 condition;

/* ENTRY */

	dcl     get_temp_segments_	 entry (char (*), pointer dimension (*), fixed bin (35));
	dcl     iox_$control	 entry (ptr, char (*), ptr, fixed bin (35));
	dcl     iox_$position	 entry (ptr, fixed bin, fixed bin (21), fixed bin (35));
	dcl     iox_$read_key	 entry (ptr, char (256) varying, fixed bin (21), fixed bin (35));
	dcl     iox_$read_record	 entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
	dcl     iox_$rewrite_record	 entry (ptr, ptr, fixed bin (21), fixed bin (35));
	dcl     iox_$seek_key	 entry (ptr, char (256) varying, fixed bin (21), fixed bin (35));
	dcl     mrds_dm_get_attributes entry (ptr, char (32), ptr, ptr, fixed bin (35));
	dcl     mrds_dsm_close$force	 entry (ptr);
	dcl     mrds_dsm_open$update_share entry (char (*), ptr, fixed bin (35));
	dcl     release_temp_segments_ entry (char (*), pointer dimension (*), fixed bin (35));

/* EXTERNAL */

	dcl     error_table_$end_of_info fixed bin (35) external static; ;
	dcl     error_table_$no_record fixed bin (35) external static;
	dcl     mrds_error_$inconsistent_submodel fixed bin (35) external static;
	dcl     sys_info$max_seg_size	 fixed bin (24) external static;

/*
   Set up initial values  for  variables  that  for  one  reason  or
   another cannot be set in the variable's declaration statement.
*/



	access_record_ptr = null;

	default_relation_access.null = "0"b;
	default_relation_access.append = "0"b;
	default_relation_access.delete = "0"b;
	default_relation_access.mbz1 = "0"b;

	default_attribute_access.null = "0"b;
	default_attribute_access.read = "0"b;
	default_attribute_access.modify = "0"b;
	default_attribute_access.mbz1 = "0"b;

	implicit_default_relation_access.null = "1"b;
	implicit_default_relation_access.append = "0"b;
	implicit_default_relation_access.delete = "0"b;
	implicit_default_relation_access.mbz1 = "0"b;

	implicit_default_attribute_access.null = "0"b;
	implicit_default_attribute_access.read = "1"b;
	implicit_default_attribute_access.modify = "0"b;
	implicit_default_attribute_access.mbz1 = "0"b;





/*
   Set up the cleanup condition handler.
*/

	on cleanup call cleanup_handler;





/*
   Set the return error code to zero - do not assume its input value was zero
*/

	p_code = 0;

/*
   Set up the switches for processing the submodel.

   The submodel must be opened twice  for  update_share.  The  first
   opening  (relation_records_iocb_ptr) is used to read the relation
   records and update their access information. The  second  opening
   (access_records_iocb_ptr)  is used to read the access records and
   change the used element to "1"b without  changing  the  "current"
   relation record.
*/


	call mrds_dsm_open$update_share (p_submodel_path, relation_records_iocb_ptr, code);
	if code ^= 0
	then do;
		call report_error (code, "^/Could not open ^a in shared update mode", "", "");
		call cleanup_handler;
		goto exit_compute_access;
	     end;



	call mrds_dsm_open$update_share (p_submodel_path, access_records_iocb_ptr, code);
	if code ^= 0
	then do;
		call report_error (code, "^/Could not open ^a in shared read mode", "", "");
		call cleanup_handler;
		goto exit_compute_access;
	     end;

/*
   Set up buffer space for reading the relation and access records,
   and an area for allocating things in.

   Three temporary segments are obtained from the temp segment pool.
   the   pointers   to  these  segments  will  be  assigned  to  the
   access_record_ptr,  the   rel_rec_5_ptr,  and the local_area_ptr.
   Since records in a vfile_ cannot be longer  than  1  segment  the
   buffer will always be adequate.
*/


	call get_temp_segments_ (p_caller_name, temp_seg_ptrs, code);
	if code ^= 0
	then do;
		call report_error (code, "^/Could not get temporary segment.", "", "");
		call cleanup_handler;
		goto exit_compute_access;
	     end;


	access_record_ptr = temp_seg_ptrs (1);
	rel_rec_5_ptr = temp_seg_ptrs (2);
	local_area_ptr = temp_seg_ptrs (3);
	local_area = empty ();

/*
   Create a subset consisting of only the relation records using the
   relation_records_iocb_ptr,  and setup to read the first record in
   the subset.



   A hi_sl_info structure is allocated in a small local  area.  This
   structure  is  used to build a subset of the records in the vfile
   which have keys greater than or equal to first_head and less than
   of equal to last_head, in this case only one pair of keys is used
   and the net effect is to select all records which have a key head
   equal  to  the  string  contained  in REL_HEAD, i.e. all relation
   records.
*/

	sl_array_limit = 1;
	allocate hi_sl_info in (local_area) set (info_ptr);
	hi_sl_info.version = sl_info_version_0;
	temp_ptr = addr (REL_HEAD);
	hi_sl_info.first_head.kptr = addrel (temp_ptr, 1);
	hi_sl_info.first_head.length = length (REL_HEAD);
	hi_sl_info.last_head.length = length (REL_HEAD);
	hi_sl_info.last_head.kptr = addrel (temp_ptr, 1);
	hi_sl_info.list_type = 1;
	hi_sl_info.status_only = "0"b;
	hi_sl_info.output_descriptors = "0"b;
	call iox_$control (relation_records_iocb_ptr, "select", info_ptr, code);
	if code ^= 0
	then call program_logic_error (code, "Unable to select relation subset.", "", "");



/*
   Position to the beginning of the "relation" subset just created.
*/

	call iox_$position (relation_records_iocb_ptr, -1, 0, code);
	if code ^= 0
	then call program_logic_error (code, "Unable to position to beginning of relation records subset.", "", "");



/*
   Read the first key of the "relation" subset. This  is  equivalent
   to getting the name of the first relation in the submodel.
*/

	call iox_$read_key (relation_records_iocb_ptr, key_string, rel_rec_5_len, code);
	if code ^= 0
	then call program_logic_error (code, "Could not read first key in relation subset.", "", "");

/*
   Walk through the "relation" subset, one relation at a  time.  For
   each  relation;  get its record (rel_rec_5), calculate the access
   for  the  relation,  calculate  the  access  for  each   of   its
   attributes, rewrite the record with the access bits set, and read
   the key of the next relation record. When all the  relations  and
   their  attributes  have  been processed check to be sure that all
   the access records have been used.
*/


	do while (code = 0);
	     call iox_$read_record (relation_records_iocb_ptr, rel_rec_5_ptr,
		(sys_info$max_seg_size * 4), rel_rec_5_len, code);
	     if code ^= 0
	     then call program_logic_error (code, "Unable to read record for key ^a.", key_string, "");



	     relation_name = substr (key_string, length (REL_HEAD) + 1);
	     call calc_relation_access (relation_name, addr (rel_rec_5_ptr -> rel_rec_5.access));


	     do attr_idx = 1 to rel_rec_5_ptr -> rel_rec_5.attr_num;
		call calc_attribute_access (relation_name, rel_rec_5_ptr -> rel_rec_5.attr (attr_idx).dsm_name,
		     addr (rel_rec_5_ptr -> rel_rec_5.attr (attr_idx).access));
	     end;


	     call validate_relation_access;


	     call iox_$rewrite_record (relation_records_iocb_ptr, rel_rec_5_ptr, rel_rec_5_len, code);
	     if code ^= 0
	     then call program_logic_error (code, "Unable to rewrite relation record for relation ^a.", relation_name, "");



	     call iox_$read_key (relation_records_iocb_ptr, key_string, rel_rec_5_len, code);
	     if code ^= 0 & code ^= error_table_$end_of_info
	     then call program_logic_error (code, "Unable to  read a key from the relation subset.", "", "");
	end;


	call verify_access_record_use;



	call cleanup_handler;

exit_compute_access:
	return;					/* Effective end of compute_dsm_access. */

calc_relation_access: proc (a_rel_name, access_ptr);

/*
   This routine calculates a relation access and sets the results in
   the relation_access structure.

   Access records are searched for starting with the  most  specific
   (case  1) and continuing to the least specific (case3). The cases
   and the cmdsm statements that  generate  the  access  are  listed
   below.

   relation access: a_rel_name (specs)
   .   Sets a_rel_name's access.

   default relation access: (specs)
   .   Sets the relation access for all relations which  do  have  a
   .   relation access statement defining a specific access.

   .   If no default relation  access  statement  is  in  the  cmdsm
   .   source  than  those  relations  which  do not have a relation
   .   access statement seting a  specific  access  will  given  the
   .   implicit default relation access.

   Cases  2  and  3  are  done  in  the  get_default_relation_access
   routine.
*/

/* PARAMETERS */

	dcl     a_rel_name		 char (*) varying;
	dcl     access_ptr		 ptr;

/* AUTOMATIC */

	dcl     key_string		 char (256) varying;


	unspec (access_ptr -> relation_access) = "0"b;
	key_string = REL_ACCESS_HEAD || a_rel_name;


	call iox_$seek_key (access_records_iocb_ptr, key_string, access_record_len, code);
	if code = 0
	then call get_relation_access (key_string, access_ptr);
	else
	     if code = error_table_$no_record
	then do;
		if ^have_sought_default_relation_access
		then do;
			have_sought_default_relation_access = "1"b;
			call get_default_relation_access;
		     end;

		access_ptr -> relation_access = default_relation_access;
	     end;
	else call program_logic_error (code, "Unable to seek key ^a.", key_string, "");

	return;

     end calc_relation_access;

calc_attribute_access: proc (a_rel_name, a_attr_name, access_ptr);

/*
   This routine calculates an attributes access and sets the results
   in the attribute_access structure.

   Access records are searched for starting with the  most  specific
   (case  1)  and continuing through to the least specific (case 5).
   The cases and the cmdsm statements that generate the  access  are
   listed below.

   attribute access: a_attr_name in relation a_rel_name  (specs);
   .   Specifically sets the access of attribute a_attr_name for its
   .   occurence in the relation a_rel_name.

   attribute access: a_attr_name (specs);
   .   Sets the access of attribute a_attr_name for its occurance in
   .   any  relation  except where a_attr_name has an access defined
   .   by the above case.

   relation access: a_rel_name (specs) with attribute access (specs);
   .   Sets the access for every attribute  in  relation  a_rel_name
   .   except  for those attributes who have had an access specified
   .   by either of the above cases.

   default attribute access: (specs)
   .   Sets the attribute access of every attribute in the  submodel
   .   expect those attributes who have had an access defined by any
   .   of the above cases.

   .   If the default attribute access statement does not  exist  in
   .   the cmdsm source than all the attributes not covered by cases
   .   1, 2, or 3 are given an implicit default attribute access.

   Cases 3, 4, and 5 are done in the get_rel_attr_access routine.
*/

	dcl     a_rel_name		 char (*) varying;	/* name of attribute's relation */
	dcl     a_attr_name		 char (*) varying;	/* (input) name of attribute whose access is being computed */
	dcl     access_ptr		 ptr;		/* (input) pointer to attribute's access structure */

/* AUTOMATIC */

	dcl     key_string		 char (256) varying;/* key value of an access record */

	unspec (access_ptr -> attribute_access) = "0"b;
	key_string = ATTR_ACCESS_HEAD || a_attr_name || ATTR_REL_DELIMITER || a_rel_name;

	call iox_$seek_key (access_records_iocb_ptr, key_string, access_record_len, code);
	if code = 0
	then call get_attribute_access (key_string, access_ptr);
	else
	     if code ^= error_table_$no_record
	then call program_logic_error (code, "Could not seek for ^a", key_string, "");
	else do;
		key_string = ATTR_ACCESS_HEAD || a_attr_name;
		call iox_$seek_key (access_records_iocb_ptr, key_string, access_record_len, code);
		if code = 0
		then call get_attribute_access (key_string, access_ptr);
		else
		     if code ^= error_table_$no_record
		then call program_logic_error (code, "Could not seek for ^a", key_string, "");
		else do;
			if last_rel_attr_access_sought_for = a_rel_name
			then access_ptr -> attribute_access = rel_attr_access;
			else do;
				last_rel_attr_access_sought_for = a_rel_name;
				call get_rel_attr_access (a_rel_name, a_attr_name);
				access_ptr -> attribute_access = rel_attr_access;
			     end;
		     end;
	     end;

	return;

     end calc_attribute_access;

get_rel_attr_access: proc (a_rel_name, a_attr_name);

/*
   This routine determines the rel_attr_access. Every relation has a
   default  attribute  access which will be the attribute access set
   on attributes without an explicit access specifiction defined  in
   the  cmdsm source. This access is rel_attr_access. It first looks
   for a record explicitly stating  the  attribute  access  for  the
   current  relation, if its found the access is interpreted and the
   value of rel_attr_access set. If  the  error  code  no_record  is
   returned  it  means  that  the  cmdsm  source  did not contain an
   explicit statement seting the attribute access for  the  relation
   (relation    access    statement    using   the   with   option),
   rel_attr_access  is  therefore  set   to   the   value   of   the
   default_attribute_access. If the default attribute access has not
   yet been found it is determined before  rel_attr_access  is  set.
   Any  other  error code indicates an unexpected error so a program
   logic error is reported.
*/

/* PARAMETER */

	dcl     a_rel_name		 char (*) varying;	/* (input) the relation's name */
	dcl     a_attr_name		 char (*) varying;	/* (input) the attribute's name */




	call iox_$seek_key (access_records_iocb_ptr, REL_ATTR_ACCESS_HEAD || a_rel_name, access_record_len, code);
	if code = 0
	then call get_attribute_access ((REL_ATTR_ACCESS_HEAD), addr (rel_attr_access));
	else
	     if code = error_table_$no_record
	then do;
		if ^have_sought_default_attribute_access
		then do;
			have_sought_default_attribute_access = "1"b;
			call get_default_attribute_access;
		     end;

		rel_attr_access = default_attribute_access;
	     end;
	else call program_logic_error (code,
		"Could not determine access for ^a in relation ^a", a_attr_name, a_rel_name);

	return;

     end get_rel_attr_access;

get_default_attribute_access: proc;

/*
   This   routine   determines   the   default   attribute    access
   specifications.  It  first  looks  for a default attribute access
   specification record that was built  in  response  to  a  default
   attribute  access statement in the cmdsm source. If the record is
   found it interprets the contained access as the default attribute
   access. If the error code no_record is returned it means that the
   source did not contain a default attribute  access  statement  so
   the  default  is  set  to  the  system  defined  default which is
   recorded  in  implicit_default_attribute_access.  If  some  other
   error  code  is returned a drastic problem has occured - report a
   program logic error.
*/

	call iox_$seek_key (access_records_iocb_ptr, (DEF_ATTR_ACCESS_HEAD), access_record_len, code);
	if code = 0
	then call get_attribute_access ((DEF_ATTR_ACCESS_HEAD), addr (default_attribute_access));
	else
	     if code = error_table_$no_record
	then default_attribute_access = implicit_default_attribute_access;
	else call program_logic_error (code, "Could not determine the default attribute access", "", "");

	return;

     end get_default_attribute_access;

get_default_relation_access: proc;

/*
   This   routine   determines   the   default    relation    access
   specifications.  It  first  looks  for  a default relation access
   specification record that was built  in  response  to  a  default
   relation  access  statement in the cmdsm source. If the record is
   found it interprets the contained access as the default  relation
   access. If the error code no_record is returned it means that the
   source did not contain a default relation access statement so the
   default is set to the system defined default which is recorded in
   implicit_default_relation_access. If some  other  error  code  is
   returned  a  drastic problem has occured - report a program logic
   error.
*/

	call iox_$seek_key (access_records_iocb_ptr, (DEF_REL_ACCESS_HEAD), access_record_len, code);
	if code = 0
	then call get_relation_access ((DEF_REL_ACCESS_HEAD), addr (default_relation_access));
	else
	     if code = error_table_$no_record
	then default_relation_access = implicit_default_relation_access;
	else call program_logic_error (code, "Could not determine the default attribute access", "", "");

	return;

     end get_default_relation_access;

get_relation_access: proc (key_string, access_ptr);

/*
   This routine reads the current access record which was set up  by
   the  caller. It interprets the record looking for relation access
   modes   (null,   append_tuple,   delete_tuple)   and   sets   the
   corresponding  bits  in  the  relation  access  structure.  If an
   unrecognized access mode is found report a  program  logic  error
   since  only  legal modes should have been written into the access
   record. If a null access  is  specified  along  with  some  other
   access  the  cmdsm source has a semantic error - report the error
   and continue processing. After the record has been processed mark
   it as having been used.
*/

/* PARAMETER */

	dcl     key_string		 char (256) varying;/* (input) key of the relation access record to be read */
	dcl     access_ptr		 ptr;		/* (input) pointer to relation access storage for this relation */

/* AUTOMATIC */

	dcl     mode_idx		 fixed bin;	/* index of the access mode in the access record */





	unspec (access_ptr -> relation_access) = "0"b;

	call iox_$read_record (access_records_iocb_ptr, access_record_ptr,
	     (sys_info$max_seg_size * 4), access_record_len, code);
	if code ^= 0
	then call program_logic_error (code, "Unable to read relation access record for key ^a.", key_string, "");

	do mode_idx = 1 to access_record.mode_num;
	     if access_record.modes (mode_idx) = "null"
	     then access_ptr -> relation_access.null = "1"b;
	     else
		if access_record.modes (mode_idx) = "append_tuple"
	     then access_ptr -> relation_access.append = "1"b;
	     else
		if access_record.modes (mode_idx) = "delete_tuple"
	     then access_ptr -> relation_access.delete = "1"b;
	     else call program_logic_error (mrds_error_$inconsistent_submodel,
		     "Unrecognized relation access mode ^a", access_record.modes (mode_idx), "");
	end;

	if access_ptr -> relation_access.null &
	     (access_ptr -> relation_access.append | access_ptr -> relation_access.delete)
	then call report_error (mrds_error_$inconsistent_submodel,
		"^/Null access given with other access modes for ^a", key_string, "");

	access_record_ptr -> access_record.used = "1"b;
	call iox_$rewrite_record (access_records_iocb_ptr, access_record_ptr, access_record_len, code);
	if code ^= 0
	then call program_logic_error (code, "Unable to mark access record as being used, record key is: ^a",
		key_string, "");

	return;

     end get_relation_access;

get_attribute_access: proc (key_string, access_ptr);

/*
   This routine reads the current access record which was set up  by
   its caller. It interprets the record looking for attribute access
   modes (null, read, update) and sets the corresponding bits in the
   attribute_access  structure.  If  an  unrecognized access mode is
   found report a program logic error since only legal modes  should
   have  been  written  into  the access record. If a null access is
   specified with some other access the cmdsm source has a  semantic
   error - report the  error  and  continue  processing.  After  the
   record  has been processed mark it as having been used.
*/

/* PARAMETER */

	dcl     key_string		 char (256) varying;/* (input) key of the attribute access record to be read */
	dcl     access_ptr		 ptr;		/* (input) pointer to attribute access storage */

/* AUTOMATIC */

	dcl     mode_idx		 fixed bin;	/* index of the access mode in the access record */





	unspec (access_ptr -> attribute_access) = "0"b;

	call iox_$read_record (access_records_iocb_ptr, access_record_ptr,
	     (sys_info$max_seg_size * 4), access_record_len, code);
	if code ^= 0
	then call program_logic_error (code, "Unable to read attribute access record for key ^a.", key_string, "");

	do mode_idx = 1 to access_record.mode_num;
	     if access_record.modes (mode_idx) = "null"
	     then access_ptr -> attribute_access.null = "1"b;
	     else
		if access_record.modes (mode_idx) = "read"
	     then access_ptr -> attribute_access.read = "1"b;
	     else
		if access_record.modes (mode_idx) = "update"
	     then access_ptr -> attribute_access.modify = "1"b;
	     else call program_logic_error (mrds_error_$inconsistent_submodel,
		     "Unrecognized attribute access mode ^a", access_record.modes (mode_idx), "");
	end;

	if access_ptr -> attribute_access.null &
	     (access_ptr -> attribute_access.read | access_ptr -> attribute_access.modify)
	then call report_error (mrds_error_$inconsistent_submodel,
		"^/Null access given with other access modes for ^a", key_string, "");

	access_record_ptr -> access_record.used = "1"b;
	call iox_$rewrite_record (access_records_iocb_ptr, access_record_ptr, access_record_len, code);
	if code ^= 0
	then call program_logic_error (code, "Unable to mark access record as being used, record key is: ^a",
		key_string, "");

	return;

     end get_attribute_access;

validate_relation_access: proc;

/*
   This procedure validates that the relation  access  specified  is
   legal.  A submodel relation must be a full view of its base model
   relation before it  can  have  either  append  or  delete  access
   specified.  It is sufficient to check attribute numbers since the
   model/submodel mapping has been checked by mrds_dsm_semantics  so
   that  the only way the submodel relation can have the same number
   of attributes as the model relation is if each model attribute is
   used  to  define  1  submodel attribute. Also a submodel relation
   must have read access specified on all the key attributes of  the
   model  relation before append access can be specified. This is so
   that  multiple  stores   cannot   be   made   until   the   error
   tuple_not_found is returned - at which time the key values of the
   tuple are known.
*/


/* AUTOMATIC */

	dcl     dm_attr		 fixed bin;	/* index of a datamodel attribute */
	dcl     dsm_attr		 fixed bin;	/* index of a submodel attribute */
	dcl     done		 bit (1) unal;	/* used to terminate searching loop */

	call mrds_dm_get_attributes
	     (p_data_model_ptr,
	     (rel_rec_5_ptr -> rel_rec_5.rel_dm_name),
	     local_area_ptr,
	     rd_ptr,
	     code);
	if code ^= 0				/* the fact that no model relation exists has already been */
	then return;				/* reported in semantics */

	if (rel_rec_5_ptr -> rel_rec_5.access.append | rel_rec_5_ptr -> rel_rec_5.access.delete) &
	     rel_rec_5_ptr -> rel_rec_5.attr_num ^= rd_ptr -> rel_desc.num_attr
	then call report_error (mrds_error_$inconsistent_submodel,
		"^/^a may not have append and/or delete access specified since its not a full view of ^a",
		relation_name, rel_rec_5_ptr -> rel_rec_5.rel_dm_name);
	else
	     if rel_rec_5_ptr -> rel_rec_5.access.append
	then do;
		do dm_attr = 1 to rd_ptr -> rel_desc.num_attr;
		     if rd_ptr -> rel_desc.attributes (dm_attr).key_flag
		     then do;
			     done = "0"b;
			     do dsm_attr = 1 to rel_rec_5_ptr -> rel_rec_5.attr_num while (^done);
				if rel_rec_5_ptr -> rel_rec_5.attr (dsm_attr).dm_name =
				     rd_ptr -> rel_desc.attributes (dm_attr).attribute_name
				then do;
					if ^rel_rec_5_ptr -> rel_rec_5.attr (dsm_attr).access.read
					then do;
						call report_error (mrds_error_$inconsistent_submodel,
						     "^/Relation ^a does not have read access on" ||
						     " all of the key attributes of its base relation ^a",
						     relation_name,
						     rel_rec_5_ptr -> rel_rec_5.rel_dm_name);
						done = "1"b;
					     end;
					else done = "1"b;
				     end;
			     end;
			end;
		end;
	     end;


	return;

     end validate_relation_access;

verify_access_record_use: proc;

/*
   This procedure verifies that the access  records  have  all  been
   used.  If  a  record  is  not  used a message is output using the
   record's key as an identifier.

   A "current" position is first set up by going to the beginning of
   the  file  and then skipping the header record. All records after
   the header record are either access records or relation  records.
   The  key of the current record is read and if does not begin with
   the string "relation:" it is treated as an access  record  -  the
   associated record is read and the used field check. If the record
   is a relation record the "current" position must be advanced  one
   record, read_record does this authomatically.

   Records are read until a non-zero code  is  returned.  Any  error
   code other than end_of_info indicates that not all of the records
   were read and is a program logic error.
*/

	dcl     local_key_string	 char (256) init (""); /* non-varying version of key_string */
						/* so that substr can be done without worry about the varying length */


	call iox_$position (access_records_iocb_ptr, -1, 0, code);
	if code ^= 0
	then call program_logic_error (code, "Unable to position to the first record to begin access verification",
		"", "");
	call iox_$position (access_records_iocb_ptr, 0, 1, code);
	if code ^= 0
	then call program_logic_error (code, "Unable to skip header record to begin access verification", "", "");

	do while (code = 0);
	     call iox_$read_key (access_records_iocb_ptr, key_string, access_record_len, code);

/* BEGIN CHANGE 81-09-17 */

	     local_key_string = key_string;
	     if code = 0 & substr (local_key_string, 1, 9) ^= "relation:" & substr (local_key_string, 1, 15) ^= "model relation:"

/* END   CHANGE 81-09-17 */

	     then do;
		     call iox_$read_record (access_records_iocb_ptr, access_record_ptr, (sys_info$max_seg_size * 4),
			access_record_len, code);
		     if code = 0
		     then do;
			     if ^access_record_ptr -> access_record.used
			     then call report_error (mrds_error_$inconsistent_submodel,
				     "^/Access specification: ^a was never used", key_string, "");
			end;
		end;
	     else do;
		     call iox_$position (access_records_iocb_ptr, 0, 1, code);
		     if code ^= 0 & code ^= error_table_$end_of_info
		     then call program_logic_error (code, "Unable to skip a relation record during access verification",
			     "", "");
		end;
	end;
	if code ^= error_table_$end_of_info
	then call program_logic_error (code, "Unable to verify access record usage", "", "");

	return;

     end verify_access_record_use;

program_logic_error: proc (icode, message, arg1, arg2);

/*
   This  routine  calls  report_error  to  report  the  error  after
   concatinating  the  phrase "^/PROGRAM LOGIC ERROR^/" to the input
   message, it then calls cleanup_handler to release  the  temporary
   segments  and  close  the submodel, it then sets the value of the
   return  error  code  and  then   does   a   non-local   goto   to
   exit_compute_access.

   NOTE this routine does NOT return it does  a  non-local  goto  to
   exit_compute_access.
*/


/* PARAMETERS */

	dcl     icode		 fixed bin (35);	/* (input) error code */
	dcl     message		 char (*);	/* (input) error message */
	dcl     arg1		 char (*) varying;	/* (input) first error message argument */
	dcl     arg2		 char (*) varying;	/* (input) second error message argument */





	call report_error (icode, "^/PROGRAM LOGIC ERROR^/" || message, arg1, arg2);

	call cleanup_handler;

	p_code = icode;

	goto exit_compute_access;

     end;						/* report_error */

report_error: proc (icode, message, arg1, arg2);

/*
   This routine reports errors via the iox_$error_output switch  and
   the  lsiting_iocb switch (providing it is non-null). It also sets
   the value of the output error code
*/



/* PARAMETERS */

	dcl     icode		 fixed bin (35);	/* (input) error code) */
	dcl     message		 char (*);	/* (input) error message */
	dcl     arg1		 char (*) varying;	/* (input) first argument to error message */
	dcl     arg2		 char (*) varying;	/* (input) second argument to error message */

/* AUTOMATIC */

	dcl     long_message	 char (100) aligned;/* long message associated with the error code */
	dcl     short_message	 char (8) aligned;	/* short message associated with the error code */

/* ENTRIES */

	dcl     convert_status_code_	 entry (fixed bin (35), char (8) aligned, char (100) aligned);
	dcl     ioa_$ioa_switch	 entry options (variable);

/* EXTERNAL */

	dcl     iox_$error_output	 ptr external static;



	call convert_status_code_ (icode, short_message, long_message);
	call ioa_$ioa_switch (iox_$error_output, long_message || message || "^/", arg1, arg2);

	if p_listing_iocb_ptr ^= null ()
	then call ioa_$ioa_switch (p_listing_iocb_ptr, long_message || message || "^/", arg1, arg2);


	p_code = icode;

	return;

     end report_error;

cleanup_handler: proc;

/*
   This procedure releases the two temporary segments and closes the
   two openings of the submodel - after checking to be sure that the
   temporary segments have been set up and the submodel opened  (pts
   ^= null).

   The error code returned by release_temp_segments_  is  ignored  -
   there  is  nothing  that  can be done anyway, and the submodel is
   closed using an entry that does not return an error code.
*/





	if temp_seg_ptrs (1) ^= null
	then call release_temp_segments_ (p_caller_name, temp_seg_ptrs, code);

	if access_records_iocb_ptr ^= null
	then call mrds_dsm_close$force (access_records_iocb_ptr);

	if relation_records_iocb_ptr ^= null
	then call mrds_dsm_close$force (relation_records_iocb_ptr);


     end cleanup_handler;

%include mrds_dsm_access_record;
%page;
%include mrds_dsm_head_strings;
%page;
%include mrds_dsm_rel_rec_5;
%page;
%include mrds_rel_desc;
%page;
%include select_info;


     end;						/* End of compute_dsm_access. */

