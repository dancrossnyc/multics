/* ***********************************************************
   *                                                         *
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
   *                                                         *
   *                                                         *
   *********************************************************** */

/* ******************************************************
   *                                                    *
   *                                                    *
   * Copyright (c) 1972 by Massachusetts Institute of   *
   * Technology and Honeywell Information Systems, Inc. *
   *                                                    *
   *                                                    *
   ****************************************************** */

mrds_builtin_:
     proc;

/* DESCRIPTION:

   This  procedure  contains  entries  to  implement all MRDS and LINUS scalar
   builtin  functions.   No error codes are returned from this modules but two
   kinds  of  conditions  call  be  signaled  function_err and fatal_func_err.
   function_err  is  signaled  when  a  stringsize  condition  is  encountered
   fatal_func_err is signaled for all other errors detected.



   HISTORY:

   77-06-01 J. A. Weeldreyer: Initially written.

   77-07-01 R.  D.  Lackey: Modified to complete implemetation of mrds builtin
   functions.

   77-12-01 R. D. Lackey: Modified to correct round builtin.

   78-03-01 R. D. Lackey: Modified to correct size in concat descriptor.

   78-04-01 R. D. Lackey: Modified to add fatal_func_err condition.

   79-12-13  Davids:  Modified  rnd  to  take log10 (abs (in_val)) rather then
   log10 (in_val) in_val = 0 is a special case and returns 0.

   79-12-20  Davids:  Modified  value  of  CHAR_VAR_DESC  so  that it shows an
   unpacked  varying  char  desc.   Modified value of BIT_VAR_DESC so that its
   unpacked and really varying.

   79-12-21 Davids: Took the condition handling out of the substr function and
   explicitly  check for those things that can cause the stringrange condition
   to  be  signaled.   Also  modified the assignment of the lengths of varying
   character  and  bit  strings  in canon_bit and canon_char to use the actual
   length  not  the  declared  length.  The length of the return string in the
   reverse  function  is now taken from the descriptor pointed to by the third
   pointer in arg_list rather than the first.

   79-12-26  Davids: Modified canon_char so that the internal pointer pointing
   at a bit varying data type points to the length word.

   79-12-27 Davids: bnv in canon_bit is now based on a_ptr rather than b_ptr.

   80-01-01  Jim Gray : Modified to add calls to mu_data_class$xxxx_data_class
   so  that  packed  decimal  data types could be handled.  Also the structure
   rslt_cfld_59  had its float decimal(59) members changed to aligned, so that
   it  looks like a complex float decimal(59) aligned, which the new unaligned
   decimal would not imitate.

   80-01-07  Rickie  E.  Brinegar: Modified to make substr check of descriptor
   class types work properly.

   80-02-01 Jim Gray : Modified to make use of extensible non-freeing area for
   temp storage rather than system_free.

   81-08-14  Roger Lackey : Removed init and tidy_up internal procedures and
   replaced allocation in connoize procedures to use automatice variables for
   buffering instead of allocation.

   81-09-21 Davids: added a line of code to  all  entries  that  use
   arg_list to set the value of num_ptrs to prevent a subscriptrange
   condition from occuring.

   81-09-23 Davids: modified substr so that if the requested  length
   of  the  substring  would cause a reference beyond the end of the
   original string, the length of the substring returned is  shorted
   so  that  it  references  up  to  the last character (bit) of the
   original string.

   81-09-24 Davids: Removed all references to the variables  t1  and
   t2. These variables were being set but never referenced. It looks
   like a past change removed their usefullness but  they  were  not
   removed  at that time. Since they were declared fixed bin (5) and
   they were being set to the descriptor type which is fixed bin (6)
   unsigned  a size condition was possible and in fact was occurring
   in floor_info when used with a data type of  real  float  decimal
   unaligned.
*/

	return;					/* should never use mrds_builtin_ entry */

abs:
     entry;

/* This entry impliments the MRDS/LINUS "abs" builtin function.
   This is an arithmetic function, so only an arithmetic argument is accepted.
   If the argument is non-complex the input value is converted to float decimal (59)
   prior to calling the abs builtin function.
   The returned result is float decimal (59).
   The PL/I "abs" builtin is used to actually perform the function. */

	on size call fatal_func_error;
	on conversion call fatal_func_error;

/* BEGIN CHANGE 81-08-14 RDL ********************************************** */

	num_ptrs = 0;				/* to aviod a compiler warning */

/* END CHANGE 81-08-14 RDL ********************************************** */

	call cu_$arg_list_ptr (al_ptr);		/* Get the argument list pointer */
	num_ptrs = arg_list.arg_count;		/* CHANGE 81-09-21 */
	r_ptr = arg_list.arg_des_ptr (2);		/* Points to place to store result */

	call
	     conv_to_float_dec_59 (arg_list.arg_des_ptr (1),
	     arg_list.arg_des_ptr (3), fld_val_1);	/* Convert to
						   float decimal (59) */
(size, conversion):
	rslt_fld_59 = abs (fld_val_1);

	return;					/* End of abs entry */



abs_info:
     entry (ad_ptr, rslt_desc);

/* Info entry for the "abs" builtin */
/* rslt_desc = 0 or float decimal (59) */

	if arg_descs.ndescs ^= 1 then
	     rslt_desc = "0"b;			/* Must have only one arg */

	else if mu_data_class$convertible_data_class (addr (arg_descs.desc (1)))
	then rslt_desc = FLD59_DESC;

	else rslt_desc = "0"b;

	return;					/* End of abs info entry */

after:
     entry;

/* This entry implements the MRDS/LINUS "after" builtin function.  This is
   a string function, so arithmetic arguments are not accepted.  If there is a
   mixture of character and bit arguments, an attempt is made to convert the bit
   argument to a character string.  The PL/I "after" builtin is used to actualy perform
   the function.  Returned result is either a bit or char varying string. */


/* BEGIN CHANGE 81-08-14 RDL ********************************************** */

	a1_ptr = addr (buffer1);
	a2_ptr = addr (buffer2);

/* END CHANGE 81-08-14 RDL ********************************************** */

	call cu_$arg_list_ptr (al_ptr);		/* get pointer to arg list */
	num_ptrs = arg_list.arg_count;		/* CHANGE 81-09-21 */
	r_ptr = addrel (arg_list.arg_des_ptr (3), -1);	/* point to place to store result */

	r_len = fixed (string (arg_list.arg_des_ptr (6) -> descriptor.size), 24);
						/* Max length of return string
						   can be no longer then length of input string (arg (1)) */

	if mu_data_class$bit_data_class (arg_list.arg_des_ptr (4))
	     & mu_data_class$bit_data_class (arg_list.arg_des_ptr (5)) then do;
						/* will canonize to bit var */
		call canon_bit (1, a1_ptr, a1_len);
		call canon_bit (2, a2_ptr, a2_len);
		rslt_bit_string = after (b1, b2);	/* do bit string after */
	     end;
	else do;					/* canonize to char. var. */
		call canon_char (1, a1_ptr, a1_len);
		call canon_char (2, a2_ptr, a2_len);
		rslt_char_string = after (c1, c2);	/* Do char string after */
	     end;



	return;					/* End of after entry */

after_info:
     entry (ad_ptr, rslt_desc);

/* Info entry for the "after" builtin */
/* rslt_desc = 0   or BIT_VAR_DESC  or  CHAR_VAR_DESC */

	rslt_desc = arg_descs.desc (1);		/* Init to non-zero value */

	if arg_descs.ndescs ^= 2 then
	     rslt_desc = "0"b;			/* Exactly 2 arguments required */

	else /* Check for string args */
	     if ^(mu_data_class$string_data_class (addr (arg_descs.desc (1)))
		& mu_data_class$string_data_class (addr (arg_descs.desc (2))))
	then rslt_desc = "0"b;

	if rslt_desc ^= "0"b then do;			/* Everything OK so set rslt_desc */

		rslt_desc = "0"b;			/* Zero all the bits in the rslt_desc */

		if addr (arg_descs.desc (1)) -> descriptor.type = /* If both string types are the same */
		     addr (arg_descs.desc (2)) -> descriptor.type then do;
			if addr (arg_descs.desc (1)) -> descriptor.type < 21 then
			     rslt_desc = BIT_VAR_DESC;/* Bit varying */
			else rslt_desc = CHAR_VAR_DESC; /* Char varying */
		     end;

		else /* String types are different */
		     rslt_desc = CHAR_VAR_DESC;	/* So make it char varying */

		addr (rslt_desc) -> descriptor.size =
		     addr (arg_descs.desc (1)) -> descriptor.size; /* Size can be no larger
						   then that of the input string */

	     end;

	return;					/*  End of after_info entry */

before:
     entry;

/* This entry implements the MRDS/LINUS "before" builtin function.  This is
   a string function, so arithmetic arguments are not accepted.  If there is a
   mixture of character and bit arguments, an attempt is made to convert the bit
   argument to a character string.  The PL/I "before" builtin is used to actualy perform
   the function.  Returned result is either a bit or char varying string. */


/* BEGIN CHANGE 81-08-14 RDL ********************************************** */

	a1_ptr = addr (buffer1);
	a2_ptr = addr (buffer2);

/* END CHANGE 81-08-14 RDL ********************************************** */

	call cu_$arg_list_ptr (al_ptr);		/* get pointer to arg list */
	num_ptrs = arg_list.arg_count;		/* CHANGE 81-09-21 */
	r_ptr = addrel (arg_list.arg_des_ptr (3), -1);	/* point to place to store result */

	r_len = fixed (string (arg_list.arg_des_ptr (6) -> descriptor.size), 24);
						/* Max length of return string
						   can be no longer then length of input string (arg (1)) */

	if mu_data_class$bit_data_class (arg_list.arg_des_ptr (4))
	     & mu_data_class$bit_data_class (arg_list.arg_des_ptr (5)) then do;
						/* will canonize to bit var */
		call canon_bit (1, a1_ptr, a1_len);
		call canon_bit (2, a2_ptr, a2_len);
		rslt_bit_string = before (b1, b2);	/* do bit string before */
	     end;
	else do;					/* canonize to char. var. */
		call canon_char (1, a1_ptr, a1_len);
		call canon_char (2, a2_ptr, a2_len);
		rslt_char_string = before (c1, c2);	/* Do char string before */
	     end;


	return;					/* End of before entry */

before_info:
     entry (ad_ptr, rslt_desc);

/* Info entry for the "before" builtin */
/* rslt_desc = 0  or  BIT_VAR_DESC  or  CHAR_VAR_DESC */

	rslt_desc = arg_descs.desc (1);		/* Init to non-zero value */

	if arg_descs.ndescs ^= 2 then
	     rslt_desc = "0"b;			/* Exactly 2 arguments required */

	else /* Check for string args */
	     if ^(mu_data_class$string_data_class (addr (arg_descs.desc (1)))
		& mu_data_class$string_data_class (addr (arg_descs.desc (2))))
	then rslt_desc = "0"b;

	if rslt_desc ^= "0"b then do;			/* Everything OK so set rslt_desc */

		rslt_desc = "0"b;			/* Zero all the bits in the rslt_desc */

		if addr (arg_descs.desc (1)) -> descriptor.type = /* If both string types are the same */
		     addr (arg_descs.desc (2)) -> descriptor.type then do;

			if addr (arg_descs.desc (1)) -> descriptor.type < 21 then
			     rslt_desc = BIT_VAR_DESC;/* Bit varying */
			else rslt_desc = CHAR_VAR_DESC; /* Char varying */
		     end;

		else /* String types are different */
		     rslt_desc = CHAR_VAR_DESC;	/* So make it char varying */

		addr (rslt_desc) -> descriptor.size =
		     addr (arg_descs.desc (1)) -> descriptor.size; /* Size can be no larger
						   then that of the input string */

	     end;

	return;					/*  End of before_info entry */

ceil:
     entry;

/* This entry impliments the MRDS/LINUS "ceil" builtin function.
   This is an arithmetic function, so only an arithmetic argument is accepted.
   The argument is converted to float decimal (59)  prior to calling the ceil builtin function.
   The returned result is float decimal (59).
   The PL/i "ceil" builtin is used to actually perform the function. */

	on size call fatal_func_error;
	on conversion call fatal_func_error;
	call cu_$arg_list_ptr (al_ptr);		/* Get the argument list pointer */
	num_ptrs = arg_list.arg_count;		/* CHANGE 81-09-21 */
	r_ptr = arg_list.arg_des_ptr (2);		/* Points to place to store result */

	call
	     conv_to_float_dec_59 (arg_list.arg_des_ptr (1),
	     arg_list.arg_des_ptr (3), fld_val_1);	/* Convert to
						   float decimal (59) */
(size, conversion):
	rslt_fld_59 = ceil (fld_val_1);

	return;					/* End of ceil entry */



ceil_info:
     entry (ad_ptr, rslt_desc);

/* Info entry for the "ceil" builtin */
/* rslt_desc = 0 or float decimal (59) */

	if arg_descs.ndescs ^= 1 then
	     rslt_desc = "0"b;			/* Must have only one arg */

	else if mu_data_class$convertible_data_class (addr (arg_descs.desc (1)))
	then rslt_desc = FLD59_DESC;

	else rslt_desc = "0"b;

	return;					/* End of ceil info entry */

concat:
     entry;

/* This entry implements the MRDS/LINUS "concat" builtin function.  This is
   a string function, so arithmetic arguments are not accepted.  If there is a
   mixture of character and bit arguments, an attempt is made to convert the bit
   argument to a character string.    Returned result is either a bit or char varying string. */


/* BEGIN CHANGE 81-08-14 RDL ********************************************** */

	a1_ptr = addr (buffer1);
	a2_ptr = addr (buffer2);

/* END CHANGE 81-08-14 RDL ********************************************** */

	call cu_$arg_list_ptr (al_ptr);		/* get pointer to arg list */
	num_ptrs = arg_list.arg_count;		/* CHANGE 81-09-21 */
	r_ptr = addrel (arg_list.arg_des_ptr (3), -1);	/* point to place to store result */

	r_len = fixed (string (arg_list.arg_des_ptr (6) -> descriptor.size), 26);
						/* Max length of return string */

	if mu_data_class$bit_data_class (arg_list.arg_des_ptr (4))
	     & mu_data_class$bit_data_class (arg_list.arg_des_ptr (5)) then do;
						/* will canonize to bit var */
		call canon_bit (1, a1_ptr, a1_len);
		call canon_bit (2, a2_ptr, a2_len);
		rslt_bit_string = b1 || b2;		/* do bit string concatination */
	     end;
	else do;					/* canonize to char. var. */
		call canon_char (1, a1_ptr, a1_len);
		call canon_char (2, a2_ptr, a2_len);
		rslt_char_string = c1 || c2;		/* Do char string concat */
	     end;


	return;					/* End of concat entry */


concat_info:
     entry (ad_ptr, rslt_desc);

/* Info entry for the "concat" builtin */
/* rslt_desc = 0  or BIT_VAR_DESC  or  CHAR_VAR_DESC */

	if arg_descs.ndescs ^= 2 then
	     rslt_desc = "0"b;			/* Must have exactly two args */

	else /* Check for string args */
	     if ^(mu_data_class$string_data_class (addr (arg_descs.desc (1)))
		& mu_data_class$string_data_class (addr (arg_descs.desc (2))))
	then rslt_desc = "0"b;

	else do;					/* If everything OK then build the descriptor */

		rslt_desc = "0"b;

		if addr (arg_descs.desc (1)) -> descriptor.type = /* If both string types are the same */
		     addr (arg_descs.desc (2)) -> descriptor.type then do;
			if addr (arg_descs.desc (1)) -> descriptor.type < 21 then
			     rslt_desc = BIT_VAR_DESC;/* Bit varying */
			else rslt_desc = CHAR_VAR_DESC; /* Char varying */
		     end;

		else /* String types are different */
		     rslt_desc = CHAR_VAR_DESC;	/* So make it char varying */


		s1 = fixed (string (addr (arg_descs.desc (1)) -> descriptor.size), 24);
		s2 = fixed (string (addr (arg_descs.desc (2)) -> descriptor.size), 24);

		desc_ptr = addr (rslt_desc);
		n = s1 + s2;			/* Max size = sum tow input sizes */
		string (descriptor.size) = bit (n);	/* New size = sum of two input sizes */

	     end;

	return;					/* End of concat_info entry */


floor:
     entry;

/* This entry impliments the MRDS/LINUS "floor" builtin function.
   This is an arithmetic function, only an arithmetic non-complex argument is accepted.
   The argument is converted to float decimal (59) prior to calling the floor builtin function.
   The returned result is a float decimal (59).
   The PL/I "floor" builtin is used to actually perform the function. */

	on size call fatal_func_error;
	on conversion call fatal_func_error;

	call cu_$arg_list_ptr (al_ptr);		/* Get the argument list pointer */
	num_ptrs = arg_list.arg_count;		/* CHANGE 81-09-21 */
	r_ptr = arg_list.arg_des_ptr (2);		/* Points to place to store result */

	call
	     conv_to_float_dec_59 (arg_list.arg_des_ptr (1),
	     arg_list.arg_des_ptr (3), fld_val_1);	/* Convert to
						   float decimal (59) */
(size, conversion):
	rslt_fld_59 = floor (fld_val_1);		/* Find the floor */

	return;					/* End of floor entry */



floor_info:
     entry (ad_ptr, rslt_desc);

/* Info entry for the "floor" builtin */
/* rslt_desc = 0 or float decimal (59) */

	if arg_descs.ndescs ^= 1 then
	     rslt_desc = "0"b;			/* Must have only one arg */

	else if mu_data_class$convertible_data_class (addr (arg_descs.desc (1)))
	then rslt_desc = FLD59_DESC;

	else rslt_desc = "0"b;

	return;					/* End of floor info entry */

index:
     entry;

/* This entry implements the MRDS/LINUS "index" builtin function.  This is
   a string function, so arithmetic arguments are not accepted.  If there is a
   mixture of character and bit arguments, an attempt is made to convert the bit
   argument to a character string.  The PL/I "index" builtin is used to actualy perform
   the function.  Returned result is a fixed bin (24). */


	call cu_$arg_list_ptr (al_ptr);		/* get pointer to arg list */
	num_ptrs = arg_list.arg_count;		/* CHANGE 81-09-21 */
	r_ptr = arg_list.arg_des_ptr (3);		/* point to place to store result */

	a1_ptr = addr (buffer1);
	a2_ptr = addr (buffer2);

	if mu_data_class$bit_data_class (arg_list.arg_des_ptr (4))
	     & mu_data_class$bit_data_class (arg_list.arg_des_ptr (5)) then do;
						/* will canonize to bit var */
		call canon_bit (1, a1_ptr, a1_len);
		call canon_bit (2, a2_ptr, a2_len);
		rslt_bin = index (b1, b2);		/* do bit string index */
	     end;
	else do;					/* canonize to char. var. */
		call canon_char (1, a1_ptr, a1_len);
		call canon_char (2, a2_ptr, a2_len);
		rslt_bin = index (c1, c2);		/* Do char string index */
	     end;


	return;					/* end of index */





index_info:
     entry (ad_ptr, rslt_desc);

/* Info entry for the "index" builtin */
/* rslt_desc = 0  or  FIXED_BIN_24 */

	if arg_descs.ndescs ^= 2 then
	     rslt_desc = "0"b;			/* need exactly 2 args */
	else /* check for string args */
	     if ^(mu_data_class$string_data_class (addr (arg_descs.desc (1)))
		& mu_data_class$string_data_class (addr (arg_descs.desc (2))))
	then rslt_desc = "0"b;
	else rslt_desc = FIB24_DESC;			/* have 2 string args */

	return;					/* end of index info entry */

mod:
     entry;

/* This entry implements the MRDS/LINUS "mod" builtin function.
   This is an arithmetic function, so only arithmetic arguments are allowed.
   The input arguments are converted to float decimal (59) and the
   returned result is a float decimal (59).
   The PL/I "mod" builtin is used to actually perform the function. */

	on size call fatal_func_error;
	on conversion call fatal_func_error;

	call cu_$arg_list_ptr (al_ptr);		/* Get the argument list pointer */
	num_ptrs = arg_list.arg_count;		/* CHANGE 81-09-21 */
	r_ptr = arg_list.arg_des_ptr (3);		/* Points to the place to store result */

	call
	     conv_to_float_dec_59 (arg_list.arg_des_ptr (1),
	     arg_list.arg_des_ptr (4), fld_val_1);	/* Convert to
						   float decimal (59) */
	call
	     conv_to_float_dec_59 (arg_list.arg_des_ptr (2),
	     arg_list.arg_des_ptr (5), fld_val_2);	/*  Convert second arg
						   to float decimal (59) */
(size, conversion):
	rslt_fld_59 = mod (fld_val_1, fld_val_2);	/* Do the mod function */

	return;					/* End of mod entry */



mod_info:
     entry (ad_ptr, rslt_desc);

/* Info entry for the "mod" builtin
   rslt_desc = 0 or float_decimal (59) */

	if arg_descs.ndescs ^= 2 then
	     rslt_desc = "0"b;			/* Must have only two args */

	else if mu_data_class$convertible_data_class (addr (arg_descs.desc (1)))
		& mu_data_class$convertible_data_class (addr (arg_descs.desc (2)))
						/* If both args can be converted */
	then rslt_desc = FLD59_DESC;

	else rslt_desc = "0"b;

	return;					/* End of mod_info entry */

reverse:
     entry;

/* This entry implements the MRDS/LINUS "reverse" builtin function.  This is
   a string function, so arithmetic arguments are not accepted.
   The PL/I "reverse" builtin is used to actualy perform
   the function.  Returned result is a bit or char varying string. */


/* BEGIN CHANGE 81-08-14 RDL ********************************************** */

	a1_ptr = addr (buffer1);

/* END CHANGE 81-08-14 RDL ********************************************** */

	call cu_$arg_list_ptr (al_ptr);		/* get pointer to arg list */
	num_ptrs = arg_list.arg_count;		/* CHANGE 81-09-21 */
	r_ptr = addrel (arg_list.arg_des_ptr (2), -1);	/* point to place to store result */

	r_len = fixed (string (arg_list.arg_des_ptr (3) -> descriptor.size), 24);
						/* Max length of return string
						   can be no larger then input string */

	if mu_data_class$bit_data_class (arg_list.arg_des_ptr (3)) then do;
						/* String type is bit */
		call canon_bit (1, a1_ptr, a1_len);
		rslt_bit_string = reverse (b1);	/* do bit string reverse */
	     end;
	else do;					/* canonize to char. var. */
		call canon_char (1, a1_ptr, a1_len);
		rslt_char_string = reverse (c1);	/* Do char string reverse */
	     end;


	return;					/* End of reverse */




reverse_info:
     entry (ad_ptr, rslt_desc);

/* Info entry for the "reverse" builtin */

	if arg_descs.ndescs ^= 1 then
	     rslt_desc = "0"b;			/* Can only accept one arg */

	else if ^mu_data_class$string_data_class (addr (arg_descs.desc (1))) then
	     rslt_desc = "0"b;			/* Got to be a
						   string of some kind */

	else do;					/* If everything OK then build the rslt desc */

		rslt_desc = "0"b;			/* Start with it all zeros */

		if addr (arg_descs.desc (1)) -> descriptor.type < 21 then
		     rslt_desc = BIT_VAR_DESC;	/* Bit varying */
		else rslt_desc = CHAR_VAR_DESC;	/* Char varying */

		addr (rslt_desc) -> descriptor.size =
		     addr (arg_descs.desc (1)) -> descriptor.size; /* size = input size */

	     end;

	return;					/* End of reverse_info entry */

round:
     entry;

/* This entry implements the MRDS/LINUS "round" builtin function.
   This is an arithmetic function so only arithmentic arguments are accepted.
   The input value is canonized to a float decimal (59) before rounding and the returned
   value is a float decimal (59). */

	on size call fatal_func_error;
	on conversion call fatal_func_error;

	call cu_$arg_list_ptr (al_ptr);
	num_ptrs = arg_list.arg_count;		/* CHANGE 81-09-21 */
	r_ptr = arg_list.arg_des_ptr (3);		/* Place to store result */

	call
	     conv_to_float_dec_59 (arg_list.arg_des_ptr (2),
	     arg_list.arg_des_ptr (5), q);

	if mu_data_class$complex_data_class (arg_list.arg_des_ptr (4)) then do;
						/* If input is complex */
		call
		     conv_to_complex_float_dec_59 (arg_list.arg_des_ptr (1),
		     arg_list.arg_des_ptr (4), cmplx_fld_59_val);
		call
		     rnd (real (cmplx_fld_59_val), q, arg_list.arg_des_ptr (4),
		     fld_val_1);			/* Round the real part */
		call
		     rnd (imag (cmplx_fld_59_val), q, arg_list.arg_des_ptr (4),
		     fld_val_2);			/* Round the imaginary part */
		rslt_cfld_59.real = fld_val_1;	/* Stuff the real and imag parts in returned result */
		rslt_cfld_59.imag = fld_val_2;
	     end;
	else do;					/* If input was not complex */
		call
		     conv_to_float_dec_59 (arg_list.arg_des_ptr (1),
		     arg_list.arg_des_ptr (4), fld_val_1);
		call rnd (fld_val_1, q, arg_list.arg_des_ptr (4), rslt_fld_59);
	     end;


	return;					/* End of round entry */


round_info:
     entry (ad_ptr, rslt_desc);

/* Info entry for the "round" builtin
   rslt_desc = 0  or FLD59_DESC  */


	if arg_descs.ndescs ^= 2 then
	     rslt_desc = "0"b;			/* Must have only two args */

	else if mu_data_class$complex_data_class (addr (arg_descs.desc (1)))
		& mu_data_class$convertible_data_class (addr (arg_descs.desc (2)))
	then rslt_desc = CFLD59_DESC;
	else if mu_data_class$convertible_data_class (addr (arg_descs.desc (1)))
		& mu_data_class$convertible_data_class (addr (arg_descs.desc (2)))
						/* If both args can be converted */
	then rslt_desc = FLD59_DESC;

	else rslt_desc = "0"b;

	return;					/* End of round_info entry */

(size, conversion):
rnd:
     proc (in_val, q, type, r_val);

/* This procedure accepts a float decimal (59) input value and rounds it
   returning the result in r_val. The type indicates if the original input was fixed or float. */

	dcl     in_val		 float decimal (59);/* (INPUT) */
	dcl     q			 float decimal (59);/* (INPUT) */
	dcl     type		 ptr;		/* (INPUT) Descriptor pointer */
	dcl     r_val		 float decimal (59);/* (OUTPUT) */

	if abs (in_val) > 0.000001 then do;
		if mu_data_class$fixed_data_class (type) then
		     n = q;			/* If input type is fixed */
		else do;				/* Floating number */
			if sign (q) = -1. then
			     call fatal_func_error;
			n = q - (floor (log10 (abs (in_val)) + 1));
		     end;

		r_val = sign (in_val) * floor (abs (in_val) * 10.0 ** n + 0.5);
		r_val = divide (r_val, (10.0 ** n), 59);
	     end;
	else r_val = 0;

	return;

     end rnd;

search:
     entry;

/* This entry implements the MRDS/LINUS "search" builtin function.  This is
   a string function, so arithmetic arguments are not accepted.  If there is a
   mixture of character and bit arguments, an attempt is made to convert the bit
   argument to a character string.  The PL/I "search" builtin is used to actualy perform
   the function.  The returned result will be a fixed bin (24).  */


/* BEGIN CHANGE 81-08-14 RDL ********************************************** */

	a1_ptr = addr (buffer1);
	a2_ptr = addr (buffer2);

/* END CHANGE 81-08-14 RDL ********************************************** */

	call cu_$arg_list_ptr (al_ptr);		/* get pointer to arg list */
	num_ptrs = arg_list.arg_count;		/* CHANGE 81-09-21 */
	r_ptr = arg_list.arg_des_ptr (3);		/* point to place to store result */

	call canon_char (1, a1_ptr, a1_len);
	call canon_char (2, a2_ptr, a2_len);
	rslt_bin = search (c1, c2);			/* Do char string search */

	return;					/* End of search */



search_info:
     entry (ad_ptr, rslt_desc);

/* Info entry for the "search" builtin */
/* rslt_desc = 0 or FIXED_BIN_24 */

	if arg_descs.ndescs ^= 2 then
	     rslt_desc = "0"b;			/* need exactly 2 args */
	else /* check for string args */
	     if ^mu_data_class$character_data_class (addr (arg_descs.desc (1))) |
		/* If arg types are not char */
		^mu_data_class$character_data_class (addr (arg_descs.desc (2)))
	then rslt_desc = "0"b;
	else rslt_desc = FIB24_DESC;			/* have 2 string args */

	return;					/* end of search info entry */

substr:
     entry;

/* This entry implements the MRDS/LINUS "substr" builtin function.  This function
   accepts either the two argument form "substr (string, starting_pos)" or the three
   argument form "substr (string, starting_pos, len)" of sub-string.
   If the input string is a bit string the returned value is a varying bit string.
   If the input string is a character string the returned value is a
   varying character string. Returned result is either bit varying or char varying string.
   The PL/I "substr" builtin is used to actually perform the function. */


/* BEGIN CHANGE 81-08-14 RDL ********************************************** */

	a1_ptr = addr (buffer1);

/* END CHANGE 81-08-14 RDL ********************************************** */

	call cu_$arg_list_ptr (al_ptr);		/* Get pointer to argument list */
	num_ptrs = arg_list.arg_count;		/* CHANGE 81-09-21 */
	nargs = arg_list.arg_count / 2;		/* Number of arguments passed */
						/* If nargs = 3   form is substr (string, starting_pos)
						   If nargs = 4   form is substr (string, starting_pos, len) */
	r_ptr = addrel (arg_list.arg_des_ptr (nargs), -1);/* Set return value pointer to last argument */
	r_len =
	     fixed (string (arg_list.arg_des_ptr (nargs + 1) -> descriptor.size),
	     24);					/* Max length of return string
						   can be no longer then length of input string (arg (1)) */

	if mu_data_class$bit_data_class (arg_list.arg_des_ptr (nargs + 1)) then
	     /* String type is bit */
	     call canon_bit (1, a1_ptr, a1_len);	/* Canonize to bit. var. */
	else /* String type is character */
	     call canon_char (1, a1_ptr, a1_len);	/* Canonize to char. var. */

	call
	     conv_to_fixed_bin_24 (arg_list.arg_des_ptr (2),
	     arg_list.arg_des_ptr (nargs + 2), starting_pos); /* Convert
						   starting position to fixed bin (24,0) */

/* BEGIN CHANGE 81-09-23 ****************************** */

	if nargs = 4 then do;
		call conv_to_fixed_bin_24 /* Convert len to fixed bin (24, 0) */
		     (arg_list.arg_des_ptr (3),
		     arg_list.arg_des_ptr (nargs + 3), len);
		if len > a1_len - starting_pos + 1	/* if too many characters are */
		then len = a1_len - starting_pos + 1;	/* requested cut it down */
	     end;

/* END   CHANGE 81-09-23 ****************************** */

	else len = a1_len - starting_pos + 1;
	if starting_pos > a1_len | starting_pos < 1 | len < 1 then do;
		if mu_data_class$bit_data_class (arg_list.arg_des_ptr (nargs + 1)) then
		     rslt_bit_string = ""b;
		else rslt_char_string = "";
	     end;
	else do;
		if mu_data_class$bit_data_class (arg_list.arg_des_ptr (nargs + 1)) then
		     rslt_bit_string = substr (b1, starting_pos, len);
						/* Do the SUBSTR */
		else rslt_char_string = substr (c1, starting_pos, len);
						/* Do the SUBSTR */
	     end;

	return;					/* End of substr */

substr_info:
     entry (ad_ptr, rslt_desc);

/* Info entry for the "substr" builtin */
/* rslt_desc = 0 or BIT_VAR_DESC or CHAR_VAR_DESC */

	rslt_desc = arg_descs.desc (1);		/* Initialize it to a non-zero value */

	if arg_descs.ndescs < 2 | arg_descs.ndescs > 3 then
	     rslt_desc = "0"b;			/* Wrong number of argsuments */

	else
	     do j = 2 to (arg_descs.ndescs);		/* Are the lengths valid for converstion? */
						/* descritors will be character unless argument */
						/* is result of another expression */
		if ^mu_data_class$real_data_class (addr (arg_descs.desc (j)))
		     & ^mu_data_class$string_data_class (addr (arg_descs.desc (j))) then
		     rslt_desc = "0"b;
	     end;

	if ^(mu_data_class$string_data_class (addr (arg_descs.desc (1))))
						/* First arg must be a string */
	then rslt_desc = "0"b;

	if rslt_desc ^= "0"b then do;			/* If everything was ok then set the rslt desc */

		if addr (arg_descs.desc (1)) -> descriptor.type < 21 then
		     rslt_desc = BIT_VAR_DESC;	/* Bit varying */
		else rslt_desc = CHAR_VAR_DESC;	/* Char varying */

		addr (rslt_desc) -> descriptor.size =
		     addr (arg_descs.desc (1)) -> descriptor.size; /* Result cannot
						   be any larger then input string length */
	     end;

	return;					/* end of substr info entry */

verify:
     entry;

/* This entry implements the MRDS/LINUS "verify" builtin function.  This is
   a string function, so arithmetic arguments are not accepted.
   The PL/I "verify" builtin is used to actualy perform the function.
   Returned result is a fixed bin (24). */


/* BEGIN CHANGE 81-08-14 RDL ********************************************** */

	a1_ptr = addr (buffer1);
	a2_ptr = addr (buffer2);

/* END CHANGE 81-08-14 RDL ********************************************** */

	call cu_$arg_list_ptr (al_ptr);		/* get pointer to arg list */
	num_ptrs = arg_list.arg_count;		/* CHANGE 81-09-21 */
	r_ptr = arg_list.arg_des_ptr (3);		/* point to place to store result */

	call canon_char (1, a1_ptr, a1_len);
	call canon_char (2, a2_ptr, a2_len);
	rslt_bin = verify (c1, c2);			/* Do char string verify */


	return;					/* End of verify */



verify_info:
     entry (ad_ptr, rslt_desc);

/* Info entry for the "verify" builtin */
/* rslt_desc = 0 or fixed bin (24) */

	if arg_descs.ndescs ^= 2 then
	     rslt_desc = "0"b;			/* need exactly 2 args */
	else /* check for string args */
	     if ^mu_data_class$character_data_class (addr (arg_descs.desc (1))) |
		/* If arg types are not char */
		^mu_data_class$character_data_class (addr (arg_descs.desc (2)))
	then rslt_desc = "0"b;

	else rslt_desc = FIB24_DESC;			/* have 2 string args */

	return;					/* end of verify info entry */

fatal_func_error:
     proc;

	signal fatal_func_err;

     end fatal_func_error;

canon_bit:
     proc (arg_index, b_ptr, b_len);

/* Procedure to canonize bit args into bit varying */

	dcl     arg_index		 fixed bin;
	dcl     b_len		 fixed bin (35);
	dcl     (
	        b_ptr,
	        a_ptr		 init (null),
	        d_ptr		 init (null)
	        )			 ptr;
	dcl     bnv		 bit (b_len) based (a_ptr);
	dcl     bv		 bit (b_len) var based (b_ptr);
	dcl     fb35		 fixed bin (35) based;

	a_ptr = arg_list.arg_des_ptr (arg_index);	/* pick up arg and desc ptrs */
	d_ptr = arg_list.arg_des_ptr (arg_index + arg_list.arg_count / 2);

	if d_ptr -> descriptor.type = BIT_VAR then do;	/* no conv., merely set ptrs */
		b_ptr = addrel (a_ptr, -1);		/* Include length field */
		b_len = b_ptr -> fb35;
	     end;
	else do;					/* must convert to var. */
		b_len = fixed (string (d_ptr -> descriptor.size));
		bv = bnv;				/* convert */
	     end;

     end canon_bit;

canon_char:
     proc (arg_index, c_ptr, c_len);

/* procedure to canonize character or bit string arguments into char. varying */

	dcl     arg_index		 fixed bin;
	dcl     c_len		 fixed bin (35);
	dcl     (
	        c_ptr,
	        a_ptr		 init (null),
	        d_ptr		 init (null)
	        )			 ptr;
	dcl     bnv		 bit (c_len) based (a_ptr);
	dcl     bv		 bit (c_len) var based (bv_ptr);
	dcl     bv_ptr		 ptr init (null);
	dcl     cnv		 char (c_len) based (a_ptr);
	dcl     cv		 char (c_len) var based (c_ptr);
	dcl     fb35		 fixed bin (35) based;

	a_ptr = arg_list.arg_des_ptr (arg_index);	/* pick up arg and desc ptrs */
	d_ptr = arg_list.arg_des_ptr (arg_index + arg_list.arg_count / 2);

	if d_ptr -> descriptor.type = CHAR_VAR then do;	/* already char var, merely set pointers */
		c_ptr = addrel (a_ptr, -1);		/* Include length field */
		c_len = c_ptr -> fb35;
	     end;
	else do;					/* must convert */
		c_len = fixed (string (d_ptr -> descriptor.size));
		if d_ptr -> descriptor.type = CHAR then
		     cv = cnv;
		else if d_ptr -> descriptor.type = BIT then
		     cv = char (bnv);
		else do;
			bv_ptr = addrel (a_ptr, -1);
			cv = char (bv);
		     end;
	     end;

     end canon_char;

(size, conversion):
conv_to_fixed_bin_24:
     proc (s_ptr, s_desc_ptr, val);

/* This procedure converts a non-complex value to
   a fixed binary (24,0) value returned as val. The input parameters are a pointer to
   the source value (s_ptr), a pointer to the source descriptor (s_desc_ptr), and the
   returned value (val).
*/

/*	PARAMETERS	*/

	dcl     s_ptr		 ptr;		/* Pointer to the source item */
	dcl     s_desc_ptr		 ptr;		/* Pointer to the source item descriptor */
	dcl     val		 fixed bin (24, 0); /* Returned value */

/*	OTHERS	*/

	dcl     assign_
				 entry (ptr, fixed bin, fixed bin (35), ptr, fixed bin, fixed bin (35));
	dcl     s_type		 fixed bin;	/* Source item type for assign_ */
	dcl     s_len		 fixed bin (35);	/* Source item length for assign_ */
	dcl     t_ptr		 ptr init (null);	/* Pointer to target item for assign_ */
	dcl     t_type		 fixed bin;	/* Target item type for assign_ */
	dcl     t_len		 fixed bin (35);	/* Target item lenth for assigh_ */

Start:
	t_ptr = addr (val);
	t_len = 24;				/* Scale = 0 precision = 24 */
	t_type = 2;				/* 2*M + P where M = 1 and P = 0 */

	s_type =
	     (2 * s_desc_ptr -> descriptor.type)
	     + fixed (s_desc_ptr -> descriptor.packed);
	s_len =
	     fixed (s_desc_ptr -> descriptor.size.scale || "000000"b
	     || s_desc_ptr -> descriptor.size.precision);

	call assign_ (t_ptr, t_type, t_len, s_ptr, s_type, s_len);

	return;

     end conv_to_fixed_bin_24;

(size, conversion):
conv_to_float_dec_59:
     proc (s_ptr, s_desc_ptr, val);

/* This procedure canonizes non-complex arithmetic values to float decimal (59).
   The input parameters are a pointer to the source value (s_ptr), a pointer to the source descriptor (s_desc_ptr),
   and the returned value (val). */

/*	PARAMETERS	*/

	dcl     s_ptr		 ptr;		/* Pointer to the source item */
	dcl     s_desc_ptr		 ptr;		/* Pointer to the source item descriptor */
	dcl     val		 float decimal (59);/* Returned value */

/*	OTHERS	*/

	dcl     assign_
				 entry (ptr, fixed bin, fixed bin (35), ptr, fixed bin, fixed bin (35));
	dcl     s_type		 fixed bin;	/* Source item type for assign_ */
	dcl     s_len		 fixed bin (35);	/* Source item length for assign_ */
	dcl     t_ptr		 ptr init (null);	/* Pointer to target item for assign_ */
	dcl     t_type		 fixed bin;	/* Target item type for assign_ */
	dcl     t_len		 fixed bin (35);	/* Target item lenth for assigh_ */

Start:
	t_ptr = addr (val);
	t_len = 59;
	t_type = 20;				/* 2*M + P where M = 10 and P = 0 */

	s_type =
	     (2 * s_desc_ptr -> descriptor.type)
	     + fixed (s_desc_ptr -> descriptor.packed);
	s_len =
	     fixed (s_desc_ptr -> descriptor.size.scale || "000000"b
	     || s_desc_ptr -> descriptor.size.precision);

	call assign_ (t_ptr, t_type, t_len, s_ptr, s_type, s_len);

	return;

     end conv_to_float_dec_59;

(size, conversion):
conv_to_complex_float_dec_59:
     proc (s_ptr, s_desc_ptr, val);

/* This procedure canonizes complex arithmetic values to complex float decimal (59).
   The input parameters are a pointer to the source value (s_ptr), a pointer to the source descriptor (s_desc_ptr),
   and the returned value (val). */

/*	PARAMETERS	*/

	dcl     s_ptr		 ptr;		/* Pointer to the source item */
	dcl     s_desc_ptr		 ptr;		/* Pointer to the source item descriptor */
	dcl     val		 complex float decimal (59); /* Returned value */

/*	OTHERS	*/

	dcl     assign_
				 entry (ptr, fixed bin, fixed bin (35), ptr, fixed bin, fixed bin (35));
	dcl     s_type		 fixed bin;	/* Source item type for assign_ */
	dcl     s_len		 fixed bin (35);	/* Source item length for assign_ */
	dcl     t_ptr		 ptr init (null);	/* Pointer to target item for assign_ */
	dcl     t_type		 fixed bin;	/* Target item type for assign_ */
	dcl     t_len		 fixed bin (35);	/* Target item lenth for assigh_ */

Start:
	t_ptr = addr (val);
	t_len = 59;
	t_type = 24;				/* 2*M + P where M = 12 and P = 0 */

	s_type =
	     (2 * s_desc_ptr -> descriptor.type)
	     + fixed (s_desc_ptr -> descriptor.packed);
	s_len =
	     fixed (s_desc_ptr -> descriptor.size.scale || "000000"b
	     || s_desc_ptr -> descriptor.size.precision);

	call assign_ (t_ptr, t_type, t_len, s_ptr, s_type, s_len);

	return;

     end conv_to_complex_float_dec_59;

%include mdbm_arg_list;
%page;
%include mdbm_descriptor;

	dcl     (
	        a1_ptr		 init (null),	/* arg pointers */
	        a2_ptr		 init (null),
	        r_ptr		 init (null),	/* pointer to function result */
	        ad_ptr				/* Input:  points to structure containing input descrips. */
	        )			 ptr;		/* pointer to work area */

	dcl     (
	        a1_len,				/* string lengths for args */
	        a2_len
	        )			 fixed bin (35);

	dcl     (
	        starting_pos,			/* Starting position for substr */
	        r_len,				/* Length of bit or char resultant string */
	        s1,
	        s2,
	        n,
	        len
	        )			 fixed bin (24);	/* Length or extent of substr */

	dcl     c1		 char (a1_len) var based (a1_ptr); /* canonized char args */
	dcl     c2		 char (a2_len) var based (a2_ptr);
	dcl     b1		 bit (a1_len) var based (a1_ptr); /* canonized bit args */
	dcl     b2		 bit (a2_len) var based (a2_ptr);
	dcl     (fld_val_1, fld_val_2, q) float decimal (59);
	dcl     rslt_desc		 bit (36) aligned;	/* Output: result descriptor */
	dcl     rslt_bin		 fixed bin (24) based (r_ptr); /* fixed bin results */
	dcl     rslt_bit_string	 bit (r_len) varying based (r_ptr); /* Bit string result */
	dcl     rslt_char_string	 char (r_len) varying based (r_ptr); /* Char string result */
	dcl     rslt_fld_59		 float decimal (59) based (r_ptr);
	dcl     1 rslt_cfld_59	 based (r_ptr),
		2 real		 float decimal (59) aligned,
		2 imag		 float decimal (59) aligned;

	dcl     alloc_array		 (mrds_data_$max_builtin_args) ptr
				 init ((mrds_data_$max_builtin_args) null); /* place to store pointers to allocated items */
	dcl     (nargs, j)		 fixed bin;


	dcl     1 arg_descs		 aligned based (ad_ptr), /* input descriptors for info entries */
		2 ndescs		 fixed bin,
		2 desc		 (0 refer (arg_descs.ndescs)) bit (36);



	dcl     FIB24_DESC		 bit (36) aligned int static options (constant)
				 init ("100000100000000000000000000000011000"b); /* Fixed bin (24) descriptor */
	dcl     CHAR_VAR_DESC	 bit (36) aligned int static options (constant)
				 init ("101011000000000000000000000000000000"b); /* Character varying descriptor */
	dcl     BIT_VAR_DESC	 bit (36) aligned int static options (constant)
				 init ("101010000000000000000000000000000000"b); /* Bit varying descriptor */
	dcl     FLD59_DESC		 bit (36) aligned int static options (constant)
				 init ("100101000000000000000000000000111011"b); /* Float decimal (59) descriptor */
	dcl     CFLD59_DESC		 bit (36) aligned int static options (constant)
				 init ("100110010000000000000000000000111011"b); /* Complex Float decimal (59) descriptor */

	dcl     cmplx_fld_59_val	 complex float decimal (59);

	dcl     (
	        CHAR		 init (21),
	        BIT		 init (19),
	        CHAR_VAR		 init (22),
	        BIT_VAR		 init (20)
	        )			 fixed bin (5) int static options (constant);

	dcl     (
	        mrds_data_$max_builtin_args,
	        mrds_data_$max_string_size
	        )			 fixed bin (35) ext;

	dcl     (conversion, size, fatal_func_err) condition;


	dcl     (abs, addr, addrel, after, before, bit, ceil, char, divide, fixed, floor,
	        imag, index, log10, mod, null, real, reverse, search, sign, string, substr,
	        verify)		 builtin;

	dcl     cu_$arg_list_ptr	 entry (ptr);


	dcl     (
	        mu_data_class$real_data_class,
	        mu_data_class$complex_data_class,
	        mu_data_class$fixed_data_class,
	        mu_data_class$string_data_class,
	        mu_data_class$convertible_data_class,
	        mu_data_class$bit_data_class,
	        mu_data_class$character_data_class
	        )			 entry (ptr) returns (bit (1) aligned); /* determines if descriptor pointed to
						   describes a data item in the class
						   that the entry point refers to */



	dcl     area_ptr		 ptr init (null ());
	dcl     (buffer1, buffer2)	 char (2 * mrds_data_$max_string_size + 4);



     end mrds_builtin_;
