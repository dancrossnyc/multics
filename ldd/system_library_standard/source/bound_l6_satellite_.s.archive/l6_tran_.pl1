/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   *********************************************************** */
/******************************************************************************/
/*							        */
/*   DESCRIPTION:						        */
/*							        */
/*        This subroutine is the NASP (see MTB 538) which implements file     */
/*   transfer to the Level 6 over an X.25 channel.		        */
/*							        */
/*							        */
/*   JOURNALIZATION:					        */
/*							        */
/*   1) Written 3/82 by R.J.C Kissel				        */
/*   2) Modified 7/83 by R.J.C. Kissel to handle passwords for Mod 400        */
/*      Release 21. and 3.0, and also fix an error message to the L6.	        */
/*   3) Modified 9/83 by R.J.C. Kissel to fix a bug in handling L6 pathnames. */
/*							        */
/******************************************************************************/

/* format: style3,linecom,ifthenstmt,indthenelse,^indnoniterdo,indnoniterend,initcol3,dclind5,idind32 */

l6_tran_:
     proc ();
RETURN:						/* Label for error returns. */
	return;

/* Parameters */

dcl  P_arg_list_ptr		       ptr parameter;
dcl  P_area_ptr		       ptr parameter;	/* Null means use the system free area. */
dcl  P_caller_name		       char (*) parameter;
dcl  P_code		       fixed bin (35) parameter;
dcl  P_complete		       bit (1) parameter;	/* "1"b -- request is complete, "0"b -- not complete */
dcl  P_error_message	       char (*) varying parameter;
dcl  P_first_arg		       fixed bin parameter;
dcl  P_in_iocbp		       ptr parameter;
dcl  P_list_flag		       bit (1) parameter;	/* "1"b -- list this request, "0"b -- don't list it */
dcl  P_nasp_info_ptr	       ptr parameter;
dcl  P_output_lines		       char (*) varying parameter;
dcl  P_out_iocbp		       ptr parameter;
dcl  P_queued_flag		       bit (1) parameter;	/* "1"b -- request from queue, "0"b -- interactive request */
dcl  P_structure_len	       fixed bin (24) parameter;
						/* In bits */
dcl  P_structure_ptr	       ptr parameter;
dcl  P_unhold		       bit (1) parameter;	/* "1"b -- update held requests, "0"b -- don't update them */

/* Automatic */

dcl  1 auto_status_branch	       aligned like status_branch;
dcl  1 auto_transfer_input_args      aligned like transfer_input_args;
dcl  1 auto_transfer_output_args     aligned like transfer_output_args;

dcl  arg			       char (arg_len) based (arg_ptr);
dcl  arg_idx		       fixed bin;
dcl  arg_len		       fixed bin (21);
dcl  arg_ptr		       ptr;
dcl  arg_list_ptr		       ptr;

dcl  based_area		       area (sys_info$max_seg_size) based (area_ptr);
dcl  area_ptr		       ptr;

dcl  caller_name		       char (32);
dcl  Cleanup_Handler	       entry () variable;
dcl  code			       fixed bin (35);

dcl  comm_buffer		       char (comm_buffer_len) based (comm_buffer_ptr);
dcl  comm_buffer_len	       fixed bin (21);
dcl  comm_buffer_ptr	       ptr defined (temp_seg_ptrs (1));

dcl  complete_flag		       bit (1);

dcl  file_buffer		       char (file_buffer_len) based (file_buffer_ptr);
dcl  file_buffer_len	       fixed bin (21);
dcl  file_buffer_ptr	       ptr defined (temp_seg_ptrs (2));

dcl  first_arg		       fixed bin;
dcl  i			       fixed bin;
dcl  ignored_len		       fixed bin (21);	/* Used in calls to ioa_$rsnnl. */
dcl  in_iocbp		       ptr;
dcl  last_file		       bit (1);

dcl  level_6_attach_desc	       char (128) varying;
dcl  level_6_chars_read	       fixed bin (21);
dcl  level_6_chars_to_write	       fixed bin (21);
dcl  level_6_data_type	       fixed bin;
dcl  level_6_dir		       char (168);
dcl  level_6_entry		       char (32);
dcl  level_6_file_type	       fixed bin;
dcl  level_6_iocbp		       ptr;
dcl  level_6_max_record_size	       fixed bin;
dcl  level_6_pathname	       char (168);
dcl  level_6_response_pathname       char (168);

dcl  list_flag		       bit (1);

dcl  multics_chars_read	       fixed bin (21);
dcl  multics_chars_to_write	       fixed bin (21);
dcl  multics_dir		       char (168);
dcl  multics_entry		       char (32);

dcl  multics_file_attach_desc	       char (256) varying;
dcl  multics_file_block_size	       fixed bin (21);
dcl  multics_file_iocbp	       ptr;
dcl  multics_file_l6_type	       fixed bin;
dcl  multics_file_type	       fixed bin;
dcl  multics_file_open_mode	       fixed bin;
dcl  multics_file_size	       fixed bin (34);

dcl  multics_is_sender	       bit (1);
dcl  multics_pathname	       char (168);

dcl  number_of_args		       fixed bin;
dcl  output_lines		       char (256) varying;
dcl  out_iocbp		       ptr;
dcl  queued_flag		       bit (1);
dcl  saved_attributes	       char (256) varying;
dcl  saved_level_6_entry	       char (32);
dcl  saved_multics_entry	       char (32);
dcl  star_area_ptr		       ptr;
dcl  star_entries_index	       fixed bin;
dcl  star_names_generated	       bit (1);
dcl  suffix		       char (32);
dcl  temp_seg_ptrs		       (2) ptr;
dcl  total_time		       fixed bin (71);
dcl  unhold_flag		       bit (1);

dcl  1 info		       aligned like indx_info;/* Use the biggest structure. */

/* The l6_tran_ shared structure */

dcl  l6tip		       ptr;
dcl  l6_tran_info_v1	       fixed bin (35) internal static options (constant) init (1);

dcl  1 l6_tran_info		       aligned based (l6tip),
       2 version		       fixed bin (35),
       2 sender_info	       aligned,
         3 pathname		       char (168) unaligned,
         3 host_name	       char (32) unaligned,
       2 receiver_info	       aligned,
         3 pathname		       char (168) unaligned,
         3 host_name	       char (32) unaligned,
       2 net_name		       char (32) unaligned,	/* Really the channel name. */
       2 net_address	       char (32) unaligned,	/* The call data for an x.25 channel. */
       2 multics_data_type	       fixed bin,		/* 1--ascii, 2--binary, 3--bcd */
       2 user_name		       char (32) unaligned,
       2 password		       char (12) unaligned,
       2 flags		       aligned,
         3 long		       bit (1) unaligned,	/* "1"b--print a transfer message, "0"b--don't print it */
         3 l6_attended	       bit (1) unaligned,	/* "1"b--no login needed, "0"b--login needed */
         3 pad		       bit (34) unaligned;

/* Internal Static */

dcl  debug_flag		       bit (1) internal static init ("0"b);

/* Internal Constants */

%include l6_tran_constants;

/* External Constants */

dcl  error_table_$area_too_small     fixed bin (35) ext static;
dcl  error_table_$bad_arg	       fixed bin (35) ext static;
dcl  error_table_$bad_file	       fixed bin (35) ext static;
dcl  error_table_$badopt	       fixed bin (35) ext static;
dcl  error_table_$badpath	       fixed bin (35) ext static;
dcl  error_table_$badstar	       fixed bin (35) ext static;
dcl  error_table_$dirseg	       fixed bin (35) ext static;
dcl  error_table_$fatal_error	       fixed bin (35) ext static;
dcl  error_table_$incompatible_file_attribute
			       fixed bin (35) ext static;
dcl  error_table_$noarg	       fixed bin (35) ext static;
dcl  error_table_$not_closed	       fixed bin (35) ext static;
dcl  error_table_$not_detached       fixed bin (35) ext static;
dcl  error_table_$too_many_args      fixed bin (35) ext static;
dcl  error_table_$unimplemented_version
			       fixed bin (35) ext static;

dcl  sys_info$max_seg_size	       fixed bin (19) ext static;

/* External Entries */

dcl  add_char_offset_	       entry (ptr, fixed bin (21)) returns (ptr) reducible;
dcl  check_star_name_$entry	       entry (char (*), fixed bin (35));
dcl  cu_$arg_list_ptr	       entry (ptr);
dcl  cu_$arg_ptr		       entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
dcl  cu_$arg_count		       entry (fixed bin, fixed bin (35));
dcl  cu_$arg_count_rel	       entry (fixed bin, ptr, fixed bin (35));
dcl  cu_$arg_ptr_rel	       entry (fixed bin, ptr, fixed bin (21), fixed bin (35), ptr);
dcl  expand_pathname_	       entry (char (*), char (*), char (*), fixed bin (35));
dcl  get_equal_name_	       entry (char (*), char (*), char (32), fixed bin (35));
dcl  get_user_free_area_	       entry returns (ptr);
dcl  get_temp_segments_	       entry (char (*), (*) ptr, fixed bin (35));
dcl  hcs_$append_branch	       entry (char (*), char (*), fixed bin (5), fixed bin (35));
dcl  hcs_$star_		       entry (char (*), char (*), fixed bin (2), ptr, fixed bin, ptr, ptr, fixed bin (35));
dcl  hcs_$status_		       entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35));
dcl  ioa_$ioa_switch	       entry () options (variable);
dcl  ioa_$general_rs	       entry (ptr, fixed bin, fixed bin, char (*), fixed bin (21), bit (1) aligned,
			       bit (1) aligned);
dcl  ioa_$rsnnl		       entry () options (variable);
dcl  ioa_$rsnpnnl		       entry options (variable);
dcl  l6_tran_util_$get_chars	       entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
dcl  l6_tran_util_$get_line	       entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
dcl  l6_tran_util_$put_chars	       entry (ptr, ptr, fixed bin (21), fixed bin (35));
dcl  l6_tran_receive_file_	       entry (ptr, ptr, char (*) var, fixed bin (35));
dcl  l6_tran_send_file_	       entry (ptr, ptr, char (*) var, fixed bin (35));
dcl  match_star_name_	       entry (char (*), char (*), fixed bin (35));
dcl  net_info_table_$get_host_address
			       entry (char (*), char (*), char (*), fixed bin (35));
dcl  pathname_		       entry (char (*), char (*)) returns (char (168));
dcl  read_password_$switch	       entry (ptr, ptr, char (*), char (*), fixed bin (35));
dcl  release_temp_segments_	       entry (char (*), (*) ptr, fixed bin (35));
dcl  suffixed_name_$make	       entry (char (*), char (*), char (32), fixed bin (35));
dcl  vfile_status_		       entry (char (*), char (*), ptr, fixed bin (35));
dcl  user_info_$whoami	       entry (char (*), char (*), char (*));

/* Builtin Functions and Conditions */

dcl  addr			       builtin;
dcl  before		       builtin;
dcl  clock		       builtin;
dcl  float		       builtin;
dcl  hbound		       builtin;
dcl  index		       builtin;
dcl  lbound		       builtin;
dcl  length		       builtin;
dcl  min			       builtin;
dcl  null			       builtin;
dcl  pointer		       builtin;
dcl  reverse		       builtin;
dcl  rtrim		       builtin;
dcl  string		       builtin;
dcl  substr		       builtin;
dcl  sum			       builtin;
dcl  unspec		       builtin;

dcl  area			       condition;
dcl  cleanup		       condition;

/* Include Files */

%include nasp_info;

%include l6_tran_transfer_args;

/* vfs_info.incl.pl1 */

%include vfs_info;

%include access_mode_values;

%include status_structures;

%include iox_entries;

%include iox_modes;

%include star_structures;

/******************************************************************************/
/*							        */
/*   ENTRY: parser						        */
/*							        */
/*        This entry is in charge of taking the user's command line arguments */
/*   and building a structure that describes the work to be done.  This       */
/*   structure is used by the other entries so they know what to do.  This    */
/*   entry may ask the user questions if it needs more information.	        */
/*							        */
/******************************************************************************/

parser:
     entry (P_in_iocbp, P_out_iocbp, P_caller_name, P_arg_list_ptr, P_first_arg, P_queued_flag, P_area_ptr,
	P_structure_ptr, P_structure_len, P_error_message, P_code);

	in_iocbp = P_in_iocbp;
	out_iocbp = P_out_iocbp;
	caller_name = P_caller_name;
	arg_list_ptr = P_arg_list_ptr;
	first_arg = P_first_arg;
	queued_flag = P_queued_flag;
	area_ptr = P_area_ptr;

	Cleanup_Handler = Parser_Cleanup;
	l6tip = null ();
	level_6_iocbp = null ();			/* No messages for the L6 from parser. */

	on cleanup call Cleanup_Handler ();

/* Make a quick check, since we currently only support interactive request. */

	if queued_flag
	     then call ERROR (error_table_$unimplemented_version, "Only interactive requests are currently supported.");

	if area_ptr = null () then call ERROR (error_table_$bad_arg, "An area pointer must be specified.");

/* Allocate the shared structure and parse the command line arguments. */

	on area call ERROR (error_table_$area_too_small, "Attempting to allocate the l6_tran_info structure.");

	allocate l6_tran_info in (based_area);

	revert area;

	l6_tran_info.version = l6_tran_info_v1;
	l6_tran_info.sender_info = "";
	l6_tran_info.receiver_info = "";
	l6_tran_info.net_name = "";			/* Default */
	l6_tran_info.multics_data_type = ASCII;		/* Default */

	call user_info_$whoami (l6_tran_info.user_name, "", "");
						/* Set the default. */

	l6_tran_info.password = "";
	l6_tran_info.flags = "0"b;			/* Reset all of them. */
	l6_tran_info.flags.long = "1"b;		/* Default */

	call cu_$arg_count_rel (number_of_args, arg_list_ptr, code);
	if code ^= 0 then call ERROR (code);

	if number_of_args - first_arg + 1 < 4 then call ERROR (error_table_$noarg, "^/^a.", USAGE);

	if number_of_args - first_arg + 1 > 11 then call ERROR (error_table_$too_many_args, "^/^a.", USAGE);

	do arg_idx = first_arg to number_of_args;	/* Process the arguments. */

	     call cu_$arg_ptr_rel (arg_idx, arg_ptr, arg_len, code, arg_list_ptr);
	     if code ^= 0 then call ERROR (code, "Trying to get argument: ^d.", arg_idx);

	     if index (arg, "-") ^= 1
		then call Process_File_Name ();

		else do;				/* Process a control arg. */

		     if arg = "-name" | arg = "-nm"
			then do;
			     arg_idx = arg_idx + 1;

			     call cu_$arg_ptr_rel (arg_idx, arg_ptr, arg_len, code, arg_list_ptr);
			     if code ^= 0 then call ERROR (code, "Trying to get the name after a -name argument.");

			     call Process_File_Name ();
			     end;

		     else if arg = "-data_type"
			then do;
			     arg_idx = arg_idx + 1;
			     call cu_$arg_ptr_rel (arg_idx, arg_ptr, arg_len, code, arg_list_ptr);
			     if code ^= 0 then call ERROR (code, "Trying to get the data type.");

			     if arg = "ascii" | arg = "ASCII" then l6_tran_info.multics_data_type = ASCII;
			     else if arg = "binary" | arg = "BINARY" then l6_tran_info.multics_data_type = BINARY;
			     else if arg = "bcd" | arg = "BCD" then l6_tran_info.multics_data_type = BCD;
			     else call ERROR (error_table_$bad_arg, "Unrecognized data type: ^a.", arg);
			     end;

		     else if arg = "-long" | arg = "-lg" then l6_tran_info.flags.long = "1"b;

		     else if arg = "-brief" | arg = "-bf" then l6_tran_info.flags.long = "0"b;

		     else if arg = "-attended" | arg = "-att" then l6_tran_info.flags.l6_attended = "1"b;

		     else if arg = "-not_attended" | arg = "-natt" then l6_tran_info.flags.l6_attended = "0"b;

		     else if arg = "-user"
			then do;
			     arg_idx = arg_idx + 1;
			     call cu_$arg_ptr_rel (arg_idx, arg_ptr, arg_len, code, arg_list_ptr);
			     if code ^= 0 then call ERROR (code, "Trying to get the user argument.");

			     l6_tran_info.user_name = arg;
			     end;

		     else if arg = "-password" | arg = "-pw"
			then do;
			     arg_idx = arg_idx + 1;
			     call cu_$arg_ptr_rel (arg_idx, arg_ptr, arg_len, code, arg_list_ptr);
			     if code ^= 0 then call ERROR (code, "Trying to get the password argument.");

			     l6_tran_info.password = arg;
			     end;

		     else if arg = "-network" | arg = "-net"
			then do;
			     arg_idx = arg_idx + 1;
			     call cu_$arg_ptr_rel (arg_idx, arg_ptr, arg_len, code, arg_list_ptr);
			     if code ^= 0 then call ERROR (code, "Trying to get the network (channel) argument.");

			     l6_tran_info.net_name = arg;
			     end;

		     else call ERROR (error_table_$badopt, "Argument: ^a.", arg);
		     end;				/* Process a control arg. */

	end;					/* Process the arguments. */

/* Make some checks to make sure we have everything we need. */

	if l6_tran_info.sender_info.pathname = ""
	     then call ERROR (error_table_$noarg, "A source pathname must be specified.");

	if l6_tran_info.receiver_info.pathname = ""
	     then call ERROR (error_table_$noarg, "A destination pathname must be specified.");

	if l6_tran_info.sender_info.host_name ^= "" & l6_tran_info.receiver_info.host_name ^= ""
	     then call ERROR (error_table_$too_many_args,
		     "Only one file name may have a host specified with the ""-at"" argument.");

	if l6_tran_info.net_name = ""
	     then call ERROR (error_table_$noarg, "A network name (X.25 channel name) must be specified.");

	if l6_tran_info.sender_info.host_name ^= ""
	     then call net_info_table_$get_host_address (l6_tran_info.sender_info.host_name, l6_tran_info.net_name,
		     l6_tran_info.net_address, code);
	     else call net_info_table_$get_host_address (l6_tran_info.receiver_info.host_name, l6_tran_info.net_name,
		     l6_tran_info.net_address, code);

	if code ^= 0
	     then call ERROR (code, "Unrecognized host: ^[^a^;^a^].", l6_tran_info.sender_info.host_name ^= "",
		     l6_tran_info.sender_info.host_name, l6_tran_info.receiver_info.host_name);

	if l6_tran_info.net_address = ""
	     then call ERROR (error_table_$noarg,
		     "Either the source or destination file must specify the ""-at"" argument with a host name (address)."
		     );


	P_structure_ptr = l6tip;
	P_structure_len = length (unspec (l6_tran_info)); /* Length in bits. */
	P_error_message = "";
	P_code = 0;

	return;

/******************************************************************************/
/*							        */
/*   ENTRY: execute						        */
/*							        */
/*        This entry is in charge of doing the actual work for a L6 file      */
/*   transfer.  It uses the structure built by the parser entry to find out   */
/*   what to do.  It may communicate with the user or operator to clarify     */
/*   operations in some cases.				        */
/*							        */
/******************************************************************************/

execute:
     entry (P_in_iocbp, P_out_iocbp, P_caller_name, P_queued_flag, P_structure_ptr, P_structure_len, P_complete, P_unhold,
	P_error_message, P_code);

	in_iocbp = P_in_iocbp;
	out_iocbp = P_out_iocbp;
	caller_name = P_caller_name;
	queued_flag = P_queued_flag;
	l6tip = P_structure_ptr;

/* Set things up for the cleanup handler. */

	Cleanup_Handler = Execute_Cleanup;
	status_area_ptr = null ();
	status_ptr = null ();
	auto_status_branch.nnames = 0;
	auto_status_branch.names_relp = "0"b;
	multics_file_iocbp = null ();
	level_6_iocbp = null ();
	file_buffer_ptr = null ();
	comm_buffer_ptr = null ();

	star_names_generated = "0"b;
	star_entry_ptr = null ();
	star_names_ptr = null ();
	star_area_ptr = null ();
	star_entry_count = 0;
	star_entries_index = 0;

	on cleanup call Cleanup_Handler ();

/* Find out who is sending, and get pathnames. */

	if l6_tran_info.sender_info.host_name = ""	/* A host name means the Level 6. */
	     then do;
		multics_is_sender = "1"b;
		multics_pathname = l6_tran_info.sender_info.pathname;
		level_6_pathname = l6_tran_info.receiver_info.pathname;
		end;

	     else do;
		multics_is_sender = "0"b;
		multics_pathname = l6_tran_info.receiver_info.pathname;
		level_6_pathname = l6_tran_info.sender_info.pathname;
		end;

	call expand_pathname_ (multics_pathname, multics_dir, saved_multics_entry, code);
	if code ^= 0 then call ERROR (code, "Trying to expand multics pathname: ^a.", multics_pathname);

	multics_pathname = pathname_ (multics_dir, saved_multics_entry);
						/* "Canonicalize" the pathname for vfile_. */
	multics_entry = saved_multics_entry;

	saved_level_6_entry = reverse (before (reverse (level_6_pathname), ">"));
	level_6_dir =
	     substr (level_6_pathname, 1, length (rtrim (level_6_pathname)) - length (rtrim (saved_level_6_entry)));
	level_6_entry = saved_level_6_entry;

/* Make some minimal syntax checks on the L6 pathname. */

	if multics_is_sender & (level_6_entry = "**" | index (substr (level_6_pathname, 2), "^") ^= 0)
	     then call ERROR (error_table_$badpath, "Invalid L6 pathname: ^a.", level_6_pathname);

/* Get temp segments for buffers for file IO and Level 6 IO. */

	call get_temp_segments_ ("l6_tran_", temp_seg_ptrs, code);
	if code ^= 0 then call ERROR (code, "Trying to get temp segs for I/O buffers.");

	comm_buffer_len = sys_info$max_seg_size * 4;
	file_buffer_len = sys_info$max_seg_size * 4;

/* Now do the real work.  We are always the initiator and the Level 6 is the acceptor. */

	if multics_is_sender
	     then do;				/* We are sending, and the file must exist. */
		call Open_L6_Connection ();

		if ^l6_tran_info.flags.l6_attended then call Login_Dialogue ();

		call OK_Dialogue ();

		last_file = "0"b;			/* Do the loop at least once. */
		do while (^last_file);

		     call Get_Next_Path (last_file);

		     info.info_version = vfs_version_1;
		     call vfile_status_ (multics_dir, multics_entry, addr (info), code);
		     if code ^= 0
			then call ERROR (code, "Trying to get vfile_status_ on: ^a, for sending.", multics_pathname)
				;

		     call Check_Multics_File ();

		     call Open_Multics_File ();

		     call Get_Saved_Attributes ();

		     call File_Definition_Dialogue ();

		     if l6_tran_info.flags.long
			then do;
			     total_time = clock ();
			     call ioa_$ioa_switch (out_iocbp,
				"Starting transfer of Multics file: ^a to Level 6 file: ^a.", multics_pathname,
				level_6_pathname);
			     end;

		     auto_transfer_input_args.version = transfer_input_args_version_1;
		     auto_transfer_input_args.comm_iocbp = level_6_iocbp;
		     auto_transfer_input_args.comm_buffer_ptr = comm_buffer_ptr;
		     auto_transfer_input_args.comm_buffer_len = comm_buffer_len;
		     auto_transfer_input_args.file_iocbp = multics_file_iocbp;
		     auto_transfer_input_args.file_buffer_ptr = file_buffer_ptr;
		     auto_transfer_input_args.file_buffer_len = file_buffer_len;
		     auto_transfer_input_args.file_type = multics_file_type;
		     auto_transfer_input_args.data_type = multics_data_type;
		     auto_transfer_input_args.tu_size = SEND_TU_SIZE;
		     auto_transfer_input_args.last_file = last_file;

		     auto_transfer_input_args.prompt_read = (level_6_chars_read ^= 0);
						/* Set in File_Definition_Dialogue. */

		     auto_transfer_output_args.version = transfer_output_args_version_1;

		     call l6_tran_send_file_ (addr (auto_transfer_input_args), addr (auto_transfer_output_args),
			P_error_message, P_code);
		     if P_code ^= 0
			then do;
			     call Cleanup_Handler ();
			     return;
			     end;

		     if l6_tran_info.flags.long
			then do;
			     total_time = clock () - total_time;
			     call ioa_$ioa_switch (out_iocbp,
				"Completed transfer of ^d records (^d bytes) in ^.3f seconds (^.3f bytes/sec).",
				auto_transfer_output_args.record_number + 1,
				auto_transfer_output_args.total_bytes, float (total_time) / 1e6,
				float (auto_transfer_output_args.total_bytes) / (float (total_time) / 1e6));
			     end;

		     call iox_$close (multics_file_iocbp, code);
		     call iox_$detach_iocb (multics_file_iocbp, code);
		     call iox_$destroy_iocb (multics_file_iocbp, code);

		end;				/* The last_file loop. */

/* "E" is not enough for the L6, send this too. */

		level_6_chars_to_write = length (" 005&");
		substr (comm_buffer, 1, level_6_chars_to_write) = " 005&";

		call l6_tran_util_$put_chars (level_6_iocbp, comm_buffer_ptr, level_6_chars_to_write, code);
						/* Ignore the code. */
		end;				/* We are sending, and the file must exist. */

	     else do;				/* We are receiving, and the file may or may not exist. */
		call Open_L6_Connection ();

		if ^l6_tran_info.flags.l6_attended then call Login_Dialogue ();

		call OK_Dialogue ();

		last_file = "0"b;			/* Loop at least once. */
		do while (^last_file);

		     level_6_response_pathname = "";	/* The L6 may tell us differently. */
		     call File_Definition_Dialogue ();

		     call Generate_Multics_Path ();

		     info.info_version = vfs_version_1;
		     call vfile_status_ (multics_dir, multics_entry, addr (info), code);

		     if code = 0
			then do;
			     call Check_Multics_File ();
			     call Verify_File_Attributes ();
			     end;

			else call Create_Multics_File ();

		     call Open_Multics_File ();

		     call Set_Saved_Attributes ();

		     if l6_tran_info.flags.long
			then do;
			     total_time = clock ();
			     call ioa_$ioa_switch (out_iocbp,
				"Starting transfer of Level 6 file: ^[^a^s^;^s^a^] to Multics file: ^a.",
				level_6_response_pathname ^= "", level_6_response_pathname, level_6_pathname,
				multics_pathname);
			     end;

		     auto_transfer_input_args.version = transfer_input_args_version_1;
		     auto_transfer_input_args.comm_iocbp = level_6_iocbp;
		     auto_transfer_input_args.comm_buffer_ptr = comm_buffer_ptr;
		     auto_transfer_input_args.comm_buffer_len = comm_buffer_len;
		     auto_transfer_input_args.file_iocbp = multics_file_iocbp;
		     auto_transfer_input_args.file_buffer_ptr = file_buffer_ptr;
		     auto_transfer_input_args.file_buffer_len = file_buffer_len;
		     auto_transfer_input_args.file_type = multics_file_type;
		     auto_transfer_input_args.data_type = multics_data_type;
		     auto_transfer_input_args.tu_size = RECV_TU_SIZE;

		     auto_transfer_output_args.version = transfer_output_args_version_1;

		     call l6_tran_receive_file_ (addr (auto_transfer_input_args), addr (auto_transfer_output_args),
			P_error_message, P_code);
		     if P_code ^= 0
			then do;
			     call Cleanup_Handler ();
			     return;
			     end;

		     last_file = auto_transfer_output_args.last_file;

		     if l6_tran_info.flags.long
			then do;
			     total_time = clock () - total_time;
			     call ioa_$ioa_switch (out_iocbp,
				"Completed transfer of ^d records (^d bytes) in ^.3f seconds (^.3f bytes/sec).",
				auto_transfer_output_args.record_number + 1,
				auto_transfer_output_args.total_bytes, float (total_time) / 1e6,
				float (auto_transfer_output_args.total_bytes) / (float (total_time) / 1e6));
			     end;

		     call iox_$close (multics_file_iocbp, code);
		     call iox_$detach_iocb (multics_file_iocbp, code);
		     call iox_$destroy_iocb (multics_file_iocbp, code);

		end;				/* The last_file loop. */
		end;				/* We are receiving, and the file may or may not exist. */

	call Cleanup_Handler ();

	P_complete = "1"b;
	P_unhold = "1"b;
	P_error_message = "";
	P_code = 0;

	return;
%page;
/******************************************************************************/
/*							        */
/*   These entries are not yet implemented.  We just want to document their   */
/*   calling sequences.					        */
/*							        */
/******************************************************************************/

cancel:
     entry (P_structure_ptr, P_structure_len, P_error_message, P_code);

	P_code = error_table_$unimplemented_version;
	return;
%skip (5);
modify:
     entry (P_in_iocbp, P_out_iocbp, P_caller_name, P_arg_list_ptr, P_first_arg, P_structure_ptr, P_structure_len,
	P_error_message, P_code);

	P_code = error_table_$unimplemented_version;
	return;
%skip (5);
list:
     entry (P_arg_list_ptr, P_first_arg, P_structure_ptr, P_structure_len, P_list_flag, P_output_lines, P_error_message,
	P_code);

	P_code = error_table_$unimplemented_version;
	return;
%skip (5);
info:
     entry (P_structure_ptr, P_structure_len, P_nasp_info_ptr, P_error_message, P_code);

	P_code = error_table_$unimplemented_version;
	return;

Check_Multics_File:
     proc ();

	multics_file_type = info.type;

	if multics_file_type > BLOCKED_FILE_TYPE
	     then call ERROR (error_table_$bad_file,
		     "The Multics file must be unstructured, sequential, or blocked.  File ^a is ^a.",
		     multics_pathname, FILE_TYPE_TO_PNAME (multics_file_type));

	if multics_file_type = BLOCKED_FILE_TYPE
	     then do;
		multics_file_block_size = blk_info.max_rec_len;
		multics_file_size = blk_info.end_pos;
		end;

	     else do;
		multics_file_block_size = 0;
		multics_file_size = 0;
		end;

	multics_file_l6_type = L6_S_FILE_TYPE;		/* This is the default. */

/* Now find out if the file is special by looking for the suffix we put on it. */

	status_area_ptr = get_user_free_area_ ();
	status_ptr = addr (auto_status_branch);

	call hcs_$status_ (multics_dir, multics_entry, CHASE, status_ptr, status_area_ptr, code);
	if code ^= 0 then call ERROR (code, "Trying to get status for: ^a.", multics_pathname);

	if status_branch.short.type = Directory then call ERROR (error_table_$dirseg, "^a.", multics_pathname);

	code = 1;					/* Go through the loop at least once. */
	do i = lbound (status_entry_names, 1) to hbound (status_entry_names, 1) while (code ^= 0);
	     call match_star_name_ ((status_entry_names (i)), "**.*.l6*", code);
	     if code = 0
		then do;
		     suffix = reverse (before (reverse (rtrim (status_entry_names (i))), "."));

		     do i = lbound (MULTICS_L6_FILE_SUFFIX, 1) to hbound (MULTICS_L6_FILE_SUFFIX, 1)
			while (suffix ^= MULTICS_L6_FILE_SUFFIX (i));
		     end;

		     if i > hbound (MULTICS_L6_FILE_SUFFIX, 1)
			then code = 1;		/* Keep looking. */
			else multics_file_l6_type = i;
		     end;
	end;

	if status_branch.nnames > 0 & status_branch.names_relp ^= "0"b
	     then free status_entry_names in (status_area_ptr -> based_area);
						/* Cleanup after ourselves. */

	if l6_tran_info.multics_data_type = BINARY & multics_file_type = UNSTRUCTURED_FILE_TYPE
	     then call ERROR (error_table_$incompatible_file_attribute,
		     "A binary file must be a sequential or blocked file: ^a.", multics_pathname);

	return;

     end Check_Multics_File;

Create_Multics_File:
     proc ();

	multics_file_l6_type = level_6_file_type;

	if level_6_file_type = L6_S_FILE_TYPE & level_6_data_type = ASCII
	     then multics_file_type = UNSTRUCTURED_FILE_TYPE;

	else if level_6_file_type = L6_S_FILE_TYPE then multics_file_type = SEQUENTIAL_FILE_TYPE;

	else multics_file_type = BLOCKED_FILE_TYPE;

	if multics_file_type = BLOCKED_FILE_TYPE
	     then do;
		if level_6_max_record_size = 0
		     then multics_file_block_size = 256;/* Set default. */
		     else multics_file_block_size = level_6_max_record_size;
		end;

	     else multics_file_block_size = 0;

	multics_file_size = 0;

	if MULTICS_L6_FILE_SUFFIX (multics_file_l6_type) ^= ""
	     then do;
		call suffixed_name_$make (multics_entry, MULTICS_L6_FILE_SUFFIX (multics_file_l6_type), multics_entry,
		     code);
		if code ^= 0
		     then call ERROR (code, "Trying to add the suffix ""^a"" to ^a",
			     MULTICS_L6_FILE_SUFFIX (multics_file_l6_type), multics_pathname);

		multics_pathname = pathname_ (multics_dir, multics_entry);
		end;

	call hcs_$append_branch (multics_dir, multics_entry, RW_ACCESS_BIN, code);
	if code ^= 0 then call ERROR (code, "Trying to create: ^a.", multics_pathname);

	return;

     end Create_Multics_File;

File_Definition_Dialogue:
     proc ();

dcl  acceptor_file_count	       pic "99";
dcl  chars_read		       fixed bin (21);
dcl  ci_size		       pic "99999";
dcl  char_position		       fixed bin;
dcl  data_type		       char (1);
dcl  file_access		       char (1);
dcl  file_name_len		       pic "99";
dcl  file_size		       pic "99999";
dcl  file_type		       char (1);
dcl  fixed_response_len	       fixed bin (21);
dcl  indicator		       char (1);
dcl  initiator_file_count	       pic "99";
dcl  key_length		       pic "999";
dcl  key_offset		       pic "9999";
dcl  key_type		       char (1);

dcl  1 l6_response		       unaligned based (comm_buffer_ptr),
       2 header,
         3 first_char	       char (1),		/* Should be "8". */
         3 response_len	       pic "999",
         3 ack_indicator	       char (1),		/* "$"--yes, "&"--no. */
       2 rest_of_response	       char (rest_of_response_len);

dcl  l6_response_path_len	       pic "99";
dcl  output_message_len	       pic "999";
dcl  percent_fill		       pic "99";
dcl  record_size		       pic "9999";
dcl  rest_of_response_len	       fixed bin;
dcl  starting_record	       pic "99999";

	if multics_is_sender
	     then do;				/*  We must describe the file to the Level 6. */
		file_name_len = length (rtrim (level_6_pathname)) + 1;
						/* The L6 requires a trailing space in the name. */
		record_size = multics_file_block_size;
		starting_record = 0;
		file_size = multics_file_size;
		initiator_file_count = 1;
		acceptor_file_count = 1;

		call ioa_$rsnpnnl (" 000 O!^2a^a ^[#^a^;^s#P^aQ^a^[R^a^;^s^]S^a^[Z^a^;^s^][^a\^a^]", comm_buffer,
		     level_6_chars_to_write, file_name_len, rtrim (level_6_pathname), saved_attributes ^= "",
		     saved_attributes, L6_FILE_TYPE (multics_file_l6_type),
		     L6_DATA_TYPE (l6_tran_info.multics_data_type), multics_file_block_size > 0, record_size,
		     starting_record, multics_file_size > 0, file_size, initiator_file_count, acceptor_file_count);

		output_message_len = level_6_chars_to_write;
						/* Set the message length. */
		substr (comm_buffer, 2, 3) = output_message_len;

		call l6_tran_util_$put_chars (level_6_iocbp, comm_buffer_ptr, level_6_chars_to_write, code);
		if code ^= 0 then call ERROR (code, "Trying to send the output file definition to the Level 6.");
		end;				/*  We must describe the file to the Level 6. */

	     else do;				/* The Level 6 will tell us about the file. */
		file_name_len = length (rtrim (level_6_pathname)) + 1;
						/* The L6 requires a trailing space in the name. */

		call ioa_$rsnpnnl (" 000 I!^2a^a ", comm_buffer, level_6_chars_to_write, file_name_len,
		     rtrim (level_6_pathname));

		output_message_len = level_6_chars_to_write;
						/* Set the message length. */
		substr (comm_buffer, 2, 3) = output_message_len;

		call l6_tran_util_$put_chars (level_6_iocbp, comm_buffer_ptr, level_6_chars_to_write, code);
		if code ^= 0 then call ERROR (code, "Trying to send the input file definition to the Level 6.");
		end;				/* The Level 6 will tell us about the file. */

/* Get the Level 6 response to our request.  This involves a loop to get everything he says he sent. */

	call l6_tran_util_$get_chars (level_6_iocbp, comm_buffer_ptr, comm_buffer_len, level_6_chars_read, code);
	if code ^= 0 then call ERROR (code, "Trying to read the output file definition ack from the Level 6.");

	fixed_response_len = l6_response.response_len;
	rest_of_response_len = fixed_response_len - length (string (l6_response.header));

	do chars_read = level_6_chars_read repeat chars_read + level_6_chars_read
	     while (chars_read < fixed_response_len);
	     call l6_tran_util_$get_chars (level_6_iocbp, add_char_offset_ (comm_buffer_ptr, chars_read),
		comm_buffer_len - chars_read, level_6_chars_read, code);
	     if code ^= 0 then call ERROR (code, "Trying to read the output file definition ack from the Level 6.");
	end;


/*****************************************************************************/
/*							       */
/*   Do the following strange thing in case the first prompt sent by the L6  */
/*   was combined with the file definition response when we called	       */
/*   get_chars.  The variable level_6_chars_read is declared in our caller,  */
/*   so set it to be any extra characters after the response.  We will       */
/*   assume that this is the prompt and will not try to get the prompt in    */
/*   l6_tran_send_file_.  We have to do a similar thing in		       */
/*   l6_tran_overseer_, but there we use a write_status to guarantee that    */
/*   our response is not combined with our prompt.  This stuff is all a      */
/*   kludge because there is no way to use the "more_data" bit in an X.25    */
/*   packet on Multics.					       */
/*							       */
/*****************************************************************************/

	level_6_chars_read = level_6_chars_read - fixed_response_len;

/*****************************************************************************/

	if l6_response.ack_indicator ^= "$"
	     then do;
		if l6_response.rest_of_response = "'82FF"
		     then call ERROR (0b, "The last file has been received.");
						/* Not really an error. */
		     else call ERROR (error_table_$fatal_error,
			     "The Level 6 rejected the file transfer.  From L6: ^a.", l6_response.rest_of_response);
		end;

/* Set default level 6 file attributes, and then get the real ones, if any. */

	level_6_data_type = ASCII;
	level_6_file_type = L6_S_FILE_TYPE;
	level_6_max_record_size = 0;

	if l6_response.rest_of_response ^= ""
	     then do;				/* Process the file attributes. */
		char_position = 1;
		do while (char_position <= length (l6_response.rest_of_response));
						/* Loop through the file attributes. */
		     indicator = substr (l6_response.rest_of_response, char_position, length (indicator));
		     char_position = char_position + length (indicator);

		     if indicator = "!"
			then do;			/* He is sending us his pathname. */
			     string (l6_response_path_len) =
				substr (l6_response.rest_of_response, char_position,
				length (l6_response_path_len));

			     char_position = char_position + length (l6_response_path_len);

			     level_6_response_pathname =
				substr (l6_response.rest_of_response, char_position, l6_response_path_len);

			     char_position = char_position + l6_response_path_len;
			     end;			/* He is sending us his pathname. */

		     else if indicator = "#"
			then saved_attributes = substr (l6_response.rest_of_response, char_position);

		     else if indicator = "P"
			then do;			/* File type */
			     file_type = substr (l6_response.rest_of_response, char_position, length (file_type));
			     char_position = char_position + length (file_type);

			     level_6_file_type = index (string (L6_FILE_TYPE), file_type);

			     if level_6_file_type = 0
				then call ERROR (error_table_$bad_file,
					"The Level 6 file type: ""^a"", is not supported.", file_type);
			     end;

		     else if indicator = "Q"
			then do;			/* Data type */
			     data_type = substr (l6_response.rest_of_response, char_position, length (data_type));
			     char_position = char_position + length (data_type);

			     level_6_data_type = index (string (L6_DATA_TYPE), data_type);

			     if level_6_data_type = 0
				then call ERROR (error_table_$bad_file,
					"The Level 6 data type: ""^a"", is not supported.", data_type);
			     end;

		     else if indicator = "R"
			then do;			/* Record size */
			     string (record_size) =
				substr (l6_response.rest_of_response, char_position, length (record_size));
			     char_position = char_position + length (record_size);

			     level_6_max_record_size = record_size;
			     end;

		     else if indicator = "S"
			then do;			/* Starting record */
			     string (starting_record) =
				substr (l6_response.rest_of_response, char_position, length (starting_record));
			     char_position = char_position + length (starting_record);
			     end;

		     else if indicator = "T"
			then do;			/* File access code */
			     file_access =
				substr (l6_response.rest_of_response, char_position, length (file_access));
			     char_position = char_position + length (file_access);
			     end;

		     else if indicator = "U"
			then do;			/* Key length */
			     string (key_length) =
				substr (l6_response.rest_of_response, char_position, length (key_length));
			     char_position = char_position + length (key_length);
			     end;

		     else if indicator = "V"
			then do;			/* Key offset */
			     string (key_offset) =
				substr (l6_response.rest_of_response, char_position, length (key_offset));
			     char_position = char_position + length (key_offset);
			     end;

		     else if indicator = "W"
			then do;			/* Percent fill */
			     string (percent_fill) =
				substr (l6_response.rest_of_response, char_position, length (percent_fill));
			     char_position = char_position + length (percent_fill);
			     end;

		     else if indicator = "X"
			then do;			/* Key type */
			     key_type = substr (l6_response.rest_of_response, char_position, length (key_type));
			     char_position = char_position + length (key_type);
			     end;

		     else if indicator = "Y"
			then do;			/* CI size */
			     string (ci_size) =
				substr (l6_response.rest_of_response, char_position, length (ci_size));
			     char_position = char_position + length (ci_size);
			     end;

		     else if indicator = "Z"
			then do;			/* File size (in CI units) */
			     string (file_size) =
				substr (l6_response.rest_of_response, char_position, length (file_size));
			     char_position = char_position + length (file_size);
			     end;

		     else if indicator = "["
			then do;			/* Initiator's file count */
			     string (initiator_file_count) =
				substr (l6_response.rest_of_response, char_position,
				length (initiator_file_count));
			     char_position = char_position + length (initiator_file_count);
			     end;

		     else if indicator = "\"
			then do;			/* Acceptor's file count */
			     string (acceptor_file_count) =
				substr (l6_response.rest_of_response, char_position, length (acceptor_file_count))
				;
			     char_position = char_position + length (acceptor_file_count);
			     end;

		     else ;			/* Not recognized, skip it */

		end;				/* Loop through the attributes. */
		end;				/* Process the file attributes. */

	return;

     end File_Definition_Dialogue;

Generate_Multics_Path:
     proc ();

dcl  code			       fixed bin (35);
dcl  l6_entryname		       char (32);

	if level_6_response_pathname ^= ""
	     then do;				/* We must generate the Multics name. */
		l6_entryname = reverse (before (reverse (level_6_response_pathname), ">"));

		call get_equal_name_ (l6_entryname, saved_multics_entry, multics_entry, code);
		if code ^= 0
		     then call ERROR (code, "Trying to do equal name processing on: ^a, matching: ^a.",
			     saved_multics_entry, l6_entryname);

		multics_pathname = pathname_ (multics_dir, multics_entry);
		end;				/* We must generate the Multics name. */

	return;

     end Generate_Multics_Path;

Get_Next_Path:
     proc (P_last_file);

dcl  P_last_file		       bit (1) parameter;

dcl  code			       fixed bin (35);

	call check_star_name_$entry (saved_multics_entry, code);

	if code = 0 then P_last_file = "1"b;		/* Not a star name, nothing to do. */

	else if code = error_table_$badstar then call ERROR (code, "Multics file name: ^a.", saved_multics_entry);

	else do;					/* We have a star name. */
	     if ^star_names_generated
		then do;				/* Get the star list once. */
		     star_area_ptr = get_user_free_area_ ();

		     call hcs_$star_ (multics_dir, saved_multics_entry, star_ALL_ENTRIES, star_area_ptr,
			star_entry_count, star_entry_ptr, star_names_ptr, code);
		     if code ^= 0
			then call ERROR (code, "Trying to match starname ^a in directory ^a.", saved_multics_entry,
				multics_dir);

/* Set the index to the first non-directory entry. */

		     do star_entries_index = 1 to hbound (star_entries, 1)
			while (star_entries (star_entries_index).type = star_DIRECTORY);
		     end;

		     if star_entries_index > hbound (star_entries, 1)
			then call ERROR (error_table_$dirseg, "Only directories match ^a.", multics_pathname);

		     star_names_generated = "1"b;
		     end;				/* Get the star list once. */

/* Just use the first matching name on an entry. */

	     multics_entry = star_names (star_entries (star_entries_index).nindex);
	     multics_pathname = pathname_ (multics_dir, multics_entry);

/* Now update the star_entries_index and set P_last_file. */

	     do star_entries_index = star_entries_index + 1 to hbound (star_entries, 1)
		while (star_entries (star_entries_index).type = star_DIRECTORY);
	     end;

	     if star_entries_index > hbound (star_entries, 1)
		then P_last_file = "1"b;
		else P_last_file = "0"b;
	     end;					/* We have a star name. */

/* Now generate the L6 pathname. */

	call get_equal_name_ (multics_entry, saved_level_6_entry, level_6_entry, code);
	if code ^= 0
	     then call ERROR (code, "Trying to do equalname matching on L6 name: ^a, against Multics name: ^a.",
		     saved_level_6_entry, multics_entry);

	level_6_pathname = rtrim (level_6_dir) || level_6_entry;

	return;

     end Get_Next_Path;

Get_Saved_Attributes:
     proc ();

	if multics_file_l6_type ^= L6_S_FILE_TYPE
	     then do;
		call iox_$read_record (multics_file_iocbp, file_buffer_ptr, file_buffer_len, multics_chars_read, code)
		     ;
		if code ^= 0
		     then call ERROR (code, "Trying to get the file attributes from the multics file: ^a.",
			     multics_pathname);

		saved_attributes = substr (file_buffer, 1, multics_chars_read);
		end;

	     else saved_attributes = "";

	return;

     end Get_Saved_Attributes;

Login_Dialogue:
     proc ();

dcl  chars_read		       fixed bin (21);
dcl  greeting_message_found	       bit (1);

	call l6_tran_util_$get_chars (level_6_iocbp, comm_buffer_ptr, comm_buffer_len, level_6_chars_read, code);
	if code ^= 0 then call ERROR (code, "Trying to read the Level 6 greeting message.");

	greeting_message_found = "0"b;
	do chars_read = level_6_chars_read repeat chars_read + level_6_chars_read while (^greeting_message_found);
						/* Discard extraneous lines. */

	     if index (substr (comm_buffer, 1, chars_read), "LOAD = ") ^= 0
		| index (substr (comm_buffer, 1, chars_read), "Load = ") ^= 0
		| index (substr (comm_buffer, 1, chars_read), "LOGIN") ^= 0
		then do;				/* We have found a greeting message. */
		     greeting_message_found = "1"b;

		     if debug_flag
			then call ioa_$rsnpnnl ("l ^a -bf -create -nw -pf -nosave -po l6_tran_overseer_^/",
				comm_buffer, level_6_chars_to_write, l6_tran_info.user_name);

			else call ioa_$rsnpnnl ("L ^a -PO TRANX -ARG ^[R^;S^]DAU^a", comm_buffer,
				level_6_chars_to_write, l6_tran_info.user_name, multics_is_sender, CR);

		     call l6_tran_util_$put_chars (level_6_iocbp, comm_buffer_ptr, level_6_chars_to_write, code);
		     if code ^= 0 then call ERROR (code, "Trying to send the login line to the Level 6.");

/* Read characters until we find "HI" or "PASSWORD" as a substring, then assume we got everything since there is no delimiter. */

		     call l6_tran_util_$get_chars (level_6_iocbp, comm_buffer_ptr, comm_buffer_len,
			level_6_chars_read, code);
		     if code ^= 0 then call ERROR (code, "Trying to read ""HI"" or ""PASSWORD"" after login.");

		     do chars_read = level_6_chars_read repeat chars_read + level_6_chars_read
			while ((index (substr (comm_buffer, 1, chars_read), "HI") = 0)
			& (index (substr (comm_buffer, 1, chars_read), "PASSWORD") = 0));
			call l6_tran_util_$get_chars (level_6_iocbp, add_char_offset_ (comm_buffer_ptr, chars_read),
			     comm_buffer_len - chars_read, level_6_chars_read, code);
			if code ^= 0 then call ERROR (code, "Trying to read ""HI"" or ""PASSWORD"" after login.");
		     end;

		     if index (substr (comm_buffer, 1, chars_read), "PASSWORD") ^= 0
			then do;			/* L6 wants a password. */
			     if l6_tran_info.password = ""
				then do;		/* Get the password from the user. */
				     call read_password_$switch (out_iocbp, in_iocbp,
					"Level 6 has requested password:", l6_tran_info.password, code);
						/* Forget the code, we won't use it anyway. */
				     end;		/* Get the password from the user. */

			     level_6_chars_to_write = length (rtrim (l6_tran_info.password));

			     if debug_flag
				then substr (comm_buffer, 1, level_6_chars_to_write) =
					rtrim (l6_tran_info.password) || "
";
				else substr (comm_buffer, 1, level_6_chars_to_write) =
					rtrim (l6_tran_info.password);

			     l6_tran_info.password = "";
						/* Erase the password now. */

			     call l6_tran_util_$put_chars (level_6_iocbp, comm_buffer_ptr, level_6_chars_to_write,
				code);
			     if code ^= 0 then call ERROR (code, "Trying to send the password to the Level 6.");

/* Read characters until we find "HI" as a substring, then assume we got everything since there is no delimiter. */

			     call l6_tran_util_$get_chars (level_6_iocbp, comm_buffer_ptr, comm_buffer_len,
				level_6_chars_read, code);
			     if code ^= 0 then call ERROR (code, "Trying to read ""HI"" after login.");

			     do chars_read = level_6_chars_read repeat chars_read + level_6_chars_read
				while (index (substr (comm_buffer, 1, chars_read), "HI") = 0);
				call l6_tran_util_$get_chars (level_6_iocbp,
				     add_char_offset_ (comm_buffer_ptr, chars_read), comm_buffer_len - chars_read,
				     level_6_chars_read, code);
				if code ^= 0 then call ERROR (code, "Trying to read ""HI"" after login.");
			     end;

			     end;			/* L6 wants a password. */

			else ;			/* We found the "HI", and that's it. */

		     end;				/* We have found a greeting message. */

		else do;				/* Get some more characters and look again. */
		     greeting_message_found = "0"b;

		     call l6_tran_util_$get_chars (level_6_iocbp, add_char_offset_ (comm_buffer_ptr, chars_read),
			comm_buffer_len - chars_read, level_6_chars_read, code);
		     if code ^= 0 then call ERROR (code, "Trying to read the Level 6 greeting message.");
		     end;

	end;					/* Discard extraneous lines. */

	return;

     end Login_Dialogue;

OK_Dialogue:
     proc ();

	level_6_chars_to_write = length ("OK?");
	substr (comm_buffer, 1, level_6_chars_to_write) = "OK?";

	call l6_tran_util_$put_chars (level_6_iocbp, comm_buffer_ptr, level_6_chars_to_write, code);
	if code ^= 0 then call ERROR (code, "Trying to send ""OK?"" to the Level 6.");

	call l6_tran_util_$get_chars (level_6_iocbp, comm_buffer_ptr, comm_buffer_len, level_6_chars_read, code);
	if code ^= 0 then call ERROR (code, "Trying to read ""OK"" from the Level 6.");

	if substr (comm_buffer, 1, level_6_chars_read) ^= "OK" then ;
						/* Something wrong, but keep going anyway. */

	return;

     end OK_Dialogue;

Open_L6_Connection:
     proc ();

	call ioa_$rsnnl ("tty_ ^a -destination ^a", level_6_attach_desc, ignored_len, l6_tran_info.net_name,
	     l6_tran_info.net_address);

	call iox_$attach_name (l6_tran_info.net_name, level_6_iocbp, (level_6_attach_desc), null (), code);
	if code ^= 0 & code ^= error_table_$not_detached
	     then call ERROR (code, "Trying to attach the Level 6 on channel: ^a.", l6_tran_info.net_name);

	call iox_$open (level_6_iocbp, Stream_input_output, "0"b, code);
	if code ^= 0 & code ^= error_table_$not_closed
	     then call ERROR (code, "Trying to open the Level 6 channel: ^a.", l6_tran_info.net_name);

	call iox_$modes (level_6_iocbp, "8bit,rawi,rawo", "", code);
	if code ^= 0
	     then call ERROR (code, "Trying to set modes on switch: ^a to ""8bit,rawi,rawo"".", l6_tran_info.net_name);

	return;

     end Open_L6_Connection;

Open_Multics_File:
     proc ();

	call ioa_$rsnnl ("^[record_stream_ -target ^]vfile_ ^a^[ -blocked ^d^;^s^]", multics_file_attach_desc,
	     ignored_len, multics_file_type = UNSTRUCTURED_FILE_TYPE, multics_pathname,
	     multics_file_type = BLOCKED_FILE_TYPE, multics_file_block_size);

	call iox_$attach_name (multics_entry, multics_file_iocbp, (multics_file_attach_desc), null (), code);
	if code ^= 0 & code ^= error_table_$not_detached
	     then call ERROR (code, "Trying to attach file: ^a through switch: ^a.", multics_pathname, multics_entry);

	if multics_is_sender
	     then multics_file_open_mode = Sequential_input;
	     else multics_file_open_mode = Sequential_output;

	call iox_$open (multics_file_iocbp, multics_file_open_mode, "0"b, code);
	if code ^= 0 & code ^= error_table_$not_closed
	     then call ERROR (code, "Trying to open file: ^a through switch: ^a.", multics_pathname, multics_entry);

	return;

     end Open_Multics_File;

Process_File_Name:
     proc ();

dcl  code			       fixed bin (35);
dcl  sender_file_flag	       bit (1);

	if l6_tran_info.sender_info.pathname = ""
	     then do;				/* From file first. */
		l6_tran_info.sender_info.pathname = arg;
		sender_file_flag = "1"b;
		end;

	     else do;				/* To file second. */
		l6_tran_info.receiver_info.pathname = arg;
		sender_file_flag = "0"b;
		end;

/* Now peek ahead in the arg list to see if there is a host specified for this file. */

	call cu_$arg_ptr_rel (arg_idx + 1, arg_ptr, arg_len, code, arg_list_ptr);

	if code = 0
	     then do;				/* There is a next arg. */
		if arg = "-at"
		     then do;			/* Pick up the host name. */
			arg_idx = arg_idx + 2;	/* Set to host arg number. */

			call cu_$arg_ptr_rel (arg_idx, arg_ptr, arg_len, code, arg_list_ptr);
			if code ^= 0
			     then call ERROR (code, "Trying to get the host name after the ""-at"" argument.");

			if sender_file_flag
			     then l6_tran_info.sender_info.host_name = arg;
			     else l6_tran_info.receiver_info.host_name = arg;

			end;			/* Pick up the host name. */
		end;				/* There is a next arg. */

	return;

     end Process_File_Name;

Set_Saved_Attributes:
     proc ();

	if multics_file_l6_type ^= L6_S_FILE_TYPE
	     then do;
		multics_chars_to_write = length (saved_attributes);
		substr (file_buffer, 1, multics_chars_to_write) = saved_attributes;

		call iox_$write_record (multics_file_iocbp, file_buffer_ptr, multics_chars_to_write, code);
		if code ^= 0 then call ERROR (code, "Trying to save the file attributes in: ^a.", multics_pathname);
		end;

	return;

     end Set_Saved_Attributes;

Verify_File_Attributes:
     proc ();

	if multics_file_l6_type ^= level_6_file_type
	     then call ERROR (error_table_$bad_file,
		     "The Level 6 file type does not match the existing Multics file type.  (M = ^a, L6 = ^a).",
		     L6_FILE_TYPE (multics_file_l6_type), L6_FILE_TYPE (level_6_file_type));

	if multics_file_type = BLOCKED_FILE_TYPE & multics_file_block_size < level_6_max_record_size
	     then call ERROR (error_table_$bad_file,
		     "The Multics file block size is less than the Level 6 record size.  (M = ^d, L6 = ^d).",
		     multics_file_block_size, level_6_max_record_size);

	if multics_file_type = UNSTRUCTURED_FILE_TYPE
	     & ^(level_6_file_type = L6_S_FILE_TYPE & level_6_data_type = ASCII)
	     then call ERROR (error_table_$bad_file,
		     "Only a sequential ascii Level 6 file may be transferred to an unstructured Multics file.");

	return;

     end Verify_File_Attributes;

/*****************************************************************************/
/*							       */
/*   PROCEDURE: ERROR					       */
/*							       */
/*   This subroutine expects arguments as follows:		       */
/*							       */
/*         call ERROR (code, ioa_control_string, ioa_arguments, ...)	       */
/*							       */
/*   where: code is fixed bin (35), and ioa_control_string and ioa_arguments */
/*          are optional character strings as defined for ioa_.	       */
/*							       */
/*   Some global variables are used:				       */
/*							       */
/*   	Cleanup_Handler (a procedure that does cleanup)		       */
/*							       */
/*     For commands:					       */
/*   	report_error (an entry variable set to com_err_ or active_fnc_err_)*/
/*   	command_name (the character string name of the command)	       */
/*	return_arg_ptr (used to return "false" for active functions)       */
/*							       */
/*     For subroutines:					       */
/*	depends on the error reporting strategy chosen.		       */
/*							       */
/*   At completion a non-local goto is done to the label RETURN.	       */
/*							       */
/*   Declarations are expected for:				       */
/*							       */
/*   	cu_$arg_list_ptr					       */
/*   	cu_$arg_ptr					       */
/*   	cu_$arg_count					       */
/*   	error_table_$fatal_error				       */
/*   	ioa_$general_rs					       */
/*							       */
/*****************************************************************************/

ERROR:
     proc () options (variable, non_quick);

dcl  arg_list_ptr		       ptr;
dcl  arg_len		       fixed bin (21);
dcl  arg_ptr		       ptr;
dcl  based_code		       fixed bin (35) based;
dcl  caller_code		       fixed bin (35);
dcl  code			       fixed bin (35);
dcl  err_msg		       char (256);
dcl  err_msg_len		       fixed bin (21);
dcl  nargs		       fixed bin;

	call cu_$arg_count (nargs, code);		/* IGNORE CODE */

	if nargs >= 1
	     then do;				/* We were called correctly. */
		arg_ptr = null ();			/* Set this so we know if cu_$arg_ptr worked. */
		call cu_$arg_ptr (1, arg_ptr, arg_len, code);

		if arg_ptr ^= null ()
		     then caller_code = arg_ptr -> based_code;
						/* The normal case. */
		     else caller_code = error_table_$fatal_error;
						/* Some problem with our arg list. */

		if nargs > 1
		     then do;			/* There is a message. */
			call cu_$arg_list_ptr (arg_list_ptr);
			call ioa_$general_rs (arg_list_ptr, 2, 3, err_msg, err_msg_len, "1"b, "0"b);
			end;

		     else do;			/* No message. */
			err_msg = "";
			err_msg_len = 0;
			end;
		end;				/* We were called correctly. */

	     else do;				/* We were called with no arguments. */
		caller_code = error_table_$fatal_error; /* The best we can do. */
		err_msg = "";
		err_msg_len = 0;
		end;				/* We were called with no arguments. */

/* The following lines must be modified depending on the error reporting strategy used. */

	if level_6_iocbp ^= null () & comm_buffer_ptr ^= null ()
	     then do;				/* Tell the Level 6. */

dcl  pic_err_msg_len	       pic "99";

		pic_err_msg_len = min (99, err_msg_len);

		call ioa_$rsnpnnl ("CU^a^aR ", comm_buffer, level_6_chars_to_write, pic_err_msg_len,
		     substr (err_msg, 1, pic_err_msg_len));

		call l6_tran_util_$put_chars (level_6_iocbp, comm_buffer_ptr, level_6_chars_to_write, code);
		end;

	P_error_message = substr (err_msg, 1, err_msg_len);
	P_code = caller_code;

/* Clean up and do a non-local goto back to the outermost block. */

	call Cleanup_Handler ();
	goto RETURN;

     end ERROR;

Parser_Cleanup:
     proc ();

	if l6tip ^= null () then free l6_tran_info in (based_area);

	return;

     end Parser_Cleanup;

Execute_Cleanup:
     proc ();

dcl  code			       fixed bin (35);

	if status_area_ptr ^= null () & status_ptr ^= null ()
	     then do;
		if status_branch.nnames > 1 & status_branch.names_relp ^= "0"b
		     then free status_entry_names in (status_area_ptr -> based_area);
		end;

	if star_area_ptr ^= null ()
	     then do;				/* Order is important here. */
		if star_names_ptr ^= null () & star_entry_ptr ^= null ()
		     then free star_names in (star_area_ptr -> based_area);

		if star_entry_ptr ^= null () then free star_entries in (star_area_ptr -> based_area);
		end;

	if multics_file_iocbp ^= null ()
	     then do;
		call iox_$close (multics_file_iocbp, code);
		call iox_$detach_iocb (multics_file_iocbp, code);
		call iox_$destroy_iocb (multics_file_iocbp, code);
		end;

	if level_6_iocbp ^= null ()
	     then do;
		call iox_$close (level_6_iocbp, code);
		call iox_$detach_iocb (level_6_iocbp, code);
		call iox_$destroy_iocb (level_6_iocbp, code);
		end;

	if file_buffer_ptr ^= null () | comm_buffer_ptr ^= null ()
	     then call release_temp_segments_ ("l6_tran_", temp_seg_ptrs, code);

	return;

     end Execute_Cleanup;

debug_on:
     entry ();
	debug_flag = "1"b;
	return;

debug_off:
     entry ();
	debug_flag = "0"b;
	return;

     end l6_tran_;
