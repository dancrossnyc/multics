/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(82-11-29,Bush), approve(), audit(), install():
     Created.
  2) change(83-11-06,Bush), approve(), audit(), install():
     Modified to fix bug causing repeatative opening of same file to not
     position to correct file.
  3) change(85-06-07,GWMay), approve(85-06-07,MECR0125),
     audit(85-06-07,GDixon), install():
     Changed arrays IFH_BKS_CNT and NLB_BKS_CNT to position to proper place on
     the tape in routine FILE_POSITION(1).
  4) change(85-10-24,GWMay), approve(85-10-24,MCR7256), audit(85-12-16,GDixon),
     install(85-12-17,MR12.0-1001):
     Formally install changes in MECR0125.
  5) change(87-08-17,GWMay), approve(87-09-09,MECR0006),
     audit(87-09-04,Farley), install(87-09-09,MR12.1-1101):
     Initialized pointers were needed and moved checks for pointers from a
     location where the pointer may not be set to a correct location.
  6) change(87-10-19,GWMay), approve(87-10-19,MCR7779), audit(87-11-02,Farley),
     install(87-11-30,MR12.2-1006):
     Formally install MECR0006.
  7) change(88-02-03,GWMay), approve(88-02-03,MCR7837), audit(88-04-12,Farley),
     install(88-04-19,MR12.2-1039):
     Fixed bug to allow unlabeled tapes to be read.
  8) change(00-01-26,Schroth), approve(00-01-26,MECR-Y2K):
     Change julian_date to use "0" prefix for dates after 1999-12-31.
     Added label_unexpired entry to check if a date recorded in a label
     has expired.
                                                   END HISTORY COMMENTS */


/* 	This procedure embodies a group of utility subroutines for the     */
/*	mtape_ per-format modules.			                 */


pfm_utils_: procedure;

/* format: style4 */


/*		ARGUMENT DATA		*/

dcl  arg_mtdp ptr;					/* Pointer to the mtape_ data structure */
dcl  link_head ptr;					/* Pointer to the head of a linked list of structures */
dcl  link_tail ptr;					/* Pointer to the tail of a linked list of structures */
dcl  arg_length fixed bin (21);			/* length of label record in bytes */
dcl  arg_lr_ptr ptr;				/* Pointer to allocated label record structure */
dcl  arg_code fixed bin (35);				/* return error code */
dcl  arg_ltype fixed bin;				/* 1 => BOF; 2 => EOV; 3 => EOF */
dcl  arg_fi_ptr ptr;				/* Callers file info structure ptr */
dcl  arg_vs_ptr ptr;				/* Callers volume info structure */
dcl  desired_position fixed bin;			/* To position within file */
dcl  new_section bit (1) aligned;			/* "0"b =>  new file; "1"b => new file section */

/*		AUTOMATIC DATA		*/

dcl  (code, rfl_code, wfl_code) fixed bin (35);
dcl  (ver_ptr, nvp, nfip, nlp, pp) ptr;
dcl  (ltype, lab_num, bks_file_cnt, fwd_file_cnt, neofs, space_files, htype,
     target_position, convert, prev_seq) fixed bin;
dcl  (term, term1, term2, found, forward) bit (1) aligned;
dcl  pic4 picture "9999";

/*		CONSTANT DATA	*/

dcl  IFH_BKS_CNT (0:5) fixed bin int static options (constant) init
	(0, 0, 1, 2, 2, 2);				/* files to bks to position to file hdr */
dcl  NLB_BKS_CNT (0:5) fixed bin int static options (constant) init
	(0, 0, 0, 0, 1, 1);				/* files to bks to position to BOF for unlabeled file */
dcl  LC char (26) int static options (constant) init
	("abcdefghijklmnopqrstuvwxyz");
dcl  UC char (26) int static options (constant) init
	("ABCDEFGHIJKLMNOPQRSTUVWXYZ");

/*		EXTERNAL STATIC DATA	*/

dcl  error_table_$lost_device_position fixed bin (35) ext static;
dcl  error_table_$end_of_info fixed bin (35) ext static;
dcl  error_table_$eov_on_write fixed bin (35) ext static;
dcl  error_table_$invalid_label_format fixed bin (35) ext static;
dcl  error_table_$invalid_file_set_format fixed bin (35) ext static;
dcl  error_table_$file_aborted fixed bin (35) ext static;
dcl  error_table_$uninitialized_volume fixed bin (35) ext static;
dcl  error_table_$no_file fixed bin (35) ext static;
dcl  error_table_$no_next_volume fixed bin (35) ext static;

/*		BUILTIN FUNCTIONS		*/

dcl  (clock, mod, null, substr, translate) builtin;

/*		EXTERNAL ENTRIES		*/

dcl  mtape_$alloc entry (ptr, fixed bin, ptr, fixed bin (21), ptr);
dcl  mtape_$error entry options (variable);
dcl  mtape_$volume_switch entry (ptr, ptr, fixed bin (35));
dcl  mtape_$order entry (ptr, char (*), fixed bin, ptr, fixed bin (35));
dcl  mtape_$read_label entry (ptr, ptr, fixed bin (35));
dcl  mtape_$user_query entry (ptr, fixed bin, fixed bin (35));
dcl  mtape_$write_label entry (ptr, ptr, fixed bin (35));
dcl  convert_date_to_binary_ entry (char (*), fixed bin (71), fixed bin (35));
dcl  datebin_ entry (fixed bin (71), fixed bin, fixed bin, fixed bin, fixed bin, fixed bin, fixed bin,
	fixed bin, fixed bin, fixed bin);
dcl  datebin_$dayr_clk entry (fixed bin (71), fixed bin);

/*		BASED DATA		*/

dcl  based_label_record char (mtape_label_record.lab_length) based (mtape_label_record.lab_ptr);
dcl  based_area area based (mtape_data.areap);
%page;
/* init_label_record - entry to allocate label record structure and storage for
   label record and link them in */

init_label_record: entry (arg_mtdp, link_tail, link_head, arg_lr_ptr, arg_length);

	mtdp = arg_mtdp;				/* copy mtape_ data pointer */
	call mtape_$alloc (mtdp, MTAPE_ALLOC_LR, link_tail, 0, lr_ptr);
	link_tail = lr_ptr;				/* Link this label record in */
	if link_head = null then			/* if this is first time through */
	     link_head = lr_ptr;			/* set link head also */
	mtape_label_record.lab_length = arg_length;	/* initialize the LR structure */
	mtape_label_record.mode = MTAPE_HWM_NINE;	/* ANSI labels are always nine track mode */
	mtape_label_record.conversion = MTAPE_CV_UC_ASCII;/* convert to upper case for writting */
	call mtape_$alloc (mtdp, MTAPE_ALLOC_STR, null, arg_length, mtape_label_record.lab_ptr);
	based_label_record = "";			/* initialize to all blanks */
	arg_lr_ptr = lr_ptr;			/* copy return argument */
	return;					/* and return to caller */


/* julian_date - entry to format date in form " yyddd" */

julian_date: entry (date_time) returns (char (6) unaligned);

dcl  date_time char (*);
dcl  clock_value fixed bin (71);
dcl  ddd picture "999";				/* day of year */
dcl  yy picture "99";				/* year */
dcl  temp fixed bin;				/* temporary */

	/* This entry formats a date string into julian date suitable for use in a tape label.
	   The format of the label date is "cyyddd", where:
	     c is a century indicator
	      - " " --> 1900's
	      - "0" --> 2000's.  (We don't care about other centuries!)
	   A label of "x99365" is a special flag date meaning forever. */

	clock_value = clock ();			/* Use todays date as default */
	if date_time ^= "" then			/* if date time given. */
	     call convert_date_to_binary_ (date_time, clock_value, code); /* Use that instead of today */
	call datebin_$dayr_clk (clock_value, temp);	/* get day of year */
	ddd = temp;				/* convert to characters */
	call datebin_ (clock_value, 0, 0, 0, temp, 0, 0, 0, 0, 0); /* get year */
	yy = mod (temp, 100);			/* drop century and convert to characters */
	if temp < 2000 then
	     return (" " || yy || ddd);		/* return formatted date */
	else return ("0" || yy || ddd);		/* return formatted date in 21st century */


/* label_unexpired - entry to check if expiry date still holds */

label_unexpired: entry (label_date) returns (bit (1) aligned);

dcl  label_date char (*);
dcl  today char (6);
dcl  EXPIRED bit (1) internal static options (constant) init ("0"b);
dcl  UNEXPIRED bit (1) internal static options (constant) init ("1"b);

	if label_date = " 00000" then			/* " 00000" means no expiry set, i.e. expired */
	     return (EXPIRED);
	else if substr (label_date, 2, 5) = "99365" then	/* "99365" is a keep forever date */
	     return (UNEXPIRED);
	else do;
	     today = julian_date ("");
	     if label_date > today then		/* not expired yet */
		return (UNEXPIRED);
	     else return (EXPIRED);
         end;

%page;
/* position_in_file - entry to position tape to indicated position within file */

position_in_file: entry (arg_mtdp, arg_fi_ptr, arg_vs_ptr, desired_position, arg_code);

	mtdp = arg_mtdp;				/* copy arg */
	vs_ptr = arg_vs_ptr;
	fi_ptr = arg_fi_ptr;
	maip = mtape_data.attach_info_ptr;
	moip = mtape_data.open_info_ptr;
	mpfmip = mtape_data.pfm_info_ptr;
	code = 0;
	if mtape_file_info.position_within_file = NOT_POSITIONED_IN_FILE then do;
	     code = error_table_$lost_device_position;	/* set appropriate error code */
	     call mtape_$error (mtdp, code,
		"^/^a ^a is not positioned within the file boundaries for file ^a",
		"Attempting to position within file and history indicates that tape volume",
		mtape_vol_set.volume_id, mtape_file_info.file_id);
	     go to PIF_RETURN;
	end;
	fwd_file_cnt = 0;
	go to FILE_POSITION (desired_position);		/* take apropriate action */

FILE_POSITION (1):					/* position to beginning of data file */
	if mtape_file_info.first_file_section_ptr ^= fi_ptr then do; /* we have to do volume switch */
	     fi_ptr = mtape_file_info.first_file_section_ptr; /* go to first file section */
	     vs_ptr = mtape_file_info.begin_vs_ptr;	/* get ptr to VS structure of new volume */
	     call mtape_$volume_switch (mtdp, vs_ptr, code); /* do the switch */
	     if code ^= 0 then do;			/* if some problem */
		call mtape_$error (mtdp, code,	/* report it */
		     "^/Attempting to mount volume ""^a"" on which the beginning of file ""^a"" is located.",
		     mtape_vol_set.volume_id, mtape_file_info.file_id);
		return;				/* and get out */
	     end;
	     fwd_file_cnt = (mtape_file_info.phy_file - mtape_data.phy_file) + 1; /* files to forward space */
	end;

FILE_POSITION (3):					/* position to beginning of file section */
	if mtape_file_info.first_file_on_volume then do;	/* if this is true, can rewind */
	     call REWIND_TO_BOF;			/* go rewind the volume and space over vol labels */
	     if code ^= 0 then
		go to PIF_RETURN;
	     fwd_file_cnt = 0;			/* zero it out so we don't go forward */
	end;
	else if fwd_file_cnt = 0 then do;		/* not 1st file on vol, must bks */
	     fwd_file_cnt = 1;			/* must also forward space 1 file */
	     if mtape_attach_info.labeled then		/* if labeled tape */
		bks_file_cnt = IFH_BKS_CNT (mtape_file_info.position_within_file);
	     else bks_file_cnt = NLB_BKS_CNT (mtape_file_info.position_within_file);
	     call mtape_$order (mtdp, "bsf", bks_file_cnt, null, code); /* backup desired files */
	     if code ^= 0 then do;
		call mtape_$error (mtdp, code,
		     "^/^a ^[headers^;^;^;section^] for file ^a on volume ^a",
		     "Attempting to backspace to the beginning of file", desired_position + 1,
		     mtape_file_info.file_id, mtape_vol_set.volume_id);
		go to PIF_RETURN;
	     end;
	end;
	if fwd_file_cnt > 0 then do;
	     call mtape_$order (mtdp, "fsf", fwd_file_cnt, null, code); /* forward required files */
	     if code ^= 0 then do;
		call mtape_$error (mtdp, code,
		     "^/^a ^[headers^;^;^;section^] for file ^a on volume ^a",
		     "Attempting to forward space to the beginning of file", desired_position + 1,
		     mtape_file_info.file_id, mtape_vol_set.volume_id);
		go to PIF_RETURN;
	     end;
	end;
	if mtape_attach_info.labeled then		/* if labeled volume */
	     mtape_file_info.position_within_file = AT_BOFH; /* set position indicator */
	else mtape_file_info.position_within_file = AT_BOFD; /* set position indicator */
	go to PIF_RETURN;

FILE_POSITION (2):					/* position to end of file */
	if mtape_file_info.position_within_file = AT_EOF then /* if we are already there, forget it */
	     go to PIF_RETURN;
	htype = EOV_LABEL;				/* preset to loop for EOV/BOF seq */
	do while (htype ^= EOF_LABEL);		/* loop until we reach EOF */
	     call mtape_$order (mtdp, "fsf", 1, null, code); /* go to end of current phy file */
	     if code ^= 0 then do;			/* we loose */
		call mtape_$error (mtdp, code,
		     "^/While forward spacing to end of file ""^a"".", mtape_file_info.file_id);
		go to PIF_RETURN;
	     end;
	     htype = EOV_LABEL;			/* preset to loop for EOV/BOF seq */
	     do while (htype = EOV_LABEL);		/* loop on EOV */
		call read_file_labels (mtdp, fi_ptr, vs_ptr, htype, code);
		if code ^= 0 then
		     go to PIF_RETURN;
		if htype = EOV_LABEL then		/* if new file section to be read */
		     fi_ptr = mtape_file_info.next_fi_ptr; /* set up for new section */
	     end;
	end;
	go to PIF_RETURN;
FILE_POSITION (4):					/* Position to end of file section */
	if mtape_file_info.position_within_file = AT_EOF then /* if we have just written file, we are at EOF */
	     go to PIF_RETURN;
	fwd_file_cnt = (mtape_file_info.phy_file + FILES_PER_FILE_GRP) - mtape_data.phy_file;
	call mtape_$order (mtdp, "fsf", fwd_file_cnt, null, code); /* fwd space required files */
	if code ^= 0 then do;			/* if some problem */
	     call mtape_$error (mtdp, code,		/* report it */
		"^/While forward spacing to end of file section ""^a"".", mtape_file_info.file_id);
	     go to PIF_RETURN;
	end;
	if mtape_file_info.next_fi_ptr ^= null then	/* if another file info exists */
	     if mtape_file_info.next_fi_ptr -> mtape_file_info.first_file_section_ptr ^=
		mtape_file_info.first_file_section_ptr then /* not part of this file */
		mtape_file_info.position_within_file = AT_EOF; /* reflect current position */
	     else mtape_file_info.position_within_file = AT_IFD;

PIF_RETURN:
	arg_code = code;
	arg_vs_ptr = vs_ptr;
	arg_fi_ptr = fi_ptr;
	return;
%page;
/* truncate_file_set - entry to free file_info structures from structure tail backwards to current file_info structure */

truncate_file_set: entry (arg_mtdp);

	mtdp = arg_mtdp;
	maip = mtape_data.attach_info_ptr;
	moip = mtape_data.open_info_ptr;
	mpfmip = mtape_data.pfm_info_ptr;
	term, term1, term2 = "0"b;			/* reset terminate conditions */
	do fi_ptr = mtape_data.fi_tail repeat mtape_file_info.prev_fi_ptr while (^term);
	     if mtape_file_info.next_fi_ptr ^= null then do; /* if not last file info */
		free mtape_file_info.next_fi_ptr -> mtape_file_info in (based_area); /* free it */
		mtape_file_info.next_fi_ptr = null;
	     end;
	     if mtape_open_info.extend then do;		/* if extending file, special case */
		do lr_ptr = mtape_file_info.last_file_trail_ptr repeat mtape_label_record.prev_lab_ptr
		     while (lr_ptr ^= null & ^term2);
		     if term1 &			/* already read 1st eof label */
			substr (based_label_record, 1, 3) ^= mtape_pfm_info.eof_prefix then
			term2 = "1"b;		/* if now past first eof label */
		     else do;			/* get rid of these labels */
			if substr (based_label_record, 1, 3) = mtape_pfm_info.eof_prefix then /* first eof label? */
			     term1 = "1"b;
			if mtape_label_record.next_lab_ptr ^= null then /* if not last label record */
			     free mtape_label_record.next_lab_ptr -> mtape_label_record in (based_area);
			free based_label_record in (based_area); /* free label contents */
		     end;
		end;
		if lr_ptr = null then		/* if eof label was first trailer label.. */
		     mtape_file_info.first_file_trail_ptr, mtape_file_info.last_file_trail_ptr = null;
		else mtape_file_info.last_file_trail_ptr = lr_ptr; /* this is now the tail */
	     end;
	     else do;				/* not extending file, get rid of all trailer labels */
		do lr_ptr = mtape_file_info.last_file_trail_ptr repeat mtape_label_record.prev_lab_ptr
		     while (lr_ptr ^= null);
		     if mtape_label_record.next_lab_ptr ^= null then /* if not last label record */
			free mtape_label_record.next_lab_ptr -> mtape_label_record in (based_area);
		     free based_label_record in (based_area); /* free label contents */
		end;
		if mtape_file_info.first_file_trail_ptr ^= null then /* if not unlabeled volume set */
		     free mtape_file_info.first_file_trail_ptr -> mtape_label_record in (based_area);
		mtape_file_info.first_file_trail_ptr, mtape_file_info.last_file_trail_ptr = null;
	     end;
	     if fi_ptr = mtape_data.fi_current then	/* are we done? */
		term = "1"b;			/* yes, set terminate condition */
	     else do;				/* no, free somemore */
		do lr_ptr = mtape_file_info.last_file_lab_ptr repeat mtape_label_record.prev_lab_ptr
		     while (lr_ptr ^= null);
		     if mtape_label_record.next_lab_ptr ^= null then /* if not last label record */
			free mtape_label_record.next_lab_ptr -> mtape_label_record in (based_area);
		     free based_label_record in (based_area); /* free label contents */
		end;
		if mtape_file_info.first_file_lab_ptr ^= null then
		     free mtape_file_info.first_file_lab_ptr -> mtape_label_record in (based_area);
	     end;
	end;
	mtape_data.fi_current -> mtape_file_info.end_of_file_set = "1"b; /* this is end of file set now */
	mtape_data.fi_tail = mtape_data.fi_current;	/* truncate this chain also */
	return;
%page;
/* read_file_labels - external entry to read and decode beginning and end of file labels */

read_file_labels: entry (arg_mtdp, arg_fi_ptr, arg_vs_ptr, arg_ltype, arg_code);

	mtdp = arg_mtdp;				/* copy args */
	fi_ptr = arg_fi_ptr;
	vs_ptr = arg_vs_ptr;
	maip = mtape_data.attach_info_ptr;
	moip = mtape_data.open_info_ptr;
	mpfmip = mtape_data.pfm_info_ptr;
	ltype, rfl_code = 0;			/* start out with good rfl_code */
	ver_ptr = null;

	if mtape_attach_info.labeled then		/* if a labeled volume set */
	     do lab_num = 1 by 1 while (rfl_code ^= error_table_$end_of_info);
	     lr_ptr = mtape_data.tlb;			/* set label record pointer */
	     call mtape_$read_label (mtdp, lr_ptr, rfl_code); /* read the label */
	     if rfl_code ^= 0 then do;		/* some error lets check for EOF */
		if rfl_code = error_table_$end_of_info then /* end of file set? */
		     if lab_num = 1 then do;		/* yes, if first read (2 consecutive EOFs) */
			fi_ptr = mtape_data.fi_tail;	/* set for last file */
			mtape_file_info.end_of_file_set = "1"b; /* Set marker */
			call mtape_$order (mtdp, "bsf", 1, null, rfl_code); /* backspace 1 file mark */
			if rfl_code ^= 0 then
			     call mtape_$error (mtdp, rfl_code,
				"^/Positioning to tape mark prior to end of file set.");
			rfl_code = error_table_$end_of_info; /* reset EOF code */
			go to RFL_RETURN;		/* return with EOF code */
		     end;
		     else ;
		else do;
		     call mtape_$error (mtdp, rfl_code,
			"^/Attempting to read file labels on volume ^a", mtape_vol_set.volume_id);
		     go to RFL_RETURN;
		end;
	     end;
	     else do;				/* No error, check labels */
		if lab_num = 1 then			/* first file label of group */
		     if substr (based_label_record, 1, 3) = mtape_pfm_info.bof_prefix then do; /* if bof label */
			ltype = BOF_LABEL;		/* set label type */
			if fi_ptr = null then	/* does file exist? */
			     call CREATE_FILE_LINK;
			if mtape_file_info.prev_fi_ptr ^= null then
			     mtape_file_info.prev_fi_ptr -> mtape_file_info.position_within_file =
				NOT_POSITIONED_IN_FILE;
			mtape_data.fi_current = fi_ptr; /* this is now current file */
			ver_ptr = mtape_file_info.first_file_lab_ptr; /* set verify ptr */
		     end;
		     else do;			/* must be EOV or EOF label group */
			if substr (based_label_record, 1, 3) = mtape_pfm_info.eov_prefix then do;
			     ltype = EOV_LABEL;	/* is it an EOV label group */
			     ver_ptr = mtape_file_info.first_file_trail_ptr; /* set verify ptr to look at trailers */
			end;
			else
			     if substr (based_label_record, 1, 3) = mtape_pfm_info.eof_prefix then do;
			     ltype = EOF_LABEL;	/* or an EOF label group */
			     ver_ptr = mtape_file_info.first_file_trail_ptr; /* set verify ptr to look at trailers */
			end;
			else do;			/* bad label */
			     rfl_code = error_table_$invalid_label_format; /* set appropriate error code */
			     call mtape_$error (mtdp, rfl_code,
				"^/Unrecognizable file label, reading file labels on volume ^a. Label contents:^/""^a""",
				mtape_vol_set.volume_id, based_label_record);
			     go to RFL_RETURN;
			end;
		     end;
		if ver_ptr = null then do;		/* if label not stored, let PFM decode it */
		     call mtape_data.decode_file_labels (mtdp, lr_ptr, lab_num, ltype, rfl_code);
		     if rfl_code ^= 0 then		/* if conversion error */
			go to RFL_RETURN;
		     if ltype > BOF_LABEL then	/* if EOF/EOV sequence */
			call init_label_record (mtdp, mtape_file_info.last_file_trail_ptr,
			     mtape_file_info.first_file_trail_ptr, lr_ptr, mtape_data.lab_buf_len);
		     else do;			/* bof label group */
			call init_label_record (mtdp, mtape_file_info.last_file_lab_ptr,
			     mtape_file_info.first_file_lab_ptr, lr_ptr, mtape_data.lab_buf_len);
			if lab_num = 1 then do;	/* complete position info */
			     mtape_file_info.phy_file = mtape_data.position.phy_file; /* copy file number */
			     if mtape_file_info.section > 1 & mtape_file_info.prev_fi_ptr = null then
				mtape_file_info.section = 1; /* must be old section we are overwriting */
			     if mtape_file_info.section > 1 then do; /* not 1st file section, must be new vol */
				mtape_file_info.first_file_on_volume = "1"b; /* set for later positioning */
				mtape_file_info.first_file_section_ptr =
				     mtape_file_info.prev_fi_ptr -> mtape_file_info.first_file_section_ptr;

				mtape_file_info.begin_vs_ptr =
				     mtape_file_info.prev_fi_ptr -> mtape_file_info.begin_vs_ptr;
			     end;
			     else do;
				mtape_file_info.begin_vs_ptr = vs_ptr; /* beginning of new file */
				mtape_file_info.first_file_section_ptr = fi_ptr;
			     end;
			     call LINK_VS_END;	/* link in the end vol set ptr */
			end;
		     end;
		     based_label_record = mtape_data.tlb -> mtape_label_record.lab_ptr -> based_label_record;
		     ver_ptr = lr_ptr;		/* set for compatibility */
		end;
		else do;				/* label already exists, compare it */
		     if based_label_record ^= ver_ptr -> mtape_label_record.lab_ptr -> based_label_record then do;
			rfl_code = error_table_$invalid_label_format;
			call mtape_$error (mtdp, rfl_code,
			     "^/^a ^a ^a, physical file ^d, ^a^/""^a""^/New value:^/""^a""",
			     mtape_pfm_info.module_id, "label record read from volume",
			     mtape_vol_set.volume_id, mtape_data.phy_file,
			     "does not agree with safe stored contents of same. Safe stored value:",
			     ver_ptr -> mtape_label_record.lab_ptr -> based_label_record, based_label_record);
			go to RFL_RETURN;
		     end;
		end;
		ver_ptr = ver_ptr -> mtape_label_record.next_lab_ptr; /* update for next compare */
	     end;
	end;
	else do;					/* an unlabeled volume set */
	     call DECODE_UNLABELED_FILE;		/* determine what and where of file */
	     if rfl_code ^= 0 then			/* if some error */
		go to RFL_RETURN;			/* bail out */
	end;
	if ltype = EOV_LABEL then do;			/* if a volume switch is necessary, do it now */
	     mtape_file_info.position_within_file = NOT_POSITIONED_IN_FILE;
	     nvp = mtape_vol_set.next_vs_ptr;		/* copy pointer, in case its null */
	     call mtape_$volume_switch (mtdp, nvp, rfl_code); /* do the magic */
	     if rfl_code ^= 0 then do;		/* could'nt do the switch */
		call mtape_$error (mtdp, rfl_code,
		     "^/Could not mount new volume at volume switch time");
		go to RFL_RETURN;
	     end;
	     vs_ptr = mtape_data.vs_current;		/* point to new volume */
	end;
	else if ltype = EOF_LABEL then		/* if reading EOF label group */
	     mtape_file_info.position_within_file = AT_EOF;
	else mtape_file_info.position_within_file = AT_BOFD; /* Header label group */
	rfl_code = 0;				/* reset code to not reflect EOF */
RFL_RETURN:
	arg_code = rfl_code;
	arg_ltype = ltype;				/* return label group type */
	arg_fi_ptr = fi_ptr;			/* and file info ptr to caller */
	arg_vs_ptr = mtape_data.vs_current;		/* return possibly updated vs_ptr */
	arg_mtdp = mtdp;				/* in case of volume switch */
	return;
%page;
/* write_file_labels - external entry to encode and write beginning and end of file labels */

write_file_labels: entry (arg_mtdp, arg_ltype, arg_code);

	mtdp = arg_mtdp;
	ltype = arg_ltype;
	vs_ptr = mtape_data.vs_current;
	fi_ptr = mtape_data.fi_current;
	maip = mtape_data.attach_info_ptr;
	moip = mtape_data.open_info_ptr;
	mpfmip = mtape_data.pfm_info_ptr;
	arg_code, wfl_code = 0;

	if ltype > BOF_LABEL then do;			/* if writing EOV/EOF, write file mark first */
	     mtape_file_info.block_count = mtape_data.phy_block; /* unload block count */
	     if mtape_attach_info.labeled then do;	/* only if labeled tape */
		call mtape_$order (mtdp, "eof", 1, null, wfl_code);
		if wfl_code ^= 0 then do;		/* can't even write eof */
		     call mtape_$error (mtdp, wfl_code, "^/While writing an End of File mark.");
		     call ABORT_FILE (wfl_code);	/* ask user what to do */
		     go to WFL_RETURN;		/* quit now */
		end;
	     end;
	     mtape_file_info.position_within_file = AT_BOFT; /* reflect current file position */
	     neofs = 2;				/* write 2 file marks after labels */
	     nlp = mtape_file_info.first_file_trail_ptr;	/* init label structure ptr */
	end;
	else do;					/* Header label */
	     if ^mtape_attach_info.labeled then		/* if unlabeled, don't write file mark */
		neofs = 0;
	     else neofs = 1;			/* write only 1 eof after labels */
	     if mtape_file_info.position_within_file ^= AT_BOFH then do; /* not positioned to header */
		call position_in_file (mtdp, fi_ptr, vs_ptr, AT_BOFH, wfl_code); /* do the positioning */
		if wfl_code ^= 0 then		/* return if error */
		     go to WFL_RETURN;
	     end;
	     nlp = mtape_file_info.first_file_lab_ptr;	/* init label structure ptr */
	end;
	call WRITE_LABEL_RECORDS (ltype, wfl_code);	/* do the actual writing of labels */
	if wfl_code ^= 0 then do;			/* this is serious */
	     call ABORT_FILE (wfl_code);		/* ask user what to do */
	     go to WFL_RETURN;
	end;
	if neofs > 0 then do;			/* if we have some eofs to write */
	     call mtape_$order (mtdp, "eof", neofs, null, wfl_code); /* Now write  file mark(s) */
	     if wfl_code ^= 0 then do;
		call mtape_$error (mtdp, wfl_code, "^/While writing an End of File mark.");
		call ABORT_FILE (wfl_code);		/* ask user what to do */
		go to WFL_RETURN;			/* quit now if we can't write eof */
	     end;
	end;
	if ltype = EOF_LABEL then do;			/* if writing EOF labels, position before last EOF */
	     mtape_file_info.end_of_file_set = "1"b;	/* Set marker, this is end of file set */
	     call mtape_$order (mtdp, "bsf", 1, null, wfl_code);
	     mtape_file_info.position_within_file = AT_EOF; /* we are positioned at EOF */
	end;
WFL_RETURN:
	if wfl_code = 0 then			/* if no other error */
	     if arg_ltype ^= ltype then		/* but we wrote EOF instead of EOV label */
		wfl_code = error_table_$no_next_volume; /* tell user he is done */
	arg_code = wfl_code;
	return;
%page;
/* file_search - external entry to search for desired file in file history, and/or on tape */

file_search: entry (arg_mtdp, arg_fi_ptr, arg_vs_ptr, arg_code);

	mtdp = arg_mtdp;				/* copy args */
	fi_ptr = arg_fi_ptr;
	vs_ptr = arg_vs_ptr;
	maip = mtape_data.attach_info_ptr;
	moip = mtape_data.open_info_ptr;
	mpfmip = mtape_data.pfm_info_ptr;
	arg_code, code = 0;

	if mtape_attach_info.labeled then
	     if mtape_vol_set.volume_check > NON_MULT_VOLUME then do; /* can't read this one */
		code = error_table_$uninitialized_volume; /* Give caller an appropriate code */
		go to FS_RETURN;
	     end;

	if mtape_open_info.append then		/* if appending file to end of FS */
	     target_position = AT_EOF;		/* final position must be EOF of last file */
	else if mtape_open_info.extend then		/* if extending existing file */
	     target_position = AT_EOFD;		/* final position must be prior to end of data file */
	else if mtape_open_info.modify then		/* if modifying existing file */
	     target_position = AT_BOFD;		/* go directly to beginning of data */
	else target_position = AT_BOFH;		/* otherwise position to file hdr */
	found = "0"b;
	fi_ptr = mtape_data.fi_head;			/* start at first file */
	do while (fi_ptr ^= null & ^found);
	     found = DESIRED_FILE (0);		/* check each file found for match */
	     if ^found then				/* if no match, advance to next file */
		fi_ptr = mtape_file_info.next_fi_ptr;
	end;
	if found then do;				/* if we found the file in history */
	     call POSITION_TO_FILE (target_position);	/* position to appropriate place */
	     if code ^= 0 then go to FS_RETURN;		/* if error, quit now */
	     if target_position = AT_BOFH then do;	/* if positioned to hdrs, read them */
		call read_file_labels (mtdp, fi_ptr, vs_ptr, htype, code);
		if code ^= 0 then go to FS_RETURN;	/* if error, quit now */
		if htype ^= BOF_LABEL then do;	/* if we found the wrong typw of label */
		     code = error_table_$invalid_file_set_format; /* set code */
		     call mtape_$error (mtdp, code,
			"^/^[EOV^;EOF^] ^a, for file ^d (physical file ^d) on volume ^a",
			htype, "file label found where BOF label expected",
			mtape_file_info.seq_number, mtape_file_info.phy_file + 1, mtape_vol_set.volume_id);
		end;
	     end;
	     if mtape_open_info.append then		/* if appending file.. */
		fi_ptr = mtape_file_info.next_fi_ptr;	/* go to next file_info (should be null) */
	end;
	else do;					/* didn't find file in history, search tape */
	     fi_ptr = mtape_data.fi_tail;		/* start at last known file */
	     if fi_ptr ^= mtape_data.fi_current then do;	/* last file beyond current position? */
		call POSITION_TO_FILE (AT_BOFH);	/* position to beginning of last file */
		if code ^= 0 then go to FS_RETURN;	/* bail out if problems */
	     end;
	     if fi_ptr ^= null then			/* not first search? */
		if mtape_file_info.position_within_file = AT_EOF then do;
		     if mtape_file_info.end_of_file_set then /* and this is last file */
			go to NF_RETURN;		/* return file not found */
		     else fi_ptr = mtape_file_info.next_fi_ptr; /* At EOF, advance to next file */
		end;
		else if mtape_file_info.position_within_file = AT_BOFH & /* if in hdr file */
		     mtape_data.phy_block ^= 0 then do; /* but not beginning */
		     call POSITION_TO_FILE (AT_BOFH);	/* position to re-read hdr */
		     if code ^= 0 then go to FS_RETURN;
		end;
		else if mtape_file_info.position_within_file = AT_BOFD | /* read trailer if */
		     mtape_file_info.position_within_file = AT_IFD | /* one of these */
		     mtape_file_info.position_within_file = AT_EOFD |
		     mtape_file_info.position_within_file = AT_EOFT |
		     (mtape_file_info.position_within_file = AT_BOFT &
		     mtape_data.phy_block ^= 0) then do;
		     call POSITION_TO_FILE (AT_BOFT);	/* position to read trailer label */
		     if code ^= 0 then go to FS_RETURN;
		end;
	     do while (^found & code = 0);		/* search until found it or end of file set */

		call read_file_labels (mtdp, fi_ptr, vs_ptr, htype, code); /* read the label group */
		if code = 0 | code = error_table_$end_of_info then do; /* if no error.. */
		     found = DESIRED_FILE (htype);	/* is this the right file? */
		     if (found & code = error_table_$end_of_info & mtape_open_info.append) | /* if EOFS */
			(^found & code = 0 & htype > BOF_LABEL) then /* or at end of file (section) */
			fi_ptr = mtape_file_info.next_fi_ptr; /* advance the file pointer */
		     if ^found & code = 0 & htype = BOF_LABEL then do; /* No, forward space to trailer label group */
			call POSITION_TO_FILE (AT_BOFT);
			if code ^= 0 then go to FS_RETURN;
		     end;
		end;
	     end;
	     if ^found then do;			/* could not find file on file set */
NF_RETURN:
		code = error_table_$no_file;
		fi_ptr = null;			/* force file info ptr to null */
		go to FS_RETURN;
	     end;
	     code = 0;				/* reset possible EOF status */
	     if mtape_open_info.extend then		/* if extending this file.. */
		call POSITION_TO_FILE (AT_EOFD);	/* position prior to file mark */
	     else if mtape_open_info.last_file |	/* if not extending the last file */
		mtape_open_info.modify then		/* or modifying this file */
		call POSITION_TO_FILE (AT_BOFD);	/* position to beginning of file data  */
	end;
FS_RETURN:
	arg_mtdp = mtdp;				/* copy arguments back in case of volume switch */
	arg_fi_ptr = fi_ptr;
	arg_vs_ptr = vs_ptr;
	arg_code = code;
	return;
%page;
/* setup_file - entry to create and setup the common attributes of a file from the open options */

setup_file: entry (arg_mtdp, arg_fi_ptr, new_section);

	mtdp = arg_mtdp;				/* copy arguments */
	fi_ptr = arg_fi_ptr;
	vs_ptr = mtape_data.vs_current;
	maip = mtape_data.attach_info_ptr;
	moip = mtape_data.open_info_ptr;
	mpfmip = mtape_data.pfm_info_ptr;

	if fi_ptr = null then			/* are we creating new file, or replacing old */
	     call CREATE_FILE_LINK;
	else call truncate_file_set (mtdp);		/* get ride of file history from this point */
	pp = mtape_file_info.prev_fi_ptr;		/* set for previous file */
	if new_section then do;			/* if adding new file section... */
	     mtape_file_info.per_file_info = pp -> mtape_file_info.per_file_info; /* copy per-file info directly */
	     mtape_file_info.section = pp -> mtape_file_info.section + 1; /* increment section */
	     mtape_file_info.first_file_on_volume = "1"b; /* new sections are always 1st */
	     mtape_file_info.end_of_file_set = "1"b;	/* currently is so */
	     pp -> mtape_file_info.end_of_file_set = "0"b;/* previous section is not end */
	     mtape_file_info.first_file_section_ptr = pp -> mtape_file_info.first_file_section_ptr;
	     mtape_file_info.begin_vs_ptr = pp -> mtape_file_info.begin_vs_ptr;
	     pp -> mtape_file_info.position_within_file = NOT_POSITIONED_IN_FILE;
	     call LINK_VS_END;			/* link in the end vs structture */
	end;
	else do;					/* An entirely new file */
	     if pp = null then do;			/* if this is first file.. */
		mtape_file_info.file_set_id = translate (mtape_vol_set.volume_id, UC, LC); /* use 1st volume name */
		prev_seq = 0;			/* set to zero */
	     end;
	     else do;				/* otherwise, get from last file */
		mtape_file_info.file_set_id = pp -> mtape_file_info.file_set_id;
		pp -> mtape_file_info.end_of_file_set = "0"b; /* previous file no longer end */
		prev_seq = pp -> mtape_file_info.seq_number;
	     end;
	     if mtape_open_info.seq_number ^= 0 then	/* if sequence number was specified.. */
		mtape_file_info.seq_number = mtape_open_info.seq_number; /* use it */
	     else mtape_file_info.seq_number = prev_seq + 1; /* otherwise use prev + 1 */
	     if mtape_open_info.file_name ^= "" then	/* if file name specified.. */
		mtape_file_info.file_id = mtape_open_info.file_name; /* use it */
	     else do;				/* must fabricate it */
		pic4 = mtape_file_info.seq_number;	/* convert seq number */
		mtape_file_info.file_id = "FILE" || pic4;
	     end;
	     mtape_file_info.section = 1;
	     mtape_file_info.begin_vs_ptr, mtape_file_info.end_vs_ptr = mtape_data.vs_current;
	     mtape_file_info.first_file_section_ptr = fi_ptr;
	     mtape_file_info.block_size = mtape_open_info.block_length;
	     mtape_file_info.record_size = mtape_open_info.record_length;
	     mtape_file_info.end_of_file_set = "1"b;	/* file set ends with this file */
	     mtape_file_info.native_file = "1"b;	/* file recorded by this PFM */
	     mtape_file_info.unlabeled_file = ^mtape_attach_info.labeled; /* invert labeled flag */
	end;
	arg_fi_ptr = fi_ptr;			/* set file_info ptr for caller */
	return;
%page;
/* ABORT_FILE - int procedure to handle errors when writing file labels and TMs */

ABORT_FILE: proc (acode);

dcl  acode fixed bin (35);

	acode = error_table_$invalid_file_set_format;	/* set default return code */
	call mtape_$user_query (mtdp, Q_ABORT_FILE, code);/* ask user what to do */
	if code ^= 0 then do;			/* user answered no */
	     call mtape_$order (mtdp, "eof", 2, null, code); /* try to write 2 EOFs anyway */
	     return;
	end;

/* user wants to truncate current file section (yes answer) */

	if mtape_file_info.section > 1 then do;		/* case 1: truncate to end of previous section */
	     mtape_data.fi_current = mtape_file_info.prev_fi_ptr; /* point to previous section */
	     call truncate_file_set (mtdp);		/* truncate to this section */
	     call CK_VOL_SWITCH (mtape_vol_set.prev_vs_ptr, "0"b); /* switch volumes */
	     if code ^= 0 then return;		/* return if error */
	     fi_ptr = mtape_data.fi_current;		/* reset file_info ptr */
	     mtape_file_info.end_vs_ptr = vs_ptr;	/* reflect that this is last volume */
	     call POSITION_TO_FILE (AT_BOFT);		/* position before EOV labels */
	     if code ^= 0 then return;		/* return if error */
	     nlp = mtape_file_info.first_file_trail_ptr;	/* init label structure ptr */
	     call WRITE_LABEL_RECORDS (EOF_LABEL, code);	/* write out the EOF sequence */
	     if code ^= 0 then return;		/* return if error */
	     call mtape_$order (mtdp, "eof", 2, null, code); /* write 2 EOF marks */
	     if code = 0 then			/* if no errors.. */
		acode = error_table_$file_aborted;	/* set appropriate return code now */
	     return;				/* and return */
	end;
	else do;					/* case 2: file on one volume */
	     call truncate_file_set (mtdp);		/* truncate and trailers */
	     call POSITION_TO_FILE (AT_BOFH);		/* position to BOF */
	     if code ^= 0 then return;		/* bail out on error */
	     call mtape_$order (mtdp, "eof", 2, null, code); /* write 2 eofs */
	     if code ^= 0 then return;		/* bail out on error */
	     acode = error_table_$file_aborted;		/* can now safely change return code */
	     do lr_ptr = mtape_file_info.last_file_lab_ptr repeat mtape_label_record.prev_lab_ptr
		while (lr_ptr ^= null);
		if mtape_label_record.next_lab_ptr ^= null then /* if not last label record */
		     free mtape_label_record.next_lab_ptr -> mtape_label_record in (based_area);
		free based_label_record in (based_area);/* free label contents */
	     end;
	     if mtape_file_info.first_file_lab_ptr ^= null then
		free mtape_file_info.first_file_lab_ptr -> mtape_label_record in (based_area);
	     if mtape_file_info.prev_fi_ptr = null then do; /* first and only file? */
		free mtape_file_info in (based_area);	/* free up area storage */
		mtape_data.fi_current, mtape_data.fi_head, mtape_data.fi_tail = null; /* wipe out all traces */
		call mtape_$order (mtdp, "rew", 0, null, code); /* rewind to BOT */
	     end;
	     else do;				/* not first file */
		fi_ptr, mtape_data.fi_current, mtape_data.fi_tail = mtape_file_info.prev_fi_ptr;
		free mtape_file_info.next_fi_ptr -> mtape_file_info in (based_area);
		mtape_file_info.next_fi_ptr = null;	/* no next file structure */
		mtape_file_info.end_of_file_set = "1"b; /* this is now end of FS */
		call POSITION_TO_FILE (AT_EOF);	/* position to the end of current file */
	     end;
	end;

     end ABORT_FILE;

%page;
/* DESIRED_FILE - procedure to check if current file is the one we are looking for */

DESIRED_FILE: proc (htype) returns (bit (1) aligned);

dcl  htype fixed bin;

	if htype ^= 0 then				/* if called when searching tape.. */
	     if mtape_open_info.extend |		/* and we want to extend a file */
		mtape_open_info.append |		/* or append a file */
		mtape_open_info.modify |		/* or modify a file */
		mtape_open_info.last_file then	/* or position to last file */
		if htype ^= EOF_LABEL then		/* but are not at end of file */
		     return ("0"b);			/* force read of end of file labels first */
	if (mtape_open_info.append | mtape_open_info.last_file) & /* if need to be at */
	     mtape_file_info.end_of_file_set then	/* end of file set and we are there */
	     return ("1"b);				/* We have found desired file */
	else if mtape_open_info.seq_number ^= 0 |	/* looking for sequence number? */
	     mtape_open_info.file_name ^= "" |		/* looking for file name? */
	     mtape_open_info.replace_id ^= "" then do;	/* looking for file name to replace? */
	     if mtape_file_info.seq_number = mtape_open_info.seq_number then
		return ("1"b);			/* if they match, we have found desired file */
	     if mtape_file_info.file_id = mtape_open_info.file_name then
		return ("1"b);			/* if they match, we have found desired file */
	     if mtape_file_info.file_id = mtape_open_info.replace_id then
		return ("1"b);			/* if they match, we have found desired file */
	end;
	else if mtape_open_info.next_file then do;	/* if looking for next file.. */
	     if htype = BOF_LABEL then		/* if searching tape, make sure we are looking at HDR GRP */
		return ("1"b);			/* We have found it */
	     if mtape_data.fi_current ^= null then	/* if not first file */
		if mtape_file_info.prev_fi_ptr = mtape_data.fi_current then
		     return ("1"b);			/* we have found it */
	end;
	return ("0"b);				/* No match, did not find desired file */

     end DESIRED_FILE;
%page;
/* POSITION_TO_FILE - internal subroutine to position to a particular existing file (defined by mtape_file_info structure),
   and to the desired position within that file */

/* *	Each logical file is made up of 3 physical files. The model
   *	used in determining position within each file is shown below:
   *
   *	----------------------------------------------------
   *	|   FILE    |        FILE    	         |  FILE     |
   *	|           |                          |           |
   *	|  HEADER   |        DATA              | TRAILER   |
   *	|           |                          |           |
   *	|           |                          |           |
   *	----------------------------------------------------
   *	 /\        /\/\          /\           /\/\        /\/\
   *	 |         | |           |            | |         | |
   *	 |__AT_BOFH | |__AT_BOFD   |__AT_IFD     | |__AT_BOFT | |__AT_EOF
   *	 |         |                          |           |
   *	           |__AT_EOFH                  |__AT_EOFD   |__AT_EOFT
*/

POSITION_TO_FILE: proc (target_position);

dcl  target_position fixed bin;

	go to PTF (target_position);			/* do the proper processing */

PTF (1):						/* Position to Beginning of File Header (AT_BOFH) */
	call CK_VOL_SWITCH (mtape_file_info.begin_vs_ptr, "0"b); /* Use 1st file section */
	if code ^= 0 then return;
PTF (9):						/* Position to Beginning of File Section */
	call FILE_RIGHT_POSITION (mtape_file_info.phy_file); /* position to right of file mark */
	if code = 0 then				/* if no error, set final position */
	     mtape_file_info.position_within_file = AT_BOFH;
	return;

PTF (2):						/* Position to End of File Header (AT_EOFH) */
	call CK_VOL_SWITCH (mtape_file_info.begin_vs_ptr, "0"b); /* Use 1st file section */
	if code ^= 0 then return;
	call FILE_LEFT_POSITION (mtape_file_info.phy_file + 1); /* position to left of file mark */
	if code = 0 then				/* if no error, set final position */
	     mtape_file_info.position_within_file = AT_EOFH;
	return;

PTF (3):						/* Position to Beginning of File Data (AT_BOFD) */
PTF (4):						/* Position within file data, not beginning (AT_IFD) */
	call CK_VOL_SWITCH (mtape_file_info.begin_vs_ptr, "0"b); /* Use 1st file section */
	if code ^= 0 then return;
	call FILE_RIGHT_POSITION (mtape_file_info.phy_file + 1); /* position to right of file mark */
	if code = 0 then				/* if no error, set final position */
	     mtape_file_info.position_within_file = AT_BOFD;
	return;

PTF (5):						/* Position to End of File Data (AT_EOFD) */
	call CK_VOL_SWITCH (mtape_file_info.end_vs_ptr, "1"b); /* Use last file section (if > 1) */
	if code ^= 0 then return;
	call FILE_LEFT_POSITION (mtape_file_info.phy_file + 2); /* position to left of file mark */
	if code = 0 then				/* if no error, set final position */
	     mtape_file_info.position_within_file = AT_EOFD;
	return;

PTF (6):						/* Position to Beginning of file trailer (AT_BOFT) */
	call CK_VOL_SWITCH (mtape_file_info.end_vs_ptr, "1"b); /* Use last file section (if > 1) */
	if code ^= 0 then return;
	call FILE_RIGHT_POSITION (mtape_file_info.phy_file + 2); /* position to right of file mark */
	if code = 0 then				/* if no error, set final position */
	     mtape_file_info.position_within_file = AT_BOFT;
	return;

PTF (7):						/* Position to End of file trailer (AT_EOFT) */
	call CK_VOL_SWITCH (mtape_file_info.end_vs_ptr, "1"b); /* Use last file section (if > 1) */
	if code ^= 0 then return;
	call FILE_LEFT_POSITION (mtape_file_info.phy_file + 3); /* position to left of file mark */
	if code = 0 then				/* if no error, set final position */
	     mtape_file_info.position_within_file = AT_EOFT;
	return;

PTF (8):						/* Position to End of file (AT_EOF) */
	call CK_VOL_SWITCH (mtape_file_info.end_vs_ptr, "1"b); /* Use last file section (if > 1) */
	if code ^= 0 then return;
PTF (10):						/* Position to End of File Section */
	call FILE_RIGHT_POSITION (mtape_file_info.phy_file + 3); /* position to right of file mark */
	if code = 0 then				/* if no error, set final position */
	     mtape_file_info.position_within_file = AT_EOF;


     end POSITION_TO_FILE;
%page;
/* CK_VOL_SWITCH - internal subroutine to check if a volume switch is necessary to get to
   desired position within file and adjust fi_ptr for proper file section */

CK_VOL_SWITCH: proc (nvp, last_file_section);

dcl  nvp ptr;
dcl  last_file_section bit (1) aligned;

	if nvp ^= mtape_data.vs_current then do;	/* volume switch required? */
	     call mtape_$volume_switch (mtdp, nvp, code); /* yes, do it */
	     if code ^= 0 then do;			/* no go? */
		call mtape_$error (mtdp, code,
		     "^/Could not switch to volume ""^a"" at volume switch time",
		     nvp -> mtape_vol_set.volume_name);
		return;
	     end;
	     vs_ptr = mtape_data.vs_current;		/* set vol ptr for new vol */
	     if ^last_file_section then		/* if we went to BOF */
		fi_ptr = mtape_file_info.first_file_section_ptr; /* set file ptr to first section */
	     else do;				/* we went to EOF */
		term = "0"b;
		do nfip = fi_ptr repeat nfip -> mtape_file_info.next_fi_ptr while (^term);
		     if nfip -> mtape_file_info.first_file_section_ptr ^=
			mtape_file_info.first_file_section_ptr then do;
			term = "1"b;		/* found it, it is last file info */
			fi_ptr = nfip -> mtape_file_info.prev_fi_ptr;
		     end;
		     else if nfip -> mtape_file_info.next_fi_ptr = null then do; /* last file */
			term = "1"b;
			fi_ptr = nfip;		/* this is it */
		     end;
		end;
	     end;
	end;

     end CK_VOL_SWITCH;

/* FILE_LEFT_POSITION - internal procedure to position to left of desired file mark */

FILE_LEFT_POSITION: proc (target_file);

dcl  target_file fixed bin;

	call FILE_RIGHT_POSITION (target_file);		/* first position to right of file */
	if code = 0 then
	     call mtape_$order (mtdp, "bsf", 1, null, code); /* now backspace 1 file to desired position */

     end FILE_LEFT_POSITION;
%page;
/* FILE_RIGHT_POSITION - internal subroutine to position to the right of the specified file mark */

FILE_RIGHT_POSITION: proc (target_file);

dcl  target_file fixed bin;

	if target_file >= mtape_data.phy_file then do;	/* Positioned before desired file? */
	     space_files = target_file - mtape_data.phy_file; /* yes, must position forward */
	     forward = "1"b;
	end;
	else do;					/* No, Positioned past desired file */
	     if mtape_file_info.first_file_on_volume then do; /* if this is true, can rewind */
		call REWIND_TO_BOF;			/* rewind tape */
		if code ^= 0 then return;
		space_files = target_file;
	     end;
	     else do;				/* no must backspace */
		space_files = mtape_data.phy_file - target_file; /* position backward */
		if space_files ^= 0 then		/* only back up if not at right position */
		     space_files = space_files + 1;

/* must back up 1 more and fwd space 1 file to get to beginning of desired file */

		forward = "0"b;
	     end;
	end;
	if space_files ^= 0 then do;			/* if we have to position.. */
	     if ^forward then do;			/* go backward n files? */
		call mtape_$order (mtdp, "bsf", space_files, null, code);
		if code = 0 then do;
		     space_files = 1;		/* must now forward space 1 file */
		     forward = "1"b;		/* set switch for error message */
		end;
	     end;
	     if code = 0 & space_files ^= 0 then
		call mtape_$order (mtdp, "fsf", space_files, null, code);
	     if code ^= 0 then do;
		call mtape_$error (mtdp, code,
		     "^/While ^[forward ^;back^]spacing ^d files to position to file ""^a"".",
		     forward, space_files, mtape_file_info.file_id);
		return;
	     end;
	end;
	mtape_data.fi_current = fi_ptr;		/* reset external position indicator */

     end FILE_RIGHT_POSITION;
%page;
/* REWIND_TO_BOF - internal procedure to rewind volume and forward space over volume labels */

REWIND_TO_BOF: proc;

	call mtape_$order (mtdp, "rew", 0, null, code);
	if code ^= 0 then do;
	     call mtape_$error (mtdp, code,
		"^/Attempting to rewind volume ^a to position to beginning of file ^a",
		mtape_vol_set.volume_id, mtape_file_info.file_id);
	     return;
	end;

/* now space over volume labels */

	if mtape_vol_set.number_of_vol_labels > 0 then do;/* only if a labeled volume */
	     call mtape_$order (mtdp, "fsr", mtape_vol_set.number_of_vol_labels, null, code);
	     if code ^= 0 then
		call mtape_$error (mtdp, code,
		     "^/Attempting to forward space over volume labels on volume ^a, to position to beginning of file ^a",
		     mtape_vol_set.volume_id, mtape_file_info.file_id);
	end;

     end REWIND_TO_BOF;

/* CREATE_FILE_LINK - internal procedure to create a file info structure and link it in */

CREATE_FILE_LINK: proc;

	call mtape_$alloc (mtdp, MTAPE_ALLOC_FI, mtape_data.fi_tail, 0, fi_ptr);
	mtape_data.fi_current, mtape_data.fi_tail = fi_ptr; /* Link this file info structure in */
	if mtape_data.fi_head = null then do;		/* if this is first file */
	     mtape_data.fi_head = fi_ptr;		/* Set link head also */
	     mtape_file_info.first_file_on_volume = "1"b; /* set indicator for later positioning */
	end;
	mtape_file_info.position_within_file = AT_BOFH;	/* set initial position to hdr file */
	mtape_file_info.phy_file = mtape_data.phy_file;	/* and set file number of header */

     end CREATE_FILE_LINK;

/* LINK_VS_END - internal procedure to link in the file_info.vs_end ptr */

LINK_VS_END: proc;

dcl  prevp ptr;
dcl  term bit (1) aligned;

	term = "0"b;
	do prevp = fi_ptr repeat prevp -> mtape_file_info.prev_fi_ptr while (prevp ^= null & ^term);
	     if prevp -> mtape_file_info.first_file_section_ptr ^= mtape_file_info.first_file_section_ptr then
		term = "1"b;
	     else prevp -> mtape_file_info.end_vs_ptr = mtape_data.vs_current;
	end;

     end LINK_VS_END;
						/* WRITE_LABEL_RECORDS - int procedure to write out label records as specified by PFM */

WRITE_LABEL_RECORDS: proc (ltype, acode);

dcl  ltype fixed bin;
dcl  (acode, code) fixed bin (35);

	acode = 0;				/* reset return code */
	if mtape_attach_info.labeled then do;		/* if a labeled tape */
RECODE_LABELS:					/* target to change EOV to EOF labels */
	     code = 0;				/* reset error code */
	     do lab_num = 1 by 1 while (code ^= error_table_$end_of_info); /* write until told to quit */
		call mtape_data.encode_file_labels (mtdp, mtape_data.tlb, lab_num, ltype, convert, code);
		if code ^= 0 then			/* if error from encode routine */
		     if code = error_table_$no_next_volume then /* user does not have another volume */
			if ltype = EOV_LABEL then do; /* and it is for end of volume */
			     ltype = EOF_LABEL;	/* then write EOF label */
			     go to RECODE_LABELS;	/* instead */
			end;
		if code = 0 then do;
		     if nlp = null then do;		/* if no previous label structure, allocate it */
			if ltype > BOF_LABEL then	/* if EOF or EOV labels.. */
			     call init_label_record (mtdp, mtape_file_info.last_file_trail_ptr,
				mtape_file_info.first_file_trail_ptr, lr_ptr, mtape_data.lab_buf_len);
			else call init_label_record (mtdp, mtape_file_info.last_file_lab_ptr,
				mtape_file_info.first_file_lab_ptr, lr_ptr, mtape_data.lab_buf_len);
		     end;
		     else lr_ptr = nlp;		/* it does exist, use it */
		     nlp = mtape_label_record.next_lab_ptr; /* update ptr for next label */
		     mtape_label_record.conversion = convert; /* set conversion indicator & copy label */
		     based_label_record = mtape_data.tlb -> mtape_label_record.lab_ptr -> based_label_record;
		     call mtape_$write_label (mtdp, lr_ptr, code); /* write it out */
		     if code ^= 0 then		/* if unrecoverable error */
			if code ^= error_table_$eov_on_write then do; /* but not EOV */
			     call mtape_$error (mtdp, code,
				"^/Attempting to write ^[BOF^;EOV^;EOF^] file label ^d on volume ^a.",
				ltype, lab_num, mtape_vol_set.volume_id);
			     acode = code;		/* report error to caller */
			     return;
			end;
			else code = 0;		/* ignore EOV status for now */
		end;
	     end;
	end;

     end WRITE_LABEL_RECORDS;
%page;
/* DECODE_UNLABELED_FILE - internal procedure to determine file position and file in file info  */

DECODE_UNLABELED_FILE: proc;

	if fi_ptr = null then do;			/* if file_info does not exist.. */
	     ltype = BOF_LABEL;			/* must be BOF */
	     call CREATE_FILE_LINK;			/* create the file info structure */
	     mtape_file_info.phy_file = mtape_data.position.phy_file; /* copy file number */
	     pp = mtape_file_info.prev_fi_ptr;		/* make lines shorter */
	     if pp ^= null then			/* if there was a previous file */
		if pp -> mtape_file_info.begin_vs_ptr ^= mtape_data.vs_current then do; /* new section */
		     mtape_file_info.section = pp -> mtape_file_info.section + 1; /* increment */
		     mtape_file_info.per_file_info = pp -> mtape_file_info.per_file_info;
		     mtape_file_info.first_file_on_volume = "1"b; /* set for later positioning */
		     mtape_file_info.first_file_section_ptr = pp -> mtape_file_info.first_file_section_ptr;
		     mtape_file_info.begin_vs_ptr = pp -> mtape_file_info.begin_vs_ptr;
		end;
		else ;
	     else do;
		mtape_file_info.section = 1;		/* beginning of new file */
		if pp = null then do;		/* first file? */
		     mtape_file_info.seq_number = 1;	/* yes, init seq number */
		     mtape_file_info.first_file_on_volume = "1"b; /* set for more efficient positioning */
		end;
		else mtape_file_info.seq_number = pp -> mtape_file_info.seq_number + 1;
		mtape_file_info.unlabeled_file = "1"b;	/* set this indicator */
		mtape_file_info.begin_vs_ptr = vs_ptr;
		mtape_file_info.first_file_section_ptr = fi_ptr;
	     end;
	     call LINK_VS_END;			/* link in the end vol ptr */
	end;
	else if mtape_data.phy_file = mtape_file_info.phy_file then do; /* currently positioned */
	     ltype = BOF_LABEL;			/* within file, its beginning */
	     if mtape_file_info.prev_fi_ptr ^= null then
		mtape_file_info.prev_fi_ptr -> mtape_file_info.position_within_file =
		     NOT_POSITIONED_IN_FILE;
	     mtape_data.fi_current = fi_ptr;		/* this is now current file */
	end;
	else do;					/* either EOF, EOV, or EOFS */
	     call mtape_$order (mtdp, "fsr", 1, null, rfl_code); /* forward space & ck for EOF status */
	     if rfl_code ^= 0 & rfl_code ^= error_table_$end_of_info then do; /* a real error */
		call mtape_$error (mtdp, rfl_code, "^/^a ^a, file ^d to test for EOV",
		     "Attempting to forward space a block on Unlabeled volume",
		     mtape_vol_set.volume_name, mtape_data.phy_file);
		return;
	     end;
	     if rfl_code = 0 then do;			/* if no eof status, we were at eof */
		ltype = EOF_LABEL;
		call mtape_$order (mtdp, "bsr", 1, null, rfl_code); /* backspace 1 file mark */
		if rfl_code ^= 0 then
		     call mtape_$error (mtdp, rfl_code,
			"^/Positioning to the end of an unlabeled file");
	     end;
	     else do;				/* 2 consecutive EOF statuses; EOV or EOFS? */
		if mtape_vol_set.next_vs_ptr ^= null then do; /*  next volume defined? */
		     ltype = EOV_LABEL;		/* yes, by definition, this is EOV */
		     rfl_code = 0;			/* reset EOF status code */
		end;
		else do;				/* end of file set */
		     mtape_file_info.end_of_file_set = "1"b; /* Set marker */
		     call mtape_$order (mtdp, "bsf", 1, null, rfl_code); /* backspace 1 file mark */
		     if rfl_code ^= 0 then
			call mtape_$error (mtdp, rfl_code,
			     "^/Positioning to the tape mark prior to the end of file set.");
		     rfl_code = error_table_$end_of_info; /* reset EOF code */
		end;
	     end;
	end;

     end DECODE_UNLABELED_FILE;
%page;
%include mtape_data;
%page;
%include mtape_label_record;

%include mtape_err_stats;
%page;
%include mtape_vol_set;
%page;
%include mtape_file_info;
%page;
%include mtape_attach_info;

%include mtape_pfm_info;
%page;
%include mtape_open_close_info;
%page;
%include mtape_constants;

     end pfm_utils_;
