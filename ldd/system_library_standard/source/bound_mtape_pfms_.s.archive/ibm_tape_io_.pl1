/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(88-09-16,Farley), approve(88-10-06,MCR8003),
     audit(88-10-06,Fawcett), install(88-10-10,MR12.2-1152):
     Correct a problem of getting a hardware status of "Transmission parity
     alert" when writing the data to tape in ascii mode.  This requires the
     zeroing of the reserved fields in the RDW, SDW and BDW structures.
  2) change(00-01-26,Schroth), approve(00-01-26,MECR-Y2K):
     Changed expiry date checking to use new pfm_utils_$label_unexpired to
     verify if a file has expired.
                                                   END HISTORY COMMENTS */


/****^  HIST
ORY COMMENTS:
  1) change(85-06-10,GWMay), approve(), audit(), install():
     modified call to pfm_utils_$position_in_file to use
     the position constant required by the routine rather than a numeric
     value.
  2) change(88-02-03,GWMay), approve(88-02-03,MCR7837),
     audit(88-04-12,Farley), install(88-04-19,MR12.2-1039):
     Changed to process user specified labels correctly.
     Changed to correctly set the RCP auth code in the header.
                                                   END HISTORY COMMENTS */

ibm_tape_io_: procedure;

/* format: style4 */

/* *	This program is known as a tape Per-Format module and runs under
   *	control of the mtape_ I/O module and is meant to process tape volumes
   *	and files in IBM standard format.
   *
   *	This Per-Format module uses the following PFM dependent option flags:
   *
   *	mtape_open_info.pfm_opt_sw (1) = "1"b = -dos
   *	mtape_open_info.pfm_opt_sw (1) = "0"b = -no_dos
   *	mtape_open_info.pfm_opt_sw (2) = "1"b = -system_use
   *	mtape_open_info.pfm_opt_sw (2) = "0"b = -no_system_use
   *
   *	Modification History:
   *
   *	Created by J. A. Bush 11/01/82
   *	Modified by J. A. Bush 11/10/83 for performance improvements
   *	Modified by Greg Texada 11/21/84 to pad U format records too.
*/

/*		ARGUMENT DATA		*/

dcl  arg_mtdp ptr;					/* Pointer to the mtape data structure */
dcl  arg_code fixed bin (35);				/* Return error code */
dcl  arg_info_ptr ptr;				/* Pointer to Order data from iox_$control call */
dcl  arg_io_call_infop ptr;				/* Pointer to io_call control info structure */
dcl  arg_order_name char (*);				/* Name of Control order to be processed */
dcl  arg_lr_ptr ptr;				/* Pointer to current label record structure */
dcl  arg_labno fixed bin;				/* label record within label group */
dcl  arg_type fixed bin;				/* 1 => BOF; 2 => EOV; 3 => EOF */
dcl  arg_convert fixed bin;				/* Label record conversion indicator */

/*		AUTOMATIC DATA		*/

dcl  Schecked_labels bit (1) aligned;
dcl  buf_ptr ptr;					/* Auto copy of users buffer pointer */
dcl  buf_len fixed bin (21);				/* Auto copy of users lrec buffer */
dcl  rec_len fixed bin (21);				/* Auto copy of logical record length */
dcl  order_name char (32);				/* Auto copy of order name */
dcl  info_ptr ptr;					/* Auto copy of order info pointer */
dcl  user_label_data char (76);			/* storage for user label data */
dcl  auth_code char (3) aligned;
dcl  today char (6);
dcl  temp_fmt char (3);
dcl  temp_mode char (6);
dcl  (term, long_record, output) bit (1) aligned;
dcl  (nvp, nlp, move_ptr) ptr;
dcl  (i, desc_type, label_type, n_segs, uln, open_idx, slab) fixed bin;
dcl  (move_len, crl, bytes_remaining, bytes_processed) fixed bin (21);
dcl  dbl bit (18);
dcl  pic1 picture "9";
dcl  pic2 picture "99";
dcl  pic4 picture "9999";
dcl  pic5 picture "99999";
dcl  pic6 picture "999999";
dcl  (code, fl_code) fixed bin (35);

/*		CONSTANT DATA		*/

dcl  myname char (32) int static options (constant) init ("ibm_tape_io_");
dcl  LABEL_LENGTH fixed bin (21) int static options (constant) init (80); /* length of label records in bytes */
dcl  MAX_IBM_RECORD_SIZE fixed bin int static options (constant) init (99999);
dcl  WRITING bit (1) aligned int static options (constant) init ("1"b);
dcl  OPENING bit (1) aligned int static options (constant) init ("0"b);
dcl  NON_MOD_FOUR fixed bin int static options (constant) init (1);
dcl  IBM_ASCII_PAD_CHAR char (1) int static options (constant) init (" ");
dcl  IBM_EBCDIC_PAD_CHAR char (1) int static options (constant) init ("_");
dcl  CW_LENGTH fixed bin int static options (constant) init (4); /* Length of an record and segment descriptors */
dcl  (SEG_B_E init (0),				/* Record begins and ends in this segment */
     SEG_B_NE init (1),				/* Record begins but does not end in this segment */
     SEG_NB_E init (2),				/* Record ends but does not begin in this segment */
     SEG_NB_NE init (3))				/* Record neither begins nor ends in this segment */
	fixed bin int static options (constant);
dcl  U_LABEL_ID (3) char (3) int static options (constant) init
	("UHL", "UTL", "UTL");
dcl  IBM_FORMAT_CODES (0:7) char (3) int static options (constant) init
	("   ", "U  ", "F  ", "V  ", "VS ", "FB ", "VB ", "VBS");
dcl  LC char (26) int static options (constant) init
	("abcdefghijklmnopqrstuvwxyz");
dcl  UC char (26) int static options (constant) init
	("ABCDEFGHIJKLMNOPQRSTUVWXYZ");

/*		EXTERNAL STATIC DATA	*/

dcl  error_table_$end_of_info fixed bin (35) ext static;
dcl  error_table_$eov_on_write fixed bin (35) ext static;
dcl  error_table_$long_record fixed bin (35) ext static;
dcl  error_table_$invalid_record_desc fixed bin (35) ext static;
dcl  error_table_$bad_file fixed bin (35) ext static;
dcl  error_table_$no_operation fixed bin (35) ext static;
dcl  error_table_$no_file fixed bin (35) ext static;
dcl  error_table_$no_next_volume fixed bin (35) ext static;
dcl  error_table_$invalid_label_format fixed bin (35) ext static;
dcl  error_table_$unimplemented_version fixed bin (35) ext static;
dcl  error_table_$uninitialized_volume fixed bin (35) ext static;

/*		BUILTIN FUNCTIONS		*/

dcl  (addr, binary, bit, copy, fixed, hbound, index, lbound, length,
     ltrim, mod, null, rel, size, substr, translate) builtin;
dcl  conversion condition;

/*		EXTERNAL ENTRIES		*/

dcl  authenticate_ entry (char (*)) returns (char (3) aligned);
dcl  ebcdic_to_ascii_ entry (char (*), char (*));
dcl  ascii_to_ebcdic_ entry (char (*), char (*));

/* 		BASED VARIABLES		*/

dcl  based_area area based (mtape_data.areap);
dcl  based_label_record char (LABEL_LENGTH) based (mtape_label_record.lab_ptr);
dcl  based_lrec_data char (move_len) based;		/* to move data to/from users buffer */
dcl  based_lrec_index (buf_len) char (1) based (mtape_data.arg_buf_ptr); /* to increment users buffer ptr */

dcl  1 bdw unaligned based (mtape_data.cur_buf_ptr),	/* block descriptor word */
       2 length bit (18),				/* binary length of block */
       2 reserved fixed bin (17);			/* reserved for future system use (MBZ) */

dcl  1 vb_record unaligned based (mtape_data.log_record_ptr), /* Template for V/VB formated records */
       2 rdw,					/* record descriptor word */
         3 length bit (18),				/* binary length of record */
         3 reserved fixed bin (17),			/* reserved for future system use (MBZ) */
       2 rdata char (move_len);			/* logical record data */

dcl  1 vbs_record unaligned based (mtape_data.log_record_ptr), /* Template for VS/VBS formated records */
       2 sdw,					/* Segment descriptor word */
         3 length bit (18),				/* binary length of record */
         3 span_indicator fixed bin (8),		/* controls of segments in record */
         3 reserved fixed bin (8),			/* reserved for future system use (MBZ) */
       2 rdata char (move_len),			/* logical record data */
       2 nxt_lrec char (1);				/* to position to nxt record */
%page;
/* pfm_init - entry to initialize the Per-Format module, setting up file and volume
   processing parameters and determining correctness of current volume */

pfm_init: entry (arg_mtdp, arg_code);

	call SETUP;				/* initialize our enviornment */
	call CHECK_VERSION (mtdp, mtape_data_version_1, "mtape_data"); /* check version of this structure every time */

/* When the pfm_init entry is called for the first time we must allocate a label record structure to
   read tape labels into. We must also check the various structure versions to make sure
   we know what the caller is talking about. */

	if mtape_data.tlb = null then do;
	     mcip = mtape_data.close_info_ptr;		/* set ptr to close into structure */
	     call pfm_utils_$init_label_record (mtdp, null, null, mtape_data.tlb, LABEL_LENGTH);
	     mtape_data.tlb -> mtape_label_record.conversion = MTAPE_CV_UC_EBCDIC; /* IBM labels in EBCDIC */
	     call CHECK_VERSION (mtape_data.tlb, mtape_lr_version_1, "mtape_label_record");
	     call CHECK_VERSION (vs_ptr, mtape_vs_version_1, "mtape_vol_set");
	     call CHECK_VERSION (maip, mtape_attach_info_version_1, "mtape_attach_info");
	     call CHECK_VERSION (moip, mtape_open_info_version_1, "mtape_open_info");
	     call CHECK_VERSION (mcip, mtape_close_info_version_1, "mtape_close_info");
	     call CHECK_VERSION (mpfmip, mtape_pfm_info_version_1, "mtape_pfm_info");
	     call mtape_$alloc (mtdp, MTAPE_ALLOC_FI, null, 0, fi_ptr); /* allocate dummy file_info structure */
	     call CHECK_VERSION (fi_ptr, mtape_fi_version_1, "mtape_file_info"); /* and check its version */
	     free mtape_file_info in (based_area);	/* we can free it now */

/* initialize the pfm_info structure for this PFM */

	     mtape_pfm_info.open_modes_allowed (1) = Sequential_input;
	     mtape_pfm_info.open_modes_allowed (2) = Sequential_output;
	     mtape_pfm_info.bof_prefix = "HDR";
	     mtape_pfm_info.eov_prefix = "EOV";
	     mtape_pfm_info.eof_prefix = "EOF";
	     mtape_pfm_info.module_id = "IBM";
	     mtape_pfm_info.no_labels_ok = "1"b;
	     mtape_pfm_info.multi_volumes_ok = "1"b;
	     mtape_pfm_info.extended_error_recovery = "0"b;
	end;
	if mtape_vol_set.volume_type = Volume_ibm_tape then /* If an ibm tape.. */
	     call CHECK_VOL_LABELS (mtape_vol_set.volume_check); /* check the volume labels */
	else do;					/* Not an ibm tape, don't bother to read labels */
	     if mtape_vol_set.volume_type = Volume_blank |
		mtape_vol_set.volume_type = Volume_unreadable then
		mtape_vol_set.volume_check = BLANK_VOLUME;
	     else if mtape_vol_set.volume_type = Volume_unknown_format then
		mtape_vol_set.volume_check = UNLABELED_VOLUME;
	     else mtape_vol_set.volume_check = RECOG_FORMAT_VOLUME;
	     mtape_data.lab_buf_len = LABEL_LENGTH;	/* set in case subsequent volumes are labeled */
	end;

pfm_init_return:					/* target of non-local gotos */
	arg_code = code;
	return;
%page;
/* file_open - entry to do format specific processing in opening the file
   or file set (i.e. read and write file labels) */

file_open: entry (arg_mtdp, arg_code);

	call SETUP;				/* initialize our enviornment */
	call SET_OPEN_IDX;				/* determine what type of processing to do */
	call pfm_utils_$file_search (mtdp, fi_ptr, vs_ptr, code); /* search for the file */
	if code ^= 0 & open_idx ^= 1 then		/* if error and not creating file.. */
	     go to open_return;			/* quit now */
	go to open_action (open_idx);			/* do the appropriate thing */

open_action (0):					/* open for input */
	call CHECK_USER_LABELS (BOF_LABEL);		/* go see if user labels to be processed */
	call SET_FILE_ATTRIBUTES;			/* complete file attributes from open desc */
	go to open_return;

open_action (1):					/* Open for output, creation */
	if code = 0 |				/* if no error */
	     code = error_table_$no_file |		/* or if could not find file */
	     code = error_table_$uninitialized_volume then do; /* or if bad vol label */
	     if NEED_TO_INIT_VOLUME () then do;		/* if volume requires initialization.. */
		call INIT_VOL_LABELS;		/* initialize the volume labels */
		if code ^= 0 then go to open_return;
	     end;
	     code = 0;				/* reset possible error code */
	     call SETUP_NEW_FILE;			/* setup new file info structure */
	     if code ^= 0 then go to open_return;
	     call pfm_utils_$write_file_labels (mtdp, BOF_LABEL, code); /* go write the file header labels */
	     if code = 0 then			/* if no error */
		if mtape_vol_set.volume_end then	/* did we run out of tape? */
		     call EOV_ON_WRITE (OPENING);	/* yes, do volume switch now */
	end;
	go to open_return;

open_action (2):					/* open for output, extend existing file */
	mtape_data.phy_block = mtape_file_info.block_count; /* preset block number */
open_action (3):					/* open for output, modify existing file */
	call pfm_utils_$truncate_file_set (mtdp);	/* get rid of EOF labels if extend | modify */
	mtape_file_info.gen_version = mod (mtape_file_info.gen_version, 100) + 1; /* increment version */
open_return:
	arg_code = code;				/* return error code */

	return;
%page;
/* file_close - entry to do format specific processing in closing the file
   or file set (i.e. read and write file trailer labels) */

file_close: entry (arg_mtdp, arg_code);

	call SETUP;				/* initialize our enviornment */
	mcip = mtape_data.close_info_ptr;		/* set up close info ptr too */

	if mtape_open_info.open_mode = Sequential_input then /* input operation? */
	     output = "0"b;				/* yes, reset output flag */
	else output = "1"b;				/* true if sqo or sqio */
	if output & mtape_data.error_lock ^= error_table_$no_next_volume then do; /* if writing tape */
	     if mtape_data.error_lock = 0 then do;	/* flush out only if possible */
		if mtape_data.processed > mtape_data.buffer_offset then /* if we have some unwritten data */
		     call WRITE_BLOCK;		/* write a short block */
		call mtape_$flush_buffers (mtdp, code); /* write out all queued buffers */
		if code ^= 0 then			/* if some error writing data */
		     if code = error_table_$eov_on_write then /* Is it end of tape? */
			call EOV_ON_WRITE (WRITING);	/* Go close out volume and initiate volume switch */
		if code ^= 0 then
		     go to close_file_return;
	     end;
	     call pfm_utils_$write_file_labels (mtdp, EOF_LABEL, code); /* write out EOF labels */
	     if code ^= 0 then			/* error writing labels.. */
		go to close_file_return;
	end;
	else do;					/* input operation, must make sure tape is stoped */
	     call mtape_$stop_tape (mtdp, code);
	     if code ^= 0 then
		go to close_file_return;
	end;

	Schecked_labels = "0"b;
						/* USER trailers can only be returned when */
						/* positioned after the file data */
	if ^output & mtape_file_info.position_within_file = AT_EOF then do;
	     call CHECK_USER_LABELS (EOF_LABEL);	/* go see if user labels to be processed */
	     Schecked_labels = "1"b;
	end;

	if mtape_close_info.position ^= 0 then do;	/* if not leaving tape where it is.. */
	     call pfm_utils_$position_in_file (mtdp, fi_ptr,
		vs_ptr, mtape_close_info.position, code);
	     if ^output & code = 0 & ^Schecked_labels &
		mtape_file_info.position_within_file = AT_EOFH then
		call CHECK_USER_LABELS (EOF_LABEL);
	end;

close_file_return:
	arg_code = code;				/* copy return error code (if any) */
	return;
%page;
/* read - entry to read format specific logical records from the current file */

read: entry (arg_mtdp, arg_code);

	mtdp = arg_mtdp;				/* copy arguments */
	buf_ptr = mtape_data.arg_buf_ptr;		/* If = null, return length of next record */
	buf_len = mtape_data.arg_buf_len;
	code, rec_len = 0;				/* initialize return record length */
	long_record = "0"b;				/* init long record flag */
	if mtape_data.remain <= 0 then		/* Do we need to read in a block? */
	     call GET_NXT_RECORD;			/* yes, do it */
	go to READ_TYPE (mtape_data.ad_file_format);	/* process depending on file format */

READ_TYPE (1):					/* Process "U" formated records */
	crl, move_len = mtape_data.remain;		/* user gets entire block */
	move_ptr = mtape_data.log_record_ptr;		/* set pointer to move data from */
	call MOVE_TO_USER;				/* move the data to the users buffer */
	go to read_return;

READ_TYPE (2):					/* Process "F/FB" formated records */
	if mtape_data.record_size > mtape_data.remain then/* don't try to move more than we have */
	     crl = mtape_data.remain;
	else crl = mtape_data.record_size;
	move_len = crl;
	move_ptr = mtape_data.log_record_ptr;		/* set pointer to move data from */
	call MOVE_TO_USER;				/* give the user his data */
	go to read_return;

READ_TYPE (3):					/* Process "V/VB" formated records */
	if mtape_data.remain < CW_LENGTH then		/* in case we have mod 4 padded block */
	     call GET_NXT_RECORD;			/* go read next block */
	if mtape_data.hdw_mode ^= MTAPE_HWM_BIN then do;	/* if not binary mode */
	     dbl = vb_record.rdw.length;		/* 9 bit mode, must shift rdw length */
	     substr (dbl, 10) = substr (dbl, 11);
	     crl = binary (bit (substr (dbl, 1, 17), 17), 21);
	end;
	else crl = binary (vb_record.rdw.length, 21);	/* binary mode copy length */
	move_len = crl - CW_LENGTH;
	move_ptr = addr (vb_record.rdata);		/* set pointer to move data from */
	call MOVE_TO_USER;				/* give the user his data */
	go to read_return;
%page;
READ_TYPE (4):					/* Process "VS/VBS" formated records */
	if mtape_data.remain < CW_LENGTH then		/* in case we have mod 4 padded block */
	     call GET_NXT_RECORD;			/* go read next block */
	term = "0"b;				/* reset terminate condition */
	do n_segs = 1 by 1 while (^term);		/* 1 record may be made up of several segments and blocks */
	     call CONVERT_DESC;			/* convert segment descriptor */
	     if n_segs = 1 then			/* if first pass through */
		do while (desc_type ^= SEG_B_E & desc_type ^= SEG_B_NE); /* make sure we get new record */
		mtape_data.remain = mtape_data.remain - crl;
		mtape_data.log_record_ptr = addr (vbs_record.nxt_lrec);
		if mtape_data.remain <= 0 then	/* Do we have to read in a new block? */
		     call GET_NXT_RECORD;
		call CONVERT_DESC;
	     end;
	     move_ptr = addr (vbs_record.rdata);	/* set ptr to move data */
	     call MOVE_TO_USER;			/* give the user his data */
	     if desc_type = SEG_B_E | desc_type = SEG_NB_E then /* end of the record? */
		term = "1"b;			/* yes, set terminate condition */
	     else if mtape_data.remain <= 0 then	/* No, New segment in next block? */
		call GET_NXT_RECORD;		/* yes, do it */
	end;

read_return:
	mtape_data.arg_rec_len = rec_len;		/* give the user the length of the record */
	if code = 0 then				/* if no error but.. */
	     if long_record then			/* we had a longer record than the users buffer */
		code = error_table_$long_record;	/* tell him about it */
	arg_code = code;				/* return error code */
	return;
%page;
/* write - entry to write format specific logical records into the current file */

write: entry (arg_mtdp, arg_code);

	mtdp = arg_mtdp;				/* Copy arguments */
	buf_ptr = mtape_data.arg_buf_ptr;
	buf_len = mtape_data.arg_buf_len;
	code = 0;
	if buf_ptr = null then do;			/* User wants to flush out buffers */
	     if mtape_data.processed > mtape_data.buffer_offset then /* if we have some unwritten data */
		call WRITE_BLOCK;			/* write a short block */
	     call mtape_$flush_buffers (mtdp, code);	/* write out all queued buffers */
	     if code ^= 0 then			/* if some error writing data */
		if code = error_table_$eov_on_write then do; /* Is it end of tape? */
		     call LOAD_PTRS;		/* load up structure pointers */
		     call EOV_ON_WRITE (WRITING);	/* Go close out volume and initiate volume switch */
		end;
	     go to write_return;			/* return to user */
	end;
	go to WRITE_TYPE (mtape_data.ad_file_format);	/* process depending on file format */

WRITE_TYPE (1):					/* Write "U" formated records */
	call LONG_RECORD_CHECK (buf_len, "0"b);		/* check for long record */
	move_len = buf_len;				/* writes entire block */
	move_ptr = mtape_data.log_record_ptr;		/* set pointer to move data to */
	call MOVE_TO_BUFFER (0, 0);			/* move the data to the tape buffer */
	go to write_return;

WRITE_TYPE (2):					/* Write "F/FB" formated records */
	call LONG_RECORD_CHECK (buf_len, "1"b);		/* check for long record */
	if mtape_data.record_size > mtape_data.remain then/* don't try to move more than we have */
	     call WRITE_BLOCK;			/* write out the current block */
	move_len = buf_len;
	move_ptr = mtape_data.log_record_ptr;		/* set pointer to move data from */
	call MOVE_TO_BUFFER (0, 1);			/* give the user his data */
	go to write_return;

WRITE_TYPE (3):					/* Write "V/VB" formated records */
	call LONG_RECORD_CHECK (buf_len, "1"b);		/* check for long record */
	if buf_len + CW_LENGTH > mtape_data.remain then	/* if record won't fit in this block */
	     call WRITE_BLOCK;			/* write out the current block */
	move_len = buf_len;				/* set record length */
	dbl = bit (binary (move_len + CW_LENGTH, 18), 18);/* convert byte count for scw */
	if mtape_data.hdw_mode ^= MTAPE_HWM_BIN then	/* if not binary mode */
	     substr (dbl, 2, 9) = substr (dbl, 3, 8) || "0"b; /* shift out 9th bit */
	vb_record.rdw.length = dbl;			/* set record length */
	vb_record.rdw.reserved = 0;			/* set MBZ field */
	move_ptr = addr (vb_record.rdata);		/* set pointer to move data from */
	call MOVE_TO_BUFFER (CW_LENGTH, CW_LENGTH);	/* copy the users data  */
	go to write_return;
%page;
WRITE_TYPE (4):					/* Write "VS/VBS" formated records */
	call LONG_RECORD_CHECK (buf_len, "1"b);		/* check for long record */
	bytes_remaining = buf_len;			/* set user buffer extents */
	bytes_processed = 0;
	term = "0"b;				/* reset terminate condition */
	do n_segs = 1 by 1 while (^term);		/* 1 record may be made up of several segments and blocks */
	     if bytes_remaining <= mtape_data.remain - CW_LENGTH then do; /* will record fit in this block? */
		term = "1"b;			/* yes, set terminate condition */
		if n_segs = 1 then			/* entire record fit in 1st block? */
		     desc_type = SEG_B_E;		/* Yes, record begins and ends in this segment */
		else desc_type = SEG_NB_E;		/* No, record ends but does not begin in this segment */
		move_len = bytes_remaining;		/* move last part (or all) of record */
	     end;
	     else do;				/* No, record will not fit in current block */
		if n_segs = 1 then			/* is this the first record segment? */
		     desc_type = SEG_B_NE;		/* Yes, record begins but does not end in this segment */
		else desc_type = SEG_NB_NE;		/* No, record neither begins nor ends in this segment */
		move_len = mtape_data.remain - CW_LENGTH; /* use rest of or entire block */
		bytes_remaining = bytes_remaining - move_len; /* decrement remaining bytes to process */
	     end;
	     bytes_processed = bytes_processed + move_len;/* add up total moved so far */
	     dbl = bit (binary (move_len + CW_LENGTH, 18), 18); /* convert byte count for scw */
	     move_ptr = addr (vbs_record.rdata);	/* set ptr to move data */
	     if mtape_data.hdw_mode ^= MTAPE_HWM_BIN then /* if not binary mode */
		substr (dbl, 2, 9) = substr (dbl, 3, 8) || "0"b; /* shift out 9th bit */
	     vbs_record.sdw.length = dbl;		/* set record length */
	     vbs_record.sdw.span_indicator = desc_type;	/* and span indicator */
	     vbs_record.sdw.reserved = 0;		/* set MBZ field */
	     call MOVE_TO_BUFFER (CW_LENGTH, CW_LENGTH + 1); /* copy the users data */
	     buf_ptr = addr (based_lrec_index (bytes_processed + 1)); /* increment users buffer ptr */
	end;

write_return:
	arg_code = code;				/* return error code */
	return;
%page;
/* order - entry to process format specific control orders not recognized by mtape_ */

order: entry (arg_mtdp, arg_order_name, arg_info_ptr, arg_io_call_infop, arg_code);

	call SETUP;				/* initialize our enviornment */
	order_name = arg_order_name;
	info_ptr = arg_info_ptr;

	arg_code = error_table_$no_operation;		/* IBM PFM has no local control operations */
	return;
%page;
/* decode_file_labels - entry to extract info contained in file labels, and fill in file_info structure */

decode_file_labels: entry (arg_mtdp, arg_lr_ptr, arg_labno, arg_type, arg_code);

	call SETUP;				/* initialize our enviornment */
	lr_ptr = arg_lr_ptr;

	on conversion begin;			/* set up handler for conversion errors */
	     code = error_table_$invalid_label_format;	/* set appropriate error code */
	     call mtape_$error (mtdp, code,
		"^/Converting IBM ^a^d label record to binary. Label contents:^/""^a""",
		substr (based_label_record, 1, 3), arg_labno, based_label_record);
	     go to dfl_return;
	end;

	ibm_hdr1P, ibm_hdr2P = mtape_label_record.lab_ptr;/* set up both template ptrs */
	go to LTYPE (arg_type);			/* decode appropriate label type */

LTYPE (1):					/* Beginning of file label */
	if ibm_hdr1.label_id = IBM_L1_ID (IBM_HDR1) then do;
						/* IBM HDR1 label */
	     if arg_labno ^= 1 then
		call mtape_$error (mtdp, error_table_$invalid_label_format, "
Additional IBM HDR1 label found while looking for IBM ^a^d label
for file ^a.  Read continues using:
""^a""",
		     substr (based_label_record, 1, 3), arg_labno,
		     mtape_file_info.file_id,
		     based_label_record);

	     mtape_file_info.file_id = ibm_hdr1.dataset_id;
	     mtape_file_info.file_set_id = ibm_hdr1.dataset_serial;
	     mtape_file_info.seq_number = binary (ibm_hdr1.dataset_sequence, 17);
	     mtape_file_info.generation = binary (ibm_hdr1.generation, 17);
	     mtape_file_info.gen_version = binary (ibm_hdr1.version, 17);
	     mtape_file_info.creation_date = ibm_hdr1.creation;
	     mtape_file_info.expiration_date = ibm_hdr1.expiration;
	     mtape_file_info.section = 1;		/* set for section 1 initially */
	     if mtape_file_info.prev_fi_ptr ^= null then	/* if we have a previous file */
		if mtape_file_info.prev_fi_ptr -> mtape_file_info.file_id = mtape_file_info.file_id then
		     mtape_file_info.section = mtape_file_info.prev_fi_ptr -> mtape_file_info.section + 1;
	     mtape_file_info.pfm_opt_sw (1) = "1"b;	/* DOS file until proven otherwise */
	     if ibm_hdr1.system = IBM_SYS_CODE then	/* tape recorded by this module? */
		mtape_file_info.native_file = "1"b;	/* yes, set flag */
	end;
	else if ibm_hdr2.label_id = IBM_L2_ID (IBM_HDR2) then do; /* IBM HDR2 label */

	     if arg_labno ^= 2 then
		call mtape_$error (mtdp, error_table_$invalid_label_format, "
Additional IBM HDR2 label found while looking for IBM ^a^d label
for file ^a.  Read continues using:
""^a""",
		     substr (based_label_record, 1, 3), arg_labno,
		     mtape_file_info.file_id, based_label_record);

	     mtape_file_info.pfm_opt_sw (1) = "0"b;	/* this is not a DOS file */
	     temp_fmt = ibm_hdr2.format || ibm_hdr2.block_attribute; /* form file format code */
	     if substr (temp_fmt, 2, 1) = "R" then	/* if records are blocked and spanned */
		substr (temp_fmt, 2, 2) = "BS";	/* correct format code */
	     if ibm_hdr2.format = "V" then		/* if variable length format */
		mtape_file_info.buffer_offset = size (bdw) * 4; /* compensate for block descriptor */
	     mtape_file_info.block_size = binary (ibm_hdr2.blksize, 21);
	     mtape_file_info.record_size = binary (ibm_hdr2.lrecl, 21);
	     mtape_file_info.length_mode = NON_MOD_FOUR;	/* set special length mode as default */
	     mtape_file_info.hdw_mode = MTAPE_UNSPECIFIED;
	     mtape_file_info.conversion = MTAPE_CV_EBCDIC;/* EBCDIC conversion by default */
	     if mtape_file_info.native_file then	/* if recorded by mtape_ */
		if ibm_system_use.mode ^= "" then do;	/* and was recorded with "-system_use" */
		     if ibm_system_use.mode = "1" then do; /* if recorded in ASCII mode */
			mtape_file_info.conversion = MTAPE_NO_CONVERSION; /* no conversion necessary */
			mtape_file_info.hdw_mode = MTAPE_HWM_NINE; /* set nine mode */
		     end;
		     else if ibm_system_use.mode = "2" then /* if recorded in EBCDIC */
			mtape_file_info.hdw_mode = MTAPE_HWM_NINE; /* set nine mode */
		     else if ibm_system_use.mode = "3" then do; /* if recorded in binary mode.. */
			mtape_file_info.conversion = MTAPE_NO_CONVERSION; /* no conversion necessary */
			mtape_file_info.hdw_mode = MTAPE_HWM_BIN;
		     end;
		end;
	     mtape_file_info.file_code = temp_fmt;	/* set file code */
	     do i = 0 to hbound (IBM_FORMAT_CODES, 1);	/* set the file format */
		if temp_fmt = IBM_FORMAT_CODES (i) then /* found it */
		     mtape_file_info.file_format = i;
	     end;
	end;
	else if substr (based_label_record, 1,
	     length (U_LABEL_ID (arg_type))) = U_LABEL_ID (arg_type) then /* user labels present */
	     mtape_file_info.user_labels_present = "1"b;
	return;

LTYPE (2):					/* End of volume label */
	if arg_labno = 1 then			/* if IBM EOV1 label */
	     mtape_file_info.block_count = binary (ibm_hdr1.blkcnt, 35); /* extract block count */
	else if arg_labno = 2 then do;		/* if IBM EOV2 label */
	     if mtape_vol_set.volume_check = MTAPE_VOLUME then /* check Multics specific stuff */
		if ibm_system_use.next_volname ^= "" then do; /* if recorded with "-system_use" */
		     if mtape_vol_set.next_vs_ptr = null then do; /* if no VS structure */
			call mtape_$alloc (mtdp, MTAPE_ALLOC_VS, mtape_data.vs_tail, 0, nvp);
			mtape_data.vs_tail = nvp;
		     end;
		     else nvp = mtape_vol_set.next_vs_ptr;
		     if nvp -> mtape_vol_set.volume_name ^=
			ibm_system_use.next_volname then
			nvp -> mtape_vol_set.volume_name = ibm_system_use.next_volname;
		end;
	end;
	else if substr (based_label_record, 1,
	     length (U_LABEL_ID (arg_type))) = U_LABEL_ID (arg_type) then do; /* user labels present */
	     mtape_file_info.user_labels_present = "1"b;
	     call CHECK_USER_LABELS (EOV_LABEL);
	end;

	return;
LTYPE (3):					/* End of file label */
	if ibm_hdr1.label_id = IBM_L1_ID (IBM_EOF1) then do;
	     if arg_labno ^= 1 then
		call mtape_$error (mtdp, error_table_$invalid_label_format, "
Additional IBM EOF1 label found while looking for IBM ^a^d label
for file ^a.  Read continues using:
""^a""",
		     substr (based_label_record, 1, 3), arg_labno,
		     mtape_file_info.file_id, based_label_record);

	     mtape_file_info.block_count = binary (ibm_hdr1.blkcnt, 35); /* extract block count */
	     mtape_file_info.gen_version = binary (ibm_hdr1.version, 17); /* save in case modified | extended file */
	end;
	else if substr (based_label_record, 1,
	     length (U_LABEL_ID (arg_type))) = U_LABEL_ID (arg_type) then /* user labels present */

	     mtape_file_info.user_labels_present = "1"b;

dfl_return:
	arg_code = code;
	return;
%page;
/* encode_file_labels - entry to fill in file labels from info obtained from file_info structure */

encode_file_labels: entry (arg_mtdp, arg_lr_ptr, arg_labno, arg_type, arg_convert, arg_code);

	call SETUP;				/* initialize our enviornment */
	lr_ptr = arg_lr_ptr;
	based_label_record = "";			/* initialize to blanks first */
	arg_convert = MTAPE_CV_UC_EBCDIC;		/* set conversion to uper case ebcdic */
	if arg_labno = 1 then do;			/* init HDR1/EOV1/EOF1 label */
	     if arg_type = EOV_LABEL then		/* if writing EOV sequence */
		if mtape_vol_set.next_vs_ptr = null then do; /* and no next volume */
		     call mtape_$user_query (mtdp, Q_NO_NEXT_VOLUME, code); /* ask user for a new one */
		     if code ^= 0 then		/* if he didn't want to continue */
			go to efl_return;		/* forget it */
		end;
	     ibm_hdr1P = mtape_label_record.lab_ptr;
	     ibm_hdr1.label_id = IBM_L1_ID (arg_type);	/* Now fill it in */
	     ibm_hdr1.dataset_id = substr (mtape_file_info.file_id, 1, length (ibm_hdr1.dataset_id));
	     ibm_hdr1.dataset_serial = substr (mtape_file_info.file_set_id, 1, length (ibm_hdr1.dataset_serial));
	     pic4 = mtape_vol_set.volume_index;
	     ibm_hdr1.volume_sequence = pic4;
	     pic4 = mtape_file_info.seq_number;
	     ibm_hdr1.dataset_sequence = pic4;
	     if mtape_file_info.generation = 0 then	/* if not a file generation */
		ibm_hdr1.generation, ibm_hdr1.version = "";
	     else do;
		pic4 = mtape_file_info.generation;
		ibm_hdr1.generation = pic4;
		pic2 = mtape_file_info.gen_version;
		ibm_hdr1.version = pic2;
	     end;
	     ibm_hdr1.creation = mtape_file_info.creation_date;
	     ibm_hdr1.expiration = mtape_file_info.expiration_date;
	     ibm_hdr1.security = "0";			/* Always unlimited access */
	     if arg_type > BOF_LABEL then do;		/* if EOV/EOF label */
		pic6 = mtape_file_info.block_count;	/* fill in the block count */
		ibm_hdr1.blkcnt = pic6;
	     end;
	     else ibm_hdr1.blkcnt = "000000";		/* used only for EOF/EOV1 records */
	     ibm_hdr1.system = IBM_SYS_CODE;
	     return;
	end;
	else if arg_labno = 2 & ^mtape_file_info.pfm_opt_sw (1) then do; /* init HDR2/EOV2/EOF2 label */
	     ibm_hdr2P = mtape_label_record.lab_ptr;
	     ibm_hdr2.label_id = IBM_L2_ID (arg_type);	/* Now fill it in */
	     ibm_hdr2.format = substr (IBM_FORMAT_CODES (mtape_file_info.file_format), 1, 1);
	     pic5 = mtape_file_info.block_size;
	     ibm_hdr2.blksize = pic5;
	     if mtape_file_info.record_size <= MAX_IBM_RECORD_SIZE then do; /* if it will fit */
		pic5 = mtape_file_info.record_size;
		ibm_hdr2.lrecl = pic5;
	     end;
	     else ibm_hdr2.lrecl = "00000";
	     if mtape_file_info.file_format < 5 then	/* if records are not blocked */
		if mtape_file_info.file_format ^= 4 then/* and not spanned */
		     ibm_hdr2.block_attribute = " ";
		else ibm_hdr2.block_attribute = "S";	/* records are spanned but not blocked */
	     else if mtape_file_info.file_format ^= 7 then/* records are blocked but not spanned */
		ibm_hdr2.block_attribute = "B";
	     else ibm_hdr2.block_attribute = "R";	/* records are both blocked and spanned */
	     if mtape_file_info.section > 1 then	/* if a volume switch has ocurred */
		ibm_hdr2.dataset_position = "1";
	     else ibm_hdr2.dataset_position = "0";
	     do i = 0 to hbound (MTAPE_VALID_DENSITIES, 1) - 1; /* set the density code */
		if mtape_vol_set.volume_density = MTAPE_VALID_DENSITIES (i + 1) then
		     pic1 = i;
	     end;
	     ibm_hdr2.density = pic1;
	     ibm_hdr2.recording_technique = "";		/* odd parity, no translation */
	     ibm_hdr2.control_characters = " ";		/* No control characters used */
	     ibm_hdr2.jobstep_id = "MULTICS /" || ltrim (mtape_file_info.creation_date);
	     if mtape_file_info.pfm_opt_sw (2) then do;	/* if "-system_use" specified */
		if arg_type = EOV_LABEL then do;	/* if at EOV */
		     if mtape_vol_set.next_vs_ptr ^= null then /* and if we have another volume */
			ibm_system_use.next_volname =
			     substr (mtape_vol_set.next_vs_ptr -> mtape_vol_set.volume_name, 1, length (ibm_system_use.next_volname));
		     arg_convert = MTAPE_CV_EBCDIC;	/* don't convert volume id */
		end;
		if mtape_file_info.hdw_mode = MTAPE_HWM_BIN then /* if recording in binary mode */
		     ibm_system_use.mode = "3";
		else if mtape_file_info.conversion = MTAPE_CV_EBCDIC then /* if recording EBCDIC data */
		     ibm_system_use.mode = "2";
		else ibm_system_use.mode = "1";	/* ASCII NINE mode */
	     end;
	     return;
	end;
	else if mtape_open_info.label_entry_present then do; /* if writing user labels */
	     if mtape_file_info.pfm_opt_sw (1) then	/* if DOS file */
		slab = 1;				/* only 1 system label */
	     else slab = 2;				/* otherwise there is 2 */
	     if arg_labno < (10 + slab) then do;	/* and not at max of 9 yet */
		uln = arg_labno - slab;		/* user labels start at 1 */
		user_label_data = "";
		call mtape_open_info.user_label (mtape_data.iocb_ptr, user_label_data, uln, arg_type,
		     mtape_file_info.section, code);	/* call the user label routine */
		if code ^= 0 then			/* if error indicated from user routine */
		     if code = error_table_$end_of_info then /* but it is normal termination */
			go to efl_return;		/* return with end of info indication */
		     else do;			/* some other error report it */
			call mtape_$error (mtdp, code,
			     "^/Calling the user label processing routine to process the ^a^d label record.",
			     U_LABEL_ID (arg_type), uln, slab);
			code = error_table_$end_of_info; /* force user label termination */
			go to efl_return;
		     end;
		pic1 = uln;			/* convert label number to ascii */
		based_label_record = U_LABEL_ID (arg_type) || pic1 || user_label_data; /* form completed user label */
		go to efl_return;
	     end;
	end;
	code = error_table_$end_of_info;		/* terminate label processing */

efl_return:
	arg_code = code;				/* copy error code */
	return;
%page;
/* CHECK_NEW_FILE_SECTION - internal procedure to check consistency of new file section */

CHECK_NEW_FILE_SECTION: proc;

dcl  per_file_overlay char (ov_len) based (addr (mtape_file_info.per_file_info));
dcl  ov_len fixed bin;
dcl  pp ptr;

	code = 0;
	fi_ptr = mtape_file_info.next_fi_ptr;		/* file info will be allocated if null */
	call pfm_utils_$read_file_labels (mtdp, fi_ptr, vs_ptr, label_type, code); /* read new file sect. HDR labels */
	if code ^= 0 then
	     return;
	if label_type ^= BOF_LABEL then do;		/* error if not header labels */
	     code = error_table_$bad_file;
	     call mtape_$error (mtdp, code,
		"^/^[EOV^;EOF^] file label found where BOF label record expected", label_type);
	     return;
	end;
	call SET_FILE_ATTRIBUTES;			/* set up missing pieces */
	pp = mtape_file_info.prev_fi_ptr;		/* get prev file ptr */
	ov_len = (binary (rel (addr (mtape_file_info.per_section_info))) -
	     binary (rel (addr (mtape_file_info.per_file_info)))) * 4;
	if mtape_file_info.record_size ^= pp -> mtape_file_info.record_size then /* if record sizes */
	     if mtape_file_info.record_size = 0 then	/* are ^=, but new section = 0 */
		pp -> mtape_file_info.record_size = 0;	/* make 1st section = 0 too */
	if mtape_file_info.section ^= pp -> mtape_file_info.section + 1 |
	     per_file_overlay ^= addr (pp -> mtape_file_info.per_file_info) -> per_file_overlay then do;
	     code = error_table_$bad_file;		/* set an appropriate error code */
	     call mtape_$error (mtdp, code,
		"^/New file section for File ""^a"" on volume ""^a"" is inconsistent with previous section",
		pp -> mtape_file_info.file_id, mtape_vol_set.volume_id);
	end;
	call mtape_$set_mode (mtdp, "data", mtape_data.hdw_mode, null, code); /* set hardware mode */

     end CHECK_NEW_FILE_SECTION;
%page;
/* CHECK_USER_LABELS - procedure to check if user labels and a user label entry exist */

CHECK_USER_LABELS: proc (htype);

dcl  htype fixed bin;
dcl  flrp ptr;

	if mtape_file_info.user_labels_present then	/* if file contains user labels */
	     if mtape_open_info.label_entry_present then do; /* and user wants to see them */
		if htype > BOF_LABEL then		/* trailer labels? */
		     flrp = mtape_file_info.first_file_trail_ptr; /* yes, search trailer list */
		else flrp = mtape_file_info.first_file_lab_ptr; /* search header list */
		do lr_ptr = flrp repeat mtape_label_record.next_lab_ptr /* search up to 1st user label */
		     while (substr (based_label_record, 1, 1) ^= "U");
		end;
		do lr_ptr = lr_ptr repeat mtape_label_record.next_lab_ptr
		     while (lr_ptr ^= null);		/* send him all labels */
		     user_label_data = substr (based_label_record, 5); /* copy user data */
		     i = fixed (substr (based_label_record, 4, 1), 17); /* get label number */
		     call mtape_open_info.user_label (mtape_data.iocb_ptr, /* call the user label routine */
			user_label_data, i, htype, mtape_file_info.section, (0)); /* ignore error code */
		end;
	     end;

     end CHECK_USER_LABELS;

/* CHECK_VERSION - internal procedure to check struture version numbers */

CHECK_VERSION: proc (s_ptr, req_version, struc_name);

dcl  s_ptr ptr;
dcl  req_version char (8);
dcl  struc_name char (32);

dcl  1 version_check based (s_ptr) aligned,		/* generic structure to check verison number */
       2 version char (8);

	if version_check.version ^= req_version then do;	/* they do not match */
	     code = error_table_$unimplemented_version;	/* set error code */
	     call mtape_$error (mtdp, code,
		"^/^a: Expecting ""^a"" version for ^a structure. Version recorded in received structure is ""^a"".",
		myname, req_version, struc_name, version_check.version);
	     go to pfm_init_return;			/* take non-local goto and return to caller */
	end;

     end CHECK_VERSION;
%page;
/* CHECK_VOL_LABELS - internal procedure to read volume label(s) of a known IBM volume */

CHECK_VOL_LABELS: proc (ridx);

dcl  ridx fixed bin;

	call mtape_$order (mtdp, "rew", 0, null, code);	/* Rewind to load point */
	if code ^= 0 then do;
	     call mtape_$error (mtdp, code,
		"While rewinding volume ^a prior to reading volume label(s)", mtape_vol_set.volume_id);
	     return;
	end;
	nlp = mtape_vol_set.first_vl_ptr;		/* arm the label record ptr */
	ibm_vol1P = mtape_data.tlb -> mtape_label_record.lab_ptr; /* get pointer to VOL1 structure */
	term = "0"b;				/* get us through the first pass */
	do i = 1 by 1 while (^term);			/* read up to HDR1 label */
	     call mtape_$read_label (mtdp, mtape_data.tlb, code); /* read label record */
	     if code ^= 0 then do;
		call mtape_$error (mtdp, code,
		     "Attempting to read IBM volume label record from volume ^a.", mtape_vol_set.volume_id);
		return;
	     end;
	     if ibm_vol1.label_id = IBM_VOL1 then do;	/* if this is VOL1 label */
		if ibm_vol1.owner_id.mult_id = MULTICS_IBM_VERSION then /* only true if recorded by mtape_ */
		     ridx = MTAPE_VOLUME;
		else ridx = NON_MULT_VOLUME;		/* volume recorded by other vendor */
	     end;
	     else if ibm_vol1.label_id = IBM_L1_ID (BOF_LABEL) then do; /* check if HDR1 label */
		term = "1"b;			/* this is the place to stop reading labels */
		mtape_vol_set.number_of_vol_labels = i - 1; /* set number of vol labels */
		ibm_hdr1P = ibm_vol1P;		/* check expiration date of first file */
		if ridx = NON_MULT_VOLUME then	/* check if recorded by tape_ibm_ */
		     if substr (ibm_hdr1.system, 1, 12) = substr (IBM_SYS_CODE, 1, 12) then
			ridx = MULT_PRIOR_VOLUME;	/* yes, tape recorded by tape_ibm_ */
		mtape_vol_set.first_file_unexpired = pfm_utils_$label_unexpired (ibm_hdr1.expiration);	/* check the label date and set the flag */
	     end;
	     if ^term then do;			/* link in this label  (if not HDR1) */
		if nlp = null then do;		/* if no label record structure exists.. */
		     call pfm_utils_$init_label_record (mtdp, mtape_vol_set.last_vl_ptr,
			mtape_vol_set.first_vl_ptr, lr_ptr, LABEL_LENGTH);
		     mtape_label_record.conversion = MTAPE_CV_UC_EBCDIC; /* IBM labels in EBCDIC */
		end;
		else lr_ptr = nlp;			/* it does exist, use it */
		based_label_record = mtape_data.tlb -> mtape_label_record.lab_ptr -> based_label_record;
		nlp = mtape_label_record.next_lab_ptr;	/* update pointer for next label */
	     end;
	end;
	call mtape_$order (mtdp, "bsr", 1, null, code);	/* backspace in front of HDR1 */
	if code ^= 0 then
	     call mtape_$error (mtdp, code,
		"Attempting to backspace over ^a label record of volume ^a.",
		ibm_vol1.label_id, mtape_vol_set.volume_id);

     end CHECK_VOL_LABELS;
%page;
/* CONVERT_DESC - internal procedure to convert RDW for S/VBS formated records */

CONVERT_DESC: proc;

	if mtape_data.hdw_mode ^= MTAPE_HWM_BIN then do;	/* if not binary mode */
	     dbl = vbs_record.sdw.length;		/* 9 bit mode, must shift rdw length */
	     substr (dbl, 10) = substr (dbl, 11);
	     crl = binary (bit (substr (dbl, 1, 17), 17), 21);
	end;
	else crl = binary (vbs_record.sdw.length, 21);	/* binary mode copy length */
	move_len = crl - CW_LENGTH;
	desc_type = vbs_record.sdw.span_indicator;	/* get the control character */
	if desc_type < SEG_B_E | desc_type > SEG_NB_NE then do; /* invalid descriptor */
	     code = error_table_$invalid_record_desc;	/* set appropriate error code */
	     call mtape_$error (mtdp, code,
		"^/^a ^a SDW at record ^d, block ^d, ^[of file section ^d ^;^s^]of file named ""^a"".",
		"Converting IBM", IBM_FORMAT_CODES (mtape_file_info.file_format),
		mtape_data.log_record, mtape_data.phy_block, (mtape_file_info.section > 1),
		mtape_file_info.section, mtape_file_info.file_id);
	     go to read_return;			/* return to user with error */
	end;

     end CONVERT_DESC;
%page;
/* EOV_ON_WRITE - internal procedure to close out volume and initiate volume switch */

EOV_ON_WRITE: proc (who_called);

dcl  who_called bit (1) aligned;

	call pfm_utils_$write_file_labels (mtdp, EOV_LABEL, code); /* yes, write out the EOV labels */
	if code ^= 0 then return;			/* some problem with writing labels, give up */
	mtape_vol_set.volume_end = "0"b;		/* reset volume end flag */
	nvp = mtape_vol_set.next_vs_ptr;		/* copy pointer, in case its null */
	call mtape_$volume_switch (mtdp, nvp, code);	/* do the magic */
	if code ^= 0 then do;			/* could'nt do the switch */
	     call mtape_$error (mtdp, code,
		"Couldn't mount new volume at volume switch time");
	     return;
	end;
	vs_ptr = mtape_data.vs_current;		/* point to new volume */
	call INIT_VOL_LABELS;			/* init volume labels */
	if code ^= 0 then return;
	fi_ptr = null;				/* this will ensure we get file_info struct allocated */
	call pfm_utils_$setup_file (mtdp, fi_ptr, "1"b);	/* set up new file section structure */
	call pfm_utils_$write_file_labels (mtdp, BOF_LABEL, code); /* and write out the section header labels */
	if code ^= 0 then return;			/* if errors.. */
	if who_called = WRITING then do;		/* if actually writing data */
	     call mtape_$set_mode (mtdp, "data", mtape_data.hdw_mode, null, code); /* set hardware mode */
	     if code ^= 0 then return;
	     call mtape_$set_mode (mtdp, "length", mtape_data.length_mode, null, code); /* and special len mode */
	     if code ^= 0 then return;
	     if mtape_data.cur_buf_idx > lbound (mtape_data.buf_ptrs, 1) then /* if we have suspened bufs */
		call mtape_$flush_buffers (mtdp, code); /* flush out any suspended buffers */
	end;

     end EOV_ON_WRITE;
%page;
/* GET_NXT_RECORD - subroutine to position to next logical record, reading nxt tape block if necessary */

GET_NXT_RECORD: proc;

dcl  term bit (1) aligned;

	term = "0"b;
	do while (^term);				/* in case we have to read 1 block of new file section */
	     call mtape_$read_block (mtdp, code);	/* so read it in */
	     if code ^= 0 then			/* if some error */
		if code = error_table_$end_of_info then do; /* if EOF, read trailer */
		     call LOAD_PTRS;		/* Load up structure pointers */
		     call pfm_utils_$read_file_labels (mtdp, fi_ptr, vs_ptr, label_type, fl_code);
		     if fl_code ^= 0 then do;		/* some problem reading labels, abort */
			code = fl_code;
			go to read_return;		/* Take non-local goto and return */
		     end;
		     if label_type = EOF_LABEL then	/* is this really end of the data file? */
			go to read_return;		/* Take non-local goto and return */
		     else if label_type = EOV_LABEL then do; /* No, volume switch has already been done */
			call CHECK_NEW_FILE_SECTION;	/* go check out new file section labels */
			if code ^= 0 then		/* some error */
			     go to read_return;	/* Take non-local goto and return */
		     end;
		     else do;			/* if label_type = BOF, this is error */
			code = error_table_$bad_file; /* set appropriate error code */
			call mtape_$error (mtdp, code,
			     "^/IBM HDR1 file label found where EOF1 or EOV1 file label record expected");
			go to read_return;		/* Take non-local goto and return */
		     end;
		end;
		else go to read_return;		/* some other error, let user see what it is */
	     else do;				/* successfully read the block */
		term = "1"b;			/* set terminate condition */
		if mtape_data.ad_file_format > 2 then do; /* if variable length records */
		     if mtape_data.hdw_mode ^= MTAPE_HWM_BIN then do; /* if not binary mode */
			dbl = bdw.length;		/* 9 bit mode, must shift bdw length */
			substr (dbl, 10) = substr (dbl, 11);
			mtape_data.cur_block.length = binary (bit (substr (dbl, 1, 17), 17), 21);
		     end;
		     else mtape_data.cur_block.length = binary (bdw.length, 21); /* binary mode copy length */
		     mtape_data.remain = mtape_data.length - mtape_data.processed; /* reset, based on recorded len */
		end;
	     end;
	end;

     end GET_NXT_RECORD;
%page;
/* INIT_VOL_LABELS - internal procedure to initialize and write the VOL1 and dummy HDR1 label records */

INIT_VOL_LABELS: proc;

	if mtape_vol_set.first_file_unexpired then	/* if not expired */
	     if ^mtape_open_info.force then do;		/* and not ignoring expiration dates */
		call mtape_$user_query (mtdp, Q_UNEXPIRED_VOLUME, code); /* ask user */
		if code ^= 0 then return;		/* user does not want labels destroyed */
	     end;

	call mtape_$order (mtdp, "den", 0, addr (mtape_attach_info.density), code); /* Rewind and set density */
	if code ^= 0 then do;
	     call mtape_$error (mtdp, code,
		"^/While rewinding and setting density to ^d BPI on volume ^a prior to volume initialization",
		mtape_attach_info.density, mtape_vol_set.volume_id);
	     return;
	end;
	if ^mtape_attach_info.labeled then do;		/* if unlabeled volume */
	     mtape_vol_set.number_of_vol_labels = 0;	/* set up volume parameters */
	     mtape_vol_set.first_vl_ptr, mtape_vol_set.last_vl_ptr = null; /* in case they were'nt */
	     mtape_vol_set.volume_density = mtape_attach_info.density; /* reset volume parameters to */
	     mtape_vol_set.volume_type = Volume_unknown_format; /* reflect that its an unlabeled volume recorded at */
	     mtape_vol_set.volume_check = MTAPE_VOLUME;	/* requested density */
	     return;				/* thats all for an unlabeled volume */
	end;
	nlp = mtape_vol_set.first_vl_ptr;		/* arm the label record ptr */
	mtape_vol_set.volume_id = mtape_vol_set.volume_name;

	auth_code = authenticate_ ((mtape_vol_set.volume_id));
	if nlp = null then do;			/* if no label record structure exists.. */
	     call pfm_utils_$init_label_record (mtdp, mtape_vol_set.last_vl_ptr,
		mtape_vol_set.first_vl_ptr, lr_ptr, LABEL_LENGTH);
	     mtape_label_record.conversion = MTAPE_CV_UC_EBCDIC; /* IBM lables are always ebcdic */
	end;
	else lr_ptr = nlp;				/* it does exist, use it */
	nlp = mtape_label_record.next_lab_ptr;		/* update pointer for next label */
	ibm_vol1P = mtape_label_record.lab_ptr;
	ibm_vol1.label_id = IBM_VOL1;			/* set label id */
	ibm_vol1.volume_serial = substr (mtape_vol_set.volume_id, 1, length (ibm_vol1.volume_serial)); /* set canonacical volume name */
	ibm_vol1.owner_id.auth_code = auth_code;	/* set authentication code for RCP */
	ibm_vol1.owner_id.mult_id = MULTICS_IBM_VERSION;	/* indicate recorded by mtape_ */
	call mtape_$write_label (mtdp, lr_ptr, code);	/* write it out */
	if code ^= 0 then do;			/* if unrecoverable error */
	     call mtape_$error (mtdp, code,
		"Attempting to write IBM VOL1 label record on volume ^a.",
		mtape_vol_set.volume_id);
	     return;
	end;
	mtape_vol_set.number_of_vol_labels = 1;		/* set this constant */
	if mtape_vol_set.last_vl_ptr ^= lr_ptr then do;	/* in case there were more labels before */
	     mtape_vol_set.last_vl_ptr = lr_ptr;	/* truncate the chain */
	     mtape_label_record.next_lab_ptr = null;
	end;

/* Now write the dummy HDR1 label */

	lr_ptr = mtape_data.tlb;
	based_label_record = IBM_L1_ID (BOF_LABEL) || copy ("0", 76);
	call mtape_$write_label (mtdp, lr_ptr, code);	/* write it out */
	if code ^= 0 then do;			/* if unrecoverable error */
	     call mtape_$error (mtdp, code,
		"^/While initializing volume ^a with dummy IBM HDR1 label record",
		mtape_vol_set.volume_id);
	     return;
	end;
	call mtape_$order (mtdp, "eof", 1, null, code);	/* write an EOF mark */
	if code ^= 0 then do;
	     call mtape_$error (mtdp, code,
		"^/While writing an EOF mark following dummy IBM HDR1 label record on volume ^a",
		mtape_vol_set.volume_id);
	     return;
	end;
	mtape_vol_set.volume_density = mtape_attach_info.density; /* reset volume parameters to */
	mtape_vol_set.volume_type = Volume_ibm_tape;	/* reflect that its an IBM volume recorded at */
	mtape_vol_set.volume_check = MTAPE_VOLUME;	/* requested density by mtape_ */

/* Position for writing first file */

	call mtape_$order (mtdp, "rew", 0, null, code);	/* Rewind to load point */
	if code ^= 0 then do;
	     call mtape_$error (mtdp, code,
		"^/While rewinding volume ^a after volume initialization", mtape_vol_set.volume_id);
	     return;
	end;
	call mtape_$order (mtdp, "fsr", 1, null, code);	/* position to write over dummy HDR1 label */
	if code ^= 0 then
	     call mtape_$error (mtdp, code,
		"^/While positioning for writing first file label on volume ^a", mtape_vol_set.volume_id);

     end INIT_VOL_LABELS;

/* LOAD_PTRS - procedure to load structure pointers for exeception processing
   of time critical external entries (read and write) */

LOAD_PTRS: proc;

	vs_ptr = mtape_data.vs_current;		/* load up pertinent structure pointers */
	fi_ptr = mtape_data.fi_current;
	maip = mtape_data.attach_info_ptr;
	moip = mtape_data.open_info_ptr;
	mpfmip = mtape_data.pfm_info_ptr;

     end LOAD_PTRS;
%page;
/* LONG_RECORD_CHECK - procedure to check if a requested write of a logical record will fit */

LONG_RECORD_CHECK: proc (length, rec_blk_ck);

dcl  length fixed bin (21);
dcl  rec_blk_ck bit (1) aligned;

	if rec_blk_ck then do;			/* comparing against record length */
	     if length > mtape_data.record_size then	/* is it to big */
		code = error_table_$long_record;	/* yes, set code */
	end;
	else if length > mtape_data.block_size then	/* comparing against blk size, will it fit */
	     code = error_table_$long_record;		/* no, set code */
	if code ^= 0 then				/* if we have a long record.. */
	     go to write_return;			/* take non-local goto to write return exit */

     end LONG_RECORD_CHECK;
%page;
/* MOVE_TO_BUFFER - subroutine to move user data to tape buffer on write,
   initiating a write of the buffer if full */

MOVE_TO_BUFFER: proc (cwl, min_len);

dcl  cwl fixed bin;					/* control word length */
dcl  min_len fixed bin;				/* minimum length of next record */
dcl  pad_chars fixed bin;
dcl  rcd_pad char (pad_chars) based (addr (tape_blk (mtape_data.processed + move_len + 1)));

	if mtape_data.conversion = MTAPE_CV_EBCDIC then	/* if data recorded in ebcdic.. */
	     call ascii_to_ebcdic_ (buf_ptr -> based_lrec_data, move_ptr -> based_lrec_data);
	else move_ptr -> based_lrec_data = buf_ptr -> based_lrec_data; /* move data to tape buffer */
	if (mtape_data.ad_file_format = 1) | (mtape_data.ad_file_format = 2) then
						/* If "U" or "F" or "FB" format		*/
	     if move_len < mtape_data.record_size then do;/* and record is not fUll */
		pad_chars = mtape_data.record_size - move_len; /* pad record out with blanks */
		rcd_pad = copy (" ", pad_chars);
		if mtape_data.conversion = MTAPE_CV_EBCDIC then /* make them ebcdic blanks */
		     call ascii_to_ebcdic_ (rcd_pad, rcd_pad); /* if appropriate */
		move_len = mtape_data.record_size;	/* reflect on all data moved */
	     end;
	mtape_data.processed = mtape_data.processed + move_len + cwl; /* add up bytes processed */
	mtape_data.remain = mtape_data.block_size - mtape_data.processed; /* decrement remaining bytes */
	if ^mtape_data.file_blocked then		/* if not "FB", "VB", or "VBS" format */
	     call WRITE_BLOCK;			/* write the block out now */
	else if mtape_data.remain < min_len then	/* if blocked but block full.. */
	     call WRITE_BLOCK;			/* write the block out now */
	else mtape_data.log_record_ptr = addr (tape_blk (mtape_data.processed + 1));
						/* Not blocked, set for next lrec */

     end MOVE_TO_BUFFER;
%page;
/* MOVE_TO_USER - subroutine to move data from tape buffer to user buffer on read */

MOVE_TO_USER: proc;

	if buf_ptr = null then			/* if caller just wants length.. */
	     rec_len = rec_len + move_len;		/* thats it */
	else do;					/* this is a real read */
	     if ^long_record then do;			/* if we can still fit the data in */
		if buf_len - move_len < 0 then do;
		     long_record = "1"b;		/* we have more data than user can take */
		     move_len = buf_len;		/* move what we can */
		end;
		buf_len = buf_len - move_len;		/* and decrement length remaining in users buffer */
		if move_len > 0 then do;		/* if we have some data to move, move it */
		     if mtape_data.conversion = MTAPE_CV_EBCDIC then /* tape recorded in ebcdic */
			call ebcdic_to_ascii_ (move_ptr -> based_lrec_data, buf_ptr -> based_lrec_data);
		     else buf_ptr -> based_lrec_data = move_ptr -> based_lrec_data; /* move computed of bytes */
		     rec_len = rec_len + move_len;	/* tell user how long record is anyway */
		     buf_ptr = addr (based_lrec_index (rec_len + 1)); /* increment users buffer ptr */
		end;
	     end;
	end;
	mtape_data.processed = mtape_data.processed + crl;
	mtape_data.remain = mtape_data.cur_block.length - mtape_data.processed;
	if mtape_data.remain > 0 then
	     mtape_data.log_record_ptr = addr (tape_blk (mtape_data.processed + 1));

     end MOVE_TO_USER;
%page;
/* NEED_TO_INIT_VOLUME - function to determine if a tape volume requires initializaton */

NEED_TO_INIT_VOLUME: proc returns (bit (1) aligned);

	if mtape_vol_set.volume_check > NON_MULT_VOLUME then /* if this is not an IBM volume */
	     return ("1"b);
	if mtape_open_info.modify | mtape_open_info.extend then /* if modifying or extending */
	     return ("0"b);				/* existing file, do not init volume */
	if ^mtape_data.first_file then do;		/* if the first opening */
	     if mtape_open_info.seq_number = 1 then	/* or we want file number 1 */
		return ("1"b);
	     if mtape_open_info.next_file then		/* or next (first) file */
		return ("1"b);
	end;
	return ("0"b);

     end NEED_TO_INIT_VOLUME;
%page;
/* SET_FILE_FORMAT - internal procedure to set file format in file info from open data */

SET_FILE_FORMAT: proc;

	temp_fmt = translate (mtape_open_info.file_format, UC, LC); /* file format in upper case */
	mtape_file_info.file_code = temp_fmt;		/* set file code */
	do i = 0 to hbound (IBM_FORMAT_CODES, 1);	/* set the file format */
	     if temp_fmt = IBM_FORMAT_CODES (i) then	/* found it */
		mtape_file_info.file_format = i;
	end;
	if substr (mtape_file_info.file_code, 1, 1) = "V" then /* if variable block size format */
	     mtape_file_info.buffer_offset = size (bdw) * 4; /* account for block data word offset */

     end SET_FILE_FORMAT;

/* SET_OPEN_IDX - subroutine to determine what kind of opening this is */

SET_OPEN_IDX: proc;

	if mtape_open_info.open_mode = Sequential_input then do; /* input operation? */
	     output = "0"b;				/* yes, reset output flag */
	     open_idx = 0;				/* and set input open idx value */
	end;
	else do;					/* some type of output operation */
	     output = "1"b;				/* true if sqo or sqio */
	     if mtape_open_info.modify then		/* if modifying an existing file */
		open_idx = 3;
	     else if mtape_open_info.extend then	/* if extending current file */
		open_idx = 2;
	     else open_idx = 1;			/* otherwise create new file */
	end;

     end SET_OPEN_IDX;

/* SET_RECORD_SIZE - internal procedure to set record size either from defaults or as specified by the user */

SET_RECORD_SIZE: proc;

	if mtape_open_info.record_length = MTAPE_UNSPECIFIED then do; /* if no "-record" value specified by user */
	     if index (mtape_file_info.file_code, "S") ^= 0 then /* if Spanned format */
		mtape_file_info.record_size = mtape_open_info.default_span_rlen; /* set default */
	     else if index (mtape_file_info.file_code, "V") ^= 0 then /* if variable format */
		mtape_file_info.record_size = mtape_open_info.default_var_rlen; /* set default */
	     else mtape_file_info.record_size = mtape_open_info.default_fix_rlen; /* assume fixed or U format */
	end;
	else mtape_file_info.record_size = mtape_open_info.record_length; /* if user specified it */

     end SET_RECORD_SIZE;
%page;
/* SET_RECORDING_MODE - internal procedure to set the recording mode in the file_info structure */

SET_RECORDING_MODE: proc;

	mtape_file_info.conversion = MTAPE_NO_CONVERSION; /* set no conversion as default */
	temp_mode = translate (mtape_open_info.recording_mode, UC, LC); /* mode to UC */
	if temp_mode = "ASCII" then			/* record in standard ascii mode */
	     mtape_file_info.hdw_mode = MTAPE_HWM_NINE;
	else if temp_mode = "EBCDIC" then do;		/* record in ebcdic mode */
	     mtape_file_info.hdw_mode = MTAPE_HWM_NINE;
	     mtape_file_info.conversion = MTAPE_CV_EBCDIC;/* set conversion for ASCII <==> EBCDIC */
	end;
	else mtape_file_info.hdw_mode = MTAPE_HWM_BIN;	/* Must be binary mode */
     end SET_RECORDING_MODE;

/* SETUP - internal procedure to set up enviornment for the external entries */

SETUP: proc;

	mtdp = arg_mtdp;				/* get pointers to pertinient data */
	vs_ptr = mtape_data.vs_current;
	fi_ptr = mtape_data.fi_current;
	maip = mtape_data.attach_info_ptr;
	moip = mtape_data.open_info_ptr;
	mpfmip = mtape_data.pfm_info_ptr;
	arg_code, code = 0;				/* and reset error codes */

     end SETUP;
%page;
/* SETUP_NEW_FILE - procedure to create a file info structure and initialize it with open options */

SETUP_NEW_FILE: proc;

	if fi_ptr ^= null then			/* if replacing existing file */
	     if ^mtape_open_info.force then		/* and not ignoring expiration dates */
		if pfm_utils_$label_unexpired ((mtape_file_info.expiration_date)) then do;	/* if expiration date is in future */
		     call mtape_$user_query (mtdp, Q_UNEXPIRED_FILE, code); /* ask user what to do */
		     if code ^= 0 then return;	/* abort file opening on "no" answer */
		     if mtape_file_info.position_within_file ^= AT_BOFH then do;
			call pfm_utils_$position_in_file (mtdp, fi_ptr, vs_ptr, AT_BOFH, code);
			if code ^= 0 then return;
		     end;
		end;
	call pfm_utils_$setup_file (mtdp, fi_ptr, "0"b);	/* do the common stuff first */
	call SET_FILE_FORMAT;			/* set the file format in file info structure */
	call SET_RECORDING_MODE;			/* set the recording mode */
	if mtape_file_info.record_size = MTAPE_UNSPECIFIED then /* no record length */
	     call SET_RECORD_SIZE;			/* either use given or default */
	mtape_file_info.gen_version = 0;
	mtape_file_info.creation_date = pfm_utils_$julian_date (""); /* set todays date */
	if mtape_open_info.expiration ^= "" then	/* if expiration specified.. */
	     mtape_file_info.expiration_date = pfm_utils_$julian_date ((mtape_open_info.expiration));
	else mtape_file_info.expiration_date = " 00000";	/* no expiration specified */
	mtape_file_info.pfm_opt_sw (1) = mtape_open_info.pfm_opt_sw (1); /* copy DOS flag */
	mtape_file_info.pfm_opt_sw (2) = mtape_open_info.pfm_opt_sw (2); /* and system_use flag */

SET_FILE_ATTRIBUTES: entry;				/* to set file attributes if not already set */

	if mtape_file_info.file_format = MTAPE_UNSPECIFIED then /* if file format not specified */
	     call SET_FILE_FORMAT;
	mtape_file_info.length_mode = NON_MOD_FOUR;	/* set special length mode as default */
	if mtape_file_info.hdw_mode = MTAPE_UNSPECIFIED then /* recording mode not set */
	     call SET_RECORDING_MODE;			/* set it */
	if mtape_file_info.block_size = MTAPE_UNSPECIFIED then /* no block size */
	     mtape_file_info.block_size = mtape_open_info.block_length; /* use given */
	if mtape_file_info.record_size = MTAPE_UNSPECIFIED then /* no record length */
	     call SET_RECORD_SIZE;			/* either use given or default */
	if mtape_data.conversion = MTAPE_CV_EBCDIC then	/* if converting to ebcdic */
	     mtape_data.padding_char = IBM_EBCDIC_PAD_CHAR; /* set EBCDIC pad char */
	else mtape_data.padding_char = IBM_ASCII_PAD_CHAR;/* otherwise set ASCII pad char */

     end SETUP_NEW_FILE;
%page;
/* WRITE_BLOCK - procedure to write out the current block when full */

WRITE_BLOCK: proc;

	if mtape_data.ad_file_format > 2 then do;	/* if variable length records */
	     dbl = bit (binary (mtape_data.processed, 18), 18);
	     if mtape_data.hdw_mode ^= MTAPE_HWM_BIN then /* if not binary mode */
		substr (dbl, 2, 9) = substr (dbl, 3, 8) || "0"b; /* 9 bit mode, must shift bdw length */
	     bdw.length = dbl;
	     bdw.reserved = 0;			/* set MBZ field */
	end;
	call mtape_$write_block (mtdp, code);
	if code ^= 0 then				/* some error */
	     if code = error_table_$eov_on_write then do; /* Is it end of tape? */
		call LOAD_PTRS;			/* Load up structure pointers */
		call EOV_ON_WRITE (WRITING);		/* Go close out volume and initiate volume switch */
		if code ^= 0 then
		     go to write_return;		/* If problem, take non-local goto and return */
	     end;
	     else go to write_return;			/* other error return to caller */

     end WRITE_BLOCK;
%page;
%include mtape_includes;
%page;
%include rcp_volume_formats;
%page;
%include ibm_vol1;
%page;
%include ibm_hdr1;
%page;
%include ibm_hdr2;
%page;
%include iox_modes;

     end ibm_tape_io_;
