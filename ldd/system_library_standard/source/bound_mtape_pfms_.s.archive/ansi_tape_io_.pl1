/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        *                                                         *
        *********************************************************** */

/****^  HISTORY COMMENTS:
  1) change(85-06-07,GWMay), approve(85-06-07,MECR0125),
     audit(85-06-07,GDixon), install():
     modified entry SETUP_NEW_FILE to call pfm_utils_$position_in_file to
     position to the beginning of the headers where it had previously
     positioned back one file.
  2) change(85-10-24,GWMay), approve(85-10-24,MCR7256), audit(85-12-16,GDixon),
     install(85-12-17,MR12.0-1001):
     Formally install changes in MECR0125.  Added use of the maxlength and
     substr functions and changed field sizes where possible to eliminate
     stringsize errors.
  3) change(87-08-17,GWMay), approve(87-09-09,MECR0006),
     audit(87-09-04,Farley), install(87-09-09,MR12.1-1101):
     Removed set density call that was moved within mtape_.
  4) change(87-10-19,GWMay), approve(87-10-19,MCR7779), audit(87-11-02,Farley),
     install(87-11-30,MR12.2-1006):
     Formally install MECR0006.
  5) change(88-02-03,GWMay), approve(88-02-03,MCR7837), audit(88-04-12,Farley),
     install(88-04-19,MR12.2-1039):
     Changed to process user specified labels correctly.
     Changed to correctly set the RCP auth code in the header.
  6) change(88-11-15,Farley), approve(88-11-16,MECR0004),
     audit(88-11-15,Beattie), install(88-11-16,MR12.2-1216):
     Changed to use the ANSI_L2_ID array for checking the ansi_hdr2 label_id,
     in the decode_file_labels entry.  The check was using
     "ANSI_L1_IS(ANSI_HDR2)", which was never allowing the "HDR2" code to
     execute.
  7) change(88-11-23,Farley), approve(88-12-14,MCR8031),
     audit(89-05-15,Parisek), install(89-05-16,MR12.3-1045):
     Official mr12.3 installation of previous change, MECR0004, for mr12.2.
  8) change(00-01-26,Schroth), approve(00-01-26,MECR-Y2K):
     Changed expiry date checking to use new pfm_utils_$label_unexpired to
     verify if a file has expired.
  9) change(00-03-10,Schroth), approve(00-03-10,MECR-MTAPE-LBLS):
     Added code to decode_file_labels to properly process pre-mtape_
     ANSI HDR2 labels.
                                                   END HISTORY COMMENTS */

ansi_tape_io_: procedure;

/* format: style4 */

/* *	This program is known as a tape Per-Format module and runs under
   *	control of the mtape_ I/O module and is meant to process tape volumes
   *	and files in ANSI standard format.
   *
   *	This Per-Format module uses the following PFM dependent option flags:
   *
   *	mtape_open_info.pfm_opt_sw (1) = "1"b = -generate
   *	mtape_open_info.pfm_opt_sw (1) = "0"b = -no_generate
   *	mtape_open_info.pfm_opt_sw (2) = "1"b = -buffer_offset
   *	mtape_open_info.pfm_opt_sw (2) = "0"b = -no_buffer_offset
   *
   *	Modification History:
   *
   *	Created by J. A. Bush 11/01/82
   *	Modified by J. A. Bush 11/10/83 for performance improvements
*/

/*		ARGUMENT DATA		*/

dcl  arg_mtdp ptr;					/* Pointer to the mtape data structure */
dcl  arg_code fixed bin (35);				/* Return error code */
dcl  arg_info_ptr ptr;				/* Pointer to Order data from iox_$control call */
dcl  arg_io_call_infop ptr;				/* Pointer to io_call control info structure */
dcl  arg_order_name char (*);				/* Name of Control order to be processed */
dcl  arg_lr_ptr ptr;				/* Pointer to current label record structure */
dcl  arg_labno fixed bin;				/* label record within label group */
dcl  arg_type fixed bin;				/* 1 => BOF; 2 => EOV; 3 => EOF */
dcl  arg_convert fixed bin;				/* Label record conversion indicator */

/*		AUTOMATIC DATA		*/

dcl  Schecked_labels bit (1) aligned;
dcl  buf_ptr ptr;					/* Auto copy of users buffer pointer */
dcl  buf_len fixed bin (21);				/* Auto copy of users lrec buffer */
dcl  rec_len fixed bin (21);				/* Auto copy of logical record length */
dcl  order_name char (32);				/* Auto copy of order name */
dcl  info_ptr ptr;					/* Auto copy of order info pointer */
dcl  install_id char (32);
dcl  user_label_data char (76);			/* storage for user label data */
dcl  auth_code char (3) aligned;
dcl  today char (6);
dcl  temp_fmt char (3);
dcl  temp_mode char (6);
dcl  (term, long_record, output) bit (1) aligned;
dcl  (nvp, nlp, move_ptr) ptr;
dcl  (i, desc_type, label_type, n_segs, uln, open_idx) fixed bin;
dcl  (move_len, crl, bytes_remaining, bytes_processed) fixed bin (21);
dcl  pic1 picture "9";
dcl  pic2 picture "99";
dcl  pic4 picture "9999";
dcl  pic5 picture "99999";
dcl  pic6 picture "999999";
dcl  (code, fl_code) fixed bin (35);

/*		CONSTANT DATA		*/

dcl  myname char (32) int static options (constant) init ("ansi_tape_io_");
dcl  LABEL_LENGTH fixed bin (21) int static options (constant) init (80); /* length of label records in bytes */
dcl  MAX_ANSI_RECORD_SIZE fixed bin int static options (constant) init (99999);
dcl  WRITING bit (1) aligned int static options (constant) init ("1"b);
dcl  OPENING bit (1) aligned int static options (constant) init ("0"b);
dcl  NON_MOD_FOUR fixed bin int static options (constant) init (1);
dcl  ANSI_ASCII_PAD_CHAR char (1) int static options (constant) init ("^");
dcl  ANSI_EBCDIC_PAD_CHAR char (1) int static options (constant) init ("_");
dcl  RCW_LENGTH fixed bin int static options (constant) init (4); /* Length of an RCW */
dcl  SCW_LENGTH fixed bin int static options (constant) init (5); /* Length of an SCW */
dcl  (SEG_B_E init (0),				/* Record begins and ends in this segment */
     SEG_B_NE init (1),				/* Record begins but does not end in this segment */
     SEG_NB_NE init (2),				/* Record neither begins nor ends in this segment */
     SEG_NB_E init (3))				/* Record ends but does not begin in this segment */
	fixed bin int static options (constant);
dcl  DUMMY_LABEL char (76) int static options (constant) init /* dummy HDR1/EOF1 label, used for volume init */
	("!!DUMMY FILE ID!!******00010001000100 00000 00000 000000MULTICS ANSI2       ");
dcl  U_LABEL_ID (3) char (3) int static options (constant) init
	("UHL", "UTL", "UTL");
dcl  ANSI_FORMAT_CODES (0:7) char (3) int static options (constant) init
	("   ", "U  ", "F  ", "D  ", "S  ", "FB ", "DB ", "SB ");
dcl  LC char (26) int static options (constant) init
	("abcdefghijklmnopqrstuvwxyz");
dcl  UC char (26) int static options (constant) init
	("ABCDEFGHIJKLMNOPQRSTUVWXYZ");

/*		EXTERNAL STATIC DATA	*/

dcl  error_table_$end_of_info fixed bin (35) ext static;
dcl  error_table_$eov_on_write fixed bin (35) ext static;
dcl  error_table_$long_record fixed bin (35) ext static;
dcl  error_table_$invalid_record_desc fixed bin (35) ext static;
dcl  error_table_$bad_file fixed bin (35) ext static;
dcl  error_table_$no_operation fixed bin (35) ext static;
dcl  error_table_$no_file fixed bin (35) ext static;
dcl  error_table_$no_next_volume fixed bin (35) ext static;
dcl  error_table_$data_seq_error fixed bin (35) ext static;
dcl  error_table_$invalid_file_set_format fixed bin (35) ext static;
dcl  error_table_$invalid_label_format fixed bin (35) ext static;
dcl  error_table_$unimplemented_version fixed bin (35) ext static;
dcl  error_table_$uninitialized_volume fixed bin (35) ext static;

/*		BUILTIN FUNCTIONS		*/

dcl  (addr, binary, copy, divide, fixed, hbound, index, lbound, length,
     maxlength, mod, null, rel, rtrim, size, substr, translate, verify)
	builtin;
dcl  conversion condition;
dcl  illegal_procedure condition;

/*		EXTERNAL ENTRIES		*/

dcl  system_info_$installation_id entry (char (*));
dcl  get_group_id_ entry () returns (char (32));
dcl  authenticate_ entry (char (*)) returns (char (3) aligned);
dcl  ebcdic_to_ascii_ entry (char (*), char (*));
dcl  ascii_to_ebcdic_ entry (char (*), char (*));

/* 		BASED VARIABLES		*/

dcl  based_area area based (mtape_data.areap);
dcl  based_label_record char (LABEL_LENGTH) based (mtape_label_record.lab_ptr);
dcl  based_lrec_data char (move_len) based;		/* to move data to/from users buffer */
dcl  based_lrec_index (buf_len) char (1) based (mtape_data.arg_buf_ptr); /* to increment users buffer ptr */
dcl  tblock char (mtape_data.length) unaligned based (mtape_data.cur_buf_ptr); /* block as char string */

dcl  1 native_bo_contents based (mtape_data.cur_buf_ptr),	/* template for  native buffer offset */
       (2 block_size fixed dec (7, 0),			/* size of block in bytes (including buffer offset) */
       2 block_number fixed dec (7, 0)) unaligned;	/* block in current file (section), from 1 */

dcl  1 db_record unaligned based (mtape_data.log_record_ptr), /* Template for D/DB formated records */
       2 rcw char (4),				/* record control word (length) */
       2 rdata char (move_len),			/* logical record data */
       2 nxt_lrec char (1);				/* to position to nxt record */

dcl  1 sb_record unaligned based (mtape_data.log_record_ptr), /* Template for S/SB formated records */
       2 scw,					/* Segment control word */
         3 span_indicator char (1),			/* controls of segments in record */
         3 rec_len char (4),				/* length of logical record segment */
       2 rdata char (move_len),			/* logical record data */
       2 nxt_lrec char (1);				/* to position to nxt record */
%page;
/* pfm_init - entry to initialize the Per-Format module, setting up file and volume
   processing parameters and determining correctness of current volume */

pfm_init: entry (arg_mtdp, arg_code);

	call SETUP;				/* initialize our enviornment */
	call CHECK_VERSION (mtdp, mtape_data_version_1, "mtape_data"); /* check version of this structure every time */

/* When the pfm_init entry is called for the first time we must allocate a label record structure to
   read tape labels into. We must also check the various structure versions to make sure
   we know what the caller is talking about. */

	if mtape_data.tlb = null then do;
	     mcip = mtape_data.close_info_ptr;		/* set ptr to close into structure */
	     call pfm_utils_$init_label_record (mtdp, null, null, mtape_data.tlb, LABEL_LENGTH);
	     call CHECK_VERSION (mtape_data.tlb, mtape_lr_version_1, "mtape_label_record");
	     call CHECK_VERSION (vs_ptr, mtape_vs_version_1, "mtape_vol_set");
	     call CHECK_VERSION (maip, mtape_attach_info_version_1, "mtape_attach_info");
	     call CHECK_VERSION (moip, mtape_open_info_version_1, "mtape_open_info");
	     call CHECK_VERSION (mcip, mtape_close_info_version_1, "mtape_close_info");
	     call CHECK_VERSION (mpfmip, mtape_pfm_info_version_1, "mtape_pfm_info");
	     call mtape_$alloc (mtdp, MTAPE_ALLOC_FI, null, 0, fi_ptr); /* allocate dummy file_info structure */
	     call CHECK_VERSION (fi_ptr, mtape_fi_version_1, "mtape_file_info"); /* and check its version */
	     free mtape_file_info in (based_area);	/* we can free it now */

/* initialize the pfm_info structure for this PFM */

	     mtape_pfm_info.open_modes_allowed (1) = Sequential_input;
	     mtape_pfm_info.open_modes_allowed (2) = Sequential_output;
	     mtape_pfm_info.bof_prefix = "HDR";
	     mtape_pfm_info.eov_prefix = "EOV";
	     mtape_pfm_info.eof_prefix = "EOF";
	     mtape_pfm_info.module_id = "ANSI";
	     mtape_pfm_info.no_labels_ok = "0"b;
	     mtape_pfm_info.multi_volumes_ok = "1"b;
	     mtape_pfm_info.extended_error_recovery = "0"b;
	end;
	if mtape_vol_set.volume_type = Volume_ansi_tape then /* If an ansi tape.. */
	     call CHECK_VOL_LABELS (mtape_vol_set.volume_check); /* check the volume labels */
	else do;					/* Not an ansi tape, don't bother to read labels */
	     if mtape_vol_set.volume_type = Volume_blank |
		mtape_vol_set.volume_type = Volume_unreadable then
		mtape_vol_set.volume_check = BLANK_VOLUME;
	     else if mtape_vol_set.volume_type = Volume_unknown_format then
		mtape_vol_set.volume_check = UNLABELED_VOLUME;
	     else mtape_vol_set.volume_check = RECOG_FORMAT_VOLUME;
	     mtape_data.lab_buf_len = LABEL_LENGTH;	/* set in case subsequent volumes are labeled */
	end;

pfm_init_return:					/* target of non-local gotos */
	arg_code = code;
	return;
%page;
/* file_open - entry to do format specific processing in opening the file
   or file set (i.e. read and write file labels) */

file_open: entry (arg_mtdp, arg_code);

	call SETUP;				/* initialize our enviornment */
	call SET_OPEN_IDX;				/* determine what type of processing to do */
	call pfm_utils_$file_search (mtdp, fi_ptr, vs_ptr, code); /* search for the file */
	if code ^= 0 & open_idx ^= 1 then		/* if error and not creating file.. */
	     go to open_return;			/* quit now */
	go to open_action (open_idx);			/* do the appropriate thing */

open_action (0):					/* open for input */
	call CHECK_USER_LABELS (BOF_LABEL);		/* go see if user labels to be processed */
	call SET_FILE_ATTRIBUTES;			/* complete file attributes from open desc */
	go to open_return;

open_action (1):					/* Open for output, creation */
	if code = 0 |				/* if no error */
	     code = error_table_$no_file |		/* or if could not find file */
	     code = error_table_$uninitialized_volume then do; /* or if bad vol label */
	     if NEED_TO_INIT_VOLUME () then do;		/* if volume requires initialization.. */
		call INIT_VOL_LABELS;		/* initialize the volume labels */
		if code ^= 0 then go to open_return;
	     end;
	     code = 0;				/* reset possible error code */
	     call SETUP_NEW_FILE;			/* setup new file info structure */
	     if code ^= 0 then go to open_return;
	     call pfm_utils_$write_file_labels (mtdp, BOF_LABEL, code); /* go write the file header labels */
	     if code = 0 then			/* if no error */
		if mtape_vol_set.volume_end then	/* did we run out of tape? */
		     call EOV_ON_WRITE (OPENING);	/* yes, do volume switch now */
	end;
	go to open_return;

open_action (2):					/* open for output, extend existing file */
	mtape_data.phy_block = mtape_file_info.block_count; /* preset block number */
open_action (3):					/* open for output, modify existing file */
	call pfm_utils_$truncate_file_set (mtdp);	/* get rid of EOF labels if extend | modify */
	mtape_file_info.gen_version = mod (mtape_file_info.gen_version, 100) + 1; /* increment version */
	go to open_return;

open_action (4):					/* open for output, generate file */
	call pfm_utils_$truncate_file_set (mtdp);	/* get rid of EOF labels */
	mtape_file_info.generation = mod (mtape_file_info.generation, 10000) + 1; /* increment generation number */
	call pfm_utils_$write_file_labels (mtdp, BOF_LABEL, code); /* go write the file header labels */
	if code = 0 then				/* if no error */
	     if mtape_vol_set.volume_end then		/* did we run out of tape? */
		call EOV_ON_WRITE (OPENING);		/* yes, do volume switch now */
open_return:
	arg_code = code;				/* return error code */

	return;
%page;
/* file_close - entry to do format specific processing in closing the file
   or file set (i.e. read and write file trailer labels) */

file_close: entry (arg_mtdp, arg_code);

	call SETUP;				/* initialize our enviornment */
	mcip = mtape_data.close_info_ptr;		/* set up close info ptr too */

	if mtape_open_info.open_mode = Sequential_input then /* input operation? */
	     output = "0"b;				/* yes, reset output flag */
	else output = "1"b;				/* true if sqo or sqio */
	if output & mtape_data.error_lock ^= error_table_$no_next_volume then do; /* if writing tape */
	     if mtape_data.error_lock = 0 then do;	/* flush out only if possible */
		if mtape_data.processed > mtape_data.buffer_offset then /* if we have some unwritten data */
		     call WRITE_BLOCK;		/* write a short block */
		call mtape_$flush_buffers (mtdp, code); /* write out all queued buffers */
		if code ^= 0 then			/* if some error writing data */
		     if code = error_table_$eov_on_write then /* Is it end of tape? */
			call EOV_ON_WRITE (WRITING);	/* Go close out volume and initiate volume switch */
		if code ^= 0 then
		     go to close_file_return;
	     end;
	     call pfm_utils_$write_file_labels (mtdp, EOF_LABEL, code); /* write out EOF labels */
	     if code ^= 0 then			/* error writing labels.. */
		go to close_file_return;
	end;
	else do;					/* input operation, must make sure tape is stoped */
	     call mtape_$stop_tape (mtdp, code);
	     if code ^= 0 then
		go to close_file_return;
	end;

	Schecked_labels = "0"b;
						/* USER trailers can only be returned when */
						/* positioned after the file data */
	if ^output & mtape_file_info.position_within_file = AT_EOF then do;
	     call CHECK_USER_LABELS (EOF_LABEL);	/* go see if user labels to be processed */
	     Schecked_labels = "1"b;
	end;

	if mtape_close_info.position ^= 0 then do;	/* if not leaving tape where it is.. */
	     call pfm_utils_$position_in_file (mtdp, fi_ptr,
		vs_ptr, mtape_close_info.position, code);
	     if ^output & code = 0 & ^Schecked_labels &
		mtape_file_info.position_within_file = AT_EOFH then
		call CHECK_USER_LABELS (EOF_LABEL);
	end;

close_file_return:
	arg_code = code;				/* copy return error code (if any) */
	return;
%page;
/* read - entry to read format specific logical records from the current file */

read: entry (arg_mtdp, arg_code);

	mtdp = arg_mtdp;				/* copy arguments */
	buf_ptr = mtape_data.arg_buf_ptr;		/* If = null, return length of next record */
	buf_len = mtape_data.arg_buf_len;
	code, rec_len = 0;				/* initialize return record length */
	long_record = "0"b;				/* init long record flag */
	if mtape_data.remain <= 0 then		/* Do we need to read in a block? */
	     call GET_NXT_RECORD;			/* yes, do it */
	go to READ_TYPE (mtape_data.ad_file_format);	/* process depending on file format */

READ_TYPE (1):					/* Process "U" formated records */
	crl, move_len = mtape_data.remain;		/* user gets entire block */
	move_ptr = mtape_data.log_record_ptr;		/* set pointer to move data from */
	call MOVE_TO_USER;				/* move the data to the users buffer */
	go to read_return;

READ_TYPE (2):					/* Process "F/FB" formated records */
	if mtape_data.record_size > mtape_data.remain then/* don't try to move more than we have */
	     crl = mtape_data.remain;
	else crl = mtape_data.record_size;
	move_len = crl;
	move_ptr = mtape_data.log_record_ptr;		/* set pointer to move data from */
	call MOVE_TO_USER;				/* give the user his data */
	go to read_return;

READ_TYPE (3):					/* Process "D/DB" formated records */
	if mtape_data.remain < RCW_LENGTH then		/* in case we have mod 4 padded block */
	     call GET_NXT_RECORD;			/* go read next block */
	do while (tape_blk (mtape_data.processed + 1) = mtape_data.padding_char);
	     call GET_NXT_RECORD;			/* if rcw is pad, get next block */
	end;
	on conversion call INV_DESC;			/* if error converting rcw */
	crl = binary (db_record.rcw, 21);		/* compute record length */
	revert conversion;				/* revert conversion condition handling */
	move_len = crl - RCW_LENGTH;
	move_ptr = addr (db_record.rdata);		/* set pointer to move data from */
	call MOVE_TO_USER;				/* give the user his data */
	go to read_return;
%page;
READ_TYPE (4):					/* Process "S/SB" formated records */
	if mtape_data.remain < SCW_LENGTH then		/* in case we have mod 4 padded block */
	     call GET_NXT_RECORD;			/* go read next block */
	term = "0"b;				/* reset terminate condition */
	on conversion call INV_DESC;			/* establish on unit for converting seg descriptors */
	do n_segs = 1 by 1 while (^term);		/* 1 record may be made up of several segments and blocks */
	     call CONVERT_DESC;			/* convert segment descriptor */
	     if n_segs = 1 then			/* if first pass through */
		do while (desc_type ^= SEG_B_E & desc_type ^= SEG_B_NE); /* make sure we get new record */
		mtape_data.remain = mtape_data.remain - crl;
		mtape_data.log_record_ptr = addr (sb_record.nxt_lrec);
		if mtape_data.remain <= 0 then	/* Do we have to read in a new block? */
		     call GET_NXT_RECORD;
		call CONVERT_DESC;
	     end;
	     move_ptr = addr (sb_record.rdata);		/* set ptr to move data */
	     call MOVE_TO_USER;			/* give the user his data */
	     if desc_type = SEG_B_E | desc_type = SEG_NB_E then /* end of the record? */
		term = "1"b;			/* yes, set terminate condition */
	     else if mtape_data.remain <= 0 then	/* No, New segment in next block? */
		call GET_NXT_RECORD;		/* yes, do it */
	end;
	revert conversion;

read_return:
	mtape_data.arg_rec_len = rec_len;		/* give the user the length of the record */
	if code = 0 then				/* if no error but.. */
	     if long_record then			/* we had a longer record than the users buffer */
		code = error_table_$long_record;	/* tell him about it */
	arg_code = code;				/* return error code */
	return;
%page;
/* write - entry to write format specific logical records into the current file */

write: entry (arg_mtdp, arg_code);

	mtdp = arg_mtdp;				/* Copy arguments */
	buf_ptr = mtape_data.arg_buf_ptr;
	buf_len = mtape_data.arg_buf_len;
	code = 0;
	if buf_ptr = null then do;			/* User wants to flush out buffers */
	     if mtape_data.processed > mtape_data.buffer_offset then /* if we have some unwritten data */
		call WRITE_BLOCK;			/* write a short block */
	     call mtape_$flush_buffers (mtdp, code);	/* write out all queued buffers */
	     if code ^= 0 then			/* if some error writing data */
		if code = error_table_$eov_on_write then do; /* Is it end of tape? */
		     call LOAD_PTRS;		/* load up structure pointers */
		     call EOV_ON_WRITE (WRITING);	/* Go close out volume and initiate volume switch */
		end;
	     go to write_return;			/* return to user */
	end;
	go to WRITE_TYPE (mtape_data.ad_file_format);	/* process depending on file format */

WRITE_TYPE (1):					/* Write "U" formated records */
	call LONG_RECORD_CHECK (buf_len, "0"b);		/* check for long record */
	move_len = buf_len;				/* writes entire block */
	move_ptr = mtape_data.log_record_ptr;		/* set pointer to move data to */
	call MOVE_TO_BUFFER (0, 0);			/* move the data to the tape buffer */
	go to write_return;

WRITE_TYPE (2):					/* Write "F/FB" formated records */
	call LONG_RECORD_CHECK (buf_len, "1"b);		/* check for long record */
	if mtape_data.record_size > mtape_data.remain then/* don't try to move more than we have */
	     call WRITE_BLOCK;			/* write out the current block */
	move_len = buf_len;
	move_ptr = mtape_data.log_record_ptr;		/* set pointer to move data from */
	call MOVE_TO_BUFFER (0, 1);			/* give the user his data */
	go to write_return;

WRITE_TYPE (3):					/* Write "D/DB" formated records */
	call LONG_RECORD_CHECK (buf_len, "1"b);		/* check for long record */
	if buf_len + RCW_LENGTH > mtape_data.remain then	/* if record won't fit in this block */
	     call WRITE_BLOCK;			/* write out the current block */
	move_len = buf_len;				/* set record length */
	pic4 = move_len + RCW_LENGTH;			/* convert RCW to ASCII */
	db_record.rcw = pic4;			/* set up RCW */
	move_ptr = addr (db_record.rdata);		/* set pointer to move data from */
	call MOVE_TO_BUFFER (RCW_LENGTH, RCW_LENGTH);	/* copy the users data  */
	go to write_return;
%page;
WRITE_TYPE (4):					/* Write "S/SB" formated records */
	call LONG_RECORD_CHECK (buf_len, "1"b);		/* check for long record */
	bytes_remaining = buf_len;			/* set user buffer extents */
	bytes_processed = 0;
	term = "0"b;				/* reset terminate condition */
	do n_segs = 1 by 1 while (^term);		/* 1 record may be made up of several segments and blocks */
	     if bytes_remaining <= mtape_data.remain - SCW_LENGTH then do; /* will record fit in this block? */
		term = "1"b;			/* yes, set terminate condition */
		if n_segs = 1 then			/* entire record fit in 1st block? */
		     desc_type = SEG_B_E;		/* Yes, record begins and ends in this segment */
		else desc_type = SEG_NB_E;		/* No, record ends but does not begin in this segment */
		move_len = bytes_remaining;		/* move last part (or all) of record */
	     end;
	     else do;				/* No, record will not fit in current block */
		if n_segs = 1 then			/* is this the first record segment? */
		     desc_type = SEG_B_NE;		/* Yes, record begins but does not end in this segment */
		else desc_type = SEG_NB_NE;		/* No, record neither begins nor ends in this segment */
		move_len = mtape_data.remain - SCW_LENGTH; /* use rest of or entire block */
		bytes_remaining = bytes_remaining - move_len; /* decrement remaining bytes to process */
	     end;
	     bytes_processed = bytes_processed + move_len;/* add up total moved so far */
	     pic4 = move_len + SCW_LENGTH;		/* convert byte count for scw */
	     move_ptr = addr (sb_record.rdata);		/* set ptr to move data */
	     pic1 = desc_type;			/* convert descriptor */
	     sb_record.scw.rec_len = pic4;		/* set record length */
	     sb_record.scw.span_indicator = pic1;	/* and span indicator */
	     call MOVE_TO_BUFFER (SCW_LENGTH, SCW_LENGTH + 1); /* copy the users data */
	     buf_ptr = addr (based_lrec_index (bytes_processed + 1)); /* increment users buffer ptr */
	end;

write_return:
	arg_code = code;				/* return error code */
	return;
%page;
/* order - entry to process format specific control orders not recognized by mtape_ */

order: entry (arg_mtdp, arg_order_name, arg_info_ptr, arg_io_call_infop, arg_code);

	call SETUP;				/* initialize our enviornment */
	order_name = arg_order_name;
	info_ptr = arg_info_ptr;

	arg_code = error_table_$no_operation;		/* ANSI PFM has no local control operations */
	return;
%page;
/* decode_file_labels - entry to extract info contained in file labels, and fill in file_info structure */

decode_file_labels: entry (arg_mtdp, arg_lr_ptr, arg_labno, arg_type, arg_code);

	call SETUP;				/* initialize our enviornment */
	lr_ptr = arg_lr_ptr;

	on conversion begin;			/* set up handler for conversion errors */
	     code = error_table_$invalid_label_format;	/* set appropriate error code */
	     call mtape_$error (mtdp, code,
		"^/Converting ANSI ^a^d label record to binary. Label contents:^/""^a""",
		substr (based_label_record, 1, 3), arg_labno, based_label_record);
	     go to dfl_return;
	end;

	ansi_hdr1P, ansi_hdr2P = mtape_label_record.lab_ptr; /* set up both template ptrs */
	go to LTYPE (arg_type);			/* decode appropriate label type */

LTYPE (1):					/* Beginning of file label */
	if ansi_hdr1.label_id = ANSI_L1_ID (ANSI_HDR1) then do;
						/* ANSI HDR1 label */
	     if arg_labno ^= 1 then
		call mtape_$error (mtdp, error_table_$invalid_label_format, "
Additional ANSI HDR1 label found while looking for ANSI ^a^d label
for file ^a.  Read continues using:
""^a""",
		     substr (based_label_record, 1, 3), arg_labno,
		     mtape_file_info.file_id,
		     based_label_record);

	     mtape_file_info.file_id = ansi_hdr1.file_id;
	     mtape_file_info.file_set_id = ansi_hdr1.set_id;
	     mtape_file_info.section = binary (ansi_hdr1.section, 17);
	     mtape_file_info.seq_number = binary (ansi_hdr1.sequence, 17);
	     mtape_file_info.generation = binary (ansi_hdr1.generation, 17);
	     mtape_file_info.gen_version = binary (ansi_hdr1.version, 17);
	     mtape_file_info.creation_date = ansi_hdr1.creation;
	     mtape_file_info.expiration_date = ansi_hdr1.expiration;
	     if ansi_hdr1.system = ANSI_SYS_CODE then	/* tape recorded by this module? */
		mtape_file_info.native_file = "1"b;	/* yes, set flag */
	end;
	else if ansi_hdr2.label_id = ANSI_L2_ID (ANSI_HDR2) then do;

	     if arg_labno ^= 2 then			/* ANSI HDR2 label */
		call mtape_$error (mtdp, error_table_$invalid_label_format, "
Additional ANSI HDR2 label found while looking for ANSI ^a^d label
for file ^a.  Read continues using:
""^a""",
		     substr (based_label_record, 1, 3), arg_labno,
		     mtape_file_info.file_id, based_label_record);

	     mtape_file_info.buffer_offset = binary (ansi_hdr2.buffer_offset, 17); /* Fill in rest of file info */
	     if mtape_file_info.buffer_offset = 0 then	/* if not using buffer offsets.. */
		mtape_file_info.native_file = "0"b;	/* revert this flag */
	     mtape_file_info.block_size = binary (ansi_hdr2.blklen, 21);
	     mtape_file_info.record_size = binary (ansi_hdr2.reclen, 21);
	     temp_fmt = ansi_hdr2.format;		/* get first character of format */
	     mtape_file_info.length_mode = NON_MOD_FOUR;	/* set special length mode as default */
	     if mtape_vol_set.volume_check < NON_MULT_VOLUME then do; /* check Multics specific stuff */
		mtape_file_info.hdw_mode = MTAPE_HWM_NINE; /* set nine mode, as default */
		mtape_file_info.conversion = MTAPE_NO_CONVERSION; /* set no conversion as default */
		if ansi_hdr2.system_use.blocked ^= " " then do;	/* this field moved with mtape_, allow old ones */
		     if ansi_hdr2.system_use.blocked = "1" then	/* check blocking attribute */
			temp_fmt = rtrim (temp_fmt) || "B";
		     go to set_mode (binary (ansi_hdr2.system_use.mode, 17)); /* set HDW and conversion modes */
		end;
		else do;				/* handle the pre-mtape_ system_use blocking and format */
		     if old_ansi_hdr2_system_use.blocked = "1" then	/* check blocking attribute */
			temp_fmt = rtrim (temp_fmt) || "B";
		     go to set_mode (binary (old_ansi_hdr2_system_use.mode, 17)); /* set HDW and conversion modes */
		end;

set_mode (3):					/* ASCII, binary mode */
		mtape_file_info.hdw_mode = MTAPE_HWM_BIN;
		go to set_mode_end;

set_mode (2):					/* EBCDIC, nine track mode */
		mtape_file_info.conversion = MTAPE_CV_EBCDIC; /* convert EBCDIC <==> ASCII */

set_mode (1):					/* ASCII, nine track mode (default) */
set_mode_end:
	     end;
	     mtape_file_info.file_code = temp_fmt;	/* set file code */
	     do i = 0 to hbound (ANSI_FORMAT_CODES, 1);	/* set the file format */
		if temp_fmt = ANSI_FORMAT_CODES (i) then/* found it */
		     mtape_file_info.file_format = i;
	     end;
	end;
	else if substr (based_label_record, 1,
	     length (U_LABEL_ID (arg_type))) = U_LABEL_ID (arg_type) then /* user labels present */
	     mtape_file_info.user_labels_present = "1"b;
	return;

LTYPE (2):					/* End of volume label */

	if arg_labno = 1 then			/* if ANSI EOV1 label */
	     mtape_file_info.block_count = binary (ansi_hdr1.blkcnt, 35); /* extract block count */
	else if arg_labno = 2 then do;		/* if ANSI EOV2 label */
	     if mtape_vol_set.volume_check < NON_MULT_VOLUME then do; /* check Multics specific stuff */
		if mtape_vol_set.next_vs_ptr = null then do; /* if no VS structure */
		     call mtape_$alloc (mtdp, MTAPE_ALLOC_VS, mtape_data.vs_tail, 0, nvp);
		     mtape_data.vs_tail = nvp;
		end;
		else nvp = mtape_vol_set.next_vs_ptr;
		if nvp -> mtape_vol_set.volume_name ^=
		     ansi_hdr2.system_use.next_volname then
		     nvp -> mtape_vol_set.volume_name = ansi_hdr2.system_use.next_volname;
	     end;
	end;
	else if substr (based_label_record, 1,
	     length (U_LABEL_ID (arg_type))) = U_LABEL_ID (arg_type) then do; /* user labels present */
	     mtape_file_info.user_labels_present = "1"b;
	     call CHECK_USER_LABELS (EOV_LABEL);
	end;

	return;

LTYPE (3):					/* End of file label */
						/* if ANSI EOF1 label */
	if ansi_hdr1.label_id = ANSI_L1_ID (ANSI_EOF1) then do;
	     if arg_labno ^= 1 then
		call mtape_$error (mtdp, error_table_$invalid_label_format, "
Additional ANSI EOF1 label found while looking for ANSI ^a^d label
for file ^a.  Read continues using:
""^a""",
		     substr (based_label_record, 1, 3), arg_labno,
		     mtape_file_info.file_id, based_label_record);

	     mtape_file_info.block_count = binary (ansi_hdr1.blkcnt, 35); /* extract block count */
	     mtape_file_info.gen_version = binary (ansi_hdr1.version, 17); /* save in case modified | extended file */
	end;
	else if substr (based_label_record, 1,
	     length (U_LABEL_ID (arg_type))) = U_LABEL_ID (arg_type) then /* user labels present */

	     mtape_file_info.user_labels_present = "1"b;


dfl_return:
	arg_code = code;
	return;
%page;
/* encode_file_labels - entry to fill in file labels from info obtained from file_info structure */

encode_file_labels: entry (arg_mtdp, arg_lr_ptr, arg_labno, arg_type, arg_convert, arg_code);

	call SETUP;				/* initialize our enviornment */
	lr_ptr = arg_lr_ptr;
	based_label_record = "";			/* initialize to blanks first */
	arg_convert = MTAPE_CV_UC_ASCII;		/* set conversion to uper case ascii */
	if arg_labno = 1 then do;			/* init HDR1/EOV1/EOF1 label */
	     if arg_type = EOV_LABEL then		/* if writing EOV sequence */
		if mtape_vol_set.next_vs_ptr = null then do; /* and no next volume */
		     call mtape_$user_query (mtdp, Q_NO_NEXT_VOLUME, code); /* ask user for a new one */
		     if code ^= 0 then		/* if he didn't want to continue */
			go to efl_return;		/* forget it */
		end;
	     ansi_hdr1P = mtape_label_record.lab_ptr;
	     ansi_hdr1.label_id = ANSI_L1_ID (arg_type);	/* Now fill it in */
						/* Use substr to move the uneven length string */
	     ansi_hdr1.file_id = substr (mtape_file_info.file_id, 1,
		maxlength (ansi_hdr1.file_id));
	     ansi_hdr1.set_id = substr (mtape_file_info.file_set_id, 1,
		maxlength (ansi_hdr1.set_id));
	     pic4 = mtape_file_info.section;
	     ansi_hdr1.section = pic4;
	     pic4 = mtape_file_info.seq_number;
	     ansi_hdr1.sequence = pic4;
	     pic4 = mtape_file_info.generation;
	     ansi_hdr1.generation = pic4;
	     pic2 = mtape_file_info.gen_version;
	     ansi_hdr1.version = pic2;
	     ansi_hdr1.creation = mtape_file_info.creation_date;
	     ansi_hdr1.expiration = mtape_file_info.expiration_date;
	     ansi_hdr1.access = " ";			/* Always unlimited access */
	     if arg_type > BOF_LABEL then do;		/* if EOV/EOF label */
		pic6 = mtape_file_info.block_count;	/* fill in the block count */
		ansi_hdr1.blkcnt = pic6;
	     end;
	     else ansi_hdr1.blkcnt = "000000";		/* used only for EOF/EOV1 records */
	     ansi_hdr1.system = ANSI_SYS_CODE;
	     return;
	end;
	else if arg_labno = 2 then do;		/* init HDR2/EOV2/EOF2 label */
	     ansi_hdr2P = mtape_label_record.lab_ptr;
	     ansi_hdr2.label_id = ANSI_L2_ID (arg_type);	/* Now fill it in */
	     ansi_hdr2.format = substr (ANSI_FORMAT_CODES (mtape_file_info.file_format), 1, 1);
	     pic5 = mtape_file_info.block_size;
	     ansi_hdr2.blklen = pic5;
	     if mtape_file_info.record_size <= MAX_ANSI_RECORD_SIZE then do; /* if it will fit */
		pic5 = mtape_file_info.record_size;
		ansi_hdr2.reclen = pic5;
	     end;
	     else ansi_hdr2.reclen = "00000";
	     if substr (ANSI_FORMAT_CODES (mtape_file_info.file_format), 2, 1) ^= "" then
		ansi_hdr2.system_use.blocked = "1";
	     else ansi_hdr2.system_use.blocked = "0";
	     if arg_type = EOV_LABEL then do;		/* if at EOV */
		if mtape_vol_set.next_vs_ptr ^= null then /* and if we have another volume */
		     ansi_hdr2.system_use.next_volname =
			mtape_vol_set.next_vs_ptr -> mtape_vol_set.volume_name;
		arg_convert = MTAPE_NO_CONVERSION;	/* don't convert volume id */
	     end;
	     if mtape_file_info.hdw_mode = MTAPE_HWM_BIN then /* if recording in binary mode */
		ansi_hdr2.system_use.mode = "3";
	     else if mtape_file_info.conversion = MTAPE_CV_EBCDIC then /* if recording EBCDIC data */
		ansi_hdr2.system_use.mode = "2";
	     else ansi_hdr2.system_use.mode = "1";	/* Standard ASCII NINE mode */
	     pic2 = mtape_file_info.buffer_offset;
	     ansi_hdr2.buffer_offset = pic2;
	     return;
	end;
	else if mtape_open_info.label_entry_present then	/* if writing user labels */
	     if arg_labno < 12 then do;		/* and not at max of 9 yet */
		uln = arg_labno - 2;		/* user labels start at 1 */
		user_label_data = "";
		call mtape_open_info.user_label (mtape_data.iocb_ptr, user_label_data, uln, arg_type,
		     mtape_file_info.section, code);	/* call the user label routine */
		if code ^= 0 then			/* if error indicated from user routine */
		     if code = error_table_$end_of_info then /* but it is normal termination */
			go to efl_return;		/* return with end of info indication */
		     else do;			/* some other error report it */
			call mtape_$error (mtdp, code,
			     "^/Calling the user label processing routine to process the ^a^d label record.",
			     U_LABEL_ID (arg_type), uln);
			code = error_table_$end_of_info; /* force user label termination */
			go to efl_return;
		     end;
		pic1 = uln;			/* convert label number to ascii */
		based_label_record = U_LABEL_ID (arg_type) || pic1 || user_label_data; /* form completed user label */
		go to efl_return;
	     end;
	code = error_table_$end_of_info;		/* terminate label processing */

efl_return:
	arg_code = code;				/* copy error code */
	return;
%page;
/* CHECK_NEW_FILE_SECTION - internal procedure to check consistency of new file section */

CHECK_NEW_FILE_SECTION: proc;

dcl  per_file_overlay char (ov_len) based (addr (mtape_file_info.per_file_info));
dcl  ov_len fixed bin;
dcl  pp ptr;

	code = 0;
	fi_ptr = mtape_file_info.next_fi_ptr;		/* file info will be allocated if null */
	call pfm_utils_$read_file_labels (mtdp, fi_ptr, vs_ptr, label_type, code); /* read new file sect. HDR labels */
	if code ^= 0 then
	     return;
	if label_type ^= BOF_LABEL then do;		/* error if not header labels */
	     code = error_table_$bad_file;
	     call mtape_$error (mtdp, code,
		"^/^[EOV^;EOF^] file label found where BOF label record expected", label_type);
	     return;
	end;
	call SET_FILE_ATTRIBUTES;			/* set up missing pieces */
	pp = mtape_file_info.prev_fi_ptr;		/* get prev file ptr */
	ov_len = (binary (rel (addr (mtape_file_info.per_section_info))) -
	     binary (rel (addr (mtape_file_info.per_file_info)))) * 4;
	if mtape_file_info.record_size ^= pp -> mtape_file_info.record_size then /* if record sizes */
	     if mtape_file_info.record_size = 0 then	/* are ^=, but new section = 0 */
		pp -> mtape_file_info.record_size = 0;	/* make 1st section = 0 too */
	if mtape_file_info.section ^= pp -> mtape_file_info.section + 1 |
	     per_file_overlay ^= addr (pp -> mtape_file_info.per_file_info) -> per_file_overlay then do;
	     code = error_table_$bad_file;		/* set an appropriate error code */
	     call mtape_$error (mtdp, code,
		"^/New file section for File ""^a"" on volume ""^a"" is inconsistent with previous section",
		pp -> mtape_file_info.file_id, mtape_vol_set.volume_id);
	end;
	mtape_data.prev_block_no = 0;			/* clear out block counter */
	call mtape_$set_mode (mtdp, "data", mtape_data.hdw_mode, null, code); /* set hardware mode */

     end CHECK_NEW_FILE_SECTION;
%page;
/* CHECK_USER_LABELS - procedure to check if user labels and a user label entry exist */

CHECK_USER_LABELS: proc (htype);

dcl  htype fixed bin;
dcl  flrp ptr;

	if mtape_file_info.user_labels_present then	/* if file contains user labels */
	     if mtape_open_info.label_entry_present then do; /* and user wants to see them */
		if htype > BOF_LABEL then		/* trailer labels? */
		     flrp = mtape_file_info.first_file_trail_ptr; /* yes, search trailer list */
		else flrp = mtape_file_info.first_file_lab_ptr; /* search header list */
		do lr_ptr = flrp repeat mtape_label_record.next_lab_ptr /* search up to 1st user label */
		     while (substr (based_label_record, 1, 1) ^= "U");
		end;
		do lr_ptr = lr_ptr repeat mtape_label_record.next_lab_ptr
		     while (lr_ptr ^= null);		/* send him all labels */
		     user_label_data = substr (based_label_record, 5); /* copy user data */
		     i = fixed (substr (based_label_record, 4, 1), 17); /* get label number */
		     call mtape_open_info.user_label (mtape_data.iocb_ptr, /* call the user label routine */
			user_label_data, i, htype, mtape_file_info.section, (0)); /* ignore error code */
		end;
	     end;

     end CHECK_USER_LABELS;

/* CHECK_VERSION - internal procedure to check struture version numbers */

CHECK_VERSION: proc (s_ptr, req_version, struc_name);

dcl  s_ptr ptr;
dcl  req_version char (8);
dcl  struc_name char (32);

dcl  1 version_check based (s_ptr) aligned,		/* generic structure to check verison number */
       2 version char (8);

	if version_check.version ^= req_version then do;	/* they do not match */
	     code = error_table_$unimplemented_version;	/* set error code */
	     call mtape_$error (mtdp, code,
		"^/^a: Expecting ""^a"" version for ^a structure. Version recorded in received structure is ""^a"".",
		myname, req_version, struc_name, version_check.version);
	     go to pfm_init_return;			/* take non-local goto and return to caller */
	end;

     end CHECK_VERSION;
%page;
/* CHECK_VOL_LABELS - internal procedure to read volume label(s) of a known ANSI volume */

CHECK_VOL_LABELS: proc (ridx);

dcl  ridx fixed bin;

	call mtape_$order (mtdp, "rew", 0, null, code);	/* Rewind to load point */
	if code ^= 0 then do;
	     call mtape_$error (mtdp, code,
		"While rewinding volume ^a prior to reading volume label(s)", mtape_vol_set.volume_id);
	     return;
	end;
	nlp = mtape_vol_set.first_vl_ptr;		/* arm the label record ptr */
	ansi_vol1P = mtape_data.tlb -> mtape_label_record.lab_ptr; /* get pointer to VOL1 structure */
	term = "0"b;				/* get us through the first pass */
	do i = 1 by 1 while (^term);			/* read up to HDR1 label */
	     call mtape_$read_label (mtdp, mtape_data.tlb, code); /* read label record */
	     if code ^= 0 then do;
		call mtape_$error (mtdp, code,
		     "Attempting to read ANSI volume label record from volume ^a.", mtape_vol_set.volume_id);
		return;
	     end;
	     if ansi_vol1.label_id = ANSI_VOL1 then do;	/* if this is VOL1 label */
		if ansi_vol1.owner_id.mult_id = MULTICS_ANSI_VERSION then /* only true if recorded by mtape_ */
		     ridx = MTAPE_VOLUME;
		else ridx = NON_MULT_VOLUME;		/* volume recorded by other vendor */
	     end;
	     else if ansi_vol1.label_id = ANSI_L1_ID (BOF_LABEL) then do; /* check if HDR1 label */
		term = "1"b;			/* this is the place to stop reading labels */
		mtape_vol_set.number_of_vol_labels = i - 1; /* set number of vol labels */
		ansi_hdr1P = ansi_vol1P;		/* check expiration date of first file */
		if ridx = NON_MULT_VOLUME then	/* check if recorded by tape_ansi_ */
		     if substr (ansi_hdr1.system, 1, 12) = substr (ANSI_SYS_CODE, 1, 12) then
			ridx = MULT_PRIOR_VOLUME;	/* yes, tape recorded by tape_ansi_ */
		mtape_vol_set.first_file_unexpired = pfm_utils_$label_unexpired (ansi_hdr1.expiration);	/* check expiry date */
	     end;
	     if ^term then do;			/* link in this label  (if not HDR1) */
		if nlp = null then			/* if no label record structure exists.. */
		     call pfm_utils_$init_label_record (mtdp, mtape_vol_set.last_vl_ptr,
			mtape_vol_set.first_vl_ptr, lr_ptr, LABEL_LENGTH);
		else lr_ptr = nlp;			/* it does exist, use it */
		based_label_record = mtape_data.tlb -> mtape_label_record.lab_ptr -> based_label_record;
		nlp = mtape_label_record.next_lab_ptr;	/* update pointer for next label */
	     end;
	end;
	call mtape_$order (mtdp, "bsr", 1, null, code);	/* backspace in front of HDR1 */
	if code ^= 0 then
	     call mtape_$error (mtdp, code,
		"Attempting to backspace over ^a label record of volume ^a.",
		ansi_vol1.label_id, mtape_vol_set.volume_id);

     end CHECK_VOL_LABELS;
%page;
/* CONVERT_DESC - internal procedure to convert RDW for S/SB formated records */

CONVERT_DESC: proc;

	do while (sb_record.scw.span_indicator = mtape_data.padding_char);
	     call GET_NXT_RECORD;			/* if scw is pad, get next block */
	end;
	desc_type = binary (sb_record.scw.span_indicator, 17); /* convert the span indicator */
	crl = binary (sb_record.scw.rec_len, 21);	/* compute the record length */
	move_len = crl - SCW_LENGTH;
	if desc_type < SEG_B_E | desc_type > SEG_NB_E then/* invalid descriptor */
	     call INV_DESC;

     end CONVERT_DESC;
%page;
/* EOV_ON_WRITE - internal procedure to close out volume and initiate volume switch */

EOV_ON_WRITE: proc (who_called);

dcl  who_called bit (1) aligned;

	call pfm_utils_$write_file_labels (mtdp, EOV_LABEL, code); /* yes, write out the EOV labels */
	if code ^= 0 then return;			/* some problem with writing labels, give up */
	mtape_vol_set.volume_end = "0"b;		/* reset volume end flag */
	nvp = mtape_vol_set.next_vs_ptr;		/* copy pointer, in case its null */
	call mtape_$volume_switch (mtdp, nvp, code);	/* do the magic */
	if code ^= 0 then do;			/* could'nt do the switch */
	     call mtape_$error (mtdp, code,
		"Couldn't mount new volume at volume switch time");
	     return;
	end;
	vs_ptr = mtape_data.vs_current;		/* point to new volume */
	call INIT_VOL_LABELS;			/* init volume labels */
	if code ^= 0 then return;
	fi_ptr = null;				/* this will ensure we get file_info struct allocated */
	call pfm_utils_$setup_file (mtdp, fi_ptr, "1"b);	/* set up new file section structure */
	call pfm_utils_$write_file_labels (mtdp, BOF_LABEL, code); /* and write out the section header labels */
	if code ^= 0 then return;			/* if errors.. */
	mtape_data.prev_block_no = 0;			/* clear out block counter */
	if who_called = WRITING then do;		/* if actually writing data */
	     call mtape_$set_mode (mtdp, "data", mtape_data.hdw_mode, null, code); /* set hardware mode */
	     if code ^= 0 then return;
	     call mtape_$set_mode (mtdp, "length", mtape_data.length_mode, null, code); /* and special len mode */
	     if code ^= 0 then return;
	     if mtape_data.cur_buf_idx > lbound (mtape_data.buf_ptrs, 1) then do; /* if we have suspened bufs */
		if mtape_data.native_file then do;	/* if writing with buffer offsets */
		     do i = lbound (all_buf_ptrs, 1) to mtape_data.cur_buf_idx - 1; /* adjust block numbers */
			all_buf_ptrs (i) -> native_bo_contents.block_number = i;
		     end;
		end;
		call mtape_$flush_buffers (mtdp, code); /* flush out any suspended buffers */
	     end;
	end;

     end EOV_ON_WRITE;
%page;
/* GET_NXT_RECORD - subroutine to position to next logical record, reading nxt tape block if necessary */

GET_NXT_RECORD: proc;

dcl  term bit (1) aligned;
dcl  (block_no, i, j) fixed bin (21);

	term = "0"b;
	do while (^term);				/* in case we have to read 1 block of new file section */
	     call mtape_$read_block (mtdp, code);	/* so read it in */
	     if code ^= 0 then			/* if some error */
		if code = error_table_$end_of_info then do; /* if EOF, read trailer */
		     call LOAD_PTRS;		/* Load up structure pointers */
		     call pfm_utils_$read_file_labels (mtdp, fi_ptr, vs_ptr, label_type, fl_code);
		     if fl_code ^= 0 then do;		/* some problem reading labels, abort */
			code = fl_code;
			go to read_return;		/* Take non-local goto and return */
		     end;
		     if label_type = EOF_LABEL then	/* is this really end of the data file? */
			go to read_return;		/* Take non-local goto and return */
		     else if label_type = EOV_LABEL then do; /* No, volume switch has already been done */
			call CHECK_NEW_FILE_SECTION;	/* go check out new file section labels */
			if code ^= 0 then		/* some error */
			     go to read_return;	/* Take non-local goto and return */
		     end;
		     else do;			/* if label_type = BOF, this is error */
			code = error_table_$bad_file; /* set appropriate error code */
			call mtape_$error (mtdp, code,
			     "^/ANSI HDR1 file label found where EOF1 or EOV1 file label record expected");
			go to read_return;		/* Take non-local goto and return */
		     end;
		end;
		else go to read_return;		/* some other error, let user see what it is */
	     else do;				/* successfully read the block */
		term = "1"b;			/* set terminate condition */
		if mtape_data.native_file then do;	/* tape written by this module? */
		     on illegal_procedure call INV_DEC_DATA; /* if garbage catch it */
		     mtape_data.cur_block.length = native_bo_contents.block_size;
		     block_no = native_bo_contents.block_number; /* convert block number */
		     revert illegal_procedure;
		     if block_no ^= mtape_data.prev_block_no + 1 then do; /* check seq. */
			call mtape_$stop_tape (mtdp, code);
			code = error_table_$data_seq_error; /* set appropriate code */
			call mtape_$error (mtdp, code,
			     "Data block number was: ^d; S/B; ^d", block_no, mtape_data.prev_block_no + 1);
			go to read_return;		/* Take non-local goto and return */
		     end;
		     mtape_data.prev_block_no = block_no; /* save current block number */
		     mtape_data.remain = mtape_data.length - mtape_data.processed; /* reset, based on recorded len */
		end;
		if mtape_data.ad_file_format = 2 then do; /* if F/FB format, check padding */
		     i = mod (mtape_data.remain, mtape_data.record_size);
		     if i ^= 0 then			/* if block not modulus record size */
			if verify (substr (tblock, mtape_data.length - i + 1, i), mtape_data.padding_char) = 0 then
			     mtape_data.length = mtape_data.length - i;
		     j = divide ((mtape_data.length - mtape_data.processed), mtape_data.record_size, 21);
		     do i = j to 1 by -1 while (verify (substr (tblock, mtape_data.processed +
			(i - 1) * mtape_data.record_size, mtape_data.record_size), mtape_data.padding_char) = 0);
			mtape_data.length = mtape_data.length - mtape_data.record_size; /* wipe record, if all pad */
		     end;
		     mtape_data.remain = mtape_data.length - mtape_data.processed; /* recompute remaining chars */
		end;
	     end;
	end;

     end GET_NXT_RECORD;
%page;
/* INIT_VOL_LABELS - internal procedure to initialize and write the VOL1, UVL1 and dummy HDR1 and EOF1 label records */

INIT_VOL_LABELS: proc;

	if mtape_vol_set.first_file_unexpired then	/* if not expired */
	     if ^mtape_open_info.force then do;		/* and not ignoring expiration dates */
		call mtape_$user_query (mtdp, Q_UNEXPIRED_VOLUME, code); /* ask user */
		if code ^= 0 then return;		/* user does not want labels destroyed */
	     end;

	call mtape_$order (mtdp, "den", 0, addr (mtape_attach_info.density), code); /* Rewind and set density */
	if code ^= 0 then do;
	     call mtape_$error (mtdp, code,
		"^/While rewinding and setting density to ^d BPI on volume ^a prior to volume initialization",
		mtape_attach_info.density, mtape_vol_set.volume_id);
	     return;
	end;

	nlp = mtape_vol_set.first_vl_ptr;		/* arm the label record ptr */
	mtape_vol_set.volume_id = mtape_vol_set.volume_name;

	auth_code = authenticate_ ((mtape_vol_set.volume_id));
	do i = 1 to 2;				/* do it for both the VOL1 and UVL1 labels */
	     if nlp = null then			/* if no label record structure exists.. */
		call pfm_utils_$init_label_record (mtdp, mtape_vol_set.last_vl_ptr,
		     mtape_vol_set.first_vl_ptr, lr_ptr, LABEL_LENGTH);
	     else lr_ptr = nlp;			/* it does exist, use it */
	     nlp = mtape_label_record.next_lab_ptr;	/* update pointer for next label */
	     if i = 1 then do;			/* init VOL1 label */
		ansi_vol1P = mtape_label_record.lab_ptr;
		ansi_vol1.label_id = ANSI_VOL1;	/* set label id */
		ansi_vol1.volume_id = substr (mtape_vol_set.volume_id, 1,
		     maxlength (ansi_vol1.volume_id));	/* set canonical volume name */
		ansi_vol1.access = " ";		/* set for unlimited access */
		ansi_vol1.owner_id.auth_code = auth_code; /* set authentication code for RCP */
		ansi_vol1.owner_id.mult_id = MULTICS_ANSI_VERSION; /* indicate recorded by mtape_ */
		ansi_vol1.label_version = LABEL_STANDARD_VERSION; /* set ANSI version */
	     end;
	     else do;				/* initialize UVL1 label */
		ansi_uvl1P = mtape_label_record.lab_ptr;/* set pointer */
		ansi_uvl1.label_id = ANSI_UVL1;	/* set label ID */
		ansi_uvl1.auth_code = auth_code;	/* set authentication code */
		ansi_uvl1.init_date = pfm_utils_$julian_date (""); /* set current date */
		call system_info_$installation_id (install_id); /* set installation name */
		ansi_uvl1.installation_id = install_id;
		ansi_uvl1.user_id = get_group_id_ ();	/* set user name */
	     end;
	     call mtape_$write_label (mtdp, lr_ptr, code);/* write it out */
	     if code ^= 0 then do;			/* if unrecoverable error */
		call mtape_$error (mtdp, code,
		     "Attempting to write ANSI ^[VOL1^;UVL1^] label record on volume ^a.",
		     i, mtape_vol_set.volume_id);
		return;
	     end;
	end;
	mtape_vol_set.number_of_vol_labels = 2;		/* set this constant */
	if mtape_vol_set.last_vl_ptr ^= lr_ptr then do;	/* in case there were more labels before */
	     mtape_vol_set.last_vl_ptr = lr_ptr;	/* truncate the chain */
	     mtape_label_record.next_lab_ptr = null;
	end;

/* Now write the dummy HDR1 and EOF1 labels */

	lr_ptr = mtape_data.tlb;
	based_label_record = ANSI_L1_ID (BOF_LABEL) || DUMMY_LABEL; /* start with HDR1 label */
	do i = 1 to 2;				/* write 2 labels */
	     call mtape_$write_label (mtdp, lr_ptr, code);/* write it out */
	     if code ^= 0 then do;			/* if unrecoverable error */
		call mtape_$error (mtdp, code,
		     "^/While initializing volume ^a with dummy ANSI ^[HDR1^;EOF1^] label record",
		     mtape_vol_set.volume_id, i);
		return;
	     end;
	     call mtape_$order (mtdp, "eof", 2, null, code); /* write 2 EOF marks */
	     if code ^= 0 then do;
		call mtape_$error (mtdp, code,
		     "^/While writing 2 EOFs following dummy ANSI ^[HDR1^;EOF1^] label record on volume ^a",
		     i, mtape_vol_set.volume_id);
		return;
	     end;
	     substr (based_label_record, 1, 4) = ANSI_L1_ID (EOF_LABEL); /* EOF1 for 2nd iteration */
	end;
	mtape_vol_set.volume_density = mtape_attach_info.density; /* reset volume parameters to */
	mtape_vol_set.volume_type = Volume_ansi_tape;	/* reflect that its an ANSI volume recorded at */
	mtape_vol_set.volume_check = MTAPE_VOLUME;	/* requested density by mtape_ */

/* Position for writing first file */

	call mtape_$order (mtdp, "rew", 0, null, code);	/* Rewind to load point */
	if code ^= 0 then do;
	     call mtape_$error (mtdp, code,
		"^/While rewinding volume ^a after volume initialization", mtape_vol_set.volume_id);
	     return;
	end;
	call mtape_$order (mtdp, "fsr", 2, null, code);	/* position to write over dummy HDR1 label */
	if code ^= 0 then
	     call mtape_$error (mtdp, code,
		"^/While positioning for writing first file label on volume ^a", mtape_vol_set.volume_id);

     end INIT_VOL_LABELS;
%page;
/* INV_DEC_DATA - procedure to catch IPR faults which would result if block prefix block serial number
   and or block number were not in expected packed decimal format */

INV_DEC_DATA: proc;

dcl  blk_prefix_wds (2) fixed bin (35) based (mtape_data.cur_buf_ptr);

	code = error_table_$invalid_file_set_format;
	call mtape_$error (mtdp, code,
	     "^/^a ^d block prefix words (^w ^w octal) from packed decimal to binary",
	     "Attempting to convert block #", mtape_data.phy_block, blk_prefix_wds (1),
	     blk_prefix_wds (2));
	go to read_return;				/* take non-local goto and return */

     end INV_DEC_DATA;

/* INV_DESC - procedure to catch conversion error and report it */

INV_DESC: proc;

	call LOAD_PTRS;				/* Load structure pointers for exeception processing */
	code = error_table_$invalid_record_desc;	/* set appropriate error code */
	call mtape_$error (mtdp, code,
	     "^/^a ^a ^[R^;S^]CW at record ^d, block ^d, ^[of file section ^d ^;^s^]of file named ""^a"".",
	     "Converting ANSI", ANSI_FORMAT_CODES (mtape_file_info.file_format), (mtape_data.ad_file_format = 3),
	     mtape_data.log_record, mtape_data.phy_block, (mtape_file_info.section > 1),
	     mtape_file_info.section, mtape_file_info.file_id);
	go to read_return;				/* return to user with error */

     end INV_DESC;

/* LOAD_PTRS - procedure to load structure pointers for exeception processing
   of time critical external entries (read and write) */

LOAD_PTRS: proc;

	vs_ptr = mtape_data.vs_current;		/* load up pertinent structure pointers */
	fi_ptr = mtape_data.fi_current;
	maip = mtape_data.attach_info_ptr;
	moip = mtape_data.open_info_ptr;
	mpfmip = mtape_data.pfm_info_ptr;

     end LOAD_PTRS;
%page;
/* LONG_RECORD_CHECK - procedure to check if a requested write of a logical record will fit */

LONG_RECORD_CHECK: proc (length, rec_blk_ck);

dcl  length fixed bin (21);
dcl  rec_blk_ck bit (1) aligned;

	if rec_blk_ck then do;			/* comparing against record length */
	     if length > mtape_data.record_size then	/* is it to big */
		code = error_table_$long_record;	/* yes, set code */
	end;
	else if length > mtape_data.block_size then	/* comparing against blk size, will it fit */
	     code = error_table_$long_record;		/* no, set code */
	if code ^= 0 then				/* if we have a long record.. */
	     go to write_return;			/* take non-local goto to write return exit */

     end LONG_RECORD_CHECK;
%page;
/* MOVE_TO_BUFFER - subroutine to move user data to tape buffer on write,
   initiating a write of the buffer if full */

MOVE_TO_BUFFER: proc (cwl, min_len);

dcl  cwl fixed bin;					/* control word length */
dcl  min_len fixed bin;				/* minimum length of next record */
dcl  pad_chars fixed bin;
dcl  rcd_pad char (pad_chars) based (addr (tape_blk (mtape_data.processed + move_len + 1)));

	if mtape_data.conversion = MTAPE_CV_EBCDIC then	/* if data recorded in ebcdic.. */
	     call ascii_to_ebcdic_ (buf_ptr -> based_lrec_data, move_ptr -> based_lrec_data);
	else move_ptr -> based_lrec_data = buf_ptr -> based_lrec_data; /* move data to tape buffer */
	if (mtape_data.ad_file_format = 1) | (mtape_data.ad_file_format = 2) then /* If "U" or "F" or "FB" format */
	     if move_len < mtape_data.record_size then do;/* and record is not fUll */
		pad_chars = mtape_data.record_size - move_len; /* pad record out with blanks */
		rcd_pad = copy (" ", pad_chars);
		if mtape_data.conversion = MTAPE_CV_EBCDIC then /* make them ebcdic blanks */
		     call ascii_to_ebcdic_ (rcd_pad, rcd_pad); /* if appropriate */
		move_len = mtape_data.record_size;	/* reflect on all data moved */
	     end;
	mtape_data.processed = mtape_data.processed + move_len + cwl; /* add up bytes processed */
	mtape_data.remain = mtape_data.block_size - mtape_data.processed; /* decrement remaining bytes */
	if ^mtape_data.file_blocked then		/* if not "FB", "DB", or "SB" format */
	     call WRITE_BLOCK;			/* write the block out now */
	else if mtape_data.remain < min_len then	/* if blocked but block full.. */
	     call WRITE_BLOCK;			/* write the block out now */
	else mtape_data.log_record_ptr = addr (tape_blk (mtape_data.processed + 1));
						/* Not blocked, set for next lrec */

     end MOVE_TO_BUFFER;
%page;
/* MOVE_TO_USER - subroutine to move data from tape buffer to user buffer on read */

MOVE_TO_USER: proc;

	if buf_ptr = null then			/* if caller just wants length.. */
	     rec_len = rec_len + move_len;		/* thats it */
	else do;					/* this is a real read */
	     if ^long_record then do;			/* if we can still fit the data in */
		if buf_len - move_len < 0 then do;
		     long_record = "1"b;		/* we have more data than user can take */
		     move_len = buf_len;		/* move what we can */
		end;
		buf_len = buf_len - move_len;		/* and decrement length remaining in users buffer */
		if move_len > 0 then do;		/* if we have some data to move, move it */
		     if mtape_data.conversion = MTAPE_CV_EBCDIC then /* tape recorded in ebcdic */
			call ebcdic_to_ascii_ (move_ptr -> based_lrec_data, buf_ptr -> based_lrec_data);
		     else buf_ptr -> based_lrec_data = move_ptr -> based_lrec_data; /* move computed of bytes */
		     rec_len = rec_len + move_len;	/* tell user how long record is anyway */
		     buf_ptr = addr (based_lrec_index (rec_len + 1)); /* increment users buffer ptr */
		end;
	     end;
	end;
	mtape_data.processed = mtape_data.processed + crl;
	mtape_data.remain = mtape_data.cur_block.length - mtape_data.processed;
	if mtape_data.remain > 0 then
	     mtape_data.log_record_ptr = addr (tape_blk (mtape_data.processed + 1));

     end MOVE_TO_USER;
%page;
/* NEED_TO_INIT_VOLUME - function to determine if a tape volume requires initializaton */

NEED_TO_INIT_VOLUME: proc returns (bit (1) aligned);

	if mtape_vol_set.volume_check > NON_MULT_VOLUME then /* if this is not an ANSI volume */
	     return ("1"b);
	if mtape_open_info.modify | mtape_open_info.extend then /* if modifying or extending */
	     return ("0"b);				/* existing file, do not init volume */
	if ^mtape_data.first_file then do;		/* if the first opening */
	     if mtape_open_info.seq_number = 1 then	/* or we want file number 1 */
		return ("1"b);
	     if mtape_open_info.next_file then		/* or next (first) file */
		return ("1"b);
	end;
	return ("0"b);

     end NEED_TO_INIT_VOLUME;
%page;
/* SET_FILE_FORMAT - internal procedure to set file format in file info from open data */

SET_FILE_FORMAT: proc;

	temp_fmt = translate (mtape_open_info.file_format, UC, LC);
						/* file format in upper case */
	mtape_file_info.file_code = temp_fmt;		/* set file code */
	do i = 0 to hbound (ANSI_FORMAT_CODES, 1);	/* set the file format */
	     if temp_fmt = ANSI_FORMAT_CODES (i) then	/* found it */
		mtape_file_info.file_format = i;
	end;

     end SET_FILE_FORMAT;

/* SET_OPEN_IDX - subroutine to determine what kind of opening this is */

SET_OPEN_IDX: proc;

	if mtape_open_info.open_mode = Sequential_input then do; /* input operation? */
	     output = "0"b;				/* yes, reset output flag */
	     open_idx = 0;				/* and set input open idx value */
	end;
	else do;					/* some type of output operation */
	     output = "1"b;				/* true if sqo or sqio */
	     if mtape_open_info.pfm_opt_sw (1) then	/* if generating a file */
		open_idx = 4;
	     else if mtape_open_info.modify then	/* if modifying an existing file */
		open_idx = 3;
	     else if mtape_open_info.extend then	/* if extending current file */
		open_idx = 2;
	     else open_idx = 1;			/* otherwise create new file */
	end;

     end SET_OPEN_IDX;

/* SET_RECORD_SIZE - internal procedure to set record size either from defaults or as specified by the user */

SET_RECORD_SIZE: proc;

	if mtape_open_info.record_length = MTAPE_UNSPECIFIED then do; /* if no "-record" value specified by user */
	     if index (mtape_file_info.file_code, "S") ^= 0 then /* if Spanned format */
		mtape_file_info.record_size = mtape_open_info.default_span_rlen; /* set default */
	     else if index (mtape_file_info.file_code, "D") ^= 0 then /* if variable format */
		mtape_file_info.record_size = mtape_open_info.default_var_rlen; /* set default */
	     else mtape_file_info.record_size = mtape_open_info.default_fix_rlen; /* assume fixed or U format */
	end;
	else mtape_file_info.record_size = mtape_open_info.record_length; /* if user specified it */

     end SET_RECORD_SIZE;
%page;
/* SET_RECORDING_MODE - internal procedure to set the recording mode in the file_info structure */

SET_RECORDING_MODE: proc;

	mtape_file_info.conversion = MTAPE_NO_CONVERSION; /* set no conversion as default */
	temp_mode = translate (mtape_open_info.recording_mode, UC, LC); /* mode to UC */
	if temp_mode = "ASCII" then			/* record in standard ascii mode */
	     mtape_file_info.hdw_mode = MTAPE_HWM_NINE;
	else if temp_mode = "EBCDIC" then do;		/* record in ebcdic mode */
	     mtape_file_info.hdw_mode = MTAPE_HWM_NINE;
	     mtape_file_info.conversion = MTAPE_CV_EBCDIC;/* set conversion for ASCII <==> EBCDIC */
	end;
	else mtape_file_info.hdw_mode = MTAPE_HWM_BIN;	/* Must be binary mode */
     end SET_RECORDING_MODE;

/* SETUP - internal procedure to set up enviornment for the external entries */

SETUP: proc;

	mtdp = arg_mtdp;				/* get pointers to pertinient data */
	vs_ptr = mtape_data.vs_current;
	fi_ptr = mtape_data.fi_current;
	maip = mtape_data.attach_info_ptr;
	moip = mtape_data.open_info_ptr;
	mpfmip = mtape_data.pfm_info_ptr;
	arg_code, code = 0;				/* and reset error codes */

     end SETUP;
%page;
/* SETUP_NEW_FILE - procedure to create a file info structure and initialize it with open options */

SETUP_NEW_FILE: proc;

	if fi_ptr ^= null then			/* if replacing existing file */
	     if ^mtape_open_info.force then		/* and not ignoring expiration dates */
		if pfm_utils_$label_unexpired ((mtape_file_info.expiration_date)) then do;	/* if expiration date is in future */
		     call mtape_$user_query (mtdp, Q_UNEXPIRED_FILE, code); /* ask user what to do */
		     if code ^= 0 then return;	/* abort file opening on "no" answer */
		     if mtape_file_info.position_within_file ^= AT_BOFH then do;
			call pfm_utils_$position_in_file (mtdp, fi_ptr, vs_ptr, AT_BOFH, code);
			if code ^= 0 then return;
		     end;
		end;
	call pfm_utils_$setup_file (mtdp, fi_ptr, "0"b);	/* do the common stuff first */
	call SET_FILE_FORMAT;			/* set the file format in file info structure */
	call SET_RECORDING_MODE;			/* set the recording mode */
	if mtape_file_info.record_size = MTAPE_UNSPECIFIED then /* no record length */
	     call SET_RECORD_SIZE;			/* either use given or default */
	if mtape_open_info.pfm_opt_sw (2) then		/* if buffer offset specified */
	     mtape_file_info.buffer_offset = size (native_bo_contents) * 4; /* set the size */
	else do;
	     mtape_file_info.native_file = "0"b;	/* otherwise reset this flag */
	     mtape_file_info.buffer_offset = 0;		/* and set for no buffer offset */
	end;
	mtape_file_info.generation = 1;		/* set up as constants for now */
	mtape_file_info.gen_version = 0;
	mtape_file_info.creation_date = pfm_utils_$julian_date (""); /* set todays date */
	if mtape_open_info.expiration ^= "" then	/* if expiration specified.. */
	     mtape_file_info.expiration_date = pfm_utils_$julian_date ((mtape_open_info.expiration));
	else mtape_file_info.expiration_date = " 00000";	/* no expiration specified */

SET_FILE_ATTRIBUTES: entry;				/* to set file attributes if not already set */

	if mtape_file_info.file_format = MTAPE_UNSPECIFIED then /* if file format not specified */
	     call SET_FILE_FORMAT;
	mtape_file_info.length_mode = NON_MOD_FOUR;	/* set special length mode as default */
	if mtape_file_info.hdw_mode = MTAPE_UNSPECIFIED then /* recording mode not set */
	     call SET_RECORDING_MODE;			/* set it */
	if mtape_file_info.block_size = MTAPE_UNSPECIFIED then /* no block size */
	     mtape_file_info.block_size = mtape_open_info.block_length; /* use given */
	if mtape_file_info.record_size = MTAPE_UNSPECIFIED then /* no record length */
	     call SET_RECORD_SIZE;			/* either use given or default */
	if mtape_data.conversion = MTAPE_CV_EBCDIC then	/* if converting to ebcdic */
	     mtape_data.padding_char = ANSI_EBCDIC_PAD_CHAR; /* set EBCDIC pad char */
	else mtape_data.padding_char = ANSI_ASCII_PAD_CHAR; /* otherwise set ASCII pad char */

     end SETUP_NEW_FILE;
%page;
/* WRITE_BLOCK - procedure to write out the current block when full */

WRITE_BLOCK: proc;

	if mtape_data.native_file then do;		/* tape written entirely by this module? */
	     native_bo_contents.block_size = mtape_data.processed; /* yes, store block size */
	     native_bo_contents.block_number = mtape_data.phy_block + 1; /* store block serial number */
	end;
	call mtape_$write_block (mtdp, code);
	if code ^= 0 then				/* some error */
	     if code = error_table_$eov_on_write then do; /* Is it end of tape? */
		call LOAD_PTRS;			/* Load up structure pointers */
		call EOV_ON_WRITE (WRITING);		/* Go close out volume and initiate volume switch */
		if code ^= 0 then
		     go to write_return;		/* If problem, take non-local goto and return */
	     end;
	     else go to write_return;			/* other error return to caller */

     end WRITE_BLOCK;
%page;
%include mtape_includes;
%page;
%include rcp_volume_formats;
%page;
%include ansi_vol1;
%include ansi_uvl1;
%page;
%include ansi_hdr1;
%page;
%include ansi_hdr2;
%page;
%include iox_modes;

     end ansi_tape_io_;
