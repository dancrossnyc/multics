/****^  **************************************************************
        *                                                            *
        * Copyright, (C) Massachusetts Institute of Technology, 1983 *
        *                                                            *
        * Copyright (c) 1972 by Massachusetts Institute of           *
        * Technology and Honeywell Information Systems, Inc.         *
        *                                                            *
        ************************************************************** */




/****^  HISTORY COMMENTS:
  1) change(78-04-06,Palter), approve(), audit(), install():
     Written.
  2) change(79-02-02,MJordan), approve(), audit(), install():
     Extensively modified.
  3) change(81-01-12,Herbst), approve(81-01-12,MCR5511), audit(), install():
     Changed to format output based on line length.
  4) change(83-02-26,Pattin), approve(), audit(), install():
     Added extended object support to entries and files.
  5) change(84-01-12,Lippard), approve(84-03-06,MCR6781), audit(), install():
     Fixed output formatting, corrected to not return the same name twice,
     and made command invocation print an error when no matches are found.
  6) change(84-09-11,Lippard), approve(84-09-18,MCR7010), audit(), install():
     Changed to properly return matching link and change -type to
     -select_entry_type (-slet).
  7) change(85-02-12,Lippard), approve(), audit(), install():
     Changed to call Cleanup procedure when no entries are found.
  8) change(86-01-23,KFleming), approve(86-01-23,MCR7333),
     audit(86-08-05,Lippard), install(86-08-06,MR12.0-1116):
     Combined exists and entries into one module, since they have so much code
     in common. Also added the object_segments/nonobject_segments keywords and
     commands.
  9) change(86-11-10,GDixon), approve(86-11-24,MCR7579),
     audit(86-11-17,Lippard), install(86-12-01,MR12.0-1229):
     Added object_files/nonobject_files and object_msfs/nonobject_msfs
     entrypoints and keywords for exists.
                                                   END HISTORY COMMENTS */


/* format: style4,indattr */
entries: procedure () options (variable);

/* This command/active-function returns the entrynames (or pathnames) which match a given
   set of pathnames containing starnames, or if called as exists, returns true/false,
   if there were any matching names found.
*/

/* Automatic */

dcl  active_function        bit (1) aligned;
dcl  archive_bc	        fixed binary (24);
dcl  archive_ptr	        pointer;
dcl  arg_count	        fixed binary;
dcl  argument	        character (argument_lth) based (argument_ptr);
dcl  argument_lth	        fixed binary (21);
dcl  argument_ptr	        pointer;
dcl  c_ptr	        pointer;
dcl  char_168	        character (168);
dcl  chars_left	        fixed bin;
dcl  chase	        bit (1);
dcl  code		        fixed binary (35);
dcl  command_name	        character (32) varying;
dcl  component	        character (32);
dcl  dir		        character (168) unaligned;
dcl  dir_dname	        character (168) unaligned;
dcl  dir_ename	        character (32) unaligned;
dcl  ename	        character (32);
dcl  entry_index	        fixed bin;
dcl  entry_type_count       fixed bin;
dcl  entry_type_no	        fixed bin;
dcl  entry_type_ptr	        pointer;
dcl  error	        entry () options (variable) variable;
dcl  first_arg	        fixed binary;
dcl  found_something        bit (1) aligned;
dcl  found_uid	        bit (1) aligned;
dcl  fs_type	        character (32);
dcl  get_argument	        entry (fixed binary, pointer, fixed binary (21), fixed binary (35)) variable;
dcl  got_key	        bit (1) aligned;
dcl  idx		        fixed binary;
dcl  inhibit_error	        bit (1) aligned;
dcl  jdx		        fixed binary;
dcl  kdx		        fixed binary;
dcl  kname_index	        fixed binary;
dcl  line_length	        fixed bin;
dcl  link_array_ptr	        ptr;
dcl  n_link_names	        fixed bin (21);
dcl  n_uids	        fixed bin (21);
dcl  old_ename	        character (32);
dcl  return_absolute_pathnames bit (1) aligned;
dcl  return_names	        bit (1) aligned;
dcl  return_value	        character (return_value_lth) varying based (return_value_ptr);
dcl  return_value_lth       fixed binary (21);
dcl  return_value_ptr       pointer;
dcl  seg_ptr	        pointer;
dcl  select_entry_type      bit (1) aligned;
dcl  space	        character (2) varying;
dcl  starname_count	        fixed binary;
dcl  starnames	        (20) character (168);
dcl  system_area	        area based (system_area_ptr);
dcl  system_area_ptr        ptr;
dcl  table_index	        fixed binary;
dcl  1 type_info	        aligned like suffix_info;
dcl  uid_array_ptr	        ptr;
dcl  unique_id	        bit (36) aligned;

/* Based */

dcl  link_array	        (sys_info$max_seg_size / 8) char (32) aligned based (link_array_ptr);
dcl  uid_array	        (sys_info$max_seg_size) bit (36) aligned based (uid_array_ptr);
dcl  1 entry_type	        aligned based (entry_type_ptr),
       2 count	        fixed bin,
       2 suffix	        (entry_type_count refer (entry_type.count)) char (32) unaligned;

/* External Data */

dcl  iox_$user_output       ptr ext;
dcl  active_fnc_err_        entry options (variable);
dcl  archive_$get_component entry (ptr, fixed bin (24), char (*), ptr, fixed bin (24), fixed bin (35));
dcl  archive_$next_component entry (ptr, fixed bin (24), ptr, fixed bin (24), char (*), fixed bin (35));
dcl  com_err_	        entry options (variable);
dcl  check_star_name_$entry entry (char (*), fixed bin (35));
dcl  cu_$af_arg_ptr	        entry (fixed binary, pointer, fixed binary (21), fixed binary (35));
dcl  cu_$af_return_arg      entry (fixed binary, pointer, fixed binary (21), fixed binary (35));
dcl  cu_$arg_count	        entry (fixed binary);
dcl  cu_$arg_ptr	        entry (fixed binary, pointer, fixed binary (21), fixed binary (35));
dcl  error_table_$archive_fmt_err fixed bin (35) ext static;
dcl  error_table_$archive_pathname fixed bin (35) ext static;
dcl  error_table_$bad_arg   fixed bin (35) ext static;
dcl  error_table_$badopt    fixed binary (35) external;
dcl  error_table_$no_s_permission fixed binary (35) external;
dcl  error_table_$noarg     fixed binary (35) external;
dcl  error_table_$no_dir    fixed bin (35) ext static;
dcl  error_table_$noentry   fixed bin (35) ext static;
dcl  error_table_$nomatch   fixed binary (35) external;
dcl  error_table_$not_act_fnc fixed binary (35) external;
dcl  error_table_$not_archive fixed bin (35) ext static;
dcl  error_table_$too_many_args fixed bin (35) ext static;
dcl  expand_pathname_       entry (character (*), character (*), character (*), fixed binary (35));
dcl  expand_pathname_$add_suffix entry (char (*), char (*), char (*), char (*), fixed bin (35));
dcl  expand_pathname_$component entry (char (*), char (*), char (*), char (*), fixed bin (35));
dcl  fs_util_$get_type      entry (char (*), char (*), char (*), fixed bin (35));
dcl  fs_util_$suffix_info_for_type entry (char (*), ptr, fixed bin (35));
dcl  get_line_length_$switch entry (ptr, fixed bin (35)) returns (fixed bin);
dcl  get_system_free_area_  entry () returns (pointer);
dcl  get_temp_segment_      entry (char (*), ptr, fixed bin (35));
dcl  hcs_$get_uid_file      entry (char (*), char (*), bit (36) aligned, fixed bin (35));
dcl  hcs_$star_dir_list_    entry (char (*), char (*), fixed bin (3), ptr, fixed bin, fixed bin, ptr, ptr, fixed bin (35));
dcl  hcs_$status_minf       entry (char (*), char (*), fixed bin (1), fixed bin (2), fixed bin (24), fixed bin (35));
dcl  initiate_file_	        entry (char (*), char (*), bit (*), ptr, fixed bin (24), fixed bin (35));
dcl  ioa_		        entry () options (variable);
dcl  ioa_$nnl	        entry () options (variable);
dcl  match_star_name_       entry (char (*), char (*), fixed bin (35));
dcl  object_lib_$initiate   entry (char(*), char(*), char(*), bit(1), ptr, fixed bin(24), bit(1), fixed bin(35));
dcl  pathname_	        entry (char(*), char(*)) returns(char(168));
dcl  release_temp_segment_  entry (char (*), ptr, fixed bin (35));
dcl  requote_string_        entry (character (*)) returns (character (*));
dcl  sys_info$max_seg_size  fixed bin (35) ext static;
dcl  terminate_file_        entry (ptr, fixed bin (24), bit (*), fixed bin (35));

/* Conditions */

dcl  cleanup	        condition;

/* Builtins */

dcl  (addr, after, before, binary, divide, hbound, index, length, max, null, rtrim, substr) builtin;

/*
   The following are manifest constants used in this procedure. The following descriptions should help in reading this
   code:

   I_D_		D_E_S_C_R_I_P_T_I_O_N_

   MSF		the missing storage system entry type
   XXXX_EI	the "entry index" for the XXXX type
   COMMAND_NAME	the command name used in error messages
   SELECT_SW	the star_select_sw that is appropriate
*/


dcl  MSF		        fixed bin static internal options (constant) init (3);

dcl  SEGMENTS_EI	        static internal options (constant) init (1);
dcl  DIRECTORIES_EI	        static internal options (constant) init (2);
dcl  MSFS_EI	        static internal options (constant) init (3);
dcl  LINKS_EI	        static internal options (constant) init (4);
dcl  ENTRIES_EI	        static internal options (constant) init (5);
dcl  BRANCHES_EI	        static internal options (constant) init (6);
dcl  FILES_EI	        static internal options (constant) init (7);
dcl  ZERO_SEGMENTS_EI       static internal options (constant) init (8);
dcl  MASTER_DIRECTORIES_EI  static internal options (constant) init (9);
dcl  NULL_LINKS_EI	        static internal options (constant) init (10);
dcl  NONSEGMENTS_EI	        static internal options (constant) init (11);
dcl  NONDIRECTORIES_EI      static internal options (constant) init (12);
dcl  NONMSFS_EI	        static internal options (constant) init (13);
dcl  NONFILES_EI	        static internal options (constant) init (14);
dcl  NONZERO_SEGMENTS_EI    static internal options (constant) init (15);
dcl  NONMASTER_DIRECTORIES_EI static internal options (constant) init (16);
dcl  NONNULL_LINKS_EI       static internal options (constant) init (17);
dcl  NONZERO_FILES_EI       static internal options (constant) init (18);
dcl  NONZERO_MSFS_EI        static internal options (constant) init (19);
dcl  NONBRANCHES_EI	        static internal options (constant) init (20);
dcl  NONLINKS_EI	        static internal options (constant) init (21);
dcl  OBJECT_FILES_EI        static internal options (constant) init (22);
dcl  NONOBJECT_FILES_EI     static internal options (constant) init (23);
dcl  OBJECT_MSFS_EI	        static internal options (constant) init (24);
dcl  NONOBJECT_MSFS_EI      static internal options (constant) init (25);
dcl  OBJECT_SEGMENTS_EI     static internal options (constant) init (26);
dcl  NONOBJECT_SEGMENTS_EI  static internal options (constant) init (27);
/*
dcl  COMPONENTS_EI	        static internal options (constant) init (28);
			"exists components" has no corresponding
			entrypoint in the entries family of commands */
dcl  EXISTS_EI	        static internal options (constant) init (29);

dcl  COMMAND_NAME	        (29) char (24) static internal options (constant) init (
		        "segments",
		        "directories",
		        "msfs",
		        "links",
		        "entries",
		        "branches",
		        "files",
		        "zero_segments",
		        "master_directories",
		        "null_links",
		        "nonsegments",
		        "nondirectories",
		        "nonmsfs",
		        "nonfiles",
		        "nonzero_segments",
		        "nonmaster_directories",
		        "nonnull_links",
		        "nonzero_files",
		        "nonzero_msfs",
		        "nonbranches",
		        "nonlinks",
		        "object_files",
		        "nonobject_files",
		        "object_msfs",
		        "nonobject_msfs",
		        "object_segments",
		        "nonobject_segments",
		        *,		/* Place holder for 
					   exists component */
		        "exists");

dcl  SELECT_SW	        (29) fixed bin static internal options (constant) init (
		        2, 2, 2, 1, 3, 2, 2, 2, 2, 5,
		        3, 3, 3, 3, 3, 2, 5, 2, 2, 1,
		        2, 2, 2, 2, 2, 2, 2, 2, *);
					/* Note: the above SELECT_SW
					   value for EXISTS_EI is
					   not used. */
dcl  TRUE		        bit (1) internal static options (constant) initial ("1"b);
dcl  FALSE	        bit (1) internal static options (constant) initial ("0"b);
dcl  KEY_NAME	        (47) char (24) int static options (constant) init (
        "branch",		       "nonbranch",
        "component",
        "directory", "dir",	       "nondirectory", "nondir",
        "entry",
        "file",		       "nonfile",
        "link",		       "nonlink",
        "master_directory", "mdir",  "nonmaster_directory", "nmdir",
        "msf",		       "nonmsf",
        "null_link", "nlink",	       "non_null_link", "nonnull_link", "nnlink",
        "object_file", "obfile",     "nonobject_file", "nobfile",
        "object_msf", "obmsf",       "nonobject_msf", "nobmsf",
        "object_segment", "obseg",   "nonobject_segment", "nobseg",
        "segment", "seg",	       "nonsegment", "nonseg",
			       "nonzero_file", "nzfile",
			       "nonzero_msf", "nzmsf",
        "zero_segment", "zseg",      "nonzero_segment", "nzseg");
dcl  INDEX_TAB	        (47) fixed bin static internal options (constant) init (
     6,  /* branch */		20,  /* nonbranch */
    28,  /* component */
 2,  2,  /* directory */            12, 12,  /* nondirectory */
     5,  /* entry */
     7,  /* file */			14,  /* nonfile */
     4,  /* link */			21,  /* nonlink */
 9,  9,  /* master_directory */     16, 16,  /* nonmaster_directory */
     3,  /* msf */			13,  /* nonmsf */
10, 10,  /* null_link */        17, 17, 17,  /* non_null_link */
22, 22,  /* object_file */	      23, 23,  /* nonobject_file */
24, 24,  /* object_msf */	      25, 25,  /* nonobject_msf */
26, 26,  /* object_segment */	      27, 27,  /* nonobject_segment */
 1,  1,  /* segment */	      11, 11,  /* nonsegment */
			      18, 18,  /* nonzero_file */
			      19, 19,  /* nonzero_msf */
 8,  8,  /* zero_segment */	      15, 15); /* nonzero_segment */
dcl  CHASE_OK	        (29) bit (1) unaligned internal static options (constant) initial (
	        "1"b, "1"b, "1"b, "0"b, "1"b, "1"b, "1"b, "1"b, "1"b, "0"b,
	        "1"b, "1"b, "1"b, "1"b, "1"b, "1"b, "0"b, "1"b, "1"b, "0"b,
	        "1"b, "1"b, "1"b, "1"b, "1"b, "1"b, "1"b, "1"b, "1"b);
dcl  ROOT		        (29) bit (1) unaligned internal static options (constant) initial (
	        "0"b, "1"b, "0"b, "0"b, "1"b, "1"b, "0"b, "0"b, "1"b, "0"b,
	        "1"b, "0"b, "1"b, "1"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b,
	        "1"b, "0"b, "1"b, "0"b, "1"b, "0"b, "1"b, "0"b, "0"b);

/*

   The following are all of the entries to this command/active function. At each entry the entry_index is set using
   the constants declared above and control is passed to the common code below.

*/


/* entries: proc() options (variable); */

	entry_index = ENTRIES_EI;
	goto COMMON;

files:
     entry () options (variable);

	entry_index = FILES_EI;
	go to COMMON;

segments:
segs:
     entry () options (variable);

	entry_index = SEGMENTS_EI;
	go to COMMON;

directories:
dirs:
     entry () options (variable);

	entry_index = DIRECTORIES_EI;
	go to COMMON;

links:
     entry () options (variable);

	entry_index = LINKS_EI;
	go to COMMON;

branches:
     entry () options (variable);

	entry_index = BRANCHES_EI;
	go to COMMON;

nonsegments:
nonsegs:
     entry () options (variable);

	entry_index = NONSEGMENTS_EI;
	go to COMMON;

nondirectories:
nondirs:
     entry () options (variable);

	entry_index = NONDIRECTORIES_EI;
	go to COMMON;

msfs:
     entry options (variable);

	entry_index = MSFS_EI;
	goto COMMON;

zero_segments:
zsegs:
     entry options (variable);

	entry_index = ZERO_SEGMENTS_EI;
	goto COMMON;

master_directories:
mdirs:
     entry () options (variable);

	entry_index = MASTER_DIRECTORIES_EI;
	goto COMMON;

null_links:
nlinks:
     entry () options (variable);

	entry_index = NULL_LINKS_EI;
	goto COMMON;

nonmsfs:
     entry () options (variable);

	entry_index = NONMSFS_EI;
	goto COMMON;

nonfiles:
     entry () options (variable);

	entry_index = NONFILES_EI;
	goto COMMON;

nonzero_segments:
nzsegs:
     entry () options (variable);

	entry_index = NONZERO_SEGMENTS_EI;
	goto COMMON;

nonmaster_directories:
nmdirs:
     entry () options (variable);

	entry_index = NONMASTER_DIRECTORIES_EI;
	goto COMMON;

nonnull_links:
nnlinks:
     entry () options (variable);

	entry_index = NONNULL_LINKS_EI;
	goto COMMON;

nonzero_files:
nzfiles:
     entry () options (variable);

	entry_index = NONZERO_FILES_EI;
	goto COMMON;

nonzero_msfs:
nzmsfs:
     entry () options (variable);

	entry_index = NONZERO_MSFS_EI;
	goto COMMON;

object_files:
obfiles:
     entry () options (variable);

	entry_index = OBJECT_FILES_EI;
	goto COMMON;

nonobject_files:
nobfiles:
     entry () options (variable);

	entry_index = NONOBJECT_FILES_EI;
	goto COMMON;

object_msfs:
obmsfs:
     entry () options (variable);

	entry_index = OBJECT_MSFS_EI;
	goto COMMON;

nonobject_msfs:
nobmsfs:
     entry () options (variable);

	entry_index = NONOBJECT_MSFS_EI;
	goto COMMON;

object_segments:
obsegs:
     entry () options (variable);

	entry_index = OBJECT_SEGMENTS_EI;
	goto COMMON;

nonobject_segments:
nobsegs:
     entry () options (variable);

	entry_index = NONOBJECT_SEGMENTS_EI;
	goto COMMON;

nonbranches:
     entry () options (variable);

	entry_index = NONBRANCHES_EI;
	goto COMMON;

nonlinks:
     entry () options (variable);

	entry_index = NONLINKS_EI;
	goto COMMON;

exists:
     entry () options (variable);

	entry_index = EXISTS_EI;
	goto COMMON;

/*
   The following is code common to all entries.
*/
COMMON:
	system_area_ptr = get_system_free_area_ ();

	star_list_branch_ptr,
	     star_list_names_ptr = null ();

	space = "";				/* no space before first pathname */

	entry_type_ptr, seg_ptr, archive_ptr, link_array_ptr, uid_array_ptr = null ();

	on condition (cleanup)
	     call Cleanup ();

	command_name = COMMAND_NAME (entry_index);	/* get the proper command name */
	found_something = FALSE;

	call cu_$af_return_arg (arg_count, return_value_ptr, return_value_lth, code);

	if code = error_table_$not_act_fnc
	then do;					/* not an active function */
	     active_function = FALSE;
	     call cu_$arg_count (arg_count);		/* get proper argument count */
	     get_argument = cu_$arg_ptr;
	     error = com_err_;
	end;

	else do;					/* active function */
	     active_function = TRUE;
	     get_argument = cu_$af_arg_ptr;
	     error = active_fnc_err_;
	end;

	if entry_index = EXISTS_EI then do;
	     return_names = FALSE;
	     first_arg = 2;
	     if arg_count < 1 then do;
USAGE:		call error (error_table_$noarg, command_name, "Usage: ^[[^]^a key star_name(s) {-control_arg(s)} ^[]^]", active_function, command_name, active_function);
		return;
	     end;
	     call get_argument (1, argument_ptr, argument_lth, code);
	     if code ^= 0 then goto ARGERR;

	     if argument = "argument" then do;
		found_something = (arg_count > 1);
		goto DONE;
	     end;
	     else if arg_count < 2 then goto USAGE;

	     got_key = FALSE;
	     do kname_index = 1 to hbound (KEY_NAME, 1) while (^got_key);
		got_key = (argument = KEY_NAME (kname_index));
	     end;
	     if ^got_key then do;
		call error (0, command_name, "Invalid key ^a.", argument);
		return;
	     end;

	     kname_index = kname_index - 1;
	     table_index = INDEX_TAB (kname_index);
	end;
	else do;
	     kname_index = 1;
	     return_names = TRUE;
	     first_arg = 1;
	     table_index = entry_index;
	end;

	star_select_sw = SELECT_SW (table_index);	/* select switch for this entry */

/*
   Scan the command arguments to make sure we have at least one starname and that only valid control arguments are
   specified by the user.
*/
	starname_count = 0;
	inhibit_error, chase, select_entry_type, return_absolute_pathnames = FALSE;

	do idx = first_arg to arg_count;
	     call get_argument (idx, argument_ptr, argument_lth, code);
	     if code ^= 0 then do;
ARGERR:		call error (code, command_name);
		return;
	     end;
	     if substr (argument, 1, 1) = "-" then do;
		if ((argument = "-absolute_pathname") | (argument = "-absp")) & return_names then return_absolute_pathnames = TRUE;
		else if (argument = "-chase") & CHASE_OK (table_index)
		then chase = TRUE;
		else if (argument = "-no_chase") & CHASE_OK (table_index)
		then chase = FALSE;
		else if (argument = "-inhibit_error" | argument = "-ihe")
		then inhibit_error = TRUE;
		else if (argument = "-no_inhibit_error" | argument = "-nihe")
		then inhibit_error = FALSE;
		else if (table_index = ENTRIES_EI | table_index = FILES_EI | table_index = EXISTS_EI) & ((argument = "-select_entry_type") | (argument = "-slet")) then do;
		     if idx = arg_count then do;
			call error (error_table_$noarg, command_name, "^a requires an entry type list.", argument);
			return;
		     end;
		     idx = idx + 1;
		     call get_argument (idx, argument_ptr, argument_lth, code);
		     if code ^= 0 then goto ARGERR;
		     call process_entry_type_list (argument, entry_type_ptr, select_entry_type);
		     if ^select_entry_type then do;
			call error (error_table_$bad_arg, command_name, "Invalid entry type selected. ^a", argument);
			return;
		     end;
		end;
		else do;				/* unknown control */
		     call error (error_table_$badopt, command_name, "^a", argument);
		     return;
		end;
	     end;
	     else do;
		if starname_count = 20 then do;
		     call error (error_table_$too_many_args, command_name, "Only 20 starnames may be specified.");
		     goto ABORT;
		end;
		starname_count = starname_count + 1;
		starnames (starname_count) = argument;
	     end;
	end;

	if starname_count = 0 then do;
	     call error (error_table_$noarg, command_name,
		"^/    Usage:  ^[[^;^]^a starnames {-control_arg^[s^]}^[]^;^]",
		active_function, command_name, (CHASE_OK (table_index)), active_function);
	     goto ABORT;
	end;

	if star_select_sw = star_BRANCHES_ONLY & chase
	then star_select_sw = star_ALL_ENTRIES;

/*
   Now that we are all set, process the starnames in order.
*/

	if return_names then do;
	     if ^active_function then line_length, chars_left = get_line_length_$switch (iox_$user_output, (0));

	     call get_temp_segment_ ((command_name), link_array_ptr, code);

	     if code ^= 0 then do;
		call error (code, command_name, "While getting temp segment.");
		go to ABORT;
	     end;

	     n_link_names = 0;

	     call get_temp_segment_ ((command_name), uid_array_ptr, code);

	     if code ^= 0 then do;
		call error (code, command_name, "While getting temp segment.");
		go to ABORT;
	     end;

	     n_uids = 0;
	end;

	do idx = 1 to starname_count;

	     found_something = found_something | Process_Pathname (starnames (idx));
	     if found_something & ^return_names then goto DONE;
	end;

DONE:	if ^return_names then do;
	     if found_something then do;
		if active_function then return_value = "true";
		else call ioa_ ("true");
	     end;
	     else do;
		if active_function then return_value = "false";
		else call ioa_ ("false");
	     end;
	end;
	else do;
	     if ^found_something then do;
		if active_function then return_value = "";
		else call error ((0), command_name, "No entries found.");
	     end;
	     else if ^active_function then call ioa_ ("");
	end;

ABORT:
	call Cleanup ();
	return;

/* This procedure processes one starname which has been specified in the command line. */
Process_Pathname:
     procedure (pathname) returns (bit (1));

dcl  pathname	        character (*) parameter;
dcl  result	        bit (1) aligned;
dcl  idx                    fixed binary;

	result = FALSE;

	call expand_pathname_$component (pathname, dir, ename, component, code);
	if code ^= 0 then goto PATH_ERR;

	if component = "" & KEY_NAME (kname_index) = "component" then do;
	     code = error_table_$not_archive;
	     goto PATH_ERR;
	end;

	if component ^= "" & KEY_NAME (kname_index) ^= "component" then do;
	     code = error_table_$archive_pathname;
	     goto PATH_ERR;
	end;

	if (dir = ">") & (ename = "") then do;
	     if table_index = ENTRIES_EI then do;	/* entry */
		if select_entry_type then
		     if entry_type_selected (entry_type_ptr, FS_OBJECT_TYPE_DIRECTORY) then call Return_Entry (ename, FALSE);
		     else return (FALSE);
		else call Return_Entry (ename, FALSE);
	     end;
	     else if ROOT (table_index) then call Return_Entry (ename, FALSE);
	     else return (FALSE);
	end;
	else do;
	     call check_star_name_$entry (ename, code);
	     if ^((code = 0) | (code = 1) | (code = 2)) then goto PATH_ERR;
	     if table_index ^= ENTRIES_EI then do;
		call Get_Star_Names ();
		if code ^= 0 & code ^= error_table_$no_s_permission then do;
		     if code = error_table_$noentry | code = error_table_$no_dir | code = error_table_$nomatch then return (FALSE);
		     else goto PATH_ERR;
		end;
		do idx = star_branch_count + star_link_count to 1 by -1 while (return_names | ^result);
		     if Process_A_Name (table_index, addr (star_dir_list_branch (idx)))
		     then call Return_Entry (star_list_names (star_dir_list_branch (idx).nindex), ((star_dir_list_branch (idx).type) = Link));
		end;
	     end;
	     else do;
		result = Process_A_Name (table_index, null ());
	     end;
	end;

	call free_star_structures ();

	return (result);

PATH_ERR:
	if (length (space) ^= 0) & ^active_function then call ioa_ ("");
	if ^inhibit_error then do;
	     call error (code, command_name, "^a", pathname);
	     goto ABORT;
	end;
	else return (FALSE);

Return_Entry: procedure (ename, is_link);

dcl  ename	        char (*) parameter;
dcl  is_link	        bit (1) parameter;
dcl  temp_string	        character (256) varying;

	     if return_names then do;
		if is_link then do;
		     call expand_pathname_ (dir, dir_dname, dir_ename, (0));
		     call hcs_$get_uid_file (dir_dname, dir_ename, unique_id, (0));
		     found_uid = FALSE;
		     do jdx = 1 to n_uids while (^found_uid);
			if unique_id = uid_array (jdx) then do;
			     found_uid = TRUE;
			     do kdx = 1 to n_link_names;
				if link_array (kdx) = ename then return;
			     end;
			     n_link_names = n_link_names + 1;
			     if n_link_names > hbound (link_array, 1) then do;
				call error (0, command_name, "Too many links for internal array.");
				goto ABORT;
			     end;
			     link_array (n_link_names) = ename;
			end;
		     end;
		     if ^found_uid then do;
			n_uids = n_uids + 1;
			if n_uids > hbound (uid_array, 1) then do;
			     call error (0, command_name, "Too many entries for internal array.");
			     goto ABORT;
			end;
			uid_array (n_uids) = unique_id;
			n_link_names = n_link_names + 1;
			if n_link_names > hbound (link_array, 1) then do;
			     call error (0, command_name, "Too many links for internal array.");
			     goto ABORT;
			end;
			link_array (n_link_names) = ename;
		     end;
		end;
		else do;
		     call hcs_$get_uid_file (dir, ename, unique_id, (0));
		     do jdx = 1 to n_uids;
			if unique_id = uid_array (jdx) then return;
		     end;
		     n_uids = n_uids + 1;
		     if n_uids > hbound (uid_array, 1) then do;
			call error (0, command_name, "Too many entries for internal array.");
			goto ABORT;
		     end;
		     uid_array (n_uids) = unique_id;
		end;
		if return_absolute_pathnames then if dir = ">" then temp_string = ">";
		     else temp_string = rtrim (dir) || ">";
		else temp_string = "";

		temp_string = temp_string || rtrim (ename);

		if active_function then do;
		     return_value = return_value || space;
		     return_value = return_value || requote_string_ ((temp_string));
		end;
		else if chars_left > length (temp_string) + length (space) then do;
		     call ioa_$nnl (space || "^a", temp_string);
		     chars_left = chars_left - length (temp_string) - length (space);
		end;
		else do;
		     call ioa_$nnl ("^/^a", temp_string);
		     chars_left = max (0, line_length - length (temp_string));
		end;

		if active_function then space = " ";
		else space = "  ";

	     end;

	     result = TRUE;

	end Return_Entry;

Process_A_Name: procedure (table_index, entry_ptr) returns (bit (1));

dcl  table_index	        fixed binary parameter;
dcl  entry_ptr	        pointer parameter;
dcl  1 entry	        aligned like star_dir_list_branch based (entry_ptr);
dcl  type		        fixed bin (2);
dcl  bit_count	        fixed bin (24);
dcl  null_link	        bit (1);
dcl  idx		        fixed binary;

	     if table_index ^= ENTRIES_EI then do;
		type = entry.type;
		bit_count = entry.bit_count;
		if type = Link then do;
		     if ^chase then do;
			call hcs_$status_minf (dir, star_list_names (entry.nindex), 1, (0), (0), code); /* Check target by chasing link */
			null_link = ^(code = 0);
		     end;
		     else call hcs_$status_minf (dir, star_list_names (entry.nindex), 1, type, bit_count, code);
		end;
		if type = Directory & bit_count > 0 then type = MSF;
	     end;

	     go to PROCESS (table_index);

PROCESS (1):					/* segment */
	     return ((type = Segment));

PROCESS (2):					/* directory */
	     return ((type = Directory & bit_count = 0));

PROCESS (3):					/* MSF */
	     return ((type = MSF));

PROCESS (4):					/* link */
PROCESS (20):
	     return ((type = Link));

PROCESS (5):					/* entry = segment, MSF, directory, or link */
	     star_select_sw = star_ALL_ENTRIES;
	     if select_entry_type then do;
		do entry_type_no = 1 to entry_type.count;
		     old_ename = ename;
		     if substr (entry_type.suffix (entry_type_no), 1, 1) = "-" then ; /* standard non-suffixed entry */
		     else call expand_pathname_$add_suffix (old_ename, entry_type.suffix (entry_type_no), char_168, ename, code);
		     call Get_Star_Names;
		     do idx = star_branch_count + star_link_count to 1 by -1;
			if star_dir_list_branch (idx).type = Link then do;
			     if ^chase then if entry_type_selected (entry_type_ptr, FS_OBJECT_TYPE_LINK)
				then call Return_Entry (star_list_names (star_dir_list_branch (idx).nindex), TRUE);
				else ;
			     else do;
				call fs_util_$get_type (dir, star_list_names (star_dir_list_branch (idx).nindex), fs_type, code);
				if fs_type = entry_type.suffix (entry_type_no)
				then call Return_Entry (star_list_names (star_dir_list_branch (idx).nindex), FALSE);
			     end;
			end;
			else do;
			     call fs_util_$get_type (dir, star_list_names (star_dir_list_branch (idx).nindex), fs_type, code);
			     if fs_type = entry_type.suffix (entry_type_no)
			     then call Return_Entry (star_list_names (star_dir_list_branch (idx).nindex), FALSE);
			end;
		     end;
		     if star_list_names_ptr ^= null () then do;
			free star_list_names_ptr -> star_list_names;
			free star_list_branch_ptr -> star_dir_list_branch;
		     end;
		     ename = old_ename;
		end;
	     end;
	     else do;
		call Get_Star_Names;
		if ^return_names
		then if star_branch_count + star_link_count > 0 then return (TRUE);
		     else ;
		else do idx = star_branch_count + star_link_count to 1 by -1;
		     call Return_Entry (star_list_names (star_dir_list_branch (idx).nindex), (star_dir_list_branch (idx).type = Link));
		end;
	     end;
	     return (result);

PROCESS (6):					/* branch = segment, MSF, or directory */
PROCESS (21):
	     return ((type ^= Link));

PROCESS (7):					/* file = MSF or segment */
	     return ((type = Segment) | (type = MSF));

PROCESS (8):					/* zero-length segment */
	     return ((type = Segment) & (bit_count = 0));

PROCESS (9):					/* master directory */
	     return ((entry.master_dir));

PROCESS (10):					/* null link */
	     return ((type = Link) & null_link);

PROCESS (11):					/* nonsegment */
	     return ((type ^= Segment));

PROCESS (12):					/* nondirectory */
	     return (^((type = Directory) & (bit_count = 0)));

PROCESS (13):					/* nonMSF */
	     return (^(type = MSF));

PROCESS (14):					/* nonfile */
	     return (^((type = Segment) | (type = MSF)));

PROCESS (15):					/* nonzero segment */
	     return ((type = Segment) & (bit_count ^= 0));

PROCESS (16):					/* nonmaster directory */
	     return ((type = Directory) & ^entry.master_dir);

PROCESS (17):					/* nonnull link */
	     return ((type = Link) & ^(null_link));

PROCESS (18):					/* nonzero file */
	     if (type = Segment) then
	          return (bit_count ^= 0);
	     else if (type = MSF) then
	          return (Msf_Nonzero (dir, star_list_names (entry.nindex), bit_count));
	     else return (FALSE);

PROCESS (19):					/* nonzero MSF */
	     if (type = MSF) then
	          return (Msf_Nonzero (dir, star_list_names (entry.nindex), bit_count));
	     else return (FALSE);

PROCESS (22):					/* object file */
	     if (type = Segment | type = MSF) then
	          return (Check_Object_Segment (dir, star_list_names (entry.nindex)));
	     else return (FALSE);

PROCESS (23):					/* nonobject file */
	     if (type = Segment | type = MSF) then
	          return (^Check_Object_Segment (dir, star_list_names (entry.nindex)));
	     else return (FALSE);

PROCESS (24):					/* object msf */
	     if type = MSF then
	          return (Check_Object_Segment (dir, star_list_names (entry.nindex)));
	     else return (FALSE);

PROCESS (25):					/* nonobject msf */
	     if type = MSF then
	          return (^Check_Object_Segment (dir, star_list_names (entry.nindex)));
	     else return (FALSE);

PROCESS (26):					/* object segment */
	     if type = Segment then
	          return (Check_Object_Segment (dir, star_list_names (entry.nindex)));
	     else return (FALSE);

PROCESS (27):					/* nonobject segment */
	     if type = Segment then
	          return (^Check_Object_Segment (dir, star_list_names (entry.nindex)));
	     else return (FALSE);

PROCESS (28):					/* exists component */
	     call initiate_file_ (dir, star_list_names (entry.nindex), R_ACCESS, archive_ptr, archive_bc, code);
	     if archive_ptr = null () then goto PATH_ERR;

	     call check_star_name_$entry (component, code);
	     if code = 1 | code = 2 then return (process_component_starname (archive_ptr, archive_bc, component));
	     else do;
		call archive_$get_component (archive_ptr, archive_bc, component, (null ()), (0), code);
		if code = 0 then return (TRUE);
		else if (code = error_table_$not_archive) | (code = error_table_$archive_fmt_err) then goto PATH_ERR;
		else return (FALSE);
	     end;

	end Process_A_Name;

/* This procedure will call hcs_$star_dir_list_ on ename. */
Get_Star_Names: procedure;

	     star_branch_count, star_link_count = 0;
	     call hcs_$star_dir_list_ (dir, ename, star_select_sw, system_area_ptr, star_branch_count, star_link_count, star_list_branch_ptr, star_list_names_ptr, code);

	end Get_Star_Names;

Check_Object_Segment: procedure (dir, ename) returns (bit (1));

dcl  (dir, ename)	        character (*) parameter;
	     
	     seg_ptr = null ();
	     call object_lib_$initiate (dir, ename, "", "1"b, seg_ptr, (0), (""b), code);
	     call terminate_file_ (seg_ptr, (0), TERM_FILE_TERM, (0));
	     return (code = 0);

	end Check_Object_Segment;


Msf_Nonzero: procedure (dir, ename, msf_indicator) returns (bit(1));

dcl  (dir, ename)	        character (*) parameter;
dcl   msf_indicator	        fixed bin(24) parameter;	/* MSF comp count */
dcl   code	        fixed bin(35);
dcl   comp	        fixed bin;
dcl   comp_bit_count        fixed bin(24);
dcl   msf_bit_count	        fixed bin(35);
dcl   msf_dir	        char(168);
	     
	     msf_dir = pathname_ (dir, ename);
	     msf_bit_count = 0;
	     do comp = 0 to msf_indicator - 1;
	          call hcs_$status_minf (msf_dir, ltrim(char(comp)),
		     1, (0), comp_bit_count, code);
		if code = 0 then
		     msf_bit_count = msf_bit_count + comp_bit_count;
		end;
	     return (msf_bit_count > 0);

	end Msf_Nonzero;

/* The process_component_starname function determines if any components in the specified archive
   match the component starname given.  If so, TRUE is returned. */
process_component_starname: proc (archive_ptr, archive_bc, c_starname) returns (bit (1));

dcl  archive_bc	        fixed bin (24),
     archive_ptr	        ptr,
     c_name	        char (32),
     c_starname	        char (32);

	     c_ptr = null ();
	     do while ("1"b);
		call archive_$next_component (archive_ptr, archive_bc, c_ptr, (0), c_name, code);
		if code ^= 0 then return (FALSE);
		if c_ptr = null () then return ("0"b);	/* no components remaining in the archive	*/
		call match_star_name_ (c_name, c_starname, code);
		if code = 0 then return ("1"b);
	     end;

	end process_component_starname;

     end Process_Pathname;

/* This entry releases the temp segment and frees the star structures. */
Cleanup: procedure ();

	if link_array_ptr ^= null ()
	then call release_temp_segment_ ((command_name), link_array_ptr, (0));
	if uid_array_ptr ^= null ()
	then call release_temp_segment_ ((command_name), uid_array_ptr, (0));
	call free_star_structures ();
	if seg_ptr ^= null () then call terminate_file_ (seg_ptr, (0), TERM_FILE_TERM, (0));
	if archive_ptr ^= null () then call terminate_file_ (seg_ptr, (0), TERM_FILE_TERM, (0));
	if entry_type_ptr ^= null () then free entry_type in (system_area);

     end Cleanup;

/* This procedure is called to clean up allocated storage. */
free_star_structures:
     procedure ();

	if star_list_names_ptr ^= null ()
	then free star_list_names;

	if star_list_branch_ptr ^= null ()
	then free star_dir_list_branch;

	star_list_branch_ptr,
	     star_list_names_ptr = null ();

     end free_star_structures;

/* The process_entry_type_list procedure parses a comma delimited list of both
   standard and extended entry types into an array of type names. */
process_entry_type_list: procedure (entry_type_list, entry_type_struct_ptr, limit_entry_selections);

dcl  entry_type_list        char (*) parameter;
dcl  entry_type_struct_ptr  pointer parameter;
dcl  limit_entry_selections
		        bit (1) aligned parameter;
dcl  types_len	        fixed bin (24);
dcl  types_ptr	        pointer;
dcl  types	        char (types_len) based (types_ptr);
dcl  entry_type_no	        fixed bin;
dcl  this_type	        char (32);


/* copy entry_type_list into "real" storage */

	types_ptr = null ();
	on cleanup begin;
	     if types_ptr ^= null () then free types in (system_area);
	end;

	types_len = length (entry_type_list);
	allocate types set (types_ptr) in (system_area);
	types = entry_type_list;

/* to start off, get a count of the number of types in the string */

	do entry_type_count = 1
	     repeat (entry_type_count + 1)
	     while (index (types, ",") > 0);
	     types = after (types, ",");
	end;

/* allocate the entry_type structure, to be used later in this command */

	allocate entry_type
	     set (entry_type_struct_ptr)
	     in (system_area);

	entry_type_struct_ptr -> entry_type.suffix (*) = "";

/* for each potential entry type, validate it and add it to the structure */

	types = entry_type_list;
	type_info.version = SUFFIX_INFO_VERSION_1;
	entry_type_no = 1;
	do while (types ^= "");
	     this_type = before (types, ",");
	     if substr (this_type, 1, 1) ^= "-" then do;
		if this_type = "link" then this_type = FS_OBJECT_TYPE_LINK;
		else if this_type = "segment" then this_type = FS_OBJECT_TYPE_SEGMENT;
		else if this_type = "directory" then this_type = FS_OBJECT_TYPE_DIRECTORY;
		else if this_type = "multisegment_file" then this_type = FS_OBJECT_TYPE_MSF;
		else if this_type = "data_management_file" then this_type = FS_OBJECT_TYPE_DM_FILE;
		entry_type_struct_ptr -> entry_type.suffix (entry_type_no) = this_type;
		if this_type = FS_OBJECT_TYPE_LINK then entry_type_no = entry_type_no + 1;
						/*  fs_util_ does not support links */
		else do;
		     call fs_util_$suffix_info_for_type (this_type, addr (type_info), code);
		     if code = 0 then entry_type_no = entry_type_no + 1; /* complaining here is also */
		end;
	     end;					/* a viable alternative. */
	     types = after (types, ",");
	end;

/* free the types variable and set the limit_entry_selections flag */

	free types_ptr -> types
	     in (system_area);

	entry_type_struct_ptr -> entry_type.count = entry_type_no - 1;
	if entry_type_struct_ptr -> entry_type.count > 0 then limit_entry_selections = "1"b;
	else limit_entry_selections = "0"b;

	return;

     end process_entry_type_list;


/* The entry_type_selected function searches the entry_type structure for a given
   type.
*/

entry_type_selected: proc (entry_type_struct_ptr, fs_type) returns (bit (1) aligned);


dcl  entry_type_struct_ptr  pointer parameter;
dcl  fs_type	        char (32) parameter;
dcl  entry_type_no	        fixed bin;

	do entry_type_no = 1 to entry_type_struct_ptr -> entry_type.count;
	     if entry_type_struct_ptr -> entry_type.suffix (entry_type_no) = fs_type then return ("1"b);
	end;
	return ("0"b);

     end entry_type_selected;

%include access_mode_values;

%include copy_flags;

%include file_system_operations;

%include object_info;

%include star_structures;

%include status_structures;

%include suffix_info;

%include terminate_file;

     end entries;
