/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(87-04-15,RWaters), approve(87-04-15,MCR7639), audit(87-04-28,Huen),
     install(87-05-21,MR12.1-1033):
     Fix bug #2092
  2) change(87-06-25,Huen), approve(87-06-25,MCR7696), audit(87-06-25,RWaters),
     install(87-12-01,MR12.2-1005):
     Fix bug2149
  3) change(88-01-29,RWaters), approve(88-01-29,MCR7724), audit(88-02-05,Huen),
     install(88-02-16,MR12.2-1024):
     Treat explicit_packed as packed.
  4) change(89-04-04,Huen), approve(89-04-04,MCR8092), audit(89-05-24,RWaters),
     install(89-05-31,MR12.3-1050):
     Fix bug2195 - Emit the "NAME DECLARED BY THE DECLARE STATEMENT AND NEVER
     REFERENCED" section when all of the declared variables were not
     referenced. Fix bug2194 - List only referenced external variables under
     the "EXTERNAL VARIABLES ARE USED" section.
                                                   END HISTORY COMMENTS */

/* Modified on:	June 23 1975 by EEW for new object map
   Modified 770404 by PG to explain why blocks are not quick.
   Modified 5 May 1977 by SHW for new pl1_operator_names_
   Modified 14 July 1978 by PCK for unsigned binary
   Modified Dec 1978 by David Spector:
	1. Fixed begin block/on unit 'on line xxx' bug
	2. New filling of last column out to 132 columns and indenting continuation lines
	3. Eliminated "internal" from builtin and generic functions
	4. Allowed more space on line for long identifiers
	5. Changed "uses condition statements" nonquick reason to "enables or reverts conditions"
	6. Containing-block qualification for duplicate identifiers
	7. Containing-structure qualification for duplicate identifiers
	8. Cross-reference lists ordered within each source input file
	9. Increased maximum number of symbols listed from 2500 to 3072
	10. Marked cross-references as 'set' or not
	11. Placed "unsigned" attribute after "packed"
	12. Fixed stringrange bug for long procedure names
	13. Storage tables for internal static and automatic variables
   Modified 18 Jan 1979 by RAB to resume printing "set" if symbol.set is on
   Modified 26 May 1979 by D. Spector for -single_symbol_list (-ssl)
   Modified 26 May 1979 by D. Spector to not list undeclared level 2+ names
   Modified 13 Nov 1979 by Peter Krupp to fix bug 1859
   Modified 25 March 1980 by M. N. Davidoff to increase maximum number of symbols listed from 3072 to 4096.
  Modified 830415 BIM to deal with tokens as labels rather than ref nodes.
  Modified 860811 RW to not call "print" when "-ssl" flag is on when there are no symbols
  Modified 870625 SH to print the negative scale factors correctly in the listing.
  Modified 882801 RW to believe explicit_packed is also packed.
  Modified 891703 SH to emit the "NAMES DECLARED BY THE DECLARE STATEMENT AND
     NEVER REFERENCED" section when all of the declared variables were not
     referenced. (pl1_2195)
  Modified 891703 SH to list only referenced external variables under the 
     "EXTERNAL VARIABLES ARE USED" section. (pl1_2194)
*/
/* format: style3 */
pl1_symbol_print:
     proc (root, do_cp_dcl, no_object);

dcl	root		ptr,
	(do_cp_dcl, no_object)
			bit (1) aligned;

dcl	digits_pic	picture "-------9";		/* fixed decimal (8) */
dcl	(i, j, k, m, n, size, int_static_list_length, auto_list_length, unused, unused_members)
			fixed bin (17),
	(p, q)		ptr,
	line		aligned char (132),
	(
	dt1		(4) init (by_declare, by_explicit_context, by_context, by_compiler),
	dt2		(4) init (by_declare, by_explicit_context, by_implication, by_compiler)
	)		bit (3) aligned,
	s		char (1) varying,
	declare_type	(4) char (24) varying int static
			init ("DECLARE STATEMENT.", "EXPLICIT CONTEXT.", "CONTEXT OR IMPLICATION.", "COMPILER.");

dcl	pl1_stat_$single_symbol_list
			bit (1) aligned external static;
dcl	cg_static_$used_operator
			bit (900) ext,
	cg_static_$bit_count
			fixed bin ext,
	(
	cg_static_$ext_proc_list,
	cg_static_$ext_var_list,
	cg_static_$root,
	cg_static_$objmap_pt
	)		ptr ext,
	pl1_operator_names_$pl1_operator_names_
			ext;

dcl	1 name_pair	aligned based,
	  2 rel_ptr	unaligned bit (18),
	  2 size		unaligned bit (18);

dcl	based_string	aligned char (size) based;

dcl	(addr, bin, divide, fixed, hbound, length, ltrim, index, mod)
			builtin;
dcl	(null, ptr, string, substr)
			builtin;

dcl	symbol_list	(4096) ptr;
dcl	1 int_static_list_st
			aligned,
	  2 int_static_list (1024) ptr unaligned;	/* For efficiency */
dcl	1 auto_list_st	aligned,
	  2 auto_list	(1024) ptr unaligned;	/* For efficiency */

dcl	sym_sort_alphabetic entry (ptr, fixed bin);
dcl	binoct		entry (bit (18) aligned) returns (char (12) aligned),
	ioa_$rsnpnnl	entry options (variable),
	cg_error		entry (fixed bin, fixed bin),
	pl1_print$varying_nl
			entry (char (*) varying),
	pl1_print$non_varying_nl
			entry (char (*) aligned, fixed bin);

dcl	FF		char (1) static aligned init ("");
%include nodes;
%include declare_type;
%include operator_names;
%include list;
%include block;
%include block_types;
%include symbol;
%include reference;
%include statement;
%include token;
%include object_map;

/* program */

	call pl1_print$varying_nl (FF || "	NAMES DECLARED IN THIS COMPILATION.");

/* NOTE: the strings used in the following calls contain tabs */

	call pl1_print$varying_nl ("
IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES");
	call pl1_print$varying_nl (
	     "								(* indicates a set context)");

	int_static_list_length = 0;			/* Initialize storage table saved lists */
	auto_list_length = 0;

/* Create lists of symbols and print them */

	if pl1_stat_$single_symbol_list
	then do;
		n, unused, unused_members = 0;
		call select_all_symbols (root);
		if n > 1
		then do;
			call sym_sort_alphabetic (addr (symbol_list), n);
			call pl1_print$varying_nl ("");
						/* Print newline */
			call print (0);		/* Print all symbols */
		     end;
		else call pl1_print$varying_nl ("THERE WERE NO NAMES DECLARED IN THIS COMPILATION.");
	     end;
	else do i = 1 to 4 while (i ^= 4 | do_cp_dcl);	/* Print up to 4 separate lists */

/* Get all declarations of desired types */

		n, unused, unused_members = 0;

		call sort_on_dcl_type (root, (dt1 (i)), (dt2 (i)));

		if n > hbound (symbol_list, 1)
		then do;
full:
			call cg_error (327, hbound (symbol_list, 1));
			n = hbound (symbol_list, 1);
		     end;

		if n > 1
		then call sym_sort_alphabetic (addr (symbol_list), n);

		if i ^= 1
		then do;
			size = n;
			k = 0;			/* All symbol indicator */
		     end;
		else do;
			size = n - (unused + unused_members);
			k = -1;			/* Referenced symbol indicator */
		     end;

		if size = 0
		then call pl1_print$varying_nl ("
THERE WERE NO NAMES DECLARED BY " || declare_type (i));
		else do;
			if size = 1
			then s = "";
			else s = "S";

			call pl1_print$varying_nl ("
NAME" || s || " DECLARED BY " || declare_type (i));

			call print (k);		/* Print symbols according to indicator */
		     end;

		if i = 1 & unused > 0
		then do;
			if unused = 1
			then s = "";
			else s = "S";

			call pl1_print$varying_nl ("
NAME" || s || " DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.");

			call print (1);		/* Print non_referenced symbols */
		     end;

	     end;

/* Print storage requirements */

	if no_object
	then return;

	call pl1_print$varying_nl ("
STORAGE REQUIREMENTS FOR THIS PROGRAM.");

	q = cg_static_$objmap_pt;

	call ioa_$rsnpnnl ("^/^-Object^-Text^-Link^-Symbol^-Defs^-Static^/Start^10x0^7x0^10o^12o^8o^12o", line, k,
	     fixed (q -> object_map.linkage_offset, 18), fixed (q -> object_map.symbol_offset, 18),
	     fixed (q -> object_map.definition_offset, 18), fixed (q -> object_map.static_offset, 18));

	call pl1_print$non_varying_nl (line, k);

	call ioa_$rsnpnnl ("Length^10o^8o^10o^12o^8o^12o", line, k, divide (cg_static_$bit_count, 36, 17, 0),
	     fixed (q -> object_map.text_length, 18), fixed (q -> object_map.linkage_length, 18),
	     fixed (q -> object_map.symbol_length, 18), fixed (q -> object_map.definition_length, 18),
	     fixed (q -> object_map.static_length, 18));

	call pl1_print$non_varying_nl (line, k);

	call pl1_print$varying_nl ("");

	call pl1_print$varying_nl (
	     "BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME");

	p = cg_static_$root -> block.son;

	do while (p ^= null);
	     call prt_block (p);

	     if p -> block.son ^= null		/* This code walks the tree of blocks by */
	     then p = p -> block.son;			/* recursing down the son chain until it */
	     else if p -> block.brother ^= null		/* runs out, then it switches to the brother */
	     then p = p -> block.brother;		/* chain (of the last son) until it runs out, then it */
	     else do;				/* picks up the brother chains it missed the first time */
		     p = p -> block.father;		/* down the tree. */
		     do while (p -> block.brother = null & cg_static_$root ^= p);
			p = p -> block.father;
		     end;
		     p = p -> block.brother;
		end;
	end;

	call print_int_static_table (int_static_list_st, int_static_list_length);

	call print_auto_table (auto_list_st, auto_list_length);

	if cg_static_$used_operator
	then ;
	else goto chk_ext;

	call pl1_print$varying_nl ("
THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.");

	line = "";
	i, k = 1;
	j = 0;
	op_names_pt = addr (pl1_operator_names_$pl1_operator_names_);

look:
	n = index (substr (cg_static_$used_operator, k), "1"b);

	if n ^= 0
	then do;

		k = k + n - 1;
		if k >= operator_names.first & k <= operator_names.last
		then do;
			p = addr (operator_names.names (k));
			goto place;
		     end;

		do n = 1 to operator_names.number_special;
		     if operator_names.special (n).offset = k
		     then do;
			     p = addr (operator_names.special (n).namep);
			     goto place;
			end;
		end;

		goto step;

place:
		size = fixed (p -> name_pair.size, 18);
		p = ptr (p, p -> name_pair.rel_ptr);

		substr (line, i, size) = p -> based_string;

		j = i + size - 1;
		i = i + 20;

		if i >= 121
		then do;
			call pl1_print$non_varying_nl (line, j);
			line = "";
			i = 1;
			j = 0;
		     end;

step:
		k = k + 1;
		goto look;
	     end;

	if j ^= 0
	then call pl1_print$non_varying_nl (line, j);

chk_ext:
	p = cg_static_$ext_proc_list;
	call print_list (1);			/* List ext. entry info */

	p = cg_static_$ext_var_list;
	call print_list (2);			/* List ext. variable info */
done:
	call pl1_print$varying_nl ("");

	return;

print_list:
     proc (ext_code);

/* parameters */

dcl	ext_code		fixed bin;		/* Print_list 1: external entries,
					    2: external variables */

/* automatic */
dcl	(hder_no_ext, hder_has_ext)
			char (512) varying;
dcl	sym2		ptr;

	if ext_code = 1
	then do;
		hder_no_ext = "
NO EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.";
		hder_has_ext = "
THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.";
	     end;
	else do;
		hder_no_ext = "
NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.";
		hder_has_ext = "
THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.";
	     end;

	if (p ^= null)
	then do;
		n = 0;

		do while (p ^= null);
		     sym2 = p -> element (2);

		     if ((sym2 -> symbol.cross_references ^= null) | (sym2 -> symbol.allocate))
		     then do;
			     n = n + 1;
			     symbol_list (n) = sym2;
			end;
		     p = p -> element (1);
		end;

		if (n > 0)
		then do;

			call pl1_print$varying_nl (hder_has_ext);
			call sym_sort_alphabetic (addr (symbol_list), n);
			line = "";
			i = 1;
			j = 0;

			do k = 1 to n;
			     p = symbol_list (k) -> symbol.token;
			     size = p -> token.size;

			     if i + size >= 121
			     then do;
				     call pl1_print$non_varying_nl (line, j);
				     line = " ";
				     i = 1;
				     j = 0;
				end;

			     substr (line, i, size) = p -> token.string;
			     j = i + size - 1;
			     if size = 30
			     then size = size + 1;

			     m = mod (size, 30);
			     if m ^= 0
			     then size = size + (30 - m);
			     i = i + size;
			end;

			if j ^= 0
			then call pl1_print$non_varying_nl (line, j);
		     end;
		else call pl1_print$varying_nl (hder_no_ext);
	     end;
	else call pl1_print$varying_nl (hder_no_ext);

     end;

prt_block:
     proc (pt);

dcl	pt		ptr;

dcl	(bp, fp)		ptr,
	(bt1, bt2, info_len)
			fixed bin,
	(name1, name2)	char (256) varying;

dcl	1 bline		aligned,
	  2 name		char (29) unal,
	  2 sp1		char (4) unal,
	  2 size		picture "-----9" unal,
	  2 sp2		char (1) unal,
	  2 type		char (19) unal,
	  2 sp3		char (1) unal,
	  2 info		char (70);

dcl	block_type	(5) char (18) varying int static
			init ("root block", "external procedure", "internal procedure", "begin block", "on unit");

dcl	nonquick_reasons	(13) char (40) varying aligned internal static options (constant)
			init ("uses auto adjustable storage", "uses returns(char(*)) or returns(bit(*))",
			"is called during a stack extension", "is invoked by a format statement",
			"contains a format statement", "uses I/O statements", "is assigned to an entry variable",
			"enables or reverts conditions", "is called by several nonquick procedures",
			"calls itself recursively", "is declared options(non_quick)",
			"is declared options(variable)", "is never referenced");

	bp = pt;
	string (bline) = "";

	call block_name (bp, name1, bt1);
	if length (name1) > length (bline.name)
	then call pl1_print$varying_nl (name1);
	else bline.name = name1;

	bline.type = block_type (bt1);

	if bp -> block.no_stack
	then do;
		fp = bp;
		do while (fp -> block.no_stack);
		     if fp -> block.owner = null
		     then fp = fp -> block.father;
		     else fp = fp -> block.owner;
		end;

		call block_name (fp, name2, bt2);
		name1 = "shares stack frame of ";
		if bt2 ^= bin (begin_block) & bt2 ^= bin (on_unit)
		then do;
			name1 = name1 || block_type (bt2);
			name1 = name1 || " ";
		     end;
		name1 = name1 || name2;
		bline.info = name1;
		info_len = length (name1);
	     end;
	else do;
		bline.size = bp -> block.last_auto_loc;
		info_len = 0;

		if bt1 = bin (external_procedure)	/* special-case the main procedure */
		then do;
			bline.info = "is an external procedure";
			info_len = length ("is an external procedure");
		     end;
		else do i = 1 to hbound (nonquick_reasons, 1);
			if substr (string (bp -> block.why_nonquick), i, 1)
			then do;
				if info_len > 0	/* if something already printed... */
				then if i = hbound (nonquick_reasons, 1)
				     then do;
					     substr (bline.info, info_len + 1, 6) = ", and ";
					     info_len = info_len + 6;
					end;
				     else if substr (string (bp -> block.why_nonquick), i + 1) = ""b
				     then do;
					     substr (bline.info, info_len + 1, 6) = ", and ";
					     info_len = info_len + 6;
					end;
				     else do;
					     substr (bline.info, info_len + 1, 2) = ", ";
					     info_len = info_len + 2;
					end;

				n = length (nonquick_reasons (i));
				if info_len + n + 1 > length (bline.info)
				then do;
					call pl1_print$non_varying_nl (string (bline),
					     length (string (bline)) - length (bline.info) + info_len);
					string (bline) = "";
					info_len = 0;
				     end;

				substr (bline.info, info_len + 1, n) = nonquick_reasons (i);
				info_len = info_len + n;
			     end;
		     end;
	     end;

	if info_len > 0 & info_len < length (bline.info)
	then do;
		substr (bline.info, info_len + 1, 1) = ".";
		info_len = info_len + 1;
	     end;

	call pl1_print$non_varying_nl (string (bline), length (string (bline)) - length (bline.info) + info_len);

     end;						/* end of prt_block */

block_name:
     proc (blkp, name, type);

dcl	blkp		ptr,
	name		char (256) varying,
	type		fixed bin;

dcl	blk		ptr;
dcl	name_ptr		ptr;

	blk = blkp;
	type = fixed (blk -> block_type, 3);

	if blk -> block_type = begin_block | blk -> block_type = on_unit
	then do;
		if blk -> block.block_type = begin_block
		then name = "begin block";
		else name = "on unit";
		name = name || " on line ";
number_name:
		if blk -> block.file_number ^= "0"b
		then do;
			digits_pic = fixed (blk -> block.file_number, 8);
			name = name || ltrim (digits_pic);
			name = name || "-";
		     end;
		digits_pic = fixed (blk -> block.line_number, 14);
		name = name || ltrim (digits_pic);
	     end;
	else do;
		name_ptr = blk -> block.main -> statement.labels -> list.element (2);
		if name_ptr -> reference.node_type = reference_node
		then name = name_ptr -> reference.symbol -> symbol.token -> token.string;
		else if name_ptr -> token.node_type = token_node
		then name = name_ptr -> token.string;
		else do;
			name = "<unknown>";
			go to number_name;
		     end;
	     end;

     end;

/* Select all symbols and store in list */

select_all_symbols:
     proc (pt);

dcl	pt		ptr;			/* points at block node */
dcl	dt		bit (3) aligned,
	null		builtin,
	(block_pt, sym_pt)	ptr;

	block_pt = pt;
	do while (block_pt ^= null);

	     sym_pt = block_pt -> block.declaration;
	     do while (sym_pt ^= null);

		dt = sym_pt -> symbol.dcl_type;

		if dt = by_compiler			/* Compiler-declared symbol */
		then if ^do_cp_dcl
		     then go to step;

		if n = hbound (symbol_list, 1)
		then goto full;

		n = n + 1;
		symbol_list (n) = sym_pt;

		if sym_pt -> symbol.cross_references = null & ^sym_pt -> symbol.allocate
		then if sym_pt -> symbol.level <= 1
		     then unused = unused + 1;
		     else unused_members = unused_members + 1;

step:
		sym_pt = sym_pt -> symbol.next;
	     end;

	     sym_pt = block_pt -> block.son;
	     if sym_pt ^= null
	     then call select_all_symbols (sym_pt);

	     block_pt = block_pt -> block.brother;
	end;

     end;

/* Procedure to fill in an array with pointers to all declarations of a given
   declare type.

   Initial Version: 13 January 1969 by JDM for Version I
	Modified: 23 Februrary 1971 by BLW for Version II	*/

sort_on_dcl_type:
     proc (pt, dtp1, dtp2);

dcl	pt		ptr,			/* points at block node */
	dtp1		bit (3) aligned,		/* first declare type */
	dtp2		bit (3) aligned;		/* second declare type */

dcl	(dt, dt1, dt2)	bit (3) aligned,
	null		builtin,
	(block_pt, sym_pt)	ptr;


	dt1 = dtp1;
	dt2 = dtp2;

	block_pt = pt;
	do while (block_pt ^= null);

	     sym_pt = block_pt -> block.declaration;
	     do while (sym_pt ^= null);

		dt = sym_pt -> symbol.dcl_type;

		if dt ^= dt1
		then if dt ^= dt2
		     then goto step;

		if n = hbound (symbol_list, 1)
		then goto full;

		n = n + 1;
		symbol_list (n) = sym_pt;

		if sym_pt -> symbol.cross_references = null & ^sym_pt -> symbol.allocate
		then if sym_pt -> symbol.level <= 1
		     then unused = unused + 1;
		     else unused_members = unused_members + 1;

step:
		sym_pt = sym_pt -> symbol.next;
	     end;

	     sym_pt = block_pt -> block.son;
	     if sym_pt ^= null
	     then call sort_on_dcl_type (sym_pt, dt1, dt2);

	     block_pt = block_pt -> block.brother;
	end;

     end;

print:
     proc (ignore_code);

/* parameters */

dcl	ignore_code	fixed bin;		/* Print -1: referenced,
						          0: all,
						         +1: non-referenced declarations. */

/* automatic */

dcl	(sym_pt, p)	ptr;
dcl	ref_list		(1024) ptr unaligned;
dcl	(k, ctype, dtype, ext, cur_attrib_col, nn, bo, i, name_width, ignore)
			fixed bin;
dcl	next_k		fixed bin;		/* index of next non-ignored name */
dcl	ref_list_length	fixed bin;
dcl	wo		fixed bin (18);
dcl	id		char (256) varying;
dcl	name		char (256) varying;
dcl	temp		char (296) varying;
dcl	number		char (12) varying;
dcl	c6		char (6);
dcl	ref_too_many	bit (1);
dcl	prev_dupl		bit (1);			/* last name was duplicate of current */
dcl	next_dupl		bit (1);			/* next name is dupl of current */
dcl	id_printed	bit (1);
dcl	something_to_print	bit (1);
dcl	ignore_symbol	bit (1);

/* pictures */

dcl	six_digits	picture "------9";

/* internal static */

dcl	char_per_line	fixed bin int static init (132);

dcl	int_ext		(0:1) char (8) int static options (constant) init ("internal", "external");

dcl	class_name	(0:23) char (20) aligned int static
			init ("ILLEGAL 0", "ILLEGAL 1", "automatic", "ILLEGAL 3", "based", "ILLEGAL 5",
			"internal static", "external static", "internal ctl", "external ctl", "defined",
			"ILLEGAL 11", "parameter", "ILLEGAL 13", "param descriptor", "ILLEGAL 15", "constant",
			"constant", "temporary", "ILLEGAL 19", "return value", "ILLEGAL 21", "stack reference",
			"constant");

dcl	dt		(0:26) char (17) aligned varying int static
			init ("unknown", "fixed bin", "fixed dec", "float bin", "float dec", "complex fixed bin",
			"complex fixed dec", "complex float bin", "complex float dec", "char", "varying char",
			"bit", "varying bit", "label", "label variable", "entry", "entry variable", "file",
			"file variable", "pointer", "offset", "structure", "area", "condition", "format",
			"format variable", "picture");

dcl	file_attr_words	(16) char (11) varying int static
			init ("print", "input", "output", "update", "stream", "", "record", "sequential", "direct",
			"interactive", "", "", "stringvalue", "keyed", "namelist", "environment");

dcl	auto_static_const	bit (10) int static init ("1010000100"b);

dcl	indent		fixed bin int static init (2);/* indentation for continuation lines */

dcl	line_pt		ptr;

dcl	1 sl,
	  2 symbol	char (20) unal,
	  2 sp1		char (1) unal,
	  2 word_offset	char (6) unal,
	  2 bit_offset	(4) char (1) unal,
	  2 sp2		char (1) unal,
	  2 location	char (6) unal,
	  2 sp3		char (1) unal,
	  2 class		char (15) unal,
	  2 sp4		char (1) unal,
	  2 data_type	char (25) unal,
	  2 sp6		char (1) unal,
	  2 attributes	char (60) unal;

dcl	line		char (132) defined (sl);

dcl	(bit, ltrim, verify)
			builtin;

dcl	digit		(0:9) char (1) aligned int static
			initial ("0", "1", "2", "3", "4", "5", "6", "7", "8", "9");

%include cgsystem;
%include label;
%include cross_reference;

	line_pt = addr (line);
	ignore = ignore_code;

/* The following code selects symbols for printing and determines whether duplicates occur */
	next_dupl = "0"b;
	k = 0;					/* No current symbol */
	do next_k = 1 to n;				/* Scan symbol_list */

/* Consider symbol symbol_list (next_k) only if it is not to be ignored */
/* Ignore non-referenced variables if "ignore" is */
/* negative, referenced variables if "ignore" */
/* is positive non-zero. */
	     begin;
dcl	sym_pt		ptr;
dcl	referenced	bit (1);
		sym_pt = symbol_list (next_k);
		ignore_symbol = "0"b;		/* Assume symbol is not to be ignored */
		if ignore ^= 0 | sym_pt -> symbol.level > 1
		then do;
			referenced = (sym_pt -> symbol.cross_references ^= null | sym_pt -> symbol.allocate);
						/* identifier is referenced */
			if ignore < 0 & ^referenced | ignore > 0 & referenced
			     | sym_pt -> symbol.level > 1 & ^referenced
			then ignore_symbol = "1"b;
		     end;
	     end;
	     if ^ignore_symbol
	     then do;
		     if k ^= 0
		     then do;
			     prev_dupl = next_dupl;
			     next_dupl =
				(symbol_list (k) -> symbol.token -> token.string
				= symbol_list (next_k) -> symbol.token -> token.string);
			     call print_k;
			end;
		     k = next_k;
		end;
	end;
	prev_dupl = "0"b;
	call print_k;				/* Print last symbol (there must be one) */
	return;

/* Print symbol table entry for current symbol */
print_k:
     proc;
	sym_pt = symbol_list (k);
	call init_attrib;
	dtype, ctype = 0;
	id = sym_pt -> symbol.token -> token.string;	/* save identifier for later */
	id_printed = "0"b;
	if sym_pt -> node.type = label_node
	then do;
		ctype = 16;
		sl.data_type = dt (13);

		if sym_pt -> label.array
		then do;
			temp = "array(";

			if sym_pt -> label.low_bound ^= 1
			then do;
				six_digits = sym_pt -> label.low_bound;
				temp = temp || ltrim (six_digits);
				temp = temp || ":";
			     end;

			six_digits = sym_pt -> label.high_bound;
			temp = temp || ltrim (six_digits);
			temp = temp || ")";
			call attrib (temp);		/* "array(low:high)" */
		     end;
		go to set_loc;
	     end;

	if sym_pt -> symbol.builtin
	then do;
		sl.data_type = "builtin function";
		goto done;
	     end;

	if sym_pt -> symbol.generic
	then do;
		sl.data_type = "generic function";
		goto done;
	     end;

	ext = fixed (sym_pt -> symbol.external, 1);

	if sym_pt -> symbol.entry
	then do;

		if sym_pt -> symbol.variable
		then do;
			dtype = 16;
			goto have_type;
		     end;

		dtype = 15;
		if sym_pt -> symbol.external & sym_pt -> symbol.initial = null
		then ctype = 23;
		else ctype = 16;

		call attrib ((int_ext (ext)));	/* "internal" or "external" entry constant */
		goto set_loc;
	     end;

	if sym_pt -> symbol.condition
	then do;
		ctype = 22;
		dtype = 23;
		goto set_loc;
	     end;

	if sym_pt -> symbol.fixed
	then do;
		dtype = 1;
		goto arith;
	     end;

	if sym_pt -> symbol.float
	then do;
		dtype = 3;

arith:
		if sym_pt -> symbol.decimal
		then dtype = dtype + 1;
		if sym_pt -> symbol.complex
		then dtype = dtype + 4;
		goto have_type;
	     end;

	if sym_pt -> symbol.char
	then do;
		dtype = 9;
		goto str;
	     end;

	if sym_pt -> symbol.bit
	then do;
		dtype = 11;

str:
		if sym_pt -> symbol.varying
		then dtype = dtype + 1;
		goto have_type;
	     end;

	if sym_pt -> symbol.picture
	then do;
		dtype = 26;
		go to have_type;
	     end;

	if sym_pt -> symbol.label
	then do;
		dtype = 13;
		goto cv;
	     end;

	if sym_pt -> symbol.format
	then do;
		dtype = 24;
		goto cv;
	     end;

	if sym_pt -> symbol.file
	then do;
		dtype = 17;

cv:
		if sym_pt -> symbol.variable
		then dtype = dtype + 1;
		goto have_type;
	     end;

	if sym_pt -> symbol.ptr
	then dtype = 19;
	else if sym_pt -> symbol.offset
	then dtype = 20;
	else if sym_pt -> symbol.structure
	then dtype = 21;
	else if sym_pt -> symbol.area
	then dtype = 22;

have_type:
	ctype = 2 * index (string (sym_pt -> symbol.storage_class), "1"b) + ext;

	if sym_pt -> symbol.allocated
	then if string (sym_pt -> symbol.storage_class) & auto_static_const
	     then do;

/* Save variables for later printout in storage table */
		     if sym_pt -> symbol.level <= 1
		     then do;			/* Members of structures ignored */
			     if ctype = 6
			     then do;		/* Internal static */
				     if int_static_list_length = hbound (int_static_list, 1)
				     then call cg_error (327, int_static_list_length);
				     else do;
					     int_static_list_length = int_static_list_length + 1;
					     int_static_list (int_static_list_length) = sym_pt;
					end;
				end;
			     else if ctype = 2
			     then do;		/* Automatic */
				     if auto_list_length = hbound (auto_list, 1)
				     then call cg_error (327, auto_list_length);
				     else do;
					     auto_list_length = auto_list_length + 1;
					     auto_list (auto_list_length) = sym_pt;
					end;
				end;
			end;

set_loc:
		     sl.location = substr (binoct (bit (fixed (sym_pt -> symbol.location, 18), 18)), 1, 6);
		end;

	sl.class = substr (class_name (ctype), 1, 15);

	if sym_pt -> node.type = label_node
	then goto done;

	p = sym_pt -> symbol.reference;
	if p -> reference.offset = null
	then do;
		nn = p -> reference.c_offset * convert_offset (p -> reference.units);
		wo = divide (nn, bits_per_word, 17, 0);
		bo = mod (nn, bits_per_word);

		if wo ^= 0
		then do;
			c6 = substr (binoct (bit (wo, 18)), 1, 6);

			substr (c6, 1, verify (c6, "0") - 1) = " ";
						/* Suppress leading zeros */

			sl.word_offset = c6;
		     end;

		if bo ^= 0
		then do;
			if wo = 0
			then substr (sl.word_offset, 6, 1) = "0";

			sl.bit_offset (1) = "(";

			sl.bit_offset (3) = digit (mod (bo, 10));

			bo = divide (bo, 10, 17, 0);
			sl.bit_offset (2) = digit (mod (bo, 10));

			sl.bit_offset (4) = ")";
		     end;

	     end;

	if sym_pt -> symbol.c_dcl_size ^= 0
	then do;
		digits_pic = sym_pt -> symbol.c_dcl_size;
		number = ltrim (digits_pic);

		if substr ("110011000000000000000000000000"b, dtype, 1)
		then do;
			number = number || ",";
			digits_pic = sym_pt -> symbol.scale;
			number = number || ltrim (digits_pic);
		     end;

		temp = dt (dtype);
		temp = temp || "(";
		temp = temp || number;
		temp = temp || ")";
		sl.data_type = temp;
	     end;
	else sl.data_type = dt (dtype);

	if sym_pt -> symbol.local
	then do;
		call attrib ("local");
	     end;

	if sym_pt -> symbol.initialed
	then do;
		call attrib ("initial");
	     end;

	if sym_pt -> symbol.array ^= null
	then do;
		call attrib ("array");
	     end;

	if sym_pt -> symbol.father ^= null | dtype = 21
	then do;
		temp = "level " || digit (sym_pt -> symbol.level);
		call attrib (temp);

/* Qualify by structure */
		if sym_pt -> symbol.level > 1 & (prev_dupl | next_dupl)
		then do;
			do p = sym_pt repeat p -> symbol.father while (p -> symbol.level > 1);
			end;			/* find level 1 containing structure */
			call attrib ("in structure"); /* Print the structure qualification */
			temp = """";
			temp = temp || p -> symbol.token -> token.string;
						/* Name of containing structure */
			temp = temp || """";
			call attrib (temp);
		     end;

		if sym_pt -> symbol.packed | sym_pt -> symbol.explicit_packed
		then do;
			call attrib ("packed");
		     end;

	     end;

	if sym_pt -> symbol.packed | sym_pt -> symbol.explicit_packed
	then call attrib ("packed");

	if sym_pt -> symbol.unsigned
	then do;
		call attrib ("unsigned");
	     end;

	if ^sym_pt -> symbol.aligned
	then do;
		call attrib ("unaligned");
	     end;

	if sym_pt -> symbol.file
	then do i = 1 to hbound (file_attr_words, 1);
		if substr (string (sym_pt -> symbol.file_attributes), i, 1)
		then call attrib ((file_attr_words (i)));
	     end;

done:
	if string (sym_pt -> symbol.source_id) ^= (27)"0"b
	then do;
		call file_line (sym_pt);
		temp = "dcl " || number;
		call attrib (temp);			/* make sure "dcl" and number are on same line */

/* Qualify by block */
		p = sym_pt -> symbol.block_node;	/* Find containing block */
		if (prev_dupl | next_dupl) & p -> block.main ^= null
		then do;				/* This is a duplicate symbol not contained in the root block */
			call block_name (p, name, dtype);
						/* Print block qualification */
			if dtype = bin (begin_block) | dtype = bin (on_unit)
			then do;
				temp = "in ";	/* begin block on line xxx */
				temp = temp || name;
				call attrib (temp);
			     end;
			else do;
				call attrib ("in procedure");
						/* procedure "name" */
				temp = """";
				temp = temp || name;
				temp = temp || """";
				call attrib (temp);
			     end;
		     end;
	     end;

/* Process cross-reference list */
	p = sym_pt -> symbol.cross_references;
	ref_too_many = "0"b;
	ref_list_length = 0;

/* Create list of cross references */
	do while (p ^= null);
	     if ref_list_length = hbound (ref_list, 1)
	     then ref_too_many = "1"b;
	     else do;
		     ref_list_length = ref_list_length + 1;
		     ref_list (ref_list_length) = p;
		end;
	     p = p -> cross_reference.next;
	end;

/* Sort the cross reference list within each included file.
   (Note: list stored in REVERSE order).
   Algorithm is insertion sort, which is the most efficient since list is usually
   ordered already. */

	begin;
dcl	temp		ptr;
dcl	compare		bit (1);			/* Compare next items */
dcl	i		fixed bin;		/* Next item to be ordered */
dcl	j1		fixed bin;		/* Current item being ordered */
dcl	j2		fixed bin;		/* Previous item to compare with */

	     do i = 2 to ref_list_length;
		compare = "1"b;
		do j1 = i repeat j2 while (compare & j1 > 1);
						/* "Bubble" item back to proper place */
		     j2 = j1 - 1;			/* Next previous candidate for comparison */
		     if ref_list (j2) -> cross_reference.file_number = ref_list (j1) -> cross_reference.file_number
		     then do;
			     if ref_list (j2) -> cross_reference.line_number
				< ref_list (j1) -> cross_reference.line_number
			     then do;
				     temp = ref_list (j1);
						/* Exchange items in wrong order */
				     ref_list (j1) = ref_list (j2);
				     ref_list (j2) = temp;
				end;
			     else compare = "0"b;	/* Stop bubbling when right order found */
			end;
		end;
	     end;
	end;

/* Print the cross reference list */
	if ref_list_length ^= 0
	then do;
		if sym_pt -> symbol.set
		then call attrib ("set");
		call attrib ("ref");
		if ref_too_many
		then call attrib ("(more)");
		do i = ref_list_length to 1 by -1;
		     call file_line ((ref_list (i)));
		     temp = number;
		     if ref_list (i) -> cross_reference.set_reference
		     then temp = temp || "*";
		     call attrib (temp);
		end;
	     end;

	if something_to_print
	then call output_line;

	return;

     end;						/* End print_k */

/* Convert source line number to char string */
file_line:
     proc (node_pt);
dcl	node_pt		ptr;

	if node_pt -> cross_reference.file_number = "0"b
	then number = "";
	else do;
		digits_pic = fixed (node_pt -> cross_reference.file_number, 8);
		number = ltrim (digits_pic);
		number = number || "-";
	     end;

	digits_pic = fixed (node_pt -> cross_reference.line_number, 14);
	number = number || ltrim (digits_pic);

     end;						/* End of file_line */

attrib:
     proc (input_string);				/* store leading space and item in "attributes" column */
dcl	input_string	char (296) varying;

	if length (input_string) + cur_attrib_col > char_per_line
	then call output_line;			/* item too big to fit on line */
	if length (input_string) + cur_attrib_col > char_per_line
	then call pl1_print$varying_nl ((82)" " || input_string);
						/* item too big even for line of its own */
	else do;
		substr (line, cur_attrib_col + 1, length (input_string)) = input_string;
						/* item fits on line */
		cur_attrib_col = cur_attrib_col + length (input_string) + 1;
						/* include leading space */
		something_to_print = "1"b;
	     end;
     end;

output_line:
     proc;					/* print out and initialize current print line */
	if ^id_printed
	then do;
		name_width = 38;			/* Print identifier. Try for maximum width. */
		if sl.location ^= ""
		then name_width = 31;		/* Narrower if there is a loc. */
		if sl.word_offset ^= ""
		then name_width = 20;		/* Narrowest if an offset. */
		if length (id) <= name_width
		then substr (line, 1, length (id)) = id;/* Name fits into available space. */
		else call pl1_print$varying_nl (id);	/* Doesn't fit. */
		id_printed = "1"b;
	     end;
	call pl1_print$varying_nl (substr (line, 1, cur_attrib_col - 1));
	call init_attrib;
	cur_attrib_col = cur_attrib_col + indent;
     end;

init_attrib:
     proc;					/* initialize storing attributes in print line */
	something_to_print = "0"b;
	cur_attrib_col = 80;			/* col 80 will get a leading space */
	line = "";				/* store spaces in print line (sl) */
     end;

     end;						/* End of print. */

print_int_static_table:
     proc (int_static_list_st, int_static_list_length);

dcl	1 int_static_list_st
			aligned,
	  2 int_static_list (1024) ptr unaligned;	/* For efficiency */
dcl	int_static_list_length
			fixed bin;

dcl	i		fixed bin;
dcl	tabs		(4) internal static options (constant) fixed bin init (1, 8, 36, 1000);

dcl	(loc_item, name_item, procedure_item)
			char (256) varying;

	if int_static_list_length = 0
	then return;				/* No internal static variables */
	call pl1_print$varying_nl ("
STORAGE FOR INTERNAL STATIC VARIABLES.
");
	call column_print (tabs, "   LOC", "IDENTIFIER", "BLOCK NAME", "");
	call sort_storage_list (int_static_list_st, int_static_list_length, 0);
						/* Sort on location */
	do i = 1 to int_static_list_length;
	     call format_items ((int_static_list (i)), loc_item, name_item, procedure_item);
						/* Get strings */
	     call column_print (tabs, loc_item, name_item, procedure_item, "");
	end;
     end;						/* End of print_int_static_table */

print_auto_table:
     proc (auto_list_st, auto_list_length);

dcl	1 auto_list_st	aligned,
	  2 auto_list	(1024) ptr unaligned;	/* For efficiency */
dcl	auto_list_length	fixed bin;

dcl	(i, ignored_type)	fixed bin;
dcl	tabs		(4) internal static options (constant) fixed bin init (1, 26, 33, 61);

dcl	p		ptr;

dcl	(stack_frame_item, loc_item, name_item, procedure_item, previous_stack_frame_item)
			char (256) varying;

	if auto_list_length = 0
	then return;				/* No automatic variables */
	previous_stack_frame_item = "";
	call pl1_print$varying_nl ("
STORAGE FOR AUTOMATIC VARIABLES.
");
	call column_print (tabs, "STACK FRAME", "   LOC", "IDENTIFIER", "BLOCK NAME");
	call sort_storage_list (auto_list_st, auto_list_length, 1);
						/* Sort on location and stack frame */
	do i = 1 to auto_list_length;
	     p = auto_list (i) -> symbol.block_node;	/* Find stack frame owner */
	     if p -> block.owner ^= null
	     then p = p -> block.owner;
	     call block_name (p, stack_frame_item, ignored_type);
	     call format_items ((auto_list (i)), loc_item, name_item, procedure_item);
						/* Get strings */
	     if stack_frame_item = previous_stack_frame_item
	     then stack_frame_item = "";		/* Blank out duplicate stack frame names */
	     else previous_stack_frame_item = stack_frame_item;
	     call column_print (tabs, stack_frame_item, loc_item, name_item, procedure_item);
	end;
     end;						/* End of print_auto_table */

column_print:
     proc (tabs, v1, v2, v3, v4);

dcl	tabs		(4) fixed bin;
dcl	(v1, v2, v3, v4)	char (256) varying;

dcl	line		char (512) varying;

	line = v1;
	call print_item (tabs (2), v2);
	call print_item (tabs (3), v3);
	if v4 ^= ""
	then call print_item (tabs (4), v4);
	if line ^= ""
	then call pl1_print$varying_nl (line);
	return;

print_item:
     proc (tab, input_string);

dcl	tab		fixed bin;
dcl	input_string	char (256) varying;

dcl	copy		builtin;

	if length (line) < tab - 1
	then line = line || copy (" ", tab - 1 - length (line));
						/* Input string fits on same line */
						/* Pad to tab */
	else do;					/* Previous item exceeded current tab */
		call pl1_print$varying_nl (line);	/* Print all but current item */
		line = copy (" ", tab - 1);		/* Pad next line to tab */
	     end;
	line = line || input_string;			/* Store item on current line */
     end;						/* End of print_item */

     end;						/* End of column_print */

sort_storage_list:
     proc (saved_list_st, saved_list_length, sorting_field);

dcl	1 saved_list_st	aligned,
	  2 saved_list	(1024) ptr unaligned;	/* For efficiency */
dcl	saved_list_length	fixed bin;
dcl	sorting_field	fixed bin;

dcl	(d, i, j, k)	fixed bin;
dcl	ignored_type	fixed bin;
dcl	(p1, p2)		ptr;
dcl	p1_owner		ptr;
dcl	p2_owner		ptr;
dcl	(compare, interchange)
			bit (1);
dcl	p1_owner_name	char (256) varying;
dcl	p2_owner_name	char (256) varying;

/* Sort saved list of symbols on location or loc/stack owner.
   Algorithm is Shell sort. */

	d = saved_list_length;
	do while (d > 1);
	     d = 2 * divide (d, 4, 17, 0) + 1;
	     do i = 1 to saved_list_length - d;
		k = i + d;
		p2 = saved_list (k);
		compare = "1"b;
		do while (compare);
		     compare = "0"b;
		     j = k - d;
		     p1 = saved_list (j);
		     if sorting_field = 0
		     then interchange = p1 -> symbol.location > p2 -> symbol.location;
		     else do;
			     p1_owner = p1 -> symbol.block_node;
						/* Find stack frame owners of p1 and p2 */
			     if p1_owner -> block.owner ^= null
			     then p1_owner = p1_owner -> block.owner;
			     p2_owner = p2 -> symbol.block_node;
			     if p2_owner -> block.owner ^= null
			     then p2_owner = p2_owner -> block.owner;
			     if p1_owner = p2_owner
			     then interchange = p1 -> symbol.location > p2 -> symbol.location;
						/* Sort symbols with same stack owner by loc */
			     else do;
				     call block_name (p1_owner, p1_owner_name, ignored_type);
						/* Sort symbols by stack owner's name */
				     call block_name (p2_owner, p2_owner_name, ignored_type);
				     interchange = p1_owner_name > p2_owner_name;
				end;
			end;
		     if interchange
		     then do;
			     saved_list (j) = saved_list (k);
						/* Interchange out-of-order symbols */
			     saved_list (k) = p1;
			     if j > d
			     then do;
				     k = j;
				     compare = "1"b;
				end;
			end;
		end;
	     end;
	end;

     end;						/* End of sort_storage_list */

format_items:
     proc (sym_pt, loc_item, name_item, procedure_item);

dcl	sym_pt		ptr;
dcl	(loc_item, name_item, procedure_item)
			char (256) varying;

dcl	type		fixed bin;
dcl	bit		builtin;

/* Get various strings from symbol node ptr */

	loc_item = substr (binoct (bit (fixed (sym_pt -> symbol.location, 18), 18)), 1, 6);
	name_item = sym_pt -> symbol.token -> token.string;
	call block_name ((sym_pt -> symbol.block_node), procedure_item, type);

     end;						/* End of format_items */

     end;						/* End of pl1_symbol_print. */
