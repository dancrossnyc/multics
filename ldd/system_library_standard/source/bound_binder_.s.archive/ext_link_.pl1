/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1978 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(85-09-24,Elhard), approve(85-09-24,MCR7198),
     audit(86-06-30,Weaver), install(86-07-16,MR12.0-1094):
     Improved documentation, changed errname to use the caller-supplied name
     instead of "binder_", and modified to store relocation address in the
     link_regeneration_table and just return relocated address on subsequent
     references.
                                                   END HISTORY COMMENTS */

/**********************************************************************/
/*							*/
/*	Name:	ext_link_					*/
/*	Input:	argument_pointer				*/
/*	Function:	given an external_ref structure (pointed to by	*/
/*		argument_pointer) defining a link in the current	*/
/*		input component, create a corresponding external	*/
/*		link in the new object segments linkage section.	*/
/*	Output:	none.					*/
/*							*/
/*	Notes:	External links are created by the following	*/
/*		process:					*/
/*		  - if the link is type-6 or *system, then find	*/
/*		    or create an init_map entry matching the	*/
/*		    initialization info for the link.		*/
/*		  - if the link is a trap-before-call link, then	*/
/*		    recursively generate the trap link, and the	*/
/*		    arg_link (if present)			*/
/*		  - try to find the segname, and entryname in the	*/
/*		    stringmap				*/
/*		  - scan the link_map for another link to the	*/
/*		    target.				*/
/*		  - if the link is a type-6 or *system link, and	*/
/*		    the init-info does not match then we must	*/
/*		    select one of the init info's or combine them	*/
/*		    The following algorithm is used to select	*/
/*		    the initialization info:			*/
/*		     If one links has an area initialization	*/
/*		     and the other does not, then abort with a	*/
/*		     fatal error.  This cannot be resolved.	*/
/*							*/
/*		     Initializations same size		*/
/*							*/
/*		     no new initialization			*/
/*		     1 was init before	use old		*/
/*		     2 was not init before	use old		*/
/*							*/
/*		     new initialization			*/
/*		     3 was init before	use old; print msg	*/
/*		     4 was not init before	use new		*/
/*							*/
/*		     New initialization smaller		*/
/*							*/
/*		     no new initialization			*/
/*		     5 was init before	use old		*/
/*		     6 was not init before	use old		*/
/*							*/
/*		     new initialization			*/
/*		     7 was init before	use old; print msg	*/
/*		     8 was not init before	*use new with	*/
/*					 larger size	*/
/*							*/
/*		     New initialization larger		*/
/*							*/
/*		     no new initialization			*/
/*		     9 was init before	*use old with	*/
/*					 larger size	*/
/*		     10 was not init before	use new		*/
/*							*/
/*		     new initialization			*/
/*		     11 was init before	use new; print msg	*/
/*		     12 was not init before	use new		*/
/*							*/
/*		     * using a given init info template with a	*/
/*		       larger size means that it must be extended	*/
/*		       with zeros				*/
/*							*/
/*		  - if an existing link is found and can be used	*/
/*		    relocate the referencing halfword and return	*/
/*		  - generate a new expression word in the	*/
/*		    definition section			*/
/*		  - generate a new type pair if the existing one	*/
/*		    could not be used			*/
/*		  - if the segname or entryname were not found in	*/
/*		    the stringmap, then add them		*/
/*		  - generate a new link in the linkage section	*/
/*		    and a new link_map entry.			*/
/*		  - relocate the referencing halfword and return	*/
/*							*/
/*	A note on error handling:				*/
/*	bx_$fatal_error is set when the error is fatal (i.e. there	*/
/*	should be no bound segment) but it is useful to continue	*/
/*	and possibly generate more messages for the user.		*/
/*	fatal_binder_error is signaled when the error is so severe	*/
/*	that the binder cannot reasonably continue (as when it runs	*/
/*	out of room).  (It is possible that a different		*/
/*	implementation could avoid having to abort.)		*/
/*							*/
/**********************************************************************/

/* Designed and initially coded by Michael J. Spier, October 6, 1970	*/
/* modified 75.06.20 by M. Weaver to fix type 6 link initialization */
/* modified July 1975 for separate static */
/* modified October 1976 to regenerate *system */
/* modified January 1977 by M. Weaver to use largest init sizes and convert some type 6 links to *system */
/*  modified March 18, 1977 by M. Weaver to handle 0 trap ptr for *system links  */
/* modified October 21, 1977 by M. Weaver to add non-relocation mode */
/* modified December 6, 1977 by M. Weaver to allow larger external variable init sizes */
/* modified Sept 1978 by David Spector for hash-coding strm */
/* Modified 01/15/81, W. Olin Sibert, to remove ribbon shifts. */
/* modified March 1, 1983 by M. Weaver to use standard include files and allocate init structures during finish */
/* modified December 29, 1983 by M. Weaver to not relocate n for *text|offsetname+n */

/* format: style3,^indnoniterdo */
ext_link_:
     procedure (argument_pointer);

declare	argument_pointer	pointer;


/* DECLARATION OF EXTERNAL SYMBOLS */

declare	decode_link_	external entry (pointer) returns (bit (1) aligned);
declare	ext_link_$gen_trap	external entry (pointer) returns (fixed bin (18) unsigned aligned);
declare	com_err_		external entry options (variable);
declare	ioa_		entry options (variable);
declare	temp_mgr_$allocate	external entry (fixed bin);
declare	temp_mgr_$reserve	external entry (pointer);
declare	strm_hash_$lookup	external entry (char (*), fixed bin (17));
declare	strm_hash_$make_entry
			external entry (char (*) aligned, fixed bin (17));

/* DECLARATION OF INTERNAL STATIC VARIABLES */

declare	(linkbase, defbase, tblp, newlinkp, init_map_ptr)
			pointer internal static;
declare	(n_tbls, nlinks, init_map_lng)
			fixed bin internal static;
declare	null_acc_offset	fixed bin (18) unsigned aligned internal static;
declare	errname		char (16) aligned internal static;
declare	wsegname		char (33) aligned internal static;
declare	wentryname	char (257) aligned internal static;
declare	ext_lng		fixed bin (18) internal static;
declare	linklimit		fixed bin internal static;	/* number of links generated */

/* DECLARATION OF AUTOMATIC STORAGE VARIABLES */

declare	(i, def_growth, map_lng, linkmapx, mapx, extension_size, new_init_map_index, strm_index, new_init_type,
	existing_init_type) fixed bin (17);
declare	(val, step, xoffset, class, name_offset)
			fixed bin (18);
declare	lrt_index		fixed bin;
declare	real_init_size	fixed bin (35);
declare	scratch		(100) fixed bin;
declare	(p, ap, link_ptr, old_trap, extp, new_ptr)
			ptr;
declare	(orig_init_info_ptr, cur_init_info_ptr, init_entry_ptr)
			ptr;
declare	new_link_modifier	bit (6) aligned;
declare	(segname_found, entryname_found, typepair_found, trap_sw, convert, new_has_init_template, init_before)
			bit (1) aligned;
declare	new_ename		char (256) varying;

declare	1 new_exp_word	aligned like exp_word;

declare	1 new_type_pair	aligned like type_pair;

declare	1 new_trap_pair	aligned like link_trap_pair;

declare	1 new		aligned,
	  2 (smaller, equal, larger)
			bit (1) aligned;

/* DECLARATION OF BUILTIN FUNCTIONS */

declare	(addr, addrel, bin, bit, currentsize, divide, fixed, index, length, mod, null, size, sign, string, substr,
	unspec, wordno)	builtin;

declare	fatal_binder_error	condition;

/* DECLARATION OF BASED STRUCTURES */

declare	1 linkmap		(10000) aligned based (newlinkp),
	  2 type_ptr	ptr,			/* ptr to link's generated type pair */
	  2 linkaddr	fixed bin (18) unsigned unaligned,
	  2 init_map_index	fixed bin unaligned,
	  2 init_source	char (32) aligned,		/* origin of init info */
	  2 has_init_template
			bit (1) unaligned,		/* "1"b -> has an associated */
						/* initialization template */
	  2 diff_init_size	bit (1) unaligned,		/* >1 size of init info specified for link */
	  2 print_msg	bit (1) unaligned,		/* >1 init template specified for link */
	  2 incompatible_init_types
			bit (1) unaligned;		/* ext var both area and other init type */

declare	1 init_map	(5000) aligned based (init_map_ptr),
	  2 init_ptr	ptr,			/* ptr to original initialization info */
	  2 new_init_ptr	ptr,			/* ptr to regenerated initialization info */
	  2 template_size	fixed bin (35),		/* expanded size of template */
	  2 total_init_size fixed bin (35),		/* size of variable incl extension */
	  2 reference_count fixed bin unaligned,	/* # of links that reference this entry */
	  2 init_type	fixed bin unaligned;	/* type of init info */

declare	1 tbl_map		based (tblp) aligned,	/* newly generated trap_pair map */
	  2 tbl_offset	(1000) fixed bin (18) unsigned unaligned;

declare	init_size_compares	(-1:1) bit (1) aligned based (addr (new));

declare	copy_save		(ext_lng) fixed bin based (p);

declare	1 word		aligned based,
	  2 left_half	bit (18) unaligned,
	  2 right_half	bit (18) unaligned;

declare	1 ext		aligned based (ap) like external_ref;

	trap_sw = "0"b;				/* indicate that this is a regular link */

start:
	def_growth = 0;
	ctp = bx_$ctp;
	strmp = bx_$strmp;
	ap = argument_pointer;			/* copy argument into our stack frame */
	ctep = ext.compent_ptr;
	val = 0;

	lrtp = comp.clrtp;
	lrt_index = ((ext.loffset - lrt.start_offset) * 0.5) + 1;
	if (lrt.regenerated (lrt_index) ^= UNRESOLVED) & (lrt.regenerated (lrt_index) ^= INTERNALLY_RESOLVED)
	then do;
	     step = fixed (lrt.regenerated (lrt_index), 18);
	     goto adjust_text;
	end;

	new_link_modifier = ext.link_tm || ext.link_td;	/* this program doesn't need them separated */

	segname_found, entryname_found, typepair_found = "0"b;

	map_lng = strm.nstr;
	new_init_map_index = 0;
	old_trap = null;
	new_has_init_template = "0"b;

	unspec (new_exp_word) = "0"b;
	unspec (new_trap_pair) = "0"b;

	new_type_pair.type = bin (ext.type, 18);	/* copy type/trap values into new type pair */
	new_type_pair.trap_relp,			/* this field does not get filled in */
	     new_type_pair.segname_relp, new_type_pair.offsetname_relp = 0;

	class = bin (ext.code15, 18);			/* use class instead of segname for types 1 & 5 */

	if new_type_pair.type = LINK_REFNAME_BASE
	then do;
	     new_type_pair.offsetname_relp = null_acc_offset;
						/* use null acc offset to compare with type 6 */
	     entryname_found = "1"b;			/* we know it's allocated */
	end;

	if ^trap_sw				/* normal ext_link_ entry (not gen_trap entry) */
	then do;					/* format name for possible error message */
	     wsegname = substr (ext.segname, 2, ext.slng - 1);
	     i = ext.elng;
	     wentryname = substr (ext.entryname, 1, i);
	     if wsegname = "*system"
	     then substr (wentryname, 1, 1) = "|";
	     else if i > 0
	     then substr (wentryname, 1, 1) = "$";
	     else do;
		i = 2;
		wentryname = "|0";
	     end;
	end;

	if ext.trap
	then if (new_type_pair.type = LINK_CREATE_IF_NOT_FOUND)
		| ((new_type_pair.type = LINK_SELF_OFFSETNAME) & (class = SECTION_SYSTEM))
	     then do;				/* have create-if-not-found or *system link */
						/* find/create an init map entry for this */
		orig_init_info_ptr = addrel (comp.cdefp, ext.trap);
		call find_init_map_entry ();
		new_has_init_template = (init_map (new_init_map_index).template_size > 0);
	     end;

	     else do;				/* have trap before link */
		addr (scratch) -> copy_save = ap -> copy_save;
						/* save input structure */
		ext.offset = ext.loffset;		/* change input struc to process trap links */
		ext.section = "link";
		ext.relinfo = " ";
		old_trap = addrel (comp.cdefp, ext.trap);
		ext.loffset = old_trap -> link_trap_pair.call_relp;
		if decode_link_ (ap)
		then go to trap_error;


		new_trap_pair.call_relp = ext_link_$gen_trap (ap);
						/* will need to recreate link */

		ext.loffset = old_trap -> link_trap_pair.info_relp;
						/* will look at arg link now */
		if ext.loffset > 0
		then do;				/* process arg link */
		     if decode_link_ (ap) = "1"b
		     then go to trap_error;
		     new_trap_pair.info_relp = ext_link_$gen_trap (ap);
		end;
		else new_trap_pair.info_relp = 0;

		do i = 1 to n_tbls;			/* scan trap before link trap pair map */
		     if unspec (new_trap_pair) = unspec (addrel (defbase, tbl_offset (i)) -> link_trap_pair)
		     then do;
			new_type_pair.trap_relp = tbl_offset (i);
						/* put rel ptr into new link's trap field */
			go to restore_ext;
		     end;
		end;				/* of searching table */

		n_tbls = i;			/* increment size of map */
		tbl_offset (i), new_type_pair.trap_relp = bx_$curdeflng;
		bx_$curdeflng = bx_$curdeflng + 1;	/* update def section size */
		addrel (defbase, tbl_offset (i)) -> link_trap_pair = new_trap_pair;
						/* copy trap pair */
restore_ext:
		ap -> copy_save = addr (scratch) -> copy_save;
						/* restore input struc */
	     end;					/* of trap decoding processing */

/* scan current portion of new linkage section to see if such ext link already exists */

	def_growth = 0;
	new_exp_word.expression = bin (ext.expr, 17);

	if new_type_pair.type = LINK_SELF_BASE | new_type_pair.type = LINK_SELF_OFFSETNAME
	then do;					/* type 1 & type 5 links don't have symbolic segnames */
	     new_type_pair.segname_relp = class;	/* retrieve segbase code */
	     segname_found = "1"b;			/* we know the "segment name" */
	     if bx_$bound_sep_stat ^= 1
	     then if class = SECTION_STATIC		/* link to *static */
		then new_type_pair.segname_relp = SECTION_LINK;
						/* will be no sep static; convert to *link */
	     if new_type_pair.type = LINK_SELF_BASE
	     then do;				/* there is no entryname symbol */
		entryname_found = "1"b;
		if class = SECTION_TEXT
		then new_exp_word.expression = new_exp_word.expression + comp.crelt;
		if class = SECTION_STATIC
		then do;				/* link to static; seg relp may have been changed */
		     if wsegname = "*static"
		     then do;			/* link to static of referencing component */
			if bx_$bound_sep_stat = 1
			then i = 0;
			else i = 8;
			new_exp_word.expression = new_exp_word.expression + comp.creli + i;
		     end;
		end;				/* Otherwise link to static of another component;
					   	   relocation of expression already done by int_link_;
						   ext.segname = original segname, etc. */
		go to lookup_links;
	     end;
	end;

/* Lookup stringmap table for segname and entryname (avoid extra strings) */

	if ^segname_found
	then do;
	     call strm_hash_$lookup (substr (ext.segname, 1, ext.slng), strm_index);
	     if strm_index ^= 0
	     then do;				/* segname found in stringmap */
		new_type_pair.segname_relp = bin (strm.entry (strm_index).map, 18);
		segname_found = "1"b;
	     end;
	end;
	if ^entryname_found
	then do;
	     call strm_hash_$lookup (substr (ext.entryname, 1, ext.elng), strm_index);
	     if strm_index ^= 0
	     then do;				/* entryname found in stringmap */
		new_type_pair.offsetname_relp = bin (strm.entry (strm_index).map, 18);
		entryname_found = "1"b;
	     end;
	end;

lookup_links:
	do linkmapx = 1 to nlinks;			/* scan all newly generated links */
	     step = linkmap (linkmapx).linkaddr;	/* get rel pointer to link */
	     link_ptr = addrel (linkbase, step);	/* and ITS pointer to it */
	     if link_ptr -> object_link.modifier ^= new_link_modifier
	     then go to advance;
	     exp_ptr = addrel (defbase, link_ptr -> object_link.expression_relp);
	     if ^typepair_found
	     then do;
		new_exp_word.type_relp = exp_ptr -> exp_word.type_relp;
						/* fill in in case this type pair fits */
		type_ptr = linkmap (linkmapx).type_ptr;
	     end;
	     else go to use_typepair;

	     if segname_found & entryname_found
	     then do;				/* see if this type pair may be reused */
		if unspec (new_type_pair) ^= unspec (type_ptr -> type_pair)
		then go to advance;			/* type pairs do not match */
						/* but not comparing init info offsets here */
		if new_init_map_index = linkmap (linkmapx).init_map_index
		then go to use_typepair;		/* init info also matches */

/* now see if the init info can be made to match */

		if (new_type_pair.type ^= LINK_CREATE_IF_NOT_FOUND)
		     & ^((new_type_pair.type = LINK_SELF_OFFSETNAME) & (class = SECTION_SYSTEM))
		then go to advance;			/* diff trap-before-links or 1 trap and 1 not */

/* At this point we know we have a reference to a variable and we can't
   have 2 links to the same variable.  We must use the existing link and
   either choose one of the init infos or combine them. */

/* Assume that ALL such links have initialization info. */

/* We can't combine the links if one is for an area and the other is not */

		existing_init_type = init_map (linkmap (linkmapx).init_map_index).init_ptr -> link_init.type;
		if linkmap (linkmapx).incompatible_init_types
		then return;			/* don't print redundant messages */
		if ((new_init_type = INIT_DEFINE_AREA) & (existing_init_type ^= INIT_DEFINE_AREA))
		     | ((existing_init_type = INIT_DEFINE_AREA) & (new_init_type ^= INIT_DEFINE_AREA))
		then do;
		     call com_err_ (0, errname,
			"External variable ^[^a^a^;^2s^]^a has incompatible initialization types.",
			wsegname ^= "*system", wsegname, substr (wentryname, 1, 1), substr (wentryname, 2));
		     bx_$fatal_error = 1;
		     linkmap (linkmapx).incompatible_init_types = "1"b;
		     return;			/* we will bomb anyway */
		end;

/* now we find out how the two initializations compare */

		string (new) = "0"b;
		real_init_size = init_map (linkmap (linkmapx).init_map_index).total_init_size;
		if real_init_size = 0		/* no template */
		then real_init_size = init_map (linkmap (linkmapx).init_map_index).init_ptr -> link_init.n_words;
		init_size_compares (
		     sign (init_map (new_init_map_index).init_ptr -> link_init.n_words - real_init_size)) = "1"b;
						/* compare new and previous init sizes and set
						   appropriate flag via based array */
		if linkmap (linkmapx).has_init_template
		then init_before = "1"b;
		else init_before = "0"b;
		if ^new.equal
		then do;				/* print warning first time around */
		     if ^linkmap (linkmapx).diff_init_size
		     then do;
			if bx_$brief ^= 1
			then call ioa_ (
				"Warning: external variable ^[^a^a^;^2s^]^a has different sizes;^/^-the largest will be used.",
				wsegname ^= "*system", wsegname, substr (wentryname, 1, 1),
				substr (wentryname, 2));
			linkmap (linkmapx).diff_init_size = "1"b;
		     end;
		end;

/* cases 1, 2, 5, 6 just go to use_typepair */

		if new_has_init_template & init_before
		then if init_map (new_init_map_index).init_ptr
			^= init_map (linkmap (linkmapx).init_map_index).init_ptr
						/* make sure it's not the same template */
		     then do;			/* cases 3, 7, 11 */
			linkmap (linkmapx).print_msg = "1"b;
			if new.equal
			then if init_map (linkmap (linkmapx).init_map_index).total_init_size
				> init_map (linkmap (linkmapx).init_map_index).template_size
			     then call replace_init_info;
						/* if old was extended, new is probably better */
		     end;

		if (new_has_init_template & ((new.equal & ^init_before) | (new.larger & init_before)))
		     | (new.larger & ^init_before)	/* cases 4, 10, 11, 12 */
		then call replace_init_info;

		else if new.smaller & new_has_init_template & ^init_before
		then do;				/* case 8 */
						/* use new init template but extend it to length of old */
		     call extend_template ((new_init_map_index),
			init_map (linkmap (linkmapx).init_map_index).init_ptr -> link_init.n_words);
		     call replace_init_info;
		end;

		else if new.larger & ^new_has_init_template & init_before
		then do;				/* case 9 */
						/* use old template extended to new size */
		     call extend_template (linkmap (linkmapx).init_map_index,
			init_map (new_init_map_index).init_ptr -> link_init.n_words);
		     call change_init_map_index;
		end;

use_typepair:
		typepair_found = "1"b;
		if unspec (new_exp_word) = unspec (exp_ptr -> exp_word)
		then goto adjust_text;		/* expression words must also match for actual link to be used */
	     end;
advance:
	end;					/* end of loop for looking at linkmap */

generate_definition:				/* generate expression word and type pair, if necessary */
	def_growth = 1;				/* def section will grow by one expression word */
	xoffset = bx_$curdeflng;			/* offset of expression word */
	exp_ptr = addrel (defbase, xoffset);
	if ^typepair_found				/* we have to generate a type pair */
	then new_exp_word.type_relp = xoffset + 1;	/* thread to type pair to be created */
	exp_ptr -> exp_word = new_exp_word;		/* put expression word into definition section */

	if typepair_found
	then go to generate_link;

	type_ptr = addrel (exp_ptr, 1);		/* ptr to type pair to be generated */
	type_ptr -> type_pair = new_type_pair;		/* copy type pair into new definition section */
	def_growth = def_growth + 2;			/* remember def section grew by 2 words */
	if new_init_map_index > 0			/* references are made by type pairs */
	then init_map (new_init_map_index).reference_count = init_map (new_init_map_index).reference_count + 1;

	if ^segname_found
	then do;					/* we have to generate an ACC string for the segname */
	     call add_name (addr (ext.segname), ext.slng);
	     type_ptr -> type_pair.segname_relp = name_offset;
	end;

	if ^entryname_found
	then do;
	     if substr (ext.entryname, 1, 33) = ext.segname
	     then type_ptr -> type_pair.offsetname_relp = type_ptr -> type_pair.segname_relp;
	     else do;				/* must generate an ACC string for the entryname */
		call add_name (addr (ext.entryname), ext.elng);
		type_ptr -> type_pair.offsetname_relp = name_offset;
	     end;
	end;

/* now update official stringmap length */

	strm.nstr = map_lng;
	if strm.nstr > strm.max_size
	then do;
	     call com_err_ (0, errname, "Stringmap table overflow; please notify maintenance.");
	     strm.nstr = 0;
	     bx_$fatal_error = 1;
	end;

generate_link:					/* regenerate link itself */
	step = bx_$tlinklng;			/* location where new link will be generated */

	linkmapx, nlinks = nlinks + 1;		/* increment table size */
	if nlinks > linklimit
	then do;					/* table overflow */
	     call com_err_ (0, errname,
		"Linktable overflow while adding link to ^a^a^/^-for component ^a.^/^-You have room for only ^d links^/^-after your ^d words of internal static.^/^-Consider using separate static (pl1 or alm) or large arrays (fortran)^/^-to make more room for links.",
		wsegname, wentryname, ext.compent_ptr -> comp.filename, linklimit, bx_$tintlng);
	     signal fatal_binder_error;		/* stop now; don't prolong the agony */
	end;
	linkmap (nlinks).type_ptr = type_ptr;		/* remembering this will make patching easier */
	linkmap (nlinks).linkaddr = step;		/* remember where link is */
	linkmap (nlinks).init_source = comp.filename;	/* and origin of init structure */
	linkmap (nlinks).init_map_index = new_init_map_index;
	linkmap (nlinks).has_init_template = new_has_init_template;
	linkmap (nlinks).diff_init_size = "0"b;
	linkmap (nlinks).print_msg = "0"b;

	link_ptr = addrel (linkbase, step);		/* get pointer to new link */
	bx_$tlinklng = step + 2;			/* and adjust new length of linkage section */
	link_ptr -> object_link.header_relp = -step;	/* backpointer to head of linkage section */
	link_ptr -> object_link.tag = "46"b3;		/* add fault tag 2 code */
	link_ptr -> object_link.expression_relp = xoffset;/* ptr to expression word in def section */
	link_ptr -> object_link.modifier = new_link_modifier;
						/* restore modifiers of original link */

adjust_text:
	bx_$curdeflng = bx_$curdeflng + def_growth;	/* adjust def section length if necessary */
	if ^ext.dont_relocate
	then do;					/* sometimes we regenerate links that aren't referenced */
	     if trap_sw
	     then trap_offset = step;			/* return rel ptr to trap fault */
	     else if ext.relinfo = "lnk18   "
	     then do;
		if ext.side = "lhe"
		then ext.ref_ptr -> word.left_half = bit (bin (step, 18), 18);
		else ext.ref_ptr -> word.right_half = bit (bin (step, 18), 18);
	     end;
	     else substr (ext.ref_ptr -> word.left_half, 4, 15) = bit (bin (step, 15), 15);
						/* put in textsection rel ptr to linkage */
	end;

	lrt.regenerated (lrt_index) = bit (bin (step, 18), 18);

	return;

trap_error:
	ap -> copy_save = addr (scratch) -> copy_save;	/* restore original link information */
	call com_err_ (0, errname, "cannot process trap before link for ^a^a referenced by ^a|^o of ^a", wsegname,
	     wentryname, ext.section, ext.offset, comp.filename);
	bx_$fatal_error = 1;
	return;



gen_trap:
     entry (argument_pointer, trap_offset);

/**********************************************************************/
/*							*/
/*	Name:	ext_link_$gen_trap				*/
/*	Input:	argument_pointer				*/
/*	Function:	This entry point generates a link in essentially	*/
/*		the same manner as ext_link_ except that it	*/
/*		returns a relptr to the trap link relative to the	*/
/*		base of the linkage section.			*/
/*	Output:	trap_offset				*/
/*							*/
/**********************************************************************/

declare	trap_offset	fixed bin (18) unsigned aligned;

	trap_sw = "1"b;				/* indicate this is a trap before link */
	trap_offset = 0;				/* preset return argument */
	go to start;

init:
     entry;

/**********************************************************************/
/*							*/
/*	Name:	ext_link_$init				*/
/*	Input:	none					*/
/*	Function:	allocates static tables for use by ext_link_ and	*/
/*		initializes various static lengths		*/
/*	Output:	none					*/
/*							*/
/**********************************************************************/

	linkbase = bx_$tlinkp;			/* beginning of linkage section */
	if mod (bx_$tlinklng, 2) = 1
	then bx_$tlinklng = bx_$tlinklng + 1;		/* make links start on even location */

	tblp = bx_$freep;				/* pointer to map of trap-pairs */
	linklimit = divide ((bx_$maxlinklng - bx_$tlinklng), 2, 17, 0);
						/* get max no of links */

	call temp_mgr_$reserve (addrel (tblp, linklimit));/* reserve map */
	n_tbls = 0;				/* indicate no trap-pairs yet */

	i = linklimit * 7;				/* get max size of init map */
	call temp_mgr_$allocate (i);			/* make sure that there is enough room */
	init_map_ptr = bx_$freep;			/* pointer to init info map */
	call temp_mgr_$reserve (addrel (init_map_ptr, i));/* reserve init info map */
	i = linklimit * 12;				/* get max size of link map */
	call temp_mgr_$allocate (i);			/* make sure that there is enough room */
	init_map_lng = 0;				/* reset length of init map */

	newlinkp = bx_$freep;			/* make new link table */
	call temp_mgr_$reserve (addrel (newlinkp, i));
	nlinks = 0;				/* preset table size */

	if bx_$debug = 1
	then errname = "ext_link_";
	else errname = bx_$caller;
	defbase = bx_$tdefp;			/* beginning of definition section */

	null_acc_offset = bx_$curdeflng - 1;		/* all zero word set in make_defs_$open_section */
						/* compute the size of the external reference structure 'ext'  */

	ap = addr (scratch);
	ext_lng = size (ext);
	return;

finish:
     entry;

/**********************************************************************/
/*							*/
/*	Name:	ext_link_$finish				*/
/*	Input:	none					*/
/*	Function:	allocates the initialization structures in the	*/
/*		bound segment and patches the initialization	*/
/*		info relptrs back into the links.  If the init	*/
/*		info for a copy_info initialization has been	*/
/*		extended, and the extension is longer than an	*/
/*		arbitrary size (50 words), the copy_info is	*/
/*		converted to a list_template containing a single	*/
/*		copy of the existing info and a repeated zero	*/
/*		Messages are also printed for links which had	*/
/*		multiple initializations specified.		*/
/*	Output:	none					*/
/*							*/
/**********************************************************************/

declare	n_bad_links	fixed bin;

/* print all multiple initialization messages */

	do i = 1 to nlinks;
	     if linkmap (i).print_msg
	     then do;
		type_ptr = linkmap (i).type_ptr;
		if type_ptr -> type_pair.type = LINK_SELF_OFFSETNAME
		then wsegname = "";			/* no segname; don't print *system */
		else wsegname = addrel (defbase, type_ptr -> type_pair.segname_relp) -> acc_string.string || "$";

		call com_err_ (0, errname,
		     "Multiple initializations specified for external variable ^a^a;^/^-the one in ^a will be used.",
		     wsegname, addrel (defbase, type_ptr -> type_pair.offsetname_relp) -> acc_string.string,
		     linkmap (i).init_source);
	     end;
	end;

/* Now allocate all init info structures that the links in the bound segment reference. */

	link_init_n_bits_in_datum = 0;
	do mapx = 1 to init_map_lng;
	     if init_map (mapx).reference_count > 0
	     then do;				/* copy into bound segment */
		init_map (mapx).new_init_ptr, cur_init_info_ptr = addrel (defbase, bx_$curdeflng);
		extension_size = init_map (mapx).total_init_size - init_map (mapx).template_size;

		if init_map (mapx).init_type = INIT_COPY_INFO
		then do;
		     if extension_size <= 50		/* arbitrary limit */
		     then do;
			cur_init_info_ptr -> link_init_copy_info = init_map (mapx).init_ptr -> link_init_copy_info;
			if extension_size > 0
			then cur_init_info_ptr -> link_init_copy_info.header.n_words =
				init_map (mapx).total_init_size;
			bx_$curdeflng = bx_$curdeflng + currentsize (cur_init_info_ptr -> link_init_copy_info);
		     end;				/* of no or small extension */
		     else do;			/* convert to list template */
			cur_init_info_ptr -> link_init_list_template.header.type = INIT_LIST_TEMPLATE;
			cur_init_info_ptr -> link_init_list_template.n_words_in_list =
			     init_map (mapx).init_ptr -> link_init_copy_info.header.n_words
			     + size (list_template_entry) + 1;
			init_entry_ptr = addr (cur_init_info_ptr -> link_init_list_template.template);
			init_entry_ptr -> list_template_entry.n_bits =
			     init_map (mapx).init_ptr -> link_init_copy_info.n_words * 36;
			init_entry_ptr -> list_template_entry.repeat = 1;
			init_entry_ptr -> list_template_entry.datum =
			     unspec (init_map (mapx).init_ptr -> link_init_copy_info.initial_data);


			init_entry_ptr =
			     addrel (init_entry_ptr, currentsize (init_entry_ptr -> list_template_entry));
			call add_extension;
			bx_$curdeflng = bx_$curdeflng + currentsize (cur_init_info_ptr -> link_init_list_template);
		     end;				/* of conversion to list */

		end;				/* of init_copy_info case */

		else if init_map (mapx).init_type = INIT_LIST_TEMPLATE
		then do;
		     cur_init_info_ptr -> link_init_list_template =
			init_map (mapx).init_ptr -> link_init_list_template;
		     if extension_size > 0
		     then do;			/* 0 repeat entry starts where last word now is */
			init_entry_ptr =
			     addrel (cur_init_info_ptr,
			     currentsize (cur_init_info_ptr -> link_init_list_template) - 1);
			call add_extension;
		     end;
		     bx_$curdeflng = bx_$curdeflng + currentsize (cur_init_info_ptr -> link_init_list_template);
		end;				/* of init_list template case */

		else do;				/* no template; just header */
		     cur_init_info_ptr -> link_init = init_map (mapx).init_ptr -> link_init;
		     if extension_size > 0
		     then cur_init_info_ptr -> link_init.n_words = init_map (mapx).total_init_size;
		     bx_$curdeflng = bx_$curdeflng + size (link_init);
		end;
	     end;
	end;					/* of copying init_info into bound segment */

/* Now update the links that have init info */

	n_bad_links = 0;
	xoffset = wordno (defbase);
	do mapx = 1 to nlinks;
	     if linkmap (mapx).init_map_index > 0
	     then do;				/* have init info to fill in */
		new_ptr = init_map (linkmap (mapx).init_map_index).new_init_ptr;
		if new_ptr ^= null
		then linkmap (mapx).type_ptr -> type_pair.trap_relp = wordno (new_ptr) - xoffset;
		else do;				/* indicates bug in this program */
		     n_bad_links = n_bad_links + 1;
		     call com_err_ (0, errname,
			"Link to external variable ^a has missing initialization information.^/^-Notify maintenance personnel.",
			addrel (defbase, linkmap (mapx).type_ptr -> type_pair.offsetname_relp) -> acc_string.string)
			;			/* segname is usually meaningless in this case */
		end;
	     end;
	end;

	if n_bad_links > 0
	then bx_$fatal_error = 1;

	return;

find_init_map_entry:
     proc;

/**********************************************************************/
/*							*/
/*	Name:	find_init_map_entry				*/
/*	Input:	orig_init_info_ptr, new_type_pair, wsegname,	*/
/*		external_ref (pointed to by ap)		*/
/*	Function:	finds or creates an init_map entry for a given	*/
/*		link.  Certain type-6 (create-if-not-found) links	*/
/*		are first converted into *system links.  If an	*/
/*		init_map entry is found that matches, it's	*/
/*		reference count is incremented and it is used.	*/
/*		otherwise an new entry is created.		*/
/*	Output:	new_init_map_index				*/
/*							*/
/**********************************************************************/

	convert = "0"b;
	if new_type_pair.type = LINK_CREATE_IF_NOT_FOUND
	then do;					/* see if it needs to be converted */
	     extp = ap;				/* normal, non trap case */
	     if wsegname = "stat_"
	     then do;
		convert = "1"b;
		new_ename = addr (ext.entryname) -> acc_string.string;
	     end;
	     else if ext.elng = 1
	     then do;				/* null entryname */
		i = index (ext.segname, ".com");
		if (i > 0) & (i = (ext.slng - 3))
		then do;
		     new_ename = substr (ext.segname, 2, i - 2);
		     if new_ename = "b_"
		     then new_ename = "blnk*com";
		     convert = "1"b;
		end;
		else do;
		     new_type_pair.offsetname_relp = null_acc_offset;
						/* set to point to all zero word */
		     entryname_found = "1"b;
		end;
	     end;
	     else if wsegname = "cobol_fsb_"
	     then do;
		new_ename = "cobol_fsb_" || addr (ext.entryname) -> acc_string.string;
		convert = "1"b;
	     end;
	end;

	if convert
	then do;					/* diddle info to make it look like *system link */
	     extp -> ext.code15 = bit (bin (LINK_SELF_OFFSETNAME, 18), 18);
	     new_type_pair.type = LINK_SELF_OFFSETNAME;
	     class = SECTION_SYSTEM;
	     wsegname = "*system";
	     addr (extp -> ext.segname) -> acc_string.count = length ("*system");
	     addr (extp -> ext.segname) -> acc_string.string = "*system";
	     extp -> ext.slng = length ("*system") + 1;
	     wentryname = "|" || new_ename;
	     addr (extp -> ext.entryname) -> acc_string.count = length (new_ename);
	     addr (extp -> ext.entryname) -> acc_string.string = new_ename;
	     extp -> ext.elng = length (new_ename) + 1;
	end;

/* See if an identical init structure is already in our map */

	new_init_type = orig_init_info_ptr -> link_init.type;

	do new_init_map_index = 1 to init_map_lng;
	     cur_init_info_ptr = init_map (new_init_map_index).init_ptr;
						/* get ptr to current entry's init info */
	     if unspec (orig_init_info_ptr -> link_init) = unspec (cur_init_info_ptr -> link_init)
	     then do;				/* so far, init headers match */
		if new_init_type = INIT_COPY_INFO
		then if unspec (orig_init_info_ptr -> link_init_copy_info.initial_data)
			= unspec (cur_init_info_ptr -> link_init_copy_info.initial_data)
		     then return;
		     else ;			/* templates don't match; continue */
		else if new_init_type = INIT_LIST_TEMPLATE
		then if unspec (orig_init_info_ptr -> link_init_list_template.template)
			= unspec (cur_init_info_ptr -> link_init_list_template.template)
		     then return;
		     else ;			/* templates don't match; continue */
		else return;			/* no templates to match in these cases */
	     end;					/* of = headers part */
	end;					/* of comparison loop */

/* if we get here a match was not found, so we have to add an init_map entry */

	init_map_lng = init_map_lng + 1;		/* new_init_map_index should already be = to this */
	init_map (init_map_lng).init_ptr = orig_init_info_ptr;
	init_map (init_map_lng).reference_count = 0;
	init_map (init_map_lng).init_type = new_init_type;
	init_map (init_map_lng).new_init_ptr = null;

/* now set template size */

	if (new_init_type = INIT_COPY_INFO) | (new_init_type = INIT_LIST_TEMPLATE)
	then init_map (init_map_lng).template_size = orig_init_info_ptr -> link_init_copy_info.header.n_words;

	else init_map (init_map_lng).template_size = 0;

	init_map (init_map_lng).total_init_size = init_map (init_map_lng).template_size;
						/* equality indicates not extended */

	return;
     end;

replace_init_info:
     proc;

/**********************************************************************/
/*							*/
/*	Name:	replace_init_info				*/
/*	Input:	new_has_init_info, linkmapx, new_init_map_index	*/
/*	Function:	Changes the init_map index in the link specified	*/
/*		by linkmapx to use the initialization info	*/
/*		referred to by new_init_map_index.		*/
/*	Output:	none					*/
/*							*/
/**********************************************************************/

	linkmap (linkmapx).init_source = comp.filename;
	linkmap (linkmapx).has_init_template = new_has_init_template;
	call change_init_map_index;

	return;

     end;





change_init_map_index:
     proc;

/**********************************************************************/
/*							*/
/*	Name:	change_init_map_index			*/
/*	Input:	linkmapx, new_init_map_index			*/
/*	Function:	replaces the init_map entry for the specified	*/
/*		link and adjusts the reference counts in the	*/
/*		init_map entries				*/
/*	Output:	none					*/
/*							*/
/*	Notes:	this procedure is logically a part of		*/
/*		replace_init_info but must sometimes be called	*/
/*		separately				*/
/*							*/
/**********************************************************************/

	init_map (linkmap (linkmapx).init_map_index).reference_count =
	     init_map (linkmap (linkmapx).init_map_index).reference_count - 1;

	init_map (new_init_map_index).reference_count = init_map (new_init_map_index).reference_count + 1;

	linkmap (linkmapx).init_map_index = new_init_map_index;

	return;

     end;

extend_template:
     proc (cur_init_map_index, target_size);

/**********************************************************************/
/*							*/
/*	Name:	extend_template				*/
/*	Input:	cur_init_map_index, target_size		*/
/*	Function:	extends the specified init_map entry to the size	*/
/*		indicated by target size.  This is done by first	*/
/*		attempting to find an existing init_map entry	*/
/*		that matches the requirements, or by creating one	*/
/*		if no matching init_info already exists.	*/
/*	Output:	new_init_map_index				*/
/*							*/
/**********************************************************************/

declare	cur_init_map_index	fixed bin unal;
declare	target_size	fixed bin (35);

/* first try to match an existing template  */

	do mapx = 1 to init_map_lng;
	     if init_map (mapx).total_init_size = target_size
	     then if init_map (mapx).init_ptr = init_map (cur_init_map_index).init_ptr
						/* the unextended templates must match;
						   the init_map has no duplicates;
						   so if they match, they are the same */
		then do;
		     new_init_map_index = mapx;
		     return;
		end;
	end;					/* of mapx loop */

/* Did not find match.  Must create a new init_map entry for the extension. */

	init_map_lng = init_map_lng + 1;

/* copy whole entry, then update */

	init_map (init_map_lng) = init_map (cur_init_map_index);
	init_map (init_map_lng).total_init_size = target_size;
	init_map (init_map_lng).reference_count = 0;	/* this will be updated later */

	new_init_map_index = init_map_lng;

	return;

     end;

add_name:
     proc (new_name_ptr, name_length);

/**********************************************************************/
/*							*/
/*	Name:	add_name					*/
/*	Input:	new_name_ptr, name_length			*/
/*	Function:	adds a new name to the definition section and to	*/
/*		the string map.				*/
/*	Output:	none					*/
/*							*/
/**********************************************************************/

declare	new_name_ptr	ptr;			/* to an ACC string */
declare	name_length	fixed bin;
declare	new_name		char (name_length) aligned based;

	name_offset = xoffset + def_growth;
	addrel (defbase, name_offset) -> new_name = new_name_ptr -> new_name;
	def_growth = def_growth + divide (name_length + 3, 4, 17, 0);

	map_lng = map_lng + 1;
	strm.entry (map_lng).map = bit (name_offset, 18);
	call strm_hash_$make_entry (new_name_ptr -> new_name, map_lng);

	return;

     end;


add_extension:
     proc;

/**********************************************************************/
/*							*/
/*	Name:	add_extension				*/
/*	Input:	init_entry_ptr, extension_size		*/
/*	Function:	adds a list_template entry to the list template	*/
/*		initialization to add <extension_size> zero words	*/
/*		to the end of the initialization		*/
/*	Output:	none					*/
/*							*/
/**********************************************************************/

/* add the extension to skip the required number of bits	*/

	init_entry_ptr -> list_template_entry.n_bits = extension_size * 36;
	init_entry_ptr -> list_template_entry.repeat = 0;

/* append the end-of-list-template marker (n_bits = 0)	*/

	addrel (init_entry_ptr, size (list_template_entry)) -> list_template_entry.n_bits = 0;

/* adjust the length of the template	*/

	cur_init_info_ptr -> link_init_list_template.n_words_in_list =
	     cur_init_info_ptr -> link_init_list_template.n_words_in_list + size (list_template_entry);
	cur_init_info_ptr -> link_init_list_template.header.n_words = init_map (mapx).total_init_size;


	return;

     end;

%include extref;

%include bindext;

%include comptbl;

%include bndtbl;

%include definition_dcls;

%include object_link_dcls;



     end;						/* of ext_link_ */
