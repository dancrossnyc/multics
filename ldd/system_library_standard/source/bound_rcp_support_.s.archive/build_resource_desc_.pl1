/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(86-07-28,Hartogs), approve(86-07-28,MCR7463),
     audit(86-08-06,Lippard), install(86-08-14,MR12.0-1123):
     Make changes to disallow specifying less than 1 resource for reservation.
                                                   END HISTORY COMMENTS */

build_resource_desc_:
     proc (P_inargs, P_areap, P_cargp, P_rscp, P_cargidx, P_errmsg, P_code);

/* Written at some point or another by R.J.C. Kissel */
/* Last modified 06/17/81 by C. D. Tavares to make "" as an acs_path not be
   expanded to [wd]. */

dcl  P_inargs dim (*) char (*) varying;
dcl  error_table_$unimplemented_version
     fixed bin (35) external;

	P_rscp = null ();
	P_errmsg = "";
	P_code = error_table_$unimplemented_version;
	return;



/* Local Variables */

dcl  DUMB_acs_path char (168);			/* To pacify Tavares. */
dcl  acarg_idx fixed bin;				/* Index into the additional control arg array. */
dcl  apply_defaults bit (1) aligned;			/* True if defaults to be applied to resource_descriptions */
dcl  argument char (256) varying;
						/* Holds arguments to be processed. */
dcl  array_args bit (1);				/* True if the arguments are in the array, P_inargs. */
dcl  attr_type fixed bin;				/* 0-absolute, 1-relative, 2-multiple. */
dcl  carg_idx fixed bin;				/* Index into the resource description control arg array. */
dcl  cargs_given bit (1);				/* True if any control arguments have been given. */
dcl  code fixed bin (35);				/* System status code. */
dcl  resource_type char (32);				/* Used to get primary resource type. */
dcl  exists bit (1);				/* Indicates wheter or not the argument exists. */
dcl  item_idx fixed bin;				/* Index into resource_descriptions items. */
dcl  names_given bit (1);				/* True if any names of resources are given. */
dcl  number_given bit (1);				/* True if the "-nb" control arg is specified. */
dcl  num_of_rscs fixed bin;				/* The number of resources described by the caller. */
dcl  nvals fixed bin;				/* Number of values to skip index. */
dcl  reservation bit (1);				/* True if a reservation structure is needed. */

dcl 1 rsc_info aligned like resource_descriptions.item;
dcl  caller_area area (261129) based (P_areap);

/* Global Variables */

dcl  arg_idx fixed bin;				/* Get_Next_Arg..index of arg in command line. */
dcl  name_stack_ptr ptr;				/* Save_Name, Get_Name..storage pointer. */
dcl  name_tail_ptr ptr;				/* Save_Name, Get_Name..storage pointer. */
dcl  nargs fixed bin;				/* Get_Next_Arg..number of args in command line. */
dcl  rdp_stack_ptr ptr;				/* Save_Pointer, Get_Pointer..storage pointer. */
dcl  rdp_tail_ptr ptr;				/* Save_Pointer, Get_Pointer..storage pointer. */

/* Global Based Variables */

dcl 1 acargs aligned based (P_cargp),
    2 number fixed bin,
    2 arg (0b refer (acargs.number)),
      3 long_name char (32),
      3 short_name char (32),
      3 nvals fixed bin;

dcl  acarg_indicies (acargs.number) based (P_cargidx);

/* Global Constants */

dcl  C_rd_cargs (24) char (32) internal static options (constant) initial ("-acc",
						/*  1 */
     "-access_class",				/*  2 */
     "-acs_path",					/*  3 */
     "-alloc",					/*  4 */
     "-attr",					/*  5 */
     "-attributes",					/*  6 */
     "-charge_type",				/*  7 */
     "-com",					/*  8 */
     "-comment",					/*  9 */
     "-crgtp",					/* 10 */
     "-loc",					/* 11 */
     "-location",					/* 12 */
     "-lock",					/* 13 */
     "-nb",					/* 14 */
     "-number",					/* 15 */
     "-ow",					/* 16 */
     "-owner",					/* 17 */
     "-pacc",					/* 18 */
     "-pattr",					/* 19 */
     "-potential_access_class",			/* 20 */
     "-potential_attributes",				/* 21 */
     "-release_lock",				/* 22 */
     "-rll",					/* 23 */
     "-uid" /* 24 */);

/* Include Files */

	%include resource_control_desc;

/* External Entries */

dcl  absolute_pathname_$add_suffix
     entry (char (*), char (*), char (*), fixed bin (35));
dcl  convert_authorization_$from_string_range
     entry (bit (72) aligned dim (2), char (*), fixed bin (35));
dcl  cu_$arg_count_rel entry (fixed bin, ptr);
dcl  cu_$arg_ptr_rel entry (fixed bin, ptr, fixed bin, fixed bin (35), ptr);
dcl  cv_oct_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
dcl  cv_rcp_attributes_$from_string
     entry (char (*), bit (72) dim (2) aligned, char (*) varying, fixed bin (35));
dcl  cv_rcp_attributes_$modify_rel
     entry (bit (72) dim (2) aligned, bit (72) dim (4) aligned, bit (72) dim (2) aligned);
dcl  cv_rcp_attributes_$from_string_rel
     entry (char (*), bit (72) dim (4) aligned, char (*) varying, fixed bin (35));
dcl  cv_rcp_attributes_$test_valid
     entry (char (*), bit (72) dim (2) aligned, fixed bin, fixed bin (35));
dcl  get_group_id_ entry () returns (char (32));
dcl  resource_info_$defaults
     entry (char (*), char (*), ptr, fixed bin, fixed bin (35));
dcl  resource_info_$get_primary_type
     entry (char (*), char (*), fixed bin (35));

/* External Constants */

dcl  error_table_$badcall
     fixed bin (35) external;
dcl  error_table_$bad_index
     fixed bin (35) external;
dcl  error_table_$badopt fixed bin (35) external;
dcl  error_table_$inconsistent
     fixed bin (35) external;
dcl  error_table_$rcp_attr_not_permitted
     fixed bin (35) external;
dcl  error_table_$rcp_bad_attributes
     fixed bin (35) external;
dcl  error_table_$bad_conversion
     fixed bin (35) external;
dcl  error_table_$noarg fixed bin (35) external;

/* Builtin Functions and Conditions */

dcl (convert, bit, divide, fixed, hbound, lbound, length, maxlength, null, rtrim, substr, unspec)
     builtin;

dcl (area, cleanup, conversion)
     condition;

from_arglist:
	entry (P_clinep, P_areap, P_cargp, P_rscp, P_apply_defaults, P_cargidx, P_errmsg, P_code);

dcl (
     P_clinep ptr,					/* Input  -- to caller's command line. */
     P_areap ptr,					/* Input  -- to caller's area. */
     P_cargp ptr,					/* Input  -- to additional control arg descriptions. */
     P_rscp ptr,					/* Output -- to resource_descriptions structure. */
     P_apply_defaults bit (1) aligned,			/* Input -- ON if defaults wanted in resource_descriptions */
     P_cargidx ptr,					/* Output -- to an array of indicies for the additional cargs. */
     P_errmsg char (*) varying,			/* Output -- descriptive error message. */
     P_code fixed bin (35)				/* Output -- standard status code. */
     ) parameter;

/*

   D_E_S_C_R_I_P_T_I_O_N_

   This subroutine takes a pointer to a command line and uses cu_$arg_ptr_rel
   to get individual arguments.  It parses the command line looking first at the
   additional control arguments, if any are specified, and then at the control
   arguments for a resource description.
   Resource description control arguments and non-control arguments are used
   to fill in a resource_descriptions structure.  This structure will be allocated
   in the caller supplied area and a pointer returned.
   If additional control arguments are found then the index of the argument
   in the command line is returned in the caller supplied array.  An error is recognized
   if there are not enough arguments left on the command line to supply the values
   required by the control argument.  Otherwise, these values are simply skipped
   and parsing continues.  It is the caller's responsibility to pick up and process
   these control arguments when control is returned to him.  A zero value for the
   index means that the corresponding control argument was not found.
   The returned error message may be used along with the error code in a call
   to com_err_ to output a meaningful error message.


   J_O_U_R_N_A_L_I_Z_A_T_I_O_N_

   1) Written 10/78 by R.J.C. Kissel.
   2) Modified 3/79 by R.J.C. Kissel to get and use the defaults in the RTDT.
   3) Modified 08/79 by C. D. Tavares to only apply defaults when required, not all the time.

*/











	call Initialize ();
	apply_defaults = P_apply_defaults;
	rdp_stack_ptr = null ();			/* These are only used by the Cleanup_Handler */
	rdp_tail_ptr = null ();			/*  for this entry point. */
	array_args = "0"b;
	reservation = "0"b;
	arg_idx = 0;

	call cu_$arg_count_rel (nargs, P_clinep);

	on cleanup
	     call Cleanup_Handler ();

	call Process_Resource_Spec ();

/*

   All the arguments have been successfully processed, now we will allocate
   the structure that the caller wants to have filled in.  We can do this because
   now we know the number of resources it must describe.  Then we will fill in
   the information we have found.
   Note that if the caller gave us a null area pointer then we are done and will
   just return.

*/

	call Fill_Resource_Desc ();

	P_rscp = resource_desc_ptr;
	P_errmsg = "";				/* Everything is all right. */
	P_code = 0;
	return;

reserve:
	entry (P_inargs, P_areap, P_cargp, P_rscp, P_resp, P_cargidx, P_errmsg, P_code);

dcl  P_resp ptr parameter;				/* Output -- to resource reservation structure. */

/*

   D_E_S_C_R_I_P_T_I_O_N_

   This subroutine perfors many of the same functions as the from_arglist
   entry point.  However, the arguments are taken from an input array
   rather than a command line.  Also, this entry must build a resource
   reservation structure, and it must handle multiple resource specifications
   separated by the -resource_type or -rsct control argument.


   J_O_U_R_N_A_L_I_Z_A_T_I_O_N_

   1) Written 12/78 by R.J.C. Kissel.
   2) Modified 3/79 by R.J.C. Kissel to get and use the defaults in the RTDT.

*/

/* Local Variables */

dcl  rdp ptr;					/* To the saved resource_descriptions structures. */
dcl  total_rscs fixed bin;				/* Total of num_of_rscs for each resource specification. */
dcl  mitem_idx fixed bin;				/* Item index for the master resource_description structure. */










	rdp_stack_ptr = null ();
	rdp_tail_ptr = null ();

	array_args = "1"b;				/* The arguments are in an array. */
	reservation = "1"b;				/* Multiple resource specifications are allowed. */
	arg_idx = 0;
	total_rscs = 0;

	nargs = hbound (P_inargs, 1);

	call Initialize ();				/* To close a small cleanup window. */
	apply_defaults = "0"b;
	on cleanup
	     call Cleanup_Handler ();

/*
   This loop processes all of the resource specifications in the resource
   description.  They are separated by the -resource_type or -rsct control
   argument which Process_Resource_Spec recognizes.  The arg_idx keeps
   track of how far we have gotten.  A pointer to the resource_descriptions
   structure for each specification is saved for later use.
*/

	do while (arg_idx < nargs);			/* arg_idx is controlled by Process_Resource_Spec. */
	     call Initialize ();
	     call Process_Resource_Spec ();
	     call Fill_Resource_Desc ();
	     call Save_Pointer (resource_desc_ptr);
	     total_rscs = total_rscs + num_of_rscs;
	end;

/*
   Now that we know everything we can allocate the final structures
   and fill them in from the saved information.
*/

	if P_areap ^= null ()
	then do;					/* Allocate stuff for the caller. */
	     Resource_count = total_rscs;

	     on area
		goto ERROR_area;
	     allocate resource_descriptions in (caller_area) set (resource_desc_ptr);
	     allocate reservation_description in (caller_area) set (resource_res_ptr);
	     revert area;

/* Now copy the information we have gathered. */

	     call Get_Pointer (rdp);
	     if rdp = null ()
	     then goto ERROR_badone;			/* There must be at least one at hhis point. */

	     mitem_idx = 1;

	     do while (rdp ^= null ());		/* Loop through all saved structures. */
		do item_idx = 1 to rdp -> resource_descriptions.n_items;
		     resource_descriptions.item (mitem_idx) = rdp -> resource_descriptions.item (item_idx);
		     mitem_idx = mitem_idx + 1;
		end;

		free rdp -> resource_descriptions;
		call Get_Pointer (rdp);
	     end;

/* Fill in the constant information in the two structures. */

	     resource_descriptions.version_no = resource_desc_version_1;
	     reservation_description.version_no = resource_res_version_1;
	     reservation_description.reserved_for = get_group_id_ ();
	     reservation_description.reserved_by = get_group_id_ ();
	     reservation_description.reservation_id = 0b;
	     reservation_description.group_starting_time = 0b;
	     reservation_description.asap_duration = 0b;
	     reservation_description.flags.auto_expire = "1"b;
	     reservation_description.flags.asap = "0"b;
	     reservation_description.flags.rel = "0"b;
	     reservation_description.flags.sec = "0"b;
	     reservation_description.reservation_group (*).starting_time = 0b;
	     reservation_description.reservation_group (*).duration = 0b;
	end;					/* Allocate stuff for the caller. */

	else do;					/* Caller wants nothing. */
	     resource_desc_ptr = null ();
	     resource_res_ptr = null ();
	end;
						/* Caller wants nothing. */
	P_rscp = resource_desc_ptr;
	P_resp = resource_res_ptr;

/*
   P_errmsg has already been initialized to the null string in Initialize.  We don't
   want to set it here because it may contain some auxillary information that is
   described in the comment in Process_Resource_Spec in the attribute processing section.
*/

	P_code = 0;
	return;

/*

   All error handling is done here.  There is a separate label for each possible
   error.  These are in the main program so that the subroutines can make non-local
   transfers out of the current environment and then return to the caller after
   building the error message.

*/

ERROR_acarg:
	P_errmsg = "After " || rtrim (acargs.arg (acarg_idx).long_name) || ".";
	P_code = error_table_$noarg;
	call Cleanup_Handler ();
	return;

ERROR_allocarg:
	P_errmsg = argument || "not on or off.";
	P_code = error_table_$badopt;
	call Cleanup_Handler ();
	return;

ERROR_area:
	P_errmsg = "Error allocating storage necessary for program operation.";
	P_code = error_table_$badcall;
	call Cleanup_Handler ();
	return;

ERROR_attr:
	P_errmsg = "Bad attribute specification: " || argument || ".";
	P_code = code;
	call Cleanup_Handler ();
	return;

ERROR_badarg:
	P_errmsg = argument;
	P_code = error_table_$badopt;
	call Cleanup_Handler ();
	return;

ERROR_badnb:
	P_errmsg = argument;
	P_code = error_table_$bad_conversion;
	call Cleanup_Handler ();
	return;

ERROR_badone:
	P_errmsg = "From build_resource_desc_.";
	P_code = error_table_$bad_index;
	call Cleanup_Handler ();
	return;

ERROR_cagiv:
	P_errmsg = "resource name " || argument || " appears after a control argument.";
	P_code = error_table_$badcall;
	call Cleanup_Handler ();
	return;

ERROR_defaults:
	P_errmsg = "Error obtaining defaults for " || rtrim (rsc_info.type) || ".";
	P_code = code;
	call Cleanup_Handler ();
	return;

ERROR_exterr:
	P_errmsg = "";				/* Error produced by an external call, just use code. */
	P_code = code;
	call Cleanup_Handler ();
	return;

ERROR_lownb:
          P_errmsg = "Number must be 1 or greater to be valid.";
	P_code = error_table_$bad_conversion;
	call Cleanup_Handler ();
	return;

ERROR_noarg:
	P_errmsg = "After " || argument;
	P_code = error_table_$noarg;
	call Cleanup_Handler ();
	return;

ERROR_noname:
	P_errmsg = "After -name.";
	P_code = error_table_$noarg;
	call Cleanup_Handler ();
	return;

ERROR_nonb:
	P_errmsg = "-number with explicit names.";
	P_code = error_table_$inconsistent;
	call Cleanup_Handler ();
	return;

ERROR_notype:
	P_errmsg = "A resource type must always be specified.";
	P_code = error_table_$badcall;
	call Cleanup_Handler ();
	return;

ERROR_pacc:
	P_errmsg = "Bad access bounds specification: " || argument || ".";
	P_code = code;
	call Cleanup_Handler ();
	return;

ERROR_pattr:
	P_errmsg = argument;
	P_code = code;
	call Cleanup_Handler ();
	return;

ERROR_prota:
	P_errmsg = """*"" not allowed in potential attributes.";
	P_code = error_table_$rcp_attr_not_permitted;
	call Cleanup_Handler ();
	return;

ERROR_type:
	P_errmsg = "Unrecognized resource type: " || argument || ".";
	P_code = code;
	call Cleanup_Handler ();
	return;

ERROR_uid:
	P_errmsg = argument;
	P_code = error_table_$bad_conversion;
	call Cleanup_Handler ();
	return;

%page;
Initialize:
	proc ();

/*

   All the local and global variables are initialized here, unless they are
   assigned to at their first use.

*/

	     argument = "";
	     num_of_rscs = 0b;
	     names_given = "0"b;
	     number_given = "0"b;
	     cargs_given = "0"b;
	     name_stack_ptr = null ();
	     name_tail_ptr = null ();
	     resource_desc_ptr = null ();
	     resource_res_ptr = null ();

	     unspec (rsc_info) = "0"b;

/*

   Now we will initialize all the cahracter strings in the structure to
   null string instead of zero bit strings.  This will make the output
   easier to read.

*/

	     rsc_info.type = "";
	     rsc_info.name = "";
	     rsc_info.owner = "";
	     rsc_info.acs_path = "";
	     rsc_info.location = "";
	     rsc_info.comment = "";
	     rsc_info.charge_type = "";

	end Initialize;

Process_Resource_Spec:
	proc ();

/*

   The resource type must be the first argument and must always be present.
   volume or a device.
   The -resource_type or -rsct control argument is optional and will
   be ignored.

*/

	     call Get_Next_Arg (argument, exists);	/* Get the type. */
	     if ^exists
	     then goto ERROR_notype;

	     if argument = "-resource_type" | argument = "-rsct"
	     then call Get_Next_Arg (argument, exists);

	     call resource_info_$get_primary_type ((argument), resource_type, code);
						/* Check the type. */
	     if code ^= 0
	     then goto ERROR_type;

	     rsc_info.type = resource_type;		/* use primary type */

/*

   Now process the rest of the arguments supplied by the caller.  If there are
   any names they must be first, before any control arguments.  Anything beginning
   with "-" unless it is preceded by "-name" or "-nm" is assumed to be a control
   argument, anything else is assumed to be a name.  A control argument is checked
   against the additional control argument array supplied by the caller first, and then
   against the known resource description control arguments.
   If this is a reservation then multiple resource types may appear
   separated by -resource_type or -rsct.  Therefore,  if "reservation" is
   true and one of these control arguments is found, we return to the
   caller because we have processed a complete resource specification.
   Notice that "arg_idx" points to the -resource_type or -rsct argument.

*/

	     call Get_Next_Arg (argument, exists);

	     do while (exists);			/* Loop through arguments. */

		if reservation & (argument = "-resource_type" | argument = "-rsct")
		then goto DONE;

		if substr (argument, 1, 1) ^= "-" | argument = "-name" | argument = "-nm"
		then do;				/* This is a name. */
		     if argument = "-name" | argument = "-nm"
		     then do;			/* Get the real name. */
			call Get_Next_Arg (argument, exists);
			if ^exists
			then goto ERROR_noname;
		     end;				/* Get the real name. */

		     if cargs_given
		     then goto ERROR_cagiv;		/* Any names must be before control args. */

		     call Save_Name (argument);

		     num_of_rscs = num_of_rscs + 1;
		     names_given = "1"b;
		end;				/* This is a name. */

		else if Is_Acarg (argument, acarg_idx)
		then do;				/* Look for additional cargs before cargs. */
		     cargs_given = "1"b;
		     acarg_indicies (acarg_idx) = arg_idx;
		     do nvals = 1 to acargs.arg (acarg_idx).nvals;
						/* Skip over values. */
			call Get_Next_Arg (argument, exists);
			if ^exists
			then goto ERROR_acarg;	/* Make sure they are there. */
		     end;				/* Skip over values. */
		end;				/* Look for additional cargs before cargs. */

		else if Is_Carg (argument, carg_idx)
		then do;				/* This is a resource description carg. */

		     if carg_idx < lbound (CARG, 1) | carg_idx > hbound (CARG, 1)
		     then goto ERROR_badone;		/* Program malfunction. */

		     cargs_given = "1"b;

		     goto CARG (carg_idx);		/* Essentially a case statement. */

CARG (2):
CARG (1):						/* -access_class, -acc */
		     call Get_Next_Arg (argument, exists);
		     if ^exists
		     then goto ERROR_noarg;

		     call convert_authorization_$from_string_range (rsc_info.aim_range, (argument), code);
		     if code ^= 0
		     then goto ERROR_pacc;
		     rsc_info.given.aim_range = "1"b;
		     goto ESAC;

CARG (3):						/* -acs_path */
		     call Get_Next_Arg (argument, exists);
		     if ^exists
		     then goto ERROR_noarg;

		     if argument = "" then
			rsc_info.acs_path = "";

		     else do;
			call absolute_pathname_$add_suffix
			     ((argument), "acs", DUMB_acs_path, code);
			if code ^= 0
			then goto ERROR_exterr;
			rsc_info.acs_path = DUMB_acs_path;
		     end;

		     rsc_info.given.acs_path = "1"b;
		     goto ESAC;

CARG (4):						/* -alloc */
		     call Get_Next_Arg (argument, exists);
		     if ^exists
		     then goto ERROR_noarg;

		     if argument = "on"
		     then rsc_info.user_alloc = "1"b;
		     else if argument = "off"
		     then rsc_info.user_alloc = "0"b;
		     else goto ERROR_allocarg;

		     rsc_info.given.user_alloc = "1"b;
		     goto ESAC;

CARG (6):
CARG (5):						/* -attributes, -attr */
		     call Get_Next_Arg (argument, exists);
		     if ^exists
		     then goto ERROR_noarg;

		     call cv_rcp_attributes_$from_string_rel ((rsc_info.type), rsc_info.desired_attributes, argument,
			code);
		     if code ^= 0
		     then goto ERROR_attr;

		     rsc_info.given.desired_attributes = "1"b;

/*
   Now we will do a kludgey thing.  In order that parse_resource_desc_ can know that
   the user specified attributes, we will set the status code for this resource to 1.
   This is necessary because currently either names or attributes
   are allowed but not both, and we will lose the information about what the user said
   because setting default attributes always says that attributes were given.  Finally,
   we need to know that attributes were given in rcp_reserve_ so we can do the right thing.
   This code can be eliminated when both names and attributes are allowed in a resource
   type specification.
*/

		     rsc_info.status_code = 1;
		     goto ESAC;

CARG (7):
CARG (10):					/* -charge_type, -crgtp */
		     call Get_Next_Arg (argument, exists);
		     if ^exists
		     then goto ERROR_noarg;

		     rsc_info.charge_type = argument;
		     rsc_info.given.charge_type = "1"b;
		     goto ESAC;

CARG (9):
CARG (8):						/* -comment, -com */
		     call Get_Next_Arg (argument, exists);
		     if ^exists
		     then goto ERROR_noarg;

		     rsc_info.comment = argument;
		     rsc_info.given.comment = "1"b;
		     goto ESAC;

CARG (12):
CARG (11):					/* -location, -loc */
		     call Get_Next_Arg (argument, exists);
		     if ^exists
		     then goto ERROR_noarg;

		     rsc_info.location = argument;
		     rsc_info.given.location = "1"b;
		     goto ESAC;

CARG (13):					/* -lock */
		     call Get_Next_Arg (argument, exists);
		     if ^exists
		     then goto ERROR_noarg;

		     if argument = "on"
		     then rsc_info.usage_lock = "1"b;

		     else if argument = "off"
		     then rsc_info.usage_lock = "0"b;

		     else goto ERROR_allocarg;

		     rsc_info.given.usage_lock = "1"b;
		     goto ESAC;

CARG (14):
CARG (15):					/* -number, -nb */
		     if names_given
		     then goto ERROR_nonb;

		     call Get_Next_Arg (argument, exists);
		     if ^exists
		     then goto ERROR_noarg;

		     on conversion
			goto ERROR_badnb;
		     if convert (num_of_rscs, argument) < 1 then goto ERROR_lownb;
		     num_of_rscs = num_of_rscs + convert (num_of_rscs, argument);
		     revert conversion;

		     number_given = "1"b;		/* For later use. */
		     goto ESAC;

CARG (16):
CARG (17):					/* -owner, -ow */
		     call Get_Next_Arg (argument, exists);
		     if ^exists
		     then goto ERROR_noarg;

		     rsc_info.owner = argument;
		     rsc_info.given.owner = "1"b;
		     goto ESAC;

CARG (18):
CARG (20):					/* -potential_access_class, -pacc */
		     call Get_Next_Arg (argument, exists);
		     if ^exists
		     then goto ERROR_noarg;

		     call convert_authorization_$from_string_range (rsc_info.potential_aim_range, (argument), code);
		     if code ^= 0
		     then goto ERROR_pacc;
		     rsc_info.given.potential_aim_range = "1"b;
		     goto ESAC;

CARG (19):
CARG (21):					/* -potential_attributes, -pattr */
		     call Get_Next_Arg (argument, exists);
		     if ^exists
		     then goto ERROR_noarg;

/*

   Convert the caller supplied attribute string, we will use rsc_info.attributes
   as temporary storage since it has the right dimensionality.  It will be cleaned
   up later.

*/

		     call cv_rcp_attributes_$from_string ((rsc_info.type), rsc_info.attributes, argument, code);
		     if code ^= 0
		     then goto ERROR_pattr;
						/*

						   Now test the second (protected attributes) string returned.  If any
						   "1" bits are present then the caller specified an "*" which is not allowed for
						   potential attributes.  Otherwise, we are only interested in the first (current
						   attributes) string.

						   */

		     if rsc_info.attributes (2)
		     then goto ERROR_prota;

/*

   Now test the attributes string to make sure it is absolute or multiple
   since that is what a potential attribute string must be.

*/

		     call cv_rcp_attributes_$test_valid ((rsc_info.type), rsc_info.attributes, attr_type, code);
		     if attr_type = 1		/* 1 is a relative attribute string. */
		     then code = error_table_$rcp_bad_attributes;

		     if code ^= 0
		     then goto ERROR_pattr;

		     rsc_info.potential_attributes = rsc_info.attributes (1);
		     rsc_info.attributes (*) = "0"b;	/* Clean up after ourselves. */
		     rsc_info.given.potential_attributes = "1"b;
		     goto ESAC;

CARG (22):
CARG (23):					/* -release_lock, -rll */
		     call Get_Next_Arg (argument, exists);
		     if ^exists
		     then goto ERROR_noarg;

		     if argument = "on"
		     then rsc_info.release_lock = "1"b;

		     else if argument = "off"
		     then rsc_info.release_lock = "0"b;

		     else goto ERROR_allocarg;

		     rsc_info.given.release_lock = "1"b;
		     goto ESAC;

CARG (24):					/* -uid */
		     call Get_Next_Arg (argument, exists);
		     if ^exists
		     then goto ERROR_noarg;

		     rsc_info.uid = bit (fixed (cv_oct_check_ ((argument), code), 36));
		     if code ^= 0
		     then goto ERROR_uid;

		     rsc_info.given.uid = "1"b;
		     goto ESAC;

ESAC:						/* End of the pseudo case statement. */
		end;				/* This is a resource description carg. */

		else goto ERROR_badarg;		/* Unrecognized argument. */

		call Get_Next_Arg (argument, exists);	/* Keep the loop going. */
	     end;					/* Loop through arguments. */

/*

   Now that everything is ok make some final checks and settings.  If
   neither the number of resources no the names of any resources have been
   specified then the default number of resources is one.  Also, if any names
   have been given then we can set the names given bit in rsc_info because
   it must be on for each item in the resource_descriptions structure.

*/

DONE:						/* Only called if reservation = "1"b and a -resource_type or -rsct argument is found. */
	     if ^names_given & ^number_given
	     then num_of_rscs = 1b;

	     rsc_info.given.name = names_given;

	end Process_Resource_Spec;

Fill_Resource_Desc:
	proc ();

	     if P_areap ^= null ()
	     then do;				/* Caller wants the structure. */
		Resource_count = num_of_rscs;

		on area
		     goto ERROR_area;
		allocate resource_descriptions in (caller_area) set (resource_desc_ptr);
		revert area;

/*

   Now set the constant information and defaults in the structure.  Do this by looping
   through the structure to set up each item.  If desired attributes are given,  they must be applied
   to the defaults in a special way.  Potential attributes are never a relative
   attribute string so defaults need not be used.  Note that n_items is already set by the
   allocation, and the type is set by setting the defaults.

*/

		do item_idx = lbound (resource_descriptions.item, 1) to hbound (resource_descriptions.item, 1) by 1;
						/* Set all items to null values. */

		     unspec (resource_descriptions.item (item_idx)) = "0"b;

		     resource_descriptions.item (item_idx).type = "";
		     resource_descriptions.item (item_idx).name = "";
		     resource_descriptions.item (item_idx).owner = "";
		     resource_descriptions.item (item_idx).acs_path = "";
		     resource_descriptions.item (item_idx).location = "";
		     resource_descriptions.item (item_idx).comment = "";
		     resource_descriptions.item (item_idx).charge_type = "";
		end;				/* Set all items to null values. */

		resource_descriptions.version_no = resource_desc_version_1;

		do item_idx = lbound (resource_descriptions.item, 1) to hbound (resource_descriptions.item, 1) by 1;
						/* Fill in each item. */

		     resource_descriptions.item (item_idx).type = rsc_info.type;

		     if rsc_info.given.uid
		     then resource_descriptions.item (item_idx).uid = rsc_info.uid;

		     if rsc_info.given.potential_attributes
		     then resource_descriptions.item (item_idx).potential_attributes = rsc_info.potential_attributes;

		     if rsc_info.given.desired_attributes
		     then do;			/* Apply these specially. */

/* Copy these for now to get them in the right form. */

			resource_descriptions.item (item_idx).attributes (1) =
			     resource_descriptions.item (item_idx).desired_attributes (1);
			resource_descriptions.item (item_idx).attributes (2) =
			     resource_descriptions.item (item_idx).desired_attributes (2);

			call cv_rcp_attributes_$modify_rel (resource_descriptions.item (item_idx).attributes (*),
			     rsc_info.desired_attributes, resource_descriptions.item (item_idx).attributes (*));

/* Now copy the results back where they belong. */

			resource_descriptions.item (item_idx).desired_attributes (1) =
			     resource_descriptions.item (item_idx).attributes (1);
			resource_descriptions.item (item_idx).desired_attributes (2) =
			     resource_descriptions.item (item_idx).attributes (2);
			resource_descriptions.item (item_idx).desired_attributes (3) = "0"b;
			resource_descriptions.item (item_idx).desired_attributes (4) = "0"b;

/* Now clean up our mess. */

			resource_descriptions.item (item_idx).attributes (*) = "0"b;
		     end;				/* Apply these specially. */

		     if rsc_info.given.potential_aim_range
		     then resource_descriptions.item (item_idx).potential_aim_range (*) =
			rsc_info.potential_aim_range (*);

		     if rsc_info.given.aim_range
		     then resource_descriptions.item (item_idx).aim_range (*) = rsc_info.aim_range (*);

		     if rsc_info.given.owner
		     then resource_descriptions.item (item_idx).owner = rsc_info.owner;

		     if rsc_info.given.acs_path
		     then resource_descriptions.item (item_idx).acs_path = rsc_info.acs_path;

		     if rsc_info.given.location
		     then resource_descriptions.item (item_idx).location = rsc_info.location;

		     if rsc_info.given.comment
		     then resource_descriptions.item (item_idx).comment = rsc_info.comment;

		     if rsc_info.given.charge_type
		     then resource_descriptions.item (item_idx).charge_type = rsc_info.charge_type;

		     if rsc_info.given.usage_lock
		     then resource_descriptions.item (item_idx).usage_lock = rsc_info.usage_lock;

		     if rsc_info.given.release_lock
		     then resource_descriptions.item (item_idx).release_lock = rsc_info.release_lock;

		     if rsc_info.given.user_alloc
		     then resource_descriptions.item (item_idx).user_alloc = rsc_info.user_alloc;

/*
   For now we will copy the given bits, although they really should be or'ed
   with the ones set by the defaults.  Also, we will always set the desired
   attributes bit on so that rcp_reserve_ can use the defaults.
*/

		     resource_descriptions.item (item_idx).given = rsc_info.given;

		     if names_given
		     then do;			/* Fill in the name. */
			call Get_Name (argument, exists);
			if ^exists
			then goto ERROR_badone;

			resource_descriptions.item (item_idx).name = argument;
			resource_descriptions.item (item_idx).given.name = "1"b;
		     end;				/* Fill in the name. */

		     else resource_descriptions.item (item_idx).name = "";

		     if apply_defaults then do;
			call resource_info_$defaults ((rsc_info.type), "", resource_desc_ptr, item_idx, code);
			if code ^= 0
			then goto ERROR_defaults;
		     end;

		end;				/* Fill in each item. */
	     end;					/* Caller wants the structure. */

	end Fill_Resource_Desc;

Get_Next_Arg:
	proc (P_arg, P_arg_exists);

dcl (
     P_arg char (*) varying,				/* Output -- the argument found. */
     P_arg_exists bit (1)				/* Output -- there was an argument to find. */
     ) parameter;

/*

   D_E_S_C_R_I_P_T_I_O_N_

   This internal procedure does everything necessary to obtain the next
   argument, either from the command line or an input array of character strings.
   Certain variables are declared globally in the main program which should be
   "own" variables for this procedure because of a deficiency in Multics PL1.

*/

/* Local Variables */

dcl  based_arg char (arg_len) based (arg_ptr);
dcl  arg_len fixed bin;
dcl  arg_ptr ptr;

	     arg_idx = arg_idx + 1;			/* We want the next one. */

	     if arg_idx > nargs
	     then do;				/* No more args. */
		arg_idx = arg_idx - 1;		/* Always point at a good argument, or 0. */
		P_arg_exists = "0"b;
						/* P_arg is left alone for error processing if necessary. */
	     end;					/* No more args. */

	     else do;				/* Get the next arg. */
		if reservation
		then do;				/* Argument in array. */
		     P_arg = P_inargs (arg_idx);
		     P_arg_exists = "1"b;
		end;				/* Argument in array. */

		else do;				/* Argument in command line. */
		     call cu_$arg_ptr_rel (arg_idx, arg_ptr, arg_len, code, P_clinep);
		     if code ^= 0
		     then goto ERROR_exterr;

		     if arg_len > maxlength (P_arg)
		     then ;			/* May want to log this sometime. */

		     P_arg = based_arg;
		     P_arg_exists = "1"b;
		end;				/* Argument in command line. */
	     end;					/* Get the next arg. */

	end Get_Next_Arg;

Save_Name:
	proc (P_name);

dcl  P_name char (*) varying parameter;
						/* Input  -- name to save. */

/*

   D_E_S_C_R_I_P_T_I_O_N_

   This internal subroutine saves character string arguments which are passed to it.
   It does so by allocating stroage and building a LIFO list of names.  Note that
   name_stack_ptr and name_tail_ptr are initialized in the main program to "null".

*/

/* Local Variables */

dcl  name_len fixed bin;				/* Length of the name to store. */
dcl  nip ptr;					/* Name item pointer. */
dcl 1 name_item aligned based,
    2 len fixed bin,
    2 name char (name_len refer (name_item.len)),
    2 next ptr;

	     name_len = length (P_name);

	     on area
		goto ERROR_area;
	     allocate name_item set (nip);
	     revert area;

	     nip -> name_item.name = P_name;
	     nip -> name_item.next = null ();

	     if name_stack_ptr = null ()
	     then name_stack_ptr = nip;		/* Only done the first time. */

	     if name_tail_ptr ^= null ()
	     then name_tail_ptr -> name_item.next = nip;

	     name_tail_ptr = nip;

	end Save_Name;

Get_Name:
	proc (P_name, P_name_exists);

dcl (
     P_name char (*) varying,				/* Output -- the next name in the list. */
     P_name_exists bit (1)				/* Output -- whether or not there is a name. */
     ) parameter;

/*

   D_E_S_C_R_I_P_T_I_O_N_

   This internal subroutine gets the next name from the LIFO list built by
   Save_Name.  It frees the list as it goes.  It also sets a flag to indicate
   whether or not a name was found.

*/

/* Local Variables */

dcl  nip ptr;					/* Name item pointer. */
dcl 1 name_item aligned based,
    2 len fixed bin,
    2 name char (0b refer (name_item.len)),
    2 next ptr;

	     if name_stack_ptr = null ()
	     then do;
		P_name = "";
		P_name_exists = "0"b;
	     end;

	     else do;
		nip = name_stack_ptr;
		P_name = nip -> name_item.name;
		P_name_exists = "1"b;
		name_stack_ptr = nip -> name_item.next;
		free nip -> name_item;
	     end;

	end Get_Name;

Save_Pointer:
	proc (P_ptr);

dcl  P_ptr ptr parameter;				/* Input  -- the pointer to be saved. */

/* Local Variables */

dcl  rip ptr;
dcl 1 rdp_item aligned based,
    2 next ptr,
    2 data ptr;

	     on area
		goto ERROR_area;
	     allocate rdp_item set (rip);
	     revert area;

	     rip -> rdp_item.data = P_ptr;
	     rip -> rdp_item.next = null ();

	     if rdp_stack_ptr = null ()
	     then rdp_stack_ptr = rip;		/* Only done the first time. */

	     if rdp_tail_ptr ^= null ()
	     then rdp_tail_ptr -> rdp_item.next = rip;

	     rdp_tail_ptr = rip;

	end Save_Pointer;

Get_Pointer:
	proc (P_ptr);

dcl  P_ptr ptr parameter;				/* Output -- the next pointer in the list. */

/* Local Variables */

dcl  rip ptr;
dcl 1 rdp_item aligned based,
    2 next ptr,
    2 data ptr;

	     if rdp_stack_ptr = null ()
	     then P_ptr = null ();

	     else do;
		rip = rdp_stack_ptr;
		P_ptr = rip -> rdp_item.data;
		rdp_stack_ptr = rip -> rdp_item.next;
		free rip -> rdp_item;
	     end;

	end Get_Pointer;

Is_Acarg:
	proc (P_arg, P_idx) returns (bit (1));

dcl (
     P_arg char (*) varying,				/* Input  -- argument to check. */
     P_idx fixed bin				/* Output -- index in caller supplied array. */
     ) parameter;

/*

   D_E_S_C_R_I_P_T_I_O_N_

   This internal subroutine checks th input argument against a caller
   supplied array of additional control argument names.  The index in the caller
   supplied array is returned as well as an indication as to whether or not a match
   was found.
   At some time we may wany to require that the input array be alphabetical
   and do a binary search.

*/

/* Local Variables */

dcl  idx fixed bin;
dcl  found bit (1);
dcl  num_args fixed bin;

	     if P_cargp = null | P_cargidx = null ()
	     then do;				/* No array given. */
		P_idx = 0;
		found = "0"b;
	     end;					/* No array given. */

	     else do;				/* Array given. */
		num_args = P_cargp -> acargs.number;

		do idx = 1 to num_args
			while (P_arg ^= P_cargp -> acargs.arg (idx).long_name
			& P_arg ^= P_cargp -> acargs.arg (idx).short_name);
		end;

		if idx > num_args
		then do;				/* Did not find it. */
		     P_idx = 0;
		     found = "0"b;
		end;				/* Did not find it. */

		else do;				/* Found it. */
		     P_idx = idx;
		     found = "1"b;
		end;				/* Found it. */
	     end;					/* Array given. */

	     return (found);

	end Is_Acarg;

Is_Carg:
	proc (P_arg, P_idx) returns (bit (1));

dcl (
     P_arg char (*) varying,				/* Input  -- argument to check. */
     P_idx fixed bin				/* Output -- index into the known cargs. */
     ) parameter;

/*

   D_E_S_C_R_I_P_T_I_O_N_

   This internal subroutine checks the input argument against the known list
   of resource description control arguments.  The index in this list is returned
   as well as an indication of whether or not a match was found in the list.
   A binary search will be used so the list of control arguments must always
   be alphabetical.  Notice that by definition of arrays, lbound, and hbound that
   the loop is executed at least once.

*/

/* Local Variables */

dcl  lb fixed bin;					/* Lower bound. */
dcl  mp fixed bin;					/* Midpoint. */
dcl  ub fixed bin;					/* Upper bound. */

	     lb = lbound (C_rd_cargs, 1);		/* Lower bound for the search. */
	     ub = hbound (C_rd_cargs, 1);		/* Upper bound for the search. */

	     do while (lb <= ub);
		mp = divide (lb + ub, 2, 17);		/* Midpoint for the search. */

		if P_arg = C_rd_cargs (mp)
		then do;
		     P_idx = mp;			/* Found. */
		     return ("1"b);
		end;

		if P_arg < C_rd_cargs (mp)
		then ub = mp - 1;
		else lb = mp + 1;
	     end;

	     P_idx = 0;				/* Not found. */
	     return ("0"b);

	end Is_Carg;

Cleanup_Handler:
	proc ();

/*

   D_E_S_C_R_I_P_T_I_O_N_

   This internal procedure cleans up before returning to the caller.
   Essentially, this just means checking for any storage which may have been
   allocated and freeing it if necessary.  It is not called if the program
   terminates normally.
   Any error codes or conditions produced by this subroutine will either be
   handled immediately or ignored as appropriate.

*/

dcl  nip ptr;					/* Name item pointer. */
dcl 1 name_item aligned based,
    2 len fixed bin,
    2 name char (0b refer (name_item.len)),
    2 next ptr;

dcl  rip ptr;					/* Rdp item pointer. */
dcl 1 rdp_item aligned based,
    2 next ptr,
    2 data ptr;

dcl  rdp ptr;


	     if resource_desc_ptr ^= null ()
	     then free resource_descriptions in (caller_area);

	     if resource_res_ptr ^= null ()
	     then free reservation_description in (caller_area);

	     do while (name_stack_ptr ^= null ());
		nip = name_stack_ptr;
		name_stack_ptr = nip -> name_item.next;
		free nip -> name_item;
	     end;

	     do while (rdp_stack_ptr ^= null ());
		rip = rdp_stack_ptr;
		rdp_stack_ptr = rip -> rdp_item.next;
		rdp = rip -> rdp_item.data;
		if rdp ^= null ()
		then free rdp -> resource_descriptions in (caller_area);
		free rip -> rdp_item;
	     end;

/* Set the output parameters except for the error message and code. */

	     if reservation
	     then P_resp = null ();
	     P_rscp = null ();
	     if P_cargidx ^= null () & P_cargp ^= null ()
	     then acarg_indicies = 0b;		/* An array assignment. */

	end Cleanup_Handler;

     end build_resource_desc_;
