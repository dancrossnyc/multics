/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(86-03-05,LJAdams), approve(86-03-05,MCR7327),
     audit(86-04-17,Lippard), install(86-04-24,MR12.0-1048):
     Changed routines to use line parsing.
  2) change(86-05-08,LJAdams), approve(86-05-14,MCR7416),
     audit(86-06-06,Gilcrease), install(86-06-12,MR12.0-1074):
     Changed sort so that the ep identifier is included.  This is so that
     separate infos are maintained for each entry_point is given on the
     command line.
  3) change(86-09-04,LJAdams), approve(86-09-04,MCR7506),
     audit(86-10-29,GDixon), install(86-10-30,MR12.0-1203):
     Moved error messages for no match on srh/section and entry point not
     found here to avoid printing duplicate error messages per info seg
     found in search path.
  4) change(87-01-20,LJAdams), approve(87-09-03,MCR7766),
     audit(88-08-14,GDixon), install(88-09-13,MR12.2-1109):
     Changed to version Vhelp_args_3.
  5) change(88-02-17,LJAdams), approve(88-03-07,MCR7857),
     audit(88-08-14,GDixon), install(88-09-13,MR12.2-1109):
     Changed to check the help_args.help_data_ptr to determine if it is a
     list_request operation.  This is because when checking the validity of
     names the lr operation must allow the (. .. ?) symbols.
  6) change(88-03-14,LJAdams), approve(88-06-01,MCR7873),
     audit(88-08-14,GDixon), install(88-09-13,MR12.2-1109):
     Changed VPDinfo_seg_1 to VPDinfo_seg_2.  Changed sort to eliminate
     duplicates from sorting 360 bits to sorting 396 bits. (phx21111)
                                                   END HISTORY COMMENTS */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* Name:  help_								*/
/*									*/
/* This subroutine implements the help command.  It performs the following functions.	*/
/*									*/
/* 1) Finds info segments.							*/
/* 2) Selects particular infos within multi-info segments.				*/
/* 3) Sorts the list of infos to be processed.					*/
/* 4) Processes each info, implementing all help control arguments and query responses.	*/
/*									*/
/* The subroutine may also be used to implement a help-style information facility in	*/
/* other subsystems.  Information segments (with an info suffix or another suffix) are	*/
/* selected and printed, based upon information given primarily in a help_args structure,	*/
/* which is declared in help_args_.incl.pl1.					*/
/*									*/
/* Usage									*/
/*									*/
/* The help_ subroutine must be invoked by a sequence of calls.			*/
/*									*/
/* 1) call help_$init to get temp segment containing help_args structure and stores the 	*/
/*    current info_segments search rules in the structure.				*/
/* 2) call help_ one or more times to select and print info segments                      */
/* 3) call help_$term to release the temp segment.				*/
/*									*/
/* Entry:  help_$check_info_segs						*/
/*									*/
/* This subroutine generates the list of info segments to be processed by the 		*/
/* check_info_segs command.  It finds info segments modified since a given date, sorts	*/
/* the list and returns it for check_info_segs to process.				*/
/*									*/
/* Usage									*/
/*									*/
/* 1) call help_$init to get temp segment containing help_args and the output list.	*/
/* 2) call help_$check_info_segs to build and sort the list of segments to be processed.	*/
/* 3) call help_$term to release the temp segment.				*/
/*									*/

/* Status									*/
/*									*/
/* 0) Created:   November, 1969   by T. H. VanVleck				*/
/* 1) Modified:  February, 1975   by T. H. VanVleck - complete rewrite		*/
/* 2) Modified:  September,1976   by Steve Herbst - accept -pathname ctl_arg		*/
/* 3) Modified:  June, 1977	    by Paul Green - diagnose zero-length info segs	*/
/* 4) Modified:  October, 1978    by Gary Dixon - complete rewrite; split into help	*/
/*				command and separate help_ subroutine.		*/
/*				Add support for check_info_segs.		*/
/* 5) Modified:  April, 1985      by L. Adams - rewrote parsing routines to use line logic*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

/* format: style2,ind2,ll131,dclind4,idind15,comcol41,linecom,ifthen */
help_:	
  procedure (procedure_name, Phelp_args, suffix, progress, Acode);

    dcl				/*	Parameters			*/
        procedure_name char (*),	/* Caller of help_ and help_$init.		*/
				/*   1) Owns temp segment help_args are stored in.*/
				/*   2) Name used in error messages.		*/
/*      Phelp_args	   ptr, */          /* ptr to argument struc at base of temp seg.	*/
				/* This is really declared in include seg.	*/
        suffix	   char (*),	/* Suffix on segs to be processed. Normally "info"*/
				/* but may be some other suffix or "" to omit	*/
				/* suffix processing.			*/
        progress	   fixed bin,	/* =1: bad help_args version			*/
				/* =2: no pathnames given.			*/
				/* =3: evaluating pathnames.			*/
				/* =4: finding help segs.			*/
				/* =5: -section/-search & printing help segs.	*/
        Acode	   fixed bin (35),	/* Return code.				*/
        APPDinfo_seg   ptr;		/* Ptr to output structures returned by		*/
				/* help_$check_info_segs			*/

    dcl Lseg	   fixed bin (21),	/* Length of info.				*/
        Ninfos_printed fixed bin,	/* Number of infos for which something has printed*/
        Nlast_info_cross_ref
		   fixed bin,	/* Last info with Scross_ref on.		*/
        Nlast_info_no_brief_data
		   fixed bin,	/* Last info not containing Syntax section,	*/
				/* which get_brief_data encountered.		*/
        PI_LABEL	   label variable,
        PDeps	   ptr,
        PDinfo	   ptr,
        Pinit_assoc_mem
		   ptr,
        Pnext_free_space
		   ptr,		/* ptr to next free word location in temp	*/
				/*   seg containing help_args.		*/
        Pquery_answers ptr,		/* ptr to formatted list of help responses.	*/
        Pseg	   ptr,
        Ptemp	   ptr,
        Sprint_inhibit bit (1) aligned, /* on if printing stopped by program_interrupt.	*/
        Sstandalone_invocation
		   bit (1),
        cleanup	   condition,
        code	   fixed bin (35),
        fcn	   fixed bin,	/* Function to be performed by this invocation.	*/
        (
        HELP	   init (0),	/*   help_				*/
        CIS	   init (1)
        )				/*   check_info_segs			*/
		   fixed bin int static options (constant),
        (i, j)	   fixed bin,
        offset	   fixed bin (35),
        program_interrupt
		   condition;

    dcl 1 Dinfo	   aligned based (PDinfo),
	2 N	   fixed bin,
	2 seg	   (0 refer (Dinfo.N)) like Dinfo_seg;
				/* Information about each log. info to be printed.*/

    dcl 1 init_assoc_mem
		   aligned based (Pinit_assoc_mem),
				/* Associative memory in which initiated segments	*/
	2 N	   fixed bin,	/* are stored.				*/
	2 seg	   (50),		/* Allow up to 50 initiated segments at once.	*/
	  3 dir	   char (168) unal,
	  3 ent	   char (32) unal,
	  3 uid	   bit (36),
	  3 pad	   fixed bin,
	  3 P	   ptr;

    dcl 1 LIST	   aligned based,	/* structure used to format list of things to be	*/
	2 header,			/* output in columns.			*/
	  3 N	   fixed bin,	/*   number of list elements.			*/
	  3 Nreal	   fixed bin,	/*   number of filled list elements.		*/
	  3 Npghs	   fixed bin,	/*   number of filled paragraphs of formatted out.*/
	  3 Nrows	   fixed bin,	/*   number of rows in formatted output.	*/
	  3 Ncols	   fixed bin,	/*   number of columns in formatted output.	*/
	  3 ML	   (6) fixed bin,	/*   length of longest element in each column.	*/
	  3 title	   char (80) varying,
				/*   title of output list.			*/
	  3 Iunit	   fixed bin,	/*   unit no of pgh containing list elements.	*/
	2 group	   (0 refer (LIST.N)),
	  3 arg	   char (88) varying,
				/*   the argument.				*/
	  3 Snot_found
		   fixed bin;	/*   = 1 if no match found for the argument.	*/

    dcl 1 query_answers
		   aligned based (Pquery_answers),
	2 header	   like LIST.header,
	2 group	   (0 refer (query_answers.N)) like LIST.group;

    dcl responses	   (25) char (50) var int static options (constant) init (" yes, y",
				/* List of allowed responses to questions asked	*/
				/*   by help_.				*/
		   " rest {-scn} {-all_entrypoints} {-entrypoints}", 
                       "    r {-scn} {-aep} {-ep}",
                       " no, n",
                       " quit, q",
                       " top, t",
                       " header, he",
		   " title {-top}",
                       " section {STRs} {-case_sensitive} {-top},", 
                       "    scn  {STRs} {-cs} {-top}",
		   " search  {STRs} {-case_sensitive} {-top},", 
                       "    srh  {STRs} {-cs} {-top}",
		   " skip {-scn} {-seen} {-rest} {-ep},",
                       "    s {-scn} {-seen} {-rest} {-ep}",
                       " brief, bf",
		   " control_arg STRs, ca STRs",
                       " entry_point {EP_NAME},",
                       "    ep {EP_NAME}",
                       " list_entry_points",
		   "    lep",
                       " list_requests,",
                       "    lr",
                       " ?",
                       " .",
                       " ..");

    dcl bit36	   bit (36) aligned based,
        bit360	   bit (360) aligned based;
  
    dcl (addr, addrel, binary, char, currentsize, dim, dimension, divide, empty, hbound, index, lbound, length, ltrim, mod,
        null, ptr, rel, reverse, rtrim, search, string, substr, unspec, verify)
		   builtin;


    dcl com_err_	   entry options (variable),
        convert_date_to_binary_
		   entry (char (*), fixed bin (71), fixed bin (35)),
        get_temp_segment_
		   entry (char (*), ptr, fixed bin (35)),
        hcs_$get_uid_seg
		   entry (ptr, bit (36) aligned, fixed bin (35)),
        hcs_$initiate  entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35)),
        hcs_$terminate_noname
		   entry (ptr, fixed bin (35)),
        hcs_$truncate_seg
		   entry (ptr, fixed bin, fixed bin (35)),
        help_rql_	   entry (char(*), char(*), ptr, fixed bin, fixed bin, fixed bin(24),
				     fixed bin, fixed bin, ptr, ptr, ptr, ptr, label, bit(1) aligned,
				     fixed bin(35)),
        match_star_name_
		   entry (char (*), char (*), fixed bin (35)),
        pathname_$component
		   entry (char (*), char (*), char (*)) returns (char (194)),
        release_temp_segment_
		   entry (char (*), ptr, fixed bin (35)),
        search_paths_$get
		   entry (char (*), bit (36), char (*), ptr, ptr, fixed bin, ptr, fixed bin (35)),
        (
        sort_items_$bit,
        sort_items_$char
        )		   entry (ptr, fixed bin),
        ssu_$destroy_invocation
		   entry (ptr),
        ssu_$print_message
		   entry () options (variable),
        ssu_$standalone_invocation
		   entry (ptr, char (*), char (*), ptr, entry, fixed bin (35));

    dcl (
        FALSE	   init ("0"b),
        TRUE	   init ("1"b)
        )		   bit (1) int static options (constant),
        HT_SP	   char (2) init ("	 ") int static options (constant),
				/* Horizontal-tab followed by space.		*/
        NL	   char (1) int static options (constant) init ("
"),
        (
        error_table_$badsyntax,
        error_table_$inconsistent,
        error_table_$incorrect_access,
        error_table_$moderr,
        error_table_$no_s_permission,
        error_table_$noarg,
        error_table_$noentry,
        error_table_$no_info,
        error_table_$nomatch,
        error_table_$unimplemented_version,
        error_table_$zero_length_seg
        )		   fixed bin (35) ext static;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

    fcn = HELP;			/* Perform a help function.			*/
    go to COMMON;


check_info_segs:
  entry (procedure_name, Phelp_args, suffix, progress, Acode, APPDinfo_seg);

    fcn = CIS;			/* Perform a check_info_segs function.		*/

COMMON:

    progress = 1;

    if help_args.version = 1 | help_args.version = 2 then
      do;				/* Version 1 and version 2 are upwards-compatible with 3.	*/
        help_args.version = Vhelp_args_3;
        help_args.sci_ptr = null;
        help_args.Sctl.inhibit_errors = FALSE;
      end;
    if help_args.version ^= Vhelp_args_3 then
      do;				/* Validate structure version.		*/
        Acode = error_table_$unimplemented_version;
        return;
      end;

    progress = 2;
    if help_args.Npaths ^> 0 then
      do;				/* Make sure info file names were given.	*/
        Acode = error_table_$noarg;
        return;
      end;
    Acode = 0;
    progress = 3;
    do i = 1 to help_args.Npaths;	/* validate input paths.			*/
      call evaluate_path (help_args.path (i), suffix);
      if Acode = 0 then
        Acode = help_args.path.code (i);
    end;
    if Acode ^= 0 then
      return;

    progress = 4;
    call get_temp_segment_ (procedure_name, Pquery_answers, Acode);
    if Acode ^= 0 then
      return;			/* Get space for format list of help responses.	*/
				/* Problem with size of query answers overlaping	*/
				/* next list so put it in a separate temp seg	*/
    query_answers.N = 2 * hbound (responses, 1);
				/* Copy allowed responses into the list.	*/
    query_answers.Nreal = query_answers.N;
    query_answers.Nrows = 0;		/* This indicates that list isn't formatted yet.	*/
    query_answers.title = "List of Responses";
    do i = lbound (responses, 1) to hbound (responses, 1);
      query_answers.group (i).arg = responses (i);
    end;
    do i = i to query_answers.N;	/* Struc must be two * size of response array	*/
      query_answers.group (i).arg = ""; /*   to allow for extension during formatting.	*/
    end;				/*   Set added elements to null strings.	*/

    Pinit_assoc_mem, Pnext_free_space = set_space_used (Phelp_args, currentsize (help_args));
				/* Get space in temp seg for associative memory	*/
				/* used to reduce calls to hcs_$initiate.	*/
    Sstandalone_invocation = FALSE;
    init_assoc_mem.N = 0;
    on cleanup call janitor ();	/* Establish cleanup on unit.			*/

    PDinfo, Pnext_free_space = set_space_used (Pnext_free_space, currentsize (init_assoc_mem));
    Dinfo.N = 0;			/* Obtain space for list of info segs to be read.	*/
    do i = 1 to help_args.Npaths;	/* Convert input paths to list of info segs.	*/
      if help_args.path (i).S.less_greater then
        call get_info_seg_list (procedure_name, suffix, fcn, help_args.path (i).dir (*), help_args.path (i), PDinfo);
      else call get_info_seg_list (procedure_name, suffix, fcn, help_args.search_dirs (*), help_args.path (i), PDinfo);
    end;
    if Dinfo.N <= 0 then
      do;				/* Stop if no matching segs found.		*/
        Acode = error_table_$nomatch;	/*   get_info_seg_list has already complained.	*/
        call janitor ();
        return;
      end;

    progress = 5;			/* Infos selected by starname.  Any other errors	*/
				/* reported via Acode describe info selection by	*/
				/* -search and -seciton criteria.		*/
    PPDinfo_seg, Pnext_free_space = set_space_used (Pnext_free_space, currentsize (Dinfo));
    PDinfo_seg.version = VPDinfo_seg_2;
    PDinfo_seg.N = Dinfo.N;
    do i = 1 to Dinfo.N;		/* Sort listed infos thrice:			*/
      PDinfo_seg.P (i) = addr (Dinfo.seg (i).uid);
      Dinfo.seg (i).X = i;		/*   1st:  sort on  Dinfo.seg.uid/.I/.E combo     */
    end;				/* 	 to eliminate duplicate infos.	*/
				/*   2nd:  sort on Dinfo.seg.ent to identify	*/
				/* 	 versions of info seg in different dirs.*/
    if Dinfo.N > 1 then
      do;				/*   3rd:  sort on Dinfo.seg.Scross_ref/dir/.ent	*/
        call sort_items_$bit (addr (PDinfo_seg.N), 396);
				/*	 combination to alphabetize output.	*/
        offset = binary (rel (addr (Dinfo.seg (1).ent))) - binary (rel (addr (Dinfo.seg (1).uid)));
				/* Compute negative offset to adjust ptrs to	*/
				/* Dinfo.seg.uid to point back to Dinfo.seg.ent.	*/

        do i = 1 to Dinfo.N while (PDinfo_seg.P (i) -> bit360 = "0"b);
	PDinfo_seg.P (i) = addrel (PDinfo_seg.P (i), offset);
        end;			/* Allow duplicate .uid/.I combos for infos	*/
				/* in which errors were encountered.  These errors*/
				/* must be reported.  get_info_seg_list has set	*/
				/* .uid/.I combo to "0"b in these cases.	*/
        j = i - 1;
        if i > Dinfo.N then		/* if all info segs are in error, skip the	*/
	go to SKIP_ELIMINATION;	/* elimination of duplicates.			*/
        go to CHECK (fcn);


CHECK (0):
        do i = i to Dinfo.N - 1;	/* Eliminate duplicate .uid/.I combos.		*/
	if PDinfo_seg.P (i) -> bit360 ^= PDinfo_seg.P (i + 1) -> bit360 then
	  do;
	    j = j + 1;		/*   (Only retain unique .uid/.I combos.)	*/
	    PDinfo_seg.P (j) = addrel (PDinfo_seg.P (i), offset);
	  end;
	else PDinfo_seg.P (i + 1) = PDinfo_seg.P (i);
				/*   (Retain info found earliest in search rules).*/
        end;
        go to END_CHECK;

CHECK (1):
        do i = i to Dinfo.N - 1;	/* Eliminate duplicate .uid combos.		*/
	if PDinfo_seg.P (i) -> bit36 ^= PDinfo_seg.P (i + 1) -> bit36 then
	  do;
	    j = j + 1;		/*   (Only retain unique .uid combos.)		*/
	    PDinfo_seg.P (j) = addrel (PDinfo_seg.P (i), offset);
	  end;
	else PDinfo_seg.P (i + 1) = PDinfo_seg.P (i);
				/*   (Retain info found earliest in search rules).*/
        end;

END_CHECK:
        j = j + 1;			/*   (Always retain the last entry in the list.)	*/
        PDinfo_seg.P (j) = addrel (PDinfo_seg.P (i), offset);
        PDinfo_seg.N = j;
      end;
    else PDinfo_seg.P (1) = addr (Dinfo.seg (1).ent);

SKIP_ELIMINATION:
    if PDinfo_seg.N > 1 then
      do;				/* Sort alphabetically by ent to identify info 	*/
        call sort_items_$char (addr (PDinfo_seg.N), 32);
				/* segments appearing in more than one search dir.*/
        offset = binary (rel (addr (Dinfo.seg (1).Scross_ref))) - binary (rel (addr (Dinfo.seg (1).ent)));
				/* Compute negative offset to adjust ptrs from	*/
				/* Dinfo.seg.ent to point to Dinfo.seg.Scross_ref.*/
        PDinfo_seg.P (1) = addrel (PDinfo_seg.P (1), offset);
        do i = 1 to Dinfo.N - 1;	/* Check for entry of same name in different dirs.*/
	PDinfo_seg.P (i + 1) = addrel (PDinfo_seg.P (i + 1), offset);
	if PDinfo_seg.P (i) -> Dinfo_seg.ent = PDinfo_seg.P (i + 1) -> Dinfo_seg.ent
	     & PDinfo_seg.P (i) -> Dinfo_seg.uid ^= PDinfo_seg.P (i + 1) -> Dinfo_seg.uid
	     & PDinfo_seg.P (i) -> Dinfo_seg.uid ^= "0"b & "0"b ^= PDinfo_seg.P (i + 1) -> Dinfo_seg.uid then
	  do;
	    if binary (rel (PDinfo_seg.P (i)), 18) < binary (rel (PDinfo_seg.P (i + 1)), 18) then
	      do;
	        Ptemp = PDinfo_seg.P (i);
				/* Mark all but entry found earliest in search	*/
	        PDinfo_seg.P (i) = PDinfo_seg.P (i + 1);
	        PDinfo_seg.P (i + 1) = Ptemp;
				/* rules with a cross reference flag.		*/
	      end;
	    PDinfo_seg.P (i) -> Dinfo_seg.Scross_ref = TRUE;
	  end;
        end;
      end;
    else PDinfo_seg.P (1) = addr (Dinfo.seg (1).Scross_ref);

    if PDinfo_seg.N > 1 then		/* Sort alphabetically by Scross_ref/dir/ent combo*/
      call sort_items_$char (addr (PDinfo_seg.N), 204);
				/* 4 + 168 + 32                                   */
    if fcn = CIS then
      do;
        call term_assoc_mem ();
        APPDinfo_seg = PPDinfo_seg;
        return;
      end;

    PDeps, Pnext_free_space = set_space_used (Pnext_free_space, currentsize (PDinfo_seg));
				/* Get space for entry point info descriptors.	*/
    Nlast_info_no_brief_data = -1;	/* No info processed yet.			*/
    Nlast_info_cross_ref = -1;

    PI_LABEL = PROCESS;		/* Establish pi handler.			*/
    on program_interrupt
      begin;
        Sprint_inhibit = TRUE;
        go to PI_LABEL;
      end;

PROCESS:
    Ninfos_printed = 0;
    code = 0;

    do i = 1 to PDinfo_seg.N while (code = 0);
				/* Process each listed info in alphabetical order.*/
      PI_LABEL = NEXT_INFO;
      PDinfo_seg_ = PDinfo_seg.P (i);
      if Dinfo_seg_.code ^= 0 then
        do;			/* Print any error encountered while finding seg.	*/
INIT_ERROR:
	call error (help_args.sci_ptr, Dinfo_seg_.code, "For ^[link^;segment^;directory^]: ^a^[>^]^a^[
Looking for an info matching ^a^].", binary (Dinfo_seg_.segment_type, 2) + 1, Dinfo_seg_.dir, Dinfo_seg_.dir ^= ">",
	     Dinfo_seg_.ent, (Dinfo_seg_.info_name ^= ""), Dinfo_seg_.info_name);
	go to NEXT_INFO;
        end;
      call initiate (Dinfo_seg_.dir, Dinfo_seg_.ent, Dinfo_seg_.uid, Pseg, code);
      if Pseg = null then
        go to INIT_ERROR;		/* Initiate the info segment.			*/
      Lseg = Dinfo_seg_.L;		/* Address all/only log info we are printing.	*/
      if Lseg = 0 then
        do;
	code = error_table_$zero_length_seg;
	go to INIT_ERROR;
        end;

      call help_rql_ (procedure_name, suffix, Phelp_args, i, Ninfos_printed, PDinfo_seg.N, Nlast_info_no_brief_data,
	 Nlast_info_cross_ref, PDinfo_seg_, Pseg, PDeps, Pquery_answers, PI_LABEL, Sprint_inhibit, code);
      if ^help_args.Sctl.inhibit_errors & code = error_table_$noentry then
        call error (help_args.sci_ptr, code, "^/Looking for entry point ^a in^/^5x^a", Dinfo_seg_.ep,
	   pathname_$component (Dinfo_seg_.dir, Dinfo_seg_.ent, ""));

NEXT_INFO:
    end;
EXIT_LOOP:
    if Ninfos_printed = 0 then	/* -section and -search didn't find any match.	*/
      Acode = error_table_$nomatch;
QUIT:
    call janitor ();
    return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


abort_help_subr:
  procedure;

    go to QUIT;

  end abort_help_subr;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


error:
  procedure options (variable);

    dcl code	   fixed bin(35);
    dcl cu_$arg_list_ptr
		   entry returns (ptr),
        cu_$generate_call
		   entry (entry, ptr);
    dcl EMPTY_ARG_LIST fixed bin(71) int static options(constant) init(0);

    if help_args.Sctl.inhibit_errors then
        return;

    if help_args.sci_ptr = null then
        do;
        Sstandalone_invocation = TRUE;
        call ssu_$standalone_invocation (help_args.sci_ptr, procedure_name, ltrim (char (Vhelp_args_3)),
	   addr(EMPTY_ARG_LIST), abort_help_subr, code);
        if code ^= 0 then
	call com_err_ (code, procedure_name, "Calling ssu_$standalone_invocation.");
        end;

    if help_args.sci_ptr ^= null then
        call cu_$generate_call (ssu_$print_message, cu_$arg_list_ptr ());

  end error;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


evaluate_path:
  procedure (info_path, suffix);

    dcl 1 info_path	   aligned like help_args.path,
        suffix	   char (*);

    dcl i		   fixed bin;

    dcl check_star_name_$entry
		   entry (char (*), fixed bin (35)),
        expand_pathname_$add_suffix
		   entry (char (*), char (*), char (*), char (*), fixed bin (35));

    info_path.dir (1) = "";		/* Initialize to unset so caller can depend on	*/
    info_path.ent = "";		/* these values.				*/
    info_path.ep = "";
    info_path.S.less_greater = (search (info_path.value, "<>") > 0);
				/* see if user gave more than just an entryname.	*/
    i = index (reverse (info_path.value), "$");
				/* see if user gave a subr entry point name.	*/
    if info_path.S.less_greater then	/*   Must allow $ in entry names forming dir	*/
				/*   part of pathname.			*/
      if search (reverse (info_path.value), "<>") < i then
        i = 0;
    if i > 0 then			/* save entry point name given by user in his	*/
      info_path.ep = substr (info_path.value, length (info_path.value) - i + 2);
    else info_path.ep = "";		/*   pathname argument.			*/
    call expand_pathname_$add_suffix (substr (info_path.value, 1, length (info_path.value) - i), suffix, info_path.dir (1),
         info_path.ent, info_path.code);
    if info_path.code ^= 0 then	/* separate pathname into dir/ent parts, add info	*/
      return;			/*   suffix.				*/
    if info_path.S.pn_ctl_arg then	/* if -pn given, assume relative pathname follows	*/
      info_path.S.less_greater = TRUE;	/*   (Note we've already expanded path on this	*/
				/*    assumption.)				*/
    if info_path.info_name = "" then
      do;
        info_path.S.separate_info_name = FALSE;
				/* info_name usually = entryname w/o suffix.	*/
        if suffix = "" then
	info_path.info_name = info_path.ent;
        else info_path.info_name =
	        substr (info_path.ent, 1, 32 - length (suffix) - index (reverse (info_path.ent), reverse (suffix) || "."));
      end;
    else info_path.S.separate_info_name = TRUE;
    call check_star_name_$entry (info_path.ent, info_path.code);
    if info_path.code = 0 then
      do;				/* if no starname given, -ep ctl arg allowed.	*/
        info_path.S.starname_ent = FALSE;
        if help_args.Sctl.ep & info_path.ep = "" then
				/* Default ep name = entryname w/o suffix.	*/
	if suffix = "" then
	  info_path.ep = info_path.ent;
	else info_path.ep =
	  substr (info_path.ent, 1, 32 - length (suffix) - index (reverse (info_path.ent), reverse (suffix) || "."));
      end;
    else if info_path.code = 1 |	/* forbid -ep if starname was given.		*/
         info_path.code = 2 then
      do;
        info_path.code = 0;
        info_path.S.starname_ent = TRUE;
        if help_args.Sctl.ep | (info_path.ep ^= "") then
	info_path.code = error_table_$inconsistent;
      end;

    if info_path.code ^= 0 then
      return;
    if info_path.S.separate_info_name then
      do;				/* Check star-ness of user-supplied info_name.	*/
        if info_path.S.info_name_not_starname then
	info_path.S.starname_info_name = FALSE;
        else
	do;
	  call check_star_name_$entry (info_path.info_name, info_path.code);
	  if info_path.code = 1 | info_path.code = 2 then
	    do;
	      info_path.code = 0;
	      info_path.S.starname_info_name = TRUE;
	    end;
	  else info_path.S.starname_info_name = FALSE;
	end;
      end;
    else info_path.S.starname_info_name = info_path.S.starname_ent;

  end evaluate_path;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


get_info_seg_list:
  procedure (procedure_name, suffix, fcn, dirs, info_path, PDinfo_) options (non_quick);
				/* non_quick so that the large area won't stay around	*/
				/*   all the while help active and take up stack frame	*/
				/*   space.					*/

    dcl procedure_name char (*),
        suffix	   char (*),
        fcn	   fixed bin,
        dirs	   (*) char (168) unaligned,
        1 info_path	   aligned like help_args.path,
        PDinfo_	   ptr;

    dcl I		   fixed bin,
        Lline	   fixed bin,
        Lseg	   fixed bin (21),
        Nstart	   fixed bin,
        Pseg	   ptr,
        Ptemp	   ptr,
        area	   area (25000) init (empty ()),
        code	   fixed bin (35),
        (i, j, k)	   fixed bin,
        l		   fixed bin (21),
        line	   char (Lline) based (Pseg),
        linfo_name	   char (32),	/* info name without the suffix.		*/
        sinfo_name	   char (32),	/* info name with the suffix.			*/
        saved_date	   fixed bin (71);

    dcl 1 Dinfo_	   aligned based (PDinfo_),
	2 N	   fixed bin,
	2 seg	   (0 refer (Dinfo_.N)) like Dinfo_seg;

    dcl seg	   char (Lseg) based (Pseg),
				/* The info segment.  Pseg must be declared in	*/
				/* the external procedure so its on unit	*/
				/* (janitor) can terminate the segment.		*/
        seg_char	   (Lseg) char (1) based (Pseg);

    dcl hcs_$star_dir_list_
		   entry (char (*), char (*), fixed bin (3), ptr, fixed bin, fixed bin, ptr, ptr, fixed bin (35)),
        hcs_$status_long
		   entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35));

    Nstart = Dinfo_.N;		/* Remember count of info segs found before we	*/
				/*   start.  Then we'll know if we find any.	*/
    do i = lbound (dirs, 1) to hbound (dirs, 1);
				/* Apply info path to each dir to be searched.	*/
      star_select_sw = star_ALL_ENTRIES;
      call hcs_$star_dir_list_ (dirs (i), info_path.ent, star_select_sw, addr (area), star_branch_count, star_link_count,
	 star_list_branch_ptr, star_list_names_ptr, code);
      if code = 0 then
        do;
	do j = 1 to star_branch_count + star_link_count;
				/* process entries found in this directory.	*/
	  k, Dinfo_.N = Dinfo_.N + 1;
	  Dinfo_.seg (k).Scross_ref = FALSE;
	  Dinfo_.seg (k).dir = dirs (i);
	  Dinfo_.seg (k).ent = star_list_names (star_dir_list_branch (j).nindex);
	  Dinfo_.seg (k).info_name = "";
	  Dinfo_.seg (k).ep = info_path.ep;
	  Dinfo_.seg (k).E = info_path.ep;
	  Dinfo_.seg (k).segment_type = star_dir_list_branch (j).type;

/* Process each entry according to its type.	*/
	  if star_dir_list_branch (j).type = star_SEGMENT then
	    do;
	      Dinfo_.seg (k).L = divide (star_dir_list_branch (j).bit_count, 9, 24, 0);
	      Dinfo_.seg (k).date = numeric_date (star_dir_list_branch (j).dtem);
	      Dinfo_.seg (k).mode = substr (star_dir_list_branch (j).mode, 2, 3);
				/* extract "rew" mode bits from "trewa".			*/
	      Dinfo_.seg (k).code = 0;
	      if Dinfo_.seg (k).L = 0 then
	        Dinfo_.seg (k).code = error_table_$zero_length_seg;
	      else if star_dir_list_branch (j).bit_count - 9 * Dinfo_.seg (k).L > 0 then
	        Dinfo_.seg (k).code = error_table_$badsyntax;
	    end;
	  else if star_dir_list_branch (j).type = star_LINK then
	    do;			/* Links must be chased, and target examined.	*/
	      call hcs_$status_long (Dinfo_.seg (k).dir, Dinfo_.seg (k).ent, 1, addr (branch), null (), code);
	      if (code = 0) | (code = error_table_$no_s_permission) then
	        do;
		if branch.type = Segment then
		  do;
		    Dinfo_.seg (k).L = divide (binary (branch.bit_count, 24), 9, 24, 0);
		    Dinfo_.seg (k).date = numeric_date (branch.dtem);
		    Dinfo_.seg (k).mode = substr (branch.mode, 2, 3);
		    Dinfo_.seg (k).code = 0;
		    if Dinfo_.seg (k).L = 0 then
		      Dinfo_.seg (k).code = error_table_$zero_length_seg;
		    else if binary (branch.bit_count, 24) - 9 * Dinfo_.seg (k).L > 0 then
		      Dinfo_.seg (k).code = error_table_$badsyntax;
		  end;
		else if branch.type = Link then
		  do;
		    Dinfo_.seg (k).L = 0;
		    Dinfo_.seg (k).date = 0;
		    Dinfo_.seg (k).mode = "0"b;
		    Dinfo_.seg (k).code = error_table_$noentry;
		  end;
		else
		  do;		/* Skip matching directories.			*/
		    Dinfo_.N = Dinfo_.N - 1;
		    go to SKIP_ENTRY;
				/*   Forget everything we've done for this entry.	*/
		  end;
	        end;
	      else
	        do;		/* Don't have access to the link target.	*/
		Dinfo_.seg (k).L = 0;
		Dinfo_.seg (k).date = 0;
		Dinfo_.seg (k).mode = "0"b;
		Dinfo_.seg (k).code = code;
	        end;
	    end;
	  else
	    do;			/* Skip matching directories.			*/
	      Dinfo_.N = Dinfo_.N - 1;
	      go to SKIP_ENTRY;
	    end;
	  if Dinfo_.seg (k).code = 0 then
	    if (Dinfo_.seg (k).mode & "100"b) then
	      if help_args.min_date_time ^< Dinfo_.seg (k).date then
	        Dinfo_.N = Dinfo_.N - 1;
	      else ;
	    else Dinfo_.seg (k).code = error_table_$moderr;
				/* report error if user can't access info seg.	*/
SKIP_ENTRY:
	end;

	free star_list_names in (area),
				/* free found entry structures.		*/
	     star_dir_list_branch in (area);
        end;

      else if (code = error_table_$incorrect_access | code = error_table_$no_info) & ^info_path.S.starname_ent then
        do;			/* If user does not have "s" permission to dir,	*/
				/* look for a specific help seg.		*/
	call hcs_$status_long (dirs (i), info_path.ent, 1, addr (branch), null (), code);
	if (code = error_table_$no_s_permission) | (code = 0) then
	  do;
	    if branch.type ^= Directory then
	      do;
	        k, Dinfo_.N = Dinfo_.N + 1;
	        Dinfo_.seg (k).Scross_ref = FALSE;
	        Dinfo_.seg (k).dir = dirs (i);
	        Dinfo_.seg (k).ent = info_path.ent;
	        Dinfo_.seg (k).info_name = "";
	        Dinfo_.seg (k).ep = info_path.ep;
	        Dinfo_.seg (k).E = info_path.ep;
	        Dinfo_.seg (k).segment_type = branch.type;
	        if branch.type = Segment then
		do;
		  Dinfo_.seg (k).L = divide (binary (branch.bit_count, 24), 9, 24, 0);
		  Dinfo_.seg (k).date = numeric_date (branch.dtem);
		  Dinfo_.seg (k).mode = substr (branch.mode, 2, 3);
		  if Dinfo_.seg (k).mode & "100"b then
		    Dinfo_.seg (k).code = 0;
		  else Dinfo_.seg (k).code = error_table_$moderr;
		  if Dinfo_.seg (k).L = 0 then
		    Dinfo_.seg (k).code = error_table_$zero_length_seg;
		  else if binary (branch.bit_count, 24) - 9 * Dinfo_.seg (k).L > 0 then
		    Dinfo_.seg (k).code = error_table_$badsyntax;
		  else if code = 0 then
		    if help_args.min_date_time ^< Dinfo_.seg (k).date then
		      Dinfo_.N = Dinfo_.N - 1;
		end;
	        else
		do;		/* Give error for link target being a link.	*/
		  Dinfo_.seg (k).L = 0;
		  Dinfo_.seg (k).date = 0;
		  Dinfo_.seg (k).mode = "0"b;
		  Dinfo_.seg (k).code = error_table_$noentry;
		end;
	      end;
	  end;
	else if code = error_table_$noentry then
	  ;
	else go to DIR_ERROR;
        end;
      else if code = error_table_$nomatch then
        ;
      else
        do;			/* Fatal error looking in this dir.		*/
DIR_ERROR:
	call error (help_args.sci_ptr, code, "^/Looking for info segments in ^a.", dirs (i));
	if dim (dirs, 1) = 1 then
	  return;			/* Avoid getting nomatch error in addition to 	*/
        end;			/* this one when only 1 dir to look into.	*/
    end;

    if fcn = CIS then
      do;
        do i = Nstart + 1 to Dinfo_.N;
	if Dinfo_.seg (i).code ^= 0 then
	  do;
	    Dinfo_.seg (i).uid = "0"b;
	    Dinfo_.seg (i).I = 0;
	    Dinfo_.seg (i).E = "";
	  end;
        end;
        return;
      end;
    else if Dinfo_.N = Nstart then
      do;
        if info_path.S.starname_ent then
	code = error_table_$nomatch;
        else code = error_table_$noentry;
        call error (help_args.sci_ptr, code, "^[-pn ^]^a", info_path.S.pn_ctl_arg, info_path.value);
      end;
    else
      do i = Nstart + 1 to Dinfo_.N;	/* Look for :Info: info dividers.		*/
        if Dinfo_.seg (i).code = 0 then
	do;
	  Dinfo_.seg (i).uid = "0"b;	/* We don't know seg's uid yet.		*/
	  call initiate (Dinfo_.seg (i).dir, Dinfo_.seg (i).ent, Dinfo_.seg (i).uid, Pseg, code);
	  if Pseg ^= null then
	    do;
	      Lseg = Dinfo_.seg (i).L;
	      Dinfo_.seg (i).I = 1;	/* Fill in substring index of 1st		*/
				/* char of physical info seg.			*/
	      I = verify (seg, "	 
");
	      if I > 1 then
	        do;		/* Strip HT SP NL from start of info seg.	*/
		Pseg = addr (seg_char (I));
		Lseg = Lseg - (I - 1);
	        end;
	      if Lseg > 8 then	/* See if info seg begins with :Info:		*/
				/*   (8 = length(":Info:C:"), C is any char.	*/
	        if substr (seg, 1, 6) = ":Info:" | substr (seg, 1, 10) = ":Internal:" then
		do;		/* Internal is for help vis			*/
		  if substr (seg, 1, 6) = ":Info:" then
		    do;
		      Pseg = addr (seg_char (7));
		      Lseg = Lseg - 6;
		    end;
		  else
		    do;
		      Pseg = addr (seg_char (11));
		      Lseg = Lseg - 10;
		    end;
		  k = i;
		  Dinfo_.seg (k).info_name = info_path.info_name;
				/* save info_name used to find infos for use in	*/
				/* error messages  (without suffix).		*/
		  saved_date = Dinfo_.seg (k).date;
				/* save date assoc with phys info seg in case	*/
				/* some log. infos don't have date in their header*/
		end;
	        else Lseg, k = 0;
	      else Lseg, k = 0;

	      do while (Lseg > 0);	/* It does contain :Info:.  Look for info(s)	*/
	        Lline = index (seg, NL);
				/* which match user-supplied entryname.		*/
	        if Lline = 0 then
		Lline = Lseg;
	        linfo_name = find_info_name (line, I);
	        do while (I > 0);
		if info_path.S.starname_info_name then
		  do;
		    call match_star_name_ (linfo_name, info_path.info_name, code);
		    if code ^= 0 then
		      go to NO_MATCH;
		  end;
		else if linfo_name ^= info_path.info_name then
		  go to NO_MATCH;

		if ^info_path.S.separate_info_name then
		  do;		/* POTENTIAL BUG:  Use of assoc. memory for 	*/
				/* initiated segs may subvert test to see if 	*/
				/* info_name really a name on phys. info seg.	*/
				/* Subsequent attempt to reinitiate may succeed 	*/
				/* by uid found in assoc mem, rather than by name	*/
				/* being found on phys. info seg.		*/
		    if suffix ^= "" then
		      sinfo_name = rtrim (linfo_name) || "." || suffix;
		    else sinfo_name = linfo_name;

/* Test now to see if log info_name is on seg.	*/
		    if info_path.S.starname_ent then
		      do;
		        call hcs_$initiate (Dinfo_.seg (k).dir, sinfo_name, "", 0, 0, Ptemp, code);
		        if Ptemp = null then
			go to NO_MATCH;
		      end;
		    Dinfo_.seg (k).ent = sinfo_name;
		  end;		/* This info matches.  Include it in output list.	*/
		j = Lline - index (reverse (line), ":") + 2;
		Dinfo_.seg (k).I = rel_char (addr (seg_char (j))) + 1;
				/* get index of first char of this info.	*/
				/* 1 is added to the char offset returned by 	*/
				/* rel_char to get a char index.		*/
		l = index (seg, "


:Info:");				/* get info length by finding next info.	*/
		if l = 0 then	/* need for help vis			*/
		  l = index (seg, "


:Internal:");			/* get info length by finding next info.	*/
		if l > 0 then
		  Dinfo_.seg (k).L = l - (j - 1);
		else Dinfo_.seg (k).L = Lseg - (j - 1);
		Pseg = addr (seg_char (j));
		Lseg = Lseg - (j - 1);
		Lline = Lline - (j - 1);
		j = verify (seg, "	 
");
		if j > 1 then
		  do;		/* Remove leading HT SP NL from log info.	*/
		    Pseg = addr (seg_char (j));
		    Lseg = Lseg - (j - 1);
		    Lline = index (seg, NL);
		    if Lline = 0 then
		      Lline = Lseg;
		  end;
		if Lseg >= Lline + 1 then
				/* Store date assoc with log info.		*/
		  if seg_char (Lline + 1) = NL then
		    do;		/* Date comes from 1st field of heading line of	*/
				/* log info, which must be followed by blank line.*/
		      Lline = Lline - 1;
		      j = search (line, "	 ");
		      if j = 0 then
		        j = Lline;
		      else
		        do;
			call convert_date_to_binary_ (substr (line, 1, j), Dinfo_.seg (k).date, code);
			if code ^= 0 then
			  Dinfo_.seg (k).date = saved_date;
		        end;
		    end;
		  else Dinfo_.seg (k).date = saved_date;
		else Dinfo_.seg (k).date = saved_date;
		I = 0;		/* Stop processing this :Info: line (this info).	*/
		if ^(info_path.S.starname_info_name | info_path.S.separate_info_name) then
		  Lseg = 0;	/* If not a starname or separate info_name, 	*/
				/* we've found one & only matching log. info	*/
		if help_args.min_date_time ^< Dinfo_.seg (k).date then
		  go to MATCH;	/* Info modified before min date; skip it	*/
		Dinfo_.seg (k).info_name = linfo_name;
				/* Save info_name for use in headings.		*/
		k, Dinfo_.N = Dinfo_.N + 1;
		Dinfo_.seg (k) = Dinfo_.seg (i);
		go to MATCH;

NO_MATCH:
		Pseg = addr (seg_char (I + 1));
		Lseg = Lseg - I;	/* Look for another name on this info, since	*/
		Lline = Lline - I;	/* previous names on it don't match user wants.	*/
		linfo_name = find_info_name (line, I);
MATCH:
	        end;

	        I = index (seg, "


:Info:");
	        if I > 0 then
		do;
		  Pseg = addr (seg_char (I + 9));
		  Lseg = Lseg - (I + 8);
		end;
	        else
		do;		/* need for help vis			*/
		  I = index (seg, "


:Internal:");
		  if I > 0 then
		    do;
		      Pseg = addr (seg_char (I + 13));
		      Lseg = Lseg - (I + 10);
		    end;
		  else Lseg = 0;
		end;
	      end;
	      if k = 0 then
	        ;			/* No :Info: in phys info seg.		*/
	      else if k = i then	/* No matching info in phys info seg.		*/
	        if info_path.S.starname_info_name then
		Dinfo_.seg (i).code = error_table_$nomatch;
	        else Dinfo_.seg (i).code = error_table_$noentry;
	      else Dinfo_.N = Dinfo_.N - 1;
				/* Matching info found.  We always get one more	*/
				/* Dinfo_.seg than we can use.		*/
	    end;
	  else Dinfo_.seg (i).code = code;
				/* Failed to initiate physical info seg.	*/
	end;
        if Dinfo_.seg (i).code ^= 0 then
	do;
	  Dinfo_.seg (i).uid = "0"b;	/* If error occurred during processing, mark	*/
	  Dinfo_.seg (i).I = 0;	/* info to cause error message to be printed.	*/
	  Dinfo_.seg (i).E = "";
	end;
      end;

find_info_name:
  proc (Aline, Iline) returns (char (32));

    dcl Aline	   char (*),	/* unprocessed part of :Info: line (incl NL).	*/
        Iline	   fixed bin,	/* amount processed while finding this info name. */
        info_name	   char (32) varying;
				/* the info_name which was found.		*/

    dcl (Icolon, Inon_space, Iquote, Iquote_quote)
		   fixed bin,
        Lline	   fixed bin,
        Pline	   ptr;

    dcl (
        QUOTE	   char (1) init (""""),
        QUOTE_QUOTE	   char (2) init ("""""")
        )		   int static options (constant);

    dcl line	   char (Lline) based (Pline),
        line_char	   (Lline) char (1) based (Pline);

    Pline = addr (Aline);
    Lline = length (Aline);
    Inon_space = verify (line, HT_SP);	/* Remove leading white space from info name.	*/
    if Inon_space > 1 then
      do;
        Pline = addr (line_char (Inon_space));
        Lline = Lline - (Inon_space - 1);
      end;
    else if Inon_space = 0 then
      do;				/* Remainder of line is empty.		*/
ERROR:
        Iline = length (Aline);
        return ("");
      end;

    if line_char (1) = QUOTE then
      do;				/* Look for quoted info name.			*/
        Pline = addr (line_char (length (QUOTE) + 1));
				/*   Skip the opening quote.			*/
        Lline = Lline - length (QUOTE);
        Iquote = index (line, QUOTE);	/*   Search for trailing quote.		*/
        if Iquote = 0 | Iquote + 2 > Lline then
				/*   Trailing quote is missing.		*/
	go to ERROR;
        Iquote_quote = index (line, QUOTE_QUOTE);
				/*   Check for doubled quotes.		*/
        if Iquote ^= Iquote_quote then	/*   There are none.			*/
	info_name = substr (line, 1, Iquote - 1);
        else
	do;			/*   Doubled quotes must be undoubled in info name*/
	  info_name = "";
	  do while (Iquote = Iquote_quote);
	    info_name = info_name || substr (line, 1, Iquote);
	    Pline = addr (line_char (Iquote + length (QUOTE_QUOTE)));
	    Lline = Lline - (Iquote + length (QUOTE_QUOTE) - 1);
	    Iquote = index (line, QUOTE);
	    if Iquote = 0 | Iquote + 2 > Lline then
	      go to ERROR;
	    Iquote_quote = index (line, QUOTE_QUOTE);
	  end;
	  info_name = info_name || substr (line, 1, Iquote - 1);
	end;
        Pline = addr (line_char (Iquote + length (QUOTE)));
        Lline = Lline - (Iquote + length (QUOTE) - 1);
        Inon_space = verify (line, HT_SP);
				/* Remove trailing white space.		*/
        if Inon_space > 1 then
	do;
	  Pline = addr (line_char (Inon_space));
	  Lline = Lline - (Inon_space - 1);
	end;
        else if Inon_space = 0 then
	go to ERROR;		/* No trailing colon.  Skip last name.		*/
        if line_char (1) = ":" then	/* info name found in correct format.		*/
	Iline = length (Aline) - (Lline - 1);
        else go to ERROR;		/* No trailing colon.  That's bad;		*/
      end;
    else
      do;				/* Info name is not quoted.			*/
        Icolon = index (line, ":");
        if Icolon = 0 then
	go to ERROR;		/*   No trailing colon.			*/
        info_name = rtrim (substr (line, 1, Icolon - 1));
        Iline = length (Aline) - (Lline - Icolon);
      end;
    return (info_name);

  end find_info_name;

%include star_structures;

%include status_structures;

    dcl 1 branch	   aligned like status_branch;

  end get_info_seg_list;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


initiate:
  procedure (dir, ent, uid, Pseg, code);/* Provide an associative memory for info segs	*/
				/* to reduce amt. of double initiating each seg.	*/

    dcl dir	   char (168) unal,
        ent	   char (32) unal,
        uid	   bit (36) aligned,
        Pseg	   ptr,
        code	   fixed bin (35);

    dcl i		   fixed bin;
    dcl Iempty	   fixed bin;

    Iempty = 0;			/* No empty slots in assoc. mem so far.		*/
    code = 0;
    Pseg = null;
    do i = 1 to init_assoc_mem.N while (Pseg = null);
				/* Look for seg to be initiated in assoc. mem.	*/
      if init_assoc_mem.seg (i).uid ^= "0"b then
        do;			/*   Zero uid?  No, we must check the cell.	*/
	if uid ^= "0"b then		/*   Can't check if we don't know segs uid.	*/
	  if uid = init_assoc_mem.seg (i).uid then
	    Pseg = init_assoc_mem.seg (i).P;
				/*   Found seg in assoc mem. Got off cheap!	*/
	  else ;
	else if dir = init_assoc_mem.seg (i).dir & ent = init_assoc_mem.seg (i).ent then
	  do;			/*   Check segs dir/ent with assoc mem.		*/
	    uid = init_assoc_mem.seg (i).uid;
	    Pseg = init_assoc_mem.seg (i).P;
	  end;
        end;
      else if Iempty = 0 then		/* Remember first empty cell in  case seg not	*/
        Iempty = i;			/* found in assoc. mem.			*/
    end;
    if Pseg ^= null then
      return;			/* See found in assoc. All done!		*/

    call hcs_$initiate (dir, ent, "", 0, 0, Pseg, code);
    if Pseg = null then
      return;			/* Have to initiate the segment.		*/
    call hcs_$get_uid_seg (Pseg, uid, code);
				/* Complain if error.  Otherwise, get seg's uid.	*/
    do i = 1 to init_assoc_mem.N while (init_assoc_mem.seg (i).uid ^= uid);
    end;				/* make sure uid doesn't appear in assoc memory	*/
    if i <= init_assoc_mem.N then
      return;			/* under another name.  If so, don't add again.	*/
    if Iempty = 0 then		/* If no empty cells, must make one.		*/
      if init_assoc_mem.N < dimension (init_assoc_mem.seg, 1) then
        do;
	init_assoc_mem.N = init_assoc_mem.N + 1;
	Iempty = init_assoc_mem.N;	/* Add new cell to the table, if room.		*/
        end;
      else
        do;			/* Must terminate cell member to make room for new*/
	Iempty = init_assoc_mem.N;	/* seg in assoc. mem.			*/
	call hcs_$terminate_noname (init_assoc_mem.seg (Iempty).P, code);
        end;
    init_assoc_mem.seg (Iempty).dir = dir;
    init_assoc_mem.seg (Iempty).ent = ent;
    init_assoc_mem.seg (Iempty).uid = uid;
    init_assoc_mem.seg (Iempty).P = Pseg;

  end initiate;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


janitor:
  procedure;			/* terminate known info segs;  truncate temp seg.	*/

    call term_assoc_mem ();
    call hcs_$truncate_seg (Phelp_args, currentsize (help_args), 0);

    if Sstandalone_invocation then
      if help_args.sci_ptr ^= null then
        do;
	call ssu_$destroy_invocation (help_args.sci_ptr);
	help_args.sci_ptr = null;
        end;

    if Pquery_answers ^= null then
      call release_temp_segment_ (procedure_name, Pquery_answers, code);

  end janitor;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


numeric_date:
  procedure (bit_date) returns (fixed bin (71));
				/* This procedure converts a file system date	*/
				/* to a numeric clock value.  A file system date	*/
				/* is the high-order 36 bits of a 52 bit clock	*/
				/* value.					*/

    dcl bit_date	   bit (36) unal,
        num_date	   fixed bin (71);


    num_date = 0;
    substr (unspec (num_date), 21, 36) = bit_date;
    return (num_date);

  end numeric_date;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


rel_char:
  proc (P) returns (fixed bin (21));	/* This procedure converts a pointer value into	*/
				/* a character offset from base of segment	*/
				/* pointed to.  We need a PL/I bif to do this.	*/
    dcl P		   ptr;

    dcl I		   fixed bin (21),
        P1	   ptr,
        i		   fixed bin;

    dcl char_offset	   (0:3) char (1) based (P1);

    P1 = ptr (P, rel (P));
    I = 4 * binary (rel (P));
    do i = 0 to 3 while (addr (char_offset (i)) ^= P);
    end;
    I = I + i;
    return (I);

  end rel_char;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


set_space_used:
  procedure (Pcurrent_space, size_current_space) returns (ptr);
				/* This procedure returns pointer to next free	*/
				/* word of storage in help_args temp segment.	*/
    dcl Pcurrent_space ptr,		/* ptr to last space allocated in the seg.	*/
        size_current_space
		   fixed bin (21),	/* amount of space used in structure last alloc.	*/
        Pnext_space	   ptr;		/* ptr to next free space.			*/

    Pnext_space = addrel (Pcurrent_space, size_current_space + mod (size_current_space, 2));
    return (Pnext_space);

  end set_space_used;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


term_assoc_mem:
  procedure;			/* terminate known info segs.			*/

    do init_assoc_mem.N = init_assoc_mem.N to 1 by -1;
      if init_assoc_mem.seg (init_assoc_mem.N).uid ^= "0"b then
        call hcs_$terminate_noname (init_assoc_mem.seg (init_assoc_mem.N).P, 0);
    end;
  end term_assoc_mem;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


init:
  entry (procedure_name, search_list_name, search_list_ref_dir, Vrequired, Phelp_args, Acode);

    dcl search_list_name
		   char (*),	/* Name of search list used in finding infos.	*/
				/*   (input)				*/
        search_list_ref_dir
		   char (*),	/* Referencing dir used in  search rules.	*/
				/*   (input)				*/
        Vrequired	   fixed bin;	/* Required version of help_args structure.	*/
				/*   (input)				*/

    dcl Parea	   ptr,
        area	   area (25000) based (Parea);

    if Vrequired ^= Vhelp_args_3 & Vrequired ^= 2 & Vrequired ^= 1 then
      do;
        Acode = error_table_$unimplemented_version;
        return;
      end;
    call get_temp_segment_ (procedure_name, Phelp_args, Acode);
    if Acode ^= 0 then		/* Obtain a temporary segment.		*/
      Phelp_args = null;
    else
      do;
        help_args.version = Vrequired;	/* Initialize the help argument structure.	*/
        help_args.help_data_ptr = null;
        help_args.sci_ptr = null;
        string (help_args.Sctl) = "0"b;
        help_args.min_Lpgh = 4;
        help_args.max_Lpgh = 15;
        help_args.Lspace_between_infos = 2;
        help_args.min_date_time = -1;
        help_args.Npaths = 0;
        help_args.Ncas = 0;
        help_args.Nsrhs = 0;
        if search_list_name ^= "" then
	do;
	  help_args.Nsearch_dirs = 1000;
				/* Allow room for up to 1000 search dirs.	*/
	  Parea = set_space_used (Phelp_args, currentsize (help_args));
	  area = empty ();
	  call search_paths_$get (search_list_name, sl_control_default, search_list_ref_dir, null, Parea, sl_info_version_1,
	       sl_info_p, Acode);
	  if Acode = 0 then
	    do;
	      help_args.Nsearch_dirs = sl_info.num_paths;
	      if help_args.Nsearch_dirs > 0 then
	        help_args.search_dirs (*) = sl_info.paths (*).pathname;
	    end;
	  else help_args.Nsearch_dirs = 0;
	end;
        else help_args.Nsearch_dirs = 0;
        call hcs_$truncate_seg (Phelp_args, currentsize (help_args), 0);
      end;
    return;


%include sl_info;

%include sl_control_s;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


term:
  entry (procedure_name, Phelp_args, Acode);

    if Phelp_args ^= null then
      do;
        if unspec(help_args.help_data_ptr) = ""b then;	/* check for case where interruption	  */
						/*  occurred before help_$init could	  */
						/*  complete its initialization of	  */
						/*  the help_args structure.  Otherwise,  */
						/*  the reference to help_data_ptr could  */
						/*  cause a seg_fault referencing dseg	  */
						/*  (segment 0|0).			  */
        else if help_args.help_data_ptr ^= null then
           call help_$term (procedure_name, help_args.help_data_ptr, Acode);
        call release_temp_segment_ (procedure_name, Phelp_args, Acode);
      end;
    
    return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

%include arg_list;

%include help_args_;

%include help_cis_args_;

    dcl 1 Dinfo_seg_   aligned like Dinfo_seg based (PDinfo_seg_),
        PDinfo_seg_	   ptr;

  end help_;
