/* ***************************************************************
   *                                                             *
   * Copyright, (C) Honeywell Information Systems Inc., 1982     *
   *                                                             *
   * Copyright (c) 1975 by Massachusetts Institute of Technology *
   *                                                             *
   * Copyright (c) 1972 by Massachusetts Institute of            *
   * Technology and Honeywell Information Systems, Inc.          *
   *                                                             *
   *************************************************************** */




/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* N__a_m_e:  lex_error_							*/
/*									*/
/*      This procedure is used by compilers generated by the reduction_compiler.	*/
/* It outputs specially-formatted error messages on the error_output stream.		*/
/*									*/
/* E__n_t_r_y:	 lex_error_							*/
/*									*/
/*      Given an error number, an error-message-already-printed switch, an error severity, */
/* a maximum error severity encountered so far, a pointer to a lex_string_ statement	*/
/* descriptor, an error message (ioa_ control string), a brief error message (a shorter	*/
/* ioa_ control string), and optional arguments to be substituted into the error messages, */
/* this procedure writes out a herald describing the error number and severity,		*/
/* the statement and line number of the source statement in error, the text of the error	*/
/* message (into which optional arguments have been substituted), and the source	*/
/* statement.  The error message and source statement are marked as having been printed	*/
/* and if severity > max_severity, max_severity is boosted to the value of severity.	*/
/* If an attempt is made to print this error message again (ie, the error reoccurs), then	*/
/* a brief form of the message is printed instead.  (This brief form may be as brief as	*/
/* a null character string.)  If an attempt is made to print the source statement in	*/
/* another error message, printing is suppressed.					*/
/*									*/
/* U__s_a_g_e									*/
/*									*/
/*      declare lex_error_ entry options (variable);				*/
/*									*/
/*      call lex_error_ (error_number, Serror_printed, severity, max_severity, Pstmt,	*/
/*		     Ptoken, S, message, brief_msg, arg1_, ... , arg_n);		*/
/*									*/
/* 1) error_number (fixed bin)	number of the error in error_control_table.	*/
/* 2) Serror_printed (bit(1) unal)	switch indicating whether the error message	*/
/*				has been printed.  This will be updated.	*/
/* 3) severity (fixed bin)		severity of this error.			*/
/* 4) max_severity (fixed bin)	severity of the highest-severity error so far.	*/
/*				This will be updated.			*/
/* 5) Pstmt (ptr)			ptr to lex_string_ type statement descriptor of	*/
/*				statement to be output after error message.	*/
/* 6) Ptoken (ptr)			ptr to lex_string_ type token descriptor of token	*/
/*				appearing in line which is in error.  Line number	*/
/*				of this token will be used in error message if	*/
/*				Pstmt is null.				*/

/* 7) S (bit(*))			control bits:				*/
/*				  substr(S,1,1) = on if brief message are never	*/
/*					        to be used.			*/
/*				  substr(S,2,1) = on if brief message are always	*/
/*					        used, even when long message	*/
/*					        has never been printed.	*/
/* 8) message (char(*) varying)	text of the error message, an ioa_ control string. */
/* 9) brief_msg (char(*) varying)	text of the brief error message.		*/
/* 10) arg_i			substitution arguments for replacing ioa_ control	*/
/*				arguments in the error message.		*/
/*									*/
/* N__o_t_e_s									*/
/*									*/
/*      The severity numbers cause the error message to preceded by one of the following	*/
/* heralds:								*/
/*	0 = COMMENT		- this is a comment.			*/
/*	1 = WARNING		- a possible error has been detected.  The	*/
/*				  compiler will still generate an object segment.	*/
/*	2 = ERROR			- a probable error has been detected.  The	*/
/*				  compiler will still generate an object segment.	*/
/*	3 = FATAL ERROR		- an error has been detected which is so severe 	*/
/*				  that no object segment will be generated.	*/
/*	4 = TRANSLATOR ERROR	- an error has been detected in the operation of	*/
/*				  the compiler or translator.  No object segment	*/
/*				  will be generated.			*/
/*									*/
/*      Error messages are of the form:						*/
/*	FATAL ERROR _e_r_r_o_r__n_u_m_b_e_r, SEVERITY _s_e_v_e_r_i_t_y IN STATEMENT _n of LINE _m		*/
/*	_t_e_x_t__o_f__e_r_r_o_r__m_e_s_s_a_g_e						*/
/*	SOURCE:								*/
/*	_s_o_u_r_c_e__s_t_a_t_e_m_e_n_t							*/
/*									*/
/* If only one statement appears in line _m, then "STATEMENT _n OF" is omitted.		*/
/*									*/
/* S__t_a_t_u_s									*/
/*									*/
/* 0) Created:  April, 1974 by G. C. Dixon					*/
/* 1) Modified: August, 1981 by M. R. Jordan to recover gracefully when severity is bad	*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


lex_error_: procedure (Nerror, SERROR_PRINTED, severity, max_severity, Pstmt, Ptoken, Scontrol,
	     message, brief);

dcl  Nerror fixed bin,				/* Number of the error which was detected. (In)	*/
     SERROR_PRINTED bit (1) unaligned,			/* on if error message text has been printed.	*/
     severity fixed bin (17),				/* severity of this error.			*/
     max_severity fixed bin,				/* severity of highest-severity error so far.	*/
						/*	Pstmt			ptr,		/* ptr to a lex_string_ statement descriptor.	*/
						/*	Ptoken			ptr,		/* ptr to a lex_string_ token descriptor.	*/
     Scontrol bit (*),				/* control bits (see above).			*/
     message char (*) varying,			/* long error message.			*/
     brief char (*) varying;				/* short error message.			*/

dcl  Lmsg fixed bin,
     1 S aligned,					/* overlay for Scontrol.			*/
     2 always_long bit (1) unal,			/*   always use long error message.		*/
     2 always_brief bit (1) unal,			/*   always use brief error message.		*/
     msg char (256) aligned;

dcl (addr, fixed, max, min, null, string)
     builtin;

dcl  cu_$arg_list_ptr entry returns (ptr),
     ioa_$general_rs entry (ptr, fixed bin, fixed bin, char (*) aligned, fixed bin,
     bit (1) aligned, bit (1) aligned),
     ioa_$ioa_stream entry options (variable),
     ioa_$ioa_stream_nnl entry options (variable),
     iox_$put_chars entry (ptr, ptr, fixed bin, fixed bin (35)),
     iox_$error_output ptr ext static;

dcl  herald (-1:4) char (16) aligned int static init (
     "TRANSLATOR ERROR", "COMMENT", "WARNING", "ERROR", "FATAL ERROR", "TRANSLATOR ERROR");

%include lex_descriptors_;

	call ioa_$ioa_stream_nnl ("error_output", "^/^a ^d, SEVERITY ^d", herald (min (4, max (-1, severity))),
	     Nerror, fixed (severity, 35));

	if Pstmt ^= null then do;
	     if stmt.Istmt_in_line > 1 then
		call ioa_$ioa_stream ("error_output", " IN STATEMENT ^d OF LINE ^d",
		fixed (stmt.Istmt_in_line, 35), fixed (stmt.line_no, 35));
	     else if stmt.Pnext ^= null then
		if stmt.Pnext -> stmt.Istmt_in_line > 1 then
		     call ioa_$ioa_stream ("error_output", " IN STATEMENT ^d OF LINE ^d",
		     fixed (stmt.Istmt_in_line, 35), fixed (stmt.line_no, 35));
		else
		call ioa_$ioa_stream ("error_output", " IN LINE ^d", fixed (stmt.line_no, 35));
	     else
	     call ioa_$ioa_stream ("error_output", " IN LINE ^d", fixed (stmt.line_no, 35));
	end;
	else if Ptoken ^= null then
	     call ioa_$ioa_stream ("error_output", " IN LINE ^d", fixed (token.line_no, 35));
	else
	call ioa_$ioa_stream ("error_output", "");

	string (S) = Scontrol;			/* copy control bits to aligned structure.	*/
	if (SERROR_PRINTED | S.always_brief) & ^S.always_long then
	     if brief = "" then;
	     else do;
		call ioa_$general_rs (cu_$arg_list_ptr (), 9, 10, msg, Lmsg, "0"b, "1"b);
		call iox_$put_chars (iox_$error_output, addr (msg), Lmsg, 0);
	     end;
	else do;
	     SERROR_PRINTED = "1"b;
	     call ioa_$general_rs (cu_$arg_list_ptr (), 8, 10, msg, Lmsg, "0"b, "1"b);
	     call iox_$put_chars (iox_$error_output, addr (msg), Lmsg, 0);
	end;

	if Pstmt ^= null then do;
	     stmt.error_in_stmt = "1"b;
	     if stmt.output_in_err_msg then;
	     else do;
		stmt.output_in_err_msg = "1"b;
		call ioa_$ioa_stream ("error_output", "SOURCE:");
		call iox_$put_chars (iox_$error_output, (stmt.Pvalue), (stmt.Lvalue), 0);
		call ioa_$ioa_stream ("error_output", "");
	     end;
	end;

	if severity > max_severity then
	     max_severity = severity;

     end lex_error_;
