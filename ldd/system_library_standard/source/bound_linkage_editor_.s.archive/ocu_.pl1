/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1986 *
        *                                                         *
        *********************************************************** */

/****^  HISTORY COMMENTS:
  1) change(86-08-12,Elhard), approve(86-08-12,MCR7505),
     audit(86-12-10,DGHowe), install(86-12-10,MR12.0-1241):
     Originally written to provide a subroutine library for creating standard
     object segments.
  2) change(86-12-19,Elhard), approve(86-12-19,PBF7505),
     audit(86-12-22,DGHowe), install(87-01-05,MR12.0-1256):
     Changed declarations of list templates to put in explicit declaration of
     the template words (instead of letting them default to fixed bin (17)) so
     that debugging versions compiled with -prefix size dont explode.
  3) change(88-10-06,Elhard), approve(88-10-06,MCR8015),
     audit(88-10-24,DGHowe), install(88-10-26,MR12.2-1185):	
     Fixed phx21213 Re: invalid deferred init template relocation, and bug in
     definition hash table generation.
                                                   END HISTORY COMMENTS */

/* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */

ocu_:
  proc;

  /*** ****************************************************************/
  /***							*/
  /***	Name:	ocu_					*/
  /***	Function:	This is a set of object creation utilities used	*/
  /***		to create standard format object segments.	*/
  /***							*/
  /*** ****************************************************************/

  /* constants */

  dcl true		bit (1) static options (constant) init ("1"b);
  dcl false		bit (1) static options (constant) init ("0"b);
  
  dcl Left		fixed bin static options (constant) init (1);
  dcl Right		fixed bin static options (constant) init (2);
  
  dcl reloc_bits		(1:12) bit (5) static options (constant)
			init ("10000"b, "10001"b, "10010"b,
			"10011"b, "10100"b, "10101"b,
			"10110"b, "10111"b, "11000"b,
			"11001"b, "11010"b, "11111"b);
  dcl reloc_chars		char (12) static options (constant)
			init ("t123lds78ire");
  dcl class_relinfo		(0:4) char (1) static options (constant)
			init ("t", "l", "s", "d", "i");

  dcl STD_RELINFO		char (13) static options (constant)
			init ("at123lds78ire");
  dcl ALM_RELINFO		char (13) static options (constant)
			init ("a0123456789L*");

  /* static structures for currentsize references */

  dcl 01 s_vlh		aligned like virgin_linkage_header
			static options (constant);
  dcl 01 s_lk		aligned like object_link
			static options (constant);
  dcl 01 s_dh		aligned like definition_header
			static options (constant);
  dcl 01 s_def		aligned like definition
			static options (constant);

  /* parameters */

  dcl A_call_relp		fixed bin (18) unsigned parameter;
  dcl A_class		fixed bin (3) parameter;
  dcl A_code		fixed bin (35) parameter;
  dcl A_component		fixed bin (15) unsigned parameter;
  dcl A_component_count	fixed bin (15) unsigned parameter;
  dcl A_component_listp	ptr parameter;
  dcl A_dir_name		char (*) parameter;
  dcl A_entry_name		char (*) parameter;
  dcl A_expression		fixed bin (17) parameter;
  dcl A_flags		bit (*) parameter;
  dcl A_generator_infop	ptr;
  dcl A_info_relp		fixed bin (18) unsigned parameter;
  dcl A_init_infop		ptr parameter;
  dcl A_modifier		bit (6) parameter;
  dcl A_my_component	fixed bin (15) unsigned parameter;
  dcl A_name		char (*) varying parameter;
  dcl A_new_value		fixed bin (35) parameter;
  dcl A_ocu_datap		ptr parameter;
  dcl A_offset		fixed bin (18) unsigned parameter;
  dcl A_offsetname		char (*) varying parameter;
  dcl A_patch_section	char (*) parameter;
  dcl A_relocationp		ptr parameter;
  dcl A_section		fixed bin (3) parameter;
  dcl A_segname		char (*) varying parameter;
  dcl A_side		char (*) parameter;
  dcl A_type		fixed bin (3) parameter;
  dcl A_word_count		fixed bin (18) unsigned parameter;
  dcl A_wordp		ptr parameter;

  /* procedures */

  dcl expand_pathname_	entry (char (*), char (*), char (*),
			fixed bin (35));
  dcl get_group_id_		entry () returns (char (32));
  dcl get_shortest_path_	entry (char (*)) returns (char (168));
  dcl get_system_free_area_	entry () returns (ptr);
  dcl get_temp_segment_	entry (char (*), ptr, fixed bin (35));
  dcl get_temp_segments_	entry (char (*), (*) ptr, fixed bin (35));
  dcl hcs_$fs_get_path_name	entry (ptr, char (*), fixed bin, char (*),
			fixed bin (35));
  dcl hcs_$set_bc		entry (char (*), char (*), fixed bin (24),
			fixed bin (35));
  dcl hcs_$star_		entry (char (*), char (*), fixed bin (2), ptr,
			fixed bin, ptr, ptr, fixed bin (35));
  dcl hcs_$status_mins	entry (ptr, fixed bin (2), fixed bin (24),
			fixed bin (35));
  dcl object_info_$brief	entry (ptr, fixed bin (24), ptr,
			fixed bin (35));
  dcl release_temp_segment_	entry (char (*), ptr, fixed bin (35));
  dcl release_temp_segments_	entry (char (*), (*) ptr, fixed bin (35));
  dcl sub_err_		entry () options (variable);
  dcl tssi_$get_segment	entry (char (*), char (*), ptr, ptr,
			fixed bin (35));
  dcl tssi_$finish_segment	entry (ptr, fixed bin (24), bit (36) aligned,
			ptr, fixed bin (35));
  dcl tssi_$clean_up_segment	entry (ptr);

  /* external */

  dcl error_table_$bad_arg	external fixed bin (35);
  dcl error_table_$improper_data_format
			external fixed bin (35);
  dcl error_table_$inconsistent_object_msf
			external fixed bin (35);
  dcl error_table_$namedup	external fixed bin (35);
  dcl error_table_$out_of_sequence
			external fixed bin (35);
  dcl error_table_$unimplemented_version
			external fixed bin (35);

  /* static */

  dcl vlh_size		fixed bin static;
  dcl lk_size		fixed bin static;
  dcl dh_size		fixed bin static;
  dcl def_size		fixed bin static;

  /* based */

  dcl 01 de		aligned like def_entry based (dep);
  dcl 01 di		aligned based (dip),
       02 header		aligned like def_info.header,
       02 def		dim (0 refer (di.N_defs)) like def_entry;
  dcl 01 frti		aligned based (frtip),
       02 header		aligned like firstref_trap_info.header,
       02 trap		dim (0 refer (frti.N_traps))
			like firstref_trap_entry;
  dcl 01 li		aligned based (lip),
       02 header		aligned like link_info.header,
       02 link		dim (0 refer (li.N_links)) like link_entry;
  dcl 01 si		aligned based (sip),
       02 header		aligned like static_info.header,
       02 static_word	dim (0 refer (si.N_static_words)) bit (36);
  dcl 01 sbi		aligned based (sbip),
       02 header		aligned like symbol_info.header,
       02 symbol_word	dim (0 refer (sbi.N_symbol_words)) bit (36);
  dcl 01 ti		aligned based (tip),
       02 header		aligned like text_info.header,
       02 text_word		dim (0 refer (ti.N_text_words)) bit (36);
  dcl 01 mi		aligned based (mip),
       02 header		aligned like msf_info.header,
       02 component		dim (0 refer (mi.N_components))
			like msf_info.component;
  dcl 01 w15		aligned based (wordp),
       02 pad1		bit (3) unaligned,
       02 left		fixed bin (15) unsigned unaligned,
       02 pad2		bit (18) unaligned;
  dcl 01 w18		aligned based (wordp),
       02 left		fixed bin (18) unsigned unaligned,
       02 right		fixed bin (18) unsigned unaligned;
  dcl 01 w15s		aligned based (wordp),
       02 pad1		bit (3) unaligned,
       02 left		fixed bin (14) unaligned,
       02 pad2		bit (18) unaligned;
  dcl 01 w18s		aligned based (wordp),
       02 left		fixed bin (17) unaligned,
       02 right		fixed bin (17) unaligned;

  /* automatic */

  dcl c			fixed bin automatic;
  dcl call_relp		fixed bin (18) unsigned automatic;
  dcl defx		fixed bin automatic;
  dcl dep			ptr automatic;
  dcl dip			ptr automatic;
  dcl dname		char (168) automatic;
  dcl ec			fixed bin (35) automatic;
  dcl ename		char (32) automatic;
  dcl frtip		ptr automatic;
  dcl i			fixed bin automatic;
  dcl info_relp		fixed bin (18) unsigned automatic;
  dcl lip			ptr automatic;
  dcl 01 linke		aligned like link_entry automatic;
  dcl linkx		fixed bin automatic;
  dcl mode		bit (36) aligned automatic;
  dcl next_word		fixed bin (18) unsigned automatic;
  dcl odp			ptr automatic;
  dcl reloc_infop		ptr automatic;
  dcl relp		fixed bin (18) unsigned automatic;
  dcl sbip		ptr automatic;
  dcl sip			ptr automatic;
  dcl static_arrayp		ptr automatic;
  dcl strx		fixed bin automatic;
  dcl symbol_arrayp		ptr automatic;
  dcl text_arrayp		ptr automatic;
  dcl tip			ptr automatic;
  dcl mip			ptr automatic;
  dcl wordp		ptr automatic;

  /* conditions */

  dcl cleanup		condition;
  dcl size		condition;

  /* builtin */

  dcl addr		builtin;
  dcl addwordno		builtin;
  dcl bit			builtin;
  dcl char		builtin;
  dcl clock		builtin;
  dcl copy		builtin;
  dcl currentsize		builtin;
  dcl divide		builtin;
  dcl fixed		builtin;
  dcl hbound		builtin;
  dcl index		builtin;
  dcl ltrim		builtin;
  dcl min			builtin;
  dcl mod			builtin;
  dcl null		builtin;
  dcl ptr			builtin;
  dcl rel			builtin;
  dcl rtrim		builtin;
  dcl search		builtin;
  dcl string		builtin;
  dcl substr		builtin;
  dcl translate		builtin;
  dcl unspec		builtin;

  return;

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


open:
  entry (A_dir_name,		/** output dir name	  (in )	*/
       A_entry_name,		/** output entry name (in )	*/
       A_flags,			/** option flags	  (in )	*/
       A_ocu_datap,			/** ocu_data pointer  (out)	*/
       A_code);			/** error code	  (out)	*/

  /*** ****************************************************************/
  /***							*/
  /***	Name:	ocu_$open					*/
  /***	Input:	dir_name, entry_name, flags			*/
  /***	Function:	allocates all of the structures to be used and	*/
  /***		initialize them.  Since most of the structures	*/
  /***		are extensible, each structure has its own temp	*/
  /***		seg.					*/
  /***	Output:	ocu_datap, code				*/
  /***							*/
  /*** ****************************************************************/

  /* arrange to clean up if we are interrupted */

  ocu_datap, A_ocu_datap = null;

  vlh_size = currentsize (s_vlh);
  lk_size = currentsize (s_lk);
  dh_size = currentsize (s_dh);
  def_size = currentsize (s_def);

  on cleanup
    begin;
    if ocu_datap ^= null
      then do;
        if temp_segs (1) ^= null
	then call release_temp_segments_ ("ocu_", temp_segs, 0);
        call release_temp_segment_ ("ocu_", ocu_datap, 0);
      end;
    A_ocu_datap = null;
  end;

  /* get the ocu_data temp seg */

  call get_temp_segment_ ("ocu_", ocu_datap, ec);
  if ec ^= 0
    then call exit (ec);

  /* get the temp segs for the extensible structures */

  call get_temp_segments_ ("ocu_", temp_segs, ec);
  if ec ^= 0
    then call exit (ec);

  /* now set up the rest of the ocu_data structure */

  ocu_data.version = ocu_data_version_1;
  string (ocu_data.flags) = ""b;
  ocu_data.target.dir = A_dir_name;
  ocu_data.target.entry = A_entry_name;
  ocu_data.msf_info.component_count = 0;
  ocu_data.msf_info.my_component = 0;
  if (A_flags & OPEN_FLAGS_BOUND)
    then ocu_data.flags.bound = true;
  if A_flags & OPEN_FLAGS_RELOCATABLE
    then ocu_data.flags.relocatable = true;
  if A_flags & OPEN_FLAGS_PROCEDURE
    then ocu_data.flags.procedure = true;
  if A_flags & OPEN_FLAGS_SEPARATE_STATIC
    then ocu_data.flags.separate_static = true;
  if A_flags & OPEN_FLAGS_PERPROCESS_STATIC
    then ocu_data.flags.perprocess_static = true;
  if A_flags & OPEN_FLAGS_NO_HASHTABLE
    then ocu_data.flags.no_hash_table = true;

  /* the variables determining the sizes of the extensible structures	*/
  /* are assumed to be zero since they are in temp-segs which should	*/
  /* be zero length when received.				*/

  /* set the returned parameter */

  A_ocu_datap = ocu_datap;

  call exit (0);

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


close:
  entry (A_ocu_datap,		/** ocu_data pointer  (in )	*/
       A_code);			/** error code	  (out)	*/

  /*** ****************************************************************/
  /***							*/
  /***	Name:	ocu_$close				*/
  /***	Input:	ocu_datap					*/
  /***	Function:	closes the ocu_ invocation and creates the actual	*/
  /***		object segment from the tables created.		*/
  /***	Output:	code					*/
  /***							*/
  /*** ****************************************************************/

  /* check out the pointer we received */

  ocu_datap = A_ocu_datap;
  if ocu_data.version ^= ocu_data_version_1
    then call exit (error_table_$unimplemented_version);

  /* arrange to cleanup if this is interrupted */

  ocu_data.target.acinfop = null;
  reloc_infop = null;

  /* perform a few consistency checks before building the object */


  on cleanup
    begin;
    if ocu_datap ^= null
      then if ocu_data.target.acinfop ^= null
	   then call tssi_$clean_up_segment (ocu_data.target.acinfop);
    if reloc_infop ^= null
      then call release_temp_segment_ ("ocu_", reloc_infop, 0);
  end;

  /* create/truncate the target object segment */

  call tssi_$get_segment (ocu_data.target.dir, ocu_data.target.entry,
       ocu_data.target.segp, ocu_data.target.acinfop, ec);
  if ec ^= 0
    then call exit (ec);

  /* allocate a temp_seg for the relocation blocks */

  call get_temp_segment_ ("ocu_", reloc_infop, ec);

  reloc_infop -> relinfo_blocks.no_relinfo = ^ocu_data.flags.relocatable;

  /* create each section of the object segment */

  call create_text (ocu_datap, reloc_infop);
  call create_defs (ocu_datap, reloc_infop);
  call create_link (ocu_datap, reloc_infop);
  call create_stat (ocu_datap);
  call create_symb (ocu_datap, reloc_infop);
  call create_obj_map (ocu_datap);

  /* release the relocation_info temp seg */

  call release_temp_segment_ ("ocu_", reloc_infop, ec);
  reloc_infop = null;

  /* determine what ACL mode should be on the resulting object */

  if ocu_data.flags.procedure
    then mode = RE_ACCESS;
    else mode = RW_ACCESS;

  /* and finish off the object segment */

  call tssi_$finish_segment (ocu_data.target.segp, ocu_data.target.bc,
       mode, ocu_data.target.acinfop, ec);

  /* now release the storage */

  call release (ocu_datap);
  A_ocu_datap = null;

  call exit (ec);

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


release:
  entry (A_ocu_datap);		/** ocu_data pointer    (in )	*/

  /*** ****************************************************************/
  /***							*/
  /***	Name:	ocu_$release				*/
  /***	Input:	ocu_datap					*/
  /***	Function:	frees the storage associated with an open ocu_	*/
  /***		invocation.  This entry is provided for use by	*/
  /***		cleanup handlers.				*/
  /***	Output:	none					*/
  /***							*/
  /*** ****************************************************************/

  /* release the temp segs for the extensible structures, and then	*/
  /* the ocu_data structure itself.				*/

  ocu_datap = A_ocu_datap;
  if ocu_datap ^= null
    then do;
      if ocu_data_ptrs.temp_segs (1) ^= null
        then call release_temp_segments_ ("ocu_", ocu_data_ptrs.temp_segs, 0);
      call release_temp_segment_ ("ocu_", ocu_datap, 0);
    end;

  return;

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


emit_text:
  entry (A_ocu_datap,		/** ocu_data pointer  (in )	*/
       A_wordp,			/** word array ptr	  (in )	*/
       A_relocationp,		/** relocation string (in )	*/
       A_word_count)		/** word count	  (in )	*/
       returns (fixed bin (18) uns);	/** text relp	  (out)	*/

  /*** ****************************************************************/
  /***							*/
  /***	Name:	ocu_$emit_text				*/
  /***	Input:	ocu_datap, wordp, relocationp, word_count	*/
  /***	Function:	appends a block of words to the text section of	*/
  /***		the object segment.  Relocation info is also	*/
  /***		appended for use in relocating linkage section	*/
  /***		references.  If the object segment being created	*/
  /***		is not relocatable, the relocation information	*/
  /***		will not be placed into the final object segment. */
  /***	Output:	text_relp					*/
  /***							*/
  /*** ****************************************************************/

  /* check out the pointer we received */

  ocu_datap = A_ocu_datap;
  if ocu_data.version ^= ocu_data_version_1
    then call sub_err_ (error_table_$unimplemented_version, "argument",
	    ACTION_CANT_RESTART, null, 0);

  /* get the pointers to the structures to be used */

  tip = ocu_data.text_infop;

  /* set up the word array and relocation string */

  word_arrayp = A_wordp;
  word_arrayl = A_word_count;

  reloc_strp = A_relocationp;
  reloc_strl = A_word_count * 2;

  /* get the info for the text section relocation info string */

  relinfo_strp = ocu_data.text_relinfop;
  relinfo_strl = ti.text_relinfol + reloc_strl;

  /* save the relpointer to the new text */

  relp = ti.N_text_words;

  /* copy the text words into the text section table */

  next_word = ti.N_text_words + 1;
  ti.N_text_words = ti.N_text_words + A_word_count;
  text_arrayp = addr (ti.text_word (next_word));

  unspec (text_arrayp -> word_array) = unspec (word_array);

  /* append the relinfo string to the text section relinfo string */

  substr (relinfo_str, ti.text_relinfol + 1, reloc_strl) =
       translate (reloc_str, STD_RELINFO, ALM_RELINFO);
  ti.text_relinfol = relinfo_strl;

  return (relp);

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


emit_definition:
  entry (A_ocu_datap,		/** ocu_data pointer  (in )	*/
       A_name,			/** definition name	  (in )	*/
       A_section,			/** target section	  (in )	*/
       A_offset,			/** offset in section (in )	*/
       A_flags)			/** definition flags  (in )	*/
       returns (fixed bin (18) uns);	/** definition relp	  (out)	*/

  /*** ****************************************************************/
  /***							*/
  /***	Name:	ocu_$emit_definition			*/
  /***	Input:	ocu_datap, name, section, offset, flags		*/
  /***	Function:	appends a single non-class-3 definition to the	*/
  /***		definition list.  If the definition target is in	*/
  /***		the static section, and we are combining the	*/
  /***		static and linkage sections, then convert the	*/
  /***		static reference to a linkage reference.	*/
  /***	Output:	definition_relp				*/
  /***							*/
  /*** ****************************************************************/

  /* check out the pointer we received */

  ocu_datap = A_ocu_datap;
  if ocu_data.version ^= ocu_data_version_1
    then call sub_err_ (error_table_$unimplemented_version,
	    "argument", ACTION_CANT_RESTART, null, 0);

  /* get a pointer to the definition list structure */

  dip = ocu_data.def_infop;

  /* make sure this call is preceeded by a call to ocu_$emit_definition */

  if di.N_defs = 0
    then call sub_err_ (error_table_$out_of_sequence, "sequence",
	    ACTION_CANT_RESTART, null, 0,
	    "^/ocu_$emit_segname must be called " ||
	    "before calling ocu_$emit_definition");

  /* increment the number of definitions */

  di.N_defs = di.N_defs + 1;

  dep = addr (di.def (di.N_defs));

  /* set up the definition, and add the name to the stringmap, if not	*/
  /* already present.					*/

  de.strx = find_string (ocu_datap, rtrim (A_name));

  de.class = A_section;
  de.offset = A_offset;

  string (de.flags) = ""b;
  
  if A_flags & DEFINITION_FLAGS_IGNORE
    then de.flags.ignore = true;
  if A_flags & DEFINITION_FLAGS_ENTRY
    then de.flags.entry = true;
  if A_flags & DEFINITION_FLAGS_RETAIN
    then de.flags.retain = true;
  if A_flags & DEFINITION_FLAGS_INDIRECT
    then de.flags.indirect = true;
  de.dup_tbl_relp = 0;

  /* return calculated definition offset */

  return (dh_size + ((di.N_defs - 1) * def_size));

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


emit_segname:
  entry (A_ocu_datap,		/** ocu_data pointer  (in )	*/
       A_name,			/** segname	  (in )	*/
       A_flags)			/** definition flags  (in )	*/
       returns (fixed bin (18) uns);	/** definition relp	  (out)	*/

  /*** ****************************************************************/
  /***							*/
  /***	Name:	ocu_$emit_segname				*/
  /***	Input:	ocu_datap, name, flags			*/
  /***	Function:	emits a single class-3 segname definition.	*/
  /***	Output:	definition_relp				*/
  /***							*/
  /*** ****************************************************************/

  /* check out the pointer we received */

  ocu_datap = A_ocu_datap;
  if ocu_data.version ^= ocu_data_version_1
    then call sub_err_ (error_table_$unimplemented_version,
	    "argument", ACTION_CANT_RESTART, null, 0);

  /* get a pointer to the definition list structure */

  dip = ocu_data.def_infop;

  /* make sure this is not a duplicate segname */

  strx = find_string (ocu_datap, rtrim (A_name));

  do defx = 1 to di.N_defs;
    if di.def (defx).class = 3 & di.def (defx).strx = strx
      then call sub_err_ (error_table_$namedup, "argument",
	      ACTION_CANT_RESTART, null, 0,
	      "^/There is already a segname definition ""^a""", A_name);
  end;

  /* increment the number of definitions */

  di.N_defs = di.N_defs + 1;

  /* create the segname, and add the name to the stringmap if not	*/
  /* already present.					*/

  dep = addr (di.def (defx));

  de.strx = strx;
  de.class = 3;
  de.offset = 0;
  de.dup_tbl_relp = 0;

  string (de.flags) = ""b;
  if A_flags & DEFINITION_FLAGS_IGNORE
    then de.flags.ignore = true;
  if A_flags & DEFINITION_FLAGS_ENTRY
    then de.flags.entry = true;
  if A_flags & DEFINITION_FLAGS_RETAIN
    then de.flags.retain = true;

  if (A_flags & DEFINITION_FLAGS_INDIRECT) ^= ""b
    then call sub_err_ (error_table_$bad_arg, "argument",
	    ACTION_CAN_RESTART, null, 0,
	    "^/Segname definitions may not be indirect.");

  /* return the calculated definition relpointer */

  return (dh_size + ((defx - 1) * def_size));

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


emit_msf_map:
  entry (A_ocu_datap,		/** ocu_data pointer    (in )	*/
       A_component_count,		/** no. of components   (in )	*/
       A_my_component);		/** this component no   (in )	*/

  /*** ****************************************************************/
  /***							*/
  /***	Name:	ocu_$emit_msf_map				*/
  /***	Input:	ocu_datap, component_count, my_component	*/
  /***	Function:	saves the values to be used for the msf_map in	*/
  /***		the definition structure.			*/
  /***	Output:	code					*/
  /***							*/
  /*** ****************************************************************/

  /* check out the pointer we were passed */

  ocu_datap = A_ocu_datap;
  if ocu_data.version ^= ocu_data_version_1
    then call sub_err_ (error_table_$unimplemented_version,
	    "argument", ACTION_CANT_RESTART, null, 0);

  if A_component_count <= 0
    then call sub_err_ (error_table_$bad_arg, "argument",
	    ACTION_CANT_RESTART, null, 0,
	    "^/The number of components in an object MSF must be positive."
	    );

  if (A_my_component < 0) | (A_my_component > A_component_count)
    then call sub_err_ (error_table_$bad_arg, "argument",
	    ACTION_CANT_RESTART, null, 0,
	    "^/The component number must be in the range " ||
	    "0 .. component_count.");

  /* store the count and component number in ocu_data */

  ocu_data.component_count = A_component_count;
  ocu_data.my_component = A_my_component;

  return;

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


emit_static:
  entry (A_ocu_datap,		/** ocu_data pointer    (in )	*/
       A_wordp,			/** static word array   (in )	*/
       A_word_count)		/** size of word array  (in )	*/
       returns (fixed bin (18) uns);	/** static relp	    (out)	*/

  /*** ****************************************************************/
  /***							*/
  /***	Name:	ocu_$emit_static				*/
  /***	Input:	ocu_datap, wordp, word_count			*/
  /***	Function:	adds a block of words to the static section.	*/
  /***	Output:	static_relp				*/
  /***							*/
  /*** ****************************************************************/

  /* check out the pointer we were passed */

  ocu_datap = A_ocu_datap;
  if ocu_data.version ^= ocu_data_version_1
    then call sub_err_ (error_table_$unimplemented_version, "argument",
	    ACTION_CANT_RESTART, null, 0);

  /* get a pointer to the static section info structure */

  sip = ocu_data.static_infop;

  /* set up the input word array */

  word_arrayp = A_wordp;
  word_arrayl = A_word_count;

  /* determine the return relpointer offset */

  relp = si.N_static_words;

  /* copy the word array into the static info structure */

  next_word = si.N_static_words + 1;
  si.N_static_words = si.N_static_words + A_word_count;
  static_arrayp = addr (si.static_word (next_word));

  unspec (static_arrayp -> word_array) = unspec (word_array);

  return (relp);

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


emit_link:
  entry (A_ocu_datap,		/** ocu_data pointer    (in )	*/
       A_type,			/** link type	    (in )	*/
       A_class,			/** link class	    (in )	*/
       A_segname,			/** target segment	    (in )	*/
       A_offsetname,		/** target definition   (in )	*/
       A_expression,		/** word offset	    (in )	*/
       A_modifier,			/** link modifier	    (in )	*/
       A_init_infop)		/** initialization	    (in )	*/
       returns (fixed bin (18) uns);	/** link relp	    (out)	*/

  /*** ****************************************************************/
  /***							*/
  /***	Name:	ocu_$emit_link				*/
  /***	Input:	ocu_datap, type, class, segname, offsetname,	*/
  /***		expression, modifier, init_infop		*/
  /***	Function:	emits a single external link. The link relpointer	*/
  /***		returned is calculated as if the static section	*/
  /***		is separate.  If the static section is internal	*/
  /***		to the linkage section, references to the linkage */
  /***		section in the text, symbol, and definition	*/
  /***		sections will be relocated to the actual location	*/
  /***		of the link.				*/
  /***	Output:	link_relp					*/
  /***							*/
  /*** ****************************************************************/

  /* check out the pointer we were passed */

  ocu_datap = A_ocu_datap;
  if ocu_data.version ^= ocu_data_version_1
    then call sub_err_ (error_table_$unimplemented_version, "argument",
	    ACTION_CANT_RESTART, null, 0);

  /* get a pointer to the link array structure */

  lip = ocu_data.link_infop;

  /* locate/create the expression_word, type_pair, strings, etc. */

  unspec (linke) = ""b;
  linke.modifier = A_modifier;
  linke.exp_wordx = find_exp_word (ocu_datap, A_expression, A_type, A_class,
       A_segname, A_offsetname, A_init_infop);

  /* search for a link with the same expression_word and modifier. If	*/
  /* found, return a relpointer to that link.			*/

  do linkx = 1 to li.N_links;
    if unspec (li.link (linkx)) = unspec (linke)
      then return (vlh_size + (lk_size * (linkx - 1)));
  end;

  /* if not found, create a new link */

  linkx, li.N_links = li.N_links + 1;
  unspec (li.link (linkx)) = unspec (linke);

  /* return the relpointer to the new link */

  return (vlh_size + (lk_size * (linkx - 1)));

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


emit_partial_link:
  entry (A_ocu_datap,		/** ocu_data pointer    (in )	*/
       A_component,			/** target component    (in )	*/
       A_section,			/** target section	    (in )	*/
       A_offset,			/** offset in section   (in )	*/
       A_modifier)			/** link modifier	    (in )	*/
       returns (fixed bin (18) uns);	/** link relp	    (out)	*/

  /*** ****************************************************************/
  /***							*/
  /***	Name:	ocu_$emit_partial_link			*/
  /***	Input:	ocu_datap, component, section, offset, modifier	*/
  /***	Function:	emits a single partially snapped link in the	*/
  /***		linkage section of the new object.		*/
  /***	Output:	link_relp					*/
  /***							*/
  /*** ****************************************************************/

  /* check out the pointer we were passed */

  ocu_datap = A_ocu_datap;
  if ocu_data.version ^= ocu_data_version_1
    then call sub_err_ (error_table_$unimplemented_version,
	    "argument", ACTION_CANT_RESTART, null, 0);

  /* get a pointer to the link array structure */

  lip = ocu_data.link_infop;

  linke.exp_wordx = 0;
  linke.type = A_section;
  linke.component = A_component;
  linke.offset = A_offset;
  linke.modifier = A_modifier;

  /* look for an identical partial link and use it if one exists */

  do linkx = 1 to li.N_links;
    if unspec (li.link (linkx)) = unspec (linke)
      then return (vlh_size + (lk_size * (linkx - 1)));
  end;

  /* if no matching link is found, generate a new link */

  linkx, li.N_links = li.N_links + 1;

  unspec (li.link (linkx)) = unspec (linke);

  /* return a relpointer to the new partial link */

  return (vlh_size + (lk_size * (linkx - 1)));

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


emit_firstref_trap:
  entry (A_ocu_datap,		/** ocu_data pointer    (in )	*/
       A_call_relp,			/** relp to call link   (in )	*/
       A_info_relp);		/** relp to info link   (in )	*/

  /*** ****************************************************************/
  /***							*/
  /***	Name:	ocu_$emit_firtstref_trap			*/
  /***	Input:	ocu_datap, call_relp, info_relp		*/
  /***	Function:	adds a first reference trap to the firstref trap	*/
  /***		block to be placed into the linkage section.  If	*/
  /***		no firstref traps are emitted, no trap block is	*/
  /***		placed in the linkage section.		*/
  /***	Output:	none					*/
  /***							*/
  /*** ****************************************************************/

  /* check out the pointer we were passed */

  ocu_datap = A_ocu_datap;
  if ocu_data.version ^= ocu_data_version_1
    then call sub_err_ (error_table_$unimplemented_version,
	    "argument", ACTION_CANT_RESTART, null, 0);

  /* get a pointer to the firstref trap array */

  frtip = ocu_data.firstref_trap_infop;

  /* increment the number of traps */

  frti.N_traps = frti.N_traps + 1;

  /* copy the relpointers into the trap array */

  frti.trap (frti.N_traps).call_relp = A_call_relp;
  frti.trap (frti.N_traps).info_relp = A_info_relp;

  return;

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


emit_symbol:
  entry (A_ocu_datap,		/** ocu_data pointer    (in )	*/
       A_wordp,			/** symbol word array   (in )	*/
       A_relocationp,		/** relocation string   (in )	*/
       A_word_count)		/** word count	    (in )	*/
       returns (fixed bin (18) uns);	/** symbol relp	    (out)	*/

  /*** ****************************************************************/
  /***							*/
  /***	Name:	ocu_$emit_symbol				*/
  /***	Input:	ocu_datap, wordp, relocationp, word_count	*/
  /***	Function:	emits a block of symbol section words and their	*/
  /***		associated relocation information.  Note that	*/
  /***		while the relocation information is located in	*/
  /***		the symbol section, it should not be emitted	*/
  /***		by the caller.  It will be synthesized by ocu_	*/
  /***		and placed at the end of the symbol section.	*/
  /***		Note also that ocu_ assumes the first thing in	*/
  /***		the symbol section is a std_symbol_header	*/
  /***		structure into which the relocation offsets will	*/
  /***		patched when the object segment is assembled.	*/
  /***	Output:	symbol_relp				*/
  /***							*/
  /*** ****************************************************************/

  /* check out the pointer we were passed */

  ocu_datap = A_ocu_datap;
  if ocu_data.version ^= ocu_data_version_1
    then call sub_err_ (error_table_$unimplemented_version, "argument",
	    ACTION_CANT_RESTART, null, 0);

  /* get a pointer to the symbol section info structure */

  sbip = ocu_data.symbol_infop;

  /* set up the input word array and relocation string */

  word_arrayp = A_wordp;
  word_arrayl = A_word_count;

  reloc_strp = A_relocationp;
  reloc_strl = A_word_count * 2;

  /* set up the symbol section relocation string */

  relinfo_strp = ocu_data.symbol_relinfop;
  relinfo_strl = sbi.symbol_relinfol + reloc_strl;

  /* determine the return value */

  relp = sbi.N_symbol_words;

  /* copy the word array into the symbol section */

  next_word = sbi.N_symbol_words + 1;
  sbi.N_symbol_words = sbi.N_symbol_words + A_word_count;
  symbol_arrayp = addr (sbi.symbol_word (next_word));

  unspec (symbol_arrayp -> word_array) = unspec (word_array);

  /* append the relocation sting to the symbol section relocation string */

  substr (relinfo_str, sbi.symbol_relinfol + 1, reloc_strl) =
       translate (reloc_str, STD_RELINFO, ALM_RELINFO);

  sbi.symbol_relinfol = relinfo_strl;

  return (relp);

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


backpatch:
  entry (A_ocu_datap,		/** ocu_data pointer    (in )	*/
       A_patch_section,		/** section to patch    (in )	*/
       A_offset,			/** word to patch	    (in )	*/
       A_side,			/** halfword to patch   (in )	*/
       A_new_value);		/** value to patch in   (in )	*/

  /*** ****************************************************************/
  /***							*/
  /***	Name:	ocu_$backpatch				*/
  /***	Input:	ocu_datap, patch_section, offset, side, value	*/
  /***	Function:	allows specific halfwords withing the text and	*/
  /***		symbol sections to be patched.  This is to allow	*/
  /***		changes to be made after the section has been	*/
  /***		emitted to install values unknown at that time.	*/
  /***		Halfwords can be patched as signed or unsigned	*/
  /***		15 or 18 bit values.  Note that the use of 15	*/
  /***		bit patching is restricted to the left halfword	*/
  /***		of text section references.  This reflects the	*/
  /***		restriction on use of 15 bit relocation info.	*/
  /***	Output:	none					*/
  /***							*/
  /*** ****************************************************************/

  /* check out the pointer we received */

  ocu_datap = A_ocu_datap;
  if ocu_data.version ^= ocu_data_version_1
    then call sub_err_ (error_table_$unimplemented_version, "argument",
	    ACTION_CANT_RESTART, null, 0);

  /* make sure the offset is positive */

  if A_offset < 0
    then call sub_err_ (error_table_$bad_arg, "argument",
	    ACTION_CANT_RESTART, null, 0,
	    "^/Negative word offset is invalid.");

  /* NB:  The pl1 prefix (size): is used to determine whether the	*/
  /*	value given is suitable for the type of patching being done	*/
  /*	since overlays are used with appropriate precision and sign	*/
  /*	the parameter is declared fixed bin (35) and we let PL/I	*/
  /*	figure out whether this is legitimate or not.		*/

  on size
    call sub_err_ (error_table_$bad_arg,
         "argument", ACTION_CANT_RESTART, null, 0,
         "^/Invalid value specified for halfword.");

  /* determine which section is being patched */

  if A_patch_section = "text"
    then do;

      /* patching text section:  make sure the word offset is OK.	*/

      tip = ocu_data.text_infop;
      if A_offset >= ti.N_text_words
        then call sub_err_ (error_table_$bad_arg, "argument",
	        ACTION_CANT_RESTART, null, 0,
	        "^/Specified offset is not within the text section.");

      wordp = addr (ti.text_word (A_offset + 1));

      /* enable size checking and asign to an appropriate overlay	*/
      /* based on the side specification given.			*/

(size):
      if A_side = "left 15 unsigned"
        then w15.left = A_new_value;
      else if A_side = "left 15 signed"
        then w15s.left = A_new_value;
      else if A_side = "left 18 unsigned"
        then w18.left = A_new_value;
      else if A_side = "left 18 signed"
        then w18s.left = A_new_value;
      else if A_side = "right 18 unsigned"
        then w18.right = A_new_value;
      else if A_side = "right 18 signed"
        then w18s.right = A_new_value;
      else call sub_err_ (error_table_$bad_arg, "argument",
	      ACTION_CANT_RESTART, null, 0,
	      "^/Invalid text section side specification.");
(nosize):
    end;
  else if A_patch_section = "symbol"
    then do;

      /* symbol section:  Make sure the offset is in the section	*/

      sbip = ocu_data.symbol_infop;
      if A_offset >= sbi.N_symbol_words
        then call sub_err_ (error_table_$bad_arg, "argument",
	        ACTION_CANT_RESTART, null, 0,
	        "^/Specified offset is not within the symbol section.");

      wordp = addr (sbi.symbol_word (A_offset + 1));

      /* enable size checking and assign to the appropriate overlay	*/

(size):
      if A_side = "left 18 unsigned"
        then w18.left = A_new_value;
      else if A_side = "left 18 signed"
        then w18s.left = A_new_value;
      else if A_side = "right 18 unsigned"
        then w18.right = A_new_value;
      else if A_side = "right 18 signed"
        then w18s.right = A_new_value;
      else call sub_err_ (error_table_$bad_arg, "argument",
	      ACTION_CANT_RESTART, null, 0,
	      "^/Invalid symbol section side specification.");
(nosize):
    end;
  else if A_patch_section = "static"
    then do;

      /* static section: make sure the offset is in the section	*/

      sip = ocu_data.static_infop;
      if A_offset >= si.N_static_words
        then call sub_err_ (error_table_$bad_arg, "argument",
	        ACTION_CANT_RESTART, null, 0,
	        "^/Specified offset is not within the static section.");

      wordp = addr (si.static_word (A_offset + 1));

      /* enable size checking and assign to the appropriate overlay	*/

(size):
      if A_side = "left 18 unsigned"
        then w18.left = A_new_value;
      else if A_side = "left 18 signed"
        then w18s.left = A_new_value;
      else if A_side = "right 18 unsigned"
        then w18.right = A_new_value;
      else if A_side = "right 18 signed"
        then w18s.right = A_new_value;
      else call sub_err_ (error_table_$bad_arg, "argument",
	      ACTION_CANT_RESTART, null, 0,
	      "^/Invalid static section side specification.");
(nosize):
    end;

  /* unknown section */

  else call sub_err_ (error_table_$bad_arg, "argument",
	  ACTION_CANT_RESTART, null, 0,
	  "^/Invalid section specification.");

  return;

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


create_msf:
  entry (A_component_listp,		/** component array	    (in )	*/
       A_component_count,		/** component count     (in )	*/
       A_generator_infop,		/** generator info	    (in )	*/
       A_code);			/** error code	    (out)	*/

  /*** ****************************************************************/
  /***							*/
  /***	Name:	ocu_$create_msf				*/
  /***	Input:	component_listp, component_count		*/
  /***	Function:	This entrypoint is used to construct component 0	*/
  /***		of an Object MSF.  This involves creating	*/
  /***		an object segment containing the definitions for	*/
  /***		each accessible point in each of the other MSF	*/
  /***		components, generating transfer vectors and	*/
  /***		partial links in the internal static area and	*/
  /***		link array of the linkage section (respectively)	*/
  /***		and generating the first reference trap to cause	*/
  /***		the snapping of partial links.  Note that it	*/
  /***		is NOT in this procedures contract to create the	*/
  /***		actual Multi-Segment File.  It will validate	*/
  /***		that the segments to be used are all in the same	*/
  /***		directory, have the appropriate names, have	*/
  /***		msf_maps, and that there are no other segments	*/
  /***		or directories in the containing directory	*/
  /***		It will then create component 0 in the same	*/
  /***		directory and set the bit count on the directory.	*/
  /***	Output:	code					*/
  /***							*/
  /*** ****************************************************************/

  /* get a temp_segment for out working structure */

  mip = null;
  odp = null;

  on cleanup
    begin;
    if mip ^= null
      then call release_temp_segment_ ("ocu_", mip, 0);
    if odp ^= null
      then call release (odp);
  end;

  call get_temp_segment_ ("ocu_", mip, ec);

  /* copy the arguments into the working structure */

  mi.containing_dir = "";
  mi.gen_info = A_generator_infop -> gen_info;
  mi.N_components, component_count = A_component_count;
  component_listp = A_component_listp;

  /* make sure the segment pointers point to the base of the segment */

  do c = 1 to component_count;
    mi.component (c).segp = ptr (component_list (c), 0);
  end;

  /* make sure all of the components are correct */

  do c = 1 to component_count;
    call validate_component (mip, c);
  end;

  call open (mi.containing_dir, "0",
       OPEN_FLAGS_RELOCATABLE | OPEN_FLAGS_PROCEDURE | OPEN_FLAGS_BOUND,
       odp, ec);
  if ec ^= 0
    then call exit (ec);

  /* emit the first reference trap and associated links */

  call_relp = emit_link (odp, (LINK_REFNAME_OFFSETNAME), 0,
       "msf_prelink_", "msf_prelink_", 0, ""b, null);
  info_relp = emit_link (odp, (LINK_SELF_BASE), (SECTION_LINK), "", "",
       0, ""b, null);
  call emit_firstref_trap (odp, call_relp, info_relp);

  /* emit the component 0 msf map */

  call emit_msf_map (odp, component_count + 1, 0);

  /* copy the external definitions for each component */

  do c = 1 to mi.N_components;
    call copy_defs (odp, mip, c);
  end;

  /* create the symbol section */

  call mk_symbol_scn (odp, mip);

  /* close the ocu_ invocation to create component 0 */

  call close (odp, ec);

  /* set the bit count on the MSF */

  call expand_pathname_ (mi.containing_dir, dname, ename, ec);
  call hcs_$set_bc (dname, ename, mi.N_components + 1, ec);

  /* release the msf_info structure */

  call release_temp_segment_ ("ocu_", mip, ec);

  call exit (ec);

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


exit:
  proc (ec);			/** error code	    (in )	*/

  /*** ****************************************************************/
  /***							*/
  /***	Name:	exit					*/
  /***	Input:	ec					*/
  /***	Function:	returns from the object creation utilities	*/
  /***		returning a specified error code.		*/
  /***	Output:	none					*/
  /***							*/
  /*** ****************************************************************/

  /* parameters */

  dcl ec			fixed bin (35) parameter;

  A_code = ec;

  /* do non-local goto to unwind stack and return from ocu_ */

  goto EXIT;

  end exit;

EXIT:
  return;

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


find_exp_word:
  proc (odp,			/** pointer to ocu_data (in )	*/
       exp,			/** expression value    (in )	*/
       type,			/** link type	    (in ) */
       class,			/** link class	    (in ) */
       segname,			/** segname string	    (in ) */
       offsetname,			/** offsetname string   (in )	*/
       init_infop)			/** init_info pointer   (in )	*/
       returns (fixed bin);		/** exp_word index	    (out) */

  /*** ****************************************************************/
  /***							*/
  /***	Name:	find_exp_word				*/
  /***	Input:	odp, exp, type, class, segname, offsetname,	*/
  /***		init_infop				*/
  /***	Function:	looks for an expression_word matching the info	*/
  /***		supplied and returns the index in the exp_word	*/
  /***		table.  If no matching expression_word exists,	*/
  /***		it it created.				*/
  /***	Output:	exp_wordx					*/
  /***							*/
  /*** ****************************************************************/

  /* parameters */

  dcl odp			ptr parameter;
  dcl exp			fixed bin parameter;
  dcl type		fixed bin (3) parameter;
  dcl class		fixed bin (3) parameter;
  dcl segname		char (*) varying parameter;
  dcl offsetname		char (*) varying parameter;
  dcl init_infop		ptr parameter;

  /* based */

  dcl 01 ewi		aligned based (ewip),
       02 header		aligned like exp_word_info.header,
       02 exp_wd		dim (0 refer (ewi.N_exp_words))
			like exp_word_entry;
  dcl 01 od		aligned like ocu_data based (odp);

  /* automatic */

  dcl ewip		ptr automatic;
  dcl 01 expe		aligned like exp_word_entry automatic;
  dcl expx		fixed bin automatic;
  dcl type_pairx		fixed bin automatic;

  /* get a pointer to the expression word array */

  ewip = od.exp_word_infop;

  /* find/create the type pair referenced */

  type_pairx = find_type_pair (odp, type, class, segname, offsetname,
       init_infop);

  /* see if a matching expression word exists and return the index	*/
  /* if one is found					*/

  expe.expression = exp;
  expe.type_pairx = type_pairx;
  expe.relp = 0;

  do expx = 1 to ewi.N_exp_words;
    if unspec (ewi.exp_wd (expx)) = unspec (expe)
      then return (expx);
  end;

  /* if not found, create a new expression word */

  expx, ewi.N_exp_words = ewi.N_exp_words + 1;

  unspec (ewi.exp_wd (expx)) = unspec (expe);

  return (expx);

  end find_exp_word;

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


find_type_pair:
  proc (odp,			/** pointer to ocu_data (in )	*/
       type,			/** link type	    (in )	*/
       class,			/** link class	    (in ) */
       segname,			/** segname string	    (in ) */
       offsetname,			/** offsetname string   (in )	*/
       init_infop)			/** init info for link  (in )	*/
       returns (fixed bin);		/** type pair index	    (out) */

  /*** ****************************************************************/
  /***							*/
  /***	Name:	find_type_pair				*/
  /***	Input:	odp, type, class, segname, offsetname, init_infop	*/
  /***	Function:	finds a type pair matching the given criteria.	*/
  /***		If no such type pair exists, create one.	*/
  /***	Output:	type_pairx				*/
  /***							*/
  /*** ****************************************************************/

  /* parameters */

  dcl odp			ptr parameter;
  dcl type		fixed bin (3) parameter;
  dcl class		fixed bin (3) parameter;
  dcl segname		char (*) varying parameter;
  dcl offsetname		char (*) varying parameter;
  dcl init_infop		ptr parameter;

  /* based */

  dcl 01 od		aligned like ocu_data based (odp);
  dcl 01 tpi		aligned based (tpip),
       02 header		aligned like type_pair_info.header,
       02 type_pr		dim (0 refer (tpi.N_type_pairs))
			like type_pair_entry;

  /* automatic */

  dcl tpip		ptr automatic;
  dcl 01 type_paire		aligned like type_pair_entry automatic;
  dcl type_pairx		fixed bin automatic;

  /* get a pointer to the type_pair array */

  tpip = od.type_pair_infop;

  type_paire.type = type;

  /* encode the refname value, either as a string relpointer, if the	*/
  /* link is a LINK_REFNAME_BASE or LINK_REFNAME_OFFSETNAME link, or	*/
  /* as the class for a LINK_SELF_BASE or LINK_SELF_OFFSETNAME link.	*/

  if type = LINK_REFNAME_BASE | type = LINK_REFNAME_OFFSETNAME
    then type_paire.segnamex = find_string (odp, segname);
    else type_paire.segnamex = class;

  /* store the offsetname value sting index.  This is only valid for	*/
  /* LINK_SELF_OFFSETNAME and LINK_REFNAME_OFFSETNAME links.	*/

  if type = LINK_SELF_OFFSETNAME | type = LINK_REFNAME_OFFSETNAME
    then type_paire.offsetnamex = find_string (odp, offsetname);
    else type_paire.offsetnamex = 0;

  /* if we have an init_info pointer, determine whether this is init	*/
  /* info or a trap pair and generate the appropriate structure.	*/

  if init_infop ^= null
    then if type = LINK_SELF_OFFSETNAME
	 then type_paire.init_infox = find_init_info (odp, init_infop);
	 else type_paire.init_infox = find_trap_pair (odp, init_infop);
    else type_paire.init_infox = 0;

  type_paire.relp = 0;

  /* now that we have filled in all the fields, try to find a type	*/
  /* pair that matches this description.  Return the index if found	*/

  do type_pairx = 1 to tpi.N_type_pairs;
    if unspec (tpi.type_pr (type_pairx)) = unspec (type_paire)
      then return (type_pairx);
  end;

  /* if not generate a new type pair and fill in the values */

  type_pairx, tpi.N_type_pairs = tpi.N_type_pairs + 1;

  unspec (tpi.type_pr (type_pairx)) = unspec (type_paire);

  return (type_pairx);

  end find_type_pair;

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


find_init_info:
  proc (odp,			/** pointer to ocu_data (in )	*/
       init_infop)			/** init info pointer   (in )	*/
       returns (fixed bin);		/** init table index    (out) */

  /*** ****************************************************************/
  /***							*/
  /***	Name:	find_init_info				*/
  /***	Input:	odp, init_infop				*/
  /***	Function:	locates an init_info block matching the block	*/
  /***		specified.  If one does not exist, it is created.	*/
  /***	Output:	init_infox				*/
  /***							*/
  /*** ****************************************************************/

  /* parameters */

  dcl odp			ptr parameter;
  dcl init_infop		ptr parameter;

  /* based */

  dcl 01 ii		aligned based (iip),
       02 header		aligned like init_info.header,
       02 init		dim (0 refer (ii.N_inits)) like init_entry;
  dcl 01 in_init		aligned like link_init based (init_infop);
  dcl 01 in_init_copy	aligned based (init_infop),
       02 header		aligned like link_init_copy_info.header,
       02 initial_data	dim (0 refer (in_init_copy.n_words)) bit (36);
  dcl 01 in_init_deferred	aligned like link_init_deferred
			based (init_infop);
  dcl 01 in_init_template	aligned based (init_infop),
       02 full_header	aligned like init_list_template.full_header,
       02 template		dim (0 refer
			(in_init_template.n_words_in_list)) bit (36);
  dcl init_str		char (init_len) based (init_infop);
  dcl 01 od		aligned like ocu_data based (odp);
  dcl 01 st_init		aligned like link_init based (stored_initp);
  dcl 01 st_init_copy	aligned based (stored_initp),
       02 header		aligned like link_init_copy_info.header,
       02 initial_data	dim (0 refer (st_init_copy.n_words)) bit (36);
  dcl 01 st_init_deferred	aligned like link_init_deferred
			based (stored_initp);
  dcl 01 st_init_template	aligned based (stored_initp),
       02 full_header	aligned like init_list_template.full_header,
       02 template		dim (0 refer
			(st_init_template.n_words_in_list)) bit (36);
  dcl stored_str		char (stored_len) based (stored_initp);

  /* automatic */

  dcl iip			ptr automatic;
  dcl init_infox		fixed bin automatic;
  dcl init_len		fixed bin (21) automatic;
  dcl len			fixed bin (18) automatic;
  dcl stored_initp		ptr automatic;
  dcl stored_len		fixed bin (21) automatic;

  /* get a pointer to the init_info array */

  iip = od.init_infop;

  /* first try to find an existing init_info matching the given one */

  do init_infox = 1 to ii.N_inits;

    /* get a pointer to the current existing init_info */

    stored_initp = addwordno (od.init_segp, ii.init (init_infox).start);

    /* figure out the lengths of the stored and given init infos and	*/
    /* compare them by overlaying character strings		*/

    if (st_init.n_words = in_init.n_words) & (st_init.type = in_init.type)
      then do;
        stored_len = ii.init (init_infox).length * 4;
        init_len = currentsize (in_init) * 4;
        if in_init.type = INIT_DEFERRED
	then init_len = currentsize (in_init_deferred) * 4;
        else if in_init.type = INIT_LIST_TEMPLATE
	then init_len = currentsize (in_init_template) * 4;
        else if in_init.type = INIT_COPY_INFO
	then init_len = currentsize (in_init_copy) * 4;
        if init_len = stored_len
	then if stored_str = init_str
	       then return (init_infox);
      end;
  end;

  /* no matching init_info exists.  Now we create one */

  stored_initp = addwordno (od.init_segp, ii.init_segl);
  init_infox, ii.N_inits = ii.N_inits + 1;
  ii.init (init_infox).start = ii.init_segl;

  /* copy the init_info depending on the type */

  if in_init.type = INIT_LIST_TEMPLATE
    then do;
      st_init_template.n_words = in_init_template.n_words;
      st_init_template.type = in_init_template.type;
      st_init_template.n_words_in_list = in_init_template.n_words_in_list;
      st_init_template.template (*) = in_init_template.template (*);
      len = currentsize (in_init_template);
    end;
  else if in_init.type = INIT_COPY_INFO
    then do;
      st_init_copy.n_words = in_init_copy.n_words;
      st_init_copy.type = in_init_copy.type;
      st_init_copy.initial_data (*) = in_init_copy.initial_data (*);
      len = currentsize (in_init_copy);
    end;
  else if in_init.type = INIT_DEFERRED
    then do;
      st_init_deferred.n_words = in_init_deferred.n_words;
      st_init_deferred.type = in_init_deferred.type;
      st_init_deferred.target_relp = in_init_deferred.target_relp;
      st_init_deferred.link_relp = in_init_deferred.link_relp;
      len = currentsize (in_init_deferred);
    end;
  else do;
    st_init.n_words = in_init.n_words;
    st_init.type = in_init.type;
    len = currentsize (in_init);
  end;

  /* adjust the size of the init_info seg and the array entry */

  ii.init (init_infox).length = len;
  ii.init_segl = ii.init_segl + len;

  return (init_infox);

  end find_init_info;

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


find_trap_pair:
  proc (odp,			/** pointer to ocu_data (in )	*/
       trapp)			/** trap-pair block ptr (in )	*/
       returns (fixed bin);		/** trap_pair index	    (out)	*/

  /*** ****************************************************************/
  /***							*/
  /***	Name:	find_trap_pair				*/
  /***	Input:	odp, trapp				*/
  /***	Function:	finds a trap pair matching the one given.  If no	*/
  /***		such trap_pair exists, it is created and the	*/
  /***		index returned.				*/
  /***	Output:	trap_pairx				*/
  /***							*/
  /*** ****************************************************************/

  /* parameters */

  dcl odp			ptr parameter;
  dcl trapp		ptr parameter;

  /* based */

  dcl 01 od		aligned like ocu_data based (odp);
  dcl 01 trap		aligned like link_trap_pair based (trapp);
  dcl 01 trpi		aligned based (trpip),
       02 header		aligned like trap_pair_info.header,
       02 trap_pair		dim (0 refer (trpi.N_trap_pairs))
			like trap_pair_entry;

  /* automatic */

  dcl trap_pairx		fixed bin automatic;
  dcl trpip		ptr automatic;

  /* get a pointer to the trap_pair array */

  trpip = od.trap_pair_infop;

  /* look for a matching existing trap pair and return the index if found */

  do trap_pairx = 1 to trpi.N_trap_pairs;
    if (trpi.trap_pair (trap_pairx).call_relp = trap.call_relp) &
         (trpi.trap_pair (trap_pairx).info_relp = trap.info_relp)
      then return (trap_pairx);
  end;

  /* if not found, create the new trap_pair */

  trap_pairx, trpi.N_trap_pairs = trpi.N_trap_pairs + 1;

  trpi.trap_pair (trap_pairx).call_relp = trap.call_relp;
  trpi.trap_pair (trap_pairx).info_relp = trap.info_relp;

  return (trap_pairx);

  end find_trap_pair;

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


find_string:
  proc (odp,			/** pointer to ocu_data (in )	*/
       string)			/** string to find	    (in )	*/
       returns (fixed bin);		/** stringmap index	    (out) */

  /*** ****************************************************************/
  /***							*/
  /***	Name:	find_string				*/
  /***	Input:	odp, string				*/
  /***	Function:	adds the string given to the definition stringmap	*/
  /***		and returns the stringmap entry index.  If the	*/
  /***		string already exists in the stringmap, the index	*/
  /***		of the existing entry is returned.		*/
  /***	Output:	stringmap_index				*/
  /***							*/
  /*** ****************************************************************/

  /* parameters */

  dcl odp			ptr parameter;
  dcl string		char (*) varying parameter;

  /* based */

  dcl 01 od		aligned like ocu_data based (odp);
  dcl 01 sme		aligned like string_map_entry based (smep);
  dcl 01 smi		aligned based (smip),
       02 header		aligned like string_map_info.header,
       02 string		dim (0 refer (smi.N_strings))
			like string_map_entry;

  /* automatic */

  dcl smep		ptr automatic;
  dcl smip		ptr automatic;
  dcl stringmapx		fixed bin automatic;

  /* builtin */

  dcl length		builtin;

  /* get pointers to the string_map and string text segment */

  smip = od.string_map_infop;
  text_segp = od.string_segp;
  text_segl = smi.string_segl;

  /* first try to locate the string in the stringmap */

  do stringmapx = 1 to smi.N_strings;
    smep = addr (smi.string (stringmapx));
    if string = substr (text_seg, sme.start_offset, sme.length)
      then return (stringmapx);
  end;

  /* if it isn't there, then we have to add it. */

  stringmapx, smi.N_strings = smi.N_strings + 1;

  /* create the stringmap entry */

  smep = addr (smi.string (stringmapx));
  sme.start_offset = text_segl + 1;
  sme.length = length (string);

  /* add the actual string to the text segment */

  text_segl, smi.string_segl = text_segl + sme.length;

  substr (text_seg, sme.start_offset, sme.length) = string;

  /* return the stringmap offset */

  return (stringmapx);

  end find_string;

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


create_text:
  proc (odp,			/** pointer to ocu_data (in )	*/
       reloc_infop);		/** ptr to relinfo blk  (out) */

  /*** ****************************************************************/
  /***							*/
  /***	Name:	create_text				*/
  /***	Input:	odp, reloc_infop				*/
  /***	Function:	copies the text section from the intermediate	*/
  /***		into the object segment.  Any references to the	*/
  /***		section are relocated to take static section size	*/
  /***		into account if the static section is in the 	*/
  /***		linkage section, and static relocation codes	*/
  /***		converted to linkage relocation.		*/
  /***	Output:	reloc_infop				*/
  /***							*/
  /*** ****************************************************************/

  /* parameters */

  dcl odp			ptr parameter;
  dcl reloc_infop		ptr parameter;

  /* based */

  dcl 01 od		aligned like ocu_data based (odp);
  dcl 01 si		aligned based (sip),
       02 header		aligned like static_info.header,
       02 static_word	dim (0 refer (si.N_static_words)) bit (36);
  dcl 01 ti		aligned based (tip),
       02 header		aligned like text_info.header,
       02 text_word		dim (0 refer (ti.N_text_words)) bit (36);

  /* automatic */

  dcl abs_count		fixed bin automatic;

  /* get pointers to the required data structures */

  tip = od.text_infop;
  sip = od.static_infop;
				/* initialize the relocation info generation stuff */

  abs_count = 0;

  /* copy each word into the actual text section */

  call install_words (addr (ti.text_word), od.text_relinfop, ti.N_text_words,
       si.N_static_words, reloc_infop, Rel_text, (ocu_data.target.segp),
       abs_count);

  /* force the segment onto a doubleword boundary */

  if mod (ti.N_text_words, 2) ^= 0
    then do;
      call append_relinfo (reloc_infop, Rel_text, "aa", abs_count);
      od.lengths.text = ti.N_text_words + 1;
    end;
    else od.lengths.text = ti.N_text_words;

  /* force any remaining absolute relinfo into the block */

  call append_relinfo (reloc_infop, Rel_text, " ", abs_count);

  /* save the segment bit_count */

  od.target.bc = od.lengths.text * 36;

  end create_text;

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


create_defs:
  proc (odp,			/** pointer to ocu_data (in )	*/
       reloc_infop);		/** pointer to relinfo  (i/o)	*/

  /*** ****************************************************************/
  /***							*/
  /***	Name:	create_defs				*/
  /***	Input:	odp, reloc_infop				*/
  /***	Function:	creates the definition section of the object	*/
  /***		segment.  This is done is a set of discrete steps	*/
  /***		  - creation of the definition header		*/
  /***		  - installation of the definition list		*/
  /***		  - installation of the stringmap		*/
  /***		  - rescan of the def list to patch in stringmap	*/
  /***		    relpointers				*/
  /***		  - threading of the definition list		*/
  /***		  - installation of the init_infos		*/
  /***		  - installation of the trap_pairs		*/
  /***		  - installation of the type_pairs		*/
  /***		  - installation of the expression_words	*/
  /***		  - installation of the msf_map		*/
  /***		  - creation of the definiiton hash_table	*/
  /***	Output:	reloc_infop				*/
  /***							*/
  /*** ****************************************************************/

  /* parameters */

  dcl odp			ptr parameter;
  dcl reloc_infop		ptr parameter;

  /* based */

  dcl 01 acc		aligned based (accp),
       02 count		fixed bin (9) unsigned unaligned,
       02 string		char (0 refer (acc.count)) unaligned;
  dcl 01 defn		aligned like definition based (defnp);
  dcl 01 dh		aligned like definition_header based (dhp);
  dcl 01 di		aligned based (dip),
       02 header		aligned like def_info.header,
       02 def		dim (0 refer (di.N_defs)) like def_entry;
  dcl 01 ewi		aligned based (ewip),
       02 header		aligned like exp_word_info.header,
       02 exp_wd		dim (0 refer (ewi.N_exp_words))
			like exp_word_entry;
  dcl 01 expr		aligned like exp_word based (exprp);
  dcl 01 ii		aligned based (iip),
       02 header		aligned like init_info.header,
       02 init		dim (0 refer (ii.N_inits)) like init_entry;
  dcl 01 lte		aligned based (ltep),
       02 header		aligned like template_entry.header,
       02 datum		bit (0 refer (lte.n_bits));
  dcl 01 mm		aligned like msf_map based (mmp);
  dcl new_init_str		char (init_strl) based (new_init_strp);
  dcl 01 new_type_pair	aligned like type_pair based (new_type_pairp);
  dcl obj_init_str		char (init_strl) based (obj_init_strp);
  dcl 01 od		aligned like ocu_data based (odp);
  dcl 01 pit		aligned like pointer_init_template based (pitp);
  dcl 01 prev_sn		aligned like segname_definition
			based (prev_snp);
  dcl 01 si		aligned based (sip),
       02 header		aligned like static_info.header,
       02 static_word	dim (0 refer (si.N_static_words)) bit (36);
  dcl 01 smi		aligned based (smip),
       02 header		aligned like string_map_info.header,
       02 string		dim (0 refer (smi.N_strings))
			like string_map_entry;
  dcl 01 sn		aligned like segname_definition based (snp);
  dcl 01 tpi		aligned based (tpip),
       02 header		aligned like type_pair_info.header,
       02 type_pr		dim (0 refer (tpi.N_type_pairs))
			like type_pair_entry;
  dcl 01 trap_pr		aligned like link_trap_pair based (trap_prp);
  dcl 01 trpi		aligned based (trpip),
       02 header		aligned like trap_pair_info.header,
       02 trap_pair		dim (0 refer (trpi.N_trap_pairs))
			like trap_pair_entry;
  dcl word		bit (36) aligned based (wordp);

  /* automatic */

  dcl abs_count		fixed bin automatic;
  dcl acc_relp		fixed bin (18) unsigned automatic;
  dcl accp		ptr automatic;
  dcl backward_relp		fixed bin (18) unsigned automatic;
  dcl block_relp		fixed bin (18) unsigned automatic;
  dcl def_relp		fixed bin (18) unsigned automatic;
  dcl defnp		ptr automatic;
  dcl dhp			ptr automatic;
  dcl dip			ptr automatic;
  dcl ewip		ptr automatic;
  dcl exprp		ptr automatic;
  dcl forward_relp		fixed bin (18) unsigned automatic;
  dcl iip			ptr automatic;
  dcl init_segp		ptr automatic;
  dcl init_segl		fixed bin (18) automatic;
  dcl init_strl		fixed bin (21) automatic;
  dcl ltep		ptr automatic;
  dcl n_words		fixed bin (18) automatic;
  dcl new_block		bit (1) automatic;
  dcl new_init_strp		ptr automatic;
  dcl new_type_pairp	ptr automatic;
  dcl obj_init_strp		ptr automatic;
  dcl pitp		ptr automatic;
  dcl prev_snp		ptr automatic;
  dcl relchrs		char (10) varying automatic;
  dcl relpair		char (2) varying automatic;
  dcl set_first		bit (1) automatic;
  dcl sip			ptr automatic;
  dcl smip		ptr automatic;
  dcl snp			ptr automatic;
  dcl tpip		ptr automatic;
  dcl tpx			fixed bin automatic;
  dcl trap_prp		ptr automatic;
  dcl trpip		ptr automatic;
  dcl mmp			ptr automatic;
  dcl wordp		ptr automatic;
  dcl zero_relp		fixed bin (18) unsigned automatic;

  /* builtin */

  dcl string		builtin;

  /* set up the structures to be used */

  dip = od.def_infop;
  smip = od.string_map_infop;
  iip = od.init_infop;
  trpip = od.trap_pair_infop;
  tpip = od.type_pair_infop;
  ewip = od.exp_word_infop;
  sip = od.static_infop;

  /* initialize the relocation generation variables */

  abs_count = 0;

  /* create the defintion_header */

  dhp = addwordno (od.target.segp, od.target.bc / 36);
  dh.def_list_relp = currentsize (dh);
  string (dh.flags) = ""b;
  dh.flags.new = true;
  dh.flags.ignore = true;

  od.lengths.defs = currentsize (dh);

  /* generate the definition header relinfo */

  if ocu_data.msf_info.component_count > 0
    then call append_relinfo (reloc_infop, Rel_defs, "dd", abs_count);
    else call append_relinfo (reloc_infop, Rel_defs, "da", abs_count);
  if ocu_data.flags.no_hash_table
    then call append_relinfo (reloc_infop, Rel_defs, "aa", abs_count);
    else call append_relinfo (reloc_infop, Rel_defs, "da", abs_count);

  /* create the definition list */

  defnp = addwordno (dhp, dh.def_list_relp);
  zero_relp = currentsize (dh) + N_defs * currentsize (defn);

  backward_relp = zero_relp;
  forward_relp = dh.def_list_relp + currentsize (defn);

  do i = 1 to di.N_defs;

    /* set up the basic threading */

    defn.forward_relp = forward_relp;
    defn.backward_relp = backward_relp;

    /* adjust the thread values for the next definition */

    backward_relp = forward_relp - currentsize (defn);
    forward_relp = forward_relp + currentsize (defn);

    /* adjust the section size */

    od.lengths.defs = od.lengths.defs + currentsize (defn);

    /* set the values for the definition */

    defn.class = di.def (i).class;
    string (defn.flags) = ""b;
    defn.flags.new = true;
    defn.flags.ignore = di.def (i).flags.ignore;
    defn.flags.entry = di.def (i).flags.entry;
    defn.flags.retain = di.def (i).flags.retain;
    defn.flags.indirect = di.def (i).flags.indirect;
    defn.name_relp = di.def (i).strx;

    /* set up the relocation info */

    if di.def (i).class = 3
      then call append_relinfo (reloc_infop, Rel_defs, "dddadd", abs_count);
      else do;

        /* set the thing relpointer */

        defn.thing_relp = di.def (i).offset;

        /* extract the relocation info and relocate link references */

        relpair = class_relinfo (di.def (i).class) || "a";
        wordp = addr (defn.thing_relp);
        call relocate_link_ref (word, relpair, si.N_static_words);

        /* if the reference is to the static section and we have	*/
        /* combined static, then convert the definition class to link	*/

        if (relpair = "ia" | relpair = "8a") & ^od.flags.separate_static
	then defn.class = CLASS_LINKAGE;

        /* append the relinfo to the relinfo block */

        relchrs = "dd" || relpair || "dd";
        call append_relinfo (reloc_infop, Rel_defs, relchrs, abs_count);
      end;
    defnp = addwordno (defnp, currentsize (defn));
  end;

  /* leave space for the zero word */

  od.lengths.defs = od.lengths.defs + 1;
  text_segp = od.string_segp;
  text_segl = smi.string_segl;
  call append_relinfo (reloc_infop, Rel_defs, "aa", abs_count);

  /* create the stringmap */

  acc_relp = od.lengths.defs;

  do i = 1 to smi.N_strings;

    /* copy the count and string into the object segment */

    accp = addwordno (dhp, acc_relp);
    acc.count = smi.string (i).length;
    acc.string = substr (text_seg, smi.string (i).start_offset,
         smi.string (i).length);
    smi.string (i).relp = acc_relp;

    /* determine how big this thing is */

    n_words = currentsize (acc);

    /* synthesize the relinfo */

    call append_relinfo (reloc_infop, Rel_defs,
         copy ("a", n_words + n_words), abs_count);
    acc_relp = acc_relp + n_words;

    /* adjust the section length */

    od.lengths.defs = od.lengths.defs + n_words;
  end;

  /* backpatch the stringmap relpointers into the definition list */

  defnp = addwordno (dhp, dh.def_list_relp);

  do i = 1 to di.N_defs;
    defn.name_relp = smi.string (defn.name_relp).relp;
    defnp = addwordno (dhp, defn.forward_relp);
  end;

  /* now thread the definition list */

  /* first make a pass setting the segname_relp values for each	*/
  /* non-type-3 definition to point back to the first type-3 def in	*/
  /* the block.						*/

  block_relp = 0;
  new_block = true;

  def_relp = dh.def_list_relp;
  defnp = addwordno (dhp, def_relp);

  do while ((defn.forward_relp ^= 0) | (defn.backward_relp ^= 0));

    /* if this is the first type 3 in the block, remember the relp */

    if (defn.class = 3) & new_block
      then block_relp = def_relp;

    /* if this is not type 3, then set the segname relp */

    else if defn.class ^= 3
      then do;
        defn.segname_relp = block_relp;
        new_block = true;
      end;

    /* go to the next definition */

    def_relp = defn.forward_relp;
    defnp = addwordno (dhp, def_relp);
  end;

  /* now we make another pass, setting the first_relp and	*/
  /* next_segname_relp values in each type-3 definition.	*/

  def_relp = dh.def_list_relp;
  snp = addwordno (dhp, def_relp);

  prev_snp = null;

  do while ((sn.forward_relp ^= 0) | (sn.backward_relp ^= 0));

    /* set the next_segname_relp */

    if (sn.class = 3) & prev_snp ^= null
      then prev_sn.next_segname_relp = def_relp;

    if sn.class = 3
      then do;
        prev_snp = addwordno (dhp, def_relp);
        set_first = true;
      end;

    /* now set the first_relp values for the segnames in the block	*/

    if (sn.class ^= 3) & set_first
      then do;

        /* save the current definition pointer */

        defnp = snp;

        /* find the first segname in the block */

        snp = addwordno (dhp, defn.segname_relp);

        /* scan forward, setting the first_relp until we find a	*/
        /* non-class-3 definition				*/

        do while (sn.class = 3);
	sn.first_relp = def_relp;
	snp = addwordno (dhp, sn.forward_relp);
        end;

        /* restore the current definition */

        snp = defnp;

        /* flag that the next type 3 starts a new block */

        set_first = false;
      end;

    def_relp = sn.forward_relp;
    snp = addwordno (dhp, def_relp);
  end;

  /* set the next_segname relp on the last class-3 definition, and	*/
  /* set the first_relp values if the last block had no non-class-3	*/
  /* definitions.						*/

  if prev_snp ^= null
    then do;
      prev_sn.next_segname_relp = zero_relp;
      if set_first
        then
	do while ((prev_sn.first_relp = 0) &
	     (prev_sn.backward_relp ^= 0));
	prev_sn.first_relp = zero_relp;
	prev_snp = addwordno (dhp, prev_sn.backward_relp);
        end;
    end;

  /* install any init_infos into the object segment */

  init_segp = od.init_segp;
  init_segl = ii.init_segl;

  do i = 1 to ii.N_inits;

    /* save the relpointer */

    ii.init (i).relp = od.lengths.defs;
    od.lengths.defs = od.lengths.defs + ii.init (i).length;

    /* get pointers to the object segment location and existing init	*/
    /* info structures for copying				*/

    obj_init_strp = addwordno (dhp, ii.init (i).relp);
    new_init_strp = addwordno (init_segp, ii.init (i).start);

    /* calculate the length if treated as as character string	*/

    init_strl = ii.init (i).length * 4;

    /* copy character string overlays */

    obj_init_str = new_init_str;

    /* the deferred initialization contains a link relpointer, which	*/
    /* must be relocated for it to work.  So we check for that type	*/
    /* of init_info and relocate the link reference.		*/

    if obj_init_strp -> link_init.type = INIT_DEFERRED
      then call relocate_link_ref (
	      addr (obj_init_strp->link_init_deferred.target_relp) -> word,
	      "2a", si.N_static_words);
      
    /* if the init info is a list template, it may have pointer init	*/
    /* templates containing a reference to a link which mist also be	*/
    /* relocated.						*/
    
    else if obj_init_strp -> link_init.type = INIT_LIST_TEMPLATE
      then do;
        ltep = addr (obj_init_strp -> link_init_list_template.template);
        
        do while (lte.n_bits ^= 0);
          
	/* see if the template is for a pointer init */
	
	if lte.init_type ^= 0
	  then do;
	    
	    /* get a pointer to the pointer datum structure */
	    
	    pitp = addr (lte.datum);
	    
	    if pit.ptr_type = CLASS_LINKAGE
	      then call relocate_link_ref (pitp -> word, "a2",
		      si.N_static_words);
	  end;
	  
	ltep = addwordno (ltep, currentsize (lte));
        end;
      end;
      
    /* generate and append the relinfo */

    call append_relinfo (reloc_infop, Rel_defs,
         copy ("a", ii.init (i).length * 2), abs_count);
  end;

  /* install any trap pairs into the object segment */

  do i = 1 to trpi.N_trap_pairs;
    trap_prp = addwordno (dhp, od.lengths.defs);
    trap_pr.call_relp = trpi.trap_pair (i).call_relp;
    trap_pr.info_relp = trpi.trap_pair (i).info_relp;

    /* generate the relinfo for the trap word */

    if trap_pr.call_relp = 0
      then substr (relpair, 1, 1) = "a";
      else substr (relpair, 1, 1) = "2";

    if trap_pr.info_relp = 0
      then substr (relpair, 2, 1) = "a";
      else substr (relpair, 2, 1) = "2";

    /* relocate any link references */

    wordp = trap_prp;
    call relocate_link_ref (word, relpair, si.N_static_words);

    /* append the relinfo to the relinfo block */

    call append_relinfo (reloc_infop, Rel_defs, relpair, abs_count);

    /* and grow the definition section */

    od.lengths.defs = od.lengths.defs + currentsize (trap_pr);
  end;

  /* now install the type pairs into the object segment */

  do i = 1 to tpi.N_type_pairs;

    /* set the relp of the type pair block */

    tpi.type_pr (i).relp = od.lengths.defs;

    /* get a pointer to the new type pair */

    new_type_pairp = addwordno (dhp, od.lengths.defs);
    od.lengths.defs = od.lengths.defs + currentsize (new_type_pair);

    /* generate the relinfo depending on the type since the fields	*/
    /* vary with the type value.				*/

    relchrs = "a";
    new_type_pair.type = tpi.type_pr (i).type;

    /* decode the offsetname */

    if (new_type_pair.type = 1) | (new_type_pair.type = 3)
      then do;
        new_type_pair.offsetname_relp = 0;
        relchrs = relchrs || "a";
      end;
      else do;
        new_type_pair.offsetname_relp =
	   smi.string (tpi.type_pr (i).offsetnamex).relp;
        relchrs = relchrs || "d";
      end;

    /* decode the segname */

    if (new_type_pair.type = 1) | (new_type_pair.type = 5)
      then do;

        /* convert Self-Base and Self-Offsetname links to static to	*/
        /* linkage references if there is no separate static section	*/

        if tpi.type_pr (i).segnamex = SECTION_STATIC &
	   ^od.flags.separate_static
	then new_type_pair.segname_relp = SECTION_LINK;
	else new_type_pair.segname_relp = tpi.type_pr (i).segnamex;
        relchrs = relchrs || "a";
      end;
      else do;
        new_type_pair.segname_relp =
	   smi.string (tpi.type_pr (i).segnamex).relp;
        relchrs = relchrs || "d";
      end;

    /* decode the init_info value */

    if tpi.type_pr (i).init_infox ^= 0
      then do;
        if (new_type_pair.type = 5)
	then new_type_pair.trap_relp =
		ii.init (tpi.type_pr (i).init_infox).relp;
	else new_type_pair.trap_relp =
		trpi.trap_pair (tpi.type_pr (i).init_infox).relp;
        relchrs = relchrs || "d";
      end;
      else relchrs = relchrs || "a";

    /* add the generated relinfo to the relinfo block */

    call append_relinfo (reloc_infop, Rel_defs, relchrs, abs_count);
  end;

  /* now create the expression words */

  do i = 1 to ewi.N_exp_words;

    /* set the relp value */

    ewi.exp_wd (i).relp = od.lengths.defs;

    /* get a pointer to the new expression word */

    exprp = addwordno (dhp, od.lengths.defs);
    od.lengths.defs = od.lengths.defs + currentsize (expr);

    /* set the type_relp and expression values */

    tpx = ewi.exp_wd (i).type_pairx;

    expr.type_relp = tpi.type_pr (tpx).relp;
    expr.expression = ewi.exp_wd (i).expression;

    /* if the link is a self-base link to the linkage section, then	*/
    /* we want to relocate the expression value to account for the	*/
    /* insertion of the static section.  If it is a self-base link to	*/
    /* static, we must convert it to a self-base link to linkage with	*/
    /* an appropriately adjusted expression value.		*/

    if tpi.type_pr (tpx).type = LINK_SELF_BASE
      then do;
        if tpi.type_pr (tpx).segnamex = SECTION_LINK
	then call relocate_link_ref (exprp -> word, "d2",
		si.N_static_words);
        else if tpi.type_pr (tpx).segnamex = SECTION_STATIC
	then call relocate_link_ref (exprp -> word, "d8",
		si.N_static_words);
      end;

    /* append the relinfo to the defs relinfo block */

    call append_relinfo (reloc_infop, Rel_defs, "da", abs_count);
  end;

  /* generate the msf_map (if any) */

  if ocu_data.msf_info.component_count > 0
    then do;

      /* get a pointer to the new msf_map */

      mmp = addwordno (dhp, od.lengths.defs);

      /* patch the relpointer into the definition header */

      dh.msf_map_relp = od.lengths.defs;
      od.lengths.defs = od.lengths.defs + currentsize (mm);

      /* set the values for the component and count */

      mm.version = msf_map_version_1;
      mm.component_count = od.msf_info.component_count;
      mm.my_component = od.msf_info.my_component;

      /* and generate relinfo */

      call append_relinfo (reloc_infop, Rel_defs, "aaaaaaaa", abs_count);
    end;

  /* now create the definition hash_table */

  if ^od.flags.no_hash_table
    then call create_hash_table (dhp, dip, smip, od.lengths.defs);

  /* force the segment onto a doubleword boundary */

  if mod (od.lengths.text + od.lengths.defs, 2) ^= 0
    then do;
      call append_relinfo (reloc_infop, Rel_defs, "aa", abs_count);
      od.lengths.defs = od.lengths.defs + 1;
    end;

  /* finish off the relinfo block */

  call append_relinfo (reloc_infop, Rel_defs, " ", abs_count);

  /* set the new bit count */

  od.target.bc = od.target.bc + 36 * od.lengths.defs;

  end create_defs;

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


create_link:
  proc (odp,			/** pointer to ocu_data (in )	*/
       reloc_infop);		/** pointer to relinfo  (i/o)	*/

  /*** ****************************************************************/
  /***							*/
  /***	Name:	create_link				*/
  /***	Input:	reloc_info				*/
  /***	Function:	creates the linkage section of the new object	*/
  /***		segment.					*/
  /***	Output:	reloc_info				*/
  /***							*/
  /*** ****************************************************************/

  /* parameters */

  dcl odp			ptr parameter;
  dcl reloc_infop		ptr parameter;

  /* based */

  dcl 01 ewi		aligned based (ewip),
       02 header		aligned like exp_word_info.header,
       02 exp_wd		dim (0 refer (ewi.N_exp_words))
			like exp_word_entry;
  dcl 01 frt		aligned based (frtp),
       02 decl_vers		fixed bin,
       02 n_traps		fixed bin,
       02 trap_array	dim (0 refer (frt.n_traps))
			like fr_traps.trap_array;
  dcl 01 frti		aligned based (frtip),
       02 header		aligned like firstref_trap_info.header,
       02 trap		dim (0 refer (frti.N_traps))
			like firstref_trap_entry;
  dcl 01 li		aligned based (lip),
       02 header		aligned like link_info.header,
       02 link		dim (0 refer (li.N_links)) like link_entry;
  dcl 01 lk		aligned like object_link based (lkp);
  dcl new_stat_str		char (stat_strl) based (new_stat_strp);
  dcl obj_stat_str		char (stat_strl) based (obj_stat_strp);
  dcl 01 od		aligned like ocu_data based (odp);
  dcl 01 si		aligned based (sip),
       02 header		aligned like static_info.header,
       02 static_word	dim (0 refer (si.N_static_words)) bit (36);
  dcl 01 partial_lk		aligned like partial_link based (partial_lkp);
  dcl 01 vlh		aligned like virgin_linkage_header based (vlhp);
  dcl word		bit (36) aligned based (wordp);

  /* automatic */

  dcl abs_count		fixed bin automatic;
  dcl ewip		ptr automatic;
  dcl frtip		ptr automatic;
  dcl frtp		ptr automatic;
  dcl lip			ptr automatic;
  dcl lkp			ptr automatic;
  dcl new_stat_strp		ptr automatic;
  dcl obj_stat_strp		ptr automatic;
  dcl relchars		char (32) varying automatic;
  dcl relpair		char (2) varying automatic;
  dcl sip			ptr automatic;
  dcl stat_strl		fixed bin (21) automatic;
  dcl static_size		fixed bin (18) automatic;
  dcl vlhp		ptr automatic;
  dcl partial_lkp		ptr automatic;
  dcl wordp		ptr automatic;

  /* builtin */

  dcl currentsize		builtin;

  /* get pointers to the structures to be used */

  sip = od.static_infop;
  lip = od.link_infop;
  frtip = od.firstref_trap_infop;
  ewip = od.exp_word_infop;

  /* initialize the relocation generation variables */

  abs_count = 0;

  /* create the linkage header */

  vlhp = addwordno (od.target.segp, od.target.bc / 36);

  relchars = "aataaaaaaaaa22aa";

  vlh.pad = ""b;
  vlh.defs_in_link = ""b;
  vlh.def_offset = od.lengths.text;
  vlh.filled_in_later = ""b;
  vlh.static_length = si.N_static_words;
  vlh.link_begin = currentsize (vlh);
  vlh.linkage_section_lng = currentsize (vlh) + N_links * currentsize (lk);

  /* adjust the header for static in linkage */

  if ^od.flags.separate_static
    then do;
      static_size = si.N_static_words + mod (si.N_static_words, 2);
      vlh.link_begin = vlh.link_begin + static_size;
      vlh.linkage_section_lng = vlh.linkage_section_lng + static_size;
    end;

  /* adjust the header for the presence of firstref traps */

  if frti.N_traps > 0
    then do;
      vlh.first_ref_relp = vlh.linkage_section_lng;
      substr (relchars, 4, 1) = "2";
      vlh.linkage_section_lng = vlh.linkage_section_lng + frti.N_traps + 2;
    end;

  /* add the relocation info for the linkage header */

  call append_relinfo (reloc_infop, Rel_link, relchars, abs_count);
  od.lengths.link = currentsize (vlh);

  /* if the static section is in the linkage section, copy it now */

  if ^od.flags.separate_static & si.N_static_words > 0
    then do;
      obj_stat_strp = addwordno (vlhp, od.lengths.link);
      new_stat_strp = addr (static_word (1));
      stat_strl = si.N_static_words * 4;
      obj_stat_str = new_stat_str;
      call append_relinfo (reloc_infop, Rel_link,
	 copy ("a", static_size * 2), abs_count);
      od.lengths.link = od.lengths.link + static_size;
      od.lengths.stat = si.N_static_words;
    end;

  /* now copy the link array */

  do i = 1 to li.N_links;
    if li.link (i).exp_wordx = 0
      then do;			/* emit a partial link */

        /* make sure that a msf_map was present */

        if od.msf_info.component_count = 0
	then call sub_err_ (error_table_$improper_data_format, "format",
		ACTION_CANT_RESTART, null, 0,
		"^/Partial links cannot be emitted " ||
		"without an msf_map.");

        /* make sure the given component number is in range */

        if li.link (i).component > od.msf_info.component_count
	then call sub_err_ (error_table_$improper_data_format, "format",
		ACTION_CANT_RESTART, null, 0,
		"^/Partial link refers to component " ||
		"outside the range in the msf_map.");

        partial_lkp = addwordno (vlhp, od.lengths.link);
        partial_lk.type = li.link (i).type;
        partial_lk.component = li.link (i).component;
        partial_lk.mbz1 = ""b;
        partial_lk.tag = FAULT_TAG_3;
        partial_lk.offset = li.link (i).offset;
        partial_lk.mbz2 = ""b;
        partial_lk.bit_offset = 0;
        partial_lk.mbz3 = ""b;
        partial_lk.modifier = li.link (i).modifier;
        call append_relinfo (reloc_infop, Rel_link, "aaaa", abs_count);
        od.lengths.link = od.lengths.link + currentsize (partial_lk);
      end;
      else do;			/* emit a normal link */
        lkp = addwordno (vlhp, od.lengths.link);
        lk.header_relp = -od.lengths.link;
        lk.ringno = 0;
        lk.mbz = ""b;
        lk.run_depth = 0;
        lk.tag = FAULT_TAG_2;
        lk.expression_relp = ewi.exp_wd (li.link (i).exp_wordx).relp;
        lk.mbz2 = ""b;
        lk.modifier = li.link (i).modifier;
        call append_relinfo (reloc_infop, Rel_link, "iada", abs_count);
        od.lengths.link = od.lengths.link + currentsize (lk);
      end;
  end;

  /* if there are firstref traps to be added, add them */

  if frti.N_traps > 0
    then do;

      /* emit the header for the firstref trap block */

      frtp = addwordno (vlhp, vlh.first_ref_relp);
      frt.decl_vers = FR_TRAPS_VERSION_1;
      frt.n_traps = frti.N_traps;
      od.lengths.link = od.lengths.link + currentsize (frt);
      call append_relinfo (reloc_infop, Rel_link, "aaaa", abs_count);

      /* copy the trap array */

      do i = 1 to frti.N_traps;
        frt.trap_array (i).call_relp = frti.trap (i).call_relp;
        frt.trap_array (i).info_relp = frti.trap (i).info_relp;
        wordp = addr (frt.trap_array (i));
        relpair = "22";

        /* adjust the relinfo for zero info relp values */

        if frt.trap_array (i).info_relp = 0
	then relpair = "2a";

        /* relocate the link references */

        call relocate_link_ref (word, relpair, si.N_static_words);
        call append_relinfo (reloc_infop, Rel_link, relpair, abs_count);
      end;
    end;

  /* force the segment to a doubleword boundary */

  if mod (od.lengths.link, 2) ^= 0
    then do;
      call append_relinfo (reloc_infop, Rel_link, "aa", abs_count);
      od.lengths.link = od.lengths.link + 1;
    end;

  /* clean up the relocation info */

  call append_relinfo (reloc_infop, Rel_link, " ", abs_count);

  /* set the new bit count */

  od.target.bc = od.target.bc + 36 * od.lengths.link;

  end create_link;

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


create_stat:
  proc (odp);			/** pointer to ocu_data (in )	*/

  /*** ****************************************************************/
  /***							*/
  /***	Name:	create_stat				*/
  /***	Input:	odp					*/
  /***	Function:	creates the static section of the new object	*/
  /***		segment if the new object is to have a separate	*/
  /***		static section.				*/
  /***	Output:	none					*/
  /***							*/
  /*** ****************************************************************/

  /* parameters */

  dcl odp			ptr parameter;

  /* based */

  dcl obj_stat_str		char (stat_strl) based (obj_stat_strp);
  dcl 01 od		aligned like ocu_data based (odp);
  dcl new_stat_str		char (stat_strl) based (new_stat_strp);
  dcl 01 si		aligned based (sip),
       02 header		aligned like static_info.header,
       02 static_word	dim (0 refer (si.N_static_words)) bit (36);

  /* automatic */

  dcl sip			ptr automatic;
  dcl stat_strl		fixed bin (21) automatic;
  dcl obj_stat_strp		ptr automatic;
  dcl new_stat_strp		ptr automatic;

  /* get a pointer to the static section info structure */

  sip = od.static_infop;

  /* save the length */

  od.lengths.stat = si.N_static_words;

  /* if the static is in linkage, just return */

  if ^od.flags.separate_static | (si.N_static_words = 0)
    then return;

  /* copy the static section into the object */

  obj_stat_strp = addwordno (od.target.segp, od.target.bc / 36);
  new_stat_strp = addr (si.static_word (1));
  stat_strl = si.N_static_words * 4;

  obj_stat_str = new_stat_str;

  end create_stat;

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


create_symb:
  proc (odp,			/** pointer to ocu_data (in )	*/
       reloc_infop);		/** reloc info pointer  (in )	*/

  /*** ****************************************************************/
  /***							*/
  /***	Name:	create_symb				*/
  /***	Input:	odp, reloc_info				*/
  /***	Function:	creates the symbol section and appends the	*/
  /***		generated relocation info to the new object	*/
  /***		segment.					*/
  /***	Output:	none					*/
  /***							*/
  /*** ****************************************************************/

  /* parameter */

  dcl odp			ptr;
  dcl reloc_infop		ptr;

  /* based */

  dcl 01 od		aligned like ocu_data based (odp);
  dcl 01 rel_info		aligned based (rel_infop),
       02 header		aligned like relinfo.header,
       02 relbits		bit (0 refer (rel_info.n_bits)) aligned;
  dcl 01 reloc_info		aligned based (reloc_infop),
       02 header		aligned like relinfo_blocks.header,
       02 relbits		bit (0 refer (reloc_info.header.n_bits))
			aligned;
  dcl 01 sbi		aligned based (sbip),
       02 header		aligned like symbol_info.header,
       02 symbol_word	dim (0 refer (sbi.N_symbol_words)) bit (36);
  dcl 01 si		aligned based (sip),
       02 header		aligned like static_info.header,
       02 static_word	dim (0 refer (si.N_static_words)) bit (36);
  dcl 01 ssh		aligned like std_symbol_header based (sshp);

  /* automatic */

  dcl abs_count		fixed bin automatic;
  dcl defs_relp		fixed bin (18) unsigned automatic;
  dcl link_relp		fixed bin (18) unsigned automatic;
  dcl rel_infop		ptr automatic;
  dcl sbip		ptr automatic;
  dcl sip			ptr automatic;
  dcl sshp		ptr automatic;
  dcl symb_relp		fixed bin (18) unsigned automatic;
  dcl symbol_size		fixed bin (18) unsigned automatic;
  dcl text_relp		fixed bin (18) unsigned automatic;
  dcl wordp		ptr automatic;

  /* get pointers to the required structures */

  sip = od.static_infop;
  sbip = od.symbol_infop;
  relinfo_strp = od.symbol_relinfop;
  relinfo_strl = sbi.symbol_relinfol;

  wordp = addwordno (od.target.segp, od.target.bc / 36);
  sshp = wordp;

  /* initialize the relocation generation variables */

  text_relp = 0;
  defs_relp = 0;
  link_relp = 0;
  symb_relp = 0;

  abs_count = 0;

  /* relocate and install each symbol word */

  call install_words (addr (sbi.symbol_word), relinfo_strp,
       sbi.N_symbol_words, si.N_static_words, reloc_infop, Rel_symb, wordp,
       abs_count);

  symbol_size = sbi.N_symbol_words;

  /* finish off the relocation info */

  call append_relinfo (reloc_infop, Rel_symb, " ", abs_count);

  /* if the object is to be relocatable, add the relocation to the	*/
  /* object segment.					*/

  if od.flags.relocatable
    then do;

      /* now append the relocation blocks to the object segment */

      /* append the text relinfo block */

      text_relp = sbi.N_symbol_words;
      rel_infop = wordp;
      rel_info.decl_vers = 2;
      rel_info.n_bits = reloc_info.section (Rel_text).n_bits;
      rel_info.relbits = substr (reloc_info.relbits,
	 reloc_info.section (Rel_text).start_offset,
	 reloc_info.section (Rel_text).n_bits);

      /* append the definition relinfo block */

      defs_relp = text_relp + currentsize (rel_info);
      rel_infop = addwordno (rel_infop, currentsize (rel_info));
      rel_info.decl_vers = 2;
      rel_info.n_bits = reloc_info.section (Rel_defs).n_bits;
      rel_info.relbits = substr (reloc_info.relbits,
	 reloc_info.section (Rel_defs).start_offset,
	 reloc_info.section (Rel_defs).n_bits);

      /* append the linkage relinfo block */

      link_relp = defs_relp + currentsize (rel_info);
      rel_infop = addwordno (rel_infop, currentsize (rel_info));
      rel_info.decl_vers = 2;
      rel_info.n_bits = reloc_info.section (Rel_link).n_bits;
      rel_info.relbits = substr (reloc_info.relbits,
	 reloc_info.section (Rel_link).start_offset,
	 reloc_info.section (Rel_link).n_bits);

      /* append the symbol relinfo block */

      symb_relp = link_relp + currentsize (rel_info);
      rel_infop = addwordno (rel_infop, currentsize (rel_info));
      rel_info.decl_vers = 2;
      rel_info.n_bits = reloc_info.section (Rel_symb).n_bits;
      rel_info.relbits = substr (reloc_info.relbits,
	 reloc_info.section (Rel_symb).start_offset,
	 reloc_info.section (Rel_symb).n_bits);

      /* calculate the new symbol section size */

      symbol_size = symb_relp + currentsize (rel_info);
    end;

  /* check to make sure the first thing in the symbol section is	*/
  /* a std_symbol_header before writing the relinfo relptrs in.	*/

  if (ssh.dcl_version ^= 1) |
       (ssh.identifier ^= "symbtree" & ssh.identifier ^= "bind_map")
    then call sub_err_ (error_table_$improper_data_format, "format",
	    ACTION_CAN_RESTART, null, 0);

  /* install the block size into the symbol header */

  ssh.block_size = bit (symbol_size, 18);

  /* install the relinfo relpointers into the symbol section */

  ssh.rel_text = bit (text_relp, 18);
  ssh.rel_def = bit (defs_relp, 18);
  ssh.rel_link = bit (link_relp, 18);
  ssh.rel_symbol = bit (symb_relp, 18);

  /* save the section length and adjust the segment bit_count */

  od.lengths.symb = symbol_size;
  od.target.bc = od.target.bc + symbol_size * 36;

  end create_symb;

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


create_obj_map:
  proc (odp);			/** pointer to ocu_data (in )	*/

  /*** ****************************************************************/
  /***							*/
  /***	Name:	create_obj_map				*/
  /***	Input:	odp					*/
  /***	Function:	creates the object_map and inserts it into the	*/
  /***		new object segment.				*/
  /***	Output:	none					*/
  /***							*/
  /*** ****************************************************************/

  /* parameters */

  dcl odp			ptr parameter;

  /* based */

  dcl 01 obj_map_relp	aligned based (obj_map_relpp),
       02 relp		fixed bin (18) unsigned unaligned,
       02 mbz		bit (18) unaligned;
  dcl 01 od		aligned like ocu_data based (odp);
  dcl 01 om		aligned like object_map based (omp);

  /* automatic */

  dcl end_relp		fixed bin (18) unsigned automatic;
  dcl obj_map_relpp		ptr automatic;
  dcl omp			ptr automatic;
  dcl om_relp		fixed bin (18) unsigned automatic;
  dcl relp		fixed bin (18) unsigned automatic;

  /* get a pointer to the new object_map and determine the relpointer */

  om_relp = divide (od.target.bc, 36, 18);
  omp = addwordno (od.target.segp, om_relp);

  /* set up the object map */

  om.decl_vers = 2;
  om.identifier = "obj_map";

  /* set the section lengths */

  end_relp = 0;
  om.text_offset = bit (end_relp);
  om.text_length = bit (od.lengths.text, 18);
  end_relp = end_relp + od.lengths.text;
  om.definition_offset = bit (end_relp, 18);
  om.definition_length = bit (od.lengths.defs, 18);
  end_relp = end_relp + od.lengths.defs;
  om.linkage_offset = bit (end_relp, 18);
  om.linkage_length = bit (od.lengths.link, 18);
  end_relp = end_relp + od.lengths.link;
  om.static_length = bit (od.lengths.stat, 18);

  /* determind the static offset depending on whether it is separate */

  if od.flags.separate_static
    then do;
      om.static_offset = bit (end_relp, 18);
      end_relp = end_relp + od.lengths.stat;
      om.symbol_offset = bit (end_relp, 18);
    end;
    else do;
      relp = fixed (om.linkage_offset, 18) + vlh_size;
      om.static_offset = bit (relp, 18);
      om.symbol_offset = bit (end_relp, 18);
    end;
  om.symbol_length = bit (od.lengths.symb, 18);

  /* set various constant values (for a standard object segment) */

  om.break_map_offset = ""b;
  om.break_map_length = ""b;
  om.entry_bound = ""b;
  om.text_link_offset = ""b;

  /* set the flags */

  om.format.bound = od.flags.bound;
  om.format.relocatable = od.flags.relocatable;
  om.format.procedure = od.flags.procedure;
  om.format.standard = true;
  om.format.separate_static = od.flags.separate_static;
  om.format.perprocess_static = od.flags.perprocess_static;

  /* generate the object map relpointer in the last word */

  obj_map_relpp = addwordno (omp, currentsize (om));
  obj_map_relp.relp = om_relp;

  /* calculate the final segment bit_count */

  od.target.bc = od.target.bc + currentsize (om) * 36 + 36;

  end create_obj_map;

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


install_words:
  proc (wordsp,			/** ptr to word array   (in )	*/
       relstrp,			/** ptr to relinfo str  (in )	*/
       n_words,			/** number of words	    (in ) */
       n_static,			/** static size	    (in ) */
       reloc_infop,			/** reloc info pointer  (i/o) */
       section,			/** section being moved (in ) */
       targetp,			/** target to move to   (i/o) */
       abs_count);			/** reloc abs count	    (i/o) */

  /*** ****************************************************************/
  /***							*/
  /***	Name:	install_words				*/
  /***	Input:	wordsp, relstrp, n_words, n_static, reloc_infop,	*/
  /***		section, targetp, abs_count			*/
  /***	Function:	copies a word block/relocation string format	*/
  /***		into the object segment and relocates all of the	*/
  /***		link and static references.			*/
  /***	Output:	reloc_infop, targetp, abs_count		*/
  /***							*/
  /*** ****************************************************************/

  /* parameters */

  dcl wordsp		ptr parameter;
  dcl relstrp		ptr parameter;
  dcl n_words		fixed bin parameter;
  dcl n_static		fixed bin parameter;
  dcl reloc_infop		ptr parameter;
  dcl section		fixed bin parameter;
  dcl targetp		ptr parameter;
  dcl abs_count		fixed bin parameter;

  /* based */

  dcl relstr		char (relstrl) based (relstrp);
  dcl copy		char (copyl) based (copyp);
  dcl target		char (copyl) based (targetp);
  dcl word		bit (36) aligned based;

  /* automatic */

  dcl copyl		fixed bin (21) automatic;
  dcl copyp		ptr automatic;
  dcl first		fixed bin (21) automatic;
  dcl halfwords		fixed bin (21) automatic;
  dcl left		fixed bin (21) automatic;
  dcl relpair		char (2) varying automatic;
  dcl relstrl		fixed bin (21) automatic;
  dcl start		fixed bin (21) automatic;

  /* calculate the length of the relinfo */

  relstrl = n_words * 2;

  start = 1;
  left = relstrl;
  copyp = wordsp;

  do while (left > 0);

    /* search for the first halfword needing relocation */

    first = search (substr (relstr, start, left), "23l8i");
    if first > 0
      then first = first - 1;
      else first = left;

    /* calculate the number of intervening words to be copied */

    first = divide (first, 2, 18, 0);

    if first > 0
      then do;

        /* convert to a character string length */

        copyl = first * 4;

        /* copy the words as a character string */

        target = copy;

        /* adjust the source and destination pointers for the copied words */

        copyp = addwordno (copyp, first);
        targetp = addwordno (targetp, first);

        /* calculate the number of halfwords copied */

        halfwords = first + first;

        /* add the relinfo and adjust the counts */

        call append_relinfo (reloc_infop, section,
	   substr (relstr, start, halfwords), abs_count);
        start = start + halfwords;
        left = left - halfwords;
      end;

    if left > 0
      then do;

        /* if not done, then extract the relinfo, relocate the link	*/
        /* or static reference, and append the relinfo		*/

        relpair = substr (relstr, start, 2);
        call relocate_link_ref (copyp -> word, relpair, n_static);
        call append_relinfo (reloc_infop, section, relpair, abs_count);

        /* length is 4 bytes (1 word) */

        copyl = 4;

        /* copy the word, adjust the pointers and counts */

        target = copy;
        targetp = addwordno (targetp, 1);
        copyp = addwordno (copyp, 1);
        start = start + 2;
        left = left - 2;
      end;
  end;

  end install_words;

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


create_hash_table:
  proc (dhp,			/** def header ptr	    (i/o)	*/
       dip,			/** def info pointer    (in ) */
       smip,			/** string map pointer  (in ) */
       defnl);			/** def section length  (i/o) */

  /*** ****************************************************************/
  /***							*/
  /***	Name:	create_hash_table				*/
  /***	Input:	dhp, dip, smip, defnl			*/
  /***	Function:	creates the definition section hash table,	*/
  /***		adjusts the section length, and backpatches the	*/
  /***		hash table relp back into the definition header.	*/
  /***	Output:	dhp, defnl				*/
  /***							*/
  /*** ****************************************************************/

  /* parameters */

  dcl dhp			ptr parameter;
  dcl dip			ptr parameter;
  dcl smip		ptr parameter;
  dcl defnl		fixed bin (18) unsigned parameter;

  /* based */

  dcl 01 di		aligned based (dip),
       02 header		aligned like def_info.header,
       02 def		dim (0 refer (di.N_defs)) like def_entry;
  dcl 01 smi		aligned based (smip),
       02 header		aligned like string_map_info.header,
       02 string		dim (0 refer (smi.N_strings))
			like string_map_entry;
  dcl 01 def		aligned like definition based (defp);
  dcl 01 sn		aligned like segname_definition based (snp);
  dcl 01 de		aligned like def_entry based (dep);
  dcl 01 srch_de		aligned like def_entry based (srch_dep);
  dcl 01 dt		aligned based (dtp),
       02 mbz		bit (18) unaligned,
       02 n_names		fixed bin (18) unsigned unaligned,
       02 table		dim (0 refer (dt.n_names)) aligned
			like duplicate_table.table;
  dcl 01 dh		aligned like definition_header based (dhp);
  dcl 01 dht		aligned based (dhtp),
       02 n_entries		fixed bin,
       02 table		dim (0 refer (dht.n_entries)) aligned
			like definition_ht.table;
  dcl 01 cht		aligned based (chtp),
       02 n_entries		fixed bin,
       02 table		dim (0 refer (cht.n_entries)) aligned
			like component_ht.table;

  /* automatic */

  dcl defp		ptr automatic;
  dcl snp			ptr automatic;
  dcl dep			ptr automatic;
  dcl srch_dep		ptr automatic;
  dcl d			fixed bin automatic;
  dcl n_names		fixed bin automatic;
  dcl n_segnames		fixed bin automatic;
  dcl make_comp_ht		bit (1) automatic;
  dcl dtp			ptr automatic;
  dcl dhtp		ptr automatic;
  dcl chtp		ptr automatic;
  dcl accp		ptr automatic;
  dcl htx			fixed bin automatic;
  dcl relp		fixed bin (18) unsigned automatic;

  n_names = 0;
  n_segnames = 0;
  make_comp_ht = false;

  /* pass 1: create the duplicate tables */

  do d = 1 to di.N_defs;
    dep = addr (di.def (d));
    if de.flags.ignore
      then ;
    else if de.class = 3
      then n_segnames = n_segnames + 1;
    else if ^de.flags.duplicate
      then do;
        n_names = n_names + 1;
        dtp = null;

        do i = d + 1 to di.N_defs;
	srch_dep = addr (di.def (i));
	if srch_de.strx = de.strx & ^srch_de.flags.ignore &
	     srch_de.class ^= 3
	  then do;
	    if dtp ^= null
	      then do;
	        dt.n_names = dt.n_names + 1;
	        dt.table (dt.n_names).def_relp =
		   dh_size + (i - 1) * def_size;
	        defp = addwordno (dhp, dt.table (dt.n_names).def_relp);
	        dt.table (dt.n_names).block_hdr_relp = def.segname_relp;
	        srch_de.flags.duplicate = true;
	      end;
	      else do;
	        dtp = addwordno (dhp, defnl);
	        dt.mbz = ""b;
	        dt.n_names = 2;

	        /* set up the table entry for the original name */

	        dt.table (1).def_relp = dh_size + ((d - 1) * def_size);
	        defp = addwordno (dhp, dt.table (1).def_relp);
	        dt.table (1).block_hdr_relp = def.segname_relp;
	        de.flags.duplicate = true;
	        de.dup_tbl_relp = defnl;

	        /* set up the table entry for the duplicate name found */

	        dt.table (2).def_relp = dh_size + ((i - 1) * def_size);
	        defp = addwordno (dhp, dt.table (2).def_relp);
	        dt.table (2).block_hdr_relp = def.segname_relp;
	        srch_de.flags.duplicate = true;
	        srch_de.dup_tbl_relp = 0;
	      end;
	  end;
        end;

        if de.flags.duplicate
	then do;
	  defnl = defnl + currentsize (dt);
	  make_comp_ht = true;
	end;
      end;
  end;

  /* pass 2: create the actual definition hash table */

  dh.hash_table_relp = defnl;
  dhtp = addwordno (dhp, defnl);
  dht.n_entries = opt_size (n_names);
  defnl = defnl + currentsize (dht);

  do d = 1 to di.N_defs;
    dep = addr (di.def (d));

    if (de.flags.duplicate & de.dup_tbl_relp = 0) | de.class = 3 |
         de.flags.ignore
      then ;
      else do;
        accp = addwordno (dhp, smi.string (de.strx).relp);
        htx = hash (accp, dht.n_entries);

        do while (unspec (dht.table (htx)) ^= ""b);
	htx = mod (htx, dht.n_entries) + 1;
        end;

        if de.duplicate
	then dht.table (htx).def_relp = de.dup_tbl_relp;
	else dht.table (htx).def_relp = dh_size + (d - 1) * def_size;
      end;
  end;

  /* pass 3: if we need a component hash table we build that now */

  if make_comp_ht
    then do;

      chtp = addwordno (dhp, defnl);
      cht.n_entries = opt_size (n_segnames);
      defnl = defnl + currentsize (cht);

      do d = 1 to di.N_defs;
        dep = addr (di.def (d));
        if de.class = 3 & ^de.flags.ignore
	then do;
	  accp = addwordno (dhp, smi.string (de.strx).relp);

	  htx = hash (accp, cht.n_entries);

	  do while (unspec (cht.table (htx)) ^= ""b);
	    htx = mod (htx, cht.n_entries) + 1;
	  end;

	  relp, cht.table (htx).def_relp = dh_size + (d - 1) * def_size;
	  snp = addwordno (dhp, relp);
	  defp = addwordno (dhp, sn.first_relp);
	  cht.table (htx).block_hdr_relp = def.segname_relp;
	end;
      end;
    end;

  end create_hash_table;

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


opt_size:
  proc (n_names)			/** valid entry count   (in )	*/
       returns (fixed bin);		/** opt table size	    (out) */

  /*** ****************************************************************/
  /***							*/
  /***	Name:	opt_size					*/
  /***	Input:	n_names					*/
  /***	Function:	calculates the definition hash table size from	*/
  /***		the number of entries to be included.		*/
  /***	Output:	ht_size					*/
  /***							*/
  /*** ****************************************************************/

  /* constants */

  dcl sizes		(1:11) fixed bin static options (constant)
			init (13, 27, 53, 89, 157, 307, 503, 733,
			1009, 1451, 2003);

  /* parameters */

  dcl n_names		fixed bin parameter;

  /* automatic */

  dcl i			fixed bin automatic;
  dcl ht_size		fixed bin automatic;

  /* allow for 20% of the buckets to be empty */

  ht_size = n_names * 1.25;

  /* pick an appropriate number of entries */

  do i = 1 to hbound (sizes, 1);
    if ht_size <= sizes (i)
      then return (sizes (i));
  end;

  /* default for very large hash tables */

  return (ht_size);

  end opt_size;

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


hash:
  proc (strp,			/** acc string pointer  (in )	*/
       size)			/** hash table size	    (in ) */
       returns (fixed bin);		/** hash index	    (out) */

  /*** ****************************************************************/
  /***							*/
  /***	Name:	hash					*/
  /***	Input:	strp, size				*/
  /***	Function:	computes the hash function for a definition hash	*/
  /***		table.					*/
  /***	Output:	index					*/
  /***							*/
  /*** ****************************************************************/

  /* parameter */

  dcl strp		ptr parameter;
  dcl size		fixed bin parameter;

  /* based */

  dcl word		fixed bin (35) based (strp);

  return (mod (word, size) + 1);

  end hash;

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


relocate_link_ref:
  proc (word,			/** word to relocate    (i/o)	*/
       relinfo,			/** relinfo for word    (i/o) */
       static_size);		/** size of static scn  (in ) */

  /*** ****************************************************************/
  /***							*/
  /***	Name:	relocate_link_ref				*/
  /***	Input:	word, relinfo, static_size			*/
  /***	Function: takes a word and relocation info and adjusts any	*/
  /***		reference to the linkage section to compensate	*/
  /***		for the insertion of the static section.	*/
  /***	Output:	word, relinfo				*/
  /***							*/
  /*** ****************************************************************/

  /* parameters */

  dcl word		bit (36) aligned parameter;
  dcl relinfo		char (2) varying parameter;
  dcl static_size		fixed bin parameter;

  /* based */

  dcl 01 w15		(1:2) unaligned based (addr (word)),
       02 pad		bit (3),
       02 value		fixed bin (15) unsigned;
  dcl 01 w18		(1:2) unaligned based (addr (word)),
       02 value		fixed bin (18) unsigned;

  /* automatic */

  dcl min			fixed bin automatic;
  dcl s			fixed bin automatic;
  dcl st_size		fixed bin (18) unsigned automatic;

  /* don't bother if the static section is separate */

  if ocu_data.flags.separate_static
    then return;

  /* leave link references that are not into the link array */

  min = vlh_size;

  /* round the static section size to an even word boundary to keep	*/
  /* the link array aligned properly (ITS pointers must be on a	*/
  /* doubleword boundary or the hardware complains. . .)		*/

  st_size = static_size + mod (static_size, 2);

  /* relocate each halfword */

  do s = Left, Right;
    if (index ("23", substr (relinfo, s, 1)) > 0) & (w18 (s).value >= min)
      then w18 (s).value = w18 (s).value + st_size;
    if (substr (relinfo, s, 1) = "l") & (w15 (s).value >= min)
      then w15 (s).value = w15 (s).value + st_size;

    /* adjust static references for the size of the linkage header	*/
    /* and convert the relinfo into linkage section relinfo		*/

    if substr (relinfo, s, 1) = "8"
      then w18 (s).value = w18 (s).value + vlh_size;
    if substr (relinfo, s, 1) = "i"
      then w15 (s).value = w15 (s).value + vlh_size;
  end;

  end relocate_link_ref;

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


append_relinfo:
  proc (relinfop,			/** prt to relinfo blk  (i/o)	*/
       scn,			/** section to add to   (in ) */
       relinfo_chrs,		/** relinfo char string (in ) */
       abs_count);			/** pending abs halfwds (i/o) */

  /*** ****************************************************************/
  /***							*/
  /***	Name:	append_relinfo				*/
  /***	Input:	relinfop, scn, relinfo_chrs, abs_count		*/
  /***	Function:	appends the specified relinfo to the relinfo	*/
  /***		block given.				*/
  /***		Absolute relocation is not appended to the	*/
  /***		relinfo until the number of consecutive		*/
  /***		halfwords is determined.  If the relinfo_chr	*/
  /***		specified is a blank, no additional relinfo is	*/
  /***		emitted but any saved absolute relinfo is	*/
  /***		appended to the relinfo block.  This is used to	*/
  /***		force all the relinfo into the block when it is 	*/
  /***		complete.					*/
  /***	Output:	relinfop, abs_count				*/
  /***							*/
  /*** ****************************************************************/

  /* parameters */

  dcl relinfop		ptr parameter;
  dcl scn			fixed bin parameter;
  dcl relinfo_chrs		char (*) varying parameter;
  dcl abs_count		fixed bin parameter;

  /* based */

  dcl 01 reloc_info		aligned based (relinfop),
       02 header		like relinfo_blocks.header,
       02 relbits		bit (0 refer (reloc_info.header.n_bits))
			aligned;

  /* automatic */

  dcl c			fixed bin (21) automatic;
  dcl 01 exp_abs		unaligned automatic,
       02 code		bit (5),
       02 count		fixed bin (10) unsigned;
  dcl i			fixed bin (21) automatic;
  dcl old_len		fixed bin (24) automatic;
  dcl relinfo_chr		char (1) automatic;

  /* builtin */

  dcl length		builtin;

  /* don't bother is the output is not relocatable */

  if reloc_info.no_relinfo
    then return;

  /* set the section start if necessary */

  if reloc_info.section (scn).start_offset = 0
    then reloc_info.section (scn).start_offset = reloc_info.header.n_bits + 1;

  /* for each character in the relinfo string */

  do c = 1 to length (relinfo_chrs);
    relinfo_chr = substr (relinfo_chrs, c, 1);

    /* if the relinfo is not absolute . . . */

    if relinfo_chr ^= "a"
      then do;

        /* see if we have pending absolute stuff to insert */

        do while (abs_count > 15);

	/* use expanded absolute if possible */

	old_len = reloc_info.header.n_bits;
	exp_abs.code = "11110"b;
	exp_abs.count = min (abs_count, 1023);
	abs_count = abs_count - exp_abs.count;
	reloc_info.header.n_bits = reloc_info.header.n_bits + 15;
	reloc_info.section (scn).n_bits =
	     reloc_info.section (scn).n_bits + 15;
	substr (reloc_info.relbits, old_len + 1, 15) = unspec (exp_abs);
        end;

        /* get the remainder using normal (non-expanded) absolute */

        if abs_count > 0
	then do;
	  old_len = reloc_info.header.n_bits;
	  reloc_info.header.n_bits = reloc_info.header.n_bits + abs_count;
	  reloc_info.section (scn).n_bits =
	       reloc_info.section (scn).n_bits + abs_count;
	  substr (reloc_info.relbits, old_len + 1, abs_count) =
	       copy ("0"b, abs_count);
	  abs_count = 0;
	end;

        /* now search for the proper relocation bits */

        i = index (reloc_chars, relinfo_chr);
        if i > 0
	then do;
	  old_len = reloc_info.header.n_bits;
	  reloc_info.header.n_bits = reloc_info.header.n_bits + 5;
	  reloc_info.section (scn).n_bits =
	       reloc_info.section (scn).n_bits + 5;
	  substr (reloc_info.relbits, old_len + 1, 5) = reloc_bits (i);
	end;
      end;

      /* otherwise, if the relocation is absolute, just increment the	*/
      /* count and continue.					*/

      else abs_count = abs_count + 1;
  end;

  end append_relinfo;

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


validate_component:
  proc (mip,			/** pointer to msf_info (in )	*/
       comp);			/** component index	    (in ) */

  /*** ****************************************************************/
  /***							*/
  /***	Name:	validate_component				*/
  /***	Input:	mip, comp					*/
  /***	Function:	This procedure is used to attempt to validate	*/
  /***		a given object segment within a set of object	*/
  /***		segments is valid as an MSF component. This is	*/
  /***		determined based on the following criteria:	*/
  /***		  -- all of the segments must be in the same	*/
  /***		     directory.  This values is set when the	*/
  /***		     first component is evaluated and checked	*/
  /***		     by the others.				*/
  /***		  -- the directory must otherwise be empty.	*/
  /***		  -- the name of the segment must correspond	*/
  /***		     to the component number of the segment.	*/
  /***		  -- the component must be an object segment.	*/
  /***		  -- the segment must have a msf_map.		*/
  /***		  -- the component number must correspond to	*/
  /***		     the component number stored in the msf_map.	*/
  /***		  -- the number of components must correspond	*/
  /***		     to the component count in the msf_map.	*/
  /***		In the process of determining validity, the	*/
  /***		bit count and relpointers to the various	*/
  /***		sections are also filled in in the msf_info	*/
  /***		structure.				*/
  /***	Output:	none					*/
  /***							*/
  /*** ****************************************************************/

  /* parameters */

  dcl mip			ptr parameter;
  dcl comp		fixed bin parameter;

  /* based */

  dcl 01 dh		aligned like definition_header based (dhp);
  dcl 01 mi		aligned based (mip),
       02 header		aligned like msf_info.header,
       02 component		dim (0 refer (mi.N_components))
			like msf_info.component;
  dcl 01 mm		aligned like msf_map based (mmp);

  /* automatic */

  dcl bc			fixed bin (24) automatic;
  dcl count		fixed bin automatic;
  dcl dname		char (168) automatic;
  dcl dhp			ptr automatic;
  dcl dnl			fixed bin automatic;
  dcl ename		char (32) automatic;
  dcl 01 oi		aligned like object_info automatic;
  dcl segp		ptr automatic;
  dcl mmp			ptr automatic;

  segp = mi.component (comp).segp;

  /* get the directory and entry names of the segment */

  call hcs_$fs_get_path_name (segp, dname, dnl, ename, ec);
  if ec ^= 0
    then call sub_err_ (ec, "argument", ACTION_CANT_RESTART, null, 0);

  if mi.containing_dir = ""
    then do;

      /* save the directory name */

      mi.containing_dir = get_shortest_path_ (substr (dname, 1, dnl));

      /* check out the directory to make sure there are no extraneous	*/
      /* segments, directories, etc.				*/

retry_star_match:
      call hcs_$star_ (mi.containing_dir, "**", star_ALL_ENTRIES, null,
	 count, null, null, ec);
      if ec ^= 0
        then do;
	call sub_err_ (ec, "", ACTION_CAN_RESTART, null, 0);
	goto retry_star_match;
        end;

      if count > mi.N_components + 1
        then call sub_err_ (error_table_$bad_arg, "argument",
	        ACTION_CANT_RESTART, null, 0,
	        "^/There are extra entries in the containing directory.");
    end;
  else if mi.containing_dir ^= get_shortest_path_ (substr (dname, 1, dnl))
    then call sub_err_ (error_table_$bad_arg, "argument",
	    ACTION_CANT_RESTART, null, 0,
	    "^/All of the components do not reside in the same directory.");

  if ename ^= ltrim (char (comp))
    then call sub_err_ (error_table_$bad_arg, "argument",
	    ACTION_CANT_RESTART, null, 0,
	    "^/The entryname for component ^d is ""^a"" instead of ""^d""",
	    comp, ename, comp);

  call hcs_$status_mins (segp, 0, bc, ec);
  mi.component (comp).bc = bc;

  oi.version_number = object_info_version_2;

  /* see if this is actually an object segment */

  call object_info_$brief (segp, bc, addr (oi), ec);
  if ec ^= 0
    then call sub_err_ (ec, "argument", ACTION_CANT_RESTART, null, 0,
	    "^/Component ^d is not an object segment.", comp);

  /* extract the section relpointers */

  mi.component (comp).text_relp = fixed (rel (oi.textp), 18);
  mi.component (comp).defn_relp = fixed (rel (oi.defp), 18);
  mi.component (comp).link_relp = fixed (rel (oi.linkp), 18);
  mi.component (comp).stat_relp = fixed (rel (oi.statp), 18);
  mi.component (comp).symb_relp = fixed (rel (oi.symbp), 18);

  /* check for presence and validity of the msf_map */

  dhp = oi.defp;

  if dh.msf_map_relp = 0
    then call sub_err_ (error_table_$inconsistent_object_msf, "argument",
	    ACTION_CANT_RESTART, null, 0,
	    "^/Component ^d has no msf_map.", comp);

  mmp = addwordno (dhp, dh.msf_map_relp);

  if mm.version ^= msf_map_version_1
    then call sub_err_ (error_table_$unimplemented_version, "argument",
	    ACTION_CANT_RESTART, null, 0,
	    "^/Incorrect version in msf_map for component ^d.", comp);

  if mm.component_count ^= mi.N_components + 1
    then call sub_err_ (error_table_$inconsistent_object_msf, "argument",
	    ACTION_CANT_RESTART, null, 0,
	    "^/Number of components in input list (^d) disagrees with the"
	    ||
	    "^/number given in the msf_map (^d) for component ^d.",
	    mi.N_components + 1, mm.component_count, comp);

  if mm.my_component ^= comp
    then call sub_err_ (error_table_$inconsistent_object_msf, "argument",
	    ACTION_CANT_RESTART, null, 0,
	    "^/Component number ^d has the component number ^d in the msf_map.",
	    comp, mm.my_component);

  end validate_component;

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


copy_defs:
  proc (odp,			/** ocu_data ptr	    (in )	*/
       mip,			/** msf_info pointer    (in )	*/
       comp);			/** component number    (in ) */

  /*** ****************************************************************/
  /***							*/
  /***	Name:	copy_defs					*/
  /***	Input:	odp, mip, comp				*/
  /***	Function:	scans the definition list of component <comp> in	*/
  /***		the msf_info structure and emits partial links	*/
  /***		and corresponding indirect definitions.		*/
  /***	Output:	none					*/
  /***							*/
  /*** ****************************************************************/

  /* parameters */

  dcl odp			ptr parameter;
  dcl mip			ptr parameter;
  dcl comp		fixed bin parameter;

  /* based */

  dcl 01 acc		aligned based (accp),
       02 count		fixed bin (9) unsigned unaligned,
       02 string		char (0 refer (acc.count)) unaligned;
  dcl 01 def		aligned like definition based (defp);
  dcl 01 dh		aligned like definition_header based (dhp);
  dcl 01 mi		aligned based (mip),
       02 header		aligned like msf_info.header,
       02 component		dim (0 refer (mi.N_components))
			like msf_info.component;
  dcl word		aligned fixed bin (35) based (defp);

  /* automatic */

  dcl accp		ptr automatic;
  dcl dhp			ptr automatic;
  dcl defp		ptr automatic;
  dcl dummy		fixed bin (18) unsigned automatic;
  dcl lk_relp		fixed bin (18) unsigned automatic;
  dcl flags		bit (4) automatic;

  /* get the definition header */

  dhp = addwordno (mi.component (comp).segp, mi.component (comp).defn_relp);

  /* scan the definition list */

  do defp = addwordno (dhp, dh.def_list_relp)
       repeat (addwordno (dhp, def.forward_relp))
       while (word ^= 0);

    /* for each externally visible definition . . . */

    if ^def.flags.ignore
      then do;

        /* get the name ACC string */

        accp = addwordno (dhp, def.name_relp);

        /* if it is a segname (class = 3), then emit a segname */

        if def.class = 3
	then dummy = emit_segname (odp, (acc.string),
		DEFINITION_FLAGS_RETAIN);
	else do;

	  /* if not a segname, emit a partial link to the target	*/
	  /* and an indirect definition to the link.		*/

	  flags = DEFINITION_FLAGS_INDIRECT | DEFINITION_FLAGS_RETAIN;
	  if def.flags.entry
	    then flags = flags | DEFINITION_FLAGS_ENTRY;

	  lk_relp = emit_partial_link (odp, (comp), (def.class),
	       (def.thing_relp), ""b);
	  dummy = emit_definition (odp, (acc.string), (CLASS_LINKAGE),
	       lk_relp, flags);
	end;
      end;
  end;

  end copy_defs;

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


mk_symbol_scn:
  proc (odp,			/** ocu_data pointer    (in )	*/
       mip);			/** msf_info pointer    (in ) */

  /*** ****************************************************************/
  /***							*/
  /***	Name:	mk_symbol_hdr				*/
  /***	Input:	odp, mip					*/
  /***	Function:	creates the symbol section to be used for object	*/
  /***		MSF component 0 and emits it.			*/
  /***	Output:	none					*/
  /***							*/
  /*** ****************************************************************/

  /* parameters */

  dcl odp			ptr parameter;
  dcl mip			ptr parameter;

  /* based */

  dcl 01 mi		aligned based (mip),
       02 header		aligned like msf_info.header,
       02 component		dim (0 refer (mi.N_components))
			like msf_info.component;
  dcl 01 mss		aligned based (mssp),
       02 header		aligned like msf_symbol_scn.header,
       02 user		char (user_length
			refer (mss.header.userid.size)) aligned,
       02 version		char (version_length
			refer (mss.header.gen_version.size)) aligned;
  dcl system_free_area	area based (system_free_areap);

  /* automatic */

  dcl dummy		fixed bin (18) unsigned automatic;
  dcl group_id		char (40) varying automatic;
  dcl mssp		ptr automatic;
  dcl reloc_str		char (2048) automatic;
  dcl system_free_areap	ptr automatic;
  dcl user_length		fixed bin automatic;
  dcl version_length	fixed bin automatic;

  /* builtin */

  dcl length		builtin;
  dcl size		builtin;

  system_free_areap = get_system_free_area_ ();

  mssp = null;

  on cleanup
    begin;
    if mssp ^= null
      then free mss in (system_free_area);
  end;

  /* find the user id string */

  group_id = get_group_id_ ();
  version_length = length (mi.gen_info.gen_version);
  user_length = length (group_id);

  /* allocate the symbol section structure */

  allocate mss in (system_free_area);

  /* set all of the values in the symbol section */

  mss.header.decl_version = 1;
  mss.header.identifier = "symbtree";
  mss.header.gen_number = mi.gen_info.gen_number;
  mss.header.gen_created = mi.gen_info.gen_created;
  mss.header.object_created = clock ();
  mss.header.generator = mi.gen_info.generator;
  mss.header.text_boundary = 2;
  mss.header.stat_boundary = 2;
  mss.header.source_map = 0;
  mss.header.area_pointer = currentsize (mss);
  mss.header.backpointer = 0;
  mss.header.block_size = 0;
  mss.header.next_block = 0;
  mss.header.rel_text = 0;
  mss.header.rel_def = 0;
  mss.header.rel_link = 0;
  mss.header.rel_symbol = 0;
  mss.header.mini_truncate = currentsize (mss);
  mss.header.maxi_truncate = currentsize (mss);

  /* store the character strings */

  mss.user = group_id;
  mss.version = mi.gen_info.gen_version;

  /* calculate the offsets */

  mss.header.userid.offset = size (std_symbol_header);
  mss.header.gen_version.offset = size (std_symbol_header) +
       divide (user_length + 3, 4, 18);
  mss.header.comment.offset = 0;
  mss.header.comment.size = 0;

  /* overlay a word array on the structure */

  word_arrayp = mssp;
  word_arrayl = currentsize (mss);

  /* generate the relocation information */

  reloc_str = "aaaaaaaaaaaaaaaaaaaararaaaaaaraaaaaaaaaa" ||
       copy ("a", currentsize (mss) - size (std_symbol_header));

  /* emit the symbol section */

  dummy = emit_symbol (odp, word_arrayp, addr (reloc_str), word_arrayl);

  /* free the symbol section structure */

  free mss in (system_free_area);
  mssp = null;

  end mk_symbol_scn;

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


%include access_mode_values;
%include definition_dcls;
%include object_info;
%include object_link_dcls;
%include object_map;
%include ocu_structures;
%include ocu_dcls;
%include star_structures;
%include std_symbol_header;
%include sub_err_flags;

  end ocu_;
