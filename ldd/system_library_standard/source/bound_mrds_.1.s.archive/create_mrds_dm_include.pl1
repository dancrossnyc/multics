/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(85-11-21,Dupuis), approve(86-08-05,MCR7491), audit(86-08-08,Blair),
     install(86-08-15,MR12.0-1127):
     Provided a fix for phx19078 (mrds #150). PL/I doesn't accept
     hyphens in names, but MRDS, COBOL, and other things do. Changed
     the code to translate hyphens to underscores when generating a
     PL/I include.
  2) change(86-11-21,Blair), approve(87-02-05,MCR7593),
     audit(87-03-24,Gilcrease), install(87-03-25,MR12.1-1012):
     Implement SCP6238 to allow creation of include files and tables for single
     relations or a list of relations, and to name the output_files with a
     control argument.
                                                   END HISTORY COMMENTS */


create_mrds_dm_include: cmdmi: proc;

/* DESCRIPTION:

   *** create_mrds_dm_include (cmdmi) This entry creates an  include
   file  from  a MRDS data base model. The file is named "<data base
   model  entry  name>.incl.pl1".  The  include  file   contains   a
   structure for each relation with the attributes for each relation
   declared as second level members of the structure.

   *** create_mrds_dm_table (cmdmt)  This  entry  creates  a  sement
   displaying  the  relations  in  a  data  base  model suitable for
   printing on a line printer. The display for each  relation  is  a
   series  of  rectangular  boxes,  each  containing  the name of an
   attribute. If the attribute is a primary key, a  "*"  appears  in
   the  upper  left corner. If the attribute is a secondary index, a
   "O" will appear in the upper right corner.
*/

/* HISTORY:

   created 78 September by Art Beattie

   Modified   by   Jim   Gray   -   -   Dec.   1979,    to    change
   mrds_cmdb_alpha_desc  to  mu_display_descriptor,  so that
   the new data types could be handled.

   Modified by Jim Gray - - Jan.  1980,  to  put  descriptor  abbrev
   function  in mu_trim_descriptor, to handle new descriptor
   lengths

   Modified by Jim Gray - - Jan. 1980, to  handle  ".db"  suffix  on
   databases

   Modified by Jim Gray - - April 1980, to work with submodels.

   Modified by Jim - - 80-9-23,  to  work  with  databases/submodels
   that have a -decode_dcl user view of the data declared. The entry
   $set_user_view in mrds_dm_get_attributes returns  the  user  view
   instead of the db view in the descriptor, if they differ.

   80-12-12 Jim Gray : Changed to use actual  entry  name  given  in
   users  link  or  addname,  rather  than  surprising  him  with  a
   different name on the database for his include or  table  segment
   name. Changed the header path to be the actual database path.

   80-12-19 Jim Gray :  added  -based  control  argument  to  CMDMI.
   changed version number from 2.0 to 3.0.

   80-12-30 Jim Gray : added force  iox_$close/detach  in  clean  up
   handler, for cases where error occurs, and this has not been done
   yet.

   81-1-6 Jim Gray : changed usage message  so  valid  control  args
   shown for cmdmi and cmdmt.

   81-01-28 Davids: removed mrds_dsm_display_rels.incl.pl1 which was
   not  being used. The code uses the model_relation structure which
   has the same format as the dsm_display_rels structure. Since  the
   format  of  the structures is fixed because of user documentation
   it does not matter which structure is used.

   81-01-31      Jim      Gray      :       added       use       of
   mrds_dsl_get_version$get_path_info        in       place       of
   dsl_$get_db_version, to take advantage of the improved interface.

   81-02-10 Jim Gray : added  check  for  a  peon  using  a  secured
   submodel once the database has become secured.

   81-02-11 Jim Gray : changed name of dsmd_, to  mrds_dsm_dsmd,  so
   that  the  internal,  not  extenral name in the bound segment was
   called.

   81-04-27  Jim  Gray  :  added  -long|-lg  and  -no_based  control
   arguments.  Also  made  a  non-DBA looking at secured db see only
   indexed flag, no key flags.

   81-06-05 Davids: removed references to the external user submodel
   interface  and  replaced  them  with  references to internal mrds
   interfaces (this includes both include files and  modules).  Also
   removed  declared  but  never referenced variables. Changed error
   messages to use the actual name of the  mrds_dsm_*  module  being
   called rather than the dsmd_* name that used to be called. Solved
   the  problem  of  mrds_dsm_relation_names  being  overlayed  with
   model_relations  by  allocating  a  model_relations structure and
   copying   the   contents   of    mrds_dsm_relations_names    into
   model_relations.  If any submodel relation name is longer than 32
   characters  (not  currently  possible)  it  will  not  be  copied
   correctly.

   81-10-21 Davids: Corrected the handling of add names and links so
   that  the name of the created segment depends of the name used in
   the command line and not the actual name of the database or  data
   submodel.

   83-01-10  Roger Lackey : Changed out_dir to always be working dir.

   83-01-18  Roger Lackey : added mrds_error_$no_model_submodel to handle
   the case where mrds_dsl_get_version$get_path_info
   returns mrds_error_$no_database.  Also declared undeclared variables.

   83-07-12  Roger Lackey: Changed call to tssi_$finish_segment to put
		       rw access on output segment for caller.

   84-02-15 Mike Kubicar: Fixed tr phx16539.  When displaying a submodel,
   cmdmi (and cmdmt) would always use the domains of the model in attribute
   order, no matter what the order of the attributes in the submodel was.
   The result was that attributes in a submodel would have have the wrong
   domains associated with them.

*/

/* Identify entry point used. */
	prog_name = "create_mrds_dm_include";
	creating_incl = ON;
	line_len = 110;
	go to COMMON;

create_mrds_dm_table: cmdmt: entry;
	prog_name = "create_mrds_dm_table";
	creating_incl = no;
	line_len = 136;
						/* Common code for all entries. */
COMMON:
						/* Initialize variables. */
	attr_desc_ptr = null;
	based_decls = OFF;
	brief_table = no;
	dm_path = "";
	dm_ptr = null;
	dmh_ptr = null;
	expect = 0;
	legend_len = 38;
	have_of = no;
	have_relation = no;
	mr_order_ptr = null;
	mr_ptr = null;
	ordering = no;
	order_begin, order_end = 0;
	out_ptr, out_acl_ptr = null;
	page_len = 59;
	rd_ptr = null;
	submodel = OFF;
	str_ptr = null ();
	hd_ptr = null ();
	new_rd_ptr = null ();
						/* Obtain number of arguments in this call. */
	call cu_$arg_count (nargs);
	if nargs < 1 then do;
		code = error_table_$wrong_no_of_args;
		if creating_incl then
		     options = "-based, -no_based, -order, -output_file, -page_length and/or -relation";
		else options = "-brief, -long, -line_length, -order, -output-file, -page_length and/or -relation";
		call ioa_$rsnnl (
		     "^/Usage is: ^a dm_path {-control_args}^/where control_args can be  ^a",
		     er_mess, 0, prog_name, options);
		go to ERROR;
	     end;
						/* The first argument is the pathname of the data base. */
	call cu_$arg_ptr (1, arg_ptr, arg_len, 0);

/* BEGIN CHANGE 81-01-31 ************************************************** */

	path_argument = arg;
	call mrds_dsl_get_version$get_path_info ((arg), addr (local_area),
	     mrds_path_info_structure_version, mrds_path_info_ptr,
	     code);				/* get full path, with .db suffix if needed */
	if mrds_path_info_ptr = null () then
	     dm_path = arg;
	else do;
		dm_path = mrds_path_info.absolute_path;
		db_version = mrds_path_info.mrds_version;
	     end;
	if code ^= 0 then do;
		if code = mrds_error_$no_database then
		     code = mrds_error_$no_model_submodel;

		call ioa_$rsnnl ("^/No database found using the data model path ""^a"".",
		     er_mess, 0, dm_path);
		goto ERROR;
	     end;

	if mrds_path_info.type.submodel then
	     submodel = ON;

/* END CHANGE 81-01-31 ********************************************** */

/* Scan the arguments which are not position sensitive. */
	do iarg = 2 to nargs;
	     call cu_$arg_ptr (iarg, arg_ptr, arg_len, 0);
RECHECK_ARG:
	     if expect = 0 then do;
						/* Next argument doesn't follow a previously processed control */
						/*   argument. */
		     if arg = "-relation" | arg = "-rel" then
			     expect = rel_name_arg;
		     else if arg = "-of" | arg = "-output_file" then
			     expect = output_file_arg;
		     else if arg = "-brief" | arg = "-bf" | arg = "-long" | arg = "-lg" then do;
			     if arg = "-brief" | arg = "-bf" then
				brief_table = ON;
			     if creating_incl then call ioa_ ("^a: The ^a control argument is ignored by this command.",
				     prog_name, arg);
			end;
		     else if arg = "-line_length" then go to HAVE_LL_CTL;
		     else if arg = "-ll" then do;

HAVE_LL_CTL:
			     if creating_incl then do;
				     call ioa_ ("^a: The ^a control argument is ignored by this command.", prog_name, arg);
				     iarg = iarg + 1;
				end;
			     else expect = ll_arg;
			end;
		     else if arg = "-page_length" then expect = pl_arg;
		     else if arg = "-pl" then expect = pl_arg;
		     else if arg = "-order" then do;
			     expect = order_arg;
			     ordering = ON;
			     order_begin = 0;
			end;
		     else if arg = "-based" | arg = "-no_based" then do;
			     if arg = "-based" then
				based_decls = ON;
			     if ^creating_incl then do;
				     call ioa_$rsnnl ("^/The ""-based"" control argument is ignored by this command.", er_mess, 0);
				     code = error_table_$badopt;
				     goto ERROR;
				end;
			end;
		     else if substr (arg, 1, 1) = "-" then do;
			     call ioa_$rsnnl ("^/Unrecognized control argument, ^a", er_mess, 0, arg);
			     code = error_table_$badopt;
			     go to ERROR;
			end;
		     else do;			/* Pathname already given.  Might be an error. */
			     call ioa_$rsnnl ("^/Bad syntax in this call at the argument, ^a", er_mess, 0, arg);
			     code = error_table_$badopt;
			     go to ERROR;
			end;
		     control_arg = arg;
		end;				/* Ends do if not expecting. */


	     else do;				/* Current arg occurs after control arg requiring one. */
		     if expect = output_file_arg then do;
			out_entry_name = arg;
			have_of = ON;
			expect = 0;
			end;
		     if expect = ll_arg then do;
						/* Expecting argument after -line_length control argument. */
			     on conversion call conv_error ();
			     line_len = convert (line_len, arg);
			     revert conversion;
			     if (^creating_incl & line_len < 64) | (creating_incl & line_len < 100) | line_len > 136 then do;
				     call ioa_$rsnnl ("^/Value of line length argument is out of the range, 63<ll<137; ^d",
					er_mess, 0, line_len);
				     code = error_table_$bad_arg;
				     go to ERROR;
				end;
			     expect = 0;
			end;			/* Ends do if expect = ll_arg. */

		     if expect = pl_arg then do;
						/* Expecting argument after -page_length control argument. */
			     on conversion call conv_error ();
			     page_len = convert (page_len, arg);
			     revert conversion;
			     if (page_len ^= 0 & page_len < 30) | page_len > 127 then do;
				     call ioa_$rsnnl ("^/^a ^d", er_mess, 0,
					"Value of page length argument can be 0 or in the range 29<pl<128. Value received was",
					page_len);
				     code = error_table_$bad_arg;
				     go to ERROR;
				end;
			     expect = 0;
			end;			/* Ends do if expect = pl_arg. */

		     if expect = order_arg | expect = rel_name_arg then do;
						/* Expecting relation names after -order control argument. */
			     if expect = rel_name_arg then have_relation = ON;
			     if order_begin = 0 then order_begin = iarg; /* Remember where first name is. */
			     if substr (arg, 1, 1) = "-" then do;
						/* Encountered a control argument. (Relation names */
						/*   cannot start with a "-" character. */
				     order_end = iarg - 1; /* Last argument was last order name, remember its position. */
				     expect = 0;
				     if order_begin > order_end then go to MISSING_VALUE;
				     go to RECHECK_ARG;
				end;
			     if iarg = nargs then do; /* Since this is the last argument, remember its position. */
				     order_end = iarg;
				     expect = 0;
				end;
			end;			/* Ends do if expect = order_arg. */
		end;				/* Ends do if expecting. */
	end;					/* Ends do for iarg loop. */
						/* Check for overall syntaxical errors. */
	if expect ^= 0 then do;

MISSING_VALUE:
		code = error_table_$noarg;
		call ioa_$rsnnl ("^/Required value for ^a control argument is missing.", er_mess, 0, control_arg);
		go to ERROR;
	     end;
	if ordering then
	     if have_relation then do;
		code = error_table_$inconsistent;
		call ioa_$rsnnl ("^/Inconsistent combination of arguments, -relation and -order.", er_mess, 0);
		go to ERROR;
		end;
	     else if order_begin = 0 then do;		/* No names were supplied after -order argument. */
		     control_arg = "-order";
		     go to MISSING_VALUE;
		end;

	call expand_pathname_ (dm_path, dm_dir, dm_entry_name, code);
	if code ^= 0 then do;
		call ioa_$rsnnl ("^/Error occured in expanding pathname for, ^a",
		     er_mess, 0, dm_path);
		go to ERROR;
	     end;

/* Prefer to have actual pathname of data model. */
	call hcs_$get_link_target (dm_dir, dm_entry_name, dm_adir, dm_aentry_name, code);
	if code ^= 0 then do;
		call ioa_$rsnnl ("^/Error occured in obtaining link target for , ^a>^a",
		     er_mess, 0, dm_dir, dm_entry_name);
		go to ERROR;
	     end;
						/* This is mostly for error messages. */
	dm_abs_path = rtrim (dm_adir) || ">" || dm_aentry_name;
						/* Create proper suffix for output file name. */
	if creating_incl then suffix = "incl.pl1";
	else suffix = "table";
	if submodel then
	     entry_suffix = "dsm";
	else entry_suffix = "db";

/* CHANGE: use entry name given, not actual database name */

	if ^have_of then do;
	     call expand_pathname_ (path_argument, out_dir, out_entry_name, code);
	     if code ^= 0 then do;
		call ioa_$rsnnl ("^/Tried to expand pathname, ^a.^a, in working directory.",
		     er_mess, 0, dm_entry_name, suffix);
		go to ERROR;
		end;
	     end;
	
	out_dir = get_wdir_ ();			/* Always put output in working_dir */

	call suffixed_name_$new_suffix ((out_entry_name), (entry_suffix), suffix, out_entry_name, code);
	if code ^= 0 then do;
		call ioa_$rsnnl ("^/Tried to change suffix on ^a.^a, in working directory.",
		     er_mess, 0, dm_entry_name, suffix);
		go to ERROR;
	     end;

/* Need some working storage. */
	dm_area_ptr = get_system_free_area_ ();
						/* Open the data model for reading only. */
	if submodel then do;
		sm_abs_path = dm_abs_path;
		call mrds_dsm_open$read (dm_path, submodel_iocb_ptr, code);
		if code ^= 0 then do;
			call ioa_$rsnnl ("^/Unable to open the submodel, ^a",
			     er_mess, 0, dm_path);
			goto ERROR;
		     end;

		call mrds_dsm_read_header (dm_area_ptr, hd_ptr, submodel_iocb_ptr, code);
		if hd_ptr = null () | code ^= 0 then do;
			call ioa_$rsnnl ("^/Unable to get header info from mrds_dsm_read_header for submodel, ^a",
			     er_mess, 0, dm_abs_path);
			goto ERROR;
		     end;

/* make a phony dm_header, with submodel info in it */

		allocate dm_header set (dmh_ptr) in (dm_area);

		dmh_ptr -> dm_header.dm_header_id = "SUBMODEL";
		dmh_ptr -> dm_header.dmd_version = hd_ptr -> mrds_dsm_header.dsm_generator_version;
		dmh_ptr -> dm_header.creator_id = hd_ptr -> mrds_dsm_header.creator_id;
		dmh_ptr -> dm_header.create_time = hd_ptr -> mrds_dsm_header.date_time_generated;

	     end;

	if submodel then
	     model_path = hd_ptr -> mrds_dsm_header.database_pn;
	else model_path = dm_abs_path;		/* CHANGE: use actual not given path in header */

	call mrds_dm_open ((model_path), retrieval, dm_ptr, code);
	if dm_ptr = null | code ^= 0 then do;
		call ioa_$rsnnl ("^/Received a null pointer from dmd_$open_dm for data model, ^a",
		     er_mess, 0, model_path);
		go to ERROR;
	     end;
	on cleanup call clean_up ();			/* Got to start thinking about cleaning this up if anything */
						/*   goes wrong. */

/* Get header information from data model for title block. */
	if ^submodel then do;
		call mrds_dm_get_header (dm_ptr, dm_area_ptr, dmh_ptr, code);
		if dmh_ptr = null () | code ^= 0 then do;
			call ioa_$rsnnl ("^/Unable to get header info from dmd_$get_header for data model, ^a",
			     er_mess, 0, model_path);
			goto ERROR;
		     end;

	     end;
	call date_time_ (create_time, time_str);
						/* Want to put current time into title block. */
	call date_time_ ((clock_ ()), current_date_time);
						/* Setup basic title block. */

/* BEGIN CHANGE 81-02-10 ********************************************** */
/* 	check to see if the database is secured */

	secured_view = OFF;
	if dmd_version >= 4 then do;

		call mrds_dm_db_secured$get_secured_status (dm_ptr, addr (local_area),
		     database_state_structure_version, database_state_ptr, code);
		if code ^= 0 then do;
			call ioa_$rsnnl ("^/Unable to get secured state of database ^a",
			     er_mess, 0, model_path);
			goto ERROR;
		     end;

		if database_state.secured then do;

/* check for correct authorization and usage,
   a DBA can do anything, a peon must be using a secure submodel */

			call mrds_dm_authorization$get_user_class (model_path, addr (local_area),
			     mrds_authorization_structure_version, mrds_authorization_ptr, code);
			if code ^= 0 then do;
				call ioa_$rsnnl ("^/Unable to get user class for database ^a",
				     er_mess, 0, model_path);
				goto ERROR;
			     end;

			if mrds_authorization.administrator then ; /* user is a DBA */
			else do;

/* must check that peon is using a secure submodel */

				secured_view = ON;
				secure_submodel = OFF;
				if ^submodel then ;
				else if mrds_dm_secured_submodel (
				     rtrim (model_path), rtrim (dm_adir), rtrim (dm_aentry_name)) then
				     secure_submodel = ON;

				if ^secure_submodel then do;
					if submodel then
					     call ioa_$rsnnl ("^/^a^a^a^a^a ^a^a^a", er_mess, 0,
						"The submodel """, sm_abs_path, """ refers to a database """,
						model_path, """ that has been secured,",
						"but the submodel itself is not in the databases inferior directory """,
						mrds_data_$submodel_dir_name, """.");
					else call ioa_$rsnnl ("^/^a^a^a ^a", er_mess, 0,
						"The database """, model_path, """ has been secured,",
						"but the caller is not a DBA, and must use a submodel to reference it.");
					code = mrds_error_$inc_secure_open;
					goto ERROR;
				     end;

			     end;

		     end;

	     end;

/* END CHANGE 81-02-10 ***************************************************** */

/* set up output header */

	lines_left = page_len;
	buf = "";

	if submodel then
	     model_type = " Sub";
	else model_type = "Data";

	call ioa_$rsnnl ("^3x* BEGIN ^a", buf (3), 0, out_entry_name);
	call ioa_$rsnnl ("^3x*^6xcreated: ^a", buf (4), 0, current_date_time);
	call ioa_$rsnnl ("^3x*^11xby: ^a (^a)", buf (5), 0, prog_name, version);

/* CHANGE: using actual path of model in header, rather than path given */

	if submodel then
	     call ioa_$rsnnl ("^3x* ^a model ^a", buf (7), 0, model_type, sm_abs_path);
	else call ioa_$rsnnl ("^3x* ^a model ^a", buf (7), 0, model_type, model_path);
	call ioa_$rsnnl ("^3x*^6xcreated: ^a", buf (8), 0, time_str);
	call ioa_$rsnnl ("^3x*^6xversion: ^d", buf (9), 0, dmd_version);
	call ioa_$rsnnl ("^3x*^11xby: ^a", buf (10), 0, dm_header.creator_id);
						/* Determine longest line in title block to find out where */
						/*   right side of box is. */
	max_buf_len = length (buf (3));
	do i = 4 to 10;
	     max_buf_len = max (max_buf_len, length (buf (i)));
	end;
						/* Put right side of title block in. */
	do i = 3 to 10;
	     buf (i) = buf (i) || copy (" ", max_buf_len + 1 - length (buf (i))) || "*";
	end;
						/* Now for the top side of title block. */
	er_mess = copy ("*", max_buf_len - 1);
	call ioa_$rsnnl ("/* ^a", buf (1), 0, er_mess);
						/* Finially, the bottom side. */
	call ioa_$rsnnl ("^3x*^vx*", buf (2), 0, max_buf_len - 3);
	call ioa_$rsnnl ("^3x^a */", buf (12), 0, er_mess);
						/* Put some blank separator lines in title block for */
						/* appearances. */
	buf (6), buf (11) = buf (2);
						/* Ready to access output segment, so lets try to get it. */

	call tssi_$get_segment (out_dir, out_entry_name, out_ptr, out_acl_ptr, code);
	if out_ptr = null then do;
		call ioa_$rsnnl ("^/Received a null pointer to segment, ^a>^a",
		     er_mess, 0, out_dir, out_entry_name);
		go to ERROR;
	     end;
						/* Attach an output stream to output segment. */
	out_atd = "vfile_ " || rtrim (out_dir) || ">" || rtrim (out_entry_name);
	call iox_$attach_name ((unique_chars_ (no)), out_iocb_ptr, (out_atd), null, code);
	if code ^= 0 then do;
		call ioa_$rsnnl ("^/Attaching switch to ^a,>^a", er_mess, 0, out_dir, out_entry_name);
		go to ERROR;
	     end;
	call iox_$open (out_iocb_ptr, stream_out, "0"b, code);
	if code ^= 0 then do;
		call ioa_$rsnnl ("^/Opening switch to ^a>^a", er_mess, 0, out_dir, out_entry_name);
		go to ERROR;
	     end;
						/* Output the title block. */
						/*   If creating a table, put legend along side of title block, */
						/*   otherwise below it. */
	if creating_incl then call output_buffer (0, 12);
	else do;
		below_sw = no;
		if legend_len + max_buf_len + 2 > line_len then do;
						/* Put legend below title box. */
			call output_buffer (0, 12);
			below_sw = ON;
			buf = "";
		     end;
						/* Construct the legend. */
		buf (2) = buf (2) || " L_E_G_E_N_D_:";
		buf (3) = buf (3) || copy (" ", 11) || copy ("_", 15) || "/  /_" || copy ("_", 8);
		buf (4) = buf (4) || copy (" ", 11) || "|*" || copy (" ", 9) || "I| /  /  |     |";
		buf (5) = buf (5) || "  relation | Attribute |       |     |";
		i = 0;
		if ^brief_table then do;
			buf (6) = buf (6) || copy (" ", 11) || "| Data Type |       |     |";
			i = 1;
		     end;
		buf (6 + i) = buf (6 + i) || copy (" ", 11) || "_|" || copy ("_", 11) || "_|__/  /___|______|";
		buf (7 + i) = buf (7 + i) || copy (" ", 25) || "/  /";
		buf (8 + i) = buf (8 + i) || copy (" ", 11) || "* = Key Attribute";
		buf (9 + i) = buf (9 + i) || copy (" ", 11) || "I = Index Attribute";
		if below_sw then call output_buffer (0, 9 + i);
		else call output_buffer (0, 12);
	     end;					/* Ends do if generating display table. */
						/* Get all the relation names. */

/* get the relations in this view */

	if ^submodel then do;
		call mrds_dm_get_relations (dm_ptr, dm_area_ptr, mr_ptr, code);
		if mr_ptr = null | code ^= 0 then do;
			call ioa_$rsnnl ("^/Received null pointer from dmd_$get_relations for data model, ^a",
			     er_mess, 0, model_path);
			go to ERROR;
		     end;
	     end;

	else do;					/* for submodels */

		call mrds_dsm_get_relation_names (dm_area_ptr, mrds_dsm_relation_names_ptr, submodel_iocb_ptr, code);
		if mrds_dsm_relation_names_ptr = null () | code ^= 0 then do;
			call ioa_$rsnnl ("^/Unable to get relation names from mrds_dsm_get_relation_names for submodel, ^a",
			     er_mess, 0, model_path);
			goto ERROR;
		     end;
		num_relations_alloc = mrds_dsm_relation_names.nrels;
		allocate model_relations in (dm_area) set (mr_ptr);
		do i = 1 to num_relations_alloc;
		     model_relations.relation_name (i) = mrds_dsm_relation_names.relation (i);
		end;
		free mrds_dsm_relation_names_ptr -> mrds_dsm_relation_names in (dm_area);
	     end;

	if ordering  | have_relation then do;			/* Special ordering has been requested. */
		num_relations_alloc, nrelations = model_relations.nrels;
		norder = order_end - order_begin + 1;
		if model_relations.nrels < norder then do; /* Can't order something that isn't there. */
			code = error_table_$badcall;
			call ioa_$rsnnl ("^/^a model has fewer relations (^d) than order list (^d).",
			     er_mess, 0, model_type, model_relations.nrels, norder);
			go to ERROR;
		     end;
						/* Set up some wroking storage to order the names in. */
		allocate model_relations in (dm_area) set (mr_order_ptr);
		if have_relation then mr_order_ptr -> model_relations.nrels = norder;
						/* Go over the argument list to put the names into the new */
						/*   storage. */
		i = 0;
		do iarg = order_begin to order_end;
		     call cu_$arg_ptr (iarg, arg_ptr, arg_len, 0);
		     i = i + 1;
		     mr_order_ptr -> relation_name (i) = arg;
		end;
		do i = 1 to norder;			/* For each name in the ordered list, find it in */
		     do j = 1 to model_relations.nrels; /*   the data model list and zip it out. */
			if mr_order_ptr -> relation_name (i) = relation_name (j) then do;
				relation_name (j) = "";
				go to NEXT_ORDER;
			     end;
		     end;				/* Ends do for model_relations.nrels loop. */
		     call ioa_$rsnnl ("^/Order list entry, ""^a"", wasn't found in model, ^a.",
			er_mess, 0, mr_order_ptr -> relation_name (i), model_path);
		     code = error_table_$bad_arg;
		     go to ERROR;

NEXT_ORDER:
		end;				/* Ends do for norder loop. */
						/* Now copy those names that weren't zipped out. */
	          if ordering then do;
		     j = norder;
		     do i = 1 to model_relations.nrels;
			if relation_name (i) ^= " " then do;
			     j = j + 1;
			     mr_order_ptr -> relation_name (j) = relation_name (i);
			     end;
			end;				/* Ends do for model_relations.nrels loop. */
	          end;
		free model_relations in (dm_area);	/* All done with original structure. */
		mr_ptr = mr_order_ptr;		/* Setup reference to new sturcture as if it was the old one. */
		mr_order_ptr = null;
	     end;					/* Ends do if ordering. */
						/* Determine length of longest relation name. */

/* go through all relations */

	max_rel_name_len = length (rtrim (relation_name (1)));
	do i = 2 to model_relations.nrels;
	     max_rel_name_len = max (max_rel_name_len, length (rtrim (relation_name (i))));
	end;
	do rltn = 1 to model_relations.nrels while (relation_name(rltn) ^= " ");

	     if ^submodel then ;
	     else do;
		     call mrds_dsm_read_relation ((relation_name (rltn)), dm_area_ptr, str_ptr, submodel_iocb_ptr, code);
		     if code ^= 0 | str_ptr = null () then do;
			     call ioa_$rsnnl ("^/Unable to get attribute information from mrds_dsm_read_relation for submodel, ^a",
				er_mess, 0, model_path);
			     goto ERROR;
			end;

		end;

	     if submodel then
		model_name = str_ptr -> relation_block.dm_rel_name;
	     else model_name = relation_name (rltn);

	     call mrds_dm_get_attributes$set_user_view ();
	     call mrds_dm_get_attributes (dm_ptr, model_name, dm_area_ptr, rd_ptr, code);
	     call mrds_dm_get_attributes$set_db_view ();
	     if rd_ptr = null | code ^= 0 then do;
		     call ioa_$rsnnl ("^/Received a null pointer from dmd_$get_attributes for data model, ^a",
			er_mess, 0, model_path);
		     go to ERROR;
		end;
						/* Convert descriptor to ASCII in standard format. */
	     buf_next_column = max_rel_name_len + 3;
	     right_margin = 5;
	     row = 1;

	     if submodel then do;			/* make a new attr list of only submodel attrs */

		     num_attr_alloc = str_ptr -> relation_block.no_rb_attributes;

		     allocate rel_desc set (new_rd_ptr) in (dm_area);

		     unspec (new_rd_ptr -> rel_desc) = "0"b;
		     new_rd_ptr -> rel_desc.num_attr = num_attr_alloc;

/* change the model attribute names to those of the submodel */

		     do sm_attr_num = 1 to num_attr_alloc;

			found = OFF;
			attr_num = 1;
			do while (^found);

			     if rd_ptr -> rel_desc.attributes (attr_num).attribute_name =
				str_ptr -> relation_block.attribute_info (sm_attr_num).dm_attr_name then do;
				     found = ON;
				     new_rd_ptr -> rel_desc.attributes (sm_attr_num) =
					rd_ptr -> rel_desc.attributes (attr_num);
				     new_rd_ptr -> rel_desc.attributes (sm_attr_num).attribute_name =
					str_ptr -> relation_block.attribute_info (sm_attr_num).dsm_attr_name;
				end;
			     else if attr_num < rd_ptr -> rel_desc.num_attr then
				attr_num = attr_num + 1;
			     else do;
				     found = ON;
				     call ioa_$rsnnl ("^/Unable to find submodel relation ""^a"" in the data model, ^a",
					er_mess, 0, str_ptr -> relation_block.attribute_info (sm_attr_num).dsm_attr_name,
					model_path);
				     goto ERROR;
				end;

			end;

		     end;

		     free rd_ptr -> rel_desc in (dm_area);
		     rd_ptr = new_rd_ptr;
		     new_rd_ptr = null ();

		end;

/* set up column and box length parameters */

	     allocate attr_descriptors in (dm_area);

	     do attr = 1 to num_attr;


		attr_desc (attr) = mu_display_descriptor (addr (descriptor (attr)));
		if creating_incl then do;
			i = index (attr_desc (attr), "leading sign");
			if i = 0 then ;
			else attr_desc (attr) = /* remove part of comment to shorten line */
				substr (attr_desc (attr), 1, i - 1) || substr (attr_desc (attr), i + 13);
		     end;
		else do;
						/* Prescan attributes and determine if this relation will fit */
						/*   on current page.  No output is done here. */
			box_len = length (rtrim (attribute_name (attr)));
			if ^brief_table then do;
				attr_desc (attr) = mu_trim_descriptor (attr_desc (attr));
				box_len = max (length (attr_desc (attr)), box_len);
			     end;
			if j = num_attr then right_margin = 3;
			if box_len + right_margin > line_len + 1 - buf_next_column then do;
						/* Have to go to another row of boxes. */
				buf_next_column = max_rel_name_len + 10;
				row = row + 1;
			     end;
			buf_next_column = buf_next_column + box_len + 3;
		     end;				/* Ends do if creating a table. */
	     end;					/* Ends do for num_attr loop. */
						/* Determine if a new page is required to display current */
						/*   relation. */
	     if creating_incl then
		if num_attr + 2 > lines_left then call new_page ();
		else ;
	     else if brief_table & (row * 4 + 1 > lines_left) | ^brief_table & (row * 5 + 1 > lines_left) then call new_page ();
	     blank_lines = 1;
	     if creating_incl then do;		/* This is all that is needed for an include file. */
		     call ioa_$rsnnl ("dcl 1 ^a aligned^[ based^;^],", buf (1), 0,
			translate (relation_name (rltn), "_", "-"), based_decls);
		     call output_buffer (blank_lines, 1);
		end;
	     else do;				/* Setup begining of line for table display. */
		     buf_next_column = max_rel_name_len + 3;
		     buf (1) = copy (" ", max_rel_name_len + 1) || "_";
		     buf (2), buf (4) = copy (" ", max_rel_name_len + 1) || "|";
		     call ioa_$rsnnl ("^vx^a |", buf (3), 0,
			max_rel_name_len - length (rtrim (relation_name (rltn))), rtrim (relation_name (rltn)));
		     buf (5) = copy (" ", max_rel_name_len + 1) || "_|";
		end;
	     right_margin = 5;

/* go through all attributes */

	     do attr = 1 to num_attr;			/* Do each attribute in turn. */

/* BEGIN CHANGE 81-04-27 ******************************************* */

/* map key heads to indexed, and other key attrs to data only
   for a secured database being viewed by a non-DBA,
   to avoid a security violation possible if the user knows key info */

		if key_flag (attr) & secured_view then do;

			key_flag (attr) = OFF;

			if key_attr_order (attr) = 1 then
			     inver_flag (attr) = ON;

		     end;

/* END CHANGE 81-04-27 *************************************************** */

		if creating_incl then do;		/* No line in incl file will be over 126 chars. */
			call ioa_$rsnnl ("^6x2 ^a ^a^[;^;,^]^[^vx/* ^[Key^]^[, ^]^[Index^] */^]", buf (1), 0,
			     translate (attribute_name (attr), "_", "-"), attr_desc (attr), (attr = num_attr),
			     (key_flag (attr) | inver_flag (attr)),
			     max (2, 98 - length (rtrim (attribute_name (attr))) - length (attr_desc (attr))), key_flag (attr),
			     (key_flag (attr) & inver_flag (attr)), inver_flag (attr));
			call output_buffer (0, 1);
		     end;
		else do;				/* This is what has to be done for each attribute in a */
						/*   table display. */
			box_len = length (rtrim (attribute_name (attr)));
			if ^brief_table then box_len = max (length (attr_desc (attr)), box_len);
						/* Don't have to worry about right hand continuations if this */
						/*   is last attribute. */
			if j = num_attr then right_margin = 3;
			if box_len + right_margin > line_len + 1 - buf_next_column then do;
						/* Box won't fit.  Indicate continuation. */
				buf (1) = buf (1) || "__";
				buf (5) = buf (5) || "__";
				i = 1;
				if brief_table then do;
					i = 0;
					buf (4) = buf (5);
				     end;
						/* Send it out to segment. */
				call output_buffer (blank_lines, 4 + i);
						/* Start next row of boxes. */
				buf (1) = copy (" ", max_rel_name_len + 6) || "___";
				do b = 2 to 4;
				     buf (b) = copy (" ", max_rel_name_len + 8) || "|";
				end;
				buf (5) = copy (" ", max_rel_name_len + 6) || "___|";
				buf_next_column = max_rel_name_len + 10;
			     end;			/* Ends do if overflowed right side of page. */
						/* Construct top of box. */
			buf (1) = buf (1) || copy ("_", box_len + 3);
						/* Indicate if attribute is keyed and/or secondary. */
			call ioa_$rsnnl ("^[*^; ^]^vx^[I^; ^]|", er_mess, 0, key_flag (attr), box_len, inver_flag (attr));
			buf (2) = buf (2) || er_mess;
						/* Now comes the attribute name. */
			call ioa_$rsnnl (" ^va |", er_mess, 0, box_len, attribute_name (attr));
			buf (3) = buf (3) || er_mess;
						/* If wanted, the descriptor info goes in next. */
			if ^brief_table then do;
				call ioa_$rsnnl (" ^va |", er_mess, 0, box_len, attr_desc (attr));
				buf (4) = buf (4) || er_mess;
			     end;
						/* The bottom of the box is last. */
			buf (5) = buf (5) || copy ("_", box_len + 2) || "_|";
			buf_next_column = buf_next_column + box_len + 3;
		     end;				/* Ends do for table generation. */
	     end;					/* Ends do for num_attr loop. */
	     if ^creating_incl then do;		/* Output anything left in output buffer. */
		     i = 1;
		     if brief_table then do;
			     i = 0;
			     buf (4) = buf (5);
			end;
		     call output_buffer (blank_lines, 4 + i);
		end;

	     if submodel then do;
		     free str_ptr -> relation_block in (dm_area);
		     str_ptr = null ();
		end;
	     free rd_ptr -> rel_desc in (dm_area);
	     rd_ptr = null ();
	     free attr_descriptors in (dm_area);	/* All done with descriptor info. */
	     attr_desc_ptr = null;
	end;					/* Ends do for model_relations.nrels loop. */

	if creating_incl then do;			/* Put out a separator bar at end of include segment. */
		er_mess = copy ("*", 76 - length (rtrim (dm_entry_name)));
		call ioa_$ioa_switch (out_iocb_ptr, "^//* END of ^a^4x^a/", out_entry_name, er_mess);
	     end;
						/* Close the output stream. */
	call iox_$close (out_iocb_ptr, code);
	if code ^= 0 then do;
		call ioa_$rsnnl ("^/Tried to close switch to ^a>^a", er_mess, 0, out_dir, out_entry_name);
		go to ERROR;
	     end;
						/* Detach the output switch. */
	call iox_$detach_iocb (out_iocb_ptr, code);
	if code ^= 0 then do;
		call ioa_$rsnnl ("^/Tried to detach switch to ^a>~a", er_mess, 0, out_dir, out_entry_name);
		go to ERROR;
	     end;
						/* Get the bit count so that tssi_ can finish its act up. */
	out_iocb_ptr = null ();

	call hcs_$status_minf (out_dir, out_entry_name, chase, 0, out_len, code);
	if code ^= 0 then do;
		call ioa_$rsnnl ("^/Tried to get length of ^a>^a", er_mess, 0, out_dir, out_entry_name);
		go to ERROR;
	     end;
						/* Now its tssi_'s turn. */
	call tssi_$finish_segment (out_ptr, out_len, (RW_ACCESS), out_acl_ptr, code);
	if code ^= 0 then do;
		call ioa_$rsnnl ("^/Tried to finish segment, ^a>^a", er_mess, 0, out_dir, out_entry_name);
		go to ERROR;
	     end;
	go to CLEANUP;				/* Mission accomplished. */

ERROR:						/* Report all errors here. */
	call com_err_ (code, prog_name, er_mess);
	code = 1;					/* so segment gets deleted */

CLEANUP:
	call clean_up ();
	return;					/* Done no matter what. */

clean_up: proc;					/* Clean up this operation. */

	call mrds_dm_get_attributes$set_db_view ();	/* leave in known state */
	if attr_desc_ptr ^= null then free attr_descriptors in (dm_area);
	if rd_ptr ^= null then free rel_desc in (dm_area);
	if mr_order_ptr ^= null then free mr_order_ptr -> model_relations in (dm_area);
	if mr_ptr ^= null then free model_relations in (dm_area);
	if dmh_ptr ^= null then free dm_header in (dm_area);
	if out_iocb_ptr ^= null then do;
		call iox_$close (out_iocb_ptr, discard_code);
		call iox_$detach_iocb (out_iocb_ptr, discard_code);
	     end;
	if out_acl_ptr ^= null then call tssi_$clean_up_segment (out_acl_ptr);
	if out_ptr ^= null & code ^= 0 then call delete_$ptr (out_ptr, "000111"b, (prog_name), code);
	if dm_ptr ^= null then call mrds_dm_close (dm_ptr, code);
	if submodel then call mrds_dsm_close$force (submodel_iocb_ptr);
	if hd_ptr ^= null () then free hd_ptr -> mrds_dsm_header in (dm_area);
	if str_ptr ^= null () then free str_ptr -> relation_block in (dm_area);
	if new_rd_ptr ^= null () then free new_rd_ptr -> rel_desc in (dm_area);

     end clean_up;

conv_error: proc;

	call ioa_$rsnnl ("^/Conversion error occured in argument, ""^a"", following ^a control argument.",
	     er_mess, 0, arg, control_arg);
	code = error_table_$bad_conversion;
	go to ERROR;

     end conv_error;

new_page: proc;

	call ioa_$ioa_switch_nnl (out_iocb_ptr, "^|");
	lines_left = page_len;

     end new_page;

output_buffer: proc (blank_line_count, buf_line_count);

	dcl     b			 fixed bin;
	dcl     blank_line_count	 fixed bin;
	dcl     buf_line_count	 fixed bin;

	if page_len ^= 0 then do;
		if lines_left < blank_line_count + buf_line_count then call new_page ();
		lines_left = lines_left - blank_line_count - buf_line_count;
	     end;

	do b = 1 to blank_line_count;
	     call ioa_$ioa_switch (out_iocb_ptr, "");
	end;
	blank_line_count = 0;

	do b = 1 to buf_line_count;
	     call ioa_$ioa_switch (out_iocb_ptr, "^a", buf (b));
	end;

     end output_buffer;

	dcl     arg		 char (arg_len) based (arg_ptr);
	dcl     arg_len		 fixed bin;
	dcl     arg_ptr		 pointer;
	dcl     attr		 fixed bin;
	dcl     attr_desc_ptr	 pointer internal static;
	dcl     1 attr_descriptors	 aligned based (attr_desc_ptr),
		2 nattr		 fixed bin,
		2 attr_desc	 (num_attr refer (attr_descriptors.nattr)) char (120) varying;
	dcl     b			 fixed bin;
	dcl     below_sw		 bit (1);
	dcl     blank_lines		 fixed bin;
	dcl     box_len		 fixed bin;
	dcl     brief_table		 bit (1);
	dcl     buf		 (12) char (256) varying;
	dcl     buf_next_column	 fixed bin;
	dcl     chase		 fixed bin (1) init (1) internal static options (constant);
	dcl     clock_		 entry returns (fixed bin (71));
	dcl     copy		 builtin;
	dcl     current_date_time	 char (24);
	dcl     addr		 builtin;
	dcl     cleanup		 condition;
	dcl     code		 fixed bin (35);
	dcl     com_err_		 entry options (variable);
	dcl     control_arg		 char (32);
	dcl     conversion		 condition;
	dcl     convert		 builtin;
	dcl     cu_$arg_count	 entry (fixed bin);
	dcl     cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin, fixed bin (35));
	dcl     date_time_		 entry (fixed bin (71), char (*));
	dcl     dm_abs_path		 char (168);
	dcl     dm_adir		 char (168);
	dcl     dm_aentry_name	 char (32);
	dcl     dm_area		 area based (dm_area_ptr);
	dcl     dm_area_ptr		 pointer internal static init (null);
	dcl     dm_dir		 char (168);
	dcl     dm_entry_name	 char (32);
	dcl     dm_path		 char (168);
	dcl     dm_ptr		 pointer;
	dcl     mrds_dm_close	 entry (ptr, fixed bin (35));
	dcl     mrds_dm_get_attributes entry (ptr, char (32), ptr, ptr, fixed bin (35));
	dcl     mrds_dm_get_header	 entry (ptr, ptr, ptr, fixed bin (35));
	dcl     mrds_dm_get_relations	 entry (ptr, ptr, ptr, fixed bin (35));
	dcl     mrds_dm_open	 entry (char (168), fixed bin, ptr, fixed bin (35));
	dcl     empty		 builtin;
	dcl     er_mess		 char (256) varying;
	dcl     error_table_$bad_arg	 fixed bin (35) external;
	dcl     error_table_$bad_conversion fixed bin (35) external;
	dcl     error_table_$badcall	 fixed bin (35) external;
	dcl     error_table_$badopt	 fixed bin (35) external;
          dcl     error_table_$inconsistent fixed bin (35) external;
	dcl     error_table_$noarg	 fixed bin (35) external;
	dcl     error_table_$wrong_no_of_args fixed bin (35) external;
	dcl     suffixed_name_$new_suffix entry (char (*), char (*), char (*), char (32), fixed bin (35));
	dcl     expand_pathname_	 entry (char (*), char (*), char (*), fixed bin (35));
	dcl     expect		 fixed bin;
	dcl     get_system_free_area_	 entry returns (ptr);
          dcl     have_of                bit (1);
          dcl     have_relation          bit (1);
	dcl     hcs_$get_link_target	 entry (char (*), char (*), char (*), char (*), fixed bin (35));
	dcl     hcs_$status_minf	 entry (char (*), char (*), fixed bin (1), fixed bin (2), fixed bin (24), fixed bin (35));
	dcl     i			 fixed bin;
	dcl     iarg		 fixed bin;
	dcl     creating_incl	 bit (1);
	dcl     based_decls		 bit (1);		/* on => create based declaration */
	dcl     secured_view	 bit (1);		/* on => non-dba on secured db */
	dcl     index		 builtin;
	dcl     ioa_		 entry options (variable);
	dcl     ioa_$ioa_switch	 entry options (variable);
	dcl     ioa_$ioa_switch_nnl	 entry options (variable);
	dcl     ioa_$rsnnl		 entry options (variable);
	dcl     iox_$attach_name	 entry (char (*), ptr, char (*), ptr, fixed bin (35));
	dcl     iox_$close		 entry (ptr, fixed bin (35));
	dcl     iox_$detach_iocb	 entry (ptr, fixed bin (35));
	dcl     iox_$open		 entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
	dcl     j			 fixed bin;
	dcl     legend_len		 fixed bin;
	dcl     length		 builtin;
	dcl     line_len		 fixed bin;
	dcl     lines_left		 fixed bin;
	dcl     ll_arg		 fixed bin init (1) internal static options (constant);
	dcl     max		 builtin;
	dcl     max_buf_len		 fixed bin;
	dcl     max_rel_name_len	 fixed bin;
	dcl     mr_order_ptr	 pointer;
	dcl     mu_display_descriptor	 entry (ptr) returns (char (120) varying);
	dcl     nargs		 fixed bin;
	dcl     no		 bit (1) init ("0"b) internal static options (constant);
	dcl     norder		 fixed bin;
	dcl     nrelations		 fixed bin;
	dcl     null		 builtin;
	dcl     order_arg		 fixed bin init (3) internal static options (constant);
	dcl     order_begin		 fixed bin;
	dcl     order_end		 fixed bin;
	dcl     ordering		 bit (1);
          dcl     output_file_arg        fixed bin init (5) internal static options (constant);
	dcl     out_acl_ptr		 pointer internal static;
	dcl     out_atd		 char (175) varying;
	dcl     out_dir		 char (168);
	dcl     out_entry_name	 char (32);
	dcl     out_iocb_ptr	 pointer init (null ());
	dcl     out_len		 fixed bin (24);
	dcl     out_ptr		 pointer;
	dcl     path_argument	 char (168);	/* holds the input argumenbt corresponding to the db/dsm path */
	dcl     page_len		 fixed bin;
	dcl     pl_arg		 fixed bin init (2) internal static options (constant);
	dcl     prog_name		 char (32) varying;
	dcl     rel_name_arg           fixed bin init (4) internal static options (constant);           
	dcl     retrieval		 fixed bin init (2) internal static options (constant);
	dcl     right_margin	 fixed bin;
	dcl     rltn		 fixed bin;
	dcl     row		 fixed bin;
	dcl     rtrim		 builtin;
	dcl     stream_out		 fixed bin init (2) internal static options (constant);
	dcl     substr		 builtin;
	dcl     suffix		 char (32);
	dcl     tssi_$clean_up_segment entry (ptr);
	dcl     tssi_$finish_segment	 entry (ptr, fixed bin (24), bit (36) aligned, ptr, fixed bin (35));
	dcl     tssi_$get_segment	 entry (char (*), char (*), ptr, ptr, fixed bin (35));
	dcl     time_str		 char (24);
	dcl     translate		 builtin;
	dcl     unique_chars_	 entry (bit (*)) returns (char (15));
	dcl     unspec		 builtin;
	dcl     version		 char (4) varying init ("3.0") internal static options (constant);
	dcl     mu_trim_descriptor	 entry (char (120) varying) returns (char (*)); /* shortens descriptor string
						   using defaults/abbrevs */
	dcl     (mrds_dm_get_attributes$set_user_view, mrds_dm_get_attributes$set_db_view) entry ();
	dcl     db_version		 fixed bin;	/* db_version 1 - 4 of database */
	dcl     mrds_dsl_get_version$get_path_info entry (char (*), ptr, fixed bin, ptr, fixed bin (35)); /* gets path details */
	dcl     local_area		 area (2048);	/* space for path info */
	dcl     hd_ptr		 ptr;		/* points to submodel header */
	dcl     str_ptr		 ptr;		/* points to submodel relation info */
	dcl     submodel		 bit (1);		/* on => submodel pathname given */
	dcl     mrds_dsm_close$force	 entry (ptr);
	dcl     discard_code	 fixed bin (35);	/* unused error code */
	dcl     mrds_dsm_open$read	 entry (char (*), ptr, fixed bin (35));
	dcl     mrds_dsm_read_header	 entry (ptr, ptr, ptr, fixed bin (35));
	dcl     mrds_dsm_get_relation_names entry (ptr, ptr, ptr, fixed bin (35));
	dcl     mrds_dsm_read_relation entry (char (*), ptr, ptr, ptr, fixed bin (35));
	dcl     submodel_iocb_ptr	 ptr init (null ());/* pointer to the submodels iocb */
	dcl     found		 bit (1);		/* on => found model attr in submodel list */
	dcl     sm_attr_num		 fixed bin;	/* index into submodel attr list */
	dcl     model_path		 char (168);	/* name of data model to open */
	dcl     entry_suffix	 char (4) varying;	/* either .dsm or .db */
	dcl     attr_num		 fixed bin;	/* index into model attr list */
	dcl     ON		 bit (1) internal static options (constant) init ("1"b); /* true value */
	dcl     OFF		 bit (1) internal static options (constant) init ("0"b); /* false value */
	dcl     model_type		 char (4);	/* either Data or Sub model */
	dcl     new_rd_ptr		 ptr;		/* to temp copy of rel_desc */
	dcl     model_name		 char (32);	/* name of data model relation */
	dcl     delete_$ptr		 entry (ptr, bit (6), char (*), fixed bin (35)); /* deletes segment from pointer */
	dcl     options		 char (80) varying; /* allowed control arguments */
	dcl     sm_abs_path		 char (168) varying;/* absolute path of submodel with suffix */
	dcl     mrds_dm_db_secured$get_secured_status entry (ptr, ptr, fixed bin, ptr, fixed bin (35)); /* gets security bit */
	dcl     secure_submodel	 bit (1);		/* on => submodel resides in submodel dir */
	dcl     mrds_error_$inc_secure_open fixed bin (35) ext; /* using db path or un-secure submodel when secured */
	dcl     mrds_error_$no_database fixed bin (35) ext static;
	dcl     mrds_error_$no_model_submodel fixed bin (35) ext static;

	dcl     mrds_data_$submodel_dir_name char (16) ext; /* name of sm dir */
	dcl     mrds_dm_secured_submodel entry (char (*), char (*), char (*)) returns (bit (1)); /* returns( true if submodel in sm dir */
	dcl     mrds_dm_authorization$get_user_class entry (char (*), ptr, fixed bin, ptr, fixed bin (35)); /* finds if user a dba */
	dcl     get_wdir_		 entry () returns (char (168));
%page;
%include mrds_authorization;
%page;
%include mrds_database_state;
%page;
%include mrds_dsm_header;
%page;
%include mrds_dsm_rel_block;
%page;
%include mrds_dsm_relation_names;
%page;
%include mrds_dm_header;
%page;
%include mrds_rel_desc;
%page;
%include mrds_model_relations;
%page;
%include mrds_path_info;
%page;
%include access_mode_values;

     end cmdmi;
