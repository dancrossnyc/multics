/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1990   *
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

/* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/****^  HISTORY COMMENTS:
  1) change(86-09-05,JMAthane), approve(86-09-05,MCR7525),
     audit(86-09-11,Martinson), install(86-11-12,MR12.0-1212):
     Added parsing of values like <pointer_value> -> <type_identifier> when
     language is PASCAL.  Fixed bugs in parsing of array values or cross
     sections.
  2) change(88-05-30,WAAnderson), approve(88-09-30,MCR7952),
     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
     Changed 'get_level' so it calls 'get_c_brackets' when the language is
     C instead of 'get_parens'.  'get_c_brackets' is functionally the same
     as 'get_parens' in the sense that they both evaluate subscripts.
  3) change(88-06-01,WAAnderson), approve(88-09-30,MCR7952),
     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
     Changed the code in 'get_c_brackets' to accept s single pair of empty
     brackets. This allows character arrays and pointers to characters to be
     handled as strings. No type checking is done in this procedure.
  4) change(88-06-07,WAAnderson), approve(88-09-30,MCR7952),
     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
     Changed the code in 'parse_normal' to modify a reference node from being
     a pointer to a character to a string value of maxlength 256 when empty
     brackets are used.
  5) change(88-07-19,WAAnderson), approve(88-09-30,MCR7952),
     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
     Added the procedure 'get_unqualified_c_value' to provide the same
     functionality as 'get_unqualified_value' but is specifically
     designed for the C symbol table format.
  6) change(88-07-25,WAAnderson), approve(88-09-30,MCR7952),
     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
     Modified 'parse_normal' and 'get_unqualified_c_value' to handle
     subscripts  within a structure.
  7) change(88-09-07,WAAnderson), approve(88-09-30,MCR7952),
     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
     Added format control comment to make the source more readable.
  8) change(88-10-28,WAAnderson), approve(88-10-28,MCR7952),
     audit(88-10-31,RWaters), install(88-11-11,MR12.2-1210):
     Modified code to compute the complete address of a character pointer
     referenced with subscripts. Prior to this fix, only literal values could
     be used as pointer subscripts.
  9) change(90-09-20,Bubric), approve(90-10-01,MCR8211), audit(90-10-01,Itani),
     install(90-10-17,MR12.4-1044):
     Have the calls to the routine 'nothing' changed to calls to the routine
     'null_entry_'.
                                                   END HISTORY COMMENTS */

probe_get_value_:
  proc ();
  call probe_error_$malfunction ();	/* dummy entry */
  return;

  /* This routine is called to parse and interpret a reference to some data item.
   One argument is used to specify the type of reference allowed at the current point.
   It returns information about the reference in a structure called reference.
   If necessary (i.e. a cross-section reference is found), the array real_subscripts
   is filled in with the bounds (low and high).

   entries:

   $value  - gets a VARIABLE may include function  call
   $reference - a misnomer,  gets a "reference" to  a symbol node - used by "symbol" request only
   Modified JRD 15 Aug 79
   Modified JRD 5 Sep 79 - for true COBOL parsing - a great pain!
   Modified 19 Feb 80 for %probe variables */
  /* Changed to accept first 3 bits of P_switches 08/26/81 S. Herbst */
  /* Changed to understand pathnames & virtual entries 09/11/81 S. Herbst */
  /* Modified June 83 JMAthane to add "a la PASCAL" parsing */
  /* Fixed "segno|offset->var" references (constant qualifier) broken earlier 07/27/83 S. Herbst */
  /* Changed to handle Pascal cross-section by changing the reference's array bounds 08/16/83 S. Herbst */
  /* Added version strings to runtime_symbol_info_ structures 10/06/83 S. Herbst */
  /* Fixed "Qualifier ^p is null." msg to not show qualifier's qualifier 02/09/84 S. Herbst */
  /* Fixed "sb $100" to reference FORTRAN statement label 02/16/84 S. Herbst */
  /* Fixed not to automatically translate "-" to "_" in (COBOL) identifiers 09/20/84 Steve Herbst */
  /* Fixed bug in cross arrays in Pascal,
   Added parsing of <pointer_value> "->" <type_identifier> in parse_a_la_pascal.
   JMAthane June 85 */

  /*
   THIS CODE IS A BOGUS HOAX - here's why

   The concepts it implements are subtlely different from those of PL/I
   (See Chapter Six of AG94)  The kinds of reference one might be interested in are:

   a value - really a pointer to it (useful in expressions)
   a reference - a pointer to some storage (what PL/I means)
   a declaration - for the "symbol" request

   Now there is this crock want_external_sw (position 1 of P_switches)
   If it is ON, this code does not invoke a function.  This means that a reference to an external function
   that returns an entry will  return the first function, not its value.
   PL/I is very explicit on this point.  The value of a reference should depend
   only on its syntax, not on what the caller wants.

*/

  /* The syntax of a reference:
   {} enclose optional material, | separates choices
   {}* indefinite repetition of option

   REF ::= constant { -> VAR} | VAR
   VAR ::= VAR1 { -> VAR }
   VAR1 ::= LEVEL{.LEVEL}* {[generation]} {(ARGLIST)}
   LEVEL ::= NAME {SUBS}
   SUBS ::= (DIM {,DIM}*)
   DIM ::= expression | expression : expression | *

*/

  dcl (
      P_probe_info_ptr	pointer,
      1 P_reference		structure aligned like reference_node,
      P_switches		bit (36) aligned,
      P_code		fixed bin (35)
      )			parameter;

  dcl switches		bit (36);
  dcl need_to_indirect_and_make_string
			bit (1) init ("0"b);


  dcl 1 ref_arg_list	aligned based (P_reference.argument_list)
			like reference_arg_list;
  dcl 1 ref_subscripts	aligned based (P_reference.subscript_ptr)
			like reference_subscripts;
  dcl 1 ref_source_info	aligned based (P_reference.source_info_ptr)
			like source_info;
  dcl 1 sub_refs		aligned
			based (P_reference.subscript_refs_ptr)
			like subscript_reference_ptrs;

  dcl (
      UPPER		init ("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
      LOWER		init ("abcdefghijklmnopqrstuvwxyz")
      )
			char (27) aligned internal static
			options (constant);

  dcl want_value		bit (1) aligned;
				/* tells whether or not to get full address */
  dcl code		fixed bin (35);
  dcl make_lower		bit (1) aligned;

  dcl dummy_entry		entry variable;

  dcl 1 subscript		aligned based like reference_node;
				/* dummy subscript */

  dcl identifier_tokens_name	char (ct -> identifier.length)
			based (ct -> identifier.name);

  dcl id_token		char (id_ptr -> identifier.length)
			based (id_ptr -> identifier.name);

  dcl cv_entry_		entry (char (*), ptr, fixed bin (35))
			returns (entry);

  dcl probe_check_ptr_$indirectable
			entry (ptr, fixed bin (35));
  dcl probe_error_$record	entry options (variable);
  dcl probe_error_$malfunction
			entry options (variable);
  dcl probe_eval_$evaluate	entry (ptr, 1 aligned like reference_node,
			bit (36) aligned, bit (1) aligned,
			fixed bin (35));
  dcl probe_eval_$add_c_dims	entry (ptr, 1 aligned like reference_node,
			bit (36) aligned, bit (1) aligned,
			fixed bin (35), fixed bin (6) unsigned);
  dcl probe_create_reference_ entry (ptr, ptr);
  dcl probe_get_$expression	entry (pointer, 1 aligned like reference_node,
			fixed bin (35));
  dcl probe_get_$generation	entry (pointer, pointer, fixed bin,
			fixed bin (35));

  dcl (
      probe_et_$bad_locator,
      probe_et_$bad_operator,
      probe_et_$bad_pointer,
      probe_et_$dim_limit,
      probe_et_$null_ptr,
      probe_et_$recorded_message,
      probe_et_$too_long
      )			fixed bin (35) external static;

  dcl error_table_$badpath	fixed bin (35) external static;

  dcl (addr, addrel, bin, binary, convert, divide, fixed, hbound, index)
			builtin;
  dcl (length, maxlength, null, substr, translate, unspec, verify)
			builtin;
  dcl id_ptr		ptr;
%page;
probe_get_value_$value:
  entry (P_probe_info_ptr, P_reference, P_switches, P_code);

  want_value = "1"b;
  switches = P_switches;
  need_to_indirect_and_make_string = "0"b;

  goto start;


probe_get_value_$reference:
  entry (P_probe_info_ptr, P_reference, P_code);

  want_value = "0"b;
  unspec (switches) = "0"b;
  goto start;

start:

  probe_info_ptr = P_probe_info_ptr;
  code = 0;

  P_reference.name = "";		/* initialize the variables */
  P_reference.flags = "0"b;
  P_reference.precision = 0;
  P_reference.symbol_ptr = null;
  P_reference.address_ptr = null;
  P_reference.type_ptr = null;
  P_reference.base_addr = null ();
  P_reference.have_generation = "0"b;
  P_reference.invocation_level = 0;
  P_reference.type = 0;
  P_reference.optional_info.n_subscripts = 0;
  P_reference.optional_info.n_arguments = 0;

  ref_arg_list.number = 0;
  ref_subscripts.number = 0;
  ref_source_info.block_ptr, ref_source_info.stack_ptr,
       ref_source_info.entry_ptr = null;


  if probe_info.language_type = COBOL_lang_type
       | probe_info.language_type = PASCAL_lang_type
    then make_lower = "1"b;
  else if probe_info.language_type = FORTRAN_lang_type
    then make_lower =
	    current_source.seg_info_ptr -> seg_info.bits.ignore_case;
  else make_lower = "0"b;

  if probe_info.ct -> token.type = GREATER_THAN
       | probe_info.ct -> token.type = LESS_THAN
    then
         call get_pathname ();
  else if looks_like_cobol ()
    then call parse_ala_cobol;
  else if probe_info.language_type = PASCAL_lang_type
    then
         call parse_ala_pascal;
  else call parse_normal;

SOME_ERROR:
  P_code = code;
  return;


RECORDED_MESSAGE:
  code = probe_et_$recorded_message;
  goto SOME_ERROR;


disgruntled:
  proc (ecode);
  dcl ecode		fixed bin (35) parameter;

  code = ecode;
  goto SOME_ERROR;
  end disgruntled;
%page;
parse_normal:
  proc;				/* parse a REF */

  dcl based_ptr		pointer based;
  dcl based_packed_ptr	pointer unal based;

  dcl stu_$offset_to_pointer	entry (pointer, pointer, pointer, pointer,
			pointer, pointer) returns (pointer);
  dcl probe_check_ptr_$check	entry (ptr, fixed bin (35));
  dcl 01 acc_str		based,
       02 str_len		fixed bin (9) unsigned unaligned,
       02 str_name		char (0 refer (acc_str.str_len)) unaligned;
  dcl name_ptr		ptr;
  dcl (tsp, old_addr, final_ptr)
			ptr;
  dcl offset_bits		fixed bin (6) unsigned;
  dcl offset_words		fixed bin (18) unsigned;
  dcl mod			builtin;
  dcl original_class	fixed bin (6) unsigned;

  original_class = 0;

  if probe_info.ct -> token.type = CONSTANT_TYPE then do;
      P_reference.constant = "1"b;
      P_reference.constant_token_ptr = probe_info.ct;
      P_reference.name = "<<constant>>";/* should be smart and get name ! */
      call bump_ct ();
    end;
  else if current_token.type = NAME_TYPE &
       probe_info.language_type = C_lang_type
    then
         call get_unqualified_c_reference ();
  else if current_token.type = NAME_TYPE
    then
         call get_unqualified_reference ();
  else do;			/* some operator */
    call probe_error_$record (probe_info_ptr, probe_et_$bad_operator,
         OPERATOR_VALUES (binary (substr (current_token.type, 13, 6), 17)));
    goto RECORDED_MESSAGE;
  end;

  old_addr = null ();
  do while (probe_info.ct -> token.type = ARROW &
       probe_info.language_type = C_lang_type);

    if (P_reference.address_ptr = null ())
      then
	 call probe_eval_$evaluate (probe_info_ptr, P_reference, (switches),
	      want_value,
	      code);

    if P_reference.type ^= pointer_dtype then do;
        call probe_error_$record (probe_info_ptr, 0,
	   "The -> symbol may be used only in conjuction with pointers to structures."
	   );
        goto RECORDED_MESSAGE;
      end;
    if (P_reference.symbol_ptr ^= null ()) then do;
        tsp = P_reference.symbol_ptr;
        do while ((fixed (tsp -> runtime_symbol.type) = pointer_dtype |
	   fixed (tsp -> runtime_symbol.type) = c_typeref_dtype)
	   & /* typeref */
	   tsp -> runtime_symbol.son ^= "000000"b3);
	tsp = addrel (tsp, fixed (tsp -> runtime_symbol.son));
        end;
        P_reference.symbol_ptr = null ();
        P_reference.type = 0;
        old_addr = P_reference.address_ptr;
        P_reference.address_ptr = null ();
        P_reference.type_ptr = null ();
        P_reference.base_addr = null ();
        name_ptr = addrel (tsp, fixed (tsp -> runtime_symbol.name));
        P_reference.name =
	   substr (name_ptr -> acc_str.str_name, 1,
	   name_ptr -> acc_str.str_len) || ".";
      end;

    call bump_ct ();

    if probe_info.ct -> token.type = NAME_TYPE
      then do;
        call get_unqualified_c_reference ();
        call probe_eval_$evaluate (probe_info_ptr, P_reference, (switches),
	   want_value,
	   code);

        final_ptr = old_addr -> based_ptr;
        if (P_reference.symbol_ptr ^= null ()) then do;
	  if (^P_reference.symbol_ptr -> runtime_symbol.bits.simple &
	       P_reference.symbol_ptr -> runtime_symbol.offset ^= 0)
	    then do;
	      offset_bits =
		 convert (offset_bits,
		 P_reference.symbol_ptr -> runtime_symbol.offset);
	      offset_words =
		 convert (offset_words, divide (offset_bits, 36, 17, 0));
	      offset_bits = convert (offset_bits, mod (offset_bits, 36));
	      addr (final_ptr) -> its_unsigned.offset =
		 addr (final_ptr) -> its_unsigned.offset + offset_words;
	      addr (final_ptr) -> its_unsigned.bit_offset =
		 addr (final_ptr) -> its_unsigned.bit_offset
		 + offset_bits;
	    end;
	end;
        dcl null_entry_		      entry options (variable);
        call null_entry_ ();

        P_reference.address_ptr = final_ptr;

        if (P_reference.n_subscripts > 0)
	then
	     call probe_eval_$add_c_dims (probe_info_ptr, P_reference,
		(switches), "1"b, code, original_class);

      end;
  end;

  if (old_addr ^= null ()) then do;
      code = 0;
      goto SOME_ERROR;
    end;

  do while (probe_info.ct -> token.type = ARROW &
       probe_info.language_type ^= C_lang_type);

    call probe_eval_$evaluate (probe_info_ptr, P_reference, (switches),
         want_value,
         code);

    if P_reference.constant then do;
        if P_reference.type ^= pointer_dtype
	then call disgruntled (probe_et_$bad_pointer);
        P_reference.base_addr = P_reference.address_ptr -> based_ptr;
      end;			/* constant */
      else do;
        if probe_info.execute then do;	/* we have valid data */
	  if P_reference.type = pointer_dtype
	    then if P_reference.packed
		 then P_reference.base_addr =
			 P_reference.address_ptr -> based_packed_ptr;
		 else P_reference.base_addr =
			 P_reference.address_ptr -> based_ptr;
	  else if P_reference.type = offset_dtype
	    then P_reference.base_addr = stu_$offset_to_pointer (
		    ref_source_info.block_ptr, P_reference.symbol_ptr,
		    P_reference.address_ptr, ref_source_info.stack_ptr,
		    (ref_source_info.seg_info_ptr -> seg_info.linkage_ptr)
		    , null);
	  else do;		/* other data type no good */
	    call probe_error_$record (probe_info_ptr, probe_et_$bad_locator,
	         P_reference.name);
	    goto RECORDED_MESSAGE;
	  end;
	end;			/* execute case */
	else P_reference.base_addr = null ();
				/* just syntax-checking */
      end;			/* variable case */

    if probe_info.flags.execute then do;
        call probe_check_ptr_$check (P_reference.base_addr, code);
        if code ^= 0
	then goto SOME_ERROR;

        call probe_check_ptr_$indirectable (P_reference.base_addr, code);
        if code ^= 0 then do;
	  if P_reference.constant
	    then call probe_error_$record
		    (probe_info_ptr, code, "Qualifier ^p",
		    P_reference.base_addr);
	  else if code = probe_et_$null_ptr
	    then call probe_error_$record (probe_info_ptr, 0,
		    "Qualifier ^a is null.",
		    qualifier_name (P_reference.symbol_ptr));
	  else call probe_error_$record (probe_info_ptr, code,
		  "Qualifier ^a = ^w ^w",
		  qualifier_name (P_reference.symbol_ptr),
		  substr (unspec (P_reference.base_addr), 1, 36),
		  substr (unspec (P_reference.base_addr), 37, 36));
	  go to RECORDED_MESSAGE;
	end;
      end;

    /* these could be dangerous */

    P_reference.flags = "0"b;
    P_reference.n_subscripts, P_reference.n_arguments = 0;
    P_reference.address_ptr = null ();
    P_reference.name = "";

    call bump_ct ();

    /* Now, what are we pointing to */

    if current_token.type = NAME_TYPE
      then call get_unqualified_reference ();
    else if current_token.type = CONSTANT_TYPE then do;
        call probe_error_$record (probe_info_ptr, 0,
	   "A constant cannot be based.");
        goto RECORDED_MESSAGE;
      end;
    else do;
      call probe_error_$record (probe_info_ptr, 0, "Bad syntax ""-> ^a"".",
	 OPERATOR_VALUES (binary (substr (current_token.type, 13, 6), 17)));
      goto RECORDED_MESSAGE;
    end;

  end;				/* do while loop */

  if index (P_reference.name, "$") = 1
       & probe_info.language_type = FORTRAN_lang_type &
       verify (substr (P_reference.name, 2), "0123456789 ") = 0
    then
         P_reference.name = substr (P_reference.name, 2);
  if (probe_info.language_type ^= C_lang_type
       | P_reference.address_ptr = null ())
    then
         call probe_eval_$evaluate (probe_info_ptr, P_reference, (switches),
	    want_value, code);

  /* The empty brackets mean indirection. The symbol must be a char pointer 
    though. */
  if (need_to_indirect_and_make_string) then do;
      if (P_reference.symbol_ptr = null ()) then do;
	call probe_error_$record (probe_info_ptr, 0,
	     "Could not locate the symbol ^a", P_reference.name);
	goto RECORDED_MESSAGE;
        end;
      if (P_reference.symbol_ptr -> runtime_symbol.son ^= "000000"b3 &
	 P_reference.type = pointer_dtype)
        then do;
	do while (fixed (P_reference.symbol_ptr -> runtime_symbol.type)
	     = pointer_dtype |
	     fixed (P_reference.symbol_ptr -> runtime_symbol.type)
	     = c_typeref_dtype);
	  P_reference.symbol_ptr =
	       addrel (P_reference.symbol_ptr,
	       fixed (P_reference.symbol_ptr -> runtime_symbol.son));
	end;
	if (fixed (P_reference.symbol_ptr -> runtime_symbol.type)
	     = char_dtype) then do;
	    P_reference.symbol_ptr = null ();
	    P_reference.address_ptr = P_reference.address_ptr -> based_ptr;
	    P_reference.type = char_dtype;
	    P_reference.precision = 256;
	    P_reference.flags.packed = "1"b;
	    P_reference.flags.constant = "1"b;
	    P_reference.flags.c_ptr_to_char = "1"b;
	  end;
	  else do;
	    call probe_error_$record (probe_info_ptr, 0,
	         "The empty subscript is only valid for character array references^/using pointer values through one level of indirection."
	         );
	    goto RECORDED_MESSAGE;
	  end;
        end;
      else if (P_reference.type = char_dtype
	 & fixed (P_reference.symbol_ptr -> runtime_symbol.ndims) > 0)
        then do;
	P_reference.symbol_ptr = null ();
	P_reference.precision = 256;
	P_reference.flags.packed = "1"b;
	P_reference.flags.constant = "1"b;
        end;
      else do;
        call probe_error_$record (probe_info_ptr, 0,
	   "The empty subscript is only valid for character array references^/using pointer values through one level of indirection."
	   );
        goto RECORDED_MESSAGE;
      end;
      need_to_indirect_and_make_string = "0"b;
    end;

  return;

get_unqualified_c_reference:
  proc ();

  dcl temp_created		bit (1);
  dcl (t_ref, s_ptr)	ptr;
  dcl name_ptr_2		ptr;
  dcl old_addr		ptr;
  dcl offset_bits		fixed bin (6) unsigned;
  dcl offset_words		fixed bin (18) unsigned;

  call get_level ();

  temp_created = "0"b;
  old_addr = null ();

  do while (probe_info.ct -> token.type = PERIOD);

    if ^temp_created then do;
        call probe_create_reference_ (probe_info_ptr, t_ref);
        t_ref -> reference_node.optional_info.subscript_ptr =
	   P_reference.optional_info.subscript_ptr;
        t_ref -> reference_node.optional_info.argument_list =
	   P_reference.optional_info.argument_list;
        t_ref -> reference_node.optional_info.n_subscripts =
	   P_reference.optional_info.n_subscripts;
        t_ref -> reference_node.optional_info.n_arguments =
	   P_reference.optional_info.n_arguments;
        t_ref -> reference_node.subscript_refs_ptr =
	   P_reference.subscript_refs_ptr;
        temp_created = "1"b;
      end;

    t_ref -> reference_node.name = id_token;

    call probe_eval_$evaluate (probe_info_ptr, t_ref -> reference_node,
         (switches), want_value, code);

    if original_class = 0 & t_ref -> reference_node.symbol_ptr ^= null ()
      then
	 original_class =
	      convert (original_class,
	      t_ref -> reference_node.symbol_ptr
	      -> runtime_symbol.address.class);

    code = 0;

    if (old_addr = null ())
      then do;
        old_addr = t_ref -> reference_node.address_ptr;
        P_reference.address_ptr = old_addr;
      end;

    s_ptr = t_ref -> reference_node.symbol_ptr;

    if (s_ptr ^= null ()) then do;
        if fixed (s_ptr -> runtime_symbol.type) = c_typeref_dtype then do;
				/* typeref */
	  do while (fixed (s_ptr -> runtime_symbol.type) = c_typeref_dtype);
	    s_ptr = addrel (s_ptr, fixed (s_ptr -> runtime_symbol.son));
	  end;
	  P_reference.name =
	       substr (P_reference.name, 1,
	       length (P_reference.name) - length (id_token));
	  name_ptr_2 = addrel (s_ptr, fixed (s_ptr -> runtime_symbol.name));
	  P_reference.name =
	       substr (name_ptr_2 -> acc_str.str_name, 1,
	       name_ptr_2 -> acc_str.str_len);
	end;
      end;

    P_reference.name = P_reference.name || ".";
    call bump_ct ();
    if probe_info.ct -> token.type ^= NAME_TYPE then do;
        call probe_error_$record (probe_info_ptr, 0,
	   "A name must follow a ""."" in a structure qualified reference");
        goto RECORDED_MESSAGE;
      end;

    P_reference.optional_info.n_subscripts = 0;
    P_reference.optional_info.n_arguments = 0;

    call get_level ();

    call probe_eval_$evaluate (probe_info_ptr, P_reference, (switches),
         want_value, code);

    code = 0;

    s_ptr = P_reference.symbol_ptr;

    if s_ptr = null () then do;
        call probe_error_$record (probe_info_ptr, 0,
	   "Could not locate the symbol.");
        goto RECORDED_MESSAGE;
      end;
    if (^s_ptr -> runtime_symbol.bits.simple &
         s_ptr -> runtime_symbol.offset ^= 0) then do;
        offset_bits = convert (offset_bits, s_ptr -> runtime_symbol.offset);

        offset_words =
	   convert (offset_words, divide (offset_bits, 36, 17, 0));
        offset_bits = convert (offset_bits, mod (offset_bits, 36));
        addr (old_addr) -> its_unsigned.offset =
	   addr (old_addr) -> its_unsigned.offset + offset_words;
        addr (old_addr) -> its_unsigned.bit_offset =
	   addr (old_addr) -> its_unsigned.bit_offset + offset_bits;
      end;

    P_reference.address_ptr = old_addr;

    if (P_reference.n_subscripts > 0)
      then
	 call probe_eval_$add_c_dims (probe_info_ptr, P_reference,
	      (switches), "1"b, code, original_class);
  end;

  /* we are end of structure ref or simple ref */

  if probe_info.ct -> token.type = LEFT_BRACKET then do;
      call bump_ct ();

      call probe_get_$generation (probe_info_ptr, P_reference.source_info_ptr,
	 P_reference.invocation_level, code);
      if code ^= 0
        then goto SOME_ERROR;

      if probe_info.ct -> operator.type ^= RIGHT_BRACKET
        then do;
	call probe_error_$record (probe_info_ptr, 0,
	     "Syntax error in generation of ^a", P_reference.name);
	goto RECORDED_MESSAGE;
        end;

      P_reference.have_generation = "1"b;
      call bump_ct ();		/* past the ] */

    end;

  /* an arglist would go here */

  end get_unqualified_c_reference;

get_unqualified_reference:
  proc ();

  call get_level ();

  do while (probe_info.ct -> token.type = PERIOD);
    P_reference.name = P_reference.name || ".";
    call bump_ct ();
    if probe_info.ct -> token.type ^= NAME_TYPE then do;
        call probe_error_$record (probe_info_ptr, 0,
	   "A name must follow a ""."" in a structure qualified reference");
        goto RECORDED_MESSAGE;
      end;
    call get_level ();
  end;

  /* we are end of structure ref or simple ref */

  if probe_info.ct -> token.type = LEFT_BRACKET then do;
      call bump_ct ();

      call probe_get_$generation (probe_info_ptr, P_reference.source_info_ptr,
	 P_reference.invocation_level, code);
      if code ^= 0
        then goto SOME_ERROR;

      if probe_info.ct -> operator.type ^= RIGHT_BRACKET
        then do;
	call probe_error_$record (probe_info_ptr, 0,
	     "Syntax error in generation of ^a", P_reference.name);
	goto RECORDED_MESSAGE;
        end;

      P_reference.have_generation = "1"b;
      call bump_ct ();		/* past the ] */

    end;

  /* an arglist would go here */

  if make_lower
    then P_reference.name = translate (P_reference.name, LOWER, UPPER);
  end get_unqualified_reference;


get_level:
  proc ();

  id_ptr = probe_info.ct;

  if length (P_reference.name) + length (identifier_tokens_name)
       > maxlength (P_reference.name)
    then call disgruntled (probe_et_$too_long);

  P_reference.name = P_reference.name || identifier_tokens_name;
  call bump_ct ();

  if probe_info.ct -> token.type = LEFT_PAREN
    then call get_parens;
  else if (probe_info.ct -> token.type = LEFT_BRACKET &
       probe_info.language_type = C_lang_type)
    then
         call get_c_brackets ();

  end get_level;

  end parse_normal;
%page;
qualifier_name:
  proc (P_ptr) returns (char (256) varying);

  dcl (P_ptr, p)		ptr;
  dcl name		char (256) varying;


  p = P_ptr;
  name = addrel (p, p -> runtime_symbol.name) -> acc.string;
  do while (fixed (p -> runtime_symbol.level, 6) > 1);
				/* print fathers */
    p = addrel (p, p -> runtime_symbol.father);
    name = addrel (p, p -> runtime_symbol.name) -> acc.string || "." || name;
  end;
  return (name);

  end qualifier_name;
%page;
parse_ala_cobol:
  proc;


  P_reference.name = identifier_tokens_name;
  call bump_ct ();			/* past the name */
  do while (cobol_connector ((probe_info.ct)));
    call bump_ct ();
    if probe_info.ct -> token.type ^= NAME_TYPE then do;
        call probe_error_$record (probe_info_ptr, 0,
	   "Syntax error - a name is needed after ""of"" or ""in""");
        goto RECORDED_MESSAGE;
      end;

    if length (P_reference.name) + length (".")
         + length (identifier_tokens_name) >
         maxlength (P_reference.name)
      then call disgruntled (probe_et_$too_long);

    P_reference.name = "." || P_reference.name;
    P_reference.name = identifier_tokens_name || P_reference.name;

    call bump_ct ();		/* past the name */

  end;				/* do-while comma loop */

  P_reference.name = translate (P_reference.name, LOWER, UPPER);

  if probe_info.ct -> token.type = LEFT_PAREN then do;
      call bump_ct ();		/* past the ( */
      call get_dim ();		/* first subscript */
      do while (probe_info.ct -> token.type = COMMA);
        call bump_ct ();
        call get_dim ();
      end;

      if probe_info.ct -> token.type ^= RIGHT_PAREN then do;
	call probe_error_$record (probe_info_ptr, 0,
	     "Syntax error in subscript list");
	goto RECORDED_MESSAGE;
        end;
      call bump_ct ();
    end;				/* subscript hacking */
  call probe_eval_$evaluate (probe_info_ptr, P_reference, (switches),
       want_value, code);
  end parse_ala_cobol;
%page;
parse_ala_pascal:
  proc;				/* parse a PASCAL REF */

  /* This procedure parses reference to a PASCAL variable and to a PASCAL constant set.
   It works as the compiler works: If the reference is composed of more than
   one symbol, it looks for the first name in the symbol table (done in probe_eval_)
   and after, uses the attributes of this symbol to analyse the following symbols.
   No abbreviation (as in PL/1, where reference to a field of a record may
   be sufficient) is allowed: "v a" trying to get the value of "b.a"
   will return "symbol a not declared" ("not found" would be better..).
   excepted if we are in a "with b" block..

*/
  dcl based_ptr		pointer based;
  dcl based_packed_ptr	pointer unal based;

  dcl size		builtin;
  dcl (first_ref, next_ref,
      first_type_ptr, next_type_ptr)
			ptr;
  dcl (first_type, next_type,
      first_value, next_value)
			fixed bin (35);
  dcl field_ptr		ptr;
  dcl got_args		bit (1) init ("0"b);
  dcl (Block_ptr,
      Base_addr,
      Linkage_ptr,
      Stack_ptr)		ptr;
  dcl 1 type_info		like runtime_type_info;
  dcl (low, mult, new_high, new_low)
			fixed bin (35);
  dcl probe_pascal_$real_type entry (fixed bin (35), ptr, fixed bin (35), ptr)
			;
  dcl stu_$find_runtime_symbol
			entry (ptr, char (*) aligned, ptr, fixed bin)
			returns (ptr);
  dcl probe_pascal_$indice_id entry (fixed bin (35), ptr, fixed bin (35))
			returns (char (32) varying);
  dcl probe_pascal_$indice_value
			entry (ptr, ptr, fixed bin (35), fixed bin (35),
			ptr, fixed bin (35));
  dcl probe_invoke_$function	entry (ptr, 1 aligned like reference_node,
			1 aligned like reference_node);
  dcl subp		ptr;
  dcl found_ptr		ptr;
  dcl steps		fixed bin;
  dcl new_name		char (32) varying;
  dcl element_name		char (256) varying;
  dcl i			fixed bin;
  dcl bit_offset		fixed bin (35);
  dcl current_indice	fixed bin;
  dcl array_type_ptr	ptr;
  dcl 1 p			based,
       2 p1		bit (30) unal,
       2 ftag		bit (6) unal,
       2 p2		bit (36) unal;


  type_info.version = RUNTIME_TYPE_INFO_VERSION_1;
  if probe_info.ct -> token.type = CONSTANT_TYPE then do;
      P_reference.constant = "1"b;
      P_reference.constant_token_ptr = probe_info.ct;
      P_reference.name = "<<constant>>";/* should be smart and get name ! */
      call bump_ct ();
      call probe_eval_$evaluate (probe_info_ptr, P_reference, (switches),
	 want_value, code);
      if current_token.type = ARROW
        then
	   if P_reference.type = pointer_dtype
	     then
		if probe_info.execute
		  then go to arrow_found_execute;
		  else go to arrow_found_check;
      goto SOME_ERROR;
    end;

  if ^probe_info.execute then do;	/* just probe syntax checking */
      if current_token.type = NAME_TYPE then do;
				/* PASCAL identifier */
	P_reference.name = identifier_tokens_name;
	call bump_ct ();
	if current_token.type = LEFT_PAREN then do;
	    call get_parens;
	    got_args = "1"b;
	  end;
	call probe_eval_$evaluate (probe_info_ptr, P_reference, (switches),
	     want_value, code);
	if code ^= 0
	  then go to SOME_ERROR;
continue_to_check:
	if ^got_args then do;
	    if current_token.type = LEFT_PAREN then do;
	        call get_parens;
	        got_args = "1"b;
	      end;
	  end;
	if got_args
	  then go to end_of_parsing;
	;			/* no more after parens */
	if current_token.type = LEFT_BRACKET then do;
next_indice:
	    call probe_pascal_$indice_value (probe_info_ptr, next_ref,
	         next_value, next_type,
	         next_type_ptr, code);
	    if code ^= 0
	      then go to SOME_ERROR;
	    if current_token.type = COMMA then do;
	        call bump_ct ();
	        go to next_indice;
	      end;
	    if current_token.type ^= LEFT_BRACKET then do;
	        call probe_error_$record (probe_info_ptr, 0,
		   "Syntax error in array indices : Comma or left bracket expected."
		   );
	        go to RECORDED_MESSAGE;
	      end;
	    call bump_ct ();
	    go to continue_to_check;
	  end;
	if (current_token.type = PASCAL_ARROW) |
	     (current_token.type = ARROW) then do;
arrow_found_check:
	    call bump_ct ();
	    go to continue_to_check;
	  end;
	if current_token.type = PERIOD then do;
	    call bump_ct ();
	    if current_token.type ^= NAME_TYPE then do;
	        call probe_error_$record (probe_info_ptr, 0,
		   "Syntax error : Field name expected after period.");
	        go to RECORDED_MESSAGE;
	      end;
	    call bump_ct ();
	    go to continue_to_check;
	  end;
        end;
      else if current_token.type = LEFT_BRACKET then do;
				/* set */
next_elem:
	call probe_pascal_$indice_value (probe_info_ptr, next_ref,
	     next_value, next_type,
	     next_type_ptr, code);
	if code ^= 0
	  then go to SOME_ERROR;
	if current_token.type = COMMA then do;
	    call bump_ct ();
	    go to next_elem;
	  end;
	if current_token.type ^= LEFT_BRACKET then do;
	    call probe_error_$record (probe_info_ptr, 0,
	         "Syntax error in set value : Comma or left bracket expected."
	         );
	    go to RECORDED_MESSAGE;
	  end;
	call bump_ct ();
        end;
    end;

  else if current_token.type = NAME_TYPE then do;
      P_reference.name = identifier_tokens_name;
      call bump_ct ();

      if current_token.type = LEFT_PAREN then do;
	call get_parens;
	got_args = "1"b;
        end;

      call probe_eval_$evaluate (probe_info_ptr, P_reference, (switches),
	 want_value, code);
      if code ^= 0
        then go to SOME_ERROR;
      if P_reference.builtin | P_reference.function then do;
	got_args = "0"b;
	P_reference.n_subscripts = 0;
        end;

      Block_ptr = P_reference.source_info_ptr -> source_info.block_ptr;
      Stack_ptr = P_reference.source_info_ptr -> source_info.stack_ptr;
      Linkage_ptr =
	 P_reference.source_info_ptr -> source_info.seg_info_ptr
	 -> seg_info.linkage_ptr;
      Base_addr = P_reference.base_addr;

continue_to_parse:
      if ^got_args then do;
	if current_token.type = LEFT_PAREN then do;
	    call get_parens;
	    got_args = "1"b;
	  end;
        end;
      if got_args
        then
	   if P_reference.type_ptr ^= null then do;

	       type_info.version = RUNTIME_TYPE_INFO_VERSION_1;

	       call runtime_symbol_info_$type (P_reference.type_ptr,
		  addr (type_info), code);
	       if code ^= 0
	         then go to SOME_ERROR;

	       if type_info.type ^= pascal_procedure_type_dtype
	         then go to not_a_proc;
	       if type_info.base_type ^= 0 then do;
				/* function */
		 if want_value then do;
				/* evaluate it */
		     call probe_invoke_$function (probe_info_ptr,
			P_reference, P_reference);
		   end;
		 P_reference.symbol_ptr = null;
		 P_reference.type = type_info.base_type;
		 P_reference.type_ptr = type_info.base_type_addr;
		 P_reference.precision = type_info.size;
	         end;
	       got_args = "0"b;
	     end;
	     else do;
not_a_proc:
	       call probe_error_$record (probe_info_ptr, 0,
		  "^a is not a procedure.", P_reference.name);
	       go to RECORDED_MESSAGE;
	     end;
      if current_token.type = LEFT_BRACKET then do;
				/* array indices */
	call bump_ct ();
	if P_reference.type_ptr ^= null then do;
	    if P_reference.type_ptr -> pascal_symbol_node_header.array_info
	      then do;
	        n_dims =
		   runtime_symbol_info_$array_dims (P_reference.type_ptr);
	        P_reference.packed =
		   P_reference.type_ptr
		   -> pascal_symbol_node_header.packed;
	        bit_offset = 0;
	        element_name = P_reference.name;
	        P_reference.cross_section =
		   is_cross_section ((probe_info.ct));
	        if P_reference.cross_section
		then P_reference.n_subscripts,
			P_reference.n_arguments, ref_subscripts.number =
			0;
	        do;
		dcl 1 array_info	        like runtime_array_info;
		array_info.version = RUNTIME_ARRAY_INFO_VERSION_1;
		array_type_ptr = P_reference.type_ptr;
		current_indice = 0;
continue_subarray:
		if P_reference.cross_section
		  then P_reference.n_subscripts,
			  P_reference.n_arguments,
			  ref_subscripts.number =
			  ref_subscripts.number + n_dims;
		call runtime_symbol_info_$array (array_type_ptr,
		     addr (array_info), code);
		if code ^= 0
		  then go to SOME_ERROR;
		do i = 1 to n_dims;
		  if P_reference.cross_section then do;
		      call probe_create_reference_ (probe_info_ptr, subp);
		      sub_refs.ptr (1, i + current_indice) = subp;
		      if current_token.type = TIMES then do;
				/* star extent */
			subp -> subscript.flags.star_extent = "1"b;
			subp -> subscript.name =
			     "<<star extent low bound>>";
			call probe_create_reference_ (probe_info_ptr,
			     subp);
			sub_refs.ptr (2, i + current_indice) = subp;
			subp -> subscript.flags.star_extent = "1"b;
			subp -> subscript.name =
			     "<<star extent high bound>>";
			ref_subscripts.value (1, i + current_indice) =
			     decode (array_info.bounds (i).lower,
			     array_info.bounds (i).lower_is_encoded,
			     P_reference.type_ptr);
			ref_subscripts.value (2, i + current_indice) =
			     decode (array_info.bounds (i).upper,
			     array_info.bounds (i).upper_is_encoded,
			     P_reference.type_ptr);
			call bump_ct ();
			go to next_dim;
		        end;
		    end;
		  call get_indice_value ();
		  if P_reference.cross_section then do;
		      subp -> reference_node = next_ref -> reference_node;
		      new_low = next_value;
		      if current_token.type = COLON then do;
			call bump_ct ();
			call get_indice_value ();
			call probe_create_reference_ (probe_info_ptr,
			     subp);
			sub_refs.ptr (2, i + current_indice) = subp;
			subp -> reference_node =
			     next_ref -> reference_node;
			new_high = next_value;
			if new_high < new_low then do;
			    call probe_error_$record (probe_info_ptr, 0,
			         "Invalid range specification ^a..^a",
			         probe_pascal_$indice_id (array_info (i)
			         .subscript_type,
			         array_info (i).subscript_type_addr,
			         new_low),
			         probe_pascal_$indice_id (array_info (i)
			         .subscript_type,
			         array_info (i).subscript_type_addr,
			         new_high));
			    go to RECORDED_MESSAGE;
			  end;
		        end;
		        else do;
			new_high = new_low;
			sub_refs.ptr (2, i + current_indice) = null;
		        end;
		      ref_subscripts.value (1, i + current_indice) =
			 new_low;
		      ref_subscripts.value (2, i + current_indice) =
			 new_high;
		    end;
		    else do;
		      mult =
			 convert_units (mult, (array_info.array_units));
		      bit_offset = bit_offset + mult * (next_value - low);
		    end;
		  new_name =
		       probe_pascal_$indice_id (array_info.bounds (i)
		       .subscript_type,
		       array_info.bounds (i).subscript_type_addr,
		       next_value);
		  if length (element_name) + 1 + length (new_name) >
		       maxlength (element_name)
		    then call disgruntled (probe_et_$too_long);
		  if i = 1
		    then element_name = element_name || "[" || new_name;
		    else element_name = element_name || "," || new_name;
next_dim:
		  if i = n_dims then do;
		      if current_token.type = RIGHT_BRACKET then do;
			call bump_ct ();
			if length (element_name)
			     = maxlength (element_name)
			  then
			       call disgruntled (probe_et_$too_long);
			if ^P_reference.cross_section
			  then P_reference.name = element_name || "]";
		        end;
		        else do;
			call probe_error_$record (probe_info_ptr, 0,
			     "Right bracket expected after ""^a""",
			     element_name);
			go to RECORDED_MESSAGE;
		        end;
		    end;
		    else do;
		      if current_token.type = COMMA then do;
			call bump_ct ();
		        end;
		        else do;
			call probe_error_$record (probe_info_ptr, 0,
			     "Comma expected after ""^a""",
			     element_name);
			go to RECORDED_MESSAGE;
		        end;
		    end;
		end;


get_indice_value:
  proc;


  call probe_pascal_$indice_value (probe_info_ptr, next_ref, next_value,
       next_type,
       next_type_ptr, code);
  if code ^= 0
    then go to SOME_ERROR;
  call probe_pascal_$real_type (array_info.bounds (i).subscript_type,
       array_info.bounds (i).subscript_type_addr,
       array_info.bounds (i).subscript_type,
       array_info.bounds (i).subscript_type_addr);
  if next_type ^= array_info.bounds (i).subscript_type
       | next_type_ptr ^= array_info.bounds (i).subscript_type_addr then do;
      call probe_error_$record (probe_info_ptr, 0,
	 "Incorrect type of value in array indices.");
      go to RECORDED_MESSAGE;
    end;
  low = decode (array_info.bounds (i).lower,
       array_info.bounds (i).lower_is_encoded, P_reference.type_ptr);
  mult = decode (array_info.bounds (i).multiplier,
       array_info.bounds (i).multiplier_is_encoded, P_reference.type_ptr);
  if next_value < low | next_value > decode (array_info.bounds (i).upper,
       array_info.bounds (i).upper_is_encoded, P_reference.type_ptr) then do;
      call probe_error_$record (probe_info_ptr, 0,
	 "Array indice out of bounds.");
      go to RECORDED_MESSAGE;
    end;
  end get_indice_value;

	        end;
	        if ^P_reference.cross_section then do;
		  P_reference.address_ptr =
		       bitrel (P_reference.address_ptr, bit_offset);

		  type_info.version = RUNTIME_TYPE_INFO_VERSION_1;

		  call runtime_symbol_info_$type (P_reference.type_ptr,
		       addr (type_info), code);
		  if code ^= 0
		    then go to SOME_ERROR;

		  P_reference.type = type_info.base_type;
		  P_reference.type_ptr = type_info.base_type_addr;
		  P_reference.precision = type_info.size;
		end;
		else do;
		  if (current_token.type = PASCAL_ARROW)
		       | (current_token.type = LEFT_PAREN)
		       | (current_token.type = PERIOD) then do;
no_more_specs:
		      call probe_error_$record (probe_info_ptr, 0,
			 "No more specification allowed after subarray description."
			 );
		      go to RECORDED_MESSAGE;
		    end;
		  if current_token.type = LEFT_BRACKET then do;
		      call bump_ct ();
		      call runtime_symbol_info_$type (array_type_ptr,
			 addr (type_info), code);
		      if code ^= 0
		        then go to SOME_ERROR;
		      array_type_ptr = type_info.base_type_addr;
		      current_indice = current_indice + n_dims;
		      if array_type_ptr ^= null
		        then
			   n_dims =
			        runtime_symbol_info_$array_dims (
			        array_type_ptr);
		        else n_dims = 0;
		      if n_dims = 0
		        then go to no_more_specs;
		        else go to continue_subarray;
		    end;
		end;
	        go to continue_to_parse;
	      end;
	      else go to not_an_array;
	  end;
	  else do;
not_an_array:
	    call probe_error_$record (probe_info_ptr, 0,
	         "^a is not an array", P_reference.name);
	    go to RECORDED_MESSAGE;
	  end;
        end;
      if probe_info.ct -> token.type = ARROW then do;
arrow_found_execute:
	if P_reference.type ^= pointer_dtype /* probe pointer variable */
	  then do;
	    if P_reference.type ^= pascal_user_defined_type_instance_dtype
	      then do;
bad_locator:
	        call probe_error_$record (probe_info_ptr, 0,
		   "Given locator is not a pointer.");
	        go to RECORDED_MESSAGE;
	      end;
	    type_info.version = RUNTIME_TYPE_INFO_VERSION_1;
	    call runtime_symbol_info_$type (P_reference.type_ptr,
	         addr (type_info), code);
	    if code ^= 0
	      then go to SOME_ERROR;
	    if type_info.type ^= pascal_typed_pointer_type_dtype
	      then go to bad_locator;
	  end;
	if P_reference.address_ptr ^= null
	  then
	       if want_value then do;
		 if ((P_reference.type = pointer_dtype)
		      & (P_reference.packed)) |
		      (P_reference.precision = 36)
		   then
		        P_reference.address_ptr =
			   P_reference.address_ptr -> based_packed_ptr;
		   else
		        P_reference.address_ptr =
			   P_reference.address_ptr -> based_ptr;
		 if P_reference.address_ptr = null then do;
		     call probe_error_$record (probe_info_ptr, 0,
			"Given locator is null.");
		     go to RECORDED_MESSAGE;
		   end;
	         end;
	call bump_ct ();
	if current_token.type ^= NAME_TYPE then do;
	    call probe_error_$record (probe_info_ptr, 0,
	         "Type identifier expected after arrow.");
	    go to RECORDED_MESSAGE;
	  end;
	P_reference.type_ptr =
	     stu_$find_runtime_symbol (Block_ptr, (current_identifier_name),
	     found_ptr, steps);
	if P_reference.type_ptr = null then do;
	    if current_identifier_name = "integer" then do;
	        P_reference.type = pascal_integer_dtype;
	        P_reference.precision = 35;
	      end;
	    else if current_identifier_name = "real" then do;
	        P_reference.type = pascal_real_dtype;
	        P_reference.precision = 63;
	      end;
	    else if current_identifier_name = "boolean" then do;
	        P_reference.type = pascal_boolean_dtype;
	        P_reference.precision = 36;
	      end;
	    else if current_identifier_name = "char" then do;
	        P_reference.type = pascal_char_dtype;
	        P_reference.precision = 36;
	      end;
	    else do;
	      call probe_error_$record (probe_info_ptr, 0,
		 "Symbol ^a not found.", current_identifier_name);
	      go to RECORDED_MESSAGE;
	    end;
	  end;
	  else do;
	    call runtime_symbol_info_$type (P_reference.type_ptr,
	         addr (type_info), code);
	    if code ^= 0
	      then go to SOME_ERROR;
	    if (type_info.type = pascal_typed_pointer_type_dtype)
	         | (type_info.type = pascal_user_defined_type_dtype)
	         | (type_info.type = pascal_set_dtype)
	         | (type_info.type = pascal_record_type_dtype)
	         | (type_info.type = pascal_record_file_type_dtype) then do;
	        P_reference.type = pascal_user_defined_type_instance_dtype;
	        if type_info.type = pascal_typed_pointer_type_dtype
		then
		     P_reference.precision = 72;
				/* supposed non packed */
		else P_reference.precision = 0;
	      end;
	    else if type_info.type = pascal_enumerated_type_dtype then do;
	        P_reference.type = pascal_enumerated_type_instance_dtype;
	        P_reference.precision = 36;
	      end;
	    else do;
	      call probe_error_$record (probe_info_ptr, 0,
		 "^a is not a type.", current_identifier_name);
	      go to RECORDED_MESSAGE;
	    end;
	  end;
	P_reference.name = "(" || current_identifier_name || ")";
	P_reference.symbol_ptr = null;
	call bump_ct ();
	go to continue_to_parse;
        end;
      else
	 if current_token.type = PASCAL_ARROW then do;
	if P_reference.type_ptr ^= null then do;
	    if P_reference.type_ptr -> pascal_symbol_node_header.type =
	         pascal_typed_pointer_type_dtype then do;
				/* variable pointer */
	        if P_reference.address_ptr ^= null
		then
		     if want_value then do;
		         if P_reference.precision = 36
			 then
			      P_reference.address_ptr =
				 P_reference.address_ptr
				 -> based_packed_ptr;
			 else
			      P_reference.address_ptr =
				 P_reference.address_ptr -> based_ptr;
		         if P_reference.address_ptr = null then do;
			   call probe_error_$record (probe_info_ptr, 0,
			        "Pointer ^a is null.", P_reference.name)
			        ;
			   go to RECORDED_MESSAGE;
			 end;
		       end;

	        call runtime_symbol_info_$type (P_reference.type_ptr,
		   addr (type_info), code);
	        if code ^= 0
		then go to SOME_ERROR;

	        P_reference.symbol_ptr = null;
	        P_reference.type = type_info.base_type;
	        P_reference.type_ptr = type_info.base_type_addr;
	        P_reference.precision = type_info.size;
	        P_reference.name = P_reference.name || "^";
	        call bump_ct ();
	        go to continue_to_parse;
	      end;
	    else if P_reference.type_ptr -> pascal_symbol_node_header.type =
	         pascal_record_file_type_dtype then do;
				/* file window */

	        type_info.version = RUNTIME_TYPE_INFO_VERSION_1;

	        call runtime_symbol_info_$type (P_reference.type_ptr,
		   addr (type_info), code);
	        if code ^= 0
		then go to SOME_ERROR;

	        P_reference.type = type_info.base_type;
	        P_reference.type_ptr = type_info.base_type_addr;
	        go to file_window_join;
	      end;
	    else go to not_a_ptr;
	  end;
	else if P_reference.type = pascal_text_file_dtype then do;
				/* text file window */
	    P_reference.type = pascal_char_dtype;
	    P_reference.precision = 36;
	    P_reference.type_ptr = null;
file_window_join:
	    P_reference.symbol_ptr = null;
	    P_reference.name = P_reference.name || "^";
	    if P_reference.address_ptr ^= null then do;
	        if P_reference.address_ptr -> p.ftag ^= "43"b3
		   | P_reference.address_ptr -> based_ptr = null
		then
		     P_reference.address_ptr = null;
		else
		     P_reference.address_ptr =
			addrel (P_reference.address_ptr -> based_ptr,
			window_place_in_pascal_fsb);
	      end;
	    call bump_ct ();
	    go to continue_to_parse;
	  end;
	else do;
not_a_ptr:
	  call probe_error_$record (probe_info_ptr, 0,
	       "^a is neither a file nor a typed pointer.",
	       P_reference.name);
	  go to RECORDED_MESSAGE;
	end;
        end;
      if current_token.type = PERIOD then do;
				/* PASCAL field expected */
	call bump_ct ();
	if current_token.type ^= NAME_TYPE then do;
no_field_name:
	    call probe_error_$record (probe_info_ptr, 0,
	         "A field name must follow the "".""");
	    go to RECORDED_MESSAGE;
	  end;
	if P_reference.type_ptr ^= null then do;
	    if P_reference.type_ptr -> pascal_symbol_node_header.type
	         = pascal_record_type_dtype then do;
	        field_ptr = runtime_symbol_info_$son (P_reference.type_ptr);
	        call scan_record (field_ptr, (want_value));
	      end;
	      else go to not_a_record;
	  end;
	else if P_reference.type = pascal_record_type_dtype then do;
	    field_ptr = runtime_symbol_info_$son (P_reference.symbol_ptr);
	    call scan_record (field_ptr, "0"b);
	  end;
	else do;
not_a_record:
	  call probe_error_$record (probe_info_ptr, 0,
	       "^a is not a record", P_reference.name);
	  go to RECORDED_MESSAGE;
	end;
	call probe_error_$record (probe_info_ptr, 0,
	     "^a is not a field of ^a", identifier_tokens_name,
	     P_reference.name);
	go to RECORDED_MESSAGE;
        end;			/* field of record */
    end;				/* identifier */

  else if current_token.type = LEFT_BRACKET then do;
				/* PASCAL set */
      P_reference.type = pascal_user_defined_type_instance_dtype;
      allocate pascal_symbol_node_header in (expression_area)
	 set (P_reference.type_ptr);
      unspec (P_reference.type_ptr -> pascal_symbol_node_header) = "0"b;
      P_reference.type_ptr -> pascal_symbol_node_header.type =
	 pascal_set_dtype;
      allocate pascal_set in (expression_area) set (P_reference.address_ptr);
      P_reference.precision = size (pascal_set);
      P_reference.packed = "0"b;
      P_reference.name = "<<set>>";
      P_reference.descriptor = 0;

      P_reference.address_ptr -> pascal_set = "0"b;

      call bump_ct ();

      if current_token.type = RIGHT_BRACKET then do;
				/* empty set */
	call bump_ct ();
	go to end_of_parsing;
        end;

      call probe_pascal_$indice_value (probe_info_ptr, first_ref, first_value,
	 first_type, first_type_ptr, code);
      if code ^= 0
        then go to SOME_ERROR;
      call fill_set (first_value, first_ref);

      do while (current_token.type = COMMA);
        call bump_ct ();
        call probe_pascal_$indice_value (probe_info_ptr, next_ref, next_value,
	   next_type,
	   next_type_ptr, code);
        if code ^= 0
	then go to SOME_ERROR;
        if (first_type ^= next_type)
	   | (first_type_ptr ^= next_type_ptr) then do;
	  call probe_error_$record (probe_info_ptr, 0,
	       "Types of elements of set do not match.");
	  go to RECORDED_MESSAGE;
	end;
        call fill_set (next_value, next_ref);
      end;

      if current_token.type ^= RIGHT_BRACKET then do;
	call probe_error_$record (probe_info_ptr, 0,
	     "Error in set description.");
	go to RECORDED_MESSAGE;
        end;

      call bump_ct ();
      go to end_of_parsing;
    end;				/* PASCAL <<set>> */

end_of_parsing:
  return;
%page;
  /* Procedures internal to parse_ala_pascal */

bitrel:
  proc (P_ptr, P_bit_offset) returns (ptr);
  dcl P_ptr		ptr parameter;
  dcl P_bit_offset		fixed bin (35) parameter;

  dcl 1 str		unaligned based (P_ptr),
       2 filler		unal bit (P_bit_offset),
       2 target		unal bit (1);

  if P_bit_offset < 0
    then return (null);
  return (addr (str.target));

  end bitrel;


convert_units:
  proc (value, unit_code) returns (fixed bin (35));

  dcl value		fixed bin (35) parameter;
				/* offset in raw */
  dcl unit_code		fixed bin (2) parameter unsigned;


  goto units_case (unit_code);

units_case (0):
  return (value * bits_per_word);	/* word */
units_case (1):
  return (value);			/* bit */
units_case (2):
  return (value * bits_per_character);	/* char */
units_case (3):
  return (value * bits_per_half);	/* halfword */

  end convert_units;


decode:
  proc (value, encoded, symbp) returns (fixed bin (35));

  dcl value		fixed bin (35);
  dcl encoded		bit (1);
  dcl symbp		ptr;

  dcl ptr			builtin;
  dcl stu_$decode_runtime_value_extended
			entry (fixed bin (35), ptr, ptr, ptr, ptr, ptr,
			ptr, fixed bin (35)) returns (fixed bin (35));
  dcl result		fixed bin (35);

  if ^encoded
    then return (value);
    else do;
      result =
	 stu_$decode_runtime_value_extended (value, Block_ptr, Stack_ptr,
	 Linkage_ptr,
	 ptr (Block_ptr, 0), Base_addr, symbp, code);
      if code ^= 0
        then go to SOME_ERROR;
      return (result);
    end;

  end decode;


fill_set:
  proc (val, ref_ptr);

  dcl val			fixed bin (35);
  dcl ref_ptr		ptr;

  if val >= pascal_max_set_size then do;
      call probe_error_$record (probe_info_ptr, 0,
	 "Value of ^a is out of PASCAL set range.",
	 ref_ptr -> reference_node.name);
      go to RECORDED_MESSAGE;
    end;
  substr (P_reference.address_ptr -> pascal_set, val + 1, 1) = "1"b;

  end fill_set;


is_cross_section:
  proc (P_ct) returns (bit (1));

  dcl (P_ct, ct)		ptr;

  do ct = P_ct repeat (ct -> current_token.next) while (ct ^= null);
    if ct -> current_token.type = RIGHT_BRACKET
      then return ("0"b);
    if ct -> current_token.type = C_INDIRECTION
         | ct -> current_token.type = TIMES | ct -> current_token.type = COLON
      then return ("1"b);
  end;
  return ("0"b);

  end is_cross_section;


scan_record:
  proc (FIELD_PTR, EXECUTE);

  dcl FIELD_PTR		ptr;
  dcl EXECUTE		bit (1);

  dcl prev_ptr		ptr;
  dcl i			fixed bin;

  prev_ptr = null;
  call scan_fields (FIELD_PTR);
  if prev_ptr ^= null then do;
      n_variants = runtime_symbol_info_$n_variants (prev_ptr);
      if n_variants ^= 0
        then
	begin;
	dcl 1 variant_info	        like runtime_variant_info;

	variant_info.version = RUNTIME_VARIANT_INFO_VERSION_1;

	call runtime_symbol_info_$variant (prev_ptr, addr (variant_info),
	     code);
	if code ^= 0
	  then go to SOME_ERROR;

	do i = 1 to n_variants;
	  call scan_record (variant_info.case (i).brother_addr, EXECUTE);
	end;
        end;
    end;
  return;

scan_fields:
  proc (FIELD_P);

  dcl FIELD_P		ptr;

  dcl name_ptr		ptr;
  dcl 1 type_info		like runtime_type_info;
  dcl 1 address_info	like runtime_address_info;

  do while (FIELD_P ^= null);
    name_ptr = runtime_symbol_info_$name (FIELD_P);
    if name_ptr ^= null then do;
        if name_ptr -> acc.string = identifier_tokens_name then do;
	  if (length (P_reference.name) + 1 + name_ptr -> acc.num_chars) >
	       maxlength (P_reference.name)
	    then call disgruntled (probe_et_$too_long);
	  P_reference.name =
	       P_reference.name || "." || identifier_tokens_name;

	  type_info.version = RUNTIME_TYPE_INFO_VERSION_1;

	  call runtime_symbol_info_$type (FIELD_P, addr (type_info), code);
	  if code ^= 0
	    then go to SOME_ERROR;

	  if EXECUTE then do;

	      address_info.version = RUNTIME_ADDRESS_INFO_VERSION_1;

	      call runtime_symbol_info_$address (FIELD_P,
		 addr (address_info), code);
	      if code ^= 0
	        then go to SOME_ERROR;

	      P_reference.address_ptr = bitrel (P_reference.address_ptr,
		 convert_units (
		 decode (address_info.offset,
		 address_info.offset_is_encoded, FIELD_P),
		 bin (address_info.units, 2)));
	    end;
	  P_reference.type = type_info.type;
	  P_reference.type_ptr = type_info.type_addr;
	  P_reference.packed = type_info.packed;
	  P_reference.precision = type_info.size;
	  P_reference.symbol_ptr = FIELD_P;
	  call bump_ct ();
	  go to continue_to_parse;
	end;
      end;
    prev_ptr = FIELD_P;
    FIELD_P = runtime_symbol_info_$brother (FIELD_P);
  end;
  end scan_fields;

  end scan_record;

  end parse_ala_pascal;
%page;
  /* COMMON SUBROUTINES FOR DIFFERENT STYLES OF PARSING */

add:
  proc (P_str);

  dcl P_str		char (*);

  if length (P_reference.name) + length (P_str) > maxlength (P_reference.name)
    then
         call disgruntled (probe_et_$too_long);

  P_reference.name = P_reference.name || P_str;

  end add;


get_dim:
  proc;

  /* we parse a dim - that may be

   DIM ::= expression | expression:expression | *

   global import P_reference, sub_refs, ct

*/

  dcl subp		ptr;
  dcl sub_no		fixed bin;

  if P_reference.n_subscripts >= hbound (sub_refs.ptr, 2)
    then call disgruntled (probe_et_$dim_limit);

  sub_no, P_reference.n_subscripts = P_reference.n_subscripts + 1;
  P_reference.n_arguments = P_reference.n_arguments + 1;

  call probe_create_reference_ (probe_info_ptr, subp);
  sub_refs.ptr (1, sub_no) = subp;

  if (ct -> token.type = TIMES | ct -> token.type = C_INDIRECTION)
       & ^P_reference.path then do;
				/* star extent */
      subp -> subscript.flags.star_extent = "1"b;
      subp -> subscript.name = "<<star extent low bound>>";
      call probe_create_reference_ (probe_info_ptr, subp);
      sub_refs.ptr (2, sub_no) = subp;
      subp -> subscript.flags.star_extent = "1"b;
      subp -> subscript.name = "<<star extent high bound>>";
      call bump_ct ();
      P_reference.cross_section = "1"b;
    end;

    else do;
      call probe_get_$expression (probe_info_ptr, subp -> reference_node,
	 code);
      if code ^= 0
        then goto SOME_ERROR;

      if probe_info.ct -> operator.type = COLON then do;
	call probe_create_reference_ (probe_info_ptr, subp);
	sub_refs.ptr (2, sub_no) = subp;
	call bump_ct ();
	call probe_get_$expression (probe_info_ptr, subp -> reference_node,
	     code);
	if code ^= 0
	  then goto SOME_ERROR;
	P_reference.cross_section = "1"b;
        end;
        else sub_refs.ptr (2, sub_no) = null ();
    end;				/* non-* case */

  end get_dim;


get_parens:
  proc ();

  call bump_ct ();			/* past the ( */
  if probe_info.ct -> operator.type = RIGHT_PAREN then do;
				/* () */
      call bump_ct ();
      P_reference.function = "1"b;	/* it is () */
    end;
    else do;
      call get_dim ();		/* first subscript */
      do while (probe_info.ct -> token.type = COMMA);
				/* DO=UNTIL */
        call bump_ct ();		/* past comma, or first paren */
        call get_dim ();
      end;			/* do until no comma loop */

      if probe_info.ct -> operator.type ^= RIGHT_PAREN then do;
	call probe_error_$record (probe_info_ptr, 0,
	     "Syntax error in subscript/argument list");
	goto RECORDED_MESSAGE;
        end;
      call bump_ct ();		/* past  the ) */
    end;				/* non - null subscript/arg list loop */

  end get_parens;


get_c_brackets:
  proc ();

  dcl not_end_of_dims	bit (1);


  call bump_ct ();			/* past the [ */
				/* One empty subscript is allowed if the symbol is a char ptr in C */
  if (probe_info.ct -> token.type = RIGHT_BRACKET)
    then
         need_to_indirect_and_make_string = "1"b;
    else call get_dim ();
  not_end_of_dims = "1"b;
  do while (not_end_of_dims);
    if (probe_info.ct -> token.type = RIGHT_BRACKET) then do;
        call bump_ct ();
        if (probe_info.ct -> token.type = LEFT_BRACKET) then do;
	  call bump_ct ();
	  if (probe_info.ct -> token.type = RIGHT_BRACKET) then do;
				/*	      call probe_error_$record (probe_info_ptr, 0,
		 "Only the first subscript of a character array referenced using^/ a pointer value may be empty."
		 );
	      goto RECORDED_MESSAGE;*/
	    end;
	    else call get_dim ();
	end;
	else not_end_of_dims = "0"b;
      end;
      else do;
        call probe_error_$record (probe_info_ptr, 0,
	   "Syntax error in subscript/argument list");
        goto RECORDED_MESSAGE;
      end;
  end;

  end get_c_brackets;


get_pathname:
  proc ();


  do while (probe_info.ct -> token.type = GREATER_THAN
       | probe_info.ct -> token.type = LESS_THAN |
       probe_info.ct -> token.type = PERIOD
       | probe_info.ct -> token.type = DOLLAR_SIGN |
       probe_info.ct -> token.type = OR_BAR);

    if probe_info.ct -> token.type = GREATER_THAN
      then call add (">");
    else if probe_info.ct -> token.type = LESS_THAN
      then call add ("<");
    else if probe_info.ct -> token.type = PERIOD
      then call add (".");
    else if probe_info.ct -> token.type = DOLLAR_SIGN
      then call add ("$");
    else call add ("|");

    call bump_ct ();

    if probe_info.ct -> token.type >= probe_info.end_token
      then go to GOT_PATH;
    else if probe_info.ct -> token.type ^= NAME_TYPE then do;
        call probe_error_$record (probe_info_ptr, error_table_$badpath);
        go to RECORDED_MESSAGE;
      end;

    call add (identifier_tokens_name);

    call bump_ct ();
  end;
GOT_PATH:
  dummy_entry = cv_entry_ ((P_reference.name), null, code);
  if code ^= 0 then do;
      call probe_error_$record (probe_info_ptr, code, P_reference.name);
      go to RECORDED_MESSAGE;
    end;

  P_reference.path = "1"b;

  call get_parens ();

  end get_pathname;



bump_ct:
  proc;
  probe_info.ct = probe_info.ct -> token.next;
  end bump_ct;


cobol_connector:
  proc (p) returns (bit (1) aligned);
  dcl p			ptr parameter;
  dcl based_two		char (2) unal based (p -> identifier.name);
  dcl c2			char (2) aligned;
  if p -> token.type = NAME_TYPE
    then if p -> identifier.length = 2 then do;
	   c2 = based_two;
	   if c2 = "of" | c2 = "in" | c2 = "OF" | c2 = "IN"
	     then return ("1"b);
	 end;
  return ("0"b);
  end cobol_connector;

looks_like_cobol:
  proc () returns (bit (1) aligned);
  if probe_info.language_type = COBOL_lang_type
       & probe_info.ct -> token.type = NAME_TYPE
    then if cobol_connector ((probe_info.ct -> token.next))
	 then return ("1"b);
  return ("0"b);			/* cobol, but in "normal" form */
  end looks_like_cobol;
%page;
  /*        INCLUDE FILES       */

%include probe_info;
%page;
%include probe_tokens;
%page;
%include probe_references;
%page;
%include probe_source_info;
%page;
%include probe_seg_info;
%page;
%include runtime_symbol;
%page;
%include acc;
%page;
%include probe_operators;
%page;
%include probe_lang_types;
%page;
%include std_descriptor_types;
%page;
%include pascal_symbol_node;
%page;
%include encoded_precision;
%page;
%include pascal_gen_constants;
%page;
%include computational_data;
%page;
%include runtime_symbol_info_;
%page;
%include system;
%include its;

  end probe_get_value_;
