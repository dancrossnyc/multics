/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(88-09-30,WAAnderson), approve(88-09-30,MCR7863),
     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
     Fixed bugs associated with object segments compiled with the -brief_table
     control argument.
  2) change(88-09-30,WAAnderson), approve(88-09-30,MCR7952),
     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
     Added format control comment to make the source more readable.
  3) change(88-10-21,WAAnderson), approve(88-10-21,MCR7952),
     audit(88-10-24,RWaters), install(88-10-27,MR12.2-1194):
     Modified for C.  The names of C functions were not been printed.
                                                   END HISTORY COMMENTS */

/* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

probe_break_mgr_:
  proc;

  call probe_error_$malfunction ();	/* dummy entry */

  /* Here we have entries to set breaks, to list breaks, and to reset breaks -
   programs here know about how breaks are implemented, and about the various data structures.
   The exact arrangements of procedures is subject to change

   COMPLETELY NEW CODE - by James R. Davis 25 Sept 79

   ENTRIES

   set_break

   list_breaks_at_line
   list_breaks_in_seg
   list_breaks_in_world
   list_broken_segs

   reset_break_at_line
   reset_breaks_in_seg
   reset_breaks_in_world
   reset_all_pause_breaks

   print_instructions	prints code for a stmt, with breaks invisible.

   Big comment explaining the data structures used - see end, just before include files */
  /* Modified 17 August 1981 by Melanie Weaver to handle segs that end on even word. */
  /* Changed to initialize break segment when needed (instead of at command time) 09/28/81 S. Herbst */
  /* Fixed to always delete break map after last break in seg is reset 11/03/81 S. Herbst */
  /* Added $is_temporary_break returns "1"b if after break is "pause" 12/02/81 S. Herbst */
  /* Fixed bug when breakmap is deleted 12/29/81 S. Herbst */
  /* Fixed to remove added w access when done 03/15/82 S. Herbst */
  /* Fixed ACL forcing once more 05/25/82 S. Herbst */
  /* Added $print_instructions 09/15/82 S. Herbst */
  /* Fixed error message printed when debug breaks are left in break map 08/12/83 S. Herbst */
  /* Fixed bug in "r N" that can reset an extra break 03/30/84 S. Herbst */
  /* Added $reset_all_pause_breaks, called when exiting probe 04/19/84 S. Herbst */
  /* Fixed not to overwrite a real break with one set by "step" 04/19/84 S. Herbst */
  /* Fixed to fail gracefully if source_info.instruction_ptr = null 08/02/84 S. Herbst */


  dcl (
      P_probe_info_ptr	ptr parameter,
      P_break_type		fixed bin,/* BREAK_AT, BREAK_AFTER, etc. */
      P_command_ptr		ptr,	/* to break request list */
      P_command_length	fixed bin (21),
				/* how many chars in list */
      P_instruction_ptr	ptr,	/* for $print_instructions */
      P_len		fixed bin,/* for $print_instructions */
      P_long_sw		bit (1) aligned,
				/* verbosity control */
      P_source_info_ptr	ptr,	/* to source_info */
      P_code		fixed bin (35)
      )			parameter;

  dcl (
      PRINT		init ("1"b),
      NO_PRINT		init ("0"b)
      )			bit (1) aligned int static options (constant);
  dcl BRIEF		bit (1) aligned int static
			options (constant) init ("0"b);

  dcl seginfop		ptr;	/* to the seg info of some object seg */
  dcl code		fixed bin (35);
  dcl number		fixed bin;/* the index into Map_array */
  dcl happy		bit (1) aligned;
				/* did we find even one break */
  dcl breakmap_deleted_sw	bit (1) aligned;
  dcl break_type		fixed bin;/* global use: AT AFTER BEFORE */
  dcl based_word		bit (36) aligned based;

  dcl first		ptr;	/* in loops, to the first */
  dcl next		ptr;	/* in loops, to the next */
  dcl long_sw		bit (1) aligned;
				/* copy of P_long, at times */
  dcl pauses_entry_sw	bit (1) aligned;
				/* called $reset_all_pause_breaks */

  dcl instruction_ptr	ptr;
  dcl slot_ptr		ptr;
  dcl slot_offset		bit (18);
  dcl saved_instruction	bit (36) aligned;

  dcl added_w_sw		bit (1) aligned;
				/* to remove w access when done if it was added */
  dcl after_sw		bit (1) aligned;
				/* ON => temporarily resetting an after break */
  dcl saved_mode_sw		bit (1) aligned;
				/* there was already an acl entry for group_id$tag_star */
  dcl saved_mode		bit (3);	/* access to restore when removing w */
  dcl saved_stp		ptr;	/* saved copy of stp while resetting breaks */
  dcl 1 seg_acl		(1) aligned like segment_acl;
  dcl acl_dn		char (168);
  dcl acl_en		char (32);

  dcl 1 Break_source	aligned like source_info
			based (break_source_info_ptr);
  dcl break_source_info_ptr	ptr;

  dcl 1 Map_array		(Map_size) aligned like statement_map
			based (Map_ptr);
  dcl Map_size		fixed bin;
  dcl Map_ptr		ptr;

  dcl NL			char (1) int static options (constant) init ("
");
  dcl (
      probe_map_sequence_$before_code
			bit (36), /* to get its address */
      probe_map_sequence_$after_code
			bit (36),
      probe_map_sequence_$count
			fixed bin,
      probe_map_sequence_$code
			bit (36),
      probe_map_sequence_$return
			bit (36),
      probe_map_sequence_$old_return
			bit (36)
      )			aligned external static;

  dcl probe_seg_mgr_$create_breakseg
			entry (fixed bin (35)) returns (ptr);
  dcl probe_seg_mgr_$get_procedure_entry
			entry (ptr, ptr, ptr, ptr, fixed bin (35));
  dcl probe_seg_mgr_$first_procedure_ptr
			entry (ptr, fixed bin (35)) returns (ptr);
  dcl probe_seg_mgr_$create_procedure_entry
			entry (ptr, ptr, ptr, ptr, fixed bin (35));
  dcl probe_seg_mgr_$delete_procedure_entry
			entry (ptr, ptr, fixed bin (35));

  dcl (
      probe_error_$malfunction,
      probe_error_$record
      )			entry options (variable);

  dcl get_group_id_		entry returns (char (32));
  dcl inst_length_		entry (ptr, fixed bin) returns (fixed bin);
  dcl print_instructions_	entry (ptr, fixed bin, ptr);
  dcl relocate_instruction_	entry (ptr, ptr, fixed bin (35));
  dcl hcs_$add_acl_entries	entry (char (*), char (*), ptr, fixed bin,
			fixed bin (35));
  dcl hcs_$delete_acl_entries entry (char (*), char (*), ptr, fixed bin,
			fixed bin (35));
  dcl hcs_$fs_get_path_name	entry (ptr, char (*), fixed bin, char (*),
			fixed bin (35));
  dcl hcs_$list_acl		entry (char (*), char (*), ptr, ptr, ptr,
			fixed bin, fixed bin (35));
  dcl hcs_$set_bc_seg	entry (ptr, fixed bin (24), fixed bin (35));


  dcl ioa_$ioa_switch	entry options (variable);

  dcl (
      probe_et_$breakless,
      probe_et_$no_breaks_set,
      probe_et_$no_breaks,
      probe_et_$non_standard,
      probe_et_$breaks_exist,
      probe_et_$old_break_map,
      probe_et_$recorded_message
      )			fixed bin (35) external static;

  dcl (add, addr, addrel, binary, bit, divide, fixed, hbound,
      mod, multiply, null, pointer, ptr, rel, size, substr, subtract, unspec)
			builtin;


RECORDED_MESSAGE:
  P_code = probe_et_$recorded_message;
  return;


set_break:
  entry (P_probe_info_ptr, P_source_info_ptr, P_break_type, P_command_ptr,
       P_command_length, P_code);


  begin;

    dcl command_ptr		  ptr;
    dcl command_length	  fixed bin (21);
    dcl command		  char (command_length) based (command_ptr);
    dcl map_seq_ptr		  ptr;	/* to map_sequence in this object seg */
    dcl place_to_set	  ptr;	/* where to put the break */
    dcl next_loc		  ptr;	/* to instruction after the broken one */
    dcl copy		  (copy_count) bit (36) based;
    dcl copy_count		  fixed bin (21);



    /* HOW TO SET BREAKS :

   Create a break map for the object seg (if one doesn't exist already)
   Ensure sufficient access and that maxlength of seg is reset to big
   create a procedure entry for seg in break_seg (if not one already)
   if there is already a break at the line of same type, reset it

   if there is no statement entry for the given statement, create it

   create a break_slot of the right kind
   relocate instruction


   An additional hairy feature:

   It may be that the user sets a break after and before a line, and the line is only one instrcuton
   long.  This is known as a "strange" break.  A "strange" break is implemented by a "tra" to the before code sequence
   (just as for a normal before break).  the before code executes its map sequence, and probe is invoked in the usual way.
   The "moved_instruction" in the before slot, however, is replaced with a "tra" to the after slot sequence.  It is as if
   there has been an "after" break set IN THE BEFORE SEQUENCE ITSELF.
   The after sequence first executes the original "moved" instruction (which completes the execution of all object code
   for the line), then executes the map sequence, and probe is once again invoked.

   When the "before" break is reset, it copies the "old_instruction" back into the object segment (just as is done for a
   "normal"    before break).  This instruction is a tra to the after code, not the original instruction.
   The original   is still stored in the after slot, since the after break is still in effect..
   If a "strange" after break   is reset, then the saved "old" and "moved" instructions are returned
   to the before slot where they   were copied from, and all is well
*/

    probe_info_ptr = P_probe_info_ptr;
    P_code = 0;
    command_length = P_command_length;
    command_ptr = P_command_ptr;
    break_type = P_break_type;
    break_source_info_ptr = P_source_info_ptr;
    code = 0;
    seginfop = Break_source.seg_info_ptr;

    if Break_source.instruction_ptr = null then do;
        place_to_set = null;
        go to CANT_RELOCATE;
      end;

    if probe_static_info.break_segment_ptr = null then do;
        probe_static_info.break_segment_ptr =
	   probe_seg_mgr_$create_breakseg (code);
        if code ^= 0 then do;
	  call probe_error_$record (probe_info_ptr, 0,
	       "Can't initialize break segment.");
	  go to RECORDED_MESSAGE;
	end;
      end;

    call probe_seg_mgr_$create_procedure_entry (probe_info_ptr, seginfop, ent,
         bmp, P_code);
    if P_code ^= 0
      then
	 return;

    call ensure_writeable ((Break_source.instruction_ptr));
    if bmp = null () then do;
        call create_breakmap ();
        procedure_entry.break_map = rel (bmp);
      end;

    number = Break_source.stmnt_map_entry_index;
    stp = search_for_stmt (ent, bmp, number);

    if stp = null ()		/* no previous record for this line */
      then stp = create_statement_entry (ent, bmp,
	      Break_source.stmnt_map_entry_index);
      else do;
        if statement_item.slots (break_type) ^= (18)"0"b
	then
	     if command = "pause"
	       then
		  return;		/* "step" break shouldn't overwrite real one */
	       else call remove_break ((break_type));
      end;


    Map_ptr = seginfop -> seg_info.statement_map_ptr;
    Map_size = seginfop -> seg_info.map_size;
    place_to_set = pointer (bmp, Map_array (number).location);

    command_list_size = command_length + 1;
				/* for NL */

    map_seq_ptr = addr (break_map.map_sequence);
    if break_type = BREAK_BEFORE then do;
        next_loc = addrel (place_to_set, inst_length_ (place_to_set, (0)));
        if next_loc = place_to_set
	then goto CANT_GET_LENGTH;

        bsp, before_slot_ptr =
	   allocate_in_breakmap (size (break_slot_before));

        /* because we didn't use pl1 allocate we must initialize the slot ourselves */

        call common_break_slot_setup (before_slot_ptr);
				/* size is set by allocate_in_breakmap */
        break_slot_before.type = BREAK_BEFORE;

        copy_count = size_of_before_sequence;
        unspec (break_slot_before.sequence) =
	   unspec (addr (probe_map_sequence_$before_code) -> copy);
        break_slot_before.sequence.map_seq_offset = rel (map_seq_ptr);
        break_slot_before.sequence.slot_offset = rel (before_slot_ptr);
        break_slot_before.sequence.return.offset = rel (next_loc);

        call relocate_instruction_ (place_to_set,
	   addr (break_slot_before.moved_instruction), code);

        if code ^= 0
	then goto CANT_RELOCATE;
        break_slot_before.old_instruction = place_to_set -> based_word;

        place_to_set -> based_word =
	   rel (addr (break_slot_before.sequence)) || TRA_code;
				/* ughh */

      end;			/* break before */
      else do;
        if number = hbound (Map_array, 1) then do;
	  call probe_error_$record (probe_info_ptr, 0,
	       "Can't set break after last line in program");
	  goto RECORDED_MESSAGE;
	end;
        next_loc = place_to_set;

        /* find last inst. in line, and first inst. after it.  this is hard,
   because we can't just look at last word of the line, because it could be
   the descriptor of an EIS.  the only safe way is to look at each instruction, find its length,
   and look where the next inst. is to begin.  I wish the statement map told us.
*/

        if statement_item.slots (BREAK_BEFORE) = "0"b
	then before_slot_ptr = null ();
	else do;

	  /* the instruction there is only a TRA, of length one, the real instruction is in the break_slot */
	  before_slot_ptr =
	       pointer (stp, statement_item.slots (BREAK_BEFORE));
	  next_loc = addrel (next_loc,
	       inst_length_ (addr (break_slot_before.old_instruction), (0)))
	       ;
	end;

        do while (rel (next_loc) < Map_array (number + 1).location);
				/* find last inst. in line */
	place_to_set = next_loc;	/* this one is known good */
	next_loc = addrel (next_loc, inst_length_ (next_loc, (0)));
	if next_loc = place_to_set	/* means the length was 0, i.e. bad */
	  then goto CANT_GET_LENGTH;
        end;

        bsp, after_slot_ptr = allocate_in_breakmap (size (break_slot_after));
        call common_break_slot_setup (after_slot_ptr);
        copy_count = size_of_after_sequence;
        unspec (break_slot_after.sequence) =
	   unspec (addr (probe_map_sequence_$after_code) -> copy);

        break_slot_after.sequence.map_seq_offset = rel (map_seq_ptr);
        break_slot_after.sequence.slot_offset = rel (after_slot_ptr);
        break_slot_after.sequence.return.offset = rel (next_loc);
        break_slot_after.type = BREAK_AFTER;

        /* where we really set the break depends on strangeness */

        if strange_casep ()
	then do;
	  call relocate_instruction_ (
	       addr (break_slot_before.moved_instruction),
	       addr (break_slot_after.moved_instruction), code);
	  if code ^= 0
	    then goto CANT_RELOCATE;
	  break_slot_after.old_instruction =
	       break_slot_before.old_instruction;
	  break_slot_before.old_instruction,
	       break_slot_before.moved_instruction =
	       rel (addr (break_slot_after.sequence)) || TRA_code;

	end;
	else do;
	  break_slot_after.old_instruction = place_to_set -> based_word;
	  call relocate_instruction_
	       (place_to_set, addr (break_slot_after.moved_instruction),
	       code);
	  if code ^= 0
	    then goto CANT_RELOCATE;
	  place_to_set -> based_word =
	       rel (addr (break_slot_after.sequence)) || TRA_code;

	end;
      end;			/* BREAK after code */

    statement_item.slots (break_type) = rel (bsp);
				/* remember the break */

    if added_w_sw
      then call restore_readonly ((Break_source.instruction_ptr));
    return;



CANT_RELOCATE:
    call probe_error_$record (probe_info_ptr, 0,
         "Can't set break because can't relocate instruction at ^p",
         place_to_set);
    goto RECORDED_MESSAGE;

CANT_GET_LENGTH:
    call probe_error_$record (probe_info_ptr, 0,
         "Can't set break because can't get length of instruction at ^p",
         place_to_set);
    goto RECORDED_MESSAGE;



strange_casep:
  proc () returns (bit (1) aligned);

  if before_slot_ptr ^= null ()
    then if before_slot_ptr -> break_slot_before.location = rel (place_to_set)
	 then return ("1"b);
  return ("0"b);
  end strange_casep;




common_break_slot_setup:
  proc (P_bsp);

  dcl P_bsp		ptr parameter;
  dcl absp		ptr;

  absp = P_bsp;

  absp -> break_slot.item_type = BREAK_ITEM;
  absp -> break_slot.breakmap_header_offset = rel (bmp);
  absp -> break_slot.statement_item_offset = rel (stp);
  if Break_source.block_ptr = null ()
    then absp -> break_slot.symbol_block_offset = "0"b;
    else absp -> break_slot.symbol_block_offset =
	    rel (Break_source.block_ptr);
  absp -> break_slot.location = rel (place_to_set);
  absp -> break_slot.count = command_list_size;
  absp -> break_slot.command_list = command || NL;
  end common_break_slot_setup;
  end;				/* set break begin block */
%page;
is_temporary_break:
  entry (P_probe_info_ptr, P_source_info_ptr) returns (bit (1));

  /* Returns "1"b if the stmt pointed to has a temporary break (the before break is "pause"), "0"b otherwise */

  probe_info_ptr = P_probe_info_ptr;
  break_source_info_ptr = P_source_info_ptr;
  seginfop = Break_source.seg_info_ptr;

  number = Break_source.stmnt_map_entry_index;

  call probe_seg_mgr_$get_procedure_entry (probe_info_ptr, seginfop, ent, bmp,
       code);
  if code ^= 0
    then
         return ("0"b);

  if ent ^= null & bmp ^= null then do;

      stp = search_for_stmt (ent, bmp, number);
      if stp ^= null
        then
	   if stp -> statement_item.slots (BREAK_BEFORE) ^= (18)"0"b
	     then do;
	       bsp = pointer (stp, statement_item.slots (BREAK_BEFORE));
	       if bsp -> break_slot.command_list = "pause" || NL
	         then return ("1"b);
				/* a temporary break */
	     end;
    end;
  return ("0"b);
%page;


  /* here are the entries to list breaks - we have four flavors

   list_breaks_at_line
   list_breaks_in_seg
   list_breaks_in_world
   list_broken_segs

*/

list_breaks_at_line:
  entry (P_probe_info_ptr, P_source_info_ptr, P_break_type, P_long_sw, P_code)
       ;

  probe_info_ptr = P_probe_info_ptr;
  break_source_info_ptr = P_source_info_ptr;
  P_code = 0;
  long_sw = P_long_sw;

  seginfop = Break_source.seg_info_ptr;
  break_type = P_break_type;
  happy = "0"b;

  number = Break_source.stmnt_map_entry_index;

  call probe_seg_mgr_$get_procedure_entry (probe_info_ptr, seginfop, ent, bmp,
       P_code);
  if P_code ^= 0
    then
         return;

  if ent ^= null () & bmp ^= null () then do;
      stp = search_for_stmt (ent, bmp, number);
      if stp ^= null then do;
	if stp -> statement_item.slots (BREAK_BEFORE) ^= (18)"0"b &
	     (break_type = BREAK_BEFORE | break_type = BREAK_AT) then do;
	    happy = "1"b;
	    call display_break
	         (ptr (stp, statement_item.slots (BREAK_BEFORE)), "0"b,
	         long_sw);
	  end;
	if stp -> statement_item.slots (BREAK_AFTER) ^= (18)"0"b &
	     (break_type = BREAK_AFTER | break_type = BREAK_AT) then do;
	    happy = "1"b;
	    call display_break
	         (ptr (stp, statement_item.slots (BREAK_AFTER)), "0"b,
	         (long_sw));
	  end;
        end;
    end;

  if ^happy
    then P_code = probe_et_$breakless;
  return;


list_breaks_in_seg:
  entry (P_probe_info_ptr, P_source_info_ptr, P_long_sw, P_code);

  probe_info_ptr = P_probe_info_ptr;
  P_code = 0;
  break_source_info_ptr = P_source_info_ptr;
  happy = "0"b;
  long_sw = P_long_sw;

  seginfop = Break_source.seg_info_ptr;
  call probe_seg_mgr_$get_procedure_entry (probe_info_ptr, seginfop, ent, bmp,
       P_code);
  if P_code ^= 0
    then
         return;

  if ent ^= null () & bmp ^= null ()
    then call list_all_in (long_sw, PRINT, happy);
  if ^happy
    then P_code = probe_et_$no_breaks;
  return;


list_breaks_in_world:
  entry (P_probe_info_ptr, P_long_sw, P_code);

  /* Note similarity to list_broken_segs and reset_breaks_in_world.
   All have exact same control structure (which is right).
   Wish PL/I supported generator-style co-rountines */

  probe_info_ptr = P_probe_info_ptr;
  happy = "0"b;
  P_code = 0;
  long_sw = P_long_sw;
  first = probe_seg_mgr_$first_procedure_ptr (probe_info_ptr, P_code);
  if P_code ^= 0
    then
         return;

  if first ^= null ()
    then
      do ent = first repeat next while (rel (ent) ^= (18)"0"b);
      next = pointer (ent, procedure_entry.chain);
				/* might disappear if found obs */
      bmp = get_breakmap_ptr ();
      if bmp ^= null ()
        then call list_all_in (long_sw, PRINT, happy);
    end;				/* lop over ents */

  if ^happy
    then P_code = probe_et_$no_breaks_set;
  return;

list_broken_segs:
  entry (P_probe_info_ptr, P_code);

  probe_info_ptr = P_probe_info_ptr;
  P_code = 0;

  first = probe_seg_mgr_$first_procedure_ptr (probe_info_ptr, P_code);
  if P_code ^= 0
    then
         return;

  happy = "0"b;

  if first ^= null ()
    then
      do ent = first repeat next while (rel (ent) ^= (18)"0"b);

      next = pointer (first, procedure_entry.chain);
				/* might disappear next line */
      bmp = get_breakmap_ptr ();	/* this could zap it */
      if bmp ^= null () then do;
	if ^happy then do;
	    happy = "1"b;		/* this is the first */
	    call ioa_$ioa_switch (probe_info.output_switch,
	         "Breaks set in:");
	  end;
	call ioa_$ioa_switch (probe_info.output_switch,
	     "   ^a>^a$^a",
	     procedure_entry.directory, procedure_entry.entry,
	     procedure_entry.segname);
        end;
    end;				/* loop */

  if ^happy
    then P_code = probe_et_$no_breaks_set;
  return;

  /* entries to reset breaks

   reset_break_at_line
   reset_breaks_in_seg
   reset_breaks_in_world

*/

reset_break_at_line:
  entry (P_probe_info_ptr, P_source_info_ptr, P_break_type, P_long_sw, P_code)
       ;

  probe_info_ptr = P_probe_info_ptr;
  break_source_info_ptr = P_source_info_ptr;
  seginfop = Break_source.seg_info_ptr;
  number = Break_source.stmnt_map_entry_index;
  break_type = P_break_type;
  long_sw = P_long_sw;
  P_code = 0;
  happy = "0"b;

  call probe_seg_mgr_$get_procedure_entry (probe_info_ptr, seginfop, ent, bmp,
       P_code);
  if P_code ^= 0
    then
         return;
  if ent ^= null () & bmp ^= null () then do;
      stp = search_for_stmt (ent, bmp, number);
      if stp ^= null () then do;
	call ensure_writeable ((bmp));
	saved_stp = stp;
	if stp -> statement_item.slots (BREAK_BEFORE) ^= (18)"0"b &
	     (break_type = BREAK_BEFORE | break_type = BREAK_AT) then do;
	    happy = "1"b;
	    call reset_the_break_at (BREAK_BEFORE, long_sw);

	    if breakmap_deleted_sw
	      then go to RESET_DONE;
	  end;
	stp = saved_stp;
	if stp -> statement_item.slots (BREAK_AFTER) ^= (18)"0"b &
	     (break_type = BREAK_AFTER | break_type = BREAK_AT) then do;
	    happy = "1"b;
	    call reset_the_break_at (BREAK_AFTER, long_sw);
	  end;
	if added_w_sw
	  then call restore_readonly ((bmp));
        end;
    end;				/* non -null break map */

RESET_DONE:
  if ^happy
    then P_code = probe_et_$breakless;
  return;

reset_breaks_in_seg:
  entry (P_probe_info_ptr, P_source_info_ptr, P_long_sw, P_code);

  probe_info_ptr = P_probe_info_ptr;
  P_code = 0;
  break_source_info_ptr = P_source_info_ptr;
  seginfop = Break_source.seg_info_ptr;
  happy = "0"b;

  call probe_seg_mgr_$get_procedure_entry (probe_info_ptr, seginfop, ent, bmp,
       P_code);
  if P_code ^= 0
    then
         return;
  if ent ^= null () & bmp ^= null () then do;
      call ensure_writeable ((bmp));
      call reset_all_breaks_in (long_sw,
	 "0"b /*reset all types, not just pauses*/, happy);
      if added_w_sw
        then call restore_readonly ((bmp));
    end;
  if ^happy
    then P_code = probe_et_$no_breaks;
  return;


reset_breaks_in_world:
  entry (P_probe_info_ptr, P_long_sw, P_code);

  probe_info_ptr = P_probe_info_ptr;
  long_sw = P_long_sw;
  pauses_entry_sw = "0"b;
RESET_ALL:
  happy = "0"b;
  code = 0;

  first = probe_seg_mgr_$first_procedure_ptr (probe_info_ptr, code);
  if code ^= 0 then do;
      if ^pauses_entry_sw
        then P_code = code;
      return;
    end;

  if first ^= null ()
    then
      do ent = first repeat next while (rel (ent) ^= (18)"0"b);
      next = pointer (ent, procedure_entry.chain);
      bmp = get_breakmap_ptr ();
      if bmp ^= null ()
        then do;
	call ensure_writeable ((bmp));
	call reset_all_breaks_in (long_sw, pauses_entry_sw, happy);
	if added_w_sw
	  then call restore_readonly ((bmp));
        end;
    end;

  if ^happy & ^pauses_entry_sw
    then P_code = probe_et_$no_breaks_set;
  return;


reset_all_pause_breaks:
  entry (P_probe_info_ptr);

  probe_info_ptr = P_probe_info_ptr;
  long_sw = "0"b;
  pauses_entry_sw = "1"b;

  go to RESET_ALL;

print_instructions:
  entry (P_probe_info_ptr, P_source_info_ptr, P_instruction_ptr, P_len);

  /* Prints the instructions for a given line, without showing the break instruction */

  probe_info_ptr = P_probe_info_ptr;
  break_source_info_ptr = P_source_info_ptr;

  seginfop = Break_source.seg_info_ptr;
  number = Break_source.stmnt_map_entry_index;
  ent, bmp, slot_ptr = null;

  /* Find out if any breaks are set at this line */

  call probe_seg_mgr_$get_procedure_entry (probe_info_ptr, seginfop, ent, bmp,
       0);
  if ent ^= null & bmp ^= null then do;

      stp = search_for_stmt (ent, bmp, number);
      if stp ^= null then do;

	after_sw = "0"b;
	slot_offset = stp -> statement_item.slots (BREAK_BEFORE);
	if slot_offset ^= (18)"0"b
	  then slot_ptr = pointer (stp, slot_offset);
	  else do;
	    after_sw = "1"b;
	    slot_offset = stp -> statement_item.slots (BREAK_AFTER);
	    if slot_offset ^= (18)"0"b
	      then slot_ptr = pointer (stp, slot_offset);
	      else slot_ptr = null;
	  end;
        end;
    end;

  /* If there is one, temporarily replace it with the original instruction */

  if slot_ptr ^= null then do;

      call ensure_writeable ((bmp));

      if after_sw then do;
	instruction_ptr =
	     pointer (P_instruction_ptr,
	     slot_ptr -> break_slot_after.location);
	saved_instruction = instruction_ptr -> based_word;
	instruction_ptr -> based_word =
	     slot_ptr -> break_slot_after.old_instruction;
        end;
        else do;
	instruction_ptr =
	     pointer (P_instruction_ptr,
	     slot_ptr -> break_slot_before.location);
	saved_instruction = instruction_ptr -> based_word;
	instruction_ptr -> based_word =
	     slot_ptr -> break_slot_before.old_instruction;
        end;
    end;

  /* Print the instructions for the statement */

  call print_instructions_ (P_instruction_ptr, P_len,
       probe_info.output_switch);

  /* Now replace the break if necessary */

  if slot_ptr ^= null then do;

      instruction_ptr -> based_word = saved_instruction;

      if added_w_sw
        then call restore_readonly ((bmp));
    end;
  return;


  /* ************************ INTERNAL PROCS ********************* */


list_all_in:
  proc (P_long, P_print, P_exists);


  dcl P_long		bit (1) aligned parameter;
				/* input: include command list? */
  dcl P_print		bit (1) aligned parameter;
  dcl P_exists		bit (1) aligned parameter;

  /* GLOBAL imports: ent, bmp,  and sets stp */

  /* Note that P_exists is SET if we FIND a break, but not cleared if we don't
   although the presence of a procedure entry that has no breaks, yet hasn't been
   garbaged collected is a bit frightening */

  do stp = pointer (bmp, procedure_entry.first_statement)
       repeat pointer (bmp, statement_item.chain)
       while (rel (stp) ^= "0"b);
    if statement_item.slots (BREAK_BEFORE) ^= "0"b
      then do;
        P_exists = "1"b;
        if ^P_print
	then
	     return;
        call display_break (
	   pointer (stp, statement_item.slots (BREAK_BEFORE)), "1"b,
	   (P_long));
      end;
    if statement_item.slots (BREAK_AFTER) ^= "0"b then do;
        P_exists = "1"b;
        if ^P_print
	then
	     return;
        call display_break (pointer (stp, statement_item.slots (BREAK_AFTER)),
	   "1"b, (P_long));
      end;
  end;				/* loop */
  end list_all_in;



display_break:
  proc (P_bsp, P_want_proc_name, P_long);

  dcl P_bsp		ptr parameter;
  dcl P_want_proc_name	bit (1) aligned parameter;
  dcl P_long		bit (1) aligned parameter;

  /* GLOBAL! ent stp  *** used by list_break */

  call ioa_$ioa_switch (probe_info.output_switch,
       "Break exists ^a ^[ :^a^;^s^]",
       formatted_break_line ((ent), (stp), (P_bsp), (P_want_proc_name)),
       P_long, P_bsp -> break_slot.command_list);
  end display_break;

formatted_break_line:
  proc (P_ent, P_stp, P_bsp, P_proc) returns (char (132) varying);

  dcl P_ent		ptr parameter;
  dcl P_stp		ptr parameter;
  dcl P_bsp		ptr parameter;
  dcl P_proc		bit (1) aligned parameter;
  dcl ioa_$rsnnl		entry options (variable);
  dcl linestr		char (132) varying;

  dcl 1 map_array		(map_size) like statement_map based (map_ptr);
  dcl map_size		fixed bin;
  dcl map_ptr		ptr;
  dcl number		fixed bin;
  dcl file		fixed bin;
  dcl line		fixed bin;
  dcl stmt		fixed bin;
  dcl use_this_name           char(32) unaligned;
  

  if (probe_info.language_type ^= C_lang_type) then
    use_this_name = P_ent->procedure_entry.segname;
  else
    use_this_name = P_ent->procedure_entry.entry;

  map_ptr = pointer (P_stp, P_ent -> procedure_entry.statement_map);
  map_size = fixed (P_ent -> procedure_entry.statement_map_size, 24);
  number = P_stp -> statement_item.number;

  if map_ptr ^= null () & number <= map_size then do;
				/* have legit number */
      file = fixed (map_array (number).file, 8);
      line = fixed (map_array (number).line, 14);
      stmt = fixed (map_array (number).statement, 5);

      call ioa_$rsnnl ("^a line ^[^d-^;^s^]^d^[,^d^;^s^]^[ in ^a^;^s^]",
	 linestr, (0),
	 PLACE (P_bsp -> break_slot.type),
	 file > 0, file,
	 line,
	 stmt > 1, stmt,
	 P_proc, use_this_name);
    end;
    else do;
      call ioa_$rsnnl ("^a|^o", linestr, (0),
            use_this_name,
	 fixed (P_bsp -> break_slot.location, 18));
    end;

  return (linestr);
  end formatted_break_line;

create_statement_entry:
  proc (P_ent, P_bmp, P_number) returns (ptr);

  dcl (
      P_ent		ptr,
      P_bmp		ptr,
      P_number		fixed bin
      )			parameter;

  dcl (ent, bmp)		ptr;
  dcl new_stmt		ptr;

  ent = P_ent;
  bmp = P_bmp;

  new_stmt = allocate_in_breakmap (size (statement_item));
  new_stmt -> statement_item.item_type = STATEMENT_ITEM;
  new_stmt -> statement_item.number = P_number;
  new_stmt -> statement_item.slots = (18)"0"b;
  new_stmt -> statement_item.proc_entry = rel (ent);
  new_stmt -> statement_item.identifier = ent -> procedure_entry.time_stamp;
  new_stmt -> statement_item.chain = ent -> procedure_entry.first_statement;

  ent -> procedure_entry.first_statement = rel (new_stmt);
  return (new_stmt);
  end create_statement_entry;



delete_statement_entry:
  proc ();

  /* GLOBAL! bmp ent stp */

  /* unthread the statement and delete it */

  dcl prev		ptr;	/* to statement item before the one to kill */

  if procedure_entry.first_statement = rel (stp)
    then procedure_entry.first_statement = statement_item.chain;
    else do;			/* not first, must search for predecessor */
      do prev = pointer (stp, procedure_entry.first_statement)
	 repeat pointer (prev, prev -> statement_item.chain)
	 while (prev -> statement_item.chain ^= rel (stp));
        if prev -> statement_item.chain = "0"b
				/* NOT FOUND */
	then call probe_error_$malfunction (probe_info_ptr, 0,
		"Break statement item ^p not found on chain of proc entry ^p",
		stp, ent);
      end;			/* search */
      prev -> statement_item.chain = statement_item.chain;
    end;

  call release_in_breakmap ((stp));
  end delete_statement_entry;




search_for_stmt:
  proc (P_ent, P_bmp, P_map_number) returns (ptr);
  dcl (
      P_ent		ptr,
      P_bmp		ptr,
      P_map_number		fixed bin
      )			parameter;

  dcl bmp			ptr;
  dcl map_number		fixed bin;
  dcl p			ptr;

  map_number = P_map_number;
  bmp = P_bmp;
  do p = pointer (bmp, P_ent -> procedure_entry.first_statement)
       repeat (pointer (bmp, p -> statement_item.chain))
       while (rel (p) ^= (18)"0"b);
    if p -> statement_item.number = map_number
      then
	 return (p);
  end;
  return (null ());
  end search_for_stmt;


reset_all_breaks_in:
  proc (P_long, P_pauses_only, P_existed);

  /* GLOBAL imports bmp, stp, ent */

  dcl P_long		bit (1) aligned parameter;
				/* shall we tell of them as they go? */
  dcl P_pauses_only		bit (1) aligned parameter;
				/* ON => reset only breaks set by "step" */
  dcl P_existed		bit (1) aligned parameter;
				/* set, if we find one - should always happen */

  dcl next		ptr;

  do stp = pointer (bmp, procedure_entry.first_statement) repeat next
       while (rel (stp) ^= "0"b);
    next = pointer (stp, statement_item.chain);
    if statement_item.slots (BREAK_BEFORE) ^= "0"b then do;
        saved_stp = stp;
        P_existed = "1"b;
        if ^P_pauses_only | ptr (stp, statement_item.slots (BREAK_BEFORE)) ->
	   break_slot_before.command_list = "pause" || NL
	then /* a break set by "step" */
	     call reset_the_break_at (BREAK_BEFORE, (P_long));

        if breakmap_deleted_sw
	then
	     return;

        stp = saved_stp;
      end;
    if statement_item.slots (BREAK_AFTER) ^= "0"b then do;
        saved_stp = stp;
        P_existed = "1"b;
        if ^P_pauses_only | ptr (stp, statement_item.slots (BREAK_AFTER)) ->
	   break_slot_after.command_list = "pause" || NL
	then /* a break set by "step" */
	     /* (shouldn't be any pause breaks after, but) */
	     call reset_the_break_at (BREAK_AFTER, (P_long));

        if breakmap_deleted_sw
	then
	     return;

        stp = saved_stp;
      end;
  end;				/* stmt loop */
  end reset_all_breaks_in;



reset_the_break_at:
  proc (P_type, P_long);

  dcl P_type		fixed bin parameter;
  dcl P_long		bit (1) aligned parameter;
  dcl other_type		fixed bin;
  dcl breaks_found		bit (1) aligned;

  /* GLOBAL! ent bmp stp */

  /* Remove the break - replace patched TRA **KLUDGE if active**
   Free the break slot
   If statement now empty, then remove it
   if proc now empty, then remove it
   if breakmap now empty, then  remove it

   If message desired, give the message

   Note: in version 3 probe, the garbage collecting was only done
   after an attempt to reset all breaks in a seg.  i suppose that was for efficiency.  In any event,
   it seems like old proc entries were not pruned.  That bug may have its cause elsewhere, tho.
*/
  breakmap_deleted_sw = "0"b;

  if P_long & ^probe_static_info.brief_sw
    then call ioa_$ioa_switch (probe_info.output_switch,
	    "Break reset ^a",
	    formatted_break_line ((ent), (stp),
	    pointer (stp, statement_item.slots (P_type)), "1"b));


  call remove_break ((P_type));

  statement_item.slots (P_type) = "0"b; /* forgotten */

  if P_type = BREAK_BEFORE
    then other_type = BREAK_AFTER;
    else other_type = BREAK_BEFORE;

  if statement_item.slots (other_type) = "0"b
    then call delete_statement_entry ();

  /* Delete the break map if there are no breaks left */

  breaks_found = "0"b;
  call list_all_in (BRIEF, NO_PRINT, breaks_found);
  if ^breaks_found then do;
      breakmap_deleted_sw = "1"b;

      call delete_breakmap ();
    end;


  if procedure_entry.first_statement
       = "0"b /* that was last stmt we just deleted */
    then do;
      call restore_readonly ((bmp));
      call probe_seg_mgr_$delete_procedure_entry (probe_info_ptr, ent, code);
				/* someday, consider macros & symbols */
    end;

  end reset_the_break_at;

remove_break:
  proc (P_type);

  dcl P_type		fixed bin parameter;

  /* GLOBAL bmp, stp */

  /* Unset the break. Unlink the slot. Free its storage.
   it was once thought (judging from the comments) that the way to rese an active break was to set a flag
   somewhere, then call an entry "release_break" to reset the break when continueing.  After that, somebody
   changed probe to kludge the probe data structures so that active breaks could be reset.
   i wonder what happens if the break request list of a break resets the break?????
*/

  dcl p			ptr;
  dcl pi_ptr		ptr;	/* to probe_info in past lives */
  dcl patch_place		ptr;	/* where to reset */
  dcl absp		ptr;	/* to slot to kill */
  dcl strange		bit (1) aligned;

  dcl based_word		bit (36) aligned based;

  absp = pointer (stp, statement_item.slots (P_type));

  if P_type = BREAK_AFTER & statement_item.slots (BREAK_BEFORE) ^= "0"b
    then do;			/* may be "strange" */
      p = pointer (stp, statement_item.slots (BREAK_BEFORE));
				/* pt to break slot for before */
      strange =
	 p -> break_slot_before.location
	 = absp -> break_slot_after.location;
    end;
    else strange = "0"b;

  patch_place = pointer (absp, absp -> break_slot.location);

  if strange then do;
      call relocate_instruction_ (
	 addr (absp -> break_slot_after.moved_instruction),
	 addr (p -> break_slot_before.moved_instruction), (0));
      p -> break_slot_before.old_instruction =
	 absp -> break_slot_after.old_instruction;
      patch_place -> based_word =
	 rel (addr (p -> break_slot_before.sequence)) || TRA_code;
				/* ughh */
    end;
    else patch_place -> based_word = absp -> break_slot.old_instruction;

  /* KLUDGE TIME - search back through all current invocations of probe for any who were invoked using
   this break */

  if P_type = BREAK_AFTER		/* where to return to */
    then patch_place = addrel (patch_place,
				/* instruction after broken one */
	    inst_length_ (addr (absp -> break_slot_after.old_instruction),
	    (0)));

  do pi_ptr = probe_info_ptr
       repeat pi_ptr -> probe_info.listener_info.previous
       while (pi_ptr ^= null ());
    if pi_ptr -> probe_info.break_slot_ptr = absp then do;
        p = pi_ptr -> probe_info.ptr_to_initial_source
	   -> source_info.stack_ptr -> stack_frame.next_sp;
        break_extension_info_ptr = addrel (p, -size (probe_break_extension));
        probe_break_extension.slot_return_addr = patch_place;

        if break_map.version >= 3
	then pi_ptr -> probe_info.real_break_return_loc =
		addr (probe_map_sequence_$return);
	else pi_ptr -> probe_info.real_break_return_loc =
		addr (probe_map_sequence_$old_return);
      end;
  end;				/* loop */

  call release_in_breakmap (absp);
  end remove_break;

create_breakmap:
  proc ();

  /* GLOBAL! seginfop SETS! bmp */

  dcl segp		ptr;	/* to seg in question */
  dcl correction		fixed bin (24);
  dcl bitcount		fixed bin (24);
  dcl wordcount		fixed bin (35);
  dcl obj_map_ptr		ptr;

  dcl 1 last_word_in_seg	aligned based,
       2 map_relp		bit (18) unal,
       2 lower_half		bit (18) unal;
  dcl copy		(copy_count) bit (36) aligned based;
  dcl copy_count		fixed bin;

  dcl hcs_$status_mins	entry (ptr, fixed bin (2), fixed bin (24),
			fixed bin (35));


  segp = seginfop -> seg_info.symbol_header_ptr;
  call hcs_$status_mins (segp, (0), bitcount, code);
  if code ^= 0
    then goto C_LOSS;
  wordcount = divide (bitcount, 36, 35, 0);
  obj_map_ptr =
       pointer (segp,
       pointer (segp, wordcount - 1) -> last_word_in_seg.map_relp);

  bmp = find_breakmap ();

  if bmp ^= null ()
    then
         if break_map.name ^= "breakmap" then do;
	   call probe_error_$record (probe_info_ptr, probe_et_$breaks_exist,
	        seginfop -> seg_info.segname);
	   go to RECORDED_MESSAGE;
	 end;
         else if break_map.version < 3
	 then code = probe_et_$old_break_map;
  if code ^= 0
    then goto C_LOSS;

  if bmp ^= null ()
    then
         return;			/* use existing breakmap */

  /* in theory, we are not called if map already existed, so this might be a bug */

  /* must create it, aligned for ptr */

  wordcount = wordcount + mod (wordcount, 2);
  bmp = pointer (segp, wordcount);

  /* may have to extend max length here */

  break_map.version = 3;
  break_map.name = "breakmap";
  break_map.identifier = seginfop -> seg_info.bound_create_time;
  break_map.symbol_header = rel (seginfop -> seg_info.bound_sym_header);

  /* now copy map_sequence code into break map */

  copy_count = probe_map_sequence_$count;
  addr (break_map.map_sequence) -> copy =
       addr (probe_map_sequence_$code) -> copy;

  wordcount = wordcount + size (break_map) + copy_count - 2;
				/* don't count ptr at end of map */
  wordcount = wordcount + mod (wordcount, 2);
  break_map.initial_word_count = wordcount;
  break_map.word_count = bit (binary (wordcount, 18, 0));

  /* upper bound is set to fill  page exactly */
  wordcount = fill_to_brim ((wordcount));
  break_map.upper_bound = bit (binary (wordcount, 18, 0));

  bitcount = (wordcount + 4) * 36;	/* why the + 4)? */
  call hcs_$set_bc_seg (bmp, bitcount, (0));

  pointer (bmp, binary (break_map.upper_bound, 18, 0) + 3)
       -> last_word_in_seg.map_relp = rel (obj_map_ptr);

  /* in version 3 probe, a pointer to the break_map was kept in the seg_info for
   either the bound_seg as  a whole (or the sole seg_info, for unbound).  But we
   dispense with this as I don't see what use it is (It was used in the break_handler)
*/

  if obj_map_ptr -> object_map.decl_vers = object_map_version_2
    then obj_map_ptr -> object_map.break_map_offset = rel (bmp);
    else obj_map_ptr -> old_object_map.break_map_offset = rel (bmp);
  return;



delete_breakmap:
  entry;

  /* GLOBAL bmp! */


  if addrel (bmp, -1) -> last_word_in_seg.map_relp ^= "0"b
    then correction = 0;
    else correction = -1;		/* break map always begins on even word;
						   must find real last word */
  obj_map_ptr =
       pointer (bmp,
       addrel (bmp, correction - 1) -> last_word_in_seg.map_relp);

  if obj_map_ptr -> object_map.decl_vers = object_map_version_2
    then obj_map_ptr -> object_map.break_map_offset = "0"b;
    else obj_map_ptr -> old_object_map.break_map_offset = "0"b;

  copy_count =
       binary (break_map.word_count, 18, 0) - fixed (rel (bmp), 18, 0) + 4;
  bmp -> copy = "0"b;

  bitcount = (binary (rel (bmp), 24, 0) + correction) * 36;

  call hcs_$set_bc_seg (bmp, bitcount, (0));
  return;

C_LOSS:
  call probe_error_$record (probe_info_ptr, code);
  goto RECORDED_MESSAGE;


find_breakmap:
  proc () returns (ptr);

  if obj_map_ptr -> object_map.identifier ^= "obj_map "
    then code = probe_et_$non_standard;

  else if obj_map_ptr -> object_map.decl_vers = object_map_version_2
    then if obj_map_ptr -> object_map.break_map_offset ^= "0"b
	 then
	      return (
		 pointer (obj_map_ptr,
		 obj_map_ptr -> object_map.break_map_offset));
	 else
	      return (null ());

  else if obj_map_ptr -> object_map.decl_vers = 1
    then if obj_map_ptr -> old_object_map.break_map_offset ^= "0"b
	 then
	      return (
		 pointer (obj_map_ptr,
		 obj_map_ptr -> old_object_map.break_map_offset));
	 else
	      return (null ());

  else code = probe_et_$non_standard;
  return (null ());

  end find_breakmap;

  end create_breakmap;		/* and delete_breakmap */



get_breakmap_ptr:
  proc returns (ptr);

  /* GLOBAL! imports ent */

  dcl hcs_$initiate		entry (char (*), char (*), char (*),
			fixed bin (1), fixed bin (2), ptr,
			fixed bin (35));
  dcl hcs_$terminate_noname	entry (ptr, fixed bin (35));

  dcl segp		ptr;


  call hcs_$initiate (procedure_entry.directory, procedure_entry.entry, "", 0,
       0, segp, (0));

  if segp ^= null () then do;		/* still exists, but may be modified */
      segp = pointer (segp, procedure_entry.break_map);
				/* look where map is spozed to be */
      if segp -> break_map.identifier = procedure_entry.time_stamp
        then
	   return (segp);
        else call hcs_$terminate_noname (segp, (0));
    end;

  /* either seg no longer exists, or has been recompiled.
   In either case, the procedure entry is obsolete and should be destroyed */

  call probe_seg_mgr_$delete_procedure_entry (probe_info_ptr, (ent), (0));

  return (null ());
  end get_breakmap_ptr;

ensure_writeable:
  proc (segptr);

  dcl segptr		ptr parameter;
				/* to the seg in question */

  dcl hcs_$fs_get_mode	entry (ptr, fixed bin (5), fixed bin (35));

  dcl mode		fixed bin (5);


  call hcs_$fs_get_mode (segptr, mode, code);
  if code ^= 0
    then goto ACL_LOSS;

  if divide (mode, 2, 17, 0) < 7 /* we don't have rew */
    then do;
      added_w_sw = "1"b;
      call hcs_$fs_get_path_name (segptr, acl_dn, (0), acl_en, code);
      if code ^= 0 then do;
ACL_LOSS:
	call probe_error_$record (probe_info_ptr, code);
	go to RECORDED_MESSAGE;
        end;

      acl_count = 1;
      seg_acl.access_name = get_group_id_ ();
      seg_acl.modes, seg_acl.zero_pad = "0"b;

      call hcs_$list_acl (acl_dn, acl_en, null, null, addr (seg_acl), 1, code)
	 ;
      if seg_acl (1).status_code ^= 0
        then saved_mode_sw = "0"b;
        else do;
	saved_mode_sw = "1"b;
	saved_mode = substr (seg_acl (1).modes, 1, 3);
        end;

      call set_access ("111"b);	/* force rew */
    end;

    else added_w_sw = "0"b;
  return;


restore_readonly:
  entry (segptr);


  if added_w_sw
    then
         if saved_mode_sw
	 then call set_access (saved_mode);
	 else call hcs_$delete_acl_entries (acl_dn, acl_en, addr (seg_acl),
		 1, 0);
				/* if there was no term for group_id, delete the added one */
  return;


set_access:
  proc (new_mode);

  dcl new_mode		bit (3) parameter;

  seg_acl.modes = new_mode;

  call hcs_$add_acl_entries (acl_dn, acl_en, addr (seg_acl), 1, code);
  if code ^= 0
    then goto ACL_LOSS;
  end set_access;

  end;				/* ensure_writeable */





fill_to_brim:
  proc (wordct) returns (fixed bin (35));

  /* given word ct, get next highest word ct that uses its pages to the max. */

  dcl wordct		fixed bin (35) parameter;
  dcl wordtp		fixed bin (35);

  wordtp = wordct + 1023;		/* make next higher word ct */
  wordtp = divide (wordtp, 1024, 0);	/* number of pages */
  wordtp = multiply (wordtp, 1024, 35, 0);
				/* restore word ct */
  wordtp = subtract (wordtp, 4, 35, 0); /* dont know why */

  return (wordtp);
  end fill_to_brim;

allocate_in_breakmap:
  procedure (required) returns (pointer);

  dcl required		fixed bin parameter;
				/* number of words needed */

  dcl needed		fixed bin;/* 0 mod 2 size */
  dcl fip			pointer;
  dcl lfip		pointer;
  dcl word		bit (36) based;

  needed = required + mod (required, 2);/* 0 mod 2 size */
  lfip = null ();
  do fip = pointer (bmp, break_map.first_free_item)
       repeat pointer (fip, fip -> free_item.chain)
       while (rel (fip) ^= (18)"0"b);

    /* search for a free item that can contain the allocation */

    if fip -> free_item.size >= needed then do;
				/* this one will work */
        if fip -> free_item.size = needed then do;
				/* occupies entire area */
	  if lfip ^= null ()
	    then
	         lfip -> free_item.chain = fip -> free_item.chain;
				/* skip this one */
	    else break_map.first_free_item = fip -> free_item.chain;
	end;
	else do;			/* only uses part, let rest remain free */
	  fip -> free_item.size = fip -> free_item.size - needed;
	  fip = addrel (fip, fip -> free_item.size);
				/* use top part */
	end;
        fip -> item.size = needed;	/* fill in for freeing */
        return (fip);
      end;

    lfip = fip;
  end;				/* of loop through chain */

  /* if we get here, weither there were no free areas, or there were none large enough, in
   either case, allocate the space at the end of the segment */

  fip = pointer (bmp, break_map.word_count);
  fip -> item.size = needed;
  break_map.word_count =
       bit (add (binary (break_map.word_count, 18, 0), needed, 18, 0));

  /* must check if this allocation has overflowed the area, if so we will extend it */

  if break_map.word_count > break_map.upper_bound then do;
      break_map.upper_bound =
	 bit (
	 subtract (
	 multiply (divide (add (binary (break_map.word_count, 18, 0),
	 1023, 18, 0), 1024, 18, 0), 1024, 18, 0), 4, 18, 0));

      call hcs_$set_bc_seg (bmp,
	 multiply (binary (break_map.upper_bound, 18, 0) + 4, 36, 24, 0),
	 (0));
				/* an error here will only cause move problems */
      addrel (pointer (bmp, break_map.upper_bound), 3) -> word =
	 addrel (bmp, -1) -> word;
    end;
  return (fip);
  end allocate_in_breakmap;


release_in_breakmap:
  procedure (item_pointer);

  dcl item_pointer		pointer,	/* pointer to the item itself */
      ip			pointer,	/* working copies of the above */
      i			fixed bin (35),
				/* offset of item */
      (p, lp)		pointer;
  dcl copy_overlay		(copy_count) bit (36) aligned based;
				/* for zeroing */
  dcl copy_count		fixed bin;


  ip = item_pointer;		/* copy pointers */
  i = binary (rel (ip), 18, 0);

  /* first check if item is at the end of the segment */

  if i + ip -> item.size
       = binary (break_map.word_count, 18, 0) /* it is at the end */
    then do;
      break_map.word_count = rel (ip);
      copy_count = ip -> item.size;
      ip -> copy_overlay = "0"b;	/* zero out words at the end of a segment */

      lp = null ();
      do p = pointer (bmp, break_map.first_free_item)
	 repeat pointer (p, p -> free_item.chain)
	 while (rel (p) ^= (18)"0"b); /*  see if this leaves one at the end of the area */

        if addrel (p, p -> free_item.size) = ip then do;
				/* this one is at the end, so remove it */
	  break_map.word_count = rel (p);
				/* new length */
	  if lp ^= null ()		/* remove form chain */
	    then lp -> free_item.chain = (18)"0"b;
				/* as items are order, this is the last */
	    else break_map.first_free_item = (18)"0"b;
	  copy_count = p -> free_item.size;
				/* zero it out */
	  p -> copy_overlay = "0"b;
	  return;
	end;

      end;
      return;
    end;

  /* no, free it within the area */

  if break_map.first_free_item then do; /* if this is not the only one, we will have to
						   check if it is contguous with the others */
      lp = null ();
      do p = pointer (bmp, break_map.first_free_item)
	 repeat pointer (p, p -> free_item.chain);
				/* termination condition checked below */

        if i < binary (rel (p), 18, 0) then do;
				/* the item goes here */
	  if lp ^= null /* if there is a previous item look at it */
	    then do;
	      if addrel (lp, lp -> free_item.size)
		 = ip /* last one and new one touch */
	        then do;
		lp -> free_item.size =
		     lp -> free_item.size + ip -> item.size;
		ip = lp;		/* we are now interested in the combination */
	        end;
	        else do;
		ip -> free_item.size = ip -> item.size;
		lp -> free_item.chain = rel (ip);
	        end;
	    end;
	    else do;
	      ip -> free_item.size = ip -> item.size;
	      break_map.first_free_item = rel (ip);
	    end;

	  if addrel (ip, ip -> free_item.size)
	       = p /* the new one and the next one touch */
	    then do;
	      ip -> free_item.size =
		 ip -> free_item.size + p -> free_item.size;
	      ip -> free_item.chain = p -> free_item.chain;
	    end;
	    else do;
	      ip -> free_item.chain = rel (p);
	    end;
	  return;			/* all done */
	end;

        if p -> free_item.chain
	   = (18)"0"b /* if this is the end of the chain, put it here */
	then do;
	  if addrel (p, p -> free_item.size) = ip
	    then p -> free_item.size =
		    p -> free_item.size + ip -> item.size;
	    else do;
	      ip -> free_item.size = ip -> item.size;
	      ip -> free_item.chain = (18)"0"b;
	      p -> free_item.chain = rel (ip);
	    end;
	  return;
	end;

      end;			/* of search through free chain */

    end;

  /* first free_item, start the chain */

  break_map.first_free_item = rel (ip);
  ip -> free_item.chain = (18)"0"b;
  ip -> free_item.size = ip -> item.size;
  return;

  end release_in_breakmap;

  /* * 			***** DATA STRUCTURES USED IN BREAKS *****

   (also see the probe implementation guide)

   the probe seg (or the break seg) it is in user's homedir and is named [user name].probe

   the object seg containing a break has a section called the breakmap - this begins
   with a breakmap header.  It is impure object segment.  Only one user may probe (or debug)
   segment at a time - the results of more than one user attempting to write
   are undefined

   The break seg begins with a break segment header, which contains the offsets (relative to base of the seg)
   of the first item of each of the following types:

   PROCEDURE -  a procedure entry describes an object seg that has breaks in it
   FREE	  - a free item is just some free storage
   SYMBOL	  - unused today, someday use to hold probe "variables" maybe
   MACRO	  - unused today, someday can hold request list for probe "macros" maybe

   Note that we do our own allocation and garbage-collection in the probe seg and in the break_map
   There is no good reason for this! (other than history)  if there were more time, I'd convert them
   both to be areas.

   In the break map we   have the break map header, and the statement entries (one for each line that has a break)
   and the break_slots (one for each break).  The last portion of the break_map_header is the "map_sequence",
   which is object code executed to cause a break.  It is extraordinarily hirsute!

   Statement_items are chained together.  The offset of the first is stored in the corresponding
   procedure entry in the probe seg.    A statement item has (among other things) the index into the
   statement_map array for the line it represents, an offset to the procedure entry it is part of
   (relative to the base of the probe_seg), and the offsets (relative to the base of the object seg) of
   the break_slots for the breaks before or after its line.

   A break_slot consists of per-break information.  The break request list is stored here
   (actual characters).  Also the relocated instruction from where the break was.

   Breaks are implemented as a "tra" to a break_slot.  There are eight words of executable code
   in each break_slot.  The "map_sequence" referred to above is the common code for each type of break.
   The code in "sequence" for each type of break is:

   * before:  spri	sp|stack_frame.next_sp,*	after:    <instruction>
   * 	  tsplb	map_sequence			nop	0,du
   * 	  nop	slot,du				nop	0,du
   * 	  <instruction>				nop	0,du
   * 	  nop	0,du				spri	sp|stack_frame.next_sp,*
   * 	  nop	0,du				tsplb	map_sequence
   * 	  nop	0,du				nop	slot,du
   * 	  tra	old_loc+il			tra	old_loc+il


   Certain of these instructions are "patched" when the break_slot is created:
   The offset of the map_sequence, and the location in the object segment to return to.
   The offset of the break_slot is saved in a "nop" instruction, where the map_sequence code   can get it.
   The instruction in the object seg is relocated into the break_slot, along with its descriptors if any.
   The instruction is replaced by a "tra" to the sequence in the break slot.

*/

%include probe_info;
%include probe_static_info;
%include probe_lang_types;
%include probe_source_info;
%include probe_seg_info;
%include probe_break_slot;
%include probe_break_extension;
%include probe_break_info;
%include object_map;
%include probe_old_object_map;
%include acls;
%include statement_map;
%include stack_frame;

  end probe_break_mgr_;
