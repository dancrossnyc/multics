/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(86-10-02,TLNguyen), approve(86-10-23,MCR7555),
     audit(86-10-29,GWMay), install(86-10-29,MR12.0-1201):
     Modified  all IACL commands to correctly process a directory type
     and omit or reject non-directory types.
  2) change(87-08-21,TLNguyen), approve(87-08-21,MCR7755),
     audit(87-09-08,Lippard), install(87-12-07,MR12.2-1009):
     Change the list_accessible and list_not_accessible to work with the ROOT
     directory.
  3) change(87-08-27,TLNguyen), approve(87-08-27,MCR7757),
     audit(87-09-08,Lippard), install(87-12-07,MR12.2-1009):
     Change list_acl command to return error_table_$noentry for a non-existent
     target of a link.
  4) change(87-08-27,TLNguyen), approve(87-08-27,MCR7763),
     audit(87-09-08,Lippard), install(87-12-07,MR12.2-1009):
     Change acl_commands_.pl1 to display a correct error message when
     -directory or -segment control arguments is specified for IACL commands.
  5) change(88-03-01,Lippard), approve(88-03-28,MCR7869),
     audit(88-04-26,Parisek), install(88-05-03,MR12.2-1044):
     Modified to give more informative error message when inconsistent
     ACL modes are specified.
  6) change(88-09-20,TLNguyen), approve(88-09-20,MCR7983),
     audit(88-10-03,Parisek), install(88-10-06,MR12.2-1134):
     Change the list_acl command to print out the pathname in the error
     message when the ACL list is empty.
                                                   END HISTORY COMMENTS */


/* format: style3,linecom,ifthenstmt,ifthendo,ifthen,^indnoniterdo,indnoniterend,indcomtxt,^inditerdo,indend,idind30 */
acl_commands_:
     procedure () options (variable);

/*^*      ACL COMMANDS -- completely rewritten, 1/28/83 Jay Pattin
   *	Fixed set_acl to work on DM files (if ^xacl_allowed & si.type_name ^= "DM file") 06/06/83 S. Herbst
   *      Added lac and lnac 8/27/83 Jay Pattin
   *      Updated for fs_util_, 2 October 1983, W. Olin Sibert
   *      Modified to prevent freeing of same block twice through 2 separate pointers, 1984.01.25, MAP
   *	Modified to use Person.*.* for default mbx acls, instead of Person.Project.*, 1984.02.02, MAP
   *      Modified to check for mbx type from suffix as well as from invocation method, 1984.02.02, MAP
   *	Modified to use fs_util_ object type instead of hcs_ entry type, 1984.02.17, MAP
   *	Modified to set ACL on non-standard object only if given suffix is nt starname, 1984.03.12, MAP
   *	Modified to report "Empty ACL" when original ACL count = 0, 1984.03.12, MAP
   *	Modified to not delete *.SysDaemon.* for da foo -all, 1984.10.24, MAP
   *	Modified to delete *.SysDaemon.* when explicitly instructed to do so.
   *        Also to give error message if -sysdaemon or -no_sysdaemon is used
   *        without -replace.  Also to fix bugs with implementation of -slet;
   *	  And to use the raw acl of extended entries for reporting acls
   *	  when -inase is used.   1/14/85, M. Sharpe.
   *	Modified star name processing when more than one entry type is
   *	  requested.  3/13/85, M.Sharpe.
   */

  /*	This procedure implements all the ACL setting, changing, deleting, and listing
   *	commands for Multics. It includes the following commands, listed in the order
   *	in which they appear in the code:

   NAME		ALTERNATE NAMES		ACL TYPE		PRIVILEGE

   set_acl	setacl, sa		branch		normal
   l_set_acl	lset_acl, lsetacl, lsa	branch		library
   hp_set_acl	hpsetacl, hpsa		branch		hphcs

   delete_acl	deleteacl, da		branch		normal
   l_delete_acl	ldelete_acl, ldeleteacl, lda	branch		library
   hp_delete_acl	hpdeleteacl, hpda		branch		hphcs

   ms_set_acl		mssa		message segment	normal
   mbx_set_acl		mbsa		mailbox		normal
   ms_delete_acl		msda		message segment	normal
   mbx_delete_acl		mbda		mailbox		normal

   set_iacl_seg		sis		segment iacl	normal
   set_iacl_dir		sid		directory iacl	normal
   delete_iacl_seg		dis		segment iacl	normal
   delete_iacl_dir		did		directory iacl	normal

   list_acl		listacl, la	branch acl	normal
   list_iacl_seg		lis		segment iacl	normal
   list_iacl_dir		lid		directory iacl	normal

   ms_list_acl		msla		message segment	normal
   mbx_list_acl		mbla		mailbox		normal

   and poor, unrelated list_accessible and list_not_accessible */

/**/

/* format: off */

declare   error_table_$action_not_performed fixed bin (35) external static;
declare   error_table_$active_function  fixed bin (35) external static;
declare   error_table_$bad_conversion   fixed bin (35) external static;
declare   error_table_$bad_name         fixed bin (35) external static;
declare   error_table_$bad_ring_brackets fixed bin (35) external static;
declare   error_table_$badopt           fixed bin (35) external static;
declare   error_table_$inconsistent     fixed bin (35) external static;
declare   error_table_$noarg            fixed bin (35) external static;
declare   error_table_$noentry          fixed bin (35) external static;
declare   error_table_$nomatch          fixed bin (35) external static;
declare   error_table_$nostars          fixed bin (35) external static;
declare   error_table_$notadir          fixed bin (35) external static;
declare   error_table_$not_seg_type     fixed bin (35) external static;
declare   error_table_$root             fixed bin (35) external static;
declare   error_table_$unsupported_operation fixed bin (35) external static;
declare   error_table_$user_not_found   fixed bin (35) external static;

declare   active_fnc_err_               entry options (variable);
declare   check_star_name_$entry        entry (char (*), fixed bin (35));
declare   com_err_                      entry options (variable);
declare   convert_authorization_$to_string_short
                                        entry (bit (72) aligned, char (*), fixed bin (35));
declare   cu_$af_return_arg_rel         entry (fixed bin, pointer, fixed bin (21), fixed bin (35), pointer);
declare   cu_$arg_list_ptr              entry (pointer);
declare   cu_$arg_ptr_rel               entry (fixed bin, pointer, fixed bin (21), fixed bin (35), pointer);
declare   cu_$generate_call             entry (entry, pointer);
declare   cu_$level_get                 entry (fixed bin (3));
declare   cv_acl_type_$create           entry (pointer, fixed bin, pointer, char (32), char (32), pointer);
declare   expand_pathname_$add_suffix   entry (char (*), char (*), char (*), char (*), fixed bin (35));
declare   get_group_id_$tag_star        entry returns (char (32));
declare   get_system_free_area_         entry returns (ptr);
declare   get_wdir_                     entry returns (char (168));
declare   hcs_$get_access_class         entry (char (*), char (*), bit (72) aligned, fixed bin (35));
declare   hcs_$get_dir_ring_brackets    entry (char (*), char (*), (2) fixed bin (3), fixed bin (35));
declare   hcs_$get_ring_brackets        entry (char (*), char (*), (*) fixed bin (3), fixed bin (35));
declare   hcs_$star_                    entry (char (*), char (*), fixed bin (2), ptr, fixed bin, ptr, ptr, fixed bin (35));
declare   hcs_$status_minf              entry (char (*), char (*), fixed bin (1),
                                        fixed bin (2), fixed bin (24), fixed bin (35));
declare   ioa_                          entry options (variable);
declare	match_star_name_		entry (char(*), char(*), fixed bin(35));
declare   msf_manager_$close            entry (ptr);
declare   msf_manager_$open             entry (char (*), char (*), ptr, fixed bin (35));
declare   pathname_                     entry (char (*), char (*)) returns (char (168));

declare   fs_util_$get_ring_brackets    entry (char (*), char (*), (*) fixed bin (3), fixed bin (35));
declare   fs_util_$make_entry_for_type  entry (char (*), char (*), entry, fixed bin (35));
declare   fs_util_$suffix_info          entry (char (*), char (*), ptr, fixed bin (35));
declare   fs_util_$suffix_info_for_type entry (char (*), ptr, fixed bin (35));

declare   hcs_$get_user_access_modes    entry (char (*), char (*), char (*), fixed bin,
                                        bit (36) aligned, bit (36) aligned, fixed bin (35));
declare   fs_util_$get_user_access_modes entry (char (*), char (*), char (*), fixed bin,
                                        bit (36) aligned, bit (36) aligned, fixed bin (35));

declare   fs_util_$list_acl             entry (char (*), char (*), char (*), pointer, pointer, fixed bin (35));

declare   hcs_$list_inacl               entry (char (*), char (*), ptr, ptr, ptr, fixed bin, fixed bin (3), fixed bin (35));
declare   hcs_$list_dir_inacl           entry (char (*), char (*), ptr, ptr, ptr, fixed bin, fixed bin (3), fixed bin (35));

declare   hcs_$replace_dir_acl          entry (char (*), char (*), pointer, fixed bin, bit (1) aligned, fixed bin (35));
declare   hcs_$replace_acl              entry (char (*), char (*), pointer, fixed bin, bit (1) aligned, fixed bin (35));
declare   hphcs_$replace_acl            entry (char (*), char (*), pointer, fixed bin, bit (1) aligned, fixed bin (35));
declare   hphcs_$replace_dir_acl        entry (char (*), char (*), pointer, fixed bin, bit (1) aligned, fixed bin (35));
declare   installation_tools_$replace_acl entry (char (*), char (*), pointer, fixed bin, bit (1) aligned, fixed bin (35));
declare   installation_tools_$replace_dir_acl
                                         entry (char (*), char (*), pointer, fixed bin, bit (1) aligned, fixed bin (35));
declare   fs_util_$replace_acl           entry (char (*), char (*), pointer, bit (1) aligned, fixed bin (35));

declare   hcs_$replace_inacl            entry (char (*), char (*),
                                        pointer, fixed bin, bit (1) aligned, fixed bin (3), fixed bin (35));
declare   hcs_$replace_dir_inacl        entry (char (*), char (*),
                                        pointer, fixed bin, bit (1) aligned, fixed bin (3), fixed bin (35));

declare  (cleanup, linkage_error)       condition;

declare  (abs, addr, after, before, char, copy, divide, index, length, max,
	null, reverse, rtrim, search, string, substr, sum, unspec, verify)
                                        builtin;

/*  */

declare   ON                            init ("1"b) bit (1) aligned internal static options (constant);
declare   OFF                           init ("0"b) bit (1) aligned internal static options (constant);

declare   DIRECTORY                     init (2) fixed bin (2) internal static options (constant);
/* Possible values for the type parameter */

declare   BRANCH_ACL                    init (101) fixed bin (10) internal static options (constant);
declare   MSEG_ACL                      init (102) fixed bin (10) internal static options (constant);
declare   MBX_ACL                       init (103) fixed bin (10) internal static options (constant);
declare   SEGMENT_IACL                  init (104) fixed bin (10) internal static options (constant);
declare   DIRECTORY_IACL                init (105) fixed bin (10) internal static options (constant);

/* Possible values for the operation parameter */

declare   LIST                          init (201) fixed bin (11) internal static options (constant);
declare   SET                           init (202) fixed bin (11) internal static options (constant);
declare   DELETE                        init (203) fixed bin (11) internal static options (constant);
declare   ACCESSIBLE                    init (204) fixed bin (11) internal static options (constant);

/* Possible values for the privilege parameter */

declare   NORMAL                        init (301) fixed bin (12) internal static options (constant);
declare   LIBRARY                       init (302) fixed bin (12) internal static options (constant);
declare   HPHCS                         init (303) fixed bin (12) internal static options (constant);

/*  */

/* Now, the entrypoints. Each one calls the common procedure to get its work done, and exits by goto ACL_COMMANDS_RETURN */

ACL_COMMANDS_RETURN:                                        /* This is the only return statement in this program. */
          return;                                           /* The "common" procedure always exits by a goto to here */


set_acl:   setacl:    sa:                                   /* Normal, unprivileged, user ACL setting command */
     entry () options (variable);
          call common ("set_acl", BRANCH_ACL, SET, NORMAL);

l_set_acl:   lset_acl:   lsetacl:   lsa:                    /* Ring 1, privileged entry for library maintenance */
     entry () options (variable);
          call common ("l_set_acl", BRANCH_ACL, SET, LIBRARY);

hp_set_acl:   hpsetacl:   hpsa:                             /* Ring 0, highly privileged entry for systems programmers */
     entry () options (variable);
          call common ("hp_set_acl", BRANCH_ACL, SET, HPHCS);

delete_acl:   deleteacl:   da:                              /* Normal, unprivileged, user ACL deletion command */
     entry () options (variable);
          call common ("delete_acl", BRANCH_ACL, DELETE, NORMAL);

l_delete_acl:   ldelete_acl:   ldeleteacl:   lda:           /* Ring 1, privileged entry for library maintenance */
     entry () options (variable);
          call common ("l_delete_acl", BRANCH_ACL, DELETE, LIBRARY);

hp_delete_acl:   hpdeleteacl:   hpda:                       /* Ring 0, highly privileged entry for systems programmers */
     entry () options (variable);
          call common ("hp_delete_acl", BRANCH_ACL, DELETE, HPHCS);

ms_set_acl:   mssa:                                         /* User command for setting message segment ACLs */
     entry () options (variable);
          call common ("ms_set_acl", MSEG_ACL, SET, NORMAL);

mbx_set_acl:   mbsa:                                        /* User command for setting mailbox ACLs */
     entry () options (variable);
          call common ("mbx_set_acl", MBX_ACL, SET, NORMAL);

ms_delete_acl:   msda:                                      /* User command for deleting message segment ACLs */
     entry () options (variable);
          call common ("ms_delete_acl", MSEG_ACL, DELETE, NORMAL);

mbx_delete_acl:   mbda:                                     /* User command for deleting mailbox ACLs */
     entry () options (variable);
          call common ("mbx_delete_acl", MBX_ACL, DELETE, NORMAL);

set_iacl_seg:   sis:                                        /* Nonprivileged user command for setting segment IACLs */
     entry () options (variable);
          call common ("set_iacl_seg", SEGMENT_IACL, SET, NORMAL);

delete_iacl_seg:   dis:                                     /* Nonprivileged user command for deleting segment IACLs */
     entry () options (variable);
          call common ("delete_iacl_seg", SEGMENT_IACL, DELETE, NORMAL);

set_iacl_dir:   sid:                                        /* Nonprivileged user command for setting directory IACLs */
     entry () options (variable);
          call common ("set_iacl_dir", DIRECTORY_IACL, SET, NORMAL);

delete_iacl_dir:   did:                                     /* Nonprivileged user command for deleting directory IACLs */
     entry () options (variable);
          call common ("delete_iacl_dir", DIRECTORY_IACL, DELETE, NORMAL);

list_acl:   listacl:   la:                                  /* User command for listing ACLs */
     entry () options (variable);
          call common ("list_acl", BRANCH_ACL, LIST, NORMAL);

list_iacl_seg:   lis:                                       /* User command for listing segment IACLs */
     entry () options (variable);
          call common ("list_iacl_seg", SEGMENT_IACL, LIST, NORMAL);

list_iacl_dir:   lid:                                       /* User command for listing directory IACLs */
     entry () options (variable);
          call common ("list_iacl_dir", DIRECTORY_IACL, LIST, NORMAL);

ms_list_acl:   msla:                                        /* User command for listing message segment ACLs */
     entry () options (variable);
          call common ("ms_list_acl", MSEG_ACL, LIST, NORMAL);

mbx_list_acl:   mbla:                                       /* User command for listing mailbox ACLs */
     entry () options (variable);
          call common ("mbx_list_acl", MBX_ACL, LIST, NORMAL);

list_accessible:   lac:                                     /* User command for locating accessable objects */
     entry options (variable);
          call common ("list_accessible", BRANCH_ACL, ACCESSIBLE, NORMAL);

list_not_accessible:   lnac:                                /* User command for locating inaccessable objects */
     entry options (variable);
          call common ("list_not_accessible", BRANCH_ACL, ACCESSIBLE, NORMAL);

/*  */

common:
     procedure (P_whoami, P_type, P_operation, P_privilege);

/* In case anyone is wondering why the peculiar precisions, it's in order to ensure that calls to "common"
   are made with the right arguments in the right places: putting a type constant in the operation slot,
   for instance, will generate a warning about incompatible datatypes. */

declare   P_whoami                      char (32) parameter;          /* Command name */
declare   P_type                        fixed bin (10) parameter;     /* Type of ACL to operate on; see constants above */
declare   P_operation                   fixed bin (11) parameter;     /* Which operation to perform */
declare   P_privilege                   fixed bin (12) parameter;     /* What level of privilege to assume */

declare   arg_list_ptr                  pointer;

/* Yes, and if anyone is wondering about this, too, it's an awkward dodge to ensure that
   the arg_list_ptr gets set properly so that the internal procedures can use it. In order
   to ensure this, though, the call to cu_$arg_list_ptr has to appear in a quick block
   immediately contained in the outer block. This is true of "common", but not of
   "nonquick_common", because it, as the procedure which really does the work, it has
   to set up a cleanup handler and do various other things that force it to be non-quick.
   So, there's this first quick procedure which is called by all the entrypoints, and
   all it does is get the argument list and call the non-quick one (which inherits all the
   type and operation parameters from this one, its parent). */

          call cu_$arg_list_ptr (arg_list_ptr);

          call nonquick_common (arg_list_ptr);

/* There is only one return statement in nonquick_common: it gets us here, and this goto gets us out completely */

          goto ACL_COMMANDS_RETURN;

/*  */

nonquick_common:
     procedure (P_arg_list_ptr);

declare   P_arg_list_ptr                pointer parameter;            /* Used to reference command-line arguments */

declare   whoami                        char (32);
declare   type                          fixed bin (10);
declare   operation                     fixed bin (11);
declare   privilege                     fixed bin (12);

declare   system_area_ptr               ptr;
declare   system_area                   area based (system_area_ptr);

declare   code                          fixed bin (35);

declare   ret_str_ptr                   ptr;
declare   ret_str_lth                   fixed bin (21);
declare   ret_str                       char (ret_str_lth) varying based (ret_str_ptr);

declare   entry_type_count		fixed bin;
declare   entry_type_ptr		ptr;
declare	1 entry_type		aligned based (entry_type_ptr),
	2 count			fixed bin,
	2 suffixes		dim (entry_type_count refer (entry_type.count)),
	3 suffix			char (32),
	3 is_std_type		bit (1);

declare	star_match_ptr		ptr;
declare   star_name_count		fixed bin;
declare   star_match		dim (star_name_count) bit (1)
				unaligned based (star_match_ptr);

declare   dname                         char (168);
declare   ename                         char (32);
declare   hcs_type			fixed bin (2);
declare   object_type                   char (32);
declare 1 si                            aligned like suffix_info;
declare 1 type_info			aligned like suffix_info;

declare   access_class                  bit (72) aligned;
declare   access_name                   char (32);
declare   acl_mask                      bit (36) aligned;
declare   buffer                        char (256);
declare   bit_count                     fixed bin (24);
declare   err_path                      char (168);
declare   iacl_ring                     fixed bin (3);
declare   pathname                      char (204);
declare   star_entry_idx                fixed bin;
declare	star_name_idx		fixed bin;
declare	do_tedious_star		bit (1) aligned;
declare   star_sw                       bit (1) aligned;
declare   xacl_allowed                  bit (1) aligned;
declare   limit_entry_types		bit (1) aligned;

/* The acl_modes and acl_names structures contain the character string modes and names specified
   on the command line. The old_acl, new_acl, and used_bits structures are used when building
   a new ACL for listing, setting, or deleting. They are declared here for ease of cleanup.
   original_count is used by build_new_acl and list_the_acl, and must be delcared external to both. */

declare   acl_names_ptr                 pointer init (null ()); /* Various things checked in the cleanup handler */
declare   acl_modes_ptr                 pointer init (null ());
declare   old_acl_ptr                   pointer init (null ());
declare   new_acl_ptr                   pointer init (null ());
declare   other_acl_ptr                 pointer init (null ()); /* Points to other-format ACL for operation (if any) */
declare   used_bits_ptr                 pointer init (null ());
declare   fcb_ptr                       pointer init (null ()); /* Used if current object is an MSF */

declare   n_acl_names                   fixed bin;
declare   max_acl_names                 fixed bin;
declare   acl_names (max_acl_names)     char (32) unaligned based (acl_names_ptr);

declare   n_acl_modes                   fixed bin;
declare   max_acl_modes                 fixed bin;
declare   acl_modes (max_acl_modes)     char (36) unaligned based (acl_modes_ptr);

declare 1 old_acl                       aligned like general_acl based (old_acl_ptr);
declare 1 new_acl                       aligned like general_acl based (new_acl_ptr);

declare	original_count		fixed bin;
declare   used_bits_count               fixed bin;
declare   used_bits (used_bits_count)   bit (1) unaligned based (used_bits_ptr);

declare   empty_acl_overlay (4)         fixed bin (71);     /* Used for easier manuipulation of empty ACLs */


declare   af_sw                         bit (1) aligned init ("0"b);
declare   chase_sw                      bit (1) aligned init ("0"b);
declare   no_chase_sw                   bit (1) aligned init ("0"b);
declare   brief_sw                      bit (1) aligned init ("0"b);
declare   replace_sw                    bit (1) aligned init ("0"b);
declare   ring_bracket_sw               bit (1) aligned init ("0"b);
declare   access_class_sw               bit (1) aligned init ("0"b);
declare   all_sw                        bit (1) aligned init ("0"b);
declare   force_no_type                 bit (1) aligned init ("0"b);
declare   iacl_sw                       bit (1) aligned init ("0"b);
declare   no_sysdaemon_sw               bit (1) aligned init ("0"b);
declare   segment_sw                    bit (1) aligned init ("0"b);
declare   directory_sw                  bit (1) aligned init ("0"b);
declare   starname_suffix	          bit (1) aligned init ("0"b);
declare   matched_sw                    bit (1) aligned init ("0"b);
declare   accessible                    bit (1) aligned init ("0"b);
declare   use_access_modes              bit (1) aligned init ("0"b);
declare	explicit_dr_arg		bit (1) aligned init ("0"b);
declare   explicit_sm_arg		bit (1) aligned init ("0"b);

/*  */

/* format: on */
	whoami = P_whoami;
	type = P_type;
	operation = P_operation;
	privilege = P_privilege;

/* flag those command interfaces that are going away soon... */

	if (type = MBX_ACL) | (type = MSEG_ACL)
	then call ioa_ ("Warning: the ^a command is obsolete and will be deleted next release.^/In the future, please use the ^a command to perform its operation.^/",
	     whoami, after (whoami, "_"));

	if (operation = ACCESSIBLE) then accessible = (whoami = "list_accessible");

	system_area_ptr = get_system_free_area_ ();
	star_names_ptr = null ();			/* Initialize variables declared in include files */
	star_entry_ptr = null ();			/* Our own have init clauses, above */
	acl_ptr = null ();

	limit_entry_types = "0"b;
	star_match_ptr = null ();

	on condition (cleanup) call cleanup_handler ();

	iacl_sw = (type = SEGMENT_IACL | type = DIRECTORY_IACL);
	err_path = "";

	call process_arguments ();

	if ^star_sw then star_entry_count = 1;
	else do;					/* star name given */
	     if af_sw then call complain (error_table_$nostars, whoami, "^a", ename);
	     if chase_sw then
		star_select_sw = star_ALL_ENTRIES;
	     else star_select_sw = star_BRANCHES_ONLY;

	     if do_tedious_star then do;
		call hcs_$star_ (dname, "**", (star_select_sw), system_area_ptr, star_entry_count, star_entry_ptr,
		     star_names_ptr, code);
		if code ^= 0 then do;
		     call complain (code, whoami, "^a", pathname_ (dname, ename));
		     goto MAIN_RETURN;
		end;

		star_name_count = sum (star_entries(*).nnames);
		call modified_star_processing ();
	     end;
	     else do;
		call hcs_$star_ (dname, ename, (star_select_sw), system_area_ptr, star_entry_count, star_entry_ptr,
		     star_names_ptr, code);
		if code ^= 0 then do;
		     call complain (code, whoami, "^a", pathname_ (dname, ename));
		     goto MAIN_RETURN;
		end;

		star_name_count = sum (star_entries(*).nnames);
		allocate star_match in (system_area);
		string (star_match) = "1"b;		/* everyone matches */
	     end;
	end;

	if privilege ^= NORMAL then
	     on linkage_error
		begin;
                         call complain (error_table_$action_not_performed, whoami,
                              "Access to ^[hphcs_^;installation_tools_^] is required.", (privilege = HPHCS));
		     goto MAIN_RETURN;
		     end;

	do star_entry_idx = 1 to star_entry_count;
	     fcb_ptr = null ();
	     if star_sw
	     then do;
		if do_tedious_star then do;
		     do star_name_idx = star_entries (star_entry_idx).nindex to star_entries (star_entry_idx).nindex  + star_entries (star_entry_idx).nnames -1;
			if star_match (star_name_idx) then do;
			     ename = star_names (star_name_idx);
			     goto FOUND_MATCH;
			end;
		     end;
		     goto SKIP_NON_MATCH;
		end;
		else ename = star_names (star_entries.nindex (star_entry_idx));
	     end;
	     
FOUND_MATCH:   err_path = pathname_ (dname, ename);	/* for error messages */

	     call get_suffix_info ();

	     object_type = si.type;
	     if limit_entry_types
		then if ^entry_type_selected (entry_type_ptr, object_type) then do;
WRONG_TYPE:
		     if ^star_sw then
			if iacl_sw
			      then call complain (error_table_$notadir, whoami, "^a", err_path);
			else call complain (0, whoami,
			"Wrong type of entry.  For ^a ^a.", si.type_name, err_path);
		     goto SKIP_MATCH;
		     end;

		else;
	     else if ^(directory_sw | segment_sw) then;	/* anything goes */
	     else if (object_type = FS_OBJECT_TYPE_DIRECTORY)
		then if ^directory_sw then goto WRONG_TYPE;
		else;
	     else if (substr (object_type, 1, 1) = "-")
		then if ^segment_sw			/* seg, msf, dmf */
		     then goto WRONG_TYPE;
		else;
	     else if (explicit_dr_arg | explicit_sm_arg) /* explicit -dir or -sm */
		then goto WRONG_TYPE;		/* extended types not selected with -sm or -dr */

	     matched_sw = "1"b;			/* found something */

	     if object_type = FS_OBJECT_TYPE_MSF then do;
		call msf_manager_$open (dname, ename, fcb_ptr, code);
		if code ^= 0 then do;
		     call complain (code, whoami, "^a", err_path);
		     goto SKIP_MATCH;
		     end;
		end;

	     call build_new_acl ();			/* Build whatever new ACL is appropriate */

	     if (operation = SET) | (operation = DELETE) then call replace_the_acl ();
	     else if (operation = LIST) then call list_the_acl ();
	     else if (operation = ACCESSIBLE) then call print_accessible ();

	     call check_for_acle_errors ();

SKIP_MATCH:
	     if object_type = FS_OBJECT_TYPE_MSF then
		if fcb_ptr ^= null () then call msf_manager_$close (fcb_ptr);
SKIP_NON_MATCH:
	     end;


	if star_sw & ^matched_sw then call complain (error_table_$nomatch, whoami, "^a", pathname);

MAIN_RETURN:
	call cleanup_handler ();
          return;                                           /* ONLY return statement in this procedure */
%page;
process_arguments:
     procedure ();

/* This procedure implements the argument processing loop. It detects all the possible
   inconsistencies among control arguments, etc.   */

dcl	(ap, ap1)			pointer;
dcl	(al, al1)			fixed bin (21);
dcl	arg			char (al) based (ap);
dcl	arg1			char (al1) based (ap1);
dcl	(argno, nargs)		fixed bin;
dcl	min_ring			fixed bin (3);
dcl	idx			fixed bin;

dcl	(
	all_val,
	chase_val,
	brief_val,
	replace_val,				/* record of specified options, used for consistency */
	raw_val,
	ring_bracket_val,
	sysdaemon_val,
	access_class_val,				/* checks later on */
	segment_val,
	directory_val
	)			fixed bin init (0); /* INITIALIZED TO ZERO, to get default */

declare   iacl_ring_arg                 fixed bin;
declare   type_name                     char (32);
declare	type_suffix		char (32);
declare   have_mode                     bit (1) aligned;
declare   want_mode                     bit (1) aligned;
declare   all_stars                     bit (1) aligned;
declare   ename_suffix                  char (32);

          call cu_$af_return_arg_rel (nargs, ret_str_ptr, ret_str_lth, code, P_arg_list_ptr);
          if (code = 0) then do;
               af_sw = "1"b;
               brief_val = 1;
               ret_str = "";
               end;
          else af_sw = "0"b;                                /* assume we're a command */

	pathname, type_name = "";
	iacl_ring = -1;
	iacl_ring_arg = 0;

	if operation = SET | operation = ACCESSIBLE then do;
						/* collect User_ids and modes -- they should come in pairs */
	     max_acl_names = divide ((nargs + 1), 2, 17, 0);
	     max_acl_modes = max_acl_names;
	     allocate acl_modes in (system_area);
	     end;

	else do;					/* other operations only collect userids */
	     max_acl_names = nargs - 1;		/* many as arg count - 1 */
	     acl_modes_ptr = null ();			/* catch errors */
	     end;

	max_acl_names = max (max_acl_names, 1);		/* make sure there's always at least one */
	allocate acl_names in (system_area);

	n_acl_names = 0;				/* collected nothing so far */
	n_acl_modes = 0;
	acl_names (*) = "";

	if operation = SET then
	     want_mode = "1"b;			/* SET wants a mode first thing after the path */
	else want_mode = "0"b;			/* Other commands never want modes */
	have_mode = "0"b;

	do argno = 1 to nargs;			/* now, collect */
               call cu_$arg_ptr_rel (argno, ap, al, (0), P_arg_list_ptr);

	     if al = 0 then do;
NULL_ARG:		call complain (0, whoami, "zero-length argument not accepted.");
		goto MAIN_RETURN;
	     end;

	     if char (arg, 1) = "-" then
		if arg = "-wd" | arg = "-working_dir" | arg = "-working_directory" then do;
		     if pathname ^= "" then do;	/* only in first position */
			call complain (0, whoami, "^a may only appear in place of the pathname argument.", arg);
			goto MAIN_RETURN;
			end;
		     pathname = get_wdir_ ();
		     end;

		else if operation = DELETE & (arg = "-all" | arg = "-a") then call SET_OPTION (all_val, ON);
		else if type = BRANCH_ACL & (arg = "-interpret_as_standard_entry" | arg = "-inase") then
		     call SET_OPTION (raw_val, ON);
		else if type = BRANCH_ACL & (arg = "-interpret_as_extended_entry" | arg = "-inaee") then
		     call SET_OPTION (raw_val, OFF);
		else if arg = "-chase" then call SET_OPTION (chase_val, ON);
		else if arg = "-no_chase" then call SET_OPTION (chase_val, OFF);
		else if type = BRANCH_ACL & (arg = "-select_entry_type" | arg = "-slet") then do;
		     if argno = nargs then do;
NOARG:
			call complain (error_table_$noarg, whoami, "Following ^a.", arg);
			goto MAIN_RETURN;
			end;
		     argno = argno + 1;
                         call cu_$arg_ptr_rel (argno, ap, al, (0), P_arg_list_ptr);
		     if al = 0 then goto NULL_ARG;

		     type_name = arg;
		     call process_entry_type_list (arg, entry_type_ptr, limit_entry_types);
		     if ^limit_entry_types then do;
			call complain (0, whoami, "One or more invalid entry types specified. ^a", arg);
			goto MAIN_RETURN;
			end;
		     end;
		else if operation = ACCESSIBLE then do; /* collect mode string to match */
		     if have_mode then do;
			call complain (0, whoami, "Only one set of modes may be given.", arg);
			goto MAIN_RETURN;
			end;

		     want_mode, have_mode = "1"b;
		     if pathname = "" then pathname = get_wdir_ ();

		     if arg = "-dir_mode" then call SET_OPTION (directory_val, ON);
		     else if arg = "-seg_mode" then call SET_OPTION (segment_val, ON);
		     else if arg ^= "-mode" then call BADOPT (argno);
		     if argno = nargs then goto NOARG;
		     end;
		else if arg = "-brief" | arg = "-bf" then call SET_OPTION (brief_val, ON);
		else if arg = "-long" | arg = "-lg" then call SET_OPTION (brief_val, OFF);
		else if arg = "-directory" | arg = "-dr" then do; 
			if type = DIRECTORY_IACL | type = SEGMENT_IACL
			then call BADOPT (argno);
			else call SET_OPTION (directory_val, ON);
			end;
		else if arg = "-segment" | arg = "-sm" then do;
			if type = DIRECTORY_IACL | type = SEGMENT_IACL
			then call BADOPT (argno);
			else call SET_OPTION (segment_val, ON);
			end;
		else if iacl_sw & (arg = "-ring" | arg = "-rg") then do;
		     iacl_ring_arg = argno;		/* remember where we saw it */
		     ap1 = null ();			/* prevent faults */
		     al1 = 0;

		     if argno = nargs then do;
			code = error_table_$noarg;
BAD_IACL_RING:
			call complain (code, whoami,	/* include the offending argument, if it exists */
			     "^a must be followed by a ring number^[.^;, not ^a^]", arg, (al1 = 0), arg1);
			goto MAIN_RETURN;
			end;

		     if iacl_ring >= 0 then do;	/* only say this once */
			call complain (0, whoami, "^a may only be specified once.", arg);
			goto MAIN_RETURN;
			end;

		     argno = argno + 1;		/* get the next argument */
                         call cu_$arg_ptr_rel (argno, ap1, al1, (0), P_arg_list_ptr);
		     if al = 0 then goto NULL_ARG;

		     iacl_ring = index ("01234567", arg1) - 1;

		     if iacl_ring < 0 | length (arg1) ^= 1 then do;
						/* not one of the digits */
			code = error_table_$bad_conversion;
			goto BAD_IACL_RING;
			end;
		     end;				/* of processing -ring */
		else if operation = LIST & ^iacl_sw then do;
		     if arg = "-ring_brackets" | arg = "-rb" then call SET_OPTION (ring_bracket_val, ON);
		     else if arg = "-no_ring_brackets" | arg = "-nrb" then call SET_OPTION (ring_bracket_val, OFF);
		     else if arg = "-access_class" | arg = "-acc" then call SET_OPTION (access_class_val, ON);
		     else if arg = "-no_access_class" | arg = "-nacc" then call SET_OPTION (access_class_val, OFF);
		     else call BADOPT (argno);
		     end;				/* of list only args */
		else if operation = SET then do;
		     if arg = "-replace" | arg = "-rp" then call SET_OPTION (replace_val, ON);
		     else if arg = "-modify" | arg = "-md" then call SET_OPTION (replace_val, OFF);
		     else if (arg = "-sysdaemon") | (arg = "-sd") then call SET_OPTION (sysdaemon_val, ON);
		     else if (arg = "-no_sysdaemon") | (arg = "-nsd") then call SET_OPTION (sysdaemon_val, OFF);
		     else call BADOPT (argno);
		     end;
		else call BADOPT (argno);		/* haven't heard of this one */

	     else if pathname = "" then		/* pathname not seen yet, this must be it */
		pathname = arg;			/* just copy it */

	     else if want_mode then do;		/* this can only happen with SET operations */
		n_acl_modes = n_acl_modes + 1;	/* get to the next entry */
		acl_modes (n_acl_modes) = arg;	/* save it in the array */
		want_mode = "0"b;			/* and ask for a name next time around */
		end;
	     else do;
		n_acl_names = n_acl_names + 1;	/* prepare to use the next entry */
		acl_names (n_acl_names) = arg;	/* save the name in the array */
		if operation = SET then want_mode = "1"b;
		end;
	     end;					/* of argument loop */

/* Now, check the various possibilities for error */

	if af_sw & operation ^= LIST then do;		/* only list can be used as an AF */
	     call complain (error_table_$active_function, whoami);
	     goto MAIN_RETURN;
	     end;

	if operation ^= LIST & operation ^= ACCESSIBLE & pathname = "" then
						/* only listing has a default */
	     call USAGE (error_table_$noarg);

	if operation = SET & n_acl_modes = 0 then	/* must have at least one mode */
	     call USAGE (error_table_$noarg);

	if pathname = "" then			/* if nothing supplied, must be the default */
	     pathname = get_wdir_ ();

	type_suffix = "";
	do_tedious_star = "0"b;			/* wishful thinking */
	if type = MBX_ACL then type_suffix = "mbx";
	else if type = MSEG_ACL then type_suffix = "ms";
	else if limit_entry_types
	     then if entry_type.count = 1
		then if ^entry_type.suffixes (1).is_std_type
		     then type_suffix = entry_type.suffixes (1).suffix;
		     else;
		else do_tedious_star = "1"b;

	dname = "";                                       /* must initialize for later reference by the "lac" and "lnac" commands */
	ename = "";
	call expand_pathname_$add_suffix (pathname, type_suffix, dname, ename, code);

	if code ^= 0 then do;			/* unacceptable pathname */

/* fix bugs for TR # phx19075 */
	     if code = error_table_$root & operation = ACCESSIBLE & pathname = ">" then do; /* accept the ROOT directory */
		code = 0;
		dname = ">";

		if type_name = "" then do;
		     if acl_names (1) ^= "" then
			ename = acl_names (1);
		     else ename = "**";
		     end;
		end;
/* end of bug fix for TR # phx19075 */

	     else do;
		call complain (code, whoami, "^a", pathname);
		goto MAIN_RETURN;
	          end;
	     end;

	if operation ^= ACCESSIBLE & dname = ">" & ename = "" then
	     code = error_table_$root;

	else call check_star_name_$entry (ename, code);
	if code > 2 then do;
	     call complain (code, whoami, "^a", pathname_ (dname, ename));
	     goto MAIN_RETURN;
	     end;
	star_sw = (code > 0);			/* remember if it was a starname */
          all_stars = (code = 2);                           /* and whether it's one of the everything names */

	if operation = ACCESSIBLE then do;
	     star_sw = "1"b;	     
	     
	     if pathname ^= ">" then
		dname = pathname_ (dname, ename);

	     if type_name ^= "" then
		ename = "**." || rtrim (type_name);
	     else ename = "**";
		
               all_stars = (type_name = "");                /* Unless we got as type, it's all entries */
	     end;

          ename_suffix = reverse (before (reverse (ename), "."));
	if search (ename_suffix, "*?") ^= 0 then starname_suffix = "1"b;

	if operation = SET & n_acl_modes > n_acl_names then do;
						/* Apply the default for the final name */
	     n_acl_names = n_acl_names + 1;
	     if ename_suffix = "mbx" then
		acl_names (n_acl_names) = before (get_group_id_$tag_star (), ".") || ".*.*";
	     else acl_names (n_acl_names) = get_group_id_$tag_star ();
	     end;

	if operation = DELETE & n_acl_names = 0 & all_val = 0 then do;
	     n_acl_names = 1;
	     if ename_suffix = "mbx" then
		acl_names (1) = before (get_group_id_$tag_star (), ".") || ".*.*";
	     else acl_names (1) = get_group_id_$tag_star ();
	     end;


          if (type = MBX_ACL) then xacl_allowed = "1"b;     /* Always extended acls */
          else if (type = MSEG_ACL) then xacl_allowed = "1"b;
          else if (privilege ^= NORMAL) then xacl_allowed = "0"b; /* No hphcs_ or ring one stuff in fs_util_, after all */
          else if (raw_val > 0) then xacl_allowed = "0"b;   /* And certainly not if we were told -inase */
          else if all_stars then xacl_allowed = "0"b;       /* Not if we got ** or equivalent, either */
          else if (index (ename, ".") = 0) then xacl_allowed = "0"b; /* Single component name */
          else if (ename_suffix = "") then xacl_allowed = "0"b; /* The ename ends in a period */
          else if starname_suffix then xacl_allowed = "0"b; 
          else if (substr (ename_suffix, 1, 1) = "-") then xacl_allowed = "0"b; /* Reserved object types begin with "-" */
          else do;
               si.version = SUFFIX_INFO_VERSION_1;
               call fs_util_$suffix_info_for_type (ename_suffix, addr (si), code);
               if (code = error_table_$unsupported_operation) then
                    xacl_allowed = "0"b;
               else if (code =0) then
                    xacl_allowed = (^si.standard_object & si.extended_acl);
               else do;
                    call complain (code, whoami, "^a", pathname_ (dname, ename));
                    goto MAIN_RETURN;
                    end;
               end;

	if type_name ^= "" | type ^= BRANCH_ACL then
	     if (directory_val ^= 0) | (segment_val ^= 0) | (raw_val ^= 0) then do;
	          call complain (error_table_$inconsistent, whoami,
		     """-type"" ^[and ""-inase"" ^]^[and ""-seg^[_mode^;ment^]"" ^;^s^]^[and ""-dir^[_mode^;ectory^]""^]"
		     , (raw_val ^= 0), (segment_val ^= 0), (operation = ACCESSIBLE),
		     (directory_val ^= 0), (operation = ACCESSIBLE));
		goto MAIN_RETURN;
		end;

	if iacl_ring >= 0 then do;			/* check if we're allowed to */
	     if operation = LIST then
		min_ring = 0;			/* can list any ring */
	     else call cu_$level_get (min_ring);	/* otherwise, we must put up with what we've got */

	     if iacl_ring < min_ring then do;		/* sorry, no dice */
		call complain (error_table_$bad_ring_brackets, whoami,
		     "IACL ring number must be between ^d and 7, not ^d.", min_ring, iacl_ring);
		goto MAIN_RETURN;
		end;
	     end;

	else call cu_$level_get (iacl_ring);		/* otherwise, set the default */

	if operation = SET & replace_val = 0 & sysdaemon_val ^= 0 then do;
	     call cu_$arg_ptr_rel (abs (sysdaemon_val), ap, al, (0), P_arg_list_ptr);
	     call complain (error_table_$badopt, whoami,
		"^/^a may only be used in conjunction with -replace", arg);
	     goto MAIN_RETURN;
	end;

	all_sw = (all_val > 0);			/* now, set the flags the main program will use */
	chase_sw = (chase_val > 0);
	no_chase_sw = (chase_val < 0);
	replace_sw = (replace_val > 0);
	no_sysdaemon_sw = (sysdaemon_val < 0);
	brief_sw = (brief_val > 0);
	force_no_type = (raw_val > 0);
	ring_bracket_sw = (ring_bracket_val > 0);
	access_class_sw = (access_class_val > 0);

	segment_sw,explicit_sm_arg = (segment_val > 0);
	directory_sw,explicit_dr_arg = (directory_val > 0);

	if (operation = SET) & (^replace_sw) then	/* Don't add *.SysDaemon if just adding stuff to the ACL */
	     no_sysdaemon_sw = "1"b;
          else if (operation = DELETE) then                 /* Similarly, if deleting, and there isn't one there now, */
               no_sysdaemon_sw = "1"b;                      /* don't add it */

	if ^(segment_sw | directory_sw) then do; /* figure out if segs or dirs */
	     if type = BRANCH_ACL & operation = SET & ^xacl_allowed & star_sw then do;
		do idx = 1 to n_acl_modes while (^segment_sw & ^directory_sw);
		     if acl_modes (idx) ^= "n" & acl_modes (idx) ^= "null" then
			if search (acl_modes (idx), "sma") > 0 then
			     directory_sw = "1"b;
			else segment_sw = "1"b;
		     end;
		if ^segment_sw & ^directory_sw then segment_sw = "1"b;
						/* default to segs, msfs, and dmfs */
		end;
	     else if operation = ACCESSIBLE & type_name = "" & n_acl_modes > 0 then
		if search (acl_modes (1), "sma") > 0 then
		     directory_sw = "1"b;
		else segment_sw = "1"b;
	     else;				/* all but SET default to everything */
	     end;

	else xacl_allowed = "0"b;

          if iacl_sw 
               then do;
                     segment_sw = "0"b;
                     directory_sw = "1"b;
                    end;

	if operation = ACCESSIBLE then do;
	     brief_sw = "1"b;			/* avoid "no match for .... " messages */

	     if n_acl_modes = 0 then
		acl_mask = copy ("1"b, 36);
	     else do;
		si.version = SUFFIX_INFO_VERSION_1;
                    if (type_name ^= "") then
                         call fs_util_$suffix_info_for_type (type_name, addr (si), (0));
                    else if directory_sw then
                         call fs_util_$suffix_info_for_type (FS_OBJECT_TYPE_DIRECTORY, addr (si), (0));
                    else call fs_util_$suffix_info_for_type (FS_OBJECT_TYPE_SEGMENT, addr (si), (0));

		acl_mask = convert_mode (acl_modes (1));
		end;

	     if n_acl_names = 0 then do;
		access_name = get_group_id_$tag_star ();
		use_access_modes = "1"b;
		end;
	     else do;
		access_name = acl_names (1);
		if index (access_name, ".") = 1 | index (access_name, "..") > 0
		     | substr (access_name, length (rtrim (access_name)), 1) = "." then
		     use_access_modes = "0"b;
		else do;
		     use_access_modes = "1"b;
                         call set_components (access_name, (""));
		     end;
		end;
	     end;

	return;					/* end of argument processing */
%page;
SET_OPTION:
     proc (P_option, P_on_off);

/* This procedure (internal to process_arguments) sets P_option to be the index of the first
   occurrence of a control argument to set the specified option. It is set negative to indicate
   that the option is to be off, and positive to indicate that it is to be on. */

dcl	(
	P_option			fixed bin,
	P_on_off			bit (1) aligned
	)			parameter;

	if P_option = 0 then			/* never specified so far. Remember argument position */
	     if P_on_off = ON then
		P_option = argno;			/* positive value indicates option ON */
	     else P_option = 0 - argno;		/* negative value indicates option OFF */

	else do;					/* Some form of option already specified */
	     if P_option < 0 then			/* Already OFF. Must we invert it? */
		if P_on_off = ON then		/* Yes, invert, but keep original arg number */
		     P_option = 0 - P_option;

	     if P_option > 0 then			/* Already ON. Must we invert it? */
		if P_on_off = OFF then		/* Yes, invert, but keep original arg number */
		     P_option = 0 - P_option;
	     end;

	return;
     end SET_OPTION;
%page;
USAGE:
     proc (P_code);

/* This procedure prints out a Usage message for each type of command */

dcl	P_code			fixed bin (35);

	if operation = SET then			/* requires at least one mode; Name always defaults */
	     call complain (P_code, whoami, "^/Usage:^-^a Path Mode1 {Name1} ... {ModeN {NameN}} {-control_args}",
		whoami);

	else if operation = DELETE then
	     call complain (P_code, whoami, "^/Usage:^-^a Path {Name1} ... {NameN} {-control_args}", whoami);

	else if operation = LIST then			/* special defaults -- sometimes is WDIR */
	     if (type = BRANCH_ACL) | iacl_sw then
		call complain (P_code, whoami, "^/Usage:^-^a {Path} {Name1} ... {NameN} {-control_args}", whoami);

	     else call complain (P_code, whoami, "^/Usage:^-^a Path {Name1} ... {NameN} {-control_args}", whoami);

	goto MAIN_RETURN;

     end USAGE;
%page;
BADOPT:
     proc (P_argno);

/* This procedure prints an error message for the control argument identified by P_argno, which
   is expected to be one of the option flags used in SET_OPTION, above. */

dcl	P_argno			fixed bin parameter;

dcl	ap			pointer;
dcl	al			fixed bin (21);
dcl	arg			char (al) based (ap);

          call cu_$arg_ptr_rel (abs (P_argno), ap, al, (0), P_arg_list_ptr); /* remember, option values may be signed */

	call complain (error_table_$badopt, whoami, "^a", arg);

	goto MAIN_RETURN;

     end BADOPT;
%page;
process_entry_type_list:	   proc(entry_type_list, entry_type_struct_ptr, limit_entry_selections);

dcl entry_type_list		char (*) parameter;
dcl entry_type_struct_ptr	pointer parameter;
dcl limit_entry_selections	bit (1) aligned;

dcl types_len	fixed bin (24);
dcl types_ptr	pointer;
dcl types		char (types_len) based (types_ptr);
dcl entry_type_no	fixed bin;
dcl this_type	char (32);

	
/* copy entry_type_list into "real" storage */

	     types_ptr = null ();
	     on cleanup
		begin;
		     if types_ptr ^= null () then free types in (system_area);
		end;

	     types_len = length (entry_type_list);
	     allocate types
		set (types_ptr) in (system_area);
	     types = entry_type_list;

/* to start off, get a count of the number of types in the string */

	     do entry_type_count = 1
		repeat (entry_type_count + 1)
		while (index (types, ",") > 0);
		types = after (types, ",");
	     end;

/* allocate the entry_type structure, to be used later in this command */

	     allocate entry_type
		set (entry_type_struct_ptr)
		in (system_area);

	     entry_type_struct_ptr -> entry_type.suffixes.suffix (*) = "";

/* for each potential entry type, validate it and add it to the structure */

	     types = entry_type_list;
	     type_info.version = SUFFIX_INFO_VERSION_1;
	     entry_type_no = 1;
	     do while (types ^= "");
		this_type = before (types, ",");
		if substr (this_type, 1, 1) ^= "-" then do;
		     entry_type.suffixes (entry_type_no).is_std_type = "1"b;  /* Presumed innocent ... */
		     if this_type = "link" then do;
			call complain (0, whoami, "This commands does not support links.");
			goto MAIN_RETURN;
		     end;

		     else if this_type = "segment" then this_type = FS_OBJECT_TYPE_SEGMENT;
		     else if this_type = "directory" then this_type = FS_OBJECT_TYPE_DIRECTORY;
		     else if this_type = "multisegment_file" then this_type = FS_OBJECT_TYPE_MSF;
		     else if this_type = "data_management_file" then this_type = FS_OBJECT_TYPE_DM_FILE;
		     else entry_type.suffixes (entry_type_no).is_std_type = "0"b;  /* ... until proven guilty */
		     entry_type_struct_ptr -> entry_type.suffixes.suffix (entry_type_no) = this_type;
		     call fs_util_$suffix_info_for_type (this_type, addr (type_info), code);
		     if code = 0 then entry_type_no = entry_type_no + 1;
		     else goto BAD_TYPE_ERROR;
		end;
		else do;
BAD_TYPE_ERROR:	     free types_ptr -> types in (system_area);
		     limit_entry_selections = "0"b;
		     return;
		end;

		types = after (types, ",");
	     end;

/* free the types variable and set the limit_entry_selections flag */

	     free types_ptr -> types
		in (system_area);

	     entry_type_struct_ptr -> entry_type.count = entry_type_no - 1;
	     if entry_type_struct_ptr -> entry_type.count = 0
		then limit_entry_selections = "0"b;
	     else limit_entry_selections = "1"b;

	     return;

	end process_entry_type_list;
%page;
     end process_arguments;
%page;

entry_type_selected:	proc (entry_type_struct_ptr, fs_type) returns (bit (1) aligned);


dcl entry_type_struct_ptr pointer parameter;
dcl fs_type char (32) parameter;
dcl entry_type_no fixed bin;

	     do entry_type_no = 1 to entry_type_struct_ptr -> entry_type.count;
		if entry_type_struct_ptr -> entry_type.suffixes.suffix (entry_type_no) = fs_type then return ("1"b);
	     end;
	     return ("0"b);

	end entry_type_selected;

%page;
modified_star_processing:
	procedure ();
/* Routine to do star processing when more than one entry type is specified
   by -slet */

dcl  star_idx		fixed bin;
dcl  type_idx		fixed bin;
dcl  temp_ename		char (32);
dcl  std_type		bit (1) aligned;


	std_type = "0"b;
	do type_idx = 1 to entry_type.count;
	     if entry_type.suffixes (type_idx).is_std_type
	     then std_type = "1"b;			/* at least one std type is specified */
	end;

	allocate star_match in (system_area);

	si.version = SUFFIX_INFO_VERSION_1;

	do star_idx = 1 to star_entry_count;
	     do type_idx = 1 to entry_type.count;
		if ^entry_type.suffixes (type_idx).is_std_type
		then do;				/* try all extended types first */
		     call expand_pathname_$add_suffix (pathname, (entry_type.suffixes(type_idx).suffix),
			dname, temp_ename, code);
 		     if code ^= 0 then goto NEXT_TYPE_NAME;
		     do star_name_idx = star_entries(star_idx).nindex to
				    star_entries(star_idx).nindex + star_entries(star_idx).nnames -1;
			call match_star_name_ (star_names (star_name_idx), temp_ename, code);
			if code = 0 then do;
/* really should check type here */
			     call fs_util_$suffix_info (dname, star_names (star_name_idx), addr (si), code);
			     if code = error_table_$not_seg_type then goto TRY_STD;
						/* All the names on an extended entry must have same suffix.
						   This entry is not of the type that this name indicates;
						   therfore, it cannot be an extended entry */
			     else if code = 0 & ^si.flags.standard_object
			     then star_match (star_name_idx) = "1"b;
			     goto NEXT_STAR_NAME;
			end;
		     end;
		end;
NEXT_TYPE_NAME:	
	     end;

TRY_STD:	     if std_type				/* The name did not fit any extended types AND the
						   user has requested a standard entry type */
	     then do star_name_idx = star_entries(star_idx).nindex to
			         star_entries(star_idx).nindex + star_entries(star_idx).nnames -1;
		call match_star_name_ (star_names (star_name_idx), ename, code);
		if code = 0 then do;
		     call fs_util_$suffix_info (dname, star_names (star_name_idx), addr (si), code);
		     if code = 0
		     then if si.flags.standard_object
			then star_match (star_name_idx) = "1"b;
		     goto NEXT_STAR_NAME;
		end;
	     end;

NEXT_STAR_NAME:
	end;
         return;
     end modified_star_processing;
%page;


build_new_acl:
     procedure ();

/* In this procedure, old_acl and new_acl are two equally large structures, each with
   enough entries to have one for each in the object's current ACL and one for each
   name specified on the command line. The old_acl entries start out by being a copy
   of the object's current ACL, and new_acl is empty. As each of the command line
   arguments is examined, all matching old_acl entries are moved to new_acl, and
   all non-matching ones without missing components are added to both old_acl and
   new_acl. */



	if (operation = SET) & replace_sw then do;	/* If doing wholesale replacement, get out early */
	     call build_replacement_acl ();
	     return;
	     end;

	if (operation = ACCESSIBLE) & use_access_modes then return;
						/* If listing things accessable just to US, */
						/* don't even bother listing the ACL */

	call get_acl ();				/* List the original object ACL */
	original_count = general_acl.count;		/* Remember how large it started */

	if (operation = LIST) & (n_acl_names = 0) then return;
						/* List the whole ACL, which is ready right now */

/* Now, allocate the old_acl and new_acl structures, with one entry for each entry from the old ACL
   plus one for each name supplied on the command line if the operation is SET. If the operation is
   LIST or ACCESSABLE, we know we won't be making the list any larger, so just use the structure
   gotten from get_acl as the old_acl.  Because of the refer extents in general_acl, we have to
   play games with acl_count here. */

	if (operation = SET) then			/* Figure out how large to make our copies */
	     acl_count = original_count + n_acl_names;
	else acl_count = original_count;

	if (operation = SET) then			/* Allocate a large enough copy if we're going to update it */
	     call enlarge_old_acl ();
	else old_acl_ptr = acl_ptr;			/* Otherwise, recycle the old one */

	call allocate_new_acl ();

	if (operation = DELETE) then			/* Keep all that don't match */
	     call build_nonmatching_acl ();
	else if (operation = SET) then		/* Keep all that does match, */
	     call build_matching_acl ("1"b);		/* and anything else from the command line, besides */
	else if (operation = LIST) then		/* Keep only things which match */
	     call build_matching_acl ("0"b);
	else if (operation = ACCESSIBLE) then call build_matching_acl ("0"b);

	call free (old_acl_ptr);			/* Free the old acl and the used bits */
	call free (used_bits_ptr);

	acl_count = new_acl.count;			/* Make it available for later uses */
	acl_ptr = new_acl_ptr;			/* copy to ones we will use to call primitives */
	new_acl_ptr = null ();			/* mark pointer as unused to avoid freeing through it */

	return;

/**/

enlarge_old_acl:
     procedure ();

declare	acle_idx			fixed bin;


	allocate old_acl in (system_area) set (old_acl_ptr);
						/* acl_count was set above */
	old_acl.version = GENERAL_ACL_VERSION_1;
	old_acl.count = general_acl.count;		/* Start with the original count of ACL entries */

	do acle_idx = 1 to old_acl.count;		/* Copy the entries from the object's ACL into this ACL */
	     old_acl.entries (acle_idx) = general_acl.entries (acle_idx);
	     end;

	call free (acl_ptr);			/* Get rid of the original one */
						/* We now have a copy in old_acl */
	return;
     end enlarge_old_acl;



allocate_new_acl:
     procedure ();

	allocate new_acl in (system_area) set (new_acl_ptr);
						/* Make a place to put the results */
	new_acl.count = 0;				/* starting out empty */
	new_acl.version = GENERAL_ACL_VERSION_1;

	used_bits_count = n_acl_names + acl_count;
	allocate used_bits in (system_area) set (used_bits_ptr);
	unspec (used_bits) = ""b;

	return;
     end allocate_new_acl;

/**/

build_replacement_acl:
     procedure ();

/* This procedure is used to build a whole replacement ACL for set_acl -replace.
   It relies on the harcore's SysDaemon switch to provide or not provide an entry
   for *.SysDaemon. */

declare	acle_idx			fixed bin;


	acl_count = n_acl_names;			/* Same size as the number of command-line arguments */
	allocate general_acl in (system_area) set (acl_ptr);
	general_acl.count = acl_count;
	general_acl.version = GENERAL_ACL_VERSION_1;

	do acle_idx = 1 to n_acl_names;		/* Fill in names from command arguments */
	     call set_components (acl_names (acle_idx), (""));
						/* "Normalize" the supplied access name */
	     general_acl.access_name (acle_idx) = acl_names (acle_idx);
	     general_acl.mode (acle_idx) = convert_mode (acl_modes (acle_idx));
	     general_acl.status_code (acle_idx) = 0;
	     end;

	return;
     end build_replacement_acl;

/**/

build_matching_acl:
     procedure (add_new_names);

/* Go through the object's ACL, and build a new one. The match_acl procedure will copy any
   names that match in the old ACL into the new_acl; the add_new_names switch determines
   whether non-matching names from the command line will be added, as well (true for SET) */


declare	add_new_names		bit (1) aligned parameter;

declare	given_name_idx		fixed bin;
declare	old_acle_idx		fixed bin;


	do given_name_idx = 1 to n_acl_names;		/* Look at each name requested on the command line */
	     if match_acl (given_name_idx, "1"b) then goto CHECK_NEXT_GIVEN_NAME;
						/* If there were matches, don't add it */

	     if add_new_names then do;
		new_acl.count = new_acl.count + 1;	/* No matches found, so make a whole new entry */
		new_acl.access_name (new_acl.count) = acl_names (given_name_idx);
		new_acl.mode (new_acl.count) = convert_mode (acl_modes (given_name_idx));

		old_acl.count = old_acl.count + 1;	/* Also add this entry to the old ACL structure, so */
		old_acl.access_name (old_acl.count) = new_acl.access_name (new_acl.count);
		end;				/* that later names will match against it */

CHECK_NEXT_GIVEN_NAME:
	     end;					/* acl_name loop */

	if ^add_new_names then return;		/* If not keeping names from original, quit now */

	do old_acle_idx = 1 to original_count;		/* Add anything that's left, BUT only from the ACL */
						/* we started with, omitting anything added above */
	     if ^used_bits (old_acle_idx) then do;	/* Didn't get matched by anything, so keep it */
		new_acl.count = new_acl.count + 1;	/* so it's still there in the new ACL */
		new_acl.status_code (new_acl.count) = 0;
		new_acl.access_name (new_acl.count) = old_acl.access_name (old_acle_idx);
		new_acl.mode (new_acl.count) = old_acl.mode (old_acle_idx);
		end;
	     end;

	return;
     end build_matching_acl;

/**/

build_nonmatching_acl:
     procedure ();

declare	given_name_idx		fixed bin;
declare	old_acle_idx		fixed bin;
declare	acle_matched		bit (1) aligned;


	do given_name_idx = 1 to n_acl_names;		/* Look at each name requested on the command line */
	     acle_matched = match_acl (given_name_idx, "0"b);
						/* Ignore the match result-- match_acl has already done */
	     end;					/* everything we need done (setting the used_bits bit) */

	if all_sw then
	     do old_acle_idx = 1 to original_count;
	     if old_acl.access_name (old_acle_idx) = "*.SysDaemon.*"
		then;				/* don't touch it! */
	     else used_bits (old_acle_idx) = "1"b;
	end;

	call free (new_acl_ptr);			/* clean up after ourselves */
	allocate new_acl in (system_area) set (new_acl_ptr);
						/* Make a place to put the results */
	new_acl.count = 0;				/* starting out empty */
	new_acl.version = GENERAL_ACL_VERSION_1;

	do old_acle_idx = 1 to original_count;		/* Add anything that's left, BUT only from the ACL */
						/* we started with, omitting anything added above */
	     if ^used_bits (old_acle_idx)		/* Didn't get matched by anything */
	     then do;
		new_acl.count = new_acl.count + 1;	/* so it's still there in the new ACL */
		new_acl.status_code (new_acl.count) = 0;
		new_acl.access_name (new_acl.count) = old_acl.access_name (old_acle_idx);
		new_acl.mode (new_acl.count) = old_acl.mode (old_acle_idx);
		end;
	     end;

	return;
     end build_nonmatching_acl;

/**/

match_acl:					/* cribbed from old find_common_acl_names_ */
     proc (name_idx, copy_matching_names) returns (bit (1) aligned);

declare	name_idx			fixed bin parameter;
declare	copy_matching_names		bit (1) aligned parameter;

declare	used			bit (1) aligned;
declare	old_acle_idx		fixed bin;
declare	missing_component		bit (1) aligned;
declare	comp_idx			fixed bin;
declare	given_comp		(3) char (32) aligned;
declare	acle_comp			(3) char (32) aligned;


	used = "0"b;
	missing_component = "0"b;			/* Missing component in name from command line */

	call set_components (acl_names (name_idx), given_comp);
	do comp_idx = 1 to 3 while (^missing_component);
	     if given_comp (comp_idx) = "" then missing_component = "1"b;
	     end;

	do old_acle_idx = 1 to old_acl.count;
	     call set_components (old_acl.access_name (old_acle_idx), acle_comp);

	     do comp_idx = 1 to 3;			/* See if the non-null components match the current */
		if given_comp (comp_idx) ^= "" then	/* entry from the old ACL */
		     if given_comp (comp_idx) ^= acle_comp (comp_idx) then goto TRY_NEXT_OLD_ACLE;
		end;

	     used = "1"b;				/* We managed to use this particular command-line ACL name */
	     if ^used_bits (old_acle_idx) then do;	/* (and this is the first time, if true) */
		used_bits (old_acle_idx) = "1"b;

		if copy_matching_names then do;	/* For set or list, copy this term into the new ACL */
		     new_acl.count = new_acl.count + 1;
		     new_acl.access_name (new_acl.count) = old_acl.access_name (old_acle_idx);
		     new_acl.status_code (new_acl.count) = 0;
		     if (operation = SET) then
			new_acl.mode (new_acl.count) = convert_mode (acl_modes (name_idx));
		     else new_acl.mode (new_acl.count) = old_acl.mode (old_acle_idx);
		     end;
		end;
TRY_NEXT_OLD_ACLE:
	     end;

/* Now, we've finished checking this particular command-line name, and we decide what to tell our caller.
   For all operations, if the name matched anywhere, quit and return "1"b.  Then, for set_acl, if the name
   was complete (no missing components, like Klensin..*), return the used bit no matter what its value,
   and the caller will add the whole name to the new ACL if it didn't match here.  If neither of those
   cases apply, there is a genuine non-match, and except in -brief mode, we complain about it. After
   complaining, "1"b is always returned, since the name has seen all the use it will ever see. */

          if used then return ("1"b);

          if (operation = SET) & (^missing_component) then return (used);

          if ^brief_sw & (original_count > 0) then
               call complain (0, whoami,
                    "No match for ^a on ^[I^]ACL of ^a", acl_names (name_idx), iacl_sw, err_path);

          return ("1"b);
     end match_acl;

     end build_new_acl;
%page;
convert_mode:
     proc (mode_string) returns (bit (36) aligned);

declare	mode_string		char (36),
	(idx, jdx)		fixed bin,
	mode			bit (36) aligned;

	if mode_string = "null" | mode_string = "n" then return (""b);

	mode = ""b;
	do idx = 1 to length (rtrim (mode_string));
	     jdx = index (rtrim (si.modes), substr (mode_string, idx, 1));
	     if jdx = 0 then do;
		call complain (0, whoami, "Invalid mode^[ for ^a^;^s^]. ^a^[ on ^a^]", si.extended_acl,
		     si.plural_name, mode_string, (err_path ^= ""), err_path);
		goto SKIP_MATCH;
		end;
	     substr (mode, jdx, 1) = "1"b;
	     end;

	return (mode);
     end convert_mode;



mode_representation:
     procedure (mode_bits) returns (char (36) varying);

declare	mode_bits			bit (36) aligned parameter;

declare	bit_idx			fixed bin;
declare	mode_string		char (36) varying;


	if (mode_bits = ""b) then return ("null");

	mode_string = "";
	do bit_idx = 1 to length (rtrim (si.modes));
	     if (substr (mode_bits, bit_idx, 1) = "1"b) then
		mode_string = mode_string || substr (si.modes, bit_idx, 1);
	     end;

	return (mode_string);
     end mode_representation;
%page;
get_suffix_info:
     proc ();


	si.version = SUFFIX_INFO_VERSION_1;

	if ^(force_no_type | iacl_sw) then do;		/* Normal case */
	     call fs_util_$suffix_info (dname, ename, addr (si), code);
	     if (code = error_table_$not_seg_type) & ((type = MBX_ACL) | (type = MSEG_ACL)) then do;
		if ^star_sw then
		     call complain (0, whoami, "^a is not a ^[mailbox^;message segment^].", err_path,
			(type = MBX_ACL));
		goto SKIP_MATCH;
		end;

	     else if code = error_table_$unsupported_operation & operation = LIST then
		code = error_table_$noentry;
		     
	     if code ^= 0 then do;
		call complain (code, whoami, "^a", err_path);
		goto SKIP_MATCH;
		end;

	     if (operation = SET) & starname_suffix & (^si.standard_object) then goto SKIP_MATCH;
	     end;

	else do;					/* No-type forcing or IACL */
	     call hcs_$status_minf (dname, ename, 1, hcs_type, bit_count, code);
	     if code ^= 0 then goto SKIP_THIS_ONE;

/*
   since we want to reference the current entry as a standard one (seg, dir,
   msf, or dmf) and we have been able to get status info, we get info on ACL
   modes by calling fs_util_ with a given type.  the algorithm to do this is:

	if ENTRY_IS_A_DIRECTORY and WE_WANT_ITS_SEG_IACL
	then GET_SUFFIX_INFO_WITH_SEG_MODES_AND_DIRECTORY_TYPE
	else if ENTRY_IS_A_DIRECTORY and WE_WANT_ITS_DIR_IACL
	     then GET_SUFFIX_INFO_WITH_DIR_MODES_AND_DIR_TYPE
	     else if ENTRY_IS_A_DIRECTORY and WE_WANT_ITS_ACL
		then GET_SUFFIX_INFO_FOR_DIRS
		else if ENTRY_IS_A_MSF
		     then GET_SUFFIX_INFO_FOR_MSFS
		     else ENTRY_IS_A_SEG so GET_SUFFIX_INFO_FOR_SEGS
*/

	     if (hcs_type = DIRECTORY) & (bit_count = 0) then
		if (type = SEGMENT_IACL) then do;
		     call fs_util_$suffix_info_for_type (FS_OBJECT_TYPE_SEGMENT, addr (si), code);
		     si.type = FS_OBJECT_TYPE_DIRECTORY;
		     end;
		else if (type = DIRECTORY_IACL) then
		     call fs_util_$suffix_info_for_type (FS_OBJECT_TYPE_DIRECTORY, addr (si), code);
		else call fs_util_$suffix_info_for_type (FS_OBJECT_TYPE_DIRECTORY, addr (si), code);
	     else if (hcs_type = DIRECTORY)
		then call fs_util_$suffix_info_for_type (FS_OBJECT_TYPE_MSF, addr (si), code);
	     else call fs_util_$suffix_info_for_type (FS_OBJECT_TYPE_SEGMENT, addr (si), code);

	     if (code ^= 0) then do;
SKIP_THIS_ONE:
		call complain (code, whoami, "^a", err_path);
		goto SKIP_MATCH;
		end;
	     end;

	return;
     end get_suffix_info;
%page;
get_acl:
     procedure ();

dcl  list_acl_entry	entry variable options (variable);


	call free (other_acl_ptr);			/* Get rid of leftovers */
	call free (acl_ptr);

	if (object_type = FS_OBJECT_TYPE_DIRECTORY) & (type = SEGMENT_IACL) then do;
	     call hcs_$list_inacl (dname, ename, system_area_ptr, other_acl_ptr, (null ()), acl_count, iacl_ring, code);
	     call make_general_acl ("segment_array");
	     end;

	else if (object_type = FS_OBJECT_TYPE_DIRECTORY) & (type = DIRECTORY_IACL) then do;
	     call hcs_$list_dir_inacl (dname, ename, system_area_ptr, other_acl_ptr, (null ()), acl_count, iacl_ring,
		code);
	     call make_general_acl ("directory_array");
	     end;


	else if force_no_type then do;
	     call fs_util_$make_entry_for_type (object_type, "list_acl", list_acl_entry, code);
	     call list_acl_entry (dname, ename, GENERAL_ACL_VERSION_1, system_area_ptr, acl_ptr, code);

	     end;

	else call fs_util_$list_acl (dname, ename, GENERAL_ACL_VERSION_1, system_area_ptr, acl_ptr, code);

	if code ^= 0 then do;
	     call complain (code, whoami, "^a", err_path);
	     goto SKIP_MATCH;
	     end;

	call free (other_acl_ptr);			/* In case we had to allocate it */

	if (acl_ptr = null ()) then do;		/* Although the primitives always return a null pointer, */
	     acl_ptr = addr (empty_acl_overlay);	/* since we loop through ACL entries, this is easier to use */
	     acl_ptr -> general_acl.version = GENERAL_ACL_VERSION_1;
	     acl_ptr -> general_acl.count = 0;
	     end;

	acl_count = general_acl.count;

	return;
     end get_acl;
%page;
replace_the_acl:
     proc ();

dcl complained_about_specific_acl bit (1) aligned;
dcl idx fixed bin;

/* This procedure handles the various special cases, converting the ACL
   between various formats as needed. */


	other_acl_ptr = null ();

	if (object_type = FS_OBJECT_TYPE_DIRECTORY) then do;
	     if (type = SEGMENT_IACL) then do;
		call make_other_acl ("segment_array");
		call hcs_$replace_inacl (dname, ename, other_acl_ptr, acl_count, no_sysdaemon_sw, iacl_ring, code);
		call copy_acle_status ("segment");
		end;

	     else if (type = DIRECTORY_IACL) then do;
		call make_other_acl ("directory_array");
		call hcs_$replace_dir_inacl (dname, ename, other_acl_ptr, acl_count, no_sysdaemon_sw, iacl_ring, code)
		     ;
		call copy_acle_status ("directory");
		end;

	     else if (privilege = HPHCS) then do;
		call make_other_acl ("directory_array");
		call hphcs_$replace_dir_acl (dname, ename, other_acl_ptr, acl_count, no_sysdaemon_sw, code);
		call copy_acle_status ("directory");
		end;

	     else if (privilege = LIBRARY) then do;
		call make_other_acl ("directory_array");
		call installation_tools_$replace_dir_acl (dname, ename, other_acl_ptr, acl_count, no_sysdaemon_sw,
		     code);
		call copy_acle_status ("directory");
		end;

               else if force_no_type then do;
                    call make_other_acl ("directory_array");
                    call hcs_$replace_dir_acl (dname, ename, other_acl_ptr, acl_count, no_sysdaemon_sw, code);
                    call copy_acle_status ("directory");
                    end;

               else call fs_util_$replace_acl (dname, ename, acl_ptr, no_sysdaemon_sw, code);
	     end;

	else if (object_type = FS_OBJECT_TYPE_SEGMENT) then do;
	     if (privilege = HPHCS) then do;
		call make_other_acl ("segment_array");
		call hphcs_$replace_acl (dname, ename, other_acl_ptr, acl_count, no_sysdaemon_sw, code);
		call copy_acle_status ("segment");
		end;

	     else if (privilege = LIBRARY) then do;
		call make_other_acl ("segment_array");
		call installation_tools_$replace_acl (dname, ename, other_acl_ptr, acl_count, no_sysdaemon_sw, code);
		call copy_acle_status ("segment");
		end;

	     else if force_no_type then do;
		call make_other_acl ("segment_array");
		call hcs_$replace_acl (dname, ename, other_acl_ptr, acl_count, no_sysdaemon_sw, code);
		call copy_acle_status ("segment");
		end;

               else call fs_util_$replace_acl (dname, ename, acl_ptr, no_sysdaemon_sw, code);
	     end;

          else call fs_util_$replace_acl (dname, ename, acl_ptr, no_sysdaemon_sw, code);

	call free (other_acl_ptr);			/* If we made one, it's useless now */

	if code ^= 0 then do;
	     complained_about_specific_acl = "0"b;
	     if acl_ptr ^= null () then
		do idx = 1 to general_acl.count;
		if general_acl.status_code (idx) ^= 0 then do;
		     complained_about_specific_acl = "1"b;
		     call complain (general_acl.status_code (idx), whoami, "^a ^a on ^a", mode_representation (general_acl.mode (idx)), general_acl.access_name (idx), err_path);
		     end;
		end;
	     if ^complained_about_specific_acl then
		call complain (code, whoami, "^a", err_path);
	     goto SKIP_MATCH;
	     end;

	return;
     end replace_the_acl;

/*  */

list_the_acl:
     proc ();

declare	acle_idx			fixed bin;
declare	real_rings		(3) fixed bin (3);
declare	dir_rings			(2) fixed bin (3) based (addr (real_rings));
declare	rings			(si.num_ring_brackets) fixed bin (3) based (addr (real_rings));


	if star_sw then call ioa_ ("  ^a", err_path);

	if ring_bracket_sw then do;
               if si.num_ring_brackets = 0 then
                    call complain (0, whoami, "The ^a object type does not support ring brackets.", si.type_name);

               else if ^force_no_type then
                    call fs_util_$get_ring_brackets (dname, ename, rings, code);

               else if (object_type = FS_OBJECT_TYPE_MSF) then do;
                    call hcs_$get_ring_brackets (err_path, "0", rings, code);
                    if (code = error_table_$noentry) then
                         call hcs_$get_dir_ring_brackets (dname, ename, dir_rings, code);
                    end;

               else if (object_type = FS_OBJECT_TYPE_DIRECTORY) then
                    call hcs_$get_dir_ring_brackets (dname, ename, dir_rings, code);

               else call hcs_$get_ring_brackets (dname, ename, rings, code);

	     if code ^= 0 then call complain (code, whoami, "Getting ring brackets for ^a", err_path);
	     else if si.num_ring_brackets > 0 then
		call ioa_ ("^v(^d, ^)^d", si.num_ring_brackets - 1, rings, rings (si.num_ring_brackets));
	     end;

	if access_class_sw then do;
	     call hcs_$get_access_class (dname, ename, access_class, code);
	     if code ^= 0 then call complain (code, whoami, "^a", err_path);
	     call convert_authorization_$to_string_short (access_class, buffer, code);
	     if code ^= 0 then call complain (code, whoami, "^a", err_path);
	     if buffer = "" then buffer = "system_low";
	     call ioa_ ("^a", buffer);
	     end;

	if (original_count = 0) | (acl_ptr = null ()) then
	     if ^brief_sw then call complain (0, whoami, "Empty ^[^[segment ^;directory ^]I^;^s^]ACL for ^a.",
                                iacl_sw, (type = SEGMENT_IACL), err_path);

	do acle_idx = 1 to general_acl.count;
	     if (general_acl.status_code (acle_idx) ^= 0) then goto SKIP_THIS_ACLE;

	     if af_sw then do;
		if (length (ret_str) > 0) then ret_str = ret_str || " ";
		ret_str = ret_str || mode_representation (general_acl.mode (acle_idx));
		ret_str = ret_str || " ";
		ret_str = ret_str || rtrim (general_acl.access_name (acle_idx));
		end;

	     else call ioa_ ("^va^2x^a", max (4, si.max_mode_len), mode_representation (general_acl.mode (acle_idx)),
		     general_acl.access_name (acle_idx));

SKIP_THIS_ACLE:
	     end;

	if ^af_sw & (general_acl.count > 0) then call ioa_ ();

	return;
     end list_the_acl;
%page;
print_accessible:
     proc ();

declare	acle_idx			fixed bin;
declare	modes			bit (36) aligned;


	if use_access_modes then do;
	     if force_no_type then
		call hcs_$get_user_access_modes (dname, ename, access_name, -1, modes, (""b), code);
	     else call fs_util_$get_user_access_modes (dname, ename, access_name, -1, modes, (""b), code);

	     if code ^= 0 then do;
		call complain (code, whoami, "Listing access for ^a.", err_path);
		return;
		end;

	     if accessible = ((modes & acl_mask) ^= ""b) then
		call ioa_ ("^va^2x^a", max (4, si.max_mode_len), mode_representation (modes), ename);
	     end;

	else if (acl_count = 0) then do;
	     if ^accessible then call ioa_ ("^vx^a", si.max_mode_len + 2, ename);
	     end;

	else do;
	     do acle_idx = 1 to general_acl.count;
		if accessible = ((general_acl.mode (acle_idx) & acl_mask) ^= ""b) then
		     call ioa_ ("^va^2x^32a^a", max (4, si.max_mode_len),
			mode_representation (general_acl.mode (acle_idx)), ename,
			general_acl.access_name (acle_idx));
		end;
	     end;
	return;

     end print_accessible;

/**/

check_for_acle_errors:
     procedure ();

declare	acle_idx			fixed bin;


	if (operation = ACCESSIBLE) then return;	/* No errors possible here */

	do acle_idx = 1 to general_acl.count;
	     if (general_acl.status_code (acle_idx) = 0) then ;
	     else if brief_sw & (general_acl.status_code (acle_idx) = error_table_$user_not_found) then ;
	     else call complain (general_acl.status_code (acle_idx), whoami, "^a for ^a.",
		     general_acl.access_name (acle_idx), err_path);
	     end;

	return;
     end check_for_acle_errors;

/**/

set_components:
     proc (sc_access_name, sc_component);

declare	sc_access_name		char (*),
	sc_component		(3) char (32) aligned;

declare	(
	sc_dot_count		init (0),
	sc_dot_loc		(2) init ((2) 0),
	sc_i,
	sc_len
	)			fixed bin;

	sc_component (*) = "";
	if sc_access_name = "." then do;
	     sc_component (3) = "*";
	     sc_access_name = "..*";
	     return;
	     end;

	sc_len = index (sc_access_name, " ") - 1;
	if sc_len = -1 then sc_len = length (sc_access_name);
	else if verify (substr (sc_access_name, sc_len + 1), " ") ^= 0 then do;
BADNAME:
	     call complain (error_table_$bad_name, whoami, "^a", sc_access_name);
	     goto MAIN_RETURN;
	     end;

	do sc_i = 1 to sc_len;
	     if substr (sc_access_name, sc_i, 1) = "." then do;
		sc_dot_count = sc_dot_count + 1;
		if sc_dot_count > 2 then go to BADNAME;
		sc_dot_loc (sc_dot_count) = sc_i;
		end;
	     end;

	if sc_dot_count = 0 then do;
	     sc_component (1) = sc_access_name;
	     sc_component (2), sc_component (3) = "*";
	     substr (sc_access_name, sc_len + 1, 4) = ".*.*";
	     end;

	else if sc_dot_count = 1 then do;
	     if sc_dot_loc (1) = 1 then do;
		sc_component (2) = substr (sc_access_name, 2, sc_len - 1);
		sc_component (3) = "*";
		end;
	     else do;
		sc_component (1) = substr (sc_access_name, 1, sc_dot_loc (1) - 1);
		if sc_dot_loc (1) < sc_len then
		     sc_component (2) = substr (sc_access_name, sc_dot_loc (1) + 1, sc_len - sc_dot_loc (1));
		sc_component (3) = "*";
		end;
	     substr (sc_access_name, sc_len + 1, 2) = ".*";
	     end;

	else do;					/* sc_dot_count = 2 */
	     if sc_dot_loc (1) ^= 1 then sc_component (1) = substr (sc_access_name, 1, sc_dot_loc (1) - 1);
	     if sc_dot_loc (1) + 1 < sc_dot_loc (2) then
		sc_component (2) = substr (sc_access_name, sc_dot_loc (1) + 1, sc_dot_loc (2) - sc_dot_loc (1) - 1);
	     if sc_dot_loc (2) < sc_len then
		sc_component (3) = substr (sc_access_name, sc_dot_loc (2) + 1, sc_len - sc_dot_loc (2));
	     end;

	return;

     end set_components;

/**/

make_general_acl:
     procedure (acl_type);

declare	acl_type			char (32) parameter;


	call cv_acl_type_$create (other_acl_ptr, acl_count, system_area_ptr, acl_type, "general", acl_ptr);

	return;



make_other_acl:
     entry (acl_type);


	acl_count = general_acl.count;
	call cv_acl_type_$create (acl_ptr, acl_count, system_area_ptr, "general", acl_type, other_acl_ptr);

	return;
     end make_general_acl;



copy_acle_status:
     procedure (acl_type);

declare	acl_type			char (32) parameter;
declare	acle_idx			fixed bin;


	do acle_idx = 1 to general_acl.count;
	     if (acl_type = "directory") then
		general_acl.status_code (acle_idx) = other_acl_ptr -> directory_acl_array (acle_idx).status_code;
	     else general_acl.status_code (acle_idx) = other_acl_ptr -> segment_acl_array (acle_idx).status_code;
	     end;

	return;
     end copy_acle_status;

/**/

complain:
     procedure () options (variable);

declare   arg_list_ptr                  pointer;


          call cu_$arg_list_ptr (arg_list_ptr);
          if af_sw then
               call cu_$generate_call (active_fnc_err_, arg_list_ptr);
          else call cu_$generate_call (com_err_, arg_list_ptr);

          return;
          end complain;

/*  */

cleanup_handler:
     proc ();

	call free (acl_ptr);
	call free (old_acl_ptr);
	call free (new_acl_ptr);
	call free (other_acl_ptr);

	call free (used_bits_ptr);

	if (fcb_ptr ^= null ()) then call msf_manager_$close (fcb_ptr);

	call free (acl_names_ptr);
	call free (acl_modes_ptr);

	call free (star_names_ptr);
	call free (star_entry_ptr);
	if star_match_ptr ^= null () then call free (star_match_ptr);

	return;
     end cleanup_handler;



free:
     procedure (freeing_ptr);

declare	freeing_ptr		pointer parameter;
declare	based_stuff_ptr		pointer;
declare	based_stuff		fixed bin based;

/*
   we free by using based_stuff, because the freeing mechanism knows how
   much there is to free at the address to which the pointer points.
*/

	based_stuff_ptr = freeing_ptr;
	freeing_ptr = null ();

          if (based_stuff_ptr = addr (empty_acl_overlay)) then return;

	if (based_stuff_ptr ^= null ()) then free based_stuff_ptr -> based_stuff in (system_area);

	return;
     end free;

%page;
%include acl_structures;
%page;
%include star_structures;
%page;
%include suffix_info;
%page;
%include copy_flags;

     end nonquick_common;

     end common;

     end acl_commands_;
