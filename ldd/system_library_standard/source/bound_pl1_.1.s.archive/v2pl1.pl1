/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(87-03-05,Huen), approve(87-03-05,MCR7629), audit(87-04-15,RWaters),
     install(87-05-14,MR12.1-1030):
     Fix PL/1 errors 2141 -
     Print a warning message about the truncation of the listing segment name.
  2) change(88-08-23,RWaters), approve(88-08-23,MCR7914), audit(88-09-28,Huen),
     install(88-10-12,MR12.2-1163):
     Added the -no_prefix control argument.
  3) change(89-04-17,JRGray), approve(89-04-17,MCR8078), audit(89-04-18,Huen),
     install(89-06-09,MR12.3-1055):
     Modified to allow for archive component pathnames.
  4) change(89-08-01,RWaters), approve(89-08-01,MCR8069), audit(89-09-07,Vu),
     install(89-09-19,MR12.3-1068):
     Added the -version and -no_version control arguments.
                                                   END HISTORY COMMENTS */

/*	PL/I COMMAND.

	This command has been rewritten in PL/I and observes Standard
	Service System conventions.  Modelled after the Fortran S.S.S.
	command written by John Gintell.

	Written by:	J.D.Mills
	On:		26 September 1969
	Modified on:	16 October 1969, by JDM.
	Modified on:	30 October 1969, by JDM for multiple tree segments.
	Modified on:	13 November 1969, by JDM to call hcs_ directly.
	Modified on:	1 December 1969, by JDM to treat pre-expanded source correctly.
	Modified on:	5 December 1969, by BLW to print compilation times
	Modified on:	20 December 1969, by JDM for greater speed.
	Modified on:	28 January 1970 by BLW to use cu_
	Modified on:	18 March 1970 by BLW to call optimizer
	Modified on:	15 April 1970 by BLW for table option
	Modified on:	 8 July 1970 by BLW for new expand_
	Modified on:	16 July 1970 by BLW for epilogue
	Modified on:	22 July 1970 by BLW for token_list in tree_
	Modified on:	6 August 1970 by PAG to eliminate varying strings in calls to hcs_ and
			to check length of entry name and the suffix
	Modified on:	26 August 1970 by PAG for Version II
	Modified on:	18 September 1970 by PAG to optionally call semantic_translator
	Modified on:	27 September 1970 by PG to compute percentages in $times entry
	Modified on:	11 January 1971 by BLW to remove intermediate seg creation
			and change to pl1_stat_
	Modified on:	29 January 1971 by BLW to be full PL/2 command
	Modified on:	5 February l97l by PG for lexical stuff.
	Modified on:	13 April 1971 by BLW to get ptr to error messages
	Modified on:	7 August 1971 by PG to combine context_processor into parse
	Modified on:	21 August 1971 by PG to combine lex and create_token
	Modified on:	21 October 1971 by BLW to call code_gen_
	Modified on:	15 January 1972 by BLW for profile option
	Modified on:	28 March 1972 by BLW for storage use summary
	Modified on:	27 June 1972 by PG for tssi_, msf_manager_, prepare_symbol_table, and the link option
	Modified on:	21 August 1972 by PG for find_include_file_
	Modified on:	20 December 1972 by RAB for 2 segment tree
	Modified on:	23 June 1975 by EEW to recognize arg: -separate_static
	Modified on:	4 December 1975 by EEW to fix cleanup problems (bug 1434)
	Modified on:	14 April 1976 by RAB to use get_line_length_
	Modified on:	22 June 1976 by RHS to support the "new" area package, with full "retry"
	Modified on:	29 July 1976 by RAB to not allow control args of the form "- xxxxxx"
	Modified on:	1 Dec 1976 by RAB for -long_profile
	Modified on:	16 Feb 1977 by RAB for -check_ansi
	Modified on:	April 1977 by RHS to use standard areas
	Modified on:	770504 by PG for EIS lex
	Modified on:	14 June 1977 by RAB for pl1_stat_$defined_list
	Modified on:	770712 by PG for pl1_severity_
	Modified on:	17 October 1977 by RAB to fix bug 1681
	Modified on:	26 September 1978 by PCK to flag unaligned decimal for Release 25, not accept -source and
			-symbol control arguments, require a dash to precede every control argument,
			and print the Release number of the compiler.
	Modified on:	10 Feb 1978 by RAB to clean up printing out of tree and xeq_tree info.
	Modified on:	24 May 1979 by PCK to implement options(packed_decimal)
	Modified on:	26 May 1979 by D. Spector to add -single_symbol_list (-ssl) control arg.
	Modified on:	3 October 1979 by PCK to allow pl1_version to be
			bound with bound_pl1_ and rename pl1_error_messages_
	Modified on:	20 November 1979 by PCK to initialize cg_static_$in_prologue and
			cg_static_$in_thunk to "0"b (part of the fix to bug 1858)
	Modified on:	4 March 1980 by M. N. Davidoff to clean up, fix bugs 1874, 1876, 1904, 1907 and allow
			-source, -symbols (suggestion 1892).
	Modified on:	20 March 1980 by PCK to implement by name assignment
			and increase the default error message width
	Modified on:	17 April 1980 by M. N. Davidoff to use pl1_error_messages_ for installed compiler.
	Modified on:	23 September 1980 by M. N. Davidoff to print message when invoked as an active function
			(suggestion 1957) and did some restructuring to make planned modifications easier.
	Modified on:	16 October 1980 by M. N. Davidoff to move call to tree_manager$init to after the command
			argument parsing loop (2024), implement -long, -no_check, -no_check_ansi, -no_list,
			-no_optimize, -no_profile, -no_separate_static, -no_table, -no_debug, -no_time (1943), and to
			make -table the default unless -no_table, -brief_table or -optimize were specified (1946).
	Modified on:	24 October 1980 by M. N. Davidoff to implement -prefix (1947).
	Modified on:	19 November 1981 by C. Hornig to allow long_profile with separate_static.
	Modified on:	25 April 1983 by Rick Gray to call find_source_file_ which allows archive
			component pathnames.
   	Modified on:	28 August 1984 by JAFalksen to use date_time_$format ("date_time",...
          Modified on:        15 January 1987 by S. Huen to print a warning message about the truncation of the listing segment name.
          Modified on:	15 August 1988 by RWaters to accept the -no_prefix control argument.
	Modified on:	28 February 1989 by RWaters to accept -version and -no_version.
*/
/* format: style3,idind30 */
pl1exl:
v2pl1:
pl1:
     procedure options (variable);

/* automatic */

declare	argument_no		fixed bin;
declare	arg_count			fixed bin;
declare	arg_length		fixed bin (21);
declare	arg_ptr			ptr;
declare	bitcnt			fixed bin (24);
declare	1 blast_ca,
	  2 off			bit (1),
	  2 on			bit (1),
	  2 set			bit (1);
declare	blast_msg_len		fixed bin (21);
declare	blast_msg_ptr		ptr;
declare	1 ca			aligned,
	  2 no_optimize		bit (1),
	  2 optimize		bit (1),
	  2 no_table		bit (1),
	  2 brief_table		bit (1),
	  2 table			bit (1),
	  2 no_check		bit (1),
	  2 check			bit (1),
	  2 no_list		bit (1),
	  2 source		bit (1),
	  2 symbols		bit (1),
	  2 map			bit (1),
	  2 list			bit (1),
	  2 single_symbol_list	bit (1),
	  2 brief			bit (1),
	  2 long			bit (1),
	  2 severity		bit (1),
	  2 no_profile		bit (1),
	  2 profile		bit (1),
	  2 long_profile		bit (1),
	  2 no_separate_static	bit (1),
	  2 separate_static		bit (1),
	  2 no_check_ansi		bit (1),
	  2 check_ansi		bit (1),
	  2 no_time		bit (1),
	  2 time			bit (1),
	  2 no_debug		bit (1),
	  2 debug			bit (1),
	  2 debug_semant		bit (1),
	  2 debug_cg		bit (1),
	  2 no_cpdcls		bit (1),
	  2 cpdcls		bit (1),
	  2 no_link		bit (1),
	  2 link			bit (1),
	  2 prefix		bit (1),
	  2 no_version		bit (1);

declare	called_cg			bit (1) aligned;
declare	clock_time		fixed bin (71);
declare	code			fixed bin (35);
declare	component			fixed bin;
declare	fcb			ptr;
declare	i			fixed bin;
declare	in_cg			bit (1) aligned;
declare	len			fixed bin (21);
declare	list_hold			ptr;
declare	list_size			fixed bin (19);
declare	listname			char (32);
declare	lname			char (32) varying;
declare	object_hold		ptr;
declare	objectname		char (32);
declare	output_pt			ptr;
declare	pathname			char (256);
declare	pd_faults			fixed bin;
declare	1 prefix			aligned,
	  2 mask			bit (12),
	  2 conditions		bit (12);
declare	prefix_string_length	fixed bin (21);
declare	prefix_string_ptr		ptr;
declare	produce_listing		bit (1) aligned;
declare	source_seg		ptr;
declare	sourcename		char (32);
declare	symbols_on		bit (1) aligned;
declare	translation_failed		bit (1) aligned;
declare	wdirname			char (168);

/* based */

declare	arg_string		char (arg_length) based (arg_ptr);
declare	blast_msg			char (blast_msg_len) based (blast_msg_ptr);
declare	digit_pic			picture "9" based;
declare	prefix_string		char (prefix_string_length) based (prefix_string_ptr);
declare	source_string		char (len) based (source_seg);

/* builtin */

declare	(addrel, baseno, before, binary, char, clock, codeptr, convert, divide, index, hbound, lbound, length, ltrim,
	mod, null, rtrim, search, string, substr, verify)
				builtin;

/* condition */

declare	cleanup			condition;
declare	listing_overflow		condition;

/* internal static */

declare	HT_SP			char (2) internal static options (constant) initial ("	 ");
declare	HT_SP_COMMA		char (3) internal static options (constant) initial ("	 ,");
declare	blast_time		fixed bin (71) internal static initial (0);
declare	comptime			char (64) var internal static;
declare	error_messages		ptr internal static initial (null);
declare	my_name			char (3) internal static options (constant) initial ("pl1");
declare	ncpu			(0:7) fixed bin (71) internal static initial ((8) 0);
declare	npages			(0:7) fixed bin internal static;
declare	number_free_segs		fixed bin internal static;
declare	objectbc			fixed bin (24) internal static;
declare	phase_name		(7) char (9) internal static options (constant)
				initial ("setup", "parse", "semantics", "optimizer", "code gen", "listing",
				"cleanup");
declare	storage			(0:7) char (10) internal static initial ((8) (1)"         0");
declare	version			char (132) varying internal static;
declare	xeq_storage		(0:7) char (10) internal static initial ((8) (1)"         0");

/* external static */

declare	cg_static_$debug		bit (1) aligned external static;
declare	cg_static_$in_prologue	bit (1) aligned external static;
declare	cg_static_$in_thunk		bit (1) aligned external static;
declare	cg_static_$optimize		bit (1) aligned external static;
declare	cg_static_$separate_static	bit (1) aligned external static;
declare	cg_static_$stop_id		bit (27) external static;
declare	cg_static_$support		bit (1) aligned external static;
declare	error_table_$badopt		fixed bin (35) external static;
declare	error_table_$entlong	fixed bin (35) external static;
declare	error_table_$inconsistent	fixed bin (35) external static;
declare	error_table_$translation_failed
				fixed bin (35) external static;
declare	error_table_$zero_length_seg	fixed bin (35) external static;
declare	pl1_blast_$blast_message	char (64) varying external static;
declare	pl1_blast_$blast_on		bit (1) aligned external static;
declare	pl1_blast_$blast_time	fixed bin (71) external static;
declare	pl1_severity_		fixed bin (35) external static;
declare	pl1_stat_$abort_label	label external static;
declare	pl1_stat_$brief_error_mode	bit (1) aligned external static;
declare	pl1_stat_$by_name_free_list	ptr aligned external static;
declare	pl1_stat_$by_name_parts_free_list
				ptr aligned external static;
declare	pl1_stat_$by_name_parts_tree	ptr aligned external static;
declare	pl1_stat_$by_name_ref_list	ptr aligned external static;
declare	pl1_stat_$char_pos		fixed bin (21) external static;
declare	pl1_stat_$check_ansi	bit (1) aligned external static;
declare	pl1_stat_$compiler_invoked	bit (1) aligned external static;
declare	pl1_stat_$compiler_name	char (8) varying external static;
declare	pl1_stat_$constant_list	ptr external static;
declare	pl1_stat_$debug_semant	bit (1) aligned external static;
declare	pl1_stat_$defined_list	ptr external static;
declare	pl1_stat_$dummy_block	ptr external static;
declare	pl1_stat_$error_messages	ptr external static;
declare	pl1_stat_$error_width	fixed bin external static;
declare	pl1_stat_$generate_symtab	bit (1) aligned external static;
declare	pl1_stat_$greatest_severity	fixed bin external static;
declare	pl1_stat_$index		fixed bin external static;
declare	pl1_stat_$last_statement_id	bit (36) external static;
declare	pl1_stat_$line_count	fixed bin external static;
declare	pl1_stat_$list_ptr		ptr external static;
declare	pl1_stat_$listing_on	bit (1) aligned external static;
declare	pl1_stat_$max_list_size	fixed bin (21) external static;
declare	pl1_stat_$max_node_type	fixed bin external static;
declare	pl1_stat_$new_fortran_option	bit (1) aligned external static;
declare	pl1_stat_$node_name		(32) char (12) external static;
declare	pl1_stat_$node_size		(32) fixed bin external static;
declare	pl1_stat_$node_uses		(32) fixed bin external static;
declare	pl1_stat_$ok_list		ptr external static;
declare	pl1_stat_$optimize		bit (1) aligned external static;
declare	pl1_stat_$options		char (400) varying external static;
declare	pl1_stat_$options_packed_dec	bit (1) aligned external static;
declare	pl1_stat_$pathname		char (168) varying external static;
declare	pl1_stat_$phase		fixed bin external static;
declare	pl1_stat_$print_cp_dcl	bit (1) aligned external static;
declare	pl1_stat_$profile		bit (1) aligned external static;
declare	pl1_stat_$profile_length	fixed bin external static;
declare	pl1_stat_$root		ptr external static;
declare	pl1_stat_$seg_name		char (32) varying external static;
declare	pl1_stat_$severity_plateau	fixed bin external static;
declare	pl1_stat_$single_symbol_list	bit (1) aligned external static;
declare	pl1_stat_$stop_id		bit (27) external static;
declare	pl1_stat_$table		bit (1) aligned external static;
declare	pl1_stat_$temporary_list	ptr external static;
declare	pl1_stat_$tree_area_ptr	ptr external static;
declare	pl1_stat_$unaligned_dec	bit (1) aligned external static;
declare	pl1_stat_$use_old_area	bit (1) aligned external static;
declare	pl1_stat_$user_id		char (32) aligned external static;
declare	pl1_stat_$validate_proc	ptr external static;
declare	pl1_stat_$version		fixed bin external static;
declare	pl1_stat_$xeq_tree_area_ptr	ptr external static;
declare	pl1_version$pl1_release	char (3) varying external static;
declare	pl1_version$pl1_version	char (256) varying external static;

/* entry */

/* Parts of the compiler */

declare	code_gen_			entry (char (32) varying, char (3) varying, char (132) varying, ptr, ptr, ptr,
				ptr, ptr, ptr, fixed bin (71), fixed bin, bit (1) aligned, bit (1) aligned,
				bit (1) aligned, bit (1) aligned, bit (1) aligned, bit (1) aligned,
				bit (1) aligned, entry, entry, fixed bin (24), fixed bin, fixed bin (71),
				bit (1) aligned, ptr, bit (1) aligned, fixed bin, fixed bin (71), bit (1) aligned)
				;
declare	code_gen_$return_bit_count	entry (fixed bin (24), fixed bin, fixed bin (71), fixed bin, fixed bin (71));
declare	error_$finish		entry;
declare	lex$terminate_source	entry;
declare	optimizer			entry (ptr);
declare	parse			entry (ptr, char (*), 1 aligned, 2 bit (12), 2 bit (12));
declare	pl1_print$non_varying	entry (char (*) aligned, fixed bin);
declare	pl1_print$non_varying_nl	entry (char (*) aligned, fixed bin);
declare	pl1_print$varying_nl	entry (char (*) varying);
declare	pl1_signal_catcher		entry (ptr, char (*), ptr, ptr, bit (1) aligned);
declare	pl1_symbol_print		entry (ptr, bit (1) aligned, bit (1) aligned);
declare	prepare_symbol_table	entry (ptr);
declare	scan_token_table		entry;
declare	semantic_translator		entry;
declare	tree_manager$init		entry (label);
declare	tree_manager$truncate	entry;

/* Others */

declare	com_err_			entry options (variable);
declare	com_err_$suppress_name	entry options (variable);
declare	condition_		entry (char (*), entry);
declare	cu_$arg_count		entry (fixed bin, fixed bin (35));
declare	cu_$arg_ptr		entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
declare	cpu_time_and_paging_	entry (fixed bin, fixed bin (71), fixed bin);
declare	date_time_$format		entry (char (*), fixed bin (71), char (*), char (*)) returns (char (250) var);
declare	debug			entry options (variable);
declare	find_source_file_		entry (char (*), char (*), char (*), ptr, fixed bin (24), fixed bin (35));
declare	get_line_length_$switch	entry (ptr, fixed bin (35)) returns (fixed bin);
declare	get_group_id_		entry () returns (char (32));
declare	get_wdir_			entry () returns (char (168));
declare	hcs_$get_max_length_seg	entry (ptr, fixed bin (19), fixed bin (35));
declare	hcs_$make_ptr		entry (ptr, char (*), char (*), ptr, fixed bin (35));
declare	hcs_$terminate_noname	entry (ptr, fixed bin (35));
declare	hcs_$truncate_seg		entry (ptr, fixed bin (19), fixed bin (35));
declare	how_many_users		entry options (variable);
declare	ioa_			entry options (variable);
declare	ioa_$nnl			entry options (variable);
declare	msf_manager_$get_ptr	entry (ptr, fixed bin, bit (1), ptr, fixed bin (24), fixed bin (35));
declare	system_info_$installation_id	entry (char (*));
declare	tssi_$clean_up_file		entry (ptr, ptr);
declare	tssi_$clean_up_segment	entry (ptr);
declare	tssi_$finish_file		entry (ptr, fixed bin, fixed bin (24), bit (36) aligned, ptr, fixed bin (35));
declare	tssi_$finish_segment	entry (ptr, fixed bin (24), bit (36) aligned, ptr, fixed bin (35));
declare	tssi_$get_file		entry (char (*), char (*), ptr, ptr, ptr, fixed bin (35));
declare	tssi_$get_segment		entry (char (*), char (*), ptr, ptr, fixed bin (35));

/* format: style3,inddcls */

%include condition_name;
%include area_structures;
%include pl1_version;

/* program */

	pl1_severity_ = 5;

	call cu_$arg_count (arg_count, code);
	if code ^= 0
	then do;
		call com_err_ (code, my_name);
		return;
	     end;

	if pl1_stat_$compiler_invoked
	then do;
		call com_err_ (0, my_name, "The compiler has been invoked with a previous invocation suspended.");
		call com_err_ (error_table_$translation_failed, my_name,
		     "Attempt to invoke pl1 recursively. Use release first.");
		return;
	     end;

	call cpu_time_and_paging_ (npages (0), ncpu (0), pd_faults);

	do i = 1 to hbound (npages, 1);
	     npages (i) = -1;
	end;

	number_free_segs = 0;

	if error_messages = null
	then begin;
		declare	error_messages_name char (32);

		version = pl1_version$pl1_version;
		pl1_stat_$user_id = get_group_id_ ();

		if pl1_version$pl1_release = "EXL"
		then error_messages_name = "pl1exl_error_messages_";
		else error_messages_name = "pl1_error_messages_";

		call hcs_$make_ptr (codeptr (v2pl1), error_messages_name, "", error_messages, code);
		if code ^= 0
		then do;
			call com_err_ (code, my_name, "^a", error_messages_name);
			return;
		     end;
	     end;

	pl1_stat_$error_messages = error_messages;
	pl1_stat_$greatest_severity = 5;
	pl1_stat_$compiler_name = my_name;
	pl1_stat_$use_old_area = "0"b;

	do i = 1 to pl1_stat_$max_node_type;
	     pl1_stat_$node_uses (i) = 0;
	end;

	pl1_stat_$abort_label = abort_return;

	in_cg, called_cg, translation_failed, pl1_stat_$generate_symtab, pl1_stat_$last_statement_id,
	     pl1_stat_$new_fortran_option, pl1_stat_$unaligned_dec, pl1_stat_$options_packed_dec, cg_static_$support,
	     cg_static_$in_prologue, cg_static_$in_thunk = "0"b;

	pl1_stat_$error_width = get_line_length_$switch (null, code);

	pl1_stat_$validate_proc, pl1_stat_$constant_list, pl1_stat_$ok_list, pl1_stat_$dummy_block,
	     pl1_stat_$defined_list, pl1_stat_$by_name_free_list, pl1_stat_$by_name_parts_free_list,
	     pl1_stat_$by_name_parts_tree, pl1_stat_$by_name_ref_list, pl1_stat_$temporary_list = null;

	pl1_stat_$profile_length, pl1_stat_$index = 0;

	pl1_stat_$stop_id, cg_static_$stop_id = (27)"1"b;

	pl1_stat_$version = pl1_version;

/* Parse the command line arguments. */

	ca = ""b;
	argument_no = 0;
	do i = 1 to arg_count;
	     call cu_$arg_ptr (i, arg_ptr, arg_length, code);
	     if code ^= 0
	     then do;
		     call com_err_ (code, my_name, "Argument ^d.", i);
		     return;
		end;

	     if index (arg_string, "-") = 1
	     then if arg_string = "-no_optimize" | arg_string = "-not"
		then do;
			ca.no_optimize = "1"b;
			ca.optimize = "0"b;
		     end;

		else if arg_string = "-optimize" | arg_string = "-ot"
		then do;
			ca.no_optimize = "0"b;
			ca.optimize = "1"b;
		     end;

		else if arg_string = "-no_table" | arg_string = "-ntb"
		then do;
			ca.no_table = "1"b;
			ca.brief_table = "0"b;
			ca.table = "0"b;
		     end;

		else if arg_string = "-brief_table " | arg_string = "-bftb"
		then do;
			ca.no_table = "0"b;
			ca.brief_table = "1"b;
			ca.table = "0"b;
		     end;

		else if arg_string = "-table" | arg_string = "-tb"
		then do;
			ca.no_table = "0"b;
			ca.brief_table = "0"b;
			ca.table = "1"b;
		     end;

		else if arg_string = "-no_check" | arg_string = "-nck"
		then do;
			ca.no_check = "1"b;
			ca.check = "0"b;
		     end;

		else if arg_string = "-check" | arg_string = "-ck"
		then do;
			ca.no_check = "0"b;
			ca.check = "1"b;
		     end;

		else if arg_string = "-no_list" | arg_string = "-nls"
		then do;
			ca.no_list = "1"b;
			ca.source = "0"b;
			ca.symbols = "0"b;
			ca.map = "0"b;
			ca.list = "0"b;
			ca.single_symbol_list = "0"b;
		     end;

		else if arg_string = "-source" | arg_string = "-sc"
		then do;
			ca.no_list = "0"b;
			ca.source = "1"b;
		     end;

		else if arg_string = "-symbols" | arg_string = "-sb"
		then do;
			ca.no_list = "0"b;
			ca.symbols = "1"b;
		     end;

		else if arg_string = "-map"
		then do;
			ca.no_list = "0"b;
			ca.map = "1"b;
		     end;

		else if arg_string = "-list" | arg_string = "-ls"
		then do;
			ca.no_list = "0"b;
			ca.list = "1"b;
		     end;

		else if arg_string = "-single_symbol_list" | arg_string = "-ssl"
		then do;
			ca.no_list = "0"b;
			ca.single_symbol_list = "1"b;
		     end;

		else if arg_string = "-brief" | arg_string = "-bf"
		then do;
			ca.brief = "1"b;
			ca.long = "0"b;
		     end;

		else if arg_string = "-long" | arg_string = "-lg"
		then do;
			ca.brief = "0"b;
			ca.long = "1"b;
		     end;

		else if index (arg_string, "-severity") = 1
		then if ^parse_severity (arg_string, "-severity")
		     then return;
		     else ;

		else if index (arg_string, "-sv") = 1
		then if ^parse_severity (arg_string, "-sv")
		     then return;
		     else ;

		else if arg_string = "-no_profile" | arg_string = "-npf"
		then do;
			ca.no_profile = "1"b;
			ca.profile = "0"b;
			ca.long_profile = "0"b;
		     end;

		else if arg_string = "-profile" | arg_string = "-pf"
		then do;
			ca.no_profile = "0"b;
			ca.profile = "1"b;
			ca.long_profile = "0"b;
		     end;

		else if arg_string = "-long_profile" | arg_string = "-lpf"
		then do;
			ca.no_profile = "0"b;
			ca.profile = "0"b;
			ca.long_profile = "1"b;
		     end;

		else if arg_string = "-no_separate_static" | arg_string = "-nss"
		then do;
			ca.no_separate_static = "1"b;
			ca.separate_static = "0"b;
		     end;

		else if arg_string = "-separate_static" | arg_string = "-ss"
		then do;
			ca.no_separate_static = "0"b;
			ca.separate_static = "1"b;
		     end;

		else if arg_string = "-no_check_ansi"
		then do;
			ca.no_check_ansi = "1"b;
			ca.check_ansi = "0"b;
		     end;

		else if arg_string = "-check_ansi"
		then do;
			ca.no_check_ansi = "0"b;
			ca.check_ansi = "1"b;
		     end;

		else if arg_string = "-no_time" | arg_string = "-ntm"
		then do;
			ca.no_time = "1"b;
			ca.time = "0"b;
		     end;

		else if arg_string = "-time" | arg_string = "-tm"
		then do;
			ca.no_time = "0"b;
			ca.time = "1"b;
		     end;

		else if arg_string = "-no_debug" | arg_string = "-ndb"
		then do;
			ca.no_debug = "1"b;
			ca.debug = "0"b;
			ca.debug_semant = "0"b;
			ca.debug_cg = "0"b;
		     end;

		else if arg_string = "-debug" | arg_string = "-db"
		then do;
			ca.no_debug = "0"b;
			ca.debug = "1"b;
		     end;

		else if arg_string = "-debug_semant" | arg_string = "-dbse"
		then do;
			ca.no_debug = "0"b;
			ca.debug_semant = "1"b;
		     end;

		else if arg_string = "-debug_cg" | arg_string = "-dbcg"
		then do;
			ca.no_debug = "0"b;
			ca.debug_cg = "1"b;
		     end;

		else if arg_string = "-no_cpdcls"
		then do;
			ca.no_cpdcls = "1"b;
			ca.cpdcls = "0"b;
		     end;

		else if arg_string = "-cpdcls"
		then do;
			ca.no_cpdcls = "0"b;
			ca.cpdcls = "1"b;
		     end;

		else if arg_string = "-no_link" | arg_string = "-nlk"
		then do;
			ca.no_link = "1"b;
			ca.link = "0"b;
		     end;

		else if arg_string = "-link" | arg_string = "-lk"
		then do;
			ca.no_link = "0"b;
			ca.link = "1"b;
		     end;

		else if arg_string = "-version"
		then do;
			ca.no_version = "0"b;
		     end;

		else if arg_string = "-no_version"
		then do;
			ca.no_version = "1"b;
		     end;
		else if arg_string = "-no_prefix"
		then do;
			ca.prefix = "0"b;
		     end;

		else if arg_string = "-prefix"
		then do;
			i = i + 1;
			if i > arg_count
			then do;
				call com_err_ (0, my_name, "Missing prefix string after -prefix.");
				return;
			     end;

			call cu_$arg_ptr (i, prefix_string_ptr, prefix_string_length, code);
			if code ^= 0
			then do;
				call com_err_ (code, my_name, "Argument ^d.", i);
				return;
			     end;

			ca.prefix = "1"b;
		     end;

		else do;
			call com_err_ (error_table_$badopt, my_name, "^a", arg_string);
			return;
		     end;

	     else do;
		     argument_no = argument_no + 1;
		     if argument_no = 1		/* process pathname later */
		     then pathname = arg_string;
		end;
	end;

	if argument_no ^= 1
	then do;
		if arg_count > 1 | ca.no_version
		then call com_err_$suppress_name (0, my_name, "Usage: ^a path {-control_args}", my_name);
		else do;				/* identify version of compiler */
			if pl1_version$pl1_release = "EXL"
			then call ioa_ ("^a", pl1_version$pl1_version);
			else call ioa_ ("PL/1 ^a", pl1_version$pl1_release);
		     end;
		return;
	     end;

/* Apply defaults. */

	if ^ca.no_table & ^ca.brief_table & ^ca.optimize
	then ca.table = "1"b;

/* We now know what options were specified. */

	pl1_stat_$options = "";

	pl1_stat_$optimize, cg_static_$optimize = ca.optimize;
	if ca.optimize
	then pl1_stat_$options = pl1_stat_$options || " optimize";

	if ca.brief_table
	then pl1_stat_$options = pl1_stat_$options || " brief_table";

	pl1_stat_$table = ca.table;
	if ca.table
	then pl1_stat_$options = pl1_stat_$options || " table";

	if ca.check
	then pl1_stat_$options = pl1_stat_$options || " check";

	if ca.source
	then pl1_stat_$options = pl1_stat_$options || " source";

	if ca.symbols
	then pl1_stat_$options = pl1_stat_$options || " symbols";

	if ca.map
	then pl1_stat_$options = pl1_stat_$options || " map";

	if ca.list
	then pl1_stat_$options = pl1_stat_$options || " list";

	pl1_stat_$single_symbol_list = ca.single_symbol_list;
	if ca.single_symbol_list
	then pl1_stat_$options = pl1_stat_$options || " single_symbol_list";

	symbols_on = ca.symbols | ca.map | ca.list | ca.single_symbol_list;
	produce_listing, pl1_stat_$listing_on = ca.source | symbols_on;

	pl1_stat_$brief_error_mode = ca.brief;

	if ca.severity
	then pl1_stat_$options = pl1_stat_$options || " severity" || convert (digit_pic, pl1_stat_$severity_plateau);
	else pl1_stat_$severity_plateau = 1;

	if ca.profile
	then pl1_stat_$options = pl1_stat_$options || " profile";

	if ca.long_profile
	then pl1_stat_$options = pl1_stat_$options || " long_profile";

	pl1_stat_$profile = ca.profile | ca.long_profile;

	cg_static_$separate_static = ca.separate_static;
	if ca.separate_static
	then pl1_stat_$options = pl1_stat_$options || " separate_static";

	pl1_stat_$check_ansi = ca.check_ansi;

	pl1_stat_$print_cp_dcl = ca.cpdcls;
	if ca.cpdcls
	then pl1_stat_$options = pl1_stat_$options || " cpdcls";

	cg_static_$debug = ca.debug | ca.debug_semant | ca.debug_cg;
	pl1_stat_$debug_semant = ca.debug_semant;

	if ca.link
	then pl1_stat_$options = pl1_stat_$options || " link";

	if ca.no_version
	then ;
	else do;
		if pl1_version$pl1_release = "EXL"
		then call ioa_ ("^a", pl1_version$pl1_version);
		else call ioa_ ("PL/1 ^a", pl1_version$pl1_release);
	     end;

	prefix = ""b;
	if ca.prefix
	then if ^parse_prefix (prefix_string)
	     then return;

	pl1_stat_$options = ltrim (pl1_stat_$options);

/* Find the source file. */
	call find_source_file_ (pathname, "pl1", sourcename, source_seg, bitcnt, code);
	if source_seg = null
	then do;
		call com_err_ (code, my_name, "^a", pathname);
		return;
	     end;

	if bitcnt = 0
	then do;
		call com_err_ (error_table_$zero_length_seg, my_name, "^a", pathname);
		call hcs_$terminate_noname (source_seg, code);
		return;
	     end;

	objectname = before (sourcename || " ", ".pl1 ");
	objectname = before (objectname, ".ex ");
	pl1_stat_$pathname = pathname;
	pl1_stat_$seg_name = rtrim (objectname);

	len = divide (bitcnt + 8, 9, 21);

	if pl1_blast_$blast_on
	then if pl1_blast_$blast_time > blast_time
	     then do;
		     call ioa_ ("^a", pl1_blast_$blast_message);
		     blast_time = clock ();
		end;

	wdirname = get_wdir_ ();
	clock_time = clock ();
	comptime = date_time_$format ("date_time", clock_time, "", "");

	list_hold = null;
	object_hold = null;

	on cleanup
	     begin;
		if ^cg_static_$debug
		then call truncate;

		pl1_stat_$compiler_invoked = "0"b;
	     end;

	if produce_listing
	then begin;
		declare	installation_id	char (32);

		component = 0;
		lname = rtrim (objectname);
		if length (lname) > 27
		then call com_err_ (error_table_$entlong, my_name,
			"The name of the listing segment is truncated to ^a.lis", lname);

		listname = lname || ".list";

		call tssi_$get_file (wdirname, listname, pl1_stat_$list_ptr, list_hold, fcb, code);
		if pl1_stat_$list_ptr = null
		then do;
			call com_err_ (code, my_name, "^a^[>^]^a", wdirname, wdirname ^= ">", listname);
			call hcs_$terminate_noname (source_seg, code);
			return;
		     end;

		call hcs_$get_max_length_seg (pl1_stat_$list_ptr, list_size, code);
		if code ^= 0
		then do;
			call com_err_ (code, my_name, "^a^[>^]^a", wdirname, wdirname ^= ">", listname);
			call hcs_$terminate_noname (source_seg, code);
			return;
		     end;

		pl1_stat_$max_list_size = 4 * list_size;
		pl1_stat_$char_pos = 1;

		call pl1_print$non_varying_nl ("	COMPILATION LISTING OF SEGMENT " || rtrim (objectname), 0);
		call pl1_print$non_varying_nl ("	Compiled by: " || pl1_version$pl1_version, 0);

		call system_info_$installation_id (installation_id);
		call pl1_print$non_varying_nl ("	Compiled at: " || installation_id, 0);
		call pl1_print$non_varying_nl ("	Compiled on: " || comptime, 0);

		if length (pl1_stat_$options) > 0
		then do;
			call pl1_print$non_varying ("	    Options: ", 0);
			call pl1_print$varying_nl (pl1_stat_$options);
		     end;

		call pl1_print$non_varying_nl ("", 0);
	     end;

	if produce_listing
	then on listing_overflow
		begin;
		     declare   component_bit_count fixed binary (24);

		     component = component + 1;

		     call msf_manager_$get_ptr (fcb, component, "1"b /* create */, pl1_stat_$list_ptr,
			component_bit_count, code);

		     if pl1_stat_$list_ptr ^= null
		     then call hcs_$get_max_length_seg (pl1_stat_$list_ptr, list_size, code);

		     if pl1_stat_$list_ptr = null | code ^= 0
		     then do;
			     call com_err_ (code, my_name, "Component ^d of ^a^[>^]^a", component, wdirname,
				wdirname ^= ">", listname);

			     if in_cg
			     then call code_gen_$return_bit_count (objectbc, npages (5), ncpu (5), npages (6),
				     ncpu (6));

			     translation_failed = "1"b;
			     goto close_list;
			end;

		     pl1_stat_$max_list_size = 4 * list_size;
		     pl1_stat_$char_pos = 1;
		end;

/* Call the phases of pl1. */

	call tree_manager$init (pl1_stat_$abort_label);

	pl1_stat_$phase = 1;
	pl1_severity_, pl1_stat_$greatest_severity = 0;
	pl1_stat_$compiler_invoked = "1"b;

	call condition_ ("any_other", pl1_signal_catcher);

	call cpu_time_and_paging_ (npages (1), ncpu (1), pd_faults);

	call parse (pl1_stat_$root, source_string, prefix);

	call cpu_time_and_paging_ (npages (2), ncpu (2), pd_faults);
	call set_storage_usage (storage (2), xeq_storage (2));

	if ca.debug_semant
	then do;
		call ioa_$nnl ("Beginning semantic translator.^/debug: ");
		call debug;
	     end;

	pl1_stat_$phase = 2;
	call semantic_translator;
	call scan_token_table;

	call cpu_time_and_paging_ (npages (3), ncpu (3), pd_faults);
	call set_storage_usage (storage (3), xeq_storage (3));

	if ^ca.check
	then call generate_code (translation_failed);

continue_from_abort:
	if translation_failed
	then call com_err_ (error_table_$translation_failed, my_name, "^a", sourcename);

	if ^called_cg
	then do;
		call cpu_time_and_paging_ (npages (5), ncpu (5), pd_faults);
		npages (6) = npages (5);
		ncpu (6) = ncpu (5);
	     end;

	if produce_listing
	then do;
		if ^called_cg
		then do;
			if symbols_on
			then call pl1_symbol_print (pl1_stat_$root, pl1_stat_$print_cp_dcl,
				ca.check | translation_failed | pl1_stat_$greatest_severity >= 3);

			call pl1_print$non_varying_nl ("", 0);

			if pl1_stat_$greatest_severity > 0
			then call error_$finish;
		     end;

close_list:
		call tssi_$finish_file (fcb, component, 9 * pl1_stat_$char_pos - 9, "101"b, list_hold, code);
		if code ^= 0
		then call com_err_ (code, my_name, "^a^[>^]^a", wdirname, wdirname ^= ">", listname);
	     end;

	if ^ca.check & ^translation_failed
	then do;
		call hcs_$truncate_seg (output_pt, divide (objectbc + 35, 36, 19), code);
		if code ^= 0
		then call com_err_ (code, my_name, "^a^[>^]^a", wdirname, wdirname ^= ">", objectname);

		call tssi_$finish_segment (output_pt, objectbc, "110"b, object_hold, code);
		if code ^= 0
		then call com_err_ (code, my_name, "^a^[>^]^a", wdirname, wdirname ^= ">", objectname);
	     end;

	call cpu_time_and_paging_ (npages (7), ncpu (7), pd_faults);
	call set_storage_usage (storage (5), xeq_storage (5));

	storage (6), storage (7) = storage (5);
	xeq_storage (6), xeq_storage (7) = xeq_storage (5);

	if ^cg_static_$debug
	then call truncate;

	pl1_severity_ = pl1_stat_$greatest_severity;

	pl1_stat_$compiler_invoked = "0"b;

	if ca.time
	then call print_times;

	return;

abort_return:
	call com_err_ (0, my_name, "An unrecoverable error has occurred.");
	translation_failed = "1"b;
	goto continue_from_abort;

times:
     entry options (variable);

	call cu_$arg_count (arg_count, code);
	if code ^= 0
	then do;
		call com_err_ (code, my_name);
		return;
	     end;

	if arg_count ^= 0
	then do;
		call com_err_$suppress_name (0, my_name, "Usage: ^a$times", my_name);
		return;
	     end;

	call print_times;

	return;

clean_up:
     entry options (variable);

	call cu_$arg_count (arg_count, code);
	if code ^= 0
	then do;
		call com_err_ (code, my_name);
		return;
	     end;

	if arg_count ^= 0
	then do;
		call com_err_$suppress_name (0, my_name, "Usage: ^a$clean_up", my_name);
		return;
	     end;

	object_hold = null;
	list_hold = null;

	call truncate;
	pl1_stat_$compiler_invoked = "0"b;

	return;

blast:
     entry options (variable);

	call cu_$arg_count (arg_count, code);
	if code ^= 0
	then do;
		call com_err_ (code, my_name);
		return;
	     end;

	string (blast_ca) = ""b;
	argument_no = 0;
	do i = 1 to arg_count;
	     call cu_$arg_ptr (i, arg_ptr, arg_length, code);
	     if code ^= 0
	     then do;
		     call com_err_ (code, my_name, "Argument ^d.", i);
		     return;
		end;

	     if arg_string = "-on"
	     then do;
		     blast_ca.on = "1"b;
		     blast_ca.off = "0"b;
		end;

	     else if arg_string = "-off"
	     then do;
		     blast_ca.on = "0"b;
		     blast_ca.off = "1"b;
		end;

	     else if arg_string = "-set"
	     then do;
		     i = i + 1;
		     if i > arg_count
		     then do;
			     call com_err_ (0, my_name, "Missing blast message after -set.");
			     return;
			end;

		     call cu_$arg_ptr (i, blast_msg_ptr, blast_msg_len, code);
		     if code ^= 0
		     then do;
			     call com_err_ (code, my_name, "Argument ^d.", i);
			     return;
			end;

		     blast_ca.set = "1"b;
		end;

	     else if index (arg_string, "-") = 1
	     then do;
		     call com_err_ (error_table_$badopt, my_name, "^a", arg_string);
		     return;
		end;

	     else argument_no = argument_no + 1;
	end;

	if argument_no ^= 0 | string (blast_ca) = ""b
	then do;
		call com_err_$suppress_name (0, my_name, "Usage: ^a$blast -control_args", my_name);
		return;
	     end;

	if blast_ca.set & (blast_ca.on | blast_ca.off)
	then do;
		call com_err_ (error_table_$inconsistent, my_name, "-set and -^[on^;off^]", blast_ca.on);
		return;
	     end;

	if blast_ca.on
	then pl1_blast_$blast_on = "1"b;

	else if blast_ca.off
	then pl1_blast_$blast_on = "0"b;

	else if blast_ca.set
	then do;
		pl1_blast_$blast_on = "0"b;
		pl1_blast_$blast_message = blast_msg;
		pl1_blast_$blast_time = clock ();
		pl1_blast_$blast_on = "1"b;
	     end;

	call ioa_ ("Accepted.");

	return;

parse_severity:
     procedure (arg_string, prefix) returns (bit (1) aligned);

	declare	arg_string	char (*);
	declare	prefix		char (*);

	declare	severity		fixed bin;

	if length (rtrim (arg_string)) = length (prefix) + 1
	then severity = index ("1234", substr (arg_string, length (prefix) + 1, 1));
	else severity = 0;

	if severity = 0
	then do;
		call com_err_ (0, my_name, "Invalid severity level. ^a", arg_string);
		return ("0"b);
	     end;

	ca.severity = "1"b;
	pl1_stat_$severity_plateau = severity;

	return ("1"b);
     end parse_severity;

parse_prefix:
     procedure (prefix_string) returns (bit (1) aligned);

	declare	prefix_string	char (*);

	declare	scan_position	fixed bin (21);

	scan_position = verify (prefix_string, HT_SP);
	if scan_position = 0
	then return ("1"b);

	pl1_stat_$options = pl1_stat_$options || " prefix(";

	if ^parse_condition_name ()
	then return ("0"b);
	do while (scan_position <= length (prefix_string));
	     if substr (prefix_string, scan_position, 1) ^= ","
	     then do;
		     call com_err_ (0, my_name, "Missing comma between condition names. ^a", prefix_string);
		     return ("0"b);
		end;

	     scan_position = scan_position + 1;

	     if ^parse_condition_name ()
	     then return ("0"b);
	end;

	pl1_stat_$options = pl1_stat_$options || ")";

	return ("1"b);

parse_condition_name:
     procedure returns (bit (1) aligned);

	declare	enabled		bit (1) aligned;
	declare	i		fixed bin;
	declare	token_length	fixed bin (21);
	declare	token_start	fixed bin (21);

	call skip_white_space;

	token_length = search (substr (prefix_string, scan_position), HT_SP_COMMA) - 1;
	if token_length < 0
	then token_length = length (substr (prefix_string, scan_position));

	if token_length = 0
	then do;
		call com_err_ (0, my_name, "Missing condition name. ^a", prefix_string);
		return ("0"b);
	     end;

	token_start = scan_position;
	scan_position = scan_position + token_length;

	enabled = index (substr (prefix_string, token_start, token_length), "no") ^= 1;
	if ^enabled
	then do;
		token_start = token_start + length ("no");
		token_length = token_length - length ("no");
	     end;

	do i = lbound (condition_name, 1) to hbound (condition_name, 1)
	     while (condition_name (i) ^= substr (prefix_string, token_start, token_length));
	end;

	if i > hbound (condition_name, 1)
	then do;
		call com_err_ (0, my_name, "Invalid condition name. ^[no^]^a", ^enabled,
		     substr (prefix_string, token_start, token_length));
		return ("0"b);
	     end;

/* The variable i never equals 10.  This takes advantage of the condition_name
   array encoding.  This is the same algorithm that statement_type uses.  The
   long names and short names of the conditions are stored in the same array.
   The indices of the long name and the short name differ by 10.  The size
   condition has the same long name and short name. */

	i = mod (i, 10);

	if substr (prefix.mask, i, 1)
	then if substr (prefix.conditions, i, 1) ^= enabled
	     then do;
		     call com_err_ (0, my_name,
			"A condition may not be enabled and disabled in the prefix string. ^a", condition_name (i));
		     return ("0"b);
		end;
	     else ;
	else do;
		substr (prefix.mask, i, 1) = "1"b;
		substr (prefix.conditions, i, 1) = enabled;

		if substr (pl1_stat_$options, length (pl1_stat_$options)) ^= "("
		then pl1_stat_$options = pl1_stat_$options || ",";

		if ^enabled
		then pl1_stat_$options = pl1_stat_$options || "no";

		pl1_stat_$options = pl1_stat_$options || rtrim (condition_name (i));
	     end;

	call skip_white_space;

	return ("1"b);

skip_white_space:
     procedure;

	declare	scan_length	fixed bin (21);

	scan_length = verify (substr (prefix_string, scan_position), HT_SP) - 1;
	if scan_length < 0
	then scan_length = length (substr (prefix_string, scan_position));

	scan_position = scan_position + scan_length;
     end skip_white_space;

     end parse_condition_name;

     end parse_prefix;

generate_code:
     procedure (translation_failed);

	declare	translation_failed	bit (1) aligned;

	translation_failed = "0"b;

	if pl1_stat_$greatest_severity >= 3
	then do;
		call com_err_ (0, my_name, "An error of severity ^d has occurred.", pl1_stat_$greatest_severity);

		if ca.debug_cg
		then do;
			call ioa_$nnl ("debug for -debug_cg: ");
			call debug;
		     end;

		translation_failed = "1"b;
		return;
	     end;

	if pl1_stat_$table | pl1_stat_$generate_symtab
	then do;
		pl1_stat_$phase = 3;
		call prepare_symbol_table (pl1_stat_$root);
	     end;

	if ca.optimize
	then do;
		pl1_stat_$phase = 4;
		call optimizer (pl1_stat_$root);
	     end;

	call cpu_time_and_paging_ (npages (4), ncpu (4), pd_faults);
	call set_storage_usage (storage (4), xeq_storage (4));

	call tssi_$get_segment (wdirname, objectname, output_pt, object_hold, code);
	if output_pt = null
	then do;
		call com_err_ (code, my_name, "^a^[>^]^a", wdirname, wdirname ^= ">", objectname);
		translation_failed = "1"b;
		return;
	     end;

	if baseno (output_pt) = baseno (source_seg)
	then do;
		call com_err_ (0, my_name,
		     "The source segment is the same as the object segment. It has been truncated. ^a", pathname);
		translation_failed = "1"b;
		return;
	     end;

	if ^ca.profile & ^ca.long_profile
	then pl1_stat_$profile_length = 0;

	if ca.debug_cg
	then do;
		call ioa_$nnl ("Beginning code generator.^/debug: ");
		call debug;
	     end;

	in_cg = "1"b;
	pl1_stat_$phase = 5;

	call code_gen_ (pl1_stat_$seg_name, (my_name), version, pl1_stat_$root, pl1_stat_$validate_proc,
	     pl1_stat_$temporary_list, pl1_stat_$constant_list, pl1_stat_$ok_list, output_pt, clock_time,
	     pl1_stat_$profile_length, produce_listing, symbols_on, pl1_stat_$print_cp_dcl, ca.map, ca.list,
	     pl1_stat_$table, pl1_stat_$generate_symtab, pl1_symbol_print, error_$finish, objectbc, npages (5),
	     ncpu (5), ca.link, pl1_stat_$dummy_block, ca.brief_table, npages (6), ncpu (6), ca.long_profile);

	in_cg = "0"b;
	called_cg = "1"b;
     end generate_code;

print_times:
     procedure;

	declare	need_nl		bit (1) aligned;
	declare	tx		float bin;
	declare	ty		float bin;

	ty = -1e0;
	do i = hbound (ncpu, 1) to 1 by -1 while (ty < 0e0);
	     ty = ncpu (i) - ncpu (0);
	end;

	if ty <= 0e0
	then do;
		call com_err_ (0, my_name, "No times available.");
		return;
	     end;

	call ioa_ ("^/Segment ^a (^d lines) was compiled by ^a on ^a", pl1_stat_$seg_name, pl1_stat_$line_count,
	     my_name, comptime);

	call how_many_users;

	call ioa_ ("^/Phase          CPU    %   Pages      Tree     Xeq_tree");

	do i = 1 to hbound (npages, 1);
	     if npages (i) < 0
	     then do;
		     ncpu (i) = ncpu (i - 1);
		     npages (i) = npages (i - 1);
		     storage (i) = storage (i - 1);
		     xeq_storage (i) = xeq_storage (i - 1);
		end;

	     tx = ncpu (i) - ncpu (i - 1);
	     call ioa_ ("^9a^9.3f^6.1f^6d ^10a ^10a", phase_name (i), tx / 1.0e6, 1.0e2 * tx / ty,
		npages (i) - npages (i - 1), storage (i), xeq_storage (i));
	end;

	call ioa_ ("TOTAL    ^9.3f      ^6d", ty / 1.0e6, npages (7) - npages (0));

	call ioa_ ("^/Summary of node usage in ^d free segments^/", number_free_segs);
	call ioa_ ((2)"NODE TYPE   NUMBER  SIZE   TOTAL^8x");

	need_nl = "0"b;
	do i = 1 to pl1_stat_$max_node_type;
	     if pl1_stat_$node_uses (i) ^= 0
	     then do;
		     call ioa_$nnl ("^12a^6d^6d^8d^[^/^;^8x^]", pl1_stat_$node_name (i), pl1_stat_$node_uses (i),
			pl1_stat_$node_size (i), pl1_stat_$node_uses (i) * pl1_stat_$node_size (i), need_nl);
		     need_nl = ^need_nl;
		end;
	end;

	call ioa_ ("^[^/^]", need_nl);
     end print_times;

truncate:
     procedure;

	call lex$terminate_source;
	call tree_manager$truncate;

	if object_hold ^= null
	then call tssi_$clean_up_segment (object_hold);

	if list_hold ^= null
	then call tssi_$clean_up_file (fcb, list_hold);
     end truncate;

set_storage_usage:
     procedure (tree_used, xeq_tree_used);

	declare	tree_used		char (*);
	declare	xeq_tree_used	char (*);

	declare	n		fixed bin;

	tree_used = char (binary (pl1_stat_$tree_area_ptr -> area_header.next_virgin, 18), 10);

	number_free_segs = count_components (pl1_stat_$tree_area_ptr);
	if number_free_segs > 1
	then substr (tree_used, 1, 3) = "(" || convert (digit_pic, number_free_segs) || ")";

	xeq_tree_used = char (binary (pl1_stat_$xeq_tree_area_ptr -> area_header.next_virgin, 18), 10);

	n = count_components (pl1_stat_$xeq_tree_area_ptr);
	if n > 1
	then substr (xeq_tree_used, 1, 3) = "(" || convert (digit_pic, n) || ")";

	number_free_segs = number_free_segs + n;

	return;

count_components:
     procedure (areap) returns (fixed bin);

	declare	areap		ptr;

	declare	p		ptr;
	declare	i		fixed bin;

	i = 0;
	do p = areap repeat addrel (p, p -> area_header.extend_info) -> extend_block.next_area while (p ^= null);
	     i = i + 1;
	end;

	return (i);
     end count_components;

     end set_storage_usage;

     end v2pl1;
