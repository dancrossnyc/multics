/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

/****^  HISTORY COMMENTS:
  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
     Deleted some unused declarations (see mrds #141)
  2) change(86-02-12,Spitzer), approve(86-02-12,MCR7311),
     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
     added checks to see if there are any domains or relations in the database
     now that rmdb can make these kind of database. if none, set various ptrs
     in the dbcb to null or to null structures.
     changed mu_temp_segments$free_segments to release them instead (so they get
     truncated).
  3) change(86-08-13,Hergert), approve(88-07-13,MCR7903),
     audit(88-07-13,Dupuis), install(88-08-01,MR12.2-1073):
     Removed changes made on 84-08-31 and reinstalled the old MR10.2 code. The
     way it was doing domain proc initiations was very slow.
  4) change(87-01-22,Hergert), approve(88-07-13,MCR7903),
     audit(88-07-13,Dupuis), install(88-08-01,MR12.2-1073):
     For new parser, added initializtion of dbcb.se_info_ptr.
  5) change(90-10-10,Zimmerman), approve(90-10-10,MCR8215),
     audit(90-10-15,Gray), install(90-10-17,MR12.4-1044):
     Add dm_not_available handler to execute clean shutdown if an attempt is
     made to open a data_management db when data_management is not available.
                                                   END HISTORY COMMENTS */


mrds_dsl_init_res: init_res: proc (view_dir, view_ent, dsm_sw, ready_mode, db_index, dbcb_ptr, administrator, error_code);

/*
                   BEGIN_DESCRIPTION:

   This  routine,  given  the  path name of a database model or submodel, will
   "open"  that  database,  returning a pointer to the resultant model created
   upon  opening,  and  a database index to be used in all future reference to
   the  database  for  file  ready/finish,  data retrieve/modify, and database
   close operations.
                   END_DESCRIPTION

Known Bugs:
   82-08-23 Davids: The values of the access_costs for a page_file type
   database must be determined (it wouldn't hurt to redetermine the values for
   the vfile case either)

Other Problems:

   PARAMETERS:

   view_dir  -  - (input) char (*) database model or submodel pathname down to
   the directory level

   view_ent - - (input) char(*) database model or submodel entryname under the
   above directory

   dsm_sw - - (input) bit(1), on => submodel to be opened, else model

   ready_mode - - (input) fixed bin, 5 => retrieve mode, 6 => update mode.

   db_index  -  -  (output)  fixed bin(35) variable holding the database index
   returned for the newly opened database, whose value will be 0 upon error or
   incomplete open

   dbcb_ptr - - (output) pointer to the resultant model built during opening

   administrator - - (output) bit (1) "1"b -> if the opener is a DBA

   error_code  -  -  (output)  fixed  bin(35) error type encoding, 0 unless an
   error occurred

   sub_error_  -  -  (output)  condition, signaled upon detection of error for
   further info



   HISTORY:

   78-08-01 Oris Friesen: Originally written.

   79-03-14 Al Kepner: Modified to remove quiesce_sw parameter.

   79-03-23 Al Kepner: Modified to set dbcb.transact_ctl_seg.

   79-05-31  Al  Kepner:  Modified to create the segment for current selection
   expression allocations.

   79-07-01 Jim Gray : Rewritten to
   1) add sub_err_ reporting of errors and structured error handling
   2) correct handling of submodels
   3) correct db_index subroutine calls
   4) add backing out of an open upon error
   5) correctly initialize dbcb
   6) improve interface to init_res
   7) add proper initialization
   8) document the modules logic

   80-10-01  Lindsey  Spratt:  Modified  to  use new submodel system; calls to
   dsmd_$foo  were  altered  to  be calls to the actual mrds_dsm_foo module, a
   submodel_iocb_ptr  (in  external  static)  was  added  to keep track of the
   "current"  submodel  opening  (a  better  technology  might  be to have the
   submodel iocb ptr part of the dbcb).

   80-10-24  Jim  Gray  :  Modified  to  add  initialization  of  new dbcb bit
   "new_select_expr".

   80-11-03  Jim  Gray  :  Modified to change delete_$ptr to hcs_$delentry_seg
   calls for performance.

   80-11-07  Jim Gray : Modified to add opening security checks so that if the
   database model is secured, it can not be opened via the model and if opened
   by  a  submodel,  the  submodel  must  reside in the submodel dir under the
   database.

   80-11-18  Jim  Gray  :  Modified to remove link access violation trick with
   db_model when doing a secure open (allowed submodel not being under db_dir)

   80-11-19 Jim Gray : Modified to compare uid's of given submodel, and actual
   db_dir>sm_dir>submodel,  so add_names on submodel_dir could be used.  Also,
   links  into  the submodels are allowed, but links out from the submodel dir
   are not.

   80-12-09  Jim Gray : only the latest version control segment is now allowed
   to  be  used  in opening a database until an AMDB -rs is done to update the
   version  of the dbc to 5, and the seg name to "db.control" This is done via
   the mu_concurrency_control$open_control_segment routine.

   80-12-24 Jim Gray : improved error message for cases where no "w" access to
   database control segment, when attempting to log new opener.

   81-01-12 Jim Gray : added submodel version parameter to mu_sec_init_res,
   and now init it from the submodel header, when a submodel opening is used.

   81-01-22  Davids:  changed  mrds_dsm_open_read to mrds_dsm_open$read.  also
   removed the mrds_dsm_entry_dcls include file.

   81-01-31  Jim  Gray  :  added setting of needed access for DBA types, if ac
   access violation occurs.

   81-02-10  Jim  Gray  :  made the check for the submodel being in the sm_dir
   when the database is secured, an external routine mrds_dm_secured_submodel,
   so that other commands could make use of it.

   81-04-06  Jim Gray : added ability of DBA to be allowed to open through the
   model view for a secured database.

   81-04-30  Jim Gray : added ability of a DBA to open through an un-installed
   submodel.

   81-05-13  Rickie  E.   Brinegar : Modified to fill the administrator bit in
   the resultant.

   81-06-05 Davids: changed the include file mrds_dsm_header_str  to
   mrds_dsm_header,  (user  interface  include file to internal mrds
   include file).

   81-07-06   Jim   Gray   :   added   init   for    dbcb.open_mode,
   new_select_expr,         no_optimize,         print_search_order,
   last_store_rel_name, last_s_e_id_num

   81-12-07 Roger Lackey : change the initization of the variable caller_name
   from mrds_dsl_open to mrds_dsl_init_res.

   82-08-20 Mike Kubicar : Added the initialization of dbcb.store_vector to
   the init_dbcb routine.

   82-08-23 Davids: added code to initialize the dbcb.relmgr_entries and
   dbcb.access_cost substructures depending on type of database, i.e.
   vfile or page_file.

   82-09-09 Mike Kubicar : Added the initialization of dbcb.modify_vector.

   82-10-12 Davids: modifications so that module would compile - 
   changed references to dbcb.store_vector and modify_vector to store and
   modify_vector_ptr. Changed references to dbcb.relmgr_entries.delete_tuple_by_id
   and modify_tuple_by_id to delete and modify_tuples_by_id. Deleted reference
   to dbcb.transact_ctl_seg and replaced it with dbcb.transactions_needed
   which is set to "1"b if the db_model_db_type ^= 1. Also set the value of
   dbcb.relmgr_entries.put_tuple and dbcb.cursor_ptrs_storage_ptr and
   dbcb.cursor_storage_area_ptr. This included adding to the clean_up
   procedure to delete cursor_storage_area_ptr.

   82-10-13 Davids: changed vrm_* entries to vfile_relmgr_$*

   82-10-15 Davids: removed call to mu_define_area to set up the cursor
   storage area (dbcb.cursor_storage_area_ptr) and the code in the clean_up
   routine to clean it up. The area is no set up by mu_cursor_manager_$get

   83-01-25 Roger Lackey : Applied get_shortest_path_ to db_path and dsm_path
                           so sub_err_ messages (limited to 256 chars) would
		       display more of the message.

   83-02-02 Davids: Added call to hcs_$get_uid_seg to set the dbcb.dbc_uid
   element in the internal proc init_dbcb. Added the exit_init_dbcb label
   to branch to incase of an error.

   83-02-10 Mike Kubicar : Removed the call to get shortest path since it
   caused the database names printed by dmod and friends to be somewhere
   between non-obvious and wrong.

   83-02-14 Davids: modified to use the new db_type_flags in the db_model
   structure instead of the old numeric db_type.

   83-02-25 Davids: modified to set the new concurrency_on and rollback_on
   elements in the dbcb structure. 

   83-04-25 Davids: Modified to reduce deep nesting by having error states
   call the new error_exit procedure which cleans up and does a non-local
   goto to leave this procedure. Removed the call to get a temp segment to
   base an area on when the opening is via a submodel so that space will be
   avaialble to read the submodel header, instead just increased the size of
   the local_area variable by 100 (to 200) to allow space to allocate the 
   header. Added code in-line to close the submodel after the call to
   mu_sec_init_res so that a normal exit does not need to call the clean up
   handler. Modified the error handling in the internal procedure init_dbcb
   so that it calls the error_exit procedure instead of goto the exit_init_dbcb
   label which just caused the procedure to return. Eliminated the extra rtrim
   on the view_ent variable when the input_path is built in
   get_model_path_and_pointer. Modified the allocation of the simple and
   general type vectors to be allocated in the dbcb.static_area instead of the
   system free area.

   83-05-02 Davids: Deleted references to the dm_specification include file
   since mike removed the get_next_search_specification pointer from the dbcb.
   Removed code in the init_dbcb internal proc that set the pointer and
   allocated and filled in the structure. Modified so that instead of calling
   hcs_$make_seg to create the curdat, stadat, and select_area segments a call
   to mu_temp_segments$get_temp_segments is made. The clean_up procedure was
   modified to call either mu_temp_segments$free_all_temp_segments if the 
   temp_dir is the pdir or delete_all_temp_segments if its some other temp dir.
   the db_pic variable was created to be a character representation of the db
   index so that it could be used to make the caller to mu_temp_segments
   unique. the res_in_pdir was created to keep track of where the segments were
   created. The new flag in the dbcb resultant_in_pdir is set from res_in_pdir.
   All this was done so that multiple openings (when using the pdir as a temp
   dir) will be faster. The first opening will be somewhat slower since there
   is more overhead in using temp segments than in just creating a segment.

   83-05-04 Davids: Changed the name that the temp segments are gotten with
   from mrds_dsl_init_resDBI to MRDSDBI so that all temp segments can be 
   cleaned up with 1 call in mrds_dsl_close.

   83-05-06 Davids: Modified so that the cleanup handler does not explicitly
   delete the rdbi segment in case of an error but just calls mu_temp_segments
   to do the correct thing (delete or release). This should have been done 
   yesterday! It caused strange segment number problems if an opening failed
   because the segment was gone but mu_temp_segments was still handing out
   a pointer to it.

   83-05-17 Davids: Renamed the internal procedure create_resultant to
   create_resultant_segments since it does not actually fill in the
   dbcb and rdbi structures. Also create_resultant_segments now gets four
   temp segments instead of 3, the fourth is four the rdbi segment which
   is no longer obtained in the mu_sec_init_res module. Created the
   internal procedures copy_resultant_data and generate_resultant_data.
   copy will copy the dbcb and rdbi segments from the database dir if they
   exist and update the process dependent values while generate will generate
   the resultant data from the model as it used to do (its the same code just
   moved into an internal proc).

   83-05-18 Davids: Added a new input parameter - ready_mode. This is needed
   to update the rm_rel_info structures in the rdbi segment if the segment is
   copied from a saved version. Added the internal procedures (with calls in
   copy_resultant_data) update_rm_domain_info and update_rm_rel_info (which
   also updates the rm_attr_info structure). These procedures complete the
   process of updating the rdbi structures so that they can be used by this
   process in this database opening. The internal proc build_entry was also
   added. this entry was copied from mu_sec_make_res and is used to make an
   entry varaible given a path_name$entry_name. Also cahnged the init_dbcb
   internal proc to set the res_laready_made element of the dbcb to OFF while
   copy_resultant_data internal proc sets it to "1"b. 

  83-05-20 Davids: Added the entries report_on_res_creation_(on off) and the
  internal static variable report_on_res_creation. These are debugging aids 
  to report how the resultant was actually created. Also added code in the
  copy_resultant_data procedure to check the version of the saved resultant
  and not use it if it is not equal to the mrds_data_$saved_res_version
  element.

  83-05-23 Davids: Added the new output parameter administrator. "1"b ->
  that the opener is a DBA for the database. This is needed so that open
  does not also have to determine if the opener is a DBA. If the opener is
  a DBA and the resultant is made from scratch than open will create a 
  copy of the resultant in the db dir. Also the rm_db_info.mdbm_secured
  bit is not set based on the db_model.mdbm_secured bit instead of relying
  on the stored value.

  83-05-26 Davids: Modified so that the rm_db_info.db_path and dsm_path are
  updated from the saved value when the saved resultant is used to open the
  db. This was needed because the path that was used to open the db might not
  be the actual db_path, i.e. links and the path the user actual used should be
  used. Added the call to error_exit in build_entry after the sub_err_ call
  reporting that the encode procedure could not be found, this prevents the
  database from being opened anyway. Added code in update_rm_rel_info to try
  to initiate the the relation models and report and error and fail to open
  if the opener does not have access to read the model. Also to check the
  version number of the id_list structure and if its not the expected value, i.e.
  1 to not use the saved resultant in the opening.

  83-06-01 Davids: Removed the reference to the dm_specification include file
  which was not used. Also fixed the loop that adjusted the key_attr_ptrs
  pointers in rm_rel_info so that it looped though all the key_attr_ptrs
  instead of just the last one.

  83-06-02 Mike Kubicar : Updated relation manager calling sequence
  declarations.

  83-06-09 Davids: Modified internal proc copy_resultant_data to
  give the dba access if he doesn't have it and to just generate
  a resultant from scratch if a non-DBA doesn't have access to the
  saved dbcb and rdbi segments or if any other error occurs.

  83-08-03 Mike Kubicar : Added code to initialize the new dbcb entry
  element_id_list_segment_ptr which points to the segment which contains
  the static element id lists.  It also gets this segment at database
  opening time.

  84-08-31 Thanh Nguyen:  Modified the build_entry proc to handle the case
  of same entry name for check or encode or decode procs but located in
  different directory.  

  84-09-04 John Hergert: Added the initialization of dbcb.compiled_se_info_ptr

  84-10-16 Thanh Nguyen:  Modified the build_entry proc to call hcs_$make_entry
  with the entrypoint name because it may be different than the entry name.

  84-11-22 John Hergert: Fixed bug where trying to open large dbs caused
  strange problems. This was because the variable chars was declared fb17
  which wasn't large enough to handle the number of bits in the rdbi seg
  in the resultant_segs dir. Changed it to fb24.

  85-01-15 Thanh Nguyen:  Added the initialization of dbcb.work_area_ptr.

  85-04-14 Thanh Nguyen: Added code to automatically update the rdbi and dbcb
  segments under resultant_segs.dir when the saved_res_version is changed.
  Also added code to initialize new reserved ptrs, words and entries of the
  new dbcb structure.
*/
%page;
/* initialize */

	error_code = 0;
	submodel_version, db_index = 0;
	dbcb_ptr, rdbi_ptr = null ();
	curdat_ptr, stadat_ptr = null ();
	model_seg_ptr = null ();
	clean_up_condition = OFF;
	submodel_open = OFF;
	res_in_pdir = OFF;
	db_pic = 0;

/* establish handler to undo loose ends if users does a quit/release */

	on cleanup begin;
		clean_up_condition = ON;
		if ^substr (db_mrds_dsl_init_res, 1, 1) then ;
		else on sub_error_ ;		/* ignore sub_err_ calls during cleanup */
		call clean_up ();
	     end;

/* establish handler to exit gracefully if an attempt is made to open a Data_Management file when DM is not running.  */

	
on dm_not_available_ begin;

		error_code = dm_error_$system_not_initialized;
                    call sub_err_ (error_code, caller_name, continue, info_ptr, return_value, "");
		call error_exit;

	     end;

/* construct pathnames of the model, the submodel if needed, and get
   a pointer to the db_model segment in the database */

	call get_model_path_and_pointer ();


/* set up the concurrent access control */

	call mu_concurrency_control$open_control_segment (db_path, dbc_ptr, bc, error_code);
	if error_code ^= 0
	then call error_exit;


/* now the non-secure resultant segments can be made,
   and a database index obtained for this opening */

	call create_resultant_segments ();

	if ^dsm_sw
	then call copy_resultant_data;
	else call generate_resultant_data;

/* this user must be added to the list of database openers */

	call mu_sec_reg_user (dbcb.dbc_ptr, rdbi_ptr, error_code);
	if error_code ^= 0
	then call error_exit;			/* error is reported to user in a lower routine */
	else dbcb.dbc_incr = ON;

exit_mrds_dsl_init_res:
	return;
%page;
report_on_res_creation_on: entry;

	report_on_res_creation = "1"b;

	return;



report_on_res_creation_off: entry;

	report_on_res_creation = "0"b;

	return;
%page;
get_model_path_and_pointer: procedure ();

/* obtain the pathname to the database model,   directly if this is for a model opening,
   indirectly if this is a submodel opening,   and also get the submodel pathname */

	if length (rtrim (view_dir)) + length (rtrim (view_ent)) + 1 > length (input_path)
	then do;
	          error_code = error_table_$dirlong;
		call error_exit;
	     end;
	else input_path = rtrim (view_dir) || ">" || rtrim (view_ent);

	if ^dsm_sw
	then do;					/* model opening */
		db_path = input_path;
		dsm_path = db_path;			/* equal since model opening */
	     end;
	else do;					/* submodel opening */
		dsm_path = input_path;
		call mrds_dsm_open$read /* get the model path from the submodel */
		     (dsm_path, submodel_iocb_ptr, error_code);
		if error_code ^= 0
		then do;
			call sub_err_ (error_code, caller_name, continue, info_ptr, return_value, "^/^a^a^a",
			     "Unable to open the submodel using the pathname """, dsm_path, """.");
			call error_exit;
		     end;

		submodel_open = ON;

		call mrds_dsm_read_header (addr (local_area), header_ptr, submodel_iocb_ptr, error_code);
		if error_code ^= 0
		then do;
			call sub_err_ (error_code, caller_name, continue, info_ptr, return_value, "^/^a^a^a",
			     "Unable to get the header information from the submodel using the pathname """,
			     dsm_path, """.");
			call error_exit;
		     end;

		db_path = header_ptr -> mrds_dsm_header.database_pn;
		submodel_version = header_ptr -> mrds_dsm_header.dsm_generator_version;
	     end;

	call initiate_file_ /* get a pointer to the common model segment */
	     (db_path, "db_model", R_ACCESS, dbm_ptr, (0), code);
	if code = error_table_$moderr
	then do;
		call mrds_dm_authorization$set_needed_access (rtrim (db_path), code); /* fails if caller not DBA */
		if code ^= 0
		then code = error_table_$moderr;
		else call initiate_file_ (db_path, "db_model", R_ACCESS, dbm_ptr, (0), code);
	     end;
	if dbm_ptr = null ()
	then do;
		error_code = code;
		call sub_err_ (error_code, caller_name, continue, info_ptr, return_value, "^/^a^a^a",
		     "Unable to get a pointer to db_model under the database directory """, db_path, """.");
		call error_exit;
	     end;

	call mrds_dm_authorization$get_user_class (rtrim (db_path), addr (local_area),
	     mrds_authorization_structure_version, mrds_authorization_ptr, error_code);
	if error_code ^= 0
	then call error_exit;

	administrator = mrds_authorization.administrator; /* send the type of user back to mrds_dsl_open */

	if db_model.mdbm_secured
	then do;					/* if database has been secured */
		if ^mrds_authorization.administrator
		then do;				/* administrators can always open */
			if ^dsm_sw		/* normal users must open via a submodel */
			then do;

				error_code = mrds_error_$inc_secure_open;
				call sub_err_ (error_code, caller_name, continue, info_ptr, return_value,
				     "^/^a^a^a ^a",
				     "The path """, db_path,
				     """ refers to a database that has been secured,",
				     "and can only be be opened via a secure submodel by a non-DBA.");
				call error_exit;
			     end;

			if ^mrds_dm_secured_submodel /* it must be a secure submodel */
			     (rtrim (db_path), rtrim (view_dir), rtrim (view_ent))
			then do;
				error_code = mrds_error_$inc_secure_open;
				call sub_err_ (error_code, caller_name, continue, info_ptr, return_value,
				     "^/^a^a^a^a^a ^a^a^a",
				     "The submodel """, dsm_path, """ refers to a database """,
				     db_path, """ that has been secured,",
				     "but the submodel itself is not in the databases inferior directory """,
				     mrds_data_$submodel_dir_name, """.");
				call error_exit;
			     end;
		     end;
	     end;
     end;
%page;
create_resultant_segments: procedure ();

/* the dbcb(database control) segment, and select area segments must be created,
   and a database index must be obtained for this opening */

/* create the dbcb segment */

	resultant_dir = mrds_dsl_resultant_storage$get ();
	if substr (resultant_dir, 2, 15) = "process_dir_dir"
	then resultant_dir = ">pdd>" || substr (resultant_dir, 18);

	call hcs_$make_seg (resultant_dir, unique_chars_ ("0"b) || ".mrds.dbcb", "",
	     RW, dbcb_ptr, error_code);
	if dbcb_ptr = null ()
	then do;
		call sub_err_ (error_code, caller_name, continue, info_ptr, return_value, "^/^a^a^a^a^a",
		     "Unable to create the resultant model dbcb segment under the directory """,
		     resultant_dir, """ for the database """, dsm_path, """.");
		call error_exit;
	     end;

	call mu_database_index$get_database_index /* get a database opening index for the user */
	     (db_index, dbcb_ptr);			/* save ptr and get index for it */
	if db_index = 0
	then do;
		error_code = mrds_error_$too_many_dbs;
		call sub_err_ (error_code, caller_name, continue, info_ptr, return_value, "^/^a ^d ^a^a^a",
		     "The maximum number of database openings =", mrds_data_$max_dbs, "has been exceeded by """,
		     dsm_path, """.");
		call error_exit;
	     end;
	db_pic = db_index;

	process_dir = get_pdir_ ();
	if substr (process_dir, 2, 15) = "process_dir_dir"
	then process_dir = ">pdd>" || substr (process_dir, 18);

	if resultant_dir = process_dir
	then res_in_pdir = "1"b;
	else res_in_pdir = "0"b;

	call mu_temp_segments$get_temp_segments (db_index, "MRDS" || db_pic, ptr_array, error_code);
	if error_code ^= 0
	then do;
		call sub_err_ (error_code, caller_name, continue, info_ptr, return_value,
		     "Could not create temporary segments for the opening of ^a", dsm_path);
		call error_exit;
	     end;
	curdat_ptr = ptr_array (1);			/* tuple retrieve area */
	stadat_ptr = ptr_array (2);			/* "first selerct tuple" retrieve area */
	model_seg_ptr = ptr_array (3);		/* select area segment */
	rdbi_ptr = ptr_array (4);			/* rdbi segment */
	el_id_seg_ptr = ptr_array (5);		/* Element id lists */

	model_area_ptr = pointer (model_seg_ptr, size (model_seg));
	dbcb.select_area_ptr = model_area_ptr;
	call mrds_dsl_init_select_area /* initialize the select area segment */
	     (dbcb_ptr, error_code);
	if error_code ^= 0
	then do;
		call sub_err_ (error_code, caller_name, continue,
		     info_ptr, return_value, "^/^a^a^a",
		     "Unable to initialize the select area for database """,
		     dsm_path, """.");
		call error_exit;
	     end;
     end;
%page;
copy_resultant_data: proc;

	dcl     saved_rdbi_ptr	 ptr;		/* pointer to the saved copy of the rdbi segment */
	dcl     rdbi_bit_count	 fixed bin (24);	/* bit count of the saved rdbi segment */
	dcl     saved_dbcb_ptr	 ptr;		/* pointer to the saved copy of the dbcb segment */
	dcl     dbcb_bit_count	 fixed bin (24);	/* bit count of the saved dbcb segment */
	dcl     chars		 fixed bin (24);	/* number of characters in the rdbi and dbcb segments */
	dcl     chars_overlay	 char (chars) based;/* character overlay for copying the segments */
	dcl     bad_id_list_version	 bit (1);		/* "1"b => the structure of the id_list has changed */

	call initiate_file_ (rtrim (db_path) || ">resultant_segs.dir", "rdbi", R_ACCESS,
	     saved_rdbi_ptr, rdbi_bit_count, error_code);
	if error_code = error_table_$moderr | error_code = error_table_$no_info
	then do;					/* see if access can be set */
		call mrds_dm_authorization$set_needed_access (rtrim (db_path), code);
		if code = 0
		then call initiate_file_ (rtrim (db_path) || ">resultant_segs.dir", "rdbi", R_ACCESS,
			saved_rdbi_ptr, rdbi_bit_count, error_code);
	     end;
	if error_code ^= 0				/* if there is any error just */
	then do;					/* give up and generate a copy */
		call generate_resultant_data;
		goto exit_copy_resultant_data;
	     end;

	call initiate_file_ (rtrim (db_path) || ">resultant_segs.dir", "dbcb", R_ACCESS,
	     saved_dbcb_ptr, dbcb_bit_count, error_code);
	if error_code = error_table_$moderr | error_code = error_table_$no_info
	then do;					/* see if access can be set */
		call mrds_dm_authorization$set_needed_access (rtrim (db_path), code);
		if code = 0
		then call initiate_file_ (rtrim (db_path) || ">resultant_segs.dir", "dbcb", R_ACCESS,
			saved_dbcb_ptr, dbcb_bit_count, error_code);
	     end;
	if error_code ^= 0				/* if there is any error just */
	then do;					/* give up and generate a copy */
		call generate_resultant_data;
		goto exit_copy_resultant_data;
	     end;

	if saved_rdbi_ptr -> rm_db_info.saved_res_version ^= mrds_data_$saved_res_version
	then do;
		call generate_resultant_data;
		if mrds_authorization.administrator then do;
						/* He/She is a DBA so let update the saved_res_version and the dbcb struture for resultant_segs.dir */
			saved_rdbi_ptr -> rm_db_info.saved_res_version = mrds_data_$saved_res_version;
			saved_dbcb_ptr -> dbcb = dbcb;
		     end;
		goto exit_copy_resultant_data;
	     end;

	chars = divide (rdbi_bit_count, 9, 24, 0) + 1;	/* add 1 to make sure that any bits after */
	rdbi_ptr -> chars_overlay = saved_rdbi_ptr -> chars_overlay; /*  the last full character are also copyed */

	rm_db_info.administrator = mrds_authorization.administrator;
	rm_db_info.mdbm_secured = db_model.mdbm_secured;
	rm_db_info.db_path = db_path;
	rm_db_info.sm_path = dsm_path;
	rm_db_info.ra_ptr = ptr (rdbi_ptr, rel (rm_db_info.ra_ptr));
	rm_db_info.tra_ptr = ptr (rdbi_ptr, rel (rm_db_info.tra_ptr));
	if rm_db_info.domain_list_ptr ^= null
	then do;
	     rm_db_info.domain_list_ptr = ptr (rdbi_ptr, rel (rm_db_info.domain_list_ptr));

	     call update_rm_domain_info;
	     end;

	bad_id_list_version = "0"b;
	call update_rm_rel_info (bad_id_list_version);
	if bad_id_list_version
	then do;
		call generate_resultant_data;
		goto exit_copy_resultant_data;
	     end;

	chars = divide (dbcb_bit_count, 9, 17, 0) + 1;
	dbcb_ptr -> chars_overlay = saved_dbcb_ptr -> chars_overlay;

	call hcs_$get_uid_seg (dbc_ptr, dbcb.dbc_uid, error_code);
	if error_code ^= 0
	then do;
		call sub_err_ (error_code, caller_name, continue, info_ptr, return_value,
		     "Unable to obtain the unique identifier of the data base control segment, opening will be aborted");
		call error_exit;
	     end;
	dbcb.work_area_ptr = null ();			/* just make sure it is null. */
	dbcb.reserved_ptrs (*) = null ();
	dbcb.dbc_ptr = dbc_ptr;
	dbcb.select_area_ptr = model_area_ptr;
	dbcb.current_data_ptr = curdat_ptr;
	dbcb.static_data_ptr = stadat_ptr;
	dbcb.rdbi_ptr = rdbi_ptr;
	dbcb.element_id_list_segment_ptr = el_id_seg_ptr;
	dbcb.resultant_in_pdir = res_in_pdir;
	dbcb.dbi = db_index;
	dbcb.res_already_made = "1"b;
	if dbcb.scope_ptr = null
	then do;
	     max_file_init = 0;
	     allocate scope_info set (scope_ptr) in (dbcb.static_area);
	     scope_info.mbz1 = "0"b;
	     scope_info.active_scopes = 0;
	     dbcb.scope_ptr = scope_ptr;
	     end;
	else dbcb.scope_ptr = ptr (dbcb_ptr, rel (dbcb.scope_ptr));
	dbcb.store_vector_ptr = ptr (dbcb_ptr, rel (dbcb.store_vector_ptr));
	dbcb.modify_vector_ptr = ptr (dbcb_ptr, rel (dbcb.modify_vector_ptr));
	if db_model.db_type_flags.vfile_type
	then do;					/* vfile type data base */
		dbcb.relmgr_entries.open = vfile_relmgr_$open;
		dbcb.relmgr_entries.close = vfile_relmgr_$close;
		dbcb.relmgr_entries.create_cursor = vfile_relmgr_$create_cursor;
		dbcb.relmgr_entries.destroy_cursor = vfile_relmgr_$destroy_cursor;
		dbcb.relmgr_entries.set_scope = vfile_relmgr_$set_scope;
		dbcb.relmgr_entries.delete_tuples_by_id = vfile_relmgr_$delete_tuples_by_id;
		dbcb.relmgr_entries.modify_tuples_by_id = vfile_relmgr_$modify_tuples_by_id;
		dbcb.relmgr_entries.get_tuple_by_id = vfile_relmgr_$get_tuple_by_id;
		dbcb.relmgr_entries.get_tuples_by_spec = vfile_relmgr_$get_tuples_by_spec;
		dbcb.relmgr_entries.get_tuple_id = vfile_relmgr_$get_tuple_id;
		dbcb.relmgr_entries.put_tuple = vfile_relmgr_$put_tuple;
		dbcb.relmgr_entries.get_count = vfile_relmgr_$get_count;
		dbcb.relmgr_entries.get_population = vfile_relmgr_$get_population;
		dbcb.relmgr_entries.get_duplicate_key_count = vfile_relmgr_$get_duplicate_key_count;
		dbcb.relmgr_entries.create_relation = vfile_relmgr_$create_relation;
		dbcb.relmgr_entries.create_index = vfile_relmgr_$create_index;
		dbcb.relmgr_entries.destroy_relation_by_path = vfile_relmgr_$destroy_relation_by_path;
	     end;
	else do;					/* page_file type database */

                    dm_system_state = dm_gate_$dm_get_system_state();   /* 12.4 This will signal dm_not_available if the dm system is down. */
		dbcb.relmgr_entries.open = relation_manager_$open;
		dbcb.relmgr_entries.close = relation_manager_$close;
		dbcb.relmgr_entries.create_cursor = relation_manager_$create_cursor;
		dbcb.relmgr_entries.destroy_cursor = relation_manager_$destroy_cursor;
		dbcb.relmgr_entries.set_scope = relation_manager_$set_scope;
		dbcb.relmgr_entries.delete_tuples_by_id = relation_manager_$delete_tuples_by_id;
		dbcb.relmgr_entries.modify_tuples_by_id = relation_manager_$modify_tuples_by_id;
		dbcb.relmgr_entries.get_tuple_by_id = relation_manager_$get_tuple_by_id;
		dbcb.relmgr_entries.get_tuples_by_spec = relation_manager_$get_tuples_by_spec;
		dbcb.relmgr_entries.get_tuple_id = relation_manager_$get_tuple_id;
		dbcb.relmgr_entries.put_tuple = relation_manager_$put_tuple;
		dbcb.relmgr_entries.get_count = relation_manager_$get_count;
		dbcb.relmgr_entries.get_population = relation_manager_$get_population;
		dbcb.relmgr_entries.get_duplicate_key_count = relation_manager_$get_duplicate_key_count;
		dbcb.relmgr_entries.create_relation = relation_manager_$create_relation;
		dbcb.relmgr_entries.create_index = relation_manager_$create_index;
		dbcb.relmgr_entries.destroy_relation_by_path = relation_manager_$destroy_relation_by_path;

	     end;

	if report_on_res_creation
	then call ioa_ ("Resultant has been created by copying from the saved copy: version is ^a",
		saved_rdbi_ptr -> rm_db_info.saved_res_version);

exit_copy_resultant_data:
	return;

     end;
%page;
update_rm_domain_info: proc;

	dcl     domain_header_ptr	 ptr;
	dcl     found		 bit (1);
	dcl     NULLOFFSET		 bit (18) init ((18)"1"b) internal static options (constant);

	domain_header_ptr = ptr (dbm_ptr, db_model.domain_ptr);
	rdi_ptr = rm_db_info.domain_list_ptr;
	do while (rdi_ptr ^= null ());
	     if (rm_domain_info.ck_proc | rm_domain_info.encd_proc | rm_domain_info.decd_proc)
	     then do;
		     di_ptr = domain_header_ptr;
		     found = "0"b;
		     do while (^found & di_ptr ^= null ());
			if domain_info.name = rm_domain_info.name
			then found = "1"b;
			else
			     if domain_info.fwd_thread = NULLOFFSET
			then di_ptr = null ();
			else di_ptr = ptr (dbm_ptr, domain_info.fwd_thread);
		     end;
		     if ^found
		     then do;
			     error_code = mrds_error_$incons_db;
			     call sub_err_ (error_code, caller_name, continue, info_ptr, return_value,
				"The domain ^a is listed in the saved rdbi structure but not in the model.",
				rm_domain_info.name);
			     call error_exit;
			end;
		     if rm_domain_info.ck_proc
		     then rm_domain_info.ck_proc_entry = build_entry (domain_info.check_path_ptr, dbm_ptr, "check");
		     if rm_domain_info.encd_proc
		     then rm_domain_info.encd_proc_entry = build_entry (domain_info.encd_path_ptr, dbm_ptr, "encode");
		     if rm_domain_info.decd_proc
		     then rm_domain_info.decd_proc_entry = build_entry (domain_info.decd_path_ptr, dbm_ptr, "decode");
		end;
	     if rm_domain_info.next_domain_ptr = null ()
	     then rdi_ptr = null ();
	     else do;
		     rm_domain_info.next_domain_ptr = ptr (rdbi_ptr, rel (rm_domain_info.next_domain_ptr));
		     rdi_ptr = rm_domain_info.next_domain_ptr;
		end;
	end;

	return;

     end;
%page;
update_rm_rel_info: proc (urri_bad_id_list_version);

	dcl     urri_bad_id_list_version bit (1);
	dcl     (i, j)		 fixed bin;
	dcl     SCOPE_UPDATE	 fixed bin init (6) internal static options (constant);
	dcl     rel_model_ptr	 ptr;		/* used to be sure that opener still has access to the relation model segments */

	rmra_ptr = rm_db_info.ra_ptr;
	do i = 1 to rm_rel_array.num_rels;
	     rm_rel_array.rel_data (i).ri_ptr = ptr (rdbi_ptr, rel (rm_rel_array.rel_data (i).ri_ptr));
	     rmri_ptr = rm_rel_array.rel_data (i).ri_ptr;
	     call initiate_file_ ((rm_db_info.db_path), rtrim (rm_rel_info.model_name) || ".m", R_ACCESS, rel_model_ptr, (0), error_code);
	     if error_code = error_table_$moderr
	     then do;
		     call mrds_dm_authorization$set_needed_access (rtrim (rm_db_info.db_path), error_code);
		     if error_code = 0
		     then call initiate_file_ ((rm_db_info.db_path), rtrim (rm_rel_info.model_name) || ".m", R_ACCESS, rel_model_ptr, (0), error_code);
		     else error_code = error_table_$moderr;
		end;
	     if rel_model_ptr = null ()
	     then do;
		     call sub_err_ (error_code, caller_name, "c", null (), return_value,
			"^/Unable to get a pointer to the model segment ""^a>^a.m""", rm_db_info.db_path, rm_rel_info.model_name);
		     call error_exit;
		end;
	     rm_rel_info.modify = (ready_mode = SCOPE_UPDATE);
	     rm_rel_info.store = rm_rel_info.modify;
	     rm_rel_info.delete = rm_rel_info.modify;
	     rm_rel_info.mdbm_secured = rm_db_info.mdbm_secured;
	     rm_rel_info.ready_mode = ready_mode;
	     rm_rel_info.id_list_ptr = ptr (rdbi_ptr, rel (rm_rel_info.id_list_ptr));
	     if rm_rel_info.id_list_ptr -> id_list.version ^= ID_LIST_VERSION_1
	     then do;
		     urri_bad_id_list_version = "1"b;
		     goto exit_update_rm_rel_info;
		end;
	     rm_rel_info.scope_flags_ptr = ptr (dbcb_ptr, rel (rm_rel_info.scope_flags_ptr));
	     do j = 1 to rm_rel_info.nkey_attr;
		rm_rel_info.key_attr_ptrs (j) = ptr (rdbi_ptr, rel (rm_rel_info.key_attr_ptrs (j)));
	     end;
	     do j = 1 to rm_rel_info.num_attr;
		rm_rel_info.attr_ptrs (j) = ptr (rdbi_ptr, rel (rm_rel_info.attr_ptrs (j)));
		rai_ptr = rm_rel_info.attr_ptrs (j);
		rm_attr_info.domain_ptr = ptr (rdbi_ptr, rel (rm_attr_info.domain_ptr));
		rm_attr_info.mdbm_secured = rm_db_info.mdbm_secured;
	     end;
	end;

exit_update_rm_rel_info:
	return;

     end;
%page;
build_entry:
     proc (path_entry_offset, base_pointer, proc_type) returns (entry);

/* DESCRIPTION:

   This  procedure  initiates the segment referenced by the pathname structure
   at the given offset The pointer to the initiated segment is returned in the
   output_ptr  parameter.   If  the  segment  could not be initiated the error
   procedure is called.

*/

	dcl     output_entry	 entry variable;	/* output -- entry of initiated segment */
	dcl     proc_type		 char (*);	/* type of procedure being set up */
	dcl     path_entry_offset	 bit (18);	/* offset in the given area to the path_entry struct */
	dcl     base_pointer	 ptr;		/* base of segment for given path_entry */
	dcl     cv_entry_		 entry (char (*), ptr, fixed bin (35)) returns (entry);

	path_entry_ptr = pointer (base_pointer, path_entry_offset);
	output_entry =
	     cv_entry_ (path_entry.path || "$" || path_entry.entry, null,
	     error_code);

	if error_code ^= 0 then do;
		call sub_err_ (error_code, caller_name, "c", null (), return_value,
		     "^/Unable to build an entry variable for the ""^a"""
		     || " procedure using the path$entry = ^a$^a for the domain ^a",
		     proc_type, path_entry.path, path_entry.entry, rm_domain_info.name);
		error_code = mrds_error_$bad_domain_proc;
		call error_exit;
	     end;

	return (output_entry);

     end build_entry;
%page;
generate_resultant_data: proc;

/* now fill in the dbcb(database control block) structure */

	call init_dbcb ();

/* the secure resultant model structures must be filled in,
   after obtaining the secure resultant segment, and a pointer to
   it must be returned to be saved in the non-secure portion */

	call mu_sec_init_res (dsm_path, submodel_version, db_path,
	     dbm_ptr, dbcb_ptr, rdbi_ptr, error_code);
	if error_code ^= 0				/* init_res reports it's own errors */
	then call error_exit;

	if report_on_res_creation
	then call ioa_ ("Resultant has been created from scratch: version is ^a",
		rm_db_info.saved_res_version);

	if submodel_open				/* can now close the submodel, if one was opened */
	then do;
		call mrds_dsm_close (submodel_iocb_ptr, error_code);
		submodel_open = OFF;
		if error_code ^= 0
		then do;
			call sub_err_ (code, caller_name, continue, info_ptr, return_value, "^/^a^a^a",
			     "Unable to close the submodel """, dsm_path, """.");
			call error_exit;
		     end;
	     end;

	rm_db_info.administrator = mrds_authorization.administrator;
	dbcb.rdbi_ptr = rdbi_ptr;

	return;

     end;

%page;
init_dbcb: procedure ();

/* initialize the database control block structure,
   the non-secure portion of the resultant model */

	call hcs_$get_uid_seg (dbc_ptr, dbcb.dbc_uid, error_code);
	if error_code ^= 0
	then do;
		call sub_err_ (error_code, caller_name, continue, info_ptr, return_value,
		     "Unable to obtain the unique identifier of the data base control segment, opening will be aborted");
		call error_exit;
	     end;
	dbcb.dbc_ptr = dbc_ptr;
	dbcb.rdbi_ptr = null ();
	dbcb.range_ptr = null ();
	dbcb.select_ptr = null ();
	dbcb.sv_ptr = null ();
	dbcb.so_ptr = null ();
	dbcb.ti_ptr = null ();
	dbcb.lit_ptr = null ();
	dbcb.current_ptr = null ();
	dbcb.ss_ptr = null ();
	dbcb.retr_info_ptr = null ();
	dbcb.trel_info_ptr = null ();
	dbcb.sti_ptr = null ();
	dbcb.sfi_ptr = null ();
	dbcb.scope_ptr = null ();
	dbcb.select_area_ptr = model_area_ptr;
	dbcb.current_data_ptr = curdat_ptr;
	dbcb.static_data_ptr = stadat_ptr;
	dbcb.element_id_list_segment_ptr = el_id_seg_ptr;
	dbcb.store_area_ptr = null ();
	dbcb.retrieve_area_ptr = null ();
	dbcb.modify_area_ptr = null ();
	dbcb.delete_area_ptr = null ();
	dbcb.def_temp_rel_area_ptr = null ();
	dbcb.compiled_se_info_ptr = null ();
	dbcb.work_area_ptr = null ();
	dbcb.se_info_ptr = null ();
	dbcb.reserved_ptrs (*) = null ();
	dbcb.cursor_ptrs_storage_ptr = null ();
	dbcb.cursor_storage_area_ptr = null ();
	dbcb.parser_work_area_ptr = null ();

	dbcb.another_flag = OFF;
	dbcb.current_flag = OFF;
	dbcb.dbc_incr = OFF;
	dbcb.delete_flag = OFF;
	dbcb.dup_retain = OFF;
	dbcb.prev_select = OFF;
	dbcb.possible_op = OFF;
	dbcb.sel_clause = OFF;
	dbcb.dsm_sw = dsm_sw;
	dbcb.val_rtrv = OFF;
	dbcb.val_mod = OFF;
	dbcb.val_del = OFF;
	dbcb.val_dtr = OFF;
	dbcb.resultant_in_pdir = res_in_pdir;
	dbcb.transactions_needed = db_model.db_type_flags.transactions_needed;
	dbcb.concurrency_on = db_model.db_type_flags.concurrency_on;
	dbcb.rollback_on = db_model.db_type_flags.rollback_on;

	dbcb.open_mode = OFF;
	dbcb.new_select_expr = ON;
	dbcb.no_optimize = OFF;
	dbcb.print_search_order = OFF;
	dbcb.res_already_made = OFF;
	dbcb.user_started_transaction = OFF;
	dbcb.non_shared_to_shared = OFF;
	dbcb.reserved = OFF;

	dbcb.nseq_sch = 0;
	dbcb.nind_sch = 0;
	dbcb.nhash_sch = 0;
	dbcb.nlk_sch = 0;
	dbcb.cur_lit_offset = 0;
	dbcb.dbi = db_index;
	dbcb.last_s_e_id_num = 0;
	dbcb.se_transaction_id = "0"b;
	dbcb.last_store_rel_name = " ";
	dbcb.reserved_words (*) = 0;
	if db_model.db_type_flags.vfile_type
	then do;					/* vfile type data base */
		dbcb.relmgr_entries.open = vfile_relmgr_$open;
		dbcb.relmgr_entries.close = vfile_relmgr_$close;
		dbcb.relmgr_entries.create_cursor = vfile_relmgr_$create_cursor;
		dbcb.relmgr_entries.destroy_cursor = vfile_relmgr_$destroy_cursor;
		dbcb.relmgr_entries.set_scope = vfile_relmgr_$set_scope;
		dbcb.relmgr_entries.delete_tuples_by_id = vfile_relmgr_$delete_tuples_by_id;
		dbcb.relmgr_entries.modify_tuples_by_id = vfile_relmgr_$modify_tuples_by_id;
		dbcb.relmgr_entries.get_tuple_by_id = vfile_relmgr_$get_tuple_by_id;
		dbcb.relmgr_entries.get_tuples_by_spec = vfile_relmgr_$get_tuples_by_spec;
		dbcb.relmgr_entries.get_tuple_id = vfile_relmgr_$get_tuple_id;
		dbcb.relmgr_entries.put_tuple = vfile_relmgr_$put_tuple;
		dbcb.relmgr_entries.get_count = vfile_relmgr_$get_count;
		dbcb.relmgr_entries.get_population = vfile_relmgr_$get_population;
		dbcb.relmgr_entries.get_duplicate_key_count = vfile_relmgr_$get_duplicate_key_count;
		dbcb.relmgr_entries.create_relation = vfile_relmgr_$create_relation;
		dbcb.relmgr_entries.create_index = vfile_relmgr_$create_index;
		dbcb.relmgr_entries.destroy_relation_by_path = vfile_relmgr_$destroy_relation_by_path;
		dbcb.access_costs.total_primary_key_cost = 11;
		dbcb.access_costs.access_cost = 7.95;
		dbcb.access_costs.access_overhead = 250;
		dbcb.access_costs.us_access_cost = 2.6;
		dbcb.access_costs.os_access_cost = 6.0;
	     end;
	else do;					/* page_file type database */
	          dm_system_state = dm_gate_$dm_get_system_state();   /* 12.4 This will signal dm_not_available_ if the dm system is down. */
		dbcb.relmgr_entries.open = relation_manager_$open;
		dbcb.relmgr_entries.close = relation_manager_$close;
		dbcb.relmgr_entries.create_cursor = relation_manager_$create_cursor;
		dbcb.relmgr_entries.destroy_cursor = relation_manager_$destroy_cursor;
		dbcb.relmgr_entries.set_scope = relation_manager_$set_scope;
		dbcb.relmgr_entries.delete_tuples_by_id = relation_manager_$delete_tuples_by_id;
		dbcb.relmgr_entries.modify_tuples_by_id = relation_manager_$modify_tuples_by_id;
		dbcb.relmgr_entries.get_tuple_by_id = relation_manager_$get_tuple_by_id;
		dbcb.relmgr_entries.get_tuples_by_spec = relation_manager_$get_tuples_by_spec;
		dbcb.relmgr_entries.get_tuple_id = relation_manager_$get_tuple_id;
		dbcb.relmgr_entries.put_tuple = relation_manager_$put_tuple;
		dbcb.relmgr_entries.get_count = relation_manager_$get_count;
		dbcb.relmgr_entries.get_population = relation_manager_$get_population;
		dbcb.relmgr_entries.get_duplicate_key_count = relation_manager_$get_duplicate_key_count;
		dbcb.relmgr_entries.create_relation = relation_manager_$create_relation;
		dbcb.relmgr_entries.create_index = relation_manager_$create_index;
		dbcb.relmgr_entries.destroy_relation_by_path = relation_manager_$destroy_relation_by_path;
		dbcb.access_costs.total_primary_key_cost = 11;
		dbcb.access_costs.access_cost = 7.95;
		dbcb.access_costs.access_overhead = 250;
		dbcb.access_costs.us_access_cost = 2.6;
		dbcb.access_costs.os_access_cost = 6.0;


	     end;



	dbcb.static_area = empty ();

	stv_number_of_dimensions = mrds_data_$max_attributes;
	allocate simple_typed_vector in (dbcb.static_area) set (dbcb.store_vector_ptr);

	gtv_number_of_dimensions = mrds_data_$max_attributes;
	allocate general_typed_vector in (dbcb.static_area) set (dbcb.modify_vector_ptr);

	return;

     end;
%page;
error_exit: procedure ();

	call clean_up;

	goto exit_mrds_dsl_init_res;

     end;
%page;
clean_up: procedure ();

	if submodel_open
	then do;
		call mrds_dsm_close (submodel_iocb_ptr, code);
		submodel_open = OFF;
		if code = 0 | clean_up_condition then ;
		else call sub_err_ (code, caller_name, continue, info_ptr, return_value, "^/^a^a^a",
			"Unable to close the submodel """, dsm_path, """.");
	     end;

	if res_in_pdir				/* segments in pdir may be resused */
	then call mu_temp_segments$release_all_temp_segments ("MRDS" || db_pic, code);
	else call mu_temp_segments$delete_all_temp_segments ("MRDS" || db_pic, code);
	if code ^= 0 & code ^= error_table_$argerr
	then call sub_err_ (code, caller_name, continue, info_ptr, return_value,
		"Could not free the temp segments created.");

	if db_index ^= 0
	then do;
		call mu_database_index$reset_resultant_model_pointer (db_index, (dbcb_ptr));
		db_index = 0;
	     end;

	if dbcb_ptr ^= null ()
	then do;
		call hcs_$delentry_seg (dbcb_ptr, code);
		if code ^= 0
		then call sub_err_ (code, caller_name, continue, info_ptr, return_value, "^/^a^a^a",
			"Unable to delete the dbcb segment for database """, dsm_path, """.");
		dbcb_ptr = null ();
	     end;
     end;
%page;
	dcl     (header_ptr,			/* points to dsm header record */
	        dbc_ptr)		 ptr;		/* point to the data base control segment */

	dcl     bc		 fixed bin (24);	/* bit count of data base control segment */
	dcl     code		 fixed bin (35);	/* return status code */

	dcl     dsm_sw		 bit (1);		/* ON => data submodel name is being used */

	dcl     ready_mode		 fixed bin;	/* mode that the database will be opened with */

	dcl     administrator	 bit (1);		/* "1"b => that the user is a DBA */

	dcl     db_index		 fixed bin (35);	/* data base index value */
	dcl     db_path		 char (168);	/* absolute path name of data base */
	dcl     dsm_path		 char (168);	/* submodel path name */
	dcl     view_dir		 char (*);	/* view path directory */
	dcl     view_ent		 char (*);	/* view path entry name */

	dcl     RW		 fixed bin (5) int static init (01010b) options (constant); /* code for read/write access */
	dcl     hcs_$make_seg	 entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
	dcl     mu_temp_segments$get_temp_segments entry (fixed bin (35), char (*), (*) ptr, fixed bin (35));
	dcl     mu_temp_segments$release_all_temp_segments entry (char (*), fixed bin (35));
	dcl     hcs_$get_uid_seg	 entry (ptr, bit (36) aligned, fixed bin (35));
	dcl     unique_chars_	 entry (bit (*)) returns (char (15));
	dcl     initiate_file_	 entry (char (*), char (*), bit (*), ptr, fixed bin (24), fixed bin (35));


	dcl     (null,
	        addr,
	        fixed,
	        length,
	        pointer,
	        rel,
	        rtrim,
	        substr,
	        empty,
	        divide,
	        ptr)		 builtin;

	dcl     cleanup		 condition;
	dcl     clean_up_condition	 bit (1);		/* on => cleanup signaled */

	dcl     mrds_data_$max_attributes ext fixed bin (35);
	dcl     mrds_data_$saved_res_version ext char (8);
	dcl     sys_info$max_seg_size	 fixed bin (35) ext;

	dcl     mrds_dsm_close	 entry (ptr, fixed bin (35));
	dcl     mrds_dsm_open$read	 entry (char (*), ptr, fixed bin (35));
	dcl     mrds_dsm_read_header	 entry (ptr, ptr, ptr, fixed bin (35));
	dcl     mu_sec_init_res	 entry (char (168), fixed bin, char (168), ptr, ptr, ptr, fixed bin (35));
	dcl     mu_sec_reg_user	 entry (ptr, ptr, fixed bin (35));
	dcl     OFF		 bit (1) init ("0"b); /* false value */
	dcl     ON		 bit (1) init ("1"b); /* true value */
	dcl     mu_database_index$get_database_index entry (fixed bin (35), ptr); /* gets database index definition */
	dcl     sub_err_		 entry options (variable); /* error reporting routine */
	dcl     caller_name		 char (20) init ("mrds_dsl_init_res"); /* name of calling routine */
	dcl     continue		 char (1) init ("c"); /* don't stop after printing mesg */
	dcl     info_ptr		 ptr init (null ());/* unused */
	dcl     return_value	 fixed bin (35) init (0); /* unused */
	dcl     submodel_open	 bit (1);		/* on => submodel has been opened */
	dcl     submodel_iocb_ptr	 ptr ext init (null); /* External static pointer to iocb
						   of submodel.  Used by mu_sec_init_res,
						   mus_get_relation_names, and
						   mus_get_attribute_names to
						   refer to a common opening of the submodel. */
	dcl     error_code		 fixed bin (35);	/* error type status encoding */
	dcl     input_path		 char (168);	/* path input by user */
	dcl     hcs_$delentry_seg	 entry (ptr, fixed bin (35)); /* delets segs without ref names */
	dcl     mu_database_index$reset_resultant_model_pointer entry (fixed bin (35), ptr); /* removes db index definition */
	dcl     mrds_data_$max_dbs	 fixed bin (35) ext;/* max number of open databases */
	dcl     sub_error_		 condition;	/* signaled when sub_err_ called */
	dcl     mrds_dsl_init_select_area entry (ptr, fixed bin (35)); /* selection expre area init */
	dcl     mrds_error_$too_many_dbs fixed bin (35) ext; /* >64 databases open attempt */
	dcl     resultant_dir	 char (168);	/* storage location of resultant model */
	dcl     process_dir		 char (168);	/* path to the process directory */
	dcl     mrds_dsl_resultant_storage$get entry returns (char (168)); /* gets resultant model directory */
	dcl     ptr_array		 (5) ptr;		/* array of pointers for mu_temp_segment */
	dcl     curdat_ptr		 ptr;		/* points to current data segment */
	dcl     stadat_ptr		 ptr;		/* points to static data segment */
	dcl     el_id_seg_ptr	 ptr;		/* points to element id list segments */
	dcl     delete_seg		 bit (6) init ("000100"b); /* switches to delete segment */
          dcl     dm_error_$system_not_initialized fixed bin (35) ext static;
	dcl     mrds_error_$inc_secure_open fixed bin (35) ext; /* incorrect method for opening secure db */
	dcl     mrds_error_$incons_db	 fixed bin (35) ext static;
	dcl     mrds_error_$bad_domain_proc fixed bin (35) ext static;
	dcl     mrds_data_$submodel_dir_name char (16) ext; /* name of submodel dir under db dir */
	dcl     mrds_dm_secured_submodel entry (char (*), char (*), char (*))
				 returns (bit (1)); /* returns true if submodel in submodel dir */
	dcl     mrds_dm_authorization$get_user_class entry (char (*), ptr, fixed bin, ptr, fixed bin (35)); /* DBA detecter */
	dcl     local_area		 area (200);	/* space for submodeldsm header and DBA info */
	dcl     mu_concurrency_control$open_control_segment entry (char (168), ptr, fixed bin (24), fixed bin (35)); /* get ptr to control seg */
	dcl     submodel_version	 fixed bin;	/* version of submodel opened, or 0 */
	dcl     error_table_$moderr	 fixed bin (35) ext;/* incorrect access */
	dcl     error_table_$no_info	 fixed bin (35) ext static; /* no access to seg and no s access on dir */
	dcl     error_table_$dirlong	 fixed bin (35) ext static;
	dcl     mrds_dm_authorization$set_needed_access entry (char (*), fixed bin (35)); /* sets access for DBA types */
	dcl     res_in_pdir		 bit (1);		/* true ==> resultant created in pdir */
	dcl     db_pic		 pic "999";
	dcl     report_on_res_creation bit (1) internal static init ("0"b);
						/* "1"b => message indicating how resultant was created will be sent to terminal */
          dcl     dm_system_state        char (4) aligned;  /* Results from dm_gate_$dm_get_system_state. Not used: call checks for dm. */
	dcl     ioa_		 entry options (variable);
	dcl     get_pdir_		 entry () returns (char (168));
	dcl     mu_temp_segments$delete_all_temp_segments entry (char (*), fixed bin (35));
	dcl     error_table_$argerr	 fixed bin (35) ext;

	dcl     vfile_relmgr_$open	 entry (char (*), char (*), bit (36) aligned, fixed bin (35));
	dcl     vfile_relmgr_$close	 entry (bit (36) aligned, fixed bin (35));
	dcl     vfile_relmgr_$create_cursor entry (bit (36) aligned, ptr, ptr, fixed bin (35));
	dcl     vfile_relmgr_$destroy_cursor entry (ptr, ptr, fixed bin (35));
	dcl     vfile_relmgr_$set_scope entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35));
	dcl     vfile_relmgr_$put_tuple entry (ptr, ptr, bit (36) aligned, fixed bin (35));
	dcl     vfile_relmgr_$delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35));
	dcl     vfile_relmgr_$modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35));
	dcl     vfile_relmgr_$get_tuple_by_id entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35));
	dcl     vfile_relmgr_$get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35));
	dcl     vfile_relmgr_$get_tuple_id entry (ptr, ptr, ptr, ptr, fixed bin (35));
	dcl     vfile_relmgr_$get_count entry (ptr, ptr, fixed bin (35), fixed bin (35));
	dcl     vfile_relmgr_$get_population entry (ptr, fixed bin (35), fixed bin (35));
	dcl     vfile_relmgr_$get_duplicate_key_count entry entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35));
	dcl     vfile_relmgr_$create_relation entry (char (*), char (*), ptr, ptr,
				 bit (36) aligned, bit (36) aligned, fixed bin (35));
	dcl     vfile_relmgr_$create_index entry (bit (36) aligned, ptr, bit (36) aligned,
				 fixed bin, bit (36) aligned, fixed bin (35));
	dcl     vfile_relmgr_$destroy_relation_by_path entry (bit (36) aligned,
				 fixed bin (35));
	dcl     relation_manager_$open entry (char (*), char (*), bit (36) aligned, fixed bin (35));
	dcl     relation_manager_$close entry (bit (36) aligned, fixed bin (35));
	dcl     relation_manager_$create_cursor entry (bit (36) aligned, ptr, ptr, fixed bin (35));
	dcl     relation_manager_$destroy_cursor entry (ptr, ptr, fixed bin (35));
	dcl     relation_manager_$set_scope entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35));
	dcl     relation_manager_$put_tuple entry (ptr, ptr, bit (36) aligned, fixed bin (35));
	dcl     relation_manager_$delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35));
	dcl     relation_manager_$modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35));
	dcl     relation_manager_$get_tuple_by_id entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35));
	dcl     relation_manager_$get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35));
	dcl     relation_manager_$get_tuple_id entry (ptr, ptr, ptr, ptr, fixed bin (35));
	dcl     relation_manager_$get_count entry (ptr, ptr, fixed bin (35), fixed bin (35));
	dcl     relation_manager_$get_population entry (ptr, fixed bin (35), fixed bin (35));
	dcl     relation_manager_$get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35));
	dcl     relation_manager_$create_relation entry (char (*), char (*), ptr, ptr,
				 bit (36) aligned, bit (36) aligned, fixed bin (35));
	dcl     relation_manager_$create_index entry (bit (36) aligned, ptr, bit (36) aligned,
				 fixed bin, bit (36) aligned, fixed bin (35));
	dcl     relation_manager_$destroy_relation_by_path entry (bit (36) aligned,
				 fixed bin (35));
          dcl     dm_gate_$dm_get_system_state entry () returns (char(4) aligned);
          dcl     dm_not_available_      condition;


%page;
%include access_mode_values;
%page;
%include dm_id_list;
%page;
%include status_structures;
%page;
%include mrds_dbcb;
%page;
%include mdbm_rm_db_info;
%page;
%include mdbm_rm_rel_array;
%page;
%include mdbm_rm_rel_info;
%page;
%include mdbm_rm_attr_info;
%page;
%include mdbm_rm_domain_info;
%page;
%include mrds_dsm_header;
%page;
%include mdbm_db_model;
%page;
%include mdbm_scope_info;
%page;
%include mdbm_seg_area;
%page;
%include mrds_select_area;
%page;
%include mrds_debug_names;
%page;
%include mrds_authorization;
%page;
%include vu_typed_vector;
%page;
     end mrds_dsl_init_res;


