/* ***********************************************************
   *                                                         *
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
   *                                                         *
   *                                                         *
   *********************************************************** */


/* ******************************************************
   *                                                    *
   *                                                    *
   * Copyright (c) 1972 by Massachusetts Institute of   *
   * Technology and Honeywell Information Systems, Inc. *
   *                                                    *
   *                                                    *
   ****************************************************** */


/****^  HISTORY COMMENTS:
  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
     This entry is being made to cover the change made on 85-07-30 by Jim
     Lippard. (see mrds #140, phx19621)
                                                   END HISTORY COMMENTS */

mrds_dsl_dl_fscope: dl_fscope: procedure;

/*    DESCRIPTION:

   This procedure deletes the user's scope of access to the database if it is open in the
   shared mode.  Calling sequence is:

   call dsl_$dl_fscope (db_index,rel_name,permit_ops,prevent_ops,...,rel_name,permit_ops,prevent_ops,code);

   ---------------------------------------------------------------------------

         
   %page;
   HISTORY:
   Written April 28, 1976 by R. G. Luebke
   Modified by Oris Friesen -- July 1977 -- to handle queueing of scope requests
   Changed to dl_fscope by Oris D. Friesen - Sept. 1978 - to handle scopes at file level rather than relation level
   Modified by Al Kepner, March 26, 1979, to allow deleting null fscope
   from a scope tuple which is already null.
   Modified by Jim Gray - - October 1979, to allow deleting null fscope
   from a file that has never had scope set.
   Modified by M. Pierret, December 1979, to change queueing strategy to
   wake up only first waiter, and to change the use of set_lock_ in
   detecting dead processes to use call by value.
   Modified by Lindsey L. Spratt, February 1980, to look for match of fil_name
   in rm_name_array.model_name instead of rm_name_array.name.  This is an
   issue when an opening is done through a submodel and the model_name and
   name are not the same.
   Modified by M.Pierret 13 April 1980 to remove priority queueing.
   Modified by Jim Gray - - June 1980, to not say dumb things like "no scope set"
   when it is told to delete all current scope, regardless of what it is.
   Modified 26 June 80 by M Pierret, changing fil_name to rel_name, file_name
   to model_rel_name and clearing up name/model_name issues for submodels.
   Also rewrote delete_scope, using more straightforward tests and
   modifications of scope.
   Modified 22 July 80 by M Pierret, removing unused variables

   80-12-10 Jim Gray : added use of include file mdbm_scope_requests as part
   of change from r-u to r-s-m-d type scope modes.
   mdbm_scope_info and mdbm_users include files also changed as a result.
   Added local declarations for actual_permits/prevents, and actual_conflicts.
   The later was added to the check_conflict interface, in order
   to be able to report exact details of why a dl_scope failed.

   80-12-12 Jim Gray : added maintenance of the update bit in the fil_list structure.
   Also, did a check for setting passive_sw in user_list on, if the delete
   scope operation removed all active update type operation scope permission.

   80-12-15 Jim Gray : fixed error routine to set users error code parameter.

   80-12-30 Jim Gray : fixed routine sufficient_scope_exists, to look for model
   rather than submodel name in fil_list list, since submodel names are not
   known here. This allows close -all to work with submodels that have alias rel names.

   81-1-11 Jim Gray : added reseting of touched bit, when del scope request
   resulted in no more scope being set for a relation.
   This allows displaying when null scope has been set.

   81-05-29 Jim Gray : changed to use new resultant model structures.

   81-12-15 R. Lackey : Modified to search rm_rel_array correctly for ful rel_name. TR11887.

   82-01-08 R. Lackey : Added check to detect relation names longer then 30 characters.

   82-10-01 Mike Kubicar : Converted to use relation manager.  Specifically
   this meant changing this module to calculate the total scopes set on a
   relation/database for the current process and pass that to relation
   manager.  If changing scopes for on db opening does not change the total
   scopes for the process, the relation manager call is not made as it
   wouldn't be needed.

   82-12-10 Davids: Modified the declarations of new_rmg_permits
   and new_rmg_prevents to bit (2) aligned from unaligned. This was
   needed because the declaration of the relation manager entries
   in the dbcb was changed from options variable to reality. 

   83-02-02 Davids: Added a call to hcs_$get_uid_seg to compare the uid of the
   segment the dbc_ptr currently points at with what it was originally. If the
   uids don't match or the uid cannot be obtained it is assumed that the
   original segment was deleted. There is no need to delete any scopes so this
   routine just returns without errors.

   83-02-07 Davids: Modified the delete_scope internal procedure to 
   create a copy of the rmri_ptr instead of using the copy in the fil_list
   structure. This is needed because the ring brackets of the db.control
   segment which is where the fil_list is kept may be 5,5,5 in which case the 
   pointer cannot be used to reference the rm_rel_info structure which is in
   the resultant and may have different ring brackets, i.e. 4,4,4.

   85-07-30 Jim Lippard: Modified the cleanup handler to dequeue active
   users.  If the user tried to delete scope on a relation for which he
   didn't have scope set and he was listed as an active user, he would be
   left in the active users list.  Later calls to set_scope resulted in
   infinite loops.

   ------------------------------------------------------------------------- */
%page;
	dbc_ptr = null;				/* in case cleanup is called before dbc_ptr is set */
	num_filns = 0;
	entry_name = "dl_fscope";			/* normal entry */
	args_exp = 5;				/* 5 calling arguments */

	call cu_$arg_count (nargs);			/* get number of arguments */
	if nargs < args_exp
	then signal arg_error;			/* must be at least args_exp arguments (1 scope tuple */
						/* plus db_index plus code */

	call cu_$arg_ptr (nargs, cd_ptr, arg_len, icode); /* get pointer to last arg (code) */
	if icode ^= 0
	then signal arg_error;
	code = 0;
	call cu_$arg_ptr (1, dbi_ptr, arg_len, icode);	/* get db_index */
	if icode ^= 0
	then call error (icode);

common_label:
	call mu_database_index$get_resultant_model_pointer (db_index, dbcb_ptr);
						/* get dbcb_ptr corresponding to db_index */
	if dbcb_ptr = null ()
	then call error (mrds_error_$invalid_db_index);

pntr2:						/* entry here => dbc already locked by mrds_dsl_close */

/* Get pointers, see if user has some files readied (scope_ptr non-null) and make sure user has no active scope. */

	icode = 0;
	call hcs_$get_uid_seg (dbcb.dbc_ptr, temp_uid, icode);
	if icode ^= 0				/* if you cannot get the uid of the data base control */
	then do;					/* assume its been deleted. Return without errors since */
		code = 0;				/* the scopes have certainly been deleted */
		goto exit;
	     end;
	if temp_uid ^= dbcb.dbc_uid			/* if the uid's don't match the original control segment */
	then do;					/* was deleted and the segment number reused. Again don't */
		code = 0;				/* do anything */
		goto exit;
	     end;
	dbc_ptr = dbcb.dbc_ptr;			/* pointer to data base control segment */
	on cleanup call clean_up;

	if dbcb.scope_ptr = null
	then call error (mrds_error_$non_scope_ready);
	scope_ptr = dbcb.scope_ptr;
	rdbi_ptr = dbcb.rdbi_ptr;
	rmra_ptr = rm_db_info.ra_ptr;

	if scope_info.active_scopes = 0
	then call error ((mrds_error_$scope_empty));

/* Lock the DBC. (If entry was from dl_fscope_all_ptr, dbc is already locked) */

	if entry_name ^= "dl_fscope_all_pntr"
	then call set_lock_$lock (dbc.scope_lock, (mrds_data_$lock_wait_time), icode);
						/* lock scope portion of dbc */
	if icode = error_table_$invalid_lock_reset | icode = error_table_$locked_by_this_process
	then icode = 0;				/* ignore these error codes */
	if icode ^= 0
	then do;					/* something is messed up in the dbc */
		dbc.trouble_switch = ON;		/* lock it to prevent further opens */
		call error (icode);
	     end;

/* Find user in user_list list */

	find_ul_ptr = convert (dbc_ptr, dbc.active_users_ofs);
	ul_ptr = null;

	my_pid = get_process_id_ ();
	do while (find_ul_ptr ^= null);
	     if find_ul_ptr -> user_list.process_id = my_pid
	     then do;
		     if find_ul_ptr -> user_list.rdbi_bits = addr (rdbi_ptr) -> ptr_bit_string
		     then do;
			     ul_ptr = find_ul_ptr;
			     find_ul_ptr = null;
			end;
		     else find_ul_ptr = convert (dbc_ptr, find_ul_ptr -> user_list.next_active_ofs);
		end;
	     else find_ul_ptr = convert (dbc_ptr, find_ul_ptr -> user_list.next_active_ofs);
	end;


	if ul_ptr = null
	then call error (mrds_error_$unknown_proc_id);

/* =======Enclosed code is executed only if entry was from dl_fscope====== */

	if entry_name = "dl_fscope"
	then do;
		if mod (nargs - 2, 3) = 0
		then num_tuples = divide (nargs - 2, 3, 17);
		else call error (error_table_$wrong_no_of_args);


		make_user_inactive = OFF;

		do i = 1 to num_tuples;		/* iterate once for each scope tuple */
		     arg_index = 3 * (i - 1) + 2;	/* move arg_index to point to 1st arg of scope tuple i */
		     call cu_$arg_ptr (arg_index, rel_ptr, rel_len, icode);
						/* get relation name */
		     if icode ^= 0
		     then call error (icode);


/* BEGIN 82-01-08 Roger Lackey ********************************************* */

		     if length (rtrim (rel_name)) > 30 then call error (mrds_error_$rel_name_too_long);

/* END   82-01-08 Roger Lackey ********************************************* */


/* Since relation names stored in the dbc are stored by the name the data model knows (as opposed to the name known
   by a submodel view) and the user may request scope giving the relation name seen in his view (rel_name), the model relation
   name must be found.  rm_rel_array.rel_data.name holds the name in the user's view, and rm_rel_array.rel_data.model_name
   holds the coresponding relation name in the model.  When rel_name is found, model_rel_name is set to rm...model_name */

/* BEGIN CHANGE 81-12-15 RDL *********************************************** */

		     rel_name_32 = rel_name;		/* Used to search rm_rel_array */
		     pos_in_rmfa = index (string (rm_rel_array.name), "!" || rel_name_32);

/* BEGIN CHANGE 81-12-15 RDL *********************************************** */

		     if pos_in_rmfa = 0 then do;
			     call sub_err_ (mrds_error_$unknown_relation_name, caller_name, continue, info_ptr, return_value,
				"^/^a^a^a", "The relation name """, rel_name,
				""" was not found in the users view of the database.");
			     call error (mrds_error_$unknown_relation_name);
			end;
		     else do;
			     pos_in_rmfa = ((pos_in_rmfa - 1) / 33) + 1;
			     model_rel_name = rm_rel_array.rel_data.model_name (pos_in_rmfa);
						/* Save rel name as per model */
			end;

		     rmri_ptr = rm_rel_array.rel_data.ri_ptr (pos_in_rmfa);

		     if rm_rel_info.ready_mode < 5	/* ready_mode must be =5(scope_retrieve)
						   or = 6 (scope_update)   */
		     then call error (mrds_error_$non_scope_ready);

/* Get permit, prevent ops */

		     call cu_$arg_ptr (arg_index + 1, permit_requests_ptr, arg_len, icode);
						/* get permit operations */
		     if icode ^= 0
		     then call error (icode);

		     call cu_$arg_ptr (arg_index + 2, prevent_requests_ptr, arg_len, icode);
						/* get prevent operations */
		     if icode ^= 0
		     then call error (icode);

/* Check for existence of relation in scope_info array, and then if adequate scope exists for that relation.
   scope_info.scope.name holds names of relations as per the data model, hence the check is made with model_rel_name */

		     do pos_in_si = 1 to scope_info.nfiles /* look for model_rel_name in file table */
			while (model_rel_name ^= scope_info.scope.name (pos_in_si));
		     end;
		     if pos_in_si > scope_info.nfiles	/* didn't find model_rel_name in view */
		     then call error (mrds_error_$unknown_relation_name);

		     if ^sufficient_scope_exists () then do; /* check that scope exists as it is to be deleted */
			     call report_scope_detail ();
			     call error (mrds_error_$scope_not_found);
			end;

/* Ready to delete */

		     call delete_scope;		/* OK, so delete */
		end;
	     end;

/* ------------END of dl_fscope block; goto COMMON -------------------- */

/* ============BEGIN code for dl_fscope_all(_pntr)===================== */

	if entry_name = "dl_fscope_all" | entry_name = "dl_fscope_all_pntr"
	then do;

/* note that it OK to delete_scope_all even when all files are not
   using scope modes, just as it is OK to delete all scope when no scope is set */


		do pos_in_si = 1 to scope_info.nfiles;
		     scope_info.scope (pos_in_si).flags = "0"b;
		end;

		scope_info.active_scopes = 0;
		make_user_inactive = ON;

	     end;

/* ---END of dl_fscope_all block ---- */

/* ====COMMON==== */

	if make_user_inactive			/* unlink from active user list */
	then call mu_de_queue_user (NO_DQ_OPEN, FREE_FIL_LIST, dbc_ptr, ul_ptr, icode);
	if icode ^= 0
	then call error (icode);

/* Finished deleting scope, now notify a waiting process that it may proceed to set scope */

	call examine_queue;

	code = 0;

	if entry_name ^= "dl_fscope_all_pntr"
	then call set_lock_$unlock (dbc.scope_lock, code);/* unlock scope lock */
exit:
	return;
%page;
mrds_dsl_dl_fscope_all:
dl_fscope_all:
     entry (a_db_index, a_code);

/* call dsl_$mrds_dsl_dl_fscope_all (db_index, code);

*/
	dcl     a_db_index		 fixed bin;	/* db$ata base index */
	dcl     a_code		 fixed bin (35);	/* return code */

	dbc_ptr = null;				/* in case cleanup is called before dbc_ptr is set */
	dbi_ptr = addr (a_db_index);
	cd_ptr = addr (a_code);

	args_exp = 2;				/* two calling arguments */
	entry_name = "dl_fscope_all";
	goto common_label;
%page;
pntr:
dl_fscope_all_pntr:
mrds_dsl_scope_all_pntr:
     entry (a_dbcb_ptr, a_cd_ptr);

/*
   call dsl_$mrds_dsl_dl_fscope_all_pntr (dbcb_ptr, code_ptr);

   this entry allows dl_fscope_all to be called with ptr arguments only
*/

	dcl     (
	        a_dbcb_ptr,				/* ptr to dbcb */
	        a_cd_ptr
	        )			 ptr;		/* ptr to status return code */

	entry_name = "dl_fscope_all_pntr";
	dbc_ptr = null;				/* in case cleanup is called before dbc_ptr is set */
	args_exp = 2;
	dbcb_ptr = a_dbcb_ptr;
	cd_ptr = a_cd_ptr;
	goto pntr2;
%page;
error:
     procedure (temp_code);

	dcl     temp_code		 fixed bin (35);

	if temp_code = mrds_error_$scope_empty & entry_name = "dl_fscope_all"
	then cd_ptr -> code = 0;
	else cd_ptr -> code = temp_code;

	call clean_up;
	go to exit;

     end error;
%page;
examine_queue:
     proc;

/*
   This routine will scan the priority and normal waiting queues until it comes across a waiting process that is
   eligble to set scope (ie, the scope requested does not conflict with current scopes now that the deleting process
   has deleted its scope).  If it  finds one such process, it will send it a wakeup, notifying it that it can proceed
   to set scope.  Only one (or none) such process will be awakened; it is the newly awakened process's job to see if
   another waiter is eligble to be awakened.
*/

	wakeup = OFF;				/* ON->wake this user up */
	QUE_FREE = fixed (unspec (CHAR_Q_F), 71);	/*  Wakeup message */

/* Check each waiting user. */

	ul_ptr = convert (dbc_ptr, dbc.waiting_users_ofs);

	do while (ul_ptr ^= null & ^wakeup);

	     if ^user_list.event_signal_sw		/* no awakeners */
	     then do;

/* Check each relation(file) for conflict. */

		     fl_ptr = convert (dbc_ptr, user_list.fil_list_ofs);
		     wakeup = ON;
		     conflict_sw = OFF;

		     do while (fl_ptr ^= null & ^conflict_sw);

			model_rel_name = fil_list.name;

			unspec (actual_permits), unspec (actual_prevents) = "0"b; /* init */

			actual_permits.read_attr = fil_list.permits.read_attr;
			actual_permits.modify_attr = fil_list.permits.modify_attr;
			actual_permits.append_tuple = fil_list.permits.append_tuple;
			actual_permits.delete_tuple = fil_list.permits.delete_tuple;

			actual_prevents.read_attr = fil_list.prevents.read_attr;
			actual_prevents.modify_attr = fil_list.prevents.modify_attr;
			actual_prevents.append_tuple = fil_list.prevents.append_tuple;
			actual_prevents.delete_tuple = fil_list.prevents.delete_tuple;

			call mu_check_scope (dbc_ptr, addr (model_rel_name), ul_ptr, addr (actual_permits),
			     addr (actual_prevents), addr (unused_conflict_detail),
			     conflict_sw, conflict_ul_ptr);


/* if there was a conflict, see if it is because of a dead process.
   if there is a dead process that was passive, it will be de-queued and this process will continue checking the files;
   if dead proc was updating (non-passive) this process will awaken waiting user-where its attempt to set will fail;
   if no dead proc, stop checking the files because there is a conflict with a live user, but continue checking */


			if conflict_sw		/* There was conflict */
			then do;
				call check_dead_proc (conflict_sw, status);
				if conflict_sw
				then wakeup = OFF;	/* conflict was not worked out */
			     end;

			fl_ptr = convert (dbc_ptr, fil_list.next_ofs);
		     end;

/* Send the wakeup if user is eligble. */

		     if wakeup
		     then do;
			     call hcs_$wakeup (user_list.process_id, user_list.ev_chn_id, QUE_FREE, state);
			     if state ^= 0
			     then wakeup = OFF;
			     else do;
				     user_list.event_signal_sw = ON;
				     dbc.wakeup_waiters = dbc.wakeup_waiters + 1;
				end;
			end;

/* A record of how many times this process was examined and NOT awakened is kept.  After a set limit is
   surpassed (allowance_count) the process is made high priority. */

		     if ^wakeup
		     then do;
			     user_list.bypass_count = user_list.bypass_count + 1;
			     if user_list.bypass_count >= user_list.allowance_count
			     then user_list.priority_high = ON;
			end;
		end;

	     ul_ptr = convert (dbc_ptr, user_list.next_waiting_ofs);
						/* Next user */
	end;


     end examine_queue;
%page;
check_dead_proc:
     proc (conflict_sw, status);

/* this checks for a potential stiff (dead process -- pointed to by conflict_ul_ptr ) and does what it can about it.
   if the process is dead and was a passive user, that process is de-queued and the dbc is somewhat cleaned up.
   if the process was non-passive then it could have died in the middle of an update and this running process
   can't do anything about it */

	dcl     (conflict_sw, status)	 bit (1);


/* Determine if process is alive or dead.  the technology for doing this is
   by calling set_lock_$lock and examining the returned code */

	if conflict_ul_ptr -> user_list.dead_proc
	then status = DEAD;
	else do;
		status = ALIVE;
		call set_lock_$lock ((conflict_ul_ptr -> user_list.db_lock_id), 0, state);
						/* Note that the lock_id arg is passed by value
						   so that the lock is not really set. */
		if state ^= 0
		then do;
			if state = error_table_$invalid_lock_reset
			then status = DEAD;
			else if state = error_table_$locked_by_this_process
			     | state = error_table_$lock_wait_time_exceeded
			then status = ALIVE;
			else icode = state;
		     end;
	     end;

/* Now see what can be done if it is dead */

	if status = ALIVE
	then ;
	else if conflict_ul_ptr -> user_list.passive_sw
	then do;
		conflict_sw = OFF;
		call mu_de_queue_user (DQ_OPEN, FREE_FIL_LIST, dbc_ptr, conflict_ul_ptr, icode);
	     end;

	else do;
		dbc.dead_proc_flag = ON;
		conflict_ul_ptr -> user_list.dead_proc = ON;
		user_list.dead_proc_conflict = ON;
	     end;

	if icode ^= 0
	then call error (icode);

	return;

     end check_dead_proc;
%page;
report_scope_detail: procedure ();

/* this rotuine reports on exactly why sufficient scope was not found
   for this delete operation to be performed */

	if conflict_detail_known then do;

		permit_conflict = "";

		if actual_conflict_detail.permits.read_attr then
		     permit_conflict = permit_conflict || "read_attr ";

		if actual_conflict_detail.permits.modify_attr then
		     permit_conflict = permit_conflict || "modify_attr ";

		if actual_conflict_detail.permits.append_tuple then
		     permit_conflict = permit_conflict || "append_tuple ";

		if actual_conflict_detail.permits.delete_tuple then
		     permit_conflict = permit_conflict || "delete_tuple ";

		if permit_conflict = "" then
		     permit_conflict = "null ";

		prevent_conflict = "";

		if actual_conflict_detail.prevents.read_attr then
		     prevent_conflict = prevent_conflict || "read_attr ";

		if actual_conflict_detail.prevents.modify_attr then
		     prevent_conflict = prevent_conflict || "modify_attr ";

		if actual_conflict_detail.prevents.append_tuple then
		     prevent_conflict = prevent_conflict || "append_tuple ";

		if actual_conflict_detail.prevents.delete_tuple then
		     prevent_conflict = prevent_conflict || "delete_tuple ";

		if prevent_conflict = "" then
		     prevent_conflict = "null ";

		call sub_err_ (mrds_error_$scope_not_found, caller_name, continue, info_ptr, return_value,
		     "^/^a^a^a^/^a^a^a^a^a",
		     "The scope delete request contained extra permits of """, permit_conflict,
		     """", "and/or extra prevents of """, prevent_conflict,
		     """ that were not present in the scope currently set, on the relation """,
		     conflict_relation, """.");

	     end;

	return;


	declare (permit_conflict, prevent_conflict) char (80) varying; /* extra scope that was not present */

     end;
%page;
sufficient_scope_exists:
     procedure () returns (bit (1));

/*	This procedure checks to be sure the scope to be deleted in fact exists	*/

	dcl     found		 bit (1);		/* ON => relation name found */

/* find the specified relation */
	fl_ptr = convert (dbc_ptr, user_list.fil_list_ofs);

	found = OFF;
	do while (^found);
	     if fl_ptr = null ()
	     then found = ON;
	     else if model_rel_name = fil_list.name
	     then found = ON;
	     else fl_ptr = convert (dbc_ptr, fil_list.next_ofs);
	end;

/* Check the current scope */

	suf_scope = "1"b;				/* assume innocent til proven guilty */
	if fl_ptr = null then do;
		actual_conflict_detail.permits = permit_requests;
		actual_conflict_detail.prevents = prevent_requests;

		if permit_requests.modify_attr | permit_requests.read_attr |
		     permit_requests.append_tuple | permit_requests.delete_tuple |
		     prevent_requests.modify_attr | prevent_requests.read_attr |
		     prevent_requests.append_tuple | prevent_requests.delete_tuple
		then do;
			suf_scope = "0"b;		/* non-null scope deletion requested */
		     end;
		else suf_scope = "1"b;		/* it's ok to dl null scope on a
						   rel that never had scope set */
	     end;

	else do;
		conflict_detail_ptr = addr (actual_conflict_detail);
		call mu_check_conflict (DEL, fl_ptr, permit_requests_ptr, prevent_requests_ptr,
		     conflict_detail_ptr, conflict_sw);
		if conflict_sw then do;
			suf_scope = "0"b;
			conflict_detail_known = "1"b;
			conflict_relation = rel_name;
		     end;
	     end;

	return (suf_scope);

	declare suf_scope		 bit (1);		/* on => suf scope exists */

     end sufficient_scope_exists;
%page;
delete_scope: procedure;

/*    This routine deletes scope by updating accss bits in scope_info and dbc (fil_list), removes relation from dbc (fil_list)
   if all scope is deleted and flags the user to be deactivated if all scope on all relations is deleted. */

	dcl     (found_matching_fil_list, active_scope_seen, finished) bit (1);
	dcl     ds_rmri_ptr		 ptr;		/* pointer to the rm_rel_info structure */

/* Update resultant model scope_info -- access bits. */

	if permit_requests.read_attr then
	     scope_info.scope (pos_in_si).flags.permits.read_attr = OFF;

	if permit_requests.modify_attr then
	     scope_info.scope (pos_in_si).flags.permits.modify_attr = OFF;

	if permit_requests.append_tuple then
	     scope_info.scope (pos_in_si).flags.permits.append_tuple = OFF;

	if permit_requests.delete_tuple then
	     scope_info.scope (pos_in_si).flags.permits.delete_tuple = OFF;

	if prevent_requests.read_attr then
	     scope_info.scope (pos_in_si).flags.prevents.read_attr = OFF;

	if prevent_requests.modify_attr then
	     scope_info.scope (pos_in_si).flags.prevents.modify_attr = OFF;

	if prevent_requests.append_tuple then
	     scope_info.scope (pos_in_si).flags.prevents.append_tuple = OFF;

	if prevent_requests.delete_tuple then
	     scope_info.scope (pos_in_si).flags.prevents.delete_tuple = OFF;

	if string (scope_info.scope (pos_in_si).flags.prevents) = "0"b &
	     string (scope_info.scope (pos_in_si).flags.permits) = "0"b then
	     scope_info.scope (pos_in_si).flags.touched = OFF;

/* Find relation in fil_list list */

	fl_ptr = convert (dbc_ptr, user_list.fil_list_ofs);
	flo_ptr = addr (user_list.fil_list_ofs);
	found_matching_fil_list = OFF;

	do while (fl_ptr ^= null & ^found_matching_fil_list);
	     if model_rel_name = fil_list.name
	     then found_matching_fil_list = ON;
	     else do;
		     flo_ptr = addr (fil_list.next_ofs);/* save ptr for possible alteration next time around */
		     fl_ptr = convert (dbc_ptr, fil_list.next_ofs);
		end;
	end;

/* Tell relation manager about the scope change if necessary.  Calculate
   scopes both before and after the deletion and call rel_mgr_ only if
   they are different */

	if fl_ptr ^= null
	then do;					/*  if it is null, then there was no scope
						   to be deleted for this fil */
		call calc_process_scopes (/* Find relmgr scope */
		     convert (dbc_ptr, dbc.active_users_ofs),
		     model_rel_name, addr (rdbi_ptr) -> ptr_bit_string,
		     other_rmg_permits, other_rmg_prevents, current_rmg_permits,
		     current_rmg_prevents);
		old_rmg_permits = other_rmg_permits | current_rmg_permits;
		old_rmg_prevents = other_rmg_prevents | current_rmg_prevents;
		new_rmg_permits = other_rmg_permits |
		     (permit_requests.read_attr || (permit_requests.append_tuple
		     | permit_requests.modify_attr
		     | permit_requests.delete_tuple));
		new_rmg_prevents = other_rmg_permits |
		     (^prevent_requests.read_attr ||
		     ^(prevent_requests.append_tuple
		     & prevent_requests.delete_tuple
		     & prevent_requests.modify_attr));
		if (old_rmg_permits ^= new_rmg_permits) |
		     (old_rmg_prevents ^= new_rmg_prevents) then do;
			ds_rmri_ptr = pointer (baseptr (baseno (fil_list.rmri_ptr)), rel (fil_list.rmri_ptr));
			call dbcb.relmgr_entries.set_scope (ds_rmri_ptr -> rm_rel_info.opening_id,
			     new_rmg_permits, new_rmg_prevents, icode);
			if icode ^= 0
			then call error (icode);
		     end;


/* Update dbc scope info -- fil_list access bits. */

		if string (scope_info.scope.flags (pos_in_si)) = "0"b
		then do;				/* all scope for this relation is being deleted */
			scope_info.active_scopes = scope_info.active_scopes - 1;
						/* so indicate one less scope tuple */
			flo_ptr -> ophset = fil_list.next_ofs;
			free fil_list in (dbc.static_area);
		     end;

		else do;				/* scope must be modified rather than deleted */

			fil_list.permits.read_attr = (fil_list.permits.read_attr &
			     ^(permit_requests.read_attr));
			fil_list.permits.modify_attr = (fil_list.permits.modify_attr &
			     ^(permit_requests.modify_attr));
			fil_list.permits.append_tuple = (fil_list.permits.append_tuple &
			     ^(permit_requests.append_tuple));
			fil_list.permits.delete_tuple = (fil_list.permits.delete_tuple &
			     ^(permit_requests.delete_tuple));
			fil_list.permits.update = (fil_list.permits.modify_attr |
			     fil_list.permits.append_tuple | fil_list.permits.delete_tuple);


			fil_list.prevents.read_attr = (fil_list.prevents.read_attr &
			     ^(prevent_requests.read_attr));
			fil_list.prevents.modify_attr = (fil_list.prevents.modify_attr &
			     ^(prevent_requests.modify_attr));
			fil_list.prevents.append_tuple = (fil_list.prevents.append_tuple &
			     ^(prevent_requests.append_tuple));
			fil_list.prevents.delete_tuple = (fil_list.prevents.delete_tuple &
			     ^(prevent_requests.delete_tuple));
			fil_list.prevents.update = (fil_list.prevents.modify_attr |
			     fil_list.prevents.append_tuple | fil_list.prevents.delete_tuple);
		     end;
	     end;

	if user_list.fil_list_ofs = NULL_OFS
	then make_user_inactive = ON;			/* All scope gone */

	saved_fl_ptr = fl_ptr;
	fl_ptr = pointer (dbc_ptr, user_list.fil_list_ofs);
	active_scope_seen = OFF;
	finished = OFF;
	do while (^finished);

	     if rel (fl_ptr) = NULL_OFS then
		finished = ON;
	     else if fil_list.permits.modify_attr | fil_list.permits.append_tuple |
		fil_list.permits.delete_tuple then do;
		     active_scope_seen = ON;
		     finished = ON;
		end;
	     else fl_ptr = pointer (dbc_ptr, fil_list.next_ofs);
	end;

	if ^active_scope_seen then
	     user_list.passive_sw = ON;		/* no longer holding update type of scope */


	fl_ptr = saved_fl_ptr;
	return;

     end delete_scope;
%page;
convert:
     proc (a_ptr, ofs) returns (ptr);

/* this procedure function converts an offset from "0"b to null
   or from the offset value to a pointer value within the segment denoted by a_ptr
*/

	dcl     result		 ptr;		/* the reultant pointer value */
	dcl     a_ptr		 ptr;		/* ptr to the segment to which the offset refers */
	dcl     ofs		 bit (18) unal;	/* the bit offset */

	dcl     (null, ptr)		 builtin;

	if ofs ^= NULL_OFS
	then result = ptr (a_ptr, ofs);
	else result = null;

	return (result);

     end convert;
%page;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*					       */
/* This routine is used to find the total scopes set by  */
/* a process on a particular database.  This is needed   */
/* for the relation_manager_$set_scope entry point.      */
/* The routine will look through the active user list    */
/* in the dbc, combining scopes for the relation of      */
/* interest if there are scopes set by the current       */
/* process.  The scopes for the current db opening are   */
/* not included in this but are returned separately.     */
/* This is so that the combined scope just before and    */
/* after the scope setting can be predicted	       */
/*					       */
/* Parameters (input):			       */
/*					       */
/*  user_list_ptr - the active user list of the database */
/*                  of interest.		       */
/*  relation_name - the name of the relation of interest */
/*  rdbi_ptr_bits - bit representation of the pointer    */
/*                  to the rm_db_info structure. It is   */
/*                  used to tell which scopes	       */
/*                  correspond to the current opening    */
/*                  id.			       */
/*					       */
/* Results (output)				       */
/*					       */
/*  relmgr_my_permits - the permits (rw) of my process   */
/*                      for the database.  This would    */
/*		    not include the current opening  */
/*		    id.                              */
/*  relmgr_other_permit - everyone else's permits	       */
/*                        (prevents)		       */
/*  relmgr_except_my_permits - relmgr_ permits for the   */
/*                             current opening.	       */
/*  relmgr_except_other_permits - the prevents for       */
/*                                current	       */
/*					       */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


calc_process_scopes:
     proc (user_list_ptr, relation_name, rdbi_ptr_bits, relmgr_my_permits,
	relmgr_other_permits, relmgr_except_my_permits,
	relmgr_except_other_permits);


/* Parameters */

	dcl     user_list_ptr	 ptr;
	dcl     relation_name	 char (30);
	dcl     rdbi_ptr_bits	 bit (72);
	dcl     relmgr_my_permits	 bit (2);
	dcl     relmgr_other_permits	 bit (2);
	dcl     relmgr_except_my_permits bit (2);
	dcl     relmgr_except_other_permits bit (2);


/* Automatic */

	dcl     f_ptr		 ptr;		/* Current file_list entry */
	dcl     my_process_id	 bit (36);	/* My pid */
	dcl     temp_relmgr_my_permits bit (2);		/* permits for one db open */
	dcl     temp_relmgr_other_permits bit (2);	/* prevents */
	dcl     u_ptr		 ptr;		/* Current user_list entry */


	u_ptr = user_list_ptr;
	my_process_id = get_process_id_ ();
	relmgr_my_permits, relmgr_other_permits = "00"b;
	do while (u_ptr ^= null ());			/* Search user list */
	     if u_ptr -> user_list.offsets.fil_list_ofs = NULL_OFS
	     then f_ptr = null ();
	     else f_ptr = ptr (u_ptr,
		     u_ptr -> user_list.offsets.fil_list_ofs);
	     if u_ptr -> user_list.ids.process_id = my_process_id then
		do while (f_ptr ^= null ());		/* Search file list */
		     if f_ptr -> fil_list.name = relation_name then do;
			     temp_relmgr_my_permits =
				f_ptr -> fil_list.permits.read_attr ||
				f_ptr -> fil_list.permits.update;
			     temp_relmgr_other_permits =
				^f_ptr -> fil_list.prevents.read_attr |
				^(f_ptr -> fil_list.prevents.modify_attr &
				f_ptr -> fil_list.prevents.append_tuple &
				f_ptr -> fil_list.prevents.delete_tuple);
			     if rdbi_ptr_bits ^=
				u_ptr -> user_list.ids.rdbi_bits then do;
				     relmgr_my_permits = relmgr_my_permits
					| temp_relmgr_my_permits;
				     relmgr_other_permits = relmgr_other_permits
					| temp_relmgr_other_permits;
				end;
			     else do;
				     relmgr_except_my_permits =
					temp_relmgr_my_permits;
				     relmgr_except_other_permits =
					temp_relmgr_other_permits;
				end;
			end;
		     if f_ptr -> fil_list.next_ofs = NULL_OFS
		     then f_ptr = null ();
		     else f_ptr = ptr (u_ptr,
			     f_ptr -> fil_list.next_ofs);
		end;
	     if u_ptr -> user_list.offsets.next_active_ofs = NULL_OFS
	     then u_ptr = null ();
	     else u_ptr = ptr (u_ptr,
		     u_ptr -> user_list.offsets.next_active_ofs);
	end;
     end calc_process_scopes;

%page;
clean_up:
     proc;
	if make_user_inactive
	then call mu_de_queue_user (NO_DQ_OPEN, FREE_FIL_LIST, dbc_ptr, ul_ptr, (0));

	if dbc_ptr ^= null
	then do;
		if code ^= error_table_$lock_wait_time_exceeded
		then do;				/* if a timeout then leave scope as is */
		     end;
		call set_lock_$unlock (dbc.scope_lock, icode);
	     end;
     end clean_up;


/* *************************************************************
   *    Logical end of program; include files of dcl's follow    *
   ************************************************************** */
%page;

	dcl     db_index		 fixed bin (35) based (dbi_ptr);
						/* index of data base to perform dl_fscope upon */
	dcl     rel_name		 char (rel_len) based (rel_ptr);
						/* relation name part of scope tuple */

/* operations to be prevented of other processes */
	dcl     state		 fixed bin (35),
	        code		 fixed bin (35) based (cd_ptr);
						/* standard system return code */


	dcl     my_pid		 bit (36);	/* Current process id */
	dcl     conflict_sw		 bit (1) unal;	/* ON => scope conflict exists */
	dcl     make_user_inactive	 bit (1) unal;	/* ON => no scope left, must takeoff the active list */
	dcl     status		 bit (1) unal;	/* ON => process is alive; OFF => dead */
	dcl     wakeup		 bit (1) unal;	/* ON => send a wakeup message to a waiting user */

	dcl     current_rmg_permits	 bit (2);		/* Current combined permits of opening to change */
	dcl     current_rmg_prevents	 bit (2);		/* Current combined prevents */
	dcl     new_rmg_permits	 bit (2) aligned;	/* Combined permits after scope deletion */
	dcl     new_rmg_prevents	 bit (2) aligned;	/* Combined prevents after scope deletion */
	dcl     old_rmg_permits	 bit (2);		/* Total combined permits */
	dcl     old_rmg_prevents	 bit (2);		/* Total combined prevents */
	dcl     other_rmg_permits	 bit (2);		/* Current combined permits of everything else */
	dcl     other_rmg_prevents	 bit (2);		/* Prevents of everything else */

	dcl     (
	        nargs,				/* number of arguments passed to dl_fscope */
	        arg_len,				/* argument length in chars */
	        num_tuples,				/* number of scope tuples represented by arg_list */
	        i,
	        pos_in_si,				/* index in scope_info array */
	        pos_in_rmfa,			/* index in rm_rel_array */
	        args_exp,				/* number of args in calling argument list */
	        arg_index,				/* index to current scope tuple in arg_list */
	        rel_len
	        )			 fixed bin;	/* length of rel_name */

	dcl     icode		 fixed bin (35);	/* internal status code */

	dcl     temp_uid		 bit (36) aligned;	/* uid of the segment that the dbc_ptr points to */

	dcl     ptr_bit_string	 bit (72) based;	/* bit string format of pointer variable */

	dcl     rel_name_32		 char (32);	/* Used to search rm_rel_array */
	dcl     entry_name		 char (32);	/* name by which this procedure was called */
	dcl     model_rel_name	 char (30);	/* relation name parameter used by check_scope
						   --check_scope only knows of model relation names */
	dcl     ophset		 bit (18) unal based; /* offset format */

	dcl     (
	        cd_ptr,				/* pointer to return code */
	        dbi_ptr,				/* pointer to data base index (db_index) */
	        rel_ptr,				/* pointer to rel_name */
	        find_ul_ptr,			/* ptr to user_list entry */
	        conflict_ul_ptr,			/* ptr to user who is causing a conflict with requested scopes */
	        flo_ptr				/* ptr to an offset to a file_list entry */
	        )			 ptr;		/* pointer to prevent operations */

	dcl     (cleanup, arg_error)	 condition;
	dcl     (addr, rel, null, string)
				 builtin;



/*		Multics subroutines 		*/

	dcl     cu_$arg_count	 entry (fixed bin),
	        cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin, fixed bin (35)),
	        set_lock_$lock	 entry (bit (36) aligned, fixed bin, fixed bin (35)),
	        set_lock_$unlock	 entry (bit (36) aligned, fixed bin (35)),
	        hcs_$wakeup		 entry (bit (36), fixed bin (71), fixed bin (71), fixed bin (35)),
	        hcs_$get_uid_seg	 entry (ptr, bit (36) aligned, fixed bin (35)),
	        get_process_id_	 entry returns (bit (36));

/*		Other subroutines		*/

	dcl     mu_database_index$get_resultant_model_pointer
				 entry (fixed bin (35), ptr),
	        mu_check_scope	 entry (ptr, ptr, ptr, ptr, ptr, ptr, bit (1), ptr),
	        mu_de_queue_user
				 entry (bit (1), bit (1), ptr, ptr, fixed bin (35)),
	        mu_check_conflict
				 entry (bit (1), ptr, ptr, ptr, ptr, bit (1));

/*		External data		*/

	dcl     (error_table_$wrong_no_of_args,
	        error_table_$lock_wait_time_exceeded,
	        error_table_$invalid_lock_reset,
	        error_table_$locked_by_this_process,
	        mrds_data_$lock_wait_time,
	        mrds_error_$invalid_db_index,
	        mrds_error_$rel_name_too_long,
	        mrds_error_$scope_empty,
	        mrds_error_$unknown_relation_name,
	        mrds_error_$non_scope_ready,
	        mrds_error_$scope_not_found,
	        mrds_error_$unknown_proc_id,
	        sys_info$max_seg_size) fixed bin (35) ext;
	dcl     OFF		 bit (1) init ("0"b) static internal options (constant);
	dcl     ON		 bit (1) init ("1"b) static internal options (constant);
	declare 1 actual_permits	 like common;
	declare 1 actual_prevents	 like common;
	declare 1 actual_conflict_detail,		/* details of why dl_scope failed */
		2 permits		 like common,
		2 prevents	 like common;
	declare 1 unused_conflict_detail,		/* throw away detail */
		2 permits		 like common,
		2 prevents	 like common;
	declare sub_err_		 entry options (variable); /* reports errors */
	declare caller_name		 char (32) init ("mrds_dsl_dl_fscope"); /* name of calling routine */
	declare continue		 char (1) init ("c"); /* dont stop after printing error */
	declare info_ptr		 ptr init (null ());/* unused */
	declare return_value	 fixed bin (35) init (0); /* unused */
	declare conflict_relation	 char (32);	/* name of relation where tried to delete more scope than present */
	declare conflict_detail_known	 bit (1) init ("0"b); /* on => knwo details of conflict */
	declare saved_fl_ptr	 ptr;		/* remember old fl_ptr */
	dcl     divide		 builtin;
	dcl     fixed		 builtin;
	dcl     index		 builtin;
	dcl     length		 builtin;
	dcl     mod		 builtin;
	dcl     pointer		 builtin;
	dcl     baseno		 builtin;
	dcl     baseptr		 builtin;
	dcl     ptr		 builtin;
	dcl     rtrim		 builtin;
	dcl     unspec		 builtin;
%page;
%include mrds_dbcb;
%page;
%include mdbm_scope_requests;
%page;
%include mdbm_scope_info;
%page;
%include mdbm_dbc;
%page;
%include mdbm_users;
%page;
%include mdbm_rm_db_info;
%page;
%include mdbm_rm_rel_array;
%page;
%include mdbm_rm_rel_info;



     end mrds_dsl_dl_fscope;

