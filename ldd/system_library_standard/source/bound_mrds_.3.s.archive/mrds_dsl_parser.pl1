/****^  ********************************************
        *                                          *
        * Copyright, (C) Honeywell Bull Inc., 1988 *
        *                                          *
        ******************************************** */

mrds_dsl_parser:
    proc (dbcb_ptr, area_ptr, caller, option_list_ptr, se_ptr, se_len, arg_ptr,
         desc_ptr,
         num_args, current_flag, code);

/****^  HISTORY COMMENTS:
  1) change(87-01-22,Hergert), approve(88-07-11,MCR7903),
     audit(88-07-07,Dupuis), install(88-08-01,MR12.2-1073):
     Written.
  2) change(88-05-06,Hergert), approve(88-07-11,MCR7903),
     audit(88-07-07,Dupuis), install(88-08-01,MR12.2-1073):
     Fixed bugs and inadequacies from original design required to pass
     audit and regression tests.
                                                   END HISTORY COMMENTS */

/* This module scans and  parses the MRDS selection expression language.
   The language and the skeleton of this code was designed using LALR.
   It was then customized to work with the rest of MRDS. 
   That is why parts of this code may seem mechanical and confusing.
   I did not spend much time to try and optimize it for either performance
   or readability.

   Caveats and disclaimers aside, this code scans and reads the input
   selection expression. It parses it by walking through the parser tables
   that were generated by LALR a token at a time and selectivly calling
   mrds_dsl_semantics to actually do any work that may be required.
   When this module returns to mrds_dsl_translate, the selection
   expression will have been translated into tabular form and optimized,
   or an error will have been detected and reported.
*/

        dbi_pic = dbcb.dbi;
        call mu_define_area$define_temp_dir_area (
	   dbcb.parser_work_area_ptr, dbcb.dbi, (sys_info$max_seg_size),
	   "MRDS" || dbi_pic, "0"b, "1"b, "0"b, "0"b, code);
        if code ^= 0 then call error (code);

        allocate parser_static_info
	   in (dbcb.parser_work_area_ptr -> parser_work_area);
        parser_static_info.pwa_ptr = dbcb.parser_work_area_ptr;
        parser_static_info.ns_ptr = null;

        current_state = 1;
        lookahead_put, lookahead_get = -1;
        parse_stack_top = 0;
        lookahead_count = 0;
        code = 0;

        unspec (parser_se_info) = "0"b;

        parser_se_info.se_ptr = se_ptr;
        parser_se_info.se_length = se_len;
        parser_se_info.se_cursor = 1;

        call mrds_dsl_semantics$init (addr (parser_lex_stack),
	   addr (parser_se_info),
	   dbcb_ptr, psi_ptr, area_ptr, caller, option_list_ptr,
	   arg_ptr, desc_ptr, num_args, current_flag);

/* The parsing loop. */
NEXT:
        if current_state = 0 then goto parse_done;

        current_table = current_state;
        if debug then do;
	  db_item = "";
	  db_data.state = current_state;
	  db_data.top = parse_stack_top;
        end;

        goto CASE (dpda.v1 (current_table));


CASE (3):						/* Multiple lookahead (k > 1) with shared look table. */
        current_table = dpda.v2 (current_table);


CASE (1):						/* Multiple lookahead (k > 1) without default transition. */
        lookahead_use = lookahead_get - lookahead_need;

        if lookahead_use < lbound (lookahead, 1)
        then lookahead_use = lookahead_use - lbound (lookahead, 1);

        lookahead_need = lookahead_need + 1;

        goto read_look;


CASE (10):					/* Obsolete -- Lookahead 1 (sometimes called read without
						   stacking) with shared transition table. */

CASE (2):						/* Read and stack and/or lookahead 1 (sometimes called
						   read without stacking) with shared transition table.
						   (Read transitions to state S are coded as +S while
						   lookahead transitions to state S are coded -S.) */
        current_table = dpda.v2 (current_table);

CASE (0):						/* Read and stack and/or lookahead 1 with neither a
						   default transition nor a marked symbol transition. */
CASE (9):						/* Obsolete -- Lookahead 1 (sometimes called
						   read without stacking). */
        lookahead_need = 1;
        lookahead_use = lookahead_get;


read_look:
        do while (lookahead_count < lookahead_need);	/* Make sure enough symbols are available. */

	  call scanner (lookahead_put);

	  if lookahead_put = lbound (lookahead, 1) then lookahead_put = 0;

	  lookahead_put = lookahead_put - 1;
	  lookahead_count = lookahead_count + 1;
        end;

        test_token = lookahead.token_id (lookahead_use);

/* Look current token_id up in the read list. */
        m = 0;
        do i = current_table + 1 to current_table + dpda.v2 (current_table);
	  n = dpda.v1 (i);

	  if n < 0 then do;
	      n = -n;
	      m = i;				/* Record a marked symbol transition. */
	  end;

	  if n = test_token then do;
	      next_state = dpda.v2 (i);
	      goto got_token;
	  end;

	  if n > test_token then goto not_found;

        end;


not_found:
        if m > 0 then do;				/* If marked symbol was in table, use it. */
	  next_state = dpda.v2 (m);
	  goto got_token;
        end;

        if debug then call ioa_$nnl (" ^4i^/", current_state);

        parser_se_info.loud = "1"b;
        parser_se_info.error_type = SE_TYPE;
        parser_se_info.error_msg =
	   "The unexpected " || get_terminal (lookahead_use)
	   || " was encountered.";
        call error (mrds_error_$sell_syntax);
        goto parse_done;


got_token:
        if debug then db_data.data = get_terminal (lookahead_use);

        if next_state < 0 then do;			/* This is a lookahead transition. */
	  if debug then do;
	      db_data.type = "LK01";
	      db_look = lookahead_need;
	  end;
	  current_state = -next_state;
        end;
        else do;					/* This is a read transition. */
	  if debug then do;
	      db_data.type = "READ";
	      db_data.flag = "*";
	  end;

	  if parse_stack_top >= hbound (parse_stack, 1)
	  then do;
	      parser_se_info.loud = "1"b;
	      parser_se_info.error_type = IL_TYPE;
	      parser_se_info.error_msg =
		 "The current stack top of "
		 || ltrim (char (parse_stack_top))
		 || ", exceeded the limit of "
		 || ltrim (char (hbound (parse_stack, 1)))
		 || ". Contact systems programming staff.";
	      call error (mrds_error_$parser_stack_overflow);
	  end;

	  parse_stack_top = parse_stack_top + 1;
	  parse_stack (parse_stack_top) = current_state;	/* Stack the current state. */
	  unspec (parser_lex_stack (parse_stack_top)) =
	       unspec (lookahead (lookahead_get));

	  if lookahead_get = lbound (lookahead, 1) then lookahead_get = 0;

	  lookahead_get = lookahead_get - 1;
	  lookahead_count = lookahead_count - 1;
	  current_state = next_state;
        end;

        if debug then call ioa_$nnl ("^a^/", db_item);

        goto NEXT;


CASE (14):					/* Multiple lookahead (k > 1) with either (but not both)
						   a default transition or a marked symbol transition. */
CASE (16):					/* Multiple lookahead (k > 1) with the table
						   continued at another state. */
CASE (15):					/* Read and stack and/or lookahead 1 with either (but not both)
						   a default transition or a marked symbol transition. */
CASE (17):					/* Read and stack and/or lookahead 1
						   continued at another state. */
CASE (7):						/* Null state -- presence indicates LALR failure. */
CASE (8):						/* Final state -- should only appear as state zero. */

CASE (4):						/* Apply by rule and alternative with lookback table. */
CASE (5):						/* Apply by rule and alternative without lookback. */
CASE (6):						/* Apply by rule and alternative with shared lookback table. */

CASE (18):					/* Apply by rule with lookback table. */
CASE (19):					/* Apply by rule without lookback. */
CASE (20):					/* Apply by rule with shared lookback table. */

        parser_se_info.loud = "0"b;
        call error (mrds_error_$parser_unrecognized_state);

CASE (13):					/* Apply by production with shared lookback table. */
        current_table = dpda.v2 (current_state + 2);
CASE (11):					/* Apply by production with lookback table. */
CASE (12):					/* Apply by production without lookback. */
        production_number = dpda.v1 (current_state + 2);

        if debug then do;
	  db_data.type = "APLY";
	  if dpda.v1 (current_state + 1) < 0 then db_data.flag = "*";
	  call ioa_$nnl ("^a  (^i", db_item, production_number);
	  call print_production_name (production_number);
	  call ioa_$nnl (")^-sd = ^i ", dpda.v1 (current_state + 1));
	  if dpda.v1 (current_state + 1) > 0 then do;
	      db_separator = "(";
	      do t = parse_stack_top
		 to parse_stack_top - dpda.v1 (current_state + 1) + 1
		 by -1;
		call ioa_$nnl ("^1a^d", db_separator, parse_stack (t));
		db_separator = "";
	      end;
	      call ioa_$nnl (")");
	  end;
	  call ioa_$nnl ("^/");
        end;

        if dpda.v1 (current_state + 2) > 0 then do;
	  call mrds_dsl_semantics (psi_ptr, lex_stack_top, production_number,
	       code);
	  if code ^= 0
	  then if code = mrds_error_$bad_attr |
		  code = mrds_error_$bad_var then do;

/* At this point the semantics routine has rejected the token on the top 
   of the stack (which is an identifier) as "not_found". It is possible
   that there is a hyphen buried in it that is suipposed to be a minus
   sign or the beginning of a keyword. If the hyphen exists in the token
   we will truncate the token just before the hyphen and try again. */

		 i = index (lex_token, "-") - 1;

		 if i > 0 then do;
		     parser_se_info.token_length,
			parser_lex_stack.token_length (lex_stack_top) =
			i;
		     parser_se_info.se_cursor =
			parser_lex_stack.token_start_pos (lex_stack_top)
			+ i;
		     lookahead_count = 0;		/* this should empty lookahead stack */
		     lookahead_get, lookahead_put = -1;

		     call mrds_dsl_semantics (psi_ptr, lex_stack_top,
			production_number, code);
		     if code ^= 0 then call error (code);
		 end;
		 else call error (code);
	       end;
	       else call error (code);
        end;

/* Check for an apply of an empty production.
   In this case the apply state number must be
   pushed onto the parse stack.  (Reference
   LaLonde, W. R.:  An efficient LALR Parser Generator.
   Tech. Report CSRG-2, 1971, pp. 34-35.) */

        if dpda.v1 (current_state + 1) < 0 then do;
	  if parse_stack_top >= hbound (parse_stack, 1) then do;
	      parser_se_info.loud = "1"b;
	      parser_se_info.error_type = IL_TYPE;
	      parser_se_info.error_msg =
		 "The current stack top of "
		 || ltrim (char (parse_stack_top))
		 || ", exceeded the limit of "
		 || ltrim (char (hbound (parse_stack, 1)))
		 || ". Contact systems programming staff.";
	      call error (mrds_error_$parser_stack_overflow);
	  end;
	  parse_stack (parse_stack_top + 1) = current_state;
        end;

/* Delete lexical & parse stack entries. */
        parse_stack_top = parse_stack_top - dpda.v1 (current_state + 1);
        if parse_stack_top <= 0
        then do;
	  parser_se_info.loud = "0"b;
	  call error (mrds_error_$parser_logic_error);
        end;

        test_state = parse_stack (parse_stack_top);
        lb = current_table + 3;
        ub = current_table + dpda.v2 (current_table);

        do while (lb <= ub);

	  i = divide (ub + lb, 2, 17, 0);

	  if dpda.v1 (i) = test_state then do;
	      current_state = dpda.v2 (i);
	      goto NEXT;
	  end;
	  else if dpda.v1 (i) < test_state
	       then lb = i + 1;
	       else ub = i - 1;
        end;

        current_state = dpda.v2 (current_table + 2);
        goto NEXT;

parse_done:

        return;

get_terminal:
    proc (lex_stack_index) returns (char (100) varying);

dcl     lex_stack_index	 fixed bin parameter;
dcl     temp		 char (100) varying;
dcl     (length, min, substr)
			 builtin;

        if parser_lex_stack.token_id (lex_stack_index) = 0
        then return ("end of the selection expression");
        else
	  begin;



dcl     token		 char (
			 min (50,
			 parser_lex_stack.token_length (lex_stack_index))
			 )
			 based (parser_lex_stack
			 .token_ptr (lex_stack_index));

dcl     terminal		 char (terminals_list
			 .
			 length (parser_lex_stack
			 .token_id (lex_stack_index)))
			 defined (terminal_characters)
			 position (terminals_list
			 .
			 position (parser_lex_stack
			 .token_id (lex_stack_index)))
			 ;

	      if length (terminal) > 2 & substr (terminal, 1, 1) = "<"
		 & substr (terminal, length (terminal), 1) = ">" then do;

		temp = substr (terminal, 2, length (terminal) - 2);

		if length (token) > 0
		then
		     temp = temp || " '" || token || "'";

	      end;
	      else if (substr (terminal, 1, 1)) = "-" & length (terminal) > 1
		 then do;
		     temp = "keyword '";

		     if length (token) > 0
		     then temp = temp || token;
		     else temp = temp || terminal;

		     temp = temp || "'";
		 end;
		 else temp = "operator '" || terminal || "'";

	      return (temp);
	  end;
    end get_terminal;

print_production_name:
    proc (production_name_index);
dcl     production_name_index	 fixed bin parameter;
dcl     variables_list_index	 fixed bin;

        if hbound (production_names, 1) > 0 then do;
	  variables_list_index =
	       -production_names (abs (production_name_index));

	  begin;

dcl     production_name	 char (variables_list
			 .length (variables_list_index))
			 defined (variable_characters)
			 position (variables_list
			 .position (variables_list_index));

	      call ioa_$nnl (" ^a", production_name);
	  end;
        end;
        return;
    end print_production_name;

dbn:
    entry ();
        debug = "1"b;
        return;
dbf:
    entry ();
        debug = "0"b;
        return;

dbsn:
    entry ();
        scanner_debug = "1"b;
        return;
dbsf:
    entry ();
        scanner_debug = "0"b;
        return;

error:
    proc (cd);
dcl     cd		 fixed bin (35);

        code, parser_se_info.error_code = cd;
        if parser_se_info.loud & option_list.error
        then call mu_print_error (addr (parser_se_info));

        goto parse_done;

    end;

scanner:
    proc (stack_index);

/*
   DESCRIPTION

   The purpose of this procedure is to return the next token in the
   selection expression to the parser. This is done via alook up table
   to conclude from the first character, what class of token we have.
   After  a token type has been determined, we parse that token and then
   look up its encoding in the keyword table then load the stacks.

   INPUT CONDITIONS:

   stack_index points to place in the lex stack where the info found
   is to be placed.

   OUTPUT DEFINITIONS:

   Blatant syntax errors like strings with no end quote and numbers that
   dont make sense (like 2.3e) are handled here. Other errors are left for
   the parser to find and report.

   se_cursor always points to the end of the token found plus 1

*/

        if scanner_debug then call ioa_$nnl ("Scanner: token key = ");

start:

        parser_se_info.token_start = parser_se_info.se_cursor;

        if parser_se_info.se_cursor > parser_se_info.se_length then do;
						/* check for EOI */
	  token_end = parser_se_info.se_cursor;
	  token_string = "eoi";
	  call load_stack;
	  goto finish;
        end;

        type = /* check first char to get an idea of type of token */
	   token_type_list (
	   char_class_list (rank (se_array (parser_se_info.se_cursor))));

        if scanner_debug then call ioa_$nnl (" ^d", type);

        goto token_type (type);

/* number */
token_type (1):


        state = 1;
number_entry:


        do while ((state > 0)
	   & (parser_se_info.se_length > parser_se_info.se_cursor));
	  parser_se_info.se_cursor = parser_se_info.se_cursor + 1;
						/* get the next char */
	  class =
	       char_class_list (rank (se_array (parser_se_info.se_cursor)));
	  if class > 6 then class = 6;		/* maximum state allowed */
	  state = num_state_table (state, class);
        end;

        if state > 0
        then token_end = parser_se_info.se_length;	/* last token was a number */
        else if state = -3
	   then token_end = parser_se_info.se_cursor;
	   else token_end = parser_se_info.se_cursor - 1;

        token_string = "<integer>";

/* now check to see if we have a bit string */

        if state < 0 then do; /* this is cheaper than checking se length */
	   if se_array (token_end+1) = B /* found a bit string */
	   then do;
	       if token_end+1 = parser_se_info.se_length
						/* end of string reached */
	       then token_end = token_end+1;
	       else if search ("1234",
		       se_array (token_end + 2)) = 0
		  then token_end = token_end+1;
		  else token_end = token_end+2;	/* take base also */

	       token_string = "<bit_string>";
	   end;
        end;

        call load_stack;

        goto finish;

/* decimal --> alone or a number or .v. */
token_type (2):


        if parser_se_info.se_length = parser_se_info.se_cursor
        then token_end = parser_se_info.se_cursor;
        else do;
	  i = verify (se_array (parser_se_info.se_cursor + 1), DIGITS);
						/* see if its a number or just a period */

	  if i ^= 0 then do;			/* period or arg substitution */

	      i = verify (se_array (parser_se_info.se_cursor + 1), "VvXx");
						/* Check for .v. or .x. */

	      if i ^= 0
	      then token_end = parser_se_info.se_cursor;
	      else if se_array (parser_se_info.se_cursor + 2) = "."
		 then token_end = parser_se_info.se_cursor + 2;
						/* found arg substitution */
		 else token_end = parser_se_info.se_cursor;
						/* just a period */
	  end;
	  else do;				/* found a number, go process it */
	      state = 2;
	      goto number_entry;
	  end;
        end;

        token_string = "";
        call load_stack;

        goto finish;

/* +- --> addop or keyword */
token_type (3):


        if parser_se_info.se_length = parser_se_info.se_cursor
        then i = 1;
        else i = verify (substr (se_string, parser_se_info.se_cursor + 1),
	        ALPHA_NUM);

        if i = 1
        then do;					/* just a - or + */
	  token_end = parser_se_info.se_cursor;
	  token_string = "";
	  call load_stack;
        end;
        else do;					/* check for keyword */

	  if i = 0 then do;				/* EOI encountered */
	      if (parser_se_info.se_length - parser_se_info.se_cursor)
		 > mrds_data_$max_id_len
	      then call scanner_error (mrds_error_$long_ident,
		      substr (se_string, parser_se_info.se_cursor));

	      token = substr (se_string, parser_se_info.se_cursor);
						/* take whole thing */
	      i = parser_se_info.se_length - parser_se_info.se_cursor + 1;
	  end;

	  else if i - 1 > mrds_data_$max_id_len		/* check token length */
	       then call scanner_error (mrds_error_$long_ident,
		       substr (se_string, parser_se_info.se_cursor, i));

	       else token = substr (se_string, parser_se_info.se_cursor, i);

	  call lookup_token (token, id);		/* see if token is a keyword */

	  if id = 0 then do;			/* just a - or a + */
	      token = substr (se_string, parser_se_info.se_cursor, 1);
	      call lookup_token (token, id);
	      if id = 0
	      then call scanner_error (mrds_error_$inv_token, token);
	      token_end = parser_se_info.se_cursor;
	  end;
	  else /* token is a keyword */
	       token_end = parser_se_info.se_cursor + i - 1;


	  parser_lex_stack.token_ptr (stack_index) = /* pointer to token */
	       addr (se_array (parser_se_info.token_start));

	  parser_se_info.token_length,		/* length of token */
	       parser_lex_stack.token_length (stack_index) =
	       token_end - parser_se_info.token_start + 1;

	  parser_lex_stack.token_id (stack_index) = id;
	  parser_lex_stack.token_start_pos (stack_index) =
	       parser_se_info.token_start;

	  parser_se_info.se_cursor = token_end + 1;

	  if token = "-no_ot" | token = "-no_optimize" then do;
	      parser_se_info.no_ot_seen = "1"b;
	      goto start;				/* get another token */
	  end;
	  else if token = "-pso" | token = "-print_search_order" then do;
		 parser_se_info.pso_seen = "1"b;
		 goto start;			/* get another token */
	       end;

        end;

        goto finish;

/*  symbol */
token_type (4):


        i = verify (substr (se_string, parser_se_info.se_cursor),
						/* find end */
	   ALPHA_NUM || "-")
	   - 1;

        if i = -1					/* EOI encountered, take whole thing */
        then if (parser_se_info.se_length - parser_se_info.se_cursor + 1)
	        > mrds_data_$max_id_len
	        /* check length */
	   then do;
	       i = index (substr (se_string, parser_se_info.se_cursor), "-");
	       if i = 0
	       then call scanner_error (mrds_error_$long_ident,
		       substr (se_string, parser_se_info.se_cursor));
	       else token_end = parser_se_info.se_cursor + i - 2;
	   end;
	   else token_end = parser_se_info.se_length;

        else if i > mrds_data_$max_id_len /* No EOI */
	   then do;
	       i = index (substr (se_string, parser_se_info.se_cursor, i),
		  "-");
	       if i = 0
	       then call scanner_error (mrds_error_$long_ident,
		       substr (se_string, parser_se_info.se_cursor));
	       else token_end = parser_se_info.se_cursor + i - 2;
	   end;
	   else token_end = parser_se_info.se_cursor + i - 1;

        token_string = "<symbol>";
        call load_stack;

        goto finish;

/* ^ ^= ^< ^> ^=< ^>< ... --> notop or relop */
token_type (5):


        if parser_se_info.se_cursor = parser_se_info.se_length
        then token_end = parser_se_info.se_cursor;	/* EOI: take the "^" */

        else do;
	  i = verify (substr (se_string, parser_se_info.se_cursor + 1, 2),
	       "=><");

	  if i = 0
	  then token_end = parser_se_info.se_cursor + 2;	/* found three char relop */
	  else token_end = parser_se_info.se_cursor + i - 1;
						/* found one or two char relop */
        end;
        token_string = "";
        call load_stack;

        goto finish;

/* = =< => --> relop */
token_type (6):


        if parser_se_info.se_cursor = parser_se_info.se_length
        then token_end = parser_se_info.se_cursor;	/* EOI: take the "=" */

        else do;
	  i = search (se_array (parser_se_info.se_cursor + 1), "><");
	  token_end = parser_se_info.se_cursor + i;
        end;

        token_string = "";
        call load_stack;


        goto finish;

/* < <= <> --> relop */
token_type (7):


        if parser_se_info.se_cursor = parser_se_info.se_length
        then token_end = parser_se_info.se_cursor;	/* EOI: take the "<" */

        else do;
	  i = search (se_array (parser_se_info.se_cursor + 1), "=>");
	  token_end = parser_se_info.se_cursor + i;
        end;

        token_string = "";
        call load_stack;


        goto finish;

/* > >= >< --> relop */
token_type (8):


        if parser_se_info.se_cursor = parser_se_info.se_length
        then token_end = parser_se_info.se_cursor;	/* EOI: take the ">" */
        else do;
	  i = search (se_array (parser_se_info.se_cursor + 1), "=<");
	  token_end = parser_se_info.se_cursor + i;
        end;

        token_string = "";
        call load_stack;


        goto finish;

/* | --> or or concat */
token_type (9):


        if parser_se_info.se_cursor >= parser_se_info.se_length
        then token_end = parser_se_info.se_cursor;	/* EOI; just take | */
        else do;
	  if se_array (parser_se_info.se_cursor + 1) = "|"
	  then token_end = parser_se_info.se_cursor + 1;
	  else token_end = parser_se_info.se_cursor;
        end;

        token_string = "";
        call load_stack;

        goto finish;

/* CR NL SP FF VT --> whitespace */
token_type (10):


        if parser_se_info.se_length = parser_se_info.se_cursor
        then i = 0;
        else i = verify (substr (se_string, parser_se_info.se_cursor + 1),
	        WHITE_SPACE);
						/* find end of white space */

        if i = 0
        then /* EOI encountered */
	   parser_se_info.se_cursor = parser_se_info.se_length + 1;
						/* flag for EOI trap at beginning */
        else parser_se_info.se_cursor = parser_se_info.se_cursor + i;
						/* get rid of white space, try again */

        goto start;

/* " --> string or bit string */
token_type (11):

        if parser_se_info.se_length = parser_se_info.se_cursor
        then call scanner_error (mrds_error_$inv_string,
	        substr (se_string, parser_se_info.token_start));

        done = "0"b;
        do while (^done);				/* find all double quotes */
	  i = index (substr (se_string, parser_se_info.se_cursor + 1), QUOTE)
	       ;
	  if i = 0				/* no end quote */
	  then call scanner_error (mrds_error_$inv_string,
		  substr (se_string, parser_se_info.token_start));

	  parser_se_info.se_cursor = parser_se_info.se_cursor + i + 1;

	  if parser_se_info.se_cursor > parser_se_info.se_length
	  then done = "1"b;
	  else if se_array (parser_se_info.se_cursor) ^= QUOTE
	       then done = "1"b;
        end;

        if parser_se_info.se_cursor <= parser_se_info.se_length
        then
	   if se_array (parser_se_info.se_cursor)
	        = B /* found a bit string */
	   then do;
	       if parser_se_info.se_cursor = parser_se_info.se_length
						/* end of string reached */
	       then token_end = parser_se_info.se_cursor;
	       else if search ("1234",
		       se_array (parser_se_info.se_cursor + 1)) = 0
		  then token_end = parser_se_info.se_cursor;
		  else token_end = parser_se_info.se_cursor + 1;
						/* take base also */

	       token_string = "<bit_string>";
	       call load_stack;
	   end;

	   else do;				/* just a string */
	       token_end = parser_se_info.se_cursor - 1;
	       token_string = "<string>";
	       call load_stack;
	   end;

        else do;					/* just a string */
	  token_end = parser_se_info.se_cursor - 1;
	  token_string = "<string>";
	  call load_stack;
        end;


        goto finish;

/* all other characters */
token_type (12):


        call scanner_error (mrds_error_$inv_token,
	   substr (se_string, parser_se_info.se_cursor, 1));
						/* cant start a token */

        goto finish;

/* :: or : */
token_type (13):

        if parser_se_info.se_cursor >= parser_se_info.se_length
        then goto token_type (12);
						/* EOI. just take : */

        if se_array (parser_se_info.se_cursor + 1) = ":"
        then do;
	  token_end = parser_se_info.se_cursor + 1;
	  token_string = "";
	  call load_stack;
        end;
        else goto token_type (12);			/* cant use a colon */

        goto finish;

/* simple one character tokens */
token_type (14):


        token_end = parser_se_info.se_cursor;
        token_string = "";
        call load_stack;


        goto finish;



finish:

        if scanner_debug
        then call ioa_ (" Token type: ^a; Token: '^a'",
	        token, substr (se_string, parser_se_info.token_start,
	        parser_lex_stack.token_length (stack_index)));
        return;

load_stack:
    proc;

/* procedure to load the lex stack, update the se info structure,
   and look up token ids
*/


        if token_string = "eoi" then do;		/* all done. */
	  parser_lex_stack.token_ptr (stack_index) = null;

	  parser_lex_stack.token_length (stack_index) = 0;

	  parser_lex_stack.token_start_pos (stack_index) =
	       parser_se_info.se_length;

	  token_id = EOI;
        end;
        else do;
	  parser_lex_stack.token_ptr (stack_index) = /* pointer to token */
	       addr (se_array (parser_se_info.token_start));

	  parser_lex_stack.token_length (stack_index) = /* length of token */
	       token_end - parser_se_info.token_start + 1;

	  parser_lex_stack.token_start_pos (stack_index) =
	       parser_se_info.token_start;

	  parser_se_info.se_cursor = token_end + 1;

	  if token_string = ""
	  then token =
		  substr (se_string, parser_se_info.token_start,
		  parser_lex_stack.token_length (stack_index));
	  else token = token_string;

	  call lookup_token (token, token_id);
	  if token_id = 0
	  then call scanner_error (mrds_error_$inv_token, token);
        end;

        parser_lex_stack.token_id (stack_index) = token_id;

        parser_se_info.token_length =
	   parser_lex_stack.token_length (stack_index);

    end load_stack;

lookup_token:
    proc (token, token_id);

/* routine to do binary search of keyword table. This procedure tries
   to do the lookup as fast possible as this is the most performance
   critical part of the scanner, and consequently the whole parser.

   This tries to take advantage of the of the speed of doing character
   comparisons in the AQ registers instead of using EIS instructions.
   Any token that is less than 9 characters can be manipulated this way.
   A token of length less than 9 can be identified in about 2/3 the time
   it takes to idenitify one of greater length.
*/

dcl     token		 char (24);
dcl     token_id		 fixed bin;

dcl     (low, middle, high)	 fixed bin;
dcl     temp_keyword	 char (24);
dcl     (temp_short_keyword, short_token)
			 char (8) aligned;
dcl     done		 bit (1) aligned;

dcl     1 short_keyword	 (hbound (keyword.name, 1)) based (sk_ptr),
						/* this masks over the keyword struct using an 8 char name field */
	2 name		 char (8) aligned,
	2 filler		 char (16);

        low = lbound (keyword.name, 1);
        high = hbound (keyword.name, 1);
        middle = divide (low + high, 2, 17, 0);
        sk_ptr = addr (keyword);
        done = "0"b;

        if index (token, " ") < 10 then do;		/* do it the fast way */
	  short_token = substr (token, 1, 8);
	  do while (^done);

	      if high < low
	      then done = "1"b;			/* something went wrong */
	      else do;

		temp_short_keyword = short_keyword.name (middle);
						/* copy it, so we only look it up once */

		if short_token ^= temp_short_keyword then do;

		    if short_token > temp_short_keyword
		    then low = middle + 1;
		    else high = middle - 1;

		    middle = divide (low + high, 2, 17, 0);

		end;
		else done = "1"b;
	      end;
	  end;

	  if short_token = temp_short_keyword
	  then token_id = keyword.value (middle);
	  else token_id = 0;

        end;

        else do;					/* do it the normal way */

	  do while (^done);
	      if high < low
	      then done = "1"b;			/* something went wrong */
	      else do;

		temp_keyword = keyword.name (middle);	/* copy it, so we only look it up once */

		if token ^= temp_keyword then do;

		    if token > temp_keyword
		    then low = middle + 1;
		    else high = middle - 1;

		    middle = divide (low + high, 2, 17, 0);

		end;
		else done = "1"b;

	      end;
	  end;

/* check to see if the search was successful, if not we're in trouble */

	  if token = temp_keyword
	  then token_id = keyword.value (middle);
	  else token_id = 0;
        end;

    end lookup_token;

scanner_error:
    proc (cd, token);

dcl     cd		 fixed bin (35);
dcl     token		 char (*);

        parser_se_info.error_code, code = cd;
        parser_se_info.loud = "1"b;
        parser_se_info.error_type = SE_TYPE;
        parser_se_info.error_msg = "'" || rtrim (token) || "'";
        call error (code);

    end scanner_error;

dcl     stack_index		 fixed bin parameter;

dcl     done		 aligned bit;
dcl     token_end		 fixed bin;		/* points to where token ends in se */
dcl     token_string	 char (24) aligned;		/* the token, if known. If its not null
						   we use this to look up the token id */
dcl     mrds_data_$max_id_len	 fixed bin (35) ext static;
dcl     mrds_error_$inv_string fixed bin (35) ext static;
dcl     mrds_error_$inv_token	 fixed bin (35) ext static;
dcl     mrds_error_$long_ident fixed bin (35) ext static;
dcl     token_id		 fixed bin;
dcl     token		 char (24);		/* size is size of keyword.name */
dcl     ioa_		 entry () options (variable);
dcl     ioa_$nnl		 entry () options (variable);
dcl     sk_ptr		 ptr internal static init (null);
						/* for binary search */
dcl     (state, class, id, i, type)
			 fixed bin;
dcl     (null, addr, rank)	 builtin;

dcl     QUOTE		 char internal static options (constant)
			 init ("""");
dcl     B			 char internal static options (constant)
			 init ("b");
dcl     DIGITS		 char (10) internal static
			 options (constant) init ("0123456789");

dcl     EOI		 fixed bin internal static
			 options (constant) init (0);
dcl     WHITE_SPACE		 char (6) based (addr (WHITE_SPACE_data));
dcl     WHITE_SPACE_data	 internal static options (constant)
			 dim (6) bit (9) unaligned
			 init ("011"b3, "012"b3, "013"b3, "014"b3,
			 "015"b3, "040"b3);		/* HT LF VT FF CR SP */

    end scanner;

%include mrds_se_info;
%page;
%include mrds_lex_stack;
%page;
%include mrds_dsl_tables;
%page;
%include mrds_se_options;
%page;
%include mrds_scanner_tables;
%page;
%include mrds_dsl_keywords;
%page;
%include mrds_dbcb;

dcl     area_ptr		 pointer parameter;
dcl     caller		 fixed binary (35) parameter;
dcl     se_ptr		 pointer parameter;
dcl     se_len		 fixed binary parameter;
dcl     arg_ptr		 pointer parameter;
dcl     desc_ptr		 pointer parameter;
dcl     num_args		 fixed binary parameter;
dcl     code		 fixed bin (35) parameter;
dcl     mu_print_error	 entry (ptr);
dcl     mrds_dsl_semantics$init
			 entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35),
			 ptr, ptr, ptr, fixed bin, bit (1) aligned);
dcl     mrds_dsl_semantics	 entry (ptr, fixed bin, fixed bin,
			 fixed bin (35));

dcl     1 parser_lex_stack	 (-3:100) aligned like lex_stack;

dcl     1 parser_se_info	 aligned like se_info;

dcl     lex_stack_ptr	 ptr;

dcl     se_info_ptr		 ptr;
dcl     1 lookahead		 (-3:100)
			 defined parser_lex_stack aligned like lex_stack;
dcl     abs		 builtin;
dcl     addr		 builtin;
dcl     char		 builtin;
dcl     current_flag	 bit (1) aligned;
dcl     current_state	 fixed bin;		/* number of current state */
dcl     current_table	 fixed bin;		/* number of current table */
dcl     dbi_pic		 picture "999";
dcl     1 db_data		 unaligned,
	2 flag		 char (1),		/* * means stacked */
	2 state		 picture "zzz9",
	2 top		 picture "zzz9",
	2 filler		 char (2),
	2 type		 char (6),
	2 data		 char (100);
dcl     db_item		 char (117) defined (db_data);
dcl     db_look		 pic "99" defined (db_data.type) pos (3);
dcl     debug		 bit (1) internal static init ("0"b);
dcl     db_separator	 char (1);
dcl     divide		 builtin;
dcl     fixed		 builtin;
dcl     hbound		 builtin;
dcl     i			 fixed bin;
dcl     index		 builtin;
dcl     ioa_$nnl		 entry options (variable);
						/* Parse stack underflow or local recovery encountered
						   impossible conditions.  Both caused by bad DPDA. */
dcl     mrds_error_$sell_syntax
			 fixed bin (35) ext;
dcl     mrds_error_$parser_logic_error
			 fixed bin (35) external static;
						/* Parse, lexical, or lookahead stack overflow. */
dcl     mrds_error_$parser_stack_overflow
			 fixed bin (35) external static;
						/* Recovery failed. */
dcl     mrds_error_$parser_unrecognized_state
			 fixed bin (35) external static;
dcl     mrds_error_$bad_attr	 fixed bin (35) ext static;
dcl     mrds_error_$bad_var	 fixed bin (35) ext static;
dcl     lb		 fixed bin;
dcl     lbound		 builtin;
dcl     lex_stack_top	 fixed bin defined parse_stack_top;
						/* location of the top of the lexical stack */
dcl     lex_token		 char (parser_lex_stack
			 .token_length (lex_stack_top))
			 based (parser_lex_stack
			 .token_ptr (lex_stack_top));
dcl     lookahead_count	 fixed bin;		/* number of terminals in lookahead stack */
dcl     lookahead_get	 fixed bin;		/* location in lookahead stack to get next token */
dcl     lookahead_need	 fixed bin;		/* number of lookahead tokens needed */
dcl     lookahead_put	 fixed bin;		/* location in the lookahead stack to put next token */
dcl     lookahead_use	 fixed bin;		/* location in the lookahead stack to test with */
dcl     mu_define_area$define_temp_dir_area
			 entry (ptr, fixed bin (35), fixed bin (18),
			 char (11), bit (1) aligned,
			 bit (1) aligned, bit (1) aligned,
			 bit (1) aligned, fixed bin (35));
dcl     (m, n)		 fixed bin;
dcl     next_state		 fixed bin;		/* number of next state */
dcl     null		 builtin;
dcl     parse_stack		 (100) fixed bin aligned;	/* parse stack */
dcl     parse_stack_top	 fixed bin;		/* location of the top of the parse stack */
dcl     production_number	 fixed bin;		/* APPLY production number */
dcl     scanner_debug	 internal static bit init ("0"b);
dcl     se_string		 char (parser_se_info.se_length)
			 based (parser_se_info.se_ptr);
						/* string view of se */
dcl     se_array		 (parser_se_info.se_length) char
			 based (parser_se_info.se_ptr);
						/* array view of se */
dcl     sys_info$max_seg_size	 fixed bin (35) ext static;
dcl     t			 fixed bin;
dcl     test_state		 fixed bin;		/* top state from parse stack during look back lookups */
dcl     test_token		 fixed bin defined test_state;/* encoding of current token */
dcl     ub		 fixed bin;
dcl     unspec		 builtin;
dcl     ALPHA_NUM		 char (63) internal static options (constant)
			 init (
			 "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz"
			 );

    end mrds_dsl_parser;
