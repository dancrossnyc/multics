/****^  ********************************************
        *                                          *
        * Copyright, (C) Honeywell Bull Inc., 1988 *
        *                                          *
        ******************************************** */



/****^  HISTORY COMMENTS:
  1) change(87-01-22,Hergert), approve(88-07-11,MCR7903),
     audit(88-07-11,Dupuis), install(88-08-01,MR12.2-1073):
     Written.
  2) change(88-06-27,Hergert), approve(88-07-11,MCR7903),
     audit(88-07-11,Dupuis), install(88-08-01,MR12.2-1073):
     Fixed bugs and inadequacies from original design required to pass audit
     and regression tests.
                                                   END HISTORY COMMENTS */


mrds_dsl_semantics:
    proc (psi_ptr, ls_top, prod_no, code);

/*	SEMANTICS SEGMENT mrds_dsl_semantics.pl1
   Generated by: Hergert.SysMaint.a using LALR 7.3a of Thursday, January 24, 1985
   Generated at: Ford ECC Multics C
   Generated on: 11/26/85  1644.7 est Tue
   Generated from: >udd>MRDS>Hergert>p>d>mrds_dsl.lalr
*/


/* -controls
   -count
   -long_source
   -source
   -symbols
   -terminals
   -production_names
   -table mrds_dsl_tables
   -terminals_list
   -variables_list
   -production
   -semantics mrds_dsl_semantics
   -synonyms '<=  ='<      ^>
   =    ^'<>     ^>'<
   ^=   '<>      >'<
   >    ^'<=     ^='<
   >=   =>       ^'<
   '<    ^>=      ^=>
   .V. .v.
   .X. .x.
   -range -from
   &   -and
   '|  -or
   ^   -not
   -order
   &
   (
   )
   *
   +
   ,
   -
   -all_of
   -any_of
   -ascending
   -current
   -descending
   -differ
   -dup
   -group_by
   -having
   -inter
   -is_between
   -is_in
   -is_like
   -is_not_between
   -is_not_in
   -is_not_like
   -is_not_null
   -is_null
   -no_optimize
   -no_ot
   -order_by
   -print_search_order
   -pso
   -range
   -select
   -union
   -where
   .
   .V.
   .X.
   /
   ::
   '<
   '<=
   <bit_string>
   <integer>
   <string>
   <symbol>
   =
   >
   >=
   [
   ]
   ^
   ^=
   '|
   '|'|
   (* COMMENTS

   To add a new production to the language, just insert the production in
   the appropriate place in this description of the grammar. Also create
   a new "prod (%%%%N): return;" sequence in the correct place, where N
   is the relative production number in the rule. Then use the command
   "lalr mrds_dsl". New tables will be created, a new mrds_dsl_semantics.pl1
   and a few other things. To test the new grammar use the command
   "lalrp mrds_dsl -trace". This invokes an interpretor that will wait
   for terminal input. Enter a sample grammar and end it with the string "EOI".
   After the grammar is proven correct the old mrds_dsl_semantics.pl1 will
   have to be modified to reflect the new grammar. Usually some of the
   productions have to be renumbered and code must be installed to handle the
   new ones.

   If a new kewyword was added then a new keyword table must also be created.
   This is done with the kwsl command: "kwsl mrds_dsl". It will create a
   new mrds_dsl.incl.pl1. This must renamed to mrds_dsl_keywords.incl.pl1
   and modified by changing the size of keyword.name and adding the new level
   major_keyword according to the old mrds_dsl_keywords.incl.pl1
   Also the declaration and initialization of op_array in 
   mrds_dsl_where_clause_ needs to be changed to reflect the new token ids
   of the relational operators. I know this stinks, but...

   Due to a bug in the LALR compiler the production
   <attrubute_spec> ::= <relation>.<attribute> has to be represented as
   <attribute_spec> ::= <symbol>.<symbol> which is syntactically
   equivalent.

   -pso and -no_ot have been removed. Since they currently can
   exist anyplace in a selection expression, to maintain
   upward compatibility, their parsing was moved to the scanner.

   -another and -compiled have been removed from <control_order>.
   They will be handled outside of the parser.

   <control_order> was renamed <current_clause>
   *)
   %page;

   (* SELECTION EXPRESSION *)
   -parse */

        dbcb_ptr = static_data.dbcb_ptr;
        select_area_ptr = static_data.select_area_ptr;
        lex_stack_ptr = static_data.lex_stack_ptr;
        code = 0;

        if debug
        then call ioa_ (
	        "Semantics: production ^d, Lex stack token '^a', stack top ^d",
	        prod_no, lex_token, ls_top);

        goto prod (prod_no);




/* <selection_expression> ::=
   <current_clause>   |
   <query> -order_by <order_spec_list> |
   <query> ! */

prod (1):
        call mrds_dsl_select_clause_$finish (dbcb_ptr, static_data.range_ptr,
	   static_data.select_list_ptr, dbcb.ti_ptr, caller,
	   area_ptr, argp_ptr, descp_ptr, num_args, cur_sw, code);
        if code ^= 0 then call error (code, ^LOUD, 0, "", "");
        goto exit;

prod (2):
        call error (mrds_error_$unimplemented_syntax, LOUD, 1, SE_TYPE, "");
        goto exit;

prod (3):

/* If we are compiling, pred_leaf_list_ptr will point to a structure containg
   pointers to the predicate leaves generated in where_clause that were
   specified as .x. These have to be filled in at run time. trl_ptr will
   point to a structure containing info on the temp rels used in a cse.
   Since we dont know the se_index at this point we pass the pointer
   back to compile in the cse struc and let him worry about it.
*/

        if caller = mrds_data_$caller_compile then do;
	  dbcb.compiled_se_info_ptr -> compiled_se_info.temp_x_leaf_ptr =
	       static_data.x_pred_leaf_ptr;
	  dbcb.compiled_se_info_ptr
	       -> compiled_se_info.temp_temp_rel_list_ptr = static_data.trl_ptr;
        end;

        goto exit;



/* <current_clause> ::=
   <current_header> |
   <current_header> <select_list> ! */

prod (4):
        goto exit;

prod (5):
        goto exit;




/* <current_header> ::= -current ! */

prod (6):
        if dbcb.current_ptr ^= null then do;
	  select_list_ptr, static_data.select_list_ptr = dbcb.current_ptr;
	  string (select_list.var_exists) = "0"b;
	  select_list.num_vars, select_list.num_items = 0;
        end;
        else call init_select_list;

        if caller = mrds_data_$caller_compile
        then call error (mrds_error_$inval_comp_expr, LOUD, 0, SE_TYPE,
	        "A selection expression consisting of -current cannot be compiled."
	        );
        if dbcb.range_ptr = null
        then /* no existing s.e. */
	   call error (mrds_error_$no_prior_se, LOUD, 0, SE_TYPE, "");

        if dbcb.ss_ptr ^= null ()
        then call error (mrds_error_$curr_not_alld, LOUD, 0, SE_TYPE, "");

        dbcb.current_flag = "1"b;

        goto exit;




/* <query> ::=
   <query_expression> |
   <query> <set_op> <query_expression>   ! */

prod (7):
        goto exit;

prod (8):

        ss_ptr = dbcb.ss_ptr;
        nitems_init = 2 * mrds_data_$max_sets;

        if se_pending then do;
	  if select_sets.nitems + 1 >= nitems_init	/* make sure there is roomm for the se and its required oper */
	  then
	       call error (mrds_error_$set_ovfl, LOUD, 0, SE_TYPE, "");

	  select_sets.nitems = select_sets.nitems + 1;
	  select_sets.items.oper_flag (select_sets.nitems) = "0"b;
						/* not an operator */
	  select_sets.items.range_ptr (select_sets.nitems) = dbcb.range_ptr;
	  select_sets.items.select_ptr (select_sets.nitems) =
	       dbcb.select_ptr;
	  select_sets.items.ti_ptr (select_sets.nitems) = dbcb.ti_ptr;
	  select_sets.items.so_ptr (select_sets.nitems) = dbcb.so_ptr;

	  se_pending = "0"b;
        end;

        select_sets.nitems = select_sets.nitems + 1;	/* incr. item count */

        select_sets.items.oper_flag (select_sets.nitems) = "1"b;
						/* build oper. item in structure */
        select_sets.items.op_code (select_sets.nitems) = op_stack (op_top);
        op_top = op_top - 1;

        goto exit;




/* <set_op> ::=
   -union |
   -inter |
   -differ   ! */

prod (9):

        call process_set_op (UNION);

        goto exit;

prod (10):

        call process_set_op (INTERSECTION);

        goto exit;

prod (11):

        call process_set_op (DIFFERENCE);

        goto exit;




/* <query_expression> ::=
   <query_clause> |
   ( <query> ) ! */

prod (12):
        dbcb.range_ptr, range_ptr = static_data.range_ptr;
        dbcb.select_ptr = static_data.select_list_ptr;
        dbcb.print_search_order = dbcb.se_info_ptr -> se_info.pso_seen;
        dbcb.no_optimize = dbcb.se_info_ptr -> se_info.no_ot_seen;
        option_list_ptr = static_data.option_list_ptr;

        if option_list.force then do;			/* setup the option specified in the smo command */
	  dbcb.print_search_order = option_list.pso;
	  dbcb.no_optimize = ^option_list.ot;
        end;
        else do;
	  if option_list.pso then dbcb.print_search_order = "1"b;
	  if ^option_list.ot then dbcb.no_optimize = "1"b;
        end;

        call get_relation_statistics (code);
        if code ^= 0 then call error (code, ^LOUD, 0, "", "");

        call mrds_dsl_optimize (dbcb_ptr, pred_tree_ptr, dbcb.so_ptr, code);
        if code ^= 0 then call error (code, ^LOUD, 0, "", "");

        se_pending = "1"b;

        goto exit;

prod (13):
        goto exit;



/* <query_clause> ::=
   <required_clause> |
   <required_clause> <optional_clauses> ! */

prod (14):
        goto exit;

prod (15):
        goto exit;




/* <required_clause> ::=
   <range_clause> <select_clause> |
   <select_clause> <range_clause> ! */

prod (16):
        goto exit;

prod (17):
        goto exit;




/* <optional_clauses> ::=
   <where_clause> |
   <group_clause> |
   <where_clause> <group_clause> ! */

prod (18):
        goto exit;

prod (19):
        call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");
        goto exit;

prod (20):
        call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");
        goto exit;




/* <group_clause> ::=
   -group_by <simple_expr> |
   -group_by <simple_expr> -having <qualifier> ! */

prod (21):
        goto exit;

prod (22):
        goto exit;




/* <order_spec_list> ::=
   <simple_expr> |
   <simple_expr> <direction> |
   <order_spec_list> , <simple_expr> |
   <order_spec_list> , <simple_expr> <direction> ! */

prod (23):
        goto exit;

prod (24):
        goto exit;

prod (25):
        goto exit;

prod (26):
        goto exit;




/* <direction> ::=
   -ascending |
   -descending ! */

prod (27):
        goto exit;

prod (28):
        goto exit;

%page;
/*
   (* RANGE CLAUSE *)




   <range_clause> ::= -range <range_def_list>   ! */

prod (29):
        goto exit;


/* <range_def_list> ::=
		<sql_range_def_list> |
		<dsl_range_def_list> ! */

prod (30):
        return;

prod (31):
        return;


/* <sql_range_def_list> ::=
		<sql_range> |
		<sql_range_def_list> , <sql_range> ! */

prod (32):
        return;

prod (33):
        return;


/* <sql_range> ::=
		<sql_range_item> |
		<sql_range_item> (+) ! */

prod (34):
        return;

prod (35):
        return;


/* <sql_range_item> ::=
		<relation_id> |
		<relation_id> <relation_label> ! */

prod (36):
        return;

prod (37):
        return;


/* <dsl_range_def_list> ::=
		<dsl_range_item> |
		<dsl_range_def_list> <dsl_range_item> ! */

prod (38):
        return;

prod (39):
        return;


/* <dsl_range_item> ::= ( <relation_label> <relation_id> ) ! */

prod (40):
        range_ptr = static_data.range_ptr;
        string (range.tup_var (range.num_vars).needed_bits) = "0"b;
        range.tup_var (range.num_vars).copy_for_current,
	   range.tup_var (range.num_vars).copied_for_current = "0"b;

        range.tup_var.name (range.num_vars) = get_stacked_token (ls_top - 2);
						/* Grab the label */

        do i = 1 to range.num_vars - 1;
	  if range.name (range.num_vars) = range.name (i)
	  then call error (mrds_error_$mult_def_var, LOUD, 2, RC_TYPE,
		  "The relation label '"
		  || get_stacked_token (ls_top - 2)
		  || "' has already been used to identify a relation.");
        end;

        goto exit;




/* <relation_id> ::=
   <relation> |
   <v_arg_substitution> |
   <db_label>.<relation> ! */

prod (41):
        range_ptr = static_data.range_ptr;
        if range.num_vars >= mrds_data_$max_tup_var
        then call error (mrds_error_$max_tup_var, LOUD, 0, RC_TYPE,
	        "The maximum number is "
	        || ltrim (char (mrds_data_$max_tup_var)));
        range.num_vars = range.num_vars + 1;		/* increment count */
        rmra_ptr = static_data.rdbi_ptr -> rm_db_info.ra_ptr;	/* point to perm rel array */

        if length (lex_token) < mrds_data_$max_id_len
        then
	   i = index (string (rm_rel_array.name), "!" || lex_token || " ");
        else i = index (string (rm_rel_array.name), "!" || lex_token);
        if i = 0
        then call error (mrds_error_$undef_rel, LOUD, 0, RC_TYPE,
	        "The relation '" || lex_token
	        || "' is unknown in this opening.");
						/* if not found */

        i = divide ((i - 1), 33, 17, 0) + 1;		/* convert from char to array index */

        range.tup_var.used (range.num_vars) = "0"b;	/* initially assume variable not used  */
        range.tup_var.whole_tuple_selected (range.num_vars) = "0"b;
						/* initially assume variable not selected  */
        range.tup_var.temp_rel (range.num_vars) = "0"b;	/* was found, init. tup var info */
        range.tup_var.rel_index (range.num_vars) = i;
        range.tup_var.ri_ptr (range.num_vars) =
	   rm_rel_array.rel_data.ri_ptr (i);

        goto exit;


prod (42):
        range_ptr = static_data.range_ptr;
        if range.num_vars >= mrds_data_$max_tup_var
        then call error (mrds_error_$max_tup_var, LOUD, 0, RC_TYPE,
	        "The maximum number is "
	        || ltrim (char (mrds_data_$max_tup_var)));
        range.num_vars = range.num_vars + 1;		/* increment count */
        if descriptor_ptr -> bit36 = FB35
        then /* if value is fixed bin, no need to convert */
	   temp_rel_index = arg_ptr -> fixed_bin_35;

        else do;					/* no such luck, must convert */

	  if ^mu_valid_data_type$valid_scalar_data_type (descriptor_ptr
	       -> bit36)
	  then
	       call error (mrds_error_$bad_temp_rel_val, ^LOUD, 0, "",
		  "");

	  call mu_convert$convert_data (arg_ptr, descriptor_ptr,
	       addr (temp_rel_index), addr (FB35), code);
	  if code ^= 0 then goto exit;

        end;					/* converting temp. rel. value */

        rmra_ptr = static_data.rdbi_ptr -> rm_db_info.tra_ptr;
        if temp_rel_index < 1 | rm_rel_array.num_rels < temp_rel_index
        then /*  if correspond. temp. rel. not yet defined */
	   call error (mrds_error_$undef_temp_rel, ^LOUD, 0, "",
	        "");

        if rm_rel_array.rel_data.ri_ptr (temp_rel_index) = null
        then
	   call error (mrds_error_$undef_temp_rel, ^LOUD, 0, "",
	        "");

        range.tup_var.used (range.num_vars) = "0"b;	/* initially assume variable not used  */
        range.tup_var.whole_tuple_selected (range.num_vars) = "0"b;
						/* initially assume variable not selected  */
        range.tup_var.temp_rel (range.num_vars) = "1"b;	/* init tup_var info */
        range.tup_var.rel_index (range.num_vars) = temp_rel_index;
        range.tup_var.ri_ptr (range.num_vars) =
	   rm_rel_array.rel_data.ri_ptr (temp_rel_index);

        if caller = mrds_data_$caller_compile then do;
	  if static_data.trl_ptr = null then do;
	      allocate temp_rel_list in (select_area) set (static_data.trl_ptr);
	      static_data.trl_ptr -> temp_rel_list.number_of_temp_rels = 0;
	  end;

	  trl_ptr = static_data.trl_ptr;
	  temp_rel_list.number_of_temp_rels =
	       temp_rel_list.number_of_temp_rels + 1;	/* save the name of the temp rel for CSE */
	  temp_rel_list.name (number_of_temp_rels) =
	       rm_rel_array.name.submodel (temp_rel_index);
	  temp_rel_list.index (number_of_temp_rels) = temp_rel_index;
        end;

        goto exit;

prod (43):
        call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");

        goto exit;


%page;
/*
   (* SELECT CLAUSE *)




   <select_clause> ::=
   <select_header> * |
   <select_header> <select_list> ! */

prod (44):
        call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");
        goto exit;

prod (45):
        call mrds_dsl_select_clause_$finish (dbcb_ptr, static_data.range_ptr,
	   static_data.select_list_ptr, dbcb.ti_ptr, caller,
	   area_ptr, argp_ptr, descp_ptr, num_args, cur_sw, code);
        if code ^= 0 then call error (code, ^LOUD, 0, "", "");
        goto exit;




/* <select_header> ::=
   -select  |
   -select -distinct
   -select -dup  ! */

prod (46):
        call init_select_list;
        goto exit;

prod (47):
        call init_select_list;
        goto exit;

prod (48):

        dbcb.val_mod, dbcb.val_del, dbcb.val_dtr = "0"b;

        if dbcb.ss_ptr = null
        then dbcb.dup_retain = "1"b;			/* set correct dup flag */
        else dbcb.ss_ptr -> select_sets.dup_retain = "1"b;

        call init_select_list;

        goto exit;




/* <select_list> ::=
   <select_item> |
   <select_list> <select_item> ! */

prod (49):
        goto exit;

prod (50):
        goto exit;




/* <select_item> ::=
   <select_id> |
   <select_id> :: <alias> ! */

prod (51):
        goto exit;

prod (52):
        call error (mrds_error_$unimplemented_syntax, LOUD, 1, SE_TYPE, "");
        goto exit;



/* <select_id> ::=
   <attribute> |
   ( <simple_expr> ) |
   ( <simple_expr> ) * |
   <relation> . <attribute> |
   <relation> . <attribute> * ! */

prod (53):
						/* this means that a whole relation is to be returned */
        call get_attribute_info (^ATTRIBUTE, ^KEY, static_data.rel_index, attr_index);

        call mrds_dsl_select_clause_$all_attributes (dbcb_ptr, static_data.range_ptr,
	   static_data.select_list_ptr, rmri_ptr, static_data.rel_index, cur_sw,
	   caller,
	   code);
        if code ^= 0 then call error (code, ^LOUD, 0, "", "");

        goto exit;

prod (54):
        call error (mrds_error_$unimplemented_syntax, LOUD, 2, SE_TYPE, "");
        goto exit;

prod (55):
        call error (mrds_error_$unimplemented_syntax, LOUD, 3, SE_TYPE, "");
        goto exit;

prod (56):
        call get_attribute_info (ATTRIBUTE, ^KEY, static_data.rel_index, attr_index);

        call mrds_dsl_select_clause_$one_attribute (dbcb_ptr, static_data.range_ptr,
	   static_data.select_list_ptr, rmri_ptr, attr_index, static_data.rel_index, ^KEY, cur_sw,
	   caller, code);
        if code ^= 0 then call error (code, ^LOUD, 0, "", "");

        goto exit;


prod (57):
        call get_attribute_info (ATTRIBUTE, KEY, static_data.rel_index, attr_index);

        call mrds_dsl_select_clause_$one_attribute (dbcb_ptr, static_data.range_ptr,
	   static_data.select_list_ptr, rmri_ptr, attr_index, static_data.rel_index, KEY, cur_sw,
	   caller, code);
        if code ^= 0 then call error (code, ^LOUD, 0, "", "");

        goto exit;


%page;
/*
   (*  WHERE CLAUSE *)




   <where_clause> ::=
   -where <qualifier> ! */

prod (58):
        call mrds_dsl_where_clause_$finish (psi_ptr,pred_tree_ptr);

        goto exit;




/* <qualifier> ::=
   <qualifier_term> |
   <qualifier> <or_op> <qualifier_term>  ! */

prod (59):
        goto exit;

prod (60):
        call mrds_dsl_where_clause_$build_node (psi_ptr,dbcb_ptr, select_area_ptr,
	   lex_stack.token_id (ls_top - 1),
	   LOGICAL_NODE, ^NOT_NODE, code);
        if code ^= 0 then call error (code, ^LOUD, 0, "", "");

        goto exit;




/* <qualifier_term> ::=
   <qualifier_factor> |
   <qualifier_term> <and_op> <qualifier_factor> ! */

prod (61):
        goto exit;

prod (62):
        call mrds_dsl_where_clause_$build_node (psi_ptr,dbcb_ptr, select_area_ptr,
	   lex_stack.token_id (ls_top - 1), LOGICAL_NODE, ^NOT_NODE, code);
        if code ^= 0 then call error (code, ^LOUD, 0, "", "");

        goto exit;




/* <qualifier_factor> ::=
   <predicate> |
   <not_op> <predicate> ! */

prod (63):
        goto exit;

prod (64):
        call mrds_dsl_where_clause_$build_node (psi_ptr,dbcb_ptr, select_area_ptr,
	   lex_stack.token_id (ls_top - 1),
	   LOGICAL_NODE, NOT_NODE, code);
        if code ^= 0 then call error (code, ^LOUD, 0, "", "");

        goto exit;




/* <predicate> ::=
   <term> |
   (<qualifier>) ! */

prod (65):
        goto exit;

prod (66):
        goto exit;




/* <term> ::=
   <expr_or_query> <comp_op> <expr_or_query> |
   <expr_or_query> <is_in> ( <query_literal> ) |
   <like_item> <like> <regular_expr> |
   <attribute_spec> <is_null> |
   <expr> <between> <expr> <and_op> <expr> ! */

prod (67):
        call mrds_dsl_where_clause_$build_node (psi_ptr,dbcb_ptr, select_area_ptr,
	   lex_stack.token_id (ls_top - 1),
	   ^LOGICAL_NODE, ^NOT_NODE, code);
        if code ^= 0 then call error (code, ^LOUD, 0, "", "");

        goto exit;

prod (68):
        goto exit;

prod (69):
        goto exit;

prod (70):
        goto exit;

prod (71):
        goto exit;




/* <expr_or_query> ::=
   ( <query_literal> ) |
   [ <old_func_or_expr> ] |
   <expr> |
   <x_arg_substitution> ! */

prod (72):
        goto exit;

prod (73):
        efd_ptr = expr_efd_ptrs (current_expr_level);
        call mrds_dsl_expr_$finish (psi_ptr,efd_ptr, select_area_ptr,
	   current_expr_level);

        if exp_fun_data.var_index <= 0 then do;		/* if constant expression */
	  if exp_fun_data.ef_ptr ^= null ()
	  then do;
	      call mrds_dsl_eval_expr (area_ptr, exp_fun_data.ef_ptr,
		 null, null, code);			/* evaluate const. expr */
	      if code ^= 0
	      then call error (code, LOUD, 0, WCE_TYPE,
		      "Error occured while evaluating expression.");
	  end;
	  call mrds_dsl_where_clause_$build_literal (psi_ptr,dbcb_ptr,
	       select_area_ptr, exp_fun_data.assn_ptr,
	       addr (exp_fun_data.descriptor), static_data.x_pred_leaf_ptr, ^X_SW,
	       code);
	  if code ^= 0 then call error (code, ^LOUD, 0, "", "");
        end;

        else do;
	  call mrds_dsl_where_clause_$build_expr (psi_ptr,efd_ptr, select_area_ptr,
	       code);
	  if code ^= 0 then call error (code, ^LOUD, 0, "", "");
        end;

        current_expr_level = current_expr_level - 1;

        goto exit;

prod (74):
        goto exit;

prod (75):
        call mrds_dsl_where_clause_$build_literal (psi_ptr,dbcb_ptr, select_area_ptr,
	   null, null, static_data.x_pred_leaf_ptr, X_SW, code);
        if code ^= 0 then call error (code, ^LOUD, 0, "", "");
        goto exit;




/* <query_literal> ::=
   <query> |
   <constant_list> ! */

prod (76):
        goto exit;

prod (77):
        goto exit;




/* <old_func_or_expr> ::=
   <old_function> |
   <old_expr> |
   ( <old_expr> ) ! */

prod (78):
        efd_ptr = func_efd_ptrs (current_func_level);

        if exp_fun_data.var_index <= 0 then do;		/* function is a constant */
	  call mrds_dsl_eval_func (area_ptr, exp_fun_data.ef_ptr, null, null,
	       code);
	  if code ^= 0
	  then
	       call error (code, LOUD, 0, WCF_TYPE,
		  "Error occured while evaluating function.");
	  if addr (exp_fun_data.descriptor) -> descriptor.type > 18
	       & addr (exp_fun_data.descriptor) -> descriptor.type < 23
	  then char_sw = CHAR_SW;
	  else char_sw = ^CHAR_SW;
	  call mrds_dsl_expr_$build_literal (psi_ptr,dbcb_ptr, exp_fun_data.assn_ptr,
	       addr (exp_fun_data.descriptor), char_sw, current_expr_level,
	       code);
	  if code ^= 0 then call error (code, ^LOUD, 0, "", "");
        end;

        else do;
	  if expr_efd_ptrs (current_expr_level) -> exp_fun_data.var_index = 0
	  then
	       expr_efd_ptrs (current_expr_level) -> exp_fun_data.var_index =
		  exp_fun_data.var_index;
	  else if expr_efd_ptrs (current_expr_level)
		  -> exp_fun_data.var_index ^= exp_fun_data.var_index
	       then call error (mrds_error_$mult_expr_vars, LOUD, 0,
		       WCE_TYPE, "");		/* else must match established var. */

	  call mrds_dsl_expr_$build_function (psi_ptr,dbcb_ptr, efd_ptr,
	       current_expr_level, code);
	  if code ^= 0 then call error (code, ^LOUD, 0, "", "");
        end;

        current_func_level = current_func_level - 1;

        goto exit;


prod (79):
        goto exit;

prod (80):
        goto exit;




/* <like_item> ::=
   <attribute_spec> |
   <function> ! */

prod (81):
        goto exit;

prod (82):
        goto exit;




/* <is_in> ::=
   -is_in |
   -is_not_in ! */

prod (83):
        call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");
        goto exit;

prod (84):
        call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");
        goto exit;




/* <like> ::=
   -is_like |
   -is_not_like ! */

prod (85):
        call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");
        goto exit;

prod (86):
        call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");
        goto exit;




/* <is_null> ::=
   -is_null |
   -is_not_null ! */

prod (87):
        call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");
        goto exit;

prod (88):
        call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");
        goto exit;




/* <between> ::=
   -is_between |
   -is_not_between ! */

prod (89):
        call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");
        goto exit;

prod (90):
        call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");
        goto exit;




/* <comp_op> ::=
   <rel_op> |
   <rel_op> -any_of | (* ^= -any_of is always true *)
   <rel_op> -all_of ! (* = -all_of is always false *) */

prod (91):
        goto exit;

prod (92):
        call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");
        goto exit;

prod (93):
        call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");
        goto exit;




/* <rel_op> ::=
   =  |  ^=  |  >   |  >=  |  '<  |  '<= ! */

prod (94):
        goto exit;

prod (95):
        goto exit;

prod (96):
        goto exit;

prod (97):
        goto exit;

prod (98):
        goto exit;

prod (99):
        goto exit;


/* <regular_expr> ::=
		<expr> |
		<x_arg_substitution> ! */

prod (100):
        return;

prod (101):
        return;
%page;
/*
   (*   EXPRESSIONS   *)


   (* SIMPLE EXPR  I.E. no arg substitution *)




   <simple_expr> ::=
   <simple_arith_term> |
   <simple_expr> <add_op> <simple_arith_term> ! */

prod (102):
        goto exit;

prod (103):
        goto exit;




/* <simple_arith_term> ::=
   <simple_arith_factor> |
   <simple_arith_term> <mult_op> <simple_arith_factor> ! */

prod (104):
        goto exit;

prod (105):
        goto exit;




/* <simple_arith_factor> ::=
   <simple_primary> |
   <simple_arith_factor> '|'| <simple_primary> |
   <add_op> <simple_primary> ! */

prod (106):
        goto exit;

prod (107):
        call error (mrds_error_$unimplemented_syntax, LOUD, 1, SE_TYPE, "");
        goto exit;

prod (108):
        goto exit;




/* <simple_primary> ::=
   <attribute_spec> |
   <function> |
   (<simple_expr>) |
   <constant> ! */

prod (109):
        goto exit;

prod (110):
        goto exit;

prod (111):
        goto exit;

prod (112):
        goto exit;

%page;
/*
   (* STANDARD EXPR  I.E. arg substitution *)




   <expr> ::=
   <arith_term> |
   <expr> <add_op> <arith_term> ! */

prod (113):
        goto exit;

prod (114):
        goto exit;




/* <arith_term> ::=
   <arith_factor> |
   <arith_term> <mult_op> <arith_factor> ! */

prod (115):
        goto exit;

prod (116):
        goto exit;




/* <arith_factor> ::=
   <primary> |
   <arith_factor> '|'| <primary> |
   <add_op> <primary> ! */

prod (117):
        if primary_type = "ATTR" then do;
	  call mrds_dsl_where_clause_$build_attribute (psi_ptr,dbcb_ptr,
	       select_area_ptr,
	       static_data.rel_index,
	       static_data.rmri_ptr -> rm_rel_info.attr_ptrs (attr_index), code);
	  if code ^= 0 then call error (code, ^LOUD, 0, "", "");
        end;

        else if primary_type = "CONS" then do;
	       call mrds_dsl_where_clause_$build_literal (psi_ptr,dbcb_ptr,
		  select_area_ptr,
		  constant_ptr, descriptor_copy_ptr, static_data.x_pred_leaf_ptr,
		  ^X_SW, code)
		  ;
	       if code ^= 0 then call error (code, ^LOUD, 0, "", "");
	   end;
	   else if primary_type = "VARG" then do;
		  call mrds_dsl_where_clause_$build_literal (psi_ptr,dbcb_ptr,
		       select_area_ptr,
		       arg_ptr, descriptor_ptr, static_data.x_pred_leaf_ptr,
		       ^X_SW, code);
		  if code ^= 0 then call error (code, ^LOUD, 0, "", "");
	        end;

        goto exit;

prod (118):
        call error (mrds_error_$unimplemented_syntax, LOUD, 1, SE_TYPE, "");
        goto exit;

prod (119):
        if primary_type = "CONS" then do;
	  char_descriptor.length =
	       lex_stack.token_length (ls_top)
	       + lex_stack.token_start_pos (ls_top)
	       - lex_stack.token_start_pos (ls_top - 1);
	  constant_ptr = lex_stack.token_ptr (ls_top - 1);
	  allocate descriptor_copy in (literal_area);
	  descriptor_copy = addr (char_descriptor) -> descriptor_copy;
	  call mrds_dsl_where_clause_$build_literal (psi_ptr,dbcb_ptr,
	       select_area_ptr,
	       constant_ptr, descriptor_copy_ptr, static_data.x_pred_leaf_ptr, ^X_SW,
	       code)
	       ;
	  if code ^= 0 then call error (code, ^LOUD, 0, "", "");
        end;
        else call error (mrds_error_$unimplemented_syntax, LOUD, 1, SE_TYPE,
	        "");
        goto exit;




/* <primary> ::=
   <attribute_spec> |
   <function> |
   (<expr>) |
   <constant> |
   <v_arg_substitution>   ! */

prod (120):
						/* Say this attribute is needed, although it may not be */
        static_data.range_ptr -> range.tup_var (static_data.rel_index).needed_bits
	   .
	   attr (static_data.rmri_ptr -> rm_rel_info.attr_ptrs (attr_index)
	   -> rm_attr_info.defn_order) = "1"b;

        primary_type = "ATTR";

        goto exit;

prod (121):
        primary_type = "FUNC";
        goto exit;

prod (122):
        primary_type = "EXPR";
        goto exit;

prod (123):					/* constant */
        primary_type = "CONS";

        goto exit;

prod (124):					/* .v. */
        primary_type = "VARG";

        goto exit;


%page;
/*
   (* OLD EXPR  I.E. BRACKETS AROUND EXPRESSIONS  *)




   <old_expr> ::=
   <old_primary> <arith_op> <old_primary> ! */

prod (125):

        call mrds_dsl_expr_$condense_stack (psi_ptr,dbcb_ptr, select_area_ptr,
	   get_stacked_token (ls_top - 1), current_expr_level, code);
        if code ^= 0 then call error (code, ^LOUD, 0, "", "");
        goto exit;




/* <old_primary> ::=
   <relation>.<attribute> |
   <old_function> |
   <constant> |
   ( <old_expr> ) |
   <v_arg_substitution>   ! */

prod (126):
        call init_expression;
        call get_attribute_info (ATTRIBUTE, ^KEY, static_data.rel_index, attr_index);
        efd_ptr = expr_efd_ptrs (current_expr_level);

        if exp_fun_data.var_index = 0
        then exp_fun_data.var_index = static_data.rel_index;
        else if static_data.rel_index ^= exp_fun_data.var_index
	   then
	        call error (mrds_error_$mult_expr_vars, LOUD, 0, WCE_TYPE,
		   "");				/* else must match that already set */

        call mrds_dsl_expr_$build_attribute (psi_ptr,dbcb_ptr, static_data.range_ptr, static_data.rel_index,
	   rm_rel_info.attr_ptrs (attr_index), current_expr_level, code);
        if code ^= 0 then call error (code, ^LOUD, 0, "", "");

        goto exit;


prod (127):
        efd_ptr = func_efd_ptrs (current_func_level);

        if exp_fun_data.var_index <= 0 then do;		/* function is a constant */
	  call mrds_dsl_eval_func (area_ptr, exp_fun_data.ef_ptr, null, null,
	       code);
	  if code ^= 0
	  then
	       call error (code, LOUD, 0, WCF_TYPE,
		  "Error occured while evaluating function.");
	  if addr (exp_fun_data.descriptor) -> descriptor.type > 18
	       & addr (exp_fun_data.descriptor) -> descriptor.type < 23
	  then char_sw = CHAR_SW;
	  else char_sw = ^CHAR_SW;
	  call mrds_dsl_expr_$build_literal (psi_ptr,dbcb_ptr, exp_fun_data.assn_ptr,
	       addr (exp_fun_data.descriptor), char_sw, current_expr_level,
	       code);
	  if code ^= 0 then call error (code, ^LOUD, 0, "", "");
        end;

        else do;
	  if expr_efd_ptrs (current_expr_level) -> exp_fun_data.var_index = 0
	  then
	       expr_efd_ptrs (current_expr_level) -> exp_fun_data.var_index =
		  exp_fun_data.var_index;
	  else if expr_efd_ptrs (current_expr_level)
		  -> exp_fun_data.var_index ^= exp_fun_data.var_index
	       then call error (mrds_error_$mult_expr_vars, LOUD, 0,
		       WCE_TYPE, "");		/* else must match established var. */

	  call mrds_dsl_expr_$build_function (psi_ptr,dbcb_ptr, efd_ptr,
	       current_expr_level, code);
	  if code ^= 0 then call error (code, ^LOUD, 0, "", "");
        end;

        current_func_level = current_func_level - 1;

        goto exit;


prod (128):
        call init_expression;
        call mrds_dsl_expr_$build_literal (psi_ptr,dbcb_ptr, constant_ptr,
	   descriptor_copy_ptr,
	   ^CHAR_SW, current_expr_level, code);
        if code ^= 0 then call error (code, ^LOUD, 0, "", "");
        goto exit;

prod (129):
        goto exit;

prod (130):
        call init_expression;
        call mrds_dsl_expr_$build_literal (psi_ptr,dbcb_ptr, arg_ptr, descriptor_ptr,
	   ^CHAR_SW, current_expr_level,
	   code);
        if code ^= 0 then call error (code, ^LOUD, 0, "", "");
        goto exit;




/* <old_function> ::= <fn_name> (<old_arg_list>)   ! */

prod (131):

        call mrds_dsl_func_$finish (psi_ptr,dbcb_ptr, select_area_ptr, area_ptr,
	   func_efd_ptrs (current_func_level),
	   current_func_level, code);
        if code ^= 0 then call error (code, ^LOUD, 0, "", "");

        goto exit;





/* <old_arg_list> ::=
   <old_arg> |
   <old_arg_list> <old_arg>   ! */

prod (132):
        goto exit;

prod (133):
        goto exit;




/* <old_arg> ::=
   [ <old_func_or_expr> ] |
   <old_function> |
   <relation>.<attribute> |
   <constant> |
   <v_arg_substitution> ! */

prod (134):
        efd_ptr = expr_efd_ptrs (current_expr_level);
        call mrds_dsl_expr_$finish (psi_ptr,efd_ptr, select_area_ptr,
	   current_expr_level);

        if exp_fun_data.var_index <= 0 then do;		/* if really a constant */

	  call mrds_dsl_eval_expr (area_ptr, exp_fun_data.ef_ptr, null, null,
	       code);
	  if code ^= 0
	  then call error (code, LOUD, 0, WCE_TYPE,
		  "Error occured while evaluating the expression.");
	  call mrds_dsl_func_$build_literal (psi_ptr,dbcb_ptr, exp_fun_data.assn_ptr,
	       addr (exp_fun_data.descriptor), current_func_level, code);
	  if code ^= 0 then call error (code, ^LOUD, 0, "", "");
        end;					/* if constant */

        else do;					/* if not constant */
	  if func_efd_ptrs (current_func_level) -> exp_fun_data.var_index = 0
	  then
	       func_efd_ptrs (current_func_level) -> exp_fun_data.var_index =
		  exp_fun_data.var_index;
	  else if func_efd_ptrs (current_func_level)
		  -> exp_fun_data.var_index ^= exp_fun_data.var_index
	       then call error (mrds_error_$mult_expr_vars, LOUD, 0,
		       WCE_TYPE, "");		/* else must match established var. */

	  call mrds_dsl_func_$build_expr_func (psi_ptr,dbcb_ptr, efd_ptr,
	       EXPRESSION, current_func_level, code);
	  if code ^= 0 then call error (code, ^LOUD, 0, "", "");
        end;

        current_expr_level = current_expr_level - 1;

        goto exit;

prod (135):
        efd_ptr = func_efd_ptrs (current_func_level);
        if exp_fun_data.var_index <= 0 then do;		/* if really a constant */
	  call mrds_dsl_eval_func (area_ptr, exp_fun_data.ef_ptr, null, null,
	       code);
	  if code ^= 0
	  then call error (code, LOUD, 0, WCF_TYPE,
		  "Error occured while evaluating function.");
	  call mrds_dsl_func_$build_literal (psi_ptr,dbcb_ptr, exp_fun_data.assn_ptr,
	       addr (exp_fun_data.descriptor), current_func_level - 1, code);
	  if code ^= 0 then call error (code, ^LOUD, 0, "", "");
        end;					/* if constant */

        else do;					/* if not constant */
	  if func_efd_ptrs (current_func_level - 1) -> exp_fun_data.var_index
	       = 0
	  then
	       func_efd_ptrs (current_func_level - 1)
		  -> exp_fun_data.var_index =
		  exp_fun_data.var_index;
	  else if func_efd_ptrs (current_func_level - 1)
		  -> exp_fun_data.var_index ^= exp_fun_data.var_index
	       then call error (mrds_error_$mult_expr_vars, LOUD, 0,
		       WCE_TYPE, "");		/* else must match established var. */

	  call mrds_dsl_func_$build_expr_func (psi_ptr,dbcb_ptr, efd_ptr,
	       ^EXPRESSION,
	       current_func_level - 1, code);
	  if code ^= 0 then call error (code, ^LOUD, 0, "", "");
        end;

        current_expr_level = current_expr_level - 1;
        current_func_level = current_func_level - 1;


        goto exit;

prod (136):
        call get_attribute_info (ATTRIBUTE, ^KEY, static_data.rel_index, attr_index);
        efd_ptr = func_efd_ptrs (current_func_level);

        if exp_fun_data.var_index = 0
        then exp_fun_data.var_index = static_data.rel_index;
        else if static_data.rel_index ^= exp_fun_data.var_index
	   then
	        call error (mrds_error_$mult_expr_vars, LOUD, 0, WCF_TYPE,
		   "");				/* else must match that already set */

        call mrds_dsl_func_$build_attribute (psi_ptr,dbcb_ptr, static_data.range_ptr, static_data.rel_index,
	   rm_rel_info.attr_ptrs (attr_index), current_func_level, code);
        if code ^= 0 then call error (code, ^LOUD, 0, "", "");

        goto exit;

prod (137):
        call mrds_dsl_func_$build_literal (psi_ptr,dbcb_ptr, constant_ptr,
	   descriptor_copy_ptr, current_func_level, code);
        if code ^= 0 then call error (code, ^LOUD, 0, "", "");
        goto exit;

prod (138):
        call mrds_dsl_func_$build_literal (psi_ptr,dbcb_ptr, arg_ptr, descriptor_ptr,
	   current_func_level, code);
        if code ^= 0 then call error (code, ^LOUD, 0, "", "");
        goto exit;

%page;
/*
   (* COMMON PRODUCTIONS *)




   <function> ::= <fn_name> (<arg_list>)   ! */

prod (139):
        call error (mrds_error_$unimplemented_syntax, LOUD, 3, SE_TYPE, "");
        goto exit;




/* <arg_list> ::=
   <expr> |
   <arg_list> , <expr>   ! */

prod (140):
        goto exit;

prod (141):
        goto exit;



/* <attribute_spec> ::=
   <attribute> |
   <symbol> . <symbol>   |
   <db_label> . <relation> . <attribute>  ! */

prod (142):
        call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");
        goto exit;

prod (143):
        call get_attribute_info (ATTRIBUTE, ^KEY, static_data.rel_index, attr_index);

        goto exit;

prod (144):
        goto exit;




/* <constant_list> ::=
   <constant_item> , <constant_item> |
   <constant_list> , <constant_item> ! */

prod (145):
        goto exit;

prod (146):
        goto exit;




/* <constant_item> ::=
   <constant> |
   <v_arg_substitution> |
   <x_arg_substitution> ! */

prod (147):
        goto exit;

prod (148):
        goto exit;

prod (149):
        goto exit;




/* <constant> ::=
   <string> |
   <integer> |
   <bit_string> ! */

prod (150):
        j = index (substr (lex_token, 2), DQ);

        if j = 0 then do;				/* no double quotes */
	  char_descriptor.length = lex_stack.token_length (ls_top) - 2;
						/* dont want first and last quotes */
	  if char_descriptor.length = 0 then do;	/* null string */
	      string_len = 0;
	      allocate string_token in (select_area) set (constant_ptr);
	  end;
	  else constant_ptr = addcharno (lex_stack.token_ptr (ls_top), 1);
						/* skip 1st quote */
        end;

        else do;					/* yech, we have double quotes */
	  string_len = lex_stack.token_length (ls_top);
	  allocate string_token in (select_area);

	  i = 1;					/* next free spot in string_token */
	  k = 2;					/* start after first quote */
	  done = "0"b;
	  do while (^done);				/* process each DQ  taking only one of the two quotes */

	      substr (string_token, i, j) = substr (lex_token, k, j);

	      i = i + j;
	      k = k + j + 1;

	      j = index (substr (lex_token, k), DQ);

	      if j = 0 then do;			/* all done, but need rest of string */
		substr (string_token, i, string_len - k) =
		     substr (lex_token, k, string_len - k);
		i = i + string_len - k;
		done = "1"b;
	      end;
	  end;

	  constant_ptr = addr (string_token);
	  char_descriptor.length = i - 1;
        end;					/* else if have DQ */


        allocate descriptor_copy in (literal_area);
        descriptor_copy = addr (char_descriptor) -> descriptor_copy;

        if debug
        then
	   call ioa_ (
	        "Quoted strings: input -> '^a' output -> '^a' descriptor -> ^o"
	        ,
	        lex_token, cons, descriptor_copy);

        goto exit;

prod (151):
        char_descriptor.length = lex_stack.token_length (ls_top);
        constant_ptr = lex_stack.token_ptr (ls_top);
        allocate descriptor_copy in (literal_area);
        descriptor_copy = addr (char_descriptor) -> descriptor_copy;

        goto exit;

prod (152):
        b_pos =
	   lex_stack.token_length (ls_top) - index (reverse (lex_token), B)
	   + 1;

/* convert the base to something meaningful */
        if b_pos = lex_stack.token_length (ls_top)
        then base = 1;
        else base =
	        binary (substr (lex_token, lex_stack.token_length (ls_top)),
	        17);

        if search (lex_token,QUOTE)=0 then do; /* bit integer i.e. 101b */
	   bit_start_pos=1;                  /* first bit pos in token */
	   i=1;                              /* token len - i = pos of last data char in token */
	   k=1;                              /* token len - k = num of data chars in token */
        end;
        else do;                             /* bit string i.e. "101"b */
	   bit_start_pos=2;
	   i=2;
	   k=3;
        end;

        j = verify (substr (lex_token, bit_start_pos, b_pos - k),
	   LEGAL_CHARACTERS (base));			/* do the characters in the string make sense given the base */

        if j = 0 then do;				/* all characters are good */
	  char_descriptor.length, string_len = (b_pos - k) * base;
	  allocate string_token in (select_area);

	  do j = bit_start_pos to b_pos - i;			/* replace characters with their corresponding bit string */
	      substr (string_token, (j - i) * base + 1, base) =
		 substr (
		 HEX_BITS (
		 index ("0123456789abcdef", substr (lex_token, j, 1))),
		 5 - base);
	  end;

	  constant_ptr = string_ptr;
	  allocate descriptor_copy in (literal_area);
	  descriptor_copy = addr (char_descriptor) -> descriptor_copy;

	  if debug
	  then call ioa_ (
		  "Bit string: input -> '^a' output -> '^a' descriptor -> ^o"
		  ,
		  lex_token, string_token, descriptor_copy);
        end;
        else call error (mrds_error_$inv_string, LOUD, 0, WC_TYPE,
	        "The bit string contains characters that conflict with given base."
	        );

        goto exit;




/* <arith_op> ::= <mult_op> | <add_op> ! */

prod (153):
        goto exit;

prod (154):
        goto exit;




/* <add_op> ::= + | - ! */

prod (155):
        goto exit;

prod (156):
        goto exit;




/* <mult_op> ::= * | / ! */

prod (157):
        goto exit;

prod (158):
        goto exit;




/* <and_op> ::= & ! */

prod (159):
        goto exit;




/* <or_op>  ::= '| ! */

prod (160):
        goto exit;




/* <not_op> ::= ^ ! */

prod (161):
        goto exit;




/* <v_arg_substitution> ::=  .V. ! */

prod (162):
        call get_next_arg (arg_ptr, descriptor_ptr);

        goto exit;




/* <x_arg_substitution> ::=  .X. ! */

prod (163):
        goto exit;




/* <db_label> ::= <symbol> ! */

prod (164):
        call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");
        goto exit;




/* <relation> ::= <symbol>   ! */

prod (165):
        goto exit;




/* <relation_label> ::= <symbol> ! */

prod (166):
        goto exit;




/* <attribute> ::=  <symbol>   ! */

prod (167):
        goto exit;




/* <fn_name> ::= <symbol> ! */

prod (168):
        if dbcb.sfi_ptr = null () then do;
	  call mrds_dsl_get_builtins (dbcb_ptr, code);
	  if code ^= 0 then call error (code, LOUD, 0, WCF_TYPE, "");
        end;

        current_func_level = current_func_level + 1;	/* now make a new function level */
        allocate exp_fun_data in (select_area);
        unspec (exp_fun_data) = "0"b;
        func_efd_ptrs (current_func_level) = efd_ptr;

        current_expr_level = current_expr_level + 1;	/* and since a function is a expression, a new one of these */
        allocate exp_fun_data in (select_area);
        unspec (exp_fun_data) = "0"b;
        expr_efd_ptrs (current_expr_level) = efd_ptr;

        call mrds_dsl_expr_$init (psi_ptr,current_expr_level);
        call mrds_dsl_func_$init (psi_ptr,dbcb_ptr, lex_token, dbcb.sfi_ptr,
	   select_area_ptr,
	   current_func_level, code)
	   ;
        if code ^= 0 then call error (code, ^LOUD, 0, "", "");

        goto exit;




/* <alias> ::=  <symbol>   ! */

prod (169):
        goto exit;


exit:
        return;

get_relation_statistics:
    procedure (code);

/* DESCRIPTION:

   This routine updates the current relation  population  statistics
   for  each  relation  in the range clause for this block. Temp rel
   stats never need to be updated, they are set at definition  time.
   Perm  rels  are  updated  at  first  reference  time,  and  every
   mrds_data_$ statistic_update_count_interval reference  times,  or
   mrds_data_$statistics_update_time_interval   elapsed  real  time,
   whichever comes first. Small size relations have their statistics
   updated  every  selection  expression,  to avoid large perenctage
   changes over few update I/O operations,  "small"  is  defined  in
   mrds_data_$statistics_update_small_rel_size.      The     current
   statistics  are  expected  to  be  reasonable  accurate  for  the
   optimization  of  search  costs  done  in  mrds_dsl_permute.  The
   statistics kept are the number of  tuples  in  the  relation  and
   number of dupliacte index values for each index.

*/

dcl     i			 fixed bin;		/* loop index */
dcl     mrds_data_$statistics_update_count_interval
			 fixed bin (35) ext;	/* number of rel refs before update needed */
dcl     mrds_data_$statistics_update_small_rel_size
			 fixed bin (35) ext;	/* num tuples below which
						   must update stats every S.E. */
dcl     mrds_data_$statistics_update_time_interval
			 fixed bin (71) ext;	/* number of real microsecs before update needed */
dcl     code		 fixed bin (35);		/* local error code */
dcl     mu_rel_statistics$record_statistics
			 entry (fixed bin (35), entry, entry, entry,
			 entry, entry, ptr, ptr, ptr,
			 fixed bin (35), fixed bin (35));

dcl     current_time	 fixed bin (71);		/* variable for current time */


        current_time = clock ();

/* go through all relations referenced in the range clause */

        do i = 1 to range.num_vars while (code = 0);

	  if ^range.tup_var (i).temp_rel then do;	/* only need to update perm rels */

	      rmri_ptr = range.tup_var (i).ri_ptr;

/* don't update relations already seen in this selection expresion */

	      if rm_rel_info.last_statistics_update_s_e_ref_num
		 ^= dbcb.last_s_e_id_num then do;

		if rm_rel_info.last_statistics_update_count ^= 0
		then /* 0 => never got stats */
		     rm_rel_info.last_statistics_update_count =
			rm_rel_info.last_statistics_update_count + 1;
						/* add to ref cnt */

		if rm_rel_info.last_statistics_update_count = 0
		     | rm_rel_info.current_tuple_population
		     <= mrds_data_$statistics_update_small_rel_size
		     | rm_rel_info.last_statistics_update_count
		     > mrds_data_$statistics_update_count_interval
		     | current_time
		     - rm_rel_info.last_statistics_update_time
		     > mrds_data_$statistics_update_time_interval then do;
						/* time to do update */

		    call mu_rel_statistics$record_statistics (dbcb.dbi,
		         dbcb.relmgr_entries.create_cursor,
		         dbcb.relmgr_entries.open,
		         dbcb.relmgr_entries.get_duplicate_key_count,
		         dbcb.relmgr_entries.get_population,
		         dbcb.relmgr_entries.get_count,
		         dbcb.cursor_ptrs_storage_ptr,
		         dbcb.cursor_storage_area_ptr, rmri_ptr,
		         dbcb.last_s_e_id_num, code);

		    if caller = mrds_data_$caller_compile
		         & rm_rel_info.current_tuple_population = 0
		    then rm_rel_info.current_tuple_population = 5;
		end;
	      end;
	  end;
        end;
    end get_relation_statistics;

get_attribute_info:
    proc (attribute, key, rel_index, attr_index);
						/* procedure to check an attribute and get the info for it */
dcl     (rel_index, attr_index)
			 fixed bin parameter;
dcl     (attribute, key)	 bit (1) aligned parameter;
dcl     (rel_pos, attr_pos)	 fixed bin;

        range_ptr = static_data.range_ptr;
        if attribute then do;				/* find relation and attribute positions in lex stack */
	  if key then do;				/* found a * after attribute for temp rel */
	      rel_pos = 3;
	      attr_pos = 1;
	  end;
	  else do;
	      rel_pos = 2;
	      attr_pos = 0;
	  end;
        end;
        else rel_pos, attr_pos = 0;

        rel_name = get_stacked_token (ls_top - rel_pos);
        attr_name = get_stacked_token (ls_top - attr_pos);

/* make sure the relation name is good */
        do rel_index = 1 to range.num_vars
	   while (rel_name ^= range.tup_var.name (rel_index));
        end;

        if rel_index > range.num_vars
        then call error (mrds_error_$bad_var, LOUD, rel_pos, SE_TYPE,
	        "The relation identifier '" || rtrim (rel_name)
	        || "' is unknown in this opening.");

        if range.tup_var.temp_rel (rel_index)
        then rmra_ptr = static_data.rdbi_ptr -> rm_db_info.tra_ptr;
        else rmra_ptr = static_data.rdbi_ptr -> rm_db_info.ra_ptr;

        static_data.rmri_ptr, rmri_ptr =
	   rm_rel_array.rel_data
	   .ri_ptr (range.tup_var.rel_index (rel_index));

        if attribute then do;
	  do attr_index = 1 to rm_rel_info.num_attr
	       while (attr_name
	       ^= rm_rel_info.attr_ptrs (attr_index) -> rm_attr_info.name);
	  end;

	  if attr_index > rm_rel_info.num_attr
	  then call error (mrds_error_$bad_attr, LOUD, attr_pos, SE_TYPE,
		  "The attribute '" || rtrim (attr_name)
		  || "' does not exist in the relation '"
		  || rtrim (rm_rel_info.name) || "'.");
        end;

    end get_attribute_info;

dbf:
    entry ();
        debug = "0"b;
        return;

dbn:
    entry ();
        debug = "1"b;
        return;


error:
    proc (cd, loud, stack_offset, error_type, message);

dcl     cd		 fixed bin (35);		/* standard error code */
dcl     loud		 bit (1) aligned;		/* OFF => dont print or signal error */
dcl     stack_offset	 fixed bin;		/* offset from ls_top of where token is in lex stack */
dcl     error_type		 char (*);
dcl     message		 char (*);

        se_info_ptr = dbcb.se_info_ptr;
        code = cd;

        if se_info.error_info_supplied then do;		/* sombody else did the dirty work */
						/* now just get the token */
	  se_info.token_length =
	       lex_stack.token_length (ls_top - se_info.stack_offset);
	  se_info.token_start =
	       lex_stack.token_start_pos (ls_top - se_info.stack_offset);
        end;

        else do;
	  se_info.loud = loud;
	  se_info.error_type = error_type;
	  se_info.token_start =
	       lex_stack.token_start_pos (ls_top - stack_offset);
	  se_info.token_length =
	       lex_stack.token_length (ls_top - stack_offset);

	  if code = mrds_error_$unimplemented_syntax
	  then se_info.error_msg =
		  "Unimplemented token is '"
		  || get_stacked_token (ls_top - stack_offset) || "'.";
	  else se_info.error_msg = message;
        end;

        goto exit;

    end error;

get_next_arg:
    proc (a_ptr, d_ptr);
dcl     (d_ptr, a_ptr)	 ptr;

        if num_args < 1
        then call error (mrds_error_$insuff_args, ^LOUD, 0, "", "");

        a_ptr = argp_ptr -> based_ptr;			/* get ptr to arg */
        d_ptr, desc_ptr = descp_ptr -> based_ptr;		/* and ptr to desc. */

        if descriptor.type = VAR_CHAR | descriptor.type = VAR_BIT
        then
	   /* if varying */
	   a_ptr = addrel (a_ptr, -1);		/* include length */

        argp_ptr = addrel (argp_ptr, 2);		/* adjust argp_ptr to bypass this arg */
        descp_ptr = addrel (descp_ptr, 2);		/* and the descp_ptr */
        num_args = num_args - 1;			/* and the remaining arg count */

    end get_next_arg;

get_stacked_token:
    proc (position) returns (char (*));
dcl     position		 fixed bin;
dcl     len		 fixed bin;
dcl     token		 char (len) based;
        len = lex_stack (position).token_length;
        return (lex_stack (position).token_ptr -> token);
    end get_stacked_token;

init_expression:
    proc;

/* This proc is called for every argument in an expression to make
   sure that we will have a exp_fun_data structure to put the expression
   into. It checks to see if our func level is the same as our expr level
   and makes a new struct if it is. The only time the func and expr level
   are the same is if the current expr is a func. The parser does not know
   when it encounters a new expression so we have to help it a little.
*/

        if current_expr_level = current_func_level then do;
	  current_expr_level = current_expr_level + 1;	/* make a new expr level */
	  allocate exp_fun_data in (select_area);
	  unspec (exp_fun_data) = "0"b;
	  expr_efd_ptrs (current_expr_level) = efd_ptr;
	  call mrds_dsl_expr_$init (psi_ptr,current_expr_level);
        end;

    end;

init_select_list:
    proc;

/* routine to initialize a select_list structure. This holds the select clause */
        allocate select_list in (select_area) set (static_data.select_list_ptr);
        select_list_ptr = static_data.select_list_ptr;
        select_list.mla_ptr = null ();
        allocate free_relations in (select_area);
        free_relations.num_free_rels = 0;
        string (select_list.var_exists) = "0"b;
        select_list.num_vars, select_list.num_items = 0;	/* init. to empty */
    end;

process_set_op:
    proc (type);

dcl     type		 fixed bin;

        if dbcb.ss_ptr = null then do;			/* first time */
	  dbcb.val_rtrv,				/* init valid. flags */
	       dbcb.val_dtr = "1"b;
	  dbcb.val_mod,
	       dbcb.val_del = "0"b;

	  nitems_init = 2 * mrds_data_$max_sets;	/* set up select sets structure */
	  allocate select_sets in (select_area);
	  select_sets.dup_retain = "0"b;
	  select_sets.nitems = 0;
	  dbcb.ss_ptr = ss_ptr;

	  do k = 1 to static_data.select_list_ptr -> select_list.num_items;
	      select_sets.domains (k) =
		 static_data.select_list_ptr -> select_list.ai_ptr (k)
		 -> rm_attr_info.domain_ptr -> rm_domain_info.name;
	  end;

	  op_top = 0;

        end;
        else do;
	  ss_ptr = dbcb.ss_ptr;
	  nitems_init = 2 * mrds_data_$max_sets;
        end;

        if se_pending then do;
	  if select_sets.nitems + 1 >= nitems_init	/* check for the se and its required oper */
	  then call error (mrds_error_$set_ovfl, LOUD, 0, SE_TYPE, "");

	  select_sets.nitems = select_sets.nitems + 1;
	  select_sets.items.oper_flag (select_sets.nitems) = "0"b;
						/* not an operator */
	  select_sets.items.range_ptr (select_sets.nitems) = dbcb.range_ptr;
	  select_sets.items.select_ptr (select_sets.nitems) =
	       dbcb.select_ptr;
	  select_sets.items.ti_ptr (select_sets.nitems) = dbcb.ti_ptr;
	  select_sets.items.so_ptr (select_sets.nitems) = dbcb.so_ptr;

	  se_pending = "0"b;
        end;

        allocate range in (select_area) set (static_data.range_ptr);
        static_data.range_ptr -> range.num_vars = 0;

        pred_tree_ptr = null;

        if op_top >= mrds_data_$max_sets
        then /* if overflowing operator stack */
	   call error (mrds_error_$set_ovfl, LOUD, 0, SE_TYPE, "");

        op_top = op_top + 1;
        op_stack (op_top) = type;

    end process_set_op;

init:
    entry (a_lex_stack_ptr, a_se_info_ptr, a_dbcb_ptr, psi_ptr, a_area_ptr, a_caller,
         a_option_list_ptr, a_argp_ptr, a_descp_ptr, a_num_args, a_cur_sw);

        allocate static_data in (parser_work_area);

/* copy the outside world into static locals */
        static_data.lex_stack_ptr = a_lex_stack_ptr;
        dbcb_ptr, static_data.dbcb_ptr = a_dbcb_ptr;
        static_data.area_ptr = a_area_ptr;
        static_data.caller = a_caller;
        static_data.option_list_ptr = a_option_list_ptr;
        static_data.argp_ptr = a_argp_ptr;
        static_data.descp_ptr = a_descp_ptr;
        static_data.num_args = a_num_args;
        static_data.cur_sw = a_cur_sw;
        dbcb.se_info_ptr = a_se_info_ptr;

        select_area_ptr, static_data.select_area_ptr = dbcb.select_area_ptr;
        static_data.trl_ptr, static_data.x_pred_leaf_ptr, pred_tree_ptr = null;
        static_data.char_descriptor.type="5260"b3;
        current_expr_level, current_func_level = 0;


/* Range clause initializations */
        if cur_sw
        then static_data.range_ptr = dbcb.range_ptr;
        else do;
	  allocate range in (select_area) set (static_data.range_ptr);
	  static_data.range_ptr -> range.num_vars = 0;
        end;

        static_data.rdbi_ptr = dbcb.rdbi_ptr;

        return;

%include mrds_lex_stack;
%page;
%include mrds_se_info;
%page;
%include mrds_se_options;
%page;
%include mrds_dbcb;
%page;
%include mrds_range;
%page;
%include mrds_compiled_se_info;
%page;
%include mdbm_rm_db_info;
%page;
%include mdbm_rm_domain_info;
%page;
%include mdbm_rm_rel_array;
%page;
%include mdbm_rm_rel_info;
%page;
%include mdbm_rm_attr_info;
%page;
%include mdbm_seg_area;
%page;
%include mrds_select_area;
%page;
%include mdbm_descriptor;
%page;
%include mrds_select_list;
%page;
%include mrds_select_sets;
%page;
%include mdbm_scope_info;
%page;
%include mrds_predicate_tree;
%page;
%include mrds_lit_info;
%page;
%include mrds_exp_fun_data;

/* declarations are sorted by variable name. Please keep it this way. */

dcl     ATTRIBUTE		 bit (1) aligned init ("1"b) internal
			 static options (constant);
dcl     B			 char (1) aligned init ("b") internal
			 static options (constant);
dcl     CHAR_SW		 bit (1) aligned init ("1"b) internal
			 static options (constant);
dcl     DQ		 char (2) init ("""""") aligned internal
			 static options (constant);	/* 2 quotes, i hope */
dcl     EXPRESSION		 bit (1) aligned init ("1"b) internal
			 static options (constant);
dcl     FB35		 bit (36) init ("404000000043"b3) internal
			 static options (constant);
dcl     HEX_BITS		 (16) char (4)
			 init ("0000", "0001", "0010", "0011", "0100",
			 "0101", "0110", "0111", "1000", "1001", "1010",
			 "1011", "1100", "1101", "1110", "1111")
			 internal static options (constant);
dcl     KEY		 bit (1) aligned init ("1"b) internal
			 static options (constant);
dcl     LEGAL_CHARACTERS	 (4) char (16)
			 init ("01", "0123", "01234567",
			 "0123456789abcdef") internal static
			 options (constant);
dcl     LOGICAL_NODE	 bit (1) aligned init ("1"b) internal
			 static options (constant);
dcl     LOUD		 bit (1) aligned init ("1"b) internal
			 static options (constant);
dcl     NOT_NODE		 bit (1) aligned init ("1"b) internal
			 static options (constant);
dcl     QUOTE		 init ("""") char(1) internal static
			 options (constant);
dcl     VAR_BIT		 init (20) fixed bin (5) internal static
			 options (constant);
dcl     VAR_CHAR		 init (22) fixed bin (5) internal static
			 options (constant);
dcl     X_SW		 bit (1) aligned init ("1"b) internal
			 static options (constant);
dcl     a_area_ptr		 ptr parameter;
dcl     a_argp_ptr		 ptr parameter;
dcl     a_caller		 fixed bin (35) parameter;
dcl     a_cur_sw		 bit aligned parameter;
dcl     a_dbcb_ptr		 ptr parameter;
dcl     a_descp_ptr		 ptr parameter;
dcl     a_lex_stack_ptr	 ptr parameter;
dcl     a_num_args		 fixed bin parameter;
dcl     a_option_list_ptr	 ptr parameter;
dcl     a_se_info_ptr	 ptr parameter;
dcl     addcharno		 builtin;
dcl     addr		 builtin;
dcl     addrel		 builtin;
dcl     attr_name		 char (32);
dcl     b_pos		 fixed bin;
dcl     base		 fixed bin;
dcl     based_ptr		 ptr based;
dcl     binary		 builtin;
dcl     bit36		 bit (36) based;
dcl     bit_start_pos          fixed bin;
dcl     char		 builtin;
dcl     char_sw		 bit (1) aligned;
dcl     clock		 builtin;
dcl     code		 fixed bin (35) parameter;
dcl     cons		 char (char_descriptor.length)
			 based (constant_ptr);
dcl     debug		 bit internal static init ("0"b);
dcl     descriptor_copy	 bit (36) aligned based (descriptor_copy_ptr);
dcl     descriptor_copy_ptr	 ptr;
dcl     divide		 builtin;
dcl     done		 bit (1) aligned;
dcl     fixed		 builtin;
dcl     fixed_bin_35	 fixed bin (35) based;
dcl     1 free_relations	 based (select_list.fr_ptr) aligned,
						/* list of relation used in the select clause */
	2 num_free_rels	 fixed bin,
	2 free_rels	 (mrds_data_$max_relations) fixed bin;
						/* array to hold all indicies of free vars */
dcl     i			 fixed bin;
dcl     index		 builtin;
dcl     ioa_		 entry () options (variable);
dcl     j			 fixed bin;
dcl     k			 fixed bin;
dcl     length		 builtin;
dcl     lex_stack_ptr	 ptr;
dcl     lex_token		 char (lex_stack (ls_top).token_length)
			 based (lex_stack (ls_top).token_ptr);
dcl     literal_area	 area based (dbcb.select_area_ptr);
dcl     ls_top		 fixed bin parameter;
dcl     ltrim		 builtin;
dcl     mrds_data_$caller_compile
			 fixed bin (35) external static;
dcl     mrds_data_$max_attributes
			 fixed bin (35) external static;
dcl     mrds_data_$max_expr_stack_size	 fixed bin (35) external static;
dcl     mrds_data_$max_id_len	 fixed bin (35) external static;
dcl     mrds_data_$max_relations
			 fixed bin (35) external static;
dcl     mrds_data_$max_select_items
			 fixed bin (35) external static;
dcl     mrds_data_$max_sets	 fixed bin (35) external static;
dcl     mrds_data_$max_temp_rels
			 fixed bin (35) external static;
dcl     mrds_data_$max_tup_var fixed bin (35) external static;
dcl     mrds_dsl_eval_expr	 entry (ptr, ptr, ptr, ptr, fixed bin (35));
dcl     mrds_dsl_eval_func	 entry (ptr, ptr, ptr, ptr, fixed bin (35));
dcl     mrds_dsl_expr_$build_attribute
			 entry (ptr,ptr, ptr, fixed bin, ptr, fixed bin,
			 fixed bin (35));
dcl     mrds_dsl_expr_$build_function
			 entry (ptr,ptr, ptr, fixed bin, fixed bin (35));
dcl     mrds_dsl_expr_$build_literal
			 entry (ptr, ptr,ptr, ptr, bit (1) aligned,
			 fixed bin, fixed bin (35));
dcl     mrds_dsl_expr_$condense_stack
			 entry (ptr, ptr,ptr, char (1) aligned, fixed bin,
			 fixed bin (35));
dcl     mrds_dsl_expr_$finish	 entry (ptr,ptr, ptr, fixed bin);
dcl     mrds_dsl_expr_$init	 entry (ptr,fixed bin);
dcl     mrds_dsl_func_$build_attribute
			 entry (ptr,ptr, ptr, fixed bin, ptr, fixed bin,
			 fixed bin (35));
dcl     mrds_dsl_func_$build_expr_func
			 entry (ptr,ptr, ptr, bit (1) aligned, fixed bin,
			 fixed bin (35));
dcl     mrds_dsl_func_$build_literal
			 entry (ptr,ptr, ptr, ptr, fixed bin, fixed bin (35))
			 ;
dcl     mrds_dsl_func_$finish	 entry (ptr,ptr, ptr, ptr, ptr, fixed bin,
			 fixed bin (35));
dcl     mrds_dsl_func_$init	 entry (ptr,ptr, char (*), ptr, ptr, fixed bin,
			 fixed bin (35));
dcl     mrds_dsl_get_builtins	 entry (ptr, fixed bin (35));
dcl     mrds_dsl_optimize	 entry (ptr, ptr, ptr, fixed bin (35));
dcl     mrds_dsl_select_clause_$all_attributes
			 entry (ptr, ptr, ptr, ptr, fixed bin,
			 bit (1) aligned, fixed bin (35), fixed bin (35))
			 ;
dcl     mrds_dsl_select_clause_$finish
			 entry (ptr, ptr, ptr, ptr, fixed bin (35), ptr,
			 ptr, ptr, fixed bin, bit (1) aligned,
			 fixed bin (35));
dcl     mrds_dsl_select_clause_$one_attribute
			 entry (ptr, ptr, ptr, ptr, fixed bin, fixed bin,
			 bit (1) aligned, bit (1) aligned,
			 fixed bin (35), fixed bin (35))
			 ;
dcl     mrds_dsl_where_clause_$build_attribute
			 entry (ptr,ptr, ptr, fixed bin, ptr, fixed bin (35))
			 ;
dcl     mrds_dsl_where_clause_$build_expr
			 entry (ptr,ptr, ptr, fixed bin (35));
dcl     mrds_dsl_where_clause_$build_literal
			 entry (ptr,ptr, ptr, ptr, ptr, ptr, bit (1) aligned,
			 fixed bin (35));
dcl     mrds_dsl_where_clause_$build_node
			 entry (ptr,ptr, ptr, fixed bin, bit (1) aligned,
			 bit (1) aligned, fixed bin (35));
dcl     mrds_dsl_where_clause_$finish
			 entry (ptr,ptr);
dcl     mrds_error_$bad_attr	 fixed bin (35) external static;
dcl     mrds_error_$bad_temp_rel_val
			 fixed bin (35) external static;
dcl     mrds_error_$bad_var	 fixed bin (35) external static;
dcl     mrds_error_$curr_not_alld
			 fixed bin (35) external static;
dcl     mrds_error_$insuff_args
			 fixed bin (35) external static;
dcl     mrds_error_$inv_string fixed bin (35) external static;
dcl     mrds_error_$inval_comp_expr
			 fixed bin (35) external static;
dcl     mrds_error_$max_tup_var
			 fixed bin (35) external static;
dcl     mrds_error_$mult_def_var
			 fixed bin (35) external static;
dcl     mrds_error_$mult_expr_vars
			 fixed bin (35) external static;
dcl     mrds_error_$no_prior_se
			 fixed bin (35) external static;
dcl     mrds_error_$set_ovfl	 fixed bin (35) external static;
dcl     mrds_error_$undef_rel	 fixed bin (35) external static;
dcl     mrds_error_$undef_temp_rel
			 fixed bin (35) external static;
dcl     mrds_error_$unimplemented_syntax
			 fixed bin (35) external static;
dcl     mu_convert$convert_data
			 entry (ptr, ptr, ptr, ptr, fixed bin (35));
dcl     mu_valid_data_type$valid_scalar_data_type
			 entry (bit (36)) returns (bit (1) aligned);
dcl     null		 builtin;
dcl     prod_no		 fixed bin parameter;
dcl     rel		 builtin;
dcl     rel_name		 char (32);
dcl     reverse		 builtin;
dcl     rtrim		 builtin;
dcl     se_info_ptr		 ptr;
dcl     search		 builtin;
dcl 1 static_data aligned based (parser_static_info.static_data_ptr),
      2 area_ptr ptr,
      2 arg_ptr ptr,
      2 argp_ptr ptr,
      2 constant_ptr ptr,
      2 dbcb_ptr ptr,
      2 descp_ptr ptr,
      2 descriptor_ptr ptr,
      2 lex_stack_ptr ptr,
      2 pred_tree_ptr ptr,
      2 option_list_ptr ptr,
      2 range_ptr ptr,
      2 rdbi_ptr ptr,
      2 rmri_ptr ptr,
      2 select_area_ptr ptr,
      2 select_list_ptr ptr,
      2 trl_ptr ptr,
      2 x_pred_leaf_ptr ptr,
      2 attr_index fixed bin,
      2 caller fixed bin (35),
      2 char_descriptor aligned,
	3 type bit (12) unal,
	3 length fixed bin (23) unal,
      2 cur_sw bit(1) aligned,
      2 se_pending bit (1) aligned,
      2 current_expr_level fixed bin,
      2 current_func_level fixed bin,
      2 num_args fixed bin,
      2 op_top fixed bin,
      2 primary_type char (4) aligned,
      2 rel_index fixed bin,
      2 efd_ptrs (mrds_data_$max_expr_stack_size),
          3 expr_efd_ptrs ptr,
          3 func_efd_ptrs ptr,
      2 op_stack (mrds_data_$max_sets) fixed bin;
dcl     string		 builtin;
dcl     string_len		 fixed bin;
dcl     string_ptr		 ptr;
dcl     string_token	 char (string_len) based (string_ptr);
dcl     substr		 builtin;
dcl     sys_info$max_seg_size	 fixed bin (35) external static;
dcl     temp_rel_index	 fixed bin (35);
dcl     unspec		 builtin;
dcl     verify		 builtin;

    end mrds_dsl_semantics;

