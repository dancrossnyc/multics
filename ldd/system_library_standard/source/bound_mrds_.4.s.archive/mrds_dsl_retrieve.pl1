/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
     This entry is being made to cover the change made on 85-06-27 by Thanh
     Nguyen. (see mrds #137)
  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
     Check to see if we were called by copy_mrds_data before issuing an error
     about the se_txn not being the same as the current txn (mrds #156).
  3) change(86-06-19,Dupuis), approve(86-08-07,MCR7491),
     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
     This entry is being made to cover the change made on 86-02-18 by John
     Hergert (mrds error list #153).
  4) change(87-01-22,Hergert), approve(88-07-11,MCR7903),
     audit(88-07-07,Dupuis), install(88-08-01,MR12.2-1073):
     For new parser, changed references to sel_ptr to selct_list_ptr.
                                                   END HISTORY COMMENTS */


mrds_dsl_retrieve: retrieve: proc;

/* (database_index, selection_expression, values,...., values, code) */

/* BEGIN DESCRIPTION

   The purpose of this procedure is to implement the dsl_$retrieve function.
   This procedure creates an argument list for and calls translate,
   then calls search.

   END DESCRIPTION
*/
%page;
/* HISTORY:

   76-02-01  Originally written by R. D. Lackey.

   77-03-01 R. D. Lackey: Modified  to support set operations.

   77-09-01 R. D. Lackey: Modified  to  correct  deletion  of  non-
   allocated file.

   77-11-01 R. D. Lackey:  Modified  to  correct  static  variables
   used by  multiple databases.

   78-07-01 Oris Friesen: Modified  to  fix  problems  with  nested
   intersects  and  differences.

   78-07-14 Oris Friesen: Modified to fix union bug.

   78-10-01 JA  Weeldreyer: Incorporated  MR7.0  changes.

   79-03-26 Al Kepner: Added caller parameter to mrds_dsl_translate.

   79-08-27 Al Kepner : Modified  to expand  the  current_data   and
   static_data  variables  (used  in eliminating duplicates) to full
   segments.

   79-10-24  Davids: Modified the  length  calculation  for  varying
   strings  so  that it takes into account bit verus character data.
   Also so that it takes the length from the correct location in the
   tuple.

   79-10-30 Jim Gray: Modified to set  the  select_list pointer from
   dbcb.current_ptr when a -current clause is used.

   79-11-14 Jim Gray: Modified to fix  looping  cleanup  handler bug
   by adding clean_up_condition variable.

   80-02-14 Jim Gray: Modified to put allocations in a   non-freeing
   extensible area managed by this routine.

   80-04-01 Jim Gray: Modified to change data_ptr passed back by the
   $set_tuple entry used by define_temp_rel so that it points to the
   data  portion  of  the  varying  character  string  current_data,
   not the count word.

   80-05-08  Davids:  modified  assignments  of  tuple_num_atts  and
   tuple_nvar_atts  to  take  values from rm_rel_info.model_num_attr
   and  model_nvar_atts   rather   than   rm_rel_info.num_attr   and
   nvar_atts.  This  was  to  fix  a problem with submodels were the
   submodel view did not contain a varying string attribute and  the
   model did.

   80-09-16 Davids: removed  declarations  of  variables  that  were
   never referenced. Also removed from the entry point set_tuple two
   lines of code that as the first thing done  saved  the  value  of
   area_ptr  in  a temporary and then set the value of area_ptr back
   before the return. the assignment into a temporary was causing an
   illegal   modifier   condition   because  of  the  value  of  the
   uninitialized bits in the stack (area_ptr is  automatic)  -  this
   only  happened when the code was compiled with optimize. when the
   code was not compiled with optimize  other  garbage  values  were
   used  which by coincidence represented a pointer. since there was
   no reason to save the value of area_ptr the code was removed.

   80-09-16 Jim  Gray:  to  put  the  duplicate  processing  and set
   operation processing vfile storage  into  the  same  directory as
   the resultant model which may be  other  than the [pd],  due to a
   call to set_mrds_temp_dir.

   80-09-18 Jim  Gray:  to  correct  the  routine  build_data_string,
   the last assignment, where the true length is being set, to change
   cur_pos / 9 to (cur_pos - 1) /  9, so that one too many characters
   are not set as the length. this is due to the fact that cur_pos is
   a substr index, not an offset.

   80-09-23 Jim Gray: to  make sure that the per  call work area was
   cleaned up when the cleanup condition was invoked, not just after
   errors and normal exit. This required taking the temp file  clean
   up into a separate routine, so that the non "-another" case could
   do its  own cleanup without causing new temp segs to be generated.

   80-11-10 Jim Gray: to change dele_$path calls to hcs_$del_dir_tree
   and hcs_$delentry_file calls to improve performance.

   81-01-17 Jim Gray : made same changes as  made  to  mus_mod_ubtup
   for TR 8670, the variable involved in this case was tup_array.

   81-01-29  Gray : removed references to mdbm_data_$current_version
   using a constant instead to allow for future db version expansion.

   81-02-03 Jim Gray : changed calculation of the varying  attribute
   bit  length in the routine build_data_string in answer to TR 9041
   so that set operations would work correctly.  Also  made  comment
   about the problem with the set operation tuple not being the same
   format  as  temp  and  perm  rel  tuples,  which  was  fixed   in
   mrds_dsl_define_temp_rel instead.

   81-03-11 Jim Gray : changed setting of  select_list  pointer  for
   set  operations  so  that  -another  calls  would get the correct
   select list. See TR 9269.

   81-03-24 Jim Gray : added capability for selection expression  to
   be declared by caller to be char varying as well as just char.

   81-07-02  Roger  Lackey  :  to  fixed  the   place   where   call
   clean_up_per_call_area  was  called  so  that error exit does not
   call it twice.

   81-07-15 Roger Lackey : to add code to automatically turn on  the
   retain_dup  (like -dup argument in select exp) when the following
   conditions exists: 1) only a single tuple varaiable exists 2) all
   primary  key  attributes  are  selected  3)  only one "and" group
   exists

   81-07-25 Jim Gray : changed handling of no  and  group  case  for
   auto -dup, so that when no where clause exists, if only one tuple
   variable is specified, the -dup option can still be  forced  when
   all key attrs are selected.

   81-09-10   Jim   Gray   :   For   TR   11483,   changed   routine
   return_data_temp,  so  that  set  operations  referring to tuples
   having varying character strings  got  their  lengths  calculated
   properly.  It  previously  was not considering whether the length
   was in bits or chars.

   81-09-10 Davids: Moved the code that sets the value  of  num_ptrs
   to  before  any  reference  num_ptrs  is  made,  i.e.  before any
   reference to arg_des_ptr is made. This prevents a  subscriptrange
   condition.

   81-10-22 Davids: Have converted references of the form:
   .          ptr = addr (bit_array (large_offset))
   .	              to
   .          ptr = add_bit_offset (bit_array_ptr, large_offset - 1)
   This gets around a pl1 bug (tr11784) that causes the first method
   to  produce  the  wrong  value  when  the code is compiled with a
   subscriptrange condition. The "-1" is needed because  bit_array's
   first element is 1 not 0.

   82-06-17  R.   Harvey:  Modified dup_check to not concatenate key
   with  rest  of record when record is longer than 256 chars.  This
   gets  around  a  pl1  bug  (tr12672) and also makes the code more
   efficient.				 
					 
   82-07-21 D. Woodka : Modified to correct a bug  (tr phx12285)  so	 
   the  dup_check  procedure would  not  return  with icode ^= 0 and 
   dup_flag = ON. This caused  a loop  of code in move_db_to_file to
   execute one too many times and return an end_of_information error
   code.

   82-08-23 Mike Kubicar : Converted module to use the simple vector
   structure instead of the tuple structure.

   82-10-25 Davids: Minor changes to the build_data_string internal proc.
   move the assignment of the rai_ptr to the first thing in the
   select_list.num_items loop so that the definition order can be determined,
   it was being assigned after that point. Also changed the assignment into
   bit_str to just assign the whole tup_data value instead of taking a
   substr since the value now contains only the value of the attribute
   of interest.

   82-11-04 Davids: Yet another change to build_data_string. Corrected the
   compound statement executed for the case of
                 if old_vi ^= select_list.item.var_index (i)
   it incorrected included the assignment of the tuple_data pointer (td_ptr)
   which meant that value of the tuple_data changed only when the tuple
   variable index changed. This was screwing up the data stored to determine
   duplicates and resulted in non-duplicate data being identified as a duplicate.

   83-01-03 Davids: Modified the build_data_string internal proc to correctly
   build the data string, i.e. make sure that it starts out as a string of
   nulls and only move that part of the varying strings that contain data.

   83-01-06 Davids: Added code to handle transactions.

   83-01-11 Davids: Modified the declaration of tup_data in build_data_string
   to be actual_len instead of rm_attr_info.bit_length. This stops a 
   stringsize condition what was causing the unused bits of tup_data from
   being truncated during the assignment into the data_string.

   83-01-14 Davids: Added code to set mftxn_code = 0 if the code was really
   tuple_not_found - that is not an error so the transaction should commit.
   Also so that this module will return the error code returned by the
   transaction code if there is a problem finishing the transaction - that type
   of error is more important than a mrds error.

   83-01-24 Davids: modifed to set mstxn_id = "0"b as the first thing, so that
   it is set incase an error occurs in argument processing or getting the 
   database index.

   83-02-03 Roger Lackey : Removed the bit_str init from build_data_string and 
   replaced it with a substr to be used when necessary.

   83-04-11 Davids: replaced references to add_bit_offset with references to 
   addbitno.

   83-05-04 Davids: Modified so that mu_define_area is called with a name
   of MRDS || dbi_pic. This will allow closes to be faster since all
   temp_segments with the name MRDS || dbi_pic can be deleted/freed in 1 call.
   the variable dbi_pic was created as an easy way to convert from fixed bin
   to character.

   83-05-24 R. Harvey: Added code to support to re-retrieve a tuple when 
   -current specifies attributes that were not previously retrieved. Also fixed
   another occurrence of the bug TR 12672.

   83-05-31 Mike Kubicar : Updated relation manager calling sequences.

   83-06-08 Davids: Added the internal procedure build_vector_from_string
   and modified the set_tuple entry to call it so that the data returned
   is in the form of a vector instead of just a varying character string.

   83-06-20 Davids: Removed check for old version database and the call
   to v1 code if it was an old version db (old version dbs can no longer
   be opened)

   83-08-03 Harvey: Fixed TR phx15427 where duplicate suppression is not 
   performed on a submodel where no key attributes are present.

   83-08-22 Mike Kubicar : Removed the redundant bit fd.dup_keys_allowed.
   Duplicate suppression is done before this bit is checked.  It also caused
   an error with duplicate suppression of sets.

   83-10-03 Paul Benjamin: Added comments in repsonse to audit; became 10th
   person to modify the code.

   84-08-29 Thanh Nguyen & Roger Lackey: Fixed the subroutine 
   build_vector_from_string to advance the "current position" for the varying 
   character string as same as any other data type when building the simple 
   typed vector list. 

   84-12-19 Thanh Nguyen: Added code to continue to retrieve another tuple if
   the retrieved tuple from -another was deleted by another parallel running 
   process (error code = mrds_error_$inconsistent_data_length) in share mode.

   85-01-15 Thanh Nguyen:  Added code to create a special work area using 
   mu_define_area$define_spec_temp_dir_area.  For now, this work area is used
   by mu_retrieve and mu_get_data to "allocate" value_for_db and value_for_user
   thru function mrds_space_allocate and reinitialize the area thru subroutine
   mrds_area_initialize.

   85-01-25 Thanh Nguyen & John Hergert: Moved the code which was added at
   84-12-19 to get_next_tuple subroutine in mu_retrieve to improve performance.

   85-04-14 Thanh Nguyen: Added code to reject the transaction of a retrieve
   with "-another" and the tx id is not the same as the transaction of the 
   original select expression.  And also added code to return an warning error
   along with data when the scope was changed from non-shared mode to shared 
   mode.

   85-06-27 Thanh Nguyen : Modified code not to call to error in the case of 
   invalid dbi.  Also moved the reseting of dbcb.non_shared_to_shared flag
   from init subroutine of this module to mrds_dsl_optimize and 
   mrds_dsl_gen_srch_prog.

   86-02-18 Hergert: Fixed bug where invalid dbi caused linkage error
   to transaction_manager_. This is because mstxn_txn_id was uninitialized.
*/
%page;
/* INPUT CONDITIONS:

   database_index 		is the index of the database the caller wishes to retrieve.

   selection_expression 	is the expression supplied by the user to select the tuples to be retrieved.

   values  		are the retrieved tuple values or attribute values.
*/

/* OUTPUT DEFINITIONS:

   If no errors are encountered the retrieval was performed.

   code = 0;			    if no errors were detected.

   code = error_table_$bad_ptr;	    if the dbcbw_ptr could not be obtained.

   code = mrds_error_$tuple_not_found;      if a tuple selected was not found in the database.

   code = mrds_error_$invalid_db_index;     if no dbcb_ptr was found for the database index.

   If less then  4 arguments were passed to this procedure the
   condition arg_error will be signaled.

code = something else;		    if another error is detected by this module.
*/
%page;
	area_ptr, dbcb_ptr = null;
	mstxn_txn_id = "0"b;
	st_entry = "0"b;				/* remember retr. entry */
	call cu_$arg_list_ptr (al_ptr);		/* Get pointer to this proc arg list */
	if al_ptr = null then signal arg_error;		/* This returns you to command level */

	nargs = divide (arg_list.arg_count, 2, 17, 0);	/* Get the number of arguments to this proc */
	if nargs < 4 then signal arg_error;		/* This returns to command level */



	if arg_list.code = 4 then num_ptrs = arg_list.arg_count; /* Determine number of ptrs in arg list */
	else num_ptrs = arg_list.arg_count + 1;


	call cu_$arg_ptr (nargs, cd_ptr, arg_len, icode); /* Get  pointer to callers return code */
	if icode ^= 0 then signal arg_error;		/* This returns to command level */

	call cu_$arg_ptr (1, dbi_ptr, arg_len, icode);	/* Get pointer to database index */
	if icode ^= 0 then call error (icode);

	call cu_$arg_ptr (2, se_ptr, se_len, icode);	/* Get pointer to selection expression */
	if icode ^= 0 then call error (icode);


	if arg_list.code = 4 then
	     desc_ptr = arg_list.arg_des_ptr (nargs + 2);
	else desc_ptr = arg_list.arg_des_ptr (nargs + 3);

	if descriptor.type = 22 then do;
		se_len_ptr = addrel (se_ptr, -1);	/* get current length of varying string */
		se_len = se_len_ptr -> fb35u;
	     end;


	appl_ptr = addr (arg_list.arg_des_ptr (3));	/* Get pointer to the beginning  */
						/*   of the arg_ptr_list for translate */
						/* Now get pointer to beginning of descriptor */
						/*   pointer list for translate */
	if arg_list.code = 4 then adpl_ptr = addr (arg_list.arg_des_ptr (nargs + 3));
	else adpl_ptr = addr (arg_list.arg_des_ptr (nargs + 4));

	num_args = nargs - 3;			/* Number of args passed to translate */

	call mu_database_index$get_resultant_model_pointer (database_index, dbcb_ptr); /* Get the dbcb pointer */
	if dbcb_ptr = null then do;
	     code = mrds_error_$invalid_db_index;
	     return;
	end;

	call init;

	mstxn_transactions_needed = dbcb.transactions_needed;

	original_appl_ptr = appl_ptr;			/* static data needed in case transaction is rolled back */
	original_adpl_ptr = adpl_ptr;
	original_num_args = num_args;

	on cleanup begin;				/* Establish a cleanup handler */
		call mstxn_cleanup;
		call cleanup_handler;
	     end;
	on any_other call mstxn_any_other;		/* Establish an any_other handler */
%include mrds_start_transaction;

	if mstxn_code ^= 0
	then call error (mstxn_code);

	dbcb.user_started_transaction = user_started_transaction;
	dbi_pic = dbcb.dbi;
	call mu_define_area$define_temp_dir_area (dbcb.retrieve_area_ptr, database_index, (sys_info$max_seg_size), "MRDS" || dbi_pic,
	     "0"b /* not extensible */, "1"b /* no freeing */, "0"b, "0"b /* no zeroing */, icode);
	if icode ^= 0 then call error (icode);
	area_ptr = dbcb.retrieve_area_ptr;
						/* Create a work area for mu_retrieve to allocate the value_for_user and value_for_db. */
	call mu_define_area$define_spec_temp_dir_area (dbcb.work_area_ptr, database_index, "MRDS" || dbi_pic, icode);
	if icode ^= 0 then call error (icode);

	call mrds_dsl_translate (dbcb_ptr, area_ptr, mrds_data_$caller_retrieve,
	     se_ptr, se_len, appl_ptr, adpl_ptr, num_args, icode);
	if icode ^= 0 then call error (icode);
	if ^dbcb.val_rtrv then call error (mrds_error_$inval_rtrv_expr);

	if dbcb.another_flag = ON then do;
		if dbcb.se_transaction_id ^= "0"b
		then if dbcb.se_transaction_id ^= user_transaction_id
		     then if ^dbcb.data.dont_check_txn_id
		          then call error (mrds_error_$inconsistent_transaction_se);
	     end;
	else if dbcb.current_flag = OFF then do;	/* If this invocation is not because of */
		call clean_up_temp_files ();		/* -another cleanup the previous tuple area */
		retrieve_info.auto_dup_determined = "0"b; /* Not determined yet */

	     end;


	if dbcb.ss_ptr ^= null then do;		/* SET RETRIEVALS are handled special */
		ss_ptr = dbcb.ss_ptr;
		if ^dbcb.another_flag then call init_set;


		select_list_ptr = dbcb.select_ptr;


		call get_set_another;		/* Pass the tuple data to user */
	     end;					/* set retrieval */
%page;
	else do;					/* Non-set retrieval */
		call mrds_dsl_search (dbcb_ptr, area_ptr, icode); /* Search for a tuple */
		if icode ^= 0 then call error (icode);

		retrieve_info.retain_dup = dbcb.dup_retain; /* ON => we retain duplicates */

		ti_ptr = dbcb.ti_ptr;		/* Establish tuple_info pointer */
		range_ptr = dbcb.range_ptr;
		select_list_ptr = dbcb.select_ptr;


		if dbcb.another_flag = ON & retrieve_info.retain_dup = OFF then do;

/*  If not done yet determine if retain dup should automatically be turned on */



			if dbcb.pred_ptr = null then
			     number_of_and_groups = 0;/* check for 1 T.V. relation dump  */
			else number_of_and_groups = dbcb.pred_ptr -> pred_array.num_ands;


			if ^retrieve_info.auto_dup_determined &
			     number_of_and_groups < 2 &
			     range.num_vars = 1 then do; /* Only one tuple variable must exists */
				rmri_ptr = range.tup_var (1).ri_ptr;
				if select_list.num_items >= rm_rel_info.nkey_attr & rm_rel_info.nkey_attr > 0 then do; /* Got to have enough key attrs */
					key_used_len = rm_rel_info.nkey_attr;

					allocate key_used in (dbcb.static_area) set (key_used_ptr);
					key_used (*) = "0"b; /* Init to off */

					do i = 1 to select_list.num_items; /* See if we use all primary key attrs */
					     found = "0"b;

					     do j = 1 to key_used_len while (^found);
						if select_list.item (i).ai_ptr = rm_rel_info.key_attr_ptrs (j) then do;
							found = "1"b;
							key_used (j) = "1"b; /* Remember we used it */
						     end;
					     end;
					end;	/* END i = 1 to select_list.num_items */

					if index (string (key_used), "0"b) = 0 then dbcb.dup_retain, retrieve_info.retain_dup = "1"b;
					if key_used_ptr ^= null then free key_used;
				     end;
				retrieve_info.auto_dup_determined = "1"b; /* Rember we determined it already */
			     end;			/* END if range.num_vars = 1 */

			if ^retrieve_info.retain_dup then call another; /* If selection expression was -another and
						   we are not retaining duplicates then call the another proc */

		     end;



		else if dbcb.current_flag = OFF & retrieve_info.retain_dup = OFF then do;
			call build_data_string (static_data);
						/* Otherwise save the data for possible future use by -another */
			retrieve_info.unique_count = 1;

		     end;
		else if dbcb.current_flag = ON then
		     select_list_ptr = dbcb.current_ptr;	/* get select list for -current */

		call return_data_tup;
		num_tuples_retrieved = num_tuples_retrieved + 1;

	     end;

	if num_tuples_retrieved = 0 then /* If none were retrieved return an error */
	     call error (mrds_error_$tuple_not_found);

	else if dbcb.another_flag = ON & dbcb.non_shared_to_shared then
	     code = mrds_error_$incomp_se_and_scope;
	else code = 0;				/* Return with no errors */



	call clean_up_per_call_area ();

exit:

	if code = mrds_error_$tuple_not_found | /* tuple not found is not really */
	     code = mrds_error_$incomp_se_and_scope	/* This is just the warning, we allow to return data. */
	then mftxn_code = 0;			/* an error so we don't want transaction to abort */
	else mftxn_code = code;

%include mrds_finish_transaction;

	if mftxn_code ^= 0				/* problems finishing the transaction are more important */
	then code = mftxn_code;			/* than any error mrds could produce on its own */

	return;					/* Return to caller with some code */

should_rollback:
     proc () returns (bit (1));

/* This module requests no rollbacks. */

	return ("0"b);

     end should_rollback;

restore_significant_data: proc;

	appl_ptr = original_appl_ptr;
	adpl_ptr = original_adpl_ptr;
	num_args = original_num_args;

	call clean_up_per_call_area ();

     end restore_significant_data;
%page;
set_tuple: entry (a_dbcb_ptr, a_area_ptr, data_ptr, a_code);

/* ENtry to retrieve a tuple for define temp rel given a set selection expr. */

	dcl     (a_dbcb_ptr,
	        a_area_ptr,
	        data_ptr)		 ptr;
	dcl     a_code		 fixed bin (35);

	area_ptr = a_area_ptr;
	dbcb_ptr = a_dbcb_ptr;
	st_entry = "1"b;
	call init;
	ss_ptr = dbcb.ss_ptr;
	if ^dbcb.another_flag then do;		/* if first time */
		call init_set;
	     end;
	call get_temp_record (set_info.cur_fdx, current_data, icode); /* get next tuple */
	if icode = error_table_$end_of_info then icode = mrds_error_$tuple_not_found;
	if icode ^= 0 then call error (icode);
	num_tuples_retrieved = num_tuples_retrieved + 1;
	set_info.cur_data_valid = "0"b;
	call build_vector_from_string (addr (current_data), data_ptr);
	a_code = 0;

st_exit:
	return;
%page;
add_record: proc (fdx, data);				/* Adds a data item to a temp-file */
						/* Duplicates are retained according to the attach description */
	dcl     data		 char (*) varying;
	dcl     fdx		 fixed bin;
	dcl     key_only		 bit (1);

	key_only = (length (data) <= 256);
	fd_ptr = retrieve_info.ret_fd_ptr (fdx);	/* Set the file desc pointer */

	if key_only = ON then do;
		call iox_$seek_key (fd.iocb_ptr, (data), rec_len, icode);
		if icode ^= error_table_$no_record then if icode ^= 0 then call error (icode);
		fd.rec_buf = "";
		fd.cur_key = data;
		fd.rec_len = 0;
	     end;
	else do;
		call iox_$seek_key (fd.iocb_ptr, (substr (data, 1, 256)), rec_len, icode);
		if icode ^= error_table_$no_record then if icode ^= 0 then call error (icode);
		fd.cur_key = substr (data, 1, 256);
		fd.rec_buf = substr (data, 257);
		fd.rec_len = length (data) - 256;
	     end;

	if (icode = error_table_$no_record) | (icode = 0) then do;
		call iox_$write_record (fd.iocb_ptr, addr (fd.rec_buf), fd.rec_len, icode);
		fd.rec_count = fd.rec_count + 1;
	     end;
	else call error (icode);

     end add_record;
%page;
another: proc;

/* This internal procedure handles the case where the selection expression is "-another".
   It checks for duplicate data from prievious calls to a retrieve with -another.

   This procedure returns to its calling procedure only when a unique data group has been found otherwise the
   error procedure is called.
*/

	dcl     fdx		 fixed bin internal static;

	dup_flag = ON;				/* Set duplicate record indicator on to start with */

	do while (dup_flag = ON);
	     call build_data_string (current_data);

	     if retrieve_info.unique_count = 1 then do;
		     if current_data ^= static_data then do; /* If the current data is
						   different then the first data acquired form
						   retrieve then do */
						/* Create a new duplicate data file */
			     call create_temp_file (fdx);
			     call add_record (fdx, static_data); /* Add the first data rec */
						/*   add_record set the dup_flag */
			     call add_record (fdx, current_data); /* Add the second data record */
			     retrieve_info.unique_count = 2; /* The number of unique records = 2 */
			     dup_flag = OFF;	/* Turn it off cause we don't have any now */
			end;
						/* If current_data = record then it is a duplicate
						   and dup_flag is left on */
		end;

	     else do;				/* This is for unique count greater then or equal  2 */
		     dup_flag = OFF;
		     if retrieve_info.retain_dup = OFF then /* We are retaining duplicates */
			call dup_check (fdx, current_data, dup_flag); /* This sets the dup_flag */
		     if dup_flag = OFF then do;
			     call add_record (fdx, current_data);
			     retrieve_info.unique_count = retrieve_info.unique_count + 1; /* If no
						   duplicates were found the
						   record was added to duplicate file
						   so add one to the unique data count */
			end;
		end;				/* Else the record was a duplicate and dup_flag is still on */

	     if dup_flag = ON then call mrds_dsl_search (dbcb_ptr, area_ptr, icode); /* See if ANOTHER record exists */
	     if icode ^= 0 then call error (icode);

	end;					/* END of do while (dup_flag = ON */

	return;					/* Return to calling proc */
     end another;
%page;
build_data_string: proc (data_str);

/* Procedure to build a character string from the selected attributes. */

	dcl     bit_str		 bit (9 * maxlength (data_str)) based (bs_ptr);
	dcl     data_str		 char (*) var;
	dcl     (bs_ptr,
	        td_ptr)		 ptr;
	dcl     tup_data		 bit (actual_len) based (td_ptr);
	dcl     (cur_pos,
	        old_vi,
	        j,
	        i)		 fixed bin (35);
	dcl     length_word_overlay	 fixed bin (35) unaligned based;
	dcl     actual_len		 fixed bin (35);	/* actual amount of bits of data in tup_data */

	cur_pos = 1;				/* initialize */

	bs_ptr = addrel (addr (data_str), 1);		/* point to data portion of string */
	old_vi = 0;

	do i = 1 to select_list.num_items;		/* look at every selected attribute */

	     rai_ptr = select_list.item.ai_ptr (i);	/* get info pointers */

	     if old_vi ^= select_list.item.var_index (i) then do; /* if must initialize */
		     old_vi = select_list.item.var_index (i); /* set for next time */
		     rmri_ptr = range.tup_var.ri_ptr (select_list.item.var_index (i));

		     do j = 1 to tuple_info.num_tuples while (tuple_info.tuple.var_index (j) ^= old_vi);
		     end;				/* locate tuple ptr */
		     simple_typed_vector_ptr
			= tuple_info.tuple.tuple_ptr (j);
		end;				/* tuple initialization */
	     td_ptr = simple_typed_vector.
		dimension (rm_attr_info.defn_order).value_ptr;

	     if mu_data_class$varying (addr (rm_attr_info.domain_ptr -> rm_domain_info.db_desc))
	     then do;
		     if mu_data_class$bit (addr (rm_attr_info.domain_ptr -> rm_domain_info.db_desc))
		     then actual_len = td_ptr -> length_word_overlay + 36; /* + 36 for length word */
		     else actual_len = td_ptr -> length_word_overlay * 9 + 36; /* char count * 9 for bit count */
		end;
	     else actual_len = rm_attr_info.bit_length;	/* set up for fixed length */

	     substr (bit_str, cur_pos, actual_len) = tup_data; /* move the value */
	     if actual_len < rm_attr_info.bit_length then
		substr (bit_str, cur_pos + actual_len, rm_attr_info.bit_length - actual_len) = "0"b;
	     cur_pos = cur_pos + rm_attr_info.bit_length;
	     if cur_pos > length (bit_str) then call error (mrds_error_$max_retr_len);

	end;					/* concatenation loop */

	addr (data_str) -> fb35u = ceil ((cur_pos - 1) / 9); /* set true length */

     end build_data_string;
%page;
build_vector_from_string: proc (bvfs_data_ptr, bvfs_simple_typed_vector_ptr);

/*
   This procedur takes a varying bit string containing data and converts it
   to a simple vector containing data.
*/

/* PARAMETERS */

	dcl     bvfs_data_ptr	 ptr;		/* (input) pointer to a varying char string containing data */
	dcl     bvfs_simple_typed_vector_ptr ptr;	/* (input) pointer to a vector, the data will be output */


/* AUTOMATIC */

	dcl     cur_pos		 fixed bin (35);	/* position of first bit of the next attr value */
	dcl     old_vi		 fixed bin (35);	/* var_index of the last attr looked at */
	dcl     i			 fixed bin (35);	/* loop counter */
	dcl     bit_string_len	 fixed bin (35);	/* number of bits in data string */
	dcl     bit_string_ptr	 ptr;		/* pointer to data bits */

/* BASED */

	dcl     bit_array		 (bit_string_len) bit (1) unal based (bit_string_ptr);
						/* bit string of data to be converted to vector */
	dcl     length_word_overlay	 fixed bin (35) unal based;




	bit_string_len = bvfs_data_ptr -> length_word_overlay * 9;
	bit_string_ptr = addrel (bvfs_data_ptr, 1);

	select_list_ptr = dbcb.select_ptr;

	cur_pos = 1;
	old_vi = 0;

	bvfs_simple_typed_vector_ptr ->
	     simple_typed_vector.number_of_dimensions = select_list.num_items;

	do i = 1 to select_list.num_items;
	     if cur_pos > bit_string_len
	     then call error (mrds_error_$max_retr_len);

	     if old_vi ^= select_list.item.var_index (i)
	     then old_vi = select_list.item.var_index (i);

	     rai_ptr = select_list.item.ai_ptr (i);

	     bvfs_simple_typed_vector_ptr ->
		simple_typed_vector.dimension (i).value_ptr = addr (bit_array (cur_pos));

	     cur_pos = cur_pos + rm_attr_info.bit_length;
	end;

	return;

     end build_vector_from_string;
%page;
create_temp_file: proc (x);				/* Creates a temp-file and its file desctor block */

/*  	PARAMETER	*/

	dcl     x			 fixed bin;	/* (OUTPUT) retrieve_info.ret_fd_ptr table index */


/*	MULTICS	*/


	dcl     unique_chars_	 entry (bit (*)) returns (char (15));

/*	OTHERS	*/

	dcl     atd		 char (200);
	dcl     KEYED_SEQ_UPDATE	 fixed bin internal static options (constant) init (10);
	dcl     number		 picture "99";


	x = 0;					/* Init */

	do i = 1 to mrds_data_$max_sets while (x = 0);	/* Find first null pointer in table */
	     if retrieve_info.ret_fd_ptr (i) = null then x = i;
	end;
	if x = 0 then call error (mrds_error_$too_many_temp_files);

	allocate fd in (dbcb.static_area) set (fd_ptr);
	retrieve_info.ret_fd_ptr (x) = fd_ptr;		/* Save the file descriptor pointer */

	number = x;				/* Make the number a picture */

	fd.name = unique_chars_ ("0"b) || ".mrds_temp." || number; /* Generate a unique file name */

	atd = "vfile_ " || rtrim (get_resultant_dir ()) || ">" || fd.name || "-dup_ok"; /* develop attach descriptor */

	call iox_$attach_ioname ((fd.name), fd.iocb_ptr, atd, icode);
	if icode = 0 then
	     call iox_$open (fd.iocb_ptr, KEYED_SEQ_UPDATE, "0"b, icode);
	if icode ^= 0 then call error (icode);


	fd.cur_key = low (256);
	fd.desc = 0;
	fd.rec_count = 0;

     end create_temp_file;
%page;
delete_temp_file: proc (x);				/* Deletes a single temp-file */

	dcl     x			 fixed bin;	/* (INPUT) retrieve_info.ret_fd_ptr index */

	dcl     file_name		 char (32);


	if retrieve_info.ret_fd_ptr (x) ^= null then do;
		fd_ptr = retrieve_info.ret_fd_ptr (x);	/* Set the pointer to the file descriptor */
		file_name = fd.name;

		call iox_$close (fd.iocb_ptr, icode);
		if icode = 0 then call iox_$detach_iocb (fd.iocb_ptr, icode);
		if icode = 0 then call iox_$destroy_iocb (fd.iocb_ptr, icode);
		if icode = 0 then
		     begin;

			call hcs_$del_dir_tree (get_resultant_dir (), file_name, icode);
			if icode = error_table_$notadir | icode = 0 then
			     call hcs_$delentry_file (get_resultant_dir (), file_name, icode);

			declare hcs_$del_dir_tree	 entry (char (*), char (*), fixed bin (35)); /* deletes sub directory contents */
			declare hcs_$delentry_file	 entry (char (*), char (*), fixed bin (35)); /* deletes segs and empty dirs */
			declare error_table_$notadir	 fixed bin (35) ext; /* entry was not a directory */

		     end;

		if icode ^= 0 & ^clean_up_condition then call error (icode);
		free fd in (dbcb.static_area);	/* Deallocate this file descriptor */
		retrieve_info.ret_fd_ptr (x) = null;
	     end;
     end delete_temp_file;
%page;
get_resultant_dir: procedure () returns (char (168));

/* routine to get the resultant models storage directory */

	declare pathname		 char (168);	/* directory under which resultant model is stored */
	declare mrds_dsl_resultant_storage$get_opening_temp_dir entry (fixed bin (35), fixed bin (35))
				 returns (char (168)); /* gets temp dir for a particular opening */

/* good index, get a pathname from the dbcb segment pointer */

	pathname = mrds_dsl_resultant_storage$get_opening_temp_dir (dbcb.dbi, icode);
	if icode ^= 0 then
	     call error (icode);			/* does not return */

/* 				The dbcb segment pointer could not be expanded into a pathname. */

	else return (pathname);			/* good path of model dir found */

     end;
%page;
delete_temp_record: proc (fdx, data);

	dcl     fdx		 fixed bin;	/* (INPUT) File desc index into retrieve_info.ret_fd_ptr array */
	dcl     data		 char (*) varying;	/* (INPUT) */
	dcl     (new_key, rec_found)	 bit (1);

	fd_ptr = retrieve_info.ret_fd_ptr (fdx);	/* Set the file desc pointer */

	if length (data) <= 256 then do;		/* All data resides in key */
		call iox_$seek_key (fd.iocb_ptr, (data), rec_len, icode);
		if icode = 0 then
		     call iox_$delete_record (fd.iocb_ptr, icode);
	     end;

	else do;					/* All data does _n_o_t reside in the key */
		new_key, rec_found = OFF;		/* Init */

		call iox_$seek_key (fd.iocb_ptr, substr (data, 1, 256), rec_len, icode);
		do while (icode = 0 & new_key = OFF & rec_found = OFF);
		     call iox_$read_key (fd.iocb_ptr, fd.cur_key, fd.rec_len, icode);
		     if fd.cur_key ^= substr (data, 1, 256) then
			new_key = ON;
		     if icode = 0 & new_key = OFF then do;
			     call iox_$read_record (fd.iocb_ptr, addr (fd.rec_buf), length (fd.rec_buf), fd.rec_len, icode);
			     if icode = 0 then
				if substr (data, 257) = substr (fd.rec_buf, 1, rec_len) then
				     rec_found = ON;
			end;
		end;
		if icode = 0 then do;
			if rec_found = ON then
			     call iox_$delete_record (fd.iocb_ptr, icode);
			else icode = error_table_$no_record;
		     end;
	     end;
	if icode ^= 0 then call error (icode);

     end delete_temp_record;
%page;
difference: proc;					/* SET DIFFERENCE operation */

	set_info.cur_data_valid = OFF;		/* not valid while being changed */

	if sb (set_info.sbi - 1).file = OFF then do;	/* If it's not in a file, put it in one */
		call create_temp_file (sb (set_info.sbi - 1).fdx);
		call move_db_to_file (set_info.sbi - 1, sb (set_info.sbi - 1).ss_item_num, sb (set_info.sbi - 1).fdx);
		sb (set_info.sbi - 1).file = ON;	/* it's in a file now */
	     end;

	fd_ptr = retrieve_info.ret_fd_ptr (sb (set_info.sbi - 1).fdx); /* So we use the right file desc */
	call iox_$position (fd.iocb_ptr, -1, 0, icode);	/* Position to BOF to read it seq  */

	set_info.cur_fdx = sb (set_info.sbi - 1).fdx;	/* This is where the difference
						   between these two will reside */

	call init_search (set_info.sbi);

	call get_data (set_info.sbi, current_data, icode);

	do while (icode = 0);			/* Do the difference */

	     if icode = 0 then do;			/* If we got the data then see if a match
						   is found from the previous selected data */
		     call dup_check (sb (set_info.sbi - 1).fdx, current_data, dup_flag);
		     if dup_flag = ON then do;	/* If so this is an difference so delete it  */
			     call delete_temp_record (set_info.cur_fdx, current_data); /* Remove it
						   from temp file */
			end;
		     dbcb.another_flag = ON;		/* For mrds_dsl_search in get_data */
		end;

	     call get_data (set_info.sbi, current_data, icode);


	end;

	if icode ^= error_table_$end_of_info then call error (icode);
	else icode = 0;

	if sb (set_info.sbi).file then call delete_temp_file (sb (set_info.sbi).fdx); /* Delete the temp file
						   no longer needed */
	set_info.sbi = set_info.sbi - 1;		/* Set up for next set operation */
	sb (set_info.sbi).fdx = set_info.cur_fdx;	/* This becomes that set block file desc index */



     end difference;
%page;
dup_check: proc (fdx, data, dup_flag);

	dcl     fdx		 fixed bin;	/* (INPUT) File desc index into retrieve_info.ret_fd_ptr array */
	dcl     data		 char (*) varying;	/* (INPUT) */
	dcl     dup_flag		 bit (1);		/* (OUTPUT) ON = duplicate record found */
	dcl     new_key		 bit (1);

	fd_ptr = retrieve_info.ret_fd_ptr (fdx);	/* Set the file desc pointer */
	dup_flag = OFF;				/* Set OFF to start with */

	if length (data) <= 256 then do;		/* All data resides in key */
		call iox_$seek_key (fd.iocb_ptr, (data), rec_len, icode);
		if icode = 0 then
		     dup_flag = ON;
	     end;

	else do;					/* All data does _n_o_t reside in the key */
		new_key = OFF;			/* Init */

		call iox_$seek_key (fd.iocb_ptr, substr (data, 1, 256), rec_len, icode);
		if icode ^= 0 then if icode ^= error_table_$no_record then call error (icode);
		do while (icode = 0 & new_key = OFF & dup_flag = OFF);
		     call iox_$read_key (fd.iocb_ptr, fd.cur_key, fd.rec_len, icode);
		     if fd.cur_key ^= substr (data, 1, 256) then
			new_key = ON;
		     if icode = 0 & new_key = OFF then do;
			     call iox_$read_record (fd.iocb_ptr, addr (fd.rec_buf), length (fd.rec_buf), fd.rec_len, icode);
			     if icode = 0 then
				if substr (data, 257) = substr (fd.rec_buf, 1, rec_len) then
				     dup_flag = ON;
			end;
		end;

	     end;

     end dup_check;
%page;

get_data: proc (sbi, current_data, icode);

/* This procedure gets the next data record from either the database or a temp-file
   for the set block specified by set block index (sbi)

   when the data is to be retrieve from the database the calling procedure
   must have called init_search prior to the first call to get_data
   so that mrds_dsl_search will get subsequent tuples for
   the selection expression		*/


	dcl     sbi		 fixed bin;	/* (INPUT) Set block index */
	dcl     current_data	 char (*) varying;	/* (OUTPUT) data returned */
	dcl     icode		 fixed bin (35);	/* (OUTPUT) Error code */

	if sb (sbi).file = ON then do;		/* Data is from a file */
		call get_temp_record (sb (sbi).fdx, current_data, icode);
		if icode ^= 0 then if icode ^= error_table_$end_of_info then call error (icode);
	     end;
	else do;					/* Data is from the database */
		call mrds_dsl_search (dbcb_ptr, area_ptr, icode);
		if icode = 0 then
		     call build_data_string (current_data);
		else do;
			if icode ^= mrds_error_$tuple_not_found then call error (icode);
			else icode = error_table_$end_of_info;
		     end;
	     end;

     end get_data;
%page;
get_set_another: proc;				/* Retrieve set another operation */

	call get_temp_record (set_info.cur_fdx, current_data, icode); /* Get next record from
						   temp file */

	if icode = 0 then /* If there is one move it to user's variables */
	     call return_data_temp (current_data);
	else if icode = error_table_$end_of_info then /* Convert this to mrds_error */
	     icode = mrds_error_$tuple_not_found;

	if icode ^= 0 then call error (icode);

	num_tuples_retrieved = num_tuples_retrieved + 1;

	set_info.cur_data_valid = ON;			/* It's valid now */

     end get_set_another;
%page;
get_temp_record: proc (fdx, current_data, icode);		/* Gets a single record from a temp-file */

	dcl     fdx		 fixed bin;	/* (INPUT) File descriptor index into
						   retrieve_info.ret_fd_ptr array */
	dcl     current_data	 char (*) varying;	/* (OUTPUT) Char string of key||data record */
	dcl     icode		 fixed bin (35);	/* (OUTPUT) Error code */

	fd_ptr = retrieve_info.ret_fd_ptr (fdx);	/* Set the file desc pointer */
	set_info.cur_data_valid = OFF;


	call iox_$read_key (fd.iocb_ptr, fd.cur_key, fd.rec_len, icode);

	if icode = 0 then do;
		if fd.rec_len > 0 then /* If there is any data in record read the record */
		     call iox_$read_record (fd.iocb_ptr, addr (fd.rec_buf), mrds_data_$max_data_length,
			fd.rec_len, icode);
		else do;				/* Otherwise position to next rec as read_record would */
			call iox_$position (fd.iocb_ptr, 0, 1, icode);
			if icode = error_table_$end_of_info then icode = 0; /* We'l catch this on next call */
		     end;
	     end;

	if icode = 0 then do;
		current_data = fd.cur_key || substr (fd.rec_buf, 1, fd.rec_len); /* Key + any data */
		set_info.cur_data_valid = ON;		/* It's valid now */
	     end;



     end get_temp_record;
%page;
init: proc;

/* initialization procedure */

	num_tuples_retrieved, icode = 0;		/* Init  to start with */
	key_used_ptr = null;

	if dbcb.retr_info_ptr = null then do;
		allocate retrieve_info in (dbcb.static_area) set (dbcb.retr_info_ptr);
		retrieve_info.version = retrieve_info_version;
		do i = 1 to mrds_data_$max_sets;
		     retrieve_info.ret_fd_ptr (i) = null;
		end;
	     end;

     end init;
%page;
init_search: proc (sbi);				/* Initializes mrds_dsl_search fo a new selection esbipression */

	dcl     x			 fixed bin;
	dcl     sbi		 fixed bin;	/* select block index */

	if sb.file (sbi) = ON
	then do;
		fd_ptr = retrieve_info.ret_fd_ptr (sb.fdx (sbi));
		call iox_$position (fd.iocb_ptr, -1, 0, icode); /* point to beginning */
		if icode ^= 0 then call error (icode);
	     end;

	else do;
		x = sb.ss_item_num (sbi);
		range_ptr,
		     dbcb.range_ptr = select_sets.items (x).range_ptr;
		dbcb.so_ptr = select_sets.items (x).so_ptr;
		ti_ptr,
		     dbcb.ti_ptr = select_sets.items (x).ti_ptr;
		select_list_ptr,
		     dbcb.select_ptr = select_sets.items (x).select_ptr;
		dbcb.another_flag, dbcb.current_flag = OFF; /* So dsl_search will initialixe */
	     end;

     end init_search;
%page;
init_set: proc;

/* Procedure to build a set of data */

	if select_sets.dup_retain then call error (mrds_error_$no_dups_for_set_oper);
	do i = 1 to mrds_data_$max_sets;		/* free any file descriptors that may be allocated */
	     if retrieve_info.ret_fd_ptr (i) ^= null then /* Delete temp file and */
		call delete_temp_file (i);		/* Null the dbdb.ret_fd_ptr (i) */
	end;

	retrieve_info.first_sw = ON;			/* So setup_set will initialize */

	call setup_set_info;

	do while (set_info.last_sb_oper = OFF);
						/* 1 => union 2 => intersection  3 =>Difference */
	     goto case (set_info.oper);

case (1):	     call union;
	     goto case_out;

case (2):	     call intersection;
	     goto case_out;

case (3):	     call difference;
	     goto case_out;

case_out:
	     call setup_set_info;			/* Setup next set operation */
	end;

	goto kase (set_info.oper);

kase (1): call union;
	goto kase_out;

kase (2): call intersection;
	goto kase_out;

kase (3): call difference;
	goto kase_out;

kase_out:

	fd_ptr = retrieve_info.ret_fd_ptr (set_info.cur_fdx);
	call iox_$position (fd.iocb_ptr, -1, 0, icode);	/* Rewind the file */

     end init_set;
%page;
intersection: proc;					/* INTERSECTION SET operation */

	set_info.cur_data_valid = OFF;		/* Cause were gona change it */

	if sb (set_info.sbi - 1).file = OFF then do;	/* If its not inafile put in one */
		call create_temp_file (sb (set_info.sbi - 1).fdx);
		call move_db_to_file (set_info.sbi - 1, sb (set_info.sbi - 1).ss_item_num, sb (set_info.sbi - 1).fdx);
		sb (set_info.sbi - 1).file = ON;	/* Got it on a file now */
	     end;

	fd_ptr = retrieve_info.ret_fd_ptr (sb (set_info.sbi - 1).fdx); /* So we use the right file desc */
	call iox_$position (fd.iocb_ptr, -1, 0, icode);	/* Position to BOF cause were gonna read it seq  */

	call create_temp_file (set_info.cur_fdx);	/* Tempfile
						   for intersection */
	call init_search (set_info.sbi);

	call get_data (set_info.sbi, current_data, icode);

	do while (icode = 0);			/* Do the intersection */

	     if icode = 0 then do;			/* If we got the data then see if a match
						   is found from the previous selected data */
		     call dup_check (sb (set_info.sbi - 1).fdx, current_data, dup_flag);
		     if dup_flag = ON then do;	/* If so this is an intersection so save it  */
			     call dup_check (set_info.cur_fdx, current_data, dup_flag); /* see if there is
						   already one on the file */
			     if ^dup_flag then call add_record (set_info.cur_fdx, current_data);
			end;
		     dbcb.another_flag = ON;		/* For mrds_dsl_search in get_data */
		end;

	     call get_data (set_info.sbi, current_data, icode);

	end;

	if icode ^= error_table_$end_of_info then call error (icode);
	else icode = 0;

	if sb (set_info.sbi).file then call delete_temp_file (sb (set_info.sbi).fdx); /* Delete the temp file
						   no longer needed */
	set_info.sbi = set_info.sbi - 1;		/* Set up for next set operation */

	sb (set_info.sbi).fdx = set_info.cur_fdx;	/* This becomes that set block file desc index */



     end intersection;
%page;
move_db_to_file: proc (sbi, is, fdx);			/* Adds data selected to a temp-file */

	dcl     is		 fixed bin;	/* (INPUT) Select sets item index */
	dcl     fdx		 fixed bin;	/* (INPUT) File desc index into retrieve_info.ret_fd_ptr array */
	dcl     sbi		 fixed bin;	/* INPUT: select block index used by init_search */


	call init_search (sbi);			/* Init pointers for mrds_dsl_search */

	icode = 0;

	do while (icode = 0);			/* Get all the tuples that satisfy the selection exp */

	     call mrds_dsl_search (dbcb_ptr, area_ptr, icode);

	     if icode = 0 then do;			/* If we found one get it from db  */

		     call build_data_string (current_data);
		     if icode = 0 then do;
			     call dup_check (fdx, current_data, dup_flag);
			     if dup_flag = OFF then call add_record (fdx, current_data);
			end;
		     dbcb.another_flag = ON;		/* So search will continue searching */

		end;
	end;

	if icode ^= 0 then if icode ^= mrds_error_$tuple_not_found then call error (icode);

     end move_db_to_file;
%page;
move_file_to_file: proc (from_fdx, to_fdx);

/* Moves data from a temp-file to a temp-file handling duplicates */

	dcl     (from_fdx,				/* (INPUT) file descriptor index
						   into retrieve_info.ret_fd_ptr array */
	        to_fdx)		 fixed bin;	/* (INPUT) File des index into retrieve_info.ret_fd_ptr array */


	fd_ptr = retrieve_info.ret_fd_ptr (from_fdx);

	call iox_$position (fd.iocb_ptr, -1, 0, icode);	/* Rewind the file */

	if icode ^= 0 then call error (icode);

	do while (icode = 0);			/* As long as there are records on input file */

	     call get_temp_record (from_fdx, current_data, icode); /* Get rec from file */

	     if icode = 0 then do;
		     call dup_check (to_fdx, current_data, dup_flag);
		     if dup_flag = OFF then call add_record (to_fdx, current_data);
		end;
	end;

	if icode ^= 0 then if icode ^= error_table_$end_of_info then call error (icode);

     end move_file_to_file;
%page;
return_data_temp: proc (data_str);

/* Procedure to return data to the caller from a temporary hold file. */

	dcl     bs_ptr		 ptr;
	dcl     data_str		 char (*) var;
	dcl     (cur_pos,
	        len,
	        i)		 fixed bin (35);

	cur_pos = 1;				/* initialize */
	bs_ptr = addr (data_str);
	bs_ptr = addrel (bs_ptr, 1);

START_RETURN_DATA_TEMP:

	do i = 1 to select_list.num_items;		/* for each selected attribute */

	     rai_ptr = select_list.item.ai_ptr (i);	/* point to attr info */

	     len = rm_attr_info.bit_length;

	     call mu_get_data$get_data_item (rai_ptr, dbcb.work_area_ptr,
		addbitno (bs_ptr, cur_pos - 1),
		select_list.item.user_ptr (i),
		select_list.item.user_desc_ptr (i), icode);
	     if icode ^= 0 then
		if icode = error_table_$noalloc then
		     go to START_RETURN_DATA_TEMP;
		else call error (icode);

	     cur_pos = cur_pos + len;			/* tidy up */

	end;					/* select item loop */

     end return_data_temp;
%page;
return_data_tup: proc;

/* Procedure to return data to the caller from the tuples retrieved. */

BEGIN_RETURN_DATA_TUP:

	do i = 1 to select_list.num_vars;		/* loop for each selected item */
	     var_index = move_list_array.var_index (i);
	     do j = 1 to tuple_info.num_tuples while (tuple_info.tuple.var_index (j) ^= var_index);
	     end;
	     icode = 0;
	     if range.tup_var (var_index).copy_for_current
	     then do;
		     rmri_ptr = range.tup_var (var_index).ri_ptr;
		     call mu_cursor_manager_$get (dbcb.dbi, rmri_ptr, (0), rm_rel_info.rel_id,
			dbcb.relmgr_entries.create_cursor, dbcb.relmgr_entries.open,
			dbcb.cursor_ptrs_storage_ptr, dbcb.cursor_storage_area_ptr,
			cursor_ptr, icode);
		     if icode ^= 0 then call error (icode);
		     call dbcb.relmgr_entries.get_tuple_by_id (
			cursor_ptr,
			tuple_info.tuple (var_index).tuple_id,
			rm_rel_info.id_list_ptr, dbcb.select_area_ptr,
			tuple_info.tuple (var_index).tuple_ptr,
			icode);
		     if icode ^= 0 then call error (icode);
		     range.tup_var (var_index).copy_for_current = "0"b;
		     range.tup_var (var_index).copied_for_current = "1"b;
		end;				/* copy for current */
	     call mu_get_data$get_data (range.tup_var.ri_ptr (move_list_array.var_index (i)), dbcb.work_area_ptr,
		tuple_info.tuple.tuple_ptr (j), move_list_array.ml_ptr (i), icode);
	     if icode ^= 0 then
		if icode ^= error_table_$noalloc
		then call error (icode);
		else go to BEGIN_RETURN_DATA_TUP;
	end;					/* loop for each item */


	dcl     icode		 fixed bin (35);
	dcl     cursor_ptr		 ptr;
	dcl     (i, j)		 fixed bin;
	dcl     var_index		 fixed bin;

     end return_data_tup;
%page;
setup_set_info: proc;				/* Prepares set_info and set blocks for next set operation */

	dcl     ix		 fixed bin;



	if retrieve_info.first_sw = ON then do;		/* First time this proc has been called for this set selection */

		set_info.cur_fdx = 0;
		set_info.ssi = 0;
		set_info.sbi = 0;
		set_info.cur_data_valid = OFF;
		retrieve_info.first_sw = OFF;
		set_info.last_sb_oper = OFF;
	     end;


	do while (select_sets.items (set_info.ssi + 1).oper_flag = OFF);
	     set_info.ssi = set_info.ssi + 1;
	     ix, set_info.sbi = set_info.sbi + 1;

	     sb (ix).ss_item_num = set_info.ssi;
	     sb (ix).fdx = 0;
	     sb (ix).file = OFF;
	     sb (ix).eod = OFF;
	     sb (ix).first = ON;
	end;

	set_info.ssi = set_info.ssi + 1;
	set_info.oper = select_sets.items (set_info.ssi).op_code;
	if set_info.ssi + 1 > select_sets.nitems then
	     set_info.last_sb_oper = ON;

     end setup_set_info;
%page;
union: proc;					/* UNION set operation */

	set_info.cur_data_valid = OFF;		/* It isgona change */

	if sb (set_info.sbi - 1).file = ON then do;	/* Previous set block is a file so use it */
		set_info.cur_fdx = sb (set_info.sbi - 1).fdx;
		if sb (set_info.sbi).file = ON then /* Current set block is a file so add it to previous */
		     call move_file_to_file (sb (set_info.sbi).fdx, set_info.cur_fdx); /*   set block file */

		else /* Add the selected tuples from db to previous sb file */
		     call move_db_to_file (set_info.sbi, sb (set_info.sbi).ss_item_num, set_info.cur_fdx);
	     end;

	else do;					/* Previous set block was not a file */
		if sb (set_info.sbi).file = ON then do; /* Current sb is a file */
			set_info.cur_fdx = sb (set_info.sbi).fdx;
			call move_db_to_file (set_info.sbi - 1, sb (set_info.sbi - 1).ss_item_num, set_info.cur_fdx);
		     end;

		else do;				/* Neither previous sb or current sb is a file */
			call create_temp_file (set_info.cur_fdx);
			call move_db_to_file (set_info.sbi, sb (set_info.sbi).ss_item_num, set_info.cur_fdx);
			call move_db_to_file (set_info.sbi - 1, sb (set_info.sbi - 1).ss_item_num, set_info.cur_fdx);
		     end;

		sb (set_info.sbi - 1).fdx = set_info.cur_fdx; /* Stash the fdx */
		sb (set_info.sbi - 1).file = ON;	/* Indicate that the file exists */
	     end;

	set_info.sbi = set_info.sbi - 1;		/* Keep track of where we are */


     end union;
%page;

error: proc (cd);

	dcl     cd		 fixed bin (35);	/* (INPUT) error code */

	if st_entry then do;
		a_code = cd;
		goto st_exit;
	     end;
	else do;
		code = cd;			/* Return the error code to caller */
		call cleanup_handler;		/* Tidy up before we leave */
		goto exit;			/* Exit mrds_dsl_sec_retrieve */
	     end;

     end error;
%page;
cleanup_handler: proc;

	clean_up_condition = ON;			/* to avoid loops */

	on seg_fault_error goto get_out;

	call clean_up_temp_files ();

	call clean_up_per_call_area ();

get_out:
	clean_up_condition = OFF;

	return;

     end cleanup_handler;
%page;
clean_up_per_call_area: procedure ();

/* routine to capture philosophy for "releasing" per call work area */

	if dbcb_ptr = null () then ;
	else if dbcb.retrieve_area_ptr ^= null () then do;
		call mu_release_area (dbcb.retrieve_area_ptr);

/* do not null area pointers, this would cause getting new temp segs, instead of reuse */

	     end;

     end;
%page;
clean_up_temp_files: procedure ();

/* routine to get rid of all temp files */

	if dbcb_ptr ^= null then do;
		if dbcb.retr_info_ptr ^= null then do;
			do i = 1 to mrds_data_$max_sets; /* free any file descriptors that may be allocated */
			     if retrieve_info.ret_fd_ptr (i) ^= null then /* Delete temp file and */
				call delete_temp_file (i); /* Null the dbdb.ret_fd_ptr (i) */
			end;
		     end;
	     end;

     end;
%page;
%page;
%include mrds_dbcb;
%page;
%include mdbm_rm_rel_info;
%page;
%include mdbm_rm_attr_info;
%page;
%include mdbm_rm_domain_info;
%page;
%include mrds_range;
%page;
%include mrds_select_list;
%page;
%include mrds_tuple_info;
%page;
%include mdbm_arg_list;
%page;
%include mrds_select_sets;
%page;
%include mrds_retrieve_info;
%page;
%include mrds_fd;
%page;
%include mdbm_descriptor;
%page;
%include mrds_predicate_tree;
%page;
%include vu_typed_vector;
%page;

	dcl     current_data	 char (4 * sys_info$max_seg_size - 4) varying based (dbcb.current_data_ptr);
	dcl     static_data		 char (4 * sys_info$max_seg_size - 4) varying based (dbcb.static_data_ptr);

	dcl     1 set_info		 aligned internal static,
		2 oper		 fixed bin,	/* Set operation being performed */
		2 ssi		 fixed bin,	/* Current select_sets index */
		2 sbi		 fixed bin,	/* Current selct_block index */
		2 cur_fdx		 fixed bin,	/* Current file desc index into retrieve_info.ret_fd_ptr array */
		2 cur_data_valid	 bit (1) unaligned, /* ON => data in variable current_data is valid */
		2 last_sb_oper	 bit (1) unaligned, /* ON => this is last set block */
		2 reserved	 bit (34) unaligned;/* Reserved for future use */



	dcl     1 sb		 (20) aligned internal static, /* Set block */
		2 ss_item_num	 fixed bin,	/* Index into select_sets table */
		2 fdx		 fixed bin,	/* File desc index into dbdb.ret_fd_ptr array */
		2 file		 bit (1) unaligned, /* ON => this set_block is a file */
		2 eod		 bit (1) unaligned, /* ON => end of data for this set_block */
		2 first		 bit (1) unaligned, /* ON => this first reference to this set_block */
		2 reserved	 bit (33) unaligned;/* Reserved for future use */
						/* Multics Subroutines */

	dcl     cu_$arg_list_ptr	 entry (ptr);
	dcl     cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin, fixed bin (35));
	dcl     error_table_$end_of_info ext fixed bin (35);
	dcl     error_table_$no_record ext fixed bin (35);
	dcl     error_table_$noalloc	 ext fixed bin (35);
	dcl     iox_$attach_ioname	 entry (char (*), ptr, char (*), fixed bin (35));
	dcl     iox_$close		 entry (ptr, fixed bin (35));
	dcl     iox_$delete_record	 entry (ptr, fixed bin (35));
	dcl     iox_$open		 entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
	dcl     iox_$position	 entry (ptr, fixed bin, fixed bin (21), fixed bin (35));
	dcl     iox_$read_key	 entry (ptr, char (256) varying, fixed bin (21), fixed bin (35));
	dcl     iox_$read_record	 entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
	dcl     iox_$seek_key	 entry (ptr, char (256) varying, fixed bin (21), fixed bin (35));
	dcl     iox_$write_record	 entry (ptr, ptr, fixed bin (21), fixed bin (35));
	dcl     (iox_$detach_iocb, iox_$destroy_iocb) entry (ptr, fixed bin (35));

	dcl     sys_info$max_seg_size	 ext fixed bin (35);

/*   DBM Routines */

	dcl     mrds_data_$caller_retrieve fixed bin (17) ext;
	dcl     mrds_data_$max_attributes fixed bin (35) ext static;
	dcl     mrds_data_$max_data_length fixed bin (21) ext;
	dcl     mrds_data_$max_id_len	 fixed bin (35) ext;
	dcl     mrds_data_$max_select_items ext fixed bin;
	dcl     mrds_data_$max_sets	 ext fixed bin;
	dcl     mrds_dsl_search	 entry (ptr, ptr, fixed bin (35));
	dcl     mrds_dsl_translate	 entry (ptr, ptr, fixed bin, ptr, fixed bin, ptr, ptr, fixed bin, fixed bin (35));
	dcl     mrds_error_$incomp_se_and_scope ext fixed bin (35);
	dcl     mrds_error_$inconsistent_transaction_se ext fixed bin (35);
	dcl     mrds_error_$invalid_db_index ext fixed bin (35);
	dcl     mrds_error_$inval_rtrv_expr ext fixed bin (35);
	dcl     mrds_error_$max_retr_len ext fixed bin (35);
	dcl     mrds_error_$no_dups_for_set_oper ext fixed bin (35);
	dcl     mrds_error_$too_many_temp_files ext fixed bin (35);
	dcl     mrds_error_$tuple_not_found ext fixed bin (35);
	dcl     mu_database_index$get_resultant_model_pointer entry (fixed bin (35), ptr);
	dcl     mu_get_data$get_data	 entry (ptr, ptr, ptr, ptr, fixed bin (35));
	dcl     mu_get_data$get_data_item entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35));
	dcl     mu_data_class$varying	 entry (ptr) returns (bit (1) aligned);
	dcl     mu_data_class$bit	 entry (ptr) returns (bit (1) aligned);

/*  OTHERS  */

	dcl     (se_ptr,				/* pointer to selection expr. */
	        cd_ptr,				/* pointer to status code */
	        dbi_ptr,				/* ptr to db index */
	        appl_ptr,				/* pointer to args for translate */
	        adpl_ptr)		 ptr;		/* pointer to descs for translate */

	dcl     fb35u		 fixed bin (35) unal based;

	dcl     icode		 fixed bin (35);	/* Internal error code */

	dcl     code		 fixed bin (35) based (cd_ptr); /* Output: status code */
	dcl     database_index	 fixed bin (35) based (dbi_ptr); /* input: db index */
	dcl     rec_len		 fixed bin (21);

	dcl     (nargs,				/* num args passed in */
	        se_len,				/* length of selection expr. */
	        arg_len,				/* length of an arg */
	        number_of_and_groups,			/* Number of and groups in a slection exp */
	        num_args,				/* num args for translate */
	        num_tuples_retrieved)	 fixed bin;	/* Count of tuples found on this call to secure_retrieve */
	dcl     i			 fixed bin;

	dcl     (null,
	        addr,
	        ceil,
	        addbitno,
	        addrel,
	        substr,
	        length,
	        low,
	        maxlength,
	        index,
	        rtrim,
	        divide,
	        fixed,
	        rel,
	        string)		 builtin;

	dcl     (cleanup, any_other, arg_error) condition;

	dcl     dup_flag		 bit (1);		/* Duplicate record indicator */
	dcl     st_entry		 bit (1);		/* to remember which entry used */
	dcl     original_appl_ptr	 ptr;		/* copy of original value of appl_ptr incase of rollback */
	dcl     original_adpl_ptr	 ptr;		/* copy of original value of adpl_ptr incase of rollback */
	dcl     original_num_args	 fixed bin;	/* copy of original value of num_args incase of rollback */

/* STATIC VARIABLES */

	dcl     OFF		 bit (1) init ("0"b) internal static options (constant);
	dcl     ON		 bit (1) init ("1"b) internal static options (constant);
	declare clean_up_condition	 bit (1) init ("0"b); /* on => clean up proc called */
	declare seg_fault_error	 condition;
	declare mu_release_area	 entry (ptr);
	declare area_ptr		 ptr;
	dcl     mu_cursor_manager_$get entry (fixed bin (35), ptr, fixed bin (35), bit (36) aligned, entry, entry, ptr, ptr,
				 ptr, fixed bin (35));
	declare mu_define_area$define_temp_dir_area entry (ptr, fixed bin (35), fixed bin (18), char (11), bit (1) aligned,
				 bit (1) aligned, bit (1) aligned, bit (1) aligned, fixed bin (35));
	dcl     mu_define_area$define_spec_temp_dir_area entry (ptr, fixed bin (35), char (11), fixed bin (35));
	declare se_len_ptr		 ptr;		/* temp for getting varying se length */
	dcl     found		 bit (1);
	dcl     j			 fixed bin;
	dcl     key_used		 (key_used_len) bit (1) based (key_used_ptr);
	dcl     key_used_len	 fixed bin;
	dcl     key_used_ptr	 ptr;
	dcl     dbi_pic		 picture "999";

     end mrds_dsl_retrieve;
