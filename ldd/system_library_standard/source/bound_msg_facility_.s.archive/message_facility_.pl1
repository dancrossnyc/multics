/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        *                                                         *
        *********************************************************** */

/* This subroutine is the heart of the Multics message facility. */
/* This replaces the Multics message facility written 12/01/75 by
   Steve Herbst. */


/****^  HISTORY COMMENTS:
  1) change(84-05-10,Lippard), approve(), audit(), install():
      Written by Jim Lippard.
  2) change(84-11-16,Lippard), approve(), audit(), install():
      Modified to prevent messages received from getting message numbers
      lower than those already in the mailbox.
  3) change(84-11-27,Lippard), approve(), audit(), install():
      Modified to fix the last fix correctly, to only print "You have N
      messages" in the alarm handler when a call string is NOT being used,
      and to make alarms work.
  4) change(84-12-18,Lippard), approve(), audit(), install():
      Modified to make message_facility_$send_message do something reasonable
      with error_table_$no_info.
  5) change(85-01-11,Lippard), approve(), audit(), install():
      Modified to make entry points take a message_id instead of an array
      index to prevent internal message arrays and applications' arrays from
      getting out of synch.
  6) change(85-01-23,Lippard), approve(), audit(), install():
      Modified to fix code calling mlr_.
  7) change(85-01-30,Lippard), approve(), audit(), install():
      Modified to speed up message selection by using a binary search.
  8) change(85-03-26,Lippard), approve(), audit(), install():
      Modified to speed up create_message_array and compact_message_array.
  9) change(85-04-16,Lippard), approve(), audit(), install():
      Modified to properly set the last message number when a new message is
      received.
 10) change(85-05-31,Lippard), approve(85-11-18,MCR7298),
     audit(86-01-10,Spitzer), install(86-01-20,MR12.0-1006):
      Modified to initialize everything in the msg_facility_mailbox structure
      before any possible aborting/freeing takes place.
 11) change(85-09-02,Lippard), approve(85-11-18,MCR7298),
     audit(86-01-10,Spitzer), install(86-01-20,MR12.0-1006):
      Modified to only send acknowledgements when the user has d permission
      on the mailbox.
 12) change(86-04-23,Lippard), approve(86-05-27,MCR7418),
     audit(86-06-24,Hartogs), install(86-06-30,MR12.0-1080):
      Modified to make get_msg_array_ptr only call create_message_array when
      necessary.
 13) change(86-06-04,Lippard), approve(86-06-24,MCR7432),
     audit(86-06-24,Hartogs), install(86-06-30,MR12.0-1080):
      Modified to properly zero fields in mail_format when sending messages.
 14) change(86-06-05,Lippard), approve(86-06-24,MCR7437),
     audit(86-06-24,Hartogs), install(86-06-30,MR12.0-1080):
      Modified to correctly figure out when to use mailbox_$own_xxx entries.
 15) change(86-08-06,Lippard), approve(87-03-18,MECR0001),
     audit(87-03-12,Fawcett), install(87-03-19,MR12.1-1002):
      Modified to check for unseen messages in wakeup processor.
 16) change(87-01-29,Lippard), approve(87-03-18,MECR0001),
     audit(87-03-12,Fawcett), install(87-03-19,MR12.1-1002):
      Modified to strip control characters from message comment field.
 17) change(87-05-08,Lippard), approve(87-04-20,MCR7669),
     audit(87-05-11,Fawcett), install(88-05-04,MR12.2-1045):
      Formal installation to close out MECR0001 and to use the permanent
      seen switches in the mailbox when access allows.
 18) change(88-03-31,Lippard), approve(88-04-18,MCR7876),
     audit(88-04-26,Parisek), install(88-05-04,MR12.2-1045):
      Changed wakeup_processor to (a) stop setting P_code, which is not
      a parameter to that procedure and (b) check for error_table_$seg_unknown
      from mailbox_$get_mode_index.  Also changed calls to ioa_$rsnnl to
      use the returned length correctly.
                                                   END HISTORY COMMENTS */

message_facility_: procedure options (variable);
	return;					/* not an entry */

	dcl     (P_msgf_mbx_ptr, P_next_msgf_mbx_ptr) ptr parm;
	dcl     (P_dname, P_ename, P_message) char (*) parm;
	dcl     P_access_class	 bit (72) aligned;
	dcl     P_default_mbx	 bit (1) aligned parm;
	dcl     P_flags		 bit (*) parm;
	dcl     P_message_id	 bit (72) aligned parm;
	dcl     P_prefix		 char (32) varying parm;
	dcl     (P_short_prefix, P_short_format) bit (1) aligned parm;
	dcl     P_handler		 entry variable parm;
	dcl     P_info_ptr		 ptr parm;
	dcl     P_time		 fixed bin (71) parm;
	dcl     P_area_ptr		 ptr;
	dcl     P_msg_array_ptr	 ptr parm;
	dcl     P_n_messages	 fixed bin parm;
	dcl     P_iocb_ptr		 ptr;
	dcl     P_code		 fixed bin (35) parm;

	dcl     access_class	 bit (1) aligned;
	dcl     access_mode		 bit (36) aligned;
	dcl     allow_switch	 bit (36) aligned;
	dcl     array_length	 fixed bin (21);
	dcl     authorization	 bit (72) aligned;
	dcl     auth_string		 char (170);
	dcl     call_string		 char (512) based (P_info_ptr);
	dcl     change_state	 bit (1) aligned;
	dcl     command_line	 char (2000);
	dcl     count		 fixed bin;
	dcl     current_message_index	 fixed bin;
	dcl     d_permission	 bit (1) aligned;
	dcl     default_dname	 char (168);
	dcl     default_ename	 char (32);
	dcl     default_uid		 bit (36) aligned;
	dcl     destination_string	 char (array_length) based (destination_string_ptr);
	dcl     destination_string_ptr ptr;
	dcl     dname		 char (168);
	dcl     ename		 char (32);
	dcl     wakeup_flags	 bit (5) aligned;
	dcl     full_name		 char (32) internal static init ("");
	dcl     hold_this_message	 bit (1) aligned;
	dcl     hold_this_notification bit (1) aligned;
	dcl     iocb_ptr		 ptr;
	dcl     last_index		 fixed bin;
	dcl     last_message_set	 bit (1) aligned;
	dcl     last_msg_time	 char (24) internal static init ("");
	dcl     last_sender		 char (120) internal static init ("");
	dcl     last_time		 fixed bin (71) internal static init (0);
	dcl     mbx_index		 fixed bin;
	dcl     message		 char (47);
	dcl     message_bit_count	 fixed bin;
	dcl     message_id		 bit (72) aligned;
	dcl     message_ident	 char (200) varying;
	dcl     message_index	 fixed bin;
	dcl     message_sender	 char (120);
	dcl     own		 bit (1) aligned;
	dcl     person		 char (22) internal static init ("");
	dcl     project		 char (9) internal static init ("");
	dcl     person_id		 char (22);
	dcl     project_id		 char (9);
	dcl     login_name		 char (32);
	dcl     seen_switch_flags	 bit (3) aligned;
	dcl     short		 bit (1) aligned;
	dcl     source_string	 char (array_length) based (source_string_ptr);
	dcl     source_string_ptr	 ptr;
	dcl     tag		 char (10) var;
	dcl     uid		 bit (36) aligned;
	dcl     use_call_string	 bit (1) aligned;

	dcl     date_time		 fixed bin (71);
	dcl     msg_date_time	 char (24);
	dcl     current_date_time	 char (24);

	dcl     freed_msgf_mbx_ptr	 ptr;
	dcl     next_msgf_mbx_ptr	 ptr;
	dcl     static_msgf_mbx_ptr	 ptr internal static init (null ());

	dcl     area_ptr		 ptr static init (null ());
	dcl     sys_area		 area (65560) based (area_ptr);
	dcl     user_area_ptr	 ptr;
	dcl     user_area		 area based (user_area_ptr);

	dcl     1 internal_msg_array	 (msg_facility_mailbox.n_elements) aligned based (msg_facility_mailbox.messages_ptr) like msg_array;

	dcl     1 local_lmi		 aligned like last_message_info;

	dcl     1 local_mi		 aligned like message_info;

	dcl     1 local_mra		 aligned like mseg_return_args;

	dcl     1 local_pf		 unaligned like msg_print_flags based (local_pf_ptr);
	dcl     local_pf_ptr	 ptr;

	dcl     1 local_smi		 aligned like send_mail_info based (local_smi_ptr);
	dcl     local_smi_ptr	 ptr;

	dcl     new_message_number	 fixed bin;

	dcl     found		 bit (1) aligned;
	dcl     retried		 bit (1) aligned;

	dcl     (idx, jdx)		 fixed bin;

	dcl     code		 fixed bin (35);

	dcl     aim_check_$greater_or_equal entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned) reducible;

	dcl     error_table_$bad_segment fixed bin (35) ext static;
	dcl     error_table_$bad_subr_arg fixed bin (35) ext static;
	dcl     error_table_$messages_off fixed bin (35) ext static;
	dcl     error_table_$noentry	 fixed bin (35) ext static;
	dcl     error_table_$no_info	 fixed bin (35) ext static;
	dcl     error_table_$no_message fixed bin (35) ext static;
	dcl     error_table_$rqover	 fixed bin (35) ext static;
	dcl     error_table_$seg_unknown fixed bin (35) ext static;
	dcl     error_table_$unimplemented_version fixed bin (35) ext static;

	dcl     (addr, after, before, clock, collate, divide, fixed, index, length, max, min, null, rel, rtrim, size, string, substr,
	        translate, unspec)	 builtin;

	dcl     (cleanup, record_quota_overflow) condition;

	dcl     canonicalize_	 entry (ptr, fixed bin (21), ptr, fixed bin (21), fixed bin (35));

	dcl     convert_access_class_$to_string_short entry (bit (72) aligned, char (*), fixed bin (35));

	dcl     cu_$cp		 entry (ptr, fixed bin (21), fixed bin (35));

	dcl     date_time_		 entry (fixed bin (71), char (*));
	dcl     date_time_$format	 entry (char (*), fixed bin (71), char (*), char (*)) returns (char (250) var);

	dcl     get_authorization_	 entry () returns (bit (72) aligned) reducible;

	dcl     get_system_free_area_	 entry () returns (ptr);


	dcl     ioa_$ioa_switch	 entry options (variable);
	dcl     ioa_$ioa_switch_nnl	 entry options (variable);
	dcl     ioa_$rsnnl		 entry options (variable);

	dcl     iox_$control	 entry (ptr, char (*), ptr, fixed bin (35));
	dcl     iox_$user_io	 ptr ext static;

	dcl     ipc_$create_ev_chn	 entry (fixed bin (71), fixed bin (35));
	dcl     ipc_$decl_ev_call_chn	 entry (fixed bin (71), entry, ptr, fixed bin, fixed bin (35));
	dcl     ipc_$delete_ev_chn	 entry (fixed bin (71), fixed bin (35));

	dcl     mailbox_$accept_wakeups_index entry (fixed bin, fixed bin (71), bit (36) aligned, fixed bin (35));
	dcl     mailbox_$close	 entry (fixed bin, fixed bin (35));
	dcl     mailbox_$delete_index	 entry (fixed bin, bit (72) aligned, fixed bin (35));
	dcl     mailbox_$get_mode_index entry (fixed bin, bit (36) aligned, fixed bin (35));
	dcl     mailbox_$get_uid_file	 entry (char (*), char (*), bit (36) aligned, fixed bin (35));
	dcl     mailbox_$incremental_read_index entry (fixed bin, ptr, bit (2) aligned, bit (72) aligned, ptr,
				 fixed bin (35));
	dcl     mailbox_$open	 entry (char (*), char (*), fixed bin, fixed bin (35));
	dcl     mailbox_$own_incremental_read_index entry (fixed bin, ptr, bit (2) aligned, bit (72) aligned, ptr,
				 fixed bin (35));
	dcl     mailbox_$own_read_index entry (fixed bin, ptr, bit (1) aligned, ptr, fixed bin (35));
	dcl     mailbox_$read_index	 entry (fixed bin, ptr, bit (1) aligned, ptr, fixed bin (35));
	dcl     mailbox_$update_message_index entry (fixed bin, fixed bin, bit (72) aligned, ptr, fixed bin (35));
	dcl     mailbox_$wakeup_add_index entry (fixed bin, ptr, fixed bin, bit (36) aligned, bit (72) aligned,
				 fixed bin (35));
	dcl     mailbox_$wakeup_aim_add_index entry (fixed bin, ptr, fixed bin, bit (36) aligned, bit (72) aligned,
				 bit (72) aligned, fixed bin (35));

	dcl     message_facility_$alarm_processor entry (ptr);
	dcl     message_facility_$wakeup_processor entry (ptr);
	dcl     message_facility_$default_alarm_handler entry (ptr, ptr);
	dcl     message_facility_$default_wakeup_handler entry (ptr, ptr);
	dcl     message_facility_$delete_message entry (ptr, bit (72) aligned, fixed bin (35));
	dcl     message_facility_$free_msgf_mbx_ptr entry (ptr, fixed bin (35));
	dcl     message_facility_$get_last_message_info entry (ptr, ptr, fixed bin (35));
	dcl     message_facility_$print_message entry (ptr, ptr, bit (72) aligned, ptr, fixed bin (35));
	dcl     message_facility_$read_message entry (ptr, bit (72) aligned, ptr, ptr, fixed bin (35));
	dcl     message_facility_$send_message entry (char (*), char (*), char (*), ptr, fixed bin (35));
	dcl     message_facility_$set_seen_switch entry (ptr, bit (72) aligned, bit (*), fixed bin (35));

	dcl     mrl_		 entry (ptr, fixed bin (21), ptr, fixed bin (21));

	dcl     pathname_		 entry (char (*), char (*)) returns (char (168));

	dcl     requote_string_	 entry (char (*)) returns (char (*));

	dcl     sub_err_		 entry options (variable);

	dcl     timer_manager_$alarm_wakeup entry (fixed bin (71), bit (2), fixed bin (71));
	dcl     timer_manager_$reset_alarm_wakeup entry (fixed bin (71));

	dcl     user_info_$whoami	 entry (char (*), char (*), char (*));

	dcl     value_$get		 entry () options (variable);

	dcl     TRUE		 bit (1) aligned internal static options (constant) init ("1"b);
	dcl     FALSE		 bit (1) aligned internal static options (constant) init ("0"b);
	dcl     ALPHABET		 char (256) init ((8)" " || "	" || (4)" " || "" || (16)" "
				 || substr (collate (), 33)); /* space, BSHT, space, RRSBRS, space, alphanumerics */
	dcl     FIVE_MINUTES	 fixed bin (71) internal static options (constant) init (300000000);
	dcl     MSG_ARRAY_BLOCK_SIZE	 fixed bin internal static options (constant) init (100);
	dcl     MSG_ARRAY_ELEMENT_LENGTH fixed bin internal static options (constant) init (16); /* four words, sixteen characters */
	dcl     NL		 char (1) aligned internal static options (constant) init ("
");
	dcl     NLSPHT		 char (3) aligned internal static options (constant) init ("
	");
	dcl     BS		 char (1) aligned internal static options (constant) init ("");
	dcl     PERMANENT_VALUES	 bit (36) aligned internal static options (constant) init ("200000000000"b3);
	dcl     READ_CURRENT	 bit (2) aligned internal static options (constant) init ("00"b);
	dcl     READ_FIRST		 bit (1) aligned internal static options (constant) init ("0"b);
	dcl     READ_FORWARD	 bit (2) aligned internal static options (constant) init ("01"b);
	dcl     RELATIVE_SECONDS	 bit (2) internal static options (constant) init ("11"b);

/* This entry returns the next msg facility mailbox pointer in the chain. */
get_next_msgf_mbx_ptr: entry (P_msgf_mbx_ptr, P_next_msgf_mbx_ptr);
	msg_facility_mailbox_ptr = P_msgf_mbx_ptr;
	P_next_msgf_mbx_ptr = null ();

	if msg_facility_mailbox_ptr = null () then next_msgf_mbx_ptr = static_msgf_mbx_ptr;
	else next_msgf_mbx_ptr = msg_facility_mailbox.next_mbx_ptr;

	code = 1;
	do while (code ^= 0);
	     msg_facility_mailbox_ptr = next_msgf_mbx_ptr;
	     code = 0;
	     if msg_facility_mailbox_ptr ^= null () then do; /* see if it's there and we have access */
		     call mailbox_$open ((msg_facility_mailbox.dname), (msg_facility_mailbox.ename),
			msg_facility_mailbox.index, code);
		     if code ^= 0 then do;
			     call message_facility_$free_msgf_mbx_ptr (msg_facility_mailbox_ptr, (0));
			     if P_msgf_mbx_ptr = null () then next_msgf_mbx_ptr = static_msgf_mbx_ptr;
			     else next_msgf_mbx_ptr = P_msgf_mbx_ptr -> msg_facility_mailbox.next_mbx_ptr;
			end;
		end;
	end;

	P_next_msgf_mbx_ptr = next_msgf_mbx_ptr;
	return;					/* get_next_msgf_mbx_ptr */

/* This entry returns a msg facility mailbox pointer for the specified mailbox. */
get_msgf_mbx_ptr: entry (P_dname, P_ename, P_msgf_mbx_ptr, P_code);
	dname = P_dname;
	ename = P_ename;
	P_msgf_mbx_ptr = null ();
	P_code = 0;

	call mailbox_$get_uid_file (dname, ename, uid, code);

	if code ^= 0 then do;
		P_code = code;
		return;
	     end;

	msg_facility_mailbox_ptr = static_msgf_mbx_ptr;
	found = FALSE;
	do while ((msg_facility_mailbox_ptr ^= null ()) & ^found);
	     if msg_facility_mailbox.uid = uid then found = TRUE;
	     else msg_facility_mailbox_ptr = msg_facility_mailbox.next_mbx_ptr;
	end;

	if ^found then do;
						/* add a new one, at the beginning of the list */
		if area_ptr = null () then area_ptr = get_system_free_area_ ();
		allocate msg_facility_mailbox set (msg_facility_mailbox_ptr) in (sys_area);
		msg_facility_mailbox.next_mbx_ptr = static_msgf_mbx_ptr;
		static_msgf_mbx_ptr = msg_facility_mailbox_ptr;

/* initialize the structure */
		msg_facility_mailbox.version = MSG_FACILITY_MAILBOX_VERSION_1;
		msg_facility_mailbox.dname = dname;
		msg_facility_mailbox.ename = ename;
		msg_facility_mailbox.uid = uid;
		call user_info_$whoami (person, project, "");
		default_dname = ">udd>" || rtrim (project) || ">" || rtrim (person);
		default_ename = rtrim (person) || ".mbx";
		call mailbox_$get_uid_file (default_dname, default_ename, default_uid, (0));
		if uid = default_uid then msg_facility_mailbox.default_mbx = TRUE;
		else msg_facility_mailbox.default_mbx = FALSE;
		msg_facility_mailbox.event_channel = 0;

		string (msg_facility_mailbox.wakeup_flags) = ""b;
		msg_facility_mailbox.mbz = ""b;
		msg_facility_mailbox.short_format = FALSE;
		msg_facility_mailbox.prefix = "";
		msg_facility_mailbox.short_prefix = FALSE;
		msg_facility_mailbox.alarm_time = 0;
		msg_facility_mailbox.alarm_event_channel = 0;
		msg_facility_mailbox.last_message_ptr = null ();
		msg_facility_mailbox.last_id = ""b;
		msg_facility_mailbox.last_message_number = 0;
		msg_facility_mailbox.highest_message = 0;
		msg_facility_mailbox.messages_ptr = null ();
		msg_facility_mailbox.n_elements = 0;
		msg_facility_mailbox.n_messages = 0;
		msg_facility_mailbox.msg_array_compacted = TRUE;
		msg_facility_mailbox.msg_array_updated = FALSE;
		msg_facility_mailbox.wakeup_handler = message_facility_$default_wakeup_handler;
		msg_facility_mailbox.wakeup_info_ptr = null ();
		msg_facility_mailbox.alarm_handler = message_facility_$default_alarm_handler;
		msg_facility_mailbox.alarm_info_ptr = null ();

/* We do this last so that everything is initialized properly in case we have
   to free the structure. */
		call mailbox_$open (dname, ename, msg_facility_mailbox.index, code);

		if code ^= 0 then do;
			P_code = code;
			return;
		     end;

	     end;

	else do;					/* see if mailbox is still there */
		call mailbox_$open ((msg_facility_mailbox.dname), (msg_facility_mailbox.ename),
		     msg_facility_mailbox.index, code);

		if code ^= 0 then do;
			P_code = code;
			call message_facility_$free_msgf_mbx_ptr (msg_facility_mailbox_ptr, (0));
			return;
		     end;
	     end;

	P_msgf_mbx_ptr = msg_facility_mailbox_ptr;
	return;					/* get_msgf_mbx_ptr */

/* This entry makes a mailbox unknown to the message facility. */
free_msgf_mbx_ptr: entry (P_msgf_mbx_ptr, P_code);
	P_code = 0;
	msg_facility_mailbox_ptr = P_msgf_mbx_ptr;

	if msg_facility_mailbox.version ^= MSG_FACILITY_MAILBOX_VERSION_1 then do;
		P_code = error_table_$unimplemented_version;
		return;
	     end;

	call mailbox_$close (msg_facility_mailbox.index, (0));

	freed_msgf_mbx_ptr = msg_facility_mailbox_ptr;
	msg_facility_mailbox_ptr = static_msgf_mbx_ptr;

	if P_msgf_mbx_ptr = static_msgf_mbx_ptr then do;	/* free first mailbox in list */
		msg_facility_mailbox_ptr = static_msgf_mbx_ptr;
		static_msgf_mbx_ptr = msg_facility_mailbox.next_mbx_ptr;
	     end;

	else do;

/* set msg_facility_mailbox_ptr to point to mbx in list just BEFORE the one we're freeing */
		found = FALSE;
		do msg_facility_mailbox_ptr = static_msgf_mbx_ptr
		     repeat (msg_facility_mailbox.next_mbx_ptr)
		     while (msg_facility_mailbox.next_mbx_ptr ^= null ()
		     & ^found);
		     if msg_facility_mailbox.next_mbx_ptr = freed_msgf_mbx_ptr then found = TRUE;
		end;

		if msg_facility_mailbox.next_mbx_ptr = null () then do; /* this msgf structure isn't in our list! */
			P_code = error_table_$unimplemented_version;
			return;
		     end;
	     end;

	P_msgf_mbx_ptr = null ();
	msg_facility_mailbox.next_mbx_ptr = freed_msgf_mbx_ptr -> msg_facility_mailbox.next_mbx_ptr;

	msg_facility_mailbox_ptr = freed_msgf_mbx_ptr;

/* reset alarm wakeups */
	if msg_facility_mailbox.alarm_time > 0 then call
		timer_manager_$reset_alarm_wakeup (msg_facility_mailbox.alarm_event_channel);

/* delete event channels */
	if msg_facility_mailbox.alarm_event_channel ^= 0 then
	     call ipc_$delete_ev_chn (msg_facility_mailbox.alarm_event_channel, (0));
	if msg_facility_mailbox.event_channel ^= 0 then call ipc_$delete_ev_chn (msg_facility_mailbox.event_channel, (0));

/* free last message mail format structure */
	if msg_facility_mailbox.last_message_ptr ^= null () then do;
		message_info_ptr = msg_facility_mailbox.last_message_ptr;
		if message_info.message_ptr ^= null () then free message_info.message_ptr -> mail_format in (sys_area);
		free message_info in (sys_area);
	     end;

/* free message array */
	if msg_facility_mailbox.messages_ptr ^= null () then free internal_msg_array in (sys_area);

	free msg_facility_mailbox in (sys_area);
	return;					/* free_msgf_mbx_ptr */

/* This entry returns the wakeup state for the specified mailbox. */
get_wakeup_state: entry (P_msgf_mbx_ptr, P_flags, P_code);
	P_flags = ""b;
	P_code = 0;
	msg_facility_mailbox_ptr = P_msgf_mbx_ptr;

	if msg_facility_mailbox.version ^= MSG_FACILITY_MAILBOX_VERSION_1 then do;
		P_code = error_table_$unimplemented_version;
		return;
	     end;

	P_flags = substr (string (msg_facility_mailbox.wakeup_flags), 1, 5);
	return;					/* get_wakeup_state */

/* This entry sets the wakeup state for the specified mailbox. */
set_wakeup_state: entry (P_msgf_mbx_ptr, P_flags, P_code);
	P_code = 0;
	msg_facility_mailbox_ptr = P_msgf_mbx_ptr;
	wakeup_flags = P_flags;
	if msg_facility_mailbox.version ^= MSG_FACILITY_MAILBOX_VERSION_1 then do;
		P_code = error_table_$unimplemented_version;
		return;
	     end;

	if substr (wakeup_flags, 4, 2) = "00"b | substr (wakeup_flags, 4, 2) = "11"b then do;
						/* can't currently "unaccept" messages, 11 is undefined */
		P_code = error_table_$bad_subr_arg;
		return;
	     end;

	if msg_facility_mailbox.event_channel = 0 then do;
		call ipc_$create_ev_chn (msg_facility_mailbox.event_channel, code);

		if code ^= 0 then do;
			P_code = code;
			return;
		     end;

		call ipc_$decl_ev_call_chn (msg_facility_mailbox.event_channel, message_facility_$wakeup_processor,
		     msg_facility_mailbox_ptr, (1), code);

		if code ^= 0 then do;
			P_code = code;
			return;
		     end;
	     end;

	if wakeup_flags ^= string (msg_facility_mailbox.wakeup_flags) then
	     change_state = TRUE;

	string (msg_facility_mailbox.wakeup_flags) = wakeup_flags;

	substr (allow_switch, 1, 1) = substr (msg_facility_mailbox.wakeup_state, 1, 1);
	substr (allow_switch, 2, 1) = substr (allow_switch, 1, 1);

SET_WAKEUP_STATE:
	call mailbox_$accept_wakeups_index (msg_facility_mailbox.index, msg_facility_mailbox.event_channel,
	     allow_switch, code);

	if code = error_table_$seg_unknown then do;
		call mailbox_$open ((msg_facility_mailbox.dname), (msg_facility_mailbox.ename),
		     msg_facility_mailbox.index, code);
		if code ^= 0 then do;
			P_code = code;
			return;
		     end;
		go to SET_WAKEUP_STATE;
	     end;

	else if code ^= 0 then do;
		P_code = code;
		return;
	     end;

	if substr (allow_switch, 1, 1) = FALSE & change_state then
	     msg_facility_mailbox.msg_array_updated = FALSE;
	return;					/* set_wakeup_state */

/* This entry returns the pathname for the specified mailbox. */
get_mbx_path: entry (P_msgf_mbx_ptr, P_dname, P_ename, P_default_mbx, P_code);
	P_dname, P_ename = "";
	P_default_mbx = ""b;
	P_code = 0;
	msg_facility_mailbox_ptr = P_msgf_mbx_ptr;

	if msg_facility_mailbox.version ^= MSG_FACILITY_MAILBOX_VERSION_1 then do;
		P_code = error_table_$unimplemented_version;
		return;
	     end;

	P_dname = msg_facility_mailbox.dname;
	P_ename = msg_facility_mailbox.ename;
	P_default_mbx = msg_facility_mailbox.default_mbx;
	return;					/* get_mbx_path */

/* This entry returns the prefix information for the specified mailbox. */
get_prefix: entry (P_msgf_mbx_ptr, P_prefix, P_short_prefix, P_code);
	P_prefix = "";
	P_short_prefix = ""b;
	P_code = 0;
	msg_facility_mailbox_ptr = P_msgf_mbx_ptr;

	if msg_facility_mailbox.version ^= MSG_FACILITY_MAILBOX_VERSION_1 then do;
		P_code = error_table_$unimplemented_version;
		return;
	     end;

	P_prefix = msg_facility_mailbox.prefix;
	P_short_prefix = msg_facility_mailbox.short_prefix;
	return;					/* get_prefix */

/* This entry sets the prefix information for the specified mailbox. */
set_prefix: entry (P_msgf_mbx_ptr, P_prefix, P_short_prefix, P_code);
	P_code = 0;
	msg_facility_mailbox_ptr = P_msgf_mbx_ptr;

	if msg_facility_mailbox.version ^= MSG_FACILITY_MAILBOX_VERSION_1 then do;
		P_code = error_table_$unimplemented_version;
		return;
	     end;

	msg_facility_mailbox.prefix = P_prefix;
	msg_facility_mailbox.short_prefix = P_short_prefix;
	return;					/* set_prefix */

/* This entry returns the short format switch for the specified mailbox. */
get_message_format: entry (P_msgf_mbx_ptr, P_short_format, P_code);
	P_short_format = ""b;
	P_code = 0;
	msg_facility_mailbox_ptr = P_msgf_mbx_ptr;

	if msg_facility_mailbox.version ^= MSG_FACILITY_MAILBOX_VERSION_1 then do;
		P_code = error_table_$unimplemented_version;
		return;
	     end;

	P_short_format = msg_facility_mailbox.short_format;
	return;					/* get_message_format */

/* This entry sets the short format switch for the specified mailbox. */
set_message_format: entry (P_msgf_mbx_ptr, P_short_format, P_code);
	P_code = 0;
	msg_facility_mailbox_ptr = P_msgf_mbx_ptr;

	if msg_facility_mailbox.version ^= MSG_FACILITY_MAILBOX_VERSION_1 then do;
		P_code = error_table_$unimplemented_version;
		return;
	     end;

	msg_facility_mailbox.short_format = P_short_format;
	return;					/* set_message_format */

/* This entry returns the alarm handler for the specified mailbox. */
get_alarm_handler: entry (P_msgf_mbx_ptr, P_handler, P_info_ptr, P_time, P_code);
	P_info_ptr = null ();
	P_time = 0;
	P_code = 0;
	msg_facility_mailbox_ptr = P_msgf_mbx_ptr;

	if msg_facility_mailbox.version ^= MSG_FACILITY_MAILBOX_VERSION_1 then do;
		P_code = error_table_$unimplemented_version;
		return;
	     end;

	P_handler = msg_facility_mailbox.alarm_handler;
	P_info_ptr = msg_facility_mailbox.alarm_info_ptr;
	P_time = msg_facility_mailbox.alarm_time;
	return;					/* get_alarm_handler */

/* This entry sets the alarm handler for the specified mailbox. */
set_alarm_handler: entry (P_msgf_mbx_ptr, P_handler, P_info_ptr, P_time, P_code);
	P_code = 0;
	msg_facility_mailbox_ptr = P_msgf_mbx_ptr;

	if msg_facility_mailbox.version ^= MSG_FACILITY_MAILBOX_VERSION_1 then do;
		P_code = error_table_$unimplemented_version;
		return;
	     end;

	if msg_facility_mailbox.event_channel = 0 then do;
		P_code = error_table_$messages_off;
		return;
	     end;

	msg_facility_mailbox.alarm_handler = P_handler;
	msg_facility_mailbox.alarm_info_ptr = P_info_ptr;
	msg_facility_mailbox.alarm_time = P_time;

/* if alarm time is nonzero, turn on hold messages mode */
	if msg_facility_mailbox.alarm_time ^= 0 then msg_facility_mailbox.hold_messages = TRUE;

/* turn off any preexisting alarm */
	if msg_facility_mailbox.alarm_event_channel ^= 0 then
	     call timer_manager_$reset_alarm_wakeup (msg_facility_mailbox.alarm_event_channel);

	if msg_facility_mailbox.alarm_event_channel = 0 then do;
		call ipc_$create_ev_chn (msg_facility_mailbox.alarm_event_channel, code);

		if code ^= 0 then do;
			P_code = code;
			return;
		     end;

		call ipc_$decl_ev_call_chn (msg_facility_mailbox.alarm_event_channel, message_facility_$alarm_processor,
		     msg_facility_mailbox_ptr, (1), code);

		if code ^= 0 then do;
			P_code = code;
			return;
		     end;
	     end;

	if P_time ^= 0 then call timer_manager_$alarm_wakeup (msg_facility_mailbox.alarm_time, RELATIVE_SECONDS,
		msg_facility_mailbox.alarm_event_channel);
	return;					/* set_alarm_handler */

/* This entry returns the wakeup handler for the specified mailbox. */
get_wakeup_handler: entry (P_msgf_mbx_ptr, P_handler, P_info_ptr, P_code);
	P_info_ptr = null ();
	P_code = 0;
	msg_facility_mailbox_ptr = P_msgf_mbx_ptr;

	if msg_facility_mailbox.version ^= MSG_FACILITY_MAILBOX_VERSION_1 then do;
		P_code = error_table_$unimplemented_version;
		return;
	     end;

	P_handler = msg_facility_mailbox.wakeup_handler;
	P_info_ptr = msg_facility_mailbox.wakeup_info_ptr;
	return;					/* get_wakeup_handler */

/* This entry sets the wakeup handler for the specified mailbox. */
set_wakeup_handler: entry (P_msgf_mbx_ptr, P_handler, P_info_ptr, P_code);
	P_code = 0;
	msg_facility_mailbox_ptr = P_msgf_mbx_ptr;

	if msg_facility_mailbox.version ^= MSG_FACILITY_MAILBOX_VERSION_1 then do;
		P_code = error_table_$unimplemented_version;
		return;
	     end;

	if msg_facility_mailbox.event_channel = 0 then do;
		P_code = error_table_$messages_off;
		return;
	     end;

	msg_facility_mailbox.wakeup_handler = P_handler;
	msg_facility_mailbox.wakeup_info_ptr = P_info_ptr;
	return;					/* set_wakeup_handler */

/* This entry returns last message information for the specified mailbox. */
get_last_message_info: entry (P_msgf_mbx_ptr, P_info_ptr, P_code);
	P_code = 0;
	msg_facility_mailbox_ptr = P_msgf_mbx_ptr;

	if msg_facility_mailbox.version ^= MSG_FACILITY_MAILBOX_VERSION_1 then do;
		P_code = error_table_$unimplemented_version;
		return;
	     end;

	last_message_info_ptr = P_info_ptr;

	if last_message_info.version ^= LAST_MESSAGE_INFO_VERSION_1 then do;
		P_code = error_table_$unimplemented_version;
		return;
	     end;

	last_message_info.last_message_ptr = msg_facility_mailbox.last_message_ptr;
	last_message_info.last_message_id = msg_facility_mailbox.last_id;
	last_message_info.last_message_number = msg_facility_mailbox.last_message_number;
	return;					/* get_last_message_info */

/* This entry returns a pointer to the message array for the specified mailbox. */
get_msg_array_ptr: entry (P_msgf_mbx_ptr, P_area_ptr, P_msg_array_ptr, P_n_messages, P_code);
	P_msg_array_ptr = null ();
	P_n_messages = 0;
	P_code = 0;
	msg_facility_mailbox_ptr = P_msgf_mbx_ptr;
	user_area_ptr = P_area_ptr;

	if msg_facility_mailbox.version ^= MSG_FACILITY_MAILBOX_VERSION_1 then do;
		P_code = error_table_$unimplemented_version;
		return;
	     end;

	if user_area_ptr = null () then user_area_ptr = get_system_free_area_ ();

/* Determine which mailbox_ entry points to use. */
	call mailbox_$get_mode_index (msg_facility_mailbox.index, access_mode, code);

	if code ^= 0 then do;
	     P_code = code;
	     return;
	end;

	own = ^substr (access_mode, 3, 1);

/* Check to see if any new messages have arrived that we missed. */
CHECK_LAST_MESSAGE:
	if ^own then call mailbox_$incremental_read_index (msg_facility_mailbox.index, user_area_ptr, READ_FORWARD,
	     msg_facility_mailbox.last_id, addr (local_mra), code);
	else call mailbox_$own_incremental_read_index (msg_facility_mailbox.index, user_area_ptr, READ_FORWARD,
	     msg_facility_mailbox.last_id, addr (local_mra), code);
	if code = error_table_$seg_unknown then do;
		call mailbox_$open ((msg_facility_mailbox.dname), (msg_facility_mailbox.ename),
		     msg_facility_mailbox.index, code);
		if code ^= 0 then do;
			P_code = code;
			return;
		     end;
		go to CHECK_LAST_MESSAGE;
	     end;

	if code ^= error_table_$no_message then
	     msg_facility_mailbox.msg_array_updated = FALSE;

/* If the message array has already been created in the past and we are
   accepting messages, the message array is automatically kept up-to-date
   and there is no need to waste computrons going through the entire
   mailbox. (The above code takes care of the cases where we're losing
   wakeups, due to another user accepting messages out from under us or
   whatever.) */

	if msg_facility_mailbox.wakeup_state = "10"b
	     & msg_facility_mailbox.messages_ptr ^= null ()
	     & msg_facility_mailbox.msg_array_updated then do;
		if ^msg_facility_mailbox.msg_array_compacted then
		     call compact_message_array;
	     end;
	else do;
		call create_message_array;
		if code ^= 0 then P_code = code;
	     end;

	n_messages = msg_facility_mailbox.n_messages;
	allocate msg_array in (user_area);
	array_length = MSG_ARRAY_ELEMENT_LENGTH * n_messages;
	destination_string_ptr = addr (msg_array (1));
	source_string_ptr = addr (internal_msg_array (1));
	destination_string = source_string;
	P_n_messages = n_messages;
	P_msg_array_ptr = msg_array_ptr;
	return;					/* get_msg_array_ptr */

/* This entry returns the specified message from the specified mailbox. */
read_message: entry (P_msgf_mbx_ptr, P_message_id, P_area_ptr, P_info_ptr, P_code);
	P_code = 0;
	msg_facility_mailbox_ptr = P_msgf_mbx_ptr;
	message_id = P_message_id;
	message_info_ptr = P_info_ptr;
	user_area_ptr = P_area_ptr;

	if msg_facility_mailbox.version ^= MSG_FACILITY_MAILBOX_VERSION_1 then do;
		P_code = error_table_$unimplemented_version;
		return;
	     end;


	if message_info.version ^= MESSAGE_INFO_VERSION_1 then do;
		P_code = error_table_$unimplemented_version;
		return;
	     end;

	if user_area_ptr = null () then user_area_ptr = get_system_free_area_ ();

/* Determine which mailbox_ entry points to use. */
	call mailbox_$get_mode_index (msg_facility_mailbox.index, access_mode, code);

	if code ^= 0 then do;
	     P_code = code;
	     return;
	end;

	own = ^substr (access_mode, 3, 1);

READ_MESSAGE:
	if ^own then call mailbox_$incremental_read_index (msg_facility_mailbox.index, user_area_ptr, READ_CURRENT,
	     message_id, addr (local_mra), code);
	else call mailbox_$own_incremental_read_index (msg_facility_mailbox.index, user_area_ptr, READ_CURRENT,
	     message_id, addr (local_mra), code);
	if code = error_table_$seg_unknown then do;
		call mailbox_$open ((msg_facility_mailbox.dname), (msg_facility_mailbox.ename),
		     msg_facility_mailbox.index, code);
		if code ^= 0 then do;
			P_code = code;
			return;
		     end;
		go to READ_MESSAGE;
	     end;

/* If the message isn't found, our message array could be out of synch
   with the mailbox, so we need to call create_message_array in the next
   call to message_facility_$get_msg_array_ptr. */
	if code = error_table_$no_message then
	     msg_facility_mailbox.msg_array_updated = FALSE;

	if code ^= 0 then do;
		P_code = code;
		return;
	     end;

	message_info.sender = local_mra.sender_id;
	message_info.message_ptr = local_mra.ms_ptr;
	message_info.authorization = local_mra.sender_authorization;

	return;					/* read_message */

/* This entry sets the seen switch for the specified message in the specified mailbox. */
set_seen_switch: entry (P_msgf_mbx_ptr, P_message_id, P_flags, P_code);
	P_code = 0;
	msg_facility_mailbox_ptr = P_msgf_mbx_ptr;
	message_id = P_message_id;
	seen_switch_flags = P_flags;

	if msg_facility_mailbox.version ^= MSG_FACILITY_MAILBOX_VERSION_1 then do;
		P_code = error_table_$unimplemented_version;
		return;
	     end;

	call get_message_index (message_id, message_index, code);

	if code ^= 0 then do;
		P_code = code;
		return;
	     end;

/* Determine which mailbox_ entry points to use. */
	call mailbox_$get_mode_index (msg_facility_mailbox.index, access_mode, code);

	if code ^= 0 then do;
	     P_code = code;
	     return;
	end;

	own = ^substr (access_mode, 3, 1);

SET_SEEN_SWITCH:
	if ^own then call mailbox_$incremental_read_index (msg_facility_mailbox.index, area_ptr, READ_CURRENT,
	     message_id, addr (local_mra), code);
	else call mailbox_$own_incremental_read_index (msg_facility_mailbox.index, area_ptr, READ_CURRENT,
	     message_id, addr (local_mra), code);
	if code = error_table_$seg_unknown then do;
		call mailbox_$open ((msg_facility_mailbox.dname), (msg_facility_mailbox.ename),
		     msg_facility_mailbox.index, code);
		if code ^= 0 then do;
			P_code = code;
			return;
		     end;
		go to SET_SEEN_SWITCH;
	     end;

	if code ^= 0 then do;
		P_code = code;
		return;
	     end;

	mail_format_ptr = local_mra.ms_ptr;

	d_permission = substr (access_mode, 2, 1);

	if mail_format.acknowledge & d_permission then call send_acknowledgement;
	if substr (seen_switch_flags, 1, 1) then do;	/* use defaults */
		hold_this_message = msg_facility_mailbox.hold_messages;
		hold_this_notification = msg_facility_mailbox.hold_notifications;
	     end;

	else do;					/* use supplied args */
		hold_this_message = substr (seen_switch_flags, 2, 1);
		hold_this_notification = substr (seen_switch_flags, 3, 1);
	     end;

/* set seen switch */
	internal_msg_array.printed (message_index) = TRUE;
	if d_permission then do;
		mail_format.seen = TRUE;
		call mailbox_$update_message_index (msg_facility_mailbox.index, 36 * (fixed (rel (addr (mail_format.text)))
		     - fixed (rel (addr (mail_format.version)))), message_id, local_mra.ms_ptr, (0));
	     end;

	found = FALSE;
	last_message_set = FALSE;
	last_index = 0;
	do idx = msg_facility_mailbox.n_elements to 1 by -1 while (^found);
	     if internal_msg_array.message_id (idx) ^= ""b then do;
		     found = TRUE;
		     last_index = idx;
		end;
	end;
	if (message_index = last_index & message_id ^= msg_facility_mailbox.last_id)
	     & found then do;			/* set last message info */
		last_message_set = TRUE;

		message_info_ptr = msg_facility_mailbox.last_message_ptr;
		if message_info_ptr ^= null () then do;
			mail_format_ptr = message_info.message_ptr;
			if mail_format_ptr ^= null () then free mail_format in (sys_area);
			free message_info in (sys_area);
		     end;

		mail_format_ptr = local_mra.ms_ptr;
		allocate message_info in (sys_area);
		message_info.version = MESSAGE_INFO_VERSION_1;
		message_info.sender = local_mra.sender_id;
		message_info.message_ptr = local_mra.ms_ptr;
		message_info.authorization = local_mra.sender_authorization;
		msg_facility_mailbox.last_message_ptr = message_info_ptr;
		msg_facility_mailbox.last_id = message_id;
		msg_facility_mailbox.last_message_number = internal_msg_array.message_number (message_index);
	     end;

	if d_permission
	     & ((mail_format.notify & ^hold_this_notification)
	     | (^mail_format.notify & ^hold_this_message)) then do; /* delete message */
		call message_facility_$delete_message (msg_facility_mailbox_ptr, message_id, code);

		if code ^= 0 then do;
			P_code = code;
			if ^last_message_set then
			     free mail_format in (sys_area);
			return;
		     end;
	     end;					/* delete message */

	if ^last_message_set then
	     free mail_format in (sys_area);

	return;					/* set_seen_switch */

/* This entry sends a message to the specified mailbox. */
send_message: entry (P_dname, P_ename, P_message, P_info_ptr, P_code);
	access_class = FALSE;
	go to SEND_COMMON;

send_message_access_class: entry (P_dname, P_ename, P_message, P_info_ptr, P_access_class, P_code);
	access_class = TRUE;
	authorization = P_access_class;

SEND_COMMON:
	P_code = 0;
	dname = P_dname;
	ename = P_ename;

	local_smi_ptr = P_info_ptr;

	on cleanup begin;
		if mbx_index ^= 0 then call mailbox_$close (mbx_index, (0));
	     end;

	call mailbox_$open (dname, ename, mbx_index, code);

	if code ^= 0 then do;
		P_code = code;
		return;
	     end;

	if P_message = "" then text_length = 0;
	else text_length = length (rtrim (P_message));

	message_bit_count = size (mail_format) * 36;

	begin;					/* allocate message */
	     dcl	   mail_format_space      bit (message_bit_count) aligned;
	     dcl	   1 local_mf	      aligned like mail_format based (local_mf_ptr);
	     dcl	   local_mf_ptr	      ptr;

	     local_mf_ptr = addr (mail_format_space);

	     local_mf.text_len = text_length;
	     local_mf.version = MAIL_FORMAT_VERSION_4;
	     local_mf.sent_from = local_smi.sent_from;
	     string (local_mf.switches) = ""b;
	     local_mf.wakeup = local_smi.wakeup;
	     local_mf.notify = local_smi.notify;
	     local_mf.acknowledge = local_smi.acknowledge;
	     local_mf.text = rtrim (P_message);
	     local_mf.lines = 0;

	     call get_person_and_project;

	     if local_mf.sent_from = "" then local_mf.sent_from = person;
	     else if local_mf.sent_from = person then local_mf.sent_from = full_name;

	     idx = 1;
	     count = 1;

	     do while (idx ^= 0 & text_length ^= 0);
		idx = index (substr (P_message, count, text_length), NL);
		count = count + idx;
		text_length = text_length - idx;
		local_mf.lines = local_mf.lines + 1;
	     end;

	     on record_quota_overflow begin;
		     P_code = error_table_$rqover;
		     go to RETURN_FROM_SM;
		end;

	     allow_switch = local_mf.wakeup || local_mf.urgent || local_smi.always_add || local_smi.never_add;
	     retried = FALSE;

RETRY:	     if ^access_class then call mailbox_$wakeup_add_index (mbx_index, addr (local_mf), message_bit_count,
		     allow_switch, message_id, code);
	     else call mailbox_$wakeup_aim_add_index (mbx_index, addr (local_mf), message_bit_count, allow_switch,
		     authorization, message_id, code);
	     if code = error_table_$bad_segment & ^retried then do;
		     retried = TRUE;
		     go to RETRY;
		end;

/* error_table_$no_info means the message was delivered but the wakeup may
   not have been due to AIM.  This statement will not be necessary if the
   primitives are changed to return a different error code in this case
   (e_t_$no_info from mailbox_$open IS an error, the message is not sent). */
	     else if code = error_table_$no_info then code = 0;

	     P_code = code;

	end;
RETURN_FROM_SM:
	call mailbox_$close (mbx_index, (0));
	return;					/* send_message */

/* This entry deletes a message from the specified mailbox. */
delete_message: entry (P_msgf_mbx_ptr, P_message_id, P_code);
	P_code = 0;
	msg_facility_mailbox_ptr = P_msgf_mbx_ptr;
	message_id = P_message_id;

	if msg_facility_mailbox.version ^= MSG_FACILITY_MAILBOX_VERSION_1 then do;
		P_code = error_table_$unimplemented_version;
		return;
	     end;

	call get_message_index (message_id, message_index, code);

	if code ^= 0 then do;
		P_code = code;
		return;
	     end;

DELETE_MESSAGE:
	call mailbox_$delete_index (msg_facility_mailbox.index, message_id, code);

	if code = error_table_$seg_unknown then do;
		call mailbox_$open ((msg_facility_mailbox.dname), (msg_facility_mailbox.ename),
		     msg_facility_mailbox.index, code);
		if code ^= 0 then do;
			P_code = code;
			return;
		     end;
		go to DELETE_MESSAGE;
	     end;

	else if code ^= 0 then do;
		P_code = code;
		return;
	     end;

/* mark msg as deleted in message array */
	internal_msg_array.message_id (message_index) = ""b;
	internal_msg_array.message_number (message_index) = 0;

	msg_facility_mailbox.n_messages = msg_facility_mailbox.n_messages - 1;
	msg_facility_mailbox.msg_array_compacted = FALSE;
	return;					/* delete_message */

/* This entry prints a message. */
print_message: entry (P_msgf_mbx_ptr, P_iocb_ptr, P_message_id, P_info_ptr, P_code);
	P_code = 0;
	msg_facility_mailbox_ptr = P_msgf_mbx_ptr;
	iocb_ptr = P_iocb_ptr;
	message_id = P_message_id;
	local_pf_ptr = P_info_ptr;

	if msg_facility_mailbox.version ^= MSG_FACILITY_MAILBOX_VERSION_1 then do;
		P_code = error_table_$unimplemented_version;
		return;
	     end;

	if ^local_pf.print_last_message then do;
		call get_message_index (message_id, message_index, code);

		if code ^= 0 then do;
			P_code = code;
			return;
		     end;

		mail_format_ptr = null ();
		local_mi.version = MESSAGE_INFO_VERSION_1;

		on cleanup begin;
			if mail_format_ptr ^= null () then free mail_format in (sys_area);
		     end;

		call message_facility_$read_message (msg_facility_mailbox_ptr, message_id, area_ptr, addr (local_mi), code);
		if code ^= 0 then return;
	     end;
	else do;					/* use last message info */
		local_lmi.version = LAST_MESSAGE_INFO_VERSION_1;

		call message_facility_$get_last_message_info (msg_facility_mailbox_ptr, addr (local_lmi), code);

		if code ^= 0 then do;
			P_code = code;
			return;
		     end;

		if local_lmi.last_message_id = ""b then do;
			P_code = error_table_$no_message;
			return;
		     end;

		message_info_ptr = local_lmi.last_message_ptr;
		local_mi = message_info;
	     end;

	mail_format_ptr = local_mi.message_ptr;

	if ^local_pf.print_last_message then do;
		if internal_msg_array.message_number (message_index) ^= 0 then call ioa_$rsnnl ("^d) ", tag, (0),
			internal_msg_array.message_number (message_index));
		else tag = "";
	     end;
	else do;
		if local_lmi.last_message_number ^= 0 then
		     call ioa_$rsnnl ("^d) ", tag, (0), local_lmi.last_message_number);
		else tag = "";
	     end;

/* print prefix, it may contain ioa_ controls */
	if local_pf.print_prefix then call ioa_$ioa_switch_nnl (iocb_ptr,
		msg_facility_mailbox.prefix);

	message_ident = "";

	if local_pf.print_ename then message_ident = rtrim (msg_facility_mailbox.ename) || " ";

	if local_pf.print_sender then do;

/* create message sender string */
		message_sender = substr (local_mi.sender, 1, length (rtrim (local_mi.sender)) - 2);
		if mail_format.sent_from ^= before (local_mi.sender, ".") & rtrim (mail_format.sent_from) ^= "" then
		     message_sender = rtrim (message_sender)
			|| " (" || rtrim (canon (rtrim (mail_format.sent_from), length (rtrim (mail_format.sent_from)))) || ")";
		authorization = get_authorization_ ();
		if ^aim_check_$greater_or_equal (local_mi.authorization, authorization) then do;
			call convert_access_class_$to_string_short (local_mi.authorization, auth_string, code);
			if auth_string = "" then auth_string = "system_low";
			message_sender = rtrim (message_sender) || " at " || auth_string;
		     end;

		if tag ^= "" then message_ident = message_ident || tag || rtrim (message_sender);
		else message_ident = message_ident || "From " || rtrim (message_sender);
	     end;
	else message_ident = message_ident || tag || "=";

	if ^local_pf.print_last_message then date_time = fixed (substr (message_id, 19, 54), 71);
	else date_time = fixed (substr (local_lmi.last_message_id, 19, 54), 71);

	if local_pf.print_date_and_time then
	     message_ident = message_ident || " " || date_time_$format ("date_time", date_time, "", "");
	else if local_pf.print_time then
	     message_ident = message_ident || " " || date_time_$format ("time", date_time, "", "");

	call ioa_$ioa_switch_nnl (iocb_ptr, "^a: ^[^/^]^a^/", message_ident,
	     (length (message_ident) > 16 & (length (message_ident) + mail_format.text_len > 80)),
	     rtrim (canon (rtrim (mail_format.text), length (rtrim (mail_format.text)))));

	if ^local_pf.print_last_message then if mail_format_ptr ^= null () then free mail_format in (sys_area);
	return;					/* print_message */

/* This entry is the processor for alarms. */
alarm_processor: entry (P_info_ptr);
	event_call_info_ptr = P_info_ptr;
	msg_facility_mailbox_ptr = event_call_info.data_ptr;

	call create_message_array;

	if code = error_table_$no_message then code = 0;

	if code ^= 0 then do;
		call sub_err_ (code, "alarm", ACTION_CANT_RESTART, null (), (0),
		     "While updating message array for mailbox ^a.", pathname_ ((msg_facility_mailbox.dname), (msg_facility_mailbox.ename)));
		return;
	     end;

	call msg_facility_mailbox.alarm_handler (msg_facility_mailbox_ptr, msg_facility_mailbox.alarm_info_ptr);

	if msg_facility_mailbox.alarm_time > 0 then call timer_manager_$alarm_wakeup (msg_facility_mailbox.alarm_time,
		RELATIVE_SECONDS, msg_facility_mailbox.alarm_event_channel);

	return;					/* alarm_processor */

/* This entry is the processor for wakeups. */
wakeup_processor: entry (P_info_ptr);
	event_call_info_ptr = P_info_ptr;
	msg_facility_mailbox_ptr = event_call_info.data_ptr;

/* Determine which mailbox_ entry points to use. */
WAKEUP_GET_MODE_INDEX:
	call mailbox_$get_mode_index (msg_facility_mailbox.index, access_mode, code);

	if code = error_table_$seg_unknown then do;
		call mailbox_$open ((msg_facility_mailbox.dname), (msg_facility_mailbox.ename),
		     msg_facility_mailbox.index, code);
		if code ^= 0 then return;
		go to WAKEUP_GET_MODE_INDEX;
	end;
	else if code ^= 0 then return;
	else own = ^substr (access_mode, 3, 1);

/* Check to see if any new messages have arrived that we missed. */
WAKEUP_CHECK_LAST_MESSAGE:
	if ^own then call mailbox_$incremental_read_index (msg_facility_mailbox.index, area_ptr, READ_FORWARD,
		msg_facility_mailbox.last_id, addr (local_mra), code);
	else call mailbox_$own_incremental_read_index (msg_facility_mailbox.index, area_ptr, READ_FORWARD,
		msg_facility_mailbox.last_id, addr (local_mra), code);
	if code = error_table_$seg_unknown then do;
		call mailbox_$open ((msg_facility_mailbox.dname), (msg_facility_mailbox.ename),
		     msg_facility_mailbox.index, code);
		if code ^= 0 then return;
		go to WAKEUP_CHECK_LAST_MESSAGE;
	     end;

	if code ^= error_table_$no_message then
	     msg_facility_mailbox.msg_array_updated = FALSE;

	if ^msg_facility_mailbox.msg_array_updated then
	     call create_message_array;
	else if ^msg_facility_mailbox.msg_array_compacted then
	     call compact_message_array;

	message_id = unspec (event_call_info.message);

/* Update last message info, do not mark message seen. */
PROCESSOR_READ:
	if ^own then call mailbox_$incremental_read_index (msg_facility_mailbox.index, area_ptr, READ_CURRENT, message_id,
	     addr (local_mra), code);
	else call mailbox_$incremental_read_index (msg_facility_mailbox.index, area_ptr, READ_CURRENT, message_id,
	     addr (local_mra), code);
	if code = error_table_$seg_unknown then do;
		call mailbox_$open ((msg_facility_mailbox.dname), (msg_facility_mailbox.ename),
		     msg_facility_mailbox.index, code);
		if code ^= 0 then return;
		go to PROCESSOR_READ;
	     end;

	if code = error_table_$no_message then return;	/* no big deal. */

	if code ^= 0 then do;
		call sub_err_ (code, "wakeup", ACTION_CANT_RESTART, null (), (0),
		     "While reading message from mailbox ^a.", pathname_ ((msg_facility_mailbox.dname), (msg_facility_mailbox.ename)));
	     end;

	mail_format_ptr = local_mra.ms_ptr;

	if mail_format.notify & ^msg_facility_mailbox.notify_mail then do;
		call mailbox_$delete_index (msg_facility_mailbox.index, message_id, code);
		free mail_format in (sys_area);
		return;
	     end;

	call get_message_index (message_id, current_message_index, code);
	if code = 0 then new_message_number = internal_msg_array.message_number (current_message_index);
	else if code = error_table_$no_message then do;
		if (^mail_format.notify & msg_facility_mailbox.hold_messages)
		     | (msg_facility_mailbox.hold_notifications & mail_format.notify) then do;
			new_message_number = msg_facility_mailbox.highest_message + 1;
			msg_facility_mailbox.highest_message = new_message_number;

		     end;

		else new_message_number = 0;

/* Update message array, adding new message at the end (unless it's the
   fairly rare case in which this message was added before others that
   have already been received but the wakeup came later). */
		msg_facility_mailbox.n_messages = msg_facility_mailbox.n_messages + 1;
		if msg_facility_mailbox.n_messages > msg_facility_mailbox.n_elements then do;
			n_messages = msg_facility_mailbox.n_elements + MSG_ARRAY_BLOCK_SIZE;
			allocate msg_array in (sys_area);
			if msg_facility_mailbox.messages_ptr ^= null () then do;
				array_length = MSG_ARRAY_ELEMENT_LENGTH * (msg_facility_mailbox.n_messages - 1);
				destination_string_ptr = addr (msg_array (1));
				source_string_ptr = addr (internal_msg_array (1));
				destination_string = source_string;
				free internal_msg_array in (sys_area);
			     end;
			msg_facility_mailbox.n_elements = n_messages;
			msg_facility_mailbox.messages_ptr = msg_array_ptr;
		     end;
		idx = msg_facility_mailbox.n_messages;

/* See if we need to insert this message at a different point in the
   message array. */
		if idx ^= 1 then do;
			found = FALSE;
			do while (^found & idx > 1);
			     if internal_msg_array.message_id (idx - 1) < message_id then found = TRUE;
			     else idx = idx - 1;
			end;

			if idx ^= msg_facility_mailbox.n_messages then do;
				array_length = MSG_ARRAY_ELEMENT_LENGTH * (msg_facility_mailbox.n_messages - idx);
				call mrl_ (addr (internal_msg_array (idx)), array_length,
				     addr (internal_msg_array (idx + 1)), array_length);
			     end;

		     end;

		internal_msg_array.message_id (idx) = message_id;
		internal_msg_array.message_number (idx) = new_message_number;
		d_permission = substr (access_mode, 2, 1);
		if d_permission then internal_msg_array.printed (idx) = mail_format.seen;
		else internal_msg_array.printed (idx) = FALSE;
		internal_msg_array.mbz (idx) = ""b;
		current_message_index = idx;
	     end;

/* update last message info */
	message_info_ptr = msg_facility_mailbox.last_message_ptr;
	if message_info_ptr ^= null () then do;
		mail_format_ptr = message_info.message_ptr;
		if mail_format_ptr ^= null () then free mail_format in (sys_area);
		free message_info in (sys_area);
	     end;

	allocate message_info in (sys_area);
	message_info.version = MESSAGE_INFO_VERSION_1;
	message_info.sender = local_mra.sender_id;
	message_info.message_ptr = local_mra.ms_ptr;
	message_info.authorization = local_mra.sender_authorization;
	msg_facility_mailbox.last_id = message_id;
	msg_facility_mailbox.last_message_ptr = message_info_ptr;
	msg_facility_mailbox.last_message_number = internal_msg_array.message_number (current_message_index);

/* Call handler. */
	call msg_facility_mailbox.wakeup_handler (msg_facility_mailbox_ptr, msg_facility_mailbox.wakeup_info_ptr);
	return;					/* wakeup_processor */

/* This entry is the default alarm handler. */
default_alarm_handler: entry (P_msgf_mbx_ptr, P_info_ptr);
	msg_facility_mailbox_ptr = P_msgf_mbx_ptr;
	if msg_facility_mailbox.n_messages = 0 then return;

	use_call_string = FALSE;
	if P_info_ptr ^= null then if call_string ^= "" then use_call_string = TRUE;

	if ^use_call_string then
	     call ioa_$ioa_switch (iox_$user_io, "^[You have^;There are^] ^d message^[s^]^[ in ^a^].", msg_facility_mailbox.default_mbx, msg_facility_mailbox.n_messages,
		(msg_facility_mailbox.n_messages ^= 1), ^msg_facility_mailbox.default_mbx,
		pathname_ ((msg_facility_mailbox.dname), (msg_facility_mailbox.ename)));
	do idx = 1 to msg_facility_mailbox.n_messages;
	     call process_message (internal_msg_array.message_id (idx));
	end;
	call iox_$control (iox_$user_io, "start", null (), code);
	return;					/* default_alarm_handler */

/* This entry is the default wakeup handler. */
default_wakeup_handler: entry (P_msgf_mbx_ptr, P_info_ptr);
	msg_facility_mailbox_ptr = P_msgf_mbx_ptr;

	use_call_string = FALSE;
	if P_info_ptr ^= null () then if call_string ^= "" then use_call_string = TRUE;

	call process_message (msg_facility_mailbox.last_id);
	call iox_$control (iox_$user_io, "start", null (), code);
	return;					/* default_wakeup_handler */

/* This procedure returns a message array index given a message ID. */
get_message_index: procedure (P_message_id, P_message_index, P_code);
	dcl     P_message_id	 bit (72) aligned parm;
	dcl     P_message_index	 fixed bin parm;
	dcl     P_code		 fixed bin (35) parm;
	dcl     idx		 fixed bin;
	dcl     (max_idx, high_idx, low_idx, high_temp, low_temp) fixed bin;
	dcl     message_id		 bit (54) aligned;
	dcl     done_searching	 bit (1) aligned;

	P_message_index = 0;

	if msg_facility_mailbox.n_messages = 0 then do;
		P_code = error_table_$no_message;
		return;
	     end;

	P_code = 0;
	message_id = substr (P_message_id, 19, 54);	/* date/time portion */

	low_idx = 1;
	if ^msg_facility_mailbox.msg_array_compacted then max_idx = msg_facility_mailbox.n_elements;
	else max_idx = msg_facility_mailbox.n_messages;	/* faster */
	high_idx = max_idx;
	idx = divide (high_idx + low_idx, 2, 17, 0);
	done_searching = FALSE;

	do while (^done_searching);
	     if internal_msg_array.message_id (idx) = ""b then do; /* deleted */
		     high_temp = min (idx + 1, max_idx);
		     low_temp = max (idx - 1, 1);
		     do while (high_temp < max_idx & internal_msg_array.message_id (high_temp) = ""b);
			high_temp = high_temp + 1;
		     end;
		     do while (low_temp > 1 & internal_msg_array.message_id (low_temp) = ""b);
			low_temp = low_temp - 1;
		     end;
		     if substr (internal_msg_array.message_id (high_temp), 19, 54) > message_id
			| internal_msg_array.message_id (high_temp) = ""b then high_idx = low_temp;
		     else low_idx = high_temp;

		     if idx > high_idx then idx = high_idx;
		     else if idx < low_idx then idx = low_idx;
		end;

	     else if substr (internal_msg_array.message_id (idx), 19, 54) < message_id then do;
		     if idx >= max_idx then done_searching = TRUE;
		     else if substr (internal_msg_array.message_id (idx + 1), 19, 54) > message_id then done_searching = TRUE;
		     else do;
			     low_idx = idx;
			     idx = idx + max (divide (high_idx - idx, 2, 17, 0), 1);
			end;
		end;

	     else if idx = 1 then done_searching = TRUE;
	     else if substr (internal_msg_array.message_id (idx - 1), 19, 54) < message_id then done_searching = TRUE;
	     else do;
		     high_idx = idx;
		     idx = idx - max (divide (idx - low_idx, 2, 17, 0), 1);
		end;
	end;

	if message_id ^= substr (internal_msg_array.message_id (idx), 19, 54) then P_code = error_table_$no_message;
	else P_message_index = idx;
	return;
     end get_message_index;

/* This procedure creates or updates the message array. */
create_message_array: procedure;
	dcl     msg_existence_array	 (msg_facility_mailbox.n_messages) bit (1) aligned;
	dcl     old_msg_count	 fixed bin;
	dcl     msg_count		 fixed bin;
	dcl     n_deleted		 fixed bin;

/* initialize msg existence array */
	msg_existence_array (*) = FALSE;
	old_msg_count = msg_facility_mailbox.n_messages;
	msg_count = 0;

/* compact message array */
	if ^msg_facility_mailbox.msg_array_compacted then
	     call compact_message_array;

/* add new messages to array */
	mail_format_ptr = null ();

	on cleanup begin;
		if mail_format_ptr ^= null () then free mail_format in (sys_area);
	     end;

/* Determine which mailbox_ entry points to use. */
	call mailbox_$get_mode_index (msg_facility_mailbox.index, access_mode, code);

	if code ^= 0 then return;
	own = ^substr (access_mode, 3, 1);

MSG_ARRAY_NEW_READ:
	if ^own then call mailbox_$read_index (msg_facility_mailbox.index, area_ptr, READ_FIRST, addr (local_mra), code);
	else call mailbox_$own_read_index (msg_facility_mailbox.index, area_ptr, READ_FIRST, addr (local_mra), code);

	if code = error_table_$seg_unknown then do;
		call mailbox_$open ((msg_facility_mailbox.dname), (msg_facility_mailbox.ename),
		     msg_facility_mailbox.index, code);
		if code ^= 0 then return;
		go to MSG_ARRAY_NEW_READ;
	     end;

	do while (code = 0);
	     mail_format_ptr = local_mra.ms_ptr;
	     message_id = local_mra.ms_id;
	     found = FALSE;
	     do idx = 1 to msg_facility_mailbox.n_messages while (^found);
		if internal_msg_array.message_id (idx) = message_id then do; /* found message */
			found = TRUE;
			msg_existence_array (idx) = TRUE;
			msg_count = msg_count + 1;
			if internal_msg_array.message_number (idx) = 0 then
			     if (msg_facility_mailbox.hold_messages & ^mail_format.notify)
				| (msg_facility_mailbox.hold_notifications & mail_format.notify) then
				do;		/* already in mbx, now in hold mode */
				     msg_facility_mailbox.highest_message = msg_facility_mailbox.highest_message + 1;
				     internal_msg_array.message_number (idx) = msg_facility_mailbox.highest_message;
				end;		/* assign number to old message */
			     else ;
			else /* message_number is nonzero, do we want to make it zero? */
			     if (^msg_facility_mailbox.hold_messages & ^mail_format.notify)
			     | (^msg_facility_mailbox.hold_notifications & mail_format.notify) then
			     internal_msg_array.message_number (idx) = 0; /* already in mailbox, now in non-hold mode */
		     end;				/* found message */
	     end;
	     if ^found & mail_format.wakeup then do;
						/* add this message */
		     msg_facility_mailbox.n_messages = msg_facility_mailbox.n_messages + 1;
		     if msg_facility_mailbox.n_messages > msg_facility_mailbox.n_elements then do;
			     n_messages = msg_facility_mailbox.n_elements + MSG_ARRAY_BLOCK_SIZE;
			     allocate msg_array in (sys_area);
			     if msg_facility_mailbox.messages_ptr ^= null () then do;
				     array_length = MSG_ARRAY_ELEMENT_LENGTH * (msg_facility_mailbox.n_messages - 1);
				     destination_string_ptr = addr (msg_array (1));
				     source_string_ptr = addr (internal_msg_array (1));
				     destination_string = source_string;
				     free internal_msg_array in (sys_area);
				end;
			     msg_facility_mailbox.n_elements = n_messages;
			     msg_facility_mailbox.messages_ptr = msg_array_ptr;
			end;

		     jdx = msg_facility_mailbox.n_messages;

/* See if we need to insert this message at a different point in the
   message array. */
		     if jdx ^= 1 then do;
			     found = FALSE;
			     do while (^found & jdx > 1);
				if internal_msg_array.message_id (jdx - 1) < message_id then found = TRUE;
				else jdx = jdx - 1;
			     end;

			     if jdx ^= msg_facility_mailbox.n_messages then do;
				     array_length = MSG_ARRAY_ELEMENT_LENGTH * (msg_facility_mailbox.n_messages - jdx);
				     call mrl_ (addr (internal_msg_array (jdx)), array_length,
					addr (internal_msg_array (jdx + 1)), array_length);
				end;

			end;

		     internal_msg_array.message_id (jdx) = message_id;
		     d_permission = substr (access_mode, 2, 1);
		     if d_permission then internal_msg_array.printed (jdx) = mail_format.seen;
		     else internal_msg_array.printed (jdx) = FALSE;
		     internal_msg_array.mbz (jdx) = ""b;

		     if (msg_facility_mailbox.hold_messages & ^mail_format.notify)
			| (msg_facility_mailbox.hold_notifications & mail_format.notify) then do;
			     internal_msg_array.message_number (jdx) =
				msg_facility_mailbox.highest_message + 1;
			     msg_facility_mailbox.highest_message = msg_facility_mailbox.highest_message + 1;
			end;
		     else internal_msg_array.message_number (jdx) = 0;
		end;				/* new one */
	     if mail_format_ptr ^= null () then do;
		     free mail_format in (sys_area);
		     mail_format_ptr = null ();
		end;

	     if ^own then call mailbox_$incremental_read_index (msg_facility_mailbox.index, area_ptr, READ_FORWARD,
		     message_id, addr (local_mra), code);
	     else call mailbox_$own_incremental_read_index (msg_facility_mailbox.index, area_ptr, READ_FORWARD, message_id,
		     addr (local_mra), code);
	end;


	if code = error_table_$no_message then code = 0;
	else if code ^= 0 then return;

/* Now delete messages which are no longer in the mailbox, if any. */
	if msg_count < old_msg_count then do;
		n_deleted = 0;
		msg_facility_mailbox.msg_array_compacted = FALSE;
		do idx = 1 to old_msg_count while (n_deleted < old_msg_count - msg_count);
		     if ^msg_existence_array (idx) then do; /* we didn't find this one */
			     n_deleted = n_deleted + 1;
			     msg_facility_mailbox.n_messages = msg_facility_mailbox.n_messages - 1;
			     internal_msg_array.message_id (idx) = ""b;
			     internal_msg_array.message_number (idx) = 0;
			end;
		end;
		call compact_message_array;
	     end;

/* If we don't own this mailbox (no "d") then assign numbers in sequence.
   This allows us to delete our messages by number in another's mailbox. */
	if own | ^substr (access_mode, 2, 1) then do;
		msg_facility_mailbox.highest_message = 0;
		do idx = 1 to msg_facility_mailbox.n_messages;
		     msg_facility_mailbox.highest_message = msg_facility_mailbox.highest_message + 1;
		     internal_msg_array.message_number (idx) = msg_facility_mailbox.highest_message;
		end;
	     end;

	if code = error_table_$no_message then code = 0;

	if msg_facility_mailbox.wakeup_state = "10"b then
	     msg_facility_mailbox.msg_array_updated = TRUE;
     end create_message_array;

/* This procedure compacts the message array. */
compact_message_array: procedure;
	idx, last_index = 0;
	do while (last_index < msg_facility_mailbox.n_messages);
	     idx = idx + 1;
	     last_index = last_index + 1;
	     do while (idx < msg_facility_mailbox.n_elements & internal_msg_array.message_id (idx) = ""b);
		idx = idx + 1;
	     end;
	     if idx ^= last_index & internal_msg_array.message_id (idx) ^= ""b then do;
		     internal_msg_array (last_index) = internal_msg_array (idx);
		     internal_msg_array.message_id (idx) = ""b;
		     internal_msg_array.message_number (idx) = 0;
		end;
	end;
	if msg_facility_mailbox.messages_ptr ^= null () & last_index ^= 0 then
	     if internal_msg_array.message_id (last_index) = ""b then last_index = last_index - 1;
	msg_facility_mailbox.n_messages = last_index;
	msg_facility_mailbox.msg_array_compacted = TRUE;
     end compact_message_array;

/* This procedure removes control characters (except backspace, tab,
   red ribbon shift, and black ribbon shift) and canonicalizes strings
   to prevent backspacing past the front of the string. */
canon: procedure (P_string, P_string_len) returns (char (*));
	dcl     P_string		 char (*) parm;
	dcl     P_string_len	 fixed bin (21) parm;
	dcl     output_string	 char (P_string_len);

	P_string = translate (P_string, ALPHABET);
	if index (P_string, BS) ^= 0 then do;
		output_string = "";
		call canonicalize_ (addr (P_string), length (P_string), addr (output_string), P_string_len, (0));
		return (output_string);
	     end;
	else return (P_string);
     end canon;

/* This procedure sends an acknowledgement message. */
send_acknowledgement: procedure;
	authorization = get_authorization_ ();
	if aim_check_$greater_or_equal (local_mra.sender_authorization, authorization) then do;
		call get_person_and_project;
		send_mail_info.version = send_mail_info_version_2;
		send_mail_info.sent_from = full_name;
		send_mail_info.wakeup = TRUE;
		send_mail_info.always_add = TRUE;
		send_mail_info.never_add = FALSE;
		send_mail_info.notify = TRUE;
		send_mail_info.acknowledge = FALSE;
		send_mail_info.mbz = ""b;
		person_id = before (substr (local_mra.sender_id, 1, length (rtrim (local_mra.sender_id)) - 2), ".");
		project_id = after (substr (local_mra.sender_id, 1, length (rtrim (local_mra.sender_id)) - 2), ".");
		dname = ">udd>" || rtrim (project_id) || ">" || person_id;
		ename = rtrim (person_id) || ".mbx";
		date_time = fixed (substr (local_mra.ms_id, 19, 54), 71);
		call date_time_ (date_time, msg_date_time);
		call date_time_ (clock (), current_date_time);
		if msg_date_time = current_date_time then message = "Acknowledged.";
		else message = "Acknowledge message of " || msg_date_time;

		code = 1;

		if person_id = "anonymous" then do;
			login_name = local_mra.ms_ptr -> mail_format.sent_from;
			call message_facility_$send_message (">udd>" || rtrim (project_id) || ">" || login_name,
			     rtrim (login_name) || ".mbx", message, addr (send_mail_info), code);
			if code ^= error_table_$noentry then code = 0;
		     end;

		if code ^= 0 then call message_facility_$send_message (dname, ename, message, addr (send_mail_info), (0));
	     end;

	mail_format.acknowledge = FALSE;
	call mailbox_$update_message_index (msg_facility_mailbox.index, 36 * (fixed (rel (addr (mail_format.text)))
	     - fixed (rel (addr (mail_format.version)))), message_id, local_mra.ms_ptr, (0));
     end send_acknowledgement;

/* This procedure prints out a message or executes the supplied call string. */
process_message: procedure (P_message_id);
	dcl     P_message_id	 bit (72) aligned parm;
	dcl     message_id		 bit (72) aligned;
	dcl     message_index	 fixed bin;

	message_id = P_message_id;
	mail_format_ptr = null ();
	local_mi.version = MESSAGE_INFO_VERSION_1;

	call get_message_index (message_id, message_index, code);

	if code ^= 0 then return;

	on cleanup begin;
		if mail_format_ptr ^= null () then free mail_format in (sys_area);
	     end;

	call message_facility_$read_message (msg_facility_mailbox_ptr, message_id, area_ptr, addr (local_mi), code);
	if code ^= 0 then return;
	mail_format_ptr = local_mi.message_ptr;
	date_time = fixed (substr (message_id, 19, 54), 71);
	call date_time_ (date_time, msg_date_time);

/* create message sender string */
	if mail_format.sent_from = before (local_mi.sender, ".") | rtrim (mail_format.sent_from) = "" then
	     message_sender = substr (local_mi.sender, 1, length (rtrim (local_mi.sender)) - 2);
	else message_sender = substr (local_mi.sender, 1, length (rtrim (local_mi.sender)) - 2)
		|| " (" || rtrim (canon (rtrim (mail_format.sent_from), length (rtrim (mail_format.sent_from)))) || ")";
	authorization = get_authorization_ ();
	if ^aim_check_$greater_or_equal (local_mi.authorization, authorization) then do;
		call convert_access_class_$to_string_short (local_mi.authorization, auth_string, code);
		if auth_string = "" then auth_string = "system_low";
		message_sender = rtrim (message_sender) || " at " || auth_string;
	     end;

	if use_call_string then do;
		call ioa_$rsnnl ("^a ^d ^a ^a ^a^[ ^a^]", command_line, (0), call_string, internal_msg_array.message_number (message_index),
		     requote_string_ (rtrim (message_sender)),
		     requote_string_ (rtrim (date_time_$format ("date_time", date_time, "", ""))),
		     requote_string_ (rtrim (canon (rtrim (mail_format.text, NLSPHT), length (rtrim (mail_format.text, NLSPHT))))),
		     ^msg_facility_mailbox.default_mbx,
		     requote_string_ (pathname_ ((msg_facility_mailbox.dname), (msg_facility_mailbox.ename))));

/* If this message is supposed to be deleted, do so. */
		if (mail_format.notify & ^msg_facility_mailbox.hold_notifications) |
		     (^mail_format.notify & ^msg_facility_mailbox.hold_messages) then
		     call message_facility_$set_seen_switch (msg_facility_mailbox_ptr, message_id, DELETE_UNHELD, (0));
		call cu_$cp (addr (command_line), length (rtrim (command_line)), (0));
	     end;

	else do;
						/* print message */
		string (msg_print_flags) = ""b;
		if message_sender = last_sender then short = TRUE;
		else short = FALSE;

/* print prefix, it may contain ioa_ controls */
		if ^short | msg_facility_mailbox.short_prefix then msg_print_flags.print_prefix = TRUE;

/* if not default mailbox, prefix with mailbox entry name */
		if ^msg_facility_mailbox.default_mbx then msg_print_flags.print_ename = TRUE;

		if ^msg_facility_mailbox.short_format | ^short then
		     msg_print_flags.print_sender = TRUE;

		if ^msg_facility_mailbox.short_format | substr (msg_date_time, 1, 8) ^= last_msg_time then
		     msg_print_flags.print_date_and_time = TRUE;
		else if date_time - last_time > FIVE_MINUTES then msg_print_flags.print_time = TRUE;

		last_sender = message_sender;
		last_time = date_time;
		last_msg_time = substr (msg_date_time, 1, 8);

		call message_facility_$print_message (msg_facility_mailbox_ptr, iox_$user_io, message_id, addr (msg_print_flags), code);


		call message_facility_$set_seen_switch (msg_facility_mailbox_ptr, message_id, DELETE_UNHELD, code);
	     end;
	if mail_format_ptr ^= null () then free mail_format in (sys_area);
     end process_message;

/* Get person ID, project ID, and full name. */
get_person_and_project: procedure;
	if person = "" then call user_info_$whoami (person, project, "");

/* Since the full name is stored in the "sent_from" field of the mail_format
   structure, we don't get a value from the value segment for an anonymous
   user since it is important that the login name be there so that replies
   and acknowledgements get sent to the right place.  When we change this
   to use mail_system_ more fully, we can do the right thing. */

	if full_name = "" & person ^= "anonymous" then do;
		call value_$get (null (), PERMANENT_VALUES, rtrim (person) || ".full_name._", full_name, code);
		if code ^= 0 then call value_$get (null (), PERMANENT_VALUES, "full_name._", full_name, code);
		if code ^= 0 then full_name = person;
	     end;

	else if person = "anonymous" then full_name = person;
     end get_person_and_project;

%page;
%include event_call_info;
%page;
%include last_message_info;
%page;
%include mail_format;
%page;
%include message_info;
%page;
%include mseg_return_args;
%page;
%include msg_array;
%page;
%include msg_facility_mailbox;
%page;
%include msg_print_flags;
%page;
%include send_mail_info;
%page;
%include sub_err_flags;
     end message_facility_;
