/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1985 *
        *                                                         *
        *********************************************************** */

/* format: off */

/* Multics Control Point Manager -- The control point manager provides a simple form of mulitasking within a process.
   Each control point is given a separate stack and, optionally, a separate of set the standard I/O switches.  Once given
   control, a control point will continue to run until it either kills itself or attempts to block on an IPC event
   channel.  This module implements the primitive operations of the control point manager. */

/****^  HISTORY COMMENTS:
  1) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
     audit(86-10-20,Fawcett), install(86-11-03,MR12.0-1206):
     Written to support control point management in March 1985 by G. Palter
     based on C. Hornig's task_ctl_.
                                                   END HISTORY COMMENTS */

/* format: style3,linecom */

cpm_:
     procedure ();

ERROR_RETURN_FROM_CPM_:
	return;					/* not an entrypoint */


/* Parameters */

dcl	P_control_point_id	bit (36) aligned parameter;
dcl	P_code		fixed binary (35) parameter;

dcl	P_ccpi_ptr	pointer parameter;		/* create: -> description of the new control point */

dcl	P_user_cl_intermediary			/* *user_cl_intermediary: the user's CL intermediary */
			entry (bit (1) aligned) variable parameter;

dcl	P_userproc				/* generate_call*: the entrypoint to be called */
			entry (pointer) variable parameter;
dcl	P_userproc_info_ptr pointer parameter;		/* generate_call*: the argument to the user's entrypoint */

dcl	P_pushed_preferred_control_point		/* (push pop)_preferred_control_point: set ON => we ... */
			bit (1) aligned parameter;	/* ... pushed the preferred control point */

dcl	P_cpma_ptr	pointer parameter;		/* get_*_meters: -> the meters */

dcl	P_cpd_ptr		pointer parameter;		/* update_state_caller: -> the control point */
dcl	P_new_state	fixed binary parameter;	/* update_state_caller: new state for the control point */

dcl	P_mask		bit (36) aligned parameter;	/* *mask_ips_interrupts_caller: the current IPS mask */


/* Remaining declarations */

dcl	1 current_control_point_data			/* the current control point's definition */
			like control_point_data aligned based (current_cpd_ptr);
dcl	current_cpd_ptr	pointer;

dcl	1 parent_control_point_data			/* the identified control point's parent's definition */
			like control_point_data aligned based (control_point_data.parent);

dcl	1 io_switches	like control_point_data.io_switches aligned based (ios_ptr);
dcl	ios_ptr		pointer;

dcl	system_area	area based (system_area_ptr);
dcl	system_area_ptr	pointer;

dcl	1 decoded_control_point_id
			aligned,
	  2 stack_segno	bit (18) unaligned,
	  2 unique_bits	bit (18) unaligned;

dcl	1 userproc_arg_list aligned,
	  2 header	like arg_list.header,
	  2 arg_ptrs	(1) pointer;

dcl	generate_call_flags bit (36) aligned;
dcl	prior_state	fixed binary;
dcl	target_cpd_ptr	pointer;

dcl	stack_idx		fixed binary;

dcl	mask		bit (36) aligned;

dcl	(
	cpm_et_$already_started,
	cpm_et_$already_stopped,
	cpm_et_$cant_destroy_root,
	cpm_et_$cant_stop_root,
	cpm_et_$cant_wakeup_when_stopped,
	cpm_et_$control_point_not_found,
	cpm_et_$preferred_cant_be_stopped,
	cpm_et_$preferred_stack_overflow,
	cpm_et_$wakeup_ignored,
	error_table_$badcall,
	error_table_$out_of_sequence,
	error_table_$unimplemented_version
	)		fixed binary (35) external;

dcl	(
	sys_info$all_valid_ips_mask,
	sys_info$comm_privilege,
	sys_info$dir_privilege,
	sys_info$ipc_privilege,
	sys_info$rcp_privilege,
	sys_info$ring1_privilege,
	sys_info$seg_privilege,
	sys_info$soos_privilege
	)		bit (36) aligned external;

dcl	continue_to_signal_ entry (fixed binary (35));
dcl	(
	cpm_alm_$call_overseer,
	cpm_alm_$call_generate_call
	)		entry ();
dcl	cpm_alm_$switch_stacks
			entry (pointer);
dcl	cpm_initialize_	entry ();
dcl	cpm_overseer_$cl_intermediary
			entry (bit (36) aligned);
dcl	cpm_overseer_$generate_call
			entry (pointer, entry (pointer), pointer);
dcl	(
	cu_$get_cl_intermediary,
	cu_$set_cl_intermediary
	)		entry (entry (bit (36) aligned));
dcl	get_privileges_	entry () returns (bit (36) aligned);
dcl	get_system_free_area_
			entry () returns (pointer);
dcl	get_temp_segment_	entry (character (*), pointer, fixed binary (35));
dcl	hcs_$get_process_usage
			entry (pointer, fixed binary (35));
dcl	hcs_$reset_ips_mask entry (bit (36) aligned, bit (36) aligned);
dcl	hcs_$set_ips_mask	entry (bit (36) aligned, bit (36) aligned);
dcl	hcs_$set_stack_ptr	entry (pointer);
dcl	ioa_$rsnnl	entry () options (variable);
dcl	ipc_$reassign_call_channels
			entry (bit (36) aligned, bit (36) aligned);
dcl	ipc_$wait_for_an_event
			entry ();
dcl	release_temp_segment_
			entry (character (*), pointer, fixed binary (35));
dcl	sub_err_		entry () options (variable);
dcl	(
	system_privilege_$comm_priv_on,
	system_privilege_$comm_priv_off,
	system_privilege_$dir_priv_on,
	system_privilege_$dir_priv_off,
	system_privilege_$ipc_priv_on,
	system_privilege_$ipc_priv_off,
	system_privilege_$rcp_priv_on,
	system_privilege_$rcp_priv_off,
	system_privilege_$ring1_priv_on,
	system_privilege_$ring1_priv_off,
	system_privilege_$seg_priv_on,
	system_privilege_$seg_priv_off,
	system_privilege_$soos_priv_on,
	system_privilege_$soos_priv_off
	)		entry (fixed binary (35));

dcl	(addr, addwordno, baseno, baseptr, binary, bit, bool, clock, codeptr, currentsize, hbound, length, mod, null,
	stackbaseptr, string, substr, unspec)
			builtin;

dcl	(any_other, cleanup)
			condition;
%page;
/* Create a new control point which is left in the STOPPED state */

create:
     entry (P_ccpi_ptr, P_control_point_id, P_code);

	if stackbaseptr () -> stack_header.cpm_enabled = ""b
	then do;					/* first time in the process */
		call cpm_initialize_ ();
		current_cpd_ptr = stackbaseptr () -> stack_header.cpm_data_ptr;
	     end;

	ccpi_ptr = P_ccpi_ptr;			/* copy input parameter for the internal procedure */

	system_area_ptr = get_system_free_area_ ();

	mask = ""b;				/* for any_other handler */
	on any_other call any_other_handler ();

	cpd_ptr = null ();				/* for cleanup handler */
	on cleanup
	     begin;
		if cpd_ptr ^= null ()
		then call destroy_control_point (cpd_ptr);
	     end;

	call create_control_point ();			/* does most of the work */

	call push_call_frame (cpm_alm_$call_overseer, unspec (create_control_point_info),
	     create_control_point_info.initproc.entry, create_control_point_info.initproc.info_ptr);

	P_control_point_id = control_point_data.id;
	P_code = 0;				/* success */

	return;


/* Control arrives here iff an error occured while creating the control point */

ERROR_RETURN_FROM_CPM_$CREATE:
	if cpd_ptr ^= null ()
	then call destroy_control_point (cpd_ptr);
	return;					/* create_failure procedure has already set P_code */
%page;
/* Destroy the specified control point -- This entrypoint queues a call to cpm_$call_self_destruct onto the target control
   point's stack and then forces the scheduler to run that control point. */

destroy:
     entry (P_control_point_id, P_code);

	call check_initialization ("cpm_$destroy");	/* aborts if not initialized */

	call find_control_point (P_control_point_id);	/* sets cpd_ptr or aborts the call entirely */
	if cpd_ptr = addr (cpm_data_$root_control_point_data)
	then do;					/* the root control point is sacred */
		P_code = cpm_et_$cant_destroy_root;
		return;
	     end;

	call generate_call (P_control_point_id, call_self_destruct, null (), P_code);

	return;



/* This entrypoint is called by cpm_$destroy on the stack of the control point which is to be destroyed.  It does a
   non-local goto to the control point's destroy label which has been initialized to cpm_$self_destruct.  The non-local
   goto will unwind the entire stack allowing any cleanup handlers to be run. */

call_self_destruct:
     entry ();

	cpd_ptr = stackbaseptr () -> stack_header.cpm_data_ptr;

	if codeptr (control_point_data.destroy) = codeptr (self_destruct)
	then go to control_point_data.destroy;		/* transfer to the self_destruct entrypoint */
	else call sub_err_ (cpm_et_$cant_destroy_root, cpm_data_$subsystem_name, ACTION_CANT_RESTART, null (), 0);



/* This entrypoint is not actually called but, rather, is the target of the non-local goto performed above by
   cpm_$call_self_destruct.  This entrypoint will update the control point's state to DEAD and then invoke the scheduler
   to find something else to do. */

self_destruct:
     entry ();

	current_cpd_ptr, cpd_ptr = stackbaseptr () -> stack_header.cpm_data_ptr;

	mask = ""b;				/* for any_other handler */
	on any_other call any_other_handler ();

	call update_state (CPM_DESTROYED);		/* this control point is ready for destruction */

	do while ("1"b);				/* find something else to do */
	     call scheduler$find_runnable ();
	end;
%page;
/* Start the specified control point -- Places the control point into the READY state if it was STOPPED */

start:
     entry (P_control_point_id, P_code);

	call check_initialization ("cpm_$start");

	call find_control_point (P_control_point_id);	/* sets cpd_ptr or aborts the call entirely */

	mask = ""b;				/* for any_other handler */
	on any_other call any_other_handler ();

	if control_point_data.state = CPM_STOPPED
	then do;
		call update_state (CPM_READY);
		P_code = 0;			/* success */
	     end;

	else P_code = cpm_et_$already_started;		/* it's already running or blocked */

	return;



/* Stop the specified control point -- Places the control point into the STOPPED state if it was READY or BLOCKED */

stop:
     entry (P_control_point_id, P_code);

	call check_initialization ("cpm_$stop");

	call find_control_point (P_control_point_id);	/* sets cpd_ptr or aborts the call entirely */
	if cpd_ptr = addr (cpm_data_$root_control_point_data)
	then do;					/* the root control point is sacred */
		P_code = cpm_et_$cant_stop_root;
		return;
	     end;

	mask = ""b;				/* for any_other handler */
	on any_other call any_other_handler ();

	if (control_point_data.state = CPM_READY) | (control_point_data.state = CPM_BLOCKED)
	then do;
		call update_state (CPM_STOPPED);
		P_code = 0;			/* success */
	     end;

	else P_code = cpm_et_$already_stopped;		/* it was stopped earlier */

	return;
%page;
/* Block the current control point */

block:
     entry ();

	call check_initialization ("cpm_$block");	/* sets current_cpd_ptr */
	cpd_ptr = current_cpd_ptr;

	mask = ""b;				/* for any_other handler */
	on any_other call any_other_handler ();

	if control_point_data.state = CPM_READY
	then call update_state (CPM_BLOCKED);

	return;



/* Wakeup the specified control point -- Places the control point into the READY state if it was BLOCKED */

wakeup:
     entry (P_control_point_id, P_code);

	call check_initialization ("cpm_$wakeup");

	call find_control_point (P_control_point_id);	/* sets cpd_ptr or aborts the call entirely */

	mask = ""b;				/* for any_other handler */
	on any_other call any_other_handler ();

	if control_point_data.state = CPM_BLOCKED
	then do;
		call update_state (CPM_READY);
		P_code = 0;			/* success */
	     end;

	else if control_point_data.state = CPM_READY	/* it's already awake */
	then P_code = cpm_et_$wakeup_ignored;

	else P_code = cpm_et_$cant_wakeup_when_stopped;	/* it's stopped and must be started first */

	return;
%page;
/* Run the scheduler to find the highest priority ready control point and give control to said control point */

scheduler:
     entry ();

	call check_initialization ("cpm_$scheduler");

	mask = ""b;				/* for any_other handler */
	on any_other call any_other_handler ();

	call scheduler$find_runnable ();

	return;
%page;
/* Return the user CL intermediary for a given control point -- The user CL intermediary is invoked by
   cpm_cl_intermediary_ (the control point CL intermediary) before actually establishing a new command level or stopping
   the control point.  The user's intermediary can take whatever actions it desires and then inform the control point's
   intermediary either to return to the caller of cu_$cl (i.e., a "start" command) or to continue with the standard CL
   intermediary operation. */

get_user_cl_intermediary:
     entry (P_control_point_id, P_user_cl_intermediary, P_code);

	call check_initialization ("cpm_$get_user_cl_intermediary");

	call find_control_point (P_control_point_id);	/* sets cpd_ptr or aborts the call entirely */

	P_user_cl_intermediary = control_point_data.user_cl_intermediary;

	P_code = 0;				/* success */

	return;



/* Set the user CL intermediary for a given control point -- See the get_user_cl_intermediary entrypoint for a description
   of this feature. */

set_user_cl_intermediary:
     entry (P_control_point_id, P_user_cl_intermediary, P_code);

	call check_initialization ("cpm_$set_user_cl_intermediary");

	call find_control_point (P_control_point_id);	/* sets cpd_ptr or aborts the call entirely */

	control_point_data.user_cl_intermediary = P_user_cl_intermediary;

	P_code = 0;				/* success */

	return;



/* A "null" entry variable which should never be called -- Used as the initial value for user's CL intermediarys */

nulle:
     entry () options (variable);

	call sub_err_ (error_table_$badcall, cpm_data_$subsystem_name, ACTION_CANT_RESTART, null (), 0,
	     "The ""null"" entry value can not be invoked.");
%page;
/* Generate a call to the supplied user program in another control point */

generate_call:					/* ... run it immediately */
     entry (P_control_point_id, P_userproc, P_userproc_info_ptr, P_code);

	generate_call_flags = CPM_GC_FORCE_READY;
	go to BEGIN_GENERATE_CALL;


generate_call_preferred:				/* ... run it immediately as the preferred control point */
     entry (P_control_point_id, P_userproc, P_userproc_info_ptr, P_code);

	generate_call_flags = CPM_GC_FORCE_READY | CPM_GC_PUSH_PREFERRED;
	go to BEGIN_GENERATE_CALL;


generate_call_when_ready:				/* ... run it when it next becomes READY */
     entry (P_control_point_id, P_userproc, P_userproc_info_ptr, P_code);

	generate_call_flags = ""b;
	go to BEGIN_GENERATE_CALL;


BEGIN_GENERATE_CALL:
	call check_initialization ("cpm_$generate_call");

	call find_control_point (P_control_point_id);	/* sets cpd_ptr or aborts the call entirely */

	mask = ""b;				/* for any_other handler */
	on any_other call any_other_handler ();


	if current_cpd_ptr = cpd_ptr
	then do;

/* The call is to take place in this control point -- Invoke the user's program directly but first place the control point
   into the same state as it would be in after releasing control via the scheduler.  This action is necessary to insure
   that cpm_overseer_$generate_call will operate correctly.  See the internal procedure switch_control_points for an
   explanation of the various operations performed here. */

		call mask_ips_interrupts (mask);	/* can't be interrupted */
		current_control_point_data.ips_mask = mask;

		current_control_point_data.privileges = get_privileges_ ();
		call cu_$get_cl_intermediary (current_control_point_data.cl_intermediary);

		if current_control_point_data.swapped_switches
		     | different_switches (current_cpd_ptr, cpm_data_$previous_control_point)
		then call save_io_switches ();	/* save when cpm_overseer_$generate_call expects to restore */

		if trace_$transaction_begin (1)	/* disable tracing temporarily */
		then ;

		unspec (userproc_arg_list.header) = ""b;/* setup the argument list for the user's procedure */
		userproc_arg_list.header.call_type = Interseg_call_type;
		userproc_arg_list.header.arg_count = 1;
		userproc_arg_list.arg_ptrs (1) = addr (P_userproc_info_ptr);

		call cpm_overseer_$generate_call (addr (generate_call_flags), P_userproc, addr (userproc_arg_list));
						/* make the call */

		if trace_$transaction_end (1)		/* turn tracing back on */
		then ;

		if current_control_point_data.swapped_switches
		     | different_switches (current_cpd_ptr, cpm_data_$previous_control_point)
		then call restore_io_switches ();	/* restore our switches if we saved them above */

		call cu_$set_cl_intermediary (current_control_point_data.cl_intermediary);
		call restore_privileges ();		/* put our privileges and CL intermediary back */

		mask = current_control_point_data.ips_mask;
		call unmask_ips_interrupts (mask);	/* allow IPS interrupts again */
	     end;


	else do;

/* The call is to take place in some other control point -- Push the necessary frame on its stack and run it immediately
   if requested.  If we do schedule it immediately, we must also temporarily change this control point's state to READY so
   that, after the other control point finishes or blocks, this control point will be able to run and clean up the stack
   frames associated with this generate_call. */

		call push_call_frame (cpm_alm_$call_generate_call, generate_call_flags, P_userproc,
		     P_userproc_info_ptr);

		if generate_call_flags & CPM_GC_FORCE_READY
		then do;				/* run the other control point right now */
			prior_state = current_control_point_data.state;

			if current_control_point_data.state ^= CPM_READY
			then do;			/* ... must make the current control point READY */
				target_cpd_ptr = cpd_ptr;
				cpd_ptr = current_cpd_ptr;
				call update_state (CPM_READY);
				cpd_ptr = target_cpd_ptr;
			     end;

			/*** A cleanup handler to restore the current control point state isn't necessary because,
			     if a non-local goto occurs, it can only have happened while this control point was
			     ready and, if we were blocked, we are about to punt the call to ipc_$block which put us
			     into that state. */

			call scheduler$run_specific_control_point ();

			if prior_state ^= CPM_READY
			then do;			/* ... put the current control point back */
				cpd_ptr = current_cpd_ptr;
				call update_state (prior_state);
			     end;
		     end;
	     end;

	P_code = 0;				/* success */

	return;
%page;
/* Return the identity of the currently preferred control point -- The preferred control point is always given priority
   over all others whenever it is ready.  In addition, cu_$cl will actually only invoke a new control point when called in
   the preferred control point. */

get_preferred_control_point:
     entry () returns (bit (36) aligned);

	call check_initialization ("cpm_$get_preferred_control_point");

	if cpm_data_$preferred_control_point ^= null ()
	then return (cpm_data_$preferred_control_point -> control_point_data.id);
	else return ((36)"0"b);			/* none at present */



/* Set the preferred control point to the specified control point iff it isn't STOPPED */

set_preferred_control_point:
     entry (P_control_point_id, P_code);

	call check_initialization ("cpm_$set_preferred_control_point");

	call find_control_point (P_control_point_id);	/* sets cpd_ptr or aborts the entire call */
	if control_point_data.state = CPM_STOPPED
	then do;
		P_code = cpm_et_$preferred_cant_be_stopped;
		return;
	     end;

	mask = ""b;				/* for any_other handler */
	on any_other call any_other_handler ();

	if cpm_data_$preferred_control_point ^= cpd_ptr
	then do;					/* actually switching control points */
		call mask_ips_interrupts (mask);
		call switch_preferred_control_points ();
		call unmask_ips_interrupts (mask);
	     end;

	P_code = 0;				/* success */

	return;
%page;
/* Push the preferred control point -- Saves the current preferred control point on the top of the stack and makes the
   specified control point preferred.  If a control point is actually pushed, the P_pushed_preferred_control_point
   parameter will be set.  That parameter must be used in subsequent calls to pop the stack. */

push_preferred_control_point:
     entry (P_control_point_id, P_pushed_preferred_control_point, P_code);

	call check_initialization ("cpm_$push_preferred_control_point");

	P_pushed_preferred_control_point = "0"b;	/* initialize this parameter for cleanup handlers */

	call find_control_point (P_control_point_id);	/* sets cpd_ptr or aborts the entire call */
	if control_point_data.state = CPM_STOPPED
	then do;
		P_code = cpm_et_$preferred_cant_be_stopped;
		return;
	     end;

	if cpm_data_$preferred_control_point_stack.stack_depth
	     = hbound (cpm_data_$preferred_control_point_stack.cpd_ptr_stack, 1)
	then do;					/* the stack is already full */
		P_code = cpm_et_$preferred_stack_overflow;
		return;
	     end;

	mask = ""b;				/* for any_other handler */
	on any_other call any_other_handler ();

	if cpm_data_$preferred_control_point ^= cpd_ptr
	then do;					/* we're actually switching preferred control points */

		call mask_ips_interrupts (mask);

		cpm_data_$preferred_control_point_stack.stack_depth, stack_idx =
		     cpm_data_$preferred_control_point_stack.stack_depth + 1;

		cpm_data_$preferred_control_point_stack.cpd_ptr_stack (stack_idx) = cpm_data_$preferred_control_point;

		call switch_preferred_control_points ();

		P_pushed_preferred_control_point = "1"b;

		call unmask_ips_interrupts (mask);
	     end;

	P_code = 0;				/* success */

	return;
%page;
/* Pop the preferred control point stack by making the top of the stack the new preferred control point if and only if
   the P_pushed_preferred_control_point parameter is "1"b. */

pop_preferred_control_point:
     entry (P_pushed_preferred_control_point);

	call check_initialization ("cpm_$pop_preferred_control_point");

	mask = ""b;				/* for any_other handler */
	on any_other call any_other_handler ();

	if P_pushed_preferred_control_point		/* the caller did push it */
	then do;

		call mask_ips_interrupts (mask);

		P_pushed_preferred_control_point = "0"b;/* once is enough, thank you */

		if cpm_data_$preferred_control_point_stack.stack_depth > 0
		then do;				/* and there's something on the stack */
			stack_idx = cpm_data_$preferred_control_point_stack.stack_depth;
			cpm_data_$preferred_control_point_stack.stack_depth = stack_idx - 1;

			cpd_ptr = cpm_data_$preferred_control_point_stack.cpd_ptr_stack (stack_idx);

			call switch_preferred_control_points ();
		     end;

		call unmask_ips_interrupts (mask);
	     end;

	return;
%page;
/* Return the usage meters recorded for a given control point */

get_control_point_meters:
     entry (P_control_point_id, P_cpma_ptr, P_code);

	call check_initialization ("cpm_$get_control_point_meters");

	cpma_ptr = P_cpma_ptr;
	if control_point_meters_argument.version ^= CONTROL_POINT_METERS_ARGUMENT_VERSION_1
	then do;
		P_code = error_table_$unimplemented_version;
		return;
	     end;

	call find_control_point (P_control_point_id);	/* sets cpd_ptr or aborts the entire call */

	mask = ""b;				/* for any_other handler */
	on any_other call any_other_handler ();

	call update_meters (current_control_point_data.meters, (0));
						/* insure that all usage values are up-to-date */

	control_point_meters_argument.meters = control_point_data.meters;
	control_point_meters_argument.number_wanted, control_point_meters_argument.number_can_return =
	     MAX_NUMBER_OF_METERS;

	P_code = 0;				/* success */

	return;



/* Return the usage meters recorded for the control point scheduler */

get_scheduler_meters:
     entry (P_cpma_ptr, P_code);

	call check_initialization ("cpm_$get_scheduler_meters");

	cpma_ptr = P_cpma_ptr;
	if control_point_meters_argument.version ^= CONTROL_POINT_METERS_ARGUMENT_VERSION_1
	then do;
		P_code = error_table_$unimplemented_version;
		return;
	     end;

	control_point_meters_argument.meters = cpm_data_$global_meters.overhead;
	control_point_meters_argument.number_wanted, control_point_meters_argument.number_can_return =
	     MAX_NUMBER_OF_METERS;

	P_code = 0;				/* success */

	return;
%page;
/* Validate that control point management is enabled */

check_initialization:
     procedure (p_entrypoint_name);

dcl	p_entrypoint_name	character (*) parameter;

	if stackbaseptr () -> stack_header.cpm_enabled	/* we are on: find the current control point's definition */
	then current_cpd_ptr = stackbaseptr () -> stack_header.cpm_data_ptr;

	else call sub_err_ (error_table_$out_of_sequence, cpm_data_$subsystem_name, ACTION_CANT_RESTART, null (), 0,
		"At least one call to cpm_$create must preceed any call to ^a.", p_entrypoint_name);

	return;

     end check_initialization;



/* Find the control_point_data for the request control point or abort the call completely */

find_control_point:
     procedure (p_control_point_id);

dcl	p_control_point_id	bit (36) aligned parameter;

	string (decoded_control_point_id) = p_control_point_id;

	if cpm_data_$valid_control_points.map (binary (decoded_control_point_id.stack_segno, 18, 0))
	then do;					/* the given ID does identify a valid stack */
		cpd_ptr = baseptr (decoded_control_point_id.stack_segno) -> stack_header.cpm_data_ptr;
		if control_point_data.id = p_control_point_id
		then return;			/* and the stack does indeed belong to that control point */
	     end;

	/*** Control arrives here iff the supplied control point ID is invalid */
	P_code = cpm_et_$control_point_not_found;
	go to ERROR_RETURN_FROM_CPM_;

     end find_control_point;
%page;
/* Mask all IPS interrupts */

mask_ips_interrupts:
     procedure (p_mask);

dcl	p_mask		bit (36) aligned parameter;

	call hcs_$set_ips_mask (""b, p_mask);

     end mask_ips_interrupts;


/* Invoke mask_ips_interrupts -- This entrypoint exists to prevent making the mask_ips_interrupts internal procedure
   non-quick by invoking it from within an on unit or other non-quick procedure. */

mask_ips_interrupts_caller:
     entry (P_mask);

	call mask_ips_interrupts (P_mask);
	return;



/* Restore the IPS mask to its state prior to calling mask_ips_interrupts */

unmask_ips_interrupts:
     procedure (p_mask);

dcl	p_mask		bit (36) aligned parameter;

	if substr (p_mask, 36, 1) = "1"b
	then call hcs_$reset_ips_mask (p_mask, p_mask);

     end unmask_ips_interrupts;


/* Invoke unmask_ips_interrupts -- This entrypoint exists to prevent making the unmask_ips_interrupts internal procedure
   non-quick by invoking it from within an on unit or other non-quick procedure. */

unmask_ips_interrupts_caller:
     entry (P_mask);

	call unmask_ips_interrupts (P_mask);
	return;



/* The any_other handler established whenever we have masked IPS signals */

any_other_handler:
     procedure ();

	call unmask_ips_interrupts_caller (mask);

	call continue_to_signal_ ((0));		/* be sure the error gets through */

     end any_other_handler;
%page;
/* Restore the current control point's system privileges -- We need not worry about access to system_privilege_ as we only
   call it when we actually discover that a privilege has changed and the only way to change privileges is to use the
   system_privilege_ gate itself. */

restore_privileges:
     procedure ();

dcl	current_privileges	bit (36) aligned;

	current_privileges = get_privileges_ ();

	if current_control_point_data.privileges = current_privileges
	then return;				/* privileges are already correct */

	if bool (current_control_point_data.privileges, current_privileges, "0110"b) & sys_info$comm_privilege
	then if current_control_point_data.privileges & sys_info$comm_privilege
	     then call system_privilege_$comm_priv_on ((0));
	     else call system_privilege_$comm_priv_off ((0));

	if bool (current_control_point_data.privileges, current_privileges, "0110"b) & sys_info$dir_privilege
	then if current_control_point_data.privileges & sys_info$dir_privilege
	     then call system_privilege_$dir_priv_on ((0));
	     else call system_privilege_$dir_priv_off ((0));

	if bool (current_control_point_data.privileges, current_privileges, "0110"b) & sys_info$ipc_privilege
	then if current_control_point_data.privileges & sys_info$ipc_privilege
	     then call system_privilege_$ipc_priv_on ((0));
	     else call system_privilege_$ipc_priv_off ((0));

	if bool (current_control_point_data.privileges, current_privileges, "0110"b) & sys_info$rcp_privilege
	then if current_control_point_data.privileges & sys_info$rcp_privilege
	     then call system_privilege_$rcp_priv_on ((0));
	     else call system_privilege_$rcp_priv_off ((0));

	if bool (current_control_point_data.privileges, current_privileges, "0110"b) & sys_info$ring1_privilege
	then if current_control_point_data.privileges & sys_info$ring1_privilege
	     then call system_privilege_$ring1_priv_on ((0));
	     else call system_privilege_$ring1_priv_off ((0));

	if bool (current_control_point_data.privileges, current_privileges, "0110"b) & sys_info$seg_privilege
	then if current_control_point_data.privileges & sys_info$seg_privilege
	     then call system_privilege_$seg_priv_on ((0));
	     else call system_privilege_$seg_priv_off ((0));

	if bool (current_control_point_data.privileges, current_privileges, "0110"b) & sys_info$soos_privilege
	then if current_control_point_data.privileges & sys_info$soos_privilege
	     then call system_privilege_$soos_priv_on ((0));
	     else call system_privilege_$soos_priv_off ((0));

	return;

     end restore_privileges;
%page;
/* Save the current control point's standard I/O switches -- Always called with all IPS signals masked */

save_io_switches:
     procedure ();

	if current_control_point_data.swapped_switches
	then ios_ptr = addr (cpm_data_$root_control_point_data.io_switches);
	else ios_ptr = addr (current_control_point_data.io_switches);

	call iox_$move_attach (iox_$user_io, io_switches.user_io, (0));
	call iox_$move_attach (iox_$user_input, io_switches.user_input, (0));
	call iox_$move_attach (iox_$user_output, io_switches.user_output, (0));
	call iox_$move_attach (iox_$error_output, io_switches.error_output, (0));

	return;

     end save_io_switches;


/* Restore the current control point's standard I/O switches -- Always called with all IPS signals masked */

restore_io_switches:
     procedure ();

	if current_control_point_data.swapped_switches
	then ios_ptr = addr (cpm_data_$root_control_point_data.io_switches);
	else ios_ptr = addr (current_control_point_data.io_switches);

	call iox_$move_attach (io_switches.user_io, iox_$user_io, (0));
	call iox_$move_attach (io_switches.user_input, iox_$user_input, (0));
	call iox_$move_attach (io_switches.user_output, iox_$user_output, (0));
	call iox_$move_attach (io_switches.error_output, iox_$error_output, (0));

	return;

     end restore_io_switches;



/* Determines if the two specified control points use different sets of standard I/O switches */

different_switches:
     procedure (p_cpd_1_ptr, p_cpd_2_ptr) returns (bit (1) aligned);

dcl	1 cpd_1		like control_point_data aligned based (p_cpd_1_ptr);
dcl	1 cpd_2		like control_point_data aligned based (p_cpd_2_ptr);
dcl	(p_cpd_1_ptr, p_cpd_2_ptr)
			pointer parameter;

	if cpd_1.swapped_switches & cpd_2.swapped_switches
	then return ("0"b);				/* both control points are using the root's switches */

	else if cpd_1.group_id = cpd_2.group_id		/* same group: they use the same switches ... */
	then return (cpd_1.swapped_switches ^= cpd_2.swapped_switches);
						/* ... unless one is using the root's but not the other */

	else if (cpd_1.swapped_switches & (cpd_2.group_id = cpm_data_$root_control_point_data.group_id))
	     | (cpd_2.swapped_switches & (cpd_1.group_id = cpm_data_$root_control_point_data.group_id))
	then return ("0"b);				/* different groups: but one is swapped to the other */

	else return ("1"b);				/* different groups really using different switches */

     end different_switches;
%page;
/* The control point scheduler */

scheduler:
     procedure ();
	return;					/* not used */


/* Run the control point at the top of the ready queue -- If there are no ready control points, wait for an IPC event to
   make one or more control points eligible. */

scheduler$find_runnable:
     entry ();

	call update_meters (current_control_point_data.meters, cpm_data_$global_meters.overhead.n_schedules);

	if cpm_data_$ready_queue.first = null ()
	then do;					/* nothing ready at present */
		if (current_cpd_ptr ^= cpm_data_$preferred_control_point)
		     & (cpm_data_$preferred_control_point ^= null ())
		then if cpm_data_$preferred_control_point -> control_point_data.state = CPM_BLOCKED
		     then do;			/* ... preferred is blocked: better to hcs_$block in it */
			     cpd_ptr = cpm_data_$preferred_control_point;
			     call switch_control_points ();
			end;
		do while (cpm_data_$ready_queue.first = null ());
		     call ipc_$wait_for_an_event ();	/* ... we are preferred or he's not blocked: hcs_$block */
		end;
	     end;

	cpd_ptr = cpm_data_$ready_queue.first;		/* run whoever's on top */

	call switch_control_points ();		/* THUNK! */

	if cpm_data_$gc_control_points		/* there are control points we can eliminate */
	then call gc_dead_control_points ();

	call update_meters (cpm_data_$global_meters.overhead, current_control_point_data.meters.n_schedules);

	return;



/* Run the selected control point */

scheduler$run_specific_control_point:
     entry ();

	call update_meters (current_control_point_data.meters, cpm_data_$global_meters.overhead.n_schedules);

	call switch_control_points ();		/* THUNK! */

	if cpm_data_$gc_control_points		/* there are control points we can eliminate */
	then call gc_dead_control_points ();

	call update_meters (cpm_data_$global_meters.overhead, current_control_point_data.meters.n_schedules);

	return;
%page;
/* Actual code to switch from one control point to another */

switch_control_points:
     procedure ();

	if current_cpd_ptr = cpd_ptr			/* asked to run ourselves -- nothing to do */
	then return;

	call mask_ips_interrupts (mask);		/* can't be interrupted during this process */


/* Save the present IPS mask, system privileges, and CL intermediary in the control point's definition -- Each control
   point is permitted to manipulate these per-process values as if it were the only control point in the process.
   Therefore, we must save and restore these values whenever we switch control points to insure that each control point's
   settings of these mechansims will be undisturbed by other control points */

	current_control_point_data.ips_mask = mask;

	current_control_point_data.privileges = get_privileges_ ();

	call cu_$get_cl_intermediary (current_control_point_data.cl_intermediary);


/* Save our standard I/O switches if they are not the same set as used by the control point about to be run */

	if different_switches (current_cpd_ptr, cpd_ptr)
	then call save_io_switches ();


/* Switch Stacks -- We must inform inform ring-0 of the change so it will properly signal faults, IPS interrupts, etc. */

	cpm_data_$previous_control_point = current_cpd_ptr;

	if trace_$transaction_begin (1)		/* disable tracing -- let the new control point ... */
	then ;					/* ... reenable it if appropriate */

	call hcs_$set_stack_ptr (control_point_data.stack_ptr);

	call cpm_alm_$switch_stacks (control_point_data.stack_ptr);

	/*** Immediately after the above call, control returns to this point in the new control point we chose to run.
	     Consequently, current_control_point_data now refers to the control point referenced above as
	     control_point_data and the control point referenced above as current_control_point_data is now referenced
	     through cpm_data_$previous_control_point. */

	if trace_$transaction_end (1)			/* reenable tracing if it was running in this control point */
	then ;


/* Restore our I/O switches */

	if different_switches (current_cpd_ptr, cpm_data_$previous_control_point)
	then call restore_io_switches ();


/* Restore our saved CL intermediary, system privileges, and IPS mask */

	call cu_$set_cl_intermediary (current_control_point_data.cl_intermediary);

	call restore_privileges ();

	mask = current_control_point_data.ips_mask;
	call unmask_ips_interrupts (mask);		/* let IPS through again */

	return;

     end switch_control_points;
%page;
/* Finish the destruction of any dead control points */

gc_dead_control_points:
     procedure ();

	system_area_ptr = get_system_free_area_ ();	/* needed by destroy_control_point */

	call gc_worker (addr (cpm_data_$root_control_point_data));

	cpm_data_$gc_control_points = "0"b;		/* we've done all we can for now */

	return;



/* Actually walks the tree of control points looking for those which can be eliminated */

gc_worker:
     procedure (p_cpd_ptr) recursive;

dcl	1 p_control_point_data
			like control_point_data aligned based (p_cpd_ptr);
dcl	p_cpd_ptr		pointer parameter;

dcl	1 a_control_point_data
			like control_point_data aligned based (a_cpd_ptr);
dcl	a_cpd_ptr		pointer;

dcl	next_cpd_ptr	pointer;

	/*** Walk the control point's list of children and flush any of them that are dead */
	do a_cpd_ptr = p_control_point_data.first_child repeat (next_cpd_ptr) while (a_cpd_ptr ^= null ());
	     next_cpd_ptr = a_control_point_data.next_peer;
	     call gc_worker (a_cpd_ptr);
	end;

	/*** If this control point is dead and has no children, eliminate it */
	if (p_control_point_data.state = CPM_DESTROYED) & (p_control_point_data.first_child = null ())
	then call destroy_control_point (p_cpd_ptr);

	return;

     end gc_worker;

     end gc_dead_control_points;

     end scheduler;
%page;
/* Update the meters for a given control point or for the scheduler itself */

update_meters:
     procedure (p_meters, p_n_schedules);

dcl	1 p_meters	like control_point_meters aligned parameter;
dcl	p_n_schedules	fixed binary parameter;

dcl	1 local_usage	like process_usage aligned;
dcl	local_real_time	fixed binary (71);

	local_real_time = clock ();			/* to compute real-time change */

	local_usage.number_wanted = MAX_NUMBER_OF_METERS; /* get all the meters */
	call hcs_$get_process_usage (addr (local_usage), (0));

	call mask_ips_interrupts (mask);		/* update them uniterruptably */

	p_n_schedules = p_n_schedules + 1;		/* count the scheduling */

	p_meters.real_time = p_meters.real_time + local_real_time - cpm_data_$global_meters.last_meters.real_time;
	p_meters.usage = p_meters.usage + local_usage - cpm_data_$global_meters.last_meters.usage;

	cpm_data_$global_meters.last_meters.real_time = local_real_time;
	cpm_data_$global_meters.last_meters.usage = local_usage;

	call unmask_ips_interrupts (mask);

	return;

     end update_meters;
%page;
/* Changes the state of a control point */

update_state:
     procedure (p_new_state);

dcl	p_new_state	fixed binary parameter;

	if p_new_state = control_point_data.state	/* the control point is already in the requested state */
	then return;

	call mask_ips_interrupts (mask);

	if control_point_data.preferred & ((p_new_state = CPM_DESTROYED) | (p_new_state = CPM_STOPPED))
	then do;					/* only READY or BLOCKED control points can be preferred */
		call set_preferred_control_point (cpm_data_$root_control_point_data.id, (0));
	     end;					/* ... so try to switch it to the root control point */

	if control_point_data.state = CPM_READY		/* it's about to become not ready: remove it from the queue */
	then call remove_from_ready_queue ();

	control_point_data.state = p_new_state;

	if control_point_data.state = CPM_READY		/* it's been made ready: stick it into the ready queue */
	then call insert_into_ready_queue ();

	else if control_point_data.state = CPM_DESTROYED	/* it's been killed */
	then do;
		call ipc_$reassign_call_channels (control_point_data.id, parent_control_point_data.id);
		string (decoded_control_point_id) = control_point_data.id;
		cpm_data_$valid_control_points.map (binary (decoded_control_point_id.stack_segno, 18, 0)) = "0"b;
		cpm_data_$gc_control_points = "1"b;	/* ... we need to cleanup when next possible */
		cpm_data_$n_control_points = cpm_data_$n_control_points - 1;
	     end;

	call unmask_ips_interrupts (mask);

	return;

     end update_state;



/* Invoke update_state -- Called by cpm_overseer_$generate_call */

update_state_caller:
     entry (P_cpd_ptr, P_new_state);

	mask = ""b;				/* for any_other handler */
	on any_other call any_other_handler ();

	cpd_ptr = P_cpd_ptr;

	call update_state (P_new_state);

	return;
%page;
/* Sets the preferred control point -- Rethreads the ready queue to reflect the change in priority of the old and new
   preferred control points */

switch_preferred_control_points:
     procedure ();

dcl	old_preferred_cpd_ptr
			pointer;

	control_point_data.preferred = "1"b;		/* this control point is now preferred */

	if control_point_data.state = CPM_READY
	then do;					/* it's ready: rethread it to the top of the queue */
		call remove_from_ready_queue ();
		call insert_into_ready_queue ();
	     end;


/* Actually switch preferred control points */

	old_preferred_cpd_ptr = cpm_data_$preferred_control_point;

	cpm_data_$preferred_control_point = cpd_ptr;	/* establish the new preferred control point */

	cpd_ptr = old_preferred_cpd_ptr;


/* control_point_data now refers to the old preferred control point */

	control_point_data.preferred = "0"b;		/* it's no longer special */

	if control_point_data.state = CPM_READY
	then do;					/* rethread to reflect its lowered priority */
		call remove_from_ready_queue ();
		call insert_into_ready_queue ();
	     end;

	return;

     end switch_preferred_control_points;
%page;
/* Inserts a control point into the ready queue -- This procedure expects its caller to have masked IPS interrupts. */

insert_into_ready_queue:
     procedure ();

dcl	(prev_cpd_ptr, next_cpd_ptr)
			pointer;

	prev_cpd_ptr = null ();			/* assume it goes at the beginning of the queue */
	next_cpd_ptr = cpm_data_$ready_queue.first;

	if control_point_data.preferred		/* it should always have first priority */
	then go to INSERT_INTO_THE_LIST;

	do next_cpd_ptr = cpm_data_$ready_queue.first repeat (next_cpd_ptr -> control_point_data.next_ready)
	     while (next_cpd_ptr ^= null ());
	     if (next_cpd_ptr -> control_point_data.priority > control_point_data.priority)
		& ^next_cpd_ptr -> control_point_data.preferred
	     then go to INSERT_INTO_THE_LIST;		/* next one is lower priority and not preferred */
	     else prev_cpd_ptr = next_cpd_ptr;
	end;					/* add to the end of the queue if we fall through */

INSERT_INTO_THE_LIST:
	if prev_cpd_ptr = null ()			/* put it at the top of the queue */
	then cpm_data_$ready_queue.first = cpd_ptr;
	else prev_cpd_ptr -> control_point_data.next_ready = cpd_ptr;

	if next_cpd_ptr = null ()			/* put it at the end of the queue */
	then cpm_data_$ready_queue.last = cpd_ptr;
	else next_cpd_ptr -> control_point_data.prev_ready = cpd_ptr;

	control_point_data.prev_ready = prev_cpd_ptr;
	control_point_data.next_ready = next_cpd_ptr;

	return;

     end insert_into_ready_queue;



/* Removes a control point from the ready queue -- This procedure expects its caller to have masked IPS interrupts. */

remove_from_ready_queue:
     procedure ();

	if control_point_data.prev_ready = null ()	/* we are at the top of the queue */
	then cpm_data_$ready_queue.first = control_point_data.next_ready;
	else control_point_data.prev_ready -> control_point_data.next_ready = control_point_data.next_ready;

	if control_point_data.next_ready = null ()	/* we are at the bottom of the queue */
	then cpm_data_$ready_queue.last = control_point_data.prev_ready;
	else control_point_data.next_ready -> control_point_data.prev_ready = control_point_data.prev_ready;

	control_point_data.ready_queue = null ();	/* complete the removal process */

	return;

     end remove_from_ready_queue;
%page;
/* Creates a new control point */

create_control_point:
     procedure () options (non_quick);

dcl	code		fixed binary (35);

	if create_control_point_info.version ^= CREATE_CONTROL_POINT_INFO_VERSION_1
	then call create_failure (error_table_$unimplemented_version);

	call mask_ips_interrupts_caller (mask);		/* avoid interrupts until we can clean up properly */

	allocate control_point_data in (system_area) set (cpd_ptr);
	control_point_data.stack_ptr, control_point_data.parent, control_point_data.peers = null ();

	call unmask_ips_interrupts_caller (mask);	/* the cleanup handler will now work OK */

	call get_temp_segment_ (cpm_data_$subsystem_name, control_point_data.stack_ptr, code);
	if code ^= 0
	then call create_failure (code);


/* Setup most of the control point's data */

	decoded_control_point_id.stack_segno = baseno (control_point_data.stack_ptr);
	decoded_control_point_id.unique_bits = substr (bit (clock (), 71), 54, 18);
	control_point_data.id = string (decoded_control_point_id);

	control_point_data.state = CPM_STOPPED;		/* the user must start it */

	control_point_data.priority = create_control_point_info.priority;
	control_point_data.preferred = "0"b;		/* it's an ordinary control point */

	control_point_data.last_frame_ptr = null ();	/* cpm_alm_$switch_stacks hasn't been used yet */

	if create_control_point_info.independent
	then control_point_data.parent = addr (cpm_data_$root_control_point_data);
	else control_point_data.parent = stackbaseptr () -> stack_header.cpm_data_ptr;

	control_point_data.peers,			/* we haven't threaded it into any lists yet */
	     control_point_data.children, control_point_data.ready_queue = null ();

	if create_control_point_info.user_cl_intermediary_given
	then control_point_data.user_cl_intermediary = create_control_point_info.user_cl_intermediary;
	else control_point_data.user_cl_intermediary = nulle;

	control_point_data.comment = create_control_point_info.comment;

	control_point_data.ips_mask = sys_info$all_valid_ips_mask;
	substr (control_point_data.ips_mask, 36) = "1"b;	/* start with all IPS interrupts enabled */

	control_point_data.privileges = ""b;		/* start with no privileges */

	control_point_data.cl_intermediary = cpm_overseer_$cl_intermediary;
						/* start with the "standard" CL intermediary */

	control_point_data.io_switches = parent_control_point_data.io_switches;
	control_point_data.group_id = parent_control_point_data.group_id;
						/* we'll share our parent's switches until we've run once */

	control_point_data.meters = 0;		/* hasn't been used yet */


/* Initialize the new control point's stack by copying its parent's stack header */

	call mask_ips_interrupts_caller (mask);		/* the rest of this operation must not be interrupted */

	if trace_$transaction_begin (1)
	then ;					/* new stack should have standard operator pointers */

	control_point_data.stack_ptr -> stack_header = parent_control_point_data.stack_ptr -> stack_header;
	control_point_data.stack_ptr -> stack_header.stack_begin_ptr,
	     control_point_data.stack_ptr -> stack_header.stack_end_ptr =
	     addwordno (control_point_data.stack_ptr, currentsize (control_point_data.stack_ptr -> stack_header));

	control_point_data.stack_ptr -> stack_header.cpm_data_ptr = cpd_ptr;
	control_point_data.stack_ptr -> stack_header.cpm_enabled = substr(control_point_data.id,1,length(stack_header.cpm_enabled));

	unspec (control_point_data.stack_ptr -> stack_header.trace) = ""b;

	if trace_$transaction_end (1)
	then ;

	control_point_data.destroy = cv_entry_to_label_ (self_destruct);


/* Thread this control point into its parent's children chain */

	if parent_control_point_data.first_child = null ()
	then do;					/* new control point is the parent's first child */
		parent_control_point_data.first_child = cpd_ptr;
		control_point_data.prev_peer = null ();
	     end;
	else do;					/* parent has several other children already */
		parent_control_point_data.last_child -> control_point_data.next_peer = cpd_ptr;
		control_point_data.prev_peer = parent_control_point_data.last_child;
	     end;

	control_point_data.next_peer = null ();
	parent_control_point_data.last_child = cpd_ptr;

	cpm_data_$valid_control_points.map (binary (decoded_control_point_id.stack_segno, 18, 0)) = "1"b;
	cpm_data_$n_control_points = cpm_data_$n_control_points + 1;

	call unmask_ips_interrupts_caller (mask);

	return;



/* Reports an error during control point creation to our caller */

create_failure:
     procedure (p_code);

dcl	p_code		fixed binary (35) parameter;

	P_code = p_code;
	go to ERROR_RETURN_FROM_CPM_$CREATE;

     end create_failure;



/* Converts an entry variable into a label variable which will unwind the stack */

cv_entry_to_label_:
     procedure (p_entry) returns (label variable);

dcl	p_entry		entry variable parameter;

dcl	a_label		label variable;
dcl	1 a_label_decoded	aligned based (addr (a_label)),
	  2 code_ptr	pointer,
	  2 environment_ptr pointer;

	a_label_decoded.code_ptr = codeptr (p_entry);
	a_label_decoded.environment_ptr = control_point_data.stack_ptr -> stack_header.stack_begin_ptr;
						/* will unwind the stack to its first frame */

	return (a_label);

     end cv_entry_to_label_;

     end create_control_point;
%page;
/* Destroys an old control point -- This procedure is only called after all the control point's children have been
   destroyed.  It is also called during the creation of a control point if an error occurs after the control point is
   partially created. */

destroy_control_point:
     procedure (p_cpd_ptr);

dcl	p_cpd_ptr		pointer parameter;

dcl	1 p_control_point_data
			like control_point_data aligned based (p_cpd_ptr);
dcl	1 p_parent_control_point_data
			like control_point_data aligned based (p_control_point_data.parent);


/* Remove the dead control point from its parent's children chain */

	if p_control_point_data.parent ^= null ()
	then do;					/* there's a parent defined */
		p_parent_control_point_data.meters = p_parent_control_point_data.meters + p_control_point_data.meters;

		call mask_ips_interrupts_caller (mask); /* prevent interrupts while rechaining */

		/*** Check that the parent knows of the control point before rechaining -- This check is only
		     necessary if the control point's peer chain pointers are null as this could indicate that the
		     control point hadn't been chained before it was destroyed. */

		if p_control_point_data.prev_peer = null ()
		then do;				/* it might be the parent's first child */
			if p_parent_control_point_data.first_child = p_cpd_ptr
			then p_parent_control_point_data.first_child = p_control_point_data.next_peer;
		     end;
		else p_control_point_data.prev_peer -> control_point_data.next_peer = p_control_point_data.next_peer;

		if p_control_point_data.next_peer = null ()
		then do;				/* it might be the parent's last child */
			if p_parent_control_point_data.last_child = p_cpd_ptr
			then p_parent_control_point_data.last_child = p_control_point_data.prev_peer;
		     end;
		else p_control_point_data.next_peer -> control_point_data.prev_peer = p_control_point_data.prev_peer;

		p_control_point_data.parent, p_control_point_data.peers = null ();
		call unmask_ips_interrupts_caller (mask);
	     end;					/* the parent no longers knows about us */


/* Destroy the dead control point's stack */

	if p_control_point_data.stack_ptr ^= null ()
	then do;					/* its stack exists */
		call release_temp_segment_ (cpm_data_$subsystem_name, p_control_point_data.stack_ptr, (0));
		p_control_point_data.stack_ptr = null ();
	     end;


/* Complete the destruction of the control point */

	free p_control_point_data in (system_area);
	p_cpd_ptr = null ();			/* its destroyed */

	return;

     end destroy_control_point;
%page;
/* Creates a stack frame on the given stack to call the specified entrypoint --

   The stack frame is initialized appropriately so that, when cpm_alm_$switch_stacks returns on the new stack, the
   entrypoint specified by the p_caller parameter will be invoked.  As this entrypoint is invoked by a return with its
   stack frame already extant, it must be an ALM routine which then calls the actual PL/I caller entrypoint.  The
   correspondence between the ALM and PL/I procedures follows:

		      ALM entrypoint		      PL/I entrypoint
		cpm_alm_$call_overseer		cpm_overseer_$overseer
		cpm_alm_$call_generate_call		cpm_overseer_$generate_call

   The PL/I entrypoint prepares the environment according to the data in the p_caller_info parameter
   and then invokes the entrypoint specified as the p_callee parameter passing it the p_callee_info_ptr parameter as its
   single parameter.  When the callee entrypoint returns, the PL/I entrypoint returns to the ALM entrypoint.  The
   cpm_alm_$call_cpm_overseer_ entrypoint will then transfer to cpm_$self_destruct to destroy the control point; the
   cpm_alm_$call_cpm_generate_call_ entrypoint will then return to the prior stack frame on the stack which is normally a
   frame owned by cpm_$scheduler. */

push_call_frame:
     procedure (p_caller, p_caller_info, p_callee, p_callee_info_ptr) options (non_quick);

dcl	p_caller		entry () variable parameter;
dcl	p_caller_info	bit (*) aligned parameter;
dcl	p_callee		entry (pointer) variable parameter;
dcl	p_callee_info_ptr	pointer parameter;

dcl	1 call_frame	aligned based (sp),		/* the stack frame for p_caller */
	  2 header	like stack_frame aligned,	/* ... standard stack frame header */
	  2 arguments,				/* ... arguments to either p_callee or p_caller's PL/I */
	    3 caller_info_ptr
			pointer,
	    3 callee	entry (pointer) variable,
	    3 callee_arg_list_ptr
			pointer,
	    3 callee_info_ptr
			pointer,
	  2 caller_arg_list,			/* ... the argument list for p_caller's PL/I counterpart */
	    3 header	like arg_list.header,
	    3 arg_ptrs	(3) pointer,
	  2 callee_arg_list,			/* ... the argument list for p_callee */
	    3 header	like arg_list.header,
	    3 arg_ptrs	(1) pointer,
	  2 caller_info	bit (length (p_caller_info)) aligned;

	call mask_ips_interrupts_caller (mask);		/* creating the frame must not be interrupted */

	sb = control_point_data.stack_ptr;		/* find the target stack ... */
	sp = stack_header.stack_end_ptr;		/* ... and the place to lay down the caller frame */

	stack_frame.return_ptr = codeptr (p_caller);	/* where to begin execution after cpm_alm_$switch_stacks */
	stack_frame.translator_id = TRANSLATOR_ID_ALM;

	call_frame.caller_info = p_caller_info;		/* copy the parameters into the frame */
	call_frame.caller_info_ptr = addr (call_frame.caller_info);
	call_frame.callee = p_callee;
	call_frame.callee_info_ptr = p_callee_info_ptr;

	stack_frame.arg_ptr = addr (call_frame.caller_arg_list);
						/* record where this frame's argument list may be found */

	unspec (call_frame.caller_arg_list.header) = ""b; /* setup the caller's argument list */
	call_frame.caller_arg_list.header.call_type = Interseg_call_type;
	call_frame.caller_arg_list.header.arg_count = 3;	/* caller_flags, callee, callee_info_ptr */
	call_frame.caller_arg_list.arg_ptrs (1) = addr (call_frame.caller_info_ptr);
	call_frame.caller_arg_list.arg_ptrs (2) = addr (call_frame.callee);
	call_frame.caller_arg_list.arg_ptrs (3) = addr (call_frame.callee_arg_list_ptr);

	call_frame.callee_arg_list_ptr = addr (call_frame.callee_arg_list);
						/* record where the callee's argument list can be found */

	unspec (call_frame.callee_arg_list.header) = ""b; /* setup the callee's argument list */
	call_frame.callee_arg_list.header.call_type = Interseg_call_type;
	call_frame.callee_arg_list.header.arg_count = 1;
	call_frame.callee_arg_list.arg_ptrs (1) = addr (call_frame.callee_info_ptr);

	stack_frame.prev_sp = control_point_data.last_frame_ptr;
						/* when this call is done: return to the scheduler */

	control_point_data.last_frame_ptr = sp;		/* have cpm_alm_$switch_stacks return to this new frame */

	stack_frame.next_sp,			/* "push" the frame into existence */
						/* Note that we guarantee that the next stack frame */
						/* goes on a mod 16-word boundary. */
	     stack_header.stack_end_ptr =
	     addwordno (sp, (currentsize (call_frame) + 16 - mod (currentsize (call_frame), 16)));

	call unmask_ips_interrupts_caller (mask);

	return;

     end push_call_frame;

/* format: off */
%page; %include cpm_data_;
%page; %include cpm_internal_data;
%page; %include cpm_control_point_data;
%include cpm_ctrl_pt_meters;
%include process_usage;
%page; %include cpm_create_ctrl_pt_info;
%page; %include cpm_generate_call_flags;
%page; %include stack_header;
%page; %include stack_frame;
%page; %include arg_list;
%page; %include iox_dcls;
%page; %include sub_err_flags;
%page; %include trace_interface;
/* format: on */

     end cpm_;
