/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1985 *
        *                                                         *
        *********************************************************** */

/* format: off */

/* Command interface to the Multics Control Point Manager */

/****^  HISTORY COMMENTS:
  1) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
     audit(86-10-20,Fawcett), install(86-11-03,MR12.0-1206):
     Written to support control point management in March 1985 by G. Palter.
                                                   END HISTORY COMMENTS */

/* format: style3,linecom */

control_point_manager_call:
cpmc:
     procedure () options (variable);


dcl	return_value	character (return_value_lth) varying based (return_value_ptr);
dcl	return_value_ptr	pointer;
dcl	return_value_lth	fixed binary (21);
dcl	is_active_function	bit (1) aligned;

dcl	argument		character (argument_lth) based (argument_ptr);
dcl	argument_ptr	pointer;
dcl	argument_lth	fixed binary (21);
dcl	(n_arguments, argument_idx)
			fixed binary;

dcl	system_area	area based (system_area_ptr);
dcl	system_area_ptr	pointer;

dcl	1 users_entry	aligned based (users_entry_ptr),
	  2 entry		entry (pointer) variable,
	  2 info_ptr	pointer;
dcl	users_entry_ptr	pointer;

dcl	command_line	character (4 * sys_info$max_seg_size - 4) varying based (command_line_ptr);
dcl	command_line_ptr	pointer;

dcl	pi_preferred	bit (1) aligned based (pi_preferred_ptr);
dcl	pi_preferred_ptr	pointer;

dcl	sci_ptr		pointer;

dcl	1 cpmc_info	aligned,
	  2 ssu_arg_ptr	entry (pointer, fixed binary, pointer, fixed binary (21)) variable,
	  2 operation_idx	fixed binary;

dcl	i		fixed binary;

dcl	code		fixed binary (35);

dcl	CONTROL_POINT_MANAGER_CALL
			character (32) static options (constant) initial ("control_point_manager_call");

dcl	CONTROL_POINT_MANAGER_CALL_VERSION
			character (32) static options (constant) initial ("1.0");

dcl	SSU_ARG_PTR	character (32) static options (constant) initial ("arg_ptr");
dcl	SSU_GET_SUBSYSTEM_AND_REQUEST_NAME
			character (32) static options (constant) initial ("get_subsystem_and_request_name");

dcl	WHITESPACE	character (5) static options (constant) initial ("
	 ");						/* NL, HT, SP, VT, FF */

/* format: off */
dcl	OPERATION_NAMES	dimension (0:21, 2) character (20) varying static options (constant) initial
	         ("",		     "",		/* (the command itself) */
		"enabled",	     "invoked",
		"id",		     "",
		"create",		     "cr",	/* ENTRY {INFO_PTR} {-control_args} */
		"destroy",	     "",		/* ID */
		"start",		     "sr",	/* ID */
		"wakeup",		     "",		/* ID */
		"stop",		     "",		/* ID */
		"scheduler",	     "",
		"generate_call",	     "gc",	/* ID ENTRY {INFO_PTR} {-control_args} */
		"list",		     "ls",	/* {ID} {-control_args} */
		"probe",		     "pb",	/* ID */
		"program_interrupt",     "pi",	/* ID {-control_arg} */
		"run",		     "",		/* {-control_args} COMMAND_LINE */
		"cl_intermediary",	     "",		/* ID */
		"set_cl_intermediary",   "",		/* ID {ENTRY} {-control_args} */
		"preferred",	     "",		
		"set_preferred",	     "",		/* ID */
		"push_preferred",	     "",		/* ID */
		"pop_preferred",	     "",		/* FLAG */
		"enable",		     "invoke",
		"select",		     "sl");	/* ID */

dcl	OPERATION_IS_COMMAND_ONLY
			dimension (21) bit (1) aligned static options (constant) initial
	         (( 2) ("0"b),			/* enabled, id */
	          (11) ("1"b),
		( 1) ("0"b),			/* cl_intermediary */
		( 1) ("1"b),
		( 1) ("0"b),			/* preferred */
		( 1) ("1"b),
		( 1) ("0"b),			/* push_preferred */
		( 3) ("1"b));

dcl	OPERATION_ENTRIES	dimension (21) entry () variable;

dcl	STATE_NAMES	dimension (0:3) character (12) varying initial
	         ("DESTROYED",	"STOPPED",	"BLOCKED",	"READY");

/* format: on */

dcl	(
	MICROSECONDS_PER_HOUR
			initial (3600000000),
	MICROSECONDS_PER_MINUTE
			initial (60000000),
	MICROSECONDS_PER_SECOND
			initial (1000000)
	)		fixed binary (71) static options (constant);

dcl	(
	cpm_et_$already_started,
	cpm_et_$control_point_not_found,
	error_table_$active_function,
	error_table_$bad_arg,
	error_table_$bad_conversion,
	error_table_$badopt,
	error_table_$inconsistent,
	error_table_$noarg,
	error_table_$too_many_args
	)		fixed binary (35) external;

dcl	sys_info$max_seg_size
			fixed binary (19) external;

dcl	active_fnc_err_$suppress_name
			entry () options (variable);
dcl	com_err_		entry () options (variable);
dcl	com_err_$suppress_name
			entry () options (variable);
dcl	cpm_initialize_	entry ();
dcl	cu_$cp		entry (pointer, fixed binary (21), fixed binary (35));
dcl	cv_dec_check_	entry (character (*), fixed binary (35)) returns (fixed binary (35));
dcl	cv_entry_		entry (character (*), pointer, fixed binary (35)) returns (entry);
dcl	cv_oct_check_	entry (character (*), fixed binary (35)) returns (bit (36) aligned);
dcl	cv_ptr_		entry (character (*), fixed binary (35)) returns (pointer);
dcl	cv_ptr_$terminate	entry (pointer);
dcl	get_system_free_area_
			entry () returns (pointer);
dcl	get_entry_name_	entry (pointer, character (*), fixed binary (18), character (8) aligned, fixed binary (35));
dcl	get_temp_segment_	entry (character (*), pointer, fixed binary (35));
dcl	hcs_$fs_get_path_name
			entry (pointer, character (*), fixed binary, character (*), fixed binary (35));
dcl	ioa_		entry () options (variable);
dcl	ioa_$rsnnl	entry () options (variable);
dcl	ioa_$rsnpnnl	entry () options (variable);
dcl	pathname_		entry (character (*), character (*)) returns (character (168));
dcl	probe$probe	entry () options (variable);
dcl	program_interrupt$program_interrupt
			entry () options (variable);
dcl	release_temp_segment_
			entry (character (*), pointer, fixed binary (35));
dcl	requote_string_	entry (character (*)) returns (character (*));
dcl	ssu_$abort_subsystem
			entry () options (variable);
dcl	ssu_$arg_ptr	entry (pointer, fixed binary, pointer, fixed binary (21));
dcl	ssu_$destroy_invocation
			entry (pointer);
dcl	ssu_$get_info_ptr	entry (pointer) returns (pointer);
dcl	ssu_$get_procedure	entry (pointer, character (*), entry, fixed binary (35));
dcl	ssu_$print_message	entry () options (variable);
dcl	ssu_$return_arg	entry (pointer, fixed binary, bit (1) aligned, pointer, fixed binary (21));
dcl	ssu_$set_info_ptr	entry (pointer, pointer);
dcl	ssu_$set_procedure	entry (pointer, character (*), entry, fixed binary (35));
dcl	ssu_$standalone_invocation
			entry (pointer, character (*), character (*), pointer, entry, fixed binary (35));

dcl	cleanup		condition;

dcl	(addr, addwordno, baseptr, before, binary, codeptr, divide, environmentptr, float, hbound, index, lbound,
	length, mod, null, rtrim, stackbaseptr, string, substr)
			builtin;
%page;
/* control_point_manager_call: cpmc: entry () options (variable); */

	call ssu_$standalone_invocation (sci_ptr, CONTROL_POINT_MANAGER_CALL, CONTROL_POINT_MANAGER_CALL_VERSION,
	     null (), abort_control_point_manager_call, code);
	if code ^= 0
	then do;
		call com_err_ (code, CONTROL_POINT_MANAGER_CALL, "Creating a standalone invocation.");
		return;
	     end;

	on cleanup call ssu_$destroy_invocation (sci_ptr);

	cpmc_info.operation_idx = 0;			/* see commentary before operation_arg_ptr for details */
	cpmc_info.ssu_arg_ptr = cpm_$nulle;
	call ssu_$set_info_ptr (sci_ptr, addr (cpmc_info));

	call ssu_$return_arg (sci_ptr, n_arguments, is_active_function, return_value_ptr, return_value_lth);
	if n_arguments = 0
	then call display_usage_message_and_abort ("operation {operation_arguments}");

	call ssu_$arg_ptr (sci_ptr, 1, argument_ptr, argument_lth);

	do cpmc_info.operation_idx = lbound (OPERATION_ENTRIES, 1) to hbound (OPERATION_ENTRIES, 1);
	     do i = lbound (OPERATION_NAMES, 2) to hbound (OPERATION_NAMES, 2);
		if argument = OPERATION_NAMES (cpmc_info.operation_idx, i)
		then go to KNOWN_OPERATION;
	     end;
	end;

	call ssu_$abort_subsystem (sci_ptr, 0, "Unknown operation.  ""^a""", argument);


KNOWN_OPERATION:
	if is_active_function & OPERATION_IS_COMMAND_ONLY (cpmc_info.operation_idx)
	then call ssu_$abort_subsystem (sci_ptr, error_table_$active_function,
		"^/^-The ""^a"" keyword is not valid when used as an active function.",
		OPERATION_NAMES (cpmc_info.operation_idx, 1));

	call prepare_for_operation ();

	call OPERATION_ENTRIES (cpmc_info.operation_idx) ();
						/* perform the requested operation */

RETURN_FROM_CONTROL_POINT_MANAGER_CALL:
	call ssu_$destroy_invocation (sci_ptr);

	return;



/* Invoked by ssu_$abort_subsystem and ssu_$abort_line after printing an error message to terminate command execution */

abort_control_point_manager_call:
     procedure ();

	go to RETURN_FROM_CONTROL_POINT_MANAGER_CALL;

     end abort_control_point_manager_call;
%page;
/* Due to a bug in ssu_, the following procedures (operation_arg_ptr and get_command_and_operation_name) must be
   entrypoints directly into control_point_manager_call rather than internal procedures.  Therefore, they can only
   reference data which is made available through the subsystem's info_ptr. */

dcl	P_sci_ptr		pointer parameter;		/* common to both entrypoints */

dcl	1 based_cpmc_info	like cpmc_info aligned based (cpmc_info_ptr);
dcl	cpmc_info_ptr	pointer;



/* ssu_$arg_ptr replacement used by the individual operations */

operation_arg_ptr:
     entry (P_sci_ptr, P_argument_idx, P_argument_ptr, P_argument_lth);

dcl	P_argument_idx	fixed binary parameter;
dcl	P_argument_ptr	pointer parameter;
dcl	P_argument_lth	fixed binary (21) parameter;

	cpmc_info_ptr = ssu_$get_info_ptr (P_sci_ptr);

	call based_cpmc_info.ssu_arg_ptr (P_sci_ptr, (P_argument_idx + 1), P_argument_ptr, P_argument_lth);

	return;



/* ssu_$get_subsystem_and_request_name replacement used by the individual operations */

get_command_and_operation_name:
     entry (P_sci_ptr) returns (character (72) varying);

dcl	command_and_operation_name
			character (72) varying;

	cpmc_info_ptr = ssu_$get_info_ptr (P_sci_ptr);

	command_and_operation_name = rtrim (CONTROL_POINT_MANAGER_CALL);

	if based_cpmc_info.operation_idx > 0
	then do;					/* there's an operation in control at present */
		command_and_operation_name = command_and_operation_name || " (";
		command_and_operation_name =
		     command_and_operation_name || OPERATION_NAMES (based_cpmc_info.operation_idx, 1);
		command_and_operation_name = command_and_operation_name || ")";
	     end;

	return (command_and_operation_name);
%page;
/* This entrypoint is invoked by the create and generate_call operations in the other control point -- After invoking the
   user's entrypoint, this entrypint will then terminate the user's info_ptr as it was initiated by this command in the
   first place. */

run_users_entry:
     entry (P_users_entry_ptr);

dcl	P_users_entry_ptr	pointer parameter;

	users_entry_ptr = P_users_entry_ptr;

	on cleanup
	     begin;
		if users_entry.info_ptr ^= null ()
		then do;
			call cv_ptr_$terminate (users_entry.info_ptr);
			users_entry.info_ptr = null ();
		     end;
	     end;

	call users_entry.entry (users_entry.info_ptr);

	if users_entry.info_ptr ^= null ()
	then do;
		call cv_ptr_$terminate (users_entry.info_ptr);
		users_entry.info_ptr = null ();
	     end;

	return;



/* This entrypoint is invoked by the run operation in the new control point to invoke execute the command line and the
   release the temporary segment containing the command line. */

run_command_line:
     entry (P_command_line_ptr);

dcl	P_command_line_ptr	pointer parameter;

	command_line_ptr = P_command_line_ptr;

	on cleanup
	     begin;
		if command_line_ptr ^= null ()
		then call release_temp_segment_ (CONTROL_POINT_MANAGER_CALL, command_line_ptr, (0));
	     end;

	call cu_$cp (addwordno (addr (command_line), 1), length (command_line), (0));

	call release_temp_segment_ (CONTROL_POINT_MANAGER_CALL, command_line_ptr, (0));

	return;
%page;
/* This entrypoint is invoked by the program_interrupt operation in the target control point to actually signal
   program_interrupt -- The user can request that the control point be made the preferred control point before actually
   signalling program_interrupt.  Due to the interaction of cpm_$generate_call and the control point scheduler, setting
   the preferred control point must be deferred until we are running in the target control point. */

pi_signaller:
     entry (P_pi_preferred_ptr);

dcl	P_pi_preferred_ptr	pointer parameter;

	system_area_ptr = get_system_free_area_ ();

	pi_preferred_ptr = P_pi_preferred_ptr;

	on cleanup
	     begin;
		if pi_preferred_ptr ^= null ()
		then free pi_preferred in (system_area);
		pi_preferred_ptr = null ();
	     end;

	if pi_preferred
	then do;
		call cpm_$set_preferred_control_point (get_control_point_id_ (), code);
		if code ^= 0
		then call com_err_ (code, CONTROL_POINT_MANAGER_CALL,
			"Trying to make the control point ^12.3b preferred.", get_control_point_id_ ());
	     end;

	free pi_preferred in (system_area);		/* we don't need it anymore */
	pi_preferred_ptr = null ();

	call program_interrupt$program_interrupt ();	/* the command knows how to handle no handler */

	return;
%page;
/* Prepare to perform a specific operation */

prepare_for_operation:
     procedure ();

	n_arguments = n_arguments - 1;		/* operations don't count their name as an argument */


/* Replace ssu_$arg_ptr with a private procedure -- The private procedure will increment the requested argument index by
   one before calling the saved value of ssu_$arg_ptr.  In this way, the individual operations can be coded as if they
   were standalone commands as the private ssu_$arg_ptr will, effectively, make them ignore the existence of our real
   first argument -- the operation keyword. */

	call ssu_$get_procedure (sci_ptr, SSU_ARG_PTR, cpmc_info.ssu_arg_ptr, code);

	if code = 0				/* we have the reall ssu_$arg_ptr stashed away */
	then call ssu_$set_procedure (sci_ptr, SSU_ARG_PTR, operation_arg_ptr, code);

	if code ^= 0
	then call ssu_$abort_subsystem (sci_ptr, code, "Attempting to replace ssu_$arg_ptr.");


/* Replace ssu_$get_subsystem_and_request_name with a private procedure -- The private procedure uses the operation's
   primary name as the "request" name. */

	call ssu_$set_procedure (sci_ptr, SSU_GET_SUBSYSTEM_AND_REQUEST_NAME, get_command_and_operation_name, code);
	if code ^= 0
	then call ssu_$abort_subsystem (sci_ptr, code, "Attempting to replace ssu_$get_subsystem_and_request_name.");


/* Initialize the OPERATION_ENTRIES array -- Multics PL/I does not implement constant entry arrays. */

	OPERATION_ENTRIES (1) = is_cpm_enabled;
	OPERATION_ENTRIES (2) = get_id;
	OPERATION_ENTRIES (3) = create_control_point$create;
	OPERATION_ENTRIES (4) = destroy;
	OPERATION_ENTRIES (5) = start;
	OPERATION_ENTRIES (6) = wakeup;
	OPERATION_ENTRIES (7) = stop;
	OPERATION_ENTRIES (8) = scheduler;
	OPERATION_ENTRIES (9) = generate_call;
	OPERATION_ENTRIES (10) = list;
	OPERATION_ENTRIES (11) = probe;
	OPERATION_ENTRIES (12) = program_interrupt;
	OPERATION_ENTRIES (13) = create_control_point$run;
	OPERATION_ENTRIES (14) = get_cl_intermediary;
	OPERATION_ENTRIES (15) = set_cl_intermediary;
	OPERATION_ENTRIES (16) = get_preferred;
	OPERATION_ENTRIES (17) = set_preferred;
	OPERATION_ENTRIES (18) = push_preferred;
	OPERATION_ENTRIES (19) = pop_preferred;
	OPERATION_ENTRIES (20) = enable_cpm;
	OPERATION_ENTRIES (21) = select;

	return;

     end prepare_for_operation;
%page;
/* Display a usage message for the command or one of its operations and then abort the command */

display_usage_message_and_abort:
     procedure (p_arguments_description);

dcl	p_arguments_description
			character (*) parameter;

	if is_active_function
	then call active_fnc_err_$suppress_name (0, CONTROL_POINT_MANAGER_CALL, "Usage:  ^a^[ ^a^;^s^]^[ ^a^]",
		CONTROL_POINT_MANAGER_CALL, (cpmc_info.operation_idx > 0),
		OPERATION_NAMES (cpmc_info.operation_idx, 1), (length (p_arguments_description) > 0),
		p_arguments_description);
	else call com_err_$suppress_name (0, CONTROL_POINT_MANAGER_CALL, "Usage:  ^a^[ ^a^;^s^]^[ ^a^]",
		CONTROL_POINT_MANAGER_CALL, (cpmc_info.operation_idx > 0),
		OPERATION_NAMES (cpmc_info.operation_idx, 1), (length (p_arguments_description) > 0),
		p_arguments_description);

	call abort_control_point_manager_call ();	/* never returns */

     end display_usage_message_and_abort;



/* Abort the operation if it was given any arguments */

reject_any_arguments:
     procedure ();

	if n_arguments ^= 0
	then call ssu_$abort_subsystem (sci_ptr, 0, "No arguments may be given for this operation.");

	return;

     end reject_any_arguments;



/* Pickup a control argument's required argument */

fetch_next_argument:
     procedure (p_noarg_message);

dcl	p_noarg_message	character (*) parameter;

	if argument_idx = n_arguments
	then call ssu_$abort_subsystem (sci_ptr, error_table_$noarg, p_noarg_message);

	argument_idx = argument_idx + 1;
	call ssu_$arg_ptr (sci_ptr, argument_idx, argument_ptr, argument_lth);

	return;

     end fetch_next_argument;
%page;
/* Convert a character string into a control point ID -- Actually, this procedure sets cpd_ptr to locate the control point
   definition requested by the user.  A control point ID can be specified in one of two ways.  Either the entire ID must
   be given or only the first six digits (the stack segment number) must be supplied.  In either case, the ID must always
   be supplied as an octal number. */

cv_string_to_control_point_id:
     procedure ();

dcl	1 decoded_control_point_id			/* internal representation of a control point ID */
			aligned,
	  2 stack_segno	bit (18) unaligned,
	  2 unique_bits	bit (18) unaligned;

dcl	control_point_id	bit (36) aligned;
dcl	check_unique_bits	bit (1) aligned;

	control_point_id = cv_oct_check_ (argument, code);
	if code ^= 0
	then call ssu_$abort_subsystem (sci_ptr, error_table_$bad_conversion,
		"Control point IDs must be given as octal strings; not ""^a"".", argument);

	if control_point_id > "000000777777"b3		/* full ID given */
	then do;
		string (decoded_control_point_id) = control_point_id;
		check_unique_bits = "1"b;
	     end;
	else do;
		string (decoded_control_point_id) = substr (control_point_id, 19, 18) || "000000"b3;
		check_unique_bits = "0"b;
	     end;

	if cpm_data_$valid_control_points.map (binary (decoded_control_point_id.stack_segno, 18, 0))
	then do;					/* the given ID does identify a valid stack */
		cpd_ptr = baseptr (decoded_control_point_id.stack_segno) -> stack_header.cpm_data_ptr;
		if check_unique_bits
		then if control_point_data.id = control_point_id
		     then return;
		     else ;			/* unique IDs don't match */
		else return;			/* caller only supplied the stack segno */
	     end;

	call ssu_$abort_subsystem (sci_ptr, cpm_et_$control_point_not_found, "^6.3b^[^6.3b^;xxxxxx^]",
	     decoded_control_point_id.stack_segno, check_unique_bits, decoded_control_point_id.unique_bits);

     end cv_string_to_control_point_id;
%page;
/* Enable control point management */

enable_cpm:
     procedure ();

	call reject_any_arguments ();

	if stackbaseptr () -> stack_header.cpm_enabled
	then call ssu_$abort_subsystem (sci_ptr, 0, "Control point management is already enabled.");
	else call cpm_initialize_ ();

	return;

     end enable_cpm;


/* Determine whether control point management is enabled */

is_cpm_enabled:
     procedure ();

dcl	cpm_is_enabled	bit (1) aligned;

	call reject_any_arguments ();

	cpm_is_enabled = (stackbaseptr () -> stack_header.cpm_enabled ^= ""b);

	if is_active_function			/* return it into the command line */
	then if cpm_is_enabled
	     then return_value = "true";
	     else return_value = "false";

	else call ioa_ ("Control point management is^[ not^] enabled.", ^cpm_is_enabled);

	return;

     end is_cpm_enabled;



/* Determine the current control point's unique ID */

get_id:
     procedure ();

dcl	id_string		character (12);

	call reject_any_arguments ();

	call ioa_$rsnnl ("^12.3b", id_string, (0), get_control_point_id_ ());

	if is_active_function			/* return it into the command line */
	then return_value = id_string;

	else call ioa_ ("Current control point ID is ^a.", id_string);

	return;

     end get_id;
%page;
/* The "create" and "run" operations */

create_control_point:
     procedure ();
	return;					/* not used */

dcl	1 ccpi_header	like create_control_point_info.header aligned;

dcl	atd_argument	character (atd_argument_lth) based (atd_argument_ptr);
dcl	atd_argument_ptr	pointer;
dcl	atd_argument_lth	fixed binary (21);

dcl	control_point_id	bit (36) aligned;

dcl	users_entry_entrypoint_name
			character (256);
dcl	users_entry_ename	character (32);

dcl	(create_operation, run_operation, in_command_line, have_users_entry, have_users_info_ptr, display_the_id,
	start_the_control_point, prefer_the_control_point, prefer_the_control_point_given)
			bit (1) aligned;



/* Create a new control point -- This operation is pratically a direct interface to cpm_$create.  However, rather than
   invoking the user's initial procedure immediately in the new control point, we supply a private initial procedure whose
   sole purpose is to insure that the user's info_ptr is properly terminated. */

create_control_point$create:
     entry ();

	if n_arguments = 0
	then call display_usage_message_and_abort ("ENTRY {INFO_PTR} {-control_args}");

	create_operation = "1"b;
	run_operation = "0"b;

	go to CREATE_CONTROL_POINT;



/* Create a new control point to execute the supplied command line */

create_control_point$run:
     entry ();

	if n_arguments = 0
	then call display_usage_message_and_abort ("{-control_args} COMMAND_LINE");

	create_operation = "0"b;
	run_operation = "1"b;

	go to CREATE_CONTROL_POINT;



/* The actual code for both the "create" and "run" operations */

CREATE_CONTROL_POINT:
	system_area_ptr = get_system_free_area_ ();

	users_entry_ptr,				/* for cleanup handler */
	     command_line_ptr, ccpi_ptr = null ();
	have_users_entry, have_users_info_ptr = "0"b;

	on cleanup
	     begin;
		if create_operation
		then do;
			if users_entry_ptr ^= null ()
			then do;
				if have_users_info_ptr
				then do;
					call cv_ptr_$terminate (users_entry.info_ptr);
					have_users_info_ptr = "0"b;
				     end;
				free users_entry in (system_area);
				users_entry_ptr = null ();
			     end;
		     end;
		else /*** if run_operation then */
		     do;
			if command_line_ptr ^= null ()
			then call release_temp_segment_ (CONTROL_POINT_MANAGER_CALL, command_line_ptr, (0));
		     end;
		if ccpi_ptr ^= null ()
		then do;
			free create_control_point_info in (system_area);
			ccpi_ptr = null ();
		     end;
	     end;


/* Setup appropriate defaults for the new control point */

	display_the_id = "1"b;			/* tell the user what happened */

	if create_operation
	then do;
		allocate users_entry in (system_area) set (users_entry_ptr);
		ccpi_header.initproc.entry = run_users_entry;
		ccpi_header.initproc.info_ptr = users_entry_ptr;
		start_the_control_point = "0"b;	/* the user must explicitly start this control point ... */
		prefer_the_control_point = "0"b;	/* ... and explicitly give it control */
	     end;

	else /*** if run_operation then */
	     do;
		call get_temp_segment_ (CONTROL_POINT_MANAGER_CALL, command_line_ptr, code);
		if code ^= 0
		then call ssu_$abort_subsystem (sci_ptr, code, "Unable to obtain space for the command line.");
		command_line = "";			/* initialize the command line to empty */
		ccpi_header.initproc.entry = run_command_line;
		ccpi_header.initproc.info_ptr = command_line_ptr;
		start_the_control_point = "1"b;	/* have execution begin as soon as possible ... */
		prefer_the_control_point = "1"b;	/* ... and let it have real control */
	     end;

	ccpi_header.version = CREATE_CONTROL_POINT_INFO_VERSION_1;
	ccpi_header.comment = "";
	ccpi_header.priority = 1;
	string (ccpi_header.flags) = ""b;
	ccpi_header.independent = "1"b;


/* Parse the arguments which define the new control point */

	in_command_line = "0"b;			/* for run: we haven't seen the command line yet */
	prefer_the_control_point_given = "0"b;

	do argument_idx = 1 to n_arguments;

	     call ssu_$arg_ptr (sci_ptr, argument_idx, argument_ptr, argument_lth);

	     if ^in_command_line & (index (argument, "-") = 1)
	     then					/*  a control argument */
		if (argument = "-long") | (argument = "-lg")
		then display_the_id = "1"b;
		else if (argument = "-brief") | (argument = "-bf")
		then display_the_id = "0"b;

		else if (argument = "-start") | (argument = "-sr")
		then start_the_control_point = "1"b;
		else if (argument = "-no_start") | (argument = "-nsr")
		then start_the_control_point = "0"b;

		else if argument = "-preferred"
		then prefer_the_control_point, prefer_the_control_point_given = "1"b;
		else if argument = "-not_preferred"
		then do;
			prefer_the_control_point = "0"b;
			prefer_the_control_point_given = "1"b;
		     end;

		else if argument = "-priority"
		then do;
			call fetch_next_argument ("A number after ""-priority"".");
			ccpi_header.priority = cv_dec_check_ (argument, code);
			if code ^= 0
			then call ssu_$abort_subsystem (sci_ptr, error_table_$bad_conversion, "-priority ""^a""",
				argument);
		     end;

		else if (argument = "-comment") | (argument = "-com")
		then do;
			call fetch_next_argument ("A string after ""-comment"".");
			ccpi_header.comment = argument;
		     end;

		else if argument = "-independent"
		then ccpi_header.independent = "1"b;
		else if argument = "-dependent"
		then ccpi_header.independent = "0"b;

		else if argument = "-cl_intermediary"
		then do;
			call fetch_next_argument ("An entry after ""-cl_intermediary"".");
			ccpi_header.user_cl_intermediary = cv_entry_ (argument, null (), code);
			if code ^= 0
			then call ssu_$abort_subsystem (sci_ptr, code, "-cl_intermediary ""^a""", argument);
			ccpi_header.user_cl_intermediary_given = "1"b;
		     end;
		else if argument = "-default_cl_intermediary"
		then ccpi_header.user_cl_intermediary_given = "0"b;

		else if (argument = "-separate_io_switches") | (argument = "-sepios")
		then do;
			ccpi_header.separate_standard_iocbs = "1"b;
			ccpi_header.user_io_attach_desc_given = "0"b;
			if argument_idx < n_arguments
			then do;			/* check for an optional attach description */
				call ssu_$arg_ptr (sci_ptr, (argument_idx + 1), atd_argument_ptr,
				     atd_argument_lth);
				if index (atd_argument, "-") ^= 1
				then do;
					ccpi_header.user_io_attach_desc_given = "1"b;
					argument_idx = argument_idx + 1;
				     end;
			     end;
		     end;
		else if (argument = "-shared_io_switches") | (argument = "-shios")
		then ccpi_header.separate_standard_iocbs, ccpi_header.user_io_attach_desc_given = "0"b;

		else if run_operation & ((argument = "-string") | (argument = "-str"))
		then do;
			if argument_idx = n_arguments
			then call ssu_$abort_subsystem (sci_ptr, error_table_$noarg,
				"A command line after ""-string"".");
			in_command_line = "1"b;
		     end;

		else call ssu_$abort_subsystem (sci_ptr, error_table_$badopt, """^a""", argument);

	     else					/* not a control argument: depends on the operation */
		if create_operation
	     then do;
		     if ^have_users_entry
		     then do;
			     users_entry.entry = cv_entry_ (argument, null (), code);
			     if code ^= 0
			     then call ssu_$abort_subsystem (sci_ptr, code, """^a""", argument);
			     have_users_entry = "1"b;
			end;

		     else if ^have_users_info_ptr
		     then do;
			     users_entry.info_ptr = cv_ptr_ (argument, code);
			     if code ^= 0
			     then call ssu_$abort_subsystem (sci_ptr, code, """^a""", argument);
			     have_users_info_ptr = "1"b;
			end;

		     else call ssu_$abort_subsystem (sci_ptr, error_table_$too_many_args, """^a""", argument);
		end;

	     else /*** if run_operation then */
		do;
		     if length (command_line) > 0
		     then command_line = command_line || " ";
		     command_line = command_line || argument;
		     in_command_line = "1"b;
		end;
	end;

	if create_operation
	then do;
		if ^have_users_entry		/* there must be an initial procedure */
		then call ssu_$abort_subsystem (sci_ptr, error_table_$noarg,
			"An initial procedure must be specified.");
		if ^have_users_info_ptr		/* ... but its info_ptr is optional */
		then users_entry.info_ptr = null ();
	     end;

	else /*** if run_operation then */
	     do;
		if length (command_line) = 0
		then call ssu_$abort_subsystem (sci_ptr, error_table_$noarg, "A command line to be executed.");
	     end;

	if prefer_the_control_point_given & ^start_the_control_point
	then call ssu_$abort_subsystem (sci_ptr, error_table_$inconsistent,
		"""-no_start"" and ""-^[not_^;^]preferred"".", ^prefer_the_control_point);

	if ccpi_header.comment = ""
	then do;					/* supply a reasonable "name" for the control point */
		if create_operation
		then do;
			call hcs_$fs_get_path_name (codeptr (users_entry.entry), ((168)" "), (0), users_entry_ename,
			     (0));
			call get_entry_name_ (codeptr (users_entry.entry), users_entry_entrypoint_name, (0),
			     ((8)" "), (0));
			ccpi_header.comment = rtrim (users_entry_ename) || "$" || users_entry_entrypoint_name;
		     end;
		else /*** if run_operation then */
		     ccpi_header.comment = before (command_line, WHITESPACE);
	     end;


/* Create and, optionally, start the control point and mark it as preferred */

	if ccpi_header.user_io_attach_desc_given
	then ccpi_user_io_attach_desc_length = atd_argument_lth;
	else ccpi_user_io_attach_desc_length = 1;	/* PL/I abhors zero-length strings */

	allocate create_control_point_info in (system_area) set (ccpi_ptr);

	create_control_point_info.header = ccpi_header;
	create_control_point_info.user_io_attach_desc_length = ccpi_user_io_attach_desc_length;

	if create_control_point_info.user_io_attach_desc_given
	then create_control_point_info.user_io_attach_desc = atd_argument;

	call cpm_$create (ccpi_ptr, control_point_id, code);
	if code ^= 0
	then call ssu_$abort_subsystem (sci_ptr, code, "Creating the control point.");

	revert cleanup;				/* it's the new control point's responsibility to cleanup */

	free create_control_point_info in (system_area);	/* we don't need it anymore */

	if start_the_control_point
	then do;
		call cpm_$start (control_point_id, code);
		if code = 0
		then				/* it started: mark it preferred if requested */
		     if prefer_the_control_point
		     then do;
			     call cpm_$set_preferred_control_point (control_point_id, code);
			     if code ^= 0
			     then call ssu_$print_message (sci_ptr, code,
				     "Trying to make the control point ^12.3b preferred.", control_point_id);
			end;
		     else ;
		else call ssu_$print_message (sci_ptr, code, "Trying to start the control point ^12.3b.",
			control_point_id);
	     end;

	if display_the_id
	then call ioa_ ("Control point ^12.3b created^[^[, started, and marked preferred^; and started^]^].",
		control_point_id, start_the_control_point, prefer_the_control_point);

	return;

     end create_control_point;
%page;
/* Destroy the specified control point */

destroy:
     procedure ();

	if n_arguments ^= 1
	then call display_usage_message_and_abort ("ID");

	call ssu_$arg_ptr (sci_ptr, 1, argument_ptr, argument_lth);

	call cv_string_to_control_point_id ();		/* sets cpd_ptr or aborts */

	call cpm_$destroy (control_point_data.id, code);
	if code ^= 0
	then call ssu_$abort_subsystem (sci_ptr, code, "Trying to destroy the control point ^12.3b.",
		control_point_data.id);

	return;

     end destroy;



/* Start the specified control point if it is in the STOPPED state */

start:
     procedure ();

	if n_arguments ^= 1
	then call display_usage_message_and_abort ("ID");

	call ssu_$arg_ptr (sci_ptr, 1, argument_ptr, argument_lth);

	call cv_string_to_control_point_id ();		/* sets cpd_ptr or aborts */

	call cpm_$start (control_point_data.id, code);
	if code ^= 0
	then call ssu_$abort_subsystem (sci_ptr, code, "Trying to start the control point ^12.3b.",
		control_point_data.id);

	return;

     end start;
%page;
/* Wakeup the specified control point if it is in the BLOCKED state */

wakeup:
     procedure ();

	if n_arguments ^= 1
	then call display_usage_message_and_abort ("ID");

	call ssu_$arg_ptr (sci_ptr, 1, argument_ptr, argument_lth);

	call cv_string_to_control_point_id ();		/* sets cpd_ptr or aborts */

	call cpm_$wakeup (control_point_data.id, code);
	if code ^= 0
	then call ssu_$abort_subsystem (sci_ptr, code, "Trying to wakeup the control point ^12.3b.",
		control_point_data.id);

	return;

     end wakeup;



/* Stop the specified control point if it is in the READY or BLOCKED state */

stop:
     procedure ();

	if n_arguments ^= 1
	then call display_usage_message_and_abort ("ID");

	call ssu_$arg_ptr (sci_ptr, 1, argument_ptr, argument_lth);

	call cv_string_to_control_point_id ();		/* sets cpd_ptr or aborts */

	call cpm_$stop (control_point_data.id, code);
	if code ^= 0
	then call ssu_$abort_subsystem (sci_ptr, code, "Trying to stop the control point ^12.3b.",
		control_point_data.id);

	return;

     end stop;
%page;
/* Select the specified control point for preferred treatment -- If the control point is STOPPED, start it.  In any event,
   try to make it the preferred control point. */

select:
     procedure ();

	if n_arguments ^= 1
	then call display_usage_message_and_abort ("ID");

	call ssu_$arg_ptr (sci_ptr, 1, argument_ptr, argument_lth);

	call cv_string_to_control_point_id ();		/* sets cpd_ptr or aborts */

	call cpm_$start (control_point_data.id, code);
	if (code ^= 0) & (code ^= cpm_et_$already_started)
	then call ssu_$abort_subsystem (sci_ptr, code, "Trying to start the control point ^12.3b.",
		control_point_data.id);

	call cpm_$set_preferred_control_point (control_point_data.id, code);
	if code ^= 0
	then call ssu_$abort_subsystem (sci_ptr, code, "Trying to make the control point ^12.3b preferred.",
		control_point_data.id);

	return;

     end select;



/* Block the current control point and invoke the control point scheduler */

scheduler:
     procedure ();

	call reject_any_arguments ();

	call cpm_$block ();
	call cpm_$scheduler ();

	return;

     end scheduler;
%page;
/* Generate a call to the given entrypoint in another control point */

generate_call:
     procedure ();

dcl	(have_control_point_id, have_users_entry, have_users_info_ptr, immediate, preferred, preferred_given)
			bit (1) aligned;

	if n_arguments = 0
	then call display_usage_message_and_abort ("ID ENTRY {INFO_PTR} {-control_args}");

	system_area_ptr = get_system_free_area_ ();

	users_entry_ptr = null ();			/* for cleanup handler */
	have_control_point_id, have_users_entry, have_users_info_ptr = "0"b;

	on cleanup
	     begin;
		if users_entry_ptr ^= null ()
		then do;
			if have_users_info_ptr
			then do;
				call cv_ptr_$terminate (users_entry.info_ptr);
				have_users_info_ptr = "0"b;
			     end;
			free users_entry in (system_area);
			users_entry_ptr = null ();
		     end;
	     end;

	allocate users_entry in (system_area) set (users_entry_ptr);


/* Parse our arguments */

	immediate = "1"b;				/* run the other control point right away */
	preferred, preferred_given = "0"b;		/* ... but do not make it the preferred control point */

	do argument_idx = 1 to n_arguments;

	     call ssu_$arg_ptr (sci_ptr, argument_idx, argument_ptr, argument_lth);

	     if index (argument, "-") = 1
	     then					/* a control argument */
		if (argument = "-immediate") | (argument = "-im")
		then immediate = "1"b;
		else if (argument = "-defer_until_ready") | (argument = "-dur")
		then immediate = "0"b;

		else if argument = "-preferred"
		then preferred, preferred_given = "1"b;
		else if argument = "-not_preferred"
		then do;
			preferred = "0"b;
			preferred_given = "1"b;
		     end;

		else call ssu_$abort_subsystem (sci_ptr, error_table_$badopt, """^a""", argument);

	     else					/* a non-control argument */
		if ^have_control_point_id
	     then do;
		     call cv_string_to_control_point_id ();
		     have_control_point_id = "1"b;
		end;

	     else if ^have_users_entry
	     then do;
		     users_entry.entry = cv_entry_ (argument, null (), code);
		     if code ^= 0
		     then call ssu_$abort_subsystem (sci_ptr, code, """^a""", argument);
		     have_users_entry = "1"b;
		end;

	     else if ^have_users_info_ptr
	     then do;
		     users_entry.info_ptr = cv_ptr_ (argument, code);
		     if code ^= 0
		     then call ssu_$abort_subsystem (sci_ptr, code, """^a""", argument);
		     have_users_info_ptr = "1"b;
		end;

	     else call ssu_$abort_subsystem (sci_ptr, error_table_$too_many_args, """^a""", argument);
	end;

	if ^have_control_point_id			/* we must have someplace to execute the entrypoint */
	then call ssu_$abort_subsystem (sci_ptr, error_table_$noarg, "A control point ID must be specified.");

	if ^have_users_entry			/* ... and there must be an entrypoint */
	then call ssu_$abort_subsystem (sci_ptr, error_table_$noarg, "An entrypoint must be specified.");

	if ^have_users_info_ptr			/* ... but its info_ptr is optional */
	then users_entry.info_ptr = null ();

	if ^immediate & preferred_given
	then call ssu_$abort_subsystem (sci_ptr, error_table_$inconsistent,
		"""-defer_until_ready"" and ""-^[not_^]preferred"".", ^preferred);


/* Make the call */

	if immediate
	then if preferred
	     then call cpm_$generate_call_preferred (control_point_data.id, run_users_entry, users_entry_ptr, code);
	     else call cpm_$generate_call (control_point_data.id, run_users_entry, users_entry_ptr, code);
	else call cpm_$generate_call (control_point_data.id, run_users_entry, users_entry_ptr, code);

	if code ^= 0
	then call ssu_$abort_subsystem (sci_ptr, code, "Trying to generate a call into the control point ^12.3b.",
		control_point_data.id);

	return;

     end generate_call;
%page;
/* List the specified (or all) control points with optional metering data */

list:
     procedure ();

dcl	cpd_ptr_list	dimension (n_arguments) pointer based (cpd_ptr_list_ptr);
dcl	cpd_ptr_list_ptr	pointer;
dcl	n_control_points	fixed binary;

dcl	(list_all, display_meters)
			bit (1) aligned;
dcl	i		fixed binary;

	if n_arguments = 0
	then call display_usage_message_and_abort ("{IDs} {-control_args}");

	if stackbaseptr () -> stack_header.cpm_enabled = ""b
	then call ssu_$abort_subsystem (sci_ptr, 0, "Control point management is not enabled.");

	system_area_ptr = get_system_free_area_ ();

	cpd_ptr_list_ptr = null ();			/* for cleanup handler */

	on cleanup
	     begin;
		if cpd_ptr_list_ptr ^= null ()
		then do;
			free cpd_ptr_list in (system_area);
			cpd_ptr_list_ptr = null ();
		     end;
	     end;

	allocate cpd_ptr_list in (system_area) set (cpd_ptr_list_ptr);


/* Parse our arguments */

	list_all = "0"b;				/* caller must either supply IDs or "-all" */
	n_control_points = 0;

	display_meters = "0"b;			/* no meters unless explicitly requested */

	do argument_idx = 1 to n_arguments;

	     call ssu_$arg_ptr (sci_ptr, argument_idx, argument_ptr, argument_lth);

	     if index (argument, "-") = 1
	     then					/* a control argument */
		if (argument = "-all") | (argument = "-a")
		then list_all = "1"b;

		else if argument = "-meters"
		then display_meters = "1"b;
		else if argument = "-no_meters"
		then display_meters = "0"b;

		else call ssu_$abort_subsystem (sci_ptr, error_table_$badopt, """^a""", argument);

	     else					/* a non-control argument: must be a control point ID */
		do;
		     call cv_string_to_control_point_id ();
		     do i = 1 to n_control_points;	/* ... don't list a control point more than once */
			if cpd_ptr_list (i) = cpd_ptr
			then go to PARSE_NEXT_ARGUMENT;
		     end;
		     n_control_points = n_control_points + 1;
		     cpd_ptr_list (n_control_points) = cpd_ptr;
		end;

PARSE_NEXT_ARGUMENT:
	end;

	if list_all & (n_control_points > 0)
	then call ssu_$abort_subsystem (sci_ptr, error_table_$inconsistent, """-all"" and control point IDs.");

	else if ^list_all & (n_control_points = 0)
	then call ssu_$abort_subsystem (sci_ptr, error_table_$noarg,
		"At least one control point ID or ""-all"" must be specified.");


/* Now display the requested control points */

	if display_meters & (list_all | (n_control_points > 1))
	then do;					/* display scheduler meters if multiple control points */
		call ioa_ ("Scheduler overhead:");
		call display_metering_data (addr (cpm_data_$global_meters.overhead));
	     end;

	if list_all | (n_control_points > 1)
	then do;					/* display a header for multiple control points */
		call ioa_ ("^4tID^12t(Long ID)^25tDepth^33tState^51tComment");
		call ioa_ ("");
	     end;

	if list_all				/* list all control points */
	then call list_all_control_points (addr (cpm_data_$root_control_point_data), 0);

	else					/* list only the ones specificly requested */
	     do i = 1 to n_control_points;
		call list_control_point (cpd_ptr_list (i), -1);
	     end;

	free cpd_ptr_list in (system_area);		/* cleanup */
	cpd_ptr_list_ptr = null ();

	return;



/* List all control points recursively */

list_all_control_points:
     procedure (p_cpd_ptr, p_depth) recursive;

dcl	1 p_cpd		like control_point_data aligned based (p_cpd_ptr);
dcl	p_cpd_ptr		pointer;

dcl	p_depth		fixed binary parameter;

dcl	1 child_cpd	like control_point_data aligned based (child_cpd_ptr);
dcl	child_cpd_ptr	pointer;

	call list_control_point (p_cpd_ptr, p_depth);	/* display this control point's definition */

	do child_cpd_ptr = p_cpd.first_child repeat (child_cpd.next_peer) while (child_cpd_ptr ^= null ());
	     call list_all_control_points (child_cpd_ptr, (p_depth + 1));
	end;

	return;

     end list_all_control_points;



/* List a single control point */

list_control_point:
     procedure (p_cpd_ptr, p_depth);

dcl	1 p_cpd		like control_point_data aligned based (p_cpd_ptr);
dcl	p_cpd_ptr		pointer;

dcl	p_depth		fixed binary parameter;

dcl	1 parent_cpd	like control_point_data aligned based (parent_cpd_ptr);
dcl	parent_cpd_ptr	pointer;
dcl	depth		fixed binary;

dcl	1 cpma		like control_point_meters_argument aligned;

	if p_depth = -1
	then do;					/* caller has asked us to compute it */
		depth = 0;
		do parent_cpd_ptr = p_cpd.parent repeat (parent_cpd.parent) while (parent_cpd_ptr ^= null ());
		     depth = depth + 1;
		end;
	     end;

	else depth = p_depth;			/* caller has supplied it */

	call ioa_ ("^[*^; ^]^6.3b^9t(^12.3b)^27t^3d^33t^a^46t^a", (p_cpd_ptr = stackbaseptr () -> stack_header.cpm_data_ptr),
	     p_cpd.id, p_cpd.id, depth, STATE_NAMES (p_cpd.state), p_cpd.comment);

	if display_meters & (p_cpd.state > CPM_DESTROYED)
	then do;					/* ask cpm_ for the meters to insure they're up-to-date */
		cpma.version = CONTROL_POINT_METERS_ARGUMENT_VERSION_1;
		call cpm_$get_control_point_meters (p_cpd.id, addr (cpma), (0));
		call display_metering_data (addr (cpma.meters));
	     end;

	return;

     end list_control_point;



/* Display the supplied metering data */

display_metering_data:
     procedure (p_meters_ptr);

dcl	1 p_meters	like control_point_meters aligned based (p_meters_ptr);
dcl	p_meters_ptr	pointer;

	call ioa_ ("^11tRuns - ^6d^46tElapsed time - ^a", p_meters.n_schedules, format_time (p_meters.real_time));

	call ioa_ ("^11tCPU time - ^a^46tPage Faults - ^6d", format_time (p_meters.virtual_cpu_time),
	     p_meters.page_faults);

	call ioa_ ("^11tSegment Faults - ^6d^46tBounds Faults - ^6d", p_meters.segment_faults, p_meters.bounds_faults);

	call ioa_ ("^11tVTOC reads - ^6d^46tVTOC writes - ^6d", p_meters.vtoc_reads, p_meters.vtoc_writes);

	call ioa_ ("");

	return;

     end display_metering_data;



/* Format an elapsed time reading as HHH:MM:SS.SSSSSS */

format_time:
     procedure (p_time) returns (character (16));

dcl	p_time		fixed binary (71) parameter;

dcl	1 formatted_time	aligned,
	  2 hours		picture "999" unaligned,
	  2 colon_1	character (1) unaligned,
	  2 minutes	picture "99" unaligned,
	  2 colon_2	character (1) unaligned,
	  2 seconds	picture "99v.999999" unaligned;

dcl	(hours_value, minutes_value, seconds_value)
			fixed binary (71);

	seconds_value = mod (p_time, MICROSECONDS_PER_MINUTE);
	minutes_value = mod ((p_time - seconds_value), MICROSECONDS_PER_HOUR);
	hours_value = p_time - (minutes_value + seconds_value);

	string (formatted_time) = "000:00:00.000000";
	formatted_time.hours = divide (hours_value, MICROSECONDS_PER_HOUR, 10, 0);
	formatted_time.minutes = divide (minutes_value, MICROSECONDS_PER_MINUTE, 7, 0);
	formatted_time.seconds = float (seconds_value) / float (MICROSECONDS_PER_SECOND);

	return (string (formatted_time));

     end format_time;

     end list;
%page;
/* Invoke probe in the specified control point */

probe:
     procedure ();

	if n_arguments ^= 1
	then call display_usage_message_and_abort ("ID");

	call ssu_$arg_ptr (sci_ptr, 1, argument_ptr, argument_lth);

	call cv_string_to_control_point_id ();		/* sets cpd_ptr or aborts */

	call cpm_$generate_call_preferred (control_point_data.id, probe_caller, null (), code);
	if code ^= 0
	then call ssu_$abort_subsystem (sci_ptr, code, "Trying to invoke probe in the control point ^12.3b.",
		control_point_data.id);

	return;

     end probe;



/* Invoked by the above internal procedure in the desired control point to actually invoke probe */

probe_caller:
     entry ();

	call probe$probe ();

	return;
%page;
/* Signal program_interrupt in the specified control point */

program_interrupt:
     procedure ();

	if n_arguments = 0
	then call display_usage_message_and_abort ("ID {-control_arg}");

	system_area_ptr = get_system_free_area_ ();

	pi_preferred_ptr = null ();			/* for cleanup handler */

	on cleanup
	     begin;
		if pi_preferred_ptr ^= null ()
		then free pi_preferred in (system_area);
		pi_preferred_ptr = null ();
	     end;

	allocate pi_preferred in (system_area) set (pi_preferred_ptr);


/* Parse our arguments */

	cpd_ptr = null ();				/* no ID yet */
	pi_preferred = "1"b;			/* the target should become preferred */

	do argument_idx = 1 to n_arguments;

	     call ssu_$arg_ptr (sci_ptr, argument_idx, argument_ptr, argument_lth);

	     if index (argument, "-") = 1
	     then					/* a control argument */
		if argument = "-preferred"
		then pi_preferred = "1"b;
		else if argument = "-not_preferred"
		then pi_preferred = "0"b;

		else call ssu_$abort_subsystem (sci_ptr, error_table_$badopt, """^a""", argument);

	     else					/* a non-control argument: must be a control point ID */
		if cpd_ptr = null ()
	     then call cv_string_to_control_point_id ();	/* sets cpd_ptr or aborts */

	     else call ssu_$abort_subsystem (sci_ptr, error_table_$too_many_args, """^a""", argument);
	end;

	if cpd_ptr = null ()
	then call ssu_$abort_subsystem (sci_ptr, error_table_$noarg, "A control point ID must be specified.");


/* Push a call to signal program_interrupt onto the target control point's stack */

	revert cleanup;				/* pi_preferred now belongs to the other control point */

	call cpm_$generate_call (control_point_data.id, pi_signaller, pi_preferred_ptr, code);
	if code ^= 0
	then call ssu_$abort_subsystem (sci_ptr, code,
		"Trying to signal program_interrupt in the control point ^12.3b.", control_point_data.id);

	return;

     end program_interrupt;
%page;
/* Determine the user CL intermediary for a specific control point */

get_cl_intermediary:
     procedure ();

dcl	cl_intermediary	entry (bit (1) aligned) variable;
dcl	cl_intermediary_name
			character (1024) varying;
dcl	cl_intermediary_entrypoint_name
			character (256);
dcl	cl_intermediary_dirname
			character (168);
dcl	cl_intermediary_ename
			character (32);

	if n_arguments ^= 1
	then call display_usage_message_and_abort ("ID");

	call ssu_$arg_ptr (sci_ptr, 1, argument_ptr, argument_lth);

	call cv_string_to_control_point_id ();		/* sets cpd_ptr or aborts */

	call cpm_$get_user_cl_intermediary (control_point_data.id, cl_intermediary, code);
	if code ^= 0
	then call ssu_$abort_subsystem (sci_ptr, code, "Trying to get the CL intermediary of the control point ^12.3b",
		control_point_data.id);

	call hcs_$fs_get_path_name (codeptr (cl_intermediary), cl_intermediary_dirname, (0), cl_intermediary_ename, (0))
	     ;
	call get_entry_name_ (codeptr (cl_intermediary), cl_intermediary_entrypoint_name, (0), ((8)" "), (0));

	call ioa_$rsnpnnl ("(^a$^a, ^p)", cl_intermediary_name, (0),
	     pathname_ (cl_intermediary_dirname, cl_intermediary_ename), cl_intermediary_entrypoint_name,
	     environmentptr (cl_intermediary));

	if is_active_function			/* return it into the command line */
	then return_value = requote_string_ ((cl_intermediary_name));

	else call ioa_ ("The CL intermediary for the control point ^12.3b is ^a.", control_point_data.id,
		cl_intermediary_name);

	return;

     end get_cl_intermediary;
%page;
/* Set the user CL intermediary for a specific control point */

set_cl_intermediary:
     procedure ();

dcl	cl_intermediary	entry (bit (1) aligned) variable;
dcl	cl_intermediary_name
			character (1024) varying;
dcl	(have_control_point_id, have_cl_intermediary, use_default_cl_intermediary)
			bit (1) aligned;

	if n_arguments = 0
	then call display_usage_message_and_abort ("ID {ENTRY} {-control_arg}");

	have_control_point_id, have_cl_intermediary, use_default_cl_intermediary = "0"b;

	do argument_idx = 1 to n_arguments;

	     call ssu_$arg_ptr (sci_ptr, argument_idx, argument_ptr, argument_lth);

	     if index (argument, "-") = 1
	     then					/* a control argument */
		if (argument = "-default") | (argument = "-dft")
		then use_default_cl_intermediary = "1"b;

		else call ssu_$abort_subsystem (sci_ptr, error_table_$badopt, """^a""", argument);

	     else					/* a non-control argument */
		if ^have_control_point_id
	     then do;
		     call cv_string_to_control_point_id ();
		     have_control_point_id = "1"b;
		end;

	     else if ^have_cl_intermediary
	     then do;
		     cl_intermediary = cv_entry_ (argument, null (), code);
		     if code ^= 0
		     then call ssu_$abort_subsystem (sci_ptr, code, """^a""", argument);
		     have_cl_intermediary = "1"b;
		     cl_intermediary_name = argument;
		end;

	     else call ssu_$abort_subsystem (sci_ptr, error_table_$too_many_args, """^a""", argument);
	end;

	if ^have_control_point_id
	then call ssu_$abort_subsystem (sci_ptr, error_table_$noarg, "A control point ID must be specified.");

	if have_cl_intermediary & use_default_cl_intermediary
	then call ssu_$abort_subsystem (sci_ptr, error_table_$inconsistent, """-default"" and ""^a"".",
		cl_intermediary_name);

	else if ^have_cl_intermediary & ^use_default_cl_intermediary
	then call ssu_$abort_subsystem (sci_ptr, error_table_$noarg, "An entrypoint or ""-default"" must be specified.")
		;

	if have_cl_intermediary
	then call cpm_$set_user_cl_intermediary (control_point_data.id, cl_intermediary, code);

	else /*** if use_default_cl_intermediary then */
	     call cpm_$set_user_cl_intermediary (control_point_data.id, cpm_$nulle, code);

	if code ^= 0
	then call ssu_$abort_subsystem (sci_ptr, code,
		"Trying to set the CL intermediary of the control point ^12.3b to ^[""^a""^;its default value^].",
		control_point_data.id, have_cl_intermediary, cl_intermediary_name);

	return;

     end set_cl_intermediary;
%page;
/* Determine the unique ID of the preferred control point (if any) */

get_preferred:
     procedure ();

dcl	preferred_control_point_id
			bit (36) aligned;
dcl	id_string		character (12);

	call reject_any_arguments ();

	preferred_control_point_id = cpm_$get_preferred_control_point ();

	if is_active_function			/* return it into the command line */
	then if preferred_control_point_id = ""b
	     then return_value = "none";
	     else do;
		     call ioa_$rsnnl ("^12.3b", id_string, (0), preferred_control_point_id);
		     return_value = id_string;
		end;

	else if preferred_control_point_id = ""b
	then call ioa_ ("There is no preferred control point.");
	else call ioa_ ("Preferred control point ID is ^12.3b.", preferred_control_point_id);

	return;

     end get_preferred;



/* Set the preferred control point */

set_preferred:
     procedure ();

	if n_arguments ^= 1
	then call display_usage_message_and_abort ("ID");

	call ssu_$arg_ptr (sci_ptr, 1, argument_ptr, argument_lth);

	call cv_string_to_control_point_id ();		/* sets cpd_ptr or aborts */

	call cpm_$set_preferred_control_point (control_point_data.id, code);
	if code ^= 0
	then call ssu_$abort_subsystem (sci_ptr, code, "Trying to make the control point ^12.3b preferred.",
		control_point_data.id);

	return;

     end set_preferred;
%page;
/* Set the preferred control point and push the previous one onto the preferred control point stack */

push_preferred:
     procedure ();

dcl	pushed_ok		bit (1) aligned;

	if n_arguments ^= 1
	then call display_usage_message_and_abort ("ID");

	call ssu_$arg_ptr (sci_ptr, 1, argument_ptr, argument_lth);

	call cv_string_to_control_point_id ();		/* sets cpd_ptr or aborts */

	call cpm_$push_preferred_control_point (control_point_data.id, pushed_ok, code);
	if code ^= 0
	then call ssu_$abort_subsystem (sci_ptr, code,
		"Trying to push the preferred stack and make the control point ^12.3b preferred.",
		control_point_data.id);

	if is_active_function			/* return an indication of success into the command line */
	then if pushed_ok
	     then return_value = "true";
	     else return_value = "false";

	return;

     end push_preferred;
%page;
/* Pop the top entry off the preferred control point stack and make it preferred */

pop_preferred:
     procedure ();

dcl	was_pushed	bit (1) aligned;

	if n_arguments ^= 1
	then call display_usage_message_and_abort ("FLAG");

	call ssu_$arg_ptr (sci_ptr, 1, argument_ptr, argument_lth);

	if index (argument, "-") = 1
	then call ssu_$abort_subsystem (sci_ptr, error_table_$badopt, """^a""", argument);

	else if argument = "true"
	then was_pushed = "1"b;
	else if argument = "false"
	then was_pushed = "0"b;

	else call ssu_$abort_subsystem (sci_ptr, error_table_$bad_arg, """^a""", argument);

	call cpm_$pop_preferred_control_point (was_pushed);

	return;

     end pop_preferred;

/* format: off */
%page; %include cpm_entries;
%page; %include cpm_internal_data;
%page; %include cpm_control_point_data;
%include cpm_ctrl_pt_meters;
%include process_usage;
%page; %include cpm_create_ctrl_pt_info;
%page; %include stack_header;
/* format: on */

     end control_point_manager_call;
