/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1990   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(74-01-01,Klinger), approve(85-01-14,MCR7139),
     audit(85-12-16,GDixon), install(85-12-19,MR12.0-1003):
      Written 1974 by Ross Klinger.
  2) change(75-08-16,Grady), approve(85-01-14,MCR7139), audit(85-12-16,GDixon),
     install(85-12-19,MR12.0-1003):
      Modified by Mike Grady to add -ordered_fields.
  3) change(82-05-11,GDixon), approve(85-01-14,MCR7139),
     audit(85-12-16,Unknown), install(85-12-19,MR12.0-1003):
      Modified by Gary Dixon to generalize -field, allow
      non_case_sensitive sorting, greater control over handling of
      duplicates, use of regular expression sort unit/field
      delimiters, etc.
  4) change(83-06-01,Schimke), approve(85-01-14,MCR7139),
     audit(85-12-16,GDixon), install(85-12-19,MR12.0-1003):
      Modified to fix an error in the -to regular expression handling code
      which was not stripping off the delimiters.
  5) change(83-08-01,Schimke), approve(85-01-14,MCR7139),
     audit(85-12-16,GDixon), install(85-12-19,MR12.0-1003):
      Modified by Dave Schimke to add -numeric and -integer global
      sort modes.  Renamed the -segment and -sm control args to
      -output_file and -of.
  6) change(84-04-05,GDixon), approve(85-01-14,MCR7139),
     audit(85-12-16,Unknown), install(85-12-19,MR12.0-1003):
      Modified by Gary Dixon to add the sort_strings (sstr) entrypoint.
  7) change(84-12-12,Lippard), approve(85-01-16,MCR7139),
     audit(85-12-16,GDixon), install(85-12-17,MR12.0-1001):
      Modified by Jim Lippard to prevent sub_error_handler from
      terminating execution (sort_seg_ takes care of it) and make
      multiple -field and -ordered_field control args aggregate
      instead of overriding.
  8) change(85-12-18,Lippard), approve(85-12-19,PBF7139),
     audit(85-12-19,GDixon), install(85-12-19,MR12.0-1003):
      Modified to keep proper field count when multiple fields are specified
      after one -field control arg.
  9) change(90-03-15,Vu), approve(90-03-15,MCR8162), audit(90-03-21,Kallstrom):
      The sstr command fails when one of the strings to be sorted contains a
      newline character.
                                                   END HISTORY COMMENTS */


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/*									*/
	/* Name: sort_seg								*/
	/*									*/
	/* Command for sorting segments or strings, based upon one or more sort fields within	*/
	/* sort units.								*/
	/*									*/

sort_seg:
ss:	
sort_file:
sf:	procedure options(variable);

    dcl	Ifl			fixed bin,	/* index into si.field array.			*/
	Itriple			fixed bin,
	Sdescending		bit(1),		/* on if -descending ctl_arg was given.		*/
	Sinteger 		          bit(1),		/* on if -integer ctl_arg given.           	*/
	Snon_case_sensitive		bit(1),		/* on if -non_case_sensitive ctl_arg given.	*/
	Snumeric   		bit(1),		/* on if -numeric ctl_arg given.        	*/
	Syes			bit(1),
	bc			fixed bin(24),
	code			fixed bin(35),
	descending_sort		fixed bin,	/* detect whether -dsc or -asc ctl_args appear.	*/
						/*   values: SS_unset, ASCENDING, DESCENDING	*/
	equal_ent			char(32),
	field_sort		fixed bin,	/* type of sort: -all, -field or -ordered_field	*/
						/*   values: ALL, FIELD, ORDERED_FIELD		*/
	in_dir			char(168),
	in_ent			char(32),
	number			fixed bin,	/* temporary to hold a converted number.	*/
	op_list			char(256) varying,
	out_dir			char(168),
	out_ent			char(32),
	out_len			fixed bin(21),
	q			fixed bin,
	1 si			aligned,
	  2 header		like ss_info.header,
	  2 field (estimate_fields()) like ss_info.field,
	sort_output		fixed bin,	/* Type of output: -replace or -output_file	*/
						/*   values: SS_unset, REPLACE, SEGMENT		*/
	type			fixed bin(2),
	undelim_char_index		fixed bin(21);

    dcl  (addcharno, addr, convert, divide, index, length,
          max, null, search, substr)
				builtin;

    dcl	cleanup			condition,
	sub_error_		condition;

    dcl	command_query_$yes_no	entry() options (variable),
	expand_pathname_		entry (char(*), char(*), char(*), fixed bin(35)),
	get_equal_name_		entry (char(*), char(*), char(*), fixed bin(35)),
	hcs_$status_minf		entry (char(*), char(*), fixed bin(1), fixed bin(2), fixed bin(24),
				     fixed bin(35)),
	requote_string_		entry (char(*)) returns(char(*)),
	sort_seg_$seg		entry (char(*), ptr, char(*), char(*), char(*), char(*), fixed bin(21),
				     fixed bin(21), fixed bin(35)),
	sort_seg_$string		entry (char(*), ptr, char(*), char(*), fixed bin(21), fixed bin(21),
				     fixed bin(35)),
	user_info_$absentee_queue	entry (fixed bin);

    dcl  (ALL			init(1),
	FIELD			init(2),
	ORDERED_FIELD		init(3)) fixed bin int static options(constant),
         (ASCENDING			init(1),
	DESCENDING		init(2)) fixed bin int static options(constant),
	CHASE			init(1) fixed bin(1) int static options(constant),
         (CHECK_NULLS		init("1"b),
          NO_CHECK_NULLS		init("0"b)) bit(1) int static options(constant),
         (FALSE			init("0"b),
	TRUE			init("1"b)) bit(1) int static options(constant),
	NL			char(1) int static options(constant) init("
"),
         (REPLACE			init(2),
	SEGMENT			init(1)) fixed bin int static options(constant),
         (error_table_$bad_arg,
	error_table_$badopt,
	error_table_$data_seq_error,
	error_table_$dirseg,
	error_table_$noarg,
	error_table_$out_of_bounds,
	error_table_$too_many_args,
	error_table_$too_many_names,
	error_table_$wrong_no_of_args,
	error_table_$zero_length_seg)
				fixed bin(35) ext static;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* STATIC ERROR MESSAGE TEXT							*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

    dcl	BAD_DELIM_LENGTH		char(153) int static options(constant) init(
"^a ^a
The delimited string length must be an integer from 1 to 131071.
If you wish ^a to be treated as a character string delimiter, use:
  ^a -string ^a"),
	BAD_FIELD_START_INDEX	char(152) int static options(constant) init(
"^a ^a
The field_start index must be an integer from 1 to 131071.
If you wish ^a to be treated as a character field delimiter, use:
  ^a ^a -string ^a"),
	BAD_FIELD_LENGTH		char(121) int static options(constant) init(
"The field_end length must be an integer from 1 to 131071, or -1 to use a length
equal to the remainder of the sort unit."),
	BAD_FIELD_END_INDEX		char(150) int static options(constant) init(
"^a ^a
The field_end index must be an integer from 1 to 131071.
If you wish -a to be treated as a character field delimiter, use:
  ^a ^a -string -a"),
	DELIM_SYNTAX		char(95) int static options(constant) init(
"Allowed syntax is:	-delimiter L
		-delimiter STR
		-delimiter /REGEXP/
		-delimiter -string STR"),
	FIELD_LENGTH_SYNTAX		char(191) int static options(constant) init(
"Allowed syntax is:  ^a field_start field_length {sort_controls}
field_length can be: L (an integer length)
		 -for L
		 -to E (a field end index)
		 -to STR
		 -to /REGEXP/
		 -to -string STR"),
	FIELD_MODES_SYNTAX		char(224) int static options(constant) init(
"Allowed syntax is:   ^a field_start field_length {sort_controls}
sort_controls can be: ascending, asc
		  descending, dsc
		  case_sensitive, cs
		  non_case_sensitive, ncs
		  character, ch
		  numeric, num
		  integer, int"),
	FIELD_START_SYNTAX		char(163) int static options(constant) init(
"Allowed syntax is:	^a field_start field_length {sort_controls}
field_start can be:	S (field start index)
		-from S
		-from STR
		-from /REGEXP/
		-from -string STR"),
	OFL_SYNTAX		char(83) int static options(constant) init(
"Allowed syntax is:	^a start_index field_length direction
direction can be:	asc, dsc");

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* ENTRYPOINT: sort_seg, ss, sort_file, sf					*/
	/* 1) Get arg count, make sure sort_seg is only invoked as a command.			*/
	/* 2) Prepare to handle in/out pathnames (sort_seg) or input strings (sort_strings).	*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	call get_invocation_type ("sort_seg", Saf, Nargs, code);
	if Saf then do;
	   call ck_err (code, ep);
	   return;
	   end;
	if Nargs = 0 then do;
	   call ck_err (error_table_$wrong_no_of_args, ep, "
Usage:	ss sort_input_pathname {-control_args}");
	   return;
	   end;

	in_dir = "";				/* No input or output pathnames given  so far.	*/
	in_ent = "";
	out_dir = "";
	out_ent = "";

	go to COMMON;



	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* ENTRYPOINT: sort_strings, sstr						*/
	/* 1) Get arg count.							*/
	/* 2) Get and initialize storage for the strings to be sorted.			*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

sort_strings:
sstr:	entry options(variable);

	call get_invocation_type ("sort_strings", Saf, Nargs, code);
	if Nargs = 0 then do;
	   call ck_err (error_table_$wrong_no_of_args, ep, "
Usage:	^[[^]sstr {-control_args} strings^[]^]", Saf, Saf);
	   return;
	   end;
	Pstring = null;
	on cleanup begin;
	   call release_temp_segment_ (ep, Pstring, code);
	   end;
	call add_to_string$init();

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* 1) Initialize argument-holding variables prior to parsing arguments.		*/
	/* 2) Set defaults for control arguments.					*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

COMMON:	si.version = SS_info_version_1;		/* Initialize structure passed to sort_seg_ which */
	si.block_size = 1;				/*   defines how sorting will be done.		*/
	si.duplicate_mode = SS_unset;
	si.mbz1(*) = 0;
	si.delim.type = SS_unset;
	si.delim.number = 0;
	si.delim.string = "";
	si.field_count = 0;
	si.field(*).from.type = SS_unset;
	si.field(*).from.number = 0;
	si.field(*).from.string = "";
	si.field(*).to.type = SS_unset;
	si.field(*).to.number = 0;
	si.field(*).to.string = "";
	si.field(*).modes = FALSE;

	field_sort = SS_unset;			/* Neither -all, -field or old -order_field given */
	sort_output = SS_unset;			/* Neither -replace nor -output_file given yet.	*/
	descending_sort = SS_unset;			/* Neither -ascending nor -descending given yet.	*/

	Snon_case_sensitive = FALSE;			/* Initial default settings: -case_sensitive and  */
	Sdescending = FALSE;			/*   -ascending				*/
          Snumeric = FALSE;				/* Also, -character				*/
          Sinteger = FALSE;				

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* ARGUMENT PROCESSING:							*/
	/* Pass 1) Pre-scan all arguments first to determine whether -ascending/-descending and	*/
	/*	 -case_sensitive/-non_case_sensitive have been specified.  The last specified	*/
	/*	 of either pair will be used as the default setting when setting sort fields.	*/
	/*         This pass is only necessary if -field is given.  If -field isn't given, then	*/
	/*	 the arguments are only scanned once, equivalent to pass 2.			*/
	/* Pass 2) Actually process control arguments, include the old -ordered_field control	*/
	/*	 argument.  -ofl was made obsolete when its functionality was added to -field.	*/
	/*	 The syntax for -ofl is:						*/
	/*	     -ofl field_start field_length sort_direction				*/
	/* 	 where field_start is a character index, field_length is a character string	*/
	/*	 length, and sort_direction is asc or dsc.				*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

REPROCESS_ARGS:
	do while (get_arg());			/* Process control arguments			*/
(nostringsize):
	   if index(arg, "-") ^= 1 then do;		/* process non-control args.			*/
	      if ep = "sort_seg" then do;		/*   for sort_seg, it is sort_input_pathname	*/
	         if in_dir ^= "" then
		  call ck_err (error_table_$too_many_names, ep, "^a
Only one input pathname allowed.  To give output path, use: -of out_path", arg);
	         call expand_pathname_ (arg, in_dir, in_ent, code);
	         call ck_err (code, ep, arg);
	         end;

	      else do;				/*   for sort_strings, it is a string.		*/
	         call add_to_string (arg);		/*   All remaining args are strings to be sorted. */
STRING_ARGS:       do while (get_arg());
		  call add_to_string (arg);
		  end;
	         end;
	      end;

	   else if (arg = "-string" | arg = "-str") & ep = "sort_strings" then
	      go to STRING_ARGS;

	   else if arg = "-all" | arg = "-a" then	/* process -all				*/
	      field_sort = ALL;

	   else if arg = "-field" | arg = "-fl" then do;	/* process -field				*/
	      field_sort = FIELD;

	      do Itriple = 1 to 3;			/* Operands of -field come in triples:		*/
	         go to FL(Itriple);			/*   field_start field_length {sort_controls}	*/

FL(1):	         if get_op (FIELD_START_SYNTAX, arg) then do;
		  Ifl = si.field_count + 1;		/*   process field_start operands		*/
		  if op = "-from" | op = "-fm" then do;
		     if get_op2 (FIELD_START_SYNTAX, arg, NO_CHECK_NULLS) then do;
		        if op2 = "-string" | op2 = "-str" then do;
			 if get_op2 ("Allowed syntax is:	^a -from -string STR",
			    arg, NO_CHECK_NULLS) then do;
			    si.field(Ifl).from.type = SS_string;
			    si.field(Ifl).from.string = op2;
			    end;
			 else Itriple = 4;
			 end;
		        else do;
			 number = cv_num_no_errors (op2, code);
			 if number >= 1 then do;
			    si.field(Ifl).from.type = SS_index;
			    si.field(Ifl).from.number = number;
			    end;
			 else if code = error_table_$out_of_bounds then do;
			    call ck_err (code, ep, BAD_FIELD_START_INDEX,
			       arg, op_list, op2, arg, op, op2);
			    end;
			 else if substr(op2,1,1) = "/" & substr(op2,length(op2),1) = "/" & length(op2)>2 then do;
			    si.field(Ifl).from.type = SS_reg_exp;
			    si.field(Ifl).from.string = substr(op2,2,length(op2)-2);
			    end;
			 else do;
			    si.field(Ifl).from.type = SS_string;
			    si.field(Ifl).from.string = op2;
			    end;
			 end;
		        end;
		     else Itriple = 4;
		     end;
		  else do;
		     number = cv_num_no_errors (op, code);
		     if code = 0 then do;
		        si.field(Ifl).from.type = SS_index;
		        si.field(Ifl).from.number = number;
		        end;
		     else if code = error_table_$out_of_bounds then
		        call ck_err (code, ep, BAD_FIELD_START_INDEX,
			 arg, op_list, op, arg, "-from", op);
		     else
		        call ck_err (code, ep, "^a ^a^/" ||
			 FIELD_START_SYNTAX, arg, op_list, arg);
		     end;
		  end;
	         else Itriple = 4;
	         go to END_FL;

FL(2):	         if get_op1 (FIELD_LENGTH_SYNTAX, arg) then do;
		  if op = "-for" then do;		/*   process field_length operands		*/
		     if get_op2 (FIELD_LENGTH_SYNTAX, arg, NO_CHECK_NULLS) then do;
		        number = cv_num_no_errors (op2, code);
		        if code = 0 then do;
			 si.field(Ifl).to.number = number;
			 si.field(Ifl).to.type = SS_length;
			 end;
		        else if code = error_table_$out_of_bounds then
			 if number = -1 then do;	/* -1 means use rest of sort unit as field.	*/
			    si.field(Ifl).to.number = number;
			    si.field(Ifl).to.type = SS_length;
			    end;
			 else
			    call ck_err (code, ep, "^a ^a^/" ||
			       BAD_FIELD_LENGTH, arg, op_list);
		        else 
			 call ck_err (code, ep, "^a ^a^/" ||
			    FIELD_LENGTH_SYNTAX, arg, op_list, arg);
		        end;
		     else Itriple = 4;
		     end;
		  else if op = "-to" then do;
		     if get_op2 (FIELD_LENGTH_SYNTAX, arg, NO_CHECK_NULLS) then do;
		        if op2 = "-string" | op2 = "-str" then do;
			 if get_op2 ("Allowed syntax is:	-a -to -string STR",
			    arg, NO_CHECK_NULLS) then do;
			    si.field(Ifl).to.type = SS_string;
			    si.field(Ifl).to.string = op2;
			    end;
			 else Itriple = 4;
			 end;
		        else do;
			 number = cv_num_no_errors (op2, code);
			 if number >= 1 then do;
			    si.field(Ifl).to.type = SS_index;
			    si.field(Ifl).to.number = number;
			    end;
			 else if code = error_table_$out_of_bounds then do;
			    call ck_err (code, ep, BAD_FIELD_END_INDEX,
			       arg, op_list, op2, arg, op, op2);
			    end;
			 else if substr(op2,1,1)="/" & substr(op2,length(op2),1)="/" & length(op2)>2 then do;
			    si.field(Ifl).to.type = SS_reg_exp;
			    si.field(Ifl).to.string = substr(op2,2,length(op2)-2);
			    end;
			 else do;
			    si.field(Ifl).to.type = SS_string;
			    si.field(Ifl).to.string = op2;
			    end;
			 end;
		        end;
		     else Itriple = 4;
		     end;
		  else do;
		     number = cv_num_no_errors (op, code);
		     if code = 0 then do;
		        si.field(Ifl).to.number = number;
		        si.field(Ifl).to.type = SS_length;
		        end;
		     else if code = error_table_$out_of_bounds then
		        if number = -1 then do;	/* -1 means use rest of sort unit as field.	*/
			 si.field(Ifl).to.number = number;
			 si.field(Ifl).to.type = SS_length;
			 end;
		        else
		           call ck_err (code, ep, "^a ^a^/" ||
			    BAD_FIELD_LENGTH, arg, op_list);
		     else
		        call  ck_err (code, ep, "^a ^a^/" ||
			 FIELD_LENGTH_SYNTAX, arg, op_list, arg);
		     end;
		  end;
	         else Itriple = 4;

	         go to END_FL;

FL(3):	         si.field(Ifl).modes.descending = Sdescending;
	         si.field(Ifl).modes.non_case_sensitive = Snon_case_sensitive;
	         si.field(Ifl).modes.numeric = Snumeric;
	         si.field(Ifl).modes.integer = Sinteger;

/*   process sort_controls			*/
FL3_OP:	         if get_op1 ("", "") then do;
		  if op = "ascending" | op = "asc" then do;
		     si.field(Ifl).modes.descending = FALSE;
		     go to FL3_OP;
		     end;
		  else if op = "descending" | op = "dsc" then do;
		     si.field(Ifl).modes.descending = TRUE;
		     go to FL3_OP;
		     end;
		  else if op = "case_sensitive" | op = "cs" then do;
		     si.field(Ifl).modes.non_case_sensitive = FALSE;
		     go to FL3_OP;
		     end;
		  else if op = "non_case_sensitive" | op = "ncs" then do;
		     si.field(Ifl).modes.non_case_sensitive = TRUE;
		     go to FL3_OP;
		     end;
		  else if op = "character" | op = "ch" then do;
		     si.field(Ifl).modes.numeric = FALSE;
		     si.field(Ifl).modes.integer = FALSE;
		     go to FL3_OP;
		     end;
		  else if op = "numeric" | op = "num" then do;
		     si.field(Ifl).modes.numeric = TRUE;
		     si.field(Ifl).modes.integer = FALSE;
		     go to FL3_OP;
		     end;
		  else if op = "integer" | op = "int" then do;
		     si.field(Ifl).modes.integer = TRUE;
		     si.field(Ifl).modes.numeric = FALSE;
		     go to FL3_OP;
		     end;
		  else if cv_num_no_errors (op, code) >= 1 then do;
		     Iarg = Iarg - 1;
		     Itriple = 0;
		     si.field_count = Ifl;
		     end;
		  else if op = "-from" | op = "-fm" then do;
		     Iarg = Iarg - 1;
		     Itriple = 0;
		     si.field_count = Ifl;
		     end;
		  else if op = "-for" | op = "-to" then do;
		     if get_op2 ("^a requires an operand.", op, NO_CHECK_NULLS) then do;
		        call ck_err (error_table_$data_seq_error, ep, "^a ^a
The operands of ^a must be in the order:  
   field_start field_length {sort_controls}", arg, op_list, arg);
		        Iarg = Iarg - 2;
		        Itriple = 1;
		        si.field_count = Ifl;
		        end;
		     else do;
		        call ck_err (error_table_$data_seq_error, ep, "^a ^a
The operands of ^a must be in the order:
  field_start field_length {sort_controls}", arg, op_list, arg);
		        Itriple = 4;
		        end;
		     end;
		  else if index(op,"-") = 1 then do;
		     Iarg = Iarg - 1;
		     Itriple = 4;
		     end;
		  else do;
		     call ck_err (error_table_$bad_arg, ep, "^a ^a
" || FIELD_MODES_SYNTAX, arg, op_list, arg);
		     Itriple = 4;
		     end;
		  end;
	         else Itriple = 4;
END_FL:	         end;
	      si.field_count = Ifl;
	      end;

	   else if (arg = "-ordered_field" | arg = "-ofl") &
		  ep = "sort_seg" then do;
	      field_sort = ORDERED_FIELD;		/* process -ordered_field			*/

	      do Itriple = 1 to 3;			/* Operands of -ordered_field come in triples:	*/
	         go to OFL(Itriple);			/*   field_start field_length sort_direction	*/

OFL(1):	         if get_op (OFL_SYNTAX, arg) then do;	/*   process field_start operand		*/
		  Ifl = si.field_count + 1;
		  si.field(Ifl).from.number =
		     cv_num (op, "The first operand of ^a is a character index from 1 to 131071.", arg);
		  si.field(Ifl).from.type = SS_index;
		  end;
	         else Itriple = 4;
	         go to END_OFL;

OFL(2):	         if get_op2 (OFL_SYNTAX, arg, CHECK_NULLS) then do;
		  si.field(Ifl).to.number =		/*   process field_length operand		*/
		     cv_num (op2, "The second operand of ^a is a field length from 1 to 131071.", arg);
		  si.field(Ifl).to.type = SS_length;
		  end;
	         else Itriple = 4;
	         go to END_OFL;

OFL(3):	         si.field(Ifl).modes = FALSE;		/*   process sort_direction operand		*/
	         if get_op2 (OFL_SYNTAX, arg, CHECK_NULLS) then do;
		  if op2 = "dsc" then
		     si.field(Ifl).modes.descending = TRUE;
		  else if op2 = "asc" then;
		  else 
		     call ck_err (error_table_$bad_arg, ep, "^a ^a
The third operand of ^a must be asc (for ascending) or dsc (for descending).",
		        arg, op_list, arg);
		  end;
	         if get_op ("", "") then do;
		  Iarg = Iarg - 1;
		  if cv_num_no_errors (op, code) >= 1 then
		     Itriple = 0;
		     si.field_count = Ifl;
		  end;
END_OFL:	         end;
	      si.field_count = Ifl;
	      end;

	   else if arg = "-ascending" | arg = "-asc" then do;
	      descending_sort = ASCENDING;		/*  process sort direction/case-sensitivity args	*/
	      Sdescending = FALSE;
	      end;
	   else if arg = "-descending" | arg = "-dsc" then do;
	      descending_sort = DESCENDING;
	      Sdescending = TRUE;
	      end;

	   else if arg = "-case_sensitive" | arg = "-cs" then
	      Snon_case_sensitive = FALSE;
	   else if arg = "-non_case_sensitive" | arg = "-ncs" then
	      Snon_case_sensitive = TRUE;

	   else if arg = "-character" | arg = "-ch" then do;
	      Snumeric = FALSE;
	      Sinteger = FALSE;
	      end;
	   else if arg = "-numeric" | arg = "-num" then do
	      Snumeric = TRUE;
	      Sinteger = FALSE;
	      end;
	   else if arg = "-integer" | arg = "-int" then do
	      Sinteger = TRUE;
	      Snumeric = FALSE;
	      end;

	   else if arg = "-duplicates" | arg = "-dup" then
	      si.duplicate_mode = SS_duplicates;	/* process duplicate-handling control args.	*/

	   else if arg = "-only_duplicates" | arg = "-odup" then
	      si.duplicate_mode = SS_only_duplicates;

	   else if arg = "-only_duplicate_keys" | arg = "-odupk" then
	      si.duplicate_mode = SS_only_duplicate_keys;

	   else if arg = "-unique" | arg = "-uq" then
	      si.duplicate_mode = SS_unique;

	   else if arg = "-unique_keys" | arg = "-uqk" then
	      si.duplicate_mode = SS_unique_keys;

	   else if arg = "-only_unique" | arg = "-ouq" then
	      si.duplicate_mode = SS_only_unique;

	   else if arg = "-only_unique_keys" | arg = "-ouqk" then
	      si.duplicate_mode = SS_only_unique_keys;

	   else if arg = "-block" | arg = "-bk" then do;	/* process sort string blocking factor arg.	*/
	      if get_op ("^a requires a block size operand from 1 to 131071.", arg) then
	         si.block_size = cv_num (op, "^a requires a block size operand from 1 to 131071.", arg);
	      end;

	   else if (arg = "-delimiter" | arg = "-dm") & 
		  ep = "sort_seg" then do;
	      if get_op (DELIM_SYNTAX, arg) then do;	/* process sort string delimiter control arg.	*/
	         if op = "-string" | op = "-str" then do;
		  if get_op ("Allowed syntax is:	^a -string STR", arg) then do;
		     si.delim.type = SS_string;
		     si.delim.string = op || NL;
		     end;
		  end;
	         else do;
		  si.delim.number = cv_num_no_errors (op, code);
		  if code = 0 then 
		     si.delim.type = SS_length;
		  else if code = error_table_$out_of_bounds then do;
		     call ck_err (code, ep, BAD_DELIM_LENGTH, arg, op, op, arg, op);
		     end;
		  else if substr(op,1,1) = "/" & substr(op,length(op),1) = "/" & length(op)>2 then do;
		     si.delim.type = SS_reg_exp;
		     si.delim.string = substr(op,2,length(op)-2);
		     end;
		  else do;
		     si.delim.type = SS_string;
		     si.delim.string = op || NL;
		     end;
		  end;
	         end;
	      end;

	   else if (arg = "-replace" | arg = "-rp") &	/* process sort_output_pathname control args.	*/
		  ep = "sort_seg" then
	      sort_output = REPLACE;
	      
	   else if (arg = "-output_file" | arg = "-of" |
		  arg = "-segment" | arg = "-sm") &
		  ep = "sort_seg" then do;
	      sort_output = SEGMENT;
	      if get_op ("^a requires pathname of output segment as an operand.", arg) then do;
	         call expand_pathname_ (op, out_dir, out_ent, code);
	         call ck_err (code, ep, "^a ^a", arg, op);
	         end;
	      end;

	   else					/* bad control argument.			*/
	      call ck_err (error_table_$badopt, ep, arg);
	   end;

	if Iarg_pass = 1 then do;			/* Must reprocess args to correctly apply the	*/
	   if Serror then go to RETURN;		/*   defaults for -asc/-dsc, -cs/-ncs, and	*/
	   if field_sort = ALL | si.field_count = 0 |	/*   -ch/-num/-int to field structure.		*/
	      field_sort = ORDERED_FIELD then;		/* Of course, if no field structure was built in	*/
	   else do;				/*   first pass, then a second pass isn't needed. */
	      in_dir = "";
	      Lstring = 0;
	      call prepare_to_reprocess_args();
	      si.field_count = 0;			/* or else we end up with twice as many */
	      go to REPROCESS_ARGS;
	      end;
	   end;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* FINAL STEPS:								*/
	/* 1) Set defaults for args not given by user.					*/
	/* 2) Check consistency of all arguments.  Make sure needed info was supplied.		*/
	/* FOR sort_seg:								*/
	/* 3) If neither -replace nor -output_file was given, query user to overwrite segment.	*/
	/* 4) Call sort_seg_ to do the actual sorting.  It will report any errors encountered	*/
	/*    during the sorting process.  It checks access to the segments, creates the output	*/
	/*    seg if needed, validates qedx regular expressions, etc.			*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if si.duplicate_mode = SS_unset then		/* Set default duplicate mode if user gave none.	*/
	   si.duplicate_mode = SS_duplicates;

	if ep = "sort_strings" then do;		/* Set delimiter chosen by add_to_string rtn.	*/
	   si.delim.type = SS_string;
	   si.delim.string = delimiter;
	   end;
	else if si.delim.type = SS_unset then do;	/* Set default sort string delimiter, a NL	*/
	   si.delim.type = SS_string;
	   si.delim.string = NL;
	   end;

	if field_sort = ALL then			/* If -all given, or none of -all/-field/-ofl	*/
	   si.field_count = 0;			/*   given, mark that no sort fields were defined.*/
	if si.field_count = 0 then do;		/* When no sort fields are defined, make one which*/
	   si.field_count = 1;			/*   encompasses the entire sort unit.		*/
	   si.field(1).from.type = SS_index;
	   si.field(1).from.number = 1;
	   si.field(1).to.type = SS_length;
	   si.field(1).to.number = -1;
	   si.field(1).modes = FALSE;
	   si.field(1).modes.descending = Sdescending;
	   si.field(1).modes.non_case_sensitive = Snon_case_sensitive;
	   si.field(1).modes.numeric = Snumeric;
	   si.field(1).modes.integer = Sinteger;
	   end;
	else if field_sort = ORDERED_FIELD then do;	/* For old -order_field, if -descending is given	*/
	   if descending_sort = DESCENDING then		/*   then invert meaning of all sort_direction	*/
	      si.field(*).modes.descending = ^si.field(*).modes.descending;
	   if Snon_case_sensitive then		/*   switches in sort_info struc, and apply -ncs. */
	      si.field(*).modes.non_case_sensitive = TRUE;
	   end;

	Serrors_are_fatal = TRUE;			/* From this point on, any error aborts command.	*/
	if ep = "sort_strings" then			/* Branch to code below for rest of sort_strings	*/
	   go to SORT_STRINGS;			/*   processing.				*/

	if in_dir = "" then				/* Complain if no sort_input_pathname given.	*/
	   call ck_err (error_table_$noarg, ep, "Input pathname required.
Usage:	ss sort_input_pathname {-control_args}");
	call hcs_$status_minf (in_dir, in_ent, CHASE, type, bc, code);
	if code ^= 0 then 
	   call ck_err (code, ep, "^a^[>^]^a", in_dir, in_dir^=">", in_ent);
	else if type ^= SEGMENT then 
	   call ck_err (error_table_$dirseg, ep, "^a^[>^]^a",
	      in_dir, in_dir^=">", in_ent);
	else if bc = 0 then 
	   call ck_err (error_table_$zero_length_seg, ep, "Sort input segment is empty
(^a^[>^]^a).", in_dir, in_dir^=">", in_ent);

	if sort_output = REPLACE then do;		/* If -replace, sort_output_path = sort_input_path*/
	   out_dir = in_dir;
	   out_ent = in_ent;
	   end;
	else if sort_output = SS_unset & ^Serror then do; /* Neither -rp nor -of given?  Query to overwrite */
	   call user_info_$absentee_queue  (q);		/* if this is an interactive invocation.	*/
	   if q = -1 then
	      call command_query_$yes_no (Syes, 0, ep, 
"If you want to sort ^a^[>^]^a
and overwrite the segment with the sorted results, reply yes.
Otherwise, reply no.  Overwrite the segment?", "Do you want to overwrite segment ^a^[>^]^a?",
	         in_dir, in_dir^=">", in_ent);
	   else Syes = TRUE;			/* if absentee, assume user wants to overwrite.	*/
	   if ^Syes then				/* Don't overwrite?  An error has occurred.	*/
	      Serror = TRUE;
	   else do;				/* Do overwrite?  Equate input and output paths.	*/
	      out_dir = in_dir;
	      out_ent = in_ent;
	      end;
	   end;
	else if ^Serror then do;			/* If -output_file,  apply equal convention to	*/
	   call get_equal_name_ (in_ent, out_ent, equal_ent, code);
						/*    make sort_output_pathname.		*/
	   call ck_err (code, ep, "^a applied to ^a",
	      out_ent, in_ent);
	   out_ent = equal_ent;
	   end;

	if Serror then go to RETURN;			/* An error occurred.  Don't do sorting.	*/

	on sub_error_ call sub_error_handler;

	call sort_seg_$seg (ep, addr(si), in_dir, in_ent, out_dir, out_ent,
	   out_len, undelim_char_index, code);		/* This subr does the work.			*/

RETURN:	if ep = "sort_strings" then
	   call release_temp_segment_ (ep, Pstring, code);
	return;					/* Simple, huh?				*/

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* FOR sort_strings:							*/
	/* 1) Be sure that an input string was provided.					*/
	/* 2) Create space for output string.  If the input string currently fills more than	*/
	/*    half of the temp segment, then the output string will overlay the input string and	*/
	/*    sort_seg_$string will handle the overlay by sorting into a second temp string and	*/
	/*    then copying the sorted result back.					*/
	/* 3) Establish sub_error_ handler to intercept error reports from sort_seg_.		*/
	/* 4) Call sort_seg_$string to process the input string.				*/
	/* 5) For active function output, add sorted string components to AF return arg,	*/
	/*    requoting each one to be sure it is treated as an individual value.		*/
	/* 6) For command output, output the sorted string components on a many-per-line basis,	*/
	/*    using multiple lines to prevent lines from overflowing.  Also,  requote components	*/
	/*    which contain a SPACE or TAB to prevent them from appearing as multiple components	*/
	/*    in the sorted list.							*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

SORT_STRINGS:
	if Lstring = 0 then 
	   call ck_err (-1, ep, "No input strings were given.");

	Lout_string = divide (length(string)+3, 4, 21, 0) * 4;
	if Lout_string + Lout_string <= MLstring then 
	   Pout_string = addcharno (Pstring, Lout_string);
	else do;
	   Pout_string = Pstring;
	   Lout_string = Lstring;
	   end;

	on sub_error_ call sub_error_handler;

	call sort_seg_$string (ep, addr(si), string, out_string, Lout_string,
	   undelim_char_index, code);

	if code = 0 then do;
	   if Saf then do;
	      do while (get_out_string_component());
	         call add_to_return_arg (out_string_component);
	         end;
	      end;
	   else do;
	      call output_string$init();
	      do while (get_out_string_component());
	         call output_string (out_string_component);
	         end;
	      call output_string$term();
	      end;
	   end;
	go to RETURN;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* 		I  N  T  E  R  N  A  L        P  R  O  C  E  D  U  R  E  S		*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

    dcl	Lout_string		fixed bin(21),
       	Lstring			fixed bin(21),
	Lout_string_component	fixed bin(21),
	MLstring			fixed bin(21),
	Pout_string		ptr,
	Pout_string_component	ptr,
	Pstring			ptr,
	delimiter			char(1),
         (get_temp_segment_, 
	release_temp_segment_)	entry (char(*), ptr, fixed bin(35)),
	possible_delimiters		char(512) varying,
	out_string		char(Lout_string) based(Pout_string),
	out_string_ch (Lout_string)	char(1) based(Pout_string),
	out_string_component	char(Lout_string_component) based(Pout_string_component),
	string			char(Lstring) based(Pstring),
	sys_info$max_seg_size	fixed bin(35) ext static;

add_to_string:
	proc (arg);

    dcl	arg			char(*);

    dcl	Istring_new		fixed bin(21),
	new_delimiter		char(1);

    dcl  (collate9, reverse, translate) builtin;

	if index(arg, delimiter) > 0 then do;		/* Insure string delimiter does not appear in any */
NEED_NEW_DELIMITER:					/*   string.				*/
	   if possible_delimiters = "" then do;
	      Serrors_are_fatal = TRUE;
	      call ck_err (-1, ep,
"The strings to be sorted use every character in the collate9 sequence.
Therefore the strings cannot be sorted.");
	      end;
	   new_delimiter = substr(possible_delimiters,1,length(delimiter));
	   possible_delimiters = substr(possible_delimiters,length(delimiter)+1);
	   if index(string,new_delimiter) + index(arg,new_delimiter) > 0 then
	      go to NEED_NEW_DELIMITER;
	   string = translate (string, new_delimiter, delimiter);
             delimiter = new_delimiter;
	   end;
	if length(string) + length(arg) + length(delimiter) > MLstring then do;
	   Serrors_are_fatal = TRUE;
	   call ck_err (error_table_$too_many_args, ep, 
"The temp segment holding strings to be sorted has overflowed.");
	   end;
	Istring_new = length(string) + 1;
	Lstring = length(string) + length(arg) + length(delimiter);
	substr(string, Istring_new) = arg;
	substr(string, length(string), 1) = delimiter;
	return;


add_to_string$init:
	entry;

	delimiter = NL;
	possible_delimiters = reverse(collate9());
	Lstring = 0;
	MLstring = sys_info$max_seg_size * 4;
	call get_temp_segment_ (ep, Pstring, code);
	if code ^= 0 then do;
	   Serrors_are_fatal = TRUE;
	   call ck_err (code, ep, "Getting a temp segment.");
	   end;
	return;

get_out_string_component:
	entry returns(bit(1));

	if length(out_string) = 0 then
	   return (FALSE);
	Lout_string_component = index(out_string, delimiter);
	Pout_string_component = addr(out_string);
	if length(out_string) > length(out_string_component) then
	   Pout_string = addr(out_string_ch(length(out_string_component)+1));
	Lout_string = length(out_string) - length(out_string_component);
	Lout_string_component = Lout_string_component - length(delimiter);
	return (TRUE);

	end add_to_string;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


    dcl	Serror			bit(1),		/* On if fatal error has occurred.		*/
       	Serrors_are_fatal		bit(1);		/* On if errors are fatal.			*/

ck_err: 	proc options(variable);			/* Procedure to report errors via com_err_ or	*/
						/*   active_fnc_err_, as appropriate.  This proc	*/
						/*   has same calling sequence as com_err_.	*/

    dcl	code			fixed bin(35) based (Pcode),
	Pcode			ptr;

    dcl	cu_$arg_list_ptr		entry returns(ptr),
	cu_$arg_ptr		entry (fixed bin, ptr, fixed bin(21), fixed bin(35)),
	cu_$generate_call		entry (entry, ptr);

	call cu_$arg_ptr (1, Pcode, 0, 0);		/* Access error table code argument.		*/
	if code = 0 then return;			/* If non-zero, this ISN'T an error.		*/
	if code = -1 then code = 0;			/* No error table code fits the desired err msg.	*/
	Serror = TRUE;				/* Record fact that an error occurred.		*/
	call cu_$generate_call (err, cu_$arg_list_ptr()); /* Actually call com_err_ or active_fnc_err_.	*/
	if Serrors_are_fatal then
	   go to RETURN;

	end ck_err;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


cv_num:	proc (op, err_msg, arg) returns(fixed bin);	/* Number conversion  internal proc.  Main 	*/
						/* entry point calls ck_err if an error occurs.	*/

    dcl	op			char(*),
	err_msg			char(*),
	arg			char(*);

    dcl	Ssuppress_error		bit(1),
	code			fixed bin(35),
	conversion		condition,
	n			fixed bin,
	size			condition;

	Ssuppress_error = FALSE;
	go to COMMON;

cv_num_no_errors:					/* Special entry point returns -2 if an error	*/
	entry (op, Acode) returns(fixed bin);		/* occurs in conversion, or actual value	*/
						/* if a non-positive number is given.		*/

    dcl	Acode			fixed bin(35);

	Ssuppress_error = TRUE;
	Acode = 0;
	if op = "" then do;
	   code = error_table_$bad_arg;
	   go to OP_NOT_NUMERIC;
	   end;

COMMON:	on conversion begin;
	   code = error_table_$bad_arg;
	   n = -2;				/* Use PL/I to do conversion, check for errors.	*/
	   go to OP_NOT_NUMERIC;
	   end;
	on size begin;
	   code = error_table_$out_of_bounds;
	   n = -2;
	   go to OP_NOT_NUMERIC;
	   end;
	n = convert(n, op);
	revert conversion, size;
	if n < 1 then do;
	   code = error_table_$out_of_bounds;
OP_NOT_NUMERIC:
	   if Ssuppress_error then
	      Acode = code;
	   else
	      call ck_err (code, ep, "^a ^a^/" || err_msg, arg, op_list, arg);
	   end;
	return (n);

	end cv_num;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


estimate_fields:					/* Internal proc to estimate number of fields	*/
	proc returns(fixed bin);			/* needed in sort info structure, based upon	*/
						/* number of arguments given  to sort_seg command.*/
						/* It never under-estimates.			*/

    dcl	Nargs			fixed bin,	/* Use of this procedure allows use to get	*/
	Nfields			fixed bin;	/* generation of storage for structure in 	*/
						/* automatic storage of main procedure.		*/

    dcl	cu_$af_arg_count		entry (fixed bin, fixed bin(35));

	call cu_$af_arg_count (Nargs, 0);
	Nfields = divide(Nargs-2, 2, 17, 0);
	Nfields = max (Nfields, 1);
	return (Nfields);

	end estimate_fields;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


    dcl	Iarg			fixed bin,	/* Current argument being processed.		*/
       	Iarg_pass			fixed bin,	/* Number of time arg list has been processed.	*/
	Larg			fixed bin(21),	/* Length of current argument.		*/
	Lop			fixed bin(21),	/* Length of current ctl arg operand.		*/
	Lop2			fixed bin(21),
	Lret			fixed bin(21),	/* Max length of AF return value.		*/
	Nargs			fixed bin,	/* Number of arguments.			*/
	Parg			ptr,		/* Ptr to current argument.			*/
	Parg_list			ptr,		/* Ptr to command/af's argument list.		*/
	Pop			ptr,		/* Ptr to current operand.			*/
	Pop2			ptr,
	Pret			ptr,		/* Ptr to AF return value.			*/
	Saf			bit(1),		/* On if invoked as an active function.		*/
	arg			char(Larg) based(Parg),
	ep			char(12),
	op			char(Lop) based(Pop),
	op2			char(Lop2) based(Pop2),
	ret			char(Lret) varying based(Pret),
         (arg_ptr			variable,
	cu_$af_arg_ptr_rel,
	cu_$arg_ptr_rel)		entry (fixed bin, ptr, fixed bin(21), fixed bin(35), ptr),
	cu_$af_return_arg		entry (fixed bin, ptr, fixed bin(21), fixed bin(35)),
       	cu_$arg_list_ptr		entry returns(ptr),
         (err			variable,
	active_fnc_err_,		
	com_err_)			entry() options(variable);
	

get_invocation_type:				/* Were we invoked as command or af?  Arg count?	*/
	proc (entrypoint, Saf, Nargs, code);

    dcl	entrypoint		char(*),
	Saf			bit(1),
	Nargs			fixed bin,
	code			fixed bin(35);

	ep = entrypoint;
	Serrors_are_fatal = FALSE;
	call cu_$af_return_arg (Nargs, Pret, Lret, code);
	if code = 0 then do;
	   Saf = TRUE;
	   arg_ptr = cu_$af_arg_ptr_rel;
	   err = active_fnc_err_;
	   ret = "";
	   end;
	else do;
	   Saf = FALSE;
	   arg_ptr = cu_$arg_ptr_rel;
	   err = com_err_;
	   end;
	Serror = FALSE;				/* No errors so far.			*/
	Parg_list =  cu_$arg_list_ptr();		/* Remember arg list ptr for subrs below.	*/
	Iarg_pass = 0;


prepare_to_reprocess_args:
	entry;

	Iarg = 0;					/* No args processed so far.			*/
	Iarg_pass = Iarg_pass + 1;

	end get_invocation_type;
       

get_arg:	proc returns(bit(1));			/* Returns TRUE if another argument exists.	*/
						/*   Its value is accessible via arg variable.	*/

	if Iarg+1 > Nargs then
	   return(FALSE);
	Iarg = Iarg + 1;
	call arg_ptr (Iarg, Parg, Larg, code, Parg_list);
	return(TRUE);

get_op:	entry (err_msg, arg) returns(bit(1));		/* Internal proc to get control arg operands.	*/
						/* Besides getting the operands, (in op or op2	*/
    dcl	err_msg			char(*),		/* variables), it catenates them together in the	*/
	arg			char(*);		/* op_list variable for use in error msgs.	*/

	op_list = "";				/* First operand of a control arg, or first of a	*/
						/* triplet of operands assoc with -field or -ofl. */

get_op1:	entry (err_msg, arg) returns(bit(1));		/* First of operand group forming second element	*/
						/* of a -field triplet.			*/

	if Iarg = Nargs then do;
	   if err_msg ^= "" then 
	      call ck_err (error_table_$noarg, ep, "^a ^a^/" ||
	         err_msg, arg, op_list, arg);
	   return (FALSE);
	   end;
	else do;
	   Iarg = Iarg + 1;
	   call arg_ptr (Iarg, Pop, Lop, code, Parg_list);
	   if op = "" then do;
	      if err_msg ^= "" then
	         call ck_err (error_table_$bad_arg, ep, "^a^[ ^a^;^s^] ""^va""^/" ||
		  err_msg, arg, op_list^="", op_list, length(op), op, arg);
	      return (FALSE);
	      end;
	   call add_op_to_list (op);
	   return (TRUE);
	   end;


get_op2:	entry (err_msg, arg, Scheck_nulls) returns(bit(1));
						/* Next of operand group.			*/

    dcl	Scheck_nulls		bit(1);

	if Iarg = Nargs then do;
	   call ck_err (error_table_$noarg, ep, "^a ^a^/" ||
	      err_msg, arg, op_list, arg);
	   return (FALSE);
	   end;
	else do;
	   Iarg = Iarg + 1;
	   call arg_ptr (Iarg, Pop2, Lop2, code, Parg_list);
	   if Scheck_nulls & op2 = "" then do;
	      call ck_err (error_table_$bad_arg, ep, "^a ^a ""^va""^/" ||
	         err_msg, arg, op_list, length(op), op, arg);
	      return (FALSE);
	      end;
	   call add_op_to_list (op2);
	   return (TRUE);
	   end;

add_op_to_list:					/* Internal proc of get_op to add new operand to	*/
	proc (op);				/* op_list variable.			*/

    dcl	op			char(*);

	if length(op) = 0 | search(op, " ""()[];	") > 0 then
	   op_list = op_list || requote_string_ (op);
	else
	   op_list = op_list || op;
	op_list = op_list || " ";

	end add_op_to_list;


add_to_return_arg:
       	entry (arg);

	if ret ^= "" then
	   ret = ret || " ";
	ret = ret || requote_string_ (arg);

	end get_arg;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


    dcl	Loutput_line		fixed bin,
	MLoutput_line		fixed bin,
	get_line_length_$switch	entry (ptr, fixed bin(35)) returns(fixed bin);

output_string:
       	proc (arg);

    dcl	arg			char(*);

    dcl	IHT_SP			fixed bin(21),
	HT_SP			char(2) int static options(constant) init("	 "),
	Lrq_arg			fixed bin(21),
	SP			char(1) int static options(constant) init(" "),
	ioa_$nnl			entry() options(variable);

	IHT_SP = search(arg, HT_SP);
	if IHT_SP > 0 then
	   Lrq_arg = length(requote_string_(arg));
	else
	   Lrq_arg = length(arg);

	if Loutput_line = 0 then do;
OUTPUT_AT_BEGINNING_OF_LINE:
	   if IHT_SP > 0 then 
	      call ioa_$nnl ("^a", requote_string_(arg));
	   else 
	      call ioa_$nnl ("^a", arg);
	   Loutput_line = Lrq_arg;
	   end;

	else if Loutput_line + length(SP) + Lrq_arg <= MLoutput_line then do;
	   if IHT_SP > 0 then
	      call ioa_$nnl (" ^a", requote_string_(arg));
	   else
	      call ioa_$nnl (" ^a", arg);
	   Loutput_line = Loutput_line + length(SP) + Lrq_arg;
	   end;

	else do;
	   call ioa_$nnl ("^/");
	   go to OUTPUT_AT_BEGINNING_OF_LINE;
	   end;
	return;


output_string$init:
	entry;

	MLoutput_line = get_line_length_$switch (null, code);
	if code ^= 0 then MLoutput_line = 136;
	Loutput_line = 0;


output_string$term:
	entry;

	if Loutput_line > 0 then
	   call ioa_$nnl ("^/");

	end output_string;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

sub_error_handler:
     proc;

/* Sub_error procedure, prints a message and cleans up */

     dcl   code                         fixed bin(35);
     dcl 1 cond_info                    like condition_info;
     dcl   find_condition_info_	entry (ptr, ptr, fixed bin (35));
     dcl   null                         builtin;
     dcl 1 sub_err_info                 like sub_error_info based (cond_info.info_ptr);

     call find_condition_info_ (null(), addr (cond_info), code);

     Serrors_are_fatal = FALSE;

     call ck_err (sub_err_info.header.status_code, ep, sub_err_info.info_string);

     end sub_error_handler;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

%include sort_seg_info;
%page;
%include condition_info;
%page;
%include sub_error_info;
%page;
%include condition_info_header;

	end sort_seg;
