/****^  ********************************************
        *                                          *
        * Copyright, (C) Honeywell Bull Inc., 1987 *
        *                                          *
        ******************************************** */

/****^  HISTORY COMMENTS:
  1) change(87-05-28,GDixon), approve(87-07-07,MCR7719),
     audit(87-07-08,Hartogs), install(87-08-04,MR12.1-1055):
      A) Initial coding, cribbed from display_connection_list.
  2) change(87-07-07,GDixon), approve(87-07-07,MCR7719),
     audit(87-07-08,Hartogs), install(87-08-04,MR12.1-1055):
      A) Remove magic numbers in several places.
      B) Correct coding error in matching_entry subroutine.
                                                   END HISTORY COMMENTS */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* display_user_messages:  a utility to display contents of the	       */
/* active_connection_list table, maintained by the connection_list_manager_  */
/* subsystem.						       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	

display_user_messages:
     proc;


/* AUTOMATIC */

dcl  brief_sw			bit(1) aligned automatic;
dcl  code				fixed bin(35) automatic;
dcl  entry_var			entry variable;
dcl (exclude, match)		char(100) varying automatic;
dcl  message_handle			bit(72) aligned automatic;
dcl  message_id			bit(72) aligned automatic;
dcl  octal_sw			bit(1) aligned automatic;
dcl  1 source			aligned automatic,
       2 id			char(32),
       2 person			char(24),
       2 project			char(12),
       2 tag			char(1) unal,
       2 tag_pad			char(3) unal;
dcl  source_id			bit(36) aligned automatic;
dcl  system_area_ptr		ptr automatic;
dcl  1 target			aligned automatic like source;
dcl  target_id			bit(36) aligned automatic;


/* BASED */

dcl  system_area			area based (system_area_ptr);
     

/* ENTRIES */

dcl  date_time_$format		entry (char(*), fixed bin(71),
				     char(*), char(*))
				     returns(char(250) var);
dcl  dump_segment_			entry (ptr, ptr, fixed bin,
				     fixed bin(18), fixed bin(18),
				     bit(*));
dcl  get_system_free_area_		entry() returns(ptr);
dcl  ioa_				entry() options(variable);
dcl  user_message_admin_$read_message   entry (ptr, ptr, ptr, fixed bin(35));
	

/* BUILTINS AND CONDITIONS */

dcl (addr, after, before, char, dimension, index, hbound, lbound, length,
     ltrim, max, null, rtrim, size, string, substr, unspec)
				builtin;
dcl (cleanup, linkage_error)		condition;


/* INTERNAL STATIC */

dcl  COMMAND_VERSION		char(3) int static options(constant)
				init("1.0");
dcl  CONTINUATION_LINE		char(8) int static options(constant)
				init("
	      ");
dcl  DO_NOT_BLOCK			fixed bin int static options(constant)
				init(-1);
dcl (FALSE			init("0"b),
     TRUE				init("1"b)) bit(1)
				     int static options(constant);
dcl  ME				char (21) int static options (constant)
				init ("display_user_messages");
dcl  ZERO_OFFSET			fixed bin(18) int static
				options(constant) init(0);

/* EXTERNAL STATIC */

dcl (error_table_$bad_arg,
     error_table_$bad_opt,
     error_table_$no_message)		fixed bin(35) ext static;
dcl  iox_$user_output		ptr ext static;

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* INVOCATION TYPE AND ARGUMENTS:				       */
/* 1) Initialize variables, and establish cleanup handler.		       */
/* 2) Create standalone ssu_ invocation for argument processing.	       */
/* 3) Initialize argument handling routines.			       */
/* 4) Process input arguments, reporting any errors as they are encountered. */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

     call initialize_args();
     on cleanup call cleanup_invocation();
     call ssu_$standalone_invocation (sci_ptr, ME, COMMAND_VERSION,
        cu_$arg_list_ptr(),exit_proc, code); 
     call check_invocation_type (ALLOW_COMMAND);
     call process_args();
     call scan_messages();



/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* REVOCATION AND EXIT:					       */
/*   This point is reached when normal processing completes successfully,    */
/* or when the error$fatal routine is called to abnormally end processing.   */
/*							       */
/* 1) Cleanup the standalone invocation.			       */
/* 2) Return to command processor.				       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

EXIT:
     call cleanup_invocation();
     return;

exit_proc:
     proc;
     go to EXIT;
     end exit_proc;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* alloc_aumi: get next aumi structure from array.  Handle array overflow    */
/* gracefully.						       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

dcl  1 aumi_struct			structure aligned
				based (aumi_struct_ptr),
       2 count			fixed bin,
       2 max_count			fixed bin,
       2 array (aumi_struct_count refer (aumi_struct.max_count))
				like as_user_message_info;
dcl  aumi_struct_count		fixed bin;
dcl (aumi_struct_ptr, temp_struct_ptr)	ptr;
dcl  1 auto_aumi_struct		structure aligned automatic,
       2 count			fixed bin,
       2 max_count			fixed bin,
       2 array (50)			like as_user_message_info;

dcl  1 aumi			aligned based(aumi_ptr)
				like as_user_message_info;
dcl  aumi_ptr			ptr;
dcl  aumi_message_time		fixed bin(71)
				based(addr(aumi.message_id));
dcl  aumi_message (aumi.message_length) fixed bin(35) based (aumi.message_ptr);
dcl  ax				fixed bin;
dcl  AUMI_ARRAY_INCREMENT		fixed bin int static options(constant)
				init(50);

alloc_aumi:
     procedure;

     if aumi_struct.count = aumi_struct.max_count then do;
        aumi_struct_count = aumi_struct.max_count + AUMI_ARRAY_INCREMENT;
        allocate aumi_struct in (system_area) set (temp_struct_ptr);
        temp_struct_ptr -> aumi_struct.max_count = aumi_struct.max_count;
        temp_struct_ptr -> aumi_struct = aumi_struct;
        temp_struct_ptr -> aumi_struct.max_count =
	 aumi_struct.max_count + AUMI_ARRAY_INCREMENT;
        if aumi_struct_ptr ^= addr (auto_aumi_struct) then
	 free aumi_struct in (system_area);
        aumi_struct_ptr = temp_struct_ptr;
        temp_struct_ptr = null;
        end;

     ax = aumi_struct.count + 1;
     aumi_ptr = addr(aumi_struct.array(ax));
     aumi.version = AS_USER_MESSAGE_INFO_VERSION_1;
     aumi.flags = FALSE;
     aumi.flags.no_handle_given = TRUE;
     aumi.flags.dont_delete = TRUE;
     aumi.message_info.message_ptr = null;
     aumi.message_info.message_length = 0;
     aumi_struct.count = ax;
     return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

alloc_aumi$init:
     entry;

     auto_aumi_struct.count = 0;
     auto_aumi_struct.max_count = dimension(auto_aumi_struct.array,1);
     aumi_struct_ptr = addr (auto_aumi_struct);
     temp_struct_ptr = null;
     return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


alloc_aumi$term:
     entry;

     if temp_struct_ptr = aumi_struct_ptr then
        temp_struct_ptr = null;
     if temp_struct_ptr ^= null then
        free temp_struct_ptr -> aumi_struct in (system_area);
     do ax = 1 to aumi_struct.count;
        if aumi_struct.message_ptr(ax) ^= null then do;
	 aumi_ptr = addr(aumi_struct.array(ax));
	 free aumi_message in (system_area);
	 aumi.message_ptr = null;
	 end;
        end;
     if aumi_struct_ptr ^= addr (auto_aumi_struct) then
        free aumi_struct in (system_area);
     return;

     end alloc_aumi;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* ARGUMENT PROCESSING:					       */
/* Declare variables and subroutines needed for argument processing.	       */
/*							       */
/* CHECK INVOCATION TYPE:					       */
/* 1) Initialize error handling subroutines.			       */
/* 2) Determine whether invoked as command or af.			       */
/* 3) Is this type of invocation allowed?			       */
/* 4) Initialize af return argument, and index of current argument.	       */
/*							       */
/* SEE OTHER ARGUMENT PROCESSING PROGRAMS:			       */
/*   get_arg, get_ctl_arg, get_bit36_opt, get_bit72_opt		       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

dcl  af_sw			bit(1) aligned,	/* on: active fnc*/
     arg				char(argl) based(argp),
     argl				fixed bin(21),	/* current arg   */
     argp				ptr,
     argn				fixed bin,	/* arg count     */
     argx				fixed bin,	/* arg index     */
     bit_opt			bit(72) var aligned,/* 1-2 word octal*/
     opt				char(optl) based(optp),
     optl				fixed bin(21),	/* current option*/
     optp				ptr,
     ret				char(retl) varying based(retp),
     retl				fixed bin(21),	/* af return val */
     retp				ptr,
     sci_ptr			ptr;		/* ssu_ info ptr */

dcl  cu_$arg_list_ptr		entry returns(ptr),
     ssu_$abort_subsystem		entry() options(variable),
     ssu_$arg_ptr			entry (ptr, fixed bin, ptr,
				     fixed bin(21)),
     ssu_$destroy_invocation		entry (ptr),
     ssu_$print_message		entry() options(variable),
     ssu_$return_arg		entry (ptr, fixed bin, bit(1) aligned,
				     ptr, fixed bin(21)),
     ssu_$standalone_invocation	entry (ptr, char(*), char(*), ptr,
				     entry, fixed bin(35));

dcl (ALLOW_COMMAND			init(1),
     ALLOW_AF			init(2),
     ALLOW_COMMAND_AF		init(3)) fixed bin int static options(constant);

check_invocation_type:
     proc (allowed);

dcl  allowed			fixed bin;
dcl (error_table_$active_function,
     error_table_$not_act_fnc)	fixed bin(35) ext static;

     call error$init();
     call ssu_$return_arg (sci_ptr, argn, af_sw, retp, retl);
     if allowed = ALLOW_COMMAND & af_sw then
        call error$fatal (sci_ptr, error_table_$active_function);
     else if allowed = ALLOW_AF & ^af_sw then
        call error$fatal (sci_ptr, error_table_$not_act_fnc);
     else if allowed = ALLOW_COMMAND_AF then;
     if af_sw then
        ret = "";
     argx = 0;
     end check_invocation_type;



/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* CLEANUP:						       */
/* 1) Destroy the ssu_ invocation (releasing temp segs obtained thru ssu_).  */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

cleanup_invocation:
     proc;

     call alloc_aumi$term();

     if sci_ptr ^= null then
        call ssu_$destroy_invocation (sci_ptr);
     end cleanup_invocation;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


cv_access_class:
     procedure (class) returns (char(256) varying);

dcl  class			bit(72) aligned parameter;

dcl  class_str			char(256) automatic,
     code				fixed bin(35);

dcl  convert_access_class_$to_string_short
				entry (bit(72) aligned, char(*),
				     fixed bin(35));

dcl  error_table_$smallarg		fixed bin(35) ext static;

     call convert_access_class_$to_string_short (class, class_str, code);
     if code ^= 0 then do;
        if code = error_table_$smallarg then;
        else class_str = "Unknown";
        end;
     return (rtrim(class_str));

     end cv_access_class;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


cv_message_type:
     procedure (source, target, handle, message) returns (char(256) varying);

dcl (source, target)		char(32) parameter;
dcl  handle			bit(72) aligned parameter;
dcl  message			(*) fixed bin(35) parameter;

dcl  type				char(256) varying;

     if handle = SYSTEM_MESSAGE_HANDLE then do;
        type = "system message: ";
        if addr(message) ^= null then do;
	 system_message_ptr = addr(message);
	 if system_message.header.version = SYSTEM_MESSAGE_VERSION_1 then do;
	    if lbound(SYSTEM_MESSAGE_TYPES,1) <= system_message.header.type &
	       system_message.header.type <= hbound(SYSTEM_MESSAGE_TYPES,1)
	    then do;
	       type = type ||
		SYSTEM_MESSAGE_TYPES(system_message.header.type);
	       if ^brief_sw then do;
		type = type || ": ";
		type = type || rtrim(warn_system_message.caller);
		type = type || CONTINUATION_LINE;
		type = type || warn_system_message.text;
		end;
	       end;
	    else do;
	       type = type || "UNKNOWN TYPE (";
	       type = type || ltrim(char(system_message.header.type));
	       type = type || ")";
	       end;
	    end;
	 else do;
	    type = type || "UNKNOWN VERSION (";
	    type = type || rtrim(system_message.header.version);
	    type = type || ")";
	    end;
	 end;
        else
	 type = type || "NULL MESSAGE POINTER";
        end;

     else if handle = USER_MESSAGE_LS_CONNECTION_INFO_HANDLE then do;
        type = "ls ";
LS_DIAL:
        if addr(message) ^= null then do;
	 ls_connection_message_ptr = addr(message);
	 if ls_connection_message.version = LS_CONNECTION_MESSAGE_V1 then do;
	    if ls_connection_message.reason = LS_MSG_CONNECTED then
	       type = type || "connected: ";
	    else if ls_connection_message.reason = LS_MSG_DISCONNECTED then
	       type = type || "disconnected: ";
	    else do;
	       type = type || "unknown operation";
	       type = type ||
		cv_octal(unspec(ls_connection_message.reason));
	       type = type || " ";
	       end;
	    type = type || rtrim (ls_connection_message.io_module_name);
	    type = type || " ";
	    type = type || rtrim (ls_connection_message.connection_name);
	    end;
	 else do;
	    type = type || "connection: ";
	    type = type || "UNKNOWN VERSION (";
	    type = type || rtrim (ls_connection_message.version);
	    type = type || ")";
	    end;
	 end;
        else do;
	 type = type || "connection: ";
	 type = type || "NULL MESSAGE POINTER";
	 end;
        end;

     else if substr(handle, length(handle) -
        length (USER_MESSAGE_LS_CONNECTION_INFO_HANDLE_LOWER_18) + 1,
        length (USER_MESSAGE_LS_CONNECTION_INFO_HANDLE_LOWER_18)) =
        USER_MESSAGE_LS_CONNECTION_INFO_HANDLE_LOWER_18 then do;
        type = "ls dial ";
        go to LS_DIAL;
        end;

     else do;
        if addr(message) = null then
	 type = "UNKNOWN MESSAGE: NULL POINTER";
        else do;
	 as_com_channel_info_ptr, ls_response_ptr = addr(message);
	 if lbound (LS_RESPONSE_TYPES, 1) <=
	    login_server_response_header.message_type &
	    login_server_response_header.message_type <=
	    hbound (LS_RESPONSE_TYPES, 1) then do;
	    type = "ls ";
	    type = type ||
	       LS_RESPONSE_TYPES (login_server_response_header.message_type);
	    type = type || "response";

	    if login_server_response_header.message_type =
	       LS_UNKNOWN_RESPONSE then;

	    else if login_server_response_header.message_type =
	       LS_VALIDATE_RESPONSE then do;
	       if login_server_response_header.version ^=
		LS_VALIDATE_RESPONSE_VERSION_1 then do;
		type = type || ": UNKNOWN VERSION (";
		type = type ||
		   rtrim (login_server_response_header.version);
		type = type || ")";
		end;
	       else do;
		type = type || ": ";
		type = type ||
		   rtrim (login_server_validate_response.person_id);
		type = type || ".";
		type = type || 
		   rtrim (login_server_validate_response.project_id);
		if ^brief_sw then
		   type = type || cv_status_code (
		   login_server_validate_response.status_code);
		end;
	       end;

	    else if login_server_response_header.message_type =
	       LS_PROCESS_RESPONSE then do;
	       if login_server_response_header.version ^=
		LOGIN_SERVER_PROCESS_RESPONSE_VERSION_1 then do;
		type = type || ": UNKNOWN VERSION (";
		type = type ||
		   rtrim (login_server_response_header.version);
		type = type || ")";
		end;
	       else do;
		type = type || ": ";
		type = type ||
		   rtrim (login_server_process_response.process_group_id);
		if ^brief_sw then do;
		   type = type || CONTINUATION_LINE;
		   if login_server_process_response.flags.
		      message_coordinator then
		      type = type || "MESSAGE COORD";
		   else if login_server_process_response.flags.created then
		      type = type || "CREATE";
		   else
		   if login_server_process_response.flags.connected then
		      type = type || "CONNECT";
		   else
		   if login_server_process_response.flags.new_proc then
		      type = type || "NEW_PROC";
		   else
		   if login_server_process_response.flags.destroyed then
		      type = type || "DESTROY";
		   if login_server_process_response.process_id ^= ""b
		   then 
		      type = type || cv_octal (
		         login_server_process_response.process_id);
		   type = type || cv_status_code (
		      login_server_process_response.status_code);
		   if login_server_process_response.
		      accounting_message_length > 0 then do;
		      type = type || ": ";
		      type = type ||
		         login_server_process_response.accounting_message;
		      end;
		   end;
		end;
	       end;

	    else if login_server_response_header.message_type =
	       LS_LIST_RESPONSE then do;
	       if login_server_response_header.version ^=
		LOGIN_SERVER_LIST_RESPONSE_VERSION_1 then do;
		type = type || ": UNKNOWN VERSION (";
		type = type ||
		   rtrim (login_server_response_header.version);
		type = type || ")";
		end;
	       end;

	    else if login_server_response_header.message_type =
	       LS_DIAL_RESPONSE then do;
	       if login_server_response_header.version ^=
		LOGIN_SERVER_DIAL_RESPONSE_VERSION_1 then do;
		type = type || ": UNKNOWN VERSION (";
		type = type ||
		   rtrim (login_server_response_header.version);
		type = type || ")";
		end;
	       else do;
		type = type || ": ";
		type = type ||
		   rtrim (login_server_dial_response.process_group_id);
		if ^brief_sw then 
		   type = type || cv_octal (
		      login_server_dial_response.process_id);
		end;
	       end;

	    else if login_server_response_header.message_type =
	       LS_TERMINATION_RESPONSE then do;
	       if login_server_response_header.version ^=
		LOGIN_SERVER_TERMINATION_RESPONSE_VERSION_1 then do;
		type = type || ": UNKNOWN VERSION (";
		type = type ||
		   rtrim (login_server_response_header.version);
		type = type || ")";
		end;
	       else do;
		type = type || ": ";
		type = type || rtrim (
		   login_server_termination_response.process_group_id);
		if ^brief_sw then do;
		   type = type ||
		      cv_octal (
		      login_server_termination_response.process_id);
		   type = type || CONTINUATION_LINE;
		   if login_server_termination_response.flags.new_proc then
		      type = type || "new_proc";
		   else if login_server_termination_response.
		      flags.fatal_error then
		      type = type || "fatal error";
		   else
		      type = type || "logout";
		   type = type || cv_status_code (
		      login_server_termination_response.status_code);
		   end;
		end;
	       end;	    

	    else if login_server_response_header.message_type =
	       LS_NEW_PROC_RESPONSE then do;
	       if login_server_response_header.version ^=
		LOGIN_SERVER_NEW_PROC_RESPONSE_VERSION_1 then do;
		type = type || ": UNKNOWN VERSION (";
		type = type ||
		   rtrim (login_server_response_header.version);
		type = type || ")";
		end;
	       else
		type = type || cv_octal (
		login_server_new_proc_response.new_process_id);
	       end;     

	    else if login_server_response_header.message_type =
	       LS_OPERATOR_RESPONSE then do;
	       if login_server_response_header.version ^=
		LOGIN_SERVER_OPERATOR_RESPONSE_VERSION_1 then do;
		type = type || ": UNKNOWN VERSION (";
		type = type ||
		   rtrim (login_server_response_header.version);
		type = type || ")";
		end;
	       else do;
		type = type || ": ";
		type = type ||
		   rtrim (login_server_operator_response.process_group_id);
		if ^brief_sw then do;
		   if login_server_operator_response.process_id ^= ""b then
		      type = type || cv_octal (
		      login_server_operator_response.process_id);
		   type = type || cv_status_code (
		      login_server_operator_response.status_code);
		   end;
		end;
	       end;
	    end;

	 else if dimension(message,1) = size(as_com_channel_info) &
	    as_com_channel_info.version =
	    AS_COM_CHANNEL_INFO_VERSION_1 then do;
	    type = "com channel info";
	    if ^brief_sw then do;
	       type = type || " for ";
	       type = type || rtrim(as_com_channel_info.channel_name);
	       end;
	    end;

	 else
	    type = "UNKNOWN MESSAGE TYPE";
	 end;
        end;
     return (type);

     end cv_message_type;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* cv_octal: return octal representation of a word.		       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


cv_octal:
     procedure (word) returns (char(13));

dcl  word				bit(36) aligned parameter;

dcl  octal_id			char(13);

dcl  ioa_$rsnnl			entry() options(variable);

     call ioa_$rsnnl (" ^12.3b", octal_id, 0, word);
     return (octal_id);

     end cv_octal;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


cv_status_code:
     procedure (code) returns (char(100) varying);

dcl  code				fixed bin(35) parameter;

dcl  long				char(100) aligned,
     short			char(8) aligned;
     
dcl  convert_status_code_		entry (fixed bin(35), char(8) aligned,
				     char(100) aligned);

     if code = 0 then
        return ("");
     call convert_status_code_ (code, short, long);
     if short ^= "" then
        return (" (" || rtrim(short) || ")");
     else
        return (" (" || rtrim(long) || ")");
     end cv_status_code;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


cv_target:
     procedure (target) returns (char(32) varying);

dcl  1 target			aligned parameter
				like as_user_message_info.destination_info;

dcl  code				fixed bin(35),
     group			char(32) varying,
     pers				char(24),
     proj				char(12),
     tag				char(1);

dcl  get_userid_$info		entry (bit(36) aligned, char(*),
				     char(*), char(*), fixed bin,
				     fixed bin, fixed bin, 
				     fixed bin(35));

     if target.process_id = ""b then
        return (rtrim (target.group_id));
     else if target.group_id ^= "" & target.group_id ^= "*.*.*" then
        return (rtrim (target.group_id));
     else do;
        call get_userid_$info (target.process_id, pers, proj, tag, 0,
	   0, 0, code);
        if code = 0 then do;
	 group = rtrim(pers);
	 group = group || ".";
	 group = group || rtrim(proj);
	 group = group || ".";
	 group = group || tag;
	 return (group);
	 end;
        else do;
	 return (cv_octal (target.process_id));
	 end;
        end;

     end cv_target;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* display_message:  Display one matching user message.		       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

dcl  1 begin			aligned automatic,
       2 (target, type)		fixed bin;
dcl  matching_entries		fixed bin;
dcl  need_heading			bit(1) aligned automatic;
dcl  1 width			aligned automatic,
       2 (source, target, type)	fixed bin;

display_message:
     procedure;

     matching_entries = matching_entries + 1;

     if brief_sw then do;
        if need_heading then do;
	 call ioa_ (
	    "^/SOURCE^vtTARGET^vtMESSAGE",
	    begin.target, begin.type);
	 need_heading = "0"b;
	 end;
        call ioa_ ("^a^vt^a^vt^a",  before(aumi.sender_info.group_id, "."),
	 begin.target, before (cv_target (aumi.destination_info), "."),
	 begin.type, cv_message_type (aumi.sender_info.group_id,
	 aumi.destination_info.group_id, aumi.message_handle, aumi_message));
        end;

     else do;
        call ioa_ ("");
        call ioa_ ("Source name:    ^32a pid:  ^12.3b",
	 aumi.sender_info.group_id, aumi.sender_info.process_id);
        call ioa_ ("Target name:    ^32a pid:  ^12.3b    ring:  ^d",
	 cv_target(aumi.destination_info), aumi.destination_info.process_id,
	 aumi.destination_info.ring);
        call ioa_ ("Message handle: ^24.3b^8x  id:  ^24.3b",
	 aumi.message_handle, aumi.message_id);
        call ioa_ ("Message time:   ^a",
	 date_time_$format ("clock", aumi_message_time, "", ""));
        if aumi.message_access_class ^= ""b then
	 call ioa_ ("Message class:  ^a",
	 cv_access_class (aumi.message_access_class));
        if aumi.message_ring ^= 4 then
	 call ioa_ ("Message ring:   ^d", aumi.message_ring);
        call ioa_ ("Message length: ^d words", aumi.message_length);
        call ioa_ ("Message type:   ^a",
	 cv_message_type (aumi.sender_info.group_id,
	 aumi.destination_info.group_id, aumi.message_handle, aumi_message));

        if octal_sw & aumi.message_length > 0 then do;
	 call ioa_ ("");
	 string(dump_segment_format_structure) = ""b;
	 dump_segment_format_structure.offset = TRUE;
	 dump_segment_format_structure.ascii = TRUE;
	 dump_segment_format_structure.raw_data = TRUE;
	 dump_segment_format_structure.interpreted_data = TRUE;
	 dump_segment_format_structure.suppress_duplicates = TRUE;
	 call dump_segment_ (iox_$user_output, addr(aumi_message),
	    DO_NOT_BLOCK, ZERO_OFFSET, dimension(aumi_message,1),
	    dump_segment_format);
	 end;
        end;
     return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


display_message$init:
     entry;

     matching_entries = 0;
     need_heading = TRUE;
     width.source = length("SOURCE");
     width.target = length("TARGET");
     width.type = length("TYPE");
     begin = 0;
     return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


display_message$matching_entry_count:
     entry returns (fixed bin);
     return (matching_entries);

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


display_message$set_widths:
     entry;

dcl (COLUMN_1			init(1),
     COLUMN_GUTTER			init(2)) fixed bin int static
				options(constant);

     width.source = max (width.source,
        length (before (rtrim (aumi.sender_info.group_id), ".")));
     width.target = max (width.target,
        length (before (cv_target (aumi.destination_info), ".")));
     width.type = max (width.type,
        length (cv_message_type (aumi.sender_info.group_id,
        aumi.destination_info.group_id, aumi.message_handle, aumi_message)));
     begin.target = COLUMN_1 + width.source + COLUMN_GUTTER;
     begin.type = begin.target + width.target + COLUMN_GUTTER;
     end display_message;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* ERROR REPORTING ROUTINES:					       */
/* 1) Nonfatal errors set a switch, which can be tested via error_occurred   */
/*    function.						       */
/* 2) Fatal errors abort the subsystem by calling the exit_proc, which       */
/*    branches to the EXIT label to exit the command.		       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

dcl  error_occurred_sw		bit(1);

error:
     proc options (variable);

dcl  code				fixed bin(35) based (codep),
     codep			ptr;

dcl  cu_$arg_list_ptr		entry returns(ptr),
     cu_$arg_ptr			entry (fixed bin, ptr, fixed bin(21),
				     fixed bin(35)),
     cu_$generate_call		entry (entry, ptr);

dcl  CODE_ARG			fixed bin int static options(constant) init(2),
    (FALSE			init("0"b),
     TRUE				init("1"b)) bit(1) int static options(constant);

     call cu_$arg_ptr (CODE_ARG, codep, 0, 0);
     if code = 0 then return;
     if code = -1 then code = 0;
     error_occurred_sw = TRUE;
     call cu_$generate_call (ssu_$print_message, cu_$arg_list_ptr());
     return;


error$init:
     entry;
     error_occurred_sw = FALSE;
     return;


error$occurred:
     entry returns (bit(1));
     return (error_occurred_sw);
	

error$fatal:
     entry options(variable);
	
     call cu_$arg_ptr (CODE_ARG, codep, 0, 0);
     if code = 0 then return;
     if code = -1 then code = 0;
     error_occurred_sw = TRUE;
     call ioa_ ("");
     call cu_$generate_call (ssu_$abort_subsystem, cu_$arg_list_ptr());
     end error;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* ARGUMENT GETTING FUNCTIONS:				       */
/*  get_arg: 	Get next argument.				       */
/*  get_arg_count:	Get number of arguments.			       */
/*  get_ctl_arg:	Get next argument, which must be a control argument.     */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

get_arg:
     proc returns (bit(1));

dcl (FALSE			init("0"b),
     TRUE				init("1"b)) bit(1) int static options(constant);

     if argx < argn then do;
        argx = argx + 1;
        call ssu_$arg_ptr (sci_ptr, argx, argp, argl);
        return (TRUE);
        end;
     else
        return (FALSE);
     end get_arg;


get_ctl_arg:
     proc returns (bit(1));

dcl  index			builtin;

dcl (FALSE			init("0"b),
     TRUE				init("1"b)) bit(1) int static options(constant),
     error_table_$bad_arg		fixed bin(35) ext static;

     if get_arg() then
        if index(arg, "-") = 1 then
        return (TRUE);
     else
        call error$fatal (sci_ptr, error_table_$bad_arg,
        "^a.^/A control argument was expected.", arg);
     return (FALSE);
     end get_ctl_arg;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* CONTROL ARG OPERAND GETTING FUNCTIONS:			       */
/*  get_bit36_opt:  Gets next arg, treats it as an octal integer operand.    */
/*  get_bit72_opt:  Gets next arg, treats it as 2-word octal integer operand.*/
/*  get_opt:        Gets next arg.				       */
/*							       */
/* Both allow the caller to specify whether the operand is required (an      */
/* opt_desc is provided) or optional (opt_desc="").		       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

get_bit36_opt:
     proc (arg_name, opt_desc) returns (bit(1));

dcl  arg_name			char(*),
     opt_desc			char(*);

dcl  code				fixed bin(35);
dcl  max_bits			fixed bin;
dcl (FALSE			init("0"b),
     TRUE				init("1"b)) bit(1)
				     int static options(constant),
    (error_table_$bad_arg,
     error_table_$noarg)		fixed bin(35) ext static;

     max_bits = 36;
     go to GET_BIT_COMMON;

get_bit72_opt:
     entry (arg_name, opt_desc) returns (bit(1));
     max_bits = 72;

GET_BIT_COMMON:
     if argx < argn then do;
        argx = argx + 1;
        call ssu_$arg_ptr (sci_ptr, argx, optp, optl);
        bit_opt = oct_to_bit (opt, max_bits, code);
        if code ^= 0 then do;
	 call error (sci_ptr, error_table_$bad_arg,
	    "^a ^a
^a must be followed by a^[n^] ^a.",
	    arg_name, opt, arg_name,
	    vowel(opt_desc), opt_desc);
	 return (FALSE);
	 end;
        else return (TRUE);
        end;
     else if opt_desc ^= "" then do;
        call error (sci_ptr, error_table_$noarg,
	 "^/^a must be followed by a^[n^] ^a.", arg_name,
	 vowel(opt_desc), opt_desc);
        return (FALSE);
        end;
     else return (FALSE);
     end get_bit36_opt;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


get_opt:
     proc (arg_name, opt_desc) returns (bit(1));

dcl  arg_name			char(*),
     opt_desc			char(*);

dcl (FALSE			init("0"b),
     TRUE				init("1"b)) bit(1) int static options(constant),
     error_table_$noarg		fixed bin(35) ext static;

     if argx < argn then do;
        argx = argx + 1;
        call ssu_$arg_ptr (sci_ptr, argx, optp, optl);
        if index(opt, "-") = 1 then do;			/* options cannot*/
	 argx = argx - 1;				/*  look like    */
	 go to NO_OPT;				/*  control args */
	 end;
        else
	 return (TRUE);
        end;

     else
NO_OPT:
     if opt_desc ^= "" then do;
        call error (sci_ptr, error_table_$noarg,
	 "^/^a must be followed by a^[n^] ^a.", arg_name,
	 vowel(opt_desc), opt_desc);
        return (FALSE);
        end;
     return (FALSE);
     end get_opt;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


vowel:
     proc (str) returns (bit(1));			/* does opt_desc */
						/* begin with a  */
						/* vowel?	       */

dcl  str				char(*);

dcl (search, substr)		builtin;

dcl (FALSE			init("0"b),
     TRUE				init("1"b)) bit(1) int static options(constant);

     if search ("aeiouAEIO", substr(str,1,1)) > 0 then
        return (TRUE);
     else
        return (FALSE);
     end vowel;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


group_id:
     procedure (arg) returns (1 like source);

dcl  arg				char(*);
dcl  1 group			aligned automatic like source;

     group.id = arg;
     group.person = before(arg,".");
     if group.person = "" then group.person = "*";
     group.project = before(after(arg,"."),".");
     if group.project = "" then group.project = "*";
     group.tag = after(after(arg,"."),".");
     if group.tag = "" then group.tag = "*";
     return (group);

     end group_id;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* INITIALIZATION.						       */
/* 1) Initialize variables holding argument values.		       */
/* 2) Initialize ssu_ info pointer.				       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

initialize_args:
     proc;

     sci_ptr = null;

     brief_sw = TRUE;
     octal_sw = FALSE;

     exclude, match, source, target = "";
     source_id, target_id, message_id, message_handle = ""b;

     call alloc_aumi$init();

     aumari.version = AS_USER_MESSAGE_ADMIN_READ_INFO_VERSION_1;
     aumari.source_group_id = "";
     aumari.source_process_id = ""b;
     aumari.target_group_id = "";
     aumari.target_process_id = ""b;
     aumari.target_handle = ""b;
     aumari.after_message_id = ""b;

     call display_message$init();

     system_area_ptr = get_system_free_area_ ();

     end initialize_args;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* matching_entry: return TRUE if active_connection_list entry match the     */
/* criteria given in input control args.  Otherwise, return FALSE.	       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

matching_entry:
     procedure returns (bit(1));

dcl  ok_so_far			bit(1);

     ok_so_far = TRUE;
     if message_id ^= ""b & ok_so_far then
        ok_so_far = (aumi.message_id = message_id);

     if message_handle ^= ""b & ok_so_far then
        ok_so_far = (aumi.message_handle = message_handle);

     if source_id ^= ""b & ok_so_far then
        ok_so_far = (aumi.sender_info.process_id = source_id);

     if target_id ^= ""b & ok_so_far then
        ok_so_far = (aumi.destination_info.process_id = target_id);

     if source.id ^= "" & ok_so_far then do;
        if source.person ^= "*" then
	 ok_so_far = (source.person = before(aumi.sender_info.group_id,"."));
        if source.project ^= "*" & ok_so_far then
	 ok_so_far = 
	 (source.project = before(after(aumi.sender_info.group_id,"."),"."));
        if source.tag ^= "*" & ok_so_far then
	 ok_so_far =
	 (source.tag = after(after(aumi.sender_info.group_id,"."),"."));
        end;

     if target.id ^= "" & ok_so_far then do;
        if aumi.destination_info.group_id = "" |
	 aumi.destination_info.group_id = "*.*.*" then 
	 aumi.destination_info.group_id = cv_target (aumi.destination_info);
        if target.person ^= "*" then
	 ok_so_far =
	 (target.person = before(aumi.destination_info.group_id,"."));
        if target.project ^= "*" & ok_so_far then
	 ok_so_far = (target.project =
	 before(after(aumi.destination_info.group_id,"."),"."));
        if target.tag ^= "*" & ok_so_far then
	 ok_so_far =
	 (target.tag = after(after(aumi.destination_info.group_id,"."),"."));
        end;

     if match ^= "" & ok_so_far then do;
        ok_so_far = index (cv_message_type (aumi.sender_info.group_id,
	 aumi.destination_info.group_id, aumi.message_handle, aumi_message),
	 match) > 0;
        end;
     
     if exclude ^= "" & ok_so_far then do;
        ok_so_far = index (cv_message_type (aumi.sender_info.group_id,
	 aumi.destination_info.group_id, aumi.message_handle, aumi_message),
	 exclude) = 0;
        end;

     return (ok_so_far);

     end matching_entry;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* oct_to_bit: converts octal integer to bit(36) or bit(72) string.	       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

oct_to_bit:
     procedure (integer, max_bits, code) returns (bit(72) varying aligned);

dcl  integer			char(*) parameter;
dcl  max_bits			fixed bin;
dcl  code				fixed bin(35) parameter;
     
dcl  bits				bit(73) varying;
dcl  digit			fixed bin;
dcl  oct_bits (48:55 /* = 060:067 octal = "0":"7" */)
				bit(3) int static options(constant)
      init("0"b3, "1"b3, "2"b3, "3"b3, "4"b3, "5"b3, "6"b3, "7"b3);

dcl (length, rank, substr, verify)	builtin;

dcl  ZERO_BITS			bit(72) aligned int static
				options(constant) init("0"b);

dcl (error_table_$bad_conversion,
     error_table_$size_error)		fixed bin(35) ext static;

     code = 0;

     if verify (integer, "01234567") > 0 then do;		/* check for     */
        code = error_table_$bad_conversion;		/* nonoctal      */
        return (""b);				/* digits	       */
        end;

     bits = ""b;					/* convert octal */
     do digit = 1 to length(integer);			/* digits to bits*/
        bits = bits || oct_bits(rank(substr(integer,digit,1)));
        end;

     if length(bits) > max_bits then do;		/* check for too */
        code = error_table_$size_error;			/* many digits   */
        return (""b);
        end;

     bits = substr(ZERO_BITS, 1, max_bits - length(bits)) || bits;
						/* right adjust  */
     return (bits);

     end oct_to_bit;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* PROCESS ARGUMENTS					       */
/* 1) Match argument to ctl_arg name and operands.		       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

process_args:
     proc;

CTL_ARG_LOOP:
     do while (get_ctl_arg ());

        if arg = "-brief" | arg = "-bf" then 
	 brief_sw = TRUE;
        else if arg = "-long" | arg = "-lg" then
	 brief_sw = FALSE;
        else if arg = "-octal" | arg = "-oc" then 
	 octal_sw = TRUE;
        else if arg = "-no_octal" | arg = "-noc" then
	 octal_sw = FALSE;

        else if arg = "-source" | arg = "-sc" then do;
	 if get_opt (arg, "source group id") then
	    source = group_id (opt);
	 end;
        else if arg = "-target" | arg = "-tgt" then do;
	 if get_opt (arg, "target group id") then
	    target = group_id (opt);
	 end;

        else if arg = "-source_id" | arg = "-scid" | arg = "-sid" then do;
	 if get_bit36_opt (arg, "octal source process id") then
	    source_id = bit_opt;
	 end;
        else if arg = "-target_id" | arg = "-tgtid" | arg = "-tid" |
	      arg = "-process_id" | arg = "-processid" |
	      arg = "-pid" then do;
	 if get_bit36_opt (arg, "octal target process id") then
	    target_id = bit_opt;
	 end;

        else if arg = "-message_id" | arg = "-mid" then do;
	 if get_bit72_opt (arg, "octal message identifier") then
	    message_id = bit_opt;
	 end;

        else if arg = "-handle" | arg = "-hdl" then do;
	 if get_bit72_opt (arg, "octal message handle") then
	    message_handle = bit_opt;
	 end;

        else if arg = "-match_data" | arg = "-match" then do;
	 if get_opt (arg, "match string") then
	    match = opt;
	 end;
        else if arg = "-exclude_data" | arg = "-exclude" | arg = "-ex" then do;
	 if get_opt ( arg, "exclude string") then
	    exclude = opt;
	 end;

        else if index (arg, "-") ^= 1 then
	 call error (sci_ptr, error_table_$bad_arg, "^a
Usage: ^a {-control_args}", arg, ME);

        else
	 call error (sci_ptr, error_table_$bad_opt, "^a", arg);
        end CTL_ARG_LOOP;

     if octal_sw then				/* -octal implies*/
        brief_sw = FALSE;				/* -brief.       */

     if error$occurred() then				/* stop now if   */
        call error$fatal (sci_ptr, -1);			/* ctl arg errs  */

     end process_args;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* scan_messages:  Walk through user message entries, displaying	       */
/* those that match the user's criteria.			       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

scan_messages:
     procedure;

     on linkage_error begin;
        call error$fatal (sci_ptr, -1,
	 "Incorrect access to the user_message_admin_ gate.");
        end;
     entry_var = user_message_admin_$read_message;	/* force linkage */
     revert linkage_error;				/* error now.    */

     aumari.after_message_id = "0"b;			/* get 1st entry */
     code = 0;
     do while (code = 0);
        call alloc_aumi();
        call user_message_admin_$read_message (addr(aumari), addr(aumi),
	 addr(system_area), code);
        if code ^= 0 then
	 aumi_struct.count = aumi_struct.count - 1;
        else aumari.after_message_id = aumi.message_id;	/* get next entry*/
        end;

     if brief_sw then
     do ax = 1 to aumi_struct.count;
        aumi_ptr = addr (aumi_struct.array(ax));
        if matching_entry() then 
	 call display_message$set_widths();
        end;
     
     do ax = 1 to aumi_struct.count;
        aumi_ptr = addr (aumi_struct.array(ax));
        if matching_entry() then
	 call display_message();
        end;

     if code ^= error_table_$no_message then
        call error$fatal (sci_ptr, code, "Getting user messages.");

     if display_message$matching_entry_count() = 0 then
        call error$fatal (sci_ptr, -1,
        "No matching user messages were found.");

     end scan_messages;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
 %include as_com_channel_info;
 %include as_user_message_aread;

dcl  1 aumari			aligned automatic like as_user_message_admin_read_info;
 %include as_user_message_info;
 %include dialup_values;
 %include dump_segment_format;
 %include login_server_messages;
 %include ls_connection_message;
 %include system_message;
 %include user_message_handles;
 %include user_attributes;
 %include user_table_entry;

     end display_user_messages;
