/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1992   *
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */





/****^  HISTORY COMMENTS:
  1) change(86-01-07,Blair), approve(86-02-26,MCR7358),
     audit(86-04-21,RBarstad), install(86-05-28,MR12.0-1062):
     85-04-01 JG Backs: Deleted the constant ASK because it was added to the
     include file xmail_responses.incl.pl1 and resulted in a compiler warning.
     85-05-07 JG Backs: Add an internal procedure to handle the new personalize
     Include Original in Reply option.
  2) change(86-01-07,Blair), approve(86-02-26,MCR7358),
     audit(86-04-21,RBarstad), install(86-05-28,MR12.0-1062):
     Move code to indicate reply was completed to before the code that
     asks if the message should be saved.  Add code to file the original
     before filing the reply when indicated.  Allow for suppressing the
     display of the original message in the upper window when indicated.
  3) change(86-01-17,Blair), approve(86-02-26,MCR7358),
     audit(86-04-21,RBarstad), install(86-05-28,MR12.0-1062):
     Check the delete_def_reply flag in CLEAN_UP to make sure that deleted
     deferred replies get deleted on cleanup.  TR 18152.
  4) change(86-01-28,Blair), approve(86-02-26,MCR7358),
     audit(86-04-21,RBarstad), install(86-05-28,MR12.0-1062):
     Add handler for reissue_query condition so that any question can be
     reissued after the user has hit break in response and then indicated that
     he wishes to continue.  TRs 18711 18974.
  5) change(86-10-15,Blair), approve(86-10-15,MCR7564),
     audit(86-10-28,RBarstad), install(86-10-29,MR12.0-1201):
     Make replies which include the original message display the message
     envelope so that the "Sender:" field will be displayed.  Fixes error_list
     129.
  6) change(87-01-21,Blair), approve(87-02-05,MCR7618),
     audit(87-04-10,RBarstad), install(87-04-26,MR12.1-1025):
     Grow the reply_msg buffer as necessary since 5000 characters isn't
     isn't always big enough.  Error_list 136.
  7) change(87-02-13,Blair), approve(87-02-13,MCR7618),
     audit(87-04-10,RBarstad), install(87-04-26,MR12.1-1025):
     Set the static variable reply_request in xmail_data so that we'll be able
     to know that a reply was being processed when a disconnect occured.  Error
     list #114.
  8) change(87-11-06,Blair), approve(87-12-10,MCR7818),
     audit(87-12-23,LJAdams), install(88-01-12,MR12.2-1013):
     Move heaven and earth to add the "Reply-To:" field to deferred msgs so
     that when we get to the emacs editor, the user can edit this field.
     Rearrange code to query in the correct sequence (ask if we are to use
     deferred before we decide whether or not to include the original.
     Also make sure we don't delete the deferred reply when we defer a
     reply that was originally deferred.
  9) change(92-09-10,Zimmerman), approve(92-09-10,MCR8256), audit(92-09-15,Vu),
     install(92-10-06,MR12.5-1022):
     Fix bug with "Reply-To:" field.
                                                   END HISTORY COMMENTS */


xmail_reply_msg_: procedure (P_mailbox_ptr, P_curr_msgs_ptr);

/* BEGIN DESCRIPTION

function:

   This proc is invoked as a consequence of the user selecting the Reply
   option on the Process Incoming Mail or Process Filed Mail nemus. The
   being-replied-to message is displayed on the upper portion of the screen.
   The proc calls emacs so that the reply text can be composed and also to 
   permit the user to modify the default recipient list. If the user has so
   specified the message will be saved in the "outgoing" mbx. The reply will
   be acknowledged if the user has so specified. 

history:

   81-07-11  Written by R. Ignagni, extensively updated in Nov 1981

   83-07-18  DJ Schimke: Modified to use new mail_system calls and version 2
   mailboxes.

   83-09-15  DJ Schimke: Increased the initial size of the based array from
   600 characters to 5000 characters. The array wasn't always big enough for
   very large to or cc fields. 5000 should be plenty. phx13809

   83-09-21  DJ Schimke: Modified to query the user before creating a new mail
   file to save a copy of the reply. This is only in effect when save-outgoing
   is set to "ask". phx13779

   83-10-12  DJ Schimke: Replaced the call to mail_system_$save_message and
   associated code with a call to xmail_file_msgs_$single_msg;

   83-10-26 DJ Schimke: Changed call to xmail_window_manager_$reconnect to a 
   call to xmail_window_manager_$quit_handler so the quit condition handler
   can special-case the reconnect condition which should NOT interrupt 
   processing after the quit. phx 13227 This entry also prompts when not at
   a reconnect condition so that unintentionally hitting the BREAK won't throw 
   away any pending work. phx 13018

   83-11-22 DJ Schimke: Removed the test for cc string ^= "" before parsing and
   replacing the cc_list_ptr in the reply message. This test didn't allow the
   user to delete the cc list even when xmail claimed to have deleted it.

   83-11-23 DJ Schimke: Added support for the new personalization option
   "Outgoing Savefile" which allows selection of where to file save messages.
   This also solves the discrepancy between setting "Save Outgoing messages"
   to "yes" and never having set "Save Outgoing messages".

   83-12-07 DJ Schimke: Cleaned up the reporting of delivery results by calling
   mlsys_utils_$print_delivery_results_ and mlsys_utils_$print_address_field 
   for displaying the failure/success of sending. This module still needs 
   recovery code to allow the sender to correct the bad addresses and continue.
   Deleted unused variable transition_state.

   83-12-08 DJ Schimke: Added simple flag to prevent the call to 
   mlsys_util_$free_delivery_results until the call to send the msg has been 
   made. Otherwise, this cleanup will get errors referencing invalid pointers.

   83-02-20 DJ Schimke: Modified the cleanup code so recipients_info is only
   freed by the CLEANUP procedure instead of the MESSAGE_CLEAN_UP procedure.
   This fixes a problem referencing recipients_info when replying to more than 
   one message (curr_msgs.count > 1). 

   84-08-08 JG Backs: Modified for the addition of blind carbon copies (bcc).

   84-11-08 JG Backs: Deleted the spaces within the quotes of "To:", "cc:"
   and "bcc:" when used in the calls to mlsys_utils_$parse_address_list_text.
   The spaces were not needed and were inconsistant across modules.  Audit
   change.

   

END DESCRIPTION
*/

/* PARAMETERS */

	dcl     P_mailbox_ptr	 ptr parameter;
	dcl     P_curr_msgs_ptr	 ptr parameter;


/* CONDITIONS */

	dcl     (quit, cleanup, reissue_query)	 condition;

/* EXTERNAL STATIC */

	dcl     error_table_$bad_segment ext static fixed bin (35);
	dcl     error_table_$namedup	 ext static fixed bin (35);
	dcl     error_table_$segknown	 ext static fixed bin (35);
          dcl     error_table_$smallarg  ext static fixed bin (35);
	dcl     iox_$user_output	 ptr external static;
	dcl     mlsys_et_$no_a_permission static ext fixed bin (35);

/* CONSTANTS */

	dcl     ALLOW_SELECTION	 bit (1) aligned static options (constant) init ("1"b);
	dcl     ACKNOWLEDGE		 char (14) static options (constant) init ("acknowledge_yn");
	dcl     CONTINUE		 char (1) static options (constant) init ("c");
	dcl     BITS_PER_CHAR	 fixed bin static options (constant) init (9);
	dcl     DEFAULT_WIDTH	 fixed bin static options (constant) init (72);
	dcl     DELETE_SEG_FORCE	 bit (6) static options (constant) init ("100100"b);
	dcl     DELETE_SEG_FORCE_CHASE bit (6) static options (constant) init ("100101"b);
	dcl     EMACS_EXT		 char (21) options (constant) init ("xmail_emacs_ext_main_") int static;
	dcl     ENTRY_NAME		 entry variable init (xmail_reply_msg_);
	dcl     ERROR_MESSAGE	 char (69) static options (constant) init ("Reply to message no. ^d terminated, due to an internal program error.");
	dcl     ERRORS_ONLY		 bit (1) aligned static options (constant) init ("1"b);
	dcl     FILE_ORIGINAL	 char (32) static options (constant) init ("file_original_yn");
	dcl     FORMAT_SEG_NAME	 char (32) static options (constant) init ("format_orig_seg");
	dcl     INCLUDE_ORIGINAL	 char (19) static options (constant) init ("include_original_yn");
	dcl     LOG		 char (1) static options (constant) init ("l");
	dcl     MAILFILE_SUFFIX	 char (6) static options (constant) init ("sv.mbx");
	dcl     NAME		 char (16) static options (constant) init ("xmail_reply_msg_");
	dcl     NL		 char (1) aligned static options (constant) init ("
");
	dcl     NO_SELECTION	 bit (1) aligned static options (constant) init ("0"b);
	dcl     NO_WIDTH_LIMIT	 fixed bin static options (constant) init (-1);
	dcl     ORIGINAL_IN_WINDOW	 char (21) static options (constant) init ("original_up_window_yn");
	dcl     ORIG_SEG_NAME	 char (32) static options (constant) init ("orig_reply_seg");
	dcl     PROBLEM		 char (60) static options (constant) init ("Replying terminated. An internal program error has occurred.");
	dcl     REPLY_SEG_NAME	 char (13) static options (constant) init ("reply_msg_seg");
	dcl     QUIT		 char (1) static options (constant) init ("q");
	dcl     SECONDS		 bit (2) static options (constant) init ("11"b);
	dcl     SAVE_MAILBOX	 char (15) static options (constant) init ("save_mailfile");
	dcl     SAVE_MESSAGE	 char (15) static options (constant) init ("save_message_yn");
	dcl     STOP		 char (1) static options (constant) init ("q");
	dcl     USE_SCREEN_WIDTH	 fixed bin aligned static options (constant) init (-1);
	dcl     VIEW_SEG_NAME	 char (32) static options (constant) init ("view_reply_seg");
	dcl     WHITE_SPACE_COMMA	 char (6) aligned static options (constant) init ("
	  ,");					/* HT VT NL <space> comma */

/* INTERNAL STATIC */

	dcl     ext_pname		 char (168) int static;
	dcl     ext_ptr		 ptr init (null) int static;
	dcl     ext_dir		 char (168) int static;
	dcl     ext_file		 char (32) int static;

/* AUTOMATIC */

	dcl     acknowledge		 char (3) varying;
	dcl     bcc_list_ptr	 ptr;
	dcl     bit_count		 fixed bin (24);
	dcl     bit_count_view	 fixed bin (24);
          dcl     buffer_size            fixed bin (21);
          dcl     buffer_used            fixed bin (21);
	dcl     cc_list_ptr		 ptr;
	dcl     code		 fixed bin (35);
	dcl     code1		 fixed bin (35);
	dcl     default_save_file	 char (32) var;
	dcl     deferred_reply_exists	 bit (1);
	dcl     deferred_seg_name	 char (32) var;
	dcl     defrepl_seg_ptr	 ptr;
	dcl     delete_def_reply	 bit (1);
	dcl     delivery_results_need_cleanup bit (1) aligned;
	dcl     emacs_seg_path_name	 char (168);
	dcl     file_original	 char (3) var;
	dcl     for_type		 char (32);
          dcl     format_reply_length    fixed bin;
          dcl     format_reply           char (33);
	dcl     format_seg_ptr	 ptr;		/* ptr to temp segment for indented formatted original message */
	dcl     idx		 fixed bin;
	dcl     idx2		 fixed bin;
	dcl     iocb_ptr		 ptr;
	dcl     include_original	 bit (1);		/* flag: "1"=yes*/
	dcl     message_num		 fixed bin;
	dcl     more_than_one	 bit (1);
	dcl     no_chars		 fixed bin (21);
	dcl     no_chars_format	 fixed bin (21);
	dcl     no_chars_orig	 fixed bin (21);
	dcl     no_chars_view	 fixed bin (21);
	dcl     no_used		 fixed bin (21);
          dcl     opt                    fixed bin;
	dcl     original_in_window	 bit (1);		/* flag: "1"=yes */
	dcl     orig_seg_ptr	 ptr;		/* ptr to temp segment for printable original message */
	dcl     prompt_string	 char (160) var;
	dcl     repl_message_ptr	 ptr;
	dcl     reply_header	 char (27);
	dcl     reply_msg_area_ptr	 ptr;
	dcl     reply_msg_ptr	 ptr;
	dcl     reply_seg_ptr	 ptr;
	dcl     reply_to_list_ptr      ptr;
	dcl     resp		 char (1) var;
	dcl     response		 char (3) varying;	/* yes no or ask */
	dcl     save_message	 char (3) var;
	dcl     saved_menu_size	 fixed bin;
	dcl     sci_ptr		 ptr;
	dcl     start_of_bcc	 fixed bin;
	dcl     start_of_cc		 fixed bin;
	dcl     start_of_orig	 fixed bin;	/* original message */
	dcl     start_of_text	 fixed bin;
	dcl     status		 fixed bin (35);
	dcl     to_list_ptr		 ptr;
	dcl     type		 fixed bin (2);
          dcl     user_name              char (22);
	dcl     view_seg_ptr	 ptr;
	dcl     yes_sw		 bit (1) aligned;

	dcl     1 auto_deliver_options like deliver_options;
	dcl     1 auto_format_message_options like format_message_options;
	dcl     1 auto_format_document_options like format_document_options;
	dcl     1 auto_message_body_section_parameter automatic like message_body_section_parameter;
	dcl     1 auto_parse_text_options like parse_text_options;
	dcl     1 auto_reply_options	 like reply_options;

/* ENTRIES */

	dcl     delete_$ptr		 entry (ptr, bit (6), char (*), fixed bin (35));
	dcl     emacs_		 entry (ptr, char (*), char (*), ptr, fixed bin (35));
	dcl     format_document_$string entry (char (*), char (*), fixed bin (21), ptr, fixed bin (35));
	dcl     get_pdir_		 entry () returns (char (168));
	dcl     get_system_free_area_	 entry () returns (ptr);

	dcl     hcs_$fs_get_path_name	 entry (ptr, char (*), fixed bin, char (*), fixed bin (35));
	dcl     hcs_$make_ptr	 entry (ptr, char (*), char (*), ptr, fixed bin (35));
	dcl     hcs_$make_seg	 entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
	dcl     hcs_$star_		 entry (char (*), char (*), fixed bin (2), ptr, fixed bin, ptr, ptr, fixed bin (35));
	dcl     hcs_$status_mins	 entry (ptr, fixed bin (2), fixed bin (24), fixed bin (35));
	dcl     ioa_		 entry options (variable);
	dcl     ioa_$ioa_switch_nnl	 entry () options (variable);
	dcl     ioa_$nnl		 entry options (variable);
	dcl     ioa_$rsnnl		 entry () options (variable);
	dcl     iox_$attach_name	 entry (char (*), ptr, char (*), ptr, fixed bin (35));
	dcl     iox_$close		 entry (ptr, fixed bin (35));
	dcl     iox_$destroy_iocb	 entry (ptr, fixed bin (35));
	dcl     iox_$detach_iocb	 entry (ptr, fixed bin (35));
	dcl     iox_$open		 entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
	dcl     mail_system_$add_body_section entry (ptr, ptr, fixed bin, fixed bin (35));
	dcl     mail_system_$deliver_message entry (ptr, ptr, ptr, fixed bin (35));
	dcl     mail_system_$free_address_list entry (ptr, fixed bin (35));
	dcl     mail_system_$free_message entry (ptr, fixed bin (35));
	dcl     mail_system_$read_message entry (ptr, fixed bin, fixed bin (35));
	dcl     mail_system_$replace_bcc entry (ptr, ptr, fixed bin (35));
	dcl     mail_system_$replace_cc entry (ptr, ptr, fixed bin (35));
	dcl     mail_system_$replace_reply_to entry (ptr, ptr, fixed bin (35));
	dcl     mail_system_$replace_to entry (ptr, ptr, fixed bin (35));
	dcl     mlsys_utils_$create_reply_message entry (ptr, ptr, ptr, fixed bin (35));
	dcl     mlsys_utils_$format_address_list_field entry (character (*) varying, ptr, fixed bin, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
	dcl     mlsys_utils_$format_message entry (ptr, ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
          dcl     mlsys_utils_$format_text_field entry
                  (character (*) varying, character (*), bit (1) aligned, fixed binary, pointer, fixed binary (21),
	fixed binary (21), fixed binary (35));
	dcl     mlsys_utils_$free_delivery_results entry (ptr, fixed bin (35));
	dcl     mlsys_utils_$parse_address_list_text entry (character (*), ptr, character (8), ptr, ptr, fixed bin (35));
	dcl     mlsys_utils_$print_address_list_field entry (char (*) var, ptr, fixed bin, ptr, fixed bin (35));
	dcl     mlsys_utils_$print_delivery_results entry (ptr, bit (1) aligned, ptr, fixed bin (35));
	dcl     ssu_$standalone_invocation entry (ptr, char (*), char (*), ptr, entry, fixed bin (35));
	dcl     ssu_$destroy_invocation entry (ptr);
	dcl     terminate_file_	 entry (ptr, fixed bin (24), bit (*), fixed bin (35));
	dcl     timer_manager_$sleep	 entry (fixed bin (71), bit (2));
	dcl     unique_chars_	 entry (bit (*)) returns (char (15));
          dcl     user_info_ entry (char(*));
	dcl     xmail_display_msgs_	 entry (ptr, ptr, ptr);
	dcl     xmail_error_$no_code	 entry options (variable);
	dcl     xmail_error_$no_print	 entry options (variable);
	dcl     xmail_error_$code_first entry options (variable);
	dcl     xmail_file_msgs_$single_msg entry (ptr, char (32) var, bit (1) aligned);
	dcl     xmail_file_msgs_$original_and_reply entry (ptr, ptr, char (32) var, bit (1) aligned);
	dcl     xmail_get_str_	 entry (char (*) var, (*) char (*) var, char (*), char (*), char (*) var);
	dcl     xmail_get_str_$yes_no	 entry (char (*) var, bit (1) aligned);
	dcl     xmail_redisplay_$all	 entry ();
	dcl     xmail_redisplay_$menu	 entry ();
	dcl     xmail_reply_msg_$ssu_exit entry ();
	dcl     xmail_sw_$redisplay	 entry ();
	dcl     xmail_sw_$update_position entry (char (*));
	dcl     xmail_sw_$update_usage entry (char (*));
	dcl     xmail_value_$get	 entry (char (*), char (*) var, fixed bin (35));
	dcl     xmail_value_$get_with_default entry (char (*), char (*) var, char (*) var, fixed bin (35));
	dcl     xmail_window_manager_$quit_handler entry () returns (bit (1) aligned);
	dcl     xmail_window_manager_$reconnect entry ();
	dcl     xmail_window_manager_$set_menu_window_size entry (fixed bin, fixed bin (35));

	dcl     based_array		 (no_chars) char (1)
				 based (reply_seg_ptr);
	dcl     based_string	 char (no_chars) based (reply_seg_ptr);
	dcl     based_string_format	 char (no_chars_format) based (format_seg_ptr);
	dcl     based_string_orig	 char (no_chars_orig) based (orig_seg_ptr);
	dcl     based_string_view	 char (no_chars_view) based (view_seg_ptr);
	dcl     def_reply_string	 char (no_chars) based (defrepl_seg_ptr);

/* AREA */

	dcl     reply_msg_area	 area aligned based (reply_msg_area_ptr);

/* BUILTINS */

	dcl     (addr, after, before, char, codeptr, divide, decat, index, length, ltrim, null, rtrim, string, substr, sum) builtin;

/* INCLUDE FILES */

%include access_mode_values;
%page;
%include iox_modes;
%page;
%include format_document_options;
%page;
%include mlsys_address_list;
%page;
%include mlsys_deliver_info;
%page;
%include mlsys_field_names;
%page;
%include mlsys_format_options;
%page;
%include mlsys_mailbox;
%page;
%include mlsys_message;
%page;
%include mlsys_parse_txt_options;
%page;
%include mlsys_reply_options;
%page;
%include star_structures;
%page;
%include terminate_file;
%page;
%include xmail_curr_msg_info;
%page;
%include xmail_data;
%page;
%include xmail_responses;
%page;
%include xmail_windows;
%page;
%include window_dcls;

/* BEGIN */

START:

/* Set ptrs to null and set up for cleanup & quit conditions */

	saved_menu_size = xmail_windows.menu.height;
	call window_$clear_window (iox_$user_output, (0));/* ignore code */
	more_than_one = "0"b;
	include_original, original_in_window = "0"b;
	reply_msg_area_ptr = get_system_free_area_ ();
	reply_seg_ptr, recipients_info_ptr, cc_list_ptr, bcc_list_ptr,
	     to_list_ptr, repl_message_ptr, iocb_ptr,
	     orig_seg_ptr, format_seg_ptr, view_seg_ptr = null ();
	defrepl_seg_ptr = null ();
	star_names_ptr = null ();
	star_entry_ptr = null ();
	sci_ptr = null ();
	delivery_results_need_cleanup = "0"b;

/*  See if there are any messages in the mailbox when reply option chosen */

	mailbox_ptr = P_mailbox_ptr;
	curr_msgsp = P_curr_msgs_ptr;
	if mailbox_ptr = null () | curr_msgsp = null ()
	then do;
		call ioa_ ("All messages have been discarded.");
		go to EXIT;
	     end;

	on condition (quit)
	     begin;
	          on reissue_query begin;
		          call window_$clear_window (iox_$user_output, (0));
			goto RETRY (opt);
			end;
		if xmail_window_manager_$quit_handler ()
		then do;
			call window_$clear_window (iox_$user_output, (0)); /* ignore code */
			call xmail_window_manager_$set_menu_window_size (saved_menu_size, code);
			call xmail_sw_$update_position ("");
			call xmail_sw_$redisplay ();
			call xmail_redisplay_$all ();
			call ioa_ ("Replying terminated.");
			call CLEAN_UP;
			goto EXIT;
		     end;
	     end;

	on condition (cleanup) call CLEAN_UP;
	xmail_data.reply_request = "1"b;
/* Create seg (for reply message) in process dir */

	call hcs_$make_seg ("", REPLY_SEG_NAME, "", RW_ACCESS_BIN, reply_seg_ptr, code);
	if code ^= 0 then do;			/*  If seg already exists set its bit count to zero */
		bit_count = 0;
		if code = error_table_$namedup | code = error_table_$segknown
		then call terminate_file_ (reply_seg_ptr, bit_count, TERM_FILE_BC, code);
		else call xmail_error_$no_code (code, NAME, STOP, "^a", PROBLEM);
	     end;

/* Create seg (to place in the being-replied-to-message) */

	call hcs_$make_seg ("", VIEW_SEG_NAME, "", RW_ACCESS_BIN, view_seg_ptr, code);
	if code ^= 0 then do;			/* If seg already exists set its bit count to zero */
		bit_count = 0;
		if code = error_table_$namedup | code = error_table_$segknown
		then call terminate_file_ (view_seg_ptr, bit_count, TERM_FILE_BC, code);
		else call xmail_error_$no_code (code, NAME, STOP, "^a", PROBLEM);
	     end;

	call iox_$attach_name (unique_chars_ ("0"b), iocb_ptr, "vfile_ " || rtrim (get_pdir_ ()) || ">" || rtrim (VIEW_SEG_NAME), codeptr (ENTRY_NAME), code);
	if code ^= 0 then
	     call xmail_error_$no_code (code, NAME, STOP, "^a", PROBLEM);

	call iox_$open (iocb_ptr, Stream_output, "0"b, code);
	if code ^= 0 then
	     call xmail_error_$no_code (code, NAME, STOP, "^a", PROBLEM);

/* Place the header & text of the message(s) being replied to in the 
  "VIEW_SEG_NAME" seg */

	call xmail_display_msgs_ (mailbox_ptr, curr_msgsp, iocb_ptr);

	if iocb_ptr ^= null ()
	then do;
		call iox_$close (iocb_ptr, (0));
		call iox_$detach_iocb (iocb_ptr, (0));
		call iox_$destroy_iocb (iocb_ptr, (0));
	     end;

/* Determine bit count of "VIEW_SEG_NAME" */

	call hcs_$status_mins (view_seg_ptr, type, bit_count_view, code);
	if code ^= 0
	then do;
		call xmail_error_$no_code (code, NAME, LOG, ERROR_MESSAGE, message_num);

		call timer_manager_$sleep (4, SECONDS);
		goto pre_end;
	     end;

/* Establish length of "based_string_view " */

	no_chars_view = divide (bit_count_view, BITS_PER_CHAR, 17, 0);

/* Determine if the original is to appear in the upper window */

	call xmail_value_$get_with_default (ORIGINAL_IN_WINDOW, (YES), response, code);
	if code ^= 0 then call xmail_error_$code_first (code, NAME, QUIT,
		"^/Unable to get a value for ""^a"" in the xmail value segment.", ORIGINAL_IN_WINDOW);
	if response = YES then original_in_window = "1"b;
	else original_in_window = "0"b;

/* Establish pathname of "reply_seg_name" in process dir */

	emacs_seg_path_name = rtrim (get_pdir_ ()) || ">" || REPLY_SEG_NAME;

/* Determine absolute pathname of the the emacs extention 
   (xmail_emacs_ext_main_) used by this procedure */

	if ext_ptr = null ()
	then do;
		call hcs_$make_ptr (codeptr (ENTRY_NAME), EMACS_EXT, "", ext_ptr, code);
		if code ^= 0 then call xmail_error_$no_code (code, NAME, STOP, "^a", PROBLEM);
		call hcs_$fs_get_path_name (ext_ptr, ext_dir, (0), ext_file, code);
		if code ^= 0 then call xmail_error_$no_code (code, NAME, STOP, "^a", PROBLEM);
		ext_pname = rtrim (ext_dir) || ">" || EMACS_EXT;

	     end;

/* Emacs extention will be called in the "reply" mode */

	for_type = "reply";

/* Set up reply and deliver options */

	recipients_info_n_lists = 3;			/* make room for bcc */

	allocate recipients_info in (reply_msg_area) set (recipients_info_ptr);
	recipients_info.area_ptr = get_system_free_area_ ();
	recipients_info.version = RECIPIENTS_INFO_VERSION_2;

	auto_reply_options.version = REPLY_OPTIONS_VERSION_2;
	auto_reply_options.to = null ();
	auto_reply_options.cc = null ();
	auto_reply_options.bcc = null ();
	auto_reply_options.flags.include_authors = "1"b;
	auto_reply_options.flags.include_self = "0"b;
	auto_reply_options.flags.mbz = "0"b;

	auto_deliver_options.version = DELIVER_OPTIONS_VERSION_2;
	auto_deliver_options.delivery_mode = ORDINARY_DELIVERY;
	auto_deliver_options.queueing_mode = ALWAYS_QUEUE_FOREIGN;
	auto_deliver_options.queued_notification_mode = NOTIFY_ON_ERROR;
	auto_deliver_options.flags.abort = "1"b;
	auto_deliver_options.flags.send_if_empty = "0"b;
	auto_deliver_options.flags.recipient_notification = "1"b;
	auto_deliver_options.flags.queue_mailing_lists = "0"b;

	auto_deliver_options.flags.mbz = "0"b;

/* See if reply is for more than one message */

	if curr_msgs.count > 1 then more_than_one = "1"b;

/* Loop based on the number of messages being replied to */

	default_save_file = "outgoing";
	do idx = 1 to curr_msgs.count;
	     message_num = curr_msgs.numbers (idx);

/* Determine ptr to message structure */

	     if mailbox.messages (message_num).message_ptr = null
	     then do;
		     call mail_system_$read_message (mailbox_ptr, message_num, code);
		     if code ^= 0
		     then call xmail_error_$no_code (code, NAME, "l", "Unable to read message ^d. This is an internal programming error.", message_num);
		end;
	     reply_msg_ptr = mailbox.messages (message_num).message_ptr;

/* Recipients are to be included in reply. Note that the user can actually
   modify, to any extent he wishes, the recipient list while in the editor */

	     auto_reply_options.flags.include_recipients = "1"b;

/* Create reply message structure */

	     repl_message_ptr = null ();

	     call mlsys_utils_$create_reply_message (reply_msg_ptr, addr (auto_reply_options), repl_message_ptr, code);
	     if repl_message_ptr ^= null ()
	     then do;
		     message_ptr = repl_message_ptr;
		     if message.to -> address_list.n_addresses = 0
		     then do;
			     call ioa_ ("You are trying to reply to your own message. Reply to message no. ^d terminated.", message_num);
			     go to pre_end;
			end;
		end;
	     if code ^= 0
	     then do;
		     call xmail_error_$no_code (code, NAME, LOG, ERROR_MESSAGE, message_num);
		     call timer_manager_$sleep (5, SECONDS);
		     go to pre_end;
		end;


/* See if deferred reply exists for this message */

	     auto_parse_text_options.version = PARSE_TEXT_OPTIONS_VERSION_1;
	     auto_parse_text_options.area_ptr = reply_msg_area_ptr;
	     auto_parse_text_options.flags.list_errors = "0"b;
	     auto_parse_text_options.flags.validate_addresses = "0"b;
	     auto_parse_text_options.flags.include_invalid_addresses = "0"b;
	     auto_parse_text_options.flags.mbz = "0"b;

               call user_info_ (user_name); /* we might need this */
	                                                               /* to plug a name into the reply-to */

	     deferred_reply_exists = "0"b;
	     delete_def_reply = "0"b;
	     deferred_seg_name = unique_chars_ ((reply_msg_ptr -> message.header.message_id)) || ".reply";
	     call hcs_$star_ ((xmail_data.mail_dir), (deferred_seg_name), star_BRANCHES_ONLY, get_system_free_area_ (), star_entry_count, star_entry_ptr, star_names_ptr, (0));
	     if star_entry_count = 1
	     then do;
		     call hcs_$make_seg ((xmail_data.mail_dir), (deferred_seg_name), "", RW_ACCESS_BIN, defrepl_seg_ptr, (0));
		     call hcs_$status_mins (defrepl_seg_ptr, type, bit_count, code);
		     if code ^= 0
		     then do;
			     call xmail_error_$no_code (code, NAME, LOG, ERROR_MESSAGE, message_num);

			     call timer_manager_$sleep (4, SECONDS);
			     goto pre_end;
			end;
		     if bit_count ^= 0 then do;
RETRY (2):			
			     opt = 2;
			     call ioa_$rsnnl ("A deferred reply for message ^d exists. Do you wish to use it? ", prompt_string, (0), message_num);
			     call xmail_get_str_$yes_no (prompt_string, yes_sw);
			     if yes_sw then do;
				     no_chars = divide (bit_count, BITS_PER_CHAR, 17, 0);
				     reply_to_list_ptr = null;
				     based_string = def_reply_string;
				     if index(before(based_string, "Reply: || NL"), "Reply-To:") > 0 then do;
					call mlsys_utils_$parse_address_list_text (rtrim (after (before (based_string, NL || "To:"), "Reply-To:"), WHITE_SPACE_COMMA), addr (auto_parse_text_options), ADDRESS_LIST_VERSION_2, reply_to_list_ptr, parse_text_error_list_ptr, code);
					if code ^= 0 then do;
					     call xmail_error_$no_code (code, NAME, LOG, ERROR_MESSAGE, message_num);
					     call timer_manager_$sleep (4, SECONDS);
					     goto pre_end;
					     end;
					end;
				     else do;
					format_reply = "";
					format_reply_length, buffer_size = length ("Reply-To:  ") + length(user_name);
					buffer_used = 0;
					call mlsys_utils_$format_text_field (REPLY_TO_FIELDNAME, rtrim(user_name), ("0"b),
					     format_reply_length, addr(format_reply), buffer_size, buffer_used, code);
					if code ^= 0 then do;
					     call xmail_error_$no_code (code, NAME, LOG, ERROR_MESSAGE, message_num);
					     call timer_manager_$sleep (4, SECONDS);
					     goto pre_end;
					     end;
					no_chars = format_reply_length + length (NL) + no_chars;
					bit_count = BITS_PER_CHAR * no_chars;
					based_string = format_reply || NL || based_string;
					end;
			     call terminate_file_ (reply_seg_ptr, bit_count, TERM_FILE_BC, code);
			     delete_def_reply = "1"b;
			     deferred_reply_exists = "1"b;
			end;

		     else do;
RETRY (3):				
			opt = 3;
			     call xmail_get_str_$yes_no ("Do you wish to discard it? ", yes_sw);
			     if yes_sw then delete_def_reply = "1"b;
			end;
		end;
	     end;

	     if ^deferred_reply_exists then do;		/* create a reply */
		call query_for_include_original ();

/* Set length of based_string temporarily to 5000 chars */

		     no_chars = 5000;
		     no_used = 0;

/* Get name(s) of sender of message being replied to */

		     call mlsys_utils_$format_address_list_field (REPLY_TO_FIELDNAME, message.header.reply_to, NO_WIDTH_LIMIT, reply_seg_ptr, no_chars, no_used, code);
		     if code ^= 0
		     then do;
			     call xmail_error_$no_code (code, NAME, LOG, ERROR_MESSAGE, message_num);
			     call timer_manager_$sleep (4, SECONDS);
			     goto pre_end;
			end;
		     if no_used > length ("Reply-To:  ") then;
		     else do;
			based_string = substr (based_string, 1, no_used) || rtrim(user_name);
			no_used = no_used + length (user_name);
			end;
		     based_string = substr (based_string, 1, no_used) || NL;
		     no_used = no_used + length (NL);                        

		     call mlsys_utils_$format_address_list_field (TO_FIELDNAME, message.header.to, NO_WIDTH_LIMIT, reply_seg_ptr, no_chars, no_used, code);
		     if code ^= 0
		     then do;
			     call xmail_error_$no_code (code, NAME, LOG, ERROR_MESSAGE, message_num);
			     call timer_manager_$sleep (4, SECONDS);
			     goto pre_end;
			end;
		     based_string = substr (based_string, 1, no_used) || NL;
		     no_used = no_used + length (NL);

/* If there were secondary recipients in the original message then determine
  the recipient list and append it to based_string so that the user may 
  modify it via the editor  */

		     start_of_cc = no_used + 1;
		     call mlsys_utils_$format_address_list_field (CC_FIELDNAME, message.header.cc, NO_WIDTH_LIMIT, reply_seg_ptr, no_chars, no_used, code);
		     if code ^= 0
		     then do;
			     call xmail_error_$no_code (code, NAME, LOG, ERROR_MESSAGE, message_num);
			     call timer_manager_$sleep (4, SECONDS);
			     goto pre_end;
			end;
		     based_string = substr (based_string, 1, no_used) || NL;
		     no_used = no_used + length (NL);


/* If there were bcc recipients in the original message then determine
  the recipient list and append it to based_string so that the user may 
  modify it via the editor  */

		     start_of_bcc = no_used + 1;
		     call mlsys_utils_$format_address_list_field (BCC_FIELDNAME, message.header.bcc, NO_WIDTH_LIMIT, reply_seg_ptr, no_chars, no_used, code);
		     if code ^= 0
		     then do;
			     call xmail_error_$no_code (code, NAME, LOG, ERROR_MESSAGE, message_num);
			     call timer_manager_$sleep (4, SECONDS);
			     goto pre_end;
			end;
		     based_string = substr (based_string, 1, no_used) || NL;
		     no_used = no_used + length (NL);

		     based_string = substr (based_string, 1, no_used) || "Reply: " || NL;
		     no_used = no_used + length ("Reply: ") + length (NL);

/* If the original is to be included, include it here */

		     if include_original
		     then call insert_original_message;

		     bit_count = no_used * BITS_PER_CHAR;
		     call terminate_file_ (reply_seg_ptr, bit_count, TERM_FILE_BC, code);
		     if code ^= 0
		     then call xmail_error_$no_code (code, NAME, STOP, "^a", PROBLEM);
		end;

/* Remove "For help press Funtion Key 1 " from status window. */

	     reply_header = "Replying to message no." || ltrim (char (message_num));
	     call xmail_sw_$update_usage (reply_header);
	     call xmail_sw_$update_position ("------------------------------------------------------------------------------");

	     call xmail_sw_$redisplay ();

/* See if more then one message is being replied-to */

	     if more_than_one then
		based_string_view = decat (based_string_view, " #" || rtrim (ltrim (char (message_num))) || " (", "011"b);
	     based_string_view = decat (based_string_view, "Date:", "011"b);
	     bit_count_view = length (decat (based_string_view, "-----(" || ltrim (rtrim (char (message_num))) || ")-----", "110"b)) * BITS_PER_CHAR;
	     call terminate_file_ (view_seg_ptr, bit_count_view, TERM_FILE_BC, code);
	     if code ^= 0
	     then call xmail_error_$no_code (code, NAME, STOP, "^a", PROBLEM);
	     if original_in_window then
		call xmail_window_manager_$set_menu_window_size (2, code);
	     else
		call xmail_window_manager_$set_menu_window_size (1, code);
	     if code ^= 0
	     then call xmail_error_$no_code (code, NAME, STOP, "^a", PROBLEM);
	     call window_$clear_window (xmail_windows.menu.iocb, (0)); /* ignore code */
	     if original_in_window
	     then call ioa_$ioa_switch_nnl (xmail_windows.menu.iocb, "      *** Use  ESC l  to view previous page,  ESC h  to view next page ***");
	     call window_$clear_window (iox_$user_output, (0)); /* ignore code */
	     call ioa_ ("...Please wait for editor...");
						/* Suppress the original if necessary. */

	     if ^original_in_window
	     then do;
		     call terminate_file_ (view_seg_ptr, 0, TERM_FILE_BC, code);
		end;
						/* Call the editor now */

	     call emacs_ (iox_$user_output, (emacs_seg_path_name), ext_pname, addr (for_type), status);

	     call xmail_window_manager_$set_menu_window_size (saved_menu_size, code);
	     if code ^= 0
	     then call xmail_error_$no_code (code, NAME, STOP, "^a", PROBLEM);
	     if status = 1
	     then do;
		     deferred_seg_name = unique_chars_ ((reply_msg_ptr -> message.header.message_id)) || ".reply";
		     call hcs_$make_seg ((xmail_data.mail_dir), (deferred_seg_name), "", RW_ACCESS_BIN, defrepl_seg_ptr, code);
		     if code ^= 0 & code ^= error_table_$namedup & code ^= error_table_$segknown then do;
			     call ioa_ ("Sorry, unable to save ""deferred reply"" for message ^d. ^/This is an internal error.", message_num);
			     if curr_msgs.count > 1 then call timer_manager_$sleep (4, SECONDS);
			     go to pre_end;
			end;

		     call hcs_$status_mins (reply_seg_ptr, type, bit_count, code);
		     if code ^= 0
		     then do;
			     call xmail_error_$no_code (code, NAME, LOG,
				ERROR_MESSAGE, message_num);
			     call timer_manager_$sleep (4, SECONDS);
			     goto pre_end;
			end;

		     call terminate_file_ (defrepl_seg_ptr, bit_count, TERM_FILE_BC, code);

/* Get number of chars in seg */

		     no_chars = divide (bit_count, BITS_PER_CHAR, 17, 0);

		     def_reply_string = based_string;
		     call ioa_ ("Deferred reply for message ^d saved.", message_num);
		     if more_than_one then call timer_manager_$sleep (3, SECONDS);
		     delete_def_reply = "0"b;
		     go to pre_end;
		end;

	     if status ^= 0

	     then do;
		     call xmail_window_manager_$reconnect ();
		     call ioa_ ("Reply to message ^d terminated.", message_num);
		     if curr_msgs.count > idx
		     then do;
			     call ioa_$nnl ("^/Do you still wish to reply to message(s): ");
			     do idx2 = idx + 1 to curr_msgs.count;
				call ioa_$nnl (" ^d", curr_msgs.numbers (idx2));
			     end;			/* end do loop */
			     call xmail_get_str_$yes_no (" ? ", yes_sw);
			     if yes_sw then go to pre_end;
			     else call ioa_ ("Replying terminated.");
			end;
		     call CLEAN_UP;
		     goto EXIT;
		end;

	     call hcs_$status_mins (reply_seg_ptr, type, bit_count, code);
	     if code ^= 0
	     then do;
		     call xmail_error_$no_code (code, NAME, LOG, ERROR_MESSAGE, message_num);
		     call timer_manager_$sleep (4, SECONDS);
		     goto pre_end;
		end;
	     if bit_count <= 0 then call xmail_error_$no_code (code, NAME, STOP, "^a", PROBLEM);
	     no_chars = divide (bit_count, BITS_PER_CHAR, 17, 0);

/* Delete deferred reply if one existed */

	     if delete_def_reply
	     then do;
		call delete_$ptr (defrepl_seg_ptr, DELETE_SEG_FORCE_CHASE, NAME, (0)); /* ignore code */
		delete_def_reply = "0"b;
		end;

	     to_list_ptr, cc_list_ptr, bcc_list_ptr = null ();

/* Add bcc handling */

	     call mlsys_utils_$parse_address_list_text (rtrim (after (before (based_string, "Reply:"), "bcc:"), WHITE_SPACE_COMMA), addr (auto_parse_text_options), ADDRESS_LIST_VERSION_2, bcc_list_ptr, parse_text_error_list_ptr, code);
	     if code ^= 0
	     then do;
		     call xmail_error_$no_code (code, NAME, LOG, ERROR_MESSAGE, message_num);
		     call timer_manager_$sleep (4, SECONDS);
		     goto pre_end;
		end;

	     if bcc_list_ptr ^= null ()
	     then do;
		     call mail_system_$replace_bcc (message_ptr, bcc_list_ptr, code);
		     if code ^= 0
		     then do;
			     call xmail_error_$no_code (code, NAME, LOG, ERROR_MESSAGE, message_num);
			     call timer_manager_$sleep (4, SECONDS);
			     goto pre_end;
			end;
		end;

/* Add Reply-To handling */

	     call mlsys_utils_$parse_address_list_text (rtrim (after (before (based_string, NL || "To:"), "Reply-To:"), WHITE_SPACE_COMMA), addr (auto_parse_text_options), ADDRESS_LIST_VERSION_2, reply_to_list_ptr, parse_text_error_list_ptr, code);
	     if code ^= 0
	     then do;
		     call xmail_error_$no_code (code, NAME, LOG, ERROR_MESSAGE, message_num);
		     call timer_manager_$sleep (4, SECONDS);
		     goto pre_end;
		end;

	     if reply_to_list_ptr ^= null ()
	     then do;
		     call mail_system_$replace_reply_to (message_ptr, reply_to_list_ptr, code);
		     if code ^= 0
		     then do;
			     call xmail_error_$no_code (code, NAME, LOG, ERROR_MESSAGE, message_num);
			     call timer_manager_$sleep (4, SECONDS);
			     goto pre_end;
			end;
		end;                                /*  reply-to handling */

/* cc handling */

	     call mlsys_utils_$parse_address_list_text (rtrim (after (before (based_string, "bcc:"), "cc:"), WHITE_SPACE_COMMA), addr (auto_parse_text_options), ADDRESS_LIST_VERSION_2, cc_list_ptr, parse_text_error_list_ptr, code);
	     if code ^= 0
	     then do;
		     call xmail_error_$no_code (code, NAME, LOG, ERROR_MESSAGE, message_num);
		     call timer_manager_$sleep (4, SECONDS);
		     goto pre_end;
		end;

	     if cc_list_ptr ^= null ()
	     then do;
		     call mail_system_$replace_cc (message_ptr, cc_list_ptr, code);
		     if code ^= 0
		     then do;
			     call xmail_error_$no_code (code, NAME, LOG, ERROR_MESSAGE, message_num);
			     call timer_manager_$sleep (4, SECONDS);
			     goto pre_end;
			end;
		end;

	     call mlsys_utils_$parse_address_list_text (rtrim (after (before (based_string, "cc:"), NL || "To:"), WHITE_SPACE_COMMA), addr (auto_parse_text_options), ADDRESS_LIST_VERSION_2, to_list_ptr, parse_text_error_list_ptr, code);
	     if code ^= 0
	     then do;
		     call xmail_error_$no_code (code, NAME, LOG, ERROR_MESSAGE, message_num);
		     call timer_manager_$sleep (4, SECONDS);
		     goto pre_end;
		end;

	     call mail_system_$replace_to (message_ptr, to_list_ptr, code);
	     if code ^= 0
	     then do;
		     call xmail_error_$no_code (code, NAME, LOG, ERROR_MESSAGE, message_num);
		     call timer_manager_$sleep (4, SECONDS);
		     goto pre_end;
		end;

	     message_body_section_ptr = addr (auto_message_body_section_parameter.section);
	     auto_message_body_section_parameter.version =
		MESSAGE_BODY_SECTION_PARAMETER_VERSION_2;
	     message_preformatted_body_section.header.section_type =
		MESSAGE_PREFORMATTED_BODY_SECTION;
	     message_preformatted_body_section.header.section_n_lines = -1;
	     start_of_text = index (based_string, "Reply:") + length ("Reply:") + length (NL);
	     message_preformatted_body_section.text_ptr =
		addr (based_array (start_of_text));
	     message_preformatted_body_section.text_lth =
		length (substr (rtrim (based_string), start_of_text));

	     recipients_info.lists (*).recipients_result_list_ptr = null ();
	     recipients_info.lists (1).address_list_ptr = message.to;
	     recipients_info.lists (2).address_list_ptr = message.cc;
	     recipients_info.lists (3).address_list_ptr = message.bcc;

	     call mail_system_$add_body_section (repl_message_ptr, addr (auto_message_body_section_parameter), 1, code);
	     if code ^= 0
	     then do;
		     call xmail_error_$no_code (code, NAME, LOG, ERROR_MESSAGE, message_num);
		     call timer_manager_$sleep (4, SECONDS);
		     goto pre_end;
		end;

	     call xmail_value_$get_with_default (ACKNOWLEDGE, (NO), acknowledge, code);
	     if code ^= 0 then call xmail_error_$code_first (code, NAME, QUIT,
		     "/^Unable to get a value for ""^a"" in the xmail value segment.", ACKNOWLEDGE);

	     if acknowledge = NO
	     then auto_deliver_options.flags.acknowledge = "0"b;
	     else if acknowledge = ASK
	     then do;
RETRY (4):		     
		     opt = 4;
		     call xmail_get_str_$yes_no ("Do you want your reply acknowledged?  ", yes_sw);
		     if yes_sw then auto_deliver_options.flags.acknowledge = "1"b;
		     else auto_deliver_options.flags.acknowledge = "0"b;
		end;
	     else if acknowledge = YES
	     then auto_deliver_options.flags.acknowledge = "1"b;
	     else call xmail_error_$code_first (error_table_$bad_segment, NAME, QUIT,
		     "^/An invalid value for ""^a"" was found in the xmail value segment.", ACKNOWLEDGE);

	     call mail_system_$deliver_message (repl_message_ptr, recipients_info_ptr, addr (auto_deliver_options), code);
	     delivery_results_need_cleanup = "1"b;
	     if code ^= 0 then do;
		     if code = mlsys_et_$no_a_permission
		     then call xmail_error_$no_code (code, NAME, CONTINUE, "You do not have permission to send message to at least one of the recipients.");
		     if n_failed_recipients > 0
		     then do;
			     call ioa_ ("Reply to message no.^d could not be sent.^/", message_num);
			     call ssu_$standalone_invocation (sci_ptr, "", "", null (), xmail_reply_msg_$ssu_exit, code1);
			     if code1 = 0 then call mlsys_utils_$print_delivery_results (sci_ptr, ERRORS_ONLY, recipients_info_ptr, code1);
			     else call xmail_error_$no_code (code1, NAME, LOG, "The reason cannot be printed due to an internal programming error");
			     call ssu_$destroy_invocation (sci_ptr);

			     if idx = curr_msgs.count then go to pre_end;

			     resp = "";
			     do while (resp = "");
				call xmail_get_str_ ("^/Press RETURN to continue; BREAK to stop.", "", "", "", resp);
			     end;
			     go to pre_end;
			end;
		     call xmail_error_$no_code (code, NAME, LOG, ERROR_MESSAGE, message_num);
		     call timer_manager_$sleep (4, SECONDS);
		     goto pre_end;
		end;

/* Issue the statement that the reply was sent. */

	     call ioa_ ("Reply to message no. ^d  sent: ", message_num);
	     call mlsys_utils_$print_address_list_field ("To", to_list_ptr, USE_SCREEN_WIDTH, null, code);
	     if code ^= 0 then call xmail_error_$no_code (code, NAME, CONTINUE, "Message sent to ""To:"" recipient(s).");

	     if cc_list_ptr ^= null
	     then do;
		     call mlsys_utils_$print_address_list_field ("cc", cc_list_ptr, USE_SCREEN_WIDTH, null, code);
		     if code ^= 0 then call xmail_error_$no_code (code, NAME, CONTINUE, "Message sent to ""cc:"" recipient(s).");
		end;
	     else call ioa_ ("cc:  <None>");

/* Add for bcc */

	     if bcc_list_ptr ^= null
	     then do;
		     call mlsys_utils_$print_address_list_field ("bcc", bcc_list_ptr, USE_SCREEN_WIDTH, null, code);
		     if code ^= 0 then call xmail_error_$no_code (code, NAME, CONTINUE, "Message sent to ""bcc:"" recipient(s).");
		end;
	     else call ioa_ ("bcc:  <None>");

/* Save the reply message for the user */

	     call xmail_value_$get (SAVE_MAILBOX, default_save_file, code);
	     if code ^= 0 then call xmail_error_$code_first (code, NAME, QUIT,
		     "^/Unable to get a value for ""^a"" in the xmail value segment.", SAVE_MAILBOX);

	     call xmail_value_$get (SAVE_MESSAGE, save_message, code);
	     if code ^= 0 then call xmail_error_$code_first (code, NAME, QUIT,
		     "^/Unable to get a value for ""^a"" in the xmail value segment.", SAVE_MESSAGE);

	     call xmail_value_$get (FILE_ORIGINAL, file_original, code);
	     if code ^= 0 then call xmail_error_$code_first (code, NAME, "q",
		     "^/Unable to get value for ""^a"" in the xmail value segment.", FILE_ORIGINAL);

	     if save_message = YES then do;
		     if file_original = YES then do;
			     if default_save_file = ASK
			     then call xmail_file_msgs_$original_and_reply (reply_msg_ptr, repl_message_ptr, "outgoing", ALLOW_SELECTION);
			     else call xmail_file_msgs_$original_and_reply (reply_msg_ptr, repl_message_ptr, minus_suffix ((default_save_file), (MAILFILE_SUFFIX)), NO_SELECTION);
			end;
		     else if file_original = ASK then do;
RETRY (5):			     
			     opt = 5;
			     call xmail_get_str_$yes_no ("Do you wish to file the original before the reply?", yes_sw);
			     if yes_sw then do;
				     if default_save_file = ASK
				     then call xmail_file_msgs_$original_and_reply (reply_msg_ptr, repl_message_ptr, "outgoing", ALLOW_SELECTION);
				     else call xmail_file_msgs_$original_and_reply (reply_msg_ptr, repl_message_ptr, minus_suffix ((default_save_file), (MAILFILE_SUFFIX)), NO_SELECTION);
				end;
			     else if default_save_file = ASK
						then call xmail_file_msgs_$single_msg (repl_message_ptr, "outgoing", ALLOW_SELECTION);
				     else call xmail_file_msgs_$single_msg (repl_message_ptr, minus_suffix ((default_save_file), (MAILFILE_SUFFIX)), NO_SELECTION);
			end;
		     else if file_original = NO
		     then do;
			     if default_save_file = ASK
			     then call xmail_file_msgs_$single_msg (repl_message_ptr, "outgoing", ALLOW_SELECTION);
			     else call xmail_file_msgs_$single_msg (repl_message_ptr, minus_suffix ((default_save_file), (MAILFILE_SUFFIX)), NO_SELECTION);
			end;
		     else call xmail_error_$code_first (error_table_$bad_segment, NAME, "q",
			     "^/An invalid value for ""^a"" was found in the xmail value segment.", FILE_ORIGINAL);
		end;
	     else if save_message = ASK
	     then do;
RETRY (6):		     
		     opt = 6;
		     call xmail_get_str_$yes_no ("Do you wish to save this reply? ", yes_sw);
		     if yes_sw then do;
			     if file_original = YES then do;
				     if default_save_file = ASK
				     then call xmail_file_msgs_$original_and_reply (reply_msg_ptr, repl_message_ptr, "outgoing", ALLOW_SELECTION);
				     else call xmail_file_msgs_$original_and_reply (reply_msg_ptr, repl_message_ptr, minus_suffix ((default_save_file), (MAILFILE_SUFFIX)), NO_SELECTION);
				end;
			     else if file_original = ASK then do;
RETRY (7):				     
				     opt = 7;
				     call xmail_get_str_$yes_no ("Do you wish to file the original before the reply?", yes_sw);
				     if yes_sw then do;
					     if default_save_file = ASK
					     then call xmail_file_msgs_$original_and_reply (reply_msg_ptr, repl_message_ptr, "outgoing", ALLOW_SELECTION);
					     else call xmail_file_msgs_$original_and_reply (reply_msg_ptr, repl_message_ptr, minus_suffix ((default_save_file), (MAILFILE_SUFFIX)), NO_SELECTION);
					end;
					     else if default_save_file = ASK
						then call xmail_file_msgs_$single_msg (repl_message_ptr, "outgoing", ALLOW_SELECTION);
				     else call xmail_file_msgs_$single_msg (repl_message_ptr, minus_suffix ((default_save_file), (MAILFILE_SUFFIX)), NO_SELECTION);
				end;
			     else if file_original = NO
			     then do;
				     if default_save_file = ASK
				     then call xmail_file_msgs_$single_msg (repl_message_ptr, "outgoing", ALLOW_SELECTION);
				     else call xmail_file_msgs_$single_msg (repl_message_ptr, minus_suffix ((default_save_file), (MAILFILE_SUFFIX)), NO_SELECTION);
				end;
			     else call xmail_error_$code_first (error_table_$bad_segment, NAME, "q",
				     "^/An invalid value for ""^a"" was found in the xmail value segment.", FILE_ORIGINAL);
			end;
		end;

	     else if save_message ^= NO
	     then call xmail_error_$code_first (error_table_$bad_segment, NAME, "q",
		     "^/An invalid value for ""^a"" was found in the xmail value segment.", SAVE_MESSAGE);

	     if idx ^= curr_msgs.count then call timer_manager_$sleep (4, SECONDS);

pre_end:

	     call MESSAGE_CLEAN_UP ();

	end;					/* end of do loop */

	call CLEAN_UP ();
EXIT:	return;

/* ENTRY POINTS */

ssu_exit: entry;

/* This entry doesn't do anything but it is called by ssu_$print_message */
/* which is called by mlsys_utils_$print_delivery_results.               */

	return;

/* INTERNAL PROCEDURES */

MESSAGE_CLEAN_UP: proc ();

	if repl_message_ptr ^= null ()
	then do;
		call mail_system_$free_message (repl_message_ptr, code);
		repl_message_ptr = null ();
	     end;
	if to_list_ptr ^= null ()
	then do;
		call mail_system_$free_address_list (to_list_ptr, code);
		to_list_ptr = null ();
	     end;
	if cc_list_ptr ^= null ()
	then do;
		call mail_system_$free_address_list (cc_list_ptr, code);
		cc_list_ptr = null ();
	     end;

/* Add for bcc */

	if bcc_list_ptr ^= null ()
	then do;
		call mail_system_$free_address_list (bcc_list_ptr, code);
		bcc_list_ptr = null ();
	     end;
	if recipients_info_ptr ^= null ()
	then do;
		if delivery_results_need_cleanup then do;
			call mlsys_utils_$free_delivery_results (recipients_info_ptr, code);
			if code ^= 0 then call xmail_error_$no_print (code, NAME, CONTINUE, "While cleaning up delivery results.");
		     end;
	     end;
	return;
     end MESSAGE_CLEAN_UP;

minus_suffix: proc (name, suffix) returns (char (*) var);

/* PARAMETERS */

	dcl     name		 char (*);
	dcl     suffix		 char (*);

/* AUTOMATIC */

	dcl     reverse_name	 char (length (name)) var;
	dcl     reverse_suffix	 char (length (suffix)) var;

/* BUILTINS */

	dcl     (after, index, length, reverse, rtrim) builtin;

	reverse_name = reverse (rtrim (name));
	reverse_suffix = reverse (rtrim (suffix));

	if index (reverse_name, reverse_suffix || ".") ^= 1
	then return (name);
	else return (reverse (after (reverse_name, reverse_suffix || ".")));

     end minus_suffix;

query_for_include_original: proc;

/* Determine if the original is to be included in the reply */

	call xmail_value_$get_with_default (INCLUDE_ORIGINAL, (NO), response, code);
	if code ^= 0 then call xmail_error_$code_first (code, NAME, "q",
		"^/Unable to get a value for ""^a"" in the xmail value segment.", INCLUDE_ORIGINAL);

	if response = YES
	then include_original = "1"b;
	else if response = ASK
	then do;
RETRY (1):		
		opt = 1;
		call xmail_get_str_$yes_no ("Do you wish to include the original in this reply? ", yes_sw);
		if yes_sw then include_original = "1"b;
	     end;
	else include_original = "0"b;

	if include_original
	then do;

/* Create segs for the printable original message before and after indenting 
   and setup format_document_ options */

		call hcs_$make_seg ("", ORIG_SEG_NAME, "", RW_ACCESS_BIN, orig_seg_ptr, code);
		if code ^= 0 then do;		/* If seg already exists set its bit count to zero */
			bit_count = 0;
			if code = error_table_$namedup | code = error_table_$segknown
			then call terminate_file_ (orig_seg_ptr, bit_count, TERM_FILE_BC, code);
			else call xmail_error_$no_code (code, NAME, STOP, "^a", PROBLEM);
		     end;

		call hcs_$make_seg ("", FORMAT_SEG_NAME, "", RW_ACCESS_BIN, format_seg_ptr, code);
		if code ^= 0 then do;		/* If seg already exists set its bit count to zero */
			bit_count = 0;
			if code = error_table_$namedup | code = error_table_$segknown
			then call terminate_file_ (format_seg_ptr, bit_count, TERM_FILE_BC, code);
			else call xmail_error_$no_code (code, NAME, STOP, "^a", PROBLEM);
		     end;

/* Set up format_message options */

		auto_format_message_options.version = FORMAT_MESSAGE_OPTIONS_VERSION_1;
		auto_format_message_options.line_length = NO_WIDTH_LIMIT;
		auto_format_message_options.envelope_formatting_mode = DEFAULT_FORMATTING_MODE;
		auto_format_message_options.header_formatting_mode = DEFAULT_FORMATTING_MODE;
		auto_format_message_options.redistributions_list_formatting_mode = DEFAULT_FORMATTING_MODE;
		auto_format_message_options.include_body = "1"b;

/* Set up format_document options */

		auto_format_document_options.version_number = format_document_version_2;
		auto_format_document_options.indentation = 4;
		auto_format_document_options.line_length = DEFAULT_WIDTH;
		string (auto_format_document_options.switches) = ""b;
		auto_format_document_options.galley_sw = "1"b; /* ... don't insert page breaks */
		auto_format_document_options.literal_sw = "1"b; /* ... don't recognize controls in the text */
		auto_format_document_options.dont_break_indented_lines_sw = "1"b; /* ... don't break lines which are indented */
		auto_format_document_options.dont_fill_sw = "1"b; /* ... don't fill */
		auto_format_document_options.syllable_size = 0;

	     end;

     end query_for_include_original;

insert_original_message: proc;

/* Internal procedure to format the original message into printable form,
   indent it, and then add it to the based_string in the reply segment
   for editing */

	start_of_orig = no_used + 1;
	no_chars_orig = 0;
GROW_MORE:
	call mlsys_utils_$format_message (reply_msg_ptr, addr (auto_format_message_options), orig_seg_ptr, no_chars, no_chars_orig, code);
	if code = error_table_$smallarg then do;
	     no_chars = no_chars + 5000;
	     goto GROW_MORE;
	     end;
	else if code ^= 0
	then do;
		call xmail_error_$no_code (code, NAME, LOG, ERROR_MESSAGE, message_num);
		go to pre_end;
	     end;

	no_chars_format = no_chars;
	call format_document_$string (based_string_orig, based_string_format, no_chars_format, addr (auto_format_document_options), code);
	if code ^= 0
	then do;
		call xmail_error_$no_code (code, NAME, LOG, ERROR_MESSAGE, message_num);
		go to pre_end;
	     end;

/* Append indented original and add the number of characters */

	based_string = substr (based_string, 1, no_used) || based_string_format;
	no_used = no_used + no_chars_format;

/* Append a newline */

	based_string = substr (based_string, 1, no_used) || NL;
	no_used = no_used + length (NL);

	return;
     end insert_original_message;

CLEAN_UP: proc ();

	if sci_ptr ^= null
	then call ssu_$destroy_invocation (sci_ptr);
	xmail_data.reply_request = "0"b;
	call xmail_redisplay_$menu ();

	if delete_def_reply
	     then call delete_$ptr (defrepl_seg_ptr, DELETE_SEG_FORCE_CHASE, NAME, (0));

	if reply_seg_ptr ^= null ()
	then do;
		call delete_$ptr (reply_seg_ptr, DELETE_SEG_FORCE_CHASE, NAME, code);
		reply_seg_ptr = null ();
	     end;
	call MESSAGE_CLEAN_UP ();

	if iocb_ptr ^= null then do;
		call iox_$close (iocb_ptr, (0));	/* ignore code */
		call iox_$detach_iocb (iocb_ptr, (0));	/* ignore code */
		call iox_$destroy_iocb (iocb_ptr, (0)); /* ignore code */
	     end;

	if view_seg_ptr ^= null ()
	then do;
		call delete_$ptr (view_seg_ptr, DELETE_SEG_FORCE, NAME, (0)); /* ignore code */
		view_seg_ptr = null ();
	     end;

	if orig_seg_ptr ^= null ()
	then do;
		call delete_$ptr (orig_seg_ptr, DELETE_SEG_FORCE, NAME, (0)); /* ignore code */
		orig_seg_ptr = null ();
	     end;
	if format_seg_ptr ^= null ()
	then do;
		call delete_$ptr (format_seg_ptr, DELETE_SEG_FORCE, NAME, (0)); /* ignore code */
		format_seg_ptr = null ();
	     end;

	if star_names_ptr ^= null () then free star_names;/* order is important */
	if star_entry_ptr ^= null () then free star_entries;
	if recipients_info_ptr ^= null ()
	then do;
		free recipients_info in (reply_msg_area);
		recipients_info_ptr = null ();
	     end;
	return;
     end CLEAN_UP;

     end xmail_reply_msg_;
