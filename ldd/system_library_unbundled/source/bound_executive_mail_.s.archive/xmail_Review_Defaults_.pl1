/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(86-01-07,Blair), approve(86-02-26,MCR7358),
     audit(86-04-21,RBarstad), install(86-05-28,MR12.0-1062):
     85-03-12  JG Backs: Split the Personalize Executive Mail menu into one
     small menu with 3 options.  Each of those options will display another
     menu.  The internal procedures for each of the original options plus new
     options being added were changed to entrypoints to be executed by the new
     menu modules: xmail_Review_Printing_.pl1, xmail_Review_Outgoing_.pl1, and
     xmail_Review_Processing_.pl1.
     85-03-27  JG Backs: Deleted duplicate code in the different entrypoints
     by using a call to internal procedure CHECK_VALUE_YN if valid responses
     to options are yes, no, or ask.  Modified CHECK_VALUE_YN to allow case
     insensitive responses, as well as "ask" and "a" as valid responses if flag
     is set.  Moved ASK, A, SET, and S constants to xmail_responses.incl.pl1.
     Added input parameters of option names to the entrypoints and additional
     info names to support the new options.
     85-04-17 JG Backs: Replaced all the Message Facility commands
     (accept_messages, defer_messages, print_messages) with calls to the new
     xmail_im_mgr_ module which uses the new Message Facility entrypoints for
     these functions.
  2) change(86-01-07,Blair), approve(86-02-26,MCR7358),
     audit(86-04-21,RBarstad), install(86-05-28,MR12.0-1062):
     85-04-19 JG Backs: Modified multics_mode entrypoint to get the value of
     always_escape_yn after the multics mode option is changed, in case the
     default for function keys has to change because of the new # of function
     keys needed.  Introduced bug when creating entrypoint from procedure.
     It was getting the multics_mode_yn value instead.
     85-04-25 JG Backs: Created new entrypoints related to getting the new
     values for each of the printing options: get_new_header, get_new_station,
     get_new_destination, get_new_copies, get_new_margin, get_new_notify.
     xmail_print_ will call these to obtain new values and not change the
     values in the value segment permanently.  Modified the existing
     entrypoints for the printing options to also call the new ones to keep
     the interface consistant for the user.
     85-04-26 JG Backs: Modified get_new_notify entrypoint to translate and
     test the new value instead of the old value.  Modified get_new_station
     to test the new value for a valid request_type, instead of changing the
     old value.  No changes to the old value should occur during get_new....
     entrypoints.  Bugfixes.
  3) change(86-01-07,Blair), approve(86-02-26,MCR7358),
     audit(86-04-21,RBarstad), install(86-05-28,MR12.0-1062):
     Modified include_original entrypoint to ask if the original should be
     displayed in the upper window. The new value name is ORIGINAL_UP_WINDOW_YN.
  4) change(87-01-16,Blair), approve(87-02-05,MCR7618),
     audit(87-04-14,RBarstad), install(87-04-26,MR12.1-1025):
     Make a new entry for including interactive messages in the mailbox.
     MSGS_AS_MAIL.
  5) change(88-06-27,Blair), approve(88-07-27,MCR7959),
     audit(88-08-25,RBarstad), install(88-09-02,MR12.2-1098):
     Allow full_name to be changed when the xmail_data.value seg is in the
     pdir.
                                                   END HISTORY COMMENTS */


xmail_Review_Defaults_: proc;

/* BEGIN DESCRIPTION

function:	This procedure provides the xmail user with a menu for the
	purpose of inspecting and updating default values which control
	aspects of the operation of xmail.

history:

   Written 7/16/81 by Paul Kyzivat 

   Modified by R. Ignagni Oct 1981 to add REVIEW_ACKNOWLEDGE 

   Extensively modified by R. Ignagni 3/4/82

   83-08-08 DJ Schimke: Changed all references of Person_id.xmail to 
   Person_id.mlsys. These references are in the delegation of authority code
   which is not used in this version, but may be used in the future. Deleted
   unreferenced variables and declared addr, before, index, rtrim and verify
   builtins.

   83-09-14 DJ Schimke: Modified to allow "y", "n", and "a" as well as "yes",
   "no", and "ask" as legal values for the YES/NO/ASK type options. TR12009

   83-09-16 DJ Schimke: Modified the printout station code to allow the 
   keyword "default" which returns the printout station to the original 
   site default by deleting the option from the value seg. phx13205

   83-10-10 DJ Schimke: replaced the calls to xmail_get_line with calls to 
   xmail_get_str_ which also handles the help function code.

   83-11-23 DJ Schimke: Added a new personalization option "Outgoing Savefile" 
   which allows selection of where to file save messages. This also solves the
   discrepancy between the different actions resulting from setting "Save
   Outgoing Messages" to "yes" vs never having set "Save Outgoing Messages".  
   The former always saved to "outgoing" while the latter always asked where.

   83-12-07 DJ Schimke Modified the code to report an error on a non-zero code
   from xmail_value_$get since the defaults for "Save-Outgoing-Messages",
   "Outgoing-Savefile", and "Acknowledge" are now guaranteed to exist by the
   code in xmail_dir_manager_. Temporarily removed the "Outgoing Savefile" 
   option. It will not be available until the MR11.0 release.

   84-02-17 DJ Schimke: Reinstated the new option "Save-Outgoing-Messages"
   for EXL version 2.1.

   84-07-03  DJ Schimke: Modified the call to xmail_create_menu_ to add the
   N_COLUMNS parameter. 

   84-09-04  JG Backs: Modified to add 6 new personalization options to the
   menu and 6 new internal procedures to handle the options.

   84-09-19  JG Backs: Added function_key_data and terminal_info include files
   to define the structures for function keys when changing from escape 
   sequences to function keys.

   84-09-24  JG Backs: Added "-brief" control argument to print_messages 
   command so the message "You have no messages" would not print. This is to
   make xmail compatible with the new message facility for mr11.

   84-10-02  JG Backs: Added a test in REVIEW_INTERACTIVE_MSGS proc so that
   when a user sets the option to no, the call to print messages will not
   be executed if the user had invoked xmail with the "-nim" argument.

   84-11-07  JG Backs: Made the user messages clearer and more consistant
   when the new personalize options are chosen and lengthened the name of
   the terminal info structure to this_terminal_info.  Also removed duplicate
   constants, used in determining values from the xmail value segment, by
   using rtrim on the info constants.  Added a trailing underscore to the
   call and declaration of module xmail_default_fkeys_.  Audit change.


   
END DESCRIPTION
*/

/* AUTOMATIC */

	dcl     answer_yn		 char (3) var;	/* value yes, no, or ask */
	dcl     changed_value	 bit (1) aligned;
	dcl     choice		 fixed bin;
	dcl     code		 fixed bin (35);
	dcl     create		 bit (1) aligned;
	dcl     dir		 char (168);
	dcl     display_needed	 bit (1) aligned;
	dcl     exists		 bit (1) aligned;
	dcl     generic_type	 char (32);
	dcl     new_full_name	 char (32);	/* contents of full name */
	dcl     prefix		 char (32) var;
	dcl     prompt_string	 char (200) var;
	dcl     response		 char (200) varying;
	dcl     response_bin	 fixed bin;         /* binary number of copies or left margin spaces */
	dcl     save_mailbox	 char (32) varying;
	dcl     status		 fixed bin (35);
	dcl     unused_return_length	 fixed bin;
	dcl     use_default_fkeys	 bit (1) aligned;	/* flag for escape */
	dcl     user_copies 	 char (2);          /* number of copies to print */
	dcl     user_destination	 char (24);
	dcl     user_header		 char (64);
	dcl     user_lmargin 	 char (2);          /* number of spaces to indent left margin when printing */
	dcl     user_notify		 char (3);	/* value yes or no */
	dcl     user_request_type	 char (24);
	dcl     value_name		 char (32) var;	/* name in xmail value segment */
	dcl     valid		 bit (1) aligned;
	dcl     yes_sw		 bit (1) aligned;

	dcl     1 this_terminal_info	 like terminal_info;/* this session */

/* CONSTANTS */

	dcl     ACCEPT_NEW		 bit (1) aligned int static options (constant) init ("1"b);
	dcl     ACCEPT_OLD		 bit (1) aligned int static options (constant) init ("1"b);
	dcl     COPIES_LIMIT	 fixed bin int static options (constant) init (30);
	dcl     COPIES_NO_GOOD         char (46) int static options (constant) init ("You may only enter a number from 1 through 30.");
	dcl     EIGHT_FKEYS		 fixed bin int static options (constant) init (8);
	dcl     FULL_MAILFILE_SUFFIX	 char (7) int static options (constant) init (".sv.mbx");
	dcl     FULL_NAME		 char (11) int static options (constant) init ("full_name._");
	dcl     LOG		 char (1) int static options (constant) init ("l");
	dcl     LOWERCASE_YN_ASK       char (8) int static options (constant) init ("yesnoask");
	dcl     MAILFILE_SUFFIX	 char (6) int static options (constant) init ("sv.mbx");
	dcl     MARGIN_LIMIT	 fixed bin int static options (constant) init (20);
	dcl     MARGIN_NO_GOOD         char (46) int static options (constant) init ("You may only enter a number from 0 through 20.");
	dcl     NAME		 init ("xmail_Review_Defaults_") char (22) int static options (constant);
	dcl     N_COLUMNS		 fixed bin int static options (constant) init (2);
	dcl     NUMERICS               char (10) int static options (constant) init ("0123456789");
	dcl     (
	/*** names of infos ***/
/*	        PRINTING_QUESTION	 init ("printing_question"),    not used, retained for documentation 
	        OUTGOING_QUESTION	 init ("outgoing_question"),    not used, retained for documentation 
	        PROCESSING_QUESTION	 init ("processing_question"),  not used, retained for documentation */
	        HEADER_QUESTION	 init ("heading_question"),
	        DESTINATION_QUESTION	 init ("destination_question"),
	        STATION_QUESTION	 init ("station_question"),
	        LONG_DESTINATION	 init ("destination_too_long"),
	        LONG_HEADER		 init ("heading_too_long"),
	        LONG_NAME		 init ("full_name_too_long"),
	        RQT_TOO_LONG	 init ("station_name_too_long"),
	        RQT_UNKNOWN		 init ("unknown_station"),
	        RQT_NOT_PRINT	 init ("wrong_type_station"),
	        ACKNOWLEDGE_YN	 init ("acknowledge_yn"),
	        ALWAYS_ESCAPE_YN	 init ("always_escape_keys_yn"),
	        CONFIRM_PRINT_YN	 init ("confirm_print_yn"),
	        COPIES_QUESTION	 init ("copies_question"),
	        FULL_NAME_QUESTION	 init ("full_name_question"),
	        INTERACTIVE_MSGS_YN	 init ("interactive_msgs_yn"),
	        LISTS_AS_MENUS_YN	 init ("lists_as_menus_yn"),
	        LEFT_MARGIN_QUESTION	 init ("left_margin_question"),
	        MULTICS_MODE_YN	 init ("multics_mode_yn"),
	        NOTIFY_YN   	 init ("notify_yn"),
	        REMOVE_MENUS_YN	 init ("remove_menus_yn"),
	        SAVE_MESSAGE_YN	 init ("save_message_yn"),
	        FILE_ORIGINAL_YN       init ("file_original_yn"),
	        INCLUDE_ORIGINAL_YN    init ("include_original_yn"),
	        ORIGINAL_UP_WINDOW_YN  init ("original_up_window_yn"),
	        SAVE_MAILBOX_HELP	 init ("save_mailfile"),
                  MSGS_AS_MAIL_YN        init ("msgs_as_mail_yn")
	        )			 char (32) int static options (constant);
	dcl     OPTION_NAMES	 int static options (constant) init (
				 "Printing Options",
				 "Outgoing Message Options",
				 "Processing Options"
				 ) dim (3) char (28) var;
	dcl     PERMANENT		 bit (36) aligned int static options (constant) init ("01"b);
          dcl     PERPROCESS             bit (36) aligned int static options (constant) init ("10"b);
	dcl     SEVEN_FKEYS		 fixed bin int static options (constant) init (7);
	dcl     TITLE		 init ("Personalize Executive Mail") char (26)
				 int static options (constant);
	dcl     UPPERCASE_YN_ASK       char (8) int static options (constant) init ("YESNOASK");

/* EXTERNAL STATIC */

	dcl     iox_$user_io	 ptr ext static;
	dcl     iox_$user_output	 ptr ext static;
	dcl     xmail_err_$help_requested ext static fixed bin (35);
	dcl     xmail_err_$exit_now	 ext static fixed bin (35);
	dcl     error_table_$oldnamerr fixed bin (35) ext static;
          dcl     error_table_$no_w_permission fixed bin(35) ext static;
	dcl     error_table_$bad_conversion fixed bin (35) ext static;

/* INTERNAL STATIC */

	dcl     menu		 int static ptr init (null);

/* ENTRIES */

	dcl     ioa_		 entry options (variable);
	dcl     ioa_$rsnnl		 entry options (variable);
	dcl     iod_info_$generic_type entry (char (*), char (32), fixed bin (35));
	dcl     iox_$control	 entry (ptr, char (*), ptr, fixed bin (35));
	dcl     mlsys_utils_$create_savebox entry (char (*), char (*), fixed bin (35));
	dcl     ttt_info_$function_key_data entry (char (*), ptr, ptr, fixed bin (35));
	dcl     value_$get		 entry () options (variable);
	dcl     value_$set		 entry () options (variable);
	dcl     xmail_create_menu_	 entry (char (*), (*) char (*) var, fixed bin, ptr, fixed bin (35));
	dcl     xmail_default_fkeys_	 entry () returns (ptr);
	dcl     xmail_display_help_	 entry (char (*), char (*), fixed bin (35));
	dcl     xmail_error_$code_first entry () options (variable);
	dcl     xmail_error_$no_code	 entry () options (variable);
	dcl     xmail_get_choice_	 entry (ptr, char (*), char (*), char (*), char (*), bit (1) aligned, char (*), fixed bin, fixed bin (35));
	dcl     xmail_get_str_	 entry (char (*) var, (*) char (*) var, char (*), char (*), char (*) var);
	dcl     xmail_get_str_$yes_no	 entry (char (*) var, bit (1) aligned);
	dcl     xmail_im_mgr_$defer_messages entry ();
	dcl     xmail_im_mgr_$print_messages entry ();
	dcl     xmail_im_mgr_$restore_original entry ();
	dcl     xmail_print_$get_heading entry (char (*), fixed bin (35));
	dcl     xmail_print_$set_heading entry (char (*), fixed bin (35));
	dcl     xmail_print_$get_destination entry (char (*), fixed bin (35));
	dcl     xmail_print_$set_destination entry (char (*), fixed bin (35));
	dcl     xmail_print_$get_request_type entry (char (*), fixed bin (35));
	dcl     xmail_print_$set_request_type entry (char (*), fixed bin (35));
	dcl     xmail_print_$get_copies entry (char (*), fixed bin (35));
	dcl     xmail_print_$set_copies entry (char (*), fixed bin (35));
	dcl     xmail_print_$get_left_margin entry (char (*), fixed bin (35));
	dcl     xmail_print_$set_left_margin entry (char (*), fixed bin (35));
	dcl     xmail_print_$get_notify entry (char (*), fixed bin (35));
	dcl     xmail_print_$set_notify entry (char (*), fixed bin (35));
	dcl     xmail_Review_Defaults_$get_new_copies entry (char (*), char (*) var, fixed bin);
	dcl     xmail_Review_Defaults_$get_new_destination entry (char (*), char (*) var);
	dcl     xmail_Review_Defaults_$get_new_header entry (char (*), char (*) var);
	dcl     xmail_Review_Defaults_$get_new_margin entry (char (*), char (*) var, fixed bin);
	dcl     xmail_Review_Defaults_$get_new_notify entry (char (*), char (*), char (*) var);
	dcl     xmail_Review_Defaults_$get_new_station entry (char (*), char (*) var);
	dcl     xmail_Review_Printing_ entry ();
	dcl     xmail_Review_Processing_ entry ();
	dcl     xmail_Review_Outgoing_ entry ();
	dcl     xmail_select_file_	 entry (char (*), char (*), char (*), bit (1) aligned, bit (1) aligned, char (168),
				 char (32) var, bit (1) aligned, bit (1) aligned, fixed bin (35));
	dcl     xmail_value_$delete	 entry (char (*), fixed bin (35));
	dcl     xmail_value_$get	 entry (char (*), char (*) var, fixed bin (35));
	dcl     xmail_value_$set	 entry (char (*), char (*) var, char (*) var, fixed bin (35));
	dcl     xmail_window_manager_$reconnect entry options (variable);

/* CONDITIONS */

	dcl     (conversion, program_interrupt, quit, size, xmail_redisplay_menu) condition;

/* BUILTINS */

	dcl     (addr, convert, length, null, rtrim, translate, verify) builtin;

/* INCLUDE FILES */

%include menu_dcls;
%page;
%include xmail_data;
%page;
%include xmail_help_infos;
%page;
%include xmail_responses;
%page;
%include xmail_windows;
%page;
%include window_dcls;
%page;
%include function_key_data;
%page;
%include terminal_info;

/* BEGIN */
	on condition (xmail_redisplay_menu) begin;
		if menu ^= null
		then call menu_$display (xmail_windows.menu.iocb, menu, (0));
	     end;

	if menu = null then do;
	     call xmail_create_menu_ (TITLE, OPTION_NAMES, N_COLUMNS, menu, code);
	     if code ^= 0 then call xmail_error_$no_code (status, NAME, "q",
		     "A programming error has been detected which prevents " ||
		     "the use of the ^a menu.", TITLE);

	end;

	on condition (program_interrupt) go to START;
	on condition (quit) begin;
		call xmail_window_manager_$reconnect ();
		go to START;
	     end;

	call window_$clear_window (iox_$user_output, (0));
	call ioa_ (" ");

START:	display_needed = "1"b;
	do while ("1"b);
	     call xmail_get_choice_ (menu, "", "", "", xmail_data.normal_usage,
		display_needed, "", choice, code);
	     display_needed = "0"b;
	     if code = 0 then call PERFORM_OPTION (choice, display_needed);
	     else if code = xmail_err_$help_requested then call EXPLAIN_OPTION (choice);
	     else if code = xmail_err_$exit_now then go to EXIT;
	     else call window_$bell (iox_$user_output, (0));
	end;
EXIT:	return;

/* INTERNAL PROCEDURES */

PERFORM_OPTION: proc (opt, redisplay);

/* PARAMETERS */

	dcl     redisplay		 bit (1) aligned parameter;
	dcl     opt		 fixed bin parameter;

/* BEGIN PERFORM_OPTION */

	call window_$clear_window (iox_$user_output, (0));
	go to OPT (opt);

OPT (1):	redisplay = "1"b;
	call xmail_Review_Printing_;
	go to OPT_EXIT;

OPT (2):	redisplay = "1"b;
	call xmail_Review_Outgoing_;
	go to OPT_EXIT;

OPT (3):	redisplay = "1"b;
	call xmail_Review_Processing_;
	go to OPT_EXIT;

OPT_EXIT: return;
     end PERFORM_OPTION;

EXPLAIN_OPTION: proc (opt);

	dcl     opt		 fixed bin parameter;

	call window_$clear_window (iox_$user_output, (0));
	call xmail_display_help_ (REVIEW_DEFAULTS_HELP,
	     translate (OPTION_NAMES (opt), "_", " "),
	     (0));

     end EXPLAIN_OPTION;

CHECK_VALUE_YN: proc (cvy_value_name, cvy_option_name, cvy_help_name, cvy_ask_sw);

/* Function: This procedure gets the value assigned to cvy_value_name, allows
             the user to change it, and then sets the new value. Yes, no and
             RETURN are the valid responses.  If cvy_ask_sw is set, ask is also
             a valid response.  Values are from xmail_data.value segment.
*/

/* PARAMETERS */

	dcl     cvy_value_name		 char (*); /* input */
	dcl     cvy_option_name		 char (*); /* input */
	dcl     cvy_help_name		 char (*); /* input */
	dcl     cvy_ask_sw		           bit (1);  /* input */

/* BEGIN  CHECK_VALUE_YN */

	changed_value = "0"b;

	call xmail_value_$get (cvy_value_name, answer_yn, status);
	if status ^= 0
	then do;
	     call xmail_error_$no_code (status, NAME, "l", "An error has occurred which prevents access to ^a.", cvy_option_name);
	     go to CHECK_VALUE_YN_EXIT;
	end;

	call ioa_ ("^a is currently set to: ^a", cvy_option_name, answer_yn);
	call ioa_ ("You may now reset option " ||
	     "or just press the RETURN key^/" ||
	     "  to leave it unchanged.");
	valid = "0"b;
	do while (^valid);
	     call ioa_$rsnnl (cvy_option_name || " ^[(enter ""yes"", ""no"", or ""ask"")^;(enter ""yes"" or ""no"")^]: ", prompt_string, unused_return_length, cvy_ask_sw);

 	     call xmail_get_str_ (prompt_string, "", REVIEW_DEFAULTS_HELP, cvy_help_name, response);

/* Allowable responses are case insensitive yes, y, no, n, ??, ?, and RETURN,
   plus a and ask if ask switch is set. */

	     response = translate (response, LOWERCASE_YN_ASK, UPPERCASE_YN_ASK);
	     if response = Y then response = YES;
	     if response = N then response = NO;
	     if response = A then response = ASK;
	     if length (response) = 0 then valid = "1"b;
	     else if response = YES | response = NO
	     then valid = "1"b;
	     else if cvy_ask_sw  & response = ASK         /* allow ask */
	     then valid = "1"b;
	     else if response = LIST
	     then call ioa_ ("^a is currently set to: ^a", cvy_option_name, answer_yn);
	     else do;
		valid = "0"b;
		if cvy_ask_sw
		then call ioa_ ("You may only enter ""yes"", ""no"", or ""ask"", followed by a RETURN.^/  Enter ? if you need help.");
		else call ioa_ ("You may only enter ""yes"" or ""no"", followed by a RETURN.^/  Enter ? if you need help.");
	     end;
	end;					/* end of do */

	if length (response) = 0 | response = answer_yn
	then call ioa_ ("^a remains unchanged.", cvy_option_name);
	else do;
	     call xmail_value_$set (cvy_value_name, (response), answer_yn, status);
	     if status = 0
	     then changed_value = "1"b;
	     else call xmail_error_$no_code (status, NAME, "l", "An error has occurred which prevents changing ^a.", cvy_option_name);
	end;

CHECK_VALUE_YN_EXIT:
     return;

     end CHECK_VALUE_YN;

CHANGE_TO_DEFAULT_KEYS: proc ();

/* Function: Change from using function keys to using escape sequences. Free
             the previous allocation pointer and call xmail_default_fkeys_
             module to allocate new structure. */

/* BEGIN */

	free xmail_data.function_key_data_ptr -> function_key_data;

	xmail_data.function_key_data_ptr = xmail_default_fkeys_ ();
	xmail_data.normal_usage = "(For help, press ESC, then ""?"")";

     end CHANGE_TO_DEFAULT_KEYS;

TEST_AND_CHANGE_FUNCTION_KEYS: proc ();

/* Function: Check terminal data to make sure it can support the number of
             function keys for this invocation of xmail. Free the previous
             allocation pointer and use function_key_data structure if
             possible. */

/* BEGIN */

	use_default_fkeys = "0"b;

/* Get terminal data (function keys etc.). */

	this_terminal_info.version = terminal_info_version;
	call iox_$control (iox_$user_io, "terminal_info", addr (this_terminal_info), code);
	if code ^= 0
	then call xmail_error_$no_code (code, NAME, "q", "Cannot get terminal info to change function keys");

	call ttt_info_$function_key_data (this_terminal_info.term_type, null, function_key_data_ptr, code);
	if code ^= 0
	then use_default_fkeys = "1"b;
	else if function_key_data.highest < xmail_data.n_fkeys_used
	then use_default_fkeys = "1"b;

	if use_default_fkeys
	then do;
	     free function_key_data_ptr -> function_key_data;
	     call CHANGE_TO_DEFAULT_KEYS;
	     call ioa_ ("WARNING: The terminal you are using does not support enough function keys.");
	     call ioa_ ("         Escape sequences will be used during this session.");
	end;
	else do;
	     free xmail_data.function_key_data_ptr -> function_key_data;
	     xmail_data.function_key_data_ptr = function_key_data_ptr;
	     xmail_data.normal_usage = "(For help, press F1)";
	end;


     end TEST_AND_CHANGE_FUNCTION_KEYS;

CONVERT: proc (c_value_char, c_value_bin, c_status);

/*
     Converts a character value to a binary value so it can be tested
     against limits.  Used for copies and left margin.
*/

/* PARAMETERS */

         dcl     c_value_char      char (*) varying;        /* input */
         dcl     c_value_bin       fixed bin;               /* output binary */
         dcl     c_status          fixed bin (35);          /* output */

/* BEGIN */

         c_status = 0;

         on conversion, size 
	     c_status = error_table_$bad_conversion;

         c_value_bin = convert (c_value_bin, c_value_char);

         revert conversion, size;         
         return;

     end CONVERT;

minus_suffix: proc (name, suffix) returns (char (*) var);

/* PARAMETERS */

	dcl     name		 char (*);
	dcl     suffix		 char (*);

/* AUTOMATIC */

	dcl     reverse_name	 char (length (name)) var;
	dcl     reverse_suffix	 char (length (suffix)) var;

/* BUILTINS */

	dcl     (after, index, length, reverse, rtrim) builtin;

/* BEGIN minus_suffix */

	reverse_name = reverse (rtrim (name));
	reverse_suffix = reverse (rtrim (suffix));

	if index (reverse_name, reverse_suffix || ".") ^= 1
	then return (name);
	else return (reverse (after (reverse_name, reverse_suffix || ".")));

     end minus_suffix;

/* ENTRYPOINTS */

/*
     The following are the entrypoints called to change the printing options
     in the personalization menu.
*/

header: entry (h_option_name);

/* PARAMETERS */

	dcl     h_option_name                 char (*);   /* input option name */

/* BEGIN */

	user_header = "";

	call xmail_print_$get_heading (user_header, status);
	if status ^= 0
	then do;
	     call xmail_error_$no_code (status, NAME, "l", "An error has occurred which prevents access to ^a.", h_option_name);
	     go to header_exit;
	end;

          call xmail_Review_Defaults_$get_new_header (user_header, response);

	if length (response) = 0 | response = user_header
	then call ioa_ ("^a remains unchanged.", h_option_name);
	else do;
	     user_header = response;
	     call xmail_print_$set_heading (user_header, status);
	     if status = 0
	     then call ioa_ ("The heading has been changed to: ^a", user_header);
	     else call xmail_error_$no_code (status, NAME, "l", "An error has occurred which prevents changing ^a.", h_option_name);
	end;

header_exit: return;

get_new_header: entry (gnh_old_header, gnh_new_header);

/*
     This entrypoint is called by both xmail_print_ and xmail_Review_Defaults_
     to allow the user to enter a new value.
*/
	      
/* PARAMETERS */

	dcl     gnh_old_header                char (*);   /* input */
	dcl     gnh_new_header                char (*) var;/* output */

/* BEGIN */

	gnh_new_header = "";

	call ioa_ ("^[No heading has been defined to label hardcopy printouts.^;The heading used to label hardcopy printouts is: ^a", gnh_old_header = "", gnh_old_header);

	call ioa_ ("You may now enter a new heading, " ||
	     "or just press the RETURN key^/" ||
	     "  to leave it unchanged.");
	valid = "0"b;
	do while (^valid);
	     call xmail_get_str_ ("New header:  ", "", REVIEW_DEFAULTS_HELP, HEADER_QUESTION, gnh_new_header);
	     if gnh_new_header = LIST
	     then call ioa_ ("^[There is no defined heading.^;The defined heading is:  ^a^]", gnh_old_header = "", gnh_old_header);
	     else if length (gnh_new_header) > length (gnh_old_header)
	     then call xmail_display_help_ (REVIEW_DEFAULTS_HELP, LONG_HEADER, (0));
	     else valid = "1"b;
	end;

          return;
	

destination: entry (d_option_name);

/* PARAMETERS */

	dcl     d_option_name                 char (*);   /* input option name */

/* BEGIN */

	user_destination = "";

	call xmail_print_$get_destination (user_destination, status);
	if status ^= 0
	then do;
	     call xmail_error_$no_code (status, NAME, "l", "An error has occurred which prevents access to ^a.", d_option_name);
	     go to destination_exit;
	end;

          call xmail_Review_Defaults_$get_new_destination (user_destination, response);

	if length (response) = 0 | response = user_destination
	then call ioa_ ("^a remains unchanged.", d_option_name);
	else do;
	     user_destination = response;
	     call xmail_print_$set_destination (user_destination, status);
	     if status = 0
	     then call ioa_ ("The destination has been changed to: ^a", user_destination);
	     else call xmail_error_$no_code (status, NAME, "l", "An error has occurred which prevents changing ^a.", d_option_name);
	end;

destination_exit: return;

get_new_destination: entry (gnd_old_destination, gnd_new_destination);

/*
     This entrypoint is called by both xmail_print_ and xmail_Review_Defaults_
     to allow the user to enter a new value.
*/
	      
/* PARAMETERS */

	dcl     gnd_old_destination         char (*);     /* input */
	dcl     gnd_new_destination         char (*) var; /* output */

/* BEGIN */

	gnd_new_destination = "";

          call ioa_ ("^[No destination has been defined to label hardcopy printouts.^;The destination used to label hardcopy printouts is: ^a.^]", gnd_old_destination = "", gnd_old_destination);

	call ioa_ ("You may now enter a new destination, " ||
	     "or just press the RETURN key^/" ||
	     "  to leave it unchanged.");
	valid = "0"b;
	do while (^valid);
	     call xmail_get_str_ ("New destination:  ", "", REVIEW_DEFAULTS_HELP, DESTINATION_QUESTION, gnd_new_destination);
	     if gnd_new_destination = LIST
               then call ioa_ ("^[There is no defined destination.^;The defined destination is: ^a.^]", gnd_old_destination = "", gnd_old_destination);

	     else if length (gnd_new_destination) > length (gnd_old_destination)
	     then call xmail_display_help_ (REVIEW_DEFAULTS_HELP, LONG_DESTINATION, (0));
	     else valid = "1"b;
	end;

          return;

station: entry (s_option_name);

/* PARAMETERS */

	dcl     s_option_name                 char (*);   /* input option name */

/* BEGIN */

	user_request_type = "";

	call xmail_print_$get_request_type (user_request_type, status);
	if status ^= 0
	then do;
	     call xmail_error_$no_code (status, NAME, "l", "An error has occurred which prevents access to ^a.", s_option_name);
	     go to station_exit;
	end;

          call xmail_Review_Defaults_$get_new_station (user_request_type, response);

	if length (response) = 0 | response = user_request_type
	then call ioa_ ("^a remains unchanged.", s_option_name);
	else do;
	     if response ^= "default" 
	     then do;
		user_request_type = response;
		call xmail_print_$set_request_type (user_request_type, status);
	     end;
	     else do;
		user_request_type = "system default";
		call xmail_value_$delete ("dprint_request_type", status);
		if status = error_table_$oldnamerr then status = 0;
	     end;

	     if status = 0
	     then call ioa_ ("The station has been changed to: ^a", user_request_type);
	     else call xmail_error_$no_code (status, NAME, "l", "An error has occurred which prevents changing ^a.", s_option_name);
	end;

station_exit: return;

get_new_station: entry (gns_old_request_type, gns_new_request_type);

/*
     This entrypoint is called by both xmail_print_ and xmail_Review_Defaults_
     to allow the user to enter a new value.
*/
	      
/* PARAMETERS */

	dcl     gns_old_request_type          char (*);    /* input */
	dcl     gns_new_request_type          char (*) var;/* output */

/* BEGIN */

	gns_new_request_type = "";

	call ioa_ ("^[Your output is printed at the system default output station^;The station used for your printouts is: ^a^]", gns_old_request_type = "", gns_old_request_type);

	call ioa_ ("You may now enter a new station, " ||
	     "or just press the RETURN key^/" ||
	     "  to leave it unchanged.");
	valid = "0"b;
	do while (^valid);
	     call xmail_get_str_ ("New printout station:  ", "", REVIEW_DEFAULTS_HELP, STATION_QUESTION, gns_new_request_type);
	     if length (gns_new_request_type) = 0 then valid = "1"b;
	     else if gns_new_request_type = LIST
	     then call ioa_ ("^[There is no defined station.^;The defined station is:  ^a^]", gns_old_request_type = "", gns_old_request_type);
	     else if gns_new_request_type = "default"
	     then valid = "1"b;
	     else do;
		if length (gns_new_request_type) > length (gns_old_request_type)
		then call xmail_display_help_ (REVIEW_DEFAULTS_HELP, RQT_TOO_LONG, (0));
		else do;
		     call iod_info_$generic_type ((gns_new_request_type), generic_type, status);
		     if status ^= 0
		     then call xmail_display_help_ (REVIEW_DEFAULTS_HELP, RQT_UNKNOWN, (0));
		     else if generic_type ^= "printer"
		     then call xmail_display_help_ (REVIEW_DEFAULTS_HELP, RQT_NOT_PRINT, (0));
		     else valid = "1"b;
		end;
	     end;
	end;

          return;

notify: entry (n_option_name);
	      
/* PARAMETERS */

	dcl     n_option_name                  char (*);  /* input option name */

/* BEGIN notify */

	user_notify = "";

	call xmail_print_$get_notify (user_notify, status);
	if status ^= 0
	then do;
	     call xmail_error_$no_code (status, NAME, "l", "An error has occurred which prevents access to ^a.", n_option_name);
	     go to notify_exit;
	end;

          call xmail_Review_Defaults_$get_new_notify (n_option_name, user_notify, response);

	if length (response) = 0 | response = user_notify
	then call ioa_ ("^a remains unchanged.", n_option_name);
	else do;
	     user_notify = response;
	     call xmail_print_$set_notify (user_notify, status);
	     if status = 0
	     then call ioa_ ("You will ^[be^;not be^] notified by message when printing is done.", response = YES);
	     else call xmail_error_$no_code (status, NAME, "l", "An error has occurred which prevents changing ^a.", n_option_name);
	end;

notify_exit: return;

get_new_notify: entry (gnn_option_name, gnn_old_notify, gnn_new_notify);

/*
     This entrypoint is called by both xmail_print_ and xmail_Review_Defaults_
     to allow the user to enter a new value.
*/
	      
/* PARAMETERS */

	dcl     gnn_option_name               char (*);    /* input */
	dcl     gnn_old_notify                char (*);    /* input */
	dcl     gnn_new_notify                char (*) var;/* output */

/* BEGIN */

	gnn_new_notify = "";

	call ioa_ ("^a is currently set to: ^a", gnn_option_name, gnn_old_notify);

	call ioa_ ("You may now reset option, " ||
	     "or just press the RETURN key^/" ||
	     "  to leave it unchanged.");

	valid = "0"b;
	do while (^valid);
	     call xmail_get_str_ ("Do you want to be notified after printing? (enter ""yes"" or ""no""):  ", "", REVIEW_DEFAULTS_HELP, NOTIFY_YN, gnn_new_notify);

/* Allowable responses are case insensitive yes, y, no, n, ??, ?, RETURN. */

	     gnn_new_notify = translate (gnn_new_notify, LOWERCASE_YN_ASK, UPPERCASE_YN_ASK);
	     if gnn_new_notify = Y then gnn_new_notify = YES;
	     if gnn_new_notify = N then gnn_new_notify = NO;
	     if length (gnn_new_notify) = 0 then valid = "1"b;
	     else if gnn_new_notify = YES | gnn_new_notify = NO
	     then valid = "1"b;

	     else if gnn_new_notify = LIST
	     then	call ioa_ ("^a is currently set to: ^a", gnn_option_name, gnn_old_notify);
	     else call ioa_ ("You may only enter ""yes"" or ""no"", followed by a RETURN.^/  Enter ? if you need help.");
	end;

          return;

copies: entry (c_option_name);

/* PARAMETERS */

	dcl     c_option_name                 char (*);   /* input option name */

/* BEGIN */

	user_copies = "";

	call xmail_print_$get_copies (user_copies, status);
	if status ^= 0
	then do;
	     call xmail_error_$no_code (status, NAME, "l", "An error has occurred which prevents access to ^a.", c_option_name);
	     go to copies_exit;
	end;

          call xmail_Review_Defaults_$get_new_copies (user_copies, response, response_bin);

	if length (response) = 0 | response = user_copies
	then call ioa_ ("^a remains unchanged.", c_option_name);
	else do;
	     user_copies = response;
	     call xmail_print_$set_copies (user_copies, status);
	     if status = 0
	     then call ioa_ ("The number of copies has been changed to: ^a", user_copies);
	     else call xmail_error_$no_code (status, NAME, "l", "An error has occurred which prevents changing ^a.", c_option_name);
	end;

copies_exit: return;

get_new_copies: entry (gnc_old_copies, gnc_new_copies, gnc_new_copies_bin);

/*
     This entrypoint is called by both xmail_print_ and xmail_Review_Defaults_
     to allow the user to enter a new value.
*/

/* PARAMETERS */

	dcl     gnc_old_copies                char (*);    /* input */
	dcl     gnc_new_copies                char (*) var;/* output */
	dcl     gnc_new_copies_bin            fixed bin;   /* output binary*/

/* BEGIN */

	gnc_new_copies = "";
	gnc_new_copies_bin = 0;

	call ioa_ ("The number of copies requested is: ^a", gnc_old_copies);

	call ioa_ ("You may now reset the number of copies, " ||
	     "or just press the RETURN key^/" ||
	     "  to leave it unchanged.");

	valid = "0"b;
	do while (^valid);
	     call xmail_get_str_ ("Number of copies (1 - 30):  ", "", REVIEW_DEFAULTS_HELP, COPIES_QUESTION, gnc_new_copies);
	     if length (gnc_new_copies) = 0
	     then valid = "1"b;
	     else if gnc_new_copies = LIST
	     then call ioa_ ("The number of copies requested is: ^a", gnc_old_copies);
	     else if verify (gnc_new_copies, NUMERICS) ^= 0
	     then call ioa_ (COPIES_NO_GOOD);

	     else do;                                     /* convert to binary and check against limit */
		call CONVERT (gnc_new_copies, gnc_new_copies_bin, status);
		if status = 0
		then if gnc_new_copies_bin < 1 | gnc_new_copies_bin > COPIES_LIMIT
	               then call ioa_ (COPIES_NO_GOOD);
	               else valid = "1"b;                      /* valid number */
		else call ioa_ (COPIES_NO_GOOD);
	     end;
	end;

          return;

left_margin: entry (lm_option_name);

/* PARAMETERS */

	dcl     lm_option_name                 char (*);  /* input option name */

/* BEGIN */

	user_lmargin = "";

	call xmail_print_$get_left_margin (user_lmargin, status);
	if status ^= 0
	then do;
	     call xmail_error_$no_code (status, NAME, "l", "An error has occurred which prevents access to ^a.", lm_option_name);
	     go to left_margin_exit;
	end;

          call xmail_Review_Defaults_$get_new_margin (user_lmargin, response, response_bin);

	if length (response) = 0 | response = user_lmargin
	then call ioa_ ("^a remains unchanged.", lm_option_name);
	else do;
	     user_lmargin = response;
	     call xmail_print_$set_left_margin (user_lmargin, status);
	     if status = 0
	     then call ioa_ ("The left margin has been changed to: ^a spaces", user_lmargin);
	     else call xmail_error_$no_code (status, NAME, "l", "An error has occurred which prevents changing ^a.", lm_option_name);
	end;

left_margin_exit: return;

get_new_margin: entry (gnm_old_lmargin, gnm_new_lmargin, gnm_new_lmargin_bin);

/*
     This entrypoint is called by both xmail_print_ and xmail_Review_Defaults_
     to allow the user to enter a new value.
*/

/* PARAMETERS */

	dcl     gnm_old_lmargin               char (*);    /* input */
	dcl     gnm_new_lmargin               char (*) var;/* output */
	dcl     gnm_new_lmargin_bin           fixed bin;   /* output binary*/

/* BEGIN */

	gnm_new_lmargin = "";
	gnm_new_lmargin_bin = 0;

	call ioa_ ("The left margin is: ^a spaces.", gnm_old_lmargin);

	call ioa_ ("You may now reset the left margin, " ||
	     "or just press the RETURN key^/" ||
	     "  to leave it unchanged.");
	valid = "0"b;
	do while (^valid);
	     call xmail_get_str_ ("Left margin (0 - 20):  ", "", REVIEW_DEFAULTS_HELP, LEFT_MARGIN_QUESTION, gnm_new_lmargin);
	     if length (gnm_new_lmargin) = 0
	     then valid = "1"b;
	     else if gnm_new_lmargin = LIST
	     then call ioa_ ("The left margin is: ^a spaces.", gnm_old_lmargin);
	     else if verify (gnm_new_lmargin, NUMERICS) ^= 0
	     then call ioa_ (MARGIN_NO_GOOD);

	     else do;                                     /* convert to binary and check against limit */
		call CONVERT (gnm_new_lmargin, gnm_new_lmargin_bin, status);
		if status = 0
		then if gnm_new_lmargin_bin > MARGIN_LIMIT
	               then call ioa_ (MARGIN_NO_GOOD);
	               else valid = "1"b;
		else call ioa_ (MARGIN_NO_GOOD);
	     end;
	end;

          return;

confirm_print: entry (cp_option_name);

/* PARAMETERS */

	dcl     cp_option_name                 char (*);  /* input option name */

/* BEGIN confirm_print */

	value_name = rtrim (CONFIRM_PRINT_YN);		/* use info constant */

	call CHECK_VALUE_YN ((value_name), cp_option_name, CONFIRM_PRINT_YN, "0"b);
	if changed_value
	then do;
	     if response = YES
	     then xmail_data.confirm_print = "1"b;
	     else xmail_data.confirm_print = "0"b;

	     call ioa_ ("The print options will ^[be displayed before printing to allow for changes.^;not be displayed.^]", response = YES);
	end;

	return;
	

/*
     The following are the entrypoints called to change the Outgoing Message
     options in the personalization menu.
*/

acknowledge: entry (a_option_name);

/* PARAMETERS */

	dcl     a_option_name                 char (*);   /* input option name */

/* BEGIN */

	value_name = rtrim (ACKNOWLEDGE_YN);		/* use info constant */

	call CHECK_VALUE_YN ((value_name), a_option_name, ACKNOWLEDGE_YN, "1"b);
	if changed_value
	then call ioa_ ("^[All messages will now^;^[Messages will not^;You will always be asked if you want to^]^] request an acknowledgment.", response = YES, response = NO);

          return;
	

save_messages: entry (smg_option_name);

/* PARAMETERS */

	dcl     smg_option_name                char (*);  /* input option name */

/* BEGIN */

	value_name = rtrim (SAVE_MESSAGE_YN);		/* use info constant */

	call CHECK_VALUE_YN ((value_name), smg_option_name, SAVE_MESSAGE_YN, "1"b);
	if changed_value
          then call ioa_ ("^[All outgoing messages will be saved.^;^[Outgoing messages will not be saved.^;You will always be asked if you want to save outgoing messages.^]^]", response = YES, response = NO);

          return;

msgs_as_mail: entry (mam_option_name);

/* PARAMETERS */

	dcl     mam_option_name                char (*);  /* input option name */

/* BEGIN */

	value_name = rtrim (MSGS_AS_MAIL_YN);		/* use info constant */

	call CHECK_VALUE_YN ((value_name), mam_option_name, MSGS_AS_MAIL_YN, "1"b);
	if changed_value
          then call ioa_ ("^[Interactive messages will be treated as mail.^;^[Interactive messages will not be treated as mail.^;You will always be asked if you want to treat interactive messages as mail.^]^]", response = YES, response = NO);

          return;

save_mailbox: entry (smb_option_name);

/* PARAMETERS */

	dcl     smb_option_name               char (*);   /* input option name */

/* BEGIN */

	value_name = rtrim (SAVE_MAILBOX_HELP);		/* use info constant */

	call xmail_value_$get ((value_name), save_mailbox, status);
	if status ^= 0
	then do;
	     call xmail_error_$no_code (status, NAME, "l", "An error has occurred that prevents access to ^a.", smb_option_name);
	     go to savebox_exit;
	end;

	save_mailbox = minus_suffix ((save_mailbox), (MAILFILE_SUFFIX));
	call ioa_ ("Outgoing savefile currently set to: ^a", save_mailbox);
	call ioa_ ("^/Type ""set"" to change the outgoing savefile," ||
	     "^/""ask"" to be asked for the savefile name each time" ||
	     "^/     a message is saved," ||
	     "^/or just press the RETURN key to leave it unchanged.^/");

	valid = "0"b;
	call ioa_$rsnnl ("How do you want to specify the outgoing savefile?:  ",
	     prompt_string, unused_return_length);
	do while (^valid);
	     call xmail_get_str_ (prompt_string, "", REVIEW_DEFAULTS_HELP, SAVE_MAILBOX_HELP, response);

/* Translate to make response case insensitive */

	     response = translate (response, LOWERCASE_YN_ASK, UPPERCASE_YN_ASK);
	     if response = A then response = ASK;
	     if response = S then response = SET;
	     if length (response) = 0 | response = SET | response = ASK
	     then valid = "1"b;
	     else if response = LIST
	     then call ioa_ ("Outgoing savefile currently set to: ^a", save_mailbox);
	     else call ioa_ ("You may only enter ""set"" or ""ask"", followed by a RETURN. ^/  Enter ? if you need help.");
	end;					/* end of do */

	if length (response) = 0
	then call ioa_ ("^a remains unchanged.", smb_option_name);
	else if response = ASK then do;
	     call xmail_value_$set ((value_name), (response), save_mailbox, status);
	     if status = 0
	     then call ioa_ ("^[You will always be asked for the name of the savefile when^;The ""^a"" savefile will be used for^] saving messages.", response = ASK, save_mailbox);
	     else call xmail_error_$no_code (status, NAME, "l", "An error has occurred which prevents changing ^a.", smb_option_name);
	end;
	else if response = SET then do;
	     call xmail_select_file_ ("mail file", MAILFILE_SUFFIX, "outgoing", ACCEPT_OLD, ACCEPT_NEW, dir, prefix, create, exists, status);
	     if status ^= 0 then go to savebox_exit;	/* Diagnostic msg already issued by xmail_select_file_. */

	     yes_sw = "0"b;
	     if ^create & ^exists then do;
		call ioa_$rsnnl ("The specified mail file ""^a"" does not exist.^/  Do you wish to create it?  ", prompt_string, unused_return_length, prefix);
		call xmail_get_str_$yes_no (prompt_string, yes_sw);
	     end;

	     if create | yes_sw then do;
		call mlsys_utils_$create_savebox (dir, (prefix), code);
		if code ^= 0
	          then call xmail_error_$code_first (status, NAME, LOG, "An error has occurred which prevents changing ^a.", smb_option_name);
		else call ioa_ ("The mail file ""^a"" has been created.", prefix);
	     end;

	     if exists | create | yes_sw then do;
		call xmail_value_$set ((value_name), prefix || FULL_MAILFILE_SUFFIX, save_mailbox, status);
		if status = 0
		then call ioa_ ("Option has been changed to ^[ask for the name of the file before^;use the ""^a"" savefile for^] saving messages.", response = ASK, prefix);
	          else call xmail_error_$no_code (status, NAME, "l", "An error has occurred which prevents changing ^a.", smb_option_name);
	     end;
	     else call ioa_ ("^a remains unchanged.", smb_option_name);
	end;

savebox_exit: return;

full_name: entry (fn_option_name);

/* PARAMETERS */

	dcl     fn_option_name                 char (*);  /* input option name */
          dcl     get_pdir_                      entry() returns(char(168));
	    

/* BEGIN */

	new_full_name = "";

	if xmail_data.value_seg_pathname = get_pdir_() then
	     call value_$get (null (), PERPROCESS, FULL_NAME, new_full_name, status);
	else
	     call value_$get (null (), PERMANENT, FULL_NAME, new_full_name, status);
	if status ^= 0
	then if status = error_table_$oldnamerr
	     then call ioa_ ("Your full name is not currently defined.");
	     else do;
	          call xmail_error_$no_code (status, NAME, "l", "An error has occurred which prevents access to ^a.", fn_option_name);
	          go to full_name_exit;
	     end;

	else call ioa_ ("The full name which appears in the From field of outgoing mail is:" ||
		"^/  ^a", new_full_name);

	call ioa_ ("You may now enter your full name, " ||
	     "or just press the RETURN key^/" ||
	     "  to leave it unchanged.");

	valid = "0"b;
	do while (^valid);
	     call xmail_get_str_ ("Enter your full name (32 character limit): ", "", REVIEW_DEFAULTS_HELP, FULL_NAME_QUESTION, response);

	     if response = LIST
	     then call ioa_ ("^[Your full name is not currently defined.^;Your full name currently is: ^a^]", new_full_name = "", new_full_name);
	     else if length (response) > length (new_full_name)
	     then call xmail_display_help_ (REVIEW_DEFAULTS_HELP, LONG_NAME, (0));
	     else valid = "1"b;
	end;					/* end of do */

	if length (response) = 0 | response = new_full_name
	then call ioa_ ("^a remains unchanged.", fn_option_name);
	else do;
	     call value_$set (null (), PERMANENT, FULL_NAME, (response), new_full_name, status);
	     if status = 0
	     then do;
		call ioa_ ("Full Name has been changed to: ^a", response);
		call ioa_ ("This change takes effect the next time you login to the system.");
	     end;
	     else if status = error_table_$no_w_permission then do;
                   call value_$set (null (), PERPROCESS, FULL_NAME, (response), new_full_name, status);
	         if status = 0
	         then do;
		    call ioa_ ("Full Name has been changed to: ^a", response);
		    call ioa_ ("This change is in effect during this process.");
	              end;
	         else call xmail_error_$no_code (status, NAME, "l", "An error has occurred which prevents changing ^a.", fn_option_name);
	         end;
	     else call xmail_error_$no_code (status, NAME, "l", "An error has occurred which prevents changing ^a.", fn_option_name);
	end;

full_name_exit: return;

include_original: entry (io_option_name);

/* PARAMETERS */

	dcl     io_option_name                char (*);   /* input option name */
	dcl     new_option_name               char (32) var;
	        

/* BEGIN include_original */

	value_name = rtrim (INCLUDE_ORIGINAL_YN);         /* use info constant */

	call CHECK_VALUE_YN ((value_name), io_option_name, INCLUDE_ORIGINAL_YN, "1"b);
	if changed_value
	then call ioa_ ("^[Original messages will be included in all^;^[Original messages will not be included in^;You will always be asked if you want to include originals in^]^] replies.", response = YES, response = NO);

	value_name = rtrim (ORIGINAL_UP_WINDOW_YN);

	call ioa_(" ");
	new_option_name = "Display Original in Upper Window";
	call CHECK_VALUE_YN ((value_name),(new_option_name),ORIGINAL_UP_WINDOW_YN, "0"b);
	if changed_value
	then call ioa_("^[The original will be displayed in^;The original will not be displayed in^] the upper window.",response = YES);

          return;

file_original: entry (fo_option_name);

/* PARAMETERS */

	dcl     fo_option_name                char (*);   /* input option name */

/* BEGIN file_original */

	value_name = rtrim (FILE_ORIGINAL_YN);         /* use info constant */

	call CHECK_VALUE_YN ((value_name), io_option_name, FILE_ORIGINAL_YN, "1"b);
	if changed_value
	then call ioa_ ("^[Originals will always be filed before replies.^;^[Originals will not be filed.^;You will always be asked if you want to file originals before replies.^]^]", response = YES, response = NO);

          return;

/* 
     The following are the entrypoints called to change the Processing options
     in the personalization menu.
*/

interactive_msgs: entry (im_option_name);

/* PARAMETERS */

	dcl     im_option_name                 char (*);  /* input option name */

/* BEGIN interactive_msgs */

	value_name = rtrim (INTERACTIVE_MSGS_YN);	/* use info constant */

	call CHECK_VALUE_YN ((value_name), im_option_name, INTERACTIVE_MSGS_YN, "0"b);
	if changed_value
          then do;
	     call ioa_ ("Interactive messages will ^[be^;not be^] processed.", response = YES);
	     if response = YES
	     then do;
		xmail_data.interactive_msgs = "1"b;
		call xmail_im_mgr_$defer_messages;
	     end;
	     else if xmail_data.interactive_msgs = "1"b
						/* changing from yes to no */
	     then do;
		xmail_data.interactive_msgs = "0"b;
		call xmail_im_mgr_$print_messages;
		call xmail_im_mgr_$restore_original;
	     end;
	end;

	return;

lists_as_menus: entry (lam_option_name);

/* PARAMETERS */

	dcl     lam_option_name               char (*);   /* input option name */

/* BEGIN lists_as_menus */

	value_name = rtrim (LISTS_AS_MENUS_YN);		/* use info constant */

	call CHECK_VALUE_YN ((value_name), lam_option_name, LISTS_AS_MENUS_YN, "0"b);
	if changed_value
          then do;
	     if response = YES
	     then xmail_data.lists_as_menus = "1"b;
	     else xmail_data.lists_as_menus = "0"b;
	     call ioa_ ("Lists will ^[be^;not be^] displayed as menus.", response = YES);
	end;

	return;

remove_menu: entry (rm_option_name);

/* PARAMETERS */

	dcl     rm_option_name                 char (*);  /* input option name */

/* BEGIN remove_menu */

	value_name = rtrim (REMOVE_MENUS_YN);		/* use info constant */

	call CHECK_VALUE_YN ((value_name), rm_option_name, REMOVE_MENUS_YN, "0"b);
	if changed_value
	then do;
	     if response = YES
	     then xmail_data.remove_menus = "1"b;
	     else xmail_data.remove_menus = "0"b;

	     call ioa_ ("During editing, the top menu will ^[be^;not be^] removed.", response = YES);
	end;

	return;

escape_keys: entry (ek_option_name);

/* PARAMETERS */

	dcl     ek_option_name                 char (*);  /* input option name */

/* BEGIN escape_keys */

	value_name = rtrim (ALWAYS_ESCAPE_YN);		/* use info constant */

	call CHECK_VALUE_YN ((value_name), ek_option_name, ALWAYS_ESCAPE_YN, "0"b);
	if changed_value
          then do;
	     call ioa_ ("^[Escape sequences will always be used in place of function keys.^;Function keys will be used when available.^]", response = YES);
     	     if response = YES
     	     then	call CHANGE_TO_DEFAULT_KEYS;
	     else	call TEST_AND_CHANGE_FUNCTION_KEYS;
	end;

	return;

multics_mode: entry (mm_option_name);

/* PARAMETERS */

	dcl     mm_option_name                char (*);   /* input option name */

/* BEGIN multics_mode */

	value_name = rtrim (MULTICS_MODE_YN);		/* use info constant */

	call CHECK_VALUE_YN ((value_name), mm_option_name, MULTICS_MODE_YN, "0"b);
	if changed_value
          then do;
	     if response = YES
	     then do;
		xmail_data.n_fkeys_used = EIGHT_FKEYS;
		xmail_data.multics_mode = "1"b;
		call ioa_ ("Multics commands will be allowed.");
	     end;
	     else do;
		xmail_data.n_fkeys_used = SEVEN_FKEYS;
		xmail_data.multics_mode = "0"b;
		call ioa_ ("Multics commands will not be allowed.");
	     end;
	     call xmail_value_$get (rtrim (ALWAYS_ESCAPE_YN), answer_yn, status);
	     if status = 0 & answer_yn = NO
	     then call TEST_AND_CHANGE_FUNCTION_KEYS;
	end;

	return;

    end xmail_Review_Defaults_;
