" ***********************************************************
" *                                                         *
" * Copyright, (C) BULL HN Information Systems Inc., 1989   *
" *                                                         *
" * Copyright, (C) Honeywell Information Systems Inc., 1982 *
" *                                                         *
" * Copyright (c) 1972 by Massachusetts Institute of        *
" * Technology and Honeywell Information Systems, Inc.      *
" *                                                         *
" ***********************************************************

" HISTORY COMMENTS:
"  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8090),
"     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
"     MCR8090 cobol_operators_.alm Disallow duplicate prime keys in Indexed
"     Sequential files.
"                                                      END HISTORY COMMENTS


"Modified on 12/19/84 by FCH, [5.3-1], BUG573(phx16343), error detection can fail if ark used
"Modified on 10/29/82 by FCH, [5.1-1], set mcode ptr, BUG536(phx12688)
"Modified on 02/18/81 by FCH, [4.4-1], operator 93(alt_rewrite) added
"         Modified on 12/14/79 by PRP, cause ipr for bad overpunch data.
"Modified on 11/05/79 by PRP, prevent close if file previously open
"        Modified on 10/31/79 by PRP, pass more system error messages to user
"Modified on 09/06/79 by FCH, key of ref was being destroyed
"Modified on 08/24/79 by PrP, [4.0-3], alt_start_control added
"        Modified on 07/10/79 by MHD, [4.0-2], fix linage problem
"         Modified on 07/17/79 by PRP, [4.0-1], MPM standard for attach and detach files
"MODIFIED on 11/30/78 by FCH, [3.0-1], alternate record keys added
"Modified on 051678 by FCH, [3.0-1], save and restore $x6 
"        Modified on 09/20/77 by Peter Krupp to extend trace interface to COBOL programs
"Modified since Version 3.0 
"
"
"
"
"
"	/*{*/
"	cobol_operators_ segment
"	Bob Chang
"	March, 1976
"
" NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE
"
"	To add a new operator:
"	(1). Insert the "tra" instruction before the line with the comment:
"	"	Please insert the next "tra" instruction before theis line.	
"	(2). Put the operator calling sequence number on "tra" instruction.
"	    The number is obtained by incrementing the last operator calling sequence
"	    number by 1.
"	(3). Insert the operator before the line with the comment:
"	"	Please insert the next operator before theis line.	
"	(4). Be sure that no "end" statement exists at the end of the operator segment
"	    which is to be inserted into cobol_operators_.
"	(5). Please put some comment before the operator.
"
" NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE
"
	name	cobol_operators_
"	/*}*/

	use	text1
	use	text2
	use	text3
	use	text4
	use	text5
	join	/text/text1,text2,text3,text4,text5
	use	text1
	include	stack_header
	include	stack_frame
	include	eis_bits
"
	segdef	operator_table
	segdef	cobol_operators_
"
"	Definitions of variables used by operators.  Since all
"	of the operators execute using the stack frame of the
"	cobol program for their temporary storage, locations 32-61
"	of the cobol stack frame are reserved for operator use.
"
"	sp|6 has been reserved for probe.
"
	equ	cobol_code,1	code identifying cobol compiled prog
	equ	maxpr,71		max precision of double fixed
"
	equ	display_ptr,32
	equ	descriptor_ptr,34
	equ	linkage_ptr,36
	equ	on_unit_ptr,30
	equ	op_return_offset,31
	equ	text_base_ptr,38
	equ	text_base_off,39
	equ	mcode,40
	equ	icode,41
	equ	status12,42
	equ	status3,43
	equ	retrycode,44
	equ	return_to_main_ptr,64
	equ	return_to_main_off,65
	equ	rts_code_ptr,66
	equ	rts_code,72
	equ	cobol_error_code,89
"
"	Definitions for cobol linkage variables used by operators.
"
	equ	cobol_data_ptr,8
	equ	control_ptr,10
	equ	ind_mask,116
	equ	file_info_ptr,12
	equ	call_cnt,14
	equ	x6_save,100		[3.0-1]
	equ	subr_return_save,106
	equ	subr_return_save_off,107
	equ	pr4_save,108
	equ	rts_save,114
	equ	pr3_save,110
	equ	pr5_save,112
"
	equ	ap,0	TEMP
	equ	ab,1	TEMP
	equ	bp,2	TEMP
	equ	bb,3	TEMP
	equ	sp,6	TEMP
"
	bool	blank,40
"
cobol_operators_:
"
" THE FOLLOWING SECTION IS DIRECTLY REFERENCED FROM cobol PROGRAMS BY MEANS OF
" ap|offset.  FOR THIS REASON, THE ORDER OF THE FOLLOWING INSTRUCTIONS MUST
" NOT BE CHANGED.
"
	even
operator_table:
"
"	transfer vector for operators not referenced directly
"	by the cobol program.  new operators may be added at the
"	end of the list only.
"
op_vector:
entry_operators:
	tra	call_ent_var_desc	0
	tra	call_ent_var	1
	tra	call_ext_in_desc	2
	tra	return_mac	3
	tra	call_ext_in	4
	tra	call_ext_out_desc	5
	tra	call_ext_out	6
	tra	opch		7
	tra	enable		8
	tra	enable_1		9
	tra	sort_entry_seq	10
	tra	sort_release	11
	tra	runtime_check	12
	tra	sort_return	13
	tra	sort_initiate	14
	tra	real_to_real	15
	tra	establish_cleanup	16
	tra	sort_terminate	17
	tra	revert_cleanup	18
	tra	sort_comp		19
	tra	accept_line	20
	tra	init_start	21
	tra	sort_commence	22
	tra	start_control	23
	tra	set_lin_file_status	24
	tra	set_file_status	25
	tra	dsply_user_output	26
	tra	close_file	27
	tra	dsply_error_output	28
	tra	close_op_file	29
	tra	open_ext_file	30
	tra	open_int_file	31
	tra	find_iocb		32
	tra	check_attach	33
	tra	attach_iocb	34
	tra	open_file		35
	tra	open_close_file	36
	tra	check_file	37
	tra	close_file_only	38
	tra	init_write	39
	tra	write_stream	40
	tra	seek_key		41
	tra	write_record	42
	tra	stop_literal	43
	tra	accept_date	44
	tra	accept_day	45
	tra	accept_time	46
	tra	accept_day_of_week	47
	tra	stop_run		48
	tra	cancel		49
	tra	inspect_tally	50
	tra	inspect_replace	51
	tra	linage		52
	tra	delete		53
	tra	delete_error	54
	tra	read_key		55
	tra	init_delete	56
	tra	special_delete	57
	tra	special_rewrite	58
	tra	rewrite		59
	tra	merge_init	60
	tra	merge_comp	61
	tra	merge_return	62
	tra	init_read		63
	tra	get_line		64
	tra	read_record	65
	tra	nonseq_read_record	66
	tra	read_seek_key	67
	tra	write_stream_linage	68
	tra	read_key_for_read	69
	tra	receive_comm	70
	tra	accept_comm	71
	tra	purge_comm	72
	tra	send_comm		73
	tra	enable_comm	74
	tra	disable_comm	75
	tra	close_reel	76
	tra	init_cd		77
	tra	alt_open_file		78	[3.0-1]
	tra	alt_start			79	[3.0-1]
	tra	alt_read_next		80	[3.0-1]
	tra	alt_read_record		81	[3.0-1]
	tra	alt_seek_key		82	[3.0-1]
	tra	alt_start_control		83	[4.0-3]
	tra	alt_read_key		84	[3.0-1]
	tra	alt_special_delete		85	[3.0-1]
	tra	alt_delete		86	[3.0-1]
	tra	alt_key_delete		87	[3.0-1]
	tra	alt_rewrite_add		88	[3.0-1]
	tra	alt_close_file		89	[3.0-1]
	tra	alt_add_write_keys		90	[3.0-1]
	tra	alt_write_seek_key		91	[3.0-1]
	tra	alt_find_rec		92	[3.0-1]
	tra	alt_rewrite		93	[4.4-1]
	tra	stop_cd_run		94	[4.4-3]
"	Please insert the next tra instruction before this line.
"
"

"	****************************************
"
"	The following operators are high used operators.
"
"	****************************************
"


"	operators to call an entry variable
"	entered with pointer to entry in bp and number
"	of arguments in position in a, offset of arg list is in x0
"
call_ent_var_desc_from_op:
	eaq	0,au		there are descriptors
	tra	call_ent_var_from_op		do not use x0
call_ent_var_desc:
	eaq	0,au		there are descriptors
"
call_ent_var:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
call_ent_var_from_op:
	ora	4,dl		insert cobol code
	epbpsb	sp|0		get ptr to base of stack
	staq	sb|0,1		save at head of list
	eppbp	bp|0,*		and ptr to entry
save_display:
	eppap	sb|0,1		get ptr to arg list
var_call:
	sti	sp|stack_frame.return_ptr+1
	callsp	bp|0		and transfer to entry
"
"	operator to call an external procedure (same or diff seg).
"	entered with pointer to entry in bp and number of args
"	in position in a, offset of arg list is in x0
"
call_ext_in_desc_from_op:
call_ext_out_desc_from_op:
	eaq	0,au		there are descriptors
	tra	call_ext_in_from_op		do not use x0
call_ext_in_desc:
call_ext_out_desc:
	eaq	0,au		there are descriptors
"
call_ext_in:
call_ext_out:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
call_ext_in_from_op:
call_ext_out_from_op:
	epbpsb	sp|0		get ptr to base of stack
	ora	4,dl		insert cobol code (do this for now)
	staq	sb|0,1		save at head of list
	eppap	sb|0,1		get pointer to arg list
"
"	This label is 'segdef'ed but is never transfered to directly. The segdef is
"	merely to allow default_error_handler to see if a fault occured as a result
"	of this particular instruction so that it can print a more informative
"	error message.
"
forward_call:
	sti	sp|stack_frame.return_ptr+1
	callsp	bp|0		transfer to entry
"
"

" Macro to generate the calling sequence for <trace>|[catch_pl1_].  When
" invoked by the COBOL entry operator it will allow trace to monitor COBOL calls
" to external procedures. (P. Krupp 09/20/77)

          macro     trace
"         BEGIN MACRO trace
          ife       &1,trace_
          epaq      *                       get segment number of cobol_operators_
          lprp4     7|stack_header.lot_ptr,*au  cobol_operators_ linkage pointer
          sprp2     7|stack_header.stack_end_ptr,* save entry pointer
          tsp2      <trace>|[catch_pl1_]           invoke trace
          lprp2     7|stack_header.stack_end_ptr,* restore entry pointer
	ldx0	2|3 restore relocation offset
ifend
"         END MACRO trace
          &end

" Macro to generate code for the COBOL entry operator.  The macro will generate
" code for two entry operators.  One for normal use and the other for using trace
" in conjunction with COBOL programs.  (P. Krupp 09/20/77)
          macro     cobol_entry
"         BEGIN MACRO cobol_entry
"
"
"	entry for entry_version_1.
"	entry for setting up the pr0 for cobol operators_ and initializing
"	the stack frame and/or header.
	segdef	&1entry_version_1
&1entry_version_1:
	ldx0	bp|0		get the relocation offset
	eppbp	bp|-3		set pr2 to cobol entry location
          trace     &1
	epaq	bp|0		get segment number of text
	lprplp	sb|stack_header.lot_ptr,*au get seg no, offset of linkage from  packed ptr
	eppbb	sb|stack_header.stack_end_ptr,* get ptr to next stack frame
	sprisp	bb|stack_frame.prev_sp set back ptr of new frame
	spriap	bb|stack_frame.arg_ptr save arg pointer
	eppab	bb|0,7		get pointer to end of new frame
	spriab	bb|stack_frame.next_sp set next pointer of new frame
	spriab	sb|stack_header.stack_end_ptr set new stack end ptr
	eppsp	bb|0		update sp
"         END MACRO cobol_entry
          &end
          cobol_entry trace_
          tra       eed           trace has been invoked, finish rest of entry operator
          cobol_entry
eed:
	lda	ap|0		get 2*n_args in au, code in al
	cana	8,dl		is there an extra arg
	tze	2,ic		no
	ada	2,du		yes, allow for it
	eppbb	ap|2,au		get ptr to descriptors
	spribb	sp|descriptor_ptr	set ptr in stack frame
save_link:
	sprilp	sp|linkage_ptr	save ptr to linkage in stack head
	spribp	sp|stack_frame.entry_ptr save ptr to entry point
init_stack_join:
	spbpbp	sp|text_base_ptr	save ptr to base of text segment
	spbpbp	sp|return_to_main_ptr		set the segment number for cobol return location
	stz	sp|stack_frame.operator_ret_ptr init operator return offset
"
	eppap	operator_table	and pointer to operators
	spriap	sp|stack_frame.operator_ptr save pointer to operator segment
	spriab	sp|4		save pointer to end of frame for temp extensions
"		set the parameter for cobol_rts
"		pr6|68 and pr6|70 are reserved for cobol_rts_
	epp0	pr6|rts_code_ptr
	spri0	pr6|70		point to the storage for rts_code_ptr
	epp0	pr6|rts_code
	spri0	pr6|rts_code_ptr	point to the base of rts stack
	lda	pr2|6		get the cobol_rts_
	epp1	pr4|0,au*	obtain the link of cobol_rts_
	spri1	pr6|rts_save	store the rts_save
	fld	2048,dl
	ora	4,dl
	staq	pr6|68
	stz	pr6|73		set 0 for the use_code on error_stack
	epp4	pr4|0,0		get pr4 for operator
	spri2	pr6|return_to_main_ptr
	spri4	pr6|pr4_save	save for future use
	spri2	pr4|16		store stat.entry_ptr
	lda	pr4|call_cnt	get the call_cnt
	tpl	return_from_control	data already initialized
	spri4	pr6|74		store the parameter
	epp0	return_from_control	preset the return point
	spri0	pr6|stack_frame.return_ptr
	lda	2,dl		load rts_code for cobol_control
	sta	pr6|rts_code
	tra	call_rts_from_op		call cobol_control
	even
return_from_control:
	epp3	return_from_call	reset the return_ptr to cobol operators_
	spri3	pr6|stack_frame.return_ptr
	epp1	pr6|pr4_save,*	load pr4
	epp3	pr1|control_ptr,*
	lxl1	pr3|27
	anx1	1,du
	eaa	0,x1
	arl	7
	sta	pr6|ind_mask
	ldi	pr6|ind_mask
	epp3	pr1|cobol_data_ptr,*
	adwp3	16384,du
	spri3	pr6|pr3_save
	epp5	pr1|cobol_data_ptr,*
	adwp5	49152,du
	spri5	pr6|pr5_save
	epp0	pr6|stack_frame.operator_ptr,*
	spri0	pr6|subr_return_save set for subroutine calls within operators
	epp4	pr6|linkage_ptr,*
	epp2	pr6|stack_frame.entry_ptr,*
	aos	pr1|call_cnt	update the call_cnt
	lda	pr1|call_cnt	check the call_cnt
	tnz	bp|6		skip one instruction, data already initialized.
	tra	bp|5
"
"
"	The operator for saveing the pointer register pr0, pr3 and pr5
"
	even
return_from_pl1_op:
	epbp0	pr6|return_to_main_ptr,*		reset the text base ptr to normal
	spri0	pr6|text_base_ptr
	even
return_from_call:
	ldi	pr6|ind_mask
	epp4	pr6|linkage_ptr,*		reload pr4
	epp3	pr6|pr3_save,*		reload pr3
	epp5	pr6|pr5_save,*		reload pr5
	epp0	pr6|stack_frame.operator_ptr,*	reload pr0
	tra	pr6|return_to_main_ptr,*		return to the cobol program
"
"	The label for  io return.
"	It skip one instruction in cobol program and reset  return_ptr to normal
"
	even
io_return_to_reset:
	lda	1,du		skip one instruction for io return
	asa	pr6|return_to_main_off
"
"	The label for reset the return_ptr before return.
"
	even
return_to_reset:		
	epp0	return_from_call	reset return_ptr back to normal
	spri0	pr6|stack_frame.return_ptr
	tra	return_from_call
"
"
"
"
"	The operator for calling the cobol_rts_ routine.
"
"
call_rts:
	epp2	pr6|rts_code		get the  stack pointer for rts
call_rts_special:
	spri2	pr6|rts_code_ptr		sotre the cobol_rts parameter
call_rts_load_code:
	sta	pr6|rts_code
"		call from cobol operator  and the parameter is set already
call_rts_from_op:
	epp2	pr6|rts_save,*		get cobol_rts_
	epbp7	pr6|0	set the stack header pointer
	epp0	pr6|68		set the argument pointer
	callsp	bp|0
"
"
"
"
"
"
"	The operator for the DISPLAY.
"		PR5 set to display area info.
"
"
"		main line code tsx0	pr0|32 = dsply_user_output, and
"			     tsx0	pr0|34 = dsply_error_output.
dsply_error_output:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	epp4	pr6|pr4_save,*
	epp1	pr4|50		pointer to iox_$error_output
	lda	4,dl		use retrycode as error switch
	tra	display_op
dsply_user_output:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	epp4	pr6|pr4_save,*
	epp1	pr4|48		pointer to iox_$user_output
	lda	3,dl		use retrycode as error switch
display_op:
	tsx6	pr0|subr_put_chars
	szn	pr6|mcode
	tze	io_return_to_reset	display good, NO retry
	lda	pr6|retrycode
	sta	pr6|cobol_error_code
	tra	cobol_error_from_op	output error message, and retry
"
"
"
"	The sort entry for compare procedure.
"
sort_entry_seq:
	eppbp	bp|-4
	eppbb	sb|stack_header.stack_end_ptr,* get ptr to next stack frame
	sprisp	bb|stack_frame.prev_sp set back ptr of new frame
	spriap	bb|stack_frame.arg_ptr save arg pointer
	eppab	bb|0,7		get pointer to end of new frame
	spriab	bb|stack_frame.next_sp set next pointer of new frame
	spriab	sb|stack_header.stack_end_ptr set new stack end ptr
	eppsp	bb|0		update sp
	epp3	return_from_call	reset the return_ptr to cobol operators_
	spri3	pr6|stack_frame.return_ptr
	spri3	pr6|pr3_save	save any pointer in case of restoration
	spri3	pr6|pr5_save	save any pointer in case of restoration
	spri3	pr6|pr4_save	save any pointer in case of restoration
	spri3	pr6|linkage_ptr
	lda	ap|0		get 2*n_args in au, code in al
	cana	8,dl		is there an extra arg
	tze	2,ic		no
	ada	2,du		yes, allow for it
	eppbb	ap|2,au		get ptr to descriptors
	spribb	sp|descriptor_ptr	set ptr in stack frame
	spribp	sp|stack_frame.entry_ptr save ptr to entry point
	spbpbp	sp|text_base_ptr	save ptr to base of text segment
	eppap	operator_table	and pointer to operators
	spriap	sp|stack_frame.operator_ptr save pointer to operator segment
	tra	bp|5
"
"
"	init_write check file condition
"
"
init_write:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	spri1	pr6|86		set pr 1
	stz	pr6|icode		reset on each entry to zero
	szn	pr1|2		is file opened
	tnz	pr6|text_base_ptr,*0  YES,
"	set status
	lda	io30_con
	ldq	s4031con
	staq	pr6|status12
	ldx1	24,du		attempt to perform io on an unopened file
	tra	return_thru_text_base_pone
"
"
"	write_stream  call  iox_$put_chars	OPERATOR(40)**********
"
"
write_stream:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	spri1	pr6|86		set iocb_ptr
	tsx6	pr0|subr_put_chars
	szn	pr6|mcode
	tze	return_to_reset
	tra	write_stream_error
"
"				**********OPERATOR(68)**********
"
"
write_stream_linage:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	spri1	pr6|86		set iocb_ptr
	tsx6	pr0|subr_put_chars
	epp1	pr6|86,*		reset pr 1
	lda	pr6|47		load A with advancing value
	dtb	(pr),(pr)		store cobol_fsb.linage_counter into stack word
	desc9ns	pr1|88,6,0
	desc9a	pr6|46,4
"	lxl3 	0,dl
"	szn 	pr6|46		if linage counter  zero then set to one
"	tnz	8,ic		NOT zero then bypass
"	aos	pr6|46		set linage counter to one start of new page
"	lxl3	1,dl
"	stz	pr6|icode	reset, as linage counter is 1
"	btd	(pr),(pr)
"	desc9a	pr6|46,4
"	desc9ns	pr1|88,6,0
"	tra	8,ic
          szn       pr6|46              [4.0-2], by MHD
          tnz       2,ic                [4.0-2], by MHD
          lda       1,dl                [4.0-2], by MHD
	ada	pr6|46		increment linage counter by advancing value
	sta	pr6|46		store new linage_counter
	btd	(pr),(pr)		store stack word into cobol_fsb.linage_counter
	desc9a	pr6|46,4
	desc9ns	pr1|88,6,0
	cmpa	pr1|93		is new linage_counter >= footing
	tmi	cont_write_stream
	lda	pr6|41
	tze	return_to_reset
	tra	io_return_to_reset
cont_write_stream:
	szn	pr6|mcode
	tze	return_to_reset
"	set status
write_stream_error:
	lda	io30_con
	ldq	s4430con
	staq	pr6|status12
	ldx1	21,du		unable to write record
	tra	io_return_to_reset
"
"
"	seek_key	call iox_$seek_key	OPERATOR(67)**********
"
"
read_seek_key:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	lda	1,dl
	sta	pr6|54
	tra	seek_common
"
"				**********OPERATOR(41)**********
"
"
seek_key:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	stz	pr6|54		for write
seek_common:
	spri1	pr6|86		set iocb_ptr
	epp2	pr1|7
	spri2	pr6|88		store pointer to key area
	epp2	pr6|62		work area not used as seek key returns length
	spri2	pr6|90		store pointer to key len
	lda	16,dl
	sta	pr6|rts_code	store rts code
	tsx6	pr0|subr_seek_op
	szn	pr6|mcode
	tze	return_to_reset
"	set status
	ldx1	26,du
	szn	pr6|54		read or write?
	tnz	io_return_to_reset	read.
	lda	io30_con
	ldq	s4632con
	staq	pr6|status12
	tra	io_return_to_reset
"
"
"	SUBROUTINE to iox_$seek_key
"
"
subr_seek_op:
	stx6	pr6|subr_return_save_off
	epp2	pr6|mcode
	spri2	pr6|92		store pointer to mcode
	spri2	pr6|76		mcode_ptr
	eax1	pr6|84
	fld	8192,dl		4 args
	epp2	pr1|0,*
	epp2	pr2|74		offset for iox_$seek_key
	epp0	return_seek_key
	spri0	pr6|stack_frame.return_ptr
	tra	call_ent_var_from_op
return_seek_key:
	epp4	pr6|linkage_ptr,*	reset linkage pointer
"	rts code must be set by caller to this SUBROUTINE
	epp0	pr6|subr_return_save,* EXIT FROM SUBROUTINE
	spri0	pr6|stack_frame.return_ptr
	tra	call_rts_from_op	handle seek errors
"
"
"	SUBROUTINE to set up for iox_$write_record and iox_$rewrite_record
"
"
subr_write_record:
	stx6	pr6|subr_return_save_off
	epp1	pr6|86,*		reset pr 1
	spri5	pr6|78		store_buff_ptr
	epp2	pr6|78
	spri2	pr6|88		store pointer to buffptr
	epp2	pr6|80
	spri2	pr6|90		store pointer to buff_len
	epp2	pr6|mcode
	spri2	pr6|92
	eax1	pr6|84
	fld	8192,dl		4 args
	epp2	pr1|0,*
	tra	pr6|subr_return_save,* EXIT FROM SUBROUTINE
"
"				**********OPERATOR(42)**********
"	write record op		call iox_$write_record
"
"
write_record:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	tsx6	pr0|subr_write_record
	epp2	pr2|62		offset for iox_$write_record
	epp0	return_write_record
	spri0	pr6|stack_frame.return_ptr
	tra	call_ent_var_from_op
return_write_record:
	szn	pr6|mcode
	tze	return_to_reset
"	set status
	lda	io30_con
	ldq	s4432con
	staq	pr6|status12
	ldx1	41,du		Write is an invalid operatoin for current open mode
	tra	io_return_to_reset
"
"
"	SUBROUTINE to put_chars
"
"
subr_put_chars:
	stx6	pr6|subr_return_save_off
	sta 	pr6|retrycode
	spri1	pr6|86		set iocb_ptr
	spri5	pr6|78		store buff_ptr
	epp2	pr6|78
	spri2	pr6|88		store pointer to buff_ptr
	epp2	pr6|80
	spri2	pr6|90		store pointer to buff_len
	epp2	pr6|mcode
	spri2	pr6|92		store pointer to mcode
	eax1	pr6|84
	fld	8192,dl		4 args
	epp2	pr1|0,*		indirect thru fsb to iocb
	epp2	pr2|42		offset for iox_$put_chars
	epp0	pr6|subr_return_save,* EXIT FROM SUBROUTINE
	spri0	pr6|stack_frame.return_ptr
	tra	call_ent_var_from_op	call iox_$put_chars
"
"
"	linage
"		A reg set with advancing value
"
"
linage:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
          lxl3      0,dl                [4.0-2], by MHD
	epp1	pr6|86,*		reset pr 1
	cmpa	1000,dl 		Is the PAGE  force value
	tze	force_page	YES,
	lda	pr6|47
	ldq	pr6|47
	sta	pr6|81		set advancing value
	adq	pr6|80		increment Q with buff length
	stq	pr6|81		= buff length +advancing value
	dtb	(pr),(pr)		store the linage_counter into a stack word
	desc9ns	pr1|88,6,0
	desc9a	pr6|46,4
	ada	pr6|46		increment A with current linage_counter
	cmpa	pr1|92		is linage_counter + advancing value > page_size
	tpnz	finish_curr_page	YES, do finish current page,include TOP, LC = 1
	lda	pr6|80		reset  A to buff length
	ldq	pr6|47		reset q to adv value
	btd	(pr),(pr)
	desc9a	pr6|46,4
	desc9ns	pr1|88,6,0
	tra	return_to_reset
force_page:
finish_curr_page:
	ldq	pr1|92		load Q with page_size
	sbq	pr6|46		subtract linage_counter from Q
	adq	1,dl
	adq	pr6|80		add advancing + buff length
	adq	pr1|94		add top_size to Q
	adq	pr1|95		add bottom_size to Q
	stq	pr6|81		= total amount from last write to new write on next page
	stz	pr6|46		initialize linage_counter to 0
	btd	(pr),(pr)		store the stack word back to the linage counter
	desc9a	pr6|46,4
	desc9ns	pr1|88,6,0
          lxl3      1,dl                [4.0-2],by MHD. shows page overflow occured
	lda 	pr6|80		reset A to length of buffer
	ldq	pr6|47		reset q to adv value
	tra	return_to_reset
"
"
"	Please insert the new highly used cobol operator before this line.
"
"

"	****************************************
"
"
"
"	This is the overpunch operator.
"
"	****************************************
"
"


"
"
cobol_opch_operator_:
opch:
"	Modified on 3/12/76 by Bob Chang for cobol operator.
"
"  This ALM procedure is the cobol_operator_ that does conversion
"  to and from overpunch sign decimal data.
"  For this first implementation some simplifying assumptions are made:
"	1.  Only three formats of data can be converted.
"		a. unpacked decimal, trailing sign.
"		b. overpunch decimal, leading sign.
"		c. overpunch decimal, trailing sign.
"
"	2.  Before this operator is called, any data, other than overpunch
"	    or unpacked decimal trailing sign, is converted to unpacked
"	    decimal trailing sign data in a temporary.
"
"  Subsequent implementations may provide for direct conversion by this
"  operator of the following data formats:
"	1. long fixed binary
"	2. short fixed binary
"	3. packed decimal, leading or trailing sign
"
"  ENTRY CONDITIONS
"
"  Data is passed to this operator in the following registers:
"
"  
"  1. pr1 points to the target of the conversion.
"  
"  2. pr2 points to the source of the conversion.
"  
"  3. pr5 points to a block of work space, at the top of the
"  stack.  This work space must be aligned on a double word
"  boundary.
"  
"  4. Q register contains the scale and precision of the source of
"  conversion.
"  
"  	a. bits 0-17 of the Q register contains the scale.
"  	Scale is obtained from data_name.places_right of a
"  	data name token.
"  
"  	b. Bits 18-36 of the Q contain precision.
"  	Precision is obtained from data_name.item_length of a
"  	data name token.
"  
"  5. A register contains the scale and precision of the target
"  of conversion.  Bits 0-17 contain the scale,
"  bits 18-36 contain the precision.  Scale and precision are obtained
"  as for the source of conversion.
"  
"  6. X7 contains a code that identifies the data type of the
"  source of conversion.  This code is defined in the following
"  table:
"  
"  	x7 contents	| type of source
"  	__________________________________________
"  	     1		| overpunch,leading sign
"  	     2		| overpunch, trailing sign
"  	     3		| unpacked decimal, trailing sign
"  
"  7. X6 contains a code that identifies the data type of the
"  target of conversion.  This code is the same as that described
"  above for X7.
"  
"  8. pr3 is used to store the location to which the cobol
"  overpunch conversion operator is to return.
"  
	segdef	cobol_opch_operator_


"  definition of offsets within the work space

	equ	scales,0
	equ	s_scale,1
	equ	t_scale,0
	equ	temp1,2
	equ	temp2,3
	equ	temp3,4
	equ	source_desc,5
	equ	target_desc,6
	equ	pr_store,8
	equ	x_store,10
	equ	save_t_scale,11
	equ	temp_source,12
	equ	udts_source_ret,32
	equ	opch_udts_ret,33
	equ	opch_opch_ret,34

"  definition of the names of pointer registers

	equ	work_pr,5
	equ	source_pr,2
	equ	target_pr,1
	equ	return_pr,3


" ***************************************
"				*
" *  ENTRY POINT			*
" *				*
" ***************************************


cobol_opch_operator_:
	spri3	pr6|return_to_main_ptr
	staq	work_pr|scales




	cmpx7	3,du	is source unpacked decimal?
	tnz	opch_source	no, must be overpunch
	tsx5	udts_source	yes
	tra	operator_exit

opch_source:

	cmpx6	3,du	Is destination unpacked decimal?
	tnz	opch_dest	no, must be overpunch

udts_dest:
	tsx5	opch_udts
	tra	operator_exit

opch_dest:
	tsx5	opch_opch

operator_exit:
	epp7	pr3|0
	epp4	pr6|linkage_ptr,*
	epp3	pr6|pr3_save,*
	epp5	pr6|pr5_save,*
	tra	pr7|0

" **************************************
" *     udts_source			*
" ***************************************

udts_source:

	stx5	work_pr|udts_source_ret  store return point

"  calculate the number of characters to move from the source, and the character
"  position in the source at which to start the move

	tsx5	calc_length

"  Set up to insert scale factors into the indirect descriptors

	lda	dec_ns_source_desc
	ldq	opch_target_desc
	tsx5	insert_scale_factor

"  Move the source to the target with scaling, but without moving the sign

	mvn	(pr,rl,id,x2),(pr,rl,id)
	arg	work_pr|source_desc
	arg	work_pr|target_desc

"  Get the character offset of the sign byte of the source

	lxl1	work_pr|s_scale
	adx1 	-1,du

"  Test to see if the sign is plus or minus

	cmpc	(pr,x1),(0,0),fill(000)
	desc9a	source_pr|0,1
	desc9a	plus_sign,1

	tze	trailing_dec_plus

"  Must be trailing minus sign

	ldx2	1,du	set to indicate trailing sign was negative

	tra	check_target_sign

trailing_dec_plus:

	ldx2	0,du	offset of plus overpunch characters in the dec_to_op_sign table

check_target_sign:

"  Determine whether target is leading or trailing sign overpunch.

	cmpx6	2,du	Is target trailing sign overpunch?
	tze	op_ts	yes

"  Must be leading sign overpunch

	ldx3	0,du
	tra	insert_op_sign

op_ts:

"  Calculate the offset of the last byte in the target

	lxl3	work_pr|t_scale
	adx3	-1,du

insert_op_sign:

"  Insert the overpunch character into the leading or trailing byte of the target.
	cmpx2	0,du
	tnz	insert_neg_op	trailing sign was negative

	mvt	(pr,x3),(pr,x3),(0,0),fill(000)
	desc9a	target_pr|0,1
	desc9a	target_pr|0,1
	arg	plus_dec_op_sign_table
	tra 	udts_source_exit
insert_neg_op:

	mvt	(pr,x3),(pr,x3),(0,0),fill(000)
	desc9a	target_pr|0,1
	desc9a	target_pr|0,1
	arg	minus_dec_op_sign_table


udts_source_exit:



"  Return to the entry sequence of this program

	ldx5	work_pr|udts_source_ret  restore return point
	tra	0,x5  return

" **************************************
" *     opch_udts			*
" ***************************************

opch_udts:

	stx5	work_pr|opch_udts_ret  store return point
"  Move the overpunch sign source into an unpacked decimal unsigned temporary.

	tsx5	unpack_opch

"  Move the sign from the sign table into the trailing sign byte of the temporary
"  Note that x1 contains the length of the source, which is the character position of 
"  the trailing sign byte.

	mlr	(x3),(pr,x1)
	desc9a	sign_table,1
	desc9a	work_pr|temp_source,1

"  Calculate the length of the temporary to move, and the character position at which 
"  to start the move.

	tsx5	calc_length

"  Increment length of source, because length was derived for overpunch source, and we 
" are moving an unpacked decimal, trailing sign temporary.

	adx1	1,du

"  Set up to insert the scale factor into the indirect descriptors.

	lda	dec_ts_temp_source_desc
	ldq	dec_ts_target_desc
	tsx5	insert_scale_factor

"  Move the unpacked dec, trailing sign temporary to the unpacked dec, target

	mvn	(pr,id,rl,x2),(pr,id,rl)
	nop	work_pr|source_desc
	nop	work_pr|target_desc

"  Return to the calling sequence

	ldx5	work_pr|opch_udts_ret
	tra	0,x5

" **************************************
" *     opch_opch			*
" ***************************************

opch_opch:

	stx5	work_pr|opch_opch_ret  store return point

"  Store the pointer to the target field and the type code of the target

	spri1	work_pr|pr_store
	stx6	work_pr|x_store

"  Set pointer to target to a temporary.  Set the target type code to unpacked decimal

	epp	target_pr,work_pr|temp_source
	ldx6	3,du

"  Save the scale and precision of the original target
	lda	work_pr|t_scale
	sta	work_pr|save_t_scale
"  Increment the precision of the target, since we are
"  adding a trailing sign byte when converting to unpacked decimal.
	lxl1	work_pr|t_scale
	adx1	1,du
	sxl1	work_pr|t_scale
"  Convert the overpunch source to an unpacked decimal into the temporary

	tsx5	opch_udts

"  Set the source pointer to the imal temporary, and the source type code to 
"  unpacked decimal.

	epp	source_pr,target_pr|0
	ldx7	3,du

"  unpacked decimal target now becomes the source
"  Set source scale and precision to the scale and precision of the
"  unpacked decimal temporary.
	lda	work_pr|t_scale
	sta	work_pr|s_scale

"	restore the target scale and precision
	lda	work_pr|save_t_scale
	sta	work_pr|t_scale


"  Restore the target pointer and type code to the overpunch target

	epp	target_pr,work_pr|pr_store,*
	ldx6	work_pr|x_store

"  Convert the unpacked dec temporary to the overpunch sign target

	tsx5	udts_source

	"  Return to the calling sequence

	ldx5	work_pr|opch_opch_ret  restore return point
	tra	0,x5  return



" ***************************************
" *     unpack_opch*
" ***************************************

unpack_opch:

"  Move the overpunch sign source into a temporary

	lxl1	work_pr|s_scale	get length of source

	mlr	(pr,rl),(pr,rl)
	desc9a	source_pr|0,x1
	desc9a	work_pr|temp_source,x1

"  Get the character position of the overpunch sign character into x2

	cmpx7	1,du	Is source leading overpunch sign?
	tnz	t_opch	no
	ldx2	0,du	Yes, overpunch character is in zeroth byte position
	tra	common1

t_opch:

	lxl2	work_pr|s_scale	get length of source
	adx2	-1,du  	Decrement by one to get char position of last byte

common1:

"  Translate the overpunch sign character into a subscript into the digit_table and sign_table

	stz	work_pr|temp1
	mvt	(pr,x2),(pr)
	desc9a	source_pr|0,1
	desc9a	work_pr|temp1(1),1
	arg	mvt_table

"  Load the subscript into x3

	ldx3	work_pr|temp1

"  Test to see if overpunch char is legal.
	adx3	-1,du
	tmi	bad_oph
"  Char OK keep going

"  Move the digit from the digit table into the leading or trailing byte of the temporary.

	mlr	(x3),(pr,x2)
	desc9a	digit_table,1
	desc9a	work_pr|temp_source,1

"  Return to the calling sequence

	tra	0,x5

"  Cause ipr for bad overpunch char.
bad_oph:
	stx3	work_pr|temp1
	cmpn	(pr),(pr)
	desc9a	work_pr|temp1(1),1
	desc9a	work_pr|temp1(1),1
" ***************************************
" *     calc_length			*
" ***************************************

calc_length:

"  This sequence of code calculates:
"  	1.  The length of the source field to be moved. (Returned in x1)
"	2. The character offset of the leftmost character of the source field
"	to be moved. (Returned in x2)
"	The length of the target field. (Returned ix x3)

"  	The calling sequence return point is contained in x5, so x5 must not be modified by
"	this code.  Also x4 is used as a work register.

"  Calculate source places left

	lxl2	work_pr|s_scale	precision (length) of source
	cmpx7	3,du	is source unpacked decimal?
	tnz	s_non_dec	no
	adx2	-1,du	decrement length to exclude the sign byte

s_non_dec:

	stx2	work_pr|temp1
	ldx1	work_pr|temp1	load length into x1
	sbx2	work_pr|s_scale	subtract scale to get source places left in x2.

"  Calculate destination places left

	lxl4	work_pr|t_scale	precision (length) of the target
	lxl3	work_pr|t_scale
	cmpx6	3,du	Is target unpacked decimal?
	tnz	t_non_dec	no
	adx4	-1,du	decrement by 1 to exclude the sign byte

t_non_dec:
	stz	work_pr|temp1
	stx4	work_pr|temp1

"  Subtract scale to get target places left

	sbx4	work_pr|t_scale
	stx4	work_pr|temp1	save places left

"  Subtrace target places left from source places left.

	ssx2	work_pr|temp1

	tmoz	target_big_enough

"  Target places left less than source places left,  must adjust source legnth.

"  Note that if the difference is positive, it contains the character position at which to start moving characters

	ldx2	work_pr|temp1
	sbx1	work_pr|temp1	adjust length
	tra	calc_length_return

target_big_enough:

"  It is not necessary to start the move at a characterhother than the first.  Set x2 to zero, so
"  that the first character in the source will be moved.

	ldx2	0,du

calc_length_return:

	tra	0,x5

" ***************************************
" *     insert_scale_factor		*
" ***************************************

insert_scale_factor:

"  This sequence of code inserts the scale factor of the source and target fields into indirect
"  descriptors.

"  ENTRY CONDITIONS
"	1. A register contains the source field indirect descriptor
"	2. Q register contains the target field indirect descriptor
"	3.  x5 conatins the return address.

"  Insert scale factor into the source indirect descriptor

	sta	work_pr|source_desc
	lda	work_pr|s_scale	scale factor in upper
	ars	18	extend sign
	neg
	als	6	shift to SF position
	ana	scale_factor_mask	and out junk
	orsa	work_pr|source_desc	insert SF inot indirect descriptor

"  Insert scale factor into the target indirect descriptor

	stq	work_pr|target_desc
	lda	work_pr|t_scale	scale factor in upper of a now
	ars	18	extend sign
	neg
	als 	6	shift to SF position
	ana	scale_factor_mask	mask out junk
	orsa	work_pr|target_desc	insert SF into indirect descriptor

"  Return to caller

	tra	0,x5

" ***************************************
" *     CONSTANTS AND TABLES		*
" ***************************************

dec_ts_temp_source_desc:
	desc9ts	work_pr|temp_source,x1,0

dec_ts_target_desc:
	desc9ts	target_pr|0,x3,0

dec_ns_source_desc:
	desc9ns	source_pr|0,x1,0

opch_target_desc:
	desc9ns	target_pr|0,x3,0

dec_ns_temp_source_desc:
	desc9ns	work_pr|temp_source,x1,0

scale_factor_mask:
	oct	000000007700

plus_sign:
	aci	/+/


plus_dec_op_sign_table:
empty1:
	oct	0
	oct	0
sign_table:
	aci	/++++/
minus_dec_op_sign_table:
	aci	/++++/
	aci	/++--/
	aci	/----/
	aci	/----/
digit_table:
	aci	/0123/
	aci	/4567/
	aci	/8901/
	aci	/2345/
	aci	/6789/
	aci	/{ABC/     PLUS OVERPUNCH DIGITS
	aci	/DEFG/     PLUS OVERPUNCH DIGITS
	aci	/HI  /     PLUS OVERPUNCH DIGITS
	aci	/}JKL/     MINUS OVERPUNCH DIGITS
	aci	/MNOP/     MINUS OVERPUNCH DIGITS
	aci	/QR  /     MINUS OVERPUNCH DIGITS
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
mvt_table:
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	001002003004
	oct	005006007010
	oct	011012000000
	oct	0
mvt_data1:
	oct	000002003004	maps overpunch digits into subscript into sign_table 
	oct	005006007010	and digit_table.
	oct	011012014015	   ditto
	oct	016017020021	   ditto
	oct	022023024000	   ditto
empty2:
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
mvt_data2:
	oct	000000000001	maps "{" into digit_table and sign_table
mvt_data3:
	oct	000013000000	maps "}" into digit_table and sign_table
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0
	oct	0

"
"
"
"  This  was added to get rid of a page of zeroes in the object segment
"  When the previos table reaches 2000 octal remove the following two statements
	org	1024
	nop	 1
	org	2048
	use	text2

	include	cobol_op_fix_con
"
"
"  This was  added to get rid of a page of zeroes in the object segment
"  When the previous table reaches  6030 octal remove the following two statements
	org	792
	nop	1
	org	1792
	use	text4

"	****************************************
"
"	This page is for the cobol_error. tra instruction.
"
"	****************************************
"
"
"
	tsx7	cobol_error_no_mcode	1
	tsx7	cobol_error_no_mcode	2
	tsx7	cobol_error		3
	tsx7	cobol_error		4
	tsx7	cobol_error_no_mcode	5
	tsx7	cobol_error		6
	tsx7	cobol_error		7
	tsx7	cobol_error_no_mcode	8
	tsx7	cobol_error_no_mcode	9
	tsx7	cobol_error_no_mcode	10
	tsx7	cobol_error		11
	tsx7	cobol_error		12
	tsx7	cobol_error		13
	tsx7	cobol_error		14
	tsx7	cobol_error		15
	tsx7	cobol_error		16
	tsx7	cobol_error_no_mcode	17
	tsx7	cobol_error		18
	tsx7	cobol_error		19
	tsx7	cobol_error_no_mcode	20
	tsx7	cobol_error		21
	tsx7	cobol_error		22
	tsx7	cobol_error_no_mcode	23
	tsx7	cobol_error_no_mcode	24
	tsx7	cobol_error		25
	tsx7	cobol_error		26
	tsx7	cobol_error		27
	tsx7	cobol_error_no_mcode	28
	tsx7	cobol_error		29
	tsx7	cobol_error		30
	tsx7	cobol_error		31
	tsx7	cobol_error		32
	tsx7	cobol_error_no_mcode	33
	tsx7	cobol_error_no_mcode	34
	tsx7	cobol_error_no_mcode	35
	tsx7	cobol_error_no_mcode	36
	tsx7	cobol_error		37
	tsx7	cobol_error		38
	tsx7	cobol_error_no_mcode	39
	tsx7	cobol_error_no_mcode	40
	tsx7	cobol_error         	41   [4.1-1]
	tsx7	cobol_error_no_mcode	42
	tsx7	cobol_error         	43  [4.1-1]
	tsx7	cobol_error_no_mcode	44
	tsx7	cobol_error_no_mcode	45
	tsx7	cobol_error_no_mcode	46
	tsx7	cobol_error_no_mcode	47
	tsx7	cobol_error_no_mcode	48
	tsx7	cobol_error_no_mcode	49
	tsx7	cobol_error		50
	tsx7	cobol_error		51
	tsx7	cobol_error		52
	tsx7	cobol_error_53		53
	tsx7	cobol_error		54
	tsx7	cobol_error		55
	tsx7	cobol_error		56
	tsx7	cobol_error		57
	tsx7	cobol_error		58
	tsx7	cobol_error_no_mcode	59
	tsx7	cobol_error_no_mcode	60
	tsx7	cobol_error_no_mcode	61
	tsx7	cobol_error_no_mcode	62
	tsx7	cobol_error_no_mcode	63
	tsx7	cobol_error_no_mcode	64
	tsx7	cobol_error_no_mcode	65
	tsx7	cobol_error_no_mcode	66
	tsx7	cobol_error_no_mcode	67
	tsx7	cobol_error_no_mcode	68
	tsx7	cobol_error_no_mcode	69
	tsx7	cobol_error_no_mcode	70
	tsx7	cobol_error_no_mcode	71
	tsx7	cobol_error_no_mcode	72
	tsx7	cobol_error_no_mcode	73
	tsx7	cobol_error_no_mcode	74
	tsx7	cobol_error_no_mcode	75
	tsx7	cobol_error_no_mcode	76
	tsx7	cobol_error_no_mcode	77
	tsx7	cobol_error_no_mcode	78
	tsx7	cobol_error_no_mcode	79
	tsx7	cobol_error_no_mcode	80
	tsx7	cobol_error_no_mcode	81
	tsx7	cobol_error_no_mcode	82
"
"
	org	1024
	use	text5

"
	include	cobol_op_var_con

"	****************************************
"
"	This page is for the cobol_error operator.
"
"	****************************************
"
"
cobol_error_no_mcode:
	stz	pr6|mcode
cobol_error:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	lda	1,dl		Set the rts_code for cobol_error_
	sta	pr6|rts_code
	sbx7	4096,du		Get the cobol_error_code
	stz	pr6|89
	sxl7	pr6|89
	epp0	pr6|stack_frame.entry_ptr,*		Get the entry pointer
	stz	pr6|92		Zero out the line number
	stz	pr6|93
	ldx0	pr0|4		entry_seq for the symbol section
	tze	line_no_done
	epp4	pr6|pr4_save,*		load pr4
	epp0	pr4|0,0*		get the symbol section
	lxl0	pr0|14		get the area offset
	lxl1	pr0|6,0		get the upper bound offset
	stx1	pr6|76		store into temporary location
	ldx0	pr0|6,0		get the lower bound offset
	ldx1	pr0|0,0		start the loop
	cmpx1	pr6|return_to_main_off
	tze	7,ic		the current line number
	tpl	5,ic		the next line number
	cmpx0	pr6|76		check with the upper bound
	tpl	line_no_done	no line number obtainable
	adx0	2,du
	tra	-7,ic		back to loop
	sbx0	2,du
	lda	pr0|0,0		get_statement_map
	ldq	pr0|1,0		load seperately in case of odd loc.
	anaq	line_mask		mask the line number part.
	lrl	10		get the file number in a reg
	sta	pr6|93
	qrl	22		get the line number in q
	stq	pr6|92
line_no_done:
	epp0	pr6|return_to_main_ptr,*		get the error pointer
	spri0	pr6|94
	lda	1,dl		get the rts code 1
	sta	pr6|rts_code
	epp0	pr4|19		load the location of program name
	spri0	pr6|96
	lda	pr4|18		get program name length
	sta	pr6|98
	lda	pr6|mcode		get status code of multics
	sta	pr6|90
	tra	call_rts_from_op
"	constant for cobol_error
	even
line_mask:
	oct	000000777777
	oct	740000000000
"
"
"
"	******************************
"
"		cobol_error_53
"
cobol_error_53:
"	epp4	pr6|linkage_ptr,*		reload pr4 after call out
"	lda	6,dl		load rts code for sort_terminate
"	sta	pr6|rts_code
"	epp0	return_from_term		overset the return pointer
"	spri0	pr6|stack_frame.return_ptr
"	tra	call_rts_from_op
	even
return_from_term:
	lda	pr6|80		get the multics status code
	sta	pr6|mcode
cobol_error_from_op:
	ldx0	pr6|return_to_main_off	load x0 before transfer to cobol_error
	epp4	pr6|linkage_ptr,*		reload pr4 after call out
	epp0	return_from_call		reset the return pointer back to noraml
	spri0	pr6|stack_frame.return_ptr
	lxl7	pr6|89		get the cobol error code
	adx7	4096,du		put the adjust error  code into x7
	tra	cobol_error
"
"
"
"
"	Please insert the next cobol error operator before this line
"

"	****************************************
"
"	The following operators are low used operators.
"
"	****************************************


"
"	operator to do a procedure return
"
return_mac:
	epbpsb	sp|0		get ptr to base of stack
	inhibit	on
	sprisp	sb|stack_header.stack_end_ptr reset stack end pointer
	eppsp	sp|stack_frame.prev_sp,* pop stack
	inhibit	off
	epbpsb	sp|0		set sb up in case we just switched stacks
	eppap	sp|stack_frame.operator_ptr,* set up operator pointer
	ldi	sp|stack_frame.return_ptr+1
	rtcd	sp|stack_frame.return_ptr continue execution after call
"
"
"
"
"	operator to enable a condition.  calling sequence is:
"		eppbp	name
"		lxl6	name_size
"		tsx0	ap|enable
"		tra	on_unit_body
"		arg	on_unit	(snap & system flags in RHS if used)
"		tra	skip_around_body
"	body of on unit starts here
"
	include	on_unit
enable_1:

"
"
enable:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	sxl0	sp|stack_frame.operator_ret_ptr
	epp1	sp|text_base_ptr,*0
	lda	=o100,dl		is there a valid on_unit_list
	cana	sp|stack_frame.prev_sp check bit 29 of sp|stack_frame.prev_sp
	tnz	3,ic		non-zero means ok
	stz	sp|stack_frame.on_unit_rel_ptrs init ptr
	orsa	sp|stack_frame.prev_sp and set bit
"
	ldx1	sp|stack_frame.on_unit_rel_ptrs get rel ptr to first enabled unit
	tze	add_on		zero means chain empty
on_1:	cmpx1	pr1|0		is this the unit we want
	tze	have_on		yes, go process
	ldx1	sp|on_unit.next,1	no, get ptr to next on chain
	tnz	on_1		and repeat if end not reached
add_on:	ldx1	pr1|0		get rel ptr to new unit
	ldx0	sp|stack_frame.on_unit_rel_ptrs get rel ptr to first unit
	stx0	sp|on_unit.next,1	set next ptr of new unit
	stx1	sp|stack_frame.on_unit_rel_ptrs make new unit first on chain
have_on:	spribp	sp|on_unit.name,1	set name of new unit
	spri3	sp|on_unit.body,1	set ptr to body
	stz	sp|on_unit.size,1	clear size field
	sxl6	sp|on_unit.size,1	set size of unit name
	lxl0	pr1|0		get snap & system flags
	sxl0	sp|on_unit.flags,1	and save in on unit
	stz	sp|stack_frame.operator_ret_ptr
	epp3	pr6|pr3_save,*
	epp5	pr6|pr5_save,*
	tra	pr1|1		return to cobol program
"
"
"
"

"	****************************************
"
"	The following operators are used for sort interface.
"
"	****************************************
"


"
"	The operator for sort_commence
"						**********OPERATOR(22)**********
"
"
sort_commence:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
"						RTS(7)
	lda	7,dl		load  rts_code
	sta	pr6|rts_code
	epp0	return_from_sort_commence	set the return_ptr to special location
	spri0	pr6|stack_frame.return_ptr
	tra	call_rts_from_op
	even
return_from_sort_commence:
	szn	pr6|80		check the status code	
	tze	sort_good		return to good sort label
	lda	56,dl		lda the error code and store
	sta	pr6|89
	tra	cobol_error_53
"
"	The operator for sort release
"		pr3 for the address od the data to be released
"		Q for the length of the data in bytes.
"						**********OPERATOR(11)**********
sort_release:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	spri3	pr6|74		store the data pointer
	stq	pr6|76		store the length of the data
"						RTS(4)
	lda	4,dl		store the rts_code
	sta	pr6|rts_code
	epp0	return_from_sort_release	set the return_ptr to special location
	spri0	pr6|stack_frame.return_ptr
	tra	call_rts_from_op
	even
return_from_sort_release:
	szn	pr6|80		check the status code
	tze	sort_good		return to good sort label
	lda	52,dl		lda the error code and store
	sta	pr6|89
	tra	cobol_error_53
"
"
"						**********OPERATOR(13)**********
"
"		14 words in stack are needed
"
sort_return:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
"						RTS(5)
	lda	5,dl		load the rts_code
	sta	pr6|rts_code
	epp0	return_from_sort_return		lda the error code and store
	spri0	pr6|stack_frame.return_ptr
	tra	call_rts_from_op
"
"
	even
return_from_sort_return:
	lda	pr6|80		check the status code
	tze	sort_good		return to good sort label
	lda	53,dl		load the error code
	sta	pr6|89
	tra	cobol_error_53
"
"
"
"
"	The operator for the sort initiate.
"	 It needs the following parameters:
"		pr3 for compare entry ptr
"		pr7 for sort_$noexit
"		x2 for the stack offset
"		14 word are used to set up parameter list for soit exit.
"
"						**********OPERATOR(14)**********
sort_initiate:
sort_exit:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	cmpx2	0,du		check same sort merge possibility
	tpl	5,ic
	epp0	pr6|pr4_save,*
	stx2	pr0|41		complement x2
	lcx2	pr0|41
	stz	pr0|41		for sort
	spri3	pr6|2,2		store the compare entry
	ldaq	null_con
	staq	pr6|4,2
	stz	pr6|0,2		store 1 in the version number
	aos	pr6|0,2
	epp3	pr6|0,2		get pointer for the exit ptr
"
sort_initiate_call:
	spri3	pr6|74		store the exit_ptr into  the argument
	epp0	return_from_sort_init	set the return_ptr to special location
	spri0	pr6|stack_frame.return_ptr
"						RTS(3)
	lda	3,dl		load the rts_code
	sta	pr6|rts_code
	epp0	pr6|pr4_save,*
	epp0	pr0|control_ptr,*
	spri0	pr6|76
	tra	call_rts_from_op
	even
return_from_sort_init:
	szn	pr6|80		check the status code
	tze	sort_good		return to good sort label
	lda	55,dl		lda the error code and store
	sta	pr6|89
	tra	cobol_error_53

"
"
"	For good sort result, skip the retry instruction.
"
sort_good:
	lda	1,du
	asa	pr6|return_to_main_off
	tra	return_to_reset
"
"
"	Establish the cleanup handler for sort.
"	The cobol_rts_handler_ is called to call sort_$terminate.
"
"						**********OPERATOR(16)**********
establish_cleanup:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	epp1	pr6|text_base_ptr,*0		get the return location
	lda	=o100,dl		check the condition bit
	cana	pr6|stack_frame.condition_word
	tnz	3,ic		some conditions are on
	stz	pr6|stack_frame.on_unit_rel_ptrs		zero out the condition offset
	orsa	pr6|stack_frame.condition_word		set the condition bit
	ldx0	pr6|stack_frame.on_unit_rel_ptrs		get the last condition
	tze	4,ic		no condition
	ldx1	pr6|stack_frame.on_unit_rel_ptrs		get the last condition
	adx1	10,ic		10 words for the last condition
	tra	2,ic
	ldx1	118,du		it is the 1st cond. Put it in pr6|118
	stx0	pr6|on_unit.next,1		reset this as the last cond
	stx1	pr6|stack_frame.on_unit_rel_ptrs
	epp2	sort_con+1		store the name cleanup
	spri2	pr6|on_unit.name,1
	epp4	pr6|pr4_save,*		load pr4
	epp3	pr4|control_ptr,*		get control_seg
	epp3	pr3|46,*		get cobol_rts_handler_
	spri3	pr6|on_unit.body,1		store into the condition body
	lda	7,dl		store the length
	sta	pr6|on_unit.size,1
	lxl0	0,dl		no  flag
	sxl0	pr6|on_unit.flags,1
	tra	return_cond
"
"	The operator for calling the sort_$terminate
"
"						**********OPERATOR(17)**********
sort_terminate:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	stz	pr6|74		zero out the status code. It is needed, unfortunately
"						RTS(6)
	lda	6,dl		load the rts_code
	sta	pr6|rts_code
	epp0	return_from_sort_term	set the return_ptr to special location
	spri0	pr6|stack_frame.return_ptr
	tra	call_rts_from_op
	even
return_from_sort_term:
	lda	pr6|74		check the status code
	tze	return_to_reset
	sta	pr6|80
	lda	54,dl		lda the error code and store
	sta	pr6|89
	tra	return_from_term
"
"
"	The operator for reverting the cleanup condition.
"
"						**********OPERATOR(18)**********
revert_cleanup:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	epp1	pr6|text_base_ptr,*0		store the return_ptr in pr1
	epbp7	pr6|0		pr7 for stack header
	epp0	pr6|118		first condition start from pr6|118
	epp2	sort_con+1		get the cleanup  character string
	eax6	7		7 characters
	tsx7	find_unit
"		unit found null out the current condition
	stz	pr6|on_unit.size,1		start searching
	ldaq	null_con
	staq	pr6|on_unit.name,1
	staq	pr6|on_unit.body,1
"		If this is the first unit then reset pr6|stack_frame.on_unit_rel_ptrs
	eaa	0,1
	cmpa	pr6|stack_frame.on_unit_rel_ptrs
	tnz	return_cond
	ldx1	pr6|on_unit.next,1
	stx1	pr6|stack_frame.on_unit_rel_ptrs
"		restore pr0, pr3 and pr4
return_cond:
	epp0	pr6|stack_frame.operator_ptr,*
	epp4	pr6|linkage_ptr,*
	epp3	pr6|pr3_save,*
	tra	pr1|0
"	This subroutine tries to find the unit for the given condition.

find_unit:
	lda	stack_frame.condition_bit,dl		make sure this is a condition stack
	cana	sp|stack_frame.condition_word		..
	tnz	get_length			..
	stz	sp|stack_frame.on_unit_rel_ptrs	..
	orsa	sp|stack_frame.condition_word		..
get_length:
	eaa	0,6		get length of name in chars
	tze	return_cond		if zero then done
	lrs	20		convert to words
	eax6	0,al		place number of words in x6
	qrl	16		get extra chars
	eax5	1,qu		place extra chars in x5
previous_char:
	eax5	-1,5		reduce chars by 1
	tnz	next_word		have we gone over word boundary
	eax6	-1,6		if so reduce number of words
	tmi	return_cond		name of all blanks
	eax5	4		have four chars in new word
next_word:
	lda	bp|0,6		get word and check for blanks
	ldq	masks1-1,5	..
	cmk	blanks		..
	tze	previous_char	if blank reduce length by 1
	ldx1	sp|stack_frame.on_unit_rel_ptrs	get offset of first on unit
	tra	next_length	..
next_on_unit:
	ldx1	sp|on_unit.next,1	get offset of next on unit
next_length:
	tze	return_cond	cannot find unit
	eaa	0,6		compute length of name
	ars	16		..
	ada	char_count-1,5	..
	cmpa	sp|on_unit.size,1	are names the same length
	tnz	next_on_unit	if not go to next on unit
	epplp	sp|on_unit.name,1*	get pointer to name for this unit
	lda	bp|0,6		compare extra chars
	ldq	masks2-1,5	..
	cmk	lp|0,6		..
	tnz	next_on_unit	no match, try next
	eax4	0,6		compare rest of name
compare_next_word:
	eax4	-1,4		..
	tmi	0,7		match, we are done
	lda	bp|0,4		..
	cmpa	lp|0,4		..
	tze	compare_next_word	..
	tra	next_on_unit	no match, try next

blanks:	aci	"    "		word of blanks
masks1:	oct	000777777777	masks for lookin at individual chars
	oct	777000777777
	oct	777777000777
	oct	777777777000
masks2:	oct	000777777777	masks for comparing strings
	oct	000000777777
	oct	000000000777
	oct	000000000000
char_count:
	oct	1		number of chars in last word
	oct	2
	oct	3
	oct	4

"
"
"	This operator is called from sort_gen to set up parameter for compare
"	procedure.
"
"						**********OPERATOR(19)**********
sort_comp:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	epp7	pr6|stack_frame.arg_ptr,*		get the argument pointer
	epp2	pr7|4,*		pr2 for second operand
	epp1	pr7|2,*		pr1 for first operand
	epp2	pr2|0,*
	epp1	pr1|0,*
	stz	pr7|6,*		prestore  0 for equal compare
	tra	pr6|text_base_ptr,*0
"
"
"	The operator for calling the pl1 operator real_to_real.
"	This operator is used for exponential computation.
"
"
"						**********OPERATOR(15)**********
real_to_real:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	epp0	cobol_operators_	reset text_base_ptr to cobol_operators_
	spri0	pr6|text_base_ptr
	epbp0	pr6|0
	epp0	pr0|28,*
	eax0	return_from_pl1_op		rest  x0 befor transfer to pl1_operators_
	tra	pr0|684
"
"

"	****************************************
"
"	This page is for merge statement interface
"
"	****************************************
"
"	merge_init				**********OPERATOR(60)**********
"
"	Input:	x2	for merge stack offset
"		x3	for no of using files
"		pr3	for compare entry
merge_init:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	cmpx2	0,du		check same sort merge possibility
	tpl	4,ic
	epp0	pr6|pr4_save,*
	stx2	pr0|41		complement x2
	lcx2	pr0|41
	stz	pr6|80
	sxl2	pr6|80		merge stack offset
	stz	pr6|81
	sxl3	pr6|81		no of using files
	epp2	pr6|0,2		stack_off loaction
	spri2	pr6|82
	eaq	0,3
	qls	1		multiply by 2 and put into Q upper
	epp2	pr2|0,qu		tree loaction
	spri2	pr6|84
	epp2	pr2|0,qu		compare entry loaction
	spri2	pr6|86
	epp0	pr6|pr4_save,*
	epp0	pr0|control_ptr,*	get controlp for temp dir
	spri0	pr6|88
	spri3	pr2|0		strore the compare entry
	ldaq	null_con
	staq	pr2|2
	lda	30,dl
	tra	call_rts_load_code
"
"	merge_comp				**********OPERATOR(61)**********
"
"	Input:	none
"
merge_comp:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	lda	31,dl
	tra	call_rts_load_code
"
"
"	merge_return				**********OPERATOR(62)**********
"
"Input:	none
"
merge_return:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	lda	32,dl
	tra	call_rts_load_code
"

"					**********OPERATOR(24)**********
"	This page is for communication interface.
"
"	****************************************
"
"					**********OPERATOR(70)**********
receive_comm:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	lda	40,dl
	tra	call_rts_load_code
"
"					**********OPERATOR(71)**********
accept_comm:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	lda	41,dl
	tra	call_rts_load_code
"
"					**********OPERATOR(72)**********
purge_comm:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	lda	42,dl
	tra	call_rts_load_code
"
"					**********OPERATOR(73)**********
send_comm:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	lda	43,dl
	tra	call_rts_load_code
"
"					**********OPERATOR(74)**********
enable_comm:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	lda	44,dl
	tra	call_rts_load_code
"
"						**********OPERATOR(75)**********
disable_comm:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	lda	45,dl
	tra	call_rts_load_code
"

"	****************************************

"
"	This page is for low used general operators.
"
"	****************************************

"
"
"
"
"
"	The operator for managing the files within OPEN and CLOSE.
"		X5 set to  2*no_of_files
"		X6 set to  2*file_no
"
"
"						**********OPERATOR(24)**********
set_lin_file_status:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	stz	pr6|46		zero work area
	aos	pr6|46		set init linage counter to 1.
	btd	(pr),(pr)
	desc9a	pr6|46,4
	desc9ns	pr1|88,6,0
	lda	pr1|94		get TOP value
	mlr	(ic),(pr,rl),fill(012)
	desc9a	-1,0
	desc9a	pr5|0,al
	sta	pr6|80		set length value
	stx6	pr6|x6_save		[3.0-1]
	tsx6	pr0|subr_put_chars		[3.0-1]
	ldx6	pr6|x6_save		[3.0-1]
	epp1	pr6|86,*
	epp3	pr6|pr3_save,*
"
"				**********OPERATOR(25)**********
"
"
set_file_status:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	epp4	pr6|pr4_save,*	load static data pointer
	ldaq	pr4|file_info_ptr
	eraq	null_con
	anaq	mask_con
	tnz	19,ic
	epp2	pr4|control_ptr,*
	adwp2	100000,du
	szn	pr2|0
	tnz	4,ic
	spri2	pr2|0
	lda	2,du
	asa	pr2|1
	ldaq	pr2|0
	staq	pr4|file_info_ptr
	ldx4 	2,du
	asx4 	pr2|1
	asx5	pr2|1
	epp2	pr4|file_info_ptr,*
	sxl5	pr2|0
	ldaq	null_con
	staq	pr2|0,5
	sbx5	2,du
	tnz	-2,ic
	epp2	pr4|file_info_ptr,*
	spri1	pr2|0,6
	epp4	pr6|linkage_ptr,*
	tra	pr6|text_base_ptr,*0

"
"
"
"				**********OPERATOR(27)**********
"	This operator handles the FILE CLOSE and DETACH.
"
"
close_file:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	spri1	pr6|86		store iocb ptr
	tsx6	pr0|subr_close_file
	tra	return_to_reset
"[3.0-1]
"[3.0-1]	alt_close_file		**********OPERATOR(89)**********
"[3.0-1]
"[3.0-1]
alt_close_file:
	inhibit on
	stx0 pr6|return_to_main_off
	inhibit off
"
	spri7 pr6|80				set file desc ptr
"
	lda 47,dl					RTS(47)
	sta pr6|rts_code				set fields in FSB
	epp0 return_from_alt_close
	spri0 pr6|stack_frame.return_ptr
	tra call_rts_from_op
"
return_from_alt_close:
	tra return_to_reset
"
"
"				**********OPERATOR(38)**********
"	This operator handles the FILE CLOSE only NO detach
"
"
close_file_only:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	spri1	pr6|86
	tsx6	pr0|subr_close_file_only
	epp1	pr6|86,*		reset pr 1 to fsb
	stz	pr1|2		reset open mode
	tra	return_to_reset
"
"
"
"				**********OPERATOR(43)**********
"	This operator is for stop literal code to call cu_$cl
"
stop_literal:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
"						RTS(8)
	lda	8,dl
	sta	pr6|rts_code
	tra	call_rts_from_op
"
"				**********OPERATOR(48)**********
"	This operator is for "stop run" code to call cobol_stoprun_
"
stop_run:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	epp4	pr6|pr4_save,*	load pr4
	staq	pr4|36		store the line number
"						RTS(9)
	lda	9,dl		load the rts_code
	sta	pr6|rts_code
	tra	call_rts_from_op
"
"				**********OPERATOR(94)**********	[4.4-3]
"	This operator is for "stop run" code to call cobol_stoprun_ if CD INITIAL used
"
stop_cd_run:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit off
	epp4	pr6|pr4_save,*	load pr4
	staq	pr4|36		save the line number
"						RTS(62)
	lda	62,dl		load the rts code
	sta	pr6|rts_code
	tra	call_rts_from_op
"
"
"	the cancel operator  used to call cobol_cantrol_$cancel.
"
"						**********OPERATOR(49)**********
cancel:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	spri3	pr6|74		store the name
	sta	pr6|76		store the name length
"						RTS(10)
	lda	10,dl		load the rts_code
	sta	pr6|rts_code
	tra	call_rts_from_op
"
"	The operator for calling cobol_su_$tally and cobol_su_$replace.
"
"						**********OPERATOR(51)**********
inspect_replace:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	lda	24,dl
	tra	3,ic
"
"						**********OPERATOR(50)**********
"
inspect_tally:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
"						RTS(23)
	lda	23,dl
	spri2	pr6|74		load tally pointer
	sta	pr6|rts_code	load the rts_code
	tra	call_rts_from_op
"
"						**********OPERATOR(12)**********
"
"
"				**********OPERATOR(77)**********
"	The operator for initialize cd token	(77)
"
init_cd:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	epp2	pr6|26,*
	ldx1	pr2|0
	tze	init_cd_space
	epp2	pr2|0,1*
	mlr	(pr),(pr)
	desc9a	pr2|0,48
	desc9a	pr1|0,48
	tra	pr6|text_base_ptr,*0
init_cd_space:
	mlr	(0),(pr),fill(040)
	desc9a	0,0
	desc9a	pr1|0,48
	tra	pr6|text_base_ptr,*0
"
"
"
"	The operator for the runtime_check option.
"
pack_mask:
	oct	775777777777
desc_mask:
	oct	000000100000
runtime_check:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	epp5	pr6|stack_frame.arg_ptr,*	get arg_ptr from the caller
	epp3	pr6|stack_frame.entry_ptr,*	get the stack_frame.entry for the callee
	stz	pr6|mcode			set the status code to 0.
	epp0	pr6|text_base_ptr,*		load the text_base into pr0
	lda	pr3|-1
	ana	desc_mask		check the descriptor bit
	tnz	3,ic
	ldx3	0,du
	tra	4,ic
	ldx1	pr3|-2			get the descr_relp_offset
	ldx3	pr0|0,1			obtain the number of arguments
	tnz	4,ic			there are arguments
	cmpx3	pr5|0			check caller
	tze	return_from_call		both have no argument
	tra	n_args_error		caller has some arguments, call error routine
	adx3	pr0|0,1			double x3 to get 2*n_args
	cmpx3	pr5|0			compare n_args with the caller's
	tze	3,ic			n_args equal, passed the first check
n_args_error:
	lxl7	4155,dl			load the error_code
	tra	cobol_error
	ldx2	pr5|1			load the desc_count
	cmpx2	0,du			Is there descriptor?
	tnz	2,ic			yes. check descriptors.
	tra	return_from_call		no. restore registers and back
	epp2	pr6|descriptor_ptr,*	load descriptor_ptr for the caller
	epp3	pr0|0,1			find parm_desc_ptr for the caller
	stx2	pr6|74
	ldx5	0,du			initialization for the loop
	ldx2	0,du
	ldx7	0,du
loop_compare:
	cmpx7	0,du
	tnz	upper_half
	lxl1	pr3|0,5
	tra	desc_join
upper_half:
	adx5	1,du			next desc_relp in next word
	ldx1	pr3|0,5			obtain the next desc_relp for the caller
desc_join:
	epp1	pr0|0,1
	epp5	pr2|0,2*
	lxl3	pr1|-1
desc_loop:
	sbx3	1,du
	tmi	desc_exit
	lda	pr1|0,3
	ana	pack_mask
	sta	pr6|75
	lda	pr5|0,3
	ana	pack_mask
	cmpa	pr6|75
	tnz	desc_error		not equal, call cobol_error_
	tra	desc_loop
desc_exit:
	adx2	2,du			yes. get the next one
	cmpx2	pr6|74			more descriptor?
	tpl	return_from_call		no. back to main procedure
	adx7	1,du
	anx7	1,du
	tra	loop_compare		back to loop
desc_error:
	ldx7	4156,du			load the error_code
	tra	cobol_error		call cobol_error_
"
"

"
"
"	open_ext_file				**********OPERATOR(30)**********
"
"
open_ext_file:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	lda	pr1|90		if file LOCKed then don't OPEN.
	ana	8192,du
	tze	cont_open_ext
"		set status
	lda 	io30_con
	ldq	s1090con
	staq	pr6|status12
	ldx1	62,du		Attempt to OPEN a file closed with the LOCK option.
	adx0	1,du		force skip over tra instr
	tra	return_thru_text_base_pone
cont_open_ext:
	sta 	pr6|55		temp save A reg value
	lda	pr1|2
	tmoz	pr6|text_base_ptr,*0 minus or zero cont processing
	cmpa	pr6|55		do the cobol modes match
	tze	return_thru_text_base_pone YES
"		set status
	lda	io30_con
	ldq	s1032con
	staq	pr6|status12
	ldx1	8,du	attempt to open ext file already opened in inconsistent mode.
	adx0	1,du		force skip over tra instruction
return_thru_text_base_pone:
	adx0	1,du		skip one instruction
	tra	pr6|text_base_ptr,*0
"
"
"	open_int_file cobol 				**********OPERATOR(31)**********
"
"
open_int_file:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	lda	pr1|90		if file LOCKed then don't OPEN.
	ana	8192,du
	tze	cont_open_int
"		set status
	lda 	io30_con
	ldq	s1090con
	staq	pr6|status12
	ldx1	62,du		Attempt to OPEN a file closed with the LOCK option.
	tra	return_thru_text_base_pone
cont_open_int:
	szn	pr1|2
	tze	pr6|text_base_ptr,*0
"		set status
	lda	io30_con
	ldq	s1036con
	staq	pr6|status12
	ldx1	9,du		attempt to open int file already opened.
	tra 	return_thru_text_base_pone
"
"
"	find_iocb cobol 				**********OPERATOR(32)**********
"		A reg = length of switch name
"		X5 = stack offset value for ioname
"
"
find_iocb:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	spri6	pr6|48		store stack_offset ptr for ioname
	spri6	pr6|50
	adx5	pr6|49		add base offset to x5
	stx5	pr6|49		set correct offset
	adx5	2,du
	stx5	pr6|51
	spri1	pr6|86		store pr1
	spri1	pr6|48,*		store fsb pointer
	sta	pr6|50,*		store switch length
	epp2	pr6|40
	spri2	pr6|76		store mcode_ptr
"
	lda	14,dl		RTS(14)
	sta	pr6|rts_code	store rts_code
	epp0	return_find_iocb
	spri0	pr6|stack_frame.return_ptr
	tra	call_rts_from_op	iox_find_iocb
return_find_iocb:
	szn	pr6|40
	tze	return_to_reset
"		set status
	lda	io30_con
	ldq	s1193con
	staq	pr6|status12
	ldx1	7,du		unable to establish iocb
	tra	io_return_to_reset
"
"	check_attach cobol 				**********OPERATOR(33)**********
"
check_attach:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	epp1	pr6|86,*		reset pr1
	epp2	pr1|0,*
	ldaq	pr2|12
	eraq	null_con
	anaq	mask_con
"   [4.0-1]   The following 7 lines are used to set a bit in the fsb if the
"    file is already attched otherwise the bit is zero
          tnz       4,ic     transfer if already attached
          lda	atd_con     load zeroes
	stba	pr1|87,20     store a byte of a into fsb
	tra	return_thru_text_base_pone
	lda	=o000400000000   load bit to be set
	stba	pr1|87,20     store the set byte of a ino fsb
	tnz	pr6|text_base_ptr,*0

"
"
"	close_op_file cobol 				**********OPERATOR(29)**********
"
"
close_op_file:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	staq	pr6|44		save open mode & optional/opened bit
	stz	pr6|46
	sxl5	pr6|46		store open mode(multics_mode)
	epp1	pr6|86,*
	tsx6	pr0|subr_close_file_only
	epp1	pr6|86,*
	tsx6	pr0|subr_open_file
	tra	open_ok
"
"
"	attach_iocb cobol_				**********OPERATOR(34)**********
"		A reg = length of attach description
"		X5 = stack offset value for atd
"
"
attach_iocb:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	epp1	pr6|86,*
	spri6	pr6|48		store stack offset for atd
	adx5	pr6|49
	stx5	pr6|49
	adx5	2,du
	stx5	pr6|51
	sta	pr6|50,*		store atd length
	epp2	pr6|40
	spri2	pr6|76		store mcode_ptr
"						RTS(15)
	lda	15,dl
	sta	pr6|rts_code	store rts_code
	epp0	return_attach_iocb
	spri0	pr6|stack_frame.return_ptr
	tra	call_rts_from_op  	iox_$attach_iocb
	even
return_attach_iocb:
	szn	pr6|40
	tze	return_to_reset
"	set status
	lda	io30_con
	ldq	s1293con
	staq	pr6|status12
	ldx1	13,du		unable to attach IO switch.
	tra	io_return_to_reset
"
"	open_file cobol 				**********OPERATOR(35)**********
"		A reg = open mode
"
open_file:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	spri1	pr6|86
	staq	pr6|44		save open mode & optional/opened bit
	stz	pr6|46
	sxl5	pr6|46		store open mode(multics_mode)
	lda	pr1|90		 if file LOCKed then don't open , return
	tsx6	pr0|subr_open_file
	tra	open_ok
"[3.0-1]
"[3.0-1]	alt_open_file	**********OPERATOR 78**********
"[3.0-1]
"[3.0-1]
alt_open_file:
	inhibit on
	stx0 pr6|return_to_main_off
	inhibit off
"
	spri7 pr6|80			set file desc ptr
	epp7 pr6|mcode				mcode_ptr
	spri7 pr6|76
	lda pr6|44			move cobol_open_mode to rts_ stack frame
	sta pr6|82
	lda pr6|46			move vfile_open_mode to rts_ stack frame
	sta pr6|84
"
	lda 46,dl				RTS(46)
	sta pr6|rts_code			set fields in FSB
	epp0 return_from_alt_open
	spri0 pr6|stack_frame.return_ptr
	tra call_rts_from_op
"
return_from_alt_open:
	tra return_to_reset
"
"
"						**********OPERATOR(36)**********
"	open close op  no. 36
"		A reg = open mode
"
"
open_close_file:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	lda	9,dl					[3.0-1]
	sta	pr6|46					[3.0-1]
	spri1	pr6|74		iocb_ptr
	spri1	pr6|86			fsb_ptr
	tsx6	pr0|subr_open_file
	epp1	pr6|86,*
	tsx6	pr0|subr_close_file_only
	tra	return_to_reset
"
"				**********OPERATOR(37)**********
"	check non cobol no. 37
"
"
check_file:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	epp1	pr6|86,*		reset pr1
	epp2 	pr1|0,*
	ldaq	pr2|16		iocb, open_descrip_ptr
	eraq	null_con
	anaq	mask_con
	tze	return_thru_text_base_pone fall though to OPEN
	lda	-1,du		noncobol open status
	sta	pr1|2		set fsb open mode
	tra	pr6|text_base_ptr,*0
"
"
"    SUBROUTINE to open files
"
"
subr_open_file:
	stx6	pr6|subr_return_save_off  save return offset within operators
	epp2	pr6|46
	spri2	pr6|88		store pointer to open mode
	stz	pr6|47
	epp2	pr6|47
	spri2	pr6|90		unused
	epp2	pr6|40
	spri2	pr6|76		mcode_ptr
	spri2	pr6|92		store pointer to mcode
	eax1	pr6|84
	fld	8192,dl		4 args
	epp2	pr1|0,*		indirect thru fsb to iocb
	epp2	pr2|26		offset for iox_$open
	epp0	return_from_open
	spri0	pr6|stack_frame.return_ptr
	tra	call_ent_var_from_op
return_from_open:
	epp4	pr6|linkage_ptr,*
	szn	pr6|40
	tze	pr6|subr_return_save,* EXIT FROM SUBROUTINE
	epp1	pr6|86,*
	stz	pr1|2
"	check if optional bit is on
	lda	pr6|45
	cmpa	optional_int
	tze	pr6|subr_return_save,* EXIT FROM SUBR
	cmpa	optional_ext
	tze	pr6|subr_return_save,* EXIT FROM SUBR
"		set status				RTS(13)
	lda	13,dl
	sta	pr6|rts_code 	store rts(13) call
	ldx1	15,du		set open error code
	epp0	return_from_open_rts
	spri0	pr6|stack_frame.return_ptr	exit to main line +1
	tra 	call_rts_from_op
return_from_open_rts:
	epp4	pr6|linkage_ptr,*	reset_linkage pointer
	ldx1	15,du
	ldq	s1295con
	cmpq	pr6|status12
	tnz	io_return_to_reset
	tra	pr6|subr_return_save,* EXIT FROM SUBROUTINE
open_ok:
	epp1	pr6|86,*		reset pr 1
	szn	pr6|40
	tze	set_open_mode
	lda	pr6|45
	cmpa	optional_int
	tze 	skip_open_mode
	cmpa	optional_ext
	tze	skip_open_mode
set_open_mode:
	lda	pr6|44
	sta	pr1|2		cobol open mode
skip_open_mode:
	epp4	pr6|pr4_save,*		load pr4
	lxl5	pr4|18		length of program name
	mlr	(pr,rl),(pr),fill(040)
	desc9a	pr4|19,x5		set name
	desc9a	pr1|71,65
	stz	pr1|6		set fsb.relkeylen to zero
	mlr	(pr),(pr),fill(060)	reset key on each open
	desc9a	0,0
	desc9a	pr1|7,16
	ldx5	high_con,du	set optional bit
	ansx5	pr1|90
	ldx5	pr6|45		set how opened bit 100000=ext 140000=int
	orsx5	pr1|90		opened bit
	tra	return_to_reset
"
"
"    SUBROUTINE to close files
"
"
subr_close_file:
	stx6	pr6|subr_return_save_off
	epp2	pr6|mcode					[5.1-1]
	spri2	pr6|88		store ptr to mcode_ptr	[5.1-1]
	spri2	pr6|76		mcode_ptr			[5.1-1]
"	check if optional bit is on
	lda	pr1|90
	cmpa	optional_int
	tze	check_if_open
	cmpa	optional_ext
	tnz	3,ic
check_if_open:
	szn	pr1|2
	tze	close_ok
	szn	pr6|retrycode		op retry code
	tnz	detach_op	
	szn	pr1|2
	tmi	detach_op		syn attachment don't close
	tnz	close_file_begin
"		set status 1,2,3	handle unopen error
	lda	io30_con
	ldq	s2036con
	staq	pr6|status12
	ldx1	17,du		set unopened error code to X1
	tra	io_return_to_reset
"	This section handles the close.
close_file_begin:
	eax1	pr6|84		argument list offset
	fld	4096,dl		2 args
	epp2	pr1|0,*		indirect thru fsb to iocb
	epp2	pr2|30		offset for close
	epp0	return_from_io_close
	spri0	pr6|stack_frame.return_ptr		adjust return from call_rts
	tra	call_ent_var_from_op	iox_$close
	even
return_from_io_close:
	epp4	pr6|linkage_ptr,*		reset linkage pointer
	szn	pr6|mcode
	tze	close_ok	
	lda	12,dl
	sta	pr6|rts_code		store rts_code
"						RTS(18)
	ldx1	18,du		set close error code to X1
	epp0	io_return_to_reset	exit to main line +1
	spri0	pr6|stack_frame.return_ptr
	tra	call_rts_from_op	handle close error
"	This section handles the detach after a close.
close_ok:
	epp1	pr6|86,*		reset pr1 with fsb_ptr
	stz	pr1|2
detach_op:
	lda	pr1|87   load bit to see if file was previously attached
	ana	=o000400000000     isolate bit
	tnz	pr6|subr_return_save,*    do not detach if file was previously attached
	lda	space_con
	cmpa	pr1|71		is attach name spaces
	tze	pr6|subr_return_save,*	yes, then NO DETACH SUBR EXIT
	epp4	pr6|pr4_save,*		load pr4
	cmpc	(pr),(pr),fill(000)	attach name to program name
	desc9a	pr1|71,65
	desc9a	pr4|19,65
	tnz	pr6|subr_return_save,*	don't detach names differ SUBR EXIT
	eax1	pr6|84
	fld	4096,dl		2 args
	epp2	pr1|0,*
	epp2	pr2|22		offset for detach_iocb
	epp0	return_from_io_detach
	spri0	pr6|stack_frame.return_ptr
	tra	call_ent_var_from_op	iox_$detach
	even
return_from_io_detach:
	szn	pr6|mcode
	tze 	detach_ok
"		set status 1,2,3	handle detach error
	aos	pr6|retrycode		set retry code to close complete
	lda	io30_con
	ldq	s2393con
	staq	pr6|status12
	ldx1	19,du		set detach error code to X1
	tra	io_return_to_reset
detach_ok:
	epp1	pr6|86,*		reset pr1 with fsb_ptr
	mlr	(pr),(pr),fill(040)	space fill attach name
	desc9a	0,0
	desc9a	pr1|71,65
	tra 	pr6|subr_return_save,* EXIT FROM SUBROUTINE
"
"
"     SUBROUTINE to  close files only, NO detach
"
"
subr_close_file_only:
	stx6	pr6|subr_return_save_off
	epp2	pr6|mcode
	spri2	pr6|88
          szn	pr1|2            [4.1-2]
	tmi	pr6|subr_return_save,*
	eax1	pr6|84		argument list offset
	fld	4096,dl		2 args
	epp2	pr1|0,*		indirect thru fsb to iocb
	epp2	pr2|30		offset for close
	epp0	return_from_io_close_only
	spri0	pr6|stack_frame.return_ptr		adjust return from call_rts
	tra	call_ent_var_from_op	iox_$close
	even
return_from_io_close_only:
	epp4	pr6|linkage_ptr,*		reset linkage pointer
	szn	pr6|mcode
	tze	pr6|subr_return_save,*	
	lda	12,dl
	sta	pr6|rts_code		store rts_code
"						RTS(18)
	ldx1	18,du		set close error code to X1
	epp0	io_return_to_reset	exit to main line +1
	spri0	pr6|stack_frame.return_ptr
	tra	call_rts_from_op	handle close error
"
"
"
"	This operator is for accept the user's word.**********OPERATOR(20)**********
"
accept_line:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	sta	pr6|80		length of the buff
	spri2	pr6|78		buff_ptr
	epp2	pr6|0,5
	spri2	pr6|82		address of the buffer on the stack
	epp2	pr6|40
	spri2	pr6|76		store the mcode_ptr
"						RTS(18)
	lda	18,dl
	sta	pr6|rts_code	for accept in cobol_rts_
	epp0	return_from_accept	preset the return pointer
	spri0	pr6|stack_frame.return_ptr
	tra	call_rts_from_op
	even
return_from_accept:
	szn	pr6|40
	tnz	accept_error	output the error message
	epp2	pr6|78,*		obtain the buff_ptr
	lxl5	pr6|81		load the actual record length
	tze	return_accept	return
	sbx5	1,du		get rid of the new line character
	sxl5	pr6|81		store the actual lengthwith new_line off
	lda	pr6|80		load the buffer length
	sba	pr6|81		get the length for the unfilled buffer
	mlr	(),(pr,rl,x5),fill(040)	fill the unfilled area with spaces
	desc9a	0,0
	desc9a	pr2|0,al
return_accept:
	lda	1,du
	asa	pr6|return_to_main_off	skip the retry error instruction
	tra	return_to_reset	return
accept_error:
	lda	6,dl
	sta	pr6|89		store the cobol error code
	tra	cobol_error_from_op	join the common error label to output the error message
"
"
"				**********OPERATOR(44)**********
"	This operator is for the use of "accept <id> from date.
"
"
accept_date:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
"						RTS(22)
	lda	22,dl
	sta	pr6|rts_code	save the rts_code
	tra	call_rts_from_op
"
"
"				**********OPERATOR(45)**********
"	This operator is for "accept <id> from day".
"
accept_day:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	epp0	return_from_day	reset the retunr point
	spri0	pr6|stack_frame.return_ptr
"						RTS(20)
	lda	20,dl
	sta	pr6|rts_code	save the rts_code
	tra	call_rts_from_op
	even
return_from_day:
	btd	(pr),(pr)
	desc9a	pr6|86,4
	desc9ns	pr6|80(2),3,0
	btd	(pr),(pr)
	desc9a	pr6|78,4
	desc9ns	pr6|79(2),4,0
	tra	return_to_reset	return
"
"			**********OPERATOR(46)**********
"	This operator is for accept <id> from time.
"
accept_time:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	epp0	return_from_time	reset the return point
	spri0	pr6|stack_frame.return_ptr
	lda	21,dl		load the rts_code
	sta	pr6|rts_code
	tra	call_rts_from_op
	even
return_from_time:
	ldaq	pr6|80		load the time of day(tod)
	dvf	5000,dl
	lrl	36
	div	6000,dl
	sta	pr6|91
	div	60,dl
	sta	pr6|90
	stq	pr6|87
	btd	(pr),(pr)
	desc9a	pr6|87,4
	desc9ns	pr6|88,2,0
	btd	(pr),(pr)
	desc9a	pr6|90,4
	desc9ns	pr6|88(2),2,0
	btd	(pr),(pr)
	desc9a	pr6|91,4
	desc9ns	pr6|89,4,0
	tra	return_to_reset
"
"			**********OPERATOR(47)**********
"	This operator is for accepr <id> from day of week.
"
accept_day_of_week:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	epp0	return_from_dow
	spri0	pr6|stack_frame.return_ptr	reset return pointer
"						RTS(21)
	lda	21,dl
	sta	pr6|rts_code
	tra	call_rts_from_op
	even
return_from_dow:
	lda	pr6|82		load the day of the week
	als	27		convert to decimal
	ora	24576,du
	sta	pr6|82	store the converted decimal back
	tra	return_to_reset	return
"
"
"	init_delete check file condition	**********OPERATOR(56)**********
"
"
init_delete:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	spri1	pr6|86		set fsb_ptr
	stz	pr6|icode			 each entry to zero
	szn	pr1|2		is file opened
	tnz	pr6|text_base_ptr,*0	YES,
"	set status
	lda	io30_con
	ldq	s7031con
	staq	pr6|status12
	ldx1	24,du		attempt to perform io on an unopened file
	tra	return_thru_text_base_pone
"
"
"	delete_error	**********OPERATOR(54)**********
"		X5 = error number for RTS interface
"
delete_error:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	sxl5	pr6|45		io_error_no
"						RTS(16)
	lda	16,dl
	sta	pr6|rts_code	store rts_code
	tra	call_rts_from_op
"
"			**********OPERATOR(55)**********
"	read_key		call iox_$read_key
"		A = offset for TEMP key storage
"		1st word = length of saved key
"		remainder = actual key
"
"
read_key:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	spri1	pr6|86		set iocb_ptr
	spri1	pr6|74		iocb_ptr
	spri6	pr6|52		get any pointer value in area
	ada	pr6|53
	sta 	pr6|53		insert correct value in pointer offset
	epp2	pr6|52,*		point to TEMP area
	spri2	pr6|90		store pointer to key length
	adwp2	1,du
read_delete_join:
	spri2	pr6|88		store pointer to key area
	epp2	pr6|mcode
	spri2	pr6|92		store pointer to mcode
	spri2	pr6|76		mcode_ptr
	eax1	pr6|84
	fld	8192,dl		4 args
	epp2	pr1|0,*
	epp2	pr2|78		offset for iox_$read_key
	epp0	return_read_key
	spri0	pr6|stack_frame.return_ptr
	tra	call_ent_var_from_op
	even
return_read_key:
	stz	pr6|83		set read_key_eof to zero
	szn	pr6|mcode
	tze	return_to_reset
	epp4	pr6|linkage_ptr,*	reset linkage pointer
	epp2	pr6|mcode
	spri2	pr6|76
"						RTS(17)
	lda	17,dl
	sta	pr6|rts_code	store rts code
	epp0	return_rts_read_key
	spri0	pr6|stack_frame.return_ptr
	tra	call_rts_from_op	handle read key errors
return_rts_read_key:
	szn	pr6|mcode
	tze	return_to_reset
	ldx1	27,du		set read error code
	tra	io_return_to_reset
"
"			**********OPERATOR(69)**********
"
"
read_key_for_read:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	spri1	pr6|86		set fsb_ptr
	spri1	pr6|74		iocb_ptr
	spri6	pr6|52		get any pointer value in area
	ada	pr6|53
	sta 	pr6|53		insert correct value in pointer offset
	epp2	pr6|52,*		point to TEMP area
	spri2	pr6|90		store pointer to key length
	epp2	pr1|7
	spri2	pr6|88		store pointer to key area
	epp2	pr6|mcode
	spri2	pr6|92		store pointer to mcode
	spri2	pr6|76		mcode_ptr
	eax1	pr6|84
	fld	8192,dl		4 args
	epp2	pr1|0,*
	epp2	pr2|78		offset for iox_$read_key
	epp0	return_for_read_key
	spri0	pr6|stack_frame.return_ptr
	tra	call_ent_var_from_op
	even
return_for_read_key:
	szn	pr6|mcode
	tze	return_to_reset
	epp4	pr6|linkage_ptr,*	reset linkage pointer
	epp2	pr6|mcode
	spri2	pr6|76
"						RTS(26)
	lda	26,dl
	sta	pr6|rts_code	store rts code
	epp0	return_rts_for_read_key
	spri0	pr6|stack_frame.return_ptr
	tra	call_rts_from_op	handle read key errors
return_rts_for_read_key:
	ldx1	27,du		set read error code
	tra	io_return_to_reset
"
"			**********OPERATOR(53)**********
"	delete		call iox_$delete_record
"
"
delete:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	spri1	pr6|86		set fsb_ptr
	tsx6	pr0|subr_delete
	szn	pr6|mcode
	tze	return_to_reset
"	set status
	lda	io30_con
	ldq	s7430con
	staq	pr6|status12
	ldx1	30,du		Unable to delete record
	tra	io_return_to_reset
"
"
"	SUBROUTINE  to iox_$delete_record
"
"
subr_delete:
	stx6	pr6|subr_return_save_off
	epp2	pr6|mcode
	spri2	pr6|88		store pointer to mcode
	eax1	pr6|84
	fld	4096,dl		2 args
	epp2	pr1|0,*
	epp2	pr2|70		offset for iox_$delete_record
	epp0	pr6|subr_return_save,* EXIT FROM SUBROUTINE
	spri0	pr6|stack_frame.return_ptr
	tra	call_ent_var_from_op
"
"			**********OPERATOR(57)**********
"	special_delete	seek BUFF, delete, seek TEMP, if EOF position
"
"
special_delete:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	sta	pr6|53		save a for future use
	spri1 	pr6|86		set fsb_ptr
	epp2	pr1|7
	spri2	pr6|88
	epp2	pr6|62		work area not used as seek key returns length
	spri2	pr6|90
"						RTS(25)
	lda	25,dl
	sta	pr6|rts_code	store rts code
	tsx6	pr0|subr_seek_op	from BUFF area
	szn 	pr6|mcode
	tnz	io_return_to_reset
	epp1	pr6|86,*
	tsx6	pr0|subr_delete
	szn 	pr6|mcode
	tze	return_special_delete
"	set status
	lda	io30_con
	ldq	s7430con
	staq	pr6|status12
	ldx1	30,du		Unable to delete record
	tra 	io_return_to_reset
return_special_delete:
	epp1	pr6|86,*
	szn	pr6|83		is read_key_eof set
	tnz	eof_position
	lda	pr6|53		reset A  from previous save
	spri6	pr6|52		set any pointer value in area
	ada	pr6|53
	sta	pr6|53		insert correct value in pointer offset
	epp2	pr6|52,*		point to TEMP area
	spri2	pr6|90		store pointer to key length
	adwp2	1,du		increment pointer offset up by one
	spri2	pr6|88		store pointer to key area
	tsx6	pr0|subr_seek_op	from TEMP area
	tra	return_to_reset		
eof_position:
	stz 	pr6|52
	aos	pr6|52		set to +1
	stz	pr6|53
	epp2	pr6|52
	spri2	pr6|88		store pointer to type = +1
	epp2	pr6|53
	spri2	pr6|90		store pointer  for n = 0
	epp2	pr6|40
	spri2	pr6|92		store pointer to mcode
	eax1	pr6|84
	fld	8192,dl		4args
	epp2	pr1|0,*
	epp2	pr2|50		offset for iox_$position
	epp0	return_to_reset		
	spri0	pr6|stack_frame.return_ptr
	tra	call_ent_var_from_op
"
"
"	special_rewrite	seek and position**********OPERATOR(58)**********
"
"
special_rewrite:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	sta	pr6|53		save offset to key area
	spri1	pr6|86		set fsb_ptr
	spri5	pr6|60		save pr 5 for rewrite
	epp2	pr1|7
	spri2	pr6|88
	epp2	pr6|62		work area not used as seek key returns length
	spri2	pr6|90
"						RTS(25)
	lda	25,dl
	sta	pr6|rts_code	store rts code
	tsx6	pr0|subr_seek_op	from BUFF area
	szn	pr6|mcode
	tnz	io_return_to_reset
	epp1	pr6|86,*
	epp5	pr6|60,*		save area points to buffer area
	tsx6	pr0|subr_write_record
	epp2	pr2|66			offset for iox_$rewrite_record
	epp0	return_special_rewrite
	spri0	pr6|stack_frame.return_ptr
	tra	call_ent_var_from_op
return_special_rewrite:
	epp1	pr6|86,*
	szn	pr6|mcode
	tze	return_special_delete
"					set status
	lda	io30_con
	ldq	s5432con
	staq	pr6|status12
	ldx1	43,du		Attempt to rewrite a file not opened as i-o
	tra	io_return_to_reset
"
"
"	rewrite	**********OPERATOR(59)**********
"
"
rewrite:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	spri1	pr6|86		set fsb_ptr
	tsx6	pr0|subr_write_record
	epp2	pr2|66		offset for iox_$rewrite_record
"						RTS(64)
	lda	64,dl					[5.3-1]
	sta	pr6|rts_code				[5.3-1]
	epp0	return_rewrite_record
	spri0	pr6|stack_frame.return_ptr
	tra	call_rts_from_op				[5.3-1]
return_rewrite_record:
	szn	pr6|mcode
	tze	return_to_reset
"	set status
"	lda	io30_con					[5.3-1]
"	ldq	s5432con					[5.3-1]
"	staq	pr6|status12				[5.3-1]
	ldx1	43,du		Attempt to rewrite a file not opened as i-o
	tra	io_return_to_reset
"
"
"	init_read check file condition	**********OPERATOR(63)**********
"
"
init_read:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	spri1	pr6|86		set fsb_ptr
	stz	pr6|icode		reset on each entry to zero
	stz	pr6|46
	szn	pr1|2		is file open
	tnz	pr6|text_base_ptr,*0  YES,
"	check if optional bit is on perform AT END condition
	lda	pr1|90
	cmpa	optional_int
	tze	read_optional
	cmpa	optional_ext
	tze	read_optional
"	set status
	lda 	io30_con
	ldq	s3031con
	staq	pr6|status12
	ldx1	40,du		attempt to perform io on unopened file
	tra	return_thru_text_base_pone
read_optional:
	lda	io10_con		set status for at end condition
	ldq	s3410con
	staq	pr6|status12
	aos	pr6|icode
	aos	pr6|46
	tra	io_return_to_reset
"
"			**********OPERATOR(64)**********
"	get_line used for cobol_read_gen
"
"
get_line:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	epp1	pr6|86,*		set iocb_ptr
	spri5	pr6|78		store buff_ptr
	epp2	pr6|78
	spri2	pr6|88		store pointer to buff_ptr
	epp2	pr6|80
	spri2	pr6|90		store pointer to buff_len
	stz	pr6|47
	epp2	pr6|47
	spri2	pr6|92	no of bytes read into buffer output
	epp2	pr6|mcode
	spri2	pr6|94		store pointer to mcode
	eax1	pr6|84
	fld	10240,dl		5 args
	epp2	pr1|0,*		indirect thru fsb to iocb
	epp2	pr2|34		offset for iox_$get_line
	epp0	return_get_line
	spri0	pr6|stack_frame.return_ptr
	tra	call_ent_var_from_op 	iox_get_line
	even
return_get_line:
	szn	pr6|mcode
	tze	return_to_reset
	epp4	pr6|linkage_ptr,*
	epp2	pr6|mcode
	spri2	pr6|76
"						RTS(28)
	lda	28,dl
	sta	pr6|rts_code
	epp0	return_read_record_exit
	spri0	pr6|stack_frame.return_ptr
	tra	call_rts_from_op
	even
"[3.0-1]
"[3.0-1]	alt_start			**********OPERATOR(79)**********
"[3.0-1]
"[3.0-1]
"
alt_start:
	inhibit on
	stx0 pr6|return_to_main_off
	inhibit off
"
	spri7 pr6|80					set file descr ptr
"
	lda 48,dl					RTS(48)
	sta pr6|rts_code					set fields in FSB
	epp0 return_from_alt_start
	spri0 pr6|stack_frame.return_ptr
	tra call_rts_from_op
"
return_from_alt_start:
	tra return_to_reset
"
"[3.0-1]
"[3.0-1]	alt_read_next		**********OPERATOR(80)**********
"[3.0-1]
"[3.0-1]
"
alt_read_next:
	inhibit on
	stx0 pr6|return_to_main_off
	inhibit off
"
	spri7 pr6|80					set file descr ptr
"
	lda 49,dl						RTS(49)
	sta pr6|rts_code					set fields in FSB
	epp0 return_from_alt_read
	spri0 pr6|stack_frame.return_ptr
	tra call_rts_from_op
"
return_from_alt_read:
	tra return_to_reset
"
"[3.0-1]
"[3.0-1]	alt_read_record		**********OPERATOR(81)**********
"[3.0-1]
"[3.0-1]
"
alt_read_record:
	inhibit on
	stx0 pr6|return_to_main_off
	inhibit off
"
	spri7 pr6|80					set file descr ptr
"
	lda 50,dl						RTS(50)
	sta pr6|rts_code					set fields in FSB
	epp0 return_from_alt_key
	spri0 pr6|stack_frame.return_ptr
	tra call_rts_from_op
"
return_from_alt_key:
	tra return_to_reset
"
"[3.0-1]
"[3.0-1]	alt_seek_key		**********OPERATOR(82)**********
"[3.0-1]
"[3.0-1]
"
alt_seek_key:
	inhibit on
	stx0 pr6|return_to_main_off
	inhibit off
"
	spri1 pr6|74				loc of file key for start
	spri7 pr6|80				set file descr ptr
	sta pr6|85				store key number
"
	lda 54,dl					RTS(54)
	sta pr6|rts_code				move key in FSB one position
	epp0 return_from_alt_seek			prefix by key number
	spri0 pr6|stack_frame.return_ptr
	tra call_rts_from_op
"
return_from_alt_seek:
	tra return_to_reset
"
"[4.0-3]
"
"
"	iox_$control  perform control order on io switch.**********OPERATOR(83)**********
"
"
alt_start_control:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	epp1	pr6|86,*		set iocb_ptr
	spri6	pr6|48		store stack_offset ptr for order name
	spri6	pr6|50
	adx5	pr6|49		add base offset to x5
	stx5	pr6|49		set correct offset
	adx5	2,du
	stx5	pr6|51
	spri1	pr6|48,*		store fsb pointer
	epp2	pr6|50,*
	adwp2	2,du
	spri2	pr6|50,*		store control pointer
	epp2	pr6|mcode
	spri2	pr6|76		store mcode_ptr
	lda	60,dl		RTS(60)
	sta	pr6|rts_code
	epp0	return_alt_start_control
	spri0	pr6|stack_frame.return_ptr
	tra	call_rts_from_op	iox_control
return_alt_start_control:
	szn	pr6|mcode
	tze	return_to_reset
"	set status
	ldx1	38,du		unable to start a file with specified key
	tra	io_return_to_reset
"
"[3.0-1]
"[3.0-1]	alt_read_key		**********OPERATOR(84)**********
"[3.0-1]
"[3.0-1]
"
alt_read_key:
	inhibit on
	stx0 pr6|return_to_main_off
	inhibit off
"
	spri1 pr6|74					loc of file key
	spri7 pr6|80					set file descr ptr
	sta pr6|85					store key number
"
	lda 59,dl						RTS(59)
	sta pr6|rts_code
"
	epp0 return_from_alt_read_key
	spri0 pr6|stack_frame.return_ptr
	tra call_rts_from_op
"
return_from_alt_read_key:
	tra return_to_reset
"[3.0-1]
"[3.0-1]	alt_special_delete		**********OPERATOR(85)**********
"[3.0-1]
"[3.0-1]
"
alt_special_delete:
	inhibit on
	stx0 pr6|return_to_main_off
	inhibit off
"
	spri1 pr6|74				loc of file key [4.4-2]
	lda pr6|80				save rec length
	sta pr6|100
	spri7 pr6|80				set file descr ptr
	epp7 pr6|mcode				mcode_ptr
	spri7 pr6|76
"
	lda 55,dl						RTS(55)
	sta pr6|rts_code				move key in FSB one pos
	epp0 return_from_alt_spec			prefix by 511
	spri0 pr6|stack_frame.return_ptr
	tra call_rts_from_op
"
return_from_alt_spec:
	lda pr6|100				restore rec length
	sta pr6|80
	tra return_to_reset
"[3.0-1]
"[3.0-1]	alt_delete		**********OPERATOR(86)**********
"[3.0-1]
"[3.0-1]
"
alt_delete:
	inhibit on
	stx0 pr6|return_to_main_off
	inhibit off
"
	lda 53,dl					RTS(53)
	sta pr6|rts_code				set fields in FSB after rewrite
	epp0 return_from_alt_fsb
	spri0 pr6|stack_frame.return_ptr
	tra call_rts_from_op
"
return_from_alt_fsb:
	tra  return_to_reset
"[3.0-1]
"[3.0-1]	alt_key_delete			**********OPERATOR(87)**********
"[3.0-1]
"[3.0-1]
"
alt_key_delete:
	inhibit on
	stx0 pr6|return_to_main_off
	inhibit off
"
	stz pr6|mcode
	epp7 pr6|mcode				mcode_ptr
	spri7 pr6|76
"
	lda 52,dl					RTS(52)
	sta pr6|rts_code				$control("record_status")
	epp0 return_from_rew_del			delete alt key values
	spri0 pr6|stack_frame.return_ptr
	tra call_rts_from_op
"
return_from_rew_del:
	szn pr6|mcode
	tze return_to_reset
"
	lda io9_con				status-key-1,2
	ldq s7430con		[5.3-1]		status-key-3
	staq pr6|status12
	ldx1 65,du				unable to delete keys
	tra io_return_to_reset
"[3.0-1]
"[3.0-1]	alt_rewrite_add		**********OPERATOR(88)**********
"[3.0-1]
"[3.0-1]
"
alt_rewrite_add:
	inhibit on
	stx0 pr6|return_to_main_off
	inhibit off
"
	stz pr6|mcode
	epp7 pr6|mcode				mcode_ptr
	spri7 pr6|76
"
	lda 58,dl					RTS(58)
	sta pr6|rts_code				$control("record_status)
	epp0 return_from_rew_add			add alt key values
	spri0 pr6|stack_frame.return_ptr		set fields in FSB after rewrite
	tra call_rts_from_op
"
return_from_rew_add:
	szn pr6|mcode
	tze return_to_reset
"
	lda io9_con				status-key-1,2
	ldq s5730con				status-key-3
	staq pr6|status12
	ldx1 64,du				unable to add key
	tra io_return_to_reset
"[3.0-1]
"[3.0-1]	alt_add_write_keys		**********OPERATOR(90)**********
"[3.0-1]
"[3.0-1]
"
alt_add_write_keys:
	inhibit on
	stx0 pr6|return_to_main_off
	inhibit off
"
	spri7 pr6|80				set file descr ptr
	stz pr6|mcode
	epp7 pr6|mcode				mcode_ptr
	spri7 pr6|76
"
	lda 56,dl					RTS(56)
	sta pr6|rts_code				add alt rec keys
	epp0 return_from_alt_add			set fields in FSB
	spri0 pr6|stack_frame.return_ptr
	tra call_rts_from_op
"
return_from_alt_add:
	szn pr6|mcode
	tze return_to_reset
"
	lda io9_con				status-key-1,2
	ldq s4730con				status-key-3
	staq pr6|status12
	ldx1 64,du				unable to add keys
	tra io_return_to_reset
"
"[3.0-1]
"[3.0-1]	alt_write_seek_key		**********OPERATOR(91)**********
"[3.0-1]
"[3.0-1]
"
alt_write_seek_key:
	inhibit on
	stx0 pr6|return_to_main_off
	inhibit off
"
	lda pr6|80
	sta pr6|100			save record size
	spri7 pr6|80			set file descr ptr
	spri5 pr6|78			store buff ptr
	epp7 pr6|mcode				mcode_ptr
	spri7 pr6|76
	stz pr6|mcode
"
	lda 51,dl				RTS(51)
	sta pr6|rts_code			if necessary: test key order, SAVE_CRP
	epp0 return_from_write_seek		test alt key values for legality
	spri0 pr6|stack_frame.return_ptr	move key in FSB one pos to right
	tra call_rts_from_op
"
return_from_write_seek:
	lda pr6|100
	sta pr6|80				restore record size
	szn pr6|mcode
	tze return_to_reset
"
	lda io9_con			status-key-1,2
	ldq s4430con			status-key-3
	staq pr6|status12
	ldx1 21,du			unable to write record
	tra io_return_to_reset
"[3.0-1]
"[3.0-1]	alt_find_rec		**********OPERATOR(92)**********
"[3.0-1]
"[3.0-1]
"
alt_find_rec:
	inhibit on
	stx0 pr6|return_to_main_off
	inhibit off
"
	spri7 pr6|80					set file descr ptr
	stz pr6|icode
	epp7 pr6|mcode				mcode_ptr
	spri7 pr6|76
"
	lda 57,dl					RTS(57)
	sta pr6|rts_code				if necessary then RESTORE_CRP
	epp0 return_from_alt_find
	spri0 pr6|stack_frame.return_ptr
	tra call_rts_from_op
"
return_from_alt_find:
"
	szn pr6|mcode
	tze return_to_reset
"
	tra read_record_exit
"
"	alt_rewrite				**********OPERATOR(93)**********
"
alt_rewrite:
	inhibit on
	stx0 pr6|return_to_main_off
	inhibit off
"
	spri5 pr6|78				loc of buffer
	stz pr6|mcode				mcode ptr
	epp7 pr6|mcode
	spri7 pr6|76
"
	lda 61,dl					RTS(61)
	sta pr6|rts_code
	epp0 return_from_rew_del
	spri0 pr6|stack_frame.return_ptr
	tra call_rts_from_op
"
"
"	read_record used by cobol_read_gen	**********OPERATOR(66)**********
"
nonseq_read_record:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	lda	1,dl
	sta	pr6|54
	tra	read_common
"
"					**********OPERATOR(65)**********
"
"
read_record:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	stz	pr6|54
read_common:
	epp1	pr6|86,*		set iocb_ptr
	spri5	pr6|78		store buff_ptr
	epp2      pr6|78
	spri2	pr6|88		store pointer to buff_ptr
	epp2 	pr6|80
	spri2	pr6|90		store pointer to buff_len
	stz	pr6|47
	epp2	pr6|47
	spri2	pr6|92		length of record in bytes output
	epp2	pr6|mcode
	spri2	pr6|94		store pointer to mcode
"						RTS(63)
	stz	pr6|mcode					[5.3-1]
	lda	63,dl					[5.3-1]
	sta	pr6|rts_code				[5.3-1]
	epp0	return_read_record
	spri0	pr6|stack_frame.return_ptr
	tra	call_rts_from_op				[5.3-1]
	even
return_read_record:
	szn	pr6|mcode
	tze	return_to_reset
read_record_exit:
	epp4	pr6|linkage_ptr,*
	epp2	pr6|mcode
	spri2	pr6|76
"						RTS(27)
	lda	27,dl
	sta	pr6|rts_code
	epp0	return_read_record_exit
	spri0	pr6|stack_frame.return_ptr
	tra	call_rts_from_op
	even
return_read_record_exit:
	szn	pr6|mcode
	tze	return_to_reset
	ldx1	25,du
	tra	io_return_to_reset
"
"
"	init_start check file condition**********OPERATOR(21)**********
"
"
init_start:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
"
	spri1	pr6|86		set fsb_ptr
	stz	pr6|icode
	szn	pr1|2		is file open
	tnz	pr6|text_base_ptr,*0  YES
"	set status
	lda	io30_con
	ldq	s6031con
	staq	pr6|status12
	ldx1	24,du		attempt to perform io on unopened file
	tra	io_return_to_reset
"
"
"	iox_$control  perform control order on io switch.**********OPERATOR(23)**********
"
"
start_control:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
"
	epp1	pr6|86,*		set iocb_ptr
	spri6	pr6|48		store stack_offset ptr for order name
	spri6	pr6|50
	adx5	pr6|49		add base offset to x5
	stx5	pr6|49		set correct offset
	adx5	2,du
	stx5	pr6|51
	spri1	pr6|48,*		store fsb pointer
	epp2	pr6|50,*
	adwp2	2,du
	spri2	pr6|50,*		store control pointer
	epp2	pr6|40
	spri2	pr6|76		store mcode_ptr
"						RTS(11)
	lda	11,dl
	sta	pr6|rts_code
	epp0	return_start_control
	spri0	pr6|stack_frame.return_ptr
	tra	call_rts_from_op	iox_control
"
return_start_control:
	szn	pr6|mcode
	tze	return_to_reset
"	set status
	ldx1	38,du		unable to start a file with specified key
	tra	io_return_to_reset
"
"	close_reel			**********OPERATOR(76)**********
"
close_reel:
	inhibit	on
	stx0	pr6|return_to_main_off
	inhibit	off
	lda	pr1|2		get open_mode
	tze	file_unopen	file not open yet, error
	epp0	ptr_desc
	spri0	pr6|100
	spri0	pr6|104
	epp0	fb35_desc
	spri0	pr6|106
	spri1	pr6|92		set parameter for iocb_ptr
	epp0	pr6|76		tvstat_ptr for input reel
	spri0	pr6|96
	epp0	pr6|mcode		mcode_ptr
	spri0	pr6|98
	cmpa	21,dl		input reel?
	tze	input_reel	yes
	cmpa	17,dl		input reel?
	tze	input_reel	yes
	ldaq	null_con
	staq	pr6|76		null info_ptr
	epp0	feov_desc
	spri0	pr6|102
	epp0	feov_con		char "feov"
	spri0	pr6|94
	eax1	pr6|90
	fld	8192,dl
	epp2	pr1|0,*		iocb_ptr
	epp2	pr2|54		entry iocb.control
	tra	call_ent_var_desc_from_op
input_reel:
	spri0	pr6|88		parameter mcode_ptr for position call
	spri1	pr6|82
	epp0	volume_desc
	spri0	pr6|102
	epp0	volume_con	char "volume_status"
	spri0	pr6|94
	epp0	zero_con		type 0
	spri0	pr6|84
	epp0	one_con		1 record for each position operation
	spri0	pr6|86
	stz	pr6|78		initialize volume no. for comparison
vol_call:
	eax1	pr6|90
	fld	8192,dl		4 parameters
	epp1	pr6|92,*		fsb_ptr
	epp2	pr1|0,*		iocb_ptr
	epp2	pr2|54		iocb.control
	epp0	return_from_vol_call
	spri0	pr6|stack_frame.return_ptr
	tra	call_ent_var_desc_from_op
return_from_vol_call:
	szn	pr6|mcode		check error code
	tnz	reel_exit
vol_call_ok:
	epp1	pr6|76,*		tvstat_ptr
	lda	pr1|3		volume sequence no.
	szn	pr6|78		first call?
	tnz	vol_comp		no, goto compare
	sta	pr6|78		yes. save vol seq no.
	tra	posi_call		call position operation
vol_comp:
	cmpa	pr6|78		comparing vol seq nos
	tnz	reel_exit	not equal, done.
posi_call:
	eax1	pr6|80
	fld	8192,dl
	epp1	pr6|82,*		fsb_ptr
	epp2	pr1|0,*		iocb_ptr
	epp2	pr2|50		position entry
	epp0	return_from_posi_call
	spri0	pr6|stack_frame.return_ptr
	tra	call_ent_var_from_op
return_from_posi_call:
	szn	pr6|mcode		check mocde
	tze	vol_call		next volume_status call
	tra	reel_exit		return
file_unopen:
	lda	pr1|90		optional bit
	cmpa	optional_int	optional internal
	tze	return_to_reset
	cmpa	optional_ext	optional external
	tze	return_to_reset
	lda	io30_con
	ldq	s2036con
	staq	pr6|status12
	ldx1	17,du
	tra	return_thru_text_base_pone
reel_exit:
	epp1	pr6|92,*
	tra	return_to_reset
"
"
"
"
"	Please insert the next operator before this line.
"
"
	segdef	cobol_operators_end
cobol_operators_end:
	oct	0
	include cobol_operators_info
	end
