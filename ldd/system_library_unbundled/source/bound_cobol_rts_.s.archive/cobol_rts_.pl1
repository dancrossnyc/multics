/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(1989-04-23,Zimmerman), approve(1989-04-23,MCR8090),
     audit(1989-05-05,RWaters), install(1989-05-24,MR12.3-1048):
     MCR8090 cobol_rts_.pl1 Disallow duplicate prime keys in Indexed Sequential
     files.
  2) change(1990-10-03,Zimmerman), approve(1990-10-03,MCR8218),
     audit(1990-10-10,Gray), install(1990-10-19,MR12.4-1048):
     Add check for pre-MR12.3 object segs to prevent attempts to access fields
     that do not exist.
  3) change(2016-01-15,Swenson), approve(2016-01-15,MCR10003):
     Fix to support 4-character time zone abbreviations.
                                                   END HISTORY COMMENTS */


/* Modified on 12/19/84 by FCH, [5.3-1], BUG573(phx16343), error checking fails for ark */
/* Modified on 07/17/82 by FCH, [5.1-1], REWRITE after ACCESS DYNAMIC can cause runtime abort, BUG532(phx13391) */
/* Modified on 09/18/81 by FCH, [5.0-1], WRITE with alt keys can abort in rts, BUG 506 */
/* Modified on 06/11/81 by FCH, [4.4-2], RTS(62) added for STOP RUN with CD INITIAL */
/* Modified on 02/19/81 by FCH, [4.4-1], REWRITE invalid detection not correct, RTS(61) added, BUG464 */
/* Modified on 12/13/79 by PRP, [4.1-1], day of year fixed for leap year */
/* Modified on 09/14/79 by FCH, [4.0-4], iox_$attach_ptr replaces iox_$attach_iocb */
/* Modified on 09/06/79 by FCH, [4.0-3], rewrite with alt rec keys */
/* Modified on 08/24/79 by PRP, [4.0-2], rts(60) added for alternate key start control */
/* Modified on 08/13/79 by FCH, [4.0-1], icode value changed in start statement */
/* Modified since Version 4.0	*/




/*	This is the cobol run time interface procedure.
	It is called by the cobol_operators_ with the parameters are set in the stack frame
	starting from the 68th word.
	From the 68th word up through the 107th word are reserved for this interfacinguse.
	From the 108th word up through the 137th word are reserved for the condition
	handling use.
	The 68th word up through the 73th word are used to set the parameter rts_stack_ptr.
	The rts_code is the 88th words of the stack frame, it is used to decide the run time
	procedure that cobol_rts_ is going to call.
Register Usage

	$pr0	cobol_operators_
	$pr1	fsb pointer
	$pr2	temporary
	$pr3	cobol_data_area
	$pr4	cobol_linkage_area
	$pr5	cobol_data_area(extension)
	$pr6	stack_prame pointer
	$pr7	temporary

	Run Time Stack Frame

  0   0
  1   1
  2   2
  3   3
  4   4
  5   5
  6   6
  7   7
  8  10
  9  11
 10  12
 11  13
 12  14
 13  15
 14  16
 15  17
 16  20	S.prev_sp, S.condition_word, S.flag_word
 17  21
 18  22	S.next_sp, S.signaller_word
 19  23
 20  24	S.return_ptr
 21  25
 22  26	S.entry_ptr
 23  27
 24  30	S.operator_ptr, S.lp_ptr
 25  31
 26  32	S.arg_ptr
 27  33
 28  34	S.static_ptr
 29  35	S.support_ptr
 30  36	S.on_unit_relptrs, on_unit_ptr
 31  37	S.operator_ret_ptr, S.translator_id, op_return_offset
 32  40	S.regs, display_ptr
 33  41
 34  42	descriptor_ptr
 35  43
 36  44	linkage_ptr
 37  45
 38  46	text_base_ptr
 39  47	text_base_off
 40  50	mcode
 41  51	icode
 42  52	status12
 43  53	status3
 44  54	retrycode, cobol_open_mode
 45  55
 46  56	multics_open_mode
 47  57
 48  60	S.min_length
 49  61
 50  62
 51  63
 52  64
 53  65
 54  66
 55  67
 56  70
 57  71
 58  72
 59  73
 60  74
 61  75
 62  76
 63  77
 64 100	return_to_main_ptr
 65 101	return_to_main_off
 66 102	rts_code_ptr
 67 103
 68 104
 69 105
 70 106
 71 107
 72 110	rts_code						args to cobol_rts
 73 111	use_code
 74 112	iocb_ptr
 75 113
 76 114	mcode_ptr
 77 115
 78 116	buff_ptr
 79 117
 80 120	buff_len
 81 121	actual_ptr
 82 122	stack_buff_ptr, cobol_open_mode
 83 123	cobol_options
 84 124	vfile_open_mode
 85 125	key of ref
 86 126	fsb_ptr			iox_, arg-1	args for iox_calls
 87 127
 88 130	file_desc_ptr		iox_, arg-2
 89 131	cobol_error_code
 90 132				iox_, arg-3
 91 133
 92 134				iox_, arg-4
 93 135
 94 136
 95 137
 96 140
 97 141
 98 142
 99 143
100 144	x6_save
101 145
102 145
103 147
104 150
105 151
106 152 	subr_return_save
107 153	subr_return_save_off
108 154	pr4_save
109 155
110 156	pr3_save
111 157
112 160	pr5_save
113 161
114 162	rts_save
115 163
116 164	ind_mask
117 165
		ENTRY OPTIONS

FUNCTION NAME			COBOL OPERATORS

(1)   cobol_error_
(2)   cobol_control_
(3)   sort_initiate
(4)   sort_release
(5)   sort_return
(6)   sort_terminate
(7)   sort_commence
(8)   stop_literal
(9)   stop_run
(10)  cancel
(11)  iox_$control		23
(129  check_close_error	27,29,36,38
(13)  check_open_error
(14)  iox_$find_iocb
(15)  iox_$attach_iocb	29,35,36
(16)  check_seek_errors	41,54,67
(17)  iox_$read_key		55
(18)  accept
(19)
(20)  accept_id
(21)  accept_id
(22)  accept_id
(23)  inspect
(24)  inspect
(25)  seek_for_delete	57,58
(26)  read_key_status_code	69
(27)  check_read_record	65,66
(28)  check_get_line	64
(29)
(30)  merge_init
(31)  merge_comp
(32)  merge_return
(33)
(34)
(35)
(36)
(37)
(38)
(39)
(40)  receive_comm
(41)  accept_comm
(42)  purge_comm
(43)  send_comm
(44)  enable_comm
(45)  disable_comm
(46)  alt_file_open
(47)  alt_read_record

		Status_Key_1 (Status_Key_2)

org = seq
	0(0)1(0)3(0,4)9
org = rel
	0(0)1(0)2(2,3,4)3(0)9
org=ind
	0(0,2)1(0)2(1,2,3,4)3(0)9

Status_Key_1 =	0 success
		1 at end
		2 invalid
		3 permanent error
		9 implementor defined

Status_Key_2 =	0 no more information
		1 sequence error
		2 duplicate key
		3 no record found
		4 boundary violation

Status_Key_3 pic 9999	wxyz

	w: cobol i/o statement
	x: vfile_command
	y: same as key_1
	z: specific cause of error

vfile_commands and error codes

	attach_ptr	(not_detached)
	close		(not_open)
	delete_record	(no_record)
	detach_iocb	(not_attached, not_closed)
	find_iocb		()
	get_chars		(short_record,end_of_info)
	get_line		(short_record,end_of_info)
	open		(not_attached,not_closed)
	position		(no_record,end_of_info)
	read_key		(end_of_info,no_record)
	read_length	(end_of_info,no_record)
	read_record	(end_of_info,no_record,long_record)
	record_status)	(no_room_for_lock,no_record,no_key)
	rewrite_record	(no_record)
	seek_head		(no_record)
	seek_key		(no_record,key_order)
	write_record	(no_key)

*/





/* format: style3 */
cobol_rts_:
     proc (rts_ptr);

dcl	1 rts_stack	based (rts_stack_ptr),
	  2 rts_code	fixed bin;

dcl	temp_mcode	fixed bin (35);
dcl	rts_stack_ptr	ptr;
dcl	rts_ptr		ptr;

	rts_stack_ptr = rts_ptr;
	goto rts (rts_stack.rts_code);

/*	*******************************
	*			*
	*	cobol_error_	*
	*			*
	*******************************/

rts (1):						/* This label is for cobol error	*/
						/* The declaration for the rts stack frame	*/
dcl	1 error_stack	based (rts_stack_ptr),
	  2 rts_code	fixed bin,
	  2 use_code	fixed bin,
	  2 filler1	char (60),
	  2 cobol_code	fixed bin,
	  2 multics_code	fixed bin (35),
	  2 filler2	fixed bin,
	  2 line_no1	fixed bin,
	  2 line_no2	fixed bin,
	  2 error_ptr	ptr,
	  2 progname_ptr	ptr,
	  2 progname_length fixed bin;

dcl	progname		char (65) based (progname_ptr);




	if error_stack.use_code = 0
	then call cobol_error_ (error_stack.cobol_code, error_stack.multics_code, error_stack.line_no1,
		error_stack.line_no2, substr (progname, 1, error_stack.progname_length), error_stack.error_ptr);
	else do;
		error_stack.use_code = 0;
		call cobol_error_$use (error_stack.cobol_code, error_stack.multics_code, error_stack.line_no1,
		     error_stack.line_no2, substr (progname, 1, error_stack.progname_length), error_stack.error_ptr);
	     end;
	return;



/*	*******************************
	*			*
	*	cobol_control_	*
	*			*
	*******************************/

rts (2):						/* This label is for cobol control	*/
						/* This stack frame is for cobol_contool_ rts stack frame.	*/
dcl	1 control_stack	based (rts_stack_ptr),
	  2 rts_code	fixed bin,
	  2 filler	char (4),
	  2 pr4_save_ptr	ptr;



	call cobol_control_$cobol_rts_control_ (control_stack.pr4_save_ptr);
	return;

/*	*******************************************************************************************/

/*		BEGIN SORT PACKAGE							*/

/*	*******************************************************************************************/



/*	*******************************
	*			*
	*	sort_initiate	*
	*			*
	*******************************/

rts (3):						/* This label is for sort_initiate	*/
						/* The declaration for the rts stack frame	*/
dcl	1 sort_initiate_stack
			based (rts_stack_ptr),
	  2 filler1	char (8),
	  2 exit_ptr	ptr,
	  2 control_ptr	ptr,
	  2 filler2	char (8),
	  2 status_code	fixed bin (35);

dcl	1 exits		based (sort_initiate_stack.exit_ptr),
	  2 version	fixed bin,
	  2 compare	entry,
	  2 input_record	entry,
	  2 output_record	entry;



	exits.input_record = sort_$noexit;
	exits.output_record = sort_$noexit;
	controlp = sort_initiate_stack.control_ptr;

	if sort_file_size = 0.0
	then sort_file_size = 1.0;
	if sort_dir_len = 0
	then call sort_$initiate ("", null (), sort_initiate_stack.exit_ptr, "-bf", sort_file_size,
		sort_initiate_stack.status_code);
	else call sort_$initiate (substr (sort_dir, 1, sort_dir_len), null (), sort_initiate_stack.exit_ptr, "-bf",
		sort_file_size, sort_initiate_stack.status_code);
	return;






/*	*******************************
	*			*
	*	sort_release	*
	*			*
	*******************************/

rts (4):						/* This label is for sort_release	*/
						/* The declaration for the rts stack frame	*/
dcl	1 sort_release_stack
			based (rts_stack_ptr),
	  2 filler1	char (8),
	  2 data_ptr	ptr,
	  2 data_length	fixed bin (21),
	  2 filler2	char (12),
	  2 status_code	fixed bin (35);

dcl	sort_$release	entry (ptr, fixed bin (21), fixed bin (35));



	call sort_$release (sort_release_stack.data_ptr, sort_release_stack.data_length, sort_release_stack.status_code)
	     ;
	return;





/*	*******************************
	*			*
	*	sort_return	*
	*			*
	*******************************/

rts (5):						/* This label is for sort_return	*/
						/* The declaration for the rts stack frame	*/
dcl	1 sort_return_stack based (rts_stack_ptr),
	  2 filler1	char (8),
	  2 buff_ptr	ptr,
	  2 record_length	fixed bin (21),
	  2 filler2	char (12),
	  2 status_code	fixed bin (35);



	call sort_$return (sort_return_stack.buff_ptr, sort_return_stack.record_length, sort_return_stack.status_code);
	if sort_return_stack.status_code = 0
	then return;
	else if sort_return_stack.status_code = error_table_$end_of_info
	then do;
		sort_return_stack.record_length = 0;
		sort_return_stack.status_code = 0;
	     end;
	return;




/*	*******************************
	*			*
	*	sort_terminate	*
	*			*
	*******************************/

rts (6):						/* This label is for sort_terminate	*/
						/* The declaration for the rts stack frame	*/
dcl	1 sort_terminate_stack
			based (rts_stack_ptr),
	  2 filler1	char (8),
	  2 status_code	fixed bin (35),
	  2 filler2	char (20),
	  2 prev_status_code
			fixed bin (35);



	call sort_$terminate (sort_terminate_stack.status_code);

	return;


/*	*******************************
	*			*
	*	sort_commence	*
	*			*
	*******************************/

rts (7):						/* This label is for sort_commence	*/
						/* The declaration for the rts stack frame	*/
dcl	1 sort_commence_stack
			based (rts_stack_ptr),
	  2 filler1	char (32),
	  2 status_code	fixed bin (35);




	call sort_$commence (sort_commence_stack.status_code);
	return;


/*	*******************************************************************************************/

/*		END SORT PACKAGE							*/

/*	*******************************************************************************************/



/*	*******************************
	*			*
	*	stop literal	*
	*			*
	*******************************/

rts (8):						/* This label is for "stop literal". It is used to eleminate the link for cu_$cl.*/
	call cu_$cl;
	return;





/*	*******************************
	*			*
	*	stop run		*
	*			*
	*******************************/

rts (9):						/* This label is for "stop run". It is used to eleminate the link for cobol_stoprun_. */
dcl	temp_ptr		ptr based;		/* temporary pointer. */

	stat_ptr = addrel (rts_stack_ptr, 36) -> temp_ptr;/* linkage section */
	stat_ptr = addrel (stat_ptr, 8);		/* static section */
	controlp = stat.control_ptr;

rts9:
	if control.main_prog_sw ^= 0
	then call signal_ ("stop_run", null (), stat_ptr);
	call cobol_stop_run_ (stat_ptr, 0, 0, 0);
	call signal_ ("command_abort_", null (), null ());
	return;

rts (62):						/*[4.4-2]*/
dcl	cobol_mcs_$stop_run entry;

/*[4.4-2]*/
	stat_ptr = addrel (rts_stack_ptr, 36) -> temp_ptr;/* linkage section */
						/*[4.4-2]*/
	stat_ptr = addrel (stat_ptr, 8);		/* static section */
						/*[4.4-2]*/
	controlp = stat.control_ptr;

/*[4.4-2]*/
	call cobol_mcs_$stop_run;

	go to rts9;








/*	*******************************
	*			*
	*	cancel		*
	*			*
	*******************************/


rts (10):						/* this label is for cancel code to call cobol_control_$cancel	*/
dcl	1 cancel_stack	based (rts_stack_ptr),
	  2 filler	char (8),
	  2 name_ptr	ptr,
	  2 name_length	fixed bin,
	  2 cancel_code	fixed bin;

dcl	cancel_name	char (65) based (cancel_stack.name_ptr);

	call cobol_control_$cancel (substr (cancel_name, 1, cancel_stack.name_length), 0, 0, cancel_code);
	return;

/*	*******************************************************************************************/

/*		BEGIN IO PACKAGE							*/

/*	*******************************************************************************************/


/******************************
	*			*
	*	iox_$control	*
	*			*
	*******************************/

rts (11):						/* This label is for iox_$control */
dcl	1 iox_control_stack based (error_block.offset_ptr),
	  2 iocb_ptr	ptr,
	  2 control_ptr	ptr;
dcl	1 struc		based (iox_control_stack.control_ptr),
	  2 relation	fixed bin,
	  2 keylen	fixed bin,
	  2 key		char (0 refer (keylen));

dcl	order_name	char (9) init ("seek_head");
dcl	control_iocb_ptr	ptr based (iox_control_stack.iocb_ptr);



	call iox_$control (control_iocb_ptr, order_name, iox_control_stack.control_ptr, mcode);

	if mcode ^= 0
	then do;
		if mcode = error_table_$no_record
		then do;
			error_block.status12 = "23";
			error_block.status3 = "6723"; /*[4.0-1] */
			icode = 4;
		     end;
		else do;
			error_block.status12 = "30";
			error_block.status3 = "6732";
		     end;
	     end;
	return;



/* The declaration for the rts stack frame	*/

dcl	1 io_stack_hdr	based (rts_stack_ptr),
	  2 rts_code	fixed bin,
	  2 use_code	fixed bin,
	  2 iocb_ptr	ptr,
	  2 mcode_ptr	ptr,
	  2 buff_ptr	ptr,
	  2 buff_len	fixed bin (21),
	  2 actual_len	fixed bin (21),
	  2 stack_buff_ptr	ptr;
dcl	1 read_key_based	based (addr (io_stack_hdr.stack_buff_ptr)),
	  2 filler	fixed bin,
	  2 read_key_eof	fixed bin;
dcl	1 error_block	based (io_stack_hdr.mcode_ptr),
	  2 mcode		fixed bin (35),
	  2 icode		fixed bin,
	  2 status12	char (2) aligned,
	  2 status3	char (4) aligned,
	  2 retrycode	fixed bin,
	  2 filler1	char (4),
	  2 option_flag	fixed bin,
	  2 filler2	char (4),
	  2 offset_ptr	ptr,
	  2 filler13	char (16),
	  2 temp_flag	fixed bin;


/*	*******************************
	*			*
	*	check close error	*
	*			*
	*******************************/

rts (12):						/* This label is for  check close error	*/
						/* The fields referenced are in dcl error_block. */
check_close_error:
	error_block.status12 = "30";
	if mcode = error_table_$no_operation
	then error_block.status3 = "2332";
	else if mcode = error_table_$bad_file
	then error_block.status3 = "2392";
	else error_block.status3 = "2390";
	return;






/******************************
	*			*
	*	check open error	*
	*			*
	*******************************/

rts (13):						/* This label is for  check open error */
						/* The fields referenced are in dcl error_block. */
check_open_error:
	error_block.status12 = "30";
	if mcode = error_table_$no_operation
	then error_block.status3 = "1232";
	else if mcode = error_table_$file_busy
	then error_block.status3 = "1291";
	else if mcode = error_table_$incompatible_attach
	then error_block.status3 = "1294";
	else if mcode = error_table_$bad_file
	then error_block.status3 = "1292";
	else if mcode = error_table_$noentry
	then error_block.status3 = "1295";
	else error_block.status3 = "1290";
	return;


/******************************
	*			*
	*	iox_$find_iocb	*
	*			*
	*******************************/

rts (14):						/* This label is for iox_$find_iocb */
dcl	1 find_iocb_stack	based (error_block.offset_ptr),
	  2 fsb_ptr	ptr,
	  2 switchlen	fixed bin,
	  2 filler2	char (4),
	  2 switchname	char (0 refer (find_iocb_stack.switchlen));

dcl	find_iocb_ptr	ptr based (find_iocb_stack.fsb_ptr);



	call iox_$find_iocb (find_iocb_stack.switchname, find_iocb_ptr, error_block.mcode);

	return;





/*******************************
	*			*
	*	iox_$attach_ptr	*
	*			*
	*******************************/

rts (15):						/* This labe is for iox_$attach_iocb */
dcl	1 attach_iocb_stack based (error_block.offset_ptr),
	  2 fsb_ptr	ptr,
	  2 atdlen	fixed bin,
	  2 filler2	char (4),
	  2 atd		char (0 refer (attach_iocb_stack.atdlen));

dcl	attach_iocb_ptr	ptr based (attach_iocb_stack.fsb_ptr);



/*[4.0-4]*/
	call iox_$attach_ptr (attach_iocb_ptr, attach_iocb_stack.atd, null (), error_block.mcode);

	return;




/******************************
	*			*
	*	check seek errors	*
	*			*
	*******************************/

rts (16):						/* This label is for  check seek key errors */
check_seek_error:
	if temp_flag = 1
	then do;
		if mcode = error_table_$key_order
		then do;
			icode = 1;
			error_block.status12 = "21";
			error_block.status3 = "3621";
		     end;
		else if mcode = error_table_$no_record
		then do;
			icode = 1;
			error_block.status12 = "23";
			error_block.status3 = "3623";
		     end;
		else do;
			error_block.status12 = "30";
			if mcode = error_table_$no_operation
			then error_block.status3 = "3632";
			else error_block.status3 = "3630";
		     end;
	     end;
	else do;
		if mcode = error_table_$no_record
		then do;
			error_block.status12 = "00";
			error_block.status3 = "0000";
			mcode = 0;
		     end;
		else if mcode = error_table_$key_order
		then do;
			error_block.status12 = "21";
			error_block.status3 = "4621";
		     end;
		else do;


			error_block.status12 = "21";
			error_block.status3 = "4622";
		     end;
	     end;


	return;



/*******************************
	*			*
	*	iox_$read_key	*
	*			*
	*******************************/

rts (17):						/* This label is for iox_$read_key errors */
read_key_error:					/* don't report EOF now, wait for seek */
	if mcode = error_table_$end_of_info
	then do;
		error_block.status12 = "00";
		error_block.status3 = "0000";
		read_key_based.read_key_eof = 1;
		mcode = 0;
	     end;
	else if mcode = error_table_$no_record
	then do;
		error_block.status12 = "10";
		error_block.status3 = "3830";
	     end;
	return;






/*	*******************************
	*			*
	*	accept		*
	*			*
	*******************************/

rts (18):						/* This label is interfacing with accept_gen for accpting user's word. */
	call iox_$get_line (iox_$user_input, io_stack_hdr.buff_ptr, io_stack_hdr.buff_len, io_stack_hdr.actual_len,
	     error_block.mcode);

	if error_block.mcode = error_table_$long_record
	then do while (error_block.mcode = error_table_$long_record);
		call iox_$get_line (iox_$user_input, io_stack_hdr.stack_buff_ptr, 64, io_stack_hdr.actual_len,
		     error_block.mcode);
		io_stack_hdr.actual_len = 0;
	     end;
	return;


rts (20):
rts (21):
rts (22):						/* These labels are for accept <id> from day (time,day of week, and date). */
dcl	1 time_stack	based (rts_stack_ptr),
	  2 rts_code	fixed bin,
	  2 use_code	fixed bin,
	  2 month		fixed bin,
	  2 filler1	char (4),
	  2 dom		fixed bin,		/* day of the month */
	  2 filler2	char (4),
	  2 year		fixed bin,
	  2 filler3	char (4),
	  2 tod		fixed bin (71),		/*time of the day */
	  2 dow		fixed bin,		/*day of the week */
	  2 zone		char (4) aligned,		/* time zone */
	  2 day_return	fixed bin,		/* day in the form yy||doy */
	  2 filler4	char (4),
	  2 doy		fixed bin,		/* day of the year */
	  2 filler5	char (4),
	  2 date		char (6);			/* day in the form yy||mm||dd */

dcl	date_time		fixed bin (71),
	d_array		(12) fixed bin static init (0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334),
	day_temp		char (8);

	date_time = clock_ ();

	if time_stack.rts_code = 22
	then do;
		call date_time_ (date_time, day_temp);
		date = substr (day_temp, 7, 2) || substr (day_temp, 1, 2) || substr (day_temp, 4, 2);
		return;
	     end;

	call decode_clock_value_ (date_time, month, dom, year, tod, dow, zone);
	if time_stack.rts_code ^= 20
	then return;

	doy = d_array (month) + dom;

	if mod (year, 4) = 0 & month > 2		/* [4.1-1] */
	then doy = doy + 1;
	else /*do nothing */
	     ;
	return;



/*	*******************************
	*			*
	*	inspect		*
	*			*
	*******************************/

rts (23):
rts (24):						/* These labels are for inspect to call cobol_su_$tally and cobol_su_$replace. */
dcl	1 inspect_stack	based (rts_stack_ptr),
	  2 rts_code	fixed bin,
	  2 filler	char (4),
	  2 work_ptr	ptr,
	  2 output_length	fixed bin;

	if inspect_stack.rts_code = 24
	then call cobol_su_$replace (inspect_stack.work_ptr);
	else call cobol_su_$tally (inspect_stack.work_ptr, inspect_stack.output_length);
	return;






/*	*****************************************
	*			*
	*	seek for delete	*
	*			*
	*******************************/

rts (25):						/* This label is for delete seek and delete record. */
	if mcode = error_table_$no_record
	then do;
		error_block.status12 = "00";
		error_block.status3 = "0000";
		mcode = 0;
	     end;
	return;


/*******************************
	*			*
	*	check_read_key	*
	*			*
	*******************************/

rts (26):						/* This label is used to set up status code for read key	*/
						/* don't report EOF now, wait for seek */
	if mcode = error_table_$end_of_info
	then do;
		error_block.status12 = "10";
		error_block.status3 = "3810";
		icode = 1;
	     end;
	else if mcode = error_table_$no_record
	then do;
		icode = 1;
		error_block.status12 = "10";
		error_block.status3 = "3830";
	     end;
	else if mcode = error_table_$no_operation
	then do;
		error_block.status12 = "30";
		error_block.status3 = "3832";
	     end;
	else do;
		error_block.status12 = "30";
		error_block.status3 = "3830";
	     end;
	return;



/*******************************
	*			*
	*	check_read_record	*
	*			*
	*******************************/

rts (27):						/* This label is used to set up status code for read record	*/
	if mcode = error_table_$short_record
	then do;
		mcode = 0;
		error_block.status12 = "00";
		error_block.status3 = "3001";
	     end;
	else if mcode = error_table_$no_record
	then do;
		if temp_flag = 1
		then do;
			error_block.status12 = "23";
			error_block.status3 = "3423";
		     end;
		else do;
			error_block.status12 = "10";
			error_block.status3 = "3430";
		     end;
		icode = 1;
	     end;
	else if mcode = error_table_$end_of_info
	then do;
		icode = 1;
		if temp_flag = 0
		then do;
			error_block.status12 = "10";
			error_block.status3 = "3410";
		     end;
		else do;
			error_block.status12 = "30";
			error_block.status3 = "3430";
		     end;
	     end;
	else do;
		error_block.status12 = "30";
		if mcode = error_table_$no_operation
		then error_block.status3 = "3432";
		else do;
			error_block.status12 = "10";	/* force END OF FILE condition */
			error_block.status3 = "3410";
		     end;
	     end;
	return;



/*******************************
	*			*
	*	check_get_line	*
	*			*
	*******************************/

rts (28):						/* This label is used to set up status codes for get_line.	*/
	if mcode = error_table_$end_of_info
	then do;
		icode = 1;
		error_block.status12 = "10";
		error_block.status3 = "3510";
	     end;
	else if mcode = error_table_$long_record
	then do;
		error_block.status12 = "30";
		error_block.status3 = "3535";
	     end;
	else do;
		error_block.status12 = "30";
		error_block.status3 = "3535";
	     end;
	return;







/*	*******************************************************************************************/

/*		END IO PACKAGE							*/

/*	*******************************************************************************************/


/*	*******************************************************************************************/

/*		BEGIN MERGE PACKAGE							*/

/*	*******************************************************************************************/


/*	The declaration for the communication stack frame which is shared by all merge rts package.	*/

dcl	1 merge_comm_stack	based (rts_stack_ptr),
	  2 rts_code	fixed bin,
	  2 filler	char (28),
	  2 merge_stack_off_rts
			fixed bin,
	  2 file_n_rts	fixed bin,
	  2 merge_record_ptr_rts
			ptr,
	  2 tree_ptr_rts	ptr,
	  2 comp_ptr_rts	ptr,
	  2 merge_controlp	ptr;

/* static internal data for merge communication stack frame in case the
	merge_comm_stack is destoryed by other rts call.		*/

dcl	1 merge_comm_static static,
	  2 merge_stack_off fixed bin,		/* start offset for record ptr. */
	  2 file_n	fixed bin,		/* no of using file. */
	  2 merge_record_ptr
			ptr,			/* base of record (pointers) */
	  2 tree_ptr	ptr,			/* base of tree (fixed bin)	*/
	  2 comp_ptr	ptr,			/* base of compare entry. */
	  2 merge_seg_ptr	ptr;			/* pointer for cobol_temp_merge_file_. */

/* compare entry	*/

dcl	1 cmp_entry	based (merge_comm_static.comp_ptr),
	  2 merge_compare	entry (ptr, ptr, fixed bin);

/* pointers to the cra of each using file. */

dcl	1 merge_record	based (merge_comm_static.merge_record_ptr),
	  2 record	(merge_comm_static.file_n) ptr;

/* temporary locations for compare usage. */

dcl	1 merge_tree	based (merge_comm_static.tree_ptr),
	  2 tree		(2 * merge_comm_static.file_n - 1) fixed bin,
	  2 compare_code	fixed bin;

/* Automatic data for merge package.	*/

dcl	(i, j, k, w)	fixed bin;



/*	*******************************
	*			*
	*	merge_init	*
	*			*
	*******************************/

rts (30):						/* Initialize the stack frame for merge and trees.	*/
	merge_comm_static.file_n = merge_comm_stack.file_n_rts;
	merge_comm_static.merge_record_ptr = merge_comm_stack.merge_record_ptr_rts;
	merge_comm_static.tree_ptr = merge_comm_stack.tree_ptr_rts;
	merge_comm_static.comp_ptr = merge_comm_stack.comp_ptr_rts;
	controlp = merge_controlp;

	call hcs_$terminate_name ("cobol_temp_merge_file_", temp_mcode);

	if sort_dir_len = 0
	then do;
		sort_dir = get_pdir_ ();
		sort_dir_len = index (sort_dir, " ") - 1;
	     end;

	call hcs_$make_seg (substr (sort_dir, 1, sort_dir_len), "cobol_temp_merge_file_", "cobol_temp_merge_file_",
	     01011b, merge_seg_ptr, temp_mcode);
	call hcs_$truncate_seg (merge_seg_ptr, 0, temp_mcode);

	do i = 1 to merge_comm_static.file_n;
	     merge_tree.tree (i) = i;
	end;

	return;


/*	*******************************
	*			*
	*	merge_comp	*
	*			*
	*******************************/

rts (31):						/* Set up to call merge compare. */
	if merge_comm_static.file_n = 1
	then return;
	do i = 1 by 2 to (2 * merge_comm_static.file_n - 3);
	     call merge_call_compare (i, i + 1);
	end;
	return;



/*	*******************************
	*			*
	*	merge_return	*
	*			*
	*******************************/

rts (32):						/* handle return statement for merge. */
	k = 2 * merge_comm_static.file_n - 1;
	if k = 1
	then return;
	i = tree (k);
	do while (i < k);
	     if mod (i, 2) = 0
	     then j = i - 1;
	     else j = i + 1;
	     call merge_call_compare (i, j);
	     i = w;
	end;
	return;

/*	*******************************************************************************************/

/*		INTERNAL SUBROUTINE FOR MERGE COMPARE SET UP				*/

/*	*******************************************************************************************/

merge_call_compare:
     proc (i, j);

/* This subroutine is used to set up tree on the stack frame through the compare
	entry on the cobol object code.	*/

dcl	(i, j)		fixed bin;

	w = merge_comm_static.file_n + (i + 1) / 2;
	if merge_tree.tree (i) = 0
	then merge_tree.tree (w) = merge_tree.tree (j);	/* eof of file i */
	else if merge_tree.tree (j) = 0
	then merge_tree.tree (w) = merge_tree.tree (i);	/* eof of file j */
	else do;
		call merge_compare (merge_record.record (merge_tree.tree (i)),
		     merge_record.record (merge_tree.tree (j)), merge_tree.compare_code);
		if merge_tree.compare_code = -1
		then merge_tree.tree (w) = merge_tree.tree (i);
		else if merge_tree.compare_code = 1
		then merge_tree.tree (w) = merge_tree.tree (j);
		else if merge_tree.tree (i) < merge_tree.tree (j)
		then merge_tree.tree (w) = merge_tree.tree (i);
		else merge_tree.tree (w) = merge_tree.tree (j);
	     end;
	return;

     end merge_call_compare;



/*	*******************************************************************************************/

/*		END MERGE PACKAGE							*/

/*	*******************************************************************************************/


/*	*******************************************************************************************/

/*		BEGIN COMMUNICATION PACKAGE						*/

/*	*******************************************************************************************/


/*	*******************************
	*			*
	*	receive_comm	*
	*			*
	*******************************/

rts (40):
dcl	1 receive_comm_stack
			based (rts_stack_ptr),
	  2 rts_code	fixed bin,
	  2 filler	fixed bin,
	  2 mcs_icdp	ptr,
	  2 mesp		ptr,
	  2 type		fixed bin,
	  2 max_meslen	fixed bin,
	  2 filler1	fixed bin,
	  2 no_data	fixed bin,
	  2 filler2	char (8),
	  2 code		fixed bin (35);

	if receive_comm_stack.type >= 2
	then do;
		receive_comm_stack.type = receive_comm_stack.type - 2;
		call cobol_mcs_$receive (receive_comm_stack.mcs_icdp, receive_comm_stack.type,
		     receive_comm_stack.mesp, receive_comm_stack.max_meslen, receive_comm_stack.code);
		if receive_comm_stack.code = cmcs_error_table_$no_message
		then do;
			receive_comm_stack.code = 0;
			receive_comm_stack.no_data = 1;
		     end;
		else receive_comm_stack.no_data = 0;
	     end;
	else do;
		call cobol_mcs_$receive_wait (receive_comm_stack.mcs_icdp, receive_comm_stack.type,
		     receive_comm_stack.mesp, receive_comm_stack.max_meslen, receive_comm_stack.code);
	     end;
	return;





/*	*******************************
	*			*
	*	accept_comm	*
	*			*
	*******************************/


rts (41):
dcl	1 accept_comm_stack based (rts_stack_ptr),
	  2 rts_code	fixed bin,
	  2 filler	fixed bin,
	  2 mcs_icdp	ptr,
	  2 filler1	char (32),
	  2 code		fixed bin (35);

	call cobol_mcs_$accept (accept_comm_stack.mcs_icdp, accept_comm_stack.code);
	return;


/*	*******************************
	*			*
	*	purge_comm	*
	*			*
	*******************************/







rts (42):
dcl	1 purge_comm_stack	based (rts_stack_ptr),
	  2 rts_code	fixed bin,
	  2 filler	fixed bin,
	  2 mcs_icdp	ptr,
	  2 filler1	char (32),
	  2 code		fixed bin (35);

	call cobol_mcs_$purge (purge_comm_stack.mcs_icdp, purge_comm_stack.code);
	return;







/*	*******************************
	*			*
	*	send_comm		*
	*			*
	*******************************/

rts (43):
dcl	1 send_comm_stack	based (rts_stack_ptr),
	  2 rts_code	fixed bin,
	  2 filler	fixed bin,
	  2 mcs_ocdp	ptr,
	  2 mesp		ptr,
	  2 max_meslen	char (4),
	  2 end_indicator	char (1),
	  2 filler2	char (3),
	  2 line_control	bit (36),
	  2 filler1	char (12),
	  2 code		fixed bin (35);

	call cobol_mcs_$send (send_comm_stack.mcs_ocdp, send_comm_stack.mesp, send_comm_stack.max_meslen,
	     send_comm_stack.end_indicator, send_comm_stack.line_control, send_comm_stack.code);
	return;




/*	*******************************
	*			*
	*	enable_comm	*
	*			*
	*******************************/

rts (44):
dcl	1 enable_comm_stack based (rts_stack_ptr),
	  2 rts_code	fixed bin,
	  2 filler	fixed bin,
	  2 mcs_icdp	ptr,
	  2 password_ptr	ptr,
	  2 password_length fixed bin,
	  2 in_or_out	fixed bin,
	  2 terminal_flag	fixed bin,
	  2 filler1	char (12),
	  2 code		fixed bin (35);

dcl	password		char (30) based (enable_comm_stack.password_ptr);

	if enable_comm_stack.in_or_out = 0
	then do;
		if enable_comm_stack.terminal_flag = 1
		then call cobol_mcs_$enable_input_terminal (enable_comm_stack.mcs_icdp,
			substr (password, 1, enable_comm_stack.password_length), enable_comm_stack.code);
		else call cobol_mcs_$enable_input_queue (enable_comm_stack.mcs_icdp,
			substr (password, 1, enable_comm_stack.password_length), enable_comm_stack.code);
	     end;
	else call cobol_mcs_$enable_output (enable_comm_stack.mcs_icdp,
		substr (password, 1, enable_comm_stack.password_length), enable_comm_stack.code);
	return;

rts (45):						/* Disable use the same stack as enable.	*/
	if enable_comm_stack.in_or_out = 0
	then do;
		if enable_comm_stack.terminal_flag = 1
		then call cobol_mcs_$disable_input_terminal (enable_comm_stack.mcs_icdp,
			substr (password, 1, enable_comm_stack.password_length), enable_comm_stack.code);
		else call cobol_mcs_$disable_input_queue (enable_comm_stack.mcs_icdp,
			substr (password, 1, enable_comm_stack.password_length), enable_comm_stack.code);
	     end;
	else call cobol_mcs_$disable_output (enable_comm_stack.mcs_icdp,
		substr (password, 1, enable_comm_stack.password_length), enable_comm_stack.code);
	return;



/*


*/
/*	*******************************************************************************************/

/*		BEGIN ALTERNATE RECORD KEY PACKAGE					*/

/*	*******************************************************************************************/




dcl	1 alt_stack_hdr	based (rts_stack_ptr),
	  2 rts_code	fixed bin (35),
	  2 use_code	fixed bin (35),
	  2 iocb_ptr	ptr,
	  2 mcode_ptr	ptr,
	  2 file_rec_buf_ptr
			ptr,
	  2 file_desc_ptr	ptr,
	  2 cobol_open_mode fixed bin (35),
	  2 cobol_options	fixed bin (35),
	  2 vfile_open_mode fixed bin (35),
	  2 key_of_ref	fixed bin (35),
	  2 fsb_ptr	ptr,			/*[5.3-1]*/
	  2 arg2_ptr	ptr,			/*[5.3-1]*/
	  2 arg3_ptr	ptr,			/*[5.3-1]*/
	  2 arg4_ptr	ptr,			/*[5.3-1]*/
	  2 arg5_ptr	ptr;

dcl	1 seek_info,
	  2 relation_type	fixed bin,
	  2 n		fixed bin,
	  2 search_key	char (256);

declare	mode		fixed bin;

/*
	where:

	relation_type	0 =  search_key
			1 >= search_key
			2 >  search_key

	n is the length of the search_key

	search_key is the character string used to match indeies

*/

/*	*******************************************************************************************/

/*		 AUTOMATIC VARIABLES FOR ALTERNATE RECORD KEYS				*/

/*	*******************************************************************************************/


declare	file_record_buffer	char (1000000) based (buff_ptr);
declare	rs_record_buffer	char (1000000) based (rs_info.record_ptr);

dcl	dummy_buffer	char (1);
dcl	char1		char (1);

dcl	rec_len		fixed bin (21);
dcl	save_sw		bit (1);

declare	key_num		fixed bin (35);
declare	(buff_ptr, alt_key_desc_ptr)
			ptr;
declare	KEY_OF_REF	fixed bin static internal;
declare	(CODE, KEY_NUM)	fixed bin (35);
declare	REC_LEN		fixed bin (21);
declare	READ_KEY		char (256) varying;

declare	1 status_info,
	  2 info		aligned like rs_info;

declare	1 GK_INFO,
	  2 HDR		like gk_header,
	  2 KEY		char (256);
declare	1 AK_INFO,
	  2 HDR		like ak_header,
	  2 KEY		char (256);

declare	MCODE		fixed bin (35) based (alt_stack_hdr.mcode_ptr);
						/*[5.3-1]*/
dcl	BUFF_LEN		fixed bin (21) based;	/*[5.3-1]*/
dcl	REC_LGT		fixed bin (21) based;	/*[5.3-1]*/
dcl	BUFF_PTR		ptr;			/*[4.4-1]*/
declare	key_status	(512) bit (1) static internal;

/*	*******************************
	*			*
	*	open		*
	*			*
	*******************************/

rts (46):						/* This label is for the OPEN statement with alternate record keys */
	fsb_ptr = alt_stack_hdr.fsb_ptr;
	fsb.file_desc_ptr = alt_stack_hdr.file_desc_ptr;
	file_desc_1_ptr = fsb.file_desc_ptr;
	fsb.vfile_open_mode = alt_stack_hdr.vfile_open_mode;
	fsb.cobol_open_mode = alt_stack_hdr.cobol_open_mode;
	fsb.last_cobol_op = 1;			/* open */
	alt_stack_hdr.fsb_ptr -> fsb.key_of_ref = 511;	/* prime key */
	fsb.crp.prime_key = "";

/*[5.3-1]*/
	if fsb.fsb_skel.mod1
	then fsb.last_key_read = "";

	if fsb.cobol_open_mode = 29 | /* input(seq) */ fsb.cobol_open_mode = 30
	     | /* input(ran) */ fsb.cobol_open_mode = 31 | /* input(dyn) */ fsb.cobol_open_mode = 45
	     | /* i-o(seq) */ fsb.cobol_open_mode = 46 | /* i-o(ran */ fsb.cobol_open_mode = 47
						/* i-o(dyn) */
	then do;					/* position the file */
		seek_info.relation_type = 0;
		seek_info.n = 1;			/*[4.4-1]*/
		unspec (char1) = "111111111"b;	/*[4.4-1]*/
		seek_info.search_key = char1;

		call iox_$control (fsb.iocb_ptr, "seek_head", addr (seek_info), MCODE);
	     end;
	return;




/*	*******************************
	*			*
	*	close		*
	*			*
	*******************************/


rts (47):						/* This label is for the CLOSE statement with alternate record keys */
						/*[4.4-1]*/
	call set_up;

	fsb.last_cobol_op = 2;			/* close */
						/*[5.3-1]*/
	if fsb.fsb_skel.mod1
	then fsb.last_key_read = "";
	return;



/*	*******************************
	*			*
	*	start		*
	*			*
	*******************************/


rts (48):						/* OP79(start) */
						/*[4.4-1]*/
	call set_up;

	fsb.last_cobol_op = 3;			/* start */
	fsb.key_of_ref = KEY_OF_REF;
	return;




/*	*******************************
	*			*
	*	read next		*
	*			*
	*******************************/


rts (49):						/* OP80(read next) */
						/*[4.4-1]*/
	call set_up;

	fsb.last_cobol_op = 4;			/* read next */
	return;




/*	*******************************
	*			*
	*	read key		*
	*			*
	*******************************/


rts (50):						/* OP(1(read key) */
						/*[4.4-1]*/
	call set_up;

	fsb.last_cobol_op = 5;			/* read key */

	if fsb.cobol_open_mode = 31 /* ind-dyn(i) */ | fsb.cobol_open_mode = 63 /* ind-dyn(o) */
	     | fsb.cobol_open_mode = 47		/* ind-dyn(io) */
	then fsb.key_of_ref = KEY_OF_REF;
	return;



/*	*******************************
	*			*
	*	write		*
	*			*
	*******************************/


rts (51):						/* OP91(write) */
						/*[4.4-1]*/
	call set_up;

	unspec (char1) = "111111111"b;
	buff_ptr = alt_stack_hdr.file_rec_buf_ptr;
	rs_info_ptr = addr (status_info);
	alt_key_desc_ptr = addr (file_desc_1.alt_key (1));

	if fsb.cobol_open_mode = 61			/* output seq */
	then if char1 || substr (fsb.key, 1, fsb.keylen_sw) /* keys not sequential */ <= fsb.crp.prime_key
	     then do;
		     MCODE = error_table_$key_order;
		     return;
		end;

	save_sw = "0"b;

	call save_NRP;

	if fsb.vfile_open_mode ^= 9			/* keyed sequential output */
	then /*[4.4-1]*/
	     do;
		key_len_ptr = addr (vfile_key.size);
		key_ptr = addr (vfile_key.key);

		do key_num = 1 to file_desc_1.alt_key_count;

/*[5.0-1]*/
		     call set_off_sz;

/*[4.4-1]*/
		     call form_alt_key (buff_ptr);	/*[4.4-1]*/
		     call iox_$seek_key (fsb.iocb_ptr, substr (vfile_key.key, 1, vfile_key.size), rec_len, MCODE);

		     if MCODE = 0			/* duplicate exists */
		     then if file_desc_1.alt_key (key_num).size >= 0
			then do;			/* duplicate exists and not legal */
				if save_sw
				then call restore_NRP;

				MCODE = error_table_$key_duplication;
				return;
			     end;

		end;				/*[4.4-1]*/
	     end;
	fsb.key = char1 || substr (fsb.key, 1, fsb.keylen_sw);
	fsb.keylen_sw = fsb.keylen_sw + 1;

	MCODE = 0;

	return;




rts (52):						/* OP87(delete) */
						/*[4.4-1]*/
	call set_up;				/*[4.4-1]*/
	call rec_status;

/*[4.4-1]*/
	if MCODE ^= 0
	then return;

/*[5.3-1]*/
	if fsb.cobol_open_mode = 45			/*[5.3-1]*/
	then if fsb.last_cobol_op ^= 4		/* read */
						/*[5.3-1]*/
	     then do;
		     error_block.status12 = "30";	/*[5.3-1]*/
		     error_block.status3 = "7033";	/*[5.3-1]*/
		     MCODE = error_table_$no_record;	/*[5.3-1]*/
		     return;			/*[5.3-1]*/
		end;


/*[4.4-1]*/
	call init_ak_info ("delete_key");

/*[4.4-1]*/
	do key_num = 1 by 1 to file_desc_1.alt_key_count;

/*[4.4-1]*/
	     call set_off_sz;

/*[4.4-1]*/
	     call process_key (rs_info.record_ptr);

/*[4.4-1]*/
	end;

	MCODE = 0;

	return;



/*	*******************************
	*			*
	*	rewrite		*
	*			*
	*******************************/

rts (61):						/* OP93(rewrite) */
						/*[4.4-1]*/
	call set_up;				/*[4.4-1]*/
	call rec_status;

/*[4.4-1]*/
	if MCODE ^= 0
	then return;

/*[4.4-1]*/
	buff_ptr = alt_stack_hdr.file_rec_buf_ptr;	/*[4.4-1]*/
	alt_key_desc_ptr = addr (file_desc_1.alt_key (1));

/*[4.4-1]*/
	call init_gk_info;
	gk_info.header.reset_pos = "1"b;
	string (key_status) = "0"b;

/*[4.4-1]*/
	do key_num = 1 by 1 to file_desc_1.alt_key_count;

/*[4.4-1]*/
	     call set_off_sz;
	     call keys_unequal;

/*[4.4-1]*/
	     if sz >= 0				/*[4.4-1]*/
	     then if key_comp			/*[4.4-1]*/
		then do;				/*[4.4-1]*/
			call process_key (buff_ptr);	/*[4.4-1]*/
			if MCODE = 0		/*[4.4-1]*/
			then do;
				MCODE = error_table_$key_duplication;
						/*[4.4-1]*/
				return;		/*[4.4-1]*/
			     end;			/*[4.4-1]*/
		     end;

/*[4.4-1]*/
	end;

/*[4.4-1]*/
	call init_ak_info ("delete_key");

/*[4.4-1]*/
	do key_num = 1 by 1 to file_desc_1.alt_key_count;

/*[4.4-1]*/
	     call set_off_sz;

/*[4.4-1]*/
	     if key_status (key_num)
	     then call process_key (rs_info.record_ptr);

/*[4.4-1]*/
	end;

/*[4.4-1]*/
	return;

/*[4.4-1]*/
declare	(sz_abs, sz, off)	fixed bin;		/*[4.4-1]*/
declare	(key_len_ptr, key_ptr, info_ptr)
			ptr;			/*[4.4-1]*/
declare	key_op		char (10);

/*[4.4-1]*/
declare	1 vfile_key,				/*[4.4-1]*/
	  2 size		fixed bin,		/*[4.4-1]*/
	  2 key		char (256);

set_off_sz:
     proc;

/*[4.4-1]*/
	off = file_desc_1.alt_key.offset (key_num) + 1;	/*[4.4-1]*/
	sz = file_desc_1.alt_key.size (key_num);

/*[4.4-1]*/
	sz_abs = abs (sz);

     end;						/*[4.4-1]*/
declare	key_comp		bit (1);
keys_unequal:
     proc;

/*[4.4-1]*/
	if substr (rs_record_buffer, off, sz_abs) ^= substr (file_record_buffer, off, sz_abs)
						/*[4.4-1]*/
	then do;
		key_comp = "1"b;
		key_status (key_num) = "1"b;
	     end;					/*[4.4-1]*/
	else key_comp = "0"b;

     end;

process_key:
     proc (loc);					/* add_key, delete_key, get_key */
						/*[4.4-1]*/
declare	loc		ptr;

/*[4.4-1]*/
	call form_alt_key (loc);			/*[4.4-1]*/
	call iox_$control (fsb.iocb_ptr, key_op, info_ptr, MCODE);

     end;

form_alt_key:
     proc (rec_ptr);

/*[4.4-1]*/
declare	rec_ptr		ptr;			/*[4.4-1]*/
declare	alt_key_num	char (1);

/*[4.4-1]*/
declare	key_len		fixed bin based (key_len_ptr);/*[4.4-1]*/
declare	key		char (256) based (key_ptr);	/*[4.4-1]*/
declare	record		char (1000000) based (rec_ptr);

/*[4.4-1]*/
	key_len = sz_abs + 1;			/*[4.4-1]*/
	unspec (alt_key_num) = substr (unspec (key_num), 28, 9);

/*[4.4-1]*/
	substr (key, 1, key_len) = alt_key_num || substr (record, off, key_len);

     end;

set_up:
     proc;

/*[4.4-1]*/
	fsb_ptr = alt_stack_hdr.fsb_ptr;		/*[4.4-1]*/
	if fsb.fsb_skel.mod1 then
	     file_desc_1_ptr = fsb.file_desc_ptr;
	else if unspec (fsb.file_desc_ptr) = (2) "040040040040"b3 then           /* pre [5.3-1] initialization */
	     file_desc_1_ptr = null ();
	else file_desc_1_ptr = fsb.file_desc_ptr;
     


     end;

rec_status:
     proc;

/*[4.4-1]*/
	call init_rs_info;				/*[4.4-1]*/
	call iox_$control (fsb.iocb_ptr, "record_status", rs_info_ptr, MCODE);

     end;




/*	*******************************
	*			*
	*	delete		*
	*			*
	*******************************/

rts (53):						/* OP86(delete) */
						/*[4.4-1]*/
	call set_up;

	fsb.last_cobol_op = 7;

	return;




/*	*******************************
	*			*
	*	make key read	*
	*			*
	*******************************/

rts (54):						/* OP82(start) */
	mode = 0;

rts54:						/*[4.4-1]*/
	call set_up;

	unspec (char1) = substr (unspec (alt_stack_hdr.key_of_ref), 28, 9);
	call make_key (char1, mode);

	KEY_OF_REF = alt_stack_hdr.key_of_ref;
	return;





/*	*******************************
	*			*
	*	make key write	*
	*			*
	*******************************/


rts (55):						/* OP85(delete,rewrite) */
						/*[4.4-1]*/
	call set_up;

	unspec (char1) = "111111111"b;

	call save_NRP;

/*[4.0-3]*/
	call make_key (char1, 1);

	return;



/*	*******************************
	*			*
	*	add keys		*
	*			*
	*******************************/

rts (56):						/* OP90(write) */
						/*[4.4-1]*/
	call set_up;

	buff_ptr = alt_stack_hdr.file_rec_buf_ptr;

	if fsb.cobol_open_mode = 61
	then fsb.crp.prime_key = substr (fsb.key, 1, fsb.keylen_sw);

/*[4.4-1]*/
	call init_ak_info ("add_key");

/*[4.4-1]*/
	do key_num = 1 by 1 to file_desc_1.alt_key_count;

/*[4.4-1]*/
	     call set_off_sz;

/*[4.4-1]*/
	     call process_key (buff_ptr);

/*[4.4-1]*/
	end;

	fsb.last_cobol_op = 8;			/* write */
	return;




/*	*******************************
	*			*
	*	read restore	*
	*			*
	*******************************/

rts (57):						/* OP92(read) */
						/*[4.4-1]*/
	call set_up;

	rs_info_ptr = addr (status_info);

	if fsb.last_cobol_op = 6 | /* rewrite */ fsb.last_cobol_op = 7 | /* delete */ fsb.last_cobol_op = 8
						/* write */
	then call restore_NRP;

/*[5.1-1]*/
	if MCODE ^= 0
	then return;
	call iox_$read_key (fsb.iocb_ptr, READ_KEY, REC_LEN, CODE);

/*[5.1-1]*/
	if CODE ^= 0				/*[5.1-1]*/
	then MCODE = CODE;				/*[5.1-1]*/
	else call eof_test (addr (READ_KEY));

/*[5.1-1]*/
	return;










/*





/*	*******************************
	*			*
	*	rewrite add keys	*
	*			*
	*******************************/

rts (58):						/* OP88(rewrite) */
						/*[4.4-1]*/
	call set_up;
	buff_ptr = alt_stack_hdr.file_rec_buf_ptr;	/*[4.4-1]*/
	call rec_status;

	if MCODE ^= 0
	then return;

/*[4.4-1]*/
	call init_ak_info ("add_key");

/*[4.4-1]*/
	do key_num = 1 by 1 to file_desc_1.alt_key_count;

/*[4.4-1]*/
	     call set_off_sz;

/*[4.4-1]*/
	     if key_status (key_num)
	     then call process_key (buff_ptr);

/*[4.4-1]*/
	end;

	fsb.last_cobol_op = 6;			/* rewrite */

	return;

rts (59):						/* OP84(read) */
	mode = 1;

	go to rts54;


/*[4.0-2]*/
rts (60):
dcl	rlen		fixed bin (21, 0);
dcl	new_key		char (256) varying;

	call iox_$control (control_iocb_ptr, order_name, iox_control_stack.control_ptr, mcode);

	if mcode = 0
	then call iox_$read_key (control_iocb_ptr, new_key, rlen, mcode);

	if mcode ^= 0
	then do;
		if mcode = error_table_$no_record
		then do;
			error_block.status12 = "23";
			error_block.status3 = "6723"; /*[4.0-1] */
			icode = 4;
		     end;
		else do;
			error_block.status12 = "30";
			error_block.status3 = "6732";
		     end;
		return;
	     end;


	if substr (struc.key, 1, 1) ^= substr (new_key, 1, 1)
	then do;
		mcode = error_table_$no_record;
		error_block.status12 = "23";
		error_block.status3 = "6723";
	     end;

	return;

rts (63):						/* OP65(read) */
						/*[5.3-1]*/
	call set_up;

/*[5.3-1]*/
	BUFF_PTR = alt_stack_hdr.arg2_ptr -> temp_ptr;

/*[5.3-1]*/
	call iox_$read_record /*[5.3-1]*/ (alt_stack_hdr.fsb_ptr -> temp_ptr,
						/* iocb ptr */
						/*[5.3-1]*/
	     BUFF_PTR,				/* buffer ptr */
						/*[5.3-1]*/
	     alt_stack_hdr.arg3_ptr -> BUFF_LEN,	/* buffer length */
						/*[5.3-1]*/
	     alt_stack_hdr.arg4_ptr -> REC_LGT,		/* record length */
						/*[5.3-1]*/
	     alt_stack_hdr.arg5_ptr -> MCODE /* error code */ /*[5.3-1]*/);

/*[5.3-1]*/
	if ^fsb.fsb_skel.mod1 | alt_stack_hdr.arg5_ptr -> MCODE ^= 0
	then return;				/*[5.3-1]*/
	if fsb.cobol_open_mode = 45			/*[5.3-1]*/
	then fsb.last_key_read /*[5.3-1]*/ = substr (BUFF_PTR -> file_record_buffer,
						/*[5.3-1]*/
		file_desc_1.prime_key.offset + 1,	/*[5.3-1]*/
		file_desc_1.prime_key.size /*[5.3-1]*/);

/*[5.3-1]*/
	return;

rts (64):						/* OP59(rewrite) */
						/*[5.3-1]*/
	call set_up;

/*[5.3-1]*/
	if fsb.cobol_open_mode = 45			/* i/o,ind,seq */
						/*[5.3-1]*/
	then do;
		if fsb.last_cobol_op ^= 4		/* must be read */
						/*[5.3-1]*/
		then do;
			error_block.status12 = "30";	/*[5.3-1]*/
			error_block.status3 = "5033";

/*[5.3-1]*/
			return;			/*[5.3-1]*/
		     end;

/*[5.3-1]*/
		BUFF_PTR = alt_stack_hdr.arg2_ptr -> temp_ptr;

/*[5.3-1]*/
		if fsb.fsb_skel.mod1 then  /*[5.3-1]*/ 
		     if /*[5.3-1]*/ fsb.last_key_read /*[5.3-1]*/
		     ^= substr /*[5.3-1]*/ (BUFF_PTR -> file_record_buffer,
						/*[5.3-1]*/
		     file_desc_1.prime_key.offset + 1,	/*[5.3-1]*/
		     file_desc_1.prime_key.size /*[5.3-1]*/)
						/*[5.3-1]*/
		then do;
			error_block.status12 = "30";	/*[5.3-1]*/
			error_block.status3 = "5024";

/*[5.3-1]*/
			alt_stack_hdr.arg5_ptr -> MCODE = error_table_$no_record;

/*[5.3-1]*/
			return;			/*[5.3-1]*/
		     end;				/*[5.3-1]*/
	     end;

/*[5.3-1]*/
	call iox_$rewrite_record /*[5.3-1]*/ (alt_stack_hdr.fsb_ptr -> temp_ptr,
						/* iocb ptr */
						/*[5.3-1]*/
	     BUFF_PTR,				/* buffer ptr */
						/*[5.3-1]*/
	     alt_stack_hdr.arg3_ptr -> REC_LGT,		/* record length */
						/*[5.3-1]*/
	     alt_stack_hdr.arg4_ptr -> MCODE /* error code */ /*[5.3-1]*/);

/*[5.3-1]*/
	return;



/*	*******************************************************************************************/

/*		 ALTERNATE RECORD KEY PACKAGE INTERNAL SUBROUTINES			*/

/*	*******************************************************************************************/

/*[5.1-1]*/
dcl	res		bit (1);

make_key:
     proc (char1, mode);

dcl	p		ptr,
	mode		fixed bin,
	char1		char (1);

dcl	1 SEEK_KEY	based (p),
	  2 rel		fixed bin,
	  2 n		fixed bin,
	  2 seek_key	char (256);

declare	1 SK		based (p),
	  2 n		fixed bin,
	  2 seek_key	char (256);

	p = alt_stack_hdr.iocb_ptr;

	if mode = 0
	then do;
		substr (SEEK_KEY.seek_key, 1, SEEK_KEY.n + 1) = char1 || substr (SEEK_KEY.seek_key, 1, SEEK_KEY.n);
		SEEK_KEY.n = SEEK_KEY.n + 1;
	     end;
	else do;
		substr (SK.seek_key, 1, SK.n + 1) = char1 || substr (SK.seek_key, 1, SK.n);
		SK.n = SK.n + 1;
	     end;

     end make_key;


/*[4.4-1]*/
declare	read_key_key	char (256) varying;

save_NRP:
     proc;


	if (fsb.cobol_open_mode = 45 | /* i-o(seq) */ fsb.cobol_open_mode = 46
	     | /* i-o(ran) */ fsb.cobol_open_mode = 47 /* i-o(dyn ) */)
	     &
	     /*[5.1-1]*/ (fsb.last_cobol_op = 1 | /* open */ fsb.last_cobol_op = 3 | /* start */ fsb.last_cobol_op = 4
	     | /* read next */ fsb.last_cobol_op = 5 /* read key */ /*[5.1-1]*/)
	then do;					/* save the keys for the next record */
		call iox_$read_key (fsb.iocb_ptr, read_key_key, rec_len, MCODE);
		save_sw = "1"b;

		if MCODE = error_table_$end_of_info
		then fsb.crp.prime_key = "";
		else if MCODE = error_table_$no_record
		then fsb.crp.prime_key = "";
		else do;

/*[5.1-1]*/
			call eof_test (addr (read_key_key));
						/*[5.1-1]*/
			if MCODE ^= 0		/*[5.1-1]*/
			then do;
				fsb.crp.prime_key = "";
						/*[5.1-1]*/
				return;		/*[5.1-1]*/
			     end;

/*[4.4-1]*/
			call rec_status;		/*[4.4-1]*/
			if MCODE ^= 0
			then return;

			fsb.crp.prime_key =
			     substr (rs_record_buffer, (file_desc_1.prime_key.offset + 1),
			     file_desc_1.prime_key.size);

/*[4.4-1]*/
			key_num = fsb.key_of_ref;
			call set_off_sz;

/*[4.4-1]*/
			if key_num ^= 511
			then do;

				fsb.crp.alt_key = substr (rs_record_buffer,
						/*[4.4-1]*/
				     off,		/*[4.4-1]*/
				     sz_abs);

			     end;

			fsb.crp.descriptor = rs_info.descriptor;
		     end;

	     end;

     end save_NRP;

restore_NRP:
     proc;

declare	key_len		fixed bin,
	key_ptr		ptr;			/*[4.0-3]*/
declare	key_string	char (512) varying based (key_ptr);

	if fsb.crp.prime_key = ""
	then do;
		MCODE = error_table_$end_of_info;
		return;
	     end;

	if fsb.key_of_ref = 511
	then do;
		key_len = length (fsb.prime_key) + 1;
		key_ptr = addr (fsb.prime_key);
	     end;
	else do;
		key_len = length (fsb.alt_key) + 1;
		key_ptr = addr (fsb.alt_key);
	     end;

	unspec (char1) = substr (unspec (fsb.key_of_ref), 28, 9);

/*[5.1-1]*/
	if fsb.key_of_ref = 511 /* prime key */ /*[5.1-1]*/ | /*[5.1-1]*/ file_desc_1.alt_key.size (fsb.key_of_ref) >= 0
						/* dupl illeg */
						/*[5.1-1]*/
	then res = "1"b;				/*[5.1-1]*/
	else res = "0"b;

/*[5.1-1]*/
	if res					/*[5.1-1]*/
	then do;

		call init_gk_info;

		gk_info.header.descrip = fsb.crp.descriptor;
		gk_info.header.key_len = key_len + 1;
		gk_info.key = char1 || substr (key_string, 1, key_len);


		gk_info.flags.position_specification.head_size = gk_info.header.key_len;

		call iox_$control (fsb.iocb_ptr, "get_key", gk_info_ptr, MCODE);

		if MCODE = 0
		then return;

	     end;

	seek_info.relation_type = 1;			/* >= */
	seek_info.n = key_len + 1;
	seek_info.search_key = char1 || substr (key_string, 1, key_len);

/*[5.1-1]*/
	call iox_sh;

	if MCODE ^= 0
	then do;
		MCODE = error_table_$end_of_info;
		return;
	     end;

	if res
	then return;

/*[4.4-1]*/
	call rec_status;

/*[5.1-1]*/
	if MCODE ^= 0
	then return;





/*[5.1-1]*/
	call key_compare;

/*[5.1-1]*/
	if res
	then return;


	i = 1;

	do while ("1"b);

/*[5.1-1]*/
	     call iox_rr;

	     if MCODE = error_table_$long_record
	     then MCODE = 0;
	     else if MCODE ^= 0
	     then return;

/*[4.4-1]*/
	     call rec_status;

	     if MCODE ^= 0
	     then return;










/*[5.1-1]*/
	     call key_compare;

/*[5.1-1]*/
	     if res
	     then do;

/*[5.1-1]*/
		     call iox_sh;

		     if MCODE ^= 0
		     then return;


		     do j = 1 to i - 1 by 1;

/*[5.1-1]*/
			call iox_rr;


			if MCODE = error_table_$long_record
			then MCODE = 0;
			else if MCODE ^= 0
			then return;

		     end;

		     return;

		end;

	     i = i + 1;

	end;

     end restore_NRP;




init_rs_info:
     proc;					/* record_status */
						/*[4.4-1]*/
	rs_info_ptr = addr (status_info);

	rs_info.version = rs_info_version_2;
	rs_info.lock_sw = "0"b;
	rs_info.unlock_sw = "0"b;
	rs_info.create_sw = "0"b;
	rs_info.locate_sw = "0"b;
	rs_info.inc_ref_count = "0"b;
	rs_info.dec_ref_count = "0"b;
	rs_info.locate_pos_sw = "0"b;
	rs_info.mbz1 = "0"b;
	rs_info.mbz2 = 0;
	rs_info.descriptor = 0;

     end init_rs_info;

init_gk_info:
     proc;

/*[4.4-1]*/
	gk_info_ptr = addr (GK_INFO);

/*[4.4-1]*/
	key_len_ptr = addr (gk_info.header.key_len);	/*[4.4-1]*/
	key_ptr = addr (gk_info.key);			/*[4.4-1]*/
	key_op = "get_key";				/*[4.4-1]*/
	info_ptr = gk_info_ptr;

	gk_info.header.flags.input_key = "1"b;
	gk_info.header.flags.input_desc = "1"b;
	gk_info.header.version = gk_info_version_0;
	gk_info.header.flags.position_specification.rel_type = 0;
						/* = */
	gk_info.header.flags.reset_pos = "0"b;
	gk_info.header.pad = "0"b;

     end;

init_ak_info:
     proc (op);					/* add_key, delete_key */
						/*[4.4-1]*/
declare	op		char (*);

/*[4.4-1]*/
	ak_info_ptr = addr (AK_INFO);

/*[4.4-1]*/
	key_len_ptr = addr (ak_info.header.key_len);	/*[4.4-1]*/
	key_ptr = addr (ak_info.key);			/*[4.4-1]*/
	key_op = op;				/*[4.4-1]*/
	info_ptr = ak_info_ptr;

/*[4.4-1]*/
	ak_info.header.input_key = "1"b;		/*[4.4-1]*/
	ak_info.header.descrip = 0b;			/*[4.4-1]*/
	ak_info.header.mbz = "0"b;

     end;

key_compare:
     proc;

/*[5.1-1]*/
	if substr /*[5.1-1]*/ (rs_record_buffer,	/*[5.1-1]*/
	     file_desc_1.alt_key.offset (fsb.key_of_ref) + 1,
						/*[5.1-1]*/
	     abs (file_desc_1.alt_key.size (fsb.key_of_ref)) /*[5.1-1]*/) /*[5.1-1]*/ ^= fsb.crp.alt_key /*[5.1-1]*/
	     | /*[5.1-1]*/ substr /*[5.1-1]*/ (rs_record_buffer,
						/*[5.1-1]*/
	     file_desc_1.prime_key.offset + 1,		/*[5.1-1]*/
	     file_desc_1.prime_key.size /*[5.1-1]*/) /*[5.1-1]*/ = fsb.crp.prime_key
						/*[5.1-1]*/
	then res = "1"b;				/*[5.1-1]*/
	else res = "0"b;

     end;

iox_sh:
     proc;

/*[5.1-1]*/
	call iox_$control (fsb.iocb_ptr, "seek_head", addr (seek_info), MCODE);

     end;

iox_rr:
     proc;

/*[5.1-1]*/
	call iox_$read_record (fsb.iocb_ptr, addr (dummy_buffer), 1, rec_len, MCODE);

     end;

eof_test:
     proc (key_loc);

/*[5.1-1]*/
dcl	key_loc		ptr;			/*[5.1-1]*/
dcl	key_str		char (256) varying based (key_loc);

/*[5.1-1]*/
	KEY_NUM = 0;				/*[5.1-1]*/
	substr (unspec (KEY_NUM), 28, 9) = unspec (substr (key_str, 1, 1));

/*[5.1-1]*/
	if KEY_NUM ^= fsb.key_of_ref
	then MCODE = error_table_$end_of_info;
	else MCODE = 0;

     end;



/*	Please insert the next run time package before this line.	*/





/* EXTERNAL_NAMES */

dcl	iox_$user_input	ptr ext;


dcl	cobol_error_	entry (fixed bin, fixed bin (35), fixed bin, fixed bin, char (*), ptr);
dcl	cobol_error_$use	entry (fixed bin, fixed bin (35), fixed bin, fixed bin, char (*), ptr);
dcl	cobol_control_$cobol_rts_control_
			entry (ptr);

dcl	sort_$initiate	entry (char (*), ptr, ptr, char (*), float bin (27), fixed bin (35));
dcl	sort_$noexit	entry ext;


dcl	error_table_$end_of_info
			fixed bin (35) ext;
dcl	error_table_$key_duplication
			fixed bin (35) ext;
dcl	error_table_$long_record
			fixed bin (35) ext;
dcl	error_table_$short_record
			fixed bin (35) ext;
dcl	error_table_$no_record
			fixed bin (35) external;
dcl	error_table_$key_order
			fixed bin (35) external;
dcl	error_table_$incompatible_attach
			fixed bin (35) external;
dcl	error_table_$noentry
			fixed bin (35) external;
dcl	error_table_$file_busy
			fixed bin (35) external;
dcl	error_table_$no_operation
			fixed bin (35) external;
dcl	error_table_$bad_file
			fixed bin (35) external;

dcl	sort_$return	entry (ptr, fixed bin (21), fixed bin (35));

dcl	sort_$terminate	entry (fixed bin (35));

dcl	sort_$commence	entry (fixed bin (35));

dcl	cu_$cl		entry;

dcl	cobol_stop_run_	entry (ptr, fixed bin, fixed bin, fixed bin),
	signal_		entry (char (*), ptr, ptr);
declare	iox_$attach_ptr	entry (ptr, char (*), ptr, fixed bin (35));
declare	iox_$control	entry (ptr, char (*), ptr, fixed bin (35));
declare	iox_$find_iocb	entry (char (*), ptr, fixed bin (35));
declare	iox_$get_line	entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
declare	iox_$read_key	entry (ptr, char (256) varying, fixed bin (21), fixed bin (35));
declare	iox_$read_record	entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
declare	iox_$rewrite_record entry (ptr, ptr, fixed bin (21), fixed bin (35));
declare	iox_$seek_key	entry (ptr, char (256) varying, fixed bin (21), fixed bin (35));

dcl	cobol_control_$cancel
			entry (char (*), fixed bin, fixed bin, fixed bin);


dcl	clock_		entry returns (fixed bin (71)),
	date_time_	entry (fixed bin (71), char (*)),
	decode_clock_value_ entry (fixed bin (71), fixed bin, fixed bin, fixed bin, fixed bin (71), fixed bin,
			char (4) aligned);

dcl	cobol_su_$tally	entry (ptr, fixed bin),
	cobol_su_$replace	entry (ptr);

dcl	hcs_$terminate_name entry (char (*), fixed bin (35));
dcl	get_pdir_		entry returns (char (168));
dcl	hcs_$make_seg	entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
dcl	hcs_$truncate_seg	entry (ptr, fixed bin (18), fixed bin (35));

dcl	cobol_mcs_$receive	entry (ptr, fixed bin, ptr, fixed bin, fixed bin (35)),
	cobol_mcs_$receive_wait
			entry (ptr, fixed bin, ptr, fixed bin, fixed bin (35));

dcl	cmcs_error_table_$no_message
			fixed bin (35) ext;

dcl	cobol_mcs_$accept	entry (ptr, fixed bin (35));

dcl	cobol_mcs_$purge	entry (ptr, fixed bin (35));

dcl	cobol_mcs_$send	entry (ptr, ptr, char (4), char (1), bit (36), fixed bin (35));

dcl	cobol_mcs_$enable_input_terminal
			entry (ptr, char (*), fixed bin (35)),
	cobol_mcs_$enable_input_queue
			entry (ptr, char (*), fixed bin (35)),
	cobol_mcs_$enable_output
			entry (ptr, char (*), fixed bin (35));


dcl	cobol_mcs_$disable_input_terminal
			entry (ptr, char (*), fixed bin (35)),
	cobol_mcs_$disable_input_queue
			entry (ptr, char (*), fixed bin (35)),
	cobol_mcs_$disable_output
			entry (ptr, char (*), fixed bin (35));

/* BUILTIN FUNCTIONS */

dcl	(substr, mod, abs, addr, addrel, length, string, unspec, null, index)
			builtin;

%include cobol_stack_frame;
%include cobol_control;
%include cobol_fixed_static;
%include cobol_fsb_type_1;
%include cobol_fsbskel;
%include cobol_file_desc_1;
%include rs_info;
%include ak_info;
     end cobol_rts_;
