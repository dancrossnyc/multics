/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
   *                                                         *
   *********************************************************** */
/* format: style1,^inddcls,ind4 */
gcos_tss_build_library: gtbl: proc;
/****	Build or update the GTSS fast load software library from
	all or selected parts of GCOS	software files (native or GES)
          and update the GTSS	program descriptors. 

          Based on the command "gcos_lib_obtain_modules" or "glom"

 Usage: gtbl INPUT_LIBS {-control_args}

           INPUT_LIBS  are paths of one or more gcos software files
                       the files may be either native GCOS or simulator format
           -control_args :=  -module_file PATH, -mf PATH
                                         a segment containing a list of modules
                                          to be moved from INPUT_LIBS to output
                             -modules STR..., -mods STR...
                                         names of modules to be moved
                             -program_descriptors PATH, -prgdes PATH
                                         path of a gtss_prgdes_alm_.incl.alm to be updated 
                             -output_library PATH, -olb PATH
                                         path of the gtss_fast_library_
                             -print_catalog, -prcat
                                         print contents of GES format INPUT_LIBS
                             -brief, -bf
                                         don't print catalog or modules moved


  Created:  Dave Ward    78-04-18  As glom
 Modified:  Ron Barstad  83-03-03  1.0 Changed name to gtbl, added version 1.0
                                   Changed to standard or current conventions
                                   Changed command line
                                       -cf to -module_file
                                       -nm to -modules
                                       -ol to -output_library
                                       -no_cat to -format
                                       added -program_descriptors
                                       deleted -olli
                                   Changed reference to XIO to gcos_xio_
                                   Changed reference to HASH to gfms_hash_
                                   Moved inits from dcl to procedure
                                   Changed gtss_bcd_ascii_ calls to gfms_bcd_ascii_
                                   Fixed msf boundry bug, each object wholly contained in a segment.
                                   Added prgdes update functionality
  

 Modified:  Ron Barstad  83-04-14  1.1 Removed need for -format, determine this
                                       by inspection
*/
%page;
/****  P R O C E D U R E  */

        call cu_$arg_count (nargs, e);
        if e = 0 & nargs < 1 then e = error_table_$noarg;
        if e ^= 0 then do;
	      call com_err_ (e, ME, "^/Usage: gtbl INPUT_LIBS {-control_args}");
	      return;
	  end;
        on condition (cleanup) call closer;

/**** Initialize */
/* format: off */
   	all_mods		= TRUE;
   	brief		= FALSE;
   	get_mod_name	= FALSE;
   	need_1_mod_name	= FALSE;
   	no_cat		= FALSE;
   	prgdes		= FALSE;
   	open_prgdes	= FALSE;
	have_output_lib     = FALSE;
	process_mf          = FALSE;
          process_ol          = FALSE;
   	pr_cat		= FALSE;

   	catl		= 1000; /* length of catalog at front of GES format lib. */
   	catl_parm		= 0;
   	cc		= -1;
	copy_names.start    = 0;
   	dcwbc		= 0;
   	init_nm		= 0;
   	libc		= 0;
	msw                 = sys_info$max_seg_size; 
   	ndcw		= 1;
   	obj_num		= 0;
	outc                = -1;
	outl                = 0;
   	wdl		= 0;
          copy_names.nm	= 0;
          lib_stack.libn	= 0;

   	input_lib_path	= "NONE";
   	output_lib_path	= "NONE";
	path                = "NONE";
   	prgdes_path	= "NO_PRGDES";

	mf_fcbp            = null();
	lib_fcbp            = null();
	out_fcbp            = null();
   	prgdes_fcbp	= null();
   	outp		= null();
   	dcwbp		= null();
   	eo_word_loc	= null();
   	reloc_word_loc	= null();
   	rd_word_loc	= null();
   	dcw_loc		= null();

	call date_time_ (clock_(), run_date);
/* format: on */
%page;
/* Process command line */

        do arg_num = 1 to nargs;
	  call cu_$arg_ptr (arg_num, ap, al, e);
	  if e ^= 0 then do;
		call com_err_ (e, ME, "Argument ^i", arg_num);
		goto close_files;
	      end;
	  if al < 1 then do;
		call com_err_ (error_table_$bad_arg, ME, "Zero length parameter (^i). Quitting.", arg_num);
		goto close_files;
	      end;
	  if substr (arg, 1, 1) = "-" then get_mod_name = FALSE;
	  if get_mod_name then do;
		need_1_mod_name = FALSE;		/* Regulates reporting name missing. */
		call next_mod_name (ap, al);
	      end;
	  else
	       if process_mf then call get_module_file;	/* Obtain control file and names therein. */
	  else
	       if process_ol then call get_out_lib;	/* Obtain output file. */
	  else
	       if open_prgdes then call get_prgdes_file;
	  else
	       if (arg = "-prgdes") | (arg = "-program_descriptors") then open_prgdes = TRUE;
	  else
	       if (arg = "-bf") | (arg = "-brief") then brief = TRUE;
	  else
	       if (arg = "-module_file") | (arg = "-mf") then process_mf = TRUE;
	  else
	       if (arg = "-output_library") | (arg = "-olb") then process_ol = TRUE;
	  else
	       if (arg = "-print_catalog") | (arg = "-prcat") then pr_cat = TRUE;
	  else
	       if (arg = "-modules") | (arg = "-mods") | (arg = "-module") | (arg = "-mod")
	  then get_mod_name, need_1_mod_name = TRUE;
	  else
	       if substr (arg, 1, 1) = "-" then do;
		call com_err_ (error_table_$badopt, ME,
		    "Unknown option ""^a"". Quitting.", arg);
		goto close_files;
	      end;
	  else
	       call stack_lib_path;
        end;
%page;
/****	Verify that caller's parameters are acceptable.	*/
        if libn < 1 then do;
	      call com_err_ (error_table_$noarg, ME, "At least one input library must be specified. Quitting.");
	      goto close_files;
	  end;
        if need_1_mod_name then do;
	      call com_err_ (error_table_$noarg, ME, "Missing module name for -modules. Quitting.");
	      goto close_files;
	  end;
        if open_prgdes then do;
	      call com_err_ (error_table_$noarg, ME, "No path supplied for -prgdes. Quitting.");
	      goto close_files;
	  end;
        if process_mf then do;
	      call com_err_ (error_table_$noarg, ME, "No module path supplied for -module_file. Quitting.");
	      goto close_files;
	  end;
        if process_ol then do;
	      call com_err_ (error_table_$noarg, ME, "Missing output path for -output_library. Quitting.");
	      goto close_files;
	  end;

/**** check for some possibly incompatable parameters */
        if prgdes & ^have_output_lib
        then call ioa_$ioa_stream ("error_output",
	       "^/Warning: no output library was specified, the program descriptors will not be updated.");
        else if ^prgdes & have_output_lib
        then call ioa_$ioa_stream ("error_output",
	       "^/Warning: the output library will be updated but no program descriptor file was specified.");

/**** give run date_time */
        if prgdes then call ioa_ ("Updated program descriptors will be labeled ""^a"".", run_date);
%page;
/****	Process input  libraries.	*/
        max_dcw_count = 2 ** length (addr (i) -> dcw.count);/* Constant => if count=0. */
        init_nm = nm;
        if nm > 0 then all_mods = FALSE;		/* Specific modules selected. */
        libc = 0;					/* Current library. */

next_input_library: ;
        libc = libc + 1;
        if libc > libn then do;			/* All input libraries processed. */
	      if nm > 0 then do;
		    if nm = 1 then
		         call ioa_$ioa_stream ("error_output",
			   "Specified module not found on input libraries.");
		    else
		         call ioa_$ioa_stream ("error_output",
			   "^i specified modules not found on input libraries.", nm);
		    if ^brief then do;
			  j = 0;
			  do k = 1 to init_nm;
			      if link (k) > -1 then do;
				    j = j + 1;
				    call ioa_$ioa_stream ("error_output", "^4i. ""^a""", j, mod_name (k));
				end;
			  end;
		        end;
		end;
	      goto close_files;
	  end;
        if get_input_lib () then goto next_input_library;	/* Could not obtain it. */
        /*** look at the first word of the library to see if it is native gcos or simulator format */
        if cp (0) -> just_a_word = "0"b
        then catl = 1000;				/* simulator library */
        else catl = 0;				/* native gcos format */
        if pr_cat then call print_catalog;
        if (brief) & (out_fcbp = null ()) & (nm = 0) then goto next_input_library;

next_dcw_block: ;
        fw = fw + obj_len;
        rl = rl - obj_len;
        if rl > 0 then dcwbp = addrel (dcwbp, obj_len);
        else
	   if word (catl + fw, dcwbp, rl, cc) then goto next_input_library;

        /***	Obtain pointer to relocation bit word (3).	*/
        call get_dcw_block_word (3, reloc_word_loc);

        /***	Locate name field on dcw block record. (4th word). */
        call get_dcw_block_word (4, name_loc);
        call gfms_bcd_ascii_ (name_loc, 6, addr (name_chars));
        dcwbc = dcwbc + 1;				/* Count of dcw blocks. */
        nl = search (name_chars, " ") - 1;
        if nl < 0 then nl = length (name_chars);

        call calculate_object_length (obj_len, total_dcw_count, initial_load_address);
        if obj_len < 1 then do;
	      if (fw = 1) & (catl ^= 0) then do;
		    call ioa_$ioa_stream ("error_output",
		        "Attempting native GCOS format for ""^a"".", input_lib_path);
		    rl, obj_len, catl = 0;
		    goto next_dcw_block;
		end;
	      call com_err_ (error_table_$improper_data_format, ME,
		"Object length calculation negative for ""^a"". Library ""^a"" skipped.",
		name_chars, input_lib_path);
	      goto next_input_library;
	  end;

        if all_mods then f = TRUE;
        else
	   f = lookup (obj_name);
        if f then do;				/* Object named in input library is a
						   module caller specified. */
	      if ^have_output_lib
	      then do;
		    if ^brief then call ioa_ ("Found module ""^a"" in ^a.", name_chars, input_lib_path);
		end;
	      else do;				/* have output lib */
		    if ^prgdes
		    then call copy_obj;
		    else do;			/* have prgdes */
			  if 0 = index (substr (prgdes_seg, start_prgdes, end_prgdes - start_prgdes), "," || obj_name)
			  then do;		/* but prgdes doesn't have module */
				if ^brief
				then call ioa_ (
				         "Call name ""^a"" not found in ^a. Did not add module to ^a.",
				         name_chars, prgdes_path, output_lib_path);
			      end;
			  else /* have out lib, prgdes, and call name */
			       call copy_obj;
		        end;
		end;
/**** debug */  if Debug then do;
		    obj_num = obj_num + 1;
		    if obj_num = 1 then do;		/* Output header. */
			  call ioa_ (
			      "^15xOBJECT   DATA  RELOC");
			  call ioa_ (
			      "^7xNAME^3x^3(  WORDS^)^3xDCWS OBJECT   COMP REMAIN PATH");
		        end;
		    call ioa_ (
		        "^4i. ""^a""^vx^7(^1x^6i^) ^a"
		        , obj_num			/** Count of objects found. */
		        , name_chars		/** Name of object. */
		        , max (0, 6 - nl)		/** Align next field. */
		        , obj_len			/** No. words in object. */
		        , data_wds			/** No. data words. */
		        , reloc_wds			/** No. relocation words. */
		        , ndcw			/** No. DCW's. */
		        , dcwbc			/** Which object on library. */
		        , cc			/** Which msf component of library. */
		        , rl			/** Words remaining in component. */
		        , input_lib_path		/** Multics file name of library. */
		        );
		end;
	  end;
        if all_mods then goto next_dcw_block;
        if nm > 0 then goto next_dcw_block;

close_files: ;
        call closer;
        return;
%page;
db: entry;
        Debug = ^Debug;
        return;
dcl     Debug		 bit (1) static int init ("0"b);
%page;
/**** Command line processing procedures */
get_module_file: proc;
        e = open_file (arg, mf_fcbp);
        if mf_fcbp ^= null () then
	   call msf_manager_$get_ptr (mf_fcbp, 0, USE_EXISTING_COMPONENTS, mfp, mfl, e);
        if e ^= 0 then do;
	      call com_err_ (e, ME, "Module file ""^a"". Quitting.", path);
	      goto close_files;
	  end;
        mfl = divide (mfl, 9, 24, 0);			/* Number characters in control file. */
        process_mf = FALSE;
        j = 1;
        do while (j <= mfl);
	  k = search (substr (mf, j), NL);
	  if k < 1 then k = mfl - j + 2;
	  if k > 1 then call next_mod_name (addr (mfa (j)), k - 1);
	  j = j + k;
        end;
    end get_module_file;
%page;
get_prgdes_file: proc;
        if prgdes then do;
	      call com_err_ (error_table_$inconsistent, ME,
		"File ""^a"" already open for prgdes. Quitting.", prgdes_path);
	      goto close_files;
	  end;
        prgdes_path = arg;
        call expand_pathname_ (prgdes_path, prgdes_dir, prgdes_entry, e);
        if e ^= 0 then goto bad_prgdes_path;
        call initiate_file_ (prgdes_dir, prgdes_entry, RW_ACCESS, prgdes_seg_ptr, prgdes_bit_count, e);
        if e ^= 0 then do;
bad_prgdes_path: call com_err_ (e, ME, "^/Program descriptor file ""^a"" not available. Quitting.", prgdes_path);
	      goto close_files;
	  end;
        prgdes_seg_size = divide (prgdes_bit_count, 9, 24);
        start_prgdes = index (prgdes_seg, "Program descriptor 1.") + 22;
        end_prgdes = index (prgdes_seg, "Program descriptor end.");
        reverse_PRGDES = reverse ("PRGDES  ");
        reverse_prog_desc = reverse ("Program descriptor ");
        open_prgdes = FALSE;
        prgdes = TRUE;
        return;
    end get_prgdes_file;
%page;
get_out_lib: proc;
        if out_fcbp ^= null () then do;
	      call com_err_ (error_table_$inconsistent, ME,
		"Output library ""^a"" already open. Quitting.", output_lib_path);
	      goto close_files;
	  end;
        process_ol = FALSE;
        have_output_lib = TRUE;
        e = open_file (arg, out_fcbp);
        output_lib_path = path;
        if e ^= 0 then
	   if e = error_table_$noentry then do;		/* New output. */
		 outc = -1;			/* so first output component will be 0 */
		 call next_out_comp;
		 outp -> fast_lib_header.id = "gtssflib";
		 outp -> fast_lib_header.num_objects = 0;
		 outl = FAST_LIB_HEADER_LENGTH;	/* Position past the header. */
		 return;
	       end;
	   else do;
out_fail:		 ;
		 call com_err_ (e, ME,
		     "Could not obtain output ""^a"". Quitting.", output_lib_path);
		 goto close_files;
	       end;
        last_outc, outc = 0;				/* init output msf component */
        e = 0;
        do while (e = 0);				/* Position to the end of the output library. */
	  call msf_manager_$get_ptr (out_fcbp, outc, USE_EXISTING_COMPONENTS, outp, outl, e);
	  if outc = 0 then
	       if outp -> fast_lib_header.id ^= "gtssflib" then do;
		     call com_err_ (error_table_$improper_data_format, ME,
		         "Output library ""^a"" header not ""gtssflib"". Quitting.",
		         output_lib_path);
		     goto close_files;
		 end;
	  if e = 0 then do;
		last_outc = outc;
		last_outl = outl;
		last_outp = outp;
		outc = outc + 1;
	      end;
	  else
	       if e ^= error_table_$noentry then goto out_fail;
        end;
        outc = last_outc;
        outp = last_outp;
        outl = last_outl;
        if mod (outl, 36) ^= 0 then do;
	      call com_err_ (e, ME,
		"Component ^i of msf ""^a"" bit count (^i) not modulo 36. Quitting.",
		outc, output_lib_path, outl);
	      goto close_files;
	  end;
        outl = divide (outl, 36, 24, 0);
        return;

dcl     e			 fixed bin (35);		/* error code */
dcl     last_outc		 fixed bin (24);
dcl     last_outl		 fixed bin (24);
dcl     last_outp		 ptr;
    end get_out_lib;
%page;
stack_lib_path: proc;
/****	Stack pointer to and length of library pathname. */
        libn = libn + 1;
        if libn > hbound (input_lib, 1) then do;
	      if (libn - 1) = hbound (input_lib, 1) then
		 call com_err_ (error_table_$too_many_names, ME,
		     "Only provision for ^i input libraries. None starting with ""^a"" used.",
		     hbound (input_lib, 1), arg);
	  end;
        else do;
	      lib_name_loc (libn) = ap;
	      lib_name_len (libn) = al;
	  end;
        return;

    end stack_lib_path;
%page;
/**** Main procedures */
calculate_object_length: proc (ol, tc, da);
/****	 Set parameter (ol) to the total length of the next input
	library object, i.e., length of dcw block (6 + number of dcw's)
	plus the length of object data words and relocation words.
	Set parameter (tc) to the total of the dcw count fields values.
	Set parameter (da) to data address in first DCW.
 */
dcl     ol		 fixed bin (24) parm;	/* object length */
dcl     tc		 fixed bin (24) parm;	/* total count, dcw content fields */
dcl     da		 fixed bin (24) parm;	/* data address */

        call get_dcw_block_word (6, rd_word_loc);		/* Obtain pointer to reloc/data words. */
        ndcw = 0;					/* Count of DCW's. */
        t = 0;					/* Totoal of DCW counts. */
        done_with_dcws = FALSE;
        do dcw_index = 1 to 58 while (done_with_dcws = FALSE);
	  call get_dcw_block_word (6 + dcw_index, dcw_loc);
	  ndcw = ndcw + 1;
	  if count then t = t + fixed (count);
	  else t = t + max_dcw_count;
	  if dcw_index = 1 then da = fixed (data_address);
	  if action = "000"b then done_with_dcws = TRUE;
        end;
        tc = t;
        ol = 6 + reloc_wds + data_wds + ndcw;
        return;

dcl     dcw_index		 fixed bin (24);
dcl     done_with_dcws	 bit (1);
dcl     t			 fixed bin (24);		/* total count */
    end calculate_object_length;
%page;
closer: proc;
/****	Release spaces for file control blocks and terminate files. */

        if lib_fcbp ^= null () then
	   call msf_manager_$close (lib_fcbp);
        if out_fcbp ^= null () then do;
	      /***	Set count of objects in file header.	*/
	      call msf_manager_$get_ptr (out_fcbp, 0, USE_EXISTING_COMPONENTS, outp, (outl), e);
	      if e ^= 0 then
		 call com_err_ (e, ME,
		     "Unable to store number of objects (^i) in header.", obj_num);
	      else
		 outp -> fast_lib_header.num_objects = outp -> fast_lib_header.num_objects + obj_num;
	      call msf_manager_$adjust (out_fcbp, outc, outl * 36, "111"b, e);
	      if e ^= 0 then
		 call com_err_ (e, ME,
		     "Setting bit count to ^i words for ""^a"", component ^i", outl, output_lib_path, outc);
	      call msf_manager_$close (out_fcbp);
	  end;
        if mf_fcbp ^= null () then
	   call msf_manager_$close (mf_fcbp);
        if prgdes then do;
	      prgdes_bit_count = prgdes_seg_size * 9;	/* 9 bits to a byte */
	      call terminate_file_ (prgdes_seg_ptr, prgdes_bit_count, TERM_FILE_TRUNC_BC_TERM, e); /* e doesn't matter*/
	  end;
        return;
    end closer;
%page;
copy_obj: proc;
/****	Copy to the output library.	*/

calc_out_length: ;
        if (msw - outl - OBJECT_HEADER_LENGTH - obj_len) < 1 then do;
	      call next_out_comp;
	      goto calc_out_length;
	  end;
        out_length = msw - outl;			/* Words remaining in current output component. */

        /***	Output object header. */
        out_ptr = addr (out (outl + 1));		/* Pointer to next output word. */
        out_ptr -> object_header.marker = MARKER;
        out_ptr -> object_header.obj_name = obj_name;
        out_ptr -> object_header.obj_len_wds = obj_len;
        out_ptr = addr (out_ptr -> object_header.obj_word1);
        out_length = out_length - OBJECT_HEADER_LENGTH;
        f, outl = outl + OBJECT_HEADER_LENGTH;
        out_ptr = addr (out (outl + 1));		/* Pointer to next output word. */

        in_ptr = dcwbp;				/* Pointer to next input word. */
        remain_words = rl;
        total_moved = 0;
        in_length = obj_len;				/* Words to move. */

        do while (in_length > 0);
	  words_moved = min (remain_words, in_length, out_length); /* Number of words to move. */
	  chars_moved = words_moved * 4;		/* Number of characters to move. */
	  out_ptr -> move_seg = in_ptr -> move_seg;
	  outl = outl + words_moved;
	  in_length = in_length - words_moved;
	  if in_length > 0 then do;			/* More to move. */
		total_moved = total_moved + words_moved;
		out_length = out_length - words_moved;
		if out_length > 0 then out_ptr = addr (out (msw - out_length + 1));
		else do;
		        call next_out_comp;
		        out_ptr = outp;
		        out_length = msw;
		    end;
		remain_words = remain_words - words_moved;
		if remain_words > 0 then in_ptr = addrel (in_ptr, words_moved);
		else /* Position to next input library component. */
		     if word (catl + fw + total_moved, in_ptr, remain_words, cc2) then do;
		        call com_err_ (error_table_$improper_data_format, ME,
			  "Move of object ""^a"" exceeded input library ""^a"" component ^i. Quitting",
			  name_chars, input_lib_path, nc);
		        goto close_files;
		    end;
	      end;
        end;

        if (reloc_abs) | (reloc_wds > 0) then
	   call com_err_ (error_table_$improper_data_format, ME,
	       "Warning, relocation specified (^1b ^i words) object ""^a"", library ""^a""",
	       reloc_abs, reloc_wds, obj_name, input_lib_path);

        if total_dcw_count ^= data_words then /* Lengths differ. */
	   call com_err_ (error_table_$improper_data_format, ME,
	       "Object ""^a"" total dcw count = ^i, data words = ^i (lib ^a).",
	       obj_name, total_dcw_count, data_wds, input_lib_path);

        if ^brief then call ioa_ ("Added module ""^a"" from ^a.", name_chars, input_lib_path);

/**** now add entry to program descriptors */
        if prgdes then do;
	      /***	Obtain pointer to entry location word (5).	*/
	      call get_dcw_block_word (5, eo_word_loc);
	      dcw_block_wds = 6 + ndcw;
	      initial_load_address = initial_load_address - 1024; /* Minus 2000 octal, related to GCOS usage. */
	      if Debug then
		 if initial_load_address < 66 then /* => 102 octal. */
		      call com_err_ (error_table_$improper_data_format, ME,
			"Object ""^a"" biased entry = ^i (lib ^a).",
			obj_name, initial_load_address, input_lib_path);
	      call update_prgdes (obj_name
		, 1				/** Library number. */
		, fixed (outc, 24)			/** Output component. */
		, f + dcw_block_wds			/** Offset to object. */
		, data_words + initial_load_address	/** Program size (words). */
		, fixed (data_words, 24)		/** Object length (words). */
		, fixed (entry_loc)			/** Entry point. */
		, initial_load_address		/** Initial load address. */
		);
	  end;
        return;

dcl     total_moved		 fixed bin (24);		/* total words moved in this object */
dcl     dcw_block_wds	 fixed bin (24);
dcl     f			 fixed bin (24);
dcl     in_length		 fixed bin (24);		/* words left in input seg */
dcl     out_length		 fixed bin (24);		/* words left in output seg */
dcl     words_moved		 fixed bin (24);		/* number of words moved from in to out segs */
dcl     chars_moved		 fixed bin (24);		/* 4 times the words moved */
dcl     min		 builtin;
dcl     move_seg		 char (chars_moved) based aligned; /* the Move Segment */
dcl     out		 (msw) bit (36) aligned based (outp);
dcl     in_ptr		 ptr;
dcl     out_ptr		 ptr;
dcl     remain_words	 fixed bin (24);		/* the number of words left in input to move */
    end copy_obj;
%page;
get_dcw_block_word: proc (n, p);
/****	Set (p) to n-th word of dcw block. 	*/
dcl     n			 fixed bin (24) parm;	/* dcw block word number */
dcl     p			 ptr parm;		/* dcw ptr */
        offset = n - 1;
        if rl > offset then do;
	      p = addrel (dcwbp, offset);
	      return;
	  end;

        if word (catl + fw + offset, p, r, c) then do;
	      call com_err_ (error_table_$improper_data_format, ME,
		"Input terminates with incomplete dcw block. Quitting.");
	      goto close_files;
	  end;
        return;

dcl     r			 fixed bin (24);
dcl     c			 fixed bin (24);
dcl     offset		 fixed bin (24);
    end get_dcw_block_word;
%page;
get_input_lib: proc returns (bit (1));
/****	Return TRUE if next input library could
	NOT be obtained.
*/
        fw = 1;					/* First word. */
        obj_len = 0;				/* Length of  current object. */
        rl = 0;					/* Remaining length of component segment. */
        if lib_fcbp ^= null () then /* Close last library. */
	   call msf_manager_$close (lib_fcbp);
        e = open_file (lib_name, lib_fcbp);
        if e ^= 0 then do;
	      call com_err_ (e, ME,
		"Library ""^a"" not available. Library skipped.", path);
	      return (TRUE);
	  end;
        input_lib_path = path;


        /***	Obtain list of pointers to components and their word lengths. */
        do nc = 0 to hbound (comp, 1);
	  cp (nc) = null ();
	  wl (nc) = 0;
	  call msf_manager_$get_ptr (lib_fcbp, nc, USE_EXISTING_COMPONENTS, cp (nc), bc, e);
	  if e ^= 0 then do;
		if (e = error_table_$noentry) & (nc > 0) then return (FALSE);
		call com_err_ (e, ME,
		    "Component ^i. ^a. Library skipped.", nc, input_lib_path);
		return (TRUE);
	      end;

	  if mod (bc, 36) ^= 0 then do;
		call com_err_ (error_table_$bad_file, ME,
		    "Component ^i of ^a bit count (^i) not multiple of 36. Library skipped.",
		    nc, input_lib_path, bc);
		return (TRUE);

	      end;
	  wl (nc) = divide (bc, 36, 24, 0);
        end;
        call com_err_ (error_table_$bad_file, ME,
	  "Exceeded ^i components in ^a. Library skipped.",
	  hbound (comp, 1) + 1, input_lib_path);
        return (TRUE);

dcl     lib_name		 char (lib_name_len (libc)) based (lib_name_loc (libc));
    end get_input_lib;
%page;
lookup: proc (lookup_name) returns (bit (1));
/****	Return TRUE if lookup_name is specified in module names list. */
dcl     lookup_name		 char (6) var parm;
        k = gfms_hash_ ((lookup_name), hbound (start, 1) + 1);
        ln = 0;
        n = start (k);
        do while (n > 0);				/* Search linked list. */
	  if lookup_name = mod_name (n) then do;	/* Found. */
		if ln = 0 then start (k) = link (n);	/* Start with next entry. */
		else link (ln) = link (n);		/* Link around entry. */
		link (n) = -1;			/* Mark entry found. */
		nm = nm - 1;			/* Reduce name count. */
		return (TRUE);
	      end;
	  ln = n;					/* Record last entry. */
	  n = link (n);				/* Proceed to next entry. */
        end;
        return (FALSE);				/* Not found. */

dcl     k			 fixed bin (24);
dcl     n			 fixed bin (24);
dcl     ln		 fixed bin (24);
    end lookup;
%page;
next_mod_name: proc (p, l);
/****	Store next module name (upper cased) in hash list.
*/
dcl     l			 fixed bin (24) parm;
dcl     p			 ptr parm;
        if l > 6 then call com_err_ (error_table_$bigarg, ME,
	       "Module name ""^a"" truncated to 6 characters.", name);
        nm = nm + 1;
        if nm > hbound (hash_list, 1) then do;
	      if (nm - 1) = hbound (hash_list, 1) then
		 call com_err_ (error_table_$too_many_names, ME,
		     "Only space for ^i module names. Names starting with ""^a"" lost.",
		     hbound (hash_list, 1), name);
	  end;
        else do;
	      mod_name (nm) = translate (name
		, "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
		, "abcdefghijklmnopqrstuvwxyz"
		);
	      /***	Store name in hash list. */
	      k = gfms_hash_ ((mod_name (nm)), hbound (start, 1) + 1);
	      link (nm) = start (k);
	      start (k) = nm;
	  end;
        return;
dcl     name		 char (l) based (p);
dcl     k			 fixed bin (24);
    end next_mod_name;
%page;
next_out_comp: proc;
/****	Obtain next output msf component.
*/
        outc = outc + 1;
        call msf_manager_$get_ptr (out_fcbp, outc, PROVIDE_NEW_COMPONENTS, outp, outl, e);
        if e ^= 0 then do;
	      call com_err_ (e, ME,
		"Can not obtain output ""^a"". Quitting.", output_lib_path);
	      goto close_files;
	  end;
        if mod (outl, 36) ^= 0 then do;
	      call com_err_ (e, ME,
		"Component ^i of msf ""^a"" bit count (^i) not modulo 36. Quitting.",
		outc, output_lib_path, outl);
	      goto close_files;
	  end;
        outl = divide (outl, 36, 24, 0);
        return;
    end next_out_comp;
%page;
open_file: proc (arg, fcbp) returns (fixed bin (35));
/****	Set file control block pointer (fcbp) to
	the msf file named by (arg). Return msf_manager error code.
*/
dcl     arg		 char (*) parm;
dcl     fcbp		 ptr parm;
        l = length (arg);
        k = search (reverse (arg), ">");
        if k > 0 then do;				/* User supplied directory. */
	      dir = substr (arg, 1, l - k);
	      msf = substr (arg, l - k + 2);
	  end;
        else do;
	      if wdl = 0 then do;
		    wd = get_wdir_ ();
		    wdl = search (wd, " ") - 1;
		    if wdl < 0 then wdl = length (wd);
		end;
	      dir = substr (wd, 1, wdl);
	      msf = arg;
	  end;
        path = dir || ">" || msf;
        /***	Open the input library file. */
        fcbp = null ();
        call msf_manager_$open ((dir), (msf), fcbp, e);
        return (e);

dcl     dir		 char (168) var;
dcl     e			 fixed bin (35);		/* error code */
dcl     k			 fixed bin (24);		/* position of > before enttry name */
dcl     l			 fixed bin (24);		/* arg length of path */
dcl     msf		 char (32) var;
    end open_file;
%page;
print_catalog: proc;
        catp = null ();
        if catl = 0 then
	   call ioa_ ("^/Library ^a appears to be native gcos and has no catalog.", input_lib_path);
        else do;
	      catp = cp (0);
	      call ioa_ ("Catalog for ^a:", input_lib_path);
	      do i = 1 to catalog.no_ent;
		call gfms_bcd_ascii_ (addr (catalog.elements (i).name), 6, addr (name_chars));
		call ioa_ ("^4i.^-^a^-^o", i, name_chars, catalog.elements (i).address);
	      end;
	  end;
        return;

dcl     i			 fixed bin (24);
dcl     catp		 ptr;

dcl     1 catalog		 aligned based (catp),
	2 fill		 fixed bin (24),
	2 no_ent		 fixed bin (24),
	2 elements	 (no_ent),
	  3 name		 bit (36),
	  3 address	 fixed bin (24);

    end print_catalog;
%page;
update_prgdes: proc (call_name, lib_num, comp_num, offset, prog_size, load_size, entry_pt, load_addr);
/****     Update prgdes_path with program descriptor info for call_name
	The seg named by prgdes_path (which is a copy of gtss_prgdes_alm_.incl.alm)
	MUST be in the following format:

1----------------------------------------------------------------------------
<front of program: copyright notices, incls, macros, comments, etc.>
segdef    prgdes
prgdes:   null
<some more local labels>
" Program descriptor 1.
CARD:  PRGDES  0,0,0,0,0,0,0,
               card,(CARDCL,1),,.BCMCL
<all the other program descriptors of the form:>
label: PRGDES  <program descriptors>
               STR1,STR2,<call name>{,STRi}
" Program descriptor <last program desc. number>.
CMDL:  PRGDES  <program descriptors>
               cmdl,EXPCL,.TSCLD,.BEXEC,LODX  MUST BE LAST DESCR.
" Program descriptor end.
<all the rest of the code>
          end
----------------------------------------------------------------------------

	Notes:
	     label: is optional.
	     STR1 etc. are optional.
	     The <program descriptors> are for the module <call name>.
		Although, <call name> is third arg of the second line,
		it is also the only occurance on that line. That is, 
		the string "<call name>" is unique in any one prog. desc.
	     The <program descriptors> are either all zero (as in the first
		one) or are these values
		1. library number, always 1
		2. component number of the output library
		3. offset of this object in this component
		4. the program size
		5. the load size
		6. the address of the entry point
		7. the initial load address

	This routine replaces all the program descriptors in prgdes_path
	which contain the given call name.

	The eight parameters to this procedure are the call name and the
	seven numbers required for the program descriptor.
*/
dcl     call_name		 char (6) var parm;
dcl     lib_num		 fixed bin (24) parm;
dcl     comp_num		 fixed bin (24) parm;
dcl     offset		 fixed bin (24) parm;
dcl     prog_size		 fixed bin (24) parm;
dcl     load_size		 fixed bin (24) parm;
dcl     entry_pt		 fixed bin (24) parm;
dcl     load_addr		 fixed bin (24) parm;

/* Initialize */
        found_name = FALSE;
        current_prgdes = start_prgdes;
        prgdes_inc = 0;
        /*** For each match of the call name, back up and replace the program descriptors */
        do while (current_prgdes < end_prgdes);
	  /*** find next reference to call name */
	  current_prgdes_size = end_prgdes - current_prgdes;
	  rel_next_name = index (substr (prgdes_seg, current_prgdes, current_prgdes_size), "," || call_name);
	  if rel_next_name = 0 then goto prgdes_done;	/* call name not found */
	  next_name = rel_next_name + current_prgdes;	/* now absolute */
	  if verify (substr (prgdes_seg, next_name + length (call_name), 1), VALID_FOL_CHAR) ^= 0
	  then goto get_next_prgdes;
	  /*** locate the old prgdes */
	  old_prgdes_last_char = next_name
	      - index (reverse (substr (prgdes_seg, current_prgdes, rel_next_name)), NL) - 1;
	  prgdes_first_char = old_prgdes_last_char
	      - index (reverse (substr (prgdes_seg, current_prgdes, old_prgdes_last_char - current_prgdes))
	      , reverse_PRGDES) + 1;
	  old_prgdes_size = old_prgdes_last_char - prgdes_first_char + 1;
	  if (old_prgdes_size < 1) then do;
		call com_err_ (error_table_$improper_data_format, ME,
		    "Cannot find program descriptors for ""^a"" in ^a. Check format.", call_name, prgdes_path);
		goto close_files;
	      end;
	  /*** build the new prgdes */
	  if substr (prgdes_seg, prgdes_first_char, 1) = "0" /* lib=0 */
	  then update_type = "Added";
	  else update_type = "Replaced";
	  if ^found_name then
	       call ioa_$rsnnl ("^7(^i,^)  "" ^a by gtbl on ^a",
		 new_prgdes, new_prgdes_size,
		 libn, comp_num, offset, prog_size, load_size, entry_pt, load_addr,
		 update_type, run_date);
	  found_name = TRUE;
	  /*** WHEW! Now comes the easy part: updating the seg with the new prgdes */
	  prgdes_inc = new_prgdes_size - old_prgdes_size;
	  if prgdes_inc > 0
	  then do;				/* hole is too small */
		prgdes_move_len = prgdes_seg_size - old_prgdes_last_char;
		prgdes_seg_size = prgdes_seg_size + prgdes_inc;
		call mrl_ (addcharno (prgdes_seg_ptr, old_prgdes_last_char), prgdes_move_len,
		    addcharno (prgdes_seg_ptr, old_prgdes_last_char + prgdes_inc), prgdes_move_len);
	      end;
	  /*** now move it in */
	  substr (prgdes_seg, prgdes_first_char, new_prgdes_size) = new_prgdes;
	  if prgdes_inc < 0				/* hole was too big! blank out rest */
	  then substr (prgdes_seg, prgdes_first_char + new_prgdes_size, -prgdes_inc) = " ";
	  if ^brief then do;
		/*** figure out which prgdes this is */
		this_prgdes = old_prgdes_last_char
		    - index (reverse (substr (prgdes_seg, current_prgdes, old_prgdes_last_char - current_prgdes)),
		    reverse_prog_desc) + 1;
		this_prgdes_num = substr (prgdes_seg, this_prgdes, index (substr (prgdes_seg, this_prgdes, 4), ".") - 1);
		call ioa_ ("^a program descriptor ^a for ""^a"".",
		    update_type, this_prgdes_num, call_name);
	      end;
	  if Debug then call ioa_ ("^a^-^a", call_name, new_prgdes);
get_next_prgdes: ;
	  /*** move up to next prgdes and continue */
	  if prgdes_inc < 0 then prgdes_inc = 0;
	  end_prgdes = end_prgdes + prgdes_inc;
	  current_prgdes = next_name + prgdes_inc + index (substr (prgdes_seg, next_name + prgdes_inc), NL) + 1;
	  prgdes_inc = 0;
        end;
prgdes_done:
        if ^found_name then
	   if ^brief then
	        call ioa_$ioa_stream ("error_output",
	        "Call name ""^a"" not found in ^a. Module WAS added to ^a", call_name, prgdes_path, output_lib_path);
        return;

dcl     current_prgdes	 fixed bin (24);
dcl     current_prgdes_size	 fixed bin (24);
dcl     found_name		 bit (1);
dcl     new_prgdes		 char (100) varying;
dcl     new_prgdes_size	 fixed bin (24);
dcl     next_name		 fixed bin (24);
dcl     old_prgdes_last_char	 fixed bin (24);
dcl     old_prgdes_size	 fixed bin (24);
dcl     prgdes_first_char	 fixed bin (24);
dcl     prgdes_inc		 fixed bin (24);
dcl     prgdes_move_len	 fixed bin (24);
dcl     rel_next_name	 fixed bin (24);
dcl     this_prgdes		 fixed bin (24);
dcl     this_prgdes_num	 char (3) var;
dcl     update_type		 char (8) varying;

    end update_prgdes;
%page;
word: proc (w, p, l, c) returns (bit (1));
/****	Set pointer (p) to word (w) of input msf and
	set the length (l) to number of words available
	in component segment.
	Set (c) to the number of the msf component
	in which the word was found.
	Return FALSE;

	Return TRUE if word (w) not available.
 */
dcl     c			 fixed bin (24) parm;
dcl     l			 fixed bin (24) parm;
dcl     p			 ptr parm;
dcl     w			 fixed bin (24) parm;
        c = -1;
        if w < 1 then return (TRUE);
        k = 0;
        do i = 0 to nc;
	  k = k + wl (i);
	  if w <= k then do;			/* Component located. */
		l = k - w + 1;
		p = addrel (cp (i), wl (i) - l);
		c = i;
		return (FALSE);
	      end;
        end;
        return (TRUE);

dcl     i			 fixed bin (24);
dcl     k			 fixed bin (24);
    end word;
%page;
/* Constants */
dcl     ME		 char (28) static int options (constant) init ("gcos_tss_build_library (1.1)");
dcl     TRUE		 bit (1) static int options (constant) init ("1"b);
dcl     FALSE		 bit (1) static int options (constant) init ("0"b);
dcl     MARKER		 bit (36) static int options (constant) init ("101100011111000000001111111111111000"b);
dcl     USE_EXISTING_COMPONENTS bit (1) static int options (constant) init ("0"b);
dcl     PROVIDE_NEW_COMPONENTS bit (1) static int options (constant) init ("1"b);
dcl     NL		 char (1) static int options (constant) init ("
");
dcl     FAST_LIB_HEADER_LENGTH fixed bin (24) static int options (constant) init (4);
dcl     OBJECT_HEADER_LENGTH	 fixed bin (24) static int options (constant) init (5);
dcl     VALID_FOL_CHAR	 char (4) static int options (constant) init (", 	
");						/* comma, space, tab, new line */
%page;
/**** builtins, conditions, entries, externals (non-variables) */

dcl     (addcharno,
        addr,
        addrel,
        divide,
        fixed,
        hbound,
        index,
        length,
        max,
        mod,
        null,
        reverse,
        search,
        substr,
        translate,
        verify)		 builtin;

dcl     cleanup		 condition;

dcl     clock_		 entry () returns (fixed bin (71));
dcl     com_err_		 entry options (variable);
dcl     cu_$arg_count	 entry (fixed bin (24), fixed bin (35));
dcl     cu_$arg_ptr		 entry (fixed bin (24), ptr, fixed bin (24), fixed bin (35));
dcl     date_time_		 entry (fixed bin (71), char (*));
dcl     expand_pathname_	 entry (char (*), char (*), char (*), fixed bin (35));
dcl     get_wdir_		 entry returns (char (168));
dcl     gfms_bcd_ascii_	 entry (ptr, fixed bin (24), ptr);
dcl     gfms_hash_		 entry (char (*), fixed bin (24)) returns (fixed bin (35));
dcl     initiate_file_	 entry (char (*), char (*), bit (*), ptr, fixed bin (24), fixed bin (35));
dcl     ioa_		 entry options (variable);
dcl     ioa_$ioa_stream	 entry options (variable);
dcl     ioa_$rsnnl		 entry () options (variable);
dcl     mrl_		 entry options (variable);
dcl     msf_manager_$adjust	 entry (ptr, fixed bin, fixed bin (24), bit (3), fixed bin (35));
dcl     msf_manager_$close	 entry (ptr);
dcl     msf_manager_$get_ptr	 entry (ptr, fixed bin, bit (1), ptr, fixed bin (24), fixed bin (35));
dcl     msf_manager_$open	 entry (char (*), char (*), ptr, fixed bin (35));
dcl     terminate_file_	 entry (ptr, fixed bin (24), bit (*), fixed bin (35));

dcl     (error_table_$bad_arg,
        error_table_$bad_file,
        error_table_$badopt,
        error_table_$bigarg,
        error_table_$improper_data_format,
        error_table_$inconsistent,
        error_table_$noarg,
        error_table_$noentry,
        error_table_$too_many_names)	 fixed bin (35) ext static;
dcl     sys_info$max_seg_size	 fixed bin (35) ext static;
%page;
/****	Variables for gtbl:
	IDENTIFIER	ATTRIBUTES	*/

dcl     al		 fixed bin (24);
dcl     all_mods		 bit (1);
dcl     ap		 ptr;
dcl     arg		 char (al) based (ap);
dcl     arg_num		 fixed bin (24);
dcl     bc		 fixed bin (24);
dcl     brief		 bit (1);
dcl     catl		 fixed bin (24);
dcl     catl_parm		 fixed bin (24);
dcl     cc		 fixed bin (24);
dcl     cc2		 fixed bin (24);
dcl     dcwbc		 fixed bin (24);
dcl     e			 fixed bin (35);
dcl     end_prgdes		 fixed bin (24);
dcl     f			 bit (1);
dcl     fw		 fixed bin (24);
dcl     get_mod_name	 bit (1);
dcl     have_output_lib	 bit (1);
dcl     i			 fixed bin (24);
dcl     initial_load_address	 fixed bin (24);
dcl     init_nm		 fixed bin (24);
dcl     input_lib_path	 char (168) var;
dcl     j			 fixed bin (24);
dcl     k			 fixed bin (24);
dcl     libc		 fixed bin (24);		/* current input library number */
dcl     lib_fcbp		 ptr;
dcl     max_dcw_count	 fixed bin (24);
dcl     mf		 char (mfl) based (mfp);	/* module file */
dcl     mfa		 (mfl) char (1) based (mfp);
dcl     mfl		 fixed bin (24);
dcl     mfp		 ptr;
dcl     mf_fcbp		 ptr;
dcl     msw		 fixed bin (24);		/* max seg words */
dcl     nargs		 fixed bin (24);
dcl     name_loc		 ptr;
dcl     nc		 fixed bin;
dcl     ndcw		 fixed bin (24);
dcl     need_1_mod_name	 bit (1);
dcl     no_cat		 bit (1);
dcl     obj_len		 fixed bin (24);
dcl     obj_name		 char (6) var based (addr (nl));
dcl     obj_num		 fixed bin (24);
dcl     prgdes		 bit (1);
dcl     prgdes_bit_count	 fixed bin (24);
dcl     prgdes_dir		 char (168);
dcl     prgdes_entry	 char (32);
dcl     prgdes_fcbp		 ptr;
dcl     prgdes_path		 char (168);
dcl     prgdes_seg		 char (prgdes_seg_size) based (prgdes_seg_ptr);
dcl     prgdes_seg_ptr	 ptr;
dcl     prgdes_seg_size	 fixed bin (24);		/* number of chars in prgdes seg */
dcl     process_mf		 bit (1);
dcl     process_ol		 bit (1);
dcl     open_prgdes		 bit (1);
dcl     outc		 fixed bin;		/* output lib component num */
dcl     outl		 fixed bin (24);		/* output lib word length */
dcl     outp		 ptr;			/* output lib pointer */
dcl     output_lib_path	 char (168) var;
dcl     out_fcbp		 ptr;
dcl     path		 char (168) var;
dcl     pr_cat		 bit (1);
dcl     reverse_PRGDES	 char (8);		/* PRGDES spelled backwards */
dcl     reverse_prog_desc	 char (19);		/* Program descriptor backwards */
dcl     rl		 fixed bin (24);
dcl     run_date		 char (16);		/* don't want time zone and day */
dcl     start_prgdes	 fixed bin (24);
dcl     total_dcw_count	 fixed bin (24);
dcl     wd		 char (168);		/* working dir */
dcl     wdl		 fixed bin (24);		/* working dir length */
dcl     just_a_word		 bit (36) based;


/* format: off */
dcl	1 object_name_structure,
	  2 nl		fixed bin(24),	/* Number characters in Name. */
	  2 name_chars	char(6);


dcl	1 msf		aligned
,	  2 nc		fixed bin(24)	/* Number of components. */
,	  2 comp		(0:99)		/* Components:	*/
,	    3 cp		ptr		/* segment.	*/
,	    3 wl		fixed bin(24)	/* number words.	*/
;

dcl	1 copy_names
,	  2 nm		fixed bin(24)       /* Number of module names. */
,	  2 start		(0:1020)fixed bin(24)/* Hash start list.
					   >0 => hash_list entry. */
,	  2 hash_list	(2000)
,	    3 link	fixed bin(24)	/* >0 => previous hash_list entry. */
,	    3 mod_name	char(6)var	/* Module name. */
;

dcl	dcwbp		ptr;
dcl	1 dcw_block	aligned based(dcwbp)
,	  2 data_check	fixed bin(24)	/* Checksum for data words. */
,	  2 rel_check	fixed bin(24)	/* checksum for reloc words */
,	  2 rel_abs	bit(36)		/* 6th bit = "1"b => relocatable. */
,	  2 name		bit(36)		/* name of program (BCD). */
,	  2 word5
,	    3 entry	bit(18)unal	/* entry address. */
,	    3 origin	bit(18)unal	/* origin. */
,	  2 word6
,	    3 reloc_words	fixed bin(17)unal	/* Number of relocation words. */
,	    3 data_words	fixed bin(17)unal	/* Number of data words.	*/
,	  2 dcws		(ndcw)bit(36)
;

dcl	eo_word_loc	ptr;
dcl	1 eo_word		aligned based(eo_word_loc)
,	  2 entry_loc	bit(18)unal
,	  2 origin_loc	bit(18)unal
;

dcl	reloc_word_loc	ptr;
dcl	1 reloc_word	aligned based(reloc_word_loc)
,	  2 fill1		bit( 6)unal
,	  2 reloc_abs	bit( 1)unal	/* "1"b => relocatable. */
,	  2 fill2		bit(29)unal
;

dcl	rd_word_loc	ptr;
dcl	1 rd_word		aligned based(rd_word_loc)
,	  2 reloc_wds	fixed bin(17)unal
,	  2 data_wds	fixed bin(17)unal
;

dcl	dcw_loc		ptr;
dcl	1 dcw		aligned based(dcw_loc)
,	  2 data_address	bit(18)unal
,	  2 zero		bit( 3)unal
,	  2 action	bit( 3)unal
,	  2 count		bit(12)unal
;


dcl	1 lib_stack
,	  2 libn		fixed bin(24) /* total number of input libraries */
,	  2 input_lib	(10)
,	    3 lib_name_loc	ptr
,	    3 lib_name_len	fixed bin(24)
;

dcl	1 fast_lib_header	aligned based
,	  2 id		char(8)
,	  2 num_objects	pic "(8)9"
;

dcl	1 object_header	aligned based
,	  2 marker	bit(36)
,	  2 obj_name	char(8)var
,	  2 obj_len_wds	fixed bin(24)
,	  2 obj_word1	bit(36)
;
%page;
%include gcos_xio_dcl_;
%page;
%include terminate_file;
%page;
%include access_mode_values;
end gcos_tss_build_library;
