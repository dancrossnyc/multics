/* ******************************************************
   *                                                    *
   *                                                    *
   * Copyright (c) 1972 by Massachusetts Institute of   *
   * Technology and Honeywell Information Systems, Inc. *
   *                                                    *
   *                                                    *
   ****************************************************** */

/* format: style3 */
apl_lex_:
     procedure;

/*
 * apl_lex_
 *
 * This module converts a character string into a lexed_function bead.
 * It is called after a function is edited, by the QuadFX function, by the execute operator,
 * and when a function is called that had not yet been lexed after a )LOAD.
 *
 * apl_lex_ is the first pass of the APL parser.  It does a left to right scan
 * and produces a lexed_function bead which includes an array of packed pointers
 * called lexemes.  Each lexeme points to a value bead, a symbol bead, or an operator bead.
 * The second pass of the parser is a right to left scan of the lexemes done at run time
 *
 * Entries:
 *  apl_line_lex_   processes a line of evaluated input
 *  apl_function_lex_   processes the definition of a function, including the header line
 *  apl_scan_        gets next token in a character string - for editor and apl_command_
 *  apl_execute_lex_   same as apl_line_lex_ except errors work differently.  Used by the execute operator
 *  canonicalize_apl_line_   canonicalizes spacing and number format in apl lines - used by editor, etc.
 */


/*
 * written 6/20/73 by D A Moon
 * debugged by DAM at various times during 7/73
 * apl_scan_ added 7/25/73 by DAM
 * facilities for the execute operator added 8/7/73 by DAM
 * modified 8/20/73 by DAM for bug fixing and localization of system variables
 * Modified 740131 by PG for better error message for misused ->
 * Modified 740320 by PG to use PL/I EIS conversion routines
 * Modified July 1974 to fix illegal machine op on outer product with left bracket by G. Gordon Benedict
 * Modified 741009 by PG to make unbalanced quotes error msg work.
 * Modified 770106 by PG to add apl_editor_scan_ and fix unbalanced parens to work (bug 193).
   Modified 780310 by PG to fix bug 314 (not checking for duplicate labels).
   Modified 780403 by PG to fix bug 318 (fix to 314 broke code to re-lex functions for error position).
   Modified 780504 by PG to add diamond processing
   Modified 780613 by PG to fix bug 323 (lex looped if given stmts (between diamonds) of zero length.)
   Modified 780909 by PG to fix bug 326 (F-<.IQ 1 caused lex to loop & fault),
	and to diagnose identifiers beginning with an underscore.
   Modified 780920 by PG to permit -> after semicolons, and to diagnose
	mixed diamonds and semicolons.
   Modified 781107 by PG to add argument list processing.
   Modified 790327 by WMY to fix bug 388, result of lexing a function with no body.
	A null lexed_function_bead_ptr was returned, now a lexed_funciton_bead
	with no statements is returned.
   Modified 800129 by PG to implement localized system variables.
   Modified 811211 by H. Hoover (UofC) to add qCALL system function.
 */

/* declarations */

dcl	line_type		bit (2) aligned,
	Diamond_type	bit (2) aligned int static init ("01"b),
	Semicolon_type	bit (2) aligned int static init ("10"b);
dcl	stmt_length_map	(100) fixed bin;
dcl	stmt_number	fixed bin;
dcl	(first_lexeme, line_len, lx, output_index)
			fixed bin;
dcl	done		bit (1) aligned;
dcl	parse_frame_ptr	ptr;
dcl	esw		fixed bin,		/* entry switch */
	apl_line_lex_	fixed bin static init (1),	/* values for esw */
	apl_function_lex_	fixed bin static init (2),	/* .. */
	apl_scan_		fixed bin static init (0),	/* .. */
	apl_execute_lex_	fixed bin static init (3),	/* .. */
						/*  canonicalize_apl_line_ fixed bin static init(4),	unused for now */
	next_lexeme	fixed bin,		/* type of the next lexeme to be emitted */
	lexeme		ptr unaligned,		/* next lexeme to be emitted */
	last_lexeme	fixed bin,		/* type of the last lexeme that was emitted */
						/* type codes which may be the value of next_lexeme, last_lexeme */
	BeginOfLine	fixed bin static init (1),	/* no last lexeme, new line has been started */
	OperatorLexeme	fixed bin static init (2),
	ValueLexeme	fixed bin static init (4),	/* a parenthesized expression */
	OpenParenLexeme	fixed bin static init (5),	/* left paren or left bracket */
	ConstantLexeme	fixed bin static init (6),	/* a numeric or character constant.  Has not yet been emitted,
					   but is sitting in stack_value_ptr -> value_bead */
	NameLexeme	fixed bin static init (7),	/* a symbol (name, identifier) */
						/* may also be SemiColon */
	error_suppress	bit (1),			/* "1"b to suppress error messages - used by apl_execute_lex_ */
	char_index	fixed bin (20),		/* 0-origin index in the variable text, which is input string */
	line_no		fixed bin,		/* current statement number */
	line_index	fixed bin (20),		/* value of char_index at start of this line */
	space_left_in_stack fixed bin,		/* number of words left in value stack, if counts down to 0 may
					   have to switch segments */
	value_stack_popper	ptr,			/* saved value of ws_info.value_stack_ptr upon entry */
	value_stack_space	ptr,			/* -> stuff we have pushed onto value stack.
					   may be different from value_stack_popper if we have switched stack segs */
	lexeme_index	fixed bin,		/* index in temp_lexeme_array of next lexeme to be emitted */
	1 lexeme_array_alignment_structure
			aligned based (value_stack_space),
	  2 emission_array	(lexeme_index),		/* array of emissions */
	    3 temp_lexeme_array
			pointer unaligned,		/* lexeme */
	    3 source_pos	fixed bin,		/* value of char_index afterfirst char of token was read */
	temp_lexeme_size	fixed bin static init (2),	/* size(emission_array(1)) is not allowed and does not work */
	char_count	fixed bin;		/* when this counts up to 0, the end of the string 'text' has been reached */

/* parenthesis stuff */

dcl	paren_level	fixed bin,		/* index into paren_stack, 0 if top level */
	1 paren_stack_structure
			(1000 /* or so */) aligned based (paren_stack_ptr),
	  2 paren_stack	fixed bin,		/* type of paen - codes dcl'ed below */
	  2 paren_loc	fixed bin (21),		/* value of char_index at left paren */
	paren_stack_ptr	pointer,			/* at begin of line, set above statement_map */
	P_S_Parens	fixed bin static init (1),	/* paren_stack: () */
	P_S_Brackets	fixed bin static init (2),	/* paren_stack: [] */
     P_S_Opr_Brackets fixed bin static init (3),
						/* paren_stack: [] after operator */
     P_S_qCALL_Parens fixed bin static init (4);
						/* paren_stack: () after qCALL system function */

dcl	code		fixed bin (35),		/* status code used to generate error messages */
	n		fixed bin,		/* temp */
	begin_subscript_calc
			fixed bin,		/* index in temp_lexeme_array of thing getting subscripted-assigned */
	chr		fixed bin (9),		/* APL character code for current character */
	temp_ptr		ptr unaligned,
	template_ptr	ptr unaligned,		/* for making lexed function bead */
	hack_ptr		pointer aligned,		/* see assign: */
	NL		character static init ("
"),
	(
	function_being_lexed,			/* -> symbol bead for function name from header line, or null */
	left_arg_symbol,				/* -> symbol bead for what it says */
	right_arg_symbol,				/* .. */
	return_value_symbol
	) /* .. */	pointer unaligned initial (null),
	name_index	fixed bin,		/* 0-origin index in the following */
	1 name_buffer_array_alignment_structure
			based (name_buffer_ptr) aligned,
						/* buffer for building up names of symbols */
	  2 name_buffer_array
			(0:(1000) /* or so */) fixed bin (8) unaligned,
						/* overlay on character string */
	1 name_buffer_alignme_structure
			aligned based (name_buffer_ptr),
	  2 name_buffer	char (name_index) unaligned,
	name_buffer_ptr	pointer;			/* resides in parse stack above paren_stack */


/* stuff for number conversion */

dcl	apl_number_for_size float;			/* used only with the size builtin */

dcl	apl_number	float bin (63),
	number_buffer	float decimal (34),
	1 overlay_on_number_buffer
			based (addr (number_buffer)) aligned,
	  2 sign		char (1) unaligned,		/* ascii code "+" or "-" */
	  2 digit		(0:33) fixed bin (8) unaligned,
						/* ascii code from chr for "0" - "9" */
	  2 must_be_zero	bit (1) unaligned,
	  2 exponent	fixed bin (7) unaligned,
	(expona, exponb)	fixed bin,
	magic_rounding_constant
			float decimal (32) static initial (1.0000000000000000000542101080243e0),
	decimal_zero	float dec (34) aligned static init (0e0),
						/* has to be named constant due to PL/I compiler bug */
	negative_exponent	bit (1),
	stack_value_ptr	ptr;			/* -> value bead sitting in stack above lexeme_array */


/* statement & label map */

dcl	1 statement_map	(1:1000 /* or so */) aligned based (statement_map_ptr),
						/* in parse stack */
	  2 lexeme_index	fixed bin,		/* index in lexeme_array of last lexeme for line */
	  2 label		pointer unaligned,		/* null or -> symbol bead for label on this line (only 1 label per line!) */
	statement_map_ptr	pointer;

/* localized symbols table */

dcl	1 MY		aligned based (parse_stack_space),
	  2 localized_symbols
			(number_of_localized_symbols) pointer unaligned;


dcl	(number_of_localized_symbols, number_of_labels)
			fixed bin;


/* form of data in parse stack is:

	localized_symbols array

	statement_map

	paren_stack

*/

/* builtins */

dcl	(abs, addr, addrel, binary, bit, decimal, fixed, hbound, index, lbound, length, mod, null, rel, size, string,
	substr, unspec)	builtin;


/* more misc dcl */

dcl	fatal		bit (1),
	ll		fixed bin,
	i		fixed bin,
	apl_error_	entry (fixed bin (35), bit (36) aligned, fixed bin, char (*), pointer unaligned, fixed bin),
	apl_get_symbol_	entry (char (*), pointer unaligned, fixed bin),
	apl_allocate_words_ entry (fixed bin (18), pointer unaligned),
	apl_free_bead_	entry (pointer unaligned),	/* only call this if reference count has decremented to zero */
	apl_copy_value_	entry (pointer unaligned, pointer unaligned);


/* external static */

dcl	(
	apl_error_table_$mixed_diamonds_and_semicolons,
	apl_error_table_$underscore_cant_begin_id,
	apl_error_table_$too_short_execute,
	apl_error_table_$too_many_statements,
	apl_error_table_$duplicate_label,
	apl_error_table_$more_than_one_line_execute,
	apl_error_table_$u_mism_ur_quotes,
	apl_error_table_$bad_subsc_assign_sys_var,
	apl_error_table_$extra_decimal_point,
	apl_error_table_$cant_be_localized,
	apl_error_table_$random_char,
	apl_error_table_$ill_scan,
	apl_error_table_$ill_reduction,
	apl_error_table_$lex_screwed_up,
	apl_error_table_$not_end_with_newline,
	apl_error_table_$ill_outer_prod,
	apl_error_table_$ill_inner_prod,
	apl_error_table_$misplaced_diamond,
	apl_error_table_$misplaced_semicolon,
	apl_error_table_$excess_right_parens,
	apl_error_table_$mismatched_parens,
	apl_error_table_$ill_opr_brackets,
	apl_error_table_$misplaced_brackets,
	apl_error_table_$excess_right_brackets,
	apl_error_table_$not_end_with_value,
	apl_error_table_$ill_small_circle,
	apl_error_table_$unknown_system_name,
	apl_error_table_$ws_full_in_lex,
	apl_error_table_$constant_mism,
	apl_error_table_$mism_quotes,
	apl_error_table_$ill_paren_level,
	apl_error_table_$not_allowed_inner_prod,
	apl_error_table_$not_allowed_outer_prod,
	apl_error_table_$more_than_one_line,
	apl_error_table_$badass,
	apl_error_table_$lone_upper_minus,
	apl_error_table_$lone_period,
	apl_error_table_$excess_label,
	apl_error_table_$random_char_in_hdr,
	apl_error_table_$need_name,
	apl_error_table_$only_1_return_value,
	apl_error_table_$need_semicolon,
	apl_error_table_$misplaced_right_arrow
	)		fixed bin (35) external;

/* include files */

%include apl_number_data;
%include apl_bead_format;
%include apl_value_bead;
%include apl_operator_bead;
%include apl_character_codes;
%include apl_lex_pseudo_chars;
%include apl_ws_info;
%include apl_operator_table_;
%include apl_lex_tables_;
%include apl_lexed_function_bead;
%include apl_parse_frame;

/**** entry point to lex a line of evaluated input ****/

apl_line_lex_:
     entry (text, lex_return_pointer, errors_occurred, a_bad_lexeme_index, parse_stack_space);

dcl	text		char (*) aligned parameter,	/* string to be lexically analyzed */
	lex_return_pointer	pointer unaligned,		/* this return argument usually -> lexed_function bead,
					   but in the case of lexing for errors, -> error_mark_structure */
	errors_occurred	bit (1) aligned parameter,	/* return argument - "1"b if lex has printed 1 or more error msgs */
	a_bad_lexeme_index	fixed bin parameter,	/* 0 for normal lexing, > 0 implies this is index of lexeme
					   at which error ocurred, so source is to be marked (lexing for errors) */
	1 error_mark_structure
			aligned based (parse_stack_space),
	  2 error_line_number
			fixed bin,
	  2 error_line_index
			fixed bin (21),		/* pl1 (1-origin) index of start of line in error */
	  2 error_index_within_line
			fixed bin,		/* pl1 (1-origin) index of character within line to be marked */
	  2 length_of_line	fixed bin,		/* number of characters in erroneous line, including newline at end */
	parse_stack_space	pointer aligned parameter;	/* -> space I can use on parse stack */


/* apl_line_lex_ begin executable code */

	error_suppress = "0"b;
	esw = apl_line_lex_;
	go to line_execute_lex_join;


apl_execute_lex_:
     entry (text, lex_return_pointer, errors_occurred, a_bad_lexeme_index, parse_stack_space);

	esw = apl_execute_lex_;
	error_suppress = ^ws_info.long_error_mode;	/* suppress syntax errors unless long mode */
line_execute_lex_join:
	errors_occurred = "0"b;
	last_lexeme = BeginOfLine;			/* don't get the idea that this statement is superfluous */
	char_index = 0;
	lexeme_index = 1;
	line_no = 0;
	call setup_value_stack;
	number_of_localized_symbols = 0;
	number_of_labels = 0;
	statement_map_ptr = parse_stack_space;		/* no local symbols table */
	char_count = -length (text) - 1;
	go to start_line;

process_newline:
snail (10):
	if paren_level ^= 0
	then go to barf_at_ill_paren_level;		/* make some error checks */
	if last_lexeme = OperatorLexeme
	then do;					/***** write around pl1 compiler bug in packed to unpacked pointer comparison ****/
		temp_ptr = addr (operator_bead_table (op_index (RightArrow)));
		if lexeme = temp_ptr
		then ;				/* special case, allow RightArrow alone on a line */
		else go to barf_at_not_end_with_value;
	     end;
	else if last_lexeme = ConstantLexeme
	then call convert_constant;
	statement_map (line_no).lexeme_index = lexeme_index - 1;

/* If we are lexing for errors, see if we have found the erroneous line. */

	if a_bad_lexeme_index ^= 0
	then if a_bad_lexeme_index < lexeme_index
	     then do;
		     error_mark_structure.error_line_number = line_no;
		     error_mark_structure.error_line_index = line_index + 1;

/* Correct the lexeme index to account for any diamond reordering present */

		     lx = a_bad_lexeme_index;

		     if line_no > 1
		     then first_lexeme = statement_map (line_no - 1).lexeme_index;
		     else first_lexeme = 0;

		     lx = lx - first_lexeme;

		     do stmt_number = stmt_number by -1 to 1 while (lx > stmt_length_map (stmt_number));
			lx = lx - stmt_length_map (stmt_number);
		     end;

		     stmt_number = stmt_number - 1;	/* we have found the right statement...skip it */

		     do stmt_number = stmt_number by -1 to 1;
			lx = lx + stmt_length_map (stmt_number);
		     end;

		     error_mark_structure.error_index_within_line = source_pos (lx + first_lexeme) - line_index;
		     error_mark_structure.length_of_line = char_index - line_index;
		     lex_return_pointer = addr (error_mark_structure);
		     return;
		end;

start_line:
	line_type = "00"b;
	stmt_number = 1;
	stmt_length_map (1) = 0;
	line_no = line_no + 1;
	paren_level = 0;
	line_index = char_index;			/* save start of line */
	lexeme = addr (operator_bead_table (op_index (NewLine)));
						/* put out a beginning of line lexeme */
	next_lexeme = BeginOfLine;
	statement_map (line_no).label = null;		/* assume line will be unlabeled */
	paren_stack_ptr = addr (statement_map (line_no + 1));
						/* put paren stack above statement map */
	go to hrund_emit;

start_new_lexeme:
snail (11):
	char_count = char_count + 1;
	if char_count = 0
	then if esw = apl_execute_lex_
	     then go to process_newline;		/* forge a newline at end of execute string */
	     else go to end_of_text;			/* but for any other entry, this is the end */
	else if char_count > 0
	then go to end_of_text;			/* newline has already been forged, so now text ends */
	chr = fixed (unspec (substr (text, char_index + 1, 1)), 9);
	char_index = char_index + 1;
	go to snail (char_type (chr));

/* snail(0) = barf_at_random_char
   snail(1) = start_name
   snail(2) =   "
   snail(3) =   "
   snail(5) = start_number
   snail(6) = start_negative_number
   snail(9) = skip_over_comment
   snail(10) = process_newline
   snail(11) = start_new_lexeme		skip over blanks
   snail(12) = process_char_constant
   snail(13) = barf_at_random_char
   snail(14) = hrund_emit_operator
   snail(22) = assign
    the remaining snails follow */

snail (4):					/* QuadQuote */
	next_lexeme = NameLexeme;			/* sort of a name */
	go to get_hrund_emit;

snail (8):					/* scan & reduction - or maybe expand & compress */
	if last_lexeme ^= OperatorLexeme
	then go to hrund_emit_operator;
	if ^(lexeme -> operator_bead.allow_reduction)
	then go to barf_at_ill_reduction;
	if chr = Slash
	then lexeme = addr (lexeme -> scalar_op.slash_operator_bead);
	else if chr = BackSlash
	then lexeme = addr (lexeme -> scalar_op.backslash_operator_bead);
	else if chr = SlashHyphen
	then lexeme = addr (lexeme -> scalar_op.slash_hyphen_operator_bead);
	else if chr = BackSlashHyphen
	then lexeme = addr (lexeme -> scalar_op.backslash_hyphen_operator_bead);
	else go to ulose;				/* tables screwed up */
	go to hrund_replace;

snail (15):					/* generate a branch from RightArrow */
	if (last_lexeme ^= BeginOfLine) & (last_lexeme ^= Diamond) & (last_lexeme ^= SemiColon)
	then go to misplaced_right_arrow;
	else go to hrund_emit_operator;


snail (16):					/* process SmallCircle, which may only be used to
		   introduce an outer product */
skip_blanks_for_SmallCircle:
	char_count = char_count + 1;
	if char_count = 0
	then go to unexpected_end_of_text;
	chr = fixed (unspec (substr (text, char_index + 1, 1)), 9);
	char_index = char_index + 1;
	if char_type (chr) = 11
	then go to skip_blanks_for_SmallCircle;		/* allow blanks */
	if char_type (chr) ^= 7
	then go to barf_at_ill_small_circle;		/* must be period */
						/* do outer product - chr = "." */

doprod (11):					/* outer product */
	char_count = char_count + 1;
	if char_count = 0
	then go to unexpected_end_of_text;
	chr = fixed (unspec (substr (text, char_index + 1, 1)), 9);
	char_index = char_index + 1;
	go to doprod (char_type (chr));

doprod (14):					/* got operator to take outer product of */
	lexeme = addr (operator_bead_table (op_index (chr)));
	if ^(lexeme -> operator_bead.allow_product)
	then go to barf_at_not_allowed_outer_prod;
	lexeme = addr (lexeme -> scalar_op.outer_product_operator_bead);
	next_lexeme = OperatorLexeme;
	go to hrund_emit;

doprod (0):
doprod (1):
doprod (2):
doprod (3):
doprod (4):
doprod (5):
doprod (6):
doprod (7):
doprod (8):
doprod (9):
doprod (10):
doprod (12):
doprod (13):
doprod (15):
doprod (16):
doprod (17):
doprod (18):
doprod (19):
doprod (20):
doprod (21):
doprod (22):
doprod (23):
	code = apl_error_table_$ill_outer_prod;
	go to error;

snail (7):					/* process dot (except outer-product dot) */
						/* operator followed by dot -- might be inner product, but
	   could be start of a number.  Have to look ahead a little */
	if char_count < -1
	then if char_type (fixed (unspec (substr (text, char_index + 1, 1)), 9)) = 5
	     then go to start_number_with_decimal_point;
	     else if last_lexeme ^= OperatorLexeme
	     then go to barf_at_lone_period;
	     else if last_lexeme ^= OperatorLexeme
	     then go to barf_at_lone_period;
	if ^(lexeme -> operator_bead.allow_product)
	then do;					/* left opeator does not permit inner product. */
						/* back up and mark it. */

		do while (char_index > line_index);	/* don't overdo things... */
		     char_count = char_count - 1;
		     char_index = char_index - 1;
		     chr = binary (unspec (substr (text, char_index, 1)), 9);
		     if char_type (chr) ^= 11		/* blanks */
		     then go to barf_at_not_allowed_inner_prod;
		end;
		go to barf_at_not_allowed_inner_prod;	/* should not get here */
	     end;

skip_blanks_for_inner_prod:
	char_count = char_count + 1;
	if char_count = 0
	then go to unexpected_end_of_text;
	chr = fixed (unspec (substr (text, char_index + 1, 1)), 9);
	char_index = char_index + 1;
	if char_type (chr) = 11
	then go to skip_blanks_for_inner_prod;

	if char_type (chr) ^= 14
	then go to barf_at_ill_inner_prod;

/* definitely an inner product, chr = right operator */

	temp_ptr = addr (operator_bead_table (op_index (chr)));

/* lexeme -> left opr, temp_ptr -> right opr */

	if ^(temp_ptr -> operator_bead.allow_product)
	then go to barf_at_not_allowed_inner_prod;

/* inner product is OK.  Dig up the correct inner-product bead */

	lexeme =
	     addr (inner_product_table (fixed (lexeme -> operator_bead.op1, 17), fixed (temp_ptr -> operator_bead.op1, 17)))
	     ;
	go to hrund_replace;			/* write over the lexeme of the left operator */


snail (17):					/* semicolon */
	if paren_level = 0				/* top level? */
	then do;
		if line_type = Diamond_type
		then do;
			code = apl_error_table_$mixed_diamonds_and_semicolons;
			go to error;
		     end;

		line_type = Semicolon_type;
	     end;
	else do;					/* within some sort of brackets or parens */
		if paren_stack (paren_level) = P_S_Opr_Brackets
		then go to barf_at_misplaced_semicolon;

		if paren_stack (paren_level) = P_S_Parens
						/* Argument List */
		then do;
			next_lexeme = OperatorLexeme;
			lexeme = addr (operator_bead_table (op_index (SemiColonCons)));
			go to hrund_emit;
		     end;
	     if paren_stack (paren_level) = P_S_qCALL_Parens
						/* qCALL argument List */
	     then do;
		next_lexeme = OperatorLexeme;
		lexeme = addr (operator_bead_table (op_index (QuadCALLSemicolon)));
		go to hrund_emit;
	     end;
	     end;

	next_lexeme = SemiColon;			/* Mixed Output */
	go to get_hrund_emit;


snail (23):					/* diamond */
	if paren_level ^= 0
	then go to barf_at_misplaced_diamond;

	if line_type = Semicolon_type
	then do;
		code = apl_error_table_$mixed_diamonds_and_semicolons;
		go to error;
	     end;

	line_type = Diamond_type;
	stmt_number = stmt_number + 1;

	if stmt_number > hbound (stmt_length_map, 1)
	then do;
		code = apl_error_table_$too_many_statements;
		go to error;
	     end;

	stmt_length_map (stmt_number) = 0;
	next_lexeme = Diamond;
	go to get_hrund_emit;

snail (18):					/* left parenthesis */
	paren_level = paren_level + 1;
	paren_stack (paren_level) = P_S_Parens;
	paren_loc (paren_level) = char_index;
	next_lexeme = OpenParenLexeme;
	if last_lexeme = NameLexeme
	then if temp_lexeme_array (lexeme_index - 1) = addr (operator_bead_table (op_index (QuadCALL)))
	     then paren_stack (paren_level) = P_S_qCALL_Parens;
	go to get_hrund_emit;

snail (20):					/* right parenthesis */
	if paren_level = 0
	then go to barf_at_excess_right_parens;
	if paren_stack (paren_level) ^= P_S_Parens & paren_stack (paren_level) ^= P_S_qCALL_Parens
	then go to barf_at_mismatched_parens;
	if last_lexeme = OperatorLexeme
	then go to barf_at_not_end_with_value;
	if last_lexeme = OpenParenLexeme
	then go to barf_at_not_end_with_value;

	paren_level = paren_level - 1;
	next_lexeme = ValueLexeme;
	go to get_hrund_emit;


snail (19):					/* left bracket */
	if last_lexeme = OperatorLexeme
	then if lexeme -> operator_bead.allow_brackets
	     then do;

/* brackets after mixed operator */

		     paren_level = paren_level + 1;
		     paren_stack (paren_level) = P_S_Opr_Brackets;
		     paren_loc (paren_level) = char_index;
		     last_lexeme = OpenParenLexeme;
		     temp_lexeme_array (lexeme_index - 1) = addr (lexeme -> mixed_op.brackets_operator_bead);
		     go to get_hrund_emit;		/* left opr bracket same as left bracket */
		end;
	     else go to barf_at_ill_opr_brackets;	/* brackets after operator, but operator doesn't want them */
	else if last_lexeme = BeginOfLine
	then go to barf_at_brackets_beginning;
	else if last_lexeme = OpenParenLexeme
	then go to barf_at_brackets_beginning;
	else if last_lexeme = SemiColon
	then go to barf_at_brackets_beginning;
	else if last_lexeme = Diamond
	then go to barf_at_brackets_beginning;

/* a valid use of brackets for subscripting */

	paren_level = paren_level + 1;
	paren_stack (paren_level) = P_S_Brackets;
	paren_loc (paren_level) = char_index;
	next_lexeme = OpenParenLexeme;
	go to get_hrund_emit;


snail (21):					/* right bracket */
	if paren_level = 0
	then go to barf_at_excess_right_brackets;
	if paren_stack (paren_level) ^= P_S_Brackets
	then if paren_stack (paren_level) ^= P_S_Opr_Brackets
	     then go to barf_at_mismatched_parens;
	     else do;				/* opr brackets */
		     next_lexeme = OperatorLexeme;
		     lexeme = addr (operator_bead_table (op_index (RightOprBracket)));
						/* funny bracket for rank spec. */
		     if last_lexeme = OpenParenLexeme
		     then go to barf_at_not_end_with_value;
						/* empty brackets not allowed */
		     else if last_lexeme = OperatorLexeme
		     then go to barf_at_not_end_with_value;
		end;
	else do;					/* regular brackets */
		next_lexeme = ValueLexeme;
		lexeme = addr (operator_bead_table (op_index (RightBracket)));
		if last_lexeme = OperatorLexeme
		then go to barf_at_not_end_with_value;
	     end;

	paren_level = paren_level - 1;
	go to hrund_emit;

/*** routines for emitting lexemes ***/

hrund_replace:					/* write new OperatorLexeme over old, last_lexeme need not be changed.  For inner product, etc. */
	temp_lexeme_array (lexeme_index - 1) = lexeme;
	go to start_new_lexeme;



hrund_emit_operator:
snail (14):
	next_lexeme = OperatorLexeme;
get_hrund_emit:
	lexeme = addr (operator_bead_table (op_index (chr)));
hrund_emit:					/* emit lexeme, set last_lexeme, and re-enter main loop on next character */
	call emission;
	go to start_new_lexeme;

emission:
     proc;

	if last_lexeme = ConstantLexeme
	then call convert_constant;			/* get constant off stack and into value bead, emit ptr to
							   value bead.   This makes room avail to emit next ptr */

	space_left_in_stack = space_left_in_stack - temp_lexeme_size;
	if space_left_in_stack < 0
	then go to value_stack_exceeded;
	temp_lexeme_array (lexeme_index) = lexeme;
	source_pos (lexeme_index) = char_index;		/* assume was one-character token */
	if char_count >= 0
	then source_pos (lexeme_index) = source_pos (lexeme_index) + 1;
						/* adjust for forged newline, which
							   didn't bump char_index.  Happens mainly
							   in names */
	lexeme_index = lexeme_index + 1;
	stmt_length_map (stmt_number) = stmt_length_map (stmt_number) + 1;
	last_lexeme = next_lexeme;
     end emission;



convert_constant:
     proc;

	if stack_value_ptr -> value_bead.total_data_elements = 1
	then /* scalar */
	     stack_value_ptr -> value_bead.rhorho = 0;
	else stack_value_ptr -> value_bead.rho (1) = stack_value_ptr -> value_bead.total_data_elements;

	if a_bad_lexeme_index ^= 0
	then temp_ptr = null;
	else call apl_copy_value_ ((stack_value_ptr), temp_ptr);
						/* take value bead off stack, put in heap */

/* now emit temp_ptr.   already know about lexeme_index, space_left_in_stack, etc. */

	temp_lexeme_array (lexeme_index - 1) = temp_ptr;
	last_lexeme = ValueLexeme;
	space_left_in_stack =
	     maximum_value_stack_size - fixed (rel (value_stack_space), 18) - lexeme_index * temp_lexeme_size;

     end convert_constant;

/*** name lexer ***/

snail (1):					/* alphabetic, underscore, delta, and underscored versions of these */
	if chr = UnderLine
	then do;
		code = apl_error_table_$underscore_cant_begin_id;
		go to error;
	     end;

snail (2):					/* E */
snail (3):					/* Quad */
	name_buffer_ptr = addr (paren_stack (paren_level + 1));
						/* put name buffer at top of parse stack */
	name_index = 0;				/* start at beginning of name buffer */

nm (1):						/* letter, etc. */
nm (2):						/* E */
nm (5):						/* digit */
						/* legal name constituents come here */
	name_buffer_array (name_index) = chr;		/* drop character into name */
	name_index = name_index + 1;

	char_count = char_count + 1;
	if char_count >= 0
	then begin;
		go to case (esw);
case (1):
case (2):
		go to unexpected_end_of_text;		/* line, function is system error */

case (3):
		chr = NewLine;			/* execute is similar except don't adjust char_count */
	     end;
	else do;
		chr = fixed (unspec (substr (text, char_index + 1, 1)), 9);
		char_index = char_index + 1;
	     end;
	go to nm (char_type (chr));

nm (0):
nm (3):
nm (4):
nm (6):
nm (7):
nm (8):
nm (9):
nm (10):
nm (11):
nm (12):
nm (13):
nm (14):
nm (15):
nm (16):
nm (17):
nm (18):
nm (19):
nm (20):
nm (21):
nm (22):
nm (23):						/* break character found.  Name has ended.  Make a lexeme for it */
	if name_buffer_array (0) = Quad
	then if name_index = 1
	     then lexeme = addr (operator_bead_table (op_index (Quad)));
	     else do;				/* system name */
		     do n = lbound (system_names, 1) to hbound (system_names, 1);
			if system_names (n) = name_buffer
			then do;
				lexeme = addr (operator_bead_table (op_index (n)));
				go to emit_name;
			     end;
		     end;
		     go to barf_at_unknown_system_name; /* not in table */
		end;

	else if name_index > 2			/* stop/trace control */
	then if name_buffer_array (1) = Delta
	     then if name_buffer_array (0) = LetterT
		then go to trace_control;
		else if name_buffer_array (0) = LetterS
		then go to stop_control;
		else go to pl1_loss;
	     else go to pl1_loss;
	else
pl1_loss:						/* because & loses in if */
	     do;					/* not a special name, look up in symbol table and check for label */

		if a_bad_lexeme_index ^= 0
		then lexeme = null;
		else call apl_get_symbol_ (name_buffer, lexeme, (0));
		if esw = apl_function_lex_
		then if chr = Colon
		     then if last_lexeme = BeginOfLine
			then do;			/* process label */
				if statement_map (line_no).label ^= null
				then go to barf_at_excess_label;
				if lexeme ^= null	/* protect loop if we are just re-lexing for errors */
				then do n = 1 to line_no - 1;
					if statement_map (n).label = lexeme
					then go to duplicate_label;
				     end;
				statement_map (line_no).label = lexeme;
						/* store ptr to symbol bead in stmt map */
				number_of_labels = number_of_labels + 1;
				go to start_new_lexeme;
			     end;
	     end;

emit_name:					/* emit name lexeme then look at chr again */
	next_lexeme = NameLexeme;
	call emission;
	source_pos (lexeme_index - 1) = source_pos (lexeme_index - 1) - name_index;
						/* -> beginning of name */
	go to snail (char_type (chr));



stop_control:
	call s_t_emit_name;
	lexeme = addr (operator_bead_table (op_index (SDelta)));
	go to emit_name;				/* put out funny lexeme which looks like system-variable */

trace_control:
	call s_t_emit_name;
	lexeme = addr (operator_bead_table (op_index (TDelta)));
	go to emit_name;				/* put out funny lexeme which looks like a system variable */


s_t_emit_name:
     proc;

	if a_bad_lexeme_index ^= 0
	then lexeme = null;
	else call apl_get_symbol_ (substr (name_buffer, 3), lexeme, (0));
						/* get ptr to symbol bead for fcn */
	next_lexeme = NameLexeme;			/* first put out name of function, then SD or TD lexeme */
	call emission;
	source_pos (lexeme_index - 1) = source_pos (lexeme_index - 1) - name_index;
						/* -> beginning of name */
     end s_t_emit_name;

/*** character constants ***/

snail (12):
	if last_lexeme ^= ConstantLexeme
	then do;					/* start a value bead in the stack */

		source_pos (lexeme_index) = char_index;
		lexeme_index = lexeme_index + 1;	/* as if we has emitted the constant-lexeme already */
		stmt_length_map (stmt_number) = stmt_length_map (stmt_number) + 1;
		stack_value_ptr = addr (temp_lexeme_array (lexeme_index));
		last_lexeme = ConstantLexeme;
		number_of_dimensions = 1;
		space_left_in_stack = space_left_in_stack - size (value_bead);
						/* = size of empty value bead with one rho vector entry */
		if space_left_in_stack < 0
		then go to value_stack_exceeded;

		string (stack_value_ptr -> value_bead.type) = character_value_type;
						/* don't worry about size field - never looked at since in stack */
		stack_value_ptr -> value_bead.reference_count = -1;
		stack_value_ptr -> value_bead.total_data_elements = 0;
						/* start out as '', the null string */
		stack_value_ptr -> value_bead.rhorho = 1;
						/* .. */
						/* don't worry about rho(1), will be set by convert_constant */
						/* also convert_constant will take care of the scalar case */
		stack_value_ptr -> value_bead.data_pointer = addr (stack_value_ptr -> value_bead.rho (2));
						/* first free loc */
		n = -1;				/* set up byte ctr to append new word */
	     end;
	else if stack_value_ptr -> value_bead.data_type.character_value
	then /* OK to append to prev string */
	     n = -1 - mod (stack_value_ptr -> value_bead.total_data_elements, 4);
						/* mod 4 char ctr, -4 to -1 */
	else go to barf_at_constant_mism;		/* not OK to append to prev # */

/* now append characters of quoted string to stack_value_ptr -> value_bead */

char_constant_loop:
	char_count = char_count + 1;
	if char_count = 0
	then go to unexpected_eot_char_constant;
	chr = fixed (unspec (substr (text, char_index + 1, 1)), 9);
	char_index = char_index + 1;
	if chr = Apostrophe
	then do;					/* may be end of string or insertion of quote into string */
		char_count = char_count + 1;
		if char_count = 0
		then if esw = apl_execute_lex_
		     then do;
			     chr = NewLine;
			     go to process_newline;
			end;
		     else go to unexpected_eot_char_constant;
		chr = fixed (unspec (substr (text, char_index + 1, 1)), 9);
		char_index = char_index + 1;
		if chr ^= Apostrophe
		then go to snail (char_type (chr));	/* end of string */
	     end;					/* two quotes, fall through to put one into string */

/* drop chr into string */

	n = n + 1;
	if n = 0
	then do;
		n = -4;				/* append new word to value bead */
		space_left_in_stack = space_left_in_stack - 1;
		if space_left_in_stack < 0
		then go to value_stack_exceeded;
	     end;

	unspec (stack_value_ptr -> value_bead.data_pointer
	     -> character_datum (stack_value_ptr -> value_bead.total_data_elements)) = bit (fixed (chr, 9), 9);
	stack_value_ptr -> value_bead.total_data_elements = stack_value_ptr -> value_bead.total_data_elements + 1;
	go to char_constant_loop;

/*** numeric constant processing ***/


start_negative_number:
snail (6):
	number_buffer = decimal_zero;			/* zero out digit(0:33), must_be_zero */
	sign = "-";
	char_count = char_count + 1;
	if char_count = 0
	then go to barf_at_lone_upper_minus;
	chr = fixed (unspec (substr (text, char_index + 1, 1)), 9);
	char_index = char_index + 1;
	if char_type (chr) = 5
	then go to number_proc;
	else if chr = Period
	then go to dec_point_join;
	else go to barf_at_lone_upper_minus;


start_number:
snail (5):
	number_buffer = decimal_zero;
number_proc:
	if esw ^= apl_scan_
	then call numsetup;


	expona = -(1 + hbound (digit, 1) + 1);		/* digit counter and exponent offset */

	if chr ^= Zero
	then go to numip (5);

/* gobble leading zeroes */

numiplz:
	char_count = char_count + 1;
	if char_count = 0
	then begin;
		go to case (esw);
case (1):
case (2):
		go to unexpected_end_of_text;
case (0):
case (3):
		chr = NewLine;
	     end;
	else do;
		chr = fixed (unspec (substr (text, char_index + 1, 1)), 9);
		char_index = char_index + 1;
	     end;
	if chr = Zero
	then go to numiplz;
	else if chr = Period
	then do;
		if esw ^= apl_scan_
		then string (stack_value_ptr -> value_bead.type) =
			string (stack_value_ptr -> value_bead.type) & not_integer_mask;
		else token_type = 4;

		exponb = expona;
		go to numfplz;
	     end;
	else go to numip (char_type (chr));		/* not leading-char, process it */

numip (5):					/* add another digit to integer part */
	digit (expona + 1 + hbound (digit, 1) + 1) = chr;
	expona = expona + 1;
	if expona = 0
	then go to eat_up_long_number_ip;

	char_count = char_count + 1;
	if char_count = 0
	then begin;
		go to case (esw);
case (1):
case (2):
		go to unexpected_end_of_text;
case (0):
case (3):
		chr = NewLine;
	     end;
	else do;
		chr = fixed (unspec (substr (text, char_index + 1, 1)), 9);
		char_index = char_index + 1;
	     end;
	go to numip (char_type (chr));

numip (7):					/* decimal point ends integer part, begins fraction part */
	if esw ^= apl_scan_
	then string (stack_value_ptr -> value_bead.type) = string (stack_value_ptr -> value_bead.type) & not_integer_mask;
						/* decimal point means not an integer (not always, e.g. 1.0, but assume always anyway) */
	else token_type = 4;

	exponb = expona;
	go to numfp_join;

numfp (5):					/* add another digit to fraction part */
	digit (exponb + 1 + hbound (digit, 1) + 1) = chr;
	exponb = exponb + 1;
	if exponb = 0
	then go to eat_up_long_number_fp;
numfp_join:
	char_count = char_count + 1;
	if char_count = 0
	then begin;
		go to case (esw);
case (1):
case (2):
		go to unexpected_end_of_text;
case (0):
case (3):
		chr = NewLine;
	     end;
	else do;
		chr = fixed (unspec (substr (text, char_index + 1, 1)), 9);
		char_index = char_index + 1;
	     end;
	go to numfp (char_type (chr));


numip (2):
numfp (2):
numhp1 (2):
numhp2 (2):					/* E seen - begin exponent */
	if esw ^= apl_scan_
	then string (stack_value_ptr -> value_bead.type) = string (stack_value_ptr -> value_bead.type) & not_integer_mask;
	else token_type = 4;			/* if there is an exponent, decide that it is not an integer */
	exponb = 0;				/* expona = number of digits of integer part - (1+hbound(digit,1)+1) */
						/* exponb gets exponent */
	negative_exponent = "0"b;			/* assume no upper minus after E */

	char_count = char_count + 1;
	if char_count = 0
	then begin;
		go to case (esw);
case (1):
case (2):
		go to unexpected_end_of_text;
case (0):
case (3):
		chr = NewLine;
	     end;
	else do;
		chr = fixed (unspec (substr (text, char_index + 1, 1)), 9);
		char_index = char_index + 1;
	     end;
	if chr = UpperMinus
	then negative_exponent = "1"b;
	else go to numep (char_type (chr));

numep_getc:
	char_count = char_count + 1;
	if char_count = 0
	then begin;
		go to case (esw);
case (1):
case (2):
		go to unexpected_end_of_text;
case (0):
case (3):
		chr = NewLine;
	     end;
	else do;
		chr = fixed (unspec (substr (text, char_index + 1, 1)), 9);
		char_index = char_index + 1;
	     end;
	go to numep (char_type (chr));

numep (5):					/* add digit to exponent */
	exponb = exponb * 10 + chr - Zero;
	go to numep_getc;

numep (0):
numep (1):
numep (2):
numep (3):
numep (4):
numep (6):
numep (8):
numep (9):
numep (10):
numep (11):
numep (12):
numep (13):
numep (14):
numep (15):
numep (16):
numep (17):
numep (18):
numep (19):
numep (20):
numep (21):
numep (22):
numep (23):					/* finish exponent (break chr seen) */
	if negative_exponent
	then exponb = -exponb;

	expona = expona + exponb;			/* set expona as if 0's given instead of E, fall through */

numip (0):
numip (1):
numip (3):
numip (4):
numip (6):
numip (8):
numip (9):
numip (10):
numip (11):
numip (12):
numip (13):
numip (14):
numip (15):
numip (16):
numip (17):
numip (18):
numip (19):
numip (20):
numip (21):
numip (22):
numip (23):
numfp (0):
numfp (1):
numfp (3):
numfp (4):
numfp (6):
numfp (8):
numfp (9):
numfp (10):
numfp (11):
numfp (12):
numfp (13):
numfp (14):
numfp (15):
numfp (16):
numfp (17):
numfp (18):
numfp (19):
numfp (20):
numfp (21):
numfp (22):
numfp (23):
numhp1 (0):
numhp1 (1):
numhp1 (3):
numhp1 (4):
numhp1 (6):
numhp1 (8):
numhp1 (9):
numhp1 (10):
numhp1 (11):
numhp1 (12):
numhp1 (13):
numhp1 (14):
numhp1 (15):
numhp1 (16):
numhp1 (17):
numhp1 (18):
numhp1 (19):
numhp1 (20):
numhp1 (21):
numhp1 (22):
numhp1 (23):
numhp2 (0):
numhp2 (1):
numhp2 (3):
numhp2 (4):
numhp2 (6):
numhp2 (8):
numhp2 (9):
numhp2 (10):
numhp2 (11):
numhp2 (12):
numhp2 (13):
numhp2 (14):
numhp2 (15):
numhp2 (16):
numhp2 (17):
numhp2 (18):
numhp2 (19):
numhp2 (20):
numhp2 (21):
numhp2 (22):
numhp2 (23):
number_finish:					/* finish number (break chr seen) */
						/* put in expona as the exponent */
	expona = expona + 1;			/* fudge,fudge, wonderful fudge from fudgetown! */

	if expona > 127
	then go to substitute_infinity;		/* next statement would raise size condition */
	if expona < -127
	then go to substitute_zero;			/* ... */
	exponent = expona;				/* pack exponent into decimal number */

	if abs (number_buffer) > decimal (TheBiggestNumberWeveGot)
	then go to substitute_infinity;
	else if abs (number_buffer) < decimal (TheSmallestNumberWeveGot)
	then go to substitute_zero;			/* OK, number_buffer may now be assigned to numeric_datum without raising any conditions or otherwise losing */

	apl_number = binary (number_buffer * magic_rounding_constant, 63);

num_spit_out:
	if esw = apl_scan_
	then go to end_number_scan;
	space_left_in_stack = space_left_in_stack - size (apl_number_for_size);
	if space_left_in_stack < 0
	then go to value_stack_exceeded;

	stack_value_ptr -> value_bead.data_pointer -> numeric_datum (stack_value_ptr -> value_bead.total_data_elements) =
	     apl_number;
	if stack_value_ptr -> value_bead.data_type.zero_or_one_value
	then /* some possibility that might be 0 or 1 */
	     if apl_number ^= 0.0e0
	     then if apl_number ^= 1.0e0
		then /* so see whether or not it really is */
		     stack_value_ptr -> value_bead.data_type.zero_or_one_value = "0"b;
	stack_value_ptr -> value_bead.total_data_elements = stack_value_ptr -> value_bead.total_data_elements + 1;
	go to snail (char_type (chr));		/* number has been emitted, look at break chr again */



start_number_with_decimal_point:
	number_buffer = decimal_zero;
dec_point_join:
	expona, exponb = -(1 + hbound (digit, 1) + 1);
	if esw ^= apl_scan_
	then do;
		call numsetup;
		string (stack_value_ptr -> value_bead.type) =
		     string (stack_value_ptr -> value_bead.type) & not_integer_mask;
	     end;
	else token_type = 4;

numfplz:						/* skip over leading zeroes in fraction part */
	char_count = char_count + 1;
	if char_count = 0
	then begin;
		go to case (esw);
case (1):
case (2):
		go to unexpected_end_of_text;
case (0):
case (3):
		chr = NewLine;
	     end;
	else do;
		chr = fixed (unspec (substr (text, char_index + 1, 1)), 9);
		char_index = char_index + 1;
	     end;
	if chr ^= Zero
	then go to numfp (char_type (chr));
	expona = expona - 1;			/* adjust for zero being thrown away */
	go to numfplz;


/* come here when numeric underflow */

substitute_zero:
	apl_number = 0.0e0;
	go to num_spit_out;

/* come here when numeric overflow */

substitute_infinity:
	if sign = "-"
	then apl_number = -TheBiggestNumberWeveGot;
	else apl_number = TheBiggestNumberWeveGot;
	go to num_spit_out;


/* come here if two decimal points in a number */

numep (7):
numfp (7):
numhp2 (7):
	if esw = apl_scan_
	then go to end_number_scan;
	code = apl_error_table_$extra_decimal_point;
	go to error;


/* come here to eat up extra digits if the loser types more than 60 or so */

numhp1 (5):
	expona = expona + 1;			/* these digits are still to the left of a decimal point */
eat_up_long_number_ip:
	char_count = char_count + 1;
	if char_count = 0
	then begin;
		go to case (esw);
case (1):
case (2):
		go to unexpected_end_of_text;
case (0):
case (3):
		chr = NewLine;
		go to number_finish;
	     end;
	chr = fixed (unspec (substr (text, char_index + 1, 1)), 9);
	char_index = char_index + 1;
	go to numhp1 (char_type (chr));


eat_up_long_number_fp:
numhp2 (5):
numhp1 (7):					/* eat digits to right of decimal point */
	char_count = char_count + 1;
	if char_count = 0
	then begin;
		go to case (esw);
case (1):
case (2):
		go to unexpected_end_of_text;
case (0):
case (3):
		chr = NewLine;
		go to number_finish;
	     end;
	chr = fixed (unspec (substr (text, char_index + 1, 1)), 9);
	char_index = char_index + 1;
	go to numhp2 (char_type (chr));

numsetup:
     proc;

	if last_lexeme ^= ConstantLexeme
	then do;					/* make value bead, as with char constant */

		source_pos (lexeme_index) = char_index; /* as if we had already emitted the constant-lexeme */
		lexeme_index = lexeme_index + 1;
		stmt_length_map (stmt_number) = stmt_length_map (stmt_number) + 1;
		stack_value_ptr = addr (temp_lexeme_array (lexeme_index));
		last_lexeme = ConstantLexeme;

		number_of_dimensions = 1;
		if space_left_in_stack < size (value_bead) + 1
		then go to value_stack_exceeded;

		string (stack_value_ptr -> value_bead.type) = zero_or_one_value_type;
						/* some bits may get cleared later */
						/* don't worry about fields not assigned here, see char const comments */
		stack_value_ptr -> value_bead.reference_count = -1;
		stack_value_ptr -> value_bead.total_data_elements = 0;
		stack_value_ptr -> value_bead.rhorho = 1;

/* set data_pointer to next double word. */

		temp_ptr = addr (stack_value_ptr -> value_bead.rho (2));
						/* next available word. */
		if substr (rel (temp_ptr), 18, 1)	/* if on an odd word boundary */
		then temp_ptr = addrel (temp_ptr, 1);	/* then make it even */

		stack_value_ptr -> value_bead.data_pointer = temp_ptr;

		space_left_in_stack =
		     maximum_value_stack_size - fixed (rel (stack_value_ptr -> value_bead.data_pointer), 18);
	     end;
	else if stack_value_ptr -> value_bead.data_type.numeric_value
	then ;					/* OK to append to prev number */
	else go to barf_at_constant_mism;		/* not OK to append to prev string */
     end numsetup;

/*** routine called to get at least half a segment of value stack space.
     anyone who tries to lex a function bigger than this is crazy!
 ***/

setup_value_stack:
     proc;

dcl	apl_get_next_value_stack_seg_
			entry (fixed bin (21));

	value_stack_popper = ws_info.value_stack_ptr;	/* so can restore ws_info.value_stack_ptr on return */
	space_left_in_stack = maximum_value_stack_size - fixed (rel (value_stack_popper), 18);
	if space_left_in_stack < 32768
	then do;					/* this seg is too small, get another one */
		call apl_get_next_value_stack_seg_ (32768);
		value_stack_space = ws_info.value_stack_ptr;
		space_left_in_stack = maximum_value_stack_size - fixed (rel (value_stack_space), 18);
	     end;
	else value_stack_space = value_stack_popper;	/* if keeping same seg */
     end setup_value_stack;

snail (9):					/* skip over comment */
	call for_illumination_only;
	go to process_newline;

/*** hirsute apl assignment operator gets all kinds of help from this phase of parse so
	runtime parser will not have to do as much work ***/

snail (22):
	if last_lexeme = NameLexeme
	then if lexeme = null
	     then go to hrund_emit_operator;		/* if lexing for errors, will be null ptr */
	     else if lexeme -> general_bead.type.symbol
	     then go to hrund_emit_operator;		/* assignment to user variable, easy - just emit -<- lexeme */
	     else if lexeme -> general_bead.type.operator
	     then do;				/* assignment to system variable */
		     if lexeme -> operator_bead.ignores_assignment
		     then lexeme = addr (operator_bead_table (op_index (AssignIgnore)));
		     else if lexeme -> operator_bead.special_assignment
		     then lexeme = addr (lexeme -> system_var_op.assignment_to);
		     else go to ulose;

		     last_lexeme = OperatorLexeme;
		     go to hrund_replace;
		end;
	     else go to ulose;

	else if last_lexeme = ValueLexeme		/*****	   then if lexeme = addr(operator_bead_table(op_index(RightBracket))) then do;	*****/
	then do;					/**** this kludge is due to bad code by PL/I for pointer compare packed ****/
		hack_ptr = lexeme;
		if hack_ptr = addr (operator_bead_table (op_index (RightBracket)))
		then do;

/* subscripted assignment - first step is to find the left end of the subscript calculation */

/***** the following code has been hacked up because of bad code generated by the PL/I compiler
		       for comparing a packed pointer with the addr of something *****/

			n = 0;
			do begin_subscript_calc = lexeme_index - 1 by -1;
						/* look back */
			     hack_ptr = temp_lexeme_array (begin_subscript_calc);
						/* copy to avoid ptr compare bug and also because
								   optimizer did not optimize repeated references */
			     if hack_ptr = addr (operator_bead_table (op_index (RightBracket)))
			     then n = n + 1;
			     else if hack_ptr = addr (operator_bead_table (op_index (RightOprBracket)))
			     then n = n + 1;
			     else if hack_ptr = addr (operator_bead_table (op_index (RightParen)))
			     then n = n + 1;
			     else if hack_ptr = addr (operator_bead_table (op_index (LeftParen)))
			     then n = n - 1;
			     else if hack_ptr = addr (operator_bead_table (op_index (LeftBracket)))
			     then n = n - 1;
			     if n = 0
			     then go to exitloop_for_subscript_calc;
			end;
exitloop_for_subscript_calc:				/* begin_subscript_calc -> "[" lexeme */
			begin_subscript_calc = begin_subscript_calc - 1;
						/* lexeme being subscripted */
			lexeme = temp_lexeme_array (begin_subscript_calc);
			if lexeme = null
			then go to subscripted_assign_user_var;
						/* bug when lexing for errors */
			if lexeme -> general_bead.type.operator
			then if lexeme -> operator_bead.allow_subscripted_assignment
			     then temp_lexeme_array (begin_subscript_calc) =
				     addr (lexeme -> system_var_op.subscripted_assignment_to);

			     else if lexeme -> operator_bead.ignores_assignment
			     then temp_lexeme_array (begin_subscript_calc) =
				     addr (operator_bead_table (op_index (AssignIgnore)));
			     else do;
				     char_index = source_pos (begin_subscript_calc);
						/* get marker at right place */
				     go to barf_at_bad_subscripted_assignment_to_system_variable;
				end;
			else if lexeme -> general_bead.type.symbol
			then do;			/* subscripted assignment to user variable */
subscripted_assign_user_var:				/* move subscript to right of the assignment lexeme.  */
				space_left_in_stack = space_left_in_stack - temp_lexeme_size;
				if space_left_in_stack < 0
				then go to value_stack_exceeded;

				begin_subscript_calc = begin_subscript_calc + 1;
						/* -> leftmost thing to be moved to right */
				do i = lexeme_index by -1 while (i ^= begin_subscript_calc);
						/* Move Right to Left loop */
				     emission_array (i) = emission_array (i - 1);
				end;
				temp_lexeme_array (begin_subscript_calc) =
				     addr (operator_bead_table (op_index (AssignSub)));
						/* insert subscripted assignment operator to
								   the left of the brakcet subscript calculation */
				source_pos (begin_subscript_calc) = char_index;
				lexeme_index = lexeme_index + 1;
						/* one more lexeme has been emitted here */
				stmt_length_map (stmt_number) = stmt_length_map (stmt_number) + 1;
			     end;
			else go to barf_at_badass;

		     end;				/* end of subscripted-assignment do */
		else go to barf_at_badass;
	     end;					/****** end of hack_ptr do, due to PL/I compiler bug ******/
	else go to barf_at_badass;			/* assignment preceded by some random lexeme */

	temp_lexeme_array (lexeme_index - 1) = addr (operator_bead_table (op_index (RightOprBracket)));
	last_lexeme = OperatorLexeme;			/* assignment looks to right like monadic operator, with rank qualifier */
	go to start_new_lexeme;

/*** all has been lexed, make a lexed_function_bead ***/

end_of_text:
	if esw ^= apl_execute_lex_
	then if char_index ^= line_index
	     then go to barf_at_not_end_with_newline;

/** if errors occurred, don't make a lexed_function_bead since our caller won't look at it anyway **/

	if errors_occurred
	then go to die_die_die;

	lexeme_index = lexeme_index - 1;		/* flush extra  begin-line lexeme */

	if esw = apl_line_lex_
	then if line_no ^= 2
	     then go to barf_at_more_than_one_line;
	     else ;
	else if esw = apl_execute_lex_
	then if line_no ^= 2
	     then go to barf_at_more_than_one_line_execute;

/* allocate lexed_function_bead */

	if a_bad_lexeme_index ^= 0
	then go to ulose;				/* shouldn't get here! ought to have encountered
						   the bad lexeme by now */
	call apl_allocate_words_ (size (lexed_function_bead) + number_of_localized_symbols + 3 + 2 * number_of_labels
	     + lexeme_index + line_no - 1 - 1, lex_return_pointer);

	string (lex_return_pointer -> lexed_function_bead.type) = lexed_function_type;

	lex_return_pointer -> lexed_function_bead.name = function_being_lexed;
	lex_return_pointer -> lexed_function_bead.number_of_statements = line_no - 1;
	lex_return_pointer -> lexed_function_bead.number_of_localized_symbols =
	     number_of_localized_symbols + number_of_labels + 3;
	lex_return_pointer -> lexed_function_bead.number_of_labels = number_of_labels;
	lex_return_pointer -> lexed_function_bead.label_values_ptr =
	     addr (lex_return_pointer -> lexed_function_bead.label_values);
	lex_return_pointer -> lexed_function_bead.statement_map_ptr =
	     addr (lex_return_pointer -> lexed_function_bead.statement_map);
	lex_return_pointer -> lexed_function_bead.lexeme_array_ptr =
	     addr (lex_return_pointer -> lexed_function_bead.lexeme_array);
	lex_return_pointer -> lexed_function_bead.localized_symbols (ReturnSymbol) = return_value_symbol;
	lex_return_pointer -> lexed_function_bead.localized_symbols (LeftArgSymbol) = left_arg_symbol;
	lex_return_pointer -> lexed_function_bead.localized_symbols (RightArgSymbol) = right_arg_symbol;
	do n = 1 by 1 while (n <= number_of_localized_symbols);
	     lex_return_pointer -> lexed_function_bead.localized_symbols (n + 3) = MY.localized_symbols (n);
	end;

	if number_of_labels ^= 0
	then do;

/* set up label_values */


		template_ptr = addr (number_buffer);

/* initialize label template outside the loop, except the actual value, stored in apl_number */

		string (template_ptr -> value_bead.type) = label_type;
		template_ptr -> value_bead.total_data_elements = 1;
		template_ptr -> value_bead.rhorho = 0;
		template_ptr -> value_bead.data_pointer = addr (apl_number);

		n = number_of_localized_symbols + 3;
		do i = 1 by 1 while (i < line_no);	/* scan statement map for labels */
		     if statement_map (i).label ^= null
		     then do;			/* aha! a label */
			     n = n + 1;
			     lex_return_pointer -> lexed_function_bead.localized_symbols (n) = statement_map (i).label;
			     apl_number = i;	/* convert line number label is on to APL number */
			     call apl_copy_value_ (template_ptr,
				lex_return_pointer -> lexed_function_bead.label_values_ptr
				-> lexed_function_label_values (n - number_of_localized_symbols - 3));
			end;
		end;

		if n ^= lex_return_pointer -> lexed_function_bead.number_of_localized_symbols
		then /* whoops */
		     go to ulose;

	     end;					/*** end of if number_of_labels ^= 0 then do ***/

/* set up statement map */

	statement_count = line_no - 1;		/* set up dimension of lexed_function_statement_map */

	do n = 1 by 1 while (n < line_no);
	     lex_return_pointer -> lexed_function_bead.statement_map_ptr -> lexed_function_statement_map (n) =
		statement_map (n).lexeme_index;
	end;

/* now set up the actual lexeme array */

	first_lexeme = 1;
	do i = 1 by 1 while (i < line_no);		/* step thru each line */
	     output_index = statement_map (i).lexeme_index;
						/* new line begins same place as old */
	     line_len = output_index - first_lexeme + 1;

/* Each line begins with a BOL. It doesn't get moved. It will have the same
	        position in the output (lexemes are conserved). */

	     first_lexeme = first_lexeme + 1;		/* don't copy BOL */

	     do while (first_lexeme <= statement_map (i).lexeme_index);
		n = 0;
		done = "0"b;
		do lx = first_lexeme to statement_map (i).lexeme_index while (^done);
		     if temp_lexeme_array (lx) -> general_bead.type.operator
		     then if temp_lexeme_array (lx) -> operator_bead.type_code = diamond_type
			then done = "1"b;
			else n = n + 1;
		     else n = n + 1;
		end;

/* At this point n is the number of lexemes before the
		   diamond, if any */

		do lx = n - 1 to 0 by -1;		/* copy lexemes backwards */
		     lex_return_pointer -> lexed_function_bead.lexeme_array_ptr
			-> lexed_function_lexeme_array (output_index) = temp_lexeme_array (first_lexeme + lx);
		     output_index = output_index - 1;
		end;

/* If there is a diamond, copy it */

		first_lexeme = first_lexeme + n;

		if first_lexeme <= statement_map (i).lexeme_index
		then do;
			lex_return_pointer -> lexed_function_bead.lexeme_array_ptr
			     -> lexed_function_lexeme_array (output_index) = temp_lexeme_array (first_lexeme);
			output_index = output_index - 1;
			first_lexeme = first_lexeme + 1;
		     end;
	     end;

	     lex_return_pointer -> lexed_function_bead.lexeme_array_ptr -> lexed_function_lexeme_array (output_index) =
		temp_lexeme_array (output_index);
	end;

	ws_info.value_stack_ptr = value_stack_popper;	/* pop our temporary storage off the value stack */

/*** set up bits_for_parse field ***/

	unspec (lex_return_pointer -> lexed_function_bead.bits_for_parse) = ""b;
	lex_return_pointer -> lexed_function_bead.bits_for_parse.function = "1"b;
	lex_return_pointer -> lexed_function_bead.bits_for_parse.op1 = 99;
	if right_arg_symbol ^= null
	then if left_arg_symbol ^= null
	     then lex_return_pointer -> lexed_function_bead.bits_for_parse.dyadic = "1"b;
	     else lex_return_pointer -> lexed_function_bead.bits_for_parse.monadic = "1"b;

	return;					/* done!! */

/*** here are some error routines ***/

misplaced_right_arrow:
	code = apl_error_table_$misplaced_right_arrow;
	go to error;

snail (0):
snail (13):
	code = apl_error_table_$random_char;
	go to error;

barf_at_ill_reduction:
	if chr ^= Slash & chr ^= SlashHyphen
	then code = apl_error_table_$ill_scan;
	else code = apl_error_table_$ill_reduction;
	go to error;

ulose:
	code = apl_error_table_$lex_screwed_up;
	go to fatal_error;


barf_at_not_end_with_newline:
unexpected_end_of_text:
	if esw = apl_execute_lex_
	then do;
		code = apl_error_table_$too_short_execute;
		go to error;
	     end;
	code = apl_error_table_$not_end_with_newline;
	go to fatal_error;
barf_at_ill_inner_prod:
	code = apl_error_table_$ill_inner_prod;
	go to error;

barf_at_misplaced_diamond:
	code = apl_error_table_$misplaced_diamond;
	go to error;

barf_at_misplaced_semicolon:
	code = apl_error_table_$misplaced_semicolon;
	go to error;

barf_at_excess_right_parens:
	code = apl_error_table_$excess_right_parens;
	go to error;

barf_at_mismatched_parens:
	code = apl_error_table_$mismatched_parens;
	go to error;

barf_at_ill_opr_brackets:
	code = apl_error_table_$ill_opr_brackets;
	go to error;

barf_at_brackets_beginning:
	code = apl_error_table_$misplaced_brackets;
	go to error;

barf_at_excess_right_brackets:
	code = apl_error_table_$excess_right_brackets;
	go to error;

barf_at_not_end_with_value:
	code = apl_error_table_$not_end_with_value;
	go to error;

barf_at_ill_small_circle:
	code = apl_error_table_$ill_small_circle;
	go to error;

barf_at_unknown_system_name:
	code = apl_error_table_$unknown_system_name;
	go to err_back_over_name;

value_stack_exceeded:
	code = apl_error_table_$ws_full_in_lex;
	go to fatal_error;

barf_at_constant_mism:
	code = apl_error_table_$constant_mism;
	go to error;

unexpected_eot_char_constant:
	begin;
	     go to case (esw);
case (2):
	     if error_suppress
	     then go to case (3);			/* entry was apl_function_lex_no_messages_, diff. error */
	     code = apl_error_table_$mism_quotes;
	     go to fatal_error;
case (1):
case (3):						/* is user error rather than system error */
	     code = apl_error_table_$u_mism_ur_quotes;
	     go to error;

	end;

barf_at_ill_paren_level:
	char_count = char_count - (char_index - paren_loc (1));
	char_index = paren_loc (1);			/* location of left-most unbalanced paren */
	code = apl_error_table_$ill_paren_level;
	go to error;

barf_at_not_allowed_inner_prod:
	code = apl_error_table_$not_allowed_inner_prod;
	go to error;

barf_at_not_allowed_outer_prod:
	code = apl_error_table_$not_allowed_outer_prod;
	go to error;

barf_at_more_than_one_line:
	code = apl_error_table_$more_than_one_line;
	go to fatal_error;

barf_at_more_than_one_line_execute:
	code = apl_error_table_$more_than_one_line_execute;
	go to error;

barf_at_badass:
	code = apl_error_table_$badass;
	go to error;

barf_at_bad_subscripted_assignment_to_system_variable:
	code = apl_error_table_$bad_subsc_assign_sys_var;
	go to error;

barf_at_lone_upper_minus:
	if esw = apl_scan_
	then go to scan0 (0);
	code = apl_error_table_$lone_upper_minus;
	go to error;

barf_at_bad_localization:
	code = apl_error_table_$cant_be_localized;
	go to fatal_error;

barf_at_lone_period:
	code = apl_error_table_$lone_period;
	go to error;

barf_at_excess_label:
	code = apl_error_table_$excess_label;
	go to error;

duplicate_label:
	code = apl_error_table_$duplicate_label;
	go to error;

/*** routines transferred to by the above barfs ***/

err_back_over_name:					/* back up to beginning of identifier */
	do while ("1"b);
	     char_count = char_count - 1;
	     char_index = char_index - 1;
	     if char_index = 0
	     then go to err_hack;			/* reached begin of text */
	     n = char_type (fixed (unspec (substr (text, char_index - 1 + 1, 1))));
	     if n ^= 1
	     then if n ^= 2
		then if n ^= 3
		     then if n ^= 5
			then go to err_hack;	/* found break char preceding name */
	end;					/* keep looping */

err_hack:						/* exitloop for the preceding loop */
	char_count = char_count + 1;
	char_index = char_index + 1;			/* as if the chr to be marked had just been read */

/* fall into error */


error:						/* barf and go on to the next line looking for more errors */
	fatal = "0"b;
	if error_suppress
	then go to die_die_die;			/* if not allowed to print messages, just go tell caller.
						   don't even bother to check for any more errors */
	go to handle_lex_error;

fatal_error:					/* error from which lex cannot recover */
	fatal = "1"b;

handle_lex_error:					/* find length of the current line */
	begin;
	     go to case (esw);

case (1):
case (2):
	     ll = index (substr (text, char_index - 1 + 1), NL) - 1;
	     if ll < 0
	     then ll = length (substr (text, char_index - 1 + 1));
	     ll = ll + char_index - line_index /* +1-1*/;
	     go to endcase;

case (3):
	     ll = -char_count - 1 + char_index - line_index;
	     if char_count >= 0
	     then ll = ll + 1;			/* reached end of execute, forged NewLine
						   was not counted in char_index */

endcase:
	end;

	call apl_error_ (code, ""b, char_index - line_index /* +1-1 */, substr (text, line_index + 1, ll),
						/* the losing line */
	     function_being_lexed, line_no);

	if fatal
	then do;					/* crap out of lex */
die_die_die:
		errors_occurred = "1"b;		/* tell our caller that we have printed some error messages */
		call cleanup;
		lex_return_pointer = null;
		if esw = apl_function_lex_
		then if error_suppress
		     then if error_line_number_arg = 0
			then error_line_number_arg = line_no;
		return;
	     end;

	errors_occurred = "1"b;			/* tell our caller that we have printed some error messages */

/* nonfatal error, advance to next line and continue lexing */

	char_count = char_count + ll - char_index + line_index;
	char_index = line_index + ll;
	go to start_line;

/*** get rid of all the beads we generated ***/

cleanup:
     proc;

	do i = lbound (MY.localized_symbols, 1) by 1 while (i <= hbound (MY.localized_symbols, 1));
	     call wash (MY.localized_symbols (i));
	end;

	if last_lexeme = ConstantLexeme
	then n = hbound (temp_lexeme_array, 1) - 1;	/* last lexeme has not yet been stored into */
	else n = hbound (temp_lexeme_array, 1);

	do i = lbound (temp_lexeme_array, 1) by 1 while (i < n);
						/* yes, < not <= ! */
	     call wash (temp_lexeme_array (i));
	end;

	call wash (function_being_lexed);
	call wash (left_arg_symbol);
	call wash (right_arg_symbol);
	call wash (return_value_symbol);
	ws_info.value_stack_ptr = value_stack_popper;
	return;

wash:
     procedure (temp_ptr);

/* parameters */

dcl	temp_ptr		ptr unal parameter;

/* program */

	if temp_ptr ^= null
	then if ^temp_ptr -> general_bead.type.operator
	     then do;
		     temp_ptr -> general_bead.reference_count = temp_ptr -> general_bead.reference_count - 1;
		     if temp_ptr -> general_bead.reference_count < 1
		     then call apl_free_bead_ (temp_ptr);
		end;

     end wash;

     end cleanup;

/*** special entry point used by QuadFX ***/

apl_function_lex_no_messages_:
     entry (text, lex_return_pointer, errors_occurred, a_bad_lexeme_index, parse_stack_space, error_line_number_arg);

dcl	error_line_number_arg
			fixed bin;		/* returns number of the argument that lost */

	error_line_number_arg = 0;			/* initialize */
	error_suppress = "1"b;
	go to join_with_apl_function_lex_;

/*** this entry is for lexing a function.  It knows about header lines, labels, etc. ***/

apl_function_lex_:
     entry (text, lex_return_pointer, errors_occurred, a_bad_lexeme_index, parse_stack_space);


	error_suppress = "0"b;
join_with_apl_function_lex_:
	esw = apl_function_lex_;
	char_count = -length (text) - 1;
	errors_occurred = "0"b;
	last_lexeme = BeginOfLine;
	char_index = 0;
	lexeme_index = 1;
	line_no = 0;				/* in case of error in header line */
	line_index = 0;				/* in case of error in header line */
	call setup_value_stack;
	number_of_labels = 0;
	char_count = -length (text) - 1;

/*** process header line, producing localized_symbols  table, and
     setting the automatic variables function_being_lexed, left_arg_symbol, right_arg_symbol, return_value_symbol  ***/

	number_of_localized_symbols = 0;
	lexeme = null;
	return_value_symbol = null;			/* assume none will show up */

hdr1_loop:
hdr1 (11):					/* to ignore blanks at begin of header line */
	char_count = char_count + 1;
	if char_count = 0
	then go to unexpected_end_of_text;
	chr = fixed (unspec (substr (text, char_index + 1, 1)), 9);
	char_index = char_index + 1;

	go to hdr1 (char_type (chr));

hdr1 (0):
hdr1 (3):
hdr1 (4):
hdr1 (5):
hdr1 (6):
hdr1 (7):
hdr1 (8):
hdr1 (12):
hdr1 (13):
hdr1 (14):
hdr1 (15):
hdr1 (16):
hdr1 (18):
hdr1 (19):
hdr1 (20):
hdr1 (21):
hdr1 (23):
hdr2 (0):
hdr2 (3):
hdr2 (4):
hdr2 (5):
hdr2 (6):
hdr2 (7):
hdr2 (8):
hdr2 (12):
hdr2 (13):
hdr2 (14):
hdr2 (15):
hdr2 (16):
hdr2 (18):
hdr2 (19):
hdr2 (20):
hdr2 (21):
hdr2 (23):
hdr3 (0):
hdr3 (3):
hdr3 (4):
hdr3 (5):
hdr3 (6):
hdr3 (7):
hdr3 (8):
hdr3 (12):
hdr3 (13):
hdr3 (14):
hdr3 (15):
hdr3 (16):
hdr3 (18):
hdr3 (19):
hdr3 (20):
hdr3 (21):
hdr3 (22):
hdr3 (23):
hdr4 (0):
hdr4 (3):
hdr4 (4):
hdr4 (5):
hdr4 (6):
hdr4 (7):
hdr4 (8):
hdr4 (12):
hdr4 (13):
hdr4 (14):
hdr4 (15):
hdr4 (16):
hdr4 (18):
hdr4 (19):
hdr4 (20):
hdr4 (21):
hdr4 (22):
hdr4 (23):
hdr5 (0):
hdr5 (4):
hdr5 (5):
hdr5 (6):
hdr5 (7):
hdr5 (8):
hdr5 (12):
hdr5 (13):
hdr5 (14):
hdr5 (15):
hdr5 (16):
hdr5 (18):
hdr5 (19):
hdr5 (20):
hdr5 (21):
hdr5 (22):
hdr5 (23):					/* moby dispatch table */
	code = apl_error_table_$random_char_in_hdr;
	go to fatal_error;

hdr1 (17):
hdr1 (22):					/* semicolon, left arrow */
	code = apl_error_table_$need_name;
	go to fatal_error;


hdr1 (9):						/* lamp - just as a hack allow comments and blank lines before the header */
	call for_illumination_only;
hdr1 (10):					/* NewLine */
	go to hdr1_loop;


hdr1 (1):
hdr1 (2):						/* begin of name - parse it and stick it in lexeme  - may be return_value or fcn_name */
	call parse_name_in_header_line;
	go to hdr2 (char_type (chr));			/* look at chr that ended name */

/* HEADER 2 LOOP BEGINS HERE */

hdr2 (11):
	char_count = char_count + 1;
	if char_count = 0
	then go to unexpected_end_of_text;
	chr = fixed (unspec (substr (text, char_index + 1, 1)), 9);
	char_index = char_index + 1;

	go to hdr2 (char_type (chr));

hdr2 (9):						/* lamp - skip comment and trun into semicolon */
	call for_illumination_only;

hdr2 (10):					/* newline - there was nothing on the header line but the name of the function */
     hdr2 (17):					/* semicolon - similar except local vars to be done */
	function_being_lexed = lexeme;
	left_arg_symbol, right_arg_symbol = null;
	go to look_for_local_var_dcls;		/* which will check whether chr = NewLine or SemiColon */

hdr2 (22):					/* LeftArrow - lexeme is symbol whose value is value of fcn */
	if return_value_symbol = null
	then return_value_symbol = lexeme;
	else do;
		code = apl_error_table_$only_1_return_value;
		go to fatal_error;
	     end;
	go to hdr1_loop;				/* and go on in same state (just about) */


hdr2 (1):
hdr2 (2):						/* another symbol follows.  There are two cases:
	1) one more symbol follows.  It is right_arg_symbol and this one is fcn name
	2) two more symbols follow. This one is left_arg_symbol and they are right_arg_symbol and fcn_name
 */
	temp_ptr = lexeme;				/* hold this one in my hand until I know which case holds */

	call parse_name_in_header_line;
	go to hdr3 (char_type (chr));

/** now search for the break character of this name **/

/* HEADER 3 LOOP BEGINS HERE */

hdr3 (11):
	char_count = char_count + 1;
	if char_count = 0
	then go to unexpected_end_of_text;
	chr = fixed (unspec (substr (text, char_index + 1, 1)), 9);
	char_index = char_index + 1;
	go to hdr3 (char_type (chr));

hdr3 (9):						/* lamp - end it all.  skip over comment and fall into newline case */
	call for_illumination_only;

hdr3 (10):					/* newline - temp_ptr = fcn name and lexeme = right arg symbol */
hdr3 (17):					/* semicolon which is similar to newline */
	function_being_lexed = temp_ptr;
	right_arg_symbol = lexeme;
	left_arg_symbol = null;
	go to look_for_local_var_dcls;		/* which checks for semicolon or newline */


hdr3 (1):
hdr3 (2):						/* case 2 - another name follows. deposit the first two and then pick up the third one */
	left_arg_symbol = temp_ptr;
	function_being_lexed = lexeme;
	call parse_name_in_header_line;
	go to hdr4 (char_type (chr));


/* HEADER 4 LOOP BEGINS HERE */

hdr4 (11):					/* and scan up to following newline or semicolon */
	char_count = char_count + 1;
	if char_count = 0
	then go to unexpected_end_of_text;
	chr = fixed (unspec (substr (text, char_index + 1, 1)), 9);
	char_index = char_index + 1;
	go to hdr4 (char_type (chr));

hdr4 (1):
hdr4 (2):						/* still another name? that's no good */
	code = apl_error_table_$need_semicolon;
	go to fatal_error;

hdr4 (9):						/* lamp - skip over comment and trun into newline */
	call for_illumination_only;

hdr4 (10):					/* new line - store final arg symbol */
hdr4 (17):					/* semicolon is sort of like newline */
	right_arg_symbol = lexeme;
	go to look_for_local_var_dcls;

/* HEADER 5 LOOP BEGINS HERE */

hdr5 (11):
hdr5 (17):					/* skip extraneous blanks and semicolons */
	char_count = char_count + 1;
	if char_count = 0
	then go to unexpected_end_of_text;
	chr = fixed (unspec (substr (text, char_index + 1, 1)), 9);
	char_index = char_index + 1;

look_for_local_var_dcls:				/* enter here with chr = SemiColon or NewLine */
	go to hdr5 (char_type (chr));

hdr5 (9):						/* lamp - skip over comment and turn into NewLine */
	call for_illumination_only;

hdr5 (10):					/* newline - this ends the header line */
	statement_map_ptr = addr (MY.localized_symbols (number_of_localized_symbols + 1));
	go to start_line;				/* this is probably the right place to join with the apl_line_lex_ code */


hdr5 (1):
hdr5 (2):
hdr5 (3):						/* seen the beginning of a name - this is a localized variable */
	call parse_name_in_header_line;

	number_of_localized_symbols = number_of_localized_symbols + 1;
	MY.localized_symbols (number_of_localized_symbols) = lexeme;

nugatory_system_variable_localization:			/* abnormal exit from call to parse_name_in_header_line */
	go to hdr5 (char_type (chr));

/*** routine to gobble up a name in the header line.  Similar to the one for names everwhere else ***/

parse_name_in_header_line:
     proc;

	name_buffer_ptr = addr (MY.localized_symbols (number_of_localized_symbols + 1));
						/* first free loc on parse stack */
	name_index = 0;

hnm (1):
hnm (2):
hnm (5):
	name_buffer_array (name_index) = chr;
	name_index = name_index + 1;

	char_count = char_count + 1;
	if char_count = 0
	then go to unexpected_end_of_text;
	chr = fixed (unspec (substr (text, char_index + 1, 1)), 9);
	char_index = char_index + 1;
	go to hnm (char_type (chr));

hnm (0):
hnm (3):
hnm (4):
hnm (6):
hnm (7):
hnm (8):
hnm (9):
hnm (10):
hnm (11):
hnm (12):
hnm (13):
hnm (14):
hnm (15):
hnm (16):
hnm (17):
hnm (18):
hnm (19):
hnm (20):
hnm (21):
hnm (22):
hnm (23):						/* char found that's not allowed in name.  name has ended.  our caller will figure out what to do with chr */
	if name_buffer_array (0) = Quad
	then do;					/* localization of system variable is only case that can
						   come here */
		do n = lbound (system_names, 1) to hbound (system_names, 1);
		     if system_names (n) = name_buffer
		     then do;
			     if ^operator_bead_table (op_index (n)).system_variable
			     then go to barf_at_bad_localization;

/** localizing system variable, put pointer to operator bead **/

			     if operator_bead_table (op_index (n)).ignores_assignment
			     then go to nugatory_system_variable_localization;
						/* take abnormal exit if trivial */

			     lexeme = addr (operator_bead_table (op_index (n)));
			     return;
			end;
		end;
		go to barf_at_bad_localization;
	     end;

	else if a_bad_lexeme_index ^= 0
	then lexeme = null;
	else call apl_get_symbol_ (name_buffer, lexeme, (0));
						/* don't worry about quad names, stop-trace control, etc. */
	return;
     end parse_name_in_header_line;

/*** lamp munger ***/

for_illumination_only:
     proc;					/* this proc changes Lamp into NewLine */

	do while (chr ^= NewLine);
	     char_count = char_count + 1;
	     if char_count = 0
	     then if esw = apl_execute_lex_
		then chr = NewLine;
		else go to unexpected_end_of_text;
	     else do;
		     chr = fixed (unspec (substr (text, char_index + 1, 1)), 9);
		     char_index = char_index + 1;
		end;
	end;
     end for_illumination_only;


dcl	data_elements	fixed bin static init (0);	/* just to satisfy GGB's include file */

/***** simple lexer for use of outside world *****/


apl_scan_:
     entry (text, initial_scan_pos, scan_pos, scan_length, token_type, scan_number_ptr_structure);

/* dcl text char(*) aligned; */
dcl	initial_scan_pos	fixed bin (21),		/* (Input) where to start looking at text */
	scan_pos		fixed bin (21),		/* (Output) index of first char of token */
	scan_length	fixed bin (21),		/* (Output) number of characters in token */
	token_type	fixed bin,		/* (Output) 0=no token found, 1=random char, 2= name,
						  3 = positive integer, 4 = some random number */
	1 scan_number_ptr_structure
			aligned,			/* (Input) null or pointer to place to put number if token_type>=3 */
	  2 scan_number_ptr pointer unaligned;

dcl	editor_scan	bit (1) aligned;

	editor_scan = "0"b;
	go to scan_begin;

apl_editor_scan_:
     entry (text, initial_scan_pos, scan_pos, scan_length, token_type, scan_number_ptr_structure);

	editor_scan = "1"b;

scan_begin:
	esw = apl_scan_;
	char_index = initial_scan_pos - 1;
	char_count = -length (text) - 2 + initial_scan_pos;

	token_type = 0;
	scan_length = 0;				/* assuming will find no token */

/* skip leading blanks */
scan0 (11):
scan0 (10):
	char_count = char_count + 1;
	if char_count = 0
	then go to scan_end;
	chr = fixed (unspec (substr (text, char_index + 1, 1)), 9);
	char_index = char_index + 1;

	if editor_scan & chr = Delta
	then i = 14;				/* Make Delta a token by itself */
	else i = char_type (chr);			/* Normal case (Delta is an alphabetic */

	go to scan0 (i);

scan0 (1):
scan0 (2):					/* scan a name */
	token_type = 2;
	scan_pos = char_index;

scanm (1):
scanm (2):
scanm (5):
	char_count = char_count + 1;
	if char_count = 0
	then do;
		scan_length = char_index - scan_pos + 1;
		return;
	     end;
	chr = fixed (unspec (substr (text, char_index + 1, 1)), 9);
	char_index = char_index + 1;

	if editor_scan & chr = Delta
	then i = 14;				/* Make Delta a token by itself */
	else i = char_type (chr);			/* Normal case (Delta is an alphabetic */

	go to scanm (i);

scanm (0):
scanm (3):
scanm (4):
scanm (6):
scanm (7):
scanm (8):
scanm (9):
scanm (10):
scanm (11):
scanm (12):
scanm (13):
scanm (14):
scanm (15):
scanm (16):
scanm (17):
scanm (18):
scanm (19):
scanm (20):
scanm (21):
scanm (22):
scanm (23):
	scan_length = char_index - scan_pos;
	return;



/* number scanning */

scan0 (5):
	token_type = 3;
	scan_pos = char_index;
	go to start_number;

scan0 (6):
	token_type = 4;
	scan_pos = char_index;
	go to start_negative_number;

scan0 (7):
	token_type = 4;
	scan_pos = char_index;
	go to start_number_with_decimal_point;

end_number_scan:					/* return here when done with number */
	if scan_number_ptr ^= null
	then scan_number_ptr -> numeric_datum (0) = apl_number;
	scan_length = char_index - scan_pos;
	if char_count >= 0
	then scan_length = scan_length + 1;		/* char_index was not bumped for the
							   pseudo NewLine supplied at end of text */
	return;


/* come here when random character is encountered while scanning */

scan0 (3):
scan0 (0):
scan0 (4):
scan0 (8):
scan0 (9):
scan0 (12):
scan0 (13):
scan0 (14):
scan0 (15):
scan0 (16):
scan0 (17):
scan0 (18):
scan0 (19):
scan0 (20):
scan0 (21):
scan0 (22):
scan0 (23):
	token_type = 1;
	scan_length = 1;				/* random char is token by itself */
	scan_pos = char_index;
	return;

/* come here when end of text is reached by scan */

scan_end:
	if token_type >= 3
	then go to end_number_scan;
	scan_pos = char_index;
	return;					/* rest has already been set up (for no token) */


/**** put apl_canonicalize_line_ here sometime when I feel like writing it ****/


     end /* apl_lex_ */;
