/****^  *************************************************************************
        *                                                                       *
        * Copyright (c) 1980 by Centre Interuniversitaire de Calcul de Grenoble *
        * and Institut National de Recherche en Informatique et Automatique     *
        *                                                                       *
        ************************************************************************* */

/****^  HISTORY COMMENTS:
  1) change(86-10-05,JMAthane), approve(86-10-05,MCR7521),
     audit(86-10-09,JPFauche), install(86-11-12,MR12.0-1212):
     New args and defaults.
                                                   END HISTORY COMMENTS */

pascal: pas: proc;

/*

   "pascal" command : invocation of the Pascal compiler.

   This PL/1 program is the command level interface for the pascal compiler
   (written in Pascal). It checks the reentrance, the parameters, and sets
   the work environment of the compiler (io switchs, temp segs, ...) */

/* Written Jean-Michel Athane 1983 */
/* Added -ndb to -no_debug, added undocumented -cond "on" for "true", "off" for "false" 03/01/83 S. Herbst */
/* Added short name "pas" 03/01/84 S. Herbst */
/* Fixed to print final "errors detected" msg on error_output, rtrim compilation errmsgs 04/10/84 S. Herbst */

/* external references to the MULTICS system */

	dcl     com_err_		 entry options (variable);
	dcl     com_err_$suppress_name entry options (variable);
	dcl     cu_$arg_count	 entry (fixed bin);
	dcl     cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin (17), fixed bin (35));
	dcl     cv_dec_check_	 entry (char (*), fixed bin (35)) returns (fixed bin (35));
	dcl     expand_pathname_$add_suffix entry (char (*), char (*), char (*), char (*), fixed bin (35));
	dcl     release_temp_segments_ entry (char (*), (*) ptr, fixed bin (35));
	dcl     get_group_id_	 entry returns (char (32));
	dcl     get_temp_segments_	 entry (char (*), (*) ptr, fixed bin (35));
	dcl     get_temp_segment_	 entry (char (*), ptr, fixed bin (35));
	dcl     release_temp_segment_	 entry (char (*), ptr, fixed bin (35));
	dcl     hcs_$fs_get_path_name	 entry (ptr, char (*), fixed bin, char (*), fixed bin (35));
	dcl     ioa_		 entry options (variable);
	dcl     ioa_$ioa_switch	 entry options (variable);
	dcl     iox_$open		 entry (ptr, fixed bin, bit (1), fixed bin (35));
	dcl     iox_$position	 entry (ptr, fixed bin, fixed bin (21), fixed bin (35),);
	dcl     iox_$get_line	 entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
	dcl     iox_$attach_name	 entry (char (*), ptr, char (*), ptr, fixed bin (35));
	dcl     iox_$look_iocb	 entry (char (*), ptr, fixed bin (35));
	dcl     iox_$destroy_iocb	 entry (ptr, fixed bin (35));
	dcl     hcs_$status_long	 entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35));
	dcl     hcs_$status_mins	 entry (ptr, fixed bin (2), fixed bin (24), fixed bin (35));
	dcl     hcs_$initiate	 entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
	dcl     object_info_$display	 entry (ptr, fixed bin (24), ptr, fixed bin (35));
	dcl     get_wdir_		 entry returns (char (168));
	dcl     iox_$find_iocb	 entry (char (*), ptr, fixed bin (35));
	dcl     iox_$close		 entry (ptr, fixed bin (35));
	dcl     iox_$detach_iocb	 entry (ptr, fixed bin (35));
	dcl     iox_$error_output	 ext ptr;
	dcl     clock_		 entry returns (fixed bin (71));
	dcl     virtual_cpu_time_	 entry returns (fixed bin (71));
	dcl     error_table_$badopt	 fixed bin (35) ext;
	dcl     error_table_$end_of_info fixed bin (35) ext;
	dcl     error_table_$long_record fixed bin (35) ext;
	dcl     error_table_$segknown	 fixed bin (35) ext;
	dcl     error_table_$short_record fixed bin (35) ext;
	dcl     system_info_$installation_id entry (char (*));
	dcl     adjust_bit_count_	 entry (char (168), char (32), bit (1), fixed bin (35), fixed bin (35));
	dcl     date_time_		 entry (fixed bin (71), char (*));
	dcl     tssi_$clean_up_segment entry (ptr);
	dcl     user_info_$process_type entry (fixed bin (17));
	dcl     tssi_$get_file	 entry (char (*), char (*), ptr, ptr, ptr, fixed bin (35));
	dcl     tssi_$finish_file	 entry (ptr, fixed bin, fixed bin (24), bit (36), ptr, fixed bin (35));
	dcl     tssi_$clean_up_file	 entry (ptr, ptr);
	dcl     msf_manager_$get_ptr	 entry (ptr, fixed bin, bit (1), ptr, fixed bin (24), fixed bin (35));
	dcl     convert_status_code_	 entry (fixed bin (35), char (8), char (100));

/* external references to other Pascal entry points */

	dcl     RACINE_defs$mpcogin	 ptr ext;
	dcl     RACINE_defs$firstcond	 ptr ext;
	dcl     RACINE_defs$ch8flag	 fixed bin (35) ext;
	dcl     RACINE_defs$no_compilation_warnings fixed bin (35) ext;
	dcl     pascal_error_table_$bad_syn_chain fixed bin (35) ext;
	dcl     pascal_gen_rel_$def	 entry (bit (5), fixed bin);
	dcl     pascal_gen_rel_$link	 entry (bit (5), fixed bin);
	dcl     pascal_gen_rel_$ps_def entry (bit (5), fixed bin);
	dcl     pascal_sources_management_$clean entry;
	dcl     racine		 entry (char (*), fixed bin (35)); /* main entry of the Pascal compiler */
	dcl     (pascal_create_area, pascal_reset_area) entry options (variable);

/* external statics */

	dcl     pascal_severity_	 fixed bin (35) ext static;

/* internal statics */

	dcl     absolute_compiler_path char (168) int static;
	dcl     absolute_source_path	 char (168) varying int static;
	dcl     pascal_is_busy	 fixed bin int static init (0);
	dcl     pascal_error_label	 label int static;
	dcl     in_ptr		 int static ptr;
	dcl     err_ptr		 int static ptr;
	dcl     first_invocation	 bit (1) init ("1"b) int static;
	dcl     1 oi		 like object_info int static;
	dcl     installation_id	 char (32) int static;
	dcl     process_type	 fixed bin (17) int static;

/* constants */

	dcl     compiler_input	 char (7) int static options (constant) init ("mpcogin");
	dcl     compiler_output	 char (8) int static options (constant) init ("mpcogout");
	dcl     compiler_error	 char (8) int static options (constant) init ("mpcogerr");

/* automatics */

	dcl     my_firstcond	 ptr;		/* ptr to the first condbox allocated by pascal command */
	dcl     condname		 char (32) varying;
	dcl     box_ptr		 ptr;
	dcl     ldn		 fixed bin;
	dcl     error_switch	 bit (1);
	dcl     n_read		 fixed bin (21);
	dcl     PARM		 char (100);
	dcl     arg_count		 fixed bin;
	dcl     bad_arg_switch	 fixed bin;
	dcl     i			 fixed bin;
	dcl     COND		 fixed bin (35);
	dcl     ps_var_string	 char (168) varying;
	dcl     ps_entry_name	 char (32);
	dcl     ps_aclinfo_ptr	 ptr;
	dcl     absolute_list_path	 char (168) varying;
	dcl     code		 fixed bin (35);
	dcl     arg_len		 fixed bin (17);
	dcl     arg_ptr		 ptr;
	dcl     parm_string		 char (100) varying;
	dcl     list_ptr		 ptr;
	dcl     list_entry_name	 char (32);
	dcl     dir_name		 char (168);
	dcl     entryname		 char (32);
	dcl     entry_type		 fixed bin (2);
	dcl     temp_list_dir	 char (168);
	dcl     temp_list_entry	 char (32);
	dcl     temp_list_path	 char (168) varying;
	dcl     atd_ptr		 ptr;
	dcl     page_length		 fixed bin (35);
	dcl     link_length		 fixed bin (35);
	dcl     source_ptr		 ptr;
	dcl     word_count		 fixed bin (35);
	dcl     def_ptr		 ptr;
	dcl     bit_count		 fixed bin (35);
	dcl     bc		 fixed bin (24);
	dcl     label_variable	 label;
	dcl     my_base		 ptr;
	dcl     var_string		 char (168) varying;
	dcl     list_aclinfo_ptr	 ptr;
	dcl     object_aclinfo_ptr	 ptr;
	dcl     command_line	 char (256);
	dcl     list_ok		 fixed bin;
	dcl     error_message	 char (256) varying;
	dcl     status_message	 char (100);
	dcl     short_info		 char (8);
	dcl     list_fcb_ptr	 ptr;
	dcl     1 list_status_branch	 like status_branch;
	dcl     last_component_ptr	 ptr;
	dcl     last_component_nbr	 fixed bin;
	dcl     trap_pair_offset	 bit (18);

	dcl     1 command_switches,
		2 listing_switches,
		  3 bfm_sw	 bit (1) unal,
		  3 list_sw	 bit (1) unal,
		  3 map_sw	 bit (1) unal,
		2 table_switches,
		  3 bftb_sw	 bit (1) unal,
		  3 tb_sw		 bit (1) unal,
		2 language_switches,
		  3 full_sw	 bit (1) unal,
		  3 iso_sw	 bit (1) unal,
		  3 sol_sw	 bit (1) unal,
		2 profile_switches,
		  3 pf_sw		 bit (1) unal,
		  3 lpf_sw	 bit (1) unal,
		2 aen_sw		 bit (1) unal,
		2 db_sw		 bit (1) unal,
		2 french_sw	 bit (1) unal,
		2 em_sw		 bit (1) unal,
		2 int_sw		 bit (1) unal,
		2 iow_sw		 bit (1) unal,
		2 ps_sw		 bit (1) unal,
		2 rlc_sw		 bit (1) unal;

/* based */

	dcl     1 attach_description	 based,
		2 length		 fixed bin (17),
		2 string		 char (0 refer (attach_description.length));

	dcl     1 label		 based,
		2 target		 ptr,
		2 stack		 ptr;

	dcl     arg		 char (arg_len) based (arg_ptr);

	dcl     1 a		 based (arg_ptr),
		2 first		 char (2) unal,
		2 l7		 char (7) unal;

	dcl     1 def_header	 based (def_ptr),
		2 def_list_relp	 bit (18) unal,
		2 unused		 bit (18) unal,
		2 hash_table_relp	 bit (18) unal,
		2 flags		 unal,
		  3 new_format	 bit (1) unal,
		  3 ignore	 bit (1) unal,
		  3 unused	 bit (16) unal,
		2 all_zero_word	 bit (36),
		2 seg_name,
		  3 num_chars	 fixed bin (9) unsigned unal,
		  3 string	 char (0 refer (def_header.seg_name.num_chars)) unal,
		2 def_seg		 aligned like definition;

	dcl     1 symb		 based (def_ptr),
		2 symb_name,
		  3 num_chars	 fixed bin (9) unsigned unal,
		  3 string	 char (12),
		2 def_symb	 aligned like definition;

	dcl     1 val		 based,
		2 high		 bit (18) unal,
		2 low		 bit (18) unal;

	dcl     1 condbox		 based (box_ptr),	/* SEE CONSTTYPE.incl.pascal */
		2 name		 char (32),
		2 nextcond	 ptr,
		2 (active, activated, setinargs) fixed bin (35);

/* builtins */

	dcl     null		 builtin;
	dcl     addrel		 builtin;
	dcl     rel		 builtin;
	dcl     ptr		 builtin;
	dcl     addr		 builtin;
	dcl     length		 builtin;
	dcl     substr		 builtin;
	dcl     rtrim		 builtin;

/* conditions */

	dcl     (cleanup, pascal_error) condition;
%page;
/* check the reentrance */

	pascal_severity_ = 0;

	if pascal_is_busy = 1 then do;
		call com_err_ (0, "pascal", "The Pascal compiler has been previously invoked and suspended.
It cannot be invoked recursively. Use ""release"" first.");
		pascal_severity_ = 4;
		return;
	     end;

	if first_invocation = "1"b then do;
		call system_info_$installation_id (installation_id);
		pascal_context_$user_id = get_group_id_ ();
		call user_info_$process_type (process_type);
here:
		label_variable = here;
		my_base = ptr (addr (label_variable) -> label.target, 0);
		call hcs_$fs_get_path_name (my_base, dir_name, i, entryname, code);
		if code ^= 0 then do;
first_error:
			call com_err_ (code, "pascal", "");
			pascal_severity_ = 5;
			return;
		     end;
		absolute_compiler_path = rtrim (dir_name) || ">" || rtrim (entryname);
		call pascal_create_area (absolute_compiler_path, "-bf", "-size", "500");
		call hcs_$status_mins (my_base, entry_type, bc, code);
		if code ^= 0 then go to first_error;
		oi.version_number = object_info_version_2;
		call object_info_$display (my_base, bc, addr (oi), code);
		if code ^= 0 then go to first_error;
		pascal_context_$compiler_created = oi.compile_time;
		pascal_context_$realformataddr = addr (pascal_context_$realformatstring);
		pascal_context_$integerformataddr = addr (pascal_context_$integerformatstring);
		pascal_context_$asciiformataddr = addr (pascal_context_$asciiformatstring);
		pascal_context_$octalformataddr = addr (pascal_context_$octalformatstring);
		pascal_context_$nilformataddr = addr (pascal_context_$nilformatstring);
		first_invocation = "0"b;
	     end;

	call set_for_cleanup;
	on cleanup call cleanup_compiler;

	RACINE_defs$firstcond = null;
	RACINE_defs$ch8flag = 0;
	RACINE_defs$no_compilation_warnings = 0;

	pascal_context_$time = clock_ ();
	pascal_context_$cpu = virtual_cpu_time_ ();

/* check the parameters */

	pascal_context_$options.ps = "0"b;
	pascal_context_$options.bind = "1"b;
	error_switch = "1"b;
	pascal_context_$option_list, parm_string = "";
	pascal_context_$options.profile,
	     pascal_context_$options.list,
	     pascal_context_$options.table,
	     pascal_context_$options.brief_table,
	     pascal_context_$options.ref_table,
	     pascal_context_$options.map,
	     pascal_context_$options.brief_map,
	     pascal_context_$options.generated_code,
	     pascal_context_$options.add_exportable_names,
	     pascal_context_$options.long_profile = "0"b;
	bad_arg_switch = 0;
						/* default values for control_args*/
	command_switches = "0"b;
	tb_sw, int_sw,				/* September the 17th 1984 */
	     em_sw, db_sw, full_sw, iow_sw, rlc_sw = "1"b;

	call cu_$arg_count (arg_count);

	if arg_count = 0 then do;
		call com_err_$suppress_name (0, "pascal", "Usage: pascal path {-control_args}");
		pascal_severity_ = 5;
		go to comp_aborted_;
	     end;

	if arg_count > 1 then do;
		do i = 2 to arg_count;
		     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
		     if code ^= 0 then go to standard_error_;
		     if (arg = "-add_exportable_names") | (arg = "-aen") then do;
			     aen_sw = "1"b;
			     pascal_context_$option_list = pascal_context_$option_list || "add_exportable_names ";
			end;
		     else if (arg = "-brief_map") | (arg = "-bfm") then do;
			     listing_switches = "0"b;
			     bfm_sw = "1"b;
			     pascal_context_$option_list = pascal_context_$option_list || "brief_map ";
			end;
		     else if (arg = "-brief_table") | (arg = "-bftb") then do;
			     table_switches = "0"b;
			     bftb_sw = "1"b;
			     pascal_context_$option_list = pascal_context_$option_list || "table ";
			end;
		     else if (arg = "-ecc")
			| (arg = "-extended_character_code") then do;
			     RACINE_defs$ch8flag = 1;
			     pascal_context_$option_list = pascal_context_$option_list ||
				"extended_character_code";
			end;
		     else if (arg = "-necc")
			| (arg = "-no_extended_character_code") then do;
			     RACINE_defs$ch8flag = 0;
			     pascal_context_$option_list = pascal_context_$option_list ||
				"no_extended_character_code";
			end;
		     else if (arg = "-ncw")
			| (arg = "-no_compilation_warnings") then do;
			     RACINE_defs$no_compilation_warnings = 1;
			     pascal_context_$option_list = pascal_context_$option_list ||
				"no_compilation_warnings";
			end;
		     else if (arg = "-cw")
			| (arg = "-compilation_warnings") then do;
			     RACINE_defs$no_compilation_warnings = 0;
			     pascal_context_$option_list = pascal_context_$option_list ||
				"compilation_warnings";
			end;
		     else if (arg = "-debug") | (arg = "-db") then do;
			     db_sw = "1"b;
			     pascal_context_$option_list = pascal_context_$option_list || "debug ";
			end;
		     else if (arg = "-english") then do;
			     french_sw = "0"b;
			     pascal_context_$option_list = pascal_context_$option_list || "english ";
			end;
		     else if (arg = "-error_messages") | (arg = "-em") then do;
			     em_sw = "1"b;
			     pascal_context_$option_list = pascal_context_$option_list || "error_messages ";
			end;
		     else if (arg = "-french") then do;
			     french_sw = "1"b;
			     pascal_context_$option_list = pascal_context_$option_list || "french ";
			end;
		     else if (arg = "-full_extensions") | (arg = "-full") then do;
			     language_switches = "0"b;
			     full_sw = "1"b;
			     pascal_context_$option_list = pascal_context_$option_list || "full_extensions ";
			end;
		     else if (arg = "-interactive") | (arg = "-int") then do;
			     int_sw = "1"b;
			     pascal_context_$option_list = pascal_context_$option_list || "interactive ";
			end;
		     else if (arg = "-io_warnings") | (arg = "-iow") then do;
			     iow_sw = "1"b;
			     pascal_context_$option_list = pascal_context_$option_list || "io_warnings ";
			end;
		     else if (arg = "-list") then do;
			     listing_switches = "0"b;
			     list_sw = "1"b;
			     pascal_context_$option_list = pascal_context_$option_list || "list ";
			end;
		     else if (arg = "-long_profile") | (arg = "-lpf") then do;
			     profile_switches = "0"b;
			     lpf_sw = "1"b;
			     pascal_context_$option_list = pascal_context_$option_list || "long_profile ";
			end;
		     else if (arg = "-map") then do;
			     listing_switches = "0"b;
			     map_sw = "1"b;
			     pascal_context_$option_list = pascal_context_$option_list || "map ";
			end;
		     else if (arg = "-no_debug") | (arg = "-ndb") then do;
			     db_sw = "0"b;
			     pascal_context_$option_list = pascal_context_$option_list || "no_debug ";
			end;
		     else if (arg = "-no_error_messages") | (arg = "-nem") then do;
			     em_sw = "0"b;
			     pascal_context_$option_list = pascal_context_$option_list || "no_error_messages ";
			end;
		     else if arg = ("-no_interactive") | (arg = "-nint") then do;
			     int_sw = "0"b;
			     pascal_context_$option_list = pascal_context_$option_list || "no_interactive ";
			end;
		     else if (arg = "-no_io_warnings") | (arg = "-niow") then do;
			     iow_sw = "0"b;
			     pascal_context_$option_list = pascal_context_$option_list || "no_io_warnings ";
			end;
		     else if (arg = "-no_list") then do;
			     listing_switches = "0"b;
			     pascal_context_$option_list = pascal_context_$option_list || "no_list ";
			end;
		     else if (arg = "-no_long_profile") | (arg = "-nlpf") then do;
			     lpf_sw = "0"b;
			     pascal_context_$option_list = pascal_context_$option_list || "no_long_profile ";
			end;
		     else if (arg = "-no_private_storage") | (arg = "-nps") then do;
			     ps_sw = "0"b;
			     pascal_context_$option_list = pascal_context_$option_list || "no_private_storage ";
			end;
		     else if (arg = "-no_profile") | (arg = "-npf") then do;
			     pf_sw = "0"b;
			     pascal_context_$option_list = pascal_context_$option_list || "no_profile ";
			end;
		     else if (arg = "-no_relocatable") | (arg = "-nrlc") |
			(arg = "-nonrelocatable") | (arg = "-non_relocatable") then do;
			     rlc_sw = "0"b;
			     pascal_context_$option_list = pascal_context_$option_list || "no_relocatable ";
			end;
		     else if (arg = "-no_table") | (arg = "-ntb") then do;
			     tb_sw = "0"b;
			     pascal_context_$option_list = pascal_context_$option_list || "no_table ";
			end;
		     else if (arg = "-page_length") | (arg = "-pl") then do;
			     if arg_count = i then do;
				     call com_err_ (0, "pascal",
					"No value specified for -page_length");
				     bad_arg_switch = 1;
				end;
			     else do;
				     i = i + 1;
				     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
				     if code ^= 0 then go to standard_error;
				     page_length = cv_dec_check_ (arg, code);
				     if code ^= 0 then do;
					     call com_err_ (0, "pascal",
						"Invalid integer -page_length value ^a", arg);
					     bad_arg_switch = 1;
					end;
				     else do;
					     if (page_length < 10) | (page_length > 99) then do;
						     call com_err_ (0, "pascal",
							"Value of -page_length must be between 10 and 99");
						     bad_arg_switch = 1;
						end;
					     else do;
						     parm_string = parm_string || "LP" || arg || " ";
						     pascal_context_$option_list =
							pascal_context_$option_list || "lp " || arg || " ";
						end;
					end;
				end;
			end;
		     else if (arg = "-private_storage") | (arg = "-ps") then do;
			     ps_sw = "1"b;
			     pascal_context_$option_list = pascal_context_$option_list || "private_storage ";
			end;
		     else if (arg = "-profile") | (arg = "-pf") then do;
			     profile_switches = "0"b;
			     pf_sw = "1"b;
			     pascal_context_$option_list = pascal_context_$option_list || "profile ";
			end;
		     else if (arg = "-relocatable") | (arg = "-rlc") then do;
			     rlc_sw = "1"b;
			     pascal_context_$option_list = pascal_context_$option_list || "relocatable ";
			end;
		     else if (arg = "sol_extensions") | (arg = "-sol") then do;
			     language_switches = "0"b;
			     sol_sw = "1"b;
			     pascal_context_$option_list = pascal_context_$option_list || "sol_extensions ";
			end;
		     else if (arg = "-standard") then do;
			     language_switches = "0"b;
			     iso_sw = "1"b;
			     pascal_context_$option_list = pascal_context_$option_list || "standard ";
			end;
		     else if (arg = "-table") | (arg = "-tb") then do;
			     table_switches = "0"b;
			     tb_sw = "1"b;
			     pascal_context_$option_list = pascal_context_$option_list || "table ";
			end;
		     else if (arg = "-reference_table") | (arg = "-rftb") then do;
			     table_switches = "0"b;
			     tb_sw = "1"b;
			     pascal_context_$options.ref_table = "1"b;
			     pascal_context_$option_list = pascal_context_$option_list || "reference_table ";
			end;
		     else
			if (arg = "-conditional_execution") | (arg = "-cond") then do;
			     if (i + 2) > arg_count then do;
cond_syntax_error:
				     call com_err_ (0, "pascal", "Bad syntax in ""-cond"" value.");
				     bad_arg_switch = 1;
				     go to cond_err;
				end;
			     call cu_$arg_ptr (i + 1, arg_ptr, arg_len, code);
			     if code ^= 0 then go to standard_error;
			     condname = translate (arg, "abcdefghijklmnopqrstuvwxyz", "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
			     allocate condbox;
			     condbox.nextcond = RACINE_defs$firstcond;
			     RACINE_defs$firstcond, my_firstcond = box_ptr;
			     condbox.name = condname;
			     condbox.setinargs = 1;
			     condbox.activated = 0;
			     call cu_$arg_ptr (i + 2, arg_ptr, arg_len, code);
			     if code ^= 0 then go to standard_error;
			     if arg = "true" | arg = "on" then condbox.active = 1;
			     else if arg = "false" | arg = "off" then condbox.active = 0;
			     else go to cond_syntax_error;
			     pascal_context_$option_list = pascal_context_$option_list ||
				"conditional_execution " || condname || " " || arg || " ";
cond_err:
			     i = i + 2;
			end;
		     else
			if (arg = "-fast_mode") | (arg = "-fast") then do;
			     parm_string = parm_string || "FAST ";
			     pascal_context_$option_list = pascal_context_$option_list || "fast_mode ";
			end;
		     else
			if (arg_len = 9) & ((a.l7 = "TRACE=0") |
			(a.l7 = "TRACE=1") | (a.l7 = "TRACE=2") | (a.l7 = "TRACE=3"))
			& ((a.first = "-S") | (a.first = "-G") | (a.first = "-D")) then do;
			     parm_string = parm_string || arg || " ";
			     pascal_context_$option_list = pascal_context_$option_list || arg || " ";
			end;
		     else do;
			     bad_arg_switch = 1;
			     call com_err_ (error_table_$badopt, "pascal", "^a", arg);
			end;
		end;
	     end;

/* parameters for compiler itself */
	if list_sw then do;
		parm_string = parm_string || "LIST PRCODE ";
		pascal_context_$options.generated_code = "1"b; pascal_context_$options.list = "1"b;
	     end;
	else if map_sw then do;
		parm_string = parm_string || "LIST ";
		pascal_context_$options.list = "1"b; pascal_context_$options.map = "1"b;
	     end;
	else if bfm_sw then do;
		parm_string = parm_string || "BRIEFMAP ";
		pascal_context_$options.list = "1"b; pascal_context_$options.brief_map = "1"b;
	     end;
	if tb_sw then do;
		parm_string = parm_string || "TABLE ";
		pascal_context_$options.table = "1"b;
		if pascal_context_$options.ref_table then
		     parm_string = parm_string || "REFS ";
		else pascal_context_$options.ref_table = "0"b;
	     end;
	else if bftb_sw then do;
		parm_string = parm_string || "BRIEFTB ";
		pascal_context_$options.brief_table = "1"b;
	     end;
	if pf_sw then do;
		parm_string = parm_string || "PROFILE ";
		pascal_context_$options.profile = "1"b;
	     end;
	else if lpf_sw then do;
		parm_string = parm_string || "LONGPROF ";
		pascal_context_$options.long_profile = "1"b;
	     end;
	if full_sw then do;
		parm_string = parm_string || "NOSTAND ";
	     end;
	else if iso_sw then do;
	     end;
	else if sol_sw then do;
		parm_string = parm_string || "STDSOL ";
	     end;
	if int_sw then do;
		parm_string = parm_string || "INTER ";
		pascal_context_$options.interactive = "1"b;
	     end;
	if ps_sw then do;
		pascal_context_$options.ps = "1"b;
	     end;
	if french_sw then do;
		parm_string = parm_string || "FRENC ";
	     end;
	if ^iow_sw then do;
		parm_string = parm_string || "NOIOW ";
	     end;
	if ^db_sw then do;
		parm_string = parm_string || "NOCHECKS ";
	     end;
	if ^rlc_sw then do;
		pascal_context_$options.bind = "0"b;
	     end;
	if aen_sw then do;
		pascal_context_$options.add_exportable_names = "1"b;
	     end;
	if ^em_sw then do;
		error_switch = "0"b;
	     end;

/* source (arg 1) */

	call cu_$arg_ptr (1, arg_ptr, arg_len, code);
	if code ^= 0 then go to standard_error_;

	call expand_pathname_$add_suffix (arg, "pascal",
	     pascal_context_$source_dir_name, pascal_context_$source_entry_name, code);
	if code ^= 0 then do;
		call com_err_ (code, "pascal", "^a", arg);
		pascal_severity_ = 5;
		go to comp_aborted_;
	     end;

	var_string = rtrim (pascal_context_$source_entry_name);
	absolute_source_path = rtrim (pascal_context_$source_dir_name) || ">" || var_string;

	call hcs_$initiate (pascal_context_$source_dir_name, pascal_context_$source_entry_name, "",
	     0, 0, source_ptr, code);
	if (code ^= 0) & (code ^= error_table_$segknown) then do;
		call com_err_ (code, "pascal", "^a", absolute_source_path);
		pascal_severity_ = 5;
		go to comp_aborted_;
	     end;

	if bad_arg_switch = 1 then do;
		pascal_severity_ = 5;
		go to comp_aborted_;
	     end;

/* initialise now */

	list_ok, pascal_context_$object_ok, pascal_context_$ps_ok, link_length, COND = 0;
	list_aclinfo_ptr, object_aclinfo_ptr, ps_aclinfo_ptr = null;

	var_string = substr (var_string, 1, length (var_string) - length (".pascal"));
	pascal_context_$object_entry_name = var_string;
	if pascal_context_$options.ps = "1"b then do;
		ps_var_string = var_string || ".defs";
		ps_entry_name = ps_var_string;
	     end;

	pascal_context_$working_dir_name = get_wdir_ ();

	if pascal_context_$options.list = "1"b then do;
		list_entry_name = rtrim (pascal_context_$object_entry_name) || ".list";
		absolute_list_path = rtrim (pascal_context_$working_dir_name) || ">" || rtrim (list_entry_name);

		call tssi_$get_file (pascal_context_$working_dir_name, list_entry_name, list_ptr,
		     list_aclinfo_ptr, list_fcb_ptr, code);
		if code ^= 0 then do;
			call com_err_ (code, "pascal", "Error while get ^a", absolute_list_path);
			pascal_severity_ = 5;
			go to comp_aborted;
		     end;
		call hcs_$fs_get_path_name (list_ptr, temp_list_dir, ldn, temp_list_entry, code);
		if code ^= 0 then go to standard_error;
		temp_list_path = rtrim (temp_list_dir) || ">" || rtrim (temp_list_entry);
	     end;

/* get temp work segments */

	if pascal_context_$options.ps = "1"b then do;
		call get_temp_segments_ ("pascal_compiler", pascal_context_$ps_segs, code);
		if code ^= 0 then go to temp_err;
	     end;

	if pascal_context_$options.generated_code then do;
		call get_temp_segment_ ("pascal_compiler", pascal_context_$usednamesaddr, code);
		if code ^= 0 then go to temp_err;
	     end;

	call get_temp_segments_ ("pascal_compiler", pascal_context_$segs, code);
	if code ^= 0 then do;
temp_err:
		call com_err_ (code, "pascal", "Error while get compiler temp work segs");
		pascal_severity_ = 5;
		go to comp_aborted_;
	     end;

	pascal_context_$stats_ptr = pascal_context_$statlink_ptr;
	pascal_context_$links_ptr = addrel (pascal_context_$statlink_ptr, 2 ** 17);
	pascal_context_$map_ptr = addrel (pascal_context_$symb_ptr, 2 ** 17);
	pascal_context_$prof_ptr = addrel (pascal_context_$map_ptr, 2 ** 16);

/* attach the io_switchs for input and output of the compiler */

	in_ptr, pascal_context_$out_ptr, err_ptr = null;

	call iox_$find_iocb (compiler_input, in_ptr, code);
	if code ^= 0 then go to standard_error_;

	call verify_io (in_ptr);

	call iox_$attach_name (compiler_input, in_ptr, "vfile_ " || absolute_source_path, null, code);
	if code ^= 0 then do;
		call com_err_ (code, "pascal",
		     "Error attaching ""^a"" switch ""vfile_ ^a"" for compiler input.",
		     compiler_input, absolute_source_path);
		pascal_severity_ = 5;
		go to comp_aborted_;
	     end;
	call iox_$find_iocb (compiler_output, pascal_context_$out_ptr, code);
	if code ^= 0 then go to standard_error_;

	call verify_io (pascal_context_$out_ptr);

	if pascal_context_$options.list = "1"b then do;
		call iox_$attach_name (compiler_output, pascal_context_$out_ptr,
		     "vfile_ " || temp_list_path, null, code);
		if code ^= 0 then do;
			call com_err_ (code, "pascal",
			     "Error attaching ""^a"" switch ""vfile_ ^a""  for compiler output.",
			     compiler_output, temp_list_path);
			pascal_severity_ = 5;
			go to comp_aborted_;
		     end;
	     end;
	else do;
		call iox_$attach_name (compiler_output, pascal_context_$out_ptr, "discard_", null, code);
		if code ^= 0 then do;
			call com_err_ (code, "pascal",
			     "Error attaching ""^a"" switch ""discard_"" for compiler output.",
			     compiler_output);
			pascal_severity_ = 5;
			go to comp_aborted;
		     end;
	     end;

	call iox_$find_iocb (compiler_error, err_ptr, code);
	if code ^= 0 then go to standard_error_;

	call verify_io (err_ptr);

	if error_switch = "1"b then do;
		call iox_$attach_name (compiler_error, err_ptr, "syn_ user_output", null, code);
		if code ^= 0 then do;
			call com_err_ (code, "pascal",
			     "Error attaching ""^a"" switch ""syn_ user_output"" for compiler error messages.",
			     compiler_error);
			pascal_severity_ = 5;
			go to comp_aborted_;
		     end;
	     end;
	else do;
		call iox_$attach_name (compiler_error, err_ptr, "discard_", null, code);
		if code ^= 0 then do;
			call com_err_ (code, "pascal",
			     "Error attaching ""^a"" switch ""discard_"" for compiler error messages.",
			     compiler_error);
			pascal_severity_ = 5;
			go to comp_aborted_;
		     end;
	     end;

/* init the different sections and generation variables */

/* -text */

	pascal_context_$text_word_count = 0;

/* -definition */

	def_ptr = pascal_context_$def_ptr;
	def_header.flags.new_format = "1"b;
	def_header.flags.ignore = "1"b;

	seg_name.num_chars = length (var_string);
	seg_name.string = var_string;
	word_count = 3 + ((seg_name.num_chars + 4) / 4);
	def_list_relp = addr (word_count) -> val.low;
	pascal_context_$segname_def_ptr = ptr (pascal_context_$def_ptr, word_count);
	def_seg.forward, def_seg.segname = rel (addrel (pascal_context_$segname_def_ptr, 7));
	def_seg.backward = "000000000000000010"b;	/* 2 : all zero word */
	def_seg.value = "000000000000000010"b;		/* 2 */
	def_seg.flags.new = "1"b;
	def_seg.class = "011"b;			/* 3 */
	def_seg.symbol = "000000000000000011"b;		/* 3 : string */

	def_ptr = ptr (def_ptr, word_count + 3);
	symb_name.num_chars = 12;
	symb_name.string = "symbol_table";
	pascal_context_$last_def_ptr = ptr (pascal_context_$def_ptr, word_count + 7);

	def_symb.backward, def_symb.segname = rel (pascal_context_$segname_def_ptr);
	def_symb.forward = "000000000000000010"b;	/* 2 : all zero word */
	def_symb.flags.new = "1"b;
	def_symb.class = "010"b;			/* 2 */
	def_symb.symbol = rel (def_ptr);
	pascal_context_$def_word_count = word_count + 10;
						/*
	if pascal_context_$options.table = "1"b then do;	/* generate link to symbol_table */
						/* trap pair */
	def_ptr = addrel (def_ptr, 7);		/* 7 = size(symb) */
	trap_pair_offset = rel (def_ptr);
	def_ptr -> type_pair.type = "000000000000000001"b;
	def_ptr -> type_pair.seg_ptr = "000000000000000010"b;
	def_ptr -> type_pair.trap_ptr,
	     def_ptr -> type_pair.ext_ptr = "0"b;
						/* exp word */
	def_ptr = addrel (def_ptr, 2);
	def_ptr -> type_ptr = trap_pair_offset;
	def_ptr -> exp = "0"b;

	pascal_context_$def_word_count = pascal_context_$def_word_count + 3;
						/* link */
	pascal_context_$links_ptr -> exp_ptr = rel (def_ptr);
	pascal_context_$links_ptr -> ft2 = "100110"b;	/* tag 46 */
						/* end; */

/* -link */

	pascal_context_$stat_half_word_count = 16;	/* header  */

/* - relocation bits */

	call pascal_gen_rel_$def (def_rel, 1);
	call pascal_gen_rel_$def (abs, (word_count * 2) - 1);
	call pascal_gen_rel_$def (def_rel, 3);
	call pascal_gen_rel_$def (abs, 1);
	call pascal_gen_rel_$def (def_rel, 2);
	call pascal_gen_rel_$def (abs, 8);
	call pascal_gen_rel_$def (def_rel, 2);
	call pascal_gen_rel_$def (symb_rel, 1);
	call pascal_gen_rel_$def (abs, 1);
	call pascal_gen_rel_$def (def_rel, 2);
						/* if pascal_context_$options.table = "1"b then do; */
	call pascal_gen_rel_$def (abs, 2);
	call pascal_gen_rel_$def (def_rel, 3);
	call pascal_gen_rel_$def (abs, 1);
						/* end; */
	call pascal_gen_rel_$link (abs, 2);
	call pascal_gen_rel_$link (text_rel, 1);
	call pascal_gen_rel_$link (abs, 13);

/* initialise ps segment generation */

	if pascal_context_$options.ps = "1"b then do;

/* -definition */

		def_ptr = pascal_context_$ps_def_ptr;
		def_header.flags.new_format = "1"b;
		def_header.flags.ignore = "1"b;

		seg_name.num_chars = length (ps_var_string);
		seg_name.string = ps_var_string;
		word_count = 3 + ((seg_name.num_chars + 4) / 4);
		def_list_relp = addr (word_count) -> val.low;
		pascal_context_$ps_segname_def_ptr = ptr (pascal_context_$ps_def_ptr, word_count);
		def_seg.forward, def_seg.segname = rel (addrel (pascal_context_$ps_segname_def_ptr, 7));
		def_seg.backward = "000000000000000010"b; /* 2 : all zero word */
		def_seg.value = "000000000000000010"b;	/* 2 */
		def_seg.flags.new = "1"b;
		def_seg.class = "011"b;		/* 3 */
		def_seg.symbol = "000000000000000011"b; /* 3 : string */

		def_ptr = ptr (def_ptr, word_count + 3);
		symb_name.num_chars = 12;
		symb_name.string = "symbol_table";
		pascal_context_$ps_last_def_ptr = ptr (pascal_context_$ps_def_ptr, word_count + 7);

		def_symb.backward, def_symb.segname = rel (pascal_context_$ps_segname_def_ptr);
		def_symb.forward = "000000000000000010"b; /* 2 : all zero word */
		def_symb.flags.new = "1"b;
		def_symb.class = "010"b;		/* 2 */
		def_symb.symbol = rel (def_ptr);
		pascal_context_$ps_def_word_count = word_count + 10;

/* -link */

		pascal_context_$ps_stat_half_word_count = 16; /* header */
		pascal_context_$ps_link_ptr -> header.stats.begin_links,
		     pascal_context_$ps_link_ptr -> header.stats.block_length = "000000000000001000"b; /* 8 */ ;

/* - relocation bits */

		if pascal_context_$options.bind = "1"b then do;
			call pascal_gen_rel_$ps_def (def_rel, 1);
			call pascal_gen_rel_$ps_def (abs, (word_count * 2) - 1);
			call pascal_gen_rel_$ps_def (def_rel, 3);
			call pascal_gen_rel_$ps_def (abs, 1);
			call pascal_gen_rel_$ps_def (def_rel, 2);
			call pascal_gen_rel_$ps_def (abs, 8);
			call pascal_gen_rel_$ps_def (def_rel, 2);
			call pascal_gen_rel_$ps_def (symb_rel, 1);
			call pascal_gen_rel_$ps_def (abs, 1);
			call pascal_gen_rel_$ps_def (def_rel, 2);
		     end;

	     end;

/* call now the compiler */

	PARM = parm_string;
	call date_time_ (pascal_context_$time, pascal_context_$time_string);

	pascal_context_$abort_comp_label = comp_aborted;
	pascal_context_$int_error_label = force_return_internal;
	pascal_error_label = force_return_pascal;
	on pascal_error go to pascal_error_label;


	call ioa_ (pascal_compiler_id$version);

	call racine (PARM, COND);


/* check the return code and edit the errors */

	if COND ^= 0 then do;
		call ioa_$ioa_switch (iox_$error_output,
		     "pascal: ^d error^[s^] detected in ^a", COND, COND > 1,
		     pascal_context_$source_entry_name);
	     end;

end_of_comp:

	if COND ^= 0 then pascal_severity_ = 3;

/* finish the list_segment if requested */

	if pascal_context_$options.list = "1"b then do;
		call hcs_$status_long (pascal_context_$working_dir_name, list_entry_name, 0,
		     addr (list_status_branch), null, code);
		if code ^= 0 then do;
			call com_err_ (code, "pascal", "Error getting status of ^a", absolute_list_path);
			pascal_severity_ = 5;
			go to comp_aborted;
		     end;
		if (list_status_branch.type = 2) & (list_status_branch.bit_count ^= 0) then do; /* MSF */
			last_component_nbr = list_status_branch.bit_count - 1;
		     end;
		else do;
			last_component_nbr = 0;
		     end;
		call adjust_bit_count_ (pascal_context_$working_dir_name, list_entry_name, "1"b, bit_count, code);
		if code ^= 0 then do;
			call com_err_ (code, "pascal", "Error adjusting bit count of listing segment ^a",
			     absolute_list_path);
			pascal_severity_ = 5;
			go to comp_aborted;
		     end;
		bc = bit_count - (last_component_nbr * 36 * (2 ** 18 - 1024));
		call tssi_$finish_file (list_fcb_ptr, last_component_nbr, bc, "101"b, list_aclinfo_ptr, code);

/*
   if code ^= 0 then do ;
   call com_err_ (code, "pascal", "Error closing ^a", absolute_list_path) ;
   pascal_severity_ = 5;
   go to comp_aborted ;
   end ;
*/
		list_ok = 1;
	     end;
	if COND ^= 0 then go to comp_aborted;




	call iox_$detach_iocb (in_ptr, code);
	call iox_$detach_iocb (pascal_context_$out_ptr, code);
	call iox_$detach_iocb (err_ptr, code);
	call release_temp_segments_ ("pascal_compiler", pascal_context_$segs, code);
	if pascal_context_$options.generated_code then
	     call release_temp_segment_ ("pascal_compiler", pascal_context_$usednamesaddr, code);
	if pascal_context_$options.ps = "1"b then
	     call release_temp_segments_ ("pascal_compiler", pascal_context_$ps_segs, code);
	call pascal_sources_management_$clean;
	call pascal_reset_area (absolute_compiler_path);
	pascal_is_busy = 0;
	return;
%page;
force_return_pascal:				/* return here on pascal_error condition
						   (error in compiler Pascal modules) */

	pascal_context_$err_info.string = pascal_operators_statics_$error_info.string;
	pascal_context_$err_info.status_code = pascal_operators_statics_$error_info.status_code;

force_return_internal:				/* return here on internal error in compiler PL1 modules */

	pascal_severity_ = 4;

	error_message = pascal_context_$err_info.string;
	call convert_status_code_ (pascal_context_$err_info.status_code, short_info, status_message);

	if pascal_context_$options.list = "1"b then do;
		call hcs_$status_long (pascal_context_$working_dir_name, list_entry_name, 0,
		     addr (list_status_branch), null, code);
		if code ^= 0 then do;
			go to no_err_list;
		     end;
		if (list_status_branch.type = 2) & (list_status_branch.bit_count ^= 0) then do; /* MSF */
			last_component_nbr = list_status_branch.bit_count - 1;
		     end;
		else do;
			last_component_nbr = 0;
		     end;
		call msf_manager_$get_ptr (list_fcb_ptr, last_component_nbr, "0"b, last_component_ptr, bc, code);
		if code ^= 0 then do;
			go to no_err_list;
		     end;
		call tssi_$finish_file (list_ptr, last_component_nbr, bc, "101"b, list_aclinfo_ptr, code);
		if code ^= 0 then do;
			go to no_err_list;
		     end;
		call adjust_bit_count_ (pascal_context_$working_dir_name, list_entry_name, "1"b, bit_count, code);
		if code ^= 0 then do;
			go to no_err_list;
		     end;
		list_ok = 1;
	     end;

no_err_list:

	call ioa_$ioa_switch (iox_$error_output, rtrim (error_message) || "
" || rtrim (status_message));
	fsb_ptr = RACINE_defs$mpcogin;
	call ioa_$ioa_switch (iox_$error_output, "pascal:
 Compilation stopped while processing source line ^d:
", record_counter);
	call iox_$open (system_ptr, 1, "0"b, code);
	if code = 0 then do;
		call iox_$position (system_ptr, 0, record_counter - 1, code);
		if (code = 0) | (code = error_table_$end_of_info) then do;
			call iox_$get_line (system_ptr, addr (command_line), 256, n_read, code);
			if (code = 0) | (code = error_table_$short_record) | (code = error_table_$long_record) then do;
				call ioa_$ioa_switch (iox_$error_output,
				     rtrim (substr (command_line, 1, n_read)));
			     end;
			else call ioa_$ioa_switch (iox_$error_output, "(cannot get source line)
");
		     end;
		else call ioa_$ioa_switch (iox_$error_output, "(cannot get source line)
");
	     end;
	else call ioa_$ioa_switch (iox_$error_output, "(cannot get source line)
");
	call ioa_$ioa_switch (iox_$error_output, "pascal: An error occurred during compilation of source segment ^a.
Please correct all the errors detected and recompile. " || "If the error persists,
contact Pascal maintenance personnel.", pascal_context_$source_entry_name);

	COND = 1;
	go to end_of_comp;

standard_error:

	pascal_severity_ = 5;
	call com_err_ (code, "pascal");

comp_aborted:

	call ioa_$ioa_switch (iox_$error_output,
	     "pascal: ^[No object created. ^]^[No list created. ^]^[No private_storage segment created.^]",
	     pascal_context_$object_ok = 0, (pascal_context_$options.list = "1"b) & (list_ok = 0),
	     (pascal_context_$options.ps = "1"b) & (pascal_context_$ps_ok = 0));

comp_aborted_:

	call cleanup_compiler;

	return;

standard_error_:

	pascal_severity_ = 5;
	call com_err_ (code, "pascal");
	go to comp_aborted_;
%page;
listhead: entry;

/* Generation of the listing header */

	call ioa_$ioa_switch (pascal_context_$out_ptr, "
	COMPILATION LISTING OF SEGMENT:
		^a", absolute_source_path);
	call ioa_$ioa_switch (pascal_context_$out_ptr, "
	Compiled by: ^a
	Compiled at: ^a", pascal_compiler_id$gen_id, installation_id);
	call ioa_$ioa_switch (pascal_context_$out_ptr, "	Compiled on: ^a
	    options: ^a

", pascal_context_$time_string, pascal_context_$option_list);

	return;
%page;
verify_io: proc (iocb_ptr);

	dcl     iocb_ptr		 ptr;

	atd_ptr = iocb_ptr -> attach_descrip_ptr;

	if atd_ptr ^= null then do;
		if iocb_ptr -> open_descrip_ptr ^= null then do;
control_syn:
			if substr (atd_ptr -> attach_description.string, 1, 5) ^= "syn_ " then go to close_now;
			if atd_ptr -> attach_description.string ^= "syn_ user_input"
			     & atd_ptr -> attach_description.string ^= "syn_ user_output"
			     & atd_ptr -> attach_description.string ^= "syn_ error_output"
			     & atd_ptr -> attach_description.string ^= "syn_ user_i/o" then do;
				call iox_$find_iocb (substr (atd_ptr -> attach_description.string,
				     6, atd_ptr -> attach_description.length - 5), iocb_ptr, code);
				if code ^= 0 then go to standard_error;
				atd_ptr = iocb_ptr -> attach_descrip_ptr;
				if atd_ptr = null then do;
					code = pascal_error_table_$bad_syn_chain;
					go to standard_error;
				     end;
				go to control_syn;
			     end;
			go to no_to_close;
close_now:
			call com_err_ (0, "pascal", "Warning: Pascal closes current file ^a",
			     iocb_ptr -> iocb.name);
			call iox_$close (iocb_ptr, code);
			if code ^= 0 then go to standard_error;
no_to_close:
		     end;
		call com_err_ (0, "pascal", "Warning: Pascal detaches I/O switch ^a",
		     iocb_ptr -> iocb.name);
		call iox_$detach_iocb (iocb_ptr, code);
		if code ^= 0 then go to standard_error;
	     end;

	return;

     end;
%page;
set_for_cleanup: proc;

	pascal_context_$out_ptr, err_ptr, pascal_context_$segs, my_firstcond, pascal_context_$usednamesaddr,
	     list_aclinfo_ptr, object_aclinfo_ptr, ps_aclinfo_ptr, pascal_context_$ps_segs = null;
	pascal_is_busy = 1;

     end set_for_cleanup;


cleanup_compiler: proc;

	dcl     iocb_ptr		 ptr;

	if pascal_context_$out_ptr ^= null then do;
		call iox_$close (pascal_context_$out_ptr, code);
		call iox_$detach_iocb (pascal_context_$out_ptr, code);
	     end;
	call iox_$look_iocb ("mpcogin", iocb_ptr, code);
	if iocb_ptr ^= null then do;
		call iox_$close (iocb_ptr, code);
		call iox_$detach_iocb (iocb_ptr, code);
		call iox_$destroy_iocb (iocb_ptr, code);
	     end;
	if err_ptr ^= null then do;
		call iox_$detach_iocb (err_ptr, code);
	     end;

	call release_temp_segments_ ("pascal_compiler", pascal_context_$segs, code);
	if code ^= 0 then do;
		call com_err_ (code, "pascal", "Error releasing compiler temp work segments.");
	     end;

	if pascal_context_$options.ps = "1"b then do;
		call release_temp_segments_ ("pascal_compiler", pascal_context_$ps_segs, code);
		if code ^= 0 then do;
			call com_err_ (code, "pascal", "Error releasing compiler temp work segments.");
		     end;
	     end;

	if pascal_context_$options.generated_code then do;
		call release_temp_segment_ ("pascal_compiler", pascal_context_$usednamesaddr, code);
		if code ^= 0 then
		     call com_err_ (code, "pascal", "Error releasing compiler temp work segment.");
	     end;

	if list_aclinfo_ptr ^= null then call tssi_$clean_up_file (list_fcb_ptr, list_aclinfo_ptr);
	if object_aclinfo_ptr ^= null then call tssi_$clean_up_segment (object_aclinfo_ptr);
	if ps_aclinfo_ptr ^= null then call tssi_$clean_up_segment (ps_aclinfo_ptr);

	call pascal_sources_management_$clean;

	call pascal_reset_area (absolute_compiler_path);

	do while (my_firstcond ^= null);
	     box_ptr = my_firstcond;
	     my_firstcond = nextcond;
	     free condbox;
	end;

	pascal_is_busy = 0;


     end cleanup_compiler;
%page;
%include pascal_ops_statics;
%page;
%include pascal_fsb;
%page;
%include pascal_context_;
%page;
%include query_info;
%page;
%include status_structures;
%page;
%include send_mail_info;
%page;
%include pl1_symbol_block;
%page;
%include object_map;
%page;
%include definition;
%page;
%include source_map;
%page;
%include std_symbol_header;
%page;
%include iocb;
%page;
%include object_info;
%page;
%include linkdcl;


     end pascal;
