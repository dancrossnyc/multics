/****^  *************************************************************************
        *                                                                       *
        * Copyright (c) 1980 by Centre Interuniversitaire de Calcul de Grenoble *
        * and Institut National de Recherche en Informatique et Automatique     *
        *                                                                       *
        ************************************************************************* */


/****^  HISTORY COMMENTS:
  1) change(86-10-05,JMAthane), approve(86-10-05,MCR7521),
     audit(86-10-09,JPFauche), install(86-11-12,MR12.0-1212):
     Pascal version for MR12
                                                   END HISTORY COMMENTS */

/* format: style4,^linecom,^ifthendo,^indproc,^indblkcom,initcol1,declareind8,dclind4,struclvlind1 */

pascal_create_tables: proc (current, return_code);

dcl current ptr;					/* current generation ptr */
dcl return_code fixed bin;

/* Created JMAthane March 83 */

/* Creates PASCAL symbol tables */


/* automatics */

dcl 1 names (0:32),
     2 first bit (18),
     2 last bit (18);

dcl 1 ext_entries (0:32),
     2 first bit (18),
     2 last bit (18);

dcl progname char (32) varying;
dcl name_place ptr;
dcl block_ptr ptr;
dcl symbol_ptr ptr;
dcl (last, next) ptr;
dcl first_node ptr;
dcl (refplace, symboffset) fixed bin (35);
dcl (p1, p2) ptr;
dcl work ptr;
dcl i fixed bin;
dcl value fixed bin (35);
dcl current_text ptr;
dcl old_text_length fixed bin (35);
dcl ref_box_ptr ptr;
dcl ref_i fixed bin;

/* ext procedures */

dcl com_err_ entry options (variable);
dcl ioa_$ioa_switch entry options (variable);

/* other PASCAL compiler entries */

dcl RACINE_defs$selectivetable fixed bin (35) ext;
dcl RACINE_defs$intptr ext ptr;			/* ptr to standard integer type box */
dcl RACINE_defs$string_ptr ext ptr;			/* ptr to standard string schema box */
dcl RACINE_defs$boolptr ext ptr;			/* ptr to standard boolean type box */
dcl RACINE_defs$realptr ext ptr;			/* ptr to standard real type box */
dcl RACINE_defs$charptr ext ptr;			/* ptr to standard char type box */
dcl RACINE_defs$programnode ptr ext;
dcl RACINE_defs$progname char (32) ext;
dcl RACINE_defs$textfilectp ptr ext;
dcl GENERE_defs$mainloc fixed bin (35) ext;
dcl pascal_gen_rel_$symb entry (bit (5), fixed bin);
dcl pascal_gen_rel_$text entry (bit (5), fixed bin);
dcl pascal_sources_management_$return_source_ptr entry (fixed bin (35), ptr);
dcl MODATTR$is_pl1_varying_char entry (ptr) returns (fixed bin (35));

/* based */

dcl 1 acc based,
     2 size fixed bin (8) unal,
     2 string char (0 refer (acc.size)) unal;

dcl 1 val based,
     2 high bit (18) unal,
     2 low bit (18) unal;


dcl 1 val14 based,
     2 high bit (22) unal,
     2 low bit (14) unal;

dcl 1 my_symbol_token based,
     2 next fixed bin (18) unsigned unal,
     2 dcl fixed bin (18) unsigned unal,
     2 name,
      3 size fixed bin (9) unsigned unal,
      3 string char (0 refer (my_symbol_token.name.size)) unal;

dcl 1 symbol_structure based,
     2 nargs bit (18) unal,
     2 unused bit (18) unal,
     2 link_to_symbol fixed bin (18) unsigned unal,
     2 block_relp bit (18) unal;

dcl 1 procedure_symbol_block based,
     2 h like pascal_symbol_node_header unal,
     2 nn like pascal_name_next unal,
     2 ad like pascal_address unal,
     2 fb like pascal_father_brother unal;


dcl 1 new_runtime_symbol based,
     2 h like pascal_symbol_node_header unal,
     2 nn like pascal_name_next unal;

dcl 1 label_node based,
     2 h like pascal_symbol_node_header unal,
     2 nn like pascal_name_next unal,
     2 ad like pascal_address unal,
     2 fb like pascal_father_brother unal;

dcl 1 with_field_node based,
     2 h like pascal_symbol_node_header unal,
     2 nn like pascal_name_next unal,
     2 ad like pascal_address unal,
     2 fb like pascal_father_brother unal,

     2 pascal_size fixed bin (35),
     2 pascal_offset fixed bin (35);

dcl first_value_block ptr int static;

dcl 1 value_block based,
     2 loc (0:49) ptr,
     2 next ptr;

dcl fb35b fixed bin (35) unal based;
dcl fb17b fixed bin (17) unal based;

dcl usednames (1024 * 255) ptr unal based (pascal_context_$usednamesaddr);

/* constants */

dcl entry_sequence_size init (2) fixed bin (25) int static options (constant);
dcl procedure_symbol_block_size fixed bin int static options (constant) init (5);
						/* conditions */

dcl cleanup condition;


/* builtins */

dcl (null, ptr, size, addrel, rel) builtin;

/* constants */
%page;

	return_code = 0;

	if (pascal_context_$symb_ptr ^= ptr (current, 0)) then do;
	     call com_err_ (0, "pascal", "Internal error. Cannot generate symbol tables.");
	     return;
	end;

	current_text = addrel (pascal_context_$text_ptr, pascal_context_$text_word_count);
	old_text_length = pascal_context_$text_word_count;

	names = "0"b;
	first_node = current;
	progname = rtrim (RACINE_defs$progname);
	ext_entries = "0"b;

	first_value_block = null;
	on cleanup begin;
	     end;
	work = first_value_block;
	do while (work ^= null);
	     p1 = work -> value_block.next;
	     free work -> value_block;
	     work = p1;
	end;

/* create root block */

	block_ptr = current;

	block_ptr -> symbol_block.flag,
	     block_ptr -> symbol_block.standard = "1"b;
	block_ptr -> symbol_block.type = EXTERNAL_ENTRY;
	if pascal_context_$options.table then do;
	     block_ptr -> symbol_block.map.first = 0;
	     block_ptr -> symbol_block.map.last = RACINE_defs$programnode -> blocknodeheader.codeend;
	end;
	value = -fixed (rel (block_ptr));
	block_ptr -> symbol_block.header,
	     block_ptr -> symbol_block.father = value;

	current = addrel (current, size (symbol_block) - 1);
	if pascal_context_$options.bind = "1"b then
	     call pascal_gen_rel_$symb (abs, 20);

/* symbol block for main entry */

	if pascal_context_$options.ref_table then do;
	     current = addrel (current, size (ref_info_header));
	     if pascal_context_$options.bind then
		call pascal_gen_rel_$symb (abs, size (ref_info_header) * 2);
	end;

	symbol_ptr = current;

	current = addrel (current, procedure_symbol_block_size);
	if pascal_context_$options.bind then do;
	     call pascal_gen_rel_$symb (abs, 6);
	     call pascal_gen_rel_$symb (text_rel, 1);
	     call pascal_gen_rel_$symb (abs, 3);
	end;
	symbol_ptr -> procedure_symbol_block.flags.name_next,
	     symbol_ptr -> procedure_symbol_block.flags.address,
	     symbol_ptr -> procedure_symbol_block.flags.father_brother = "1"b;
	symbol_ptr -> procedure_symbol_block.h.type = ext_entry_runtime_dtype;
	symbol_ptr -> procedure_symbol_block.ad.location = GENERE_defs$mainloc;
	symbol_ptr -> procedure_symbol_block.ad.class = 12;
	symbol_ptr -> procedure_symbol_block.fb.father =
	     fixed (rel (block_ptr)) - fixed (rel (symbol_ptr));

/* name token for main entry point */

	call allocate_name (progname, name_place);
	symbol_ptr -> procedure_symbol_block.nn.name =
	     fixed (rel (name_place)) - fixed (rel (symbol_ptr)) + 1;
	name_place -> my_symbol_token.dcl = fixed (rel (symbol_ptr)) - fixed (rel (name_place));
	ext_entries (length (progname)).first,
	     ext_entries (length (progname)).last = rel (symbol_ptr);

/* create tables for different levels */

	block_ptr -> symbol_block.son =
	     fixed (rel (current)) - fixed (rel (block_ptr));
	call create_level_tables (RACINE_defs$programnode, rel (first_node));

/* sort ext_entries of root */

	i = 32;
	do while ((ext_entries (i).first = "0"b) & (i >= 0));
	     i = i - 1;
	end;
	do while (i > 0);
	     if ext_entries (i - 1).first = "0"b then do;
		ext_entries (i - 1).first = ext_entries (i).first;
		ext_entries (i - 1).last = ext_entries (i).last;
	     end;
	     else do;
		last = ptr (current, ext_entries (i - 1).last);
		next = ptr (current, ext_entries (i).first);
		get_fbr (last) -> pascal_father_brother.brother =
		     fixed (rel (next)) - fixed (rel (last));
	     end;
	     i = i - 1;
	end;
	first_node -> symbol_block.start =
	     fixed (ext_entries (0).first) - fixed (rel (first_node));

/* chain table in symbol_block */

	if ext_entries (2).first ^= "0"b then do;
	     first_node -> symbol_block.chain (1) =
		fixed (ext_entries (2).first) - fixed (rel (first_node));
	     if ext_entries (4).first ^= "0"b then do;
		first_node -> symbol_block.chain (2) =
		     fixed (ext_entries (4).first) - fixed (rel (first_node));
		if ext_entries (8).first ^= "0"b then do;
		     first_node -> symbol_block.chain (3) =
			fixed (ext_entries (8).first) - fixed (rel (first_node));
		     if ext_entries (16).first ^= "0"b then do;
			first_node -> symbol_block.chain (4) =
			     fixed (ext_entries (16).first) - fixed (rel (first_node));
		     end;
		end;
	     end;
	end;

/* names general thread and token tables in blocks */
	i = 32;
	do while ((names (i).first = "0"b) & (i >= 0));
	     i = i - 1;
	end;
	if i >= 0 then do;
	     do while (i > 0);
		if names (i - 1).first = "0"b then
		     names (i - 1).first = names (i).first;
		else do;
		     last = ptr (current, names (i - 1).last);
		     next = ptr (current, names (i).first);
		     value = fixed (rel (next)) - fixed (rel (last));
		     last -> symbol_token.next = value;
		end;
		i = i - 1;
	     end;
	     work = first_node;
	     call get_token_table;
	end;

end_of_pascal_create_tables:

	work = first_value_block;
	do while (work ^= null);
	     p1 = work -> value_block.next;
	     free work -> value_block;
	     work = p1;
	end;

	if pascal_context_$options.generated_code then
	     do while (pascal_context_$text_word_count ^= old_text_length);
	     old_text_length = old_text_length + 1;
	     usednames (old_text_length) = addr (pascal_context_$octalformatstring);
	end;

	return;

%page;

get_fbr: proc (bp) returns (ptr);

dcl bp ptr;

dcl i fixed bin;

dcl size builtin;

	if ^bp -> pascal_symbol_node_header.father_brother then return (null);
	i = size (pascal_symbol_node_header);
	if bp -> pascal_symbol_node_header.flags.name_next then i = i + size (pascal_name_next);
	if bp -> pascal_symbol_node_header.flags.base_type_info then i = i + size (pascal_base_type_info);
	if bp -> pascal_symbol_node_header.flags.address then i = i + size (pascal_address);
	return (addrel (bp, i));

     end get_fbr;

get_fts: proc (bp) returns (ptr);

dcl bp ptr;

dcl i fixed bin;

dcl size builtin;

	if ^bp -> pascal_symbol_node_header.father_type_successor then return (null);
	i = size (pascal_symbol_node_header);
	if bp -> pascal_symbol_node_header.flags.name_next then i = i + size (pascal_name_next);
	if bp -> pascal_symbol_node_header.flags.base_type_info then i = i + size (pascal_base_type_info);
	if bp -> pascal_symbol_node_header.flags.address then i = i + size (pascal_address);
	if bp -> pascal_symbol_node_header.flags.father_brother then i = i + size (pascal_father_brother);
	if bp -> pascal_symbol_node_header.flags.son_level then i = i + size (pascal_son_level);
	return (addrel (bp, i));

     end get_fts;

get_siz: proc (bp) returns (ptr);

dcl bp ptr;

dcl i fixed bin;

dcl size builtin;

	if ^bp -> pascal_symbol_node_header.flags.size then return (null);
	i = size (pascal_symbol_node_header);
	if bp -> pascal_symbol_node_header.flags.name_next then i = i + size (pascal_name_next);
	if bp -> pascal_symbol_node_header.flags.base_type_info then i = i + size (pascal_base_type_info);
	if bp -> pascal_symbol_node_header.flags.address then i = i + size (pascal_address);
	if bp -> pascal_symbol_node_header.flags.father_brother then i = i + size (pascal_father_brother);
	if bp -> pascal_symbol_node_header.flags.son_level then i = i + size (pascal_son_level);
	if bp -> pascal_symbol_node_header.flags.father_type_successor then i = i + size (pascal_father_type_successor);
	return (addrel (bp, i));

     end get_siz;

get_slv: proc (bp) returns (ptr);

dcl bp ptr;

dcl i fixed bin;

dcl size builtin;

	if ^bp -> pascal_symbol_node_header.son_level then return (null);
	i = size (pascal_symbol_node_header);
	if bp -> pascal_symbol_node_header.flags.name_next then i = i + size (pascal_name_next);
	if bp -> pascal_symbol_node_header.flags.base_type_info then i = i + size (pascal_base_type_info);
	if bp -> pascal_symbol_node_header.flags.address then i = i + size (pascal_address);
	if bp -> pascal_symbol_node_header.flags.father_brother then i = i + size (pascal_father_brother);
	return (addrel (bp, i));

     end get_slv;


%page;

internal_error: proc (message);

dcl message char (*);

	call com_err_ (0, "pascal", message);
	call ioa_$ioa_switch (pascal_context_$out_ptr, "

********  SYMBOL TABLES GENERATION INTERNAL ERROR :
	" || message);
	return_code = 1;
	go to end_of_pascal_create_tables;

     end internal_error;

user_error: proc (message);

dcl message char (*);

	call com_err_ (0, "pascal", message);
	call ioa_$ioa_switch (pascal_context_$out_ptr, "

********  SYMBOL TABLES GENERATION ERROR :
	" || message);
	return_code = 2;
	go to end_of_pascal_create_tables;

     end user_error;
%page;

alloc_scalar_code: proc (value, value_place);

dcl value fixed bin (35);				/* (input) */
dcl value_place ptr;				/* (output) */

dcl (i, j, k) fixed bin;
dcl work ptr;

	i = value / 50;
	j = mod (value, 50);

	if first_value_block = null then do;
	     allocate value_block set (first_value_block);
	     first_value_block -> value_block.loc = null;
	     first_value_block -> value_block.next = null;
	end;

	work = first_value_block;
	do k = 1 to i;
	     if work -> value_block.next = null then do;
		allocate value_block set (work -> value_block.next);
		work = work -> value_block.next;
		work -> value_block.loc = null;
		work -> value_block.next = null;
	     end;
	     else work = work -> value_block.next;
	end;

	if work -> value_block.loc (j) = null then do;
	     work -> value_block.loc (j) = current;
	     current -> fb35b = value;
	     current = addrel (current, 1);
	     if pascal_context_$options.bind then
		call pascal_gen_rel_$symb (abs, 2);
	end;
	value_place = work -> value_block.loc (j);

     end alloc_scalar_code;

%page;

get_token_table: proc;

/* fills token table in runtime blocks */

	if names (1).first ^= "0"b then do;
	     work -> symbol_block.token (0) =
		fixed (names (1).first) - fixed (rel (work));
	     if names (2).first ^= "0"b then do;
		work -> symbol_block.token (1) =
		     fixed (names (2).first) - fixed (rel (work));
		if names (4).first ^= "0"b then do;
		     work -> symbol_block.token (2) =
			fixed (names (4).first) - fixed (rel (work));
		     if names (8).first ^= "0"b then do;
			work -> symbol_block.token (3) =
			     fixed (names (8).first) - fixed (rel (work));
			if names (16).first ^= "0"b then do;
			     work -> symbol_block.token (4) =
				fixed (names (16).first) - fixed (rel (work));
			     if names (32).first ^= "0"b then do;
				work -> symbol_block.token (5) =
				     fixed (names (32).first) - fixed (rel (work));
			     end;
			end;
		     end;
		end;
	     end;
	end;

	if work -> symbol_block.son ^= 0 then do;
	     work = addrel (work, work -> symbol_block.son);
	     call get_token_table;
	     work = addrel (work, work -> symbol_block.father);
	end;

	if work -> symbol_block.brother ^= 0 then do;
	     work = addrel (work, work -> symbol_block.brother);
	     call get_token_table;
	end;

     end get_token_table;

%page;

allocate_name: proc (name, place);

dcl name char (32) varying;
dcl place ptr;

/* generates my_symbol_token for "name" and returns his "place" */

dcl previous_name ptr;
dcl name_ptr ptr;
dcl token_length fixed bin;

	token_length = 2 + (length (name) / 4);
	if names (length (name)).first = "0"b then do;	/* first in the list */
	     current -> my_symbol_token.next,
		current -> my_symbol_token.dcl = 0;
	     current -> my_symbol_token.name.size = length (name);
	     current -> my_symbol_token.name.string = name;
	     place = current;
	     if pascal_context_$options.bind = "1"b then
		call pascal_gen_rel_$symb (abs, token_length * 2);
	     current = addrel (current, token_length);
	     names (length (name)).first,
		names (length (name)).last = rel (place);
	end;
	else do;
	     name_ptr = addrel (pascal_context_$symb_ptr, names (length (name)).first);
	     previous_name = null;
search:
	     if name_ptr -> my_symbol_token.name.string < name then do;
		if name_ptr -> my_symbol_token.next = 0 then do; /* insert after */
		     value = fixed (rel (current)) - fixed (rel (name_ptr));
		     name_ptr -> my_symbol_token.next = value;
		     current -> my_symbol_token.next = 0;
		     current -> my_symbol_token.dcl = 0;
		     current -> my_symbol_token.name.size = length (name);
		     current -> my_symbol_token.name.string = name;
		     place = current;
		     if pascal_context_$options.bind = "1"b then
			call pascal_gen_rel_$symb (abs, token_length * 2);
		     current = addrel (current, token_length);
		     names (length (name)).last = rel (place);
		end;
		else do;
		     previous_name = name_ptr;
		     name_ptr = addrel (name_ptr, name_ptr -> my_symbol_token.next);
		     go to search;
		end;
	     end;
	     else if name_ptr -> my_symbol_token.name.string = name then /* allready exists */
		place = name_ptr;
	     else do;				/* insert before */
		if previous_name = null then
		     names (length (name)).first = rel (current);
		else do;
		     value = fixed (rel (current)) - fixed (rel (previous_name));
		     previous_name -> my_symbol_token.next = value;
		end;
		value = fixed (rel (name_ptr)) - fixed (rel (current));
		current -> my_symbol_token.next = value;
		current -> my_symbol_token.dcl = 0;
		current -> my_symbol_token.name.size = length (name);
		current -> my_symbol_token.name.string = name;
		place = current;
		if pascal_context_$options.bind = "1"b then
		     call pascal_gen_rel_$symb (abs, token_length * 2);
		current = addrel (current, token_length);
	     end;
	end;

     end allocate_name;

%page;

create_level_tables: proc (node_ptr, father_block);

dcl node_ptr ptr;					/* ptr to pascal level node */
dcl father_block bit (18);				/* offset in symb sect of father symbol_block - "0"b if none */

/* automatics */

dcl 1 symbols (0:32),
     2 first bit (18),
     2 last bit (18);

dcl name_place ptr;
dcl block_ptr ptr;					/* ptr to symbol_block for this level */
dcl symbol_ptr ptr;					/* ptr to current symbol block */
dcl previous_symbol ptr;
dcl symbol_name char (32) varying;			/* name of current symbol */
dcl name char (32);
dcl (table_ptr, last, next) ptr;
dcl struct_ptr ptr;
dcl (p1, p2, p3, p4) ptr;
dcl source_string char (4 * 255 * 1024) based;
dcl (len, j, withclass) fixed bin (35);
dcl withrel bit (5);
dcl loc_rel bit (5) init ("0"b);
dcl type_code fixed bin (35);
dcl (entry_seq_ptr, parm_list_ptr) ptr;
dcl type_addr ptr;
dcl parm_size fixed bin (35);
dcl type_table ptr;
dcl it fixed bin;
dcl arg_is_packed bit (1);
dcl arg_dims fixed bin;
dcl arg_type_ptr ptr;
dcl original_record ptr;

/* fill symbol entry structure */

	if node_ptr -> blocknodeheader.blocktp = procblock then
	     if node_ptr -> procnode.structureplace ^= 0 then do;
		struct_ptr = addrel (pascal_context_$text_ptr, node_ptr -> procnode.structureplace);
		struct_ptr -> symbol_structure.link_to_symbol = 0;
		struct_ptr -> symbol_structure.block_relp = rel (current);
	     end;

/* skip withblock if no complete table wanted */

	if ^pascal_context_$options.table then
	     if node_ptr -> blocknodeheader.blocktp = withblock then return;

/* create node box */

	block_ptr = current;

	block_ptr -> symbol_block.flag,
	     block_ptr -> symbol_block.standard = "1"b;
	if node_ptr -> blocknodeheader.blocktp = procblock then
	     do;
	     p1 = node_ptr -> procnode.blockbox;
	     if p1 = null then
		block_ptr -> symbol_block.type = EXTERNAL_ENTRY; /* main */
	     else
		if p1 -> proc_d.prockind = actual then
		block_ptr -> symbol_block.type = NON_QUICK_INTERNAL_PROCEDURE;
	     else block_ptr -> symbol_block.type = EXTERNAL_ENTRY;
	     len = size (symbol_block) - 1;
	     current = addrel (current, len);
	     if pascal_context_$options.bind = "1"b then
		call pascal_gen_rel_$symb (abs, len * 2);

	end;
	else do;
	     block_ptr -> symbol_block.type = PASCAL_WITH_BLOCK;
	     current = addrel (current, size (with_symbol_block));
	     if pascal_context_$options.bind then
		call pascal_gen_rel_$symb (abs, size (with_symbol_block) * 2);
	     call get_symbol_block (node_ptr -> withnode.recordptr, original_record);
	     block_ptr -> with_symbol_block.real_level_1 = fixed (rel (original_record)) - fixed (rel (block_ptr));
	     block_ptr -> with_symbol_block.with_string = fixed (rel (current)) - fixed (rel (block_ptr));
	     call pascal_sources_management_$return_source_ptr (node_ptr -> withnode.wstrfile, p2);
	     j = node_ptr -> withnode.wstrindex + 1;
	     len, current -> acc.size = node_ptr -> withnode.wstrlength;
	     current -> acc.string = substr (p2 -> source_string, j, len);
	     call normalize_source_acc (current);
	     len = (current -> acc.size + 4) / 4;
	     current = addrel (current, len);
	     if pascal_context_$options.bind then
		call pascal_gen_rel_$symb (abs, len * 2);
	     block_ptr -> symbol_block.owner_flag = "1"b;
	     p3 = ptr (block_ptr, father_block);
	     do while (p3 -> symbol_block.type = PASCAL_WITH_BLOCK);
		p3 = addrel (p3, p3 -> symbol_block.father);
	     end;
	     block_ptr -> symbol_block.owner = fixed (rel (p3)) - fixed (rel (block_ptr));
	end;
	if pascal_context_$options.table then do;
	     block_ptr -> symbol_block.map.first = node_ptr -> procnode.codebegin;
	     block_ptr -> symbol_block.map.last = node_ptr -> procnode.codeend;
	end;
	block_ptr -> symbol_block.header = -fixed (rel (block_ptr));
	block_ptr -> symbol_block.father =
	     fixed (father_block) - fixed (rel (block_ptr));

/* create runtime token for block name */

	if node_ptr -> blocknodeheader.blocktp = procblock then do;
	     if node_ptr -> procnode.blockbox = null then do; /* main */
		call allocate_name (progname, name_place);
	     end;
	     else do;
		call allocate_name (rtrim (node_ptr -> procnode.blockbox -> cth.name), name_place);
	     end;

	     block_ptr -> symbol_block.name = fixed (rel (name_place)) - fixed (rel (block_ptr)) + 1;
	end;

	symbols = "0"b;

/* create tables for symbols of this level */

	if node_ptr -> blocknodeheader.blocktp = withblock then do; /* WITH symbols */
	     if node_ptr -> withnode.windirect = true then do;
		withclass = 2;			/* stack indirect */
		withrel = abs;
	     end;
	     else do;
		if node_ptr -> withnode.wbase = locals then do;
		     withclass = 1;			/* stack */
		     withrel = abs;
		end;
		else do;
		     withclass = 4;			/* statics */
		     withrel = int18;
		end;
	     end;

	     p3 = node_ptr -> blocknodeheader.first;
	     do while (p3 ^= null);
		if p3 -> cth.klass = field then do;
		     symbol_name = rtrim (p3 -> cth.name);
		     if symbol_name ^= "" then do;
			call allocate_name (symbol_name, name_place);
			symbol_ptr = current;
			symbol_ptr -> with_field_node.name = fixed (rel (name_place)) - fixed (rel (symbol_ptr)) + 1;
			if name_place -> my_symbol_token.dcl ^= 0 then do;
			     work = addrel (name_place, name_place -> my_symbol_token.dcl);
			     symbol_ptr -> new_runtime_symbol.next_token =
				fixed (rel (work)) - fixed (rel (symbol_ptr));
			     name_place -> my_symbol_token.dcl =
				fixed (rel (symbol_ptr)) - fixed (rel (name_place));
			end;
			name_place -> my_symbol_token.dcl =
			     fixed (rel (symbol_ptr)) - fixed (rel (name_place));
			symbol_ptr -> pascal_symbol_node_header.flags.name_next,
			     symbol_ptr -> pascal_symbol_node_header.flags.address,
			     symbol_ptr -> pascal_symbol_node_header.flags.father_brother,
			     symbol_ptr -> pascal_symbol_node_header.flags.size,
			     symbol_ptr -> pascal_symbol_node_header.flags.in_with_block,
			     symbol_ptr -> pascal_symbol_node_header.flags.offset = "1"b;
			symbol_ptr -> pascal_symbol_node_header.flags.packed =
			     original_record -> pascal_symbol_node_header.packed;
			current = addrel (current, 7);
			if pascal_context_$options.bind then do;
			     call pascal_gen_rel_$symb (abs, 6);
			     call pascal_gen_rel_$symb (withrel, 1);
			     call pascal_gen_rel_$symb (abs, 7);
			end;
			symbol_ptr -> with_field_node.location = node_ptr -> withnode.wdisp;
			symbol_ptr -> with_field_node.class = withclass;
			symbol_ptr -> with_field_node.units = "10"b;
			call get_var_type_info (p3 -> field_d.fldtype, type_code, p4);
			symbol_ptr -> pascal_symbol_node_header.type = type_code;
			if p4 ^= null then
			     symbol_ptr -> pascal_symbol_node_header.type_offset = fixed (rel (p4)) - fixed (rel (symbol_ptr));
			symbol_ptr -> with_field_node.pascal_size = decode_size (p3 -> field_d.bytwidth, p3 -> field_d.fldtype);
			symbol_ptr -> with_field_node.pascal_offset = p3 -> field_d.fldaddr;
			call symbol_thread;
		     end;
		end;
		p3 = p3 -> cth.nxtel;
	     end;
	end /* WITH symbols */;

	else do;					/* PROC symbols */
	     table_ptr = node_ptr -> procnode.first;
						/* create tables for symbols of this block */
	     do while (table_ptr ^= null);
		symbol_name = rtrim (table_ptr -> cth.name);
		if (pascal_context_$options.table & symbol_name ^= "")
		     | ((RACINE_defs$selectivetable = 1) & (table_ptr -> cth.symbtablerefs ^= 0)) then

/* For now, ignore SimOne types MONITOR, MODUL, CONDITION */
		     if ^((table_ptr -> cth.klass = types) &
			((table_ptr -> tdh.form = monormod) | (table_ptr -> tdh.form = condition)))
		     then do;
			call get_symbol_block (table_ptr, symbol_ptr);
			if table_ptr -> cth.symbtablerefs ^= 0 then do;
			     refplace = table_ptr -> cth.symbtablerefs;
			     symboffset = fixed (rel (symbol_ptr)) - fixed (pascal_context_$symb_ptr -> area_pointer);
			     do while (refplace ^= 0);
				p2 = addrel (pascal_context_$text_ptr, refplace);
				refplace = p2 -> fb17b;
				p2 -> fb17b = symboffset;
			     end;
			     table_ptr -> cth.symbtablerefs = 0;
			end;
			call symbol_thread;
		     end;
		table_ptr = table_ptr -> cth.nxtel;
	     end;
						/* create parm descs and complete entry sequence */
						/* only if complete tables available */
	     if pascal_context_$options.table then do;
		p1 = node_ptr -> procnode.blockbox;
		num_descs = 0;
		if p1 ^= null then do;
		     if p1 -> proc_d.prockind ^= exportable then go to no_descs;
		     num_descs = p1 -> proc_d.nbparproc;
		end;
		if p1 = null then
		     entry_seq_ptr =
			addrel (pascal_context_$text_ptr, (GENERE_defs$mainloc - entry_sequence_size));
		else
		     entry_seq_ptr =
			addrel (pascal_context_$text_ptr, (p1 -> proc_d.locincode / 4) - entry_sequence_size);

/*
   entry_seq_ptr -> symbol_block_offset = fixed (rel (block_ptr)) - fixed (pascal_context_$symb_ptr -> area_pointer);
*/

		entry_seq_ptr -> descr_relp_offset = rel (current_text);

		call build_pascal_parm_descs (p1);

no_descs:
						/* create now tables for labels */
		p3 = node_ptr -> procnode.firstlabel;
		do while (p3 ^= null);
		     symbol_name = ltrim (character (p3 -> labelblock.number));
		     call allocate_name (symbol_name, name_place);
		     symbol_ptr = current;
		     symbol_ptr -> label_node.name = fixed (rel (name_place)) - fixed (rel (symbol_ptr)) + 1;
		     if name_place -> my_symbol_token.dcl ^= 0 then do;
			work = addrel (name_place, name_place -> my_symbol_token.dcl);
			symbol_ptr -> new_runtime_symbol.next_token =
			     fixed (rel (work)) - fixed (rel (symbol_ptr));
			name_place -> my_symbol_token.dcl =
			     fixed (rel (symbol_ptr)) - fixed (rel (name_place));
		     end;
		     name_place -> my_symbol_token.dcl =
			fixed (rel (symbol_ptr)) - fixed (rel (name_place));
		     symbol_ptr -> pascal_symbol_node_header.flags.name_next,
			symbol_ptr -> pascal_symbol_node_header.flags.address,
			symbol_ptr -> pascal_symbol_node_header.flags.father_brother = "1"b;
		     symbol_ptr -> pascal_symbol_node_header.type = pascal_label_dtype;
		     symbol_ptr -> label_node.location = p3 -> labelblock.locinbytes / 4;
		     symbol_ptr -> label_node.class = 12;
		     call symbol_thread;
		     current = addrel (current, 5);
		     if pascal_context_$options.bind then do;
			call pascal_gen_rel_$symb (abs, 6);
			call pascal_gen_rel_$symb (text_rel, 1);
			call pascal_gen_rel_$symb (abs, 3);
		     end;
		     p3 = p3 -> labelblock.brother;
		end;
	     end;

	end /* PROC symbols */;

/* sort symbols of level */

	i = 32;
	do while ((symbols (i).first = "0"b) & (i >= 0));
	     i = i - 1;
	end;
	if i = -1 then do;
	     block_ptr -> symbol_block.start = 0;
	end;
	else do;
	     do while (i > 0);
		if symbols (i - 1).first = "0"b then do;
		     symbols (i - 1).first = symbols (i).first;
		     symbols (i - 1).last = symbols (i).last;
		end;
		else do;
		     last = ptr (current, symbols (i - 1).last);
		     next = ptr (current, symbols (i).first);
		     get_fbr (last) -> pascal_father_brother.brother =
			fixed (rel (next)) - fixed (rel (last));
		end;
		i = i - 1;
	     end;
	     value = fixed (symbols (0).first) - fixed (rel (block_ptr));
	     block_ptr -> symbol_block.start = value;
	end;

/* chain table in symbol_block */

	if symbols (2).first ^= "0"b then do;
	     block_ptr -> symbol_block.chain (1) =
		fixed (symbols (2).first) - fixed (rel (block_ptr));
	     if symbols (4).first ^= "0"b then do;
		block_ptr -> symbol_block.chain (2) =
		     fixed (symbols (4).first) - fixed (rel (block_ptr));
		if symbols (8).first ^= "0"b then do;
		     block_ptr -> symbol_block.chain (3) =
			fixed (symbols (8).first) - fixed (rel (block_ptr));
		     if symbols (16).first ^= "0"b then do;
			block_ptr -> symbol_block.chain (4) =
			     fixed (symbols (16).first) - fixed (rel (block_ptr));
		     end;
		end;
	     end;
	end;

/* create table for son procedures */

	if node_ptr -> procnode.son ^= null then do;
	     block_ptr -> symbol_block.son = fixed (rel (current)) - fixed (rel (block_ptr));
	     call create_level_tables (node_ptr -> procnode.son, rel (block_ptr));
	end;
	else block_ptr -> symbol_block.son = 0;

/* create table for brother procedures */

	if node_ptr -> procnode.brother ^= null then do;
	     block_ptr -> symbol_block.brother = fixed (rel (current)) - fixed (rel (block_ptr));
	     call create_level_tables (node_ptr -> procnode.brother, father_block);
	end;
	else block_ptr -> symbol_block.brother = 0;

	return;

%page;
build_pascal_parm_descs: proc (p1);

dcl p1 ptr;					/* (input) ptr to procedure box */

dcl num_descs fixed bin init (0);
dcl i fixed bin;
dcl table_ptr ptr;
dcl is_function bit (1);

	if p1 ^= null then num_descs = p1 -> proc_d.nbparproc;

	parm_list_ptr = current_text;
	parm_list_ptr -> parm_desc_ptrs.n_args = num_descs;
	i = size (parm_list_ptr -> parm_desc_ptrs);
	current_text = addrel (current_text, i);
	call pascal_gen_rel_$text (abs, 1);
	call pascal_gen_rel_$text (text_rel, 2 * i - 1);
	if p1 ^= null then do;
	     is_function = ((p1 -> proc_d.proctype) ^= p1);
	     table_ptr = p1 -> proc_d.formals;
	     do i = 1 to num_descs;
		arg_dims = 0; arg_is_packed = "0"b;
		if table_ptr ^= null then do;
		     if table_ptr -> cth.klass = vars then
			if table_ptr -> var_d.vkind = arraybound then
			     go to skip_array_bound;
		     if table_ptr -> cth.klass = proc then do;
			call get_proc_type (table_ptr, type_addr);
			parm_size = pascal_parameter_proc_size;
			type_code = pascal_parameter_procedure_dtype;
		     end;
		     else do;
			type_table = table_ptr -> var_d.vtype;
			call get_var_type_info (type_table, type_code, type_addr);
			parm_size = type_table -> tdh.size;
			if type_table -> tdh.form = arrays then do;
			     arg_type_ptr = type_table;
			     arg_is_packed = (type_table -> tdh.pack = 1);
			     do while (arg_type_ptr -> atd.conformant = 1);
				arg_dims = arg_dims + 1;
				arg_type_ptr = arg_type_ptr -> atd.aeltype;
			     end;
			end;
		     end;
		end;
		else
		     if (i = num_descs) & is_function then do;
		     type_table = p1 -> proc_d.proctype;
		     call get_var_type_info (type_table, type_code, type_addr);
		     parm_size = type_table -> tdh.size;
		end;
		else call internal_error
			("Internal inconsistency in parameter list for procedure " || rtrim (p1 -> cth.name));
		arg_descriptor_ptr = current_text;
		arg_descriptor_ptr -> arg_descriptor.flag = "1"b;
		arg_descriptor_ptr -> extended_arg_descriptor.number_dims = arg_dims;
		arg_descriptor_ptr -> arg_descriptor.packed = arg_is_packed;
		do it = 1 to arg_dims;
		     unspec (arg_descriptor_ptr -> extended_arg_descriptor.dims (it).low),
			unspec (arg_descriptor_ptr -> extended_arg_descriptor.dims (it).high),
			unspec (arg_descriptor_ptr -> extended_arg_descriptor.dims (it).multiplier) = "1"b;
		end;
		if type_code > 63 then do;
		     arg_descriptor_ptr -> extended_arg_descriptor.type = extended_arg_type;
		     arg_descriptor_ptr -> extended_arg_descriptor.real_type = type_code;
		     if type_addr ^= null then
			arg_descriptor_ptr -> extended_arg_descriptor.type_offset =
			     fixed (rel (type_addr)) - fixed (pascal_context_$symb_ptr -> area_pointer);
		     len = 2 + 3 * arg_dims;
		end;
		else do;
		     arg_descriptor_ptr -> arg_descriptor.type = type_code;
		     if (type_code = pascal_integer_dtype)
			| (type_code = pascal_real_dtype) then
			arg_descriptor_ptr -> arg_descriptor.size = decode_size (parm_size, type_table);
		     len = size (arg_descriptor);
		end;
		value = fixed (rel (arg_descriptor_ptr));
		parm_list_ptr -> descriptor_relp (i) = addr (value) -> val.low;
		current_text = addrel (arg_descriptor_ptr, len);
		call pascal_gen_rel_$text (abs, len * 2);
skip_array_bound:
		if table_ptr ^= null then
		     table_ptr = table_ptr -> cth.nxtel;
	     end;
	end;
	pascal_context_$text_word_count = fixed (rel (current_text));

     end build_pascal_parm_descs;
%page;
build_pl1_parm_descs: proc (p1);

dcl p1 ptr;					/* (input) ptr to procedure box */

dcl table_ptr ptr;
dcl (desc_len, i) fixed bin;
dcl size builtin;
dcl num_descs fixed bin init (0);
dcl is_function bit (1);

	if p1 ^= null then
	     num_descs = p1 -> proc_d.nbparproc;
	parm_list_ptr = current_text;
	parm_list_ptr -> parm_desc_ptrs.n_args = num_descs;
						/*	i = size (parm_list_ptr -> parm_desc_ptrs); */
	i = (2 + num_descs) / 2;
	current_text = addrel (current_text, i);
	call pascal_gen_rel_$text (abs, 1);
	call pascal_gen_rel_$text (text_rel, 2 * i - 1);
	if p1 = null then return;

	table_ptr = p1 -> proc_d.formals;
	is_function = ((p1 -> proc_d.proctype) ^= p1);
	do i = 1 to num_descs;
	     arg_descriptor_ptr = current_text;
	     desc_len = 0;
	     arg_descriptor_ptr -> arg_descriptor.flag = "1"b;
	     if (i = num_descs) & (is_function) then
		call build_basic_pl1_desc ((p1 -> proc_d.proctype), (current_text), desc_len);
	     else
		if table_ptr ^= null then do;
		if table_ptr -> cth.klass = vars then
		     if table_ptr -> var_d.vkind = arraybound then
			go to skip_array_bound;
		if table_ptr -> cth.klass = proc then do;
		     arg_descriptor_ptr -> arg_descriptor.type = entry_dtype;
		     desc_len = 1;
		end;
		else
		     call build_basic_pl1_desc ((table_ptr -> var_d.vtype), (current_text), desc_len);
	     end;
	     else call internal_error
		     ("Internal inconsistency in parameter list for procedure " || rtrim (p1 -> cth.name));
	     call pascal_gen_rel_$text (abs, desc_len * 2);
	     value = fixed (rel (arg_descriptor_ptr));
	     parm_list_ptr -> descriptor_relp (i) = addr (value) -> val.low;
	     current_text = addrel (arg_descriptor_ptr, desc_len);
skip_array_bound:
	     if table_ptr ^= null then
		table_ptr = table_ptr -> cth.nxtel;
	end;
	pascal_context_$text_word_count = fixed (rel (current_text));

	return;

arg_desc_error:
	call user_error ("Cannot generate descriptor for argument " || ltrim (char (i)) ||
	     " passed to external procedure " || rtrim (p1 -> cth.name) ||
	     " (language " || rtrim (trap_info.trans) || ").");

build_basic_pl1_desc: proc (TTP, PLACE, LEN);

dcl TTP ptr;					/* Type Table Ptr (input) */
dcl PLACE ptr;					/* (input) */
dcl LEN fixed bin;					/* longueur generee (output) */

dcl (lsize, len, it, ndims) fixed bin;
dcl set_eltype ptr;
dcl (work, work1) ptr;
dcl done bit (1) init ("0"b);

	PLACE -> arg_descriptor.flag = "1"b;
	if TTP -> tdh.form = aliastype then
	     TTP = TTP -> aliastype_td.realtype;

	if TTP = RACINE_defs$boolptr
	     | TTP = RACINE_defs$intptr then do;
fix_bin_35_desc:
	     PLACE -> arg_descriptor.type = real_fix_bin_1_dtype;
	     PLACE -> arg_descriptor.size = 35;
	     LEN = 1;
	     return;
	end;
	if TTP = RACINE_defs$realptr then do;
	     PLACE -> arg_descriptor.type = real_flt_bin_2_dtype;
	     PLACE -> arg_descriptor.size = 63;
	     LEN = 1;
	     return;
	end;
	if TTP = RACINE_defs$charptr
	     | TTP = RACINE_defs$textfilectp then go to arg_desc_error;
	if (TTP -> tdh.form = numeric)
	     | (TTP -> tdh.form = scalar) then go to fix_bin_35_desc;
	if TTP -> tdh.form = pointer then do;
	     PLACE -> arg_descriptor.type = pointer_dtype;
	     LEN = 1;
	     return;
	end;
	if TTP -> tdh.form = power then do;
	     set_eltype = TTP -> power_td.elset;
	     if set_eltype = RACINE_defs$boolptr then
		PLACE -> arg_descriptor.size = 2;
	     else if set_eltype = RACINE_defs$charptr then
		PLACE -> arg_descriptor.size = 256;
	     else if set_eltype -> tdh.form = numeric then
		PLACE -> arg_descriptor.size = TTP -> numeric_td.nmax + 1;
	     else if set_eltype -> tdh.form = scalar then do;
		if set_eltype -> std.subrng = true then
		     set_eltype = set_eltype -> scalar_subrange_td.typset;
		work = set_eltype -> scalar_td.fconst; lsize = 0;
		do while (work ^= null);
		     lsize = lsize + 1;
		     work = work -> cdh.succ;
		end;
		PLACE -> arg_descriptor.size = lsize;
	     end;
	     LEN = 1;
	     return;
	end;
	if TTP -> tdh.form = arrays then do;
	     ndims = 0; work1 = TTP; work = TTP -> atd.aeltype;
count_dims:
	     if (work = RACINE_defs$charptr)
		& (work1 -> tdh.pack = true)
		& (work1 -> atd.conformant = false) then do;
		PLACE -> arg_descriptor.type = char_dtype;
		PLACE -> arg_descriptor.size =
		     work1 -> array_td.hi - work1 -> array_td.lo + 1;
		done = "1"b;
	     end;
	     else do;
		ndims = ndims + 1;
		if (work -> tdh.form = arrays) then
		     if (work1 -> atd.conformant = work -> atd.conformant)
			& (work1 -> tdh.pack = work -> tdh.pack) then do;
			work1 = work;
			work = work -> atd.aeltype;
			go to count_dims;
		     end;
	     end;
	     if done then go to fill_dims;
	     if TTP -> tdh.pack = true then do;
		PLACE -> arg_descriptor.packed = "1"b;
		if (work = RACINE_defs$realptr)
		     | (work = RACINE_defs$intptr) then do;
		     call build_basic_pl1_desc (work, PLACE, LEN);
		     done = "1"b;
		end;
		else if (work = RACINE_defs$charptr) then
		     if (work1 -> atd.conformant = true) then do;
			PLACE -> arg_descriptor.type = char_dtype;
			PLACE -> arg_descriptor.size = 1;
			done = "1"b;
		     end;
		     else go to fill_dims;
		else go to arg_desc_error;
		go to fill_dims;
	     end;
	     else do;
fill_dims:
		PLACE -> arg_descriptor.number_dims = ndims;
		if TTP -> atd.conformant = true then
		     do it = ndims to 1 by -1;
		     unspec (PLACE -> extended_arg_descriptor.dims.low (it)) = "400000000000"b3;
		     unspec (PLACE -> extended_arg_descriptor.dims.high (it)) = "400000000000"b3;
		     unspec (PLACE -> extended_arg_descriptor.dims.multiplier (it)) = "400000000000"b3;
		end;
		else do;
		     work = TTP;
		     do it = ndims to 1 by -1;
			PLACE -> extended_arg_descriptor.dims.low (it) = work -> array_td.lo;
			PLACE -> extended_arg_descriptor.dims.high (it) = work -> array_td.hi;
			if TTP -> tdh.pack = true then
			     PLACE -> extended_arg_descriptor.dims.multiplier (it) =
				work -> array_td.subsize * 9;
			else
			     PLACE -> extended_arg_descriptor.dims.multiplier (it) =
				work -> array_td.subsize / 4;
			work = work -> atd.aeltype;
		     end;
		end;
		if ^done then
		     if work -> tdh.form = arrays then go to arg_desc_error;
		     else do;
			call build_basic_pl1_desc ((work), PLACE, LEN);
			if LEN > 1 then go to arg_desc_error;
		     end;
		LEN = 1 + ndims * 3;
	     end;
	     return;
	end;
	if TTP -> tdh.form = records then do;
	     call build_record_desc (TTP, PLACE, LEN, 0);
	     return;
	end;
	go to arg_desc_error;

     end build_basic_pl1_desc;

build_record_desc: proc (TTP, PLACE, LEN, NDIMS);

dcl TTP ptr;					/* (input) ptr to record type table */
dcl PLACE ptr;					/* (input) ptr to place where generate descriptor */
dcl LEN fixed bin;					/* (output) length of descriptor generated */
dcl NDIMS fixed bin;				/* (input) number of dims for this structure */
dcl DIMSPLACE ptr;					/* (input) ptr to ddescription of this dims (3 * NDIMS words) */
dcl n_fields fixed bin;
dcl current_desc_place ptr;
dcl work ptr;
dcl work1 ptr;
dcl (fldp, fldtp) ptr;
dcl (it, ndims, len, ed_size) fixed bin;
dcl existing_dims (ed_size) fixed bin (35) based;

/* At this moment, at PLACE, we have a descriptor word with only the field ndims filled.
   At PLACE +1, if ndims is non null, we have the dimension description (3 * ndims words */

	if TTP -> tdh.pack = true then go to arg_desc_error;
	if TTP -> records_td.recvar ^= null then go to arg_desc_error;
	PLACE -> arg_descriptor.type = structure_dtype;
	PLACE -> arg_descriptor.flag = "1"b;
	ed_size = 3 * NDIMS;
	LEN = ed_size + 1;
	current_desc_place = addrel (PLACE, LEN);

	if MODATTR$is_pl1_varying_char (TTP) = true then do;
	     PLACE -> arg_descriptor.type = varying_char_dtype;
	     PLACE -> arg_descriptor.size =
		TTP -> records_td.fstfld -> field_d.fldtype -> numeric_td.nmax;
	     return;
	end;
	fldp = TTP -> records_td.fstfld; n_fields = 0;
	do while (fldp ^= null);
	     n_fields = n_fields + 1;
	     fldtp = fldp -> field_d.fldtype;
	     if fldtp -> tdh.form = arrays then do;
		if fldtp -> tdh.pack = true then do;
		     if fldtp -> atd.aeltype = RACINE_defs$charptr then do;
			current_desc_place -> arg_descriptor.type = char_dtype;
			current_desc_place -> arg_descriptor.flag = "1"b;
			current_desc_place -> arg_descriptor.size =
			     fldtp -> array_td.hi - fldtp -> array_td.lo + 1;
			current_desc_place -> arg_descriptor.number_dims = NDIMS;
			addrel (current_desc_place, 1) -> existing_dims = addrel (PLACE, 1) -> existing_dims;
			len = 1 + ed_size;
			go to next_field;
		     end;
		     else go to arg_desc_error;
		end;
		ndims = 0; work1 = fldtp; work = fldtp -> atd.aeltype;
count_dims:
		ndims = ndims + 1;
		if (work -> tdh.form = arrays) then
		     if (work1 -> tdh.pack = work -> tdh.pack) then do;
			work1 = work;
			work = work -> atd.aeltype;
			go to count_dims;
		     end;
		if work -> tdh.form = records then do;
		     current_desc_place -> arg_descriptor.number_dims = ndims + NDIMS;
		     work1 = fldtp;
		     do it = ndims to 1 by -1;
			current_desc_place -> extended_arg_descriptor.dims.low (it) = work1 -> array_td.lo;
			current_desc_place -> extended_arg_descriptor.dims.high (it) = work1 -> array_td.hi;
			current_desc_place -> extended_arg_descriptor.dims.multiplier (it) =
			     work1 -> array_td.subsize / 4;
			work1 = work1 -> atd.aeltype;
		     end;
		     addrel (current_desc_place, 1 + ndims * 3) -> existing_dims = addrel (PLACE, 1) -> existing_dims;
		     call build_record_desc ((work), current_desc_place, len, NDIMS + ndims);
		     go to next_field;
		end;
	     end;
	     current_desc_place -> arg_descriptor.number_dims = NDIMS;
	     addrel (current_desc_place, 1) -> existing_dims = addrel (PLACE, 1) -> existing_dims;
	     if fldtp -> tdh.form = records then
		call build_record_desc ((fldtp), current_desc_place, len, NDIMS);
	     else do;
		call build_basic_pl1_desc ((fldtp), current_desc_place, len);
		if len ^= 1 then go to arg_desc_error;
		len = 1 + NDIMS * 3;
	     end;
next_field:
	     current_desc_place = addrel (current_desc_place, len);
	     fldp = fldp -> cth.nxtel;
	end;
	LEN = fixed (rel (current_desc_place)) - fixed (rel (PLACE));
	PLACE -> arg_descriptor.size = n_fields;

     end build_record_desc;

     end build_pl1_parm_descs;
%page;
normalize_source_acc: proc (sp);

dcl sp ptr;

dcl 1 str like acc based (sp);
dcl (translate, substr, index) builtin;
dcl (i1, i2, l, i, j) fixed bin;

	l = str.size;
						/* translate upper case, line feed and tabs */
	str.string = translate (str.string, "abcdefghijklmnopqrstuvwxyz  ",
	     "ABCDEFGHIJKLMNOPQRSTUVWXYZ
");
						/* remove comments */
check_com:
	i1 = index (str.string, "{");
	i2 = index (str.string, "(*");
	if (i1 ^= 0) | (i2 ^= 0) then do;
	     if (i1 ^= 0) & (i2 ^= 0) then
		if i1 < i2 then go to remove_com_1; else go to remove_com_2;
	     if (i1 ^= 0) then go to remove_com_1;
	     else go to remove_com_2;
remove_com_1:
	     j = index (substr (str.string, i1), "}");
	     if j ^= 0 then do;
		str.string = substr (str.string, 1, i1 - 1) || substr (str.string, i1 + j) || copy (" ", j);
		l = l - j;
		go to check_com;
	     end;
remove_com_2:
	     j = index (substr (str.string, i2), "*)");
	     if j ^= 0 then do;
		str.string = substr (str.string, 1, i2 - 1) || substr (str.string, i2 + j + 1) || copy (" ", j + 1);
		l = l - (j + 1);
		go to check_com;
	     end;
	end;
						/* remove blanks */
	i = index (str.string, " ");
	do while (i ^= 0);
	     str.string = substr (str.string, 1, i - 1) || substr (str.string, i + 1) || " ";
	     l = l - 1;
	     i = index (str.string, " ");
	end;
	str.size = l;
     end normalize_source_acc;
%page;
get_var_type_info: proc (BP, TC, TP);

dcl BP ptr;					/* (input) ptr to compiler TYPE box */
dcl TC fixed bin (35);				/* (output) type code for variable of this type */
dcl TP ptr;					/* (output) ptr to runtime symbol block generated for this TYPE (null if none) */

	TC = 0; TP = null;

	if BP -> tdh.form = aliastype then
	     BP = BP -> aliastype_td.realtype;

	if BP = RACINE_defs$intptr then TC = pascal_integer_dtype;
	else if BP = RACINE_defs$realptr then TC = pascal_real_dtype;
	else if BP = RACINE_defs$charptr then TC = pascal_char_dtype;
	else if BP = RACINE_defs$boolptr then TC = pascal_boolean_dtype;
	else if BP = RACINE_defs$textfilectp then TC = pascal_text_file_dtype;
	else do;
	     if (BP -> tdh.form = scalar) & (BP -> std.subrng = false) then
		TC = pascal_enumerated_type_instance_dtype;
	     else TC = pascal_user_defined_type_instance_dtype;
	     call get_symbol_block (BP, TP);
	end;
     end get_var_type_info;

decode_size: proc (S, T) returns (fixed bin (35));

dcl S fixed bin (35);				/* size found in PASCAL compiler table (in bytes) */
dcl T ptr;					/* ptr to compiler type box */

/* returns correct size for runtime tables */

	if T = RACINE_defs$intptr
	     | T -> tdh.form = numeric then return ((S * 9) - 1);
	if T = RACINE_defs$realptr then return ((S * 9) - 9);
	return (S * 9);

     end decode_size;

symbol_thread: proc;

dcl (p1, p2) ptr;

	p1 = get_fbr (symbol_ptr);
	p1 -> pascal_father_brother.father =
	     fixed (rel (block_ptr)) - fixed (rel (symbol_ptr));
	if symbols (length (symbol_name)).first = "0"b then do;
	     p1 -> pascal_father_brother.brother = 0;
	     symbols (length (symbol_name)).first,
		symbols (length (symbol_name)).last = rel (symbol_ptr);
	end;
	else do;
	     work = ptr (current, symbols (length (symbol_name)).first);
	     previous_symbol = null;
search:
	     p2 = get_fbr (work);
	     name = addrel (work, work -> new_runtime_symbol.name) -> acc.string;
	     if name < symbol_name then do;		/* insert after work -> symbol */
		if p2 -> pascal_father_brother.brother = 0 then do;
		     p2 -> pascal_father_brother.brother =
			fixed (rel (symbol_ptr)) - fixed (rel (work));
		     symbols (length (symbol_name)).last = rel (symbol_ptr);
		     p1 -> pascal_father_brother.brother = 0;
		end;
		else do;
		     previous_symbol = work;
		     work = addrel (work, p2 -> pascal_father_brother.brother);
		     go to search;
		end;
	     end;
	     else do;				/* insert before work -> symbol */
		if previous_symbol = null then
		     symbols (length (symbol_name)).first = rel (symbol_ptr);
		else do;
		     get_fbr (previous_symbol) -> pascal_father_brother.brother =
			fixed (rel (symbol_ptr)) - fixed (rel (previous_symbol));
		end;
		p1 -> pascal_father_brother.brother =
		     fixed (rel (work)) - fixed (rel (symbol_ptr));
	     end;
	end;
     end symbol_thread;

%page;

get_symbol_block: proc (TP, SP);

dcl TP ptr;					/* ptr to compiler symbol table (input) */
dcl SP ptr;					/* ptr to runtime symbol table (output) */

dcl symbol_name char (32) varying;
dcl (name_place,
    symbol_ptr,
    record_ptr,
    value_place,
    ev_addr,
    low_addr,
    up_addr,
    nnx_ptr,
    btp_ptr,
    add_ptr,
    fbr_ptr,
    sbl_ptr,
    fts_ptr,
    slv_ptr,
    siz_ptr,
    off_ptr,
    ari_ptr,
    vai_ptr) ptr;

dcl value fixed bin (35);
dcl bsl fixed bin (35);
dcl name_flag bit (1);
dcl scount fixed bin (35);
dcl type_code fixed bin (35);
dcl ndims fixed bin (35);
dcl (work, work1, work2, work3) ptr;
dcl fb63b float bin (63) unal based;
dcl bstring char (bsl) unal based;
dcl (p1, p2, p3) ptr;
dcl has_ref_table bit (1) init ("0"b);

	if TP -> cth.symbolplace ^= null then do;	/* allready built */
	     SP = TP -> cth.symbolplace;
	     return;
	end;

	symbol_name = rtrim (TP -> tdh.name);
	if symbol_name ^= "" then call allocate_name (symbol_name, name_place);

	if pascal_context_$options.ref_table then
	     has_ref_table = (TP -> cth.klass = vars) | (TP -> cth.klass = proc);
	if has_ref_table then do;
	     current = addrel (current, size (ref_info_header));
	     if pascal_context_$options.bind then
		call pascal_gen_rel_$symb (abs, size (ref_info_header) * 2);
	end;
	call alloc_hdr;
	SP = symbol_ptr;
	TP -> cth.symbolplace = symbol_ptr;

	if symbol_name ^= "" then do;
	     call alloc_nnx;
	     nnx_ptr -> pascal_name_next.name = fixed (rel (name_place)) - fixed (rel (symbol_ptr)) + 1;
	     if name_place -> my_symbol_token.dcl ^= 0 then do;
		work = addrel (name_place, name_place -> my_symbol_token.dcl);
		symbol_ptr -> new_runtime_symbol.next_token =
		     fixed (rel (work)) - fixed (rel (symbol_ptr));
		name_place -> my_symbol_token.dcl =
		     fixed (rel (symbol_ptr)) - fixed (rel (name_place));
	     end;
	     name_place -> my_symbol_token.dcl =
		fixed (rel (symbol_ptr)) - fixed (rel (name_place));
	     name_flag = "1"b;
	end;
	else name_flag = "0"b;

	if TP -> cth.klass = konst then do;		/* CONSTANT */
	     if TP -> cdh.typofconst = wordconst then do; /* one word constant */
		if TP -> cdh.contype = RACINE_defs$intptr then do; /* integer */
		     call alloc_add (abs);
		     if name_flag then call alloc_fbr;
		     call alloc_siz;
		     symbol_ptr -> pascal_symbol_node_header.type = pascal_integer_dtype;
		     add_ptr -> pascal_address.location = fixed (rel (current)) - fixed (rel (symbol_ptr));
		     add_ptr -> pascal_address.class = pascal_constant_in_symbol_class_code;
		     current -> fb35b = TP -> wordconst_cd.values;
		     current = addrel (current, 1);
		     if pascal_context_$options.bind then
			call pascal_gen_rel_$symb (abs, 2);
		     siz_ptr -> pascal_size = decode_size (4, RACINE_defs$intptr);
		end;
		else if TP -> cdh.contype = RACINE_defs$charptr then do; /* char */
		     call alloc_add (abs);
		     if name_flag then call alloc_fbr;
		     call alloc_siz;
		     symbol_ptr -> pascal_symbol_node_header.type = pascal_char_dtype;
		     add_ptr -> pascal_address.location = fixed (rel (current)) - fixed (rel (symbol_ptr));
		     add_ptr -> pascal_address.class = pascal_constant_in_symbol_class_code;
		     current -> fb35b = TP -> wordconst_cd.values;
		     current = addrel (current, 1);
		     if pascal_context_$options.bind then
			call pascal_gen_rel_$symb (abs, 2);
		     siz_ptr -> pascal_size = decode_size (4, RACINE_defs$charptr);
		end;
		else if TP -> cdh.contype -> tdh.form = scalar then do; /* scalar */
		     call alloc_add (abs);
		     if name_flag then call alloc_fbr;
		     call alloc_fts;
		     call alloc_siz;
		     symbol_ptr -> pascal_symbol_node_header.type = pascal_enumerated_type_element_dtype;
		     call alloc_scalar_code (TP -> wordconst_cd.values, value_place);
		     add_ptr -> pascal_address.location = fixed (rel (value_place)) - fixed (rel (symbol_ptr));
		     add_ptr -> pascal_address.class = pascal_constant_in_symbol_class_code;
		     siz_ptr -> pascal_size = decode_size (4, TP -> cdh.contype);
		end;
		else call internal_error ("Unknown word const type.");
	     end;
	     else if TP -> cdh.typofconst = dwordconst then do;
		if TP -> cdh.contype = RACINE_defs$realptr then do; /* real */
		     call alloc_add (abs);
		     if name_flag then call alloc_fbr;
		     call alloc_siz;
		     symbol_ptr -> pascal_symbol_node_header.type = pascal_real_dtype;
		     add_ptr -> pascal_address.location = fixed (rel (current)) - fixed (rel (symbol_ptr));
		     add_ptr -> pascal_address.class = pascal_constant_in_symbol_class_code;
		     current -> fb63b = TP -> dwordconst_cd.valreel;
		     current = addrel (current, 2);
		     if pascal_context_$options.bind then
			call pascal_gen_rel_$symb (abs, 4);
		     siz_ptr -> pascal_size = decode_size (8, RACINE_defs$charptr);
		end;
		else call internal_error ("Unknown double word constant type.");
	     end;
	     else if TP -> cdh.typofconst = alfaconst then do; /* string */
		call alloc_add (abs);
		p2 = add_ptr;
		if name_flag then call alloc_fbr;
		call alloc_siz;
		scount = TP -> alfaconst_cd.alfalong;
		siz_ptr -> pascal_size = decode_size (TP -> alfaconst_cd.alfalong, RACINE_defs$charptr);
		symbol_ptr -> pascal_symbol_node_header.type = pascal_user_defined_type_instance_dtype;
		symbol_ptr -> pascal_symbol_node_header.type_offset = fixed (rel (current)) - fixed (rel (symbol_ptr));
		call alloc_hdr;
		symbol_ptr -> pascal_symbol_node_header.flags.packed = "1"b;
		symbol_ptr -> pascal_symbol_node_header.type = pascal_user_defined_type_dtype;
		call alloc_btp;
		call alloc_siz;
		call alloc_ari (1);
		btp_ptr -> pascal_base_type_info.base_type = pascal_char_dtype;
		p2 -> pascal_address.location = fixed (rel (current)) - fixed (rel (SP));
		p2 -> pascal_address.class = pascal_constant_in_symbol_class_code;
		ari_ptr -> pascal_array_info.ndims = 1;
		ari_ptr -> pascal_array_info.lower (1) = 1;
		ari_ptr -> pascal_array_info.upper (1) = scount;
		ari_ptr -> pascal_array_info.multiplier (1) = 1;
		ari_ptr -> pascal_array_info.subscript_type (1) = pascal_integer_dtype;
		siz_ptr -> pascal_size = decode_size (1, RACINE_defs$charptr);
		work = TP -> alfaconst_cd.alfadeb;
		do while (scount > 16);
		     bsl = 16;
		     current -> bstring = work -> alfabox.string;
		     current = addrel (current, 16 / 4);
		     if pascal_context_$options.bind then
			call pascal_gen_rel_$symb (abs, 16 / 2);
		     scount = scount - 16;
		     work = work -> alfabox.next;
		end;
		bsl = scount;
		current -> bstring = addr (work -> alfabox.string) -> bstring;
		bsl = (bsl + 3) / 4;
		current = addrel (current, bsl);
		if pascal_context_$options.bind then
		     call pascal_gen_rel_$symb (abs, (bsl * 2));
	     end;
	end /* CONSTANT */;

	else if TP -> cth.klass = types then do;	/* TYPES */
	     if TP -> tdh.form = numeric then do;
		symbol_ptr -> pascal_symbol_node_header.type = pascal_user_defined_type_dtype;
		call alloc_btp;
		btp_ptr -> pascal_base_type_info.base_type = pascal_integer_dtype;
		if name_flag then call alloc_fbr;
		call alloc_siz;
		siz_ptr -> pascal_size = 35;
		call alloc_sbl;
		sbl_ptr -> pascal_subrange_limits.subrange_lower_bound = TP -> numeric_td.nmin;
		sbl_ptr -> pascal_subrange_limits.subrange_upper_bound = TP -> numeric_td.nmax;
	     end /* numeric type */;
	     else if TP -> tdh.form = scalar then do;	/* enumerated type */
		if TP -> std.subrng = false then do;	/* not subrange */
		     symbol_ptr -> pascal_symbol_node_header.type = pascal_enumerated_type_dtype;
		     if name_flag then call alloc_fbr;
		     call alloc_slv;
		     work = TP -> scalar_td.fconst;
		     call get_symbol_block (work, work1);
		     get_fts (work1) -> pascal_father_type_successor.father_type = fixed (rel (symbol_ptr)) - fixed (rel (work1));
		     work = work -> cdh.succ;
		     do while (work ^= null);
			work2 = work1;
			call get_symbol_block (work, work1);
			work3 = get_fts (work1);
			work3 -> pascal_father_type_successor.successor = fixed (rel (work2)) - fixed (rel (work1));
			work3 -> pascal_father_type_successor.father_type = fixed (rel (symbol_ptr)) - fixed (rel (work1));
			work = work -> cdh.succ;
		     end;
		     slv_ptr -> pascal_son_level.son = fixed (rel (work1)) - fixed (rel (symbol_ptr));
		end;
		else if TP -> std.subrng = true then do;/* subrange */
		     symbol_ptr -> pascal_symbol_node_header.type = pascal_user_defined_type_dtype;
		     call alloc_btp;
		     if name_flag then call alloc_fbr;
		     call alloc_sbl;
		     call get_var_type_info (TP -> scalar_subrange_td.typset, type_code, work);
		     btp_ptr -> pascal_base_type_info.base_type = type_code;
		     if work ^= null then
			btp_ptr -> pascal_base_type_info.base_type_offset = fixed (rel (work)) - fixed (rel (symbol_ptr));
		     if type_code = pascal_enumerated_type_instance_dtype then do;
			work = addrel (work, get_slv (work) -> pascal_son_level.son);
			scount = 0;
			do while (scount < TP -> scalar_subrange_td.smin);
			     work = addrel (work, get_fts (work) -> pascal_father_type_successor.successor);
			     scount = scount + 1;
			end;
			sbl_ptr -> pascal_subrange_limits.lower_bound_is_encoded = "1"b;
			call build_encoded_ref_to_scalar (addr (sbl_ptr -> pascal_subrange_limits.subrange_lower_bound), work);
			do while (scount < TP -> scalar_subrange_td.smax);
			     work = addrel (work, get_fts (work) -> pascal_father_type_successor.successor);
			     scount = scount + 1;
			end;
			sbl_ptr -> pascal_subrange_limits.upper_bound_is_encoded = "1"b;
			call build_encoded_ref_to_scalar (addr (sbl_ptr -> pascal_subrange_limits.subrange_upper_bound), work);
		     end;
		     else if type_code = pascal_char_dtype then do;
			sbl_ptr -> pascal_subrange_limits.subrange_lower_bound = TP -> scalar_subrange_td.smin;
			sbl_ptr -> pascal_subrange_limits.subrange_upper_bound = TP -> scalar_subrange_td.smax;
		     end;
		end;
	     end;
	     else if TP -> tdh.form = pointer then do;	/* pointer */
		symbol_ptr -> pascal_symbol_node_header.type = pascal_typed_pointer_type_dtype;
		call alloc_btp;
		if name_flag then call alloc_fbr;
		call alloc_siz;
		call get_var_type_info (TP -> pointer_td.eltype, scount, work);
		btp_ptr -> pascal_base_type_info.base_type = scount;
		if work ^= null then
		     btp_ptr -> pascal_base_type_info.base_type_offset = fixed (rel (work)) - fixed (rel (symbol_ptr));
		siz_ptr -> pascal_size =
		     decode_size (TP -> pointer_td.eltype -> tdh.size, TP -> pointer_td.eltype);
	     end;
	     else if TP -> tdh.form = power then do;	/* power */
		symbol_ptr -> pascal_symbol_node_header.type = pascal_set_dtype;
		call alloc_btp;
		if name_flag then call alloc_fbr;
		call get_var_type_info (TP -> power_td.elset, scount, work);
		btp_ptr -> pascal_base_type_info.base_type = scount;
		if work ^= null then
		     btp_ptr -> pascal_base_type_info.base_type_offset = fixed (rel (work)) - fixed (rel (symbol_ptr));
	     end;
	     else if TP -> tdh.form = arrays then do;	/* array */
		ndims = 1; work1 = TP; work = TP -> atd.aeltype;
		do while ((work -> tdh.form = arrays) & (work -> cth.name = "")
		     & (work -> tdh.pack = TP -> tdh.pack));
		     ndims = ndims + 1;
		     work1 = work;
		     work = work -> atd.aeltype;
		end;
		call alloc_btp;
		if name_flag then call alloc_fbr;
		call alloc_siz;
		call alloc_ari (ndims);
		symbol_ptr -> pascal_symbol_node_header.type = pascal_user_defined_type_dtype;
		symbol_ptr -> pascal_symbol_node_header.flags.packed = (TP -> tdh.pack = true);
		call get_var_type_info (work, type_code, work2);
		btp_ptr -> pascal_base_type_info.base_type = type_code;
		if work2 ^= null then
		     btp_ptr -> pascal_base_type_info.base_type_offset = fixed (rel (work2)) - fixed (rel (symbol_ptr));
		ari_ptr -> pascal_array_info.virtual_origin = 0;
		if TP -> atd.conformant = false then do;/* non conformant */
		     ari_ptr -> pascal_array_info.array_units = 2; /* bytes */
		     siz_ptr -> pascal_size = decode_size (work1 -> array_td.subsize, work);
		     work = TP;
		     do scount = 1 to ndims;
			ari_ptr -> pascal_array_info.virtual_origin =
			     ari_ptr -> pascal_array_info.virtual_origin + (work -> array_td.lo) * (work -> array_td.subsize);
			ari_ptr -> pascal_array_info.bounds (scount).lower = work -> array_td.lo;
			ari_ptr -> pascal_array_info.bounds (scount).upper = work -> array_td.hi;
			ari_ptr -> pascal_array_info.bounds (scount).multiplier = work -> array_td.subsize;
			call get_var_type_info (work -> atd.inxtype, type_code, work2);
			ari_ptr -> pascal_array_info.bounds (scount).subscript_type = type_code;
			if work2 ^= null then
			     ari_ptr -> pascal_array_info.bounds (scount).subscript_type_offset =
				fixed (rel (work2)) - fixed (rel (symbol_ptr));
			work = work -> atd.aeltype;
		     end;
		end;
		else do;
		     if TP -> tdh.pack = true then do;
			ari_ptr -> pascal_array_info.array_units = 1; /* bits */
			if work -> tdh.form = numeric then
			     siz_ptr -> pascal_size = decode_size (work -> numeric_td.npksize, work);
			else if work -> tdh.form = scalar then
			     siz_ptr -> pascal_size = decode_size (work -> scalar_td.spksize, work);
			else if work -> tdh.form = pointer then
			     siz_ptr -> pascal_size = decode_size (work -> pointer_td.ptpksize, work);
			else if work -> tdh.form = power then
			     siz_ptr -> pascal_size = decode_size (work -> power_td.ppksize, work);
			else siz_ptr -> pascal_size = decode_size (work -> tdh.size, work);
		     end;
		     else do;
			ari_ptr -> pascal_array_info.array_units = 0; /* words */
			siz_ptr -> pascal_size = decode_size (work -> tdh.size, work);
		     end;
		     work = TP;
		     do scount = 1 to ndims;
			ari_ptr -> pascal_array_info.bounds (scount).lower_is_encoded,
			     ari_ptr -> pascal_array_info.bounds (scount).upper_is_encoded,
			     ari_ptr -> pascal_array_info.bounds (scount).multiplier_is_encoded = "1"b;
			call get_symbol_block (work -> conformant_array_td.ptlow, low_addr);
			call get_symbol_block (work -> conformant_array_td.pthigh, up_addr);
			if is_numeric (work -> atd.inxtype) then do;
			     call build_encoded_ref_to_integer (addr (ari_ptr -> pascal_array_info.bounds (scount).lower), low_addr);
			     call build_encoded_ref_to_integer (addr (ari_ptr -> pascal_array_info.bounds (scount).upper), up_addr);
			end;
			else do;
			     call build_encoded_ref_to_scalar (addr (ari_ptr -> pascal_array_info.bounds (scount).lower), low_addr);
			     call build_encoded_ref_to_scalar (addr (ari_ptr -> pascal_array_info.bounds (scount).upper), up_addr);
			end;
			ev_addr = addr (ari_ptr -> pascal_array_info.bounds (scount).multiplier);
			ev_addr -> pascal_encoded_value.code = "000100"b; /* code 4 */
			ev_addr -> pascal_encoded_value.n1 = "0"b;
			ev_addr -> pascal_encoded_value.n2 = val_to_bit_6 (work -> conformant_array_td.pthigh -> var_d.vdispl / 4 + 1);
			ev_addr -> pascal_encoded_value.n3 = work -> conformant_array_td.pthigh -> var_d.vaddr / 4;
			call get_var_type_info (work -> atd.inxtype, type_code, work2);
			ari_ptr -> pascal_array_info.bounds (scount).subscript_type = type_code;
			if work2 ^= null then
			     ari_ptr -> pascal_array_info.bounds (scount).subscript_type_offset =
				fixed (rel (work2)) - fixed (rel (symbol_ptr));
			work = work -> atd.aeltype;
		     end;
		end;
	     end;
	     else if TP -> tdh.form = records then do;	/* record */
		if TP -> tdh.father_schema = RACINE_defs$string_ptr then do;
		     if name_flag then call alloc_fbr;
		     symbol_ptr -> pascal_symbol_node_header.type = pascal_string_type_dtype;
		     call alloc_siz; p2 = siz_ptr;
		     if TP -> tdh.actual_parameter_list -> var_d.vkind = arraybound then do;
			symbol_ptr -> pascal_symbol_node_header.size_is_encoded = "1"b;
			call get_symbol_block (TP -> tdh.actual_parameter_list, p1);
			call build_encoded_ref_to_integer (p2, p1);
		     end;
		     else
			siz_ptr -> pascal_size = TP -> tdh.actual_parameter_list -> wordconst_cd.values;
		end;
		else do;
		     record_ptr = symbol_ptr;
		     if name_flag then call alloc_fbr;
		     call alloc_slv;
		     symbol_ptr -> pascal_symbol_node_header.type = pascal_record_type_dtype;
		     symbol_ptr -> pascal_symbol_node_header.packed = (TP -> tdh.pack = true);
		     slv_ptr -> pascal_son_level.level = 1;
		     p2 = null;
		     p3 = slv_ptr;
		     p1 = fieldlist (TP -> records_td.fstfld, p2, TP -> records_td.recvar, symbol_ptr -> pascal_symbol_node_header.packed);
		     if p1 ^= null then
			p3 -> pascal_son_level.son = fixed (rel (p1)) - fixed (rel (record_ptr));
		end;
	     end;
	     else if TP -> tdh.form = files then do;	/* file */
		call alloc_btp;
		if name_flag then call alloc_fbr;
		symbol_ptr -> pascal_symbol_node_header.type = pascal_record_file_type_dtype;
		call get_var_type_info (TP -> files_td.feltype, type_code, work);
		btp_ptr -> pascal_base_type_info.base_type = type_code;
		if work ^= null then
		     btp_ptr -> pascal_base_type_info.base_type_offset = fixed (rel (work)) - fixed (rel (symbol_ptr));
	     end /* files */;
	     else if TP -> tdh.form = aliastype then do;
		call alloc_btp;
		if name_flag then call alloc_fbr;
		symbol_ptr -> pascal_symbol_node_header.type = pascal_user_defined_type_dtype;
		call get_var_type_info (TP -> aliastype_td.realtype, type_code, work);
		btp_ptr -> pascal_base_type_info.base_type = type_code;
		if work ^= null then
		     btp_ptr -> pascal_base_type_info.base_type_offset = fixed (rel (work)) - fixed (rel (symbol_ptr));
	     end /* aliastype */;
	end /* TYPES */;
	else if TP -> cth.klass = vars then do;		/* VARIABLE */
	     if TP -> var_d.vkind = actual then do;
		if TP -> var_d.vlevel = 0 then do;
		     call alloc_add (int18);
		     add_ptr -> pascal_address.class = pascal_internal_global_class_code;
		end;
		else do;
		     call alloc_add (abs);
		     add_ptr -> pascal_address.class = pascal_local_class_code;
		end;
		add_ptr -> pascal_address.location = TP -> var_d.vaddr / 4;
	     end;
	     else if (TP -> var_d.vkind = formal) | (TP -> var_d.vkind = arraybound) then do;
		call alloc_add (abs);
		add_ptr -> pascal_address.class = pascal_parameter_class_code;
		add_ptr -> pascal_address.location = TP -> var_d.vaddr / 4;
	     end;
	     else do;				/* externals */
		call alloc_add (link18);
		if TP -> var_d.vtype -> tdh.form = files then
		     add_ptr -> pascal_address.class = pascal_ext_file_class_code;
		else
		     add_ptr -> pascal_address.class = pascal_external_global_class_code;
		add_ptr -> pascal_address.location = pascal_context_$link_base + (TP -> var_d.vaddr / 4);
	     end;
	     if name_flag then call alloc_fbr;
	     call alloc_siz;
	     if TP -> var_d.vkind = arraybound then do;
		call alloc_off;
		off_ptr -> pascal_offset = TP -> var_d.vdispl / 4;
	     end;
	     call get_var_type_info (TP -> var_d.vtype, type_code, work);
	     symbol_ptr -> pascal_symbol_node_header.type = type_code;
	     if work ^= null then
		symbol_ptr -> pascal_symbol_node_header.type_offset = fixed (rel (work)) - fixed (rel (symbol_ptr));
	     siz_ptr -> pascal_size = decode_size (TP -> var_d.vtype -> tdh.size, TP -> var_d.vtype);
	     if TP -> var_d.vkind = formal then
		if SP -> pascal_symbol_node_header.type = pascal_user_defined_type_instance_dtype then do;
		     p1 = addrel (SP, SP -> pascal_symbol_node_header.type_offset);
		     if p1 -> pascal_symbol_node_header.type = pascal_string_type_dtype then
			if p1 -> pascal_symbol_node_header.size_is_encoded then do;
			     p1 = addrel (p1, get_siz (p1) -> pascal_encoded_value.n3);
			     get_fbr (p1) -> pascal_father_brother.father =
				fixed (rel (block_ptr)) - fixed (rel (p1));
			end;
		end;
	end /* VARS */;
	else if TP -> cth.klass = proc then do;		/* PROC */
	     value = TP -> proc_d.procaddr / 4;		/* byte count to word count */
	     if TP -> proc_d.prockind = actual then do;	/* local procedure */
		call alloc_add (text_rel);
		symbol_ptr -> pascal_symbol_node_header.type = 25; /* 25 int_entry_runtime_dtype */
		go to get_int_proc_loc;
	     end;
	     else if TP -> proc_d.prockind = formal then do; /* parameter procedure */
		call alloc_add (abs);
		symbol_ptr -> pascal_symbol_node_header.type = pascal_parameter_procedure_dtype;
		add_ptr -> pascal_address.class = pascal_parameter_class_code; /* 8 : parameter */
		add_ptr -> pascal_address.location = value;
	     end;
	     else if TP -> proc_d.prockind = exportable then do;
		call alloc_add (text_rel);
		symbol_ptr -> pascal_symbol_node_header.type = 26; /* 26 ext_entry_runtime_dtype */
get_int_proc_loc:
		add_ptr -> pascal_address.location = TP -> proc_d.locincode / 4;
		add_ptr -> pascal_address.class = 12;	/* 12 : text reference */
	     end;
	     else if TP -> proc_d.prockind = imported then do;
		call alloc_add (link18);
		symbol_ptr -> pascal_symbol_node_header.type = 27; /* 27 ext_procedure_runtime_dtype */
		value = pascal_context_$link_base + value;
		add_ptr -> pascal_address.location = value;
		add_ptr -> pascal_address.class = 5;	/* 5 : ext static */
	     end;
	     if name_flag then call alloc_fbr;
	     if TP -> proc_d.prockind = formal then do;
		call alloc_siz;
		siz_ptr -> pascal_size = pascal_parameter_proc_size;
	     end;
	     work1 = symbol_ptr;
	     call get_proc_type (TP, work);
	     work1 -> pascal_symbol_node_header.type_offset = fixed (rel (work)) - fixed (rel (work1));
						/* Create parm descs for external procedures needing descriptors */
	     if (TP -> proc_d.prockind = imported)
		& (TP -> proc_d.pwantsdescs = true) then do;
		trap_info_ptr = addrel (ptr (current_text, 0), TP -> proc_d.pextcalltrapinfoplace);
		trap_info.call_descs_relp = fixed (rel (current_text)) - fixed (rel (trap_info_ptr));
		if (trap_info.trans = "Pascal") | (trap_info.trans = "ALM")
		     | (trap_info.trans = "Unknown") then
		     call build_pascal_parm_descs (TP);
		else
		     call build_pl1_parm_descs (TP);
	     end;
	end /* PROC */;

	if has_ref_table then do;
	     addrel (SP, -1) -> ref_info_header.place = fixed (rel (current)) - fixed (rel (SP));
	     ref_n = 0;
	     ref_box_ptr = TP -> cth.references;
	     ref_info_ptr = current;
	     do while (ref_box_ptr ^= null);
		do ref_i = 1 to ref_box_ptr -> reflist.refnbr;
		     if ref_box_ptr -> reflist.sttmapindex (ref_i) ^= -2 then do;
			if ref_box_ptr -> reflist.sttmapindex (ref_i) = -1 then
			     set_in_value_section = "1"b;
			else do;
			     ref_n = ref_n + 1;
			     ref_info.modified (ref_n) = (ref_box_ptr -> reflist.linen (ref_i) < 0);
			     ref_info.map_index (ref_n) = ref_box_ptr -> reflist.sttmapindex (ref_i);
			end;
		     end;
		end;
		ref_box_ptr = ref_box_ptr -> reflist.nextref;
	     end;
	     addrel (SP, -1) -> ref_info_header.nbr = ref_n;
	     current = addrel (current, size (ref_info));
	     if pascal_context_$options.bind then
		call pascal_gen_rel_$symb (abs, size (ref_info) * 2);
	end;
	return;
						/*						*/
build_encoded_ref_to_scalar: proc (ev_addr, tp);

dcl (ev_addr, tp) ptr;

	ev_addr -> pascal_encoded_value.code = "010000"b;
	ev_addr -> pascal_encoded_value.n1 = "0"b;
	ev_addr -> pascal_encoded_value.n2 = "100100"b;
	ev_addr -> pascal_encoded_value.n3 = fixed (rel (tp)) - fixed (rel (symbol_ptr));

	return;

     end build_encoded_ref_to_scalar;

build_encoded_ref_to_integer: proc (ev_addr, tp);

dcl (ev_addr, tp) ptr;

	ev_addr -> pascal_encoded_value.code = "010000"b;
	ev_addr -> pascal_encoded_value.n1 = "000001"b;
	ev_addr -> pascal_encoded_value.n2 = "100100"b;
	ev_addr -> pascal_encoded_value.n3 = fixed (rel (tp)) - fixed (rel (symbol_ptr));

	return;

     end build_encoded_ref_to_integer;


%page;
val_to_bit_6: proc (value) returns (bit (6));

dcl value fixed bin (35);
dcl bit_36 bit (36) unal based;

	return (substr (addr (value) -> bit_36, 31, 6));
     end;


is_numeric: proc (type_ptr) returns (bit (1));

dcl type_ptr ptr;
dcl tp ptr;

	tp = type_ptr;
	do while (tp -> tdh.form = aliastype);
	     tp = tp -> aliastype_td.realtype;
	end;
	return (tp -> tdh.form = numeric);

     end;
						/*						*/
fieldlist: proc (FIRST, POSTLAST, TAGFIELD, PACKED) returns (ptr);

dcl (FIRST, POSTLAST, TAGFIELD) ptr;
dcl PACKED bit (1);					/* true if record is packed */

dcl variant_ptr ptr;
dcl symbol_name char (32) varying;
dcl (p1, p3, p4, p5, p6) ptr;
dcl selector_field bit (1);
dcl setoffset fixed bin (35);
dcl bitstring bit (288);
dcl stringsize fixed bin (35);
dcl bstring bit (stringsize) based;
dcl case_count fixed bin (35);
dcl index fixed bin (35);

	if FIRST = null then return (null);
	if TAGFIELD = null then selector_field = "0"b;
	else do;
	     case_count = 0;			/* count of branches */
	     p3 = TAGFIELD -> not_tagval_fd.variants;
	     do while (p3 ^= null);
		case_count = case_count + 1;
check_case:
		if (p3 -> tagval_fd.nxtel ^= null) then do;
		     if p3 -> tagval_fd.nxtel -> firstfield = p3 -> tagval_fd.firstfield then do;
			p3 = p3 -> tagval_fd.nxtel;
			go to check_case;
		     end;
		end;
		p3 = p3 -> tagval_fd.nxtel;
	     end;
	     p1 = TAGFIELD -> not_tagval_fd.selectorfield;
	     if p1 = null then selector_field = "0"b;
	     else selector_field = "1"b;
	     if selector_field then do;
		symbol_name = rtrim (p1 -> tdh.name);
		if symbol_name ^= "" then call allocate_name (symbol_name, name_place);
	     end;
	     variant_ptr = current;
	     call alloc_hdr;
	     if selector_field then do;
		if symbol_name ^= "" then do;
		     call alloc_nnx;
		     call alloc_add (abs);
		     nnx_ptr -> pascal_name_next.name = fixed (rel (name_place)) - fixed (rel (symbol_ptr)) + 1;
		     if name_place -> my_symbol_token.dcl ^= 0 then do;
			work = addrel (name_place, name_place -> my_symbol_token.dcl);
			symbol_ptr -> new_runtime_symbol.next_token =
			     fixed (rel (work)) - fixed (rel (symbol_ptr));
			name_place -> my_symbol_token.dcl =
			     fixed (rel (symbol_ptr)) - fixed (rel (name_place));
		     end;
		     name_place -> my_symbol_token.dcl =
			fixed (rel (symbol_ptr)) - fixed (rel (name_place));
		end;
	     end;
	     call alloc_fbr;
	     fbr_ptr -> pascal_father_brother.father = fixed (rel (record_ptr)) - fixed (rel (symbol_ptr));
	     call alloc_slv;
	     if selector_field then do;
		call alloc_siz;
		call alloc_off;
	     end;
	     call alloc_vai (case_count);
	     p6 = TAGFIELD -> not_tagval_fd.casetype;
	     call get_var_type_info (p6, type_code, p4);
	     symbol_ptr -> pascal_symbol_node_header.type = type_code;
	     symbol_ptr -> pascal_symbol_node_header.packed = PACKED;
	     if p4 ^= null then
		symbol_ptr -> pascal_symbol_node_header.type_offset = fixed (rel (p4)) - fixed (rel (symbol_ptr));
	     stringsize = 72 * 4;
	     setoffset = 0;
	     if p4 ^= null then do;
		if p6 -> tdh.form = numeric then do;
		     setoffset = p6 -> numeric_td.nmin;
		     stringsize = p6 -> numeric_td.nmax - setoffset + 1;
		end;
		else if p6 -> tdh.form = scalar then
		     if p6 -> std.subrng = true then do;
			setoffset = p6 -> scalar_subrange_td.smin;
			stringsize = p6 -> scalar_subrange_td.smax - setoffset + 1;
		     end;
	     end;
	     else
		if type_code = pascal_boolean_dtype then do;
		stringsize = 2;
		setoffset = 0;
	     end;
	     if selector_field then do;
		off_ptr -> pascal_offset = p1 -> field_d.fldaddr;
		add_ptr -> pascal_address.units = "10"b;
		siz_ptr -> pascal_size = decode_size (p1 -> field_d.bytwidth, p6);
	     end;
	     slv_ptr -> pascal_son_level.level = 2;
	     fbr_ptr -> pascal_father_brother.father = fixed (rel (record_ptr)) - fixed (rel (variant_ptr));
	     vai_ptr -> pascal_variant_info.first_value_in_set = setoffset;
						/* loop on cases */
	     index = case_count;
	     p3 = TAGFIELD -> not_tagval_fd.variants;
	     do while (p3 ^= null);
		bitstring = "0"b;
fill_string:
		substr (bitstring, (p3 -> tagval_fd.caseval) + 1 - setoffset, 1) = "1"b;
		if p3 -> tagval_fd.nxtel ^= null then
		     if p3 -> tagval_fd.nxtel -> tagval_fd.firstfield = p3 -> tagval_fd.firstfield then do;
			p3 = p3 -> tagval_fd.nxtel;
			go to fill_string;
		     end;
		current -> bstring = addr (bitstring) -> bstring;
		vai_ptr -> pascal_variant_info.case (index).set_offset = fixed (rel (current)) - fixed (rel (variant_ptr));
		i = (stringsize + 35) / 36;
		current = addrel (current, i);
		if pascal_context_$options.bind then
		     call pascal_gen_rel_$symb (abs, i * 2);
		p6 = vai_ptr;
		p5 = fieldlist (p3 -> tagval_fd.firstfield, POSTLAST, p3 -> tagval_fd.variants, PACKED);
		if p5 ^= null then
		     p6 -> pascal_variant_info.case (index).brother = fixed (rel (p5)) - fixed (rel (variant_ptr));
		p3 = p3 -> tagval_fd.nxtel;
		vai_ptr = p6;
		index = index - 1;
	     end;
	end;
						/* list of normal fields */
	if selector_field then POSTLAST = p1;
	p3 = FIRST; p1 = null;
	p5 = null;
	do while (p3 ^= POSTLAST);
	     symbol_name = rtrim (p3 -> tdh.name);
	     if symbol_name ^= "" then call allocate_name (symbol_name, name_place);
	     call alloc_hdr;
	     if symbol_name ^= "" then do;
		call alloc_nnx;
		nnx_ptr -> pascal_name_next.name = fixed (rel (name_place)) - fixed (rel (symbol_ptr)) + 1;
		if name_place -> my_symbol_token.dcl ^= 0 then do;
		     work = addrel (name_place, name_place -> my_symbol_token.dcl);
		     symbol_ptr -> new_runtime_symbol.next_token =
			fixed (rel (work)) - fixed (rel (symbol_ptr));
		     name_place -> my_symbol_token.dcl =
			fixed (rel (symbol_ptr)) - fixed (rel (name_place));
		end;
		value = fixed (rel (symbol_ptr)) - fixed (rel (name_place));
		name_place -> my_symbol_token.dcl = value;
	     end;
	     call alloc_add (abs);
	     call alloc_fbr;
	     call alloc_slv;
	     call alloc_siz;
	     call alloc_off;
	     call get_var_type_info (p3 -> field_d.fldtype, type_code, p4);
	     symbol_ptr -> pascal_symbol_node_header.type = type_code;
	     symbol_ptr -> pascal_symbol_node_header.packed = PACKED;
	     if p4 ^= null then
		symbol_ptr -> pascal_symbol_node_header.type_offset = fixed (rel (p4)) - fixed (rel (symbol_ptr));
	     slv_ptr -> pascal_son_level.level = 2;
	     off_ptr -> pascal_offset = p3 -> field_d.fldaddr;
	     siz_ptr -> pascal_size = decode_size (p3 -> field_d.bytwidth, p3 -> field_d.fldtype);
	     add_ptr -> pascal_address.units = "10"b;
	     fbr_ptr -> pascal_father_brother.father = fixed (rel (record_ptr)) - fixed (rel (symbol_ptr));
	     if p1 ^= null then
		get_fbr (p1) -> pascal_father_brother.brother = fixed (rel (symbol_ptr)) - fixed (rel (p1));
	     else p5 = symbol_ptr;
	     p1 = symbol_ptr;
	     p3 = p3 -> field_d.nxtel;
	end;
	if TAGFIELD ^= null then
	     if p1 ^= null then
		get_fbr (p1) -> pascal_father_brother.brother = fixed (rel (variant_ptr)) - fixed (rel (p1));
	     else p5 = variant_ptr;
	POSTLAST = FIRST;
	return (p5);
     end fieldlist;
						/*						*/
alloc_add: proc (rel_info);

dcl rel_info bit (5);

	add_ptr = current;
	current = addrel (current, size (pascal_address));
	if pascal_context_$options.bind then do;
	     call pascal_gen_rel_$symb (rel_info, 1);
	     call pascal_gen_rel_$symb (abs, 1);
	end;
	symbol_ptr -> pascal_symbol_node_header.flags.address = "1"b;

     end alloc_add;


alloc_hdr: proc;

	symbol_ptr = current;
	add_ptr, btp_ptr, slv_ptr, nnx_ptr, fbr_ptr, fts_ptr, siz_ptr, off_ptr, sbl_ptr, vai_ptr, ari_ptr = null;
	current = addrel (current, size (pascal_symbol_node_header));
	if pascal_context_$options.bind then
	     call pascal_gen_rel_$symb (abs, size (pascal_symbol_node_header) * 2);

     end alloc_hdr;

alloc_btp: proc;

	btp_ptr = current;
	current = addrel (current, size (pascal_base_type_info));
	if pascal_context_$options.bind then
	     call pascal_gen_rel_$symb (abs, size (pascal_base_type_info) * 2);
	symbol_ptr -> pascal_symbol_node_header.flags.base_type_info = "1"b;

     end alloc_btp;

alloc_slv: proc;

	slv_ptr = current;
	current = addrel (current, size (pascal_son_level));
	if pascal_context_$options.bind then
	     call pascal_gen_rel_$symb (abs, size (pascal_son_level) * 2);
	symbol_ptr -> pascal_symbol_node_header.flags.son_level = "1"b;

     end alloc_slv;

alloc_nnx: proc;

	nnx_ptr = current;
	current = addrel (current, size (pascal_name_next));
	if pascal_context_$options.bind then
	     call pascal_gen_rel_$symb (abs, size (pascal_name_next) * 2);
	symbol_ptr -> pascal_symbol_node_header.flags.name_next = "1"b;

     end alloc_nnx;

alloc_fbr: proc;

	fbr_ptr = current;
	current = addrel (current, size (pascal_father_brother));
	if pascal_context_$options.bind then
	     call pascal_gen_rel_$symb (abs, size (pascal_father_brother) * 2);
	symbol_ptr -> pascal_symbol_node_header.flags.father_brother = "1"b;

     end alloc_fbr;

alloc_fts: proc;

	fts_ptr = current;
	current = addrel (current, size (pascal_father_type_successor));
	if pascal_context_$options.bind then
	     call pascal_gen_rel_$symb (abs, size (pascal_father_type_successor) * 2);
	symbol_ptr -> pascal_symbol_node_header.flags.father_type_successor = "1"b;

     end alloc_fts;

alloc_siz: proc;

	siz_ptr = current;
	current = addrel (current, size (pascal_size));
	if pascal_context_$options.bind then
	     call pascal_gen_rel_$symb (abs, size (pascal_size) * 2);
	symbol_ptr -> pascal_symbol_node_header.flags.size = "1"b;

     end alloc_siz;

alloc_off: proc;

	off_ptr = current;
	current = addrel (current, size (pascal_offset));
	if pascal_context_$options.bind then
	     call pascal_gen_rel_$symb (abs, size (pascal_offset) * 2);
	symbol_ptr -> pascal_symbol_node_header.flags.offset = "1"b;

     end alloc_off;

alloc_sbl: proc;

	sbl_ptr = current;
	current = addrel (current, size (pascal_subrange_limits));
	if pascal_context_$options.bind then
	     call pascal_gen_rel_$symb (abs, size (pascal_subrange_limits) * 2);
	symbol_ptr -> pascal_symbol_node_header.flags.subrange_limits = "1"b;

     end alloc_sbl;

alloc_vai: proc (dims);

dcl dims fixed bin (35);
dcl i fixed bin (35);

	vai_ptr = current;
	vai_ptr -> pascal_variant_info.number_of_variants, nvariants = dims;
	i = size (vai_ptr -> pascal_variant_info);
	current = addrel (current, i);
	if pascal_context_$options.bind then
	     call pascal_gen_rel_$symb (abs, i * 2);
	symbol_ptr -> pascal_symbol_node_header.variant_info = "1"b;

     end alloc_vai;

alloc_ari: proc (dims);

dcl dims fixed bin (35);
dcl i fixed bin (35);

	ari_ptr = current;
	ari_ptr -> pascal_array_info.ndims, nd = dims;
	i = size (ari_ptr -> pascal_array_info);
	current = addrel (current, i);
	if pascal_context_$options.bind then
	     call pascal_gen_rel_$symb (abs, i * 2);
	symbol_ptr -> pascal_symbol_node_header.array_info = "1"b;

     end alloc_ari;


     end get_symbol_block;

%page;
get_proc_type: proc (TP, type_ptr);

dcl TP ptr;					/* (input) ptr to compiler proc box */
dcl type_ptr ptr;					/* (output) ptr to type symbol node */

/* create procedure type description */
dcl (work, p4, p5, p6, p7) ptr;
dcl type_code fixed bin (35);
dcl symbol_ptr ptr;
dcl (btp_ptr, nnx_ptr, siz_ptr, fbr_ptr, slv_ptr) ptr;

	if TP -> proc_d.ptypesymbolplace ^= null then do;
	     type_ptr = TP -> proc_d.ptypesymbolplace;
	     return;
	end;

	type_ptr,
	     TP -> proc_d.ptypesymbolplace = current;
	symbol_ptr = current;
	current = addrel (current, size (pascal_symbol_node_header));
	symbol_ptr -> pascal_symbol_node_header.type = pascal_procedure_type_dtype;
	if TP -> proc_d.proctype ^= TP then do;		/* is a function */
	     btp_ptr = current;
	     current = addrel (current, size (pascal_base_type_info));
	     symbol_ptr -> pascal_symbol_node_header.flags.base_type_info = "1"b;
	end;
	if TP -> proc_d.formals ^= null then do;	/* has parameters */
	     slv_ptr = current;
	     current = addrel (current, size (pascal_son_level));
	     symbol_ptr -> pascal_symbol_node_header.flags.son_level = "1"b;
	end;
	if pascal_context_$options.bind then
	     call pascal_gen_rel_$symb (abs, 2 * (fixed (rel (current)) - fixed (rel (symbol_ptr))));
	if TP -> proc_d.proctype ^= TP then do;		/* is a function */
	     call get_var_type_info (TP -> proc_d.proctype, type_code, work);
	     btp_ptr -> pascal_base_type_info.base_type = type_code;
	     if work ^= null then
		btp_ptr -> pascal_base_type_info.base_type_offset = fixed (rel (work)) - fixed (rel (symbol_ptr));
	end;
	p4 = TP -> proc_d.formals;
	if p4 ^= null then do;
	     p5 = symbol_ptr;
	     slv_ptr -> pascal_son_level.son = fixed (rel (current)) - fixed (rel (symbol_ptr));
	     fbr_ptr = null;
next_formal_parameter:
	     if p4 -> tdh.klass = vars then
		if p4 -> var_d.vkind = arraybound then /* skip it */
		     if p4 -> cth.nxtel = null then do;
			if fbr_ptr ^= null then
			     fbr_ptr -> pascal_father_brother.brother = 0;
			go to end_of_params;
		     end;
		     else do;
			p4 = p4 -> cth.nxtel;
			go to next_formal_parameter;
		     end;
	     symbol_ptr = current;
	     current = addrel (current, size (pascal_symbol_node_header));
	     nnx_ptr = current;
	     current = addrel (current, size (pascal_name_next));
	     symbol_ptr -> pascal_symbol_node_header.flags.name_next = "1"b;
	     if p4 -> tdh.klass ^= proc then do;
		btp_ptr = current;
		current = addrel (current, size (pascal_base_type_info));
		symbol_ptr -> pascal_symbol_node_header.flags.base_type_info = "1"b;
	     end;
	     else btp_ptr = null;
	     fbr_ptr = current;
	     current = addrel (current, size (pascal_father_brother));
	     symbol_ptr -> pascal_symbol_node_header.flags.father_brother = "1"b;
	     siz_ptr = current;
	     current = addrel (current, size (pascal_size));
	     symbol_ptr -> pascal_symbol_node_header.flags.size = "1"b;
	     if pascal_context_$options.bind then
		call pascal_gen_rel_$symb (abs, 2 * (fixed (rel (current)) - fixed (rel (symbol_ptr))));
	     if p4 -> tdh.klass = proc then do;
		symbol_ptr -> pascal_symbol_node_header.type = pascal_entry_formal_parameter_dtype;
		siz_ptr -> pascal_size = pascal_parameter_proc_size;
		call get_proc_type (p4, p6);
		symbol_ptr -> pascal_symbol_node_header.type_offset = fixed (rel (p6)) - fixed (rel (symbol_ptr));
	     end;
	     else do;
		if p4 -> var_d.varparam = true then
		     symbol_ptr -> pascal_symbol_node_header.type = pascal_variable_formal_parameter_dtype;
		else
		     symbol_ptr -> pascal_symbol_node_header.type = pascal_value_formal_parameter_dtype;
		siz_ptr -> pascal_size = decode_size (p4 -> var_d.vtype -> tdh.size, p4 -> var_d.vtype);
		call get_var_type_info (p4 -> var_d.vtype, type_code, work);
		btp_ptr -> pascal_base_type_info.base_type = type_code;
		if work ^= null then
		     btp_ptr -> pascal_base_type_info.base_type_offset = fixed (rel (work)) - fixed (rel (symbol_ptr));
	     end;
	     call allocate_name (rtrim (p4 -> cth.name), p7);
	     nnx_ptr -> pascal_name_next.name = fixed (rel (p7)) + 1 - fixed (rel (symbol_ptr));
	     fbr_ptr -> pascal_father_brother.father = fixed (rel (p5)) - fixed (rel (symbol_ptr));
	     if p4 -> cth.nxtel ^= null then do;
		fbr_ptr -> pascal_father_brother.brother = fixed (rel (current)) - fixed (rel (symbol_ptr));
		p4 = p4 -> cth.nxtel;
		go to next_formal_parameter;
	     end;
end_of_params:
	end;


     end get_proc_type;
     end create_level_tables;

/* INCLUDE FILES */
%include pascal_context_;
%include pascal_loc_class_codes;
%include pascal_context_table;
%include runtime_symbol;
%include std_descriptor_types;
%include std_symbol_header;
%include entry_sequence_info;
%include arg_descriptor;
%include runtime_symbol_block;
%include linkdcl;
%include runtime_block_type;
%include pascal_symbol_node;
%include pascal_gen_constants;
%include pascal_ref_info;
%include pascal_call_trap_info;
     end pascal_create_tables;
