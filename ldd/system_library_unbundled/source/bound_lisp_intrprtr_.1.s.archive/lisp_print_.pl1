/* **************************************************************
   *                                                            *
   * Copyright, (C) Massachusetts Institute of Technology, 1973 *
   *                                                            *
   ************************************************************** */
print:	proc;


/* This segment contains all of the LISP formatting and output
   routines.  Coded 6/7/72, by D. Reed */
/* changed to detect ctrlr_no_uwrite error, 9 Sep 72 by DAM */
/* changed to not insert extra newlines on output to file, DAM 1 Nov 72
     and to format floating point numbers using danb's convert_sfl_ instead of the
     char builtin */
/* bignums added, dam, 13 jan 73 */
/* changed for (status _) and (status terpri), dam, 12 FEB 1973 */
/* changed for new I/O system, 22 Mar 1973 by DAM */
/* status_terpri, status_underline moved into readtable, 7 Apr 73 by DAM */
/* modified for new syntax bits, new iochan format 73.10.24 by DAM */
/* Modified 74.03.16 by DAM to use EIS, to support abbreviation,
   and to be more efficient and easier to read */
/* modified 74.05.16 by DAM for new array stuff */
/* modified 74.09.21 by DAM to accept t for tty as well as nil */
/* modified 74.12.09 by DAM for external arrays */


	/* FLAGS */

dcl (printing,		/* 1 => output to files, 0 => explode */
     slashing,		/* 1 => slash special characters, 0 => output as is */
     begin_with_nl,		/* 1 => is print rather than prin1 or princ, need NL at beginning */
     dest1,		/* stack -> temp(2) is a file */
     destl,		/* stack -> temp(2) is a list of files */
     explicit_tty,		/* (print foo t) flag - ignore ^w */
     send_to_tty,		/* output should go to tty */
     send_to_files,		/* output should go to one or more files */
     abbreving_flag,	/* 1=> this buffer is sharp sign or dot dot dot */
     abbreved_out_flag,	/* 1=> this buffer shouldn't go to abbreving destinations */
     someone_gets_abbreved,	/* 1=> there is some abbreviated destination */
     someone_gets_unabbreved, /* 1=> there is some unabbreviated destination */
     abbrev_on_files,		/* 1=> output to files should be abbreviated,
			   0=> only output to terminal should be abbreviated */
     check_prinlevel,
     check_prinlength,
     explodensw,
     flatsw) bit(1) aligned,	
    code fixed bin,
    nargs fixed bin,
    newline char(1) static init("
"),
    space char(1) static init(" "),
    quote char(1) static init(""""),
    left_paren char(1) static init("("),
    right_paren char(1) static init(")"),
    sharp_sign char(1) static init("#"),
    dot_dot_dot char(3) static init("..."),
    sharp_sign_buffer char(1) varying static init("#"),
    dot_dot_dot_buffer char(4) varying static init("...)"),
    dot char(1) static init("."),
    lisp_io_control_$end_of_block entry(ptr, fixed bin(71), fixed bin),
    lisp_io_control_$fix_not_ok_iochan entry(ptr, bit(1) aligned) returns (bit(1) aligned),
    lisp_io_fns_$namestring entry,
    i fixed bin,
    j fixed bin,
    idx fixed bin,
    Ch1 char(1) aligned,
    Ch2 char(1) aligned,
    Ch1_syntax bit(27) aligned,
    Ch2_syntax bit(27) aligned,
    nelemt fixed bin,
    cruft fixed bin(71),
    errcode(2) fixed bin based aligned,		/* structure for lisp_error_ */
    len fixed bin,
    lisp_static_vars_$outfiles fixed bin(71) aligned external,
    outfiles fixed bin(71) def (lisp_static_vars_$outfiles),
    lisp_error_ entry,
    lisp_get_atom_ entry(char(*) aligned, fixed bin(71)),
    lisp_$apply entry,
    lisp_property_fns_$get entry,
    io_buffer char(262143) based aligned;

	/* declarations for abbreviation feature */

dcl (prinlevel, prinlength) fixed bin(35),
    (lisp_static_vars_$prinlevel, lisp_static_vars_$prinlength) external pointer,
    curlevel fixed bin(35),
    curlength fixed bin(35);

	/* structure pushed on by pdl by recursion to print a list */

dcl 1 list_save aligned based structure,
    2 saved_reti fixed bin,
    2 saved_curlength fixed bin(35);

	/* SPECIAL CHARACTERS (format effectors) */

dcl backspace char(1) static init(""),
    tab char(1) static init("	"),
    carriage_return char(1) static init(""),
    newpage char(1) static init(""),
    format_effectors char(5) static init("	
");	/* BS, HT, NL, CR, NP */


	/* STUFF IN STACKS */

dcl stack ptr,			/* -> lowest stuff in stack (initially args).
				   stack -> temp(1) is data to output.
					later is explode list or flatsize count.
				   stack -> temp(2) is file or list of files (see dest1, destl flags.) */
    tstack ptr,			/* -> top four cells in stack.
				   tstack -> temp(1) = data being printed.
				   tstack -> temp(2) = I/O temporary.
				   tstack -> temp(3) = file outputting on (in I/O routine) */
    the_array_pointer pointer,
    unm ptr,			/* -> stuff on unmarked pdl */
    unmp ptr,			/* -> special stuff pushed on unmarked pdl for error */
    bufp pointer,			/* -> output buffer in unmarked pdl */
    saved_bufp pointer,		/* saved copy of bufp (used by abbrev hacks) */
    buffer char(262143) varying based(bufp),	/* output buffer */
					/* note this can't be 262144 long or formline_ thinks it is zero */
    bufmaxl fixed bin(18),		/* number of chars in buffer protected by unmkd_ptr.
				   must be an odd multiple of 4 (double word alignment) */
    bufminl fixed bin(18) static init(76);	/* minimum value of bufmaxl */

dcl type_field bit(36) aligned,
    reti fixed bin,		/* return index */
    radix fixed bin,		/* output radix for fixed point numbers */
    tempd fixed bin(40),		/* enough precision to handle worst case */
    numbuff(36) char(1) unaligned,	/* char array for formatting numbers */
    lisp_special_fns_$cons entry,
    lisp_list_utils_$nreverse entry,
    lisp_alloc_ entry(fixed bin, fixed bin(71) aligned),
    (null, addr, addrel, substr, collate, divide, hbound, lbound, mod, binary,
	char, length, unspec, size, string, before, search, index) builtin;

dcl 1 a_lisp_datum aligned based structure,
    2 (word1, word2) bit(36),

    1 overlay_on_lisp_datum aligned based,
      2 octal_byte(24) bit(3) unaligned;

	/* dcl for bignums */

dcl left_arrow fixed bin,			/* for output of 4000000 in form 4_18. */
    bit36 bit(36) aligned,
    DigitSet char(36) static init("0123456789abcdefghijklmnopqrstuvwxyz"),
    dpw fixed bin,
    wd fixed bin (35),
    lisp_bignums_$bnprint entry,
   1 bnprintargs aligned based (unm),		/* argument list for lisp_bignums_$bnprint, on unmkd pdl */
     2 array ptr,				    /* ptr to array of fixnums (return) */
     2 size fixed bin,			    /* size of array of fixnums (return) */
     2 rad fixed bin(35),			    /* big radix */
    bndigs (1:bnprintargs.size) fixed bin(35) aligned based(bnprintargs.array);  /* the array of digits in base bigradix */

%include lisp_bignum_fmt;
%include lisp_bignum_io_data;
%include lisp_ptr_fmt;
%include lisp_name_codes;
%include lisp_stack_fmt;
%include lisp_common_vars;
%include lisp_readtable;
%include lisp_array_fmt;

dcl slash_suppressors bit(27) static init(	/* syntax that in 2nd char can suppress
					   slashing of first char in pname */
     "000000000000000000001001011"b);	/* slash_if_not_first|plus_minus|extd_alpha|alpha */

%include lisp_nums;
%include lisp_cons_fmt;
%include lisp_atom_fmt;
%include lisp_string_fmt;
%include lisp_io;
%include lisp_error_codes;




/* print: proc; */


	slashing, begin_with_nl = "1"b;		/* options peculiar to print */
	go to prin_com;

prin1:	entry;

	slashing = "1"b;			/* formatted but no nl */
	go to prin1_com;

princ:	entry;

	slashing = "0"b;			/* no formatting other than whitespace */

prin1_com:begin_with_nl = "0"b;
prin_com:	printing = "1"b;			/* actual output to be done */
	flatsw = "0"b;			/* not doing flatsize, flatc */
	call get_dest_subr;			/* find out where output is to be sent */
	go to print_common;			/* go join common code, stack already set */

/*
 * The above entries are the old subr versions retained because they are called internally.
 * The following entries are the new, lsubr versions.
 */

print_:	entry;

	slashing, begin_with_nl = "1"b;
	go to prin_com_;

prin1_:	entry;

	slashing = "1"b;
	go to prin1_com_;

princ_:	entry;

	slashing = "0"b;

prin1_com_:
	begin_with_nl = "0"b;
prin_com_:
	printing = "1"b;
	flatsw = "0"b;
	call get_dest;
	go to print_common;



explode:	entry;

	slashing = "1"b;
	go to explodecom;

explodec:	entry;

	slashing = "0"b;			/* no formatting */
explodecom:
	explodensw = "0"b;
	go to explode1;

exploden:	entry;

	explodensw = "1"b;
	slashing = "0"b;
explode1:	printing = "0"b;
	flatsw = "0"b;
	stack = addrel(stack_ptr, -2);
	call set_up_buffer;
	go to print_common;

flatsize:	entry;

	slashing = "1"b;
	go to flatcom;

flatc:	entry;

	slashing = "0"b;
flatcom:	flatsw = "1"b;
	printing = "0"b;
	stack = addrel(stack_ptr, -2);
	call set_up_buffer;
	go to print_common;

tyo:	entry;

	abbreving_flag, abbreved_out_flag, abbrev_on_files = "0"b;	/* don't try to abbreviate */
	call get_dest;
tyo_restart:
	if stack -> fixnum_fmt.type_info ^= fixnum_type then go to bad_tyo;
	if stack -> fixedb > 511 then go to bad_tyo;
	if stack -> fixedb < 0 then go to bad_tyo;
	printing = "1"b;
	buffer = byte (stack -> fixedb);
	call send_the_buffer;
	call flush_buffers;
	go to exit;

bad_tyo:
	unm = unmkd_ptr;			/* get room on unmkd_stack for error info */
	unmkd_ptr = addrel(unm,2);
	unm -> errcode(1) = bad_arg_correctable;
	unm -> errcode(2) = fn_tyo;
	tstack -> temp(3) = stack -> temp(1);
	call lisp_error_;
	stack -> temp(1) = tstack -> temp(3);
	go to tyo_restart;			/* come back and try again */


type_string: entry(string_to_be_typed_out);

dcl string_to_be_typed_out char(*) aligned;

	abbreving_flag, abbreved_out_flag, abbrev_on_files = "0"b;	/* don't try to abbreviate */
	call get_dest_non_lsubr;

	if length(string_to_be_typed_out) > bufmaxl
	then do;		/* need bigger buffer */
	     bufmaxl = 8*divide(length(string_to_be_typed_out)+3, 8, 18, 0) + 4;	/* double word alignment */
	     unmkd_ptr = addrel(bufp, divide(bufmaxl, 4, 18, 0)+1);
	     end;

	buffer = string_to_be_typed_out;
	call send_the_buffer;
	call flush_buffers;
	stack_ptr = stack;
	unmkd_ptr = unm;
	return;


terpri:	entry;			/* terpri as lsubr (0 . 1) */

	abbreving_flag, abbreved_out_flag, abbrev_on_files = "0"b;	/* don't try to abbreviate */
	call get_dest_4_terpri;		/* special variant of get_dest */
	printing = "1"b;
	buffer = newline;
	call send_the_buffer;
	call flush_buffers;
	stack_ptr = addr(stack -> temp(2));
	unmkd_ptr = unm;
	stack -> temp(1) = nil;			/* return nil*/
	return;

type_nl:	entry;

	abbreving_flag, abbreved_out_flag, abbrev_on_files = "0"b;	/* don't try to abbreviate */
	call get_dest_non_lsubr;
	buffer = newline;
	call send_the_buffer;
	call flush_buffers;
	stack_ptr = stack;
	unmkd_ptr = unm;
	return;


print_common:				/* all code for formatting lisp objects starts here */

	/* Make sure the readtable has not been munged */

	if addr(
	     addr(readtable)->based_ptr -> atom.value)
		-> lisp_ptr_type & Array36 then;
	  else go to bad_readtable;	/* not an array */

	/* its an array, make sure it was made by makreadtable */

	if addr(readtable)->based_ptr -> atom_ptrs.value -> array_info.type ^= Readtable_array
	then go to bad_readtable;

	prinlevel = lisp_static_vars_$prinlevel -> fixedb;
	prinlength = lisp_static_vars_$prinlength -> fixedb;
	if lisp_static_vars_$prinlevel -> fixnum_fmt.type_info = fixnum_type
	then check_prinlevel = "1"b;
	else check_prinlevel = "0"b;
	if lisp_static_vars_$prinlength -> fixnum_fmt.type_info = fixnum_type
	then check_prinlength = "1"b;
	else check_prinlength = "0"b;

	curlevel = 0;
	abbreving_flag, abbreved_out_flag = "0"b;
	abbrev_on_files = abbreviate_on_files;
	if ^ printing
	   then if abbreviate_on_flat
	           then do;
			someone_gets_abbreved = "1"b;
			someone_gets_unabbreved = "0"b;
			end;
		 else do;
			someone_gets_abbreved = "0"b;
			someone_gets_unabbreved = "1"b;
			end;
	   else do;
		someone_gets_abbreved = "1"b;
		if ^ send_to_files then someone_gets_unabbreved = "0"b;
		else if abbrev_on_files then someone_gets_unabbreved = "0"b;
		else someone_gets_unabbreved = "1"b;
		end;

	if ^ someone_gets_abbreved then check_prinlevel, check_prinlength = "0"b;

	reti = 0;			/* set transfer vector return index */

	tstack -> temp(1) = stack -> temp(1);		/* first argument to print loop */

	if ^printing
	then if flatsw
	     then do;			/* set count of printable characters */
		     stack -> fixnum_fmt.type_info = fixnum_type;
		     stack -> fixedb = 0;
		end;
	     else stack -> temp(1) = nil;	/* list of characters, later to be reversed */
	else if begin_with_nl
	     then do;
		buffer = newline;
		call send_the_buffer;
		end;

print_loop:				/* main printing loop, pseudo-recursive function */

	type_field = tstack -> temp_type36(1);	/* get type to branch on */
	if type_field = fixnum_type then go to format_fixed;
	if type_field = flonum_type then go to format_float;
	if type_field & Bigfix36 then go to format_big;
	if type_field & Atsym36 then go to format_symbol;
	if type_field & String36 then go to format_string;
	if type_field & File36 then go to format_file_object;
	if type_field & Array36 then go to format_array_pointer;
	if tstack -> temp_type(1) then go to format_random;	/* got screwed up type */
	if tstack -> lisp_ptr.itsmod ^= "100011"b then go to format_random;
	if substr(tstack -> a_lisp_datum.word2, 19, 18) ^= ""b then go to format_random;

	/* not an atomic type, so print list format, by recursing */

	/* have to move the buffer so can save return address */

	bufp = addrel(unm, 2);
	bufmaxl = bufminl;
	unmkd_ptr = addrel(bufp, 1+divide(bufminl,4,18,0));
	unm -> saved_reti = reti;
	unm -> saved_curlength = curlength;
	unm = bufp;
	curlength = 0;
	curlevel = curlevel + 1;
	if check_prinlevel
	then if curlevel > prinlevel
	     then do;		/* abbreviation hacks */
		if ^ abbreved_out_flag
		then do;		/* have to put a sharp sign */
		     abbreving_flag = "1"b;
		     saved_bufp = bufp;
		     bufp = addr(sharp_sign_buffer);
		     call send_the_buffer;
		     bufp = saved_bufp;
		     abbreving_flag = "0"b;
		     if ^ someone_gets_unabbreved then go to rest_of_list_suppressed;	/* make explode work right */
		     end;
		abbreved_out_flag = "1"b;
		end;

	/* begin the list with a left parenthesis */

	buffer = left_paren;
	call send_the_buffer;

list_loop:tstack -> temp(2) = tstack -> temp_ptr(1) -> cons.car;
	tstack -> temp(1) = tstack -> temp_ptr(1) -> cons.cdr;	/* next list element */
	tstack = addr(tstack -> temp(2));			/* recursively print list item */
	stack_ptr = addr(tstack -> temp(4));
	reti = 1;							/* return for list routine */
	curlength = curlength + 1;
	if check_prinlength
	then if curlength > prinlength
	     then do;	/* abbreviation */
		if ^ abbreved_out_flag
		then do;
		     abbreving_flag = "1"b;	/* have to put a dot dot dot */
		     saved_bufp = bufp;
		     bufp = addr(dot_dot_dot_buffer);
		     call send_the_buffer;
		     bufp = saved_bufp;
		     abbreving_flag = "0"b;
		     abbreved_out_flag = "1"b;
		     if ^ someone_gets_unabbreved		/* try not to loop on circular lists */
		     then do;
			tstack = addrel(tstack, -2);
			go to rest_of_list_suppressed;
			end;
		     end;
		end;

	if ^ abbreved_out_flag then go to print_loop;		/* print car of list */
	else if someone_gets_unabbreved then go to print_loop;
	else;			/* no need to recurse because no one will see it anyway */

print_ret(1):	/* return from printing one list element */
	tstack = addrel(tstack,-2);				/* back down stack */
	if tstack -> temp(1) = nil then go to print_ret(2);		/* end of list */
	else if tstack -> temp_type(1)
	     then do;
non_nil_end:	buffer = " . ";		/* dotted pair dot */
		call send_the_buffer;
		reti = 2;					/* for end of list */
		stack_ptr = addr (tstack -> temp (4));
		go to print_loop;
		end;

	else if tstack -> lisp_ptr.itsmod ^= "100011"b then go to non_nil_end;

	else do;					/* have another atom here */
	     buffer = space;
	     call send_the_buffer;
	     go to list_loop;
	     end;

print_ret(2):	/* return from printing a list */

	buffer = right_paren;
	call send_the_buffer;

rest_of_list_suppressed:
	/* pop the stack.  again, must re-allocate buffer slightly */

	unm = addrel(unm,-2);
	bufp = unm;
	bufmaxl = bufmaxl + 8;		/* 8 more chars are protected */
	reti = unm -> saved_reti;
	curlength = unm -> saved_curlength;
	curlevel = curlevel - 1;

	/* turn off abbreved_out_flag if we are now back in un abbreved region */

	if check_prinlevel then if curlevel > prinlevel then go to keep_on_abbreving;
	if check_prinlength then if curlength > prinlength then go to keep_on_abbreving;
	abbreved_out_flag = "0"b;
keep_on_abbreving:

	go to print_ret(reti);

print_ret(0):	/* return from printing the whole thing */

	if printing
	then do;
	     if begin_with_nl then do;
		buffer = space;			/* print, want space after the output */
		call send_the_buffer;
		end;
	     call flush_buffers;
	     end;
exit:	stack_ptr = addr(stack -> temp(2));
	unmkd_ptr = unm;				/* pop back unmkd stack */
	if ^printing then if ^flatsw then call lisp_list_utils_$nreverse;		/* zap list to reverse of self */
			else;
	else stack->temp(1) = t_atom;
	return;


format_big:	/* format a fixed point bignum */

	call get_radix;

	/* convert the bignum to an array of small nums which are digits to some big radix, namely
		the largest possible power of the output radix that fits in 35 bits */

	dpw = digsperwd(radix);
	unmkd_ptr = addrel(unm, size(bnprintargs));	/* make arg list for lisp_bignums_$bnprint */
	tstack -> temp(3) = tstack -> temp(1);	/* copy argument */
	bnprintargs.rad = bigradix(radix);
	call lisp_bignums_$bnprint;
	stack_ptr = addr(tstack -> temp(4));	/* lisp_bignums_ mungs stack */

	/* now put buffer above bnprintargs on stack */

	bufp = unmkd_ptr;				/* allocate buffer above bnprintargs and bndigs */
	bufmaxl = bufminl;
	unmkd_ptr = addrel(bufp, 1+divide(bufminl,4,18,0));

	/* set sign into buffer */

	if tstack -> temp_ptr(1) -> lisp_bignum.sign
	then buffer = "-";
	else if radix <= 10 then buffer = "";	/* omit + usually */
	     else buffer = "+";		/* but if wierd base indicate is number not atom */

	/* expand each of these fixnums into digits */

	do j = hbound(bndigs, 1) to lbound(bndigs, 1) by -1;
	     wd = bndigs(j);			/* next word to be expanded into digits */
	     do i = 35 by -1 to 36-dpw;
		idx = divide(wd, radix, 35, 0);
		code = binary(wd, 40) - binary(radix*idx, 40);
		numbuff(i+1) = substr(DigitSet, code+1, 1);
		if idx = 0 then if j = hbound(bndigs, 1) then go to done_bfx;	/* suppress leading zeroes for
									   first word only */
		wd = idx;
		end;
	     i = 36-dpw;
done_bfx:	     if length(buffer) + 36 - i + 1 > bufmaxl then do;	/* grow buffer */
							/* extra +1 is for decimal point. */
			bufmaxl = 4 + 8*divide(length(buffer) + 36 - i - 4 + 7, 8, 18, 0);
			unmkd_ptr = addrel(bufp, 1+divide(bufmaxl, 4, 18, 0));
			end;
	    buffer = buffer || substr(string(numbuff), i+1);
	    end;
	left_arrow = 0;
	go to point;			/* maybe add decimal point at end */

get_radix: proc;

retry:	if addr(base) -> based_ptr -> fixnum_fmt.type_info ^= fixnum_type
	then go to bad_radix;

	radix = addr(base) -> based_ptr -> fixedb;

	if radix < 2 then go to bad_radix;
	if radix > 36 then go to bad_radix;
	return;		/* good radix */

bad_radix:unmp = unmkd_ptr;			/* get room to pass error code */
	unmkd_ptr = addrel(unmp, 2);
	unmp -> errcode(1) = bad_base;
	call lisp_error_;			/* signal error */
	go to retry;

end get_radix;





format_fixed:			/* format a fixed point number */

	buffer = "";
	call get_radix;

	if tstack -> fixedb < 0
	then buffer = "-";			/* put minus sign */
	else do;
	     tstack -> fixedb = - tstack -> fixedb;	/* uniform negative conversion */
	     if radix > 10
	     then buffer = "+";		/* to indicate number in wierd base */
	     end;


	/* print numbers with 18, 24, or 30 trailing zeroes with the _ (left arrow) notation */

	left_arrow = 0;
	if tstack -> fixedb ^= 0 then
	  if radix = 8 then goto underline_hackery;			/* only use this format for octal output */
	   else if ^ status_underline then
underline_hackery:
		/* may be allowed to use the xx_yy. output format */

	   if read_table.syntax(95) = "000000000000110010"b then do;	/* only if syntax of _ is standard */
	     bit36 = unspec(tstack -> fixedb);	/* look at the number to be printed */
	     if substr(bit36, 2, 35) = ""b then do;
		left_arrow = 35;
		tstack -> fixedb = -1;			/* must be 400000000000 */
		end;
	     else if substr(bit36, 7, 30) = ""b then do;
		left_arrow = 30;
		unspec(tstack -> fixedb) = (30)"1"b||bit36;   /* qrs 30 */
		end;
	     else if substr(bit36, 13, 24) = ""b then do;
		left_arrow = 24;
		unspec(tstack -> fixedb) = (24)"1"b||bit36;	/* qrs 24 */
		end;
	     else if substr(bit36, 19, 18) = ""b then do;
		left_arrow = 18;
		unspec(tstack -> fixedb) = (18)"1"b||bit36;	/* qrs 18 */
		end;
	     end;

pnum:	do i = 35 by -1;				/* convert number */
	     idx = divide(tstack->fixedb,radix,35,0);
	     tempd = radix*idx;
	     code = tempd - binary(tstack->fixedb,40,0);
	     numbuff(i+1) = substr(DigitSet,code+1,1);
	     if idx = 0 then go to done_num;
	     tstack -> fixedb = idx;
	end;

done_num: buffer = buffer || substr(string(numbuff), i+1);

	/* buffer contains number.  append "." and "_" frobs if necessary, then output */

point:	if radix = 10				/* add decimal point? */
	then if addr(stnopoint)->based_ptr->atom.value = nil
	     then buffer = buffer || ".";

	if left_arrow ^= 0 then do;			/* print _ and the shift factor in decimal */
	     buffer = buffer || "_";
	     tstack -> fixedb = -left_arrow;	/* = shift factor */
	     left_arrow = 0;			/* prevent recursion */
	     if addr(stnopoint)->based_ptr -> atom.value = nil then radix = 10;	/* put shift factor in decimal if possible */
	     go to pnum;
	     end;

	/* whole number is now in buffer.  put it out, empty the stack (in case of bignum), and return */

	call send_the_buffer;
	bufp = unm;
	bufmaxl = bufminl;
	unmkd_ptr = addrel(bufp, 1+divide(bufminl,4,18,0));
	go to print_ret(reti);



format_float:		/* format a floating point number */

/**dcl numeric_to_ascii_ entry(float decimal(59), fixed bin, char(262144) varying);
/**		/* note return parameter's length is misdeclared.  This won't hurt anything because it is declared longer than it should be */
/**
/**	call numeric_to_ascii_((tstack -> floatb), 8, buffer);		/* do the conversion */
/**	if index(buffer, ".") = 0 then buffer = buffer || ".0";	/* disallow integer format */

	/* above code replaced by the following */

dcl lisp_flonum_conversion_ entry(1 aligned structure like arg_str);

dcl 1 arg_str aligned structure,
      2 flonum float bin(27),
      2 bufp unaligned pointer,
      2 temps_for_the_alm_code,
        3 mantissa fixed bin(27),
        3 exponent fixed bin(8),
        3 dec_temp float decimal(10),
        3 dec_exp float decimal(10),
        3 dbl_temp fixed bin(71);

	arg_str.flonum = tstack -> floatb;
	arg_str.bufp = bufp;
	call lisp_flonum_conversion_(arg_str);	/* use eis instructions to convert nicely */

	call send_the_buffer;

	go to print_ret(reti);




	/* format an array pointer giving type, bounds, and address */

dcl array_type fixed bin,
    array_type_name (0:6) char(12) varying static init(
	"array", "nil", "fixnum", "flonum", "readtable", "obarray", "dead-array");

format_array_pointer:

	buffer = sharp_sign;
	if tstack -> temp_ptr(1) -> array_info.minus_2_times_ndims = 0 then go to format_external_array_pointer_differently;
	array_type = tstack -> temp_ptr(1) -> array_info.type;
	if array_type < 0 then go to format_random;
	if array_type > 6 then go to format_random;
	buffer = buffer || array_type_name(array_type);
	if array_type ^= Dead_array then do;		/* put bounds */
	   Ch1 = "-";				/* character to go before bound */
	   do i = 1 to tstack -> temp_ptr(1) -> array_info.ndims;
	      buffer = buffer || Ch1;
	      Ch1 = ":";				/* character to go before next bound */
	      tempd = tstack -> temp_ptr(1) -> array_info.array_data_ptr ->
			array_data.dope_vector(i-tstack -> temp_ptr(1) -> array_info.ndims).bounds;
	      do idx = 36 repeat (idx-1);
	         j = divide(tempd, 10, 35, 0);
	         numbuff(idx) = substr(DigitSet, tempd-10*j+1, 1);
	         tempd = j;
	         if tempd = 0 then go to format_array_exitloop;
	         end;
format_array_exitloop:
	      if length(buffer)+36-idx+1+15 > bufmaxl then do;	/* get room for this number + all cruft after it */
		bufmaxl = 4 + 8*divide(length(buffer)+36-idx+1+15-4+7, 8, 18, 0);
		unmkd_ptr = addrel(bufp, 1+divide(bufmaxl, 4, 18, 0));
		end;
	      buffer = buffer || substr(string(numbuff), idx, 36-idx+1);
	      end;
	   end;

	/* put address of array_info block */

	the_array_pointer = tstack -> temp_ptr(1);
	buffer = buffer || "-";

format_array_pointer_address:
	j = fixed(baseno(the_array_pointer), 18);
	do idx = 36 by -1;		/* until j=0 */
	   i = divide(j,8,17,0);
	   numbuff(idx) = substr(DigitSet, j-8*i+1, 1);
	   j = i;
	   if j = 0 then go to endloop_0001;
	   end;
endloop_0001:
	buffer = buffer || substr(string(numbuff), idx, 36-idx+1);
	buffer = buffer || "|";

	j = fixed(rel(the_array_pointer), 18);
	do idx = 36 by -1;		/* until j=0 */
	   i = divide(j, 8, 17, 0);
	   numbuff(idx) = substr(DigitSet, j-8*i+1, 1);
	   j = i;
	   if j = 0 then go to endloop_0002;
	   end;
endloop_0002:
	buffer = buffer || substr(string(numbuff), idx, 36-idx+1);

	call send_the_buffer;
	go to print_ret(reti);

format_external_array_pointer_differently:

	buffer = buffer || "external@";
	the_array_pointer = tstack -> temp_ptr(1) -> array_info.array_data_ptr;
	go to format_array_pointer_address;

	/* format a file object -- sharp sign and the path name */

format_file_object:
	if addr(tstack -> temp_ptr(1) -> iochan.namelist)->lisp_ptr.type ^= Cons
			then go to format_random;		/* don't want a wta-barf here, since would loop! */
	tstack -> temp(1) = tstack -> temp_ptr(1) -> iochan.namelist;	/* get namelist, and make into a string */
	stack_ptr = addr(tstack -> temp(2));
	call lisp_io_fns_$namestring;			/* get name of this file as a lisp string */
	stack_ptr = addr(tstack -> temp(4));
	if 1 + tstack -> temp_ptr(1) -> lisp_string.string_length > bufmaxl
	then do;		/* allocate more buffer */
	     bufmaxl = 4 + 8*divide(tstack -> temp_ptr(1) -> lisp_string.string_length + 1 - 4 + 7, 8, 18, 0);
	     unmkd_ptr = addrel(bufp, 1+divide(bufmaxl, 4, 18, 0));
	     end;
	buffer = sharp_sign;
	buffer = buffer || tstack -> temp_ptr(1) -> lisp_string.string;
	call send_the_buffer;
	go to print_ret(reti);

format_string:		/* print string value */

	if ^slashing then do;		/* easy case, just ship it out */

		if tstack -> temp_ptr(1) -> lisp_string.string_length > bufmaxl
		then do;
		     bufmaxl = 4 + 8*divide(tstack -> temp_ptr(1) -> lisp_string.string_length - 4 + 7, 8, 18, 0);
		     unmkd_ptr = addrel(bufp, 1+divide(bufmaxl, 4, 18, 0));
		     end;
		buffer = tstack -> temp_ptr(1) -> lisp_string.string;
		end;
	else do;				/* hard case, have to put in quotes */
		buffer = quote;
		nelemt = tstack -> temp_ptr(1) -> lisp_string.string_length;
		i = 0;
		do while (nelemt > 0);		/* push out sections not containing quotes */
/*** COMPILER BUG:		   j = length(before(substr(tstack -> temp_ptr(1) -> lisp_string.string, i+1), quote));  ***/
		   j = -1 + index(substr(tstack -> temp_ptr(1) -> lisp_string.string, i+1), quote);
		   if j < 0 then j = length(substr(tstack -> temp_ptr(1) -> lisp_string.string, i+1));
		   if 2 + length(buffer) + j > bufmaxl then do;	/* allocate more buffer */
							/* note, the '2 + ' is for a possible quote */
			bufmaxl = 4 + 8*divide(2 + length(buffer) + j - 4 + 7, 8, 18, 0);
			unmkd_ptr = addrel(bufp, 1+divide(bufmaxl, 4, 18, 0));
			end;
		   buffer = buffer || substr(tstack -> temp_ptr(1) -> lisp_string.string, i+1, j);
		   i = i + j;
		   nelemt = nelemt - j;

		   /* now there may be a quote as the next character, or else we're done */

		   if nelemt > 0 then do;		/* there is a quote */
			buffer = buffer || (quote || quote);
			i = i + 1;
			nelemt = nelemt - 1;
			end;
		   end;

		/* stick one more quote on the end */

	 	if length(buffer) + 1 > bufmaxl then do;
			bufmaxl = 4 + 8*divide(length(buffer) + 1 - 4 + 7, 8, 18, 0);
			unmkd_ptr = addrel(bufp, 1+divide(bufmaxl, 4, 18, 0));
			end;
		buffer = buffer || quote;
		end;

	/* string has been formatted into buffer, type it out and return */

	call send_the_buffer;

	go to print_ret(reti);

format_symbol:

	if tstack -> temp_ptr(1) -> atom.pnamel = 0 then go to print_ret(reti);

	Ch1 = substr(tstack -> temp_ptr(1) -> atom.pname,1,1);
	Ch1_syntax = read_table.syntax(binary(unspec(Ch1),9));
	if tstack -> temp_ptr(1) -> atom.pnamel = 1
	then Ch2_syntax = "0"b;		/* cause code below to work */
	else do;
	     Ch2 = substr(tstack -> temp_ptr(1) -> atom.pname,2,1);
	     Ch2_syntax = read_table.syntax(binary(unspec(Ch2),9));
	     end;

	if ^ slashing then do;	/* no slashing, just copy out the pname */
	     if tstack -> temp_ptr(1) -> atom.pnamel > bufmaxl
	     then do;		/* allocate some more buffer */
		bufmaxl = 4 + 8*divide(tstack -> temp_ptr(1) -> atom.pnamel - 4 + 7, 8, 18, 0);
		unmkd_ptr = addrel(bufp, 1+divide(bufmaxl, 4, 18, 0));
		end;
	     buffer = tstack -> temp_ptr(1) -> atom.pname;
	     call send_the_buffer;
	     go to print_ret(reti);
	     end;
				/* slashing, see if first character should be slashed */
	else if Ch1_syntax & single_char_object
	     then if Ch2_syntax then go to slash_first_char;
		else go to dont_slash_first_char;  /* suppress slash for lone sco */
	     else if Ch1_syntax & slash_if_first
		then if Ch1_syntax & slash_if_not_first then go to slash_first_char;
		else if Ch1_syntax & plus_minus
		     then if Ch2_syntax = ""b then go to dont_slash_first_char;
		     else if Ch2_syntax & slash_suppressors then go to dont_slash_first_char;
		     else go to slash_first_char;
		else if Ch1_syntax & digit
		     then if Ch2_syntax & shift_scale then go to slash_first_char;
		     else if Ch2_syntax & slash_suppressors then go to dont_slash_first_char;
		     else go to slash_first_char;
		else go to slash_first_char;	/* something random, better slash it */
	     else go to dont_slash_first_char;	/* slash bit not turned on */

dont_slash_first_char:
	buffer = Ch1;
	go to scan_pname;

slash_first_char:
	buffer = "//";
	substr(buffer, 2, 1) = Ch1;	/* efficiency hack */

scan_pname:

	/* now scan through pname, putting out characters and slashes */

	do i = 2 by 1 while( i <= tstack -> temp_ptr(1) -> atom.pnamel );
	   Ch1 = substr(tstack -> temp_ptr(1) -> atom.pname, i, 1);
	   if read_table.syntax(binary(unspec(Ch1), 9)) & slash_if_not_first
	   then do;		/* put out a slash before this char. */
	        call ensure_room_in_buffer;
	        buffer = buffer || "/";
	        end;
	   call ensure_room_in_buffer;	/* now put out the character */
	   buffer = buffer || Ch1;
	   end;

	call send_the_buffer;

	go to print_ret(reti);


ensure_room_in_buffer:  procedure;

	if length(buffer) >= bufmaxl then do;
	   bufmaxl = bufmaxl + 8;		/* append two more words to buffer */
	   unmkd_ptr = addrel(unmkd_ptr, 2);
	   end;
end ensure_room_in_buffer;

format_random:				/* non-printable type */

	/* format up as a sharp sign and 24 octal digits */

	buffer = sharp_sign;

	do i = 1 to 24;
	   buffer = buffer || substr(DigitSet, 1+binary(tstack -> octal_byte(i), 3), 1);
	   end;
	call send_the_buffer;
	go to print_ret(reti);

/*** internal procedures for sending characters out (the "I/O" routines) ***/


send_the_buffer:  procedure;

	if printing then do;
		if send_to_tty then call send_buffer_to_tty;
		if send_to_files then call send_buffer_to_files;
		end;

	else if flatsw then stack -> fixedb = stack -> fixedb + length(buffer);

	else do;		/* exploding */

		do i = 1 to length(buffer);
		   tstack -> temp(3) = stack -> temp(1);	/* list so far */
		   Ch1 = substr(buffer, i, 1);
		   idx = rank (Ch1);		/*  511 chars BSG 10/13/80 */
		   if explodensw then do;
			addr(tstack -> temp(2)) -> fixnum_fmt.type_info = fixnum_type;
			addr(tstack -> temp(2)) -> fixedb = idx;
			end;
		   else do;
			dcl charobjp ptr,
			    char_obj fixed bin(71) aligned based(charobjp),
			   1 obarray_structure based aligned,
			     2 hash_table(0:510) fixed bin(71),
 			     2 char_objects(0:127) fixed bin(71);
		        if idx > 127 then call lisp_get_atom_ (Ch1,tstack -> temp (2));
		        else do;
			charobjp=addr (addr(obarray)->based_ptr->atom_ptrs.value->array_info.array_data_ptr->char_objects(idx) );
			
			if char_obj = nil then do;
			     if idx = 0 then call lisp_get_atom_("", char_obj);
				else call lisp_get_atom_(Ch1, char_obj);
			     end;
			tstack -> temp(2) = char_obj;
			end;
		  end;
		   stack_ptr = addr(tstack -> temp(4));	/* list printer screws this up */
		   call lisp_special_fns_$cons;
		   stack -> temp(1) = tstack -> temp(2);
		   stack_ptr = addr(tstack -> temp(4));
		   end;
		end;

end send_the_buffer;

send_buffer_to_files:  proc;

	if destl then do;
		tstack -> temp(3) = stack -> temp(2);	/* list of files */
		do while(tstack -> temp_type(3) = Cons);
		   tstack -> temp(2) = tstack -> temp_ptr(3) -> cons.car;
		   tstack -> temp(3) = tstack -> temp_ptr(3) -> cons.cdr;
		   call send_buffer_to_a_file;
		   end;
		end;

	else if dest1 then do;
		tstack -> temp(2) = stack -> temp(2);	/* a single file */
		call send_buffer_to_a_file;
		end;
end send_buffer_to_files;


send_buffer_to_tty:  proc;

dcl outp pointer,			/* -> iochan structure for file outputting on */
    same_line bit(1),		/* "1"b means could put auto newline, "0"b means already done */
    invoke_endpagefn bit(1),		/* flag that page broke in the middle of the buffer */
    hpos fixed bin,			/* horizontal position temp. during motion computation */
    position fixed bin(18),		/* position in buffer */
    i fixed bin(18),		/* temp. */
    nelemt fixed bin(18),		/* count of number of elements in various loops */
    starting_index fixed bin(18),	/* where to start outputting from */
    Nelemt fixed bin(18),		/* count of number of elements left to do in buffer */
    saved_nelemt fixed bin(18),	/* number of elements that were sent out */
    amount fixed bin(18);		/* number of characters that could be put out and fit */


	if ^ explicit_tty			/* if not (print foo t), look at ^w */
	then if addr(ctrlW) -> based_ptr -> atom.value ^= nil then return;	/* tty output suppressed */
	tstack -> temp(2) = nil;

send_buffer_to_a_file:  entry;

	Nelemt = length(buffer);
	starting_index = 1;

retry:	if tstack -> temp(2) = nil then outp = lisp_static_vars_$tty_output_chan;
	else if tstack -> temp(2) = t_atom then outp = lisp_static_vars_$tty_output_chan;
	else if tstack -> temp_type36(2) & File36 then outp = tstack -> temp_ptr(2);
	else do;		/* error */
	     unmp = unmkd_ptr;
	     unmkd_ptr = addrel(unmp, 2);
	     unmp -> errcode(1) = bad_output_dest;
	     call lisp_error_;		/* the losing file is on top of the stack */
	     go to retry;
	     end;

	/* make sure abbreviation allows this buffer to go to this destination */

	if (tstack -> temp_type36(2) & File36) = ""b
	then do;	/* tty */
	     if abbreved_out_flag then return;
	     end;
	else do;	/* non-tty file */
	     if abbrev_on_files & abbreved_out_flag then return;
	     if bool(abbrev_on_files, abbreving_flag, "0110"b) then return;
	     end;

	/* check that this iochan is OK to use */

	if string(outp -> iochan.flags) & not_ok_to_write
	then if lisp_io_control_$fix_not_ok_iochan(outp, "1"b)
	     then return;
	string(outp -> iochan.flags) = string(outp -> iochan.flags) & flag_reset_mask;		/* clear certain flags */

	if Nelemt = 0 then return;		/* seem to be all done */
	invoke_endpagefn = "0"b;

	/* compute motion due to this string and do auto-terpri stuff */

	same_line = "1"b;
compute_motion:
	position = starting_index;
	nelemt = Nelemt;
	hpos = outp -> iochan.charpos;
	do while (nelemt > 0);
	   i = search(substr(buffer, position, nelemt), format_effectors);
	   if i = 0 then i = nelemt + 1;	/* rest of string is normal characters */
	   if i > 1 then do;		/* some normal chars to process */
		hpos = hpos + (i - 1);	/* compute horizonal motion */
		position = position + (i - 1);
		nelemt = nelemt - (i - 1);
check_hpos:	if same_line 		/* do auto terpri stuff */
		then if ^ status_terpri
		  then if outp -> iochan.image_mode = "0"b
		     then if outp -> iochan.linel ^= 0
			then if outp -> iochan.linel < hpos
			     then if hpos > i-1 then do;
				same_line = "0"b;		/* now on new line, don't loop infinitely */
				call send_out_newline;
				if substr(buffer, starting_index, 1) = space
				then do;
				     starting_index = starting_index + 1;
				     Nelemt = Nelemt - 1;
				     end;
				go to compute_motion;
				end;
		end;
	   else do;			/* this character is a format effector */
		Ch1 = substr(buffer, position, 1);
		position = position + 1;
		nelemt = nelemt - 1;
		if Ch1 = backspace then if hpos > 0 then hpos = hpos - 1; else;
		else if Ch1 = tab then do;
			hpos = 10 * divide(hpos + 10, 10, 17, 0);
			go to check_hpos;
			end;
		else if Ch1 = newline then do;
			hpos = 0;
			same_line = "0"b;	/* no need for auto terpri now */
			outp -> iochan.nlsync = "1"b;
			outp -> iochan.linenum = outp -> iochan.linenum + 1;
			if outp -> iochan.pagel ^= 0
			then if outp -> iochan.pagel <= outp -> iochan.linenum
			     then go to move_to_new_page;
			end;
		else if Ch1 = newpage then do;
			hpos = 0;
			same_line = "0"b;
move_to_new_page:		outp -> iochan.linenum = 0;
			outp -> iochan.pagenum = outp -> iochan.pagenum + 1;

			/* invoke the endpagefn if there is one - but first send buffer to devicee */

			if ^ outp -> iochan.interactive
			then if outp -> iochan.function ^= nil
			     then do;
				invoke_endpagefn = "1"b;
				nelemt = position - starting_index;
				go to exitloop;
				end;
			end;

		else if Ch1 = carriage_return then hpos = 0;
		end;
	   end;

exitloop:	/* we have either processed it all or stopped because of end of page.
	   update charpos from hpos then if endpagefn needs to be invoked,
	   send partial buffer to device, invoke endpagefn, send rest of buffer */

	outp -> iochan.charpos = hpos;

	if invoke_endpagefn then do;
		nelemt = position-1;	/* up to and including NP char. */
		go to send_to_device;
		end;

	/* special checks for tty:  read_print_nl_sync and ^w */

	if (tstack -> temp_type36(2) & File36) = ""b then do;
		if read_print_nl_sync then do;
		   if substr(buffer, starting_index, 1) = newline then do;
			starting_index = starting_index + 1;
			Nelemt = Nelemt - 1;
			end;
		   read_print_nl_sync = "0"b;
		   end;
		end;

	/* send this buffer to this device */

	nelemt = Nelemt;
send_to_device:
	saved_nelemt = nelemt;
	do while(nelemt > 0);
compute_amount:
	   amount = outp -> iochan.iolength - outp -> iochan.ioindex;
	   if amount = 0 then do;
		call lisp_io_control_$end_of_block(outp, cruft, code);
		if code = -2 then return;	/* can't accept any more output */
		go to compute_amount;
		end;
	   if amount > nelemt then amount = nelemt;
	   substr(outp -> ioptr -> io_buffer, outp -> ioindex+1, amount) =
		substr(buffer, starting_index, amount);	/* move into buffer */
	   starting_index = starting_index + amount;
	   nelemt = nelemt - amount;
	   outp -> ioindex = outp -> ioindex + amount;
	   end;

	/* now may need to invoke endpagefn */

	if invoke_endpagefn then do;
		starting_index = starting_index + saved_nelemt;
		Nelemt = Nelemt - saved_nelemt;
		invoke_endpagefn = "0"b;
		call flush_buffers;

		stack_ptr = addr(tstack -> temp(7));		/* need 3 more cells */
		tstack -> temp(4) = outp -> iochan.function;
		tstack -> temp(5) = tstack -> temp(2);	/* file */
		tstack -> temp(6) = nil;
		call lisp_special_fns_$cons;
		call lisp_$apply;

		go to retry;		/* recompute outp (in case gc) and do rest of buffer */
		end;


send_out_newline:  proc;		/* needed since can't change the buffer */

dcl invoke_endpagefn bit(1) init("0"b);	/* localized because means exit through routine
				   that might set flag in outside world, not set flag in o.w. */

	/* check that this iochan is OK to use */

	if string(outp -> iochan.flags) & not_ok_to_write
	then if lisp_io_control_$fix_not_ok_iochan(outp, "1"b)
	     then return;
	string(outp -> iochan.flags) = string(outp -> iochan.flags) & flag_reset_mask;		/* clear certain flags */

	outp -> iochan.charpos = 0;
	outp -> iochan.nlsync = "1"b;
	outp -> iochan.extra_nl_done = "1"b;
	outp -> iochan.linenum = outp -> iochan.linenum + 1;
	if outp -> iochan.pagel ^= 0
	then if outp -> iochan.pagel <= outp -> iochan.linenum
	     then invoke_endpagefn = "1"b;

	if outp -> iochan.iolength <= outp -> iochan.ioindex then do;
		call lisp_io_control_$end_of_block(outp, cruft, code);
		if code = -2 then return;
		end;
	substr(outp -> ioptr -> io_buffer, outp -> ioindex+1, 1) = newline;
	outp -> ioindex = outp -> ioindex + 1;
	if invoke_endpagefn then do;
		position = starting_index;
		go to move_to_new_page;		/* GROSS:  eventually will do the right thing though */
		end;
end send_out_newline;


end send_buffer_to_tty;

flush_buffers:  proc;

dcl tstack pointer,
    outp pointer;

	/* call end_of_block for any interactive output iochans */

	if send_to_tty
	then do;
	     outp = tty_output_chan;
	     call flush2;
	     end;

	if dest1 then do;
		if stack -> temp(2) = nil then outp = tty_output_chan;
		else if stack -> temp(2) = t_atom then outp = tty_output_chan;
		else if stack -> temp_type36(2) & File36 then outp = stack -> temp_ptr(2);
		else go to ng1;

		call flush2;
ng1:		end;
	else if destl then do;
		tstack = stack_ptr;
		stack_ptr = addrel(tstack, 2);
		do tstack -> temp(1) = stack -> temp(2)
			repeat (tstack -> temp_ptr(1) -> cons.cdr)
			while  (tstack -> temp_type(1) = Cons);
		     if tstack -> temp_ptr(1) -> cons.car = nil then outp = tty_output_chan;
		     else if tstack -> temp_ptr(1) -> cons.car = t_atom then outp = tty_output_chan;
		     else if tstack -> temp_ptr(1) -> cons_types36.car & File36
			then outp = tstack -> temp_ptr(1) -> cons_ptrs.car;
		     else go to ng2;
		     call flush2;
ng2:		     end;
		stack_ptr = tstack;
		end;


flush2:	proc;		/* proc to maybe flush buffer of outp -> iochan */


	if ^ outp -> iochan.seg then
	 if outp -> iochan.charmode then go to flush3;
	 else if outp -> iochan.interactive then if outp -> iochan.nlsync then
flush3:	  if ^ outp -> iochan.write then
	    if outp -> iochan.ioindex > 0
	      then do;
		if string(outp -> iochan.flags) & not_ok_to_write then
			if lisp_io_control_$fix_not_ok_iochan(outp, "1"b) then return;
		call lisp_io_control_$end_of_block(outp, stack -> temp(1), code);
		end;
end flush2;

end flush_buffers;

bad_readtable:
	/* first attempt to fix the readtable so user can input */

	stack = stack_ptr;
	stack_ptr = addr(stack -> temp(3));
	stack -> temp(1) = readtable;		/* get the array property, which should be original readtable */
	stack -> temp(2) = array_atom;
	call lisp_property_fns_$get;
	addr(readtable)->based_ptr -> atom.value = stack -> temp(1);

	/* now signal the uncorrectable error */

	unmkd_ptr = addrel(unm, 2);
	unm -> errcode(1) = badreadtable;
	call lisp_error_;

/*** internal procedures to prepare for printing.
	which procedure is called depends on what entry we came in on.
	these procedures set stack -> temp(2), set flags,
	and set up the buffer in the unmarked pdl ***/

get_dest:	proc;		/* for lsubrs */

	stack  =  addrel(stack_ptr, -2);		/* lsubr */
	nargs = stack -> fixedb;
	stack = addrel(stack, nargs);
join2:	explicit_tty = "0"b;
	if nargs = -2 then go to joint;		/* only 1 arg is like subr */

	/* 2nd arg was given */

	send_to_tty = "0"b;
	send_to_files = "1"b;

	/* stack -> temp(2) is file or list of files */

	if stack -> temp_type(2) = Cons then do;
		destl = "1"b;
		dest1 = "0"b;
		end;
	  else do;
		dest1 = "1"b;
		destl = "0"b;
		end;
	go to check_for_tty_as_file_and_set_up_the_buffer_then_return;

get_dest_4_terpri: entry;		/* special for terpri which has one less arg */

	stack = addrel(stack_ptr, -2);
	nargs = stack -> fixedb;
	stack = addrel(stack, nargs);
	if nargs = 0 then		/* simulate extra arg */
	     do;
		nargs = -2;
		stack_ptr = addr(stack -> temp(3));
	     end;
	 else do;
		nargs = -4;
		stack -> temp(2) = stack -> temp(1);	/* arg given, make look like 2nd */
	      end;
	go to join2;

get_dest_non_lsubr:  entry;

	stack = stack_ptr;
	printing = "1"b;
	stack_ptr = addr(stack -> temp(4));
	go to joint;

get_dest_subr: entry;

	stack = addrel(stack_ptr, -2);		/* for subr 1 entry points */
joint:
	flatsw = "0"b;
	if addr(ctrlR)->based_ptr -> atom.value ^= nil then
	do;
	stack -> temp(2) = addr(outfiles)->based_ptr -> atom.value;
	if stack -> temp_type(2) then do;
		dest1 = "0"b;
		destl = "0"b;
		end;
	     else do;
		destl = "1"b;
		dest1 = "0"b;
		end;
	end;
	else dest1, destl = "0"b;

	if (dest1 | destl) = ""b
	then send_to_files = "0"b;
	else send_to_files = "1"b;

	send_to_tty = "1"b;			/* check ^w dynamically so user can
					   turn off long output after it starts. */

check_for_tty_as_file_and_set_up_the_buffer_then_return:

	if send_to_files
	then if dest1
	     then if stack -> temp(2) = nil then go to not_really_to_files;
		else if stack -> temp(2) = t_atom then go to not_really_to_files;
		else;
	     else if destl
		then if stack -> temp_type(2) then go to not_really_to_files;	/* empty list */
		     else if stack -> temp_ptr(2) -> cons.car = nil |
			   stack -> temp_ptr(2) -> cons.car = t_atom
			then if stack -> temp_ptr(2) -> cons.cdr = nil
			     then go to not_really_to_files;

	go to really_to_files;

not_really_to_files:
	explicit_tty = "1"b;
	send_to_files = "0"b;		/* this hackery makes abbreviation work better */
	send_to_tty = "1"b;

really_to_files:
	call set_up_buffer;
end get_dest;


/* here is the routine that sets up all the cruft in the unmarked pdl */

set_up_buffer:  proc;

	unm, bufp = unmkd_ptr;
	bufmaxl = bufminl;
	unmkd_ptr = addrel(bufp, divide(bufmaxl,4,18,0)+1);	/* protect buffer */
	buffer = "";
	tstack = addr(stack -> temp(3));
	stack_ptr = addr(tstack -> temp(4));
end;



end print;
