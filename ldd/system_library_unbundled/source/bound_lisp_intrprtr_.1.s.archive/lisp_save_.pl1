/* **************************************************************
   *                                                            *
   * Copyright, (C) Massachusetts Institute of Technology, 1973 *
   *                                                            *
   ************************************************************** */
lisp_save_: proc(arg);
	/*** NOTE WELL:  DUE TO A BUG IN THE PL1 COMPILER, THIS PROGRAM MUST ALWAYS BE COMPILED WITH -OPTIMIZE ***/


/*
 * changes made 3/20/73 by DAM:
 *  changed the variable size to Size to allow use of the size BIF
 *  added pointer overlays curptrp, newptrp, fakeptrp
 *  added code to save file objects (iochans)
 * Modified 73.12.17 by DAM for a new format of saved environment header
 * Modified 74.06.03 by DAM for new-arrays and to save the gensym data
 * Modified 78.06.04 by BSG to put on Subr bit in snapped array links
 * Modified 82.10.14 by Richard Lamson to remove warning about up-to-date-ness
 */


/* D E C L A R A T I O N S */


/* P A R A M E T E R */

dcl arg char(*) parameter;				/* name of env. to save */


/* A U T O M A T I C */

dcl  current_save_seg bit(18) init(""b),		/* baseno of last temp seg created, used for threading */
     temp_ptr ptr,					/* used to circomvent PL/I v2 bug */
     temp_ptr_1 ptr,
     temp_ptr_0 ptr,
     first_save_seg bit(18) init(""b),			/* baseno of first temp seg created, has thread to rest */
     free_allocptr ptr init(null),			/* -> next cell of lists space in temp seg to allocate */
     stat_allocptr ptr init(null),			/* -> next part of static temp seg to allocate */
     dir char(168),					/* directory pathname */
     ent char(32),					/* entryname of savefile */
     ename char(32),
     segnumber fixed bin init(0),			/* msf component number */
     curptr fixed bin(71) aligned,			/* current object */
     curptrp ptr aligned based(addr(curptr)),		/* and same as a pointer */
     newptr fixed bin(71) aligned,			/* copy */
     newptrp ptr aligned based(addr(newptr)),		/* and same as a pointer */
     newsegptr ptr,
     fakeptr fixed bin(71) aligned,			/* object stored in saved env - has fake segment number */
     fakeptr2 fixed bin(71) aligned,
     newptr2 ptr,
     fake_lists_seg bit(18),				/* segment index of current lists seg for making fakeptr */
     fake_array_seg bit(18),				/* segment index of current array seg for making fakeptr */
     segptr ptr,
     acinfo ptr,					/* make tssi_ happy */
     number_of_array_links fixed bin,
     system_tv_segno bit(18) init(baseno(addr(lisp_subr_tv_$tv_begin))),	/* segment number of lisp_subr_tv_ */
     system_tv_offset fixed bin(17) init(binary(rel(addr(lisp_subr_tv_$tv_begin)))),
     segment_size fixed bin(19),
     this_seg_is_static bit(1),
     retad label local,				/* return address from pseudo subroutine copy */
     code fixed bin(35),				/* Multics status code */
     bucketx fixed bin,				/* index into gc'ed stuff in lisp_static_vars_ */
     bucketno fixed bin,				/* which garbage-collected slot in lisp_static_vars_ */
						/* is being saved/restored; or else how many of these */
     Size fixed bin,				/* size in words of data to copy */
     switch fixed bin,				/* type of subr object being saved */
     to_be_copied fixed bin,				/* total number words to move, may split across segments */
     words_left fixed bin,				/* number words left in segment currently moving into */
     stack ptr init(null),				/* -> our private stack used for recursion */
     bit_length fixed bin(24),			/* dummy argument for hcs_ calls */
     defptr ptr,
     string_ptr ptr,
     list_of_iochans ptr,				/* list of all iochans that have been saved */
     list_of_subr_blocks ptr,				/* list of all new-type subr blocks that have been saved */
     file_control_ptr ptr;

dcl  new_format bit(1),		/* 1 => saved_env structure, 0 => save_header structure */
     atomic_constants_addr ptr,
     atomic_constants_count fixed bin(18),
     rest_of_gc_area_addr ptr,
     rest_of_gc_area_count fixed bin(18),
     first_seg_ptr ptr;

dcl amount_of_gensym_data fixed bin,
     amount_of_maknum_data  fixed bin,
    (array_data_size, dope_vector_size) fixed bin(18),
    must_convert_arrays bit(1),
    i fixed bin;




/* B A S E D   O V E R L A Y S */

dcl  1 curptr_ovly based(addr(curptr)) aligned,
     2 filler bit(21)unaligned,
     2 curptr_type bit(9) unaligned,			/* */
     2 pad bit(23) unaligned,
     2 curptr_odd bit(1) unaligned,			/* */
     2 rest_of_curptr bit(18) unaligned,
     1 fakeptr_ovly based(addr(fakeptr))aligned,
     2 filler bit(21) unaligned,
     2 fakeptr_type bit(9) unaligned,			/* */
     2 pad bit(42) unaligned,
     Array_Data fixed bin(71) aligned based,		/* just data */
     temp (1000) fixed bin(71) aligned based,		/* (like lisp_stack_fmt.incl.pl1) */
     bit18unal bit(18) unaligned based,
     copy_mask (Size) based aligned bit(36),		/* (mask?) used to copy_words */
     transfer_location ptr based;			/* used to save local label retad on stack */


/* O L D   S A V E   F I L E   H E A D E R */

dcl  1 save_header based aligned,			/* goes at word 0 of component 0 of msf */
     2 num_gc_ptrs fixed bin(17) unaligned,		/* amount of cruft before first seg - from lisp_static_vars_ */
     2 seg_count fixed bin(17) unaligned,		/* number of segments represented.  /= number msf components */
     2 seg_size fixed bin,				/* Size of saved segments */
     2 iochan_list ptr,				/* list of saved iochans, here because not in
						   the gc'able part of lisp_static_vars_ that is saved */
     2 next_dbl_word fixed bin(71);			/* first free location after this structure */


/* N E W   S A V E   F I L E   H E A D E R */

dcl 1 saved_env aligned based,
    2 flag fixed bin(17) unaligned,                /* -1 => this format */
    2 seg_count fixed bin(17) unaligned,           /* number of segments represented.  /= number of msf components */
    2 seg_size fixed bin,                          /* Size of saved segments */
    2 version_number fixed bin,                    /* 3 for this declaration */
    2 iochan_list ptr,                             /* pseudo ptr for list of all iochans */
    2 subr_block_list ptr,                         /* pseudo ptr for list of all new type subr blocks */
    2 offset_to_first_seg fixed bin(18),           /* offset in first msf component of start of first saved segment */
    2 atomic_constants,                            /* saved lisp_static_vars_ atoms */
      3 offset fixed bin(18),                      /* offset in first msf component */
      3 length fixed bin(18),                      /* number of saved items */
    2 rest_of_gc_area,                             /* similar stuff for other part of lisp_static_vars_ that is saved */
      3 offset fixed bin(18),
      3 length fixed bin(18),
    2 gensym_data (amount_of_gensym_data) bit(36) aligned,	/* either 0 words (v=1) or 2 words (v>_2) */
    2 maknum_data (amount_of_maknum_data) bit(36) aligned, /* either 0 words (v<_2) or 5 words (v > 2) */
    2 seg_type (0 refer (saved_env.seg_count)) bit(1) unaligned;  /* table of segment types, 1 = static, 0 = lists */


/* S E G M E N T   H E A D E R */

dcl  1 segment based aligned,				/* appears before each segment represented in save msf */
     2 chain bit(18) unaligned,			/* root of its-pair chain requiring fixing up */
     2 seg_type bit(18) unaligned,			/* ""b = lists, "1"b = array = static */
     2 seg_chain bit(18) unaligned,			/* segno of next seg in list of such */
     2 seg_size bit(18) unaligned;			/* number of words (always even) that were saved in the msf */


/* S T A T I C   S E G   K L U D G E */

dcl 1 static_seg_kludge aligned based,		/* header of saved static seg */
      2 link_block_chain_ptr ptr,		/* overlaid by segment header */

      2 def_sect_ptr ptr,
      2 saved_list_of_subr_blocks ptr,		/* hidey-hole for list of comp subr blocks (Kludgey!!) */
      2 virgin_link_ptr ptr,
      2 zeroes bit(72);

/* S T A T I C   S E G   T E M P L A T E */

dcl 1 static_seg_template aligned static,	/* initialization for static seg header */
      2 chain_pointer ptr init(null),
      2 def_pointer ptr init(null),
      2 thread_pointer ptr init(null),
      2 virgin_link_pointer ptr init(null),
      2 zeroes bit(72) init(""b);

dcl 1 static_seg_header aligned based like static_seg_template;


/* F O R M A T   O F   E N T R Y   P O I N T   I N   S U B R   B L O C K */

dcl  1 subr based aligned,
       2 nargs fixed bin(17) unaligned,
       2 infop fixed bin(17) unaligned,
       2 entry_inst(3) bit(36) aligned,
       2 stat_size fixed bin(17) unal,			/* for type 3 subrs, static block Size */
       2 rest_of_word bit(18) unal,
       2 gcmark bit(18) aligned;			/* marker used by garbage collector for type 3 subrs */


/* F O R M A T   O F   A R R A Y S */

%include lisp_array_fmt;


/* F O R M A T   O F   L I N K S */

dcl  1 acc based aligned,
       2 len fixed bin(8) unaligned,			/* "acc string" */
       2 string char(262144) unaligned,
     1 link_info based aligned,
      2 header_ptr fixed bin(17) unaligned,		/* standard ft2 pair */
      2 ft2 fixed bin(17) unaligned,
      2 def_offset bit(18) unaligned,
      2 rest fixed bin(17) unaligned,
      2 type_pair_ptr bit(18) unal,
      2 exp_val bit(18) unal,
      2 class bit(18) unal,
      2 trap_off bit(18) unal,
      2 seg_nam_ptr bit(18) unaligned,
      2 ent_nam_ptr bit(18) unaligned;


/* F O R M A T   O F   O U R   R E C U R S I O N   S T A C K */

dcl  1 stack_entry based(stack) aligned,
     2 object fixed bin(71) aligned,
     2 return ptr,					/* saved copy of retad */
     1 array_save based(stack) aligned,
       2 address ptr,
       2 Size fixed bin,
       2 pad fixed bin,
       2 return_addr ptr;
dcl 1 array_link_save based(stack) aligned,
      2 save_temp_ptr pointer unaligned,
      2 save_temp_ptr_1 pointer unaligned,
      2 save_fakeptr fixed bin(71),
      2 save_newptr fixed bin(71),
      2 save_return unaligned pointer,
      2 number_of_links_left fixed bin;


/*  E X T E R N A L   S T A T I C */

dcl  lisp_standard_environment_$ ext fixed bin,		/* the default environment for unsave */
     lisp_static_vars_$saved_environment_dir ext char(168),
     lisp_static_vars_$no_snapped_links bit(1) external aligned,
    lisp_static_vars_$maknum_data (5) bit(36) aligned ext,
     lisp_subr_tv_$tv_begin ext bit(36) aligned,
     lisp_static_vars_$number_gc_ptrs ext fixed bin(17) aligned,    /* number of cells to save in lisp_static_vars_ */
     lisp_static_vars_$number_of_atomic_constants ext fixed bin(17) aligned,
     lisp_static_vars_$garbage_collected_ptrs ext fixed bin(71) aligned, /* first cell to be saved */
     lisp_static_vars_$garbage_collect_inhibit  ext  bit(36) aligned,
     lisp_static_vars_$subr_block_list external pointer,
     lisp_static_vars_$ignore_faults bit(1) aligned external;


/* M A N I F E S T   C O N S T A N T S */

dcl  already_copied fixed bin(71) static init(-1) aligned,
     subr_size (-2:3) fixed bin static init(4,0,2,6,4,6),		/* Size of blocks in subrs */
     unsnapped_array_link_instruction bit(36) static init("001000000001010110010111010001010000"b);


/* E X T E R N A L   E N T R I E S   C A L L E D */

dcl  lisp_alloc_$init_alloc entry(ptr,fixed bin,ptr,fixed bin),
     cu_$cl entry,
     lisp_save_alm_ entry(pointer, pointer),		/* fast chain chaser written in alm */
     lisp_get_atom_ entry(char(*), fixed bin(71)),
     (lisp_io_control_$set_for_save, lisp_io_control_$empty_all_buffers) entry,
     lisp_garbage_collector_ entry,
     lisp_alloc_$rehash_maknum entry,
     lisp_garbage_collector_$set_gc_params entry,
     lisp_segment_manager_$get_lists entry(ptr),
     lisp_segment_manager_$free_lists entry(ptr),
     lisp_segment_manager_$get_array entry(ptr),
     lisp_segment_manager_$free_array entry(ptr),
     expand_pathname_$add_suffix entry (char(*), char(*), char(*), char(*), fixed bin(35)),
     pathname_ entry (char(*), char(*)) returns(char(168)),
     com_err_ entry options(variable),
     msf_manager_$open entry (char (*), char(*), ptr, fixed bin(35)),
     hcs_$get_link_target entry (char(*), char(*), char(*), char(*), fixed bin(35)),
     msf_manager_$get_ptr entry (ptr, fixed bin, bit(1), ptr, fixed bin(24), fixed bin(35)),
     msf_manager_$close entry (ptr),
     hcs_$get_max_length_seg entry(pointer, fixed bin(19), fixed bin(35)),
     tssi_$get_file entry (char (*), char (*), ptr, ptr, ptr, fixed bin(35)),
     tssi_$finish_file entry (ptr, fixed bin, fixed bin(24), bit(36) aligned, ptr, fixed bin(35));


/* B U I L T I N */

dcl (addr,addrel,baseno,baseptr,binary,bit,divide,fixed,min,mod,null,size,ptr,rel,unspec,substr,string) builtin;

%include lisp_stack_seg;
%include lisp_bignum_fmt;
%include lisp_free_storage;
%include lisp_iochan;
%include lisp_subr_fmt;
%include lisp_string_fmt;
%include lisp_cons_fmt;
%include lisp_ptr_fmt;
%include lisp_comp_subr_block;
%include lisp_atom_fmt;

%include lisp_common_vars;
%include lisp_maknum_table;

/* 

/* entry to save the current lisp environment at path specified by arg */

	call expand_pathname_$add_suffix (arg, "sv.lisp", dir, ent, code);
	if code ^= 0 then go to crump;
	call tssi_$get_file(dir,ent,segptr,acinfo,file_control_ptr,code);	/* get segment for result */
	if code ^= 0 then go to crump;
	call hcs_$get_max_length_seg(segptr, segment_size, code);
	if code ^= 0 then go to crump;

	lisp_static_vars_$ignore_faults = "1"b;	/* can't user interrupt, since
						   we're going to destroy the env. */
	call lisp_io_control_$empty_all_buffers;		/* set up the I/O system for saving */
	call lisp_io_control_$set_for_save;
	list_of_iochans = null;
	list_of_subr_blocks = null;
	stack = ptr(stack_ptr,0);
	bucketno = lisp_static_vars_$number_gc_ptrs; /* numbeer of things saved */

	/* generate header for save file */

	segptr -> saved_env.flag = -1;		/* flag that this is new format */
	segptr -> saved_env.version_number = 3;
	amount_of_maknum_data = 5;
	amount_of_gensym_data = 2;
	segptr -> saved_env.gensym_data(*) = ptr(unmkd_ptr, ""b) -> stack_seg.gensym_data(*);
	segptr -> saved_env.atomic_constants.length = lisp_static_vars_$number_of_atomic_constants + 1;	/* allow for obarray */
	segptr -> saved_env.atomic_constants.offset = fixed(rel(addr(segptr -> saved_env.seg_type(300))), 18);	/* ?? */
	if mod(segptr -> saved_env.atomic_constants.offset, 2) ^= 0
	then segptr -> saved_env.atomic_constants.offset = segptr -> saved_env.atomic_constants.offset + 1;
	segptr -> saved_env.rest_of_gc_area.offset = segptr -> saved_env.atomic_constants.offset +
		2 * segptr -> saved_env.atomic_constants.length;
	segptr -> saved_env.rest_of_gc_area.length = lisp_static_vars_$number_gc_ptrs - segptr -> saved_env.atomic_constants.length;
	segptr -> saved_env.offset_to_first_seg = segptr -> saved_env.rest_of_gc_area.offset +
		2 * segptr -> saved_env.rest_of_gc_area.length;

	temp_ptr_0 = addr(lisp_static_vars_$garbage_collected_ptrs);

	newsegptr = addrel(segptr, segptr -> saved_env.atomic_constants.offset);
	words_left = segment_size - segptr -> saved_env.atomic_constants.offset;
	do while(bucketno > 0);
	     bucketno = bucketno - 1;
	     curptr = temp_ptr_0 -> Array_Data;	/* next ptr */
	     retad = main_loop;
	     go to copy;
main_loop:	     newsegptr->Array_Data = curptr;
	     newsegptr = addrel(newsegptr,2);
	     words_left = words_left - 2;
	     temp_ptr_0 = addrel(temp_ptr_0,2);
	end;

	if lisp_static_vars_$maknum_mask = -1 then go to stash_maknum_data;

		lisp_static_vars_$maknum_left = 0;
		do bucketno = lbound(maknum_table,1) to hbound(maknum_table,1);
			if string(maknum_table(bucketno).first)
			then if maknum_table(bucketno).first.type & Numeric
			then lisp_static_vars_$maknum_left = lisp_static_vars_$maknum_left+1;
			else do;
				curptrp =  maknum_table_ptrs(bucketno).second;
				curptr_type =  maknum_table(bucketno).first.type;
				retad =  mak_loop;
				go to copy;
mak_loop:				maknum_table_ptrs(bucketno).second = curptrp;
				lisp_static_vars_$maknum_left = lisp_static_vars_$maknum_left+1;
			     end;
		end;

		Size = size(maknum_table);
		call allocate;
		newptrp -> maknum_table(*) =  maknum_table(*);
		lisp_static_vars_$maknum_table_ptr = addr(fakeptr) ->curptrp;	/* fake up table ptr */

stash_maknum_data:
	segptr -> saved_env.maknum_data(*)  =  lisp_static_vars_$maknum_data(*);
	go to done;

/* 

/* pseudo subroutine to do copying of lisp objects. It is recursive, so that
   arbitrary structures may be copied. recursion is implemented by using the
   push down stack segment. Note that a destructive copy is made, so lisp
   must be re-entered to get the resulting environment back */


copy:	if curptr = 0 then go to retad;
	if curptr_type & Numeric then go to retad;	/* if simple object (resides in pointer) then just return */
	if curptr_type & String then go to copy_string;	/* if string the go to string copy routine */
	if curptr_odd				/* if odd address, fix to even address...snapped link */
	then do;
		curptr_odd = "0"b;				/* make address even */
		stack -> return = addr(retad) -> transfer_location;
		stack -> object = 0;			/* just fill it in (?) */
		stack = addrel(stack,4);
		retad = odd_address;
	     end;

	if curptrp -> cons.car = already_copied then do;	/* if atomic symbol or cons has been copied, then just return new address, stored in cdr */
	     curptr = curptrp -> cons.cdr;
	     go to retad;
	end;
	if curptr_type & Bigfix then go to copy_bigfix;
	if curptr_type & File then go to copy_file;
	if curptr_type & Array then go to copy_array;
	if curptr_type & Subr then go to copy_subr;	/* if subr then go to subr copy routine */
	if curptr_type & Atsym then go to copy_atsym;	/* if atomic symbol then go to routine to copy it */

/* do cons pointers */

	Size = 4;
	call allocate;

	newptrp -> cons = curptrp -> cons;		/* copy contents */
	curptrp -> cons.car = already_copied;
	curptrp -> cons.cdr = fakeptr;

copy_file_like_cons:
	stack -> return = addr(retad) -> transfer_location;
	stack -> object = newptr;

common_collector:
	curptr = newptrp -> cons.car;
	newptrp -> cons.car = fakeptr;
	stack = addrel(stack,4);
	retad = cdr_next;
	go to copy;
cdr_next: stack = addrel(stack,-4);
	newptr = stack -> object;
	fakeptr = newptrp -> cons.car;
	newptrp -> cons.car = curptr;
	if curptr_type & Numeric then go to do_cdr;
	addr(newptrp ->cons.car)-> lisp_ptr.chain = ptr(newptrp,0)-> segment.chain;
	ptr(newptrp,0)-> segment.chain = rel(addr(newptrp ->cons.car));
do_cdr:	curptr = newptrp -> cons.cdr;
	newptrp -> cons.cdr = fakeptr;
	stack = addrel(stack,4);
	retad = cons_almost_done;
	goto copy;
cons_almost_done: 
	stack = addrel(stack,-4);
	newptr = stack -> object;
	fakeptr = newptrp-> cons.cdr;
	newptrp-> cons.cdr = curptr;
	if curptr_type & Numeric then go to cons_done;
	addr(newptrp->cons.cdr)-> lisp_ptr.chain = ptr(newptrp,0) -> segment.chain;
	ptr(newptrp,0) -> segment.chain = rel(addr(newptrp->cons.cdr));
cons_done: curptr = fakeptr;
	addr(retad) -> transfer_location = stack -> return;
	go to retad;


/* routine to copy atomic symbol, and recursively copy its values */

copy_atsym: Size = divide(curptrp -> pnamel + 23,4,17,0);
	call allocate;
	newptrp-> copy_mask = curptrp -> copy_mask;
	fakeptr_type = Atsym;
	curptrp -> atom.value = already_copied;
	curptrp -> atom.plist = fakeptr;

	stack -> return = addr(retad) -> transfer_location;
	stack -> object = newptr;

	if newptrp -> atom_double_words.value = Undefined then go to do_cdr;
	go to common_collector;
copy_string: 			/* copy a lisp format string */
	Size = curptrp -> string_length;
	if Size < 0
	then do;
		curptrp = curptrp -> copied_string.new_fake_address;
		curptr_type = String;
		go to retad;
	     end;
	Size = divide(Size + 7,4,17,0);
	call allocate;
	newptrp-> copy_mask = curptrp -> copy_mask;
	curptrp -> string_length = -5050;	/* mark as copied */
	curptrp -> copied_string.new_fake_address = addr(fakeptr) -> based_ptr;
dcl 1 copied_string based aligned,
      2 paddup fixed bin,
      2 new_fake_address ptr unaligned;

	curptr = fakeptr;
	curptr_type = String;
	goto retad;

copy_bigfix:
	Size = divide(curptrp->lisp_bignum.prec+2,2,18,0)*2;
	call allocate;
	newptrp->copy_mask = curptrp->copy_mask;
	fakeptr_type = curptr_type;
	curptrp->cons.car = already_copied;
	curptrp->cons.cdr = fakeptr;
	curptr = fakeptr;
	go to retad;


/* copy a subr value into static */

copy_subr:
	if curptr_type & System_Subr
	then do;
		addr(curptr)->lisp_ptr.segno = ""b;			/* segno of 0 is relative to tv */
		addr(curptr)->lisp_ptr.ringnum = ""b;			/* unsave needs 0 ring fields */
		addr(curptr)->lisp_ptr.offset = addr(curptr)->lisp_ptr.offset - system_tv_offset;
		go to retad;
	     end;
	if curptrp -> subr_entries(1).rest_of_tsx0 = tsx0_ic
	then go to copy_comp_subr;
	switch = subr_size(curptrp->subr.infop);
	if curptrp->subr.infop = 3 then switch = switch +
						     curptrp->subr.stat_size-2;
	defptr = addrel(curptrp,switch);	/* get linker info address */
	string_ptr = ptr(defptr,defptr->link_info.seg_nam_ptr);
	Size = divide(string_ptr->acc.len,4,17,0);
	string_ptr = ptr(defptr,defptr->link_info.ent_nam_ptr);
	Size = Size + divide(string_ptr->acc.len,4,17,0)+switch+7;	/* get totoal Size fo subr block */
	call allocate_static;

	newptrp->copy_mask = curptrp->copy_mask;
	fakeptr_type = curptr_type;				/* get type info into symbolic pointer */
	curptrp->cons.car = already_copied;
	curptrp->cons.cdr = fakeptr;	/* save new location */
	defptr = addrel(newptrp,switch);
	curptr = fakeptr;
	defptr->link_info.header_ptr = 2-binary(rel(defptr),18,0);
	defptr->link_info.ft2 = 100110b;
	defptr->link_info.def_offset = rel(addr(defptr->link_info.type_pair_ptr));
	defptr->link_info.rest = 0;
	defptr -> link_info.type_pair_ptr = rel(addr(defptr->link_info.class));
	defptr -> link_info.seg_nam_ptr = rel(addrel(defptr,5));
	defptr -> link_info.ent_nam_ptr = rel(addrel(defptr,6+divide(addrel(defptr,5)->acc.len,4,17,0)));
	if newptrp->subr.infop ^= 3 then go to retad;	/* return if no data to continue with */
	newptrp -> subr.gcmark = "0"b;	/* zero out word used by garbage collector */
	stack -> array_save.Size = newptrp->subr.stat_size-2;
	stack -> array_save.return_addr = addr(retad)->transfer_location;
	stack -> array_save.address, defptr = addrel(newptrp,6);
	retad = array_loop;
	go to subr_join;

copy_comp_subr:
	if  curptrp -> subr_entries(1).head_offset = -1		/* means already copied */
	then do;
		newptrp = ptr(baseptr(curptrp -> subr_entries(1).nargs), curptrp -> subr_entries(1).code_offset);
		addr(newptr) -> lisp_ptr_type = addr(newptr) -> lisp_ptr_type | Subr36;
		addr(newptr) -> lisp_ptr.ringnum = "000"b;
		curptr = newptr;
		go to retad;
	     end;

	defptr = addrel(curptrp, curptrp -> subr_entries(1).head_offset-1);
	newptrp = addrel(defptr, defptr -> subr_block_head.subr_code_link_offset+6);
	newptrp -> lisp_subr_links(1).itp_base = "001"b;
	newptrp -> lisp_subr_links(1).itp_mod = "100001"b;
	newptrp -> lisp_subr_links(1).link_opr_tv_offset = "000000000001001000"b;
	newptrp -> lisp_subr_links(1).mbz = "0"b;
	newptrp -> lisp_subr_links(1).further_mod = "010000"b;
	newptrp -> lisp_subr_links(1).itp_info = "0"b;
	Size = defptr -> subr_block_head.subr_code_link_offset + divide(51+newptrp -> link_to_subr_code.name_length,4,35,0);
	newptrp = addrel(newptrp, -2);		/* check for array links */
	if newptrp -> array_link_count.must_be_zero = ""b
	then number_of_array_links = newptrp -> array_link_count.number_of_array_links;
	else number_of_array_links = -1;
	call allocate_static;
	newptrp -> copy_mask = defptr -> copy_mask;

	/* copy the "secret" bit used by (sstatus uuolinks) */

	newptrp -> subr_block_head_overlay.no_links_are_snapped =
	 defptr -> subr_block_head_overlay.no_links_are_snapped;

	/* thread into list of all the comp subr blocks in the world */

	unspec (newptrp -> subr_block_head.next_compiled_block)= unspec (list_of_subr_blocks);
	if list_of_subr_blocks ^= null then do;
		addr(newptrp -> subr_block_head.next_compiled_block) -> lisp_ptr.chain = ptr(newptrp, 0) -> segment.chain;
		ptr(newptrp, 0) -> segment.chain = rel(addr(newptrp -> subr_block_head.next_compiled_block));
		end;
	unspec(list_of_subr_blocks) = unspec(fakeptr);

	newptrp -> subr_block_head.gcmark = "0"b;

	addr(fakeptr) -> based_ptr = addr(addr(fakeptr)->based_ptr-> subr_block_head.constants(defptr->subr_block_head.gc_length+1));
	temp_ptr = addr(defptr->subr_block_head.constants(defptr->subr_block_head.gc_length+1));

	Size = divide(newptrp -> subr_block_head.subr_code_link_offset,2,35,0) - newptrp -> subr_block_head.gc_length  -1;
	if number_of_array_links >= 0 then Size = Size - (2*number_of_array_links+1);
	do switch = 1 to Size;
	     temp_ptr -> subr_entries(switch).nargs = substr(unspec(fakeptr),1,18);
	     temp_ptr -> subr_entries(switch).code_offset = substr(unspec(fakeptr),37,18);
	     temp_ptr -> subr_entries(switch).head_offset = -1;
	     addr(fakeptr) -> based_ptr = addrel(addr(fakeptr) -> based_ptr, 2);
	end;

	unspec(fakeptr) = curptrp -> subr_entries(1).nargs || "000"b || Subr || "100011"b || curptrp -> subr_entries(1).code_offset;

	/* copy pointers in snapped array links */

	if number_of_array_links >= 0 then do;
	   temp_ptr = addrel(defptr, defptr -> subr_block_head.subr_code_link_offset+6-2-4*number_of_array_links);
	   temp_ptr_1 = addrel(newptrp, defptr -> subr_block_head.subr_code_link_offset+6-2-4*number_of_array_links);
	   stack -> array_link_save.save_newptr = newptr;
	   stack -> array_link_save.save_fakeptr = fakeptr;
	   stack -> array_link_save.save_return = addr(retad)->transfer_location;
	   stack -> array_link_save.number_of_links_left = number_of_array_links;
	   retad = array_link_loop;
array_link_loop_0:
	   stack -> array_link_save.number_of_links_left = stack -> array_link_save.number_of_links_left - 1;
	   if stack -> array_link_save.number_of_links_left < 0 then go to array_link_loop_end;
	   if temp_ptr -> array_links(1).instruction = unsnapped_array_link_instruction
	   then do;
	        temp_ptr = addrel(temp_ptr, 4);	/* don't copy pointer since not set */
	        go to copy_unsnapped_array_link;
	        end;
	   curptrp = temp_ptr -> array_links(1).pointer;
	   unspec(curptrp) = unspec(curptrp) | Array36 | Subr36;
	   temp_ptr = addrel(temp_ptr, 4);
	   stack -> array_link_save.save_temp_ptr = temp_ptr;
	   stack -> array_link_save.save_temp_ptr_1 = temp_ptr_1;
	   stack = addrel(stack, size(array_link_save));
	   go to copy;
array_link_loop:
	   stack = addrel(stack, -size(array_link_save));
	   temp_ptr = stack -> array_link_save.save_temp_ptr;
	   temp_ptr_1 = stack -> array_link_save.save_temp_ptr_1;
	   addr(fakeptr) -> lisp_ptr.chain = ptr(temp_ptr_1, 0) -> segment.chain;
	   ptr(temp_ptr_1, 0) -> segment.chain = rel(addr(temp_ptr_1 -> array_links(1).pointer));
	   unspec(temp_ptr_1 -> array_links(1).pointer) = unspec(fakeptr);
copy_unsnapped_array_link:
	   temp_ptr_1 = addrel(temp_ptr_1, 4);
	   go to array_link_loop_0;
array_link_loop_end:
	   newptr = stack -> array_link_save.save_newptr;
	   fakeptr = stack -> array_link_save.save_fakeptr;
	   addr(retad)->transfer_location = stack -> array_link_save.save_return;
	   end;


	stack -> array_save.Size = 2* newptrp -> subr_block_head.gc_length;
	stack -> array_save.return_addr = addr(retad) -> transfer_location;
	stack -> array_save.address, defptr = addr(newptrp -> subr_block_head.constants(1));
	retad = array_loop;
	go to subr_join;
copy_file:			/* copy an iochan.  Has to recurse for the two garbage-collectable
				   components function and namelist, and for the thread of all iochans */


	if curptrp -> iochan.gc_mark then do;			/* already been copied, ioptr -> the copy */
		curptrp = curptrp -> iochan.ioptr;
		curptr_type = File;
		go to retad;
		end;
	Size = size(iochan);
	call allocate_static;				/* make a copy of this iochan in save seg */
	newptrp -> copy_mask = curptrp -> copy_mask;
	fakeptr_type = File;
	curptrp -> iochan.gc_mark = "1"b;
	unspec(curptrp -> iochan.ioptr) = unspec(fakeptr);

	/* maintain a new threaded list of iochans - in list_of_iochans 
	   this will replace lisp_static_vars_$iochan_list */

	unspec (newptrp -> iochan.thread) = unspec (list_of_iochans);
	if list_of_iochans ^= null then do;
	     addr(newptrp -> iochan.thread)->lisp_ptr.chain = ptr(newptrp, 0) -> segment.chain;
	     ptr(newptrp, 0) -> segment.chain = rel(addr(newptrp -> iochan.thread));
	     end;
	unspec(list_of_iochans) = unspec(fakeptr);	/* keep ring number in this pointer zero for unsave */

	/* now collect the function and namelist as if they were a cons */

	newptrp = addr(newptrp -> iochan.function);
	go to copy_file_like_cons;

copy_array:			/* copy a lisp array */

	/* compute number of words in array */

	if curptrp -> array_info.type < Fixnum_array then Size = 2;
	else if curptrp -> array_info.type < Obarray_array then Size = 1;
	else if curptrp -> array_info.type = Obarray_array then Size = 2;
	else go to copy_dead_array;
	if curptrp -> array_info.minus_2_times_ndims = 0	/* external array */
	then do;
	     curptrp -> array_info.array_data_ptr = null;	/* won't work in new process probably */
	     go to copy_dead_array;
	     end;
	defptr = curptrp -> array_info.array_data_ptr;
	do i = -(curptrp -> array_info.ndims) repeat (i+1) while (i < 0);
	   Size = Size * defptr -> array_data.dope_vector(i+1).bounds;
	   end;

	/* compute amount of garbage-collectable stuff */

	if curptrp -> array_info.type < Fixnum_array then array_data_size = Size;
	else if curptrp -> array_info.type = Obarray_array then array_data_size = Size;
	else if curptrp -> array_info.type = Readtable_array then array_data_size = 18;
	else array_data_size = 0;		/* numeric array */

	dope_vector_size = 2*(curptrp -> array_info.ndims);
	Size = Size + dope_vector_size;		/* allow for dope vector */
	call allocate;
	newptrp->copy_mask = addrel(defptr, -dope_vector_size)->copy_mask;
	fakeptr2 = fakeptr + 262144*dope_vector_size;	/* addrel fakeptr, -> array_data.data */
	newptr2 = addrel(newptrp, dope_vector_size);
	Size = 8;					/* create array_info */
	call allocate_static;
	newptrp -> copy_mask = curptrp -> copy_mask;
	fakeptr_type = curptr_type;
	unspec(newptrp -> array_info.array_data_ptr) = unspec(fakeptr2);
	string_ptr = ptr(newptrp, 0);			/* put on list of fakeptr's */
	addr(newptrp -> array_info.array_data_ptr)-> lisp_ptr.chain = string_ptr -> segment.chain;
	string_ptr -> segment.chain = rel(addr(newptrp -> array_info.array_data_ptr));
	newptrp -> array_info.gc_mark = (18)"0"b;	/* zero out gc mark */

	curptrp -> cons.car = already_copied;		/* mark old object */
	curptrp -> cons.cdr = fakeptr;		/* and remember new loc */

	stack -> array_save.Size = array_data_size;
	stack -> array_save.return_addr = addr(retad)->transfer_location;
	stack -> array_save.address, defptr = newptr2;	/* data to be collected */
	retad = array_loop;

subr_join:
	do while(stack->array_save.Size > 0);
	     curptr = defptr -> Array_Data;		/* get next pointer */
	     if curptr = 0 then;
	     else if curptr_type & Numeric then;
	     else if addr(curptr)->lisp_ptr.itsmod ^= "100011"b then;
	     else do;
			defptr -> Array_Data = fakeptr;	/* save fakeptr */
			stack = addrel(stack,6);
			go to copy;
array_loop:		stack = addrel(stack,-6);
			defptr = stack -> array_save.address;
			string_ptr = ptr(defptr,0);		/* segment base ptr */
			fakeptr = defptr -> Array_Data;	/* restore fakeptr */
			defptr -> Array_Data = curptr;	/* store copied data */
			addr(defptr -> Array_Data)->lisp_ptr.chain = string_ptr->segment.chain;
			string_ptr->segment.chain = rel(defptr);
		end;
	     stack -> array_save.Size = stack ->array_save.Size - 2;
	     stack -> array_save.address, defptr = addrel(defptr,2);
	end;

	addr(retad) -> transfer_location = stack -> array_save.return_addr;
	curptr = fakeptr;
	go to retad;

copy_dead_array:
	Size = 8;
	call allocate_static;
	newptrp -> copy_mask = curptrp -> copy_mask;
	newptrp -> array_info.gc_mark = ""b;
	curptrp -> cons.car = already_copied;
	curptrp -> cons.cdr = fakeptr;
	curptr = fakeptr;
	go to retad;

odd_address:					/* fix up odd address pointer here --- array or subr link */
	curptr_odd = "1"b;				/* make it odd */
	stack = addrel(stack,-4);			/* pop stack */
	addr(retad) -> transfer_location = stack -> return;
	go to retad;

/* 

/* now to finish up, copy temporary segments into segments desired, compacting as you go,
   and clean up */

done:	segptr -> saved_env.seg_count = segnumber;
	segptr -> saved_env.seg_size = segment_size;

	/* save the lists of iochans and new type (comp) subr blocks */

	unspec (segptr -> saved_env.iochan_list) = unspec (list_of_iochans);
	unspec (segptr -> saved_env.subr_block_list) = unspec (list_of_subr_blocks);

	segnumber = 0;
	newsegptr = addrel(segptr, segptr -> saved_env.offset_to_first_seg);	/* actually, should be pointing here right now anyway */
	do while(first_save_seg ^= ""b);
	     curptrp = baseptr(first_save_seg);
	     first_save_seg = curptrp -> segment.seg_chain;
	     curptrp -> segment.seg_chain = ""b;
	     this_seg_is_static = curptrp -> segment.seg_type;
	     to_be_copied = binary(curptrp -> segment.seg_size,18,0);
copy_more:     Size = min(to_be_copied,words_left);
	     newsegptr-> copy_mask = curptrp -> copy_mask;
	     words_left = words_left - Size;
	     newsegptr = addrel(newsegptr,Size);
	     to_be_copied = to_be_copied - Size;
	     if to_be_copied > 0 | words_left = 0 then do;
		curptrp = addrel(curptrp,Size);
		segnumber = segnumber + 1;
pm1:		call msf_manager_$get_ptr (file_control_ptr, segnumber, "1"b, segptr, bit_length, code);
		if segptr = null then do;
				call com_err_(code, "lisp_save_", "Correct and type start.");
				call cu_$cl;
				go to pm1;
				end;
		words_left = segment_size;
		newsegptr = segptr;
		if to_be_copied > 0 then goto copy_more;
	     end;
		if this_seg_is_static then call lisp_segment_manager_$free_array(curptrp);
		else call lisp_segment_manager_$free_lists(curptrp);
	end;
	call tssi_$finish_file(file_control_ptr, segnumber,binary(rel(newsegptr),18,0)*36,"1000"b,acinfo,code);
	return;
crump:	call com_err_(code,"lisp_save_","Can't save environment at ^a",
	     pathname_ (dir, ent));
	return;
/* 

/* internal subroutine to allocate storage in temporary segments, and return "symbolc addresses"
   in fakeptr, as well as real addresses */

allocate: proc;

/* allocate Size words, set newptr -> actual place allocated, fakeptr to fake
   pointer to that place which can be put in the saved environment */

	     dcl
	     1 allocation based aligned,
	     2 words(Size) bit(36),
	     2 dbl_word fixed bin(71);


	     if free_allocptr = null then do;
make_seg:		segnumber = segnumber + 1;
		segptr -> saved_env.seg_type(segnumber) = "0"b;
		call lisp_segment_manager_$get_lists(free_allocptr);
		fake_lists_seg = bit(fixed(segnumber, 18), 18);
		if current_save_seg then do;
		     temp_ptr = baseptr(current_save_seg);
		     temp_ptr -> segment.seg_chain = baseno(free_allocptr);
		end;
		else first_save_seg = baseno(free_allocptr);
		current_save_seg = baseno(free_allocptr);
		free_allocptr -> segment.seg_chain = ""b;
		free_allocptr -> segment.seg_type = ""b;
		free_allocptr -> segment.chain = ""b;
		free_allocptr = addrel(free_allocptr,4);
	     end;

	     if binary(rel(free_allocptr),18,0) + Size > segment_size then go to make_seg;

	     newptrp = free_allocptr;
	     unspec(fakeptr) = fake_lists_seg || "000000000000100011"b ||	/* seg idx, its -- ring must be 0 for unsave */
			    rel(free_allocptr);
	     free_allocptr = addr(free_allocptr -> allocation.dbl_word);
	     ptr(free_allocptr,0) -> segment.seg_size = rel(free_allocptr);
	     return;
	end;

/* 

/* internal routine like "allocate", except that a temporary segment used for static is used
   for the allocation */

allocate_static: proc;

dcl  1 allocation based aligned,
     2 words(Size) bit(36),
     2 dbl_word fixed bin(71);

	     if stat_allocptr = null then do;
make_seg:		segnumber = segnumber + 1;
		segptr -> saved_env.seg_type(segnumber) = "1"b;
		call lisp_segment_manager_$get_array(stat_allocptr);
		fake_array_seg = bit(fixed(segnumber, 18), 18);
		if current_save_seg then do;
		     temp_ptr = baseptr(current_save_seg);
		     temp_ptr -> segment.seg_chain = baseno(stat_allocptr);
		end;
		else first_save_seg = baseno(stat_allocptr);
		current_save_seg = baseno(stat_allocptr);
		stat_allocptr -> static_seg_header = static_seg_template;
		stat_allocptr -> segment.seg_chain = ""b;
		stat_allocptr -> segment.seg_type = "1"b;
		stat_allocptr -> segment.chain = ""b;
		stat_allocptr = addrel(stat_allocptr, size(static_seg_header)+2);
	     end;

	     if binary(rel(stat_allocptr),18,0) + Size > segment_size then go to make_seg;
	     newptrp = stat_allocptr;
	     unspec(fakeptr) = fake_array_seg || "000000000000100011"b ||	/* seg idx, its, ring zero for unsave */
			    rel(stat_allocptr);
	     stat_allocptr = addr(stat_allocptr -> allocation.dbl_word);
	     ptr(stat_allocptr,0) -> segment.seg_size = rel(stat_allocptr);
	     return;
	end;

/* 

/* routine to unsave a lisp environment which has been saved by the above */

unsave:	entry(arg,last_stat_seg,last_stat_off,error_code);

dcl last_stat_seg ptr parameter,	/* (output) used to tell make_lisp_subr_block_ about static segs */
    last_stat_off fixed bin(18) parameter, /* (output)  .. */
    error_code fixed bin(35) parameter,	   /* (output) return code.  non zero means couldn't unsave env. */
    cur_ring bit(3) aligned,
    free_size fixed bin;

	error_code = 0;

	/* kludge to fill in validation level in pointer to current validation level */

	segptr = addr(cur_ring);
	cur_ring = addr(segptr)->lisp_ptr.ringnum;

	bucketx = 0;			/* assume no environment conversion will be necessary */

	if arg = "" then do;
	     segptr = addr(lisp_standard_environment_$);
	     file_control_ptr = null();	/* remember we got this from special place */
	     ent = "lisp_standard_environment_";
	end;
	else do;
	     call expand_pathname_$add_suffix (arg, "sv.lisp", dir, ent, code);
	     if code ^= 0 then go to crump_2;
	     call msf_manager_$open (dir, ent, file_control_ptr, code);
	     if code ^= 0 then go to crump_2;
	     call msf_manager_$get_ptr (file_control_ptr, 0, "0"b, segptr, bit_length, code);
	     if segptr = null then go to crump_2;
	     call hcs_$get_link_target (dir, ent, lisp_static_vars_$saved_environment_dir, (32)" ", code);
	     if code ^= 0 then go to crump_2;
	end;
	segnumber = segptr -> save_header.seg_count;	/* works whether old or new format because first part of structure is the same */
	segment_size = binary(segptr -> save_header.seg_size,18,0);
	bucketno = segptr -> save_header.num_gc_ptrs;	/* lisp_static_vars_$number_gc_ptrs at time saved */
	if bucketno >= 0 then do;	/* old format */
	new_format = "0"b;
	if bucketno ^= lisp_static_vars_$number_gc_ptrs then do;	/* Barf! */
	   call com_err_(0, "lisp_save_", "^a is an old format saved environment.  An attempt at conversion will be made.",
			ent);
	   if bucketno = 0 then do;
		call com_err_(0, "lisp_save_", "^a is too inconsistent to be converted.  Resave it.",
						ent);
		error_code = 1;		/* Kludge */
		return;
		end;
	   if bucketno > lisp_static_vars_$number_gc_ptrs
	   then do;
		call com_err_(0, "lisp_save_", "^a cannot be converted.", ent);
		error_code = 1;	/* kludge */
		return;
		end;
	   if bucketno < lisp_static_vars_$number_gc_ptrs
	   then bucketx = bucketno+1;				/* excess cruft will have to be filled */
	   end;

	atomic_constants_addr = addr(segptr -> save_header.next_dbl_word);
	atomic_constants_count = 104;
	rest_of_gc_area_addr = addrel(atomic_constants_addr, 208);
	rest_of_gc_area_count = bucketno - 104;
	first_seg_ptr = addrel(addr(segptr -> save_header.next_dbl_word), 2 * bucketno);
	lisp_static_vars_$maknum_mask = -1;
	end;	/* end of old format stuff */

	else do;		/* new format save header */

	new_format = "1"b;
	bucketx = 0;			/* see about 10 lines before crump_2: */
	if segptr -> saved_env.version_number = 1 then do;	/* old-arrays version */
		amount_of_gensym_data, amount_of_maknum_data = 0;
		must_convert_arrays = "1"b;
		lisp_static_vars_$maknum_mask = -1;
		end;
	else if segptr -> saved_env.version_number <= 3 then do;	/* new-arrays version */
		amount_of_gensym_data = 2;
		if segptr -> saved_env.version_number = 2
		then do;
			lisp_static_vars_$maknum_mask = -1;
			amount_of_maknum_data = 0;
	 	      end;
		else  do;
			amount_of_maknum_data = 5;
			lisp_static_vars_$maknum_data(*) = segptr -> saved_env.maknum_data(*);
		     end;
		must_convert_arrays = "0"b;
		ptr(unmkd_ptr, ""b) -> stack_seg.gensym_data(*) = segptr -> saved_env.gensym_data(*);
		end;
	else do;						/* unreckognized version */
		call com_err_(0, "lisp_save_", "^a is in unknown format #^d; resave it.",
				ent, segptr -> saved_env.version_number);
		error_code = 1;
		return;
		end;

	atomic_constants_addr = addrel(segptr, segptr -> saved_env.atomic_constants.offset);
	atomic_constants_count = segptr -> saved_env.atomic_constants.length;
	rest_of_gc_area_addr = addrel(segptr, segptr -> saved_env.rest_of_gc_area.offset);
	rest_of_gc_area_count = segptr -> saved_env.rest_of_gc_area.length;
	first_seg_ptr = addrel(segptr, segptr -> saved_env.offset_to_first_seg);
	end;

	/* check for minor differences between saved lisp_static_vars_ and current lisp_static_vars_ */

	if (atomic_constants_count > lisp_static_vars_$number_of_atomic_constants + 1) |
	   (rest_of_gc_area_count + atomic_constants_count > lisp_static_vars_$number_gc_ptrs)
	then call com_err_(0, "lisp_save_", "^a was saved with a newer lisp than you are using.^/If you encounter mysterious errors, try re-saving it.",
		pathname_ (dir, ent));

	

/* begin block to allocate space for segment number translation table */

table_alloc: begin;
dcl  segno_table(segnumber) ptr;
dcl  new_chain bit(18),
    (cur_stat,cur_free) ptr init(null),
    no_segs fixed bin init(0),
     seg_offset bit(18),
     i fixed bin,
     j fixed bin,
     next_offset fixed bin(18),
     newptr ptr,
     curptr ptr,
     counter fixed bin(18),
     switch fixed bin;


/* get all needed segments */

	     j = 0;			/* msf component number taking from */
	     newptr = first_seg_ptr;
	     if new_format = "0"b then do i = 1 to segnumber;

		if newptr -> segment.seg_type
		then call lisp_segment_manager_$get_array(segno_table(i));	/* get right type of segment */
		else call lisp_segment_manager_$get_lists(segno_table(i));

		/* now make newptr point at the next segment */

		next_offset = fixed(rel(newptr), 18) + fixed(newptr -> segment.seg_size, 18);
		if next_offset + 2 > segment_size then do;		/* advance segs */
		   next_offset = next_offset - segment_size;		/* Note: all segs must be multiple of */
		   j = j + 1;					/* two words in length or this loses */
		   call msf_manager_$get_ptr(file_control_ptr, j, "0"b, newptr, bit_length, code);
		   if newptr = null() then go to crump_2;
		   end;
		newptr = ptr(newptr, next_offset);
	     end;

	     else do i = 1 to segnumber;
		if segptr -> saved_env.seg_type(i)
		then call lisp_segment_manager_$get_array(segno_table(i));
		else call lisp_segment_manager_$get_lists(segno_table(i));
		end;

/* set lisp_static_vars_$iochan_list from save_header */

	     if new_format = "0"b then
		if segptr -> save_header.iochan_list = null ()
		then lisp_static_vars_$iochan_list = null ();
		else lisp_static_vars_$iochan_list = ptr(segno_table(
					  fixed(baseno(segptr -> save_header.iochan_list), 18)),
					rel(segptr -> save_header.iochan_list));
	     else do;
		if segptr -> saved_env.iochan_list = null ()
		then lisp_static_vars_$iochan_list = null ();
		else lisp_static_vars_$iochan_list = ptr(segno_table(fixed(baseno(segptr -> saved_env.iochan_list), 18)),
					rel(segptr -> saved_env.iochan_list));
		if segptr -> saved_env.subr_block_list = null ()
		then lisp_static_vars_$subr_block_list = null ();
		else lisp_static_vars_$subr_block_list = ptr(segno_table(fixed(baseno(segptr -> saved_env.subr_block_list), 18)),
					rel(segptr -> saved_env.subr_block_list));
		end;

/* unsave atomic_constants portion of lisp_static_vars_ */

	     temp_ptr_1 = addr(lisp_static_vars_$garbage_collected_ptrs);
	     newptr = atomic_constants_addr;

	     do counter = min(lisp_static_vars_$number_of_atomic_constants+1, atomic_constants_count)
		by -1
		while (counter > 0);
		call copy_1_datum;
		end;


copy_1_datum:  proc;	/* moves one double-word and hacks the segment number */

	temp_ptr_1 -> Array_Data = newptr -> Array_Data;
	newptr = addrel(newptr,2);
	if temp_ptr_1->lisp_ptr.type & Numeric then;
	else do;
	     	if temp_ptr_1->lisp_ptr.segno
		then temp_ptr_1->lisp_ptr.segno =
			baseno(segno_table(binary(temp_ptr_1->lisp_ptr.segno,18,0)));
		else do;
			temp_ptr_1->lisp_ptr.segno = system_tv_segno;
			temp_ptr_1->lisp_ptr.offset = temp_ptr_1->lisp_ptr.offset + system_tv_offset;
		     end;
		temp_ptr_1 -> lisp_ptr.ringnum = cur_ring;	/* for 6180 validation info */
	     end;
	temp_ptr_1 = addrel(temp_ptr_1,2);
end copy_1_datum;


	     /* fill in any excess atomic constants that were added to lisp_static_vars_ since this environment
		was saved.  This has to be done here so temp_ptr_1 will maintain correct values */

	     do counter = atomic_constants_count by 1
		while (counter <= lisp_static_vars_$number_of_atomic_constants);	/* Note - there are two +_ bugs which cancel */
		temp_ptr_1 -> Array_Data = lisp_static_vars_$t_atom;	/* almost but not quite right.
								However a warning has been typed out */
		temp_ptr_1 = addrel(temp_ptr_1, 2);
		end;


/* unsave the other S-expression data in lisp_static_vars_ */

	     newptr = rest_of_gc_area_addr;
	     do counter = min(lisp_static_vars_$number_gc_ptrs - lisp_static_vars_$number_of_atomic_constants - 1,
			rest_of_gc_area_count) by -1 while (counter > 0);
		call copy_1_datum;
		end;


	     /* fill in any excess stuff in rest_of_gc_area that was added after this environment was saved */

	     do counter = rest_of_gc_area_count by 1
		while(counter < lisp_static_vars_$number_gc_ptrs - lisp_static_vars_$number_of_atomic_constants - 1);
		temp_ptr_1 -> Array_Data = nil;		/* see comment on previous reference to t_atom */
		temp_ptr_1 = addrel(temp_ptr_1, 2);
		end;

/* unsave the storage segments */

	     newptr = first_seg_ptr;
	     do i = 1 to segnumber;

		curptr = segno_table(i);
		seg_offset = newptr -> segment.seg_size;
		to_be_copied = binary(seg_offset,18,0);

copy_unsave:	Size = min(to_be_copied,segment_size-binary(rel(newptr),18,0));
		curptr -> copy_mask = newptr -> copy_mask;
		newptr = addrel(newptr,Size);
		to_be_copied = to_be_copied - Size;
		if to_be_copied > 0 then do;
		     curptr = addrel(curptr,Size);
		     no_segs = no_segs + 1;
		     call msf_manager_$get_ptr(file_control_ptr, no_segs, "0"b, segptr, bit_length, code);
		     if segptr = null() then go to crump_2;
		     newptr = segptr;
		     go to copy_unsave;
		end;

/* get chain, and chase down it, fixing up the ITS pointers in the chain */

		curptr = segno_table(i);
		new_chain = curptr -> segment.chain;
		if curptr -> segment.seg_type = ""b then do;
		     curptr -> alloc_segment.next_seg = cur_free;
		     cur_free = curptr;
		     free_size = binary(seg_offset,18,0);
		end;
		else do;
		     if cur_stat = null then curptr -> static_seg_header.chain_pointer = null;
		     else curptr -> static_seg_header.chain_pointer = ptr(cur_stat,0);
		     curptr -> static_seg_header.def_pointer = curptr;	/* set definitions pointer for links */
		     cur_stat = ptr(curptr,seg_offset);
		end;

/***** Following 13 lines commented out and replaced by call to alm routine
/*		do while(new_chain);
/*		     curptr = ptr(curptr,new_chain);
/*		     new_chain = curptr -> lisp_ptr.chain;
/*		     if curptr -> lisp_ptr.segno			/* check for offset in tv */
/*		     then curptr -> lisp_ptr.segno = baseno(segno_table(binary(curptr->lisp_ptr.segno,18,0)));
/*		     else do;
/*			     curptr -> lisp_ptr.segno = system_tv_segno;
/*			     curptr -> lisp_ptr.offset = curptr -> lisp_ptr.offset + system_tv_offset;
/*			end;
/*		     curptr -> lisp_ptr.ringnum = cur_ring;		/* make sure validation of indirection
/*								  is for current ring! */
/*		     curptr -> lisp_ptr.chain = "0"b;
/*		end;
/***** End of commented out section *****/

	     call lisp_save_alm_(ptr(curptr, new_chain), addr(segno_table));	/* fix all its pairs in this seg */

	     end;

/* inform allocation routines of new environment */

	     free_size = 4*divide(free_size+3,4,17,0);
	     lisp_alloc_$cur_seg = cur_free;
	     lisp_alloc_$consptr = addr(cur_free -> alloc_segment.tally_word);
	     consptr_ovly.mod = "101011"b;
	     cur_free -> alloc_segment.tally_word.seg_offset = bit(binary(free_size,18,0),18);
	     cur_free -> alloc_segment.tally_word.tally = bit(binary(divide(mod(-1020-free_size,16384),4,18,0),12,0),12);
	     cur_free -> alloc_segment.tally_word.delta = 4;
	     lisp_alloc_$seg_blk_cntr = divide(free_size+1024,16384,17,0) - 16;
	     call lisp_garbage_collector_$set_gc_params;
	     last_stat_seg = ptr(cur_stat,0);
	     last_stat_off = binary(rel(cur_stat),18,0);

	     if new_format = "0"b  then do;

	     /* pick up list of all subr blocks out of header of last static seg */

	     lisp_static_vars_$subr_block_list = last_stat_seg -> static_seg_kludge.saved_list_of_subr_blocks;
	     last_stat_seg -> static_seg_kludge.saved_list_of_subr_blocks = null;
	     end;

/* put maknum stuff in */


	     if lisp_static_vars_$maknum_mask ^= -1
	     then do;
		lisp_static_vars_$maknum_table_ptr = ptr(segno_table(
						fixed(baseno(lisp_static_vars_$maknum_table_ptr),18)),
						rel(lisp_static_vars_$maknum_table_ptr));
		do counter = lbound(maknum_table,1) to hbound(maknum_table,1);
			if string(maknum_table(counter).first)
			then if maknum_table(counter).first.type &Numeric
			then;
			else  maknum_table(counter).second.segno  =  fixed(baseno(segno_table(
								maknum_table(counter).second.segno)),18);
		end;
		lisp_static_vars_$garbage_collect_inhibit = "1"b;
		call  lisp_alloc_$rehash_maknum;
		lisp_static_vars_$garbage_collect_inhibit = "0"b;
		end;



	     if file_control_ptr ^= null()		/* check to see if we used not standard environment */
	     then call msf_manager_$close(file_control_ptr);
	end table_alloc;


	/* clear no snapped links flag since we're not sure if we
	   just unsaved some snapped links */

	lisp_static_vars_$no_snapped_links = "0"b;

	/* code to fill in slots in lisp_static_vars_ that weren't unsaved into - only when converting
	   old environment */

	if bucketx ^= 0 then do;		/* need to fill in end of lisp_static_vars_ */

	   call lisp_get_atom_("++inserted-due-to-conversion-from-old-format++", curptr);	/* KLUDGE, */
	   curptrp -> atom.value = nil;				/* but seems best way to avoid lossage */
	   do while (bucketx ^= lisp_static_vars_$number_gc_ptrs);
	      addr(lisp_static_vars_$garbage_collected_ptrs) -> temp(bucketx) = curptr;
	      end;
	   end;

	/* if necessary, do a garbage collection to convert from old arrays to new arrays */

	if must_convert_arrays then do;
		call com_err_(0, "lisp_save_", "Converting from old arrays to new arrays.");
		call lisp_garbage_collector_;
		end;
	return;
crump_2:	call com_err_(code,"lisp_save_","Can't reload environment from ^a",ent);
	error_code = code;
     end;
