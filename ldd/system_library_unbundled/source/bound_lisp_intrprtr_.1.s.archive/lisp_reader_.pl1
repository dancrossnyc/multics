/* **************************************************************
   *                                                            *
   * Copyright, (C) Massachusetts Institute of Technology, 1973 *
   *                                                            *
   ************************************************************** */
read:	proc;

/*
 * lisp_reader_   which does all formatted input for lisp
 * written 20-JUNE-1972 by David Moon
 * modified 30 June 72 to make read, readch, and tyi lsubr's DAM
 * modified to allow quits while reading,
 *  to allow macro characters in readlist -- D A Moon 14 Aug 72
 * prologue interpreter added 17 Aug 72 D A Moon
 * eof_retn bug fixed, 7 Sep. 72 by DAM
 * Major revisions for increased speed and other good things, 27 Nov 1972, DAM
 * bignum reader added, 14 Jan 1972, dam
 * new (lsubr) version of tyipeek added, dam, 30 jan 73
 * modified for new I/O system, 23 Mar 73 by DAM
 * changed to bind infile, ^q when a file arg is given, 10 June 1973 by dam.
 * modified 21 October 1973 by DAM for new syntax bits, new iochan format.
 * modified 18 February 1974 by DAM for the implode function
 * modified 15 April 1974 by DAM for EIS and to fix bugs in number reader
 * modified 74.05.30 by DAM for new arrays
 * modified 74.09.21 by DAM to accept t for the tty as well as nil
 * modified 28 November 1979 by BSG for top-level splicing macro hacks.
 * modified 5/2/80 by BSG for read_from_list
 * modified 08/20/82 by Richard Lamson to fix tyi EOF handling
 * modified 10/07/82 by Richard Lamson to fix previous fix for tyipeek
 */


dcl fb fixed bin aligned,			/* ascii code for current character */
    1 kludge_structure aligned based(addr(fb)),		/* to make b be right-aligned */
      2 random_garbage_bits bit(27) unaligned,
      2 b char(1) unaligned,			/* this is really the low 9 bits of fb */
    lisp_static_vars_$infile external fixed bin(71),
    infile fixed bin(71) def (lisp_static_vars_$infile),
    bb bit(27),			/* syntax bits for b */
    unm ptr,			/* -> unmarked pdl */
    unm1 ptr,			/* saved value of unm on entry, for eof_retn */
    stack ptr,			/* -> marked pdl */
    errcode(2) fixed bin aligned based,	/* for calls to lisp_error_ */
    implode_sw bit(1),			/* 1 => implode, 0 => maknam */
    tyipeeksw bit(1),			/* so tyipeek can return 3 (ETX or ^C) on EOF */
    special_file bit(1),			/* 1 => have binding block for infile, ^q */
    eolhacksw bit(1),			/* when readlisting, supplies space at end of list */
    eofstack ptr,				/* -> eofval,,special input file */
    origb fixed bin,				/* save untranslated char */
    pnp ptr,			/* -> pname buffer */
    pnamelen fixed bin,		/* number of chars in pname buffer */
    pname_buffer char(pnamelen) aligned based(pnp),
    (real_io, readlistf, read_from_stringf) bit(1),
						/* distinguish between read and*/
						/* readlist and read re-directed to a read list */
    p ptr,
    inp ptr;				/* -> iochan structure for current input channel */

dcl newline char(1) static init("
");


dcl (lisp_static_vars_$quote_macro, lisp_static_vars_$semicolon_macro, lisp_static_vars_$vertical_bar_macro)
	fixed bin (71) aligned external static;		/* special macro indicators */


dcl (ptr, rel, size, null, substr, addr, addrel, fixed, bit, unspec, divide, string,
	add, hbound, lbound, length, max, mod, multiply, float) builtin,
    b2 bit(27),			/* for saving bb */
    bb_wanted bit(27),		/* for tyipeek - matched against bb */

	/* Number Accumulators */

    (nn, n4f) fixed bin(35),
    bign fixed bin(71),
    bigdn fixed bin(71),
    n fixed bin(35),
    dn fixed bin(35),
    one_word_limit fixed bin(71) static init(11111111111111111111111111111111111b),
    nmargs fixed bin(35),
    fn float bin(50),
    ib fixed bin,
    ibv fixed bin aligned based(addr(
	addr(addr(ibase) -> based_ptr -> atom.value) -> fixedb)),		/* value of ibase */
    fpdigits fixed bin,	/* number of digits in fracyion part */
    (bit36, bit36a) bit(36) aligned;	/* for simulated pdp-10 lsh instructions */

dcl i fixed bin,			/* random do-loop index */
    tblp ptr,				/* calculate addr of read_table once only */
    char1 char(1) aligned,
    bfb based fixed bin,
    inlist ptr,			/* to input list for readlist */
    iostatus bit(72) aligned;			/* for calling ios_ */
dcl code fixed bin;		/* implicit argument to internal procedure error */

dcl 1 readlist_data_struc based (readlist_data_strucp) aligned,  /* for multi-frame readlist/readstringery */
    2 inlist ptr,					/* ptr to marked pdl slot with readable Lisp object */
    2 stringf bit (1) aligned,			/* 1 = read_from_string, 0 = readlist */
    2 chrct fixed bin (21);				/* index of next char to be read */

dcl readlist_data_strucp ptr;
dcl 1 auto_readlist_data_struc like readlist_data_struc automatic aligned;

	/* entry points called */

dcl lisp_$apply ext entry,
    lisp_property_fns_$putprop ext entry,
    lisp_list_utils_$subst ext entry,
    lisp_error_ ext entry,
    ios_$read ext entry(char(*) , ptr, fixed bin, fixed bin, fixed bin, bit(72) aligned),
    ioa_ ext entry options(variable),
    lisp_alloc_$gensym ext entry,
    lisp_io_man_$free_uread_chan ext entry,
    make_lisp_subr_block_$make_array ext entry(fixed bin(71) aligned, fixed bin, dim(*) fixed bin, bit(1)),
    lisp_alloc_ ext entry (fixed bin, pointer),
    lisp_bignums_$bnread entry,
    lisp_property_fns_$get entry,
    lisp_special_fns_$ncons ext entry,
    lisp_special_fns_$cons ext entry,
    lisp_array_fcns_$star_array entry;


	/* dcl for bignums */

dcl 1 fnx aligned based(addr(fn)),		/* structure of double floating number - for rou.nding */
      2 exp fixed bin(7) unal,
      2 sign bit(1) unal,
      2 mantissa bit(28) unal,		/* first word + 1 bit for rounding */
      2 rest_of_mantissa bit(35) unal;


dcl bnp ptr,
    bnct fixed bin,
    bnbp ptr,
    dpw fixed bin,
    bnsize fixed bin,
    bndigs(bnsize) fixed bin(35) aligned based(bnbp);	/* array of digits, base bigradix(ib) */


	/* nonstandard argument list for lisp_bignums_$bnread */

dcl 1 bnreadargs based aligned,
     2 array ptr,					/* -> bndigs array */
     2 size fixed bin(17) unal,			/* size of array (in left half) */
     2 pad bit(18) unal,
     2 radix fixed bin(35);				/* radix of bndigs array */
%include lisp_bignum_io_data;
%include lisp_bignum_fmt;


	/* Declaration of state variables */

dcl 1 stacked_variables aligned based(unm),	/* stored on unmkd pdl, stacked by ( and ' */
      2 exitcode fixed bin,			/* specifies where to return from rdobj */
      2 dotted_pair_flag bit(1),		/* used by list reader to remember presence of dot */
      2 left_super fixed bin,			 
      2 right_super fixed bin,

    (splice_dot_kludge init(0),
     topexit init(1),
     quotexit init(2),			/* manifest values for exitcode */
     listexit init(3),
     superexit init(4),			/* superexit = listexit except indicates left super parenthesis */
     list1exit init(5),			/* same as listexit except is for first thing in list */
     super1exit init(6)) fixed bin static,	/* same as superexit except is for first thing in list */

    got_splice bit(1),			/* indicates splicing macro */
    got_macro bit(1),			/* indicates current object is result of a character macro */
    got_something bit(1),			/* indicates that some substantive object was read */
    got_list bit(1),			/* needed by top level newline kludge ,   means a list was read */
    reading_atsym bit(1),			/* for rdbk. */
    reading_number bit(1),			/* .. */
    minus_flag bit(1),			/* for number rdr */
    forced_num bit(1),			/* number introduced by +, containing letters as digits */
    shiftscale_flag bit(1),			/* indicates fixed point number modifier | or _ was seen */
    expon_flag bit(1),			/* indicates an exponent was seen */
    float_flag bit(1),			/* indicates an exponent or a decimal point */
    dbnf bit(1),				/* decimal overflow flag, make bignum if dot at end of number */
    obnf bit(1),				/* other base overflow flag, make bignum if no dot at end of number */
    tyipeek_t bit(1),			/* distinguish (tyipeek t) from other tyipeek */
    in_middle bit(1),			/* in middle of some objects, helps with eof handling */
    dnum bit(1);				/* indicates is a decimal number */


dcl prefsync static bit(1) init("0"b),	 	/* "prefix sync:"  see rdtvx: ff. */
    lisp_fault_handler_$ctrl_from_reader entry(char(1)aligned);


	/* Declaration of stuff in lisp_reader_alm_ */

dcl ten_to_the(-38:38) float bin(50) aligned based(addr(lisp_reader_alm_$powers_of_ten)),
    lisp_reader_alm_$powers_of_ten external static,
    lisp_reader_alm_$left_shift entry(fixed bin(35), fixed bin(35));

%include lisp_name_codes;
%include lisp_faults;

%include lisp_io;
%include lisp_array_fmt;
%include lisp_readtable;

	/* declare combinations of syntax bits that will be needed.
	   this has to be done because the v2pl1 code generator does
	   not do logical-or's of manifest constants at compile time */

dcl (nspblnk	init ("111111101010111111111111111"b),	/* ^( special | blank | vertical_motion ) */
     special_blank	init ("000000000101000000000000000"b),	/* special | blank */
     alpha2	init ("000000000000000000000000011"b),	/* alpha | extd_alpha */
     realchar	init ("000000001010110110000011111"b),	/* single_char_object | lparn | dotted_pair_dot | macro |
					   slashifier | string_quote_exp | shift_scale |
					   plus_minus | digit | extd_alpha | alpha */
     jwnumchar	init ("000000000000000000000001111"b),	/* plus_minus | digit | extd_alpha | alpha */
     jwnumchar2	init ("000000000000000000000000101"b),	/* digit | alpha */
     bothdots	init ("000000000000010000010000000"b),	/* dotted_pair_dot | decimal_point */
     goodbegin	init ("000000001001100110000001111"b),	/* blank | lparn | macro | slashifier | string_quote_exp |
					   plus_minus | digit | extd_alpha | alpha */
     brkchr1	init ("000000001011111100000000000"b),	/* single_char_object | blank | lparn | dotted_pair_dot |
					   rparn | macro | string_quote_exp */
     nbrkchr	init ("000000000000000010010011111"b)	/* slashifier | shift_scale | plus_minus | digit | decimal_point |
					   extd_alpha | alpha */
    ) bit(27) static;

%include lisp_stack_fmt;
%include lisp_common_vars;
%include lisp_nums;
%include lisp_cons_fmt;
%include lisp_ptr_fmt;
%include lisp_atom_fmt;
%include lisp_error_codes;
%include lisp_string_fmt;

	/* fancy entry points to the reader */

/*read:	entry;		/* lisp read function */

	tyipeeksw = "0"b;
	eolhacksw = "1"b;
	call eof_hack;
	readlistf = "0"b;
	call set_inp;			/* find current input channel */
	call set_tblp;
readcom:	unm = unmkd_ptr;
	unmkd_ptr = addrel(unm, 4);		/* set up toplevel stacked variables */

	/* Make sure the obarray is really an obarray, since much lossage could otherwise result */

	call verify_obarray;

	exitcode = topexit;
rdcom1:	stack_ptr = addr(stack -> temp(2));	/* room in which to work */
	go to rdobj0;			/* go get something */
exit(1):
	if got_macro & got_splice		/* top level splicing macro */
	then if stack -> temp_type (1) = Cons		/* Atoms mean naught */
	     then if stack -> temp_ptr (1) -> cons_types.cdr = Cons
		then do;
		     code = badmacro;		/* 2 or more objs at top level ng */
		     call error;
		     end;
		else stack -> temp (1) = stack -> temp_ptr (1) -> cons.car; /* Take 1st elmt */
	     else go to rdobj0;			/* "those nasty splicing read macros at top level " */
	if ^got_something then go to rdobj0;			/* ignore junk like extra right parens */

	if readlistf then do;		/* end of readlist/read-from-string */
	     inlist -> temp(1) = stack -> temp(1);  /* move return value down */
	     stack_ptr = addr(inlist -> temp(2));
		unm = err_recp;
		rdr_state = sv_rdr_state;
		rdr_label = sv_rdr_label;
		rdr_ptr = sv_rdr_ptr;
		err_recp = ptr(unm, fault_save.prev_frame);
		unmkd_ptr = unm;
	     return;
	     end;

	if got_list then if fb=10 then go to drop_nl;		/* drop newline after list for MACLISP
				compatiblity -- unlike Multics, the PDP-10 needs no newline after ")" */
	if bb & nspblnk

		/* nondisposable break char - save it */

	     then if real_io
		then inp -> iochan.ioindex = inp -> iochan.ioindex - 1;	/* back up buffer */
		else if readlist_data_struc.stringf
		     then readlist_data_struc.chrct = readlist_data_struc.chrct - 1;
		else do;		/* cons the character back onto the list */
		     stack_ptr = addr(stack -> temp(4));
		     stack -> temp(3) = inlist -> temp(1);
		     addr(stack -> temp(2))-> fixnum_fmt.type_info = fixnum_type;
		     addr(stack -> temp(2))-> fixedb = fb;
		     call lisp_special_fns_$cons;
		     inlist -> temp(1) = stack -> temp(2);
		     end;

drop_nl:
	eofstack -> temp(1) = stack -> temp(1);		/* value to be returned */

eof_retn:
	if special_file then call eofhack_unbind;	/* restore infile, ^q */
	unmkd_ptr = unm1;
	stack_ptr = addr(eofstack -> temp(2));
	return;

read_from_string: entry;				/* 5/2/80 BSG */
	read_from_stringf = "1"b;
	go to readlist_join;

readlist: entry;

	read_from_stringf = "0"b;
readlist_join:
	tyipeeksw = "0"b;
	readlistf = "1"b;				/* for return */
	special_file = "0"b;
	call set_tblp;
	stack = stack_ptr;
	inlist = addrel(stack, -2);			/* underneath the working stack is our arg */
rfs_retry:
	if read_from_stringf
	then if ^(inlist -> temp_type(1) = String
	 | inlist -> temp_type(1) = Atsym) then do;
		unm = unmkd_ptr;	/* bad_arg_correctable error */
		unmkd_ptr = addrel(unm, 2);
		unm -> errcode(1) = bad_arg_correctable;
		unm -> errcode(2) = fn_read_from_string;
		call lisp_error_;	/* the bad arg is already on stack */
		go to rfs_retry;	/* Error Recovery -- new value for arg is on stack */
		end;

	if ^read_from_stringf & inlist -> temp(1) = nil
	then do;				/* special case (readlist nil) => (ascii 0) */
		fb = 0;
		stack = inlist;
		call get_sing_char;
		return;
		end;

	/* save the state of the reader in case this readlist is in a macro-char function */

	unm = unmkd_ptr;
	unmkd_ptr = addrel(unm, size(fault_save));
	fault_save.prev_frame = rel(err_recp);
	fault_save.stack_ptr = rel(stack);
	fault_save.sv_gc_inhibit = gc_inhibit;
	fault_save.code1 = 0;			/* indicate no error associated with this fault_save */
	fault_save.sv_array_info = null();		/* we're not in the middle of an array opertaion */
	sv_rdr_label = rdr_label;
	sv_rdr_ptr = rdr_ptr;
	sv_rdr_state = rdr_state;
	err_recp = unm;

	readlist_data_strucp = addr (auto_readlist_data_struc);
	readlist_data_struc.inlist = inlist;
	readlist_data_struc.stringf = read_from_stringf;
	readlist_data_struc.chrct = 1;
	rdr_ptr = addr (readlist_data_struc);
	rdr_state = 2;				/* so that macros will read from the readlist */
	real_io = "0"b;
	eolhacksw = "1"b;			/* so no <space> need be supplied to terminate an atom */
	go to readcom;

maknam:	entry;

	implode_sw = "0"b;
	go to maknam_joint;

implode:	entry;

	implode_sw = "1"b;
maknam_joint:

	stack = addrel(stack_ptr, -2);		/* -> arg which is list of chars */
	unm = unmkd_ptr;
	call pnamesetup;
	do while (stack -> temp_type(1) = Cons);
	     if stack -> temp_ptr(1) -> cons_types36.car & Fixed36
	       then do;				/* number is ascii code for char */
		fb = addr(stack -> temp_ptr(1) -> cons.car) -> fixedb;
		if fb < 0 then go to maknamloss;
		if fb >= 128 then go to maknamloss;
		end;
	     else if stack -> temp_ptr(1) -> cons_types36.car & Atsym36
	       then b = substr(stack -> temp_ptr(1) -> cons_ptrs.car -> atom.pname, 1, 1);
	     else go to maknamloss;

	     call pnameput;				/* deposit character into pname buffer */
	     stack -> temp(1) = stack -> temp_ptr(1) -> cons.cdr;
						/* advance input list */

	     end;
	if implode_sw then call get_atom;
	else call make_name;
	unmkd_ptr = pnp;				/* clear unmkd pdl */
	return;

	/* come here in the even of  of an error while maknam'ing */

maknamloss:
	stack -> temp(1) = stack -> temp_ptr(1) -> cons.car;	/* the losing "character" */
	go to err_2;


readstring:	entry;		/* Here is the lisp 'readline' function, formerly called readstring */

	tyipeeksw = "0"b;
	eolhacksw = "1"b;
	call eof_hack;
	call char_read_setup;
	call set_inp;
	call pnamesetup;
rs_loop:
	call rdinch;
	if b = newline	then	do;
			call lisp_alloc_(divide(pnamelen+7, 4, 17, 0), stack -> temp_ptr(1));
			stack -> temp_type(1) = String;
			stack -> temp_ptr(1) -> lisp_string.string_length = pnamelen;
			stack -> temp_ptr(1) -> lisp_string.string = pname_buffer;
			go to drop_nl;	/* return it */
			end;
	/* normal character, put it in */

	in_middle = "1"b;				/* we are now really reading something */
	call pnameput;
	go to rs_loop;

char_read_setup: proc;

	in_middle = "0"b;
	reading_atsym, reading_number = "0"b;
	unm = unmkd_ptr;
	unmkd_ptr = addrel(unm, size(stacked_variables));
	exitcode = 1;	/* necessary to make end of file in readline work properly */
	call set_tblp;	/* required by rdinch */
	end;

	/* come here to read in one object */

rdobj0:	/* reset all the state variables that need to be reset */

	got_macro,
	got_something,
	got_list,
	reading_atsym,
	reading_number,
	minus_flag,
	forced_num,
	expon_flag,
	float_flag,
	in_middle,
	dnum,
	dotted_pair_flag,
	shiftscale_flag = "0"b;

rdobj1:	call rdchar;
rdobj:
	if bb & blank then go to rdobj1;		/* skip over blanks */


	else if bb & alpha2 then do;	/* atomic symbol */
		call pnamesetup;
obtain_pname:	call pnameput;
rdnumo_aa:	reading_atsym = "1"b;			/* so rdchar will know what to do with break char */
read_Atloop:	call rdchar;
		call pnameput;
		go to read_Atloop;

	/* rdchar jumps to here when the break char is detected */

rdaend:		got_something = "1"b;			/* because of random 'goto rdaend' somewhere */
		reading_atsym = "0"b;
		call get_atom;			/* find the atom in hash table */
		call reset_tblp;		/* garbage collector may have moved readtable */
		unmkd_ptr = pnp;			/* flush the pname buffer */
		go to exit(exitcode);

	/* come here when a number is discovered to be really an atomic symbol */

rdnumo:		reading_number,
		minus_flag,
		expon_flag,
		float_flag,
		dnum = "0"b;
		go to rdnumo_aa;
		end;

		/* LIST READER */

	else if bb & lparn then do;
		unm = unmkd_ptr;			/* push stacked-variables */
		unmkd_ptr = addrel(unm, 4);
		if bb & bit12 then do;
			left_super = origb;
			right_super = fb;	/* expected matching right super parenthesis */
			exitcode = super1exit;
			end;
		     else exitcode = list1exit;
		dotted_pair_flag = "0"b;
		stack -> temp(1) = nil;		/* initially no list has been read */
		call rdchar;			/* skip over the left parenthesis */

rdlst3x:		stack_ptr = addr(stack -> temp(4));	/* stack contains:
						   1 -> list being read.
						   2 -> last cons in list being read, to be rplacd'ed
						   3 =  temp storage for object being read in list
						 */
		stack = addr(stack -> temp(3));

rdlst3a:		go to rdobj;



		/* come back here after reading an element of any kind of list */

exit(3):
exit(4):
exit(5):
exit(6):

		if dotted_pair_flag then go to rdlst4;
		if got_macro then do;
		      got_macro = "0"b;		/* Turn off flag */
		      if ^got_splice then go to rdlst2;
		      else do;		/* ^splicing is regular stuff */
			got_something = "0"b;			/* in case it is nothing */
			if stack -> temp_type(1) then go to rdlst3a;	/* if it is nothing, go away */

			   /* copy the list to be spliced in and remember its ending cons */
			   /* only have to copy top level */

			stack = addrel(stack, -4);
			stack_ptr = addr(stack -> temp(7));
			stack -> temp(4) = nil;
			do while (stack -> temp_type(3) = Cons);
			     stack -> temp(6) = stack -> temp_ptr(3) -> cons.car;
			     stack -> temp(3) = stack -> temp_ptr(3) -> cons.cdr;

			     call lisp_special_fns_$ncons;
			     call reset_tblp;		/* garbage collector may have moved readtable */
			     if stack -> temp(4) = nil then	/* remember start of list */
				stack -> temp(4) = stack -> temp(6);
			      else stack -> temp_ptr(5) -> cons.cdr = stack -> temp(6);
							/* or chain list together */
			      stack -> temp(5) = stack -> temp(6);	/* remember last cons in list */
			     end;
			stack -> temp(3) = stack -> temp(5);
splice_it_in:
				/*
				   1 -> list being built up
				   2 -> last cons in that list, unless first time
				   3 -> new last cons
				   4 -> cons to be added to end of list (usually same as 3)
				 */
			if exitcode >= list1exit		/* if first time */
			 then do;
			      exitcode = exitcode - 2;	/* is no longer first time */
			      stack -> temp(1) = stack -> temp(3);	/* set ptr to 1st cons in list */
			      end;
			 else stack -> temp_ptr(2) -> cons.cdr = stack -> temp(4);
			stack -> temp(2) = stack -> temp(3);	/* new last cons in list */
			got_something = "0"b;
			go to rdlst3x;			/* keep on reading list */
			end;
		     end;

		else if got_something then do;
rdlst2:			stack = addrel(stack, -4);		/* get back our own stack */
			stack_ptr = addr(stack -> temp(4));
			call lisp_special_fns_$ncons;
			call reset_tblp;		/* garbage collector may have moved readtable */
			stack_ptr = addr(stack -> temp(5));
			stack -> temp(4) = stack -> temp(3);
			go to splice_it_in;
			end;


		else if bb & rparn then			/* some kind of right parenthesis */
rparn_proc:	  if bb & bit12 then do;

			/* RIGHT SUPER-PARENTHESIS */

			if exitcode = listexit then go to supply_right;
			if exitcode = list1exit then go to supply_right;
			if exitcode = superexit then go to check_super_match;
			if exitcode = super1exit then   
check_super_match:		    if right_super ^= fb then

				/* mismatched super parentheses -- barf! */

				go to err_mmsp;
			else go to rdlst_r_p;		/* matches left-super */

			go to err_nlsp;		/* matches quote or toplevel, error */
						/* ignores leading ) but not leading ] */

			/* (...] causes ) to be inserted before the ] */

supply_right:		got_something = "1"b;
			stack = addrel(stack, -4);		/* pop back */
			stack_ptr = addr(stack -> temp(2));
			unmkd_ptr = unm;
			unm = addrel(unm, -4);
			got_list = "1"b;
			if exitcode < listexit		/* returning to toplevel or quote,
							    enough )'s have been supplied */
			     then go to rdex;
			else go to exit(exitcode);		/* returning to list, keep on supplying )'s */
			end;
		  else do;
		/* REGULAR RIGHT PARENTHESIS */

			if exitcode = superexit then go to supply_left;
			if exitcode = super1exit then go to supply_left;

rdlst_r_p:		stack = addrel(stack, -4);		/* pop back */
			stack_ptr = addr(stack -> temp(2));
			unmkd_ptr = unm;
			unm = addrel(unm, -4);

			/* put in a pseudo space as next char so no read off end of file */

rdex:			bb = ^nspblnk;
			fb = 128;		/* doesn't matter */
			got_something = "1"b;
			got_list = "1"b;
			go to exit(exitcode);

			/* [ ... ) --> [(...)
			   that is, a left super parenthesis may only match a right super parenthesis, not a ) */

supply_left:		stack = addrel(stack , -4);
			stack_ptr = addr(stack -> temp(3));
			stack -> temp(2) = nil;
			call lisp_special_fns_$cons;		/* make list with present list as 1st elem */
			call reset_tblp;		/* garbage collector may have moved readtable */
			exitcode = superexit;		/* have read first thing now. */
			call rdchar;			/* skip over the right paren */
			go to rdlst3x;			/* keep reading looking for right super paren */
			end;

		/* must be right paren missing */

parn_missing:		code = parenmissing;

		call error;


	/* dotted pair processor */

rdlst4:		if got_macro
		then if got_splice
		     then if stack -> temp_type (1) = Cons
			then if stack -> temp_ptr (1) -> cons_types.cdr = Cons
			     then go to dot_loses;	/* no multi-lists */
			     else stack -> temp (1) = stack -> temp_ptr (1) -> cons.car;
		     else do;			/* Got nothing */
			got_macro, got_something = "0"b;
			go to rdobj;
			end;
		got_macro = "0"b;
		if ^got_something then go to dot_loses;		/* (a.) not allowed */
		if exitcode >= list1exit then go to dot_loses;	/* (. not allowed */
		/* if exitcode = super1exit then go to dot_loses;	/* [. not allowed */

			/* OK, attach to end of list */

		stack = addrel(stack, -4);
rdlst39:		stack -> temp_ptr(2) -> cons.cdr = stack -> temp(3);
rdlst40:
		if bb & rparn then do;
			stack = addrel(stack, 4);		/* put back where we found it */
			go to rparn_proc;			/* and go handle the right paren in the usual way */
			end;

		if bb & realchar then;
		  else do;
			call rdchar;
			go to rdlst40;
			end;

		/* check for splicing macro at end of dotted list, move it up to before the dot */

		if bb & macro then if bb & splice then do;

			got_splice = "1"b;
			stack_ptr = addr(stack -> temp(5));
			stack = addr(stack -> temp(4));
			unm = unmkd_ptr;
			unmkd_ptr = addrel(unm, 4);		/* push stacked-variables */
			exitcode = splice_dot_kludge;		/* set to come back after expanding macro */
			go to proc_macro;
exit(0):			
			unmkd_ptr = unm;
			unm = addrel(unm, -4);
			stack = addrel(stack, -6);

			/* contents of stack:
			     temp(1) - list being built (first)
			     temp(2) - list being built (last)
			     temp(3) - cdr of dotted pair
			     temp(4) - value of splicing macro
			 */

			got_something, got_splice = "0"b;
			if stack -> temp_type(4) = Cons then do; /* really splice (if atom, dotted pair already set up on end of list) */
				stack_ptr = addr(stack -> temp(4));
				go to dot_loses;
				end;
			call reset_tblp;		/* garbage collector may have moved readtable */
			go to rdlst39;
			end;

		/* loser forgot to put right paren after dotted pair */

		code = parenmissing;
		call error;



		end;
	else if bb & digit then go to rdnum;


	else if bb & plus_minus then do;		/* object begins with a + or a - */
		call pnamesetup;			/* in case it turns out to be an atomic symbol */
		call pnameput;			/* save the + or the - */
		if bb & bit12 then minus_flag = "1"b;
		in_middle = "1"b;
		call rdchar;
		in_middle = "0"b;

		/* if (status +) is t, use White's base>10 "+" hack */

		if plus_status = nil then
		     if bb & jwnumchar then
			if bb & digit then go to rdnum2;	/* yes, it really seems to be a number */
			  else 	/* no, it's actually an atomic symbol */
			     do;
			      minus_flag = "0"b;
			      go to obtain_pname;	/* so read rest of it */
			     end;
		       else;
		  else if bb & jwnumchar2 then do;	/* White's + hack, forces it to be a number */
			forced_num = "1"b;
			go to rdnum2;
			end;


		/* plus not followed by digit or letter */

		if bb & decimal_point then do;
		     in_middle = "1"b;
		     call rdchar;
		     in_middle = "0"b;
		     if bb & digit then go to rdobj5;		/* -.d floating point */
		     end;
	     else if bb & special then 	/* just + by itself */
		   do;
		     minus_flag = "0"b;	/* turn off flag */
		     go to rdaend;
		   end;

		/* not a recognizable form */

		go to ill_obj;
		end;



	else if bb & dotted_pair_dot then do;
		b2 = bb;	/* save the dot or decimal point */
		in_middle = "1"b;
		call rdchar;	/* and look ahead a little */
		in_middle  = "0"b;
		if bb & digit then
		     if b2 & decimal_point then do;	/* .d floating point */

rdobj5:			dnum, float_flag = "1"b;
			n4f = 0;		/* set up to get fraction part */
			go to rdnum;
			end;

		/* OK, must be a dotted pair */

		if dotted_pair_flag then go to dot_loses; /* can't have two dotted pairs in a row */
						/* i.e a dotted triple */
		dotted_pair_flag = "1"b;
		if bb & goodbegin then;
		  else
dot_loses:		do; code = doterror; call error; end;

		go to rdobj;		/* OK, go get second half of dotted pair */
		end;

	else if bb & decimal_point	/* period with syntax as decimal point but not dotted pair dot */
	     then go to rdnum;	/* rdnum will decide if it is flonum or atomic symbol */

	else if bb & string_quote_exp then if bb & bit12 then do;	/* read a string */
		in_middle = "1"b;
		call pnamesetup;				/* make a buffer */
stringer:		call rdinch;
		bb = tblp -> syntax(fb);		/* We want to see slashes! */
		if bb & string_quote_exp then if bb & bit12 then go to end_maybe;
put_stringer:
		call pnameput;
		go to stringer;

end_maybe:	call rdinch;		/* in case "" which means " inside string */
		bb = tblp -> syntax(fb);
		if bb & string_quote_exp then if bb & bit12 then go to put_stringer;

		/* really end of string */

		in_middle = "0"b;
		call lisp_alloc_(1+divide(pnamelen+3, 4, 17, 0), p);
		p -> string_length = pnamelen;
		p -> lisp_string.string = pnp -> pname_buffer;
		stack -> temp_ptr(1) = p;
		stack -> temp_type(1) = String;
		got_something = "1"b;			/* we read something substantial */
		unmkd_ptr = pnp;			/* remove pname buffer from unmkd pdl */
		call reset_tblp;		/* garbage collector may have moved readtable */

		/* pretend current char was read by rdchar instead of rdinch */

		origb = fb;
		fb = tblp -> translation(fb);

		go to exit(exitcode);
		end;
	     else;	/* PROPER BALANCE OF IF CLAUSES IS IMPERATIVE */



	else if bb & macro then do;			/* macro character */
		if bb & splice then got_splice = "1"b;
		  else got_splice = "0"b;
proc_macro:
					/* b=index in macro_table (unless someone clobbered it) */
		if fb <= 0 then go to bad_mac;
		if fb <= num_macs then stack -> temp(1) = tblp -> macro_table(fb);
		  else do;	/* have to search list */
			stack -> temp(1) = tblp -> more_macros;
			do fb = -fb by 1 to -10;	/* take a sufficient number of cdrs */

			     if stack -> temp(1) = nil then go to bad_mac;
			     if stack -> temp_type(1) then go to bad_mac;
			     stack -> temp(1) = stack -> temp_ptr(1) -> cons.cdr;
			     end;
			if stack -> temp(1) = nil then go to bad_mac;
			if stack -> temp_type(1) then goto bad_mac;
			stack -> temp(1) = stack -> temp_ptr(1) -> cons.car;
			end;
		stack_ptr = addr(stack -> temp(3));
		if stack -> temp(1) = lisp_static_vars_$quote_macro	/* check for internal macros */
				then go to special_quote_macro;
		else if stack -> temp(1) = lisp_static_vars_$semicolon_macro
				then go to special_semicolon_macro;
		else if stack -> temp(1) = lisp_static_vars_$vertical_bar_macro
					then go to special_vertical_bar_macro;
		stack -> temp(2) = nil;
		call lisp_$apply;			/* apply macro function to nil */
				/* It's easy now that those delayed read macros have been flushed */
		call set_inp;			/* in case the macro fcn changed the input dev. on us */
		call set_tblp;			/* in case bastard changed readtable */
semicolon_macro_join:
		if tyipeeksw then go to tyipeek_proc_macro_ret;
		fb = 131;			/* pseudo-space */
		bb = special_blank;
special_macro_join:
		got_macro, got_something = "1"b;		/* got_splice already set */
		go to exit(exitcode);

bad_mac:		fb = origb;
		call get_sing_char;		/* convert to an atom with pname of the macro char */
		do; code = badmacro; call error; end;

		end;


	else if bb & single_char_object then do;
		call get_sing_char;
		go to rdex;
		end;


	/* not good object begin char, just return it and let our caller figure it out */

	go to exit(exitcode);

rdchar:	proc;		/* get a char, return numeric code in fb, syntax bits in bb */


get_another:

	call rdinch;
	origb = fb;			 		/* save untranslated char code */
	fb = tblp -> translation(fb);				/* translate char code */
	if bb & special then;
	  else return;				/* ordinary char */

	/* see if it's a break char */

	if bb & brkchr1 then go to rdbk;
											/* Yes */
	  else if bb & nbrkchr
	    then if bb & slashifier then do;
		/* slash - make next char look like extd_alpha */

		call rdinch;
		bb = extd_alpha;
		return;
		end;
	       else return;	/* alpha or something with special somehow set */
	    else go to get_another;	/* worthless - skip it */


rdbk:	/* we read a break character - want to do something about it? */

	if reading_atsym then go to rdaend;		/* these tests _m_u_s_t be in this order */
	  else if reading_number then go to rdnum4;
	else return;



	end rdchar;

	/* all this proc does is get a char in fb and set bb to its syntax */
rdinch:	proc;

dcl unm ptr,
    sco char (1),
    cde fixed bin,
    lisp_io_control_$fix_not_ok_iochan entry(ptr, bit(1) aligned) returns(bit(1)aligned),
    lisp_io_control_$end_of_block entry (ptr, fixed bin(71), fixed bin),
    input_buffer_overlay char(inp -> iochan.iolength) aligned based(inp -> iochan.ioptr);


rdinch_aa:
        fb = 0;				/* clear bits in fb not set by setting b */
        if real_io then do;

	if string(inp -> iochan.flags) & not_ok_to_read then
	   if lisp_io_control_$fix_not_ok_iochan(inp, "0"b) then do;	/* get new input source */
		call set_inp;
		call reset_tblp;		/* garbage collector may have moved readtable */
		go to rdinch_aa;
		end;
	if inp -> iochan.ioindex >= inp -> iochan.iolength then do;	/* ran out of chars, do something */

		call lisp_io_control_$end_of_block(inp, eofstack -> temp(1), cde);
		call reset_tblp;		/* garbage collector may have moved readtable */
		go to tv(cde);			/* action to take depends on what lisp_io_control_ did */
tv(2):		if tyipeeksw then do;
tyipeek_eof:	     fb = 3;
		     go to tyicom;
		     end;
		if eofstack -> temp_type36(1) & Float36 then	/* top level loop - as a conveneneince, */
		     if eofstack -> fixedb = 0 then		/* check for eof in middle of object even for cde=2 */
			go to tv(1);
		go to eof_retn;

tv(-1):		call set_inp;
		go to rdinch_aa;

tv(0):		if inp -> iochan.interactive then read_print_nl_sync = "1"b;	/* tty is at left margin now */
		go to rdinch_aa;			/* OK, process next block */

tv(1):		/* err if in middle of object (EOF) */

		if tyipeeksw then go to tyipeek_eof;

		if in_middle then go to g0001;
		else if exitcode ^= 1 then
	     g0001:  do;
			unm = unmkd_ptr;
			unmkd_ptr = addrel(unm, 2);
			unm -> errcode(1) = eof_in_object;
			call lisp_error_;
			call reset_tblp;		/* garbage collector may have moved readtable */
			go to tv1cont;		/* user interrupt function said to continue anyway */
			end;
		if cde = 1 then if reading_atsym | reading_number then do;
			fb = 131;			/* pseudo-space - break out of this atom */
			bb = special_blank;
			return;
			end;
tv1cont:	 
		if cde = 2 then go to eof_retn;	/* see tv(2): */
		call set_inp;
		go to rdinch_aa;			/* not in an object, continue reading */

		end;

	inp -> iochan.ioindex = inp -> iochan.ioindex + 1;
	b = substr(input_buffer_overlay, inp -> iochan.ioindex, 1);
	if fb >= 128 then go to rdinch_aa;			/*** ignore non-ascii characters */

	/* this kludge is so that bsg's ec's can input control characters.
	   If a \036=\r=^|^| is seen, it is taken as a prefix and
	   the following char is a ctrl char unless it is 036 too. */

	if fb = 030	/* 036 octal */
	     then if prefsync then prefsync = "0"b;	/* double -- let it through */
		else do;
		     prefsync = "1"b;		/* so come back here on next character */
		     go to rdinch_aa;
		     end;
	     else if prefsync then do;		/* character following prefix = fb */
		prefsync = "0"b;
		if b = "?" then 		/* handle this one specially */
		     if inp = tty_input_chan then call ioa_(";reading from terminal.");
		      else call ioa_(";reading from file.");
		else call lisp_fault_handler_$ctrl_from_reader((b));
		call set_inp;			/* input source may have been changed */
		call reset_tblp;		/* garbage collector may have moved readtable */
		go to rdinch_aa;
		end;

	/* vertical motion checking */

	bb = tblp -> syntax(fb);		/* get syntax for here and elsewhere's use */
	if bb & vertical_motion
	then if ^ tyipeeksw
	then call proc_vertical_motion;

	return;
	end;

        else   /* fake io */;

          if readlist_data_struc.stringf then do;		/* read from string */
	     if inlist -> temp_type(1) & Atsym then do;
		if readlist_data_struc.chrct > inlist -> temp_ptr(1) -> atom.pnamel then go to readlist_eof;
		sco = substr (inlist -> temp_ptr(1) -> atom.pname, readlist_data_struc.chrct, 1);
	     end;
	     else do;
		if readlist_data_struc.chrct > inlist -> temp_ptr(1) -> lisp_string.string_length then go to readlist_eof;
		sco = substr (inlist -> temp_ptr(1) -> lisp_string.string, readlist_data_struc.chrct, 1);

	     end;
	     if ^tyipeeksw then readlist_data_struc.chrct = readlist_data_struc.chrct + 1;
	     fb = fixed (unspec (sco), 9);
	     bb = tblp -> syntax (fb);
	     return;
	end;
	if inlist -> temp_type(1) then  /* EOF */
readlist_eof:
	     if tyipeeksw then do;			/* could be tyipeek in readlist in char macro */
		fb = 3;
		go to tyicom;
		end;
	     else if eolhacksw then do;

		/* for readlist, supply one pseudo-space at end of list so atoms will terminate */

		eolhacksw = "0"b;		/* do this once only, in case parentheses mismatch */
supply_pseudo_space:
		fb = 131;
		bb = special_blank;
		return;
		end;
	     else go to err_1;		/* Mustn't call error except from immediately containing lexical block */

	if inlist -> temp_ptr(1) -> cons_types.car & Fixed then do;
		fb = addr(inlist -> temp_ptr(1) -> cons.car) -> fixedb;
		if fb < 0 then go to readlistloses;
		  else if fb > 131 then go to readlistloses;
		end;

	  else if inlist -> temp_ptr(1) -> cons_types.car & Atsym then do;
			/*Atomic Symbol, use first char of pname */

		b = substr(inlist -> temp_ptr(1) -> cons_ptrs.car -> atom.pname, 1, 1);
		end;
	  else do;		/* loser in input list */
readlistloses:
		inlist -> temp(1) = inlist -> temp_ptr(1) -> cons.car;	/* the losing elem */
		stack_ptr = addr(inlist -> temp(2));
		go to err_2;
		end;

	/* set syntax for this character that we just read */

	bb = tblp -> syntax(fb);

	/* read a char, so advance input list to next */

	if ^tyipeeksw then
	  inlist -> temp(1) = inlist -> temp_ptr(1) -> cons.cdr;
	return;
	end rdinch;

set_inp: proc;		/* to find the input file to be used and set the pointer inp
			   to point to its iochan block.  In the event
			   of a re-entry to a readlist (e.g. because of a call to read
			   from inside the function called by a macro character found
			   in a readlist), real_io and inlist are set up */


	if ^special_file then		/* be sure to allow read macro fcn to escape to tty with (read nil) */
	  if rdr_state = 2 then do;		/* re-entry to readlist */
	     real_io = "0"b;
	     readlist_data_strucp = rdr_ptr;
	     inlist = readlist_data_struc.inlist; /* -> stack cell containing ptr to list being read from */
	     return;
	     end;

	if addr(ctrlQ)->based_ptr -> atom.value = nil then	/* input from tty */
		inp = tty_input_chan;
	else if addr(infile)->based_ptr -> atom.value = nil |	/* input from tty anyway */
	        addr(infile)->based_ptr -> atom.value = t_atom then do;
default_to_tty:	inp = tty_input_chan;
		if ^special_file then addr(ctrlQ)->based_ptr -> atom.value = nil;	/* make toplevel win */
		end;
	else if addr(
		addr(infile)->based_ptr -> atom.value
		  )->lisp_ptr_type & File36 then inp = addr(infile)->based_ptr -> atom_ptrs.value;	/* take from file */
	else go to default_to_tty;				/* infile set bad, just take from tty */

	real_io = "1"b;			/* reading from iochan pointed at by inp */


	return;

     end set_inp;

increment_input_ptr:
      proc;
      if ^ real_io then
      if readlist_data_struc.stringf then readlist_data_struc.chrct = readlist_data_struc.chrct + 1;
      else inlist -> temp(1) = inlist -> temp_ptr(1) -> cons.cdr;
      else if bb & vertical_motion then call proc_vertical_motion;
end increment_input_ptr;


proc_vertical_motion: proc;		/* character with vertical_motion syntax in fb, do all good things */

	if ^ real_io then return;
	inp -> iochan.charpos = 0;	/* NL and NP always cause return to left margin */
	inp -> iochan.nlsync = "1"b;
	if fb = 12 then go to new_page;	/* NP character */

	inp -> iochan.linenum = inp -> iochan.linenum + 1;	/* NL character */
	if inp -> iochan.pagel = 0 then return;			/* infinite pages */
	if inp -> iochan.pagel > inp -> iochan.linenum 		/* or page not yet exceeded */
	then return;
new_page:
	inp -> iochan.linenum = 0;
	inp -> iochan.pagenum = inp -> iochan.pagenum + 1;	/* advance to top of a new page */

	return;						/* no endpagefn's on input files */

end proc_vertical_motion;

	/* internal proc to get readtable, make tblp point at it */

set_tblp:	proc;

dcl stack ptr;

	   /* make sure readtable is an array */

	if addr(
	    addr(readtable) -> based_ptr -> atom.value)
		-> lisp_ptr_type & Array36 then;
			else go to err;

	/* make sure it is a Readtable array */

	if addr(readtable)-> based_ptr -> atom_ptrs.value
		-> array_info.type ^= Readtable_array then go to err;

reset_tblp: entry;

	tblp = addr(read_table);		/* set ptr to array structure for later use */
	return;

err:	/* bad readtable, attempt to fix it then signal error */

	stack = stack_ptr;
	stack_ptr = addr(stack -> temp(3));
	stack -> temp(1) = readtable;			/* get array property of readtable, */
	stack -> temp(2) = array_atom;		/* which should be the original readtable */
	call lisp_property_fns_$get;
	if stack -> temp(1) ^= nil then
	     addr(readtable) -> based_ptr -> atom.value = stack -> temp(1);

	code = badreadtable;
	call error;

	end set_tblp;


	/* declaration of obarray, and internal proc to make sure that the
	   value of the atom obarray is really an obarray */

dcl htptr ptr,			/* temp pointer to hash table */

    1 obarray_struct based(htptr) aligned,
      2 hash_table(0:510) fixed bin(71),
      2 char_objects(0:127) fixed bin(71);


verify_obarray: proc;

dcl stack ptr;

	if addr(
	     addr(obarray)->based_ptr -> atom.value)
		-> lisp_ptr_type & Array36 then;
	   else go to err;		/* not an array, barf */

	if addr(obarray)->based_ptr -> atom_ptrs.value -> array_info.type ^= Obarray_array
	then go to err;

	return;			/* obarray is OK */

err:	/* bad obarray, attempt to fix it then signal error */

	stack = stack_ptr;
	stack_ptr = addr(stack -> temp(3));
	stack -> temp(1) = obarray;		/* get the array prop of obarray, which should be the initial obarray */
	stack -> temp(2) = array_atom;
	call lisp_property_fns_$get;
	if stack -> temp(1) ^= nil then
	     addr(obarray)->based_ptr -> atom.value = stack -> temp(1);

	code = badobarray;
	call error;			/* uncorrectable error - for now */

	end verify_obarray;


	/* Single - Character Readers */

real_tyi:	entry;

	tyipeeksw = "0"b;
	eolhacksw = "0"b;
	call eof_hack;
	call char_read_setup;
	call set_inp;
	call rdinch;
	if special_file then call eofhack_unbind;
tyicom:	stack_ptr = addr(eofstack -> temp(2));
	eofstack -> fixnum_fmt.type_info = fixnum_type;
	eofstack -> fixedb = fb;
	unmkd_ptr = unm1;
	return;

real_tyipeek:	entry;

	special_file = "0"b;			/* fix a lotta things - BSG 5/4/80 */
	tyipeek_t = "0"b;
	tyipeeksw = "1"b;
	eolhacksw = "0"b;
	unm1 = unmkd_ptr;				/* We will need this later. */
	call char_read_setup;
	stack = addrel(stack_ptr, -2);		/* lsubr - get argcount */
	nmargs = stack -> fixedb;
	eofstack = addrel(stack, nmargs);
	stack_ptr = addr(eofstack -> temp(4));
	stack = addr(eofstack -> temp(3));
	if nmargs = -2 then go to tyipeek_wierd;		/* we have an argument, go do strange things */
	eofstack -> temp(1) = t_atom;
	call set_inp;

	call rdinch;
typk5:	if real_io then inp -> iochan.ioindex = inp -> iochan.ioindex - 1;
	go to tyicom;


tyipeek_wierd:
	stack -> temp(1) = eofstack -> temp(1);		/* our arg */
	eofstack -> temp(1) = t_atom;
	call set_inp;				/* input from default input source, in tyipeek mode (eof sp.) */

tyipw_retry:
	if stack -> temp(1) = t_atom then do;
			nmargs = 177806848;		/* 1246217000 octal */
			tyipeek_t = "1"b;
			end;

	 else do;
	    if stack -> fixnum_fmt.type_info ^= fixnum_type then do;	/* bad arg - barf */
	   	unm = unmkd_ptr;
		unmkd_ptr = addrel(unm, 2);
		unm -> errcode(1) = bad_arg_correctable;
		unm -> errcode(2) = fn_tyipeek;
		call lisp_error_;
		call reset_tblp;		/* garbage collector may have moved readtable */
		go to tyipw_retry;
		end;
	    nmargs = stack -> fixedb;		/* fetch argument */
	    end;
	if nmargs >= 512 /* "1000"b3 */ then go to tyipeek_really_wierd;

	/* search for the character n, position read ptr just before it */

tyipw_loop:
	call rdinch;			/* get a character */
	if fb = nmargs then go to typk5;		/* if this is the one we want go finish up */
	if ^real_io then
	     if readlist_data_struc.stringf then readlist_data_struc.chrct = readlist_data_struc.chrct + 1;
	     else inlist -> temp(1) = inlist -> temp_ptr(1) -> cons.cdr;	/* patch up for readlist macro */
	else if bb & vertical_motion then call proc_vertical_motion;
	go to tyipw_loop;

tyipeek_really_wierd:

	/* searching for character of specified syntax */

	bb_wanted = substr(unspec(nmargs), 1, 27);		/* nmargs is syntax bits * 1000 octal */
						/* align and change to a bit string */

tyipww_loop:
	call rdinch;			/* get a character */
	if tyipeek_t then if bb & macro then if bb & splice then do;
		call increment_input_ptr;
		got_splice = "1"b;
		fb = tblp -> translation(fb);
		go to proc_macro;
tyipeek_proc_macro_ret:
		go to tyipww_loop;
		end;
	if bb & bb_wanted then go to typk5;		/* found what we were looking for */
	call increment_input_ptr;
	go to tyipww_loop;


real_readch:	entry;

	tyipeeksw = "0"b;
	eolhacksw = "0"b;
	call eof_hack;
	call char_read_setup;
	call set_inp;
	call rdinch;
	if special_file then call eofhack_unbind;
	stack = eofstack;
	stack_ptr = addr(stack -> temp(2));
	call get_sing_char;
	unmkd_ptr = unm1;
	return;

	/* The lisp ascii function which converts a number  to an atomic symbol */

ascii:	entry;

ascii_retry:
	call set_tblp;
	stack = addrel(stack_ptr, -2);
	if stack -> temp_type36(1) & Fixed36 then;	/* winner */
	  else do;
ascii_err:
		unm = unmkd_ptr;	/* bad_arg_correctable error */
		unmkd_ptr = addrel(unm, 2);
		unm -> errcode(1) = bad_arg_correctable;
		unm -> errcode(2) = fn_ascii;
		call lisp_error_;	/* the bad arg is already on stack */
		go to ascii_retry;	/* Error Recovery -- new value for arg is on stack */
		end;

	fb = stack -> fixedb;
	if fb < 0 then go to ascii_err;
	else if fb > 511 then go to ascii_err;
	call get_sing_char;
	return;




	/* THE NUMBER READER */


rdnum:
	call pnamesetup;			/* in case it's really an atomic symbol */

	/* obtain value of ibase */
rdnum2:
get_ibase:
	if addr(addr(ibase)->based_ptr -> atom.value) -> temp_type36(1) & Fixed36 then;
	  else 
bad_ibase_:	begin;
		dcl unmm ptr;
		unmm = unmkd_ptr;
		unmkd_ptr = addrel(unmm, 2);
		unmm -> errcode(1) = bad_ibase;
		call lisp_error_;
		call reset_tblp;		/* garbage collector may have moved readtable */
		go to get_ibase;
		end;
	ib = ibv;	/* ... the value of ibase */
	if ib < 2 then go to bad_ibase_;	/* check range since going to use ib as index into arrays */
	if ib >= 37 then go to bad_ibase_;	/*	bigradix and digsperwd */

	call pnameput;
	n = 0;				/* number to base ibase is accumulated here */
	dn = 0;				/* number to base 10 is accumulated here */
	dbnf, obnf = "0"b;			/* clear overflow flags */
	fpdigits = 0;				
	reading_number = "1"b;

rdnum1a:	if bb & digit then do;
	/* found a digit -- accumulate the number */

rdnum5:	fb = fb - 48;
	bigdn = add(dn*10, fb, 71, 0);		/* check for overflow */
	if bigdn > one_word_limit then dbnf = "1"b;	/* and if so, have decimal bignum */
	else do;
	     dn = bigdn;				/* we can legally assign here */
	     fpdigits = fpdigits + 1;			/* in case we are in a fraction part */
	     end;
	bign = add(n*ib, fb, 71, 0);			/* check for overflow */
	if bign > one_word_limit then obnf = "1"b;	/* again check for legal assignment. */
	else n = bign;
			/* Fall into rdnum1 */
rdnum1:	call rdchar;
	call pnameput;
	go to rdnum1a;
	end;

	else if bb & decimal_point then

proc_dec_point:
	     if dnum then go to ill_obj;	/* can't be a decimal point */
	     else if expon_flag then if shiftscale_flag then;	/* allow . in fixed point scale, */
			       else go to ill_obj;	/* but not in floating exponent */
	     else do;
		b2 = bb;
		dnum = "1"b;		/* in case break char follows, will go to rdnum4 */
		if ^ real_io then stack -> temp(1) = inlist -> temp(1);
		call rdchar;		/* look ahead & find out what kind of decimal point */
		call pnameput;		/* don't lose the character */
		if bb & digit then
		     if shiftscale_flag then go to ill_obj;	/* loser tried to shift fractional bits */
		     else do;
			float_flag, dnum = "1"b;	/* make floating number of form ddd.ddd */
			n4f = dn;			/* save integer part */
			dn = 0;
			fpdigits = 0;
			go to rdnum5;
			end;
		else if bb & string_quote_exp then
		     if bb & bit12 then;
			else go to make_fake_mantissa;	/* ddd.Ennn floating number */
		else if bb & shift_scale then do;
		     n = dn;			/* shift or scale a decimal number */
		     go to rdnumss;
		     end;

		/* randomness after a decimal point, might really be a dotted pair */

		if b2 & dotted_pair_dot then do;
		     dnum = "0"b;			/* wasn't really a decimal point */
		   if real_io then
		        inp -> iochan.ioindex = inp -> iochan.ioindex - 1;	/* back up to the dot */
		   else if readlist_data_struc.stringf then readlist_data_struc.chrct = readlist_data_struc.chrct - 1;
		   else inlist -> temp(1) = stack -> temp(1);
							/* This counteracts the lookahead */
							/* that we did before */
		     bb = b2 & ^decimal_point;
		     go to rdnum4;			/* finish number, later dotted pair will be found */
		     end;
		else go to not_really_a_number;
		end;

	else if bb & string_quote_exp then
	     if bb & bit12 then go to rdnumalph;
	     else if forced_num then go to rdnumalph;	/* in this case, e is digit not exponent mark */
	     else do;
					/* exponent marker */
		if expon_flag then go to ill_obj;	/* sorry, only one to a customer */
		if shiftscale_flag then go to ill_obj;	/* .. */
		if ^float_flag then do;	/* fake the fraction part */

make_fake_mantissa:	     n4f = dn;
		     dn = 0;
		     fpdigits = 0;
		     end;
		if minus_flag then do;
		     minus_flag = "0"b;
		     n4f = -n4f;
		     dn = -dn;
		     end;
		float_flag, expon_flag, dnum = "1"b;
		if fpdigits < lbound(ten_to_the, 1) then go to flonum_out_of_range;
		if fpdigits >= 1+hbound(ten_to_the, 1) then go to flonum_out_of_range;
		fn = float(n4f, 50) + float(dn, 50) * ten_to_the(-fpdigits);
		n, dn = 0;
		go to rdnewnum;		/* go get the exponent */
		end;
	else
rdnumalph:     if bb & alpha then			/* letter in a number */
	     if forced_num then do;		/* The + hack, take it as a digit */
		if fb < 96 then fb = fb - 7;	/* so A comes out as 10 */
		else fb = fb - 39;		/* so a comes out as 10 */
		go to rdnum5;		   /* just as if it were a digit */
		end;
	     else go to rdnumo;		/* surprise, it really was an atomic symbol */


	else if bb & shift_scale then do;
	     if shiftscale_flag then go to ill_obj;

rdnumss:	     shiftscale_flag = "1"b;		/******** SHOULD DO BIGNUM SCALING HERE **********/
	     if minus_flag then do;
		minus_flag = "0"b;
		n = -n;
		end;
	     if bb & bit12 then; else expon_flag = "1"b;	/* scale */
	     if dnum then nn = dn; else nn = n;	/* have the thing to be shifted or scaled */
	     dnum = "0"b;

	     n, dn = 0;				/* go read shift factor or scale factor */
	     go to rdnewnum;
	     end;


	else /* some random crud in number */
not_really_a_number: if forced_num then go to ill_obj;
		 else go to rdnumo;	/* so make it an atomic symbol instead */

rdnewnum:	call rdchar;
	call pnameput;
	if bb & plus_minus then do;
		if bb & bit12 then minus_flag = "1"b;
		go to rdnum1;
		end;
	go to rdnum1a;



	/* break char found */

rdnum4:	if bb & decimal_point then go to proc_dec_point;	/* don't want decimal points to
						be break characters when in a number */
	if shiftscale_flag then do;			/* perform a shift/scale operation that was requested earlier */
	     if dnum then n = dn;		/* if decimal shift factor */
	     shiftscale_flag, dnum = "0"b;
	     if minus_flag then go to ill_obj;	/* It would be easy to do, but for some reason MACLISP
					   doesn't allow it */
	     if expon_flag then do;

			/* SCALE */

		expon_flag = "0"b;
		do i = 1 to n;		/* fastest way since n is small unless the user is also a loser */
		     nn = nn * ib;
		     end;
		end;
	     else do;

		call lisp_reader_alm_$left_shift(nn, n);
		end;

ret_fix:	     stack -> fixedb = nn;
	     stack -> fixnum_fmt.type_info = fixnum_type;

ret_num:	     forced_num = "0"b;
	     got_something = "1"b;		/* so they know we returned something */
	     unmkd_ptr = pnp;		/* flush pname buffer */
	     reading_number = "0"b;
	     go to exit(exitcode);
	     end;
	else if expon_flag then do;		/* the rest has already been floated and put in fn */

	     expon_flag, float_flag, dnum = "0"b;
	     if minus_flag then do;
		minus_flag = "0"b;
		dn = -dn;
		end;
	     if dn < lbound(ten_to_the, 1) then go to flonum_out_of_range_1;
	     if dn >= 1+hbound(ten_to_the, 1) then go to flonum_out_of_range_1;
	     fn = fn * ten_to_the(dn);
ret_float:
	/* round the mantissa by using a based overlay on fn */

	if fn >= 0 then do;
	     nn = fixed(fnx.mantissa)+1;		/* add 1 to first bit beyond first word of mantissa */
	     if substr(unspec(nn), 8, 1) then do;	/* overflow, renormalize */
		unspec(nn) = "0"b||unspec(nn);	/* right shift mantissa 1 place */
		n = fnx.exp + 1;			/* and add one to exponent */
		if n >= 128 then go to flonum_out_of_range;  /* if exp overflows */
		fnx.exp = n;			/* if no overflow, put new exp back */
		end;
	     fnx.mantissa = substr(unspec(nn), 9, 28);	/* put rounded mantissa back in fn */
	     end;

	   else do;	/* same code for negative number */
	     nn = fixed(fnx.mantissa)+1;
	     if substr(unspec(nn), 9, 1) then do;	/* must renormalize */
		unspec(nn) = "0"b||unspec(nn);
		n = fnx.exp + 1;
		if n >= 128 then go to flonum_out_of_range;
		fnx.exp = n;
		end;
	     fnx.mantissa = substr(unspec(nn), 9, 28);
	     end;

	     stack -> floatb = fn;
	     stack -> flonum_fmt.type_info = flonum_type;
	     go to ret_num;
	     end;

	else if float_flag then do;		/* ddd.ddd with no exponent */

	     float_flag, dnum = "0"b;
	     if fpdigits < lbound(ten_to_the, 1) then go to flonum_out_of_range_2;
	     if fpdigits >= 1+hbound(ten_to_the, 1) then go to flonum_out_of_range_2;
	     fn = float(n4f, 50) + float(dn, 50) * ten_to_the(-fpdigits);
	     if minus_flag then do;
		fn = -fn;
		minus_flag = "0"b;
		end;
	     go to ret_float;
	     end;

	else if dnum then do;
	     dnum = "0"b;
	     if dbnf then go to decimal_bignum;
	     nn = dn;
	     go to rfx;
	     end;

	/* just an ordinary number */

	if obnf then go to read_bignum;
	nn = n;
rfx:	if minus_flag then do;
		nn = -nn;
		minus_flag = "0"b;
		end;
	go to ret_fix;



	/* come here when floating number has exponent out of bounds */

flonum_out_of_range:
flonum_out_of_range_1:
flonum_out_of_range_2:

	code = flonum_too_big;
	call error;

	/* bignum reader */

	/* extract the bignum from the pname buffer, convert it first to a larger base such
	   that each digit almost fills up a word, then call the lisp_bignums_ module
	   to convert the bignum to the proper internal form */

decimal_bignum:
	ib = 10;

read_bignum:
	bnct = 0;
	bnp = pnp;

	/* check if there is a sign at the beginning that has to be dropped */

	fb = 0;
	b = substr(pname_buffer, 1, 1);
	if b >= "a" then if b <= "z" then go to rdbn1;	/* valid digit (in some bases) */
	if b >= "A" then if b <= "Z" then go to rdbn1;	/* .. */
	if b >= "0" then if b <= "9" then go to rdbn1;	/* .. */
	call getbnc;				/* random char at beginning, skip over it */
	pnamelen = pnamelen - 1;

	/* set up array into which to put digits to base bigradix(ib) */

rdbn1:	bnbp = unmkd_ptr;		/* allocate the array on the unmkd pdl */
	dpw = digsperwd(ib);
	bnsize = divide(pnamelen+dpw-1, dpw, 17, 0);  /* size of array */
	n = bnsize;
	if substr(unspec(n), 36, 1) then n=n+1;		/* make even */
	unmkd_ptr = addrel(bnbp, n);

	nn = (bnsize-1) * dpw;	/* number of full words */
	dn = 0;
	do i = 1 to pnamelen - nn;	/* do the first word, which may contain less than dpw digits */
		call getbnc;
		dn = dn*ib + fb;
		end;
	bndigs(1) = dn;		/* put first word into array */

	/* now do the rest of the digits */

	do nn = 2 to bnsize;	/* loop for each word in bndigs, except the first one */
	     dn = 0;
	     do i = 1 to dpw;	/* loop for each digit going to go into this word */
		call getbnc;
		dn = dn*ib + fb;
		end;
	     bndigs(nn) = dn;
	     end;

	/* now call bignum module to add and multiply by bigradix to convert this to a real bignum */

	stack_ptr = stack;		/* the bignum will be pushed on */
	bnp = unmkd_ptr;
	unmkd_ptr = addrel(bnp, size(bnreadargs));
	bnp -> bnreadargs.array = bnbp;
	bnp -> bnreadargs.radix = bigradix(ib);
	bnp -> bnreadargs.size = bnsize;
	call lisp_bignums_$bnread;
	unmkd_ptr = pnp;		/* clear all this garbage off the unmkd pdl */
	if minus_flag then do;		/* make the bignum negative if necc. */
	     minus_flag = "0"b;
	     if stack -> temp_ptr(1) -> lisp_bignum.prec = 2	/* check for special case */
	     then if stack -> temp_ptr(1) -> lisp_bignum.words(1) = 0
		then if stack -> temp_ptr(1) -> lisp_bignum.words(2) = 1
		     then do;
			     stack -> fixnum_fmt.type_info = fixnum_type;
			     unspec(stack -> fixedb) = "100000000000000000000000000000000000"b;
			     go to done_negating;
			end;
	     stack -> temp_ptr(1) -> lisp_bignum.sign = (18)"1"b;
done_negating:
	     end;
	   else stack -> temp_ptr(1) -> lisp_bignum.sign = (18)"0"b;

	forced_num, reading_number = "0"b;
	got_something = "1"b;
	call reset_tblp;		/* garbage collector may have moved readtable */
	go to exit(exitcode);



/* routine to get char from pname buffer for bignum.  Returns digit value in fb */

getbnc:	proc;

	fb = 0;
	bnct = bnct+1;
	b = substr(bnp -> pname_buffer, bnct, 1);
	if fb < 64 then fb = fb - 48;		/* 0 to 9 */
	else if fb < 96 then fb = fb - 55; 	/* A to Z */
	else fb = fb - 87;			/* a to z */
	return;
	end getbnc;

		/* pname - buffer handlers */

pnamesetup:	proc;		/* init pname buffer */

	pnamelen = 0;
	pnp = unmkd_ptr;	/* put pname buffer in the unmarked pdl */
	unmkd_ptr = addrel(pnp, 2);
end;

pnameput:	proc;			/* deposit byte into pname buffer */

	pnamelen = pnamelen+1;
	substr(pname_buffer, pnamelen, 1) = b;
	if (unspec(pnamelen) & "000000000000000000000000000000000111"b) = (36)"0"b
	then do;		/* need another double word */
	     unmkd_ptr = addrel(unmkd_ptr, 2);
	     end;
end;

	/* fast routines for the two builtin macro characters */

special_quote_macro:

	unm = unmkd_ptr;
	unmkd_ptr = addrel(unm, 4);
	exitcode = quotexit;
	go to rdcom1;	/* read the S-expression to be quoted */

exit(2):
	if got_macro & got_splice then		/* here we go again */
	     if stack -> temp_type (1) = Cons
	     then if stack -> temp_ptr (1) -> cons_types.cdr = Cons
		then go to err_qm;
		else stack -> temp (1) = stack -> temp_ptr (1) -> cons.car;
	     else do;
		got_something, got_macro = "0"b;
		go to rdobj;
		end;
	if ^ got_something then go to err_qm;		/* ') is illegal */
				/* and cons up a list of it */
	stack_ptr = addr(stack -> temp(4));
	stack -> temp(3) = nil;
	stack -> temp(2) = stack -> temp(1);
	stack -> temp(1) = quote_atom;
	call lisp_special_fns_$cons;
	call lisp_special_fns_$cons;
	unmkd_ptr = unm;			/* pop */
	unm = addrel(unm, -4);
	got_splice = "0"b;			/* bug... */
	call reset_tblp;		/* garbage collector may have moved readtable */
	go to special_macro_join;

special_semicolon_macro:

read_1_line: call rdinch;
	if fb = 10  /* ascii newline */ then do;
	     stack -> temp(1) = nil;			/* splice () is a no-op */
	     stack_ptr = addr(stack -> temp(2));
	     go to semicolon_macro_join;
	     end;
	  else go to read_1_line;

special_vertical_bar_macro:
	dcl firstfb fixed bin;
	firstfb = origb;
	in_middle = "1"b;
	call pnamesetup;
	call rdinch;

	do while(fb ^= firstfb);	/* | */
	     if fb ^= 10	/* newline */
	     then do;
		if bb & slashifier then call rdinch;	      /* slash protects next char */
		call pnameput;
		end;
	     call rdinch;
	end;

	in_middle = "0"b;
	call get_atom;	    /* get an atom in */
	unmkd_ptr = pnp;
	got_splice = "0"b;
	call reset_tblp;
	fb = 131;
	bb = special_blank;
	go to special_macro_join;

eof_hack: proc;		/* processes the arguments to read, etc lsubrs */

	stack = addrel(stack_ptr, -2);		/* -> argcount*-2 */
	eofstack = addrel(stack, stack -> fixedb);	/* -> args */
	stack_ptr = addr(eofstack -> temp(4));
	if stack -> fixedb = 0 then do;		/* no args */
		eofstack -> temp(1) = nil;		/* no eofval */
		special_file = "0"b;		/* no bindings */
		end;
	else if stack -> fixedb = -2 then		/* 1 arg */
	     if eofstack -> temp_type36(1) & File36 then go to g0002;
	     else if eofstack -> temp(1) = t_atom then go to g0002;
	     else if eofstack -> temp(1) = nil then do;
	g0002:	eofstack -> temp(2) = eofstack -> temp(1);	/* special input source */
		eofstack -> temp(1) = nil;			/* no eofval */
		go to special_inp;
		end;
	     else special_file = "0"b;		/* eofval given, but no special input source */
	else					/* 2 args */
	     if eofstack -> temp_type36(2) & File36 then go to special_inp;	/* 1st arg is eofval, 2nd is file */
	     else if eofstack -> temp(2) = nil then go to special_inp;	/* .. */
	     else if eofstack -> temp(2) = t_atom then go to special_inp;	/* .. */
	     else do;				/* interchange args */
		eofstack -> temp(3) = eofstack -> temp(1);
		eofstack -> temp(1) = eofstack -> temp(2);
		eofstack -> temp(2) = eofstack -> temp(3);
		if eofstack -> temp(2) = nil then go to special_inp;	/* yes, 2nd arg is file */
		else if eofstack -> temp_type36(2) & File36 then go to special_inp;
		special_file = "0"b;		/* no of those four goto's went, so ignore extra arg */
		end;

	stack = addr(eofstack -> temp(3));		/* initial free slot */
	unm1 = unmkd_ptr;				/* save unmkd_ptr so can restore when done */
	return;

special_inp:		/* bind infile to arg in eofstack -> temp(2), ^q to t */

	special_file = "1"b;		/* remember to get rid of binding block before returning */
	stack_ptr = addr(eofstack -> temp(7));	/* room for binding block plus eofval cell plus temp(6) cell */
	stack = addrel(eofstack, 2);			/* -> bindings */
	eofstack -> temp(6) = eofstack -> temp(2);	/* save value to bind infile to */
	stack -> bindings(1).atom = infile;
	stack -> bindings(2).atom = ctrlQ;
	stack -> bindings(1).old_val = addr(stack -> bindings(1).atom)->based_ptr -> atom.value;
	stack -> bindings(2).old_val = addr(stack -> bindings(2).atom)->based_ptr -> atom.value;
	unm1 = unmkd_ptr;
	unmkd_ptr = addrel(unm1, 2);
	unm1 -> binding_block.bot_block = rel(stack);
	unm1 -> binding_block.top_block = rel(addr(stack -> bindings(3)));
	unm1 -> binding_block.back_ptr = rel(binding_top);
	unm1 -> binding_block.rev_ptr = ""b;
	binding_top = unm1;

	addr(infile)->based_ptr -> atom.value = eofstack -> temp(6);	/* specified input source */
	addr(ctrlQ)->based_ptr -> atom.value = t_atom;			/* enable it */

	stack = addr(eofstack -> temp(6));		/* first cell available to program */
	end;


eofhack_unbind: proc;			/* get rid of binding block created above */
					/* called shortly before returning if special_file is found to be 1 */

	stack = ptr(stack_ptr, binding_top -> binding_block.bot_block);	/* -> bindings on marked pdl */
	addr(stack -> bindings(1).atom)->based_ptr -> atom.value =
		stack -> bindings(1).old_val;
	addr(stack -> bindings(2).atom)->based_ptr -> atom.value =
		stack -> bindings(2).old_val;		/* this better not be somebody else's bindings ! */
	binding_top = ptr(binding_top, binding_top -> binding_block.back_ptr);
	end;		/* caller will flush stacks */

err_1:	code = shortreadlist;
	call error;

err_2:	code = badreadlist;
	call error;

err_mmsp:	code = mismatch_super_parens;
	call get_sing_char;			/* actual right paren */
	stack = addrel(stack, 2);
	stack_ptr = addr(stack -> temp(2));
	fb = right_super;			/* expected right paren */
	call get_sing_char;
	call lisp_special_fns_$cons;		/* so user can see them */
	call error;

err_nlsp:	code = no_left_super_paren;
	call error;

err_qm:	code = quoterror;
	call error;

ill_obj:	code = illobj;
	call error;

tma_err:	code = too_many_args;
	call error;

	/* ERROR INTERFACE */

error:	proc;

	unm = unmkd_ptr;
	unmkd_ptr = addrel(unm, 2);
	unm -> errcode(1) = code;
	call lisp_error_;
	end;

	/* The LISP makreadtable function, which copies the read table */

makreadtable: entry;		/* just a write-around to *array now */

	/* check for an arg of nil, which he have to replace with a gensym'ed atom */

	stack = addrel(stack_ptr, -2);
	obnf = "0"b;
	if stack -> temp(1) = nil then do;
makgensym:     stack -> fixnum_fmt.type_info = fixnum_type;
	     stack -> fixedb = 0;				/* gensym is an lsubr */
	     call lisp_alloc_$gensym;
	     end;
	else if stack -> temp(1) = t_atom then do;	/* (makreadtable t) - copy initial onto a gensym */
	     obnf = "1"b;
	     go to makgensym;
	     end;

	stack_ptr = addr(stack -> temp(6));
	stack -> temp(2) = stack -> temp(1);
	stack -> temp(3) = lisp_static_vars_$readtable;
	if obnf
	then stack -> temp(4) = t_atom;
	else stack -> temp(4) = nil;
	addr(stack -> temp(5)) -> fixnum_fmt.type_info = fixnum_type;
	addr(stack -> temp(5)) -> fixedb = -6;
	call lisp_array_fcns_$star_array;

	stack_ptr = addr(stack -> temp(2));	/* return the atom which is still sitting under here */
	return;

lisp_get_atom_: entry (name, location);

/* procedure to find an atom by name, and intern it on the current obarray.
   Redone completely for the unsharing of nil and the PL/I null pointer. 
   New hash function, 16 Nov 1972, DAM */

dcl name char(*) aligned,
    extra_stuff bit(36) aligned based(addrel(pnp, namelen)),	/* last word in pname */
    kludgey_mask (1:4) static bit(36) aligned initial(	/* for clearing extra bits at end of pname */
	"777000000000"b3,				/* 1 mod 4, 3 extra chars */
	"777777000000"b3,				/* 2 mod 4, 2 extra chars */
	"777777777000"b3,				/* 3 mod 4, 1 extra char */
	"777777777777"b3),				/* 4 chars in last word */
    namelen fixed bin,
    location fixed bin(71) aligned,


    indx fixed bin,
    name_word fixed bin (35) aligned based,
    cnt fixed bin,
    stac ptr;

	call verify_obarray;		/* make sure user hasn't bound obarray to nil or something */
	pnamelen = length(name);
	pnp = addr(name);
	stack = addr(location);			/* where to put the ptr to atom */
	call get_atom;
	return;

get_atom:	proc;

dcl esw fixed bin, maknamsw bit(1) init("0"b);


	/* gets an atom whose name is of length pnamelen beginning at loc pnp,
	   a pointer
	   to the resulting atom is put in stack -> temp(1) */


	esw = 1;

get_atom_join:

/* hash code name */

	 		/* add up all words in name, does not rely on knowing
				   that unused chars are filled with \\000 */


		/* NB: there is a copy of this algorithm 2 pages further on,
		   under the entry hash_fcn.  */

       if pnamelen = 0 then indx = 511;	/* ascii 0 is in char_objects(0) */
         else if pnamelen = 1 & rank (substr(pname_buffer, 1, 1)) <= 127
	    then indx = 511 + rank (substr(pname_buffer, 1, 1)); /* char_objects(fb) */
         else do;
	namelen = divide(pnamelen-1, 4, 17, 0);		/* length of pname - 1 */
	unspec(indx) = extra_stuff & kludgey_mask(pnamelen - 4*namelen);	/* get last word */
	do cnt = 0 to namelen-1;		/* add up all words except last word */
	     indx = indx + addrel(pnp, cnt) -> name_word;
	     end;
	indx = mod(indx, 509);
        end;

/* get hash table pointer */

	htptr = addr(obarray)->based_ptr->atom_ptrs.value -> array_info.array_data_ptr;


/* now lookup in bucket */

      if indx >= 511 then do;	/* if in char_objects array, is not a bucket!! */
	stack -> temp(1) = char_objects(indx-511);
	if stack -> temp(1) = nil then go to make_new;	/* if no atom yet interned in this slot */
	go to atom_rtn(esw);
	end;
      else do;		/* in a bucket, have to go through the bucket - searching code */
	stac = stack_ptr;

	stack_ptr = addr(stac -> temp(3));


	do stac -> temp(1) = hash_table(indx) repeat stac -> temp_ptr(1) -> cons.cdr
	     while(stac -> temp(1) ^= nil);

	     stac -> temp(2) = stac -> temp_ptr(1) -> cons.car;
	     if stac -> temp_ptr(2) -> atom.pnamel = pnamelen
	     then if substr(stac->temp_ptr(2)->atom.pname,1,pnamelen) = substr(pname_buffer,1,pnamelen)
		then do;
			stack -> temp(1) = stac -> temp(2);
			stack_ptr = stac;
			go to atom_rtn(esw);
		     end;
	end;
      end;


/* not found, so make a new atom */

make_new:
	call lisp_alloc_(divide(pnamelen+23,4,17,0),stack->temp_ptr(1));

	stack -> temp_type(1) = Atsym;


	stack -> temp_ptr(1) -> atom_double_words.value = Undefined;
	stack -> temp_ptr(1) -> atom.pnamel = pnamelen;
	substr(stack -> temp_ptr(1) -> atom.pname,1,pnamelen) = substr(pname_buffer,1,pnamelen);
	stack -> temp_ptr(1) -> atom.plist = nil;
	if maknamsw then return;		/* if entered via make_name */
      if indx >= 511 then char_objects(indx-511) = stack -> temp(1);	/* put in proper place in obarray */
      else do;
	stac -> temp(1) = stack -> temp(1);
	htptr = addr(obarray)->based_ptr->atom_ptrs.value -> array_info.array_data_ptr;
	stac -> temp(2) = hash_table(indx);
	call lisp_special_fns_$cons;
	htptr = addr(obarray)->based_ptr->atom_ptrs.value -> array_info.array_data_ptr;
	hash_table(indx) = stac -> temp(1);
	stack_ptr = stac;
      end;
      go to atom_rtn(esw);

atom_rtn(1):
	return;
get_sing_char: entry;

dcl a_char char(1);
dcl char_obj fixed bin(71) aligned based(charobjp),
    charobjp ptr;

          htptr = addr(obarray)->based_ptr->atom_ptrs.value -> array_info.array_data_ptr;
	if fb > 127 then go to make_new_sing_char;
	charobjp = addr(char_objects(fb));
	if char_obj = nil then
	     do;
make_new_sing_char: if fb = 0 then pnamelen = 0;		/* so (ascii 0) will be the null pname */
		     else pnamelen = 1;
		a_char = byte (fb);
		pnp = addr(a_char);
		esw = 2;
		go to get_atom_join;
atom_rtn(2):	if fb < 128
		then char_obj = stack -> temp(1);	/* save for later use */
		end;
	else stack -> temp(1) = char_obj;
	call reset_tblp;		/* garbage collector may have moved readtable */
	return;

make_name:  entry;		/* for maknam, make uninterned atomic symbol */

	maknamsw = "1"b;
	go to make_new;


	end get_atom;

/* ext entry to compute hash function - used by lisp_obarray_utils_ */
	/****** KLUDGE: unlike lisp_get_atom_, this entry assumes that the extra
		bits in the last word of the pname have already been zeroed *******/

hash_fcn: entry(name, a_indx);

	dcl a_indx fixed bin; /* name char(*) aligned */

	pnp = addr(name);
	if length(name) = 0 then indx = 511;
	else if length(name) = 1 & rank (substr (name, 1, 1)) <= 127
	     then indx = 511 + rank (substr (name, 1, 1));
	else do;
	     indx = 0;
	     do cnt = 0 to divide(length(name)-1, 4, 17, 0);
		indx = indx + addrel(pnp, cnt) -> name_word;
		end;
	     indx = mod(indx, 509);
	     end;
	a_indx = indx;
	return;

end;

