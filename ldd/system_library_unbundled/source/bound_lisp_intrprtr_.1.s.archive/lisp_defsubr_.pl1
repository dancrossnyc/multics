/* **************************************************************
   *                                                            *
   * Copyright, (C) Massachusetts Institute of Technology, 1973 *
   *                                                            *
   ************************************************************** */
defsubr: proc;

/* LISP subroutine definition subroutine. Makes a SUBR block in the
   lisp environment.
   Modified by Alex Sunguroff, 6/21/72, to add the subr, store.
   Modified by Dave Reed, 6/13/72, for the new lisp
   environment structure 
   Modified 10 AUG 72 by D. Moon for new lisp_error_
   Modified 1 Dec 1973 by D. A. Moon to make stuff in lisp_old_io_ be sysp again
   Modified 74.05.17 by DAM to take out array stuff and obsolete defsubr type 3.
   Also make_lisp_subr_block_ was made an internal procedure since no one else uses it now.
 */

dcl stack ptr,
    (sw, lsubrsw, fsubrsw) bit(1),
    (pointer, baseno) builtin,
    arg_index fixed bin,
    number_args fixed bin,
    flags fixed bin aligned,
    type fixed bin(2) aligned,
    nargs fixed bin aligned,
    subr_offsets(-2:2) fixed bin static init(4,0,2,6,4),
    1 subr_info_stuff based aligned,
      2 nargs fixed bin(17) unal,
      2 subr_type fixed bin(17) unal,
    lisp$ external fixed bin,
    lisp_linker_ entry(pointer),
    lisp_linkage_error condition,
    subr_ptr ptr,
    data_ptr ptr,
    link_ptr ptr,
    data_object based aligned fixed bin(71),		/* lisp object for defsubr copy of type 3 data */
    1 lisp_fixnum_ovly_lk based aligned,
      2 pad bit(45) unal,
      2 lk_info bit(27) unal,		/* stuff generated by lisp compiler */
    1 link_info based aligned,
      2 base bit(3) unal,		/* itp base */
      2 info bit(27) unal,		/* from defsubr's arguments */
      2 mod bit(6) unal,
      2 word2 bit(36),

    lisp_error_ entry,
     unm ptr,
     1 args_to_lisp_error_ based (unm) aligned,
       2 ercode fixed bin,
       2 fcn_name fixed bin,
     myname fixed bin,		/* copy of fcn_name */
     err fixed bin,
     copy_block (nwords) based aligned fixed bin(35);

dcl 1 subr_head based aligned,
      2 maxnum bit(9) unaligned,
      2 minnum bit(9) unaligned;

dcl lisp_special_fns_$cons entry;

dcl (lisp_static_vars_$subr, lisp_static_vars_$lsubr, lisp_static_vars_$fsubr, lisp_static_vars_$array) fixed bin(71) external,
    (array  defined  lisp_static_vars_$array,
     subr   defined  lisp_static_vars_$subr,
     lsubr  defined  lisp_static_vars_$lsubr,
     fsubr  defined  lisp_static_vars_$fsubr) fixed bin(71);

%include lisp_error_codes;
%include lisp_name_codes;
%include lisp_stack_seg;
%include lisp_cons_fmt;
%include lisp_comp_subr_block;

%include lisp_ptr_fmt;
%include lisp_string_fmt;
%include lisp_nums;
%include lisp_common_vars;
%include lisp_stack_fmt;
%include lisp_atom_fmt;



	myname = fn_defsubr;		/* in case of error */
	stack = addrel(stack_ptr,-2);	/* get addr of arg count */
	number_args = -divide(stack -> fixedb,2,35,0);	/* get real arg count */
	stack = addrel(stack,stack->fixedb);	/* make stack point at begin of args */

defsubr_5:
	if number_args < 5 then flags = 0;	/* default flags */
	else if stack -> temp_type(5) & Fixed
	then flags = addr(stack->temp(5))->fixedb;
	else go to bad_argument_5;

defsubr_4:
	if number_args < 4 then type = 2;	/* default type is PL/I */
	else if stack -> temp_type(4) & Fixed
	then type = addr(stack -> temp(4))->fixedb;
	else go to bad_argument_4;
	if type ^= 2 then if type ^= -2 then go to bad_argument_4;	/* only PL/I subrs still work here */

defsubr_3:
	if stack -> temp_type(3) & Fixed
	then nargs = addr(stack -> temp(3)) -> fixedb;
	else go to bad_argument_3;

defsubr_2:
	if stack -> temp_type(2) & String then;
	else go to bad_argument_2;

defsubr_1:
	if stack -> temp_type(1) & String then;
	else go to bad_argument_1;

	call make_lisp_subr_block_(stack->temp_ptr(1), type, stack->temp_ptr(1)->string, stack->temp_ptr(2)->string,
				nargs, flags);
	stack_ptr = addr(stack->temp(2));
	return;
 
	/* error handlers */

too_few:	err = too_few_args;
	go to fatal;

too_many:	err = too_many_args;
fatal:
	stack_ptr = stack;
	call error;
	return;

bad_argument_5:
	addrel(stack_ptr, -2) -> temp(1) = stack -> temp(5);
	err = bad_arg_correctable;
	call error;
	stack -> temp(5) = addrel(stack_ptr, -2) -> temp(1);
	go to defsubr_5;

bad_argument_4:
	addrel(stack_ptr, -2) -> temp(1) = stack -> temp(4);
	err = bad_arg_correctable;
	call error;
	stack -> temp(4) = addrel(stack_ptr, -2) -> temp(1);
	go to defsubr_4;

bad_argument_3:
	addrel(stack_ptr, -2) -> temp(1) = stack -> temp(3);
	err = bad_arg_correctable;
	call error;
	stack -> temp(3) = addrel(stack_ptr, -2) -> temp(1);
	go to defsubr_3;

bad_argument_2:
	addrel(stack_ptr, -2) -> temp(1) = stack -> temp(2);
	err = bad_arg_correctable;
	call error;
	stack -> temp(2) = addrel(stack_ptr, -2) -> temp(1);
	go to defsubr_2;

bad_argument_1:
	addrel(stack_ptr, -2) -> temp(1) = stack -> temp(1);
	err = bad_arg_correctable;
	call error;
	stack -> temp(1) = addrel(stack_ptr, -2) -> temp(1);
	go to defsubr_1;

/* interface to lisp_error_, called with ercode in vraiable err */

error:	proc;

	unm = unmkd_ptr;			/* push err code onto unmkd pdl */
	unmkd_ptr = addrel(unm, 2);
	unm -> ercode = err;
	unm -> fcn_name = myname;
	call lisp_error_;
	return;
	end;

args:	entry;			/* lsubr to tell how many args a subr expects or to put that there*/

	stack = addrel(stack_ptr,-2);
	if addr(stack -> temp(1)) -> fixedb = -2 then sw = "1"b;
	else sw = ""b;
	stack = addrel(stack, addr(stack -> temp(1)) -> fixedb);
args_01:
	stack_ptr = addr(stack -> temp(5));
	if stack -> temp_type36(1) & Atsym36 then; else do;
		err = bad_arg_correctable;
		myname = fn_args;
		stack_ptr = addr(stack -> temp(6));
		stack -> temp(5) = stack -> temp(1);	/* put losing arg at top of pdl */
		call error;
		stack -> temp(1) = stack -> temp(5);	/* put corrected value back */
		go to args_01;			/* reset stack_ptr & retry */
		end;
	stack -> temp(3) = stack -> temp_ptr(1) -> atom.plist;
	do while (stack -> temp_type(3) = Cons);
	     if stack -> temp_ptr(3) -> cons.car = lsubr then do;
		lsubrsw = "1"b;
		fsubrsw = "0"b;
		go to common_in_args;
	     end;
	     if stack -> temp_ptr(3) -> cons.car = fsubr then do;
		fsubrsw = "1"b;
		lsubrsw = "0"b;
		go to common_in_args;
		end;
	     if stack -> temp_ptr(3) -> cons.car = subr  then do;
		lsubrsw = ""b;
		fsubrsw = "0"b;
common_in_args:
		     stack -> temp(3) = stack -> temp_ptr(3) -> cons_ptrs.cdr -> cons.car;
		     if stack -> temp_type36(3) & Subr36 then go to Subr_pointer_is_found;
		     /* if not really a subr, skip to next property */
		end;
	     stack -> temp(3) = stack -> temp_ptr(3) -> cons.cdr;
	     if stack -> temp_type(3) = Cons then
		stack -> temp(3) = stack -> temp_ptr(3) -> cons.cdr;
	end;
	stack -> temp(1) = nil;
	stack_ptr = addr(stack -> temp(2));
	return;					/*it could not filnd a function definition*/

Subr_pointer_is_found:
	subr_ptr = stack -> temp_ptr(3);
	if sw then do;				/*if we're going to give back the value*/
		if fsubrsw then do;
			stack -> temp(3) = nil;
			go to args_return;
			end;
		else if lsubrsw then do;
		     addr(stack -> temp(3)) -> fixnum_fmt.type_info = fixnum_type;
		     addr(stack -> temp(3)) -> fixedb = binary(subr_ptr -> minnum, 9);
	     addr(stack -> temp(4)) -> fixnum_fmt.type_info = fixnum_type;
	     addr(stack -> temp(4)) -> fixedb = binary(subr_ptr -> maxnum, 9);
		end;
		else do;
			stack -> temp(3) = nil;
			addr(stack -> temp(4)) -> fixnum_fmt.type_info = fixnum_type;
			addr(stack -> temp(4)) -> fixedb = binary(subr_ptr -> minnum, 9);	/* get nargs */
	     end;
	     call lisp_special_fns_$cons;
args_return:   stack -> temp(1) = stack -> temp(3);
	     stack_ptr = addr(stack -> temp(2));
	     return;				/*and so we return*/
	end;

	stack -> temp(3) = stack -> temp_ptr(2) -> cons.car;
	stack -> temp(4) = stack -> temp_ptr(2) -> cons.cdr;
	if stack -> temp(3) = nil then do;
	     subr_ptr -> maxnum = bit(binary(0, 9));
	     subr_ptr -> minnum = bit(fixed(addr(stack -> temp(4)) -> fixedb,9));
	     end;
	else do;
	     subr_ptr -> minnum = bit(fixed(addr(stack -> temp(3)) -> fixedb, 9));
	     subr_ptr -> maxnum = bit(fixed(addr(stack -> temp(4)) -> fixedb, 9));
	     end;
	stack -> temp(1) = stack -> temp(2);
	stack_ptr = addr(stack -> temp(2));
	return;

sysp:	entry;				/*subr  predicate to tell if a subr is a system subr*/

	stack = addrel(stack_ptr, -2);
sysp_01:
	stack_ptr = addr(stack -> temp(4));
	if stack -> temp_type36(1) & Atsym36 then; else do;	/*must be an atom*/
sysp_bad_1:
	     stack_ptr = addr(stack -> temp(2));
	     err = bad_arg_correctable;
	     myname = fn_sysp;
	     call error;
	     go to sysp_01;
	     end;
	stack -> temp(2) = stack -> temp_ptr(1) -> atom.plist;	/*get the p-list*/
	do while(stack -> temp_type(2) = Cons);			/*search down the p-list*/
	     if stack -> temp_ptr(2) -> cons.car = lsubr |
		stack -> temp_ptr(2) -> cons.car = subr |
		stack -> temp_ptr(2) -> cons.car = fsubr then do;	/*if the indicator is found then ...*/
		     stack -> temp(3) = stack -> temp_ptr(2) -> cons_ptrs.cdr -> cons.car;	/*getptr*/
		     if stack -> temp_type36(3) & System_Subr36
		     then do;
			     stack -> temp(1) = stack -> temp_ptr(2) -> cons.car;
			     stack_ptr = addr(stack -> temp(2));
			     return;
			end;
		     if stack -> temp_type36(3) & Subr36 then do;	/*must be Subr ptr*/
			data_ptr = stack -> temp_ptr(3);
			if data_ptr -> subr_entries(1).rest_of_tsx0 = tsx0_ic then go to new_type_subr;
								/* compiled subr */
			if data_ptr -> subr_info_stuff.subr_type = 3 then do;
			     data_ptr = addrel(data_ptr, 4);	/* -> tsplp n,ic* instruction */
			     data_ptr = addrel(data_ptr, data_ptr -> subr_info_stuff.nargs);	/* get addr of link */
			     end;
			else data_ptr = addrel(data_ptr, subr_offsets(data_ptr -> subr_info_stuff.subr_type));
			number_args = data_ptr -> based_ptr -> fixedb;
			     /* this is just a dummy operation to snap pointer_to_subr*/
			if baseno(data_ptr -> based_ptr) =
			     baseno(addr(lisp$)) then
				stack -> temp(1) = stack -> temp_ptr(2) -> cons.car;/*will return thee, indicator*/
			else
ret_nilll:			stack -> temp(1) = nil;			/*return nil*/
			stack_ptr = addr(stack -> temp(2));
			return;
			end;
		end;
	     stack -> temp(2) =  stack -> temp_ptr(2) -> cons.cdr;
	     if stack -> temp_type(2) = Cons then
	  	stack -> temp(2) = stack -> temp_ptr(2) -> cons.cdr;	/*cdr down farther*/
	end;
	stack -> temp(1) = nil;					/*return nil*/
	stack_ptr = addr(stack -> temp(2));
	return;

/* come here for sysp of a new (fasload) subr */

new_type_subr:

	data_ptr = addrel(addr(data_ptr -> subr_entries(1).head_offset), data_ptr -> subr_entries(1).head_offset - 2);	/* -> subr block */
				/* the -2 is to allow for the fact that the instructions start 2 words into the subr block */
	link_ptr = addrel(addr(data_ptr -> subr_block_head.subr_code_link_offset), data_ptr -> subr_block_head.subr_code_link_offset);
	if link_ptr -> link_info.mod ^= "100011"b then do;	/* if necessary, snap link */
		on condition(lisp_linkage_error) go to ret_nilll;
		call lisp_linker_(link_ptr);
		revert condition(lisp_linkage_error);
		end;
	if baseno(link_ptr -> based_ptr) ^= baseno(addr(lisp$)) then go to ret_nilll;
	/* yes, it really is bound in with us.  Must be sysp */

	stack -> temp(1) = stack -> temp_ptr(2) -> cons.car;		/* will reeturn thee, indicator. */
	stack_ptr = addr(stack -> temp(2));
	return;

/** internal procedure to generate a PL/I type subr for defsubr **/

make_lisp_subr_block_: proc(block_ptr, subr_type, seg_name, entrypoint, num_args, flags);

/* Routine to make a standard form SUBR block in the lisp static
   data segment. Takes as arguments:

	block_ptr -- return pointer to  allocated block.
	subr_type -- 0,  fast call LISP subroutine which needs no save lp or bp.
		   1,  fast call LISP subroutine which needs save of lp and bp
		   2,  PL/I routine called with args on LISP stacks, through interface.
		   3,  lisp compiled function, with static data in its block.
	seg_name  -- name of segment containing code for SUBR
	entrypoint-- name of entry in segment.
	num_args  -- number of args expected by SUBR
	flags	-- number of words to be allocated for type 3 static data block.
		   if not type 3 subr; should be zero!

   Coded by D. Reed 6/8/72 */
    /* modified 6/2/73 by DAM for recursive lisp - stat_top and
       cur_stat_seg moved to lisp_static_vars_ */


dcl block_ptr ptr,
    subr_type fixed bin(2) aligned,
    seg_name  char(*) aligned,
    entrypoint char(*) aligned,
    num_args  fixed bin(17) aligned,
    flags     fixed bin(17) aligned;

dcl delta_size(-2:3) fixed bin(4) aligned static init(11,0,9,13,11,13),	/* number words over space for strings needed by block */

    space pointer,
    segnamel fixed bin,
    entryl   fixed bin,
    1 basic_block based aligned,
      2 no_args fixed bin(17) unaligned,
      2 stype   fixed bin(17) unaligned,
      2 entry_instructions(5) bit(36) aligned,

    tra_1_ic_ind bit(36) aligned static init("000000000000000001111001000000010100"b),
    eaplp_ab_sys_lp bit(36) aligned static init("001000000000100100011111000001010000"b),
    tsblp_ic_ind bit(18) aligned static init("110111000000010100"b),
    eax7_2 bit(36) aligned static init("000000000000000010110010111000001111"b),
    eax7_4 bit(36) aligned static init("000000000000000100110010111000001111"b),
    stpbp_ab_back_2 bit(36) aligned static init("001111111111111110010101010001001111"b),
    stplp_ab_back_4 bit(36) aligned static init("001111111111111100110101000001001111"b),
    tsbbp_ab_pl1_int bit(36) aligned static init("001000000000110110010111010001010000"b),
    tsbbp_ab_lsubr_int bit(36) aligned static init("001000000000111000010111010001010000"b),
    1 linkage_block based aligned,		/* appears after allocated space for random data */
      2 link,
        3 header_rel fixed bin(17) unaligned,	/* back offset to header at word 2 of segment */
        3 fault_tag fixed bin(17) unaligned,	/* set to 100110b */
        3 exp_word bit(18) unaligned,
        3 more_mod   bit(18) unaligned,		/* should be zero */
      2 exp_offset bit(18) unaligned,	/* rel of next word in segment */
      2 expression bit(18) unaligned,	/* zero this */
      2 class fixed bin(17) unaligned,	/* should be 4 */
      2 trap fixed bin(17) unaligned,		/* should be zero */
      2 segname_rel bit(18) unaligned,
      2 entry_rel bit(18) unaligned,
      2 start_of_strings fixed bin,		/* where first string goes */
    1 acc based aligned,
      2 len fixed bin(8) unaligned,		/* just never greater than 32 */
      2 string char(262144) unaligned,		/* filled in with len chars */

    size fixed bin(18),
    lisp_static_man_$allocate entry(pointer, fixed bin(18)),
    (addrel,rel,addr,null,substr,length,divide) builtin;

	segnamel = length(seg_name);		/* compute storage for acc strings */
	entryl = length(entrypoint);
	size = divide(segnamel,4,17,0)+divide(entryl,4,17,0);	/* the extra two words are in the deltas */

	size = size + delta_size(subr_type) + flags;

	size = 2*divide(size+1,2,17,0);		/* round to mod2 bound */

	call lisp_static_man_$allocate(block_ptr, size);

	space = block_ptr;
	addr(block_ptr)->lisp_ptr.type = Subr;

	space -> basic_block.no_args = num_args;/* fill in block */
	space -> basic_block.stype = subr_type;
	go to make_entry(subr_type);		/* branch on type */
make_entry(-2):
	space -> basic_block.entry_instructions(3) = tsbbp_ab_lsubr_int;	/* this is an LSUBR */
	go to make_type_2;
make_entry(2):
	space -> basic_block.entry_instructions(3) = tsbbp_ab_pl1_int;
make_type_2:
	space -> basic_block.entry_instructions(1) = eax7_2;
	space -> basic_block.entry_instructions(2) = stpbp_ab_back_2;
	space = addrel(space,4);
make_link:
	space -> linkage_block.header_rel = 2 - binary(rel(space),18,0);
	space -> linkage_block.fault_tag = 100110b;	/* 46(8) */

	space -> linkage_block.more_mod = "0"b;
	space -> linkage_block.link.exp_word = rel(addr(space->linkage_block.exp_offset));
	space -> linkage_block.exp_offset = rel(addr(space->linkage_block.class));
	space -> linkage_block.expression = "0"b;
	space -> linkage_block.class = 4;
	space -> linkage_block.trap = 0;
	space -> linkage_block.segname_rel = rel(addr(space->linkage_block.start_of_strings));
	space -> linkage_block.entry_rel = rel(addrel(addr(space->linkage_block.start_of_strings),divide(segnamel,4,17,0)+1));
	space = addr(space->linkage_block.start_of_strings);
	space -> acc.len = segnamel;
	substr(space->acc.string,1,segnamel) = substr(seg_name,1,segnamel);
	space = addrel(space,divide(segnamel,4,17,0)+1);
	space -> acc.len = entryl;
	substr(space->acc.string,1,entryl) = substr(entrypoint,1,entryl);

	return;


end make_lisp_subr_block_;


end defsubr;
