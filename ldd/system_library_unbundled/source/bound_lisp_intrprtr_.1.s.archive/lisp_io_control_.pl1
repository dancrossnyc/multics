/* **************************************************************
   *                                                            *
   * Copyright, (C) Massachusetts Institute of Technology, 1973 *
   *                                                            *
   ************************************************************** */
lisp_io_control_: procedure;

/*
 * This module contains the central core of the new LISP I/O System.
 * This includes the lisp functions openi, openo, close, rename, deletef, and mergef,
 * as well as several subroutines that are called by other lisp
 * functions and by the garbage collector, saver, booter, etc.
 *
 * Written March, 1973 by D.A.Moon
 * modified 73.10.25 by DAM for new iochan format
 * modified 74.05.14 by DAM for EIS, and to not suspend acl on output files.
 * instead, the fact that msf_manager_ gives access if it creates the file is relied upon
 * thus iochan.aclinfop is no longer used
 * modified 74.09.21 by DAM to accept t for tty as well as nil
 * modified 74.12.20 by DAM for new 'open' function
 * modified 78.05.18 by BSG for 256-char mode string
 * modified 81.02.25 by PCK to use mode_string_$get_mode to parse mode strings and for 512-char mode string
 * modified 1982.10.05 by Richard Lamson to add (includef ...)
 */

/**********************************************

The i/o system operates with file objects, which are
lisp objects pointed at by a pointer with the 'File' type
bit turned on.  The format of a file object is declared
as the structure 'iochan.'  An iochan is created when
a file is "opened," and effectively destroyed when it is
"closed."  Some of the information in the iochan is used
by this module to interface with the Multics file system,
multi-segment file manager, and i/o switch.  Other information
is used by the other i/o modules to control formatting,
e-o-f handling, etc.  All files are divided into "blocks,"
which are either one segment of a multi-segment file or one
buffer-load of a stream.  The beginning of a block is pointed
at by iochan.ioptr, and iochan.ioindex is used as the character
position within the block.  The length of the block, in characters
is kept in iochan.iolength.  When the end of a block is reached,
lisp_io_control_$end_of_block is invoked by one of the lisp i/o
functions to advance to the next block.  The other entry points
in this module are concerned with exceptional conditions such as
creation and destruction of iochans (open/close), garbage
collection, saving, and file system errors.

**********************************************/

declare
addr builtin,
reverse builtin,
addrel builtin,
1 amv like mode_value aligned,	/* Automatic storage for mode_value structure */
bc fixed bin(24),			/* bit count */
binary builtin,
buffer_size fixed bin static init(256),	/* number o chars in a stream buffer */
code fixed bin(35),			/* status return code */
codde fixed bin,
com_err_ ext entry options(variable),
delete_$path ext entry (char(*), char(*), bit(6), char(*), fixed bin(35)),
divide builtin,
dname char(168),			/* directory pathname of file being opened */
ename char(36) varying,		/* place to suffix_cs up the entryname of the file being opened */
err fixed bin(35),			/* lisp error code, used by int proc error */
error_table_$end_of_info ext fixed bin(35),
error_table_$long_record ext fixed bin(35),
error_table_$dirseg external fixed bin(35),
error_table_$no_space external fixed bin(35),	/* used when eof bit is lit up for output stream */
error_table_$entlong external fixed bin(35),
error_table_$noentry external fixed bin(35),
esw fixed bin,		/* entry switch controls error proc: >0 = fcn, 0 = save, <0 = internal subroutine */
expand_path_ ext entry(ptr, fixed bin, ptr, ptr, fixed bin(35)),
find_include_file_$initiate_count entry(char(*)aligned, pointer, char(*)aligned, fixed bin(24), pointer, fixed bin(35)),
get_wdir_ ext entry returns(char(168)),
hcs_$chname_file ext entry (char(*), char(*), char(*), char(*), fixed bin(35)),
hcs_$fs_get_path_name ext entry (pointer, char(*), fixed bin, char(*), fixed bin(35)),
hcs_$get_max_length_seg ext entry (pointer, fixed bin(19), fixed bin(35)),
hcs_$status_minf ext entry (char(*), char(*), fixed bin, fixed bin, fixed bin(24), fixed bin(35)),
i fixed bin,
index builtin,
infile fixed bin(71) def (lisp_static_vars_$infile),
instack fixed bin(71) def (lisp_static_vars_$instack),
iox_$modes entry(ptr, char(*), char(*), fixed bin(35)),
iox_$get_line entry(ptr, ptr, fixed bin(24), fixed bin(24), fixed bin(35)),
iox_$get_chars entry(ptr, ptr, fixed bin(24), fixed bin(24), fixed bin(35)),
iox_$control entry(ptr, char(*), ptr, fixed bin(35)),
iox_$put_chars entry(ptr, ptr, fixed bin(24), fixed bin(35)),
iox_$look_iocb entry(char(*), ptr, fixed bin(35)),
j fixed bin,
length builtin,
lisp_$apply entry,
lisp_get_atom_ entry(char(*) aligned, fixed bin(71)),
lisp_io_control_$close entry,		/* recurse to close iochan on eof */
lisp_io_fns_$inpush entry,
lisp_io_fns_$internal_namelist entry(fixed bin),
lisp_list_utils_$nreverse entry,
lisp_reader_$maknam entry,
lisp_print_$exploden entry,
lisp_special_fns_$cons entry,
lisp_special_fns_$xcons entry,
lisp_static_vars_$STAR fixed bin(71) external,
lisp_static_vars_$close fixed bin(71) external,
lisp_static_vars_$deletef fixed bin(71) external,
lisp_static_vars_$infile fixed bin(71) external,
lisp_static_vars_$instack fixed bin(71) external,
lisp_static_vars_$mergef fixed bin(71) external,
lisp_static_vars_$old_io_defaults external pointer,
lisp_static_vars_$open fixed bin(71) external,
lisp_static_vars_$outfile fixed bin(71) external,
lisp_static_vars_$outfiles fixed bin(71) external,
lisp_static_vars_$rdr_label external label,
lisp_static_vars_$rdr_ptr external pointer,
lisp_static_vars_$rdr_state external fixed binary,
lisp_static_vars_$rename fixed bin(71) external,
lisp_static_vars_$stream fixed bin(71) external,
lisp_static_man_$allocate entry(pointer, fixed bin(18)),
maxlen fixed bin(19),					/* maximum - length attrib */
min builtin,
mode_string_$get_mode entry (char(*), char(*), ptr, fixed bin(35)),
msf_manager_$adjust ext entry (ptr, fixed bin, fixed bin(24), bit(3) aligned, fixed bin(35)),
msf_manager_$get_ptr ext entry (ptr, fixed bin, bit(1) aligned, ptr, fixed bin(24), fixed bin(35)),
msf_manager_$open entry(char(*), char(*), pointer, fixed bin(35)),
msf_manager_$close entry(pointer),
myname fixed bin,		/* fn_ code for function entry point */
nargs fixed bin,		/* number of args to mergef */
null builtin,
other_ename char(32),		/* for rename */
outfiles fixed bin(71) def (lisp_static_vars_$outfiles),
p ptr,			/* points at iochan currently being processed */
p2 ptr,
p_fb fixed bin(71) aligned based(addr(p)),
ptr builtin,
q ptr,
rdr_label label def(lisp_static_vars_$rdr_label),
rdr_ptr pointer def(lisp_static_vars_$rdr_ptr),
rdr_state fixed bin def(lisp_static_vars_$rdr_state),
rel builtin,
rnstack ptr,			/* orig value of 'stack,' used by rename */
size builtin,
stack ptr,
star fixed bin(71) def (lisp_static_vars_$STAR),
status fixed bin(35) aligned,
stream fixed bin(71) def (lisp_static_vars_$stream),
string builtin,
substr builtin,
type fixed bin,				/* return arg of hcs_$status_minf */
user_io_modes char(512),
verify builtin;


	/* based overlay for setting the type bits of the pointer p
	   so that it can be put in the marked pdl as a file object */

dcl 1 p_ aligned based(addr(p)) like lisp_ptr;




	/* Variables used by open */

dcl direction fixed bin,
     (In init(0), Out init(1), Append init(2)) fixed bin static;

dcl data_mode fixed bin,
    (Ascii init(0), Fixnum init(1), Image init(2)) fixed bin static;

dcl buffer_mode fixed bin,
    (Block init(0), Single init(1)) fixed bin static;

dcl device_type fixed bin,
    (Ordinary init(0), Terminal init(1)) fixed bin static;

dcl openx_sim_arg char(8) aligned;		/* "read", "print", or "append" */

	/* Error Codes */

dcl (lisp_error_table_$bad_item_in_modelist,
     lisp_error_table_$reopen_inconsistent,
     lisp_error_table_$io_wrong_direction,
     lisp_error_table_$file_is_closed,
     lisp_error_table_$file_sys_fun_err,
     lisp_error_table_$stars_left_in_name,
     lisp_error_table_$bad_arg_correctable,
     lisp_error_table_$bad_entry_name,
     lisp_error_table_$include_file_error) fixed bin external;


%include lisp_common_vars;
%include lisp_stack_fmt;
%include lisp_io;
%include lisp_name_codes;
%include lisp_ptr_fmt;
%include lisp_nums;
%include lisp_cons_fmt;
%include lisp_atom_fmt;
%include lisp_string_fmt;
%include mode_string_info;

/*
 * The three lisp lsubrs for opening files (creating iochans).
 */

openi:	entry;

	myname = fn_openi;
	openx_sim_arg = "read";
	go to openx;

openo:	entry;

	myname = fn_openo;
	openx_sim_arg = "print";
	go to openx;

opena:	entry;

	myname = fn_opena;
	openx_sim_arg = "append";


openx:
	esw = 1;
	stack = addrel(stack_ptr,-2);				/* get argument */
	call set_mode_defaults;
	call modelist_process(openx_sim_arg);			/* get proper mode */
	go to open_stuff;

/*
 * General 'open' entry
 */

open:	entry;

	myname = fn_open;
	esw = 2;
	stack = addrel(stack_ptr, -2);
	nargs = stack -> fixedb;				/* lsubr */
	stack = addrel(stack, nargs);
	if nargs = 0 then stack -> temp(1) =
			tty_output_chan -> iochan.namelist;	/* default names */
	else if nargs <= -4 then do;				/* process modelist */
	   do while(stack -> temp_type(2) = Cons);
	      call modelist_object(stack -> temp_ptr(2) -> cons.car);
	      stack -> temp(2) = stack -> temp_ptr(2) -> cons.cdr;
	      end;
	   if stack -> temp(2) ^= nil then call modelist_object(stack -> temp(2));
	   end;

open_stuff:

/*
 * create an iochan block in static storage, then initialize it from the defaults
 */

	if stack -> temp_type36(1) & File36 then do;		/* re-open file */
	   p = stack -> temp_ptr(1);
	   go to gc_close;					/* get the file closed */
open_close_ret:
	   call init_an_iochan;
	   end;
	else call make_an_iochan;
	stack_ptr = addr(stack -> temp(3));
	stack -> temp(2) = tty_output_chan -> iochan.namelist;	/* get the defaults */
	nargs = 2;
	if stack -> temp_type36(1) & File36		/* if file passed in, now have it in p so */
	then stack -> temp(1) = p -> iochan.namelist;	/* substitute its namelist */
	call umergef;				/* merge arg with defaults, do err checking and all good things */
	p -> iochan.charpos, p -> iochan.linenum, p -> iochan.pagenum = 0;
	/* set linel, pagel from device characteristics */
	p -> iochan.pagel = 59;	/* random constant for Multics */
	p -> iochan.linel = 110;	/* another random constant, for all but tty */
	/* set eoffn or endpagefn from default */
	if direction = In
	then p -> iochan.function = tty_input_chan -> iochan.function;	/* default eoffn */
	else p -> iochan.function = tty_output_chan -> iochan.function;	/* default endpagefn */
	p -> iochan.namelist = stack -> temp(1);		/* namelist gotten by umergef */
	if direction = In
	then p -> iochan.write = "1"b;	/* input chan - leave .read 0 */
	else p -> iochan.read = "1"b;		/* output chan - leave .write 0 */

/*
 * decide whether this is a stream or a file, and apply appropriate special open code
 */

	if stack -> temp_ptr(1) -> cons.car = stream then do;	/* namelist specifies stream */
		p -> iochan.name = stack -> temp_ptr(1) -> cons_ptrs.cdr
			-> cons_ptrs.car -> atom.pname;	/* stream name is cadr of namelist */
		call lisp_static_man_$allocate(p -> iochan.ioptr, divide(buffer_size, 4, 18, 0));
		if direction = In then p -> iochan.iolength = 0;
		else if data_mode = Fixnum then p -> iochan.iolength = divide(buffer_size, 4, 24, 0);
		else p -> iochan.iolength = buffer_size;	/* output or append */
		p -> iochan.aclinfop = null;		/* not used for stream */
		call iox_$look_iocb(p->iochan.name, p -> iochan.fcbp, code);
		if code ^= 0 then go to file_sys_fun_err_;
		end;	/* if stream not attached, we'll find out when we try to use it */

	else do;	/* it's a file (msf), get dname and ename and call msf_manager_ */

		call get_path_name;

		if direction = In then		/* input file, easiest to open */
			call open_input_file;

		else if direction = Out then do;		/* output file, open, create, set up first seg */
			call open_output_file;
opena_new:		call get_output_seg_ptr;
			end;
		else do;		/* opena - append output to prev existing seg */

			call open_output_file;

			/* now find last seg */

			call hcs_$status_minf(dname, p -> iochan.name, 1, type, bc, code);	/* code must be 0!! */
			if code ^= 0 then go to opena_new;		/* it's not there yet */
			if type = 2 then p -> iochan.component = bc-1;	/* if msf, set to last component */
			call get_output_seg_ptr;		/* get ptr to and bc of last seg */
			if data_mode = Fixnum
			then p -> iochan.ioindex = min(divide(bc, 36, 24, 0),	/* and set posn to append to what is there */
						p -> iochan.iolength);
			else p -> iochan.ioindex = min(divide(bc, 9, 24, 0),	/* and set posn to append to what is there */
						p -> iochan.iolength);
			end;
		end;

/*
 * Set miscellaneous attributes in the iochan
 */

	if data_mode = Fixnum then p -> iochan.fixnum_mode = "1"b;
	else if data_mode = Image then p -> iochan.image_mode = "1"b;

	if buffer_mode = Single then p -> iochan.charmode = "1"b;

	if device_type = Terminal then p -> iochan.interactive = "1"b;

/*
 * iochan has been successfully created
 * so link it onto threaded list of all chans
 * if an interrupt occurs at the wrong time here, the lossage won't be
 * sufficiently bad to justify worrying
 */

	p -> iochan.thread = lisp_static_vars_$iochan_list;
	lisp_static_vars_$iochan_list = p;

/*
 * All done, turn on type bit for file and return
 */

	p_.type = File;
	stack -> temp(1) = p_fb;
exit:
	stack_ptr = addr(stack -> temp(2));
	return;

/*
 * Internal procedure to set defaults for modelist
 */

set_mode_defaults:  procedure;

dcl p pointer;

	if stack -> temp_type36(1) & File36 then do;	/* use prior attributes of file */
	   p = stack -> temp_ptr(1);
	   if p -> iochan.read then direction = Out; else direction = In;
	   if p -> iochan.fixnum_mode then data_mode = Fixnum;
	   else if p -> iochan.image_mode then data_mode = Image;
	   else data_mode = Ascii;
	   if p -> iochan.charmode then buffer_mode = Single;
	   else buffer_mode = Block;
	   if p -> iochan.interactive then device_type = Terminal;
	   else device_type = Ordinary;
	   end;
	else do;					/* standard defaults */
	   direction = In;
	   data_mode = Ascii;
	   buffer_mode = Block;
	   device_type = Ordinary;
	   end;
end;

/*
 * Internal procedure to process one modelist entry
 */

modelist_process:  procedure(item);

dcl item char(*) aligned;

	if item = "in" then direction = In;
	else if item = "read" then direction = In;
	else if item = "out" then direction = Out;
	else if item = "print" then direction = Out;
	else if item = "append" then direction = Append;

	else if item = "ascii" then data_mode = Ascii;
	else if item = "fixnum" then data_mode = Fixnum;
	else if item = "image" then data_mode = Image;

	else if item = "dsk" then device_type = Ordinary;
	else if item = "tty" then device_type = Terminal;

	else if item = "block" then buffer_mode = Block;
	else if item = "single" then buffer_mode = Single;
	else err = lisp_error_table_$bad_item_in_modelist;	/* caller sees */
end;

/*
 * Internal procedure to process an object in the modelist
 */

modelist_object:  procedure(a_object);

dcl a_object fixed bin(71),
    object fixed bin(71) init(a_object),
    object_type bit(36) aligned based(addr(object)),
    tsp pointer;

retry:	err = 0;
	if object_type & Atsym36 then call modelist_process(addr(object)-> based_ptr -> atom.pname);
	else if object_type & String36 then call modelist_process(addr(object)-> based_ptr -> lisp_string.string);
	else err = lisp_error_table_$bad_item_in_modelist;

	if err = 0 then return;		/* won */
	tsp = stack_ptr;			/* otherwise fail correctably */
	stack_ptr = addr(tsp -> temp(2));
	tsp -> temp(1) = object;
	call error;
	object = tsp -> temp(1);
	stack_ptr = tsp;
	go to retry;

end;

/*
 * Internal procedure to make an iochan block and do first initialization
 */

make_an_iochan: proc;

	call lisp_static_man_$allocate(p, size(iochan));

init_an_iochan:  entry;

	p -> iochan.component, p -> iochan.ioindex = 0;
	string(p -> iochan.flags) = ""b;		/* clear all flags in the iochan */
	end;

/*
 * Internal procedure to get dir path name and entry name from name list
 */

get_path_name: proc;

		p -> iochan.seg = "1"b;
		call get_path_name_0;

		p -> iochan.name = substr(ename, 1, length(ename)-1);	/* drop last period */
	return;


	end;


get_path_name_0: proc;

		dcl tsp ptr;		/* have to avoid munging stack -> temp(1) */

		tsp = stack_ptr;
		stack_ptr = addr(tsp -> temp(2));
		tsp -> temp(1) = stack -> temp(1);

try_again:	dname = tsp -> temp_ptr(1) -> cons_ptrs.car -> atom.pname;
							/* dir pn is car of namelist */
		ename = "";				/* concatenate up ename from list of names, */
		do					     /* in cdr of namelist */
		   tsp -> temp(1) = tsp -> temp_ptr(1) -> cons.cdr
		   repeat (tsp -> temp_ptr(1) -> cons.cdr)
		   while (tsp -> temp_type(1) = Cons);
			ename = ename || tsp -> temp_ptr(1) -> cons_ptrs.car -> atom.pname || ".";
			end;
		if length(ename) = 0 then go to bad_ename;	/* lose if no names */
		else if length(ename) >= 34 then go to bad_ename;	/* or name longer than 32 chars (+1 for last ".") */
		stack_ptr = tsp;
		return;

bad_ename:	/* give a wrng-type-arg on the name list if the entry name is no good (too long or short) */

	err = lisp_error_table_$bad_entry_name;
	call error;
	go to try_again;

	end;


/*
 * Internal procedure to open an input seg, set up iochan block to point to it
 */

open_input_file: proc;

			call msf_manager_$open(dname, p -> iochan.name, p -> iochan.fcbp, code);
			if code ^= 0 then do;		/* file not found or other lossage */
fs_loss_close_maybe:	     if code ^= error_table_$dirseg then
fs_loss_close_it:			call close_msf;	/* flush FCB */
			     go to file_sys_fun_err_;	/* give a fail-act */
			     end;
			p -> iochan.aclinfop = null;

			/* set up ptr to first seg of file */

			call msf_manager_$get_ptr(p -> iochan.fcbp, p -> iochan.component,  /* or current comp if reopen */
					"0"b, p -> iochan.ioptr, bc, code);
			if p -> iochan.ioptr = null then go to fs_loss_close_it;
							/* can't really open, we don't have access */
			if data_mode = Fixnum
			then p -> iochan.iolength = divide(bc, 36, 24, 0);  /* get word count from bit count */
			else p -> iochan.iolength = divide(bc, 9, 24, 0);  /* get char count from bit count */
			return;



/*
 * Internal procedure to open an output file, saving acl and setting access to rwa
 */

open_output_file:  entry;

			call msf_manager_$open(dname, p -> iochan.name, p -> iochan.fcbp, code);
			if p -> iochan.fcbp = null then go to fs_loss_close_maybe;
			return;

/*
 * Internal proc to get ptr to a component of an output msf
 */

get_output_seg_ptr: entry;

			/* now get ptr to first seg */

			call msf_manager_$get_ptr(p -> iochan.fcbp, p -> iochan.component, "1"b, 
					p -> iochan.ioptr, bc, code);
			if p -> iochan.ioptr = null then go to fs_loss_close_it;
							/* couldn't create the seg, go clean and barf */

			/* set iochan.iolength from the maximum length attribute of the seg */

			call hcs_$get_max_length_seg(p -> iochan.ioptr, maxlen, code);
			if code ^= 0 then go to fs_loss_close_it;		/* !!! */

			if data_mode = Fixnum
			then p -> iochan.iolength = maxlen;
			else p -> iochan.iolength = maxlen*4;		/* number of chars before o.o.b. fault */
			return;

end open_input_file;


/*
 * lisp close subr - closes the file and gets rid of the iochan
 *  does not detach streams since open does not attach them
 */

close:	entry;

	esw = 4;
	stack = addrel(stack_ptr, -2);		/* get arg */
	myname = fn_close;
	do while (^ stack -> temp_type36(1) & File36);
		err = lisp_error_table_$bad_arg_correctable;
		call error;
		end;

	/* garbage collector joins here */

	p = stack -> temp_ptr(1);
gc_close:	if (string(p -> iochan.flags) & "011"b) ^= "011"b then do;	/* if not already closed */
	     if p -> iochan.seg then
	       if ^ p -> iochan.read then		/* input file, just close the FCB */
		call close_msf;
	       else
		call close_output_file;
	     else		/* a stream:  flush buffer if output, but don't have to do anything else */
	       if ^ p -> iochan.write then call dump_buffer;
		end;

	if esw < 0 then go to gc_close_1;			/* skip this if gc_flush entry */


/*
 * as far as the Multics environment is concerned, the iochan is closed
 * but there are still some things left to do in the lisp environment
 */


	/* (setq instack (delq p instack)) */

	stack_ptr = addr(stack -> temp(5));
	stack -> temp(2), stack -> temp(3) = addr(instack) -> based_ptr -> atom.value;
	do while (stack -> temp_type(3) = Cons);
	     if stack -> temp_ptr(3) -> cons.car = stack -> temp(1)	/* p appears in the list */
		then if stack -> temp(2) = stack -> temp(3)	/* first in list is special case */
		     then stack -> temp(2) = stack -> temp_ptr(3) -> cons.cdr;
		     else stack -> temp_ptr(4) -> cons.cdr =	/* if not first in list, rplacd it out */
				stack -> temp_ptr(3) -> cons.cdr;
	     stack -> temp(4) = stack -> temp(3);
	     stack -> temp(3) = stack -> temp_ptr(3) -> cons.cdr;
	     end;
	addr(instack) -> based_ptr -> atom.value = stack -> temp(2);

	/* (and (eq p infile) (inpush -1)) */

	if stack -> temp(1) = addr(infile) -> based_ptr -> atom.value then do;
/*	     if addr(instack)-> based_ptr -> atom_types.value = Cons	*/
	     if addr(instack)-> based_ptr -> lisp_ptr.type = Cons
	     then addr(infile) -> based_ptr -> atom.value = addr(instack) -> based_ptr -> atom_ptrs.value -> cons.car;
	     else addr(infile)-> based_ptr -> atom.value = t_atom;	/* empty list -> tty */
	     if addr(instack) -> based_ptr -> atom.value ^= nil 
		then addr(instack) -> based_ptr -> atom.value =
		  addr(instack) -> based_ptr -> atom_ptrs.value -> cons.cdr;
	     end;

	if addr(infile) -> based_ptr -> atom.value = nil
	   | addr(infile) -> based_ptr -> atom.value = t_atom
	     then addr(ctrlQ) -> based_ptr -> atom.value = nil;

	/* (setq outfiles (delq p outfiles)) */

	stack -> temp(2), stack -> temp(3) = addr(outfiles) -> based_ptr -> atom.value;
	do while (stack -> temp_type(3) = Cons);
	     if stack -> temp_ptr(3) -> cons.car = stack -> temp(1)	/* p appears in the list */
		then if stack -> temp(2) = stack -> temp(3)	/* first in list is special case */
		     then stack -> temp(2) = stack -> temp_ptr(3) -> cons.cdr;
		     else stack -> temp_ptr(4) -> cons.cdr =	/* if not first in list, rplacd it out */
				stack -> temp_ptr(3) -> cons.cdr;
	     stack -> temp(4) = stack -> temp(3);
	     stack -> temp(3) = stack -> temp_ptr(3) -> cons.cdr;
	     end;
	addr(outfiles) -> based_ptr -> atom.value = stack -> temp(2);

	if stack -> temp(2) = nil
	     then addr(ctrlR) -> based_ptr -> atom.value = nil;

/*
 * Mark iochan closed by setting both read and write
 */

gc_close_1:
	p -> iochan.read, p -> iochan.write = "1"b;

/*
 * unthread from system's iochan list
 */

errtn(-1):	/* error return from lisp_io_control_$gc_flush -- unthread so error doesn't occur every gc */

	if lisp_static_vars_$iochan_list = p then
	     lisp_static_vars_$iochan_list = p -> iochan.thread;
	else
	     do q = lisp_static_vars_$iochan_list
		repeat (q -> iochan.thread)
		while (q ^= null);
		  if q -> iochan.thread = p then do;
			q -> iochan.thread = p -> iochan.thread;
			go to exit_t;
			end;
		  end;
			/* if we normal-exit this loop, was weird err but who cares? */

/*
 * all done closing, so return
 * value of close is t instead of argument because argument is no longer a valid file object
 */

exit_t:	if esw < 0 then do;		/* return from gc_flush entry */
		stack_ptr = stack;
		return;
		end;
	else if esw < 3 then go to open_close_ret;
	stack -> temp(1) = t_atom;
	go to exit;

/*
 * garbage collector calls this entry when it finds an unreachable iochan
 * unless it is one of the tty iochans, it is  automatically closed
 */

gc_flush:	entry (a_iochan);

	esw = -1;	myname = 0;
	stack = stack_ptr;
	p = a_iochan;
	if p -> iochan.seg then if p -> iochan.fcbp = null then return;	/* already been flushed so don't try
								   to flush it again - interaction
								   with saver */
	go to gc_close;


close_msf: procedure;

	if p -> iochan.fcbp ^= null() then call msf_manager_$close(p -> iochan.fcbp);
	p -> iochan.fcbp = null();

end;

close_output_file: procedure;

		/* Set bit count on output file and close fcb */

		if p -> iochan.fcbp ^= null()
		then do;
			if p -> iochan.fixnum_mode		/* cv words to chars */
			then p -> iochan.ioindex = p -> iochan.ioindex*4;
			call msf_manager_$adjust(p -> iochan.fcbp, p -> iochan.component, p -> iochan.ioindex*9, "111"b, code);
			if code ^= 0 then go to file_sys_fun_err_;
			call msf_manager_$close (p -> iochan.fcbp);
			p->iochan.fcbp = null();
		end;
	end close_output_file;


/*
 * This entry is called by reader or printer when an iochan has flags that say it is not OK to use
 *
 * This could be due to:
 *	1) I/O in wrong direction
 *	2) iochan has been closed
 *	3) the lisp environment has been saved and this file needs to be re-opened
 * This routine identifies the cause of the problem and fixes it or signals a fail-act
 */

fix_not_ok_iochan: entry(a_iochan, intended_dir, fail_act_f);

dcl intended_dir bit(1) aligned parameter,	/* 1 = out, 0 = in */
    fail_act_f bit(1) aligned parameter;	/* returned 1 if fail-act occurred */

	esw = -2;
	stack = stack_ptr;
	fail_act_f = "0"b;
	if intended_dir = "1"b then myname = fn_openo;
		else myname = fn_openi;
	p = a_iochan;
	if p -> iochan.fixnum_mode then data_mode = Fixnum; else data_mode = Ascii;
						/* may be needed below */
	if p -> iochan.must_reopen then 		/* we unsave the iochan only now, not in lisp_unsave_,
						   because it is only now that the use has demonstrated
						   that he still wants to use this iochan. */

	     if p -> iochan.seg then do;
		stack_ptr = addr(stack -> temp(2));
		stack -> temp(1) = p -> iochan.namelist;	/* re-open with same name as before */
		call get_path_name;
		if ^ p -> iochan.read then call open_input_file;
		else do;
		     call open_output_file;
		     call msf_manager_$get_ptr(p -> iochan.fcbp, 	/* get seg to which we were last outputting */
			p -> iochan.component, "0"b,		/* but don't try to create it if it has  gone */
			p -> iochan.ioptr, 0, code);
		     if p -> iochan.ioptr = null then go to file_sys_fun_err_;
		     end;

		/* the component number and char position are set from before, just check that the
		   file has not gotten shorter somehow */

		if p -> iochan.ioindex > p -> iochan.iolength then do;
			call close_msf;
			go to reopen_inconsistent_;
			end;
		p -> iochan.must_reopen = "0"b;
		return;
		end;
	     else  do;		/* reopening a stream, have to get  a  new buffer */
		call lisp_static_man_$allocate(p -> iochan.ioptr, divide(buffer_size, 4, 18, 0));
		p -> iochan.must_reopen = "0"b;
		return;
		end;
	else if (string(p -> iochan.flags) & "011"b) = "011"b then do;	/* file has been closed! */
		go to iochan_has_been_closed_;
		end;
	else do;
		go to io_wrong_direction_;
		end;

/*
 * Entry to make all iochans saveable - called near the beginning of the save process
 */

set_for_save: entry;

	esw = 0;
	do p = lisp_static_vars_$iochan_list
	       repeat (p -> iochan.thread)
	       while (p ^= null);
		if p -> iochan.seg then		/* streams are no problem since user has to reattach them */
		     if ^(p -> iochan.read & p -> iochan.write)	/* if still open */
		       then if p -> iochan.must_reopen then;	/* already saved from before */
		       else do;
			if ^p -> iochan.read then call close_msf;	/* close input file */
			   else call close_output_file;
set_for_save_err_ret:	p -> iochan.ioptr, p -> iochan.fcbp, p -> iochan.aclinfop = null;
			end;
		     else;	/* already closed - no action */
		else do;
			p -> iochan.ioptr =   null;	/* flush the buffer  (completely)  */
			p  ->  iochan.ioindex = 0;
			p -> iochan.nlsync = "0"b;
			if ^p -> iochan.read then  p -> iochan.iolength  = 0;
			p->iochan.fcbp = null();
			end;
			p -> iochan.must_reopen = "1"b;	/* so fix_not_ok_iochan will get called on next reference */
		end;
	return;

/*
 * lisp_io_control_$boot called at environment-boot time to set up the two initial
 * files, tty_input_chan and tty_output_chan.  These are handled slightly
 * differently from other files in some respets, so they have their
 * interactive flag turned on.  Fortunately no errors can occur here.
 */

boot:	entry;

	call make_an_iochan;		/* tty_input_chan first */
	tty_input_chan = p;
	p -> iochan.write = "1"b;		/* input chan, leave flags.read = 0 */
	p -> iochan.interactive = "1"b;
	p -> iochan.name = "user_input";
	call lisp_static_man_$allocate(p -> iochan.ioptr, divide(buffer_size, 4, 18, 0));
	p -> iochan.iolength = 0;
	call iox_$look_iocb(p->iochan.name, p->iochan.fcbp, code);
	p -> iochan.aclinfop, p -> iochan.thread = null;
	p -> iochan.function = nil;		/* default eoffn */
	p -> iochan.pagel = 0;		/* page length for non-display tty's (no 'pl' mode) is infinite */
	p -> iochan.linel = 70;		/* default line length for tty's */
	p -> iochan.charpos, p -> iochan.linenum, p -> iochan.pagenum = 0;
	p -> iochan.namelist = nil;	/* not ever used */

	q = p;
	call make_an_iochan;
	tty_output_chan = p;
	p -> iochan.read = "1"b;
	p -> iochan.interactive ="1"b;
	p -> iochan.charmode = "1"b;
	p -> iochan.name = "user_output";
	call lisp_static_man_$allocate(p -> iochan.ioptr, divide(buffer_size, 4, 18, 0));
	p -> iochan.iolength = buffer_size;
	p -> iochan.charpos, p -> iochan.linenum, p -> iochan.pagenum = 0;
	p -> iochan.pagel = q -> iochan.pagel;
	p -> iochan.linel = q -> iochan.linel;
	p -> iochan.function = nil;			/* default endpagefn */
		/* p -> iochan.namelist will get set soon by init entry */
	call iox_$look_iocb(p->iochan.name, p->iochan.fcbp, code);
	p -> iochan.aclinfop = null;
	p -> iochan.thread = q;
	addr(p -> iochan.thread)->lisp_ptr.type = File;		/* turn on type bit */
	lisp_static_vars_$iochan_list = p;
	addr(lisp_static_vars_$iochan_list)->lisp_ptr.type,	/* turn on type bits since these ptrs are gc'ed */
	addr(lisp_static_vars_$tty_input_chan)->lisp_ptr.type,
	addr(lisp_static_vars_$tty_output_chan)->lisp_ptr.type = File;

	/* initialize the variables ^q, ^r, ^w, infile, outfiles */

	addr(ctrlQ)->based_ptr -> atom.value,
	addr(ctrlR)->based_ptr -> atom.value,
	addr(ctrlW)->based_ptr -> atom.value,
	addr(instack)->based_ptr -> atom.value,
	addr(outfiles)->based_ptr -> atom.value = nil;
	addr(infile)->based_ptr -> atom.value = t_atom;

	return;


/*
 * Routine to dump buffer of output stream.  p -> iochan.
 */

dump_buffer: proc;

	if p->iochan.ioindex = 0 then do; p -> iochan.nlsync = "0"b; return; end;	/* bugs in various io modules */
	if p->iochan.fcbp = null() then call get_iocb;
	if p->iochan.fixnum_mode then p->iochan.ioindex = 4*p->iochan.ioindex;
	call iox_$put_chars(p->iochan.fcbp, p->iochan.ioptr, p->iochan.ioindex, code);
	if code ^= 0 then go to file_sys_fun_err_;
	p -> iochan.ioindex = 0;			/* the buffer is now empty */
	p -> iochan.nlsync = "0"b;			/* .. */
	end dump_buffer;

get_iocb: procedure;

	call iox_$look_iocb(p -> iochan.name, p -> iochan.fcbp, status);
	if status ^= 0 then do;
		code = status;
		go to file_sys_fun_err_;
	end;
	end get_iocb;



/*
 * Entry to empty all buffers of all output streams
 */

empty_all_buffers: entry;

	esw = -4;
	do p = lisp_static_vars_$iochan_list
	      repeat (p -> iochan.thread)
	      while (p ^= null);
		if ^ p -> iochan.seg then if ^ p -> iochan.write	/* open output stream */
			then call dump_buffer;
empty_all_err_ret:
		end;
	return;


/*
 * Initialize entry
 */

init: entry;


	/* initialize default namelist to (working-dir  .  *)  */

	dname = get_wdir_();
	i = length(dname) + 1 - verify(reverse(dname), " ");
	stack = stack_ptr;
	stack_ptr = addr(stack -> temp(3));
	call lisp_get_atom_(substr(dname, 1, i), stack -> temp(1));
	stack -> temp(2) = star;
	call lisp_special_fns_$cons;
	tty_output_chan -> iochan.namelist = stack -> temp(1);
	stack_ptr = stack;

	/* get the real pagel and linel for the tty from the DIM */

	tty_input_chan -> iochan.charpos, tty_output_chan -> iochan.charpos = 0;	/* also resetting all this cruft */
	tty_input_chan -> iochan.linenum, tty_output_chan -> iochan.linenum = 0;
	tty_input_chan -> iochan.pagenum, tty_output_chan -> iochan.pagenum = 0;
	tty_input_chan -> iochan.pagel, tty_output_chan -> iochan.pagel = 0;
	tty_input_chan -> iochan.linel, tty_output_chan -> iochan.linel = 80;	/* default should be 0 but for sake of Macsyma, ... */

	call iox_$look_iocb(tty_output_chan->iochan.name, tty_output_chan->iochan.fcbp, status);
	if status ^= 0 then go to no_modes_available;
	call iox_$modes(tty_output_chan->iochan.fcbp, "", user_io_modes, status);
	if status ^= 0 then go to no_modes_available;

	/* Extract line length and page length from mode string if possible */

	mode_value_ptr = addr (amv);
	mode_value_ptr -> mode_value.version = mode_value_version_3;
	mode_value_ptr -> mode_value.flags = "0"b;

	call mode_string_$get_mode (user_io_modes,"ll",mode_value_ptr,status);
	if status = 0
	then if mode_value_ptr -> mode_value.numeric_valuep
	     then tty_input_chan -> iochan.linel,tty_output_chan -> iochan.linel = mode_value_ptr -> mode_value.numeric_value;

	mode_value_ptr -> mode_value.flags = "0"b;

	call mode_string_$get_mode (user_io_modes,"pl",mode_value_ptr,status);

	if status = 0
	then if mode_value_ptr -> mode_value.numeric_valuep
	     then tty_input_chan -> iochan.pagel,tty_output_chan -> iochan.pagel = mode_value_ptr -> mode_value.numeric_value;

	/* flush tty buffers */

no_modes_available:
	tty_input_chan -> iochan.ioindex, tty_input_chan -> iochan.iolength = 0;

	tty_output_chan -> iochan.ioindex = 0;

	/* make uread, etc. default to working dir */

	lisp_static_vars_$old_io_defaults -> atom.value = nil;

	return;


/*
 * Called by other i/o functions when the end of a block (stream buffer or m.s.f. segment)
 * is reached on either input or output.  All good things are done, including handling
 * of end-of-file.  A return code is passed to the caller to tell him what action was taken.
 */

end_of_block:  entry (a_iochan, eofval, cde);

dcl a_iochan ptr,  eofval fixed bin(71) /* a lisp object */,  cde fixed bin;
		/*  cde = 0 --> OK
			1 --> eof - continue reading
			2 --> eof - return eofval immediately (used for fail-act's too)
		         -1 --> select new input file
		         -2 --> error - must select new file.  bad_input_source or bad_output_dest err has been done
		*/

	esw = -3;
	cde = 0;		/* assuming eof or err is not going to happen */
	p = a_iochan;
	if ^ p -> iochan.write then
	   if p -> iochan.seg then do;

		/* end of seg on output msf, call msf manager to get next seg */

		p -> iochan.component = p -> iochan.component + 1;
		call get_output_seg_ptr;
		p -> iochan.ioindex = 0; 	/* start at beginning of this seg */
		end;
	      else call dump_buffer;		/* Buffer full on stream - dump it */
	else
	   if p -> iochan.seg then do;

		/* End of input seg, try to get another one from msf manager */

		p -> iochan.component = p -> iochan.component + 1;
		call msf_manager_$get_ptr(p -> iochan.fcbp, p -> iochan.component,
			"0"b, p -> iochan.ioptr, bc, code);
		p -> iochan.ioindex, p -> iochan.iolength = 0;
		if p -> iochan.ioptr = null	/* Error return */
			then if code = error_table_$noentry then go to E_O_F;
			else go to file_sys_fun_err_;	/* LOSE!! */
		if p -> iochan.fixnum_mode
		then p -> iochan.iolength = divide(bc, 36, 24, 0);
		else p -> iochan.iolength = divide(bc, 9, 24, 0);
		end;
	  else do;

		/* End of stream buffer, call iox_$read */

		p -> iochan.ioindex, p -> iochan.iolength = 0;
		if p->iochan.fcbp = null() then call get_iocb;
		if p -> iochan.interactive then do;

			/* tty_input_chan, flush tty_output_chan (before going blocked) */

			q = p;
			p = tty_output_chan;
			call dump_buffer;
			p -> iochan.charpos = 0;		/* tty is now at left margin */
			p = q;

			/* fix up rdr state stuff so quit while blocked in iox_$read will work right */

			rdr_label = input_wait_ab_exit;
			rdr_state = 1;
			end;

		if p->iochan.fixnum_mode
		then do;
			call iox_$get_chars(p->iochan.fcbp, p->iochan.ioptr, (buffer_size), p->iochan.iolength, code);
			p->iochan.iolength = divide(p->iochan.iolength+3,4,24,0);
		     end;
		else call iox_$get_line(p->iochan.fcbp, p->iochan.ioptr, (buffer_size), p->iochan.iolength, code);

		rdr_state = 0;

		/* check status for eof, err */

		if code ^= 0
		then if code = error_table_$end_of_info then goto E_O_F;
		     else if code = error_table_$long_record then return;
			else goto file_sys_fun_err_;
		else return;

		/* come here if some kind of quit while blocked on user_input.  Return a code -1
		   to tell the caller to check whether he wants to input from a different file now */
input_wait_ab_exit:
		rdr_state = 0;
		cde = -1;
		return;

		end;
	return;		/* successfully got next block, continue the i/o operation */

/* END OF FILE HANDLING
 *
 * come here with p -> iochan, eofval = nil or arg to read, cde will be set to 1 or 2
 */

E_O_F:
	if eofval = t_atom then go to eof_imm_ret;	/* this is tyipeek - don't use the eoffn */
	if p -> iochan.function ^= nil then do;

		/* Call user's eof function, args = p, eofval */

		stack = stack_ptr;
		stack_ptr = addr(stack -> temp(5));
		stack -> temp(4) = nil;	/* cons up arg list for apply */
		stack -> temp(3) = eofval;
		p_.type = File;
		stack -> temp(2) = p_fb;
		stack -> temp(1) = p -> iochan.function;
		call lisp_special_fns_$cons;
		call lisp_special_fns_$cons;
		call lisp_$apply;

		/* check the value returned by the eoffn */

		if stack -> temp(1) = nil then go to eof_nil_1;
		 else if stack -> temp(1) = t_atom then do;
			stack_ptr = stack;
			cde = 1;			/* proceed, eoffn has done insel */
			return;
			end;
		eofval = stack -> temp(1);	/* force read to return what the eoffn retturned */
		stack_ptr = stack;
		go to eof_imm_ret;

		end;

	else do;

		/* No eoffn -- default handling directed by eofval */

		if eofval ^= nil then go to eof_imm_ret;	
			/* if eofval supplied on call to read, return it */
eof_nil:				/* no eofval - close this file and continue reading from the one selected by close */

		stack = stack_ptr;
		stack_ptr = addr(stack -> temp(2));
eof_nil_1:
		p_.type = File;
		stack -> temp(1) = p_fb;
		call lisp_io_control_$close;
		cde = 1;
		return;


eof_imm_ret:	/* force read to return eofval immediately */

		cde = 2;
		return;

		end;

/*
 * Error Handling
 *
 * all errors (almost) come to these routines.  The stack is fiddled
 * and lisp_error_ is called.  What happens when lisp_error_ returns
 * and what is put on the stack as an argument to the fail-act routine
 * is determined by esw, the entry switch.
 */

/* routine to call lisp_error_ */

error:	proc;

dcl unm ptr,
    ercode(2) aligned based(unm) fixed bin,
    lisp_error_ entry;

	unm = unmkd_ptr;
	unmkd_ptr = addrel(unm, 2);
	ercode(1) = err;
	ercode(2) = myname;
	call lisp_error_;
	end;

/*
 * Funny errors in fix_not_ok_iochan
 */

reopen_inconsistent_:
	err = lisp_error_table_$reopen_inconsistent;
	stack_ptr = stack;
	go to inouterr1;

io_wrong_direction_:
	err = lisp_error_table_$io_wrong_direction;
	go to inouterr;

iochan_has_been_closed_:
	err = lisp_error_table_$file_is_closed;
	go to inouterr;

inouterr:
	/* make list (infile x) or (outfile x) as arg to fail-act */

	stack = stack_ptr;
inouterr1:
	stack_ptr = addr(stack -> temp(4));
	if p -> iochan.write
	then stack -> temp(1) = lisp_static_vars_$infile;
	else stack -> temp(1) = lisp_static_vars_$outfile;
errproc_aa:		/** other errors join here **/
	stack -> temp(3) = nil;
	p_.type = File;
	stack -> temp(2) = p_fb;
errproc_cc:		/** and here **/
	call lisp_special_fns_$cons;
	call lisp_special_fns_$cons;
	if esw = 7 then do;			/* special kludgery for rename because
					   it moves 'stack.' */
		rnstack -> temp(1) = stack -> temp(1);
		stack = rnstack;
		stack_ptr = addrel(stack, 2);
		end;
	myname = code;			/* fake out 'error' proc in case of file_sys_fun_err */
	call error;
	go to errtn(esw);			/* crawl out in entry-dependent way */

/* error exit for lisp_io_control_$fix_not_ok_iochan -- reflect to caller */

errtn(-2):
	if intended_dir = "1"b then addr(ctrlR)->based_ptr -> atom.value = t_atom;
				else addr(ctrlQ)->based_ptr -> atom.value = t_atom;
	stack_ptr = stack;
	fail_act_f = "1"b;
	return;				/* value of fail-act has been pushed onto marked pdl */

errtn(-4):	/* lisp_io_control_$empty_all_buffers - just continue in do loop */

	stack_ptr = stack;
	go to empty_all_err_ret;

errtn(-3):	/* lisp_io_control_$end_of_block -- tell caller and give him value of the fail-act */

	cde = -2;
	if ^ p -> iochan.read then addr(ctrlQ)->based_ptr -> atom.value = t_atom;
	if ^ p -> iochan.write then addr(ctrlR)->based_ptr -> atom.value = t_atom;
	stack_ptr = stack;
	return;

	/* lisp fcn entry points just return value of fail-act as their value */

errtn(7):   errtn(1):    errtn(2):    errtn(3):     errtn(5):     errtn(4):    errtn(6):

	stack_ptr = addr(stack -> temp(2));
	return;



/*
 * General file system errors come here
 *
 * We take a fail-act with args = a list of some fcn name and the file object
 * the action on return from the fail-act is controlled by esw
 * 'code' contains a Multics status code, from which the error message will be derived * myname is not used
 */

file_sys_fun_err_:
	err = lisp_error_table_$file_sys_fun_err;
	go to errproc(esw);		/* set up stack, get name of fcn */


errproc(1):
errproc(2):
errproc(3):
errproc(4):
errproc(5):
	stack_ptr = addr(stack -> temp(4));
	call get_fname;
	go to errproc_aa;


errproc(7):	/* cons up list of 'rename and both (processed) args */

	stack_ptr = addr(stack -> temp(5));
	stack -> temp(4) = nil;
	stack -> temp(3) = stack -> temp(2);
	stack -> temp(2) = stack -> temp(1);
	call get_fname;
	call lisp_special_fns_$cons;
	go to errproc_cc;

errproc(0):	/* lisp_io_control_$set_for_save
		 *** the lisp error mechanism is not in operation,
		 *** so barf through com_err_ and continue with our do loop
	 	 */

	call com_err_(code, "lisp_io_control_", "^/^-Trying to close and save file object ""^a"" at ^p",
				p -> iochan.name /* don't bother with full path name */,  p);
	go to set_for_save_err_ret;


errproc(-1):	/* lisp_io_control_$gc_flush -- failed trying to auto-close */

	call com_err_(code, "lisp_io_control_", "^/^-Trying to auto-close file object ""^a"" at ^p",
				p -> iochan.name, p);
	go to gc_close_1;			/* just ignore the error, except for now print kludgey message */

errproc(-2):	/* lisp_io_control_$fix_not_ok_iochan -- fcn name is infile or outfile  */

	if intended_dir = "1"b then addr(ctrlR)->based_ptr -> atom.value = nil;
			else addr(ctrlQ)->based_ptr -> atom.value = nil;
	go to inouterr1;

errproc(-3):	/* lisp_io_control_$end_of_block -- fcn name is again infile or outfile (still a hack) */

	if ^ p -> iochan.read then addr(ctrlQ)->based_ptr -> atom.value = nil;
	if ^ p -> iochan.write then addr(ctrlR)->based_ptr -> atom.value = nil;
	go to inouterr;

errproc(-4):	/* lisp_io_control_$empty_all_buffers -- lisp error mechanism may not be working (quit or save),
		   so just ignore the error and go on to the next buffer */
	go to empty_all_err_ret;

errproc(-5):	/* lisp_io_control_$cleanup -- ignore the error completely (what else would you do?) */

	go to cleanup_err_ret;


/*
 * routine to put lisp atom qhich is name of function selected by esw into stack -> temp(1) -- used for errors
 */

get_fname: proc;

	go to gfn(esw);

gfn(1):
gfn(2):
gfn(3):	stack -> temp(1) = lisp_static_vars_$open;
	return;

gfn(4):	stack -> temp(1) = lisp_static_vars_$close;
	return;

gfn(5):	stack -> temp(1) = lisp_static_vars_$mergef;
	return;

gfn(6):	stack -> temp(1) = lisp_static_vars_$deletef;
	return;

gfn(7):	stack -> temp(1) = lisp_static_vars_$rename;
	return;

	end;

/*
 * cleanup entry called by lisp command cleanup handler
 * we close all files
 */

cleanup:	entry;

	esw = -5;

	do p = lisp_static_vars_$iochan_list
	     repeat (p -> iochan.thread)
	     while (p ^= null);

		if (string(p -> iochan.flags) & "011"b) ^= "011"b then	/* if still open */
		     if p -> iochan.seg then
		        if p -> iochan.fcbp ^= null then
			if ^ p -> iochan.read then
				call close_msf;
			    else call close_output_file;
cleanup_err_ret:	end;
	return;

/*
 * lisp mergef lsubr
 *  calls same internal routine umergef as the open functions
 */

mergef:	entry;

	stack = addrel(stack_ptr, -2);	/* get arg count */
	nargs = stack -> fixedb;
	stack = addrel(stack, nargs);
	nargs = divide(nargs, -2, 17, 0);
	esw = 5;
	myname = fn_mergef;

	call umergef;

	go to exit;

/*
 * Internal proc to perform application of defaults by mergeing of namelists
 *
 * called with stack -> array of namelists, nargs = how many
 * returns with stack -> one namelist result
 * also expands namestrings into namelists
 * in the case where this was called by a function other than
 * mergef itself, the result is checked for improper format.
 * otherwise no error checking is done; when you try to use
 * the result the presence of e.g. numbers will cause err msg
 */

umergef:	proc;

	dcl sp ptr,	/* -> arg being processed */
	    unm ptr,
	    tp ptr;	/* -> top of stack area for making arg lists to cons */
			/* stack -> current result-list */

	sp = stack;
	tp = stack_ptr;
	if stack -> temp_type(1) then	/* convert to a list */
	     do;
		stack_ptr = addrel(tp, 2);
		tp -> temp(1) = stack -> temp(1);
		call lisp_io_fns_$internal_namelist(myname);
		stack -> temp(1) = tp -> temp(1);
		end;
	do while (nargs >= 2);	/* go through arguments */
		if stack -> temp_ptr(1) -> cons.car = stream then go to exitloop;	/* streams don't need all this
							lossage, just fall right through */
	     sp = addrel(sp, 2);	/* next arg... */
	     nargs = nargs-1;
	     if sp -> temp(1) = nil then do;		/* special kludge - drop last name */
		if stack -> temp_ptr(1) -> cons_types.cdr = Cons then do;
		     stack_ptr = addrel(tp, 2);
		     tp -> temp(1) = nil;
		     do sp -> temp(1) = stack -> temp(1)	/* copy the arg, except for last cons */
			     repeat(sp -> temp_ptr(1) -> cons.cdr)
			     while(sp -> temp_ptr(1) -> cons_types.cdr = Cons);
			stack_ptr = addrel(tp, 4);
			tp -> temp(2) = sp -> temp_ptr(1) -> cons.car;
			call lisp_special_fns_$xcons;
			end;
		     call lisp_list_utils_$nreverse;
		     stack -> temp(1) = tp -> temp(1);		/* move result down */
		     stack_ptr = tp;
		     end;
		end;
	     else do;
		if sp -> temp_type(1) then do;	/* convert to a list */
		     stack_ptr = addrel(tp, 2);
		     tp -> temp(1) = sp -> temp(1);
		     call lisp_io_fns_$internal_namelist(myname);
		     sp -> temp(1) = tp -> temp(1);
		     end;

		/* normal mergef case - (margef x y) where x and y are lists */

		stack_ptr = addrel(tp, 2);
		tp -> temp(1) = nil;		/* going to cons up reverse output list */
		do while (stack -> temp_type(1) = Cons &
			sp -> temp_type(1) = Cons);	/* do while both lists hold out */

			stack_ptr = addrel(tp, 4);
			if stack -> temp_ptr(1) -> cons.car ^= star then
				tp -> temp(2) = stack -> temp_ptr(1) -> cons.car;
			     else tp -> temp(2) = sp -> temp_ptr(1) -> cons.car;
					/* select from x unless *, in which case take from y */
			call lisp_special_fns_$xcons;
			stack -> temp(1) = stack -> temp_ptr(1) -> cons.cdr;
			sp -> temp(1) = sp -> temp_ptr(1) -> cons.cdr;
			end;

		/* one or both of the lists has come to an end */

			if stack -> temp_type36(1) & Atsym36 then	/* x has come to the end, */
			  if stack -> temp(1) ^= nil then do;		/* x is dotted */
			     do while (sp -> temp_type(1) = Cons);   /* copy rest of y over */
				stack_ptr = addrel(tp, 4);
				tp -> temp(2) = sp -> temp_ptr(1) -> cons.car;
				call lisp_special_fns_$xcons;
				sp -> temp(1) = sp -> temp_ptr(1) -> cons.cdr;
				end;
			     if stack -> temp(1) ^= star then	/* x had dotted atom, make sure list ends with it */
				if stack -> temp(1) ^= tp -> temp_ptr(1) -> cons.car
				     then do;
					stack_ptr = addrel(tp, 4);
					tp -> temp(2) = stack -> temp(1);
					call lisp_special_fns_$xcons;
					end;
			     go to x01;
			     end;

			/* copy rest of names in x */

			do while (stack -> temp_type(1) = Cons);
			     stack_ptr = addrel(tp, 4);
			     tp -> temp(2) = stack -> temp_ptr(1) -> cons.car;
			     call lisp_special_fns_$xcons;
			     stack -> temp(1) = stack -> temp_ptr(1) -> cons.cdr;
			     end;

			if sp -> temp(1) ^= nil then		/* if there is more to the list, */
			  if sp -> temp_type(1) ^= Cons then	/* y ends with a dotted atom */
			    if sp -> temp(1) ^= star then	/* other than .*, which is ignored */
			      if tp -> temp_ptr(1) -> cons.car	/* then make sure the list ends with this */
					^= sp -> temp(1) then do;
				stack_ptr = addrel(tp, 4);
				tp -> temp(2) = sp -> temp(1);
				call lisp_special_fns_$xcons;
				go to x01;
				end;
x01:			call lisp_list_utils_$nreverse;	/* the list was consed up in the wrong order */
			stack -> temp(1) = tp -> temp(1);	/* move result down */
			end;
		end;

exitloop:	/* all done processing args, maybe check for errors */

	if myname ^= fn_mergef then do;	/* if called internally, make sure args to openi, etc. are OK */
	     nargs = 0;
	     do tp -> temp(1) = stack -> temp(1)
		repeat (tp -> temp_ptr(1) -> cons.cdr)
		while (tp -> temp_type(1) = Cons);

		nargs = nargs + 1;
		if tp -> temp_ptr(1) -> cons.car = star then go to stars_left;
		else if tp -> temp_ptr(1) -> cons_types36.car & String36 then do;	/* string is ok */
			call lisp_get_atom_(tp -> temp_ptr(1) -> cons_ptrs.car -> lisp_string.string,
					tp -> temp_ptr(1) -> cons.car);
			end;
		else if tp -> temp_ptr(1) -> cons_types36.car & Numeric36 then do;	/* number is ok */

			/* bind *nopoint to t */

			unm = unmkd_ptr;
			unmkd_ptr = addrel(unm, 2);
			stack_ptr = addr(tp -> temp(5));
			unm -> binding_block.bot_block = rel(addr(tp -> temp(2)));
			unm -> binding_block.top_block = rel(addr(tp -> temp(4)));
			unm -> binding_block.back_ptr = rel(binding_top);
			tp -> temp(3) = lisp_static_vars_$stnopoint;
			tp -> temp(2) = tp -> temp_ptr(3) -> atom.value;
			binding_top = unm;
			tp -> temp_ptr(3) -> atom.value = t_atom;

			/* call exploden on the number */

			tp -> temp(4) = tp -> temp_ptr(1) -> cons.car;
			call lisp_print_$exploden;

			/* maknam the result */

			call lisp_reader_$maknam;

			/* rplaca it back into the namelist */

			tp -> temp_ptr(1) -> cons.car = tp -> temp(4);

			/* get rid of the binding */

			tp -> temp_ptr(3) -> atom.value = tp -> temp(2);
			binding_top = ptr(binding_top, unm -> binding_block.back_ptr);
			unmkd_ptr = unm;
			stack_ptr = addr(tp -> temp(2));
			end;

		else if tp -> temp_ptr(1) -> cons_types.car & ^Atsym then go to stars_left;	/* random - barf */
		end;
	     if tp -> temp(1) ^= nil then go to stars_left;	/* dotted list is NG */

		/* expand the directory path name if necessary */

	     if stack -> temp_ptr(1) -> cons.car ^= stream then
	     if substr(stack -> temp_ptr(1) -> cons_ptrs.car -> atom.pname, 1, 1) ^= ">" then do;
		call expand_path_(addr(stack -> temp_ptr(1) -> cons_ptrs.car -> atom.pname),
			        stack -> temp_ptr(1) -> cons_ptrs.car -> atom.pnamel,
			        addr(dname),
			        null,
			        code);
		nargs = index(dname, " ")-1; if nargs < 0 then nargs = length(dname);
		if code = 0 then call lisp_get_atom_(substr(dname, 1, nargs), stack -> temp_ptr(1) -> cons.car);
									/* ok to rplaca since was copied */
		end;
	     end;
	stack_ptr = addrel(stack, 2);		/* flush args & stuff from stack */
	return;
	end;

/* Error handling for umergef */

stars_left:
	err = lisp_error_table_$stars_left_in_name;	/* or any namelist format error */
errproc_6_join:
	stack_ptr = addr(stack -> temp(4));
	stack -> temp(3) = nil;
	stack -> temp(2) = stack -> temp(1);
	call get_fname;
	go to errproc_cc;

/*
 * Lisp file deletion function
 */

deletef:	entry;

	stack = addrel(stack_ptr, -2);	/* subr 1 arg */
	myname = fn_deletef;
	esw = 6;
	stack_ptr = addr(stack -> temp(3));
	stack -> temp(2) = tty_output_chan -> iochan.namelist;	/* mergef arg with defaults */
	nargs = 2;
	call umergef;

	call get_path_name_0;		/* set dname, ename */

	call delete_$path(dname, substr(ename, 1, length(ename)-1),
		"000110"b,	/* no questions, df seg & msf, don't chase links, don't force if ssw on */
		"", code);
	if code = 0 then go to exit;

	err = lisp_error_table_$file_sys_fun_err;
errproc(6):
	go to errproc_6_join;	/* previous page */

/*
 * Lisp file renaming function
 */

rename:	entry;

	rnstack, stack = addrel(stack_ptr, -4);	/* subr 2 args */
	myname = fn_rename;
	esw = 7;
	stack_ptr = addr(stack -> temp(5));
	stack -> temp(4) = tty_output_chan -> iochan.namelist;
	stack -> temp(3) = stack -> temp(1);	/* put first arg over the defaults */
	nargs = 2;
	stack = addr(stack -> temp(3));
	call umergef;
	rnstack -> temp(1) = stack -> temp(1);		/* save processed first arg */
	stack = addrel(stack, -2);
	nargs = 2;
	call umergef;			/* put second arg over (first arg over defaults) */
	call get_path_name_0;		/* get ename for second arg */
	other_ename = substr(ename, 1, length(ename)-1);

	stack = rnstack;				/* back where it was originally */
	call get_path_name_0;		/* get dname and ename for original name */

	call hcs_$chname_file(dname, substr(ename, 1, length(ename)-1), substr(ename, 1, length(ename)-1),
			other_ename, code);
	if code ^= 0 then go to file_sys_fun_err_;
	stack -> temp(1) = stack -> temp(2);		/* return value is processed second arg */
	go to exit;

force_output: entry;

/* the force output function, which forces an output file
   to disgorge its buffer */

	myname = fn_force_output;
fo_ci_join:
	stack = addrel(stack_ptr, -2);			/* subr, arg = file */
fo_ci_retry:
	if stack -> temp(1) = nil | stack -> temp(1) = t_atom
	   then if myname = fn_force_output then p = tty_output_chan;
		else p = tty_input_chan;
	else if stack -> temp_type36(1) & File36
	   then p = stack -> temp_ptr(1);
	else do;
fo_ci_barf:
	     err = lisp_error_table_$bad_arg_correctable;
	     call error;
	     go to fo_ci_retry;
	     end;

	if p -> iochan.seg then return;			/* nugatory for files */
	if p -> iochan.must_reopen then call lisp_io_control_$fix_not_ok_iochan(p, "1"b, ("0"b));	/* mung stream buffer if first use */
	     dcl lisp_io_control_$fix_not_ok_iochan entry(ptr, bit(1) aligned, bit(1) aligned);

	/* check direction */

	if myname = fn_force_output then
	    if p -> iochan.write then go to fo_ci_barf;
	    else;
	else /* if myname = fn_clear_input then */
	    if p -> iochan.read then go to fo_ci_barf;
	    else;

	/* p -> iochan to be munged */

	if myname = fn_force_output then call dump_buffer;
	   else do;		/*(clear-input p)*/
	     p -> iochan.ioindex = 0;
	     p -> iochan.iolength = 0;
	     if p -> iochan.fcbp = null() then call get_iocb;
	      call iox_$control (p->iochan.fcbp, "resetread", null(), status);
	     end;
	return;

clear_input:	entry;

	myname = fn_clear_input;
	go to fo_ci_join;

/* this is the lisp %include function, which works like %include in pl/1 */

percent_include:  entry;

	stack = addrel(stack_ptr, -2);	/* fsubr - pick up argument */
	stack -> temp(1) = stack -> temp_ptr(1) -> cons.car;
	go to include_common;

includef: entry;	/*** (includef, same as %include except subr ***/

	stack = addrel (stack_ptr, -2);	/* subr 1 arg */

include_common:
	if stack -> temp_type36(1) & String36
	then ename = stack -> temp_ptr(1) -> lisp_string.string;
	else if stack -> temp_type36(1) & Atsym36
	then ename = stack -> temp_ptr(1) -> atom.pname;
	else go to include_file_not_found;	/* no numbers, etc. */

	/* tack ".incl.lisp" on the end of ename */

	if length(ename) > 22 then go to include_file_name_truncated;
	other_ename = ename || ".incl.lisp";

	/* find the include file */

	call find_include_file_$initiate_count("lisp", null, 	/* phooey on referencing_dir rule */
			(other_ename), (0), q, code);
	if q = null then go to include_file_not_found_but_have_code;

	/* get the actual pathname of the include file (what a Kludge) */

	call hcs_$fs_get_path_name(q, dname, (0), other_ename, code);
	if code ^= 0 then go to include_file_not_found_but_have_code;	/* (??) */

	/* create and initialize an iochan block (file object) */

	call make_an_iochan;
	p -> iochan.charpos, p -> iochan.linenum, p -> iochan.pagenum = 0;
	p -> iochan.pagel = 59;		/* random constant - see open */
	p -> iochan.linel = 110;		/* random constant - see open */
	p -> iochan.function = tty_input_chan -> iochan.function;	/* default eoffn */
	p -> iochan.write = "1"b;				/* input channel!! */

	/* construct namelist - assume our argument contained no dots (Kludge?) */

	stack_ptr = addr(stack -> temp(7));
	stack -> temp(6) = nil;
	call lisp_get_atom_("lisp", stack -> temp(5));
	call lisp_get_atom_("incl", stack -> temp(4));
	call lisp_get_atom_((ename), stack -> temp(3));
	i = verify(reverse(dname), " ");		/* strip trailing blanks for directory path name */
						/* i /= 0 is assumed since all blank dname would be wierd */
	call lisp_get_atom_(substr(dname, 1, length(dname)-i+1), stack -> temp(2));
	do i = 0 to 3;
	   call lisp_special_fns_$cons;
	   end;
	p -> iochan.namelist = stack -> temp(2);		/*** Note: assume p survives through g.c. ***/

	/* open the input file */

	p -> iochan.seg = "1"b;
	p -> iochan.name = other_ename;
	esw = -6;				/* prepare error return */
	call open_input_file;

	/* all set, thread into iochan list */

	p -> iochan.thread = lisp_static_vars_$iochan_list;
	lisp_static_vars_$iochan_list = p;

	/* turn on type bit and turn into lisp object in marked stack */

	p_.type = File;
	stack -> temp(1) = p_fb;

	/* inpush it */

	stack_ptr = addr(stack -> temp(2));
	call lisp_io_fns_$inpush;

	/* turn on ^q flag so will start reading from this place (if %include from tty!!) */

	addr(ctrlQ) -> based_ptr -> atom.value = t_atom;
	return;			/* inpush has left right things on stack */

include_file_name_truncated:
	code = error_table_$entlong;
	go to include_file_not_found_but_have_code;

include_file_not_found:
	code = error_table_$noentry;
include_file_not_found_but_have_code:
errproc(-6):		/* error exit from open_input_file */
	/* signal uncorrectable lisp error */

	stack_ptr = addr(stack -> temp(4));	/* stack -> temp(1) = our arg */
	stack -> temp(3) = nil;		/* cons up kludgey error message */
	stack -> temp(2) = stack -> temp(1);
	call lisp_get_atom_("%include", stack -> temp(1));
	call lisp_special_fns_$cons;
	call lisp_special_fns_$cons;

	myname = code;			/* Gag! pass error_table_ code to lisp_error_ */
	err = lisp_error_table_$include_file_error;
	call error;			/* never returns - uncorrectable error */
	return;

/*
 * Fixnum I/O Functions
 */

in:	entry;

dcl fail_flag bit(1) aligned,
    word fixed bin(35),
    words (0:1000) fixed bin(35) based;

	myname = fn_in;

reget_in:	stack = addrel(stack_ptr, -2);		/* subr 1 arg */
	do while((stack -> temp_type36(1) & File36) = ""b);
	   err = lisp_error_table_$bad_arg_correctable;
	   call error;
	   end;
	p = stack -> temp_ptr(1);			/* -> iochan */
	if string(p -> iochan.flags) & not_ok_to_read_fixnum then go to in_loss;
	else if ^ p -> iochan.fixnum_mode then do;
in_loss:	     call fix_not_ok_iochan(p, "0"b, fail_flag);
	     if fail_flag then go to reget_in;
	     end;

	if p -> iochan.ioindex >= p -> iochan.iolength
	then do;
	     call end_of_block(p, (nil), codde);
	     if codde ^= 0 then return;		/* foo.  shouldn't happen */
	     end;

	word = p -> iochan.ioptr -> words(p -> iochan.ioindex);
in_out_ret:
	p -> iochan.ioindex = p -> iochan.ioindex + 1;
	stack -> fixnum_fmt.type_info = fixnum_type;
	stack -> fixedb = word;
	return;


out:	entry;

	myname = fn_out;

reget_out:stack = addrel(stack_ptr, -4);		/* subr 2 args */
	do while((stack -> temp_type36(2) & Fixed36) = ""b);
	   err = lisp_error_table_$bad_arg_correctable;
	   call error;
	   end;
	word = addr(stack -> temp(2)) -> fixedb;
	stack_ptr = addr(stack -> temp(2));
	do while((stack -> temp_type36(1) & File36) = ""b);
	   err = lisp_error_table_$bad_arg_correctable;
	   call error;
	   end;
	p = stack -> temp_ptr(1);
	if string(p -> iochan.flags) & not_ok_to_write_fixnum then go to out_loss;
	else if ^ p -> iochan.fixnum_mode then do;
out_loss:	     call fix_not_ok_iochan(p, "1"b, fail_flag);
	     if fail_flag then go to reget_out;
	     end;

	if p -> iochan.ioindex >= p -> iochan.iolength
	then do;
	     call end_of_block(p, (nil), codde);
	     if codde ^= 0 then return;
	     end;

	p -> iochan.ioptr -> words(p -> iochan.ioindex) = word;
	go to in_out_ret;
end lisp_io_control_;
