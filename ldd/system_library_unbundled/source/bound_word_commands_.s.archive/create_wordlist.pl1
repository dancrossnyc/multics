/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1989                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(85-09-13,Spitzer), approve(85-09-13,MCR6618),
     audit(85-10-30,Blair), install(85-12-16,MR12.0-1001):
     Allow to read/write
     MSFs.
  2) change(88-10-05,Lee), approve(88-11-14,MCR8018), audit(88-11-28,Flegel),
     install(89-01-23,MR12.3-1010):
     phx20562 (Commands 478) - fixed bug in locate_words when -lines
     control arg is specified.
                                                   END HISTORY COMMENTS */

create_wordlist: cwl: proc;

/* converted 7/12/77 by J. Stern from word_list to create_wordlist 
   modified 05/28/80 by P. Benjamin to fix missing -li shortname for -lines
		 and fix bug where -li has no arg and should default to 0
   modified 05/29/80 by P. Benjamin to fix -lg bug where all lines not printed.
*/


/* Automatic */

dcl  temp_dir char (168);
dcl  (uid_in, uid_out) bit (36) aligned;		/* File UIDs */
dcl  current_record fixed bin (24);
dcl  max_line_len fixed bin (21);			/* size of read input buffer */
dcl  changed_lines bit (1) aligned;			/* =1b, changed input line */
dcl  output_record_number fixed bin (35);		/* record number in temp file */
dcl  (inputp, outputp, sortp) ptr init (null);		/* IOCB pointers */
dcl  type fixed bin (2);				/* 1=segment, 2=directory */
dcl  msf bit (1) aligned;
dcl (nmp, mpp, mlp, rlp, rpp, system_area_ptr) ptr init (null);
dcl  ap ptr;
dcl  al fixed bin;
dcl (ldpp, ldcp) ptr init (null);
dcl  old_ptr ptr;
dcl  old_count fixed bin;
dcl  plip ptr init (null);
dcl  prevx fixed bin;
dcl  lines fixed bin (24) init (-1);
dcl (argno, n_args, n_words, wordx) fixed bin;
dcl  no_sort_opt bit (1) aligned init ("0"b);
dcl (brief_opt, long_opt) bit (1) aligned init ("0"b);
dcl  header_opt bit (1) aligned init ("0"b);
dcl  no_exclude_opt bit (1) aligned init ("0"b);
dcl  count_opt bit (1) aligned init ("0"b);
dcl  no_control_opt bit (1) aligned init ("0"b);
dcl (cwl_cmd, lw_cmd, rw_cmd) bit (1) aligned init ("0"b);
dcl  got_pname bit (1) aligned init ("0"b);
dcl  invalid_sw bit (1) aligned;
dcl  ul_sw bit (1) aligned;
dcl  whoami char (16);
dcl  (ename, input_ename, sort_name) char (32);
dcl  (dname, input_dname, sort_dir) char (168);
dcl  arg_syntax char (120);
dcl  code fixed bin (35);
dcl  bc fixed bin (24);
dcl  temp_ptr_array (3) ptr init ((3) null);
dcl (input_ptr, temp_ptr, output_ptr, sort_data_ptr) ptr init (null);
dcl (input_len, output_len, temp_len) fixed bin (21);
dcl  line_ptr ptr;
dcl  strip_ptr ptr;
dcl (to_line, from_line) fixed bin (24) init (0);
dcl (delim_ix, delim_len, line_ix, line_len, ul_spaces) fixed bin (21);
dcl (token_ix, token_len, strip_ix, strip_len, word_ix, word_len, ul_ix, ul_len) fixed bin (24);
dcl (rev_line_ix, rev_line_len) fixed bin (24);
dcl (i, j, n, line_diff, last, line, output_words) fixed bin (24);
dcl  ul_ptr ptr;
dcl  max_sort_entries fixed bin (24);


/* Based */

dcl  system_area area (65536) based (system_area_ptr);
dcl  arg char (al) based (ap);
dcl  match_word char (match_len (wordx)) based (match_ptr (wordx));
dcl  match_len (n_words) based (mlp) fixed bin;
dcl  match_ptr (n_words) based (mpp) ptr;
dcl  rev_word char (rev_len (wordx)) based (rev_ptr (wordx));
dcl  rev_len (n_words) based (rlp) fixed bin;
dcl  rev_ptr (n_words) based (rpp) ptr;
dcl  num_matches (n_words) based (nmp) fixed bin;
dcl  line_data_ptr (n_words) ptr based (ldpp);
dcl  line_data_count (n_words) fixed bin based (ldcp);
dcl 1 line_data (line_data_count (wordx)) aligned based (line_data_ptr (wordx)),
    2 line_num fixed bin,
    2 line_index fixed bin (24);
dcl  line_data_kludge (2 * line_data_count (wordx)) fixed bin based (line_data_ptr (wordx));
dcl  line_data_mover (old_count) fixed bin (71) based (old_ptr);
dcl  prev_line_ix (0 : lines-1) fixed bin (24) based (plip);
dcl  input_cs char (input_len) based (input_ptr);
dcl  input_vec (input_len) char (1) unal based (input_ptr);
dcl  input_line char (line_len) based (line_ptr);
dcl  output_cs char (output_len) based (output_ptr);
dcl  temp_cs char (temp_len) based (temp_ptr);
dcl  temp_vec (temp_len) char (1) unal based (temp_ptr);
dcl  strip_cs char (1048576) based (strip_ptr);
dcl  strip_vec (1048576) char (1) based (strip_ptr);
dcl  ul_cs char (ul_len) based (ul_ptr);
dcl  ul_vec (ul_len) char (1) based (ul_ptr);
dcl 1 sort_data (max_sort_entries) aligned based (sort_data_ptr),
    2 wordp ptr unal,
    2 wordl fixed bin (24);


/* Static */

dcl  line_data_incr fixed bin int static init (50);
dcl  delims char (5) aligned int static init (" 	
");						/* SPACE, HT, VT, FF, NL */
dcl  NL char (1) aligned int static init ("
");
dcl  letters char (52) int static options (constant) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");

dcl (error_table_$noarg,
     error_table_$dirseg,
     error_table_$key_duplication,
     error_table_$no_key,
     error_table_$no_record,
     error_table_$short_record,
     error_table_$end_of_info,
     error_table_$noentry,
     error_table_$wrong_no_of_args,
     error_table_$badopt,
     error_table_$inconsistent,
     error_table_$zero_length_seg,
     error_table_$entlong) fixed bin (35) ext;

dcl  sys_info$max_seg_size fixed bin (24) ext static;


/* Conditions */

dcl  cleanup condition;


/* Builtins */

dcl (addr, divide, index, hbound, length, max, min, mod, null, reverse, rtrim, search, substr, unspec, verify) builtin;


/* Entries */

dcl  absolute_pathname_ entry (char(*), char(*), fixed bin(35));
dcl  cu_$arg_count entry (fixed bin);
dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
dcl  expand_pathname_ ext entry (char (*), char (*), char (*), fixed bin (35));
dcl  get_system_free_area_ entry (ptr);
dcl  delete_$path entry (char(*), char(*), bit(36) aligned, char(*), fixed bin(35));
dcl  initiate_file_ entry (char(*), char(*), bit(*), ptr, fixed bin(24), fixed bin(35));
dcl  terminate_file_ entry (ptr, fixed bin(24), bit(*), fixed bin(35));
dcl  com_err_ ext entry options (variable);
dcl  ioa_ ext entry options (variable);
dcl  get_wdir_ ext entry returns (char (168));
dcl  hcs_$get_uid_file entry (char (*), char (*), bit (36) aligned, fixed bin (35));
dcl  hcs_$make_seg ext entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
dcl  hcs_$status_minf entry (char(*), char(*), fixed bin(1), fixed bin(2), fixed bin(24), fixed bin(35));
dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin (24));
dcl  alphabetize_strings_ entry (ptr, fixed bin (24));
dcl  (get_temp_segments_, release_temp_segments_) entry (char (*), (*) ptr, fixed bin (35));
dcl  unique_chars_ entry (bit(*)) returns(char(15));
dcl  get_pdir_ entry() returns(char(168));
dcl  pathname_ entry (char(*), char(*)) returns(char(168));
dcl  iox_$attach_name entry (char(*), ptr, char(*), ptr, fixed bin(35));
dcl  iox_$open entry (ptr, fixed bin, bit(1) aligned, fixed bin(35));
dcl  iox_$close entry (ptr, fixed bin(35));
dcl  iox_$detach_iocb entry (ptr, fixed bin(35));
dcl  iox_$destroy_iocb entry (ptr, fixed bin(35));	  
dcl  iox_$get_line entry (ptr, ptr, fixed bin(21), fixed bin(21), fixed bin(35));		  
dcl  iox_$put_chars entry (ptr, ptr, fixed bin(21), fixed bin(35));
dcl  iox_$position entry (ptr, fixed bin, fixed bin(21), fixed bin(35));
dcl  iox_$control entry (ptr, char(*), ptr, fixed bin(35));
%page;
	cwl_cmd = "1"b;				/* remember we came in via the create_wordlist entry */
	whoami = "create_wordlist";
	arg_syntax = "path {-brief} {-from N} {-to N} {-header} {-no_sort} {-no_exclude} {-no_control_lines}";
	goto join;

locate_words: lw: entry;

	lw_cmd = "1"b;				/* remember we came in via the locate_words entry */
	whoami = "locate_words";
	arg_syntax = "path words {-from N} {-to N} {-header} {-lines N | -long | -count} {-word word}";
	goto join;

revise_words: rw: entry;

	rw_cmd = "1"b;				/* remember we came in via the revise_words entry */
	whoami = "revise_words";
	arg_syntax = "path word1 rev1 ... wordN revN {-from N} {-to N} {-header} {-lines N | -long | -brief} {-word word rev}";
join:	call cu_$arg_count (n_args);			/* get number of arguments */
	if cwl_cmd & n_args < 1
	then do;
noarg:	     code = error_table_$noarg;
usage:	     call com_err_ (code, whoami, "^/Usage:  ^a ^a", whoami, arg_syntax);
	     return;
	end;
	if lw_cmd & n_args < 2
	then goto noarg;
	if rw_cmd & n_args < 3
	then goto noarg;

	if ^cwl_cmd
	then do;
	     if lw_cmd
	     then n_words = n_args;			/* upper bound on number of words */
	     else n_words = divide (n_args, 2, 17, 0);
	     on cleanup call cleaner;
	     call get_system_free_area_ (system_area_ptr);
	     allocate match_len in (system_area);
	     allocate match_ptr in (system_area);
	     if rw_cmd
	     then do;
		allocate rev_len in (system_area);
		allocate rev_ptr in (system_area);
	     end;
	end;

	temp_dir = get_pdir_ ();
	n_words = 0;
	do argno = 1 by 1 to n_args;
	     call cu_$arg_ptr (argno, ap, al, code);
	     if index (arg, "-") ^= 1 then do;		/* not an option */
		if ^got_pname then do;		/* this should be a pathname */
		     call expand_pathname_ (arg, dname, ename, code);
		     if code ^= 0 then do;
			call com_err_ (code, whoami, arg);
			return;
		     end;
		     got_pname = "1"b;
		end;
		else if cwl_cmd then do;
		     code = error_table_$wrong_no_of_args;
		     goto usage;
		end;
		else do;				/* this should be a match word */
insert_word:	     do wordx = 1 to n_words while (match_word < arg); /* find place to insert arg. */
		     end;

		     do j = n_words to wordx by -1;	/* make room for insertion. */
			match_ptr (j + 1) = match_ptr (j);
			match_len (j + 1) = match_len (j);
			if rw_cmd then do;
			     rev_ptr (j + 1) = rev_ptr (j);
			     rev_len (j + 1) = rev_len (j);
			end;
		     end;
		     match_ptr (wordx) = ap;		/* save ptr to current word */
		     match_len (wordx) = al;		/* save length of current word */
		     n_words = n_words + 1;
		     if rw_cmd then do;
			call next_arg;
			rev_ptr (wordx) = ap;
			rev_len (wordx) = al;
		     end;
		end;
	     end;
	     else if arg = "-word" then do;
		call next_arg;
		goto insert_word;
	     end;
	     else if cwl_cmd & (arg = "-no_sort" | arg = "-ns") then no_sort_opt = "1"b;
	     else if ^lw_cmd & (arg = "-bf" | arg = "-brief") then brief_opt = "1"b;
	     else if arg = "-he" | arg = "-header" then header_opt = "1"b;
	     else if ^cwl_cmd & (arg = "-lg" | arg = "-long") then long_opt = "1"b;
	     else if cwl_cmd & (arg = "-ne" | arg = "-no_exclude") then no_exclude_opt = "1"b;
	     else if lw_cmd & (arg = "-ct" | arg = "-count") then count_opt = "1"b;
	     else if ^lw_cmd & (arg = "-temp_dir" | arg = "-td") then do;
		     call next_arg;
		     call absolute_pathname_ (arg, temp_dir, code);
		     if code ^= 0 then do;
			call com_err_ (code, whoami, "^a", arg);
			return;
			end;
		     end;
	     else if arg = "-ncl" | arg = "-no_control_lines"
	     then no_control_opt = "1"b;
	     else if arg = "-fm" | arg = "-from"
	     then do;
		call next_arg_num (from_line);
		if code ^= 0 | from_line < 1
		then do;
bad_line:		     call com_err_ (0, whoami, "Invalid line number.  ^a", arg);
		     return;
		end;
	     end;
	     else if arg = "-to"
	     then do;
		call next_arg_num (to_line);
		if code ^= 0 | to_line < 1
		then goto bad_line;
	     end;
	     else if ^cwl_cmd & (arg = "-lines" | arg = "-li")
	     then do;
		if argno + 1 > n_args then lines = 0;
		else do;
		     argno = argno + 1;
		     call cu_$arg_ptr (argno, ap, al, code);
		     lines = cv_dec_check_ (arg, code);
		     if code ^= 0 then do;
			lines = 0;
			code = 0;
			argno = argno - 1;
		     end;
		end;
		if lines < 0
		then do;
		     call com_err_ (0, whoami, "Invalid line count.  ^a", arg);
		     return;
		end;
	     end;
	     else do;
		call com_err_ (error_table_$badopt, whoami, "^a", arg);
		return;
	     end;
	end;

	if ^got_pname				/* pathname missing */
	| (^cwl_cmd & n_words = 0)			/* match word(s) missing */
	then goto noarg;

	if (long_opt | lines ^= -1) & (count_opt | brief_opt)
	then do;
	     call com_err_ (error_table_$inconsistent, whoami, "^[-count^;-brief^] and ^[-long^;-lines^] are mutually exclusive.", count_opt, long_opt);
	     return;
	end;
	if lines > -1
	then long_opt = "1"b;
	else lines = 0;

	if ^cwl_cmd then do;			/* check validity of word arguments */
	     invalid_sw = "0"b;			/* assume all word arguments are valid */
	     do wordx = 1 to n_words;
		call validate_word (match_word);
	     end;
	     if invalid_sw then return;

	     allocate num_matches in (system_area);
	     num_matches (*) = 0;
	     if ^count_opt
	     then do;
		allocate line_data_ptr in (system_area);
		allocate line_data_count in (system_area);
		line_data_count (*) = 0;
	     end;
	     if lines > 0
	     then do;
		allocate prev_line_ix in (system_area);
		prev_line_ix (*) = 1;
	     end;
	end;
	else on cleanup call cleaner;

	input_ename = ename;			/* save for later */
	input_dname = dname;

	call hcs_$status_minf (dname, ename, 1, type, bc, code);
	if code ^= 0 then call err_exit;

	if type = 2
	then if bc = 0				/* directory */
	     then do;
		code = error_table_$dirseg;		/* can't do anything with it */
		call err_exit;
		end;
	     else msf = "1"b;			/* directory with bit count = MSF */
	else msf = "0"b;

/* If the input is an MSF, then we have to use vfile_ rather thanpointer I/O
   to read it. There is also a possibility that if we are doing a revise_words
   on a non-MSF, the changes could involve growing the input segment to an
   MSF. That is handled later. */

	if msf then call open_file (dname, ename, inputp, Stream_input);
	else do;					/* initiate input seg */
	     call initiate_file_ (dname, ename, R_ACCESS, input_ptr, bc, code);
	     if input_ptr = null then call err_exit;
	     input_len = divide (bc, 9, 21, 0);		/* get character count */
	     if input_len = 0 then do;
		code = error_table_$zero_length_seg;
		call err_exit;
		end;
	     end;

	if cwl_cmd then do;				/* if create_wordlist entry */
	     call hcs_$get_uid_file (input_dname, input_ename, uid_in, code);
	     if code ^= 0 then call err_exit;

	     i = length (rtrim (ename));
	     if i > 29 then do;			/* make sure we can add ".wl" suffix to entry name */
		call com_err_ (error_table_$entlong, whoami, "^a.wl", ename);
		goto finish;
	     end;
	     substr (ename, i+1, 3) = ".wl";

	     dname = get_wdir_ ();

	     call hcs_$get_uid_file (dname, ename, uid_out, code);
	     if code ^= 0
	     then if code ^= error_table_$noentry
		then call err_exit;

	     if uid_in = uid_out then do;
		call com_err_ (0, whoami, "Input and output files are the same. ^a and ^a.",
		     pathname_ (input_dname, input_ename), pathname_ (dname, ename));
		goto finish;
		end;

	     if msf then do;
		call open_file (dname, ename, outputp, Stream_output);
		if ^no_sort_opt then do;
		     call open_file ("", "", sortp, Keyed_sequential_update);
		     sort_dir = dname;
		     sort_name = ename;
		     end;
		end;
	     else do;
		call hcs_$make_seg (dname, ename, "", 01010b, output_ptr, code); /* create output seg in working dir */
		if output_ptr = null then call err_exit;
		end;
	end;
	else if rw_cmd & msf then do;			/* revise_words needs to change the source file */
		call open_file ("", "", outputp, Stream_output);
		sort_dir = dname;			/* save path for deletion */
		sort_name = ename;
		end;

	call get_temp_segments_ (whoami, temp_ptr_array, code);
	if code ^= 0
	then do;
	     call com_err_ (code, whoami, "Cannot get temporary segments.");
	     goto finish;
	end;

	ul_ptr = temp_ptr_array (1);			/* place to assemble de-underlined words */
	if msf
	then input_ptr, line_ptr = temp_ptr_array (2);	/* place to read vfile_ input */
	else do;
	     sort_data_ptr = temp_ptr_array (2);	/* used for sorting */
	     max_sort_entries = divide (sys_info$max_seg_size, 2, 24, 0);
	     end;
	if rw_cmd then temp_ptr = temp_ptr_array (3);

	if header_opt
	then call ioa_ ("^/^-^a^/", pathname_ (input_dname, input_ename));

%page;
	prevx = lines -1;
	line_ix = 1;
	rev_line_ix = 1;
	line_diff = 0;
	output_words = 0;				/* init word counter */
	output_len = 0;
	temp_len = 0;				/* init length of temp seg */
	last = 0;					/* init index of last input seg char moved to temp seg */

	changed_lines = "0"b;			/* didnt change anything yet for revise_words */
	output_record_number = 0;

	if msf then do;
	     max_line_len = sys_info$max_seg_size * 4;
	     call iox_$get_line (inputp, line_ptr, max_line_len, input_len, code);
	     end;

	do line = 1 by 1;				/* scan input one line at a time */
	     if msf
	     then if code ^= 0
		then if code = error_table_$end_of_info
		     then goto end_of_data;
		     else if code = error_table_$short_record
			then goto msf_read;		/* no trailing NL */
			else call err_exit;
		else do;
msf_read:		     line_ix = 1;			/* fake indices so that later code works */
		     rev_line_ix = 1;		/*   for both cases */
		     output_len = 0;
		     temp_len = 0;
		     last = 0;
		     end;
	     else if line_ix > input_len
		then goto end_of_data;

	     line_len = index (substr (input_cs, line_ix), NL) -1;
	     if line_len = -1			/* input does not end with NL */
	     then line_len = input_len - line_ix + 1;	/* do it anyway */

	     if line < from_line
	     then goto next_line;
	     if to_line ^= 0 & line > to_line
	     then goto end_of_data;

	     if line_len = 0
	     then goto next_line;

	     line_ptr = addr (input_vec (line_ix));

	     if no_control_opt
	     then if substr (input_line, 1, 1) = "."
		then goto next_line;

	     strip_ptr = line_ptr;
	     delim_ix = 1;				/* prepare to look at first char of line */

	     do while (delim_ix <= line_len);		/* scan until line exhausted */
		delim_len = verify (substr (input_line, delim_ix), delims) -1; /* skip delimiters */
		if delim_len = -1
		then delim_len = line_len -delim_ix +1;

		token_ix = delim_ix + delim_len;	/* advance index past delimiters */
		if token_ix > line_len
		then goto next_line;
		else if token_ix = line_len
		then token_len = 1;
		else do;
		     token_len = search (substr (input_line, token_ix+1), delims); /* find end-of-token delimiter */
		     if token_len = 0 then		/* no delimiter */
			token_len = line_len + 1 - token_ix; /* use end of line as delimiter */
		end;

		strip_ix = token_ix;
		strip_len = token_len;
		call strip_punc;			/* strip surrounding punctuation from token */
		call check_ul;			/* check for underlining */

		if ul_sw then do;			/* the word was underlined */
		     ul_ix = word_ix;
		     ul_spaces = 0;
		     strip_ptr = ul_ptr;		/* prepare to strip words in ul_cs */
		     i = 1;
		     do while (i <= ul_len);		/* rescan token to pick out words */
			n = verify (substr (ul_cs, i), " "); /* skip spaces */
			if n = 0 then goto end_of_ul;
			i = i + n -1;		/* advance index past spaces */
			ul_spaces = ul_spaces + n -1; /* remember number of spaces seen */
			n = index (substr (ul_cs, i), " ") -1; /* find next space */
			if n = -1 then		/* no more spaces */
			     n = ul_len +1 -i;	/* use end of token as delimiter */
			strip_ix = i;
			strip_len = n;
			call strip_punc;
			if cwl_cmd then call output_word;
			else call test_word;
			i = i + n;
		     end;
end_of_ul:	     if cwl_cmd
		     then ul_ptr = addr (ul_vec (ul_len + 1)); /* move buffer ahead for next de-underlined word */
		     strip_ptr = line_ptr;
		end;

		else				/* no underlining to worry about */
		if cwl_cmd then call output_word;
		else call test_word;

next_token:	delim_ix = token_ix + token_len;	/* advance index past current token */
	     end;
next_line:
	     if lines > 0				/* must remember previous line indices */
	     then do;				/* use prev_line_ix array as circular buffer */
		prevx = mod (prevx + 1, lines);	/* advance circular buffer index */
		if msf & rw_cmd
		then do;
		     prev_line_ix (prevx) = output_record_number;
		     output_record_number = output_record_number + 1;
		     end;
		else do;				/* fixed for phx20562, use rev_line_ix */
						/* only if revise_word command */
		     if ^rw_cmd then prev_line_ix (prevx) = line_ix;
		     else prev_line_ix (prevx) = rev_line_ix;
		     end;
	     end;

	     if msf
	     then do;
		if rw_cmd then do;
		     if temp_len ^= 0 then do;	/* write out line to temp work file */
			call iox_$put_chars (outputp, temp_ptr, temp_len, code);
			if code ^= 0 then call err_exit;
			if last < input_len		/* copy end of input line */
			then call iox_$put_chars (outputp, addr (input_vec (last+1)), input_len-last, code);
			end;
		     else call iox_$put_chars (outputp, line_ptr, input_len, code);
		     if code ^= 0 then call err_exit;
		     end;

		call iox_$get_line (inputp, line_ptr, max_line_len, input_len, code);
		end;
	     else do;
		line_ix = line_ix + line_len + 1;

		if rw_cmd & long_opt
		then do;
		     rev_line_len = line_len + line_diff;    /* compute length of revised line */
		     rev_line_ix = rev_line_ix + rev_line_len +1; /* compute index of next revised line */
		     line_diff = 0;
		     end;
		end;
	end;
%page;
end_of_data:

/* For revise_words, if there are any chars left after the last
   revision, move them to the temp seg.  Then copy the whole
   temp seg into the original input seg (which becomes the output seg). */

	if rw_cmd then do;
	     if msf then do;
		if changed_lines
		then do;
		     code = 0;
		     do while (code = 0);		/* copy rest of input file */
			call iox_$get_line (inputp, line_ptr, max_line_len, input_len, code);
			if code = 0 | code = error_table_$short_record
			then call iox_$put_chars (outputp, line_ptr, input_len, code);
			end;
		     if code ^= error_table_$end_of_info then call err_exit;

		     call iox_$close (inputp, code);	/* close input file */
		     call close_file (outputp);
		     outputp = null;

		     call copy_temp_file (dname, ename, get_wdir_ (), input_ename);

		     call iox_$open (inputp, 1, "0"b, code); /* open input file for reading */
		     if code ^= 0 then call err_exit;
		     end;
		else call close_file (outputp);	/* don't need temp work file anymore */
		end;
	     else if last > 0 then do;
		     n = input_len - last;
		     if n > 0 then do;
			substr (temp_cs, temp_len+1, n) = substr (input_cs, last+1, n);
			temp_len = temp_len + n;
			end;
		     output_ptr = input_ptr;
		     substr (output_ptr -> temp_cs, 1, temp_len) = substr (temp_cs, 1, temp_len);
		     input_len, output_len = temp_len;
		     end;
	end;

	if cwl_cmd then do;				/* if create_wordlist entry */
	     if ^brief_opt then
		call ioa_ ("total number of words = ^d", output_words); /* print word count */
	     if ^no_sort_opt then do;			/* if nosort option not requested */
		if msf then call copy_keyed_file;
		else do;
		     call alphabetize_strings_ (sort_data_ptr, output_words); /* alphabetize the words */
		     call copy_sorted_words;		/* copy sorted words to output seg */
		     end;
		if ^brief_opt then
		     call ioa_ ("number of unique words = ^d", output_words); /* print unique word count */
	     end;
	end;

	else do;
	     if msf then do;
		current_record = 1;
		call iox_$position (inputp, -1, 0, code);    /* BOF */
		end;

	     do wordx = 1 to n_words;			/* print results for locate_words or revise_words */
		if count_opt
		then call ioa_ ("^d match^[es^] for ^a", num_matches (wordx), (num_matches (wordx) ^= 1), match_word);
		else if rw_cmd & ^long_opt
		then do;
		     if num_matches (wordx) = 0
		     then call ioa_ ("No revisions for ^a", match_word);
		     else if ^brief_opt
		     then call ioa_ ("^d revision^[s^] for ^a", num_matches (wordx), (num_matches (wordx) ^= 1), match_word);
		end;
		else if lw_cmd & ^long_opt
		then do;
		     if num_matches (wordx) = 0
		     then call ioa_ ("^20a NONE", match_word);
		     else do;
			line_data_count (wordx) = num_matches (wordx);
			do i = 1 by 20 to 2*num_matches (wordx);
			     call ioa_ ("^[^20a^;^20x^s^]^vs^10(^d^x^s^)", i = 1, match_word, i-1, line_data_kludge);
			end;
		     end;
		end;
		else call print_long;		/* print lines of text */
		end;
	end;


	if (cwl_cmd | (rw_cmd & last > 0)) & ^msf then do;
	     substr (output_cs, output_len+1, 4 - mod (output_len, 4)) = "   "; /* set to NUL */
	     call terminate_file_ (output_ptr, 9*output_len, TERM_FILE_TRUNC_BC, code); /* truncate output seg */
	     if code ^= 0 then call err_exit;
	end;

finish:	call cleaner;
exit:	return;

err_exit:						/* moan and return */
     proc;

	call com_err_ (code, whoami, "^a", pathname_ (input_dname, input_ename));
	goto finish;
	end err_exit;
%page;
next_arg:	proc;					/* fetches next command arg */

	     argno = argno + 1;
	     if argno > n_args
	     then goto noarg;

	     call cu_$arg_ptr (argno, ap, al, code);

	end next_arg;

next_arg_num: proc (num);				/* fetches next arg, converts to fixed bin */

dcl  num fixed bin (24);


	     call next_arg;
	     num = cv_dec_check_ (arg, code);

	end next_arg_num;
%page;
validate_word: proc (word);

dcl  word char (*);

/* checks validity of words supplied as arguments to commands
   a word must not contain delimiters or surrounding punctuation and must not be underlined
*/

	     if search (word, delims) ^= 0		/* word contains delimiters */
	     then do;
bad_word:		call com_err_ (0, whoami, """^a"" is not a word.", word);
		invalid_sw = "1"b;			/* the word is invalid */
		return;
	     end;
	     strip_ptr = addr (word);
	     strip_ix = 1;
	     strip_len = length (word);
	     call strip_punc;			/* strip surrounding punctuation from argument word */
	     if word_ix > 1 | word_len < strip_len	/* some punctuation was removed */
	     then goto bad_word;
	     call check_ul;				/* check word for underlining */
	     if ul_sw then goto bad_word;

	end validate_word;
%page;
strip_punc: proc;

/* removes surrounding punctuation from a string
   the input string is given by substr(strip_cs, strip_ix, strip_len)
   the output string is given by substr(strip_cs, word_ix, word_len)
*/

dcl  n fixed bin (24);

	     n = verify (substr (strip_cs, strip_ix, strip_len), "([{""") -1; /* check for leading punctuation including PAD (177) */
	     if n = -1 then goto no_strip;		/* if all punctuation, do not strip */
	     word_ix = strip_ix + n;
	     word_len = strip_len - n;
	     n = verify (reverse (substr (strip_cs, word_ix, word_len)), ")]}""!,.:;?")-1; /* check for trailing punctuation */
	     if n = -1 then do;			/* if all punctuation, do not strip */
no_strip:		word_ix = strip_ix;
		word_len = strip_len;
		return;
	     end;
	     word_len = word_len - n;
	     if word_len >= 2 then do;		/* enough room for underlining */
		if strip_ix < word_ix then
		     if substr (strip_cs, word_ix, 2) = "_"
		     then do;			/* do not strip underlined leading punctuation */
			word_ix = word_ix -1;
			word_len = word_len + 1;
		     end;
		if word_ix + word_len < strip_ix + strip_len then
		     if substr (strip_cs, word_ix + word_len -2, 2) = "_"
		     then word_len = word_len +1;	/* do not strip underlined trailing punctuation */
	     end;

	end strip_punc;
%page;
check_ul:	proc;

/* checks word for continuous underlining
   de-underlined string is assembled in ul_cs
   underline without adjacent backspace -> space
   the input word is given by substr(strip_cs, word_ix, word_len)
*/

dcl (i, j) fixed bin;
dcl  end_word_ix fixed bin;

	     ul_sw = "0"b;				/* assume word is not underlined */
	     if index (substr (strip_cs, word_ix, word_len), "") ^= 0
	     then do;				/* word contains backspaces, check for underlining */
		i = word_ix;
		end_word_ix = word_ix + word_len - 1;
		do j = 1 by 1 while (i <= end_word_ix); /* scan token */
		     if i+2 > end_word_ix then goto check_single_ul;
		     if substr (strip_cs, i, 2) = "_"
		     then do;
			substr (ul_cs, j, 1) = substr (strip_cs, i+2, 1);
			i = i + 3;
		     end;
		     else if substr (strip_cs, i+1, 2) = "_"
		     then do;
			substr (ul_cs, j, 1) = substr (strip_cs, i, 1);
			i = i +3;
		     end;
		     else
check_single_ul:	     if substr (strip_cs, i, 1) = "_"
		     then do;
			substr (ul_cs, j, 1) = " ";
			i = i + 1;
		     end;
		     else return;			/* not standard underlined string */
		end;
		ul_sw = "1"b;			/* yup, that was an underlined string */
		ul_len = j - 1;			/* remember length of de-underlined string */
	     end;

	end check_ul;
%page;
output_word: proc;

/* Move the word specified to an output file. If MSF input, then if sorting the
   word goes to a keyed vfile_, else put in stream output file. If ^MSF,
   then if sorting, word ptr and length goes to sort_data array, else put in
   output seg with NL appended. Since we're eliminating white space from the
   input file and words are delimited by at least 1 white space character,
   if the input is not an MSF, the output cannot be. Words containing no
   letters are excluded from the wordlist unless -no_exclude specified.
*/

dcl  1 aki,
       2 flags aligned,
         3 input_key bit (1) unaligned init ("1"b),
         3 input_desc bit (1) unaligned init ("1"b),
         3 mbz bit (34) unaligned init ("0"b),
       2 descrip fixed bin (35) init (0),
       2 key_len fixed bin,
       2 key char (256);

	     if ^no_exclude_opt
	     then if search (substr (strip_cs, word_ix, word_len), letters) = 0
		then return;

	     output_words = output_words + 1;
	     if msf
	     then if no_sort_opt
		then do;
		     call iox_$put_chars (outputp, addr (strip_vec (word_ix)), (word_len), code);
		     if code ^= 0 then call err_exit;
		     call iox_$put_chars (outputp, addr (NL), length (NL), code);
		     if code ^= 0 then call err_exit;
		     end;
		else do;
		     aki.key_len = min (256, word_len);
		     aki.key = substr (strip_cs, word_ix, word_len);
		     call iox_$control (sortp, "add_key", addr (aki), code);
		     if code ^= 0
		     then if code = error_table_$key_duplication
			then ;			/* allowable */
			else call err_exit;
		end;
	     else if no_sort_opt
		then do;
		     substr (output_cs, output_len + 1, word_len) = substr (strip_cs, word_ix, word_len);
		     output_len = output_len + word_len;
		     substr (output_cs, output_len + 1, 1) = NL;
		     output_len = output_len + 1;
		     end;
		else do;
		     if output_words > hbound (sort_data, 1)
		     then do;
			call com_err_ (0, whoami, "Number of words exceeds sorting limit of ^d.", hbound (sort_data, 1));
			goto finish;
		     end;

		     sort_data (output_words).wordp = addr (strip_vec (word_ix));
		     sort_data (output_words).wordl = word_len;
		     end;

	return;
	end output_word;
%page;
test_word: proc;

/* tests if current word matches any of the match words
   if a match is found, the action taken depends on whether locate_words or revise_words was called
   for locate_words, the line number and line index of the current word is saved
   for revise_words, the uncopied portion of the input string preceding the current word is copied to the temp seg
   if "-long" was specified, the line number and line index of the revised word is saved
*/

dcl  cc fixed bin (24);
dcl  i fixed bin;

/* Since the match_word array is sorted, we only have to
   search until we find the first word in the array that is greater than or equal to the
   current word. */

	     do wordx = 1 to n_words while (match_word < substr (strip_cs, word_ix, word_len));
	     end;

	     if wordx <= n_words
	     then if match_word = substr (strip_cs, word_ix, word_len)
		then do;
		     num_matches (wordx) = num_matches (wordx) + 1; /* we found a match, increment match count */
		     if count_opt
		     then return;
		     if rw_cmd then do;		/* move chars before current word to temp seg and revise word */
			if ul_sw then do;		/* word was de-underlined */
			     word_ix = ul_ix + ul_spaces + 3* (word_ix-1-ul_spaces); /* get index of original word */
			     word_len = 3 * word_len; /* get length of original word */
			end;
			word_ix = word_ix + line_ix -1;
			cc = word_ix -last -1;	/* compute number of unmoved chars before word_ix */
			substr (temp_cs, temp_len+1, cc) = substr (input_cs, last+1, cc); /* move 'em */
			last = last + cc + word_len;	/* recompute last char moved */
			temp_len = temp_len + cc;	/* number of chars in temp seg */
			changed_lines = "1"b;
			if ^ul_sw then do;
			     substr (temp_cs, temp_len+1, length (rev_word)) = rev_word; /* drop in the revision */
			     temp_len = temp_len + length (rev_word);
			end;
			else do i = 1 to length (rev_word); /* underline the revision canonically */
			     if substr (rev_word, i, 1) < "_" then do;
				substr (temp_cs, temp_len +1, 1) = substr (rev_word, i, 1);
				temp_len = temp_len +1;
				substr (temp_cs, temp_len+1, 2) = "_";
				temp_len = temp_len + 2;
			     end;
			     else do;
				substr (temp_cs, temp_len +1, 2) = "_";
				temp_len = temp_len +2;
				substr (temp_cs, temp_len +1, 1) = substr (rev_word, i, 1);
				temp_len = temp_len +1;
			     end;
			end;
			if long_opt
			then do;			/* compute difference between original and revised line lengths */
			     line_diff = line_diff + length (rev_word) - word_len;
			     goto save_line_number;
			end;
		     end;
		     else do;
save_line_number:
			if mod (num_matches (wordx), line_data_incr) = 1
			then do;			/* allocate more space for line data */
			     old_count = line_data_count (wordx);
			     if old_count > 0
			     then old_ptr = line_data_ptr (wordx);
			     line_data_count (wordx) = old_count + line_data_incr;
			     allocate line_data in (system_area);
			     if old_count > 0
			     then do;
				line_data_ptr (wordx) -> line_data_mover = line_data_mover;
				free line_data_mover in (system_area);
			     end;
			end;
			line_num (num_matches (wordx)) = line; /* remember line number */
			if long_opt
			then if msf		/* don't need line_index for MSFs */
			     then line_index (num_matches (wordx)) = 0;
			     else do;		/* remember line index */
				if lines = 0
				then if lw_cmd
				     then i = line_ix;
				     else i = rev_line_ix;
				else i = prev_line_ix (mod (prevx + 1, lines)); /* use oldest line in circular buffer */
				line_index (num_matches (wordx)) = i;
				end;
		     end;
		end;

	end test_word;
%page;
print_long: proc;					/* prints output for -long option */

dcl (i, j, k) fixed bin (21);
dcl  last_line_printed fixed bin (21);
dcl  j_contains_match bit(1);
dcl  NL_index fixed bin (21);
  
	     if n_words ^= 1
	     then if lw_cmd
		then call ioa_ ("^2/^a^/", match_word);
		else call ioa_ ("^2/^a^/", rev_word);

	     if num_matches (wordx) = 0
	     then do;
		call ioa_ ("^-NONE");
		return;
	     end;

	     last_line_printed = 0;
	     do i = 1 to num_matches (wordx);		/* print line containing each match */
		if i > 1
		then if line_num (i) = line_num (i-1)
		     then goto next_line_num;	/* don't print same line twice */
		line = line_num (i);
		line_ix = line_index (i);
		do j = max (line - lines, 1) to line + lines;	/* print surrounding lines */
		     if ^msf
		     then if line_ix > input_len
			then goto next_line_num;

		     if i < num_matches (wordx)
		     then if (j = line_num (i+1)) & (j ^= line)
			then goto next_line_num;	/* don't print line for next match yet */

		     if msf then do;
			if j ^= current_record
			then do;			/* find record with relative positioning */
			     call iox_$position (inputp, 0, j - current_record, code);
			     if code ^= 0 & code ^= error_table_$short_record then call err_exit;
			     end;
			call iox_$get_line (inputp, line_ptr, max_line_len, line_len, code);
			if code ^= 0
			then if code = error_table_$end_of_info
			     then goto next_line_num;
			     else call err_exit;

			current_record = j + 1;	/* reading advanced by 1 record */
		          NL_index = index (input_line, NL); /* look for NL */
			if NL_index ^= 0
			then line_len = NL_index - 1; /* we have one, bump back 1 char so ioa_ doesn't print 2 NLs */
			end;
		     else do;
			line_ptr = addr (input_vec (line_ix));
			line_len = index (substr (input_cs, line_ix), NL) -1;
			if line_len = -1
			then line_len = input_len - line_ix + 1;
			end;
		     if j > last_line_printed
		     then do;
			do k = i to num_matches (wordx);
			     if line_num (k) = j 
			     then do;
				j_contains_match = "1"b;
				k = num_matches (wordx);
			     end;
			     else j_contains_match = "0"b;
			end;
			call ioa_ ("^6d ^[*^; ^]  ^a", j, ((lines > 0) & ((j = line) | (j_contains_match = "1"b))), input_line);
			last_line_printed = j;
		     end;
		     line_ix = line_ix + line_len + 1;
		end;
next_line_num:
	     end;

	end print_long;
%page;
copy_keyed_file:
     proc;

dcl  1 gki,
       2 flags aligned like gk_header.flags,
       2 descrip fixed bin (35) aligned,
       2 key_len fixed bin,
       2 key char (256);

	unspec (gki) = "0"b;

	dname = sort_dir;
	ename = sort_name;
	call iox_$position (sortp, -1, 0, code);	/* to BOF */
	if code ^= 0 then call err_exit;

	code, output_words = 0;
	do while (code = 0);
	     call iox_$control (sortp, "get_key", addr (gki), code);
	     if code = 0 then do;
		output_words = output_words + 1;
		call iox_$put_chars (outputp, addr (gki.key), (gki.key_len), code);
		if code ^= 0 then call err_exit;
		call iox_$put_chars (outputp, addr (NL), length (NL), code);
		if code ^= 0 then call err_exit;

		call iox_$position (sortp, 0, 1, code);
		if code = 0 then call iox_$control (sortp, "get_key", addr (gki), code);
		end;
	     end;
	if code = error_table_$end_of_info | code = error_table_$no_key | code = error_table_$no_record
	then ;					/* allowable errors */
	else call err_exit;

	return;
	end copy_keyed_file;
%page;
copy_sorted_words: proc;

/* copies sorted words from temp seg to output seg
   eliminates duplications
*/

dcl  i fixed bin (24);
dcl  unique_words fixed bin (24);
dcl (wordp, last_wordp) ptr;
dcl (wordl, last_wordl) fixed bin (24);
dcl  sort_string char (wordl) based (wordp);
dcl  last_sort_string char (last_wordl) based (last_wordp);


	     unique_words = 0;
	     last_wordl = 0;

	     do i = 1 to output_words;
		wordp = sort_data (i).wordp;
		wordl = sort_data (i).wordl;

		if wordl = last_wordl
		then if sort_string = last_sort_string
		     then goto next_word;
		unique_words = unique_words + 1;

		last_wordl = wordl;
		last_wordp = wordp;

		substr (output_cs, output_len + 1, wordl) = sort_string;
		output_len = output_len + wordl;
		substr (output_cs, output_len + 1, 1) = NL;
		output_len = output_len + 1;

next_word:
	     end;

	     output_words = unique_words;

	end copy_sorted_words;
%page;
cleaner:	proc;					/* cleanup handler */

	     if plip ^= null then do;
		free prev_line_ix in (system_area);
		plip = null;
	     end;

	     if ldpp ^= null then do;
		do wordx = 1 to n_words;
		     if line_data_count (wordx) > 0
		     then free line_data in (system_area);
		end;
		free line_data_ptr in (system_area);
		free line_data_count in (system_area);
		ldpp, ldcp = null;
	     end;
	     if nmp ^= null then do;
		free num_matches in (system_area);
		nmp = null;
	     end;
	     if mpp ^= null then do;
		free match_ptr in (system_area);
		mpp = null;
	     end;
	     if mlp ^= null then do;
		free match_len in (system_area);
		mlp = null;
	     end;
	     if rpp ^= null then do;
		free rev_ptr in (system_area);
		rpp = null;
	     end;
	     if rlp ^= null then do;
		free rev_len in (system_area);
		rlp = null;
	     end;

	     if temp_ptr_array (1) ^= null
	     then call release_temp_segments_ (whoami, temp_ptr_array, code);

	     if msf then do;
		call close_file (inputp);
		call close_file (outputp);
		if ^no_sort_opt & cwl_cmd then do;
		     call close_file (sortp);
		     call delete_$path (sort_dir, sort_name, "101111"b, whoami, code);
		     if code ^= 0 then call com_err_ (code, whoami, "Deleting ^a.", pathname_ (sort_dir, sort_name));
		     end;
		end;
	     else do;				/* terminate input  output segs */
		if input_ptr = output_ptr
		then input_ptr = null;
		do input_ptr = input_ptr, output_ptr;
		     if input_ptr ^= null then call terminate_file_ (input_ptr, 0, TERM_FILE_TERM, (0));
		     end;
		end;

	return;
	end cleaner;
%page;
copy_temp_file:
     proc (input_dir, input_name, output_dir, output_name);

/* Copy the contents of the input file to the output file. This is only used
   in MSF mode. */

dcl  (input_dir, output_dir) char (*) parameter;
dcl  (input_name, output_name) char (*) parameter;
dcl  buffer char (1024);

dcl 1 co like copy_options;

dcl  copy_ entry (ptr);

	co.version = COPY_OPTIONS_VERSION_1;
	co.caller_name = whoami;
	co.source_dir = input_dir;
	co.source_name = input_name;
	co.target_dir = output_dir;
	co.target_name = output_name;
	unspec (co.flags) = "0"b;
	co.flags.delete = "1"b;			/* delete source when done */
	co.flags.force = "1"b;			/* try to force access if needed */

	unspec (co.copy_items) = "0"b;
	co.copy_items.update = "1"b;

	call copy_ (addr(co));			/* copy work file to input file */
	if co.target_err_switch
	then call err_exit;				/* errors reported by sub_err_ */

	return;
	end copy_temp_file;
%page;
open_file:
     proc (dir, ent, iocbp, mode);

dcl  (dir, ent) char (*) parameter;
dcl  iocbp ptr parameter;
dcl  mode fixed bin parameter;
dcl  atd char (256) varying;
dcl  switchname char (32) varying;

	dname = dir;
	if dname = "" then dname = temp_dir;
	ename = ent;
	if ename = "" then ename = unique_chars_ ("0"b) || "." || whoami;

	atd = "vfile_ " || rtrim (dname);
	atd = atd || ">";
	atd = atd || rtrim (ename);

	switchname = unique_chars_ (""b) || ".";
	switchname = switchname || whoami;

	call iox_$attach_name ((switchname), iocbp, (atd), null, code);
	if code ^= 0 then call err_exit;

	call iox_$open (iocbp, mode, "0"b, code);
	if code ^= 0 then call err_exit;

	return;
	end open_file;

close_file:
     proc (iocbp);

dcl  iocbp ptr parameter;

	if iocbp ^= null then do;
	     call iox_$close (iocbp, (0));
	     call iox_$detach_iocb (iocbp, (0));
	     call iox_$destroy_iocb (iocbp, (0));
	     end;

	return;
	end close_file;
%page;
%include copy_options;
%include copy_flags;
%include ak_info;
%include access_mode_values;
%include terminate_file;
%include iox_modes;

     end create_wordlist;
