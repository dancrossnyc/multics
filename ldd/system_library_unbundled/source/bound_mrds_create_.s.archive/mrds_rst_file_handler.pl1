/* ***********************************************************
   *                                                         *
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
   *                                                         *
   *                                                         *
   *********************************************************** */

/* ******************************************************
   *                                                    *
   *                                                    *
   * Copyright (c) 1972 by Massachusetts Institute of   *
   * Technology and Honeywell Information Systems, Inc. *
   *                                                    *
   *                                                    *
   ****************************************************** */


/* HISTORY:

   originally written by jim gray - - october 1978
   modified by Jim Gray - - July 1979 to add pl1 version of data alignment in tuple
   Modified by Jim Gray - - Dec. 1979, to  add consideration of packed decimal
   data types to pad_to_alignment_boundary routine.
   Modified by Jim Gray - - Dec. 1979, to make pad_to_alignment_boundary external
   procedure mdbm_util_$align_data_item, so other routines could use it.
   Modified by Jim Gray - - Jan. 1980, to disallow file statement, only default files are now allowed.
   Modified by Jim Gray - - April 1980, to remove abs. path in attach desc, so databsaes can be copied.
   Modified by Jim Gray - - Sept. 1980, to capture the use of reserved segment names
   "dbc" and "db_model" for this new architecture.

   81-04-30 Jim Gray : changed max number of relations creatable
   tobe dependent on mrds_data_$max_relations, rather than on a file_id_len
   that is constrained by the mdbm_tuple_id include file structure.

   81-05-01 Jim Gray : changed db_model.file_id_len to be taken from mrds_data_$max_relations

   81-05-18 Jim Gray : added check for max attrs per relation

   81-09-16 Davids: added the rtrim so that the code would compile with
   .        the prefix option stringsize.

   81-11-25 Davids: changed rel_info.id to  be  "000000000001"b  and
   file_info.file_id  to be "000000000000000000000000000000000001"b,
   For all relations and files. This was to prepare the way for easy
   restructuring,  i.e.  adding  and  deleteing relations and making
   temp_rels permanent.

   82-05-19 Davids: changed rel_info.nsec_inds to  rel_info.unused_3
   because  it  really wasn't the number of secondary indices in the
   relation it was always zero - it is still 0 but now it has a more
   descriptive name.

   82-06-25  R.  Harvey: changed to use mdbm_file_model_init.incl to
   speed up creation of databases.

   82-07-02 Roger Lackey: deleted
   file_model.num_rels = file_model.num_rels + 1;
   because it is now initialized in structured and only one relation per file
   is allowed now.

   83-02-17 Davids: explicitly declared variables that were declared by
   context or implication and deleted declarations to variables that were
   not referenced.
*/


mrds_rst_file_handler:
     procedure (rsc_ptr, list_ptr);

/*
   .                       BEGIN_DESCRIPTION:
   this routine builds/alters the mrds database model file information
   and the global entity lists maintained by RMDB/CMDB,
   based upon the file data and directive that is active when
   called by the RMDB/CMDB parser.
   the directive may be undefine, define, redefine, or cmdb and the data is
   either a file name to be deleted, or a linked list of linked list of
   structures holding the file information and it's relation list
   .                       END_DESCRIPTION
*/

/* PARAMETERS:

   rsc_ptr - - (input) pointer to the common control segment

   list_ptr - - (input) pointer to the single file name to be deleted(undefine only) or to the
   file structure headed list of relation structures

   database model - - (output) updated model with altered file information

   global lists - - (output) the list of database entities, updated
   according to directive and data

   error_output - - (output) via mrds_rst_error calls, of error messages
*/

/* REMAINING ERRORS:


   undefine:

   the file name may be the <error_symbol>(this may be ignored)
   the file may not be defined in the database

   define, cmdb:

   the file name may be the <error_symbol>(this may be ignored)
   one of the relation names may be the <error_symbol>(this may be ignored)
   the file may already be defined in the database
   a relation may not be defined in the database
   a relation may reside in a file already
   the file/relation max_tuples may not be set
   the file type may conflict with the max_tuples option values given

   redefine:

   same as define, except file name may not be defined in the database
   or the relation(s) may reside in other than the given file

   note: "(this may be ignored)" means a previous error will prevent
   a database model with erroneous information from being built

*/

/* set semantic structure pointers */

	stmt_ptr = rsc_ptr -> rsc.stmt_ptr;
	directive_ptr = rsc_ptr -> rsc.directive_ptr;

	if directive.type = UNDEFINE then do;		/* input structure depends on direcitve */
		delete_name_ptr = list_ptr;
		file_name = rtrim (delete_name.overlay);/* CHANGE 81-09-16 */
	     end;
	else do;
		file_ptr = list_ptr;
		file_name = file.name;
	     end;

/* call trace if metering is on */

	if ^rsc.trace_sw then
	     ;
	else call
		mrds_rst_meter (rsc_ptr, "mrds_rst_file_handler", IN, file_name);

/* check on which directive called us */

	if directive.type = UNDEFINE | directive.type = REDEFINE then do;
		if stmt (directive.type).file.number > 0 then
		     ;				/* not first time */
		else do;				/* first time only, issue error */
			call
			     ioa_$rs ("^a ^a", message, message_length,
			     "The file handler will not implement ""undefine"" or ""redefine"""
			     , "directives until a later release.");
			call
			     mrds_rst_error (rsc_ptr, 2 /* severity */,
			     mrds_error_$rst_undone_option, (message));
		     end;
	     end;
	else do;

/* define or cmdb directive was caller, process newly defined file */

		if file.default then
		     ;				/* called from file cleanup to give default file for rels */
		else if rsc.allow_blocked_files then
		     ;
		else if rsc.blocked_file_seen then
		     ;
		else do;
			rsc.blocked_file_seen = ON;
			call
			     ioa_$rs ("^a", message, message_length,
			     "The file statment will not be implemented until a later release."
			     );
			call
			     mrds_rst_error (rsc_ptr, 2 /* severity */,
			     mrds_error_$rst_undone_option, (message));
		     end;


		call define_file ();

	     end;

/* call the trace routine if metering is turned on */

	if ^rsc.trace_sw then
	     ;
	else call
		mrds_rst_meter (rsc_ptr, "mrds_rst_file_handler", OUT, file_name);

define_file:
     procedure ();

/* routine to build the model for this file according to it's definition */

	error_mode = OFF;

/* check that files defined in the source do not use relation names */

	if file.default then
	     ;					/* file from cleanup handler */
	else do;					/* from source */

		call
		     mrds_rst_tree_search ((file.name), rsc.h_grel_ptr, node_ptr,
		     parent_ptr, success);

		if ^success then
		     ;				/* not a relation name */
		else do;				/* bad name, do a fixup */
			error_mode = ON;		/* set special provisions for detecting all errors */
			call
			     ioa_$rs ("^a^a^a ^d ^a", message, message_length, "The file """,
			     file.name, """ on line", file.line_num,
			     "has the same name as a relation, only default files may have relation names!!"
			     );
			call
			     mrds_rst_error (rsc_ptr, 2 /* severity */,
			     mrds_error_$rst_dup_file, (message));
			call mrds_rst_rsc_alloc (rsc_ptr, GL, gl_ptr); /* get dummy version not in list */
		     end;
	     end;

/* make sure the file is not already in the database or previously defined(if above error did'nt occur) */

	if error_mode then
	     error_code = 0;
	else call
		mrds_rst_list_element$add ((file.name), MAIN_LIST, rsc_ptr,
		rsc.h_gfile_ptr, gl_ptr, error_code);

	if error_code = 0 then
	     ;					/* normal processing of good file */
	else do;
		error_mode = ON;			/* make special provisions so all errors are detected */
		call
		     ioa_$rs ("^a^a^a ^d ^a", message, message_length, "The file """,
		     file.name, """ on line", file.line_num,
		     "is already defined in the database, duplicate names are not allowed!!"
		     );
		call
		     mrds_rst_error (rsc_ptr, 2 /* severity */, mrds_error_$rst_dup_file,
		     (message));
		call mrds_rst_rsc_alloc (rsc_ptr, GL, gl_ptr); /* make dummy version not in list */
	     end;

/* check for reserved segment names (due to db architecture) being used for file name */

	if file.name ^= "dbc" & file.name ^= "db_model" then
	     ;
	else do;
		error_mode = ON;			/* use unique name instead of reserved name */
		if file.default then
		     call
			ioa_$rs ("^a^a^a", message, message_length,
			"The relation name """, file.name,
			""" is a reserved name in this database architecture.");
		else call
			ioa_$rs ("^a^a^a ^d ^a", message, message_length,
			"The file name """, file.name, """ given on line",
			file.line_num,
			"is a reserved name in this database architecture.");
		call
		     mrds_rst_error (rsc_ptr, 2 /* severity */,
		     mrds_error_$rst_reserved_name, (message));
	     end;

/* file was not found in list so it was added,
   link list element to list head and fill in the blanks */

	gl.type = MAIN_LIST;
	gl.name = file.name;
	gl.item_info_ptr = null ();			/* no file_info yet */
	gl.parse_info_ptr = file_ptr;
	gl.other_info_ptr = gl_ptr;
	gl.item_sub_list_ptr = null ();		/* no relations yet */
	gl.file_info_ptr = null ();			/* no file model defined to hold file yet */
	gl.file_model_ptr = null ();
	gl.affected = ON;
	gl.undefine = OFF;
	gl.redefine = OFF;
	if directive.type = DEFINE then do;
		gl.define = ON;
		gl.cmdb = OFF;
	     end;
	else do;					/* CMDB directive */
		gl.define = OFF;
		gl.cmdb = ON;
	     end;
	gl.superior_assigned = OFF;			/* no file model for this file yet */
	gl.inferior_assigned = OFF;			/* no relations for this file yet */
	gl.complete = OFF;				/* file is not formatted yet */
	gl.consistant = ON;				/* assume innocent until proven guilty */
	gl.reserved = OFF;

/* build the file model and file_info for this file */

	call load_file_model ();

/* process the list of relations for this file */

	if ^gl.superior_assigned then
	     ;
	else do;

		call file_relation_handler ();

/* compute parameters for blocked files, now that max_tuples and tuple sizes are known */

		if ^gl.inferior_assigned then
		     gl.consistant = OFF;

/* check for too many files or too many tuples */

		call check_file_size_and_number ();

	     end;

     end;

file_relation_handler:
     procedure ();

/* check each relation in the list for this file */

	max_tuples = 0;
	item_ptr = file.i_ptr;			/* get first on list of this file's relations */
	do while (item_ptr ^= null ());

/* make sure that the given relation is defined in the database */

	     call
		mrds_rst_tree_search (item.name, rsc.h_grel_ptr, node_ptr,
		parent_ptr, success);

	     if ^success then do;			/* not found */
		     call
			ioa_$rs ("^a^a^a ^d ^a^a^a", message, message_length,
			"The relation """, item.name, """ on line", item.line_num,
			"given for file """, file.name,
			""" has not been defined in the database.");
		     call
			mrds_rst_error (rsc_ptr, 2 /* severity */,
			mrds_error_$rst_undef_rel, (message));
		end;
	     else do;
		     rel_gl_ptr = node_ptr -> node.data;/* get relation global element pointer */
		     relation_ptr = rel_gl_ptr -> gl.parse_info_ptr; /* get relation declaration */

/* check that this relation is not already in some file */

		     if ^rel_gl_ptr -> gl.superior_assigned then
			;
		     else do;
			     call
				ioa_$rs ("^a^a^a ^d ^a^a^a^a^a", message, message_length,
				"The relation """, relation.name, """ on line",
				relation.line_num, "given in file """, file.name,
				""" is already defined as belonging to file """,
				rel_gl_ptr -> gl.other_info_ptr -> gl.name,
				""",  moving relations is not allowed!!");
			     call
				mrds_rst_error (rsc_ptr, 2 /* severity */,
				mrds_error_$rst_rel_has_file, (message));
			end;
		     rel_gl_ptr -> gl.superior_assigned = ON; /* file present for this relation */
		     rel_gl_ptr -> gl.file_info_ptr = fi_ptr; /* set file info/model in relation global element */
		     rel_gl_ptr -> gl.file_model_ptr = fm_ptr;
		     rel_gl_ptr -> gl.other_info_ptr = gl_ptr; /* file global list element for relation */

/* add this relation to the file's relation sublist */

		     call
			mrds_rst_list_element$add (relation.name, SUB_LIST, rsc_ptr,
			gl.item_sub_list_ptr, sl_ptr, error_code);

		     if error_code ^= 0 then do;
			     call
				ioa_$rs ("^a^a^a^a", message, message_length,
				"LOGIC ERROR in  mrds_rst_file_handler, a duplicate relation """
				, relation.name, """ was found in sublist of file """,
				file.name, """.");
			     call
				mrds_rst_error (rsc_ptr, 4 /* severity */, error_code,
				(message));
			     num_dims = 0;		/* unused variable */
			end;
		     else do;

/* fill in the sublist element */

			     sl.type = SUB_LIST;
			     sl.name = relation.name;
			     sl.item_info_ptr = null (); /* no relation info yet */
			     sl.parse_info_ptr = relation_ptr; /* relation parse structure */
			     sl.old_other_info_ptr = null ();
			     sl.new_other_info_ptr = gl_ptr;
			     sl.global_list_ptr = rel_gl_ptr;
			     sl.reserved = OFF;

/* build the relation info for this "good" relation in this file */

			     call load_rel_info ();
			     gl.inferior_assigned = ON; /* relation present for file */

/* build all the attribute infos contained in this relation, if attributes present, and rel_info obtained */

			     if ^rel_gl_ptr -> gl.inferior_assigned
				| ^rel_gl_ptr -> gl.complete then
				;
			     else do;

				     call load_attr_infos ();

				     call check_relation_key_length ();

				     call align_varying_tuple_data ();
				end;
			end;
		end;

/* go to next relation in list */

	     item_ptr = item.next;
	end;

     end;

load_file_model:
     procedure ();

/* routine to initialize and fill in the file model/info */

	db_model_path = rtrim (rsc.temp_dir) || ">db_model";

/* update the db_model file statistics */

	dbm_ptr = rsc.n_dm_ptr;
	db_model.num_unblk_files = db_model.num_unblk_files + 1;
	db_model.unblk_file_id_len =
	     max (db_model.unblk_file_id_len,
	     fixed (ceil (log2 (db_model.num_unblk_files)), 17));
	bit_36_temp = db_model.num_unblk_files;

/* add a file_info to the db_model for this file */

	call mrds_rst_model_alloc (rsc_ptr, db_model_path, FILE_INFO, fi_ptr);

	if fi_ptr ^= null () then
	     ;
	else if rsc.model_overflow then
	     ;					/* reported first time only */
	else do;
		rsc.model_overflow = ON;
		call
		     ioa_$rs ("^a^a^a^a ^a", message, message_length, "File """,
		     file.name, """", line_number (),
		     "caused an overflow of the db_model while processing the file_info.")
		     ;
		call
		     mrds_rst_error (rsc_ptr, 2 /* severity */,
		     mrds_error_$rst_model_limit, (message));
	     end;

	gl.file_info_ptr = fi_ptr;
	gl.item_info_ptr = fi_ptr;

	if error_mode then
	     name_of_file = unique_chars_ ("0"b);	/* use dummy name if previous error */
	else name_of_file = rtrim (file.name);
	file_model_path = rtrim (rsc.temp_dir) || ">" || name_of_file || ".m";

	if fi_ptr = null () then
	     ;					/* due to model overflow */
	else do;

		file_info.file_name = name_of_file;
		file_info.file_id = "000000000000000000000000000000000001"b;

/* link into file_info list in order */

		file_info.fwd_ptr, file_info.unused = NULL_OFFSET;

		if db_model.file_ptr = NULL_OFFSET then
		     db_model.file_ptr = rel (fi_ptr);
		else do;
			if stmt (directive.type).file.number > 0 then
			     ;			/* not first time */
			else do;			/* first time, get list end */
				last_fi_ptr = pointer (dbm_ptr, db_model.file_ptr);
				do while (last_fi_ptr -> file_info.fwd_ptr ^= NULL_OFFSET);
				     last_fi_ptr =
					pointer (dbm_ptr, last_fi_ptr -> file_info.fwd_ptr);
				end;
			     end;
			last_fi_ptr -> file_info.fwd_ptr = rel (fi_ptr); /* set list end as new file_info */
		     end;
		last_fi_ptr = fi_ptr;

	     end;

/* get a segment for a file_model for this file */

	call
	     mrds_rst_get_seg_ptr (rsc_ptr,
	     rsc.h_n_seg_info_ls_ptr /* put in new model list */,
	     name_of_file || ".m" /* file_model name */, ON /* create seg */,
	     fm_ptr, error_code);

	if error_code ^= 0 then do;
		call
		     ioa_$rs ("^a^a^a", message, message_length,
		     "Unable to make segment for file model of file """, name_of_file,
		     """.");
		call mrds_rst_error (rsc_ptr, 4 /* severity */, error_code, (message));
	     end;
	else do;

/* initialize the file model */

		call file_model_init ();
		gl.superior_assigned = ON;		/* file model for file present */
		gl.file_model_ptr = fm_ptr;

	     end;

     end;

file_model_init:
     procedure ();
						/* fill in file parameters with initial values */

	like_file_model = init_file_model;		/* init model */
	file_model.fi_ptr = rel (fi_ptr);		/* offset in db_model of file_info */
	file_model.changer_ptr = db_model.changer_ptr;	/* get person.project and system time */
	file_model.fm_area = empty ();		/* initailize file_model area */

     end;

load_rel_info:
     procedure ();

/* routine to allocate and initialize the rel_info structure for
   the current relation in this file, using the file model area,
   and updating the file_model and global file element as necessary */

	call mrds_rst_model_alloc (rsc_ptr, file_model_path, REL_INFO, ri_ptr);

	if ri_ptr ^= null then
	     rel_gl_ptr -> gl.complete = ON;		/* rel_info present now */
	else if rsc.model_overflow then
	     ;					/* reported only first time */
	else do;
		rsc.model_overflow = ON;
		call
		     ioa_$rs ("^a^a^a^a ^a^a^a", message, message_length, "File """,
		     file.name, """", line_number (),
		     "caused an overflow of the file_model while processing the relation """
		     , relation.name, """.");
		call
		     mrds_rst_error (rsc_ptr, 2 /* severity */,
		     mrds_error_$rst_model_limit, (message));
	     end;

	rel_gl_ptr -> gl.item_info_ptr = ri_ptr;	/* set rel_info in rel global element */
	sl.item_info_ptr = ri_ptr;			/* set rel_info in file's rel sublist element */

/* update the relation count */

	if ri_ptr = null () then
	     ;
	else do;

		db_model.num_rels = db_model.num_rels + 1;

/* initialize relation detailed information */

		rel_info = init_rel_info;		/* copy template */
		rel_info.name = relation.name;
		rel_info.changer_ptr = file_model.changer_ptr;
		bit_36_temp = db_model.num_rels;

		file_model.rel_ptr = rel (ri_ptr);

	     end;

     end;

load_attr_infos:
     procedure ();

/* routine to allocate and initialize the attr_info structures for
   the attributes in the current relation, using the file model area,
   updating the file_model and rel_info and global list elements as necessary to reflect the additions */

	root_ptr = rel_gl_ptr -> gl.item_sub_list_ptr;	/* start of attr list for this relation */
	all_attributes_used = OFF;			/* not all attrs added to rel yet */
	current_definition_order = 1;

/* run through all attributes in this relation */

	do while (^all_attributes_used);

	     if ^definition_order_found () then
		all_attributes_used = ON;
	     else do;

/* get needed pointers */

		     di_ptr = attr_gl_ptr -> gl.other_info_ptr; /* get attribute's domain info pointer */
		     dom_sl_ptr = attr_gl_ptr -> gl.item_info_ptr; /* corres domain sublist for attr */

/* now get space for a new attr_info for this attribute for this relation */

		     call
			mrds_rst_model_alloc (rsc_ptr, file_model_path, ATTR_INFO,
			ai_ptr);
		     if ai_ptr ^= null then
			attr_gl_ptr -> gl.complete = ON; /* attr_info present */
		     else if ^rsc.model_overflow then do;
			     rsc.model_overflow = ON; /* so only first overflow reported */
			     call
				ioa_$rs ("^a^a^a^a ^a^a^a^a^a", message, message_length,
				"File """, file.name, """", line_number (),
				"caused an overflow of the file_model while processing attribute """
				, attr_gl_ptr -> gl.name, """ in relation """,
				rel_gl_ptr -> gl.name, """.");
			     call
				mrds_rst_error (rsc_ptr, 2 /* severity */,
				mrds_error_$rst_model_limit, (message));
			end;

/* update global list entries */

		     rel_sl_ptr -> sl.item_info_ptr = ai_ptr; /* set attr_info in rel's attr sublist element
						   this can be used now to get the fm_ptr via pointer(ai_ptr,0)
						   and the fi_ptr via pointer(fm_ptr, file_model.fi_ptr) */
		     if attr_sl_ptr ^= null () then do;
			     attr_sl_ptr -> sl.item_info_ptr = ri_ptr; /* set rel_info in attr's rel sublist element */
			     attr_sl_ptr -> sl.old_other_info_ptr = ai_ptr;
						/* set attr_info ptr for this rel */
			end;
		     if dom_sl_ptr = null () then
			;
		     else dom_sl_ptr -> sl.item_info_ptr = ai_ptr; /* set attr_info in domain's attr sublist */

/* fill in the attr_info structure for this attribute */

		     call set_attr_info ();

		end;

/* go to the next attribute in user defined order */

	     current_definition_order = current_definition_order + 1;
	end;
     end;

set_attr_info:
     procedure ();

/* routine to fill in the attr_info structure details */

/* count up number of attributes */

	if ai_ptr = null () then
	     ;
	else do;
		rel_info.num_attr = rel_info.num_attr + 1;
		if ^attribute.pr_key then
		     ;
		else rel_info.num_key_attrs = rel_info.num_key_attrs + 1;

		if rel_info.num_attr > mrds_data_$max_attributes & ^rsc.max_attrs
		then do;
			rsc.max_attrs = ON;
			call
			     ioa_$rs ("^a^a^a^a^a ^d^a", message, message_length,
			     "Attribute """, attr_gl_ptr -> gl.name, """ in relation """,
			     rel_gl_ptr -> gl.name,
			     """ exceeded the maxmimum number of attributes allowed per relation of"
			     , mrds_data_$max_attributes, ".");
			call
			     mrds_rst_error (rsc_ptr, 2 /* severity */,
			     mrds_error_$max_attributes, (message));
		     end;



/* initialize attr_info structure */

		attr_info.name = attribute.name;
		attr_info.changer_ptr = file_model.changer_ptr;
		attr_info.key_attr = attribute.pr_key;	/* ON => primary key */
		attr_info.index_attr = OFF;		/* not involved in indexes or links yet */
		attr_info.link_attr = OFF;
		attr_info.reserved = OFF;
		attr_info.index_id = OFF;
		attr_info.defn_order = attribute.defn_order;
		attr_info.key_order = attribute.key_order;
		attr_info.link_par_cnt, attr_info.link_child_cnt = 0;
		attr_info.rslt_ptr = NULL_OFFSET;	/* off for  mrds */

/* compute attribute bit offset and length, update rel_info max data length,
   and number/offset of varying attributes, and the average tuple size,
   also set the attribute and global list domain info pointers */

		call compute_bit_offset_and_length ();	/* sets average_tuple_length */

/* link the attr_info into the list in definition order */

		current_ai_ptr = pointer (fm_ptr, rel_info.attr_ptr);
		last_ai_ptr = null ();
		place_not_found = ON;

/* find the right list position according to definition order */

		do while (place_not_found);
		     if rel (current_ai_ptr) = NULL_OFFSET then
			place_not_found = OFF;
		     else if current_ai_ptr -> attr_info.defn_order
			     >= attr_info.defn_order then
			place_not_found = OFF;
		     else do;
			     last_ai_ptr = current_ai_ptr;
			     current_ai_ptr =
				pointer (fm_ptr, current_ai_ptr -> attr_info.fwd_thread);
			end;
		end;

/* set this attr_info's forward pointer */

		if current_ai_ptr = null () then
		     attr_info.fwd_thread = NULL_OFFSET;
		else attr_info.fwd_thread = rel (current_ai_ptr);

/* set previous pointer to this attr_info */

		if last_ai_ptr = null () then
		     rel_info.attr_ptr = rel (ai_ptr);
		else last_ai_ptr -> attr_info.fwd_thread = rel (ai_ptr);
	     end;

     end;

definition_order_found:
     procedure () returns (bit (1));

/* this routine determines if the current definition order
   correspondes to any in the sublist of attrs for this relation */

	node_ptr = root_ptr;			/* convention for first on list */
	found = OFF;
	required_order_found = OFF;
	do while (^found);

	     call get_definition_order (order_was_obtained, order_obtained);
	     if ^order_was_obtained then do;
		     found = ON;
		     required_order_found = OFF;
		end;
	     else if current_definition_order ^= order_obtained then
		;
	     else do;
		     found = ON;
		     required_order_found = ON;
		end;

	end;

	return (required_order_found);


	declare required_order_found	 bit (1);		/* on => current order is in list */
	declare found		 bit (1);		/* on => exit loop, else keep looking */
	declare order_was_obtained	 bit (1);		/* on => given order was in list */
	declare order_obtained	 fixed bin;	/* order found during get next order */

     end;

get_definition_order:
     procedure (found, order_found);

/* get the definition order of the next attribute in the relation's attr sublist */

	call
	     mrds_rst_tree_successor (root_ptr, node_ptr, successor_ptr,
	     successor_parent_ptr, found);
	if ^found then
	     order_found = 0;
	else do;

		node_ptr = successor_ptr;		/* make it the current one */
		rel_sl_ptr = node_ptr -> node.data;	/* get rel sublist pointer */
		attr_gl_ptr = rel_sl_ptr -> sl.global_list_ptr; /* get global attr pointer */
		call
		     list_search (relation.name, attr_gl_ptr -> gl.item_sub_list_ptr,
		     attr_sl_ptr, ATTR_SL);
		attribute_ptr = rel_sl_ptr -> sl.parse_info_ptr; /* get parse information */
		order_found = attribute.defn_order;

	     end;


	declare order_found		 fixed bin;	/* definition order of next attribute */
	declare found		 bit (1);		/* on => attr found, else none left */

     end;

list_search:
     procedure (key, root_ptr, data_ptr, success);

/* routine to get an element pointer from the global lists */

	call mrds_rst_tree_search (key, root_ptr, node_ptr, parent_ptr, success);

	if success then
	     data_ptr = node_ptr -> node.data;
	else do;
		call
		     ioa_$rs ("^a^a^a", message, message_length,
		     "LOGIC ERROR in mrds_rst_file_handler, the name """, key,
		     """ was found in a global list, but not in the corresponding sublist"
		     );
		call
		     mrds_rst_error (rsc_ptr, 4 /* severity */,
		     mrds_error_$rst_logic_error, (message));
		data_ptr = null ();
	     end;

	declare key		 char (32) aligned; /* name to look for in list */
	declare root_ptr		 ptr;		/* head of desired list */
	declare node_ptr		 ptr;		/* pointer to head portion of list element */
	declare parent_ptr		 ptr;		/* pointer to tree parent of found node */
	declare data_ptr		 ptr;		/* pointer to data portion of list element */
	declare success		 bit (1);		/* ON => element found */

     end;

compute_bit_offset_and_length:
     procedure ();

/* routine to convert the attribute's domain descriptor into
   the required tuple offset and space required and update the
   corresponding statistics for the relation information
   NOTE: the padding routines were introduced to make the data stored
   in the tuple(via bit offset/length) relect the pl1 definition
   of storage locations needed for unaligned and aligned data types */

	attr_info.bit_length = get_domain_bit_size ();	/* also sets domain_info ptr in attr_info */

/* fixed length attribute/domain handling */

	if ^varying_string then do;			/* fixed attributes */
		padding =
		     mdbm_util_$align_data_item (desc_ptr, rel_info.var_offset - 1);
		attr_info.bit_offset = rel_info.var_offset + padding;
						/* set to end of fixed data */
		rel_info.var_offset =
		     rel_info.var_offset + attr_info.bit_length + padding;
						/* set new fixed data end */
		rel_info.avg_data_len =
		     rel_info.avg_data_len + attr_info.bit_length + padding;
						/* average = max for fixed */
	     end;

/* varying string handling */

	else do;					/* varying strings */
		rel_info.nvar_atts = rel_info.nvar_atts + 1; /* count up varying attributes */
		attr_info.bit_offset = rel_info.nvar_atts; /* varying array index, not offset */
		rel_info.avg_data_len =
		     rel_info.avg_data_len + average_varying_length
		     + pad (WORD, average_varying_length); /* use average for varying */
		padding = pad (WORD, attr_info.bit_length); /* varying must start/stop on word boundary */
	     end;

/* set the maximum tuple and key bit lengths */

	rel_info.max_data_len =
	     rel_info.max_data_len + attr_info.bit_length + padding;
	if ^attribute.pr_key then
	     ;
	else rel_info.max_key_len = rel_info.max_key_len + attr_info.bit_length;


     end;

get_domain_bit_size:
     procedure () returns (fixed binary (35));

/* calculate the amount of storage that needs to be allocated(in bits)
   to hold a converted value that has the same type as the domain */

	varying_string = OFF;

/* set attributes domain info pointer */

	if di_ptr = null () then do;
		attr_info.domain_ptr = NULL_OFFSET;
		domain_bit_length = 1;		/* set dummy domain size */
		attr_gl_ptr -> gl.consistant = OFF;	/* no domain info present for attribute */
		desc_ptr = null ();
	     end;
	else do;					/* good domain present */

		attr_info.domain_ptr = rel (di_ptr);
		attr_gl_ptr -> gl.other_info_ptr = di_ptr; /* set domain_info in attr global element */
		rel_sl_ptr -> sl.new_other_info_ptr = di_ptr; /* set domain_info in rel sublist for attr */
		desc_ptr = addr (domain_info.db_desc);	/* get descriptor for this attribute */

/* set bit length according to this domain's data type, and average length of varying strings */

		domain_bit_length =
		     mdbm_util_$get_data_bit_length (desc_ptr -> descriptor_bit_36_ovrly)
		     ;

/* set varying strings average bit length */

		if descriptor.type = 20 then do;	/* bit varying */
			varying_string = ON;
			average_varying_length = domain_info.ave_len + 36;
		     end;
		else if descriptor.type = 22 then do;	/* char varying */
			varying_string = ON;
			average_varying_length = (domain_info.ave_len * 9) + 36;
		     end;
		else ;				/* not varying string */

	     end;

	return (domain_bit_length);


	declare domain_bit_length	 fixed binary (35); /* required bit length to store domain's data */

     end;

pad:
     procedure (pad_size, pad_base) returns (fixed bin);

/* routine to return the number of bits necessary to pad a bit count
   out to an alignment boundary of 9(byte), 36(word), or 72(double word) bits
   as determined by the pad size input */

	if mod (pad_base, pad_size) = 0 then
	     number_of_bits = 0;
	else do;

		number_of_bits = pad_size - mod (pad_base, pad_size);

	     end;

	return (number_of_bits);


	declare pad_size		 fixed bin;	/* either 9 or 36 or 72 */
	declare pad_base		 fixed bin (35);	/* current bit length to be padded */
	declare number_of_bits	 fixed bin;	/* what has to be added to get to the desired boundary */

     end;

align_varying_tuple_data:
     procedure ();

/* varying attributes in the tuple must start on a word boundary,
   this routine makes sure that the end of the fixed data portion of the
   tuple, which is where the varying attributes start, is on that boundary */

	if rel_info.nvar_atts = 0 then
	     ;
	else do;

		amount_to_pad = pad (WORD, rel_info.var_offset - 1);
		rel_info.var_offset = rel_info.var_offset + amount_to_pad;
		rel_info.max_data_len = rel_info.max_data_len + amount_to_pad;
		rel_info.avg_data_len = rel_info.avg_data_len + amount_to_pad;

	     end;


	declare amount_to_pad	 fixed bin;	/* bits needed for word alignment */

     end;

check_file_size_and_number:
     procedure ();

/* routine to check that the number of files and/or
   the maximum number of file tuples don't
   exceed implementation limits based on the mdbm_tuple_id.incl.pl1 constants */

	file_id_space = db_model.unblk_file_id_len;	/* already set to max(file_id_len, ceil(log2(num_files))) */
	db_model.max_max_tuples = max (db_model.max_max_tuples, max_tuples);
						/* get max across all files so far */
	if db_model.max_max_tuples = 0 then
	     tuple_id_space = 0;
	else tuple_id_space = ceil (log2 (db_model.max_max_tuples));
	vfile_component_space = ceil (log2 (max_vfile_components));

/* try to pad the file_id_space out to mrds_data_$file_id_len_pad
   to make room for restructuring to add files wihtout causing the
   reformatting of all files in the database due to an overflow of the
   existing db_model.file_id_len space allotted */

/*	     if file_type = BLOCKED then
   blocked_check = ON ;
   else blocked_check = OFF ;
   first_time = ON ;
   space_left_to_pad = ON ;
   do while (space_left_to_pad) ;

   if (blocked_check & (file_id_space + tuple_id_space <= 34)) |
   (^blocked_check & (file_id_space + vfile_component_space <= 17)) then do ;

   /* last space usage within limits, try to get another
   bit for the file_id_space to occupy * /

   if file_id_space < mrds_data_$file_id_len_pad then
   file_id_space = file_id_space + 1 ; /* can add bit since within needed space guess * /
   else space_left_to_pad = OFF ;
   end ;

   else if ^first_time then do ;

   /* we padded too much, back off one bit and use that * /

   file_id_space = file_id_space - 1 ;
   space_left_to_pad = OFF ;
   end ;

   else do ;

   /* not enough space on the first try with minimrdsm sizes * /

   space_left_to_pad = OFF ; */

	file_id_space = ceil (log2 (mrds_data_$max_relations)) + 1;

	if db_model.num_blk_files + db_model.num_unblk_files
	     > mrds_data_$max_relations then do;


		if rsc.max_files then
		     ;				/* only give error first time */
		else do;
			rsc.max_files = ON;
			call
			     ioa_$rs ("^a^a^a^a ^a ^d ^a", message, message_length,
			     "The file """, file.name, """", line_number (),
			     "was unblocked file number", db_model.num_unblk_files,
			     "and exceeded the maximum number of unblocked files allowed."
			     );
			call
			     mrds_rst_error (rsc_ptr, 2 /* severity */,
			     mrds_error_$rst_option_limit, (message));
		     end;
	     end;


/* save the possibly bigger file_id_space calculated */

	db_model.unblk_file_id_len = file_id_space;



	declare file_id_space	 fixed binary;	/* bit length of file id */
	declare tuple_id_space	 fixed binary;	/* bit length of tuple maximum */
	declare vfile_component_space	 fixed binary;	/* bit length of max vfile components */
	declare max_vfile_components	 fixed binary init (900); /* max no of comps */

     end;

check_relation_key_length:
     procedure ();

/* make sure that the data length of the attributes
   that make up the primary key for this relation do not
   exceed the implementation restriction maximum */

	key_length_in_chars = ceil (rel_info.max_key_len / 9);

	if key_length_in_chars <= mrds_data_$max_key_len then
	     ;
	else do;

		call
		     ioa_$rs ("^a^a^a ^d ^a^a^a ^d ^a ^d ^a", message, message_length,
		     "The relation """, relation.name, """ on line", relation.line_num,
		     "given in file """, file.name,
		     """ has a primary key data length of", key_length_in_chars,
		     "characters, which is greater than the allowed maximum length of",
		     mrds_data_$max_key_len, "characters.");
		call
		     mrds_rst_error (rsc_ptr, 2 /* severity */, mrds_error_$long_key,
		     (message));

	     end;


     end;

line_number:
     procedure () returns (char (20) varying);

/* return null string for default files,
   or the line occurence for files from the source */

	if file.default then
	     returned_line = "";
	else returned_line = ", on line " || ltrim (char (file.line_num)) || ",";

	return (returned_line);


	declare returned_line	 char (20) varying;

     end;

	declare name_of_file	 char (30) varying; /* name to add .m to for model seg */
	declare db_model_path	 char (168);	/* path name to db_model */
	declare file_model_path	 char (200);	/* path name down to file_model */
	declare mrds_rst_rsc_alloc	 entry (ptr, fixed bin, ptr); /* work area manager */
	declare mrds_rst_model_alloc	 entry (ptr, char (*), fixed bin, ptr);
						/* model allocation routine */

	declare unique_chars_	 entry (bit (*)) returns (char (15)); /* unique character generator */
	declare error_mode		 bit (1);		/* ON => duplicate file name processing fixup */
	declare mrds_rst_tree_successor entry (ptr, ptr, ptr, ptr, bit (1));
						/* get next routine */
	declare attr_gl_ptr		 ptr;		/* pointer to attribute global element */
	declare dom_sl_ptr		 ptr;		/* pointer to corres attribute domain sublist element */
	declare rel_sl_ptr		 ptr;		/* pointer to relation sublist element */
	declare attr_sl_ptr		 ptr;		/* pointer to attribute sublist element */
	declare ATTR_SL		 bit (1);		/* ON => pointer found for attr_sl_ptr */
						/* init path/entry value */
	declare file_name		 char (30);	/* file name for this call */
	declare (addr, ceil, char, log2, empty, fixed, ltrim, max, mod, null, pointer, rel, rtrim)
				 builtin;		/* functions known to pl1 */
	declare ON		 bit (1) internal static options (constant) init ("1"b);
						/* true value */
	declare OFF		 bit (1) internal static options (constant) init ("0"b);
						/* false value */
	declare NULL_OFFSET		 bit (18) internal static options (constant)
				 init ((18)"1"b);	/* db version of null offset */
	declare sys_info$max_seg_size	 fixed bin (35) external; /* system constant */
	declare mrds_rst_get_seg_ptr
				 entry (ptr, ptr, char (32) aligned, bit (1), ptr, fixed bin (35));
						/* ON => get new segment */
	declare error_code		 fixed binary (35); /* mrds_error_ table index */
	declare message		 char (320) varying;/* specifics of error message */
	declare message_length	 fixed bin (21);	/* length of specifics message */
	declare last_fi_ptr		 ptr internal static; /* saved file_info pointer */
	declare last_ai_ptr		 ptr;		/* saved attr_info pointer */
	declare current_ai_ptr	 ptr;		/* pointer to present attr_info in list */
	declare place_not_found	 bit (1);		/* definition order insertion place flag */
	declare mrds_error_$rst_model_limit fixed bin (35) external;
						/* model capacity exceeded */
	declare mrds_error_$long_key	 fixed bin (35) external; /* max key length exceeded */
	declare mrds_error_$rst_option_limit fixed bin (35) external;
						/* exceeded allowable for option */
	declare mrds_error_$rst_undone_option fixed bin (35) external;
						/* option not coded yet */
	declare mrds_error_$rst_undef_rel fixed bin (35) external; /* item not in database */
	declare mrds_error_$rst_dup_file fixed bin (35) external; /* duplicate attr definition */
	declare mrds_error_$rst_rel_has_file fixed bin (35) external;
						/* file assigned to relation */
	declare mrds_error_$rst_logic_error fixed bin (35) ext; /* program failure */
	declare max_tuples		 fixed binary (71); /* file's accumulated max tuples */
	declare mrds_data_$max_key_len fixed bin (35) ext;/* implementation restriction on key size */
	declare key_length_in_chars	 fixed bin (35);	/* computed character length of relation key */
	declare mrds_rst_tree_search	 entry (char (32) aligned, ptr, ptr, ptr, bit (1));
						/* list searcher */
	declare mrds_rst_error	 entry (ptr, fixed bin, fixed bin (35), char (*));
						/* general error handler */
	declare ioa_$rs		 entry options (variable); /* string manipulator */
	declare mrds_rst_list_element$add
				 entry (char (32) aligned, fixed binary, ptr, ptr, ptr,
				 fixed bin (35));
	declare list_ptr		 ptr;		/* pointer to parse info list */
	declare IN		 bit (1) internal static options (constant) init ("1"b);
						/* input meter flag */
	declare OUT		 bit (1) internal static options (constant) init ("0"b);
						/* output meter flag */
	declare mrds_rst_meter	 entry (ptr, char (*), bit (1), char (*));
						/* metering/tracing routine */
	declare rel_gl_ptr		 ptr;		/* temp storage for relation global element pointer */
	declare average_varying_length fixed bin (35);	/* average varying string bit length */
	declare varying_string	 bit (1);		/* ON => varying string type attribute */
	declare bit_36_temp		 fixed bin (35) aligned; /* 36 bit word to overlay */
	declare BYTE		 fixed bin init (9);/* byte boundary = 9 bits */
	declare WORD		 fixed bin init (36); /* word boundary = 36 bits */
	declare DOUBLE_WORD		 fixed bin init (72); /* double word boundary = 72 bits */
	declare padding		 fixed bin;	/* amount needed to pad to a given boundary */
	declare current_definition_order fixed bin;	/* definition order for current attr */
	declare all_attributes_used	 bit (1);		/* on => all rel attrs processed */
	declare mdbm_util_$get_data_bit_length entry (bit (36))
				 returns (fixed bin (35)); /* gets storage bits from descriptor */
	declare descriptor_bit_36_ovrly bit (36) based;	/* overlay for descriptor */
	declare mdbm_util_$align_data_item entry (ptr, fixed bin (35))
				 returns (fixed bin); /* aligns to data type boundary,
						   given current offset */
	declare mrds_error_$rst_reserved_name fixed bin (35) ext; /* reserved name used */
	declare mrds_data_$max_relations fixed bin (35) ext; /* most relations can create */
	declare mrds_data_$max_attributes fixed bin (35) ext; /* max attrs allowed per rel */
	declare mrds_error_$max_attributes fixed bin (35) ext; /* > mrds_data_$max_attrs seen */

%include mrds_rst_struct_types;
%include mdbm_descriptor;
%include mrds_rst_rsc;
%include mrds_rst_semantics;
%include mrds_rst_parse_info;
%include mrds_rst_tree;
%include mrds_rst_global_lists;
%include mdbm_file_model;
%include mdbm_file_model_init;
%include mdbm_db_model;

     end;
