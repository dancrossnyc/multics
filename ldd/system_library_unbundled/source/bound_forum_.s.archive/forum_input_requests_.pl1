/****^  ***************************************************************
        *                                                             *
        * Copyright, (C) BULL HN Information Systems Inc., 1990       *
        *                                                             *
        * Copyright, (C) Massachusetts Institute of Technology, 1986  *
        *                                                             *
        * Copyright (c) 1982 by Massachusetts Institute of Technology *
        *                                                             *
        *************************************************************** */



/****^  HISTORY COMMENTS:
  1) change(86-07-29,Pattin), approve(86-07-29,MCR7354),
     audit(86-08-07,Margolin), install(86-08-16,MR12.0-1128):
     Fixed bug in apply request causing null ptr faults.
  2) change(90-09-03,Bubric), approve(90-09-03,MCR8200),
     audit(90-09-26,Blackmore), install(90-10-05,MR12.4-1038):
     Fix the forum request "apply" so that it doesn't change an unprocessed
     transaction's meeting to the current meeting.
  3) change(91-09-05,Huen), approve(91-09-05,MCR8249),
     audit(92-01-08,Zimmerman), install(92-04-27,MR12.5-1014):
     phx20579: Fix the "apply" request to create new unproc trans when
     no unproc trans exists and no trans_specs is given.
     phx20578: Generate a complete header when printing an unproc trans which
     is created iwth the use of the "spply" request.
  4) change(91-09-05,Huen), approve(91-09-05,MCR8250),
     audit(92-01-08,Zimmerman), install(92-04-27,MR12.5-1014):
     phx20898 & 20899: Fix the "enter" request to handle trans created with
     "reply -mtg"
                                                   END HISTORY COMMENTS */
/* This module contains the following forum requests:

   talk   reply   set_message   enter   subject   fill
   apply   qedx   ted

   Original coding 6/81 J. Spencer Love
   Modified for ssu_ 8/21/81 Jay Pattin
   added set_message 2/27/82 Jay Pattin
   changed to use format_document_ and apply_request_util_ 6/27/82 Jay Pattin
   changed to use qedx_ (FINALLY !!) 1/18/83 Jay Pattin */

forum_input_requests_$talk_request:
     procedure (P_ssu_ptr, P_passport_info_ptr);

	declare (P_ssu_ptr, P_passport_info_ptr)
				 ptr parameter;

	declare (addr, codeptr, divide, index, length, ltrim, min, null, rtrim, string, substr, translate, verify)
				 builtin;

	declare (cleanup, linkage_error) condition;

	declare answer		 char (6) varying,
	        arg_count		 fixed bin,
	        arg_idx		 fixed bin,
	        arg_len		 fixed bin (21),
	        arg_ptr		 ptr,
	        auto_rql		 bit (1) aligned,
	        auto_write		 bit (1) aligned,
	        bit_count		 fixed bin (24),
	        brief_switch	 bit (1),
	        buffer_len		 fixed bin (21),
	        buffer_ptr		 ptr,
	        default_switch	 bit (1) aligned,
	        dirname		 char (168),
	        entryname		 char (32),
	        fill_switch		 fixed bin,
	        first_nonwhite_pos	 fixed bin (21),
	        force		 bit (1) aligned,
	        idx		 fixed bin (21),
	        inhibit_auto_fill	 bit (1) aligned,
	        inhibit_input_cp_escape bit (1) aligned,
	        line_length		 fixed bin,
	        mask		 bit (36) aligned,
	        message		 char (256),
	        message_sw		 bit (1) aligned,
	        forum_idx		 fixed bin,
	        forum_dir		 char (168),
	        forum_name		 char (32),
	        full_forum_name	 char (32),
	        new_buffer_ptr	 ptr,
	        new_buffer_len	 fixed bin (21),
	        no_chars_read	 fixed bin (21),	/* used for iox_ calls */
	        reply_switch	 bit (1),
	        reply_trans_idx	 fixed bin,
	        request_loop	 bit (1) aligned,
	        return_arg_len	 fixed bin (21),
	        return_arg_ptr	 ptr,
	        ssu_ptr		 ptr,
	        status		 fixed binary (35),
	        subject_arg_len	 fixed bin (21),
	        subject_arg_ptr	 ptr,
	        subject_switch	 bit (1) aligned,
	        ted_data_p		 ptr,
	        temp_forum		 bit (1) aligned,
	        text_len		 fixed bin (21),
	        temp_seg_ptr	 ptr,
	        terminal_switch	 bit (1) aligned,
	        trans_pic		 pic "zz9999",	/* pretty picture of trans no */
	        user_file_len	 fixed bin (21),
	        user_file_ptr	 ptr,
	        whoami		 char (32),
	        whoami_really	 char (32);

	declare 1 ted_info		 aligned like ted_data,
	        1 fdoc		 aligned like format_document_options,
	        1 qi		 aligned,
		2 header		 like qedx_info.header,
		2 buffers		 (2) like qedx_info.buffers;

	declare arg		 char (arg_len) based (arg_ptr),
	        buffer		 char (buffer_len) based (buffer_ptr),
	        new_buffer		 char (new_buffer_len) based (new_buffer_ptr),
	        return_arg		 char (return_arg_len) varying based (return_arg_ptr),
	        subject		 char (no_chars_read - first_nonwhite_pos)
				 based (add_char_offset_ (buffer_ptr, first_nonwhite_pos)),
	        subject_arg		 char (subject_arg_len) based (subject_arg_ptr),
	        temp_seg		 char (4 * sys_info$max_seg_size) based (temp_seg_ptr),
	        temp_text		 char (text_len) based (temp_seg_ptr),
	        user_file		 char (user_file_len) based (user_file_ptr);

	declare static_initialized	 bit (1) aligned static initial ("0"b),
	        my_person_id	 char (20) static,
	        my_project_id	 char (9) static;

	declare NORMAL_TERMINATION	 initial (1) fixed bin static options (constant),
	        ENTER_REQUEST_LOOP	 initial (2) fixed bin static options (constant),
	        ENTER_EDITOR	 initial (3) fixed bin static options (constant);

	declare LOWER_CASE		 initial ("abcdefghijklmnopqrstuvwxyz") char (26) static options (constant),
	        UPPER_CASE		 initial ("ABCDEFGHIJKLMNOPQRSTUVWXYZ") char (26) static options (constant);

	declare NL		 char (1) static options (constant) initial ("
"),
	        SPACE_AND_TAB	 char (2) static options (constant) initial ("	 "),
	        WHITE_CHARS		 char (5) static options (constant) initial ("
	 ");					/* NL VT FF HT SPACE				*/

	declare (forum_et_$cant_notify,
	        forum_et_$no_forum,
	        forum_et_$no_unprocessed,
	        forum_et_$read_only,
	        error_table_$bad_conversion,
	        error_table_$badopt,
	        error_table_$fatal_error,
	        error_table_$inconsistent,
	        error_table_$long_record,
	        error_table_$noarg,
	        error_table_$oldnamerr,
	        error_table_$recoverable_error,
	        error_table_$zero_length_seg,
	        sys_info$max_seg_size) fixed bin (35) external,
	        iox_$user_input	 ptr external;

	declare add_char_offset_	 entry (ptr, fixed bin (21)) returns (ptr) reducible,
	        command_query_	 entry () options (variable),
	        format_document_$string entry (char (*), char (*), fixed bin (21), ptr, fixed bin (35)),
	        forum_requests_$open_forum
				 entry (char (*), fixed bin, char (*), char (*), fixed bin (35)),
	        forum_trans_specs_$parse_specs
				 entry (ptr, fixed bin, bit (36) aligned, entry, fixed bin, char (*), char (*), ptr),
	        forum_trans_util_$read_trans entry (ptr, fixed bin, fixed bin, ptr, fixed bin (35)),
	        forum_$close_forum	 entry (fixed bin, fixed bin (35)),
	        forum_$enter_trans	 entry (fixed bin, char (*), fixed bin, char (*), bit (1) aligned, fixed bin,
				 fixed bin (35)),
	        forum_$get_message	 entry (fixed bin, char (*), fixed bin (35)),
	        forum_$set_message	 entry (fixed bin, char (*), fixed bin (35)),
	        forum_$open_forum	 entry (char (*), char (*), fixed bin, fixed bin (35)),
	        cu_$cp		 entry (ptr, fixed bin (21), fixed bin (35)),
	        cv_dec_check_	 entry (char (*), fixed bin (35)) returns (fixed bin (35)),
	        expand_pathname_	 entry (char (*), char (*), char (*), fixed bin (35)),
	        get_temp_segment_	 entry (char (*), ptr, fixed bin (35)),
	        hcs_$fs_get_path_name	 entry (ptr, char (*), fixed bin, char (*), fixed bin (35)),
	        hcs_$initiate_count	 entry (char (*), char (*), char (*), fixed bin (24), fixed bin (2), ptr,
				 fixed bin (35)),
	        hcs_$reset_ips_mask	 entry (bit (36) aligned, bit (36) aligned),
	        hcs_$set_bc_seg	 entry (ptr, fixed bin (24), fixed bin (35)),
	        hcs_$set_ips_mask	 entry (bit (36) aligned, bit (36) aligned),
	        hcs_$status_mins	 entry (ptr, fixed bin (2), fixed bin (24), fixed bin (35)),
	        hcs_$terminate_noname	 entry (ptr, fixed bin (35)),
	        iox_$get_line	 entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35)),
	        ioa_		 entry options (variable),
	        ioa_$nnl		 entry options (variable),
	        ipc_$cutoff		 entry (fixed bin (71), fixed bin (35)),
	        ipc_$reconnect	 entry (fixed bin (71), fixed bin (35)),
	        qedx_		 entry (ptr, fixed bin (35)),
	        release_temp_segment_	 entry (char (*), ptr, fixed bin (35)),
	        requote_string_	 entry (char (*)) returns (char (*)),
	        ssu_$abort_line	 entry options (variable),
	        ssu_$apply_request_util entry (ptr, fixed bin, ptr, fixed bin (21), fixed bin (21)),
	        ssu_$arg_ptr	 entry (ptr, fixed bin, ptr, fixed bin (21)),
	        ssu_$get_request_name	 entry (ptr) returns (char (32) varying),
	        ssu_$get_subsystem_and_request_name
				 entry (ptr) returns (char (72) varying),
	        ssu_$print_message	 entry options (variable),
	        ssu_$return_arg	 entry (ptr, fixed bin, bit (1) aligned, ptr, fixed bin (21)),
	        user_info_$whoami	 entry (char (*), char (*), char (*)),
	        value_$get		 entry options (variable);
%page;
%include forum_passport;
%page;
%include forum_user_trans;
%page;
%include forum_trans_list;
%page;
%include query_info;
%page;
%include ted_;
%page;
%include qedx_info;
%page;
%include format_document_options;
%page;
/* forum_input_requests_$talk_request:  procedure (P_ssu_ptr, P_passport_info_ptr);		*/

	call setup_request (1);

	reply_switch = "0"b;
	auto_rql = "1"b;

	on cleanup call clean_up_talk ();

	do arg_idx = 1 to arg_count;
	     call parse_arg (arg_idx);
	end;

	call process_transaction ();

	call clean_up_talk ();

	return;
%page;
forum_input_requests_$reply_request:
     entry (P_ssu_ptr, P_passport_info_ptr);

	call setup_request (1);
	if passport.forum_idx = 0 then call ssu_$abort_line (ssu_ptr, forum_et_$no_forum);

	reply_switch = "1"b;
	auto_rql = "1"b;

	on cleanup call clean_up_talk ();

	parse_flags_word = ""b;
	parse_flags.only_one = "1"b;
	parse_flags.disallow_unproc = "1"b;
	parse_flags.disallow_meeting = "1"b;
	parse_flags.disallow_reverse = "1"b;
	parse_flags.disallow_idl = "1"b;
	parse_flags.dont_read = "1"b;
	parse_flags.disallow_cmsg = "1"b;
	parse_flags.disallow_by_chain = "1"b;
	call forum_trans_specs_$parse_specs (passport_info_ptr, 1, parse_flags_word, parse_arg, forum_idx, forum_dir,
	     forum_name, forum_trans_list_ptr);

	if forum_idx ^= 0 then do;
		temp_forum = "1"b;
		if forum_idx < 0 then
		     full_forum_name = rtrim (forum_name) || ".forum";
		else full_forum_name = rtrim (forum_name) || ".control";
	     end;
	else forum_idx = passport.forum_idx;
	reply_trans_idx = forum_trans_list.list (1).trans_num; /* get correct subject */

	free forum_trans_list;

	call process_transaction ();

	call clean_up_talk ();

	return;
%page;
forum_input_requests_$set_message:
     entry (P_ssu_ptr, P_passport_info_ptr);

	call setup_request (1);

	message_sw, auto_rql = "1"b;

	on cleanup call clean_up_talk ();

	do arg_idx = 1 to arg_count;
	     call parse_arg (arg_idx);
	end;

	call process_transaction ();
	call clean_up_talk ();

	return;
%page;
parse_arg:
     procedure (arg_idx);

	declare arg_idx		 fixed bin;

	call ssu_$arg_ptr (ssu_ptr, arg_idx, arg_ptr, arg_len);

	if substr (arg, 1, min (1, arg_len)) = "-"
	then if arg = "-brief" | arg = "-bf" then brief_switch = "1"b;
	     else if arg = "-auto_write" then auto_write = "1"b;
	     else if arg = "-no_auto_write" then auto_write = "0"b;
	     else if arg = "-fill" | arg = "-fi" then fill_switch = 1;
	     else if arg = "-force" | arg = "-fc" then force = "1"b;
	     else if arg = "-input_file" | arg = "-if" then call get_input_file (arg_idx);
	     else if arg = "-line_length" | arg = "-ll" then do;
		     if arg_idx = arg_count then
			call ssu_$abort_line (ssu_ptr, error_table_$noarg, "Following ^a.", arg);
		     arg_idx = arg_idx + 1;
		     call ssu_$arg_ptr (ssu_ptr, arg_idx, arg_ptr, arg_len);
		     line_length = cv_dec_check_ (arg, status);
		     if status ^= 0 then
			call ssu_$abort_line (ssu_ptr, error_table_$bad_conversion, "^a", arg);

		     if line_length < 40 then call ssu_$abort_line (ssu_ptr, 0, "Line length must be at least 40.");
		     fill_switch = 1;
		end;
	     else if arg = "-long" | arg = "-lg" then brief_switch = "0"b;
	     else if ^message_sw & (arg = "-meeting" | arg = "-mtg") then call get_forum (arg_idx);
	     else if arg = "-no_fill" | arg = "-nfi" then fill_switch = -1;
	     else if arg = "-no_force" | arg = "-nfc" then force = "0"b;
	     else if arg = "-no_request_loop" | arg = "-nrql" then do;
		     request_loop = "0"b;
		     auto_rql = "0"b;
		end;
	     else if arg = "-request_loop" | arg = "-rql" then do;
		     request_loop = "1"b;
		     auto_rql = "0"b;
		end;
	     else if ^message_sw & (arg = "-subject" | arg = "-sj") then call get_subject (arg_idx);
	     else if arg = "-terminal_input" | arg = "-ti" then terminal_switch = "1"b;

	     else call ssu_$abort_line (ssu_ptr, error_table_$badopt, """^a""", arg);

	else call ssu_$abort_line (ssu_ptr, 0, "Usage:  ^a ^[{trans_spec} ^]{-control_args}", whoami, reply_switch);

	return;

     end parse_arg;
%page;
get_input_file:
     procedure (arg_idx);

	declare arg_idx		 fixed bin;

	if user_file_ptr ^= null () then call ssu_$abort_line (ssu_ptr, 0, "Only one -input_file is permitted.");

	arg_idx = arg_idx + 1;
	call ssu_$arg_ptr (ssu_ptr, arg_idx, arg_ptr, arg_len);

	call expand_pathname_ (arg, dirname, entryname, status);
	if status ^= 0 then call ssu_$abort_line (ssu_ptr, status, "^a", arg);

	call hcs_$initiate_count (dirname, entryname, "", bit_count, 0, user_file_ptr, status);
	if user_file_ptr = null ()
	then call ssu_$abort_line (ssu_ptr, status, "Initiating ^a^[>^]^a.", dirname, dirname ^= ">", entryname);

	user_file_len = divide (bit_count, 9, 21, 0);
	if user_file_len <= 0 then
	     call ssu_$abort_line (ssu_ptr, error_table_$zero_length_seg, "^a^[>^]^a", dirname, dirname ^= ">", entryname);

	return;

     end get_input_file;
%page;
get_forum:
     procedure (arg_idx);

	declare arg_idx		 fixed bin;

	if temp_forum then call ssu_$abort_line (ssu_ptr, 0, "-meeting may only be specified once.");

	arg_idx = arg_idx + 1;
	call ssu_$arg_ptr (ssu_ptr, arg_idx, arg_ptr, arg_len);

	call forum_requests_$open_forum (arg, forum_idx, forum_dir, forum_name, status);
	if status ^= 0 then call ssu_$abort_line (ssu_ptr, status, "^a", arg);

	temp_forum = "1"b;
	if forum_idx < 0 then
	     full_forum_name = rtrim (forum_name) || ".forum";
	else full_forum_name = rtrim (forum_name) || ".control";
	return;

     end get_forum;
%page;
get_subject:
     procedure (arg_idx);

	declare arg_idx		 fixed bin;

	if subject_arg_ptr ^= null ()
	then call ssu_$abort_line (ssu_ptr, 0, "Only one ""-subject"" may be specified.");

	arg_idx = arg_idx + 1;
	call ssu_$arg_ptr (ssu_ptr, arg_idx, subject_arg_ptr, subject_arg_len);

	subject_arg_len = length (rtrim (subject_arg, WHITE_CHARS));
	idx = verify (subject_arg, WHITE_CHARS) - 1;
	if idx < 0 then idx = 0;
	subject_arg_len = subject_arg_len - idx;
	subject_arg_ptr = add_char_offset_ (subject_arg_ptr, idx);

	if subject_arg_len = 0 then call ssu_$abort_line (ssu_ptr, 0, "The subject field may not be blank.");

	return;

     end get_subject;

ask_subject:
     procedure ();

	no_chars_read, first_nonwhite_pos = 0;
	do while (no_chars_read <= first_nonwhite_pos);
	     call get_line ("Subject:  ");
	end;

	call allocate_transaction (subject, "", inhibit_auto_fill);

	return;

     end ask_subject;

add_to_subject:
     procedure ();

	if buffer_ptr = null () then do;
		buffer_len = 256;
		allocate buffer in (forum_area);
	     end;

	do while (subject_arg_len + arg_len + 1 > buffer_len);
	     call make_bigger_buffer (subject_arg_len);
	end;

	buffer = substr (buffer, 1, subject_arg_len) || arg || " ";
	subject_arg_len = subject_arg_len + arg_len + 1;

	return;
     end add_to_subject;
%page;
process_transaction:
     procedure ();

	if forum_idx = 0 then call ssu_$abort_line (ssu_ptr, forum_et_$no_forum);

	if user_file_ptr ^= null () & terminal_switch then
	     call ssu_$abort_line (ssu_ptr, error_table_$inconsistent, """-input_file"" and ""-terminal_input""");

	if user_file_ptr ^= null () then
	     if auto_rql then request_loop = "1"b;
	     else ;
	else auto_rql = "0"b;

	if fill_switch = 0 then
	     if user_file_ptr ^= null () | ^passport.talk_fill then fill_switch = -1;
	     else fill_switch = 1;

	if passport.unprocessed_trans_ptr ^= null ()
	then if user_file_ptr ^= null () & ^request_loop
	     then forum_user_trans_ptr = null ();	/* Don't affect unprocessed in this case. */
	     else if ^force then do;
		     query_info.version = query_info_version_5;
		     query_info.suppress_name_sw = ""b;
		     query_info.yes_or_no_sw = "1"b;
		     call command_query_ (addr (query_info), answer, whoami_really,
			"A previous unprocessed transaction has not been entered.^/Do you wish to overwrite it?");
		     if answer = "no" then call ssu_$abort_line (ssu_ptr);
		end;

	inhibit_auto_fill = (fill_switch < 0);

	if ^message_sw then do;
		if ^brief_switch & passport.print_message then do;
			call forum_$get_message (forum_idx, message, status);
			if status = 0 then call ioa_$nnl ("^a", message);
			passport.print_message = "0"b;
		     end;

		if reply_switch then call print_subject ("", inhibit_auto_fill);
		else if subject_arg_ptr ^= null () then call allocate_transaction (subject_arg, "", inhibit_auto_fill);
		else call ask_subject ();
	     end;
	else call allocate_transaction ((""), (""), inhibit_auto_fill);

	if user_file_ptr ^= null () then do;
		call allocate_transaction (forum_user_trans.subject, user_file, forum_user_trans.unfilled);
		if ^request_loop then call enter_the_transaction ();
		if auto_rql then
		     call ioa_ ("Use the ""enter"" request to enter the ^[message^;transaction^].", message_sw);
	     end;

	else call build_transaction ();

	return;

     end process_transaction;
%page;
print_subject:
     procedure (P_text, P_inhibit_auto_fill);

	declare P_text		 char (*),
	        P_inhibit_auto_fill	 bit (1) aligned,
	        p			 ptr;


/* If -subject given in "reply" request, then override default subject specification.  We needn't tell him, he knows.	*/

	if subject_arg_len > 0 then do;
		call allocate_transaction (subject_arg, P_text, P_inhibit_auto_fill);
		return;
	     end;

/* Now read out the forum to reply to so we can get its subject.  Transaction is always from current meeting*/

	call forum_trans_util_$read_trans (passport_info_ptr, passport.forum_idx, reply_trans_idx, p, status);
	if status ^= 0 then call ssu_$abort_line (ssu_ptr, status, "Transaction #^d.", reply_trans_idx);

/* If the unprocessed transaction has no associated forum_name, repair damage done by "subject -unthread".		*/

	if forum_name = "" then do;
		forum_dir = passport.forum_dir;
		full_forum_name = passport.forum_name;
		forum_name = no_suffix_name;
	     end;

/* If subject already begins with "Re: " then we shouldn't add another one.					*/

	if substr (p -> forum_user_trans.subject, 1, min (4, p -> forum_user_trans.subject_length)) = "Re: "
	then call allocate_transaction (p -> forum_user_trans.subject, P_text, P_inhibit_auto_fill);
	else call allocate_transaction ("Re: " || p -> forum_user_trans.subject, P_text, P_inhibit_auto_fill);

/* OK, now we can tell the user what the subject is. */

	call ioa_ ("Subject:  ^a", forum_user_trans.subject);

	return;

     end print_subject;
%page;
build_transaction:					/* Internal procedure to handle interactive 'talk' requests */
     procedure ();

	declare termination_type	 fixed bin;

	call get_temp_segment_ (whoami_really, temp_seg_ptr, status);
	if status ^= 0 then call ssu_$abort_line (ssu_ptr, status, "Getting temp segment.");

	call ipc_$cutoff (passport.public_channel, (0));

	call ioa_ ("^[Message^;Transaction^]:", message_sw);

	termination_type = add_lines ();

	if termination_type = ENTER_EDITOR then call enter_the_editor ();

	if termination_type = ENTER_REQUEST_LOOP & no_chars_read > first_nonwhite_pos + 2
	then do;
		first_nonwhite_pos = first_nonwhite_pos + 2;
		if substr (buffer, no_chars_read, 1) = NL then no_chars_read = no_chars_read - 1;
		if no_chars_read = first_nonwhite_pos then ;
		else if translate (substr (buffer, first_nonwhite_pos + 1, no_chars_read - first_nonwhite_pos),
		     LOWER_CASE, UPPER_CASE) = "nf"
		then forum_user_trans.unfilled = "1"b;
		else call ssu_$print_message (ssu_ptr, 0, "Characters following ""q"" ignored.");
	     end;

	call clean_up_talk ();

	if termination_type = NORMAL_TERMINATION & ^request_loop then call enter_the_transaction ();

	return;

     end build_transaction;
%page;
add_lines:
     procedure () returns (fixed bin);

	declare idx		 fixed bin (21),
	        quote_switch	 bit (1) aligned,
	        second_char		 char (1) based (addr (substr (buffer, first_nonwhite_pos + 2))),
	        third_char		 char (1) based (addr (substr (buffer, first_nonwhite_pos + 3)));

	quote_switch = "0"b;
	text_len = 0;
	do while ("1"b);
	     call get_line ("");
	     if no_chars_read = 2
	     then if substr (buffer, 1, 2) = "." || NL then return (NORMAL_TERMINATION);

	     first_nonwhite_pos = 0;
	     idx = index (substr (buffer, 1, no_chars_read), "\") - 1;
	     do while (idx >= 0);
		if idx > 0 then call add_to_trans (buffer, first_nonwhite_pos, idx);

		if quote_switch | no_chars_read - first_nonwhite_pos < 2 then
		     call add_to_trans (buffer, first_nonwhite_pos, 1);
		else if second_char = "c" | second_char = "C" then do;
			first_nonwhite_pos = first_nonwhite_pos + 2;
			quote_switch = "1"b;
		     end;
		else if second_char = "q" | second_char = "Q" then return (ENTER_REQUEST_LOOP);
		else if second_char = "f" | second_char = "F" then do;
			if idx ^= 0 then text_len = text_len - 1; /* In this case, the new line goes on the request */
			if no_chars_read - first_nonwhite_pos < 3 then return (ENTER_EDITOR);
			else if third_char ^= "q" & third_char ^= "Q" then return (ENTER_EDITOR);
			else do;
				first_nonwhite_pos = first_nonwhite_pos + 1;
				return (ENTER_REQUEST_LOOP);
			     end;
		     end;
		else call add_to_trans (buffer, first_nonwhite_pos, 1);

		idx = index (substr (buffer, first_nonwhite_pos + 1, no_chars_read - first_nonwhite_pos), "\") - 1;
	     end;

	     call add_to_trans (buffer, first_nonwhite_pos, no_chars_read - first_nonwhite_pos);
	end;

add_to_trans:
     procedure (buffer, pos, len);

	declare buffer		 char (*),
	        pos		 fixed bin (21),
	        len		 fixed bin (21);

	substr (temp_seg, text_len + 1, len) = substr (buffer, pos + 1, len);
	text_len = text_len + len;
	first_nonwhite_pos = first_nonwhite_pos + len;
	quote_switch = "0"b;

	return;
     end add_to_trans;

     end add_lines;
%page;
/* This procedure is used for the subject prompt and by the talk and reply requests to read in a transaction.
   It returns its results in the global variables buffer, no_chars_read, and first_nonwhite_pos.  It removes
   the trailing newline from the line, if any, and trims off trailing whitespace.  It optionally accepts the
   ".." escape to execute command lines while doing input.  The ".." must be the first white characters on the
   line.  The ".." is always accepted when the prompt field is nonblank; otherwise the "value" variable
   "forum.input_cp_escape" is consulted.								*/

get_line:
     procedure (prompt);

	declare prompt		 char (*),
	        newline		 bit (1) aligned;

	do while ("1"b);
	     call read_a_line ();

	     newline = "0"b;			/* Now hack off whitespace */
	     if substr (buffer, no_chars_read, 1) = NL
	     then do;
		     newline = "1"b;
		     no_chars_read = no_chars_read - 1;
		end;
	     no_chars_read = length (rtrim (substr (buffer, 1, no_chars_read), SPACE_AND_TAB));
	     if newline & prompt = ""
	     then do;
		     substr (buffer, no_chars_read + 1, 1) = NL;
		     no_chars_read = no_chars_read + 1;
		end;

	     first_nonwhite_pos = verify (substr (buffer, 1, no_chars_read), WHITE_CHARS) - 1;
	     if first_nonwhite_pos < 0
	     then do;
		     first_nonwhite_pos = no_chars_read;
		     return;			/* Line is blank.  Can't contain command processeor escape. */
		end;

	     if no_chars_read - first_nonwhite_pos < 2 then return;
	     if substr (buffer, first_nonwhite_pos + 1, 2) ^= ".." then return;

	     if prompt = ""
	     then if ^input_cp_escape_allowed () then return;

	     call cu_$cp (add_char_offset_ (addr (buffer), first_nonwhite_pos + 2),
		no_chars_read - first_nonwhite_pos - 2, (0));

	     if prompt = "" then call ioa_ ("Please continue entering your ^[reply^;transaction^].", reply_switch);
	end;
%page;
/* The following internal procedure of get_line actually reads an entire line into a buffer.  This is done as
   a separate level to compensate for the losing I/O system behavior when the input buffer is too small.		*/

read_a_line:
     procedure ();

	declare long_record		 bit (1) aligned,
	        no_new_chars_read	 fixed bin (21);

	if buffer_ptr = null ()
	then do;
		buffer_len = 256;
		allocate buffer in (forum_area);
	     end;

	long_record = "0"b;
	no_chars_read = 0;
	do while (long_record | no_chars_read = 0);

	     if prompt ^= "" & ^long_record then call ioa_$nnl (prompt);

	     call iox_$get_line (iox_$user_input, add_char_offset_ (buffer_ptr, no_chars_read),
		buffer_len - no_chars_read, no_new_chars_read, status);
	     no_chars_read = no_chars_read + no_new_chars_read;
	     if status = 0 then long_record = "0"b;
	     else if status ^= error_table_$long_record then call ssu_$abort_line (ssu_ptr, status);
	     else do;
		     call make_bigger_buffer (no_chars_read);
		     long_record = "1"b;
		end;
	end;

	return;

     end read_a_line;

     end get_line;

make_bigger_buffer:
     proc (copy_len);

	declare copy_len		 fixed bin (21);

	new_buffer_len = 2 * buffer_len;
	allocate new_buffer in (forum_area);
	substr (new_buffer, 1, copy_len) = substr (buffer, 1, copy_len);
	free buffer;
	buffer_ptr = new_buffer_ptr;
	buffer_len = new_buffer_len;
	new_buffer_ptr = null ();

	return;
     end make_bigger_buffer;
%page;
input_cp_escape_allowed:
     procedure () returns (bit (1) aligned);

	declare tf_string		 char (5);

	if inhibit_input_cp_escape then return ("0"b);

	call value_$get (null (), "11"b, rtrim (my_person_id) || ".forum.input_cp_escape", tf_string, status);
	if status ^= 0
	then if status ^= error_table_$oldnamerr
	     then return ("0"b);
	     else do;
		     call value_$get (null (), "11"b, "forum.input_cp_escape", tf_string, status);
		     if status ^= 0 then return ("0"b);
		end;

	tf_string = translate (tf_string, LOWER_CASE, UPPER_CASE);

	if tf_string = "true" then return ("1"b);
	if tf_string = "t" then return ("1"b);
	if tf_string = "on" then return ("1"b);
	if tf_string = "yes" then return ("1"b);
	if tf_string = "y" then return ("1"b);

	inhibit_input_cp_escape = "1"b;

	return ("0"b);

     end input_cp_escape_allowed;
%page;
enter_the_editor:
     procedure ();

	first_nonwhite_pos = first_nonwhite_pos + 2;	/* Skip the \f */

	call allocate_transaction (forum_user_trans.subject, temp_text, forum_user_trans.unfilled);
	text_len = -1;

	if standard_default_editor () then call call_qedx (subject);
	else call call_ted (add_char_offset_ (buffer_ptr, first_nonwhite_pos), no_chars_read - first_nonwhite_pos);

	return;
     end enter_the_editor;


standard_default_editor:
     procedure () returns (bit (1) aligned);

	declare editor		 char (4);

	on linkage_error go to USE_QEDX;

	call value_$get (null (), "11"b, rtrim (my_person_id) || ".forum.editor", editor, status);
	if status ^= 0 then
	     if status ^= error_table_$oldnamerr then return ("1"b);
	     else do;
		     call value_$get (null (), "11"b, "forum.editor", editor, status);
		     if status ^= 0 then return ("1"b);
		end;

	editor = translate (editor, LOWER_CASE, UPPER_CASE);

	if editor ^= "ted" then return ("1"b);

	if codeptr (ted_) ^= null () then return ("0"b);	/* Provoke linkage error if possible. */

USE_QEDX:
	return ("1"b);

     end standard_default_editor;
%page;
call_qedx:
     proc (request);

	declare request		 char (*);

	qi.header.version = QEDX_INFO_VERSION_1;
	qi.editor_name = whoami_really;
	string (qi.header.flags) = ""b;
	qi.header.query_if_modified = "1"b;

	qi.buffers (1).buffer_name = "0";
	qi.buffers (1).buffer_pathname = "<forum transaction>";
	qi.buffers (1).region_ptr = temp_seg_ptr;
	qi.buffers (1).region_max_lth = 4 * sys_info$max_seg_size;
	qi.buffers (1).region_initial_lth = forum_user_trans.text_length;
	string (qi.buffers (1).flags) = ""b;
	qi.buffers (1).read_write_region, qi.buffers (1).default_read_ok, qi.buffers (1).default_write_ok,
	     qi.buffers (1).locked_pathname = "1"b;
	qi.buffers (1).auto_write = auto_write;

	if request = "" then qi.n_buffers = 1;
	else do;
		qi.n_buffers = 2;
		qi.buffers (2).buffer_name = "exec";
		qi.buffers (2).buffer_pathname = "";
		qi.buffers (2).region_ptr = addr (request);
		qi.buffers (2).region_max_lth, qi.buffers (2).region_initial_lth = length (rtrim (request));
		string (qi.buffers (2).flags) = ""b;
		qi.buffers (2).read_write_region, qi.buffers (2).execute_buffer = "1"b;
	     end;

	call qedx_ (addr (qi), status);
	if status = error_table_$fatal_error then call ssu_$abort_line (ssu_ptr, 0);

	if qi.buffers (1).region_final_lth > 0 then text_len = qi.buffers (1).region_final_lth;
	else if forum_user_trans.text_length > 0 then
	     call ssu_$abort_line (ssu_ptr, 0, "Qedx returned a zero length buffer.  ^[Message^;Transaction^] not replaced.",
		message_sw);

	return;
     end call_qedx;
%page;
call_ted:
     proc (rq_ptr, rq_len);

	declare rq_ptr		 ptr,
	        rq_len		 fixed bin (21),
	        rq		 char (rq_len) based (rq_ptr),
	        path		 char (168),
	        request		 char (2 * 172 + rq_len);

	call hcs_$set_bc_seg (temp_seg_ptr, (9 * forum_user_trans.text_length), (0));
	call hcs_$fs_get_path_name (temp_seg_ptr, dirname, arg_idx, entryname, status);
	if status ^= 0 then call ssu_$abort_line (ssu_ptr, status);

	path = substr (dirname, 1, arg_idx) || ">" || rtrim (entryname);
	if ^auto_write then request = "r " || path || NL || "^r " || path || NL || rq;
	else request = rq;

	ted_info.tedname = rtrim (whoami_really);
	ted_info.version = ted_data_version_1;
	ted_info.ted_com_p = addr (request);
	ted_info.ted_com_l = length (rtrim (request));
	ted_info.ted_mode = 0;			/* NORMAL */
	ted_info.arg_list_p, ted_info.return_string_p = null ();
	ted_info.arg_list_1, ted_info.arg_list_n, ted_info.return_string_l = 0;
	ted_info.input_l, ted_info.output_l = 0;
	ted_info.temp_dir = "";

	if auto_write then do;
		ted_info.input_p, ted_info.output_p = temp_seg_ptr;
		ted_info.input_l = forum_user_trans.text_length;
	     end;
	else ted_info.input_p, ted_info.output_p = null ();

	call ted_ (addr (ted_info), status);
	if status ^= 0 then call ssu_$abort_line (ssu_ptr, status);

	if auto_write then text_len = ted_info.output_l;
	else do;
		call hcs_$status_mins (temp_seg_ptr, (0), bit_count, status);
		if status ^= 0 then call ssu_$abort_line (ssu_ptr, status, "Getting bit count.");

		text_len = divide (bit_count, 9, 21, 0);
	     end;

	if text_len = 0 then
	     if forum_user_trans.text_length > 0 then
		call ssu_$abort_line (ssu_ptr, 0, "Ted returned a zero length buffer.  ^[Message^;Transaction^] not replaced.",
		     message_sw);

	return;
     end call_ted;
%page;
forum_input_requests_$enter_request:
     entry (P_ssu_ptr, P_passport_info_ptr);

	call setup_request (-1);

	on cleanup call clean_up_talk ();

	do arg_idx = 1 to arg_count;
	     call ssu_$arg_ptr (ssu_ptr, arg_idx, arg_ptr, arg_len);

	     if arg = "-meeting" | arg = "-mtg"
	     then if reply_trans_idx = 0 | message_sw
		then call get_forum (arg_idx);
		else call ssu_$abort_line (ssu_ptr, 0, "Cannot use -meeting entering a reply or message.");
	     else if arg = "-brief" | arg = "-bf" then brief_switch = "1"b;
	     else if arg = "-long" | arg = "-lg" then brief_switch = "0"b;

	     else call ssu_$abort_line (ssu_ptr, error_table_$badopt, """^a""", arg);
	end;

	call enter_the_transaction ();

	call clean_up_talk ();

	return;
%page;
enter_the_transaction:
     procedure ();

	if forum_user_trans.text_length = 0
	then call ssu_$abort_line (ssu_ptr, 0, "Zero-length ^[message^;transaction^] - not entered.", message_sw);

	if forum_user_trans.type = message_type then do;
		call forum_$set_message (forum_idx, forum_user_trans.text, status);
		if status ^= 0 then call ssu_$abort_line (ssu_ptr, status, "Message not set.");
		free forum_user_trans;
		passport.unprocessed_trans_ptr = null ();
	     end;

	else do;
		if full_forum_name ^= passport.forum_name then do;
			call forum_$open_forum (forum_dir, full_forum_name, forum_idx, status);
			if status ^= 0 then
			     call ssu_$abort_line (ssu_ptr, status, "Opening ^a^[>^]^a.", forum_dir, forum_dir ^= ">",
				forum_name);
		     end;

		mask = ""b;
		on cleanup begin;
			if substr (mask, 36, 1) then
			     call hcs_$reset_ips_mask (mask, mask);
			call clean_up_talk ();
		     end;

		call hcs_$set_ips_mask (""b, mask);

/* TR20898 & 20899: If entering the trans in another mtg with the use of reply, trans shouldn't be chained;
   therefore, reply_trans_idx which is used previously to get correct subject, has to be set to zero. */

		if reply_switch & (passport.forum_idx ^= forum_idx)
		then reply_trans_idx = 0;

		call forum_$enter_trans (forum_idx, forum_user_trans.text, reply_trans_idx, forum_user_trans.subject,
		     forum_user_trans.unfilled, forum_user_trans.trans_no, status);
		if status ^= 0 then
		     if status = forum_et_$cant_notify then
			call ssu_$print_message (ssu_ptr, status, "The transaction was entered.");
		     else call ssu_$abort_line (ssu_ptr, status, "Transaction not entered.");

		if forum_user_trans_ptr = passport.unprocessed_trans_ptr then passport.unprocessed_trans_ptr = null ();

		call hcs_$reset_ips_mask (mask, mask);

		if ^brief_switch then do;
			trans_pic = forum_user_trans.trans_no;
			call ioa_ ("Transaction [^a] entered in ^a^[>^]^a meeting.", ltrim (trans_pic), forum_dir,
			     forum_dir ^= ">", forum_name);
		     end;

		if forum_idx = passport.forum_idx then forum_user_trans_ptr = null ();

		else do;
			free forum_user_trans;
			call forum_$close_forum (forum_idx, (0));
			forum_idx = passport.forum_idx;
			passport.unprocessed_forum_dir = "";
			passport.unprocessed_forum_name = "";
			passport.unprocessed_reply_trans = 0;
		     end;
	     end;

	return;

     end enter_the_transaction;
%page;
/* This routine allocates a transaction, possibly replacing in a race-free way the currently allocated transaction.	*/

allocate_transaction:
     procedure (P_subject, P_text, P_fill_trans);

	declare P_subject		 char (*),
	        P_text		 char (*),
	        P_fill_trans	 bit (1) aligned,
	        p			 ptr,
	        saved_forum_user_trans_ptr ptr;

	alloc_subject_length = length (rtrim (P_subject, WHITE_CHARS));
	alloc_text_length = length (rtrim (P_text, WHITE_CHARS));
	if alloc_text_length > 0 then alloc_text_length = alloc_text_length + 1;

	saved_forum_user_trans_ptr = forum_user_trans_ptr;
	p = null ();
	on cleanup
	     begin;
		if p ^= null ()
		then if p ^= forum_user_trans_ptr then free p -> forum_user_trans;
		     else if saved_forum_user_trans_ptr ^= null ()
		     then if saved_forum_user_trans_ptr = passport.unprocessed_trans_ptr
			then free passport.unprocessed_trans_ptr -> forum_user_trans;
			else free saved_forum_user_trans_ptr -> forum_user_trans;
	     end;

	allocate forum_user_trans in (forum_area) set (p);

	if message_sw then p -> forum_user_trans.type = message_type;
	else p -> forum_user_trans.type = user_trans_type;
	p -> forum_user_trans.person_id = my_person_id;
	p -> forum_user_trans.project_id = my_project_id;
	p -> forum_user_trans.next_trans_ptr, p -> forum_user_trans.prev_trans_ptr = null ();
	p -> forum_user_trans.unfilled = P_fill_trans;

	p -> forum_user_trans.subject = substr (P_subject, 1, alloc_subject_length);

	if alloc_text_length > 0
	then do;
		substr (p -> forum_user_trans.text, 1, alloc_text_length - 1) =
		     substr (P_text, 1, alloc_text_length - 1);
		substr (p -> forum_user_trans.text, alloc_text_length, 1) = NL;
	     end;

	forum_user_trans_ptr = p;

	text_len = -1;

	if saved_forum_user_trans_ptr ^= null ()
	then if saved_forum_user_trans_ptr = passport.unprocessed_trans_ptr
	     then free passport.unprocessed_trans_ptr -> forum_user_trans;
	     else free saved_forum_user_trans_ptr -> forum_user_trans;

	return;

     end allocate_transaction;
%page;
forum_input_requests_$subject_request:
     entry (P_ssu_ptr, P_passport_info_ptr);

	call setup_request (-1);
	if message_sw then call ssu_$abort_line (ssu_ptr, 0, "Messages do not have subjects.");

	if arg_count = 0 then
	     if return_arg_ptr ^= null () then do;
		     return_arg = requote_string_ (forum_user_trans.subject);
		     return;
		end;
	     else do;
		     call ioa_ ("Subject: ^a", forum_user_trans.subject);
		     return;
		end;

	if return_arg_ptr ^= null () then call ssu_$abort_line (ssu_ptr, 0, "Usage:  [sj]");

	on cleanup call clean_up_talk ();

	do arg_idx = 1 to arg_count;
	     call ssu_$arg_ptr (ssu_ptr, arg_idx, arg_ptr, arg_len);

	     if index (arg, "-") = 1 & ^subject_switch then
		if arg = "-default" then default_switch = "1"b;
		else if arg = "-subject" | arg = "-sj" then subject_switch = "1"b;
		else call ssu_$abort_line (ssu_ptr, error_table_$badopt, "^a", arg);
	     else call add_to_subject ();
	end;
	subject_arg_ptr = buffer_ptr;

	if default_switch & buffer_ptr ^= null () then
	     call ssu_$abort_line (ssu_ptr, error_table_$inconsistent, "You cannot give both a subject and -default.");

	if default_switch & reply_trans_idx = 0 then
	     call ssu_$abort_line (ssu_ptr, 0, "-default may only be used with replies.");

	if default_switch then do;
		if forum_idx = 0 then do;
			call forum_$open_forum (forum_dir, full_forum_name, forum_idx, status);
			if status ^= 0 then call ssu_$abort_line (ssu_ptr, status, "Opening ^a>^a", forum_dir, forum_name);
		     end;
		call print_subject (forum_user_trans.text, forum_user_trans.unfilled);
	     end;

	else if subject_arg_len > 0 then
	     call allocate_transaction (subject_arg, forum_user_trans.text, forum_user_trans.unfilled);
	else if subject_arg_ptr ^= null () then
	     call ssu_$abort_line (ssu_ptr, 0, "The subject field may not be blank.");

	call clean_up_talk ();

	return;
%page;
forum_input_requests_$fill_request:
     entry (P_ssu_ptr, P_passport_info_ptr);

	call setup_request (-1);

	do arg_idx = 1 to arg_count;
	     call ssu_$arg_ptr (ssu_ptr, arg_idx, arg_ptr, arg_len);

	     if index (arg, "-") = 1 then
		if arg = "-line_length" | arg = "-ll" then do;
			arg_idx = arg_idx + 1;
			call ssu_$arg_ptr (ssu_ptr, arg_idx, arg_ptr, arg_len);

			line_length = cv_dec_check_ (arg, status);
			if status ^= 0
			then call ssu_$abort_line (ssu_ptr, error_table_$bad_conversion, "^a", arg);
		     end;
		else if arg = "-on" then fill_switch = 1;
		else if arg = "-off" then fill_switch = -1;
		else call ssu_$abort_line (ssu_ptr, error_table_$badopt, "^a", arg);
	     else call ssu_$abort_line (ssu_ptr, 0, "Usage:  fill {-control_args}");
	end;

	if fill_switch ^= 0 then do;
		forum_user_trans.unfilled = (fill_switch < 0);
		return;
	     end;

	if line_length < 10 | line_length > 136 then
	     call ssu_$abort_line (ssu_ptr, 0, "Invalid line length.  ^d", line_length);

	on cleanup call clean_up_talk ();

	text_len = forum_user_trans.text_length;

	if forum_user_trans.unfilled then do;
		call fill_the_transaction (forum_user_trans.text);
		if status ^= 0 then call ssu_$abort_line (ssu_ptr, status, "Filling transaction.");
	     end;
	else call unpack_trans_to_temp_seg ();		/* clean up talk will fill it */

	call clean_up_talk ();
	return;
%page;
forum_input_requests_$apply_request:
     entry (P_ssu_ptr, P_passport_info_ptr);

	declare new_unpro_trans	 bit (1);

	call setup_request (2);

	if arg_count = 0 then
APPLY_USAGE:   call ssu_$abort_line (ssu_ptr, 0, "Usage:  apply {trans_specs} {-control_args} command_line");

	on cleanup call clean_up_apply ();
						/* TR20579 & 20810: apply can create unproc trans */
	parse_flags_word = DISALLOW_MTG | DEFAULT_TO_UNPROC | DISALLOW_CMSG | CALL_ON_BAD_ARGS | CREATE_UNPROC;
	arg_idx = 0;

	call forum_trans_specs_$parse_specs (passport_info_ptr, 1, parse_flags_word, apply_args, (0), "", "",
	     forum_trans_list_ptr);
	if arg_idx = 0 then call ssu_$abort_line (ssu_ptr, 0, "No command line given.");

	new_unpro_trans = "0"b;

/* TR20579: If no unproc trans and no trans_specs given, create new unproc trans */

	if (passport.unprocessed_trans_ptr = null () & forum_trans_list.size = 0) then do;
		forum_trans_list.size = 1;
		forum_trans_list.trans_num (1) = 0;	/* force to unproc instead of using current trans */
		new_unpro_trans = "1"b;
	     end;

	do idx = 1 to forum_trans_list.size;

	     if forum_trans_list.trans_num (idx) = 0 then do; /* if unproc */
		     forum_user_trans_ptr = passport.unprocessed_trans_ptr;
		     reply_trans_idx = passport.unprocessed_reply_trans;
		     if forum_user_trans_ptr ^= null () then
			message_sw = (forum_user_trans.type = message_type);
		     if passport.read_only then
			call ssu_$abort_line (ssu_ptr, forum_et_$read_only);
		end;
	     else do;
		     call forum_trans_util_$read_trans (passport_info_ptr, forum_idx, forum_trans_list.trans_num (idx),
			forum_user_trans_ptr, status);
		     if status ^= 0 then call ssu_$abort_line (ssu_ptr, status, "Reading transaction ^d.",
			     forum_trans_list.trans_num (idx));
		end;

	     call unpack_trans_to_temp_seg ();
	     call ssu_$apply_request_util (ssu_ptr, arg_idx, temp_seg_ptr, forum_user_trans.text_length, text_len);

	     if forum_trans_list.trans_num (idx) = 0 then do;
		     if text_len = 0 then call ssu_$abort_line (ssu_ptr, 0,
			     "Command returned a zero length file.  ^[Message^;Transaction^] not replaced.", message_sw);

		     if ^forum_user_trans.unfilled & fill_switch >= 0 then begin;

			     declare text		      char (text_len);
			     text = temp_text;
			     call fill_the_transaction (text);
			end;
		     if status = 0 then do;
			     call allocate_transaction (forum_user_trans.subject, temp_text, forum_user_trans.unfilled);
			     passport.unprocessed_trans_ptr = forum_user_trans_ptr;
			     passport.unprocessed_reply_trans = reply_trans_idx;
						/* TR20578: If new_unproc_trans, generate correct meeting_name */
			     if new_unpro_trans then do;
				     passport.unprocessed_forum_dir = forum_dir;
				     passport.unprocessed_forum_name = full_forum_name;
				     passport.unprocessed_name_len = length (rtrim (forum_name));
				     new_unpro_trans = "0"b;
				end;
			end;
		     text_len = -1;			/* prevent cleanup from doing it again */
		     forum_user_trans_ptr = null ();
		end;
	end;

	call clean_up_apply ();

	return;
%page;
apply_args:
     proc (P_arg_idx);

	declare P_arg_idx		 fixed bin;

	call ssu_$arg_ptr (ssu_ptr, P_arg_idx, arg_ptr, arg_len);
	if index (arg, "-") = 1 then
	     if arg = "-fill" | arg = "-fi" then fill_switch = 1;
	     else if arg = "-no_fill" | arg = "-nfi" then fill_switch = -1;
	     else call ssu_$abort_line (ssu_ptr, error_table_$badopt, "^a", arg);
	else do;
		arg_idx = P_arg_idx;
		P_arg_idx = arg_count + 1;
	     end;

	return;
     end apply_args;


clean_up_apply:
     proc ();

	if forum_trans_list_ptr ^= null () then free forum_trans_list;
	if passport.unprocessed_trans_ptr = forum_user_trans_ptr then call clean_up_talk ();

	if temp_seg_ptr ^= null () then call release_temp_segment_ (whoami_really, temp_seg_ptr, (0));

	return;
     end clean_up_apply;
%page;
forum_input_requests_$qedx_request:			/* Entry to enter qedx */
     entry (P_ssu_ptr, P_passport_info_ptr);

	call editor_request ("1"b);

	return;


forum_input_requests_$ted_request:
     entry (P_ssu_ptr, P_passport_info_ptr);

	on linkage_error
	     call ssu_$abort_line (ssu_ptr, 0, "The ""ted"" editor appears not to be available at this site.");

	if codeptr (ted_) = null () then return;	/* Provoke linkage_error if possible. */

	revert linkage_error;

	call editor_request ("0"b);
	return;

editor_request:
     proc (qedx_switch);

	declare qedx_switch		 bit (1) aligned;

	call setup_request (0);

	do arg_idx = 1 to arg_count;
	     call ssu_$arg_ptr (ssu_ptr, arg_idx, arg_ptr, arg_len);
	     if index (arg, "-") = 1 then
		if arg = "-fill" | arg = "-fi" then fill_switch = 1;
		else if arg = "-no_fill" | arg = "-nfi" then fill_switch = -1;
		else if arg = "-auto_write" then auto_write = "1"b;
		else if arg = "-no_auto_write" then auto_write = "0"b;
		else call ssu_$abort_line (ssu_ptr, error_table_$badopt, "^a", arg);
	     else call ssu_$abort_line (ssu_ptr, 0, "Usage:  ^[qx^;ted^] {-control_args}", qedx_switch);
	end;

	on cleanup call clean_up_talk ();

	call unpack_trans_to_temp_seg ();

	call ipc_$cutoff (passport.public_channel, (0));

	if qedx_switch then call call_qedx ("");
	else call call_ted (null (), (0));

	call clean_up_talk ();

	return;
     end editor_request;
%page;
unpack_trans_to_temp_seg:
     procedure ();

	if forum_user_trans_ptr = null () then do;
		if passport.forum_idx = 0 then
		     call ssu_$abort_line (ssu_ptr, forum_et_$no_forum);
		call ask_subject ();
	     end;

	if temp_seg_ptr = null () then do;
		call get_temp_segment_ (whoami_really, temp_seg_ptr, status);
		if status ^= 0 then call ssu_$abort_line (ssu_ptr, status, "Getting temp segment.");
	     end;

	substr (temp_seg, 1, forum_user_trans.text_length) = forum_user_trans.text;

	return;

     end unpack_trans_to_temp_seg;


fill_the_transaction:
     proc (transaction);

	declare transaction		 char (*);

	if temp_seg_ptr = null () then do;
		call get_temp_segment_ (whoami_really, temp_seg_ptr, status);
		if status ^= 0 then call ssu_$abort_line (ssu_ptr, status, "Getting temp segment.");
	     end;

	fdoc.version_number = format_document_version_2;
	fdoc.indentation = 0;
	fdoc.line_length = line_length;
	string (fdoc.switches) = ""b;
	fdoc.galley_sw, fdoc.literal_sw, fdoc.dont_break_indented_lines_sw = "1"b;
	fdoc.syllable_size = 3;			/* Make fdoc happy */
	call format_document_$string (transaction, temp_seg, text_len, addr (fdoc), status);
	if status = error_table_$recoverable_error then status = 0;

	return;
     end fill_the_transaction;
%page;
clean_up_talk:
     procedure ();

	declare p			 ptr;

	status = 0;
	if new_buffer_ptr ^= null () then free new_buffer;
	if buffer_ptr ^= null () then free buffer;

	if forum_trans_list_ptr ^= null () then free forum_trans_list;
	if forum_idx ^= passport.forum_idx then call forum_$close_forum (forum_idx, (0));

	if user_file_ptr ^= null () then do;
		p = user_file_ptr;
		user_file_ptr = null ();
		call hcs_$terminate_noname (p, (0));
		if forum_user_trans_ptr ^= null () then
		     if ^forum_user_trans.unfilled & fill_switch >= 0 then do;
			     call fill_the_transaction (forum_user_trans.text);
			     if status = 0 then
				call allocate_transaction (forum_user_trans.subject, temp_text, forum_user_trans.unfilled);
			     call release_temp_segment_ (whoami_really, temp_seg_ptr, (0));
			end;
	     end;

	if temp_seg_ptr ^= null () then do;
		if text_len >= 0 then do;
			if ^forum_user_trans.unfilled & fill_switch >= 0 then begin;

				declare text		 char (text_len);
				text = temp_text;
				call fill_the_transaction (text);
			     end;
			if status = 0 then
			     call allocate_transaction (forum_user_trans.subject, temp_text, forum_user_trans.unfilled);
		     end;
		call release_temp_segment_ (whoami_really, temp_seg_ptr, (0));
	     end;

	if forum_user_trans_ptr ^= null then do;
		if passport.unprocessed_trans_ptr ^= forum_user_trans_ptr & passport.unprocessed_trans_ptr ^= null () then
		     free passport.unprocessed_trans_ptr -> forum_user_trans;

		passport.unprocessed_trans_ptr = forum_user_trans_ptr;
		passport.unprocessed_reply_trans = reply_trans_idx;
		passport.unprocessed_forum_dir = forum_dir;
		passport.unprocessed_forum_name = full_forum_name;
		passport.unprocessed_name_len = length (rtrim (forum_name));
	     end;

	call ipc_$reconnect (passport.public_channel, (0));

	return;

     end clean_up_talk;
%page;
setup_request:
     procedure (P_new_trans_switch);

	declare P_new_trans_switch	 fixed bin;

	ssu_ptr = P_ssu_ptr;
	passport_info_ptr = P_passport_info_ptr;

	whoami = ssu_$get_request_name (ssu_ptr);
	whoami_really = ssu_$get_subsystem_and_request_name (ssu_ptr);
	buffer_ptr, forum_trans_list_ptr, new_buffer_ptr, subject_arg_ptr, temp_seg_ptr, user_file_ptr = null ();
	brief_switch, default_switch, force, inhibit_auto_fill, inhibit_input_cp_escape, request_loop = "0"b;
	fill_switch, subject_arg_len = 0;
	if passport.input_fill_width ^= 0 then line_length = passport.input_fill_width;
	else line_length = 72;
	forum_idx = passport.forum_idx;
	text_len = -1;
	message_sw, subject_switch, temp_forum, terminal_switch = "0"b;
	auto_write = passport.auto_write;

	if P_new_trans_switch = 1 & passport.read_only then
	     call ssu_$abort_line (ssu_ptr, forum_et_$read_only);

	if P_new_trans_switch > 0 | (passport.unprocessed_trans_ptr = null () & P_new_trans_switch = 0) then do;
		forum_user_trans_ptr = null ();
		if passport.forum_idx = 0 then forum_dir, full_forum_name, forum_name = "";
		else do;
			forum_dir = passport.forum_dir;
			full_forum_name = passport.forum_name;
			forum_name = no_suffix_name;
		     end;
		reply_trans_idx = 0;
	     end;

	else if passport.unprocessed_trans_ptr = null () then
	     call ssu_$abort_line (ssu_ptr, forum_et_$no_unprocessed);

	else do;
		forum_user_trans_ptr = passport.unprocessed_trans_ptr;
		forum_dir = passport.unprocessed_forum_dir;
		full_forum_name = passport.unprocessed_forum_name;
		forum_name = substr (passport.unprocessed_forum_name, 1, passport.unprocessed_name_len);
		reply_trans_idx = passport.unprocessed_reply_trans;
		message_sw = (forum_user_trans.type = message_type);
	     end;

	if ^static_initialized then do;
		call user_info_$whoami (my_person_id, my_project_id, (""));
		static_initialized = "1"b;
	     end;

	call ssu_$return_arg (ssu_ptr, arg_count, ("0"b), return_arg_ptr, return_arg_len);

	return;

     end setup_request;

     end forum_input_requests_$talk_request;
