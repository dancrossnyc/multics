/****^  ***************************************************************
        *                                                             *
        * Copyright, (C) BULL HN Information Systems Inc., 1992       *
        *                                                             *
        * Copyright, (C) Massachusetts Institute of Technology, 1986  *
        *                                                             *
        * Copyright (c) 1982 by Massachusetts Institute of Technology *
        *                                                             *
        *************************************************************** */



/****^  HISTORY COMMENTS:
  1) change(1986-07-29,Pattin), approve(1986-07-29,MCR7354),
     audit(1986-08-07,Margolin), install(1986-08-16,MR12.0-1128):
     Added the bref transactiobn specifier.  Reorganized program to optimize
     performance, specifically by minimizing gate calls.  Added expand_list
     instead of allocating massive trans_list structure.   Fixed bug where
     arg_map was not being freed.  Remember deleted status in trans_list
     structure.   Fixed handling of \c in regexps.
  2) change(1991-08-29,Huen), approve(1991-08-29,MCR8248),
     audit(1992-01-08,Zimmerman), install(1992-04-27,MR12.5-1014):
     phx21375: Set the initial value of current trans correctly.
     phx21376: Fxi the "delete" request to handle the current trans correctly
     so that the behavour will be consistent with the rdm "dl" request.
     phx21377: Same trans returned by the "c" request and "c" used as an arg.
  3) change(1991-09-05,Huen), approve(1991-09-05,MCR8249),
     audit(1992-01-08,Zimmerman), install(1992-04-27,MR12.5-1014):
     phx20579: Set inhibit_error if unproc trans is selected.
  4) change(1991-09-05,Huen), approve(1991-09-05,MCR8250),
     audit(1992-01-08,Zimmerman), install(1992-04-27,MR12.5-1014):
     phx20810: Do not output error if inhibit_error is used with the "list"
     active request.
  5) change(1992-09-10,Zimmerman), approve(1992-09-10,MCR8258),
     audit(1992-09-22,WAAnderson), install(1992-09-28,MR12.5-1020):
     Problem with current being set to deleted txn., or being set to -1.
  6) change(2016-01-15,Swenson), approve(2016-01-15,MCR10003):
     Fix to support 4-character time zone abbreviations.
                                                   END HISTORY COMMENTS */


/* format: style3,ifthen,ifthendo,ifthenstmt,^indnoniterdo,^inditerdo,idind30 */

forum_trans_specs_$parse_specs:
     procedure (P_passport_info_ptr, P_first_arg, P_parse_flags, P_ctl_arg_entry, P_forum_idx, P_forum_dir, P_forum_name,
	P_forum_trans_list_ptr);

/* Subroutine to parse and process transaction specifiers for forum
   Also includes requests to return transaction numbers for all specifiers */

/* original coding  06/17/81 Jay Pattin
   modified for ssu_ 08/22/81 Jay Pattin
   added chairman_message trans spec 05/14/82 Jay Pattin
   added highest (last_seen) trans spec 10/20/82 Jay Pattin
   changes for reading deleted transactions, added -idl, -odl, -ondl 10/23/82 Jay Pattin
   added seen/unseen and friends 1/8/83 Jay Pattin
   made spec requests call parse 6/29/83 Jay Pattin
   Modified 12/21/83 by Jeffrey I. Schiller to fix first_unseen to skip
   over expunged transactions.
   Speed improvements 11/30/85 Jay Pattin
   Added bref 12/22/85 Jay Pattin  */

dcl	(
	P_forum_idx		fixed bin,
	P_forum_dir		char (*),
	P_forum_name		char (*),
	P_forum_trans_list_ptr	pointer,
	P_first_arg		fixed bin,
	P_parse_flags		bit (36) aligned,
	P_ctl_arg_entry		entry (fixed bin) variable,
	P_passport_info_ptr		pointer,
	P_ssu_ptr			pointer
	)			parameter;

declare	value			fixed bin,	/* value of expression */
	(this_val, state, last_val)	fixed bin,
	(by_chain, list, no_current, reverse_sw, idl_given, temp_forum, initial, reset_current, expunged, inhibit_error,
	have_limits)		bit (1) aligned init ("0"b),
	(active_function, in_expr, cache, deleted, in_range)
				bit (1) aligned,
	(empty, blank, only_unproc)	bit (1) init ("1"b),
	first_char		char (1),
	me			char (22),
	arg_len			fixed bin (21),
	arg_ptr			ptr,
	argmap_ptr		ptr,
	alloc_argmap_size		fixed bin,
	bit_map_len		fixed bin,
	bit_map_ptr		ptr,
	code			fixed bin (35),
	forum_idx			fixed bin,
	forum_dir			char (168),
	forum_name		char (32),
	message			char (256),
	request_name		char (32),
	ret_len			fixed bin (21),
	ret_ptr			ptr,
	ret_string		char (80) varying init (""),
	ssu_ptr			ptr,
	(current, nref, pref, first, last, last_seen, last_tri, last_sent)
				fixed bin,
	(idx, jdx, kdx, tidx, sign, select_type, type, arg_count)
				fixed bin,
	match_code		fixed bin (35);

declare	arg			char (arg_len) based (arg_ptr),
	bit_map			bit (bit_map_len) aligned based (bit_map_ptr);
declare	ret_val			char (ret_len) varying based (ret_ptr);
declare	argmap			bit (alloc_argmap_size) based (argmap_ptr);
						/* on if we look at it on pass 2 */

declare	(
	DIGITS			char (10) init ("1234567890"),
	LETTERS			char (53) init ("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"),
	UC_ALPHA			char (26) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
	LC_ALPHA			char (26) init ("abcdefghijklmnopqrstuvwxyz")
	)			internal static options (constant);

declare	keywords			(55) char (16) internal static options (constant)
				init ("first", "f", "last", "l", "previous", "prev", "p", "next", "n", "current",
				"c", "firstref", "fref", "lastref", "lref", "previousref", "pref", "nextref",
				"nref", "allref", "aref", "all", "a", "new", "unprocessed", "unproc", "unp", "u",
				"restref", "rref", "chairman_message", "cmsg", "all_seen", "seen", "first_seen",
				"fs", "next_seen", "ns", "previous_seen", "ps", "last_seen", "ls", "highest",
				"all_unseen", "unseen", "first_unseen", "fu", "next_unseen", "nu",
				"previous_unseen", "pu", "last_unseen", "lu", "beforeref", "bref");

declare	key_val			(55) fixed bin
				init (1, 1, 2, 2, 3, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12,
				13, 13, 13, 13, 14, 14, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 21, 22,
				22, 23, 23, 24, 24, 25, 25, 26, 26, 15, 15);

declare	(
	FIRST			init (1),
	LAST			init (2),
	PREVIOUS			init (3),
	NEXT			init (4),
	CURRENT			init (5),
	FREF			init (6),
	LREF			init (7),
	PREF			init (8),
	NREF			init (9),
	AREF			init (10),
	ALL			init (11),
	NEW			init (12),
	UNPROC			init (13),
	RREF			init (14),
	BREF			init (15),
	CMSG			init (16),
	SEEN			init (17),
	FIRST_SEEN		init (18),
	NEXT_SEEN			init (19),
	PREV_SEEN			init (20),
	LAST_SEEN			init (21),
	UNSEEN			init (22),
	FIRST_UNSEEN		init (23),
	NEXT_UNSEEN		init (24),
	PREV_UNSEEN		init (25),
	LAST_UNSEEN		init (26)
	)			fixed bin internal static options (constant);

declare	(
	NEED_CURRENT		init ("00100111110001100011000110"b),
	NEED_LIMITS		init ("11011000001100001111111111"b),
	MULTIPLE			init ("00000000011101101000010000"b),
	UNPROC_OK			init ("00000111010001100000000000"b)
	)			bit (26) static options (constant);

declare	(
	ANYTHING			init (0),
	MUST_BE_ARITH		init (1),
	MUST_BE_REGEXP		init (2),
	MUST_BE_USERID		init (3)
	)			fixed bin internal static options (constant);

declare	(
	AFTER			init (1),
	BEFORE			init (2),
	ON_OR_BEFORE		init (3),
	DATE			init (4)
	)			fixed bin static options (constant);

declare	THERE_IS_NO		char (32) static options (constant) init ("There is no ^a transaction.");

declare	1 trans_specs		aligned,
	  2 flags			aligned,
	    3 selected		bit (1) unaligned,	/* on if any transactions selected */
	    3 regexp_given		bit (1) unaligned,
	    3 no_match_sj		bit (1) unaligned,	/* don't match regexp against subject */
	    3 no_match_text		bit (1) unaligned,	/* ditto for text */
	    3 id_given		bit (1) unaligned,
	    3 date_given		bit (1) unaligned,
	    3 pad			bit (30) unaligned,
	  2 low_date		fixed bin (71),
	  2 high_date		fixed bin (71),
	  2 regexp_len		fixed bin (21),
	  2 regexp		char (256),	/* select by regexp matching */
	  2 person_id		char (22);	/* Used for selecting by person_id */

declare	saved_regexp		char (256) varying internal static init ("");

declare	(fixed, substr, verify, translate, null, string, length, min, hbound, index, after, before, char, ltrim, rtrim,
	unspec, max, addr, reverse)	builtin;
declare	(area, cleanup)		condition;

declare	convert_date_to_binary_	entry (char (*), fixed bin (71), fixed bin (35)),
	decode_clock_value_		entry (fixed bin (71), fixed bin, fixed bin, fixed bin, fixed bin (71), fixed bin,
				char (4)),
	encode_clock_value_		entry (fixed bin, fixed bin, fixed bin, fixed bin, fixed bin, fixed bin,
				fixed bin (71), fixed bin, char (4), fixed bin (71), fixed bin (35)),
	ioa_			entry () options (variable),
	user_info_$whoami		entry (char (*), char (*), char (*)),
	search_file_$silent		entry (ptr, fixed bin (21), fixed bin (21), ptr, fixed bin (21), fixed bin (21),
				fixed bin (21), fixed bin (21), fixed bin (35)),
	forum_$forum_limits		entry (fixed bin, fixed bin, fixed bin, fixed bin, fixed bin, fixed bin,
				bit (36) aligned, fixed bin (35)),
	forum_$get_transaction_map_idx
				entry (fixed bin, char (*), bit (*) aligned, fixed bin (35)),
	forum_$next_transaction	entry (fixed bin, fixed bin, fixed bin, fixed bin (35)),
	forum_$previous_transaction	entry (fixed bin, fixed bin, fixed bin, fixed bin (35)),
	forum_$trans_ref_info	entry (fixed bin, fixed bin, fixed bin, fixed bin, fixed bin, bit (1) aligned,
				fixed bin (35)),
	forum_$trans_time_info	entry (fixed bin, fixed bin (71), fixed bin (71), fixed bin, fixed bin,
				fixed bin (35)),
	forum_$check_user		entry (fixed bin, char (*), fixed bin, fixed bin (35)),
	forum_$close_forum		entry (fixed bin, fixed bin (35)),
	forum_$get_message		entry (fixed bin, char (*), fixed bin (35)),
	forum_requests_$open_forum	entry (char (*), fixed bin, char (*), char (*), fixed bin (35)),
	forum_trans_util_$clear_cache entry (ptr),
	forum_trans_util_$read_trans	entry (ptr, fixed bin, fixed bin, ptr, fixed bin (35)),
	forum_trans_util_$reverse	entry (ptr, ptr),
	forum_trans_util_$sort_by_chain
				entry (ptr, fixed bin, ptr, fixed bin),
	ssu_$abort_line		entry options (variable),
	ssu_$arg_ptr		entry (ptr, fixed bin, ptr, fixed bin (21)),
	ssu_$get_request_name	entry (ptr) returns (char (32)),
	ssu_$print_message		entry options (variable),
	ssu_$return_arg		entry (ptr, fixed bin, bit (1) aligned, ptr, fixed bin (21));

declare	(
	error_table_$badopt,
	error_table_$inconsistent,
	error_table_$noarg,
	error_table_$nomatch,
	forum_et_$bad_trans_spec,
	forum_et_$no_forum,
	forum_et_$no_current,
	forum_et_$old_format,
	forum_et_$missing_spec,
	forum_et_$too_many_trans,
	forum_et_$too_many_regexps,
	forum_et_$too_many_personids,
	forum_et_$key_not_allowed,
	forum_et_$no_trans_for_user,
	forum_et_$no_transactions,
	forum_et_$trans_deleted,
	forum_et_$trans_reaped,
	forum_et_$trans_not_deleted,
	forum_et_$unproc_not_allowed,
	forum_et_$null_range_spec,
	forum_et_$invalid_trans_idx
	)			fixed bin (35) external;
%page;
%include forum_trans_list;
%page;
%include forum_user_trans;
%page;
%include forum_passport;
%page;
	passport_info_ptr = P_passport_info_ptr;
	ssu_ptr = passport.ssu_ptr;

	P_forum_idx = 0;
	parse_flags_word = P_parse_flags;
	forum_idx = passport.forum_idx;		/* assume current forum */
	current = passport.current_trans;
	if current = 0 then no_current = "1"b;

	argmap_ptr, bit_map_ptr, forum_trans_list_ptr = null ();
	code, last_tri = 0;
	cache = "1"b;				/* Use the cache (we are in current forum) */

	on cleanup call cleanup_handler;

	string (trans_specs.flags) = ""b;
	trans_specs.low_date, trans_specs.high_date = 0;
	trans_specs.regexp = "";
	trans_specs.regexp_len = 0;
	trans_specs.person_id = "";

	if parse_flags.must_be_deleted then select_type = ONLY_DELETED;
	else if parse_flags.allow_deleted then select_type = INCLUDE_DELETED;
	else select_type = ONLY_UNDELETED;

	call ssu_$return_arg (ssu_ptr, arg_count, active_function, (null ()), (0));

	alloc_argmap_size = arg_count;
	allocate argmap in (forum_area);		/* tells if args are processed on pass 1 */

	state = ANYTHING;
	do idx = P_first_arg to arg_count;		/* Pass 1, ctl args, ids, regexps */
	     call ssu_$arg_ptr (ssu_ptr, idx, arg_ptr, arg_len);
	     if substr (arg, 1, 1) = "-" & index (DIGITS, substr (arg, 2, 1)) = 0 & state = ANYTHING then do;
						/* control arg */
		if ^parse_flags.disallow_meeting & (arg = "-meeting" | arg = "-mtg") then do;
		     idx = idx + 1;
		     if idx > arg_count then
NOARG:
			call ssu_$abort_line (ssu_ptr, error_table_$noarg, "Following ""^a"".", arg);
		     call ssu_$arg_ptr (ssu_ptr, idx, arg_ptr, arg_len);
		     call forum_requests_$open_forum (arg, forum_idx, forum_dir, forum_name, code);
		     if code ^= 0 then call ssu_$abort_line (ssu_ptr, code, "Opening meeting ""^a"".", arg);

		     temp_forum = "1"b;
		     if forum_idx ^= passport.forum_idx then cache = "0"b;
		end;

		else if ^parse_flags.disallow_idl & (arg = "-include_deleted" | arg = "-idl") then
		     select_type = INCLUDE_DELETED;
		else if ^parse_flags.disallow_idl & (arg = "-only_deleted" | arg = "-odl") then
		     select_type = ONLY_DELETED;
		else if ^parse_flags.disallow_idl & (arg = "-only_non_deleted" | arg = "-ondl") then
		     select_type = ONLY_UNDELETED;

		else if parse_flags.allow_inhibit_error & (arg = "-inhibit_error" | arg = "-ihe") then
		     inhibit_error = "1"b;
		else if parse_flags.allow_inhibit_error & (arg = "-no_inhibit_error" | arg = "-nihe") then
		     inhibit_error = "0"b;
		else if ^parse_flags.disallow_initial & arg = "-initial" then initial = "1"b;
		else if ^parse_flags.disallow_by_chain & arg = "-by_chain" then by_chain = "1"b;
		else if ^parse_flags.disallow_reverse & (arg = "-reverse" | arg = "-rv") then reverse_sw = "1"b;
		else if ^parse_flags.dont_read then do;
		     if arg = "-after" | arg = "-af" then call get_date (AFTER, "1"b);
		     else if arg = "-after_time" | arg = "-aft" then call get_date (AFTER, "0"b);
		     else if arg = "-before" | arg = "-be" then call get_date (BEFORE, "1"b);
		     else if arg = "-before_time" | arg = "-bet" then call get_date (BEFORE, "0"b);
		     else if arg = "-between" | arg = "-bt" then do;
			call get_date (AFTER, "1"b);
			call get_date (ON_OR_BEFORE, "1"b);
		     end;
		     else if arg = "-between_time" | arg = "-btt" then do;
			call get_date (AFTER, "0"b);
			call get_date (BEFORE, "0"b);
		     end;
		     else if arg = "-date" | arg = "-dt" then call get_date (DATE, "1"b);
		     else if arg = "-from" | arg = "-fm" then do;
			if idx = arg_count then goto NOARG;
			state = MUST_BE_USERID;
		     end;
		     else if arg = "-subject" | arg = "-sj" then do;
			if idx = arg_count then goto NOARG;
			state = MUST_BE_REGEXP;
			trans_specs.no_match_text = "1"b;
		     end;
		     else if arg = "-text" | arg = "-tx" then do;
			if idx = arg_count then goto NOARG;
			state = MUST_BE_REGEXP;
			trans_specs.no_match_sj = "1"b;
		     end;
		     else call P_ctl_arg_entry (idx);
		end;
		else call P_ctl_arg_entry (idx);
	     end;					/* control arg */
	     else do;
		empty = "0"b;
		substr (argmap, idx, 1) = "1"b;	/* process it on pass 2 */
		if index (arg, ":") = 0 | index (arg, "/") ^= 0 then
		     call pass1 (arg);		/* range not given */
		else do;
		     only_unproc = "0"b;
		end;
		state = ANYTHING;
	     end;
	end;					/* pass1 */

	if reverse_sw & by_chain then
	     call ssu_$abort_line (ssu_ptr, error_table_$inconsistent, """-reverse"" and ""-by_chain""");
	if trans_specs.high_date < trans_specs.low_date & trans_specs.high_date ^= 0 then
	     call ssu_$abort_line (ssu_ptr, forum_et_$bad_trans_spec, "Invalid range in date specification.");

/* TR20810: If inhibit_error is set, do not output error */
	if last_sent = 0 & trans_specs.id_given & ^inhibit_error then
	     call ssu_$abort_line (ssu_ptr, forum_et_$no_trans_for_user, "^a", arg);
	if ^parse_flags.default_to_unproc then
	     only_unproc = only_unproc & ^empty;	/* if something given, then isn't only unproc */
	else only_unproc = only_unproc & (passport.unprocessed_trans_ptr ^= null ());

	if ^only_unproc & forum_idx = 0 then call ssu_$abort_line (ssu_ptr, forum_et_$no_forum);
	if only_unproc then last = 0;			/* unproc doesn't require a forum */
	else if temp_forum then call get_limits ();

	alloc_trans_list_size = 100;

RETRY_ATL:
	on area
	     begin;
		call forum_trans_util_$clear_cache (passport_info_ptr);
		goto RETRY_ATL;
	     end;

	allocate forum_trans_list in (forum_area);
	forum_trans_list.max_size = 100;
	forum_trans_list.size, forum_trans_list.max_personid_len = 0;

	revert area;

	do idx = P_first_arg to arg_count;		/* pass 2 */
	     if substr (argmap, idx, 1) then do;
		call ssu_$arg_ptr (ssu_ptr, idx, arg_ptr, arg_len);
		in_range = "0"b;
		jdx = index (arg, ":");
		if jdx ^= 0 then do;
		     if jdx = 1 | jdx = arg_len then
			call ssu_$abort_line (ssu_ptr, 0, "Null value before or after a "":"". ^a", arg);
		     in_range = "1"b;
		     call pass2 (before (arg, ":"));
		     last_val = value;
		     call pass2 (after (arg, ":"));
		     call do_range ();		/* add transactions in the range */
		end;
		else call pass2 (arg);
	     end;
	end;

	if ^trans_specs.selected then do;		/* noone home */
	     if ^blank then
		if ^inhibit_error then
		     call ssu_$abort_line (ssu_ptr, forum_et_$no_transactions);
		else ;
	     else if trans_specs.regexp_given | trans_specs.id_given | trans_specs.date_given then call get_all ();
	     else if parse_flags.non_null then call ssu_$abort_line (ssu_ptr, forum_et_$missing_spec);
	     else if parse_flags.default_to_none then inhibit_error = "1"b;
	     else if parse_flags.default_to_all then call get_all ();
						/* TR20810, 20579: Set inhibit_error if unproc trans is selected */
	     else if parse_flags.default_to_unproc
		& (parse_flags.create_unproc | passport.unprocessed_trans_ptr ^= null ()) then do;
		if passport.unprocessed_trans_ptr = null () then
		     inhibit_error = "1"b;
		else do;
		     deleted = "0"b;
		     kdx = UNPROC;			/* Yet another kludge */
		     call allocate_num (0);
		end;
	     end;
	     else do;
		if current > 0 then this_val = current; /* TR21375-6: Try setting current first. */
		else if current = 0 then do;
		     call set_current ();		/* TR21377: Same trans returned by "c" request and "c" used as an arg */
		     passport.current_trans = this_val;
		     current = this_val;
		end;
		if current = 0 then call ssu_$abort_line (ssu_ptr, forum_et_$no_current);
		call get_tri (current, "0"b, 0, (0));
		if ^initial | pref = 0 then call allocate_num (current);
	     end;
	end;
	if bit_map_ptr ^= null () then free bit_map;
	if argmap_ptr ^= null () then free argmap;

	if ^trans_specs.selected & ^inhibit_error then	/* still noone home */
	     call ssu_$abort_line (ssu_ptr, forum_et_$no_transactions);

	if forum_trans_list.size > 1 then
	     if reverse_sw then call forum_trans_util_$reverse (passport_info_ptr, forum_trans_list_ptr);
	     else if by_chain then
		call forum_trans_util_$sort_by_chain (passport_info_ptr, forum_idx, forum_trans_list_ptr, select_type)
		     ;

	if temp_forum then do;			/* if -meeting was given, tell our caller */
	     P_forum_idx = forum_idx;
	     P_forum_name = forum_name;
	     P_forum_dir = forum_dir;
	end;
	P_forum_trans_list_ptr = forum_trans_list_ptr;
	return;
%page;
/* Now the entries that return values for all the keywords */
first_request:
     entry (P_ssu_ptr, P_passport_info_ptr);

	call common (FIRST, "0"b);

last_request:
     entry (P_ssu_ptr, P_passport_info_ptr);

	call common (LAST, "0"b);

previous_request:
     entry (P_ssu_ptr, P_passport_info_ptr);

	call common (PREVIOUS, "1"b);

next_request:
     entry (P_ssu_ptr, P_passport_info_ptr);

	call common (NEXT, "1"b);

current_request:
     entry (P_ssu_ptr, P_passport_info_ptr);

	call common (CURRENT, "0"b);

fref_request:
     entry (P_ssu_ptr, P_passport_info_ptr);

	call common (FREF, "1"b);

lref_request:
     entry (P_ssu_ptr, P_passport_info_ptr);

	call common (LREF, "1"b);

pref_request:
     entry (P_ssu_ptr, P_passport_info_ptr);

	call common (PREF, "1"b);

nref_request:
     entry (P_ssu_ptr, P_passport_info_ptr);

	call common (NREF, "1"b);

aref_request:
     entry (P_ssu_ptr, P_passport_info_ptr);

	call common (AREF, "1"b);

rref_request:
     entry (P_ssu_ptr, P_passport_info_ptr);

	call common (RREF, "1"b);

bref_request:
     entry (P_ssu_ptr, P_passport_info_ptr);

	call common (BREF, "1"b);

new_request:
     entry (P_ssu_ptr, P_passport_info_ptr);

	call common (NEW, "0"b);

all_request:
     entry (P_ssu_ptr, P_passport_info_ptr);

	call common (ALL, "0"b);

seen_request:
     entry (P_ssu_ptr, P_passport_info_ptr);

	call common (SEEN, "0"b);

unseen_request:
     entry (P_ssu_ptr, P_passport_info_ptr);

	call common (UNSEEN, "0"b);

first_seen_request:
     entry (P_ssu_ptr, P_passport_info_ptr);

	call common (FIRST_SEEN, "0"b);

first_unseen_request:
     entry (P_ssu_ptr, P_passport_info_ptr);

	call common (FIRST_UNSEEN, "0"b);

next_seen_request:
     entry (P_ssu_ptr, P_passport_info_ptr);

	call common (NEXT_SEEN, "1"b);

next_unseen_request:
     entry (P_ssu_ptr, P_passport_info_ptr);

	call common (NEXT_UNSEEN, "1"b);

prev_seen_request:
     entry (P_ssu_ptr, P_passport_info_ptr);

	call common (PREV_SEEN, "1"b);

prev_unseen_request:
     entry (P_ssu_ptr, P_passport_info_ptr);

	call common (PREV_UNSEEN, "1"b);

last_seen_request:
     entry (P_ssu_ptr, P_passport_info_ptr);

	call common (LAST_SEEN, "0"b);

last_unseen_request:
     entry (P_ssu_ptr, P_passport_info_ptr);

	call common (LAST_UNSEEN, "0"b);

MAIN_RETURN:
	return;

common:
     proc (P_type, allow_spec);

declare	P_type			fixed bin,
	allow_spec		bit (1) aligned;

	ssu_ptr = P_ssu_ptr;
	passport_info_ptr = P_passport_info_ptr;
	type = P_type;
	forum_idx = passport.forum_idx;
	if forum_idx = 0 then call ssu_$abort_line (ssu_ptr, forum_et_$no_forum);
	current = passport.current_trans;
	if current = 0 then no_current = "1"b;
	list = "1"b;
	temp_forum = "0"b;
	last_tri = 0;
	argmap_ptr, bit_map_ptr, forum_trans_list_ptr = null ();
	select_type = ONLY_UNDELETED;
	request_name = ssu_$get_request_name (ssu_ptr);
	call ssu_$return_arg (ssu_ptr, arg_count, active_function, ret_ptr, ret_len);

	on cleanup call cleanup_handler ();

	if arg_count > 0 & allow_spec then do;
	     parse_flags_word =
		ONLY_ONE | DISALLOW_MTG | DISALLOW_REV | DISALLOW_INITIAL | DONT_READ | DISALLOW_CMSG
		| DISALLOW_BYCHAIN;
	     if ^substr (UNPROC_OK, type, 1) then parse_flags_word = parse_flags_word | DISALLOW_UNPROC;

	     call forum_trans_specs_$parse_specs (passport_info_ptr, 1, parse_flags_word, dummy, (0), (""), (""),
		forum_trans_list_ptr);
	     current = forum_trans_list.trans_num (1);
	     if current = 0 then do;
		if ^substr (UNPROC_OK, type, 1) then
		     call ssu_$abort_line (ssu_ptr, 0, "The unprocessed transaction is not a reply.");
		current = passport.unprocessed_reply_trans;
		if type = PREF then current = -current; /* PREF of unproc is weird */
	     end;
	     free forum_trans_list;
	end;

	do idx = 1 to arg_count;
	     call ssu_$arg_ptr (ssu_ptr, idx, arg_ptr, arg_len);
	     if index (arg, "-") = 1 then do;
		if arg = "-include_deleted" | arg = "-idl" then select_type = INCLUDE_DELETED;
		else if arg = "-only_deleted" | arg = "-odl" then select_type = ONLY_DELETED;
		else if arg = "-only_non_deleted" | arg = "-ondl" then select_type = ONLY_UNDELETED;
		else if ^allow_spec then call ssu_$abort_line (ssu_ptr, error_table_$badopt, "^a", arg);
	     end;
	     else if ^allow_spec then call ssu_$abort_line (ssu_ptr, 0, "Usage:  ^a {-control_args}", request_name);
	end;

	if substr (NEED_LIMITS, type, 1) then do;
	     call forum_$forum_limits (forum_idx, select_type, last_seen, first, last, (0), ("0"b), code);
	     if code ^= 0 then call ssu_$abort_line (ssu_ptr, code, "Getting meeting status.");
	     if first = 0 then call ssu_$abort_line (ssu_ptr, forum_et_$no_transactions);
	end;

	if type >= SEEN then do;
	     bit_map_len = last;
	     allocate bit_map in (forum_area);
	     call forum_$get_transaction_map_idx (forum_idx, "", bit_map, code);
	     if code ^= 0 then
		if code = forum_et_$old_format then do;
		     if type ^= LAST_SEEN then
			call ssu_$abort_line (ssu_ptr, 0, "Version 1 meetings do not have seen maps.");
		end;
		else call ssu_$abort_line (ssu_ptr, code, "Getting transaction map.");
	end;

	if last_seen > 0 & current = 0 & substr (NEED_CURRENT, type, 1) then
	     call ssu_$abort_line (ssu_ptr, forum_et_$no_current);

	unspec (trans_specs) = "0"b;

	if type = AREF then call add_aref ("1"b);
	else if type = RREF then call add_rref ();
	else if type = BREF then call add_aref ("0"b);
	else if type = NEW then call add_new ();
	else if type = ALL then call get_all ();
	else if type = SEEN then call get_seen ("1"b);
	else if type = UNSEEN then call get_seen ("0"b);
	else do;
	     if type = CURRENT then do;
		if current > 0 then this_val = current; /* TR21375-6: Try setting current first. */
		else if current = 0 then do;
		     call set_current ();		/* TR21377: Same trans returned by "c" request and "c" used as an arg */
		     passport.current_trans = this_val;
		     current = this_val;
		end;

		if current = 0 then call ssu_$abort_line (ssu_ptr, forum_et_$no_current);
	     end;
	     else if type = FIRST then this_val = first;
	     else if type = LAST then this_val = last;
	     else if type = PREVIOUS then call get_prev ();
	     else if type = NEXT then call get_next ();
	     else if type = FREF then call get_fref ();
	     else if type = LREF then call get_lref ();
	     else if type = NREF then call get_nref ();
	     else if type = PREF then call get_pref ();
	     else if type = FIRST_SEEN then call get_first_seen ();
	     else if type = FIRST_UNSEEN then call get_first_unseen ();
	     else if type = NEXT_SEEN then call get_next_seen ();
	     else if type = NEXT_UNSEEN then call get_next_unseen ();
	     else if type = PREV_SEEN then call get_prev_seen ();
	     else if type = PREV_UNSEEN then call get_prev_unseen ();
	     else if type = LAST_SEEN then call get_last_seen ();
	     else if type = LAST_UNSEEN then call get_last_unseen ();
	     trans_specs.selected = "1"b;
	     ret_string = ltrim (char (this_val));	/* and put it in a string */
	end;
	call cleanup_handler ();

	if ^trans_specs.selected then call ssu_$abort_line (ssu_ptr, forum_et_$no_transactions);

	if active_function then
	     ret_val = ret_val || ret_string;
	else call ioa_ ("^a", ret_string);
	goto MAIN_RETURN;

dummy:
     entry (P_arg_idx);

declare	P_arg_idx			fixed bin;

	call ssu_$arg_ptr (ssu_ptr, P_arg_idx, arg_ptr, arg_len);
	call ssu_$abort_line (ssu_ptr, error_table_$badopt, "^a", arg);
	return;

     end common;
%page;
cleanup_handler:
     proc;

	if forum_trans_list_ptr ^= null () then free forum_trans_list;
	if bit_map_ptr ^= null () then free bit_map;
	if argmap_ptr ^= null () then free argmap;
	if temp_forum then call forum_$close_forum (forum_idx, (0));
	return;
     end;

add_to_string:					/* routine to build return string for all, aref, new */
     proc (number);

declare	number			fixed bin;

	trans_specs.selected = "1"b;			/* remember if we found any */
	if active_function then
	     ret_val = ret_val || ltrim (char (number)) || " ";
	else do;
	     if length (ret_string) > 72 then do;
		call ioa_ (ret_string);		/* print out one line */
		ret_string = "";
	     end;
	     ret_string = ret_string || ltrim (char (number)) || " ";
	end;
	return;
     end add_to_string;

get_limits:
     proc ();

	call forum_$forum_limits (forum_idx, select_type, last_seen, first, last, (0), (""b), code);
	if code ^= 0 then call ssu_$abort_line (ssu_ptr, code);
	if first = 0 then call ssu_$abort_line (ssu_ptr, forum_et_$no_transactions);
	if temp_forum then do;
	     current = last_seen;
	     no_current = "0"b;
	end;

	have_limits = "1"b;
     end get_limits;
%page;
get_date:
     proc (type, truncate);

declare	type			fixed bin,
	truncate			bit (1) aligned,
	(month, day, year)		fixed bin,
	time_stamp		fixed bin (71),
	ONE_DAY_MINUS_A_MICROSECOND	init (86399999999) fixed bin (71) static options (constant);

	if idx = arg_count then goto NOARG;
	idx = idx + 1;
	call ssu_$arg_ptr (ssu_ptr, idx, arg_ptr, arg_len);
	call convert_date_to_binary_ (arg, time_stamp, code);
	if code ^= 0 then call ssu_$abort_line (ssu_ptr, code, "^a", arg);

	if truncate then do;
	     call decode_clock_value_ (time_stamp, month, day, year, (0), (0), (""));
	     call encode_clock_value_ (month, day, year, 0, 0, 0, 0, 0, "", time_stamp, (0));
	end;

	trans_specs.date_given = "1"b;
	if type = BEFORE then trans_specs.high_date = time_stamp;
	else if type = ON_OR_BEFORE then trans_specs.high_date = time_stamp + ONE_DAY_MINUS_A_MICROSECOND;
	else if type = AFTER then trans_specs.low_date = time_stamp;
	else do;
	     trans_specs.low_date = time_stamp;
	     trans_specs.high_date = time_stamp + ONE_DAY_MINUS_A_MICROSECOND;
	end;

	return;
     end get_date;
%page;
get_tri:
     proc (idx, ignore_reaped, direction, next);

declare	(idx, direction, next)	fixed bin,
	ignore_reaped		bit (1) aligned;

	if idx ^= last_tri then do;
	     call forum_$trans_ref_info (forum_idx, idx, select_type, pref, nref, deleted, code);
	     if code ^= 0 then
		if (code ^= forum_et_$trans_reaped) | ^ignore_reaped then
		     call ssu_$abort_line (ssu_ptr, code, "Transaction ^d.", idx);
	end;

	expunged = (code ^= 0);
	if code = 0 then next = idx + direction;
	else if direction = 1 then next = find_next (idx);
	else if direction = -1 then next = find_previous (idx);

	last_tri = idx;
	return;
     end get_tri;

find_next:
     proc (idx) returns (fixed bin);

declare	(idx, next)		fixed bin;

	if forum_idx > 0 then return (idx + 1);

	call forum_$next_transaction (forum_idx, idx, next, code);
	if code ^= 0 then
	     if code = forum_et_$no_transactions then
		next = (2 ** 17) - 1;		/* bbig number, > last, hopefully */
	     else call ssu_$abort_line (ssu_ptr, code, "Transaction ^d.", idx);
	return (next);
     end find_next;


find_previous:
     proc (idx) returns (fixed bin);

declare	(idx, previous)		fixed bin;

	if forum_idx > 0 then return (idx - 1);

	call forum_$previous_transaction (forum_idx, idx, previous, code);
	if code ^= 0 then
	     if code = forum_et_$no_transactions then
		previous = -1;
	     else call ssu_$abort_line (ssu_ptr, code, "Transaction ^d.", idx);
	return (previous);
     end find_previous;


lookup_word:
     proc (word) returns (fixed bin);

declare	word			char (*) parameter,
	idx			fixed bin;

	word = translate (word, LC_ALPHA, UC_ALPHA);	/* ignore case */

	do idx = 1 to hbound (keywords, 1);
	     if word = keywords (idx) then return (key_val (idx));
	end;

	return (0);
     end lookup_word;
%page;
/* Deal with regexps and userids, check for bad characters */
pass1:
     proc (spec);

declare	spec			char (*);
declare	pos			fixed bin init (1);
declare	spec_len			fixed bin;

	spec_len = length (spec);
	if spec_len = 0 then call ssu_$abort_line (ssu_ptr, forum_et_$null_range_spec, "^a", arg);
	in_expr = "0"b;

	do while (pos <= spec_len);
	     first_char = substr (spec, pos, 1);

	     if state = MUST_BE_REGEXP & first_char ^= "/" then
		call ssu_$abort_line (ssu_ptr, forum_et_$bad_trans_spec,
		     "Missing regexp following -subject or -text.");
	     if state = MUST_BE_USERID then do;
		jdx = spec_len - pos + 1;
		goto USERID;
	     end;

	     if first_char = "+" | first_char = "-" then do;
		if pos = spec_len then
		     call ssu_$abort_line (ssu_ptr, forum_et_$bad_trans_spec, "Trailing '+' or '-'.");
		pos = pos + 1;
		in_expr = "1"b;
		first_char = substr (spec, pos, 1);
	     end;
	     else if state = MUST_BE_ARITH then call ssu_$abort_line (ssu_ptr, forum_et_$bad_trans_spec, spec);
	     else if pos > 1 then call ssu_$abort_line (ssu_ptr, forum_et_$bad_trans_spec, "^a", spec);

/* skip over numbers */
	     if index (DIGITS, first_char) ^= 0 then do;
		only_unproc = "0"b;
		jdx = verify (substr (spec, pos), DIGITS);
		if jdx = 0 then
		     jdx = spec_len - pos + 1;
		else jdx = jdx - 1;
		pos = pos + jdx;
	     end;

	     else if first_char = "/" then do;		/* start of a regexp */
		if parse_flags.dont_read then
		     call ssu_$abort_line (ssu_ptr, forum_et_$bad_trans_spec,
			"Regular expressions may not be used with this request.");
		if in_expr then call ssu_$abort_line (ssu_ptr, forum_et_$bad_trans_spec, spec);
		if trans_specs.regexp_given then call ssu_$abort_line (ssu_ptr, forum_et_$too_many_regexps, spec);
		jdx = pos + 1;
REGEXP_LOOP:
		if jdx > spec_len then
BAD_REGEXP:
		     call ssu_$abort_line (ssu_ptr, forum_et_$bad_trans_spec,
			"Missing trailing '/' after regexp ""^a"".", spec);
		kdx = index (substr (spec, jdx), "/");
		if kdx = 0 then goto BAD_REGEXP;	/* didn't find a '/' */
		if kdx >= 3 then
		     if substr (spec, jdx + kdx - 3, 2) = "\c" then do;
						/* \c makes / not terminator */
			substr (trans_specs.regexp, trans_specs.regexp_len + 1, kdx - 2) =
			     substr (spec, jdx, kdx - 3) || "/";
			trans_specs.regexp_len = trans_specs.regexp_len + kdx - 2;
			jdx = jdx + kdx;
			goto REGEXP_LOOP;
		     end;

		trans_specs.regexp_given = "1"b;
		if kdx > 1 then do;
		     substr (trans_specs.regexp, trans_specs.regexp_len + 1) = substr (spec, jdx, kdx - 1);
		     trans_specs.regexp_len = trans_specs.regexp_len + kdx - 1;
		     saved_regexp = trans_specs.regexp;
		end;
		else do;
		     if saved_regexp = "" then
			call ssu_$abort_line (ssu_ptr, forum_et_$bad_trans_spec, "No previous regexp for //.");
		     trans_specs.regexp_len = length (rtrim (saved_regexp));
		     trans_specs.regexp = saved_regexp;
		end;

		pos = jdx + kdx;
		only_unproc = "0"b;
		substr (argmap, idx, 1) = "0"b;	/* don't need to look here again */
	     end;					/* regexp */

	     else if index (LETTERS, first_char) ^= 0 then do;
						/* keyword or userid */
		jdx = verify (substr (spec, pos), LETTERS);
		if jdx = 0 then
		     jdx = spec_len - pos + 1;	/* rest of line */
		else jdx = jdx - 1;

		kdx = lookup_word (substr (spec, pos, min (32, jdx)));
		if kdx > 0 then goto GOT_WORD;

		if parse_flags.call_on_non_ctl_arg then do;
						/* Request wants to see this one */
		     substr (argmap, idx, 1) = ""b;
		     call P_ctl_arg_entry (idx);
		     return;
		end;				/* Nobody knows who this is. */
		call ssu_$abort_line (ssu_ptr, forum_et_$bad_trans_spec, "^a", arg);
USERID:
		if index (arg, ".") > 0 then
		     call ssu_$abort_line (ssu_ptr, forum_et_$bad_trans_spec,
			"Person_id's may not contain ""."". ""^a""", arg);

		call forum_$check_user (forum_idx, arg, last_sent, (0));

		if trans_specs.id_given then call ssu_$abort_line (ssu_ptr, forum_et_$too_many_personids, arg);

		if parse_flags.dont_read then
		     call ssu_$abort_line (ssu_ptr, forum_et_$bad_trans_spec,
			"Personids may not be used with this request. ^a.", arg);
		trans_specs.id_given = "1"b;
		trans_specs.person_id = arg;
		only_unproc = "0"b;
		substr (argmap, idx, 1) = "0"b;	/* don't need to look here on pass 2 */
		goto END_LOOP;


GOT_WORD:
		if kdx ^= UNPROC then only_unproc = "0"b;
END_LOOP:
		pos = pos + jdx;
		state = MUST_BE_ARITH;
	     end;					/* keyword or user id */
	     else if parse_flags.call_on_non_ctl_arg then do;
						/* Request wants to see this one */
		substr (argmap, idx, 1) = ""b;
		call P_ctl_arg_entry (idx);
		return;
	     end;
	     else call ssu_$abort_line (ssu_ptr, forum_et_$bad_trans_spec, "^a", spec);
						/* unknown special char */
	end;					/* token loop */

     end pass1;
%page;
/* This subroutine figures out which transactions were requested */
pass2:
     proc (spec);

declare	spec			char (*);
declare	pos			fixed bin init (1);
declare	spec_len			fixed bin;

	spec_len = length (spec);

	if index (spec, ":") ^= 0 then call ssu_$abort_line (ssu_ptr, forum_et_$bad_trans_spec, "^a", arg);
	value = 0;
	sign = 1;
	in_expr = "0"b;

	do while (pos <= spec_len);
	     this_val = 0;
	     first_char = substr (spec, pos, 1);
	     kdx = index ("++-", first_char);

	     if kdx ^= 0 then do;
		pos = pos + 1;
		if value = 0 & pos = 2 then value = current;
						/* leading + or - is relative to current */
		in_expr = "1"b;			/* next must be single numeric */
		sign = 2 - kdx;
		first_char = substr (spec, pos, 1);
	     end;
	     else if pos > 1 then call ssu_$abort_line (ssu_ptr, forum_et_$bad_trans_spec, "^a", spec);

	     if index (DIGITS, first_char) ^= 0 then do;
		jdx = index (DIGITS, first_char);
		jdx = verify (substr (spec, pos), DIGITS);
		if jdx = 0 then
		     jdx = spec_len - pos + 1;
		else jdx = jdx - 1;

		if jdx > 6 then call ssu_$abort_line (ssu_ptr, forum_et_$invalid_trans_idx, spec);
		this_val = fixed (substr (spec, pos, jdx));
		pos = pos + jdx;
	     end;

	     else if index (LETTERS, first_char) ^= 0 then do;
						/* keyword or userid */
		jdx = verify (substr (spec, pos), LETTERS);
		if jdx = 0 then
		     jdx = spec_len - pos + 1;	/* word is the rest of line */
		else jdx = jdx - 1;

		kdx = lookup_word (substr (spec, pos, min (32, jdx)));
		if kdx = 0 then
		     call ssu_$abort_line (ssu_ptr, forum_et_$bad_trans_spec, substr (spec, pos, min (32, jdx)));

		if substr (MULTIPLE, kdx, 1) & (in_range | in_expr) then
BAD_WORD:
		     call ssu_$abort_line (ssu_ptr, forum_et_$key_not_allowed, "'^a' in '^a'",
			substr (spec, pos, min (32, jdx)), arg);

		if substr (NEED_CURRENT, kdx, 1) & no_current then
		     call ssu_$abort_line (ssu_ptr, forum_et_$no_current);

		if ^have_limits & substr (NEED_LIMITS, kdx, 1) then call get_limits ();

		if kdx >= SEEN & bit_map_ptr = null () then do;
		     bit_map_len = last;
		     allocate bit_map in (forum_area);
		     call forum_$get_transaction_map_idx (forum_idx, "", bit_map, code);
		     if code ^= 0 then
			if code = forum_et_$old_format then do;
			     if kdx ^= LAST_SEEN then
				call ssu_$abort_line (ssu_ptr, 0, "Version 1 meetings do not have seen maps.");
			end;
			else call ssu_$abort_line (ssu_ptr, code, "Getting transaction map.");
		end;

		if kdx = ALL then call get_all ();
		else if kdx = NEW then do;
		     in_range = "1"b;
		     call add_new ();
		end;

		else if kdx = AREF then do;
		     in_range = "1"b;
		     call add_aref ("1"b);
		end;

		else if kdx = RREF then do;
		     in_range = "1"b;
		     call add_rref ();
		end;

		else if kdx = BREF then do;
		     in_range = "1"b;
		     call add_aref ("0"b);
		end;

		else if kdx = CMSG then do;
		     if parse_flags.disallow_cmsg then
			call ssu_$abort_line (ssu_ptr, 0, "The chairman_message keyword may not be used.");
		     if in_range | in_expr then goto BAD_WORD;
		     call forum_$get_message (forum_idx, message, code);
		     if code ^= 0 then call ssu_$abort_line (ssu_ptr, code, "Getting chairman message.");
		     in_range = "1"b;
		     deleted = "0"b;
		     call allocate_num (-1);
		end;

		else if kdx = UNPROC then do;
		     if parse_flags.disallow_unproc then call ssu_$abort_line (ssu_ptr, forum_et_$unproc_not_allowed);
		     if in_range | in_expr then goto BAD_WORD;
		     in_range = "1"b;
		     deleted = "0"b;
		     call allocate_num (0);		/* unprocessed is transaction 0 */
		end;
		else if kdx = CURRENT then do;
		     if current > 0 then this_val = current;
						/* TR21375-6: Try setting current first. */
		     else if current = 0 then do;
			call set_current ();	/* TR21377: Same trans returned by "c" request and "c" used as an arg */
			passport.current_trans = this_val;
			current = this_val;
		     end;

		     if current = 0 then call ssu_$abort_line (ssu_ptr, forum_et_$no_current);
		end;
		else if kdx = FIRST then this_val = first;
		else if kdx = LAST then this_val = last;
		else if kdx = PREVIOUS then call get_prev ();
		else if kdx = NEXT then call get_next ();
		else if kdx = FREF then call get_fref ();
		else if kdx = LREF then call get_lref ();
		else if kdx = NREF then call get_nref ();
		else if kdx = PREF then call get_pref ();
		else if kdx = SEEN then call get_seen ("1"b);
		else if kdx = FIRST_SEEN then call get_first_seen ();
		else if kdx = NEXT_SEEN then call get_next_seen ();
		else if kdx = PREV_SEEN then call get_prev_seen ();
		else if kdx = LAST_SEEN then call get_last_seen ();
		else if kdx = UNSEEN then call get_seen ("0"b);
		else if kdx = FIRST_UNSEEN then call get_first_unseen ();
		else if kdx = NEXT_UNSEEN then call get_next_unseen ();
		else if kdx = PREV_UNSEEN then call get_prev_unseen ();
		else if kdx = LAST_UNSEEN then call get_last_unseen ();

END_LOOP:
		pos = pos + jdx;
	     end;					/* keyword or user id */
	     else call ssu_$abort_line (ssu_ptr, forum_et_$bad_trans_spec, "^a", spec);
	     value = value + sign * this_val;		/* add up expression */
	     sign = 1;
	end;					/* token loop */

	if ^in_range then do;			/* add it to the list */
	     call get_tri (value, "1"b, 0, (0));
	     if ^(initial & pref ^= 0) then call allocate_num (value);
	end;
     end pass2;
%page;
get_seen:
     proc (seen);

declare	seen			bit (1) aligned,
	idx			fixed bin;

	in_range = "1"b;
	blank = "0"b;
	tidx = 1;
	do while (tidx <= bit_map_len);
	     idx = index (substr (bit_map, tidx), seen);
	     if idx = 0 then return;
	     tidx = tidx + idx - 1;
	     if tidx <= bit_map_len then do;
		call get_tri (tidx, "1"b, 1, idx);
		if check () then call add_from_multiple ();
		tidx = idx;
	     end;
	end;
     end get_seen;

get_first_seen:
     proc ();
dcl	(backward_sw, which_seen, next_sw)
				bit (1);

	backward_sw = "0"b;
	which_seen = "1"b;
	next_sw = "0"b;
	goto get_common;


get_first_unseen:
     entry ();
	which_seen = "0"b;
	backward_sw = "0"b;
	next_sw = "0"b;
	goto get_common;

get_last_unseen:
     entry ();
	backward_sw = "1"b;
	which_seen = "0"b;
	next_sw = "0"b;
	goto get_common;

set_current:
     entry ();

	if ^have_limits then call get_limits ();
	if bit_map_ptr = null () then do;
	     bit_map_len = last;
	     allocate bit_map in (forum_area);
	     call forum_$get_transaction_map_idx (forum_idx, "", bit_map, code);
	     if code ^= 0 then call ssu_$abort_line (ssu_ptr, code, "Getting transaction map.");
	end;

	reset_current = "1"b;
	backward_sw = "1"b;
	which_seen = "1"b;
	next_sw = "0"b;
	goto get_common;

get_last_seen:
     entry ();
	if bit_map_ptr = null () then do;		/* v1 meeting */
	     this_val = last_seen;
	     return;
	end;
	backward_sw = "1"b;
	which_seen = "1"b;
	next_sw = "0"b;
	goto get_common;

get_next_seen:
     entry ();
	backward_sw = "0"b;
	which_seen = "1"b;
	next_sw = "1"b;
	goto get_common;

get_next_unseen:
     entry ();
	backward_sw = "0"b;
	which_seen = "0"b;
	next_sw = "1"b;
	goto get_common;

get_prev_seen:
     entry ();
	backward_sw = "1"b;
	which_seen = "1"b;
	next_sw = "1"b;
	goto get_common;

get_prev_unseen:
     entry ();
	backward_sw = "1"b;
	which_seen = "0"b;
	next_sw = "1"b;
	goto get_common;

get_common:
	if next_sw then do;				/* TR21375-6: If there is no seen trans, "c" is set to the first non_deleted */
	     if last_seen = 0 then
		this_val = first;
	     else this_val = current;
	end;
	else do;
	     if backward_sw then
		this_val = last;
	     else this_val = first;
	     if substr (bit_map, this_val, 1) = which_seen then
		if ^expungedp () then return;
	end;

/* TR21375-6: If current trans is deleted, "c" is skipped to the next non_deleted trans.  If there are no more non_deleted trans, c is undefined */
	do while ("1"b);
	     this_val = skip_some ();
	     if this_val = 0 then do;
		if next_sw then
		     call ssu_$abort_line (ssu_ptr, 0, "No ^[previous^;more^] ^[un^]seen transactions.", backward_sw,
			^which_seen);
		else if ^(reset_current) then
		     call ssu_$abort_line (ssu_ptr, 0, "^[No^;All^] transactions have been seen.", which_seen);

/* Reset current to first non_deleted trans if reset_current is set */
		else if (first > 0) then do;
		     this_val = first;
		     reset_current = "0"b;
		end;
	     end;
	     if ^expungedp () then return;
	end;

skip_some:
     proc () returns (fixed bin);
dcl	i			fixed bin;

	if backward_sw then do;
	     this_val = find_previous (this_val);
	     if this_val <= 0 then return (0);
	     i = index (reverse (substr (bit_map, 1, this_val)), which_seen);
	     if i = 0 then return (i);
	     i = this_val - i + 1;
	     return (i);
	end;
	else do;
	     this_val = find_next (this_val);
	     if this_val > last then return (0);
	     i = index (substr (bit_map, this_val), which_seen);
	     if i = 0 then return (i);
	     i = i + this_val - 1;
	     return (i);
	end;

     end skip_some;

expungedp:
     proc () returns (bit (1));

	call get_tri (this_val, "1"b, 0, (0));
	return (^check ());

     end expungedp;

     end get_first_seen;
%page;
get_nref:
     proc ();

	call get_tri (current, "0"b, 0, (0));
	if nref = 0 then
	     call ssu_$abort_line (ssu_ptr, 0, "There is no next transaction in this chain. ^[""^a""^]", ^list, arg);
	this_val = nref;
	return;
     end get_nref;

get_pref:						/* gets previous in chain of current */
     proc ();

	if current < 0 then
	     this_val = -current;			/* pref unproc */
	else do;
	     call get_tri (current, "0"b, 0, (0));
	     if pref = 0 then
		call ssu_$abort_line (ssu_ptr, 0, "There is no previous transaction in this chain. ^[""^a""^]", ^list,
		     arg);
	     this_val = pref;
	end;
	return;
     end get_pref;

get_lref:						/* gets last in current chain */
     proc ();

	do this_val = current repeat nref;
	     call get_tri (this_val, "1"b, 0, (0));
	     if nref = 0 then return;
	end;
     end get_lref;

get_fref:						/* gets first in current chain */
     proc;

	do this_val = current repeat pref;
	     call get_tri (this_val, "1"b, 0, (0));
	     if pref = 0 then return;
	end;
     end get_fref;

get_prev:						/* gets previous undeleted */
     proc;

declare	idx			fixed bin;

	do tidx = current - 1 repeat idx while (tidx > 0);
	     call get_tri (tidx, "1"b, -1, idx);
	     if check () then do;
		this_val = tidx;
		return;
	     end;
	end;
	call ssu_$abort_line (ssu_ptr, 0, THERE_IS_NO, "previous");
     end get_prev;

check:
     proc () returns (bit (1) aligned);

	return (^expunged & ((deleted & select_type ^= ONLY_UNDELETED) | (^deleted & select_type ^= ONLY_DELETED)));

     end check;

get_next:
     proc ();

declare	idx			fixed bin;

	do tidx = current + 1 repeat idx while (tidx <= last);
	     call get_tri (tidx, "1"b, 1, idx);
	     if check () then do;
		this_val = tidx;
		return;
	     end;
	end;
	call ssu_$abort_line (ssu_ptr, 0, THERE_IS_NO, "next");
     end get_next;


get_all:						/* gets all non-deleted */
     proc ();

declare	(low, high, idx)		fixed bin;

/* This can be called even if get_limits hasn't been called, if default_to_all
   or date/regexp */

	if ^have_limits then call get_limits ();

	in_range = "1"b;
	if trans_specs.date_given then do;
	     call forum_$trans_time_info (forum_idx, trans_specs.low_date, trans_specs.high_date, low, high, code);
	     if code ^= 0 then call ssu_$abort_line (ssu_ptr, code);
	     if high + low = 0 then low = 1;		/* No transactions in range */
	end;
	else do;
	     low = first;
	     high = last;
	end;

	do tidx = low repeat idx while (tidx <= high);
	     call get_tri (tidx, "1"b, 1, idx);
	     if check () then call add_from_multiple ();
	end;
	return;
     end get_all;

add_from_multiple:
     proc ();

	if list then call add_to_string (tidx);
	else if ^(initial & pref ^= 0) then call allocate_num (tidx);

     end add_from_multiple;
%page;
/* This routine actually adds a transaction number to the list after making sure it is compatible */
/* with the flags given to parse_specs - deleted etc */

allocate_num:
     proc (tnum);

declare	tnum			fixed bin;

	blank = "0"b;
	if (tnum = 0 & kdx ^= UNPROC) | (tnum = -1 & kdx ^= CMSG) | tnum < -1 then
	     call ssu_$abort_line (ssu_ptr, forum_et_$invalid_trans_idx, "^d", tnum);

	if trans_specs.selected & parse_flags.only_one then call ssu_$abort_line (ssu_ptr, forum_et_$too_many_trans);
	if deleted & select_type = ONLY_UNDELETED then do;
	     if ^in_range then call ssu_$print_message (ssu_ptr, forum_et_$trans_deleted, "Transaction ^d.", tnum);
	     return;
	end;
	else if code = forum_et_$trans_reaped then do;
	     if ^in_range then call ssu_$print_message (ssu_ptr, code, "Transaction ^d.", tnum);
	     return;
	end;
	else if ^deleted & select_type = ONLY_DELETED then do;
	     if ^in_range then call ssu_$print_message (ssu_ptr, forum_et_$trans_not_deleted, "Transaction ^d.", tnum);
	     return;
	end;

	if ^parse_flags.dont_read & tnum ^= -1 then do;
	     if ^select (tnum) then return;		/* check if it matches username and/or regexp */
	     forum_trans_list.max_personid_len =
		max (forum_trans_list.max_personid_len, length (rtrim (forum_user_trans.person_id)));
	end;

	if forum_trans_list.size = forum_trans_list.max_size then call expand_list ();
	forum_trans_list.size = forum_trans_list.size + 1;
	forum_trans_list.list.trans_num (forum_trans_list.size) = tnum;
	if tnum <= 0 then do;
	     forum_trans_list.list.nref (forum_trans_list.size) = 0;
	     forum_trans_list.list.pref (forum_trans_list.size) = 0;
	end;
	else do;
	     forum_trans_list.list.nref (forum_trans_list.size) = nref;
	     forum_trans_list.list.pref (forum_trans_list.size) = pref;
	end;
	string (forum_trans_list.list.flags (forum_trans_list.size)) = ""b;
	forum_trans_list.list.flags.deleted (forum_trans_list.size) = deleted;

	trans_specs.selected = "1"b;
	return;
     end allocate_num;
%page;
expand_list:
     procedure ();

declare	idx			fixed bin,
	new_list_ptr		pointer,
	1 new_list		aligned like forum_trans_list based (new_list_ptr);

	new_list_ptr = null ();
	alloc_trans_list_size = forum_trans_list.max_size * 4;

	on cleanup
	     begin;
		if new_list_ptr ^= null then free new_list;
	     end;

RETRY:
	on area
	     begin;
		call forum_trans_util_$clear_cache (passport_info_ptr);
		goto RETRY;
	     end;

	allocate new_list in (forum_area);
	revert area;

	new_list.max_size = alloc_trans_list_size;
	new_list.size = forum_trans_list.size;
	new_list.max_personid_len = forum_trans_list.max_personid_len;

	do idx = 1 to new_list.size;
	     new_list.list (idx) = forum_trans_list.list (idx);
	end;

	free forum_trans_list;
	forum_trans_list_ptr = new_list_ptr;
	return;
     end expand_list;
%page;
/* This routine adds all transactions greater than last_seen not from this user to the list */
add_new:
     proc;

declare	idx			fixed bin;

	blank = "0"b;				/* KLUDGE - in case there aren't any new ones */
	call user_info_$whoami (me, "", "");
	if last_seen = 0 then
	     tidx = 1;
	else tidx = last_seen + 1;

	do tidx = tidx repeat idx while (tidx <= last);
	     call get_tri (tidx, "1"b, 1, idx);
	     if check () then do;
		call forum_trans_util_$read_trans (passport_info_ptr, forum_idx, tidx, forum_user_trans_ptr, (0));
		if forum_user_trans.person_id ^= me then call add_from_multiple ();
						/* if I sent it, it ain't new */
	     end;
	end;
	return;
     end add_new;


add_aref:						/* adds all in current chain */
     proc (P_all);

declare	(P_all, all)		bit (1) aligned;

	all = P_all;
	do tidx = current repeat pref;		/* back up to beginning of chain */
	     call get_tri (tidx, "1"b, 0, (0));
	     if pref = 0 then goto BEGIN_CHAIN;
	end;

add_rref:
     entry ();

	call get_tri (current, "0"b, 0, (0));
	if nref = 0 then call ssu_$abort_line (ssu_ptr, 0, "There are no more transactions in this chain.");
	tidx = nref;
	all = "1"b;

BEGIN_CHAIN:					/* and add moving forward */
	do tidx = tidx repeat nref;
	     call get_tri (tidx, "0"b, 0, (0));
	     if check () then call add_from_multiple ();
	     if nref = 0 | initial | (^all & nref = current) then return;
	end;
     end add_aref;


do_range:						/* add all non-deleted in a range */
     proc ();

declare	idx			fixed bin;

	if last_val > value then call ssu_$abort_line (ssu_ptr, forum_et_$null_range_spec, arg);
	blank = "0"b;
	do tidx = last_val repeat idx while (tidx <= value);
	     call get_tri (tidx, "1"b, 1, idx);
	     if check () then
		if ^(initial & pref ^= 0) then call allocate_num (tidx);
	end;
	return;
     end do_range;
%page;
/* This routine matches usernames and regexps */
select:
     proc (L_trans_num) returns (bit (1));

declare	L_trans_num		fixed bin;

	call forum_trans_util_$read_trans (passport_info_ptr, forum_idx, L_trans_num, forum_user_trans_ptr, (0));
	if forum_user_trans_ptr = null () then return ("0"b);

	if trans_specs.id_given then
	     if trans_specs.person_id ^= forum_user_trans.person_id then return ("0"b);

	if trans_specs.date_given then do;
	     if trans_specs.low_date >= forum_user_trans.time then return ("0"b);
	     if trans_specs.high_date ^= 0 & trans_specs.high_date <= forum_user_trans.time then return ("0"b);
	end;

	if trans_specs.regexp_given then do;
	     if ^trans_specs.no_match_sj then do;
		call search_file_$silent (addr (trans_specs.regexp), 1, trans_specs.regexp_len,
		     addr (forum_user_trans.subject), 1, (forum_user_trans.subject_length), (0), (0), match_code);
		if match_code = 0 then return ("1"b);
		else if match_code ^= error_table_$nomatch then
		     call ssu_$abort_line (ssu_ptr, match_code, """^a""", trans_specs.regexp);
	     end;

	     if trans_specs.no_match_text then return ("0"b);
	     call search_file_$silent (addr (trans_specs.regexp), 1, trans_specs.regexp_len,
		addr (forum_user_trans.text), 1, (forum_user_trans.text_length), (0), (0), match_code);
	     if match_code ^= 0 then
		if match_code = error_table_$nomatch then
		     return ("0"b);
		else call ssu_$abort_line (ssu_ptr, match_code, """^a""", trans_specs.regexp);
	end;

	return ("1"b);
     end select;

     end forum_trans_specs_$parse_specs;
