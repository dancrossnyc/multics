/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8060 cobol_mcs.pl1 Reformatted code to new Cobol standard.
                                                   END HISTORY COMMENTS */


/* Modified on 03/17/82 by FCH, [5.2-1], eliminate need for copy switch by using temp seg, BUG530 */
/* Modified on 07/21/81 by FCH, [4.4-9], ..command added, BUG468 */
/* Modified on 06/02/81 by FCH, [4.4-8], initialization, BUG468 */
/* Modified on 06/01/81 by FCH, [4.4-7], on command_abort_ added, BUG468 */
/* Modified on 05/05/81 by FCH, [4.4-5], attach and detach commands added, BUG468 */
/* Modified on 05/01/81 by FCH, [4.4-3], all option on receive added, BUG468 */
/* Modified on 04/23/81 by FCH, [4.4-1], delete final new-line from send buffer, BUG468 */
/* Modified since Version 4.3 */






/* format: style3 */
cmcs:
cobol_mcs:
     procedure options (separate_static);

/* This COBOL MCS command is used to intialize the process environment
   for subsequent CMCS processing. For "CMCS terminals", it will enter
   request mode, and allow the user to essentially duplicate the COBOL program
   MCS functions through the request interface.
*/

/* Bob May, 5/31/77 */

dcl	(i, j)		fixed bin,
	dname		char (168),
	ename		char (32),
	char_delim	char (1),
	io_subtype	fixed bin,
	rcv_tree_path	char (48) init (""),
	code		fixed bin (35),
	my_name		char (16),		/* either cobol_mcs or cobol_mcs_admin */
	my_brief_name	char (8),			/* for whoami */
	(password1, password2)
			char (10);

dcl	station_name	char (12),
	dest_table_index	fixed bin,
	err_sw		bit (1) init ("0"b);

dcl	output_cd_size	fixed bin;		/* temp output CD stuff, to get started */

dcl	output_cd_area	(output_cd_size) fixed bin based (output_cdp);

dcl	ptr_array		(1) ptr;			/* for get, release temp segments */

dcl	overlay_len	fixed bin,		/* for structure initialization */
	overlay		(overlay_len) fixed bin based;

dcl	buffer_len	fixed bin (21),
	buffer_max_len	fixed bin (21),
	buffer_ptr	ptr,
	buffer		char (256);


dcl	send_buffer_ptr	ptr,
	send_buffer_max_len fixed bin (21),
	send_buffer_len	fixed bin (35),		/* actual number of chars in temp buffer */
	char_send_buffer_len
			pic "9999",
	send_buffer	char (send_buffer_max_len) based (send_buffer_ptr);

/* Switches */

dcl	(scpsw_sw, interactive_sw)
			bit (1);

dcl	test_sw		bit (1) int static init ("0"b);

dcl	(cleanup, program_interrupt, command_abort_)
			condition;

dcl	term_id		char (4),
	term_type		fixed bin,
	term_channel	char (8);

dcl	command_count	fixed bin int static init (15);

dcl	1 command_list	int static,
	  2 brief		(15) char (8) init ("q",	/* 1 */
			"e",			/* 2 */
			"amc",			/* 3 */
			"r",			/* 4 */
			"s",			/* 5 */
			"ei",			/* 6 */
			"eit",			/* 7 */
			"eo",			/* 8 */
			"di",			/* 9 */
			"dit",			/* 10 */
			"do",			/* 11 */
			"p",			/* 12 */
			".",			/* 13 */
			"a",			/* 14 */
			"d"),			/* 15 */
	  2 long		(15) char (32) init ("quit",	/* 1 */
			"execute",		/* 2 */
			"accept_message_count",	/* 3 */
			"receive",		/* 4 */
			"send",			/* 5 */
			"enable_input",		/* 6 */
			"enable_input_terminal",	/* 7 */
			"enable_output",		/* 8 */
			"disable_input",		/* 9 */
			"disable_input_terminal",	/* 10 */
			"disable_output",		/* 11 */
			"purge",			/* 12 */
			".",			/* 13 */
			"activate",		/* 14 */
			"deactivate");		/* 15 */


dcl	admin_command_count fixed bin int static init (11);

dcl	1 admin_command_list
			int static,
	  2 brief		(11) char (8) init (".",	/* 1 */
			"q",			/* 2 */
			"e",			/* 3 */
			"test",			/* 4 */
			"ccpsw",			/* 5 */
			"scpsw",			/* 6 */
			"ccq",			/* 7 */
			"start_mp",		/* 8 (not currently used) */
			"stop_mp",		/* 9 */
			"clear_mp",		/* 10 */
			"purge_qs"),		/* 11 */
	  2 long		(11) char (32) init (".",	/* 1 */
			"quit",			/* 2 */
			"execute",		/* 3 */
			"test",			/* 4 */
			"change_cmcs_password",	/* 5 */
			"set_cmcs_password",	/* 6 */
			"create_cmcs_queues",	/* 7 */
			"start_mp",		/* 8 (not currently used) */
			"stop_mp",		/* 9 */
			"clear_mp",		/* 10 */
			"purge_queues");		/* 11 */

dcl	req		char (256),		/* request line input buffer */
	(req_arg_count, req_left_begin, req_left_len)
			fixed bin,
	req_len		fixed bin (21),		/* for use with iox_$get_line */
	req_cmd_ptr	ptr,
	req_cmd_len	fixed bin;

dcl	(cmd_parsed_sw, args_parsed_sw)
			bit (1);

dcl	max_arg_count	fixed bin int static options (constant) init (25);

dcl	1 arg_array	(25),
	  2 argp		ptr,
	  2 argl		fixed bin;


dcl	max_req_args	fixed bin int static options (constant) init (16);
						/* loop control */

dcl	whitespace	char (5) int static options (constant) init ("

");						/* b, HT, NL, VT, FF */


dcl	user_info_$absentee_queue
			entry (fixed bin),
	user_info_$tty_data entry (char (*), fixed bin, char (*)),
	absolute_pathname_	entry (char (*), char (*), fixed bin (35)),
	expand_pathname_	entry (char (*), char (*), char (*), fixed bin (35)),
	cu_$cp		entry (ptr, fixed bin, fixed bin (35)),
	read_password_	entry (char (*), char (*)),
	get_process_id_	entry () returns (bit (36)),
	get_wdir_		entry () returns (char (168)),
	get_temp_segments_	entry (char (*), (*) ptr, fixed bin (35)),
	release_temp_segments_
			entry (char (*), (*) ptr, fixed bin (35)),
	hcs_$make_seg	entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35)),
	(
	ioa_,
	ioa_$rsnnl
	)		entry options (variable);	/*[5.2-1]*/
dcl	cmcs_initiate_ctl_$release
			entry (fixed bin (35));
dcl	(
	error_table_$action_not_performed,
	error_table_$long_record,
	error_table_$too_many_args,
	error_table_$wrong_no_of_args
	)		fixed bin (35) external;

dcl	(addr, char, fixed, null, search, size, string, substr, verify)
			builtin;			/*  */
%include cmcs_arg_processing;
%include cmcs_cd_dcls;
%include cmcs_cobol_mcs_dcls;
%include cmcs_control_hdr;
%include cmcs_entry_dcls;
%include cmcs_error_table_dcls;
%include cmcs_iox_processing;
%include cmcs_ipc_processing;
%include cmcs_station_ctl;
%include cmcs_system_ctl;
%include cmcs_terminal_ctl;
%include cmcs_tree_ctl;
%include cmcs_user_ctl;
%include cmcs_vfile_rs;
%include cmcs_wait_ctl;

/*  */
/* cobol_mcs, cmcs only */

	my_name = "cobol_mcs";
	my_brief_name = "cmcs";

	call cu_$arg_count (arg_count);

	if arg_count < 2 | arg_count > 3
	then do;

print_usage:
		code = 0;

print_error_usage:
		call com_err_ (code, my_name, "^/Usage: cobol_mcs cmcs_dir -message_processor (-mp) <station_name>

or:    cobol_mcs cmcs_dir -terminal (-term) {<station_name>}");

		return;

	     end;

common_entry:
	call get_temp_segments_ ("cobol_mcs", ptr_array, code);

	if code ^= 0
	then do;

		call com_err_ (code, my_name, "Attempting to create cmcs_user_ctl_.control in your process_dir.");
		return;
	     end;

	user_ctl_ptr = ptr_array (1);			/* now we can do something with it */

	call cu_$arg_ptr (1, arg_ptr, arg_len, code);

	if code ^= 0
	then go to print_error_usage;

	if arg = "-wd" | arg = "-working_dir"
	then dname = get_wdir_ ();
	else do;

		call absolute_pathname_ (arg, dname, code);
		if code ^= 0
		then go to print_error_usage;
	     end;

/* general initialization */

	buffer_ptr = addr (buffer);
	buffer_max_len = 4 * 16 * 1024;		/* terminal input arbitrarily limited to 16k chunks */

/*[4.4-5]*/
	user_ctl.attach_bit, user_ctl.rec = "0"b;
	d_stat_path = "";				/*[4.4-5]*/
	user_ctl.output_file = "";			/*[4.4-5]*/
	user_ctl.iocb_ptr = null ();			/*[4.4-5]*/
	IOCB_ptr = iox_$user_output;


/* clear all user_ctl data */

	overlay_len = size (user_ctl);
	user_ctl_ptr -> overlay (*) = 0;		/* clean slate */
						/*[4.4-8]*/
	string (user_ctl.init_sw) = "0"b;
	user_ctl.cmcs_dir, user_ctl.station_name, user_ctl.term_id, user_ctl.term_channel,
	     user_ctl.last_receive_info.tree_path, user_ctl.last_send_info.dest_name = "";
						/* so it isn't garbage if printed */

	user_ctl.last_receive_info.tree_ctl_eptr = null ();
	user_ctl.last_send_info.tree_ctl_eptr = null ();
	user_ctl.station_info.station_entries (*).station_ctl_eptr = null ();
	user_ctl.wait_info.wait_ctl_eptr = null ();	/* so we don't reference the dseg */

	user_ctl.cmcs_dir = dname;			/* start filling things in */

	external_user_ctl_ptr = user_ctl_ptr;		/* first reference */

	call cobol_mcs_$set_user_ctl_exists_sw ("1"b);	/* let the world know we're ready */
	call cmcs_initiate_ctl_ ("", null (), code);	/* just set all the ptrs in user_ctl, ma'am */

	if code ^= 0
	then do;

		external_user_ctl_ptr = null ();
		return;				/* cminit_ will print the error message */
	     end;

/* Drop-thru means that user_ctl has had all its control seg ptrs set by cminit_.
			   Now we all can get ptrs from user_ctl without using a call */

	queue_ctl_ptr = user_ctl.queue_ctl_ptr;		/* for admin and MPs */
	station_ctl_ptr = user_ctl.station_ctl_ptr;	/* for admin and MPs */
	system_ctl_ptr = user_ctl.system_ctl_ptr;	/* for admin and MPs */
	terminal_ctl_ptr = user_ctl.terminal_ctl_ptr;	/* for admin and MPs */
	tree_ctl_ptr = user_ctl.tree_ctl_ptr;		/* for admin and MPs */
	wait_ctl_ptr = user_ctl.wait_ctl_ptr;

	user_ctl.process_id = get_process_id_ ();

	call set_interactive_info;

	if my_brief_name = "cmcsa"
	then do;

		user_ctl.admin_sw = "1"b;
		user_ctl.process_type = 3;		/* admin process */
	     end;

	if my_name = "cobol_mcs"
	then do;					/* cobol_mcs only */

		call cu_$arg_ptr (2, arg_ptr, arg_len, code);
		if code ^= 0
		then go to print_error_usage;

		if arg = "-mp" | arg = "-message_processor"
		then do;

			call cu_$arg_ptr (3, arg_ptr, arg_len, code);

			if code ^= 0
			then go to print_error_usage;
			station_name = arg;
			user_ctl.mp_sw = "1"b;	/* we made it, user is a station */
			user_ctl.process_type = 1;	/* process is a CMCS message processor */
		     end;

		else if arg = "-term" | arg = "-terminal"
		then do;


			if ^interactive_sw
			then do;

				call com_err_ (0, my_name, "The terminal option must be used interactively.");
				go to print_usage;
			     end;

			if arg_count = 3
			then do;

				call cu_$arg_ptr (3, arg_ptr, arg_len, code);

				if code ^= 0
				then go to print_error_usage;

				station_name = arg;
			     end;
			else do;

				call cmcs_terminal_ctl_$find (term_channel, station_name, code);
				if code ^= 0
				then do;
					call com_err_ (code, my_name,
					     "Attempting to find your terminal subchannel in the cmcs_terminal_ctl.control segment."
					     );
					return;
				     end;
			     end;

			user_ctl.station_name = station_name;
			user_ctl.terminal_sw = "1"b;
			user_ctl.process_type = 2;	/* user is a CMCS terminal */
		     end;

		call cmcs_station_ctl_$attach (station_name, station_ctl_eindex, code);

		if code ^= 0
		then do;				/* station already taken */

			call com_err_ (code, my_name,
			     "Attempting to attach station ""^a"". Returning to command level.", station_name);
			return;
		     end;

		user_ctl.station_name = station_name;
		user_ctl.station_ctl_eindex = station_ctl_eindex;
						/* save for disable checks */

	     end;

/* Initialization for use as terminal */

	if user_ctl.terminal_sw
	then do;

		allocate input_cd;			/* fixed size, no problem */
		output_cd_size = 100;		/* can be increased later, if desired */
		allocate output_cd_area;
		output_cd.bin_max_station_count = 10;	/* artificial command-interface  limitation */
		output_cd.char_max_station_count = 10;	/* artificial command-interface  limitation */

		call get_temp_segments_ (my_name, ptr_array, code);

		if code ^= 0
		then do;
			call com_err_ (code, my_name, "Attempting to get temp seg for send buffer.");
			return;
		     end;

		send_buffer_ptr = ptr_array (1);	/* only using one */
		send_buffer_max_len = 9999;		/* max no of chars a COBOL program can send at one time */
	     end;

	if ^user_ctl.mp_sw
	then do;					/* they just abort */

/* check for interrupted operations */

		on program_interrupt /* for all modes of use */
		     begin;
			call ioa_ ("Returning to request level.");
			go to nonlocal_request;	/* nonlocal goto */
		     end;

/* catch any release stack */
/*[4.4-7]*/
		on command_abort_ go to nonlocal_return;
		on cleanup go to nonlocal_return;	/* for all modes of use */
	     end;

	user_ctl.initialized_sw = "1"b;

/* Station Processing */

	if ^user_ctl.admin_sw			/* everyone else may need this */
	then do;

/* Any checks to force use only as daemon should go here */

		call ipc_$create_ev_chn (user_ctl.ev_wait_chn, code);

		if code ^= 0
		then do;
			call com_err_ (code, my_name,
			     "Attempting to create an event wait channel. Returning to command level.");
			go to nonlocal_return;
		     end;

		ev_wait_list.n_chn = 1;
		ev_wait_list.ev_chn (1) = user_ctl.ev_wait_chn;
		ev_wait_list_ptr, user_ctl.ev_wait_list_ptr = addr (ev_wait_list);
		ev_info_ptr, user_ctl.ev_info_ptr = addr (ev_info);
	     end;

	if user_ctl.mp_sw
	then do;

		call cmcs_wait_ctl_$mp_login (user_ctl.wait_ctl_mp_eindex, code);

		if code ^= 0
		then do;
			call com_err_ (code, my_name,
			     "Attempting to add process to list of logged-in message processors. Returning to command level."
			     );
			go to nonlocal_return;
		     end;

/* We are logged in, but not yet available. Set ptr to mp wait entry for subsequent wakeup prcessing. */

		wait_ctl_mp_eindex = user_ctl.wait_ctl_mp_eindex;
						/* set working value from saved value */
		wait_ctl_mp_eptr = addr (wait_ctl.mp_info.mp_entries (wait_ctl_mp_eindex));

mp_loop:
		call cmcs_wait_ctl_$mp_available (user_ctl.wait_ctl_mp_eindex, tree_ctl_eindex, code);

/* wakeup with an available message, hopefully */

		if code ^= 0
		then do;

			call com_err_ (code, my_name,
			     "Attempting to add process to list of available message processors. Returning to command level."
			     );
			go to nonlocal_return;
		     end;

/* So far, so good. Now check the ev_message to see what we are supposed to do. If 0, we process a message.
   If 1, we log out. If anything else, we complain, and wait for the next wakeup. Ho hum, what a life! */

		if ev_info.ev_message = 1
		then do;

mp_logout:
			call ioa_ ("Message Processor (Station ^a) returning to command level.",
			     user_ctl.station_name);
			call cmcs_wait_ctl_$mp_logout (wait_ctl_mp_eindex, code);
						/* we don't want any more wakeups */

			if code ^= 0
			then call com_err_ (code, my_name,
				"Attempting to request an mp_logout for this process. Continuing to log out.");

			go to nonlocal_return;
		     end;

		else if ev_info.ev_message ^= 0
		then do;

			code = error_table_$action_not_performed;
			call com_err_ (code, my_name,
			     "Invalid event message  received in wakeup. Returning to mp_loop.");

			go to mp_loop;

		     end;

/* Drop-thru means we must process a message in some queue specified in the mp wait entry */

/* process the returned tree_ctl_eindex */

		tree_ctl_eindex = wait_ctl_mp_entry.tree_ctl_eindex;
						/* the tree_ctl_entry has all the necessary info */
		tree_ctl_eptr = addr (tree_ctl.entries (tree_ctl_eindex));

		if ^(tree_ctl_entry.mp_sw | tree_ctl_entry.cobol_program_id_sw)
		then do;

			code = error_table_$action_not_performed;

mp_cmd_err:
			call com_err_ (code, my_name,
			     "Error found in command line syntax or execution for ""^a"". Returning to mp_loop.");

			go to mp_loop;

		     end;

		call ioa_$rsnnl ("^a ^a ^a", buffer, buffer_len,
		     substr (tree_ctl_entry.mp_line, 1, tree_ctl_entry.mp_line_len),
		     substr (tree_ctl_entry.cobol_program_id, 1, tree_ctl_entry.cobol_program_id_len),
		     string (tree_ctl_entry.tree_path));

		call cu_$cp (addr (buffer), fixed (buffer_len, 17), code);

		if code ^= 0
		then do;

			call com_err_ (code, my_name, "Executing command line (^a).  Returning to mp_loop.",
			     substr (buffer, 1, buffer_len));
		     end;

		go to mp_loop;
	     end;					/* of station processing */

/*[4.4-5]*/
declare	1 info_structure	aligned,			/*[4.4-5]*/
	  2 ev_chain	fixed bin (71),		/*[4.4-5]*/
	  2 input_available bit (1);

/*[4.4-5]*/
declare	timer_manager_$sleep
			entry (fixed bin (71), bit (2));
						/*[4.4-5]*/
declare	info_ptr		ptr;			/*[4.4-5]*/
declare	IOCB_ptr		ptr;

delay:
     proc;

/*[4.4-5]*/
	info_ptr = addr (info_structure);



/*[4.4-5]*/
	do while ("1"b);

/*[4.4-5]*/
	     call timer_manager_$sleep (1, "11"b);	/* 1 sec delay */
						/*[4.4-5]*/
	     call iox_$control (iox_$user_input, "read_status", info_ptr, code);

/*[4.4-5]*/
	     if info_structure.input_available
	     then go to GL;

/*[4.4-5]*/
	     call rec_messages;

/*[4.4-5]*/
	end;

     end;

rec_messages:
     proc;

/*[4.4-5]*/
	char_delim = "2";				/*[4.4-5]*/
	io_subtype = 2;				/*[4.4-5]*/
	all_bit = "1"b;				/*[4.4-5]*/
	string (input_cd.tree_path) = d_stat_path;

/*[4.4-5]*/
	user_ctl.rec = "1"b;			/*[4.4-5]*/
	call rec;					/*[4.4-5]*/
	user_ctl.rec = "0"b;


     end;

/* NONLOCAL REQUEST */

nonlocal_request:
read_request:					/*[4.4-5]*/
	if my_brief_name = "cmcs"
	then if user_ctl.attach_bit
	     then call delay;



GL:
	call iox_$get_line (iox_$user_input, addr (req), 256, req_len, code);

	if code ^= 0
	then do;
		if code = error_table_$long_record
		then do;

			call com_err_ (code, my_name, "Request lines must be <= 256 characters. Please reenter.");
			go to read_request;
		     end;
		else do;				/* unexpected problem */

			call com_err_ (code, my_name, "Attempting to read a request line from user_input.");
			return;
		     end;
	     end;

	if req_len = 1
	then go to read_request;			/* just spacing down the terminal */

/*[4.4-9]*/
	if substr (arg, 1, 2) = ".."			/*[4.4-9]*/
	then do;
		req_left_begin = 3;			/*[4.4-9]*/
		req_left_len = req_len - 2;

/*[4.4-9]*/
		go to command (2);			/*[4.4-9]*/
	     end;

	cmd_parsed_sw, args_parsed_sw = "0"b;		/* flags to control parsing */
	req_left_begin = 1;
	req_left_len = req_len - 1;			/* forget the trailing NL */

	call get_req_cmd;				/* strip off the command */

	if user_ctl.process_type = 2
	then do;

		do i = 1 to command_count;		/* try the brief forms first */
		     if arg = command_list.brief (i)
		     then go to command (i);
		end;

		do i = 1 to command_count;		/* likes to type */
		     if arg = command_list.long (i)
		     then go to command (i);
		end;

	     end;

	else if user_ctl.process_type = 3
	then do;

		do i = 1 to admin_command_count;	/* try the brief forms first */
		     if arg = admin_command_list.brief (i)
		     then go to admin_command (i);
		end;

		do i = 1 to admin_command_count;	/* likes to type */
		     if arg = admin_command_list.long (i)
		     then go to admin_command (i);
		end;

	     end;

	call com_err_ (0, my_name, "Unrecognized command ""^a"". Please reenter request.", arg);

	go to read_request;


cmcsa:
cobol_mcs_admin:
     entry;

	my_name = "cobol_mcs_admin";
	my_brief_name = "cmcsa";

	call cu_$arg_count (arg_count);

	if arg_count ^= 1
	then do;					/* needs help */

		call com_err_ (0, my_name, "Usage: cobol_mcs_admin cmcs_dir");
		return;
	     end;

	go to common_entry;

/* NONLOCAL RETURN */
/* quit */

command (1):
admin_command (2):					/*[4.4-5]*/
	if my_brief_name = "cmcs"
	then if user_ctl.attach_bit
	     then call rec_messages;

nonlocal_return:
	if ^user_ctl.admin_sw			/* do for everyone except admin */
	then do;

		if test_sw
		then call ioa_ ("Starting purge all before return.");
						/* DEBUG */

		call cobol_mcs_$stop_run ();

		if user_ctl.terminal_sw		/* no one else uses these */
		then do;

			if input_cdp ^= null ()
			then free input_cd;

			if output_cdp ^= null ()
			then free output_cd;

			if send_buffer_ptr ^= null ()
			then do;

				ptr_array (1) = send_buffer_ptr;

				call release_temp_segments_ (my_name, ptr_array, code);

				if code ^= 0
				then call com_err_ (code, my_name,
					"From releasing the send buffer segment. Continuing.");
			     end;
		     end;

		call ipc_$delete_ev_chn (user_ctl.ev_wait_chn, code);

		if code ^= 0
		then call com_err_ (code, my_name,
			"Attempting to delete the wait event channel. Please contact the CMCS Administrator. Continuing."
			);

		call cmcs_station_ctl_$detach (user_ctl.station_ctl_eindex, code);

		if code ^= 0
		then call com_err_ (code, my_name, "Attempting to detach the process station_name. Continuing.");
	     end;


	call cobol_mcs_$set_user_ctl_exists_sw ("0"b);	/* now illegal to use CMCS */

	external_user_ctl_ptr = null ();
	ptr_array (1) = user_ctl_ptr;			/*[5.2-1]*/
	if my_brief_name = "cmcs"			/*[5.2-1]*/
	then do;
		call release_temp_segments_ ("cobol_mcs", ptr_array, code);

		if code ^= 0
		then call com_err_ (code, my_name,
			"Attempting to release temporary segment for user_ctl. Continuing return to command level.")
			;			/*[5.2-1]*/
		call cmcs_initiate_ctl_$release (code); /*[5.2-1]*/
	     end;
	return;					/* execute */

command (2):
admin_command (3):
	call cu_$cp (addr (substr (req, req_left_begin, 1)), req_left_len, code);

	if code ^= 0
	then do;
		call com_err_ (code, my_name, "From execute request.");
	     end;

/*[4.4-5]*/
	if my_brief_name = "cmcs"
	then if user_ctl.attach_bit
	     then call rec_messages;

	go to read_request;


/* accept_message_count */

command (3):
	if test_sw
	then call ioa_ ("amc");

	io_subtype = 1;

	call get_req_arg_count;

	if arg_count ^= 1
	then do;

		call com_err_ (0, my_name, "Usage: accept_message_count tree_path");

		go to read_request;

	     end;


	call req_arg_ptr (1);

	call cmcs_expand_tree_path_ (arg, rcv_tree_path, code);

	if code ^= 0
	then do;

amc_error:
		call com_err_ (code, my_name, "From accept_message_count, using ""^a"".", arg);

		call cmcs_decode_status_ (iox_$user_output, input_cdp, 5, io_subtype, code);

		go to read_request;

	     end;



	string (input_cd.tree_path) = rcv_tree_path;



	call cobol_mcs_$accept (input_cdp, code);

	if code ^= 0
	then go to amc_error;

	call ioa_ ("Message count for ""^a"" is ^a.", arg, input_cd.msg_count);

	rcv_tree_path = "";				/* so we don't confuse receives */

	go to read_request;

/*[4.4-3]*/
declare	all_bit		bit (1);

/* receive */

command (4):
	if test_sw
	then call ioa_ ("receive");

/*[4.4-3]*/
	all_bit = "0"b;

	call get_req_arg_count;

	if arg_count = 0 | arg_count > 2
	then do;

		call com_err_ (0, my_name, "Usage: receive delim {tree_path}");
		go to read_request;
	     end;

	call req_arg_ptr (1);			/* get delimiter */

	if arg = "1" | arg = "esi"
	then do;					/* wants message segment */

		char_delim = "1";
		io_subtype = 1;
	     end;
	else if arg = "2" | arg = "emi"
	then do;					/* wants entire message */

		char_delim = "2";
		io_subtype = 2;
	     end;

/*[4.4-3]*/
	else if arg = "3" | arg = "all"		/*[4.4-3]*/
	then do;
		char_delim = "2";			/*[4.4-3]*/
		io_subtype = 2;			/* entire message */
						/*[4.4-3]*/
		all_bit = "1"b;			/*[4.4-3]*/
	     end;

	else do;

/*[4.4-3]*/
		call com_err_ (0, my_name, "Receive delimiter must be esi (1) or emi (2) or all (3).");
		go to read_request;
	     end;

	if arg_count = 2
	then do;					/* supplied the tree_path */

		call req_arg_ptr (2);
		call cmcs_expand_tree_path_ (arg, rcv_tree_path, code);

		if code ^= 0
		then do;

			call com_err_ (code, my_name, "Expanding ""^a"" to full tree path.", arg);
			go to read_request;
		     end;
	     end;
	else if rcv_tree_path = ""			/* didn't give new one, is old one ok? */
	then do;

		call com_err_ (0, my_name, "Previous tree path is blank. Please reenter request with new tree path.");

		go to read_request;
	     end;

	string (input_cd.tree_path) = rcv_tree_path;

/*[4.4-3]*/
	call rec;

	if code ^= 0
	then do;

		call com_err_ (code, my_name, "From receive.");
		call cmcs_decode_status_ (iox_$user_output, input_cdp, 2, io_subtype, code);

		if code ^= 0
		then call com_err_ (code, my_name, "From the status decode.");

	     end;

	if input_cd.text_delim = 0 | input_cd.text_delim = 1
	then rcv_tree_path = string (input_cd.tree_path); /* partial message, keep abs tree path */
	else rcv_tree_path = "";			/* nullify for complete messages and rcv errors */

	go to read_request;

rec:
     proc;

/*[4.4-3]*/
declare	mess_bit		bit (1);

/*[4.4-3]*/
	mess_bit = "0"b;

/*[4.4-3]*/
	do while ("1"b);

/*[4.4-3]*/
	     call cmcs_queue_ctl_$print (input_cdp, io_subtype, IOCB_ptr, code);

/*[4.4-3]*/
	     if ^all_bit
	     then return;

/*[4.4-3]*/
	     if code ^= 0				/*[4.4-3]*/
	     then do;
		     if code = cmcs_error_table_$no_message & (mess_bit | user_ctl.attach_bit)
		     then code = 0;

/*[4.4-3]*/
		     return;			/*[4.4-3]*/
		end;

/*[4.4-3]*/
	     mess_bit = "1"b;			/*[4.4-3]*/
	end;

     end;

/* send */

command (5):
	if test_sw
	then call ioa_ ("send");

	send_buffer_len = 0;			/* start fresh each time */

	call get_req_arg_count;			/* for initial checks */

	if arg_count < 2
	then do;					/* doesn't know how to use */

		call com_err_ (0, my_name, "Usage: send delim dest1 {dest2 ... destn}");
		go to read_request;
	     end;
	else if arg_count > 11
	then do;

		call com_err_ (0, my_name,
		     "Only 10 destinations can be specified in the send request. Please reenter request.");
		go to read_request;
	     end;

	call req_arg_ptr (1);			/* get message delim */

	if arg = "1" | arg = "esi"
	then do;					/* send data as message segment */

		char_delim = "1";			/* for cobol_mcs_ interface */
		io_subtype = 1;			/* for internal interfaces */
	     end;
	else if arg = "2" | arg = "emi"
	then do;					/* send data as complete message */

		char_delim = "2";
		io_subtype = 2;
	     end;
	else if arg = "3" | arg = "egi"
	then do;					/* egi same as emi */

		char_delim = "3";
		io_subtype = 3;

	     end;
	else do;

		call com_err_ (0, my_name, "The send delimiter must be esi (1), emi (2), or egi (3).");
		go to read_request;
	     end;

	call fill_dest_table (2);			/* arg 2 = 1st dest name */

send_loop:
	call iox_$get_line (iox_$user_input, buffer_ptr, buffer_max_len, buffer_len, code);

	if code ^= 0
	then do;

		call com_err_ (code, my_name, "While doing a get_line for the send data.");

		go to read_request;
	     end;

	if buffer_len = 2
	then if substr (buffer, 1, 1) = "."
	     then do;

		     if send_buffer_len = 0
		     then do;			/* tried to send a null message */

			     call com_err_ (0, my_name, "Send data must be non-null. Returning to request level.");

			     go to read_request;
			end;

/*[4.4-1]*/
		     if substr (send_buffer, send_buffer_len, 1) = "
"						/*[4.4-1]*/
		     then send_buffer_len = send_buffer_len - 1;

		     output_cd.text_len = send_buffer_len;

		     call cobol_mcs_$send (output_cdp, send_buffer_ptr, "9999", char_delim, (36)"0"b, code);

		     if code ^= 0
		     then do;

			     call com_err_ (code, my_name, "From send.");
			     call cmcs_decode_status_ (iox_$user_output, output_cdp, 1, io_subtype, code);

			     if code ^= 0
			     then call com_err_ (code, my_name, "From decode of status information.");
			end;

		     go to read_request;
		end;

	if send_buffer_len + buffer_len > send_buffer_max_len
	then do;					/* should never happen, but just in case... */

		call com_err_ (0, my_name,
		     "You have exceeded the maximum amount of input to the send request (^d characters).
	Returning to request level.", send_buffer_max_len);

		go to read_request;
	     end;

	substr (send_buffer, send_buffer_len + 1, buffer_len) = substr (buffer, 1, buffer_len);
	send_buffer_len = send_buffer_len + buffer_len;

	go to send_loop;

/* enable_input */

command (6):
	if test_sw
	then call ioa_ ("ei");

	io_subtype = 1;

	call get_req_arg_count;

	if arg_count ^= 1
	then do;

		call com_err_ (0, my_name, "Usage: enable_input tree_path");
		go to read_request;
	     end;

	call req_arg_ptr (1);
	call cmcs_expand_tree_path_ (arg, rcv_tree_path, code);

	if code ^= 0
	then do;

ei_error:
		call com_err_ (code, my_name, "From enable_input.");
		call cmcs_decode_status_ (iox_$user_output, input_cdp, 3, io_subtype, code);

		go to read_request;
	     end;

	string (input_cd.tree_path) = rcv_tree_path;

	call get_password;

	call cobol_mcs_$enable_input_queue (input_cdp, password1, code);

	if code ^= 0
	then go to ei_error;

	go to read_request;


/* enable_input_terminal */

command (7):
	if test_sw
	then call ioa_ ("eit");

	io_subtype = 2;

	call get_req_arg_count;

	if arg_count ^= 1
	then do;
		call com_err_ (0, my_name, "Usage: enable_input_terminal station_name");
		go to read_request;
	     end;

	call get_password;

	call req_arg_ptr (1);

	input_cd.station_name = arg;

	call cobol_mcs_$enable_input_terminal (input_cdp, password1, code);

	if code ^= 0
	then do;

		call com_err_ (code, my_name, "From enable_input_terminal.");
		call cmcs_decode_status_ (iox_$user_output, input_cdp, 3, io_subtype, code);

		go to read_request;
	     end;

	go to read_request;


/* enable_output */

command (8):
	if test_sw
	then call ioa_ ("eo");

	io_subtype = 3;

	call get_req_arg_count;

	if arg_count = 0
	then do;

		call com_err_ (0, my_name, "Usage: enable_output dest1 {dest2 ... dest10}");
		go to read_request;
	     end;

	call get_password;
	call fill_dest_table (1);

	call cobol_mcs_$enable_output (output_cdp, password1, code);

	if code ^= 0
	then do;

		call com_err_ (code, my_name, "From enable_output");
		call cmcs_decode_status_ (iox_$user_output, output_cdp, 3, io_subtype, code);

		go to read_request;
	     end;

	go to read_request;


/* disable_input */

command (9):
	if test_sw
	then call ioa_ ("di");

	io_subtype = 1;

	call get_req_arg_count;

	if arg_count ^= 1
	then do;

		call com_err_ (0, my_name, "Usage: disable_input tree_path");
		go to read_request;
	     end;

	call req_arg_ptr (1);
	call cmcs_expand_tree_path_ (arg, rcv_tree_path, code);

	if code ^= 0
	then do;

di_error:
		call com_err_ (code, my_name, "From disable_input.");
		call cmcs_decode_status_ (iox_$user_output, input_cdp, 4, io_subtype, code);

		go to read_request;
	     end;

	string (input_cd.tree_path) = rcv_tree_path;

	call get_password;

	call cobol_mcs_$disable_input_queue (input_cdp, password1, code);

	if code ^= 0
	then go to di_error;

	go to read_request;


/* disable_input_terminal */

command (10):
	if test_sw
	then call ioa_ ("dit");

	io_subtype = 2;

	call get_req_arg_count;

	if arg_count ^= 1
	then do;

		call com_err_ (0, my_name, "Usage: disable_input_terminal station_name");
		go to read_request;
	     end;

	call get_password;
	call req_arg_ptr (1);

	input_cd.station_name = arg;

	call cobol_mcs_$disable_input_terminal (input_cdp, password1, code);

	if code ^= 0
	then do;

		call com_err_ (code, my_name, "From disable_input_terminal.");
		call cmcs_decode_status_ (iox_$user_output, input_cdp, 4, io_subtype, code);

		go to read_request;
	     end;

	go to read_request;


/* disable_output */

command (11):
	if test_sw
	then call ioa_ ("do");

	io_subtype = 3;

	call get_req_arg_count;

	if arg_count = 0
	then do;

		call com_err_ (0, my_name, "Usage: disable_output dest1 {dest2 ... dest10}");

		go to read_request;
	     end;

	call fill_dest_table (1);
	call get_password;

	call cobol_mcs_$disable_output (output_cdp, password1, code);

	if code ^= 0
	then do;

		call com_err_ (code, my_name, "From disable_output");
		call cmcs_decode_status_ (iox_$user_output, output_cdp, 4, io_subtype, code);

		go to read_request;
	     end;

	go to read_request;


/* purge */

command (12):
	if test_sw
	then call ioa_ ("purge");

	io_subtype = 1;

	call get_req_arg_count;

	if arg_count = 0
	then do;

print_purge_usage:
		call com_err_ (0, my_name, "Usage: purge s {dest1 dest2 ... {dest10}");

		go to read_request;

	     end;

	call req_arg_ptr (1);

	if arg ^= "s"
	then go to print_purge_usage;

	if arg_count > 1
	then do;

		call fill_dest_table (2);

		call cobol_mcs_$purge (output_cdp, code);
						/* sends only, for cmd interface */

		if code ^= 0
		then do;

			call com_err_ (code, my_name, "From purge");
			call cmcs_decode_status_ (iox_$user_output, output_cdp, 6, io_subtype, code);

		     end;
	     end;
	else do;

		call cobol_mcs_$purge (null (), code);
		if code ^= 0
		then call com_err_ (code, my_name, "From purge.");

	     end;

	go to read_request;

/*activate */

command (14):					/* activate [ station_name [ path_name ]] */
						/*[4.4-5]*/
	if user_ctl.attach_bit			/*[4.4-5]*/
	then do;
		call com_err_ (0, my_name, "Station already activated");
						/*[4.4-5]*/
		go to read_request;			/*[4.4-5]*/
	     end;

/*[4.4-5]*/
	call get_req_arg_count;

/*[4.4-5]*/
	if arg_count > 2				/*[4.4-5]*/
	then do;
		call bad_attach;			/*[4.4-5]*/
		go to read_request;			/*[4.4-5]*/
	     end;

/*[4.4-5]*/
	go to A (arg_count);			/* activate */
A (0):						/*[4.4-5]*/
	ARG = user_ctl.station_name;
	user_ctl.iocb_ptr = null ();			/*[4.4-5]*/
	go to A0;					/* activate station-name */
A (1):						/*[4.4-5]*/
	call save_station;
	user_ctl.iocb_ptr = null ();			/*[4.4-5]*/
	go to A0;					/* activate station-name file_name */
A (2):						/*[4.4-5]*/
	call save_station;				/*[4.4-5]*/
	call save_path (2);				/*[4.4-5]*/
	go to A0;

A0:						/*[4.4-5]*/
	call cmcs_tree_ctl_$find_qual_name (ARG, a_index, a_eptr, d_stat_path, code);

/*[4.4-5]*/
	if code ^= 0				/*[4.4-5]*/
	then do;
		d_stat_path = "";			/*[4.4-5]*/
		call com_err_ (code, my_name, "illegal destination");
						/*[4.4-5]*/
	     end;

/*[4.4-5]*/
	user_ctl.attach_bit = "1"b;

/*[4.4-5]*/
	go to read_request;

/*[4.4-5]*/
declare	a_index		fixed bin,
	a_eptr		ptr;			/*[4.4-5]*/
declare	ARG		char (12);		/*[4.4-5]*/
declare	d_stat_path	char (52);


/* deactivate */

command (15):					/* deactivate */
						/*[4.4-5]*/
	if ^user_ctl.attach_bit			/*[4.4-5]*/
	then do;
		call com_err_ (0, my_name, "Station already deactivated");
						/*[4.4-5]*/
		go to read_request;			/*[4.4-5]*/
	     end;

/*[4.4-5]*/
	if user_ctl.iocb_ptr ^= null ()		/*[4.4-5]*/
	then do;
		call iox_$close (user_ctl.iocb_ptr, code);
						/*[4.4-5]*/
		call code_test;			/*[4.4-5]*/
		call iox_$detach_iocb (user_ctl.iocb_ptr, code);
						/*[4.4-5]*/
		call code_test;			/*[4.4-5]*/
	     end;

/*[4.4-5]*/
	user_ctl.attach_bit = "0"b;			/*[4.4-5]*/
	user_ctl.output_file = "";			/*[4.4-5]*/
	user_ctl.iocb_ptr = null ();			/*[4.4-5]*/
	IOCB_ptr = iox_$user_output;

/*[4.4-5]*/
	go to read_request;

save_station:
     proc;

/*[4.4-5]*/
	call req_arg_ptr (1);

/*[4.4-5]*/
	ARG = arg;
     end;

save_path:
     proc (arg_num);

/*[4.4-5]*/
declare	arg_num		fixed bin;

/*[4.4-5]*/
	call req_arg_ptr (arg_num);

/*[4.4-5]*/
	call exp;

/*[4.4-5]*/
	call iox_$attach_name /*[4.4-5]*/ ("A",		/*[4.4-5]*/
	     user_ctl.iocb_ptr,			/*[4.4-5]*/
	     "vfile_ " || substr (dname, 1, dsz) || ">" || substr (ename, 1, esz) || " -extend",
						/*[4.4-5]*/
	     null (),				/*[4.4-5]*/
	     code /*[4.4-5]*/);

/*[4.4-5]*/
	call code_test;

/*[4.4-5]*/
	call iox_$open (user_ctl.iocb_ptr, 2, "0"b, code);

/*[4.4-5]*/
	call code_test;

/*[4.4-5]*/
	IOCB_ptr = user_ctl.iocb_ptr;
     end;

code_test:
     proc;

/*[4.4-5]*/
	if code ^= 0				/*[4.4-5]*/
	then do;
		call com_err_ (code);

/*[4.4-5]*/
		go to read_request;			/*[4.4-5]*/
	     end;
     end;

bad_attach:
     proc;

/*[4.4-5]*/
	call com_err_ (0, my_name, "Usage: attach [atation-name] ");

     end;



/* change_cmcs_password */

admin_command (5):
	if test_sw
	then call ioa_ ("Command ""change_cmcs_password"":");

	scpsw_sw = "0"b;				/* check old psw before resetting it */

	call ioa_ ("Old password will be requested and then new password will be requested.");
	call get_password;

	scpsw_sw = "1"b;

common_password:
	call get_password;				/* if we return here, we checked out ok */

	system_ctl.password = password2;		/* changed from now on */

	go to read_request;

/* set_cmcs_password */

admin_command (6):
	if test_sw
	then call ioa_ ("Command ""set_cmcs_password"":");
	scpsw_sw = "1"b;				/* don't check old psw before resetting it */

	go to common_password;



/* create_cmcs_queues */

admin_command (7):
	if test_sw
	then call ioa_ ("Command ""create_cmcs_queues"":");

	call cmcs_create_queues_ (code);

	if code ^= 0
	then do;
		call com_err_ (code, my_name);
	     end;

	go to read_request;

/* who am I? */

command (13):
admin_command (1):
	if user_ctl.process_type = 2
	then call ioa_ ("^a, ^a", my_brief_name, user_ctl.station_name);
	else call ioa_ ("^a", my_brief_name);

	go to read_request;


/* test */

admin_command (4):
	call get_req_arg_count;

	call ioa_ ("Arg count is ^d.", arg_count);

	go to read_request;

/* stop_mp */

admin_command (9):
	call cmcs_wait_ctl_$stop_mp (code);

	if code ^= 0
	then call com_err_ (code, my_name, "Attempting to issue ""stop_mp"" command. Returning to request level.");

	go to read_request;

/* */

/* clear_mp */

admin_command (10):
	call cmcs_wait_ctl_$clear_mp (code);

	if code ^= 0
	then call com_err_ (code, my_name, "Attempting to perform clear_mp request. Returning to request level.");

	go to read_request;


/* */

/* start_mp */
admin_command (8):
	call cmcs_wait_ctl_$start_mp (code);

	if code ^= 0
	then call com_err_ (code, my_name, "Attempting to perform start_mp request. Returning to request level.");

	go to read_request;

/*  */

/* purge_queues */
admin_command (11):					/* This request currently purges all queues and all records with status 1 and status 4 are deleted.
   Records with status 3 are moved back to status 2. Records with status 2 are left as-is.
   This request must be executed only when no other users of the given CMCS environment are on the system
   because no attempt is made to determine that a message is being processed by another process. */
	if test_sw
	then call ioa_ ("Command ""purge_queues"":");

	call cmcs_purge_queues_ (0, "1"b, code);

	if code ^= 0
	then call com_err_ (code, my_name, "From the purge_queues request. Returning to request level.");

	go to read_request;

/* */

/* Parsing Procedures */

get_req_cmd:
     proc;

	if ^cmd_parsed_sw
	then do;

		call parse_args;
		req_cmd_ptr = arg_ptr;		/* save for later reference */
		req_cmd_len = arg_len;
	     end;
	else do;

		arg_ptr = req_cmd_ptr;		/* retrieve previously set values */
		arg_len = req_cmd_len;
	     end;

	return;

     end /* get_req_cmd */;

/* */

get_req_arg_count:
     proc;

	if ^cmd_parsed_sw
	then call parse_args;

	if ^args_parsed_sw
	then do;

		call parse_args;
		req_arg_count = arg_count;		/* save for later reference */
		args_parsed_sw = "1"b;
	     end;
	else arg_count = req_arg_count;

	return;

     end /* get_req_arg_count */;

/* */

req_arg_ptr:
     proc (arg_no);

dcl	arg_no		fixed bin;

	call get_req_arg_count;			/* make sure everything is set up */

	arg_ptr = arg_array (arg_no).argp;
	arg_len = arg_array (arg_no).argl;

	return;

     end /* req_arg_ptr */;

/* */

parse_args:
     proc;

	arg_count = 0;

	do j = 1 to max_req_args while (req_left_len > 0);

	     i = verify (substr (req, req_left_begin, req_left_len), whitespace);
						/* find first nonblank */

	     if i ^= 0
	     then do;				/* found another arg */

		     arg_count = arg_count + 1;
		     req_left_begin = req_left_begin + i - 1;
		     req_left_len = req_left_len - i + 1;
		end;
	     else req_left_len = 0;			/* no more args, stop looking */

	     arg_ptr = addr (substr (req, req_left_begin, 1));

	     i = search (substr (req, req_left_begin, req_left_len), whitespace);
						/* find end of arg */

	     if i ^= 0
	     then arg_len = i - 1;
	     else arg_len = req_left_len;

	     req_left_begin = req_left_begin + arg_len;	/* set for next iteration now or later */
	     req_left_len = req_left_len - arg_len;

	     if ^cmd_parsed_sw
	     then do;

		     cmd_parsed_sw = "1"b;		/* avoid infinite loop */
		     code = 0;

		     return;			/* that's all we need this time */
		end;

	     arg_array (arg_count).argp = arg_ptr;
	     arg_array (arg_count).argl = arg_len;

	end;					/* of parse loop */

	if req_left_len ^= 0
	then code = error_table_$too_many_args;
	else code = 0;

	return;

     end /* parse_args */;

/*  */

set_interactive_info:
     proc;

	call user_info_$absentee_queue (i);		/* to see if we're interactive */

	if i ^= -1
	then interactive_sw = "0"b;			/* No, Virginia */
	else do;

		interactive_sw = "1"b;		/* yes, Virginia */

		call user_info_$tty_data (term_id, term_type, term_channel);

		user_ctl.interactive_sw = "1"b;
		user_ctl.term_id = term_id;
		user_ctl.term_type = term_type;
		user_ctl.term_channel = term_channel;
	     end;
	return;

     end /* set_interactive_info */;

/* */

get_password:
     proc ();

	if interactive_sw				/* should be done interactively but... */
	then do;

request_password:
		call read_password_ ("Input COBOL MCS password:", password1);
		call read_password_ ("Please repeat for verification...", password2);

		if password1 ^= password2
		then do;

			call com_err_ (0, my_name, "Passwords do not match. Please repeat.");

			go to request_password;

		     end;

encode_password:
		password2 = cmcs_scramble_ (password1); /* maintain secure passwords */

		if ^scpsw_sw
		then if password2 ^= system_ctl.password/* change, not set */
		     then do;			/* not what it's thought to be */

			     call com_err_ (cmcs_error_table_$bad_password, my_name, "Returning to request level.");

			     go to read_request;

			end;
		scpsw_sw = "0"b;			/* reset so we check the next time */
	     end;
	else do;

		call com_err_ (error_table_$action_not_performed, my_name,
		     "Passwords for COBOL MCS must be changed either by COBOL program or interactively.");

		go to read_request;

	     end;
	return;

     end /* get_password */;

/*  */

fill_dest_table:
     proc (x_arg_no);

dcl	x_arg_no		fixed bin;		/* starting arg number */

	err_sw = "0"b;
	dest_table_index = 0;			/* initialize */

	do i = x_arg_no to arg_count;

	     call req_arg_ptr (i);
	     station_name = arg;			/* for fixed 12 char size */

	     call cmcs_station_ctl_$validate (station_name, station_ctl_eindex, code);

	     if code ^= 0
	     then do;

		     err_sw = "1"b;
		     call com_err_ (code, my_name, """^a"".", station_name);
		end;
	     else do;

		     dest_table_index = dest_table_index + 1;
		     output_cd.dest_table (dest_table_index).station_name = station_name;
		end;
	end;

	if err_sw
	then do;

		call com_err_ (error_table_$action_not_performed, my_name, "Please reenter request.");

		go to read_request;			/* non-local */
	     end;

	output_cd.station_count = dest_table_index;
	code = 0;

	return;

     end /* fill_dest_table */;


exp:
     proc;

/*[4.4-5]*/
	call expand_pathname_ (arg, dname, ename, code);

/*[4.4-5]*/
	call code_test;

/*[4.4-5]*/
	dsz = index (dname, " ");			/*[4.4-5]*/
	if dsz <= 0
	then dsz = 168;
	else dsz = dsz - 1;

/*[4.4-5]*/
	esz = index (ename, " ");			/*[4.4-5]*/
	if esz <= 0
	then esz = 32;
	else esz = esz - 1;

     end;

/*[4.4-5]*/
declare	(dsz, esz)	fixed bin;

test:
     entry ();

	test_sw = "1"b;
	return;

     end /* cobol_mcs */;
