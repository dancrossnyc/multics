/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(1985-12-19,Herbst), approve(1986-03-25,MCR7367),
     audit(1986-04-28,Margolin), install(1986-05-22,MR12.0-1059):
     Added $switch_on_request and $switch_off_request.
  2) change(1986-02-27,Herbst), approve(1986-03-25,MCR7367),
     audit(1986-04-28,Margolin), install(1986-05-22,MR12.0-1059):
     Changed print request to turn on message's seen switch.
  3) change(1986-03-25,Herbst), approve(1986-03-25,MCR7367),
     audit(1986-04-28,Margolin), install(1986-05-22,MR12.0-1059):
     Changed switch_type from fixed bin to char (4) aligned.
  4) change(1986-04-01,Herbst), approve(1986-04-01,MCR7367),
     audit(1986-04-28,Margolin), install(1986-05-22,MR12.0-1059):
     Moved request entry points here from rdm_message_mark_mgr_.
  5) change(1986-04-04,Herbst), approve(1986-04-04,MCR7367),
     audit(1986-04-28,Margolin), install(1986-05-22,MR12.0-1059):
     Fixed to print a blank line for "new" request if no new messages.
  6) change(1986-04-28,Herbst), approve(1986-04-28,MCR7367),
     audit(1986-04-28,Margolin), install(1986-05-22,MR12.0-1059):
     Changed error message for invalid request arguments.
  7) change(1989-04-03,Lee), approve(1989-05-10,MCR8104),
     audit(1989-07-18,LZimmerman), install(1989-10-02,MR12.3-1079):
     phx20589, Mail 502 - added test in perform_list_request to prevent the
     current message from being changed if called as an active function.
  8) change(1989-04-03,Lee), approve(1989-05-10,MCR8104),
     audit(1989-07-18,LZimmerman), install(1989-10-02,MR12.3-1079):
     phx19118, Mail 459 - corrected direction of comparison in "-btt" test for
     valid date/time range.
  9) change(1989-04-07,Lee), approve(1989-05-10,MCR8104),
     audit(1989-07-18,LZimmerman), install(1989-10-02,MR12.3-1079):
     phx19099, phx15783, Mail 457 - added message_type parameter to call to
     rdm_message_mark_mgr_$mark_current_message to catch use of "-odl" with
     the current message.
 10) change(1989-04-11,Lee), approve(1989-05-10,MCR8104),
     audit(1989-07-18,LZimmerman), install(1989-10-02,MR12.3-1079):
     phx18564, phx17540, phx17353, Mail 446 - the new entry set_new_current_msg
     in rdm_mailbox_interface_ is now called when the current message is
     changed to guarantee that the new current message is never a deleted
     message; reformatting.
 11) change(1991-12-17,Huen), approve(1991-12-17,MCR8239),
     audit(1992-02-13,Zimmerman), install(1992-04-24,MR12.5-1013):
     Fix mail_362 - check for new messages after every request line.
 12) change(2016-01-15,Swenson), approve(2016-01-15,MCR10003):
     Fix to support 4-character time zone abbreviations.
                                                   END HISTORY COMMENTS */


/* format: off */

/* read_mail message handling requests: list, print, print_header, delete, retrieve
   send_mail original message handling requests: list_original, print_original, print_original_header
   forward original message handling sub-requests: print_original */

/* Created:  Late 1978 by W. Olin Sibert */
/* Recoded:  30 December 1979 by W. Olin Sibert to add extended selection control arguments */
/* Modified: 1 January 1980 by W. Olin Sibert to fix more bugs in setting the current message */
/* Modified: 1 June 1980 by G. Palter address the following entries on the mail system error list --
      #0263: current message in read_mail should be set to the message being processed - thus, if an error occurs, the
	   current message will remain on which the error occured;
      #0186: there should be a "print_original" request in send_mail which prints the message being replied to when
	   invoked by read_mail's "reply" request */
/* Modified: 4 June 1980 by G. Palter address the following entries on the mail system error list --
      #0293: read_mail's "print" request accepts the "-delete" control argument, but doesn't honor it;
      #0219: listing by "-redistributed_to" or "-recipient" faults because of the organization of forwarding fields */
/* Modified: 3 November 1981 by W. Olin Sibert to fix bug #0219, again */
/* Modified: 30 March 1982 by G. Palter to address the following entries on the mail system error list --
      #0299: the "-brief", "-long", and "-mseg_info" control arguments of the "list" request are not implemented; and
      #0283: add "-line_length" and "-no_line_length" control arguments to the "list" request */
/* Modified: 24 September 1982 by G. Palter to use the same control arguments to specify case sensitivity as the new
      sort_seg command */
/* Modified: 8 October 1982 by G. Palter to not reference sys_info$time_correction_constant */
/* Modified: 28 October 1982 by G. Palter to make case insensitive searching work and to make the "-recipient" control
      argument properly recognize regular expression matching */
/* Modified: October 1983 by G. Palter as part of the conversion to the new mail system interface */

/* format: on,style4,delnl,insnl,ifthenstmt,ifthen */


rdm_msg_requests_:
     procedure (P_sci_ptr, P_rdm_invocation_ptr);

	return;					/* not an entry */


/* Parameters */

dcl  P_sci_ptr pointer parameter;
dcl  P_rdm_invocation_ptr pointer parameter;


/* Remaining declarations */

dcl  is_original_request bit (1) aligned;		/* ON => invoked from send_mail or forward sub-request loop */
dcl  saved_rdm_sci_ptr pointer;

dcl  msg_spec_array (msg_spec_array_size) fixed binary based (msg_spec_array_ptr);
dcl  (msg_spec_array_size, msg_spec_count) fixed binary;
dcl  msg_spec_array_ptr pointer;

dcl  1 class_sw aligned,				/* which types of selection control arguments are given */
       2 time bit (1) unaligned,
       2 subject bit (1) unaligned,
       2 sender bit (1) unaligned,
       2 recipient bit (1) unaligned;
dcl  class_count (4) fixed binary;			/* count of each class of selection */

dcl  1 sel aligned based (sel_ptr),
       2 class fixed binary,				/* class of selection -- time, text, sender, recipient */
       2 type fixed binary,				/* which header field for all but time selections */
       2 time_1 fixed binary (71),			/* for date/time selections ... */
       2 time_2 fixed binary (71),			/* ... */
       2 string,					/* for string matching */
         3 regexp_sw bit (1) aligned,			/* ON => string is a regular expression */
         3 str_lth fixed binary (21),
         3 str_ptr pointer,
       2 address_ptr pointer;				/* -> address for address matching */
dcl  sel_ptr pointer;

dcl  1 selection_array aligned based (selection_array_ptr),
       2 array (n_selections) like sel;
dcl  selection_array_ptr pointer;
dcl  n_selections fixed binary;

dcl  1 local_fmo aligned like format_message_options;
dcl  formatting_mode fixed binary;

dcl  (request, other_keyword_type) fixed binary;
dcl  active_request bit (1) aligned;
dcl  switch_type char (4) aligned;
dcl  (argument_idx, first_argument, n_arguments) fixed binary;
dcl  message_number_string char (8) varying;
dcl  output_buffer char (256) varying;
dcl  output_line_length fixed bin;

dcl  return_value character (return_value_max_lth) varying based (return_value_ptr);
dcl  return_value_ptr pointer;
dcl  return_value_max_lth fixed binary (21);

dcl  (argument, control_argument) character (argument_lth) based (argument_ptr);
dcl  argument1 character (argument1_lth) based (argument1_ptr);
dcl  argument2 character (argument2_lth) based (argument2_ptr);
dcl  (argument_ptr, argument1_ptr, argument2_ptr) pointer;
dcl  (argument_lth, argument1_lth, argument2_lth) fixed binary (21);

dcl  msg_type fixed binary;

dcl  (listing_header_sw, force_sw, delete_sw, reverse_sw, dl_rt_sw, case_independence_sw) bit (1) aligned;
dcl  listing_line_length fixed binary;

dcl  (first_message_idx, last_message_idx, message_idx_increment, message_idx, message_number) fixed binary;
dcl  idx fixed binary;

dcl  code fixed binary (35);

dcl  iox_$user_output pointer external;

/* format: off */
dcl (error_table_$badarg, error_table_$badopt, error_table_$noarg, error_table_$nomatch,
     mlsys_et_$null_search_string, ssu_et_$unimplemented_request)
	fixed binary (35) external;

dcl (LIST_REQUEST		initial (1),
     PRINT_REQUEST		initial (2),
     PRINT_HEADER_REQUEST	initial (3),
     DELETE_REQUEST		initial (4),
     RETRIEVE_REQUEST	initial (5),
     SWITCH_OFF_REQUEST	initial (6),
     SWITCH_ON_REQUEST	initial (7),
     OTHER_REQUEST		initial (8))
	fixed binary static options (constant);

dcl (LIST_INFO		initial ("1"b),
     JUST_LIST_NUMBERS	initial ("0"b))
	bit (1) aligned static options (constant);

dcl (SUBJECT_CLASS		initial (1),
     TIME_CLASS		initial (2),
     SENDER_CLASS		initial (3),
     RECIPIENT_CLASS	initial (4))
	fixed binary static options (constant);

dcl (ONE_DAY		initial (86399999999),	/* one microsecond less than 1 day */
     BEGINNING_OF_TIME	 initial (86400000000),	/* 1 January 1901 midnight GMT */
     END_OF_TIME		 initial (3122064000000000))	/* 1 January 1999 midnight GMT */
	fixed binary (71) static options (constant);

dcl (LOWERCASE	initial ("abcdefghijklmnopqrstuvwxyz"),
     UPPERCASE	initial ("ABCDEFGHIJKLMNOPQRSTUVWXYZ"))
	character (26) static options (constant);
/* format: on */

dcl  NULL_STRING character (1) static options (constant) initial ("");
dcl  SLASH character (1) static options (constant) initial ("/");

dcl  convert_date_to_binary_ entry (character (*), fixed binary (71), fixed binary (35));
dcl  cu_$grow_stack_frame entry (fixed binary (19), pointer, fixed binary (35));
dcl  cv_dec_check_ entry (character (*), fixed binary (35)) returns (fixed binary (35));
dcl  decode_clock_value_$date_time
	entry (fixed binary (71), fixed binary, fixed binary, fixed binary, fixed binary, fixed binary, fixed binary,
	fixed binary (71), fixed binary, character (4), fixed binary (35));
dcl  encode_clock_value_
	entry (fixed binary, fixed binary, fixed binary, fixed binary, fixed binary, fixed binary, fixed binary (71),
	fixed binary, character (4), fixed binary (71), fixed binary (35));
dcl  get_line_length_$switch entry (ptr, fixed bin (35)) returns (fixed bin);
dcl  ioa_ entry () options (variable);
dcl  iox_$control entry (pointer, character (*), pointer, fixed binary (35));
dcl  mail_system_$compare_addresses entry (pointer, pointer, fixed binary (35)) returns (bit (1) aligned);
dcl  mail_system_$free_address entry (pointer, fixed binary (35));
dcl  mail_system_$set_message_switch entry (ptr, char (4) aligned, bit (1) aligned, fixed bin (35));
dcl  mlsys_utils_$parse_address_control_args entry (pointer, fixed binary, pointer, pointer, fixed binary (35));
dcl  mlsys_utils_$print_message entry (pointer, pointer, pointer, fixed binary (35));
dcl  mlsys_utils_$print_message_summary
	entry (pointer, fixed binary, bit (1) aligned, fixed binary, pointer, fixed binary (35));
dcl  mlsys_utils_$print_message_summary_header entry (fixed binary, pointer, fixed binary (35));
dcl  pathname_ entry (char (*), char (*)) returns (char (168));
dcl  rdm_mailbox_interface_$delete_messages entry (pointer, bit (1) aligned);
dcl  rdm_mailbox_interface_$mark_processed entry (pointer, fixed binary);
dcl  rdm_mailbox_interface_$mark_processed_and_acknowledge entry (pointer, fixed binary);
dcl  rdm_mailbox_interface_$read_message entry (pointer, fixed binary, pointer, fixed binary (35));
dcl  rdm_mailbox_interface_$retrieve_messages entry (pointer);
dcl  rdm_mailbox_interface_$set_new_current_msg entry (ptr, fixed binary, fixed binary);
dcl  rdm_message_mark_mgr_$clear_marked_messages entry (pointer);
dcl  rdm_message_mark_mgr_$do_request entry (ptr, ptr, fixed bin, fixed bin, bit (1) aligned);
dcl  rdm_message_mark_mgr_$mark_all_messages entry (pointer, fixed binary);
dcl  rdm_message_mark_mgr_$mark_current_message entry (pointer, fixed binary);
dcl  rdm_message_mark_mgr_$mark_messages
	entry (pointer, pointer, fixed binary (21), fixed binary, bit (*), fixed binary (35));
dcl  rdm_message_mark_mgr_$remark_original_messages entry (pointer);
dcl  rdm_search_utils_$prepare_address_list_field_for_search
	entry (pointer, fixed binary, character (*) varying, pointer, pointer, fixed binary (21));
dcl  rdm_search_utils_$prepare_message_references_field_for_search
	entry (pointer, fixed binary, character (*) varying, pointer, pointer, fixed binary (21));
dcl  requote_string_ entry (char (*)) returns (char (*));
dcl  search_file_$silent
	entry (pointer, fixed binary (21), fixed binary (21), pointer, fixed binary (21), fixed binary (21),
	fixed binary (21), fixed binary (21), fixed binary (35));
dcl  ssu_$abort_line entry () options (variable);
dcl  ssu_$arg_count entry (pointer, fixed binary);
dcl  ssu_$arg_ptr entry (pointer, fixed binary, pointer, fixed binary (21));
dcl  ssu_$return_arg entry (pointer, fixed binary, bit (1) aligned, pointer, fixed binary (21));

dcl  cleanup condition;

dcl  (addcharno, addr, convert, currentsize, divide, index, length, ltrim) builtin;
dcl  (maxlength, min, null, rtrim, string, substr, translate, unspec, verify) builtin;
%page;
/* The "list" and "list_original" requests: displays a one line summary of the selected messages */

list_request:
     entry (P_sci_ptr, P_rdm_invocation_ptr);

	request = LIST_REQUEST;
	go to COMMON;



/* The "print" and "print_original" request: prints the specified messages.  Control arguments are provided to select
   several different levels of detail for the information displayed from the message header */

print_request:
     entry (P_sci_ptr, P_rdm_invocation_ptr);

	request = PRINT_REQUEST;
	go to COMMON;


/* The "print_header" and "print_original_header" requests: prints the message header of the specified messages.  Control
   arguments are provided to control the level of detail to be displayed */

print_header_request:
     entry (P_sci_ptr, P_rdm_invocation_ptr);

	request = PRINT_HEADER_REQUEST;
	go to COMMON;


/* The "delete" request: marks the specified messages for deletion when upon exit from read_mail */

delete_request:
     entry (P_sci_ptr, P_rdm_invocation_ptr);

	request = DELETE_REQUEST;
	go to COMMON;


/* The "retrieve" request: unmarks the specified messages so they will not be deleted upon exit from read_mail */

retrieve_request:
     entry (P_sci_ptr, P_rdm_invocation_ptr);

	request = RETRIEVE_REQUEST;
	go to COMMON;


/* The "switch_off" request: turns off a specified per-message switch */

switch_off_request:
     entry (P_sci_ptr, P_rdm_invocation_ptr);

	request = SWITCH_OFF_REQUEST;
	go to COMMON;


/* The "switch_on" request: turns on a specified per-message switch */

switch_on_request:
     entry (P_sci_ptr, P_rdm_invocation_ptr);

	request = SWITCH_ON_REQUEST;
	go to COMMON;

all_request:
     entry (P_sci_ptr, P_rdm_invocation_ptr);

	request = OTHER_REQUEST;
	other_keyword_type = ALL_KEYWORD;
	go to COMMON;

first_request:
     entry (P_sci_ptr, P_rdm_invocation_ptr);

	request = OTHER_REQUEST;
	other_keyword_type = FIRST_KEYWORD;
	go to COMMON;

last_request:
     entry (P_sci_ptr, P_rdm_invocation_ptr);

	request = OTHER_REQUEST;
	other_keyword_type = LAST_KEYWORD;
	go to COMMON;

previous_request:
     entry (P_sci_ptr, P_rdm_invocation_ptr);

	request = OTHER_REQUEST;
	other_keyword_type = PREVIOUS_KEYWORD;
	go to COMMON;

next_request:
     entry (P_sci_ptr, P_rdm_invocation_ptr);

	request = OTHER_REQUEST;
	other_keyword_type = NEXT_KEYWORD;
	go to COMMON;

current_request:
     entry (P_sci_ptr, P_rdm_invocation_ptr);

	request = OTHER_REQUEST;
	other_keyword_type = CURRENT_KEYWORD;
	go to COMMON;

seen_request:
     entry (P_sci_ptr, P_rdm_invocation_ptr);

	request = OTHER_REQUEST;
	other_keyword_type = SEEN_KEYWORD;
	go to COMMON;

unseen_request:
     entry (P_sci_ptr, P_rdm_invocation_ptr);

	request = OTHER_REQUEST;
	other_keyword_type = UNSEEN_KEYWORD;
	go to COMMON;

new_request:
     entry (P_sci_ptr, P_rdm_invocation_ptr);

	request = OTHER_REQUEST;
	other_keyword_type = NEW_KEYWORD;
	go to COMMON;

first_seen_request:
     entry (P_sci_ptr, P_rdm_invocation_ptr);

	request = OTHER_REQUEST;
	other_keyword_type = FIRST_SEEN_KEYWORD;
	go to COMMON;

first_unseen_request:
     entry (P_sci_ptr, P_rdm_invocation_ptr);

	request = OTHER_REQUEST;
	other_keyword_type = FIRST_UNSEEN_KEYWORD;
	go to COMMON;

last_seen_request:
     entry (P_sci_ptr, P_rdm_invocation_ptr);

	request = OTHER_REQUEST;
	other_keyword_type = LAST_SEEN_KEYWORD;
	go to COMMON;

last_unseen_request:
     entry (P_sci_ptr, P_rdm_invocation_ptr);

	request = OTHER_REQUEST;
	other_keyword_type = LAST_UNSEEN_KEYWORD;
	go to COMMON;

previous_seen_request:
     entry (P_sci_ptr, P_rdm_invocation_ptr);

	request = OTHER_REQUEST;
	other_keyword_type = PREVIOUS_SEEN_KEYWORD;
	go to COMMON;

previous_unseen_request:
     entry (P_sci_ptr, P_rdm_invocation_ptr);

	request = OTHER_REQUEST;
	other_keyword_type = PREVIOUS_UNSEEN_KEYWORD;
	go to COMMON;

next_seen_request:
     entry (P_sci_ptr, P_rdm_invocation_ptr);

	request = OTHER_REQUEST;
	other_keyword_type = NEXT_SEEN_KEYWORD;
	go to COMMON;

next_unseen_request:
     entry (P_sci_ptr, P_rdm_invocation_ptr);

	request = OTHER_REQUEST;
	other_keyword_type = NEXT_UNSEEN_KEYWORD;
	go to COMMON;
%page;
COMMON:
	call setup_request ();			/* set up common defaults */

	on condition (cleanup) call cleanup_request ();

	rdm_invocation.sci_ptr = P_sci_ptr;		/* avoids aborting the entire reply/forward accidently */

	if request = RETRIEVE_REQUEST then		/* retrieve request operates on deleted messages only */
	     msg_type = ONLY_DELETED_MESSAGES;
	else msg_type = NON_DELETED_MESSAGES;

	dl_rt_sw = (request = DELETE_REQUEST) | (request = RETRIEVE_REQUEST);
						/* delete and retrieve don't accept -idl/-odl/-ondl */

	if (request = PRINT_REQUEST) | (request = PRINT_HEADER_REQUEST) then do;
	     local_fmo.version = FORMAT_MESSAGE_OPTIONS_VERSION_1;
	     local_fmo.line_length = 0;		/* ... use the terminal's line length */
	     if request = PRINT_REQUEST then do;	/* ... print: use default format specified to read_mail */
		formatting_mode = rdm_invocation.print_options.formatting_mode;
		local_fmo.include_body = "1"b;
	     end;
	     else do;				/* ... print_header: use default format by default */
		formatting_mode = DEFAULT_FORMATTING_MODE;
		local_fmo.include_body = "0"b;
	     end;
	end;

	else if (request = LIST_REQUEST) then do;
	     listing_header_sw = "1"b;		/* default is to print header line */
	     listing_line_length = 0;			/* ... and to use the terminal's line length */
	end;

/* Mail 362: Should not check for new messages before list and print request */

/* Scan the request's arguments */

	if request = SWITCH_OFF_REQUEST | request = SWITCH_ON_REQUEST then do;
	     if n_arguments < 1 then call ssu_$abort_line (P_sci_ptr, error_table_$noarg, "No switch type specified.");
	     call ssu_$arg_ptr (P_sci_ptr, 1, argument_ptr, argument_lth);
	     if (argument = "seen") then
		switch_type = PER_MESSAGE_SEEN_SWITCH_TYPE;
	     else call ssu_$abort_line (P_sci_ptr, error_table_$badopt, "Invalid switch type ^a", argument);
	     first_argument = 2;
	end;
	else first_argument = 1;

	call process_arguments ();

	class_sw.time = (class_count (TIME_CLASS) ^= 0);	/* determine which selection control arguments were used */
	class_sw.subject = (class_count (SUBJECT_CLASS) ^= 0);
	class_sw.sender = (class_count (SENDER_CLASS) ^= 0);
	class_sw.recipient = (class_count (RECIPIENT_CLASS) ^= 0);


/* Determine which messages are selected:  If there are message specifiers, process them to get the initial set of
   eligible messages and then apply the selection control arguments, if any.  If there are no message specifiers but there
   are selection control arguments, mark all messages as eligible and apply the control arguments.  If there are no
   message specifiers and no selection control arguments, the list request defaults to all messages, the *_original
   requests default to those messages being processed by the reply/forward request, and the retrieve request aborts as it
   requires some specifier */

	if msg_spec_count = 0 then			/* no message specifiers */
	     if is_original_request & (string (class_sw) = ""b) then
		call rdm_message_mark_mgr_$remark_original_messages (rdm_invocation_ptr);

	     else if request = LIST_REQUEST then
		call rdm_message_mark_mgr_$mark_all_messages (rdm_invocation_ptr, msg_type);

	     else if request = RETRIEVE_REQUEST then	/* must have some type of specification ... */
		if string (class_sw) = ""b then	/* ... and no selection control arguments */
		     call ssu_$abort_line (P_sci_ptr, error_table_$noarg,
			"At least one message specifier is required for this request.");
		else call rdm_message_mark_mgr_$mark_all_messages (rdm_invocation_ptr, msg_type);

	     else if request = OTHER_REQUEST then	/* all, first, seen, first_seen, etc. */
		call rdm_message_mark_mgr_$do_request (P_sci_ptr, rdm_invocation_ptr, other_keyword_type, msg_type,
		     reverse_sw);

	     else do;				/* all other requests ... */
		if string (class_sw) = ""b then
		     call rdm_message_mark_mgr_$mark_current_message (rdm_invocation_ptr, msg_type);
						/* phx19099 RL - usage of "-odl" with current will be caught during marking */
		else call rdm_message_mark_mgr_$mark_all_messages (rdm_invocation_ptr, msg_type);
	     end;

	else call process_msg_specs ();		/* process the message specifiers */

	if (string (class_sw) ^= ""b) & case_independence_sw then call make_lowercase_select_strings ();
						/* user wants case independence: use lower-case */

	if string (class_sw) ^= ""b then		/* there are other selections to be performed */
	     call process_selections (marked_chain.n_messages);

	if marked_chain.n_messages = 0 & request ^= OTHER_REQUEST then
	     call ssu_$abort_line (P_sci_ptr, 0, "No messages selected.");


/* Perform the actual request */

	if reverse_sw then do;			/* process them in the opposite of the order marked */
	     first_message_idx = marked_chain.n_messages;
	     last_message_idx = 1;
	     message_idx_increment = -1;
	end;
	else do;					/* process them in the order makred */
	     first_message_idx = 1;
	     last_message_idx = marked_chain.n_messages;
	     message_idx_increment = 1;
	end;

	if request = LIST_REQUEST then call perform_list_request (LIST_INFO);

	else if (request = PRINT_REQUEST) | (request = PRINT_HEADER_REQUEST) then do;
	     call perform_printing_request ();
	     if delete_sw then			/* ... delete them after printing */
		call rdm_mailbox_interface_$delete_messages (rdm_invocation_ptr, "0"b);
	end;

	else if request = DELETE_REQUEST then
	     call rdm_mailbox_interface_$delete_messages (rdm_invocation_ptr, force_sw);

	else if request = RETRIEVE_REQUEST then call rdm_mailbox_interface_$retrieve_messages (rdm_invocation_ptr);

	else if request = SWITCH_OFF_REQUEST | request = SWITCH_ON_REQUEST then call set_switch (P_sci_ptr);

	else if request = OTHER_REQUEST then call perform_list_request (JUST_LIST_NUMBERS);

	call cleanup_request ();

	return;
%page;
/* The "mailbox" request: returns/prints the pathname of the mailbox being examined by read_mail */

mailbox_request:
     entry (P_sci_ptr, P_rdm_invocation_ptr);

	rdm_invocation_ptr = P_rdm_invocation_ptr;

	call ssu_$return_arg (P_sci_ptr, n_arguments, active_request, return_value_ptr, return_value_max_lth);

	if n_arguments > 0 then call ssu_$abort_line (P_sci_ptr, 0, "No arguments are allowed.");

	mailbox_ptr = rdm_invocation.mailbox_ptr;

	if active_request then			/* requote it in case it contains spaces */
	     return_value = requote_string_ (rtrim (pathname_ (mailbox.mailbox_dirname, mailbox.mailbox_ename)));
	else call ioa_ ("Reading: ^a", pathname_ (mailbox.mailbox_dirname, mailbox.mailbox_ename));

	return;
%page;
/* Prepares to execute the request */

setup_request:
     procedure ();

	rdm_invocation_ptr = P_rdm_invocation_ptr;

	if rdm_invocation.type = SDM_INVOCATION then do;
	     /*** Invoked from send_mail during a reply ... */
	     sdm_invocation_ptr = rdm_invocation_ptr;
	     if (request ^= LIST_REQUEST) & (request ^= PRINT_REQUEST) & (request ^= PRINT_HEADER_REQUEST) then
		call ssu_$abort_line (P_sci_ptr, ssu_et_$unimplemented_request);
	     else if sdm_invocation.rdm_invocation_ptr = null () then
		call ssu_$abort_line (P_sci_ptr, 0, "This request is valid only during a ""reply"" request.");
	     is_original_request = "1"b;
	     rdm_invocation_ptr = sdm_invocation.rdm_invocation_ptr;
	end;

	else if rdm_invocation.type = RDM_FORWARD_INVOCATION then do;
	     /*** Invoked from the forward request sub-loop ... */
	     rdm_forward_invocation_ptr = rdm_invocation_ptr;
	     if request ^= PRINT_REQUEST then		/* ... only print_original for forward */
		call ssu_$abort_line (P_sci_ptr, ssu_et_$unimplemented_request);
	     is_original_request = "1"b;
	     rdm_invocation_ptr = rdm_forward_invocation.rdm_invocation_ptr;
	end;

	else is_original_request = "0"b;		/* normal read_mailish usage */

	if request = LIST_REQUEST | request = OTHER_REQUEST then
						/* only one of these which can be an active request */
	     call ssu_$return_arg (P_sci_ptr, n_arguments, active_request, return_value_ptr, return_value_max_lth);
	else do;
	     call ssu_$arg_count (P_sci_ptr, n_arguments);
	     active_request = "0"b;			/* ... won't hurt */
	end;

	call rdm_message_mark_mgr_$clear_marked_messages (rdm_invocation_ptr);

	msg_spec_count = 0;
	msg_type = NON_DELETED_MESSAGES;		/* default value */

	msg_spec_array_size = n_arguments;		/* setup the array of message specifier argument indeces */
	msg_spec_array_ptr = stack_allocate (currentsize (msg_spec_array));

	n_selections = n_arguments;			/* setup the array of selection specifications */
	selection_array_ptr = stack_allocate (currentsize (selection_array));

	saved_rdm_sci_ptr = rdm_invocation.sci_ptr;	/* for cleanup handler */
	selection_array.array (*).address_ptr = null ();	/* ... */

	n_selections = 0;				/* haven't seen any selection control arguments yet */

	class_count (*) = 0;

	case_independence_sw, delete_sw, force_sw, listing_header_sw, reverse_sw = "0"b;

	return;

     end setup_request;
%page;
/* Cleans up after the execution of one of these requests */

cleanup_request:
     procedure ();

dcl  idx fixed binary;

	do idx = 1 to n_selections;
	     sel_ptr = addr (selection_array.array (idx));
	     if sel.address_ptr ^= null () then call mail_system_$free_address (sel.address_ptr, (0));
	end;

	rdm_invocation.sci_ptr = saved_rdm_sci_ptr;

	return;

     end cleanup_request;



/* Allocates an object by extending its caller's stack frame */

stack_allocate:
     procedure (p_size) returns (pointer) /* options (quick) */;

dcl  p_size fixed binary (19) parameter;
dcl  obj_ptr pointer;
dcl  code fixed binary (35);

	call cu_$grow_stack_frame (p_size, obj_ptr, code);
	if code ^= 0 then
	     call ssu_$abort_line (P_sci_ptr, code, "Unable to allocate ^d words of stack frame space.", p_size);

	return (obj_ptr);

     end stack_allocate;
%page;
/* Process the request line arguments */

process_arguments:
     procedure ();

	do argument_idx = first_argument to n_arguments;

	     call ssu_$arg_ptr (P_sci_ptr, argument_idx, argument_ptr, argument_lth);

	     if index (argument, "-") ^= 1 & request ^= OTHER_REQUEST then do;
						/* a message specifier ... */
		msg_spec_count = msg_spec_count + 1;	/* ... record its position for later */
		msg_spec_array (msg_spec_count) = argument_idx;
	     end;

	     else if request = SWITCH_OFF_REQUEST | request = SWITCH_ON_REQUEST then
		call ssu_$abort_line (P_sci_ptr, error_table_$badopt, """^a""", argument);

	     else if ^dl_rt_sw & ((argument = "-reverse") | (argument = "-rv")) then reverse_sw = "1"b;
	     else if ^dl_rt_sw & ((argument = "-no_reverse") | (argument = "-nrv")) then reverse_sw = "0"b;

	     else if ^dl_rt_sw & ((argument = "-include_deleted") | (argument = "-idl")) then msg_type = ALL_MESSAGES;
	     else if ^dl_rt_sw & ((argument = "-only_deleted") | (argument = "-odl")) then
		msg_type = ONLY_DELETED_MESSAGES;
	     else if ^dl_rt_sw & ((argument = "-only_non_deleted") | (argument = "-ondl")) then
		msg_type = NON_DELETED_MESSAGES;

	     else if request = OTHER_REQUEST then
		if index (argument, "-") ^= 1 then
		     call ssu_$abort_line (P_sci_ptr, error_table_$badarg,
			"This request accepts only control arguments.");
		else call ssu_$abort_line (P_sci_ptr, error_table_$badopt, """^a""", argument);

	     /*** obsolete control arguments: remove support in MR11 */
	     else if ^dl_rt_sw & ((argument = "-all") | (argument = "-a")) then msg_type = ALL_MESSAGES;

	     else if (argument = "-non_case_sensitive") | (argument = "-ncs") then case_independence_sw = "1"b;
	     else if (argument = "-case_sensitive") | (argument = "-cs") then case_independence_sw = "0"b;

	     else if (argument = "-subject") | (argument = "-sj") then do;
		call get_next_one_argument ("A string or a regular expression");
		call get_selection (SUBJECT_CLASS);
		sel.type = SUBJECT_FIELD;		/* which field to scan */
		call add_string_or_regexp (argument1);
	     end;

	     else if (argument = "-in_reply_to") | (argument = "-irt") then do;
		call get_next_one_argument ("A string or a regular expression");
		call get_selection (SUBJECT_CLASS);
		sel.type = IN_REPLY_TO_FIELD;		/* which field to scan */
		call add_string_or_regexp (argument1);
	     end;

	     else if (argument = "-between") | (argument = "-bt") then do;
		call get_next_two_arguments ("Two date/times");
		call get_selection (TIME_CLASS);	/* sel.type is irrelevant for TIME class */
		sel.time_1 = convert_time (argument1, "1"b);
		sel.time_2 = convert_time (argument2, "1"b) + ONE_DAY;
		if sel.time_1 >= sel.time_2 then do;
BETWEEN_TIMES_IN_WRONG_ORDER:
		     call ssu_$abort_line (P_sci_ptr, 0, "The range of ^a ""^a"" ""^a"" is empty or backwards.",
			control_argument, argument1, argument2);
		end;
	     end;

	     else if (argument = "-between_times") | (argument = "-between_time") | (argument = "-btt") then do;
		call get_next_two_arguments ("Two date/times");
		call get_selection (TIME_CLASS);	/* sel.type is irrelevant for TIME class */
		sel.time_1 = convert_time (argument1, "0"b);
		sel.time_2 = convert_time (argument2, "0"b);
						/* phx19118 RL - corrected direction of time comparison */
		if sel.time_1 > sel.time_2 then go to BETWEEN_TIMES_IN_WRONG_ORDER;
	     end;

	     else if (argument = "-after") | (argument = "-af") then do;
		call get_next_one_argument ("A date/time");
		call get_selection (TIME_CLASS);
		sel.time_1 = convert_time (argument1, "1"b);
		sel.time_2 = END_OF_TIME;
	     end;

	     else if (argument = "-after_time") | (argument = "-aft") then do;
		call get_next_one_argument ("A date/time");
		call get_selection (TIME_CLASS);
		sel.time_1 = convert_time (argument1, "0"b);
		sel.time_2 = END_OF_TIME;
	     end;

	     else if (argument = "-before") | (argument = "-be") then do;
		call get_next_one_argument ("A date/time");
		call get_selection (TIME_CLASS);
		sel.time_1 = BEGINNING_OF_TIME;
		sel.time_2 = convert_time (argument1, "1"b);
	     end;

	     else if (argument = "-before_time") | (argument = "-bet") then do;
		call get_next_one_argument ("A date/time");
		call get_selection (TIME_CLASS);
		sel.time_1 = BEGINNING_OF_TIME;
		sel.time_2 = convert_time (argument1, "0"b);
	     end;

	     else if (argument = "-date") | (argument = "-dt") then do;
		call get_next_one_argument ("A date/time");
		call get_selection (TIME_CLASS);
		sel.time_1 = convert_time (argument1, "1"b);
		sel.time_2 = sel.time_1 + ONE_DAY;
	     end;

	     else if (argument = "-from") | (argument = "-fm") then do;
		call get_next_one_argument ("An address or a regular expression");
		call get_selection (SENDER_CLASS);
		sel.type = FROM_FIELD;
		if index (argument1, SLASH) = 1 then
		     call add_string_or_regexp (argument1);
		else call add_address ();
	     end;

	     else if (argument = "-reply_to") | (argument = "-rpt") then do;
		call get_next_one_argument ("An address or a regular expression");
		call get_selection (SENDER_CLASS);
		sel.type = REPLY_TO_FIELD;
		if index (argument1, SLASH) = 1 then
		     call add_string_or_regexp (argument1);
		else call add_address ();
	     end;

	     else if argument = "-to" then do;
		call get_next_one_argument ("An address or a regular expression");
		call get_selection (RECIPIENT_CLASS);
		sel.type = TO_FIELD;
		if index (argument1, SLASH) = 1 then
		     call add_string_or_regexp (argument1);
		else call add_address ();
	     end;

	     else if argument = "-cc" then do;
		call get_next_one_argument ("An address or a regular expression");
		call get_selection (RECIPIENT_CLASS);
		sel.type = CC_FIELD;
		if index (argument1, SLASH) = 1 then
		     call add_string_or_regexp (argument1);
		else call add_address ();
	     end;

	     else if argument = "-bcc" then do;
		call get_next_one_argument ("An address or a regular expression");
		call get_selection (RECIPIENT_CLASS);
		sel.type = BCC_FIELD;
		if index (argument1, SLASH) = 1 then
		     call add_string_or_regexp (argument1);
		else call add_address ();
	     end;

	     else if (argument = "-forwarded_to") | (argument = "-fwdt") then do;
		call get_next_one_argument ("An address or a regular expression");
		call get_selection (RECIPIENT_CLASS);
		sel.type = TO_FIELD + REDISTRIBUTED_FIELDS_BASE;
		if index (argument1, SLASH) = 1 then
		     call add_string_or_regexp (argument1);
		else call add_address ();
	     end;

	     else if (argument = "-recipient") | (argument = "-rcp") then do;
		call get_next_one_argument ("An address or a regular expression");
		call get_selection (RECIPIENT_CLASS);
		sel.type = -1;			/* special -- indicates all recipient fields */
		if index (argument1, SLASH) = 1 then
		     call add_string_or_regexp (argument1);
		else call add_address ();
	     end;

	     else if request = PRINT_REQUEST then do;
		if ((argument = "-delete") | (argument = "-dl")) & ^is_original_request then delete_sw = "1"b;
		else if ((argument = "-no_delete") | (argument = "-ndl")) & ^is_original_request then
		     delete_sw = "0"b;
		else if (argument = "-long_header") | (argument = "-lghe") then
		     formatting_mode = LONG_FORMATTING_MODE;
		else if (argument = "-header") | (argument = "-he") then formatting_mode = DEFAULT_FORMATTING_MODE;
		else if (argument = "-brief_header") | (argument = "-bfhe") then
		     formatting_mode = BRIEF_FORMATTING_MODE;
		else if (argument = "-no_header") | (argument = "-nhe") then formatting_mode = NONE_FORMATTING_MODE;
		/*** obsolete control arguments: delete in MR11 */
		else if ((argument = "-header_only") | (argument = "-ho")) then do;
		     formatting_mode = DEFAULT_FORMATTING_MODE;
		     local_fmo.include_body = "0"b;
		end;
		else call ssu_$abort_line (P_sci_ptr, error_table_$badopt, """^a""", argument);
	     end;

	     else if request = PRINT_HEADER_REQUEST then do;
		if ((argument = "-delete") | (argument = "-dl")) & ^is_original_request then delete_sw = "1"b;
		else if ((argument = "-no_delete") | (argument = "-ndl")) & ^is_original_request then
		     delete_sw = "0"b;
		else if (argument = "-long") | (argument = "-lg") then formatting_mode = LONG_FORMATTING_MODE;
		else if (argument = "-default") | (argument = "-dft") then formatting_mode = DEFAULT_FORMATTING_MODE;
		else if (argument = "-brief") | (argument = "-bf") then formatting_mode = BRIEF_FORMATTING_MODE;
		else call ssu_$abort_line (P_sci_ptr, error_table_$badopt, """^a""", argument);
	     end;

	     else if request = LIST_REQUEST then do;
		if (argument = "-header") | (argument = "-he") then listing_header_sw = "1"b;
		else if (argument = "-no_header") | (argument = "-nhe") then listing_header_sw = "0"b;
		else if (argument = "-line_length") | (argument = "-ll") then do;
		     call get_next_one_argument ("A number");
		     listing_line_length = cv_dec_check_ (argument1, code);
		     if code ^= 0 then
INVALID_LINE_LENGTH_SPECIFICATION:
			call ssu_$abort_line (P_sci_ptr, 0,
			     "Line length must be a number not less than 60; not ""^a"".", argument1);
		     if listing_line_length < 60 then go to INVALID_LINE_LENGTH_SPECIFICATION;
		end;
		else if (argument = "-no_line_length") | (argument = "-nll") then listing_line_length = -1;
		else call ssu_$abort_line (P_sci_ptr, error_table_$badopt, """^a""", argument);
	     end;

	     else if request = DELETE_REQUEST then do;
		if (argument = "-force") | (argument = "-fc") then force_sw = "1"b;
		else if (argument = "-no_force") | (argument = "-nfc") then force_sw = "0"b;
		else call ssu_$abort_line (P_sci_ptr, error_table_$badopt, """^a""", argument);
	     end;

	     else call ssu_$abort_line (P_sci_ptr, error_table_$badopt, """^a""", argument);
	end;

	return;
%page;
/* Internal to process_arugments: fetches the next argument and complains if it's not there */

get_next_one_argument:
	procedure (p_expected);

dcl  p_expected character (*) parameter;

	     if (argument_idx + 1) > n_arguments then
		call ssu_$abort_line (P_sci_ptr, error_table_$noarg, "^a after ""^a"".", p_expected, control_argument)
		     ;

	     argument_idx = argument_idx + 1;
	     call ssu_$arg_ptr (P_sci_ptr, argument_idx, argument1_ptr, argument1_lth);

	     return;

	end get_next_one_argument;



/* Inernal to process_arguments: fetches the next two arguments and complains if either is not there */

get_next_two_arguments:
	procedure (p_expected);

dcl  p_expected character (*) parameter;

	     if (argument_idx + 2) > n_arguments then
		call ssu_$abort_line (P_sci_ptr, error_table_$noarg, "^a after ""^a"".", p_expected, control_argument)
		     ;

	     argument_idx = argument_idx + 1;
	     call ssu_$arg_ptr (P_sci_ptr, argument_idx, argument1_ptr, argument1_lth);

	     argument_idx = argument_idx + 1;
	     call ssu_$arg_ptr (P_sci_ptr, argument_idx, argument2_ptr, argument2_lth);

	     return;

	end get_next_two_arguments;
%page;
/* Internal to process_arguments: gets the next selection_array entry: initializes it, increments the per-class counter,
   and sets sel_ptr */

get_selection:
	procedure (p_class);

dcl  p_class fixed binary parameter;

	     n_selections = n_selections + 1;
	     sel_ptr = addr (selection_array.array (n_selections));

	     unspec (sel) = ""b;
	     sel.class = p_class;
	     sel.str_ptr = null ();
	     sel.address_ptr = null ();

	     class_count (p_class) = class_count (p_class) + 1;

	     return;

	end get_selection;
%page;
/* Internal to process_arguments: makes the current selection a string or regular expression selection based on the
   whether the first character of the string is not or is a slash (/), respectively */

add_string_or_regexp:
	procedure (p_string);

dcl  p_string character (*) parameter;
dcl  search_string character (sel.str_lth) unaligned based (sel.str_ptr);

	     sel.regexp_sw = (index (p_string, SLASH) = 1);

	     if sel.regexp_sw then do;		/* a regular expression */
		if substr (p_string, length (p_string), 1) ^= SLASH then
		     call ssu_$abort_line (P_sci_ptr, 0, "Missing regular expression delimiter. ^a ""^a""",
			control_argument, p_string);
		sel.str_ptr = addcharno (addr (p_string), 1);
		sel.str_lth = length (p_string) - 2;	/* ... excluding the slashes */
	     end;

	     else do;				/* a string to be matched exactly */
		sel.str_ptr = addr (p_string);
		sel.str_lth = length (p_string);
	     end;

	     if verify (search_string, WHITESPACE) = 0 then
						/* can't be empty */
		call ssu_$abort_line (P_sci_ptr, mlsys_et_$null_search_string, "After ""^a"".", control_argument);

	     if sel.regexp_sw then do;		/* insure that it has proper syntax */
		call search_file_$silent (sel.str_ptr, 1, sel.str_lth, addr (NULL_STRING), 1, 0, (0), (0), code);
		if code = error_table_$nomatch then	/* ... can only get this if the expression's syntax is OK */
		     code = 0;
		if code ^= 0 then call ssu_$abort_line (P_sci_ptr, code, "^a ""^a""", control_argument, p_string);
	     end;

	     return;

	end add_string_or_regexp;
%page;
/* Internal to process_arguments: converts a date/time string and optionally truncates to midnight */

convert_time:
	procedure (p_time, p_adjust_sw) returns (fixed binary (71));

dcl  p_time character (*) parameter;
dcl  p_adjust_sw bit (1) aligned parameter;

dcl  clock_value fixed binary (71);
dcl  (month, day_of_month, year) fixed binary;
dcl  time_zone character (4);
dcl  code fixed binary (35);

	     call convert_date_to_binary_ (p_time, clock_value, code);
	     if code ^= 0 then call ssu_$abort_line (P_sci_ptr, code, "^a ""^a""", control_argument, p_time);

	     if p_adjust_sw then do;			/* truncate to the previous midnight */
		time_zone = "";			/* must be initialized */
		call decode_clock_value_$date_time (clock_value, month, day_of_month, year, (0), (0), (0), (0), (0),
		     time_zone, (0));
		call encode_clock_value_ (month, day_of_month, year, 0, 0, 0, 0, 0, time_zone, clock_value, (0));
	     end;

	     return (clock_value);

	end convert_time;
%page;
/* Internal to process_arguments: collects a single address from the argument list */

add_address:
	procedure ();

dcl  1 local_pcao aligned like parse_ca_options;
dcl  code fixed binary (35);

	     local_pcao.version = PARSE_CA_OPTIONS_VERSION_1;
	     local_pcao.logbox_creation_mode, local_pcao.savebox_creation_mode = DONT_CREATE_MAILBOX;
	     local_pcao.abort_on_errors = "1"b;
	     local_pcao.validate_addresses = "0"b;
	     local_pcao.mbz = ""b;

	     call mlsys_utils_$parse_address_control_args (P_sci_ptr, argument_idx, addr (local_pcao), sel.address_ptr,
		code);
	     if code ^= 0 then			/* ... only fatal errors will get here */
		call ssu_$abort_line (P_sci_ptr, code, "Parsing control arguments.");

	     argument_idx = argument_idx - 1;		/* do loop will increment this again ... */

	     return;

	end add_address;

     end process_arguments;
%page;
/* Marks the messages selected by the message specifiers */

process_msg_specs:
     procedure ();

dcl  idx fixed binary;

	do idx = 1 to msg_spec_count;
	     call ssu_$arg_ptr (P_sci_ptr, msg_spec_array (idx), argument_ptr, argument_lth);

	     call rdm_message_mark_mgr_$mark_messages (rdm_invocation_ptr, argument_ptr, argument_lth, msg_type, ""b,
		code);
	     if code ^= 0 then call ssu_$abort_line (P_sci_ptr, code);
	end;

	return;

     end process_msg_specs;
%page;
/* Converts all selection strings to lowercase for case independent searching:  The lowercase version of the strings are
   allocated on our caller's stack */

make_lowercase_select_strings:
     procedure () /* options (quick) */;

dcl  sel_str character (sel.str_lth) based (sel.str_ptr);

dcl  copy_str character (copy_str_lth) based (copy_str_ptr);
dcl  copy_str_lth fixed binary (21);
dcl  copy_str_ptr pointer;

dcl  idx fixed binary;

	do idx = 1 to n_selections;
	     sel_ptr = addr (selection_array.array (idx));
	     if sel.str_ptr ^= null () then do;		/* there's a string */
		copy_str_lth = sel.str_lth;
		copy_str_ptr = stack_allocate (divide ((copy_str_lth + 3), 4, 18, 0));
		copy_str = translate (sel_str, LOWERCASE, UPPERCASE);
		sel.str_ptr = copy_str_ptr;		/* ... replace it by the all lowercase copy */
	     end;
	end;

	return;

     end make_lowercase_select_strings;
%page;
/* Processes the message selection control arguments */

process_selections:
     procedure (p_message_count) options (non_quick);

dcl  p_message_count fixed binary parameter;

dcl  time_bits (p_message_count) bit (1) unaligned automatic;
dcl  subject_bits (p_message_count) bit (1) unaligned automatic;
dcl  sender_bits (p_message_count) bit (1) unaligned automatic;
dcl  recipient_bits (p_message_count) bit (1) unaligned automatic;
dcl  new_marked_bits (p_message_count) bit (1) unaligned automatic;

dcl  1 buffer aligned based,				/* used for following like clauses */
       2 text_ptr pointer,
       2 text_lth fixed binary (21);

dcl  1 message_field_buffers aligned,			/* used to reduce # of calls to mlsys_utils_$format... */
       2 in_reply_to like buffer,
       2 from like buffer,
       2 reply_to like buffer,
       2 to like buffer,
       2 cc like buffer,
       2 bcc like buffer;

dcl  1 matched_sw aligned like class_sw;		/* for determining when we may stop looking at selections */

dcl  1 saved_last_search_buffer aligned like rdm_invocation.last_search_buffer;

dcl  code fixed binary (35);
dcl  (message_idx, message_number, selection_idx, idx) fixed binary;


	new_marked_bits (*) = "1"b;			/* assume everything matches */

	if class_sw.time then string (time_bits) = ""b;
	if class_sw.subject then string (subject_bits) = ""b;
	if class_sw.sender then string (sender_bits) = ""b;
	if class_sw.recipient then string (recipient_bits) = ""b;

	saved_last_search_buffer = rdm_invocation.last_search_buffer;

	on condition (cleanup)
	     begin;
	     if saved_last_search_buffer.buffer_ptr = rdm_invocation.last_search_buffer.buffer_ptr then
		rdm_invocation.last_search_buffer = saved_last_search_buffer;
	end;


/* Process the selections: a message is selected if it matches all classes with non-zero selection specifications; only
   one specification in a class must match to say that message matches the class */

	do message_idx = 1 to marked_chain.n_messages;
	     message_number = marked_chain.messages (message_idx);

	     call rdm_mailbox_interface_$read_message (rdm_invocation_ptr, message_number, message_ptr, code);
	     if code ^= 0 then
		call ssu_$abort_line (P_sci_ptr, code, "Reading message #^d from ^a.", message_number,
		     rdm_invocation.mailbox_name);

	     message_field_buffers.in_reply_to.text_ptr,	/* haven't contructed any printed representations yet */
		message_field_buffers.from.text_ptr, message_field_buffers.reply_to.text_ptr,
		message_field_buffers.to.text_ptr, message_field_buffers.cc.text_ptr,
		message_field_buffers.bcc.text_ptr = null ();

	     string (matched_sw) = ""b;		/* not matched yet */

	     do selection_idx = 1 to n_selections;
		sel_ptr = addr (selection_array.array (selection_idx));
		if sel.class = TIME_CLASS then call process_time_selection ();
		else if sel.class = SUBJECT_CLASS then call process_subject_selection ();
		else if sel.class = SENDER_CLASS then call process_sender_selection ();
		else if sel.class = RECIPIENT_CLASS then call process_recipient_selection ();
	     end;

CHECK_NEXT_MESSAGE:					/* control transfers here if message matches completely */
	     if saved_last_search_buffer.buffer_ptr = rdm_invocation.last_search_buffer.buffer_ptr then
		rdm_invocation.last_search_buffer = saved_last_search_buffer;
	end;

	if class_sw.time then string (new_marked_bits) = string (new_marked_bits) & string (time_bits);
	if class_sw.subject then string (new_marked_bits) = string (new_marked_bits) & string (subject_bits);
	if class_sw.sender then string (new_marked_bits) = string (new_marked_bits) & string (sender_bits);
	if class_sw.recipient then string (new_marked_bits) = string (new_marked_bits) & string (recipient_bits);


/* Remove all those messages from the marked chain which did not match the selection criteria */

	do message_idx = marked_chain.n_messages to 1 by -1;
	     if ^new_marked_bits (message_idx) then do;	/* delete this one */
		do idx = (message_idx + 1) to marked_chain.n_messages;
		     marked_chain.messages (idx - 1) = marked_chain.messages (idx);
		end;
		marked_chain.n_messages = marked_chain.n_messages - 1;
	     end;
	end;

	return;
%page;
/* Internal to process_selections: processes a single time selection for the current message */

process_time_selection:
	procedure ();

	     if matched_sw.time then return;		/* already matched one of the time criteria */

	     if (message.date_time_created >= sel.time_1) & (message.date_time_created <= sel.time_2) then do;
		time_bits (message_idx) = "1"b;	/* it matches */
		matched_sw.time = "1"b;
	     end;

	     if string (matched_sw) = string (class_sw) then go to CHECK_NEXT_MESSAGE;
						/* stop when all criteria are met */

	     return;

	end process_time_selection;
%page;
/* Internal to process_selections: processes a single text field (Subject/In-Reply-To) selection: either substring or
   regular expression match */

process_subject_selection:
	procedure ();

	     if matched_sw.subject then return;		/* already matched a subject criteria */

	     if sel.type = SUBJECT_FIELD then		/* check the message subject */
		if match_sel_on_string (message.subject.text_ptr, message.subject.text_lth) then do;
		     subject_bits (message_idx) = "1"b; /* ... it matches */
		     matched_sw.subject = "1"b;
		end;
		else ;

	     else /*** if sel.type = IN_REPLY_TO_FIELD then */
		/*** don't bother if there's no In-Reply-To field */
		if message.n_reply_references > 0 then do;
		if message_field_buffers.in_reply_to.text_ptr = null () then
		     call rdm_search_utils_$prepare_message_references_field_for_search (rdm_invocation_ptr,
			message_number, REPLY_REFERENCES_FIELDNAME, message.reply_references,
			message_field_buffers.in_reply_to.text_ptr, message_field_buffers.in_reply_to.text_lth);
		if match_sel_on_string (message_field_buffers.in_reply_to.text_ptr,
		     message_field_buffers.in_reply_to.text_lth) then do;
		     subject_bits (message_idx) = "1"b;
		     matched_sw.subject = "1"b;
		end;
	     end;

	     if string (matched_sw) = string (class_sw) then go to CHECK_NEXT_MESSAGE;

	     return;

	end process_subject_selection;
%page;
/* Internal to process_selections: processes a single sender field (From/Reply-To) selection: either a regular expression
   or an address match */

process_sender_selection:
	procedure ();

	     if matched_sw.sender then return;		/* already satisfied a sender selection */

	     if sel.type = FROM_FIELD then
		call process_address_list_selection (FROM_FIELDNAME, message.from, message_field_buffers.from,
		     sender_bits, matched_sw.sender);

	     else /*** if sel.type = REPLY_TO_FIELD then */
		call process_address_list_selection (REPLY_TO_FIELDNAME, message.reply_to,
		     message_field_buffers.reply_to, sender_bits, matched_sw.sender);

	     return;

	end process_sender_selection;
%page;
/* Internal to process_selections: processes a single recipient field (To/cc/bcc/Redistributed-To) selection: either a
   regular expression or an address match */

process_recipient_selection:
	procedure ();

	     if matched_sw.recipient then return;	/* already matched a recipient selection */

	     if sel.type = -1 then do;		/* special case: all recipients */
		call process_single_recipient_selection (TO_FIELD);
		call process_single_recipient_selection (CC_FIELD);
		call process_single_recipient_selection (BCC_FIELD);
		call process_single_recipient_selection ((TO_FIELD + REDISTRIBUTED_FIELDS_BASE));
	     end;

	     else call process_single_recipient_selection (sel.type);

	     return;



/* Internal to process_recipients_selection: actually processes the selection */

process_single_recipient_selection:
	     procedure (p_field_type);

dcl  p_field_type fixed binary parameter;

dcl  1 redistributed_buffer aligned like buffer;
dcl  redistributed_fieldname character (64) varying;
dcl  idx fixed binary;

		if p_field_type = TO_FIELD then
		     call process_address_list_selection (TO_FIELDNAME, message.to, message_field_buffers.to,
			recipient_bits, matched_sw.recipient);

		if p_field_type = CC_FIELD then
		     call process_address_list_selection (CC_FIELDNAME, message.cc, message_field_buffers.cc,
			recipient_bits, matched_sw.recipient);

		if p_field_type = BCC_FIELD then
		     call process_address_list_selection (BCC_FIELDNAME, message.bcc, message_field_buffers.bcc,
			recipient_bits, matched_sw.recipient);

		else /*** if p_field_type = (TO_FIELD + REDISTRIBUTED_FIELDS_BASE) then */
		     if message.n_redistributions > 0 then do;
		     redistributed_fieldname = REDISTRIBUTED_PREFIX || TO_FIELDNAME;
		     do idx = 1 to message.n_redistributions;
			redistributed_buffer.text_ptr = null ();
			call process_address_list_selection (redistributed_fieldname,
			     message_redistributions_list.redistributions (idx).to, redistributed_buffer,
			     recipient_bits, matched_sw.recipient);
		     end;
		end;

		return;

	     end process_single_recipient_selection;

	end process_recipient_selection;
%page;
/* Internal to process_selections: performs a selection over the given address list */

process_address_list_selection:
	procedure (p_fieldname, p_address_list_ptr, p_list_buffer, p_matched_bits_array, p_matched_type_sw);

dcl  p_fieldname character (*) varying parameter;
dcl  p_address_list_ptr pointer parameter;
dcl  1 p_list_buffer aligned parameter like buffer;
dcl  p_matched_bits_array (*) bit (1) unaligned parameter;
dcl  p_matched_type_sw bit (1) unaligned parameter;

dcl  address_idx fixed binary;

	     if is_empty_list (p_address_list_ptr) then
		;				/* don't bother if it's emtpy */

	     else do;
		if sel.regexp_sw then do;		/* match against the printed representation */
		     if p_list_buffer.text_ptr = null () then
			call rdm_search_utils_$prepare_address_list_field_for_search (rdm_invocation_ptr,
			     message_number, p_fieldname, p_address_list_ptr, p_list_buffer.text_ptr,
			     p_list_buffer.text_lth);
		     if match_sel_on_string (p_list_buffer.text_ptr, p_list_buffer.text_lth) then
			go to FOUND_MATCHING_ADDRESS;
		end;

		else do;				/* compare individual addresses */
		     do address_idx = 1 to p_address_list_ptr -> address_list.n_addresses;
			if mail_system_$compare_addresses (sel.address_ptr,
			     p_address_list_ptr -> address_list.addresses (address_idx), (0)) then
			     go to FOUND_MATCHING_ADDRESS;
		     end;
		end;
	     end;

	     return;				/* control reaches here iff there's no match */


/* Control arrives here iff a match was found in the address list */

FOUND_MATCHING_ADDRESS:
	     p_matched_bits_array (message_idx) = "1"b;
	     p_matched_type_sw = "1"b;

	     if string (matched_sw) = string (class_sw) then go to CHECK_NEXT_MESSAGE;

	     return;

	end process_address_list_selection;
%page;
/* Internal to process_selections: matches the string either against a substring or a regular expression */

match_sel_on_string:
	procedure (p_str_ptr, p_str_lth) returns (bit (1) aligned);

dcl  p_str_ptr pointer parameter;
dcl  p_str_lth fixed binary (21) parameter;

dcl  sel_str character (sel.str_lth) unaligned based (sel.str_ptr);

dcl  match_str character (match_str_lth) based (match_str_ptr);
dcl  match_str_lth fixed binary (21);
dcl  match_str_ptr pointer;

dcl  match_sw bit (1) aligned;
dcl  code fixed binary (35);


	     match_str_ptr = p_str_ptr;
	     match_str_lth = p_str_lth;


/* If case independence is requested, copy the string onto the stack and convert it to lower case */

	     if case_independence_sw then
		begin options (non_quick);

dcl  copied_str character (match_str_lth) automatic;

		copied_str = translate (match_str, LOWERCASE, UPPERCASE);
		if sel.regexp_sw then do;
		     call search_file_$silent (sel.str_ptr, 1, sel.str_lth, addr (copied_str), 1, match_str_lth, (0),
			(0), code);
		     match_sw = (code = 0);
		end;
		else match_sw = (index (copied_str, sel_str) ^= 0);
	     end;


/* Normal case sensitive check */

	     else do;
		if sel.regexp_sw then do;
		     call search_file_$silent (sel.str_ptr, 1, sel.str_lth, match_str_ptr, 1, match_str_lth, (0), (0),
			code);
		     match_sw = (code = 0);
		end;
		else match_sw = (index (match_str, sel_str) ^= 0);
	     end;

	     return (match_sw);

	end match_sel_on_string;

     end process_selections;
%page;
/* Lists the selected messages */

perform_list_request:
     procedure (P_list_sw);

dcl  P_list_sw bit (1) aligned;
dcl  (is_non_deleted, return_one_sw, seen_old_current_message) bit (1) aligned;
dcl  (old_current_message, new_current_message) fixed binary;
dcl  message_number_picture picture "(8)z9";


	if active_request then
	     return_value = "";			/* initialize output */
	else do;					/* displaying on the terminal ... */
	     if P_list_sw = JUST_LIST_NUMBERS then do;
		output_line_length = min (maxlength (output_buffer), get_line_length_$switch (iox_$user_output, (0)));
		output_buffer = "";
	     end;
	     else if listing_header_sw then do;
		call mlsys_utils_$print_message_summary_header (listing_line_length, iox_$user_output, code);
		if code ^= 0 then call ssu_$abort_line (P_sci_ptr, code, "Printing listing header line.");
	     end;
	end;

	seen_old_current_message = "0"b;		/* assume current message isn't going to be listed */
	old_current_message = rdm_invocation.current_message;
	new_current_message = 0;


/* Determine which message will be "current" after the list request completes:  if the current message is listed, it will
   remain the current message; otherwise, the first non-deleted message will become current */

	do message_idx = first_message_idx to last_message_idx by message_idx_increment;
	     message_number = marked_chain.messages (message_idx);
	     is_non_deleted = "1"b;			/* ... examine the deleted chain */
	     do idx = 1 to deleted_chain.n_messages while (is_non_deleted);
		if deleted_chain.messages (idx) = message_number then is_non_deleted = "0"b;
	     end;
	     if is_non_deleted then			/* ... it's not been deleted */
		if new_current_message = 0 then new_current_message = message_number;
	     if message_number = old_current_message then seen_old_current_message = "1"b;
	end;

	if seen_old_current_message then		/* present current message is in the list: it stays current */
	     new_current_message = old_current_message;
	else					/* present current message isn't being listed ... */
	     if new_current_message = 0 then		/* ... but all the listed messages are deleted: status quo */
	     new_current_message = old_current_message;


/* Actually list the messages */

	do message_idx = first_message_idx to last_message_idx by message_idx_increment;
	     message_number = marked_chain.messages (message_idx);

	     if active_request then do;		/* just return the message number */
		if length (return_value) > 0 then return_value = return_value || " ";
		return_value = return_value || ltrim (convert (message_number_picture, message_number));
	     end;
	     else if P_list_sw = JUST_LIST_NUMBERS then do;
						/* just print the message numbers (seen, etc.) */
		message_number_string = ltrim (convert (message_number_picture, message_number));
		if (length (output_buffer) + length (message_number_string) + 1) > output_line_length then do;
		     call ioa_ ("^a", output_buffer);
		     output_buffer = "";
		end;
		if output_buffer ^= "" then output_buffer = output_buffer || " ";
		output_buffer = output_buffer || message_number_string;
	     end;
	     else call list_single_message ();		/* display the summary */
	end;

	if P_list_sw = JUST_LIST_NUMBERS then do;
	     return_one_sw =
		(request = OTHER_REQUEST & other_keyword_type ^= ALL_KEYWORD & other_keyword_type ^= SEEN_KEYWORD
		& other_keyword_type ^= UNSEEN_KEYWORD & other_keyword_type ^= NEW_KEYWORD);
	     if active_request then do;
		if return_value = "" & return_one_sw then return_value = "0";
						/* default for "first", etc. if no message */
	     end;
	     else do;
		if output_buffer = "" & return_one_sw then output_buffer = "0";
		if ^active_request then call ioa_ ("^a", output_buffer);
	     end;
	end;

/* phx20589 RL - change current message only if not active request; */
/* also check that set_new_current_msg is called with a non-zero new */
/* current message since we don't want to change the current message */
/* if it's zero and the call to set_new_current_msg may do that */
	if ^active_request & new_current_message ^= 0 then
	     call rdm_mailbox_interface_$set_new_current_msg (rdm_invocation_ptr, new_current_message,
		rdm_invocation.current_message);

	return;



/* Internal to perform_list_request: lists a single message */

list_single_message:
	procedure ();

	     call rdm_mailbox_interface_$read_message (rdm_invocation_ptr, message_number, message_ptr, code);
	     if code ^= 0 then
		call ssu_$abort_line (P_sci_ptr, code, "Reading message #^d from ^a.", message_number,
		     rdm_invocation.mailbox_name);

	     call mlsys_utils_$print_message_summary (message_ptr, message_number,
		(message_number = new_current_message), listing_line_length, iox_$user_output, code);
	     if code ^= 0 then
		call ssu_$abort_line (P_sci_ptr, code, "Printing listing of message #^d.", message_number);

	     call rdm_mailbox_interface_$mark_processed (rdm_invocation_ptr, message_number);

	     return;

	end list_single_message;

     end perform_list_request;
%page;
/* Prints the selected messages: implements the guts of the print and print_header requests */

perform_printing_request:
     procedure ();

	if formatting_mode = BRIEF_FORMATTING_MODE then
	     local_fmo.envelope_formatting_mode = NONE_FORMATTING_MODE;
	else local_fmo.envelope_formatting_mode = formatting_mode;

	local_fmo.header_formatting_mode, local_fmo.redistributions_list_formatting_mode = formatting_mode;

	do message_idx = first_message_idx to last_message_idx by message_idx_increment;
	     message_number = marked_chain.messages (message_idx);

	     call rdm_mailbox_interface_$read_message (rdm_invocation_ptr, message_number, message_ptr, code);
	     if code ^= 0 then
		call ssu_$abort_line (P_sci_ptr, code, "Reading message #^d from ^a.", message_number,
		     rdm_invocation.mailbox_name);

/* phx18564 RL - set current message to message_number only if it is not a deleted message;
   otherwise current set to next non-deleted message after message_number */
	     call rdm_mailbox_interface_$set_new_current_msg (rdm_invocation_ptr, message_number,
		rdm_invocation.current_message);

/* it's current while we're printing it */

	     /*** following ioa_ call is OK until messages appear with sections that aren't preformatted */
	     call ioa_ ("^/ #^d^[ (^d line^[s^] in body)^]:", message_number, (message.total_lines ^= -1),
		message.total_lines, (message.total_lines ^= 1));
	     call mlsys_utils_$print_message (message_ptr, addr (local_fmo), iox_$user_output, code);
	     if code ^= 0 then
		call ssu_$abort_line (P_sci_ptr, code, "Attempting to print message #^d.", message_number);
	     call ioa_ (" ---(^d)---", message_number);
	     call iox_$control (iox_$user_output, "reset_more", null (), (0));

	     call rdm_mailbox_interface_$mark_processed_and_acknowledge (rdm_invocation_ptr, message_number);

	     if request = PRINT_REQUEST then
		call mail_system_$set_message_switch (message_ptr, PER_MESSAGE_SEEN_SWITCH_TYPE, "1"b, (0));
	end;

	return;

     end perform_printing_request;

%page;
set_switch:
     proc (P_sci_ptr);

dcl  P_sci_ptr ptr;
dcl  switch_value bit (1) aligned;

	if request = SWITCH_OFF_REQUEST then
	     switch_value = "0"b;
	else switch_value = "1"b;

	do message_idx = first_message_idx to last_message_idx by message_idx_increment;
	     message_number = marked_chain.messages (message_idx);

	     call rdm_mailbox_interface_$read_message (rdm_invocation_ptr, message_number, message_ptr, code);
	     if code ^= 0 then
		call ssu_$abort_line (P_sci_ptr, code, "Reading message #^d from ^a.", message_number,
		     rdm_invocation.mailbox_name);

	     call mail_system_$set_message_switch (message_ptr, switch_type, switch_value, code);
	     if code ^= 0 then call ssu_$abort_line (P_sci_ptr, code, "Setting switch on message ^d", message_number);
	end;

	return;

     end set_switch;
%page;
/* Determines if the supplied address list is empty */

is_empty_list:
     procedure (p_address_list_ptr) returns (bit (1) aligned);

dcl  p_address_list_ptr pointer parameter;

	if p_address_list_ptr = null () then		/* no data at all */
	     return ("1"b);

	else return ((p_address_list_ptr -> address_list.n_addresses = 0));

     end is_empty_list;
%page;
%include rdm_invocation;
%page;
%include rdm_message_list;
%page;
%include rdm_message_chains;
%page;
%include rdm_msg_spec_keywords;
%page;
%include rdm_switch_types;
%page;
%include sdm_invocation;
%page;
%include rdm_fwd_invocation;
%page;
%include mlsys_format_options;
%page;
%include mlsys_parse_ca_options;
%page;
%include mlsys_field_names;
%page;
%include mlsys_mailbox;
%page;
%include mlsys_field_types;
%page;
%include mlsys_message;
%page;
%include mlsys_address_list;
%page;
/* The standard definition of whitespace on Multics */

dcl  WHITESPACE character (5) static options (constant) initial (" 	
");						/* SP HT NL VT FF */

     end rdm_msg_requests_;
