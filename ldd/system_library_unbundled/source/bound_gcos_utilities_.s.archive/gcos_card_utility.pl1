/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   * Copyright (c) 1972 by Massachusetts Institute of        *
   * Technology and Honeywell Information Systems, Inc.      *
   *                                                         *
   *********************************************************** */


gcos_card_utility: gcu: proc;

/*
   *  This command copies GCOS card image files, changing their format,
   *  content and medium as specified by the control arguments given.
   *
   *	USAGE: gcu input_specification output_specification
   *
   *  The input and output specifications are composed of pathnames and
   *  control arguments. The list of arguments that can be used is very long,
   *  and is documented in the MPM, so it will not be repeated here.
   *
   *  This procedure only processes the command line. It calls the subroutine
   *  gcos_card_utility_ to do the real work.
*/
%page;
/*
   *	WRITTEN BY T. CASEY	 MAY 1973
   *	MODIFIED BY T. CASEY
   *			 SEPTEMBER 1973
   *			 OCTOBER 1973
   *			 MARCH 1974
   *			 AUGUST 1974
   *			 NOVEMBER 1974
   *			 JULY 1975
   *			 MARCH 1976
   *
   *	MODIFIED BY S. AKERS AUGUST, 1981:
   *				     Fix range errors in suffix checking.
   *				     Make suffix checking more efficient.
   *
   *				     Add "-canonicalize" "-can" "-ncan"
   *				     "-gcos_bcd" "-gcb" control_args.
   *				     Change handling of canonicalization,
   *				     new default is to NOT do it. Ignore
   *				     the "-no" control_arg.
   *
   *				     Changed formfeed to %page;
   *
   *				     Fixed control_arg checker so it
   *				     doesn't generate stringrange errors.
   *  Modified: Ron Barstad      82-09-28  Fixed typo error in label err(68)
   *  Modified: Ron Barstad  2.0 83-02-08  Fix nested if in -tape arg processing
   *                                       Added version in "me", started with 2.0
   * Modified: Ron Barstad  2.1 83-06-09  Allowed conversion to ascii or gcos_ascii
   *                                      from BCD media code 0 to be over 80 chars
   * Modified: Ron Barstad  2.2 83-07-13  Fixed -tape group again, find bad -args >4 chars
   */
%page;
/*  D  E  C  L  A  R  A  T  I  O  N  S     */

/*	 External Entries		*/

dcl  com_err_ ext entry options (variable);
dcl  cu_$arg_count entry (fixed bin, fixed bin(35));
dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin(21), fixed bin(35));
dcl  cv_dec_check_ ext entry (char (*), fixed bin(35)) returns (fixed bin);
dcl  db ext entry;
dcl  decode_nstd_status_ ext entry (bit (72) aligned, char (*) varying);
dcl  expand_path_ entry (ptr, fixed bin(21), ptr, ptr, fixed bin(35));
dcl  get_system_free_area_ ext entry returns (ptr);
dcl  gcos_card_utility_ ext entry (ptr, ptr, fixed bin(35));
dcl  hcs_$initiate_count ext entry
    (char (*) aligned, char (*) aligned, char (*) aligned, fixed bin(24), fixed bin(2), ptr, fixed bin(35));
dcl  hcs_$terminate_noname ext entry (ptr, fixed bin(35));
dcl (ioa_, ioa_$nnl) ext entry options (variable);
dcl  ios_$attach ext entry
    (char (*) aligned, char (*) aligned, char (*) aligned, char (*) aligned, bit (72) aligned);
dcl  ios_$detach ext entry
    (char (*) aligned, char (*) aligned, char (*) aligned, bit (72) aligned);

dcl (
     error_table_$badopt
     , error_table_$inconsistent
     , error_table_$ioname_not_found
     , error_table_$noarg
     ) ext fixed bin(35);

/*	Builtin	*/

dcl (addr, baseno, divide, length,
     max, null, substr, index, reverse, rtrim, unspec)	builtin;

dcl  cleanup condition;

/*	 For argument processing	*/

dcl  ap ptr;
dcl  al fixed bin(21);
dcl  arg char (al) based (ap);
dcl (nargs, argno) fixed bin;

dcl (i, j, k, l, m, n) fixed bin(24);
dcl (starting_line_no, ending_line_no, no_of_lines) fixed bin(24)init (0);

dcl  status bit (72) aligned;
dcl  code fixed bin(35) aligned based (addr (status));
dcl  numeric_arg fixed bin(24);
dcl  tab_index fixed bin(24)init (0);

dcl  expected_arg fixed bin(24)init (0);

/* For program readability, we assign names to the numeric values
   that the multi-valued switch - expected_arg - can have */

dcl (						/* names in alphabetic order */
     first_line init (31)
     , last_line init (32)
     , line_count init (33)
     , list init (34)
     , list_file init (35)
     , tabs init (36)
     , tape_id init (37)
     , tape_label init (38)
     ) fixed bin(24)int static;

dcl (						/* switches init off */
     io_spec_given (2),				/* on when input or output spec is completed */
     io_source_given (2),				/* on after a tape or file name has been given */
     list_finished (2)				/* on when a list has been given - only one is allowed */
     ) bit (1) aligned init ((2) (1) "0"b);

dcl (
     fixed_in_db
     , list_started					/* on while reading list elements from arg list */
     , verify_suffix				/* on if we must check for consistent suffixes
						   in a list of pathnames */
     , detach_tapes					/* on if only detaching tapes left attached
						   from previous use of this command */
     , normal_termination				/* distinguish cleanup condition from normal termination */
     ) bit (1) aligned init ("0"b);

dcl  me char (23) aligned int static options (constant) init ("gcos_card_utility (2.2)");

dcl  dirname char (168) aligned;
dcl  ename char (32) aligned;
dcl  bitcount fixed bin(24);
dcl  segptr ptr init (null);
dcl  seglen fixed bin(24);
dcl  seg_olay char (seglen) based (segptr);

dcl  rw char (1) aligned;						/* "r" or " " (rw) for tape attachments */

dcl  newline char (1) unaligned int static init ("
");

dcl  word_string_len fixed bin(24)init (1);
dcl  word_string (word_string_len) bit (36) aligned based;
dcl (numeric, control) bit (1) init ("0"b);

dcl  free_ptr ptr based (free_ptr_ptr);						/* used in cleanup_proc to free allocated storage */
dcl  free_ptr_ptr ptr;						/* this is NOT a typing error */

dcl  system_free_ptr ptr init (get_system_free_area_ ());
dcl  system_free_area area based (system_free_ptr);

/*	For calling gcos_card_utility_	*/

dcl 1 input_structure_area like input automatic;						/* place to put input structure */
dcl 1 output_structure_area like output automatic;						/* place to put output structure */


%include gcos_utility_args_;
%page;
/*  P  R  O  C  E  D  U  R  E     */

	call cu_$arg_count (nargs,code);
	if nargs = 0 then do;
	     code = error_table_$noarg;
	     call com_err_ (code, me,
		"^/Usage: gcu input_specification output_specification");
	     return;
	end;

/*  Initialize */

	input_ptr = addr (input_structure_area);
	output_ptr = addr (output_structure_area);
	unspec (input) = ""b;			/* zero out the structures */
	unspec (output) = ""b;			/* to avoid problems with garbage */

	input.list_ptr, input.tape_ptr = null;		/* don't want zeros there, though */
	output.list_ptr, output.tape_ptr = null;
	input.sw = input_code;
	output.sw = output_code;

	input.com_err = "1"b;			/* tell gcos_card_utility_ subroutine to
						   call com_err_ if any errors occur */

	io_ptr = input_ptr;				/* start with input spec unless user says -output */
	input.no_canon = "1"b;			/* Default is no canonicalization */

	on condition (cleanup) call cleanup_proc;


arg_loop:	do argno = 1 to nargs;

	     call cu_$arg_ptr (argno, ap, al, code);
	     if code ^= 0 then call arg_error (2);

	     numeric_arg = cv_dec_check_ (arg, code);	/* see if it's a numeric arg */
	     if code = 0 then numeric = "1"b;
	     else numeric = "0"b;
	     code = 0;				/* to avoid confusion if errors later */

	     if substr (arg, 1, 1) = "-" then control = "1"b; /* see if it's a control arg */
	     else control = "0"b;

	     if expected_arg ^= 0 then		/* if we are expecting anything specific */
interpret_expected_arg: do;

/* In alphabetic order by name */

		if expected_arg = first_line then do;
		     if ^numeric then call arg_error (3); /* numeric arg missing */
		     starting_line_no = numeric_arg;
		     expected_arg = 0;
		end;

		else if expected_arg = last_line then do;
		     if ^numeric then call arg_error (4); /* expected numeric arg missing */
		     ending_line_no = numeric_arg;
		     expected_arg = 0;
		end;

		else if expected_arg = line_count then do;
		     if ^numeric then call arg_error (5); /* numeric arg missing */
		     no_of_lines = numeric_arg;
		     expected_arg = 0;
		end;

		else if expected_arg = list then do;
		     if list_started then do;		/* if not first time */
			if control then do;		/* control arg signals end of list */
			     expected_arg = 0;	/* back to looking for ctl args */
			     list_finished (io.sw) = "1"b; /* remember that list was read */
			     goto interpret_control_arg; /* go process this arg */
			end;

			if al > io.list_name_size then call arg_error (6); /* name too long */
			io.list_count = io.list_count + 1; /* bump count */

			if io.set = multiple_files	/* if pathname */
			then do;
			     io_list (io.list_count).names = get_io_pathname (arg);
			     call check_suffix (arg);
			     end;
			else io_list (io.list_count).names = arg; /* else snumb or edit name */

		     end;

		     else do;			/* first argument in list - it could be the first name,
						   or one of -all, -name, or -file_input */
			if control then do;
			     if arg = "-fi" | arg = "-file" | arg = "-file_input" then
				expected_arg = list_file; /* next arg will be pathname */
			     else if arg = "-all" then do;
				if io.sw = output_code then
				     call arg_error (7); /* -all only allowed in input list */
				if input.set = multiple_files then
				     call arg_error (8); /* -all only allowed after -gmap ot -library or -imcv */
				input.all = "1"b;
				input.list_count = 99999; /* arbitrary large number */
				expected_arg = 0;
			     end;
			     else if arg = "-nm" | arg = "-name" | arg = "-names" then do;
				if io.sw = input_code then
				     call arg_error (9); /* -name only allowed in output list */
				output.name_files = "1"b;
				output.list_count = 99999; /* arbitrary large number */
				expected_arg = 0;
			     end;
			     else call arg_error (10); /* expected arg missing */
			end;

			else do;			/* allocate and initialize list */
			     if al > io.list_name_size then call arg_error (11); /* name too long */
			     list_started = "1"b;
			     io.list_count = nargs - argno + 1; /* max list length is rest of args */
			     allocate io_list in (system_free_area) set (io.list_ptr);
			     unspec (io_list) = ""b;	/* clear it */
			     io.list_count = 1;
			     io_list (1).names = arg; /* save first item in list */
			end;			/* end alloc and init list */
		     end;				/* end first time */
		end;				/* end expecting list item */

		else if expected_arg = list_file then do;

		     expected_arg = 0;		/* turn off the expected switch */

		     call expand_path_ (addr (arg), al, addr (dirname), addr (ename), code);
		     if code ^= 0 then call arg_error (12); /* from a file system call */
		     call hcs_$initiate_count (dirname, ename, "", bitcount, 0, segptr, code);
		     if segptr = null then call arg_error (13); /* from a file system call */
		     code = 0;			/* clear possble error_table_$segknown,
						   to avoid confusion if a real error occurs later */

		     seglen = divide (bitcount, 9, 17, 0);
		     k = 0;			/* counter for newlines */
		     n = 1;			/* start with first char */
		     l = seglen;			/* have whole seg left to search */

		     do while (l > 0);		/* search whole seg */
			m = index (substr (seg_olay, n, l), newline); /* for newlines */
			if m ^= 0 then do;		/* if we found one */
			     if m > 1 then		/* don't blow up on blank lines */
				k = k + 1;	/* count newlines (actually counting names) */
			     if m > io.list_name_size + 1 then call arg_error (14); /* name too long */
			     l = l - m;		/* shorten string yet to be searched */
			     n = n + m;		/* move past this newline */
			end;
			else l = 0;		/* no newline at end - but end of segment anyway */
		     end;				/* end of name counting loop */

		     io.list_count = k;		/* actual length of list */
		     allocate io_list in (system_free_area) set (io.list_ptr); /* allocate storage for list */
		     unspec (io_list) = ""b;		/* clear it */

		     l = seglen;			/* re init length of string to be processed */
		     n = 1;			/* and starting char of the string */
		     do k = 1 to io.list_count;	/* copy names from seg to structure */
indx:			m = index (substr (seg_olay, n, l), newline);
			if m > 1 then do;		/* check for blank lines */
			     if io.set = multiple_files	/* if pathname */
			     then do;
				io_list (k).names = get_io_pathname (substr (seg_olay, n, m-1));
				call check_suffix (substr (seg_olay, n, m-1));
				end;
			     else			/* else must be snumb or edit name */
			     io_list (k).names = substr (seg_olay, n, m-1); /* name, less the newline */
			end;
			n = n + m;		/* move past name */
			l = l - m;		/* shorten the string */
			if m = 1 then goto indx;	/* dont increment k if it was a blank line */
		     end;
		     list_finished (io.sw) = "1"b;	/* remember that we already have the list */
		     call hcs_$terminate_noname (segptr, code);
		     if code ^= 0 then
			call arg_error (67);	/* OUT OF ORDER - ADDED LATER */
		end;				/* end of expecting list file do group */

		else if expected_arg = tabs then do;

		     if ^numeric then do;		/* can't be a tabstop if not numeric */
			if tab_index = 0 then
			     call arg_error (15);	/* tabstop arguments missing */
			else do;			/* end of tabstop list is signified by any non numeric arg */
			     expected_arg = 0;
			     if control then
				goto interpret_control_arg;
			     else goto interpret_path;
			end;
		     end;				/* end of non numeric do group */

		     else do;			/* it was numeric - see if it is a legal tabstop */
			if numeric_arg < 2
			| numeric_arg > 80 then
			     call arg_error (16);	/* tabstop can't be before col 2 or past col 80 */
			if tab_index > 0 then	/* if not first tabstop */
			     if numeric_arg ^> input.tabstops (tab_index) then /* it must be > previous one */
				call arg_error (17); /* tabstops not in increasing numeric order */

			tab_index = tab_index + 1;
			if tab_index > 10 then
			     call arg_error (18);	/* only 10 tabstops allowed */
			input.tabstops (tab_index) = numeric_arg;
		     end;				/* end of numeric arg do group */
		end;				/* end of expecting tabstops do group */

		else if expected_arg = tape_id then do;
		     if al > 32 then call arg_error (19); /* tape id too long */
		     io_tape.id = arg;
		     if control then
			if arg = "-att" | arg = "-attached" then
			     io_tape.attached = "1"b;
		     expected_arg = 0;
		end;

		else if expected_arg = tape_label then do;
		     expected_arg = 0;
		     if numeric then		/* check for easiest case first */
			io_tape.position = numeric_arg;
		     else do;			/* check for label or n,label or label,n */
			i = index (arg, ",");	/* look for comma */
			if i = 0 then do;		/* no comma - all label */
			     m = 1;		/* set up substr parameters to pick up whole arg */
			     n = al;
			     goto check_label;	/* and go see if its an ok label */
			end;
						/* set up substring parameters */
			k = 1;l = i-1;		/* part before comma */
			m = i+1;n = al-i;		/* part after comma */
			j = index (substr (arg, m, n), ","); /* look for extra comma */
			if j ^= 0 then
			     call arg_error (20);	/* bad tape label format - 2 commas */
cv_dec_label:		j = cv_dec_check_ (substr (arg, k, l), code);
			if code ^= 0 then do;
			     code = 0;		/* not an error_table_ code - clear it */
			     if m = 1 then		/* if we already switched */
				call arg_error (21); /* bad tape label format - comma but no numeric field */
			     else do;		/* switch fields */
				k = m;l = n;	/* maybe the second part is numeric */
				m = 1;n = i-1;	/* and the first is the label */
				goto cv_dec_label;	/* go try to convert it */
			     end;			/* end switch fields */
			end;			/* end code = 0 */
			io_tape.position = j;	/* save position */
check_label:		if n > 12 then
			     call arg_error (22);	/* bad tape label format - label > 12 chars */
			io_tape.label = substr (arg, m, n);
		     end;				/* end of check for label or n,label do group */
		end;				/* end of expecting label do group */


		else				/* expected arg has bad value */
		call arg_error (-1);		/* -1 means "program bug" */

	     end interpret_expected_arg;


	     else if control then			/* not expecting anything */
interpret_control_arg: do;				/* if control arg, see what it is */

/* In alphabetic order by the long spelling of the argument */

/* -all only allowed in a list; checked for after all legal args, below */

		if arg = "-app" | arg = "-append" then do;
		     if io.sw = input_code then call arg_error (23); /* -append legal only for output */
		     output.append = "1"b;
		end;

		else if arg = "-aci" | arg = "-ascii" then do;
		     if io.format ^= 0 then
			if io.format ^= ascii then
			     call arg_error (24);	/* inconsistent format spec */
		     io.format = ascii;
		     if io.medium ^= 0 then		/* DON'T THINK THIS CAN EVER HAPPEN - */
			if io.medium ^= file then	/* BUT LET'S BE SAFE */
			     call arg_error (25);	/* inconsistent medium spec */
		     io.medium = file;
		end;

		else if arg = "-att" | arg = "-attached" then do;
		     if io.medium ^= tape then
			call arg_error (50);	/* OUT OF ORDER - MESSAGE CHANGED */
		     io_tape.attached = "1"b;
		end;

		else if arg = "-bf" | arg = "-brief" then
		     io.brief = "1"b;

		else if arg = "-cdk" | arg = "-comdk" then do;
		     io.comdk = "1"b;
		     if io.format ^= 0 then
			if io.format ^= gcos then
			     call arg_error (26);	/* inconsistent format spec */
		     io.format = gcos;
		end;

		else if arg = "-ct" | arg = "-count" then do;
		     if io.sw = output_code then call arg_error (27); /* not allowed for output */
		     if no_of_lines ^= 0 | ending_line_no ^= 0 then /* if that info already given */
			call arg_error (28);	/* inconsistent args */
		     expected_arg = line_count;
		end;

		else if arg = "-db" | arg = "-debug" then
		     input.debug = "1"b;

		else if arg = "-det" | arg = "-detach" then do;
		     if argno = nargs then		/* check for special case */
			if argno = 1		/* -detach the only argument */
			| (argno = 2 & input.debug) then /* or just preceeded by -debug */
			     detach_tapes = "1"b;	/* if so detach tapes and quit */
detach_tape:
		     call ios_$detach (tape_stream (io.sw), "", "", status);
		     if code ^= 0 then
			if code ^= error_table_$ioname_not_found then
			     call arg_error (29);	/* error detaching tape */
		     if detach_tapes then do;		/* if detaching both tapes */
			if io.sw = input_code then do;
			     io_ptr = output_ptr;
			     goto detach_tape;
			end;
			else return;		/* all done - just called to detach tapes */
		     end;				/* end of just detaching do group */
		end;				/* end of -detach do group */

/* -file_input only allowed in a list; checked for after all legal args, below */

		else if arg = "-ft" | arg = "-first" then do;
		     if io.sw = output_code then call arg_error (30); /* not legal for output */
		     if starting_line_no ^= 0 then call arg_error (31);
		     expected_arg = first_line;
		end;

		else if arg = "-gc" | arg = "-gcos" then do;
gcos_arg:		     if io.format ^= 0 then
			if io.format ^= gcos then
			     call arg_error (32);	/* inconsistent format spec */
		     io.format = gcos;
		end;

		else if arg = "-gca" | arg = "-gcos_ascii" then do;
		     if io.sw = input_code then call arg_error (72); /* OUT OF ORDER - ADDED LATER */
		     output.gcos_ascii = "1"b;
		     goto gcos_arg;
		end;

		else if arg = "-gcb" | arg = "-gcos_bcd" then do;
		     if io.sw = input_code then call arg_error (72); /* OUT OF ORDER - ADDED LATER */
		     output.gcos_bcd = "1"b;
		     goto gcos_arg;
		end;

		else if arg = "-gmap" | arg = "-lib" | arg = "-library" then do;
		     input.set = library;
		     input.list_name_size = 4;	/* library edit names are 4 chars */
set_up_for_list:					/* come here from -imcv to finish setting up for list */
		     if io.sw = output_code then call arg_error (33);
		     if list_finished (io.sw) then call arg_error (34); /* already given */
		     expected_arg = list;
		     list_started = "0"b;		/* we want to special-case the first list element */
		end;

		else if arg = "-imcv" then do;
		     input.set = imcv;
		     input.list_name_size = 5;	/* snumbs are 5 chars max */
		     goto set_up_for_list;		/* go share code with -library */
		end;

		else if arg = "-in" | arg = "-input" then do;
		     if argno > 1 then		/* except for first argument, when io.sw is
						   initialized to the default (input_code) */
			if argno ^= 2 | ^input.debug then /* (or if first arg was -db and this is the 2nd) */
			     io_spec_given (io.sw) = "1"b; /* remember that input or output (io.sw says which)
						   specs have already been given */
		     if io_spec_given (input_code) then /* if input specs have already been given */
			call arg_error (35);	/* do not allow them to be given again */
		     io_ptr = input_ptr;		/* switch to processing the input specification */
		end;

		else if arg = "-lbl" | arg = "-label" then do;
		     if io.medium ^= tape then
			call arg_error (36);	/* -tape must preceed -retain or -label */
		     expected_arg = tape_label;
		end;

/* -library is a generalization of -gmap, and is processed above, with -gmap */

		else if arg = "-lt" | arg = "-last" then do;
		     if io.sw = output_code then call arg_error (37); /* not allowed for output */
		     if no_of_lines ^= 0 | ending_line_no ^= 0 then /* if that info already given */
			call arg_error (38);	/* inconsistent args */
		     expected_arg = last_line;
		end;

		else if arg = "-ls" | arg = "-list" then do;
		     if io_source_given (io.sw) then
			call arg_error (39);	/* can't say -list if -tape or pathname already given */
		     io_source_given (io.sw) = "1"b;
		     if list_finished (io.sw) then
			call arg_error (40);	/* only one list allowed */
		     list_started = "0"b;		/* so we can special case the first list item */
		     expected_arg = list;
		     io.list_name_size = 168;		/* max length of pathname */
		     io.set = multiple_files;
		     if io.medium ^= raw then
			io.medium = file;
		     if io.format ^= 0 then		/* if format already given */
			verify_suffix = "0"b;	/* ignore suffixes */
		     else verify_suffix = "1"b;	/* otherwise first suffix determines format,
						   and the rest must be consistent with it */
		end;

		else if arg = "-lg" | arg = "-long" then
		     io.long = "1"b;

		else if arg = "-no" | arg = "-no_canonicalize"
		      | arg = "-ncan"
		     then do;
			if io.sw = output_code then call arg_error (41); /* legal only for input */
			input.no_canon = "1"b;
			end;

		else if arg = "-can" | arg = "-canonicalize"
		     then do;
			if io.sw = output_code then call arg_error (41); /* legal only for input */
			input.no_canon = "0"b;
			end;

/* -name only allowed in a list; checked for after all legal args, below */

		else if arg = "-out" | arg = "-output" then do;
		     if argno > 1 then
			if argno ^= 2 | ^input.debug then
			     io_spec_given (io.sw) = "1"b; /* same logic as for input */
		     if io_spec_given (output_code) then call arg_error (42);
		     io_ptr = output_ptr;		/* switch to processing output specification */
		end;

		else if arg = "-raw" then do;
		     if io.medium = tape then
			call arg_error (43);	/* inconsistent medium spec */
		     io.medium = raw;
		     if io.format ^= 0 then
			if io.format ^= gcos then
			     call arg_error (44);	/* inconsistent format spec */
		     io.format = gcos;
		end;

		else if arg = "-ret" | arg = "-retain" then do;
		     if io.medium ^= tape then
			call arg_error (45);	/* -tape must preceed -retain or -label */
		     io_tape.retain = "1"b;
		end;

		else if arg = "-tabs" then do;
		     if io.sw = output_code then
			call arg_error (66);	/* OUT OF ORDER - ADDED LATER */
		     if input.tabs_given then
			call arg_error (46);	/* can't give tabs twice */
		     input.tabs_given = "1"b;
		     expected_arg = tabs;
		end;

		else if (arg = "-tape") | (arg = "-tape7") | (arg = "-tape9") then do;
		     if io_source_given (io.sw) then
			call arg_error (47);	/* can't say -tape after giving file name */
		     io_source_given (io.sw) = "1"b;
		     if io.medium ^= 0 then		/* possible -raw -tape */
			call arg_error (69);	/* OUT OF ORDER - ADDED LATER */
		     io.medium = tape;
		     if io.format ^= 0 then
			if io.format ^= gcos then
			     call arg_error (48);	/* inconsistent format spec */
		     io.format = gcos;		/* can only be gcos files on tape */
		     allocate io_tape in (system_free_area) set (io.tape_ptr);
		     unspec (io_tape) = ""b;		/* clear it */
		     io_tape.label = "";		/* want blanks (not zeros) in label field */
		     if al > 5 then do;		/* see if a 7 or 9 on the end */
			io_tape.tracks = substr (arg, 6, 1);
			if (io_tape.tracks ^= "7"
			& io_tape.tracks ^= "9")
			|al ^= 6
			then call arg_error (49);
		     end;
		     else io_tape.tracks = " ";
		     expected_arg = tape_id;
		end;				/* end of -tape do group */

		else if arg = "-tc" | arg = "-tnc" | arg = "-truncate" then
		     io.truncate_ascii = "1"b;


/* The following control arguments are only allowed in place of some expected
   argument, and their occurrence out of context is an error */

		else if arg = "-fi" | arg = "-file" | arg = "-file_input"
		| arg = "-all" | arg = "-nm" | arg = "-name" then
		     call arg_error (51);		/* only allowed in place of a list */

		else				/* bad control arg */
		call arg_error (52);

	     end interpret_control_arg;


/* interpret non-control arg - i.e. pathname not preceeded by ctl arg */

	     else
interpret_path: do;

check_if_given:	if io_source_given (io.sw) then	/* if a pathname or tape number was already given */
switch_io:	     do;				/* for the current spec, switch to the other one */
						/* if -in and -out not given, the default is -in, then -out, with
						   the switch being made when the second pathname is found */
		     if io.sw = input_code then
			io_ptr = output_ptr;
		     else call arg_error (53);
		     goto check_if_given;		/* in case both have been given */
		end switch_io;

		io.set = single_file;
		if io.medium ^= raw then		/* unless -raw preceeded this */
		     io.medium = file;
		io_source_given (io.sw) = "1"b;

		io.file_name = get_io_pathname (arg);	/* expand the pathname */
		call check_suffix (arg);		/* validate the suffix, if there is one */

	     end interpret_path;

	end arg_loop;

/* Check input and output specification for completeness and consistency */

	if expected_arg ^= 0 then do;			/* still expecting an argument? */
	     if list_started then			/* were we in a list, with first item already given? */
		list_finished (io.sw) = "1"b;		/* it's ok for arg list to end in a list */
	     else if expected_arg ^= tabs then		/* also ok to end with list of tabstops */
		call arg_error (54);		/* expected arg missing after last arg on line */
	end;

/* check io stuff */
	do io_ptr = input_ptr, output_ptr;

	     if io.format = 0 then
		io.format = ascii;			/* the default */

	     if io.set = 0 then
		io.set = single_file;		/* if no list was given, this is still zero */

	     if ^io_source_given (io.sw) then
		call arg_error (55);		/* io spec incomplete - must give tape or file name */

	     if io.format ^= ascii then
		if io.truncate_ascii then
		     call arg_error (56);		/* -truncate only allowed for ascii */

/* check input-only stuff */

	     if io.sw = input_code
	     then do;

		input.first_line = starting_line_no;	/* will be zero if -ft not given */
		if no_of_lines ^= 0			/* if -ct given */
		then input.last_line = max (input.first_line, 1) + no_of_lines -1; /* then compute last line no */
		else input.last_line = ending_line_no;	/* will be zero if -lt not given */

		end;

/* check output-only stuff */
	     if io.sw = output_code
	     then do;
		if output.append
		then if output.medium = tape
		     then call arg_error (58);	/* can not append to a tape file */
		if output.name_files 
		then if input.set ^= library 
		     then if input.set ^= imcv
			then call arg_error (70);	/* OUT OF ORDER - ADDED LATER */
		end;
	end;

/* Check for tape to disk copy, to avoid deblocking if possible */

	do io_ptr = input_ptr, output_ptr;
	     if io.format ^= gcos then goto not_blocks;
	     if io.comdk then goto not_blocks;
	     if io.medium = raw then goto not_blocks;
	     if io.set ^= single_file then goto not_blocks;
	end;
	if output.append 		then goto not_blocks;
	if output.gcos_ascii 	then goto not_blocks;
	if output.gcos_bcd 		then goto not_blocks;
	if input.first_line  ^= 0 	then goto not_blocks;
	if input.last_line   ^= 0 	then goto not_blocks;

	input.format, output.format = blocks;		/* We can copy without deblocking */

not_blocks:


/* Attach tapes here to minimize mounting and dismounting */

	do io_ptr = input_ptr, output_ptr;
	     if io.sw = input_code then
		rw = "r";				/* attach input tape in read-only mode */
	     else rw = " ";				/* equivalent to "rw" for ios_$attach */
	     if io.medium = tape then
		if ^io_tape.attached then do;

/* ***** NOTE *****
   The method of specifying tracks and density is undergoing some changes
   (July 1975). The validity of this code must be reviewed periodically. */
		     if io_tape.tracks ^= " " then do;	/* if tracks given by -tape7 or -tape9 */
			i = index (io_tape.id, " ");	/* find end of tape name and append ",Ntrack" */
			if substr (io_tape.id, i-5, 5) ^= "track" then /* but make sure it's not there already */
			     if i <= 26 then	/* and there's room to put it there */
				substr (io_tape.id, i, 7) = "," || io_tape.tracks || "track";
		     end;
		     io_tape.attached = "1"b;		/* for cleanup_proc; turn on BEFORE calling attach */
		     call ios_$attach (tape_stream (io.sw), "nstd_", io_tape.id, rw, status);
		     if code ^= 0 then
			call arg_error (59);	/* error attaching tape */
		end;				/* end tape and not attached do group */
	end;					/* end attach tapes do loop */

/* now call subroutine to do the real work */
	call gcos_card_utility_ (input_ptr, output_ptr, code);
	if code ^= 0 then
	     if ^input.com_err then			/* if subroutine did not call com_err_ */
		call com_err_ (code, me);

	revert cleanup;

	normal_termination = "1"b;			/* tell cleanup_proc that this is not cleanup condition */
	call cleanup_proc;				/* used for cleanup and normal termination */
quit:	return;
%page;
/*  I  N  T  E  R  N  A  L     P  R  O  C  E  D  U  R  E  S     */


/* Procedure to format and print error messages */

arg_error: proc (error_code);

dcl  error_code fixed bin(24);			/* identifies the place where the error occurred.  Each call
						   has a different number, even if the message is the same.
						   The first 64 are in order in the program. Those above 64
						   were added later and are out of order. */

dcl  max_error_code fixed bin(24)init (71);		/* next available error_code value is 72 */

dcl  bad_arg char (168) varying;			/* the bad argument or pathname */
dcl (err_msg, msg2) char (200) varying;			/* portions of message text */

dcl  mnames (11:20) char (8) aligned int static init (
     "filename",
     "snumb",
     "editname",
     "filename",
     "ascii",
     "gcos",
     "blocks",
     "raw",
     "tape",
     "file");


	     bad_arg = arg;				/* the bad thing is the current argument */
	     goto arg_error_common;

/* Entry called from get_io_pathname - second argument is the bad pathname */
path_error:    entry (error_code, err_path);

dcl  err_path char (*);						/* might be from a file instead of an argument */

	     bad_arg = err_path;			/* argment or file item to be printed */

arg_error_common:

	     if error_code < 2 | error_code > max_error_code then do;
		err_msg = "Program bug. ^a";
		goto call_com_err;
	     end;

/* Use error_code as an index into a transfer vector that the compiler
   will build for us. This is implemented efficiently in the v2pl1 compiler */

	     goto err (error_code);

/* Since we checked the upper and lower bound of error code above, no problems can arise */

err (2):
	     err_msg = "^a From cu_$arg_ptr.";
	     goto call_com_err;

err (3): err (4): err (5):
	     err_msg = "Numeric, before ^a";
	     goto et_noarg;				/* go set code = error_table_$noarg */

err (6): err (11):
	     err_msg = "Name in list is too long: ^a^/Max length of ^a is ^d.";
	     msg2 = mnames (io.set);
	     numeric_arg = io.list_name_size;
	     goto call_com_err;

err (7): err (27): err (30): err (33): err (37): err (41): err (66):
	     err_msg = "This argument is only allowed in the input specification: ^a";
	     goto call_com_err;

err (8):
	     err_msg = "-all only allowed immediately following -gmap, -library, or -imcv";
	     goto call_com_err;

err (9): err (23): err (72):
	     err_msg = "This argument is only allowed in the output specification: ^a";
	     goto call_com_err;

err (10):
	     err_msg = "list item, before ^a";
	     goto et_noarg;

err (12): err (60):
	     err_msg = "From expand_path_ ^a";
	     goto call_com_err;

err (13):
	     err_msg = "From hcs_$initiate_count ^a";
	     goto call_com_err;

err (14):
	     bad_arg = substr (seg_olay, n, m-1);	/* pick up bad name from file */
	     goto err (6);				/* and go set up the "too long" message */

err (15):
	     err_msg = "Tabstops, before ^a";
	     goto et_noarg;

err (16):
	     err_msg = "Illegal tabstop value: ^a^/Value must be 2 thru 80.";
	     goto call_com_err;

err (17):
	     err_msg = "Tabstop value out of order: ^a^/Previous value was ^s^d";
	     numeric_arg = input.tabstops (tab_index);
	     goto call_com_err;

err (18):
	     err_msg = "Only 10 tabstops allowed: ^a is the 11th.";
	     goto call_com_err;

err (19):
	     err_msg = "Tape number too long: ^a^/Max length is 32 characters.";
	     goto call_com_err;

err (20):
	     err_msg = "Bad tape label format - 2 commas: ^a";
	     goto call_com_err;

err (21):
	     err_msg = "Bad tape label format - comma but no numeric field: ^a";
	     goto call_com_err;

err (22):
	     err_msg = "Bad tape label format - file name too long: ^a^/Max length is 12 characters.";
	     bad_arg = substr (bad_arg, m, n);
	     goto call_com_err;

err (24): err (26): err (32): err (44): err (48): err (61): err (62): err (63): err (64):
	     msg2 = mnames (io.format);
	     goto inconsistent_message;		/* go set err_msg and error_table_$inconsistent */

err (25): err (43): err (69):
	     msg2 = mnames (io.medium);
	     goto inconsistent_message;

err (28): err (31): err (38):
	     err_msg = "^a and the previously specified -first, -last, or -count.";
	     goto et_inconsistent;

err (29):
	     err_msg = "From ios_$detach the previously retained tape.";
	     goto tape_message;			/* check for and decode tape hardware status */

err (34): err (40):
	     err_msg = "Only one list is allowed in the input or output specification: ^a";
	     goto call_com_err;

err (35):
	     msg2 = "the input specification";
	     goto given_message;

err (36): err (45):
	     err_msg = "-tape must preceed ^a";
	     goto call_com_err;

err (39): err (47):
	     msg2 = "a pathname or tape number";
	     goto given_message;

err (42): err (53):
	     msg2 = "the output specification";
	     goto given_message;

err (46):
	     msg2 = "a set of tabstops";
	     goto given_message;

err (49):
	     err_msg = "Illegal form of -tape argument: ^a";
	     goto call_com_err;

err (50):
	     err_msg = "^a only allowed after -tape, in place of, or in addition to, tape number";
	     goto call_com_err;

err (51):
	     err_msg = "^a only allowed in place of a list.";
	     goto call_com_err;

err (52):
	     code = error_table_$badopt;
	     err_msg = "^a";
	     goto call_com_err;

err (54):
	     err_msg = "After ^a";
	     goto et_noarg;

err (55):
	     err_msg = "^a pathname or tape number";
	     bad_arg = io_names (io.sw);
	     goto et_noarg;

err (56):
	     err_msg = "-truncate only allowed for an ASCII file";
	     goto call_com_err;

err (57):
	     err_msg = "-no_canonicalize only allowed for an ASCII file.";
	     goto call_com_err;

err (58):
	     err_msg = "-append is not allowed for a tape output file.";
	     goto call_com_err;

err (59):
	     err_msg = "from ios_$attach ^a";
	     goto tape_id_message;

err (65):
	     err_msg = "From ios_$detach ^a";
	     goto tape_id_message;

err (67): err (68):
	     err_msg = "From hcs_$terminate_noname ^a";
	     goto call_com_err;

err (70):
	     err_msg = "-name only allowed when input is gmap, library, or imcv.";
	     goto call_com_err;

/* Set up error codes and messages common to several of the above */

et_noarg:
	     code = error_table_$noarg;
	     goto call_com_err;

inconsistent_message:
	     err_msg = "^/^a and ^a (previously specified or implied).";
et_inconsistent:
	     code = error_table_$inconsistent;
	     goto call_com_err;

given_message:
	     err_msg = "^a is an error because ^a was previously given.";
	     goto call_com_err;

tape_id_message:
	     bad_arg = io_tape.id;
tape_message:
	     if substr (status, 1, 1) then do;		/* hardware status */
		msg2 = bad_arg;			/* save the tape id */
		call decode_nstd_status_ (status, bad_arg);
		err_msg = "^a^/" || err_msg;		/* print decoded status before rest of message */
	     end;
	     goto call_com_err;

call_com_err:  call com_err_ (code, me, err_msg, bad_arg, msg2, numeric_arg);

	     if argno <= nargs then			/* if not past end of arglist */
		call ioa_$nnl ("Argument number ^d.  ", argno);
	     if nargs > 0 then
		call ioa_ ("^a specification.", io_names (io.sw));


	     if input.debug then do;
		call ioa_ ("arg error number ^d", error_code);
		call ioa_ ("CALLING DB");
		call db;
	     end;

	     if ^fixed_in_db then do;
		normal_termination = ^normal_termination; /* by flipping the switch instead of turning it on,
						   we avoid an infinite loop in the case where cleanup_proc
						   gets an error detaching tape, and if the switch is on,
						   it calls us back again to print an error message */
		call cleanup_proc;			/* detach tapes and free allocated storage */
		goto quit;
	     end;

	     fixed_in_db = "0"b;			/* turn off switch for next time */
	     return;
	end arg_error;

%page;
check_suffix: proc (given_path);

/*

	This  procedure  checks  the  suffix (if any) in the pathname, and
	complains  to  the  user  if the suffix does not match the control
	arguments  which  were specified.  If the suffix is acceptable, it
	is used to provide gcos_card_utility_ with the data type contained
	in the file.

*/

dcl  given_path			char (*)		parm;
dcl  suffix_string			char (32) varying;

     call get_suffix (given_path, suffix_string);
     if   length (suffix_string) ^= 0		/* only if suffix exists */
     then do;
	if io.format = 0			/* If format not given, get it from suffix. */
	then do;

	     if suffix_string = ".ascii" then io.format = ascii;
	     else if suffix_string = ".gcos" then io.format = gcos;
	     else if suffix_string = ".raw"
		then do;
		     io.format = gcos;
		     io.medium = raw;
		     end;
	     else if suffix_string = ".comdk"
		then do;
		     io.format = gcos;
		     io.comdk = "1"b;
		     end;

	     if io.medium = 0 then io.medium = file;	/* If not raw or tape, then file. */

	     end;

	else if verify_suffix
	     then do;		/* check for consistent suffixes within a list */
		if suffix_string = ".ascii"
		then do;
		     if io.format ^= ascii
		     then call path_error (61, given_path); /* inconsistent suffixes */
		     end;
		else if suffix_string = ".gcos"
		     then do;
			if io.format ^= gcos 
			then call path_error (62, given_path); /* inconsistent suffixes */
			end;
		else if suffix_string = ".raw"
		     then do;
			if io.format ^= gcos | io.medium ^= raw
			then call path_error (63, given_path); /* inconsistent suffixes */
			end;
		else if suffix_string = ".comdk"
		     then do;
						/* comdk is not inconsistent with gcos -
						   but if it was not the first suffix given,
						   then the gcos suffix determines the format */
			if io.format ^= gcos
			     then call path_error (64, given_path); /* inconsistent suffixes */
			end;
		end;				/* end of verify suffix do group */
	end;				/* end of suffix-checker */
	return;
     end check_suffix;
%page;
/* Procedure to detach tapes and free allocated storage.
   Called on cleanup condition, and also for normal termination.
   The switch, normal_termination, tells us which it is. */

cleanup_proc: proc;

/* Detach tapes (unless user said -retain) */

	     do io_ptr = input_ptr, output_ptr;
		if io.tape_ptr ^= null then do;	/* there is a tape */
		     if io_tape.retain then do;	/* but user said retain */
			if io_tape.attached then	/* if the tape is really attached */
			     if ^io.brief then	/* and user did not say -brief */
				call com_err_ (0, me, "Tape ^a will remain attached.", io_tape.id);
		     end;				/* end retain */
		     else do;			/* detach it */
			if io_tape.attached then do;	/* only if it is already attached */
			     call ios_$detach (tape_stream (io.sw), "", "", status);
			     if code ^= 0 then do;
				if normal_termination then /* avoid infinite loop */
				     call arg_error (65); /* OUT OF ORDER - ADDED LATER */
			     end;			/* end code ^= 0 */
			end;			/* end attached */
		     end;				/* end ^retain */
		end;				/* end io.tape_ptr ^= null */
	     end;					/* end detach tapes do loop */


/* Free allocated storage */
	     do free_ptr_ptr =
		     addr (input.list_ptr),
		     addr (input.tape_ptr),
		     addr (output.list_ptr),
		     addr (output.tape_ptr);

		if free_ptr ^= null then
		     if baseno (system_free_ptr) = baseno (free_ptr) then /* make sure it is in free area */
			free free_ptr -> word_string; /* can point to any old thing -
						   only the pointer is passed to the free routine */
	     end;

	     if segptr ^= null then do;
		call hcs_$terminate_noname (segptr, code);
		if code ^= 0 then
		     if normal_termination then
			call arg_error (68);	/* OUT OF ORDER- ADDED LATER */
	     end;

	end cleanup_proc;
%page;
/* Procedure to expand pathname */

get_io_pathname: proc (given_path) returns (char (168));

dcl  given_path char (*);
dcl  expanded_path char (168);
dcl  pl fixed bin(21);

	     pl = length (given_path);

	     call expand_path_ (addr (given_path), pl, addr (expanded_path), null, code);
	     if code ^= 0 then
		call path_error (60, given_path);
	     return (expanded_path);

	end get_io_pathname;
%page;
get_suffix: proc (input_string, return_suffix);

/*

      This  procedure  returns  the  suffix  of  an input_string
      (.gcos,  .ascii,  etc.).   If  there  are  more  than  two
      components  in  an input_string, the last one is returned.
      If  there is no suffix, the suffix field is returned null.

*/

dcl   input_string			char(*)		parm;
dcl   return_suffix			char(*) varying	parm;

dcl   work_string			char(168) varying;
dcl   dot_index			fixed bin (24);
dcl   dot				char(1)
				internal static
				options(constant)
				init(".");

     work_string = reverse (rtrim (input_string));
     dot_index = index (work_string, dot);

     if   dot_index ^= 0

     then return_suffix = reverse (substr (work_string, 1, dot_index));

     else return_suffix = "";

     return;

     end get_suffix;

end gcos_card_utility;
