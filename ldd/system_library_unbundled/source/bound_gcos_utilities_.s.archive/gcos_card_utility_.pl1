/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   * Copyright (c) 1972 by Massachusetts Institute of        *
   * Technology and Honeywell Information Systems, Inc.      *
   *                                                         *
   *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(2016-01-15,Swenson), approve(2016-01-15,MCR10003):
     Fix to support 4-character time zone abbreviations.
                                                   END HISTORY COMMENTS */

gcos_card_utility_: proc (a_input_ptr, a_output_ptr, a_code);


/*

   This  subroutine does the work of the gcu (gcos_card_utility)
   command.

   It  is called with pointers to two structures in the argument
   list, one containing all information pertaining to input, the
   other, all information pertaining to output.

   These  structures contain pointers to other structures, which
   contain  information  about  magnetic  tape  I/O, or lists of
   input  or  output items.  These structures are only allocated
   if needed.  Otherwise, the pointers to them are null.

   All  these  structures  are  described  by  the include file:
   gcos_utility_args_.incl.pl1

   Actual   space   for   these   structures   is  allocated  in
   gcos_card_utility.pl1

   This  procedure  is  composed  of  a large number of internal
   procedures,  for  the purpose of making it easily extensible,
   and  to  allow  the  flow of control to be easily followed by
   readers   of  the  code.   The  procedures  are  arranged  in
   alphabetic order by name, following the main procedure.
*/
%page;
/*
   WRITTEN  BY T. CASEY MAY 1973
   MODIFIED BY T. CASEY SEPTEMBER 1973
   *		    OCTOBER 1973
   *		    MARCH 1974
   *		    AUGUST 1974
   *		    DECEMBER 1974
   *		    JULY 1975
   *		    MARCH 1976
   *		    JANUARY 1977
   *
   MODIFIED BY D. WARD  APRIL 1981:
   *				Changed to octal bit constants. 
   *				Changed \014 to %page;
   *
   MODIFIED BY S. AKERS AUGUST 1981:
   *			       	Fixed problem of writing zero-length
   *				BCWs to tapes when prior input block
   *				is exactly 320 words.
   *
   *				Added conversion from gcos_ascii to
   *    				gcos_bcd.
   *
   *				Cleaned up format of program, putting
   *				more stuff into internal procedures.
   *
   *				Fixed bug which caused an EOF RCW to
   *				be written to a tape.
   *
   *				Changed Multics ASCII output to
   *				omit trailing blanks.
   *
   *				Fixed bug in converting GCOS ASCII
   *				to GCOS BCD.
   *
   * Modified: Ron Barstad  2.1 83-06-09  Allowed conversion to ascii or gcos_ascii
   *                                      from BCD media code 0 to be over 80 chars
   * Modified: Ron Barstad  2.2 83-07-13  Read and believe "char position" field of rcw of gcos records.
   */
%page;
/*	D  E  C  L  A  R  A  T  I  O  N  S  	*/


/*	Arguments		*/

dcl  a_code                   fixed bin(35) parm;
dcl  a_input_ptr              ptr parm;
dcl  a_output_ptr             ptr parm;

/*	Argument Structures		*/

%include gcos_utility_args_;



/*	Error Table Entries		*/

dcl  error_table_$action_not_performed ext fixed bin(35);


/*	External Static	*/

dcl (gcos_control_tables_$activity_table,
     gcos_control_tables_$cardtable (8) char (8),
     gcos_control_tables_$exc_offset fixed bin(17),
     gcos_control_tables_$nonact fixed bin(24),
     gcos_control_tables_$tablelen fixed bin(17),
     gcos_control_tables_$tabstops) external static;


/*	External Entries		*/

dcl (
     clock_ entry returns (fixed bin(71)),
     com_err_ entry options (variable),
     command_query_ entry options (variable),
     db entry,
     decode_clock_value_ entry (fixed bin(71), fixed bin(24), fixed bin(24), fixed bin(24), fixed bin(71), fixed bin(24), char (4) aligned),
     decode_nstd_status_ entry (bit (72) aligned, char (*) varying),
     gcos_cv_ascii_gebcd_check_ entry (ptr, fixed bin(24), ptr, fixed bin(35)),
     gcos_cv_gebcd_ascii_ entry (ptr, fixed bin(24), ptr),
     ioa_ entry options (variable),

     ios_$attach entry (char (*) aligned, char (*) aligned, char (*) aligned, char (*) aligned, bit (72) aligned),
     ios_$detach entry (char (*) aligned, char (*) aligned, char (*) aligned, bit (72) aligned),
     ios_$order entry (char (*) aligned, char (*) aligned, ptr, bit (72) aligned),
     ios_$read entry (char (*) aligned, ptr, fixed bin(24), fixed bin(24), fixed bin(24), bit (72) aligned),
     ios_$seek entry (char (*) aligned, char (*) aligned, char (*) aligned, fixed bin(24), bit (72) aligned),
     ios_$setdelim entry (char (*) aligned, fixed bin(24), bit (9), fixed bin(24), bit (9), bit (72) aligned),
     ios_$setsize entry (char (*) aligned, fixed bin(24), bit (72) aligned),
     ios_$tell entry (char (*) aligned, char (*) aligned, char (*) aligned, fixed bin(24), bit (72) aligned),
     ios_$write entry (char (*) aligned, ptr, fixed bin(24), fixed bin(24), fixed bin(24), bit (72) aligned),
     system_info_$installation_id entry (char (*))
     ) external;

dcl (addr, addrel, before, bin, bit, divide, fixed, hbound, index, length, max, min, mod,
     null, reverse, rtrim, string, substr, unspec, verify) builtin;

dcl  cleanup                  condition;



/*	Work areas and overlays for them		*/


dcl  ascii_block              char (input_block_len) based (input_block_ptr);
dcl  input_block              (320) bit (36) aligned	/* PLACE FOR ios_$read TO PUT THE DATA */;
dcl  input_block_len          fixed bin(24);
dcl  input_block_ptr          ptr;

dcl 1 bcw aligned based,

      2 bsn bit (18) unaligned,
      2 length bit (18) unaligned;

dcl 1 bcw_word based (input_block_ptr) aligned,

      2 bcw_num fixed bin (18) unsigned unaligned,
      2 bcw_len fixed bin (18) unsigned unaligned;

dcl  ascii_card               char (ascii_line_len) aligned based (addr (ascii_line));
dcl  ascii_line               char (1280) aligned	/* PLACE TO PUT ASCII LINE TRANSLATED FROM BCD */;

dcl  ascii_line_ptr           ptr;
dcl  ascii_line_len           fixed bin(24)init (80);	/* a variable, in case we ever want to
						   create variable length output lines */

dcl  gcos_work_area           (320) bit (36) aligned;	/* PLACE TO PUT GCOS RECORD,
						   TRANSLATED FROM ASCII OR RAW INPUT */
dcl  gcos_work_area_ptr       ptr;

dcl 1 bcd_card aligned based (bcd_work_area_ptr),
    2 rcw bit (36) unaligned,
    2 column (84) bit (6) unaligned;

dcl 1 bin_card aligned based,
    2 rcw bit (36) unaligned,
    2 column (80) bit (12) unaligned;

dcl  comdk_card_ptr           ptr;
dcl 1 comdk_card aligned based (comdk_card_ptr),		/* for decoding input comdk cards */
    2 rcw bit (36) unaligned,
    2 col1 bit (12) unaligned,			/* col 1 */
    2 seq_no bit (24) unaligned,			/* cols 2, 3 */
    2 checksum bit (36) unaligned,			/* cols 4-6 */
    2 char (132) bit (6) unaligned,			/* cols 7-72 */
    2 seq_col (8) bit (12) unaligned;						/* col 73-80 */

dcl 1 k_card like comdk_card aligned based (comdk_work_area_ptr)	/* for encoding output comdk cards */;

dcl  bit_string               bit (bit_string_len) unaligned based	/* overlay for moving bcd chars */;
dcl  bit_string_len           fixed bin(24);

dcl  char_string              char (char_string_len) unaligned based	/* overlay for moving ASCII chars */;
dcl  char_string_len          fixed bin(24);

dcl  word_string              (word_string_len) bit (36) aligned based	/* overlay for moving words */;
dcl  word_string_len          fixed bin(24);

dcl  bcd_work_area            (15) bit (36) aligned	/* PLACE TO BUILD BCD RECORD FROM COMDK CARDS */;
dcl  bcd_work_area_ptr        ptr;

dcl  gcos_record_len          fixed bin(24);
dcl  gcos_record_ptr          ptr;
dcl 1 gcos_record aligned based (gcos_record_ptr),	/* overlay for wherever a gcos record is - in input_block,
						   in gcos_work_area, or in bcd_work_area */
    2 rcw bit (36) aligned,
    2 data_words (gcos_record_len) bit (36) aligned;

dcl 1 rcw aligned based,
    2 length bit (18) unaligned,
    2 char_pos bin (2) unsigned unaligned,
    2 eof bit (4) unaligned,
    2 zeroes bit (2) unaligned,
    2 media_code bit (4) unaligned,
    2 report_code bit (6) unaligned;

dcl  raw_card                 (80) bit (12) unaligned	/* PLACE TO BUILD RAW OUTPUT CARD TRANSLATED FROM BCD */;
dcl  raw_card_ptr             ptr;

dcl  comdk_work_area          (28) bit (36) aligned	/* PLACE TO BUILD OUTPUT COMDK CARDS */;
dcl  comdk_work_area_ptr      ptr;

dcl  write_buffer             (320) bit (36) aligned	/* PLACE TO ACCUMULATE OUTPUT RECORDS FOR ios_$write */;
dcl  write_buffer_ptr         ptr;

dcl  act_ptr                  ptr	/* to look up tabstops for an activity */;
dcl 1 act_table_entry aligned based (act_ptr),		/* overlay for table entry for one activity */
    2 fill1 fixed bin(24),
    2 fill2 char (4),
    2 tab_index fixed bin(24);	/* position in tabstops table of settings for this activity */

dcl  tabstop_ptr              ptr	/* pointer to external static tabstop table */;
dcl 1 tabstops aligned based (tabstop_ptr),
    2 count fixed bin(24)aligned,			/* number of sets of tabstops */
    2 tab (0:tabstops.count - 1),
      3 stop (10) fixed bin(24)aligned;			/* each set is 10 or fewer stops */



/* Tape label structures */

dcl 1 header_label aligned based (label_ptr),
    2 btl bit (72) aligned,				/* GE/b/b600/bBTL/b */
    2 installation bit (36) aligned,
    2 reel_ser_no bit (36) aligned,			/* /bxxxxx */
    2 file_ser_no bit (36) aligned,			/* must = reel_ser_no, for single-reel files */
    2 reel_seq_no bit (36) aligned,			/* /b/bxxxx - xxxx=1 for single-reel files */
    2 creation_date bit (36) aligned,			/* /byyddd */
    2 retention_days bit (36) aligned,			/* /b/b/bxxx */
    2 file_name bit (72) aligned,
    2 unused (3) bit (36) aligned,
    2 prverr bit (36) aligned;						/* /b/b/b/b/b/b */

dcl 1 saved_header_label like header_label aligned automatic;

dcl 1 partial_label aligned based (label_ptr),
    2 btl bit (72) aligned,
    2 installation bit (36) aligned,
    2 reel_ser_no bit (36) aligned,
    2 zero_words (6) bit (36) aligned,			/* must be zero, for partial label */
    2 unused (4) bit (36) aligned;

dcl 1 trailer_label aligned based (label_ptr),
    2 eof bit (36) aligned,				/* /bEOF/b/b or /bEOR/b/b */
    2 block_count bit (36) aligned,
    2 unused (11) bit (36) aligned,
    2 next_reel bit (36) aligned;						/* /b/b/b/b/b/b */

/*	Switches		*/

dcl (
     appending_to_output,
     eof,
     eoj,
     file_eob,
     file_eof,
     found_last_line,
     input_comdk_open,
     just_looking,
     looking_for_first_line,
     looking_for_last_line,
     no_end_card,
     output_comdk_open,
     rcw_eof
     ) bit (1) aligned init ("0"b);

dcl  no_label                 (2) bit (1) aligned init ((2) (1)"0"b);


/*	Error Handling Variables		*/

dcl  code                     fixed bin(35) based (addr (status));
dcl  status                   bit (72) aligned;


/*	Fixed Bin		*/

dcl  tod                      fixed bin(71);

dcl (
     bcd_col_index,
     bin_cards_skipped,
     block_serial_number,
     comdk_char_index,
     comdk_error_count,
     comdk_out_index,
     dom,
     dow,
     element_size,
     elements_wanted,
     elements_written,
     err_num,
     field_len,
     file_record_count,
     first_key,
     i,
     input_block_count,
     input_record_count,
     item_index,
     item_length,
     j,
     k,
     last_key,
     list_index,
     month,
     next_input_index,
     next_output_index,
     nondollar_tab_index,
     offset,
     output_block_count,
     output_block_len,
     output_record_count,
     path_len,
     prev_comdk_seq_no,
     raw_cards_bad,
     raw_chars_bad,
     remaining_block_len,
     remaining_output_words,
     string_len,
     year
     ) fixed bin(24)init (0);

dcl  chase                    fixed bin(1) init (1);
dcl  seq_col                  (5:8) fixed bin(24)/* numeric values of punches in cols 77-80 */;


/*	Pointers - Additional pointers are declared adjacent to the variables whose addresses they are initialized to */

dcl (
     label_ptr,
     output_word_ptr,
     saved_record_ptr)
     ptr;


/*	Strings		*/

/*	ASCII strings */

dcl  punches                  char (36) varying;

dcl  punch                    (12) char (3) int static init ("-12", "-11", "-0", "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9");


dcl  inst                     char (32);
dcl  me                       char (20) int static init ("gcos_card_utility_");
dcl  tape_status_message      char (50) varying;
dcl (input_stream_name, output_stream_name) char (32) aligned;

dcl  ascii_search_key         (15) char (15) aligned int static init (
     "$      snumb   ",
     "$      gmap    ",
     "$      355map  ",
     "$      object  ",
     "$      forty   ",
     "$      fortran ",
     "$      ids     ",
     "$      pl1     ",
     "$      cobol   ",
     "$      asm66   ",
     "$      cbl74   ",
     "$      cbl68   ",
     "$      malt    ",
     "$      ilang   ",
     "$      ids2    ");

dcl  answer                   char (8) varying init ("");
dcl  card_type                char (8) aligned;
dcl  edit_name                char (8);
dcl  item_name                char (8) aligned	/* edit name or snumb */;
dcl  next_output_suffix       char (6) aligned;
dcl  zone                     char (4) aligned;
dcl  ascii_newline            char (1) int static init ("
");
dcl  ascii_backspace          char (1) int static init ("");
dcl  ascii_pads               char (4) int static init ("")	/* four octal 177's */;
dcl  ascii_tab                char (1) int static init ("	");

/*	BCD and binary strings */

dcl  bcd_blank_card           (14) bit (36) aligned int static init
    ((13) (6) "010000"b, "010000010000"b);	/* we HOPE this puts blanks in 80 6-bit chars,
					   and fills the rest of the last word with zeros */

dcl  bcd_btl                  bit(72)static int options(constant) init("272520200600002022634320"b3) /* GEbb600bBTLb (BCD). */;

dcl  bcd_beofbb               bit(36)static int options(constant)init("202546262020"b3) /* bEOFbb (BCD). */;

dcl  bcd_beorbb               bit(36)static int options(constant)init("202546512020"b3) /* bEORbb (BCD). */;

dcl  bcd_b1                   bit(36)static int options(constant)init("200000000000"b3) /* b00000 (BCD). */;

dcl  bcd_b2                   bit(36)static int options(constant)init("202000000000"b3) /* bb0000 (BCD). */;

dcl  bcd_b3                   bit(36)static int options(constant)init("202020000000"b3) /* bbb000 (BCD). */;

dcl  bcd_b6                   bit(36)static init options(constant)init((6)"20"b3) /* 6 blanks (BCD). */;

dcl  ascii_header_rcw         bit(36) static int options(constant) init("000024001000"b3);
						/* rec len = 20; media code = 8 */

dcl  bcd_rcw                  bit(36)static int options(constant)init("000016000200"b3);
						/* rec len = 14; media code = 0010 (bcd card) */

dcl  bin_rcw                  bit(36)static int options(constant)init( "000033000100"b3);
						/* rec len = 27; media code = 0001 (binary card) */

dcl  eof_rcw                  bit(36)static int options(constant)init( "000000170000"b3);
						/* rec len = 0; eof = bcd_eof; media code,report code = 0 */
dcl  bcd_endjob               bit(36)static int options(constant)init( "254524414622"b3) /* ENDJOB (BCD). */;
dcl  gcd_star_eof             bit(36)static int options(constant)init( "545454254626"b3) /* ***EOF (BCD). */;
dcl  bcd_search_key           (15)bit(36)static int options(constant)init(
 "624564442220"b3	/* SNUMBb (BCD). */
,"274421472020"b3	/* GMAPbb (BCD). */
,"030505442147"b3	/* 355MAP (BCD). */
,"462241252363"b3	/* OBJECT (BCD). */
,"264651637020"b3	/* FORTYb (BCD). */
,"264651635121"b3	/* FORTRA (BCD). */
,"312462202020"b3	/* IDSbbb (BCD). */
,"474301202020"b3	/* PL1bbb (BCD). */
,"234622464320"b3	/* COBOLb (BCD). */
,"216244060620"b3	/* ASM66b (BCD). */
,"232243070420"b3	/* CBL74b (BCD). */
,"232243061020"b3	/* CBL68b (BCD). */
,"442143632020"b3	/* MALTbb (BCD). */
,"314321452720"b3	/* ILANGb (BCD). */
,"312462022020"b3	/* IDS2bb (BCD). */
);

dcl  bcd_dkend                bit(36)static int options(constant)init( "244225452420"b3) /* DKENDb (BCD). */;

dcl  bcd_edit_name            (8) bit (6) unaligned;

dcl  comdk_col_1              bit(12)static int options(constant)init("5005"b3);

dcl  ascii_header_media_code  bit (4) unaligned int static init ("1000"b) /* media code 8 - header for gcos TSS ascii file */;
dcl  ascii_media_code         bit (4) unal int static init ("0110"b)	/* media code 6 - ASCII  */;
dcl  bcd_blank                bit(6)static int options(constant)init("20"b3) /* blank (BCD). */;
dcl  bcd_dollar               bit(6)static int options(constant)init( "53"b3) /* $ (BCD). */;
dcl  bcd_eof                  bit(4)static int options(constant)init("1111"b);
dcl  bcd_media_code           bit (4) unaligned int static init ("0010"b)	/* media code 2 - BCD card */;
dcl  plain_bcd_media_code     bit (4) unal int static init ("0000"b) /* media code 0 - BCD variable length record */;


dcl  pten                     (0:5) int static fixed bin(24)init (1, 10, 100, 1000, 10000, 100000);




/* TRANSLATION TABLES FOR CONVERSION FROM-TO RAW CARD IMAGES */


/* BCD characters, in same order as their corresponding card punch codes in bin_table, below */

dcl  bcd_table                (0:63) bit (6) aligned internal static init (
     "010000"b,					/* " " */
     "001001"b,					/* "9" */
     "001000"b,					/* "8" */
     "000111"b,					/* "7" */
     "001111"b,					/* "?" */
     "000110"b,					/* "6" */
     "001110"b,					/* ">" */
     "000101"b,					/* "5" */
     "001101"b,					/* ":" */
     "000100"b,					/* "4" */
     "001100"b,					/* "@" */
     "000011"b,					/* "3" */
     "001011"b,					/* "#" */
     "000010"b,					/* "2" */
     "001010"b,					/* "[" */
     "000001"b,					/* "1" */
     "000000"b,					/* "0" */
     "111001"b,					/* "z" */
     "111000"b,					/* "y" */
     "110111"b,					/* "x" */
     "111111"b,					/* "!" */
     "110110"b,					/* "w" */
     "111110"b,					/* """ */
     "110101"b,					/* "v" */
     "111101"b,					/* "=" */
     "110100"b,					/* "u" */
     "111100"b,					/* "%" */
     "110011"b,					/* "t" */
     "111011"b,					/* "," */
     "110010"b,					/* "s" */
     "111010"b,					/* "<-" */
     "110001"b,					/* "/" */
     "101010"b,					/* "-" */
     "101001"b,					/* "r" */
     "101000"b,					/* "q" */
     "100111"b,					/* "p" */
     "101111"b,					/* "'" */
     "100110"b,					/* "o" */
     "101110"b,					/* ";" */
     "100101"b,					/* "n" */
     "101101"b,					/* ")" */
     "100100"b,					/* "m" */
     "101100"b,					/* "*" */
     "100011"b,					/* "l" */
     "101011"b,					/* "$" */
     "100010"b,					/* "k" */
     "100001"b,					/* "j" */
     "100000"b,					/* "|" */
     "011010"b,					/* "&" */
     "011001"b,					/* "i" */
     "011000"b,					/* "h" */
     "010111"b,					/* "g" */
     "011111"b,					/* "\" */
     "010110"b,					/* "f" */
     "011110"b,					/* "<" */
     "010101"b,					/* "e" */
     "011101"b,					/* "(" */
     "010100"b,					/* "d" */
     "011100"b,					/* "]" */
     "010011"b,					/* "c" */
     "011011"b,					/* "." */
     "010010"b,					/* "b" */
     "010001"b,					/* "a" */
     "110000"b					/* "+" */
     );

/* card punch codes for the GEBCD characters, arranged in ascending order of their
   numeric values, to allow lookup of INPUT raw card column contents, using a
   half-interval (binary) search */

dcl  bin_table                (0: 63) bit (12) aligned internal static init (
     "000000000000"b,				/* " " */
     "000000000001"b,				/* "9" */
     "000000000010"b,				/* "8" */
     "000000000100"b,				/* "7" */
     "000000000110"b,				/* "?" */
     "000000001000"b,				/* "6" */
     "000000001010"b,				/* ">" */
     "000000010000"b,				/* "5" */
     "000000010010"b,				/* ":" */
     "000000100000"b,				/* "4" */
     "000000100010"b,				/* "@" */
     "000001000000"b,				/* "3" */
     "000001000010"b,				/* "#" */
     "000010000000"b,				/* "2" */
     "000010000010"b,				/* "[" */
     "000100000000"b,				/* "1" */
     "001000000000"b,				/* "0" */
     "001000000001"b,				/* "z" */
     "001000000010"b,				/* "y" */
     "001000000100"b,				/* "x" */
     "001000000110"b,				/* "!" */
     "001000001000"b,				/* "w" */
     "001000001010"b,				/* """ */
     "001000010000"b,				/* "v" */
     "001000010010"b,				/* "=" */
     "001000100000"b,				/* "u" */
     "001000100010"b,				/* "%" */
     "001001000000"b,				/* "t" */
     "001001000010"b,				/* "," */
     "001010000000"b,				/* "s" */
     "001010000010"b,				/* "<-" */
     "001100000000"b,				/* "/" */
     "010000000000"b,				/* "-" */
     "010000000001"b,				/* "r" */
     "010000000010"b,				/* "q" */
     "010000000100"b,				/* "p" */
     "010000000110"b,				/* "'" */
     "010000001000"b,				/* "o" */
     "010000001010"b,				/* ";" */
     "010000010000"b,				/* "n" */
     "010000010010"b,				/* ")" */
     "010000100000"b,				/* "m" */
     "010000100010"b,				/* "*" */
     "010001000000"b,				/* "l" */
     "010001000010"b,				/* "$" */
     "010010000000"b,				/* "k" */
     "010100000000"b,				/* "j" */
     "011000000000"b,				/* "|" */
     "100000000000"b,				/* "&" */
     "100000000001"b,				/* "i" */
     "100000000010"b,				/* "h" */
     "100000000100"b,				/* "g" */
     "100000000110"b,				/* "\" */
     "100000001000"b,				/* "f" */
     "100000001010"b,				/* "<" */
     "100000010000"b,				/* "e" */
     "100000010010"b,				/* "(" */
     "100000100000"b,				/* "d" */
     "100000100010"b,				/* "]" */
     "100001000000"b,				/* "c" */
     "100001000010"b,				/* "." */
     "100010000000"b,				/* "b" */
     "100100000000"b,				/* "a" */
     "101000000000"b				/* "+" */
     );

/* card punch codes for the GEBCD characters, arranged in order of the numeric
   values of their corresponding 6-bit BCD codes, to allow OUTPUT raw card column
   contents to be obtained using the BCD character as an index into the table */

dcl  raw_table                (0:63) bit (12) aligned int static init (
     "001000000000"b,				/* 0 */
     "000100000000"b,				/* 1 */
     "000010000000"b,				/* 2 */
     "000001000000"b,				/* 3 */
     "000000100000"b,				/* 4 */
     "000000010000"b,				/* 5 */
     "000000001000"b,				/* 6 */
     "000000000100"b,				/* 7 */
     "000000000010"b,				/* 8 */
     "000000000001"b,				/* 9 */
     "000010000010"b,				/* [ */
     "000001000010"b,				/* # */
     "000000100010"b,				/* @ */
     "000000010010"b,				/* : */
     "000000001010"b,				/* > */
     "000000000110"b,				/* ? */
     "000000000000"b,				/* blank */
     "100100000000"b,				/* A */
     "100010000000"b,				/* B */
     "100001000000"b,				/* C */
     "100000100000"b,				/* D */
     "100000010000"b,				/* E */
     "100000001000"b,				/* F */
     "100000000100"b,				/* G */
     "100000000010"b,				/* H */
     "100000000001"b,				/* I */
     "100000000000"b,				/* & */
     "100001000010"b,				/* . */
     "100000100010"b,				/* ] */
     "100000010010"b,				/* ( */
     "100000001010"b,				/* < */
     "100000000110"b,				/* \ */
     "011000000000"b,				/* | */
     "010100000000"b,				/* J */
     "010010000000"b,				/* K */
     "010001000000"b,				/* L */
     "010000100000"b,				/* M */
     "010000010000"b,				/* N */
     "010000001000"b,				/* O */
     "010000000100"b,				/* P */
     "010000000010"b,				/* Q */
     "010000000001"b,				/* R */
     "010000000000"b,				/* - */
     "010001000010"b,				/* $ */
     "010000100010"b,				/* * */
     "010000010010"b,				/* ) */
     "010000001010"b,				/* ; */
     "010000000110"b,				/* ' */
     "101000000000"b,				/* + */
     "001100000000"b,				/* / */
     "001010000000"b,				/* S */
     "001001000000"b,				/* T */
     "001000100000"b,				/* U */
     "001000010000"b,				/* V */
     "001000001000"b,				/* W */
     "001000000100"b,				/* X */
     "001000000010"b,				/* Y */
     "001000000001"b,				/* Z */
     "001010000010"b,				/* <- (left arrow) */
     "001001000010"b,				/* , */
     "001000100010"b,				/* % */
     "001000010010"b,				/* = */
     "001000001010"b,				/* " */
     "001000000110"b				/* ! */
     );






%include query_info;

%include gcos_xlate_bcd_ascii_;
%page;
/*	P  R  O  C  E  D  U  R  E   	*/

/* Initialization */

	input_ptr = a_input_ptr;			/* copy argument structure pointers to */
	output_ptr = a_output_ptr;			/* local storage, for better accessing code */
	nondollar_tab_index = -1;			/* initialize to "no value assigned" code */
	query_info.yes_or_no_sw = "1"b;		/* we ask only yes or no questions */

	on condition (cleanup) call cleanup_proc;

	unspec (write_buffer) = ""b;			/* zero the output buffer,
						   to avoid garbage at the ends of short records */
	if output.name_files
	then do;			/* set suffix for output file names */
	     if output.format = ascii then
		next_output_suffix = ".ascii";
	     else if output.medium = raw then
		next_output_suffix = ".raw";
	     else if output.comdk then
		next_output_suffix = ".comdk";
	     else next_output_suffix = ".gcos";
	     end;

	do io_ptr = input_ptr, output_ptr;
	     if io.medium = tape then
		if io_tape.label = "-nl"
		 | io_tape.label = "-no_label"
		 | io_tape.label = "-no_labels"
		then no_label (io.sw) = "1"b;
	end;

	input_block_ptr = addr (input_block);		/* get pointers to work areas */
	ascii_line_ptr = addr (ascii_line);
	gcos_work_area_ptr = addr (gcos_work_area);
	bcd_work_area_ptr = addr (bcd_work_area);
	raw_card_ptr = addr (raw_card);
	comdk_work_area_ptr = addr (comdk_work_area);
	write_buffer_ptr = addr (write_buffer);

/* do not get ptr to ext static tabstop table now. wait to see if it is needed.
   do it in open_input. */


  /*          Processing (What there is of it...)          */

	if input.set = single_file
	   then call process_single_file;
     else if input.set = imcv
	   then call process_imcv;
     else if input.set = library
	   then call process_library_file;
     else if input.set = multiple_files
	   then call process_multiple_files;
     else call fatal_error (1);		/* error_table_$badcall */

        /* Just return normally, no fuss, no bother. */

	a_code = code;
	return;

  /* Whoops! Something went bust, so gotta clean up first. */

cleanup_and_return:
	call cleanup_proc;
	a_code = code;
	return;

/*	 END OF MAIN PROCEDURE. INTERNAL PROCEDURES AND DEBUGGING ENTRIES FOLLOW */
%page;
bcd_string: proc (in_string, in_count) returns (bit (*) aligned);

dcl  in_string                char (*);
dcl  ret_bits                 bit (ret_len) aligned based (addr (work_bits));
dcl  work_bits                bit (72) aligned;
dcl  work_chars               char (12) aligned;
dcl (digit, i, in_count, in_no, indx, num, ret_len, xnum) fixed bin(24);

	     work_chars = in_string;			/* align the input string */
	     call gcos_cv_ascii_gebcd_check_ (addr (work_chars), in_count, addr (work_bits), code);
	     if code ^= 0 then do;
		call ioa_ ("Error in character ^d of : ~a", code, in_string);
		code = 0;				/* code is position of bad char - not error table code */
		call fatal_error (2);		/* bad string - can't convert to BCD */
	     end;

return_string:					/* come here from bcd_string_bin entry point */
	     ret_len = in_count*6;			/* compute length in bits of the BCD string */
	     return (ret_bits);

bcd_string_bin: entry (in_no, in_count) returns (bit (*) aligned);

	     indx = 1;
	     num = in_no;

	     do i = in_count-1 by -1 to 0;		/* convert digits left to right */
		xnum = mod (num, pten (i));		/* get digits to right of the one we want */
						/* pten(i) contains 10**i */
		digit = divide (num-xnum, pten (i), 17, 0); /* get digit we want */
		if indx = 1 then			/* if first time around loop */
		     if digit > 9 then		/* check for number too large for field */
			call fatal_error (3);	/* number to large for BCD field */
		substr (work_bits, indx, 6) = bit (fixed (digit, 6)); /* make BCD char from digit */
		indx = indx + 6;			/* move to next digit in receiving field */
		num = xnum;			/* work with digits to right of one just converted */
	     end;

	     goto return_string;			/* go return the string when done converting */

end bcd_string;
%page;
canonicalizer: proc (input_string_ptr, initial_input_characters,
		output_card_ptr, initial_output_columns);

/* NOTE: a copy of this internal procedure exists also in gcos_gein_pass1_.
   The initialization is different, but the canonicalization is the same.
   Any changes should be made to both copies, if appropriate. */

dcl  initial_input_characters fixed bin(24);
dcl  input_string             char (initial_input_characters) based (input_string_ptr);
dcl  input_string_ptr         ptr;

dcl  initial_output_columns   fixed bin(24);
dcl  output_card              char (initial_output_columns) based (output_card_ptr);
dcl  output_card_ptr          ptr;

dcl (
     next_input_character,
     next_output_column,
     next_backspace,				/* relative to next_input_character */
     next_tab,					/* relative to next_input_character */
     remaining_input_characters,
     remaining_output_columns,
     character_count,
     blank_count,
     first_blank,
     i,
     backspace_count
     ) fixed bin(24);

dcl (more_backspaces,
     more_tabs) bit (1) aligned;

dcl  tabstop                  (10) fixed bin(24)based (tab_ptr)	/* tabstops currently in use */;
dcl  tab_ptr                  ptr	/* pointer to tabs currently in use */;



/*     INITIALIZE        */

	     next_input_character, next_output_column = 1;
	     remaining_input_characters = initial_input_characters;
	     remaining_output_columns = initial_output_columns;

	     more_backspaces, more_tabs = "1"b;		/* we want to look for backspaces and tabs at the start */

	     if substr (input_string, remaining_input_characters, 1) = ascii_newline /* if last char is a newline */
	     then remaining_input_characters = remaining_input_characters - 1; /* then get rid of it */


	     if substr (input_string, 1, 1) = "$" then
set_dollar_tabs:	do;

		tab_ptr = addr (tab (0));		/* get pointer to dollar tabs */

		end set_dollar_tabs;

	     else					/* not a dollar card */
set_nondollar_tabs: do;

		if input.tabs_given then		/* if user supplied nondollar tabstops */
		     tab_ptr = addr (input.tabstops);	/* get pointer to user-supplied tabstops */

		else do;				/* otherwise use the ones we looked up */
		     if nondollar_tab_index = -1 then call fatal_error (4); /* check for case of:
						   1) not a complete job,
						   so no activity card to determine tabs from, and
						   2) no tabs given by user, resulting in no tabstops to use */

		     else tab_ptr = addr (tab (nondollar_tab_index)); /* get pointer to tabs for this activity */
		end;

		end set_nondollar_tabs;


/*     MAIN LOOP. FILL UP OUTPUT CARD */

canon_loop:    do while (remaining_output_columns > 0);	/* keep going while there is any room on output card */

		if more_backspaces then		/* if there MIGHT be more backspaces */
find_next_backspace:     do;				/* then look for one */

		     next_backspace = index (substr (input_string, next_input_character,
			remaining_input_characters), ascii_backspace);
		     if next_backspace = 0 then more_backspaces = "0"b; /* if none found, remember not to look again */

		     end find_next_backspace;

		if more_tabs then			/* if there MIGHT be more tabs */
find_next_tab:	     do;				/* then look for one */
		     next_tab = index (substr (input_string, next_input_character,
			remaining_input_characters), ascii_tab);
		     if next_tab = 0 then more_tabs = "0"b; /* if none found, remember not to look again */
		     end find_next_tab;

		if more_backspaces then		/* if we found a backspace */
look_at_backspace:	     do;				/* see if it is in a legal position */
						/* maybe sometime allow backspaces to be in places other than
						   immediately following tabs, but for now, it's an error */

		     if ^more_tabs | next_backspace ^= next_tab+1 then call fatal_error (5);

		     end look_at_backspace;

		if more_tabs then			/* if we found a tab, we want to move the characters before it */
process_tab:	     do;				/* to the output card, and fill with blanks to next tab stop */

		     character_count = min (		/* compute the number of characters */
			next_tab - 1,		/* before the tab */
			remaining_output_columns);	/* but not more than there's room for on output card */

		     first_blank = next_output_column + character_count;

		     do i = 1 to hbound (tabstop, 1)	/* look for a tabstop */
			     while (tabstop (i) <= first_blank); /* that's past the characters */
						/* if it's in the column immediately after the characters,
						   then go to the next one, the way a typewriter will */
		     end;

		     if i <= hbound (tabstop, 1) then	/* if we found one */

			blank_count = min (		/* compute the number of blanks */
			tabstop (i) - first_blank,	/* needed to get there */
			remaining_output_columns);	/* but not more than there's room for on output card */

		     else				/* if no more tabstops, replace tab with one blank */
		     blank_count = min (1, remaining_output_columns);


		     end process_tab;

		else
no_more_tabs:	do;				/* if there are no more tabs,
						   we want to move the rest of the input characters
						   to the output card, and fill the rest of it with blanks */

		     character_count = min (		/* compute rest of characters to move */
			remaining_input_characters,	/* all the rest, since no more tabs */
			remaining_output_columns);	/* but not more than there's room for on output card */

		     blank_count = max (0,		/* compute blanks needed to fill rest of card */
			remaining_output_columns - remaining_input_characters);

		     end no_more_tabs;

		if character_count > 0 then		/* move characters to output card, if there are any */
move_characters:	     do;
		     substr (output_card, next_output_column, character_count) =
			substr (input_string, next_input_character, character_count);

		     remaining_input_characters = remaining_input_characters - character_count;

		     next_input_character = next_input_character + character_count;

		     remaining_output_columns = remaining_output_columns - character_count;

		     next_output_column = next_output_column + character_count;

		     end move_characters;

		if blank_count > 0 then		/* fill with blanks, if any */
move_blanks:	     do;

		     substr (output_card, next_output_column, blank_count) = "";

		     remaining_output_columns = remaining_output_columns - blank_count;

		     next_output_column = next_output_column + blank_count;

		     end move_blanks;



		if more_tabs then do;		/* move past tab in input string */
		     remaining_input_characters = remaining_input_characters - 1;
		     next_input_character = next_input_character + 1;
		end;




		if more_backspaces then
backspace:	     do;				/* if we found a backspace, we will:
						   1) see if there's more than one of them, and
						   2) move back that many columns, deleting whatever is there,
						   (probably only blanks ) */

		     do i = next_input_character to initial_input_characters
			     while (substr (input_string, i, 1) = ascii_backspace);
		     end;

		     character_count = i - next_input_character; /* count backspace characters */

		     backspace_count = min (character_count, /* count columns to backspace */
			next_output_column - 1);	/* but don't backspace past beginning of card */


/* skip over input backspace characters */
		     remaining_input_characters = remaining_input_characters - character_count;

		     next_input_character = next_input_character + character_count;

/* backspace on output card */
		     remaining_output_columns = remaining_output_columns + backspace_count;

		     next_output_column = next_output_column - backspace_count;

		     end backspace;

		     end canon_loop;

/*     WE FALL THRU HERE WHEN remaining_output_columns BECOMES ZERO */


	     if remaining_input_characters > 0 then	/* if input left over */
		if ^input.truncate_ascii then		/* and user did not say -truncate */
		     call fatal_error (6);		/* complain */


	     if ^input.tabs_given then		/* if user did not supply the nondollar tab stops */
		if substr (output_card, 1, 1) = "$" then
look_up_tabstops:	     do;				/* we will determine them from the type of activity */

		     card_type = substr (output_card, 8, 8); /* get card type */

		     do i = 1 to gcos_control_tables_$tablelen /* look it up in cardtable */
			     while (card_type ^= gcos_control_tables_$cardtable (i));
		     end;				/* fall thru if found, or end of table */
						/* don't really care which */
		     if i >= gcos_control_tables_$exc_offset then /* if its not before the first activity card */
			if i < gcos_control_tables_$nonact then /* and not after the last one */
act_card:			     do;			/* then it must be one */

			     act_ptr = addr (gcos_control_tables_$activity_table); /* pointer to data table */
			     act_ptr = addrel (act_ptr, (i - gcos_control_tables_$exc_offset)*3);
						/* pointer to data for this activity */
			     nondollar_tab_index = act_table_entry.tab_index; /* index to tabs for this activity */
			     end act_card;
			     end look_up_tabstops;


	     return;

end canonicalizer;
%page;
check_bin_cards: proc;

	     if bin_cards_skipped > 0 then do;
		call ioa_ ("^a: ^d non-bcd-card records skipped just before:^/^a", me,
		     bin_cards_skipped, ascii_card);
		bin_cards_skipped = 0;
	     end;

	     return;

end check_bin_cards;
%page;
check_for_eod: proc returns (bit (1));			/* check for end of library deck */

dcl  i                        fixed bin(24);

	     if eof then goto eod;


	     if output.format = ascii | output.gcos_ascii then do;
		if substr (ascii_card, 1, 1) = "$" then do; /* a dollar card can indicate end of deck */
		     if substr (ascii_card, 1, 15) = "$      dkend   " then goto eod;
		     do i = 2 to 15;		/* check for missing end card -
						   this might be a GMAP, 355MAP, or OBJECT card */
			if substr (ascii_card, 1, 15) = ascii_search_key (i) then goto noend;
		     end;
		     goto eod;			/* NOTE - we are assuming that any other dollar card
						   also ends the library deck, without starting a new one */
		end;
	     end;

	     else do;				/* check it in BCD */
		if gcos_record_ptr -> bcd_card.column (1) = bcd_dollar then do;
		     if substr (string (gcos_record), 79, 36) = bcd_dkend then goto eod;
		     do i = 2 to 15;
			if substr (string (gcos_record), 79, 36) = bcd_search_key (i) then goto noend;
		     end;
		     goto eod;			/* see NOTE above */
		end;
	     end;

	     return ("0"b);

noend:	     no_end_card = "1"b;
eod:	     return ("1"b);

end check_for_eod;
%page;
check_for_eoj: proc returns (bit (1));

	     if eof then return ("1"b);

	     if output.format = ascii | output.gcos_ascii then do; /* check it in ascii */
		if substr (ascii_card, 1, 15) = ascii_search_key (1) then do; /* $ snumb */
		     no_end_card = "1"b;
		     return ("1"b);
		end;
	     end;

	     else do;				/* check it in BCD */
		if gcos_record_ptr -> bcd_card.column (1) = bcd_dollar then do;
		     if substr (string (gcos_record), 79, 36) = bcd_search_key (1) then do; /* SNUMB */
			no_end_card = "1"b;
			return ("1"b);
		     end;
		end;				/* end dollar card */
	     end;					/* end check it in BCD */

	     return ("0"b);

end check_for_eoj;
%page;
cleanup_proc: proc;

dcl  i                        fixed bin(24);

/* Detach file streams. Leave tapes for caller to detach or retain. */

	     do i = 1 to 2;
		call ios_$detach ((file_stream (i)), "", "", status);
	     end;

	     return;

end cleanup_proc;
%page;
close_comdk_output: proc;

	     k_card.char (comdk_out_index) = "111110"b;	/* 76 octal - end of comdk */
	     call write_comdk_card;			/* write out the last card */
	     output_comdk_open = "0"b;		/* remember that comdk is no longer open */

	     return;

end close_comdk_output;
%page;
close_input: proc;

	     io_ptr = input_ptr;			/* in case of error, to indicate which file */

	     if input.medium = tape then do;

		if found_last_line then		/* if we stopped because of -last or -count */
		     if ^file_eof then do;		/* and the last block has not been read */
			call ios_$order (output_stream_name, "forward_file", null, status);
			if code ^= 0 then
			     call interpret_tape_status;
			if ^file_eof then
			     call fatal_error (61);
		     end;

		if ^no_label (io.sw) then do;		/* if labeled tape, read trailer label */
		     label_ptr = input_block_ptr;
		     file_eof = "0"b;
read_trailer:	     call read_block;		/* read the trailer label */
		     if file_eof then do;
			if rcw_eof then do;		/* if we had not yet read the eof tape mark */
			     rcw_eof = "0"b;	/* we just did */
			     goto read_trailer;	/* so go try to read trailer again */
			end;
			call fatal_error (7);	/* eof when trailer label expected */
		     end;				/* end file_eof do group */
		     if input_block_len ^= 14 then
			call fatal_error (8);	/* data record when trailer label expected */
		     if trailer_label.eof ^= bcd_beofbb then /* /bEOF/b/b */
			if trailer_label.eof ^= bcd_beorbb then /* /bEOR/b/b */
			     call fatal_error (9);	/* bad trailer label format */

		     input_block_count = input_block_count - 2; /* deduct the eof and the trailer label */
		     if fixed (trailer_label.block_count) ^= input_block_count then
			if ^input.brief then
			     call ioa_ ("^a: warning: block count in trailer label (^d) ^= blocks read (^d).",
			     me, fixed (trailer_label.block_count), input_block_count);

		     call read_block;		/* read the eof mark after the trailer label */
		     if ^file_eof then
			call fatal_error (10);	/* expected eof after trailer not found */
		end;				/* end of labeled tape do group */

		else do;				/* unlabeled tape */
		     if rcw_eof then do;		/* if we have not yet read the eof tape mark */
			file_eof, rcw_eof = "0"b;	/* turn off switches */
			call read_block;		/* and read it now */
			if ^file_eof then		/* if eof tape mark not there */
			     call fatal_error (60);	/* expected eof after unlabeled tape file missing */
		     end;
		end;

	     end;

	     else do;

		call ios_$detach (input_stream_name, "", "", status);

		if code ^= 0 then call fatal_error (11);

	     end;

	     tape_status_message = "";
	     return;

end close_input;
%page;
close_output: proc;

	     io_ptr = output_ptr;			/* in case of error, to indicate which file */

	     if output_comdk_open then		/* if we were writing a comdk */
		call close_comdk_output;		/* put out the last card */

	     if output.medium ^= raw			/* if an ordinary GCOS file */
	     then if output.format ^= ascii
		then if output.format ^= blocks
		     then if output.medium ^= tape	/* and not a tape file, */

			then call write_gcos_record (addr (eof_rcw), 1); /* then write eof record */

	     if output.medium = tape then do;

		call write_tape_eof;		/* write eof and check error code */

		if ^no_label (io.sw) then do;		/* if labeled tape, build and write trailer label */
		     label_ptr = write_buffer_ptr;	/* build it in the write buffer */
		     unspec (trailer_label) = ""b;	/* clear it first */
		     trailer_label.eof = bcd_beofbb;	/* /bEOF/b/b */
		     trailer_label.block_count = bit (fixed (output_block_count, 36));
		     trailer_label.next_reel = bcd_b6;	/* six bcd blanks */

		     call write_tape_label;		/* write label and eof, checking error codes */

/* build partial label */
		     word_string_len = 14;		/* length of label */
						/* use word_string overlay because structure assignment
						   compiles into element-by-element assignment */
		     addr (header_label) -> word_string = addr (saved_header_label) -> word_string;
						/* partial label is header label, */
		     unspec (partial_label.zero_words) = ""b; /* with words 5-10 zeroed */

		     call write_tape_label;		/* write it and an eof, checking error codes */

/* now, in case there is more to write on the tape, backspace to beginning of partial label,
   so it will be overwritten if there is more */

		     do i = 1 to 2;
			file_eof = "0"b;
			call ios_$order (output_stream_name, "backspace_file", null, status);
			if code ^= 0 then
			     call interpret_tape_status;
			if ^file_eof then		/* should get eof status from backspace file */
			     call fatal_error (12);	/* error while backspacing over partial label */
		     end;

/* read the eof before the partial label */
		     call ios_$read (output_stream_name, input_block_ptr, 0, elements_wanted, input_block_len, status);
		     file_eof = "0"b;
		     if code ^= 0 then
			call interpret_tape_status;
		     if ^file_eof then
			call fatal_error (13);	/* while positioning to partial label */
		end;				/* end of labeled tape do group */

	     end;

	     else do;

		call ios_$detach (output_stream_name, "", "", status);

		if code ^= 0 then call fatal_error (14);

	     end;

	     tape_status_message = "";
	     return;

end close_output;
%page;
copy_jobs:     proc;

	     do list_index = 1 to input.list_count while (^eof);
		call find_list_item;

		if ^eof
		then do;

		     if output.set = multiple_files
		     then call open_next_output;
		     call copy_one_job;
		     if output.set = multiple_files
		     then call close_output;

		     end;
	     end;
end copy_jobs;
%page;
copy_one_deck: proc;				/* procedure to copy one library deck */
dcl  first_card               bit (1) aligned;

	     eof, eoj = "0"b;
	     first_card = "1"b;

	     do while (^eoj);
		if ^first_card then
		     eoj = check_for_eod ();		/* see if this card is an end of deck indicator */
		else first_card = "0"b;
		if ^eof then			/* if there is a card there */
		     if ^no_end_card then		/* and its not the first card of the next deck, write it */
			call write_output;		/* first card was read by find_list_item */
		if ^eoj then call read_and_convert_input;
	     end;

end copy_one_deck;
%page;
copy_one_file: proc;

	     eof = "0"b;

	     do while (^eof);

		call read_and_convert_input;
		if ^eof then call write_output;
	     end;

	     return;
end copy_one_file;
%page;
copy_one_job: proc;
dcl  first_card               bit (1) aligned;

	     eof, eoj = "0"b;
	     first_card = "1"b;

	     do while (^eoj);

		if ^first_card then
		     eoj = check_for_eoj ();
		else first_card = "0"b;
		if ^eof then			/* if there is a card there */
		     if ^no_end_card then		/* and its not the first card of the next job, write it */
			call write_output;		/* first card ( $ snumb) was read by find_list_item */
		if ^eoj then call read_and_convert_input;
	     end;

end copy_one_job;
%page;
cv_bin_to_bcd: proc (input_ptr, output_ptr);
dcl (
     direction,					/* direction of half-interval search */
     i,						/* loop index */
     interval,					/* increment for half-interval search */
     j,						/* loop index */
     k,
     search_index					/* index into binary table */
     ) fixed bin(24)aligned;

dcl (
     input_ptr,					/* pointer to binary data (argument) */
     output_ptr					/* pointer to bcd output (argument) */
     ) ptr aligned;

dcl (
     bad_card,					/* turned on if a bad char is found */
     bin_char_not_found				/* ON until bin_table search is successful */
     ) bit (1) aligned;


dcl (
     divide
     ) builtin;


dcl 1 bcd_chars aligned based (output_ptr),		/* bcd output structure */
    2 bcd_char (0:79) bit (6) unaligned;

dcl  bin_char                 (0:79) bit (12) unaligned based (input_ptr)	/* mask for looking at binary input */;
dcl  this_char                bit (12) aligned	/* copy char to aligned string to avoid hardware bug in cmpb */;


/* perform conversion */

	     bad_card = "0"b;

cv_card:	     do i = 0 to 79;			/* convert 80 characters */

		this_char = bin_char (i);		/* copy to aligned string to avoid hardware bug */
		if this_char = "0"b			/* make quick check for blank */
		then bcd_char (i) = bcd_blank;

		else				/* not binary blank */
translate_char:	do;

		     direction = 1;			/* set up half-interval search */
		     interval = 32;
		     search_index = 0;
		     bin_char_not_found = "1"b;

search_table:	     do j = 1 to 6 while (bin_char_not_found);

			search_index = search_index + direction*interval; /* compute index into binary table */

			if this_char = bin_table (search_index) /* match found */
			then do;
			     bcd_char (i) = bcd_table (search_index); /* set bcd character */
			     bin_char_not_found = "0"b;
			end;

			else			/* not a match */
			do;
			     if this_char > bin_table (search_index) /* set direction of search increment */
			     then direction = 1;
			     else direction = -1;
			     interval = divide (interval, 2, 17, 0); /* set search increment magnitude */
			end;

			end search_table;

		     if bin_char_not_found then	/* no match found */
illegal_char:		do;			/* not a GEBCD card code */

			bcd_char (i) = bcd_blank;	/* leave column blank */
			if ^bad_card then do;	/* if first bad char on card */
			     bad_card = "1"b;	/* remembr it */
			     raw_cards_bad = raw_cards_bad + 1; /* count cards */
			end;

			raw_chars_bad = raw_chars_bad + 1; /* count bad characters */

			if ^input.brief then do;	/* tell user what's wrong, unless told not to */

			     punches = "";		/* clear the string first */

			     do k = 1 to 12;	/* then tell user which rows were punched */
				if substr (this_char, k, 1) then /* if this row punched */
				     punches = punches || punch (k); /* add row number to string to be printed */
			     end;
			     substr (punches, 1, 1) = " "; /* get rid of leading "-" */
			     call ioa_ ("^a: raw card ^d, column ^d - not GEBCD punch:^a^/Processing continues.",
				me, input_block_count, i+1, punches);
			end;
		     end illegal_char;


		end translate_char;

	     end cv_card;

	     return;
end cv_bin_to_bcd;
%page;
fatal_error: proc (error_code);

dcl  error_code               fixed bin(24);		/* identifies the place where the error occurred.  Each call
						   has a different number, even if the message is the same.
						   The first 58 are in order in the program. Those above 58
						   were added later and are out of order. */
dcl  fixed_in_db              bit (1) aligned init ("0"b);
dcl  max_error_code           fixed bin(24)init (61)	/* next available code is 62 */;
dcl (err_msg, msg2) char (200) varying init ("");

	     if ^input.com_err then goto set_code;	/* print only if caller said to */

	     if error_code < 1 | error_code > max_error_code then do;
		err_msg = "Program error - bad internal error code: ^s^d";
		err_num = error_code;
		goto call_com_err;
	     end;

	     goto err (error_code);

err (1): err (44): err (55):
	     err_msg = "Invalid input arguments.";
	     goto call_com_err;

err (2):
	     err_msg = "ASCII character without BCD equivalent in the above value from the command line.";
	     goto call_com_err;

err (3):
	     err_msg = "Program error - converting numeric to BCD for tape label.";
	     goto call_com_err;

err (4):
	     err_msg = "No activity card before data cards in ^a.
Must give either -tabs or -no_canonicalize.";
	     goto call_com_err;

err (5):
	     err_msg = "Backspace not immediately preceeded by tab, in ^a, line ^d";
	     goto set_line_no;

err (6): err (41):
	     err_msg = "Line > 80 characters and -truncate not given:
^a, line ^d.";
	     goto set_line_no;

err (7):
	     err_msg = "File mark where trailer label expected, on ^a ^s^a";
	     goto call_com_err;

err (8):
	     err_msg = "Data record where trailer label expected, on ^a ^s^a";
	     goto call_com_err;

err (9):
	     err_msg = "Bad trailer label on ^a ^s^a";
	     goto call_com_err;

err (10):
	     err_msg = "Expected filemark after trailer not found on ^a ^s^a";
	     goto call_com_err;

err (11): err (14):
	     err_msg = "From ios_$detach ^a";		/* detaching input or output file - not tape */
	     goto call_com_err;
err (12):
	     err_msg = "While backspacing over partial label on ^a ^s^a ^a";
	     goto call_com_err;

err (13):
	     err_msg = "While positioning to partial label on ^a ^s^a ^a";
	     goto call_com_err;

err (15):
	     err_msg = "End of file in middle of comdk: ^a, BCD card ^d";
	     goto set_line_no;

err (16):
	     err_msg = "Non-comdk card in middle of comdk: ^a, BCD card ^d";
	     goto set_line_no;

err (17): err (22):
	     err_msg = "Comdk sequence number error: ^a, BCD card ^d";
	     goto set_line_no;

err (18):
	     err_msg = "Null comdk card: ^a, BCD card ^d";
	     goto set_line_no;

err (19): err (23):
	     err_msg = "Bad comdk field length: ^a, BCD card ^d";
	     goto set_line_no;

err (20):
	     err_msg = "Bad comdk string length: ^a, BCD card ^d";
	     goto set_line_no;

err (21):
	     err_msg = "Comdk field > remainder of BCD card: ^a, BCD card ^d";
	     goto set_line_no;

err (24): err (27):
	     err_msg = "From ios_$attach ^a";
	     goto call_com_err;

err (25): err (28):
	     err_msg = "From ios_$setsize ^a";
	     goto call_com_err;

err (26):
	     err_msg = "From ios_$setdelim ^a";
	     goto call_com_err;

err (29):
	     err_msg = "From ios_$tell last ^a";
	     goto call_com_err;

err (30):
	     err_msg = "From ios_$seek last first ^a";
	     goto call_com_err;

err (31):
	     err_msg = "Program error - unable to append to existing gcos file ^a";
	     goto call_com_err;

err (32):
	     err_msg = "While rewinding ^a ^s^a ^a";
	     goto call_com_err;

err (33):
	     err_msg = "Unexpected filemark read while positioning ^a (file number ^d) ^a";
	     goto call_com_err;

err (34):
	     err_msg = "While positioning ^a (file number ^d) ^a ^a";
	     goto call_com_err;

err (35):
	     err_msg = "Partial label (end of information) read while positioning ^a ^s^a";
	     goto call_com_err;

err (36):
	     err_msg = "Expected header label not found, while positioning ^a ^s^a";
	     goto call_com_err;

err (37):
	     err_msg = "End of reel label (file continued on another reel) read while positioning ^a ^s^a";
	     goto call_com_err;

err (38):
	     err_msg = "Expected trailer label not found, while positioning ^a ^s^a";
	     goto call_com_err;

err (39):
	     err_msg = "Program error while positioning ^a ^s^a";
	     goto call_com_err;

err (40):
	     err_msg = "No newline for over 1280 characters - not an ASCII file: ^a, line ^d";
	     goto set_line_no;

err (42):
	     err_msg = "ASCII character without BCD equivalent: ^/^a, line ^d";
	     goto set_line_no;

err (43):
	     err_msg = "BCD card record > 18 words: ^a, card ^d";
	     goto set_line_no;

err (45): err (46):
	     err_msg = "From ios_$read:";
	     goto set_block_no;

err (47):
	     err_msg = "Read error - wrong number of elements read:";
	     goto set_block_no;

err (48):
	     err_msg = "Read error - zero length block:";
	     goto set_block_no;

err (49):
	     err_msg = "Bad length in block control word:";
	     goto set_block_no;

err (50):
	     err_msg = "Error while deblocking - bad block or record control word:";
	     goto set_block_no;

err (51): err (52):
	     err_msg = "From ios_$write";
	     goto set_out_block_no;

err (53):
	     err_msg = "Write error - wrong number of elements written:";
	     goto set_out_block_no;

err (54):
	     err_msg = "Program error - attempt to write GCOS record > 319 words into";
	     goto set_out_block_no;

err (56):
	     err_msg = "Program error - bad record length or media code for raw output file: ^a, card ^d";
	     err_num = output_block_count;
	     goto call_com_err;

err (57):
	     err_msg = "While writing filemark on ^a ^s^a ^a";
	     goto call_com_err;

err (58):
	     err_msg = "While writing label on ^a ^s^a ^a";
	     goto call_com_err;

err (59):
	     err_msg = "Program error - while encoding output comdk.";
	     goto call_com_err;

err (60):
	     err_msg = "Expected filemark after last block of unlabeled tape file not found on ^a^s^a";
	     goto call_com_err;

err (61):
	     err_msg = "While skipping to trailer label.";
	     goto set_block_no;

set_block_no:
	     err_num = input_block_count;
	     goto set_block_msg;

set_out_block_no:
	     err_num = output_block_count;
	     goto set_block_msg;

set_block_msg:
	     err_msg = err_msg || " ^a, block ^d ^s^a";
	     goto call_com_err;

set_line_no:
	     err_num = file_record_count;

	     if input.set = library then
		msg2 = " edit name = ";
	     else if input.set = imcv then
		msg2 = " snumb = ";
	     else goto call_com_err;

	     msg2 = msg2 || item_name;
	     err_msg = err_msg || " ^a";		/* add control to print msg2 */

call_com_err:
	     call com_err_ (code, me, err_msg, io.file_name, err_num, msg2, tape_status_message);

	     if input.debug then do;
		call ioa_ ("error number gcu_^d", error_code);
		call ioa_ ("CALLING DB");
		call db;

		if fixed_in_db then return;
	     end;
set_code:	     if code = 0 then code = error_table_$action_not_performed;
	     goto cleanup_and_return;

end fatal_error;
%page;
find_list_item: proc;				/* procedure to find the next $ GMAP, $ 355MAP, $ OBJECT
						   $ FORTRAN, $COBOL, or $ SNUMB card
						   that has one of the selected item names on it */

dcl  i                        fixed bin(24);
dcl  saved_comdk_sw           bit (1) aligned;

	     saved_comdk_sw = input.comdk;		/* save value of comdk switch */
	     input.comdk = "0"b;			/* and turn it off, to save the cost of
						   uncoming decks that are not being copied */
	     just_looking = "1"b;			/* suppress the "bin cards skipped" messages */
	     if no_end_card then do;			/* if no end card in previous item  */
		no_end_card = "0"b;			/* we already have one of the key cards in the buffer */
		if output.format = ascii | output.gcos_ascii then goto have_aci; /* so go look at it */
		else goto have_bcd;			/* in ascii or bcd, as the case may be */
	     end;

find_item_read: call read_and_convert_input;		/* read next record */
	     if eof then do;
		input.comdk = saved_comdk_sw;		/* possible multiple file input */
		just_looking = "0"b;		/* so clean up */

		if looking_for_first_line then	/* if we never found the -first card */
		     if saved_comdk_sw then		/* and we were not uncompressing */
			call ioa_ ("^a: Warning: comdks were NOT being uncompressed during the
search for card ^d, resulting in a lower card count than you expected", me, input.first_line);
		return;
	     end;

	     if output.format = ascii | output.gcos_ascii then do; /* ASCII card */
		if substr (ascii_card, 1, 1) ^= "$" then /* if not a dollar card */
		     goto find_item_read;		/* go read the next one */
		do i = first_key to last_key;		/* these indices select either:
						   1) $ SNUMB card, or
						   2) $ GMAP, $ 355MAP, or $ OBJECT card */
		     if substr (ascii_card, 1, 15) = ascii_search_key (i) then /* if this is one of those cards */
			goto have_aci;		/* go get the name off it */
		end;				/* if we fall thru here, it is not one of they key cards */
		goto find_item_read;		/* so go read the next card */
have_aci:		item_name = substr (ascii_card, item_index, item_length); /* pick up edit name or snumb */
	     end;

	     else if gcos_record_ptr -> rcw.media_code = bcd_media_code then do; /* BCD card */
		if gcos_record_ptr -> bcd_card.column (1) ^= bcd_dollar then /* if not dollar card */
		     goto find_item_read;		/* go read next one */
		do i = first_key to last_key;		/* indices pick out either:
						   1) $ SNUMB card, or
						   2) $ GMAP, $ 355MAP, or $ OBJECT */
		     if substr (string (gcos_record), 79, 36) = bcd_search_key (i) then /* if this is one of them */
			goto have_bcd;		/* go get the name off it */
		end;				/* if we fall thru, it is not one of the key cards */
		goto find_item_read;		/* so go read the next one */
have_bcd:		item_name = "";			/* blank out ascii item name */
		do i = 0 to item_length-1;		/* and convert BCD item name to ASCII */
		     substr (item_name, i+1, 1) = xlate (fixed (gcos_record_ptr -> bcd_card.column (item_index+i)));
		end;
	     end;

	     else goto find_item_read;		/* binary card. read next one */

/* if we fall thru here, we have a key card, and we have gotten the item name from it */

	     if item_length = 5 then do;		/* if snumb card, check for short snumb */
		i = index (item_name, ",");		/* look for comma */
		if i ^= 0 then			/* if there was one */
		     substr (item_name, i) = "";	/* blank out it, and whatever follows */
	     end;

	     if input.all then goto print_being_copied;	/* if user said -all, we copy all input items */
	     do i = 1 to input.list_count		/* if not, look up this name in the input list */
						/* comparing only the first N characters of the item name */
						/* with the input list items */
		     while (input_list (i).names ^= substr (item_name, 1, input.list_name_size));
	     end;					/* where N is the length of the input list items */
						/* This is temporary until the command procedure and the input_list
						   structure in the include file can be changed to allow variable length
						   item names, longer than 4 characters (up to 8) */
	     if i = input.list_count + 1 then do;	/* if not found */
		if input.long then call ioa_ (item_name);
		goto find_item_read;		/* keep reading */
	     end;

	     input_list (i).used = "1"b;		/* keep track of which ones we found,
						   for later error message printing */
						/* It might be good to add code to check for
						   a name appearing more than once in the input file,
						   and warn the user, and ask if it should be copied again */

print_being_copied: if input.long | output.long then call ioa_ ("^a  being copied", item_name);

	     input.comdk = saved_comdk_sw;
	     just_looking = "0"b;

	     return;				/* we found one */

end find_list_item;
%page;
get_comdk: proc (record_ptr, record_len);

dcl  fb_temp                  fixed bin(24);
dcl  record_len               fixed bin(24);
dcl  record_ptr               ptr;

	     record_len = 14;			/* we will always return a bcd card */
	     record_ptr = bcd_work_area_ptr;		/* in the work area reserved for us */
	     word_string_len = 14;			/* move 14 words */
	     addrel (record_ptr, 1) -> word_string =	/* into the work area */
		addr (bcd_blank_card) -> word_string;	/* initializing it to 80 bcd blanks */
	     bcd_col_index = 1;			/* start filling in card at col 1 */

uncom_loop:    if field_len = 0 then do;		/* end of comdk card - read next one */
		call read_record (comdk_card_ptr, fb_temp);
		if eof then call fatal_error (15);	/* eof in middle of comdk */
		if (fb_temp ^= 27 & fb_temp ^= 24)	/* if not proper length */
		| comdk_card.col1 ^= comdk_col_1	/* or not comdk code in col 1 */
		then call fatal_error (16);		/* non-comdk card in comdk */
		fb_temp = fixed (comdk_card.seq_no);
		if fb_temp ^= prev_comdk_seq_no + 1 then
		     call fatal_error (17);		/* bad comdk sequence number */
		prev_comdk_seq_no = fb_temp;
		field_len = fixed (comdk_card.char (1));
		if field_len = 0 then
		     call fatal_error (18);		/* null comdk card */
		comdk_char_index = 2;
	     end;


	     if field_len = 63 then do;		/* end of bcd card */
		field_len = fixed (comdk_card.char (comdk_char_index)); /* get next field length */
		comdk_char_index = comdk_char_index + 1;
		if field_len = 62 then do;		/* end of this comdk */
		     if comdk_error_count >0 then
			call ioa_ ("^d field length errors", comdk_error_count);
		     if input.set = library then
			call ioa_ ("(in ^a)", item_name);
		     input_comdk_open = "0"b;		/* so don't come here next time */
		end;
		return;
	     end;


	     if field_len > 55 then
		call fatal_error (19);		/* bad comdk field length */

	     string_len = fixed (comdk_card.char (comdk_char_index)); /* this string length */
	     comdk_char_index = comdk_char_index + 1;
	     if comdk_char_index + string_len > 132 then	/* first char after string */
		call fatal_error (20);		/* comdk string runs off comdk card */
	     if bcd_col_index + field_len > 85 then do;
		if input.debug then do;
		     comdk_error_count = comdk_error_count + 1;
		     if ^input.brief then do;
			call ioa_ ("Illegal comdk: field runs off end of BCD card");
			call ioa_ ("comdk card number ^d, character ^d is field length of ^d",
			     prev_comdk_seq_no, comdk_char_index-2, field_len);
			call ioa_ ("BCD card number ^d, column ^d is next col to fill",
			     file_record_count, bcd_col_index);
			call ioa_ ("Skipping field and blanking rest of BCD card");
		     end;
		     goto next_string;
		end;
		else call fatal_error (21);		/* comdk field runs off bcd card */
	     end;

	     bcd_col_index = bcd_col_index + field_len - string_len; /* move past blanks */
	     bit_string_len = string_len*6;		/* string length in bits, for move */
						/* move the string into the bcd card */
	     addr (bcd_card.column (bcd_col_index)) -> bit_string =
		addr (comdk_card.char (comdk_char_index)) -> bit_string;

	     bcd_col_index = bcd_col_index + string_len;	/* next vacant column */
next_string:   comdk_char_index = comdk_char_index + string_len; /* index of next field length */
	     field_len = fixed (comdk_card.char (comdk_char_index)); /* next field length */
	     comdk_char_index = comdk_char_index + 1;	/* next item on comdk card */
	     goto uncom_loop;


end get_comdk;
%page;
interpret_tape_status: proc;

	     if substr (status, 1, 3) = "100"b then do;	/* if this is hardware status, decode it */
		if substr (status, 27, 4) = "0100"b	/* major status End of File */
		& (substr (status, 31, 6) = "001111"b	/* EOF 7track */
		| substr (status, 31, 6) = "010011"b)	/* EOF 9track */
		then file_eof = "1"b;

		else call decode_nstd_status_ (status, tape_status_message);

	     end;					/* if not hardware status, just return */

	     return;

end interpret_tape_status;
%page;
julian_day: proc (month, dom, year) returns (fixed bin);

dcl  mlen                     (12) fixed bin(24)int static init (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);
dcl (i, month, dom, year, jday) fixed bin(24);

	     jday = 0;
	     do i = 1 to month-1;			/* add up days in preceeding months */
		jday = jday+mlen (i);
	     end;
	     jday = jday + dom;			/* add date in this month */
	     if month > 2 then			/* if March or later */
		if mod (year, 4) = 0 then		/* and this is leap year */
		     jday = jday + 1;		/* add in Feb 29 */
	     return (jday);
end julian_day;
%page;
make_gcos_record:	proc;				/* come here to build gcos records */

		gcos_record_ptr = gcos_work_area_ptr;	/* build record in gcos_work_area */

		if output.gcos_ascii then do;

		     char_string_len = ascii_line_len;	/* length of ascii char string to move */
		     addrel (gcos_record_ptr, 1) -> char_string = ascii_card; /* move it into gcos record */

		     i = mod (char_string_len, 4);	/* number of chars in partially filled word */
		     if i ^= 0 then do;		/* if there is a partially filled word */
			i = 4-i;			/* compute number of pad characters needed to fill it out */
			char_string_len = char_string_len + i; /* lengthen string by that much */
			substr (addrel (gcos_record_ptr, 1) -> char_string, ascii_line_len+1, i) =
			     substr (ascii_pads, 1, i);
		     end;				/* and move in the pad characters */

		     gcos_record.rcw = ""b;		/* clear the rcw, and fill in some fields */
		     gcos_record_len = divide (char_string_len, 4, 17, 0); /* word length of record */
		     gcos_record_ptr -> rcw.length = bit (fixed (gcos_record_len, 18)); /* into rcw */
		     gcos_record_ptr -> rcw.media_code = ascii_media_code; /* media code = 6 */

		     if i ^= 0 then do;		/* if last word is partially filled */
			i = 4-i;			/* get back the number of chars in it */
			substr (gcos_record.rcw, 19, 2) = bit (bin (i, 2)); /* and put it in the rcw, in a new field
						   that used to be part of the eof indicator */
		     end;

		end;

		else do;				/* regular BCD record wanted */

		     gcos_record_len = 14;		/* fixed bin(24)copy of rcw.length */
		     gcos_record.data_words = bcd_b6;	/* fill with BCD spaces */
		     call gcos_cv_ascii_gebcd_check_
			(ascii_line_ptr, ascii_line_len, addrel (gcos_record_ptr, 1), code);
		     if code ^= 0 then do;
			call ioa_ ("Error on character ^d of:^/^a", code, ascii_card);
			code = 0;			/* code is position of bad char - not error table code */
			call fatal_error (42);
		     end;

		     gcos_record.rcw = bcd_rcw;

		end;

	     return;
end make_gcos_record;
%page;
open_comdk_input: proc (record_ptr, record_len);

dcl  record_len               fixed bin(24);
dcl  record_ptr               ptr;

	     comdk_error_count = 0;
	     input_comdk_open = "1"b;			/* remember that comdk is open */
	     comdk_card_ptr = record_ptr;		/* point to first comdk card */
	     prev_comdk_seq_no = fixed (comdk_card.seq_no);
	     if prev_comdk_seq_no ^= 1 then
		call fatal_error (22);		/* bad initial comdk seq no */
	     field_len = fixed (comdk_card.char (1));	/* first field len */
	     if field_len < 1 | field_len > 55 then
		call fatal_error (23);		/* bad initial comdk field len */
	     comdk_char_index = 2;			/* since we got char 1 above */
	     bcd_work_area_ptr -> gcos_record.rcw = bcd_rcw; /* initialize the rcw */


	     return;


end open_comdk_input;
%page;
open_comdk_output: proc;

dcl (i, j) fixed bin(24);

	     string (k_card) = ""b;			/* clear the 28 word buffer used to build comdk cards */

	     k_card.rcw = bin_rcw;			/* rec len = 27, media code = 1 */
	     k_card.col1 = comdk_col_1;		/* 5005 octal (12-0-7-9 punch) */
	     comdk_out_index = 1;			/* start with first char on output card */

	     k_card.seq_no = bit (bin (1, 24));		/* fixed bin(24)24 constant 1 */

/* Initialize sequence columns (73-80) to "EEEE0000" where EEEE is the first 4 characters of the edit name */

	     if input.set = library then
		edit_name = substr (item_name, 1, 4);
	     else if input.medium = tape then
		edit_name = "....";
	     else do;				/* get an edit name from the file name */
		i, j = 1;				/* don't want it to be ">udd", so find entry name */
find_edit_name:
		j = index (substr (input.file_name, i), ">"); /* look for another ">" */
		if j ^= 0 then do;			/* found one */
		     i = i + j;			/* move past it */
		     goto find_edit_name;
		end;
		edit_name = substr (input.file_name, i, 4);
	     end;

	     unspec (bcd_edit_name) = bcd_string (edit_name, 4); /* convert edit name to bcd */
	     do i = 1 to 4;				/* use numeric value of bcd character as index into table */
		k_card.seq_col (i) = raw_table (fixed (bcd_edit_name (i))); /* of card punch patterns for those chars */
	     end;

	     do i = 5 to 8;				/* initialize col 77-80 to zeros */
		k_card.seq_col (i) = raw_table (0);
		seq_col (i) = 0;			/* fixed bin(24)copy of 77-80, for incrementing */
	     end;

	     output_comdk_open = "1"b;

	     return;


end open_comdk_output;
%page;
open_input: proc;

	     io_ptr = input_ptr;			/* for position tape, and to tell which file, if error */

	     if input.medium = tape then do;		/* the tape will already be attached */

		input_stream_name = tape_stream (input.sw);

		element_size = 36;
		elements_wanted = 320;
		call position_tape;			/* reads and verifies labels */

	     end;					/* end open tape */

	     else do;

		input_stream_name = file_stream (input.sw);

		call ios_$attach (input_stream_name, "file_", input.file_name, "r", status);
		if code ^= 0 then call fatal_error (24);

		if input.medium = raw then do;
		     element_size = 960;		/* 12 rows X 80 columns */
		     elements_wanted = 1;

		     input_block_ptr = addrel (gcos_work_area_ptr, 1); /* read directly into the record, after the rcw */

/* by reading the record directly into gcos_work_area, we save copying it later */
/* input_block_ptr tells ios_$read where to put the input */

		end;

		else if input.format = ascii then do;
		     element_size = 9;		/* the default - set in case changed previously */
		     elements_wanted = 1280;		/* the buffer size */
		end;

		else do;				/* all other possibilities */
		     element_size = 36;		/* one word */
		     elements_wanted = 320;		/* one block */
		end;

		call ios_$setsize (input_stream_name, element_size, status);
		if code ^= 0 then call fatal_error (25);

	     end;					/* end open non tape */

	     if input.format = ascii then do;

		if ^input.no_canon then		/* if we are going to call canonicalizer */
		     tabstop_ptr = addr (gcos_control_tables_$tabstops); /* get pointer to tab table */
						/* by waiting to do it now,
						   we avoid initiating segment gcos_control_tables_ in
						   cases where we are not going to use anything in it */

		call ios_$setdelim (input_stream_name, 1, unspec (ascii_newline), 1, unspec (ascii_newline), status);
		if code ^= 0 then call fatal_error (26);
						/* we had to set the delimiter back to newline, since the
						   ios_$setsize call removes the default delimiter */

	     end;

	     file_eob = "1"b;			/* always read a block on first read call */
	     file_eof = "0"b;			/* not eof 'til we read an eof */
	     rcw_eof = "0"b;
	     found_last_line = "0"b;

	     looking_for_first_line, looking_for_last_line = "0"b;
	     if input.first_line > 0 then
		looking_for_first_line = "1"b;

	     else					/* don't start looking for last line til first line found */
	     if input.last_line > 0 then
		looking_for_last_line = "1"b;

	     tape_status_message = "";

	     if input.long then
		call ioa_ ("^a being read", input.file_name);

	     return;

end open_input;
%page;
open_next_input: proc;

	     next_input_index = next_input_index + 1;
	     input.file_name = input_list (next_input_index).names;
	     call open_input;
	     input_list (next_input_index).used = "1"b;
	     file_record_count = 0;			/* causes -first, -last, -count to be
						   applied separately to each input file */

	     return;

end open_next_input;
%page;
open_next_output: proc;

	     next_output_index = next_output_index + 1;

	     if next_output_index > output.list_count then do;
		if ^input.brief then do;
		     io_ptr = input_ptr;
		     call report_missing_items;
		end;
		goto cleanup_and_return;
	     end;

	     if output.name_files then do;
		if index (substr (item_name, 1, item_length), " ") > 1 then
		     output.file_name = before (item_name, " ")||next_output_suffix;
		else output.file_name = substr (item_name, 1, item_length)||next_output_suffix;
	     end;
	     else do;
		output.file_name = output_list (next_output_index).names;
		output_list (next_output_index).used = "1"b;
	     end;

	     call open_output;

	     return;


end open_next_output;
%page;
open_output: proc;

	     io_ptr = output_ptr;			/* for position_tape, and to tell which file, if error */

	     if output.medium = tape then do;

		output_stream_name = tape_stream (output.sw);

/* tape is already attached */

		call position_tape;

		if ^no_label (io.sw) then do;		/* if labeled tape, build and write header label */
		     label_ptr = write_buffer_ptr;	/* build it in the write buffer */
		     unspec (header_label) = ""b;	/* clear it first */

		     header_label.btl = bcd_btl;	/* GE/b/b600/bBTL/b */

		     call system_info_$installation_id (inst); /* get installation id */
		     header_label.installation = bcd_string (inst, 6); /* first 6 chars of it in BCD */

		     header_label.reel_ser_no = bcd_b1; /* blank first char */
		     substr (header_label.reel_ser_no, 7, 30) = bcd_string (string (output_tape.id), 5);
						/* ser no in last 5 chars */

		     header_label.file_ser_no = header_label.reel_ser_no; /* always the same for single reel files */

		     header_label.reel_seq_no = bcd_b2; /* blank first 2 chars */
		     substr (header_label.reel_seq_no, 36, 1) = "1"b; /* last 24 bits are the fixed binary number 1 */

		     header_label.creation_date = bcd_b1; /* blank first char */
		     call decode_clock_value_ (clock_ (), month, dom, year, tod, dow, zone); /* get date */
		     substr (header_label.creation_date, 7, 12) = bcd_string_bin (mod (year, 100), 2);
						/* last 2 digits of year, in BCD */
		     substr (header_label.creation_date, 19, 18) = bcd_string_bin (julian_day (month, dom, year), 3);
						/* 3 digit julian day, in BCD */

		     header_label.retention_days = bcd_b3; /* first 3 chars blank */
						/* last 3 all zero - no retention days */

		     header_label.file_name = bcd_string (string (output_tape.label), 12);

		     header_label.prverr = bcd_b6;	/* 6 BCD blanks */

		     word_string_len = 14;		/* length of label */
		     addr (saved_header_label) -> word_string = addr (header_label) -> word_string;
						/* save it to use for building partial label later */
						/* use word_string overlay, since structure assignment
						   compiles into element-by-element assignment */

		     call write_tape_label;		/* write label and eof, checking error codes */
		end;				/* end of labeled tape do group */

	     end;

	     else do;

		output_stream_name = file_stream (output.sw);

		call ios_$attach (output_stream_name, "file_", output.file_name, "rw", status);
						/* attach in "rw" mode, to allow reading to end of file
						   to be appended to, if there is one */
		if code ^= 0 then call fatal_error (27);

/* set element size */

		if output.medium = raw then
		     element_size = 960;

		else if output.format = ascii then
		     element_size = 9;

		else
		element_size = 36;

		call ios_$setsize (output_stream_name, element_size, status);
		if code ^= 0 then call fatal_error (28);


		call ios_$tell (output_stream_name, "last", "first", offset, status);
		if code ^= 0 then call fatal_error (29);

		appending_to_output = "0"b;		/* initialize switch to off */
		if offset ^= 0 then			/* if output seg has something in it already */
		     if output.append then		/* and user said -append */
			appending_to_output = "1"b;	/* then remember to do so */

		     else do;			/* else ask what to do */
			call command_query_ (addr (query_info), answer, me,
			     "^a already exists. Do you want to overwrite it?", output.file_name);

			if answer = "no" then goto cleanup_and_return;

			else do;			/* truncate the output file */
			     call ios_$seek (output_stream_name, "last", "first", 0, status);
			     if code ^= 0 then call fatal_error (30);
			end;

		     end;				/* end ask user about existing file */
	     end;					/* end attach non tape */

	     if output.medium ^= raw then
		if output.format ^= ascii then
		     if output.format ^= blocks then do;

			if appending_to_output then do;

			     call ios_$read (output_stream_name, gcos_record_ptr, 0, 320, gcos_record_len, status);
			     return;
			end;

			else do;
			     remaining_output_words = 319;
			     output_word_ptr = addrel (write_buffer_ptr, 1);
			     block_serial_number = 1;
			     write_buffer_ptr -> bcw.bsn = bit (fixed (block_serial_number, 18));
			     output_block_len = 0;	/* fixed bin(24)copy of bcw.length */
			     write_buffer_ptr -> bcw.length = (18)"0"b;

			     if output.gcos_ascii then do; /* write an empty 20-word record at the start of a gcos
						   ascii file to be compatible in format with the real gcos */
				output_block_len = output_block_len + 21; /* 20 words plus rcw */
				write_buffer_ptr -> bcw.length = bit (bin (output_block_len, 18));
				output_word_ptr -> word_string (1) = ascii_header_rcw;
				output_word_ptr = addrel (output_word_ptr, 21);
				remaining_output_words = remaining_output_words - 21;
			     end;

			end;

		     end;

	     tape_status_message = "";

	     if output.long then
		call ioa_ ("^a being written", output.file_name); /* print file name or tape message */

	     return;

end open_output;
%page;
position_tape: proc;

dcl  expected_input           fixed bin(24)/* next thing expected from tape */;
dcl (header init (1),				/* names for things expected from tape */
     trailer init (2),
     eof_after_header init (3),
     eof_after_trailer init (4),
     eof_after_forward_file init (5)
     )int static fixed bin(24);
dcl  file_number              fixed bin(17)init (0);
dcl  position_found           bit (1) aligned init ("0"b);	/* to remember that we found the position,
						   while we are reading past the eof mark after a label */
dcl  ascii_file_name          char (12) aligned;
dcl  ascii_ser_no             char (5) aligned;
dcl  i                        fixed bin(24);

dcl 1 hdr aligned based (label_ptr),			/* overlay for header label */
    2 fill1 (3) bit (36) aligned,			/* to pick up chracters in reel_ser_no and file_name */
    2 ser (0:5) bit (6) unaligned,			/* one at a time */
    2 fill2 (4) bit (36) aligned,
    2 fname (12) bit (6) unaligned;			/* don't care about rest of it */

dcl 1 tape_message aligned based (addr (io.file_name)),
   (2 io_name char (6),
    2 b1 char (1),
    2 tape char (4),
    2 b2 char (1),
    2 tape_id char (5),
    2 b3 char (1),
    2 file char (4),
    2 b4 char (1),
    2 fileno char (3),
    2 b5 char (1),
    2 filename char (12)) unaligned;

/* Put tape information into io.filename, for convenience of message printing */
	     io.file_name = "";
						/* tape_message overlays beginning of io.file_name */
	     tape_message.tape = "tape";
	     tape_message.io_name = substr (io_names (io.sw), 1, length (tape_message.io_name)); /* "input" or "output" */
	     tape_message.tape_id = substr (io_tape.id, 1, length (tape_message.tape_id));


/* Check for nothing to do */
	     if io_tape.position = 0 then do;		/* if user did not give position */
		if io.sw = output_code then return;	/* use current position for output */
		else if no_label (io.sw) then return;	/* do the same for input, if there are no labels */
		else if io_tape.label = "" then	/* or, if input file name not given */
		     goto omit_rewind;		/* just read past the header label */
	     end;

/* Rewind tape */
	     call ios_$order ((tape_stream (io.sw)), "rewind", null, status);
	     if code ^= 0 then
		call fatal_error (32);		/* error rewinding tape */
	     if io.sw = output_code | no_label (io.sw) then
		if io_tape.position = 1 then goto set_fileno; /* we are already there */
omit_rewind:					/* come here to just read past header label of current file */

/* Initialize for search loop */
	     label_ptr = input_block_ptr;
	     if no_label (io.sw) then do;		/* if unlabeled tape */
		expected_input = eof_after_forward_file; /* just skip to requested position */
		file_number = 1;			/* we are already at first file */
	     end;

	     else expected_input = header;

/* Search loop */
position_loop: file_eof = "0"b;
	     err_num = file_number;			/* in case of error while positioning */

	     if expected_input = eof_after_forward_file then /* skip over data records */
		call ios_$order ((tape_stream (io.sw)), "forward_file", null, status);
	     else					/* just read labels and eof marks */
	     call ios_$read ((tape_stream (io.sw)), input_block_ptr, 0, elements_wanted, input_block_len, status);

	     if code ^= 0 then do;

		call interpret_tape_status;		/* check for eof or other error */

		if file_eof then do;		/* eof mark read */

		     if expected_input = eof_after_forward_file then do;
			if ^no_label (io.sw) then	/* unless this is an unlabeled tape, */
			     expected_input = trailer; /* the next thing will be a trailer label */

			else do;			/* it is an unlabeled tape */
			     if io.long then	/* tell user that previous file was skipped */
				call ioa_ ("tape ^a, file ^d will be skipped", io_tape.id, file_number);
			     file_number = file_number + 1; /* increment file number */
			     if file_number = io_tape.position then /* if this is the file we want */
				goto set_fileno;	/* go put its number into message and return */
			end;

		     end;

		     else if expected_input = eof_after_trailer then
			if position_found then goto set_filename; /* positioned for writing label of output file */
			else expected_input = header;

		     else if expected_input = eof_after_header then
			if position_found then goto set_filename; /* positioned for reading input data records */
			else expected_input = eof_after_forward_file; /* skip over data records */

		     else call fatal_error (33);	/* unexpected eof while positioning tape */

		end;				/* end eof mark read */

		else call fatal_error (34);		/* io error while positioning tape */

	     end;					/* end code ^= 0 */

	     else if expected_input = header then do;	/* want header label */
		if header_label.btl = bcd_btl then do;	/* this is one */
		     expected_input = eof_after_header;
		     file_number = file_number + 1;

		     if unspec (partial_label.zero_words) = ""b then /* check for partial label */
			call fatal_error (35);	/* partial label while positioning tape */

		     if file_number = 1 then do;	/* first file on tape */
			do i = 1 to 5;		/* convert reel serial number in label to ASCII */
			     substr (ascii_ser_no, i, 1) = xlate (fixed (hdr.ser (i)));
			end;

			if substr (io_tape.id, 1, 4) = "-att" then /* if we did not know the serial no */
			     tape_message.tape_id, io_tape.id = ascii_ser_no; /* we do now */

			else do;			/* if we already knew it, verify correct tape */
			     if substr (io_tape.id, 1, 5) ^= ascii_ser_no then do; /* need substr because of possible
						   trailing ",Ntrack in id */
				call command_query_ (addr (query_info), answer, me,
				     "Label on ^a tape contains reel serial number ^a.
You specified reel ^a. Do you wish to proceed?", io_names (io.sw), ascii_ser_no, io_tape.id);
				if answer = "no" then goto cleanup_and_return;
			     end;			/* end mismatched ser nos */
			end;			/* end we already knew ser no */

		     end;				/* end file number = 1 */

		     do i = 1 to 12 ;		/* convert file name in label to ASCII */
			substr (ascii_file_name, i, 1) = xlate (fixed (hdr.fname (i)));
		     end;

		     if io_tape.position ^= 0 then do;	/* if user gave position */
			if file_number = io_tape.position then do; /* and this is it */
			     if io_tape.label ^= "" then do; /* if file name also given */
				if ascii_file_name ^= io_tape.label then do; /* compare them */
				     call command_query_ (addr (query_info), answer, me,
					"File ^d on tape ^a is named ^a.
You specified the file name: ^a. Do you wish to proceed?",
					file_number, io_tape.id, ascii_file_name, io_tape.label);
				     if answer = "no" then goto cleanup_and_return;
				     io_tape.label = ascii_file_name; /* replace given name by one from tape label */
				end;		/* end names not the same */
			     end;			/* end user gave label */

			     position_found = "1"b;

			end;			/* end this is specified position */
		     end;				/* end user gave position */

		     else do;			/* user did not give position */
						/* this has to be input */
			if io_tape.label = "" then	/* we were just reading past header label */
			     goto found_input_position; /* of current file */
			if ascii_file_name = io_tape.label then
found_input_position:	     position_found = "1"b;
		     end;

		     if io.long then do;
			if position_found then
			     answer = "copied";
			else answer = "skipped";
			call ioa_ ("tape ^a, file ^d (^a) will be ^a."
			     , ascii_ser_no, file_number, ascii_file_name, answer);
		     end;

		end;				/* end this is a header label */

		else call fatal_error (36);		/* expected header label not found */
	     end;					/* end expecting header label */

	     else if expected_input = trailer then do;
		if trailer_label.eof = bcd_beofbb then do;
		     expected_input = eof_after_trailer;
		     if io.sw = output_code then do;	/* for output, stop after trailer of previous file */
			if file_number = io_tape.position - 1 then do;
						/* if this file immediately preceeds the one to be written */
			     position_found = "1"b;
			     if io.long then
				call ioa_ ("Output will be written on tape ^a after file ^d (^a).",
				ascii_ser_no, file_number, ascii_file_name);
			end;

		     end;				/* end output */
		end;				/* end eof label */

		else if trailer_label.eof = bcd_beorbb then
		     call fatal_error (37);		/* eor label while positioning */

		else call fatal_error (38);		/* expected trailer label missing while positioning */

	     end;					/* end expecting trailer */

	     else call fatal_error (39);		/* bug in position tape */

	     goto position_loop;

set_filename:					/* put file name into tape message */
	     tape_message.filename = io_tape.label;
						/* fall thru and put file number in it too */
set_fileno:    ;
dcl p13 pic "(12)z9";
dcl 1 p13_ovl based(addr(p13))
,2 l10 char(10)unal
,2 r3  char( 3)unal
;
	     p13 = file_number;
	     tape_message.fileno = p13_ovl.r3;		/* last 3 of the 10 digits returned
						   by char for fixed bin(17) */
	     tape_message.file = "file";
	     return;

end position_tape;
%page;
process_imcv:  proc;

	     call open_input;

	     if output.set ^= multiple_files then call open_output;

/* set up parameters for find_list_item */

	     item_index = 16;			/* snumb begins in col 16 */
	     item_length = 5;			/* and can be up to 5 chars long */
	     first_key = 1;				/* look for $ SNUMB */
	     last_key = 1;				/* only */
	     eof = "0"b;

	     call copy_jobs;		/* Now do the grubby work */

	     if output.set ^= multiple_files then call close_output;

	     else if ^output.name_files then
		if next_output_index < output.list_count then
		     if ^output.brief then do;
			io_ptr = output_ptr;
			call report_missing_items;
		     end;

	     if eof then do;
		if ^input.all then
		     if list_index ^= input.list_count + 1 then
			if ^input.brief then do;
			     io_ptr = input_ptr;
			     call report_missing_items;
			end;

		if looking_for_first_line then
		     call report_suspicious_eof;
	     end;

	     call close_input;

end process_imcv;
%page;
process_library_file:    proc;

	     call open_input;
	     if output.set ^= multiple_files then call open_output;
	     eof = "0"b;


/* set up parameters for find_list_item */

	     item_index = 73;			/* edit name starts in col 73 */
	     item_length = 8;			/* and is up to 8 chars long */
	     first_key = 2;				/* look for $ GMAP (2) */
						/* $ 355MAP (3) */
						/* $ OBJECT (4) */
						/* $ FORTRAN (5) */
	     last_key = 15;				/* or $ IDS2 (15) */

copy_library_decks: do list_index = 1 to input.list_count while (^eof);

		call find_list_item;

		if ^eof
		then do;
		     if output.set = multiple_files then call open_next_output;
		     call copy_one_deck;
		     if output.set = multiple_files then call close_output;
		end;

	     end copy_library_decks;

	     if input.long then call ioa_ ("^/End of Library copy.");
	     if output.set ^= multiple_files then call close_output;

	     else if ^output.name_files then
		if next_output_index < output.list_count then
		     if ^output.brief then do;
			io_ptr = output_ptr;
			call report_missing_items;
		     end;

	     if eof then do;
		if ^input.all then			/* if all decks were not being copied */
		     if list_index ^= input.list_count + 1 then
			if ^input.brief then do;
			     io_ptr = input_ptr;
			     call report_missing_items;
			end;

		if looking_for_first_line then
		     call report_suspicious_eof;
	     end;

	     call close_input;

end process_library_file;
%page;
process_multiple_files: proc;

	     if output.set ^= multiple_files then call open_output;


copy_files:    do list_index = 1 to input.list_count;

		call open_next_input;
		if output.set = multiple_files then call open_next_output;

		call copy_one_file;

		call close_input;
		if output.set = multiple_files then call close_output;

	     end copy_files;

	     if output.set ^= multiple_files then call close_output;

	     else					/* check for all of the output files written */
	     if ^output.name_files then		/* but only if names were given */
		if next_output_index ^= output.list_count then
		     if ^output.brief then do;
			io_ptr = output_ptr;
			call report_missing_items;
		     end;

end process_multiple_files;
%page;
process_single_file: proc;

	     call open_input;
	     if output.set = multiple_files then	/* if user did a dumb thing - i.e.
						   gave several output files, but only one input file */
		call open_next_output;		/* we will be sensible, by writing into the first one,
						   instead of trying to write into a file whose name is given
						   by the garbage in an uninitialized variable */

	     else call open_output;

	     call copy_one_file;

	     call close_input;
	     call close_output;

	     if output.set = multiple_files then	/* if user did a dumb thing */
		if output.list_count > 1 then		/* and it was a very dumb thing */
		     if ^output.brief then do;	/* if he is willing to be told about it */
			io_ptr = output_ptr;	/* tell him */
			call report_missing_items;
		     end;

end process_single_file;
%page;
put_comdk: proc (record_ptr, record_len);

dcl  record_len               fixed bin(24);
dcl  record_ptr               ptr;

dcl  b_col                    fixed bin(24)/* current column from b_card */;
dcl  extra_chars              fixed bin(24)/* number of chars past the limit of 55 per field */;
dcl  field_len                fixed bin(24)/* length of compressed field, including leading blanks */;
dcl  saved_string_len         fixed bin(24)/* remember nonblank count when limit of 55 is exceeded */;
dcl  string_len               fixed bin(24)/* length of trailing nonblank string in compressed field */;
dcl  string_start             fixed bin(24)/* b_col where nonblank string starts */;
dcl 1 b_card like bcd_card aligned based (record_ptr);

dcl  blank                    bit (1) aligned	/* on if current char from b_card is blank */;
dcl  in_blanks                bit (1) aligned	/* on while in a string of 3 or more blanks */;
dcl  prev_blanks              fixed bin(24)/* counter used to find 3 or more consecutive blanks */;


	     prev_blanks, field_len, string_len = 0;
	     string_start = 1;			/* first string starts in col 1 */
	     in_blanks = "1"b;			/* to compress 1 or 2 blanks at start of card */

	     if comdk_out_index = 132 then		/* if current output card is full */
		call finish_comdk_card;		/* write it out and initialize a new one */

	     do b_col = 1 to 80;			/* scan input card for compressible fields */

		if b_card.column (b_col) = bcd_blank
		then blank = "1"b;
		else blank = "0"b;

		if ^blank then			/* if in a nonblank string */
		     if comdk_out_index > 129 then	/* but there is no room for another field */
						/* on the current output card */
			call finish_comdk_card;	/* write it out and initialize another one */

		field_len = field_len + 1;		/* add this char to length of field */

		if in_blanks then do;		/* if already in a string of blanks */
		     if ^blank then do;		/* not blank - end of blank string */
			in_blanks = "0"b;
			string_len = 1;		/* start a new nonblank string */
			string_start = b_col;	/* at this column */
		     end;
		end;				/* end of in blanks do group */

		else do;				/* not in blanks */
		     string_len = string_len + 1;	/* add this char to length of nonblank string */
		     if blank then do;		/* if this is a blank */
			if prev_blanks = 2 then do;	/* we found 3 consecutive blanks */
			     in_blanks = "1"b;
			     prev_blanks = 0;
			     if field_len > 3 then do; /* if there was a field before the blanks */
				field_len = field_len - 3; /* remove the them from it */
				string_len = string_len - 3;
				call put_comdk_string; /* and write it out */
			     end;
			     string_len = 0;	/* new field has no trailing nonblanks yet */
			     field_len = 3;		/* but it has 3 leading blanks */
			end;			/* end found 3 blanks do group */
			else
			prev_blanks = prev_blanks + 1; /* count blanks */
		     end;				/* end this is a blank do group */
		     else				/* not a blank */
		     prev_blanks = 0;		/* reset, in case 1 or 2 blanks preceeded this nonblank */
		end;				/* end not in blanks do group */

		if ^in_blanks then do;		/* we might not be in blanks now, although we were before */

		     if field_len = 56 then		/* if 1 char too many */
			if b_col = 80 then		/* but this is the last column */
						/* the check for >=57, below, will fail */
			     goto field_too_long;	/* so go write out the first 55 chars now */

		     if field_len >= 57 then do;	/* max field length is 55, but we let it go longer,
						   in case the card ends in a long string of blanks,
						   or there are 3 consecutive blanks in chars 54-57 */
field_too_long:					/* come here if 56th char is in col 80 */
			extra_chars = field_len - 55;
			call put_long_comdk_string;	/* go put out first 55 chars, and adjust for extras */
		     end;				/* end >=57 char do group */

		     if ^blank then do;		/* if no possibility of getting into blanks */
			extra_chars = string_len + 2 + comdk_out_index -132; /* check for full output card */
			if extra_chars >= 0 then do;	/* if we will fill or overfill it */
			     if extra_chars = 0 then	/* we might exactly fill the output card */
				if field_len = 56 then /* with character 56 of a field (illegal) */
				     extra_chars = 1; /* because we let it grow to 57 (see above) */
			     call put_long_comdk_string; /* go put out first 55 chars and adjust for extras */
			end;			/* end of string-fills-card do group */
		     end;				/* end of this-is-not-a-blank do group */
		end;				/* end not-in-blanks-now do group */

	     end;					/* end 1 to 80 loop on b_col */

/* Fall thru here after looking at all 80 columns */

	     if prev_blanks > 0 then do;		/* discard 1 or 2 trailing blanks */
		string_len = string_len - prev_blanks;
		field_len = field_len - prev_blanks;
	     end;

	     if string_len > 0 then			/* if the card ends in a nonblank string */
		call put_comdk_string;		/* put it out now */
	     k_card.char (comdk_out_index) = "111111"b;	/* 77 octal - end of bcd card */
	     comdk_out_index = comdk_out_index + 1;

	     return;

/* * * * * * * * * * *

   INTERNAL PROCEDURES WITHIN THIS INTERNAL PROCEDURE */

put_comdk_string: proc;

/* FOR DEBUGGING */
		if field_len > 55 then goto k_len_err;
		if string_len + 2 > 132 - comdk_out_index then
k_len_err:
		     call fatal_error (59);		/* program error while encoding output comdk */

		k_card.char (comdk_out_index) = bit (fixed (field_len, 6));
		comdk_out_index = comdk_out_index + 1;
		k_card.char (comdk_out_index) = bit (fixed (string_len, 6));
		comdk_out_index = comdk_out_index + 1;

		if string_len > 0 then do;		/* if there is a non blank string */
		     bit_string_len = string_len * 6;	/* move it as based bit string */
		     addr (k_card.char (comdk_out_index)) -> bit_string =
			addr (b_card.column (string_start)) -> bit_string;
		     comdk_out_index = comdk_out_index + string_len;
		end;

		if comdk_out_index = 132 then		/* if card completely full */
		     call finish_comdk_card;		/* write it out */
						/* however, if there is room for the end of bcd card and
						   end of deck indicators, we will put off writing it out
						   until we know if there is more data */

		return;

	     end put_comdk_string;

/* * * * * * * * * * * */

put_long_comdk_string: proc;

		field_len = field_len - extra_chars;	/* get rid of the extra chars */
		saved_string_len = string_len;	/* remember how many nonblanks there were */
		string_len = max (0, string_len - extra_chars); /* possibility of more than 55 blanks */
		call put_comdk_string;		/* put out the 55 char field */
		field_len = extra_chars;		/* the left over chars start a new field */
		string_len = min (saved_string_len, extra_chars); /* if nonblank after many blanks,
						   string_len will be 1, while extra_chars will be larger */
		string_start = b_col - string_len + 1;	/* position of first nonblank extra char */

		if comdk_out_index > 129 then		/* if there is no room for another field
						   on the current output card */
		     if string_len > 0 then		/* but we have the makings of another field */
			if prev_blanks ^= string_len then /* and there is no possibility of its being all blank */
			     call finish_comdk_card;	/* write out the current output card and initialize another */

		if ^in_blanks then do;
		     if prev_blanks = string_len then	/* if first 1 or 2 chars of left over string are blank */
			prev_blanks, string_len = 0;	/* get rid of them */
		     if string_len = 0 then		/* if there are no nonblank chars */
			in_blanks = "1"b;		/* any leading blanks get compressed out */
		     else if b_card.column (string_start) = bcd_blank then do;
			string_start = string_start + 1;
			string_len = string_len - 1;
		     end;
		end;

	     end put_long_comdk_string;


/* * * * * * * * * * * */

finish_comdk_card: proc;

dcl  i                        fixed bin(24);

		k_card.char (comdk_out_index) = "000000"b; /* end of comdk card - more to come */
		call write_comdk_card;		/* write out the card */
		string (k_card.char) = "0"b;		/* clear the 132 output characters */
		comdk_out_index = 1;		/* and start with the first one */
		k_card.seq_no = bit (fixed (1+fixed (k_card.seq_no), 24)); /* increment sequence number */

/* Increment sequence field - columns 77-80 */

		i = 8;				/* seq_col(1:8) correspond to card col(73:80) */
seq_carry:	seq_col (i) = seq_col (i) + 1;
		if seq_col (i) = 10 then seq_col (i) = 0; /* check for carry */
		k_card.seq_col (i) = raw_table (seq_col (i));
		if seq_col (i) = 0 then do;		/* if we carried 1 */
		     i = i - 1;			/* add it to the column to the left */
		     if i >= 5 then goto seq_carry;	/* but don't overflow into column 76 */
		end;

		return;
	     end finish_comdk_card;


end put_comdk;
%page;
read_and_convert_ascii: proc;

dcl  i                        fixed bin(24);

	     call read_block;

/* read_block will return file_eof when it is returning the last block.
   read_and_convert_input checks file_eof before calling us, so we do not
   have to check for eof here */

	     if input_block_len = elements_wanted then
		if substr (ascii_block, input_block_len, 1) ^= ascii_newline then
		     call fatal_error (40);		/* no newline for a long way in ascii file */

	     if substr (ascii_block, input_block_len, 1) = ascii_newline then /* if there is a trailing newline */
		input_block_len = input_block_len - 1;	/* get rid of it */

	     if input_block_len = 0 then do;		/* check for empty line */
		input_block_len = input_block_len + 1;	/* aos instead of lda sta */
		substr (ascii_block, 1, 1) = " ";	/* put in 1 blank to avoid trouble later */
	     end;

	     if input.no_canon then do;		/* if we are not canonicalizing, fix up line length here */
		if (output.gcos_ascii) | (output.format = ascii) then
		     ascii_line_len = input_block_len;	/* records are variable length */
		else do;				/* otherwise they are fixed length 80 column card images */
		     ascii_line_len = 80;
		     if input_block_len > 80 then do;	/* if input line is too long */
			if ^input.truncate_ascii then /* and user did not say truncate */
			     call fatal_error (41);	/* complain */
			input_block_len = 80;	/* else truncate */
		     end;
		end;
		ascii_card = ascii_block;		/* copy input line into work area */
	     end;					/* end no_canonicalize do group */

	     else do;				/* we are canonicalizing */
		if (output.gcos_ascii) | (output.format = ascii) then /* if variable length records */
		     ascii_line_len = length (ascii_line); /* allow max length for canonicalized line */
		else ascii_line_len = 80;		/* else make it 80 column card image */
		call canonicalizer (input_block_ptr, input_block_len, ascii_line_ptr, ascii_line_len);
		if output.gcos_ascii then do;		/* now get rid of the trailing blanks, if we
						   allowed max length for variable length line */
		     i = verify (reverse (ascii_card), " "); /* i will be position of first nonblank */
		     ascii_line_len = ascii_line_len - i + 1; /* so get rid of i-1 trailing blanks */
		end;
	     end;					/* end of canonicalize do group */


	     if output.format ^= ascii then call make_gcos_record;

	     return;

end read_and_convert_ascii;
%page;
read_and_convert_gcos: proc;

dcl  i                        fixed bin(24);
dcl  fill_index		fixed bin (24);
dcl  media_code               bit (4) unaligned;

skip_card: ;					/* come here after discarding a non-bcd card,
						   to get another card */
	     if input.comdk then call read_comdk (gcos_record_ptr, gcos_record_len);
	     else call read_record (gcos_record_ptr, gcos_record_len);

/* we now have a gcos record, complete with rcw */


	     if eof then do;			/* maybe we don't have a record... */

		if output.format = ascii | output.gcos_ascii then
		     if ^output.brief then do;

			ascii_card = "END OF FILE";	/* supply something to print, since there is no card */
			call check_bin_cards;	/* and go see if deck ended with binary cards */
		     end;

		return;

	     end;

	     media_code = gcos_record_ptr -> rcw.media_code;


	     if media_code = ascii_header_media_code then do;
		if input.long then
		     call ioa_ ("discarding gcos ascii header record");
		goto skip_card;
	     end;

	     else if media_code = ascii_media_code then do; /* if we have a gcos ascii record */
		ascii_line_len = 4*fixed (gcos_record_ptr -> rcw.length); /* record length in chars */
		if (gcos_record_ptr -> rcw.char_pos ^= 0)
		     then ascii_line_len = ascii_line_len -4 +(gcos_record_ptr -> rcw.char_pos);
		char_string_len = ascii_line_len;	/* length of string to move */
		ascii_card = addrel (gcos_record_ptr, 1) -> char_string; /* move it out of record */
		if ascii_line_len < 6		/* gotta pad first word */
		then do;
		     fill_index = ascii_line_len +1;
		     ascii_line_len = 6;
		     substr (ascii_card, fill_index, (7 - fill_index)) = " ";
		     end;
	     end;


	     if output.format = ascii | output.gcos_ascii then do;

		if (media_code = bcd_media_code) | (media_code = plain_bcd_media_code) then do; /* if bcd record */
						/* or media code = 0 */

		     if (gcos_record_len > 18) & (media_code = bcd_media_code)
			then call fatal_error (43);

		     if gcos_record_len <= 14		/* if this is an ordinary BCD card */
		     then ascii_line_len = 80;	/* make it exactly 80 columns */
		     else ascii_line_len = gcos_record_len*6; /* if BCD record is longer than a card */
		     ascii_card = "";		/* blank out 'ascii_line_len' characters
						   (the conversion routine doesn't) */

		     call gcos_cv_gebcd_ascii_ (addrel (gcos_record_ptr, 1), min (ascii_line_len, gcos_record_len*6), ascii_line_ptr);

		     if ^input.brief then call check_bin_cards; /* go see if binary cards preceeded this one */

		     if output.gcos_ascii		/* chop off trailing blanks */
		     then do;
			ascii_line_len = length (rtrim (ascii_card));
			if ascii_line_len = 0	/* but leave at least one char
						   so we don't get shot down */
			then do;
			     ascii_line_len = ascii_line_len + 1;
			     substr (ascii_card, ascii_line_len, 1) = " ";
			     end;
			call make_gcos_record;
			end;

		end;

		else if media_code ^= ascii_media_code then do; /* if not BCD or ASCII record,
						   we have to discard it on ASCII output */

		     if ^input.brief then
			if ^just_looking then	/* we skip thru comdks while looking for edit name or snumb */
			     bin_cards_skipped = bin_cards_skipped + 1;
						/* keep track of binary cards, to print in message later */

		     goto skip_card;		/* skip this binary card; go get next card */

		end;

	     end;

	     else					/* output is BCD */
	     if media_code = ascii_media_code then	/* if we have gcos_ascii input */
		call make_gcos_record;		/* go convert it to BCD */

	     return;

end read_and_convert_gcos;
%page;
read_and_convert_input: proc;				/* a call to this procedure will:
						   1) read next record from input file, whatever its type, and
						   2) convert it to proper format for output, except for
						   compressing for comdk output, which is done in write_output */

	     io_ptr = input_ptr;			/* to tell which file, if error */

read_next_record:					/* come here while searching for first line */
	     file_record_count = file_record_count + 1;
	     if looking_for_last_line then
		if file_record_count > input.last_line then do;
		     found_last_line = "1"b;
		     goto return_eof;
		end;

	     if looking_for_first_line then
		if file_record_count >= input.first_line then do;
		     looking_for_first_line = "0"b;
		     if input.last_line > 0 then
			looking_for_last_line = "1"b;
		end;

	     if file_eof then
		if file_eob then
		     if ^input_comdk_open then do;
return_eof:		eof = "1"b;
			return;
		     end;

	     if input.format = ascii then call read_and_convert_ascii;
	     else if input.format = blocks then do;
		if file_eof then do;
		     eof = "1"b;
		     return;
		end;
		call read_block;
		if input.medium = tape then
		     if file_eof then do;
			eof = "1"b;
			return;
		     end;
	     end;
	     else if input.format = gcos then call read_and_convert_gcos;
	     else call fatal_error (44);

	     input_record_count = input_record_count + 1;

	     if looking_for_first_line then
		goto read_next_record;

	     return;

end read_and_convert_input;
%page;
read_block: proc;					/* procedure to call ios_$read and interpret status code */

	     call ios_$read (input_stream_name, input_block_ptr, 0, elements_wanted, input_block_len, status);

	     input_block_count = input_block_count + 1;	/* count blocks */

	     if input.medium ^= tape then do;

		file_eof = substr (status, 46, 1);
		if code ^= 0 then call fatal_error (45);
		if file_eof
		then if output.medium = tape		/* chop off the EOF RCW if tape output */
		     then bcw_word.bcw_len = bcw_word.bcw_len - 1;
 
	     end;					/* end check non-tape status */

	     else do;

		if code ^= 0 then do;
		     file_eof = "0"b;
		     call interpret_tape_status;
		     if ^file_eof then		/* if not just end of file */
			call fatal_error (46);	/* tape read error */
		     else do;			/* skip block length checking if end of file */
			if output.medium = tape	/* chop off the EOF RCW if tape output */
			then bcw_word.bcw_len = bcw_word.bcw_len - 1;
			return;
			end;
		end;

	     end;					/* end check tape status */

	     if input.format ^= ascii
	     then if input.medium ^= tape
		then if elements_wanted ^= input_block_len
		     then call fatal_error (47);

	     if input_block_len = 0 then call fatal_error (48);

	     return;

end read_block;
%page;
read_comdk: proc (record_ptr, record_len);		/* returns a bcd or binary card in a gcos record;
						   uncompresses any comdks that it reads */

dcl  record_len               fixed bin(24);
dcl  record_ptr               ptr;


	     if input_comdk_open then call get_comdk (record_ptr, record_len); /* if already in a comdk */

	     else do;

		call read_record (record_ptr, record_len);

		if eof then return;

		if (record_len = 27|record_len = 24) then /* if the length is that of a binary card */
		     if record_ptr -> bin_card.column (1) = comdk_col_1 /* and col 1 has the comdk code in it */
		     then do;			/* then this is the start of a comdk */
			call open_comdk_input (record_ptr, record_len); /* send comdk card to open routine */
			call get_comdk (record_ptr, record_len); /* now go get first uncomed card from it */
		     end;

	     end;

	     return;

end read_comdk;
%page;
read_gcos_record: proc (record_ptr, record_len);		/* procedure to read next record from a
						   standard system format gcos file */

dcl  record_len               fixed bin(24);
dcl  record_ptr               ptr;

	     if file_eob then do;			/* if no more records in this block */


		if file_eof then do;		/* check for end of file from last read block call */
		     eof = "1"b;			/* tell caller, if eof */
		     return;			/* and return */
		end;
						/* else keep reading */
		call read_block;			/* get next block */
			/* End of file checking is made complicated by the fact that the file_ dim
			   returns an EOF status from the same call that returns the last words in the file,
			   and we have to remember that status and act on it the NEXT time we want to
			   read a block. The nstd_ dim, however, returns EOF when there are no more
			   tape records to be returned. If we are reading a tape, we have to check
			   for EOF again, now. */

		if input.medium = tape then		/* if reading tape */
		     if file_eof then do;		/* and there are no more records */
			eof = "1"b;		/* tell caller */
			return;			/* and return to him immediately */
		     end;

		remaining_block_len = fixed (input_block_ptr -> bcw.length); /* get block length */
		if remaining_block_len > 319 | remaining_block_len < 1 then call fatal_error (49);

		file_eob = "0"b;			/* remember that we got block */

		record_ptr, saved_record_ptr = addrel (input_block_ptr, 1); /* get first record */

	     end;

	     else					/* else just get next record */
	     record_ptr, saved_record_ptr = addrel (saved_record_ptr, fixed (saved_record_ptr -> rcw.length) + 1);

	     if record_ptr -> rcw.eof = bcd_eof then do;	/* check for eof record */

		rcw_eof, eof, file_eof, file_eob = "1"b; /* if so, turn on all end switches */
		return;				/* and return */
	     end;

	     record_len = fixed (record_ptr -> rcw.length); /* get record length */

	     remaining_block_len = remaining_block_len - record_len - 1; /* decrement block length */
	     if remaining_block_len < 0 then call fatal_error (50); /* should never go negative */
	     if remaining_block_len = 0 then file_eob = "1"b; /* check for end of block */

	     return;

end read_gcos_record;
%page;
read_raw_record: proc (record_ptr, record_len);		/* procedure to get next card from a raw card file,
						   and return it in a gcos standard record */


dcl  record_len               fixed bin(24);
dcl  record_ptr               ptr;

	     if file_eof then do;
		eof = "1"b;
		return;
	     end;

	     record_ptr = gcos_work_area_ptr;
	     gcos_work_area = "0"b;			/* clear work area */
	     call read_block;			/* read one 960-bit string into it, in words 2-28 */

	     if substr (gcos_work_area (2), 10, 3) = "101"b then do; /* 7-9 punch ? */
		gcos_work_area (1) = bin_rcw;		/* rcw for binary card */
		record_len = 27;
	     end;

	     else do;				/* bcd card */

		call cv_bin_to_bcd (input_block_ptr, input_block_ptr);
						/* NOTE translation in place: output is half as long as input */

		gcos_work_area (1) = bcd_rcw;		/* rcw for bcd record */
		record_len = 14;
	     end;

	     return;


end read_raw_record;
%page;
read_record: proc (record_ptr, record_len);		/* procedure to get the next gcos record;
						   decides whether to read from a gcos file, or
						   build one from the next card in a raw file;
						   comdk cards are passed to the caller unchanged */

dcl  record_len               fixed bin(24);
dcl  record_ptr               ptr;

	     if input.medium = raw then call read_raw_record (record_ptr, record_len);
	     else call read_gcos_record (record_ptr, record_len);

	     return;

end read_record;
%page;
report_missing_items: proc;

dcl  i                        fixed bin(24);

	     if io.sw = input_code then do;

		if ^eof then do;			/* must have run out of output names */
		     call ioa_ ("^a: Output list exhausted while input items remain to be copied.
The following input item(s) have not been copied:^/^a", me, item_name);
		end;
		else call ioa_ ("^a: The following input items were not found:", me);
	     end;

	     else call ioa_ ("^a: Input list exhausted while output file names remain.
The following output file(s) have not been written:", me);

	     if io.list_ptr = null then		/* must be input -all, and there is no list */
		call ioa_ ("^/And any that follow it in the input file.");

	     else do i = 1 to io.list_count;
		if ^io_list (i).used then
		     call ioa_ (io_list (i).names);
	     end;

	     return;

end report_missing_items;
%page;
report_suspicious_eof: proc;

	     call ioa_ ("^a: End of file after card ^d of ^a, while seeking card ^d", me,
		file_record_count, input.file_name, input.first_line);
	     return;

end report_suspicious_eof;
%page;
write_block: proc (block_ptr, block_len);		/* procedure to call ios_$write and interpret status code */

dcl  block_ptr                ptr;
dcl  block_len                fixed bin(24);		/* THIS block_len IS THE TOTAL NUMBER OF ELEMENTS
						   TO BE WRITTEN; FOR A GCOS BLOCK, THE CALLER MUST ADD 1
						   TO bcw.length TO OBTAIN THE CORRECT VALUE */


	/* Don't write a zero-length (BCW-only) block to a tape */

	     if output.format = ascii
	      | block_len > 1

	     then do;

		output_block_count = output_block_count + 1;
		call ios_$write (output_stream_name, block_ptr, 0, block_len, elements_written, status);

		if code ^= 0

		then do;

		     if output.medium = tape

		     then do;

			call interpret_tape_status;
			call fatal_error (51);		/* tape write error */
			end;

		     else call fatal_error (52);

		     end;

		if elements_written ^= block_len
		then call fatal_error (53);
		end;

	     return;

end write_block;
%page;
write_comdk: proc (record_ptr, record_len);

dcl  dont_compress            bit (1) aligned;
dcl  record_len               fixed bin(24);
dcl  record_ptr               ptr;

	     dont_compress = "0"b;

	     if record_ptr -> rcw.media_code ^= bcd_media_code then
		dont_compress = "1"b;		/* don't compress binary cards */
	     else					/* it is a bcd card */
	     if record_ptr -> bcd_card.column (1) = bcd_dollar then
		dont_compress = "1"b;		/* don't compress dollar cards, either */

	     if output_comdk_open then do;
		if dont_compress then do;		/* close it */
		     call close_comdk_output;
		     call write_record (record_ptr, record_len); /* and then write this record */
		end;

		else call put_comdk (record_ptr, record_len);

	     end;					/* end comdk open */

	     else do;				/* comdk not open */
		if dont_compress then
		     call write_record (record_ptr, record_len);

		else do;
		     call open_comdk_output;
		     call put_comdk (record_ptr, record_len);
		end;

	     end;					/* end comdk not open */

	     return;

end write_comdk;
%page;
write_comdk_card: proc;

dcl  checksum                 fixed bin(71);
dcl  i                        fixed bin(24);

/* compute checksum of word 1 and words 3-24 of the comdk record */

	     checksum = fixed (comdk_work_area_ptr -> gcos_record.data_words (1), 36);

	     do i = 3 to 24;
		if checksum >= 68719476736 then	/* 2**36 */
		     checksum = checksum - 68719476736 + 1; /* a carry into bit 37 gets added to bit 1 */
		checksum = checksum + fixed (comdk_work_area_ptr -> gcos_record.data_words (i), 36);
	     end;
						/* NOTE: a carry into bit 37 when the LAST word is added
						   is ignored and not added to bit 1 - this is apparently
						   the way GEFRC does it, so we will do the same */

/* put checksum into record */
	     k_card.checksum = bit (fixed (checksum, 36));

/* write it out */
	     call write_record (comdk_work_area_ptr, 27);

	     return;

end write_comdk_card;
%page;
write_gcos_record: proc (record_ptr, record_len);

dcl  record_ptr               ptr;
dcl  record_len               fixed bin(24);		/* THIS record_len INCLUDES THE RCW; THE CALLER MUST ADD 1
						   TO rcw.length TO OBTAIN THE CORRECT VALUE */
dcl  block_len                fixed bin(24)/* to send block length to write block */;
dcl  record                   (record_len) bit (36) based;

	     if record_len > 319 then call fatal_error (54);

	     if record_len > remaining_output_words then do; /* write out the block */

		if output.medium = tape then		/* for tape files */
		     block_len = output_block_len + 1;	/* write 320 words or less */
		else				/* for disk files, we pad blocks to 320 words */
		block_len = 320;			/* so a read of 320 words will get exactly one block */

		call write_block (write_buffer_ptr, block_len);

		unspec (write_buffer) = ""b;		/* zero the output buffer,
						   to avoid garbage at the ends of short blocks */

		remaining_output_words = 319;
		output_word_ptr = addrel (write_buffer_ptr, 1);

		block_serial_number = block_serial_number + 1;
		write_buffer_ptr -> bcw.bsn = bit (fixed (block_serial_number, 18));

		output_block_len = 0;		/* fixed bin(24)copy of bcw.length */

	     end;

	     output_block_len = output_block_len + record_len;
	     write_buffer_ptr -> bcw.length = bit (fixed (output_block_len, 18));

	     output_word_ptr -> record = record_ptr -> record;

	     output_word_ptr = addrel (output_word_ptr, record_len);
	     remaining_output_words = remaining_output_words - record_len;

	     if record_len = 1 then do;		/* record_len of 1 must be an end-of-file word
						   (000000170000 octal), so force out the block */
		if output.medium = tape then do;	/* tape files should not end with eof records */
		     write_buffer_ptr -> bcw.length = bit (bin (output_block_len-1, 18)); /* adjust bcw.length */
		     block_len = output_block_len;	/* write one less word (omit the eof_rcw) */
		end;

		else block_len = 320;		/* if not tape, write exactly 320 words */
		call write_block (write_buffer_ptr, block_len);
	     end;

	     return;

end write_gcos_record;
%page;
write_output: proc;

dcl  i                        fixed bin(24);

	     io_ptr = output_ptr;			/* to tell which file, if error */

	     if output.format = gcos then do;
		if output.comdk then call write_comdk (gcos_record_ptr, gcos_record_len);
		else call write_record (gcos_record_ptr, gcos_record_len);
	     end;
	     else if output.format = ascii then do;
		i = length (rtrim (ascii_card)) + 1;	/* get rid of trailing blanks */

		if output.truncate_ascii
		then if i > 81
		     then i = 81;			/* chop the line at 80 chars */

		substr (ascii_line, i, 1) = ascii_newline; /* last char must be newline */
		call write_block (ascii_line_ptr, i);
	     end;

	     else if output.format = blocks
		then do;
		     if output.medium = tape
		     then i = bcw_word.bcw_len + 1;	/* pick up block length, including bcw */

		     else if input.medium = tape	/* if tape to segment copy */
			then i = 320;			/* pad output block to 320 words */
			else i = input_block_len;		/* if not tape, write out exactly what was read in */
		     call write_block (input_block_ptr, i);
		     end;

		else call fatal_error (55);

	     output_record_count = output_record_count + 1;

	     return;

end write_output;
%page;
write_raw_record: proc (record_ptr, record_len);

dcl  record_len               fixed bin(24);
dcl  record_ptr               ptr;

dcl  i                        fixed bin(24);
dcl  raw_ptr                  ptr;

	     if (record_len = 27|record_len = 24)	/* if binary card */
	     &record_ptr -> rcw.media_code = "0001"b then do;
		raw_ptr = addrel (record_ptr, 1);	/* data starts right after rcw */
		goto write_raw;			/* go write it out */
	     end;

	     else if record_len = 14			/* if BCD card */
	     &record_ptr -> rcw.media_code = "0010"b then do;
		do i = 1 to 80;
		     raw_card (i) = raw_table (fixed (record_ptr -> bcd_card.column (i)));
		end;
		raw_ptr = raw_card_ptr;

write_raw:	call write_block (raw_ptr, 1);	/* write one 960-bit element */
		return;
	     end;

	     else call fatal_error (56);		/* bad record length or media code */

end write_raw_record;
%page;
write_record: proc (record_ptr, record_len);

dcl  record_len               fixed bin(24);
dcl  record_ptr               ptr;

	     if output.medium = raw then call write_raw_record (record_ptr, record_len);
	     else call write_gcos_record (record_ptr, record_len + 1);
						/* +1 because rcw not included in record_len, and
						   write_gcos_record wants total number of words to be written */

	     return;

end write_record;
%page;
write_tape_eof: proc;

	     call ios_$order (output_stream_name, "eof", null, status);
	     if code ^= 0 then do;
		call interpret_tape_status;
		call fatal_error (57);		/* error while writing tape eof */
	     end;

	     return;

end write_tape_eof;
%page;
write_tape_label: proc;		/* write a label on magnetic tape */

	     call write_block (label_ptr, 14);
	     if code ^= 0 then do;
		call interpret_tape_status;
		call fatal_error (58);		/* error writing tape label */
	     end;

	     output_block_count = output_block_count - 1; /* do not count label as a block -
						   exact count is needed to put in trailer label */
	     call write_tape_eof;			/* write eof mark and check error code */

	     return;

end write_tape_label;


/* ******************************************************************************************************************** */
/* ******************************************************************************************************************** */
/* ******************************************************************************************************************** */
/* ******************************************************************************************************************** */

end gcos_card_utility_;
