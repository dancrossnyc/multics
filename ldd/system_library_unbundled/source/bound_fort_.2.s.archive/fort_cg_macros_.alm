
" ******************************************************
" *                                                    *
" * Copyright, (C) Honeywell Limited, 1983             *
" *                                                    *
" * Copyright (c) 1972 by Massachusetts Institute of   *
" * Technology and Honeywell Information Systems, Inc. *
" *                                                    *
" ******************************************************

" HISTORY COMMENTS:
"  1) change(86-07-14,BWong), approve(86-07-14,MCR7286),
"     audit(86-07-17,Ginter), install(86-07-28,MR12.0-1105):
"     Fix fortran bugs 430, 452, and 463.
"  2) change(86-07-14,BWong), approve(86-07-14,MCR7442),
"     audit(86-07-17,Ginter), install(86-07-28,MR12.0-1105):
"     Fix fortran bug 410.
"  3) change(88-04-28,RWaters), approve(88-04-28,MCR7875),
"     audit(88-07-13,Huen), install(88-11-10,MR12.2-1209):
"     Implement SCP 6339:  removed the special case code for constants since
"     they can now be up to 128K chars long.
"                                                      END HISTORY COMMENTS


" Written:	January 1976, by G. D. Chang
"
" Modified:
"         08 Mar 86, SH - 410: Fix bug in cv_bif_to_external where offsets
"		into vector for dtan, asin, dasin and acos were out
"		of order.
"	08 Aug 85, BW - 430: Prevent emission of deallocation code for
"		automatic LA's and VLA's when they don't exist in the
"		compilation unit.
"	02 Aug 85, BW - 463: Removed code to save and restore stack
"		extents in 'quick_return' and 'make_quick_entry'.
"		This was only done when char star-extent variables
"		were concatenated.
"         12 May 95, BW - 452: Fix looping problem when a vla array is
"		incorrectly used as a format in a write statement.
"	22 Jun 84, MM - Install typeless functions support.
"	28 Mar 84, MM - Install HFP support.
"	12 Sep 83, HH - 388: Insure any logical value in the indicators
"		is stored before issuing an 'fneg'.
"	17 Jun 83, HH - 383: Replace 'scan_parameter_list' subroutine with
"		'prepare_for_namelists' subr and 'process_param_list' proc.
"	 7 June 83, TO: 381 - Fix pr0|shorten_stack for registers pr1,x1.
"	31 Jan 83, TO & HH - Install LA/VLA support.
"	10 January  1982, TO - Add 'emit_entry_defs' call to entries.
"	 3 January  1982, TO - Add DO-loop optimization of forcing 'even'
"		address of top label of loop.
"	17 Dec 82, TO - Add 'emit_profile_entry' simple operator.
"         17 Nov 82, HH - 361:  'get_format_var' operator no longer needed.
"	27 July 1982, TO - Fix check in relational operators to permit
"	     temporary nodes, such as expressions and function returns in
"	     relationals with character constants.
"	12 May 1982, HH - Add "fixedoverflow" check for multiplies.
"	 5 May 1982, TO - Add shorten stack to return from char*(*) function.
"	 1 April   1982, TO  - Add intrinsic externals for builtins.
"	28 October 1981, CRD - Inquire statement.
"	20 October 1981, CRD - Internal files.
"	27 August 1981, CRD - More general UNIT field in OPEN/CLOSE stmts.
"	21 August 1981, CRD - Blank field in OPEN statement.
"	27 July 1981, CRD - Allow format labels in assign_label operator,
"		and allow integer scalars in format operator.
"	18 June 1981, CRD - Fix unnumbered bug in complex exponentiation.
"	10 June 1981, CRD - New polish for backspace/endfile/rewind.
"	2 June 1981, CRD - Handle statement functions with 0 arguments.
"	12 May 1981, CRD - Add equiv_op, not_equiv_op.
"	23 April 1981, CRD - Fix bug 317.
"	18 March 1981, CRD - Fix bug 310.
"	13 March 1981, CRD - Modifications for assumed size arrays.
"	19 February 1981, CRD - Change check_subscript for variable lower
"		array bounds.
"	9 December 1980, CRD - Fix bug 298.
"	8 December 1980, CRD - Implement Fortran 77 block IF statement.
"	24 November 1980, CRD - Implement Fortran 77 zero trip DO loops.
"	24 November 1980, CRD - Change several I/O routines to issue load_pr
"		macros BEFORE loading the A or Q.  This is necessary as
"		loading a pointer to a character array element may use the
"		A or Q.
"	31 October 1980, CRD - Fix bug in div_rc.
"	24 October 1980, CRD - Add code for new Fortran 77 intrinsics.
"	13 October 1980, CRD - As a result of the change to manage the A, Q,
"		and EAQ separately, in_reg and return eaq_name macros no
"		longer erase the machine state entirely.  Therefore, it is
"		necessary to issue a use_eaq macro before emitting a call
"		to one of the type conversion operators.
"	10 October 1980, CRD - Fix bug whereby real and dp DO loops  did not
"		truncate loop count to integer.
"	26 September 1980, CRD - Change make_quick_entry to asert that pr1
"		contains the arg list ptr.
"	17 September 1980, CRD - Fix bug 278.  The AMAX0, MAX1, AMIN0, and
"		MIN1 intrinsics got incorrect code because of improper
"		EAQ management.
"	22 August 1980, CRD - Fix error handling for open statement.
"	13 August 1980, CRD - Add error_macro segdef.
"	24 July 1980, CRD - Fix bug in subscript processing which caused
"		non-integer subscripts to confuse the machine state.
"	16 July 1980, CRD - Key argument list consistency checking off of
"		variable_arglist bit, not needs_descriptors bit.
"	15 July 1980, CRD - Centralize call-side descriptor checking in
"		descriptor_check subroutine.  Change logic so that
"		descriptors are automatically generated for calls with
"		character mode arguments in ansi77 mode.
"	27 June 1980, CRD - Modify I/O routines to allow I/O of character
"		strings of variable length.  Put check in func_ref to
"		ensure that function is not *-length.
"	26 June 1980, CRD - Check data type of parent in substr.
"	23 June 1980, CRD - Check ansi77 mode for concatenation.
"	14 May 1980, CRD - Fix bug in ICHAR intrinsic.
"	7 March 1980, CRD - Implement concatenation.
"	1 February 1980, CRD - Fix bug in which subscripts with bad data
"		types get no error messages.  Make a similar change for
"		substring expressions.
"	24 January 1980, CRD - Add code to make_entry, make_quick_entry,
"		and make_call to allow for Fortran entries which
"		require descriptors.
"	14 Dec 1979, CRD - Add use_ind macros to relational operators, and
"		change make_entry and make_quick_entry to allow for entries
"		that require descriptors.
"	1 Nov 1979, CRD - Add mpy to single_inst table, change if_ind and
"		unless_ind macros to have eaq_name.
"	09 Aug 1979, CRD - Fix bug 221 (dmod implemented incorrectly)
"	12 Jul 1979, PES - More forgiving encode/decode statement.  The string
"		may now be an array, simple variable, or array element of any type
"		but logical.
"	09 Jul 1979, CRD - Changes to fix bug 220, in which files do not
"		get closed if there is no STOP or CALL EXIT statement in the
"		main program.
"	17 Nov 1978, RAB - Centralizes rounding decisions in "round" and
"		"store" macros.  Precedes many floating compares
"		with rounds.
"	13 Sep 1978, PES - Changes to fix bug 183, in which fortran sometimes decides that
"		external subroutine names passed out as arguments in a call should be
"		treated as character strings.
"	05 Sep 1978, PES - Changes to fix bug 179, in which real/dp function results are
"		rounded before being stored.
"	27 Jul 1978, PES - Changes to fix min and max bug. audit changes.
"	20 Jun 1978, DSL - Clean up and bug fixes from loop optimizer audit.
"		Fix macros for sign builtin functions.
"	25 May 1978, DSL - Minor bug fixes in open/close. Fix bug 159 in which
"		indicators are not set correctly before calls to "sign" BIFs
"		and for aint BIF. Fix bug 156 in which "frd" or "dfrd" is
"		required before conversion to integer.
"	02 May 1978, DSL - fix bug 153 in which macros contained a
"		dfcmp	=0.,du.
"	13 Feb 1978, DSL - Fix bug 140 in which "load_pr pr1" destroys the
"		addressability of subsequent operands. Also, changed fst to fstr in
"		div_ic code. Also converted round_dp_to_real to a function.
"	03 Feb 1978, DSL - Emergency fix to negate complex.
"	05 Jan 1978, DSL - Implement double precision to complex conversion for
"		arithmetic infix oprs and for assignment.
"	04 Jan 1978, DSL - Implement rel ops for one char const opnd and one
"		arith opnd. Fix bug in func ref (unreported) in which no warning is
"		printed if return value is char and may need descriptors.
"	27 Dec 1977, DSL - fix bug in cv_bif_to_external (136); use new macros
"		pad_char_const_to_(word dw) in assign, fix bug in func_ref (130),
"		change macros to truncate on store when appropriate, introduce use
"		of new macro, dt_jump1.
"	15 Sep 1977, DSL - interim fix to abs bif until load_for_test macro
"		is available.
"	19 Jul 1977, DSL - fix bugs in open/close.
"	14 Jul 1977, DSL - 1) fix sf def for simple references.
"		2) change implementation of open/close. 3) fix sf ref for
"		logical sf. 4) prevent parameters from reaching make_external_variable.
"	26 May 1977, GDC - allow statement functions to take character
"		arguments with character data-types.
"
	maclist	object
	include		fort_macros
	include		fort_equs

	include		stack_header
	include		stack_frame

	name		fort_cg_macros_

	segdef		operator_table
	segdef		single_inst
	segdef		interpreter_macros
	segdef		first_scan
	segdef		abort_list
	segdef		error_macro

	use		.text.

	include	fort_operator_table

	include	fort_single_inst

interpreter_macros:
	zero	check_subscript
	zero	subscript_mpy
	zero	move_eis
	zero	check_stringrange


check_subscript:
	func	3

	swap	arg1

	" arg1: upper bound
	" arg2: lower bound
	" arg3: subscript

	if	arg1,=,op1,ret_sub
	if	arg2,=,op1,ret_sub

	load	q,arg1

	use_eaq

	lda	arg2
	cwl	arg3
	tze	2,ic
	tsx0	pr0|bound_ck_signal

ret_sub:
	return	arg3


subscript_mpy:
	proc	1


	if	arg1,=,1,ret_mpy

	if_check_multiply	subscript_mpy.1

	if	arg1,=,2,qls1

subscript_mpy.1:
	mpy	arg1

	unless_check_multiply	ret_mpy
	tsx0	pr0|mpy_overflow_check

ret_mpy:	return

qls1:	emit	1

	qls	1

	return


move_eis:
	proc	2

	emit_eis
	mlr	(),(pr),fill(040)
	desc9a	arg1
	desc9a	arg2

	return


check_stringrange:
	proc	3

	" arg1 is length of parent
	" arg2 is index of first char in substring
	" arg3 is index of last char in substring

	use_eaq

	lda	1,dl		" Get lower bound in A
	load	q,arg1		" Get upper bound in Q
	cwl	arg2		" Check the first index
	tze	2,ic
	tsx0	pr0|signal_stringrange

	lda	arg2		" Get first index in A
	load	q,arg1		" Get length of string in Q
	cwl	arg3		" Check second index
	tze	2,ic
	tsx0	pr0|signal_stringrange

	return


"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

first_scan:
	scan		continue,continue

abort_list:
	scan		continue,(continue,next)

error_macro:
	error

assign:	proc		2

	dt_jump		(assign_ii,assign_ri,assign_di,assign_ci,assign_ir,assign_rr,assign_dr,assign_cr,assign_id,assign_rd,assign_dd,assign_cd,assign_ic,assign_rc,assign_dc,assign_cc,assign_e2,assign_e1,assign_t,assign_t)

assign_ii:
	load		q,arg2
	store		q,arg1
	return

assign_ir:
	s_call		cv_load.ri
	store		q,arg1
	return

assign_ri:
	s_call		cv_load.ir
	store		eaq,arg1
	return

assign_id:
	s_call		cv_load.di
	store		q,arg1
	return

assign_di:
	s_call		cv_load.id
	store		deaq,arg1
	return

assign_rr:
	load		eaq,arg2
	store		eaq,arg1
	return

assign_dd:
	load		deaq,arg2
	store		deaq,arg1
	return

assign_rd:
	load		deaq,arg2
	fstr		arg1
	return

assign_dr:
	load		eaq,arg2
	store		deaq,arg1,no_update
	return

assign_ic:
	s_call		cv_load.ri
	store		q,arg1
	return

assign_ci:
	s_call		cv_load.ir
	jump		assign_cr.01

assign_rc:
	load		eaq,arg2
	store		eaq,arg1
	return

assign_cr:
	load		eaq,arg2
assign_cr.01:
	store		eaq,arg1,no_update
	reset_eaq
	fld		=0.,du
	fst		arg1+1
	return

assign_dc:
	load		eaq,arg2
	store		deaq,arg1,no_update
	return

assign_cd:
	load		deaq,arg2
	jump		assign_cr.01

assign_cc:
	load		aq,arg2
	store		aq,arg1
	return

assign_e2:
	if_dt		logical,assign_l
	if_dt		char,assign_h
	error		310,op1

assign_l:
	swap		arg1

	unless_dt		logical,logical.p

	load		a,arg1
	store		a,arg2
	return

assign_h:		" Modified 12/27/77 to allow char consts for all arith data types
	dt_jump1		arg1,(assign_ih,assign_rh,assign_dh,assign_ch,assign_lh,assign_hh,assign_th)

assign_ih:
assign_rh:
assign_lh:
assign_th:
	unless_optype	constant,char2.p
	pad_char_const_to_word	op1
	load		a,op1
	store		a,op2
	return

assign_dh:
assign_ch:
	unless_optype	constant,char2.p
	pad_char_const_to_dw	op1
	load		aq,op1
	store		aq,op2
	return


assign_hh:
	emit_eis
	mlr		(pr),(pr),fill(040)
	desc9a		arg2
	desc9a		arg1

	return

logical.p:
	print		338,arg1,op1
	return

char2.p:
	print		337,op1
	return

assign_e1:
	print		309,arg1
	return

assign_t:
	dt_jump1		arg1,(assign_t.normal,assign_t.normal,assign_e1,assign_e1,assign_t.to_logical,assign_t.normal)

assign_t.to_logical:
	load_for_test	tq,arg2
	emit		2
	tze		2,ic
	ldq		131072,du
	store		tq,arg1
	jump		assign_t.return

assign_t.normal:
	unless_one_word_dt	arg1,assign_e1		" trap assignments to incorrect char variables
	load		tq,arg2
	store		tq,arg1

assign_t.return:
	return


add:	func		2

	dt_jump		(add_ii,add_ri,add_di,add_ci,add_ir,add_rr,add_dr,add_cr,add_id,add_rd,add_dd,add_cd,add_ic,add_rc,add_dc,add_cc,add_e2,add_e1,add_tl,add_tl)

add_ii:
	load_top		q
	adq		arg1
	return		q

add_ir:
	swap		arg1

add_ri:
	s_call		cv_load.ir
	fad		arg1
	return		eaq

add_id:
	swap		arg1

add_di:
	s_call		cv_load.id
	dfad		arg1
	return		deaq

add_rr:
	load_top		eaq
	fad		arg1
	return		eaq

add_dd:
	load_top		deaq
	dfad		arg1
	return		deaq

add_rd:
	swap		arg1

add_dr:
	if_eaq		eaq,arg2,add_dr.1

	load		deaq,arg1
	fad		arg2
	return		deaq

add_dr.1:
	dfad		arg1
	return		deaq

add_ic:
	swap		arg1

add_ci:
	s_call		cv_load.ir
	push_temp		cmpx
	jump		add_cr.1

add_rc:
	swap		arg1

add_cr:
	push_temp		cmpx

	if_eaq		eaq,arg2,add_cr.1
	if_eaq		eaq,arg1,add_cr.2

	load		ieaq,arg1
	store		ieaq,op1,no_update
	fld		arg1
	fad		arg2
	in_reg		eaq,op1
	return		op1

add_cr.1:
	fad		arg1
add_cr.11:
	reset_eaq				"so store sees no rounded state
	store		eaq,op1,no_update
	fld		arg1+1
	in_reg		ieaq,op1
	return		op1

add_cr.2:
	fad		arg2
	jump		add_cr.11

add_dc:
	swap		arg1

add_cd:
	push_temp		cmpx

	if_eaq		deaq,arg2,add_cd.1
	if_eaq		eaq,arg1,add_cd.2

	load		ieaq,arg1
	store		ieaq,op1,no_update
	fld		arg1
	dfad		arg2
	in_reg		eaq,op1
	return		op1

add_cd.1:
	fad		arg1
add_cd.11:
	reset_eaq					"so store sees ^ round
	store		eaq,op1,no_update
	fld		arg1+1
	in_reg		ieaq,op1
	return		op1

add_cd.2:
	dfad		arg2
	jump		add_cd.11

add_cc:
	push_temp		cmpx

	if_eaq		eaq,arg2,add_cc.1
	if_eaq		ieaq,arg2,add_cc.2
	if_eaq		eaq,arg1,add_cc.3

	load		ieaq,arg1
	fad		arg2+1
add_cc.01:
	reset_eaq					"set ^rounded
	store		ieaq,op1,no_update
	fld		arg1
	fad		arg2
	in_reg		eaq,op1
	return		op1

add_cc.1:
	fad		arg1
add_cc.11:
	reset_eaq					"set ^rounded
	store		eaq,op1,no_update
	fld		arg1+1
	fad		arg2+1
	in_reg		ieaq,op1
	return		op1

add_cc.2:
	fad		arg1+1
	jump		add_cc.01

add_cc.3:
	fad		arg2
	jump		add_cc.11

add_e1:
	error		309,arg1

add_e2:
	error		310,arg2

add_tl:
	load_top		tq
	dt_jump1		arg1,(add_tl.1,add_e1,add_e1,add_e1,add_e1,add_e1,add_tl.1)

add_tl.1:
	adq		arg1
	return		tq

sub:	func		2

	dt_jump		(sub_ii,sub_ri,sub_di,sub_ci,sub_ir,sub_rr,sub_dr,sub_cr,sub_id,sub_rd,sub_dd,sub_cd,sub_ic,sub_rc,sub_dc,sub_cc,sub_e2,sub_e1,sub_tl,sub_tl)

sub_ii:
	load		q,arg1
	sbq		arg2
	return		q

sub_ir:
	swap		arg1

	s_call		cv_load.ir
	fsb		arg1
	return		eaq

sub_ri:
	if_eaq		q,arg2,sub_ri.1

	if_optype		constant,conv_sub_ri

	use_eaq
	lcq		arg2
	tsx0		pr0|integer_to_real
	fad		arg1
	return		eaq

conv_sub_ri:
	convert_constant	real
	load		eaq,arg2
	emit		1
	fneg
	fad		arg1
	return		eaq

sub_ri.1:
	use_eaq
	tsx0		pr0|integer_to_real
	emit		1
	fneg
	fad		arg1
	return		eaq

sub_id:
	swap		arg1

	s_call		cv_load.id
	dfsb		arg1
	return		deaq

sub_di:
	if_eaq		q,arg2,sub_di.1

	if_optype		constant,conv_sub_di

	use_eaq
	lcq		arg2
	tsx0		pr0|integer_to_double
	dfad		arg1
	return		deaq

conv_sub_di:
	convert_constant	dp
	load		deaq,arg2
	emit		1
	fneg
	dfad		arg1
	return		deaq

sub_di.1:
	use_eaq
	tsx0		pr0|integer_to_double
	emit		1
	fneg
	dfad		arg1
	return		deaq

sub_rr:
	use_ind
	if_eaq		eaq,arg2,sub_rr.1

	load		eaq,arg1
	fsb		arg2
	return		eaq

sub_rr.1:
	emit		1
	fneg
	fad		arg1
	return		eaq

sub_dd:
	use_ind
	if_eaq		deaq,arg2,sub_dd.1

	load		deaq,arg1
	dfsb		arg2
	return		deaq

sub_dd.1:
	emit		1
	fneg
	dfad		arg1
	return		deaq

sub_rd:
	use_ind
	if_eaq		deaq,arg2,sub_rd.1

	load		eaq,arg1
	dfsb		arg2
	return		deaq

sub_rd.1:
	emit		1
	fneg
	fad		arg1
	return		deaq

sub_dr:
	use_ind
	if_eaq		eaq,arg2,sub_dr.1

	load		deaq,arg1
	fsb		arg2
	return		deaq

sub_dr.1:
	emit		1
	fneg
	dfad		arg1
	return		deaq

sub_ic:
	push_temp		cmpx

	swap		arg1

	if_optype		constant,conv_sub_ic

	swap		arg1
	load		q,arg1
	use_eaq
	tsx0		pr0|integer_to_real
	jump		sub_rc.1

conv_sub_ic:
	convert_constant	real
	swap		arg1
	load		eaq,arg1
	jump		sub_rc.1

sub_ci:
	push_temp		cmpx

	swap		arg2

	if_optype		constant,conv_sub_ci

	swap		arg2
	use_eaq
	lcq		arg2
	tsx0		pr0|integer_to_real
	jump		sub_cr.10

conv_sub_ci:
	convert_constant	real

	swap		arg2
	load		eaq,arg2
	jump		sub_cr.1

sub_rc:
	push_temp		cmpx

	use_ind
	if_eaq		eaq,arg1,sub_rc.1
	if_eaq		eaq,arg2,sub_rc.2

	load		ieaq,arg2
	emit		1
	fneg
	store		ieaq,op1,no_update
	fld		arg1
	fsb		arg2
	in_reg		eaq,op1
	return		op1

sub_rc.1:
	fsb		arg2
sub_rc.11:
	reset_eaq					"set ^ rounded
	store		eaq,op1,no_update
	fld		arg2+1
	emit		1
	fneg
	in_reg		ieaq,op1
	return		op1

sub_rc.2:
	emit		1
	fneg
	fad		arg1
	jump		sub_rc.11

sub_cr:
	push_temp		cmpx

	use_ind
	if_eaq		eaq,arg2,sub_cr.1
	if_eaq		eaq,arg1,sub_cr.2

	load		ieaq,arg1
	store		ieaq,op1,no_update
	fld		arg1
	fsb		arg2
	in_reg		eaq,op1
	return		op1

sub_cr.1:
	emit		1
	fneg
sub_cr.10:
	fad		arg1
sub_cr.11:
	reset_eaq					"set ^rounded
	store		eaq,op1,no_update
	fld		arg1+1
	in_reg		ieaq,op1
	return		op1

sub_cr.2:
	fsb		arg2
	jump		sub_cr.11

sub_dc:
	push_temp		cmpx

	use_ind
	if_eaq		deaq,arg1,sub_dc.1
	if_eaq		eaq,arg2,sub_dc.2

	load		ieaq,arg2
	emit		1
	fneg
	store		ieaq,op1,no_update
	dfld		arg1
	fsb		arg2
	in_reg		eaq,op1
	return		op1

sub_dc.1:
	fsb		arg2
sub_dc.11:
	reset_eaq					"set ^rounded
	store		eaq,op1,no_update
	fld		arg2+1
	emit		1
	fneg
	in_reg		ieaq,op1
	return		op1

sub_dc.2:
	emit		1
	fneg
	dfad		arg1
	jump		sub_dc.11

sub_cd:
	push_temp		cmpx

	use_ind
	if_eaq		deaq,arg2,sub_cd.1
	if_eaq		eaq,arg1,sub_cd.2

	load		ieaq,arg1
	store		ieaq,op1,no_update
	fld		arg1
	dfsb		arg2
	in_reg		eaq,op1
	return		op1

sub_cd.1:
	emit		1
	fneg
sub_cd.10:
	fad		arg1
sub_cd.11:
	reset_eaq					"set ^rounded
	store		eaq,op1,no_update
	fld		arg1+1
	in_reg		ieaq,op1
	return		op1

sub_cd.2:
	dfsb		arg2
	jump		sub_cd.11

sub_cc:
	push_temp		cmpx

	use_ind
	if_eaq		eaq,arg2,sub_cc.1
	if_eaq		ieaq,arg2,sub_cc.2
	if_eaq		eaq,arg1,sub_cc.3

	load		ieaq,arg1
	fsb		arg2+1
sub_cc.01:
	reset_eaq					"set ^rounded
	store		ieaq,op1,no_update
	fld		arg1
	fsb		arg2
	in_reg		eaq,op1
	return		op1

sub_cc.1:
	emit		1
	fneg
	fad		arg1
sub_cc.11:
	reset_eaq					"set ^rounded
	store		eaq,op1,no_update
	fld		arg1+1
	fsb		arg2+1
	in_reg		ieaq,op1
	return		op1

sub_cc.2:
	emit		1
	fneg
	fad		arg1+1
	jump		sub_cc.01

sub_cc.3:
	fsb		arg2
	jump		sub_cc.11

sub_e1:
	error		309,arg1

sub_e2:
	error		310,arg2

sub_tl:
	unless_dt		(int,typeless),sub_e2
	dt_jump1		arg1,(sub_tl.1,sub_e1,sub_e1,sub_e1,sub_e1,sub_e1,sub_tl.1)
	load		tq,arg1

sub_tl.1:
	sbq		arg2
	return		tq

mult:	func		2

	dt_jump		(mult_ii,mult_ri,mult_di,mult_ci,mult_ir,mult_rr,mult_dr,mult_cr,mult_id,mult_rd,mult_dd,mult_cd,mult_ic,mult_rc,mult_dc,mult_cc,mult_e2,mult_e1,mult_tl,mult_tl)

mult_ii:
	use_eaq
	load_top		q
	mpy		arg1

	unless_check_multiply	mult_ii.1
	tsx0		pr0|mpy_overflow_check

mult_ii.1:
	return		q

mult_ir:
	swap		arg1

mult_ri:
	s_call		cv_load.ir
	fmp		arg1
	return		eaq

mult_id:
	swap		arg1

mult_di:
	s_call		cv_load.id
	dfmp		arg1
	return		deaq

mult_rr:
	load_top		eaq
	fmp		arg1
	return		eaq

mult_dd:
	load_top		deaq
	dfmp		arg1
	return		deaq

mult_rd:
	swap		arg1

mult_dr:
	if_eaq		eaq,arg2,mult_dr.1

	load		deaq,arg1
	fmp		arg2
	return		deaq

mult_dr.1:
	dfmp		arg1
	return		deaq

mult_ic:
	swap		arg1

mult_ci:
	push_temp		cmpx

	swap		arg2

	if_optype		constant,conv_mult_ci

	swap		arg2
	push_temp		real

	load		q,arg2
	use_eaq
	tsx0		pr0|integer_to_real

	swap		arg2
	store		eaq,arg2,no_update
	pop		op1
	jump		mult_cr.1

conv_mult_ci:
	convert_constant	real

	swap		arg2
	load		eaq,arg2
	jump		mult_cr.1

mult_rc:
	swap		arg1

mult_cr:
	push_temp		cmpx

	if_eaq		eaq,arg2,mult_cr.1
	if_eaq		eaq,arg1,mult_cr.2

	load		ieaq,arg1
	fmp		arg2
	reset_eaq					"set ^rounded
	store		ieaq,op1,no_update
	fld		arg1
	fmp		arg2
	in_reg		eaq,op1
	return		op1

mult_cr.1:
	use_eaq
	fmp		arg1
mult_cr.11:
	store		eaq,op1,no_update
	fld		arg2
	fmp		arg1+1
	in_reg		ieaq,op1
	return		op1

mult_cr.2:
	reset_eaq					"set ^rounded (operand needn't be saved)
	fmp		arg2
	jump		mult_cr.11

mult_dc:
	swap		arg1

mult_cd:
	push_temp		cmpx

	if_eaq		deaq,arg2,mult_cd.1
	if_eaq		eaq,arg1,mult_cd.2

	load		ieaq,arg1
	dfmp		arg2
	reset_eaq					"set ^rounded
	store		ieaq,op1,no_update
	fld		arg1
	dfmp		arg2
	in_reg		eaq,op1
	return		op1

mult_cd.1:
	use_eaq
	fmp		arg1
mult_cd.11:
	store		eaq,op1,no_update
	dfld		arg2
	fmp		arg1+1
	in_reg		ieaq,op1
	return		op1

mult_cd.2:
	reset_eaq					"set ^rounded (operand needn't be saved)
	dfmp		arg2
	jump		mult_cd.11

mult_cc:
	load		aq,arg1
	load_pr		pr2,arg2
	tsx0		pr0|complex_multiply
	ldaq		pr6|complex
	free_regs
	return		aq


mult_tl:
	load_top		tq
	dt_jump1		arg1,(mult_tl.1,mult_e1,mult_e1,mult_e1,mult_e1,mult_e1,mult_tl.1)

mult_tl.1:
	use_eaq
	mpy		arg1

	unless_check_multiply	mult_tl.2
	tsx0		pr0|mpy_overflow_check

mult_tl.2:
	return		tq

mult_e1:
	error		309,arg1

mult_e2:
	error		310,arg2

div:	func		2

	dt_jump		(div_ii,div_ri,div_di,div_ci,div_ir,div_rr,div_dr,div_cr,div_id,div_rd,div_dd,div_cd,div_ic,div_rc,div_dc,div_cc,div_e2,div_e1,div_tl,div_tl)

div_ii:
	use_eaq
	load		q,arg1
	div		arg2
	return		q

div_ir:
	swap		arg1

	s_call		cv_load.ir
	fdv		arg1
	return		eaq

div_ri:
	s_call		cv_load.ir
	fdi		arg1
	return		eaq

div_id:
	swap		arg1

	s_call		cv_load.id
	dfdv		arg1
	return		deaq

div_di:
	s_call		cv_load.id
	dfdi		arg1
	return		deaq

div_rr:
	if_eaq		eaq,arg2,div_rr.1

	load		eaq,arg1
	fdv		arg2
	return		eaq

div_rr.1:
	fdi		arg1
	return		eaq

div_dd:
	if_eaq		deaq,arg2,div_dd.1

	load		deaq,arg1
	dfdv		arg2
	return		deaq

div_dd.1:
	dfdi		arg1
	return		deaq

div_rd:
	load		eaq,arg1
	dfdv		arg2
	return		deaq

div_dr:
	load		eaq,arg2
	dfdi		arg1
	return		deaq

div_ic:
	swap		arg1

	if_optype		constant,conv_div_ic

	swap		arg1
	load		q,arg1
	use_eaq
	tsx0		pr0|integer_to_real
	fstr		sp|double_temp
	lda		sp|double_temp
	jump		div_rc.01

conv_div_ic:
	convert_constant	real
	swap		arg1
	jump		div_rc

div_ci:
	push_temp		cmpx

	swap		arg2

	if_optype		constant,conv_div_ci

	swap		arg2
	push_temp		real

	load		q,arg2
	use_eaq
	tsx0		pr0|integer_to_real

	swap		arg2
	store		eaq,arg2,no_update
	pop		op1
	jump		div_cr.1

conv_div_ci:
	convert_constant	real

	swap		arg2
	load		eaq,arg2
	jump		div_cr.1

div_rc:
	load		a,arg1
div_rc.01:
	ldq		=0.,du
	load_pr		pr2,arg2
	use_eaq
	tsx0		pr0|complex_divide
	ldaq		pr6|complex
	free_regs
	return		aq

div_cr:
	push_temp		cmpx

	if_eaq		eaq,arg2,div_cr.1
	if_eaq		eaq,arg1,div_cr.2

	load		ieaq,arg1
	reset_eaq					"set ^ rounded (operand not saved)
	fdv		arg2
div_cr.01:
	store		ieaq,op1,no_update
	fld		arg1
	fdv		arg2
	in_reg		eaq,op1
	return		op1

div_cr.1:
	use_eaq
	fdi		arg1+1
	jump		div_cr.01

div_cr.2:
	fdv		arg2
	reset_eaq					"set ^rounded
	store		eaq,op1,no_update
	fld		arg1+1
	fdv		arg2
	in_reg		ieaq,op1
	return		op1

div_dc:
	swap		arg1
	call		round_dp_to_real
	swap		arg1
	jump		div_rc

div_cd:
	push_temp		cmpx

	if_eaq		deaq,arg2,div_cd.1
	if_eaq		eaq,arg1,div_cd.2

	load		ieaq,arg1
	reset_eaq
	dfdv		arg2
div_cd.01:
	store		ieaq,op1,no_update
	fld		arg1
	dfdv		arg2
	in_reg		eaq,op1
	return		op1

div_cd.1:
	use_eaq
	fdi		arg1+1
	jump		div_cd.01

div_cd.2:
	dfdv		arg2
	reset_eaq
	store		eaq,op1,no_update
	fld		arg1+1
	dfdv		arg2
	in_reg		ieaq,op1
	return		op1

div_cc:
	load		aq,arg1
	load_pr		pr2,arg2
	tsx0		pr0|complex_divide
	ldaq		pr6|complex
	free_regs
	return		aq

div_tl:
	unless_dt		(int,typeless),div_e2
	dt_jump1		arg1,(div_tl.1,div_e1,div_e1,div_e1,div_e1,div_e1,div_tl.1)
	load		tq,arg1

div_tl.1:
	use_eaq
	div		arg2
	return		tq

div_e1:
	error		309,arg1

div_e2:
	error		310,arg2

cv_load.ir:
	if_optype		constant,conv_ir

	load		q,op1
	use_eaq
	tsx0		pr0|integer_to_real
	s_return

conv_ir:
	convert_constant	real
	load		eaq,op1
	s_return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

cv_load.ri:
	if_optype		constant,conv_ri
	load		eaq,op1
	round		eaq
	use_eaq
	tsx0		pr0|real_to_integer
	s_return

conv_ri:
	convert_constant	int
	load		q,op1
	s_return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

cv_load.id:
	if_optype		constant,conv_id

	load		q,op1
	use_eaq
	tsx0		pr0|integer_to_double
	s_return

conv_id:
	convert_constant	dp
	load		deaq,op1
	s_return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

cv_load.di:
	if_optype		constant,conv_di
	load		deaq,op1
	round		deaq
	use_eaq
	tsx0		pr0|double_to_integer
	s_return

conv_di:
	convert_constant	int
	load		q,op1
	s_return


"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

"	This function expects a dp operand on the top of the stack. It "converts" it to single
"	precision by using convert_constant or indicating its value is now in the eaq. The
"	value in the eaq is not explicitly stored into a sp temp because it is assumed that
"	the next use of the eaq will force the store.

round_dp_to_real:
	func		1

	if_optype		constant,round_dp_const
	push_temp		real
	load		deaq,op2
	return		eaq

round_dp_const:
	convert_constant	real
	return		op1

exponentiation:
	func		2

	dt_jump		(exponentiation_ii,exponentiation_ri,exponentiation_di,exponentiation_ci,exponentiation_ir,exponentiation_rr,exponentiation_dr,exponentiation_cr,exponentiation_id,exponentiation_rd,exponentiation_dd,exponentiation_cd,exponentiation_ic,exponentiation_rc,exponentiation_dc,exponentiation_cc,exponentiation_e2,exponentiation_e1,exponentiation_e2,exponentiation_e1)

exponentiation_ii:
	push_temp		32

	load		q,arg1
	load_pr		pr1,arg2
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr3,pr4,pr5,pr7)
	tsp3		pr0|int_p_int
	free_regs
	return		q

exponentiation_ir:
	push_temp		32

	swap		arg1

	if_optype		constant,conv_exponentiation_ir

	swap		arg1
	load		q,arg1
	use_eaq
	tsx0		pr0|integer_to_real
	jump		exponentiation_rr.02

conv_exponentiation_ir:
	convert_constant	real

	swap		arg1
	jump		exponentiation_rr.01

exponentiation_ri:
	push_temp		32

	load		eaq,arg1
	load_pr		pr1,arg2
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr3,pr4,pr5,pr7)
	tsp3		pr0|real_p_int
	free_regs
	return		eaq

exponentiation_id:
	push_temp		32

	swap		arg1

	if_optype		constant,conv_exponentiation_id

	swap		arg1
	load		q,arg1
	use_eaq
	tsx0		pr0|integer_to_double
	jump		exponentiation_dd.02

conv_exponentiation_id:
	convert_constant	dp

	swap		arg1
	jump		exponentiation_dd.01

exponentiation_di:
	push_temp		32

	load		deaq,arg1
	load_pr		pr1,arg2
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr3,pr4,pr5,pr7)
	tsp3		pr0|dbl_p_int
	free_regs
	return		deaq

exponentiation_rr:
	push_temp		32

exponentiation_rr.01:
	load		eaq,arg1
exponentiation_rr.02:
	load_pr		pr1,arg2
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr3,pr4,pr5,pr7)
	tsp3		pr0|real_p_real
	free_regs
	return		eaq

exponentiation_dd:
	push_temp		32

exponentiation_dd.01:
	load		deaq,arg1
exponentiation_dd.02:
	load_pr		pr1,arg2
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr3,pr4,pr5,pr7)
	tsp3		pr0|dbl_p_dbl
	free_regs
	return		deaq

exponentiation_rd:
	push_temp		32

	load		eaq,arg1
	jump		exponentiation_dd.02

exponentiation_dr:
	push_temp		32

	load		deaq,arg1
	load_pr		pr1,arg2
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr3,pr4,pr5,pr7)
	tsp3		pr0|dbl_p_real
	free_regs
	return		deaq

exponentiation_ic:
	push_temp		32
	load_pr		pr2,op1
	swap		arg1

	if_optype		constant,conv_exponentiation_ic

	swap		arg1
	push_temp		cmpx
	load		q,arg1
	use_eaq
	tsx0		pr0|integer_to_real
	store		eaq,op1,no_update
	fld		=0.,du
	fst		op1+1
	ldaq		op1
	jump		exponentiation_cc.01

conv_exponentiation_ic:
	convert_constant	cmpx

	swap		arg1
	load		aq,arg1
	jump		exponentiation_cc.01

exponentiation_ci:
	push_temp		32
	load_pr		pr2,op1
	push_temp		cmpx

	swap		arg2

	if_optype		constant,conv_exponentiation_ci

	swap		arg2
	load		q,arg2
	use_eaq
	tsx0		pr0|integer_to_real
	store		eaq,op1,no_update
	fld		=0.,du
	fst		op1+1
	jump		exponentiation_cr.01

conv_exponentiation_ci:
	convert_constant	cmpx

	swap		arg2
	load		aq,arg2
	staq		op1
	jump		exponentiation_cr.01

exponentiation_dc:
	swap		arg1
	call		round_dp_to_real
	swap		arg1

exponentiation_rc:
	push_temp		32
	load_pr		pr2,op1

	load		a,arg1
	use_eaq
	ldq		=0.,du
	jump		exponentiation_cc.01

exponentiation_cd:
	call		round_dp_to_real

exponentiation_cr:
	push_temp		32
	load_pr		pr2,op1
	push_temp		cmpx

	load		a,arg2
	use_eaq
	ldq		=0.,du
	staq		op1
exponentiation_cr.01:
	ldaq		arg1
	load_pr		pr1,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr3,pr4,pr5,pr7)
	tsp3		pr0|cmpx_p_cmpx
	ldaq		pr6|temp_pt
	free_regs
	return		aq

exponentiation_cc:
	push_temp		32
	load_pr		pr2,op1
	load		aq,arg1
exponentiation_cc.01:
	load_pr		pr1,arg2
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr3,pr4,pr5,pr7)
	tsp3		pr0|cmpx_p_cmpx
	ldaq		pr6|temp_pt
	free_regs
	return		aq

exponentiation_e1:
	error		309,arg1

exponentiation_e2:
	error		310,arg2

negate:	func		1		

	if_dt		int,negate_i
	if_dt		real,negate_r
	if_dt		dp,negate_d
	if_dt		cmpx,negate_c

	error		315,op1

negate_i:
	use_eaq
	lcq		op1
	return		q

negate_r:
	load		eaq,op1
	emit		1
	fneg
	return		eaq

negate_d:
	load		deaq,op1
	emit		1
	fneg
	return		deaq

negate_c:
	push_temp		cmpx

	use_ind
	if_eaq		eaq,op2,negate_c.1

	load		ieaq,op2
	emit		1
	fneg
	store		ieaq,op1,no_update
	load		eaq,op2
	emit		1
	fneg
	in_reg		eaq,op1
	return		op1

negate_c.1:
	emit		1
	fneg
	store		eaq,op1,no_update
	load		ieaq,op2
	emit		1
	fneg
	in_reg		ieaq,op1
	return		op1

"push_var used rather than push_temp in this block to permit non-standard
"construction of do-loop in the extended range of an extended range do-loop.
do:	proc		4

	swap		arg2
	copy		arg1
	call		convert_to_cv_type
	swap		arg2

	swap		arg3
	copy		arg1
	call		convert_to_cv_type
	swap		arg3

	copy		arg1
	call		convert_to_cv_type

	push_label			" arg5 is label for top of loop
	push_label			" arg6 is label for end of loop

	swap		arg1

	if_dt		int,do_i
	if_dt		real,do_r
	jump		do_d

do_i:
	swap		arg1
	swap		arg4		" get incre on top of stack
	unless_ansi77	do_i.no_save_incre
	if_optype		constant,do_i.no_save_incre
	load		q,op1
	push_variable	int
	store		q,op1
	swap		op2
	pop		op1		" replace incre with variable

do_i.no_save_incre:
	swap		arg4		" restore correct order

	load		q,arg2
	store		q,arg1

	use_eaq

	swap		arg4
	if_optype		constant,do_i_constant
	swap		arg4

	ldq		arg3
	sbq		arg2
	div		arg4
	adq		1,dl

	push_variable	int
	store		q,arg7

	unless_ansi77	do_i.one_trip
	tmoz		arg6

do_i.one_trip:
	force_even		" optimize even address for loop
	label		arg5

	scan		continue,next

	shorten_stack

	load		q,arg4
	asq		arg1

	use_eaq

	lcq		1,dl
	asq		arg7
	tpnz		arg5

	label		arg6

	return

do_i_constant:
	swap		arg4

"	If final (to) is not a constant, it is saved before the label macro flushes it

	swap		arg3
	if_optype		constant,to_is_constant	" no need to save, it is a constant

	load		q,op1			" load value and put in temp
	pop		op1			" will replace expre with temp
	push_variable	int
	store		q,op1

to_is_constant:
	swap		arg3			" restore stack to correct order

	unless_ansi77	do_i_constant.one_trip

	load		q,arg2
	compare		q,arg3

	if_negative	arg4,do_i.zero_trip.negative
	tpnz		arg6
	jump		do_i_constant.one_trip

do_i.zero_trip.negative:
	tmi		arg6

do_i_constant.one_trip:
	force_even		" optimize even address for loop
	label		arg5

	scan		continue,next

	shorten_stack

	load		q,arg1

	use_eaq

	if_negative	arg4,do_i_negative

	push_builtin	one
	if		arg4,=,op1,do_i_1

	adq		arg4
	store		q,arg1
	use_ind
	cmpq		arg3
	tmoz		arg5

	label		arg6

	return

do_i_1:

	aos		arg1
	cmpq		arg3
	tmi		arg5

	label		arg6

	return

do_i_negative:
	adq		arg4
	store		q,arg1
	use_ind
	cmpq		arg3
	tpl		arg5

	label		arg6

	return

do_r:
	swap		arg1
	swap		arg4		" get incre on top of stack
	unless_ansi77	do_r.no_save_incre
	if_optype		constant,do_r.no_save_incre
	load		eaq,op1
	push_variable	real
	store		eaq,op1
	swap		op2
	pop		op1		" replace incre with variable

do_r.no_save_incre:
	swap		arg4		" restore correct order

	load		eaq,arg2
	store		eaq,arg1

	use_eaq

	fld		arg3
	fsb		arg2
	fdv		arg4		" subtracting -1 is the same as adding
	fsb		=-1.0,du		" +1, but -1 is the same in hex
	tsx0		pr0|real_to_integer

	push_variable	int
	store		q,arg7

	unless_ansi77	do_r.one_trip
	tmoz		arg6

do_r.one_trip:
	force_even		" optimize even address for loop
	label		arg5

	scan		continue,next

	shorten_stack

	load		eaq,arg1
	use_eaq
	fad		arg4
	store		eaq,arg1,no_update

	lcq		1,dl
	asq		arg7
	tpnz		arg5

	label		arg6

	return

do_d:
	swap		arg1
	swap		arg4		" get incre on top of stack
	unless_ansi77	do_d.no_save_incre
	if_optype		constant,do_d.no_save_incre
	load		deaq,op1
	push_variable	dp
	store		deaq,op1
	swap		op2
	pop		op1		" replace incre with variable

do_d.no_save_incre:
	swap		arg4		" restore correct order

	load		deaq,arg2
	store		deaq,arg1

	use_eaq

	dfld		arg3
	dfsb		arg2
	dfdv		arg4		" subtracting -1 is the same as adding
	fsb		=-1.0,du		" +1, but -1 is the same in hex
	tsx0		pr0|double_to_integer

	push_variable	int
	store		q,arg7

	unless_ansi77	do_d.one_trip
	tmoz		arg6

do_d.one_trip:
	force_even		" optimize even address for loop
	label		arg5

	scan		continue,next

	shorten_stack

	load		deaq,arg1
	use_eaq
	dfad		arg4
	store		deaq,arg1,no_update

	lcq		1,dl
	asq		arg7
	tpnz		arg5

	label		arg6

	return

convert_to_cv_type:
	func		2

	dt_jump		(ccv_ii,ccv_ri,ccv_di,ccv_ci,ccv_ir,ccv_rr,ccv_dr,ccv_cr,ccv_id,ccv_rd,ccv_dd,ccv_cd,ccv_ic,ccv_rc,ccv_dc,ccv_cc,ccv_e2,ccv_e1,ccv_e2,ccv_e1)

ccv_ii:
	return		arg1

ccv_ir:
	swap		arg1

	s_call		cv_load.ir
	return		eaq

ccv_ri:
	swap		arg1

	s_call		cv_load.ri
	return		q

ccv_id:
	swap		arg1

	s_call		cv_load.id
	return		deaq

ccv_di:
	swap		arg1

	s_call		cv_load.di
	return		q

ccv_rr:
	return		arg1

ccv_dd:
	return		arg1

ccv_rd:
	load		eaq,arg1
	return		deaq

ccv_dr:
	load		deaq,arg1
	return		eaq

ccv_ic:
	error		316,op1

ccv_ci:
	load		eaq,arg1
	round		eaq
	use_eaq
	tsx0		pr0|real_to_integer
	return		q

ccv_rc:
	error		316,op1

ccv_cr:
	load		eaq,arg1
	return		eaq

ccv_dc:
	error		316,op1

ccv_cd:
	load		eaq,arg1
	return		deaq

ccv_cc:
	print		316,op1
	return

ccv_e1:
	print		317,arg1
	return

ccv_e2:
	print		318,op1
	return

builtin:	func		2,abort_list_op		last assigned number = 93
"
"	The builtin code depends on 5 indexed operators. Four uses are here. The other
"	appears in the cv_bif_to_external code. Remember to change ALL five.
"

	push_bif_index	arg1
	push_count_indexed	arg3,(1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,2,2,2,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,-1,1,1,1,1,1,1,1,1,1,2,1,2,2,2,2,1,1,1,1,1,1,1,1,1,1,2,-1,1,1,3,2,2,2,2,-1,-1)

	if		arg4,<,0,builtin_var
	if		arg2,=,op1,builtin2

	print		319,arg1

	jump		bu_abort_list

builtin2:
	decrement		arg2,1
	scan		bu_abort_list,next

	jump_indexed	arg3,(builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.tl,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.char_ok,builtin2.char_ok,builtin2.char_ok,builtin2.char_ok,builtin2.char_ok,builtin2.char_ok,builtin2.char_ok,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.nc,builtin2.one_word,builtin2.one_word,builtin2.one_word,builtin2.one_word,builtin2.one_word,builtin2.one_word,builtin2.one_word,builtin2.one_word,builtin2.one_word,builtin2.one_word)

builtin2.char_ok:
	unless_dt		(int,real,dp,cmpx,char),wrong_type.p
	jump		builtin2.join

builtin2.one_word:
	unless_one_word_dt	op1,bu_dt1.p
	jump		builtin2.join

builtin2.tl:
	unless_dt		(int,real,dp,cmpx,typeless),wrong_type.p
	jump		builtin2.join

builtin2.nc:
	unless_dt		(int,real,dp,cmpx),wrong_type.p

builtin2.join:
	unless		arg2,=,0,builtin2

builtin3:
	jump_indexed	arg3,(abs,iabs,dabs,cabs,alog,dlog,clog,alog10,dlog10,atan,datan,atan2,datan2,cos,dcos,ccos,dim,idim,ddim,exp,dexp,cexp,max,amax0,amax1,max0,max1,dmax1,min,amin0,amin1,min0,min1,dmin1,mod,amod,dmod,sign,isign,dsign,sin,dsin,csin,sqrt,dsqrt,csqrt,tanh,int_builtin,aint,idint,float,ifix,sngl,real_builtin,aimag,dble,cmplx,conjg,tan,dtan,asin,dasin,acos,dacos,char_builtin,ichar,index,len,lge,lgt,lle,llt,cosh,sinh,dcosh,dsinh,dtanh,dint,anint,dnint,nint,idnint,dprod,and.tl,bool.tl,compl.tl,fld.tl,ilr.tl,ils.tl,irl.tl,irs.tl,or.tl,xor.tl)

builtin_var:
	jump_indexed	arg3,(builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.1,builtin_var.2,builtin_var.2,builtin_var.2,builtin_var.2,builtin_var.2,builtin_var.2,builtin_var.2,builtin_var.2,builtin_var.2,builtin_var.2)


builtin_var.1:
	scan		bu_abort_list,(next,builtin3)

	" NOTE: There are no non typeless builtins which take a variable
	" number of arguments and which also take character mode arguments.

	unless_dt		(int,real,dp,cmpx),wrong_type.p
	jump		builtin_var.1

builtin_var.2:
	scan		bu_abort_list,(next,builtin3)
	unless_one_word_dt	op1,bu_dt1.p
	jump		builtin_var.2

bu_ret_q:
	scan		continue,(continue,next)

	return		q

bu_ret_eaq:
	scan		continue,(continue,next)

	return		eaq

bu_ret_deaq:
	scan		continue,(continue,next)

	return		deaq

bu_ret_aq:
	scan		continue,(continue,next)

	return		aq

bu_ret_tq:
	scan		continue,(continue,next)

	return		tq

bu_ret_trc:
	scan		continue,(continue,next)

	return		trc

bu_ret_tnc:
	scan		continue,(continue,next)

	return		tnc

bu_ret_op1:
	scan		continue,(continue,next)

	return		op1

mm_ret_q:
	push_temp		int
	in_reg		q,op1
	use_ind
	return		op1

mm_ret_eaq:
	push_temp		real
	in_reg		eaq,op1
	use_ind
	return		op1

mm_ret_deaq:
	push_temp		dp
	in_reg		deaq,op1
	use_ind
	return		op1

mm_ret_tq:
	push_temp		typeless
	in_reg		tq,op1
	return		op1

abort_list_op:
	proc		0

bu_abort_list:
	scan		continue,(continue,next)

	error

wrong_number.p:
	print		319,arg1

	error

wrong_type.p:
	print		320,arg1,op1

	jump		bu_abort_list

wrong_char_length.p:
	print		359,op2

	jump		bu_abort_list

abs:						" builtin 01
	if_dt		int,iabs.1
	if_dt		real,abs.1
	if_dt		dp,dabs.1
	jump		cabs.1

iabs:						" builtin 02
	unless_dt		int,iabs.p
iabs.1:
	load_for_test	q,arg5
	tpl		3,ic
	erq		pr0|all_ones
	adq		1,dl
	jump		bu_ret_q

abs.1:
	load_for_test	eaq,arg5
	tpl		2,ic
	emit		1
	fneg
	jump		bu_ret_eaq

dabs:						" builtin 03
	unless_dt		dp,dabs.p
dabs.1:
	load_for_test	deaq,arg5
	tpl		2,ic
	emit		1
	fneg
	jump		bu_ret_deaq

cabs:						" builtin 04
	unless_dt		cmpx,cabs.p
cabs.1:
	load		aq,arg5
	use_eaq
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|cabs_
	fld		pr6|temp_pt
	free_regs
	jump		bu_ret_eaq

iabs.p:
	jump		bu_dt5.p

dabs.p:
	jump		bu_dt5.p

cabs.p:
	jump		bu_dt5.p

alog:						" builtin 05
	if_dt		int,alog_i
	if_dt		real,alog.1
	if_dt		dp,dlog.1
	jump		clog.1

alog.1:
	load		eaq,arg5
	jump		alog.2

alog_i:
	s_call		cv_load.ir

alog.2:
	use_eaq
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|log_
	free_regs
	jump		bu_ret_eaq

dlog:						" builtin 06
	unless_dt		dp,dlog.p
dlog.1:
	load		deaq,arg5
	use_eaq
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|dlog_
	free_regs
	jump		bu_ret_deaq

clog:						" builtin 07
	unless_dt		cmpx,clog.p
clog.1:
	load		aq,arg5
	use_eaq
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|clog_
	ldaq		pr6|temp_pt
	free_regs
	jump		bu_ret_aq

dlog.p:
	jump		bu_dt5.p

clog.p:
	jump		bu_dt5.p

alog10:						" builtin 08
	if_dt		int,alog10_i
	if_dt		real,alog10.1
	if_dt		dp,dlog10.1
	jump		alog10.p

alog10.1:
	load		eaq,arg5
	jump		alog10.2

alog10_i:
	s_call		cv_load.ir

alog10.2:
	use_eaq
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|alog10_
	free_regs
	jump		bu_ret_eaq

dlog10:						" builtin 09
	unless_dt		dp,dlog10.p
dlog10.1:
	load		deaq,arg5
	use_eaq
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|dlog10_
	free_regs
	jump		bu_ret_deaq

alog10.p:
	jump		bu_dt5.p

dlog10.p:
	jump		bu_dt5.p

atan:						" builtin 10
	if_dt		int,atan_i
	if_dt		real,atan.1
	if_dt		dp,datan.1
	jump		atan.p

atan.1:
	load		eaq,arg5
	jump		atan.2

atan_i:
	s_call		cv_load.ir

atan.2:
	use_eaq
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|atan_
	free_regs
	jump		bu_ret_eaq

datan:						" builtin 11
	unless_dt		dp,datan.p
datan.1:
	load		deaq,arg5
	use_eaq
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|datan_
	free_regs
	jump		bu_ret_deaq

atan.p:
	jump		bu_dt5.p

datan.p:
	jump		bu_dt5.p

atan2:						" builtin 12
	dt_jump		(atan2_ii,atan2_ri,atan2_di,atan2_ci,atan2_ir,atan2_rr,atan2_dr,atan2_cr,atan2_id,atan2_rd,atan2_dd,atan2_cd,atan2_ic,atan2_rc,atan2_dc,atan2_cc,atan2_e2,atan2_e1,atan2_e2,atan2_e1)

atan2_ii:
	s_call		builtin_2args_ii
	jump		atan2.1

atan2_ir:
	s_call		builtin_2args_ir
	jump		atan2.1

atan2_ri:
	s_call		builtin_2args_ri
	jump		atan2.1

atan2_id:
	s_call		builtin_2args_id
	jump		datan2.1

atan2_di:
	s_call		builtin_2args_di
	jump		datan2.1

atan2_rr:
	jump		atan2.1

atan2_dd:
	jump		datan2.1

atan2_rd:
	load		eaq,arg5
	use_eaq
	push_temp		32
	load_pr		pr2,op1
	load_pr		pr1,arg6
	jump		datan2.2

atan2_dr:
	push_temp		dp
	load		eaq,arg6
	store		deaq,op1,no_update
	swap		arg6
	pop		op1
	jump		datan2.1

atan2_ic:
	jump		bu_dt6.p

atan2_ci:
	jump		bu_dt5.p

atan2_rc:
	jump		bu_dt6.p

atan2_cr:
	jump		bu_dt5.p

atan2_dc:
	jump		bu_dt6.p

atan2_cd:
	jump		bu_dt5.p

atan2_cc:
	jump		bu_dt5.p

atan2_e1:
	jump		bu_dt5.p

atan2_e2:
	jump		bu_dt6.p

atan2.1:
	load		eaq,arg5
	use_eaq
	push_temp		32
	load_pr		pr2,op1
	load_pr		pr1,arg6
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr3,pr4,pr5,pr7)
	tsp3		pr0|atan2_
	free_regs
	jump		bu_ret_eaq

datan2:						" builtin 13
	swap		arg5
	unless_dt		dp,atan2.p
	swap		arg5
	unless_dt		dp,atan2_ee

datan2.1:
	load		deaq,arg5
	use_eaq
	push_temp		32
	load_pr		pr2,op1
	load_pr		pr1,arg6
datan2.2:
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr3,pr4,pr5,pr7)
	tsp3		pr0|datan2_
	free_regs
	jump		bu_ret_deaq

atan2.p:
atan2_ee:
	jump		bu_dt6.p

cos:						" builtin 14
	if_dt		int,cos_i
	if_dt		real,cos.1
	if_dt		dp,dcos.1
	jump		ccos.1

cos.1:
	load		eaq,arg5
	jump		cos.2

cos_i:
	s_call		cv_load.ir

cos.2:
	use_eaq
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|cos_
	free_regs
	jump		bu_ret_eaq

dcos:						" builtin 15
	unless_dt		dp,dcos.p
dcos.1:
	load		deaq,arg5
	use_eaq
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|dcos_
	free_regs
	jump		bu_ret_deaq

ccos:						" builtin 16
	unless_dt		cmpx,ccos.p
ccos.1:
	load		aq,arg5
	use_eaq
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|ccos_
	ldaq		pr6|temp_pt
	free_regs
	jump		bu_ret_aq

dcos.p:
	jump		bu_dt5.p

ccos.p:
	jump		bu_dt5.p

dim:						" builtin 17
	dt_jump		(dim_ii,dim_ri,dim_di,dim_ci,dim_ir,dim_rr,dim_dr,dim_cr,dim_id,dim_rd,dim_dd,dim_cd,dim_ic,dim_rc,dim_dc,dim_cc,dim_e2,dim_e1,dim_e2,dim_e1)

idim:						" builtin 18
	swap		arg5
	unless_dt		int,idim.p
	swap		arg5
	unless_dt		int,idim.p

dim_ii:
	push_temp		int

	load		q,arg5
	use_eaq
	make_addressable	arg5,arg6
	cmpq		arg6
	tmi		2,ic
	ldq		arg6
	stq		op1
	ldq		arg5
	sbq		op1
	jump		bu_ret_q

dim_ir:
	s_call		builtin_2args_ir
	jump		dim.1

dim_ri:
	s_call		builtin_2args_ri
	jump		dim.1

dim_id:
	s_call		builtin_2args_id
	jump		ddim.1

dim_di:
	s_call		builtin_2args_di
	jump		ddim.1

dim_rr:
	jump		dim.1

dim_dd:
	jump		ddim.1

dim_rd:
	jump		rddim.1

dim_dr:
	jump		drdim.1

dim_ic:
	jump		bu_dt6.p

dim_ci:
	jump		bu_dt5.p

dim_rc:
	jump		bu_dt6.p

dim_cr:
	jump		bu_dt5.p

dim_dc:
	jump		bu_dt6.p

dim_cd:
	jump		bu_dt5.p

dim_cc:
	jump		bu_dt5.p

dim_e1:
	jump		bu_dt5.p

dim_e2:
	jump		bu_dt6.p

dim.1:
	load		eaq,arg5
	use_eaq
	make_addressable	arg5,arg6
	round		eaq
	fcmp		arg6
	tmi		2,ic
	fld		arg6
	emit		1
	fneg
	fad		arg5
	jump		bu_ret_eaq

ddim:						" builtin 19
	swap		arg5
	unless_dt		dp,ddim.p
	swap		arg5
	unless_dt		dp,ddim.p

ddim.1:
	load		deaq,arg5
	use_eaq
	make_addressable	arg5,arg6
	round		deaq
	dfcmp		arg6
	tmi		2,ic
	dfld		arg6
	emit		1
	fneg
	dfad		arg5
	jump		bu_ret_deaq

rddim.1:
	load		eaq,arg5
	use_eaq
	make_addressable	arg5,arg6
	round		deaq
	dfcmp		arg6
	tmi		2,ic
	dfld		arg6
	emit		1
	fneg
	fad		arg5
	jump		bu_ret_deaq

drdim.1:
	load		deaq,arg5
	use_eaq
	make_addressable	arg5,arg6
	fcmp		arg6
	tmi		2,ic
	fld		arg6
	emit		1
	fneg
	dfad		arg5
	jump		bu_ret_deaq

idim.p:
ddim.p:
	jump		bu_dt6.p

exp:						" builtin 20
	if_dt		int,exp_i
	if_dt		real,exp.1
	if_dt		dp,dexp.1
	jump		cexp.1

exp.1:
	load		eaq,arg5
	jump		exp.2

exp_i:
	s_call		cv_load.ir

exp.2:
	use_eaq
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|exp_
	free_regs
	jump		bu_ret_eaq

dexp:						" builtin 21
	unless_dt		dp,dexp.p

dexp.1:
	load		deaq,arg5
	use_eaq
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|dexp_
	free_regs
	jump		bu_ret_deaq

cexp:						" builtin 22
	unless_dt		cmpx,cexp.p

cexp.1:
	load		aq,arg5
	use_eaq
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|cexp_
	ldaq		pr6|temp_pt
	free_regs
	jump		bu_ret_aq

dexp.p:
	jump		bu_dt5.p

cexp.p:
	jump		bu_dt5.p

max:						" builtin 23
	unless		arg2,>,1,wrong_number.p
	dt_jump		(max_ii,max_ri,max_di,max_ci,max_ir,max_rr,max_dr,max_cr,max_id,max_rd,max_dd,max_cd,max_ic,max_rc,max_dc,max_cc,max_e2,max_e1,max_e2,max_e1)

max_ii:
	jump		g.max0

max_ir:
	s_call		builtin_2args_ir
	jump		g.amax1

max_ri:
	s_call		builtin_2args_ri
	jump		g.amax1

max_id:
	s_call		builtin_2args_id
	jump		g.dmax1

max_di:
	s_call		builtin_2args_di
	jump		g.dmax1

max_rr:
	jump		g.amax1

max_dd:
	jump		g.dmax1

max_rd:
	swap		op2
	load		eaq,op1
	round		eaq
	copy		op2
	jump		g.dmax1.loop.1

max_dr:
	swap		op2
	jump		max_rd

max_ic:
	jump		mm_dt1.p

max_ci:
	jump		mm_dt2.p

max_rc:
	jump		mm_dt1.p

max_cr:
	jump		mm_dt2.p

max_dc:
	jump		mm_dt1.p

max_cd:
	jump		mm_dt2.p

max_cc:
	jump		mm_dt1.p

max_e1:
	jump		mm_dt2.p

max_e2:
	jump		mm_dt1.p

g.max0:
	load_top		q
	use_eaq
	copy		op2
	jump		g.max0.loop.1

g.max0.loop:
	if_dt		int,g.max0.loop.1
	if_dt		real,g.max0.real
	if_dt		dp,g.max0.dp

	jump		mm_dt1.p

g.max0.real:
	tsx0		pr0|integer_to_real
	jump		g.amax1.loop.1

g.max0.dp:
	tsx0		pr0|integer_to_double
	jump		g.dmax1.loop.1

g.max0.loop.1:
	cmpq		op1
	tpl		2,ic
	ldq		op1
	pop		op1

	if		arg2,=,2,g.max0.r

	copy		arg2
	copy		opv
	decrement		arg2,1
	jump		g.max0.loop

g.max0.r:
	jump		mm_ret_q

g.amax1:
	load_top		eaq
	round		eaq
	copy		op2
	jump		g.amax1.loop.1

g.amax1.loop:
	if_dt		real,g.amax1.loop.1
	if_dt		int,g.amax1.int
	if_dt		dp,g.amax1.dp

	jump		mm_dt1.p

g.amax1.int:
	push_temp		real
	store		eaq,op1,no_update
	swap		op2

	s_call		cv_load.ir
	pop		op1
	jump		g.amax1.loop.1

g.amax1.dp:
	jump		g.dmax1.loop.1

g.amax1.loop.1:
	fcmp		op1
	tpl		2,ic
	fld		op1
	pop		op1

	if		arg2,=,2,g.amax1.r

	copy		arg2
	copy		opv
	decrement		arg2,1
	jump		g.amax1.loop

g.amax1.r:
	jump		mm_ret_eaq

g.dmax1:
	load_top		deaq
	round		deaq
	copy		op2
	jump		g.dmax1.loop.1

g.dmax1.loop:
	if_dt		dp,g.dmax1.loop.1
	if_dt		int,g.dmax1.int
	if_dt		real,g.dmax1.real

	jump		mm_dt1.p

g.dmax1.int:
	push_temp		dp
	store		deaq,op1,no_update
	swap		op2

	s_call		cv_load.id
	pop		op1
	jump		g.dmax1.loop.1

g.dmax1.real:
	fcmp		op1
	tpl		2,ic
	fld		op1
	jump		g.dmax1.loop.2

g.dmax1.loop.1:
	dfcmp		op1
	tpl		2,ic
	dfld		op1

g.dmax1.loop.2:
	pop		op1

	if		arg2,=,2,g.dmax1.r

	copy		arg2
	copy		opv
	decrement		arg2,1
	jump		g.dmax1.loop

g.dmax1.r:
	jump		mm_ret_deaq

amax0:						" builtin 24
	unless		arg2,>,1,wrong_number.p
	swap		op2
	unless_dt		int,amax0.p
	swap		op2
	unless_dt		int,amax0.p

	load_top		q
	use_eaq
	copy		op2

amax0.loop:
	cmpq		op1
	tpl		2,ic
	ldq		op1
	pop		op1

	if		arg2,=,2,amax0.r

	copy		arg2
	copy		opv
	decrement		arg2,1
	unless_dt		int,amax0.p
	jump		amax0.loop

amax0.r:
	tsx0		pr0|integer_to_real
	jump		mm_ret_eaq

amax0.p:
	jump		mm_dt1.p

amax1:						" builtin 25
	unless		arg2,>,1,wrong_number.p
	swap		op2
	unless_dt		real,amax1.p
	swap		op2
	unless_dt		real,amax1.p

	load_top		eaq
	copy		op2

amax1.loop:
	fcmp		op1
	tpl		2,ic
	fld		op1
	pop		op1

	if		arg2,=,2,amax1.r

	copy		arg2
	copy		opv
	decrement		arg2,1
	unless_dt		real,amax1.p
	jump		amax1.loop

amax1.r:
	jump		mm_ret_eaq

amax1.p:
	jump		mm_dt1.p

max0:						" builtin 26
	unless		arg2,>,1,wrong_number.p
	swap		op2
	unless_dt		int,max0.p
	swap		op2
	unless_dt		int,max0.p

	load_top		q
	copy		op2

max0.loop:
	cmpq		op1
	tpl		2,ic
	ldq		op1
	pop		op1

	if		arg2,=,2,max0.r

	copy		arg2
	copy		opv
	decrement		arg2,1
	unless_dt		int,max0.p
	jump		max0.loop

max0.r:
	jump		mm_ret_q

max0.p:
	jump		mm_dt1.p

max1:						" builtin 27
	unless		arg2,>,1,wrong_number.p
	swap		op2
	unless_dt		real,max1.p
	swap		op2
	unless_dt		real,max1.p

	load_top		eaq
	round		eaq
	use_eaq
	copy		op2

max1.loop:
	fcmp		op1
	tpl		2,ic
	fld		op1
	pop		op1

	if		arg2,=,2,max1.r

	copy		arg2
	copy		opv
	decrement		arg2,1
	unless_dt		real,max1.p
	jump		max1.loop

max1.r:
	tsx0		pr0|real_to_integer
	jump		mm_ret_q

max1.p:
	jump		mm_dt1.p

dmax1:						" builtin 28
	unless		arg2,>,1,wrong_number.p
	swap		op2
	unless_dt		dp,dmax1.p
	swap		op2
	unless_dt		dp,dmax1.p

	load_top		deaq
	round		deaq
	copy		op2

dmax1.loop:
	dfcmp		op1
	tpl		2,ic
	dfld		op1
	pop		op1

	if		arg2,=,2,dmax1.r

	copy		arg2
	copy		opv
	decrement		arg2,1
	unless_dt		dp,dmax1.p
	jump		dmax1.loop

dmax1.r:
	jump		mm_ret_deaq

dmax1.p:
	jump		mm_dt1.p

min:						" builtin 29
	unless		arg2,>,1,wrong_number.p
	dt_jump		(min_ii,min_ri,min_di,min_ci,min_ir,min_rr,min_dr,min_cr,min_id,min_rd,min_dd,min_cd,min_ic,min_rc,min_dc,min_cc,min_e2,min_e1,min_e2,min_e1)

min_ii:
	jump		g.min0

min_ir:
	s_call		builtin_2args_ir
	jump		g.amin1

min_ri:
	s_call		builtin_2args_ri
	jump		g.amin1

min_id:
	s_call		builtin_2args_id
	jump		g.dmin1

min_di:
	s_call		builtin_2args_di
	jump		g.dmin1

min_rr:
	jump		g.amin1

min_dd:
	jump		g.dmin1

min_rd:
	swap		op2
	load		eaq,op1
	round		eaq
	copy		op2
	jump		g.dmin1.loop.1

min_dr:
	swap		op2
	jump		min_rd

min_ic:
	jump		mm_dt1.p

min_ci:
	jump		mm_dt2.p

min_rc:
	jump		mm_dt1.p

min_cr:
	jump		mm_dt2.p

min_dc:
	jump		mm_dt1.p

min_cd:
	jump		mm_dt2.p

min_cc:
	jump		mm_dt1.p

min_e1:
	jump		mm_dt2.p

min_e2:
	jump		mm_dt1.p

g.min0:
	load_top		q
	use_eaq
	copy		op2
	jump		g.min0.loop.1

g.min0.loop:
	if_dt		int,g.min0.loop.1
	if_dt		real,g.min0.real
	if_dt		dp,g.min0.dp

	jump		mm_dt1.p

g.min0.real:
	tsx0		pr0|integer_to_real
	jump		g.amin1.loop.1

g.min0.dp:
	tsx0		pr0|integer_to_double
	jump		g.dmin1.loop.1

g.min0.loop.1:
	cmpq		op1
	tmoz		2,ic
	ldq		op1
	pop		op1

	if		arg2,=,2,g.min0.r

	copy		arg2
	copy		opv
	decrement		arg2,1
	jump		g.min0.loop

g.min0.r:
	jump		mm_ret_q

g.amin1:
	load_top		eaq
	round		eaq
	copy		op2
	jump		g.amin1.loop.1

g.amin1.loop:
	if_dt		real,g.amin1.loop.1
	if_dt		int,g.amin1.int
	if_dt		dp,g.amin1.dp

	jump		mm_dt1.p

g.amin1.int:
	push_temp		real
	store		eaq,op1,no_update
	swap		op2

	s_call		cv_load.ir
	pop		op1
	jump		g.amin1.loop.1

g.amin1.dp:
	jump		g.dmin1.loop.1

g.amin1.loop.1:
	fcmp		op1
	tmoz		2,ic
	fld		op1
	pop		op1

	if		arg2,=,2,g.amin1.r

	copy		arg2
	copy		opv
	decrement		arg2,1
	jump		g.amin1.loop

g.amin1.r:
	jump		mm_ret_eaq

g.dmin1:
	load_top		deaq
	round		deaq
	copy		op2
	jump		g.dmin1.loop.1

g.dmin1.loop:
	if_dt		dp,g.dmin1.loop.1
	if_dt		int,g.dmin1.int
	if_dt		real,g.dmin1.real

	jump		mm_dt1.p

g.dmin1.int:
	push_temp		dp
	store		deaq,op1,no_update
	swap		op2

	s_call		cv_load.id
	pop		op1
	jump		g.dmin1.loop.1

g.dmin1.real:
	fcmp		op1
	tmoz		2,ic
	fld		op1
	jump		g.dmin1.loop.2

g.dmin1.loop.1:
	dfcmp		op1
	tmoz		2,ic
	dfld		op1

g.dmin1.loop.2:
	pop		op1

	if		arg2,=,2,g.dmin1.r

	copy		arg2
	copy		opv
	decrement		arg2,1
	jump		g.dmin1.loop

g.dmin1.r:
	jump		mm_ret_deaq

amin0:						" builtin 30
	unless		arg2,>,1,wrong_number.p
	swap		op2
	unless_dt		int,amin0.p
	swap		op2
	unless_dt		int,amin0.p

	load_top		q
	use_eaq
	copy		op2

amin0.loop:
	cmpq		op1
	tmoz		2,ic
	ldq		op1
	pop		op1

	if		arg2,=,2,amin0.r

	copy		arg2
	copy		opv
	decrement		arg2,1
	unless_dt		int,amin0.p
	jump		amin0.loop

amin0.r:
	tsx0		pr0|integer_to_real
	jump		mm_ret_eaq

amin0.p:
	jump		mm_dt1.p

amin1:						" builtin 31
	unless		arg2,>,1,wrong_number.p
	swap		op2
	unless_dt		real,amin1.p
	swap		op2
	unless_dt		real,amin1.p

	load_top		eaq
	round		eaq
	copy		op2

amin1.loop:
	fcmp		op1
	tmoz		2,ic
	fld		op1
	pop		op1

	if		arg2,=,2,amin1.r

	copy		arg2
	copy		opv
	decrement		arg2,1
	unless_dt		real,amin1.p
	jump		amin1.loop

amin1.r:
	jump		mm_ret_eaq

amin1.p:
	jump		mm_dt1.p

min0:						" builtin 32
	unless		arg2,>,1,wrong_number.p
	swap		op2
	unless_dt		int,min0.p
	swap		op2
	unless_dt		int,min0.p

	load_top		q
	copy		op2

min0.loop:
	cmpq		op1
	tmoz		2,ic
	ldq		op1
	pop		op1

	if		arg2,=,2,min0.r

	copy		arg2
	copy		opv
	decrement		arg2,1
	unless_dt		int,min0.p
	jump		min0.loop

min0.r:
	jump		mm_ret_q

min0.p:
	jump		mm_dt1.p

min1:						" builtin 33
	unless		arg2,>,1,wrong_number.p
	swap		op2
	unless_dt		real,min1.p
	swap		op2
	unless_dt		real,min1.p

	load_top		eaq
	round		eaq
	use_eaq
	copy		op2

min1.loop:
	fcmp		op1
	tmoz		2,ic
	fld		op1
	pop		op1

	if		arg2,=,2,min1.r

	copy		arg2
	copy		opv
	decrement		arg2,1
	unless_dt		real,min1.p
	jump		min1.loop

min1.r:
	tsx0		pr0|real_to_integer
	jump		mm_ret_q

min1.p:
	jump		mm_dt1.p

dmin1:						" builtin 34
	unless		arg2,>,1,wrong_number.p
	swap		op2
	unless_dt		dp,dmin1.p
	swap		op2
	unless_dt		dp,dmin1.p

	load_top		deaq
	round		deaq
	copy		op2

dmin1.loop:
	dfcmp		op1
	tmoz		2,ic
	dfld		op1
	pop		op1

	if		arg2,=,2,dmin1.r

	copy		arg2
	copy		opv
	decrement		arg2,1
	unless_dt		dp,dmin1.p
	jump		dmin1.loop

dmin1.r:
	jump		mm_ret_deaq

dmin1.p:
	jump		mm_dt1.p

mod:						" builtin 35
	dt_jump		(mod_ii,mod_ri,mod_di,mod_ci,mod_ir,mod_rr,mod_dr,mod_cr,mod_id,mod_rd,mod_dd,mod_cd,mod_ic,mod_rc,mod_dc,mod_cc,mod_e2,mod_e1,mod_e2,mod_e1)

mod_ii:
	jump		mod.1

mod_ir:
	s_call		builtin_2args_ir
	jump		amod.1

mod_ri:
	s_call		builtin_2args_ri
	jump		amod.1

mod_id:
	s_call		builtin_2args_id
	jump		dmod.1

mod_di:
	s_call		builtin_2args_di
	jump		dmod.1

mod_rr:
	jump		amod.1

mod_dd:
	jump		dmod.1

mod_rd:
	jump		rdmod.1

mod_dr:
	jump		dmod.1

mod_ic:
	jump		bu_dt6.p

mod_ci:
	jump		bu_dt5.p

mod_rc:
	jump		bu_dt6.p

mod_cr:
	jump		bu_dt5.p

mod_dc:
	jump		bu_dt6.p

mod_cd:
	jump		bu_dt5.p

mod_cc:
	jump		bu_dt5.p

mod_e1:
	jump		bu_dt5.p

mod_e2:
	jump		bu_dt6.p

mod.1:
	load		q,arg5
	use_eaq
	div		arg6
	emit		1
	lrs		36
	jump		bu_ret_q

amod:						" builtin 36
	swap		arg5
	unless_dt		real,amod.p
	swap		arg5
	unless_dt		real,amod.p

amod.1:
	load		eaq,arg5
	load_pr		pr2,arg6
	tsx0		pr0|fort_modfl
	free_regs
	jump		bu_ret_eaq

dmod:						" builtin 37
	swap		arg5
	unless_dt		dp,dmod.p
	swap		arg5
	unless_dt		dp,dmod.p

dmod.1:
	load		deaq,arg5
dmod.2:
	use_eaq
	load_pr		pr2,arg6
	tsx0		pr0|fort_dmod
	free_regs
	jump		bu_ret_deaq

rdmod.1:
	load		eaq,arg5
	jump		dmod.2

amod.p:
dmod.p:
	jump		bu_dt6.p

sign:						" builtin 38
	dt_jump		(sign_ii,sign_ri,sign_di,sign_ci,sign_ir,sign_rr,sign_dr,sign_cr,sign_id,sign_rd,sign_dd,sign_cd,sign_ic,sign_rc,sign_dc,sign_cc,sign_e2,sign_e1,sign_e2,sign_e1)

isign:						" builtin 39
	swap		arg5
	unless_dt		int,isign.p
	swap		arg5
	unless_dt		int,isign.p

sign_ii:
	load_pr		pr2,arg6
	load_for_test	q,arg5
	tsx0		pr0|sign_fx
	free_regs
	jump		bu_ret_q

sign_ir:
	s_call		builtin_2args_ir
	jump		sign.1

sign_ri:
	s_call		builtin_2args_ri
	jump		sign.1

sign_id:
	s_call		builtin_2args_id
	jump		dsign.1

sign_di:
	s_call		builtin_2args_di
	jump		dsign.1

sign_rr:
	jump		sign.1

sign_dd:
	jump		dsign.1

sign_rd:
	jump		rdsign.1

sign_dr:
	jump		dsign.1

sign_ic:
	jump		bu_dt6.p

sign_ci:
	jump		bu_dt5.p

sign_rc:
	jump		bu_dt6.p

sign_cr:
	jump		bu_dt5.p

sign_dc:
	jump		bu_dt6.p

sign_cd:
	jump		bu_dt5.p

sign_cc:
	jump		bu_dt5.p

sign_e1:
	jump		bu_dt5.p

sign_e2:
	jump		bu_dt6.p

sign.1:
	load_pr		pr2,arg6
	load_for_test	eaq,arg5
	tsx0		pr0|sign_fl
	free_regs
	jump		bu_ret_eaq

dsign:						" builtin 40
	swap		arg5
	unless_dt		dp,dsign.p
	swap		arg5
	unless_dt		dp,dsign.p

dsign.1:
	load_pr		pr2,arg6
	load_for_test	deaq,arg5
dsign.2:
	tsx0		pr0|sign_fl
	free_regs
	jump		bu_ret_deaq

rdsign.1:
	load_pr		pr2,arg6
	load_for_test	eaq,arg5
	jump		dsign.2

isign.p:
dsign.p:
	jump		bu_dt6.p

builtin_2args_ii:
	swap		op2

	if_optype		constant,conv_bu_ii.1

	push_temp		real

	load		q,op2
	use_eaq
	tsx0		pr0|integer_to_real
	in_reg		eaq,op1
	swap		op2
	pop		op1
	swap		op2
	jump		builtin_2args_ii.1

conv_bu_ii.1:
	convert_constant	real

	swap		op2
	jump		builtin_2args_ii.1

builtin_2args_ii.1:
	if_optype		constant,conv_bu_ii.2

	push_temp		real

	load		q,op2
	use_eaq
	tsx0		pr0|integer_to_real
	in_reg		eaq,op1
	swap		op2
	pop		op1
	s_return

conv_bu_ii.2:
	convert_constant	real

	s_return

builtin_2args_ir:
	swap		op2

	if_optype		constant,conv_bu_ir

	push_temp		real

	load		q,op2
	use_eaq
	tsx0		pr0|integer_to_real
	in_reg		eaq,op1
	swap		op2
	pop		op1
	swap		op2
	s_return

conv_bu_ir:
	convert_constant	real

	swap		op2
	s_return

builtin_2args_ri:
	if_optype		constant,conv_bu_ri

	push_temp		real

	load		q,op2
	use_eaq
	tsx0		pr0|integer_to_real
	in_reg		eaq,op1
	swap		op2
	pop		op1
	s_return

conv_bu_ri:
	convert_constant	real

	s_return

builtin_2args_id:
	swap		op2

	if_optype		constant,conv_bu_id

	push_temp		dp

	load		q,op2
	use_eaq
	tsx0		pr0|integer_to_double
	in_reg		deaq,op1
	swap		op2
	pop		op1
	swap		op2
	s_return

conv_bu_id:
	convert_constant	dp

	swap		op2
	s_return

builtin_2args_di:
	if_optype		constant,conv_bu_di

	push_temp		dp

	load		q,op2
	use_eaq
	tsx0		pr0|integer_to_double
	in_reg		deaq,op1
	swap		op2
	pop		op1
	s_return

conv_bu_di:
	convert_constant	dp

	s_return

sin:						" builtin 41
	if_dt		int,sin_i
	if_dt		real,sin.1
	if_dt		dp,dsin.1
	jump		csin.1

sin.1:
	load		eaq,arg5
	jump		sin.2

sin_i:
	s_call		cv_load.ir

sin.2:
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|sin_
	free_regs
	jump		bu_ret_eaq

dsin:						" builtin 42
	unless_dt		dp,dsin.p
dsin.1:
	load		deaq,arg5
	use_eaq
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|dsin_
	free_regs
	jump		bu_ret_deaq

csin:						" builtin 43
	unless_dt		cmpx,csin.p
csin.1:
	load		aq,arg5
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|csin_
	ldaq		pr6|temp_pt
	free_regs
	jump		bu_ret_aq

dsin.p:
csin.p:
	jump		bu_dt5.p

sqrt:						" builtin 44
	if_dt		int,sqrt_i
	if_dt		real,sqrt.1
	if_dt		dp,dsqrt.1
	jump		csqrt.1

sqrt.1:
	load		eaq,arg5
	jump		sqrt.2

sqrt_i:
	s_call		cv_load.ir

sqrt.2:
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|sqrt_
	free_regs
	jump		bu_ret_eaq

dsqrt:						" builtin 45
	unless_dt		dp,dsqrt.p
dsqrt.1:
	load		deaq,arg5
	use_eaq
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|dsqrt_
	free_regs
	jump		bu_ret_deaq

csqrt:						" builtin 46
	unless_dt		cmpx,csqrt.p
csqrt.1:
	load		aq,arg5
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|csqrt_
	ldaq		pr6|temp_pt
	free_regs
	jump		bu_ret_aq

dsqrt.p:
csqrt.p:
	jump		bu_dt5.p

tanh:						" builtin 47
	dt_jump1		arg5,(tanh.int,tanh.real,tanh.dp,tanh.p,tanh.p,tanh.p,tanh.p)

tanh.int:
	s_call		cv_load.ir
	jump		tanh.1

tanh.real:
	load		eaq,arg5

tanh.1:
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|tanh_
	fld		pr6|temp_pt
	free_regs
	jump		bu_ret_eaq

tanh.dp:
	load		deaq,arg5
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|dtanh_
	dfld		pr6|temp_pt
	free_regs
	jump		bu_ret_deaq


dtanh:						" builtin 77
	unless_dt		dp,dtanh.p
	jump		tanh.dp


tanh.p:
dtanh.p:
	jump		bu_dt5.p

sinh:						" builtin 74
	dt_jump1		arg5,(sinh.int,sinh.real,sinh.dp,sinh.p,sinh.p,sinh.p,sinh.p)

sinh.int:
	s_call		cv_load.ir
	jump		sinh.1

sinh.real:
	load		eaq,arg5

sinh.1:
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|sinh_
	fld		pr6|temp_pt
	free_regs
	jump		bu_ret_eaq

sinh.dp:
	load		deaq,arg5
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|dsinh_
	dfld		pr6|temp_pt
	free_regs
	jump		bu_ret_deaq


dsinh:						" builtin 76
	unless_dt		dp,dsinh.p
	jump		sinh.dp


sinh.p:
dsinh.p:
	jump		bu_dt5.p

cosh:						" builtin 73
	dt_jump1		arg5,(cosh.int,cosh.real,cosh.dp,cosh.p,cosh.p,cosh.p,cosh.p)

cosh.int:
	s_call		cv_load.ir
	jump		cosh.1

cosh.real:
	load		eaq,arg5

cosh.1:
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|cosh_
	fld		pr6|temp_pt
	free_regs
	jump		bu_ret_eaq

cosh.dp:
	load		deaq,arg5
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|dcosh_
	dfld		pr6|temp_pt
	free_regs
	jump		bu_ret_deaq


dcosh:						" builtin 75
	unless_dt		dp,dcosh.p
	jump		cosh.dp


cosh.p:
dcosh.p:
	jump		bu_dt5.p

int_builtin:					" builtin 48
	dt_jump1		arg5,(int_builtin.int,int_builtin.real,int_builtin.dp,int_builtin.cmpx,int.p,int.p,int_builtin.tl)

int_builtin.int:
	load		q,arg5
	jump		bu_ret_q

int_builtin.real:
	s_call		cv_load.ri
	jump		bu_ret_q

int_builtin.dp:
	s_call		cv_load.di
	jump		bu_ret_q

int_builtin.cmpx:
	s_call		cv_load.ri
	jump		bu_ret_q

int_builtin.tl:
	load		q,arg5
	jump		bu_ret_q


ifix:						" builtin 52
	unless_dt		real,ifix.p
	jump		int_builtin.real


idint:						" builtin 50
	unless_dt		dp,idint.p
	jump		int_builtin.dp


int.p:
ifix.p:
idint.p:
	jump		bu_dt5.p

aint:						" builtin 49
	dt_jump1		arg5,(aint.int,aint.real,aint.dp,aint.p,aint.p,aint.p,aint.p)

aint.int:
	s_call		cv_load.ir
	jump		bu_ret_eaq

aint.real:
	load_for_test	eaq,arg5
	tsx0		pr0|trunc_fl
	jump		bu_ret_eaq

aint.dp:
	load_for_test	deaq,arg5
	tsx0		pr0|trunc_fl
	jump		bu_ret_deaq


dint:						" builtin 78
	unless_dt		dp,dint.p
	jump		aint.dp


aint.p:
dint.p:
	jump		bu_dt5.p

anint:						" builtin 79
	dt_jump1		arg5,(anint.int,anint.real,anint.dp,anint.p,anint.p,anint.p,anint.p)

anint.int:
	s_call		cv_load.ir
	jump		bu_ret_eaq

anint.real:
	load_for_test	eaq,arg5
	tsx0		pr0|nearest_whole_number
	jump		bu_ret_eaq

anint.dp:
	load_for_test	deaq,arg5
	tsx0		pr0|nearest_whole_number
	jump		bu_ret_deaq


dnint:						" builtin 80
	unless_dt		dp,dnint.p
	jump		anint.dp


anint.p:
dnint.p:
	jump		bu_dt5.p

nint:						" builtin 81
	dt_jump1		arg5,(nint.int,nint.real,nint.dp,nint.p,nint.p,nint.p,nint.p)

nint.int:
	load		q,arg5
	jump		bu_ret_q

nint.real:
	load_for_test	eaq,arg5
	use_eaq
	tsx0		pr0|nearest_integer
	jump		bu_ret_q

nint.dp:
	load_for_test	deaq,arg5
	use_eaq
	tsx0		pr0|nearest_integer
	jump		bu_ret_q


idnint:						" builtin 82
	unless_dt		dp,idnint.p
	jump		nint.dp


nint.p:
idnint.p:
	jump		bu_dt5.p

real_builtin:					" builtin 54
	dt_jump1		arg5,(real_builtin.int,real_builtin.real,real_builtin.dp,real_builtin.cmpx,real.p,real.p,real.p)

real_builtin.int:
	s_call		cv_load.ir
	jump		bu_ret_eaq

real_builtin.real:
	load		eaq,arg5
	jump		bu_ret_eaq

real_builtin.dp:
	load		deaq,arg5
	emit		1
	frd		0
	jump		bu_ret_eaq

real_builtin.cmpx:
	load		eaq,arg5
	jump		bu_ret_eaq


float:						" builtin 51
	unless_dt		int,float.p
	jump		real_builtin.int


sngl:						" builtin 53
	unless_dt		dp,sngl.p
	jump		real_builtin.dp


real.p:
float.p:
sngl.p:
	jump		bu_dt5.p

aimag:						" builtin 55
	unless_dt		cmpx,aimag.p

	load		ieaq,arg5
	jump		bu_ret_eaq

aimag.p:
	jump		bu_dt5.p

dble:						" builtin 56
	dt_jump1		arg5,(dble.int,dble.real,dble.dp,dble.cmpx,dble.p,dble.p,dble.p)

dble.int:
	s_call		cv_load.id
	jump		bu_ret_deaq

dble.real:
	load		eaq,arg5
	jump		bu_ret_deaq

dble.dp:
	load		deaq,arg5
	jump		bu_ret_deaq

dble.cmpx:
	load		eaq,arg5
	jump		bu_ret_deaq

dble.p:
	jump		bu_dt5.p

cmplx:						" builtin 57
	if		arg2,=,1,cmplx.one
	if		arg2,=,2,cmplx.two
	error		319,arg1

cmplx.one:
	dt_jump1		arg5,(cmplx.one.int,cmplx.one.real,cmplx.one.dp,cmplx.one.cmpx,cmplx.one.p,cmplx.one.p,cmplx.one.p)

cmplx.one.int:
	s_call		cv_load.ir
	jump		cmplx.one.join

cmplx.one.real:
	load		eaq,arg5
	jump		cmplx.one.join

cmplx.one.dp:
	load		deaq,arg5
	emit		1
	frd		0
	jump		cmplx.one.join

cmplx.one.cmpx:
	load		aq,arg5
	return		aq

cmplx.one.join:
	reset_eaq
	push_temp		cmpx
	store		eaq,op1,no_update
	fld		=0.0,du
	fst		op1+1
	return		op1

cmplx.one.p:
	jump		mm_dt1.p

cmplx.two:
	dt_jump		(cmplx.two.ii,cmplx.two.ri,cmplx.two.di,cmplx.two.e1,cmplx.two.ir,cmplx.two.rr,cmplx.two.dr,cmplx.two.e1,cmplx.two.id,cmplx.two.rd,cmplx.two.dd,cmplx.two.e1,cmplx.two.e2,cmplx.two.e2,cmplx.two.e2,cmplx.two.e1,cmplx.two.e2,cmplx.two.e1,cmplx.two.e2,cmplx.two.e1)

cmplx.two.ii:
	push_temp		cmpx
	if_eaq		q,arg6,cmplx.two.ii.1
	swap		arg5
	s_call		cv_load.ir
	swap		arg5
	store		eaq,op1,no_update
	swap		arg6
	s_call		cv_load.ir
	swap		arg6
	in_reg		ieaq,op1
	return		op1

cmplx.two.ii.1:
	swap		arg6
	s_call		cv_load.ir
	swap		arg6
	store		ieaq,op1,no_update
	swap		arg5
	s_call		cv_load.ir
	swap		arg5
	in_reg		eaq,op1
	return		op1

cmplx.two.rr:
	push_temp		cmpx
	if_eaq		eaq,arg6,cmplx.two.rr.1
	load		eaq,arg5
	store		eaq,op1,no_update
	fld		arg6
	in_reg		ieaq,op1
	return		op1

cmplx.two.rr.1:
	store		ieaq,op1,no_update
	fld		arg5
	in_reg		eaq,op1
	return		op1

cmplx.two.dd:
	push_temp		cmpx
	if_eaq		deaq,arg6,cmplx.two.dd.1
	load		deaq,arg5
	emit		1
	frd		0
	store		eaq,op1,no_update
	dfld		arg6
	emit		1
	frd		0
	in_reg		ieaq,op1
	return		op1

cmplx.two.dd.1:
	emit		1
	frd		0
	store		ieaq,op1,no_update
	dfld		arg5
	emit		1
	frd		0
	in_reg		eaq,op1
	return		op1

cmplx.two.e1:
	jump		mm_dt2.p

cmplx.two.e2:
	jump		mm_dt1.p

cmplx.two.ri:
cmplx.two.di:
cmplx.two.ir:
cmplx.two.dr:
cmplx.two.id:
cmplx.two.rd:
	error		314,arg1

conjg:						" builtin 58
	unless_dt		cmpx,conjg.p

	push_temp		cmpx

	use_ind
	if_eaq		ieaq,arg5,conjg.1

	load		eaq,arg5
	store		eaq,op1,no_update
	fld		arg5+1
	emit		1
	fneg
	in_reg		ieaq,op1

	scan		continue,(continue,next)
	return		op1

conjg.1:
	emit		1
	fneg
	store		ieaq,op1,no_update
	fld		arg5
	in_reg		eaq,op1

	scan		continue,(continue,next)
	return		op1

conjg.p:
	jump		bu_dt5.p

tan:						" builtin 59
	if_dt		int,tan_i
	if_dt		real,tan.1
	if_dt		dp,dtan.1
	jump		tan.p

tan.1:
	load		eaq,arg5
	jump		tan.2

tan_i:
	s_call		cv_load.ir

tan.2:
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|tan_
	free_regs
	jump		bu_ret_eaq

dtan:						" builtin 60
	unless_dt		dp,dtan.p
dtan.1:
	load		deaq,arg5
	use_eaq
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|dtan_
	free_regs
	jump		bu_ret_deaq

tan.p:
	jump		bu_dt5.p

dtan.p:
	jump		bu_dt5.p

asin:						" builtin 61
	if_dt		int,asin_i
	if_dt		real,asin.1
	if_dt		dp,dasin.1
	jump		asin.p

asin.1:
	load		eaq,arg5
	jump		asin.2

asin_i:
	s_call		cv_load.ir

asin.2:
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|asin_
	free_regs
	jump		bu_ret_eaq

dasin:						" builtin 62
	unless_dt		dp,dasin.p
dasin.1:
	load		deaq,arg5
	use_eaq
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|dasin_
	free_regs
	jump		bu_ret_deaq

asin.p:
	jump		bu_dt5.p

dasin.p:
	jump		bu_dt5.p

acos:						" builtin 63
	if_dt		int,acos_i
	if_dt		real,acos.1
	if_dt		dp,dacos.1
	jump		acos.p

acos.1:
	load		eaq,arg5
	jump		acos.2

acos_i:
	s_call		cv_load.ir

acos.2:
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|acos_
	free_regs
	jump		bu_ret_eaq

dacos:						" builtin 64
	unless_dt		dp,dacos.p
dacos.1:
	load		deaq,arg5
	use_eaq
	push_temp		32
	load_pr		pr2,op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|dacos_
	free_regs
	jump		bu_ret_deaq

acos.p:
	jump		bu_dt5.p

dacos.p:
	jump		bu_dt5.p

char_builtin:						" builtin 65
	unless_dt		int,char.p

	if_optype		constant,char.constant

	push_char_temp	1

	load		q,op2

	emit_inst		1
	qls		27

	stq		op1

	reset_eaq

	jump		bu_ret_op1

char.constant:
	int_to_char1
	jump		bu_ret_op1

char.p:
	jump		bu_dt1.p

ichar:						" builtin 66
	unless_dt		char,ichar.p

	if_optype		constant,ichar.constant

	push_temp		int

	if_aligned	op2,ichar.aligned

	emit_eis
	mrl		(pr),(pr),fill(0)
	desc9a		op2,1
	desc9a		op1,4

	set_in_storage	op1

	jump		bu_ret_op1

ichar.aligned:
	use_eaq

	ldq		op2

	emit_inst		1
	qrl		27

	jump		bu_ret_q

ichar.constant:
	char1_to_int
	jump		bu_ret_op1

ichar.p:
	jump		bu_dt1.p

index:						" builtin 67
	unless_dt		char,index.p
	swap		op2
	unless_dt		char,index.p

	push_length	op2
	if		op1,=,1,index.1
	if		op1,=,2,index.2

	" Length of second string is not known to be 1 or 2

	push_length	op2

	use_eaq

	load_pr		pr2,op3
	load		q,op1
	tsx0		pr0|set_cs_eis

	free_regs

	use_eaq

	load_pr		pr2,op4
	load		q,op2
	tsx0		pr0|index_cs_eis

	free_regs

	jump		bu_ret_q

index.1:

	" Length of second string is known to be 1

	use_eaq

	emit_eis
	scm		(pr),(pr),mask(0)
	desc9a		op2
	desc9a		op3,1

	arg		pr6|double_temp

	ldq		pr6|double_temp
	ttf		2,ic
	lcq		1,dl
	adq		1,dl

	jump		bu_ret_q

index.2:

	" Length of second string is known to be 2

	use_eaq

	emit_eis
	scd		(pr),(pr)
	desc9a		op2
	desc9a		op3,2

	arg		pr6|double_temp

	ldq		pr6|double_temp
	ttf		2,ic
	lcq		1,dl
	adq		1,dl

	jump		bu_ret_q

index.p:
	jump		bu_dt1.p

len:						" builtin 68
	unless_dt		char,len.p

	push_length	op1

	jump		bu_ret_op1

len.p:
	jump		bu_dt1.p

lge:						" builtin 69
	unless_dt		char,lge.p
	swap		op2
	unless_dt		char,lge.p

	use_ind

	emit_eis
	cmpc		(pr),(pr),fill(040)
	desc9a		op1
	desc9a		op2

	jump		bu_ret_trc

lge.p:
	jump		bu_dt1.p

lgt:						" builtin 70
	unless_dt		char,lgt.p
	swap		op2
	unless_dt		char,lgt.p

	use_ind

	emit_eis
	cmpc		(pr),(pr),fill(040)
	desc9a		op2
	desc9a		op1

	jump		bu_ret_tnc

lgt.p:
	jump		bu_dt1.p

lle:						" builtin 71
	unless_dt		char,lle.p
	swap		op2
	unless_dt		char,lle.p

	use_ind

	emit_eis
	cmpc		(pr),(pr),fill(040)
	desc9a		op2
	desc9a		op1

	jump		bu_ret_trc

lle.p:
	jump		bu_dt1.p

llt:						"builtin 72
	unless_dt		char,llt.p
	swap		op2
	unless_dt		char,llt.p

	use_ind

	emit_eis
	cmpc		(pr),(pr),fill(040)
	desc9a		op1
	desc9a		op2

	jump		bu_ret_tnc

llt.p:
	jump		bu_dt1.p

dprod:						" builtin 83
	swap		arg5
	unless_dt		real,dprod.p
	swap		arg5
	unless_dt		real,dprod.p
	load_top		eaq
	fmp		op2
	jump		bu_ret_deaq

dprod.p:
	jump		bu_dt6.p

and.tl:						" builtin 84
	unless		arg2,>,1,wrong_number.p
	load_top		tq
	copy		op2

and.tl.loop:
	anq		op1
	pop		op1
	if		arg2,=,2,and.tl.r
	copy		arg2
	copy		opv
	decrement		arg2,1
	jump		and.tl.loop

and.tl.r:
	jump		mm_ret_tq

bool.tl:						" builtin 85
	load		tq,arg5
	jump		bu_ret_tq

compl.tl:						" builtin 86
	use_eaq
	lcq		1,dl
	erq		arg5
	jump		bu_ret_tq

fld.tl:						" builtin 87
	rhs_fld
	jump		bu_ret_tq

ilr.tl:						" builtin 88
	dt_jump1		arg5,(ilr.1,bu_dt5.p,bu_dt5.p,bu_dt5.p,bu_dt5.p,bu_dt5.p,ilr.1)

ilr.1:
	dt_jump1		arg6,(ilr.2,bu_dt6.p,bu_dt6.p,bu_dt6.p,bu_dt6.p,bu_dt6.p,bu_dt6.p)

ilr.2:
	load		q,arg5
	load		ia,arg6
	qlr		0,al
	jump		bu_ret_q

ils.tl:						" builtin 89
	dt_jump1		arg5,(ils.1,bu_dt5.p,bu_dt5.p,bu_dt5.p,bu_dt5.p,bu_dt5.p,ils.1)

ils.1:
	dt_jump1		arg6,(ils.2,bu_dt6.p,bu_dt6.p,bu_dt6.p,bu_dt6.p,bu_dt6.p,bu_dt6.p)

ils.2:
	load		q,arg5
	load		ia,arg6
	qls		0,al
	jump		bu_ret_q

irl.tl:						" builtin 90
	dt_jump1		arg5,(irl.1,bu_dt5.p,bu_dt5.p,bu_dt5.p,bu_dt5.p,bu_dt5.p,irl.1)

irl.1:
	dt_jump1		arg6,(irl.2,bu_dt6.p,bu_dt6.p,bu_dt6.p,bu_dt6.p,bu_dt6.p,bu_dt6.p)

irl.2:
	load		q,arg5
	load		ia,arg6
	qrl		0,al
	jump		bu_ret_q

irs.tl:						" builtin 91
	dt_jump1		arg5,(irs.1,bu_dt5.p,bu_dt5.p,bu_dt5.p,bu_dt5.p,bu_dt5.p,irs.1)

irs.1:
	dt_jump1		arg6,(irs.2,bu_dt6.p,bu_dt6.p,bu_dt6.p,bu_dt6.p,bu_dt6.p,bu_dt6.p)

irs.2:
	load		q,arg5
	load		ia,arg6
	qrs		0,al
	jump		bu_ret_q

or.tl:						" builtin 92
	unless		arg2,>,1,wrong_number.p
	load_top		tq
	copy		op2

or.tl.loop:
	orq		op1
	pop		op1
	if		arg2,=,2,or.tl.r
	copy		arg2
	copy		opv
	decrement		arg2,1
	jump		or.tl.loop

or.tl.r:
	jump		mm_ret_tq

xor.tl:						" builtin 93
	unless		arg2,>,1,wrong_number.p
	load_top		tq
	copy		op2

xor.tl.loop:
	erq		op1
	pop		op1
	if		arg2,=,2,xor.tl.r
	copy		arg2
	copy		opv
	decrement		arg2,1
	jump		xor.tl.loop

xor.tl.r:
	jump		mm_ret_tq

bu_dt1.p:
	print		321,arg1,op1
	jump		bu_abort_list

bu_dt2.p:
	print		321,arg1,op2
	jump		bu_abort_list

bu_dt5.p:
	print		321,arg1,arg5
	jump		bu_abort_list

bu_dt6.p:
	print		321,arg1,arg6
	jump		bu_abort_list

mm_dt1.p:
	error		321,arg1,op1

mm_dt2.p:
	error		321,arg1,op2

"		Errors common to all relational operators.
logical_op1:
	error		339,op1

logical_op2:
	error		339,op2

invalid_opnd:
	error		340,op2

not_scalar:
	error		340,op1

typeless_op1:
	error		362,op1

typeless_op2:
	error		362,op2
"
"		Begin relational operators.
"
less:	func		2

	use_ind

	dt_jump		(less_ii,less_ri,less_di,less_ci,less_ir,less_rr,less_dr,less_cr,less_id,less_rd,less_dd,less_cd,less_ic,less_rc,less_dc,less_cc,less_e2,less_e1,less_tl,less_tl)

less_ii:
	if_eaq		q,arg2,less_ii.1

	load		q,arg1
	cmpq		arg2
	return		tmi

less_ii.1:
	cmpq		arg1
	return		tpnz

less_ir:
	swap		arg1

	s_call		cv_load.ir
	fcmp		arg1
	return		tmi

less_ri:
	s_call		cv_load.ir
	fcmp		arg1
	return		tpnz

less_id:
	swap		arg1

	s_call		cv_load.id
	dfcmp		arg1
	return		tmi

less_di:
	s_call		cv_load.id
	dfcmp		arg1
	return		tpnz

less_rr:
	if_eaq		eaq,arg2,less_rr.1

	load		eaq,arg1
	round		eaq
	fcmp		arg2
	return		tmi

less_rr.1:
	round		eaq
	fcmp		arg1
	return		tpnz

less_dd:
	if_eaq		deaq,arg2,less_dd.1

	load		deaq,arg1
	round		deaq
	dfcmp		arg2
	return		tmi

less_dd.1:
	round		deaq
	dfcmp		arg1
	return		tpnz

less_rd:
	if_eaq		deaq,arg2,less_rd.1

	load		eaq,arg1
	dfcmp		arg2
	return		tmi

less_rd.1:
	round		deaq
	fcmp		arg1
	return		tpnz

less_dr:
	if_eaq		eaq,arg2,less_dr.1

	load		deaq,arg1
	round		deaq
	fcmp		arg2
	return		tmi

less_dr.1:
	dfcmp		arg1
	return		tpnz

less_ic:
	error		323,arg2

less_ci:
	error		323,arg1

less_rc:
	error		323,arg2

less_cr:
	error		323,arg1

less_dc:
	error		312,arg1,arg2

less_cd:
	error		311,arg1,arg2

less_cc:
	error		328,arg1,arg2

less_e2:
	if_dt		logical,logical_op1
	dt_jump1		arg1,(less_ih,less_rh,less_dh,less_ch,logical_op2,less_hh,less_th)

less_ih:
less_rh:
less_th:
	unless_optype	constant,invalid_opnd

	swap		arg1
	unless_optype	(variable,array_ref,temp),not_scalar

	pad_char_const_to_word	arg1	" the two operands remain swapped

	load		a,arg2
	cmpa		arg1
	return		tnc

less_dh:
less_ch:
	unless_optype	constant,invalid_opnd

	swap		arg1
	unless_optype	(variable,array_ref,temp),not_scalar

	pad_char_const_to_dw	arg1	" the two operands remain swapped

	load		aq,arg2
	cmpaq		arg1
	return		tnc

less_hh:
	use_eaq

	emit_eis
	cmpc		(pr),(pr),fill(040)
	desc9a		arg1
	desc9a		arg2

	return		tnc

less_e1:
	unless_optype	(variable,array_ref,temp),not_scalar

	swap		arg1
	unless_optype	constant,invalid_opnd
"				Operands remain swapped.
	dt_jump1		arg2,(less_hi,less_hr,less_hd,less_hc,logical_op1,less_hh,less_ht)

less_hi:
less_hr:
less_ht:
	pad_char_const_to_word	arg2

	load		a,arg2
	cmpa		arg1
	return		tnc

less_hd:
less_hc:
	pad_char_const_to_dw	arg2

	load		aq,arg2
	cmpaq		arg1
	return		tnc

less_tl:
	unless_dt		(int,typeless),typeless_op1
	dt_jump1		op2,(less_tl.1,typeless_op2,typeless_op2,typeless_op2,typeless_op2,typeless_op2,less_tl.1)

less_tl.1:
	if_eaq		tq,arg2,less_tl.2

	load		tq,arg1
	cmpq		arg2
	return		tmi

less_tl.2:
	cmpq		arg1
	return		tpnz

less_or_equal:
	func		2

	use_ind

	dt_jump		(less_or_equal_ii,less_or_equal_ri,less_or_equal_di,less_or_equal_ci,less_or_equal_ir,less_or_equal_rr,less_or_equal_dr,less_or_equal_cr,less_or_equal_id,less_or_equal_rd,less_or_equal_dd,less_or_equal_cd,less_or_equal_ic,less_or_equal_rc,less_or_equal_dc,less_or_equal_cc,less_or_equal_e2,less_or_equal_e1,less_or_equal_tl,less_or_equal_tl)

less_or_equal_ii:
	if_eaq		q,arg2,less_or_equal_ii.1

	load		q,arg1
	cmpq		arg2
	return		tmoz

less_or_equal_ii.1:
	cmpq		arg1
	return		tpl

less_or_equal_ir:
	swap		arg1

	s_call		cv_load.ir
	fcmp		arg1
	return		tmoz

less_or_equal_ri:
	s_call		cv_load.ir
	fcmp		arg1
	return		tpl

less_or_equal_id:
	swap		arg1

	s_call		cv_load.id
	dfcmp		arg1
	return		tmoz

less_or_equal_di:
	s_call		cv_load.id
	dfcmp		arg1
	return		tpl

less_or_equal_rr:
	if_eaq		eaq,arg2,less_or_equal_rr.1

	load		eaq,arg1
	round		eaq
	fcmp		arg2
	return		tmoz

less_or_equal_rr.1:
	round		eaq
	fcmp		arg1
	return		tpl

less_or_equal_dd:
	if_eaq		deaq,arg2,less_or_equal_dd.1

	load		deaq,arg1
	round		deaq
	dfcmp		arg2
	return		tmoz

less_or_equal_dd.1:
	round		deaq
	dfcmp		arg1
	return		tpl

less_or_equal_rd:
	if_eaq		deaq,arg2,less_or_equal_rd.1

	load		eaq,arg1
	dfcmp		arg2
	return		tmoz

less_or_equal_rd.1:
	round		deaq
	fcmp		arg1
	return		tpl

less_or_equal_dr:
	if_eaq		eaq,arg2,less_or_equal_dr.1

	load		deaq,arg1
	round		deaq
	fcmp		arg2
	return		tmoz

less_or_equal_dr.1:
	dfcmp		arg1
	return		tpl

less_or_equal_ic:
	error		323,arg2

less_or_equal_ci:
	error		323,arg1

less_or_equal_rc:
	error		323,arg2

less_or_equal_cr:
	error		323,arg1

less_or_equal_dc:
	error		312,arg1,arg2

less_or_equal_cd:
	error		311,arg1,arg2

less_or_equal_cc:
	error		328,arg1,arg2

less_or_equal_e2:
	if_dt		logical,logical_op1
	dt_jump1		arg1,(less_or_equal_ih,less_or_equal_rh,less_or_equal_dh,less_or_equal_ch,logical_op2,less_or_equal_hh,less_or_equal_th)

less_or_equal_ih:
less_or_equal_rh:
less_or_equal_th:
	unless_optype	constant,invalid_opnd

	swap		arg1
	unless_optype	(variable,array_ref,temp),not_scalar

	pad_char_const_to_word	arg1	" the two operands remain swapped

	load		a,arg1
	cmpa		arg2
	return		trc

less_or_equal_dh:
less_or_equal_ch:
	unless_optype	constant,invalid_opnd

	swap		arg1
	unless_optype	(variable,array_ref,temp),not_scalar

	pad_char_const_to_dw	arg1	" the two operands remain swapped

	load		aq,arg1
	cmpaq		arg2
	return		trc

less_or_equal_hh:
	use_eaq

	emit_eis
	cmpc		(pr),(pr),fill(040)
	desc9a		arg2
	desc9a		arg1

	return		trc

less_or_equal_e1:
	unless_optype	(variable,array_ref,temp),not_scalar

	swap		arg1
	unless_optype	constant,invalid_opnd
"				Operands remain swapped.
	dt_jump1		arg2,(less_or_equal_hi,less_or_equal_hr,less_or_equal_hd,less_or_equal_hc,logical_op1,less_or_equal_hh,less_or_equal_ht)

less_or_equal_hi:
less_or_equal_hr:
less_or_equal_ht:
	pad_char_const_to_word	arg2

	load		a,arg1
	cmpa		arg2
	return		trc

less_or_equal_hd:
less_or_equal_hc:
	pad_char_const_to_dw	arg2

	load		aq,arg1
	cmpaq		arg2
	return		trc

less_or_equal_tl:
	unless_dt		(int,typeless),typeless_op1
	dt_jump1		op2,(less_or_equal_tl.1,typeless_op2,typeless_op2,typeless_op2,typeless_op2,typeless_op2,less_or_equal_tl.1)

less_or_equal_tl.1:
	if_eaq		tq,arg2,less_or_equal_tl.2

	load		tq,arg1
	cmpq		arg2
	return		tmoz

less_or_equal_tl.2:
	cmpq		arg1
	return		tpl


equal:	func		2

	use_ind

	dt_jump		(equal_ii,equal_ri,equal_di,equal_ci,equal_ir,equal_rr,equal_dr,equal_cr,equal_id,equal_rd,equal_dd,equal_cd,equal_ic,equal_rc,equal_dc,equal_cc,equal_e2,equal_e1,equal_tl,equal_tl)

equal_ii:
	load_top		q
	cmpq		arg1
	return		tze

equal_ir:
	swap		arg1

equal_ri:
	s_call		cv_load.ir
	fcmp		arg1
	return		tze

equal_id:
	swap		arg1

equal_di:
	s_call		cv_load.id
	dfcmp		arg1
	return		tze

equal_rr:
	load_top		eaq
	round		eaq
	fcmp		arg1
	return		tze

equal_dd:
	load_top		deaq
	round		deaq
	dfcmp		arg1
	return		tze

equal_rd:
	swap		arg1

equal_dr:
	if_eaq		eaq,arg2,equal_dr.1

	load		deaq,arg1
	round		deaq
	fcmp		arg2
	return		tze

equal_dr.1:
	dfcmp		arg1
	return		tze

equal_ic:
	error		323,arg2

equal_ci:
	error		323,arg1

equal_rc:
	error		323,arg2

equal_cr:
	error		323,arg1

equal_dc:
	error		312,arg1,arg2

equal_cd:
	error		311,arg1,arg2

equal_cc:
	load_top		aq
	cmpaq		arg1
	return		tze

equal_e2:
	if_dt		char,equal_ah
	swap		arg1	" top is logical, so swap and test

	if_dt		logical,equal_ll
	error		313,op1

equal_ll:
	load_top		a
	cmpa		arg1
	return		tze

equal_ah:
	dt_jump1		arg1,(equal_ih,equal_rh,equal_dh,equal_ch,logical_op2,equal_hh,equal_th)

equal_ih:
equal_rh:
equal_th:
	unless_optype	constant,invalid_opnd

	swap		arg1
	unless_optype	(variable,array_ref,temp),not_scalar

	pad_char_const_to_word	arg1	" the two operands remain swapped

	load_top		a
	cmpa		arg1
	return		tze

equal_dh:
equal_ch:
	unless_optype	constant,invalid_opnd

	swap		arg1
	unless_optype	(variable,array_ref,temp),not_scalar

	pad_char_const_to_dw	arg1	" the two operands remain swapped

	load_top		aq
	cmpaq		arg1
	return		tze

equal_hh:
	use_eaq

	emit_eis
	cmpc		(pr),(pr),fill(040)
	desc9a		arg1
	desc9a		arg2

	return		tze

equal_e1:
	unless_optype	(variable,array_ref,temp),not_scalar

	swap		arg1
	unless_optype	constant,invalid_opnd
"				Operands remain swapped.
	dt_jump1		arg2,(equal_hi,equal_hr,equal_hd,equal_hc,logical_op1,equal_hh,equal_ht)

equal_hi:
equal_hr:
equal_ht:
	pad_char_const_to_word	arg2

	load_top		a
	cmpa		arg1
	return		tze

equal_hd:
equal_hc:
	pad_char_const_to_dw	arg2

	load_top		aq
	cmpaq		arg1
	return		tze

equal_tl:
	unless_dt		(int,typeless),typeless_op1
	dt_jump1		op2,(equal_tl.1,typeless_op2,typeless_op2,typeless_op2,typeless_op2,typeless_op2,equal_tl.1)

equal_tl.1:
	load_top		tq
	cmpq		arg1
	return		tze


not_equal:
	func		2

	use_ind

	dt_jump		(not_equal_ii,not_equal_ri,not_equal_di,not_equal_ci,not_equal_ir,not_equal_rr,not_equal_dr,not_equal_cr,not_equal_id,not_equal_rd,not_equal_dd,not_equal_cd,not_equal_ic,not_equal_rc,not_equal_dc,not_equal_cc,not_equal_e2,not_equal_e1,not_equal_tl,not_equal_tl)

not_equal_ii:
	load_top		q
	cmpq		arg1
	return		tnz

not_equal_ir:
	swap		arg1

not_equal_ri:
	s_call		cv_load.ir
	fcmp		arg1
	return		tnz

not_equal_id:
	swap		arg1

not_equal_di:
	s_call		cv_load.id
	dfcmp		arg1
	return		tnz

not_equal_rr:
	load_top		eaq
	round		eaq
	fcmp		arg1
	return		tnz

not_equal_dd:
	load_top		deaq
	round		deaq
	dfcmp		arg1
	return		tnz

not_equal_rd:
	swap		arg1

not_equal_dr:
	if_eaq		eaq,arg2,not_equal_dr.1

	load		deaq,arg1
	round		deaq
	fcmp		arg2
	return		tnz

not_equal_dr.1:
	dfcmp		arg1
	return		tnz

not_equal_ic:
	error		323,arg2

not_equal_ci:
	error		323,arg1

not_equal_rc:
	error		323,arg2

not_equal_cr:
	error		323,arg1

not_equal_dc:
	error		312,arg1,arg2

not_equal_cd:
	error		311,arg1,arg2

not_equal_cc:
	load_top		aq
	cmpaq		arg1
	return		tnz

not_equal_e2:
	if_dt		char,not_equal_ah
	swap		arg1	" top is logical, so swap and test other

	if_dt		logical,not_equal_ll
	error		313,op1

not_equal_ll:
	load_top		a
	cmpa		arg1
	return		tnz

not_equal_ah:
	dt_jump1		arg1,(not_equal_ih,not_equal_rh,not_equal_dh,not_equal_ch,logical_op2,not_equal_hh,not_equal_th)

not_equal_ih:
not_equal_rh:
not_equal_th:
	unless_optype	constant,invalid_opnd

	swap		arg1
	unless_optype	(variable,array_ref,temp),not_scalar

	pad_char_const_to_word	arg1	" the two operands remain swapped

	load_top		a
	cmpa		arg1
	return		tnz

not_equal_dh:
not_equal_ch:
	unless_optype	constant,invalid_opnd

	swap		arg1
	unless_optype	(variable,array_ref,temp),not_scalar

	pad_char_const_to_dw	arg1	" the two operands remain swapped

	load_top		aq
	cmpaq		arg1
	return		tnz

not_equal_hh:
	use_eaq

	emit_eis
	cmpc		(pr),(pr),fill(040)
	desc9a		arg1
	desc9a		arg2

	return		tnz

not_equal_e1:
	unless_optype	(variable,array_ref,temp),not_scalar

	swap		arg1
	unless_optype	constant,invalid_opnd
"				Operands remain swapped.
	dt_jump1		arg2,(not_equal_hi,not_equal_hr,not_equal_hd,not_equal_hc,logical_op1,not_equal_hh,not_equal_ht)

not_equal_hi:
not_equal_hr:
not_equal_ht:
	pad_char_const_to_word	arg2

	load_top		a
	cmpa		arg1
	return		tnz

not_equal_hd:
not_equal_hc:
	pad_char_const_to_dw	arg2

	load_top		aq
	cmpaq		arg1
	return		tnz


not_equal_tl:
	unless_dt		(int,typeless),typeless_op1
	dt_jump1		op2,(not_equal_tl.1,typeless_op2,typeless_op2,typeless_op2,typeless_op2,typeless_op2,not_equal_tl.1)

not_equal_tl.1:
	load_top		tq
	cmpq		arg1
	return		tnz

greater_or_equal:
	func		2

	use_ind

	dt_jump		(greater_or_equal_ii,greater_or_equal_ri,greater_or_equal_di,greater_or_equal_ci,greater_or_equal_ir,greater_or_equal_rr,greater_or_equal_dr,greater_or_equal_cr,greater_or_equal_id,greater_or_equal_rd,greater_or_equal_dd,greater_or_equal_cd,greater_or_equal_ic,greater_or_equal_rc,greater_or_equal_dc,greater_or_equal_cc,greater_or_equal_e2,greater_or_equal_e1,greater_or_equal_tl,greater_or_equal_tl)

greater_or_equal_ii:
	if_eaq		q,arg2,greater_or_equal_ii.1

	load		q,arg1
	cmpq		arg2
	return		tpl

greater_or_equal_ii.1:
	cmpq		arg1
	return		tmoz

greater_or_equal_ir:
	swap		arg1

	s_call		cv_load.ir
	fcmp		arg1
	return		tpl

greater_or_equal_ri:
	s_call		cv_load.ir
	fcmp		arg1
	return		tmoz

greater_or_equal_id:
	swap		arg1

	s_call		cv_load.id
	dfcmp		arg1
	return		tpl

greater_or_equal_di:
	s_call		cv_load.id
	dfcmp		arg1
	return		tmoz

greater_or_equal_rr:
	if_eaq		eaq,arg2,greater_or_equal_rr.1

	load		eaq,arg1
	round		eaq
	fcmp		arg2
	return		tpl

greater_or_equal_rr.1:
	round		eaq
	fcmp		arg1
	return		tmoz

greater_or_equal_dd:
	if_eaq		deaq,arg2,greater_or_equal_dd.1

	load		deaq,arg1
	round		deaq
	dfcmp		arg2
	return		tpl

greater_or_equal_dd.1:
	round		deaq
	dfcmp		arg1
	return		tmoz

greater_or_equal_rd:
	if_eaq		deaq,arg2,greater_or_equal_rd.1

	load		eaq,arg1
	dfcmp		arg2
	return		tpl

greater_or_equal_rd.1:
	round		deaq
	fcmp		arg1
	return		tmoz

greater_or_equal_dr:
	if_eaq		eaq,arg2,greater_or_equal_dr.1

	load		deaq,arg1
	round		deaq
	fcmp		arg2
	return		tpl

greater_or_equal_dr.1:
	dfcmp		arg1
	return		tmoz

greater_or_equal_ic:
	error		323,arg2

greater_or_equal_ci:
	error		323,arg1

greater_or_equal_rc:
	error		323,arg2

greater_or_equal_cr:
	error		323,arg1

greater_or_equal_dc:
	error		312,arg1,arg2

greater_or_equal_cd:
	error		311,arg1,arg2

greater_or_equal_cc:
	error		328,arg1,arg2

greater_or_equal_e2:
	if_dt		logical,logical_op1
	dt_jump1		arg1,(greater_or_equal_ih,greater_or_equal_rh,greater_or_equal_dh,greater_or_equal_ch,logical_op2,greater_or_equal_hh,greater_or_equal_th)

greater_or_equal_ih:
greater_or_equal_rh:
greater_or_equal_th:
	unless_optype	constant,invalid_opnd

	swap		arg1
	unless_optype	(variable,array_ref,temp),not_scalar

	pad_char_const_to_word	arg1	" the two operands remain swapped

	load		a,arg2
	cmpa		arg1
	return		trc

greater_or_equal_dh:
greater_or_equal_ch:
	unless_optype	constant,invalid_opnd

	swap		arg1
	unless_optype	(variable,array_ref,temp),not_scalar

	pad_char_const_to_dw	arg1	" the two operands remain swapped

	load		aq,arg2
	cmpaq		arg1
	return		trc

greater_or_equal_hh:
	use_eaq

	emit_eis
	cmpc		(pr),(pr),fill(040)
	desc9a		arg1
	desc9a		arg2

	return		trc

greater_or_equal_e1:
	unless_optype	(variable,array_ref,temp),not_scalar

	swap		arg1
	unless_optype	constant,invalid_opnd
"				Operands remain swapped.
	dt_jump1		arg2,(greater_or_equal_hi,greater_or_equal_hr,greater_or_equal_hd,greater_or_equal_hc,logical_op1,greater_or_equal_hh,greater_or_equal_ht)

greater_or_equal_hi:
greater_or_equal_hr:
greater_or_equal_ht:
	pad_char_const_to_word	arg2

	load		a,arg2
	cmpa		arg1
	return		trc

greater_or_equal_hd:
greater_or_equal_hc:
	pad_char_const_to_dw	arg2

	load		aq,arg2
	cmpaq		arg1
	return		trc

greater_or_equal_tl:
	unless_dt		(int,typeless),typeless_op1
	dt_jump1		op2,(greater_or_equal_tl.1,typeless_op2,typeless_op2,typeless_op2,typeless_op2,typeless_op2,greater_or_equal_tl.1)

greater_or_equal_tl.1:
	if_eaq		tq,arg2,greater_or_equal_tl.2

	load		tq,arg1
	cmpq		arg2
	return		tpl

greater_or_equal_tl.2:
	cmpq		arg1
	return		tmoz

greater:	func		2

	use_ind

	dt_jump		(greater_ii,greater_ri,greater_di,greater_ci,greater_ir,greater_rr,greater_dr,greater_cr,greater_id,greater_rd,greater_dd,greater_cd,greater_ic,greater_rc,greater_dc,greater_cc,greater_e2,greater_e1,greater_tl,greater_tl)

greater_ii:
	if_eaq		q,arg2,greater_ii.1

	load		q,arg1
	cmpq		arg2
	return		tpnz

greater_ii.1:
	cmpq		arg1
	return		tmi

greater_ir:
	swap		arg1

	s_call		cv_load.ir
	fcmp		arg1
	return		tpnz

greater_ri:
	s_call		cv_load.ir
	fcmp		arg1
	return		tmi

greater_id:
	swap		arg1

	s_call		cv_load.id
	dfcmp		arg1
	return		tpnz

greater_di:
	s_call		cv_load.id
	dfcmp		arg1
	return		tmi

greater_rr:
	if_eaq		eaq,arg2,greater_rr.1

	load		eaq,arg1
	round		eaq
	fcmp		arg2
	return		tpnz

greater_rr.1:
	round		eaq
	fcmp		arg1
	return		tmi

greater_dd:
	if_eaq		deaq,arg2,greater_dd.1

	load		deaq,arg1
	round		deaq
	dfcmp		arg2
	return		tpnz

greater_dd.1:
	round		deaq
	dfcmp		arg1
	return		tmi

greater_rd:
	if_eaq		deaq,arg2,greater_rd.1

	load		eaq,arg1
	dfcmp		arg2
	return		tpnz

greater_rd.1:
	round		deaq
	fcmp		arg1
	return		tmi

greater_dr:
	if_eaq		eaq,arg2,greater_dr.1

	load		deaq,arg1
	round		deaq
	fcmp		arg2
	return		tpnz

greater_dr.1:
	dfcmp		arg1
	return		tmi

greater_ic:
	error		323,arg2

greater_ci:
	error		323,arg1

greater_rc:
	error		323,arg2

greater_cr:
	error		323,arg1

greater_dc:
	error		312,arg1,arg2

greater_cd:
	error		311,arg1,arg2

greater_cc:
	error		328,arg1,arg2

greater_e2:
	if_dt		logical,logical_op1
	dt_jump1		arg1,(greater_ih,greater_rh,greater_dh,greater_ch,logical_op2,greater_hh,greater_th)

greater_ih:
greater_rh:
greater_th:
	unless_optype	constant,invalid_opnd

	swap		arg1
	unless_optype	(variable,array_ref,temp),not_scalar

	pad_char_const_to_word	arg1	" the two operands remain swapped

	load		a,arg1
	cmpa		arg2
	return		tnc

greater_dh:
greater_ch:
	unless_optype	constant,invalid_opnd

	swap		arg1
	unless_optype	(variable,array_ref,temp),not_scalar

	pad_char_const_to_dw	arg1	" the two operands remain swapped

	load		aq,arg1
	cmpaq		arg2
	return		tnc

greater_hh:
	use_eaq

	emit_eis
	cmpc		(pr),(pr),fill(040)
	desc9a		arg2
	desc9a		arg1

	return		tnc

greater_e1:
	unless_optype	(variable,array_ref,temp),not_scalar

	swap		arg1
	unless_optype	constant,invalid_opnd
"				Operands remain swapped.
	dt_jump1		arg2,(greater_hi,greater_hr,greater_hd,greater_hc,logical_op1,greater_hh,greater_ht)

greater_hi:
greater_hr:
greater_ht:
	pad_char_const_to_word	arg2

	load		a,arg1
	cmpa		arg2
	return		tnc

greater_hd:
greater_hc:
	pad_char_const_to_dw	arg2

	load		aq,arg1
	cmpaq		arg2
	return		tnc

greater_tl:
	unless_dt		(int,typeless),typeless_op1
	dt_jump1		op2,(greater_tl.1,typeless_op2,typeless_op2,typeless_op2,typeless_op2,typeless_op2,greater_tl.1)

greater_tl.1:
	if_eaq		tq,arg2,greater_tl.2

	load		tq,arg1
	cmpq		arg2
	return		tpnz

greater_tl.2:
	cmpq		arg1
	return		tmi

or:	func		2

	unless_dt		logical,or_e2
	swap		arg1
	unless_dt		logical,or_e1

	load_top		a
	ora		arg1
	return		a

or_e1:
	error		313,arg1

or_e2:
	error		313,arg2

and:	func		2

	unless_dt		logical,and_e2
	swap		arg1
	unless_dt		logical,and_e1

	load_top		a
	ana		arg1
	return		a

and_e1:
	error		313,arg1

and_e2:
	error		313,arg2

not:	func		1		

	unless_dt		logical,not.e

	if_eaq		ind,op1,not_ind

	load		a,op1
	era		=o400000,du
	return		a

not_ind:
	ind_jump		(not_tze,not_tnz,not_tmi,not_tpl,not_tmoz,not_tpnz,not_tnc,not_trc)

not_tze:
	return		tnz

not_tnz:
	return		tze

not_tmi:
	return		tpl

not_tpl:
	return		tmi

not_tmoz:
	return		tpnz

not_tpnz:
	return		tmoz

not_tnc:
	return		trc

not_trc:
	return		tnc

not.e:
	error		313,op1

equiv:	func		2

	unless_dt		logical,equiv.p
	swap		arg1
	unless_dt		logical,equiv.p

	use_ind

	load_top		a
	cmpa		arg1
	return		tze


not_equiv:
	func		2

	unless_dt		logical,not_equiv.p
	swap		arg1
	unless_dt		logical,not_equiv.p

	use_ind

	load_top		a
	cmpa		arg1
	return		tnz


equiv.p:
not_equiv.p:
	error		313,op1

jump:	proc		1


	shorten_stack

	tra		arg1
	return

jump_logical:
	proc		1

	unless_dt		logical,jump_logical.p

	shorten_stack	protect_indicators

	push_label

	if_eaq		ind,arg1,jump_logical_ind

	load		a,arg1


	if_ind		a,emit_tze

	cmpa		0,dl	" set the indicators

emit_tze:
	tze		op1
	jump		jl_statement

jump_logical_ind:


	ind_jump		(jump_logical_tze,jump_logical_tnz,jump_logical_tmi,jump_logical_tpl,jump_logical_tmoz,jump_logical_tpnz,jump_logical_tnc,jump_logical_trc)

jump_logical_tze:
	tnz		op1
	jump		jl_statement

jump_logical_tnz:
	tze		op1
	jump		jl_statement

jump_logical_tmi:
	tpl		op1
	jump		jl_statement

jump_logical_tpl:
	tmi		op1
	jump		jl_statement

jump_logical_tmoz:
	tpnz		op1
	jump		jl_statement

jump_logical_tpnz:
	tmoz		op1
	jump		jl_statement

jump_logical_tnc:
	trc		op1
	jump		jl_statement

jump_logical_trc:
	tnc		op1
	jump		jl_statement

jump_logical.p:
	print		324,op1
	scan		continue,next
	return

jl_statement:
	swap		arg1
	pop		op1

	scan		continue,next

	label		op1
	return

jump_arithmetic:
	proc		4

	swap		arg1

	unless_dt		(int,real,dp),jump_arithmetic.e

	shorten_stack

	if_dt		int,jump_arithmetic_i
	if_dt		real,jump_arithmetic_r
	swap		arg1

	unless_eaq	deaq,arg1,jump_arithmetic_r.1

	if_ind		deaq,jump_arithmetic.01

	fcmp		=0.,du
	in_reg		deaq,arg1

	jump		jump_arithmetic.01

jump_arithmetic_i:
	swap		arg1
	unless_eaq	q,arg1,jump_arithmetic_i.1

	if_ind		q,jump_arithmetic.01

	cmpq		0,dl
	in_reg		q,arg1

	jump		jump_arithmetic.01

jump_arithmetic_i.1:
	use_ind
	szn		arg1
	jump		jump_arithmetic.01

jump_arithmetic_r:
	swap		arg1

	unless_eaq	eaq,arg1,jump_arithmetic_r.1

	if_ind		eaq,jump_arithmetic.01

	fcmp		=0.,du
	in_reg		eaq,arg1

	jump		jump_arithmetic.01

jump_arithmetic_r.1:
	use_ind
	use_eaq			" so we dont have to invent use_eaq protect_indicators
	fszn		arg1
	jump		jump_arithmetic.01

jump_arithmetic.01:
	swap		arg1
	pop		arg4


	swap		arg2
	swap		arg1

	push_label

	swap		arg3
	if_optype		rel_constant,ja3

	copy		arg3
	swap		arg4
	pop		arg5

ja3:
	swap		arg3

	swap		arg2
	if_optype		rel_constant,ja2

	copy		arg2
	swap		arg4
	pop		arg5

ja2:
	swap		arg2

	swap		arg1
	if_optype		rel_constant,ja1

	copy		arg1
	swap		arg4
	pop		arg5

ja1:
	swap		arg1

	swap		arg3

	if		arg1,=,op1,jump_arithmetic_13
	if		arg2,=,op1,jump_arithmetic_23

	swap		arg1

	if		arg2,=,op1,jump_arithmetic_12

	swap		arg1
	swap		arg3

	tmi		arg1
	tze		arg2
	tra		arg3
	label		op1
	return

jump_arithmetic_12:
	swap		arg1
	swap		arg3

	tmoz		arg1
	tra		arg3
	label		op1
	return

jump_arithmetic_13:
	swap		arg3

	tnz		arg1
	tra		arg2
	label		op1
	return

jump_arithmetic_23:
	swap		arg3

	tpl		arg2
	tra		arg1
	label		op1
	return

jump_arithmetic.e:
	error		325,op1

jump_computed:
	proc		1

	if		arg1,<,1,jc_list.p

	copy		arg1

	push_label		"push fall_through label

	scan		jc_error,(continue,next)

	scan		continue,next

	unless_dt		(int,real,dp,cmpx),jump_computed.p

	shorten_stack

	if_dt		int,jump_computed_i
	if_dt		real,jump_computed_r
	if_dt		dp,jump_computed_d
	jump		jump_computed_r

jump_computed_i:
	load		q,op1
	jump		jc_transfer

jump_computed_r:
	s_call		cv_load.ri
	jump		jc_transfer

jump_computed_d:
	s_call		cv_load.di
	jump		jc_transfer

jc_transfer:
	pop		op1


	if_ind		q,jc_tmoz
	cmpq		0,dl

jc_tmoz:
	tmoz		arg3
	cmpq		arg1
	tpnz		arg3

	push_label
	adq		op1
	label		op1

	tra		0,ql

	pop		op1

jc_labels:
	copy		arg2
	tra		opv
	decrement		arg2,1
	if		arg2,^=,0,jc_labels

jc_ret:
	label		arg3	this is fall_through label
	return

jc_list.p:
	print		327

	scan		continue,(continue,next)
	scan		continue,next
	jump		jc_ret

jump_computed.p:
	print		326,arg1
	return

jc_error:
	print		342,op1

	scan		continue,(continue,next)
	scan		continue,next
	jump		jc_ret

jump_assigned:
	proc		1

	unless_dt		int,jump_assigned.e

	unless_array	jump_assigned.1

	print		300,op1

jump_assigned.1:
	use_ind
	shorten_stack

	ldx0		arg1

	tra		0,0
	return

jump_assigned.e:
	print		301,op1
	return

assign_label:
	proc		2

	unless_dt		int,assign_label.e
	unless_array	assign_label.1

	print		300,op1

assign_label.1:
	swap		arg1
	if_optype		rel_constant,assign_label.2

	" The label is on a format statement.

	load_pr		pr2,arg2
	sprp2		arg1
	flush_ref		arg1
	free_regs
	return

	" The label is on an executable statement.

assign_label.2:
	use_ind
	eax0		arg2
	stx0		arg1
	flush_ref		arg1
	return

assign_label.e:
	print		301,op1
	return

block_if:
	proc		2

	swap		arg1
	unless_dt		logical,block_if.p
	swap		arg1

	shorten_stack	protect_indicators

	push_label
	push_label

	" arg1: predicate
	" arg2: clause count
	" arg3: label for end of entire block IF
	" arg4: label for end of current clause

	if_eaq		ind,arg1,block_if.ind

	load		a,arg1
	if_ind		a,block_if.no_cmpa
	cmpa		0,dl

block_if.no_cmpa:
	tze		arg4
	jump		block_if.pop_predicate

block_if.ind:
	ind_jump		(block_if.tze,block_if.tnz,block_if.tmi,block_if.tpl,block_if.tmoz,block_if.tpnz,block_if.tnc,block_if.trc)

block_if.tze:
	tnz		arg4
	jump		block_if.pop_predicate

block_if.tnz:
	tze		arg4
	jump		block_if.pop_predicate

block_if.tmi:
	tpl		arg4
	jump		block_if.pop_predicate

block_if.tpl:
	tmi		arg4
	jump		block_if.pop_predicate

block_if.tmoz:
	tpnz		arg4
	jump		block_if.pop_predicate

block_if.tpnz:
	tmoz		arg4
	jump		block_if.pop_predicate

block_if.tnc:
	trc		arg4
	jump		block_if.pop_predicate

block_if.trc:
	tnc		arg4
	jump		block_if.pop_predicate

block_if.pop_predicate:

	" The predicate is no longer needed, so we can get rid of it now.
	" By doing this, we will avoid storing it.

	swap		arg1
	pop		op1
	swap		arg1

	" At this point, the stack format is
	" arg1: label for end of entire block IF
	" arg2: clause count
	" arg3: label for end of current clause

block_if_loop:
	scan		continue,(next,block_if_end)

	decrement		arg2,1
	if		arg2,=,0,block_if.no_tra
	tra		arg1

block_if.no_tra:
	label		arg3		" Mark end of clause

	if		arg2,=,0,block_if_loop
	pop		arg3
	push_label			" Get new end of clause lbl

	" The new end of clause label is passed to the first operator in
	" the new clause, which will either be an ELSE_IF or ELSE operator.

	copy		arg3
	jump		block_if_loop

block_if_end:
	label		arg1		" Mark end of block IF
	return

block_if.p:
	print		324,op1
	scan		continue,(continue,next)
	return

else_if:
	proc		2

	unless_dt		logical,else_if.p

	shorten_stack	protect_indicators

	" arg1: end of clause label
	" arg2: predicate

	if_eaq		ind,arg2,else_if.ind

	load		a,arg2
	if_ind		a,else_if.no_cmpa
	cmpa		0,dl

else_if.no_cmpa:
	tze		arg1
	return

else_if.ind:
	ind_jump		(else_if.tze,else_if.tnz,else_if.tmi,else_if.tpl,else_if.tmoz,else_if.tpnz,else_if.tnc,else_if.trc)

else_if.tze:
	tnz		arg1
	return

else_if.tnz:
	tze		arg1
	return

else_if.tmi:
	tpl		arg1
	return

else_if.tpl:
	tmi		arg1
	return

else_if.tmoz:
	tpnz		arg1
	return

else_if.tpnz:
	tmoz		arg1
	return

else_if.tnc:
	trc		arg1
	return

else_if.trc:
	tnc		arg1
	return

else_if.p:
	error		324,op1

else:
	proc		1

	" arg1: end of clause label

	" The else operator needn't do anything but pop the end of clause
	" label from the operand stack.

	return

read:	proc		2

	swap		arg1

	unless_dt		int,read.p

	swap		arg1
	load		q,arg1
	lda		arg2
	reserve_regs	(x6,pr1,pr2,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_read
	free_regs
	reset_eaq
	return

read.p:
	print		302,op1
	return

write:	proc		2

	swap		arg1

	unless_dt		int,write.p

	swap		arg1
	load		q,arg1
	lda		arg2
	reserve_regs	(x6,pr1,pr2,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_write
	free_regs
	reset_eaq
	return

write.p:
	print		302,op1
	return

format:	proc		1

	if_dt		char,format_c

	unless_dt		int,format.pp

	if_array		format_c

	" Must be an integer variable defined with a format value in an
	" ASSIGN statement.  The variable will contain a packed pointer
	" which locates the format string.

	reserve_regs	pr2
	lprp2		arg1
	push_builtin	ps
	spri2		op1+format_slot
	free_regs
	return

format.pp:
	error		329,arg1

format.pv:
	error		358,arg1

format_c:
	if_VLA		arg1,format.pv	" cannot be a Very Large Array
	load_pr		pr2,arg1
	push_builtin	ps
	spri2		op1+format_slot
	free_regs
	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

end_label:
	proc		1
	load_pr		pr5,arg1
	push_builtin	ps
	spri5		op1+end_label_slot
	free_regs
	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

error_label:
	proc		1

	load_pr		pr5,arg1
	push_builtin	ps
	spri5		op1+error_label_slot
	free_regs
	return

xmit_scalar:
	proc		1

	use_eaq

	load_pr		pr2,arg1

	dt_jump1		op1,(xs_i,xs_r,xs_d,xs_c,xs_l,xs_h,xs_t)

xs_i:
xs_t:
	lda		=1b18,du		=o400000
	jump		xs_transfer

xs_r:
	lda		=1b19,du		=o200000
	jump		xs_transfer

xs_d:
	lda		=1b20,du		=o100000
	jump		xs_transfer

xs_c:
	lda		=1b21,du		=o040000
	jump		xs_transfer

xs_l:
	lda		=1b22,du		=o020000
	jump		xs_transfer

xs_h:
	push_length	arg1
	lda		op1
	emit		1
	als		4
	ora		4096,du		=o010000

xs_transfer:
	reserve_regs	(x6,pr1,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_scalar_xmit
	free_regs
	reset_eaq
	return

xmit_array:
	proc		1

	use_eaq

	load_pr		pr2,arg1

	dt_jump1		op1,(xa_i,xa_r,xa_d,xa_c,xa_l,xa_h,xa_t)

xa_i:
xa_t:
	if_VLA		op1,xa_i_VLA
	lda		=65b24,du		=o404000
	jump		xa_transfer

xa_i_VLA:
	lda		=o406000,du
	jump		xa_transfer

xa_r:
	if_VLA		op1,xa_r_VLA
	lda		=33b24,du		=o204000
	jump		xa_transfer

xa_r_VLA:
	lda		=o206000,du
	jump		xa_transfer

xa_d:
	if_VLA		op1,xa_d_VLA
	lda		=17b24,du		=o104000
	jump		xa_transfer

xa_d_VLA:
	lda		=o106000,du
	jump		xa_transfer

xa_c:
	if_VLA		op1,xa_c_VLA
	lda		=9b24,du		=o044000
	jump		xa_transfer

xa_c_VLA:
	lda		=o046000,du
	jump		xa_transfer

xa_l:
	if_VLA		op1,xa_l_VLA
	lda		=5b24,du		=o024000
	jump		xa_transfer

xa_l_VLA:
	lda		=o026000,du
	jump		xa_transfer

xa_h:
	push_length	arg1
	lda		op1
	emit		1
	als		4
	ora		6144,du		=o014000

xa_transfer:
	push_array_size	arg1
	ldq		op1

	reserve_regs	(x6,pr1,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_array_xmit
	free_regs
	reset_eaq
	return

xmit_vector:
	proc		2

	load_pr		pr2,arg1
	load		q,arg2		" collapsed implied loop provides the count

	swap		arg1		"Note arguments remain swapped

	dt_jump1		op1,(xv_i,xv_r,xv_d,xv_c,xv_l,xv_h,xv_t)

xv_i:
xv_t:
	if_VLA		op1,xv_i_VLA
	lda		=65b24,du		=o404000
	jump		xv_transfer

xv_i_VLA:
	lda		=o406000,du
	jump		xv_transfer

xv_r:
	if_VLA		op1,xv_r_VLA
	lda		=33b24,du		=o204000
	jump		xv_transfer

xv_r_VLA:
	lda		=o206000,du
	jump		xv_transfer

xv_d:
	if_VLA		op1,xv_d_VLA
	lda		=17b24,du		=o104000
	jump		xv_transfer

xv_d_VLA:
	lda		=o106000,du
	jump		xv_transfer

xv_c:
	if_VLA		op1,xv_c_VLA
	lda		=9b24,du		=o044000
	jump		xv_transfer

xv_c_VLA:
	lda		=o046000,du
	jump		xv_transfer

xv_l:
	if_VLA		op1,xv_l_VLA
	lda		=5b24,du		=o024000
	jump		xv_transfer

xv_l_VLA:
	lda		=o026000,du
	jump		xv_transfer

xv_h:
	push_length	arg2
	lda		op1
	emit		1
	als		4
	ora		6144,du		=o014000

xv_transfer:

	reserve_regs	(x6,pr1,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_array_xmit
	free_regs
	reset_eaq
	return

endfile:	proc		2

	swap		arg1
	unless_dt		int,endfile.p

	load		q,arg2
	lda		arg1
	reserve_regs	(x6,pr1,pr2,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_manip
	free_regs
	reset_eaq
	return

endfile.p:
	print		302,op1
	return

rewind:	proc		2

	swap		arg1
	unless_dt		int,rewind.p

	load		q,arg2
	lda		arg1
	reserve_regs	(x6,pr1,pr2,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_manip
	free_regs
	reset_eaq
	return

rewind.p:
	print		302,op1
	return

backspace:
	proc		2

	swap		arg1
	unless_dt		int,backspace.p

	load		q,arg2
	lda		arg1
	reserve_regs	(x6,pr1,pr2,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_manip
	free_regs
	reset_eaq
	return

backspace.p:
	print		302,op1
	return

margin:	proc		2

	unless_dt		int,margin2.p
	swap		arg1
	unless_dt		int,margin1.p
	swap		arg1

	load		q,arg1
	push_builtin	ps
	lda		arg2
	sta		op1+margin_slot
	lda		=3b27,du		=o001400
	reserve_regs	(x6,pr1,pr2,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_manip
	free_regs
	reset_eaq
	return

margin1.p:
	print		302,op1
	return

margin2.p:
	print		331,op1
	return

openfile:	proc		3

	swap		arg1
	unless_dt		int,openfile1.p
	swap		arg1
	swap		arg2
	unless_dt		char,openfile2.p
	if_array		openfile2.p
	swap		arg2
	unless_dt		char,openfile3.p
	if_array		openfile3.p

	push_length	arg2
	push_builtin	ps
	load_pr		pr2,arg2
	spri2		op1+file_name_slot
	load_pr		pr2,arg3
	spri2		op1+file_type_slot
	lda		op2
	sta		op1+string_length_slot
	lda		=5b28,du		=o001200
	load		q,arg1
	reserve_regs	(x6,pr1,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_manip
	free_regs
	reset_eaq
	return

openfile1.p:
	print		302,op1
	return

openfile2.p:
	print		332,op1
	return

openfile3.p:
	print		333,op1
	return

open:
close:
	proc		4

"			arg1 - file number expre. must be integer
"			arg2 - job_bits const generated by compiler.
"			arg3 - open/close stmnt const generated by compiler.
"			arg4 - A count. Unused in macros.

	use_eaq
	reserve_regs	(x6,pr1,pr2,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_get_area_ptr	" returns ptr in PS.buffer_p
	free_regs

"		Now add a new arg4. Swap existing arg4 with the builtin ps_area_ptr

	pop		op1		" remove useless count
	push_builtin	ps_area_ptr	" area_ptr builtin becomes arg4
	push_count	0		" index value for bit-string


	lda		arg3	" fields-specified bit string

"		Note - The first time this loop is entered, arg5 is op1.

open_loop:
	load_pr_value	pr3,arg4			" reload pr3 if not already loaded

	eax1		op1	" load value of index into xr1 for runtime code

	tsx0		pr0|ftn_open_element
	reset_eaq

open_loop.2:
	scan		open_loop.e,(next,open_return)

"		Each successful scan adds two operands to the stack.
"		     op2 - A value. See individual field for specifics.
"		     op1 - A count. The index for the individual field.
"		This scan must be executed at least once to insure that existing error_label_op and
"		iostat_op are scanned before the code at label open_return is executed.

	jump_indexed	op1,(opencase1,opencase2,opencase3,opencase4,opencase5,opencase6,opencase7,opencase8,opencase9,opencase10,opencase11,opencase12,opencase13,opencase14)

opencase1:		" status
opencase2:		" io switch
opencase3:		" attach
opencase4:		" file
opencase5:		" mode
opencase6:		" access
opencase7:		" form
opencase13:		" blank
	swap		op2			" check data type
	unless_dt		char,open_loop1.p

	push_length	op1
	load_pr		pr2,op2			" point to string
	load		q,op1			" load string's length
	pop		op2			" pop back to count (index)
	jump		open_loop

opencase8:		" recl
	swap		op2			" check data type
	unless_dt		int,open_loop2.p

	load		q,op1			" load the value
	pop		op1			" pop back to count (index)
	jump		open_loop

opencase9:		" binary
opencase10:		" prompt
opencase11:		" carriage
opencase12:		" defer
	swap		op2			" check data type

	unless_dt		logical,open_loop3.p

	load		a,op1
	pop		op1			" pop back to count (index)
	jump		open_loop

opencase14:		" unit
	swap		op2			" get unit number
	swap		arg1			" save it
	pop		op2			" pop counts
	jump		open_loop.2		" no code generated now

open_loop.e:
	print		349
	jump		abort_list

open_loop1.p:
	print		351,op1
	jump		abort_list

open_loop2.p:
	print		352,op1
	jump		abort_list

open_loop3.p:
	print		353,op1
	jump		abort_list

open_return:
	swap		arg1			" get file number expre.
	unless_dt		int,open.p		" must be integer
	load		q,op1
	lda		arg2
	reserve_regs	(x6,pr1,pr2,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_manip
	free_regs
	reset_eaq
	return

open.p:
	error		302,op1

inquire:
	proc		3

	" arg1 - job bits
	" arg2 - fields specified bit mask
	" arg3 - count (unused in macros)

	" First get pointer to work area

	use_eaq
	reserve_regs	(x6,pr1,pr2,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_get_area_ptr
	free_regs

	pop		op1		" Pop useless count
	push_builtin	ps_area_ptr	" This becomes arg3

	" First pass thru loop is for fields specified mask

	push_count	0		" Field index
	lda		arg2

inquire_loop:
	load_pr_value	pr3,arg3		" Load pr3 if necessary
	eax1		op1		" Load field index
	tsx0		pr0|ftn_inquire_element
	reset_eaq

	scan		inquire_loop.e,(next,inquire_return)

	" Each successful scan pushes two operands onto the stack:
	"    op2 - A value (unit or filename) or reference (all others)
	"    op1 - A count (the field index)

	jump_indexed	op1,(inquire_case_1,inquire_case_2,inquire_case_3,inquire_case_4,inquire_case_5,inquire_case_6,inquire_case_7,inquire_case_8,inquire_case_9,inquire_case_10,inquire_case_11,inquire_case_12,inquire_case_13,inquire_case_14,inquire_case_15,inquire_case_16,inquire_case_17,inquire_case_18,inquire_case_19,inquire_case_20,inquire_case_21,inquire_case_22,inquire_case_23,inquire_case_24,inquire_case_25,inquire_case_26)


inquire_case_4:		" file
inquire_case_6:		" access
inquire_case_7:		" form
inquire_case_13:		" blank
inquire_case_21:		" name
inquire_case_22:		" sequential
inquire_case_23:		" formatted
inquire_case_24:		" unformatted
inquire_case_26:		" direct

	" First check data type.

	swap		op2
	unless_dt		char,inquire_loop.not_char

	" Load pointer in pr2, and length in Q.

	push_length	op1
	load_pr		pr2,op2
	load		q,op1

	pop		op2		" Pop back to field index
	jump		inquire_loop


inquire_case_8:		" recl
inquire_case_19:		" number
inquire_case_25:		" nextrec

	" First check data type.

	swap		op2
	unless_dt		int,inquire_loop.not_int

	" Load pr2 with pointer to integer.

	load_pr		pr2,op1

	pop		op1		" Pop back to field index
	jump		inquire_loop


inquire_case_14:		" unit

	" First check data type.

	swap		op2
	unless_dt		int,inquire_loop.not_int

	" Load unit number in Q.

	load		q,op1

	pop		op1		" Pop back to field index
	jump		inquire_loop


inquire_case_17:		" exist
inquire_case_18:		" opened
inquire_case_20:		" named

	" First check data type.

	swap		op2
	unless_dt		logical,inquire_loop.not_logical

	" Load pr2 with pointer to logical variable.

	load_pr		pr2,op1

	pop		op1		" Pop back to field index
	jump		inquire_loop


inquire_case_1:		" Invalid inquire fields
inquire_case_2:
inquire_case_3:
inquire_case_5:
inquire_case_9:
inquire_case_10:
inquire_case_11:
inquire_case_12:
inquire_case_15:
inquire_case_16:
	print		357,op1
	jump		abort_list


inquire_loop.e:
	print		356
	jump		abort_list

inquire_loop.not_char:
	print		351,op1
	jump		abort_list

inquire_loop.not_int:
	print		352,op1
	jump		abort_list

inquire_loop.not_logical:
	print		353,op1
	jump		abort_list


inquire_return:
	push_count	0		" Dummy unit number
	load		q,op1		" Get unit in Q
	lda		arg1		" Get job bits in A
	reserve_regs	(x6,pr1,pr2,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_manip
	free_regs
	reset_eaq
	return


closefile:
	proc		1

	unless_dt		int,closefile.p

	load		q,arg1
	lda		=3b28,du		=o000600
	reserve_regs	(x6,pr1,pr2,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_manip
	free_regs
	reset_eaq
	return

closefile.p:
	print		302,arg1
	return

iostat:
	proc		1

	unless_dt		int,iostat.p

	push_builtin	ps
	load_pr		pr2,arg1
	spri2		op1+iostat_slot
	free_regs

	return

iostat.p:
	print		350,op1
	return

record_number:
	proc		1

	unless_dt		int,record_number.p

	load		q,arg1
	push_builtin	ps
	stq		op1+record_number_slot
	return

record_number.p:
	print		304,arg1
	return

string:
	proc		1

	unless_dt		logical,string_c

	print		305,arg1

string_c:
	load_pr		pr2,arg1
	push_builtin	ps
	spri2		op1+string_slot
	free_regs
	return

string_length:
	proc		1

	load		q,arg1
	push_builtin	ps
	stq		op1+string_length_slot
	return

read_internal_file:
write_internal_file:
	proc		1

	unless_dt		char,internal_file.p

	push_builtin	ps

	load_pr		pr2,arg1
	spri2		arg2+string_slot

	push_length	arg1
	load		q,op1
	stq		arg2+string_length_slot
	pop		op1

	swap		arg1
	if_array		internal_file.array

	stz		arg1+buffer_size_slot
	jump		internal_file.ret

internal_file.array:
	push_array_size	op1
	load		q,op1
	stq		arg1+buffer_size_slot

internal_file.ret:
	free_regs
	return


internal_file.p:
	error		303


terminate:
	proc		0

	reserve_regs	(x6,pr1,pr2,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_terminate
	free_regs
	reset_eaq
	return

sf_def:	proc		1

	push_label
	s_func_label	arg1
	label		op1

	push_temp		int
	sxl0		arg3

	scan		sf_def.p,next

	copy		arg1

	dt_jump		(sf_def_ii,sf_def_ri,sf_def_di,sf_def_ci,sf_def_ir,sf_def_rr,sf_def_dr,sf_def_cr,sf_def_id,sf_def_rd,sf_def_dd,sf_def_cd,sf_def_ic,sf_def_rc,sf_def_dc,sf_def_cc,sf_def_e2,sf_def_e1,sf_def_e2,sf_def_e1)

sf_def_ii:
	load		q,op2
	jump		sf_def_ret

sf_def_ir:
	pop		op1
	s_call		cv_load.ir
	jump		sf_def_ret

sf_def_ri:
	pop		op1
	s_call		cv_load.ri
	jump		sf_def_ret

sf_def_id:
	pop		op1
	s_call		cv_load.id
	jump		sf_def_ret

sf_def_di:
	pop		op1
	s_call		cv_load.di
	jump		sf_def_ret

sf_def_ic:
	pop		op1
	s_call		cv_load.ir
	push_temp		real
	store		eaq,op1,no_update
	load		a,op1
	ldq		=0.,du
	jump		sf_def_ret

sf_def_ci:
	pop		op1
	s_call		cv_load.ri
	jump		sf_def_ret

sf_def_rd:
sf_def_rr:
	load		eaq,op2
	jump		sf_def_ret

sf_def_dr:
sf_def_dd:
	load		deaq,op2
	jump		sf_def_ret

sf_def_dc:
	swap		op2
	call		round_dp_to_real
	swap		op2

sf_def_rc:
	load		a,op2
	ldq		=0.,du
	jump		sf_def_ret

sf_def_cr:
	load		eaq,op2
	jump		sf_def_ret

sf_def_cd:
	load		deaq,op2
	jump		sf_def_ret

sf_def_cc:
	load		aq,op2
	jump		sf_def_ret

sf_def_e2:
	unless_dt		logical,sf_def.p0

	swap		op2
	unless_dt		logical,sf_def_e1

	load		a,op1
	jump		sf_def_ret

sf_def_e1:
	print		346,arg1
	return

sf_def_ret:
	use_ind

	lxl0		arg3
	tra		0,0

	pop		arg1		" Force all temps to be freed, then s_func_finish makes them go away

	s_func_finish

	return

sf_def.p:
	print		306,arg1
	scan		continue,next
	return

sf_def.p0:
	print		347,arg1
	return

sf:	func		2

	if		arg2,=,0,sf_no_args

	push_count	1

sf_loop:
	push_s_func_var	arg1,sf_too_many.p

	if		op2,=,1,sf_skip

	swap		arg3
	swap		op2
	swap		arg3

sf_skip:
	increment		arg3,1

	scan		sf_error_r,next

	dt_jump		(sf_ii,sf_ri,sf_di,sf_ci,sf_ir,sf_rr,sf_dr,sf_cr,sf_id,sf_rd,sf_dd,sf_cd,sf_ic,sf_rc,sf_dc,sf_cc,sf_e2,sf_e1,sf_e2,sf_e1)

sf_ii:
	load		q,op1
	stq		op2
	jump		sf_r

sf_ir:
	s_call		cv_load.ri
	stq		op2
	jump		sf_r

sf_ri:
	s_call		cv_load.ir
	store		eaq,op2,no_update
	jump		sf_r

sf_id:
	s_call		cv_load.di
	stq		op2
	jump		sf_r

sf_di:
	s_call		cv_load.id
	store		deaq,op2,no_update
	jump		sf_r

sf_rr:
	load		eaq,op1
	store		eaq,op2,no_update
	jump		sf_r

sf_dd:
	load		deaq,op1
	store		deaq,op2,no_update
	jump		sf_r

sf_rd:
	load		deaq,op1
	fstr		op2
	jump		sf_r

sf_dr:
	load		eaq,op1
	store		deaq,op2,no_update
	jump		sf_r

sf_ic:
	s_call		cv_load.ri
	stq		op2
	jump		sf_r

sf_ci:
	s_call		cv_load.ir
	store		eaq,op2,no_update
	fld		=0.,du
	fst		op2+1
	jump		sf_r

sf_rc:
	load		eaq,op1
	store		eaq,op2,no_update
	jump		sf_r

sf_cr:
	load		eaq,op1
	store		eaq,op2,no_update
	fld		=0.,du
	fst		op2+1
	jump		sf_r

sf_dc:
	load		eaq,op1
	store		deaq,op2,no_update
	jump		sf_r

sf_cd:
	load		deaq,op1
	store		eaq,op2,no_update
	fld		=0.,du
	fst		op2+1
	jump		sf_r

sf_cc:
	use_eaq
	load		aq,op1
	staq		op2
	jump		sf_r

sf_e1:
	print		334,arg1,op2
	jump		sf_error_r

sf_e2:
	if_dt		logical,sf_l
	if_dt		char,sf_h

	print		334,arg1,op1
	jump		sf_error_r

sf_l:
	swap		op2
	unless_dt		logical,sf_e1

	swap		op2

	load		a,op1
	sta		op2
	jump		sf_r

sf_h:
	swap		op2
	unless_dt		char,sf_e1

	emit_eis

	mlr		(pr),(pr),fill(040)
	desc9a		op2
	desc9a		op1
	jump		sf_r

sf_r:
	swap		arg3
	if		arg2,>=,op1,sf_loop

sf_no_args:
	push_sf_arg_count	arg1
	if		arg2,<,op1,sf_insuf.p

	push_s_func_label	arg1

	use_eaq
	reserve_regs	all-pr4
	tsx0		op1
	free_regs

	scan		continue,(continue,next)

	dt_jump1		arg1,(sf_ret_i,sf_ret_r,sf_ret_d,sf_ret_c,sf_ret_l,sf_ret_h,sf_ret_t)

sf_ret_i:
sf_ret_t:
	push_temp		int
	in_reg		q,op1
	use_ind
	return		op1

sf_ret_r:
	push_temp		real
	in_reg		eaq,op1
	use_ind
	return		op1

sf_ret_d:
	push_temp		dp
	in_reg		deaq,op1
	use_ind
	return		op1

sf_ret_c:
	push_temp		cmpx
	in_reg		aq,op1
	use_ind
	return		op1

sf_ret_l:
	push_temp		logical
	in_reg		a,op1
	use_ind
	return		op1

sf_ret_h:
	error		343,arg1

sf_error_r:
	scan		continue,(continue,next)

	error

sf_insuf.p:
	print		307,arg1
	jump		sf_error_r

sf_too_many.p:
	print		308,arg1
	jump		sf_error_r

item:	proc		0

	exit		1
	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

exit:	proc		0

	exit		1
	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

eol:	proc		0

	exit		2
	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

return:	proc		0

	unless_main	quick_return

	tra	pr0|fortran_end

	return

quick_return:
	push_builtin entry_info

	rtcd		op1

	return

pause:	proc		1

	use_eaq
	push_length	arg1
	if		op1,=,0,short_pause

	load_pr		pr2,arg1
	ldq		op1

	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)

pause.1:
	tsx0		pr0|fortran_pause
	free_regs
	reset_eaq
	return

short_pause:
	ldq		op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr2,pr3,pr4,pr5,pr7)
	jump		pause.1

stop:	proc		1

	use_eaq
	push_length	arg1
	if		op1,=,0,short_stop

	load_pr		pr2,arg1
	ldq		op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)

stop.1:
	tsx0		pr0|fortran_stop
	reset_regs
	reset_eaq
	return

short_stop:
	ldq		op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr2,pr3,pr4,pr5,pr7)
	jump		stop.1

subscript:
	func		2

	start_subscript

subscript_scan:
	scan		subscript_err,(next,subscript_end)

	if_dt		int,process_subscript
	if_optype		constant,convert_subscript
	unless_dt		(real,dp,cmpx),subscript_dt_err

	if_dt		dp,subscript_dp
	push_temp		int
	load		eaq,op2
	round		eaq
	use_eaq
	tsx0		pr0|real_to_integer
	in_reg		q,op1
	swap		op2
	pop		op1
	jump		process_subscript

subscript_dp:
	push_temp		int
	load		deaq,op2
	round		deaq
	use_eaq
	tsx0		pr0|double_to_integer
	in_reg		q,op1
	swap		op2
	pop		op1
	jump		process_subscript

convert_subscript:
	convert_constant	int
	jump		process_subscript

process_subscript:
	next_subscript
	jump		subscript_scan

subscript_dt_err:
	print		458,op1,arg1

subscript_err:
	subscript_error

subscript_end:
	finish_subscript

	return		op1

substr:	func	3

	" arg1 - parent of substring reference
	" arg2 - index of first character in substring
	" arg3 - index of last character in substring
	" value returned is a filled-in array_ref node

	" Make sure parent is of data type character

	swap	arg1
	unless_dt	char,substr.not_char
	swap	arg1

	" Coerce first index to integer

	swap	arg2
	s_call	coerce_substr_exp
	swap	arg2

	" Coerce last character index to integer

	s_call	coerce_substr_exp

	" Now build a substring reference and return it

	make_substring

	return	op1

substr.not_char:
	error	159,op1


coerce_substr_exp:

	if_dt	int,cse_return

	if_optype	constant,cse_convert_constant

	if_dt	(real,cmpx),cse_convert_real

	if_dt	dp,cse_convert_dp

	error	459,op1,arg1

	s_return

cse_convert_constant:
	convert_constant int
	s_return

cse_convert_real:
	push_temp	int
	load	eaq,op2
	round	eaq
	use_eaq
	tsx0	pr0|real_to_integer
	in_reg	q,op1
	swap	op2
	pop	op1
	s_return

cse_convert_dp:
	push_temp	int
	load	deaq,op2
	round	deaq
	use_eaq
	tsx0	pr0|double_to_integer
	in_reg	q,op1
	swap	op2
	pop	op1

cse_return:
	s_return

func_ref:	func		2

	s_call		evaluate_arglist

	dt_jump1		arg1,(int_func,real_func,dp_func,cmpx_func,logical_func,char_func,typeless_func)

char_func:
	push_length	arg1
	unless_optype	count,func_ref.star_extent
	push_char_temp	var

	s_call		descriptor_check

	jump		func_join

int_func:
typeless_func:
	push_temp		int
	jump		func_join

real_func:
	push_temp		real
	jump		func_join

dp_func:
	push_temp		dp
	jump		func_join

cmpx_func:
	push_temp		cmpx
	jump		func_join

logical_func:
	push_temp		logical

func_join:
	increment		arg2,1	function result becomes last arg

	set_in_storage	op1	" return value is in storage on return from func

	s_call		make_call

	return		op2		arglist temp is now op1

func_ref.star_extent:
	error		355,arg1

main:	proc		2

	emit_entry_defs
	emit		1
	oct		000000300000	" revision_1, entry_defs
	s_call		make_entry
	s_call		prepare_for_namelists
	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

subr:	proc		2

	emit_entry_defs
	emit		1
	oct		000000300000	" revision_1, entry_defs
	s_call		make_entry
	s_call		make_quick_entry
	s_call		prepare_for_namelists
	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

func:	proc		2

	emit_entry_defs
	emit		1
	oct		000000320000	" revision_1, entry_defs, func
	s_call		make_entry
	s_call		make_quick_entry
	s_call		prepare_for_namelists
	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

block_data:
	proc		0

	return

make_entry:
	assign_entry	arg1

	emit		1
	eax7		0

	epp2		pr7|stack_header.pl1_operators_ptr,*

	if_needs_descriptors arg1,make_et_desc
	tsp2		pr2|ext_entry
	jump		make_et_join

make_et_desc:
	tsp2		pr2|ext_entry_desc

make_et_join:
	copy		arg2
	multiply		op1,2
	zero		op1
	pop		op1

	emit		1
	zero

	emit_profile_entry		" if we will do long_profile set it up

	unless_hfp	make_et_init_auto
	tsx0		pr0|enter_HFP_mode

make_et_init_auto:
	call		init_auto

	unless_cleanup	make_et_no_cleanup	"no cleanup needed

	tsx0		pr0|fort_cleanup
	emit_cleanup_args

make_et_no_cleanup:
	push_builtin	null
	push_builtin	ps

	if		op2,=,op1,pop_ps

	load_pr		pr2,op1
	spri2		pr6|ps_ptr
	spri6		pr2|0
	free_regs

pop_ps:	pop		op2
	unless_storage_created make_et_descp		is there external storage?
	reserve_regs	all			calling external routines
	tsx0		pr0|fort_storage		request storage create/init
	emit_storage_args
	free_regs

make_et_descp:

	epp1		pr6|stack_frame.arg_ptr,*

	unless_needs_descriptors arg1,make_et_ret

	epp3		pr6|descriptor_ptr,*	Load desc ptr

make_et_ret:
	s_return

prepare_for_namelists:
	unless_namelist_used  pfn_ret

	push_builtin	star_symbol
	push_builtin	ps

	load_pr		pr2,op2
	spri2		op1+2

	set_runtime_block_loc

	adwp2		0,du
	spri2		op1+4

	free_regs
	pop		op2

pfn_ret:

	s_return

init_auto:
	proc		0

	push_builtin	auto_overlay

	push_length	op1

	if		op1,=,0,init_return

	push_builtin	auto_template

	emit_eis

	mlr		(pr),(pr),fill(0)
	desc9a		op1
	desc9a		op3

init_return:
	return

make_quick_entry:
	copy		arg1	Copy original symbol for entry
	get_quick_label	arg1	Replace arg1 with label for quick entry pt

"If storage space needs to be created then we substitute fort_return_mac for
"return_op to get the storage released at the end of the external call.

	unless_cleanup	mqe_no_storage
	epp2		pr0|fort_return_mac
	jump		mqe_end_storage

mqe_no_storage:
	epp2		pr0|return_op

mqe_end_storage:
	label		arg1
	push_builtin	entry_info

	spri2		op1	Store return pointer
	spri1		op1+2	Store arg pointer
	arg_ptr_in_pr1		Update machine state

	unless_needs_descriptors op2,mqe_no_desc
	spri3		op1+4	Store descriptor pointer
	desc_ptr_in_pr3		Update machine state

mqe_no_desc:
	swap		op2	Get original entry symbol on top
	pop		op1	Pop it off

	s_return

process_param_list:
	proc		1
	scan		abort_list,(continue,next)

	check_parameters
	return

descriptor_check:

	" Subroutine to check to see whether or not descriptors might be
	" required for a subroutine call or function reference.  In ansi66
	" mode, we print a message warning the user that descriptors might
	" be necessary.  In ansi77 mode, we go ahead and cause descriptors
	" to be used (silently).  In either mode, if the called subprogram
	" is local to this compilation, then it will already have been taken
	" care of by the storage allocator.

	" Called from func_ref (to check the function return value of
	" character valued functions) and from evaluate_arglist.

	" Assumes that arg1 is the external symbol.

	if_local		arg1,descriptor_check.return
	if_needs_descriptors arg1,descriptor_check.return
	if_ansi77		descriptor_check.set

	" Print a warning that this call might need descriptors

	print		348,arg1
	jump		descriptor_check.return

descriptor_check.set:

	" Cause descriptors to be generated for this call

	set_needs_descriptors		" arg1 implied

descriptor_check.return:
	s_return

increment_polish:
	proc		0

	skip_data

	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

label_operator:
	proc		1

	label		arg1

	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

stat:	proc		0

	shorten_stack
	stat

	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

call:	proc		2

"
	s_call		evaluate_arglist
	s_call		make_call

	return

evaluate_arglist:
	scan		abort_list,(next,check_args)
	if_optype		bif,conv_bif
	if_optype		external,conv_external

	unless_dt		char,evaluate_arglist

	" If argument is of data type character, check to see if we should
	" warn the user about descriptors or just use them.

	s_call		descriptor_check

	jump		evaluate_arglist

conv_bif:
	call		cv_bif_to_external
	jump		evaluate_arglist

conv_external:
	if_parameter	op1,evaluate_arglist	" parameters already are external variables

	call		make_external_variable
	jump		evaluate_arglist

check_args:
	check_arg_list
	s_return

cv_bif_to_external:
	func		1

	push_bif_index	arg1	" get index into big table
"				now get offset into vector
	push_count_indexed	op1,(38,39,40,19,2,12,21,3,13,4,14,5,15,7,17,23,41,42,43,1,11,20,0,0,0,0,0,0,0,0,0,0,0,0,57,58,10,44,45,46,6,16,22,9,18,24,8,0,47,0,0,0,0,0,48,0,0,49,26,27,28,29,30,31,0,0,32,50,0,0,0,0,36,34,37,35,33,51,52,53,54,55,56,0,0,0,0,59,60,61,62,0,0)

	if		op1,=,0,not_external_bif

	reserve_regs	(x2,pr2,pr4)
	use_eaq

	eax2		op1
	tsx0		pr0|get_math_entry

	jump		ext_join

not_external_bif:
	error		461,arg1

make_external_variable:
	func		1

	load_pr		pr2,arg1

ext_join:
	push_builtin	null_ptr
	push_temp		4

	spri2		op1
	load		aq,op2
	staq		op1+2

	free_regs
	return		op1

make_call:
	copy		arg2		get nargs

	unless_needs_descriptors	arg1,inc_for_hdr
	multiply		op1,2

inc_for_hdr:
	increment		op1,1		(for header)

	unless_parameter	arg1,double_count
	increment		op1,1		for display pointer

double_count:
	multiply		op1,2		double to get size of temp

	if_local		arg1,local_call

	push_temp		var

	store_arg_addrs

	make_descriptors

	use_eaq				" any temps that need to be saved...
	reserve_regs	indices		... must be saved now
	free_regs				we still might need xregs for > 16K addressing

	eax1		op1
	multiply		arg2,2048
	fld		arg2

	load_pr		pr2,arg1

	reserve_regs	all		all regs may be used by the call programs

	if_parameter	arg1,call_variable

	if_needs_descriptors	arg1,call_ext_desc

	tsx0		pr0|call_ext_out
	jump		call_join

call_ext_desc:
	tsx0		pr0|call_ext_out_desc
	jump		call_join

call_variable:
	if_needs_descriptors	arg1,call_variable_desc

	tsx0		pr0|call_var
	jump		call_join

call_variable_desc:
	tsx0		pr0|call_var_desc

call_join:
	free_regs
	free_descriptors
	s_return


local_call:
	if_constant_addrs	use_itp

	push_temp		var

	store_arg_addrs

	make_descriptors

	multiply		arg2,2048
	use_eaq
	fld		arg2
	staq		op1

local_join:
	load_pr		pr1,op1

	unless_needs_descriptors arg1,lc_no_desc

	lda		pr1|0	Get 2*nargs in au
	epp3		pr1|2,au	Load descriptor pointer

lc_no_desc:
	get_quick_label	arg1	replace external ref with label for quick entry point

	reserve_regs	all-pr4

	tsp2		arg1

	free_regs
	free_descriptors
	s_return

use_itp:
	gen_itp_list		replaces top of stack with constant arg list
	use_eaq
	jump		local_join

chain:	proc		3

	swap		arg1

	if_dt		char,chain2
	unless_dt		int,chain_path.p
	unless_array	chain_path.p

chain2:
	swap		arg1

	swap		arg2

	if_dt		char,chain3
	unless_dt		int,chain_sys.p
	unless_array	chain_sys.p

chain3:
	swap		arg2

	copy		arg3
	increment		op1,47
	push_temp		var

chain_fill:
	use_eaq

	ldq		arg3
	stq		op1

	emit_eis
	mlr		(pr),(pr)
	desc9a		arg1,168
	desc9a		op1+1,168

	ldaq		arg2
	staq		op1+45

	load_pr		pr2,op1
	emit		1
	eax0		0

chain_next_file:
	scan		next,(next,chain_ret)

	ldq		op1
	stq		op2+47,0
	eax0		1,0
	jump		chain_next_file

chain_ret:
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr2,pr3,pr4,pr5,pr7)

	tsx0		pr0|fortran_chain
	free_regs
	reset_eaq

	return

chain_path.p:
	print		335,op1
	scan		continue,(continue,next)
	return

chain_sys.p:
	print		336,op1
	scan		continue,(continue,next)
	return

endunit:	proc		0

	end_unit
	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

non_executable:
	proc		0
	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

no_op:	proc		0
	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

form_VLA_packed_ptr:
	func		1
	load		q,arg1
	div		pr0|VLA_words_per_seg
	emit_inst		2
	als		18
	llr		18
	return		q

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

opt_subscript:
	proc		2

	optimized_subscript
	return

left_shift:
	func		2

	load		q,arg1
	qls		arg2

	return		q

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

right_shift:
	func		2

	load		q,arg1
	qrs		arg2

	return		q

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

store_zero:
	proc		1

	stz		arg1
	flush_ref		arg1

	return

storage_add:
	proc		2

	load		q,arg2
	use_ind
	asq		arg1
	flush_ref		arg1

	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

storage_sub:
	proc		2

	load		q,arg2
	use_ind
	ssq		arg1
	flush_ref		arg1

	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

neg_storage_add:
	proc		2

	use_eaq
	lcq		arg2
	asq		arg1
	flush_ref		arg1

	return

storage_add_one:
	proc		1

	use_ind

	aos		arg1
	flush_ref		arg1

	return

namelist:	proc		1

	push_builtin	ps
	load_pr		pr2,arg1
	spri2		op1+namelist_slot

	free_regs
	return

cat:	func		2

	unless_ansi77	cat.not_ansi77

	swap		arg1
	unless_dt		char,cat.p
	swap		arg1
	unless_dt		char,cat.p

	start_cat		cat.dont_copy_arg1

	emit_eis		equal_lengths
	mlr		(pr),(pr),fill(040)
	desc9a		arg1
	desc9a		op1

cat.dont_copy_arg1:
	continue_cat

	emit_eis		equal_lengths
	mlr		(pr),(pr),fill(040)
	desc9a		arg2
	desc9a		op1

	finish_cat

	return		op1


cat.p:
	error		354,op1

cat.not_ansi77:
	error		153

lhs_fld:
	proc		4
	lhs_fld
	return

	" These should never appear in the polish.  They are only used on the
	" optimizing side.

convert_to_int: 
convert_to_real:
convert_to_dp:
convert_to_cmpx:
read_scalar:
read_array:
read_vector:
write_scalar:
write_array:
write_vector:
jump_true:
jump_false:
sub_index:
loop_end:
read_namelist:
write_namelist:
decode_string:
encode_string:
load_xreg:
load_preg:
	error	455

	end
