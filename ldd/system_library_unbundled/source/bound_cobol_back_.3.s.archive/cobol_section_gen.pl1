/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8060 cobol_section_gen.pl1 Reformatted code to new Cobol standard.
                                                   END HISTORY COMMENTS */


/*{*/
/* format: style3 */
cobol_section_gen:
     proc (in_token_ptr);

/*
The procedure cobol_section_gen performs the following functions:

  1.  Generates an end-of-perform range alterable GO and incre-
      ments perform_para_index by 1 if the paragraph being ter-
      minated is at the end of a perform range as determined by
      examining para_eop_flag ((1, it is; 0, it is not).

  2.  Generates the number of end-of-perform range alterable GO's
      dictated by the value of sect_eop_flag; 0, 1, or 2.

  3.  Determines if the section being entered is at the end of a
      PERFORM statement and/or SORT statement perform range by
      examining perform_list.perf.proc_num(perform_para_index).
      If it is not, sect_eop_flag is set to 0.  If it is, sect_
      eop_flag is set to 1, perform_sect_index is set equal to
      perform_para_index, and perform_para_index is incremented
      by 1.  Then, perform_list.perf.proc_num(perform_para_index)
      is examined, using the new value of perform_para_index, to
      determine if the section has been referenced in both a 
      PERFORM and a SORT statement (in this case there are two
      entries for the procedure in perform_list  -  the first for
      PERFORM statements and the second for SORT statements).  If
      there is no second entry in perform_list for the section,
      then no further action is taken.  If there is, then sect_
      eop_flag and perform_para_index are both incremented by 1.

  4.  Determines if the section being entered must be initialized
      prior to its execution as a result of an implicit transfer
      of control from the preceding section.  (Initialization is
      required if the section being entered has a COBOL segment
      number different from that of its predessor and if the seg-
      ment of which the section is a member is independent and
      contains alterable GO's.)  If initialization is required,
      code is generated to cause execution of an initialization
      sequence for the segment prior to execution of code gener-
      ated to implement the statements that comprise the section.

  5.  Associates the section's procedure number with the text 
      location into which the first instruction emitted by the 
      next generator called will be placed (this is the first
      free text location following the code, if any, generated
      by cobol_section_gen).

U__s_a_g_e:_

     declare cobol_section_gen entry (ptr);

     call cobol_section_gen (in_token_ptr);

						   */

%include cobol_in_token;

/*
G__e_n_e_r_a_t_e_d_C__o_d_e:_

Two sequences of code may be generated by cobol_section_gen.  They
are as follows;

  Sequence 1:  Implements end-of-perform range alterable GO's.

  Sequence 2:  Implements the transfer of control to and estab-
	     lishes return from the appropriate segment initi-
	     alization code sequence.

Sequence 1 -

     lda  target_An
     tra  0,al

where:
target_An is a 36-bit variable allocated in the program's COBOL
	data segment.  Each target_An, for n = 1, 2, 3, ...,
	is uniquely associated with the procedure at whose end
	these instructions are generated.

Sequence 2 -

     eaa  2,ic
     tra  s_init_relp,ic

where:
s_init_relp is the offset, relative to the instruction in which
	  it appears, of the first instruction of the initial-
	  ization code sequence provided for the COBOL segment
	  of which the section being entered is a part.

Note that following the execution of the eaa instruction bits 0 -
17 inc. of the a-register (au) will contain the address of the
instruction following the tra instruction i.e. the address of the
first instruction generated to implement the statements contained
in the section being entered.  Since the terminal instruction of
the initialization sequences for independent segments (which do
not otherwise employ the a-register) is tra 0,au, control will
be transferred to this instruction.
						   */

/*
D__a_t_a:_

     % include cobol_;

	Items in cobol_$incl.pl1 used (u) and/or set (s) by
	cobol_section_gen;
	     cobol_ptr (u)
	     para_eop_flag (u/s)
	     perform_list_ptr (u)
	     perform_para_index (u/s)
	     perform_sect_index (u/s)
	     priority_no (u/s)
	     sect_eop_flag (u/s)
	     seg_init_list_ptr (u)
	     text_wd_off (u)

						   */

%include cobol_perform_altgo;
%include cobol_perform_list;
%include cobol_seg_init_list;
%include cobol_type7;


dcl	proc_no		fixed bin,		/* Tag number of the section being
			   entered.		   */
	index		fixed bin;		/* Do loop index.		   */

/* Instruction pair to transfer control to and establish return
   from independent segment initialization code sequence.	   */

dcl	seg_init_tra_inst_pr
			(4) bit (18) unaligned static
			init ("000000000000000010"b, "110011101000000100"b, "000000000000000000"b,
			"111001000000000100"b);	/*
The instructions produced are:
     eaa  2,ic,
     tra  0,1c
						   */

/*
P__r_o_c_e_d_u_r_e_s_C__a_l_l_e_d:_
						   */

dcl	cobol_addr	entry (ptr, ptr, ptr),
	cobol_define_tag	entry (fixed bin),
	cobol_emit	entry (ptr, ptr, fixed bin),
	cobol_make_tagref	entry (fixed bin, fixed bin, ptr),
	cobol_register$load entry (ptr);

/*
B__u_i_l_t-__i_n_F__u_n_c_t_i_o_n_s_U__s_e_d:_
						   */

dcl	addr		builtin,
	null		builtin,
	substr		builtin,
	unspec		builtin;

/*}*/

%include cobol_;

start:						/*  Get procedure (tag) number of section being entered.	   */
	proc_no = in_token.token_ptr (1) -> proc_def.proc_num;

/*		  "PERFORM" Functions		   */

	if cobol_$perform_list_ptr ^= null
	then do;

/* Paragraph terminated at end-of-perform range? */

		if cobol_$para_eop_flag ^= 0
		then /* Insert alterable GO */
		     do;
			call cobol_register$load (addr (register_request));
			input_struc_basic.segno = perform_list.perf.target_a_segno (cobol_$perform_para_index);
			input_struc_basic.char_offset =
			     perform_list.perf.target_a_offset (cobol_$perform_para_index);
			call cobol_addr (addr (input_struc_basic), addr (prfrm_altgo_inst_pr), null);
			call cobol_emit (addr (prfrm_altgo_inst_pr), null, 2);
			call cobol_define_tag (perform_list.perf.int_tag_no (cobol_$perform_para_index));
			cobol_$para_eop_flag = 0;
			cobol_$perform_para_index = cobol_$perform_para_index + 1;
		     end;

/* Section terminated at end-of-perform range? */

		do index = 1 to cobol_$sect_eop_flag;
		     call cobol_register$load (addr (register_request));
		     input_struc_basic.segno = perform_list.perf.target_a_segno (cobol_$perform_sect_index);
		     input_struc_basic.char_offset = perform_list.perf.target_a_offset (cobol_$perform_sect_index);
		     call cobol_addr (addr (input_struc_basic), addr (prfrm_altgo_inst_pr), null);
		     call cobol_emit (addr (prfrm_altgo_inst_pr), null, 2);
		     if in_token.token_ptr (1) -> proc_def.declarative_proc = "0"b
		     then call cobol_define_tag (perform_list.perf.int_tag_no (cobol_$perform_sect_index));

		     else perform_list.perf.int_tag_no (cobol_$perform_sect_index) =
			     -perform_list.perf.int_tag_no (cobol_$perform_sect_index);

		     cobol_$perform_sect_index = cobol_$perform_sect_index + 1;
		end;

/* Section entered at end-of-perform range? */

		cobol_$sect_eop_flag = 0;
		cobol_$perform_sect_index = cobol_$perform_para_index;
		if cobol_$perform_para_index <= perform_list.n
		then do while (proc_no = perform_list.perf.proc_num (cobol_$perform_para_index));
			cobol_$sect_eop_flag = cobol_$sect_eop_flag + 1;
			cobol_$perform_para_index = cobol_$perform_para_index + 1;
		     end;

	     end;

/*      Initialize segment containing section entered.	   */

	if cobol_$seg_init_list_ptr ^= null
	then do;
		if unspec (in_token.token_ptr (1) -> proc_def.priority)
		     ^= substr (unspec (cobol_$priority_no), 19, 18)
		then do;
			substr (unspec (cobol_$priority_no), 19, 18) =
			     unspec (in_token.token_ptr (1) -> proc_def.priority);
			if cobol_$priority_no > 49
			then do index = 1 to seg_init_list.n;
				if seg_init_list.seg.priority (index) = cobol_$priority_no
				then do;
					call cobol_emit (addr (seg_init_tra_inst_pr), null, 2);
					call cobol_make_tagref (seg_init_list.seg.int_tag_no (index),
					     cobol_$text_wd_off - 1, null);
					goto end_do_loop;
				     end;

			     end;
end_do_loop:
		     end;

	     end;

/*  Associate procedure number with next location in text.   */

	call cobol_define_tag (proc_no);

	return;

     end cobol_section_gen;
