/****^  *********************************************************
        *                                                       *
        * Copyright, (C) BULL HN Information Systems Inc., 1990 *
        *                                                       *
        * Copyright, (C) Honeywell Limited, 1983                *
        *                                                       *
        * Copyright (c) 1972 by Massachusetts Institute of      *
        * Technology and Honeywell Information Systems, Inc.    *
        *                                                       *
        ********************************************************* */



/****^  HISTORY COMMENTS:
  1) change(86-07-14,BWong), approve(86-07-14,MCR7382), audit(86-07-17,Ginter),
     install(86-07-28,MR12.0-1105):
     Fix fortran bug 472.
  2) change(86-10-17,Ginter), approve(86-10-17,MCR7556), audit(86-10-22,Huen),
     install(86-11-13,MR12.0-1216):
     Fixed fortran bugs 496 and 502.
  3) change(87-04-15,Huen), approve(87-04-15,MCR7651), audit(87-04-15,RWaters),
     install(87-05-08,MR12.1-1031):
     Fix fortran bug 431.
  4) change(90-04-27,Huen), approve(90-04-27,MCR8159), audit(90-05-16,Gray),
     install(90-05-30,MR12.4-1011):
     ft_512 : enable probe to display correct values for parameter variables
     when the object segments are bound.
                                                   END HISTORY COMMENTS */


/* format: style3,^delnl,ifthenstmt,^indattr,indcom,indend,^inditerdo,^indnoniterdo,indnoniterend,linecom */
fort_make_symbol_section:
     procedure (P_shared_global_ptr, P_cg_global_ptr, P_param_ptr, P_sym_offset, P_sym_length);

	/* Fortran compiler's routines for building the runtime symbol table.

Written:	21 August 1979 by C R Davis (actually stolen from the CGs).

Modified: 31 Mar 90, SH - 512: Set up relocation information for the symbol
          table entries that describe parameter variables.
Modified: 17 Feb 87, RW & SH - 431: Allow substrings in Equivalence 
          statements for ANSI 77.
Modified: 09 Sep 86, AG - 496: use symbol.addr_hold when creating runtime
	symbol table for VL Common blocks whose first element is a
	nondimensioned symbol.
Modified: 16 Oct 85, BW - 472: Don't put lines without object code in the
	statement map.
Modified: 28 Mar 84, HH - Install HFP support.
Modified: 29 Aug 83, RG - To change call from lang_util_ to ioa_$rsnnl
Modified: 31 Jan 83, TO - Install LA/VLA support.
Modified: 23 Dec 82, TO - 367: Implement PARAMETER variables in table.
Modified: 17 December 1982, TO - Add '-long_profile' support.
Modified: 17 May 1982, TO - fix to runtime reference to character*(*)
	multiplier.  This must be a byte multiplier, the descriptor mult is
	bits.  Refer now to extended multipler which ends extended
	descriptor.
Modified:  4 May 1982, TO - fix to put star_extent length correctly addressed
	by runtime_symbol.size.
Modified:  4 May 1982, TO - fix to get_address to reflect that stack_indirects
	have their stack location in symbol.location, not in
	symbol.address.offset.
Modified: 18 February 1981, CRD - change process_variable to fill in lower
	bound information for Fortran 77 arrays.
Modified: 15 October 1979, CRD - renamed fort_make_symbol_table to
	fort_make_symbol_section.
Modified: 12 Spetember 1979, CRD - fix bug 241 (runtime_symbol.next
	invalid when symbols more than 16K apart.
Modified: 30 August 1979, CRD - set runtime_symbol.units and
	runtime_symbol.array_units in preparation for ANSI 77
	character mode.
*/


declare						/* Parameters */

	P_shared_global_ptr pointer,			/* Input */
	P_cg_global_ptr pointer,			/* Input */
	P_param_ptr pointer,			/* Input */
	P_sym_offset fixed binary (18),		/* Input */
	P_sym_length fixed binary (18);		/* Output */


declare						/* Automatic */

	a_base pointer,
	cg_global_ptr pointer,
	def_pos fixed binary (18),
	def_reloc_base pointer,
	first_namelist fixed binary (18),
	generate_map bit (1) aligned,
	generate_profile bit (1) aligned,
	generate_symtab bit (1) aligned,
	info_ptr pointer,
	last_pos fixed binary (18),
	link_base pointer,
	link_pos fixed binary (18),
	link_reloc_base pointer,
	profile_start fixed binary (18),
	shared_global_ptr pointer,
	star_symbol_link fixed binary (18),
	sym_base pointer,
	sym_pos fixed binary (18),
	symrel fixed binary (18),
	sym_reloc_base pointer,
	symtab_param_ptr pointer,
	text_pos fixed binary (18);

declare						/* Overlays */

	a_name (0:261119 - 2 * (number_of_lines + 1)) fixed binary (18) aligned based (a_base),
	polish (0:polish_max_len - 1) fixed binary (18) aligned based (polish_base),
	quads (0:quad_max_len - 1) fixed binary (18) aligned based (quadruple_base),
	rands (0:operand_max_len - 1) fixed binary (18) aligned based (operand_base),
	reloc (0:3) bit (36) aligned based,
	vsegname character (32) varying defined (objectname);

declare

	1 text_halfs (0:262143) aligned based (object_base),
	  2 left fixed binary (17) unaligned,
	  2 right fixed binary (17) unaligned;


declare

	1 reloc_halfs (0:262143) aligned based (relocation_base),
	  2 left bit (18) unaligned,
	  2 right bit (18) unaligned;


declare						/* Builtins */

	(addr, addrel, binary, bit, divide, fixed, hbound, length, ltrim,
	max, min, mod, null, rel, size, string, substr, ptr, unspec, verify)
          builtin;

%include fort_nodes;

%include fort_opt_nodes;

%include fort_listing_nodes;

declare

	1 shared_globals structure aligned based (shared_global_ptr),

%include fort_shared_vars;

declare

	1 cg_globals structure aligned based (cg_global_ptr),

%include fort_cg_vars;

%include fort_options;

%include fort_system_constants;

declare

	1 symtab_parameters structure aligned based (symtab_param_ptr),

%include fort_symtab_parms;

%include pl1_symbol_block;

%include std_symbol_header;

%include profile_entry;
%include long_profile;

%include relbts;

	/* Copy input arguments */

	shared_global_ptr = P_shared_global_ptr;
	cg_global_ptr = P_cg_global_ptr;
	symtab_param_ptr = P_param_ptr;
	symrel = P_sym_offset;

	/* Copy status of partial object segment */

	link_base = symtab_parameters.link_base_ptr;
	link_reloc_base = symtab_parameters.link_reloc_base_ptr;
	def_reloc_base = symtab_parameters.def_reloc_base_ptr;
	text_pos = symtab_parameters.current_text_offset;
	def_pos = symtab_parameters.current_def_offset;
	link_pos = symtab_parameters.current_link_offset;
	last_pos = symtab_parameters.final_text_offset;
	profile_start = symtab_parameters.profile_offset;
	star_symbol_link = symtab_parameters.star_symbol_link;
	first_namelist = symtab_parameters.first_namelist_symbol;


	if shared_globals.options.list
	then a_base = addr (source_list (number_of_lines + 2));


	/* Set up symbol table and relocation pointers */

	sym_base = addrel (object_base, symrel);
	sym_reloc_base = addrel (relocation_base, symrel);
	sym_pos = 0;

	/* Decide how much of the symbol table to generate */

	generate_map = shared_globals.options.brief_table
	     | shared_globals.options.table
	     | shared_globals.options.profile;
	generate_profile = shared_globals.options.profile;
	generate_symtab = shared_globals.options.table
	     | shared_globals.options.namelist_used;

	/* Now start generating the symbol table */

	call init_symbol ();

	if generate_map
	then if shared_globals.options.optimize
	     then call gen_opt_statement_map ();
	     else call gen_statement_map ();

	if generate_symtab
	then do;
	     call make_symbol_table ();
	     call fill_sym_info_into_entries ();
	     if shared_globals.options.namelist_used
	     then call make_ok_lists ();
	     end;

	call end_symbol ();

	P_sym_length = sym_pos;			/* Return length */

	return;

init_symbol:
     procedure ();

	/* starts generating the symbol section */

dcl	(sym_ptr, map_ptr, sp, sym_reloc_ptr) ptr;

dcl	source_index fixed bin (18);
dcl	(m, n) fixed bin (18);

dcl	version_name_and_number char (148) varying;

dcl	fort_$symbol_table fixed bin (17) ext static;

dcl	size builtin;

%include source_map;

	/* generate symbol table header */

	sym_ptr = sym_base;
	sym_pos = size (std_symbol_header);

	sym_ptr -> std_symbol_header.dcl_version = 1;
	sym_ptr -> std_symbol_header.identifier = "symbtree";
	sym_ptr -> std_symbol_header.gen_number = 1;
	sym_ptr -> std_symbol_header.gen_created = addr (fort_$symbol_table) -> std_symbol_header.object_created;

	sym_ptr -> std_symbol_header.object_created = date_time_compiled;

	sym_ptr -> std_symbol_header.generator = compiler_name;

	version_name_and_number =
	     fort_version_info$version_name || fort_version_info$version_number;
						/* keep store_string quick */
	string (sym_ptr -> std_symbol_header.gen_version) = store_string (version_name_and_number);

	string (sym_ptr -> std_symbol_header.userid) = store_string (vuser_id);

	string (sym_ptr -> std_symbol_header.comment) = store_string (options_string);

	sym_ptr -> std_symbol_header.text_boundary,
	     sym_ptr -> std_symbol_header.stat_boundary = "000000000000000010"b;

	/* generate source map (which must start on even boundary) */

	sym_pos = sym_pos + mod (sym_pos, 2);

	sym_ptr -> std_symbol_header.source_map = bit (sym_pos, 18);

	map_ptr = addrel (sym_base, sym_pos);
	map_ptr -> source_map.version = 1;
	map_ptr -> source_map.number, n = number_of_source_segments;

	sym_pos = sym_pos + size (source_map);

	source_index = first_segment;

	do m = 1 to n;
	     sp = addr (rands (source_index));
	     string (map_ptr -> source_map.map (m).pathname) = store_string (sp -> source.pathname);
	     map_ptr -> source_map.map (m).uid = sp -> source.uid;
	     map_ptr -> source_map.map (m).dtm = sp -> source.dtm;
	     source_index = sp -> source.next;
	     end;

	/* generate pl1 symbol block */

	sym_ptr -> std_symbol_header.area_pointer = bit (sym_pos, 18);

	info_ptr, sym_ptr = addrel (sym_base, sym_pos);
	sym_reloc_ptr = addrel (sym_reloc_base, sym_pos);

	sym_pos = sym_pos + size (pl1_symbol_block);

	sym_ptr -> pl1_symbol_block.version = 1;
	sym_ptr -> pl1_symbol_block.identifier = "pl1info";
	sym_ptr -> pl1_symbol_block.greatest_severity = error_level;

	sym_ptr -> pl1_symbol_block.flags.io = shared_globals.options.namelist_used;
	sym_ptr -> pl1_symbol_block.flags.map = generate_map;

	string (sym_ptr -> pl1_symbol_block.segname) = store_string (vsegname);

	if generate_profile
	then do;
	     sym_ptr -> pl1_symbol_block.flags.profile = "1"b;
	     sym_ptr -> pl1_symbol_block.profile = bit (profile_start, 18);
	     sym_reloc_ptr -> pl1_symbol_block.profile = rc_is18;
	     sym_ptr -> pl1_symbol_block.flags.long_profile =
		shared_globals.options.long_profile;
	     end;

	sym_base -> std_symbol_header.maxi_truncate = bit (sym_pos, 18);

	return;
     end init_symbol;

gen_opt_statement_map:
     procedure ();

	/* generates statement_map to support brief_table & table */

dcl	(cs, stm, q, pp, next_stm_ptr) ptr;
dcl	first_code_loc fixed bin (18);
dcl	first_time bit (1) aligned;
dcl	last_code_loc fixed bin (18);
dcl	map_start fixed bin (18);
dcl	profile_pos fixed bin (18);
dcl	old_id bit (27);

%include statement_map;

	if shared_globals.options.long_profile
	then do;
	     profile_pos = profile_start + size (long_profile_header);
	     pp = addrel (link_base, profile_start);
	     pp -> long_profile_header.nentries = 0;
	     end;
	else profile_pos = profile_start;

	map_start = sym_pos;
	info_ptr -> pl1_symbol_block.map.first = bit (sym_pos, 18);
	first_time = "1"b;

	do cur_subprogram = first_subprogram repeat cs -> subprogram.next_subprogram
	     while (cur_subprogram > 0);
	     cs = addr (rands (cur_subprogram));
	     old_id = (27)"1"b;

	     cs -> subprogram.map.first = sym_pos;

	     do cur_statement = cs -> subprogram.first_quad repeat binary (stm -> opt_statement.next, 18)
		while (cur_statement > 0 | first_time);
		first_time = "0"b;
		stm = addr (quads (cur_statement));

		if stm -> opt_statement.put_in_map & ^stm -> opt_statement.moved
		then if old_id ^= unspec (stm -> opt_statement.source_id)
			| generate_profile & stm -> opt_statement.put_in_profile
		     then do;
			first_code_loc = binary (stm -> opt_statement.location, 18);
			if stm -> opt_statement.next = "0"b
			then last_code_loc = -1;
			else do;
			     next_stm_ptr = ptr (stm, stm -> opt_statement.next);
			     last_code_loc = binary (next_stm_ptr -> opt_statement.location, 18) - 1;
			     end;
			if last_code_loc >= first_code_loc
						/* Only put the line in the statement map if it contains object code. */
			then do;
			     old_id = unspec (stm -> opt_statement.source_id);

			     q = addrel (sym_base, sym_pos);
			     q -> statement_map.location = stm -> opt_statement.location;
			     unspec (q -> statement_map.source_id) = unspec (stm -> opt_statement.source_id);
			     q -> statement_map.source_info.start =
				bit (fixed (stm -> opt_statement.start, 18), 18);
			     q -> statement_map.source_info.length = stm -> opt_statement.length;

			     addrel (sym_reloc_base, sym_pos) -> reloc (0) = rc_t;

			     if generate_profile
			     then if stm -> opt_statement.put_in_profile
				then do;
				     addrel (link_base, profile_pos) -> profile_entry.map =
					bit (fixed (sym_pos - map_start, 18), 18);
				     if shared_globals.options.long_profile
				     then do;
					profile_pos = profile_pos + size (long_profile_entry);
					pp -> long_profile_header.nentries =
					     pp -> long_profile_header.nentries + 1;
					end;
				     else profile_pos = profile_pos + size (profile_entry);
				     end;

			     sym_pos = sym_pos + size (statement_map);
			     end;
			end;
		end;
	     cs -> subprogram.map.last = sym_pos;
	     end;

	/* generate dummy last entry */

	q = addrel (sym_base, sym_pos);
	q -> statement_map.location = bit (last_pos, 18);
	unspec (q -> statement_map.source_id) = (27)"1"b;

	addrel (sym_reloc_base, sym_pos) -> reloc (0) = rc_t;

	if generate_profile
	then addrel (link_base, profile_pos) -> profile_entry.map = bit (fixed (sym_pos - map_start, 18), 18);

	sym_pos = sym_pos + size (statement_map);

	info_ptr -> pl1_symbol_block.map.last = bit (sym_pos, 18);

     end gen_opt_statement_map;

gen_statement_map:
     procedure ();

	/* generates statement_map to support brief_table & table */

dcl	(cs, stm, q, pp, next_stm_ptr) ptr;
dcl	first_code_loc fixed bin (18);
dcl	first_time bit (1) aligned;
dcl	last_code_loc fixed bin (18);
dcl	map_start fixed bin (18);
dcl	profile_pos fixed bin (18);
dcl	old_id bit (27);

%include statement_map;

	if shared_globals.options.long_profile
	then do;
	     profile_pos = profile_start + size (long_profile_header);
	     pp = addrel (link_base, profile_start);
	     pp -> long_profile_header.nentries = 0;
	     end;
	else profile_pos = profile_start;

	map_start = sym_pos;
	info_ptr -> pl1_symbol_block.map.first = bit (sym_pos, 18);
	first_time = "1"b;

	do cur_subprogram = first_subprogram repeat cs -> subprogram.next_subprogram
	     while (cur_subprogram > 0);
	     cs = addr (rands (cur_subprogram));
	     old_id = (27)"1"b;

	     cs -> subprogram.map.first = sym_pos;

	     do cur_statement = cs -> subprogram.first_polish repeat binary (stm -> statement.next, 18)
		while (cur_statement > 0 | first_time);
		first_time = "0"b;
		stm = addr (polish (cur_statement));

		if stm -> statement.put_in_map
		then if old_id ^= unspec (stm -> statement.source_id)
			| generate_profile & stm -> statement.put_in_profile
		     then do;
			first_code_loc = binary (stm -> statement.location, 18);
			if stm -> statement.next = "0"b
			then last_code_loc = -1;
			else do;
			     next_stm_ptr = ptr (stm, stm -> statement.next);
			     last_code_loc = binary (next_stm_ptr -> statement.location, 18) - 1;
			     end;
			if last_code_loc >= first_code_loc
						/* Only put the line in the statement map if it contains object code. */
			then do;
			     old_id = unspec (stm -> statement.source_id);

			     q = addrel (sym_base, sym_pos);
			     q -> statement_map.location = stm -> statement.location;
			     unspec (q -> statement_map.source_id) = unspec (stm -> statement.source_id);
			     q -> statement_map.source_info.start = bit (fixed (stm -> statement.start, 18), 18);
			     q -> statement_map.source_info.length = stm -> statement.length;

			     addrel (sym_reloc_base, sym_pos) -> reloc (0) = rc_t;

			     if generate_profile
			     then if stm -> statement.put_in_profile
				then do;
				     addrel (link_base, profile_pos) -> profile_entry.map =
					bit (fixed (sym_pos - map_start, 18), 18);
				     if shared_globals.options.long_profile
				     then do;
					profile_pos = profile_pos + size (long_profile_entry);
					pp -> long_profile_header.nentries =
					     pp -> long_profile_header.nentries + 1;
					end;
				     else profile_pos = profile_pos + size (profile_entry);
				     end;

			     sym_pos = sym_pos + size (statement_map);
			     end;
			end;
		end;
	     cs -> subprogram.map.last = sym_pos;
	     end;

	/* generate dummy last entry */

	q = addrel (sym_base, sym_pos);
	q -> statement_map.location = bit (last_pos, 18);
	string (q -> statement_map.source_id) = (27)"1"b;

	addrel (sym_reloc_base, sym_pos) -> reloc (0) = rc_t;

	if generate_profile
	then addrel (link_base, profile_pos) -> profile_entry.map = bit (fixed (sym_pos - map_start, 18), 18);

	sym_pos = sym_pos + size (statement_map);

	info_ptr -> pl1_symbol_block.map.last = bit (sym_pos, 18);

     end gen_statement_map;

fill_sym_info_into_entries:
     procedure ();

	/* puts runtime symbol table info into entry sequence */

dcl	(cs, s, p) ptr;
dcl	(sym, star_symbol) fixed bin (18);
dcl	text_pos fixed bin (18);

	s = addr (rands (star_symbol_link));
	star_symbol = s -> symbol.address.offset;
	if s -> symbol.large_address
	then star_symbol = star_symbol + s -> symbol.location;

	do sym = first_entry_name repeat s -> symbol.next_symbol while (sym > 0);
	     s = addr (rands (sym));
	     cs = addr (rands (s -> symbol.parent));

	     /* do the following only if runtime block was allocated */

	     if cs -> subprogram.runtime ^= 0
	     then do;
		text_pos = s -> label.location;	/* a slight kludge */

		/* fill in trailer */

		text_halfs (text_pos + 4).left = star_symbol;
		text_halfs (text_pos + 4).right = cs -> subprogram.runtime;

		reloc_halfs (text_pos + 4).left = rc_lp18;
		reloc_halfs (text_pos + 4).right = rc_s;

		/* fill in namelist information */

		if shared_globals.options.list	/* tell listing generator which are not insts */
		then do;
		     a_name (text_pos + 3) = -1;
		     a_name (text_pos + 4) = -1;
		     end;

		if cs -> subprogram.namelist_used
		then do;
		     if cs -> subprogram.subprogram_type = main_program
		     then p = s;			/* no associated rel con for main */
		     else p = addr (rands (s -> symbol.initial));
						/* get associated rel con */

		     text_pos = p -> label.hash_chain;
		     text_halfs (text_pos).left = cs -> subprogram.runtime;
		     reloc_halfs (text_pos).left = rc_s;
		     end;
		end;				/* do block for subprograms with runtime_block nodes */
	     end;

     end fill_sym_info_into_entries;

make_ok_lists:
     procedure ();

	/* builds ok lists for namelist */

dcl	(i, ipol, sym, text_pos) fixed bin (18);
dcl	(s, q, qr) ptr;

dcl	1 ok_list aligned based,
	  2 number fixed bin (18),
	  2 offset (polish (ipol) + 1) bit (18) unal;

dcl	1 ok_list_reloc aligned based,
	  2 number fixed bin (18),
	  2 offset (polish (ipol) + 1) bit (18) unal;

	do sym = first_namelist repeat s -> symbol.next_member while (sym > 0);
	     s = addr (rands (sym));
	     text_pos = s -> label.location;
	     q = addrel (object_base, text_pos);
	     qr = addrel (relocation_base, text_pos);
	     ipol = s -> symbol.initial;

	     q -> ok_list.number = polish (ipol) + 1;
	     q -> ok_list.offset (1) = s -> symbol.runtime;
	     qr -> ok_list_reloc.offset (1) = rc_s;

	     do i = 1 to polish (ipol);
		q -> ok_list.offset (i + 1) = addr (rands (polish (ipol + i))) -> symbol.runtime;
		qr -> ok_list_reloc.offset (i + 1) = rc_s;
		end;
	     end;

     end make_ok_lists;

end_symbol:
     procedure ();

	/* finishes off the symbol section */

dcl	(p, sym_ptr) ptr;
dcl	(i, j, k, l, m) fixed bin (18);
dcl	b18 bit (18) aligned;
dcl	sym_rel_bit_count fixed bin (27);

dcl	1 reloc_in aligned based (p),
	  2 half_word (0:1000) unaligned bit (18);

dcl	1 relinfo aligned based,
	  2 version fixed bin (18),
	  2 rel_bit_count fixed bin (18),
	  2 relbits bit (i refer (rel_bit_count)) unaligned;

	sym_base -> std_symbol_header.mini_truncate = bit (sym_pos, 18);

	/* following is section that packs relocation bits into the symbol section */

	l = 1;
	sym_rel_bit_count = sym_pos;
	sym_ptr = addrel (sym_base, sym_pos);

	if shared_globals.options.relocatable
	then do p = relocation_base, def_reloc_base, link_reloc_base, sym_reloc_base;

	     b18 = bit (sym_pos, 18);

	     if l = 1
	     then do;
		m = text_pos;
		sym_base -> std_symbol_header.rel_text = b18;
		end;
	     else if l = 2
	     then do;
		m = def_pos;
		sym_base -> std_symbol_header.rel_def = b18;
		end;
	     else if l = 3
	     then do;
		m = link_pos;
		sym_base -> std_symbol_header.rel_link = b18;
		end;
	     else if l = 4
	     then do;
		m = sym_rel_bit_count;
		sym_base -> std_symbol_header.rel_symbol = b18;
		end;

	     m = m * 2;

	     sym_ptr -> relinfo.version = 1;

	     i, k = 0;

	     do j = 0 to m - 1;

		b18 = p -> reloc_in.half_word (j);
		if b18
		then do;
		     if k ^= 0
		     then do;

			/* have a string of "k" consecutive half_words with
			   absolute relocation; use expanded absolute coding
			   if there are more than 15 halfwords */

			call expanded_absolute;

			k = 0;
			end;

		     substr (sym_ptr -> relbits, i + 1, 5) = substr (b18, 14, 5);
		     i = i + 5;
		     end;

		else k = k + 1;

		end;

	     if k ^= 0 then call expanded_absolute;

	     sym_ptr -> rel_bit_count = i;
	     l = l + 1;

	     j = size (sym_ptr -> relinfo);
	     sym_pos = sym_pos + j;
	     sym_ptr = addrel (sym_ptr, j);

	     end;

	/* finish off symbol header */

	sym_base -> std_symbol_header.block_size = bit (sym_pos, 18);

expanded_absolute:
     procedure ();

	if k < 16
	then i = i + k;

	else do;

	     do while (k > 1023);
		substr (sym_ptr -> relbits, i + 1, 15) = "111101111111111"b;
		i = i + 15;
		k = k - 1023;
		end;

	     substr (sym_ptr -> relbits, i + 1, 15) = "11110"b || bit (fixed (k, 10), 10);
	     i = i + 15;
	     end;

     end;

     end end_symbol;

store_string:
     procedure (str) returns (bit (36) aligned);

dcl	str char (*) varying;

dcl	b36 bit (36),
	based_string char (length (str)) based aligned;

	if length (str) = 0
	then return ((36)"0"b);

	substr (b36, 1, 18) = bit (sym_pos, 18);
	addrel (sym_base, sym_pos) -> based_string = str;
	sym_pos = sym_pos + divide (length (str) + 3, 4, 17, 0);
	substr (b36, 19, 18) = bit (fixed (length (str), 18), 18);

	return (b36);

     end store_string;

make_symbol_table:
     procedure ();

	/* This procedure makes standard symbol table entries for the new fortran
   compiler.  It is called after the std_symbol_header and pl1_symbol_block
   nodes and the statement map have been created. The following global
   variables are assumed:

	sym_base - base of symbol section. ptr to std_symbol_header.
	sym_pos - current length of symbol section.
	symrel - offset of symbol section.
	info_ptr - ptr to pl1_symbol_block.
	objectname - name of the object segment.

   Others such as rands, polish, operand_base are not mentioned here.

*/


	/* Declarations */

dcl	all_symbols bit (1) aligned;			/* local copy of options.table */
dcl	alloc_len fixed bin (18);			/* length of CURRENT runtime_node being allocated */
dcl	blk fixed bin (18);
dcl	blkp ptr;					/* current runtime block pointer */
dcl	block_name char (32) varying;			/* name for VLA/LA base */
dcl	count fixed bin (18);			/* global count of symbols in sort array */
dcl	cur_subp ptr;				/* pointer to subprogram node */
dcl	convert_data_type (0:1, 0:6) fixed bin (6) init
	     (0, ft_integer_dtype, ft_real_dtype, ft_double_dtype, ft_complex_dtype, ft_logical_dtype, ft_char_dtype,
	     0, ft_integer_dtype, ft_hex_real_dtype, ft_hex_double_dtype, ft_hex_complex_dtype, ft_logical_dtype,
	     ft_char_dtype);
dcl	convert_size (0:5) fixed bin (18) int static options (constant) init (0, 35, 27, 63, 27, 1);
dcl	dp ptr;
dcl	ext_proc fixed bin (18);			/* offset of ext proc block */
dcl	factor fixed bin (19) int static options (constant) init (262144);
dcl	final (0:5) fixed bin (18);
dcl	fptype fixed bin (1) init (fixed (shared_globals.options.hfp, 1, 0));
dcl	i fixed bin (18);				/* temp */
dcl	i2 fixed bin (18);
dcl	j fixed bin (18);
dcl	last_blk fixed bin (18);			/* for building int proc brother chain */
dcl	last_len fixed bin (18);			/* for building length vectors */
dcl	last_sym fixed bin (18);			/* for chaining symbols */
dcl	lbl_name picture "99999";
dcl	length builtin;
dcl	lengths (0:6) fixed bin (18) int static options (constant) init (1, 2, 4, 8, 16, 32, 64);
dcl	max_len fixed bin (18);
dcl	min_len fixed bin (18);
dcl	n fixed bin (18);				/* = length(runtime_token.string); only set in get_acc_str! */
dcl	off fixed bin (18);				/* temp */
dcl	rel_bits bit (18) unaligned;			/* loop index */
dcl	pointer_pos fixed bin (18);			/* position of pointer runtime */
dcl	rel_bits2 bit (18) unaligned;			/* loop index */
dcl	root fixed bin (18);			/* offset of root block */
dcl	simple_len fixed bin (18) int static options (constant) init (5);
dcl	size builtin;
dcl	sp ptr;					/* pointer to symbol node */
dcl	sp2 ptr;					/* pointer to symbol node */
dcl	string builtin;
dcl	sym_sec (0:261119) fixed bin (18) aligned based (sym_base);
dcl	symp ptr;					/* current runtime symbol pointer */
dcl	sym_max_len fixed bin (18);			/* max sym section length */
dcl	symtab_base ptr;				/* base of array for sorting */
dcl	symtab_max fixed bin (18);			/* max length for array */
dcl	text_ref bit (4) aligned int static options (constant) init ("1100"b);
dcl	tkn_len fixed bin (9);			/* set by get_acc_str */
dcl	tkn_ptr ptr;				/* points to name for a runtime_token node, set by get_acc_str */
dcl	words (alloc_len) bit (36) aligned based;	/* to zero area for each allocated node */

dcl	1 symbol_template like runtime_symbol aligned;

dcl	1 block_template like runtime_block aligned;

dcl	1 token_list (256) aligned,
	  2 first fixed bin (18) unsigned unaligned,
	  2 last fixed bin (18) unsigned unaligned;

dcl	1 symbols (131071) aligned based (symtab_base),
	  2 str_p ptr unaligned,
	  2 offset fixed bin (18) unsigned unaligned,
	  2 length fixed bin (18) unsigned unaligned;

%include runtime_symbol;
%include std_descriptor_types;

	/* Initialization */

	unspec (block_template) = "0"b;

	block_template.flag = "1"b;
	block_template.fortran = "1"b;
	block_template.standard = "1"b;
	block_template.type = "011000"b;		/* 24 - procedure */
						/* all others = "0"b */

	unspec (symbol_template) = "0"b;

	symbol_template.flag = "1"b;
	symbol_template.aligned = "1"b;
	symbol_template.simple = "1"b;
						/* all others = "0"b */

	min_len = hbound (token_list, 1);		/* keep track of symbol length range */
	max_len = 0;
	unspec (token_list) = "0"b;

	symtab_base = addr (polish (next_free_polish));
	symtab_max = divide (polish_max_len - next_free_polish, 2, 17, 0);
						/* NOTE - size(symbols) = 2 */

	sym_max_len = object_max_len - symrel;		/* max sym sect len */

	cur_subprogram = 0;				/* for error messages */
	all_symbols = shared_globals.options.table;

	/* set relevant fields in pl1_symbol_block */

	info_ptr -> pl1_symbol_block.flags.table = "1"b;
	info_ptr -> pl1_symbol_block.flags.io = shared_globals.options.namelist_used;


	/* Allocate runtime root block

	     BY block_template	flag, quick, fortran, standard, owner_flag, skip, type, number, name, brother,
				entry_info.
	     IN allocate_block	father, header.
	     IN connect_symbols_to_block start, chain(*).
	     BY following code	map.first, map.last.
	     BY allocating root	son
	     BY finish up code	token(*) */

	last_blk = 0;				/* for brother chain */

	call allocate_block (0, size (runtime_block) - 1, 0, root, blkp);

	if generate_map
	then do;
	     blkp -> runtime_block.map.first =
		backward_ref (binary (info_ptr -> pl1_symbol_block.map.first, 18) - root);
	     blkp -> runtime_block.map.last = backward_ref (binary (info_ptr -> pl1_symbol_block.map.last, 18) - root);
	     end;

	/* allocate external entry constants for all entry points.

	     BY symbol_template	flag, skip, array_units, units, type, level, ndims, aligned, packed, simple,
				decimal, scale, son, class, next, size.
	     IN allocate_symbol	name, father.
	     IN connect_symbols_to_block brother.
	     BY following code	location.

	     NOTE - son is used to save text address of int entry const associated with this sym; used later */

	symbol_template.type = "011010"b;		/* 26 - external entry constant */
	symbol_template.class = text_ref;

	count = 0;
	do i = first_entry_name repeat sp -> symbol.next_symbol while (i ^= 0);
	     sp = addr (rands (i));
	     symp = null;				/* symbol may not be allocated */

	     if addr (rands (sp -> symbol.parent)) -> subprogram.namelist_used | all_symbols
	     then call allocate_symbol (get_acc_str$symbol (sp), simple_len, root, "1"b, symp);

	     /* continue only if the allocation was successful */

	     if symp ^= null
	     then do;
		call add_to_array;

		symp -> runtime_symbol.location = get_address (sp);
		addrel (relocation_base, rel (symp)) -> runtime_symbol.location = rc_t;
						/* set reloc bits */

		/* if symbol has an associated int entry const, copy its text address */

		if sp -> symbol.initial ^= 0
		then symp -> runtime_symbol.son = unspec (addr (rands (sp -> symbol.initial)) -> label.location);

		sym_pos = sym_pos + simple_len;
		end;
	     end;					/* loop to generate ext entry consts */

	/* sort ext entry symbols and chain them together */

	call connect_symbols_to_block (root, blkp);


	/* Allocate runtime ext proc block

	     BY block_template	flag, quick, fortran, standard, owner_flag, skip, type, number, brother, entry_info.
	     IN allocate_block	name, father, header.
	     BY following code	start, map.first, map.last, chain(*).
	     BY allocating int procs	son
	     BY finish up code	token(*) */

	last_blk = 0;				/* for brother chain */

	call allocate_block (get_acc_str$varying (objectname), size (runtime_block) - 1, root, ext_proc, blkp);

	if generate_map
	then do;
	     blkp -> runtime_block.map.first =
		backward_ref (binary (info_ptr -> pl1_symbol_block.map.first, 18) - ext_proc);
	     blkp -> runtime_block.map.last =
		backward_ref (binary (info_ptr -> pl1_symbol_block.map.last, 18) - ext_proc);
	     end;

	/* allocate internal entry constants. Only main_entry_point_name does not have one. If we walk the root block's
	   declaration chain, we can allocate everything in symbol and block nodes in one pass.

	     BY symbol_template	flag, skip, array_units, units, type, level, ndims, aligned, packed, simple,
				decimal, scale, son, class, size.
	     IN allocate_symbol	name, father, next.
	     BY following code	brother, location. */

	last_sym = 0;				/* to build brother chain */
	last_len = 1;				/* to build block.chain(*) */
	symbol_template.type = "011001"b;		/* = 25; internal entry constant; class is already set */
	symp = addr (sym_sec (root));			/* to provide easy entry into the loop */

	do rel_bits = symp -> runtime_block.start repeat symp -> runtime_symbol.brother while (rel_bits ^= "0"b);
	     symp = addrel (symp, rel_bits);

	     /* allocate it if it has an associated internal entry constant */

	     if symp -> runtime_symbol.son ^= "0"b
	     then do;

		off = unpack (symp -> runtime_symbol.name) + binary (rel (symp), 18) - symrel;
						/* convert rel to absolute */

		call allocate_symbol (off, simple_len, ext_proc, "0"b, sp);

		sp -> runtime_symbol.location = symp -> runtime_symbol.son;
		symp -> runtime_symbol.son = "0"b;

		addrel (relocation_base, rel (sp)) -> runtime_symbol.location = rc_t;
						/* set reloc bits */

		if last_sym = 0
		then blkp -> runtime_block.start = forward_ref (sym_pos - ext_proc);
		else addr (sym_sec (last_sym)) -> runtime_symbol.brother = forward_ref (sym_pos - last_sym);

		last_sym = sym_pos;

		/* build runtime_block.chain(*) */

		tkn_len = binary (addr (sym_sec (off - 1)) -> runtime_token.size, 9);

		do i = last_len to 4;
		     if tkn_len >= lengths (i)
		     then if blkp -> runtime_block.chain (i) = "0"b
			then do;
			     last_len = i + 1;
			     blkp -> runtime_block.chain (i) = forward_ref (sym_pos - ext_proc);
			     end;
		     end;				/* loop to set chain(*) */

		sym_pos = sym_pos + simple_len;
		end;				/* do block to build int entry const symbol */
	     end;					/* loop thru ext entry constant symbols */


	/* Walk subprogram chain, building internal blocks with their symbols

	     block_template:	flag, quick, fortran, standard, owner_flag, skip, type, number, son.
	     allocate_block: proc	name, brother, father, header.
	     connect_symbols_to_block: start, chain(*).
	     following code		map.first, map.last, entry_info, owner.
	     finish up code		token(*). */

	block_template.quick = "1"b;
	block_template.owner_flag = "1"b;
	last_blk = 0;

	do cur_subprogram = first_subprogram repeat cur_subp -> subprogram.next_subprogram while (cur_subprogram ^= 0);
	     cur_subp = addr (rands (cur_subprogram));

	     /* allocate block node and its symbol nodes, only if required */

	     if cur_subp -> subprogram.namelist_used | all_symbols
	     then do;
		call allocate_block (get_acc_str$symbol (addr (rands (cur_subp -> subprogram.symbol))),
		     size (runtime_block), ext_proc, blk, blkp);
		cur_subp -> subprogram.runtime = blk;

		if cur_subp -> subprogram.entry_info = 0/* subprogram is not quick procedure */
		then do;
		     blkp -> runtime_block.quick = "0"b;
		     blkp -> runtime_block.owner_flag = "0"b;
		     sym_pos = sym_pos - 1;
		     end;

		else do;				/* quick procedure block */
		     blkp -> runtime_block.owner = backward_ref (ext_proc - blk);
		     blkp -> runtime_block.entry_info = unspec (cur_subp -> subprogram.entry_info);
		     end;

		if generate_map
		then do;
		     blkp -> runtime_block.map.first = backward_ref (cur_subp -> subprogram.map.first - blk);
		     blkp -> runtime_block.map.last = backward_ref (cur_subp -> subprogram.map.last - blk);
		     end;

		/* process all relevant declarations for the block */

		count = 0;

		/* automatic variables - buckets 1 to 4

		     BY symbol_template	flag, skip, array_units, units, level, [ndims,] aligned, packed,
					[simple,] decimal, scale, son, class, offset.
		     IN process_variable	type, [ndims,] [simple,] name, father, location, next, size,
					[virtual_org,] [bounds(*)]
		     IN connect_symbols_to_block brother */

		symbol_template.class = "0001"b;	/* automatic storage */

		do i = 1 to 4;
		     do j = cur_subp -> subprogram.storage_info (i).first repeat sp -> node.next while (j ^= 0);
			sp = addr (rands (j));

			if sp -> node.node_type = symbol_node
			then do;
			     call process_variable (sp, simple_len, "1"b, symp);
			     sym_pos = sym_pos + alloc_len;
			     end;

			else do i2 = sp -> header.first_element repeat sp2 -> symbol.next_member while (i2 ^= 0);
			     sp2 = addr (rands (i2));

			     call process_variable (sp2, simple_len, "1"b, symp);

			     if (sp2->symbol.equivalenced & sp2->symbol.in_equiv_stmnt & sp2->symbol.char_num > 0 & sp2->symbol.character & sp2->symbol.offset > 0) 
                                      then do;
				symp->runtime_symbol.aligned = "0"b;
				symp->runtime_symbol.simple  = "0"b;
				symp->runtime_symbol.packed  = "1"b;
				symp->runtime_symbol.offset = mod(sp2->symbol.offset, 4);
                                      end;
			     sym_pos = sym_pos + alloc_len;
			     end;
			end;			/* buckets 1 to 4 */
		     end;				/* automatic variables */

		/* static variables - buckets 5 to 8

		     BY symbol_template	flag, skip, array_units, units, level, [ndims,] aligned, packed,
					[simple,] decimal, scale, son, class, offset.
		     IN process_variable	type, [ndims,] [simple,] name, father, location, next, size,
					[virtual_org,] [bounds(*)]
		     IN connect_symbols_to_block brother */

		symbol_template.class = "0100"b;	/* static storage */

		do i = 5 to 8;
		     do j = cur_subp -> subprogram.storage_info (i).first repeat sp -> node.next while (j ^= 0);
			sp = addr (rands (j));

			if sp -> node.node_type = symbol_node
			then do;
			     call process_variable (sp, simple_len, "1"b, symp);

			     if symp ^= null
			     then do;
				sym_pos = sym_pos + alloc_len;
				addrel (relocation_base, rel (symp)) -> runtime_symbol.location = rc_is18;
						/* set reloc bits */
				end;
			     end;

			else do i2 = sp -> header.first_element repeat sp2 -> symbol.next_member while (i2 ^= 0);
			     sp2 = addr (rands (i2));

			     call process_variable (sp2, simple_len, "1"b, symp);

			     if symp ^= null
			     then do;
				sym_pos = sym_pos + alloc_len;
				addrel (relocation_base, rel (symp)) -> runtime_symbol.location = rc_is18;
						/* set reloc bits */
				end;
			     end;
			end;			/* buckets 5 to 8 */
		     end;				/* static variables */

		/* external entries and common block members - bucket 9

			COMMON BLOCK MEMBERS

		     BY symbol_template	flag, skip, array_units, units, level, [ndims], aligned, packed,
					simple, decimal, scale, son, location, class.
		     IN process_variable	type, [ndims], name, father, next, size, [virtual_org], [bounds(*)].
		     IN connect_symbols_to_block brother.
		     BY following code	offset.

			EXTERNAL ENTRY REFERENCES

		     BY symbol_template	flag, skip, array_units, units, type, level, ndims, aligned,
					packed, simple, decimal, scale, sone, class, size.
		     IN allocate_symbol	name, father, next.
		     IN connect_symbols_to_block brother.
		     BY following code	location. */

		do i = cur_subp -> storage_info (9).first repeat sp -> node.next while (i ^= 0);
		     sp = addr (rands (i));

		     if sp -> node.node_type = header_node
		     then do;
			symbol_template.class = "0101"b;
						/* external static */
			symbol_template.location = bit (fixed (sp -> header.location, 18), 18);
			symbol_template.simple = "0"b;

			do i2 = sp -> header.first_element repeat sp2 -> symbol.next_member while (i2 ^= 0);
			     sp2 = addr (rands (i2));

			     call process_variable (sp2, simple_len + 2, "0"b, symp);

			     if symp ^= null
			     then do;
				symp -> runtime_symbol.offset = sp2 -> symbol.offset;
				addrel (relocation_base, rel (symp)) -> runtime_symbol.location = rc_lp18;
						/* set reloc bits */

				sym_pos = sym_pos + alloc_len;
				end;
			     end;			/* loop thru common block members */
			end;			/* case of common block chain */

		     else if sp -> symbol.initial = 0 & all_symbols
						/* for full table, allocate ext. ent. refs */
		     then do;
			symbol_template.class = "1101"b;
						/* link ref */
			symbol_template.type = "011011"b;
						/* ext entry ref */
			symbol_template.simple = "1"b;

			call allocate_symbol (get_acc_str$symbol (sp), simple_len, blk, "0"b, symp);

			if symp ^= null
			then do;
			     call add_to_array;

			     symp -> runtime_symbol.location = get_address (sp);
			     addrel (relocation_base, rel (symp)) -> runtime_symbol.location = rc_lp18;
						/* set reloc bits */

			     sym_pos = sym_pos + alloc_len;
			     end;
			end;			/* case of external reference */
		     end;				/* bucket 9 */

		/* parameters - bucket 10

		     BY symbol_template	flag, skip, array_units, units, level, [ndims,] aligned, packed,
					simple, decimal, scale, son, offset.
		     IN process_variable	type, [ndims,] [simple,] name, father, next, size,
					[virtual_org,] [bounds(*)]
		     IN connect_symbols_to_block brother
		     BY following code	location, class. */

		symbol_template.simple = "1"b;

		do i = cur_subp -> subprogram.storage_info (10).first repeat sp -> symbol.next_symbol while (i ^= 0);

		     sp = addr (rands (i));

		     if sp -> symbol.VLA
		     then do;

			/* Allocate runtime block  for base pointer. */

			symbol_template.units = "00"b;
			symbol_template.type = "001101"b;
						/* Pointer */
			symbol_template.level = "00"b3;
			symbol_template.aligned = "0"b;
			symbol_template.packed = "1"b;/* Packed for VLA's */
			symbol_template.simple = "1"b;
			symbol_template.scale = "00"b3;
			symbol_template.size = 0;

			symbol_template.class = "0001"b;
						/* AUTOMATIC */
			block_name = "vla$parm$";
			symbol_template.location = bit (fixed (sp -> symbol.address.offset, 18), 18);

			block_name = block_name || sp -> symbol.name;
			call allocate_symbol (get_acc_str$varying (block_name),
			     simple_len, blk, "0"b, symp);
			call add_to_array;
			pointer_pos = sym_pos;	/* save runtime position */
			sym_pos = sym_pos + simple_len;

			/* Template for parameter off this base */

			symbol_template.simple = "0"b;
			symbol_template.packed = "0"b;
			symbol_template.aligned = "1"b;
			end;

		     call process_variable (sp, simple_len, "0"b, symp);


		     /* process runtime_symbol node only if it is allocated */

		     if symp ^= null
		     then do;
			if sp -> symbol.VLA
			then do;
			     symp -> runtime_symbol.location = rel_ref (pointer_pos - sym_pos);
			     symp -> runtime_symbol.class = "1010"b;
						/* VLA_based */
			     end;
			else if sp -> symbol.stack_indirect
			then do;
			     symp -> runtime_symbol.location = get_address (sp);
			     symp -> runtime_symbol.class = "1000"b;
			     end;
			else do;
			     symp -> runtime_symbol.location =
				bit (binary (divide (sp -> symbol.location, 2, 17, 0), 18), 18);
			     symp -> runtime_symbol.class = "1001"b;
			     end;

			sym_pos = sym_pos + alloc_len;
			end;			/* do block to finish off parameter runtime_symbol */
		     unspec (symbol_template) = "0"b;

		     symbol_template.flag = "1"b;
		     symbol_template.aligned = "1"b;
		     symbol_template.simple = "1"b;
						/* all others = "0"b */
		     end;				/* parameters - bucket 10 */

		/* namelist names, PARAMETER variables - bucket 11
		     All fields are set by the template. */


		do i = cur_subp -> subprogram.storage_info (11).first repeat sp -> symbol.next_symbol while (i ^= 0);
		     sp = addr (rands (i));

		     /* Process PARAMETER variables. */

		     if sp -> symbol.named_constant & ^sp -> symbol.by_compiler
		     then do;
			sp2 = addr (rands (sp -> symbol.initial));
			sp -> symbol.data_type = sp2 -> constant.data_type;
			symbol_template.simple = "1"b;
			symbol_template.location = bit (binary (sp2 -> constant.location, 18), 18);
			symbol_template.class = "1100"b;
			call process_variable (sp, simple_len, "0"b, symp);
			/* Bug 512: Set up reloc info */
			addrel (relocation_base, rel (symp)) -> runtime_symbol.location = rc_t;
			if symp ^= null
			then do;
			     if sp -> symbol.character
			     then symp -> runtime_symbol.size = sp2 -> char_constant.length;
			     sym_pos = sym_pos + simple_len;
			     end;
			end /* named_constant */;
		     else if sp -> symbol.namelist
		     then do;
			symbol_template.type = "0"b;
			symbol_template.simple = "1"b;
			symbol_template.location = "0"b;
			symbol_template.class = "0"b;

			call allocate_symbol (get_acc_str$symbol (sp), simple_len, blk, "0"b, symp);
			call add_to_array;

			sp -> symbol.runtime = bit (sym_pos, 18);
			sym_pos = sym_pos + simple_len;
			end /* namelist */;
		     end /* do i */;		/* bucket 11 */

		/* Large Array block members - buckets 13, 14

			LARGE ARRAY BLOCK MEMBERS

		     BY symbol_template	flag, skip, array_units, units, level, [ndims], aligned, packed,
					simple, decimal, scale, son, location, class.
		     IN process_variable	type, [ndims], name, father, next, size, [virtual_org], [bounds(*)].
		     IN connect_symbols_to_block brother.
		     BY following code	offset. */


		do j = 13, 14;			/* scan auto and static */
		     do i = cur_subp -> storage_info (j).first repeat sp -> node.next while (i ^= 0);
			sp = addr (rands (i));

			if sp -> node.node_type = header_node
			then do;

			     /* Allocate runtime block  for base pointer. */

			     symbol_template.units = "00"b;
			     symbol_template.type = "001101"b;
						/* Pointer */
			     symbol_template.level = "00"b3;
			     symbol_template.aligned = "1"b;
			     symbol_template.packed = "0"b;
						/* Not packed for LA's */
			     symbol_template.simple = "1"b;
			     symbol_template.scale = "00"b3;
			     symbol_template.size = 0;

			     if sp -> header.static
			     then do;
				symbol_template.class = "0100"b;
						/* STATIC */
				block_name = "la$static$";
				end;
			     else do;
				symbol_template.class = "0001"b;
						/* AUTOMATIC */
				block_name = "la$auto$";
				end;

			     symbol_template.location = bit (fixed (sp -> header.location, 18), 18);

			     block_name = block_name || ltrim (octal (unspec (sp -> header.location)), "0");
			     call allocate_symbol (get_acc_str$varying (block_name),
				simple_len, blk, "0"b, symp);
			     call add_to_array;
			     pointer_pos = sym_pos;	/* save runtime position */
			     sym_pos = sym_pos + simple_len;
			     if sp -> header.static
			     then addrel (relocation_base, rel (symp)) ->
				     runtime_symbol.location = rc_is18;


			     /* Template for LA's off this header */

			     symbol_template.class = "0011"b;
						/* BASED */
			     symbol_template.packed = "0"b;
			     symbol_template.simple = "0"b;

			     do i2 = sp -> header.first_element repeat sp2 -> symbol.next_member while (i2 ^= 0);
				sp2 = addr (rands (i2));

				call process_variable (sp2, simple_len + 2, "0"b, symp);

				if symp ^= null
				then do;
				     symp -> runtime_symbol.offset = sp2 -> symbol.offset;
				     symp -> runtime_symbol.location = rel_ref (pointer_pos - sym_pos);
				     sym_pos = sym_pos + alloc_len;
				     end;
				end;		/* loop thru LA block members */
			     end;			/* case of LA block chain */
			end;
		     end;				/* buckets 13, 14 */


		/* Very Large Array block members - buckets 15, 16, 17

			VERY LARGE ARRAY BLOCK MEMBERS

		     BY symbol_template	flag, skip, array_units, units, level, [ndims], aligned, packed,
					simple, decimal, scale, son, location, class.
		     IN process_variable	type, [ndims], name, father, next, size, [virtual_org], [bounds(*)].
		     IN connect_symbols_to_block brother.
		     BY following code	offset. */


		do j = 15 to 17;			/* scan auto, static, and common */
		     do i = cur_subp -> storage_info (j).first repeat sp -> node.next while (i ^= 0);
			sp = addr (rands (i));

			if sp -> node.node_type = header_node
			then do;

			     /* Allocate runtime block  for base pointer. */

			     symbol_template.units = "00"b;
			     symbol_template.type = "001101"b;
						/* Pointer */
			     symbol_template.level = "00"b3;
			     symbol_template.aligned = "0"b;
			     symbol_template.packed = "1"b;
						/* Packed for VLA's */
			     symbol_template.simple = "1"b;
			     symbol_template.scale = "00"b3;
			     symbol_template.size = 0;

			     /*  Find the first member of the VLA group which has no offset and use its   */
			     /*  packed pointer as the base pointer for the VLA.                          */

			     do sp2 = addr (rands (sp -> header.first_element))
				repeat addr (rands (sp2 -> symbol.next_member)) while (sp2 -> symbol.offset ^= 0);
				end;

			     /* if the first element is a nondimensioned symbol (only happens in           */
			     /* VL Common), restore symbol.address.offset from symbol.addr_hold.	   */
			     if sp -> header.in_common & ^sp2 -> symbol.dimensioned
			     then
				substr (unspec (sp2 -> symbol.address), 1, 18) = sp2 -> symbol.addr_hold;

			     if ^sp2 -> symbol.large_address
			     then symbol_template.location = bit (fixed (sp2 -> symbol.address.offset, 18));
			     else symbol_template.location =
				     bit (fixed (sp2 -> symbol.address.offset + sp2 -> symbol.location, 18));

			     if sp -> header.static
			     then do;
				symbol_template.class = "0100"b;
						/* STATIC */
				block_name = "vla$static$" || sp2 -> symbol.name;
				end;
			     else if sp -> header.automatic
			     then do;
				symbol_template.class = "0001"b;
						/* AUTOMATIC */
				block_name = "vla$auto$" || sp2 -> symbol.name;
				end;
			     else do;
				symbol_template.class = "0100"b;
						/* COMMON */
				if sp -> header.block_name = "blnk*com"
				then block_name = "vla$common$_";
				else block_name = "vla$common$" || sp -> header.block_name;
				end;

			     call allocate_symbol (get_acc_str$varying (block_name),
				simple_len, blk, "0"b, symp);
			     call add_to_array;
			     pointer_pos = sym_pos;	/* save runtime position */
			     sym_pos = sym_pos + simple_len;
			     if sp -> header.static | sp -> header.in_common
			     then addrel (relocation_base, rel (symp)) ->
				     runtime_symbol.location = rc_is18;


			     /* Template for VLA's off this header */

			     symbol_template.class = "1010"b;
						/* VLA_based */
			     symbol_template.aligned = "1"b;
			     symbol_template.packed = "0"b;
			     symbol_template.simple = "0"b;

			     do i2 = sp -> header.first_element repeat sp2 -> symbol.next_member while (i2 ^= 0);
				sp2 = addr (rands (i2));

				call process_variable (sp2, simple_len + 2, "0"b, symp);

				if symp ^= null
				then do;
				     symp -> runtime_symbol.offset = sp2 -> symbol.offset;
				     symp -> runtime_symbol.location = rel_ref (pointer_pos - sym_pos);
				     sym_pos = sym_pos + alloc_len;
				     end;
				end;		/* loop thru VLA block members */
			     end;			/* case of VLA block chain */
			end;
		     end;				/* buckets 15, 16, 17 */


		/* labels - separate chain
		     All fields, except location, are set by the template.

			NOTE - allocated only if full symbol table. */

		symbol_template.type = "011000"b;	/* = 24; label */
		symbol_template.class = text_ref;

		if all_symbols
		then do i = cur_subp -> subprogram.first_label repeat sp -> label.next_label while (i ^= 0);
		     sp = addr (rands (i));

		     if sp -> label.name > 0 & sp -> label.name <= 99999 & string (sp -> label.usage) = "01"b
		     then do;
			lbl_name = sp -> label.name;
			call allocate_symbol (get_acc_str$varying (substr (lbl_name, verify (lbl_name, "0"))),
			     simple_len, blk, "0"b, symp);
			call add_to_array;

			symp -> runtime_symbol.location = unspec (sp -> label.location);
			addrel (relocation_base, rel (symp)) -> runtime_symbol.location = rc_t;
						/* set reloc bits */

			sym_pos = sym_pos + alloc_len;
			end;			/* executable user labels */
		     end;				/* labels */

		/* finish up the block */

		call connect_symbols_to_block (blk, blkp);

		end;				/* do block for subprograms to be allocated */
	     end;					/* loop thru subprogram nodes */


	/* Finish up - link up all tokens and set block.token(*) for all blocks */

	last_len = 0;				/* for building length vector */
	unspec (final) = "0"b;			/* length vector in absolute form */
	off = 0;					/* offset of previous token node */

	/* build one continuous list of tokens while calculating the absolute vector */

	do i = min_len to max_len;

	     if token_list (i).first > 0
	     then do;
		j = token_list (i).first;

		if off > 0 then addr (sym_sec (off)) -> runtime_token.next = rel_ref (j - off);
		off = j;

		do j = last_len to 5;
		     if i >= lengths (j)
		     then if final (j) = 0
			then do;
			     last_len = j + 1;
			     final (j) = off;
			     end;
		     end;				/* loop to set vector elements */
		off = token_list (i).last;		/* get end of the vector */
		end;				/* block to link up partial list of tokens */
	     end;					/* loop to find and link up all partial lists */

	/* now walk the block chains and set all their vectors */

	sp = sym_base;

	do rel_bits = bit (root, 18) repeat sp -> runtime_block.son while (rel_bits ^= "0"b);
	     sp = addrel (sp, rel_bits);
	     off = binary (rel (sp), 18) - symrel;

	     do i = 0 to 5;
		if final (i) > 0 then sp -> runtime_block.token (i) = rel_ref (final (i) - off);
		end;

	     sp2 = sp;

	     do rel_bits2 = sp -> runtime_block.son repeat sp2 -> runtime_block.brother while (rel_bits2 ^= "0"b);
		sp2 = addrel (sp2, rel_bits2);
		off = binary (rel (sp2), 18) - symrel;

		do i = 0 to 5;
		     if final (i) > 0 then sp2 -> runtime_block.token (i) = rel_ref (final (i) - off);
		     end;
		end;				/* loop through brother chain */
	     end;					/* loop through son chain */
	return;

allocate_block:
     procedure (a_name, a_len, a_parent, blk_off, blk_ptr);

dcl	B fixed bin (18);
dcl	BP ptr;
dcl	a_len fixed bin (18);
dcl	a_name fixed bin (18);
dcl	a_parent fixed bin (18);
dcl	blk_name fixed bin (18);
dcl	blk_off fixed bin (18);
dcl	blk_ptr ptr;
dcl	parent fixed bin (18);

	/* copy input arguments */

	blk_name = a_name;
	alloc_len = a_len;
	parent = a_parent;

	/* allocate block node */

	if sym_pos + alloc_len >= sym_max_len then call print_message (414, "object segment", object_max_len - bias);

	B = sym_pos;
	BP = addr (sym_sec (B));
	unspec (BP -> words) = unspec (block_template);
	sym_pos = sym_pos + alloc_len;

	/* link this block to its parent block */

	if parent = 0				/* parent is std_symbol_header */
	then do;
	     parent = binary (rel (sym_base), 18) - symrel;
	     info_ptr -> pl1_symbol_block.root = bit (B, 18);
	     end;

	/* if this block has no brother, it is first son; otherwise put it on brother chain */

	else if last_blk = 0
	then addr (sym_sec (parent)) -> runtime_block.son = forward_ref (B - parent);
	else addr (sym_sec (last_blk)) -> runtime_block.brother = forward_ref (B - last_blk);
	last_blk = B;

	BP -> runtime_block.father = backward_ref (parent - B);

	BP -> runtime_block.header = backward_ref (-B);

	/* set name field */

	if blk_name > 0 then BP -> runtime_block.name = backward_ref (blk_name - B);

	/* set output arguments */

	blk_off = B;
	blk_ptr = BP;
     end allocate_block;

allocate_symbol:
     procedure (a_name, a_len, a_parent, nd_sw, sym_ptr);

dcl	SP ptr;
dcl	a_len fixed bin (18);
dcl	a_name fixed bin (18);
dcl	a_parent fixed bin (18);
dcl	distance fixed bin (18);
dcl	last_dcl fixed bin (14);
dcl	namedup_is_error bit (1) aligned;
dcl	nd_sw bit (1) aligned;
dcl	sym_blk fixed bin (18);
dcl	sym_name fixed bin (18);
dcl	sym_ptr ptr;

	/* copy input arguments */

	sym_name = a_name - 1;			/* convert from acc off to node offset */
	alloc_len = a_len;
	sym_blk = a_parent;
	namedup_is_error = nd_sw;

	/* allocate symbol node */

	if sym_pos + alloc_len >= sym_max_len then call print_message (414, "object segment", object_max_len - bias);

	SP = addr (sym_sec (sym_pos));
	sym_ptr = SP;				/* set output argument */
	unspec (SP -> words) = unspec (symbol_template);

	/* link symbol to token */

	SP -> runtime_symbol.name = backward_ref (sym_name + 1 - sym_pos);

	/* link token to symbol */

	if addr (sym_sec (sym_name)) -> runtime_token.dcl ^= "0"b
						/* previous symbol declared with this name */
	then if namedup_is_error
	     then do;
		call print_message (428, addr (sym_sec (sym_name)) -> runtime_token.string);
		unspec (SP -> runtime_symbol) = "0"b;
		sym_ptr = null;			/* set output argument */
		return;
		end;
	     else do;				/* must chain all symbols with same name */
		last_dcl = unpack (addr (sym_sec (sym_name)) -> runtime_token.dcl) + sym_name;
						/* convert rel to absolute */
		distance = last_dcl - sym_pos;
		if distance + 16384 <= 0
		then do;				/* can't chain */
		     call print_message (503, addr (sym_sec (sym_name)) -> runtime_token.string);
		     SP -> runtime_symbol.next = "0"b;
		     end;
		else SP -> runtime_symbol.next = substr (backward_ref (distance), 5, 14);
		end;

	addr (sym_sec (sym_name)) -> runtime_token.dcl = forward_ref (sym_pos - sym_name);

	/* link to father block */

	SP -> runtime_symbol.father = backward_ref (sym_blk - sym_pos);
     end allocate_symbol;

add_to_array:
     procedure ();

	/* put symbol in sort array */

	count = count + 1;
	if count > symtab_max then call print_message (414, "sort array", symtab_max - bias);
	symbols (count).str_p = addrel (tkn_ptr, 1);
	symbols (count).length = tkn_len;
	symbols (count).offset = sym_pos;

     end add_to_array;

connect_symbols_to_block:
     procedure (a_parent, a_parent_ptr);		/* implied input: addr(symbols), count */

dcl	a_parent fixed bin (18);
dcl	a_parent_ptr ptr;
dcl	(i1, j1, len) fixed bin (18);
dcl	last_len fixed bin (18);
dcl	SB fixed bin (18);
dcl	SBP ptr;

	SB = a_parent;
	SBP = a_parent_ptr;

	call sort_symbols;

	last_len = 1;
	last_sym = 0;

	do i1 = 1 to count;

	     /* chain symbols together using the brother chain */

	     j1 = symbols (i1).offset;

	     if last_sym = 0
	     then SBP -> runtime_block.start = forward_ref (j1 - SB);
	     else addr (sym_sec (last_sym)) -> runtime_symbol.brother = rel_ref (j1 - last_sym);

	     last_sym = j1;

	     /* fill in lookup vector for block as we go */

	     len = symbols (i1).length;

	     do j1 = last_len to 4 while (len >= lengths (j1));
		if SBP -> runtime_block.chain (j1) = "0"b
		then do;
		     last_len = j1 + 1;
		     SBP -> runtime_block.chain (j1) = forward_ref (last_sym - SB);
		     end;
		end;
	     end;					/* loop to chain symbols and build block.chain(*) */
     end connect_symbols_to_block;

process_variable:
     procedure (a_symbol, a_len, a_set_address, a_var);

dcl	a_len fixed bin (18);
dcl	a_set_address bit (1) aligned;
dcl	a_symbol ptr;
dcl	a_var ptr;
dcl	i1 fixed bin (18);
dcl	mult fixed bin (18);
dcl	nd fixed bin (6);
dcl	set_address bit (1) aligned;
dcl	stack_offset fixed bin (18);
dcl	symb ptr;
dcl	var ptr;
dcl	encodep ptr;				/* pointer to encoded size */

	/* copy input arguments */

	symb = a_symbol;
	alloc_len = a_len;
	set_address = a_set_address;

	/* allocate symbol */

	if symb -> symbol.by_compiler | (^all_symbols & ^symb -> symbol.put_in_symtab)
	then do;
	     alloc_len = 0;
	     a_var = null;				/* set output argument */
	     return;
	     end;

	call allocate_symbol (get_acc_str$symbol (symb), alloc_len, blk, "0"b, var);
	call add_to_array;

	/* set data type and precision */

	var -> runtime_symbol.type = bit (convert_data_type (fptype, symb -> symbol.data_type), 6);

	if symb -> symbol.character
	then do;
	     if symb -> symbol.star_extents
	     then do;
		encodep = addr (var -> runtime_symbol.size);
		encodep -> encoded_value.flag = "10"b;	/* ENCODED */
		encodep -> encoded_value.code = "0"b;	/* Value is contents of stack word (n3) */
		encodep -> encoded_value.n1, encodep -> encoded_value.n2 = "0"b;
		encodep -> encoded_value.n3 = get_address (addr (rands (symb -> symbol.v_length)));
		end;
	     else var -> runtime_symbol.size = symb -> symbol.char_size + 1;
	     end;
	else var -> runtime_symbol.size = convert_size (symb -> symbol.data_type);

	var -> runtime_symbol.units = substr (unspec (symb -> symbol.units), 2, 2);

	/* set symbol address */

	if set_address then var -> runtime_symbol.location = get_address (symb);

	/* if symbol is dimensioned, add bound fields */

	if symb -> symbol.dimensioned
	then do;
	     dp = addr (rands (symb -> symbol.dimension));/* get pointer to dimension info */

	     nd = dp -> dimension.number_of_dims;	/* get and store number of dimensions */
	     var -> runtime_symbol.ndims = bit (nd, 6);
	     var -> runtime_symbol.simple = "0"b;	/* long runtime symbol node allocated */
	     var -> runtime_symbol.array_units = substr (unspec (symb -> symbol.units), 2, 2);
	     alloc_len = simple_len + 2 + 3 * nd;

	     if sym_pos + alloc_len >= sym_max_len
	     then call print_message (414, "object_segment", object_max_len - bias);

	     if symb -> symbol.v_length = 0
	     then mult = symb -> symbol.element_size;
	     else mult = 0;

	     /* if variable extents, may use values stored in the array's descriptor */

	     if symb -> symbol.variable_extents | symb -> symbol.star_extents
	     then stack_offset = binary (get_address (addr (rands (symb -> symbol.hash_chain))), 18);

	     /* process each bound in turn */

	     do i1 = 0 to nd - 1;

		/* multiplier is constant until variable bound is encountered */

		if mult > 0			/* multiplier is a constant */
		then var -> runtime_symbol.bounds (nd - i1).multiplier = mult;
		else do;

		     /* multiplier will refer to field in runtime descriptor for the array */
		     /* If we are character*(*) we need a character
		        multiplier from the extended descriptor. */

		     if symb -> symbol.star_extents
		     then var -> runtime_symbol.bounds (nd - i1).multiplier = stack_offset + i1 + 1 + nd * 3;
		     else var -> runtime_symbol.bounds (nd - i1).multiplier = stack_offset + i1 * 3 + 3;
		     substr (unspec (var -> runtime_symbol.bounds (nd - i1).multiplier), 1, 6) = "100000"b;
		     end;

		/* fill in the lower bound information */

		if dp -> dimension.v_bound (i1 + 1).lower
		then do;
		     mult = 0;
		     var -> runtime_symbol.bounds (nd - i1).lower = stack_offset + i1 * 3 + 1;
		     substr (unspec (var -> runtime_symbol.bounds (nd - i1).lower), 1, 6) = "100000"b;
		     end;
		else var -> runtime_symbol.bounds (nd - i1).lower = dp -> dimension.lower_bound (i1 + 1);

		/* fill in the upper bound information */

		if dp -> dimension.v_bound (i1 + 1).upper
		then do;
		     mult = 0;
		     var -> runtime_symbol.bounds (nd - i1).upper = stack_offset + i1 * 3 + 2;
		     substr (unspec (var -> runtime_symbol.bounds (nd - i1).upper), 1, 6) = "100000"b;
		     end;
		else var -> runtime_symbol.bounds (nd - i1).upper = dp -> dimension.upper_bound (i1 + 1);

		/* update multiplier for next dimension */

		if mult > 0
		then mult = mult * dp -> dimension.size (i1 + 1);

		end;

	     /* set virtual origin */

	     if dp -> dimension.variable_virtual_origin
	     then do;
		var -> runtime_symbol.virtual_org =
		     binary (get_address (addr (rands (dp -> dimension.virtual_origin))), 18);
		substr (unspec (var -> runtime_symbol.virtual_org), 1, 6) = "100000"b;
		end;
	     else var -> runtime_symbol.virtual_org = dp -> dimension.virtual_origin;

	     end;					/* do block for dimensioned variable */

	/* store offset of symbol entry in symbol node */

	if symb -> symbol.put_in_symtab then symb -> symbol.runtime = bit (sym_pos, 18);

	/* set output argument */

	a_var = var;

     end process_variable;

rel_ref:
     procedure (value) returns (bit (18) aligned);	/* procedure to produce rel pointers */

dcl	value fixed bin (18);

	if value >= 0
	then do;

forward_ref:
     entry (value) returns (bit (18) aligned);

	     return (bit (value, 18));
	     end;

	else do;

backward_ref:
     entry (value) returns (bit (18) aligned);

	     return (bit (binary (factor + value, 18), 18));
	     end;

     end rel_ref;


unpack:
     procedure (field) returns (fixed bin (18));

dcl	field bit (18) unaligned;

	if substr (field, 1, 1) = "0"b
	then return (binary (field, 18));
	else return (binary (field, 18) - factor);

     end unpack;


get_address:
     procedure (symbol_ptr) returns (bit (18) aligned);

dcl	symbol_ptr ptr;

	if symbol_ptr -> symbol.large_address
	then return (bit (binary (symbol_ptr -> symbol.address.offset + symbol_ptr -> symbol.location, 18), 18));
	else if symbol_ptr -> symbol.stack_indirect
	then return (bit (binary (symbol_ptr -> symbol.location, 18), 18));
	else return (bit (binary (symbol_ptr -> symbol.address.offset, 18), 18));

     end get_address;

get_acc_str:
     procedure (a_str) returns (fixed bin (18));

dcl	a_str char (*);
dcl	full_offset fixed bin (18);
dcl	last_tkn ptr;
dcl	not_found bit (1) aligned;
dcl	str char (256) varying;
dcl	sym_node ptr;
dcl	tkn_off fixed bin (18);
dcl	vstr char (32) varying;

dcl	1 acc aligned based,
	  2 pad1 bit (36) unaligned,
	  2 pad2 bit (9) unaligned,
	  2 str char (n) unaligned;

	/* copy input arguments */

	str = a_str;
	n, tkn_len = length (str);
	goto common;


get_acc_str$symbol:
     entry (sym_node) returns (fixed bin (18));

	str = sym_node -> symbol.name;
	n, tkn_len = length (str);
	goto common;


get_acc_str$varying:
     entry (vstr) returns (fixed bin (18));

	str = vstr;
	n, tkn_len = length (str);

common:

	/* save length info */

	min_len = min (n, min_len);
	max_len = max (n, max_len);

	/* search appropriate partial list for this token */

	last_tkn = null;				/* previous token in list */

	if token_list (n).first = 0
	then tkn_ptr = null;			/* first token for this list */
	else do;
	     tkn_ptr = addr (sym_sec (token_list (n).first));
	     not_found = "1"b;

	     do while (not_found);
		if str = tkn_ptr -> acc.str		/* token node already allocated */
		then return (binary (rel (tkn_ptr), 18) - symrel + 1);

		if str < tkn_ptr -> acc.str		/* strings must be ordered alphabetically */
		then not_found = "0"b;		/* insert new token here */
		else do;
		     last_tkn = tkn_ptr;		/* previous token in list */
		     if tkn_ptr -> runtime_token.next = "0"b
		     then do;			/* at the end of the list, get out */
			not_found = "0"b;
			tkn_ptr = null;		/* no following token in list */
			end;
		     else tkn_ptr = addrel (tkn_ptr, tkn_ptr -> runtime_token.next);
		     end;				/* do block to get next token */
		end;				/* loop thru partial list */
	     end;					/* do block for searching partial list */

	/* must create a new token node; first link it into the list */

	full_offset = symrel + sym_pos;

	if last_tkn = null
	then token_list (n).first = sym_pos;		/* token is at the head of the list */
	else last_tkn -> runtime_token.next = forward_ref (full_offset - binary (rel (last_tkn), 18));

	if tkn_ptr = null
	then do;
	     token_list (n).last = sym_pos;		/* token is at the tail of the list */
	     addr (sym_sec (sym_pos)) -> runtime_token.next = "0"b;
	     end;
	else addr (sym_sec (sym_pos)) -> runtime_token.next = backward_ref (binary (rel (tkn_ptr), 18) - full_offset);

	/* build a new token node */

	tkn_ptr = addr (sym_sec (sym_pos));
	tkn_off = sym_pos + 1;
	tkn_ptr -> runtime_token.dcl = "0"b;
	tkn_ptr -> runtime_token.size = tkn_len;
	substr (tkn_ptr -> runtime_token.string, 1, n) = str;

	/* bump length of sym section and return */

	sym_pos = sym_pos + size (tkn_ptr -> runtime_token);
	return (tkn_off);

     end get_acc_str;

sort_symbols:
     procedure ();

dcl	(i1, j1, d, first) fixed bin (18);
dcl	swap_em bit (1) aligned;
dcl	length builtin;

dcl	1 swap like symbols aligned;

dcl	1 j_struct aligned based (symbols (j1).str_p),
	  2 pad bit (9) unaligned,
	  2 j_string char (symbols (j1).length) unaligned;

dcl	1 j_plus_d_struct aligned based (symbols (j1 + d).str_p),
	  2 pad bit (9) unaligned,
	  2 j_plus_d_string char (symbols (j1 + d).length) unaligned;

	/* get first power of two greater than number of symbols */

	do d = 1 repeat d + d while (d <= count);
	     end;

	d = divide (d, 2, 17, 0) - 1;			/* get d such that d = 2**n-1 & 2**n < count <= 2**(n+1) */

	/* loop until entire list is processed */

	do while (d > 0);
	     do first = 1 to d;
		do i1 = first to count by d;

		     /* bubble strings up on its parital list */

		     j1 = i1;
		     swap_em = "1"b;

		     do while (swap_em & j1 > 0 & j1 + d <= count);

			swap_em = "0"b;

			if length (j_string) > length (j_plus_d_string)
			then swap_em = "1"b;
			else if length (j_string) = length (j_plus_d_string)
			then if j_string > j_plus_d_string
			     then swap_em = "1"b;

			if swap_em
			then do;
			     swap = symbols (j1);
			     symbols (j1) = symbols (j1 + d);
			     symbols (j1 + d) = swap;
			     j1 = j1 - d;
			     end;
			end;			/* bubble loop */
		     end;
		end;

	     d = divide (d, 2, 17, 0);
	     end;
     end sort_symbols;

octal:
     proc (bits) returns (char (12));

dcl	bits bit (36) aligned;
dcl	octal_string char (12) aligned;

dcl	ioa_$rsnnl entry options (variable);

	call ioa_$rsnnl ("^w", octal_string, 12, bits);
	return (octal_string);
     end octal;
     end make_symbol_table;

     end fort_make_symbol_section;
