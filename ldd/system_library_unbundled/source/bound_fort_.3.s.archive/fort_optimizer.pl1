/****^  ******************************************************
        *                                                    *
        * Copyright, (C) Honeywell Limited, 1983             *
        *                                                    *
        * Copyright (c) 1972 by Massachusetts Institute of   *
        * Technology and Honeywell Information Systems, Inc. *
        *                                                    *
        ****************************************************** */



/****^  HISTORY COMMENTS:
  1) change(86-07-14,BWong), approve(86-07-14,MCR7442), audit(86-07-17,Ginter),
     install(86-07-28,MR12.0-1105):
     Fix fortran bug 488.
                                                   END HISTORY COMMENTS */


/* format: style4,delnl,insnl,^ifthendo,indnoniterend,inditerdo,indend,^indproc,indcom,declareind5 */
fort_optimizer:
     procedure (pt1);

/****^
Written:	24 January 1978 by Richard A. Barnes

Modified: 16 Apr 86, AFG - 488: Set "used" bit for symbols used as variable
	offsets in folded array_ref's.
Modified: 18 Sep 84, HH - 441: Temporarily bypass bug by disabling 'constant_assign'.
Modified: 22 Jun 84, MM - Install typeless functions support.
Modified: 28 Mar 84, HH - Install HFP support.
Modified: 27 Jul 83, HH - 391: Fix substrings of 'constant_value' variables.
Modified:	17 Jun 83, HH - 383: Add support for 'process_param_list_op'.
Modified: 31 Jan 83: HH - Install LA/VLA support.
Modified: 20 Dec 1982, 359: TO - read_namelist needs processing in
	     'optimize_flow_unit' to give its namelist variables a 'set'
	     context.
Modified: 29 May 1982, TO - 'build_flow_units' was not calling
	     'connect_jump_assigned' unless both an 'assign' and a 'goto'
	     were seen.  It should have been either.
Modified: 13 April 1982, TO - Modify message 384 call to include range of 
	lines which are being removed.
Modified: 15 March 1981, HH - Fix bug 263:  make 'constant_expression' trap
          arithmetic exceptions during constant folding.
Modified: 28 October 1981, CRD - Support for the inquire statement.
Modified: 20 October 1981, CRD - Internal files.
Modified: 3 September 1981, CRD - Fix bug 337.  Changed reduce not to drop ref
	counts when unthreading, but rather have reduce_strength do it later.
	If the expression is freed in the interim, the reference counts will
	not have been spuriously decremented.
Modified: 2 September 1981, CRD - Fix bug 334 by eliminating special case for
	equal_op and not_equal_op in analyze_loop_index_values.  The special
	case was apparently added (by RAB on 1 December 1979) to improve
	object code, but it also introduces a bug.  Since no one remembers
	the intent of the special case, it is being removed at the risk of
	losing some optimization.
Modified: 31 August 1981, CRD - Change make_jump_to to insert another
	opt_statement, so that derive_insert_for_bt does not use the
	previous flow unit by mistake.
Modified: 31 July 1981, CRD - Remove optimize_jump.  Logic will be placed in
	cg macros, to avoid problems with discarded machine states.
Modified: 28 July 1981, CRD - Change handling of assing_label operator in
	build_flow_units -- operand is not always an executable label.
Modified: 14 July 1981, CRD - Fix bug in which reduce_strength uses the wrong
	induction variable when eliminating sub_index operators.
Modified: 12 May 1981, CRD - Add equiv_op, not_equiv_op.
Modified: 13 April 1981, CRD - Fix unreported bug in which opt_subscripts are
	not properly reduced to constants if the constant is a result of
	folding and there is no sub_index operator.
Modified: 25 February 1981, CRD - Minor auditing changes.
Modified: 21 January 1981, CRD - Remove the pseudo-recursive free_expression
	subroutine introduced in the fix to bug 271.  Fix bug 271 instead by
	freeing the operator associated with a strength reduction frame if
	its output has a zero reference count.  This fixes bug 304.
Modified: 5 January 1981, CRD - Remove some invalid PL/I in
	constant_expression and constant_assign.
Modified: 17 December 1980, CRD - Fix bug 280.  This was motivated
	by the addition of block IF statements.
Modified: 11 December 1980, CRD - Fix bug 299.  New back targets
	created by the optimizer did not have flow_unit.has_label
	set.
Modified: 9 December 1980, CRD to extend arrays for new block_if,
	else_if, and else operators.
Modified: 1 December 1980, CRD to fix a bug in index_value_analysis
	in which the input to an increment operator was not
	disqualified if the output was not eligible.
Modified: 25 November 1980, CRD to fix a bug in process_frozen_for_do
	in which the assignment was erroneously eliminated if the
	rhs was a symbol whose sets were moved out of the loop.
Modified: 24 November 1980, CRD to permit constant_expression to fold
	relational operators, and to add optimize_jump.
Modified: 8 October 1980 by CRD to fix bugs 262 and 264.  The special
	handling of "symbol = constant" is now done by
	constant_assign.  Character constants are now treated
	properly.
Modified: 1 October 1980 by CRD to add free_expression, and to change
	reduce_strength to call it when an equivalent induction
	variable has been found.
Modified: 16 September 1980 by CRD to properly free operators that
	are unthreaded by reduce and whose operators are in loop
	end lists.
Modified: 16 September 1980 by CRD to change search_for_equivalent to
	not use the global variable which, and to change
	record_secondaries to not record symbols with coordinate 0.
Modified: 28 July 1980 by CRD to fix use_inputs not to replace the
	first operand of an opt_subscript operator with a constant,
	and to make it set the allocate bit for the constant node.
Modified: 22 July 1980 by CRD to fix optimize_flow_unit not to
	replace the first operand of an opt_subscript operator with
	a constant.
Modified: 18 June 1980 by CRD to make constant_expression work on
	sub_index operators that are not offsets of opt_subscript
	operators.
Modified: 16 June 1980 by CRD to fix bug 261 (machine state not
	cleared before loop entry flow units).
Modified:	14 March 1980 by RAB to add case to try to calculate range
	by considering vars that assign to the var in question.
	Also unreferenced vars in fort_optimizer were cleaned out,
	and print_hash_bucket_meters was moved to after the include
	files.
Modified:	17 February 1980 to make hash use addition rather than
	exclusive or to derive mod_2_sum.
Modified:	13 February 1980 by RAB to allow for optional metering of
	the primary list hash buckets.
Modified:	9 February 1980 by RAB to change index_value_analysis to
	allow induction variables that are busy_on_exit from a loop
	to be kept in an index register if they are known to be
	non-negative.
Modified:	2 February 1980 by RAB to recognize LHS of assignment of
	form i = j as possible induction variable.  Add ass_chain.
Modified:	31 January 1980 by RAB to add is_suitable_loop_exit to improve
	check made in calculate_range_for_counter.
Modified:	26 January 1980 by RAB to add calculate_range_for_counter and to
	fix minor glitch in remove_dead_assignments.
Modified:	9 January 1980 by RAB - to fix bug caused when flow_unit.n_in_loop_end
	exceeds 127 -- reference counts get left too high because size condition
	occurs on operator.number.
Modified:	30 December 1979 by RAB to turn on the induction variable
	bit for all new induction variables found by add_potential_induction_var.
Modified:	27 December 1979 by RAB to allow induction variables that
	are incremented by a non_constant to be kept in an index
	register as long as they are not used in a comparison for
	other than equality.
Modified:	18 December 1979 by RAB to complete register optimizer
	changes and to pool free lists by size for those containing
	items of size 2 - 4.
Modified:	1 December 1979 by RAB to not bother calculating range info
	for induction vars involved in equals or not_equals comparisons
	and to require that induction_vars involved in jump_arithmetic
	be fixed bin(17) in order to be kept in an index register.
Modified:	24 September 1979 by RAB to improve fix to bug 237.
Modified:	20 September 1979 by RAB to add index_value_analysis for register optimizer.
Modified:	17 September 1979 by RAB - to make first set of changes in
	preparation for register optimization.
Modified:	13 September 1979 by RAB - to fix bug 237 in which the optimizer
	does not realize that real and complex variables may be equivalenced
	together and be simultaneously defined.  This is the only case
	of mixed data type aliasing in the language.
Modified:	1 September 1979 by RAB - to fix 234 in which the optimizer
	mistakenly assumes that the encode statements completely sets
	its target buffer, and so will mistakenly remove preceding
	assignments to the buffer if it is not referenced in between.
Modified:	14 August 1979 by RAB - to implement most of Fortran 77 char mode.
	Data flow analysis has been greatly simplified by using flow_unit.always_completely_set.
	flow_unit.dim_or_alias_or_not_set has been removed along with various masks.
Modified:	13 August 1979 by RAB to change last_assigned_op from 95 to 97.  This
	adds cat_op and substr_op but does not completely implement substr_op.
Modified:	4 July 1979 by RAB to fix 218 in which the loop_end_chains were
	not necessarily built after the bodies of all contained loops.
	This was fixed by moving loop_end_chain info from loop node
	to flow_unit node, by making sure loop.last_unit was good
	for all contained loops as well as for this loop, and
	by placing in loop_end list for the current loop all
	temps used_across_loops in the bt_list that are already
	in a loop_end list for an inner loop.
Modified:	28 June 1979 by RAB - to speed up compute_busy_on_exit with
	flow_unit.dim_or_alias_or_not_set.
Modified:	27 June 1979 by RAB - to optimize goto a goto statement.
Modified:	20 June 1979 by RAB to fix 214 in which the optimizer
	builds incorrect flow information for err=, end=, and
	assigned goto's.
Modified:	20 June 1979 by RAB to improve the busy_on_exit algorithm
	so that dimensioned static variables are not considered
	busy_on_exit from a subprogram unless they are used
	in the subprogram.
Modified:	20 June 1979 by RAB to improve the busy_on_exit algorithm so that
	scalar static variables are not considered busy_on_exit from a
	subprogram unless they might be used in a future invocation of the
	subprogram before they are set.
Modified:	2 June 1979 by RAB to greatly speed up intersection by
	use of flow_unit.is_active_operator -> obits and
	operator.coordinate
Modified:	27 May 1979 by RAB to diagnose a loop without an exit
Modified: 25 May 1979 by RAB to fix bug in redirect_edge
Modified:	19 May 1979 by RAB to improve remove_loop
Modified:	16 May 1979 by RAB to initialize loop.has_side_effects
Modified:	8 April 1979 by RAB to make minor improvements in strength
	reduction and to note why commoning MUST occur while
	candidates for strength reduction are being found
Modified:	26 March 1979 by RAB to recompute usage information before
	removing dead assignments
Modified:	1 March 1979 by RAB to remove all assignment made dead
	by constant propagation.
Modified:	10 December 1978 by RAB - to change named constant test
	from symbol.initialed to symbol.initial ^= 0 because of
	parse's special handling of zero.
Modified: 06 December 1978 by PES - for %options and %globals.
Modified: 25 October 1978 by PES- for large common and arrays.
Modified:	27 September 1978 by RAB to improve fix to 187
Modified:	23 September 1978 by RAB to fix 187
	(back_target not necessarily before every flow_unit in a loop)
****/

dcl  pt1 pointer;					/* ptr to shared_globals */

dcl  adam_loop pointer;				/* ptr to non_iterative loop representing the subprogram */
dcl  alias_mask bit (7) aligned internal static options (constant) initial ((7)"1"b);
dcl  aliasable_mask (0:7) bit (max_sym) aligned based (aliasable_mask_p);
dcl  aliasable_mask_p pointer;			/* ptr to aliasable_mask */
dcl  assignment_class fixed binary (18) internal static initial (4);
dcl  always_safe_to_move_class fixed binary (18);		/* ops in this and lower classes may be moved from
						   nonarticulation blocks */
dcl  cannot_fault_class fixed binary (18) internal static initial (1);
dcl  cs pointer;					/* ptr to cur_subprogram */
dcl  consolidating bit (1) aligned;			/* "1"b -- consolidate_subprogram running */
dcl  do_timings bit (1) aligned;			/* "1"b -- timing info shd be printed */
dcl  entry_unit pointer;				/* ptr to dummy entry flow unit */
dcl  exit_unit pointer;				/* ptr to dummy exit flow unit */
dcl  flow_unit_vector_p pointer;			/* ptr to flow_unit_vector */
dcl  free (2:4) pointer;				/* ptr to free lists by size */
dcl  freefu pointer;				/* ptr to free list of flow_units */
dcl  freei pointer;					/* ptr to free list of input_to nodes */
dcl  freep pointer;					/* ptr to list of partially freed primaries */
dcl  freep_tail pointer;				/* ptr to end of list of partially freed primaries */
dcl  freesrv pointer;				/* ptr to chain of free strength reduction variable nodes */
dcl  full_strength_reduction bit (1) aligned;		/* ON if we should include induction vars updated by
						   nonincrements */
dcl  function_class fixed binary (18) static initial (6);
dcl  hash_mask bit (4297) aligned;			/* mask used to speed up search for expressions available
						   for commoning */
dcl  highest_reducible_class fixed binary (18) internal static initial (4);
dcl  i fixed binary (18);
dcl  init_frame pointer;				/* ptr to initial frame used in reduce_strength */
dcl  init_lp_frame pointer;				/* ptr to initial frame used in optimize_subprogram */
dcl  integer_scalar_mask bit (max_sym) aligned based (integer_scalar_mask_p);
dcl  integer_scalar_mask_p pointer;			/* -> integer_scalar_mask */
dcl  loop_entry_list pointer;				/* ptr to chain of loop entry units */
dcl  loop_vector_p pointer;				/* ptr to loop vector */
dcl  max_flow_units fixed binary (18);			/* length of flow_unit_vector */
dcl  max_operands fixed binary;			/* maximum value of operator.number */
dcl  max_operators fixed binary (18);			/* length of obits */
dcl  max_sym fixed binary (18);			/* maximum length of bit vectors */
dcl  meter_hash_buckets bit (1) aligned;
dcl  n_flow_units fixed binary (18);			/* number of flow units created */
dcl  n_loops fixed binary (18);			/* number of loops created */
dcl  n_operators fixed binary (18);			/* number of operators given coordinates in obits */
dcl  n_sym fixed binary (18);				/* number of symbols in bit vectors */
dcl  need_consolidation_pass bit (1) aligned;		/* "1"b -- reoptimize after all other optimizations done */
dcl  non_auto_mask bit (max_sym) aligned based (non_auto_mask_p);
dcl  non_auto_mask_p pointer;				/* -> non_auto_mask */
dcl  one fixed binary (18);				/* operand for integer constant 1 */
dcl  onep pointer;					/* ptr to one */
dcl  operand_base pointer;				/* ptr to operand region */
dcl  operand_max_len fixed binary (19);			/* maximum length of operand region */
dcl  opt_base pointer;				/* ptr to optimizer's region */
dcl  opt_max_len fixed binary (19);			/* maximum length of optimizer's region */
dcl  polish_base pointer;				/* ptr to polish region */
dcl  polish_max_len fixed binary (19);			/* maximum length of polish region */
dcl  quad_max_len fixed binary (19);			/* maximum length of quad (tuple) region */
dcl  quadruple_base pointer;				/* ptr to quad (tuple) region */
dcl  s_list pointer;				/* ptr to secondary list */
dcl  scan_bits_p pointer;				/* ptr to scan_bits */
dcl  scan_vector_p pointer;				/* ptr to scan_vector */
dcl  shared_struc_ptr pointer;			/* ptr to shared_globals */
dcl  state_discarded bit (1) aligned;			/* "1"b -- no current machine state */
dcl  temp_bits_p pointer;				/* ptr to temp_bits */
dcl  unlikely_to_fault_class fixed binary (18) internal static initial (2);
dcl  zero fixed binary (18);				/* operand for integer constant 0 */

	/* experiments seem to show that 11 is the best hash_table size,
	   although 23 looks good in some cases. */

dcl  1 bt_list_st (0:10) automatic aligned,		/* hash table for back target's primary list */
       2 bt_list pointer unaligned;

dcl  1 p_list_st (0:10) automatic aligned,		/* hash table for primary list */
       2 p_list pointer unaligned;

dcl  hash_counter (0:10) fixed binary;			/* used for metering p_list & bt_list. */

dcl  (
     full_optimization initial (1),
     common_only initial (2)
     ) fixed binary (18) internal static options (constant);

dcl  (
     complete_fu initial (1),
     partial_fu initial (2)
     ) fixed binary (18) internal static options (constant);

	/* op_class:
	   0	invalid
	   1	reducible, no chance of exception
	   2	reducible, small chance of exception
	   3	reducible, large chance of exception
	   4	reducible assignment
	   5	irreducible assignment
	   6	call or func_ref
	   7	entry point
	   8	jump
	   9	jump_arithmetic
	   10	jump_computed
	   11	jump_assigned
	   12	jump_true, jump_false
	   13	return, stop
	   14	error_label, end_label
	   15	irreducible, no special case
	   16	assign_label
	   17	end_unit
	   18	read_namelist
	   19	write_namelist
	   20	non_executable, no_op
	   21	irreducible, partially sets
	   22	inquire
	*/

dcl  op_class (109) fixed binary internal static initial (4, 2, 2, 2, 3, 3, 2, 1, 1, 1,
						/* 1 - 10 */
	1, 1, 1, 1, 1, 1, 8, 0, 9, 10,		/* 11 - 20 */
	11, 16, 15, 15, 15, 14, 14, 15, 15, 15,		/* 21 - 30 */
	(10) 15,					/* 31 - 40 */
	13, 15, 13, 0, 0, 0, 0, 3, 0, 0,		/* 41 - 50 */
	0, 6, 7, 0, 7, 7, 7, 0, 0, 6,			/* 51 - 60 */
	15, 17, 21, 21, 1, 1, 1, 1, 4, 5,		/* 61 - 70 */
	5, 5, 5, 0, 15, 15, 15, 2, 1, 1,		/* 71 - 80 */
	1, 15, 15, 15, 15, 15, 15, 12, 12, 1,		/* 81 - 90 */
	15, 18, 19, 15, 21, 1, 3, 0, 0, 0,		/* 91 - 100 */
	0, 0, 1, 1, 15, 21, 22, 7, 5);		/* 101 - 109 */

	/* xop_class:
	   1	opt_subscript
	   2	incrementing
	   3	relational
	   4	jump_arithmetic
	   5	assign
	   6	write_namelist
	   7	most operators
	   8	cat
	*/

dcl  xop_class (109) fixed binary internal static initial (5, 7, 7, 7, 7, 7, 7, 3, 3, 3,
						/* 1 - 10 */
	3, 3, 3, 7, 7, 7, 7, 7, 4, 7,			/* 11 - 20 */
	(10) 7,					/* 21 - 30 */
	(10) 7,					/* 31 - 40 */
	(10) 7,					/* 41 - 50 */
	(10) 7,					/* 51 - 60 */
	7, 7, 7, 7, 7, 1, 7, 7, 7, 2,			/* 61 - 70 */
	7, 2, 2, 7, 7, 7, 7, 7, 7, 7,			/* 71 - 80 */
	(10) 7,					/* 81 - 90 */
	7, 7, 6, 7, 7, 8, 7, 7, 7, 7,			/* 91 - 100 */
	7, 7, 7, 7, 7, 7, 7, 7, 7);			/* 101 - 109 */

dcl  scan_bits bit (max_flow_units) aligned based (scan_bits_p);
						/* bit string used in scanning flow units */
dcl  temp_bits bit (max_sym) aligned based (temp_bits_p);	/* bit string used in busy_on_exit calculation */


dcl  1 flow_unit_vector_st based (flow_unit_vector_p) aligned,
       2 flow_unit_vector (max_flow_units) pointer unaligned;
						/* vector of flow_units in ascending order by level number */

dcl  1 loop_vector_st based (loop_vector_p) aligned,
       2 loop_vector (n_loops) pointer unaligned;		/* vector of loops in descending order by nesting depth
						   and front to back */

dcl  1 scan_vector_st aligned based (scan_vector_p),
       2 scan_vector (max_flow_units) pointer unaligned;	/* vector used in scanning flow_units */

dcl  bits bit (max_sym) aligned based;			/* one bit per symbol */
dcl  dbits bit (max_flow_units) aligned based;		/* one bit per flow_unit */
dcl  lbits bit (n_loops) aligned based;			/* one bit per loop */
dcl  obits bit (max_operators) aligned based;		/* one bit per operator */

dcl  opt (0:opt_max_len - 1) fixed binary (35) aligned based (opt_base);

dcl  rands (0:operand_max_len - 1) fixed binary (18) aligned based (operand_base);

dcl  polish (0:polish_max_len - 1) fixed binary (18) aligned based (polish_base);

dcl  quad (0:quad_max_len - 1) fixed binary (18) aligned based (quadruple_base);

dcl  1 secondary based aligned,			/* must be same size as primary */
       2 next pointer unaligned,			/* must overlay primary.next */
       2 last pointer unaligned,			/* must overlay primary.last */
       2 symbol pointer unaligned,
       2 primary pointer unaligned;

dcl  1 sr_cand based aligned,				/* strength reduction candidate node */
       2 next pointer unaligned,
       2 operator pointer unaligned,			/* strength reduction candidate */
       2 which fixed binary (18),			/* operand number of induction variable */
       2 statement pointer unaligned;			/* opt_statement in which operator appeared */

dcl  1 sr_var based aligned,				/* strength reduction variable node */
       2 next pointer unaligned,
       2 variable fixed binary (18),			/* newly created variable */
       2 all_constant bit (1) aligned,			/* all terms of initialization code are constant */
       2 sign_differs bit (1) aligned,			/* sign of increment differs from sign of original */
       2 sign_unknown bit (1) aligned,			/* sign of increment has unknown relationship to
						   sign of original */
       2 updated_by pointer unaligned,			/* -> operator updating its value inside the loop */
       2 used_in pointer unaligned,			/* -> mask indicating in which loops this has been used */
       2 ninst fixed binary (18),			/* number of tuples in initializing code */
       2 tuple (8) structure aligned,
         3 operator pointer unaligned,
         3 which fixed binary (18);

dcl  1 incr based aligned,				/* increment node */
       2 next pointer unaligned,
       2 value pointer unaligned,			/* -> increment operator */
       2 statement pointer unaligned,			/* -> increment statement */
       2 var_chain pointer unaligned;			/* -> chain of new induction vars */

dcl  1 dead_assign_cand based aligned,			/* dead assignment candidate node */
       2 next pointer unaligned,
       2 variable fixed binary (18),
       2 flow_unit pointer unaligned;

dcl  1 equiv_array based aligned,			/* equivalenced array info -- must be same size as INPUT_TO */
       2 next pointer unaligned,
       2 lowest fixed binary (18),
       2 highest fixed binary (18);

dcl  1 lp_frame based aligned,
       2 next pointer unaligned,
       2 back pointer unaligned,
       2 data structure aligned,
         3 this_fu pointer unaligned,
         3 last_fu pointer unaligned,
         3 next_lp pointer unaligned,
         3 hold_p_list pointer unaligned,
         3 hold_bt_list pointer unaligned,
         3 hold_incr_chain pointer unaligned,
         3 hold_sr_chain pointer unaligned,
         3 hold_sr_tail pointer unaligned,
         3 hold_ass_chain pointer unaligned,
         3 resume_st fixed binary (18),
         3 first_jump_target pointer unaligned;

dcl  section (10) character (25) varying internal static options (constant)
	initial ("assign_symbol_coordinates", "build_flow_units", "flow_analysis", "optimize_loop", "reduce_strength",
	"replace_tests", "remove_dead_assignments", "consolidate_subprogram", "recompute_usage", "index_value_analysis")
	;

dcl  1 timing_info aligned,
       2 last_vcpu fixed binary (71),
       2 last_pf fixed binary (18),
       2 last_section fixed binary (18),
       2 entry (10) aligned,
         3 vcpu fixed binary (18),
         3 pf fixed binary (18);

dcl  total_pf fixed binary (18);
dcl  total_vcpu float binary;
dcl  tx float binary;
dcl  (max_n_sym, max_n_loops, max_n_flow_units) fixed binary (18);

dcl  ioa_ entry options (variable);

dcl  (abs, addr, bit, char, dim, divide, fixed, float, hbound, length, ltrim, max, min, mod, null, rel, round, size,
     string, substr, sum, unspec) builtin;

%include fort_opt_nodes;
%include fort_nodes;
%include fort_system_constants;

dcl  1 shared_globals structure aligned based (shared_struc_ptr),
%include fort_shared_vars;
%include fort_options;

	if hbound (op_class, 1) ^= last_assigned_op | hbound (xop_class, 1) ^= last_assigned_op
	then do;
	     call print_message (382, "The size of the op_class array", "last_assigned_op");
	     return;
	     end;

	shared_struc_ptr = pt1;

	operand_max_len = shared_globals.operand_max_len;
	quad_max_len = shared_globals.quad_max_len;
	opt_max_len = shared_globals.opt_max_len;
	polish_max_len = shared_globals.polish_max_len;

	operand_base = shared_globals.operand_base;
	quadruple_base = shared_globals.quadruple_base;
	opt_base = shared_globals.opt_base;
	polish_base = shared_globals.polish_base;

	max_operands = 10b ** length (unspec (null -> operator.number)) - 1;

	meter_hash_buckets = "0"b;

	consolidating = "0"b;

	p_list (*) = null;
	bt_list (*) = null;

	hash_mask = "0"b;

	free (*) = null;

	s_list, freei, freep, freep_tail, freesrv, init_frame, loop_entry_list, entry_unit, exit_unit, adam_loop,
	     freefu, init_lp_frame = null;

	n_loops = 0;

	timing_info.last_section = 0;
	max_n_sym, max_n_loops, max_n_flow_units = 0;

	allocate_symbol_name = 0;

	zero = 0;
	zero = create_constant (int_mode, unspec (zero));

	one = 1;
	one = create_constant (int_mode, unspec (one));
	onep = addr (rands (one));

	full_strength_reduction = "1"b;

	/* MAIN OPTIMIZATION LOOP */

	do cur_subprogram = first_subprogram repeat cs -> subprogram.next_subprogram while (cur_subprogram > 0);
	     cs = addr (rands (cur_subprogram));

	     need_consolidation_pass = cs -> subprogram.options.consolidate;

	     if cs -> subprogram.options.ignore_articulation_blocks
	     then always_safe_to_move_class = unlikely_to_fault_class;
	     else always_safe_to_move_class = cannot_fault_class;

	     do_timings = cs -> subprogram.options.time_optimizer;

	     call timer (1);

	     call assign_symbol_coordinates;

	     call timer (2);

	     call build_flow_units;

	     call timer (3);

	     call flow_analysis;

	     call timer (4);

	     call optimize_subprogram;

	     call timer (10);

	     call index_value_analysis;

	     max_n_sym = max (max_n_sym, n_sym);
	     max_n_loops = max (max_n_loops, n_loops);
	     max_n_flow_units = max (max_n_flow_units, n_flow_units);

	     end;

	call timer (0);

	if do_timings
	then do;
	     total_vcpu = float (sum (timing_info.vcpu (*)));
	     total_pf = sum (timing_info.pf (*));

	     call ioa_ ("Section                         CPU    %   Pages");

	     do i = 1 to hbound (section, 1);
		tx = float (timing_info.vcpu (i));
		call ioa_ ("^27a^9.3f^6.1f^6d", section (i), tx / 1.0e6, 100e0 * tx / total_vcpu, timing_info.pf (i));
		end;

	     call ioa_ ("TOTAL                      ^9.3f      ^6d", total_vcpu / 1.0e6, total_pf);
	     call ioa_ ("^/max(symbols):^-^d^/max(loops):^-^d^/max(flow_units):^-^d", max_n_sym, max_n_loops,
		max_n_flow_units);

	     end;

	shared_globals.free (*) = free (*);
	shared_globals.freei = freei;

	return;

timer:
     procedure (i);

	/* timing routine */

dcl  i fixed binary (18);

dcl  vcpu fixed binary (71);
dcl  (pf, last, dummy) fixed binary (18);
dcl  cpu_time_and_paging_ entry (fixed bin (18), fixed bin (71), fixed bin (18));

	if ^do_timings
	then return;

	if timing_info.last_section = 0
	then do;
	     call cpu_time_and_paging_ (timing_info.last_pf, timing_info.last_vcpu, dummy);
	     timing_info.vcpu (*) = 0;
	     timing_info.pf (*) = 0;
	     end;

	else do;
	     call cpu_time_and_paging_ (pf, vcpu, dummy);
	     last = timing_info.last_section;
	     timing_info.vcpu (last) = timing_info.vcpu (last) + (vcpu - timing_info.last_vcpu);
	     timing_info.pf (last) = timing_info.pf (last) + (pf - timing_info.last_pf);
	     timing_info.last_vcpu = vcpu;
	     timing_info.last_pf = pf;
	     end;

	timing_info.last_section = i;

     end timer;

assign_symbol_coordinates:
     procedure ();

	/* assigns coordinates to the symbols for use with the bit masks */

dcl  (s, h, ea, equiv_array_chain, equiv_array_tail) pointer;
dcl  (i, hdr, sym) fixed binary (18);
dcl  has_parameters bit (1) aligned;

dcl  1 initial aligned based,
       2 next fixed binary (18),
       2 limit fixed binary (18),
       2 value fixed binary (18);

	has_parameters = cs -> subprogram.has_parameters;
	equiv_array_chain, equiv_array_tail = null;

	/* symbols in common whose space is not overlapped by that of other symbols
	   get unique coordinates */

	/* loop to turn on in_equiv_stmnt for all symbols in common that might be overlapped
	   by equivalenced arrays */

	do hdr = cs -> subprogram.common_chain repeat h -> header.next_header while (hdr > 0);
	     h = addr (rands (hdr));

	     do sym = h -> header.first_element repeat s -> symbol.next_member while (sym > 0);
		s = addr (rands (sym));

		if s -> symbol.in_equiv_stmnt & s -> symbol.dimensioned
		then do;
		     ea = create_input_to ();

		     ea -> equiv_array.next = equiv_array_chain;
		     equiv_array_chain = ea;
		     if equiv_array_tail = null
		     then equiv_array_tail = ea;

		     ea -> equiv_array.lowest = s -> symbol.offset;
		     ea -> equiv_array.highest =
			s -> symbol.offset + addr (rands (s -> symbol.dimension)) -> dimension.array_size - 1;
		     end;
		end;

	     if equiv_array_chain ^= null
	     then do;
		do sym = h -> header.first_element repeat s -> symbol.next_member while (sym > 0);
		     s = addr (rands (sym));

		     do ea = equiv_array_chain repeat ea -> equiv_array.next
			while (^s -> symbol.in_equiv_stmnt & ea ^= null);

			if s -> symbol.offset >= ea -> equiv_array.lowest
			     & s -> symbol.offset <= ea -> equiv_array.highest
			then s -> symbol.in_equiv_stmnt = "1"b;
			end;
		     end;

		equiv_array_tail -> equiv_array.next = freei;
		freei = equiv_array_chain;
		equiv_array_chain, equiv_array_tail = null;
		end;
	     end;

	/* assign coordinates to all non constant referenced symbols.  Parameters
	   and equivalenced symbols get coordinates depending on their data_type. */

	if last_assigned_mode ^= length (alias_mask) | last_assigned_mode ^= hbound (aliasable_mask, 1)
	then do;
	     call print_message (382, "last_assigned_mode", "length(alias_mask)");
	     return;
	     end;

	n_sym = last_assigned_mode;
	do sym = cs -> subprogram.first_symbol repeat s -> symbol.next_symbol while (sym > 0);
	     s = addr (rands (sym));

	     s -> symbol.secondary = null;

	     if s -> symbol.allocate & ^s -> symbol.constant & ^s -> symbol.named_constant & ^s -> symbol.builtin
		& ^s -> symbol.stmnt_func & ^s -> symbol.namelist
	     then do;
		if s -> symbol.in_equiv_stmnt | s -> symbol.parameter | (s -> symbol.in_common & has_parameters)
		then s -> symbol.aliasable = "1"b;

		if (s -> symbol.static | s -> symbol.automatic) & s -> symbol.initial ^= 0 & ^s -> symbol.set
		     & ^s -> symbol.passed_as_arg & ^s -> symbol.aliasable & ^s -> symbol.dimensioned
		then do;

		     /* convert the symbol into a named constant */

		     s -> symbol.automatic, s -> symbol.static = "0"b;
		     s -> symbol.named_constant = "1"b;
		     s -> symbol.initial = addr (polish (s -> symbol.initial)) -> initial.value;
		     end;

		else if ^s -> symbol.parameter & ^s -> symbol.in_equiv_stmnt
		then do;
		     n_sym = n_sym + 1;
		     s -> symbol.coordinate = n_sym;
		     end;
		else s -> symbol.coordinate = s -> symbol.data_type;
		end;
	     end;

	/* allow room for creation of more symbols (use a min of 288 until we have a way to
	   recycle str_red-created vars) */

	max_sym, cs -> subprogram.max_sym = max (36 * divide (n_sym + 89, 36, 17, 0), 288);

	/* Set up aliasable_mask's, non_auto_mask, and integer_scalar_mask.	*/

	non_auto_mask_p = get_opt_space (size (non_auto_mask));
	non_auto_mask = alias_mask;

	integer_scalar_mask_p = get_opt_space (size (integer_scalar_mask));

	aliasable_mask_p = get_opt_space (size (aliasable_mask));
	aliasable_mask (0) = alias_mask;

	do i = 1 to length (alias_mask);
	     substr (aliasable_mask (i), i, 1) = "1"b;
	     end;

	do sym = cs -> subprogram.first_symbol repeat s -> symbol.next_symbol while (sym > 0);
	     s = addr (rands (sym));

	     if s -> symbol.coordinate > length (alias_mask)
	     then do;
		i = s -> symbol.coordinate;

		if ^s -> symbol.automatic
		then substr (non_auto_mask, i, 1) = "1"b;

		if s -> symbol.data_type = int_mode & ^s -> symbol.dimensioned
		then substr (integer_scalar_mask, i, 1) = "1"b;

		if s -> symbol.in_common
		then do;
		     substr (aliasable_mask (s -> symbol.data_type), i, 1) = "1"b;
		     substr (aliasable_mask (0), i, 1) = "1"b;
		     end;
		end;

	     end;

     end assign_symbol_coordinates;

build_flow_units:
     procedure ();

	/* builds flow_units and collects variable usage information */

dcl  need_new_unit bit (1) aligned;
dcl  (lp, o, p, st, cur_unit) pointer;
dcl  (op, next_statement, op_code, ipol) fixed binary (17);
dcl  i fixed binary (18);
dcl  chaining_input bit (1) aligned;

dcl  (jump_assigned_list, jump_assigned_target_list) pointer;

	/* initialize */

	chaining_input = "1"b;
	max_flow_units, n_operators, n_loops = 0;

	jump_assigned_list, jump_assigned_target_list = null;

	state_discarded = "1"b;
	need_new_unit = "1"b;			/* need a new unit to represent top of the program */
	adam_loop = create_loop (null);
	cur_unit, entry_unit = create_flow_unit ();
	entry_unit -> flow_unit.processed = "1"b;
	entry_unit -> flow_unit.position, entry_unit -> flow_unit.number = 1;
	exit_unit = create_flow_unit ();

	/* loop through the statement chain to get flow information */

	do cur_statement = cs -> subprogram.first_quad repeat next_statement while (cur_statement > 0);
	     st = addr (quad (cur_statement));
	     next_statement = fixed (st -> opt_statement.next, 18);

	     if st -> opt_statement.label ^= 0
	     then if addr (rands (st -> opt_statement.label)) -> label.executable
		then if addr (rands (st -> opt_statement.label)) -> label.referenced_executable
						/* must be a jump target */
		     then need_new_unit = "1"b;

	     if need_new_unit & st -> opt_statement.put_in_map
						/* put_in_map means executable */
	     then call change_cur_unit;

	     /* process this statement's operators getting usage and flow information */

	     do op = st -> opt_statement.first_operator repeat o -> operator.next while (op ^= next_statement);
		o = addr (quad (op));
		op_code = o -> operator.op_code;
		go to action (op_class (op_code));

action (1):					/* reducible */
action (2):					/* .. */
action (3):					/* .. */
action (4):					/* assignment */
action (5):					/* .. */
		n_operators = n_operators + 1;
		o -> operator.coordinate = n_operators;

		call use_inputs;
		call set ((o -> operator.output), 0, "1"b);
		go to step;

action (6):					/* call & func_ref */
		call process_call;
		go to step;

action (7):					/* entry points */
		/*** We won't create a flow_unit here because one has already been
		     created before the statement loop because we are either at the top
		     of the program, or are after an unconditional jump or return.
		***/
		call link (entry_unit, cur_unit);
		cur_unit -> flow_unit.entry_pt = "1"b;
		go to step;

action (8):					/* jump */
		call link_to_target (o -> operand (1));
		state_discarded = "1"b;
		need_new_unit = "1"b;

		if addr (rands (o -> operand (1))) -> label.statement = next_statement
		then do;

		     /* special case:  go to next_statement */

		     o -> operator.op_code = no_op;
		     o -> operator.number = 0;
		     end;

		go to step;

action (9):					/* jump_arithmetic */
		call use_inputs;
		do i = 2 to 4;
		     call link_to_target (o -> operand (i));
		     end;
		state_discarded = "1"b;
		need_new_unit = "1"b;
		go to step;

action (10):					/* jump_computed */
		call use_inputs;
		do i = 1 to o -> operator.operand (1) + bias;
		     call link_to_target (o -> operator.operand (i + 1));
		     end;
		need_new_unit = "1"b;
		go to step;

action (11):					/* jump_assigned */
		call use_inputs;
		call add_to_jump_assigned_list;
		state_discarded = "1"b;
		need_new_unit = "1"b;
		go to step;

action (12):					/* jump_true, jump_false */
		call use_inputs;
		call link_to_target (o -> operand (2));
		need_new_unit = "1"b;
		go to step;

action (13):					/* return, stop */
		call use_inputs;			/* in case of stop n */
		call link (cur_unit, exit_unit);
		state_discarded = "1"b;
		need_new_unit = "1"b;
		go to step;

action (14):					/* error_label, end_label */
		call link_to_target (o -> operand (1));
		call link_entry_to_target;
		addr (rands (o -> operand (1))) -> label.restore_prs = "1"b;
		need_new_unit = "1"b;
		go to step;

action (15):					/* irreducible */
		cur_unit -> flow_unit.has_side_effects = "1"b;

		call use_inputs;
		call set ((o -> operator.output), 0, "1"b);
		go to step;

action (16):					/* assign_label */
		call set ((o -> operator.output), 0, "1"b);
		if addr (rands (o -> operator.operand (1))) -> node.node_type = label_node
		then do;
		     call link_entry_to_target ();
		     call add_to_jump_assigned_target_list ();
		     end;
		go to step;

action (17):					/* end_unit */
		st -> opt_statement.flow_unit = exit_unit;
		call change_cur_unit;
		go to step;

action (18):					/* read_namelist */
		cur_unit -> flow_unit.has_side_effects = "1"b;

		ipol = addr (rands (o -> operand (1))) -> symbol.initial;
		do i = 1 to polish (ipol);
		     call set ((polish (ipol + i)), 0, "0"b);
		     end;
		go to step;

action (19):					/* write_name_list */
		cur_unit -> flow_unit.has_side_effects = "1"b;

		ipol = addr (rands (o -> operand (1))) -> symbol.initial;
		do i = 1 to polish (ipol);
		     call use_symbol (addr (rands (polish (ipol + i))));
		     end;
		go to step;

action (20):					/* non_executable, no_op */
		go to step;

action (21):					/* irreducible, partially sets */
		cur_unit -> flow_unit.has_side_effects = "1"b;

		call use_inputs;
		call set ((o -> operator.output), 0, "0"b);

		go to step;

action (22):					/* inquire */
		cur_unit -> flow_unit.has_side_effects = "1"b;

		do i = 1 to 3;
		     call use_one_input (i);
		     end;

		do i = 4 to o -> operator.number by 2;
		     if o -> operator.operand (i + 1) + bias = 4
						/* filename */
			| o -> operator.operand (i + 1) + bias = 14
						/* unit */
		     then call use_one_input (i);
		     else call set ((o -> operator.operand (i)), i, "0"b);
		     end;

		go to step;

action (0):					/* unexpected operators */
		call print_message (383, op_code - bias);

step:
		end;

	     st -> opt_statement.flow_unit = cur_unit;
	     cur_unit -> flow_unit.last_statement = cur_statement;
	     end;

	/* connect all flow_units ending in jump_assigned operators with
	   all possible targets */


	/* connect_jump_assigneds if EITHER we had an assign or a jump_assigned_list */

	if jump_assigned_list ^= null | jump_assigned_target_list ^= null
	then call connect_jump_assigneds;

	/* set n_flow_units */

	n_flow_units = exit_unit -> flow_unit.number;

	/* allocate dominated_by bit vectors */

	max_flow_units = 36 * divide (n_flow_units + 55, 36, 17, 0);

	do p = entry_unit repeat p -> flow_unit.next while (p ^= null);
	     p -> flow_unit.dominated_by = get_opt_space (size (dbits));
	     end;

	/* seg max_operators */

	max_operators, cs -> subprogram.max_operators = 36 * divide (n_operators + n_operators + 35, 36, 17);

	/* allocate bit vectors in loop node */

	adam_loop -> loop.is_member = get_opt_space (size (dbits));
	adam_loop -> loop.is_exit = get_opt_space (size (dbits));
	adam_loop -> loop.articulation_blocks = get_opt_space (size (dbits));

	return;

recompute_usage:
     entry;

	/* recompute_usage completely recomputes all flow_unit & loop usage bits after
	   most optimizations have been performed. */

	chaining_input = "0"b;

	/* zero out loop usage bits */

	do i = 1 to n_loops;
	     lp = loop_vector (i);
	     lp -> loop.used -> bits, lp -> loop.set -> bits, lp -> loop.busy_on_exit -> bits,
		lp -> loop.set_multiple -> bits = "0"b;
	     end;

	/* zero out all flow_unit usage bits */

	do cur_unit = exit_unit repeat cur_unit -> flow_unit.back while (cur_unit ^= null);
	     cur_unit -> flow_unit.used -> bits, cur_unit -> flow_unit.set -> bits,
		cur_unit -> flow_unit.busy_on_entry -> bits, cur_unit -> flow_unit.set_multiple -> bits,
		cur_unit -> flow_unit.busy_on_exit -> bits, cur_unit -> flow_unit.always_completely_set -> bits =
		"0"b;
	     end;

	/* scan through the quads picking up new usage info */

	do cur_statement = cs -> subprogram.first_quad repeat next_statement while (cur_statement > 0);
	     st = addr (quad (cur_statement));
	     next_statement = fixed (st -> opt_statement.next, 18);
	     cur_unit = st -> opt_statement.flow_unit;

	     /* process the statement's operators */

	     do op = st -> opt_statement.first_operator repeat o -> operator.next while (op ^= next_statement);
		o = addr (quad (op));
		op_code = o -> operator.op_code;
		go to reaction (op_class (op_code));

reaction (1):					/* reducible */
reaction (2):					/* .. */
reaction (3):					/* .. */
reaction (4):					/* assignment */
reaction (15):					/* irreducible */
		call use_inputs;
		call set ((o -> operator.output), 0, "1"b);
		go to restep;

reaction (5):					/* increment */
		call use_inputs;

		p = addr (rands (o -> operator.output));
		if p -> node.node_type = array_ref_node
		then p = addr (rands (p -> array_ref.parent));

		call use_symbol (p);
		call set ((o -> operator.output), 0, "1"b);
		go to restep;

reaction (6):					/* call & func_ref */
		call process_call;
		go to restep;

reaction (9):					/* jump_arithmetic */
reaction (10):					/* jump_computed */
reaction (11):					/* jump_assigned */
reaction (12):					/* jump_true, jump_false */
reaction (13):					/* return, stop */
		call use_inputs;
		go to restep;

reaction (16):					/* assign_label */
		call set ((o -> operator.output), 0, "1"b);
		go to restep;

reaction (18):					/* read_namelist */
		ipol = addr (rands (o -> operand (1))) -> symbol.initial;
		do i = 1 to polish (ipol);
		     call set ((polish (ipol + i)), 0, "0"b);
		     end;
		go to restep;

reaction (19):					/* write_namelist */
		ipol = addr (rands (o -> operand (1))) -> symbol.initial;
		do i = 1 to polish (ipol);
		     call use_symbol (addr (rands (polish (ipol + i))));
		     end;
		go to restep;

reaction (21):					/* irreducible, partially sets */
		call use_inputs;
		call set ((o -> operator.output), 0, "0"b);

		go to restep;

reaction (22):					/* inquire */
		do i = 1 to 3;
		     call use_one_input (i);
		     end;

		do i = 4 to o -> operator.number by 2;
		     if o -> operator.operand (i + 1) + bias = 4
						/* filename */
			| o -> operator.operand (i + 1) + bias = 14
						/* unit */
		     then call use_one_input (i);
		     else call set ((o -> operator.operand (i)), i, "0"b);
		     end;

		go to restep;

reaction (0):					/* unexpected operators */
		call print_message (383, op_code - bias);

reaction (7):					/* entry points */
reaction (8):					/* jump */
reaction (14):					/* error_label, end_label */
reaction (17):					/* end_unit */
reaction (20):					/* non_executable, no_op */
restep:
		end;
	     end;

	/* complete data flow analysis */

	call analyze_data_flow;

	return;

use_inputs:
     procedure ();

	/* marks all input operands as used */
	/* also chains temps & array_refs to their uses */

dcl  i fixed binary (18);

	do i = 1 to o -> operator.number;
	     call use_one_input (i);
	     end;

     end use_inputs;

use_one_input:
     procedure (iop);

	/* Marks the specified operand as used. */

dcl  (iop, i, opnd) fixed binary (18);
dcl  p pointer;					/* pointer to the node to "use" */
dcl  s pointer;					/* pointer to array_ref symbol nodes */
dcl  q pointer;					/* pointer to opt_subscript quad */

	i = iop;
	opnd = o -> operator.operand (i);

	if opnd > 0
	then do;
	     p = addr (rands (opnd));

	     if p -> node.node_type = symbol_node
	     then do;
		if p -> symbol.named_constant
		then do;

		     /* turn named constant into a constant */

		     if op_code = opt_subscript_op & i = 1
		     then addr (rands (p -> symbol.initial)) -> node.allocate = "1"b;
		     else o -> operator.operand (i) = p -> symbol.initial;

		     /* if constant is input to opt_subscript_op,
		        combine variable & constant offset */

		     if op_code = opt_subscript_op & i = 3
		     then call make_constant_opt_subscript (o);
		     end;

		else if i ^= 1 | op_code ^= opt_subscript_op
		then call use_symbol (p);
		end;

	     else if p -> node.node_type = temporary_node & chaining_input
	     then call chain_input (p, o, i);

	     else if p -> node.node_type = array_ref_node
	     then do;
		if chaining_input
		then call chain_input (p, o, i);

		/* get address of quad which produced the array_ref node */
		q = addr (quad (p -> array_ref.output_by));

		/* get address of variable offset if it exists */
		if q -> operator.operand (3) ^= 0
		then do;
		     s = addr (rands (q -> operator.operand (3)));

		     /* use temporary offset if it is a symbol */
		     if s -> node.node_type = symbol_node
		     then call use_symbol (s);
		     end;

		/* use array which is the parent of the array ref */
		s = addr (rands (p -> array_ref.parent));
		call use_symbol (s);
		end;
	     end;

     end use_one_input;

use_symbol:
     procedure (s);

dcl  s pointer;					/* symbol */
dcl  (c, dt, other_dt) fixed binary (18);

	if s -> symbol.coordinate > 0
	then do;
	     c = s -> symbol.coordinate;

	     substr (cur_unit -> flow_unit.used -> bits, c, 1) = "1"b;
	     if ^substr (cur_unit -> flow_unit.always_completely_set -> bits, c, 1)
	     then substr (cur_unit -> flow_unit.busy_on_entry -> bits, c, 1) = "1"b;

	     if s -> symbol.aliasable
	     then do;
		dt = s -> symbol.data_type;

		if s -> symbol.parameter
		then do;
		     cur_unit -> flow_unit.used -> bits = cur_unit -> flow_unit.used -> bits | aliasable_mask (dt);
		     cur_unit -> flow_unit.busy_on_entry -> bits =
			cur_unit -> flow_unit.busy_on_entry -> bits
			| (aliasable_mask (dt) & ^cur_unit -> flow_unit.always_completely_set -> bits);
		     end;

		else if c > length (alias_mask)
		then do;

		     /* the variable is in common */

		     substr (cur_unit -> flow_unit.used -> bits, dt, 1) = "1"b;
		     substr (cur_unit -> flow_unit.busy_on_entry -> bits, dt, 1) = "1"b;
		     end;

		else do;

		     /* the symbol is equivalenced.  Deal with the fact that
		        a real variable may be equivalenced with a complex
		        variable, and both may be simultaneously defined. */

		     if dt = real_mode
		     then other_dt = cmpx_mode;

		     else if dt = cmpx_mode
		     then other_dt = real_mode;

		     else other_dt = 0;

		     if other_dt > 0
		     then do;
			substr (cur_unit -> flow_unit.used -> bits, other_dt, 1) = "1"b;
			substr (cur_unit -> flow_unit.busy_on_entry -> bits, other_dt, 1) = "1"b;
			end;
		     end;
		end;
	     end;

     end use_symbol;

set:
     procedure (opnd, iop, always_sets);

	/* turns on set & set_multiple bits for opnd */

dcl  opnd fixed binary (18),				/* operand being set */
     iop fixed binary (18),				/* which operand of the operator (0 is output) */
     always_sets bit (1) aligned;			/* guarantees variable is set, and, if the
						   operand if a symbol node, that the whole
						   variable is set.	*/

dcl  (i, dt, other_dt) fixed binary (18);
dcl  always_completely_sets bit (1) aligned;		/* guarantees entire generation of variable is set */
dcl  p pointer;

	if opnd > 0
	then do;
	     always_completely_sets = always_sets;

	     p = addr (rands (opnd));

	     if p -> node.node_type = array_ref_node
	     then do;
		if op_code ^= opt_subscript_op
		then do;
		     always_completely_sets = "0"b;	/* sets only one array element or a substring */
		     if iop = 0 & chaining_input
		     then call chain_input (p, o, 0);
		     p = addr (rands (p -> array_ref.parent));
		     end;
		end;

	     if p -> node.node_type = symbol_node
	     then do;
		i = p -> symbol.coordinate;
		if i > 0
		then do;
		     if substr (cur_unit -> flow_unit.set -> bits, i, 1)
		     then substr (cur_unit -> flow_unit.set_multiple -> bits, i, 1) = "1"b;
		     else substr (cur_unit -> flow_unit.set -> bits, i, 1) = "1"b;

		     if p -> symbol.aliasable
		     then do;
			dt = p -> symbol.data_type;

			if p -> symbol.parameter
			then do;
			     cur_unit -> flow_unit.set_multiple -> bits =
				cur_unit -> flow_unit.set_multiple -> bits
				| (cur_unit -> flow_unit.set -> bits & aliasable_mask (dt));
			     cur_unit -> flow_unit.set -> bits =
				cur_unit -> flow_unit.set -> bits | aliasable_mask (dt);
			     always_completely_sets = "0"b;
						/* several variables share this coordinate */
			     end;

			else if i > length (alias_mask)
			then if substr (cur_unit -> flow_unit.set -> bits, dt, 1)
			     then substr (cur_unit -> flow_unit.set_multiple -> bits, dt, 1) = "1"b;
			     else substr (cur_unit -> flow_unit.set -> bits, dt, 1) = "1"b;

			else do;

			     /* equivalenced variables */

			     always_completely_sets = "0"b;
						/* several variables share this coordinate */

			     /* real and complex vars may be equivalenced
			        and simultaneously defined */

			     if dt = real_mode
			     then other_dt = cmpx_mode;

			     else if dt = cmpx_mode
			     then other_dt = real_mode;

			     else other_dt = 0;

			     if other_dt > 0
			     then if substr (cur_unit -> flow_unit.set -> bits, other_dt, 1)
				then substr (cur_unit -> flow_unit.set_multiple -> bits, other_dt, 1) = "1"b;
				else substr (cur_unit -> flow_unit.set -> bits, other_dt, 1) = "1"b;
			     end;
			end;

		     if always_completely_sets
		     then substr (cur_unit -> flow_unit.always_completely_set -> bits, i, 1) = "1"b;
		     end;
		end;
	     end;

     end set;

process_call:
     procedure ();

dcl  i fixed binary (18);

	call use_inputs;

	/* set the arguments */

	do i = 3 to o -> operator.number;
	     call set ((o -> operator.operand (i)), i, "0"b);
	     end;

	/* use & set all aliasables */

	cur_unit -> flow_unit.used -> bits = cur_unit -> flow_unit.used -> bits | aliasable_mask (0);
	cur_unit -> flow_unit.busy_on_entry -> bits =
	     cur_unit -> flow_unit.busy_on_entry -> bits
	     | (aliasable_mask (0) & ^cur_unit -> flow_unit.always_completely_set -> bits);
	cur_unit -> flow_unit.set_multiple -> bits =
	     cur_unit -> flow_unit.set_multiple -> bits | (cur_unit -> flow_unit.set -> bits & aliasable_mask (0));
	cur_unit -> flow_unit.set -> bits = cur_unit -> flow_unit.set -> bits | aliasable_mask (0);

	/* set the output */

	call set ((o -> operator.output), 0, "1"b);

	cur_unit -> flow_unit.has_side_effects = "1"b;

     end process_call;

change_cur_unit:
     procedure ();

	/* makes a new flow_unit the current unit and chains it in */

dcl  next_unit pointer;

	need_new_unit = "0"b;

	if st -> opt_statement.flow_unit ^= null
	then next_unit = st -> opt_statement.flow_unit;
	else next_unit = create_flow_unit ();

	next_unit -> flow_unit.position, next_unit -> flow_unit.number = cur_unit -> flow_unit.number + 1;
	next_unit -> flow_unit.first_statement = cur_statement;

	cur_unit -> flow_unit.next = next_unit;
	next_unit -> flow_unit.back = cur_unit;

	if ^state_discarded
	then do;
	     cur_unit -> flow_unit.falls_through = "1"b;
	     call link (cur_unit, next_unit);
	     end;
	else state_discarded = "0"b;

	cur_unit = next_unit;
	st -> opt_statement.flow_unit = cur_unit;

     end change_cur_unit;

link_to_target:
     procedure (lab);

	/* links cur_unit to the flow_unit designated by the label lab */

dcl  lab fixed binary (18);				/* label of target (input/output) */

dcl  target_statement fixed binary (18);
dcl  (target, target_unit) pointer;

	call get_final_target (lab, target_statement, target);

	if target -> opt_statement.flow_unit = null
	then do;
	     target_unit = create_flow_unit ();
	     target -> opt_statement.flow_unit = target_unit;
	     end;
	else target_unit = target -> opt_statement.flow_unit;

	target_unit -> flow_unit.has_label = "1"b;

	call link (cur_unit, target_unit);

	if next_statement = target_statement
	then cur_unit -> flow_unit.falls_through = "1"b;

     end link_to_target;

get_final_target:
     procedure (lab, target_statement, target);

	/* gets final target of jump.  This optimizes a goto a goto statement */

dcl  lab fixed binary (18),				/* label referenced in the jump (input/output) */
     target_statement fixed binary (18),		/* statement labelled by lab(output) */
     target pointer;				/* .. (output) */

dcl  try_to_optimize bit (1) aligned;
dcl  i fixed binary;
dcl  o pointer;

	i = 1;
	try_to_optimize = "1"b;

	do while (try_to_optimize);
	     target_statement = addr (rands (lab)) -> label.statement;
	     target = addr (quad (target_statement));

	     do o = addr (quad (target -> opt_statement.first_operator)) repeat addr (quad (o -> operator.next))
		while (o -> operator.op_code = no_op | o -> operator.op_code = non_executable);
		end;

	     if o -> operator.op_code = jump_op & i < 10
	     then do;
		lab = o -> operand (1);

		/* Set removable to prevent warning 384 */

		target -> opt_statement.removable = "1"b;
		end;
	     else try_to_optimize = "0"b;

	     i = i + 1;
	     end;

     end get_final_target;

link_entry_to_target:
     procedure ();

	/* links entry unit to target unit which is operator.operand(1) */

dcl  (target, target_st) pointer;

	target_st = addr (quad (addr (rands (o -> operand (1))) -> label.statement));

	if target_st -> opt_statement.flow_unit ^= null
	then target = target_st -> opt_statement.flow_unit;
	else do;
	     target = create_flow_unit ();
	     target_st -> opt_statement.flow_unit = target;
	     end;

	target -> flow_unit.has_label = "1"b;
	target_st -> opt_statement.referenced_by_assign = "1"b;

	call link (entry_unit, target);

     end link_entry_to_target;

add_to_jump_assigned_list:
     procedure ();

dcl  c pointer;

	c = create_chain ();

	c -> chain.value = cur_unit;
	c -> chain.next = jump_assigned_list;
	jump_assigned_list = c;

     end add_to_jump_assigned_list;

add_to_jump_assigned_target_list:
     procedure ();

dcl  (target, target_st, c, sym) pointer;

	target_st = addr (quad (addr (rands (o -> operand (1))) -> label.statement));
	target = target_st -> opt_statement.flow_unit;

	sym = addr (rands (o -> operator.output));

	if sym -> symbol.secondary = null
	then do;
	     c = create_chain ();

	     c -> chain.value = sym;
	     c -> chain.next = jump_assigned_target_list;
	     jump_assigned_target_list = c;
	     end;

	c = create_chain ();

	c -> chain.value = target;
	c -> chain.next = sym -> symbol.secondary;
	sym -> symbol.secondary = c;

     end add_to_jump_assigned_target_list;

connect_jump_assigneds:
     procedure ();

dcl  (c_source, c_target, source, st, o, sym, last, last_c) pointer;

	last = null;

	do c_source = jump_assigned_list repeat c_source -> chain.next while (c_source ^= null);

	     source = c_source -> chain.value;

	     st = addr (quad (source -> flow_unit.last_statement));
	     st = addr (quad (fixed (st -> opt_statement.next, 18)));
	     o = addr (quad (st -> opt_statement.prev_operator));
	     sym = addr (rands (o -> operand (1)));

	     do c_target = sym -> symbol.secondary repeat c_target -> chain.next while (c_target ^= null);
		call link (source, (c_target -> chain.value));
		end;

	     last = c_source;
	     end;

	if last ^= null
	then do;
	     last -> chain.next = free (size (chain));
	     free (size (chain)) = jump_assigned_list;
	     jump_assigned_list = null;
	     end;

	last_c = null;

	do c_target = jump_assigned_target_list repeat c_target -> chain.next while (c_target ^= null);

	     last_c = c_target;
	     sym = c_target -> chain.value;

	     do last = sym -> symbol.secondary repeat last -> chain.next while (last -> chain.next ^= null);
		end;

	     last -> chain.next = free (size (chain));
	     free (size (chain)) = sym -> symbol.secondary;
	     sym -> symbol.secondary = null;
	     end;

	if last_c ^= null
	then do;
	     last_c -> chain.next = free (size (chain));
	     free (size (chain)) = jump_assigned_target_list;
	     jump_assigned_target_list = null;
	     end;

     end connect_jump_assigneds;

     end build_flow_units;

link:
     procedure (from_unit, to_unit);

	/* builds an edge between from_unit and to_unit */

dcl  (from_unit, to_unit) pointer;

dcl  (e, q) pointer;

	e = get_opt_space (size (edge));

	e -> edge.from.back = null;
	e -> edge.to.back = null;

	e -> edge.from.value = from_unit;
	e -> edge.to.value = to_unit;

	e -> edge.from.next, q = to_unit -> flow_unit.predecessors;
	to_unit -> flow_unit.predecessors = e;
	if q ^= null
	then q -> edge.from.back = e;

	e -> edge.to.next, q = from_unit -> flow_unit.successors;
	from_unit -> flow_unit.successors = e;
	if q ^= null
	then q -> edge.to.back = e;

     end link;

make_constant_opt_subscript:
     procedure (p_o);

dcl  (o, p_o) pointer;				/* points at operator */
dcl  (c2, c3) fixed binary (18);

	o = p_o;
	unspec (c2) = addr (rands (o -> operator.operand (2))) -> constant.value;
	unspec (c3) = addr (rands (o -> operator.operand (3))) -> constant.value;
	o -> operator.operand (2) = create_integer_constant (c2 + c3);
	o -> operator.operand (3) = 0;

     end make_constant_opt_subscript;

flow_analysis:
     procedure ();

dcl  (c, e, exit, lastc, lp, p, q) pointer;
dcl  (i, lvec, pnum, qnum) fixed binary (18);
dcl  found bit (1) aligned;

	/* BACK DOMINATOR ALGORITHM */

	/* Assign level numbers.  The level number represents the minimum
	   distance from the entry_unit.  */

	flow_unit_vector_p = get_opt_space (size (flow_unit_vector_st));
	flow_unit_vector (1) = entry_unit;
	entry_unit -> flow_unit.level_number = 0;
	lvec = 1;

	do i = 1 by 1 while (i <= lvec);
	     p = flow_unit_vector (i);
	     qnum = p -> flow_unit.level_number + 1;

	     do e = p -> flow_unit.successors repeat e -> edge.to.next while (e ^= null);
		q = e -> edge.to.value;
		if q -> flow_unit.level_number = 0
		then do;
		     q -> flow_unit.level_number = qnum;
		     lvec = lvec + 1;
		     flow_unit_vector (lvec) = q;
		     if q -> flow_unit.predecessors -> edge.from.next = null
						/* check for only one predecessor */
		     then q -> flow_unit.dominator = p;
		     end;
		end;
	     end;

	if lvec ^= n_flow_units
	then do;
	     call detach_flow_units;
	     n_flow_units = lvec;
	     end;

	/* Determine back dominators.  a is the back dominator of b if a is the closest unit to
	   b that must be executed before b is executed.	*/

	begin;

dcl  scan_vector (n_flow_units) pointer unaligned;
dcl  scan_bits bit (n_flow_units) aligned;

dcl  (i, j, lvec, lowest_level, our_level) fixed binary (18);
dcl  (e, p, q, bd, lowest_fu) pointer;

	     do i = 2 to n_flow_units;
		p = flow_unit_vector (i);

		if p -> flow_unit.dominator ^= null
		then bd = p -> flow_unit.dominator;

		else do;

		     /* we want to initialize scan_bits with dominated_by bits from and the bit for
		        the predecessor with lowest level number */

		     our_level = p -> flow_unit.level_number;
		     lowest_level = n_flow_units;
		     lowest_fu = null;

		     do e = p -> flow_unit.predecessors repeat e -> edge.from.next while (e ^= null);
			q = e -> edge.from.value;
			if q -> flow_unit.level_number < lowest_level
			then do;
			     lowest_level = q -> flow_unit.level_number;
			     lowest_fu = q;
			     end;
			end;

		     scan_bits = lowest_fu -> flow_unit.dominated_by -> dbits;
		     substr (scan_bits, lowest_fu -> flow_unit.number, 1) = "1"b;

		     /* scan all backward paths to find intersection furthest back from p,
		        that is, with the lowest level number */

		     lowest_level = n_flow_units;
		     lowest_fu = null;
		     scan_vector (1) = p;
		     lvec = 1;

		     do j = 1 by 1 while (j <= lvec);
			q = scan_vector (j);

			if q -> flow_unit.level_number < our_level
			then call process ((q -> flow_unit.dominator));

			else do e = q -> flow_unit.predecessors repeat e -> edge.from.next while (e ^= null);
				call process ((e -> edge.from.value));
				end;
			end;

		     p -> flow_unit.dominator, bd = lowest_fu;
		     end;

		p -> flow_unit.dominated_by -> dbits = bd -> flow_unit.dominated_by -> dbits;
		substr (p -> flow_unit.dominated_by -> dbits, bd -> flow_unit.number, 1) = "1"b;
		end;

process:
     procedure (fu);

dcl  fu pointer;					/* flow_unit being scanned */

	if substr (scan_bits, fu -> flow_unit.number, 1)
	then do;
	     if fu -> flow_unit.level_number < lowest_level
	     then do;
		lowest_level = fu -> flow_unit.level_number;
		lowest_fu = fu;
		end;
	     end;
	else do;
	     substr (scan_bits, fu -> flow_unit.number, 1) = "1"b;
	     lvec = lvec + 1;
	     scan_vector (lvec) = fu;
	     end;

     end process;

	end /* back dominator begin block */;

	/* FIND LOOP ENTRY UNITS */

	loop_entry_list = null;

	/* order of processing of flow_units is important */

	do i = n_flow_units by -1 to 3;
	     p = flow_unit_vector (i);
	     pnum = p -> flow_unit.number;
	     found = "0"b;

	     /* a loop entry unit either dominates one of its predecessors or is its own predecessor */

	     do e = p -> flow_unit.predecessors repeat e -> edge.from.next while (^found & e ^= null);
		q = e -> edge.from.value;
		if p = q | substr (q -> flow_unit.dominated_by -> dbits, pnum, 1)
		then found = "1"b;
		end;

	     if found
	     then do;

		if ^addr (quad (p -> flow_unit.first_statement)) -> opt_statement.referenced_by_assign
		then do;

		     /* we have a legitimate loop entry unit */

		     c = create_chain ();
		     c -> chain.next = loop_entry_list;
		     loop_entry_list = c;
		     c -> chain.value = p;
		     p -> flow_unit.loop_entry = "1"b;
		     end;
		end;
	     end;

	/* ASSIGN ALL FLOW UNITS TO LOOPS */

	scan_vector_p = get_opt_space (size (scan_vector_st));
	scan_bits_p = get_opt_space (size (scan_bits));
	lastc = null;

	do c = loop_entry_list repeat c -> chain.next while (c ^= null);
	     p = c -> chain.value;
	     pnum = p -> flow_unit.number;

	     /* Create a loop node.  Assign a provisional back_target. */

	     lp = create_loop ((p -> flow_unit.loop));
	     p -> flow_unit.loop = lp;
	     lp -> loop.entry_unit = p;
	     lp -> loop.back_target = p -> flow_unit.dominator;

	     /* Scan back from the loop entry unit on all paths that don't reach the back target
	        (without retouching the entry unit) and contain flow_units dominated by the loop
	        entry unit to get loop members.  */

	     scan_bits = "0"b;
	     lvec = 1;
	     substr (scan_bits, pnum, 1) = "1"b;
	     scan_vector (1) = p;

	     do i = 1 by 1 while (i <= lvec);
		do e = scan_vector (i) -> flow_unit.predecessors repeat e -> edge.from.next while (e ^= null);
		     q = e -> edge.from.value;

		     if (i ^= 1
			| q ^= lp -> loop.back_target & substr (q -> flow_unit.dominated_by -> dbits, pnum, 1))
			& ^substr (scan_bits, q -> flow_unit.number, 1)
		     then do;
			lvec = lvec + 1;
			scan_vector (lvec) = q;
			substr (scan_bits, q -> flow_unit.number, 1) = "1"b;
			q -> flow_unit.loop = lp;
			end;
		     end;
		end;

	     lastc = c;
	     end;

	if loop_entry_list ^= null
	then do;

	     /* free loop_entry_list */

	     lastc -> chain.next = free (size (chain));
	     free (size (chain)) = loop_entry_list;
	     loop_entry_list = null;
	     end;

	/* MAKE A VECTOR OF LOOPS IN DESCENDING ORDER OF NESTING DEPTH AND FROM FRONT TO BACK */

	cs -> subprogram.n_loops = n_loops;
	cs -> subprogram.loop_vector_p, loop_vector_p = get_opt_space (size (loop_vector_st));
	lvec = n_loops;

	loop_vector (lvec) = adam_loop;

	adam_loop -> loop.number = lvec;
	adam_loop -> loop.ancestors_and_me = get_opt_space (size (lbits));
	substr (adam_loop -> loop.ancestors_and_me -> lbits, lvec, 1) = "1"b;

	do i = n_loops to 1 by -1;
	     lp = loop_vector (i);

	     do p = lp -> loop.last_son repeat p -> loop.prev_brother while (p ^= null);
		lvec = lvec - 1;

		loop_vector (lvec) = p;

		p -> loop.number = lvec;
		p -> loop.ancestors_and_me = get_opt_space (size (lbits));
		p -> loop.ancestors_and_me -> lbits = lp -> loop.ancestors_and_me -> lbits;
		substr (p -> loop.ancestors_and_me -> lbits, lvec, 1) = "1"b;
		end;

	     end;

	/* ASSIGN REAL BACK TARGETS (fixes bug 187) */

	/* find earliest flow_unit for each loop */

	do p = exit_unit -> flow_unit.back repeat p -> flow_unit.back while (p ^= null);
	     p -> flow_unit.loop -> loop.first_unit = p;
	     end;

	/* find last flow_unit for each loop */

	do p = entry_unit -> flow_unit.next repeat p -> flow_unit.next while (p ^= null);
	     p -> flow_unit.loop -> loop.last_unit = p;
	     end;

	/* refine first_unit and last_unit to account for contained loops */

	do i = 1 to n_loops - 1;
	     lp = loop_vector (i);

	     do p = lp -> loop.son repeat p -> loop.brother while (p ^= null);
		if lp -> loop.first_unit -> flow_unit.position > p -> loop.first_unit -> flow_unit.position
		then lp -> loop.first_unit = p -> loop.first_unit;

		if lp -> loop.last_unit -> flow_unit.position < p -> loop.last_unit -> flow_unit.position
		then lp -> loop.last_unit = p -> loop.last_unit;
		end;

	     end;

	/* Now make sure each loop has a suitable back_target.
	   A suitable back_target has one successor and
	   physically appears before any flow_unit in the loop.
	   The latter is necessary because the code generator
	   makes one linear pass over the program.  We scan from
	   outside-in so that inner back targets are closest to
	   their loops */

	do i = n_loops - 1 to 1 by -1;
	     lp = loop_vector (i);
	     p = lp -> loop.entry_unit;
	     q = p -> flow_unit.dominator;

	     if q -> flow_unit.successors -> edge.to.next ^= null
		| q -> flow_unit.position > lp -> loop.first_unit -> flow_unit.position
	     then q = create_new_back_target (p, (lp -> loop.first_unit));

	     lp -> loop.back_target = q;
	     q -> flow_unit.is_back_target = "1"b;
	     end;

	/* CHAIN FLOW_UNITS BELONGING TO EACH LOOP.
	   Note that all flow_units must now have been created so that we can properly determine the exit paths. */

	do p = exit_unit repeat p -> flow_unit.back while (p ^= null);
	     pnum = p -> flow_unit.number;
	     lp = p -> flow_unit.loop;
	     substr (lp -> loop.is_member -> dbits, p -> flow_unit.number, 1) = "1"b;
	     p -> flow_unit.next_in_loop = lp -> loop.members;
	     lp -> loop.members = p;

	     /* check if this is an exit unit (used to determine articulation blocks) */

	     if lp -> loop.depth > 0
	     then do e = p -> flow_unit.successors repeat e -> edge.to.next while (e ^= null);
		     q = e -> edge.to.value -> flow_unit.loop;

		     /* if we have an exit unit, mark it in this loop and in intervening loops */

		     if lp -> loop.depth > q -> loop.depth
		     then do exit = lp repeat exit -> loop.father while (exit ^= q);
			     c = create_chain ();
			     c -> chain.value = e;
			     c -> chain.next = exit -> loop.exits;
			     exit -> loop.exits = c;
			     substr (exit -> loop.is_exit -> dbits, pnum, 1) = "1"b;
			     end;
		     end;
	     end;

	/* DETERMINE ARTICULATION BLOCKS */

	do i = 1 to n_loops - 1;
	     lp = loop_vector (i);
	     lp -> loop.articulation_blocks -> dbits = lp -> loop.is_member -> dbits;

	     do c = lp -> loop.exits repeat c -> chain.next while (c ^= null);
		p = c -> chain.value -> edge.from.value;
		scan_bits = p -> flow_unit.dominated_by -> dbits;
		substr (scan_bits, p -> flow_unit.number, 1) = "1"b;
		lp -> loop.articulation_blocks -> dbits = lp -> loop.articulation_blocks -> dbits & scan_bits;
		end;
	     end;

	/* allocate temp_bits */

	temp_bits_p = get_opt_space (size (temp_bits));

	/* COMPLETE DATA_FLOW ANALYSIS */

	call analyze_data_flow;

	return;

create_new_back_target:
     procedure (pt, p_ins) returns (pointer);

dcl  (p, pt) pointer;				/* ptr to loop entry unit */
dcl  (ins, p_ins) pointer;				/* ptr to earliest flow_unit in loop */

dcl  (e, q, fu, next_edge, pr, qst, o) pointer;
dcl  (j, qlabel, pnum, old_label, qpos) fixed binary (18);


	/* this routine creates a new flow_unit (with statement & label) to be a
	   back target for the loop entry unit p and splices it in */

	p = pt;
	ins = p_ins;
	pnum = p -> flow_unit.number;

	q = insert_flow_unit_before (ins, qlabel, qst);

	q -> flow_unit.level_number = p -> flow_unit.level_number;
	q -> flow_unit.dominator = p -> flow_unit.dominator;
	q -> flow_unit.dominated_by -> dbits = p -> flow_unit.dominated_by -> dbits;
	p -> flow_unit.dominator = q;
	q -> flow_unit.loop = p -> flow_unit.loop -> loop.father;

	do j = n_flow_units by -1 to 1 while (flow_unit_vector (j) ^= p);
	     flow_unit_vector (j), fu = flow_unit_vector (j - 1);
	     if substr (fu -> flow_unit.dominated_by -> dbits, pnum, 1)
	     then substr (fu -> flow_unit.dominated_by -> dbits, n_flow_units, 1) = "1"b;
	     end;

	flow_unit_vector (j) = q;

	qpos = q -> flow_unit.position;

	old_label = addr (quad (p -> flow_unit.first_statement)) -> opt_statement.label;

	q -> flow_unit.falls_through = p = ins;

	if ^q -> flow_unit.falls_through
	then call make_jump_to (old_label, q);

	/* redirect edges from outside the loop to the new back target */

	do e = p -> flow_unit.predecessors repeat next_edge while (e ^= null);
	     next_edge = e -> edge.from.next;
	     pr = e -> edge.from.value;

	     if pr ^= p & ^substr (pr -> flow_unit.dominated_by -> dbits, pnum, 1)
	     then do;

		/* pr is a flow_unit outside of the loop headed by p */

		/* set the reference_backwards bit , if necessary */

		if pr -> flow_unit.position > qpos
		then qst -> opt_statement.referenced_backwards = "1"b;

		/* change this edge to point to the new flow unit */

		call redirect_edge (e, q);

		/* now change the jump_x operator, if any, to jump to the right place */

		if old_label > 0
		then do;
		     o = addr (quad (pr -> flow_unit.last_statement));
		     o = addr (quad (fixed (o -> opt_statement.next, 18)));
		     o = addr (quad (o -> opt_statement.prev_operator));

		     if o -> operator.op_code = jump_op
		     then o -> operand (1) = qlabel;

		     else if o -> operator.op_code = jump_true_op | o -> operator.op_code = jump_false_op
		     then do;
			if o -> operand (2) = old_label
			then o -> operand (2) = qlabel;

			if pr -> flow_unit.next = p
			then call splice_in_another_fu (pr, q, qlabel);
			end;

		     else if o -> operator.op_code = jump_arithmetic_op
		     then do j = 2 to 4;
			     if o -> operand (j) = old_label
			     then o -> operand (j) = qlabel;
			     end;

		     else if o -> operator.op_code = jump_computed_op
		     then do;
			do j = 1 to o -> operand (1) + bias;
			     if o -> operand (j + 1) = old_label
			     then o -> operand (j + 1) = qlabel;
			     end;

			if pr -> flow_unit.next = p
			then call splice_in_another_fu (pr, q, qlabel);
			end;

		     else				/* it was a fall through */
			if pr -> flow_unit.next ^= q
		     then do;
			pr -> flow_unit.falls_through = "0"b;
			pr -> flow_unit.last_statement = insert_statement_after ((pr -> flow_unit.last_statement));
			call make_jump_to (qlabel, pr);
			end;
		     end;
		end;
	     end;

	/* link the new back target to the loop entry unit */

	call link (q, p);

	return (q);

insert_flow_unit_before:
     procedure (p_ins, new_label, new_stm) returns (pointer);

dcl  (p_ins, ins) pointer;				/* -> flow_unit before which we insert the new flow_unit */
dcl  new_label fixed binary (18);			/* label for new flow_unit (output) */
dcl  new_stm pointer;				/* -> stm for new flow_unit (output) */

dcl  (fu, q, qst) pointer;
dcl  (q_statement, qlabel) fixed binary (18);

	ins = p_ins;

	q = create_flow_unit ();

	if n_flow_units >= max_flow_units
	then do;
	     cur_statement = ins -> flow_unit.back -> flow_unit.last_statement;
	     call print_message (388);
	     stop;
	     end;

	n_flow_units = n_flow_units + 1;
	q -> flow_unit.number = n_flow_units;
	q -> flow_unit.position = ins -> flow_unit.position;
	q -> flow_unit.back = ins -> flow_unit.back;
	q -> flow_unit.next = ins;
	ins -> flow_unit.back = q;
	q -> flow_unit.back -> flow_unit.next = q;

	do fu = ins repeat fu -> flow_unit.next while (fu ^= null);
	     fu -> flow_unit.position = fu -> flow_unit.position + 1;
	     end;

	q_statement = insert_statement_after ((q -> flow_unit.back -> flow_unit.last_statement));
	q -> flow_unit.first_statement = q_statement;
	q -> flow_unit.last_statement = q_statement;

	qst = addr (quad (q_statement));
	qst -> opt_statement.flow_unit = q;

	qlabel = create_label (q_statement);
	q -> flow_unit.has_label = "1"b;

	new_label = qlabel;
	new_stm = qst;
	return (q);

     end insert_flow_unit_before;

redirect_edge:
     procedure (e, new_target);

dcl  e pointer,					/* -> edge whose target is changed */
     new_target pointer;				/* -> new target unit */

dcl  (e1, next_edge, old_target) pointer;

	next_edge = e -> edge.from.next;
	old_target = e -> edge.to.value;

	if e -> edge.from.back = null
	then old_target -> flow_unit.predecessors = next_edge;
	else e -> edge.from.back -> edge.from.next = next_edge;
	if next_edge ^= null
	then next_edge -> edge.from.back = e -> edge.from.back;

	e -> edge.to.value = new_target;
	e -> edge.from.next, e1 = new_target -> flow_unit.predecessors;
	e -> edge.from.back = null;
	new_target -> flow_unit.predecessors = e;
	if e1 ^= null
	then e1 -> edge.from.back = e;

     end redirect_edge;

make_jump_to:
     procedure (tlabel, fu);

dcl  tlabel fixed binary (18),			/* target label of jump */
     fu pointer;					/* -> flow_unit in which jump is inserted */

dcl  (j_operator, j_statement) fixed binary (18);

	j_statement, fu -> flow_unit.last_statement = insert_statement_after ((fu -> flow_unit.last_statement));
	j_operator = insert_operator_after (jump_op, 1, j_statement);
	addr (quad (j_operator)) -> operand (1) = tlabel;

     end make_jump_to;

splice_in_another_fu:
     procedure (pr, bt, btlabel);

dcl  pr pointer,					/* -> flow_unit that falls thru */
     bt pointer,					/* -> flow_unit we will build jump to (new back target) */
     btlabel fixed binary (18);			/* label on bt */

dcl  q pointer;
dcl  (j, useless) fixed binary (18);
dcl  useless_ptr pointer;

	q = insert_flow_unit_before ((pr -> flow_unit.next), useless, useless_ptr);

	q -> flow_unit.level_number = bt -> flow_unit.level_number;
	q -> flow_unit.dominator = pr;
	q -> flow_unit.dominated_by -> dbits = pr -> flow_unit.dominated_by -> dbits;
	substr (q -> flow_unit.dominated_by -> dbits, pr -> flow_unit.number, 1) = "1"b;
	q -> flow_unit.loop = bt -> flow_unit.loop;

	do j = n_flow_units by -1 to 1 while (flow_unit_vector (j) ^= bt);
	     flow_unit_vector (j) = flow_unit_vector (j - 1);
	     end;

	flow_unit_vector (j) = q;

	call make_jump_to ((btlabel), q);

	/* redirect edges */

	call redirect_edge (e, q);

	call link (q, bt);

     end splice_in_another_fu;

     end create_new_back_target;

detach_flow_units:
     procedure ();

	/* detaches unreachable flow_units */

dcl  (lst, nst, p, qst, st, last_o, next_fu) pointer;
dcl  (q_statement, last_statement, next_statement, last_operator) fixed binary (18);

	do p = entry_unit -> flow_unit.next repeat next_fu while (p ^= exit_unit);
	     next_fu = p -> flow_unit.next;

	     if p -> flow_unit.level_number = 0
	     then do;
		cur_statement = p -> flow_unit.first_statement;
		st = addr (quad (cur_statement));

		/* unthread the statement/operator chain */

		q_statement = p -> flow_unit.last_statement;
		qst = addr (quad (q_statement));
		next_statement = fixed (qst -> opt_statement.next, 18);
		nst = addr (quad (next_statement));
		last_statement = fixed (st -> opt_statement.back, 18);
		lst = addr (quad (last_statement));
		last_operator = st -> opt_statement.prev_operator;
		last_o = addr (quad (last_operator));

		/* Print warning if this is a real statement */

		if ^st -> opt_statement.removable
		then call print_message (384, fixed (st -> opt_statement.source_id.line, 14, 0) - bias,
			fixed (qst -> opt_statement.source_id.line, 14, 0) - bias);

		lst -> opt_statement.next = qst -> opt_statement.next;
		last_o -> operator.next = next_statement;
		nst -> opt_statement.back = st -> opt_statement.back;
		nst -> opt_statement.prev_operator = last_operator;

		/* detach and unthread the flow_unit */

		call detach_flow_unit (p);
		end;
	     end;

     end detach_flow_units;

     end flow_analysis;

detach_flow_unit:
     procedure (pt);

	/* detaches a flow_unit from its edges and unthreads a flow_unit from the
	   flow_unit chain */

dcl  (p, pt) pointer;

	p = pt;

	/* detach all edges connected to this flow_unit */

	do while (p -> flow_unit.predecessors ^= null);
	     call unlink ((p -> flow_unit.predecessors));
	     end;

	do while (p -> flow_unit.successors ^= null);
	     call unlink ((p -> flow_unit.successors));
	     end;

	/* unthread the flow_unit */

	call unthread_flow_unit (p);

     end detach_flow_unit;

unlink:
     procedure (e);

	/* unlinks an edge between 2 flow_units */

dcl  e pointer;					/* -> edge to be unlinked */

dcl  (from_unit, to_unit) pointer;

	from_unit = e -> edge.from.value;
	to_unit = e -> edge.to.value;

	if e -> edge.from.back ^= null
	then e -> edge.from.back -> edge.from.next = e -> edge.from.next;
	else to_unit -> flow_unit.predecessors = e -> edge.from.next;
	if e -> edge.from.next ^= null
	then e -> edge.from.next -> edge.from.back = e -> edge.from.back;

	if e -> edge.to.back ^= null
	then e -> edge.to.back -> edge.to.next = e -> edge.to.next;
	else from_unit -> flow_unit.successors = e -> edge.to.next;
	if e -> edge.to.next ^= null
	then e -> edge.to.next -> edge.to.back = e -> edge.to.back;

     end unlink;

analyze_data_flow:
     procedure ();

	/* Calls subroutines to do data flow analysis . */

	call summarize_loop_usage;

	call compute_busy_on_exit;

	call summarize_loop_busy_on_exit;

     end analyze_data_flow;

compute_busy_on_exit:
     procedure ();

	/* computes busy_on_exit information */

dcl  (i, j, lvec) fixed binary;
dcl  (bd, e, fu, p, q) pointer;

	/* initialize exit_unit to show that all aliasable vars are busy_on_entry */

	exit_unit -> flow_unit.busy_on_entry -> bits = aliasable_mask (0);

	/* process each flow_unit in descending order by level number,
	   propagating information backwards to its dominator */

retry:
	do i = n_flow_units to 2 by -1;
	     p = flow_unit_vector (i);
	     bd = p -> flow_unit.dominator;

	     scan_vector (1) = p;
	     j = 0;
	     lvec = 1;

	     do while (j ^= lvec);
		j = j + 1;
		if j > n_flow_units
		then j = 1;

		fu = scan_vector (j);
		fu -> flow_unit.in_queue = "0"b;

		do e = fu -> flow_unit.predecessors repeat e -> edge.from.next while (e ^= null);
		     q = e -> edge.from.value;
		     q -> flow_unit.busy_on_exit -> bits =
			q -> flow_unit.busy_on_exit -> bits | fu -> flow_unit.busy_on_entry -> bits;

		     temp_bits =
			q -> flow_unit.busy_on_entry -> bits
			| (q -> flow_unit.busy_on_exit -> bits & ^q -> flow_unit.always_completely_set -> bits);

		     if temp_bits ^= q -> flow_unit.busy_on_entry -> bits
		     then do;
			q -> flow_unit.busy_on_entry -> bits = temp_bits;
			if q ^= bd & ^q -> flow_unit.in_queue
			then do;
			     lvec = lvec + 1;
			     if lvec > n_flow_units
			     then lvec = 1;
			     scan_vector (lvec) = q;
			     q -> flow_unit.in_queue = "1"b;
			     end;
			end;
		     end;
		end;
	     end;


	/* decide whether we have to make another pass because some static
	   variables are busy on entry to the program but were not considered
	   busy_on_exit from the program */

	temp_bits =
	     exit_unit -> flow_unit.busy_on_entry -> bits
	     | (entry_unit -> flow_unit.busy_on_entry -> bits & non_auto_mask);

	if temp_bits ^= exit_unit -> flow_unit.busy_on_entry -> bits
	then do;
	     exit_unit -> flow_unit.busy_on_entry -> bits = temp_bits;
	     go to retry;
	     end;


     end compute_busy_on_exit;

summarize_loop_usage:
     procedure ();

	/* build up loop usage information by collecting from member flow_units and
	   propagating upwards to containing loops */

dcl  i fixed binary;
dcl  (lp, p) pointer;

	do i = 1 to n_loops;
	     lp = loop_vector (i);

	     do p = lp -> loop.members repeat p -> flow_unit.next_in_loop while (p ^= null);
		lp -> loop.set_multiple -> bits =
		     lp -> loop.set_multiple -> bits
		     | ((lp -> loop.set -> bits & p -> flow_unit.set -> bits) | p -> flow_unit.set_multiple -> bits);
		lp -> loop.set -> bits = lp -> loop.set -> bits | p -> flow_unit.set -> bits;
		lp -> loop.used -> bits = lp -> loop.used -> bits | p -> flow_unit.used -> bits;
		lp -> loop.has_side_effects = lp -> loop.has_side_effects | p -> flow_unit.has_side_effects;
		end;

	     do p = lp -> loop.son repeat p -> loop.brother while (p ^= null);
		lp -> loop.set_multiple -> bits =
		     lp -> loop.set_multiple -> bits
		     | ((lp -> loop.set -> bits & p -> loop.set -> bits) | p -> loop.set_multiple -> bits);
		lp -> loop.set -> bits = lp -> loop.set -> bits | p -> loop.set -> bits;
		lp -> loop.used -> bits = lp -> loop.used -> bits | p -> loop.used -> bits;
		lp -> loop.has_side_effects = lp -> loop.has_side_effects | p -> loop.has_side_effects;
		end;
	     end;

     end summarize_loop_usage;

summarize_loop_busy_on_exit:
     procedure ();

	/* summarize busy_on_exit info by using busy_on_entry of loop exit targets */

dcl  i fixed binary;
dcl  (c, lp) pointer;

	do i = 1 to n_loops;
	     lp = loop_vector (i);

	     do c = lp -> loop.exits repeat c -> chain.next while (c ^= null);
		lp -> loop.busy_on_exit -> bits =
		     lp -> loop.busy_on_exit -> bits
		     | c -> chain.value -> edge.to.value -> flow_unit.busy_on_entry -> bits;
		end;
	     end;

     end summarize_loop_busy_on_exit;

create_label:
     procedure (q_statement) returns (fixed binary (18));

	/* creates a label for a statement */

dcl  q_statement fixed binary (18);			/* stmt to which label is to be attached */

dcl  qlabel fixed binary (18);
dcl  qlab pointer;

	qlabel = create_node (label_node, size (label));
	qlab = addr (rands (qlabel));

	addr (quad (q_statement)) -> opt_statement.label = qlabel;
	qlab -> label.statement = q_statement;
	qlab -> label.operand_type = rel_constant;
	qlab -> label.referenced, qlab -> label.referenced_executable = "1"b;
	addr (rands (cs -> subprogram.last_label)) -> label.next_label = qlabel;
	cs -> subprogram.last_label = qlabel;

	return (qlabel);

     end create_label;

unthread_flow_unit:
     procedure (fu);

dcl  fu pointer;					/* -> flow_unit to be unthreaded */

	fu -> flow_unit.back -> flow_unit.next = fu -> flow_unit.next;
	fu -> flow_unit.next -> flow_unit.back = fu -> flow_unit.back;

	fu -> flow_unit.next = freefu;
	freefu = fu;

	fu -> flow_unit.removed = "1"b;

     end unthread_flow_unit;

insert_statement_after:
     procedure (last_statement) returns (fixed binary (18));

	/* used by create_new_back_target and move to insert a new opt_statement node after an existing one.
	   There must be a statement already after the existing one for this to work */

dcl  last_statement fixed binary (18);

dcl  (our_statement, next_statement) fixed binary (18);
dcl  (next_operator, last_operator) fixed binary (18);
dcl  (lastp, ourp, nextp, nextop, lastop) pointer;

	/* get an opt_statement node */

	our_statement = get_quad_space (size (opt_statement));
	ourp = addr (quad (our_statement));

	/* initialize the node */

	unspec (ourp -> opt_statement) = "0"b;
	ourp -> opt_statement.op_code = stat_op;
	ourp -> opt_statement.location = (18)"1"b;
	ourp -> opt_statement.put_in_map = "1"b;
	ourp -> opt_statement.operator_list = null;

	/* get last and next statement pointers */

	lastp = addr (quad (last_statement));
	next_statement = fixed (lastp -> opt_statement.next, 18);
	nextp = addr (quad (next_statement));

	/* get next and last operator pointers */

	next_operator = next_statement;
	nextop = nextp;
	last_operator = nextp -> opt_statement.prev_operator;
	lastop = addr (quad (last_operator));

	/* thread in our opt_statement */

	ourp -> opt_statement.next = bit (next_statement, 18);
	ourp -> opt_statement.back = bit (last_statement, 18);
	lastp -> opt_statement.next = bit (our_statement, 18);
	nextp -> opt_statement.back = bit (our_statement, 18);
	ourp -> opt_statement.first_operator = next_operator;
	ourp -> opt_statement.prev_operator = last_operator;
	nextop -> operator.back = our_statement;
	lastop -> operator.next = our_statement;

	/* use lastp's source_id and flow_unit */

	unspec (ourp -> opt_statement.source_id) = unspec (lastp -> opt_statement.source_id);
	ourp -> opt_statement.flow_unit = lastp -> opt_statement.flow_unit;

	return (our_statement);

     end insert_statement_after;

insert_operator_after:
     procedure (op_code, number, last_operator) returns (fixed binary (18));

dcl  op_code fixed binary (18),
     number fixed binary (18),
     last_operator fixed binary (18);

dcl  (o, next_o, last_o) pointer;
dcl  op fixed binary (18);

	/* allocate the space */

	n_operands = number;
	op = get_quad_space (size (operator));
	o = addr (quad (op));

	/* initialize the space */

	o -> operator.op_code = op_code;
	o -> operator.number = n_operands;
	o -> operator.assigns_constant_to_symbol = "0"b;
	o -> operator.freed = "0"b;
	o -> operator.primary = null;

	/* if the operator is reducible, assign it a coordinate */

	if op_class (op_code) <= highest_reducible_class
	then do;
	     n_operators = n_operators + 1;

	     if n_operators <= max_operators
	     then o -> operator.coordinate = n_operators;
	     else do;
		call print_message (390);
		stop;
		end;
	     end;

	/* insert the operator */

	last_o = addr (quad (last_operator));
	next_o = addr (quad (last_o -> operator.next));
	o -> operator.next = last_o -> operator.next;
	o -> operator.back = last_operator;
	last_o -> operator.next = op;
	next_o -> operator.back = op;

	return (op);

     end insert_operator_after;

create_flow_unit:
     procedure () returns (pointer);

dcl  p pointer;
dcl  1 fort_node_templates_$flow_unit_template ext static aligned like flow_unit;


	/* allocates flow unit */

	if freefu = null
	then p = get_opt_space (size (flow_unit));
	else do;
	     p = freefu;
	     freefu = freefu -> flow_unit.next;
	     end;

	p -> flow_unit = fort_node_templates_$flow_unit_template;

	p -> flow_unit.loop = adam_loop;
	p -> flow_unit.set = get_opt_space (size (bits));
	p -> flow_unit.used = get_opt_space (size (bits));
	p -> flow_unit.busy_on_entry = get_opt_space (size (bits));
	p -> flow_unit.set_multiple = get_opt_space (size (bits));
	p -> flow_unit.busy_on_exit = get_opt_space (size (bits));
	p -> flow_unit.always_completely_set = get_opt_space (size (bits));
	if max_flow_units > 0
	then p -> flow_unit.dominated_by = get_opt_space (size (dbits));

	return (p);

     end create_flow_unit;

create_loop:
     procedure (dad) returns (pointer);

dcl  dad pointer;					/* ptr to containing loop */

dcl  (p, prev) pointer;

	p = get_opt_space (size (loop));

	if dad ^= null
	then do;

	     /* derive information from containing loop */

	     p -> loop.father = dad;
	     p -> loop.prev_brother, prev = dad -> loop.last_son;
	     dad -> loop.last_son = p;
	     if prev ^= null
	     then prev -> loop.brother = p;
	     else dad -> loop.son = p;
	     p -> loop.depth = dad -> loop.depth + 1;
	     p -> loop.is_member = get_opt_space (size (dbits));
	     p -> loop.is_exit = get_opt_space (size (dbits));
	     p -> loop.articulation_blocks = get_opt_space (size (dbits));
	     p -> loop.induction_var = get_opt_space (size (bits));
	     p -> loop.may_keep_in_xr = get_opt_space (size (bits));
	     p -> loop.computed = get_opt_space (size (obits));
	     end;

	else do;

	     /* initialize information for adam_loop */

	     p -> loop.father, p -> loop.prev_brother, p -> loop.is_member, p -> loop.is_exit,
		p -> loop.articulation_blocks, p -> loop.induction_var, p -> loop.may_keep_in_xr, p -> loop.computed =
		null;
	     p -> loop.depth = 0;
	     end;

	p -> loop.xregs_used, p -> loop.pregs_used, p -> loop.number = 0;

	p -> loop.has_side_effects = "0"b;

	p -> loop.ancestors_and_me, p -> loop.brother, p -> loop.son, p -> loop.last_son, p -> loop.entry_unit,
	     p -> loop.exits, p -> loop.back_target, p -> loop.first_unit, p -> loop.last_unit, p -> loop.members,
	     p -> loop.global_xr_items, p -> loop.global_pr_items, p -> loop.range_list, p -> loop.msp,
	     p -> loop.eligible_ind_var_op_var, p -> loop.left_shift_chain = null;

	p -> loop.used = get_opt_space (size (bits));
	p -> loop.set = get_opt_space (size (bits));
	p -> loop.set_multiple = get_opt_space (size (bits));
	p -> loop.busy_on_exit = get_opt_space (size (bits));

	n_loops = n_loops + 1;

	return (p);

     end create_loop;

optimize_subprogram:
     procedure ();

	/* optimize_subprogram has a choice of 2 different optimization algorithms.  In the first algortihm, loops are
	   processed inside-out, front to back (in other words, bottom-up).  After all loops except the non-iterative
	   outer loop are processed, the whole program is passed over for a consoldation pass to remove common
	   subexpressions that were made removable by earlier optimizations.  In the second algorithm, loops are
	   processed top-down recursively.  After an inner loop is processed, all expressions moved out of that
	   loop are processed to see if they can be further moved, commoned, etc.

	   NOTE:  Commoning MUST occur in the same pass that candidates for strength
	   reduction are found because otherwise candidates for common
	   expressions may be found so far apart that inefficient init
	   code may be produced.  By commoning at the same time, fewer
	   candidates are found, thus init code will be better. */

	/* GLOBAL VARS */

dcl  our_depth fixed binary (18);
dcl  (fu, lp, bt, lpf) pointer;
dcl  (sr_chain, sr_tail, incr_chain, ass_chain, da_chain) pointer;
dcl  free_var_list pointer;
dcl  used_invariant_symbol bit (1) aligned;
dcl  doing_loop bit (1) aligned;

	/* LOCAL VARS */

dcl  (i, j, k, new_statement, op, opt_mode) fixed binary (18);
dcl  (stm, q, t, o, c, lastc) pointer;
dcl  srvp pointer;

	/* initialize */

	da_chain, free_var_list = null;

	if need_consolidation_pass
	then do;
	     incr_chain, sr_chain, sr_tail, ass_chain = null;

	     do i = 1 to n_loops - 1;
		lp = loop_vector (i);
		call optimize_loop (lp);
		end;

	     call consolidate_subprogram;
	     end;

	else call process_loops_top_down;

	/* recompute all usage bits */

	call timer (9);

	call recompute_usage;

	/* remove dead assignments */

	if da_chain ^= null
	then do;
	     call timer (7);
	     call remove_dead_assignments;
	     end;

	call timer (4);

	/* convert the loop_end_chains into operators and operands */

	do i = 2 to n_flow_units;			/* want to look at detached as well as attached units */
	     fu = flow_unit_vector (i);
	     if fu -> flow_unit.n_in_loop_end > 0
	     then do;
		new_statement = insert_statement_after ((fu -> flow_unit.last_statement));
		addr (quad (new_statement)) -> opt_statement.put_in_map = "0"b;
						/* no code */
		j = fu -> flow_unit.n_in_loop_end;
		k = 0;

		do c = fu -> flow_unit.loop_end_chain repeat c -> lchain.next while (c ^= null);
		     if k <= 0
		     then do;
			k = min (j, max_operands);
			op = insert_operator_after (loop_end_op, k, new_statement);
			o = addr (quad (op));
			end;
		     lastc = c;
		     o -> operand (k) = c -> lchain.value;
		     k = k - 1;
		     j = j - 1;
		     end;

		lastc -> lchain.next = free (size (chain));
		free (size (chain)) = fu -> flow_unit.loop_end_chain;

		fu -> flow_unit.last_statement = new_statement;

		fu -> flow_unit.n_in_loop_end = 0;
		fu -> flow_unit.loop_end_chain = null;
		end;
	     end;

	/* free all sr_var nodes */

	do srvp = free_var_list repeat q while (srvp ^= null);
	     if srvp -> sr_var.used_in -> lbits
	     then do;
		q = addr (rands (srvp -> sr_var.variable));
		q -> symbol.allocate, q -> symbol.referenced, q -> symbol.set = "1"b;
		end;
	     q = srvp -> sr_var.next;
	     srvp -> sr_var.next = freesrv;
	     freesrv = srvp;
	     end;

	free_var_list = null;

optimize_loop:
     procedure (p_lp);

	/* optimizes loops for the bottom-up algorithm */

dcl  (lp, p_lp) pointer;				/* ptr to loop */

dcl  (last_fu, next_lp) pointer;

	/* initialize */

	lp = p_lp;

	state_discarded = "1"b;
	our_depth = lp -> loop.depth;
	bt = lp -> loop.back_target;
	doing_loop = "1"b;

	call derive_insert_for_bt (bt);

	/* We now mask out the used bits of invariant symbols.  process_moved_descendants
	   will turn on the bits of those invariant symbols containing uses not actually
	   moved out of the loop. */

	lp -> loop.used -> bits = lp -> loop.used -> bits & lp -> loop.set -> bits;

	/* process the loop */

	last_fu, next_lp = null;

	do fu = lp -> loop.members repeat fu -> flow_unit.next_in_loop while (fu ^= null);
	     if last_fu ^= fu -> flow_unit.back
	     then do;

		/* we have passed over flow_units from other loops */

		if ^fu -> flow_unit.back -> flow_unit.falls_through
		then state_discarded = "1"b;
		else if ^state_discarded
		then if next_lp ^= fu -> flow_unit.back -> flow_unit.loop
		     then state_discarded = "1"b;
		end;

	     if fu -> flow_unit.loop_entry
	     then call clear ("0"b);			/* Leave hash index intact */

	     call optimize_flow_unit (fu, full_optimization, complete_fu, our_depth);

	     if fu -> flow_unit.next_in_loop ^= fu -> flow_unit.next
	     then do;

		/* we are about to pass over flow_units from other loops */

		if ^fu -> flow_unit.falls_through
		then state_discarded = "1"b;
		else do;
		     next_lp = fu -> flow_unit.next -> flow_unit.loop;

		     if our_depth < next_lp -> loop.depth
		     then call set_loop_variants (next_lp);
		     else do;
			call process_jump_target ((fu -> flow_unit.next -> flow_unit.first_statement));
			state_discarded = "1"b;
			end;
		     end;
		end;

	     last_fu = fu;
	     end;

	call finish_loop;

	call clear ("1"b);

     end optimize_loop;

consolidate_subprogram:
     procedure ();

	/* runs the consolidation pass for the bottom-up algorithm */

	/* uses optimize_subprogram's variables */

	call timer (8);

	consolidating = "1"b;

	/* remove all vestiges of the previous optimizations' effects from the opt_statement nodes */

	do fu = exit_unit -> flow_unit.back repeat fu -> flow_unit.back while (fu ^= entry_unit);
	     stm = addr (quad (fu -> flow_unit.first_statement));
	     if stm -> opt_statement.has_operator_list
	     then do;
		if stm -> opt_statement.operator_list ^= null
		then do;

		     /* release useless primaries on operator_list */

		     t = stm -> opt_statement.operator_list;
		     do q = t repeat t while (q ^= null);
			call release_node (q, t, 0);
			end;
		     stm -> opt_statement.operator_list = null;
		     end;

		fu -> flow_unit.is_active_operator -> obits = "0"b;
		stm -> opt_statement.has_operator_list = "0"b;
		end;

	     fu -> flow_unit.processed = "0"b;
	     end;

	/* Pass over all the flow_units. */

	do fu = entry_unit -> flow_unit.next repeat fu -> flow_unit.next while (fu ^= exit_unit);
	     lp = fu -> flow_unit.loop;
	     if lp = adam_loop
	     then opt_mode = full_optimization;
	     else opt_mode = common_only;
	     our_depth = lp -> loop.depth;

	     call optimize_flow_unit (fu, opt_mode, complete_fu, our_depth);
	     end;

	if meter_hash_buckets
	then call print_hash_bucket_meters;

	call clear ("1"b);

	consolidating = "0"b;

     end consolidate_subprogram;

process_loops_top_down:
     procedure ();

	/* this routine does top - down processing of loops */

	/* uses declaration in optimize_subprogram */

	/* begin processing of loops */

	if init_lp_frame = null
	then init_lp_frame, lpf = create_lp_frame (null);
	else lpf = init_lp_frame;

	lp = adam_loop;
	call start_loop;

	/* These nested loops simulate a recursive walk of the loop tree */

	do while (lp ^= null);

	     do while (lpf -> lp_frame.this_fu ^= null);
		fu = lpf -> lp_frame.this_fu;
		lpf -> lp_frame.this_fu = fu -> flow_unit.next_in_loop;

		if lpf -> lp_frame.last_fu ^= fu -> flow_unit.back
		then do;

		     /* we have passed over flow_units from other loops */

		     if ^fu -> flow_unit.back -> flow_unit.falls_through
		     then state_discarded = "1"b;
		     else if ^state_discarded
		     then if lpf -> lp_frame.next_lp ^= fu -> flow_unit.back -> flow_unit.loop
			then state_discarded = "1"b;
		     end;

		call optimize_flow_unit (fu, full_optimization, complete_fu, our_depth);

		if fu -> flow_unit.is_back_target
		then do;

		     /* we have a back target, so we now process inner loop */

		     call push_loop;
		     call start_loop;
		     end;

		else do;
		     if fu -> flow_unit.next_in_loop ^= fu -> flow_unit.next
		     then do;

			/* we are about to pass over flow_units from other loops */

			if ^fu -> flow_unit.falls_through
			then state_discarded = "1"b;
			else do;
			     lpf -> lp_frame.next_lp = fu -> flow_unit.next -> flow_unit.loop;

			     if our_depth < lpf -> lp_frame.next_lp -> loop.depth
			     then call set_loop_variants ((lpf -> lp_frame.next_lp));
			     else do;
				call process_jump_target ((fu -> flow_unit.next -> flow_unit.first_statement));
				state_discarded = "1"b;
				end;
			     end;
			end;

		     lpf -> lp_frame.last_fu = fu;
		     end;
		end;

	     /* processing of flow_units in this loop is done, we now wind up processing of the loop */

	     if doing_loop
	     then call finish_loop;

	     call clear ("1"b);

	     /* now pop the loop so we can resume processing of outer loop */

	     call pop_loop;

	     end;


     end process_loops_top_down;

start_loop:
     procedure ();

	/* initializes processing of a loop for the top-down algorithm */

	state_discarded = "1"b;
	our_depth = lp -> loop.depth;
	bt = lp -> loop.back_target;
	doing_loop = bt ^= null;
	incr_chain, sr_chain, sr_tail, ass_chain = null;
	lpf -> lp_frame.this_fu = lp -> loop.members;
	lpf -> lp_frame.last_fu, lpf -> lp_frame.next_lp = null;

     end start_loop;

finish_loop:
     procedure ();

dcl  (c, o, p, q, outp) pointer;
dcl  i fixed binary (18);
dcl  exit_target pointer unaligned;
dcl  has_multiple_exits bit (1) aligned;

	/* Because of the refinement of the used bits, we have to OR in the used
	   bits of inner loops, which have, of course, already been completely processed. */

	do p = lp -> loop.son repeat p -> loop.brother while (p ^= null);
	     lp -> loop.used -> bits = lp -> loop.used -> bits | p -> loop.used -> bits;
	     end;

	/* OR back target's primaries into entry unit */

	if ^need_consolidation_pass
	then call union ((lp -> loop.entry_unit), bt_list_st);

	/* DO STRENGTH REDUCTION */

	call timer (5);

	call reduce_strength (lp);

	call timer (4);

	/* Optionally, print out metering information on the primary lists. */

	if meter_hash_buckets
	then call print_hash_bucket_meters;

	/* Free all primaries in the back target.

	   For each temporary (or array_ref) in the bt_list
	   that still has used_across_loops bit on and is already
	   in a loop_end list for an inner loop, put the temp in
	   the loop_end list for this loop.  This fixes bug 218.	*/

	do i = 0 to hbound (bt_list, 1);

	     do p = bt_list (i) repeat q while (p ^= null);
		q = p -> primary.next;

		o = p -> primary.expression;
		outp = addr (rands (o -> operator.output));
		if outp -> node.node_type = temporary_node | o -> operator.op_code = opt_subscript_op
		then if outp -> temporary.used_across_loops
		     then if outp -> temporary.loop_end_fu_pos > 0
			     & outp -> temporary.loop_end_fu_pos < lp -> loop.last_unit -> flow_unit.position
			then call put_in_loop_end (outp, lp);

		call release_primary (p);
		end;

	     end;

	/* consider removing loop */

	if ^lp -> loop.has_side_effects
	then if (lp -> loop.set -> bits & lp -> loop.busy_on_exit -> bits) = "0"b
	     then do;

		/* loop must have only 1 exit target */

		if lp -> loop.exits = null
		then do;
		     call print_message (389);	/* loop has no exit */
		     return;
		     end;

		exit_target = lp -> loop.exits -> chain.value -> edge.to.value;
		has_multiple_exits = "0"b;

		do c = lp -> loop.exits -> chain.next repeat c -> chain.next while (c ^= null & ^has_multiple_exits);
		     if exit_target ^= c -> chain.value -> edge.to.value
		     then has_multiple_exits = "1"b;
		     end;

		if ^has_multiple_exits
		then call remove_loop (lp);
		end;

     end finish_loop;

push_loop:
     procedure ();

	/* prepares for processing of inner loop for the top-down algorithm */

dcl  i fixed binary (18);
dcl  (o, p, q, hold_list, outp, next_lp, last_p) pointer;

	/* save the present machine state so we can resume it later */

	hold_list = null;

	do i = 0 to hbound (p_list, 1);
	     do p = p_list (i) repeat p -> primary.next while (p ^= null);
		q = create_o_node (hold_list, 0);
		q -> primary.data = p -> primary.data;
		end;
	     end;

	lpf -> lp_frame.hold_p_list = hold_list;

	hold_list = null;

	do i = 0 to hbound (bt_list, 1);
	     do p = bt_list (i) repeat p -> primary.next while (p ^= null);
		q = create_o_node (hold_list, 0);
		q -> primary.data = p -> primary.data;
		end;
	     end;

	lpf -> lp_frame.hold_bt_list = hold_list;

	/* save strength reduction candidate state */

	lpf -> lp_frame.hold_incr_chain = incr_chain;
	lpf -> lp_frame.hold_sr_chain = sr_chain;
	lpf -> lp_frame.hold_sr_tail = sr_tail;
	lpf -> lp_frame.hold_ass_chain = ass_chain;

	/* now set the loop variants for the new loop */

	next_lp = fu -> flow_unit.successors -> edge.to.value -> flow_unit.loop;
	call set_loop_variants (next_lp);

	/* add p_list onto bt_list & null out p_list */

	do i = 0 to hbound (p_list, 1);
	     last_p = null;

	     do p = p_list (i) repeat p -> primary.next while (p ^= null);
		o = p -> primary.expression;
		outp = addr (rands (o -> operator.output));
		if outp -> node.node_type = temporary_node | o -> operator.op_code = opt_subscript_op
		then outp -> temporary.invariant = "1"b;
		last_p = p;
		end;

	     if last_p ^= null
	     then do;
		last_p -> primary.next = bt_list (i);
		if bt_list (i) ^= null
		then bt_list (i) -> primary.last = last_p;
		bt_list (i) = p_list (i);
		bt_list (i) -> primary.last = addr (bt_list (i));
		p_list (i) = null;
		end;
	     end;

	/* we can now detach secondaries (except for constant assignments), since only loop invariants are left */

	call detach_secondaries ("0"b);

	/* fill in insert_* fields in back target of next_lp */

	bt = fu;

	call derive_insert_for_bt (bt);

	/* build a new opt_statement node to mark place we should resume operation in pop_loop */

	call insert_stm_in_back_target (bt, addr (quad (bt -> flow_unit.insert_statement)));

	lpf -> lp_frame.resume_st = bt -> flow_unit.insert_statement;

	/* UPDATE lp */

	lp = next_lp;

	if lpf -> lp_frame.next = null
	then lpf = create_lp_frame (lpf);
	else lpf = lpf -> lp_frame.next;

	/* We now mask out the used bits of invariant symbols.  process_moved_descendants
	   will turn on the bits of those invariant symbols whose uses are not moved
	   out of the loop. */

	lp -> loop.used -> bits = lp -> loop.used -> bits & lp -> loop.set -> bits;

     end push_loop;

pop_loop:
     procedure ();

	/* prepares to resume processing of an outer loop after the inner loop is completed.  All
	   expressions moved to the outer loop are now processed.  */

dcl  (hold_has_label, hold_has_operator_list, hold_entry_pt, possibly_found) bit (1) aligned;
dcl  (p, q, hold_list, new, stm, o, outp, c, last_c, old_lp) pointer;
dcl  (hash_index, hold_first_statement) fixed binary (18);

	fu = lp -> loop.back_target;

	/* RESTORE lp */

	old_lp = lp;
	lp = lp -> loop.father;
	lpf = lpf -> lp_frame.back;

	if lp = null
	then return;

	/* restore machine state */

	hold_list = lpf -> lp_frame.hold_p_list;
	lpf -> lp_frame.hold_p_list = null;

	do p = hold_list repeat q while (p ^= null);
	     q = p -> primary.next;
	     o = p -> primary.expression;

	     if ^o -> operator.freed
	     then do;
		outp = addr (rands (o -> operator.output));
		if outp -> node.node_type = temporary_node | o -> operator.op_code = opt_subscript_op
		then outp -> temporary.invariant = "0"b;

		hash_index = hash (o, possibly_found);
		new = create_primary (p_list_st (hash_index));
		new -> primary.data = p -> primary.data;
		o -> operator.primary = new;
		call record_secondaries (o, 0);
		end;

	     call release_node (p, hold_list, 0);
	     end;

	hold_list = lpf -> lp_frame.hold_bt_list;
	lpf -> lp_frame.hold_bt_list = null;

	do p = hold_list repeat q while (p ^= null);
	     q = p -> primary.next;
	     o = p -> primary.expression;

	     if ^o -> operator.freed
	     then do;
		hash_index = hash (o, possibly_found);
		new = create_primary (bt_list_st (hash_index));
		new -> primary.data = p -> primary.data;
		o -> operator.primary = new;
		if o -> operator.assigns_constant_to_symbol
		then call record_secondaries (o, -1);
		end;

	     call release_node (p, hold_list, 0);
	     end;

	state_discarded = "0"b;

	/* restore strength reduction candidate state */

	incr_chain = lpf -> lp_frame.hold_incr_chain;
	sr_chain = lpf -> lp_frame.hold_sr_chain;
	sr_tail = lpf -> lp_frame.hold_sr_tail;
	ass_chain = lpf -> lp_frame.hold_ass_chain;

	/* restore other global vars */

	our_depth = lp -> loop.depth;
	bt = lp -> loop.back_target;
	doing_loop = bt ^= null;

	/* process new operators that have been moved up from the inner loop.
	   This will be done by fooling optimize_flow_unit into doing it.  */

	hold_first_statement = fu -> flow_unit.first_statement;
	fu -> flow_unit.first_statement = lpf -> lp_frame.resume_st;
	stm = addr (quad (fu -> flow_unit.first_statement));
	hold_has_operator_list = stm -> opt_statement.has_operator_list;
	stm -> opt_statement.has_operator_list = "0"b;
	hold_has_label = fu -> flow_unit.has_label;
	fu -> flow_unit.has_label = "0"b;
	hold_entry_pt = fu -> flow_unit.entry_pt;
	fu -> flow_unit.entry_pt = "0"b;

	call optimize_flow_unit (fu, full_optimization, partial_fu, our_depth);

	fu -> flow_unit.entry_pt = hold_entry_pt;
	fu -> flow_unit.has_label = hold_has_label;
	stm -> opt_statement.has_operator_list = hold_has_operator_list;
	fu -> flow_unit.first_statement = hold_first_statement;

	/* union new p_list with jump_targets first referenced by inner loop */

	if lpf -> lp_frame.first_jump_target ^= null
	then do;
	     call set_loop_variants (old_lp);

	     last_c = null;
	     do c = lpf -> lp_frame.first_jump_target repeat c -> chain.next while (c ^= null);
		call union ((c -> chain.value), p_list_st);
		last_c = c;
		end;

	     last_c -> chain.next = free (size (chain));
	     free (size (chain)) = lpf -> lp_frame.first_jump_target;
	     lpf -> lp_frame.first_jump_target = null;
	     end;

     end pop_loop;

create_lp_frame:
     procedure (last_p) returns (pointer);

	/* creates lp_frame to help in recursive processing of loops */

dcl  last_p pointer;				/* -> lp_frame we are to connect to the new one */

dcl  p pointer;

	p = get_opt_space (size (lp_frame));

	p -> lp_frame.next = null;
	p -> lp_frame.back = last_p;
	if last_p ^= null
	then last_p -> lp_frame.next = p;
	p -> lp_frame.first_jump_target = null;

	return (p);

     end create_lp_frame;

optimize_flow_unit:
     procedure (p_fu, mode, how_much, p_our_depth);

	/* optimize_flow_unit implements an optimization algorithm that has been developed (with many improvements) from
	   the algorithm used by the Multics PL/I common subexpression optimizer (as of 1977).  The two primary lists,
	   p_list and bt_list, are lists of expressions available for commoning; bt_list is the list of expressions
	   originating outside of the loop.  The secondary list, s_list, is a list of variables upon which the exprs
	   in the p_list depend.  When a variable in s_list is set, all expressions in the p_list depending on that
	   variable are removed.  No expressions are removed from bt_list since they are loop invariant.  bt_list
	   is only used if mode = full_optimization.  */

dcl  (fu, p_fu) pointer;				/* flow_unit being optimized */
dcl  mode fixed binary (18);				/* full_optimization, common_only */
dcl  how_much fixed binary (18);			/* complete_fu, partial_fu */
dcl  (our_depth, p_our_depth) fixed binary (18);		/* flow_unit's nesting depth */

dcl  ipol fixed bin (18);				/* polish index for read_namelist */
dcl  (bt, o, outp, p, q, stm, lp) pointer;
dcl  (bd_level_number, coord, i, next_op, next_statement, next_unit_statement, op_code, opnd, outp_node_type, hash_index)
	fixed binary (18);
dcl  (invariant, is_articulation_block, used_across_loops, reducible, all_constant, have_sr_candidate,
     doing_full_optimization, succeeded, optimizing_loop, possibly_found, constant_assignment) bit (1) aligned;

	fu = p_fu;
	doing_full_optimization = mode = full_optimization;
	our_depth = p_our_depth;

	if fu -> flow_unit.first_statement = 0
	then return;

	stm = addr (quad (fu -> flow_unit.first_statement));

	/* process possible label or operator_list starting the flow unit */

	if fu -> flow_unit.has_label | stm -> opt_statement.has_operator_list
	then do;

	     if state_discarded
	     then do;
		call intersection (stm, 1);
		call intersection (stm, 3);
		end;

	     if stm -> opt_statement.referenced_backwards & ^stm -> opt_statement.referenced_by_assign
	     then do;
		call set_loop_variants ((fu -> flow_unit.loop));

		/* determine level number of most recently processed back dominator */

		do p = fu -> flow_unit.dominator repeat p -> flow_unit.dominator while (^p -> flow_unit.processed);
		     end;

		bd_level_number = p -> flow_unit.level_number;

		/* remove computations first evaluated in a flow unit of higher level number */

		do i = 0 to hbound (p_list, 1);
		     p = p_list (i);
		     do while (p ^= null);
			if p -> primary.flow_unit -> flow_unit.level_number > bd_level_number
			then do;
			     q = p -> primary.next;
			     call release_primary (p);
			     p = q;
			     end;
			else p = p -> primary.next;
			end;
		     end;

		if state_discarded
		then call intersection (stm, 2);
		end;

	     if ^state_discarded
	     then do;
		call intersection (stm, 1);
		call intersection (stm, 2);
		end;

	     if ^fu -> flow_unit.loop_entry
	     then call trim_operator_list (stm);

	     state_discarded = "0"b;

	     end;

	/* initialize for optimization loop */

	lp = fu -> flow_unit.loop;
	is_articulation_block = substr (lp -> loop.articulation_blocks -> dbits, fu -> flow_unit.number, 1);
	bt = lp -> loop.back_target;
	if fu -> flow_unit.next ^= null
	then next_unit_statement = fu -> flow_unit.next -> flow_unit.first_statement;
	else next_unit_statement = 0;

	/* mask out used bits for invariant symbols as process_moved_descendants will recalculate these bits */

	if doing_full_optimization & bt ^= null
	then do;
	     if how_much = complete_fu
	     then fu -> flow_unit.used -> bits = fu -> flow_unit.used -> bits & lp -> loop.set -> bits;
	     optimizing_loop = "1"b;
	     end;
	else optimizing_loop = "0"b;

	/* optimization loop */

	do cur_statement = fu -> flow_unit.first_statement repeat next_statement
	     while (cur_statement ^= next_unit_statement);
	     stm = addr (quad (cur_statement));
	     next_statement = fixed (stm -> opt_statement.next, 18);

	     do op = stm -> opt_statement.first_operator repeat next_op while (op ^= next_statement);
		o = addr (quad (op));
		op_code = o -> operator.op_code;
		next_op = o -> operator.next;
		if o -> operator.output > 0
		then do;
		     outp = addr (rands (o -> operator.output));
		     outp_node_type = outp -> node.node_type;
		     end;
		else do;
		     outp = null;
		     outp_node_type = 0b;
		     end;

		/* determine reducibility and moveability of operands */

		constant_assignment, have_sr_candidate, used_invariant_symbol, used_across_loops = "0"b;
		all_constant = "1"b;
		reducible = "1"b;
		invariant = optimizing_loop;

		do i = 1 to o -> operator.number;
		     opnd = o -> operand (i);

		     if opnd > 0
		     then do;
			p = addr (rands (opnd));

			if p -> node.node_type = constant_node
			then do;
			     if op_code = opt_subscript_op & i = 3
			     then call make_constant_opt_subscript (o);
			     else if have_identity (o, i)
			     then go to step;
			     end;

			else if p -> node.node_type = array_ref_node
			then do;
			     used_across_loops = used_across_loops | p -> array_ref.used_across_loops;
			     if p -> array_ref.irreducible
			     then reducible = "0"b;
			     invariant = invariant & p -> array_ref.invariant;
			     p = addr (rands (p -> array_ref.parent));
			     all_constant = "0"b;
			     coord = p -> symbol.coordinate;
			     if coord > 0
			     then if substr (lp -> loop.set -> bits, coord, 1)
				then invariant = "0"b;
				else used_invariant_symbol = optimizing_loop;
			     p -> symbol.has_constant_value = "0"b;
						/* Optimizer botches substring whose parent has constant value. */
			     end;

			else if p -> node.node_type = symbol_node
			then do;
			     if p -> symbol.has_constant_value & (op_code ^= call_op) & (op_code ^= func_ref_op)
				& (op_code ^= opt_subscript_op | i ^= 1)
			     then do;
				o -> operand (i) =
				     p -> symbol.secondary -> secondary.primary -> chain.value
				     -> primary.expression -> operand (1);

				if op_code = opt_subscript_op & i = 3
				then call make_constant_opt_subscript (o);
				else if have_identity (o, i)
				then go to step;
				end;

			     else do;
				all_constant = "0"b;

				if i ^= 1 | op_code ^= opt_subscript_op
				then do;
				     coord = p -> symbol.coordinate;
				     if coord > 0
				     then if substr (lp -> loop.set -> bits, coord, 1)
					then invariant = "0"b;
					else used_invariant_symbol = optimizing_loop;
				     end;
				end;
			     end;

			else if p -> node.node_type = temporary_node
			then do;
			     if p -> temporary.frozen_for_do
			     then call process_frozen_for_do (p);

			     else do;
				all_constant = "0"b;
				used_across_loops = used_across_loops | p -> temporary.used_across_loops;
				if p -> temporary.irreducible
				then reducible = "0"b;
				invariant = invariant & p -> temporary.invariant;
				end;
			     end;
			end;
		     end;

		if outp_node_type = array_ref_node
		then do;
		     if outp -> array_ref.irreducible
		     then reducible = "0"b;
		     used_across_loops = used_across_loops | outp -> array_ref.used_across_loops;
		     end;

		else if outp_node_type = temporary_node
		then if outp -> temporary.frozen_for_do
		     then if addr (rands (o -> operand (1))) -> node.node_type ^= array_ref_node
			then invariant = "0"b;
			else ;
		     else ;

		else if all_constant & op_code = assign_op
		then constant_assignment = constant_assign (o);

		if reducible & op_class (op_code) <= highest_reducible_class
		then do;

		     /* handle reducible operators */

		     if outp_node_type = temporary_node | op_code = opt_subscript_op
		     then outp -> temporary.used_across_loops, outp -> temporary.invariant = "0"b;

		     /* search current machine state for equivalent expression */

		     hash_index = hash (o, possibly_found);

		     if possibly_found
		     then do;
			do p = p_list (hash_index) repeat p -> primary.next while (p ^= null);
			     q = p -> primary.expression;
			     if compare_expression (o, q)
			     then do;
				call common (o, q, succeeded);
				if succeeded
				then go to step;
				end;
			     end;

			/* search back target for equivalent expression */

			if invariant
			then do p = bt_list (hash_index) repeat p -> primary.next while (p ^= null);
				q = p -> primary.expression;
				if compare_expression (o, q)
				then do;
				     call common (o, q, succeeded);
				     go to step;
				     end;
				end;
			end;

		     /* attempt to fold the operation if all operands are constants */

		     if all_constant & op_class (op_code) < assignment_class
		     then if constant_expression (o)
			then go to step;

		     /* try to move the expression */

		     if invariant & (is_articulation_block | op_class (op_code) <= always_safe_to_move_class)
		     then do;
			p = outp;

			/* check the output operand for suitability */

			if outp_node_type ^= temporary_node
			then do;
			     if outp_node_type = array_ref_node & op_code ^= opt_subscript_op
			     then do;
				invariant = invariant & p -> array_ref.invariant;
				if invariant
				then p = addr (rands (p -> array_ref.parent));
				end;

			     if p -> node.node_type = symbol_node
			     then do;
				coord = p -> symbol.coordinate;
				if substr (bt -> flow_unit.busy_on_exit -> bits, coord, 1)
				     | substr (lp -> loop.set_multiple -> bits, coord, 1)
				then invariant = "0"b;
				end;
			     end;

			if invariant
			then do;

			     /* We can move it! */

			     call move (o, stm, fu, bt);

			     /* add the operator to the back target's machine state */

			     p = create_primary (bt_list_st (hash_index));
			     p -> primary.expression = o;
			     p -> primary.flow_unit = bt;
			     o -> operator.primary = p;

			     if constant_assignment
			     then do;
				o -> operator.assigns_constant_to_symbol = "1"b;
				call record_secondaries (o, -1);
				end;

			     go to step;
			     end;
			end;

		     /* not moved or commoned, add the expression to the primary list,
		        process set contexts, and process moved descendants */

		     p = create_primary (p_list_st (hash_index));
		     p -> primary.expression = o;
		     p -> primary.flow_unit = fu;
		     o -> operator.primary = p;
		     call record_secondaries (o, 1);	/* record input operands as secondaries */

		     if outp_node_type ^= temporary_node & op_code ^= opt_subscript_op
		     then do;
			call set (outp);

			if o -> operator.primary ^= null
						/* the primary could have been removed if the target */
			then do;			/* also appeared on the right hand side. */
			     if constant_assignment
			     then do;
				o -> operator.assigns_constant_to_symbol = "1"b;
				if doing_full_optimization & ^outp -> symbol.aliasable
				then call chain_dac ((o -> operator.output), fu);
				end;

			     call record_secondaries (o, -1);
						/* record output operand as secondary */
			     end;
			end;

		     /* look for add, subtract, multiply, or increment by a loop invariant */

		     if doing_full_optimization & outp -> node.data_type = int_mode
		     then if (op_code = mult_op | op_code = add_op | op_code = sub_op) & optimizing_loop
			then have_sr_candidate = check_str_reducibility ();
			else if op_code = assign_op
			then call check_increment;

		     if ^have_sr_candidate & (used_across_loops | used_invariant_symbol)
		     then call process_moved_descendants (o, fu);
		     end;

		else do;

		     /* irreducible operators (and operands) */

		     if used_across_loops | used_invariant_symbol
		     then call process_moved_descendants (o, fu);

		     if outp_node_type ^= 0b & outp_node_type ^= temporary_node & op_code ^= opt_subscript_op
		     then call set (outp);

		     /* handle special cases */

		     go to case (op_class (op_code));

case (4):						/* assignment */
		     if doing_full_optimization & outp -> node.data_type = int_mode & op_code = assign_op
		     then call check_increment;
		     go to join;

case (6):						/* call & func_ref */
		     do i = 3 to o -> operator.number;
			call set (addr (rands (o -> operand (i))));
			end;

		     call set_externals;
		     go to join;

case (7):						/* entry points */
		     call clear ("1"b);
		     state_discarded = "0"b;
		     go to join;

case (8):						/* jump */
		     call process_jump_label ((o -> operand (1)));
		     state_discarded = "1"b;
		     go to join;

case (9):						/* jump_arithmetic */
		     do i = 2 to 4;
			call process_jump_label ((o -> operand (i)));
			end;
		     state_discarded = "1"b;
		     go to join;

case (10):					/* jump_computed */
		     do i = 1 to o -> operand (1) + bias;
			call process_jump_label ((o -> operand (i + 1)));
			end;
		     go to join;

case (11):					/* jump_assigned */
case (13):					/* return, stop */
		     state_discarded = "1"b;
		     go to join;

case (12):					/* jump_true, jump_false */
		     call process_jump_label ((o -> operand (2)));
		     go to join;

case (18):					/* read_namelist */
		     ipol = addr (rands (o -> operand (1))) -> symbol.initial;
		     do i = 1 to polish (ipol);
			call set (addr (rands (polish (ipol + i))));
			end;
		     goto join;

case (1):						/* reducible */
case (2):						/* .. */
case (3):						/* .. */
case (5):						/* assignment */
case (14):					/* error_label, end_label */
case (15):					/* irreducible */
case (16):					/* assign_label */
case (17):					/* end_unit */
case (19):					/* write_namelist */
case (20):					/* non_executable, no_op */
case (21):					/* irreducible, partially sets */
case (22):					/* inquire */
join:
		     if outp_node_type = temporary_node | op_code = opt_subscript_op
		     then outp -> temporary.irreducible = "1"b;
		     end;

step:
		end;

	     end;

	fu -> flow_unit.processed = "1"b;

compare_expression:
     procedure (pa, pb) returns (bit (1) aligned);

dcl  (pa, pb) pointer;

dcl  (a, b, r1, r2) pointer;
dcl  i fixed binary (18);

	a = pa;
	b = pb;

	/* Although it is inelegant, we compare operand(1) outside the loop
	   for  speed.  This is valid because all reducible operators must
	   have at least one input operand. */

	if a -> operand (1) ^= b -> operand (1)
	then go to fail;

	if a -> operator.op_code ^= b -> operator.op_code
	then go to fail;

	if a -> operator.number ^= b -> operator.number
	then go to fail;

	do i = 2 to a -> operator.number;
	     if a -> operand (i) ^= b -> operand (i)
	     then go to fail;
	     end;

	if a -> operator.output ^= b -> operator.output
	then do;
	     r1 = addr (rands (a -> operator.output));
	     r2 = addr (rands (b -> operator.output));
	     if r1 -> node.node_type ^= r2 -> node.node_type
	     then go to fail;
	     if r1 -> node.node_type ^= temporary_node
	     then if b -> operator.op_code ^= opt_subscript_op
		then go to fail;
	     end;

	return ("1"b);

fail:
	return ("0"b);

     end compare_expression;

common:
     procedure (p_old, p_new, succeeded);

	/* removes common (or redundant) expressions */

dcl  (p_old, old) pointer,				/* ptr to operator to be commoned (input) */
     (p_new, new) pointer,				/* ptr to operator already in machine state (input) */
     succeeded bit (1) aligned;			/* "1"b if commoning succeeds (output) */

dcl  (old_outp, new_outp, old_startp, new_fu) pointer;
dcl  (new_out, old_out, i) fixed binary (18);

	old = p_old;
	new = p_new;

	/* replace instances of old's output with new's output */

	old_out = old -> operator.output;
	new_out = new -> operator.output;
	new_outp = addr (rands (new_out));
	old_outp = addr (rands (old_out));

	/* if loop nesting depths of new and old differ, then appropriate action must be taken */

	new_fu = new -> operator.primary -> primary.flow_unit;

	if new_fu -> flow_unit.loop ^= fu -> flow_unit.loop
	then if new_fu -> flow_unit.loop -> loop.depth <= our_depth
	     then do;
		if doing_full_optimization
		then new_outp -> temporary.invariant = "1"b;
		new_outp -> temporary.used_across_loops = "1"b;
		end;

	     else do;

		/* we will allow commoning from inside to ouside only if inner temp has high ref count */

		if new_outp -> node.node_type = temporary_node
		then if new_outp -> temporary.ref_count = 1
		     then do;
			succeeded = "0"b;
			return;
			end;

		new -> operator.primary -> primary.flow_unit = fu;
		end;

	succeeded = "1"b;

	/* Do actual commoning */

	if old_outp -> node.node_type = temporary_node | old -> operator.op_code = opt_subscript_op
	then do;
	     if old_outp -> temporary.ref_count > 0
	     then do;
		new_outp -> temporary.ref_count = new_outp -> temporary.ref_count + old_outp -> temporary.ref_count;
		old_outp -> temporary.ref_count = 0;
		old_startp = addr (polish (old_outp -> temporary.start_input_to));

		call replace_inputs (old_startp, new_out);

		addr (polish (new_outp -> temporary.end_input_to)) -> input_to.next = old_startp;
		new_outp -> temporary.end_input_to = old_outp -> temporary.end_input_to;
		end;
	     end;

	else do;
	     if old_outp -> node.node_type = array_ref_node
	     then do;				/* ref_count will be decremented by free_operator (disconnect_temporary) */
		old_outp = addr (rands (old_outp -> array_ref.parent));
		end;

	     /* old_outp is now a symbol,  so update busy_on_exit */

	     if fu ^= new_fu
	     then do;
		i = old_outp -> symbol.coordinate;
		substr (new_fu -> flow_unit.busy_on_exit -> bits, i, 1) =
		     substr (new_fu -> flow_unit.busy_on_exit -> bits, i, 1)
		     | (substr (fu -> flow_unit.busy_on_exit -> bits, i, 1)
		     | substr (fu -> flow_unit.used -> bits, i, 1));
		end;
	     end;

	/* decrement ref counts of inputs and free the operator */

	call decrement_input_ref_counts (old);

	call free_operator (old);

     end common;

have_identity:
     procedure (o, i) returns (bit (1) aligned);

	/* this routine looks for adds or subtracts of zero or multiplies by one.  These should only have
	   been produced by the optimizer during strength reduction + constant_expression.  This has the problem
	   of not setting the used bits for symbols replacing the temporary so that the effect must be locally
	   restricted.  */

dcl  o pointer,					/* -> operator being checked */
     i fixed binary (18);				/* index of operand having a constant value */

dcl  other fixed binary (18);
dcl  (otherp, inp) pointer;

	if o -> operand (i) = one & op_code = mult_op
	     | o -> operand (i) = zero & (op_code = add_op | (op_code = sub_op & i = 2))
	then do;
	     other = o -> operand (3 - i);
	     otherp = addr (rands (other));
	     inp = addr (polish (outp -> temporary.start_input_to));

	     call replace_inputs (inp, other);

	     if otherp -> node.node_type = temporary_node | otherp -> node.node_type = array_ref_node
	     then do;
		otherp -> temporary.ref_count = otherp -> temporary.ref_count - 1 + outp -> temporary.ref_count;
		addr (polish (otherp -> temporary.end_input_to)) -> input_to.next = inp;
		otherp -> temporary.end_input_to = outp -> temporary.end_input_to;
		end;

	     call free_operator (o);

	     return ("1"b);
	     end;

	else return ("0"b);

     end have_identity;

check_str_reducibility:
     procedure () returns (bit (1) aligned);

	/* this routine chains together all multiplies, adds, and subtracts by a loop
	   invariant of a simple integer variable as long as they are not increments or decrements */

dcl  (p, next_op) pointer;
dcl  i fixed binary (18);
dcl  is_loop_invariant (2) bit (1) aligned;

	if op_code ^= mult_op
	then do;
	     next_op = addr (polish (outp -> temporary.start_input_to)) -> input_to.operator;
	     if next_op -> operator.op_code = assign_op
	     then if next_op -> operator.output = o -> operand (1) | next_op -> operator.output = o -> operand (2)
		then return ("0"b);
	     end;

	is_loop_invariant (1), is_loop_invariant (2) = "0"b;

	do i = 1 to 2;
	     p = addr (rands (o -> operand (i)));

	     if p -> node.node_type = array_ref_node
	     then return ("0"b);

	     else if p -> node.node_type = constant_node
	     then is_loop_invariant (i) = "1"b;

	     else if p -> node.node_type = temporary_node
	     then if p -> temporary.invariant
		then is_loop_invariant (i) = "1"b;
		else return ("0"b);

	     else if ^substr (lp -> loop.set -> bits, p -> symbol.coordinate, 1)
	     then is_loop_invariant (i) = "1"b;
	     else if p -> symbol.aliasable | p -> symbol.dimensioned
		| substr (lp -> loop.set_multiple -> bits, p -> symbol.coordinate, 1)
	     then return ("0"b);

	     end;

	/* if both or neither are loop invariant, then give up */

	if is_loop_invariant (1) = is_loop_invariant (2)
	then return ("0"b);

	if is_loop_invariant (1)
	then i = 2;
	else i = 1;

	/* chain this on sr_chain */

	call chain_sr_cand (o, i, stm);

	return ("1"b);

     end check_str_reducibility;

check_increment:
     procedure ();

	/* this routine optimizes incrementing and decrementing of an integer variable by replacing the 2 operations
	   with a "to_storage" op.  It then chains operators that update induction variables. */

dcl  (oexpr, inp, incrp) pointer;
dcl  (target, i, op_code, input) fixed binary (18);
dcl  is_temp_or_array_ref bit (1) aligned;

	input = o -> operand (1);
	inp = addr (rands (input));

	if inp -> node.node_type ^= temporary_node
	then do;
	     if bt ^= null & inp -> node.node_type = symbol_node & outp_node_type = symbol_node
		& full_strength_reduction
	     then do;

		/* The assignment is of the form i = j.  If both variables
		   could be induction variables, then chain the assignment
		   on ass_chain.  Obviously, if RHS is known to be an
		   induction variable, we can chain directly on incr_chain. */

		if ^outp -> symbol.aliasable & ^substr (lp -> loop.set_multiple -> bits, outp -> symbol.coordinate, 1)
		then if substr (lp -> loop.induction_var -> bits, inp -> symbol.coordinate, 1)
		     then do;
			substr (lp -> loop.induction_var -> bits, outp -> symbol.coordinate, 1) = "1"b;
			call chain_incr (o, stm, incr_chain);
			end;
		     else if ^inp -> symbol.aliasable & substr (lp -> loop.set -> bits, inp -> symbol.coordinate, 1)
			& ^substr (lp -> loop.set_multiple -> bits, inp -> symbol.coordinate, 1)
		     then call chain_incr (o, stm, ass_chain);
		end;

	     return;
	     end;

	/* See if this operation is an incrementing or decrementing of an integer. */

	oexpr = addr (quad (inp -> temporary.output_by));
	op_code = oexpr -> operator.op_code;

	if op_code ^= add_op & op_code ^= sub_op
	then return;

	target = o -> operator.output;

	do i = 1 to 2 while (oexpr -> operand (i) ^= target);
	     end;

	if i > 2
	then return;

	/* we have an optimizable incrementing or decrementing.  Make the new operator. */

	incrp = addr (rands (oexpr -> operand (3 - i)));
	is_temp_or_array_ref = incrp -> node.node_type = array_ref_node | incrp -> node.node_type = temporary_node;

	if op_code = add_op
	then if incrp = onep
	     then do;
		o -> operator.op_code = storage_add_one_op;
		o -> operator.number = 0;
		end;
	     else do;
		o -> operator.op_code = storage_add_op;
		o -> operand (1) = oexpr -> operand (3 - i);
		end;

	else do;
	     o -> operand (1) = oexpr -> operand (3 - i);
	     if i = 1
	     then o -> operator.op_code = neg_storage_add_op;
	     else o -> operator.op_code = storage_sub_op;
	     end;

	/* now adjust ref counts */

	if inp -> temporary.ref_count <= 1
	then do;
	     if outp_node_type = array_ref_node
	     then outp -> array_ref.ref_count = outp -> array_ref.ref_count - 1;

	     call free_operator (oexpr);
	     end;

	else do;
	     call disconnect_temporary (inp, o);
	     if is_temp_or_array_ref
	     then incrp -> temporary.ref_count = incrp -> temporary.ref_count + 1;
	     end;

	/* adjust the input chains */

	if is_temp_or_array_ref
	then call chain_input (incrp, o, 1);

	/* see if this incrementing should go on the incr_chain. */

	if o -> operator.op_code = storage_sub_op | bt = null
	then return;

	/* the target must be a simple integer, set only once in the loop */

	if outp_node_type = array_ref_node
	then return;

	if outp -> symbol.aliasable | substr (lp -> loop.set_multiple -> bits, outp -> symbol.coordinate, 1)
	then return;

	/* the increment must be loop invariant and not an array element */

	if incrp -> node.node_type = array_ref_node
	then return;

	else if incrp -> node.node_type = symbol_node
	then if incrp -> symbol.aliasable | substr (lp -> loop.set -> bits, incrp -> symbol.coordinate, 1)
	     then return;
	     else ;

	else if incrp -> node.node_type = temporary_node
	then if incrp -> temporary.invariant
	     then if addr (quad (incrp -> temporary.output_by)) -> operator.primary -> primary.flow_unit
		     -> flow_unit.loop = lp
		then return;
		else ;
	     else return;

	/* We have found an induction variable, mark and chain it. */

	substr (lp -> loop.induction_var -> bits, outp -> symbol.coordinate, 1) = "1"b;

	call chain_incr (o, stm, incr_chain);

     end check_increment;

process_frozen_for_do:
     procedure (pt);

	/* either sets appropriate bits for temp used to freeze do increment or limit, or replaces it with a symbol */

dcl  (p, pt) pointer;				/* -> temporary with frozen_for_do bit on */

dcl  (assp, s) pointer;
dcl  hash_index fixed binary (18);
dcl  possibly_found bit (1) aligned;

	p = pt;

	/* get ptr to operator producing this temp  (it must be assign_op) */

	assp = addr (quad (p -> temporary.output_by));

	/* if rhs is invariant symbol or constant, then we will replace the temp */

	s = addr (rands (assp -> operand (1)));

	if s -> node.node_type = constant_node
	then do;
	     call replace_lhs_with_rhs;
	     return;
	     end;

	if s -> node.node_type = symbol_node
	then if ^substr (lp -> loop.set -> bits, s -> symbol.coordinate, 1)
	     then if bt ^= null ()
		then if ^substr (bt -> flow_unit.set -> bits, s -> symbol.coordinate, 1)
		     then do;
			call replace_lhs_with_rhs;

			used_invariant_symbol = "1"b;
			all_constant = "0"b;

			return;
			end;

	all_constant, p -> temporary.irreducible, p -> temporary.frozen_for_do = "0"b;

	/* following code should be executed only if we're in a real loop */

	if bt ^= null
	then do;
	     p -> temporary.invariant, p -> temporary.used_across_loops, used_across_loops = "1"b;


	     /* we have to make sure there is a primary for assp so that
	        process_moved_descendants will work */

	     if assp -> operator.primary = null
	     then do;
		hash_index = hash (assp, possibly_found);
		p = create_primary (bt_list_st (hash_index));
		p -> primary.expression = assp;
		p -> primary.flow_unit = bt;
		assp -> operator.primary = p;
		end;
	     end;

replace_lhs_with_rhs:
     procedure ();

	call replace_inputs (addr (polish (p -> temporary.start_input_to)), (assp -> operand (1)));
	call free_operator (assp);

     end replace_lhs_with_rhs;

     end process_frozen_for_do;

     end optimize_flow_unit;

decrement_input_ref_counts:
     procedure (p_o);

	/* decrements input operand ref_counts */

dcl  (i, opnd) fixed binary (18);
dcl  (p_o, o, p) pointer;

	o = p_o;

	do i = 1 to o -> operator.number;
	     opnd = o -> operand (i);
	     if opnd > 0
	     then do;
		p = addr (rands (opnd));
		if p -> node.node_type = temporary_node | p -> node.node_type = array_ref_node
		then p -> temporary.ref_count = p -> temporary.ref_count - 1;
		end;
	     end;

     end decrement_input_ref_counts;

chain_sr_cand:
     procedure (o, i, stm);

	/* adds a new sr_cand to the tail of the sr_chain */

dcl  o pointer,
     i fixed binary (18),
     stm pointer;

dcl  src pointer;

	if free (size (sr_cand)) = null
	then src = get_opt_space (size (sr_cand));
	else do;
	     src = free (size (sr_cand));
	     free (size (sr_cand)) = free (size (sr_cand)) -> sr_cand.next;
	     end;

	src -> sr_cand.operator = o;
	src -> sr_cand.which = i;
	src -> sr_cand.statement = stm;
	src -> sr_cand.next = null;

	if sr_tail = null
	then sr_chain = src;
	else sr_tail -> sr_cand.next = src;

	sr_tail = src;

     end chain_sr_cand;

chain_incr:
     procedure (o, stm, incr_chain);

	/* chain incr node on incr_chain */

dcl  (o, stm, incr_chain) pointer;

dcl  c pointer;

	if free (size (incr)) = null
	then c = get_opt_space (size (incr));
	else do;
	     c = free (size (incr));
	     free (size (incr)) = free (size (incr)) -> incr.next;
	     end;

	c -> incr.value = o;
	c -> incr.statement = stm;
	c -> incr.var_chain = null;
	c -> incr.next = incr_chain;
	incr_chain = c;

     end chain_incr;

replace_inputs:
     procedure (p_inp, p_new_out);

dcl  p_inp pointer;					/* beginning of inputs chain to be processed */
dcl  (new_out, p_new_out) fixed binary (18);		/* operand that replaces present output */

dcl  inp pointer;

	new_out = p_new_out;

	do inp = p_inp repeat inp -> input_to.next while (inp ^= null);
	     if inp -> input_to.which > 0
	     then inp -> input_to.operator -> operator.operand (inp -> input_to.which) = new_out;
	     else if inp -> input_to.which = 0
	     then inp -> input_to.operator -> operator.output = new_out;
	     else inp -> input_to.operator -> lchain.value = new_out;
	     end;

     end replace_inputs;

set:
     procedure (pt);

	/* set is called whenever a variable is seen to be set */

dcl  (p, pt, q, secp) pointer;
dcl  dt fixed binary (4);

	p = pt;
	if p -> node.node_type = array_ref_node
	then p = addr (rands (p -> array_ref.parent));

	if p -> node.node_type = symbol_node
	then do;
	     if ^p -> symbol.aliasable
	     then do;
		secp = p -> symbol.secondary;
		if secp ^= null
		then do;
		     call free_them (secp);
		     call release_node (secp, s_list, 2);
		     end;
		return;
		end;

	     if p -> symbol.parameter
	     then do;
		dt = p -> symbol.data_type;

		secp = s_list;
		do while (secp ^= null);
		     q = secp -> secondary.symbol;
		     if (q -> symbol.parameter | q -> symbol.in_common) & q -> symbol.data_type = dt
		     then call free_secondary (secp);
		     else secp = secp -> secondary.next;
		     end;

		return;
		end;

	     if ^p -> symbol.in_equiv_stmnt
	     then do;

		/* must be in common, but not equivalenced */

		dt = p -> symbol.data_type;

		secp = s_list;
		do while (secp ^= null);
		     q = secp -> secondary.symbol;
		     if q = p | (q -> symbol.parameter & q -> symbol.data_type = dt)
		     then call free_secondary (secp);
		     else secp = secp -> secondary.next;
		     end;

		return;
		end;

	     /* must be equivalenced */

	     dt = p -> symbol.data_type;

	     call set_equivalences (p, dt);		/* set our symbol and possible aliases */

	     /* reals and complex vars may be equivalenced together and
	        be defined at the same time */

	     if dt = real_mode
	     then call set_equivalences (p, cmpx_mode);

	     else if dt = cmpx_mode
	     then call set_equivalences (p, real_mode);

	     return;
	     end;

     end set;

set_externals:
     procedure ();

dcl  (s, secp) pointer;

	secp = s_list;
	do while (secp ^= null);
	     s = secp -> secondary.symbol;
	     if s -> symbol.parameter | s -> symbol.in_common
	     then call free_secondary (secp);
	     else secp = secp -> secondary.next;
	     end;

     end set_externals;

set_equivalences:
     procedure (pt, p_dt);

dcl  (pt, p) pointer,				/* points to equivalenced symbol that was set */
     (p_dt, dt) fixed binary (4);			/* data_type of equivalenced symbols to be set */

dcl  (q, secp) pointer;
dcl  (head, off) fixed binary (18);
dcl  delta fixed binary (1);

	p = pt;
	dt = p_dt;
	head = p -> symbol.parent;
	off = p -> symbol.offset;

	delta = fixed (p -> symbol.data_type ^= dt, 1);

	secp = s_list;
	do while (secp ^= null);
	     q = secp -> secondary.symbol;
	     if q -> symbol.aliasable & q -> symbol.data_type = dt
		& ((q -> symbol.parameter & p -> symbol.in_common)
		| (q -> symbol.parent = head & q -> symbol.in_equiv_stmnt
		& (q -> symbol.dimensioned | p -> symbol.dimensioned | abs (q -> symbol.offset - off) <= delta)))
	     then call free_secondary (secp);
	     else secp = secp -> secondary.next;
	     end;

     end set_equivalences;

free_secondary:
     procedure (p_secp);

dcl  (p_secp, secp) pointer;

	secp = p_secp;
	p_secp = secp -> secondary.next;
	call free_them (secp);
	call release_node (secp, s_list, 2);

     end free_secondary;

set_loop_variants:
     procedure (p_lp);

dcl  (lp, p_lp, secp, s) pointer;

	lp = p_lp;
	secp = s_list;
	do while (secp ^= null);
	     s = secp -> secondary.symbol;
	     if substr (lp -> loop.set -> bits, s -> symbol.coordinate, 1)
	     then call free_secondary (secp);
	     else secp = secp -> secondary.next;
	     end;

     end set_loop_variants;

free_them:
     procedure (p_secp);

dcl  (p_secp, secp) pointer;

dcl  (o, outp, p, c, inp, lastc) pointer;
dcl  (j, lvec) fixed binary (18);
dcl  queue (256) pointer unaligned;

	lastc = null;
	secp = p_secp;

	do c = secp -> secondary.primary repeat c -> chain.next while (c ^= null);
	     p = c -> chain.value;
	     if p -> primary.expression ^= null
	     then do;
		o = p -> primary.expression;
		o -> operator.primary = null;
		queue (1) = o;
		j = 0;
		lvec = 1;
		call release_primary (p);

		/* use a queue to avoid recursive walk */

		do while (j ^= lvec);
		     j = j + 1;
		     if j > hbound (queue, 1)
		     then j = 1;

		     o = queue (j);
		     outp = addr (rands (o -> operator.output));

		     if outp -> node.node_type = temporary_node | o -> operator.op_code = opt_subscript_op
		     then if outp -> temporary.start_input_to > 0
			then do inp = addr (polish (outp -> temporary.start_input_to))
				repeat inp -> input_to.next while (inp ^= null);
				o = inp -> input_to.operator;

				if inp -> input_to.which >= 0
						/* must be an operator */
				then if o -> operator.primary ^= null
				     then do;
					p = o -> operator.primary;
					o -> operator.primary = null;

					lvec = lvec + 1;
					if lvec > hbound (queue, 1)
					then lvec = 1;
					if lvec ^= j
					then queue (lvec) = o;
					else call print_message (414, "The set queue", hbound (queue, 1) - bias)
						;

					call release_primary (p);
					end;
				end;
		     end;
		end;
	     lastc = c;
	     end;

	if lastc ^= null
	then do;
	     lastc -> chain.next = free (size (chain));
	     free (size (chain)) = secp -> secondary.primary;
	     end;

     end free_them;

record_secondaries:
     procedure (p_o, p_code);

dcl  (p_o, o) pointer,				/* ptr to operator node whose operands are being recorded */
     (p_code, code) fixed binary (18);			/* setting of code is:
						   -1	record output only
						   0	record all operands
						   +1	record input only	*/

dcl  i fixed binary (18);
dcl  have_opt_subscript bit (1) aligned;

	o = p_o;
	have_opt_subscript = o -> operator.op_code = opt_subscript_op;
	code = p_code;

	if code >= 0
	then do i = 1 to o -> operator.number;
		if ^have_opt_subscript | i ^= 1
		then call record ((o -> operand (i)));
		end;

	if code <= 0
	then if ^have_opt_subscript
	     then do;
		i = o -> operator.output;
		if o -> operator.assigns_constant_to_symbol
		then addr (rands (i)) -> symbol.has_constant_value = "1"b;

		call record (i);
		end;

record:
     procedure (opnd);

dcl  opnd fixed binary (18);

dcl  (s, secp, c) pointer;

	if opnd > 0
	then do;
	     s = addr (rands (opnd));

	     if s -> node.node_type = array_ref_node
	     then s = addr (rands (s -> array_ref.parent));

	     if s -> node.node_type = symbol_node
	     then if s -> symbol.coordinate > 0
		then do;
		     if s -> symbol.secondary = null
		     then do;
			secp = create_o_node (s_list, 2);
			secp -> secondary.symbol = s;
			secp -> secondary.primary = null;
			s -> symbol.secondary = secp;
			end;
		     else secp = s -> symbol.secondary;

		     c = create_chain ();
		     c -> chain.value = o -> operator.primary;
		     c -> chain.next = secp -> secondary.primary;
		     secp -> secondary.primary = c;
		     end;
	     end;

     end record;

     end record_secondaries;

process_jump_label:
     procedure (lab);

dcl  lab fixed binary (18);				/* operand number of label */

dcl  (stm, q, t, new, target_fu, target_lp, c, last, p, pf, target_optr) pointer;
dcl  i fixed binary (18);

	stm = addr (quad (addr (rands (lab)) -> label.statement));
	go to join;

process_jump_target:
     entry (stmnt);

dcl  stmnt fixed binary (18);				/* offset in quad of statement */

	stm = addr (quad (stmnt));

join:
	target_fu = stm -> opt_statement.flow_unit;

	if target_fu -> flow_unit.position > fu -> flow_unit.position & ^stm -> opt_statement.referenced_by_assign
	then if stm -> opt_statement.has_operator_list
	     then call intersection (stm, 2);
	     else do;

		/* this is the first forward jump to the target to be processed, so create an operator list */

		if target_fu -> flow_unit.is_active_operator = null
		then target_fu -> flow_unit.is_active_operator = get_opt_space (size (obits));
		target_optr = target_fu -> flow_unit.is_active_operator;

		t = null;

		do i = 0 to hbound (p_list, 1);
		     do q = p_list (i) repeat q -> primary.next while (q ^= null);
			new = create_o_node (t, 0);
			new -> primary.data = q -> primary.data;
			substr (target_optr -> obits, q -> primary.expression -> operator.coordinate, 1) = "1"b;
			end;
		     end;

		/* if going to an outer loop, stick the bt_list in too */

		if ^need_consolidation_pass & our_depth > target_fu -> flow_unit.loop -> loop.depth
		then do;
		     do i = 0 to hbound (bt_list, 1);
			do q = bt_list (i) repeat q -> primary.next while (q ^= null);
			     new = create_o_node (t, 0);
			     new -> primary.data = q -> primary.data;
			     substr (target_optr -> obits, q -> primary.expression -> operator.coordinate, 1) =
				"1"b;
			     end;
			end;

		     /* Add this target to the chain of targets to be processed when the loop is done.
		        Anything added to bt_list will then be added to the target's operator_list. */

		     target_lp = target_fu -> flow_unit.loop;
		     last = null;
		     pf = lpf -> lp_frame.back;

		     do p = lp -> loop.father repeat p -> loop.father while (last ^= target_lp);
			c = create_chain ();
			c -> chain.value = target_fu;
			c -> chain.next = pf -> lp_frame.first_jump_target;
			pf -> lp_frame.first_jump_target = c;
			pf = pf -> lp_frame.back;
			last = p;
			end;
		     end;

		if t ^= null
		then stm -> opt_statement.operator_list = t;
		stm -> opt_statement.has_operator_list = "1"b;
		end;

     end process_jump_label;

intersection:
     procedure (p_state, p_i);

	/* this routine gets the intersection of the p_list and the primary list attached to the statement node.
	   If i = 2 the statement node list is replaced by the intersection.
	   If i = 1, the primary list p_list is replaced by the  intersection.
	   If i = 3, the primary list p_list is replaced by the union of p_list and the statement node list. */

dcl  (p_state, state, o, p, st_list, t, next_p, obptr) pointer;
dcl  (i, p_i, j) fixed binary (18);
dcl  possibly_found bit (1) aligned;

	state = p_state;
	i = p_i;

	if i = 1 & state -> opt_statement.referenced_by_assign
	then do;
	     call clear ("1"b);
	     return;
	     end;

	if ^state -> opt_statement.has_operator_list
	then return;

	st_list = state -> opt_statement.operator_list;

	obptr = state -> opt_statement.flow_unit -> flow_unit.is_active_operator;

	if i = 1
	then do;
	     do j = 0 to hbound (p_list, 1);
		do p = p_list (j) repeat next_p while (p ^= null);
		     next_p = p -> primary.next;

		     if ^substr (obptr -> obits, p -> primary.expression -> operator.coordinate, 1)
		     then call release_primary (p);

		     end;
		end;

	     return;
	     end;

	p = st_list;

	do while (p ^= null);
	     next_p = p -> primary.next;

	     /* we can use operator.primary to determine if an operator
	        is in the primary list! */

	     if p -> primary.expression -> operator.primary ^= null
	     then go to next;

	     /* this element is not common to both lists */

	     go to case (i);

case (2):
	     substr (obptr -> obits, p -> primary.expression -> operator.coordinate, 1) = "0"b;
	     call release_node (p, st_list, 0);
	     go to end_case;

case (3):
	     o = p -> primary.expression;

	     if ^o -> operator.freed			/* op must not be freed */
	     then do;
		j = hash (o, possibly_found);
		t = create_primary (p_list_st (j));
		t -> primary.data = p -> primary.data;
		o -> operator.primary = t;
		call record_secondaries (o, 0);
		end;

end_case:
next:
	     p = next_p;
	     end;

	if i = 2
	then state -> opt_statement.operator_list = st_list;

     end intersection;

union:
     procedure (fu, p_list_st);

	/* this routine replaces the primary list hanging off the first statement of the given flow unit with the
	   union of that list and the given primary list */

dcl  fu pointer,					/* given flow_unit */
     1 p_list_st (0:10) aligned,			/* given primary list */
       2 p_list pointer unaligned;

dcl  (stm, st_list, p, q, t, obptr) pointer;
dcl  i fixed binary (18);

	stm = addr (quad (fu -> flow_unit.first_statement));
	if stm -> opt_statement.referenced_by_assign
	then return;

	if fu -> flow_unit.is_active_operator = null
	then fu -> flow_unit.is_active_operator = get_opt_space (size (obits));
	obptr = fu -> flow_unit.is_active_operator;

	if stm -> opt_statement.operator_list = null
	then do;
	     st_list = null;
	     do i = 0 to hbound (p_list, 1);
		do q = p_list (i) repeat q -> primary.next while (q ^= null);
		     p = create_o_node (st_list, 0);
		     p -> primary.data = q -> primary.data;
		     substr (obptr -> obits, p -> primary.expression -> operator.coordinate, 1) = "1"b;
		     end;
		end;
	     stm -> opt_statement.operator_list = st_list;
	     end;

	else do;
	     st_list = stm -> opt_statement.operator_list;

	     do i = 0 to hbound (p_list, 1);
		do p = p_list (i) repeat p -> primary.next while (p ^= null);
		     if ^substr (obptr -> obits, p -> primary.expression -> operator.coordinate, 1)
		     then do;
			substr (obptr -> obits, p -> primary.expression -> operator.coordinate, 1) = "1"b;
			t = create_o_node (st_list, 0);
			t -> primary.data = p -> primary.data;
			end;
		     end;
		end;

	     stm -> opt_statement.operator_list = st_list;
	     end;

	stm -> opt_statement.has_operator_list = "1"b;

     end union;

trim_operator_list:
     procedure (stm);

	/* this routine is called after all intersections on a statement have been processed.
	   It releases those primaries not needed for the code generator. */

dcl  stm pointer;					/* -> opt_statement whose operator_list is to be trimmed */

dcl  (p, q, st_list) pointer;
dcl  our_depth fixed binary (18);

	if stm -> opt_statement.operator_list ^= null
	then do;
	     our_depth = lp -> loop.depth;
	     st_list = stm -> opt_statement.operator_list;

	     do p = st_list repeat q while (p ^= null);
		q = p -> primary.next;
		if our_depth > p -> primary.flow_unit -> flow_unit.loop -> loop.depth
		then call release_node (p, st_list, 0);
		end;

	     stm -> opt_statement.operator_list = st_list;
	     end;

     end trim_operator_list;

clear:
     procedure (zero_hash_mask);

	/* this routine releases all primaries on p_list and releases all secondaries.  bt_list is left unchanged. */

dcl  zero_hash_mask bit (1) aligned;
dcl  (p, q) pointer;
dcl  i fixed binary (18);

	do i = 0 to hbound (p_list, 1);
	     do p = p_list (i) repeat q while (p ^= null);
		q = p -> primary.next;
		call release_primary (p);
		end;
	     end;

	if zero_hash_mask
	then hash_mask = "0"b;

	call detach_secondaries ("1"b);

     end clear;

detach_secondaries:
     procedure (p_detach_constant_assignments);

	/* this routine releases all secondaries */

dcl  (detach_constant_assignments, p_detach_constant_assignments) bit (1) aligned;

dcl  (p, q, c, lastc) pointer;

	detach_constant_assignments = p_detach_constant_assignments;

	do p = s_list repeat q while (p ^= null);
	     q = p -> secondary.next;

	     if detach_constant_assignments | ^p -> secondary.symbol -> symbol.has_constant_value
	     then do;
		lastc = null;
		do c = p -> secondary.primary repeat c -> chain.next while (c ^= null);
		     lastc = c;
		     end;

		if lastc ^= null
		then do;
		     lastc -> chain.next = free (size (chain));
		     free (size (chain)) = p -> secondary.primary;
		     end;

		call release_node (p, s_list, 2);
		end;
	     end;

	/* put free primaries on the free list.  It is safe to do this because no more secondaries exist
	   that point to the free primaries.	*/

	if freep_tail ^= null
	then do;
	     freep_tail -> primary.next = free (size (primary));
	     free (size (primary)) = freep;
	     freep_tail, freep = null;
	     end;

     end detach_secondaries;

release_node:
     procedure (pt, list_head, i);

	/* these routines are utility routines to create and free nodes.   i = 0 for statement list primary nodes.
	   i = 1 for p_list or bt_list primary nodes (no longer implemented here).  i = 2 for secondary nodes.  */

dcl  (p, pt, list_head) pointer;
dcl  i fixed binary (18);

	p = pt;

	if p -> primary.next ^= null
	then p -> primary.next -> primary.last = p -> primary.last;
	if p -> primary.last = null
	then list_head = p -> primary.next;
	else p -> primary.last -> primary.next = p -> primary.next;

	if i = 2					/* secondary node */
	then do;
	     p -> secondary.symbol -> symbol.secondary = null;
	     p -> secondary.symbol -> symbol.has_constant_value = "0"b;
	     end;

	p -> primary.next = free (size (primary));
	free (size (primary)) = p;

	p -> primary.last = null;

     end release_node;

create_o_node:
     procedure (list_head, i) returns (pointer);

dcl  (list_head, p) pointer;
dcl  i fixed binary (18);

	if free (size (primary)) = null
	then p = get_opt_space (size (primary));
	else do;
	     p = free (size (primary));
	     free (size (primary)) = free (size (primary)) -> primary.next;
	     end;

	p -> primary.last = null;
	p -> primary.next = list_head;
	if list_head ^= null
	then list_head -> primary.last = p;
	list_head = p;
	return (p);

     end create_o_node;

release_primary:
     procedure (pt);

	/* these routines are utility routines to create and free primary nodes for the hash lists:
	   p_list & bt_list.  They take advantage of the fact that primary.next is the first
	   word of the primary node. */

dcl  (p, pt, o) pointer;

	p = pt;

	if p -> primary.next ^= null
	then p -> primary.next -> primary.last = p -> primary.last;
	p -> primary.last -> primary.next = p -> primary.next;

	if freep = null
	then freep_tail = p;

	o = p -> primary.expression;
	o -> operator.primary = null;
	if o -> operator.assigns_constant_to_symbol
	then addr (rands (o -> operator.output)) -> symbol.has_constant_value = "0"b;

	p -> primary.expression = null;
	p -> primary.next = freep;
	freep = p;

	p -> primary.last = null;

     end release_primary;

create_primary:
     procedure (list_head_st) returns (pointer);

dcl  1 list_head_st aligned,
       2 list_head pointer unaligned;

dcl  p pointer;

	if free (size (primary)) = null
	then p = get_opt_space (size (primary));
	else do;
	     p = free (size (primary));
	     free (size (primary)) = free (size (primary)) -> primary.next;
	     end;

	p -> primary.last = addr (list_head);
	p -> primary.next = list_head;
	if list_head ^= null
	then list_head -> primary.last = p;
	list_head = p;

	return (p);

     end create_primary;

hash:
     procedure (p_o, possibly_found) returns (fixed binary (18)) irreducible;

	/* function to provide a hash_index for an operator to speed up searching of
	   a primary list */

dcl  (o, p_o) pointer,				/* operator for which hash function
						   is calculated (input) */
     possibly_found bit (1) aligned;			/* "1"b if hash_mask is ON for this
						   operator (output) */

dcl  mod_2_sum fixed binary (34);
dcl  (i, hash_mask_index) fixed binary (18);

	o = p_o;

	mod_2_sum = o -> operator.op_code;
	do i = 1 to o -> operator.number;
	     mod_2_sum = mod_2_sum + o -> operand (i);
	     end;

	hash_mask_index = mod (mod_2_sum, length (hash_mask));

	possibly_found = substr (hash_mask, hash_mask_index + 1, 1);
	substr (hash_mask, hash_mask_index + 1, 1) = "1"b;

	return (mod (mod_2_sum, dim (p_list, 1)));

     end hash;

move:
     procedure (p_o, p_stm, p_fu, p_bt);

dcl  (o, p_o) pointer,				/* -> operator to be moved */
     (stm, p_stm) pointer,				/* -> stm from which o is moved */
     (fu, p_fu) pointer,				/* -> flow_unit from which o is moved */
     (bt, p_bt) pointer;				/* -> flow_unit to which o is moved (back_target) */

dcl  (c, i, opnd, op, outp_node_type, op_code) fixed binary (18);
dcl  (o_before, o_after, p, outp) pointer;

	o = p_o;
	stm = p_stm;
	fu = p_fu;
	bt = p_bt;

	if unspec (addr (quad (bt -> flow_unit.insert_statement)) -> opt_statement.source_id)
	     ^= unspec (stm -> opt_statement.source_id)
	then call insert_stm_in_back_target (bt, stm);

	call unthread (o);

	/* insert o (op) in the back target */

	o_before = addr (quad (bt -> flow_unit.insert_operator));
	o_after = addr (quad (o_before -> operator.next));
	o -> operator.back = bt -> flow_unit.insert_operator;
	o -> operator.next = o_before -> operator.next;
	op = fixed (rel (o), 18);
	o_before -> operator.next = op;
	o_after -> operator.back = op;
	bt -> flow_unit.insert_operator = op;

	/* change bit vectors that are referenced later */

	op_code = o -> operator.op_code;
	p, outp = addr (rands (o -> operator.output));
	outp_node_type = outp -> node.node_type;

	if outp_node_type = array_ref_node
	then if op_code ^= opt_subscript_op
	     then p = addr (rands (p -> array_ref.parent));

	if p -> node.node_type = symbol_node
	then do;
	     c = p -> symbol.coordinate;
	     if ^substr (bt -> flow_unit.set -> bits, c, 1)
	     then substr (bt -> flow_unit.set -> bits, c, 1) = "1"b;
	     else substr (bt -> flow_unit.set_multiple -> bits, c, 1) = "1"b;
	     substr (lp -> loop.set -> bits, c, 1) = "0"b;
	     substr (fu -> flow_unit.set -> bits, c, 1) = "0"b;
	     substr (bt -> flow_unit.busy_on_exit -> bits, c, 1) =
		substr (fu -> flow_unit.busy_on_exit -> bits, c, 1) | substr (fu -> flow_unit.used -> bits, c, 1);
	     end;

	do i = 1 to o -> operator.number;
	     opnd = o -> operand (i);
	     if opnd > 0
	     then do;
		p = addr (rands (opnd));

		if p -> node.node_type = symbol_node & (i ^= 1 | op_code ^= opt_subscript_op)
		     & p -> symbol.coordinate > 0
		then do;
		     c = p -> symbol.coordinate;
		     substr (bt -> flow_unit.used -> bits, c, 1) = "1"b;
		     end;

		else if p -> node.node_type = array_ref_node
		then do;
		     p = addr (rands (p -> array_ref.parent));
		     c = p -> symbol.coordinate;
		     substr (bt -> flow_unit.used -> bits, c, 1) = "1"b;
		     end;
		end;
	     end;

	/* show that this operator is invariant and was used across loops */

	if outp_node_type = temporary_node | op_code = opt_subscript_op
	then do;
	     outp -> temporary.invariant = "1"b;
	     outp -> temporary.used_across_loops = "1"b;
	     end;

     end move;

insert_stm_in_back_target:
     procedure (bt, stm);

dcl  bt pointer,					/* -> back target where new statement is to be inserted */
     stm pointer;					/* -> stm from which the statement_id is copied */

dcl  new_statement fixed binary (18);
dcl  (new_stm, first_stm) pointer;

	/* make a statement that indicates "moved" code */

	new_statement = insert_statement_after ((bt -> flow_unit.insert_statement));
	new_stm = addr (quad (new_statement));

	if unspec (new_stm -> opt_statement.source_id) ^= unspec (stm -> opt_statement.source_id)
	then do;
	     new_stm -> opt_statement.moved = "1"b;
	     unspec (new_stm -> opt_statement.source_id) = unspec (stm -> opt_statement.source_id);
	     end;
	else new_stm -> opt_statement.moved = stm -> opt_statement.moved;

	if bt -> flow_unit.falls_through
	then bt -> flow_unit.last_statement = new_statement;
	else if bt -> flow_unit.first_statement = bt -> flow_unit.last_statement
	then do;
	     first_stm = addr (quad (bt -> flow_unit.first_statement));
	     bt -> flow_unit.first_statement = new_statement;
	     new_stm -> opt_statement.flow_unit = bt;
	     new_stm -> opt_statement.has_operator_list = first_stm -> opt_statement.has_operator_list;
	     first_stm -> opt_statement.has_operator_list = "0"b;
	     new_stm -> opt_statement.operator_list = first_stm -> opt_statement.operator_list;
	     first_stm -> opt_statement.operator_list = null;
	     if first_stm -> opt_statement.label ^= 0
	     then do;
		new_stm -> opt_statement.label = first_stm -> opt_statement.label;
		addr (rands (first_stm -> opt_statement.label)) -> label.statement = new_statement;
		first_stm -> opt_statement.label = 0;
		new_stm -> opt_statement.referenced_backwards = first_stm -> opt_statement.referenced_backwards;
		first_stm -> opt_statement.referenced_backwards = "0"b;
		new_stm -> opt_statement.referenced_by_assign = first_stm -> opt_statement.referenced_by_assign;
		first_stm -> opt_statement.referenced_by_assign = "0"b;
		end;
	     end;

	bt -> flow_unit.insert_statement = new_statement;
	bt -> flow_unit.insert_operator = new_statement;

     end insert_stm_in_back_target;

free_operator:
     procedure (p_o);

	/* frees an operator node and its associated output.  The operator may NOT
	   be reused because of potential references to it by input_to nodes, but its output may be reused. */

dcl  (o, p_o) pointer;				/* -> operator node */

dcl  (t, pr) pointer;
dcl  temp fixed binary (18);

	o = p_o;

	/* if the operator still has a primary, release it. */

	if o -> operator.primary ^= null
	then do;
	     pr = o -> operator.primary;
	     call release_primary (pr);
	     end;

	/* free the output if it is a temp or the operator is opt_subscript.
	   Note that temps & array_refs are the same size and that array_refs
	   will not be "created" after fort_converter. */

	temp = o -> operator.output;
	if temp > 0
	then do;
	     t = addr (rands (temp));

	     if t -> node.node_type = temporary_node | o -> operator.op_code = opt_subscript_op
	     then do;
		t -> temporary.next = next_free_temp;
		next_free_temp = temp;
		end;

	     else if t -> node.node_type = array_ref_node
	     then call disconnect_temporary (t, o);
	     end;

	/* mark the operator so it will be obvious that it has been freed */

	o -> operator.output = 0;
	o -> operator.freed = "1"b;

	/* unthread the operator */

	call unthread (o);

     end free_operator;

process_moved_descendants:
     procedure (p_o, fu);

	/* This routine ensures that expressions that have been moved out of a loop or commoned with expressions
	   outside a loop stay active throughout the loop.  The reference count of each such expression is
	   incremented by one and it is hung off a loop_end_chain which appears at the end of the loop.
	   This routine also refines the used strings.	*/

dcl  (o, p_o) pointer;				/* -> operator whose descendants are used across loops
						   or are invariant symbols */
dcl  fu pointer;					/* -> flow_unit being processed */

dcl  (i, c, opnd, op_code) fixed binary (18);
dcl  (outp, p) pointer;

	o = p_o;
	op_code = o -> operator.op_code;

	opnd = o -> operator.output;
	if opnd > 0
	then do;
	     outp = addr (rands (opnd));
	     if outp -> node.node_type = array_ref_node & op_code ^= opt_subscript_op
	     then if outp -> array_ref.used_across_loops
		then call put_in_a_loop_end (outp);
	     end;

	do i = 1 to o -> operator.number;
	     opnd = o -> operand (i);
	     if opnd > 0
	     then do;
		p = addr (rands (opnd));

		if p -> node.node_type = temporary_node
		then if p -> temporary.used_across_loops
		     then call put_in_a_loop_end (p);
		     else ;

		else do;
		     if p -> node.node_type = array_ref_node
		     then do;
			if p -> array_ref.used_across_loops
			then call put_in_a_loop_end (p);
			p = addr (rands (p -> array_ref.parent));
			end;

		     if used_invariant_symbol
			& (p -> node.node_type = symbol_node & (i ^= 1 | op_code ^= opt_subscript_op))
		     then do;
			c = p -> symbol.coordinate;
			if c ^= 0
			then do;
			     substr (lp -> loop.used -> bits, c, 1) = "1"b;
			     substr (fu -> flow_unit.used -> bits, c, 1) = "1"b;
			     end;
			end;
		     end;
		end;
	     end;

put_in_a_loop_end:
     procedure (pt);

dcl  (p, pt, lp_evaluated, lp_to_put, q) pointer;
dcl  max_fu_pos fixed binary (18);

	p = pt;

	/* figure out in which containing loop's end chain this temp or array_ref should go.
	   This is complicated by the possibility of extended range loops.  We therefore find
	   the loop whose last statement is furthest down in the program. */

	lp_evaluated =
	     addr (quad (p -> temporary.output_by)) -> operator.primary -> primary.flow_unit -> flow_unit.loop;
	max_fu_pos = 0;

	do q = lp repeat q -> loop.father
	     while (^substr (lp_evaluated -> loop.ancestors_and_me -> lbits, q -> loop.number, 1));
	     if q -> loop.last_unit -> flow_unit.position > max_fu_pos
	     then do;
		max_fu_pos = q -> loop.last_unit -> flow_unit.position;
		lp_to_put = q;
		end;
	     end;

	/* unless this operand is in a loop end chain after this one, stich it in */

	if max_fu_pos > p -> temporary.loop_end_fu_pos
	then call put_in_loop_end (p, lp_to_put);

	p -> temporary.used_across_loops = "0"b;

     end put_in_a_loop_end;

     end process_moved_descendants;

constant_expression:
     procedure (p_o) returns (bit (1) aligned);

	/* this routine attempts to fold constant expressions */

dcl  (o, p_o) pointer;				/* ptr to operator with possible constant operands */

dcl  (
     p (2),
     inp,
     outp,
     q,
     start_inp
     ) pointer;
dcl  (opnd, i, op_code) fixed binary (18);

dcl  data_type (2) fixed bin (4);
dcl  max_data_type fixed bin (4);
dcl  result bit (72) aligned;
dcl  source (2) bit (72);

dcl  01 source_as_int (2) based (addr (source)),
       02 int_source fixed bin (18),
       02 pad bit (36);

dcl  error_condition char (16),
     literal_expression char (33 + 4 + 33) varying,
     literal_operand char (33) varying,
     literal_operator (2:13) char (4) varying static options (constant)
	init ("+", "-", "*", "/", "**", "-", ".lt.", ".le.", ".eq.", ".ne.", ".ge.", ".gt.");

dcl  error condition,
     fixedoverflow condition,
     overflow condition,
     size condition,
     underflow condition,
     zerodivide condition;

	/* initialize */

	o = p_o;

	/* make sure operands fit in our arrays */

	if o -> operator.number > hbound (p, 1)
	then return ("0"b);

	outp = addr (rands (o -> operator.output));

	/* see if all operands are constant and collect their values */

	do i = 1 to o -> operator.number;
	     opnd = o -> operand (i);
	     if opnd > 0
	     then do;
		p (i) = addr (rands (opnd));

		if p (i) -> node.node_type = constant_node
		then do;
		     data_type (i) = p (i) -> constant.data_type;
		     source (i) = p (i) -> constant.value;
		     end;

		else return ("0"b);
		end;
	     end;

	/*  Catch arithmetic errors in the folding.  */

	on error goto error_condition_detected;
	on fixedoverflow goto fixedoverflow_condition_detected;
	on overflow goto overflow_condition_detected;
	on size goto size_condition_detected;
	on underflow goto underflow_condition_detected;
	on zerodivide goto zerodivide_condition_detected;

	op_code = o -> operator.op_code;

	/* dispatch on op_code */

	go to case (op_code);

case (1):						/* assign  - handled by constant_assign */
case (14):					/* or */
case (15):					/* and */
case (16):					/* not */
case (17):					/* jump */
case (18):					/* jump_logical */
case (19):					/* jump_arithmetic */
case (20):					/* jump_computed */
case (21):					/* jump_assigned */
case (22):					/* assign_label */
case (23):					/* read */
case (24):					/* write */
case (25):					/* format */
case (26):					/* end_label */
case (27):					/* error_label */
case (28):					/* xmit_scalar */
case (29):					/* xmit_array */
case (30):					/* xmit_vector */
case (31):					/* endfile */
case (32):					/* rewind */
case (33):					/* backspace */
case (34):					/* margin */
case (35):					/* openfile */
case (36):					/* closefile */
case (37):					/* record_number */
case (38):					/* string */
case (39):					/* string_length */
case (40):					/* terminate */
case (41):					/* return */
case (42):					/* pause */
case (43):					/* stop */
case (44):					/* item */
case (45):					/* exit */
case (46):					/* eol */
case (47):					/* do */
case (48):					/* builtin */
case (49):					/* sf */
case (50):					/* sf_def */
case (51):					/* subscript */
case (52):					/* func_ref */
case (53):					/* block_data */
case (54):					/* increment_polish */
case (55):					/* main */
case (56):					/* func */
case (57):					/* subr */
case (58):					/* stat */
case (59):					/* label */
case (60):					/* call */
case (61):					/* chain */
case (62):					/* endunit */
case (63):					/* non_executable */
case (64):					/* no */
case (65):					/* indirect_scan */
case (66):					/* opt_subscript */
case (67):					/* left_shift */
case (68):					/* right_shift */
case (69):					/* store_zero */
case (70):					/* storage_add */
case (71):					/* storage_sub */
case (72):					/* neg_storage_add */
case (73):					/* storage_add_one */
case (74):					/* namelist */
case (75):					/* open */
case (76):					/* close */
case (77):					/* iostat */
case (82):					/* read_scalar */
case (83):					/* read_array */
case (84):					/* read_vector */
case (85):					/* write_scalar */
case (86):					/* write_array */
case (87):					/* write_vector */
case (88):					/* jump_true */
case (89):					/* jump_false */
case (91):					/* loop_end */
case (92):					/* read_namelist */
case (93):					/* write_namelist */
case (94):					/* decode_string */
case (95):					/* encode_string */
case (96):					/* cat */
case (97):					/* substr */
case (98):					/* load_xreg */
case (99):					/* load_preg */
case (100):					/* block_if */
case (101):					/* else_if */
case (102):					/* else */
case (103):					/* equiv */
case (104):					/* not_equiv */
case (105):					/* read_internal_file */
case (106):					/* write_internal_file */
case (107):					/* inquire */
case (108):					/* process_param_list */
	return ("0"b);


case (2):						/* add */
case (3):						/* sub */
case (4):						/* mult */
case (5):						/* div */
case (6):						/* exponentiation */
	max_data_type = max (data_type (1), data_type (2));
	if data_type (1) ^= max_data_type
	then source (1) = conv_round (max_data_type, data_type (1)) (source (1), 0);
	else if data_type (2) ^= max_data_type
	then source (2) = conv_round (max_data_type, data_type (2)) (source (2), 0);
	result = binop_round (max_data_type, max_data_type) (op_code - 1, source (1), source (2), 0);
	goto join;

case (7):						/* negate */
	result = negate_round (data_type (1)) (op_code - 1, source (1), ""b, 0);
	goto join;

case (8):						/* less */
case (9):						/* less_or_equal */
case (10):					/* equal */
case (11):					/* not_equal */
case (12):					/* greater_or_equal */
case (13):					/* greater */
	result = comp_parm (data_type (1), data_type (2)) ((op_code), source (1), source (2), 0);
	goto join;

case (78):					/* convert_to_int */
case (79):					/* convert_to_real */
case (80):					/* convert_to_dp */
case (81):					/* convert_to_cmpx */
	result = conv_round (op_code - 77, data_type (1)) (source (1), 0);
	goto join;

case (90):					/* sub_index */
						/* ** If the sub_index is used as the variable offset of an
						   opt_subscript operator, then combine the variable offset which
						   happens to be constant and the real constant offset.  If the
						   sub_index is used for a length (for a substring reference or
						   concatenation operator) simply replace the output of the
						   sub_index with the constant.
						   ** */
	opnd = create_integer_constant (int_source (1));

	start_inp = addr (polish (outp -> temporary.start_input_to));

	do inp = start_inp repeat inp -> input_to.next while (inp ^= null);
	     q = inp -> input_to.operator;
	     if inp -> input_to.which > 0
	     then do;
		if q -> operator.op_code = opt_subscript_op & inp -> input_to.which = 3
		then do;
		     unspec (i) = addr (rands (q -> operator.operand (2))) -> constant.value;
(size):
		     q -> operator.operand (2) = create_integer_constant (i + int_source (1));
		     q -> operator.operand (3) = 0;
		     end;
		else q -> operand (inp -> input_to.which) = opnd;
		end;
	     else q -> lchain.value = o -> operand (1);
	     end;

	go to done;

join:
	opnd = create_constant ((outp -> temporary.data_type), result);

	start_inp = addr (polish (outp -> temporary.start_input_to));

	call replace_inputs (start_inp, opnd);

done:						/* free the input chain */
	addr (polish (outp -> temporary.end_input_to)) -> input_to.next = freei;
	freei = start_inp;

	/* free the operator */

	call free_operator (o);

	return ("1"b);


	/*  An arithmetic error occurred during folding.  Set 'literal_expression'   */
	/*  to the literal form of the constant expression that was being folded,    */
	/*  then issue an error message indicating the error and showing the value   */
	/*  of 'literal_expression'.  Return 'false' to the caller to indicate that  */
	/*  the expression was not folded.                                           */

arithmetic_error_detected:
	if o -> operator.number = 2
	then do;					/*  Synthesize binary expression.  */
	     literal_operand = literal_value (p (1) -> constant.data_type, p (1) -> constant.value);
	     if substr (literal_operand, 1, 1) = "-"
	     then do;
		literal_expression = "(";
		literal_expression = literal_expression || literal_operand;
		literal_expression = literal_expression || ")";
		end;
	     else literal_expression = literal_operand;
	     if op_code >= lbound (literal_operator, 1) & op_code <= hbound (literal_operator, 1)
	     then literal_expression = literal_expression || literal_operator (op_code);
	     else literal_expression = literal_expression || "?";
	     literal_operand = literal_value (p (2) -> constant.data_type, p (2) -> constant.value);
	     if substr (literal_operand, 1, 1) = "-"
	     then do;
		literal_expression = literal_expression || "(";
		literal_expression = literal_expression || literal_operand;
		literal_expression = literal_expression || ")";
		end;
	     else literal_expression = literal_expression || literal_operand;
	     end;
	else if op_code = negate_op
	then do;
	     literal_expression = "-";
	     literal_operand = literal_value (p (1) -> constant.data_type, p (1) -> constant.value);
	     if substr (literal_operand, 1, 1) = "-"
	     then do;
		literal_expression = literal_expression || "(";
		literal_expression = literal_expression || literal_operand;
		literal_expression = literal_expression || ")";
		end;
	     else literal_expression = literal_expression || literal_operand;
	     end;
	else if op_code = convert_to_int_op
	then do;
	     literal_expression = "int(";
	     literal_expression =
		literal_expression || literal_value (p (1) -> constant.data_type, p (1) -> constant.value);
	     literal_expression = literal_expression || ")";
	     end;
	else if op_code = convert_to_real_op
	then do;
	     literal_expression = "real(";
	     literal_expression =
		literal_expression || literal_value (p (1) -> constant.data_type, p (1) -> constant.value);
	     literal_expression = literal_expression || ")";
	     end;
	else if op_code = convert_to_dp_op
	then do;
	     literal_expression = "dble(";
	     literal_expression =
		literal_expression || literal_value (p (1) -> constant.data_type, p (1) -> constant.value);
	     literal_expression = literal_expression || ")";
	     end;
	else if op_code = convert_to_cmpx_op
	then do;
	     literal_expression = "cmplx(";
	     literal_expression =
		literal_expression || literal_value (p (1) -> constant.data_type, p (1) -> constant.value);
	     literal_expression = literal_expression || ")";
	     end;
	else if op_code = sub_index_op
	then do;
	     literal_expression = literal_value ((int_mode), unspec (i));
	     literal_expression = literal_expression || "+";
	     literal_expression = literal_value ((int_mode), unspec (int_source (1)));
	     end;
	else literal_expression = "?";
	call print_message (174, error_condition, "constant expression: " || literal_expression);
	return ("0"b);

error_condition_detected:
	error_condition = "error";
	goto arithmetic_error_detected;

fixedoverflow_condition_detected:
	error_condition = "fixedoverflow";
	goto arithmetic_error_detected;

overflow_condition_detected:
	error_condition = "overflow";
	goto arithmetic_error_detected;

size_condition_detected:
	error_condition = "size";
	goto arithmetic_error_detected;

underflow_condition_detected:
	error_condition = "underflow";
	goto arithmetic_error_detected;

zerodivide_condition_detected:
	error_condition = "zerodivide";
	goto arithmetic_error_detected;

literal_value:
     proc (data_type, bit_value) recursive returns (char (35) varying);

	/*  Function:  to return the literal value of a FORTRAN numeric datum.       */

	/*  Arguments:                                                               */
	/*                                                                           */
	/*  data_type  (Input)                                                       */
	/*     is the type of the datum:  'int_mode', 'real_mode', 'dp_mode' or      */
	/*     'cmpx_mode'.                                                          */
	/*                                                                           */
	/*  bit_value  (Input)                                                       */
	/*     is the bit string representing the value of the datum.                */

	/*  Notes:                                                                   */
	/*                                                                           */
	/*  (1) The result is set to "?" if an invalid data type is specified.       */

dcl  data_type fixed bin (4) unsigned unaligned,
     bit_value bit (72) aligned;

dcl  assign_ entry (ptr, fixed bin, fixed bin (35), ptr, fixed bin, fixed bin (35));

dcl  imag builtin,
     real builtin;

dcl  Packed fixed bin (1) static options (constant) init (1),
     Unpacked fixed bin (1) static options (constant) init (0);

dcl  descriptor_type fixed bin,
     dp_picture pic "-9v.999999999999999999es999",
     idx_of_e fixed bin,
     int_value fixed bin (35),
     real_picture pic "-9v.99999999es999",
     result char (35) varying;
%include std_descriptor_types;


	if data_type = cmpx_mode
	then do;
	     result = "(";
	     result = result || literal_value ((real_mode), substr (bit_value, 1, 36));
	     result = result || ",";
	     result = result || literal_value ((real_mode), substr (bit_value, 37, 36));
	     result = result || ")";
	     end;
	else if data_type = dp_mode
	then do;
	     if cs -> subprogram.hfp
	     then descriptor_type = real_flt_hex_2_dtype;
	     else descriptor_type = real_flt_bin_2_dtype;
	     call assign_ (addr (dp_picture), 2 * char_dtype + Packed, length (dp_picture), addr (bit_value),
		2 * descriptor_type + Unpacked, 63);
	     idx_of_e = index (dp_picture, "e");
	     result = rtrim (rtrim (ltrim (substr (dp_picture, 1, idx_of_e - 1)), "0"), ".");
	     result = result || "D";
	     result = result || substr (dp_picture, idx_of_e + 1, 1);
	     result = result || ltrim (substr (dp_picture, idx_of_e + 2, 2), "0");
	     result = result || substr (dp_picture, idx_of_e + 3, 1);
	     end;
	else if data_type = int_mode
	then do;
	     unspec (int_value) = substr (bit_value, 1, 36);
	     result = ltrim (char (int_value));
	     end;
	else if data_type = real_mode
	then do;
	     if cs -> subprogram.hfp
	     then descriptor_type = real_flt_hex_1_dtype;
	     else descriptor_type = real_flt_bin_1_dtype;
	     call assign_ (addr (real_picture), 2 * char_dtype + Packed, length (real_picture), addr (bit_value),
		2 * descriptor_type + Unpacked, 27);
	     idx_of_e = index (real_picture, "e");
	     result = rtrim (rtrim (ltrim (substr (real_picture, 1, idx_of_e - 1)), "0"), ".");
	     result = result || "E";
	     result = result || substr (real_picture, idx_of_e + 1, 1);
	     result = result || ltrim (substr (real_picture, idx_of_e + 2, 2), "0");
	     result = result || substr (real_picture, idx_of_e + 3, 1);
	     end;
	else result = "?";
	return (result);
     end literal_value;

     end constant_expression;

constant_assign:
     procedure (p_o) returns (bit (1) aligned);

	/* This routine does special processing for assigments of constants to
	   symbols.  The constant right hand side must be converted to the data type
	   of the left hand side so that subsequent uses of the constant in place of
	   the symbol come out with the right value and the right data type.  If the
	   assign operator passed in does assign a constant to a symbol, "1"b is
	   returned. As there are no typeless constants, there is no code to support
	   data type 7. */

dcl  p_o pointer;					/* Pointer to assign operator */

dcl  (o, inp, outp) pointer;
dcl  (in_dt, out_dt) fixed binary (4);

dcl  target bit (72) aligned;				/* Value of constant */

dcl  char4_target character (4);
dcl  char8_target character (8);


	return ("0"b);				/* Temporarily disable 'constant_assign' to bypass bug 441. */
ignore_this_procedure:
	o = p_o;
	inp = addr (rands (o -> operator.operand (1)));
	outp = addr (rands (o -> operator.output));

	in_dt = inp -> node.data_type;
	out_dt = outp -> node.data_type;

	/* Dispatch on data types of LHS and RHS */

	go to conv (6 * (out_dt - 1) + in_dt);

conv (2):						/* int = real */
conv (3):						/* int = dp */
conv (4):						/* int = cmpx */
conv (7):						/* real = int */
conv (9):						/* real = dp */
conv (10):					/* real = cmpx */
conv (13):					/* dp = int */
conv (14):					/* dp = real */
conv (16):					/* dp = cmpx */
conv (19):					/* cmpx = int */
conv (20):					/* cmpx = real */
conv (21):					/* cmpx = dp */
	target = conv_round (out_dt, in_dt) ((inp -> constant.value), 0);
	goto change_constant;

conv (6):						/* int = char */
conv (12):					/* real = char */
conv (30):					/* logical = char */
	char4_target = inp -> char_constant.value;
	target = unspec (char4_target);
	goto change_constant;

conv (18):					/* dp = char */
conv (24):					/* cmpx = char */
	char8_target = inp -> char_constant.value;
	target = unspec (char8_target);
	goto change_constant;

conv (36):					/* char = char */
	if outp -> node.node_type = symbol_node
	then if outp -> symbol.v_length = 0
	     then do;
		o -> operator.operand (1) =
		     create_char_constant (char (inp -> char_constant.value, outp -> symbol.char_size + 1));
		return ("1"b);
		end;
	return ("0"b);


change_constant:
	o -> operator.operand (1) = create_constant (out_dt, target);


conv (1):						/* int = int */
conv (8):						/* real = real */
conv (15):					/* dp = dp */
conv (22):					/* cmpx = cmpx */
conv (29):					/* logical = logical */
	return (outp -> node.node_type = symbol_node);


conv (5):						/* int = logical */
conv (11):					/* real = logical */
conv (17):					/* dp = logical */
conv (23):					/* cmpx = logical */
conv (25):					/* logical = int */
conv (26):					/* logical = real */
conv (27):					/* logical = dp */
conv (28):					/* logical = cmpx */
conv (31):					/* char = int */
conv (32):					/* char = real */
conv (33):					/* char = dp */
conv (34):					/* char = cmpx */
conv (35):					/* char = logical */
	return ("0"b);

     end constant_assign;

reduce_strength:
     procedure (p_lp);

	/* routine to do strength reduction */

dcl  (lp, p_lp) pointer;				/* loop in which strength reduction is to be done */

dcl  (srp, incrp, src, incrc, cur_frame, cur_o, inp, o, bt, assp, outp, deltap, stm, fu, srvp, p, last, varp, new_incrp,
     q) pointer;
dcl  (i, induction_var, coord, op_code, number, new_increment, delta, which, insert_delta, variable, assignment, j,
     insert_new) fixed binary (18);
dcl  (inc_found, inc_found_before) bit (1) aligned;
dcl  induction_busy_on_exit bit (1) aligned;		/* "1"b -- induction var is busy_on_exit from lp */
dcl  have_test_replacement_candidate bit (1) aligned;
dcl  found_new_induction_variable bit (1) aligned;
dcl  induction_boe_from_bt bit (1) aligned;
dcl  update_insert_operator bit (1) aligned;

dcl  1 sr_frame based aligned,			/* stack frame used in strength reduction */
       2 prev pointer unaligned,
       2 next pointer unaligned,
       2 data structure aligned,
         3 operator pointer unaligned,			/* operator being reduced */
         3 inp pointer unaligned,			/* input to be processed */
         3 delta fixed binary (18),			/* increment to associate with this operator */
         3 init fixed binary (18),			/* last operator used in initializing expression */
         3 variable fixed binary (18),			/* new variable (if nonzero) made for this operator */
         3 ninst fixed binary (18),			/* number of tuples to generate this result */
         3 all_constant bit (1) aligned,		/* ON if all opnds except orig ind var are constant */
         3 which fixed binary (18),			/* which operand was previous operator */
         3 sign bit (1) aligned,			/* sign of the increment */
         3 sign_unknown bit (1) aligned;		/* sign of increment unknown */

	lp = p_lp;
	bt = lp -> loop.back_target;

	inc_found_before, have_test_replacement_candidate = "0"b;

retry:
	found_new_induction_variable = "0"b;

	/* See if we can find additional induction variables updated by stmts
	   of the form i = j. */

	if full_strength_reduction
	then call find_new_induction_vars_on_ass_chain (lp);

	/* loop through the candidates for strength reduction */

	do src = sr_chain repeat src -> sr_cand.next while (src ^= null);
	     srp = src -> sr_cand.operator;
	     which = src -> sr_cand.which;
	     if which = 0
	     then go to step;
	     if srp -> operator.freed
	     then go to step;
	     stm = src -> sr_cand.statement;
	     fu = stm -> opt_statement.flow_unit;

	     induction_var = srp -> operand (which);

	     /* see if this candidate involves a legitimate induction variable */

	     inc_found = "0"b;
	     incrc = incr_chain;

	     do while (incrc ^= null & ^inc_found);
		incrp = incrc -> incr.value;
		if induction_var = incrp -> operator.output
		then inc_found = "1"b;
		else incrc = incrc -> incr.next;
		end;

	     if inc_found
	     then do;

		/* the following code is the main logic of strength reduction.  It will
		   make one or more new induction variables to replace uses of this expression
		   or expressions containing this expression that also involve loop invariants */

		/* remember the busyness_on_exit of this induction variable */

		induction_busy_on_exit =
		     substr (lp -> loop.busy_on_exit -> bits, addr (rands (induction_var)) -> symbol.coordinate, 1);

		induction_boe_from_bt =
		     substr (bt -> flow_unit.busy_on_exit -> bits, addr (rands (induction_var)) -> symbol.coordinate,
		     1);

		if ^inc_found_before
		then do;

		     /* initialize for inserting delta */

		     if ^bt -> flow_unit.falls_through
		     then if bt -> flow_unit.first_statement = bt -> flow_unit.last_statement
			then call insert_stm_in_back_target (bt, stm);
		     insert_delta = bt -> flow_unit.insert_operator;
		     bt -> flow_unit.insert_operator = insert_operator_after (no_op, 0, insert_delta);
		     inc_found_before = "1"b;
		     end;

		/* create an initial frame to represent the induction variable */

		if init_frame ^= null
		then cur_frame = init_frame;
		else init_frame, cur_frame = create_sr_frame (null);

		cur_frame -> sr_frame.all_constant = "1"b;
		cur_frame -> sr_frame.ninst = 0;

		cur_frame -> sr_frame.sign = "0"b;
		cur_frame -> sr_frame.sign_unknown = "0"b;

		if incrp -> operator.op_code = assign_op
		then cur_frame -> sr_frame.delta = 0;

		else if incrp -> operator.op_code = storage_add_one_op
		then cur_frame -> sr_frame.delta = one;

		else do;
		     if incrp -> operator.op_code = neg_storage_add_op
		     then cur_frame -> sr_frame.sign = "1"b;
		     cur_frame -> sr_frame.delta = incrp -> operand (1);
		     end;

		/* build a frame for our candidate */

		call reduce (srp, which);


		/* this set of loops processes all expressions containing our candidate */

		do while (cur_frame ^= init_frame);

		     do while (cur_frame -> sr_frame.inp ^= null);
			inp = cur_frame -> sr_frame.inp;
			cur_frame -> sr_frame.inp = inp -> input_to.next;

			o = inp -> input_to.operator;
			which = inp -> input_to.which;

			if which > 0		/* must be an operator */
			then if ^o -> operator.freed	/* must not have been freed */
			     then if is_reducible (o, which)
				then call reduce (o, which);

				else do;
				     if cur_frame -> sr_frame.variable = 0
				     then do;

					/* we have a non-reducible operator, so, unless an equivalent already
					   exists, we must create and initialize a new induction variable to
					   substitute for the reducible code that has been processed.	*/

					variable = search_for_equivalent (/* cur_frame, incrc */);

					outp = addr (rands (cur_frame -> sr_frame.operator -> operator.output));
					inp = addr (polish (outp -> temporary.start_input_to));

					if variable = 0
					then do;
					     srvp = create_var (lp);

					     variable = srvp -> sr_var.variable;

					     outp -> temporary.start_input_to, outp -> temporary.end_input_to =
						0;

					     if induction_boe_from_bt
					     then do;
						outp -> temporary.ref_count = 1;

						/* build initializing code */

						update_insert_operator =
						     cur_frame -> sr_frame.init
						     = bt -> flow_unit.insert_operator;

						assignment =
						     insert_operator_after (assign_op, 1,
						     (cur_frame -> sr_frame.init));

						if update_insert_operator
						then bt -> flow_unit.insert_operator = assignment;

						assp = addr (quad (assignment));
						assp -> operator.output = variable;
						assp -> operand (1) =
						     cur_frame -> sr_frame.operator -> operator.output;

						call chain_input (outp, assp, 1);
						end;

					     else outp -> temporary.ref_count = 0;

					     /* Note:  following code sets usage and busy_on_exit bits needed by
					        this pass of the optimizer.  Recompute_usage will do a better
					        job for later.	*/

					     varp = addr (rands (variable));
					     coord = varp -> symbol.coordinate;
					     substr (bt -> flow_unit.set -> bits, coord, 1) =
						induction_boe_from_bt;
					     substr (bt -> flow_unit.busy_on_exit -> bits, coord, 1) =
						induction_boe_from_bt;
					     substr (lp -> loop.used -> bits, coord, 1) = "1"b;
					     substr (lp -> loop.set -> bits, coord, 1) = "1"b;
					     substr (lp -> loop.induction_var -> bits, coord, 1) = "1"b;

					     do p = lp -> loop.father repeat p -> loop.father while (p ^= null);
						substr (p -> loop.used -> bits, coord, 1) = "1"b;
						if induction_boe_from_bt
						     | substr (p -> loop.set -> bits, coord, 1)
						then substr (p -> loop.set_multiple -> bits, coord, 1) = "1"b;
						substr (p -> loop.set -> bits, coord, 1) = "1"b;
						end;

					     /* build incrementing or updating code */

					     insert_new = fixed (rel (incrp), 18);
					     delta = cur_frame -> sr_frame.delta;

					     if delta = 0
					     then do;

						/* original induction var not updated by increment */

						number = 1;
						op_code = assign_op;
						delta = incrp -> operand (1);
						last = init_frame;

						do p = init_frame -> sr_frame.next
						     repeat p -> sr_frame.next while (last ^= cur_frame);
						     q = p -> sr_frame.operator;
						     j = p -> sr_frame.which;

						     insert_new =
							insert_operator_after ((q -> operator.op_code), 2,
							(insert_new));

						     call connect_expression (delta, insert_new, j);
						     call connect_expression ((q -> operand (3 - j)),
							insert_new, 3 - j);

						     delta, addr (quad (insert_new)) -> operator.output =
							create_integer_temporary (insert_new);

						     if last = init_frame
						     then call chain_sr_cand (addr (quad (insert_new)), j,
							     (incrc -> incr.statement));

						     last = p;
						     end;
						end;

					     else do;
						number = 1;
						if cur_frame -> sr_frame.sign
						then op_code = neg_storage_add_op;
						else if delta = one
						then do;
						     op_code = storage_add_one_op;
						     number = 0;
						     end;
						else op_code = storage_add_op;
						end;

					     new_increment =
						insert_operator_after (op_code, number, insert_new);

					     new_incrp = addr (quad (new_increment));
					     new_incrp -> operator.output = variable;

					     if number > 0
					     then do;
						call connect_expression (delta, new_increment, 1);

						/* if this is a temp, add to loop end chain */

						if op_code ^= assign_op
						then do;
						     deltap = addr (rands (delta));
						     if deltap -> node.node_type = temporary_node
						     then if deltap -> temporary.loop_end_fu_pos = 0
							then call put_in_loop_end (deltap, lp);
						     end;
						end;

					     /* remember the new induction variable for
					        commoning and test replacement */

					     /* fill in the sr_var node */

					     srvp -> sr_var.next = incrc -> incr.var_chain;
					     incrc -> incr.var_chain = srvp;

					     /* fill in information */

					     srvp -> sr_var.all_constant = cur_frame -> sr_frame.all_constant;
					     srvp -> sr_var.sign_differs =
						init_frame -> sr_frame.sign ^= cur_frame -> sr_frame.sign;
					     srvp -> sr_var.sign_unknown = cur_frame -> sr_frame.sign_unknown;
					     srvp -> sr_var.updated_by = new_incrp;

					     if varp -> symbol.secondary ^= null
					     then do;
						call free_them ((varp -> symbol.secondary));
						call release_node ((varp -> symbol.secondary), s_list, 2);
						end;
					     varp -> symbol.secondary = srvp;

					     srvp -> sr_var.ninst = cur_frame -> sr_frame.ninst;
					     if srvp -> sr_var.ninst <= hbound (srvp -> sr_var.tuple, 1)
					     then do;
						if ^induction_busy_on_exit
						then have_test_replacement_candidate = "1"b;
						p = cur_frame;
						do i = srvp -> sr_var.ninst to 1 by -1;
						     srvp -> sr_var (i).operator = p -> sr_frame.operator;
						     srvp -> sr_var (i).which = p -> sr_frame.which;
						     p = p -> sr_frame.prev;
						     end;
						end;
					     end;

					else do;

					     /* An equivalent variable exists;
					        just free the operator. */

					     cur_o = cur_frame -> sr_frame.operator;
					     if fixed (rel (cur_o), 18) = bt -> flow_unit.insert_operator
					     then bt -> flow_unit.insert_operator = cur_o -> operator.back;

					     call decrement_input_ref_counts (cur_o);
					     call free_operator (cur_o);

					     end;

					call replace_inputs (inp, variable);

					cur_frame -> sr_frame.variable = variable;
					end;

				     if o -> operator.op_code = assign_op
				     then if full_strength_reduction
					then if output_is_new_induction_var (o)
					     then call add_new_induction_var (o);
					     else ;
					else ;

				     else if o -> operator.op_code = sub_index_op
				     then do;

					/* we don't need sub_index since opnd2 is now a variable */

					outp = addr (rands (o -> operator.output));
					inp = addr (polish (outp -> temporary.start_input_to));
					call replace_inputs (inp, cur_frame -> sr_frame.variable);
					call free_operator (o);
					end;
				     end;
			end;

		     cur_o = cur_frame -> sr_frame.operator;
		     if ^cur_o -> operator.freed
		     then do;
			outp = addr (rands (cur_o -> operator.output));

			if ^induction_boe_from_bt
			then do;

			     /* This operator was unthreaded by reduce;
			        finish freeing it now.  If the output has a
			        nonzero ref_count, it had better only be in
			        loop end lists. */

			     call decrement_input_ref_counts (cur_o);

			     if outp -> temporary.ref_count > 0
			     then do;

				/* Walk the input_to list. */

				do inp = addr (polish (outp -> temporary.start_input_to))
				     repeat (inp -> input_to.next) while (inp ^= null ());
				     if inp -> input_to.which >= 0
				     then if ^inp -> input_to.operator -> operator.freed
					then call print_message (391);
						/* Fatal */
					else ;
				     else inp -> input_to.operator -> lchain.value = 0;
				     end;
				end;

			     outp -> temporary.next = next_free_temp;
			     next_free_temp = cur_o -> operator.output;
			     cur_o -> operator.output = 0;
						/* mark as free */
			     cur_o -> operator.freed = "1"b;
			     end;

			else if outp -> temporary.ref_count = 0
			then do;

			     /* The output of this operator was input
			        only to an expression for which there
			        was already an equivalent induction
			        variable. */

			     if fixed (rel (cur_o), 18) = bt -> flow_unit.insert_operator
			     then bt -> flow_unit.insert_operator = cur_o -> operator.back;

			     call decrement_input_ref_counts (cur_o);
			     call free_operator (cur_o);

			     end;
			end;

		     cur_frame = cur_frame -> sr_frame.prev;
		     end;

		/* mark successful candidate */

		src -> sr_cand.which = 0;
		end;

step:
	     end;


	if found_new_induction_variable
	then go to retry;


finish:						/* Do test replacement */
	if have_test_replacement_candidate
	then do;
	     call timer (6);
	     call replace_tests;
	     end;

	/* free the chains */

	last = null;
	do incrc = incr_chain repeat incrc -> incr.next while (incrc ^= null);

	     /* remember which new induction vars were used in this loop and surrounding loops */

	     do srvp = incrc -> incr.var_chain repeat p while (srvp ^= null);
		addr (rands (srvp -> sr_var.variable)) -> symbol.secondary = null;
		i = addr (rands (srvp -> sr_var.variable)) -> symbol.coordinate;
		if substr (lp -> loop.used -> bits, i, 1) | substr (bt -> flow_unit.used -> bits, i, 1)
		then srvp -> sr_var.used_in -> lbits =
			srvp -> sr_var.used_in -> lbits | lp -> loop.ancestors_and_me -> lbits;
		p = srvp -> sr_var.next;
		srvp -> sr_var.next = free_var_list;
		free_var_list = srvp;
		end;

	     incrc -> incr.var_chain = null;
	     last = incrc;
	     end;

	if sr_chain ^= null
	then do;

	     /* do loop end processing for the unsuccessful candidates */

	     do src = sr_chain repeat src -> sr_cand.next while (src ^= null);
		if src -> sr_cand.which ^= 0
		then do;
		     stm = src -> sr_cand.statement;
		     srp = src -> sr_cand.operator;
		     fu = stm -> opt_statement.flow_unit;
		     used_invariant_symbol = "1"b;	/* for safety's sake */
		     call process_moved_descendants (srp, fu);
		     end;
		end;

	     sr_tail -> sr_cand.next = free (size (sr_cand));
	     free (size (sr_cand)) = sr_chain;
	     end;

	if incr_chain ^= null
	then do;
	     last -> incr.next = free (size (incr));
	     free (size (incr)) = incr_chain;
	     end;

	last = null;
	do incrc = ass_chain repeat incrc -> incr.next while (incrc ^= null);
	     last = incrc;
	     end;

	if last ^= null
	then do;
	     last -> incr.next = free (size (incr));
	     free (size (incr)) = ass_chain;
	     end;

	incr_chain, sr_chain, sr_tail, ass_chain = null;

	return;

is_reducible:
     procedure (o, which) returns (bit (1) aligned);

	/* decides if an expression is a candidate for strength reduction */

dcl  o pointer,					/* pts to candidate operator */
     which fixed binary (18);				/* operand number of induction variable */


	if o -> operator.op_code = add_op | o -> operator.op_code = sub_op | o -> operator.op_code = mult_op
	then return (is_invariant ((o -> operand (3 - which))));

	return ("0"b);

     end is_reducible;

is_invariant:
     procedure (opnd) returns (bit (1) aligned);

dcl  opnd fixed binary (18);

dcl  p pointer;

	p = addr (rands (opnd));

	if p -> node.node_type = array_ref_node
	then return ("0"b);

	else if p -> node.node_type = constant_node
	then return ("1"b);

	else if p -> node.node_type = temporary_node
	then return (p -> temporary.invariant);

	else return (^substr (lp -> loop.set -> bits, p -> symbol.coordinate, 1));

     end is_invariant;

reduce:
     procedure (p_o, p_which);

	/* builds an sr_frame to hold info about this operator, moves initializing code to back target, and derives
	   delta for incrementing */

dcl  (o, p_o) pointer,				/* points at operator to be reduced */
     (which, p_which) fixed binary (18);		/* operand number of induction variable */

dcl  (next_frame, outp, deltap, p, p1, p2) pointer;
dcl  i fixed binary (18);
dcl  factor fixed binary (18);
dcl  (cvalue1, cvalue2) fixed binary (18);

	o = p_o;
	which = p_which;

	if induction_boe_from_bt
	then do;

	     /* move this expression to the back target as initialization code.  Turn off bits set by move so
	        as not to confuse optimizer later */

	     call move (o, stm, fu, bt);
	     outp = addr (rands (o -> operator.output));
	     outp -> temporary.invariant, outp -> temporary.used_across_loops = "0"b;
	     end;

	else do;

	     /* Don't need initializaton code, so unthread the operator.  It
	        will be be freed later by reduce_strength when its sr_frame
	        is popped. */

	     call unthread (o);
	     end;

	/* build a new sr_frame */

	if cur_frame -> sr_frame.next ^= null
	then next_frame = cur_frame -> sr_frame.next;
	else next_frame = create_sr_frame (cur_frame);

	next_frame -> sr_frame.operator = o;
	next_frame -> sr_frame.variable = 0;
	next_frame -> sr_frame.which = which;
	next_frame -> sr_frame.inp = addr (polish (addr (rands (o -> operator.output)) -> temporary.start_input_to));
	next_frame -> sr_frame.ninst = cur_frame -> sr_frame.ninst + 1;
	next_frame -> sr_frame.init = bt -> flow_unit.insert_operator;

	p2 = addr (rands (o -> operand (3 - which)));
	next_frame -> sr_frame.all_constant =
	     cur_frame -> sr_frame.all_constant & (p2 -> node.node_type = constant_node);

	/* calculate delta and sign for new frame.  Put operations for delta in back target */

	next_frame -> sr_frame.sign = cur_frame -> sr_frame.sign;
	next_frame -> sr_frame.sign_unknown = cur_frame -> sr_frame.sign_unknown;

	if cur_frame -> sr_frame.delta = 0		/* induction var updated by assignment */
	then next_frame -> sr_frame.delta = 0;

	else if o -> operator.op_code = mult_op
	then do;
	     factor = o -> operand (3 - which);

	     if p2 -> node.node_type ^= constant_node
	     then next_frame -> sr_frame.sign_unknown = "1"b;
	     else do;
		unspec (cvalue2) = p2 -> constant.value;
		if cvalue2 < 0
		then do;
		     factor = create_integer_constant (-cvalue2);
		     p2 = addr (rands (factor));
		     next_frame -> sr_frame.sign = ^next_frame -> sr_frame.sign;
		     end;
		end;

	     if cur_frame -> sr_frame.delta = one
	     then next_frame -> sr_frame.delta = factor;

	     else do;
		p1 = addr (rands (cur_frame -> sr_frame.delta));

		if p1 -> node.node_type = constant_node & p2 -> node.node_type = constant_node
		then do;
		     unspec (cvalue1) = p1 -> constant.value;
		     unspec (cvalue2) = p2 -> constant.value;
		     next_frame -> sr_frame.delta = create_integer_constant (cvalue1 * cvalue2);
		     end;
		else do;
		     insert_delta = insert_operator_after (mult_op, 2, (insert_delta));
		     deltap = addr (quad (insert_delta));
		     next_frame -> sr_frame.delta, deltap -> operator.output =
			create_integer_temporary (insert_delta);

		     call connect_expression ((cur_frame -> sr_frame.delta), insert_delta, which);
		     call connect_expression (factor, insert_delta, 3 - which);

		     /* set appropriate used bits in back target */

		     do i = 1 to 2;
			p = addr (rands (deltap -> operand (i)));
			if p -> node.node_type = symbol_node
			then substr (bt -> flow_unit.used -> bits, p -> symbol.coordinate, 1) = "1"b;
			end;
		     end;
		end;
	     end;

	else do;

	     /* we have + or -, delta is unchanged, but the sign may change if we have c - i */

	     if o -> operator.op_code = sub_op & which = 2
	     then next_frame -> sr_frame.sign = ^next_frame -> sr_frame.sign;

	     next_frame -> sr_frame.delta = cur_frame -> sr_frame.delta;
	     end;

	/* make the new frame our current frame */

	cur_frame = next_frame;

     end reduce;

search_for_equivalent:
     procedure (/* cur_frame, incrc */) returns (fixed binary (18));

	/* searches for new induction variable that would be equivalent to the one we
	   would have to create for this sr_frame */

dcl  (srvp, p, o1, o2) pointer;
dcl  (i, ninst, which) fixed binary (18);
dcl  inequality_found bit (1) aligned;

	ninst = cur_frame -> sr_frame.ninst;
	if ninst <= hbound (srvp -> sr_var.tuple, 1)
	then do srvp = incrc -> incr.var_chain repeat srvp -> sr_var.next while (srvp ^= null);
		if ninst = srvp -> sr_var.ninst
		then do;
		     inequality_found = "0"b;
		     p = cur_frame;
		     do i = ninst to 1 by -1 while (^inequality_found);
			if p -> sr_frame.operator ^= srvp -> sr_var.operator (i)
			then do;
			     inequality_found = "1"b;
			     if p -> sr_frame.which = srvp -> sr_var.which (i)
			     then do;
				which = p -> sr_frame.which;
				o1 = p -> sr_frame.operator;
				o2 = srvp -> sr_var.operator (i);
				if o1 -> operator.op_code = o2 -> operator.op_code
				then if o1 -> operand (3 - which) = o2 -> operand (3 - which)
				     then inequality_found = "0"b;
				end;
			     end;
			p = p -> sr_frame.prev;
			end;

		     if ^inequality_found
		     then return (srvp -> sr_var.variable);
		     end;
		end;

	return (0);

     end search_for_equivalent;

create_sr_frame:
     procedure (last_frame) returns (pointer);

	/* creates strength_reduction frame used by reduce_strength to effect tree
	   search for uses of reducible expression */

dcl  last_frame pointer;				/* points to frame we are to connect to the new one */

dcl  new_frame pointer;

	new_frame = get_opt_space (size (sr_frame));

	new_frame -> sr_frame.next = null;
	new_frame -> sr_frame.prev = last_frame;
	if last_frame ^= null
	then last_frame -> sr_frame.next = new_frame;

	return (new_frame);

     end create_sr_frame;

create_var:
     procedure (lp) returns (pointer);

	/* creates automatic integer variable for use as a strength reduction induction variable */

dcl  lp pointer;

dcl  (var, lp_num) fixed binary (18);
dcl  (p, last, srvp) pointer;

	lp_num = lp -> loop.number;

	/* See if there is already a suitable induction variable.  It must already be used in this loop. */

	last = null;
	do srvp = free_var_list repeat srvp -> sr_var.next while (srvp ^= null);
	     if ^substr (srvp -> sr_var.used_in -> lbits, lp_num, 1)
	     then do;
		if last ^= null
		then last -> sr_var.next = srvp -> sr_var.next;
		else free_var_list = srvp -> sr_var.next;
		return (srvp);
		end;
	     last = srvp;
	     end;

	/* we need a brand new variable */

	srvp = create_sr_var_node ();
	srvp -> sr_var.used_in = get_opt_space (size (lbits));

	/* create and initialize the symbol node */

	var = create_node (symbol_node, size (symbol));
	srvp -> sr_var.variable = var;
	p = addr (rands (var));

	p -> symbol.data_type = int_mode;
	p -> symbol.element_size = data_type_size (int_mode);
	p -> symbol.operand_type = variable_type;
	p -> symbol.by_compiler = "1"b;
	p -> symbol.integer, p -> symbol.automatic = "1"b;
	p -> symbol.new_induction_var = "1"b;

	p -> symbol.secondary = null;

	/* connect the node to the symbol chain */

	addr (rands (cs -> subprogram.last_symbol)) -> symbol.next_symbol = var;
	cs -> subprogram.last_symbol = var;

	/* assign a coordinate to the symbol */

	n_sym = n_sym + 1;
	if n_sym > max_sym
	then do;

	     /* FATAL ERROR because we have already moved code on the assumption of the success of create_var */

	     call print_message (385);
	     return (null);
	     end;

	p -> symbol.coordinate = n_sym;

	substr (integer_scalar_mask, n_sym, 1) = "1"b;

	return (srvp);

     end create_var;

create_sr_var_node:
     procedure () returns (pointer);

dcl  srvp pointer;

	if freesrv = null
	then srvp = get_opt_space (size (sr_var));
	else do;
	     srvp = freesrv;
	     freesrv = freesrv -> sr_var.next;
	     end;

	return (srvp);

     end create_sr_var_node;

output_is_new_induction_var:
     procedure (o) returns (bit (1) aligned);

dcl  o pointer;					/* -> assign op whose output is being examined */

dcl  s pointer;

	/* Since the RHS of o is a new induction variable, if the LHS is a
	   simple integer set only once in the loop, then it too is an inductioon
	   variable. */

	s = addr (rands (o -> operator.output));

	if s -> node.node_type = symbol_node
	then if s -> symbol.data_type = int_mode
	     then if ^s -> symbol.aliasable & ^s -> symbol.new_induction_var
		then if ^substr (lp -> loop.set_multiple -> bits, s -> symbol.coordinate, 1)
		     then return ("1"b);

	return ("0"b);

     end output_is_new_induction_var;

add_new_induction_var:
     procedure (p_o);

dcl  (o, p_o) pointer;				/* -> assignment producing new induction var */

dcl  (left, right, srvp) pointer;

	found_new_induction_variable = "1"b;

	o = p_o;

	left = addr (rands (o -> operator.output));
	right = addr (rands (o -> operator.operand (1)));

	/* we need to mark used bits for right in all flow_units
	   so that used_in_loop will look for us */

	call force_used_in_loop (lp, (right -> symbol.coordinate));

	/* chain incr nodes first for right, then for left */

	srvp = right -> symbol.secondary;
	call chain_incr ((srvp -> sr_var.updated_by), (incrc -> incr.statement), incr_chain);
	call chain_incr (o, stm, incr_chain);

	/* turn on the induction_var bit in lp, so we know about this variable */

	substr (lp -> loop.induction_var -> bits, left -> symbol.coordinate, 1) = "1"b;

     end add_new_induction_var;

find_new_induction_vars_on_ass_chain:
     procedure (p_lp);

dcl  (lp, p_lp) pointer;				/* -> loop node */

dcl  (c, next, prev) pointer;
dcl  (o, left, right) pointer;
dcl  changed bit (1) aligned;

	/* ass_chain chains assignments of the form i = j, where both i and
	   j are simple integers assigned only ince in lp.  If j is an
	   induction variable, then so is i. */

	lp = p_lp;

	changed = "1"b;

	do while (changed);
	     changed = "0"b;
	     prev = null;

	     do c = ass_chain repeat next while (c ^= null);
		next = c -> incr.next;
		o = c -> incr.value;
		left = addr (rands (o -> operator.output));
		right = addr (rands (o -> operand (1)));

		if substr (lp -> loop.induction_var -> bits, right -> symbol.coordinate, 1)
		then do;

		     /* left can now be made an induction variable. */

		     changed = "1"b;
		     substr (lp -> loop.induction_var -> bits, left -> symbol.coordinate, 1) = "1"b;

		     /* Rethread this operation onto incr_chain. */

		     if prev ^= null
		     then prev -> incr.next = c -> incr.next;
		     else ass_chain = c -> incr.next;
		     c -> incr.next = incr_chain;
		     incr_chain = c;
		     end;

		else prev = c;
		end;
	     end;

     end find_new_induction_vars_on_ass_chain;

force_used_in_loop:
     procedure (lp, coord);

	/* forces used bit on in all flow_units and all loops contained in lp */

dcl  lp pointer,
     coord fixed binary (18);

dcl  (adam, p) pointer;
dcl  c fixed binary (18);

	adam = lp;
	c = coord;

	call force_loop (adam);

	if adam -> loop.son = null
	then return;

	/* simulate recursive walk */

	p = adam -> loop.son;

	do while ("1"b);
	     call force_loop (p);

	     if p -> loop.son ^= null
	     then p = p -> loop.son;

	     else do;
		do while (p -> loop.brother = null);
		     p = p -> loop.father;
		     if p = adam
		     then return;
		     end;

		p = p -> loop.brother;
		end;
	     end;

force_loop:
     procedure (lp);

dcl  (lp, fu) pointer;

	substr (lp -> loop.used -> bits, c, 1) = "1"b;

	do fu = lp -> loop.members repeat fu -> flow_unit.next_in_loop while (fu ^= null);
	     substr (fu -> flow_unit.used -> bits, c, 1) = "1"b;
	     end;

     end force_loop;

     end force_used_in_loop;

replace_tests:
     procedure ();

	/* This program attempts to eliminate induction variables that are only used to increment themselves,
	   or are only used to increment themselves and in one end_of_loop test */

dcl  (incrc, incrp, indp, o, fu) pointer;
dcl  (induction_var, n_uses, st_found, which, code) fixed binary (18);

	do incrc = incr_chain repeat incrc -> incr.next while (incrc ^= null);
	     incrp = incrc -> incr.value;
	     induction_var = incrp -> operator.output;
	     indp = addr (rands (induction_var));

	     if incrc -> incr.var_chain ^= null
		& ^substr (lp -> loop.busy_on_exit -> bits, indp -> symbol.coordinate, 1)
	     then do;
		n_uses = used_in_loop (induction_var, lp, o, st_found, fu);

		if n_uses = 0
		then call eliminate_increment;

		else if n_uses = 1
		then do;

		     /* We have a use other than the increment.  It must be as the operand
		        of a relational operator in the test ending an exit flow unit */

		     if substr (lp -> loop.is_exit -> dbits, fu -> flow_unit.number, 1)
			& st_found = fu -> flow_unit.last_statement & o -> operator.op_code >= less_op
			& o -> operator.op_code <= greater_op
		     then do;

			/* see if other operand is a loop constant */

			if o -> operand (1) = induction_var
			then which = 1;
			else which = 2;

			if is_invariant ((o -> operand (3 - which)))
			then do;
			     call change_test (code);
			     if code = 0
			     then call eliminate_increment;
			     end;
			end;
		     end;
		end;
	     end;

change_test:
     procedure (code);

dcl  code fixed binary (18);				/* (output) */

dcl  (srvp, p, invp, q) pointer;
dcl  (min_ninst, invariant_opnd, i, last_temp, input, j) fixed binary (18);
dcl  found_all_constant bit (1) aligned;
dcl  reverse_rel_op (8:13) fixed binary (18) internal static initial (13, 12, 10, 11, 9, 8);

	/* first, we must find a good new induction variable to use */

	found_all_constant = "0"b;
	min_ninst = 1000;
	srvp = null;

	do p = incrc -> incr.var_chain repeat p -> sr_var.next while (p ^= null);
	     if ^p -> sr_var.sign_unknown
		& substr (lp -> loop.used -> bits, addr (rands (p -> sr_var.variable)) -> symbol.coordinate, 1)
	     then if p -> sr_var.all_constant & ^found_all_constant
		then do;
		     found_all_constant = "1"b;
		     min_ninst = p -> sr_var.ninst;
		     srvp = p;
		     end;

		else if p -> sr_var.ninst < min_ninst & p -> sr_var.all_constant = found_all_constant
		then do;
		     min_ninst = p -> sr_var.ninst;
		     srvp = p;
		     end;
	     end;

	if min_ninst > hbound (srvp -> sr_var.tuple, 1)
	then do;

	     /* we can't change the test */

	     code = 1;
	     return;
	     end;

	else code = 0;

	/* srvp now points at the sr_var node we will use.  If the loop invariant
	   is a temporary, disconnect it from this operator */

	invariant_opnd = o -> operand (3 - which);
	invp = addr (rands (invariant_opnd));

	if invp -> node.node_type = temporary_node
	then call disconnect_temporary (invp, o);

	else if invp -> node.node_type = symbol_node
	then substr (bt -> flow_unit.used -> bits, invp -> symbol.coordinate, 1) = "1"b;

	/* build up the new expression that will be tested against */

	do i = 1 to min_ninst;
	     q = srvp -> sr_var.operator (i);
	     j = srvp -> sr_var.which (i);

	     insert_delta = insert_operator_after ((q -> operator.op_code), 2, (insert_delta));

	     if i = 1
	     then input = invariant_opnd;
	     else input = last_temp;

	     call connect_expression (input, insert_delta, j);
	     call connect_expression ((q -> operand (3 - j)), insert_delta, 3 - j);

	     last_temp, addr (quad (insert_delta)) -> operator.output = create_integer_temporary (insert_delta);
	     end;

	call connect_expression (last_temp, fixed (rel (o), 18), 3 - which);
	o -> operand (which) = srvp -> sr_var.variable;

	if srvp -> sr_var.sign_differs
	then o -> operator.op_code = reverse_rel_op (o -> operator.op_code);

	call put_in_loop_end (addr (rands (last_temp)), lp);

	substr (fu -> flow_unit.used -> bits, indp -> symbol.coordinate, 1) = "0"b;
	substr (fu -> flow_unit.used -> bits, addr (rands (srvp -> sr_var.variable)) -> symbol.coordinate, 1) = "1"b;

     end change_test;

eliminate_increment:
     procedure ();

dcl  p pointer;

	/* if the value the induction variable was incremented by was a temporary, disconnect it */

	if incrp -> operator.number > 0
	then do;
	     p = addr (rands (incrp -> operand (1)));
	     if p -> node.node_type = temporary_node
	     then call disconnect_temporary (p, incrp);
	     end;

	/* unthread the operator */

	call unthread (incrp);

	/* update various usage bits */

	substr (lp -> loop.used -> bits, indp -> symbol.coordinate, 1) = "0"b;
	substr (lp -> loop.set -> bits, indp -> symbol.coordinate, 1) = "0"b;
	substr (bt -> flow_unit.busy_on_exit -> bits, indp -> symbol.coordinate, 1) = "0"b;

	/* Can't propagate resetting of busy_on_exit any further since used bit has been turned on in
	   back target by strength reduction. */

     end eliminate_increment;

     end replace_tests;

     end reduce_strength;

used_in_loop:
     procedure (p_induction_var, p_adam, p_o, p_st_found, p_fu) returns (fixed binary (18));

	/* counts non-incremental uses of induction variable in a loop; stops if more than one use found. */

dcl  (induction_var, p_induction_var) fixed binary (18),	/* induction variable (input) */
     (p_adam, adam) pointer,				/* -> loop to be searched (input) */
     p_o pointer,					/* -> operator in which use found (output) */
     p_st_found fixed binary (18),			/* offset of stmt in which use found (output) */
     p_fu pointer;					/* -> flow_unit in which use found (output) */
						/*  returns:
						   0 -- no use found
						   1 -- one use found
						   2 -- many uses found	*/
dcl  (coord, n_uses) fixed binary (18);
dcl  p pointer;
dcl  ind_used bit (1) aligned;

	adam = p_adam;
	induction_var = p_induction_var;
	coord = addr (rands (induction_var)) -> symbol.coordinate;
	n_uses = 0;

	call process_flow_units (adam);

	if n_uses > 1 | adam -> loop.son = null
	then return (n_uses);

	/* simulate recursive tree walk */

	p = adam -> loop.son;

	do while ("1"b);
	     ind_used = substr (p -> loop.used -> bits, coord, 1);

	     if ind_used
	     then do;
		call process_flow_units (p);
		if n_uses > 1
		then return (n_uses);
		end;

	     if ind_used & p -> loop.son ^= null
	     then p = p -> loop.son;

	     else do;
		do while (p -> loop.brother = null);
		     p = p -> loop.father;
		     if p = adam
		     then return (n_uses);
		     end;

		p = p -> loop.brother;
		end;
	     end;

process_flow_units:
     procedure (lp);

dcl  lp pointer;					/* -> loop to be scanned */

dcl  (o, stm, fu) pointer;
dcl  (next_statement, next_unit_statement, op, i) fixed binary (18);

	do fu = lp -> loop.members repeat fu -> flow_unit.next_in_loop while (fu ^= null);
	     if substr (fu -> flow_unit.used -> bits, coord, 1)
	     then do;

		/* turn off used bit util we are sure that the var is used */

		substr (fu -> flow_unit.used -> bits, coord, 1) = "0"b;

		/* loop through the statements */

		if fu -> flow_unit.next ^= null
		then next_unit_statement = fu -> flow_unit.next -> flow_unit.first_statement;
		else next_unit_statement = 0;

		do cur_statement = fu -> flow_unit.first_statement repeat next_statement
		     while (cur_statement ^= next_unit_statement);

		     stm = addr (quad (cur_statement));
		     next_statement = fixed (stm -> opt_statement.next, 18);

		     do op = stm -> opt_statement.first_operator repeat o -> operator.next
			while (op ^= next_statement);

			o = addr (quad (op));

			do i = 1 to o -> operator.number;
			     if o -> operand (i) = induction_var
			     then do;
				n_uses = n_uses + 1;
				substr (fu -> flow_unit.used -> bits, coord, 1) = "1"b;
				if n_uses > 1
				then return;
				p_o = o;
				p_st_found = cur_statement;
				p_fu = fu;
				end;
			     end;

			if o -> operator.op_code = write_namelist_op
			then if in_namelist (o, induction_var)
			     then do;
				n_uses = 2;
				substr (fu -> flow_unit.used -> bits, coord, 1) = "1"b;
				return;
				end;
			end;
		     end;
		end;
	     end;

     end process_flow_units;

     end used_in_loop;

chain_dac:
     procedure (var, fu);

	/* chains dead_assign_cand nodes for later processing */

dcl  var fixed binary (18),				/* variable to be removed later */
     fu pointer;					/* -> flow_unit from which var shd be removed */

dcl  p pointer;

	p = create_da_node ();
	p -> dead_assign_cand.next = da_chain;
	da_chain = p;
	p -> dead_assign_cand.variable = var;
	p -> dead_assign_cand.flow_unit = fu;

     end chain_dac;

create_da_node:
     procedure () returns (pointer);

dcl  p pointer;

	if free (size (dead_assign_cand)) = null
	then p = get_opt_space (size (dead_assign_cand));
	else do;
	     p = free (size (dead_assign_cand));
	     free (size (dead_assign_cand)) = free (size (dead_assign_cand)) -> dead_assign_cand.next;
	     end;

	return (p);

     end create_da_node;

remove_dead_assignments:
     procedure ();

	/* This routine removes assignments made dead by the combination of strength reduction, test replacement, and
	   constant propagation. */

dcl  (dac, fu, last, o, varp) pointer;
dcl  (back, c, first_statement, i, op, variable) fixed binary (18);
dcl  in_common bit (1) aligned;

	/* This program assumes that an assignment will not be dead unless the right hand side is a constant,
	   since unless this is so, the init code for new induction variables will reference the old
	   induction variable.  Although all vars added to da_chain were not busy_on_exit from their
	   flow_units when added, they may be now, so that we must perform the check again inside
	   the loop.	*/

	last = null;

	do dac = da_chain repeat dac -> dead_assign_cand.next while (dac ^= null);
	     variable = dac -> dead_assign_cand.variable;
	     varp = addr (rands (variable));
	     c = varp -> symbol.coordinate;
	     in_common = varp -> symbol.in_common;
	     fu = dac -> dead_assign_cand.flow_unit;

	     if ^fu -> flow_unit.removed & substr (fu -> flow_unit.set -> bits, c, 1)
		& ^substr (fu -> flow_unit.busy_on_exit -> bits, c, 1)
	     then do;

		/* refresh insert_operator field since previous optimizations may have killed it */

		call derive_insert_for_bt (fu);

		/* loop backwards through operators looking for uses and sets */

		first_statement = fu -> flow_unit.first_statement;

		do op = fu -> flow_unit.insert_operator repeat back while (op ^= first_statement);
		     o = addr (quad (op));
		     back = o -> operator.back;

		     /* special handling for namelist and common */

		     if o -> operator.op_code = read_namelist_op | o -> operator.op_code = write_namelist_op
		     then if in_namelist (o, variable)
			then go to step;
			else ;
		     else if in_common
		     then if o -> operator.op_code = func_ref_op | o -> operator.op_code = call_op
			then go to step;

		     /* look for uses */

		     do i = 1 to o -> operator.number;
			if o -> operand (i) = variable
			then go to step;
			end;

		     /* look for set */

		     if o -> operator.output = variable & o -> operator.op_code ^= stat_op
		     then do;
			if op_class (o -> operator.op_code) >= function_class
			then go to step;

			call unthread (o);

			if ^substr (fu -> flow_unit.set_multiple -> bits, c, 1)
			then do;
			     substr (fu -> flow_unit.set -> bits, c, 1) = "0"b;
			     go to step;
			     end;
			end;
		     end;

		substr (fu -> flow_unit.set -> bits, c, 1) = "0"b;
		substr (fu -> flow_unit.set_multiple -> bits, c, 1) = "0"b;
		substr (fu -> flow_unit.used -> bits, c, 1) = "0"b;
		end;

step:
	     last = dac;
	     end;

	last -> dead_assign_cand.next = free (size (dead_assign_cand));
	free (size (dead_assign_cand)) = da_chain;
	da_chain = null;

     end remove_dead_assignments;

create_integer_temporary:
     procedure (op) returns (fixed binary (18));

dcl  op fixed binary (18);				/* operator producing the temp */

dcl  t pointer;
dcl  temp fixed binary (18);

	/* allocate the space */

	if next_free_temp = 0
	then do;
	     temp = create_node (temporary_node, size (temporary));
	     t = addr (rands (temp));
	     end;

	else do;
	     temp = next_free_temp;
	     t = addr (rands (temp));
	     next_free_temp = t -> temporary.next;
	     unspec (t -> temporary) = "0"b;
	     t -> temporary.node_type = temporary_node;
	     end;

	/* fill in the data */

	t -> temporary.data_type = int_mode;
	t -> temporary.operand_type = temp_type;
	t -> temporary.size = 1;
	t -> temporary.output_by = op;
	t -> temporary.not_in_storage = "1"b;

	return (temp);

     end create_integer_temporary;

remove_loop:
     procedure (lp);

	/* removes "useless" loops */

dcl  lp pointer;					/* -> loop to be removed */

dcl  (adam, p, bt, bd, bdl, exit_target, jop, jst) pointer;
dcl  finished bit (1) aligned;
dcl  (j_operator, j_statement) fixed binary (18);

	adam = lp;

	/* print warning since this could be unexpected if the user was trying
	   to save data between invocations with automatic variables */

	cur_statement = adam -> loop.entry_unit -> flow_unit.first_statement;
	call print_message (387);

	bt = adam -> loop.back_target;

	/* propagate busy_on_exit from loop to back_target */

	bt -> flow_unit.busy_on_exit -> bits = adam -> loop.busy_on_exit -> bits;

	/* Remove all operations from the loop. */

	call remove_units_from_loop (adam);

	/* process all of adam's descendants */

	if adam -> loop.son ^= null
	then do;
	     p = adam -> loop.son;
	     finished = "0"b;

	     do while (^finished);
		call remove_units_from_loop (p);

		if p -> loop.son ^= null
		then p = p -> loop.son;

		else do;
		     do while (p -> loop.brother = null & ^finished);
			p = p -> loop.father;
			if p = adam
			then finished = "1"b;
			end;

		     p = p -> loop.brother;
		     end;
		end;
	     end;

	/* attach back target directly to the exit target of the loop */

	exit_target = adam -> loop.exits -> chain.value -> edge.to.value;

	if bt -> flow_unit.falls_through
	then do;
	     if bt -> flow_unit.next ^= exit_target
	     then do;

		/* need a jump to the exit_target */

		j_operator, bt -> flow_unit.insert_operator =
		     insert_operator_after (jump_op, 1, (bt -> flow_unit.insert_operator));
		addr (quad (j_operator)) -> operand (1) = get_flow_unit_label (exit_target);
		end;
	     end;

	else do;
	     j_statement = bt -> flow_unit.last_statement;
	     jst = addr (quad (j_statement));
	     j_operator = jst -> opt_statement.first_operator;
	     jop = addr (quad (j_operator));

	     if bt -> flow_unit.next ^= exit_target
	     then jop -> operand (1) = get_flow_unit_label (exit_target);
	     else call free_operator (jop);
	     end;

	call link (bt, exit_target);

	/* if the exit_target's back dominator was in one of the removed
	   loops, the adam loop's back target becomes the new back
	   dominator */

	bd = exit_target -> flow_unit.dominator;
	bdl = bd -> flow_unit.loop;
	if substr (bdl -> loop.ancestors_and_me -> lbits, adam -> loop.number, 1)
	then exit_target -> flow_unit.dominator = bt;

	return;

get_flow_unit_label:
     procedure (fu) returns (fixed binary (18));

dcl  fu pointer;					/* -> flow_unit whose label is to be returned */

dcl  (f_label, f_statement) fixed binary (18);

	f_statement = fu -> flow_unit.first_statement;
	f_label = addr (quad (f_statement)) -> opt_statement.label;
	if f_label = 0
	then f_label = create_label (f_statement);

	return (f_label);

     end get_flow_unit_label;

remove_units_from_loop:
     procedure (lp);

dcl  lp pointer;					/* -> loop whose flow_units are to be removed */

dcl  (fu, first_fu, o, stm) pointer;
dcl  (op, next_op, next_statement, next_unit_statement) fixed binary (18);

	first_fu = lp -> loop.members;
	lp -> loop.members = null;

	do fu = first_fu repeat fu -> flow_unit.next_in_loop while (fu ^= null);
	     next_unit_statement = fu -> flow_unit.next -> flow_unit.first_statement;

	     do cur_statement = fu -> flow_unit.first_statement repeat next_statement
		while (cur_statement ^= next_unit_statement);
		stm = addr (quad (cur_statement));
		next_statement = fixed (stm -> opt_statement.next, 18);

		do op = stm -> opt_statement.first_operator repeat next_op while (op ^= next_statement);
		     o = addr (quad (op));
		     next_op = o -> operator.next;
		     call remove_operator (o);
		     end;

		stm -> opt_statement.label = 0;
		stm -> opt_statement.flow_unit = bt;
		if stm -> opt_statement.moved
		then call free_statement (stm);
		end;

	     fu -> flow_unit.used -> bits, fu -> flow_unit.busy_on_entry -> bits, fu -> flow_unit.busy_on_exit -> bits,
		fu -> flow_unit.always_completely_set -> bits, fu -> flow_unit.set -> bits,
		fu -> flow_unit.set_multiple -> bits = "0"b;

	     /* detach the flow_unit */

	     call detach_flow_unit (fu);
	     end;

	lp -> loop.used -> bits, lp -> loop.set -> bits, lp -> loop.set_multiple -> bits = "0"b;

remove_operator:
     procedure (p_o);

dcl  (o, p_o) pointer;				/* -> operator to be removed from loop */

dcl  (p, outp) pointer;
dcl  (i, opnd) fixed binary (18);

	o = p_o;

	do i = 1 to o -> operator.number;
	     opnd = o -> operand (i);
	     if opnd > 0
	     then do;
		p = addr (rands (opnd));

		if p -> node.node_type = array_ref_node
		then p -> array_ref.ref_count = p -> array_ref.ref_count - 1;

		else if p -> node.node_type = temporary_node
		then p -> temporary.ref_count = p -> temporary.ref_count - 1;
		end;
	     end;

	if o -> operator.output > 0
	then do;
	     outp = addr (rands (o -> operator.output));

	     if outp -> node.node_type = temporary_node | o -> operator.op_code = opt_subscript_op
	     then call replace_inputs (addr (polish (outp -> temporary.start_input_to)), 0);
	     end;

	call free_operator (o);

     end remove_operator;

     end remove_units_from_loop;

     end remove_loop;

free_statement:
     procedure (stm);

dcl  stm pointer;					/* -> opt_statement to be unthreaded */

dcl  (next_statement, last_statement) fixed binary (18);
dcl  (nst, lst) pointer;

	next_statement = fixed (stm -> opt_statement.next, 18);
	nst = addr (quad (next_statement));
	last_statement = fixed (stm -> opt_statement.back, 18);
	lst = addr (quad (last_statement));

	lst -> opt_statement.next = stm -> opt_statement.next;
	nst -> opt_statement.back = stm -> opt_statement.back;

	call unthread (stm);

     end free_statement;

     end optimize_subprogram;

create_integer_constant:
     procedure (value) returns (fixed binary (18));

dcl  value fixed binary (18);

	if value = 1
	then return (one);
	else return (create_constant (int_mode, unspec (value)));

     end create_integer_constant;

index_value_analysis:
     procedure ();

	/* index_value_analysis:

	   determines which induction variables may be kept in an index register throughout a loop.
	   To be eligible , an induction variable must not be busy_on_exit from a loop, must
	   not be compared with anything unless we can determine its range, must not be assigned to
	   an ineligible variable, and must not be used except as an offset or length, and in assignment
	   or comparison contexts.

	   This roiutine also sets ref_count_copy for temporary and array_ref nodes and computes loop.computed,
	   a bit string identifying operators that compute their values within a loop.
	*/

dcl  i fixed binary;


	do i = 1 to n_loops;
	     call analyze_loop_index_values ((loop_vector (i)), i ^= n_loops);
	     end;

	return;

analyze_loop_index_values:
     procedure (p_lp, p_do_analysis);

dcl  (p_lp, lp) pointer,				/* -> loop to be analyzed */
     (p_do_analysis, do_analysis) bit (1) aligned;

dcl  (
     fu,
     o,
     opnd (2),
     outp,
     p,
     stm
     ) pointer;
dcl  (i, op_code) fixed binary;
dcl  (ipol, next_statement, op, next_unit_statement) fixed binary (18);
dcl  int_image fixed binary (35) aligned based;
dcl  (assignment_list, comparison_list, eligible_ind_var_op_var_list, busy_on_exit_list) pointer;

	/* INITIALIZE */

	lp = p_lp;
	do_analysis = p_do_analysis;
	assignment_list, comparison_list, eligible_ind_var_op_var_list, busy_on_exit_list = null;

	/* Initialize loop.may_keep_in_xr with information from inner loops.
	   We gather information about induction vars AND invariants to propagate
	   upwards.  Invariants may be kept in xrs despite context
	   as long as context info is propagated upwards to loops where the vars
	   may not be invariant.	*/

	if do_analysis
	then do;
	     lp -> loop.may_keep_in_xr -> bits =
		lp -> loop.induction_var -> bits | (integer_scalar_mask & ^lp -> loop.set -> bits);

	     do p = lp -> loop.son repeat p -> loop.brother while (p ^= null);
		lp -> loop.may_keep_in_xr -> bits =
		     lp -> loop.may_keep_in_xr -> bits & p -> loop.may_keep_in_xr -> bits;
		p -> loop.may_keep_in_xr -> bits =
		     p -> loop.may_keep_in_xr -> bits | (integer_scalar_mask & ^p -> loop.set -> bits);
		lp -> loop.computed -> obits = lp -> loop.computed -> obits | p -> loop.computed -> obits;
		end;
	     end;

	else do p = lp -> loop.son repeat p -> loop.brother while (p ^= null);
		p -> loop.may_keep_in_xr -> bits =
		     p -> loop.may_keep_in_xr -> bits | (integer_scalar_mask & ^p -> loop.set -> bits);
		end;

	/* Process all operators immediately contained in this loop. */

	do fu = lp -> loop.members repeat fu -> flow_unit.next_in_loop while (fu ^= null);
	     if fu -> flow_unit.next ^= null
	     then next_unit_statement = fu -> flow_unit.next -> flow_unit.first_statement;
	     else next_unit_statement = 0;

	     if fu -> flow_unit.first_statement ^= 0
	     then do cur_statement = fu -> flow_unit.first_statement repeat next_statement
		     while (cur_statement ^= next_unit_statement);
		     stm = addr (quad (cur_statement));
		     next_statement = fixed (stm -> opt_statement.next, 18);

		     do op = stm -> opt_statement.first_operator repeat o -> operator.next
			while (op ^= next_statement);
			o = addr (quad (op));
			op_code = o -> operator.op_code;

			if o -> operator.output > 0
			then do;
			     outp = addr (rands (o -> operator.output));

			     if outp -> node.node_type = temporary_node | op_code = opt_subscript_op
			     then outp -> temporary.ref_count_copy = outp -> temporary.ref_count;
			     end;

			if do_analysis
			then do;
			     if o -> operator.coordinate > 0
			     then substr (lp -> loop.computed -> obits, o -> operator.coordinate, 1) = "1"b;

			     go to case (xop_class (op_code));

case (1):						/* opt_subscript */
			     if o -> operand (3) > 0
			     then do;
				if outp -> array_ref.large_offset
				then call disqualify (addr (rands (o -> operand (3))));
				end;

			     go to case_end;

case (2):						/* incrementing */
			     if o -> operator.number > 0
			     then do;
				p = addr (rands (o -> operand (1)));

				if p -> node.node_type ^= constant_node
				then if ^invariant (p)
				     then call disqualify (p);
				     else if eligible (outp)
				     then do;
					call chain_it (o, eligible_ind_var_op_var_list);
					call check_busy_on_exit (outp);
					outp -> symbol.secondary = null;
					end;
				     else call disqualify (p);

				else if eligible (outp)
				then do;
				     if op_code = neg_storage_add_op
				     then p = addr (
					     rands (
					     create_integer_constant (-addr (p -> constant.value) -> int_image))
					     );
				     outp -> symbol.secondary = p;
				     call check_busy_on_exit (outp);
				     end;
				end;

			     else if eligible (outp)
			     then do;
				outp -> symbol.secondary = onep;
				call check_busy_on_exit (outp);
				end;

			     go to case_end;

case (3):						/* relational */
			     opnd (1) = addr (rands (o -> operand (1)));
			     opnd (2) = addr (rands (o -> operand (2)));

			     do i = 1 to 2;
				if ^invariant (opnd (i))
				then do;
				     call disqualify (opnd (3 - i));

				     if eligible (opnd (i))
				     then if invariant (opnd (3 - i))
					then call chain_it (o, comparison_list);
				     end;
				end;

			     go to case_end;

case (4):						/* jump_arithmetic */
			     p = addr (rands (o -> operand (1)));

			     if eligible (p)
			     then if ^invariant (p)
				then call chain_it (o, comparison_list);
				else call disqualify (p);

			     go to case_end;

case (5):						/* assign */
			     p = addr (rands (o -> operand (1)));

			     if ^eligible (outp)
			     then call disqualify (p);
			     else do;
				if eligible (p)
				then do;
				     call chain_it (o, assignment_list);
				     call check_busy_on_exit (outp);
				     end;
				outp -> symbol.secondary = null;
				end;

			     go to case_end;

case (6):						/* write_namelist */
			     ipol = addr (rands (o -> operand (1))) -> symbol.initial;
			     do i = 1 to polish (ipol);
				call disqualify (addr (rands (polish (ipol + i))));
				end;

			     go to case_end;

case (7):						/* most_operators */
			     call disqualify_inputs;
			     go to case_end;

case (8):						/* cat */
case_end:
			     end;
			end;
		     end;
	     end;

	/* process comparison and assignment lists */

	call process_assignment_list ("0"b);

	call process_comparison_list;

	call process_busy_on_exit_list;

	call process_assignment_list ("1"b);

	lp -> loop.eligible_ind_var_op_var = eligible_ind_var_op_var_list;

	return;

invariant:
     procedure (p) returns (bit (1) aligned);

dcl  p pointer;					/* -> operand */

dcl  o pointer;

	if p -> node.node_type = constant_node
	then return ("1"b);

	else if p -> node.node_type = symbol_node
	then return (^substr (lp -> loop.set -> bits, p -> symbol.coordinate, 1));

	else if p -> node.node_type = temporary_node
	then do;
	     o = addr (quad (p -> temporary.output_by));
	     if o -> operator.coordinate > 0
	     then return (^substr (lp -> loop.computed -> obits, o -> operator.coordinate, 1));
	     end;

	return ("0"b);

     end invariant;

check_busy_on_exit:
     procedure (p);

dcl  p pointer;					/* -> induction variable */

	/* If p is busy_on_exit from lp, we have to chain it for later
	   checking to see if it is non-negative so that it may be easily
	   updated from an xreg. */

	if substr (lp -> loop.busy_on_exit -> bits, p -> symbol.coordinate, 1)
	then call chain_it (p, busy_on_exit_list);

     end check_busy_on_exit;

eligible:
     procedure (p) returns (bit (1) aligned);

	/* determines if an operand is eligible to be kept in an index register */

dcl  p pointer;					/* -> operand */

	if p -> node.node_type = symbol_node
	then if p -> symbol.coordinate > 0
	     then return (substr (lp -> loop.may_keep_in_xr -> bits, p -> symbol.coordinate, 1));

	return ("0"b);

     end eligible;

disqualify_inputs:
     procedure ();

dcl  (i, opnd) fixed binary;

	do i = 1 to o -> operator.number;
	     opnd = o -> operand (i);
	     if opnd > 0
	     then call disqualify (addr (rands (opnd)));
	     end;

     end disqualify_inputs;

disqualify:
     procedure (p);

	/* Makes an operand ineligible to be kept in an index register */

dcl  p pointer;					/* -> operand */

	if p -> node.node_type = symbol_node
	then if p -> symbol.coordinate > 0
	     then substr (lp -> loop.may_keep_in_xr -> bits, p -> symbol.coordinate, 1) = "0"b;

     end disqualify;

chain_it:
     procedure (o, list_head);

dcl  o pointer,					/* -> item to be chained */
     list_head pointer;				/* head of chain */

dcl  c pointer;

	c = create_chain ();
	c -> chain.value = o;
	c -> chain.next = list_head;
	list_head = c;

     end chain_it;

process_comparison_list:
     procedure ();

	/* Attempts to get range information for all comparisons on the list. */

dcl  (bt, c, exit_c, exit_fu, last_c, orig_o, p, prev_fu, r) pointer;
dcl  op_code fixed binary;
dcl  have_eligible_variable bit (1) aligned;
dcl  which fixed binary;

dcl  1 range_bits automatic like range.range_bits unaligned;

dcl  max_integer fixed binary (35) internal static initial (011111111111111111111111111111111111b);

	bt = lp -> loop.back_target;
	last_c = null;

	do c = comparison_list repeat c -> chain.next while (c ^= null);
	     last_c = c;
	     orig_o = c -> chain.value;
	     op_code = orig_o -> operator.op_code;

	     p = addr (rands (orig_o -> operand (1)));
	     which = 1;
	     have_eligible_variable = eligible (p);

	     if ^have_eligible_variable & orig_o -> operator.op_code ^= jump_arithmetic_op
	     then do;
		p = addr (rands (orig_o -> operand (2)));
		which = 2;
		have_eligible_variable = eligible (p);
		end;

	     if have_eligible_variable
	     then do;
		string (range_bits) = try_to_calculate_range (p);

		if string (range_bits)
		then do;
		     r = find_range (p, lp, "1"b);
		     string (r -> range.bits) = string (r -> range.bits) & string (range_bits);

		     if string (r -> range.bits) = "0"b | (op_code = jump_arithmetic_op & ^r -> range.fb17)
		     then call disqualify (p);
		     else if op_code ^= jump_arithmetic_op
		     then if addr (rands (orig_o -> operand (3 - which))) -> node.node_type ^= constant_node
			then call chain_it (orig_o, eligible_ind_var_op_var_list);
		     end;

		else call disqualify (p);
		end;
	     end;

	if last_c ^= null
	then do;
	     last_c -> chain.next = free (size (chain));
	     free (size (chain)) = comparison_list;
	     end;

	return;

	/* Attempts to get range info for those vars busy_on_exit from the loop. */

process_busy_on_exit_list:
     entry;

	bt = lp -> loop.back_target;
	last_c = null;
	op_code = 0;

	do c = busy_on_exit_list repeat c -> chain.next while (c ^= null);
	     last_c = c;
	     p = c -> chain.value;

	     if eligible (p)
	     then do;
		r = find_range (p, lp, "1"b);

		prev_fu = null;

		do exit_c = lp -> loop.exits repeat exit_c -> chain.next while (exit_c ^= null & r -> range.fb18_uns);
		     exit_fu = exit_c -> chain.value -> edge.from.value;

		     if exit_fu ^= prev_fu
		     then do;
			prev_fu = exit_fu;
			call derive_insert_for_bt (exit_fu);
			orig_o = addr (quad (exit_fu -> flow_unit.insert_operator));

			string (range_bits) = try_to_calculate_range (p);

			string (r -> range.bits) = string (r -> range.bits) & string (range_bits);
			end;
		     end;

		if ^r -> range.fb18_uns
		then call disqualify (p);
		end;
	     end;

	if last_c ^= null
	then do;
	     last_c -> chain.next = free (size (chain));
	     free (size (chain)) = busy_on_exit_list;
	     end;

	return;

try_to_calculate_range:
     procedure (pt) returns (bit (2) aligned);

dcl  (p, pt) pointer;				/* -> var whose range is being calculated */

dcl  ac pointer;
dcl  var fixed binary (18);

dcl  1 range_bits automatic like range.range_bits unaligned;

	p = pt;

	string (range_bits) = calculate_range_by_subscripts (p);

	/* if we haven't found a range, use vars we assign to or from */

	var = fixed (rel (p), 18);

	do ac = assignment_list repeat ac -> chain.next while (string (range_bits) = "0"b & ac ^= null);
	     if ac -> chain.value -> operand (1) = var
	     then string (range_bits) =
		     calculate_range_by_subscripts (addr (rands (ac -> chain.value -> operator.output)));

	     else if ac -> chain.value -> operator.output = var
	     then string (range_bits) =
		     calculate_range_by_subscripts (addr (rands (ac -> chain.value -> operator.operand (1))));
	     end;

	/* If we still haven't found a range, see if we are in
	   lock step with another induction variable whose range
	   is knowable. */

	if string (range_bits) = "00"b
	then string (range_bits) = calculate_range_for_counter (p);

	return (string (range_bits));

     end try_to_calculate_range;

calculate_range_by_subscripts:
     procedure (pt) returns (bit (2) aligned);

dcl  (p, pt) pointer;				/* var whose range is being calculated */

dcl  1 range_bits automatic like range.range_bits unaligned;
dcl  (fu, o, s) pointer;
dcl  (first_statement, op, n, var) fixed binary (18);
dcl  (upper_bound, lower_bound, increment) fixed binary (35);
dcl  constant_offset fixed binary (24);
dcl  max_size fixed binary (24);

	/* This code attempts to calculate a variable's range by assuming
	   that an array or string must not be referenced outside its
	   generation of storage, i.e., subscriptrange, stringrange, and
	   stringsize must not occur! */

	p = pt;
	o = orig_o;

	upper_bound = max_integer;
	lower_bound = -upper_bound;

	if p -> symbol.secondary ^= null
	then do;
	     increment = addr (p -> symbol.secondary -> constant.value) -> int_image;
	     var = fixed (rel (p), 18);

	     do fu = null repeat fu -> flow_unit.dominator while (fu ^= bt);
		if fu ^= null
		then do;
		     first_statement = fu -> flow_unit.first_statement;
		     op = fu -> flow_unit.next -> flow_unit.first_statement;
		     o = addr (quad (op));
		     end;
		else first_statement = 0;

		do op = o -> operator.back repeat o -> operator.back while (op ^= first_statement);
		     o = addr (quad (op));
		     n = o -> operator.number;

		     if o -> operator.op_code = stat_op
		     then if fu = null
			then do;
			     fu = o -> opt_statement.flow_unit;
			     first_statement = fu -> flow_unit.first_statement;
			     if op = first_statement
			     then o = addr (quad (o -> operator.next));
			     end;
			else ;

		     else if o -> operator.op_code = opt_subscript_op
		     then do;
			s = addr (rands (o -> operand (1)));

			if n >= 4
			then if o -> operand (4) = var
			     then do;
				lower_bound = max (lower_bound, 1);
				if ^s -> symbol.variable_extents
				then max_size = s -> symbol.char_size + 1;
				else max_size = max_char_length;
				upper_bound = min (upper_bound, max_size);
				end;

			if o -> operand (3) = var
			then do;
			     constant_offset =
				addr (addr (rands (o -> operand (2))) -> constant.value) -> int_image;

			     lower_bound = max (lower_bound, min (increment, 0) - constant_offset);

			     max_size = get_max_size (s);

			     upper_bound = min (upper_bound, max_size - constant_offset + max (increment, 0) - 1);
			     end;
			end;

		     else if o -> operator.op_code = cat_op
		     then if o -> operand (n) = var
			then do;
			     lower_bound = max (lower_bound, 1);
			     upper_bound = min (upper_bound, max_char_length);
			     end;
		     end;
		end;
	     end;

	string (range_bits) = "0"b;
	if lower_bound >= -131072 & upper_bound < 131072
	then range_bits.fb17 = "1"b;
	if lower_bound >= 0 & upper_bound < 262144
	then range_bits.fb18_uns = "1"b;

	return (string (range_bits));

     end calculate_range_by_subscripts;

get_max_size:
     procedure (s) returns (fixed binary (24));

dcl  s pointer;					/* -> symbol node */

dcl  sys_info$max_seg_size fixed bin (18) ext;

dcl  d pointer;
dcl  max_chars fixed bin (21);
dcl  max_words fixed bin (24);
dcl  max_size fixed binary (24);

	/* returns maximum size of an array */

	max_chars = sys_info$max_seg_size * chars_per_word;
	if s -> symbol.VLA
	then max_words = max_fixed_bin_24;
	else max_words = sys_info$max_seg_size;

	if s -> symbol.dimension > 0
	then do;
	     d = addr (rands (s -> symbol.dimension));

	     if s -> symbol.variable_extents | s -> symbol.star_extents
		| (s -> symbol.parameter & d -> dimension.element_count <= 1)
	     then if s -> symbol.units = char_units
		then max_size = max_chars;
		else max_size = max_words;
	     else max_size = d -> dimension.array_size;
	     end;

	else if s -> symbol.variable_extents
	then if s -> symbol.units = char_units
	     then max_size = max_chars;
	     else max_size = max_words;
	else max_size = s -> symbol.element_size;

	return (max_size);

     end get_max_size;

calculate_range_for_counter:
     procedure (pt) returns (bit (2) aligned);

dcl  (p, pt) pointer;				/* var whose range is being calculated */

dcl  1 range_bits automatic like range.range_bits unaligned;

dcl  (c, const_p, fu, last_c, o, s, u) pointer;
dcl  (first_statement, op, var) fixed binary (18);
dcl  (upper_bound, lower_bound, bound) fixed binary (35);
dcl  (starting_value, other_value) fixed binary (35);
dcl  found bit (1) aligned;
dcl  (opt_subscript_chain, update_chain) pointer;
dcl  (increment, other_increment) fixed binary (18);

	/* This code hopes that our variable is in lock step with another
	   variable that is referencing a string or array.  If so, and if
	   our starting value is known, we can deduce a maximum number
	   of iterations for our variable and thus figure out the other
	   bound.  If our comparand is constant, and the op_code is proper,
	   the job is even easier. */

	p = pt;
	string (range_bits) = "0"b;

	if p -> symbol.secondary ^= null
	then do;
	     increment = addr (p -> symbol.secondary -> constant.value) -> int_image;
	     call get_starting_value (p, starting_value, found);

	     if found
	     then do;
		if increment > 0
		then do;
		     upper_bound = max_integer;
		     lower_bound = starting_value;
		     end;
		else do;
		     upper_bound = starting_value;
		     lower_bound = -max_integer;
		     end;

		/* If comparand is constant, we can deduce range quickly.
		   We assume the bottom of a do-loop ends with a jump_false_op. */

		if op_code ^= 0 & op_code ^= jump_arithmetic_op
		then if addr (rands (orig_o -> operand (3 - which))) -> node.node_type = constant_node
		     then if is_suitable_loop_exit (orig_o, p, lp)
			then do;
			     other_value =
				addr (addr (rands (orig_o -> operand (3 - which))) -> constant.value)
				-> int_image;
			     if increment > 0 & op_code = greater_op
			     then upper_bound = max (other_value + increment, lower_bound);
			     else if increment < 0 & op_code = less_op
			     then lower_bound = min (other_value + increment, upper_bound);
			     end;

		if upper_bound = max_integer | lower_bound = -max_integer
		then do;

		     /* We have to do it the hard way. */

		     opt_subscript_chain, update_chain = null;
		     o = orig_o;

		     do fu = null repeat fu -> flow_unit.dominator while (fu ^= bt);
			if fu ^= null
			then do;
			     first_statement = fu -> flow_unit.first_statement;
			     op = fu -> flow_unit.next -> flow_unit.first_statement;
			     o = addr (quad (op));
			     end;
			else first_statement = 0;

			do op = o -> operator.back repeat o -> operator.back while (op ^= first_statement);
			     o = addr (quad (op));

			     if o -> operator.op_code = stat_op
			     then if fu = null
				then do;
				     fu = o -> opt_statement.flow_unit;
				     first_statement = fu -> flow_unit.first_statement;
				     if op = first_statement
				     then o = addr (quad (o -> operator.next));
				     end;
				else ;

			     else if o -> operator.op_code = opt_subscript_op
			     then if o -> operand (3) > 0
				then do;
				     s = addr (rands (o -> operand (3)));
				     if s -> node.node_type = symbol_node
				     then if substr (lp -> loop.induction_var -> bits, s -> symbol.coordinate, 1)
					then call chain_it (o, opt_subscript_chain);
				     end;
				else ;

			     else if o -> operator.output > 0
			     then do;
				s = addr (rands (o -> operator.output));
				if s -> node.node_type = symbol_node
				then if substr (lp -> loop.induction_var -> bits, s -> symbol.coordinate, 1)
				     then call chain_it (o, update_chain);
				end;
			     end;
			end;

		     /* Process opt_subscript_chain. */

		     last_c = null;
		     do c = opt_subscript_chain repeat c -> chain.next while (c ^= null);
			last_c = c;
			o = c -> chain.value;
			var = o -> operand (3);
			found = "0"b;

			do u = update_chain repeat u -> chain.next while (^found & u ^= null);
			     if u -> chain.value -> operator.output = var
			     then found = "1"b;
			     end;

			if found
			then do;
			     const_p = addr (rands (var)) -> symbol.secondary;
			     if const_p ^= null
			     then other_increment = abs (addr (const_p -> constant.value) -> int_image);
			     else other_increment = 1;

			     bound = starting_value
				+ increment
				*
				divide (get_max_size (addr (rands (o -> operand (1)))) + other_increment - 1,
				other_increment, 24, 0);

			     if increment > 0
			     then upper_bound = min (upper_bound, bound);
			     else lower_bound = max (lower_bound, bound);
			     end;
			end;

		     if last_c ^= null
		     then do;
			last_c -> chain.next = free (size (chain));
			free (size (chain)) = opt_subscript_chain;
			end;

		     last_c = null;
		     do c = update_chain repeat c -> chain.next while (c ^= null);
			last_c = c;
			end;

		     if last_c ^= null
		     then do;
			last_c -> chain.next = free (size (chain));
			free (size (chain)) = update_chain;
			end;
		     end;

		if lower_bound >= -131072 & upper_bound < 131072
		then range_bits.fb17 = "1"b;
		if lower_bound >= 0 & upper_bound < 262144
		then range_bits.fb18_uns = "1"b;
		end;
	     end;

	return (string (range_bits));

     end calculate_range_for_counter;

get_starting_value:
     procedure (pt, starting_value, found);

dcl  (p, pt) pointer,				/* var whose starting value is needed */
     starting_value fixed binary (35),			/* answer (output) */
     found bit (1) aligned;				/* "1"b - starting value is valid (output) */

dcl  (first_statement, i, op, var) fixed binary (18);
dcl  o pointer;
dcl  in_common bit (1) aligned;

	/* Looks for starting value of an induction variable.  We only search back target. */

	p = pt;
	found = "0"b;

	if substr (bt -> flow_unit.set -> bits, p -> symbol.coordinate, 1)
	then do;
	     var = fixed (rel (p), 18);
	     in_common = p -> symbol.in_common;

	     /* refresh insert_operator field */

	     call derive_insert_for_bt (bt);

	     /* Loop back through operators looking for an assignment to var. */

	     first_statement = bt -> flow_unit.first_statement;

	     do op = bt -> flow_unit.insert_operator repeat o -> operator.back while (op ^= first_statement);
		o = addr (quad (op));

		if o -> operator.op_code = read_namelist_op
		then if in_namelist (o, var)
		     then return;
		     else ;

		else if o -> operator.op_code = call_op | o -> operator.op_code = func_ref_op
		then do;
		     if in_common | o -> operator.output = var
		     then return;

		     do i = 1 to o -> operator.number;
			if o -> operand (i) = var
			then return;
			end;
		     end;

		else if o -> operator.output = var
		then do;
		     if o -> operator.op_code = assign_op
		     then if addr (rands (o -> operand (1))) -> node.node_type = constant_node
			then do;
			     starting_value = addr (addr (rands (o -> operand (1))) -> constant.value) -> int_image;
			     found = "1"b;
			     end;
		     return;
		     end;
		end;
	     end;

     end get_starting_value;

is_suitable_loop_exit:
     procedure (p_o, var_p, p_lp) returns (bit (1) aligned);

dcl  (orig_o, p_o) pointer,				/* -> relational op that may be input to
						   a jump_false_op whose fall_through
						   exits the loop */
     var_p pointer,					/* induction variable */
     (lp, p_lp) pointer;				/* loop */

dcl  (fu, inp, jop, lab, o, outp, stm) pointer;
dcl  (first_statement, op, var) fixed binary (18);
dcl  found bit (1) aligned;

	/* Sees if the relational op that we are looking at is an
	   input to a jump_false_op whose fall_through exits the loop,
	   whose target is within the loop, and which must be
	   executed when the induction variable is updated. */

	orig_o = p_o;
	lp = p_lp;

	/* The update of the induction variable must be in the same
	   flow_unit as that of the test so that the test is not
	   bypassed whenever the variable is updated. */

	var = fixed (rel (var_p), 18);
	fu = null;
	first_statement = 0;
	found = "0"b;

	do op = orig_o -> operator.back repeat o -> operator.back while (^found & op ^= first_statement | fu = null);
	     o = addr (quad (op));

	     if o -> operator.op_code = stat_op
	     then if fu = null
		then do;
		     fu = o -> opt_statement.flow_unit;
		     first_statement = fu -> flow_unit.first_statement;
		     if op = first_statement
		     then o = addr (quad (o -> operator.next));
		     end;
		else ;

	     else if o -> operator.output = var
	     then found = "1"b;
	     end;

	if ^found
	then return ("0"b);

	/* Examine all operators that orig_o is input to */

	outp = addr (rands (orig_o -> operator.output));
	do inp = addr (polish (outp -> temporary.start_input_to)) repeat inp -> input_to.next while (inp ^= null);
	     if inp -> input_to.which > 0
	     then do;
		jop = inp -> input_to.operator;

		/* op_code for bottom of a do_loop is jump_false_op */
		if jop -> operator.op_code ^= jump_false_op
		then return ("0"b);

		/* target must be within loop */

		lab = addr (rands (jop -> operand (2)));
		stm = addr (quad (lab -> label.statement));
		if stm -> opt_statement.flow_unit -> flow_unit.loop ^= lp
		then return ("0"b);

		/* fall_through must exit the loop */

		if fu -> flow_unit.next -> flow_unit.loop -> loop.depth >= lp -> loop.depth
		then return ("0"b);
		end;
	     end;

	return ("1"b);

     end is_suitable_loop_exit;

     end process_comparison_list;

find_range:
     procedure (pt, plp, create_it) returns (pointer);

	/* Finds range data for a variable or, optionally, creates the data */

dcl  (p, pt) pointer,				/* -> symbol whose range data is needed */
     (lp, plp) pointer,				/* -> loop whose list is searched */
     create_it bit (1) aligned;

dcl  r pointer;

	p = pt;
	lp = plp;

	do r = lp -> loop.range_list repeat r -> range.next while (r ^= null);
	     if r -> range.variable = p
	     then return (r);
	     end;

	if create_it
	then do;
	     r = create_range (p, lp);
	     string (r -> range.bits) = "11"b;
	     end;

	return (r);

     end find_range;

create_range:
     procedure (p, lp) returns (pointer);

dcl  p pointer,					/* -> symbol for whom a range node is being created */
     lp pointer;					/* -> loop whose list is being added to */

dcl  r pointer;

	r = get_opt_space (size (range));
	r -> range.variable = p;
	r -> range.next = lp -> loop.range_list;
	lp -> loop.range_list = r;

	return (r);

     end create_range;

process_assignment_list:
     procedure (free_assignment_list);

	/* eligible vars may only assign to eligible vars */

dcl  free_assignment_list bit (1) aligned;

dcl  (c, inp, last_c, next_c, o, outp, rin, rout) pointer;
dcl  change_occurred bit (1) aligned;

	change_occurred = "1"b;

	do while (change_occurred);
	     change_occurred = "0"b;
	     last_c = null;

	     do c = assignment_list repeat next_c while (c ^= null);
		next_c = c -> chain.next;
		o = c -> chain.value;
		inp = addr (rands (o -> operand (1)));
		outp = addr (rands (o -> operator.output));

		if ^eligible (inp)
		then call remove (c, last_c);

		else if ^eligible (outp)
		then do;
		     call remove (c, last_c);
		     substr (lp -> loop.may_keep_in_xr -> bits, inp -> symbol.coordinate, 1) = "0"b;
		     change_occurred = "1"b;
		     end;

		else do;
		     last_c = c;

		     /* propagate range information */

		     rout = find_range (outp, lp, "0"b);
		     if rout ^= null
		     then do;
			rin = find_range (inp, lp, "0"b);
			if rin = null
			then do;
			     change_occurred = "1"b;
			     rin = create_range (inp, lp);
			     string (rin -> range.bits) = string (rout -> range.bits);
			     end;
			end;

		     /* propagate increment information */

		     if outp -> symbol.secondary = null & inp -> symbol.secondary ^= null
		     then do;
			outp -> symbol.secondary = inp -> symbol.secondary;
			change_occurred = "1"b;
			end;
		     end;
		end;
	     end;

	if free_assignment_list & last_c ^= null
	then do;
	     last_c -> chain.next = free (size (chain));
	     free (size (chain)) = assignment_list;
	     end;

	return;

remove:
     procedure (c, last_c);

dcl  c pointer,					/* assignment list item being removed */
     last_c pointer;				/* previous list item */

	if last_c ^= null
	then last_c -> chain.next = c -> chain.next;
	else assignment_list = c -> chain.next;

	c -> chain.next = free (size (chain));
	free (size (chain)) = c;

     end remove;

     end process_assignment_list;

     end analyze_loop_index_values;

     end index_value_analysis;

%include fort_opt_utilities;

%include fort_utilities;

print_hash_bucket_meters:
     procedure ();

dcl  i fixed binary;
dcl  p pointer;

	do i = 0 to hbound (p_list, 1);
	     hash_counter (i) = 0;
	     do p = p_list (i) repeat p -> primary.next while (p ^= null);
		hash_counter (i) = hash_counter (i) + 1;
		end;
	     end;

	call ioa_ ("p_list:  ^(^4d^3x^)", hash_counter);

	do i = 0 to hbound (bt_list, 1);
	     hash_counter (i) = 0;
	     do p = bt_list (i) repeat p -> primary.next while (p ^= null);
		hash_counter (i) = hash_counter (i) + 1;
		end;
	     end;

	call ioa_ ("bt_list: ^(^4d^3x^)", hash_counter);

     end print_hash_bucket_meters;

     end fort_optimizer;
