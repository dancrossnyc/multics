/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(86-08-18,JSLove), approve(86-08-18,MCR7518),
     audit(86-08-21,Parisek), install(86-10-02,MR12.0-1175):
     Changed to call match_star_name_ instead of linus_match_star_name.
     Linus_match_star_name was deleted when the new match_star_name_ was
     installed.
                                                   END HISTORY COMMENTS */


/* format: off */
%skip(1);
linus_options: proc;
%skip(1);
/*
     
     This module provides an interface to the options used in formatting
     reports. The following external entry points in order of appearance
     are available:

     initialize
     
     Called by all format related requests when they are invoked.
     It takes care of making sure everything is up to date, allocated, etc.
     
     terminate
     
     Called by linus termination code if lcb.report_control_info_ptr is
     non-null.  It takes care of undoing everything this subroutine does
     during the course of a linus session.

     check_identifier

     Called to check a column/option identifier.  Translates an option name
     and option identifier into a character string consisting of the option
     name and real option identifier (i.e.  translates 1 into the name of
     column 1.) Can also be used to determine if the column name is a star
     name.

     check_name
     
     Called to check an option name, expand the short option name into a
     long name, and determine if it needs a column/option identifier.

     get
     
     Called to get the value of a formatting option.

     get_active
     
     Called to get the names and values of the active formatting
     options.

     get_all
     
     Called to get the names and values of all of the formatting
     options.

     get_named
     
     Called to get the names and values of a set of formatting options.  The
     options are named by the caller, but the names of columns can be names,
     star names or numbers.  The names returned by this module are actual
     column names instead of numbers or star names.

     set_and_check
     
     Called to set a formatting option to a provided value.  The option
     name and value are checked for validity.

     set_all_to_system_defaults
     
     Called to set all of the formatting options to their default
     values.



     Known Bugs:

     Other Problems:

     History:

     Written - Al Dupuis - August 1983


*/
%page;
%skip(3);
/* These parameters are described at each entry where they are used. */
%skip(3);
dcl code_parm fixed bin (35) parm;
dcl identifier_needed_parm bit (1) aligned parm;
dcl lcb_ptr_parm ptr parm;
dcl long_option_name_parm char (*) varying parm;
dcl names_and_values_info_ptr_parm ptr parm;
dcl names_and_values_ptr_parm ptr parm;
dcl no_of_names_and_values_parm fixed bin (21) parm;
dcl no_of_options_in_name_table_parm fixed bin (21) parm;
dcl normalized_option_name_parm char (*) varying parm;
dcl option_identifier_parm char (*) varying parm;
dcl option_name_parm char (*) varying parm;
dcl option_name_table_ptr_parm ptr parm;
dcl option_value_parm char (*) varying parm;
dcl size_of_names_and_values_parm fixed bin (21) parm;
dcl system_default_parm bit (1) aligned parm;
%skip(5);
          call ssu_$abort_line (lcb.subsystem_control_info_ptr, 0,
	     "This is not a valid entrypoint.");
%page;
initialize: entry (
%skip(1);
          lcb_ptr_parm, /* input: pointer to the linus control block */
          code_parm     /* output: success or failure */
	       );
%skip(1);
/*

     This entry point is called by the display, set_format_options, 
     list_format_options, save_format_options and restore_format_options
     requests when they are invoked.  It is not called by column_value or
     display_builtins, and should not be called by any future active requests
     like column_value when they are implemented. This code makes sure that:

     1) The linus options value seg is created; that the value seg is loaded
     with the system defaults; that 3 areas for allocations are created; and
     that 9 temp segments are created.  This is done once per linus invocation.
     
     2) That the area used for allocations of name value pairs is emptied.  
     This is done once per invocation of this entrypoint.

     3) That the options which refer to columns are up to date.  This means
     deleting the old column options and loading the value seg with the new
     column default options if the user has done a lila proc since the last
     time this entry was called, or deleting the old column options if the
     user has done an unsuccessful lila proc since the last time this entry
     was called.

*/
%skip(1);
          me = "linus_options$initialize";
	lcb_ptr = lcb_ptr_parm;
	code_parm = 0;
%skip(1);
          if lcb.report_control_info_ptr = null ()
	then do;
	     call setup_to_do_reporting;
	     lcb.report_control_info_ptr = report_cip;
	     call load_value_seg_with_report_defaults;
	end;
%skip(1);
          call housekeeping;
	temp_seg_ptr = names_and_values_area_ptr;
	call release_area_ (temp_seg_ptr);
%skip(1);
          if lcb.selection_expression_identifier = 0
	then return;
%page;    
/* 

     If we are out of date, or, there is no valid lila expression available
     but the column options are still around, then delete the column
     options.  Then if there is a valid lila selection expression available,
     load the new column default values.

*/
%skip(1);
	if report_control_info.selection_expression_identifier
	^= lcb.selection_expression_identifier
	| ^valid_selection_expression
	then do;
	     call value_$get (value_seg_ptr, PERMANENT,
		OPTIONS.GENERAL_COLUMN.NAME (1), returned_option_value, code);
	     if code = 0
	     then call delete_column_options;
	     else if code ^= error_table_$oldnamerr
		then call ssu_$abort_line (sci_ptr, code,
		     "While trying to get the value of ^a for ^a.",
		     OPTIONS.GENERAL_COLUMN.NAME (1), me);
	          else;
	end;
%skip(1);
          if report_control_info.selection_expression_identifier
	^= lcb.selection_expression_identifier
	& valid_selection_expression
	then call load_value_seg_with_column_defaults;
%skip(1);
	return;
%page;
terminate: entry (
%skip(1);
          lcb_ptr_parm, /* input: ptr to the linus control block */
          code_parm     /* output: success or failure */
	      );
%skip(1);
/*

     This entry point is called by the linus termination procedure when the
     linus user has issued the "quit" request, or cleanup of linus has been
     signalled.  It deletes the value segment and releases areas and temp
     segs set up in the setup_to_do_reporting proc. It also deletes the copy
     of the report if one is still laying around (i.e. the display request
     was invoked with "-keep_report" and linus was quit out of before display
     was invoked again).

*/
%skip(1);
	/* Have to use this name or temp segs won't be released. */
%skip(1);
          me = "linus_options$initialize";
%skip(1);
	lcb_ptr = lcb_ptr_parm;
	code_parm = 0;
	sci_ptr = lcb.subsystem_control_info_ptr;
%skip(1);
          report_cip = lcb.report_control_info_ptr;
	if report_control_info.flags.permanent_report
	then do;
	     call linus_fr_delete_report (lcb_ptr, code);
	     if code ^= 0
	     then call ssu_$print_message (sci_ptr, code,
		"While trying to delete the copy of the report.");
	end;
%skip(1);
          /* Delete the value seg. */
%skip(1);
          call delete_$ptr (report_control_info.value_seg_ptr,
	     "100111"b, me, code);
	if code ^= 0
	then call ssu_$print_message (sci_ptr, code,
	     "While trying to delete the format options.");
%skip(1);
          /* Then the area/temp seg for name value allocations. */
%skip(1);
	temp_seg_ptr = report_control_info.name_value_area_ptr;
	call release_area_ (temp_seg_ptr);
	call release_temp_segment (report_control_info.name_value_area_ptr);
%skip(1);
          /* The temp seg for arrays of name-value pairs. */
%skip(1);
	call release_temp_segment (report_control_info.name_value_temp_seg_ptr);
%skip(1);
          /* The temp seg for report workspace. */
%skip(1);
	call release_temp_segment (report_control_info.report_temp_seg_ptr);
%skip(1);
          /* The temp seg and area for display workspace. */
%skip(1);
	temp_seg_ptr = report_control_info.display_work_area_ptr;
	call release_area_ (temp_seg_ptr);
	call release_temp_segment (report_control_info.display_work_area_ptr);
%skip(1);
          /* The temp seg and area for report allocations. */
%skip(1);
	temp_seg_ptr = report_control_info.report_work_area_ptr;
	call release_area_ (temp_seg_ptr);
	call release_temp_segment (report_control_info.report_work_area_ptr);
%skip(1);
	/* And the 4 temp segs for report building workspace. */
%skip(1);
	call release_temp_segment (report_control_info.input_string_temp_seg_ptr);
	call release_temp_segment (report_control_info.output_string_temp_seg_ptr);
	call release_temp_segment (report_control_info.editing_strings_temp_seg_ptr);
	call release_temp_segment (report_control_info.headers_temp_seg_ptr);
%skip(1);
	return;
%page;
check_identifier: entry (
%skip(1);
          lcb_ptr_parm,                /* input: ptr to linus control block */
	option_name_parm,            /* input: option name to look up */
	option_identifier_parm,      /* input: option identifier to look up */
          normalized_option_name_parm, /* output: the option name and identifier */
	code_parm		         /* output: success or failure */
	     );
%skip(1);
/*

     This entry is called to translate an option name and identifier into
     a character string that contains the option name and real option
     identifier. That is, an option identifier can be a number or the name
     of a column. The returned option identifier is always the name of the
     column. The option_name_parm should be the expanded version, as this
     entry shouldn't be called until the check_name entry was called. This
     entry does not support star names, but is useful for determining if
     the identifier is a star name.

*/
%skip(1);
          me = "linus_options$check_identifier";
	lcb_ptr = lcb_ptr_parm;
	option_name = option_name_parm;
	option_identifier = option_identifier_parm;
	normalized_option_name_parm = "";
	code_parm = 0;
%skip(1);
	call housekeeping;
%skip(1);
	call normalize_option_name (option_name, option_identifier, 
	     option_type, option_table_index, normalized_option_name, code);
	code_parm = code;
	normalized_option_name_parm = normalized_option_name;
%skip(1);
          return;
%page;
check_name: entry (
%skip(1);
          lcb_ptr_parm,           /* input: ptr to linus control block */
          option_name_parm,       /* input: option name to determine type of */
          long_option_name_parm,  /* output: long version of above name */
          identifier_needed_parm, /* output: ON means identifier needed */
          code_parm               /* output: success or failure */
		  );
%skip(1);
/*

     This entry point is called to check an option name and determine the
     type of option the caller is dealing with.  There are two types of
     options.  Ones like "-page_size" (general report or general column
     options) which do not require anything else to identify them.  For these
     types "0"b is returned to describe their type.  Others like "-width"
     (specific column options) require a column number or name to identify
     which they apply to.  For these types "1"b is returned.  The short or
     long name provided is used to find the long name of the option and this
     long name is returned.

*/
%skip(1);
	me = "linus_options$check_name";
          lcb_ptr = lcb_ptr_parm;
	option_name = option_name_parm;
	long_option_name_parm = "";
	identifier_needed_parm = OFF;
	code_parm = 0;
%skip(1);
          call housekeeping;
%skip(1);
	call expand_short_option_name (option_name, long_option_name, code);
	if code ^= 0
	then do;
	     code_parm = code;
	     return;
	end;
	else long_option_name_parm = long_option_name;
%skip(1);
          call lookup_option_number (long_option_name,
	     option_type, option_table_index);
	if option_type = SPECIFIC_COLUMN_OPTION
	then identifier_needed_parm = ON;
	else;
%page;
	if ^valid_selection_expression
	then if (option_type = GENERAL_COLUMN_OPTION
	     | option_type = SPECIFIC_COLUMN_OPTION)
	     then code_parm = linus_error_$no_lila_expr_processed;
	     else;
	else;
%skip(1);
          return;
%page;
get:	entry (
%skip(1);
          lcb_ptr_parm,                /* input: ptr to the linus control block */
          option_name_parm,            /* input: option name to get value for */
	option_identifier_parm,      /* input: option identifier for name */
	normalized_option_name_parm, /* output: the option name and identifier */
          option_value_parm,           /* output: option value defined for name */
          code_parm                    /* output: success or failure */
	     );
%skip(1);
/*

     This entry point is called by subroutines and requests. It
     attempts to get the option value associated with the caller provided
     option name. For option names that require an identifier, the option
     name concatenated with a blank and the real option identifier is also
     returned. That is, column names rather than numbers are always returned.

*/
%skip(1);	
          me = "linus_options$get";
%skip(1);
	lcb_ptr = lcb_ptr_parm;
	option_name = option_name_parm;
	option_identifier = option_identifier_parm;
%skip(1);
	normalized_option_name_parm = "";
	option_value_parm = "";
	code_parm = 0;
%skip(1);
          call housekeeping;
%skip(1);
	call normalize_option_name (option_name,
	     option_identifier, option_type, option_table_index, 
	     normalized_option_name, code);
	if code ^= 0
	then do;
	     code_parm = code;
	     return;
	end;

%skip(1);
	call value_$get (value_seg_ptr, PERMANENT,
	     normalized_option_name, option_value, code);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code,
	     "While trying to get the value for ^a.", 
	     normalized_option_name_parm);
%skip(1);
	normalized_option_name_parm = normalized_option_name;
	option_value_parm = option_value;
%skip(1);
          return;
%page;
get_active: entry (
%skip(1);
          lcb_ptr_parm,                   /* input: ptr to the linus control block */
          names_and_values_info_ptr_parm, /* output: ptr to names and values info */
          no_of_names_and_values_parm,    /* output: no of name-value pairs */
          names_and_values_ptr_parm,      /* output: ptr to the names and values */
          size_of_names_and_values_parm,  /* output: length of names_and_values char string */
          code_parm                       /* output: success or failure */
	      );
%skip(1);
/*

     This entrypoint is called by the linus list_format_options and
     save_format_options requests to get all the active formatting option
     names and values.  They are returned as a character string, along
     with a structure which describes the character string.

*/
%skip(1);
          me = "linus_options$get_active";
	lcb_ptr = lcb_ptr_parm;
	names_and_values_info_ptr_parm = null ();
	no_of_names_and_values_parm = 0;
	names_and_values_ptr_parm = null ();
	size_of_names_and_values_parm = 0;
	code_parm = 0;
%skip(1);
          call housekeeping;
%skip(1);
          call get_all_names_and_values;
	call extract_active_from_all;
%skip(1);
	names_and_values_info_ptr_parm = like_names_and_values_info_ptr;
          no_of_names_and_values_parm = no_of_active_names_and_values;
	names_and_values_ptr_parm = names_and_values_ptr;
	size_of_names_and_values_parm = size_of_names_and_values;
%skip(1);
          return;
%page;
get_all: entry (
%skip(1);
          lcb_ptr_parm,                   /* input: ptr to the linus control block */
          names_and_values_info_ptr_parm, /* output: ptr to names and values info */
          no_of_names_and_values_parm,    /* output: no of name-value pairs */
          names_and_values_ptr_parm,      /* output: ptr to the names and values */
          size_of_names_and_values_parm,  /* output: length of names_and_values char string */
          code_parm                       /* output: success or failure */
	      );
%skip(1);
/*

     This entrypoint is called by the linus list_format_options and
     save_format_options requests to get all of the formatting option names
     and values.  They are returned as a character string, along with a
     structure which describes the character string.

*/
%skip(1);
          me = "linus_options$get_all";
	lcb_ptr = lcb_ptr_parm;
	names_and_values_info_ptr_parm = null ();
	no_of_names_and_values_parm = 0;
	names_and_values_ptr_parm = null ();
	size_of_names_and_values_parm = 0;
	code_parm = 0;
%skip(1);
          call housekeeping;
%skip(1);
          call get_all_names_and_values;
%skip(1);
	names_and_values_info_ptr_parm = names_and_values_info_ptr;
	no_of_names_and_values_parm = no_of_names_and_values;
	names_and_values_ptr_parm = names_and_values_ptr;
	size_of_names_and_values_parm = size_of_names_and_values;
%skip(1);
          return;
%page;
get_named: entry (
%skip(1);
          lcb_ptr_parm,                     /* input: ptr to the linus control block */
          option_name_table_ptr_parm,       /* input: an array of option names and identifiers */
          no_of_options_in_name_table_parm, /* input: no of option names */
          names_and_values_info_ptr_parm,   /* output: ptr to names and values info */
          no_of_names_and_values_parm,      /* output: no of name value pairs */
          names_and_values_ptr_parm,        /* output: ptr to the names and values */
          size_of_names_and_values_parm,    /* output: length of names_and_values char string */
          code_parm                         /* output: success or failure */
	      );
%skip(1);
/*

     This entrypoint is called by the linus save_format_options and
     list_format_options requests.  It takes an array of names as input and
     creates a character string containing all of the names and values, along
     with a structure which describes the character string.

*/
%skip(1);
          me = "linus_options$get_named";
	lcb_ptr = lcb_ptr_parm;
	option_name_table_ptr = option_name_table_ptr_parm;
	no_of_options_in_name_table = no_of_options_in_name_table_parm;
	names_and_values_info_ptr_parm = null();
	no_of_names_and_values_parm = 0;
	names_and_values_ptr_parm = null ();
	size_of_names_and_values_parm = 0;
	code_parm = 0;
%skip(1);
          call housekeeping;
%skip(1);
          call get_named_values (code);
          if code ^= 0
	then code_parm = code;
	else do;
	     names_and_values_info_ptr_parm = names_and_values_info_ptr;
	     no_of_names_and_values_parm = no_of_names_and_values;
	     names_and_values_ptr_parm = names_and_values_ptr;
	     size_of_names_and_values_parm = size_of_names_and_values;
	end;
%skip(1);
          return;
%page;
set_and_check: entry (
%skip(1);
          lcb_ptr_parm,           /* input: ptr to linus control block */
          option_name_parm,       /* input: option name to set value for */
	option_identifier_parm, /* input: option identifier for name */
          option_value_parm,      /* input: option value to set */
          system_default_parm,    /* input: on = set value to system default */
          code_parm               /* output: success or failure */
		);
%skip(1);
/*

     This entry point is called by the set_format_options request to set a user
     specified option name to either a user provided option value or the system
     provided default.  It first makes sure that the option name is valid.  The
     caller should have first called the check_name entry of this
     suboutine and had the option name expanded and checked at that time.  If
     the user has requested that it be set to the system default value, it sets
     it from system tables.  Otherwise it determines if the value is legitimate
     for the particular option.  It is then set if the value is correct.

*/
%skip(1);
          me = "linus_options$set_and_check";
	lcb_ptr = lcb_ptr_parm;
	option_name = option_name_parm;
	option_identifier = option_identifier_parm;
	option_value = option_value_parm;
	system_default = system_default_parm;
	code_parm = 0;
%skip(1);
          call housekeeping;
%skip(1);
     	call set_the_values (option_name, option_identifier,
	     option_value, system_default, code);
	code_parm = code;
%skip(1);
          return;
%page;
set_all_to_system_defaults: entry (
%skip(1);
          lcb_ptr,  /* input: ptr to linus control block */
          code_parm /* output: success or failure */
			   );
%skip(1);
/*

     This entrypoint is called by the set_format_options request to set all
     of the formatting options to the system provided defaults.  It first
     sets the general report options. It then sets the general and specific
     column options if a valid lila statement is available. If there are old
     column options hanging around they are deleted before the set operation.

*/
%skip(1);
          me = "linus_options$set_all_to_system_defaults";
	lcb_ptr = lcb_ptr_parm;
	code_parm = 0;
%skip(1);
          call housekeeping;
          call load_value_seg_with_report_defaults;
%skip(1);
	if ^valid_selection_expression
	then return;
%skip(1);
          call value_$get (value_seg_ptr, PERMANENT,
	     OPTIONS.GENERAL_COLUMN.NAME (1), returned_option_value, code);
	if code = 0
	then call delete_column_options;
	else if code ^= error_table_$oldnamerr
	     then call ssu_$abort_line (sci_ptr, code,
	          "While trying to get the value of ^a for ^a.",
	          OPTIONS.GENERAL_COLUMN.NAME (1), me);
	     else;
%skip(1);
	call load_value_seg_with_column_defaults;
%skip(1);
	return;
%page;
delete_column_options: proc;
%skip(3);
/*

     This proc is called to delete the column option names and values so that
     leftover column options from another select don't get confused with the
     current column options. If it runs into trouble the line is aborted 
     here because reporting can't possibly continue.

*/
%skip(1);
dcl dco_inner_loop fixed bin;
dcl dco_loop fixed bin;
%skip(1);
          alloc_name_count = NUMBER_OF_GENERAL_COLUMN_OPTIONS_IN_TABLE
	     + NUMBER_OF_SPECIFIC_COLUMN_OPTIONS_IN_TABLE;	     
	alloc_max_name_len = max (LONGEST_SPECIFIC_COLUMN_OPTION_NAME_LENGTH,
	     LONGEST_GENERAL_COLUMN_OPTION_NAME_LENGTH)
	     + length (BLANK) + length (STAR_DOT_STAR_STAR);
	allocate match_info in (names_and_values_area)
	     set (match_info_ptr);
	match_info.version = match_info_version_1;
%skip(1);
	do dco_loop = 1 to NUMBER_OF_GENERAL_COLUMN_OPTIONS_IN_TABLE;
%skip(1);
	     match_info.name_array.exclude_sw (dco_loop) = OFF;
	     match_info.name_array.regexp_sw (dco_loop) = OFF;
	     match_info.name_array.name (dco_loop) 
		= OPTIONS.GENERAL_COLUMN.NAME (dco_loop);
%skip(1);
	end;
%skip(1);
          dco_inner_loop = NUMBER_OF_GENERAL_COLUMN_OPTIONS_IN_TABLE + 1;
%skip(1);
	do dco_loop = 1 to NUMBER_OF_SPECIFIC_COLUMN_OPTIONS_IN_TABLE;
%skip(1);
	     match_info.name_array.exclude_sw (dco_inner_loop) = OFF;
	     match_info.name_array.regexp_sw (dco_inner_loop) = OFF;
	     match_info.name_array.name (dco_inner_loop) = 
		OPTIONS.SPECIFIC_COLUMN.NAME (dco_loop) 
		|| BLANK || STAR_DOT_STAR_STAR;
	     dco_inner_loop = dco_inner_loop + 1;
%skip(1);
	end;
%page;
          call value_$list (value_seg_ptr, PERMANENT, match_info_ptr,
	     names_and_values_area_ptr, value_list_info_ptr, code);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code,
	     "^a", "While trying to get the option names for the columns.");
%skip(1);
          do dco_loop = 1 to value_list_info.pair_count;
%skip(1);
	     call value_$delete (value_seg_ptr, PERMANENT,
		substr (value_list_info.chars, 
		value_list_info.pairs.name_index (dco_loop), 
		value_list_info.pairs.name_len (dco_loop)), code);
	     if code ^= 0
	     then call ssu_$abort_line (sci_ptr, code,
		"While trying to delete the value of ^a.", 
		substr (value_list_info.chars, 
		value_list_info.pairs.name_index (dco_loop), 
		value_list_info.pairs.name_len (dco_loop)));
%skip(1);
	end;
%skip(1);
	report_control_info.options_identifier = 
	     report_control_info.options_identifier + 1;
%skip(1);
          return;
%skip(1);
     end delete_column_options;
%page;
expand_short_option_name: proc (

	eson_option_name_parm,       /* input: option name to expand */
	eson_long_option_name_parm,  /* output: long version of option name */
	eson_code_parm	         /* output: success or failure */
			 );
%skip(3);
/*

     When this proc is called it expects eson_option_name_parm to contain the
     short or long option name.  It sets eson_long_option_name_parm based on
     the value of eson_option_name_parm.  If the name isn't valid it sets
     eson_code_parm to reflect this.  It first does a binary table search on
     the short_names table and if it's unsucessful it does the same to the
     long_names table.

*/
%skip(1);
dcl eson_code_parm fixed bin (35) parm;
dcl eson_long_option_name_parm char (*) varying parm;
dcl eson_option_name_parm char (*) varying parm;
dcl eson_table_index fixed bin;
%skip(3);
	eson_long_option_name_parm = "";
	eson_code_parm = 0;
%skip(1);
	eson_table_index = lookup_name_from_table (eson_option_name_parm,
	     OPTION_NAMES_AS_ARGS.SHORT_NAME);
	if eson_table_index ^= 0
	then do;
	     eson_long_option_name_parm = OPTION_NAMES_AS_ARGS.
		LONG_NAME_IN_SHORT_NAME_ORDER (eson_table_index);
	     return;
	end;
%skip(1);
	eson_table_index = lookup_name_from_table (eson_option_name_parm,
	     OPTION_NAMES_AS_ARGS.LONG_NAME);
	if eson_table_index ^= 0
	then eson_long_option_name_parm = eson_option_name_parm;
	else eson_code_parm = linus_error_$bad_option_name;
%skip(1);
	return;
%page;
lookup_name_from_table: proc (

	lnft_name_parm, /* input: name to look up */
	lnft_table_parm /* output: table to do lookup from */
		         ) returns (fixed bin);
%skip(3);
dcl lnft_loop1 fixed bin;
dcl lnft_loop2 fixed bin;
dcl lnft_loop3 fixed bin;
dcl lnft_name_parm char (*) varying parm;
dcl lnft_table_parm (*) char (*) varying parm;
%skip(1);
          lnft_loop1 = 1;
	lnft_loop2 = hbound (lnft_table_parm, 1);
%skip(1);
	do while (lnft_loop1 <= lnft_loop2);
%skip(1);
	     lnft_loop3 = divide (lnft_loop1 + lnft_loop2, 2, 17);
	     if lnft_name_parm = lnft_table_parm (lnft_loop3)
	     then return (lnft_loop3);
%skip(1);
	     if lnft_name_parm < lnft_table_parm (lnft_loop3)
	     then lnft_loop2 = lnft_loop3 - 1;
	     else lnft_loop1 = lnft_loop3 + 1;
%skip(1);
	end;
%skip(1);
	return (0);
%skip(1);
     end lookup_name_from_table;
%skip(3);
     end expand_short_option_name;
%page;
extract_active_from_all: proc;
%skip(3);
/*

     This proc is called by the entry get_active to extract the names and
     values from the value list structures that are considered active.  It
     expects that get_all_names_and_values has just been called, and moves the
     index and length of each name and value considered active, into a
     structure returned to the caller of the get_active entrypoint.

*/
%skip(1);
dcl eafa_inner_loop fixed bin;
dcl eafa_loop fixed bin;
%skip(3);
	no_of_names_and_values_in_bit_map = no_of_names_and_values;
	no_of_active_names_and_values = no_of_names_and_values;
%skip(1);
	allocate names_and_values_bit_map in (names_and_values_area)
	     set (names_and_values_bit_map_ptr);
	unspec (names_and_values_bit_map) = OFF;
%skip(1);
          do eafa_loop = 1 to NUMBER_OF_GENERAL_REPORT_OPTIONS_IN_TABLE;
%skip(1);
	     if report_control_info.format_options_flags.
		general_report_default_value (eafa_loop)
	     then do;
		names_and_values_bit_map (eafa_loop) = ON;
		no_of_active_names_and_values = 
		     no_of_active_names_and_values - 1;
	     end;
%skip(1);
	end;
%page;
          if valid_selection_expression
	then do;
	     eafa_inner_loop = NUMBER_OF_GENERAL_REPORT_OPTIONS_IN_TABLE + 1;
	     do eafa_loop = 1 to NUMBER_OF_GENERAL_COLUMN_OPTIONS_IN_TABLE;
		if report_control_info.format_options_flags
		     .general_column_default_value (eafa_loop)
		then do;
		     names_and_values_bit_map (eafa_inner_loop) = ON;
		     no_of_active_names_and_values =
			no_of_active_names_and_values - 1;
		end;
		eafa_inner_loop = eafa_inner_loop + 1;
	     end;
	end;
%skip(1);
	allocate like_name_value_info in (names_and_values_area) 
	     set (like_names_and_values_info_ptr);
%skip(1);
          eafa_inner_loop = 1;
%skip(1);
          do eafa_loop = 1 to no_of_names_and_values_in_bit_map;
               if names_and_values_bit_map (eafa_loop) = OFF
	     then do;
		like_name_value_info.name.index (eafa_inner_loop) =
		     name_value_info.name.index (eafa_loop);
		like_name_value_info.name.length (eafa_inner_loop) =
		     name_value_info.name.length (eafa_loop);
                    like_name_value_info.value.index (eafa_inner_loop) =
		     name_value_info.value.index (eafa_loop);
		like_name_value_info.value.length (eafa_inner_loop) =
		     name_value_info.value.length (eafa_loop);
		eafa_inner_loop = eafa_inner_loop + 1;
	     end;
	end;
%skip(1);
          return;
%skip(1);
     end extract_active_from_all;
%page;
get_all_names_and_values: proc;
%skip(3);
/*
          
     This proc is called to obtain all of the names and values.  It first gets
     the general report options.  Then, if there are column options defined,
     the general column options are gotten, followed by the specific column
     options.

*/
%skip(1);
dcl ganav_inner_loop fixed bin;
dcl ganav_loop fixed bin;
dcl ganav_loop_limit fixed bin;
dcl ganav_no_of_chars_already_done fixed bin (21);
%skip(3);
	/* Get the names and values for the general report options. */
%skip(1);
	alloc_name_count = NUMBER_OF_GENERAL_REPORT_OPTIONS_IN_TABLE;
	alloc_max_name_len = LONGEST_GENERAL_REPORT_OPTION_NAME_LENGTH;
	allocate match_info in (names_and_values_area) set (match_info_ptr);
	match_info.version = match_info_version_1;
%skip(1);
          do ganav_loop = 1 to NUMBER_OF_GENERAL_REPORT_OPTIONS_IN_TABLE;
%skip(1);
	     match_info.name_array.exclude_sw (ganav_loop) = OFF;
	     match_info.name_array.regexp_sw (ganav_loop) = OFF;
	     match_info.name_array.name (ganav_loop) 
		= OPTIONS.GENERAL_REPORT.NAME (ganav_loop);
%skip(1);
	end;
%skip(1);
          call value_$list (value_seg_ptr, PERMANENT, match_info_ptr,
	     names_and_values_area_ptr, value_list_info_ptr, code);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code,
	     "^/While trying to get the report option names and values.");
%skip(1);
	general_report_names_and_values_info_ptr = value_list_info_ptr;
%page;
	/* Get the names and values for the general and specific column options. */
%skip(1);
          if valid_selection_expression
	then do;
%skip(1);
	     alloc_name_count = NUMBER_OF_GENERAL_COLUMN_OPTIONS_IN_TABLE;
	     alloc_max_name_len = LONGEST_GENERAL_COLUMN_OPTION_NAME_LENGTH;
	     allocate match_info in (names_and_values_area) 
		set (match_info_ptr);
	     match_info.version = match_info_version_1;
%skip(1);
	     do ganav_loop = 1 to NUMBER_OF_GENERAL_COLUMN_OPTIONS_IN_TABLE;
%skip(1);
		match_info.name_array.exclude_sw (ganav_loop) = OFF;
		match_info.name_array.regexp_sw (ganav_loop) = OFF;
		match_info.name_array.name (ganav_loop)
		     = OPTIONS.GENERAL_COLUMN.NAME (ganav_loop);
%skip(1);
	     end;
%skip(1);
               call value_$list (value_seg_ptr, PERMANENT, match_info_ptr,
		names_and_values_area_ptr, value_list_info_ptr, code);
	     if code ^= 0
	     then call ssu_$abort_line (sci_ptr, code,
		"^/While trying to get the general column option names and values.");
%skip(1);
	     general_columns_names_and_values_info_ptr = value_list_info_ptr;
%skip(1);
	     alloc_name_count = NUMBER_OF_SPECIFIC_COLUMN_OPTIONS_IN_TABLE;
	     alloc_max_name_len = LONGEST_SPECIFIC_COLUMN_OPTION_NAME_LENGTH
		+ length (BLANK) + length (STAR_DOT_STAR_STAR);
	     allocate match_info in (names_and_values_area) 
		set (match_info_ptr);
	     match_info.version = match_info_version_1;
%skip(1);
	     do ganav_loop = 1 to NUMBER_OF_SPECIFIC_COLUMN_OPTIONS_IN_TABLE;
%skip(1);
		match_info.name_array.exclude_sw (ganav_loop) = OFF;
		match_info.name_array.regexp_sw (ganav_loop) = OFF;
		match_info.name_array.name (ganav_loop)
		     = OPTIONS.SPECIFIC_COLUMN.NAME (ganav_loop) 
		     || BLANK || STAR_DOT_STAR_STAR;
%skip(1);
	     end;
%skip(1);
               call value_$list (value_seg_ptr, PERMANENT, match_info_ptr,
		names_and_values_area_ptr, value_list_info_ptr, code);
	     if code ^= 0
	     then call ssu_$abort_line (sci_ptr, code,
		"While trying to get the specific column option names and values.");
%skip(1);
	     specific_columns_names_and_values_info_ptr = value_list_info_ptr;
%skip(1);
	end;
%skip(1);
	/* Set the number of options we have and the length of them. */
%skip(1);
          if valid_selection_expression
	then size_of_names_and_values = 
	     general_report_names_and_values_info_ptr -> value_list_info.chars_len
               + general_columns_names_and_values_info_ptr -> value_list_info.chars_len
               + specific_columns_names_and_values_info_ptr -> value_list_info.chars_len;
	else size_of_names_and_values =
	     general_report_names_and_values_info_ptr -> value_list_info.chars_len;
	allocate names_and_values in (names_and_values_area)
	     set (names_and_values_ptr);
%skip(1);
          if valid_selection_expression
          then no_of_names_and_values = 
	     general_report_names_and_values_info_ptr -> value_list_info.pair_count
               + general_columns_names_and_values_info_ptr -> value_list_info.pair_count
               + specific_columns_names_and_values_info_ptr -> value_list_info.pair_count;
	else no_of_names_and_values =
	     general_report_names_and_values_info_ptr -> value_list_info.pair_count;
	allocate name_value_info in (names_and_values_area) 
	     set (names_and_values_info_ptr);
%skip(1);
     	/* Move the general report options and their lengths and index
             into the callers table. */
%skip(1);
          value_list_info_ptr = general_report_names_and_values_info_ptr;
          substr (names_and_values, 1, value_list_info.chars_len)
	     = value_list_info.chars;
%skip(1);
	do ganav_loop = 1 to NUMBER_OF_GENERAL_REPORT_OPTIONS_IN_TABLE;
%skip(1);
	     name_value_info.name.index (ganav_loop) = 
		value_list_info.pairs.name_index (ganav_loop);
	     name_value_info.name.length (ganav_loop) = 
		value_list_info.pairs.name_len (ganav_loop);
               name_value_info.value.index (ganav_loop) =
		value_list_info.pairs.value_index (ganav_loop);
	     name_value_info.value.length (ganav_loop) = 
		value_list_info.pairs.value_len (ganav_loop);
%skip(1);
	end;
%skip(1);
          if ^valid_selection_expression
          then return;
%skip(1);
     	/* Move the general and specific column options and their lengths
             and index into the callers table. */
%skip(1);
          ganav_no_of_chars_already_done = value_list_info.chars_len;
          ganav_inner_loop = NUMBER_OF_GENERAL_REPORT_OPTIONS_IN_TABLE + 1;
	value_list_info_ptr = general_columns_names_and_values_info_ptr;
	substr (names_and_values, ganav_no_of_chars_already_done + 1,
	     value_list_info.chars_len) = value_list_info.chars;
%skip(1);
          do ganav_loop = 1 to NUMBER_OF_GENERAL_COLUMN_OPTIONS_IN_TABLE;
%skip(1);
	     name_value_info.name.index (ganav_inner_loop) = 
		value_list_info.pairs.name_index (ganav_loop) 
		+ ganav_no_of_chars_already_done;
	     name_value_info.name.length (ganav_inner_loop) = 
		value_list_info.pairs.name_len (ganav_loop);
%skip(1);
               name_value_info.value.index (ganav_inner_loop) =
		value_list_info.pairs.value_index (ganav_loop) 
		+ ganav_no_of_chars_already_done;
	     name_value_info.value.length (ganav_inner_loop) = 
		value_list_info.pairs.value_len (ganav_loop);
	     ganav_inner_loop = ganav_inner_loop + 1;
%skip(1);
	end;
%skip(1);
          ganav_no_of_chars_already_done = 
	     ganav_no_of_chars_already_done + value_list_info.chars_len;
	value_list_info_ptr = specific_columns_names_and_values_info_ptr;
	substr (names_and_values, ganav_no_of_chars_already_done + 1,
	     value_list_info.chars_len) = value_list_info.chars;
%skip(1);
          ganav_loop_limit = NUMBER_OF_SPECIFIC_COLUMN_OPTIONS_IN_TABLE
	     * table_info.column_count;
%skip(1);
          do ganav_loop = 1 to ganav_loop_limit;
%skip(1);
	     name_value_info.name.index (ganav_inner_loop) = 
		value_list_info.pairs.name_index (ganav_loop) 
		+ ganav_no_of_chars_already_done;
	     name_value_info.name.length (ganav_inner_loop) = 
		value_list_info.pairs.name_len (ganav_loop);
%skip(1);
               name_value_info.value.index (ganav_inner_loop) =
		value_list_info.pairs.value_index (ganav_loop) 
		+ ganav_no_of_chars_already_done;
	     name_value_info.value.length (ganav_inner_loop) = 
		value_list_info.pairs.value_len (ganav_loop);
	     ganav_inner_loop = ganav_inner_loop + 1;
%skip(1);
	end;
%skip(1);
          return;
%skip(1);
     end get_all_names_and_values;
%page;
get_general_column_default_value: proc (

	ggcdv_option_name_parm, /* input: name of option */
	ggcdv_option_value_parm /* output: default value for above option */
			        );
%skip(3);
/*

     When this proc is called it expects ggcdv_option_name_parm to contain
     the name of the option that the default should be generated for.  It
     sets ggcdv_option_value_parm to this default value or "ERROR" if things
     don't work out well.

*/
%skip(1);
dcl ggcdv_loop fixed bin;
dcl ggcdv_option_name_parm char (*) varying parm;
dcl ggcdv_option_value_parm char (*) varying parm;
%skip(1);
	if ggcdv_option_name_parm 
	     = OPTIONS.GENERAL_COLUMN.NAME (INDEX_FOR_COLUMN_ORDER)
	then do;
	     ggcdv_option_value_parm = table_info.columns.column_name (1);
	     if number_of_defined_columns = 1
	     then return;
	     do ggcdv_loop = 2 to number_of_defined_columns;
		ggcdv_option_value_parm = ggcdv_option_value_parm || BLANK
		     || table_info.columns.column_name (ggcdv_loop);
	     end;
	end;
	else ggcdv_option_value_parm = "ERROR";
%skip(1);
	return;
%skip(1);
     end get_general_column_default_value;
%page;
get_specific_column_default_value: proc (

	gscdv_option_name_parm,	/* input: option name */
	gscdv_option_identifier_parm,	/* input: identifier for name */
	gscdv_option_value_parm       /* output: value for the option */
				);
%skip(3);
/*

     This proc gets the default value of any given column.  When called, it
     expects that gscdv_option_name_parm contains a valid option name and
     gscdv_option_identifier_parm contains a valid option identifier which has
     been normalized into a column name.  It places the default value in
     gscdv_option_value_parm.  This proc expects that table_info is available
     and up to date, which means there has to be a set of columns defined.
     Error conditions are handled by setting the value "ERROR".  There should
     never be any error conditions unless this proc is used incorrectly.

*/
%skip(1);
dcl gscdv_column_option_number fixed bin;
dcl gscdv_column_type fixed bin (6) unsigned unaligned;
dcl gscdv_hit bit (1) aligned;
dcl gscdv_loop fixed bin;
dcl gscdv_option_identifier_parm char (*) varying parm;
dcl gscdv_option_name_parm char (*) varying parm;
dcl gscdv_option_value_parm char (*) varying parm;
%skip(1);
          gscdv_hit = OFF;
%skip(1);
	do gscdv_loop = 1 to number_of_defined_columns while (^gscdv_hit);
	     if table_info.columns.column_name (gscdv_loop) 
		= gscdv_option_identifier_parm
	     then do;
		gscdv_hit = ON;
		gscdv_column_option_number = gscdv_loop;
	     end;
	end;
%skip(1);
	if ^gscdv_hit 
	then do;
	     gscdv_option_value_parm = "ERROR";
	     return;
	end;
%page;
          if gscdv_option_name_parm 
	     = OPTIONS.SPECIFIC_COLUMN.NAME (INDEX_FOR_ALIGNMENT)
	then do;
	     desc_ptr = addr (table_info.columns.column_data_type (
		gscdv_column_option_number));
	     gscdv_column_type = descriptor.type;
	     if (gscdv_column_type >= 1 & gscdv_column_type <= 8)             /* NUMERIC */
	     | (gscdv_column_type = 33 | gscdv_column_type = 34)
	     then gscdv_option_value_parm = RIGHT;
	     else if (gscdv_column_type >= 9 & gscdv_column_type <= 12)       /* DECIMAL */
		| (gscdv_column_type = 29 | gscdv_column_type = 30)
		| (gscdv_column_type = 35 | gscdv_column_type = 36)
		| (gscdv_column_type >= 38 & gscdv_column_type <= 46)
		then if fixed (descriptor.size.scale, 17, 0) > 0
		     then gscdv_option_value_parm = DECIMAL || BLANK || ltrim (char
		          (table_info.columns.column_length (gscdv_column_option_number)
		          - fixed (descriptor.size.scale, 17, 0)));
	               else gscdv_option_value_parm = RIGHT;
	          else if (gscdv_column_type >= 19 & gscdv_column_type <= 22) /* CHAR OR BIT */
		     then gscdv_option_value_parm = LEFT;
		     else call ssu_$abort_line (sci_ptr, 0,
		     "The table information described an unsupported data type.^/The data descriptor was ^d.", 
		     gscdv_column_type);
	end;
          else if gscdv_option_name_parm
	     = OPTIONS.SPECIFIC_COLUMN.NAME (INDEX_FOR_TITLE)
	     then gscdv_option_value_parm
	     = table_info.columns.column_name (gscdv_column_option_number);
	     else if gscdv_option_name_parm 
		= OPTIONS.SPECIFIC_COLUMN.NAME (INDEX_FOR_WIDTH)
		then gscdv_option_value_parm = ltrim (char 
		     (table_info.columns.column_length (gscdv_column_option_number)));
	          else gscdv_option_value_parm = "ERROR";
%skip(1);
     end get_specific_column_default_value;
%page;
get_named_values: proc (gnv_code_parm);
%skip(3);
/*

     This proc is called by the get_named entrypoint to get the names and
     values which match a set of option names and identifiers supplied by the
     caller of the get_named entry.  The option name can be a short or long
     name.  The column/option identifier provided can be a column name,
     column number, or star name.  The star names can only match column
     names; star name matching of column numbers is not attempted.
     Unfortunately, value_$list has an ugly little quirk of not returning the
     code error_table_$nomatch when star names result in no match, if any
     other name in the match_info structure does get a match.  So we have to
     pre-match star names or else user specified star names that don't get a
     match could well go unnoticed.

*/
%skip(1);
dcl gnv_code_parm fixed bin (35) parm;
dcl gnv_current_star_name fixed bin;
dcl gnv_inner_loop fixed bin;
dcl gnv_loop fixed bin;
dcl gnv_match_info_index fixed bin;
dcl gnv_number_of_matches fixed bin;
%skip(1);
	gnv_code_parm = 0;
%skip(1);
	alloc_name_count = no_of_options_in_name_table;
	if valid_selection_expression
	then alloc_max_name_len = MAXIMUM_NORMALIZED_OPTION_NAME_LENGTH;
	else alloc_max_name_len = MAXIMUM_OPTION_NAME_LENGTH;
%skip(1);
	star_name_info_ptr = names_and_values_temp_seg_ptr;
	star_name_info.maximum_number_of_star_names 
	     = no_of_options_in_name_table;
	star_name_info.star_name_map (*) = OFF;
	star_name_info.number_of_star_names = 1;
%skip(1);
	allocate column_map in (names_and_values_area) set (column_map_ptr);
%skip(1);
	do gnv_loop = 1 to no_of_options_in_name_table;
%skip(1);
	     call normalize_option_name (
		option_name_table.the_name (gnv_loop),
		option_name_table.the_identifier (gnv_loop),
		option_type, option_table_index, 
		normalized_option_name, gnv_code_parm);
	     if gnv_code_parm = 0
	     then if option_type = SPECIFIC_COLUMN_OPTION
		then option_name_table.the_identifier (gnv_loop)
		     = after (normalized_option_name, BLANK);
	          else option_name_table.the_identifier (gnv_loop) = "";
	     else if gnv_code_parm = error_table_$nostars
		then do;
		     call match_column_names (
			option_name_table.the_identifier (gnv_loop),
			column_map, gnv_number_of_matches, gnv_code_parm);
		     if gnv_code_parm ^= 0
		     then call ssu_$abort_line (sci_ptr, gnv_code_parm,
			"^/The column identifier ^a did not match any column names.",
			option_name_table.the_identifier (gnv_loop));
		     else;
		     if gnv_number_of_matches ^= 1
		     then alloc_name_count = alloc_name_count
			+ gnv_number_of_matches - 1;
		     star_name_info.star_name_map (gnv_loop) = ON;
		     star_name_info.column_maps_info (
			star_name_info.number_of_star_names)
			.number_of_matches = gnv_number_of_matches;
		     star_name_info.column_maps_info (
			star_name_info.number_of_star_names)
			.column_bit_map (*) = column_map (*);
		     star_name_info.number_of_star_names
			= star_name_info.number_of_star_names + 1;
		end;
		else if gnv_code_parm = linus_error_$bad_option_name
		     then call ssu_$abort_line (sci_ptr, gnv_code_parm,
		          "^/^a is not a valid option name.",
		          option_name_table.the_name (gnv_loop));
		     else if gnv_code_parm = linus_error_$bad_option_identifier
			then call ssu_$abort_line (sci_ptr, gnv_code_parm,
			     "^/^a is not a valid option identifier for ^a.",
			     option_name_table.the_identifier (gnv_loop),
		               option_name_table.the_name (gnv_loop));
			else call ssu_$abort_line (sci_ptr, gnv_code_parm);
%skip(1);
	end;
%skip(1);
	star_name_info.number_of_star_names
	     = star_name_info.number_of_star_names - 1;
%skip(1);
	allocate match_info in (names_and_values_area) set (match_info_ptr);
	match_info.version = match_info_version_1;
%skip(1);
	gnv_match_info_index = 1;
	gnv_current_star_name = 1;
	do gnv_loop = 1 to no_of_options_in_name_table;
%skip(1);
	     match_info.name_array.exclude_sw (gnv_match_info_index) = OFF;
	     match_info.name_array.regexp_sw (gnv_match_info_index) = OFF;
%skip(1);
	     if ^star_name_info.star_name_map (gnv_loop)
	     then do;
		if option_name_table.the_identifier (gnv_loop) = ""
		then match_info.name_array.name (gnv_match_info_index)
		     = option_name_table.the_name (gnv_loop);
		else match_info.name_array.name (gnv_match_info_index)
		     = option_name_table.the_name (gnv_loop)
		     || BLANK || option_name_table.the_identifier (gnv_loop);
		gnv_match_info_index = gnv_match_info_index + 1;
	     end;
	     else do;
		column_map_ptr = addr (star_name_info
		     .column_maps_info (gnv_current_star_name)
		     .column_bit_map (1));
		do gnv_inner_loop = 1 to number_of_defined_columns;
		     if column_map (gnv_inner_loop)
		     then do;
			match_info.name_array.name (gnv_match_info_index)
			     = option_name_table.the_name (gnv_loop)
			     || BLANK || table_info.columns.column_name (gnv_inner_loop);
			gnv_match_info_index = gnv_match_info_index + 1;
		     end;
		end;
		gnv_current_star_name = gnv_current_star_name + 1;
	     end;
%skip(1);
	end;
%skip(1);	
	call value_$list (value_seg_ptr, PERMANENT, match_info_ptr,
	     names_and_values_area_ptr, value_list_info_ptr, code);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code,
	     "^/Unable to get the values of the specified format options.");
	else;
%skip(1);
	no_of_names_and_values = value_list_info.pair_count;
	allocate name_value_info in (names_and_values_area) 
	     set (names_and_values_info_ptr);
%skip(1);
	do gnv_loop = 1 to no_of_names_and_values;
               name_value_info.name.length (gnv_loop) 
		= value_list_info.pairs.name_len (gnv_loop);
	     name_value_info.name.index (gnv_loop) 
		= value_list_info.pairs.name_index (gnv_loop);
               name_value_info.value.length (gnv_loop) 
		= value_list_info.pairs.value_len (gnv_loop);
	     name_value_info.value.index (gnv_loop) 
		= value_list_info.pairs.value_index (gnv_loop);
	end;
%skip(1);
	size_of_names_and_values = value_list_info.chars_len;
	allocate names_and_values in (names_and_values_area)
	     set (names_and_values_ptr);
          names_and_values = value_list_info.chars;
%skip(1);
          return;
%skip(1);
     end get_named_values;
%page;
housekeeping: proc;
%skip(3);
/*

     This procedure is called to set up various automatic versions of some of
     some things we will need to run this subroutine, and to make sure
     linus_table$info has been called.

*/
%skip(1);
	sci_ptr = lcb.subsystem_control_info_ptr;
          report_cip = lcb.report_control_info_ptr;
	value_seg_ptr = report_control_info.value_seg_ptr;
	names_and_values_area_ptr = report_control_info.name_value_area_ptr;
	names_and_values_temp_seg_ptr = report_control_info.name_value_temp_seg_ptr;
%skip(1);
	call linus_table$info (lcb_ptr, table_ip, code);
	if code ^= 0 
	then if code ^= linus_error_$no_lila_expr_processed
	     then call ssu_$abort_line (sci_ptr, code,
	          "While trying to get table information.");
	     else do;
		valid_selection_expression = OFF;
		number_of_defined_columns = 0;
	     end;
	else do;
	     valid_selection_expression = ON;
	     number_of_defined_columns = table_info.column_count;
	end;
%skip(1);
          return;
%skip(1);
     end housekeeping;
%page;
load_value_seg_with_column_defaults: proc;
%skip(3);
/*

     This procedure is called to load all of the column default values into
     the value seg.  It expects that table_info has been set and is current
     (which means there must be a valid selection expression available.)

*/
%skip(1);
dcl lvswcd_inner_loop fixed bin;
dcl lvswcd_loop fixed bin;
%skip(1);
	do lvswcd_loop = 1 to NUMBER_OF_GENERAL_COLUMN_OPTIONS_IN_TABLE;
%skip(1);
	     lvswcd_option_name = OPTIONS.GENERAL_COLUMN.NAME (lvswcd_loop);
	     lvswcd_option_value = OPTIONS.GENERAL_COLUMN.VALUE (lvswcd_loop);
	     if length (lvswcd_option_value) > 0
	     then if substr (lvswcd_option_value, 1, 1) = LEFT_BRACKET
		then do;
		     call get_general_column_default_value (
			lvswcd_option_name, lvswcd_option_value);
		     if lvswcd_option_value = "ERROR"
		     then call ssu_$abort_line (sci_ptr, 0,
			"While trying to get the default value for ^a.",
			lvswcd_option_name);
		     else;
		end;
		else;
	     else;
%skip(1);
	     call value_$set (value_seg_ptr, PERMANENT, lvswcd_option_name,
		lvswcd_option_value, returned_option_value, code);
	     if code ^= 0
	     then call ssu_$abort_line (sci_ptr, code,
		"While trying to set the value ^a for ^a.",
		lvswcd_option_value, lvswcd_option_name);
%skip(1);
	end;
%page;
	do lvswcd_loop = 1 to NUMBER_OF_SPECIFIC_COLUMN_OPTIONS_IN_TABLE;
%skip(1);
	     lvswcd_option_name = OPTIONS.SPECIFIC_COLUMN.NAME (lvswcd_loop);
%skip(1);
	     do lvswcd_inner_loop = 1 to number_of_defined_columns;
%skip(1);
		lvswcd_option_identifier 
		     = table_info.columns.column_name (lvswcd_inner_loop);
		normalized_option_name
		     = lvswcd_option_name || BLANK || lvswcd_option_identifier;
		lvswcd_option_value = OPTIONS.SPECIFIC_COLUMN.VALUE (lvswcd_loop);
		if length (lvswcd_option_value) > 0
		then if substr (lvswcd_option_value, 1, 1) = LEFT_BRACKET
		     then do;
			call get_specific_column_default_value (
			     lvswcd_option_name, lvswcd_option_identifier,
			     lvswcd_option_value);
			if lvswcd_option_value = "ERROR"
			then call ssu_$abort_line (sci_ptr, 0,
			     "While trying to get the default value for ^a.",
			     normalized_option_name);
			else;
		     end;
		     else;
		else;
%skip(1);
		call value_$set (value_seg_ptr, PERMANENT, 
		     normalized_option_name, lvswcd_option_value, 
		     returned_option_value, code);
		if code ^= 0
		then call ssu_$abort_line (sci_ptr, code,
		     "While trying to set the value ^a for ^a.",
		     lvswcd_option_value, normalized_option_name);
%skip(1);
	     end;
%skip(1);
	end;
%skip(1);
	report_control_info.options_identifier
	     = report_control_info.options_identifier + 1;
	report_control_info.selection_expression_identifier
	     = lcb.selection_expression_identifier;
	report_control_info.format_options_flags
	     .general_column_default_value (*) = ON;
%skip(1);
          return;
%skip(1);
     end load_value_seg_with_column_defaults;
%page;
load_value_seg_with_report_defaults: proc;
%skip(3);
/*

     This proc is called to load the value seg with the general report option
     defaults from the OPTIONS.GENERAL_REPORT table found in the include file
     linus_format_options.incl.pl1.

*/
%skip(1);
dcl lvswrd_loop fixed bin;
%skip(1);
          do lvswrd_loop = 1 to NUMBER_OF_GENERAL_REPORT_OPTIONS_IN_TABLE;
%skip(1);
	     call value_$set (value_seg_ptr, PERMANENT, 
		OPTIONS.GENERAL_REPORT.NAME (lvswrd_loop), 
		OPTIONS.GENERAL_REPORT.VALUE (lvswrd_loop), 
		returned_option_value, code);
	     if code ^= 0 
	     then call ssu_$abort_line (sci_ptr, code,
		"While trying to set the value ^a for ^a.",
		OPTIONS.GENERAL_REPORT.VALUE (lvswrd_loop), 
		OPTIONS.GENERAL_REPORT.NAME (lvswrd_loop));
%skip(1);
	end;
%skip(1);
	report_control_info.options_identifier = 
	     report_control_info.options_identifier + 1;
	report_control_info.format_options_flags.general_report_default_value (*) = ON;
%skip(1);
	return;
%skip(1);
     end load_value_seg_with_report_defaults;
%page;
lookup_option_number: proc (

	lon_option_name_parm,  /* input: option name to look up */
	lon_option_type_parm,  /* output: the table to index into */
	lon_option_index_parm  /* output: the index into the table */
		       );
%skip(1);
/*
     
     This proc looks up option names from the three tables of option names.
     lon_option_name_parm is expected to contain the name of the option.
     lon_option_type_parm is set to indicate whether it is a general report,
     general column, or specific column option. lon_option_index_parm is
     the index into the appropriate table so the caller can obtain its value.

*/
%skip(1);
dcl lon_loop fixed bin;
dcl lon_option_name_parm char (*) varying parm;
dcl lon_option_type_parm fixed bin parm;
dcl lon_option_index_parm fixed bin parm;
%skip(1);
	lon_option_type_parm = 0;
%skip(1);
          lon_option_index_parm = lookup_general_report_option ();
	if lon_option_index_parm ^= 0
	then do;
	     lon_option_type_parm = GENERAL_REPORT_OPTION;
	     return;
	end;
%skip(1);
	lon_option_index_parm = lookup_general_column_option ();
	if lon_option_index_parm ^= 0
	then do;
	     lon_option_type_parm = GENERAL_COLUMN_OPTION;
	     return;
	end;
%skip(1);
	lon_option_index_parm = lookup_specific_column_option ();
	if lon_option_index_parm ^= 0
	then lon_option_type_parm = SPECIFIC_COLUMN_OPTION;
%skip(1);
	return;
%page;
lookup_general_column_option: proc () returns (fixed bin);
%skip(1);
	/* Look up the option name from the general column names table. */
%skip(1);
	do lon_loop = 1 to NUMBER_OF_GENERAL_COLUMN_OPTIONS_IN_TABLE;
	     if lon_option_name_parm = OPTIONS.GENERAL_COLUMN.NAME (lon_loop)
	     then return (lon_loop);
	end;
%skip(1);
	return (0);
%skip(1);
     end lookup_general_column_option;
%skip(3);
lookup_general_report_option: proc () returns (fixed bin);
%skip(1);
	/* Look up the option name from the general report names table. */
%skip(1);
	do lon_loop = 1 to NUMBER_OF_GENERAL_REPORT_OPTIONS_IN_TABLE;
	     if lon_option_name_parm = OPTIONS.GENERAL_REPORT.NAME (lon_loop)
	     then return (lon_loop);
	end;
%skip(1);
	return (0);
%skip(1);
     end lookup_general_report_option;
%skip(3);
lookup_specific_column_option: proc () returns (fixed bin);
%skip(1);
	/* Look up the option name from the specific column names table. */
%skip(1);
	do lon_loop = 1 to NUMBER_OF_SPECIFIC_COLUMN_OPTIONS_IN_TABLE;
	     if lon_option_name_parm = OPTIONS.SPECIFIC_COLUMN.NAME (lon_loop)
	     then return (lon_loop);
	end;
%skip(1);
	return (0);
%skip(1);
     end lookup_specific_column_option;
%skip(1);
     end lookup_option_number;
%page;
match_column_names: proc (

	mcn_star_name_parm,         /* input: star name to match */
	mcn_column_map_parm,        /* input/output: array of match bits */
	mcn_number_of_matches_parm, /* output: number of matches */
	mcn_code_parm	        /* output: success or failure */
		     );
%skip(3);
/*

     This proc is called with a star name to determine which columns match
     it. The variable mcn_star_name_parm contains the variable which is used
     to try to get a match. The array mcn_column_map_parm contains one bit
     for each defined column. Each column that matches the star name has its
     corresponding bit turned on, and the variable mcn_number_of_matches_parm
     contains the number of columns that matched. The variable mcn_code_parm
     is set to reflect any problems encountered.

*/
%skip(1);
dcl mcn_code_parm fixed bin (35) parm;
dcl mcn_loop fixed bin;
dcl mcn_column_map_parm (*) bit (1) parm;
dcl mcn_number_of_matches fixed bin;
dcl mcn_number_of_matches_parm fixed bin parm;
dcl mcn_star_name_parm char (*) varying parm;
%skip(1);
	mcn_column_map_parm (*) = OFF;
	mcn_number_of_matches_parm = 0;
	mcn_code_parm = 0;
%skip(1);
	if hbound (mcn_column_map_parm, 1) ^= number_of_defined_columns
	then call ssu_$abort_line (sci_ptr, 0, "^a ^a^/^a",
	     "Invalid use of match_column_names by ", me,
	     "The match table was not equal to the number of defined columns.");
	else;
%skip(1);
	mcn_number_of_matches = 0;
	do mcn_loop = 1 to number_of_defined_columns;
	     call match_star_name_ (
		(table_info.columns.column_name (mcn_loop)), 
		(mcn_star_name_parm), mcn_code_parm);
	     if mcn_code_parm = 0
	     then do;
		mcn_column_map_parm (mcn_loop) = ON;
		mcn_number_of_matches = mcn_number_of_matches + 1;
	     end;
	     else if mcn_code_parm ^= error_table_$nomatch
		then return;
	          else;
	end;
%skip(1);
	if mcn_number_of_matches ^= 0
	then do;
	     mcn_number_of_matches_parm = mcn_number_of_matches;
	     mcn_code_parm = 0;
	end;
	else;
%skip(1);
	return;
%skip(1);
     end match_column_names;
%page;
normalize_option_name: proc (

	non_option_name_parm,            /* input: the option name */
	non_option_identifier_parm,      /* input: the column name or number */
	non_option_type_parm,            /* output: the type of option */
	non_option_table_index_parm,     /* output: index into options table */
	non_normalized_option_name_parm, /* output: the option and column name */
	non_code_parm		   /* output: success or failure */
		        );
%skip(1);
/*

     This proc is called to set general purpose info about the option currently
     being dealt with.  It expects non_option_name_parm to contain a name
     which can be used to determine whether or not it requires an identifier.
     The option_name must already have been expanded into a long name (see
     the "check_name" entry for expansion of option names).  If an
     identifier is needed, it expects non_option_identifier_parm to contain
     it.  The identifier can be the name of a column or the position of the
     column in the LILA select.  If the identifier is a star name or invalid,
     non_code_parm is set.  It places the option name into
     non_normalized_option_name_parm if a column identifier isn't needed, and
     the option name and column name in it when an identifier is needed.
     When errors occur normalized_option_name is set to "", except for
     starnames.  The variable non_option_type_parm is set to flag whether it
     is a general report, general column, or specific column option.  The
     variable non_option_table_index_parm is set so the caller can index into
     the appropriate options table.

*/
%skip(1);
dcl non_code_parm fixed bin (35) parm;
dcl non_column_option_number fixed bin;
dcl non_loop fixed bin;
dcl non_normalized_option_name_parm char (*) varying parm;
dcl non_option_identifier_parm char (*) varying parm;
dcl non_option_name_parm char (*) varying parm;
dcl non_option_table_index_parm fixed bin parm;
dcl non_option_type_parm fixed bin parm;
%skip(3);
	non_normalized_option_name_parm = "";
          non_code_parm = 0;
%skip(1);
	call lookup_option_number (non_option_name_parm,
	     non_option_type_parm, non_option_table_index_parm);
	if non_option_table_index_parm = 0
	then do;
	     non_code_parm = linus_error_$bad_option_name;
	     return;
	end;
%skip(1);	
	if (non_option_type_parm = GENERAL_COLUMN_OPTION 
	| non_option_type_parm = SPECIFIC_COLUMN_OPTION)
          & (^valid_selection_expression)
	then do;
	     code = linus_error_$no_lila_expr_processed;
	     return;
	end;
	else;
%skip(1);
          if non_option_type_parm = GENERAL_REPORT_OPTION
	| non_option_type_parm = GENERAL_COLUMN_OPTION
	then do;
	     non_normalized_option_name_parm = non_option_name_parm;
	     return;
	end;
%skip(1);
	if search (non_option_identifier_parm, STAR_OR_QUESTION_MARK) ^= 0
	then do;
	     non_code_parm = error_table_$nostars;
	     non_normalized_option_name_parm = non_option_name_parm
		|| BLANK || non_option_identifier_parm;
	     return;
	end;
%skip(1);
          if verify (non_option_identifier_parm, DIGITS) = 0
	then do;
	     non_column_option_number = convert (non_column_option_number, 
		non_option_identifier_parm);
	     if non_column_option_number < 1
	     | non_column_option_number > number_of_defined_columns
	     then non_code_parm = linus_error_$bad_option_identifier;
	     else non_normalized_option_name_parm = 
		non_option_name_parm || BLANK
		|| table_info.columns.column_name (non_column_option_number);
	     return;
	end;
%skip(1);
          do non_loop = 1 to number_of_defined_columns;
	     if non_option_identifier_parm = table_info.columns.column_name (non_loop)
	     then do;
		non_normalized_option_name_parm =
		     non_option_name_parm || BLANK || non_option_identifier_parm;
		return;
	     end;
	end;
%skip(1);
          non_code_parm = linus_error_$bad_option_identifier;
%skip(1);
	return;
%skip(1);
     end normalize_option_name;
%page;
release_temp_segment: proc (

	rts_ptr_parm	/* input: ptr to temp segment */
			      );
%skip(3);
dcl rts_code fixed bin (35);
dcl rts_ptr_parm ptr parm;
%skip(1);
	call release_temp_segment_ (me, rts_ptr_parm, rts_code);
	if rts_code ^= 0
	then call ssu_$print_message (sci_ptr, rts_code,
	     "While trying to release the temporary segment pointed to by ^/^p.", rts_ptr_parm);
%skip(1);
	return;
%skip(1);
     end release_temp_segment;
%page;
set_the_values: proc (

	stv_option_name_parm,	   /* input: option name */
	stv_option_identifier_parm,	   /* input: column identifier */
	stv_option_value_parm,	   /* input: option value */
	stv_system_default_parm,	   /* input: on means yes */
	stv_code_parm		   /* output: success or failure */
		   );
%skip(1);
/*

     This proc is called to set the value of a format option. If the value
     is a star name then the value is set for every name that matches the
     star name. The internal proc set_value sets the value. For a normal
     column name, it is called once with normalized_option_name used for
     the set operation. For star names, normalized_option_name is changed
     before each call with a column name that matched the star name.

*/     
%skip(1);
dcl stv_code_parm fixed bin (35) parm;
dcl stv_loop fixed bin;
dcl stv_number_of_matches fixed bin;
dcl stv_option_name_parm char (*) varying parm;
dcl stv_option_identifier_parm char (*) varying parm;
dcl stv_option_value_parm char (*) varying parm;
dcl stv_system_default_parm bit (1) aligned parm;
dcl stv_value_has_been_tested bit (1) aligned;
%skip(1);
	call normalize_option_name (stv_option_name_parm, 
	     stv_option_identifier_parm, option_type, option_table_index, 
	     normalized_option_name, stv_code_parm);
	if stv_code_parm = 0
	then do;
	     call set_value (stv_code_parm);
	     return;
	end;
	else if stv_code_parm ^= error_table_$nostars
	     then return;
%skip(1);
	allocate column_map in (names_and_values_area) 
	     set (column_map_ptr);
	call match_column_names (stv_option_identifier_parm,
	     column_map, stv_number_of_matches, stv_code_parm);
	if stv_code_parm ^= 0
	then return;
%page;
	do stv_loop = 1 to number_of_defined_columns;
%skip(1);
	     if column_map (stv_loop)
	     then do;
		normalized_option_name = stv_option_name_parm
		     || BLANK || table_info.columns.column_name (stv_loop);
		call set_value (stv_code_parm);
		if stv_code_parm ^= 0
		then return;
	     end;
%skip(1);
	end;
%skip(1);
	return;
%page;
set_value: proc (

	sv_code_parm		   /* output: success or failure */
		   );
%skip(3);
/*

     This proc is called to set the value of a format option.  The variable
     stv_system_default_parm is used to determine if the caller wants the
     system default value for the named option.  normalized_option_name is
     used to determine who's to be set.  stv_option_value_parm is the value
     which will be set if stv_system_default_parm is off.  option_type and
     option_table_index are used to find the value which will be set when
     stv_system_default_parm is on. The bit that indicates whether or not
     a value is the same as the system default is set for the general report
     and general column options. These bits are used by the get_active entry
     to determine which values are considered active. If the caller requested
     that it be set to the system default, the value is set from the OPTIONS
     table. General column and specific column values from this table
     sometimes need the actual value computed based on the current set of
     columns. These values are recognizable because they begin with a left 
     bracket. The procs get_general_column_default_value and 
     get_specific_column_default_value are called to compute the value. There
     is a dependency between the -group option and the two options 
     -group_footer_trigger and -group_header_trigger. If the -group option
     is being set back to the default then the function valid_option_value is
     invoked to make sure the other two are set back to their defaults.

*/
%skip(3);
dcl sv_code_parm fixed bin (35) parm;
dcl sv_force_group_triggers_consistency bit (1);
%skip(1);
	sv_code_parm = 0;
%skip(1);
	if ^stv_system_default_parm
	then do;
	     sv_option_value = stv_option_value_parm;
	     if ^valid_option_value (stv_option_name_parm, sv_option_value)
	     then do;
		stv_code_parm = linus_error_$bad_option_value;
		return;
	     end;
	     else;
	end;
	else do;
	     if option_type = GENERAL_REPORT_OPTION
	     then do;
		sv_option_value 
		     = OPTIONS.GENERAL_REPORT.VALUE (option_table_index);
		report_control_info.format_options_flags.
		     general_report_default_value (option_table_index) = ON;
	     end;
	     else if option_type = GENERAL_COLUMN_OPTION
		then do;
		     sv_option_value
			= OPTIONS.GENERAL_COLUMN.VALUE (option_table_index);
		     if length (sv_option_value) > 0
		     then if substr (sv_option_value, 1, 1) = LEFT_BRACKET
			then call get_general_column_default_value (
			     stv_option_name_parm, sv_option_value);
		          else;
		     else if stv_option_name_parm = OPTIONS.GENERAL_COLUMN.NAME (INDEX_FOR_GROUP)
			then sv_force_group_triggers_consistency
			     = valid_option_value (stv_option_name_parm, sv_option_value);
		          else;
		     report_control_info.format_options_flags.
			general_column_default_value (option_table_index) = ON;
		end;
	          else do;
		     sv_option_value = 
			OPTIONS.SPECIFIC_COLUMN.VALUE (option_table_index);
		     if length (sv_option_value) > 0
		     then if substr (sv_option_value, 1, 1) = LEFT_BRACKET
			then do;
			     sv_spare_option_identifier 
				= after (normalized_option_name, BLANK);
			     call get_specific_column_default_value (
				stv_option_name_parm,
				sv_spare_option_identifier,
				sv_option_value);
			end;
		          else;
		     else;
		end;
	     if sv_option_value = "ERROR"
	     then call ssu_$abort_line (sci_ptr, 0,
		"Unable to set the value of ^a to the system default.",
		normalized_option_name);
	end;
%skip(1);
          call value_$set (value_seg_ptr, PERMANENT,
	     normalized_option_name, sv_option_value,
	     returned_option_value, code);
%skip(1);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code,
	     "While trying to set the value ^a for ^a.",
	     sv_option_value, normalized_option_name);
%skip(1);
	report_control_info.options_identifier = 
	     report_control_info.options_identifier + 1;
%skip(1);
     	if stv_system_default_parm 
	| option_type = SPECIFIC_COLUMN_OPTION
	then return;
%page;
     	if option_type = GENERAL_REPORT_OPTION
	then do;
	     if sv_option_value
	     = OPTIONS.GENERAL_REPORT.VALUE (option_table_index)
	     then report_control_info.format_options_flags.
		general_report_default_value (option_table_index) = ON;
	     else report_control_info.format_options_flags.
		general_report_default_value (option_table_index) = OFF;
	end;
	else do;
	     stv_value_has_been_tested = OFF;
	     if length (sv_option_value) > 0
	     & length (OPTIONS.GENERAL_COLUMN.VALUE (option_table_index)) > 0
	     then if substr (OPTIONS.GENERAL_COLUMN.VALUE (
		option_table_index), 1, 1) = LEFT_BRACKET
		then do;
		     call get_general_column_default_value (
			stv_option_name_parm, sv_spare_option_value);
		     if sv_spare_option_value = "ERROR"
		     then call ssu_$abort_line (sci_ptr, 0,
			"Unable to get the default value of ^a.",
			stv_option_name_parm);
		     else;
		     stv_value_has_been_tested = ON;
		     if sv_option_value = sv_spare_option_value
		     then report_control_info.format_options_flags.
			general_column_default_value (option_table_index) = ON;
		     else report_control_info.format_options_flags.
			general_column_default_value (option_table_index) = OFF;
		end;
		else;
	     else;
	     if ^stv_value_has_been_tested
	     then if sv_option_value
		= OPTIONS.GENERAL_COLUMN.VALUE (option_table_index)
		then report_control_info.format_options_flags.
		     general_column_default_value (option_table_index) = ON;
		else report_control_info.format_options_flags.
		     general_column_default_value (option_table_index) = OFF;
	     else;
	end;
%skip(1);
	return;
%skip(1);
     end set_value;
%skip(1);
     end set_the_values;
%page;
setup_to_do_reporting: proc;
%skip(3);
/*

     This proc is called to setup all the areas, temp segs, etc.  that are
     needed to produce linus reports through the display request.  Each
     "thing" it needs is described below before it is created.

*/
%skip(1);
	sci_ptr = lcb.subsystem_control_info_ptr;
%skip(1);
          /* Create the info structure. */
%skip(1);
          allocate report_control_info in (lcb.static_area)
	     set (report_cip);
          unspec (report_control_info) = OFF;
%skip(1);
          /* Create the value segment. */
%skip(1);
	call hcs_$make_seg (get_pdir_(), "linus_format_options.value", "", 
	     REW_ACCESS_BIN, value_seg_ptr, code);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code,
	     "^a", "While trying to create the options' value segment.");
%skip(1);
          /* Initialize its contents. */
%skip(1);
	call value_$init_seg (value_seg_ptr, 0, null(), 0, code);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code,
	     "^a", "While trying to initialize the options' value segment.");
          report_control_info.value_seg_ptr = value_seg_ptr;
%skip(1);
          /* Create a temp seg for name-value allocations. Define an area
             over it. This area will be emptied from now on every time
             the initialize entrypoint is called, via a call to 
             release_area_. */
%skip(1);
          call get_temp_segment_ (me, temp_seg_ptr, code);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code,
	     "While trying to create a temporary segment for the options.");
          names_and_values_area_ptr = temp_seg_ptr;
	call mdbm_util_$mu_define_area (names_and_values_area_ptr, 
	     (sys_info$max_seg_size), "options.LIN", EXTENSIBLE, 
	     NON_FREEING, NO_ZERO_ON_ALLOC, NO_ZERO_ON_FREE, code);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code,
	     "While trying to define an area for allocations of options.");
	report_control_info.name_value_area_ptr = names_and_values_area_ptr;
%skip(1);
          /* Create a temp seg for star name processing and other temp operations. */
%skip(1);
          call get_temp_segment_ (me, temp_seg_ptr, code);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code,
	     "While trying to create a temporary segment for the options.");
	report_control_info.name_value_temp_seg_ptr = temp_seg_ptr;
%skip(1);
	/* Create a temp seg/area for display work space. */
%skip(1);
          call get_temp_segment_ (me, temp_seg_ptr, code);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code,
	     "While trying to create a temporary segment for the options.");
	call mdbm_util_$mu_define_area (temp_seg_ptr, 
	     (sys_info$max_seg_size), "display.LIN", EXTENSIBLE, 
	     NON_FREEING, NO_ZERO_ON_ALLOC, NO_ZERO_ON_FREE, code);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code,
	     "While trying to define an area for allocations for display.");
	report_control_info.display_work_area_ptr = temp_seg_ptr;
%skip(1);
          /* Create a temp seg for holding the formatted page. */
%skip(1);
          call get_temp_segment_ (me, temp_seg_ptr, code);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code,
	     "While trying to create a temporary segment for the report.");
	report_control_info.report_temp_seg_ptr = temp_seg_ptr;
%skip(1);
          /* Create a temp seg for report allocations. Define an 
             area over it. */
%skip(1);
          call get_temp_segment_ (me, temp_seg_ptr, code);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code,
	     "While trying to create a temporary segment for the report.");
	call mdbm_util_$mu_define_area (temp_seg_ptr,
	     (sys_info$max_seg_size), "options.LIN", EXTENSIBLE, 
	     NON_FREEING, NO_ZERO_ON_ALLOC, NO_ZERO_ON_FREE, code);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code,
	     "While trying to define an area for allocations of report information.");
	report_control_info.report_work_area_ptr = temp_seg_ptr;
%skip(1);
	/* Create 4 temp segs for report building workspace. */
%skip(1);
	call get_temp_segment_ (me, temp_seg_ptr, code);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code,
	     "While trying to create a temporary segment for the report.");
	report_control_info.input_string_temp_seg_ptr = temp_seg_ptr;
%skip(1);
	call get_temp_segment_ (me, temp_seg_ptr, code);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code,
	     "While trying to create a temporary segment for the report.");
	report_control_info.output_string_temp_seg_ptr = temp_seg_ptr;
%skip(1);
	call get_temp_segment_ (me, temp_seg_ptr, code);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code,
	     "While trying to create a temporary segment for the report.");
	report_control_info.editing_strings_temp_seg_ptr = temp_seg_ptr;
%skip(1);
	call get_temp_segment_ (me, temp_seg_ptr, code);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code,
	     "While trying to create a temporary segment for the report.");
	report_control_info.headers_temp_seg_ptr = temp_seg_ptr;
%skip(1);
          /* Set a few values so we start cleanly */
%skip(1);
	report_control_info.format_report_info_ptr = null ();
	report_control_info.display_iocb_ptr = null ();
	report_control_info.temp_dir_name = get_pdir_ ();
	allocate status_branch in (names_and_values_area) set (status_ptr);
	call expand_pathname_ (report_control_info.temp_dir_name,
	     directory_name, entry_name, code);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code,
	     "While trying to expand ^a.", report_control_info.temp_dir_name);
	call hcs_$status_long (directory_name, entry_name, 1,
	     status_ptr, null (), code);
	if code ^= 0 & code ^= error_table_$no_s_permission
	then call ssu_$abort_line (sci_ptr, code,
	     "While trying to determine the unique id of ^a.",
	     report_control_info.temp_dir_name);
	report_control_info.temp_dir_unique_id = status_branch.long.uid;
%skip(1);
          return;
%skip(1);
     end setup_to_do_reporting;
%page;
valid_option_value: proc (

	vov_option_name_parm,	/* input: option name */
	vov_option_value_parm	/* input: option value */
		     ) returns (bit (1));
%skip(3);
/*

     This function is invoked to check the value for an option.  It expects
     that vov_option_name_parm contains a valid option name which has been
     expanded, and that vov_option_value_parm contains the value to check for
     validity.  This function calls an internal procedure to do the checking.
     These internal procedures are declared in the three tables immediately
     following this description.  If it is a valid value, "1"b is returned.
     "0"b indicates an invalid value.

*/
%skip(1);
dcl vov_any_or_all bit (1) aligned;
dcl vov_check_result_bit bit (1) aligned;
%skip(1);
dcl vov_check_procs_for_general_report_options (NUMBER_OF_GENERAL_REPORT_OPTIONS_IN_TABLE) entry init (

check_any_single_printable_character,	/* "-delimiter" */
check_on_or_off,			/* "-format_document_controls" */
check_on_or_off,			/* "-hyphenation" */
check_any_character_string,		/* "-page_footer_value" */
check_any_character_string,		/* "-page_header_value" */
check_zero_or_greater_than_six,	/* "-page_length" */
check_zero_or_any_positive_integer,	/* "-page_width" */
check_on_or_off,			/* "-title_line" */
check_any_printable_string_no_NL	/* "-truncation" */
);
%skip(1);
dcl vov_check_procs_for_general_column_options (NUMBER_OF_GENERAL_COLUMN_OPTIONS_IN_TABLE) entry init (

check_all_column_names_eventually,	/* "-column_order" */
check_any_column_names_or_none,	/* "-count" */
check_any_column_names_or_none,	/* "-exclude" */
check_and_keep_triggers_consistent,	/* "-group" */
check_any_valid_group_list,		/* "-group_footer_trigger" */
check_any_character_string,		/* "-group_footer_value" */
check_any_valid_group_list,		/* "-group_header_trigger" */
check_any_character_string,		/* "-group_header_value" */
check_any_column_names_or_none,	/* "-outline" */
check_any_column_names_or_none,	/* "-page_break" */
check_any_character_string,		/* "-row_footer_value" */
check_any_character_string,		/* "-row_header_value" */
check_subcount_list_or_none,		/* "-subcount" */
check_subtotal_list_or_none,		/* "-subtotal" */
check_any_column_names_or_none	/* "-total" */
);
%skip(1);
dcl vov_check_procs_for_specific_column_options (NUMBER_OF_SPECIFIC_COLUMN_OPTIONS_IN_TABLE) entry init (

check_any_alignment_mode,		/* "-alignment" */
check_any_character_string,		/* "-editing" */
check_any_folding_action,		/* "-folding" */
check_any_printable_string_no_NL,	/* "-separator" */
check_any_character_string,		/* "-title" */
check_any_positive_integer		/* "-width" */
);
%skip(1);
dcl vov_character_string char (80) varying;
dcl vov_complete_the_list bit (1) aligned;
dcl vov_loop fixed bin;
dcl vov_loop_limit fixed bin;
dcl vov_number_tester fixed bin;
dcl vov_one_to_nine_found bit (1) aligned;
dcl vov_option_name_parm char (*) varying parm;
dcl vov_option_value_parm char (*) varying parm;
dcl vov_target_character char (1);
%skip(3);
          vov_check_result_bit = OFF;
%skip(1);
	call lookup_option_number (vov_option_name_parm,
	     option_type, option_table_index);
	if option_table_index = 0
	then return (OFF);
%skip(1);
	if option_type = GENERAL_REPORT_OPTION
	then call vov_check_procs_for_general_report_options (option_table_index);
	else if option_type = GENERAL_COLUMN_OPTION
	     then call vov_check_procs_for_general_column_options (option_table_index);
	     else call vov_check_procs_for_specific_column_options (option_table_index);
%skip(1);
          return (vov_check_result_bit);
%page;
check_all_column_names_eventually: proc;
%skip(3);
	vov_any_or_all = ANY;
	vov_complete_the_list = ON;
          vov_check_result_bit = replace_column_list_after_checking (judgement_table_ptr);
%skip(1);
          return;
%skip(1);
     end check_all_column_names_eventually;
%page;
check_and_keep_triggers_consistent: proc;
%skip(1);
dcl caktc_group_list_ptr ptr;
dcl caktc_inner_loop fixed bin;
dcl caktc_loop fixed bin;
%skip(3);
	if vov_option_value_parm = ""
	then do;
	     do caktc_loop = INDEX_FOR_GROUP_HEADER_TRIGGER, INDEX_FOR_GROUP_FOOTER_TRIGGER;
		call value_$set (value_seg_ptr, PERMANENT,
		     OPTIONS.GENERAL_COLUMN.NAME (caktc_loop),
		     OPTIONS.GENERAL_COLUMN.VALUE (caktc_loop),
		     returned_option_value, code);
		if code ^= 0
		then call ssu_$abort_line (sci_ptr, code,
		     "While trying to set the value ^a for ^a.",
		     OPTIONS.GENERAL_COLUMN.NAME (caktc_loop),
		     OPTIONS.GENERAL_COLUMN.VALUE (caktc_loop));
		report_control_info.format_options_flags.
		     general_column_default_value (caktc_loop) = ON;
	     end;
	     vov_check_result_bit = ON;
	     return;
	end;
%skip(1);
	vov_any_or_all = ANY;
	vov_complete_the_list = OFF;
	vov_check_result_bit = replace_column_list_after_checking (judgement_table_ptr);
	if ^vov_check_result_bit
	then return;
%skip(1);
	caktc_group_list_ptr = judgement_table_ptr;
	caktc_option_value = vov_option_value_parm;
	do caktc_loop = INDEX_FOR_GROUP_HEADER_TRIGGER, INDEX_FOR_GROUP_FOOTER_TRIGGER;
	     call value_$get (value_seg_ptr, PERMANENT, OPTIONS.GENERAL_COLUMN.NAME (caktc_loop),
		vov_option_value_parm, code);
	     if code ^= 0
	     then call ssu_$abort_line (sci_ptr, code,
		"While trying to get the value of ^a.",
		OPTIONS.GENERAL_COLUMN.NAME (caktc_loop));
	     if vov_option_value_parm ^= ""
	     then do;
		vov_check_result_bit = replace_column_list_after_checking (judgement_table_ptr);
		do caktc_inner_loop = 1 to number_of_defined_columns;
		     if judgement_table.present (caktc_inner_loop)
		     then if ^(caktc_group_list_ptr -> judgement_table.present (caktc_inner_loop))
			then judgement_table.present (caktc_inner_loop) = OFF;
		          else;
		     else;
		end;
		vov_option_value_parm = "";
		do caktc_inner_loop = 1 to number_of_defined_columns;
		     if judgement_table.present (caktc_inner_loop)
		     then vov_option_value_parm = vov_option_value_parm
			|| table_info.columns (caktc_inner_loop).column_name || BLANK;
		     else;
		end;
		vov_option_value_parm = rtrim (vov_option_value_parm);
		call value_$set (value_seg_ptr, PERMANENT,
		     OPTIONS.GENERAL_COLUMN.NAME (caktc_loop), vov_option_value_parm,
		     returned_option_value, code);
		if code ^= 0
		then call ssu_$abort_line (sci_ptr, code,
		     "While trying to set the value ^a for ^a.",
		     vov_option_value_parm, OPTIONS.GENERAL_COLUMN.NAME (caktc_loop));
		if vov_option_value_parm = ""
		then report_control_info.format_options_flags.
		     general_column_default_value (caktc_loop) = ON;
	     end;
	end;
%skip(1);
	vov_check_result_bit = ON;
	vov_option_value_parm = caktc_option_value;
%skip(1);
	return;
%skip(1);
     end check_and_keep_triggers_consistent;
%page;
check_any_alignment_mode: proc;
%skip(3);
          if vov_option_value_parm = RIGHT
          | vov_option_value_parm = LEFT
          | vov_option_value_parm = CENTER
	| vov_option_value_parm = BOTH
	then vov_check_result_bit = ON;
	else do;
	     vov_character_string = before (vov_option_value_parm, BLANK);
	     if vov_character_string ^= DECIMAL
	     then return;
	     vov_character_string 
		= ltrim (rtrim (after (vov_option_value_parm, DECIMAL)));
	     if verify (vov_character_string, DIGITS) = 0
	     then if convert (vov_loop, vov_character_string) ^= 0
		then vov_check_result_bit = ON;
	          else;
	     else;
	end;
%skip(1);
          return;
%skip(1);
     end check_any_alignment_mode;
%page;
check_any_character_string: proc;
%skip(3);
          vov_check_result_bit = ON;
%skip(1);
	return;
%skip(1);
     end check_any_character_string;
%skip(1);
check_any_column_names_or_none: proc;
%skip(3);
          if vov_option_value_parm = ""
	then do;
	     vov_check_result_bit = ON;
	     return;
	end;
	vov_any_or_all = ANY;
	vov_complete_the_list = OFF;
	vov_check_result_bit = replace_column_list_after_checking (judgement_table_ptr);
%skip(1);
	return;
%skip(1);
     end check_any_column_names_or_none;
%skip(3);
check_any_folding_action: proc;
%skip(3);
          if vov_option_value_parm = FILL
	| vov_option_value_parm = TRUNCATE
          then vov_check_result_bit = ON;
%skip(1);
          return;
%skip(1);
     end check_any_folding_action;
%page;
check_any_printable_string_no_NL: proc;
%skip(3);
          vov_loop_limit = length (vov_option_value_parm);
	if vov_loop_limit = 0
	then  do;
	     vov_check_result_bit = ON;
	     return;
	end;
	do vov_loop = 1 to vov_loop_limit;
	     vov_target_character = substr (vov_option_value_parm, vov_loop, 1);
	     if vov_target_character < BLANK
	     | vov_target_character > TILDE
	     then return;
	end;
          vov_check_result_bit = ON;
%skip(1);
          return;
%skip(1);
     end check_any_printable_string_no_NL;
%skip(3);
check_any_single_printable_character: proc;
%skip(3);
          if length (vov_option_value_parm) = 1
	then if vov_option_value_parm >= BLANK 
	     & vov_option_value_parm <= TILDE
	     then vov_check_result_bit = ON;
	     else;
	else;
%skip(1);
          return;
%skip(1);
     end check_any_single_printable_character;
%page;
check_any_positive_integer: proc;
%skip(3);
          vov_loop_limit = length (vov_option_value_parm);
	if vov_loop_limit = 0
	then return;
	vov_one_to_nine_found = OFF;
	do vov_loop = 1 to vov_loop_limit;
	     vov_target_character = substr (vov_option_value_parm, vov_loop, 1);
	     if vov_target_character < ZERO
	     | vov_target_character > NINE
	     then return;
	     if vov_target_character ^= ZERO
	     then vov_one_to_nine_found = ON;
	end;
	if vov_one_to_nine_found
          then vov_check_result_bit = ON;
%skip(1);
          return;
%skip(1);
     end check_any_positive_integer;
%page;
check_any_valid_group_list: proc;
%skip(1);
dcl cavgl_group_list_judgement_table_ptr ptr;
dcl cavgl_loop fixed bin;
%skip(3);
	if vov_option_value_parm = ""
	then do;
	     vov_check_result_bit = ON;
	     return;
	end;
	vov_any_or_all = ANY;
	vov_complete_the_list = OFF;
	vov_check_result_bit = replace_column_list_after_checking (judgement_table_ptr);
	if ^vov_check_result_bit
	then return;
	cavgl_group_list_judgement_table_ptr = judgement_table_ptr;
	cavgl_save_option_value = vov_option_value_parm;
	call value_$get (value_seg_ptr, PERMANENT, OPTIONS.GENERAL_COLUMN.NAME
	     (INDEX_FOR_GROUP), vov_option_value_parm, code);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code,
	     "While trying to get the value of ^a.", 
	     OPTIONS.GENERAL_COLUMN.NAME (INDEX_FOR_GROUP));
	vov_check_result_bit = replace_column_list_after_checking (judgement_table_ptr);
	if ^vov_check_result_bit
	then return;
	vov_option_value_parm = cavgl_save_option_value;
	vov_check_result_bit = OFF;
%skip(1);
	do cavgl_loop = 1 to number_of_defined_columns;
	     if cavgl_group_list_judgement_table_ptr -> judgement_table.present (cavgl_loop)
	     then if ^judgement_table.present (cavgl_loop)
		then return;
	          else;
	     else;
	end;
	vov_check_result_bit = ON;
%skip(1);
	return;
%skip(1);
     end check_any_valid_group_list;
%page;
check_on_or_off: proc;
%skip(3);
	if vov_option_value_parm = "on"
	| vov_option_value_parm = "off"
          then vov_check_result_bit = ON;
%skip(1);
	return;
%skip(1);
     end check_on_or_off;
%page;
check_subcount_list_or_none: proc;
%skip(3);
	if vov_option_value_parm = ""
	then do;
	     vov_check_result_bit = ON;
	     return;
	end;
%skip(1);
     	vov_check_result_bit = replace_subtotal_list_after_checking (ALLOW_DUPLICATES);
%skip(1);
	return;
%skip(1);
     end check_subcount_list_or_none;
%skip(3);
check_subtotal_list_or_none: proc;
%skip(3);
	if vov_option_value_parm = ""
	then do;
	     vov_check_result_bit = ON;
	     return;
	end;
%skip(1);
     	vov_check_result_bit = replace_subtotal_list_after_checking (DONT_ALLOW_DUPLICATES);
%skip(1);
	return;
%skip(1);
     end check_subtotal_list_or_none;
%skip(3);
check_zero_or_any_positive_integer: proc;
%skip(3);
          if verify (vov_option_value_parm, DIGITS) = 0
	then vov_check_result_bit = ON;
%skip(1);
          return;
%skip(1);
     end check_zero_or_any_positive_integer;
%page;
check_zero_or_greater_than_six: proc;
%skip(3);
          if verify (vov_option_value_parm, DIGITS) = 0
	then do;
	     vov_number_tester = convert (vov_number_tester,
		vov_option_value_parm);
	     if vov_number_tester = 0
	     |  vov_number_tester > 6
	     then vov_check_result_bit = ON;
	end;
%skip(1);
          return;
%skip(1);
     end check_zero_or_greater_than_six;
%page;
replace_column_list_after_checking: proc (
	rclac_judgement_table_ptr_parm	/* output: points to the judgement table */
				 ) returns (bit(1));
%skip(3);
/*

     This proc is called to check a list of columns, which may be given as
     column names or numbers, and then create a new list containing only column
     names if the check proved sucessful.  It expects that
     vov_option_value_parm contains the list of columns.  The variable
     vov_any_or_all_parm dictates what type of checking is done.  Since the
     time when this code was written the restriction of having all columns
     named in a "-column_order" option was removed, but this subroutine still
     provides the service of validating that all columns are present in a list
     because it is felt an additional option which has this requirement may
     be added sometime in the future.  If the check proves sucessfull,
     vov_option_value_parm is replaced with a list of column names, and "1"b is
     returned.  An unsucessful check returns "0"b and the value of
     vov_option_value_parm isn't set. If the variable vov_complete_the_list
     is on the list is filled in with any missing columns; if it is off the
     list will only contain the names of the columns found. The judgment_table
     structure if filled in to describe the original list found. Each bit 
     turned on indicates that particular column was found in the list and the
     number field of the structure indicates where in the list it was found.

*/
%skip(1);
dcl rclac_code fixed bin (35);
dcl rclac_column_name_length fixed bin;
dcl rclac_current_position fixed bin;
dcl rclac_finished bit (1) aligned;
dcl rclac_first_blank fixed bin;
dcl rclac_hit bit (1) aligned;
dcl rclac_inner_loop fixed bin;
dcl 1 rclac_judgement_table (number_of_defined_columns) like judgement_table based (rclac_judgement_table_ptr);
dcl rclac_judgement_table_ptr ptr;
dcl rclac_judgement_table_ptr_parm ptr parm;
dcl rclac_loop fixed bin;
dcl rclac_no_of_claimed_digits fixed bin;
dcl rclac_spare_option_value_length fixed bin;
dcl rclac_still_skipping_blanks bit (1) aligned;
dcl rclac_target_character char (1);
%skip(1);
	rclac_judgement_table_ptr_parm = null ();
          if vov_option_value_parm = ""
	then return (OFF);
%skip(1);
          rclac_spare_option_value =  ltrim (rtrim (translate
	     (vov_option_value_parm, BLANK, TAB))) || BLANK;
	rclac_spare_option_value_length = length (rclac_spare_option_value);
	rclac_current_position = 1;
%skip(1);
          allocate rclac_judgement_table in (names_and_values_area)
	     set (rclac_judgement_table_ptr);
	unspec (rclac_judgement_table) = OFF;
%skip(1);
          rclac_finished = OFF;
%skip(1);
          do rclac_loop = 1 to number_of_defined_columns while (^rclac_finished);
%skip(1);
	     rclac_first_blank = index (substr (rclac_spare_option_value, 
		rclac_current_position), BLANK) 
		+ rclac_current_position - 1;
	     if rclac_first_blank >= rclac_spare_option_value_length
	     then if rclac_loop ^= number_of_defined_columns
		& vov_any_or_all = ALL
		then return (OFF);
	          else rclac_finished = ON;
	     else;
%skip(1);
	     rclac_target_character = substr (rclac_spare_option_value, 
		rclac_current_position, 1);
	     if rclac_target_character >= ZERO 
	     & rclac_target_character <= NINE
	     then do;
		rclac_no_of_claimed_digits 
		     = rclac_first_blank - rclac_current_position;
		if rclac_no_of_claimed_digits < 1
		then return (OFF);
%skip(1);
		rclac_judgement_table.number (rclac_loop) = cv_dec_check_
		     (substr (rclac_spare_option_value, rclac_current_position, 
		     rclac_no_of_claimed_digits), rclac_code);
		if rclac_code ^= 0
		then return (OFF);
%skip(1);
		if rclac_judgement_table.number (rclac_loop) < 1 
		| rclac_judgement_table.number (rclac_loop) > number_of_defined_columns
		then return (OFF);
	     end;
	     else do;
		rclac_hit = OFF;
		rclac_column_name_length 
		     = rclac_first_blank - rclac_current_position;
%skip(1);
		do rclac_inner_loop = 1 to number_of_defined_columns while (^rclac_hit);
		     if substr (rclac_spare_option_value, 
		     rclac_current_position, rclac_column_name_length) 
		     = table_info.columns.column_name (rclac_inner_loop)
		     then rclac_hit = ON;
		end;
%skip(1);
		if ^rclac_hit
		then return (OFF);
		else rclac_judgement_table.number (rclac_loop) 
		     = rclac_inner_loop - 1;
	     end;
%skip(1);
	     if rclac_judgement_table.present (rclac_judgement_table.number (rclac_loop))
	     then return (OFF);
%skip(1);
	     rclac_judgement_table.present (
		rclac_judgement_table.number (rclac_loop)) = ON;
%skip(1);
               if ^rclac_finished
	     then do;
		rclac_still_skipping_blanks = ON;
		rclac_current_position = rclac_first_blank + 1;
		do while (rclac_still_skipping_blanks);
		     if substr (rclac_spare_option_value, 
		     rclac_current_position, 1) ^= BLANK
		     then rclac_still_skipping_blanks = OFF;
		     else rclac_current_position 
			= rclac_current_position + 1;
		end;
		if rclac_current_position < rclac_spare_option_value_length
		& rclac_loop >= number_of_defined_columns
		then return (OFF);
	     end;
	end;
%skip(1);
          if vov_any_or_all = ALL
	then do rclac_loop = 1 to number_of_defined_columns;
	     if ^rclac_judgement_table.present (rclac_loop)
	     then return (OFF);
	end;
%skip(1);
          rclac_spare_option_value = "";
%skip(1);
	do rclac_loop = 1 to number_of_defined_columns;
	     if rclac_judgement_table.number (rclac_loop) ^= 0
	     then rclac_spare_option_value = rclac_spare_option_value 
		|| table_info.columns.column_name (
		rclac_judgement_table.number (rclac_loop)) || BLANK;
	end;
%skip(1);
	if vov_complete_the_list
	then do rclac_loop = 1 to number_of_defined_columns;
	     if ^rclac_judgement_table.present (rclac_loop)
	     then rclac_spare_option_value = rclac_spare_option_value
		|| table_info.columns.column_name (rclac_loop) || BLANK;
	end;
%skip(1);
	vov_option_value_parm = rtrim (rclac_spare_option_value);
	rclac_judgement_table_ptr_parm = rclac_judgement_table_ptr;
%skip(1);
          return (ON);
%skip(1);
     end replace_column_list_after_checking;
%page;
replace_subtotal_list_after_checking: proc (rslac_allow_duplicates_parm) returns (bit(1));
%skip(3);
/*

     This proc is called to check a list of subtotal triplets, and then
     create a new list if the check proved successful.  The syntax of a
     triplet is "column_1,column_2{,reset|running}".  Each triplet is
     separated by whitespace. column_N can be given as a column name or
     column number. It expects that vov_option_value_parm contains the
     list of subtotal triplets. If the check proves successful,
     vov_option_value_parm is replaced with a list of triplets which has
     each column number replaced by the column name, and the optional
     third portion of a triplet filled in. A single blank separates each
     triplet in the new list.

*/
%skip(1);
dcl rslac_allow_duplicates_parm bit (1) aligned parm;
dcl rslac_blank_position fixed bin;
dcl rslac_code fixed bin (35);
dcl rslac_current_position fixed bin;
dcl rslac_original_option_value_length fixed bin;
dcl rslac_still_parsing bit (1) aligned;
%skip(1);
	if vov_option_value_parm = ""
	then return (OFF);
%skip(1);
          rslac_original_option_value =  ltrim (rtrim (translate
	     (vov_option_value_parm, BLANK, TAB))) || BLANK;
	rslac_original_option_value_length 
	     = length (rslac_original_option_value);
	rslac_result_option_value = "";
	rslac_current_position = 1;
	rslac_still_parsing = ON;
%skip(1);
	do while (rslac_still_parsing);
	     call get_triplet (rslac_code);
	     if rslac_code = 0
	     then call parse_triplet (rslac_allow_duplicates_parm, rslac_code);
	end;
%skip(1);
	if rslac_code ^= 0
	then return (OFF);
%skip(1);
	vov_option_value_parm = rtrim (rslac_result_option_value);
%skip(1);
	return (ON);
%page;
get_triplet: proc (gt_code_parm);
%skip(3);
dcl gt_code_parm fixed bin (35) parm;
dcl gt_still_skipping_blanks bit (1) aligned;
%skip(1);
	gt_code_parm = 0;
	rslac_blank_position 
	     = index (substr (rslac_original_option_value, 
	     rslac_current_position), BLANK);
	rslac_triplet = substr (rslac_original_option_value,
	     rslac_current_position, rslac_blank_position - 1);
	rslac_current_position 
	     = rslac_current_position + rslac_blank_position;
%skip(1);
	if rslac_current_position >= rslac_original_option_value_length
	then rslac_still_parsing = OFF;
	else do;
	     gt_still_skipping_blanks = ON;
	     do while (gt_still_skipping_blanks);
		if substr (rslac_original_option_value, 
		rslac_current_position, 1) = BLANK
		then rslac_current_position = rslac_current_position + 1;
		else gt_still_skipping_blanks = OFF;
	     end;
	end;
%skip(1);
	return;
%skip(1);
     end get_triplet;
%page;
parse_triplet: proc (
	pt_allow_duplicates_parm,	/* input: on means allow duplicate definitions,
				   a subtotal can also "watch" itself */
	 pt_code_parm		/* output: success or failure */
		);
%skip(3);
dcl pt_allow_duplicates_parm bit (1) aligned parm;
dcl pt_character_string char (80) varying;
dcl pt_code_parm fixed bin (35) parm;
dcl pt_column_number fixed bin;
dcl pt_comma_position fixed bin;
dcl pt_current_position fixed bin;
dcl pt_first_column_found fixed bin;
dcl pt_hit bit (1) aligned;
dcl pt_inner_loop fixed bin;
dcl pt_loop fixed bin;
dcl pt_second_column_found fixed bin;
dcl pt_triplet_length fixed bin;
%skip(1);
	pt_code_parm = 1;
	pt_triplet_length = length (rslac_triplet);
	pt_current_position = 1;
%skip(1);
	do pt_loop = 1 to 2;
	     pt_comma_position = index (substr (rslac_triplet, 
		pt_current_position), COMMA);
	     if pt_comma_position = 0
	     then if pt_loop = 1
		then return;
	          else pt_comma_position 
		     = pt_triplet_length + 2 - pt_current_position;
	     else;
	     pt_character_string = substr (rslac_triplet, 
		pt_current_position, pt_comma_position - 1);
	     pt_current_position = pt_current_position + pt_comma_position;
	     if pt_current_position > pt_triplet_length
	     & pt_loop = 1
	     then return;
	     if verify (pt_character_string, DIGITS) = 0
	     then do;
		pt_column_number = convert (pt_column_number, 
		     pt_character_string);
		if pt_column_number < 1
		| pt_column_number > number_of_defined_columns
		then return;
		else;
		rslac_result_option_value
		     = rslac_result_option_value 
		     || table_info.columns.column_name (pt_column_number) || COMMA;
		if pt_loop = 1
		then pt_first_column_found = pt_column_number;
		else pt_second_column_found = pt_column_number;
	     end;
	     else do;
		pt_hit = OFF;
		do pt_inner_loop = 1 to number_of_defined_columns while (^pt_hit);
		     if pt_character_string 
		     = table_info.columns.column_name (pt_inner_loop)
		     then do;
			pt_hit = ON;
			pt_column_number = pt_inner_loop;
		     end;
		end;
		if ^pt_hit
		then return;
		else;
		if pt_loop = 1
		then pt_first_column_found = pt_column_number;
		else pt_second_column_found = pt_column_number;
		rslac_result_option_value
		     = rslac_result_option_value
		     || pt_character_string || COMMA;
	     end;
	end;
%skip(1);
	if ^pt_allow_duplicates_parm
	then if pt_first_column_found = pt_second_column_found
	     then return;
	     else;
	else;
%skip(1);
	if pt_current_position >= pt_triplet_length
	then rslac_result_option_value
	     = rslac_result_option_value || RESET || BLANK;
	else do;
	     pt_character_string = substr (rslac_triplet, 
		pt_current_position);
	     if pt_character_string = RESET
	     then rslac_result_option_value
		= rslac_result_option_value || RESET || BLANK;
	     else if pt_character_string = RUNNING
		then rslac_result_option_value
		     = rslac_result_option_value || RUNNING || BLANK;
	          else return;
	end;
%skip(1);
	pt_code_parm = 0;
%skip(1);
	return;
%skip(1);
     end parse_triplet;
%skip(1);
     end replace_subtotal_list_after_checking;
%skip(1);
     end valid_option_value;
%page;
%skip(1);
dcl ALL bit (1) aligned static int options (constant) init ("1"b);
dcl ALLOW_DUPLICATES bit (1) aligned static int options (constant) init ("1"b);
dcl ANY bit (1) aligned static int options (constant) init ("0"b);
%skip(1);
dcl BLANK char (1) static int options (constant) init (" ");
dcl BOTH char (4) static int options (constant) init ("both");
%skip(1);
dcl CENTER char (6) static int options (constant) init ("center");
dcl COMMA char (1) static int options (constant) init (",");
%skip(1);
dcl DECIMAL char (7) static int options (constant) init ("decimal");
dcl DIGITS char (10) static int options (constant) init ("0123456789");
dcl DONT_ALLOW_DUPLICATES bit (1) aligned static int options (constant) init ("0"b);
%skip(1);
dcl EXTENSIBLE bit (1) aligned static int options (constant) init ("1"b);
%skip(1);
dcl FILL char (4) static int options (constant) init ("fill");
%skip(1);
dcl LEFT char (4) static int options (constant) init ("left");
dcl LEFT_BRACKET char (1) static int options (constant) init ("[");
%skip(1);
dcl NINE char (1) static int options (constant) init ("9");
dcl NO_ZERO_ON_ALLOC bit (1) aligned static int options (constant) init ("0"b);
dcl NO_ZERO_ON_FREE bit (1) aligned static int options (constant) init ("0"b);
dcl NON_FREEING bit (1) aligned static int options (constant) init ("1"b);
%skip(1);
dcl OFF bit (1) aligned static int options (constant) init ("0"b);
dcl ON bit (1) aligned static int options (constant) init ("1"b);
%skip(1);
dcl PERMANENT bit (36) aligned static int options (constant) init ("01"b);
%skip(1);
dcl RESET char (5) static int options (constant) init ("reset");
dcl RIGHT char (5) static int options (constant) init ("right");
dcl RUNNING char (7) static int options (constant) init ("running");
%skip(1);
dcl STAR_OR_QUESTION_MARK char (2) static int options (constant) init ("*?");
dcl STAR_DOT_STAR_STAR char (4) static int options (constant) init ("*.**");
%skip(1);
dcl TAB char (1) static int options (constant) init ("	");
dcl TILDE char (1) static int options (constant) init ("~");
dcl TRUNCATE char (8) static int options (constant) init ("truncate");
%skip(1);
dcl ZERO char (1) static int options (constant) init ("0");
%page;
dcl addr builtin;
dcl after builtin;
%skip(1);
dcl before builtin;
%skip(1);
dcl caktc_option_value char (MAXIMUM_OPTION_VALUE_LENGTH) varying;
dcl cavgl_save_option_value char (MAXIMUM_OPTION_VALUE_LENGTH) varying;
dcl char builtin;
dcl code fixed bin (35);
dcl column_map (number_of_defined_columns) bit (1) based (column_map_ptr);
dcl column_map_ptr ptr;
dcl convert builtin;
dcl cv_dec_check_ entry (char(*), fixed bin(35)) returns(fixed bin(35));
%skip(1);
dcl delete_$ptr entry (ptr, bit(6), char(*), fixed bin(35));
dcl directory_name char (168);
dcl divide builtin;
%skip(1);
dcl entry_name char (32);
dcl error_table_$no_s_permission fixed bin(35) ext static;
dcl error_table_$nomatch fixed bin(35) ext static;
dcl error_table_$nostars fixed bin(35) ext static;
dcl error_table_$oldnamerr fixed bin(35) ext static;
dcl expand_pathname_ entry (char(*), char(*), char(*), fixed bin(35));
%skip(1);
dcl fixed builtin;
%skip(1);
dcl general_columns_names_and_values_info_ptr ptr;
dcl general_report_names_and_values_info_ptr ptr;
dcl get_pdir_ entry() returns(char(168));
dcl get_temp_segment_ entry (char(*), ptr, fixed bin(35));
%skip(1);
dcl hbound builtin;
dcl hcs_$make_seg entry (char(*), char(*), char(*), fixed bin(5), ptr, fixed bin(35));
dcl hcs_$status_long entry (char(*), char(*), fixed bin(1), ptr, ptr, fixed bin(35));
%skip(1);
dcl index builtin;
%skip(1);
dcl 1 judgement_table (number_of_defined_columns) aligned based (judgement_table_ptr),
      2 present bit (1),
      2 number fixed bin (35);
dcl judgement_table_ptr ptr;
%skip(1);
dcl length builtin;
dcl 1 like_name_value_info (no_of_active_names_and_values) based (like_names_and_values_info_ptr) like name_value_info;
dcl like_names_and_values_info_ptr ptr;
dcl linus_error_$bad_option_identifier fixed bin(35) ext static;
dcl linus_error_$bad_option_name fixed bin(35) ext static;
dcl linus_error_$bad_option_value fixed bin(35) ext static;
dcl linus_error_$no_lila_expr_processed fixed bin(35) ext static;
dcl linus_fr_delete_report entry (ptr, fixed bin(35));
dcl match_star_name_ entry (char(*), char(*), fixed bin(35));
dcl linus_table$info entry (ptr, ptr, fixed bin (35));
dcl long_option_name char (MAXIMUM_OPTION_NAME_LENGTH) varying;
dcl ltrim builtin;
dcl lvswcd_option_identifier char (MAXIMUM_OPTION_IDENTIFIER_LENGTH) varying;
dcl lvswcd_option_name char (MAXIMUM_OPTION_NAME_LENGTH) varying;
dcl lvswcd_option_value char (MAXIMUM_OPTION_VALUE_LENGTH) varying;
%skip(1);
dcl max builtin;
dcl me char (64);
dcl mdbm_util_$mu_define_area entry (ptr, fixed bin(18), char(11), bit(1) aligned, bit(1) aligned, bit(1) aligned, bit(1) aligned, fixed bin(35));
%skip(1);
dcl names_and_values_area area (sys_info$max_seg_size) based (names_and_values_area_ptr);
dcl names_and_values_area_ptr ptr;
dcl names_and_values_bit_map (no_of_names_and_values_in_bit_map) bit (1) based (names_and_values_bit_map_ptr);
dcl names_and_values_bit_map_ptr ptr;
dcl names_and_values_temp_seg_ptr ptr;
dcl normalized_option_name char (MAXIMUM_NORMALIZED_OPTION_NAME_LENGTH) varying;
dcl no_of_active_names_and_values fixed bin;
dcl no_of_names_and_values_in_bit_map fixed bin;
dcl null builtin;
dcl number_of_defined_columns fixed bin;
%skip(1);
dcl option_identifier char (MAXIMUM_OPTION_IDENTIFIER_LENGTH) varying;
dcl option_name char (MAXIMUM_OPTION_NAME_LENGTH) varying;
dcl option_table_index fixed bin;
dcl option_type fixed bin;
dcl option_value char (MAXIMUM_OPTION_VALUE_LENGTH) varying;
%skip(1);
dcl rel builtin;
dcl release_area_ entry (ptr);
dcl release_temp_segment_ entry (char(*), ptr, fixed bin(35));
dcl returned_option_value char (MAXIMUM_OPTION_VALUE_LENGTH) varying;
dcl rclac_spare_option_value char (MAXIMUM_OPTION_VALUE_LENGTH) varying;
dcl rslac_original_option_value char (MAXIMUM_OPTION_VALUE_LENGTH) varying;
dcl rslac_result_option_value char (MAXIMUM_OPTION_VALUE_LENGTH) varying;
dcl rslac_triplet char (MAXIMUM_OPTION_VALUE_LENGTH) varying;
dcl rtrim builtin;
%skip(1);
dcl sci_ptr ptr;
dcl search builtin;
dcl specific_columns_names_and_values_info_ptr ptr;
dcl 1 star_name_info based (star_name_info_ptr),
      2 maximum_number_of_star_names fixed bin,
      2 number_of_star_names fixed bin,
      2 star_name_map (maximum_number_of_star_names) bit (1),
      2 column_maps_info (number_of_star_names),
        3 number_of_matches fixed bin,
        3 column_bit_map (number_of_defined_columns) bit (1);
dcl star_name_info_ptr ptr;
dcl ssu_$abort_line entry() options(variable);
dcl ssu_$print_message entry() options(variable);
dcl substr builtin;
dcl sv_option_value char (MAXIMUM_OPTION_VALUE_LENGTH) varying;
dcl sv_spare_option_identifier char (MAXIMUM_OPTION_IDENTIFIER_LENGTH) varying;
dcl sv_spare_option_value char (MAXIMUM_OPTION_VALUE_LENGTH) varying;
dcl sys_info$max_seg_size fixed bin(35) ext static;
dcl system_default bit (1) aligned;
%skip(1);
dcl temp_seg_ptr ptr;
dcl translate builtin;
%skip(1);
dcl unspec builtin;
%skip(1);
dcl valid_selection_expression bit (1) aligned;
dcl value_seg_ptr ptr;
dcl value_$delete entry (ptr, bit(36) aligned, char(*), fixed bin(35));
dcl value_$init_seg entry (ptr, fixed bin, ptr, fixed bin(19), fixed bin(35));
dcl value_$get entry() options(variable);
dcl value_$list entry (ptr, bit(36) aligned, ptr, ptr, ptr, fixed bin(35));
dcl value_$set entry() options(variable);
dcl verify builtin;
%skip(1);
%page;
%include access_mode_values;
%page;
%include arg_descriptor;
%page;
%include arg_list;
%page;
%include linus_format_options;
%page;
%include linus_lcb;
%page;
%include linus_names_and_values;
%page;
%include linus_options_extents;
%page;
%include linus_report_info;
%page;
%include linus_table_info;
%page;
%include mdbm_descriptor;
%page;
%include status_structures;
%page;
%include value_structures;
%skip(3);
     end linus_options;
