/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8060 cobol.pl1 Reformatted code to new Cobol standard.
                                                   END HISTORY COMMENTS */


/* Modified on 10/1/83 by FCH, [5.2...]. trace added */
/* Modified on 11/25/81 by FCH, [5.1-3], main prog added to include file table, BUG519(phx11818) */
/* Modified on 10/23/81 by FCH, [5.1-2], issue diag if long line found, phx11819(BUG517) */
/* Modified on 10/13/81 by FCH, [5.1-1], hisi data alloc algorithm if cobol$multics */
/* Modified on 10/02/81 by FCH, [5.0-1], formatting not forced if first char was tab, BUG511 */
/* Modified on 07/11/81 by FCH, [4.4-9], work files clobbered if corres and debug phases used, phx10380(BUG492) */
/* Modified on 05/27/81 by FCH, [4.4-8], size of work files reset to zero, phx09988(BUG485) */
/* Modified on 05/26/81 by FCH, [4.4-7], cobol_ecs_info replaced by sys incl file status_structures, phx09946(BUG484) */
/* Modified on 05/25/81 by FCH, [4.4-6], change message emitted when -table and -fmt used, phx09946(BUG484) */
/* Modified on 05/19/81 by FCH, [4.4-5], default is table */
/* Modified on 05/19/81 by FCH, [4.4-4], -sv and -lev may optionally be followed by spaces */
/* Modified on 12/01/80 by FCH, [4.4-3], report writer phase added */
/* Modified on 10/22/80 by FCH, COBOL_SYNTAX_TRACE_ changed to cobol_syntax_trace_ */
/* Modified on 10/17/80 by PRP, [4.4-2], TR7956(BUG446), temp segs not cleaned up on bad arg error */
/* Modified on 08/15/80 by FCH, [4.4-1], TR6483(BUG440), zero length source seg caused compiler to abort */
/* Modified on 2/27/80 by PRP, [4.2-4], phx05396b  -sv4 fixed */
/* Modified on 02/14/80 by FCH, [4.2-3], answered phx05331s */
/* Modified on 02/12/80 by MHD, [4.2-2], answered phx05237o, phx05238u, and phx05231b */
/* Modified on 10/26/79 by MHD, [4.1-3], left cobol_m2fp pointing to last minpral-2 for appending type 25 tokens */
/* Modified on 10/18/79 by MHD, [4.1-2], deleted unused parameter to cobol_print_diag */
/* Modified on 10/12/79 by FCH, [4.1-1], -card, revision to .ex.cobol */
/* Modified on 08/17/79 by PRP, [4.0-6], fixed warning message for -fmt and -tb */
/* Modified on 06/08/79  by PRP, [4.0-5], recursive call to compiler eliminated */
/* Modified on 04/09/79 by FCH, [4.0-4], compatibility entry points added added */
/* Modified on 04/02/79 by FCH, [4.0-3], debug phase added */
/* Modified on 03/30/79 by FCH, [4.0-2], option -svNM added */
/* Modified on 02/26/79 by FCH, [4.0-1], option -levN M added */
/* Modified on 1/31/79 by FCH, [3.0-11], cobol equiv to cobol$id */
/* Modified on 10/25/78 by RAL, [3.0-10], initilize ecs_info_table.diag_indicators */
/* Modified on 10/25/78 by FCH, [3.0-9], area allocation standardized */
/* Modified on 10/23/78 by RAL, [3.0-8], COPY ... REPLACING and REPLACE statements */
/* Modified on 09/12/78 by RAL, [3.0-7], warning about the use of -tb and -fmt and probing source */
/* Modified on 06/22/78 by RAL, [3.0-6], entries cobol$(push_name pop_name) */
/* Modified on 06/06/78 by FCH, [3.0-5], delete list file before compilation */
/* Modified on 05/24/78 by FCH, [3.0-4], logic of condition handling rewritten */
/* Modified on 04/27/78 by FCH, [3.0-3], symbol section(compiler options) */
/* Modified on 04/27/78 by FCH, [3.0-2], symbol section(source module path name) */
/* Modified on 01/24/78 by FCH, [3.0-1], xref listing suppressed if fatals */
/* Modified since Version 3.0 */







/* format: style3 */
cobol:
     proc;

/*   This is the driver for the Multics COBOL compiler.
It processes all compiler control options, establishes the source
segment, and calls each phase of the compiler in order:

     Front:
	cobol_lex		(LEX)
	cobol_idedsyn	(ID/ED SYNTAX)
	cobol_ddsyntax	(DD SYNTAX)
	cobol_ddalloc	(DD ALLOCATION)
	cobol_repl3	(REPLACEMENT)
	cobol_ci_phase	(CORRESPONDING)
	cobol_pdstax	(PD SYNTAX)
	cobol_print_diag	(PRINT DIAG)
     Back:
	cobol_gen_driver_	(GENERATOR)
	cobol_make_xref_	(ANALYZER)
	cobol_fix_driver_	(FIXUP)

All files used by the various phases are declared, opened and closed
by the driver.  */

/*************************************/
id:
     entry;					/*[3.0-11]*/

	string (trace) = ""b;
	MODE = 0;
	go to start;

/*************************************/
trace:
     entry;

	string (trace) = "1000"b;
	MODE = 0;

	go to start;

rw:
     entry;

/*[4.4-0]*/
	MODE = 5;					/*[4.4-0]*/
	go to start;

gcos:
     entry;

/*[4.0-4]*/
	call set_mode (1);				/*[4.0-4]*/
	go to start;

ibm_ansi:
     entry;

/*[4.0-4]*/
	call set_mode (2);				/*[4.0-4]*/
	go to start;

ibm_ef:
     entry;

/*[4.0-4]*/
	call set_mode (3);				/*[4.0-4]*/
	go to start;

multics:
     entry;

/*[4.0-4]*/
	call set_mode (4);				/*[4.0-4]*/
	go to start;

copy_file_size:
     entry (bc);

/*[5.1-2]*/
	call cobol_merge$copy_file_size (bc);		/*[5.1-2]*/
	return;

/*[5.1.2]*/
dcl	cobol_merge$copy_file_size
			entry (fixed bin (24));	/*[5.1-2]*/
dcl	bc		fixed bin (24);

push_name:
     entry (dir_name, entryname);			/* [3.0-6] */

/* This is called to push the source name and
			    all include files onto a stack to be
			      used to build the symbol table */


dcl	dir_name		char (168);
dcl	entryname		char (32);

	call hcs_$status_long (dir_name, entryname, 1, addr (branch_status), null (), mcode);

	c_name.ct = c_name.ct + 1;

/* [3.0-9] */
	allocate source_name in (cobol_area) set (source_name_ptr);
						/* [3.0-9] */
	source_name.prev_name_ptr = c_name.last_name_ptr; /* [3.0-9] */
	c_name.last_name_ptr = source_name_ptr;		/* [3.0-9] */

	l_dn = index (dir_name, " ") - 1;
	l_en = index (entryname, " ") - 1;

	source_name.sname = substr (dir_name, 1, l_dn) || ">" || substr (entryname, 1, l_en);
						/*[4.4-7]*/
	source_name.uid = branch_status.uid;		/*[4.4-7]*/
	source_name.dtm = branch_status.dtcm;

	return;


pop_name:
     entry returns (ptr);				/* [3.0-6] */

/* This is call to pop the names off of
			    a stack by cobol_sym_init.pl1 */

/* [3.0-9] */
	if c_name.last_name_ptr = null ()
	then return (null ());			/* [3.0-9] */
						/* [3.0-9] */
	c_name.pname = c_name.last_name_ptr -> source_name.sname;
						/* [3.0-9] */
	c_name.uid = c_name.last_name_ptr -> source_name.uid;
						/* [3.0-9] */
	c_name.dtm = c_name.last_name_ptr -> source_name.dtm;
						/* [3.0-9] */
	c_name.last_name_ptr = c_name.last_name_ptr -> source_name.prev_name_ptr;

	c_name.size = index (c_name.pname, " ") - 1;
	if c_name.size = -1
	then c_name.size = 168;

	return (addr (c_name));

/* [3.0-9] */

alloc:
     entry (alloc_size) returns (ptr);

declare	alloc_size	fixed bin (35);		/**/
						/**/
	allocate words in (cobol_area) set (source_name_ptr);
						/**/
						/**/
	return (source_name_ptr);			/**/


clean_up:
     entry;

/*  This entry is called as a command to cleanup the compile time files. */
/* The calling sequence is:
				cobol$clean_up
			/*}*/
	if fpath ^= ""
	then do segname = "cobol_seg1_", "cobol_seg2_", "cobol_seg3_", "cobol_initval_", "cobol_ntbuff_",
		"cobol_minpral-1_", "cobol_minpral-2_", /*[4.4-3]*/
		"rwdd.incl.cobol", "rwpd.incl.cobol", "cobol_rmin2_", "cobol_r2min2_", "cobol_print_", "cobol_diags_",
		"cobol_pdout_", "cobol_corrout_", "cobol_minpral-1_1", "cobol_minpral-2_1", "cobol_rmin2_1",
		"cobol_pdout_1", "cobol_minpral-1_2", "cobol_minpral-2_2", "cobol_rmin2_2", "cobol_pdout_2",
						/**/
						/*			"cobol_minpral-1_3","cobol_minpral-2_3","cobol_rmin2_3","cobol_pdout_3",
/*			"cobol_minpral-1_4","cobol_minpral-2_4","cobol_rmin2_4","cobol_pdout_4",
/*			"cobol_minpral-1_5","cobol_minpral-2_5","cobol_rmin2_5","cobol_pdout_5",
/**/
		"cobol_common_", "cobol_name_table_", "cobol_format_temp_";

		call hcs_$delentry_file (fpath, segname, mcode);

	     end;

	return;


/*************************************/

restart:
     entry;

	if ^restart
	then return;

	if abort_sw
	then go to finish;
	else abort_sw = "1"b;

	if intact
	then call cu_$cl;
	else if endgen_sw
	then go to finish;
	else if gen_sw
	then go to no_gen;
	else go to start_print_diag;

define_data:
     entry;

/*[5.1-2]*/
	call ided;				/*[5.1-2]*/
	call dd;

/*[5.1-2]*/
	return;

/*************************************/
/* INITIALIZATION */

start:	/***.....  Trace_Bit="0"b;/**/
	/***.....  Trace_Lev=1;/**/
	/***.....  Trace_Line=(60)".";/**/
	if recursion
	then do;

/*[4.0-5]*/
		call ioa_$ioa_stream ("error_output",
		     "cobol: Translation failed. Attempt to invoke COBOL recursively use release first.");

/*[4.0-5]*/
		return;
	     end;
	else recursion = "1"b;

/*[5.1-2]*/
	lex_quit = LEX_QUIT;			/*[5.1-2]*/
	comp_term = COMP_TERM;

/*[4.0-5]*/
/* ESTABLISH CONDITION HANDLERS */

	on command_abort call COND ("command_abort");	/* [3.0-4] */
	on command_abort_ call COND ("command_abort_");	/* [3.0-4] */
	on cleanup call CLEANUP;


	restart = "0"b;
	cobol_sfp = null ();
	cobol_x2_fileno = 0;			/* for optional jif file */
	p_err = "0"b;
	area_info_area.areap = null ();

	call cu_$af_arg_count (pc, mcode);

	if mcode = 0
	then do;

		call com_err_ (0, "cobol", "This command may not be invoked as an active function");
		go to comp_term;

	     end;
	else if mcode ^= error_table_$not_act_fnc
	then do;

		call com_err_ (mcode, "cobol");
		go to comp_term;

	     end;

	if pc = 0
	then /* if no arguments list options */
	     do;

		call print_options;
		go to comp_term;

	     end;


/*[5.1-2]*/
	call init_cobol;

/*[5.1-2]*/
	do i = 1 to pc;

/*[5.1-2]*/
	     call cu_$arg_ptr (i, arg_ptr, l, mcode);

/*[5.1-2]*/
	     call option;

/*[5.1-2]*/
	end;

/*[5.1-2]*/
	call setup;				/* initialize for compilation */
						/*[5.1-2]*/
	call expand_phase;				/* expand_phase_cobol_source */



/*[5.1-2]*/
	call lex;					/* lexical analysis phase */

/*[5.1-2]*/
	call cobol$define_data;

/*[5.1-2]*/
	call ddalloc;				/* dd allocation phase */

/*[5.1-2]*/
	call replace;				/* replacement phase */

/*[5.1-2]*/
	call db_corr;				/* debug, corresponding phase */



/*[5.1-2]*/
/* pd syntax analysis phase */

	if time
	then call hcs_$get_usage_values (pb_pf, pb_tm, pb_pp);

	fixed_common.syntax_trace = trace.pd;

/*[5.1-2]*/
	call cobol_pdstax;

/*[5.1-2]*/
	if mcode ^= 0
	then return;

	call cobol_swf_close (cobol_dfp, ST, tptr, 0);

	if time
	then call timer ("PD_SYNTAX.....");

start_print_diag:					/*[5.1-2]*/
	call print_diag;				/*[5.1-2]*/
	call generator;

no_gen:
	endgen_sw = "1"b;

/*[5.1-2]*/
	call analyzer;

/*[5.1-2]*/
	if fixed_common.fatal_no = 0 & opts.cu & ^abort_sw/*[5.1-2]*/
	then call fixup;

finish:						/*[5.1-2]*/
	call finish_proc;

	return;


/* GENERALIZED ERROR PROCESSING */

arg_error:
	call com_err_ (error_table_$badopt, "cobol", argb);

	go to COMP_TERM;

missing_arg_error:
	call com_err_ (error_table_$noarg, "cobol");

	go to COMP_TERM;



multics_error:
	segname = "";

multics_file_error:
	call com_err_ (mcode, "cobol", "  ^a", segname);

COMP_TERM:
	call finis;

	recursion = "0"b;
	return;

LEX_QUIT:						/*[5.1-2]*/
	call CLEANUP;				/*[5.1-2]*/
	call finis;

/*[5.1-2]*/
	return;





set_mode:
     proc (num);

/*[4.0-4]*/
declare	num		fixed bin;

/*[4.0-4]*/
	MODE = num;				/*[4.0-4]*/
	string (trace) = ""b;

     end;

ssv:
     proc;

/*[4.4-4]*/
declare	ch		char (1);

/*[4.4-4]*/
	call cl_arg_check;

/*[4.4-4]*/
	if m ^= 1
	then go to arg_error;

/*[4.4-4]*/
	ch = substr (argb, 1, 1);

/*[4.4-4]*/
	if ch < "1" | ch > "4"
	then go to arg_error;

/*[4.4-4]*/
	call setsv (ch);

/*[4.4-4]*/
	substr (arg, l, 2) = " " || ch;		/*[4.4-4]*/
	l = l + 2;

     end;

slv:
     proc;

/*[4.4-4]*/
declare	(ch1, ch2)	char (1);

/*[4.4-4]*/
	ch2 = " ";

/*[4.4-4]*/
	call cl_arg_check;

/*[4.4-4]*/
	ch1 = substr (argb, 1, 1);

/*[4.4-4]*/
	if ch1 < "1" | ch1 > "5"
	then go to arg_error;

/*[4.4-4]*/
	if m = 1					/*[4.4-4]*/
	then call setlev (ch1, "3");			/*[4.4-4]*/
	else if m = 2				/*[4.4-4]*/
	then do;
		ch2 = substr (argb, 2, 1);

/*[4.4-4]*/
		if ch2 < "1" | ch2 > "3"
		then go to arg_error;

/*[4.4-4]*/
		call setlev (ch1, ch2);		/*[4.4-4]*/
	     end;					/*[4.4-4]*/
	else go to arg_error;

/*[4.4-4]*/
	substr (arg, l, 3) = " " || ch1 || ch2;		/*[4.4-4]*/
	l = l + 3;

     end;

cl_arg_check:
     proc;

/*[4.4-4]*/
	if i = pc
	then go to arg_error;

/*[4.4-4]*/
	i = i + 1;

/*[4.4-4]*/
	call cu_$arg_ptr (i, arg_ptr, m, mcode);

/*[4.4-4]*/
	if mcode ^= 0
	then go to multics_error;

     end;

comp_env:
     proc;

/*[4.0-4]*/

/*[4.0-4]*/
	go to M (MODE);				/* default */

M (0):						/*[4.0-4]*/
	go to MM;

M (1):						/* gcos */
						/*[4.0-4]*/
	fixed_common.compile_mode = "101"b;

/*[4.0-4]*/
	go to MM;

M (2):						/* ibm_ansi */
						/*[4.0-4]*/
	fixed_common.compile_mode = "01"b;

/*[4.0-4]*/
	go to MM;

M (3):						/* ibm_ef */
						/*[4.0-4]*/
	fixed_common.compile_mode = "01"b;

/*[4.0-4]*/
	go to MM;

M (4):						/* multics */
						/*[5.1-1]*/
	fixed_common.compile_mode = "00011"b;

/*[4.0-4]*/
	go to MM;

M (5):						/* rw */
						/*[4.4-0]*/
	go to MM;

/*	1  alphanumeric literal continuation ala gcos
		2  " or ' allowed to delimit alphanumeric literals
		3  replace tab by spaces to give a 72 char line
		4 "$" and "_" allowed in data-names
		5 hisi data allocation algorithm used
	*/
MM:
     end;


init_cobol:
     proc;

/* GET SOURCE PROGRAM NAME AND OPTIONS */

	upto = 0;
	cobol_options = "";
	cobol_options_len = 1;

	string (opts) = ""b;
	opts.pd = "1"b;				/* always print diagnostics on console*/
	opts.cu = "1"b;				/* produce object code */
	opts.m_wn = "1"b;				/*print warnings on terminal*/
	opts.m_fat = "1"b;				/*   print fatals on terminal*/
						/*[4.4-5]*/
	opts.pst = "1"b;				/* default is table */

	cobol_xlast8 = "0"b;
	time = "0"b;
	intact = "0"b;
	opts.card = "0"b;
	opts.exp, expand = "0"b;			/* [3.0-8] */
	COMP_LEVEL = "5";
	LEVSV = "001"b;
	ddsyn_sw = "0"b;
	repl_sw = "0"b;

	rel = 1;					/* release files as default (truncate and terminate segments) */

	files_wd = "0"b;
	temp_dir_sw = "0"b;
	gen_sw = "0"b;
	endgen_sw = "0"b;
	abort_sw = "0"b;

/*[4.4-5]*/
	no_tbl_pres, tbl_pres = "0"b;

/* [3.0-9] */
	call init;

/* [3.0-9] */
	if code ^= 0
	then go to multics_error;

     end;

option:
     proc;

	if substr (argb, 1, 1) = "-"
	then do;

		arg = substr (argb, 2);

/*[4.4-5]*/
		if arg = "table" | arg = "tb"
		then do;
			opts.pst = "1"b;
			tbl_pres = "1"b;
		     end;
		else if arg = "symbols" | arg = "sb" | arg = "source" | arg = "sc"
		then call ioa_ ("cobol: Option ^a is obsolete, use -ls or -map (see cobol command)", argb);
		else if arg = "map"
		then do;

			opts.exs = "1"b;
			opts.m_map = "1"b;
			opts.xrn = "1"b;

		     end;

/*[4.0-2]*/
		else /*[4.0-2]*/
		     if substr (arg, 1, 8) = "severity" /*[4.0-2]*/
		then do;
			if l = 10			/*[4.0-2]*/
			then call setsv (substr (arg, 9, 1));
						/*[4.0-2]*/
			else /*[4.0-2]*/
			     if l = 11		/*[4.0-2]*/
			then call setsv (substr (arg, 9, 1));
						/*[4.4-4]*/
			else /*[4.4-4]*/
			     if l = 9		/*[4.4-4]*/
			then call ssv;		/*[4.4-4]*/
			else go to arg_error;	/*[4.0-2]*/
		     end;				/*[4.0-2]*/
		else /*[4.0-2]*/
		     if substr (arg, 1, 2) = "sv"	/*[4.0-2]*/
		then do;
			if l = 4			/*[4.0-2]*/
			then call setsv (substr (arg, 3, 1));
						/*[4.0-2]*/
			else /*[4.0-2]*/
			     if l = 5		/*[4.0-2]*/
			then call setsv (substr (arg, 3, 1));
						/*[4.4-4]*/
			else /*[4.4-4]*/
			     if l = 3		/*[4.4-4]*/
			then call ssv;		/*[4.4-4]*/
			else go to arg_error;	/*[4.0-2]*/
		     end;

		else if arg = "brief" | arg = "bf"
		then opts.m_bf = "1"b;
		else if arg = "format" | arg = "fmt"
		then opts.fmt = "1"b;
		else if arg = "runtime_check" | arg = "rck"
		then opts.oc = "1"b;
		else if arg = "profile" | arg = "pf"
		then opts.profile, opts.pst = "1"b;
		else if arg = "check" | arg = "ck"
		then opts.cu = "0"b;
		else if arg = "list" | arg = "ls"
		then do;

			opts.exs = "1"b;
			opts.xrn = "1"b;
			opts.obj = "1"b;

		     end;
		else if arg = "no_warning" | arg = "nw"
		then opts.nw = "1"b;		/*06-30-77*/
		else if arg = "expand" | arg = "exp"
		then opts.exp, expand = "1"b;		/* [3.0-8] */
						/*[4.1-1]*/
		else if arg = "card"
		then opts.card = "1"b;
		else if arg = "time" | arg = "tm"
		then time = "1"b;
		else if arg = "debug" | arg = "db"
		then do;

			intact = "1"b;
			rel = 0;

		     end;				/*[4.4-5]*/
		else /*[4.4-5]*/
		     if arg = "no_table" | arg = "ntb"	/*[4.4-5]*/
		then do;
			opts.pst = "0"b;
			no_tbl_pres = "1"b;
		     end;
		else if arg = "temp_dir" | arg = "td"
		then do;

			files_wd = "1"b;
			temp_dir_sw = "1"b;
			i = i + 1;

			if i > pc
			then go to missing_arg_error;

			call cu_$arg_ptr (i, arg_ptr, l, mcode);
			if mcode ^= 0
			then go to multics_error;

			if substr (argb, 1, 1) = "-"
			then go to missing_arg_error;

/* following changes are for [4.1-1] and check to see if the */
/* argument specified with  the temp_dir argument is a diectory */

			call expand_pathname_ (argb, dpath, en_1, mcode);

			if mcode ^= 0
			then do;

PATHNAME_ERROR:
				call com_err_ (mcode, "cobol", "^a", argb);

				go to comp_term;

			     end;

			call absolute_pathname_ (argb, fpath, mcode);
						/* get it as a single component, as well */

			if mcode ^= 0
			then goto PATHNAME_ERROR;

			if fpath ^= ">"		/* handle special case (ROOT).  */
			then do;

				call hcs_$status_minf (dpath, en_1, 1, entry_type, (0), mcode);

				if mcode ^= 0
				then do;

					call com_err_ (mcode, "cobol", "^a", fpath);
					go to comp_term;

				     end;

				if entry_type ^= DIRECTORY
				then do;

					call com_err_ (error_table_$notadir, "cobol", "^a", fpath);
					go to comp_term;

				     end;

			     end;			/* then */

/* end changes for [4.1-1] */

		     end;
		else if arg = "working_dir" | arg = "wd"
		then do;

			files_wd = "1"b;
			fpath = get_wdir_ ();

			call ioa_ (
			     "cobol: Obsolete -working_dir option accepted: use ""-temp_dir [wd]"" in future.");

		     end;
		else if trace.on & substr (arg, 1, 5) = "trace"
		then do;

			trace_arg = arg;

			if substr (arg, 6, 2) = "id"
			then trace.id = "1"b;
			else if substr (arg, 6, 2) = "dd"
			then trace.dd = "1"b;
			else if substr (arg, 6, 2) = "pd"
			then trace.pd = "1"b;	/*[4.0-3]*/
			else if substr (arg, 6, 2) = "db"
			then trace.db = "1"b;	/*[4.4-3]*/
			else if substr (arg, 6, 2) = "rw"
			then trace.rw = "1"b;
			else go to arg_error;

			call cobol_syntax_trace_$reset_trace;
			call cobol_syntax_trace_$initialize (addr (trace_arg));

		     end;				/*[4.0-1]*/
		else /*[4.0-1]*/
		     if substr (arg, 1, 5) = "level"	/*[4.0-1]*/
		then do;
			if l = 7			/*[4.0-1]*/
			then call setlev (substr (arg, 6, 1), "3");
						/*[4.0-1]*/
			else /*[4.0-1]*/
			     if l = 8		/*[4.0-1]*/
			then call setlev (substr (arg, 6, 1), substr (arg, 7, 1));
						/*[4.4-4]*/
			else /*[4.4-4]*/
			     if l = 6		/*[4.4-4]*/
			then call slv;		/*[4.4-4]*/
			else go to arg_error;	/*[4.0-1]*/
		     end;				/*[4.0-1]*/
		else /*[4.0-1]*/
		     if substr (arg, 1, 3) = "lev"	/*[4.0-1]*/
		then do;
			if l = 5			/*[4.0-1]*/
			then call setlev (substr (arg, 4, 1), "3");
						/*[4.0-1]*/
			else /*[4.0-1]*/
			     if l = 6		/*[4.0-1]*/
			then call setlev (substr (arg, 4, 1), substr (arg, 5, 1));
						/*[4.4-4]*/
			else /*[4.4-4]*/
			     if l = 4		/*[4.4-4]*/
			then call slv;		/*[4.4-4]*/
			else go to arg_error;	/*[4.0-1]*/
		     end;
		else go to arg_error;

		if temp_dir_sw
		then do;

			temp_dir_sw = "0"b;
			substr (cobol_options, cobol_options_len, 9) = "temp_dir,";

		     end;
		else substr (cobol_options, cobol_options_len, l + 1) = substr (arg, 1, l - 1) || ",";

		cobol_options_len = cobol_options_len + l + 1;

	     end;
	else do;

		if p_err = "0"b
		then do;

			tpath = argb;
			ltp = l;
			p_err = "1"b;
		     end;
		else go to arg_error;

	     end;

/*[4.4-5]*/
	if opts.profile				/*[4.4-5]*/
	then do;
		opts.pst, tbl_pres = "1"b;
		no_tbl_pres = "0"b;
	     end;

     end;

setup:
     proc;

/*[4.4-5]*/
	if cobol_options = " "			/*[4.4-5]*/
	then do;
		cobol_options = "tb,";		/*[5.5-5]*/
		cobol_options_len = 5;		/*[4.4-5]*/
	     end;					/*[4.4-5]*/
	else if ^no_tbl_pres & ^tbl_pres		/*[4.4-5]*/
	then do;
		substr (cobol_options, cobol_options_len, 4) = "tb,";
						/*[4.4-5]*/
		cobol_options_len = cobol_options_len + 4;
						/*[4.4-5]*/
	     end;

	if cobol_options_len = 1
	then do;

		cobol_options = "none";
		cobol_options_len = 4;
	     end;
	else do;

		cobol_options_len = cobol_options_len - 2;
		substr (cobol_options, cobol_options_len, 1) = ";";
	     end;

	if p_err = "0"b
	then go to missing_arg_error;

/* GET ENTRY NAME,DIRECTORY NAME AND PATH NAME */

	p_ptr = addr (dpath);
	e_ptr = addr (ename);
	tp_ptr = addr (tpath);
	fd_ptr = addr (fpath);

/* Following changes made in [4.1-1] */
/* begin changes */

	call expand_pathname_$add_suffix (tpb, "cobol", dpath, en_1, mcode);

	if mcode ^= 0
	then go to multics_error;

	call get_length (p_ptr, 168, ldp);
	call get_length (addr (en_1), 32, en_len);

	len = en_len - 6;
	ename = substr (en_1, 1, len);

	ln = substr (ename, 1, len) || ".list";

	call expand_pathname_ (lname, pln, ln, mcode);

	if mcode ^= 0
	then go to multics_error;

	tpath = dpb || ">" || enb;

	call get_length (tp_ptr, 168, ltp);

	pdpath = get_pdir_ ();

	if ^files_wd
	then fpath = pdpath;

	call get_length (fd_ptr, 168, fdlen);

/* end changes in [4.1-1] */

	if fdlen < 0
	then fdlen = 168;


/* START COMPILATION */

	if time | intact
	then call hcs_$get_usage_values (rb_pf, rb_tm, rb_pp);

	if intact
	then call hcs_$get_usage_values (pb_pf, pb_tm, pb_pp);

	cc = cc + 1;
	cobol_$compile_count = cc;

/* DECLARE FILES TO THE IO SYSTEM */

	call cobol_vdwf (cobol_cmfp, fdir || ">cobol_common_");
	call cobol_vdwf (cobol_ntfp, fdir || ">cobol_name_table_");
	call cobol_swf (cobol_m1fp, fdir || ">cobol_minpral-1_");
	call cobol_swf (cobol_m2fp, fdir || ">cobol_minpral-2_");
						/*[4.4-3]*/
	call cobol_swf (cobol_rwdd, fdir || ">rwdd.incl.cobol");
						/*[4.4-3]*/
	call cobol_swf (cobol_rwpd, fdir || ">rwpd.incl.cobol");
	call cobol_swf (cobol_rm2fp, fdir || ">cobol_rmin2_");
	call cobol_swf (cobol_dfp, fdir || ">cobol_diags_");
	call cobol_swf (cobol_pfp, fdir || ">cobol_print_");
	call cobol_swf (cobol_$initval_file_ptr, fdir || ">cobol_initval_");
	call cobol_vdwf_open (cobol_ntfp, ST);
	call cobol_vdwf_open (cobol_cmfp, ST);
	call cobol_vdwf_sput (cobol_cmfp, ST, addr (common), 4 * size (fixed_common), fcom_key);
						/* initialize fixed common */
	call cobol_vdwf_dget (cobol_cmfp, ST, cobol_com_ptr, fcom_ln, fcom_key);
						/* set external pointer to it */

	call cobol_version$set;

/*[4.4-0]*/
	if MODE ^= 0
	then call comp_env;



	if COMP_LEVEL ^= "5"
	then fixed_common.comp_level = COMP_LEVEL;

/*[4.0-1]*/
	fixed_common.levsv = LEVSV;
	fixed_common.compiler_id = 3;
	cobol_$obj_seg_name = enb;

	call cobol_init_ (fpath, rtbuff_ptr);

/*[4.0-4]*/
	call cobol_gns$set_table;

	if rtbuff_ptr = null ()
	then go to comp_term;

     end;

expand_phase:
     proc;

	if time
	then call hcs_$get_usage_values (pb_pf, pb_tm, pb_pp);

/* Following changes made in [4.1-1] */
/* begin changes */

	call hcs_$initiate_count (dpath, en_1, "", BC, 1, cobol_sfp, mcode);

/*[5.1-3]*/
	include_ptr (0) = pointer (cobol_sfp, 1);

	if cobol_sfp = null ()
	then do;

		call com_err_ (mcode, "cobol", "^a", tpb || ".cobol");

		goto comp_term;

	     end;					/* then */

/*[4.4-1]*/
	if BC = 0					/*[4.4-1]*/
	then do;
		call com_err_ (0, "cobol", "Zero length segment. ^a", tpb || ".cobol");

/*[4.4-1]*/
		go to comp_term;

/* zero length source segment */

/*[4.4-1]*/
	     end;

	if ^opts.fmt
	then if substr (first_source_line, 1, 6) ^= "      "
	     then do;

		     ch1 = substr (first_source_line, 1, 1);
						/*[5.0-1]*/
		     if ch1 > "9" | ch1 = "*" | ch1 = "/" | ch1 = "	"
		     then do;

			     if opts.card
			     then do;

				     call ioa_ (M1);
				     call ioa_ (M2);

				     go to comp_term;

				end;		/* then */

			     else call ioa_ (M1);

			     opts.fmt, fixed_common.options.fmt = "1"b;

			     call set_options (", (fmt);", 8);

			end;			/* then */

		end;				/* then */

	     else ;				/* do nothing */

	else do;

		if opts.card
		then do;

			call ioa_ (M2);

			go to comp_term;

		     end;				/* then */

	     end;					/* else */

	ecs = expand | opts.card | opts.fmt;


	if ecs & en_len > 9
	then if substr (en_1, en_len - 8) = ".ex.cobol"
	     then do;

		     call ioa_ (M4);
		     expand, opts.exp, opts.card, opts.fmt = "0"b;

		end;				/* then */

	call cobol_version$print;

/* end changes for [4.1-1] */

	if ecs
	then do;

/*[4.4-6]*/
		if opts.pst
		then call f_mess;

		if time
		then call hcs_$get_usage_values (pb_pf, pb_tm, pb_pp);

		save_sfp = cobol_sfp;
		ecs_info_ptr = addr (ecs_info_table);
		ecs_info_table.input_ptr = cobol_sfp;	/*[4.1-1]*/
		ecs_info_table.card_indicator = opts.card;
						/*[4.1-1]*/
		ecs_info_table.exp_indicator = expand;
		ecs_info_table.format_indicator = opts.fmt;
		ecs_info_table.compiler_level = fixed_common.comp_level;
		ecs_info_table.diag_indicators = "000"b;
		ecs_info_table.fatal_count = 0;	/*[4.0-1]*/
		ecs_info_table.levsv = fixed_common.levsv;

/*[4.1-1]*/
		ecs_info_table.dir = pdpath;		/*[4.1-1]*/
		ecs_info_table.ent = substr (ename, 1, len) || ".ex.cobol";

		call expand_cobol_source$expand (ecs_info_ptr, mcode);

		if mcode ^= 0
		then goto multics_error;

/*[5.1-2]*/
		BC = ecs_info_table.bc;

		cobol_sfp = ecs_info_table.output_ptr;
		fixed_common.fatal_no = fixed_common.fatal_no + ecs_info_table.fatal_count;

		if time
		then call timer ("EXPAND........");
	     end;					/* [3.0-8] */

/*[5.1-2]*/
	call cobol_merge$source_file_size (BC);

	entry_ptr = addr (branch_status);		/* [3.0-6] */

	call hcs_$fs_get_path_name (cobol_sfp, dn, i, en, mcode);
						/* [3.0-6] */

	if mcode ^= 0
	then goto multics_error;			/* [3.0-6] */

	call push_name (dn, en);			/* [3.0-6] */

     end;

lex:
     proc;

	call cobol_swf_open (cobol_m1fp, ST, tptr, tln, "ou");
	call cobol_swf_open (cobol_m2fp, ST, tptr, tln, "ou");
	call cobol_swf_open (cobol_pfp, ST, tptr, tln, "ou");

	fixed_common.descriptor = common.descriptor;

	call cobol_swf_open (cobol_dfp, ST, tptr, tln, "ou");

	save_m2fp = cobol_m2fp;

/* START LEX PHASE */

	if time
	then call hcs_$get_usage_values (pb_pf, pb_tm, pb_pp);

	endlex_sw = "0"b;				/* 10-27-77 */
						/*[4.4-3]*/
	fixed_common.syntax_trace = trace.rw;

	call cobol_lex (enb);

/*[4.4-3]*/
	fixed_common.syntax_trace = "0"b;
	endlex_sw = "1"b;				/* 10-27-77 */
						/*[4-1.2]	cobol_m2fp = save_m2fp;*/
	fixed_common.last_print_rec = cobol_lpr;

	call cobol_swf_close (cobol_pfp, ST, tptr, 0);

	cobol_sfp = pointer (cobol_sfp, 0);		/* reset to start of source */

	if time
	then call timer ("LEX...........");

	if fixed_common.prog_name = "" | fixed_common.prog_name = substr (ename, 1, len)
	then tname = substr (ename, 1, len);
	else tname = substr (ename, 1, len) || "$" || fixed_common.prog_name;

	mcode = -3;				/* avoid stop run if only prog in run unit */

	call cobol_control_$cancel (tname, 0, 1, mcode);

/*[5.1-2]*/
	if MODE = 5
	then go to lex_quit;

     end;

ided:
     proc;

/*************************************/
/* POSITION FILES FOR ID/ED */

	if time
	then call hcs_$get_usage_values (pb_pf, pb_tm, pb_pp);

	call cobol_swf_close (cobol_m1fp, ST, tptr, 0);
	call cobol_swf_open (cobol_m1fp, ST, tptr, tln, "in");

/* START ID/ED SYNTAX PHASE */

	cobol_com_fileno = cobol_cmfp;		/*{4.4-3]*/
	cobol_name_fileno, cobol_name_fileno_ptr = cobol_ntfp;
	cobol_min1_fileno = cobol_m1fp;
	fixed_common.syntax_trace = trace.id;

	call cobol_idedsyn;

	fixed_common.syntax_trace = "0"b;

	if fixed_common.prog_name = ""
	then fixed_common.prog_name = substr (ename, 1, len);
						/* PROGRAM-ID missing */

	if time
	then call timer ("ID/ED SYNTAX..");

     end;

dd:
     proc;

/*************************************/
/* START DD SYNTAX PHASE */

	if time
	then call hcs_$get_usage_values (pb_pf, pb_tm, pb_pp);

	fixed_common.syntax_trace = trace.dd;

	call cobol_ddsyntax;

	fixed_common.syntax_trace = "0"b;

	if time
	then call timer ("DD SYNTAX.....");

	call cobol_swf_close (cobol_m1fp, ST, tptr, rel); /* close and release cobol_minpral-1_ */

     end;


ddalloc:
     proc;

/*************************************/
/* START DD ALLOCATION PHASE */

	if time
	then call hcs_$get_usage_values (pb_pf, pb_tm, pb_pp);

	call cobol_swf_open (cobol_$initval_file_ptr, ST, tptr, tln, "ou");

	ddsyn_sw = "1"b;

	call cobol_init_$segs (mcode, tpath);		/* [3.0-2] */

	if mcode ^= 0
	then go to comp_term;

/*************************************/
/* GET LINK OFFSET FOR COBOL RUN TIME PACKAGE */
/*-04/08/76-*/
	linkoff = 0;

	call cobol_make_link_$type_4 (linkoff, "cobol_rts_");

	call cobol_ddalloc;

	if time
	then call timer ("DD ALLOCATION.");

     end;

replace:
     proc;

/*************************************/
/* POSITION FILES FOR REPLACEMENT */

	if time
	then call hcs_$get_usage_values (pb_pf, pb_tm, pb_pp);

	call cobol_swf_close (cobol_$initval_file_ptr, ST, tptr, 0);
	call cobol_swf_close (cobol_m2fp, ST, tptr, 0);
	call cobol_vdwf_close (cobol_ntfp, ST, tptr, 0);
	call cobol_swf_open (cobol_m2fp, ST, tptr, tln, "in");
	call cobol_swf_open (cobol_rm2fp, ST, tptr, tln, "ou");
	call cobol_vdwf_open (cobol_ntfp, ST);

/*[4.4-3]*/
/*cobol_name_fileno_ptr = cobol_ntfp;*/

	cobol_curr_in = cobol_m2fp;
	cobol_curr_out = cobol_rm2fp;

/* START REPLACEMENT PHASE */

	mem_size = 1048575;				/* Number of bytes in 262143 words */

	call cobol_repl3 (mem_size, rtbuff_ptr);

	if time
	then call timer ("REPLACEMENT...");

	cobol_m2fp = cobol_curr_in;
	cobol_rm2fp = cobol_curr_out;

	call cobol_swf_close (cobol_m2fp, ST, tptr, rel); /* close and release input to replacement */
	call cobol_swf_close (cobol_rm2fp, ST, tptr, 0);	/* close and retain output from replacement */
	call cobol_swf (cobol_pdofp, fdir || ">cobol_pdout_");
	call cobol_swf_open (cobol_pdofp, ST, tptr, tln, "ou");

	repl_sw = "1"b;

     end;

db_corr:
     proc;

	call cobol_swf_open (cobol_rm2fp, ST, tptr, tln, "in");

/*[4.0-3]*/
	if fixed_common.corr | fixed_common.initl	/*[4.0-3]*/
	then do;
		call START;			/*OPEN(corrout_)*/

/*[4.0-3]*/
		call cobol_ci_phase;

/*[4.0-3]*/
		if fixed_common.debug		/*[4.0-3]*/
		then do;
			call START_DB;		/* OPEN(rmin2_) */

/*[4.0-3]*/
			fixed_common.syntax_trace = trace.db;
						/*[4.0-3]*/
			call cobol_db_phase;	/*[4.0-3]*/
			fixed_common.syntax_trace = "0"b;

/*[4.0-3]*/
			call FINISH_DB;		/* CLOSE(corrout_,rmin2_) */
						/*[4.0-3]*/
						/* OPEN(rmin2_) */
						/*[4.0-3]*/
		     end;				/*[4.4-9]*/
		else call FINISH ("CORRESPONDING.");

/*[4.0-3]*/
	     end;					/*[4.0-3]*/
	else if fixed_common.debug			/*[4.0-3]*/
	then do;
		call START;			/* OPEN(corrout_) */

/*[4.0-3]*/
		fixed_common.syntax_trace = trace.db;	/*[4.0-3]*/
		call cobol_db_phase;		/*[4.0-3]*/
		fixed_common.syntax_trace = "0"b;

/*[4.0-3]*/
		call FINISH ("DEBUG.........");	/* CLOSE(rmin2_,corrout_) */
						/*[4.0-3]*/
						/* OPEN(corrout_) */
						/*[4.0-3]*/
	     end;

     end;

print_diag:
     proc;

/*************************************/
/* START PRINT_DIAG PHASE */


	if fixed_common.fatal_no ^= 0
	then do;

		if fixed_common.fatal_no > 1
		then errorcon = "errors";
		else errorcon = "error";

		call ioa_ ("");

		if abort_sw
		then call com_err_ (0, "cobol", "^d other fatal ^a encountered in ^a to this point.",
			fixed_common.fatal_no, errorcon, enb);
		else call com_err_ (0, "cobol", "^d fatal ^a encountered in ^a.", fixed_common.fatal_no, errorcon,
			enb);

	     end;

	if time
	then call hcs_$get_usage_values (pb_pf, pb_tm, pb_pp);

	if opts.exs
	then do;

		call delete_$path (pln, ln, "100111"b, "", mcode);
						/* [3.0-5] */

		wdir = get_wdir_ ();
		call cobol_cselfle (ST, cobol_hfp, enb || ".list", " ", 0, "h", ""b);
						/* open list file */

	     end;

	call cobol_swf_open (cobol_pfp, ST, tptr, tln, "in");
	call cobol_swf_open (cobol_dfp, ST, tptr, tln, "in");

	if fixed_common.options.exp = "0"b
	then ecs_info_table.diag_indicators = "000"b;	/* [3.0-10] */

	call cobol_print_diag;			/* [4.1-2] */

	call cobol_swf_close (cobol_pfp, ST, tptr, rel);	/* close and release cobol_print_ */
	call cobol_swf_close (cobol_dfp, ST, tptr, rel);	/* close and release cobol_diags_ */
	call cobol_swf_close (cobol_pdofp, ST, tptr, 0);

	if time
	then call timer ("PRINT DIAG....");

	call cobol_swf_close (cobol_rm2fp, ST, tptr, rel);/* close and release cobol_rmin2_ */

	if opts.exs
	then call cobol_cselfle (ST, cobol_hfp, " ", " ", 1, "k", "0"b);
						/* close list file setting bitcount */

	if opts.exs
	then do;

		segname = substr (cobol_$obj_seg_name, 1, index (cobol_$obj_seg_name, " ") - 1) || ".list";

		call hcs_$initiate_count (wdir, segname, "", BC, 01b, cobol_$list_ptr, mcode);

		if cobol_$list_ptr = null ()
		then go to multics_file_error;

		cobol_$list_off = divide (BC + 8, 9, 24, 0) + 1;

	     end;
	else cobol_$list_ptr = null ();

/*************************************/

	if fixed_common.fatal_no ^= 0 | ^opts.cu | abort_sw
	then do;

		if fixed_common.fatal_no ^= 0 & ^abort_sw
		then call com_err_ (error_table_$translation_failed, "cobol");
		else if ^opts.cu
		then call ioa_ ("cobol: No object program generated for ^a.", enb);

		if intact & ^time
		then call timer ("Front:");

		go to no_gen;

	     end;

	if intact & ^time
	then do;

		call timer ("Front:");
		call hcs_$get_usage_values (pb_pf, pb_tm, pb_pp);

	     end;


     end;


generator:
     proc;

/*************************************/
/*************************************/
/* START GENERATOR PHASE */

	cobol_$next_tag = fixed_common.spec_tag_counter + 1;
	segname = "cobol_pdout_";


	call hcs_$initiate (fpath, segname, "", 0b, 00b, cobol_$minpral5_ptr, mcode);

	if cobol_$minpral5_ptr = null ()
	then go to multics_file_error;

	if opts.pst | opts.obj | opts.m_map
	then cobol_$pd_map_sw = 1;
	else cobol_$pd_map_sw = 0;

	if opts.pst
	then do;

		call cobol_vdwf_close (cobol_ntfp, ST, tptr, 0);
		call cobol_vdwf_open (cobol_ntfp, ST);

	     end;

	gen_sw = "1"b;

	if time
	then call hcs_$get_usage_values (pb_pf, pb_tm, pb_pp);

	call cobol_gen_driver_;

	if time
	then call timer ("GENERATOR.....");

	cobol_$constant_offset = cobol_$con_wd_off - mod (cobol_$con_wd_off, 2);

     end;

analyzer:
     proc;

/*************************************/
/* START ANALYZER PHASE */

	if opts.xrn & fixed_common.fatal_no = 0
	then do;					/*[3.0-1]*/

		if time
		then call hcs_$get_usage_values (pb_pf, pb_tm, pb_pp);

		call cobol_make_xref_;

		if time
		then call timer ("ANALYZER......");

	     end;

     end;

fixup:
     proc;

/*************************************/
/* START FIXUP PHASE */

	if time
	then call hcs_$get_usage_values (pb_pf, pb_tm, pb_pp);

	call cobol_fix_driver_;

	if time
	then call timer ("FIXUP.........");

	if intact & ^time
	then call timer ("Back :");

     end;

finish_proc:
     proc;

/* FINISH UP */

	if repl_sw
	then call cobol_swf_close (cobol_pdofp, ST, tptr, rel);
						/* close and release cobol_pdout_ */

	if ddsyn_sw
	then call cobol_swf_close (cobol_$initval_file_ptr, ST, tptr, rel);
						/* close and release cobol_initval_ */

	call cobol_vdwf_close (cobol_cmfp, ST, tptr, rel);/* close and release cobol_common_ */

	call cobol_vdwf_close (cobol_ntfp, ST, tptr, rel);/* close and release cobol_name_table_ */

	if abort_sw
	then call com_err_ (error_table_$translation_aborted, "cobol");

	call CLEANUP;				/* [3.0-4] */

/* [3.0-9] */
	call finis;

	if time | intact
	then do;

		pb_tm = rb_tm;
		pb_pf = rb_pf;
		pb_pp = rb_pp;

		if time
		then call timer ("TOTAL:");
		else call timer ("Total:");

	     end;

     end;





/*[4.1-1]*/

get_length:
     proc (p, l, j);

declare	p		ptr,
	l		fixed bin,
	j		fixed bin,
	name		char (l) based (p);

	j = index (name, " ");

	if j = 0
	then j = l;
	else j = j - 1;

     end get_length;

/*[4.1-1]*/

set_options:
     proc (str, size);

declare	str		char (*),
	size		fixed bin;

	if substr (cobol_options, cobol_options_len, 1) = ";"
	then cobol_options_len = cobol_options_len - 1;

	substr (cobol_options, cobol_options_len + 1, 8) = substr (str, 1, size);

	cobol_options_len = cobol_options_len + size;

     end set_options;


/*[4.0-3]*/

START:
     proc;

/*[4.0-3]*/
/*[4.0-3]*/
	if time
	then call hcs_$get_usage_values (pb_pf, pb_tm, pb_pp);

/*[4.0-3]*/
	call cobol_swf (cobol_m1fp, fdir || ">cobol_corrout_");
						/*[4.0-3]*/
	call cobol_swf_open (cobol_m1fp, ST, tptr, tln, "ou");
						/* output, corres or db */

/*[4.0-3]*/
	cobol_rmin2fp = cobol_rm2fp;			/* input, corres or db */
						/*[4.0-3]*/
	cobol_x3fp = cobol_m1fp;			/* output, corres or db */

     end;

/*[4.0-3]*/

FINISH:
     proc (ph_name);

/*[4.0-3]*/
/*[4.0-3]*/
dcl	ph_name		char (14);

/*[4.0-3]*/
	call cobol_swf_close (cobol_rm2fp, ST, tptr, 1);	/* input, corres or db */

/*[4.0-3]*/
	cobol_rm2fp = cobol_x3fp;			/* output of corres or db becomes input to pd */

/*[4.0-3]*/
	call cobol_swf_close (cobol_x3fp, ST, tptr, 0);	/* output, corres or db */
						/*[4.0-3]*/
	call cobol_swf_open (cobol_rm2fp, ST, tptr, tln, "in");
						/* input, pd */

/*[4.0-3]*/
	if time
	then call timer (ph_name);

     end;

/*[4.0-3]*/

START_DB:
     proc;

/*[4.0-3]*/
/*[4.0-3]*/
	if time
	then call hcs_$get_usage_values (pb_pf, pb_tm, pb_pp);

/*[4.4-9]*/
	call cobol_swf_close (cobol_m1fp, ST, tptr, 0);	/* output, corres */
						/*[4.4-9]*/
	call cobol_swf_close (cobol_rm2fp, ST, tptr, 0);	/* input, corres */

/*[4.0-3]*/
	cobol_rmin2fp = cobol_m1fp;			/* input, db */
						/*[4.0-3]*/
	cobol_x3fp = cobol_rm2fp;			/* output, db */

/*[4.4-9]*/
	call cobol_swf_open (cobol_m1fp, ST, tptr, tln, "in");
						/* input, db */
						/*[4.4-9]*/
	call cobol_swf_open (cobol_rm2fp, ST, tptr, tln, "ou");
						/* output, db */

     end;						/*[4.0-3]*/

FINISH_DB:
     proc;

/*[4.0-3]*/
/*[4.0-3]*/
	call cobol_swf_close (cobol_rmin2fp, ST, tptr, 1);/* input, db */

/*[4.0-3]*/
	cobol_rm2fp = cobol_x3fp;			/* output of db becomes input to pd */

/*[4.0-3]*/
	call cobol_swf_close (cobol_x3fp, ST, tptr, 0);	/* output, db */
						/*[4.0-3]*/
	call cobol_swf_open (cobol_rm2fp, ST, tptr, tln, "in");
						/* input, pd */

/*[4.0-3]*/
	if time
	then call timer ("DEBUG.........");

     end;						/*[4.0-3]*/

/*************************************/
/* TIMER PROCEDURE */

timer:
     proc (phase);

dcl	phase		char (14);
dcl	(temp, lp, rp)	fixed bin (35);

	call hcs_$get_usage_values (pe_pf, pe_tm, pe_pp);
	temp = pe_tm - pb_tm;
	pb_pf = pe_pf - pb_pf;
	pb_pp = pe_pp - pb_pp;
	lp = divide (temp, 1000000, 35, 0);
	rp = mod (temp, 1000000);
	rp = divide (rp, 1000, 35, 0);

	call ioa_ ("^a ^2d.^3d seconds,^3d pagefaults,^3d prepages.", phase, lp, rp, pb_pf, pb_pp);
	return;
     end timer;

/*[4.0-1]*/

setlev:
     proc (lv, sv);

/*[4.0-1]*/
dcl	(lv, sv)		char (1);

/*[4.0-1]*/
	if lv < "1" | lv > "5"
	then go to arg_error;

/*[4.0-1]*/
	COMP_LEVEL = lv;

/*[4.0-1]*/
	if sv = "1"
	then LEVSV = "100"b;			/*[4.0-1]*/
	else if sv = "2"
	then LEVSV = "010"b;			/*[4.0-1]*/
	else if sv = "3"
	then LEVSV = "001"b;			/*[4.0-1]*/
	else go to arg_error;

     end;

/*[4.0-1]*/

/*[4.0-2]*/

setsv:
     proc (sv);


/*[4.0-2]*/
dcl	sv		char (1);

/*[4.0-2]*/
	if sv < "1" | sv > "4"
	then go to arg_error;

/*[4.0-2]*/
	opts.m_obs = "1"b;

/*[4.2-4]*/
	if sv = "4"				/*[4.2-4]*/
	then opts.m_fat, opts.m_wn, opts.m_obs = "0"b;	/*[4.0-2]*/
	else if sv = "3"				/*[4.0-2]*/
	then opts.m_wn, opts.m_obs = "0"b;		/*[4.0-2]*/
	else if sv = "2"				/*[4.0-2]*/
	then opts.m_obs = "0"b;

     end;

/*[4.0-2]*/


/*************************************/
/* CLEANUP PROCEDURE FOR CLEANUP CONDITION */

CLEANUP:
     proc;					/* [3.0-4] */

	if ^recursion
	then return;				/* 10-27-77 */

	recursion = "0"b;
	revert cleanup;				/* [3.0-4] */

/*[5.1-3]*/
	if cobol_$include_cnt > 0
	then do i = 0 to cobol_$include_cnt;
		call cobol_cselfle (ST, include_ptr (i), " ", " ", 0, "k", "0"b);
	     end;

	if ^intact
	then do segname = "cobol_seg1_", "cobol_seg2_", "cobol_seg3_", "cobol_initval_", "cobol_ntbuff_",
		"cobol_minpral-1_", "cobol_minpral-2_", /*[4.4-3]*/
		"rwdd.incl.cobol", "rwpd.incl.cobol", "cobol_rmin2_", "cobol_r2min2_", "cobol_print_", "cobol_diags_",
		"cobol_pdout_", "cobol_corrout_",	/*[4.4-8]*/
		"cobol_pdout_",			/*[4.4-8]*/
		"cobol_initval_",			/*[4.4-8]*/
		"cobol_print_",			/*[4.4-8]*/
		"cobol_diags_",			/*[4.4-8]*/
		"cobol_rmin2_",			/*[4.4-8]*/
		"cobol_minpral-1_", "cobol_minpral-2_", /*[4.4-8]*/
		"cobol_name_table_", "cobol_common_", "cobol_name_table_", "cobol_format_temp_";
		call hcs_$truncate_file (fpath, segname, 0, mcode);
		call hcs_$terminate_file (fpath, segname, 0b, mcode);
						/*[4.4-8]*/
		call hcs_$set_bc (fpath, segname, 0, mcode);
	     end;

/* [3.0-9] */
	call finis;

	return;

     end CLEANUP;					/* [3.0-4] */

COND:
     proc (cond_name);				/* [3.0-4] */

declare	cond_name		char (*),
	code		fixed bin (35);		/* [3.0-4] */
declare	find_condition_info_
			entry (ptr, ptr, fixed bin (35));
						/* [3.0-4] */

	call find_condition_info_ (null (), addr (cond_info), code);
						/* [3.0-4] */

	call cobol_error (cond_name, cond_info.infoptr, "0"b);
						/* [3.0-4] */

/* [3.0-9] */
	call finis;

     end;


cobol_error:
     proc (cond_name, sptr, cont);			/* condition handler for compile time errors */

dcl	sptr		ptr;
dcl	cond_name		char (*);
dcl	cont		bit (1);
dcl	1 s		based (sptr),
	  2 name		char (32),
	  2 len		fixed bin,
	  2 string	char (0 refer (s.len));

dcl	1 io		based (sptr),
	  2 name		char (32),
	  2 code		fixed bin (35),
	  2 action	fixed bin,		/* 1 - init */
						/* 2 - open */
						/* 3 - get */
						/* 4 - put */
						/* 5 - dget */
						/* 6 - dput */
						/* 7 - close */
						/* 8 - bad cobol_cselfle type */
						/* 9 - bad open mode for sequential file */
	  2 iocb_ptr	ptr,
	  2 file_type	fixed bin,		/* 1 - source */
						/* 2 - copy */
						/* 3 - list */
						/* 4 - cobol_swf */
						/* 5 - cobol_vdwf */
	  2 key		char (5);			/* valid only for type 5, action 5 | 6 */

dcl	action_con	(7) char (10)
			init ("initialize", "open", "get", "put", "direct get", "direct put", "close");
dcl	attach_descrip	char (172) varying based (io.iocb_ptr -> iocb.attach_descrip_ptr);

start_error:
	if cond_name = "command_abort_" | cond_name = "command_abort"
						/* [3.0-4] */
	then if s.name = "cobol_io_"
	     then do;

		     if io.action > 7
		     then do;

			     if action = 8
			     then call com_err_ (error_table_$no_operation, "cobol", "Bad cobol_cselfle file type");
			     else call com_err_ (error_table_$no_operation, "cobol",
				     "Bad open mode for a sequential file");

			end;

		     else if io.file_type = 0 | io.file_type > 3
		     then do;

			     if io.file_type > 3
			     then do;

				     call com_err_ (error_table_$no_operation, "cobol",
					"Attempting to ^a internal work file at ^p", action_con (io.action),
					io.iocb_ptr);

				     if io.file_type = 5 & (io.action = 4 | io.action = 5)
				     then call com_err_ (0, "cobol", "Key is ^a", io.key);

				end;

			     else call com_err_ (error_table_$no_operation, "cobol", "Referencing ^p", io.iocb_ptr);

			     call com_err_ (error_table_$translation_aborted, "cobol");

			end;

		     else call com_err_ (io.code, "cobol", substr (attach_descrip, 7));
		     go to comp_term;

		end;

	     else do;

		     if substr (s.name, 1, 6) = "cobol_"
		     then call com_err_ (0, "cobol", "Unrecoverable code generator error (^a).  ^a.",
			     substr (s.name, 7), s.string);
		     else call com_err_ (0, "cobol", "Unrecoverable ^a error.  ^a.", s.name, s.string);

		end;

	else do;					/* other condition */

		call com_err_ (0, "cobol", "Unrecoverable error.  Unexpected condition signalled.");

		if ^restart
		then do;
			restart = "1"b;
			call cobol$restart;
		     end;

		cont = "1"b;

		return;

	     end;

	if ^intact
	then do;
		if abort_sw
		then go to finish;			/* recursion not allowed */
		else abort_sw = "1"b;

		if ^endlex_sw
		then go to finish;

		if endgen_sw
		then go to finish;
		else if gen_sw
		then go to no_gen;
		else go to start_print_diag;
	     end;
	else call cu_$cl;

	return;

     end cobol_error;


/*************************************/

print_options:
     proc;

dcl	message		char (80);

/*[4.2-2]*/

/*[4.2-3]*/
	call com_err_ (error_table_$noarg, "cobol");

	call cobol_version$print;

/*[4.2-3]*/
	call ioa_ ("Usage: cobol path {ctl_args}");	/*[4.2-3]*/
	call ioa_ ("Control arguments:-map -list -no_table -profile");
						/*[4.2-3]*/
	call ioa_ ("-brief -check -runtime_check -expand");
						/*[4.2-3]*/
	call ioa_ ("-format -card -temp_dir PATH");	/*[4.2-3]*/
	call ioa_ ("-severity N -level NM");

     end print_options;




init:
     proc;

/**/
/**/
	code = 0;					/**/
						/**/
	call get_temp_segments_ ("cobol", temp_ptr, code);/**/
						/**/
	if code ^= 0
	then return;				/**/
						/**/
	area_infop = addr (area_info_area);		/**/
						/**/
	area_info_area.version = area_info_version_1;	/**/
	area_info_area.owner = "cobol";		/**/
	area_info_area.areap = temp_ptr (1);		/**/
	area_info_area.size = sys_info$max_seg_size;	/**/
						/**/
	string (area_info_area.control) = "10001"b;	/**/
						/**/
	call define_area_ (area_infop, code);		/**/
						/**/
	if code ^= 0
	then return;				/**/
						/**/
	cobol_area_ptr = temp_ptr (1);		/**/
	c_name.last_name_ptr = null ();		/**/
	c_name.ct = 0;

     end;

/**/

finis:
     proc;

/**/
/**/
	if area_info_area.areap ^= null ()
	then call release_area_ (area_info_area.areap);	/**/
						/**/
	call release_temp_segments_ ("cobol", temp_ptr, code);

     end;

/* [3.0-9] */

f_mess:
     proc;

/*[4.4-6]*/
	call ioa_ (M3);

/*[4.4-6]*/
	call ioa_ ("cobol: " /*[4.4-6]*/
	     || /*[4.4-6]*/ "Compilation will take place using the source program [pd]>" /*[4.4-6]*/
	     || /*[4.4-6]*/ substr (ename, 1, len) /*[4.4-6]*/ || /*[4.4-6]*/ ".ex.cobol" /*[4.4-6]*/);

     end;

declare	DIRECTORY		fixed bin (2) static internal options (constant) init (2);

declare	1 stat		static,
	  2 (entry_ptr, save_m2fp, arg_ptr, p_ptr, e_ptr, tp_ptr, fd_ptr)
			ptr,
	  2 (tptr, rtbuff_ptr, save_sfp, format_sfp)
			ptr,
	  2 (cobol_area_ptr, source_name_ptr)
			ptr,
	  2 temp_ptr	(1) ptr,
	  2 (rb_pf, rb_pp, pb_pf, pb_pp, pe_pf, pe_pp)
			fixed bin,
	  2 (l_en, l_dn, linkoff, l, m, pc, i, MODE)
			fixed bin,
	  2 (ldp, ltp, len, fdlen, upto, en_len)
			fixed bin,
	  2 cc		fixed bin init (0),
	  2 (rb_tm, pb_tm, pe_tm)
			fixed bin (71),
	  2 (mcode, code)	fixed bin (35),
	  2 entry_type	fixed bin (2),
	  2 mem_size	fixed bin (31),
	  2 (fcom_ln, tln, rel)
			fixed bin (15),
	  2 BC		fixed bin (24),
	  2 recursion	bit (1) init ("0"b),
	  2 LEVSV		bit (3),
	  2 ST		bit (32),
	  2 (p_err, corr_sw, abort_sw, endlex_sw, gen_sw, endgen_sw, restart)
			bit (1),
	  2 (time, intact, expand, files_wd, temp_dir_sw)
			bit (1),
	  2 (repl_sw, ddsyn_sw, no_tbl_pres, tbl_pres, ecs)
			bit (1),
	  2 (lex_quit, comp_term)
			label,
	  2 answer	char (3) varying,
	  2 ename		char (32) aligned,
	  2 tpath		char (168) aligned,
	  2 fpath		char (168) init (""),
	  2 (tchar, COMP_LEVEL, ch1)
			char (1),
	  2 (segname, trace_arg, ln, en, en_1)
			char (32),
	  2 (pln, dn, dpath, pdpath, wdir)
			char (168),
	  2 arg		char (16),
	  2 errorcon	char (6),
	  2 tname		char (65),
	  2 fcom_key	char (5);


dcl	error_table_$noarg	fixed bin (35) ext static;
dcl	error_table_$badopt fixed bin (35) ext static;
dcl	error_table_$translation_failed
			fixed bin (35) ext static;
dcl	error_table_$not_act_fnc
			fixed bin (35) ext static;
dcl	error_table_$no_operation
			fixed bin (35) ext static;
dcl	error_table_$translation_aborted
			fixed bin (35) ext static;
dcl	error_table_$notadir
			fixed bin (35) ext static;
dcl	sys_info$max_seg_size
			fixed bin (35) ext static;

	/***.....	dcl Trace_Bit bit(1) static external;/**/
	/***.....	dcl Trace_Lev fixed bin static external;/**/
	/***.....	dcl Trace_Line char(60) static external;/**/
	/***.....   dcl ioa_$nnl entry options(variable);/**/

dcl	1 trace		static,
	  2 on		bit (1) init ("0"b),
	  2 id		bit (1) init ("0"b),
	  2 dd		bit (1) init ("0"b),
	  2 pd		bit (1) init ("0"b),
	  2 db		bit (1) init ("0"b),	/*[4.0-3]*/
	  2 rw		bit (1) init ("0"b);	/*[4.4-3]*/

dcl	01 ecs_info_table	automatic structure like ecs_info_table_;
dcl	1 area_info_area	aligned automatic structure like area_info;

dcl	1 common		static,			/* initial values of fixed_common */
	  2 prog_name	char (30) init (""),
	  2 compiler_rev_no char (25) init (""),
	  2 phase_name	char (6) init (""),
	  2 currency	char (1) init ("$"),
	  2 fatal_no	fixed bin (15) init (0),
	  2 warn_no	fixed bin (15) init (0),
	  2 proc_counter	fixed bin (15) init (0),
	  2 spec_tag_counter
			fixed bin (15) init (0),
	  2 file_count	fixed bin (7) init (0),
	  2 filedescr_offsets
			(20) char (5) init ((20) (5)"0"),
	  2 perf_alter_info char (5) init ("00000"),
	  2 another_perform_info
			char (5) init ("00000"),
	  2 sort_in_info	char (5) init ("00000"),
	  2 odo_info	char (5) init ("00000"),
	  2 size_seg	fixed bin (15) init (0),
	  2 size_offset	fixed bin (31) init (0),
	  2 size_perform_info
			char (5) init ("00000"),
	  2 rename_info	char (5) init ("00000"),
	  2 report_names	char (5) init ("00000"),
	  2 rw_buf_seg	fixed bin (15) init (0),
	  2 rw_buf_offset	fixed bin (31) init (0),
	  2 rw_buf_length	fixed bin (31) init (0),
	  2 file_keys	char (5) init ("00000"),
	  2 search_keys	char (5) init ("00000"),
	  2 dd_seg_size	fixed bin (31) init (65536),
	  2 pd_seg_size	fixed bin (31) init (0),
	  2 seg_limit	fixed bin (7) init (49),
	  2 number_of_dd_segs
			fixed bin (15) init (0),
	  2 seg_info	char (5) init ("00000"),
	  2 number_of_ls_pointers
			fixed bin (15) init (0),
	  2 link_sec_seg	fixed bin (15) init (0),
	  2 link_sec_offset fixed bin (31) init (0),
	  2 sra_clauses	fixed bin (15) init (0),
	  2 fix_up_info	char (5) init ("00000"),
	  2 linage_info	char (5) init ("00000"),
	  2 first_dd_item	char (5) init ("00000"),
	  2 sort_out_info	char (5) init ("00000"),
	  2 db_info	char (5) init ("00000"),
	  2 realm_info	char (5) init ("00000"),
	  2 rc_realm_info	char (5) init ("00000"),
	  2 last_file_key	char (5) init ("00000"),
	  2 prog_coll_seq	fixed bin (15) init (0),
	  2 sysin_fno	fixed bin (15) init (0),
	  2 sysout_fno	fixed bin (15) init (0),
	  2 dummy11	fixed bin (15) init (0),
	  2 dummy12	fixed bin (15) init (0),
	  2 dummy13	fixed bin (15) init (0),
	  2 dummy14	fixed bin (15) init (0),
	  2 dummy15	fixed bin (15) init (0),
	  2 opts,
	    3 cu		bit (1) unaligned,		/* produce a cu*/
	    3 pst		bit (1) unaligned,		/* produce a symbol table */
	    3 wn		bit (1) unaligned,		/* list warnings in listing*/
	    3 obs		bit (1) unaligned,		/* list observations in listing */
	    3 dm		bit (1) unaligned,		/* NA produce a data map*/
	    3 xrl		bit (1) unaligned,		/* NA list cross reference by line number*/
	    3 xrn		bit (1) unaligned,		/* list cross references by data name*/
	    3 src		bit (1) unaligned,		/* NA list original source */
	    3 obj		bit (1) unaligned,		/* list object code */
	    3 exs		bit (1) unaligned,		/* list expanded source*/
	    3 sck		bit (1) unaligned,		/* NA sequence check the source*/
	    3 rno		bit (1) unaligned,		/*NA renumber the output source*/
	    3 u_l		bit (1) unaligned,		/* convert lower case to upper case (1) or
				   convert upper case to lower case (0).
				   Only meaningful if cnv = 1. */
	    3 cnv		bit (1) unaligned,		/* do concobol_version specified in u_l. */
	    3 cos		bit (1) unaligned,		/* NA compile optional source statements */
	    3 fmt		bit (1) unaligned,		/* accept pseudo-free-form source */
	    3 profile	bit (1) unaligned,
	    3 nw		bit (1) unaligned,		/* observations and warnings not printed on output listing*/
						/*06-30-77*/
	    3 exp		bit (1) unaligned,		/* option to call cobol_expand_source_ */
	    3 card	bit (1) unaligned,		/*[4.1-1]*/
	    3 fil2	bit (5) unaligned,
	    3 m_map	bit (1) unaligned,		/* Produce a procedure division map*/
	    3 m_bf	bit (1) unaligned,		/* print brief diags on terminal */
	    3 m_fat	bit (1) unaligned,		/* print fatal diags on terminal */
	    3 m_wn	bit (1) unaligned,		/* print warnings on terminal */
	    3 m_obs	bit (1) unaligned,		/* print observations on terminal*/
	    3 pd		bit (1) unaligned,		/* print diags on terminal */
	    3 oc		bit (1) unaligned,		/* generate code for object time checking*/
	  2 supervisor	bit (1) init ("0"b),
	  2 dec_comma	bit (1) init ("0"b),
	  2 init_cd	bit (1) init ("0"b),
	  2 corr		bit (1) init ("0"b),
	  2 initl		bit (1) init ("0"b),
	  2 debug		bit (1) init ("0"b),
	  2 report	bit (1) init ("0"b),
	  2 sync_in_prog	bit (1) init ("0"b),
	  2 pd_section	bit (1) init ("0"b),
	  2 list_switch	bit (1) init ("1"b),
	  2 alpha_cond	bit (1) init ("0"b),
	  2 num_cond	bit (1) init ("0"b),
	  2 spec_sysin	bit (1) init ("0"b),
	  2 spec_sysout	bit (1) init ("0"b),
	  2 dummy16	bit (1) init ("0"b),
	  2 obj_dec_comma	bit (1) init ("0"b),
	  2 default_sign_type
			bit (3) init ("001"b),	/* trailing overpunch */
	  2 default_display bit (1) init ("0"b),
	  2 syntax_trace	bit (1) init ("0"b),
	  2 dummy17_1	bit (17) init (""b),
	  2 descriptor	bit (2) init ("10"b),
	  2 levsv		bit (3) init ("001"b),	/*[4.0-1]*/
	  2 dummy17	bit (5) init (""b),
	  2 lvl_rstr	bit (32) init (""b),
	  2 inst_rstr	bit (32) init (""b),
	  2 comp_level	char (1) init ("5"),
	  2 dummy18	char (30) init (""),
	  2 object_sign	char (1) init (""),
	  2 last_print_rec	char (5) init ("00000"),
	  2 coll_seq_info	char (5) init ("00000"),
	  2 sys_status_seg	fixed bin (15) init (0),
	  2 sys_status_offset
			fixed bin (31) init (0),
	  2 compiler_id	fixed bin (15) init (3),
	  2 date_comp_ln	fixed bin (15) init (0),
	  2 compile_mode	bit (36) init ("0"b),
	  2 default_temp	fixed bin (15) init (30),
	  2 dummy26	fixed bin (15) init (0),
	  2 display_device	fixed bin (15) init (0),
	  2 dummy28	fixed bin (15) init (0),
	  2 alphabet_offset fixed bin init (0);

declare	1 MESS		static,
	  2 M1		char (77)
			init ("cobol: The -fmt option is assumed since the file is apparently in free format"),
	  2 M2		char (60) init ("cobol: The -card option is inconsistant with the -fmt option"),
	  2 M3		char (102)
			init (
			"cobol: A run time symbol table was requested and one of the options -expand, -format or -card was used"
			),
	  2 M4		char (111)
			init (
			"cobol: The -exp option may not be used if the entry name of the source program ends in "".ex.cobol"""
			);

dcl	1 c_name		static,			/*[3.0-9]*/
	  2 ct		fixed bin,		/*[3.0-9]*/
	  2 size		fixed bin,		/*[3.0-9]*/
	  2 last_name_ptr	ptr,
	  2 pname		char (168) aligned,
	  2 uid		bit (36),
	  2 dtm		bit (36);

dcl	1 query_info	aligned static,
	  2 cobol_version	fixed bin init (2),
	  2 yes_or_no_sw	bit (1) unal init ("1"b),
	  2 suppress_name_sw
			bit (1) unal init ("0"b),
	  2 status_code	fixed bin (35) init (0),
	  2 query_code	fixed bin (35) init (0);

dcl	01 anarea		based (rtbuff_ptr) aligned,
	  02 dummy_ptr	ptr,
	  02 rtarea	char (82000);


dcl	argb		char (l) based (arg_ptr);
dcl	tpb		char (ltp) based (tp_ptr);	/* path name of source program (minus .cobol */
dcl	dpb		char (ldp) based (p_ptr);	/* path name of directory of source program */
dcl	enb		char (len) based (e_ptr);	/* name of object program */
dcl	first_source_line	char (32) based (cobol_sfp);	/*[5.1-3]*/
dcl	include_ptr	(0:1000) ptr based (cobol_$include_info_ptr);

/* [3.0-9] */
dcl	words		(alloc_size) fixed bin (35) based;
						/* [3.0-9] */
dcl	cobol_area	area based (cobol_area_ptr);
dcl	lname		char (len + 5) based (addr (ln));


dcl	1 source_name	based (source_name_ptr),	/* [3.0-9] */
	  2 prev_name_ptr	ptr,
	  2 sname		char (168) aligned,
	  2 uid		bit (36),
	  2 dtm		bit (36);

declare	fdir		char (fdlen) based (fd_ptr);	/* pathname or dir containing work files */


declare	(command_abort, command_abort_, cleanup)
			condition;		/* [3.0-4] */

/*[5.1-2]*/
declare	cobol$define_data	entry;

dcl	expand_cobol_source$expand
			entry (ptr, fixed bin (35));
dcl	hcs_$fs_get_path_name
			entry (ptr, char (*), fixed bin, char (*), fixed bin (35));
declare	hcs_$status_long	entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35));
						/* [3.0-6] */
declare	delete_$path	entry (char (*), char (*), bit (6), char (*), fixed bin (35));
						/* [3.0-5] */

dcl	(size, divide, index, mod, null, pointer, string, substr, addr)
			builtin;

dcl	cobol$restart	ext entry;
dcl	cobol_control_$cancel
			ext entry (char (*), fixed bin, fixed bin, fixed bin (35));
dcl	cobol_version$print entry;
dcl	cobol_make_link_$type_4
			entry (fixed bin, char (*));
dcl	cobol_version$set	entry;
dcl	cu_$cl		ext entry;
dcl	cobol_lex		ext entry (char (*));
dcl	cobol_repl3	ext entry (fixed bin (31), ptr);
dcl	cobol_print_diag	entry;

dcl	(cobol_pdstax, cobol_ddsyntax, cobol_ddalloc, cobol_idedsyn, cobol_ci_phase, cobol_db_phase, cobol_gen_driver_,
	cobol_fix_driver_, cobol_make_xref_)
			ext entry;


dcl	(cobol_generator, cobol_fixup)
			ext entry;
dcl	cobol_source_formatter_
			entry (ptr, ptr, fixed bin (15), fixed bin, fixed bin);
dcl	cobol_init_	ext entry (char (168), ptr);
dcl	cobol_init_$segs	ext entry (fixed bin (35), char (168) aligned);
						/* [3.0-2] */
dcl	condition_	entry (char (*), entry);
dcl	get_pdir_		entry returns (char (168) aligned);
dcl	get_wdir_		entry returns (char (168) aligned);

/*[4.4-8]*/
declare	hcs_$set_bc	entry (char (*), char (*), fixed bin (24), fixed bin (35));

dcl	hcs_$delentry_file	entry (char (*), char (*), fixed bin (35));
dcl	hcs_$truncate_file	entry (char (*), char (*), fixed bin, fixed bin (35));
dcl	hcs_$truncate_seg	entry (ptr, fixed bin, fixed bin (35));
dcl	hcs_$terminate_file entry (char (*), char (*), fixed bin (1), fixed bin (35));
dcl	hcs_$initiate_count entry (char (*), char (*), char (*), fixed bin (24), fixed bin (2), ptr, fixed bin (35));
dcl	revert_cleanup_proc_
			entry;
dcl	establish_cleanup_proc_
			entry (entry);
dcl	hcs_$make_seg	entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
dcl	hcs_$initiate	entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
dcl	com_err_		entry options (variable);
dcl	hcs_$get_usage_values
			ext entry (fixed bin, fixed bin (71), fixed bin);
dcl	ioa_		entry options (variable);
dcl	ioa_$ioa_stream	entry options (variable);
dcl	cu_$arg_count	entry (fixed bin);
dcl	cu_$af_arg_count	entry (fixed bin, fixed bin (35));
dcl	cu_$arg_ptr	entry (fixed bin, ptr, fixed bin, fixed bin (35));
dcl	cobol_syntax_trace_$initialize
			entry (ptr);
dcl	cobol_syntax_trace_$reset_trace
			entry;
dcl	cobol_gns$set_table entry;


dcl	command_query_	entry options (variable);

dcl	cobol_cselfle	entry (bit (32), ptr, char (*), char (3), fixed bin (15), char (1), bit (8)) ext;
dcl	(cobol_swf, cobol_vdwf)
			entry (ptr, char (*)) ext;
dcl	cobol_vdwf_open	entry (ptr, bit (32)) ext;
dcl	(cobol_vdwf_dget, cobol_vdwf_sput)
			entry (ptr, bit (32), ptr, fixed bin (15), char (5));
dcl	cobol_swf_open	entry (ptr, bit (32), ptr, fixed bin (15), char (2)) ext;
dcl	(cobol_swf_close, cobol_vdwf_close)
			entry (ptr, bit (32), ptr, fixed bin (15)) ext;

declare	cobol_merge$source_file_size
			entry (fixed bin (24));

/* [3.0-9] */
dcl	get_temp_segments_	entry (char (*), (*) ptr, fixed bin (35));
						/* [3.0-9] */
dcl	release_temp_segments_
			entry (char (*), (*) ptr, fixed bin (35));
						/* [3.0-9] */
dcl	define_area_	entry (ptr, fixed bin (35));	/* [3.0-9] */
dcl	release_area_	entry (ptr);


dcl	expand_pathname_	entry (char (*), char (*), char (*), fixed bin (35)),
	absolute_pathname_	entry (char (*), char (*), fixed bin (35)),
	hcs_$status_minf	entry (char (*), char (*), fixed bin (1), fixed bin (2), fixed bin (24), fixed bin (35)),
	expand_pathname_$add_suffix
			entry (char (*), char (*), char (*), char (*), fixed bin (35));


%include cobol_;
%include cobol_fixed_common;
%include cobol_ext_;
%include cobol_fsb;
%include iocb;
%include cobol_ecs_info;
/* [3.0-8] */

/*[4.4-7]*/
declare	1 branch_status	aligned like status_branch;

%include status_structures;

%include area_info;
/* [3.0-9] */

declare	1 cond_info	static,
%include cond_info;
     end cobol;
