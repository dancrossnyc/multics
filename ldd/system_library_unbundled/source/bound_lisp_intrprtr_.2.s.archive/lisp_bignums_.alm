" **************************************************************
" *                                                            *
" * Copyright, (C) Massachusetts Institute of Technology, 1973 *
" *                                                            *
" **************************************************************
"
" lisp_bignums_
"
" N.B. The algorithms presented herein are either from
" Knuth's Art of Computer Programming, vol 2 (notation
" is saved once in a while), or are obvious (hopefully)
" and commented.
" Large sections of uncommented code (such as in div_bb) will
" be easier to read with Knuth's book beside you.
"
" The format of this set of routines is internal subroutines
" first, in alphabetic order, followed by code that is referenced
" from outside.
"
" Initially coded late 1972 and early 1973 by Dan Bricklin
" Modified 75.04.17 by DAM to fix bug in haipart and convert for 6180 a little
" Last modified Christmas Eve, 1980 by Richard Lamson to fix interaction
"	between call_alloc_bfx and garbage collector.
"
	segdef	convert_bfx_to_sfl
	segdef	plus
	segdef	difference
	segdef 	times
	segdef	quotient
	segdef	fix
	segdef 	float
	segdef	add1
	segdef	sub1
	segdef	minus
	segdef	abs
	segdef	minusp
	segdef	plusp
	segdef	max
	segdef	min
	segdef	lessp
	segdef	greaterp
	segdef	remainder
	segdef	expt
	segdef	haulong
	segdef	haipart
	segdef	gcd
"
	include stack_header
	include	lisp_object_types
	include	lisp_stack_seg
	include 	lisp_name_codes
"
	bool 	nooverflow,004000		"inhibits overflow and sets carry to zero
"
" these values are used to access the AUTOMATIC VARIABLES
"
	equ	old_lp,-4			"old lp - saved by caller
	equ	bn_pl1_ptr,-4		"ptr to array
	equ	return_point,-2		"return point, saved by caller
	equ	bn_pl1_length,-2		"size of array
	equ	bn_pl1_radix,-1		"arg from pl1 caller
	equ	num_of_args,0		"what x5 contained on entry, in upper 18 bits
	equ	saved_indicators,1		"what the indicator register was, saved with an sti
	equ	initial_value,2		"used by expt and gcd to keep umkdpdl at minimum
	equ	resultp,4			"ptr to result
	equ	biggerp,6			"ptr to bigger of the two
	equ	smallerp,8		"ptr to smaller of the two
	equ	divisor,8			"place to hold sfx divisor  
	equ	multiplier,8		"place to hold sfx multiplier
	equ	addend,8			"place to hold sfx addend
	equ	big_limit,10		"length of bigger of the two
	equ	small_limit,11		"length of smaller
	equ	temp,12			"temporary double word
	equ	op_table,14		"needed to decide if add or subtract is needed
	equ	carry,15			"holds carry in multiply
	equ	carrya,16			"another carry
	equ	shift_value,17		"number of bits to shift
	equ	shiftp,18			"where to put shifted result
	equ	divisorp,20		"ptr to divisor
	equ	dividendp,22		"ptr to dividend in bfx divide
	equ	answerp,24		"ptr to quotient in bfx divide
	equ	v1p,26
	equ	presultp,26
	equ	v2p,28
	equ	powerp,28
	equ	n,30
	equ	m,31
	equ	j,32
	equ	qhat,33
	equ	rhat,34
	equ	div_bb_ret,35
	equ	div_bb_temp,36
	equ	div_bb_lsh_ret,38
	equ	switched,39
	equ	function_name,40		"function name code for error
	equ	q,41
	equ	up,42
	equ	vp,44
	equ	ptemp1,46
	equ	ptemp2,48
	equ	ptemp3,50
	equ	ptemp4,52
	equ	uh,54
	equ	vh,55
	equ	A,56
	equ	B,57
	equ	C,58
	equ	D,59
	equ	auto_block_size,60		"size, in words, of the automatic block
"
"
"
"
abs_sfx_a_to_q:				"this routine puts the abs of the a into the q.
					"if still an sfx, then it skips one on return.
					"if too big, then it doesn't skip, and returns ptr to
					"bfx version in lp.
"
	lrs	36			"get into aq
	tpl	1,x0			"positive is ok - so skip
	negl	0			"do the abs
	cmpaq	=v36/0,o36/400000000000	"is it too big?
	tnz	1,x0			"no, so skip
	tra	convert_aq_to_bfx		"yes, so convert, and conversion routine will tra 0,x0
"
"
add_bb:					"this routine adds bigger and smaller, and
					"puts result in result (already alloced).  It takes
					"care of sign problems.
"
	stx0	bp|n			"save return point
	eax4	add_opcode		"remember that we want to add
	stx4	bp|op_table
	stz	bp|switched
	lxl2	bp|biggerp,*		"set up limits
	stx2	bp|big_limit
	lxl2	bp|smallerp,*
	stx2	bp|small_limit
	tsx0	compare_bfx		"bigger better be bigger
	tsx0	switch_bfx
	nop	0,dl
	nop	0,dl
	ldx2	bp|biggerp,*		"if signs are different, subtract
	erx2	bp|smallerp,*
	adx2	bp|op_table
	epplp	1,x2*			"exop wants info in lp
	ldx2	bp|biggerp,*		"set result sign
	xec	3,x4
	stx2	bp|resultp,*
	ldx0	bp|n			"restore return point
	tra	exop_bfx			"do the add
"
"
add_bs:					"this routine adds addend to bignum bigger.
"
	lxl2	bp|biggerp,*		"set big_limit
	stx2	bp|big_limit
	eax2	1			"get ptr to first word
	epplp	add_structure		"get ready to go to exop later
	ldq	bp|biggerp,*x2		"load first word of bignum
	adlq	bp|addend			"add the sfx
	lda	0,du			"clear the a
	lls	1			"get the carry there
	qrl	1
	stq	bp|resultp,*x2		"store the result
	tra	exop_bfx_ripple		"ripple the carry
"
"
alloc_bfx6:				"this routine allocs a bignum of length x6 on
					"the unmarked stack, and returns a ptr in lp
"
	epplp	ab|0,x7			"get the ptr
	eax6	2,x6			"add 1 for header word, and 1 for 2 rounding
	anx6	-2,du			"make even
	stx6	bp|temp			"add to x7
	adx7	bp|temp
	stz	lp|0			"certain routines assume sign is set "+"
	tra	0,x0			"return
"
"
bad_error:				"recoverable, but only by giving value for function
	eax7	8,x7			"get some space
	spribp	ab|-6,x7			"save bp
	ldq	bp|function_name		"get who we are, along with error (in aq)
	staq	ab|-2,x7			"give to lisp_error_
	tsx6	call_lisp_error_		"call the error printer
	eppbp	ab|-4,x7*			"get bp back
	ldaq	ap|-2			"get value to return to caller
	eppap	ap|-2			"pop it off the mkd stack
	eax7	-6,x7			"get rid of our temp storage
	tra	return			"return to caller
"
"
badarg:					"recoverable error - input wrong type
	eax7	8,x7			"get some space on unmkd pdl
	staq	ab|-8,x7			"save the aq
	spribp	ab|-6,x7			"save the bp (ptr to auto vars)
	lda	<lisp_error_table_>|[bad_arg_correctable]
	ldq	bp|function_name		"also the name of the function causing err
	staq	ab|-2,x7
	epplp	ap|0,x5			"get ptr to offending arg
	sprilp	ab|-4,x7			"remember where it was, for reseting
	ldaq	lp|0			"give it to lisp_error_
	eppap	ap|2			"bump marked pdl
	staq	ap|-2			"store it
	tsx6	call_lisp_error_		"call lisp_error_
	ldaq	ap|-2			"get corrected arg
	eppap	ap|-2			"pop mrkd pdl
	staq	ab|-2,x7*			"store over old, bad arg
	ldaq	ab|-6,x7			"restore aq
	eppbp	ab|-4,x7*			"restore bp
	eax7	-6,x7			"free this temp space (lisp_error_ frees 2)
	tra	numval			"go back and test type again
"
"
call_alloc_bfx:				"this routine replaces result with same bignum,
					"but allocated in lisp space.
"
	stx0	bp|temp			"save return point
	sxl3	bp|temp			"save x3
"
"	Now, we need to check to see if the bignum is in the heap.
"	If it is, the pointer to it has to be in the heap during the
"	call to lisp_alloc_, because otherwise the GC could smash it.
"
	stz	bp|temp+1			"set flag
	epaq	bp|0			"get segno of unmarked pdl
	eax3	0,au			"into x3
	cmpx3	bp|resultp		"is resultp in unmkd pdl?
	tze	do_call_alloc_bfx		"yes -- go do it
	stc1	bp|temp+1			"we need to copy resultp
	ldaq	bp|resultp
	ora	Big_fixed,dl		"make it a bignum for gc
	staq	ap|0			"put onto marked stack
	eppap	ap|2
do_call_alloc_bfx:
	epplp	ab|system_lp,*		"get ptr to linkage for call
	eax5	0,x1			"alloc routine preserves x5, and we
					"need x1 saved to get our auto vars back
	ldq	bp|resultp,*		"get number of words needed, on 4 boundary
	adq	4,dl
	anq	=o777774,dl
	tsx6	<lisp_alloc_>|[words_alloc]	"make the call to the alloc routine
	eax1	0,x5			"reload x1
	epplp	bp|0			"save ptr to alloced area in lp
	eppbp	ab|0,x1			"reload ptr to auto area
	szn	bp|temp+1			"did we copy pointer?
	tze	finish_call_alloc_bfx	"no -- done
	ldaq	ap|-2			"yes -- get it from stack
	eppap	ap|-2			"reset stack ptr
	staq	bp|resultp		"and put it back where it's expected
finish_call_alloc_bfx:
	tsx6	move_bfx			"move the result into new place
	sprilp	bp|resultp		"put ptr to result in resultp
	lxl3	bp|temp
	ldx0	bp|temp			"reload return point
	tra	0,x0			"return
"
"
call_lisp_error_:				"this routine calls lisp_error_
					"it is called by a tsx6
"
	epplp	ab|system_lp,*		"get ptr to linkage
	spriap	<lisp_static_vars_>|[stack_ptr]" save interesting ptrs
	stx7	<lisp_static_vars_>|[unmkd_ptr]+1
	stc1	ab|in_pl1_code		"say we are in pl1
	push				"get place to save all registers
	call	<lisp_error_>|[lisp_error_]
	eaa	sp|16,*
	sprisp	sb|stack_header.stack_end_ptr
	eppsp	sb|0,au
	epbpab	<lisp_static_vars_>|[unmkd_ptr],*
	eppap	<lisp_static_vars_>|[stack_ptr],*
	ldx7	<lisp_static_vars_>|[unmkd_ptr]+1
	stz	ab|in_pl1_code
	tra	0,x6			"return to caller
"
"
check_aq:					"this routine skips if aq is an sfx.
"
	cmpaq	=v36/0,o36/400000000000
	tpl	0,x0			"no
	cmpaq	=v36/-1,o36/400000000000
	tpl	1,x0			"yes
	tra	0,x0			"no
"
"
compare_bfx:				"this routine compares bigger and smaller.
					"it skips 0, 1, or 2 for <, =, >.
					"it ignores the signs, and uses the limits for sizes
"
	ldx2	bp|big_limit		"load size of bigger
	cmpx2	bp|small_limit		"compare with smaller
	tmi	0,x0			"if smaller bigger, then b<s
	tze	2,ic			"if the same, then need more checking
	tra	2,x0			"otherwise, b>s, so skip 2
	eax2	1,x2			"add one to size, then start checking
compare_bfx_loop:
	eax2	-1,x2			"look at next lower order word
	tze	1,x0			"done - all equal => a=b so skip 1
	ldq	bp|biggerp,*x2		"load bigger number
	cmpq	bp|smallerp,*x2		"compare with smaller one
	tmi	0,x0			"smaller is bigger, so return no skip (b<s)
	tze	compare_bfx_loop		"try next word if equal
	tra	2,x0			"otherwise b>s, so skip 2
"
"
compare_signed_bfx:				"this routine compares bigger and smaller
					"taking into account the signs.
"
	ldx2	bp|biggerp,*		"compare signs
	cmpx2	bp|smallerp,*
	tmi	0,x0			"return with <
	tze	2,ic			"since we don't have a tpnz on 645
	tpl	2,x0			"return with >
	lxl3	bp|biggerp,*		"set up lengths
	stx3	bp|big_limit
	lxl3	bp|smallerp,*
	stx3	bp|small_limit
	eax2	0,x2			"check sign
	tmi	2,ic
	tra	compare_bfx		"for + it's the normal compare and return
	eax3	0,x0			"save return point
	tsx0	compare_bfx		"do a compare, and translate results for neg
	tra	2,x3			" >
	tra	1,x3			" =
	tra	0,x3			" <
"
"
convert_aq_to_bfx:				"this routine converts the aq to a bfx.
					"returns ptr to it in lp, and gives a bfx
					"of three words.  Won't work with -4000...
					"since it has to negate the aq
"
	epplp	ab|0,x7			"get ptr to bfx to be allocated
	eax7	4,x7			"alloc the bfx
	cmpaq	=0			"check sign
	tpl	4,ic			"skip around negate if plus
	negl	0			"do the negate
	eax2	-1			"load sign of result
	tra	2,ic
	eax2	0			"positive sign
	stx2	lp|0			"store the sign
	lls	1			"store each of the words
	qrl	1
	stq	lp|1
	eax2 	2			"load the tentative length
	lrl	35
	cmpa	0,dl
	tze	3,ic			"is the a zero? if so - length = 2
	sta	lp|3			"store the a if something there
	eax2	3			"length is 3
	qrl	1			"shift q to proper place
	stq	lp|2			"store the q
	sxl2	lp|0			"store the length
	tra	0,x0			"return
"
"
convert_bfx_to_sfl:				"this routine converts the bfx->by lp to an
					"sfl in the EAQ.  It is called by tsx6,
					"and only modifies x2.  It is an external entry.
					"It skips on return if conversion is ok, and
					"does not skip if there was an overflow
"
	lxl2	lp|0			"get length
	cmpx2	4,du
	tze	convert_bfx_to_sfl_check4	"4 is a special case - not all fit
	tpl	0,x6			"return if too big - no skip=>overflow
	lda	lp|0,x2			"load last (most sig.) word
	ldq	lp|-1,x2			"and next to last
	qls	1			"make one bit string (remove empty bit)
convert_bfx_to_sfl_l:
	lde	convert_bfx_to_sfl_tab,x2	"load an exponent
	fad	=0.0			"normalize
	ldx2	lp|0			"load the sign
	xec	convert_bfx_to_sfl_tab+1,x2	"perhaps negate
	tra	1,x6			"return with skip
convert_bfx_to_sfl_check4:
	lda	lp|0,x2			"load high order word
	cana	=vo14/37777,o22/0		"check if too big
	tnz	0,x6			"too big - don't skip
	ldq	lp|-1,x2			"load next word
	qls	1
	lls	14			"make so exponent isn't too big
	tra	convert_bfx_to_sfl_l	"join other code
convert_bfx_to_sfl_tab:
	fneg	0
	nop	0,dl
	vfd	8/70
	vfd	8/105
	vfd	8/127
"
"
convert_bfx_to_sfx:				"this routine converts result to an sfx -
					"if does not check to see if possible
"
	lxl2	bp|resultp,*		"load length
	cmpx2	2,du			"if length 2 then must be -400000000000
	tze	convert_bfx_to_sfx_2	"separate code for that
	lda	0,du			"clear a
	ldx2	1,du			"get address of low order word
	ldq	bp|resultp,*x2		"put it in q
	szn	bp|resultp,*		"do we need to negate it?
	tpl	2,ic			"no, skip neg instruction
	negl	0			"negate the aq
	lda	fixnum_type,dl		"add type bits
	tra	0,x0			"return
convert_bfx_to_sfx_2:
	ldq	=o400000000000		"load the value
	lda	fixnum_type,dl		"add type bits
	tra	0,x0			"return
"
"
convert_q_to_bfx:				"this routine returns in the lp a ptr
					"to the q in bfx format - length 2 words
"
	epplp	ab|0,x7			"get ptr to area to be allocated
	eax7	4,x7			"alloc 4 words
	cmpq	0,dl			"find out sign of number
	tmi	6,ic			"neg - have to negate for abs value
	stq	lp|1			"positive - just store as is
	stz	lp|2			"high order word is zero
	ldq	2,dl			"put in sign and length
	stq	lp|0
	tra	0,x0			"return
	lls	36			"bring into a
	lrs	36			"back to q, extending sign bit
	negl	0			"negate it
	lls	1			"bring high order bit into a
	qrl	1			"bring rest back without it
	stq	lp|1			"store double word result
	sta	lp|2
	ldq	=v18/-1,18/2		"load neg sign and length 2
	stq	lp|0			"store in bfx
	tra	0,x0			"return
"
"
convert_q_to_sfl:				"this routine converts the sfx in the q into an sfl
					"in the EAQ.
"
	lls	36
	lde	=35b25,du
	fad	=0.0,du
	tra	0,x0			"return
"
"
div_bb:					"this routine divides bfx bigger by bfx smaller,
					"and places the result in answer.
"
	stx0	bp|div_bb_ret		"save return address
	lxl2	bp|smallerp,*		"get high order word
	ldq	0,dl			"clear q
	lda	bp|smallerp,*x2		"get into EAQ
	lde	0,du
	fad	=0			"normalize (find # of leading zeroes)
	ste	bp|temp
	lda	bp|temp			"make it a number (it is negative)
	ars	28
	neg	0			"make it positive
	sta	bp|shift_value		"save as shift value
	epplp	bp|smallerp,*		"get ptr to value to be copied and shifted
	tsx0	div_bb_lsh		"do it
	sprilp	bp|divisorp		"store ptr to result
	epplp	bp|biggerp,*		"do same for other number
	tsx0	div_bb_lsh
	sprilp	bp|dividendp
	lxl2	bp|smallerp,*		"get len of divisor
	epplp	bp|divisorp,*x2		"get ptr to end of divisor
	sprilp	bp|v1p			"save for future reference
	epplp	lp|-1
	sprilp	bp|v2p
	stx2	bp|n
	lxl6	bp|biggerp,*		"get len of other
	adx6	1,du			"it is one greater than divisor
	stx6	bp|j			"save
	sbx6	bp|n			"calc length of result
	tmi	div_bb_zero		"divisor is bigger than dividend
	tze	div_bb_zero
	stx6	bp|m
	tsx0	alloc_bfx6		"alloc result
	sprilp	bp|answerp		"save ptr to it
	ldx6	bp|m			"store length
	sxl6	lp|0
	ldx6	bp|smallerp,*
	erx6	bp|biggerp,*
	stx6	bp|answerp,*		"store sign
"
get_qhat:
	ldx2	bp|j			"set lp->dividend
	epplp	bp|dividendp,*x2
	lda	lp|0			"calc quotient digit guess, a la Knuth.
	cmpa	bp|v1p,*
	tmi	div_bb_less
	ldq	=o377777777777
	lda	lp|-1
	tra	l3h
dec_qhat:
	ldq	bp|qhat
	sbq	1,dl
	lda	bp|rhat
l3h:	stq	bp|qhat
	adla	bp|v1p,*
	tmi	got_qhat
	sta	bp|rhat
	tra	got_rhat
div_bb_less:
	ldq	lp|-1
	qls	1
	dvf	bp|v1p,*
	sta	bp|qhat
	stq	bp|rhat
got_rhat:
	ldq	bp|qhat
	mpy	bp|v2p,*
	lls	1
	cmpa	bp|rhat
	tmi	got_qhat
	tnz	dec_qhat
	qrl	1
	cmpq	lp|-2
	tmi	got_qhat
	tnz	dec_qhat
"
got_qhat:
	eax3	0
	stz	bp|carry			"do multiply and subtract
	stz	bp|carrya
	sbx2	bp|n
	epplp	bp|dividendp,*x2
div_bb_loop:
	eax3	1,x3
	ldq	bp|divisorp,*x3
	mpy	bp|qhat
	adl	bp|carry
	lls	1
	qrl	1
	stq	bp|temp
	sta	bp|carry
	ldq	lp|-1,x3
	sblq	bp|carrya
	sblq	bp|temp
	lda	0,dl
	lls	1
	qrl	1
	stq	lp|-1,x3
	sta	bp|carrya
	cmpx3	bp|n
	tnz	div_bb_loop
	eax3	1,x3
	ldq	lp|-1,x3
	sblq	bp|carrya
	sblq	bp|carry
	lda	0,dl
	lls	1
	qrl	1
	stq	lp|-1,x3
	cmpa	0,dl
	tze	store_q
	ldq	bp|qhat			"qhat too big, so dec by one
	sbq	1,dl
	stq	bp|qhat
	eax3	0
	lda	0,dl			"add back in
div_bb_loop1:
	eax3	1,x3
	ldq	lp|-1,x3
	adlq	add_structure+1,al
	adlq	bp|divisorp,*x3
	lda	0,du
	lls	1
	qrl	1
	stq	lp|-1,x3
	cmpx3	bp|n
	tnz	div_bb_loop1
	eax3	1,x3
	ldq	lp|-1,x3
	adlq	add_structure+1,al
	lls	1
	qrl	1
	stq	lp|-1,x3
"
store_q:
	ldx2	bp|m
	lda	bp|qhat
	sta	bp|answerp,*x2
	ldx3	bp|j
	eax3	-1,x3
	stx3	bp|j
	eax2	-1,x2
	stx2	bp|m
	tnz	get_qhat
	ldx0	bp|div_bb_ret
	tra	0,x0
div_bb_zero:
	eax6	1			"result is zero
	tsx0	alloc_bfx6
	sprilp	bp|answerp
	eax2	1
	sxl2	lp|0			"store vital statistics
	ldx2	bp|smallerp,*
	erx2	bp|biggerp,*
	stx2	lp|0
	stz	lp|1
	ldx0	bp|div_bb_ret		"return
	tra	0,x0
"
"
div_bb_lsh:
	stx0	bp|div_bb_lsh_ret
	lxl6	lp|0
	sprilp	bp|div_bb_temp
	adx6	3,du
	tsx0	alloc_bfx6
	sprilp	bp|shiftp
	lxl2	bp|div_bb_temp,*
	stz	lp|0
	stz	lp|2,x2
	epplp	bp|div_bb_temp,*
	tsx0	lsh_bfx
	epplp	bp|shiftp,*
	ldx0	bp|div_bb_lsh_ret
	tra	0,x0
"
"
div_bs:					"this routine divides bfx bigger by divisor,
					"putting the quotient in result, and the
					"remainder is left in the q.
"
	lxl2	bp|biggerp,*		"load the offset of last (m.sig.) element
	sxl2	bp|resultp,*		"it is also the length of result
	lda	0,dl			"clear the remainder
div_bs_loop:
	ldq	bp|biggerp,*x2		"get next word to divide 
	qls	1			"dvf needs this shift
	dvf	bp|divisor		"do the divide of aq
	sta	bp|resultp,*x2		"store the quotient
	eax2	-1,x2			"go to next word
	tze	0,x0			"done - return
	llr	36			"move remainder to above next word
	tra	div_bs_loop		"get next word
"
"
div_by_zero:
	lda	<lisp_error_table_>|[division_by_zero]	"load error code
	tra	bad_error			"join error code
"
"
enter:					"this routine does the stuff for entry
"
	eax1	0,x7			"save where x7 was in x1
	eax7	auto_block_size,x7		"alloc the automatic variables
	eppbp	ab|0,x1			"get ptr to them in bp
	stx5	bp|num_of_args		"save x5 (number of args * -2)
	sti	bp|saved_indicators		"save the indicators
	stq	bp|function_name		"remember who we are for errors
	tra	0,x0			"return
"
"
exop_bfx:					"this routine does bfx adds and subtracts
					"lp should point to a structure in the
					"correct format.
"
	ldx2	0,du
	lda	0,du
exop_bfx_loop:
	eax2	1,x2			"get next set of words
	ldq	bp|biggerp,*x2		"get bigger one
	adlq	lp|1,al			"add carry into it (0,+1,-1)
	xec	lp|0			"do add or subtract
	lda	0,du			"clear a
	lls	1			"shift high bit into a
	qrl	1			"leave it there
	stq	bp|resultp,*x2		"store q as result
	cmpx2	bp|small_limit		"are we done this loop?
	tnz	exop_bfx_loop		"no - do next higher word
	tra	exop_bfx_check		"join ripple code at check point
exop_bfx_ripple:
	eax2	1,x2			"get next word
	ldq	bp|biggerp,*x2		"load into q
	adlq	lp|1,al			"add in carry factor
	lda	0,du			"move high bit into a
	lls	1
	qrl	1
	stq	bp|resultp,*x2		"store result
exop_bfx_check:
	cmpx2	bp|big_limit		"are we done?
	tnz	exop_bfx_ripple		"no
	eax2	1,x2			"get room for last carry
	sta	bp|resultp,*x2		"store it
	sxl2	bp|resultp,*		"store size
	tra	0,x0
"
"
float_error:
	sprilp	bp|temp			"put value in error in mkd pdl
	ldaq	bp|temp
	ora	Big_fixed,dl
	eppap	ap|2			"make room on mkd pdl
	staq	ap|-2			"put value there
	lda	<lisp_error_table_>|[unable_to_float]	"load error code
	tra	bad_error			"join error code
"
"
force_q_to_bfx:				"this routine converts the q to a bfx.
					"it assumes that it is invoked after an
					"overflow and uses the carry indicator
					"to know more about the result
					"it returns a ptr to the bfx in lp
"
	epplp	ab|0,x7			"load ptr to area to be alloced
	eax7	4,x7			"alloc the area
	trc	force_q_to_bfx_neg		"transfer if carry -> negative result
	lda	0,du			"move high order bit into a
	lls	1
	qrl	1
	stq	lp|1			"store result
	sta	lp|2
	ldq	2,dl			"set length and sign (pos)
	stq	lp|0
	tra	0,x0
force_q_to_bfx_neg:
	lda	=v36/-1			"its a large negative number
	negl	0			"get abs
	lls	1			"get second word
	qrl	1
	stq	lp|1			"store result
	sta	lp|2
	ldq	=v18/-1,18/2		"get length and sign (neg)
	stq	lp|0			"store it
	tra	0,x0
"
"
load_arg_bfx:				"this routine moves result and arg into big and small
"
	epplp	bp|resultp,*
	sprilp	bp|biggerp
	lxl2	lp|0
	stx2	bp|big_limit
	epplp	ap|0,x5*
	sprilp	bp|smallerp
	lxl2	lp|0
	stx2	bp|small_limit
	tra	0,x0
"
"
lsh_bfx:					"this routine shifts left bfx->lp shift_value places
					"and puts the answer in shiftp->bfx.  X2 says how many words.
"
	lxl3	bp|shift_value
	eppbp	bp|shiftp,*
	stz	bp|1,x2
lsh_bfx_loop:
	lda	0,dl
	ldq	lp|0,x2
	lls	1,x3
	qrl	1
	orsa	bp|1,x2
	stq	bp|0,x2
	eax2	-1,x2
	tnz	lsh_bfx_loop
	eppbp	ab|0,x1
	tra	0,x0
"
"
move_bfx:					"moves resulp->bfx to lp->bfx
					"called with tsx6, and clobbers x4, a, q
"
	eppbb	bp|resultp,*		"get pointer to bfx to be moved in bb
	ldq	bb|0			"get length
	qls	2			"convert to number of characters
	eax4	4,ql			"add allow for header. (assume not ridiculously huge)
	mlr	(pr,rl),(pr,rl)		"move the stuff
	desc9a	bb|0,x4
	desc9a	lp|0,x4
	tra	0,x6			"return
"
"
mpy_bfx:					"this routine multiplies bigger by smaller
"
	eax2	1			"load ptrs, 2 -> bigger (multiplicandd)
	eax3	1			"           3 -> smaller(multiplier)
	eax4	1			"           4 -> result (product)
	stz	bp|carry			"zero the carry
mpy_bfx_loop1:
	ldq	bp|biggerp,*x2		"load next word of multiplicand
	mpy	bp|smallerp,*x3		"do the multiply
	adl	bp|carry			"add the single word carry to the aq
	lls	1			"store the lower word
	qrl	1
	stq	bp|resultp,*x4
	eax4	1,x4			"go to next word of result
	sta	bp|carry			"store the new carry
	cmpx2	bp|big_limit		"are we done the first pass?
	tze	mpy_bfx_join		"yes
	eax2	1,x2			"no - get next word of bigger
	tra	mpy_bfx_loop1		"continue multiplying
mpy_bfx_loop2:
	ldq	bp|biggerp,*x2		"load next word of bigger
	mpy	bp|smallerp,*x3		"do mult
	adl	bp|carry			"add carry
	adl	bp|resultp,*x4		"add to result
	lls	1
	qrl	1
	stq	bp|resultp,*x4		"store low word
	eax4	1,x4			"now add high word to result
	sta	bp|carry			"store the new carry
	cmpx2	bp|big_limit		"are we done with multiplicand?
	tze	3,ic			"yes - check multiplier
	eax2	1,x2			"bump x2
	tra	mpy_bfx_loop2		"continue
mpy_bfx_join:
	lda	bp|carry			"store the carry in next word
	sta	bp|resultp,*x4
	eax4	1,x4			"bump x4 incase next x3 ->val is zero
	stz	bp|carry			"clear the carry
	eax2	1			"reset multiplicand ptr
	cmpx3	bp|small_limit		"are we done with multiplier?
	tze	mpy_bfx_done		"yes
	eax3	1,x3			"bump x3
	szn	bp|smallerp,*x3		"is multiplier zero?
	tze	mpy_bfx_join		"yes - skip the multiply
	eax4	0,x3			"product ptr starts where multiplier's is
	tra	mpy_bfx_loop2		"continue
mpy_bfx_done:
	eax4	-1,x4			"x4 is one too far
	sxl4	bp|resultp,*		"done - store length
	tra	0,x0			"return
"
"
mpy_bs:					"this routine multiplies bigger by sfx multiplier
"
	epplp	bp|biggerp,*		"get ptr to bfx
	lxl2	lp|0			"get length of bfx
	stx2	bp|big_limit		"store as loop terminater.
	eax2	0			"initialize counter
	stz	bp|carry			"clear carry
mpy_bs_loop:
	eax2	1,x2			"get next word
	ldq	lp|0,x2			"load next word
	mpy	bp|multiplier		"do the multiply
	adl	bp|carry			"add the carry
	lls	1			"get new carry
	qrl	1
	stq	bp|resultp,*x2		"store the result
	sta	bp|carry			"store the carry
	cmpx2	bp|big_limit		"are we done?
	tmi	mpy_bs_loop		"no
	eax2	1,x2			"get next result word
	sta	bp|resultp,*x2		"store the last carry
	sxl2	bp|resultp,*		"store the length
	tra	0,x0			"return
"
"
norm_a:					" normalizes A reg., returns number of significant
					" bits in Q.
	ldq	0,dl
	lde	=o106000,du		" 35.<-28.
	cmpa	0,dl			" get sign of arg
	tze	0,x0			" return if zero.
	tpl	norm_ge0			" if A < 0
	cmpa	=o400000,du		" check for bad case.
	tnz	3,ic			" and return 36
	ldq	36,dl			" in this case
	tra	0,x0
	sba	1,dl
norm_ge0:
	fad	=0.0,du			" normalize.
	ste	bp|temp			" get the exponent register
	ldq	bp|temp			" into the Q
	qrs	36-8			" shift it to correct place,
	tra	0,x0
"
"
numval:					"checks type of arg -> by x5, skipping:
					" 0 if sfx
					" 1 if sfl
					" 2 if bfx
					" 3 if bfl
					" error otherwise
					"
					"uses x2.
"
	lxl2	ap|0,x5			"load the type bits into x2
	canx2	Fixed,du			"check with all numeric types and skip
	tnz	0,x0
	canx2	Float,du
	tnz	1,x0
	canx2	Big_fixed,du
	tnz	2,x0
	tra	badarg			"ERROR
"
"
ret_to_pl1:				"this routine returns to a pl1 program -
					"it needs to have the lp set.
"
	spriap	<lisp_static_vars_>|[stack_ptr] "let pl1 prog know about stack changes
	stx7	<lisp_static_vars_>|[unmkd_ptr]+1
	stc1	ab|in_pl1_code		"indicate that we aren't in non-pl1
	short_return
"
"
return:					"this routine is the opposite of enter
					"returned values should be in aq
"
	ldi	bp|saved_indicators		"restore the indicators
	ldx5	bp|num_of_args		"restore x5 for the next instruction
	eppap	ap|0,x5			"pop the marked stack
	epplp	bp|old_lp,*		"restore the caller's lp
	eppbp	bp|return_point,*		"get ptr to return point
	eax7	-4,x1			"pop the unmarked stack
	tra	bp|0			"return
"
"
return_0:					"returns with a zero value
"
	lda	fixnum_type,dl		"put type bits in the a
	ldq	0,dl			"load a value of zero
	tra	return			"return
"
"
return_0.0:				"returns a floating zero
	lda	flonum_type,dl
	ldq	=0.0
	tra	return
"
"
return_1:
	lda	fixnum_type,dl
	ldq	1,dl
	tra	return
"
"
return_1.0:				"returns a floating one
	lda	flonum_type,dl
	ldq	=1.0
	tra	return
"
"
return_bfx:				"gets a place for result, then returns
"
	tsx0	call_alloc_bfx		"allocate the bfx
	ldaq	bp|resultp		"get ptr to it
	ora	Big_fixed,dl		"make bignum ptr
	tra	return			"do a return
"
"
return_minus1:				"returns a minus one
	lda	fixnum_type,dl		"load type bits
	lcq	1,dl			"load the value
	tra	return			"return
"
"
return_nil:				"returns the value nil
	ldaq	ab|nil
	tra	return
"
"
return_sfl:				"returns q as an sfl
	fst	bp|temp			"store EAQ in sfl
	ldq	bp|temp			"load as one number (one word)
	lda	flonum_type,dl		"load type bits
	tra	return
"
"
return_sfx:				"returns q as an sfx
	lda	fixnum_type,dl		"load type bits
	tra	return
"
"
return_true:				"returns the value t
	ldaq	ab|true
	tra	return
"
"
rsh_bfx:					"shifts lp->bfx right shift_value
					"places, in place.
"
	lxl3	bp|shift_value		"get value to shift
	lxl2	lp|0			"get length
	stx2	bp|big_limit		"save it
	cmpx2	1,du			"rsh_bfx (1)?
	tze	rsh_bfx_1
	eax2	1			"initialize x2, word counter
	ldq	lp|0,x2			"get first word
	qls	1			"move up to block sign
rsh_bfx_loop:
	lda	lp|1,x2			"get next word
	lrl	0,x3			"do the shift
	qrl	1			"make a sign bit
	stq	lp|0,x2			"store the result
	llr	37,x3			"move what's left to the q in position
	eax2	1,x2			"get next word
	cmpx2	bp|big_limit		"are we done?
	tmi	rsh_bfx_loop		"no
	qrl	1,x3			"store last word
	stq	lp|0,x2
	tra	0,x0			"return

rsh_bfx_1:ldq	lp|1
	qrl	0,x3
	stq	lp|1
	tra	0,x0
"
"
setup_mpy_bfx:				"this routine takes bigger and smaller and sets
					"the proper variables for a mpy_bfx -
					"including allocing the result and setting
					"sign.
"
	lxl2	bp|biggerp,*		"set limits
	stx2	bp|big_limit
	lxl2	bp|smallerp,*
	stx2	bp|small_limit
	epplp	ab|0,x7			"alloc correct size result
	sprilp	bp|resultp
	eax2	2,x7
	adx2	bp|big_limit
	adx2	bp|small_limit
	anx2	-2,du
	eax7	0,x2
	ldx2	bp|biggerp,*
	erx2	bp|smallerp,*
	stx2	bp|resultp,*
	tra	0,x0
"
"
switch_bfx:				"switches bigger and smaller
"
	ldaq	bp|biggerp		"switch the ptrs
	staq	bp|temp
	ldaq	bp|smallerp
	staq	bp|biggerp
	ldaq	bp|temp
	staq	bp|smallerp
	ldaq	bp|big_limit		"load big and small limits as a unit
					"this requires them to be 2 word aligned
	llr	36			"switch their positions
	staq	bp|big_limit		"store the switched values
	lda	-1,du			"indicate that a swich was performed
	ersa	bp|switched
	tra	0,x0			"return
"
"
switch_to_lisp:				"loads registers to make a lisp environment
"
	epbpab	<lisp_static_vars_>|[unmkd_ptr],*
	eppap	<lisp_static_vars_>|[stack_ptr],*
	ldx7	<lisp_static_vars_>|[unmkd_ptr]+1
	stz	ab|in_pl1_code
	tra	0,x0
"
"
truncate_bfx:				"this routine sets the length of result
					"to the smallest value possible, stripping
					"off leading zeroes.  It will skip on return
					"if the result could be an sfx.
"
	lxl2	bp|resultp,*		"get length
	eax2	1,x2			"start out one ahead
truncate_bfx_loop:
	eax2	-1,x2			"go back one word
	tze	truncate_bfx_small		"all zero -> small
	szn	bp|resultp,*x2		"see if word is zero
	tze	truncate_bfx_loop		"yes, look at word before it
	sxl2	bp|resultp,*		"store new length
	cmpx2	1,du			"are we now an sfx?
	tze	1,x0			"yes
	cmpx2	2,du			"now check for -400000000000
	tnz	0,x0
	szn	bp|resultp,*
	tpl	0,x0
	lda	bp|resultp,*x2
	eax2	-1,x2
	ldq	bp|resultp,*x2
	cmpaq	=v36/1,36/0
	tze	1,x0			"skip on return if could be sfx
	tra	0,x0
truncate_bfx_small:
	ldx2	1,du			"get length of one
	sxl2	bp|resultp,*		"store it
	tra	1,x0			"skip on return
"
"
plus:					"This is the plus lsubr
	lcq	-fn_plus,dl		"remember who we are (incase of error)
	eax4	add_opcode		"since this op is table driven, load the table
plus_start:
	tsx0	enter			"set up the automatic variables
	stx4	bp|op_table		"save what type of op we are
	eax5	0,x5			"are there any arguments?
	tze	return_0			"no - return a zero
	tsx0	numval			"branch on type of first arg
	tra	plus_sfx
	tra	plus_sfl
	tra	plus_bfx
"
plus_sfx:
	ldi	nooverflow,dl		"inhibit overflow
	ldaq	ap|0,x5			"load first arg and its type bits
plus_sfx_loop:
	eax5	2,x5			"get next arg
	tze	return			"no more - return what we have in the aq
	tsx0	numval			"branch on type
	tra	plus_sfx_add
	tra	plus_sfx_sfl
	tra	plus_sfx_make_big
"
plus_sfx_add:
	xec	2,x4			"do the operation - add or subtract
	tov	2,ic			"if overflow, then switch to bignum
	tra	plus_sfx_loop		"get next arg and add it
	tsx0	force_q_to_bfx		"get ptr to q in bfx form
	sprilp	bp|resultp		"store it in resultp
	tra	plus_bfx_loop		"join bfx code
plus_sfx_make_big:
	tsx0	convert_q_to_bfx		"change to bfx
	sprilp	bp|resultp
	tra	plus_bfx_add		"join bfx code
"
plus_sfx_sfl:
	tsx0	convert_q_to_sfl		"convert the sfx to sfl
	tra	plus_sfl_add		"and join the sfl code
"
plus_sfl:
	fld	ap|1,x5			"load first arg
plus_sfl_loop:
	eax5	2,x5			"get next arg
	tze	return_sfl		"no more - return
	tsx0	numval			"branch on arg type
	tra	plus_sfl_sfx
	tra	plus_sfl_add
	tra	plus_sfl_bfx
plus_sfl_add:
	xec	6,x4			"do add or subtract
	tra	plus_sfl_loop		"get next arg
plus_sfl_sfx:
	fst	bp|temp			"save what we have
	ldq	ap|1,x5			"convert arg to sfl
	tsx0	convert_q_to_sfl
	xed	4,x4			"do operation, with optional negate
	tra	plus_sfl_loop
plus_sfl_bfx:
	fst	bp|temp			"save q
	epplp	ap|0,x5*			"get ptr to bfx
	tsx6	convert_bfx_to_sfl		"do convert
	tra	float_error		"no skip means a conversion error
	xed	4,x4			"do operation
	tra	plus_sfl_loop		"get next arg
"
plus_bfx:
	ldaq	ap|0,x5			"move ptr to 1st arg to resultp
	staq	bp|resultp
plus_bfx_loop:
	eax5	2,x5			"get next arg
	tze	return_bfx		"no more - alloc result and return
	tsx0	numval			"branch on arg type
	tra	plus_bfx_make_big
	tra	plus_bfx_sfl
	tra	plus_bfx_add
plus_bfx_add:
	stz	bp|switched		"reset check for switching (subtract needs)
	tsx0	load_arg_bfx		"move result and arg into big and small
	tsx0	compare_bfx		"compare them
	tsx0	switch_bfx		"switch if b<s
	nop	0
plus_bfx_common:
	epplp	ab|0,x7			"get ptr to area to be alloced for result
	sprilp	bp|resultp
	eax2	3,x7			"get EVEN(x7 + 3 + big_limit)
	adx2	bp|big_limit
	anx2	-2,du
	eax7	0,x2
	ldx2	bp|biggerp,*		"are signs different?
	erx2	bp|smallerp,*
	adx2	bp|op_table		"pick up what to do based on that
	epplp	1,x2*
	tsx0	exop_bfx			"do the operation
	ldx2	bp|biggerp,*		"load sign of bigger
	xec	3,x4			"change if need be
	stx2	bp|resultp,*		"store as sign of result - converting
					"to sfx takes care of minus zero
	tsx0	truncate_bfx		"can the result be truncated?
	tra	plus_bfx_loop		"get next arg
	tsx0	convert_bfx_to_sfx		"trunc skipped, so make an sfx
	tra	plus_sfx_loop		"join sfx code
plus_bfx_make_big:
	ldq	ap|1,x5			"load value from arg
	tsx0	convert_q_to_bfx		"convert to bfx
	sprilp	bp|smallerp		"store ptr to it in smaller
	ldx2	2,du
	stx2	bp|small_limit
	epplp	bp|resultp,*		"move result to bigger
	sprilp	bp|biggerp
	lxl2	lp|0
	stx2	bp|big_limit
	stz	bp|switched		"reset switching switch
	tra	plus_bfx_common		"join other code
plus_bfx_sfl:
	epplp	bp|resultp,*		"convert result to sfl
	tsx6	convert_bfx_to_sfl
	tra	float_error		"no skip=> overflow
	tra	plus_sfl_add		"join sfl code
"
"
difference:
	lcq	-fn_difference,dl		"remember who we are
	eax4	sub_opcode		"indicate that we are subtract
	tra	plus_start		"and then join the plus code
"
"
	even
add_opcode:
	arg	sub_structure
	arg	add_structure
	adq	ap|1,x5
	nop	0,du
	fad	bp|temp
	nop 	0,dl
	fad	ap|1,x5
	adq	1,dl
"
	even
sub_opcode:
	arg	add_structure
	arg	sub_structure
	sbq	ap|1,x5
	erx2	bp|switched
	fsb	bp|temp
	fneg	0
	fsb	ap|1,x5
	sbq	1,dl
add_structure:
	adlq	bp|smallerp,*x2
	dec	0
	dec	1
sub_structure:
	sblq	bp|smallerp,*x2
	dec	0
	dec	-1
"
"
times:
	lcq	-fn_times,dl		"remember who we are
	tsx0	enter			"set up the auto vars
	eax5	0,x5			"are there any args?
	tze	return_1			"no - return a one
	tsx0	numval			"branch on arg type
	tra	times_sfx
	tra	times_sfl
	tra	times_bfx
times_sfx:
	ldq	ap|1,x5			"load the first arg
times_sfx_loop:
	eax5	2,x5			"get next arg
	tze	return_sfx		"no more - done
	tsx0	numval			"branch on type of next arg
	tra	times_sfx_mpy
	tra	times_sfx_sfl
	tra	times_sfx_bfx
times_sfx_mpy:
	mpy	ap|1,x5			"do the multiply
	cmpaq	=v36/0,o36/400000000000	"check that the product is still sfx
	tpl	3,ic			"no
	cmpaq	=v36/-1,o36/400000000000
	tpl	times_sfx_loop		"ok - still sfx so continue
times_sfx_gets_big:
	tsx0	convert_aq_to_bfx		"convert result to bfx
	sprilp	bp|resultp		"store ptr to it
	tra	times_bfx_loop		"join bfx code
times_sfx_sfl:
	tsx0	convert_q_to_sfl		"convert to sfl and join them
	tra	times_sfl_mpy
times_sfx_bfx:
	epplp	ap|0,x5*			"set up for big times small
	sprilp	bp|biggerp		"move in ptr to bfx
	tra	times_bs_join		"small num is in q, so just join
"
times_sfl:
	fld	ap|1,x5			"load first arg
times_sfl_loop:
	eax5	2,x5			"get next arg
	tze	return_sfl
	tsx0	numval			"branch on arg type
	tra	times_sfl_sfx
	tra	times_sfl_mpy
	tra	times_sfl_bfx
times_sfl_mpy:
	fmp	ap|1,x5			"do the mpy
	tra	times_sfl_loop		"get next arg
times_sfl_sfx:
	fst	bp|temp			"save EAQ
	ldq	ap|1,x5			"get sfx to be made into sfl
	tsx0	convert_q_to_sfl
	fmp	bp|temp			"do the mpy
	tra	times_sfl_loop		"do again
times_sfl_bfx:
	fst	bp|temp			"save
	epplp	ap|0,x5*			"convert bfx arg to sfl
	tsx6	convert_bfx_to_sfl
	tra	float_error		"no skip - overflow
	fmp	bp|temp			"do the mpy
	tra	times_sfl_loop		"and get next arg
"
times_bfx:
	ldaq	ap|0,x5			"make first arg old result
	staq	bp|resultp
times_bfx_loop:
	eax5	2,x5			"get next arg
	tze	return_bfx		"no more - done
	tsx0	numval			"branch on type of next arg
	tra	times_bfx_sfx
	tra	times_bfx_sfl
	tra	times_bfx_mpy
times_bfx_mpy:
	tsx0	load_arg_bfx		"load result and arg into big and small
times_bfx_common:
	epplp	ab|0,x7			"get ptr to result (to be allocated)
	sprilp	bp|resultp		"store in resultp
	eax2	2,x7			"calc EVEN(x7 + big_limit + small_limit + 2)
	adx2	bp|big_limit
	adx2	bp|small_limit
	anx2	-2,du
	eax7	0,x2			"alloc the appropriate number of words
	ldx2	bp|biggerp,*		"calc sign of result
	erx2	bp|smallerp,*
	stx2	bp|resultp,*		"store it
	tsx0	mpy_bfx			"do the multiply
	tsx0	truncate_bfx		"truncate it
	tra	times_bfx_loop		"get next arg
	tsx0	convert_bfx_to_sfx		"truncate skipped => make small
	tra	times_sfx_loop		"join sfx code
times_bfx_sfx:
	ldaq	bp|resultp		"move in bignum
	staq	bp|biggerp
	ldq	ap|1,x5			"get small num
times_bs_join:
	ldx2	bp|biggerp,*		"get sign of bfx
	lls	36			"xor with sign of sfx (put in a)
	tpl	times_bs_pos		"sfx positive=> don't negate value and bfx sign
	cmpa	=o400000000000		"see if we can't negate it
	tze	times_bs_make_bb		"can't negate - go to bfx times bfx
	neg 	0			"negate the number - need abs
	erx2	-1,du			"change sign of result
times_bs_pos:
	sta	bp|multiplier		"save abs of sfx as multiplier
	lxl6	bp|biggerp,*		"get length of bfx
	eax6	1,x6			"add one for length of sfx = len result
	tsx0	alloc_bfx6		"alloc the result
	sprilp	bp|resultp		"save ptr to it
	stx2	lp|0			"save the sign
	tsx0	mpy_bs			"do the multiply
	tsx0	truncate_bfx		"try to make smaller
	tra	times_bfx_loop		"get next arg
	tsx0	convert_bfx_to_sfx		"skip => make small
	tra	times_sfx_loop
times_bs_make_bb:
	lrs	36			"put in q
	tsx0	convert_q_to_bfx		"change the sfx to a bfx
	sprilp	bp|smallerp		"setup for bfx times bfx
	lxl2	lp|0
	stx2	bp|small_limit
	lxl2	bp|biggerp,*
	stx2	bp|big_limit
	tra	times_bfx_common		"join bfx bfx code
"
times_bfx_sfl:
	epplp	bp|resultp,*		"get ptr to result to convert
	tsx6	convert_bfx_to_sfl
	tra	float_error		"error in conversion
	tra	times_sfl_mpy		"no error - join sfl code
"
"
quotient:
	lcq	-fn_quotient,dl		"remember who we are
	tsx0	enter			"set up the auto vars, etc.
	eax5	0,x5			"any args?
	tze	return_1			"no - return the identity - 1
	tsx0	numval			"branch on arg type
	tra	quot_sfx
	tra	quot_sfl
	tra	quot_bfx
"
quot_sfx:
	ldq	ap|1,x5			"pick up first arg
quot_sfx_loop:
	eax5	2,x5			"get next arg (in sfx mode)
	tze	return_sfx		"no more - done
	tsx0	numval			"branch on arg type
	tra	quot_sfx_div
	tra	quot_sfx_sfl
	tra	quot_sfx_bfx
quot_sfx_div:
	cmpq	=o400000000000		"check that won't overflow
	tnz	4,ic
	lda	=-1			"-4000000.../-1 will do that
	cmpa	ap|1,x5
	tze	quot_sfx_make_big		"go to bfx mode
	div	ap|1,x5			"do the divide
	tra	quot_sfx_loop		"get next arg
quot_sfx_make_big:
	tsx0	convert_q_to_bfx		"do the conversion
	sprilp	bp|resultp
	tra	quot_bs			"join the other code
quot_sfx_bfx:
	cmpq	=o400000000000		"are we -400.../400...?
	tnz	quot_sfx_zero		"no
	epplp	ap|0,x5*
	lda	lp|0
	ldq	lp|1
	cmpaq	=v18/0,18/2,36/0
	tnz	quot_sfx_zero
	lda	lp|2
	cmpa	1,dl
	tnz	quot_sfx_zero
	ldq	=-1
	tra	quot_sfx_loop
quot_sfx_zero:
	ldq	0,dl
	tra	quot_sfx_loop		"get next
quot_sfx_sfl:
	tsx0	convert_q_to_sfl		"change to sfl mode
	tra	quot_sfl_div
"
quot_sfl:
	fld	ap|1,x5			"load first arg
quot_sfl_loop:
	eax5	2,x5			"get next arg
	tze	return_sfl		"no more - return
	tsx0	numval			"what type is arg?
	tra	quot_sfl_sfx
	tra	quot_sfl_div
	tra	quot_sfl_bfx
quot_sfl_div:
	fdv	ap|1,x5			"do the divide
	tra	quot_sfl_loop		"get next arg
quot_sfl_sfx:
	fst	bp|temp			"save the EAQ
	ldq	ap|1,x5			"load the sfx and convert
	tsx0	convert_q_to_sfl
	fdi	bp|temp			"do the divide
	tra	quot_sfl_loop		"get next arg
quot_sfl_bfx:
	fst	bp|temp			"save
	epplp	ap|0,x5*			"get ptr to arg
	tsx6	convert_bfx_to_sfl		"and convert it to sfl
	tra	quot_sfl_bfx_overflow	"overflow
	fdi	bp|temp			"do the divide
	tra	quot_sfl_loop		"and get the next arg

quot_sfl_bfx_overflow:
	epplb	ab|system_lp,*
	link	zunderflow,<lisp_static_vars_>|[zunderflow],*	zunderflow=t?
	ldaq	lb|zunderflow,*
	cmpaq	ab|nil
	tze	float_error		no, error.
	fld	=0.0,du			yes, return 0.0
	tra	return_sfl
"
quot_bfx:
	ldaq	ap|0,x5			"make first arg old result
	staq	bp|resultp
quot_bfx_loop:
	eax5	2,x5			"get next arg
	tze	return_bfx		"no more - return
	tsx0	numval			"branch on type
	tra	quot_bs
	tra	quot_bfx_sfl
	tra	quot_bb
quot_bs:
	ldaq	bp|resultp		"divide bfx by sfx, move result to bigger
	staq	bp|biggerp
	ldx2	bp|biggerp,*		"load sign of dividend
	lda	ap|1,x5			"load divisor value
	tpl	quot_bs_join		"don't do anything if non-negative
	cmpa	=o400000000000		"see if can't take negative
	tze	quot_bs_make_bb
	neg	0			"get abs value
	erx2	-1,du			"get sign of result
quot_bs_join:
	sta	bp|divisor		"store divisor
	epplp	ab|0,x7			"get ptr to result (to be alloced)
	sprilp	bp|resultp		"store in resultp
	stx2	bp|resultp,*		"store sign
	lxl2	bp|biggerp,*		"get length of dividend
	adx2	2,du			"add one for header, and 1 to round
	anx2	-2,du			"round down to even
	stx2	bp|temp
	adx7	bp|temp			"bump x7
	tsx0	div_bs			"do the divide
	tsx0	truncate_bfx		"try to truncate
	tra	quot_bfx_loop		"get next arg
	tsx0	convert_bfx_to_sfx		"skipped, so convert to sfx
	tra	quot_sfx_loop
quot_bs_make_bb:
	lrs	36			"move into q
	tsx0	convert_q_to_bfx		"do conversion
	sprilp	bp|smallerp
	tra	quot_bb_div		"join bfx code
quot_bfx_sfl:
	epplp	bp|resultp,*		"get ptr to bfx so far
	tsx6	convert_bfx_to_sfl		"convert it
	tra	float_error		"error
	tra	quot_sfl_div		"join other code
quot_bb:
	tsx0	load_arg_bfx
quot_bb_div:
	tsx0	div_bb
	ldaq	bp|answerp
	staq	bp|resultp
	tsx0	truncate_bfx
	tra	quot_bfx_loop
	tsx0	convert_bfx_to_sfx
	tra	quot_sfx_loop
"
"
	entry	bnprint
bnprint:
	tsx0	switch_to_lisp		"setup lisp environment
	tsx0	enter			"get auto vars
	ldaq	ap|-2			"get ptr to bignum to be broken up
	staq	bp|biggerp		"store it where it can be used
"
	lda	bp|bn_pl1_radix		"load radix
	sta	bp|divisor		"store where it will be needed
	lxl6	bp|biggerp,*		"alloc result - about twice bigger in size
	stx6	bp|temp
	adx6	bp|temp
	tsx0	alloc_bfx6
	sprilp	bp|resultp
	stz	lp|0			"make sign positive
	epplp	ab|0,x7			"get ptr to array of results
	sprilp	bp|bn_pl1_ptr
	eax7	2,x7			"bump x7
	eax3	0			"x3 is index into this array
bnprint_loop:
	tsx0	div_bs			"do the divide
	stq	bp|bn_pl1_ptr,*x3		"store the remainder
	eax3	1,x3			"bump the pointer
	canx3	1,du			"check if time to bumb x7
	tnz	2,ic
	eax7	2,x7			"bump it
	tsx0	truncate_bfx		"truncate result
	tra	bnprint_still_big		"still bignum
	eax2	1			"could be small, so are we done?
	lda	bp|resultp,*x2		"done if quotient is < radix
	cmpa	bp|bn_pl1_radix		"do the compare
	tmi	bnprint_done		"if radix>quot, then done
bnprint_still_big:
	ldaq	bp|resultp		"move result into bigger
	staq	bp|biggerp
	tra	bnprint_loop		"do again
bnprint_done:
	tsx0	convert_bfx_to_sfx		"get last word
	stq	bp|bn_pl1_ptr,*x3		"store it
	eax3	1,x3			"make x3 be length
	stz	bp|bn_pl1_length		"clear high bits
	sxl3	bp|bn_pl1_length		"store array length
	eppap	ap|-2			"clear arg
	epplp	ab|system_lp,*		"load lp
	tra	ret_to_pl1		"return
"
"
fix:
	lcq	-fn_fix,dl
	eax5	-2			"indicate that we have one arg
	tsx0	enter			"set up auto vars
	tsx0	numval			"check type of arg
	tra	fix_sfx
	tra	fix_sfl
	tra	fix_bfx
fix_sfx:
	ldaq	ap|-2			"just a straight copy
	tra	return
fix_sfl:
	fld	ap|-1			"load the value
	tmi	fix_sfl_neg		"test sign
	fcmp	=1.0			"see if it is greater than 1
	tmi	return_0			"smaller => 0
	tze	return_1			"equal => 1
	fcmp	=1.0e10			"are we sure that it can be sfx
	tmi	3,ic			"yes
	eax4	0			"load sign (0 => +)
	tra	fix_sfl_bfx		"go do bfx conversion
	ufa	=71b25,du			"convert to sfx
	tra	return_sfx
fix_sfl_neg:
	fcmg	=1.0			"see if fraction
	tze	return_minus1		"equal -1
	tmi	return_0			"is fraction
	fcmg	=1.0e10			"can it be an sfx?
	tmi	4,ic			"yes
	eax4	-1			"no, so set sign, and go to bfx
	fneg	0
	tra	fix_sfl_bfx
	ufa	=71b25,du			"do the conversion to sfx
	tra	return_sfx		"and return
fix_sfl_bfx:
	fst	bp|temp+1			"save the floating value
	eax6	5			"alloc bfx of 5 words
	tsx0	alloc_bfx6
	sprilp	bp|resultp
	ldaq	=v36/0,36/0		"load a zero
	staq	lp|0			"zero out bfx
	staq	lp|2
	staq	lp|4
	lda	bp|temp+1			"load sfl as word, to get exp
	lrl	64			"put exp as value in q
	div	35,dl			"find how many words result will be
	eax2	0,ql			"put value in x2
	neg	0			"negate remainder
	eax3	35,al			"add to 35
	fld	bp|temp+1			"load number
	lrl	0,x3			"do the shift
	qrl	1
	sta	lp|1,x2			"store the result
	stq	lp|0,x2
	eax2	1,x2			"get bfx length
	sxl2	lp|0			"store it in bfx
	stx4	lp|0			"store sign
	tsx0	truncate_bfx		"can we be an sfx?
	tra	return_bfx		"no - return
	tsx0	convert_bfx_to_sfx		"convert
	tra	return_sfx		"return
fix_bfx:
	ldaq	ap|-2			"just return bfx given
	staq	bp|resultp
	tra	return_bfx
"
"
float:
	lcq	-fn_float,dl
	eax5	-2			"indicate that we take one arg
	tsx0	enter			"setup the bignums environment
	tsx0	numval			"branch on type
	tra	float_sfx
	tra	float_sfl
	tra	float_bfx
float_sfx:
	ldq	ap|-1			"get arg
	tsx0	convert_q_to_sfl		"do the conversion
	tra	return_sfl
float_sfl:
	ldaq	ap|-2			"just return the arg
	tra	return
float_bfx:
	epplp	ap|-2,*			"get ptr to value
	tsx6	convert_bfx_to_sfl		"do the conversion
	tra	float_error		"overflow
	tra	return_sfl		"do the return
"
"
	entry	bnread
bnread:
	tsx0	switch_to_lisp		"get lisp environment
	tsx0	enter			"get this set of routine's environment
	ldx6	bp|bn_pl1_length		"alloc bfx at least as big as array length
	stx6	bp|small_limit		"save for loop test
	tsx0	alloc_bfx6
	sprilp	bp|resultp		"store ptr in resultp
	ldq	bp|bn_pl1_ptr,*		"load first word
	tsx0	convert_q_to_bfx		"make it a bfx for rest of routine
	sprilp	bp|biggerp
	eax3	1			"init counter
bnread_loop:
	lda	bp|bn_pl1_radix		"load radix
	sta	bp|multiplier		"store as multiplier
	tsx0	mpy_bs			"mult times the accumulated result
	epplp	bp|resultp,*		"move result to bigger
	sprilp	bp|biggerp
	lda	bp|bn_pl1_ptr,*x3		"load next number to be added
	sta	bp|addend			"it is put in addend
	tsx0	add_bs			"do the add
	tsx0	truncate_bfx		"truncate result for neatness
	nop	0			"don't care if can be sfx
	epplp	bp|resultp,*		"move
	sprilp	bp|biggerp
	eax3	1,x3			"get next word
	cmpx3	bp|small_limit		"are we done?
	tnz	bnread_loop		"no
	tsx0	call_alloc_bfx		"put result into lisp space
	eppap	ap|2			"get place on mrkd stack for result
	ldaq	bp|resultp		"put bignum ptr there
	ora	Big_fixed,dl
	staq	ap|-2
	epplp	ab|system_lp,*		"get ready to return
	tra	ret_to_pl1		"do it
"
"
add1:
	lcq	-fn_add1,dl
	eax4	add_opcode		"indicate that we will do adds
add1_enter:
	eax5	-2			"we are called with one arg
	tsx0	enter			"set up auto vars
	tsx0	numval			"check type of arg
	tra	add1_sfx
	tra	add1_sfl
	tra	add1_bfx
add1_sfx:
	ldi	nooverflow,dl		"mask overflows
	ldq	ap|-1			"load value
	xec	7,x4			"add or subtract one
	tov	2,ic			"check for overflow
	tra	return_sfx		"done
	tsx0	force_q_to_bfx		"change to bfx
	sprilp	bp|resultp
	tra	return_bfx		"done
add1_sfl:
	fld	=1.0			"get the one to add or subtract
	fst	bp|temp			"save it
	fld	ap|-1			"load value to be add/sub to
	xec	4,x4			"do the operation
	tra	return_sfl		"done
add1_bfx:
	stx4	bp|op_table		"we will use the code of plus_bfx
	epplp	ap|-2,*			"get bfx value setup like plus
	sprilp	bp|biggerp
	stz	bp|switched
	lxl2	bp|biggerp,*
	stx2	bp|big_limit
	epplp	bfx_one
	sprilp	bp|smallerp
	eax2	1
	stx2	bp|small_limit
	tra	plus_bfx_common
"
	even
bfx_one:
	vfd	18/0,18/1
	dec	1
"
"
sub1:
	lcq	-fn_sub1,dl
	eax4	sub_opcode
	tra	add1_enter
"
"
minus:
	lcq	-fn_minus,dl
	eax5	-2			"we have one arg
	tsx0	enter			"start
	tsx0	numval			"branch on type
	tra	minus_sfx
	tra	minus_sfl
	tra	minus_bfx
minus_sfx:
	lda	ap|-1			"load value
	lrs	36			"put into AQ
	negl	0			"do tbe minus
	cmpaq	=v36/0,o36/400000000000	"check that it hasn't become a bfx
	tnz	return_sfx
	tsx0	convert_aq_to_bfx		"it has - change
	sprilp	bp|resultp
	tra	return_bfx
minus_sfl:
	fld	ap|-1			"load the value
	fneg	0			"negate it
	tra	return_sfl
minus_bfx:
	ldaq	ap|-2			"copy bfx
	staq	bp|resultp
	tsx0	call_alloc_bfx
	eax2	-1			"negate it
	ersx2	bp|resultp,*
	tsx0	truncate_bfx		"check for -400000000000
	tra	minus_bfx_big
	tsx0	convert_bfx_to_sfx		"convert to sfx
	tra	return_sfx
minus_bfx_big:
	ldaq	bp|resultp		"setup return
	ora	Big_fixed,dl
	tra	return
"
"
abs:
	lcq	-fn_abs,dl
	eax5	-2			"we have one arg
	tsx0	enter			"get environment
	tsx0	numval			"branch on arg type
	tra	abs_sfx
	tra	abs_sfl
	tra	abs_bfx
abs_sfx:
	lda	ap|-1			"get arg
	lrs	36			"make 2 words
	tpl	return_sfx		"do abs operation
	negl	0
	cmpaq	=v36/0,o36/400000000000
	tnz	return_sfx
	tsx0	convert_aq_to_bfx
	sprilp	bp|resultp
	tra	return_bfx
abs_sfl:
	fld	ap|-1			"load value
	tpl	return_sfl		"do abs operation
	fneg	0
	tra	return_sfl
abs_bfx:
	szn	ap|-2,*			"check sign
	tmi	abs_bfx_minus		"branch if negative
	ldaq	ap|-2			"return argument as is
	tra	return
abs_bfx_minus:
	ldaq	ap|-2
	staq	bp|resultp		"copy and change sign
	tsx0	call_alloc_bfx
	eax2	0
	ansx2	bp|resultp,*
	ldaq	bp|resultp
	ora	Big_fixed,dl
	tra	return			"return
"
"
minusp:
	lcq	-fn_minusp,dl
	eax5	-2			"we have one arg
	tsx0	enter			"do entry sequence
	tsx0	numval			"branch to code suitable for arg type
	tra	minusp_sfx
	tra	minusp_sfl
	tra	minusp_bfx
minusp_sfx:
	szn	ap|-1			"test sign
	tmi	return_true		"return verdict
	tra	return_nil
minusp_sfl:
	fszn	ap|-1
	tmi	return_true
	tra	return_nil
minusp_bfx:
	szn	ap|-2,*
	tmi	return_true
	tra	return_nil
"
"
plusp:
	lcq	-fn_plusp,dl
	eax5	-2			"we have 2 args
	tsx0	enter			"enter
	tsx0	numval			"dispatch
	tra	plusp_sfx
	tra	plusp_sfl
	tra	plusp_bfx
plusp_sfx:
	szn	ap|-1
	tmi	return_nil		"tell verdict
	tze	return_nil
	tra	return_true
plusp_sfl:
	fszn	ap|-1
	tmi	return_nil
	tze	return_nil
	tra	return_true
plusp_bfx:
	szn	ap|-2,*
	tmi	return_nil
	tra	return_true		"can't have zero bfx
"
"
max:
	lcq	-fn_max,dl
	eax4	max_table			"set up max xec table
max_start:
	tsx0	enter			"set up environment
	tsx0	numval			"branch on arg type
	tra	max_sfx
	tra	max_sfl
	tra	max_bfx
max_sfx:
	ldaq	ap|0,x5			"load first arg
max_sfx_loop:
	eax5	2,x5			"get next arg
	xec	1,x4
	tsx0	numval			"branch on type of next arg
	tra	max_sfx_sfx
	tra	max_sfx_sfl
	tra	max_sfx_bfx
max_sfx_sfx:
	cmpq	ap|1,x5			"do the comparison
	xec	0,x4			"what to do is table driven
	ldq	ap|1,x5			"load other value
	tra	max_sfx_loop
max_sfx_sfl:
	tsx0	convert_q_to_sfl		"convert to sfl
	tra	max_sfl_sfl		"join that code
max_sfx_bfx:
	tsx0	convert_q_to_bfx		"go to bfx mode
	sprilp	bp|biggerp
	tra	max_bfx_bfx
max_sfl:
	fld	ap|1,x5			"load initial value
max_sfl_loop:
	eax5	2,x5			"get next arg
	xec	5,x4
	tsx0	numval			"branch on type
	tra	max_sfl_sfx
	tra	max_sfl_sfl
	tra	max_sfl_bfx
max_sfl_sfx:
	fst	bp|temp			"save old value
	ldq	ap|1,x5			"get sfx value to be made sfl
	tsx0	convert_q_to_sfl		"convert it
max_sfl_sfx_cmp:
	fcmp	bp|temp			"compare with old value
	xec	2,x4
	fld	bp|temp			"switch to old value
	xec	3,x4
max_sfl_sfl:
	fcmp	ap|1,x5			"do the compare
	xec	4,x4
	fld	ap|1,x5
	tra	max_sfl_loop
max_sfl_bfx:
	fst	bp|temp			"save old value
	epplp	ap|0,x5*			"try to convert new value to sfl
	tsx6	convert_bfx_to_sfl
	tra	float_error
	tra	max_sfl_sfx_cmp		"do the compare
max_bfx:
	ldaq	ap|0,x5			"get initial value
	staq	bp|biggerp
max_bfx_loop:
	ldaq	bp|biggerp
	staq	bp|resultp
	eax5	2,x5			"get next arg
	xec	9,x4
	tsx0	numval			"check type
	tra	max_bfx_sfx
	tra	max_bfx_sfl
	tra	max_bfx_bfx
max_bfx_sfx:
	ldq	ap|1,x5			"get value
	tsx0	convert_q_to_bfx		"make it big
	sprilp	bp|smallerp
	tra	max_bfx_bfx_cmp
max_bfx_sfl:
	epplp	bp|biggerp,*		"get value so far
	tsx6	convert_bfx_to_sfl		"convert to sfl
	tra	float_error
	tra	max_sfl_sfl		"join sfl code
max_bfx_bfx:
	ldaq	ap|0,x5			"get new value
	staq	bp|smallerp
max_bfx_bfx_cmp:
	tsx0	compare_signed_bfx
	xec	6,x4
	xec	7,x4
	xec	8,x4
max_bfx_bfx_switch:
	tsx0	switch_bfx		"change bigger and smaller
	tra	max_bfx_loop		"continue
"
max_table:
	tpl	max_sfx_loop		" 0
	tze	return_sfx		" 1
	tpl	max_sfl_loop		" 2
	tra	max_sfl_loop		" 3
	tpl	max_sfl_loop		" 4
	tze	return_sfl		" 5
	tra	max_bfx_bfx_switch		" 6
	tra	max_bfx_loop		" 7
	tra	max_bfx_loop		" 8
	tze	return_bfx		" 9
"
"
min:
	lcq	-fn_min,dl
	eax4	min_table
	tra	max_start			"set up and join max
"
min_table:
	tmi	max_sfx_loop		" 0
	tze	return_sfx		" 1
	tmi	max_sfl_loop		" 2
	tra	max_sfl_loop		" 3
	tmi	max_sfl_loop		" 4
	tze	return_sfl		" 5
	tra	max_bfx_loop		" 6
	tra	max_bfx_loop		" 7
	tra	max_bfx_bfx_switch		" 8
	tze	return_bfx		" 9
"
"
lessp:
	lcq	-fn_lessp,dl
	eax4	lessp_table
	tra	max_start
"
lessp_table:
	tpl	return_nil		" 0
	tze	return_true		" 1
	xed	lessp_table_2		" 2
	tra	return_nil		" 3
	tpl	return_nil		" 4
	tze	return_true		" 5
	tra	max_bfx_bfx_switch		" 6
	tra	return_nil		" 7
	tra	return_nil		" 8
	tze	return_true		" 9
	even
lessp_table_2:
	tze	return_nil
	tpl	max_sfl_loop
"
"
greaterp:
	lcq	-fn_greaterp,dl
	eax4	greaterp_table		"load table ptr and join max
	tra	max_start
"
greaterp_table:
	xed	greaterp_table_0		" 0
	tze	return_true		" 1
	tmi	max_sfl_loop		" 2
	tra	return_nil		" 3
	xed	greaterp_table_4		" 4
	tze	return_true		" 5
	tra	return_nil		" 6
	tra	return_nil		" 7
	tra	max_bfx_bfx_switch		" 8
	tze	return_true		" 9
	even
greaterp_table_0:
	tmi	return_nil
	tze	return_nil
greaterp_table_4:
	tmi	return_nil
	tze	return_nil
"
"
remainder:
	lcq	-fn_remainder,dl
	eax5	-4			"we have 2 args
	tsx0	enter			"set up environment
	tsx0	numval			"test type of first arg
	tra	rem_sfx
	tra	badarg
	tra	rem_bfx
rem_sfx:
	eax5	-2			"check second arg
	tsx0	numval
	tra	rem_sfx_sfx
	tra	badarg
	tra	rem_sfx_bfx
rem_sfx_sfx:
	ldq	ap|-3			"get first number
	cmpq	=o400000000000		"check for -400.../-1
	tnz	4,ic
	lda	=-1
	cmpa	ap|-1
	tze	rem_sfx_make_big		"need bfx arith.
	div	ap|-1			"do the division
	lrs	36			"get the remainder in proper place
	tra	return_sfx		"return
rem_sfx_make_big:
	tsx0	convert_q_to_bfx
	tra	rem_bfx_sfx_start		"join bfx code
rem_sfx_bfx:
	ldq	ap|-3			"check for -400.../400...
	cmpq	=o400000000000
	tnz	rem_sfx_bfx_rem
	epplp	ap|-2,*
	lda	lp|0
	ldq	lp|1
	cmpaq	=v18/0,18/2,36/0
	tnz	rem_sfx_bfx_rem
	lda	lp|2
	cmpa	1,dl
	tnz	rem_sfx_bfx_rem
	tra	return_0			"rem(-400.../400...) = 0
rem_sfx_bfx_rem:
	ldq	ap|-3			"the dividend is the remainder
	tra	return_sfx
rem_bfx:
	eax5	-2			"look at second arg
	tsx0	numval
	tra	rem_bfx_sfx
	tra	badarg
	tra	rem_bfx_bfx
rem_bfx_sfx:
	epplp	ap|-4,*			"get ptr to first arg
rem_bfx_sfx_start:
	sprilp	bp|biggerp		"store it
	lda	ap|-1			"get divisor
	tpl	rem_bfx_sfx_join		"get abs
	cmpa	=o400000000000		"is it too big?
	tze	rem_bfx_sfx_expand
	neg	0
rem_bfx_sfx_join:
	sta	bp|divisor		"store as divisor
	lxl6	lp|0			"quotient is of the size of the dividend
	tsx0	alloc_bfx6		"alloc the result
	sprilp	bp|resultp
	tsx0	div_bs			"do the division
	lda	0			"remainder is in q
	szn	bp|biggerp,*		"sgn(rem) = sgn(dividend)
	tpl	2,ic
	negl	0
	tra	return_sfx		"return
rem_bfx_sfx_expand:
	lrs	36			"put it in the q
	tsx0	convert_q_to_bfx		"convert to bfx
	tra	rem_bfx_bfx_start		"join bfx bfx code
rem_bfx_bfx:
	epplp	ap|-2,*			"get ptr to second arg
rem_bfx_bfx_start:
	sprilp	bp|smallerp		"store it
	epplp	ap|-4,*			"get ptr to first
	sprilp	bp|biggerp		"store it, too
	tsx0	div_bb			"do the divide
	ldx2	bp|n			"get length of divisor
	sxl2	bp|dividendp,*		"store as length of remainder
	ldx2	bp|biggerp,*		"get sign of dividend
	stx2	bp|dividendp,*		"it is sign of remainder
	epplp	bp|dividendp,*		"get ptr to it
	sprilp	bp|resultp		"store in result
	tsx0	rsh_bfx			"shift right to normalize result
	tsx0	truncate_bfx		"make as small as possible
	tra	return_bfx		"that's it
	tsx0	convert_bfx_to_sfx		"skip => can be sfx
	tra	return_sfx
"
"
expt:
	lcq	-fn_expt,dl
	eax5	-4			"we have two args
	tsx0	enter			"enter
	eax5 	-2			"look at second arg
	tsx0	numval
	tra	expt_x_sfx
	tra	expt_x_sfl
	tra	expt_x_bfx
expt_x_sfx:
	eax5	-4			"look at other arg
	tsx0	numval
	tra	expt_sfx_sfx
	tra	expt_sfl_sfx
	tra	expt_bfx_sfx
expt_sfx_sfx:
	szn	ap|-1			"to what are we raising it?
	tze	return_1			"x**0 is 1
	tmi	badarg			"only positive exponents allowed
	ldq	ap|-3			"get base
	tze	return_0			"zero to anything but zer o is zero
	cmpq	1,dl			"one to anything but zero is one
	tze	return_1
	cmpq	=-1			"minus one is almost as easy
	tnz	expt_sfx_sfx_nmo		"nmo => not minus one
	lda	ap|-1			"load power
	cana	1,dl			"test for even/odd
	tnz	2,ic			"transfer if odd (leaving -1 in q)
	ldq	1,dl
	tra	return_sfx
expt_sfx_sfx_nmo:
	lda	ap|-1			"load power
	cmpa	1,dl			"special cas e one
	tze	return_sfx
	sta	bp|n			"save exponent
	stq	bp|m			"save base as initial value to be squared
	ldq	1,dl			"initial result
	stq	bp|j			" j is the partial result
expt_sfx_sfx_loop:
	lda	bp|n			"get the exponent
	cana	1,dl			"is it odd?
	tze	expt_sfx_sfx_even
	ldq	bp|j
	mpy	bp|m			"multiply accumulated power * partial result
	tsx0	check_aq			"is it still small?
	tra	expt_sfx_sfx_big1		"no
	stq	bp|j			"store as new partial result
expt_sfx_sfx_even:
	lda	bp|n			"ge t the exponent
	ars	1			"get next bit
	tze	expt_sfx_sfx_done		"zero - done
	sta	bp|n			"save it
	ldq	bp|m			"get next power
	mpy	bp|m
	tsx0	check_aq
	tra	expt_sfx_sfx_big2
	stq	bp|m
	tra	expt_sfx_sfx_loop		"do next
expt_sfx_sfx_done:
	ldq	bp|j			"get result
	tra	return_sfx		"return
expt_sfx_sfx_big1:
	stx7	bp|initial_value		"need to remember where stack was
	tsx0	convert_aq_to_bfx		"change j and m to bfx and join bfx
	sprilp	bp|presultp
	ldq	bp|m
	tsx0	convert_q_to_bfx
	sprilp	bp|powerp
	tra	expt_bfx_sfx_even
expt_sfx_sfx_big2:
	stx7	bp|initial_value		"remember where stack was
	staq	bp|temp			"want j stored before m
	ldq	bp|j
	tsx0	convert_q_to_bfx
	sprilp	bp|presultp
	ldaq	bp|temp
	tsx0	convert_aq_to_bfx
	sprilp	bp|powerp
	tra	expt_bfx_sfx_loop
expt_sfl_sfx:
	lda	ap|-1			"to what are we raising it?
	tze	return_1.0		"x**0 is one, floating point
	sta	bp|n
	tpl	expt_sfl_sfx_plus		handle negative powers here
	neg	0
	sta	bp|n
	fld	=1.0,du			"get inverse of base
	fdv	ap|-3
	tra	2,ic			"and store as base
expt_sfl_sfx_plus:
	fld	ap|-3			"get base
	fst	bp|m			"save as multiplier
	fld	=1.0,du			"get initial partial result
	fst	bp|j			"save it
expt_sfl_sfx_loop:
	lda	bp|n			"is the current power value even?
	cana	1,dl
	tze	expt_sfl_sfx_even		"yes
	fld	bp|j			"odd => p. res. <- p. res. * multiplier
	fmp	bp|m
	fst	bp|j
expt_sfl_sfx_even:
	lda	bp|n			"get next bit of power
	ars	1
	tze	expt_sfl_sfx_done		"no more one bits => done
	sta	bp|n			"save power
	fld	bp|m			"square multiplier
	fmp	bp|m
	fst	bp|m
	tra	expt_sfl_sfx_loop		"do again
expt_sfl_sfx_done:
	fld	bp|j
	tra	return_sfl

expt_x_sfl:
	eax5	-4			"look at other arg
	tsx0	numval
	tra	expt_sfx_sfl
	tra	expt_sfl_sfl
	tra	badarg			"bignum to float power not supported

expt_sfx_sfl:
expt_sfl_sfl:		"hard cases - call PL/I support procedure

	ldi	bp|saved_indicators		flush ourselves
	ldx5	bp|num_of_args
	eppap	ap|4,x5			leave just our 2 args on stack
	eax7	0,x1			flush all but caller's lp and bp

	spriap	<lisp_static_vars_>|[stack_ptr]   now enter PL/I mode
	stx7	<lisp_static_vars_>|[unmkd_ptr]+1
	stc1	ab|in_pl1_code
	push
	eppap	<lisp_subr_tv_>|[..lisp..]
	spriap	sp|22
	eppap	null_arg_list
	short_call <lisp_trig_>|[expt_assistance]
	eppbp	sp|16,*			pop stack
	sprisp	sb|20
	eppsp	bp|0
	eppap	<lisp_static_vars_>|[stack_ptr],*
	epbpab	<lisp_static_vars_>|[unmkd_ptr],*
	ldx7	<lisp_static_vars_>|[unmkd_ptr]+1
	stz	ab|in_pl1_code

	ldaq	ap|-2
	eppap	ap|-2
	epplp	ab|old_lp,x7*
	eppbp	ab|return_point,x7*
	eax7	-4,x7
	tra	bp|0

	even
null_arg_list:
	oct	4,0

expt_bfx_sfx:
	szn	ap|-1			"to what are we raising it?
	tze	return_1			"x**0 is 1
	tmi	badarg			"only positive exponents allowed
	lda	ap|-1			"check if x**1
	cmpa	1,dl
	tnz	3,ic
	ldaq	ap|-4			"identity
	tra	return
	sta	bp|n			"save exponent
	stx7	bp|initial_value		"remember where umstk was
	ldq	1,dl			"initial partial result is one
	tsx0	convert_q_to_bfx
	sprilp	bp|presultp		"move base to power
	ldaq	ap|-4
	staq	bp|resultp
	lxl6	bp|resultp,*
	tsx0	alloc_bfx6
	sprilp	bp|powerp
	tsx6	move_bfx
expt_bfx_sfx_loop:
	lda	bp|n			"get exponent
	cana	1,dl			"was it odd or even?
	tze	expt_bfx_sfx_even		"no
	ldaq	bp|presultp		"presult <= presult * power
	staq	bp|smallerp
	ldaq	bp|powerp
	staq	bp|biggerp
	tsx0	setup_mpy_bfx
	tsx0	mpy_bfx
	tsx0	truncate_bfx
	nop	0,dl
	ldaq	bp|resultp
	staq	bp|presultp
expt_bfx_sfx_even:
	lda	bp|n			"get exponent
	ars	1			"get next bit
	tze	expt_bfx_sfx_done		"zero - done
	sta	bp|n			"save exponent
	ldaq	bp|powerp			"square power
	staq	bp|smallerp
	staq	bp|biggerp
	tsx0	setup_mpy_bfx
	tsx0	mpy_bfx
	tsx0	truncate_bfx
	nop	0,dl
	ldaq	bp|resultp
	staq	bp|powerp
	ldx2	bp|initial_value		"is presult at the lowest place in umstk?
	cmpx2	bp|presultp+1
	tze	expt_bfx_sfx_copy_p		"yes
	ldaq	bp|presultp		"move it to lowest place
	staq	bp|resultp
	epplp	ab|0,x2
	sprilp	bp|presultp
	tsx6	move_bfx
expt_bfx_sfx_copy_p:
	lxl2	bp|presultp,*		"how low can we move power?
	eax2	2,x2
	adx2	bp|initial_value
	anx2	-2,du
	epplp	ab|0,x2
	ldaq	bp|powerp
	staq	bp|resultp		"move it
	sprilp	bp|powerp
	tsx6	move_bfx
	lxl2	bp|powerp,*		"truncate stack
	eax2	2,x2
	anx2	-2,du
	adx2	bp|powerp+1
	eax7	0,x2
	tra	expt_bfx_sfx_loop
expt_bfx_sfx_done:
	ldaq	bp|presultp		"done - get result
	staq	bp|resultp
	tra	return_bfx		"done
expt_x_bfx:
	eax5	-4			"look at first arg
	tsx0	numval
	tra	expt_sfx_bfx
	tra	expt_sfl_bfx
	tra	badarg
expt_sfx_bfx:
	eax5	-2			"checking second arg's applicability to first - so err on 2nd
	ldq	ap|-3			"get the base
	tze	return_0			"0**x is zero (x bfx)
	cmpq	1,dl			"1**x is 1
	tze	return_1
	cmpq	=-1			"is it -1?
	tnz	badarg			"that's the last legal one
	eax2	1			"check for even odd
	lda	ap|-2,*x2
	cana	1,dl
	tze	return_1
	tra	return_sfx		"-1 left in q
expt_sfl_bfx:
	eax5	-2			"similar to sfx_bfx
	fld	ap|-3
	tze	return_0.0
	fcmp	=1.0,du
	tze	return_1.0
	fcmp	=-1.0,du
	tnz	badarg
	eax2	1
	lda	ap|-2,*x2
	cana	1,dl
	tze	return_1.0
	fld	=-1.0,du
	tra	return_sfl
"
"
haipart:	lcq	-fn_haipart,dl
	eax5	-4
	tsx0	enter
	eax5	-2
	tsx0	numval			" check second arg type.
	tra	haipart_ok
	tra	badarg
	tra	badarg

haipart_ok:
	eax5	-4
	tsx0	numval			" branck on first arg type.
	tra	haipart_sfx
	tra	badarg
	tra	haipart_bfx

haipart_sfx:
	lda	ap|1,x5			" get first argument into A
	tsx0	norm_a			" and get number of significant bits in it.
	lls	36			" move length to A,
	ldq	ap|1,x5			" and get argument 1.
	tpl	3,ic			" if negative, make positive
	erq	=-1			" avoiding fixedoverflow
	adlq	1,dl		" by negating with two instructions.
	cmg	ap|3,x5			" compare length to |arg 2|
	tze	simple_haipart_sfx		" if length <= |arg 2|
	tmi	simple_haipart_sfx

	szn	ap|3,x5			" get sign of second arg.
	tze	return_0			" if second arg 0, the result is 0.
	tmi	haipart_sfx_rem		" if negative, do remainder
	sba	ap|3,x5			" get power of 2 to divide by
	qrl	0,al			" shift down top part of word.
	tra	return_sfx

haipart_sfx_rem:
	lda	36,dl			" get amount to delete from front
	ada	ap|3,x5			" which is 36-number of bits wanted.
	qls	0,al
	qrl	0,al
	tra	return_sfx

simple_haipart_sfx:				" return absolute value, which is in q.
	cmpq	=o400000,du		" check for screw case, which is bignum.
	tnz	return_sfx		" otherwise return small number.
	epplp	ab|0,x7			" get space for bignum.
	eax7	4,x7			" on unmarked stack
	lda	2,dl			" 2 words long,
	sta	lp|0
	stz	lp|1			" a zero word, and
	lda	1,dl			" a one word
	sta	lp|2
	sprilp	bp|resultp		" set result
	tra	return_bfx		" and return bignum.


"
"
"
haipart_bfx:
	epplp	ap|0,x5*			" get pointer to first argument.
	lxl2	lp|0			" and length.
	lda	lp|0,x2			" get last word
	tsx0	norm_a			" count number of bits in it
	stq	bp|temp			" and save the count
	eaq	-1,x2			" get number of whole words in argument
	qrs	18
	mpy	35,dl			" get length in bits
	adq	bp|temp			" ...

	lls	36			" compare bit length
	cmg	ap|3,x5			" with secons argument.
	tmi	simple_haipart_bfx		" if second arg specifies more bits,
	tze	simple_haipart_bfx	" just do the right thing
	szn	ap|3,x5			" check whether to do remainder
	tze	return_0			" return zero if no bits asked for
	tpl	3,ic			" if remainder,
	lca	ap|3,x5			" get number of bits.
	tra	2,ic
	sba	ap|3,x5			" else subtract 2nd arg.

	lrl	36			" determine how many bits are to be divided off the right
	div	35,dl			" A contains number of bits,
					" Q contains number of whole words.

	szn	ap|3,x5			" check again whether to remainder
	tmi	haipart_bfx_rem

	sta	bp|shift_value
	qls	18
	stq	bp|temp			" savenumber of words to truncate from right.
	lxl6	lp|0			" compute length of result
	sbx6	bp|temp			" by subtracting off number of words truncated.
	stx6	bp|temp+1			" save size in words of result
	ldx3	bp|temp			" get offset for mlr below
	tsx0	alloc_bfx6		" allocate result on stack
	sprilp	bp|resultp		" and save location.
	ldx2	bp|temp+1			" set the length of the result.
	sxl2	lp|0			" note that the sign is zero.
	eppbb	ap|0,x5*			" bb -> place copied from.
	eppbb	bb|0,x3			" offset by number of words dropped
	eaq	0,x2			" qu := # words to copy (not header)
	qls	2			" convert # words to # characters
	mlr	(pr,rl),(pr,rl)
	desc9a	bb|1,qu
	desc9a	lp|1,qu
	tsx0	rsh_bfx			" shift bfx right by amount required.
	tsx0	truncate_bfx
	tra	return_bfx
	tsx0	convert_bfx_to_sfx	" truncate skipped, so make sfx
	tra	return


haipart_bfx_rem:				" remainder operation.
	sba	36,dl
	neg	0			" get amount to delete from high order word.
	sta	bp|shift_value
	eax6	1,ql			" allocate this many words.
	stx6	bp|temp+1
	tsx0	alloc_bfx6		" allocate the bfx on stack.
	sprilp	bp|resultp
	ldx2	bp|temp+1
	sxl2	lp|0			" set length of result.

	eppbb	ap|0,x5*			" get pointer to argument.
	eaq	0,x2			" compute length of stuff after header, in characters
	mpy	4,dl
	mlr	(pr,rl),(pr,rl)
	desc9a	bb|1,qu
	desc9a	lp|1,qu

	lda	lp|0,x2			" get high order word
	lxl3	bp|shift_value		" get amount to delete
	als	0,x3
	arl	0,x3
	sta	lp|0,x2			" put back word after deleteion.

	tsx0	truncate_bfx
	tra	return_bfx
	tsx0	convert_bfx_to_sfx
	tra	return

simple_haipart_bfx:
	ldaq	ap|0,x5			" get first arg.
	szn	lp|0			" check its sign,
	tpl	return			" return the arg as result.
	staq	bp|resultp		" set up to cpy to result
	tsx0	call_alloc_bfx
	eax2	0			" to set sign.
	stx2	bp|resultp,*
	ldaq	bp|resultp		" load the name of the result
	ora	Big_fixed,dl
	tra	return			" and return
"
"
"
"
"
gcd:
	lcq	-fn_gcd,dl		"load type code of gcd
	eax5	-4			"we are a subr with 2 args
	tsx0	enter			"set up environment
	tsx0	numval			"look at first arg
	tra	gcd_sfx
	tra	badarg
	tra	gcd_bfx
gcd_sfx:
	lda	ap|-3			"look at first arg
	tsx0	abs_sfx_a_to_q		"get abs of first arg
	tra	gcd_bfx_join		"if too big, join big code
	stq	bp|divisor		"save it
	eax5	-2			"check second arg
	tsx0	numval
	tra	gcd_ss
	tra	badarg
	tra	gcd_sb
gcd_ss:
	lda	ap|-1			"load second arg
	tsx0	abs_sfx_a_to_q		"get abs
	tra	gcd_sb_join		"too big
	szn	bp|divisor		"test for zero operands => return abs of other
	tze	return_sfx		"answer is in q already
	cmpq	0,dl			"test other one
	tnz	gcd_ss_loop
	ldq	bp|divisor
	tra	return_sfx
gcd_ss_loop:
	div	bp|divisor		"get remainder of (q) and divisor
gcd_ss_loop1:
	ldq	bp|divisor 		"replace (q) with other value
	sta	bp|divisor		"replace other with remainder
	cmpa	0,dl			"if remainder was zero, done, otherwise, loop
	tnz	gcd_ss_loop
	tra	return_sfx		"old other value (in q now) is result
gcd_sb:
	epplp	ap|-2,*			"get ptr to big arg
gcd_sb_join:
	sprilp	bp|biggerp		"save it
gcd_sb_do:
	szn	bp|divisor		"test smallnum for 0 (big can't be zero)
	tze	gcd_bs0
	lxl6	bp|biggerp,*		"alloc space for quotient, which we ignore
	tsx0	alloc_bfx6
	sprilp	bp|resultp
	tsx0	div_bs			"do a divide
	lls	36			"put in the a the remainder (now in q)
	tra	gcd_ss_loop1		"join other code
gcd_bfx:
	epplp	ap|-4,*			"get ptr to big num
gcd_bfx_join:
	sprilp	bp|biggerp		"store the ptr to big num
	eax5	-2			"look at second arg
	tsx0	numval
	tra	gcd_bs
	tra	badarg
	tra	gcd_bb
gcd_bs:
	lda	ap|-1			"get small num
	tsx0	abs_sfx_a_to_q
	tra	gcd_bb_join
	stq	bp|divisor		"save it
	tra	gcd_sb_do			"join other big/small code
gcd_bs0:
	epplp	bp|biggerp,*		"get copy of big arg, and abs of it
	sprilp	bp|resultp
	tsx0	call_alloc_bfx		"get copy into lisp space
	eax2	0			"set sign to plus
	stx2	bp|resultp,*
	ldaq	bp|resultp		"set up return
	ora	Big_fixed,dl
	tra	return
gcd_bb:
	epplp	ap|-2,*			"get ptr to second arg
gcd_bb_join:
	sprilp	bp|smallerp		"save it
	lxl2	lp|0			"make sure bigger is bigger
	stx2	bp|small_limit
	lxl2	bp|biggerp,*
	stx2	bp|big_limit
	tsx0	compare_bfx
	tsx0	switch_bfx
	nop	0,dl
	nop	0,dl
	ldx6	bp|big_limit		"put bigger of two in u, smaller in v
	tsx0	alloc_bfx6
	sprilp	bp|up
	ldaq	bp|biggerp
	staq	bp|resultp
	tsx6	move_bfx
	ldx6	bp|small_limit
	tsx0	alloc_bfx6
	sprilp	bp|vp
	ldaq	bp|smallerp
	staq	bp|resultp
	tsx6	move_bfx
	eax2	0			"set signs to zero - i.e. get abs
	stx2	bp|up,*
	stx2	bp|vp,*
	stx7	bp|initial_value		"save stack end - so we can truncate garbage
gcd_bb_l1:
	lda	bp|vp,*			"check that we don't have to go to gcd_bs
	cmpa	1,dl			"is length 1?
	tze	gcd_bb_to_bs
	cmpa	bp|up,*			"make sure lengths are same (sign is 0, so lda)
	tnz	gcd_bb_doremain		"if not equal, then make like Euclid
	ldq	bp|up,*al			"high order word is used for quicky calculation
	stq	bp|uh			"u hat
	ldq	bp|vp,*al
	stq	bp|vh			"v hat
	ldq	1,dl			"set A,D = 1
	stq	bp|A
	stq	bp|D
	stz	bp|B			"and B, C = 0
	stz	bp|C
gcd_bb_l2:
	ldq	bp|vh			"follow Lehmer's alg in Knuth
	adlq	bp|C
	tze	gcd_bb_l4
	stq	bp|temp
	ldq	bp|uh
	adlq	bp|A
	tmi	gcd_bb_l4			"overflow
	div	bp|temp
	stq	bp|q
	ldq	bp|vh
	adlq	bp|D
	tze	gcd_bb_l4
	tmi	gcd_bb_l4
	stq	bp|temp
	ldq	bp|uh
	adlq	bp|B
	div	bp|temp
	cmpq	bp|q
	tnz	gcd_bb_l4
gcd_bb_l3:
	mpy	bp|C
	negl	0
	adl	bp|A
	lda	bp|C
	sta	bp|A
	stq	bp|C
	ldq	bp|q
	mpy	bp|D
	negl	0
	adl	bp|B
	lda	bp|D
	sta	bp|B
	stq	bp|D
	ldq	bp|q
	mpy	bp|vh
	negl	0
	adl	bp|uh
	lda	bp|vh
	sta	bp|uh
	stq	bp|vh
	tra	gcd_bb_l2
gcd_bb_l4:
	szn	bp|B
	tze	gcd_bb_doremain
	epplp	bp|up,*			"calc Au, Bv, Cu, and Dv, then combine
	sprilp	bp|biggerp
	lxl6	lp|0
	eax6	1,x6
	tsx0	alloc_bfx6
	sprilp	bp|resultp
	sprilp	bp|ptemp1
	eax2	0
	lda	bp|A
	tpl	3,ic			"set sign of result
	neg	0
	eax2	-1
	stx2	lp|0
	sta	bp|multiplier
	tsx0	mpy_bs
	epplp	bp|vp,*
	sprilp	bp|biggerp
	lxl6	lp|0
	eax6	1,x6
	tsx0	alloc_bfx6
	sprilp	bp|resultp
	sprilp	bp|ptemp2
	eax2	0
	lda	bp|B
	tpl	3,ic
	neg	0
	eax2	-1
	stx2	lp|0
	sta	bp|multiplier
	tsx0	mpy_bs
	epplp	bp|up,*
	sprilp	bp|biggerp
	lxl6	lp|0
	eax6	1,x6
	tsx0	alloc_bfx6
	sprilp	bp|resultp
	sprilp	bp|ptemp3
	eax2	0
	lda	bp|C
	tpl	3,ic
	neg	0
	eax2	-1
	stx2	lp|0
	sta	bp|multiplier
	tsx0	mpy_bs
	epplp	bp|vp,*
	sprilp	bp|biggerp
	lxl6	lp|0
	eax6	1,x6
	tsx0	alloc_bfx6
	sprilp	bp|resultp
	sprilp	bp|ptemp4
	eax2	0
	lda	bp|D
	tpl	3,ic
	neg	0
	eax2	-1
	stx2	lp|0
	sta	bp|multiplier
	tsx0	mpy_bs
	ldaq	bp|ptemp1			"do the combining
	staq	bp|biggerp
	ldaq	bp|ptemp2
	staq	bp|smallerp
	ldaq	bp|up
	staq	bp|resultp
	tsx0	add_bb
	tsx0	truncate_bfx
	nop	0,dl
	ldaq	bp|ptemp3
	staq	bp|biggerp
	ldaq	bp|ptemp4
	staq	bp|smallerp
	ldaq	bp|vp
	staq	bp|resultp
	tsx0	add_bb
	tsx0	truncate_bfx
	nop	0,dl
	ldx7	bp|initial_value		"release all scratch space used above
	tra	gcd_bb_l1			"go around again
gcd_bb_doremain:
	ldaq	bp|up
	staq	bp|biggerp
	ldaq	bp|vp
	staq	bp|smallerp		"do normal remainder way
	tsx0	div_bb
	epplp	bp|vp,*
	sprilp	bp|resultp
	epplp	bp|up,*
	tsx6	move_bfx			"move v to u
	ldx2	bp|n			"normalize remainder, and put in v
	epplp	bp|dividendp,*
	stz	lp|0			"make positive
	sxl2	lp|0			"store size
	sprilp	bp|resultp
	tsx0	rsh_bfx
	tsx0	truncate_bfx
	nop	0,dl
	epplp	bp|vp,*
	tsx6	move_bfx
	ldx7	bp|initial_value		"clean up mess
	tra	gcd_bb_l1
gcd_bb_to_bs:
	epplp	bp|vp,*			"set up for bs
	sprilp	bp|resultp
	tsx0	convert_bfx_to_sfx		"make the smaller one an sfx
	stq	bp|divisor
	epplp	bp|up,*
	tra	gcd_sb_join
"
"
haulong:	lcq	-fn_haulong,dl		" function to count significant bits in a number.
	eax5	-2
	tsx0	enter			" set up.
	tsx0	numval			" check argument type.
	tra	haulong_sfx
	tra	badarg
	tra	haulong_bfx
haulong_sfx:				" single precision haulong.
	lda	ap|1,x5			" load argument.
	tsx0	norm_a			" normalize it
	tra	return_sfx		" return Q, which contains number of significant bits.

haulong_bfx:
	epplp	ap|0,x5*			" get pointer to bignum
	lxl2	lp|0			" get number words in bignum
	lda	lp|0,x2			" load the most significant word.
	tsx0	norm_a			" get number of significant bits in Q.
	stq	bp|temp			" and remember for later.
	eaq	-1,x2			" get number of words in bignum in Q.
	qrs	18
	mpy	35,dl			" 35 bits per word.
	adq	bp|temp
	tra	return_sfx
	end
	fld	ap|-3			"get base
	tze	return_0.0		"0**x is zero, floating point
	fcmp	=1.0,du			"special case 1**x, -1**x
	tze	return_1.0
	fcmp	=-1.0,du
	tnz	expt_sfl_sfx_nmo
	lda	ap|-1
	cana	1,dl			"test power for odd/even
	tze	return_1.0
	fld	=-1.0,du
	tra	return_sfl
expt_sfl_sfx_nmo:
