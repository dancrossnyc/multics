/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   * Copyright (c) 1972 by Massachusetts Institute of        *
   * Technology and Honeywell Information Systems, Inc.      *
   *                                                         *
   *********************************************************** */


/* Runtime system for Multics BASIC

   Initial Version: 12 November 1973 by BLW
	Modified: 20 January 1974 by BLW to use iox_
	Modified: 12 March 1974 by BLW to fix bug013 
	Modified: 17 March 1974 by BLW to fix bug015
	Modified: 28 March 1974 by BLW to fix bug022 
	Modified:  2 April 1974 by BLW to fix bug025 
	Modified: 22 April 1974 by BLW to fix bug026, bug027, bug028, and bug029
	Modified: 23 July 1974 by BLW to fix bugs 038 and 042
	Modified: 27 August 1974 by BLW to fix bug 047
	Modified: January 1976 by MBW to use iox_ more extensively
	Modified: May 1976 by MBW to add double precision capabilities
	Modified: 21 January 1977 by MBW to fix bug 064
	Modified:	18 February 1977 by MBW to fix bug 066
	Modified: 7 March 1977 by MBW to fix bug 067
	Modified: 6 July 1977 by MBW to fix bug 074
	Modified: 29 July 1977 by MBW to change file opening strategy
	Modified: 4 August 1977 by MBW to reset margins when changing file types
	Modified: 25 May 1978 by MBW to not reset tty margin automatically
	Modified: 29 December 1983 by MBW to fix switch(66) and to not try to close unused file
          Modified: 24 April 1984 by AH, 103: Fix the implied minus sign
                        in the PRINT USING statement.
	Modified: 15 May 1984 by DWL to document use of sst$ for mid$
	Modified: 22 May 1984 by DWL to add new switch 134 for left$
	Modified: 23 May 1984 by DWL to add new switch 135 for right$
	Modified: 28 May 1984 by DWL to fix ep error on switch 134 (201),
	          and switch 135 (202) for left$, right$
*/

basic_runtime_: proc(bo_stack_pt);

dcl	bo_stack_pt ptr;

dcl	(bo_pt,p1,p2,p3,p4,program_header_pt) ptr,
	ans char(28) varying,
	ch aligned char(1),
	c6 char(6),
	c8 char(8),
	c12 char(12),
	user_name char(22),
	c32 char(32),
	c64 char(64),
	dir char(168),
	ent char(32),
	(no_input,mat_input) bit(1),
	seg_no bit(18),
	(buff_size,old_buff_size) fixed bin(21),
	code fixed(35),
	bit_length fixed bin(5),
	file_lng fixed bin (34),
	(i,k,loc,m,n,tab_size) fixed bin;

dcl	ascii_size_op char (5) varying static;

dcl	sys_info$max_seg_size fixed bin ext;

dcl	vfx fixed bin(35),
	vbs bit(36) aligned based(addr(vfx));

dcl	double_vfx fixed bin(71),
	double_vbs bit(72) aligned based(addr(double_vfx));

dcl	entry_variable entry variable,
	1 ev		based(addr(entry_variable)),
	2 location	ptr,
	2 stack		ptr;

dcl (	max_string_size	init(4096),
	max_buffer_size	init(4096),
	default_buffer_size	init(128),
	area_header_size	init(24),
	bits_per_char	init(9)) fixed bin static;

dcl	based_vs char(4096) varying based;

dcl	1 varying		aligned based,
	2 len		fixed bin,
	2 chars		char(1);

dcl	1 change		aligned based,
	2 str(n)		bit(bit_length) unaligned;

dcl	float_bin(0:10) float bin based;

dcl	double_float_bin(0:10) float bin(63) based;

dcl	double_bit_word(0:10) bit(72) aligned based;

dcl	fix_bin(0:10) fixed bin based;

dcl	bit_word(0:10) bit(36) aligned based;


dcl	char_string char(n) based unaligned;

dcl	varying_char_string char(n) varying based;

dcl	header_numbers (2) char(1) unaligned static init("1", "2");

dcl	typ_name(5) char(8) varying int static
	init("any", "tty", "terminal", "numeric", "string");

dcl	per_name(7) char(8) varying int static
	init("input","linput","read","print","reset","scratch","write");

dcl	per_bits(7) bit(5) aligned int static
	init("01100"b,	/* input */
	     "01100"b,	/* linput */
	     "00011"b,	/* read */
	     "01100"b,	/* print */
	     "00111"b,	/* reset */
	     "00111"b,	/* scratch */
	     "00011"b);	/* write */

dcl	NL char(1) static init("
"),
	white_space char(2) static init(" 	"),	/* space, HT */
	amp_NL char(2) static init("&
"),
	comma_NL char(2) static init(",
");

dcl	(ioa_,ioa_$nnl,com_err_) entry options(variable),
	basic_file_name_ entry(char(168) aligned),
	timer_manager_$cpu_call entry(fixed bin(71),bit(2),entry),
	timer_manager_$reset_cpu_call entry(entry),
	hcs_$make_seg entry(char(*),char(*),char(*),fixed bin(5),ptr,fixed(35)),
	assign_round_ options(variable),
	area_ entry(fixed bin,ptr),
	user_info_ entry(char(*),char(*),char(*)),
	hcs_$delentry_file entry(char(*),char(*),fixed(35)),
	hcs_$del_dir_tree entry(char(*),char(*),fixed(35)),
	cu_$stack_frame_ptr entry returns(ptr),
	get_pdir_ entry(char(168)),
	expand_path_ entry(ptr,fixed bin,ptr,ptr,fixed(35)),
	hcs_$status_ entry(char(*),char(*),fixed bin,ptr,ptr,fixed(35)),
	iox_$open entry(ptr, fixed bin, bit(1) aligned, fixed bin(35)),
	iox_$control entry(ptr, char(*), ptr, fixed bin(35)),
	iox_$close entry(ptr, fixed bin(35)),
	iox_$detach_iocb entry( ptr, fixed bin(35)),
	iox_$position entry (ptr, fixed bin, fixed bin(21), fixed bin(35)),
	iox_$put_chars entry (ptr, ptr, fixed bin(21), fixed bin(35)),
	iox_$get_chars entry (ptr, ptr, fixed bin(21), fixed bin(21), fixed bin(35)),
	iox_$read_record entry (ptr, ptr, fixed bin(21), fixed bin(21), fixed bin(35)),
	iox_$write_record entry (ptr, ptr, fixed bin(21), fixed bin(35)),
	vfile_status_ entry (char(*), char(*), ptr, fixed bin(35)),
	convert_old_basic_file_ entry (char(*), char(*), fixed bin(35)),
	iox_$find_iocb entry(aligned char(*),ptr,fixed(35)),
	iox_$attach_iocb entry(ptr,char(*),fixed(35)),
	iox_$destroy_iocb entry(ptr,fixed(35));

dcl	iox_$user_output ptr ext,
	iox_$user_input ptr ext;

dcl (	error_table_$end_of_info,
	error_table_$fulldir,
	error_table_$no_operation,
	error_table_$not_done,
	error_table_$long_record,
	error_table_$noentry) fixed bin(35) ext static;

dcl	fast_related_data_$basic_area_p ptr ext;
dcl	fast_related_data_$in_fast_or_dfast bit(1) aligned ext;

dcl	buffer char(buffer_size) based(buffer_pt),
	1 buffer_pair	based(buffer_pt),
	2 buff1		char(old_buff_size),
	2 buff2		char(old_buff_size);

dcl	string_seg ptr;

dcl	(field_length,field_start,precision,scale,exp_length,digit_count,
	 digit_pos,field_pos) fixed bin;

dcl	1 print_using_bits unaligned,
	2 (left_just,right_just)	bit(1),
	2 have_dollar		bit(1),
	2 (have_plus,have_minus)	bit(1),
	2 have_exp		bit(1),
	2 have_decimal		bit(1);

dcl	pu_string char(pu_length) aligned based(print_using_pt);

dcl	fixed_dec_1 fixed dec(1),
	fixed_dec_1_overlay char(2) aligned based(addr(fixed_dec_1));

dcl	fixed_dec_2 fixed dec(2),
	fixed_dec_2_overlay char(3) aligned based(addr(fixed_dec_2));

dcl	(abs,addr,addrel,bit,convert,date,divide,fixed,hbound,oncode,baseno,reverse,string,ptr,
	 float,index,length,null,substr,verify,search,rel,unspec,time,max,min,mod,rtrim) builtin;

dcl	1 param_info_aligned	based,
	2 param_type(1)		bit(9) unaligned;

dcl	basic_error_messages_$ aligned ext,
	1 message_overlay	aligned based(addr(basic_error_messages_$)),
	2 index_block(0:500),
	  3 loc		fixed bin,
	  3 sev		fixed bin,
	  3 len		fixed bin,
	2 skip		unal char(k),
	2 message		unal char(index_block(error_number).len-1);

dcl	1 basic_string	aligned based,
	2 count		fixed bin,
	2 value		char(n) varying;

dcl	1 string_word	aligned based,
	2 offset		bit(18) unaligned,
	2 ignored		bit(18) unaligned;

dcl	1 arg_info	aligned based,
	2 string_word	bit(36),			/* string word used for local copy */
	2 type		fixed bin(17) unal,		/* 0 = fixed, 1 = varying */
	2 length		fixed bin(17) unal;		/* length of original string arg */

dcl	word fixed bin based aligned;

dcl	1 arglist		aligned based,
	2 arg_count	fixed bin(16) unaligned,
	2 skip		bit(54) unaligned,
	2 arg_ptr(10)	ptr;

dcl	string_area area(65536) based(string_segment);

dcl	info(20) fixed bin(35);		/* storage for vfile_status_ */

dcl	1 position_info aligned,
	2 next_position fixed bin(34),
	2 last_position fixed bin(34);

dcl	1 margin_info aligned,
	2 old_max_recl fixed bin(21),
	2 new_max_recl fixed bin(21);

dcl	string_buffer char(4096) aligned;

dcl	1 map(100)	aligned based,
	2 location	bit(18) unaligned,
	2 line		bit(18) unaligned;

dcl	have_conversion_label bit(36) aligned based(addr(conversion_label));

dcl	have_size_label bit(36) aligned based(addr(size_label));

	/* following block of words will be used as the fcb for tty.  it is
	   declared "big enough" instead of via like attribute so we
	   can make unqualified references to basic_fcb */

dcl	tty_fcb(32) fixed bin(71) static;

%include basic_operator_frame;
%include basic_fcb;

%include vfs_info;
%include basic_program_header;
%include basic_symbols;
%include basic_param_types;
%include iocb;
%include status_info_branch;

	bo_pt = bo_stack_pt;
	goto switch(q_reg + (precision_lng-1)*67);

	/* initialize */

switch(0):
switch(67):
	if fast_related_data_$basic_area_p = null
	then do;

	     /* first time in process */

	     call hcs_$make_seg("","basic_string_segment_","",01011b,string_seg,code);

	     if string_seg = null
	     then do;
		call com_err_(0,"basic","Could not make string segment");
		goto abort_label;
		end;

	     call area_(sys_info$max_seg_size + area_header_size,string_seg);

	     fast_related_data_$basic_area_p = string_seg;

	     fcb_pt = addr(tty_fcb);
	     owner = null;
	     margin = 75;
	     open_mode = Ascii_input_output;
	     end;

	string_segment = fast_related_data_$basic_area_p;
	string_value = "0"b;

	if fast_related_data_$in_fast_or_dfast then ascii_size_op = " -ssf";
	else ascii_size_op = " ";

	do i = 1 to 16;
	     fcb(i) = null;
	     end;

	fcb_pt = addr(tty_fcb);
	fcb(0) = fcb_pt;

	if owner = null then owner = bo_pt;

	buffer_pos = 0;
	buffer_pt = addr(file_name);
	buffer_size = length(file_name);

	file_type = tty_file;

	last_operation = 0;

	program_header_pt = program_header;

	if time_limit ^= 0.0e0
	then do;

	     /* Set up cpu timer to go off after specified time limit.  Since we may
	        have several basic programs active, we fill in the stack part of the
	        entry variable to indicate which program set up the timer;  this will
	        be used to turn off timer at end of execution. */

	     entry_variable = cpu_limit;
	     ev.stack = bo_pt;

	     call timer_manager_$cpu_call(time_limit * 1.0e6,"10"b,entry_variable);
	     end;

	return;

	/* cleanup */

switch(1):
switch(68):
	call tidy_up("1"b);
	return;

	/* print error message */

switch(2): switch(69):
	call print_error(error_number);
	return;

	/* numeric print */

switch(3): switch(70):
	call check_print;
	call numeric_print;
	return;

	/* string print */

switch(4): switch(71):
	call check_print;
	p1 = get_string_ptr(pr(1));
	call string_print;
	return;

	/* tab to next multiple of 15 */

switch(5): switch(72):
	call check_print;
	tab_size = max(15, number_length+8);
	call tab(divide(line_pos + tab_size,tab_size,17,0)*tab_size);
	return;

	/* end print */

switch(6): switch(73):
	call check_print;
	call force_buffer;
	return;

	/* print new line */

switch(7): switch(74):
	call check_print;
	call print_new_line;
	return;

	/* tab function */

switch(8): switch(75):
	call check_print;
	call tab(fixed(temp(1)));
	return;

	/* spc function */

switch(9): switch(76):
	call check_print;
	call tab(fixed(temp(1)) + line_pos);
	return;

	/* string assign, pr(1) is right side, pr(3) is left side */

switch(10): switch(77):
	call string_assign;
	pr(1) = addr(pr(3) -> string_word);
	return;

	/* string compare, pr(1) is left side, pr(3) is right side */

switch(11): switch(78):
	p1 = get_string_ptr(pr(1));
	p2 = get_string_ptr(pr(3));

	if p1 = p2
	then do;
	     temp(1) = 0;
	     return;
	     end;

	if p1 -> based_vs < p2 -> based_vs
	then temp(1) = -1;
	else if p1 -> based_vs = p2 -> based_vs
	     then temp(1) = 0;
	     else temp(1) = +1;

	return;

	/* concatenation, pr(1) is left side, pr(3) is right side */

switch(12): switch(79):
	p1 = get_string_ptr(pr(1));
	p2 = get_string_ptr(pr(3));

	n = length(p1 -> based_vs) + length(p2 -> based_vs);

	if n > max_string_size
	then do;
	     call print_error(104);
	     goto abort_label;
	     end;

	call allocate_string;

	p3 -> basic_string.value = p1 -> based_vs || p2 -> based_vs;

	call return_string;
	return;

	/* linput */

switch(13): switch(80):
	call check_input;
	call linput;
	call return_string;
	return;

	/* numeric input */

switch(14): switch(81):
	call check_input;
	mat_input = "0"b;

	call numeric_input;

	do while(no_input);
	     call get_input(-107);
	     call numeric_input;
	     end;

	return;

	/* string input */

switch(15): switch(82):
	call check_input;
	mat_input = "0"b;

	call string_input;

	do while(no_input);
	     call get_input(-107);
	     call string_input;
	     end;

	call return_string;
	return;

	/* end input */

switch(16): switch(83):
	call end_input;
	return;

	/* pos(a$,b$,n); pr(1) gives a$, pr(3) gives b$, n in temp(1) */

switch(17): switch(84):
	i = fixed(temp(1));

	if i <= 0
	then do;

return_0:	     temp(1) = 0;
	     return;
	     end;

	p1 = get_string_ptr(pr(1));

	if i > length(p1 -> based_vs) then goto return_0;

	p2 = get_string_ptr(pr(3));

	n = index(substr(p1 -> based_vs,i),p2 -> based_vs);

	if n = 0 then goto return_0;

	temp(1) = n + i - 1;
	return;

	/* chr$(n) */

switch(18): switch(85):
	unspec(ch) = bit(fixed(temp(1),9),9) & "001111111"b;

	n = 1;
	call allocate_string;
	p3 -> basic_string.value = ch;

	call return_string;
	return;

	/* clk$ */

switch(19): switch(86):
	c12 = time();

	c8 = substr(c12,1,2) || ":" || substr(c12,3,2) || ":" || substr(c12,5,2);

	call use_c8;
	return;

	/* dat$ */

switch(20): switch(87):
	c6 = date();

	c8 = substr(c6,3,2) || "/" || substr(c6,5,2) || "/" || substr(c6,1,2);
	call use_c8;
	return;

	/* usr$ */

switch(21): switch(88):
	call user_info_(user_name,c8,c8);

	n = index(user_name," ") - 1;
	if n < 0 then n = length(user_name);
	call allocate_string;
	p3 -> basic_string.value = substr(user_name,1,n);
	call return_string;
	return;

	/* str$(x) */

switch(22):
	call convert_number;

	n = length(ans);
	call allocate_string;
	p3 -> basic_string.value = ans;
	call return_string;
	return;

	/* seg$(a$,i,j) */

switch(23): switch(90):
	i = fixed(temp(1));
	n = fixed(temp(2)) - i + 1;
	goto sst;

	/* sst$(a$,i,n) and mid$(a$,i,n) */

switch(24): switch(91):
	i = fixed(temp(1));
	n = fixed(temp(2));

sst:	p1 = get_string_ptr(pr(1));

right_entry:
	if i < 1 then n = 0;

	n = max(min(n,length(p1 -> based_vs) - i + 1),0);

	call allocate_string;
	p3 -> basic_string.value = substr(p1 -> based_vs,i,n);
	call return_string;
	return;

	/* hps */

switch(25): switch(92):
	call get_file_number("01100"b);

	temp(1) = fcb(n) -> line_pos;
	return;

	/* tst(a$) */

switch(26):
	temp(1) = float(fixed(convert_string(),1),1);
	return;

	/* val(a$) */

switch(27):
	if convert_string() then return;

	call print_error(124);
	goto abort_label;

	/* deallocate string specified by pr(1) */

switch(28): switch(95):
	call deallocate_string(pr(1));
	return;

	/* file */

switch(29): switch(96):
	file_number = fixed(temp(1));

	if file_number = 0 then goto invalid_file_number;
	if file_number > 16 then goto invalid_file_number;

	fcb_pt = fcb(file_number);

	if fcb_pt ^= null then call close_file("0"b);	/* but save iocb */
	else do;
	     quits_disabled = "1"b;
	     allocate basic_fcb in(string_area);
	     quits_disabled = "0"b;

	     if had_quit then call signal_quit;

	     fcb(file_number) = fcb_pt;
	     seg_pt = null;			/* do not have iocb yet */
	     owner = bo_pt;
	     end;

	string(basic_fcb.bits) = "0"b;
	file_type = undefined_file;
	open_mode = Not_open;
	write_permission = "0"b;
	margin = -1;
	io_ops_since_margin = -1;
	buffer_pt = null;

	p1 = get_string_ptr(pr(1));

	if p1 -> based_vs = "*"
	then do;

	     /* Create unique name for segment in process directory */

	     call get_pdir_(dir);

	     n = index(dir," ");
	     if n = 0 then n = length(dir) + 1;

	     file_name = substr(dir,1,n-1) || ">" || unique();

	     temporary_file = "1"b;
	     write_permission = "1"b;
	     end;
	else do;
	     file_name = p1 -> based_vs;

	     call open_file;
	     end;

	last_operation = file_op;

	return;

	/* margin */

switch(30): switch(97):
	n = fixed(temp(1));
	if n < 0 then goto invalid_margin;
	if n > 4095 then goto invalid_margin;

	if file_type = numeric_file
	then do;			/* if empty, just set margin variable and hope that next
				   use will change file type */
	     call iox_$control (seg_pt, "read_position", addr(position_info), code);
	     if position_info.last_position > 0
	     then if n ^= 1 then goto invalid_margin;
	     end;
	else if file_type = string_file
	     then do;
		call check_random_string(String_update);  /* be sure it's open correctly */
		margin_info.new_max_recl = n;
		call iox_$control (seg_pt, "max_rec_len", addr(margin_info), code);
		if code =  error_table_$no_operation
		then if n ^= margin_info.old_max_recl
		     then go to invalid_margin;
		end;

	margin = n;
	io_ops_since_margin = -1;
	return;

	/* scratch */

switch(31): switch(98):
	if file_number = 0 then goto invalid_file_number;

	/* seg_pt = null should imply that file is nonexistent */

	if seg_pt = null then return;
	if file_type = undefined_file then return;

	if file_type = ascii_file then do;
	     call zap_file;			/* can't open for input_output if attached to record_stream */
	     call attach_ascii;
	     buffer_pos = buffer_length;
	     end;
	else do;
	     if open_mode < Ascii_input then do;	/* not open or open for input only */
		if file_type = numeric_file then call open_random (Numeric_input_output);
		else call open_random (String_update);
		end;
	     call iox_$position (seg_pt, -1, 0, code);
	     call iox_$control (seg_pt, "truncate", null, code);
	     end;

	last_operation = scratch_op;
	return;

	/* reset ascii */

switch(32): switch(99):
	if file_number = 0 then goto invalid_file_number;

	if (file_type ^= undefined_file) & (open_mode ^= Not_open)
	then do;
	     if open_mode = Ascii_output then return;	/* can't reset output only */
	     call check_ascii (Ascii_input);
	     call reset_ascii;
	     end;

	return;

	/* reset random */

switch(33): switch(100):
	n = fixed(temp(1));

	if file_type = tty_file then goto invalid_file_number;
	if file_type = undefined_file then do;
	     if n = 0 then return;		/* file will start at 0 when it's created */
	     else goto pointer_error;
	     end;
	if file_type = ascii_file then goto type_and_usage_conflict;

	if open_mode = Not_open then do;	/* must open first */
	     if file_type = numeric_file then i = Numeric_input;
	     else i = String_input;
	     call open_random (i);
	     end;

	if n < 0 then goto pointer_error;
	if file_type = numeric_file then buff_size = n*precision_lng*4;
	else if file_type = string_file then buff_size = n;
	call iox_$position  (seg_pt, 2, buff_size, code);
	if code ^= 0 then goto pointer_error;

	last_operation = reset_op;
	return;

	/* numeric write */

switch(34):
	call check_random_numeric (Numeric_input_output);
	call numeric_write;
	return;

	/* numeric read */

switch(35):
	call check_random_numeric (Numeric_input);
	call numeric_read;
	return;

	/* string write */

switch(36): switch(103):
	call check_random_string (String_update);
	p1 = get_string_ptr(pr(1));
	call string_write;
	return;

	/* string read */

switch(37): switch(104):
	call check_random_string (String_input);
	call string_read;
	call return_string;
	return;

	/* lof function */

switch(38): switch(105):
	call get_file_number("10011"b);

	if n = 0 then goto invalid_file_number;
	temp(1) = length_of_file (fcb(n) -> seg_pt);
	return;

	/* loc function */

switch(39): switch(106):
	call get_file_number("10011"b);

	if n = 0 then goto invalid_file_number;
	if (fcb(n) -> seg_pt = null)
	| (file_type = undefined_file)
	| (open_mode = Not_open)
	then do;
	     temp(1) = 0;
	     return;
	     end;

	call iox_$control (fcb(n)->seg_pt, "read_position", addr(position_info), code);
	if code ^= 0 then goto invalid_file_number;

	if fcb(n)->file_type = numeric_file
	then temp(1) = divide(position_info.next_position, (precision_lng*4), 21, 0);
	else temp(1) = position_info.next_position;

	return;

	/* mar function */

switch(40): switch(107):
	call get_file_number("11111"b);

	temp(1) = fcb(n) -> margin;
	return;

	/* check eof for file specified by temp(1)
	   result temp(1) = 0 => more, ^= 0 -> eof */

switch(41): switch(108):
	call get_file_number("11111"b);

	if n = 0 then temp(1) = 0;
	else do;
	     file_number = n;
	     fcb_pt = fcb(n);

	     if open_mode = Not_open 
	     then do;
		file_lng = length_of_file (seg_pt);
		if file_lng > 0 then temp(1) = 0;
		else temp(1) = 1;
		end;

	     else do;
		call iox_$control (seg_pt, "read_position", addr(position_info), code);
		if code ^= 0
		then temp(1) = 1;		/* assume unopen file is empty */
		else if position_info.next_position < position_info.last_position
		     then temp(1) = 0;
		     else do;
			temp(1) = 1;
			if file_type = ascii_file
			then if buffer_pos < buffer_length
			     then temp(1) = 0;
			end;
		end;
	     end;

	return;

	/* typ(n,str) where n in temp(1) and str given by pr(1) */

switch(42): switch(109):
	p1 = get_string_ptr(pr(1));

	do i = 1 to hbound(typ_name,1);
	     if p1 -> based_vs = typ_name(i) then goto typ_ok;
	     end;

	temp(1) = -1;
	return;

typ_ok:	n = fixed(temp(1));

	if n < 0 then goto invalid_file_number;
	if n > 16 then goto invalid_file_number;

	if fcb(n) = null then temp(1) = 0;
	else if i = 1 | (fcb(n) -> file_type = undefined_file & i ^= 2)
	     then temp(1) = 1;
	     else temp(1) = float(fixed(fcb(n) -> file_type = i,1),1);

	return;

	/* change from string given by pr(1) to array given by pr(2) */

switch(43):
	bit_length = fixed(temp(1));
	if bit_length <= 0 then goto change_error;
	if bit_length > 27 then goto change_error;

	p1 = get_string_ptr(pr(1));

	n = divide(length(p1 -> based_vs) * bits_per_char,bit_length,17,0);

	if n > pr(2) -> current_bounds(1) then goto change_error;

	p2 = pr(2) -> array_dope.data;
	p2 -> float_bin(0) = n;

	p1 = addr(p1 -> varying.chars);

	do i = 1 to n;
	     p2 -> float_bin(i) = float(fixed(p1 -> change.str(i),27),27);
	     end;

	return;

	/* change to string given by pr(1) from array given by pr(2) */

switch(44):
	bit_length = fixed(temp(1));
	if bit_length <= 0 then goto change_error;
	if bit_length > 27 then goto change_error;

	call deallocate_string(pr(1));

	p2 = pr(2) -> array_dope.data;
	m = p2 -> float_bin(0);
	if m > pr(2) -> current_bounds(1) then goto change_error;

	n = divide(m*bit_length + bits_per_char-1,bits_per_char,17,0);

	call allocate_string;

	pr(1) -> bit_word(0) = rel(p3);
	p1 = addr(p3 -> basic_string.value);

	p1 -> varying.len = n;
	p1 = addr(p1 -> varying.chars);

	do i = 1 to m;
	     vfx = p2 -> float_bin(i);

	     if vfx < 0 then goto change_error;
	     if substr(vbs,1,36-bit_length) then goto change_error;

	     p1 -> change.str(i) = substr(vbs,37-bit_length,bit_length);
	     end;

	/* zero out any remaining bits in last ASCII character */

	n = n*bits_per_char - m*bit_length;
	if n ^= 0 then substr(p1 -> change.str(i),1,n) = "0"b;

	return;

	/* mat numeric input */

switch(45):
	call check_input;
	mat_input = "1"b;
	number_read = 0;
	call mat_loop(1);
	return;

	/* mat string input */

switch(46):
	call check_input;
	mat_input = "1"b;
	number_read = 0;
	call mat_loop(2);
	return;

	/* mat numeric print */

switch(47):
	call check_print;

	if pr(2) -> current_bounds(2) > 1 then a_reg = max(a_reg,1);

	call print_new_line;
	call mat_loop(3);
	return;

	/* mat string print */

switch(48):
	call check_print;

	if pr(2) -> current_bounds(2) > 1 then a_reg = max(a_reg,1);

	call print_new_line;
	call mat_loop(4);
	return;

	/* mat numeric read */

switch(49):
	call check_random_numeric (Numeric_input);
	call mat_loop(7);
	return;

	/* mat string read */

switch(50):
	call check_random_string (String_input);
	call mat_loop(8);
	return;

	/* mat numeric write */

switch(51):
	call check_random_numeric (Numeric_input_output);
	call mat_loop(9);
	return;

	/* mat string write */

switch(52):
	call check_random_string (String_update);
	call mat_loop(10);
	return;

	/* mat numeric data read */

switch(53):
	call mat_loop(5);
	return;

	/* mat string data read */

switch(54):
	call mat_loop(6);
	return;

	/* mat linput */

switch(55):
	call mat_loop(11);
	call end_input;
	return;

	/* start print using */

switch(56): switch(123):
	call check_print;

	p1 = get_string_ptr(pr(1));
	pu_length = length(p1 -> based_vs);

	if pu_length = 0 then goto zero_print_using;

	quits_disabled = "1"b;
	allocate pu_string in(string_area);
	quits_disabled = "0"b;

	if had_quit then call signal_quit;

	pu_string = p1 -> based_vs;
	pu_pos = 0;

	return;

	/* print using numeric */

switch(57):
	call print_using_numeric;
	return;

	/* print using string */

switch(58): switch(125):
	p1 = get_string_ptr(pr(1));
	call print_using_string;
	return;

	/* end print using */

switch(59): switch(126):
	call get_next_field("1"b);

	quits_disabled = "1"b;
	free pu_string in(string_area);
	quits_disabled = "0"b;

	if had_quit then call signal_quit;

	return;

	/* mat print using numeric */

switch(60):
	call mat_loop(12);
	return;

	/* mat print using string */

switch(61):
	call mat_loop(13);
	return;

	/* mat a$ = nul$ */

switch(62):
	call mat_loop(14);
	return;

	/* mat a$ = b$ */

switch(63):
	p4 = pr(1) -> array_dope.data;
	call mat_loop(15);
	return;

	/* per(n,str) where n in temp(1) and str given by pr(1) */

switch(64): switch(131):
	p1 = get_string_ptr(pr(1));

	do i = 1 to hbound(per_name,1);
	     if p1 -> based_vs = per_name(i) then goto per_ok;
	     end;

	temp(1) = -1;
	return;

per_ok:	n = fixed(temp(1));

	if n < 0 then goto invalid_file_number;
	if n > 16 then goto invalid_file_number;

	if fcb(n) = null then temp(1) = 0;
	else temp(1) = float(fixed(substr(per_bits(i),fcb(n) -> file_type,1),1));

	if i > 3				/*  check for output permission */
	then if file_type ^= undefined_file
	     then if  ^write_permission
		then temp(1) = 0;

	return;

	/* create string value from string pointed at by pr(2) and whose
	   length is in a_reg */

switch(65): switch(132):
	n = a_reg;
	call allocate_string;
	p3 -> basic_string.value = pr(2) -> char_string;
	call return_string;
	return;

	/* make the string word pointed at by pr(2) specify a unique string value */

switch(66): switch(133):
	p1 = get_string_ptr(pr(2));
	n = length(p1 -> based_vs);

	if (n = 0) | (addrel(p1,-1) -> basic_string.count ^= 1)
	then do;

	     /* The string value is shared, we have to make unique copy */

	     call allocate_string;
	     p3 -> basic_string.value = p1 -> based_vs;

	     call deallocate_string(pr(2));

	     pr(2) -> string_word.offset = rel(p3);
	     end;

	return;

	/* str$(x) */

switch(89):
	call d_convert_number;

	n = length(ans);
	call allocate_string;
	p3 -> basic_string.value = ans;
	call return_string;
	return;

	/* tst(a$) */

switch(93):

	temp(1) = float(fixed(d_convert_string(),1),1);
	return;

	/* val(a$) */

switch(94):
	if d_convert_string() then return;

	call print_error(124);
	goto abort_label;

	/* numeric write */

switch(101):
	call check_random_numeric (Numeric_input_output);
	call d_numeric_write;
	return;

	/* numeric read */

switch(102):
	call check_random_numeric (Numeric_input);
	call d_numeric_read;
	return;

	/* change from string given by pr(1) to array given by pr(2) */

switch(110):
	bit_length = fixed(temp(1));
	if bit_length <= 0 then goto change_error;
	if bit_length > 63 then goto change_error;

	p1 = get_string_ptr(pr(1));

	n = divide(length(p1 -> based_vs) * bits_per_char,bit_length,17,0);

	if n > pr(2) -> current_bounds(1) then goto change_error;

	p2 = pr(2) -> array_dope.data;
	p2 -> double_float_bin(0) = n;

	p1 = addr(p1 -> varying.chars);

	do i = 1 to n;
	     p2 -> double_float_bin(i) = float(fixed(p1 -> change.str(i),63),63);
	     end;

	return;

	/* change to string given by pr(1) from array given by pr(2) */

switch(111):
	bit_length = fixed(temp(1));
	if bit_length <= 0 then goto change_error;
	if bit_length > 63 then goto change_error;

	call deallocate_string(pr(1));

	p2 = pr(2) -> array_dope.data;
	m = p2 -> double_float_bin(0);
	if m > pr(2) -> current_bounds(1) then goto change_error;

	n = divide(m*bit_length + bits_per_char-1,bits_per_char,17,0);

	call allocate_string;

	pr(1) -> bit_word(0) = rel(p3);
	p1 = addr(p3 -> basic_string.value);

	p1 -> varying.len = n;
	p1 = addr(p1 -> varying.chars);

	do i = 1 to m;
	     double_vfx = p2 -> double_float_bin(i);

	     if double_vfx < 0 then goto change_error;
	     if substr(double_vbs,1,72-bit_length) then goto change_error;

	     p1 -> change.str(i) = substr(double_vbs,73-bit_length,bit_length);
	     end;

	/* zero out any remaining bits in last ASCII character */

	n = n*bits_per_char - m*bit_length;
	if n ^= 0 then substr(p1 -> change.str(i),1,n) = "0"b;

	return;

	/* mat numeric input */

switch(112):
	call check_input;
	mat_input = "1"b;
	number_read = 0;
	call d_mat_loop(1);
	return;

	/* mat string input */

switch(113):
	call check_input;
	mat_input = "1"b;
	number_read = 0;
	call d_mat_loop(2);
	return;

	/* mat numeric print */

switch(114):
	call check_print;

	if pr(2) -> current_bounds(2) > 1 then a_reg = max(a_reg,1);

	call print_new_line;
	call d_mat_loop(3);
	return;

	/* mat string print */

switch(115):
	call check_print;

	if pr(2) -> current_bounds(2) > 1 then a_reg = max(a_reg,1);

	call print_new_line;
	call d_mat_loop(4);
	return;

	/* mat numeric read */

switch(116):
	call check_random_numeric (Numeric_input);
	call d_mat_loop(7);
	return;

	/* mat string read */

switch(117):
	call check_random_string (String_input);
	call d_mat_loop(8);
	return;

	/* mat numeric write */

switch(118):
	call check_random_numeric (Numeric_input_output);
	call d_mat_loop(9);
	return;

	/* mat string write */

switch(119):
	call check_random_string (String_update);
	call d_mat_loop(10);
	return;

	/* mat numeric data read */

switch(120):
	call d_mat_loop(5);
	return;

	/* mat string data read */

switch(121):
	call d_mat_loop(6);
	return;

	/* mat linput */

switch(122):
	call d_mat_loop(11);
	call end_input;
	return;

	/* print using numeric */

switch(124):
	call d_print_using_numeric;
	return;

	/* mat print using numeric */

switch(127):
	call d_mat_loop(12);
	return;

	/* mat print using string */

switch(128):
	call d_mat_loop(13);
	return;

	/* mat a$ = nul$ */

switch(129):
	call d_mat_loop(14);
	return;

	/* mat a$ = b$ */

switch(130):
	p4 = pr(1) -> array_dope.data;
	call d_mat_loop(15);
	return;

switch(134):
switch(201):
	/* left$ */
	/* used code from sst$ but initialize first */
	i = 1;
	n = fixed (temp(1));
	goto sst;
switch(135):
switch(202):
	/* right$ */
	/* use sst$ but initialize first */
	n = fixed(temp(1));

	/* Determine length and count back */

	p1 = get_string_ptr(pr(1));
	i = length(p1 -> based_vs) - n + 1;
	if i <= 0 then i = 1;
	goto right_entry;
	

	/* errors */

invalid_margin:
	n = 131;

err:	call print_error(n);
	goto abort_label;

type_and_usage_conflict:
	n = 132;
	goto err;

end_of_file:
	n = 133;
	goto err;

file_error:
	n = 134;
	goto err;

invalid_file_number:
	n = 135;
	goto err;

pointer_error:
	n = 136;
	goto err;

change_error:
	n = 138;
	goto err;

array_error:
	n = 139;
	goto err;

out_of_data:
	n = 103;
	goto err;

zero_print_using:
	n = 141;
	goto err;

print_using_error:
	n = 142;
	goto err;

incorrect_format_for_file_input:
	n = 145;
	goto err;

open_error:
	n = 147;
	goto err;

cannot_write:
	n = 148;
	goto err;

input_line_too_long:
	n = 149;
	goto err;

iox_error:
	n = 158;
	goto err;

close_error:
	n = 157;
	file_type = undefined_file;
	goto err;

cannot_read:
	n = 156;
	goto err;

cannot_scratch:
	n = 159;
	goto err;

default:	entry(mc_ptr,name,co_ptr,info_ptr,continue);

dcl	(mc_ptr,co_ptr,info_ptr) ptr,
	name char(*) unaligned,
	continue bit(1) aligned;

%include mc;

dcl	oncode_values(20) fixed bin static init(5,8,9,10,11,12,13,16,33,46,17,18,6,19,20,21,22,23,47,63);

dcl	math_message(20) fixed bin static init(114,115,116,117,118,119,120,121,122,123,95,96,
					114,115,116,117,120,119,122,123);

dcl	convert_new_oncode_ entry (fixed bin (35)) returns (fixed bin (35));
dcl	cond char(32);

	/* get ptr to stack frame of basic program in which fault occurred
	   by fishing it out of our argument list */

	p1 = cu_$stack_frame_ptr() -> arglist_ptr;
	bo_pt = p1 -> arglist.arg_ptr(p1 -> arglist.arg_count + 1);

	if ignore_handler then go to refuse;
	cond = name;

	if cond = "error"
	then do;
	     n = convert_new_oncode_ (oncode());

	     if n < 5 then goto refuse;
	     if precision_lng = 1 then if n > 46 then go to refuse;
	     else if n > 63 then go to refuse;

	     if n = 17 then return;

	     do i = 1 to hbound(oncode_values,1);
		if oncode_values(i) = n then goto math_error;
		end;

refuse:	     continue = "1"b;
	     return;

math_error:    call print_error(math_message(i));

	     return;
	     end;

	if have_conversion_label
	then do;
	     if cond = "conversion" then goto conversion_label;
	     if cond = "underflow" then goto conversion_label;
	     if cond = "overflow" then goto conversion_label;
	     end;

	if have_size_label
	then do;
	     if cond = "size" then goto size_label;
	     if cond = "fixedoverflow" then goto size_label;
	     end;

	if cond = "overflow"
	then do;
	     call restart_with_infinity(125,precision_lng);

	     /* the eovf indicator must be turned off here because it isn't later;
	        otherwise it can mess up interpretatio of later faults */

	     if mc_ptr ^= null then addr(mc_ptr->mc.scu(0))->scu.ir.eovf = "0"b;

	     return;
	     end;

	if cond = "zerodivide"
	then do;
	     call restart_with_infinity(144,precision_lng);
	     return;
	     end;

	if cond = "underflow"
	then do;
	     call get_mc_info;

	     call error_print(140);

	     /* turn off eufl indicator here because it's not turned off automatically */

	     if mc_ptr ^= null then addr(mc_ptr->mc.scu(0))->scu.ir.eufl = "0"b;

	     /* the FIM has already advanced the location counter and
	        put 0.0e0 in the eaq, so all we have to do is return */

	     return;
	     end;

	if cond = "lockup"
	then do;
	     mcp = mc_ptr;
	     scup = addr(mc.scu);

	     if baseno(program_header) ^= "000"b || scu.psr then goto refuse;

	     loc = fixed(scu.ilc,18);
	     call error_print(126);

	     goto abort_label;
	     end;

	if cond = "area"
	then do;
	     loc = fixed(basic_operators_frame.xr(7),18) - 1;

	     call error_print(143);

	     goto abort_label;
	     end;

	if cond = "stringsize" then return;

	if cond = "quit"
	then if quits_disabled
	     then do;
		had_quit = "1"b;
		return;
		end;
	     else goto refuse;

	goto refuse;

cpu_limit: entry(mc_ptr);

	/* cpu limit reached, get ptr to stack frame of basic program by
	   fishing it out of our arg list */

	p1 = cu_$stack_frame_ptr() -> arglist_ptr;
	bo_pt = p1 -> arglist.arg_ptr(p1 -> arglist.arg_count + 1);

	call get_mc_info;

	call error_print(146);

	goto abort_label;

cleanup:  entry;

	/* get ptr to stack frame of basic program by fishing it out of our arg list */

	p1 = cu_$stack_frame_ptr() -> arglist_ptr;
	bo_pt = p1 -> arglist.arg_ptr(p1 -> arglist.arg_count + 1);

	call tidy_up("0"b);
	return;

close_basic_file: entry(fn);

dcl	fn float bin;

	/* This entry is called by a basic sub-program to close a specified file.
	   We get the pointer to the stack frame of the basic program by taking
	   one step backwards in the stack */

	bo_pt = cu_$stack_frame_ptr() -> prev_sp;

	file_number = fixed(fn);

	if file_number <= 0 then return;
	if file_number > 16 then return;

	fcb_pt = fcb(file_number);

	if fcb_pt ^= null then call close_file("1"b);

	return;

	/* This procedure determines the location at which a fault occurred
	   by looking in machine conditions provided by signal.  If no
	   machine conditions are available, the condition is refused.
	   If the fault happened in the basic program, the ilc is used;
	   otherwise, the point of entry into basic_operators_ is used. */

get_mc_info:   proc;

	     mcp = mc_ptr;
	     if mcp = null then goto refuse;

	     scup = addr(mc.scu);

	     seg_no = "000"b || scu.psr;

	     if seg_no = baseno(program_header) then loc = fixed(scu.ilc,18);
	     else loc = fixed(basic_operators_frame.xr(7),18) - 1;

	     end;

	/* This procedure is called when the default handler wishes to
	   restart executing with the instruction after the one which
	   caused a fault. */

restart:	     proc;

	     scu.ilc = bit(fixed(fixed(scu.ilc, 18) + 1,18), 18);
	     scu.rfi = "1"b;
	     scu.if = "0"b;

	     end;

	/* This procedure is called to restart instruction after one causing
	   fault with value of + infinity in EAQ.  The argument gives error
	   message to be printed. */

restart_with_infinity: proc(errno,prec_lng);

dcl	errno fixed bin;
dcl	prec_lng fixed bin unaligned;

	     call get_mc_info;

	     call error_print(errno);

	     /* set result to + infinity */

	     if prec_lng = 1 then do;		/* single precision */
		mc.e = "01111111"b;
		mc.a = "011111111111111111111111111000000000"b;
		mc.q = "0"b;
		end;

	     else do;			/* extended precision*/
		mc.e = "01111111"b;
		mc.a = "011111111111111111111111111111111111"b;
		mc.q = "111111111111111111111111111000000000"b;
		end;

	     /* restart with instruction after one causing fault */

	     call restart;
	     end;

	/* This procedure is called to straighten up after program finishes. */

tidy_up:	     proc(normal);

dcl	     normal bit(1) aligned;

	     program_header_pt = program_header;

	     if time_limit ^= 0.0e0
	     then do;

		/* Turn off cpu timer */

		entry_variable = cpu_limit;
		ev.stack = bo_pt;

		call timer_manager_$reset_cpu_call(entry_variable);
		end;

	     call cleanup_strings;

	     if non_basic_caller
	     then do;

		/* If any of the arguments of this subprogram are string scalars,
		   we have to copy current value of string argument into original
		   argument and then free the basic string value */

		p1 = addrel(program_header_pt,incoming_args.location);

		do i = 1 to fixed(substr(incoming_args.number,1,17),17);
		     if fixed(p1 -> param_type(i),9) = string_scalar_param
		     then do;
			p2 = arg(i);
			p3 = get_string_ptr(p2);
			p4 = arglist_ptr -> arg_ptr(i);

			n = p2 -> arg_info.length;
			if p2 -> arg_info.type = 0 then p4 -> char_string = p3 -> based_vs;
			else addrel(p4,-1) -> varying_char_string = p3 -> based_vs;

			call deallocate_string(p2);
			end;
		     end;
		end;

	     call close_all_files(normal);
	     end;

	/* This procedure is called to perform a string assignment.  PR3
	   points at target and PR1 points at source.  If the target string
	   is non-null, the reference count on the string block is decremented
	   and the block is freed if the count reached zero.  If the source
	   is a null string, the target word is zeroed.  If the source string
	   is a constant, it must be copied into the string segment.  The
	   target word gets set to the offset of the string block in the
	   string segment.  For a normal assignment of the form
			let a$ = b$
	   the string words of both variables will "point" to same block
	   in string storage. */

string_assign: proc;

	     /* don't do anything if we have a$ = a$ */

	     if pr(1) = pr(3) then return;

	     /* drop reference count and free (if necessary) current value of left side */
     
	     call deallocate_string(pr(3));
     
	     if pr(1) -> word = 0
	     then do;
     
		/* right side is null string */
     
		pr(3) -> word = 0;
		return;
		end;
     
	     if pr(1) -> string_word.offset
	     then do;
     
		/* right side is variable, bump its reference count */
     
		p1 = ptr(string_segment,pr(1) -> string_word.offset);
     
		p1 -> basic_string.count = p1 -> basic_string.count + 1;
     
		pr(3) -> string_word.offset = pr(1) -> string_word.offset;
		end;
	     else do;
     
		/* right side is constant, copy it into string segment */
     
		n = length(pr(1) -> based_vs);
		call allocate_string;
     
		p3 -> basic_string.value = pr(1) -> based_vs;
     
		pr(3) -> string_word.offset = rel(p3);
		end;
	     end;

	/* This procedure is called to allocate a string block;  the size of
	   the string is contained in the global variable "n".  The reference
	   count of the new block (pointed at by global variable p3) is set to 1. */

allocate_string: proc;

	     quits_disabled = "1"b;
	     allocate basic_string in(string_area) set(p3);
	     quits_disabled = "0"b;

	     if had_quit then call signal_quit;

	     p3 -> basic_string.count = 1;

	     end;

	/* This procedure is called to deallocate the string specified by the
	   string variable pointed at by arg sp.  The reference count on the string
	   block is decremented and the block is freed if the count reached zero.
	   The string variable is set to zero which indicates a null value. */

deallocate_string: proc(sp);

dcl	     (sp,bsp) ptr;

	     if sp -> string_word.offset
	     then do;
		bsp = ptr(string_segment,sp -> string_word.offset);
		bsp -> basic_string.count = bsp -> basic_string.count - 1;

		if bsp -> basic_string.count = 0
		then do;
		     quits_disabled = "1"b;
		     free bsp -> basic_string in(string_area);
		     quits_disabled = "0"b;

		     if had_quit then call signal_quit;
		     end;

		string(sp -> string_word) = (36)"0"b;
		end;
     
	     end;

	/* This procedure contains entries for printing run-time error messages
	   whose text is stored in basic_error_messages_.  A negative message
	   number indicates that no trailing <NL> is desired.  The "print_error"
	   entry gets its line number from the value of index register 7 at last
	   entry into basic_operators_ while the "error_print" entry uses the
	   value of the global variable "loc" to find the line number. */

print_error:   proc(num);

dcl	     (num,ln,save_file_number,et) fixed bin,
	     main bit(1),
	     save_fcb_pt ptr,
	     ev entry variable options(variable);

	     ln = get_line_number();

com:	     save_file_number = file_number;
	     save_fcb_pt = fcb_pt;

	     file_number = 0;
	     fcb_pt = fcb(0);

	     if last_operation = print_op
	     then if line_pos ^= 0
		then call print_new_line;

	     file_number = save_file_number;
	     fcb_pt = save_fcb_pt;

	     error_number = abs(num);

	     et = index_block(error_number).sev;
	     main = et = 4 | main_program;

	     if main
	     then if num < 0 then ev = ioa_$nnl; else ev = ioa_;
		else ev = ioa_$nnl;

	     if et = 3
	     then do;
		if file_number ^= 0 then call ioa_$nnl("File ""^a"": ",file_name);
		et = 2;
		end;

	     k = index_block(error_number).loc;
	     if k = -1 then call ev("RUNTIME ERROR ^d in ^d",error_number,ln);
	     else if et = 2
		then call ev(message,ln);
		else if et = 1
		     then call ev(message,pr(1) -> based_vs,ln);
		     else call ev(message,pr(1),ln);

	     if ^main
	     then do;
		if num < 0 then ev = ioa_$nnl; else ev = ioa_;

		call ev(" of subprogram ""^A""",addrel(entryname,0));	/* pass UNPACKED ptr */
		end;

	     if num < 0 then call ioa_$nnl("? ");
	     return;

error_print:   entry(num);

	     ln = obtain_line_number();
	     goto com;
	     end;

	/* This procedure is called to convert an object program location into
	   a line number;  it does a binary search on the statement map.  The
	   "get_line_number" entry uses the value of index register 7 at last
	   entry into basic_operators_ while the "obtain_line_number" entry
	   uses the value in the global variable "loc".  In either case, the
	   location is adjusted to be an offset with respect to the program
	   header and that is the value actually used in the search. */

get_line_number: proc returns(fixed bin);

dcl	     (lower,upper,i,map_loc) fixed bin,
	     mp ptr;

	     loc = fixed(xr(7),18) - 1;

obtain_line_number: entry returns(fixed bin);

	     loc = loc - fixed(program_header_offset,18);

	     lower = 1;
	     upper = fixed(program_header -> basic_program_header.statement_map.number,18);

	     mp = addrel(program_header,program_header -> basic_program_header.statement_map.location);

	     do while(lower <= upper);
		i = divide(lower+upper,2,17,0);

		map_loc = fixed(mp -> map(i).location,18);

		if loc < map_loc
		then upper = i - 1;
		else if loc = map_loc then do;
		     /* skip over any remark lines */
		     do while(loc = fixed(mp->map(i+1).location,18)); i = i+1; end;
		     return(fixed(mp -> map(i).line,18));
		     end;
		     else if loc < fixed(mp -> map(i+1).location,18)
			then return(fixed(mp -> map(i).line,18));
			else lower = i + 1;

		end;

	     return(-1);
	     end;

	/* This procedure is called at the end of execution, just prior to
	   a return, to clean up all string variables.  Each string variable
	   has its string block reference count decremented;  the block is freed
	   if the count reached zero.  Note that we cannot just free each block
	   since the same block may be referenced by more than one variable and
	   in fact, such references may be from other programs.  It is for the
	   convenience of this procedure that all string variables are stored in
	   a contiguous block. */

cleanup_strings: proc;

dcl	     i fixed bin,
	     p ptr;

	     p = addrel(bo_pt,program_header -> basic_program_header.string_storage.location);

	     do i = 1 to fixed(program_header -> basic_program_header.string_storage.number,18);
		call deallocate_string(p);

		p = addrel(p,1);
		end;

	     /* if the string temporary contains a value, free it */

	     call deallocate_string(addr(string_value));
	     end;


	/* This procedure is called to convert the value in the global variable
	   "temp(1)" from float binary(27) to the appropriate string representation
	   in I, F, or E format according to the rules of the language;
	   the converted value is placed in the global variable "ans". */

convert_number: proc;
     
dcl	     abs_value float bin,
	     (k,j,ndigits) fixed bin,
	     dec_value float dec(6),
	     fixed_dec_value fixed dec(9),
	     exp fixed bin;
     
dcl	     1 dec_value_overlay aligned based(addr(dec_value)),
	     2 sign	char(1) unaligned,
	     2 digits	char(6) unaligned,
	     2 skip	bit(1) unaligned,
	     2 exponent	fixed bin(7) unaligned;
     
dcl	     fixed_digits char(10) aligned based(addr(fixed_dec_value));

	     if temp(1) = 0
	     then do;
		ans = " 0";
		return;
		end;
     
	     abs_value = abs(temp(1));
     
	     if temp(1) < 0 then ans = "-"; else ans = " ";
     
	     if abs_value < 134217728	/* 2 ** 27 */
	     then if float(fixed(abs_value)) = abs_value
		then do;
     
		     /* integer format */
     
		     fixed_dec_value = convert(fixed_dec_value,abs_value);
     
		     k = verify(substr(fixed_digits,2),"0");
		     ans = ans || substr(fixed_digits,k+1);
		     return;
		     end;
     
	     /* we assume that the following conversion is ROUNDED
	        and normalized to the left */
     
	     dec_value = convert(dec_value,abs_value);
     
	     k = verify(reverse(digits),"0");
	     ndigits = 7 - k;
     
	     exp = exponent + k - 1;
     
	     if exp >= 0
	     then do;

		if exp + ndigits <= 8
		then do;

		     /* due to rounding integer is closest approximation */

		     ans = ans || substr(digits,1,ndigits);

		     if exp > 0 then ans = ans || substr("00000000",1,exp);

		     return;
		     end;

		/* exponential format */

e_format:		ans = ans || substr(digits,1,1);
		ans = ans || ".";
		ans = ans || substr(digits,2,ndigits-1);
		ans = ans || " E";

		exp = exp + ndigits - 1;
     
		if abs(exp) < 10
		then do;
		     fixed_dec_1 = convert(fixed_dec_1,exp);
		     ans = ans || fixed_dec_1_overlay;
		     end;
		else do;
		     fixed_dec_2 = convert(fixed_dec_2,exp);
		     ans = ans || fixed_dec_2_overlay;
		     end;
     
		return;
		end;
     
	     j = ndigits + exp;
     
	     if j <= 0
	     then do;
		if ndigits - j > 6 then goto e_format;
     
		ans = ans || "0.";
		if j ^= 0 then ans = ans || substr("00000000",1,abs(j));
		ans = ans || substr(digits,1,ndigits);
		end;
	     else do;
		ans = ans || substr(digits,1,j);
		ans = ans || ".";
		ans = ans || substr(digits,j+1,ndigits-j);
		end;
     
	     end;

	     /* This function converts the BASIC string specified by pr(1)
	        to a numeric value in temp(1).  "1"b is returned if no
	        error was found and "0"b is returned if the string was
	        erroneous.  The conversion is attempted twice;  if the
	        first attempt fails, we try again with all white space removed
	        from the string.  This logic attempts to optimize the
	        simple cases that do not have embedded white space. */

convert_string: proc returns(bit(1) aligned);

dcl	     good_string bit(1) aligned;

	     p1 = get_string_ptr(pr(1));
	     good_string = "0"b;

	     conversion_label = first_error;
	     temp(1) = convert(temp(1),p1 -> based_vs);

ok:	     good_string = "1"b;

done:	     have_conversion_label = (36)"0"b;
	     return(good_string);

	     /* had error first time, try again if string contains white space */

first_error:   if search(p1 -> based_vs,white_space) = 0 then goto done;

	     conversion_label = done;

		begin;

dcl		copy char(length(p1 -> based_vs)),
		(i,j) fixed bin;

		copy = "";
		j = 0;

		do i = 1 to length(p1 -> based_vs);
		     if index(white_space,substr(p1 -> based_vs,i,1)) = 0
		     then do;

			/* current char not white space, copy it */

			j = j + 1;
			substr(copy,j,1) = substr(p1 -> based_vs,i,1);
			end;
		     end;

		temp(1) = convert(temp(1),copy);
		end;

	     goto ok;
	     end;

	/* This procedure is called to obtain a pointer to the string block
	   specified by the string variable pointed at by the argument ptr "sp".
	   If the specified string variable is zero, a pointer to the zero
	   length varying string is returned. */

get_string_ptr: proc(sp) returns(ptr);

dcl	     sp ptr,
	     null_vs char(1) varying static init("");

	     if sp -> word = 0 then return(addr(null_vs));

	     if sp -> string_word.offset
	     then return(addr(ptr(string_segment,sp -> string_word.offset) -> basic_string.value));

	     return(sp);
	     end;

	/* This procedure is called to make sure that a PRINT-type operation
	   is valid on the file specified by the global variable "fcb_pt".
	   The file must be ASCII (or TTY);  if the last operation was not
	   a PRINT, the file is converted to PRINT and the buffers set up. */

check_print:   proc;

	     call check_ascii (Ascii_output);

	     if last_operation ^= print_op
	     then do;

		if file_number = 0 then seg_pt = iox_$user_output;

		buffer_pos, line_pos = 0;
		last_operation = print_op;
		end;

	     end;

	/* This procedure is called to make sure that a INPUT-type operation
	   is valid on the file specified by the global variable "fcb_pt".
	   The file must be ASCII (or TTY);  if the last operation was not
	   a INPUT, the file is converted to INPUT and more input is gotten. */

check_input:   proc;

	     call check_ascii (Ascii_input);

	     if last_operation ^= input_op
	     then do;
		if file_number = 0 then seg_pt = iox_$user_input;

		last_operation = input_op;
		buffer_pos = buffer_length;
		end;

	     if buffer_pos >= buffer_length
	     then do;
		if file_number = 0 then call prompt;

		call get_input(0);
		end;

	     end;

	/* This procedure repositions an ascii file to its beginning */

reset_ascii:   proc;

	     call seg_pt -> iocb.position(seg_pt,-1,0,code);

	     if code ^= 0
	     then if code ^= error_table_$no_operation
		then goto iox_error;

	     buffer_pos = buffer_length;

	     last_operation = reset_op;
	     end;

	/* This procedure prints an input prompt on terminal */

prompt:	     proc;

	     substr(buffer,1,2) = "? ";
	     call iox_$user_output -> iocb.put_chars(iox_$user_output,buffer_pt,2,code);

	     end;

	/* This procedure is called to make sure that ASCII-type operations
	   are valid on the file specified by the global variable "fcb_pt".
	   If the file is not ASCII or TTY, it can be converted to ASCII if
	   it empty but an error is issued if it is non-empty. */

check_ascii:   proc (new_mode);

dcl	new_mode fixed bin;

	     io_ops_since_margin = io_ops_since_margin + 1;

	     if file_type = tty_file then return;

	     if open_mode = new_mode then return;
	     if open_mode = Ascii_input_output then return;
	     if file_type = ascii_file then do;		/* open the wrong way--close and reopen */
		call open_ascii (new_mode);
		return;
		end;

	     /* can convert file to ascii if it is empty */

	     /* be sure file is empty */
	     if length_of_file (seg_pt) > 0 then goto type_and_usage_conflict;

	     if file_type >= numeric_file
	     then call zap_file;

	     if io_ops_since_margin > 0 then do;
		margin = -1;		/* reset so we don't use old margin */
		io_ops_since_margin = 0;
		end;

	     call attach_ascii;
	     call open_ascii (new_mode);

	     last_operation = 0;
	     end;

	/* This procedure is called to make sure that the file specified by
	   the global variable "fcb_pt" is RANDOM-NUMERIC.  If not, it
	   is converted if empty or an error is issued if it is non-empty. */

check_random_numeric: proc (new_mode);

dcl	new_mode fixed bin;

	     io_ops_since_margin = io_ops_since_margin + 1;

	     if open_mode = new_mode then return;
	     if open_mode = Numeric_input_output then return;
	     if file_type = numeric_file then do;	/* close and reopen the right way */
		call open_random (new_mode);
		return;
		end;

	     if must_be_ascii then goto type_and_usage_conflict;
	     /* be sure file is empty before converting type */

	     if open_mode = Ascii_output then goto type_and_usage_conflict;
						/* can't be empty if open for stream_output */
	     if length_of_file (seg_pt) > 0 then goto type_and_usage_conflict;

	     /* if file used to be some other type, we must get rid of
	        vfile header or vfile won't allow random numeric use */

	     if file_type = string_file then call zap_file;
	     else if file_type = ascii_file then call close_vfile;

	     call attach_numeric;
	     call open_random(new_mode);		/* this should create file if it doesn't already exist  */

	     margin = 1;
	     io_ops_since_margin = 0;
	     end;

	/* This procedure is called to make sure that the file specified by
	   the global variable "fcb_pt" is RANDOM-STRING.  If not, it is
	   converted if empty or an error is issued if it is non-empty. */

check_random_string: proc (new_mode);

dcl	new_mode fixed bin;

	     io_ops_since_margin = io_ops_since_margin + 1;

	     if open_mode = new_mode then return;
	     if open_mode = String_update then return;
	     if file_type = string_file then do;
		call open_random (new_mode);
		return;
		end;

	     if must_be_ascii then goto type_and_usage_conflict;

	      /* be sure file is empty before converting type */

	     if open_mode = Ascii_output then goto type_and_usage_conflict;
						/* can't be empty if open for ascii output */
	     if length_of_file (seg_pt) > 0 then goto type_and_usage_conflict;

	     if file_type = numeric_file then call zap_file;	/* get rid of old vfile header */
	     else if file_type = ascii_file then call close_vfile;

	     if (io_ops_since_margin > 0) | (margin < 0) then do;
		margin = 12;
		io_ops_since_margin = 0;
		end;

	     call attach_string;
	     call open_random (new_mode);	/* this should create file if it doesn't already exist */

	     end;

	/* This function returns the length of a file attached through vfile_.
	   If the file is not attached, or not attached through vfile_,
	   0 is returned.  The length is in units appropriate to the type of file.  */

length_of_file: proc (iocbptr) returns (fixed bin (34));

dcl	iocbptr ptr;

	     if iocbptr = null then return (0);

	     info (1) = vfs_version_1;
	     call iox_$control (iocbptr, "file_status", addr (info), code);
	     if code ^= 0 then return (0);

	     file_lng = uns_info.end_pos;		/* this works for blocked files too */
	     if file_lng ^= 0
	     then if uns_info.type = 1			/* unstructured */
		then if uns_info.flags.header_present		/* numeric */
		     then file_lng = divide (file_lng, (precision_lng*4), 34, 0);

	     return (file_lng);

	     end;


	/* This procedure is called to completely wipe out an empty file so that
	   its type can be changed.  We must get rid of the vfile header so vfile
	   won't give us an error.  We don't do this during scratch op because
	   then we want header (with margin) to stay around. */

zap_file: proc;

	     call close_vfile;
	     if code ^= 0 then goto close_error;

	     /* truncate by  opening for stream_output without append */

	     call iox_$attach_iocb (seg_pt, "vfile_ " || file_name, code);

	     if code = 0 then do;
		attached_by_us = "1"b;
		call iox_$open (seg_pt, stream_output, "0"b, code);
		if code = 0 then opened_by_us = "1"b;
		end;

	     if code ^= 0 then goto open_error;

	     call close_vfile;		/* close this special opening */

	     end;

	/* This procedure allocates a buffer for an ASCII file */

get_ascii_buffer: proc;

	     file_type = ascii_file;
	     if margin < 0 then margin = 75;

	     buff_size, buffer_size = default_buffer_size;

	     quits_disabled = "1"b;
	     allocate buffer in(string_area);
	     quits_disabled = "0"b;

	     if had_quit then call signal_quit;

	     end;

	/* This procedure is called to force the contents of the print
	   buffer of the ASCII or TTY file specified by the global variable
	   "fcb_pt". */

force_buffer:  proc;

	     call seg_pt -> iocb.put_chars(seg_pt,buffer_pt,buffer_pos,code);
	     if code ^= 0 then goto iox_error;


	     buffer_pos = 0;
	     end;

	/* This procedure places a <NL> at the end of the print buffer of
	   the file specified by the global variable "fcb_pt" and then
	   forces the buffer. */

print_new_line: proc;

	     if buffer_pos = buffer_size then call force_buffer;

	     buffer_pos = buffer_pos + 1;
	     substr(buffer,buffer_pos,1) = NL;

	     call force_buffer;

	     line_pos = 0;
	     end;

	/* This procedure appends the varying string pointed at by the
	   global variable "p1" to the PRINT buffer of the ASCII (or TTY)
	   file specified by the global variable "fcb_pt".  In the case of
	   the "string_print" entry, the value of "p1" was set by the caller;
	   in the case of the "numeric_print" entry, the value in global
	   variable "temp(1)" is converted to string form and "p1" is set
	   to point at the result of the conversion.  This routine worries
	   about the situations where the string to be PRINTed does not
	   fit in the space left on the line and where the string is too
	   big for a completely empty line. */

numeric_print: proc;

	     if precision_lng = 1 then call convert_number;
	     else call d_convert_number;
	     ans = ans || " ";
	     p1 = addr(ans);

string_print:  entry;

	     if margin ^= 0
	     then if line_pos + length(p1 -> based_vs) > margin
		then call print_new_line;

	     do i = 0 repeat(i + k) while("1"b);
		n = length(p1 -> based_vs) - i;

		k = buffer_size - buffer_pos;
		if margin ^= 0 then k = min(k,margin - line_pos);

		if k >= n
		then do;
		     substr(buffer,buffer_pos + 1,n) = substr(p1 -> based_vs,i+1,n);
		     buffer_pos = buffer_pos + n;
		     line_pos = line_pos + n;
		     return;
		     end;

		substr(buffer,buffer_pos+1,k) = substr(p1 -> based_vs,i+1,k);
		buffer_pos = buffer_pos + k;
		line_pos = line_pos + k;

		if line_pos = margin then call print_new_line;
		else call force_buffer;
		end;

	     end;

	/* This procedure is called to close the file specified by the
	   global variable "fcb_pt".  A <NL> is placed at the end of a
	   PRINT file if needed.  A scratch file is deleted;  the bit
	   count of a non-scratch segment is computed and the file
	   is released. */

close_file:    proc(destroy);

dcl	destroy bit(1) aligned;

	     if last_operation = close_op then return;

	     if last_operation = print_op
	     then if line_pos ^= 0
		then call print_new_line;

	     code = 0;

	     call close_vfile;
	     if destroy
		then if code = 0
		     then if ^must_be_ascii
			     then call iox_$destroy_iocb (seg_pt, code);

	     if code ^= 0 then call print_error(157);

	     if temporary_file then do;

		/* A temporary file gets deleted after closing */

		call expand_path_(addr(file_name),length(file_name),addr(dir),addr(ent),code);
		call hcs_$delentry_file(dir,ent,code);

		if code = error_table_$fulldir
		then do;

		     /* file is multi-segment-file */

		     call hcs_$del_dir_tree(dir,ent,code);

		     if code = 0 then call hcs_$delentry_file(dir,ent,code);
		     end;

		/* ignore other error codes */
		end;

	     last_operation = close_op;
	     end;

	/* This procedure is called to close all files belonging to
	   the current object program;  any files received as parameters
	   will not be closed.  If the TTY belongs to this object program
	   and the closing is NORMAL, a <NL> will be appended to the
	   TTY output. */

close_all_files: proc(normal);

dcl	     normal bit(1) aligned;

	     do i = 1 to 16;
		fcb_pt = fcb(i);

		if fcb_pt ^= null
		then if owner = bo_pt
		     then do;
			if fcb_pt -> basic_fcb.seg_pt ^= null
			then call close_file("1"b);

			quits_disabled = "1"b;
			free basic_fcb in(string_area);
			quits_disabled = "0"b;

			if had_quit then call signal_quit;
			end;
		end;

	     if normal
	     then do;
		fcb_pt = fcb(0);

		if owner = bo_pt
		then do;
		     if last_operation = print_op
		     then if line_pos ^= 0
			then call print_new_line;

		     owner = null;
		     end;

		end;
	     end;

	/* This procedure is called to get a line of input for an INPUT
	   operation on the file specified by the global variable "fcb_pt".
	   A non-zero argument indicates an error message to be printed if
	   the file is actually the TTY. */

get_input:     proc(en);

dcl	     en fixed bin;

	     if file_type = tty_file
	     then if en ^= 0
		then call print_error(en);

	     call read_line;

	     if code = error_table_$end_of_info then goto end_of_file;
	     end;

	/* This procedure is called to read a complete line of input from
	   an ASCII file.  If the line is too long for the buffer associated
	   with the file, a new buffer of twice the size is obtained and
	   another read is done.  */

read_line:     proc;

dcl	     bp ptr,
	     bl fixed bin(21);

	     call seg_pt -> iocb.get_line(seg_pt,buffer_pt,buffer_size,buffer_length,code);

	     do while(code ^= 0);
		if code ^= error_table_$long_record then return;

		if file_type = tty_file then goto input_line_too_long;
		if buffer_size >= max_buffer_size then goto input_line_too_long;

		old_buff_size = buffer_size;
		buffer_size = 2 * old_buff_size;

		quits_disabled = "1"b;
		allocate buffer in(string_area) set(bp);
		substr(bp -> buffer,1,old_buff_size) = substr(buffer,1,old_buff_size);
		free buffer in(string_area);
		buffer_pt = bp;
		quits_disabled = "0"b;

		if had_quit then call signal_quit;

		call seg_pt -> iocb.get_line(seg_pt,addr(buff2),old_buff_size,bl,code);

		buffer_length = buffer_length + bl;
		end;

	     buffer_pos = 0;
	     end;

	/* This procedure is called to open the file whose name is in fcb
	   specified by global variable fcb_pt.  If the file name begins
	   with ":", it is a Multics switch name;  otherwise, the file name
	   specifies a segment or msf in storage system.  If the file exists,
	   open_file attempts to determine type so it can open file
	   appropriately;  if file doesn't exist, we can't create it */

open_file:     proc;

	     /* Give special operating system a chance to change file name */

	     call basic_file_name_(file_name);

	     if substr(file_name,1,1) = ":"
	     then do;
     
		/* file name is Multics switch name */

		if fast_related_data_$in_fast_or_dfast then go to open_error;	/* don't allow this mode in FAST */
     
		must_be_ascii = "1"b;
     
		n = index(file_name," ");
		if n = 0 then n = length(file_name) + 1;

		call iox_$find_iocb(substr(file_name,2,n-1),seg_pt,code);
		if code ^= 0 then goto open_error;

		/* we must attach using description given in file name
		   if iocb is not already attached */

		if seg_pt -> iocb.attach_descrip_ptr = null
		then do;
		     if n > length(file_name) then goto open_error;

		     do while(substr(file_name,n,1) = " ");
			if n >= length(file_name) then goto open_error;
			n = n + 1;
			end;

		     call iox_$attach_iocb(seg_pt,substr(file_name,n),code);
		     if code ^= 0 then goto open_error;

		     attached_by_us = "1"b;
		     end;
		file_type = ascii_file;

		/* open file if not already open, if already open, determine mode */

		p4 = seg_pt -> iocb.open_descrip_ptr;

		if p4 ^= null
		then do;
		     if substr(p4 -> based_vs,1,6) ^= "stream" then goto open_error;

		     n = index(p4 -> based_vs," ") - 1;
		     if n < 0 then n = length(p4 -> based_vs);

		     if index(substr(p4 -> based_vs,1,n),"input") ^= 0 then open_mode = Ascii_input;
		     if index(substr(p4 -> based_vs,1,n),"output") ^= 0 then do;
			if open_mode = Ascii_input
			then open_mode = Ascii_input_output;
			else open_mode = Ascii_output;
			write_permission = "1"b;
			end;

		     end;

		call get_ascii_buffer;
		end;
	     else do;
     
		/* file is segment or msf in storage system */
     
		must_be_ascii = "0"b;
     
		call expand_path_(addr(file_name),length(file_name),addr(dir),addr(ent),code);
     
		if code ^= 0 then goto file_error;
     
		call hcs_$status_(dir,ent,1,addr(status_info_branch),null,code);
     
		if code ^= 0
		then do;
     
		     /* if file does not exist, we cannot create it until
		        we know what type it is to be. */
     
		     if code ^= error_table_$noentry then goto open_error;
		     write_permission = "1"b;		/* can write if we create */
     
		     return;
		     end;
     
		write_permission = substr (mode,4,1);
		if status_info_branch.type = "10"b	/* directory */
		then do;
		     must_be_ascii = "1"b;		/* to keep close from truncating */
		     call attach_ascii;
		     end;
		else do;
     
		     /* we must have at least 'r' permission on segment */

		     if substr(mode,2,1) = "0"b then goto open_error;
     
		     /* determine type and open */

		     info(1) = vfs_version_1;			/* set version number */
		     call vfile_status_ (dir, ent, addr(info), code);
		     if code ^= 0 then go to open_error;	/* can't do anything */


		      /* check for old format random files and convert if necessary */

		      if uns_info.type = 1
		     then if ^uns_info.flags.header_present
			then do;

			     call convert_old_basic_file_ (dir, ent, code);
			     if code = 0 then do;

				call ioa_ ("Converted file ^a to new format.", file_name);
				call vfile_status_(dir, ent, addr(info), code);
				end;

			     else if code =  error_table_$not_done
				then do;
				     call attach_ascii;
				     return;
				     end;
				else do;
				     call ioa_ ("Unable to convert old format file ^a to new format.", file_name);
				     go to open_error;
				     end;

			     end;

		     if blk_info.type = 3 then do;
			margin = blk_info.max_rec_len;
			call attach_string;
			end;

		     else if uns_info.type ^= 1
			then goto type_and_usage_conflict;
			else do;
			     if ^uns_info.flags.header_present then call attach_ascii;

			     else do;
				if uns_info.header_id ^= precision_lng then goto type_and_usage_conflict;
				margin = 1;
				call attach_numeric;
				end;
			     end;
		     end;
     
		end;
     
	     end;

	/* This procedure specifies the attachment options for a terminal format file.
	   Opening is done when the file is actually referenced. */

attach_ascii:  proc;

	     call attach_vfile ("vfile_ " || rtrim(file_name) || " -append " || ascii_size_op);

	     call get_ascii_buffer;

	     file_type = ascii_file;

	     end;

	/* This procedure specifies the attachment options for a random numeric file.
	   Opening is done when the file is actually referenced. */

attach_numeric:  proc;

	     call attach_vfile ("vfile_ " || rtrim(file_name) || " -no_trunc -header " || header_numbers(precision_lng) || " -ssf");

	     file_type = numeric_file;

	     end;

	/* This procedure specifies the attachment options for a random string file.
	   Opening is done when the file is actually referenced. */

attach_string:  proc;

dcl	k fixed bin;
dcl	fixed_dec_value fixed dec(7);
dcl	fixed_digits char(8) aligned based(addr(fixed_dec_value));

	     fixed_dec_value = convert(fixed_dec_value, margin);
	     k = verify (substr (fixed_digits, 2), "0");

	     call attach_vfile ("vfile_ " || rtrim(file_name) || " -blocked " || substr(fixed_digits, k+1)  || " -ssf");

	     file_type = string_file;

	     end;

	/* This procedure is called to attach a file via the vfile_
	   IO module using a unique stream name of the form basic.xxxx */

attach_vfile:  proc(attach_descrip);

dcl	     attach_descrip char(*);

	     attached_by_us = "1"b;

	     if seg_pt = null then do;
		call iox_$find_iocb(unique(),seg_pt,code);
		if code ^= 0 then goto open_error;
		end;

	     call iox_$attach_iocb (seg_pt, attach_descrip, code);
	     if code ^= 0 then goto open_error;

	     end;

	/* This procedure returns a string of the form
		basic.nnnnnn
	   where the decimal number nnnnnn is incremented
	   by 1 each time unique is called. */

unique:	     proc returns(char(12));

dcl	     unique_count fixed dec(6) static init(0),
	     1 unique_value static,
	     2 header	char(6) init("basic."),
	     2 count	picture "999999";

	     unique_count = unique_count + 1;
	     unique_value.count = unique_count;

	     return(string(unique_value));
	     end;

	     /* This procedure opens an ascii file.  If the file is already open, it must
	        be closed first. */

open_ascii:    proc (new_open_mode);

dcl	new_open_mode fixed bin;

	     if open_mode > Not_open then do;
		if ^opened_by_us then goto open_error;
		call iox_$close (seg_pt, code);
		if code ^= 0 then goto open_error;
		end;

	     call iox_$open (seg_pt, open_types (new_open_mode), "0"b, code);
	     if code ^= 0 then goto open_error;

	     opened_by_us = "1"b;
	     open_mode = new_open_mode;
	     end;


	     /* This procedure opens a random numeric or string file.  If the file is already open,
	        the current position must be remembered, the file must be closed, and the
	        position must be restored after reopening. */

open_random:   proc (new_open_mode);

dcl	new_open_mode fixed bin;

	     if open_mode > Not_open then do;
		if ^opened_by_us then goto open_error;
		call iox_$control (seg_pt, "read_position", addr(position_info), code);
		if code ^= 0 then goto open_error;
		buff_size = position_info.next_position;
		call iox_$close (seg_pt, code);
		if code ^= 0 then goto open_error;
		end;

	     call iox_$open (seg_pt, open_types (new_open_mode), "0"b, code);
	     if code ^= 0 then goto open_error;

	     opened_by_us = "1"b;			/* set so we can close */

	     if open_mode > Not_open then do;
		call iox_$position (seg_pt, 2, buff_size, code);
		if code ^= 0 then goto pointer_error;
		end;

	     open_mode = new_open_mode;

	     end;


	/* This procedure is called to close a file.  The file is closed
	   and detached (if we opened or attached), and for ascii files
	   the buffer is freed.  */

close_vfile:   proc;

	     if seg_pt ^= null then do;		/* sometimes this gets called with seg_pt=null! */
	     if seg_pt -> iocb.open_descrip_ptr ^= null & opened_by_us
	     then do;
		call seg_pt -> iocb.close(seg_pt,code);
		if code ^= 0 then return;
		opened_by_us = "0"b;
		open_mode = Not_open;
		end;

	     if seg_pt -> iocb.attach_descrip_ptr ^= null & attached_by_us
	     then do;
		call seg_pt -> iocb.detach_iocb(seg_pt,code);
		if code ^= 0 then return;
		attached_by_us = "0"b;
		end;
	     end;

	     if buffer_pt ^= null then do;
		quits_disabled = "1"b;
		free buffer in(string_area);
		buffer_pt = null;
		quits_disabled = "0"b;
	     end;

	     if had_quit then call signal_quit;

	     file_type = undefined_file;
	     end;


	/* This procedure is called to tab to the indicated position on
	     the PRINT file specified by the global variable "fcb_pt". */

tab:	     proc(new_pos);

dcl	     new_pos fixed bin;

	     if margin = 0 then n = new_pos;
	     else n = mod(new_pos, margin);

	     n = n - line_pos;

	     do while(n > 0);
		k = min(buffer_size - buffer_pos,n);
		substr(buffer,buffer_pos+1,k) = "";
		buffer_pos = buffer_pos + k;

		if buffer_pos = buffer_size then call force_buffer;

		n = n - k;
		end;

	     line_pos = new_pos;
	     end;

	/* This procedure sets the global variable "n" to the file number
	   specified by the global variable "temp(1)".  An error is issued
	   if the file number is invalid, no file exists for the specified
	   number, or if the file is of the wrong type as indicated by the
	   argument "ok_type". */

get_file_number: proc(ok_type);

dcl	     ok_type bit(5) aligned;

	     n = fixed(temp(1));

	     if n < 0 then goto invalid_file_number;
	     if n > 16 then goto invalid_file_number;

	     if fcb(n) = null then goto invalid_file_number;

	     if substr(ok_type,fcb(n) -> file_type,1) = "0"b then goto invalid_file_number;
	     end;

	/* This procedure writes the value in the global variable "temp(1)"
	   into the next position in the RANDOM NUMERIC file specified
	   by the global variable "fcb_pt".  An endfile is generated if the
	   max length of the file is exceeded. */

numeric_write: proc;

	     call iox_$put_chars (seg_pt, addr(temp(1)), 4, code);

	     if code ^= 0 then goto end_of_file;	/* msg should really reflect code */

	     end;

	/* This procedure writes the varying string pointed at by the
	   global variable "p1" into the next position in the RANDOM
	   STRING file specified by the global variable "fcb_pt". 
	   An endfile is generated if the max length of the file is exceeded. */

string_write:  proc;

	     call iox_$write_record (seg_pt, addrel(p1,1), min(length(p1->based_vs), margin), code);

	     if code ^= 0 then goto end_of_file;	/* should improve to use code */

	     end;

	/* This procedures sets the global variable "temp(1)" to the value
	   in the next position in the RANDOM NUMERIC file specified by
	   the global variable "fcb_pt". */

numeric_read:  proc;

	     call iox_$get_chars (seg_pt, addr(temp(1)), 4, buff_size, code);

	     if code ^= 0 then go to end_of_file;

	     end;

	/* This procedure sets the global variable "p1" to point to
	   the next string in the RANDOM STRING file specified by
	   the global variable "fcb_pt".  A new string block is allocated. */

string_read:   proc;

	     call iox_$read_record (seg_pt, addr(string_buffer), 4096, buff_size, code);
	     if code ^= 0 then goto end_of_file;

	     n = buff_size;
	     call allocate_string;
	     p3 -> basic_string.value = substr(string_buffer, 1, n);

	     end;

	/* This procedure is called when a string value is to be returned
	   to the object program.  The global variable "string_value" is set to
	   the offset of the string block in the string segment and PR1
	   is set to point at "string_value". */

return_string: proc;

	     call deallocate_string(addr(string_value));

	     string_value = rel(p3);
	     pr(1) = addr(string_value);

	     end;

	/* This procedure is called to read a numeric value from the
	   file specified by the global variable "fcb_pt".  The "conversion"
	   condition is handled by setting the global variable "conversion_label"
	   before the conversion;  after the conversion is completed the
	   global label is set to "null" by zeroing out the first word.
	   The value read will be stored in the global variable "temp(1)". */

numeric_input: proc;

	     no_input = "1"b;

num:	     if buffer_pos >= buffer_length - 1 then return;

	     n = 0;
	     do while(buffer_pos < buffer_length);
		buffer_pos = buffer_pos + 1;

		ch = substr(buffer,buffer_pos,1);

		if ch = "," then goto ni_done;
		if ch = NL then goto ni_done;

		if mat_input
		then if substr(buffer,buffer_pos,2) = amp_NL
		     then do;

			/* make sure we see & at beginning of next request */

			buffer_pos = buffer_pos - 1;
			goto ni_done;
			end;

		if search(ch,white_space) = 0
		then do;
		     n = n + 1;
		     substr(c32,n,1) = ch;
		     end;
		end;

	     /* there was no NL at end of input line */

	     if file_type ^= tty_file then goto incorrect_format_for_file_input;

	     call get_input(-110);
	     goto num;

ni_done:	     if n = 0
	     then do;
		if ch = "," then goto num;
		if ch ^= "&" then return;

		if file_type = tty_file then call prompt;

		call get_input(0);
		goto num;
		end;

	     if file_type = tty_file
	     then if substr(c32,1,1) = "s" | substr(c32,1,1) = "S"
		then do;
		     call print_error(109);
		     goto abort_label;
		     end;

	     conversion_label = bad_ni;

	     if precision_lng = 1 then temp(1) = convert(temp(1),substr(c32,1,n));
	     else d_temp(1) = convert(d_temp(1),substr(c32,1,n));

	     have_conversion_label = "0"b;
	     no_input = "0"b;
	     return;

bad_ni:	     if file_type ^= tty_file then goto incorrect_format_for_file_input;

     /* special case this message because an extra string  is printed */
	     call ioa_$nnl ("Incorrect numeric input in ^d, retype beginning with ^a^/?",
		get_line_number(), substr(c32, 1,  n));
	     call get_input(0);
	     goto num;
	     end;

	/* This procedure is called to read a string value from the file
	   specified by the global variable "fcb_pt".  The global variable
	   "p3" will point to the string block for the new value. */

string_input:  proc;

	     no_input = "1"b;

str:	     if buffer_pos >= buffer_length - 1 then return;

	     n = verify(substr(buffer,buffer_pos+1,buffer_length-buffer_pos),white_space);

	     if n = 0
	     then do;
		if file_type ^= tty_file then goto incorrect_format_for_file_input;

		call get_input(-110);
		goto str;
		end;

	     buffer_pos = buffer_pos + n;

	     if substr(buffer,buffer_pos,1) = """"
	     then do;

		/* pick up quoted string */

		buffer_pos = buffer_pos + 1;

		k = index(substr(buffer,buffer_pos,buffer_length-buffer_pos+1),"""");

		if k = 0
		then do;
si_bad:		     if file_type ^= tty_file then goto incorrect_format_for_file_input;

		     call ioa_$nnl ("Incorrect string input  in ^d, retype beginning with ^a^/?",
			get_line_number(), substr(buffer, buffer_pos-1, buffer_length-buffer_pos+1));
		     call get_input(0);
		     goto str;
		     end;

		n = k-1;
		end;
	     else do;

		/* pick up string terminated by a comma or NL */

		k = search(substr(buffer,buffer_pos,buffer_length-buffer_pos+1),comma_NL);

		if k = 0 then goto si_bad;

		n, k = k - 1;

		if n = 0
		then if substr(buffer,buffer_pos,1) = ","
		     then goto str;
		     else return;

		if mat_input
		then if substr(buffer,buffer_pos+k-1,2) = amp_NL
		     then if k > 1 then n = n - 1;
			else do;
			     call get_input(0);
			     goto str;
			     end;

		end;

	     call allocate_string;
	     p3 -> basic_string.value = substr(buffer,buffer_pos,n);

	     buffer_pos = buffer_pos + k;

	     no_input = "0"b;
	     end;

	/* This procedure is called to do a LINPUT operation on the file
	   specified by the global variable "fcb_pt".  The global variable
	   "p3" will be set to point to the string block for the line that
	   was read. */

linput:	     proc;

	     n = buffer_length - buffer_pos - 1;
	     if n < 0 then n = 0;

	     call allocate_string;

	     p3 -> basic_string.value = substr(buffer,buffer_pos+1,n);

	     buffer_pos = buffer_length;
	     end;

	/* The procedure is called when an 8 character string is to be
	   returned to the object program;  the value to be used is in
	   the global variable "c8". */

use_c8:	     proc;

	     n = 8;
	     call allocate_string;
	     p3 -> basic_string.value = c8;
	     call return_string;
	     end;

	/* This procedure is called to do the looping required to do the
	   matrix operation indicated by the argument "action_code".
	   Global variable PR2 points at the array dope. */

mat_loop:      proc(action_code);

dcl	     action_code fixed bin;

dcl	     (row,row_max,col,col_max,i) fixed bin,
	     data_pt ptr,
	     vector bit(1) aligned;

	     row_max = pr(2) -> current_bounds(1) - 1;
	     if row_max <= 0 then goto array_error;

	     col_max = pr(2) -> current_bounds(2);
	     if col_max = 0 then goto array_error;

	     if col_max < 0
	     then do;
		vector = "1"b;
		col_max = 1;
		i = 1;

		if action_code <= 2
		then if a_reg = 0
		     then row_max = pr(2) -> original_bounds(1) - 1;
		end;
	     else do;
		vector = "0"b;
		col_max = col_max - 1;
		i = col_max + 2;
		end;

	     data_pt = pr(2) -> array_dope.data;

	     do row = 1 to row_max;
		do col = 1 to col_max;

		     goto mat(action_code);

		     /* numeric input */

mat(1):		     call numeric_input;

		     if no_input
		     then do;
			if vector & a_reg = 0
			then do;
			     pr(2) -> current_bounds(1) = number_read + 1;
			     return;
			     end;

			do while(no_input);
			     call get_input(-107);
			     call numeric_input;
			     end;
			end;

		     number_read = number_read + 1;

		     data_pt -> float_bin(i) = temp(1);
		     goto next_mat;

		     /* string input */

mat(2):		     call string_input;

		     if no_input
		     then do;
			if vector & a_reg = 0
			then do;
			     pr(2) -> current_bounds(1) = number_read + 1;
			     return;
			     end;

			do while(no_input);
			     call get_input(-107);
			     call string_input;
			     end;
			end;

		     call deallocate_string(addr(data_pt -> bit_word(i)));

		     number_read = number_read + 1;

		     data_pt -> bit_word(i) = rel(p3);
		     goto next_mat;

		     /* numeric print */

mat(3):		     temp(1) = data_pt -> float_bin(i);
		     call numeric_print;

		     call mat_print_format_check;
		     goto next_mat;

		     /* string print */

mat(4):		     p1 = get_string_ptr(addr(data_pt -> bit_word(i)));
		     call string_print;

		     call mat_print_format_check;
		     goto next_mat;

		     /* numeric data read */

mat(5):		     if numeric_data.start >= numeric_data.finish then goto out_of_data;

		     data_pt -> float_bin(i) = text_base_ptr -> float_bin(numeric_data.start);

		     numeric_data.start = numeric_data.start + 1;
		     goto next_mat;

		     /* string data read */

mat(6):		     if string_data.start >= string_data.finish then goto out_of_data;

		     call deallocate_string(addr(data_pt -> bit_word(i)));

		     p1 = addr(text_base_ptr -> bit_word(text_base_ptr -> fix_bin(string_data.start)));
		     n = length(p1 -> based_vs);

		     call allocate_string;
		     p3 -> basic_string.value = p1 -> based_vs;

		     data_pt -> bit_word(i) = rel(p3);

		     string_data.start = string_data.start + 1;
		     goto next_mat;

		     /* numeric read */

mat(7):		     call numeric_read;
		     data_pt -> float_bin(i) = temp(1);
		     goto next_mat;

		     /* string read */

mat(8):		     call deallocate_string(addr(data_pt -> bit_word(i)));

		     call string_read;
		     data_pt -> bit_word(i) = rel(p3);
		     goto next_mat;

		     /* numeric write */

mat(9):		     temp(1) = data_pt -> float_bin(i);
		     call numeric_write;
		     goto next_mat;

		     /* string write */

mat(10):		     p1 = get_string_ptr(addr(data_pt -> bit_word(i)));
		     call string_write;
		     goto next_mat;

		     /* linput */

mat(11):		     call deallocate_string(addr(data_pt -> bit_word(i)));

		     call check_input;	/* get next line */
		     call linput;

		     data_pt -> bit_word(i) = rel(p3);
		     goto next_mat;

		     /* numeric print using */

mat(12):		     temp(1) = data_pt -> float_bin(i);
		     call print_using_numeric;
		     call mat_print_using_check;
		     goto next_mat;

		     /* string print using */

mat(13):		     p1 = get_string_ptr(addr(data_pt -> bit_word(i)));
		     call print_using_string;
		     call mat_print_using_check;
		     goto next_mat;

		     /* set string matrix to nul */

mat(14):		     call deallocate_string(addr(data_pt -> bit_word(i)));
		     data_pt -> bit_word(i) = "0"b;
		     goto next_mat;

		     /* mat a$ = b$ */

mat(15):		     pr(3) = addr(data_pt -> bit_word(i));
		     pr(1) = addr(p4 -> bit_word(i));
		     call string_assign;
		     goto next_mat;

next_mat:		     i = i + 1;
		     end;

		if ^ vector then i = i + 1;
		end;

mat_print_format_check: proc;

		if col ^= col_max then call mat_print_format;
		else if vector
		     then if row ^= row_max
			then call mat_print_format;
			else call print_new_line;
		     else call print_new_line;

		end;

mat_print_format:   proc;

		if a_reg = 0 then call print_new_line;
		else if a_reg = 1
		     then call tab(divide(line_pos + 15,15,17,0)*15);

		end;

mat_print_using_check: proc;

		if col = col_max
		then if ^ vector
		     then do;
			call print_new_line;
			pu_pos = 0;
			end;

		end;

	     end;

	/* This procedure is called at the end of an INPUT operation on
	   the file specified by the global variable "fcb_pt".  It
	   verifies that no unexpected data values were provided. */

end_input:     proc;

	     if buffer_pos < buffer_length
	     then if verify(substr(buffer,buffer_pos+1,buffer_length-buffer_pos-1),", ") ^= 0
		then call print_error(108);
     
	     buffer_pos = buffer_length;
	     end;

	/* This procedure writes its string argument, a character at a
	   time, into the file indicated by the global variable "fcb_pt". */

put_string:    proc(s);

dcl	     s char(*) aligned;

dcl	     si fixed bin;

	     do si = 1 to length(s);
		call put_char(substr(s,si,1));
		end;

	     end;

	/* This procedure writes a single character into the print buffer
	   of the file specified by the global variable "fcb_pt". */

put_char:      proc(c);

dcl	     c char(1) aligned;

	     if buffer_pos = buffer_size then call force_buffer;

	     if margin ^= 0
	     then if line_pos = margin
		then call print_new_line;

	     line_pos = line_pos + 1;

	     buffer_pos = buffer_pos + 1;
	     substr(buffer,buffer_pos,1) = c;

	     end;


	/* This procedure is called to identify the next field in a
	   PRINT USING string;  the argument indicates if this is the
	   end of the PRINT USING operation.  Data about the field that
	   was found is left in the global variables "field_length", "field_start",
	   "precision", "scale", "exp_length", "left_just", and "right_just".
	   Any characters that precede the start of the field are written
	   into the output buffer of the file specified by global variable
	   "fcb_pt". */

get_next_field: proc(end_scan);

dcl	     end_scan bit(1) aligned;

dcl	     here_before bit(1);

	     here_before = "0"b;

	     field_length,
	     field_start,
	     precision,
	     scale,
	     exp_length = 0;

	     string(print_using_bits) = "0"b;

next_char:     pu_pos = pu_pos + 1;

	     if pu_pos > pu_length
	     then do;
		if field_start ^= 0 then goto end_field;

		if end_scan then return;

		if here_before then goto print_using_error;

		here_before = "1"b;
		call print_new_line;
		pu_pos = 0;
		goto next_char;
		end;

	     goto case(index("<>$+-#^.",substr(pu_string,pu_pos,1)));

	     /* not special character */

case(0):	     if field_start = 0 then call put_char(substr(pu_string,pu_pos,1));
	     else field_length = field_length + 1;

	     goto next_char;

	     /* < */

case(1):	     if field_start ^= 0 then goto end_field;

	     left_just = "1"b;

case1a:	     field_start = pu_pos;
	     field_length = field_length + 1;
	     goto next_char;

	     /* > */

case(2):	     if field_start ^= 0 then goto end_field;

	     right_just = "1"b;
	     goto case1a;

	     /* $ */

case(3):	     if field_start ^= 0 then goto end_field;

	     have_dollar = "1"b;

	     field_start = pu_pos;
	     field_length = field_length + 1;

	     /* make sure $ is followed by + or - */

	     if pu_pos = pu_length then goto print_using_error;

	     if substr(pu_string,pu_pos+1,1) = "+" then have_plus = "1"b;
	     else do;
		have_minus = "1"b;		/* - is assumed when there is no control */
		if substr(pu_string,pu_pos+1, 1) ^= "-" then go to next_char;
		end;

	     pu_pos = pu_pos + 1;

	     field_length = field_length + 1;
	     goto next_char;

	     /* + */

case(4):	     if field_start ^= 0 then goto end_field;

	     have_plus = "1"b;
	     goto case1a;

	     /* - */

case(5):	     if field_start ^= 0 then goto end_field;

	     have_minus = "1"b;
	     goto case1a;

	     /* # */

case(6):	     if exp_length ^= 0 then goto end_field;

	     if field_start = 0 then goto print_using_error;

	     field_length = field_length + 1;
	     precision = precision + 1;

	     if have_decimal then scale = scale + 1;
	     goto next_char;

	     /* ^ */

case(7):	     if field_start = 0 then goto print_using_error;

	     exp_length = exp_length + 1;
	     field_length = field_length + 1;
	     goto next_char;

	     /* . */

case(8):	     if field_start = 0 then call put_char(ch);
	     else do;
		if have_decimal then goto print_using_error;

		have_decimal = "1"b;
		field_length = field_length + 1;
		end;

	     goto next_char;

end_field:     if exp_length ^= 0
	     then do;
		if exp_length ^= 5 then goto print_using_error;
		have_exp = "1"b;
		end;

	     pu_pos = pu_pos - 1;
	     end;

	/* This procedure is called to put out the numeric value in the
	   global variable "temp(1)" on file specified by global variable
	   "fcb_pt" according to the next field in the PRINT USING string.
	   The "size" condition is handled by setting the global label
	   variable "size_label" which is recognized by the default
	   handler;  the label is reset after the conversion by setting
	   its first word to zero. */

print_using_numeric: proc;

dcl	     zero_surpression bit(1),
	     exp fixed bin,
	     float_sign aligned char(1);

dcl	     1 decimal_value	based(addr(c64)) aligned,
	     2 sign		char(1) unal,
	     2 digit(precision)	char(1) unal,
	     2 skip		bit(1) unal,
	     2 exponent		fixed bin(7) unal;

	     call get_next_field("0"b);

	     if left_just then goto print_using_error;
	     if right_just then goto print_using_error;

	     if scale > 38 then goto punt;

	     if exp_length = 0
	     then do;

		/* f format */

		if have_minus
		then if temp(1) >= 0
		     then precision = precision + 1;

		if precision = 0 then goto punt;

		size_label = punt;

		call assign_round_(addr(c64),18,fixed(scale * 1000000000000000000b + precision,35),
		 addr(temp(1)),6,27);

		have_size_label = (36)"0"b;
		end;
	     else do;

		/* e format, we assume the following conversion
		   produces a left justified result */

		if precision = 0 then precision = 1;

		call assign_round_(addr(c64),20,precision,addr(temp(1)),6,27);

		if temp(1) = 0 then exp = 0;
		else exp = exponent + scale;
		end;

	     zero_surpression = ^ have_exp;

	     digit_count = 0;
	     digit_pos = 0;

	     do field_pos = field_start to field_start+field_length - 1;
		ch = substr(pu_string,field_pos,1);
		goto case(index("$+-#^.",ch));

case(0):		if zero_surpression then ch = " ";
		goto place;

		/* $ */

case(1):		goto next;

		/* + */

case(2):		float_sign = decimal_value.sign;

		if have_exp then call put_char(float_sign);

		goto next;

		/* - */

case(3):		if temp(1) < 0 then goto case(2);

		float_sign = " ";

		if have_exp
		then do;
		     call put_char(float_sign);
		     goto next;
		     end;

		/* # */

case(4):		digit_pos = digit_pos + 1;
		ch = digit(digit_pos);

		if zero_surpression
		then if ch ^= "0" | digit_pos = precision - scale | have_exp
		     then call end_surpression;
		     else ch = " ";
		else digit_count = digit_count + 1;

		if digit_count > 8 then ch = "?";

		goto place;

		/* ^ */

case(5):		call put_string(" E");

		if abs(exp) < 10
		then do;
		     fixed_dec_1 = convert(fixed_dec_1,exp);
		     call put_string(fixed_dec_1_overlay);
		     call put_char(" ");
		     end;
		else do;
		     fixed_dec_2 = convert(fixed_dec_2,exp);
		     call put_string(fixed_dec_2_overlay);
		     end;

		field_pos = field_pos + 4;
		goto next;

		/* . */

case(6):		if zero_surpression
		then do;
		     call end_surpression;
		     if float_sign = " " then call put_char("0");
		     end;

place:		call put_char(ch);

next:		end;

		return;

punt:		have_size_label = (36)"0"b;

		do field_pos = field_start to field_start+field_length - 1;
		     ch = substr(pu_string,field_pos,1);

		     if index("$+-#^",ch) ^= 0 then ch = "*";

		     call put_char(ch);
		     end;


end_surpression:	proc;

		if have_dollar then call put_char("$");

		if float_sign ^= " " then call put_char(float_sign);

		zero_surpression = "0"b;
		end;

	     end;

	/* This procedure is called to output the string value specified by
	   the global pointer "p1" on the file specified by the global
	   variable "fcb_pt" according to the next field in the PRINT USING
	   string. */

print_using_string: proc;

dcl	     (n_spaces,s_pos) fixed bin;

	     call get_next_field("0"b);

	     if right_just
	     then do;
		n_spaces = precision + 1 - length(p1 -> based_vs);

		if n_spaces >= 0 then s_pos = 0;
		else s_pos = - n_spaces;
		end;
	     else if left_just
		then n_spaces, s_pos = 0;
		else goto print_using_error;

	     do field_pos = field_start to field_start + field_length - 1;
		ch = substr(pu_string,field_pos,1);

		if index("<>#",ch) ^= 0
		then if n_spaces > 0
		     then do;
			ch = " ";
			n_spaces = n_spaces - 1;
			end;
		     else do;
			s_pos = s_pos + 1;

			if s_pos > length(p1 -> based_vs) then ch = " ";
			else ch = substr(p1 -> based_vs,s_pos,1);
			end;

		call put_char(ch);
		end;

	     end;

	/* This procedure is called to resignal the quit condition because
	   a quit occurred while quits were inhibited */

signal_quit:   proc;

dcl	     quit condition;

	     had_quit = "0"b;
	     signal quit;

	     end;


	/* This procedure is called to convert the value in the global variable
	   "temp(1)" from float binary(27) to the appropriate string representation
	   in I, F, or E format according to the rules of the language;
	   the converted value is placed in the global variable "ans". */

d_convert_number: proc;
     
dcl	     abs_value float bin(63),
	     (k,j,ndigits,num_size) fixed bin,
	     fixed_dec_value fixed dec(9),
	     exp fixed bin;
     
dcl	     1 c64_overlay aligned based(addr(c64)),
	     2 sign	char(1) unaligned,
	     2 digits	char(num_size) unaligned,
	     2 skip	bit(1) unaligned,
	     2 exponent	fixed bin(7) unaligned;
     
dcl	     fixed_digits char(10) aligned based(addr(fixed_dec_value));

	     if d_temp(1) = 0
	     then do;
		ans = " 0";
		return;
		end;
     
	     abs_value = abs(d_temp(1));
     
	     if d_temp(1) < 0 then ans = "-"; else ans = " ";
     
	     if abs_value < 134217728	/* 2 ** 27 */
	     then if float(fixed(abs_value)) = abs_value
		then do;
     
		     /* integer format */
     
		     fixed_dec_value = convert(fixed_dec_value,abs_value);
     
		     k = verify(substr(fixed_digits,2),"0");
		     ans = ans || substr(fixed_digits,k+1);
		     return;
		     end;
     
	     /* we assume that the following conversion is ROUNDED
	        and normalized to the left */
     
	     num_size = number_length;		/* copy for faster accessing */
	     call assign_round_(addr(c64),20,num_size,addr(d_temp(1)),8,63);
     
	     k = verify(reverse(digits),"0");
	     ndigits = num_size - k + 1;
     
	     exp = exponent + k - 1;
     
	     if exp >= 0
	     then do;

		if (exp + ndigits) = num_size
		then do;

		     /* due to rounding integer is closest approximation */
		     /* type 1234560 */

		     ans = ans || substr(digits,1,ndigits);

		     ans = ans || ".";		/* indicate integer is approximation */
		     return;
		     end;

		/* exponential format */

e_format:		ans = ans || substr(digits,1,1);
		ans = ans || ".";
		ans = ans || substr(digits,2,ndigits-1);
		ans = ans || " E";

		exp = exp + ndigits - 1;
     
		if abs(exp) < 10
		then do;
		     fixed_dec_1 = convert(fixed_dec_1,exp);
		     ans = ans || fixed_dec_1_overlay;
		     end;
		else do;
		     fixed_dec_2 = convert(fixed_dec_2,exp);
		     ans = ans || fixed_dec_2_overlay;
		     end;
     
		return;
		end;
     
	     j = ndigits + exp;
     
	     if j <= 0
	     then do;
		if ndigits - j > num_size then goto e_format;	/* type .0123456 */
		/* type .000123 */
     
		ans = ans || "0.";
		if j ^= 0 then ans = ans || substr("0000000000000000000",1,abs(j));
		ans = ans || substr(digits,1,ndigits);
		end;
	     else do;
		/* type 1.23456 */
		ans = ans || substr(digits,1,j);
		ans = ans || ".";
		ans = ans || substr(digits,j+1,ndigits-j);
		end;
     
	     end;

	     /* This function converts the BASIC string specified by pr(1)
	        to a numeric value in temp(1).  "1"b is returned if no
	        error was found and "0"b is returned if the string was
	        erroneous.  The conversion is attempted twice;  if the
	        first attempt fails, we try again with all white space removed
	        from the string.  This logic attempts to optimize the
	        simple cases that do not have embedded white space. */

d_convert_string: proc returns(bit(1) aligned);

dcl	     good_string bit(1) aligned;

	     p1 = get_string_ptr(pr(1));
	     good_string = "0"b;

	     conversion_label = first_error;
	     d_temp(1) = convert(d_temp(1),p1 -> based_vs);

ok:	     good_string = "1"b;

done:	     have_conversion_label = (36)"0"b;
	     return(good_string);

	     /* had error first time, try again if string contains white space */

first_error:   if search(p1 -> based_vs,white_space) = 0 then goto done;

	     conversion_label = done;

		begin;

dcl		copy char(length(p1 -> based_vs)),
		(i,j) fixed bin;

		copy = "";
		j = 0;

		do i = 1 to length(p1 -> based_vs);
		     if index(white_space,substr(p1 -> based_vs,i,1)) = 0
		     then do;

			/* current char not white space, copy it */

			j = j + 1;
			substr(copy,j,1) = substr(p1 -> based_vs,i,1);
			end;
		     end;

		d_temp(1) = convert(d_temp(1),copy);
		end;

	     goto ok;
	     end;

	/* This procedure writes the value in the global variable "temp(1)"
	   into the next position in the RANDOM NUMERIC file specified
	   by the global variable "fcb_pt".  An endfile is generated if the
	   max length of the file is exceeded. */

d_numeric_write: proc;

	     call iox_$put_chars(seg_pt, addr(d_temp(1)), 8, code);

	     if code ^= 0 then goto end_of_file;

	     end;

	/* This procedures sets the global variable "temp(1)" to the value
	   in the next position in the RANDOM NUMERIC file specified by
	   the global variable "fcb_pt". */

d_numeric_read:  proc;

	     call iox_$get_chars(seg_pt, addr(d_temp(1)), 8, buff_size, code);

	     if code ^= 0 then goto end_of_file;

	     end;

	/* This procedure is called to do the looping required to do the
	   matrix operation indicated by the argument "action_code".
	   Global variable PR2 points at the array dope. */

d_mat_loop:      proc(action_code);

dcl	     action_code fixed bin;

dcl	     (row,row_max,col,col_max,i) fixed bin,
	     data_pt ptr,
	     vector bit(1) aligned;

	     row_max = pr(2) -> current_bounds(1) - 1;
	     if row_max <= 0 then goto array_error;

	     col_max = pr(2) -> current_bounds(2);
	     if col_max = 0 then goto array_error;

	     if col_max < 0
	     then do;
		vector = "1"b;
		col_max = 1;
		i = 1;

		if action_code <= 2
		then if a_reg = 0
		     then row_max = pr(2) -> original_bounds(1) - 1;
		end;
	     else do;
		vector = "0"b;
		col_max = col_max - 1;
		i = col_max + 2;
		end;

	     data_pt = pr(2) -> array_dope.data;

	     do row = 1 to row_max;
		do col = 1 to col_max;

		     goto mat(action_code);

		     /* numeric input */

mat(1):		     call numeric_input;

		     if no_input
		     then do;
			if vector & a_reg = 0
			then do;
			     pr(2) -> current_bounds(1) = number_read + 1;
			     return;
			     end;

			do while(no_input);
			     call get_input(-107);
			     call numeric_input;
			     end;
			end;

		     number_read = number_read + 1;

		     data_pt -> double_float_bin(i) = d_temp(1);
		     goto next_mat;

		     /* string input */

mat(2):		     call string_input;

		     if no_input
		     then do;
			if vector & a_reg = 0
			then do;
			     pr(2) -> current_bounds(1) = number_read + 1;
			     return;
			     end;

			do while(no_input);
			     call get_input(-107);
			     call string_input;
			     end;
			end;

		     call deallocate_string(addr(data_pt -> double_bit_word(i)));

		     number_read = number_read + 1;

		     data_pt -> double_bit_word(i) = rel(p3);
		     goto next_mat;

		     /* numeric print */

mat(3):		     d_temp(1) = data_pt -> double_float_bin(i);
		     call numeric_print;

		     call mat_print_format_check;
		     goto next_mat;

		     /* string print */

mat(4):		     p1 = get_string_ptr(addr(data_pt -> double_bit_word(i)));
		     call string_print;

		     call mat_print_format_check;
		     goto next_mat;

		     /* numeric data read */

mat(5):		     if numeric_data.start >= numeric_data.finish then goto out_of_data;

		     data_pt -> double_float_bin(i) = addr(text_base_ptr -> float_bin(numeric_data.start)) -> double_float_bin(0);

		     numeric_data.start = numeric_data.start + 2;
		     goto next_mat;

		     /* string data read */

mat(6):		     if string_data.start >= string_data.finish then goto out_of_data;

		     call deallocate_string(addr(data_pt -> double_bit_word(i)));

		     p1 = addr(text_base_ptr -> bit_word(text_base_ptr -> fix_bin(string_data.start)));
		     n = length(p1 -> based_vs);

		     call allocate_string;
		     p3 -> basic_string.value = p1 -> based_vs;

		     data_pt -> double_bit_word(i) = rel(p3);

		     string_data.start = string_data.start + 1;
		     goto next_mat;

		     /* numeric read */

mat(7):		     call d_numeric_read;
		     data_pt -> double_float_bin(i) = d_temp(1);
		     goto next_mat;

		     /* string read */

mat(8):		     call deallocate_string(addr(data_pt -> double_bit_word(i)));

		     call string_read;
		     data_pt -> double_bit_word(i) = rel(p3);
		     goto next_mat;

		     /* numeric write */

mat(9):		     d_temp(1) = data_pt -> double_float_bin(i);
		     call d_numeric_write;
		     goto next_mat;

		     /* string write */

mat(10):		     p1 = get_string_ptr(addr(data_pt -> double_bit_word(i)));
		     call string_write;
		     goto next_mat;

		     /* linput */

mat(11):		     call deallocate_string(addr(data_pt -> double_bit_word(i)));

		     call check_input;	/* get next line */
		     call linput;

		     data_pt -> double_bit_word(i) = rel(p3);
		     goto next_mat;

		     /* numeric print using */

mat(12):		     d_temp(1) = data_pt -> double_float_bin(i);
		     call d_print_using_numeric;
		     call mat_print_using_check;
		     goto next_mat;

		     /* string print using */

mat(13):		     p1 = get_string_ptr(addr(data_pt -> double_bit_word(i)));
		     call print_using_string;
		     call mat_print_using_check;
		     goto next_mat;

		     /* set string matrix to nul */

mat(14):		     call deallocate_string(addr(data_pt -> double_bit_word(i)));
		     data_pt -> double_bit_word(i) = "0"b;
		     goto next_mat;

		     /* mat a$ = b$ */

mat(15):		     pr(3) = addr(data_pt -> double_bit_word(i));
		     pr(1) = addr(p4 -> double_bit_word(i));
		     call string_assign;
		     goto next_mat;

next_mat:		     i = i + 1;
		     end;

		if ^ vector then i = i + 1;
		end;

mat_print_format_check: proc;

		if col ^= col_max then call mat_print_format;
		else if vector
		     then if row ^= row_max
			then call mat_print_format;
			else call print_new_line;
		     else call print_new_line;

		end;

mat_print_format:   proc;

		if a_reg = 0 then call print_new_line;
		else if a_reg = 1
		     then do;
			     tab_size = max(15,number_length+8);
			     call tab(divide(line_pos + tab_size, tab_size, 17, 0)*tab_size);
			     end;

		end;

mat_print_using_check: proc;

		if col = col_max
		then if ^ vector
		     then do;
			call print_new_line;
			pu_pos = 0;
			end;

		end;

	     end;

	/* This procedure is called to put out the numeric value in the
	   global variable "temp(1)" on file specified by global variable
	   "fcb_pt" according to the next field in the PRINT USING string.
	   The "size" condition is handled by setting the global label
	   variable "size_label" which is recognized by the default
	   handler;  the label is reset after the conversion by setting
	   its first word to zero. */

d_print_using_numeric: proc;

dcl	     zero_surpression bit(1),
	     exp fixed bin,
	     float_sign aligned char(1);

dcl	     1 decimal_value	based(addr(c64)) aligned,
	     2 sign		char(1) unal,
	     2 digit(precision)	char(1) unal,
	     2 skip		bit(1) unal,
	     2 exponent		fixed bin(7) unal;

	     call get_next_field("0"b);

	     if left_just then goto print_using_error;
	     if right_just then goto print_using_error;

	     if scale > 38 then goto punt;

	     if exp_length = 0
	     then do;

		/* f format */

		if have_minus
		then if d_temp(1) >= 0
		     then precision = precision + 1;

		if precision = 0 then goto punt;

		size_label = punt;

		call assign_round_(addr(c64),18,fixed(scale * 1000000000000000000b + precision,35),
		 addr(temp(1)),8,27);

		have_size_label = (36)"0"b;
		end;
	     else do;

		/* e format, we assume the following conversion
		   produces a left justified result */

		if precision = 0 then precision = 1;

		call assign_round_(addr(c64),20,precision,addr(temp(1)),8,27);

		if d_temp(1) = 0 then exp = 0;
		else exp = exponent + scale;
		end;

	     zero_surpression = ^ have_exp;

	     digit_count = 0;
	     digit_pos = 0;

	     do field_pos = field_start to field_start+field_length - 1;
		ch = substr(pu_string,field_pos,1);
		goto case(index("$+-#^.",ch));

case(0):		if zero_surpression then ch = " ";
		goto place;

		/* $ */

case(1):		goto next;

		/* + */

case(2):		float_sign = decimal_value.sign;

		if have_exp then call put_char(float_sign);

		goto next;

		/* - */

case(3):		if d_temp(1) < 0 then goto case(2);

		float_sign = " ";

		if have_exp
		then do;
		     call put_char(float_sign);
		     goto next;
		     end;

		/* # */

case(4):		digit_pos = digit_pos + 1;
		ch = digit(digit_pos);

		if zero_surpression
		then if ch ^= "0" | digit_pos = precision - scale | have_exp
		     then call end_surpression;
		     else ch = " ";
		else digit_count = digit_count + 1;

		if digit_count > number_length+2 then ch = "?";

		goto place;

		/* ^ */

case(5):		call put_string(" E");

		if abs(exp) < 10
		then do;
		     fixed_dec_1 = convert(fixed_dec_1,exp);
		     call put_string(fixed_dec_1_overlay);
		     call put_char(" ");
		     end;
		else do;
		     fixed_dec_2 = convert(fixed_dec_2,exp);
		     call put_string(fixed_dec_2_overlay);
		     end;

		field_pos = field_pos + 4;
		goto next;

		/* . */

case(6):		if zero_surpression
		then do;
		     call end_surpression;
		     if float_sign = " " then call put_char("0");
		     end;

place:		call put_char(ch);

next:		end;

		return;

punt:		have_size_label = (36)"0"b;

		do field_pos = field_start to field_start+field_length - 1;
		     ch = substr(pu_string,field_pos,1);

		     if index("$+-#^",ch) ^= 0 then ch = "*";

		     call put_char(ch);
		     end;


end_surpression:	proc;

		if have_dollar then call put_char("$");

		if float_sign ^= " " then call put_char(float_sign);

		zero_surpression = "0"b;
		end;

	     end;

	end;
