/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8060 cobol_idedsyn.pl1 Reformatted code to new Cobol standard.
                                                   END HISTORY COMMENTS */


/* Modified on 09/08/81 by FCH, [5.0-1], fix flagging for Validation-81, BUG501(SQ431,SG441) */
/* Modified on 07/16/81 by FCH, [4.4-3], DEFAULT FOR COMP IS DISPLAY does not work, phx10066(BUG494) */
/* Modified on 04/09/81 by FCH, [4.4-2], fix bugs in leveling for validation-81, BUG477 */
/* Modified on 10/22/80 by FCH, COBOL_SYNTAX_TRACE_ changed to cobol_syntax_trace_ */
/* Modified on 09/30/80 by FCH, [4.4-1], density is 6250 is supported, BUG447(TR7681) */
/* Modified on 07/17/80 by FCH, [4.3-1], ignore APPLY TEMP for external files */
/* Modified on 04/17/80 by FCH, [4.2-2], L-216 added (DYNAMIC phrase), level-6 consistancy */
/* Modified on 12/12/79 by MHD, [4.2-1], added action(78) and check(28) - leveling for SORT files */
/* Modified on 10/11/79 by MHD, [4.1-1], RERUN clause */
/* Modified on 09/10/79 by FCH, [4.0-9], set attach_options_info */
/* Modified on 08/28/79 by FCH, [4.0-8], fix lev diags for same area */
/* Modified on 08/24/79 by FCH, [4.0-7], fix ALSO HIGH-VALUE NC219 */
/* Modified on 06/18/79 by MHD, [4.0-6], appended to debug statement */
/* Modified on 05/17/79 by FCH, [4.0-6], debug statement */
/* Modified on 03/23/79 by FCH, [4.0-5], fix select statement flagging */
/* Modified on 03/21/79 by FCH, [4.0-4], fix file_table.detach setting */
/* Modified on 03/21/79 by FCH, [4.0-3], preattached implies no detach on close */
/* Modified on 03/13/79 by FCH, [4.0-2], set debug bit */
/* Modified on 03/13/79 by FCH, [4.0-1], preattached implies external and non-optional */
/* Modified on 01/09/79 by FCH, [3.0-7] , alt key chain */
/* Modified on 12/11/78 by RAL [3.0-6]. made seq default organization */
/* Modified on 12/05/78 by RAL, [3.0-5], added dupl_alt to indicate that file has duplicate keys */
/* Modified on 11/13/78 by RAL, [3.0-4],  added counting of alternate_keys in file_table */
/* Modified on 06/07/78 by RAL, [3.0-3], action(173) leveling diag 169 */
/* Modified on 03/30/78 by FCH, [3.0-2], set file_key.next_alt + other additions for alt record MR7.0 */
/* Mofified on 03/30/78 by FCH, [3.0-1], new action(75), duplicates clause, alt rec key */
/* Modified since Version 3.0 */








/* format: style3 */
cobol_idedsyn:
     proc;



	call cobol_ided (p1, n_reducs);

	fixed_common.cpl_files = "0"b;
	diag_num = 0;
	current_line = 3;				/* 2*5+5 */

	coll_seq = collate ();

/* initialize automatic data */

	zero = "000000000000000000";

	call alloc;

	error = " ";
	fixed_common.seg_limit = 1;
	kill_diag = 0;
	mod_num = 0;				/*[5.0-1]*/
	seg_limit = 0;
	nat_alf_size = 127;
	addr (indicators) -> bit36 = "0"b;
	samect = 0;
	samerecct = 0;
	mult_fil_no = 0;
	rerunclock = "0"b;
	remarksbit = "0"b;
	debugbit = "0"b;
	optional_file = "0"b;
	external_file = "0"b;
	previous_valid_fkeys = "0"b;
	implnm_bit = "0"b;
	ed_found = "0"b;
	console_name = "0"b;
	dec_is_com = fixed_common.dec_comma;
	fixed_common.dec_comma = "0"b;
	fixed_common.comp_defaults.comp_5 = "1"b;
	dpass_sw = "0"b;
	qual_sw = "0"b;				/* init value */
						/* initialize contradiction matrix for select clause */
	array (1) = "00011011111010110010"b;
	array (2) = "00011011111001010010"b;
	array (3) = "00000100000000001101"b;
	array (4) = "00000011110111110101"b;
	array (5) = "00000011110111111001"b;
	array (6) = "00000000000000000000"b;
	array (7) = "00000000000001010000"b;
	array (8) = "00000000000010100000"b;
	array (9) = "00000000000111110000"b;
	array (10) = "00000000000111100000"b;
	array (11) = "00000000000001100000"b;
	array (12) = "00000000000000000000"b;
	array (13) = "00000000000001100000"b;
	array (14) = "00000000000000110000"b;
	array (15) = "00000000000000010000"b;
	array (16) = "00000000000000000000"b;
	array (17) = "00000000000000000000"b;
	array (18) = "00000000000000000000"b;
	array (19) = "00010011110111111100"b;
	array (20) = "00000000000000000000"b;
	array (21) = "001111111111111111110"b;

/* initialize word_array table */

	word_array.word_size (1) = 6;
	word_array.word (1) = "assign";
	word_array.word_size (2) = 6;
	word_array.word (2) = "assign";
	word_array.word_size (3) = 12;
	word_array.word (3) = "organization";
	word_array.word_size (4) = 12;
	word_array.word (4) = "organization";
	word_array.word_size (5) = 12;
	word_array.word (5) = "organization";
	word_array.word_size (6) = 6;
	word_array.word (6) = "access";
	word_array.word_size (7) = 6;
	word_array.word (7) = "device";
	word_array.word_size (8) = 6;
	word_array.word (8) = "device";
	word_array.word_size (9) = 6;
	word_array.word (9) = "device";
	word_array.word_size (10) = 6;
	word_array.word (10) = "device";
	word_array.word_size (11) = 6;
	word_array.word (11) = "prefix";
	word_array.word_size (12) = 6;
	word_array.word (12) = "prefix";
	word_array.word_size (13) = 6;
	word_array.word (13) = "prefix";
	word_array.word_size (14) = 5;
	word_array.word (14) = "sysin";
	word_array.word_size (15) = 6;
	word_array.word (15) = "sysout";
	word_array.word_size (16) = 8;
	word_array.word (16) = "optional";
	word_array.word_size (17) = 12;
	word_array.word (17) = "relative key";
	word_array.word_size (18) = 10;
	word_array.word (18) = "record key";
	word_array.word_size (19) = 12;
	word_array.word (19) = "organization";
	word_array.word_size (20) = 9;
	word_array.word (20) = "keyed key";
	word_array.word_size (21) = 6;
	word_array.word (21) = "assign";

/*[4.0-6]*/
	if fixed_common.debug			/*[4.0-6]*/
	then do;
		right.line = 0;			/* sets up entry in table for mnemonic name "SWITCH-8" */
						/*[4.0-6]*/
		right.column = 15;			/*[4.0-6]*/
		right.name = "switch-8";		/*[4.0-6]*/
		addr (mnemonic_name.class) -> bit8 = "0"b;
						/*[4.0-6]*/
		mnemonic_name.class.switch_name = "1"b; /*[4.0-6]*/
		left.number = 8;			/*[4.0-6]*/
		call nm (addr (right), left.number);	/* switch8 to name table */

/* sets up entry in table for condition name "DEBUG-ON" */

/*[4.0-6]*/
		substr (switch_bits, left.num, 1) = "1"b;
						/*[4.0-6]*/
		addr (mnemonic_name.class) -> bit8 = "0"b;
						/*[4.0-6]*/
		mnemonic_name.class.switch_condition = "1"b;
						/*[4.0-6]*/
		mnemonic_name.on_status = "1"b;	/*[4.0-6]*/
		mnemonic_name.column = 30;		/* means nothing */
						/*[4.0-6]*/
		mnemonic_name.def_line = 0;		/* line is not actually in program */
						/*[4.0-6]*/
		mnemonic_name.name = "debug-on";	/*[4.0-6]*/
		mnemonic_name.name_size = length (mnemonic_name.name);
		mnemonic_name.size = mnemonic_name.name_size + type17_size;
						/*[4.0-6]*/
		mnemonic_name.iw_key = left.number;	/* see cobol_imp_word */
						/*[4.0-6]*/
		call buildnm;			/* puts the name in the table */
						/*[4.0-6]*/
	     end;

/* initialize diag_item structure */

	diag1_ptr = addr (diag_item);
	diag_item.type = 5;
	diag_item.run = 2;
	diag_item.replace = "0"b;
	diag_item.filler = "000000"b;

	diag2_ptr = addr (lev_diag_item);
	lev_diag_item.type = 5;
	lev_diag_item.size = 28;
	lev_diag_item.run = 9;

	defaults = "0"b;
	clause_num = 0;
	last_clause = 0;
	pcs.type = 0;
	char1_ptr = addr (char1);
	trace_ptr = addr (interp);
	tbit = fixed_common.syntax_trace;
	if tbit
	then call cobol_syntax_trace_$initialize_phase (trace_ptr, 1);
	call scan;				/* read first minpral item */

	go to loop;

alloc:
     proc;

	ft_ptr = addr (ft_build_area (1));
	file_table_size = size (file_table) * 4;

	name_ptr = addr (ft_build_area (1));
	mnemonic_name.name_size = 0;
	type17_size = size (mnemonic_name) * 4;

	fkey_ptr = addr (ft_build_area (1));
	file_key.name_size = 0;
	file_key_size = size (file_key) * 4;

	qual_ptr = addr (ft_build_area (1));
	qual_rec.size = 0;
	key_qual_size = size (qual_rec) * 4;

	alpha_ptr = addr (ft_build_area (1));
	alphabet_name.name_size = 0;
	alphabet_name_size = size (alphabet_name) * 4;

     end;




/*					*/
/*	syntax interpreter			*/
/*					*/

fail:
	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm2);
	current_line = current_line + 1;

loop:
	syntax_line_ptr = addr (syntax_table (current_line));
	go to test (syntax_line.t_type);

test (0):
	if reserved_word.type ^= 1
	then go to fail;
	if reserved_word.key ^= syntax_line.t_field
	then go to fail;

success:
	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm1);

ucon:
	if syntax_line.o_bit ^= " "
	then do;
		if syntax_line.o_bit > fixed_common.comp_level
		then call lev_diag (syntax_line.a_num, record.header.line, record.header.column);
		go to ret;
	     end;

	go to action (syntax_line.a_num);

test (1):
	go to check (syntax_line.t_field);		/* check routine test */

test (2):
	diag_num = syntax_line.t_field;		/* unconditional branch */
	act_num = syntax_line.a_num;

	if syntax_line.o_bit ^= " "
	then do;
		if syntax_line.o_bit > fixed_common.comp_level
		then do;
			mod_num = syntax_line.a_num;
			call lev_diag (diag_num, record.header.line, record.header.column);
		     end;

		diag_num = 0;
		act_num = 0;
	     end;

	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm1);

	go to action (act_num);

check (0):
	wnum = cobol_imp_word$imp_word (p2);

	if wnum = 0 | wnum ^= syntax_line.a_num
	then go to fail;

	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm1);

	go to ret;

ret:
action (0):
	if kill_diag ^= 0
	then kill_diag, diag_num = 0;
	else if diag_num ^= 0
	then call diag;

	if syntax_line.s_bit = "s"
	then call scan;

	current_line = syntax_line.s_exit;

	go to loop;

declare	tm1		fixed bin init (1),
	tm2		fixed bin init (2),
	tm3		fixed bin init (3),
	tm4		fixed bin init (4),
	tm5		fixed bin init (5);

declare	cobol_syntax_trace_$trace
			entry (ptr, fixed bin);
declare	cobol_syntax_trace_$initialize_phase
			entry (ptr, fixed bin);

declare	(syntax_line_ptr, trace_ptr)
			ptr;

declare	tbit		bit (1);
declare	(diag_num, kill_diag)
			fixed bin;

declare	1 interp,
	  2 current_line	fixed bin,
	  2 phase		fixed bin,
	  2 p2		ptr,
	  2 p1		ptr,
	  2 directory_ptr	ptr,
	  2 source_ptr	ptr;

declare	1 syntax_table	(0:10000) based (p1),
	  2 b1		fixed bin,
	  2 b2		fixed bin,
	  2 b3		fixed bin,
	  2 b4		fixed bin,
	  2 b5		fixed bin;


declare	1 syntax_line	based (syntax_line_ptr),
	  2 s_bit		char (1),
	  2 o_bit		char (1),
	  2 t_type	fixed bin,
	  2 t_field	fixed bin,
	  2 s_exit	fixed bin,
	  2 a_num		fixed bin;

diag:
     proc;

	if remarksbit = "1"b
	then return;

	diag_item.line = record.header.line;
	diag_item.column = record.header.column;
	diag_item.size = 25;
	diag_item.number = diag_num;
	diag_item.param_at_end = "0"b;

	call cobol_c_list (diag1_ptr);		/* issue diagnostic */

	diag_num = 0;
     end;

lev_diag:
     proc (diag_num, lin, col);

/*[4.4-2]*/
declare	(diag_num, lin, col)
			fixed bin;

/*[4.4-2]*/
	lev_diag_item.line = lin;			/*[4.4-2]*/
	lev_diag_item.column = col;
	lev_diag_item.number = diag_num;
	lev_diag_item.module = mod_num;

	call cobol_c_list (diag2_ptr);

	mod_num = 0;

     end;

scan:
     proc;

	do while ("1"b);

	     call cobol_swf_get (cobol_min1_fileno, min1_status, p2, mrcsz);

	     rw_ptr = p2;				/* set reserved word token structure. */
	     nlit_ptr = p2;				/* set numeric literal token structure. */
	     alit_ptr = p2;				/* set alphanumeric literal token structure */

	     if substr (min1_status, 17, 16) ^= "0000000000000000"b
	     then go to action (61);

	     if record.header.type ^= 6
	     then do;
		     if record.header.type ^= 5
		     then do;
			     dpass_sw = "0"b;
			     return;
			end;

		     if dpass_sw = "1"b
		     then dpass_sw = "0"b;
		     else do;
			     if remarksbit = "0"b
			     then call cobol_c_list (p2);

			     if message.body.info.replaces_token ^= "0"b
			     then do;
				     if ed_found = "0"b
				     then current_line = 1;
						/* 0*1+1 */
				     else current_line = 2;
						/* 1*5+5 */

				     go to loop;
				end;
			end;
		end;

	end;

     end;



/* CHECK ROUTINES */

alfnam:
check (1):					/* name of program collating sequence alphabet */
	call system_name (addr (left));

	if left.type = 0
	then go to fail;

	go to success;


system_name:
     proc (p);

declare	p		ptr,
	key		fixed bin;

declare	1 sys_name	based (p),
	  2 type		fixed bin,		/* 0 undefined */
						/* 1 user name */
						/* 2 switch name */
						/* 3 device name */
						/* 4 impl alpha name */
						/* 5 standard alpha name */
						/* 6 printer ctl word */
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 number	fixed bin,
	  2 num		fixed bin,
	  2 name		char (32) varying;

	sys_name.type = 0;
	sys_name.number = 0;
	sys_name.name = "";

	if reserved_word.type = 1
	then do;
		key = reserved_word.key;

		if key = 288
		then num = 1;			/* is_word("native") */
		else if key = 505
		then num = 2;			/* is_word("standard-1") */
		else if key = 208
		then num = 3;			/* is_word("standard-2") */
		else return;

		sys_name.type = 5;
		sys_name.number = num;
		sys_name.line = reserved_word.line;
		sys_name.column = reserved_word.column;
		return;
	     end;

	else if user_word.type ^= 8
	then return;
	sys_name.number = cobol_imp_word$imp_word (p2);
	sys_name.num = cobol_imp_word$switch_name (p2);

	if sys_name.num ^= 0
	then sys_name.type = 2;
	else do;
		sys_name.num = cobol_imp_word$device_name (p2);

		if sys_name.num ^= 0
		then sys_name.type = 3;
		else do;
			sys_name.num = cobol_imp_word$alphabet_name (p2);

			if sys_name.num ^= 0
			then sys_name.type = 4;
			else do;
				sys_name.num = cobol_imp_word$printer_control (p2);

				if sys_name.num ^= 0
				then sys_name.type = 6;
				else sys_name.type = 1;
			     end;

		     end;

	     end;


	sys_name.name = user_word.word;
	sys_name.line = user_word.line;
	sys_name.column = user_word.column;

     end;


clorder:
check (2):					/* check for improper clause ordering */
	if clause_order = 0
	then go to success;

	go to fail;



check (3):
	;
areaa:
	if record.column < 12
	then go to success;

	if fixed_common.comp_level < "3"
	then call lev_diag (133, record.header.line, record.header.column);

	go to fail;



check (4):
	;
asgn:						/* assumes ft_ptr set to correct file */
	if file_table.ifn ^= " "
	then go to success;

	go to fail;

check (5):
comptype:
	comp_type = cobol_imp_word$comp_type (p2);

	if comp_type ^= 0
	then go to success;

	comp_type = cobol_imp_word$disp_type (p2);

	if comp_type = 0
	then go to fail;

	comp_type = comp_type + 10;

	go to success;

/* is the current word the name of a file selected in the file-control paragraph? */

check (6):
	;
chckft:
	call check_ft;

	if res = 0
	then go to success;

	go to fail;

check_ft:
     proc;

/*[4.1-1]*/
/*  Changed to return res = 1 if an error  occurs.  IO_ERROR used to be  seperated */
/* from this procedure and set  error to "E" but error was never referenced.  Also  */
/* reorganized it a little to help readability */


	res = 0;

	if record.header.type = 8
	then if fixed_common.file_count ^= 0		/* fail then if no files selected */
	     then do;

		     com_io_key = filedescr_offsets (1);/*	get 1st file_table */

		     do while ("1"b);

			call cobol_vdwf_dget (cobol_com_fileno, com_status, file_ptr, common_recsize, com_io_key);

			if substr (com_status, 17, 16) ^= "0000000000000000"b
			then go to io_error;

			if user_word.word
			     = substr (file_ptr -> file_table.name, 1, file_ptr -> file_table.name_size)
			then return;

			if file_ptr -> file_table.next = "00000"
			then goto io_error;

			com_io_key = file_ptr -> file_table.next;

		     end;				/* do while */

		end;				/* then */

io_error:
	file_ptr = null ();
	res = 1;
	return;

     end check_ft;




comp_test:
check (7):					/* determine if computer not multics */
	if comp_num = 1 | comp_num = 7
	then go to success;

	go to fail;



dupdev:
check (8):					/* test for duplicate device name */
	if right.type = 3 & substr (dev_bits, right.num, 1)
	then go to fail;

	substr (dev_bits, right.num, 1) = "1"b;

	go to success;


dupsw:
check (9):					/* test for duplicate switch name */
	if substr (switch_bits, left.num, 1)
	then go to fail;

	substr (switch_bits, left.num, 1) = "1"b;

	go to success;

fileorg:
check (10):					/* check for legal file organization */
	file_org = 1;

	if reserved_word.type ^= 1
	then go to fail;

	key = reserved_word.key;

	if key = 597
	then file_org = 1;				/* is_word("sequential") */
	else if key = 223
	then file_org = 2;				/* is_word("indexed") */
	else if key = 167
	then file_org = 3;				/* is_word("relative") */
	else if key = 407
	then file_org = 4;				/* is_word("stream") */
	else if key = 423
	then file_org = 5;				/* is_word("ids-ii") */
	else if key = 416
	then file_org = 6;				/* is_word("keyed") */
	else go to fail;

	if file_org > 3 & fixed_common.comp_level ^= "5"
	then call lev_diag (157, record.header.line, record.header.column);

	go to success;



filequal:
check (11):					/* test for legal file qualifier before file organization */
	file_qual = cobol_imp_word$computer_name (p2);

	if file_qual ^= 0
	then go to success;

	fq = cobol_imp_word$file_org (p2);

	if fq <= 3
	then go to fail;

	file_qual = fq + 6;

	go to success;

/* is the current word different from previously selected file names? */

check (12):
	;
cknew:
	if fixed_common.file_count = 0
	then go to success;
	com_io_key = filedescr_offsets (1);		/* get 1st file_table */
	call cobol_vdwf_dget (cobol_com_fileno, com_status, file_ptr, common_recsize, com_io_key);

check12a:
	if user_word.word = substr (file_ptr -> file_table.name, 1, file_ptr -> file_table.name_size)
	then go to fail;

	if file_ptr -> file_table.next = "00000"
	then go to success;

	com_io_key = file_ptr -> file_table.next;	/* get next file_ptr -> file_table */
	call cobol_vdwf_dget (cobol_com_fileno, com_status, file_ptr, common_recsize, com_io_key);

	go to check12a;

switch_2:
check (13):
	call set_sw;



	go to success;




idparnm:
check (14):					/* determine id paragraph number */
	if reserved_word.type = 1
	then do;
		key = reserved_word.key;

		if key = 510
		then clause_num = 2;		/* is_word("author") */
		else if key = 554
		then clause_num = 3;		/* is_word("installation") */
		else if key = 528
		then clause_num = 4;		/* is_word("date-written") */
		else if key = 527			/* is_word("date-compiled") */
		then do;
			clause_num = 5;
			if fixed_common.comp_level < "3"
			then call lev_diag (3, record.header.line, record.header.column);
		     end;
		else if key = 594
		then clause_num = 6;		/* is_word("security") */
		else if key = 586			/* is_word("remarks") */
		then do;
			clause_num = 7;
			if fixed_common.comp_level < "5"
			then call lev_diag (152, record.header.line, record.header.column);
		     end;
		else go to fail;

		go to success;

	     end;

	go to fail;



in_dev:
check (15):					/* test for input device */
	key = cobol_imp_word$device_name (p2);

	if key = 1 | key = 3
	then go to success;

	go to fail;



out_dev:
check (16):					/* test for output device name */
	key = cobol_imp_word$device_name (p2);

	if key = 2 | key = 3
	then go to success;

	go to fail;


/* has the program name been stored in common? */

check (17):
	;
ckpnm:
	if fixed_common.prog_name ^= " "
	then go to success;

	go to fail;

is_dev:
check (18):
	if clause_num = 2
	then go to success;

	go to fail;

is_alf:
check (19):
	if clause_num = 3
	then go to success;

	go to fail;


/* is temp1 greater than zero, meaning current clause is not simple SAME AREA? */

check (20):
	;
cktemp1:
	if temp1 > 0
	then go to success;

	go to fail;

dupopt:
check (21):
	if sk_ind
	then go to fail;
	else go to success;

is_sw:
check (22):
	if clause_num = 1
	then go to success;

	go to fail;

/* is the currency sign literal valid? */

check (23):
	;
currlit:
	if record.type ^= 3 | alphanum_lit.lit_size ^= 1
	then go to fail;

	tempn1 =
	     index ("0123456789abcdefghijklmnopqrstuvwxyzABCDLPRSVXZ *+-,.;()""/=", substr (alphanum_lit.string, 1, 1));

	if tempn1 ^= 0
	then go to fail;

	go to success;

/* a) if lexical scan recognized a decimal-point clause, was the clause found in special-names?
   b) if lexical scan found no decimal-point clause, was the clause not found in special-names? */

check (24):
	;
decptok:
	if dec_is_com = "1"b & fixed_common.dec_comma = "0"b
	then go to fail;
	else go to success;
leftname:
check (25):					/* left hand name in special-names paragraph clause */
	call system_name (addr (left));

	if left.type = 0 | left.type = 5
	then go to fail;

	go to success;


/* is the current numeric literal greater than 1? */

oc_name:
check (26):					/* determine number of object computer */
	call computer_name;

	if comp_num = 0
	then go to fail;
	else obj_comp_num = comp_num;

	go to success;

rempar:
check (27):					/* determine if remarks paragraph used */
	if clause_num = 7
	then go to success;

	go to fail;

/*[4.2-1]*/
sortfile:
check (28):					/* check if file_name represents a sort file */
	if cobol_res_words$check_sort_list (alphanum_lit.string)
	then go to success;

	go to fail;

/* is the current item a valid implementor-name for use in an ASSIGN clause? */

check (29):
	;
implnm:
	dpass_sw = "1"b;

	if record.header.type ^= 8
	then go to fail;

	n = index (user_word.word, "-");

	if n = 0
	then do;
		file_table.device = 6;

		if user_word.length > 16
		then do;
			diag_num = 106;
			call diag;

			user_word.length = 16;
		     end;

		go to success;

	     end;

	if n = 1
	then go to fail;

	device_name_size = user_word.length - n;

	if n > 17
	then do;
		diag_num = 106;
		call diag;

		user_word.length = 16;
	     end;

	else user_word.length = n - 1;

	device_name = substr (user_word.word, n + 1, device_name_size);

	if device_name = "printer" | device_name = "PRINTER"
	then do;
		property (7) = "1"b;
		file_table.device = 1;
	     end;

	else if device_name = "card-reader" | device_name = "CARD-READER"
	then do;
		property (8) = "1"b;
		file_table.device = 2;
	     end;

	else if device_name = "card-punch" | device_name = "CARD-PUNCH"
	then do;
		property (9) = "1"b;
		file_table.device = 3;
	     end;

	else if device_name = "msd" | device_name = "MSD"
	then file_table.device = 4;

	else if device_name = "tape" | device_name = "TAPE"
	then do;
		property (10) = "1"b;
		file_table.device = 5;
	     end;

	else if device_name = "virtual" | device_name = "VIRTUAL"
	then file_table.device = 6;

	else if device_name = "preattached" | device_name = "PREATTACHED"
	then file_table.device = 7;

	else do;
		diag_num = 107;
		call diag;

		file_table.device = 6;
	     end;

	go to success;


/* is the current item a valid implementor-name for use to indicate the place where RERUN 
				information is to be stored? */

check (30):
	;
implnm1:						/*[4.1-1]*/
	if cobol_imp_word$imp_word (p2) = 1009		/* is it "checkpoint-file" */
						/*[4.1-1]*/
	then goto success;

	go to fail;

/* is current word an integer? */

check (31):
	;
integr:
	call integer;				/*[5.0-1]*/
	seg_limit = num_binary;
	if num_binary = 0
	then go to fail;
	else go to success;

integer:
     proc;

	num_binary = 0;


	if record.header.type ^= 2
	then return;
	if numeric_lit.integral = "0"b
	then return;
	if numeric_lit.sign ^= " "
	then return;
	if numeric_lit.literal = substr (zero, 1, numeric_lit.places)
	then return;

	call dtb;					/* converte current decimal string to binary value */

/* binary value is stored in num_binary fixed bin(24) field */

     end;

rightname:
check (32):					/* right hand name in special-names paragraph clause */
	call system_name (addr (right));

	if right.type = 0
	then go to fail;

	go to success;


/* if a key has been specified for the current file, is the type of key consistent with
the file's organization? */

check (33):
	;
keyok:						/* assumes ft_ptr set to correct file */
	if file_table.relative_key = "1"b
	then go to check33a;

	if file_table.organization = 3
	then go to success;

	go to fail;

check33a:
	if file_table.organization = 2
	then go to success;

	go to fail;

/* if the organization of the current file requires a key, has the key been specified? */

check (34):
	;
keyreqd:						/* assumes ft_ptr set to correct file */
	if file_table.organization = 2
	then go to check34a;
	if file_table.organization = 3
	then go to check34b;

	go to success;

check34a:
	if file_table.access <= 1
	then go to success;				/* key not required for sequential access */
	if file_table.relative_key = "1"b
	then go to success;

	go to fail;

check34b:
	if file_table.record_key
	then go to success;

	go to fail;				/* has the current file been named in a previous multiple file clause? */

check (35):
	;
multok:						/* assumes ft_ptr set to correct file */
	if file_ptr = null ()
	then do;
		diag_num = 101;
		call diag;
	     end;
	else if file_ptr -> file_table.mult_position_no ^= 0
	then do;
		file_ptr = null ();

		go to fail;
	     end;
	else temp1 = temp1 + 1;

	go to success;

sncl:
check (36):
	go to LT (left.type);

LT (0):						/* illegal */
	clause_num = 0;

	go to success;

LT (1):						/* user name */
	if right.type = 4 | right.type = 5
	then clause_num = 3;
	else clause_num = 0;

	go to success;

LT (2):						/* switch name */
	if right.type = 5
	then clause_num = 3;
	else clause_num = 1;

	go to success;

LT (3):						/* device name */
	if right.type = 5
	then clause_num = 3;
	else clause_num = 2;

	go to success;

LT (4):						/* implementor alphabet name */
	if right.type = 4 | right.type = 5
	then clause_num = 3;
	else clause_num = 0;

	go to success;

LT (5):						/* standard alphabet name */
	clause_num = 0;

	go to success;

LT (6):						/* printer control name */
	if right.type = 5
	then clause_num = 3;
	else clause_num = 2;

	go to success;

check (37):
figcon:
	if reserved_word.type = 1 & reserved_word.figcon
	then go to success;

	go to fail;

check (39):
	go to success;


check (40):
	;
switchnm:						/* is the current item a switch-name? */
	wnum = cobol_imp_word$switch_name (p2);

	if wnum = 0
	then go to fail;

	go to success;

tempint:
check (41):					/* check for legal integer in temp clause */
	if numeric_lit.type ^= 2 | ^numeric_lit.integral
	then go to fail;

	int_res = fixed (numeric_lit.literal);

	if int_res < 18 | int_res > 61
	then go to fail;

	go to success;


/* is the current numeric literal 1 through 49? */

check (42):
	;
smal50:
	if num_binary > 0 & num_binary < 50
	then go to success;

	go to fail;

/* has the current file been named previously in a SAME AREA clause? */

check (43):
	;
samefree:						/* legality test, same clause */
	if file_ptr = null ()
	then do;
		diag_num = 101;
		call diag;

		go to success;
	     end;
	else if same_type ^= 0
	then go to SM (same_type);

	go to fail;

SM (1):						/* same record area clause */
	if file_ptr -> file_table.same_rec_clause = 0
	then go to success;

	go to fail;

SM (2):						/* same sort area clause */
	if file_ptr -> file_table.same_sort_clause = 0
	then go to success;

	go to fail;

SM (3):						/* same sort-merge area clause */
	if file_ptr -> file_table.same_sort_clause = 0
	then go to success;
	go to fail;

SM (4):						/* same area clause */
	if file_ptr -> file_table.same_area_clause = 0
	then go to success;

	go to fail;

/* is the current item a special-name other than a switch? */

check (45):
	;
specnam:
	if record.header.type ^= 1
	then go to fail;
	if reserved_word.key = 197
	then go to success;				/* CONSOLE */
	if reserved_word.key = 281
	then go to success;				/* SYSIN */
	if reserved_word.key = 294
	then go to success;				/* SYSOUT */

	go to fail;

sc_name:
check (46):					/* determine number of source computer */
	call computer_name;

	if comp_num = 0
	then go to fail;
	else source_comp_num = comp_num;

	go to success;

computer_name:
     proc;

	comp_num = cobol_imp_word$computer_name (p2);

	if comp_num ^= 0
	then return;

	comp_num = cobol_imp_word$file_org (p2);

	if comp_num = 4
	then comp_num = 9;
	else comp_num = 0;

     end;

/* is temp1 equal to 1, meaning the current clause is a SaME RECORD AREA clause? */

check (47):
	;
temp1eq1:
	if temp1 = 1
	then go to success;

	go to fail;

/* is the current item a user word? */

check (48):
	;
usrwd:
	if record.type = 8
	then go to success;

	go to fail;

switch:
check (49):					/* test for unique switch name before on-off */
	if left.type ^= 2
	then go to fail;

	if substr (switch_bits, left.num, 1)
	then go to fail;

	substr (switch_bits, left.num, 1) = "1"b;
	call set_sw;

	go to success;

set_sw:
     proc;

	addr (mnemonic_name.class) -> bit8 = "0"b;

	mnemonic_name.class.switch_condition = "1"b;
	mnemonic_name.iw_key = left.number;

	if reserved_word.key = 134
	then mnemonic_name.on_status = "1"b;		/* is_word("ON") */
	else mnemonic_name.off_status = "1"b;		/* is_word("OFF") */

     end;

switch_1:
check (50):					/* test for unique switch name before mnemonic name */
	if left.type ^= 2 | right.type = 5
	then go to fail;

	if substr (switch_bits, left.num, 1)
	then go to fail;

	substr (switch_bits, left.num, 1) = "1"b;

	call set_sw;

	go to success;

/* is the current word an alphanumeric literal? */

check (51):
	;
alphanmlit:
	if record.type = 3
	then go to success;

	go to fail;


/* can recovery be made on the current word? */

check (52):
	;
recovword:
	if record.header.type ^= 1
	then go to fail;
	if reserved_word.ided_recovery = "1"b
	then go to success;

	go to fail;

check (53):
	;
orgqualok:					/* success if organization and organization qualifier are compatible */
	if file_table.organization = 2 & property (19) = "1"b
	then if file_table.org_qual = 6
	     then go to success;
	     else go to fail;
	if file_table.organization = 2 & property (19) = "0"b & file_table.org_qual = 6
	then go to fail;
	if file_table.organization = 3 & file_table.org_qual = 7
	then go to fail;
	if file_table.organization = 1 & file_table.org_qual = 5
	then go to fail;
	if file_table.org_qual < 100
	then go to success;
	if file_table.organization < 2
	then go to success;

	go to fail;

check (54):
	;
catusrwd:						/* Scan to bypass illegal character err diag */
	dpass_sw = "1"b;
	if record.header.type ^= 8
	then go to fail;
	if user_word.length > 200
	then go to fail;				/* catalogue name too large */

	go to success;

check (55):
	;
charst1:						/* set character string for ATTACH-OPTIONS */
	dpass_sw = "1"b;
	if record.header.type ^= 3
	then go to fail;
	if alphanum_lit.lit_size > 128
	then go to fail;

	go to success;

check (56):
	;
catalphalit:
	dpass_sw = "1"b;
	if alphanum_lit.type ^= 3
	then go to fail;
	if alphanum_lit.lit_size > 200
	then go to fail;
	file_table.cat_nm = alphanum_lit.string;

	go to success;

dupdef:
check (57):					/* check for duplicate clause */
	if ^substr (clause_bits, clause_num, 1)
	then go to success;

	go to fail;

denint:
check (58):
	call integer;

/*[4.4-1]*/
	if num_binary = 800 | num_binary = 1600 | num_binary = 6250
	then go to success;

	go to fail;

check (59):
ckintnm:
	if fixed_common.file_count = 0
	then go to success;

	com_io_key = filedescr_offsets (1);

	call cobol_vdwf_dget (cobol_com_fileno, com_status, file_ptr, common_recsize, com_io_key);

	do while ("1"b);

	     if user_word.word = substr (file_table.ifn, 1, file_table.ifn_size)
	     then go to fail;

	     if file_ptr -> file_table.next = "00000"
	     then go to success;

	     call cobol_vdwf_dget (cobol_com_fileno, com_status, file_ptr, common_recsize, com_io_key);
	     com_io_key = file_ptr -> file_table.next;
	end;



/* ACTION ROUTINES */
/* perform necessary initialization functions */

action (1):
	;
begrun:
	fixed_common.phase_name = "IDED20";
	fixed_common.dd_seg_size = 1048576;
	fixed_common.pd_seg_size = 1048576;
	fixed_common.object_sign = fixed_common.currency;
	name_ptr = addr (ft_build_area (1));		/* initialize mnemonic-name pointer */

	last_clause = 0;
	clause_order = 0;
	clause_bits = "0"b;

	go to ret;

action (2):					/* initialize for source computer paragraph */
	clause_bits = "0"b;
	last_clause = 0;
	clause_order = 0;

	go to ret;


action (3):					/* determine number of source computer clause */
	key = reserved_word.key;

	if key = 568
	then clause_num = 1;			/* is_word("memory") */
	else if key = 88
	then clause_num = 2;			/* is_word("debugging") */
	else if key = 604
	then clause_num = 3;			/* is_word("supervisor") */
	else clause_num = 0;

	go to ret;

action (4):					/* source computer clauses */
	if clause_num ^= 0
	then go to SC (clause_num);
	else go to ret;

SC (1):						/* memory size clause */
	go to dup_order;

SC (2):						/* debugging mode clause */
						/*[4.0-2]*/
	fixed_common.debug = "1"b;
	go to dup_order;

SC (3):						/* supervisor clause */
	go to dup_order;

action (5):					/* initialize for object computer paragraph */
	clause_bits = "0"b;
	last_clause = 0;
	clause_order = 0;

	obj_comp_name = 1;
	seg_lim = 0;
	alf_type = 0;




	go to ret;

action (6):					/* determine number of object computer clause */
	key = reserved_word.key;

	if key = 604
	then clause_num = 1;			/* is_word("SUPERVISOR") */
	else if key = 568
	then clause_num = 2;			/* is_word("MEMORY") */
	else if key = 587				/* is_word("SEQUENCE") */
	then do;
		clause_num = 3;
		call set_pcs_loc;
	     end;
	else if key = 595
	then clause_num = 4;			/* is_word("SEGMENT-LIMIT") */
	else if key = 509
	then clause_num = 5;			/* is_word("ASSIGN") */
	else if key = 196
	then clause_num = 6;			/* is_word("DATA") */
	else if key = 142
	then clause_num = 7;			/* is_word("PROCEDURE") */
	else clause_num = 0;

	go to ret;

set_pcs_loc:
     proc;

	pcs.line = reserved_word.line;
	pcs.column = reserved_word.column;

     end;

action (7):					/* execute object computer clause */
	if clause_num ^= 0
	then go to OC (clause_num);
	else go to ret;

OC (1):						/* supervisor_clause */
	fixed_common.supervisor = "1"b;

	go to dup_order;

OC (2):						/* memory clause */
	go to dup_order;

OC (3):						/* program collating sequence clause */
	pcs.type = alf_type;
	pcs.name = alf_name;
	pcs.num = alf_num;

	go to dup_order;

OC (4):						/* segment-limit clause */
	fixed_common.seg_limit = num_binary;

	go to dup_order;

OC (5):						/* assign clause */
	go to dup_order;

OC (6):						/* maximum data clause */
	fixed_common.dd_seg_size = num_binary;

	go to dup_order;

OC (7):						/* maximum procedure clause */
	fixed_common.pd_seg_size = num_binary;

	go to dup_order;

action (8):					/* program collating sequence clause found */
	clause_num = 3;

	go to ret;

/* store the name from PROGRAM-ID in common */

action (9):
	;

	if record.type = 2
	then fixed_common.prog_name = numeric_lit.literal;
	else fixed_common.prog_name = user_word.word;

	go to ret;				/* set on remarks bit to suppress any diags issued by lexical scan on comment-entries in ID */

action (10):
	;

	remarksbit = "1"b;

	go to ret;				/* set off the remarks bit */

action (11):
	;

	remarksbit = "0"b;

	go to ret;				/* set on DEBUGGING MODE indicators */

action (12):
	;

	temp1 = 4;
	debugbit = "1"b;
	fixed_common.debug = "1"b;

	go to ret;				/* store the segment limit integer in common */

action (13):					/* initialize for special names paragraph */
	clause_bits = "0"b;
	last_clause = 0;
	clause_order = 0;

	currsign = " ";
	objsign = " ";

	switch_bits = "0"b;
	dev_bits = "0"b;
	alph_bits = "0"b;

	go to ret;

action (14):					/* determine clause number for special-names paragraph */
	key = reserved_word.key;

	if key = 504
	then clause_num = 3;			/* is_word("ALPHABET") */
	else if key = 525
	then clause_num = 4;			/* is_word("CURRENCY") */
	else if key = 538				/* is_word("DECIMAL-POINT") */
	then do;
		clause_num = 5;
		dec_com = "0"b;
		obj_com = "0"b;
	     end;
	else clause_num = 0;

	go to ret;

action (15):
	clause_num = 0;
	last_clause = 0;
	clause_order = 0;

	go to ret;

action (16):
	dec_com = "1"b;
	obj_com = "1"b;

	go to ret;

action (17):
	obj_com = "1"b;

	go to ret;

action (18):
	;

	fixed_common.seg_limit = num_binary;

	go to ret;

action (19):
	currsign = alphanum_lit.string;

	go to ret;

action (20):
	objsign = currsign;

	go to ret;

action (21):					/* alphabet_name is alpha_def: initialization */
	call reset_alpha;
	clause_num = 3;
	call char_spec (addr (left_char_spec));
	if left_char_spec.type = 1
	then alphabet_name.loval_char = addr (left_char_spec.value) -> ch.ch4;
	else alphabet_name.loval_char = left_char_spec.char;

	if fixed_common.comp_level < "3"
	then call lev_diag (6, record.header.line, record.header.column);
	go to ret;

reset_alpha:
     proc;

declare	i		fixed bin;

	do i = 1 by 1 to 500;
	     ft_build_area (i) = 0;
	end;

	alphabet_name.def_line = user_word.line;
	alphabet_name.type = 40;

	do i = 0 by 1 to 511;
	     tran_tab (i) = 0;
	end;

	addr (nat_bits) -> bit512 = "0"b;
	ord_num = 0;
	call alf_ent;
	dup_alpha_value = "1"b;
	one_one_bit = "0"b;
	alf_range = 1;
	dup_alf_value = "0"b;
	high_value_value = 0;

     end;

alf_ent:
     proc;

	ord_num = 0;
	curr_ord_num = 0;
	ord_max = 0;

     end;

action (22):					/* type 17 name table entry: switch name */
	addr (mnemonic_name.class) -> bit8 = "0"b;
	mnemonic_name.class.switch_name = "1"b;

	call nm (addr (right), left.number);

	go to ret;

nm:
     proc (p, num);

declare	(L, num)		fixed bin,
	p		ptr;

declare	1 N		based (p),
	  2 type		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 number	fixed bin,
	  2 num		fixed bin,
	  2 name		char (32) varying;

	L = length (N.name);

	mnemonic_name.iw_key = num;
	mnemonic_name.size = L + type17_size;
	mnemonic_name.def_line = N.line;
	mnemonic_name.column = N.column;
	mnemonic_name.name_size = L;
	mnemonic_name.name = substr (N.name, 1, L);

	call buildnm;

     end;

action (23):					/* type 17 name table entry, switch condition name */
	mnemonic_name.size = user_word.length + type17_size;
	mnemonic_name.column = user_word.column;
	mnemonic_name.def_line = user_word.line;
	mnemonic_name.name_size = user_word.length;
	mnemonic_name.name = substr (user_word.word, 1, mnemonic_name.name_size);
	mnemonic_name.iw_key = left.number;

	call buildnm;

	go to ret;

buildnm:
     proc;

	mnemonic_name.type = 17;
	mnemonic_name.line = 0;
	mnemonic_name.string_ptr = null ();
	mnemonic_name.prev_rec = null ();
	mnemonic_name.alphabet_offset = 0;

	call cobol_vdwf_sput (cobol_name_fileno, name_status, name_ptr, mnemonic_name.size, name_key);

     end;


action (24):
	;
buildft:
	do i = 1 by 1 to 500;
	     ft_build_area (i) = 0;
	end;

	ft_ptr = addr (ft_build_area (1));
	temp4 = user_word.length + file_table_size;

	file_table.name_size = user_word.length;
	file_table.name = user_word.word;
	file_table.next = "00000";
	file_table.tape_device_key = "00000";
	file_table.add_cat_key = "00000";
	file_table.ifn = " ";
	file_table.file_id_info = "00000";
	file_table.retention_info = "00000";
	file_table.padding_char = " ";
	file_table.banner_char = "!";			/* ! = octal 41 */
	file_table.file_status_info = "00000";
	file_table.extra_status_info = "00000";
	file_table.cat_id_info = "00000";
	file_table.r_key_info = "00000";
	file_table.alt_key_info = "00000";
	file_table.rec_do_info = "00000";
	file_table.label_info = "00000";
	file_table.data_info = "00000";
	file_table.attach_options_info = "00000";
	file_table.replacement_info = "00000";
	file_table.report_info = "00000";
	file_table.linage_info = "00000";
	file_table.optional = optional_file;
	file_table.external = external_file;
	file_table.record_format = 0;
	file_table.label_format = 0;
	file_table.cat_nm = " ";

	file_table.ao_string = "00000";
	file_table.file_desc_1_offset = 0;		/* [3.0-2] */
	file_table.alternate_keys = 0;		/* [3.0-4] */
	file_table.dupl_alt = "0"b;			/* [3.0-5] */
	file_table.organization = 1;			/* seq default */
						/* [3.0-6] */
	file_table.om_string = " ";

	file_table.file_no = fixed_common.file_count + 1;
	file_table.code_set = 1;			/* set to default code set of EBCDIC */
	ft_size = temp4;				/* save file table size for replace_io */

	ignore_file = "0"b;

	go to ret;

emit_ft:
     proc;

/*[4.0-5]*/
dcl	(i, num)		fixed bin;

	fixed_common.file_count = fixed_common.file_count + 1;

	call cobol_vdwf_sput (cobol_com_fileno, com_status, ft_ptr, ft_size, common_key);

/* put default file table */

	if fixed_common.file_count < 21
	then fixed_common.filedescr_offsets (fixed_common.file_count) = common_key;

/* save file table address */

	if fixed_common.file_count > 1
	then do;

/*establish link from last file table to this file */

		call cobol_vdwf_dget (cobol_com_fileno, com_status, last_ft_ptr, common_recsize, last_prev_file_key);

		last_ft_ptr -> file_table.next = common_key;
						/* now linked */

		call cobol_vdwf_dput (cobol_com_fileno, com_status, last_ft_ptr, common_recsize, last_prev_file_key);

	     end;

	last_prev_file_key = common_key;		/* save current file table address for linking */

/*[4.0-5]*/
	do i = 1 by 1 to 10;

/*[4.0-5]*/
	     if source_pos.line (i) ^= 0
	     then do;

/*[4.0-5]*/
		     lev_diag_item.line = source_pos.line (i);
						/*[4.0-5]*/
		     lev_diag_item.column = source_pos.column (i);
						/*[4.0-5]*/
		     org = file_table.organization;

/*[4.2-1]*/
		     if sort_name = "1"b
		     then org = 6;

/*[4.0-5]*/
		     go to FT (i);

FT (1):
		     num = 113;
		     call LEV1;
		     go to FT1;			/* organization clause */
FT (2):
		     num = 117;
		     mod_num = 16;
		     LEV = "3";
		     go to FT1;			/* optional phrase */
FT (3):
		     num = 118;
		     call LEV2;
		     go to FT1;			/* reserve clause */
FT (4):
		     num = 188;
		     call LEV1;
		     go to FT1;			/* record key clause */
FT (5):
		     num = 126;
		     call LEV2;
		     go to FT1;			/* alt rec key clause */
FT (6):
		     num = 183;
		     call LEV1;
		     go to FT1;			/* select clause */
FT (7):
		     num = 184;
		     call LEV1;
		     go to FT1;			/* assign clause */
FT (8):
		     num = 185;

/*[4.2-2]*/
		     call LEV1;

/*[4.2-2]*/
		     if dynamic_acc
		     then do;
			     LEV_NUM = lev2_org (org);/* access clause */
						/*[4.2-2]*/
			     MOD_NUM = lev2_mod (org);/*[4.2-2]*/
			end;

/*[4.0-5]*/
		     go to FT1;

FT (9):
		     num = 186;
		     call LEV1;
		     go to FT1;			/* file status clause */
FT (10):
		     num = 187;
		     call LEV1;
		     go to FT1;			/* relative key clause */

FT1:						/*[4.0-5]*/
		     if LEV > fixed_common.comp_level
		     then do;

			     lev_diag_item.module = mod_num;
			     lev_diag_item.number = num;

			     call cobol_c_list (diag2_ptr);

/*[4.0-5]*/
			end;

		     mod_num = 0;			/*[4.0-5]*/
		end;

/*[4.0-5]*/
	end;

/*[4.2-2]*/
	if dynamic_acc				/*[4.2-2]*/
	then if LEV_NUM > fixed_common.comp_level	/*[4.2-2]*/
	     then do;
		     lev_diag_item.module = MOD_NUM;	/*[4.2-2]*/
		     lev_diag_item.number = 216;	/*[4.2-2]*/
		     lev_diag_item.line = dyn.line;	/*[4.2-2]*/
		     lev_diag_item.column = dyn.column;

/*[4.2-2]*/
		     call cobol_c_list (diag2_ptr);

/*[4.2-2]*/
		end;

     end;

LEV1:
     proc;

/*[4.0-5]*/
	mod_num = lev1_mod (org);
	LEV = lev1_org (org);

     end;						/*[4.0-5]*/
						/*[4.0-5]*/
LEV2:
     proc;

/*[4.0-5]*/
	mod_num = lev2_mod (org);
	LEV = lev2_org (org);

     end;						/*[4.0-5]*/
						/*[4.0-5]*/

action (25):					/* file_contol paragraph: execute clause */
	if clause_num ^= 0
	then go to FCC (clause_num);

	go to ret;

FCC (1):						/* assign clause */
	file_table.ifn_size = user_word.length;
	file_table.ifn = substr (user_word.word, 1, file_table.ifn_size);

	go to ret;

FCC (2):						/* organization clause */
	if file_org = 0
	then go to ret;

	file_table.org_qual = 4;			/* set default to multics */
	file_table.code_set = 1;

	go to FO (file_org);

FO (1):						/* sequential */
	property (3) = "1"b;
	file_table.organization = 1;

	if file_qual = 12				/* ibm-dos */
	then do;
		file_table.org_qual = 5;
		file_table.code_set = 4;
	     end;
	else if file_qual = 10			/* h-2000 */
	then do;
		file_table.org_qual = 6;
		file_table.code_set = 2;
	     end;
	else if file_qual = 13			/* ibm-os */
	then do;
		file_table.org_qual = 7;
	     end;

	go to FO1;

FO (2):						/* indexed */
	property (5) = "1"b;
	file_table.organization = 3;

	if file_qual = 8				/* level-64 */
	then do;
		file_table.org_qual = 3;
		file_table.code_set = 1;
	     end;
	else if file_qual = 12			/* ibm-dos */
	then do;
		file_table.org_qual = 5;
		file_table.code_set = 1;
	     end;

	go to FO1;

FO (3):						/* relative */
	property (4) = "1"b;
	file_table.organization = 2;

	if org_qual = 10				/* h-2000 */
	then do;
		file_table.org_qual = 6;
		file_table.code_set = 2;
	     end;
	else if org_qual = 12
	then do;
		file_table.org_qual = 5;
		file_table.code_set = 1;
	     end;

	go to FO1;

FO (4):						/* stream */
	file_table.organization = 5;

	go to FO1;

FO (5):						/* ids-ii */
	file_table.organization = 5;

	go to FO1;

FO (6):						/* keyed */
	property (19) = "1"b;
	file_table.organization = 2;

	go to FO1;

FO1:
	if file_qual = 15
	then do;
		file_table.org_qual = 1;
		file_table.code_set = 1;
	     end;

	go to ret;

FCC (3):						/* reserve clause */
	file_table.buffers = num_binary;

	go to ret;

FCC (4):						/* access clause */
	if file_acc ^= 0
	then go to FA (file_acc);

	go to ret;

FA (1):						/* sequential */
	file_table.access = 1;

	go to ret;

FA (2):						/* random */
	property (6) = "1"b;
	file_table.access = 2;

	go to ret;

FA (3):						/* dynamic */
	property (6) = "1"b;
	file_table.access = 3;

	go to ret;

FCC (5):						/* record key clause */
	rec_key = "1"b;

	go to ret;

FCC (6):						/* file status clause */
	go to ret;

FCC (7):						/* alternate key clause */
	go to ret;

FCC (8):						/* catalog name clause */
	go to ret;

FCC (9):						/* ssf, flr, vlr, bsn */
	if ssf_ind
	then do;
		property (12) = "1"b;
		file_table.record_prefix = 2;

	     end;

	if flr_ind
	then file_table.fixed_recs = "1"b;
	else if vlr_ind
	then file_table.variable_recs = "1"b;
	else if span_ind
	then file_table.spanned_recs = "1"b;

	if bsn_ind
	then file_table.bsn = "1"b;

	go to ret;

FCC (10):						/* process area */
	file_table.process_area = "1"b;

	go to ret;

FCC (11):						/* interchange */
	file_table.interchange = "1"b;

	go to ret;

FCC (12):						/* relative key clause */
	rel_key = "1"b;

	go to ret;

FCC (13):						/* no process area */
	file_table.process_area = "0"b;

	go to ret;

action (26):
	;

	ed_found = "1"b;

	go to ret;


action (27):					/* i-o-control: initialize */
	mult_fil_no = 0;
	clause_bits = "0"b;
	last_clause = 0;
	clause_order = 0;

	go to ret;

action (28):					/* i-o-control: set clause number */
	key = reserved_word.key;

	if key = 508
	then clause_num = 1;			/* is_word("apply") */
	else if key = 588
	then clause_num = 2;			/* is_word("rerun") */
	else if key = 593				/* id_word("same") */
						/*[5.0-1]*/
	then do;
		clause_num = 3;			/*[5.0-1]*/
		same_loc.line = record.header.line;	/*[5.0-1]*/
		same_loc.column = record.header.column; /*[5.0-1]*/
	     end;
	else if key = 570
	then clause_num = 4;			/* is_word("multiple") */
	else clause_num = 0;

	temp1 = 0;

	go to ret;

action (29):					/* file_control_control: access clause */
	rel_key = "0"b;
	rec_key = "0"b;

	key = reserved_word.key;

	if key = 597
	then file_acc = 1;				/* is_word("sequential") */
	else if key = 147
	then file_acc = 2;				/* is_word("random") */
	else if key = 169				/* is_word("dynamic") */
						/*[4.2-2]*/
	then do;
		file_acc = 3;			/*[4.2-2]*/
		dynamic_acc = "1"b;			/*[4.2-2]*/
		dyn.line = reserved_word.line;	/*[4.2-2]*/
		dyn.column = reserved_word.column;	/*[4.2-2]*/
	     end;

	else file_acc = 0;

	go to ret;

action (30):					/*[4.0-5]*/
	key = reserved_word.key;

/*[4.0-5]*/
	if key = 167				/*relative*/
						/*[4.0-5]*/
	then do;
		rel_key = "1"b;			/*[4.0-5]*/
		source_pos.line (10) = record.header.line;
						/*[4.0-5]*/
		source_pos.column (10) = record.header.column;
						/*[4.0-5]*/
	     end;					/*[4.0-5]*/
	else /*[4.0-5]*/
	     if key = 148				/*record*/
						/*[4.0-5]*/
	then do;
		rec_key = "1"b;			/*[4.0-5]*/
		source_pos.line (4) = record.header.line;
						/*[4.0-5]*/
		source_pos.column (4) = record.header.column;
						/*[4.0-5]*/
	     end;

	go to ret;

action (31):					/* file control paragraph: select clause */
	key = reserved_word.key;

	if key = 307
	then external_file = "1"b;			/* is_word("external") */
	else do;					/* is_word("optional") */
		optional_file = "1"b;
		source_pos.line (2) = record.header.line;
		source_pos.column (2) = record.header.column;
	     end;

	go to ret;

action (32):					/* indicate alternate record key */
	call enter_key (5);

	go to ret;

action (33):					/* file organization is indexed */
	file_org = 2;

	go to ret;

action (34):					/* vlr, flr, bsn, spanned */
	key = reserved_word.key;

	if key = 85
	then ssf_ind = "1"b;			/* is_word("ssf") */
	else if key = 272
	then flr_ind = "1"b;			/* is_word("flr") */
	else if key = 201
	then vlr_ind = "1"b;			/* is_word("vlr") */
	else if key = 413
	then bsn_ind = "1"b;			/* is_word("bsn") */
	else if key = 601
	then span_ind = "1"b;			/* is_word("spanned") */

	go to ret;

/* construct an entry in common for the current relative key name */

action (35):
	;

	property (17) = "1"b;			/* indicate relative key */
	file_table.relative_key = "1"b;
	file_table.address_format = 3;

	call enter_key (1);

	go to ret;

enter_key:
     proc (temp6);

declare	(temp6, temp4)	fixed bin;

	temp4 = user_word.length + file_key_size;
	fkey_ptr = addr (file_key_area);
	file_key.next = "00000";

/*[3.0-7]*/
	if temp6 = 5				/*[3.0-7]*/
	then file_key.next_alt = file_table.alt_key_info; /*[3.0-7]*/
	else file_key.next_alt = "00000";

	file_key.qual = "00000";			/*[3.0-7]*/
	addr (file_key.info) -> bit8 = "00000000"b;
	file_key.file_no = file_table.file_no;
	file_key.key_type = temp6;
	file_key.line = user_word.line;
	file_key.column = user_word.column;
	file_key.temp_seg = 0;
	file_key.temp_offset = 0;
	file_key.desc = " ";

	if user_word.type = 8
	then do;
		file_key.name_size = user_word.length;
		file_key.name = user_word.word;
	     end;
	else do;
		file_key.name_size = alphanum_lit.lit_size;
		file_key.name = alphanum_lit.string;
	     end;
	file_key_type = file_key.key_type;		/*for	check */
	common_recsize = temp4;			/* temp4 contains size of	file_key. */

	call cobol_vdwf_sput (cobol_com_fileno, com_status, fkey_ptr, common_recsize, common_key);

	if fixed_common.file_keys = "00000"
	then fixed_common.file_keys = common_key;
	else do;

		call cobol_vdwf_dget (cobol_com_fileno, com_status, work_ptr, common_recsize,
		     fixed_common.last_file_key);	/*link key rec */

		work_ptr -> file_key.next = common_key; /* now linked */

		call cobol_vdwf_dput (cobol_com_fileno, com_status, work_ptr, common_recsize,
		     fixed_common.last_file_key);

	     end;

	fixed_common.last_file_key = common_key;	/* save current file key address */

	if temp6 > 100
	then temp6 = temp6 - 100;

	if temp6 < 14
	then do;
		go to T (temp6);

T (1):
		file_table.r_key_info = common_key;
		go to T1;
T (2):
		file_table.r_key_info = common_key;
		go to T1;
T (3):
		file_table.file_status_info = common_key;
		go to T1;
T (4):
		file_table.extra_status_info = common_key;
		go to T1;
T (5):
		file_table.alternate_keys = file_table.alternate_keys + 1;
						/* [3.0-4] */
						/*[3.0-7]*/
		file_table.alt_key_info = common_key;
		go to T1;				/* [3.0-2] */

T (6):
		go to T1;
T (7):
		file_table.cat_id_info = common_key;
		go to T1;
T (8):
		file_table.attach_options_info = common_key;
		go to T1;
T (9):
		file_table.replacement_info = common_key;
		go to T1;
T (10):
		go to T1;
T (11):
		go to T1;
T (12):
		file_table.add_cat_key = common_key;
		go to T1;
T (13):
		file_table.file_id_info = common_key;
		go to T1;
T (14):
		file_table.retention_info = common_key;
		go to T1;

T1:
	     end;

	qual_sw = "0"b;				/* this item is a subject of file key */

     end;








action (36):					/* apply attach options */
	if alphanum_lit.type = 3			/* alphanumeric literal */
	then do;
		apply_num = 5;

		file_table.ao_len = alphanum_lit.lit_size;
		file_table.ao_string = alphanum_lit.string;

		call enter_key (108);
	     end;
	else if user_word.type = 8			/* data-name */
	then do;
		apply_num = 6;
		call enter_key (8);
	     end;
	else apply_num = 0;

	go to ret;

action (37):					/* apply tape-option: execute clause */
	key = cobol_imp_word$io_technique (p2);

	if key = 0
	then go to ret;

	if substr (options_bits, key, 1)
	then sk_ind = "1"b;
	else do;
		sk_ind = "0"b;
		substr (options_bits, key, 1) = "1"b;
	     end;

	go to ATO (key);

ATO (1):						/* additional */
	go to ret;

ATO (5):						/* density */
	go to ret;

ATO (7):						/* device */
	go to ret;

ATO (8):						/* force */
	file_table.force = "1"b;

	go to ret;

ATO (10):						/* output-mode */
	go to ret;

ATO (12):						/* protect */
	file_table.protect = "1"b;

	go to ret;

ATO (13):						/* retain */
	file_table.retain = "1"b;

	go to ret;

action (38):					/* apply file is */
	key = cobol_imp_word$io_technique (p2);

	if key = 15
	then apply_num = 1;				/* is_word("temporary") */
	else if key = 11
	then apply_num = 2;				/* is_word("permanent") */
	else apply_num = 0;

	go to ret;

action (39):					/* apply [no] detach */
	key = reserved_word.key;

	if key = 129
	then apply_num = 3;				/* is_word("no") */
	else if key = 405
	then apply_num = 4;				/* is_word("detach") */
	else apply_num = 0;

	go to ret;

action (40):					/* program collating sequence: save line and col */
	call set_pcs_loc;

	go to ret;


action (41):					/* apply tape-options: initialization */
	options_bits = "0"b;
	apply_num = 7;

	addr (file_table.tape) -> bit18 = "0"b;

	file_table.ao_len = 0;
	file_table.ao_string = "00000";

	file_table.output_mode = 0;
	file_table.tape_device = 0;

	file_table.add_cat_key = "00000";

	go to ret;

action (42):					/* select clause: initialization */
						/*[4.2-1]*/
	sort_name = "0"b;

	vector = "0"b;
	clause_bits = "0"b;
	external_file = "0"b;
	optional_file = "0"b;
	ignore_file = "1"b;
	cat_type = 0;


	do i = 1 by 1 to 10;

	     source_pos.line (i) = 0;

	end;

/*[4.0-5]*/
	source_pos.line (6) = record.header.line;	/*[4.0-5]*/
	source_pos.column (6) = record.header.column;	/*[4.0-5]*/
	dynamic_acc = "0"b;

	go to ret;

action (43):					/* apply: execute clause */
	if file_ptr = null ()
	then do;
		diag_num = 101;
		call diag;
	     end;
	else if apply_num ^= 0
	then go to AP (apply_num);

	go to ret;

AP (1):						/* apply file is temporary */
	if ^(file_ptr -> file_table.temp) & ^(file_ptr -> file_table.perm)
						/*[4.3-1]*/
	then if file_ptr -> file_table.external		/*[4.3-1]*/
	     then do;
		     diag_num = 181;		/*[4.3-1]*/
		     call diag;			/*[4.3-1]*/
		end;				/*[4.3-1]*/
	     else file_ptr -> file_table.temp = "1"b;

	go to ret;

AP (2):						/* apply file is permanent */
	if ^(file_ptr -> file_table.temp) & ^(file_ptr -> file_table.perm)
	then file_ptr -> file_table.perm = "1"b;


	go to ret;

AP (3):						/* apply no detach */
	if ^(file_ptr -> file_table.attach) & ^(file_ptr -> file_table.detach)
	then file_ptr -> file_table.detach = "1"b;	/*[4.0-3]*/

	go to ret;

AP (4):						/* apply detach */
	if ^(file_ptr -> file_table.attach) & ^(file_ptr -> file_table.detach)
	then file_ptr -> file_table.detach = "0"b;	/*[4.0-3]*/

	go to ret;

AP (5):						/* attach options literal */
	if file_ptr -> file_table.ao_len = 0 & file_ptr -> file_table.ao_string = "00000"
	then do;
		file_ptr -> file_table.ao_len = file_table.ao_len;
		file_ptr -> file_table.ao_string = substr (file_table.ao_string, 1, file_table.ao_len);
	     end;

	go to ret;

AP (6):						/* attach-options data-name */
						/*[4.0-9]*/
	if file_ptr -> file_table.attach_options_info = "00000"
						/*[4.0-9]*/
	then do;
		file_ptr -> file_table.attach_options_info =
		     /*[4.0-9]*/ substr (file_table.attach_options_info, 1, 5);
	     end;

	go to ret;

AP (7):						/* tape-options: enter file table */
	if ^(file_ptr -> file_table.temp)
	then file_ptr -> file_table.temp = file_table.temp;
	if ^(file_ptr -> file_table.perm)
	then file_ptr -> file_table.perm = file_table.perm;
	if ^(file_ptr -> file_table.attach)
	then file_ptr -> file_table.attach = file_table.attach;
	if ^(file_ptr -> file_table.detach)
	then file_ptr -> file_table.detach = file_table.detach;
	if ^(file_ptr -> file_table.density)
	then file_ptr -> file_table.density = file_table.density;
	if ^(file_ptr -> file_table.retain)
	then file_ptr -> file_table.retain = file_table.retain;
	if ^(file_ptr -> file_table.force)
	then file_ptr -> file_table.force = file_table.force;
	if ^(file_ptr -> file_table.protect)
	then file_ptr -> file_table.protect = file_table.protect;
						/*[4.4-1]*/
	if ^(file_ptr -> file_table.den_6250)		/*[4.4-1]*/
	then file_ptr -> file_table.den_6250 = file_table.den_6250;

	if file_ptr -> file_table.output_mode = 0 & file_table.output_mode ^= 0
	then do;
		file_ptr -> file_table.output_mode = file_table.output_mode;
		file_ptr -> file_table.om_len = file_table.om_len;
		file_ptr -> file_table.om_string = file_table.om_string;
	     end;

	if file_ptr -> file_table.tape_device = 0 & file_table.tape_device ^= 0
	then do;
		file_ptr -> file_table.tape_device = file_table.tape_device;
		file_ptr -> file_table.tape_device_num = file_table.tape_device_num;
		file_ptr -> file_table.tape_device_key = file_table.tape_device_key;
	     end;

	if file_ptr -> file_table.add_cat_key = "00000" & file_table.add_cat_key ^= "00000"
	then file_ptr -> file_table.add_cat_key = file_table.add_cat_key;

	go to ret;

action (44):					/* alphabet definition: left operand */
	call char_spec (addr (left_char_spec));
	curr_ord_num = ord_num;
	ord_max = 0;
	right_char_spec.type = left_char_spec.type;
	right_char_spec.value = left_char_spec.value;
	if left_char_spec.type = 2
	then right_char_spec.char = left_char_spec.char;

	go to ret;

action (45):					/* apply tape-option: device */
	if sk_ind
	then go to ret;

	if numeric_lit.type = 2			/* literal */
	then do;
		file_table.tape_device = 1;
		file_table.tape_device_num = num_binary;
	     end;

	else if user_word.type = 8			/* data-name */
	then do;
		file_table.tape_device = 2;
		call enter_key (10);
		file_table.tape_device_key = common_key;
	     end;

	else file_table.tape_device = 0;

	go to ret;

action (46):					/* apply tape-option; output-mode */
	if sk_ind
	then go to ret;

	key = cobol_imp_word$io_technique (p2);

	if key = 16
	then file_table.output_mode = 1;		/* is_word("generation") */
	else if key = 9
	then file_table.output_mode = 2;		/* is_word("modification") */
	else if key = 17
	then file_table.output_mode = 3;		/* is_wod("replacement") */
	else file_table.output_mode = 0;

	go to ret;

action (47):					/* apply tape-option: output-mode */
	if sk_ind
	then go to ret;

	if user_word.type = 8			/* data-name */
	then do;
		file_table.output_mode = 4;
		call enter_key (9);
	     end;

	else if alphanum_lit.type = 3			/* alphanumeric literal */
	then do;
		file_table.output_mode = 3;
		call enter_key (109);
	     end;

	else file_table.output_mode = 0;

	go to ret;

action (48):					/* apply tape-options: density */
	if sk_ind
	then go to ret;

/*[4.4-1]*/
	file_table.tape.density, file_table.tape.den_6250 = "0"b;

/*[4.4-1]*/
	if num_binary = 1600			/*[4.4-1]*/
	then file_table.tape.density = "1"b;		/*[4.4-1]*/
	else if num_binary = 6250			/*[4.4-1]*/
	then file_table.tape.den_6250 = "1"b;

	go to ret;

action (49):					/* apply tape-options; catalogue-name */
	if sk_ind
	then go to ret;

	if alphanum_lit.type = 3			/* alphanumeric liteal */
	then call enter_key (112);
	else if user_word.type = 8			/* data-name */
	then do;
		call enter_key (12);
	     end;

	go to ret;

action (50):
	if clause_num < last_clause
	then clause_order = 1;

	last_clause = clause_num;

	go to ret;

action (51):					/* same clause */
	if same_type = 0
	then go to ret;
	else go to SMN (same_type);

SMN (1):						/* same record area clause */
	file_ptr -> file_table.same_rec_clause = samerecct;

	go to SMN1;

SMN (2):						/* same sort area clause */
	file_ptr -> file_table.same_sort_clause = samesct;

	go to SMN1;

SMN (3):						/* same sort-merge area clause */
	go to SMN1;

SMN (4):						/* same area clause */
	file_ptr -> file_table.same_area_clause = samect;

	go to SMN1;

SMN1:
	file_ptr -> file_table.same_file = "1"b;

	call cobol_vdwf_dget (cobol_com_fileno, com_status, file_ptr, common_recsize, com_io_key);

	go to ret;

action (52):					/* object is decimal-point */
	obj_com = "0"b;

	go to ret;

action (53):					/* move table to alphabet entry */
	call init_alpha;

	alphabet_name.one_one = one_one_bit;
	alf_size = ord_num;

	if one_one_bit | dup_alpha_value
	then alphabet_name.onto = "1"b;

	alphabet_name.hi_value = addr (ord_num) -> ch.ch4;
	alphabet_name.hival_char = addr (high_value_value) -> ch.ch4;

	orig_alf_size = alf_size;

	do i = 0 by 1 to nat_alf_size;

	     if nat_bits (i) = "0"b
	     then do;
		     tran_tab (i) = alf_size;
		     alf_size = alf_size + 1;
		end;

	end;

	if alf_size ^= orig_alf_size
	then alphabet_name.hi_value = addr (alf_size) -> ch.ch4;

	if nat_alf_size < 511
	then do i = nat_alf_size + 1 by 1 to 511;

		if nat_bits (i) = "0"b
		then do;
			tran_tab (i) = alf_size;
			alf_size = alf_size + 1;
		     end;

	     end;

	call set_table;

	go to ret;

set_table:
     proc;					/* define table in alphabet def */

declare	(table_ptr, tran_ptr)
			ptr;
declare	table		(0:511) char (1) based (table_ptr);
declare	1 tran		(0:511) based (tran_ptr),
	  2 ch1		char (1),
	  2 ch2		char (1),
	  2 ch3		char (1),
	  2 ch4		char (1);

declare	i		fixed bin;

	table_ptr = addr (alphabet_name.table);
	tran_ptr = addr (tran_tab (0));

	do i = 0 by 1 to 511;

	     table (i) = tran.ch4 (i);

	end;

     end;

action (54):
	fixed_common.descriptor = "01"b;

	go to ret;

action (55):
	fixed_common.descriptor = "10"b;

	go to ret;

action (56):
	;
intpos:						/* assumes ft_ptr set to correct file */
	if file_ptr ^= null ()
	then do;
		file_ptr -> file_table.mult_position_no = num_binary;

		call cobol_vdwf_dput (cobol_com_fileno, com_status, file_ptr, common_recsize, com_io_key);

	     end;

	go to ret;

/* store the implicit position number of the current file on multiple file tape */

action (57):
	;					/* assumes ft_ptr set to correct file */

	file_table.mult_position_no = temp1;

	call cobol_vdwf_dput (cobol_com_fileno, com_status, ft_ptr, common_recsize, com_io_key);

	go to ret;				/* increment the MULTIPLE FILE position number in temp1 by 1 */

action (58):
	;

	if file_ptr ^= null ()
	then file_ptr -> file_table.mult_position_no = temp1;

	go to ret;

/* load the success exit of the current syntax line in the line storage area with the relative 
address of the first syntax line of the recovery routine currently being executed */

action (59):
	;

	current_line = recovaddress;
	kill_diag = 1;				/* suppress diag */

	go to loop;

/* store the relative address of the first syntax line of the recovery routine which is being entered */

action (60):
	;

	recovaddress = current_line;

	go to ret;				/* perform necessary termination functions */

action (61):
	;

	if fixed_common.file_count > 0
	then cobol_$misc_end_ptr = addrel (cobol_$misc_end_ptr, file_table_size);

	if pcs.type = 1 | pcs.type = 2 | pcs.type = 3
	then do;
		diag_item.number = 99;
		diag_item.size = 25;
		diag_item.param_at_end = "0"b;
		diag_item.line = pcs.line;
		diag_item.column = pcs.column;

		call cobol_c_list (diag1_ptr);

		pcs.type = 0;
	     end;
	else if pcs.type = 4
	then do;
		call set_iw_key (pcs.type, pcs.num);

		call set_offset (pcs.num - 9);

		call cobol_vdwf_sput (cobol_name_fileno, name_status, alpha_ptr, alphabet_name.size, name_key);

		diag_num = 103;
		call diag;

		if alphabet_name.iw_key ^= 11
		then fixed_common.prog_coll_seq = addr (name_key) -> fb;
	     end;

	return;

action (62):					/* character size is ... */
	alphabet_name.char_size = num_binary;

	go to ret;

action (63):					/* program collating sequence clause: save alphabet name */
	alf_type = left.type;
	alf_name = left.name;
	alf_num = left.number;
	go to ret;

/* store the procedure segment size in common */
action (64):
	objsign = alphanum_lit.string;

	go to ret;

action (65):					/** special-names paragraph, execute clause */
	if clause_num ^= 0
	then go to SNP (clause_num);

	go to ret;

SNP (1):						/* switch clause */
	go to dup_order;

SNP (2):						/* device clause */
	go to dup_order;

SNP (3):						/* alphabet clause */
	addr (alphabet_name.prev_rec) -> fb = fixed_common.alphabet_offset;

	call cobol_vdwf_sput (cobol_name_fileno, name_status, alpha_ptr, alphabet_name.size, name_key);

	fixed_common.alphabet_offset = addr (name_key) -> fb;
	if dup_alf_value
	then do;
		diag_num = 157;
		call diag;
	     end;
	if pcs.type ^= 0
	then do;
		if alphabet_name.name = pcs.name
		then do;
			pcs.type = 10;
			if alphabet_name.iw_key ^= 11
			then fixed_common.prog_coll_seq = addr (name_key) -> fb;

		     end;
	     end;

	go to dup_order;

SNP (4):						/*currency sign clause */
	if currsign ^= " "
	then fixed_common.currency = currsign;
	if objsign ^= " "
	then fixed_common.object_sign = objsign;

	go to dup_order;

SNP (5):						/* decimal-point clause */
	fixed_common.dec_comma = dec_com;
	fixed_common.obj_dec_comma = obj_com;

	go to dup_order;

init_alpha:
     proc;

	i = length (left.name);

	alphabet_name.size = i + alphabet_name_size;
	alphabet_name.line = left.line;
	alphabet_name.column = left.column;
	alphabet_name.string_ptr = null ();
	alphabet_name.prev_rec = null ();
	alphabet_name.name_size = i;
	alphabet_name.name = left.name;

     end;

action (66):					/* alphabet_name is name */
	clause_num = 3;

	call set_iw_key (right.type, right.number);

	call set_offset (alphabet_name.iw_key);

	go to ret;

set_iw_key:
     proc (type, number);

declare	(type, number)	fixed bin;

	call reset_alpha;

	call init_alpha;

	if type = 4
	then do;
		alphabet_name.iw_key = number - 9;	/* implementor name */
	     end;
	else do;
		alphabet_name.iw_key = number;	/* standard name */
	     end;


	if alphabet_name.iw_key > 0 & alphabet_name.iw_key < 10
	then go to STD (alphabet_name.iw_key);
	else go to STD0;

STD (1):						/* NATIVE */
	alphabet_name.iw_key = 11;

	go to STD0;

STD (2):						/* STANDARD-1 */
	alphabet_name.iw_key = 11;

	go to STD0;

STD (3):						/* STANDARD-2 */
	alphabet_name.iw_key = 11;

	go to STD0;

STD0:
     end;

set_offset:
     proc (key);

declare	key		fixed bin;

	if key > 11
	then go to IMP (key - 11);
	else return;
IMP (1):						/*ebcdic */
	call cobol_set_type40_$ebcdic (alpha_ptr);

	go to IMP0;

IMP (2):						/* gbcd */
	go to IMP0;

IMP (3):						/* hbcd */
	go to IMP0;

IMP (4):						/* ibcd */
	go to IMP0;

IMP (5):						/* jis */
	go to IMP0;

IMP0:
     end;

action (67):					/* left operand, alphabet clause */
	if reserved_word.type = 1
	then do;
		key = reserved_word.key;

		if key = 166
		then alf_range = 1;			/* is_word("thru") */
		else if key = 96
		then alf_range = 2;			/* is_word("also") */
		else alf_range = 0;

	     end;

	else alf_range = 0;

	go to ret;

char_spec:
     proc (p);

declare	p		ptr;

declare	1 char_spec	based (p),
	  2 type		fixed bin,
	  2 value		fixed bin,
	  2 char		char (256) varying;

	if numeric_lit.type = 2
	then do;
		char_spec.type = 1;
		char_spec.value = fixed (numeric_lit.literal) - 1;

		if char_spec.value < 0 | char_spec.value > nat_alf_size
		then do;
			diag_num = 102;
			call diag;
		     end;

	     end;

	else if alphanum_lit.type = 3
	then do;
		char_spec.type = 2;
		char_spec.char = alphanum_lit.string;

		if fixed_common.comp_level < "5" & alphanum_lit.lit_size > 1
		then call lev_diag (124, record.header.line, record.header.column);

	     end;

	else if reserved_word.type = 1
	then do;
		key = reserved_word.key;

		if key = 180
		then char_spec.type = 3;		/* is_word("zero") */
		else if key = 192
		then char_spec.type = 4;		/* is_word("space") */
		else if key = 235
		then char_spec.type = 5;		/* is_word("quote") */
		else if key = 221
		then char_spec.type = 6;		/* is_word ("high-value") */
		else if key = 229
		then char_spec.type = 7;		/* is_word("low-value") */

		else char_spec.type = 0;

	     end;

	else char_spec.type = 0;


     end;

action (68):					/* right operand, alphabet clause */
	call char_spec (addr (right_char_spec));

	go to ret;

action (69):					/** unary ALSO */
	call range_spec;
	alf_range = 3;

	go to ret;

action (70):					/* range specification, alphabet clause */
	call range_spec;				/*[4.0-7]*/
	alf_range = 1;
	go to ret;

range_spec:
     proc;

/* range specification */

	go to AR (alf_range);

AR (0):						/* illegal */
	go to AR1;

AR (1):						/* left THRU right */
	call range;

	go to AR1;

AR (2):						/* left ALSO right */
	call also (addr (left_char_spec));
	call also (addr (right_char_spec));

	go to AR1;

AR (3):						/* ALSO right */
	call also (addr (right_char_spec));

AR1:
     end;

also:
     proc (p);

declare	p		ptr;
declare	(loc, L, i)	fixed bin;

declare	1 char_spec	based (p),
	  2 type		fixed bin,
	  2 value		fixed bin,
	  2 char		char (256) varying;

	go to AL (char_spec.type);

AL (0):						/* illegal */
	return;

AL (1):						/* numeric literal */
	go to AL1;

AL (2):						/* alphanumeric literal */
	L = length (char_spec.char);
	call setup;

	do i = 1 by 1 to L;

	     char1 = substr (char_spec.char, i, 1);
	     call set_also_char (fixed (char1_ptr -> bit9));

	end;

	return;

AL (3):						/* is_word("zero") */
	char_spec.value = index (coll_seq, "0");

	go to AL1;

AL (4):						/* is_word("space") */
	char_spec.value = index (coll_seq, " ");

	go to AL1;

AL (5):						/* is_word("quote") */
	char_spec.value = index (coll_seq, """");

	go to AL1;

AL (6):						/* is_word("high-value") */
	char_spec.value = 128;

	go to AL1;

AL (7):						/* is_word("low-value") */
	char_spec.value = 1;

	go to AL1;

AL1:
	call setup;
	call set_also_char (char_spec.value);

     end;

setup:
     proc;

	one_one_bit = "1"b;

	ord_num = curr_ord_num;

     end;

set_also_char:
     proc (loc);

declare	loc		fixed bin;

/*[4.0-7]*/
	if loc < 0 | loc > nat_alf_size + 1
	then return;

	if nat_bits (loc)
	then dup_alf_value = "1"b;

	else do;
		nat_bits (loc) = "1"b;
		tran_tab (loc) = ord_num;

		if ord_num >= ord_max
		then do;
			high_value_value = loc;
			ord_max = ord_num;
		     end;

		ord_num = ord_num + 1;
	     end;

     end;

set_char:
     proc (loc);

declare	loc		fixed bin;

	if nat_bits (loc)
	then dup_alf_value = "1"b;
	else do;
		nat_bits (loc) = "1"b;
		tran_tab (loc) = ord_num;
		ord_num = ord_num + 1;

		high_value_value = loc;
	     end;

     end;

range:
     proc;

declare	(L, i, loc)	fixed bin;

	ord_num = curr_ord_num + ord_max;

	go to TL (left_char_spec.type);

TL (0):						/* illegal */
	return;

TL (1):						/* left side is numeric literal*/
	left_number = left_char_spec.value;

	go to T1;

TL (2):						/* left side is alphanumeric literal */
	L = length (left_char_spec.char);
	char1 = substr (left_char_spec.char, L, 1);
	left_number = fixed (char1_ptr -> bit9);

	if L > 1
	then do i = 1 by 1 to L - 1;

		char1 = substr (left_char_spec.char, i, 1);
		loc = fixed (char1_ptr -> bit9);
		call set_char (loc);

	     end;

	go to T1;

TL (3):						/* left side is zero */
	left_number = index (coll_seq, "0");

	go to T1;

TL (4):						/* left side is space */
	left_number = index (coll_seq, " ");

	go to T1;

TL (5):						/* left side is quote */
	left_number = index (coll_seq, """");

	go to T1;

TL (6):						/* left side is high-value */
	left_number = 128;

	go to T1;

TL (7):						/* left-side is low-value */
	left_number = 1;

	go to T1;

T1:
	go to TR (right_char_spec.type);

TR (0):
	right_number = left_number;

	call emit_range;

	go to T2;

TR (1):						/* right side is numeric literal */
	right_number = right_char_spec.value;
	call emit_range;

	go to T2;

TR (2):						/* right side is alphanumeric literal */
	L = length (right_char_spec.char);
	char1 = substr (right_char_spec.char, 1, 1);
	right_number = fixed (char1_ptr -> bit9);
	call emit_range;

	if L > 1
	then do i = 2 by 1 to L;

		char1 = substr (right_char_spec.char, i, 1);
		loc = fixed (char1_ptr -> bit9);
		call set_char (loc);

	     end;

	go to T2;

TR (3):						/* right side is zero */
	right_number = index (coll_seq, "0");
	call emit_range;

	go to T2;


TR (4):						/* right side is space */
	right_number = index (coll_seq, " ");
	call emit_range;

	go to T2;

TR (5):						/* right side is quote */
	right_number = index (coll_seq, """");
	call emit_range;

	go to T2;

TR (6):						/* right side is high-value */
	right_number = 128;
	call emit_range;

	go to T2;

TR (7):						/* right side is low-value */
	right_number = 1;
	call emit_range;

	go to T2;


T2:
	curr_ord_num = ord_num;
	ord_max = 0;

     end;


emit_range:
     proc;

	if left_number < 0 | left_number > nat_alf_size | right_number < 0 | right_number > nat_alf_size
	then return;

	if left_number <= right_number
	then do i = left_number by 1 to right_number;

		call set_char (i);

	     end;

	else do i = left_number by -1 to right_number;

		call set_char (i);

	     end;

     end;


action (71):
	if user_word.type = 8
	then do;
		file_table.catalogued = 3;
		call enter_key (7);
	     end;
	else if alphanum_lit.type = 3
	then file_table.catalogued = 2;

	go to ret;

action (72):
	right_char_spec.type = 0;

	call range_spec;

	go to ret;

action (73):
	org = file_ptr -> file_table.organization;

	mod_num = lev1_mod (org);

	current_line = current_line + org + 1;

	go to loop;

action (74):
	org = file_table.organization;

	mod_num = lev2_mod (org);

	current_line = current_line + org + 1;

	go to loop;

action (75):
	call cobol_vdwf_dget (cobol_com_fileno,		/* [3.0-1] */
	     com_status,				/* [3.0-1] */
	     work_ptr,				/* [3.0-1] */
	     common_recsize,			/* [3.0-1] */
	     fixed_common.last_file_key /* [3.0-1] */);	/* [3.0-1] */

	work_ptr -> file_key.duplicates = "1"b;		/* [3.0-1] */

	call cobol_vdwf_dput (cobol_com_fileno,		/* [3.0-1] */
	     com_status,				/* [3.0-1] */
	     work_ptr,				/* [3.0-1] */
	     common_recsize,			/* [3.0-1] */
	     fixed_common.last_file_key /* [3.0-1] */);	/* [3.0-1] */
	file_table.dupl_alt = "1"b;			/* [3.0-5] */

	go to ret;				/* [3.0-1] */

action (76):					/*[4.0-8]*/
	current_line = current_line + same_type + 1;

	go to loop;

action (77):					/* issue diagnostic m = 2srt(131) with mod_num =  6 */
	if "4" > fixed_common.comp_level
	then do;
		mod_num = 6;			/* 2srt */
		call lev_diag (131, rec_loc.line, rec_loc.column);
						/* SAME RECORD AREA */
	     end;

	go to ret;

action (78):					/* set sort_name to show that file name is a sort file */
						/*[4.2-1]*/
	sort_name = "1"b;

	go to ret;

action (79):
	property (18) = "1"b;			/* indicate record key */
	file_table.record_key = "1"b;
	call enter_key (2);

	go to ret;

/* catalogue name clause */

/* construct an entry in common for the current file status item name */

action (80):					/* assumes ft_ptr set to correct file */
						/* indicate file status item name */
	file_table.file_status = "1"b;
	call enter_key (3);

	go to ret;
action (84):
	go to dup_order;

action (85):					/* begin the mnemonic-name record for this item */
	mnemonic_name.class = class24;
	mnemonic_name.on_status = "0"b;
	mnemonic_name.off_status = "0"b;

	go to ret;

action (92):					/* same clause */
						/*[5.0-1]*/
	string (org_vector) = "0"b;

/*[5.0-1]*/
	if reserved_word.type ^= 1			/*[5.0-1]*/
	then do;
		same_type = 4;			/*[5.0-1]*/
		samect = samect + 1;		/*[5.0-1]*/
		go to ret;			/*[5.0-1]*/
	     end;

	key = reserved_word.key;

	if key = 148				/* is_word("record") */
	then do;
		same_type = 1;
		samerecct = samerecct + 1;
		fixed_common.sra_clauses = samerecct;

/*[5.0-1]*/
		rec_loc.line = record.header.line;	/*[5.0-1]*/
		rec_loc.column = record.header.column;
	     end;
	else if key = 49				/* is_word("sort) */
	then do;
		same_type = 2;
		samesct = samesct + 1;
	     end;
	else if key = 598				/* is_word("sort-merge") */
	then do;
		same_type = 3;
		samesmct = samesmct + 1;
	     end;
	else do;
		same_type = 4;
		samect = samect + 1;
	     end;

	go to ret;

/* increment the sequential number of the current SAME AREA clause by 1, and set temp1, temp2, and 
				temp3 to zero */

action (93):
	samect = samect + 1;
	temp1 = 0;
	temp2 = 0;
	temp3 = 0;

	go to ret;

/* build qualifier record in common for file key or file status name being processed */

action (95):
	;					/* assumes fkey_ptr set to correct key or file status name */

	temp4 = user_word.length + key_qual_size;
	qual_ptr = addr (file_key_area);
	qual_rec.next = "00000";
	qual_rec.size = user_word.length;
	qual_rec.name = user_word.word;
	common_recsize = temp4;			/* temp4 contains size of	qual_rec. */

	call cobol_vdwf_sput (cobol_com_fileno, com_status, qual_ptr, common_recsize, common_key);

	if qual_sw = "0"b
	then do;					/* is this 1st	qual?*/

		call cobol_vdwf_dget (cobol_com_fileno, com_status, work_ptr, common_recsize,
		     fixed_common.last_file_key);	/* get subject */

		work_ptr -> file_key.qual = common_key; /* link to current qual*/

		call cobol_vdwf_dput (cobol_com_fileno, com_status, work_ptr, common_recsize,
		     fixed_common.last_file_key);

	     end;

	else do;					/* two or more qual. */

		call cobol_vdwf_dget (cobol_com_fileno, com_status, work_ptr, common_recsize, prev_qual_key);
						/* get qual.	*/

		work_ptr -> qual_rec.next = common_key; /* now link to current qual. */

		call cobol_vdwf_dput (cobol_com_fileno, com_status, work_ptr, common_recsize, prev_qual_key);

	     end;

	prev_qual_key = common_key;			/* save current qual. rec. */
	qual_sw = "1"b;

	go to ret;

action (96):					/* file table to variable common */
	if file_table.organization = 2 & file_table.access = 0
	then file_table.access = 1;
	if ^ignore_file
	then call emit_ft;

	go to ret;

action (97):					/* type 17 name table entry, device number */
	addr (mnemonic_name.class) -> bit8 = "0"b;

	if left.number >= 210
	then mnemonic_name.class.printer_control = "1"b;
	else do;

		if left.number ^= 0
		then left.number = left.number - 8;

		go to RN (left.number);

RN (0):						/* illegal */
		go to RN1;

RN (1):						/* SYSIN */
		mnemonic_name.class.accept_device = "1"b;

		go to RN1;

RN (2):						/* SYSOUT */
		mnemonic_name.class.display_device = "1"b;

		go to RN1;

RN (3):						/* CONSOLE */
		mnemonic_name.class.accept_device = "1"b;
		mnemonic_name.class.display_device = "1"b;

		go to RN1;

RN1:
	     end;
	call nm (addr (right), left.number);

	go to ret;

action (98):					/* file control paragraph: determine clause number */
	file_qual = 0;
	key = reserved_word.key;

	if key = 509
	then clause_num = 1;			/* is_word("assign") */
	else if key = 181
	then clause_num = 2;			/* is_word("organization") */

	else if key = 589				/* is_word("reserve") */
	then clause_num = 3;

	else if key = 501
	then clause_num = 4;			/* is_word("access") */
	else if key = 108
	then clause_num = 6;			/* is_word("file") */
	else if key = 247
	then clause_num = 6;			/* is_word("status") */
	else if key = 331
	then clause_num = 8;			/* is_word("catalog-name") */

	else if key = 85
	then /* is_word("ssf") */
	     do;
		clause_num = 9;
		ssf_ind = "1"b;
	     end;

	else if key = 272
	then /* is_word("flr") */
	     do;
		clause_num = 9;
		flr_ind = "1"b;
	     end;

	else if key = 201
	then /* is_word("vlr") */
	     do;
		clause_num = 9;
		vlr_ind = "1"b;
	     end;

	else if key = 413
	then /* is_word("bsn") */
	     do;
		clause_num = 9;
		bsn_ind = "1"b;
	     end;

	else if key = 601
	then /* is_word("spanned") */
	     do;
		clause_num = 9;
		span_ind = "1"b;
	     end;

	else if key = 329
	then clause_num = 10;			/* is_word("process-area") */
	else if key = 327
	then clause_num = 11;			/* is_word("interchange") */
	else if key = 167
	then clause_num = 12;			/* is_word("relative") */

	else if key = 507				/* is_word("alternate") */
	then clause_num = 7;

	else if key = 148
	then clause_num = 5;			/* is_word("record") */
	else if key = 129
	then clause_num = 13;			/* is_word("no") */
	else clause_num = 0;

/*[4.0-5]*/
	if clause_num ^= 0
	then go to SL (clause_num);			/*[4.0-5]*/
SL (1):
	val = 7;
	go to SLL;
SL (2):
	val = 1;
	go to SLL;
SL (3):
	val = 3;
	go to SLL;
SL (4):
	val = 8;
	go to SLL;
SL (5):
	val = 4;
	rec_key = "1"b;
	go to SLL;
SL (6):
	val = 9;
	go to SLL;
SL (7):
	val = 5;
	go to SLL;
SL (8):
	go to ret;
SL (9):
	go to ret;
SL (10):
	go to ret;
SL (11):
	go to ret;
SL (12):
	val = 10;
	rel_key = "1"b;
	go to SLL;
SL (13):
	go to ret;

/*[4.0-5]*/
/*[4.0-5]*/
SLL:						/*[4.0-5]*/
						/*[4.0-5]*/
	source_pos.line (val) = record.header.line;	/*[4.0-5]*/
	source_pos.column (val) = record.header.column;
	go to ret;				/*[4.0-5]*/


action (125):					/* construct a file key record for the status key 3 item */
	temp6 = 4;				/* indicate status key 3 name in file status clause */
	file_table.extra_status = "1"b;
	call enter_key (4);

	go to ret;

action (133):					/* diagnose any contradictions in previous select clause */
	if file_table.organization = 0
	then file_table.organization = 1;
	if file_table.buffers = 0
	then file_table.buffers = 1;

/*[4.0-1]*/
	if file_table.device = 7			/* preattached */
						/*[4.0-1]*/
	then do;
		file_table.optional = "0"b;		/*[4.0-1]*/
		file_table.external = "1"b;		/*[4.0-3]*/
		file_table.detach = "1"b;		/*[4.0-1]*/
	     end;


	if file_table.optional
	then if file_table.organization ^= 1
	     then do;
		     diag_num = 110;
		     call diag;

		     if fixed_common.comp_level < "5"
		     then call lev_diag (9, record.header.line, record.header.column);

		end;

	if file_table.access > 1
	then if file_table.organization ^= 2 & file_table.organization ^= 3
	     then do;
		     diag_num = 109;
		     call diag;

		     file_table.access = 1;
		end;

	if (file_table.device ^= 1)
	then if file_table.record_prefix = 0
	     then file_table.record_prefix = 2;

	do i = 1 to 21;

	     if property (i) ^= "0"b
	     then do;

		     vector_temp = vector & array (i);

		     if vector_temp ^= "0"b
		     then do;

			     diag_item.line = record.header.line;
			     diag_item.column = record.header.column;
			     diag_item.number = 9;
			     diag_item.param_at_end = "1"b;
			     diag_item.image_size = word_array.word_size (i) + 5;
			     diag_item.image = word_array.word (i);

			     substr (diag_item.image, word_array.word_size (i) + 1, 5) = " and ";

			     do j = 1 to 21;

				if temp_bit (j) ^= "0"b
				then do;

					substr (diag_item.image, word_array.word_size (i) + 6,
					     word_array.word_size (j)) = word_array.word (j);

					diag_item.image_size =
					     word_array.word_size (i) + 5 + word_array.word_size (j);

					diag_item.size = 32 + diag_item.image_size;

					call cobol_c_list (diag1_ptr);

				     end;

			     end;

			end;

		end;
	end;

	go to ret;

action (162):					/* determine number of default section clause */
	call def_clause_num;

	go to ret;

def_clause_num:
     proc;

	if reserved_word.type = 1
	then do;
		key = reserved_word.key;

		if key = 122
		then clause_num = 2;		/* is_word("leading") */
		else if key = 255
		then clause_num = 2;		/* is_word("trailing") */
		else if key = 106
		then clause_num = 3;		/* is_word("comp") */
		else if key = 1
		then clause_num = 5;		/* is_word("accept") */
		else if key = 42
		then clause_num = 6;		/* is_word("display") */
		else if key = 251
		then clause_num = 1;		/* is_word("symbolic") */
		else if key = 131
		then clause_num = 4;		/* is_word("numeric") */
		else clause_num = 0;

	     end;

	else if user_word.type = 8
	then do;
		key = cobol_imp_word$imp_word (p2);

		if key = 11
		then clause_num = 6;		/* IS_WORD("console") */
		else if key = 10
		then clause_num = 6;		/* IS_WORD("sysout") */
		else if key = 1000
		then clause_num = 4;		/* is_word("temp") */
		else clause_num = 0;

	     end;

	else clause_num = 0;

     end;

action (163):					/* initialize for default section */
	lead_trail = 0;				/* sign is trailing */
	sep_sign = 0;				/* sign is non-separate */
	acc_dev_num = 0;				/* accept device is sysin */
	disp_dev_num = 0;				/* display device is sysout */
	int_res = 30;				/* intermediate results to 30 digits */
	queue_name = 0;				/* symbolic queue is omitted */
	comp_type = 0;				/* default comp is display */

	clause_bits = "0"b;
	last_clause = 0;
	clause_order = 0;

	go to ret;

action (164):					/* determine accept device number */
	key = cobol_imp_word$device_name (p2);

	if key = 1
	then acc_dev_num = 0;			/* IS_WORD("sysin") */
	else if key = 3
	then acc_dev_num = 1;			/* IS_WORD("console") */
	else acc_dev_num = 0;

	go to ret;

action (165):					/* determine display device number */
	key = cobol_imp_word$device_name (p2);

	if key = 2
	then disp_dev_num = 0;			/* IS_WORD("sysout") */
	else if key = 3
	then disp_dev_num = 1;			/* IS_WORD("console") */
	else disp_dev_num = 0;

	call def_clause_num;

	go to ret;

action (166):
	go to ret;

action (167):					/* determine message queue number */
	key = reserved_word.key;

	if key = 203
	then queue_name = 0;			/* is_word("omitted") */
	else if key = 126
	then queue_name = 1;			/* is_word("message") */
	else queue_name = 0;

	go to ret;

action (168):					/* initialize for id paragraphs */
	clause_bits = "0"b;
	last_clause = 0;
	clause_order = 0;


	go to ret;

action (169):					/* default section clause */
	if clause_num ^= 0
	then go to D (clause_num);
	else go to ret;

D (1):						/* symbolic queue clause */
	go to dup_order;

D (2):						/* display sign clause */
	if lead_trail ^= 0
	then substr (dst, 2, 1) = "1"b;
	else substr (dst, 3, 1) = "1"b;

	if sep_sign ^= 0
	then if substr (dst, 2, 2) = "10"b
	     then substr (dst, 1, 3) = "100"b;
	     else substr (dst, 1, 3) = "011"b;

	if dst ^= "0"b
	then fixed_common.default_sign_type = dst;

	go to dup_order;

D (3):						/* default_comp_clause */
	if comp_type ^= 0
	then do;
		if comp_type < 10
		then do;
			def_ptr = addr (fixed_common.comp_defaults);
			def_ptr -> bit9 = "0"b;
			addr (fixed_common.disp_defaults) -> bit8 = "0"b;
						/*[4.4-3]*/
			substr (def_ptr -> bit9, comp_type, 1) = "1"b;
		     end;
		else do;
			def_ptr = addr (fixed_common.disp_defaults);
			def_ptr -> bit8 = "0"b;
			addr (fixed_common.comp_defaults) -> bit9 = "0"b;
						/*[4.4-3]*/
			substr (def_ptr -> bit8, comp_type - 10, 1) = "1"b;
		     end;
	     end;

	go to dup_order;

D (4):						/* temp_clause */
	fixed_common.default_temp = int_res;

	go to ret;

D (5):						/* accept_device clause */
	fixed_common.accept_device = acc_dev_num;

	go to dup_order;

D (6):						/* display device clause */
	fixed_common.display_device = disp_dev_num;

	go to dup_order;

dup_order:
	if clause_num < last_clause
	then clause_order = 1;

	last_clause = clause_num;

	go to ret;

action (170):					/* default sign is leading */
	call def_clause_num;
	lead_trail = 1;

	go to ret;

action (171):					/* default_sign is trailing */
	call def_clause_num;
	lead_trail = 0;

	go to ret;

action (172):					/* sign is separate */
	sep_sign = 1;

	go to ret;

action (173):					/* [3.0-3] issue lev diag for 169-missing period after division */
	if fixed_common.comp_level < "5"
	then call lev_diag (169, record.header.line, record.header.column);

	go to ret;

action (174):					/*[4.4-2]*/
	mod_num = 0;
	go to ret;

action (175):					/*[4.4-2]*/
	call sav_lin_col;
	go to ret;

action (176):					/*[4.4-2]*/
	qualif = "1"b;
	go to ret;

action (177):					/*[4.4-2]*/
	if fixed_common.comp_level < "3"		/*[4.4-2]*/
	then if qualif				/*[4.4-2]*/
	     then call lev_diag (5, save.line, save.column);
	go to ret;

/*[5.0-1]*/

action (178):					/* SAME AREA clause */
	go to SA (org);

SA (1):						/* seq file */
	mod_num = 0;
	go to SA0;

SA (2):						/* rel file */
	call sa_mess (2, 17);
	go to SA0;

SA (3):						/* inx file */
	call sa_mess (3, 19);
	go to SA0;

SA (4):						/* illegal */
	go to SA0;

SA (5):						/* str file */
	call sa_mess (5, 25);
	go to SA0;
SA0:
	go to ret;

declare	org_vector	(5) bit (1);

declare	1 same_loc,
	  2 line		fixed bin,
	  2 column	fixed bin;
dcl	level_num		(26) char (1)
			init ("1", "3", "1", "3", "3", "4", "2", "4", "2", "4", "2", "3", "2", "3", "1", "3", "2",
			"3", "4", "4", "4", "4", "3", "3", "5", "5");

sa_mess:
     proc (org_num, md_num);

declare	(org_num, md_num)	fixed bin;

	if org_vector (org_num)
	then return;

	org_vector (org_num) = "1"b;
	mod_num = md_num;

	if level_num (md_num) > fixed_common.comp_level
	then call lev_diag (211, same_loc.line, same_loc.column);

     end;

action (179):					/* SAME RECORD AREA clause */
	go to SRA (org);

SRA (1):						/* seq file */
	if org_vector (org)
	then go to ret;

	org_vector (org) = "1"b;
	mod_num = 16;
	if "3" > fixed_common.comp_level
	then call lev_diag (131, rec_loc.line, rec_loc.column);
	go to SRA0;

SRA (2):						/* rel file */
	call sra_mess (2, 17);
	go to SRA0;

SRA (3):						/* inx file */
	call sra_mess (3, 19);
	go to SRA0;

SRA (4):						/* illegal */
	go to SRA0;

SRA (5):						/* str file */
	call sra_mess (5, 25);
	go to SRA0;

SRA0:
	go to ret;

declare	1 rec_loc,
	  2 line		fixed bin,
	  2 column	fixed bin;

sra_mess:
     proc (org_num, md_num);

declare	(org_num, md_num)	fixed bin;

	if org_vector (org_num)
	then return;

	org_vector (org_num) = "1"b;
	mod_num = md_num;

	if level_num (md_num) > fixed_common.comp_level
	then call lev_diag (211, same_loc.line, same_loc.column);

	md_num = md_num + 1;
	mod_num = md_num;

	if level_num (md_num) > fixed_common.comp_level
	then call lev_diag (131, rec_loc.line, rec_loc.column);

     end;

sav_lin_col:
     proc;

/*[4.4-2]*/
	save.line = record.header.line;
	save.column = record.header.column;		/*[4.4-2]*/
	qualif = "0"b;
     end;

dtb:
     proc;
	num_binary = fixed (numeric_lit.literal);
     end;

/*[5.0-1]*/
declare	seg_limit		fixed bin static internal;

get_seg_limit:
     entry returns (fixed bin);

/*[5.0-1]*/
	return (seg_limit);


/*[4.2-1]*/
dcl	sort_name		bit (1),
	cobol_res_words$check_sort_list
			entry (char (*)) returns (bit (1));
declare	LEV		char (1);

declare	lev1_org		(6) char (1) init ("0", "2", "4", "0", "0", "3");
declare	lev2_org		(6) char (1) init ("3", "3", "4", "0", "5", "4");

/*[4.0-5]*/
dcl	dynamic_acc	bit (1),
	val		fixed bin;
declare	1 source_pos	(10),
	  2 line		fixed bin,
	  2 column	fixed bin;

declare	lev1_mod		(6) fixed bin init (15, 17, 19, 0, 25, 5);
declare	lev2_mod		(6) fixed bin init (16, 18, 20, 0, 26, 6);

declare	(mod_num, act_num, org)
			fixed bin;

/*[4.2-2]*/
declare	1 dyn,					/*[4.2-2]*/
	  2 line		fixed bin,		/*[4.2-2]*/
	  2 column	fixed bin;

/*[4.2-2]*/
declare	LEV_NUM		char (1),
	MOD_NUM		fixed bin;

declare	(addr, addrel, index, null, rel, substr, unspec, fixed, char, length, size, string)
			builtin;
declare	(collate)		builtin;


dcl	1 qual_rec	based (qual_ptr),
	  2 next		char (5),
/******** new i_o key ******/
	  2 size		fixed bin,
	  2 name		char (0 refer (qual_rec.size));

/* general form of internal record */
/* current minpral item buffer */
dcl	1 record		based (p2),
	  2 header,
	    3 size	fixed bin,
	    3 line	fixed bin,
	    3 column	fixed bin,
	    3 type	fixed bin,
	  2 body		char (record.header.size - 16);

/* description of diagnostic item in input minpral */
dcl	1 message		based (p2),
	  2 header,
	    3 size	fixed bin,
	    3 line	fixed bin,
	    3 column	fixed bin,
	    3 type	fixed bin,		/* = 5 */
	  2 body,
	    3 run		fixed bin,
	    3 number	fixed bin,
	    3 info,
	      4 param_at_end
			bit (1),
	      4 replaces_token
			bit (1),
	      4 filler	bit (6),
	    3 length	fixed bin,
	    3 image	char (message.length);

/* type 5 structure used to construct diagnostics issued by idedsyn */
dcl	1 diag_item,				/* header */
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,		/* body */
	  2 run		fixed bin,
	  2 number	fixed bin,
	  2 param_at_end	bit (1),
	  2 replace	bit (1),
	  2 filler	bit (6),
	  2 image_size	fixed bin,
	  2 image		char (29);

/*[4.4-2]*/
declare	qualif		bit (1);

/*[4.4-2]*/
declare	1 save,					/*[4.4-2]*/
	  2 line		fixed bin,		/*[4.4-2]*/
	  2 column	fixed bin;

declare	1 lev_diag_item,
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 run		fixed bin,
	  2 number	fixed bin,
	  2 module	fixed bin;

/* external entry declarations */
dcl	cobol_swf_get	entry (ptr, bit (32), ptr, fixed bin) ext;
dcl	cobol_vdwf_dput	entry (ptr, bit (32), ptr, fixed bin, char (5)) ext;
dcl	cobol_vdwf_dget	entry (ptr, bit (32), ptr, fixed bin, char (5)) ext;
dcl	cobol_vdwf_sput	entry (ptr, bit (32), ptr, fixed bin, char (5)) ext;
dcl	cobol_c_list	entry (ptr) ext;		/* called to print source images and diagnostics */
dcl	cobol_ided	entry (ptr, fixed bin) ext;	/* called to get syntax table 1st line */
dcl	n_reducs		fixed bin;

/*work area for io */
dcl	min1_status	bit (32);			/*minpral	file return code */
dcl	com_status	bit (32);			/*common file return code */
dcl	name_status	bit (32);			/*name_tbl file return code */
dcl	ft_size		fixed bin;		/*file table item size */
dcl	prev_qual_key	char (5);			/* previous qual_key record address */
dcl	last_prev_file_key	char (5);			/* last previous file_table address */
dcl	same_ptr_key	char (5);			/* same area previous file table address */
dcl	last_fkey_ptr	char (5);			/*address of last file_key record */
dcl	last_ft_ptr	ptr;			/* previous file table pointer */
dcl	file_key_type	fixed bin;		/* file key type saving area */
dcl	qual_sw		bit (1);			/* indicator	if qualifier exist */
dcl	com_io_key	char (5);			/*common_file io key */

/* work areas */
dcl	file_key_area	char (256);		/* work area for file key record */
declare	x		bit (8) based;
declare	class24		bit (24) based (addr (reserved_word.verb));

declare	ft_build_area	(500) fixed bin;		/* file table entry */

dcl	zero		char (18);		/* constant zero */
dcl	banchar		char (1);			/* banner character from apply clause saved here */
dcl	padchar		char (1);			/* padding character from apply clause saved here */
dcl	error		char (1);			/* set to "E" if run interrupted by io error */
declare	device_name_size	fixed bin;
declare	device_name	char (32) varying;
dcl	current_file_no	fixed bin;		/* same area file no */
						/* pointers */
dcl	name_ptr		ptr;			/* pointer to mnemonic-name record in common */
dcl	ft_ptr		ptr;			/* pointer to current file table record in common */
dcl	(work_ptr, save_ptr)
			ptr;
dcl	fkey_ptr		ptr;			/* pointer to current file key or file status record in common */
dcl	qual_ptr		ptr;			/* pointer to qualifier record in common */
dcl	same_ptr		ptr;			/* pointer to file table for previous file in current SAME [RECORD] AREA clause */
dcl	(diag1_ptr, diag2_ptr)
			ptr;			/* pointer to diag_item, passed to print routine */

/*work area for output item size */
dcl	file_table_size	fixed bin;		/*file table base */
dcl	type17_size	fixed bin;		/*mnemonic name item size*/
dcl	file_key_size	fixed bin;		/*key name itemsize:*/
dcl	key_qual_size	fixed bin;		/* qualifier itemsize:*/
						/* fixed binary work fields */
dcl	i		fixed bin;		/* counter for contradiction matrix action routine */
dcl	j		fixed bin;		/* counter for contradiction matrix action routine */
dcl	n		fixed bin;		/*pointer to the specified device type in device_name */
dcl	n1		fixed bin;		/* temp length of userword.body.word8 */
dcl	tempn1		fixed bin;		/* temp	field , used immed... thereby avail most anytime */
dcl	temp1		fixed bin;
dcl	temp2		fixed bin;
dcl	temp3		fixed bin;
dcl	temp4		fixed bin;		/* work area */
dcl	temp5		fixed bin;
dcl	temp6		fixed bin;		/* work area */
dcl	num_binary	fixed bin;		/* numeric literal binary value */
dcl	mrcsz		fixed bin;		/* minpral file record size */

declare	(samect, samerecct, samesct, samesmct, same_type)
			fixed bin init (0);
declare	(nat_alf_size, orig_alf_size)
			fixed bin;

dcl	mult_fil_no	fixed bin;
dcl	recovaddress	fixed bin;
dcl	addrform		fixed bin;		/* number identifying address format from apply clause saved here */
dcl	common_recsize	fixed bin;		/* size of record just read from common file */
dcl	(common_key, save_common_key)
			char (5);			/* record number of common record just read or to be read */
dcl	name_key		char (5);			/* bit strings */
dcl	rerunclock	bit (1);			/* set on if RERUN ... CLOCK-UNITS specified in program */
dcl	remarksbit	bit (1);
dcl	debugbit		bit (1);
dcl	optional_file	bit (1);			/* set on if OPTIONAL found in SELECT clause for a file */
dcl	external_file	bit (1);			/* set on if EXTERNAL found in SELECT clause for a file */
dcl	previous_valid_fkeys
			bit (1);
dcl	implnm_bit	bit (1);
dcl	ed_found		bit (1);			/* set on when ENVIRONMENT DIVISION header found */
dcl	console_name	bit (1);			/* set on when a mnemonic name for CONSOLE is found */
dcl	dec_is_com	bit (1);			/* set on when decimal-point is comma is found (NOT set when */
						/* decimal-point is decimal-point) */
dcl	dpass_sw		bit (1);			/* Set on when a special character (such as _ ) is detected */


/* structures associated with contradiction checking of select statement clauses */
/* the positional significance of the bits in the 18-bit string is:
		(1)	assign...H_RD
		(2)	assign...H_PR
		(3)	sequential organization
		(4)	relative organization
		(5)	indexed organization
		(6)	non-sequential access (either random or dynamic)
		(7)	device is printer
		(8)	device is card-reader
		(9)	device is card-punch
		(10)	device is tape
		(11)	standard record prefix
		(12)	ssf record prefix
		(13)	dof record prefix
		(14)	sysin
		(15)	sysout
		(16)	optional
		(17)	relative key
		(18)	record key					 
		(19) keyed organization
		(20) keyed key		
		(21) assign...H_SORT	*/
dcl	array		(21) bit (21);
dcl	property		(21) bit (1);
dcl	vector		bit (21) based (addr (property));
dcl	vector_temp	bit (21);
dcl	temp_bit		(21) bit (1) based (addr (vector_temp));
dcl	1 word_array	(21),
	  2 word_size	fixed bin,
	  2 word		char (12);


declare	fbarray		(100000) fixed bin based;
declare	bit8		bit (8) based;
declare	bit9		bit (9) based;
declare	bit512		bit (512) based;
declare	bit18		bit (18) based;
declare	bit36		bit (36) based;
declare	fb		fixed bin based;

declare	1 ch		based,
	  2 ch1		char (1),
	  2 ch2		char (1),
	  2 ch3		char (1),
	  2 ch4		char (1);

declare	options_bits	bit (18);

declare	(lead_trail, file_org, file_qual, opt_num, fq, ord_num, alf_range, ord_max, curr_ord_num, sep_sign, key,
	apply_num, max, left_number, right_number, wnum, comp_num, obj_comp_num, source_comp_num, alf_type, alf_size,
	alf_num, high_value_value, alphabet_name_size, cat_type, file_acc, last_clause, clause_order, clause_num,
	seg_lim, int_res, comp_name, source_comp_name, obj_comp_name, acc_dev_num, disp_dev_num, queue_name, comp_type)
			fixed bin;

declare	tran_tab		(0:511) fixed bin;
declare	nat_bits		(0:511) bit (1);

declare	coll_seq		char (128);

declare	1 indicators,
	  2 dec_com	bit (1),
	  2 dup_alf_value	bit (1),
	  2 ignore_file	bit (1),
	  2 rel_key	bit (1),
	  2 rec_key	bit (1),
	  2 one_one_bit	bit (1),
	  2 dup_alpha_value bit (1),
	  2 ssf_ind	bit (1),
	  2 flr_ind	bit (1),
	  2 vlr_ind	bit (1),
	  2 bsn_ind	bit (1),
	  2 sk_ind	bit (1),
	  2 span_ind	bit (1),
	  2 obj_com	bit (1);

declare	(file_ptr, alpha_ptr, def_ptr, char1_ptr)
			ptr;

declare	(clause_bits, switch_bits, defaults, dev_bits, alph_bits)
			bit (36);

declare	1 left,
	  2 type		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 number	fixed bin,
	  2 num		fixed bin,
	  2 name		char (32) varying;

declare	1 right,
	  2 type		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 number	fixed bin,
	  2 num		fixed bin,
	  2 name		char (32) varying;

declare	1 left_char_spec,
	  2 type		fixed bin,
	  2 value		fixed bin,
	  2 char		char (256) varying;

declare	1 right_char_spec,
	  2 type		fixed bin,
	  2 value		fixed bin,
	  2 char		char (256) varying;

declare	res		fixed bin;
declare	dst		bit (3) init ("0"b);
declare	currsign		char (1);
declare	objsign		char (1);
declare	char1		char (1);
declare	alf_name		char (32) varying;

declare	1 pcs,					/* program collating sequence */
	  2 type		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 num		fixed bin,
	  2 name		char (32) varying;

declare	cobol_set_type40_$ebcdic
			entry (ptr);
declare	cobol_imp_word$device_name
			entry (ptr) returns (fixed bin);
declare	cobol_imp_word$printer_control
			entry (ptr) returns (fixed bin);
declare	cobol_imp_word$computer_name
			entry (ptr) returns (fixed bin);
declare	cobol_imp_word$imp_word
			entry (ptr) returns (fixed bin);
declare	cobol_imp_word$file_org
			entry (ptr) returns (fixed bin);
declare	cobol_imp_word$disp_type
			entry (ptr) returns (fixed bin);
declare	cobol_imp_word$comp_type
			entry (ptr) returns (fixed bin);
declare	cobol_imp_word$alphabet_name
			entry (ptr) returns (fixed bin);
declare	cobol_imp_word$switch_name
			entry (ptr) returns (fixed bin);
declare	cobol_imp_word$io_technique
			entry (ptr) returns (fixed bin);

%include cobol_;
%include cobol_ext_;
%include cobol_fixed_common;
%include cobol_file_table;
%include cobol_file_key;
%include cobol_type1;
%include cobol_type2;
%include cobol_type3;
declare	1 user_word	based (p2),
%include cobol_TYPE8;
declare	1 alphabet_name	based (alpha_ptr),
%include cobol_TYPE40;
%include cobol_type17;

     end;
