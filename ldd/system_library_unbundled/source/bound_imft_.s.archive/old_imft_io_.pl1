/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   *********************************************************** */


/* I/O module to transmit files between Multics sites using I/O daemon record oriented communications modules */

/* Created:  October 1980 by G. Palter */
/* Modified: April 1982 by G. Palter to greatly simplify attach description and internal operation */
/* Modified: 26 July 1982 by G. Palter to add get_channel_names control order */
/* Modified: February 1983 by Robert Coren to change from imft_io_ to old_imft_io_ */

/* format: style4,delnl,insnl,ifthenstmt,ifthen */


old_imft_io_:
     procedure ();
	return;					/* not an entry */


/* Parameters */

dcl  P_iocb_ptr pointer parameter;			/* *: -> I/O switch being operated upon */
dcl  P_code fixed binary (35) parameter;

dcl  P_attach_options (*) character (*) varying parameter;	/* attach: attachment arguments */
dcl  P_loud_sw bit (1) parameter;			/* attach: ON => attachment errors should call com_err_ */

dcl  P_open_mode fixed binary parameter;		/* open: opening mode */
dcl  P_open_sw bit (1) parameter;			/* open: obsolete parameter */

dcl  P_data_lth fixed binary (21) parameter;		/* get_*: set to # of characters read into buffer;
						   put_chars: # of characters to transmit as logical record */

dcl  P_buffer_ptr pointer parameter;			/* get_*: -> area to place result of read */
dcl  P_buffer_max_lth fixed binary (21) parameter;	/* get_*: size of area in characters */

dcl  P_data_ptr pointer parameter;			/* put_chars: -> data stream to be written */

dcl  P_order character (*) parameter;			/* control: name of control order to be performed */
dcl  P_info_ptr pointer parameter;			/* control: -> additional information required to execute the
						   control order */

dcl  P_new_modes character (*) parameter;		/* modes: new modes to be set */
dcl  P_old_modes character (*) parameter;		/* modes: set to modes in effect before change */


/* Local copies of parameters */

dcl  iocb_ptr pointer;
dcl  code fixed binary (35);

dcl  argument character (argument_lth) based (argument_ptr);/* based on attach options */
dcl  argument_lth fixed binary (21);
dcl  argument_ptr pointer;

dcl  loud_sw bit (1) aligned;

dcl  open_mode fixed binary;

dcl  buffer_lth fixed binary (21);

dcl  order character (32);
dcl  info_ptr pointer;


/* Remaining declarations */

dcl  1 local_tgci aligned like tty_get_channel_info;	/* for get_channel_names */

dcl  system_area area aligned based (system_area_ptr);
dcl  system_area_ptr pointer;

dcl  argument_idx fixed binary;			/* # of attach option being processed */

dcl  direction character (32);
dcl  (input_description_idx, output_description_idx) fixed binary;

dcl  an_attach_description character (512);

dcl  terminal_switch_name character (32);
dcl  terminal_iocb_ptr pointer;
dcl  terminal_attach_count fixed binary static initial (0);
dcl  terminal_attach_count_pic picture "999";

dcl  ips_mask bit (36);

dcl  local_record_type fixed binary;

dcl  IMFT_IO_ character (32) static options (constant) initial ("old_imft_io_");

dcl  N_BITS_PER_CHARACTER fixed binary static options (constant) initial (9);

dcl  RELATIVE_SECONDS bit (2) static options (constant) initial ("11"b);
dcl  ONE_MINUTE fixed binary (71) static options (constant) initial (60);

dcl  SP character (1) static options (constant) initial (" ");

/* format: off */
dcl (error_table_$action_not_performed, error_table_$badopt, error_table_$bad_arg, error_table_$bad_conversion,
     error_table_$bad_mode, error_table_$eof_record, error_table_$improper_data_format, error_table_$invalid_read,
     error_table_$invalid_write, error_table_$noarg, error_table_$no_operation, error_table_$not_attached,
     error_table_$not_closed, error_table_$not_detached, error_table_$not_open, error_table_$null_info_ptr,
     error_table_$short_record, error_table_$undefined_order_request, error_table_$unimplemented_version)
	fixed binary (35) external;

dcl (imft_et_$cant_get_channel_names, imft_et_$reply_pending, imft_et_$timeout)
	fixed binary (35) external;
/* format: on */

dcl  add_bit_offset_ entry (pointer, fixed binary (24)) returns (pointer);
dcl  com_err_ entry () options (variable);
dcl  continue_to_signal_ entry (fixed binary (35));
dcl  cu_$arg_list_ptr entry () returns (pointer);
dcl  cu_$arg_ptr entry (fixed binary, pointer, fixed binary (21), fixed binary (35));
dcl  cv_dec_check_ entry (character (*), fixed binary (35)) returns (fixed binary (35));
dcl  get_system_free_area_ entry () returns (pointer);
dcl  hcs_$reset_ips_mask entry (bit (36), bit (36));
dcl  hcs_$set_ips_mask entry (bit (36), bit (36));
dcl  ioa_$general_rs entry (pointer, fixed binary, fixed binary, character (*), fixed binary (21), bit (1), bit (1));
dcl  iox_$attach_ioname entry (character (*), pointer, character (*), fixed binary (35));
dcl  iox_$control entry (pointer, character (*), pointer, fixed binary (35));
dcl  iox_$close entry (pointer, fixed binary (35));
dcl  iox_$destroy_iocb entry (pointer, fixed binary (35));
dcl  iox_$detach_iocb entry (pointer, fixed binary (35));
dcl  iox_$err_no_operation entry () options (variable);
dcl  iox_$open entry (pointer, fixed binary, bit (1) aligned, fixed binary (35));
dcl  iox_$propagate entry (pointer);
dcl  iox_$read_record entry (pointer, pointer, fixed binary (21), fixed binary (21), fixed binary (35));
dcl  iox_$write_record entry (pointer, pointer, fixed binary (21), fixed binary (35));
dcl  requote_string_ entry (character (*)) returns (character (*));
dcl  timer_manager_$alarm_call entry (fixed binary (71), bit (2), entry);
dcl  timer_manager_$reset_alarm_call entry (entry);

dcl  (any_other, cleanup, imft_debug_, imft_read_abort_, imft_write_abort_) condition;

dcl  (addr, collate, convert, currentsize, divide, hbound, lbound, length, ltrim, min, mod, null, rtrim, string, substr,
     verify, unspec) builtin;

/**/

/* Description of a switch attached through this module */

dcl  1 iad aligned based (iad_ptr),
       2 attach_description character (1024) varying,	/* attach description for this I/O switch */
       2 open_description character (24) varying,		/* open description for this I/O switch */
       2 input_switch like switch_info,			/* defines the input terminal switch */
       2 output_switch like switch_info,		/* defines the output terminal switch */
       2 abort_code fixed binary (35),			/* status code of last aborted I/O operation */
       2 flags aligned,
         3 input_direction bit (1) unaligned,		/* ON => receives data from remote system */
         3 abort_in_progress bit (1) unaligned,		/* ON => last I/O operation failed */
         3 debug_mode bit (1) unaligned,		/* ON => trying to debug IMFT: stop on errors */
         3 pad bit (33) unaligned;

dcl  iad_ptr pointer;


/* Description of a single terminal level I/O switch */

dcl  1 switch_info aligned based (switch_info_ptr),
       2 terminal_iocb_ptr pointer,			/* -> IOCB for terminal level module */
       2 current_physical_record_type fixed binary,	/* type of record currently in buffer (if any) */
       2 current_physical_record_n_els fixed binary (24),	/* # of characters or bits in current record */
       2 current_physical_record_used fixed binary (24),	/* # of characters or bits already returned to caller */
       2 pad bit (36),
       2 tior,					/* terminal_io_record used for I/O */
         3 header like terminal_io_record.header,
         3 data character (IMFT_PHYSICAL_RECORD_LTH) unaligned;

dcl  switch_info_ptr pointer;

/**/

/* Physical record structure used to transmit data and control information */

dcl  1 imft_physical_record aligned based (ipr_ptr),
       2 pad1 bit (2) unaligned,
       2 record_type fixed binary (7) unaligned unsigned,	/* type of record: data or control */
       2 pad2 bit (2) unaligned,
       2 flags unaligned,
         3 binary bit (1) unaligned,			/* ON => binary data in record as 7-bit bytes */
         3 bolr bit (1) unaligned,			/* ON => this is first physical record of a logical record */
         3 eolr bit (1) unaligned,			/* ON => last physical record in logical record */
         3 pad3 bit (4) unaligned,
       2 n_els unaligned,				/* # of elements (characters or 7-bit bytes) */
         3 pad4 bit (2) unaligned,
         3 high_order bit (7) unaligned,
         3 pad5 bit (2) unaligned,
         3 low_order bit (7) unaligned,
       2 data character (IMFT_PHYSICAL_RECORD_DATA_LTH) unaligned;
						/* the actual data */

dcl  1 ipr_data_overlay unaligned based (addr (imft_physical_record.data)),
       2 elements (IMFT_PHYSICAL_RECORD_DATA_LTH) unaligned,/* 7-bit bytes of binary data unpacked in 9 bits */
         3 pad1 bit (2) unaligned,
         3 byte bit (7) unaligned;

dcl  ipr_ptr pointer;

dcl  (
     IMFT_PHYSICAL_RECORD_LTH initial (80),		/* size of each physical record */
     IMFT_PHYSICAL_RECORD_DATA_LTH initial (76),		/* # of bytes of user's data in each record */
     IMFT_PHYSICAL_RECORD_DATA_BITS_LTH initial (532)	/* # of bits of user's data in each record for binary data */
     ) fixed binary static options (constant);

/**/

/* Attach an I/O switch for file transfer */

old_imft_io_attach:
     entry (P_iocb_ptr, P_attach_options, P_loud_sw, P_code);

	iocb_ptr = P_iocb_ptr;
	loud_sw = P_loud_sw;
	code = 0;

	iad_ptr = null ();				/* avoid freeing garbage if I/O switch already attached */

	if iocb_ptr -> iocb.attach_descrip_ptr ^= null () then do;
	     P_code = error_table_$not_detached;
	     if loud_sw then call com_err_ (P_code, IMFT_IO_, "For switch ^a.", iocb_ptr -> iocb.name);
	     return;
	end;

	system_area_ptr = get_system_free_area_ ();

	on condition (cleanup) call cleanup_attachment ((0));


/* Process attachment options */

	if hbound (P_attach_options, 1) < 1 then
	     call abort_attachment (error_table_$noarg,
		"""-direction"", ""-input_description"", and ""-output_description"" must be supplied.");

	allocate iad in (system_area) set (iad_ptr);
	iad.input_switch.terminal_iocb_ptr,		/* keeps cleanup handler happy */
	     iad.output_switch.terminal_iocb_ptr = null ();

	direction = "";				/* haven't seen -direction yet */
	input_description_idx = 0;			/* haven't seen -input_description yet */
	output_description_idx = 0;			/* haven't seen -output_description yet */
	iad.debug_mode = "0"b;			/* haven't seen -debug yet */

	iad.attach_description = "";
	iad.open_description = "";


	do argument_idx = lbound (P_attach_options, 1) to hbound (P_attach_options, 1);

	     argument_ptr = substraddr (P_attach_options (argument_idx), 1);
	     argument_lth = length (P_attach_options (argument_idx));

	     if argument = "-direction" then do;
		direction = get_string_argument ();
		if (direction ^= "input") & (direction ^= "output") then
		     call abort_attachment (error_table_$bad_arg,
			"-direction must be followed by ""input"" or ""output""; not ""^a"".", direction);
	     end;

	     else if (argument = "-input_description") | (argument = "-ids") then do;
		an_attach_description = get_string_argument ();
		input_description_idx = argument_idx;
	     end;

	     else if (argument = "-output_description") | (argument = "-ods") then do;
		an_attach_description = get_string_argument ();
		output_description_idx = argument_idx;
	     end;

	     else if argument = "-debug" then iad.debug_mode = "1"b;

	     else call abort_attachment (error_table_$badopt, """^a""", argument);
	end;

	if direction = "" then call abort_attachment (error_table_$noarg, "-direction");

	if input_description_idx = 0 then call abort_attachment (error_table_$noarg, "-input_description");

	if output_description_idx = 0 then call abort_attachment (error_table_$noarg, "-output_description");


/* Construct our attach description */

	iad.attach_description = rtrim (IMFT_IO_);

	iad.attach_description = iad.attach_description || " -direction ";
	iad.attach_description = iad.attach_description || rtrim (direction);

	argument_ptr = substraddr (P_attach_options (input_description_idx), 1);
	argument_lth = length (P_attach_options (input_description_idx));
	iad.attach_description = iad.attach_description || " -input_description ";
	iad.attach_description = iad.attach_description || requote_string_ (argument);

	argument_ptr = substraddr (P_attach_options (output_description_idx), 1);
	argument_lth = length (P_attach_options (output_description_idx));
	iad.attach_description = iad.attach_description || " -output_description ";
	iad.attach_description = iad.attach_description || requote_string_ (argument);


/* Attach through the terminal level */

	iad.input_direction = (direction = "input");

	terminal_attach_count = terminal_attach_count + 1;
	if terminal_attach_count > 999 then terminal_attach_count = 1;

	terminal_switch_name =
	     rtrim (IMFT_IO_) || ".input." || ltrim (convert (terminal_attach_count_pic, terminal_attach_count));

	call iox_$attach_ioname (terminal_switch_name, terminal_iocb_ptr, (P_attach_options (input_description_idx)),
	     code);
	if code ^= 0 then
	     call abort_attachment (code, "Unable to attach input channel via: ^a",
		P_attach_options (input_description_idx));

	iad.input_switch.terminal_iocb_ptr = terminal_iocb_ptr;


	terminal_switch_name =
	     rtrim (IMFT_IO_) || ".output." || ltrim (convert (terminal_attach_count_pic, terminal_attach_count));

	call iox_$attach_ioname (terminal_switch_name, terminal_iocb_ptr, (P_attach_options (output_description_idx)),
	     code);
	if code ^= 0 then
	     call abort_attachment (code, "Unable to attach output channel via: ^a",
		P_attach_options (output_description_idx));

	iad.output_switch.terminal_iocb_ptr = terminal_iocb_ptr;


/* Initialize the input and output terminal switch structures */

	iad.input_switch.current_physical_record_type, iad.output_switch.current_physical_record_type = -1;
	iad.input_switch.current_physical_record_n_els, iad.output_switch.current_physical_record_n_els = 0;
	iad.input_switch.current_physical_record_used, iad.output_switch.current_physical_record_used = 0;

	iad.input_switch.tior.version, iad.output_switch.tior.version = terminal_io_record_version_1;

	iad.input_switch.tior.device_type = READER_DEVICE;
	iad.output_switch.tior.device_type = PUNCH_DEVICE;

	iad.input_switch.tior.slew_type, iad.output_switch.tior.slew_type = SLEW_BY_COUNT;
	iad.input_switch.tior.slew_count, iad.output_switch.tior.slew_count = 1;

	string (iad.input_switch.tior.flags), string (iad.output_switch.tior.flags) = ""b;

	iad.input_switch.tior.element_size, iad.output_switch.tior.element_size = N_BITS_PER_CHARACTER;
	iad.input_switch.tior.n_elements, iad.output_switch.tior.n_elements = IMFT_PHYSICAL_RECORD_LTH;

	iad.abort_in_progress = "0"b;			/* didn't encounter any errors yet */
	iad.abort_code = 0;


/* Mask and complete construction of the IOCB */

	ips_mask = ""b;

	on condition (any_other) call any_other_handler ();

	call hcs_$set_ips_mask (((36)"0"b), ips_mask);

	iocb_ptr -> iocb.attach_descrip_ptr = addr (iad.attach_description);
	iocb_ptr -> iocb.attach_data_ptr = iad_ptr;
	iocb_ptr -> iocb.open = imft_io_open;
	iocb_ptr -> iocb.detach_iocb = imft_io_detach;

	call iox_$propagate (iocb_ptr);

	call hcs_$reset_ips_mask (ips_mask, ips_mask);

RETURN_FROM_ATTACH:
	P_code = code;
	return;

/**/

/* Open an I/O switch for file transfer */

imft_io_open:
     entry (P_iocb_ptr, P_open_mode, P_open_sw, P_code);

	iocb_ptr = P_iocb_ptr -> iocb.actual_iocb_ptr;
	iad_ptr = iocb_ptr -> iocb.attach_data_ptr;

	if iocb_ptr -> iocb.open_descrip_ptr ^= null () then do;
	     P_code = error_table_$not_closed;
	     return;
	end;

	open_mode = P_open_mode;

	if ^((iad.input_direction & (open_mode = Stream_input)) | (^iad.input_direction & (open_mode = Stream_output)))
	then do;					/* opening mode and direction must agree */
	     P_code = error_table_$bad_mode;
	     return;
	end;

	call iox_$open (iad.input_switch.terminal_iocb_ptr, Sequential_input, "0"b, P_code);
	if P_code ^= 0 then return;

	call iox_$open (iad.output_switch.terminal_iocb_ptr, Sequential_output, "0"b, P_code);
	if P_code ^= 0 then do;			/* must close the other one to stay happy */
	     call iox_$close (iad.input_switch.terminal_iocb_ptr, (0));
	     return;
	end;

	iad.open_description = rtrim (iox_modes (open_mode));

	ips_mask = ""b;

	on condition (any_other) call any_other_handler ();

	call hcs_$set_ips_mask (((36)"0"b), ips_mask);

	if iad.input_direction then
	     iocb_ptr -> iocb.get_chars, iocb_ptr -> iocb.get_line = imft_io_get_chars;
	else iocb_ptr -> iocb.put_chars = imft_io_put_chars;

	iocb_ptr -> iocb.control = imft_io_control;
	iocb_ptr -> iocb.modes = imft_io_modes;

	iocb_ptr -> iocb.close = imft_io_close;
	iocb_ptr -> iocb.detach_iocb = imft_io_detach;

	iocb_ptr -> iocb.open_descrip_ptr = addr (iad.open_description);
						/* it's now open */

	call iox_$propagate (iocb_ptr);

	call hcs_$reset_ips_mask (ips_mask, ips_mask);

	P_code = 0;
	return;

/**/

/* Close an I/O switch used for file transfer */

imft_io_close:
     entry (P_iocb_ptr, P_code);

	iocb_ptr = P_iocb_ptr -> iocb.actual_iocb_ptr;
	iad_ptr = iocb_ptr -> iocb.attach_data_ptr;
	code = 0;

	if iocb_ptr -> iocb.open_descrip_ptr = null () then do;
	     P_code = error_table_$not_open;
	     return;
	end;

	call iox_$close (iad.output_switch.terminal_iocb_ptr, code);
	if (code = error_table_$not_open) | (code = error_table_$not_attached) then code = 0;

	call iox_$close (iad.input_switch.terminal_iocb_ptr, code);
	if (code = error_table_$not_open) | (code = error_table_$not_attached) then code = 0;

	ips_mask = ""b;

	on condition (cleanup) call any_other_handler ();

	call hcs_$set_ips_mask (((36)"0"b), ips_mask);

	iocb_ptr -> iocb.open_descrip_ptr = null ();

	iocb_ptr -> iocb.open = imft_io_open;
	iocb_ptr -> iocb.detach_iocb = imft_io_detach;

	iocb_ptr -> iocb.control, iocb_ptr -> iocb.modes, iocb_ptr -> iocb.get_chars, iocb_ptr -> iocb.get_line,
	     iocb_ptr -> iocb.put_chars = iox_$err_no_operation;

	call iox_$propagate (iocb_ptr);

	call hcs_$reset_ips_mask (ips_mask, ips_mask);

	P_code = code;

	return;

/**/

/* Detach an I/O switch from file transfer */

imft_io_detach:
     entry (P_iocb_ptr, P_code);

	iocb_ptr = P_iocb_ptr;
	code = 0;

	if iocb_ptr -> iocb.attach_descrip_ptr = null () then do;
	     P_code = error_table_$not_attached;
	     return;
	end;

	if iocb_ptr -> iocb.open_descrip_ptr ^= null () then do;
	     P_code = error_table_$not_closed;
	     return;
	end;

	system_area_ptr = get_system_free_area_ ();

	iad_ptr = iocb_ptr -> iocb.attach_data_ptr;

	call cleanup_attachment (code);

	ips_mask = ""b;

	on condition (any_other) call any_other_handler ();

	call hcs_$set_ips_mask (((36)"0"b), ips_mask);

	iocb_ptr -> iocb.attach_descrip_ptr = null ();	/* it's detached */

	call iox_$propagate (iocb_ptr);

	call hcs_$reset_ips_mask (ips_mask, ips_mask);

	P_code = code;				/* in case trouble freeing the channel */
	return;

/**/

/* Write data records to the remote Multics: formats the user's data stream into IMFT physical records and
   transmits them to the remote Multics.  The IMFT physical record format is designed so that one put_chars call on this
   system will be converted into one get_chars (or get_line) call on the remote.  If any errors are detected while
   writing, this I/O module signals the "imft_write_abort_" condition which imft_transmit_object_ handles through the
   "get_abort_info" control order */

imft_io_put_chars:
     entry (P_iocb_ptr, P_data_ptr, P_data_lth, P_code);

	iocb_ptr = P_iocb_ptr -> iocb.actual_iocb_ptr;
	iad_ptr = iocb_ptr -> iocb.attach_data_ptr;
	code = 0;

	if iad.input_direction then do;		/* can't write the input side of a pipe */
	     P_code = error_table_$invalid_write;
	     return;
	end;

	call transmit_logical_data_record (IMFT_DATA, P_data_ptr, P_data_lth);
						/* does the actual work */

	P_code = code;
	return;

/**/

/* Read data records from the remote Multics:  reads requested number of data characters from the remote system.
   Data is read until either the user's buffer is filled or a control record is encountered.  If a control record is read
   before any data is found or an I/O error occurs during a read, the condition "imft_read_abort_" is signalled which is
   recognized by the caller.  The reason for the termination of the read request can be determined by the "get_abort_info"
   control order */

imft_io_get_chars:
     entry (P_iocb_ptr, P_buffer_ptr, P_buffer_max_lth, P_data_lth, P_code);

	iocb_ptr = P_iocb_ptr -> iocb.actual_iocb_ptr;
	iad_ptr = iocb_ptr -> iocb.attach_data_ptr;

	if ^iad.input_direction then do;		/* attempt to read the "punch" */
	     P_code = error_table_$invalid_read;
	     return;
	end;

	call receive_logical_data_records (P_buffer_ptr, P_buffer_max_lth, P_data_lth);

	P_code = 0;				/* here iff successful */
	return;

/**/

/* Perform control operations on an I/O switch attached for file transfer */

imft_io_control:
     entry (P_iocb_ptr, P_order, P_info_ptr, P_code);

	iocb_ptr = P_iocb_ptr -> iocb.actual_iocb_ptr;
	iad_ptr = iocb_ptr -> iocb.attach_data_ptr;

	order = P_order;
	info_ptr = P_info_ptr;

	code = 0;


	if order = "write_command_record" then do;

/* Write a command record:  Commands are sent by an output driver to the remote system's input driver to instruct the
   input driver as to what it should do next (begin reception of an object, abort, synchronize, etc.) */

	     if info_ptr = null () then code = error_table_$null_info_ptr;

	     else if info_ptr -> icri.version ^= ICRI_VERSION_1 then code = error_table_$unimplemented_version;

	     else if iad.input_direction then		/* must be transmitting data */
		code = error_table_$invalid_write;

	     else do;
		icri_ptr = info_ptr;
		if icri.timeout > 0 then do;		/* trap no response */
		     call timer_manager_$alarm_call ((icri.timeout), RELATIVE_SECONDS, read_write_timeout);
		     on condition (cleanup) call timer_manager_$reset_alarm_call (read_write_timeout);
		end;
		call transmit_logical_control_record ((icri.record_type), icri.record_ptr, icri.record_lth, code);
		call timer_manager_$reset_alarm_call (read_write_timeout);
	     end;
	end;


	else if order = "read_command_record" then do;

/* Read a command record: any intervening data records are discarded */

	     if info_ptr = null () then code = error_table_$null_info_ptr;

	     else if info_ptr -> icri.version ^= ICRI_VERSION_1 then code = error_table_$unimplemented_version;

	     else if ^iad.input_direction then		/* must be receiving data to receive control records */
		code = error_table_$invalid_read;

	     else do;
		icri_ptr = info_ptr;
		if icri.timeout > 0 then do;		/* trap no response */
		     call timer_manager_$alarm_call ((icri.timeout), RELATIVE_SECONDS, read_write_timeout);
		     on condition (cleanup) call timer_manager_$reset_alarm_call (read_write_timeout);
		end;
		call receive_logical_control_record (icri.record_ptr, icri.record_max_lth, icri.record_lth,
		     icri.record_type, code);
		call timer_manager_$reset_alarm_call (read_write_timeout);
	     end;
	end;


	else if order = "write_reply_record" then do;

/* Write a reply record:  Reply records are often sent by an input driver in response to a command record and indicate the
   input driver's reasons for accepting or rejecting a command */

	     if info_ptr = null () then code = error_table_$null_info_ptr;

	     else if info_ptr -> icri.version ^= ICRI_VERSION_1 then code = error_table_$unimplemented_version;

	     else if ^iad.input_direction then		/* must be receive side of a connection */
		code = error_table_$invalid_write;

	     else do;
		icri_ptr = info_ptr;
		if icri.timeout > 0 then do;		/* trap no response */
		     call timer_manager_$alarm_call ((icri.timeout), RELATIVE_SECONDS, read_write_timeout);
		     on condition (cleanup) call timer_manager_$reset_alarm_call (read_write_timeout);
		end;
		call transmit_logical_control_record ((icri.record_type), icri.record_ptr, icri.record_lth, code);
		call timer_manager_$reset_alarm_call (read_write_timeout);
	     end;
	end;


	else if order = "read_reply_record" then do;

/* Read a reply record */

	     if info_ptr = null () then code = error_table_$null_info_ptr;

	     else if info_ptr -> icri.version ^= ICRI_VERSION_1 then code = error_table_$unimplemented_version;

	     else if iad.input_direction then		/* must be transmitting side of connection */
		code = error_table_$invalid_read;

	     else do;
		icri_ptr = info_ptr;
		if icri.timeout > 0 then do;		/* trap no response */
		     call timer_manager_$alarm_call ((icri.timeout), RELATIVE_SECONDS, read_write_timeout);
		     on condition (cleanup) call timer_manager_$reset_alarm_call (read_write_timeout);
		end;
		call receive_logical_control_record (icri.record_ptr, icri.record_max_lth, icri.record_lth,
		     icri.record_type, code);
		call timer_manager_$reset_alarm_call (read_write_timeout);
	     end;
	end;


	else if order = "get_abort_info" then do;

/* Return cause of previous get_chars or put_chars failure */

	     if info_ptr = null () then code = error_table_$null_info_ptr;

	     else if info_ptr -> icri.version ^= ICRI_VERSION_1 then code = error_table_$unimplemented_version;

	     else do;
		icri_ptr = info_ptr;

		if iad.abort_in_progress then do;	/* something did indeed go wrong */
		     iad.abort_in_progress = "0"b;

		     if (iad.abort_code ^= 0) & (iad.abort_code ^= imft_et_$reply_pending) then do;
						/* I/O error during read/write */
			icri.record_type = IMFT_ABORT;
			abort_command_ptr = icri.record_ptr;
			abort_command.reason = IMFT_ABORT_IO_ERROR;
			abort_command.code = iad.abort_code;
			icri.record_lth = 4 * currentsize (abort_command);
		     end;				/* let caller see exact error */

		     else do;			/* encountered a control record: return it */
			call timer_manager_$alarm_call (ONE_MINUTE, RELATIVE_SECONDS, read_write_timeout);
			on condition (cleanup) call timer_manager_$reset_alarm_call (read_write_timeout);
			call receive_logical_control_record (icri.record_ptr, icri.record_max_lth, icri.record_lth,
			     icri.record_type, code);
			call timer_manager_$reset_alarm_call (read_write_timeout);
		     end;
		end;

		else code = error_table_$no_operation;	/* no abort was happening */
	     end;
	end;


	else if order = "get_channel_names" then do;

/* Return the names of the channels attached through this switch */

	     if info_ptr = null () then code = error_table_$null_info_ptr;

	     else if info_ptr -> get_channel_names.version ^= GET_CHANNEL_NAMES_VERSION_1 then
		code = error_table_$unimplemented_version;

	     else do;
		get_channel_names_ptr = info_ptr;
		local_tgci.version = tty_get_channel_info_version;

		call iox_$control (iad.input_switch.terminal_iocb_ptr, "get_channel_info", addr (local_tgci), code);

		if code = 0 then do;		/* got the input channel ... */
		     get_channel_names.input_channel = local_tgci.channel_name;
		     call iox_$control (iad.output_switch.terminal_iocb_ptr, "get_channel_info", addr (local_tgci),
			code);
		     if code = 0 then		/* ... and got the output channel */
			get_channel_names.output_channel = local_tgci.channel_name;
		end;

		if code ^= 0 then			/* couldn't get one of the channel names */
		     if code = error_table_$undefined_order_request then code = imft_et_$cant_get_channel_names;
	     end;
	end;


	else if (order = "read_status") | (order = "resetread") then
	     call iox_$control (iad.input_switch.terminal_iocb_ptr, order, info_ptr, code);
						/* always apply these to the input connection */

	else if (order = "write_status") | (order = "resetwrite") | (order = "runout") then
	     call iox_$control (iad.output_switch.terminal_iocb_ptr, order, info_ptr, code);
						/* always apply these to the output connection */

	else if order = "abort" then do;		/* always apply this to both switches */
	     call iox_$control (iad.input_switch.terminal_iocb_ptr, order, info_ptr, code);
	     call iox_$control (iad.output_switch.terminal_iocb_ptr, order, info_ptr, code);
	end;

	else do;					/* pass others on to the appropriate half of the connection */
	     if iad.input_direction then
		call iox_$control (iad.input_switch.terminal_iocb_ptr, order, info_ptr, code);
	     else call iox_$control (iad.output_switch.terminal_iocb_ptr, order, info_ptr, code);
	end;

RETURN_FROM_IMFT_CONTROL:
	P_code = code;

	return;

/**/

/* Internal procedure which is invoked when a read/write of a command/reply record times out */

read_write_timeout:
     procedure ();

	code = imft_et_$timeout;

	if iad.debug_mode then			/* give the programmer a chance when debugging */
	     signal condition (imft_debug_);

	go to RETURN_FROM_IMFT_CONTROL;

     end read_write_timeout;

/**/

/* Change modes: no modes are supported */

imft_io_modes:
     entry (P_iocb_ptr, P_new_modes, P_old_modes, P_code);

	iocb_ptr = P_iocb_ptr -> iocb.actual_iocb_ptr;
	P_old_modes = "";				/* no modes are reflected to caller */

	if P_new_modes = "" then
	     P_code = 0;
	else P_code = error_table_$bad_mode;

	return;

/**/

/* Cleanup whatever portion of an attachment exists */

cleanup_attachment:
     procedure (P_code);

dcl  P_code fixed binary (35) parameter;		/* a parameter to allow callers to ignore it */

	P_code = 0;

	if iad_ptr ^= null () then do;		/* there is an I/O switch */

	     if iad.input_switch.terminal_iocb_ptr ^= null () then do;
		call iox_$close (iad.input_switch.terminal_iocb_ptr, (0));
		call iox_$detach_iocb (iad.input_switch.terminal_iocb_ptr, P_code);
		call iox_$destroy_iocb (iad.input_switch.terminal_iocb_ptr, (0));
		iad.input_switch.terminal_iocb_ptr = null ();
	     end;

	     if iad.output_switch.terminal_iocb_ptr ^= null () then do;
		call iox_$close (iad.output_switch.terminal_iocb_ptr, (0));
		call iox_$detach_iocb (iad.output_switch.terminal_iocb_ptr, P_code);
		call iox_$destroy_iocb (iad.output_switch.terminal_iocb_ptr, (0));
		iad.output_switch.terminal_iocb_ptr = null ();
	     end;

	     free iad in (system_area);
	     iad_ptr = null ();

	end;

	return;

     end cleanup_attachment;

/**/

/* Wrapper to protect against errors while IPS interrupts are masked */

any_other_handler:
     procedure () options (non_quick);

	if ips_mask then call hcs_$reset_ips_mask (ips_mask, ips_mask);
	ips_mask = ""b;

	call continue_to_signal_ ((0));		/* not interested, */

	return;

     end any_other_handler;



/* Abort a call to the attach entry:  print an error message if requested */

abort_attachment:
     procedure () options (variable, non_quick);

dcl  the_code fixed binary (35) based (the_code_ptr);
dcl  the_code_ptr pointer;

dcl  caller_message character (256);

	call cu_$arg_ptr (1, the_code_ptr, (0), (0));

	if loud_sw then do;				/* an error message is requested */
	     call ioa_$general_rs (cu_$arg_list_ptr (), 2, 3, caller_message, (0), "1"b, "0"b);
	     call com_err_ (the_code, IMFT_IO_, "For switch ^a: ^a", iocb_ptr -> iocb.name, caller_message);
	end;

	call cleanup_attachment ((0));		/* get rid of anything that was accomplished */

	if the_code = 0 then
	     code = error_table_$action_not_performed;
	else code = the_code;			/* save the error code */

	go to RETURN_FROM_ATTACH;

     end abort_attachment;

/**/

/* Fetch the next argument from the attach options and validate that it is a non-null character string */

get_string_argument:
     procedure () returns (character (*));

dcl  option_name character (32);

	option_name = argument;			/* about to move on to the next one */

	if argument_idx = hbound (P_attach_options, 1) then
	     call abort_attachment (error_table_$noarg, "Character string following ""^a"".", option_name);

	argument_idx = argument_idx + 1;

	argument_ptr = substraddr (P_attach_options (argument_idx), 1);
	argument_lth = length (P_attach_options (argument_idx));

	if argument = "" then
	     call abort_attachment (0, "Character string following ""^a"" must be non-null.", option_name);

	return (argument);

     end get_string_argument;

/**/

/* Transmit a logical record to the remote system as multiple physical records */

transmit_logical_record:
     procedure ();

	return;					/* not an entry */


/* Parameters */

dcl  P_logical_record_type fixed binary (7) unaligned unsigned parameter;
						/* type of record being transmitted */
dcl  P_logical_record_data_ptr pointer parameter;		/* -> the logical record */
dcl  P_logical_record_data_lth fixed binary (21) parameter; /* length of logical record in characters */

dcl  P_code fixed binary (35) parameter;		/* control: status code */


/* Remaining declarations */

dcl  logical_record_data character (logical_record_data_lth) unaligned based (logical_record_data_ptr);
dcl  logical_record_data_lth fixed binary (21);
dcl  logical_record_data_ptr pointer;

dcl  logical_record_data_bits bit (logical_record_data_n_bits) unaligned based (logical_record_data_ptr);
dcl  logical_record_data_bits_lth fixed binary (24);

dcl  bytes_array (n_bytes) bit (7) unaligned based (bytes_array_ptr);
dcl  n_bytes fixed binary;
dcl  bytes_array_ptr pointer;

dcl  1 trsi aligned like tty_read_status_info automatic;

dcl  put_chars_operation bit (1) aligned;		/* ON => iox_$put_chars (data records) */

dcl  (amount_sent, amount_left) fixed binary (24);	/* may hold bit counters */
dcl  amount_to_send fixed binary (14);
dcl  fb14uu fixed binary (14) unaligned unsigned;

dcl  based_character character (1) unaligned based;

dcl  idx fixed binary;



/* Transmit a data record: aborts by signalling imft_write_abort_ if an I/O error is encountered */

transmit_logical_data_record:
     entry (P_logical_record_type, P_logical_record_data_ptr, P_logical_record_data_lth);

	put_chars_operation = "1"b;
	go to TRANSMIT_COMMON;


/* Transmit a control record: any errors are reflected to the caller */

transmit_logical_control_record:
     entry (P_logical_record_type, P_logical_record_data_ptr, P_logical_record_data_lth, P_code);

	P_code = 0;
	put_chars_operation = "0"b;


TRANSMIT_COMMON:
	if ^iad.input_direction then do;		/* output side: check for unexpected replies */
	     trsi.input_pending = "0"b;		/* ... in case the next call fails */
	     call iox_$control (iad.input_switch.terminal_iocb_ptr, "read_status", addr (trsi), (0));
	     if trsi.input_pending then call abort_write_operation (imft_et_$reply_pending);
	end;

	logical_record_data_ptr = P_logical_record_data_ptr;
	logical_record_data_lth = P_logical_record_data_lth;

	terminal_io_record_ptr = addr (iad.output_switch.tior);
	ipr_ptr = addr (terminal_io_record.data);

	unspec (imft_physical_record) = ""b;		/* start out clean */

	imft_physical_record.record_type = P_logical_record_type;

	if logical_record_data_lth > 0 then
	     imft_physical_record.binary = (verify (logical_record_data, collate ()) ^= 0);

	amount_sent = 0;


	if logical_record_data_lth = 0 then do;		/* empty record: transmit header only */
	     imft_physical_record.bolr,		/* this is the entire logical record */
		imft_physical_record.eolr = "1"b;
	     call transmit_physical_record ();
	end;


	else if imft_physical_record.binary then do;

/* Binary data: unpack 7 bits at a time into 9 bit forming valid ASCII characters for transmission.  At some future time,
   support for binary transmission should be provided */

	     logical_record_data_bits_lth = N_BITS_PER_CHARACTER * logical_record_data_lth;

	     do while (amount_sent < logical_record_data_bits_lth);

		amount_left = logical_record_data_bits_lth - amount_sent;
		amount_to_send = min (amount_left, IMFT_PHYSICAL_RECORD_DATA_BITS_LTH);
						/* are using 7 bits per character */

		n_bytes = divide (amount_to_send + 6, 7, 17, 0);
		bytes_array_ptr = add_bit_offset_ (logical_record_data_ptr, (amount_sent));
						/* first bit to go into this record */
		do idx = 1 to n_bytes;
		     if idx = n_bytes then		/* special case last byte */
			if mod (amount_to_send, 7) ^= 0 then
			     unspec (substraddr (imft_physical_record.data, (idx)) -> based_character) =
				"00"b || substr (bytes_array (idx), 1, mod (amount_to_send, 7));
			else unspec (substraddr (imft_physical_record.data, (idx)) -> based_character) =
				"00"b || bytes_array (idx);
		     else unspec (substraddr (imft_physical_record.data, (idx)) -> based_character) =
			     "00"b || bytes_array (idx);
		end;

		fb14uu = amount_to_send;		/* record # of bits transmitted */
		imft_physical_record.n_els.high_order = substr (unspec (fb14uu), 1, 7);
		imft_physical_record.n_els.low_order = substr (unspec (fb14uu), 8, 7);

		if amount_sent = 0 then		/* first physical record of logical record */
		     imft_physical_record.bolr = "1"b;
		if amount_to_send = amount_left then	/* last physical record */
		     imft_physical_record.eolr = "1"b;

		call transmit_physical_record ();	/* zap! */

		amount_sent = amount_sent + amount_to_send;
	     end;
	end;


	else do;

/* Character only data */

	     do while (amount_sent < logical_record_data_lth);

		amount_left = logical_record_data_lth - amount_sent;
		amount_to_send = min (amount_left, IMFT_PHYSICAL_RECORD_DATA_LTH);
						/* determine how much to send now */
		imft_physical_record.data = substr (logical_record_data, (amount_sent + 1), amount_to_send);

		fb14uu = amount_to_send;		/* put # of characters in record into the record */
		imft_physical_record.n_els.high_order = substr (unspec (fb14uu), 1, 7);
		imft_physical_record.n_els.low_order = substr (unspec (fb14uu), 8, 7);

		if amount_sent = 0 then		/* first physical record of logical one */
		     imft_physical_record.bolr = "1"b;
		if amount_to_send = amount_left then	/* last physical record */
		     imft_physical_record.eolr = "1"b;

		call transmit_physical_record ();	/* zap! */

		amount_sent = amount_sent + amount_to_send;
	     end;
	end;

	if ^put_chars_operation then			/* here iff all written OK */
	     P_code = 0;

RETURN_FROM_TRANSMIT_LOGICAL_RECORD:
	return;



/* Internal to transmit_logical_record: transmits a single physical record to the remote system */

transmit_physical_record:
	procedure ();

dcl  saved_record_type fixed binary;
dcl  saved_binary_flag bit (1) aligned;
dcl  code fixed binary (35);

	     saved_record_type = imft_physical_record.record_type;
	     saved_binary_flag = imft_physical_record.binary;

	     terminal_io_record.element_size = 9;
	     terminal_io_record.n_elements = IMFT_PHYSICAL_RECORD_LTH;
						/* make sure they're still correct */

	     call iox_$write_record (iad.output_switch.terminal_iocb_ptr, terminal_io_record_ptr,
		(4 * currentsize (terminal_io_record)), code);
	     if code ^= 0 then call abort_write_operation (code);

	     unspec (imft_physical_record) = ""b;	/* start next record clean */
	     imft_physical_record.record_type = saved_record_type;
	     imft_physical_record.binary = saved_binary_flag;

	     return;				/* it won */

	end transmit_physical_record;



/* Internal to transmit_logical_record: aborts the current write operation */

abort_write_operation:
	procedure (p_code);

dcl  p_code fixed binary (35) parameter;

	     if put_chars_operation then do;		/* data stream: abort the operation completely */
		iad.abort_in_progress = "1"b;
		iad.abort_code = p_code;
SIGNAL_TRANSMISSION_FAILURE_FOREVER:
		signal condition (imft_write_abort_);
		go to SIGNAL_TRANSMISSION_FAILURE_FOREVER;
	     end;					/* imft_transmit_object_ shouldn't return */

	     else do;				/* writing a control record: reflect error to caller */
		P_code = p_code;
		go to RETURN_FROM_TRANSMIT_LOGICAL_RECORD;
	     end;

	end abort_write_operation;

     end transmit_logical_record;

/**/

/* Receive the contents of a logical record from the remote system */

receive_logical_record:
     procedure ();

	return;					/* not an entry */

dcl  P_buffer_ptr pointer parameter;			/* -> buffer to place record contents */
dcl  P_buffer_max_lth fixed binary (21) parameter;	/* maximum size of buffer (in characters) */
dcl  P_buffer_used fixed binary (21) parameter;		/* # of characters placed into buffer */

dcl  P_record_type fixed binary parameter;		/* control: set to type of control record found */
dcl  P_code fixed binary (35) parameter;		/* control: status cod */


/* Remaining declarations */

dcl  buffer bit (buffer_max_lth) unaligned based (buffer_ptr);
dcl  (buffer_used, buffer_max_lth) fixed binary (24);
dcl  buffer_ptr pointer;

dcl  buffer_as_chars character (P_buffer_max_lth) unaligned based (buffer_ptr);

dcl  1 byte_structure aligned,
       2 pad bit (2) unaligned,
       2 byte bit (7) unaligned;

dcl  get_chars_operation bit (1) aligned;		/* ON => reading data stream */
dcl  continue bit (1) aligned;

dcl  (space_left, amount_left, amount_to_copy, amount_done) fixed binary (24);
dcl  (characters_used, characters_to_copy) fixed binary (21);
dcl  byte_idx fixed binary (21);
dcl  n_bits_from_byte fixed binary;



/* Receive data records: aborts by signalling imft_read_abort_ if an I/O error is encountered or the previous read
   operation terminated with a control record */

receive_logical_data_records:
     entry (P_buffer_ptr, P_buffer_max_lth, P_buffer_used);

	get_chars_operation = "1"b;
	go to RECEIVE_COMMON;


/* Receive a control record: flushes all data records until a control record is found and returned */

receive_logical_control_record:
     entry (P_buffer_ptr, P_buffer_max_lth, P_buffer_used, P_record_type, P_code);

	P_record_type = -1;				/* haven't found it yet */
	P_code = 0;
	get_chars_operation = "0"b;


RECEIVE_COMMON:
	buffer_ptr = P_buffer_ptr;
	buffer_max_lth = N_BITS_PER_CHARACTER * P_buffer_max_lth;

	buffer_used = 0;

	terminal_io_record_ptr = addr (iad.input_switch.tior);
	ipr_ptr = addr (terminal_io_record.data);


	continue = "1"b;

	do while (continue);

	     if iad.input_switch.current_physical_record_type = -1 then
READ_ANOTHER_RECORD:
		call receive_physical_record ();

	     if iad.input_switch.current_physical_record_type = IMFT_DATA then
		if get_chars_operation then
		     ;				/* data record OK */
		else go to READ_ANOTHER_RECORD;	/* data records should be ignored */

	     else					/* control record ... */
		if get_chars_operation then		/* ... while reading data ... */
		if buffer_used = 0 then		/* ... is only fatal if first read */
		     call abort_read_operation (0);
		else go to END_OF_GET_CHARS;		/* in middle of stream: end of get_chars */

	     if ^get_chars_operation then		/* if reading control records ... */
		if P_record_type = -1 then		/* ... and haven't determined type yet */
		     P_record_type = iad.input_switch.current_physical_record_type;


	     if iad.input_switch.current_physical_record_n_els = 0 then ;
						/* nothing in this record to unpack or copy */


	     else if imft_physical_record.binary then do;

/* Binary data: pack low order 7-bits of each character into the caller's buffer as a continuous bit stream */

		if buffer_used < buffer_max_lth then do;

		     space_left = buffer_max_lth - buffer_used;
		     amount_left =
			iad.input_switch.current_physical_record_n_els
			- iad.input_switch.current_physical_record_used;
		     amount_to_copy = min (space_left, amount_left);

		     amount_done = 0;
		     do while (amount_done < amount_to_copy);
			byte_idx = divide (iad.input_switch.current_physical_record_used, 7, 17, 0) + 1;
			n_bits_from_byte = min ((amount_to_copy - amount_done), 7);
			unspec (byte_structure) = unspec (substr (imft_physical_record.data, byte_idx, 1));
			substr (buffer, (buffer_used + 1), n_bits_from_byte) =
			     substr (byte_structure.byte,
			     (mod (iad.input_switch.current_physical_record_used, 7) + 1), n_bits_from_byte);
			buffer_used = buffer_used + n_bits_from_byte;
			iad.input_switch.current_physical_record_used =
			     iad.input_switch.current_physical_record_used + n_bits_from_byte;
			amount_done = amount_done + n_bits_from_byte;
		     end;
		end;
	     end;


	     else do;

/* Character data: copy it to caller's buffer */

		call adjust_buffer_used ();		/* make sure it's integral # of characters */
		characters_used = divide ((buffer_used + N_BITS_PER_CHARACTER - 1), N_BITS_PER_CHARACTER, 21, 0);

		if buffer_used < buffer_max_lth then do;
		     space_left = buffer_max_lth - buffer_used;
		     amount_left =
			N_BITS_PER_CHARACTER
			* (iad.input_switch.current_physical_record_n_els
			- iad.input_switch.current_physical_record_used);
		     amount_to_copy = min (space_left, amount_left);
		     characters_to_copy =
			divide ((amount_to_copy + N_BITS_PER_CHARACTER - 1), N_BITS_PER_CHARACTER, 21, 0);
		     substr (buffer_as_chars, (characters_used + 1), characters_to_copy) =
			substr (imft_physical_record.data, (iad.input_switch.current_physical_record_used + 1),
			characters_to_copy);
		     buffer_used = buffer_used + amount_to_copy;
		     iad.input_switch.current_physical_record_used =
			iad.input_switch.current_physical_record_used + characters_to_copy;
		end;
	     end;

	     if iad.input_switch.current_physical_record_used >= iad.input_switch.current_physical_record_n_els then
		iad.input_switch.current_physical_record_type = -1;

	     if ^get_chars_operation & imft_physical_record.eolr then continue = "0"b;
						/* got it all */

	     continue = continue & (buffer_used < buffer_max_lth);
	end;

END_OF_GET_CHARS:
	call adjust_buffer_used ();			/* make sure it's integral # of characters */
	P_buffer_used = divide ((buffer_used + N_BITS_PER_CHARACTER - 1), N_BITS_PER_CHARACTER, 21, 0);


RETURN_FROM_RECEIVE_LOGICAL_RECORD:
	return;



/* Internal to receive_logical_record: receives a single physical record */

receive_physical_record:
	procedure ();

dcl  fb14uu fixed binary (14) unaligned unsigned;
dcl  code fixed binary (35);

	     terminal_io_record.element_size = 9;
	     terminal_io_record.n_elements = IMFT_PHYSICAL_RECORD_LTH;

	     call iox_$read_record (iad.input_switch.terminal_iocb_ptr, terminal_io_record_ptr,
		(4 * currentsize (terminal_io_record)), (0), code);
	     if code ^= 0 then call abort_read_operation (code);

	     if terminal_io_record.n_elements ^= IMFT_PHYSICAL_RECORD_LTH then
		call abort_read_operation (error_table_$short_record);

	     iad.input_switch.current_physical_record_type = imft_physical_record.record_type;

	     unspec (fb14uu) = imft_physical_record.n_els.high_order || imft_physical_record.n_els.low_order;
	     iad.input_switch.current_physical_record_n_els = fb14uu;
						/* record # of characters or bytes */

	     iad.input_switch.current_physical_record_used = 0;
						/* haven't taken any */

	     if imft_physical_record.bolr & ^get_chars_operation then
		if buffer_used ^= 0 then		/* missed end of control record */
		     call abort_read_operation (error_table_$improper_data_format);

	     return;

	end receive_physical_record;



/* Internal to receive_logical_record: aborts the current read operation */

abort_read_operation:
	procedure (p_code);

dcl  p_code fixed binary (35) parameter;

	     if get_chars_operation then do;		/* get_chars (data stream): signal imft_read_abort_ */
		iad.abort_in_progress = "1"b;
		iad.abort_code = p_code;
SIGNAL_RECEIVE_FAILURE_FOREVER:
		signal condition (imft_read_abort_);
		go to SIGNAL_RECEIVE_FAILURE_FOREVER;
	     end;

	     else do;				/* reading control record: return code to caller */
		P_code = p_code;
		go to RETURN_FROM_RECEIVE_LOGICAL_RECORD;
	     end;

	end abort_read_operation;



/* Internal to receive_logical_record: adjusts buffer_used to be an integral # of characters */

adjust_buffer_used:
	procedure ();

dcl  n_bits_to_zero fixed binary;

	     if mod (buffer_used, N_BITS_PER_CHARACTER) ^= 0 then do;

		n_bits_to_zero = N_BITS_PER_CHARACTER - mod (buffer_used, N_BITS_PER_CHARACTER);

		substr (buffer, (buffer_used + 1), n_bits_to_zero) = ""b;
						/* insure no garbage in buffer */
		buffer_used = buffer_used + n_bits_to_zero;
	     end;

	     return;

	end adjust_buffer_used;

     end receive_logical_record;

/**/

/* substraddr:  Return a pointer to the specified character of a varying or nonvarying string.  When the substraddr
   builtin function is finally implemented, these internal procedures should be removed */

dcl  substraddr
	generic (substraddr_nonvarying when (character (*) nonvarying, fixed binary precision (1:35)),
	substraddr_varying when (character (*) varying, fixed binary precision (1:35)));


substraddr_nonvarying:
     procedure (P_string, P_position) returns (pointer);

dcl  P_string character (*) nonvarying parameter;
dcl  P_position fixed binary (21) parameter;

dcl  string_overlay (length (P_string)) character (1) unaligned based (addr (P_string));

	return (addr (string_overlay (P_position)));

     end substraddr_nonvarying;


substraddr_varying:
     procedure (P_string, P_position) returns (pointer);

dcl  P_string character (*) varying parameter;
dcl  P_position fixed binary (21) parameter;

dcl  1 string_overlay aligned based (addr (P_string)),
       2 lth fixed binary (21),
       2 characters (0 refer (string_overlay.lth)) character (1) unaligned;

	return (addr (string_overlay.characters (P_position)));

     end substraddr_varying;

/**/

%include iocb;
%page;
%include iox_modes;
%page;
%include terminal_io_record;

%include tty_read_status_info;

%include tty_get_channel_info;
%page;
%include "_imft_cri";

%include "_imft_get_channel_names";
%page;
%include "_imft_std_commands";

     end old_imft_io_;
