/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        *********************************************************** */

/* Submits Inter-Multics File Transfer (IMFT) requests */

/* Created:  April 1982 by G. Palter */
/* Modified: 16 July 1982 by G. Palter to rename "-entry_name" to "-entryname" and correct the error message produced by
   "-target_pathname" when the target pathname is omitted */
/* Modified: March 1983 by Robert Coren to implement "-source" */


/****^  HISTORY COMMENTS:
  1) change(87-11-15,Oke), approve(88-08-01,MCR7948), audit(88-10-11,Farley),
     install(88-10-14,MR12.2-1165):
     Add support for -date_time_after, -skipped and -no_skipped.
  2) change(88-06-22,Beattie), approve(88-08-01,MCR7948),
     audit(88-10-11,Farley), install(88-10-14,MR12.2-1165):
     Add support for -delete, -no_delete, -extend, -replace and -update.
     Changed all access checks to look for explicit ACL entries.
                                                   END HISTORY COMMENTS */


/* format: style4,delnl,insnl,ifthenstmt,ifthen */

enter_imft_request:
eir:
     procedure () options (variable);

	call cu_$arg_count (n_arguments, code);
	if code ^= 0 then do;			/* not called as a command */
	     call com_err_ (code, ENTER_IMFT_REQUEST);
	     return;
	end;

	if n_arguments = 0 then do;			/* must be given some pathnames */
	     call com_err_$suppress_name (NO_ERROR, ENTER_IMFT_REQUEST, "Usage:  ^a transfer_specs {-control_args}",
		ENTER_IMFT_REQUEST);
	     return;
	end;


/* Establish defaults */

	found_transfer_spec = "0"b;			/* will need at least one of these */

	request_type = imft_default_rqt_ ();		/* tries to find the real name of the default request type */
	foreign_system = after (rtrim (request_type), "To_");
	if foreign_system = ""			/* name not of standard form */
	     then
	     foreign_system = rtrim (request_type);	/* so fake it */
	queue = 0;				/* use the default queue */

	include_files = "1"b;			/* default is to send matching files and subtrees */
	include_subtrees = "1"b;
	file_subtree_arg = "";

	chase_control = DEFAULT_CHASE;		/* chase non-starnames; don't chase starnames */

	long_mode = "1"b;				/* default is -long */
	long_id = "0"b;				/* default is -short_id */
	absolute_pathname = "0"b;			/* default is -entryname */
	notify = "1"b;				/* default is -notify */
	merge_directories = "1"b;			/* default is -merge_directories */
	remote = "0"b;				/* default -s -destination */
	foreign_user = "";				/* default is that user IDs are the same */

	delete_obj = "0"b;				/* default is to not delete */
	extend_seg = "0"b;				/* default is to replace */
	update_seg = "0"b;

	date_time_after = 0;			/* any date */
	list_skipped = "0"b;

	the_argument_list = cu_$arg_list_ptr ();


MAIN_EIR_BLOCK:
	begin;

dcl  is_pathname (n_arguments) bit (1) aligned;

	     is_pathname (*) = "0"b;			/* indicates which arguments are transfer_specs */


/* Scan the argument list, process all control arguments, and validate the syntax of supplied transfer_specs */

	     do argument_idx = 1 to n_arguments;

		call cu_$arg_ptr_rel (argument_idx, argument_ptr, argument_lth, code, the_argument_list);
		if code ^= 0 then do;
		     call com_err_ (code, ENTER_IMFT_REQUEST, "Accessing argument #^d.", argument_idx);
		     return;
		end;

		if index (argument, "-") = 1 then	/* a control argument */
		     if (argument = "-files") | (argument = "-file") | (argument = "-f") then do;
			include_files = "1"b;	/* files only, please */
			include_subtrees = "0"b;
			file_subtree_arg = argument;
		     end;

		     else if (argument = "-subtrees") | (argument = "-subtree") | (argument = "-subt") then do;
			include_subtrees = "1"b;	/* subtrees only, please */
			include_files = "0"b;
			file_subtree_arg = argument;
		     end;

		     else if argument = "-chase" then chase_control = ALWAYS_CHASE;
		     else if argument = "-no_chase" then chase_control = NEVER_CHASE;

		     else if (argument = "-destination") | (argument = "-ds") then do;
			remote = "0"b;
			go to FOREIGN_SYSTEM;
		     end;

		     else if (argument = "-source") | (argument = "-sc") then do;
			remote = "1"b;
FOREIGN_SYSTEM:
			call get_next_argument ("A system name", foreign_system);
			if remote then
			     request_type = "From_" || foreign_system;
			else request_type = "To_" || foreign_system;

			call iod_info_$generic_type (request_type, generic_type, code);
			if code ^= 0 then do;	/* couldn't lookup the specified destination */
INVALID_DESTINATION_SPECIFICATION:
			     if code = error_table_$id_not_found then
				call com_err_ (NO_ERROR, ENTER_IMFT_REQUEST,
				     "Unknown ^[source^;destination^].  ""^a""", remote, foreign_system);
			     else call com_err_ (code, ENTER_IMFT_REQUEST, "-^[source^;destination^] ""^a""",
				     remote, foreign_system);
			     return;
			end;
			if generic_type ^= FT_GENERIC_TYPE then do;
			     call com_err_ (NO_ERROR, ENTER_IMFT_REQUEST,
				"Unknown ^[source^;destination^].  ""^a""", remote, foreign_system);
			     return;
			end;
		     end;

		     else if (argument = "-queue") | (argument = "-q") then do;
			call get_next_argument ("A number", queue_string);
			queue = cv_dec_check_ (queue_string, code);
			if code ^= 0 then do;
INVALID_QUEUE_SPECIFICATION:
			     call com_err_ (NO_ERROR, ENTER_IMFT_REQUEST,
				"The queue must be a number between 1 and 4; not ""^a"".", queue_string);
			     return;
			end;
			if (queue < 1) | (queue > 4) then go to INVALID_QUEUE_SPECIFICATION;
		     end;				/* will check if queue is OK for destination later */

		     else if (argument = "-long") | (argument = "-lg") then long_mode = "1"b;
		     else if (argument = "-brief") | (argument = "-bf") then long_mode = "0"b;

		     else if (argument = "-long_id") | (argument = "-lgid") then long_id = "1"b;
		     else if (argument = "-short_id") | (argument = "-shid") then long_id = "0"b;

		     else if (argument = "-absolute_pathname") | (argument = "-absp") then absolute_pathname = "1"b;
		     else if (argument = "-entryname") | (argument = "-etnm") then absolute_pathname = "0"b;

		     else if (argument = "-notify") | (argument = "-nt") then notify = "1"b;
		     else if (argument = "-no_notify") | (argument = "-nnt") then notify = "0"b;

		     else if (argument = "-merge_directories") | (argument = "-mdr") then merge_directories = "1"b;
		     else if (argument = "-replace_directories") | (argument = "-rpdr") then merge_directories = "0"b;

		     else if (argument = "-foreign_user") | (argument = "-fu") then do;
			call get_next_argument ("A user ID", foreign_user);
			if after (foreign_user, ".") = "" then do;
INVALID_FOREIGN_USER_SPECIFICATION:
			     call com_err_ (NO_ERROR, ENTER_IMFT_REQUEST,
				"Foreign user must be of the form Person.Project; not ""^a"".", foreign_user);
			     return;
			end;
			if after (foreign_user, ".") = "*" then go to INVALID_FOREIGN_USER_SPECIFICATION;
			if before (foreign_user, ".") = "" then go to INVALID_FOREIGN_USER_SPECIFICATION;
			if before (foreign_user, ".") = "*" then go to INVALID_FOREIGN_USER_SPECIFICATION;
			if after (after (foreign_user, "."), ".") ^= "" then
			     go to INVALID_FOREIGN_USER_SPECIFICATION;
		     end;

		     else if (argument = "-target_pathname") | (argument = "-tpn") then do;
			call com_err_ (error_table_$noarg, ENTER_IMFT_REQUEST,
			     """^a"" must be preceded by a pathname.", argument);
			return;
		     end;

/* Process date_time_after, dtaf control */

		     else if (argument = "-date_time_after") | (argument = "-dtaf") then do;
			call get_next_argument ("date_time of last mod", date_time_after_string);
			call convert_date_to_binary_ (date_time_after_string, date_time_after, code);
			if code ^= 0 then do;
			     call com_err_ (code, ENTER_IMFT_REQUEST, "-dtaf time ""^a"" is not valid.",
				date_time_after_string);
			     return;
			end;
		     end;

		     else if (argument = "-skipped") | (argument = "-skpd") then list_skipped = "1"b;

		     else if (argument = "-no_skipped") | (argument = "-nskpd") then list_skipped = "0"b;

		     else if (argument = "-delete") | (argument = "-dl") then delete_obj = "1"b;
		     else if (argument = "-no_delete") | (argument = "-ndl") then delete_obj = "0"b;

		     else if (argument = "-extend") then do;
			extend_seg = "1"b;
			update_seg = "0"b;
			include_files = "1"b;
			include_subtrees = "0"b;
			file_subtree_arg = argument;
		     end;

		     else if (argument = "-replace") | (argument = "-rp") then do;
			extend_seg = "0"b;
			update_seg = "0"b;
			include_files = "1"b;
			file_subtree_arg = argument;
		     end;

		     else if (argument = "-update") | (argument = "-ud") then do;
			extend_seg = "0"b;
			update_seg = "1"b;
			include_files = "1"b;
			include_subtrees = "0"b;
			file_subtree_arg = argument;
		     end;

		     else do;			/* unrecognized control argument */
			call com_err_ (error_table_$badopt, ENTER_IMFT_REQUEST, """^a""", argument);
			return;
		     end;

		else do;				/* a transfer_spec: star_path {-tpn equal_path} */
		     found_transfer_spec = "1"b;
		     is_pathname (argument_idx) = "1"b; /* flag this for later */
		     call expand_pathname_ (argument, local_dirname, local_starname, code);
		     if code ^= 0 then do;
			call com_err_ (code, ENTER_IMFT_REQUEST, "^a", argument);
			return;
		     end;
		     call check_star_name_$entry (local_starname, code);
		     if (code ^= 0) & (code ^= 1) & (code ^= 2) then do;
			call com_err_ (code, ENTER_IMFT_REQUEST, "^a", pathname_ (local_dirname, local_starname));
			return;
		     end;
		     if argument_idx < n_arguments then do;
			call cu_$arg_ptr_rel ((argument_idx + 1), next_argument_ptr, next_argument_lth, code,
			     the_argument_list);	/* peek ahead for -tpn equal_path */
			if code ^= 0 then do;
			     call com_err_ (code, ENTER_IMFT_REQUEST, "Accessing argument #^d.", (argument_idx + 1))
				;
			     return;
			end;
			if (next_argument = "-target_pathname") | (next_argument = "-tpn") then do;
			     argument_idx = argument_idx + 1;
			     argument_ptr = next_argument_ptr;
			     argument_lth = next_argument_lth;
			     call get_next_argument ("A pathname", foreign_pathname);
			     call expand_pathname_ (foreign_pathname, foreign_dirname, foreign_equalname, code);
			     if code ^= 0 then do;
				call com_err_ (code, ENTER_IMFT_REQUEST, "-target_pathname ""^a""",
				     foreign_pathname);
				return;
			     end;
			     call get_equal_name_$check_equal_name_ (foreign_equalname, code);
			     if (code ^= 0) & (code ^= 1) & (code ^= 2) then do;
				call com_err_ (code, ENTER_IMFT_REQUEST, "-target_pathname ""^a""",
				     pathname_ (foreign_dirname, foreign_equalname));
				return;
			     end;
			end;
		     end;
		end;
	     end;

	     if ^found_transfer_spec then do;		/* nothing to transfer (sigh) */
		call com_err_ (error_table_$noarg, ENTER_IMFT_REQUEST, "At least one pathname must be supplied.");
		return;
	     end;

	     if (extend_seg | update_seg) & include_subtrees then do;
		call com_err_ (NO_ERROR, ENTER_IMFT_REQUEST,
		     "The ^[-extend^;-update^] control option cannot be used with the -subtree control option.",
		     extend_seg);
		return;
	     end;

	     call iod_info_$queue_data (request_type, default_queue, max_queues, code);
	     if code ^= 0 then go to INVALID_DESTINATION_SPECIFICATION;

	     if queue = 0 then queue = default_queue;	/* supply default if needed */
	     if queue > max_queues then do;		/* bad queue number for this request type */
		call com_err_ (NO_ERROR, ENTER_IMFT_REQUEST,
		     "^[Source^;Destination^] ^a has only ^d queue^[s^]; you specified queue ^d.", remote,
		     foreign_system, max_queues, (max_queues ^= 1), queue);
		return;
	     end;

	     call iod_info_$driver_access_name (request_type, driver_userid, code);
	     if code ^= 0 then go to INVALID_DESTINATION_SPECIFICATION;


/* Argument parsing completed: open the queue where we will enter the requests and validate our access */

	     system_area_ptr = get_system_free_area_ ();

	     queue_index = 0;			/* for cleanup handler */
	     skipped_count, n_requests_submitted = 0;
	     acl_ptr, star_entry_ptr, star_names_ptr = null ();

	     on condition (cleanup) call cleanup_handler ();

	     queue_ename = rtrim (request_type) || "_" || convert (queue_picture, queue) || ".ms";

	     call message_segment_$open (imft_data_$queue_dirname, queue_ename, queue_index, code);
	     if code ^= 0 then do;
		call com_err_ (code, ENTER_IMFT_REQUEST, "Opening ^a.",
		     pathname_ (imft_data_$queue_dirname, queue_ename));
		go to RETURN_FROM_ENTER_IMFT_REQUEST;
	     end;

	     call message_segment_$get_mode_index (queue_index, queue_mode, code);
	     if code ^= 0 then do;
		call com_err_ (code, ENTER_IMFT_REQUEST, "Determining access to ^a.",
		     pathname_ (imft_data_$queue_dirname, queue_ename));
		go to RETURN_FROM_ENTER_IMFT_REQUEST;
	     end;

	     if (queue_mode & AS_EXTENDED_ACCESS) = AS_EXTENDED_ACCESS then do;
		call message_segment_$get_message_count_index (queue_index, previous_queue_total, code);
		if code ^= 0 then do;
		     call com_err_ (code, ENTER_IMFT_REQUEST, "Determining number of messages in ^a.",
			pathname_ (imft_data_$queue_dirname, queue_ename));
		     go to RETURN_FROM_ENTER_IMFT_REQUEST;
		end;
		have_previous_queue_total = "1"b;
	     end;

	     else if (queue_mode & A_EXTENDED_ACCESS) = A_EXTENDED_ACCESS then have_previous_queue_total = "0"b;

	     else do;				/* not enough access at all */
		call com_err_ (NO_ERROR, ENTER_IMFT_REQUEST, "You do not have permission to use ^a queue ^d.",
		     request_type, queue);
		go to RETURN_FROM_ENTER_IMFT_REQUEST;
	     end;


/* Fill in constant portion of the ft_request */

	     unspec (local_ft_request) = ""b;

	     local_ft_request.header.hdr_version = queue_msg_hdr_version_1;
	     local_ft_request.header.message_type = FT_MESSAGE_TYPE;
	     local_ft_request.header.notify = notify;
	     local_ft_request.header.orig_queue = queue;
	     local_ft_request.header.std_length = currentsize (local_ft_request);

	     local_ft_request.version = FT_REQUEST_VERSION_1;
	     local_ft_request.delete = delete_obj;	/* daemon does deletions, not coordinator */
	     local_ft_request.extend = extend_seg;
	     local_ft_request.update = update_seg;

	     acl_count = 2;				/* one entry each for driver and user */
	     allocate general_acl in (system_area) set (acl_ptr);
	     general_acl.version = GENERAL_ACL_VERSION_1;
	     general_acl.count = acl_count;
	     general_acl (DRIVER_ACL_IDX).access_name = driver_userid;
	     general_acl (USER_ACL_IDX).access_name = get_group_id_$tag_star ();
	     imft_chk_acl.version = IMFT_CHECK_ACL_VERSION_1;
	     imft_chk_acl.foreign_sys_name = foreign_system;
	     imft_chk_acl.gen_acl_ptr = acl_ptr;
	     imft_chk_acl.effective_ring = get_ring_ ();
	     imft_chk_acl.check_aim = "0"b;		/* aim checking done by output daemon */
	     imft_chk_acl.accessfile_pathname = "";

	     if foreign_user ^= "" then do;		/* foreign user is different from local user */
		local_ft_request.foreign_user = foreign_user;
		local_ft_request.foreign_user_given = "1"b;
	     end;

	     if remote then do;			/* request for transfer from other system */
		local_ft_request.remote_transfer = "1"b;
		local_ft_request.include_files = include_files;
		local_ft_request.include_subtrees = include_subtrees;
		local_ft_request.chase_control = chase_control;
	     end;

/* Find each transfer_spec and submit the appropriate requests */

	     have_starname = "0"b;			/* until we know better */
	     do argument_idx = 1 to n_arguments;

		if is_pathname (argument_idx) then do;

		     call cu_$arg_ptr_rel (argument_idx, argument_ptr, argument_lth, ignore_code, the_argument_list);
		     call expand_pathname_ (argument, local_dirname, local_starname, ignore_code);

		     local_ft_request.foreign_path_given = "0"b;
		     if argument_idx < (n_arguments - 1) then do;
			call cu_$arg_ptr_rel (argument_idx + 1, argument_ptr, argument_lth, ignore_code,
			     the_argument_list);
			if (argument = "-target_pathname") | (argument = "-tpn") then do;
			     argument_idx = argument_idx + 2;
			     call cu_$arg_ptr_rel (argument_idx, argument_ptr, argument_lth, ignore_code,
				the_argument_list);
			     call expand_pathname_ (argument, foreign_dirname, foreign_equalname, ignore_code);
			     local_ft_request.foreign_path_given = "1"b;
			end;
		     end;

		     if ^remote then do;		/* if transferring from here, interpret starname */
			call check_star_name_$entry (local_starname, code);
			have_starname = (code ^= 0);

			if have_starname then do;	/* more than one object */
			     star_entry_ptr, star_names_ptr = null ();
			     skipped_a_request, submitted_a_request, printed_an_error_message = "0"b;
			     if chase_control = ALWAYS_CHASE then
				call hcs_$star_ (local_dirname, local_starname, star_ALL_ENTRIES, system_area_ptr,
				     star_entry_count, star_entry_ptr, star_names_ptr, code);
			     else call hcs_$star_ (local_dirname, local_starname, star_BRANCHES_ONLY,
				     system_area_ptr, star_entry_count, star_entry_ptr, star_names_ptr, code);
			     if code ^= 0 then do;
				call com_err_ (code, ENTER_IMFT_REQUEST, "^a",
				     pathname_ (local_dirname, local_starname));
				go to PROCESS_NEXT_TRANSFER_SPEC;
			     end;
			     do entry_idx = 1 to star_entry_count;
				call process_single_request (local_dirname,
				     star_names (star_entries (entry_idx).nindex));
PROCESS_NEXT_STAR_ENTRY:
			     end;
			     free star_names in (system_area);
			     free star_entries in (system_area);
			     star_entry_ptr, star_names_ptr = null ();
			     if (^submitted_a_request & ^skipped_a_request) & ^printed_an_error_message then
				call com_err_ (error_table_$nomatch, ENTER_IMFT_REQUEST, "^a",
				     pathname_ (local_dirname, local_starname));
			end;

			else call process_single_request (local_dirname, local_starname);
		     end;

		     else call process_single_request (local_dirname, local_starname);

PROCESS_NEXT_TRANSFER_SPEC:
		end;
	     end;


/* Print the total number of requests entered if in long mode and cleanup */

RETURN_FROM_ENTER_IMFT_REQUEST:
	     if long_mode & (n_requests_submitted > 0) then
		call ioa_ ("^d request^[s^] submitted^[; ^d already in^; to^s^] ^a queue ^d.", n_requests_submitted,
		     (n_requests_submitted > 1), have_previous_queue_total, previous_queue_total, request_type, queue)
		     ;

CLEANUP:
	     call cleanup_handler ();

	     return;
%page;

/* Performs all necessary processing to submit a single request */

process_single_request:
     procedure (p_dirname, p_ename);

dcl  (p_dirname, p_ename) character (*) parameter;

dcl  (local_dirname, local_pathname, real_dirname, parent_dirname, dirname_here) character (168);
dcl  (local_ename, local_type, real_ename, foreign_ename, parent_ename) character (32);
dcl  message character (512);
dcl  entry_bit_count fixed binary (24);
dcl  entry_type fixed binary (2);
dcl  idx fixed binary;

dcl  request_id character (19);
dcl  the_message_id bit (72) aligned;

dcl  1 stat like status_branch;

	local_dirname = p_dirname;
	local_ename = p_ename;

/* Construct the foreign pathname if -target_pathname was specified */

	if local_ft_request.foreign_path_given then do;
	     if remote then
		foreign_ename = foreign_equalname;	/* don't convert the equal name here */
	     else do;
		call get_equal_name_ (local_ename, foreign_equalname, foreign_ename, code);
		if code ^= 0 then do;
		     call com_err_ (code, ENTER_IMFT_REQUEST, "Applying ^a to ^a.", foreign_equalname, local_ename);
		     go to ABORT_SINGLE_REQUEST;
		end;
	     end;
	end;

	local_pathname = pathname_ (local_dirname, local_ename);
%page;
	if ^remote then do;

/****
      Determine the type of entry and, if requested and the entry is a link,
      determine its actual target.
*/

	     call hcs_$status_long (local_dirname, local_ename, HCS_DONT_CHASE, addr (stat), null (), code);
	     entry_type = stat.type;
	     entry_bit_count = stat.bit_count;
	     if code ^= 0 then do;

COULD_NOT_STATUS_BRANCH:
		call com_err_ (code, ENTER_IMFT_REQUEST, "^a", pathname_ (local_dirname, local_ename));
		go to ABORT_SINGLE_REQUEST;
	     end;

	     if (entry_type = star_LINK) then
		if (^have_starname & (chase_control = DEFAULT_CHASE)) | (chase_control = ALWAYS_CHASE) then do;
		     call hcs_$get_link_target (local_dirname, local_ename, real_dirname, real_ename, code);
		     if code ^= 0 then do;
			call com_err_ (code, ENTER_IMFT_REQUEST, "Determining link target of ^a.",
			     pathname_ (local_dirname, local_ename));
			go to ABORT_SINGLE_REQUEST;
		     end;
		     local_dirname = real_dirname;
		     local_ename = real_ename;
		     local_pathname = pathname_ (local_dirname, local_ename);
		     call hcs_$status_long (local_dirname, local_ename, HCS_DONT_CHASE, addr (stat), null (), code);
		     entry_type = stat.type;
		     entry_bit_count = stat.bit_count;
		     if code ^= 0 then go to COULD_NOT_STATUS_BRANCH;
		end;
		else do;
		     call com_err_ (error_table_$link, ENTER_IMFT_REQUEST, "^a",
			pathname_ (local_dirname, local_ename));
		     go to ABORT_SINGLE_REQUEST;
		end;

/*
   Pass the dtaf screen to determine if we send it.  This will also check
   directories, but not their contents.
*/

	     if ^remote & (cv_fstime_ ((stat.dtcm)) <= date_time_after) then do;
		if list_skipped then
		     call ioa_ ("^[^a^s^;^s^a^] not changed after dtaf.", absolute_pathname, local_pathname,
			local_ename, date_time_after_string);
		skipped_count = skipped_count + 1;
		skipped_a_request = "1"b;
		goto SKIP_THIS_REQUEST;
	     end;
%page;
/****
      Check the user's and the daemon's access to object.  Both must have
      explicit non-null access to the branch.
*/

	     imft_chk_acl.dirname = local_dirname;
	     imft_chk_acl.ename = local_ename;
	     imft_chk_acl.dir_access = S_ACCESS;
	     imft_chk_acl.seg_access = R_ACCESS;
	     imft_chk_acl.bad_acl_idx = USER_ACL_IDX;	/* by default, error is user's */

	     call imft_util_$check_object_acl (addr (imft_chk_acl), code);
	     if code = 0 then code = imft_chk_acl.error_code;
	     if code ^= 0 then
		if code = error_table_$unimplemented_version then do;
		     call com_err_ (code, ENTER_IMFT_REQUEST, BAD_CHK_OBJ_ACL_STR);
		     go to CLEANUP;
		end;
		else do;
		     call com_err_ (NO_ERROR, ENTER_IMFT_REQUEST, "^a^/^2x(^a)",
			imft_chk_acl (imft_chk_acl.bad_acl_idx).error_message, local_pathname);
		     go to ABORT_SINGLE_REQUEST;
		end;

	     do idx = 1 to hbound (general_acl.entries, 1);
		if general_acl (idx).status_code ^= 0 then
		     call com_err_ (NO_ERROR, ENTER_IMFT_REQUEST, "^a^/^2x(^a)", imft_chk_acl (idx).error_message,
			local_pathname);
	     end;

	     if ^imft_chk_acl.allow_transfer | ^imft_chk_acl.objects_to_transfer then go to ABORT_SINGLE_REQUEST;

/* If -file or -subtree was specified, verify that the branch is of the appropriate type */

	     if ^(imft_chk_acl.type = ENTRY_TYPE_DIRECTORY) & ^include_files then do;
		if ^have_starname then
		     call com_err_ (NO_ERROR, ENTER_IMFT_REQUEST,
			"Files may not be specified when ""^a"" is used.  ^a", file_subtree_arg, local_pathname);
		return;
	     end;

	     if (imft_chk_acl.type = ENTRY_TYPE_DIRECTORY) & ^include_subtrees then do;
		if ^have_starname then
		     call com_err_ (NO_ERROR, ENTER_IMFT_REQUEST,
			"Subtrees may not be specified when ""^a"" is used.  ^a", file_subtree_arg, local_pathname);
		return;
	     end;

	     if (extend_seg | update_seg)
		& ^((imft_chk_acl.type = ENTRY_TYPE_SEGMENT) | (imft_chk_acl.type = ENTRY_TYPE_MSF)) then do;

		if index (imft_chk_acl.type, "-") = 1 then
		     local_type = substr (imft_chk_acl.type, 2);
		else local_type = imft_chk_acl.type;

		call com_err_ (NO_ERROR, ENTER_IMFT_REQUEST,
		     "Can only ^[extend^]^[update^] with segments or MSFs, not with ^a type objects:^/^2x^a",
		     extend_seg, update_seg, local_type, local_pathname);
		go to ABORT_SINGLE_REQUEST;
	     end;


	end;					/* if ^remote */
%page;
	if remote & local_ft_request.foreign_path_given	/* in this case, "foreign" path is really local */
	     then
	     dirname_here = foreign_dirname;
	else dirname_here = local_dirname;
	call expand_pathname_ (dirname_here, parent_dirname, parent_ename, ignore_code);

/****
      Must always have S access to containing or parent directory for both
      driver and user.

      If the -delete option was used or local object is being extended or
      updated, both driver and user must have explicit SMA.
*/

	imft_chk_acl.dirname = parent_dirname;
	imft_chk_acl.ename = parent_ename;
	imft_chk_acl.dir_access = S_ACCESS;
	imft_chk_acl.seg_access = R_ACCESS;
	imft_chk_acl.bad_acl_idx = USER_ACL_IDX;	/* by default, error is user's */

	call imft_util_$check_object_acl (addr (imft_chk_acl), code);
	if code = 0 then code = imft_chk_acl.error_code;
	if code ^= 0 then do;
	     if code = error_table_$unimplemented_version then do;
		call com_err_ (code, ENTER_IMFT_REQUEST, BAD_CHK_OBJ_ACL_STR);
		go to CLEANUP;
	     end;
	     call set_dir_s_error_message (imft_chk_acl.bad_acl_idx);
	     call com_err_ (code, ENTER_IMFT_REQUEST, message);
	     go to PROCESS_NEXT_TRANSFER_SPEC;		/* cannot win here for any starname */

	end;					/* if code ^= 0 */

	code = 0;
	do idx = 1 to hbound (general_acl.entries, 1);	/* see if general_acl has any errors to report */
	     if general_acl (idx).status_code ^= 0 then do;
		code = general_acl (idx).status_code;
		call set_dir_s_error_message (idx);
		call com_err_ (code, ENTER_IMFT_REQUEST, message);
	     end;
	end;

	if code ^= 0 then go to PROCESS_NEXT_TRANSFER_SPEC;
						/* cannot win here with any starname */
%page;
	if remote | delete_obj then do;		/* need SMA to parent directory for this case */

	     imft_chk_acl.dir_access = SMA_ACCESS;
	     imft_chk_acl.seg_access = RW_ACCESS;
	     imft_chk_acl.bad_acl_idx = USER_ACL_IDX;	/* by default, error is user's */

	     call imft_util_$check_object_acl (addr (imft_chk_acl), code);
	     if code = 0 then code = imft_chk_acl.error_code;
	     if code ^= 0 then do;
		if code = error_table_$unimplemented_version then do;
		     call com_err_ (code, ENTER_IMFT_REQUEST, BAD_CHK_OBJ_ACL_STR);
		     go to CLEANUP;
		end;
		else do;
		     call set_dir_sma_error_message (imft_chk_acl.bad_acl_idx);
		     call command_query_$yes_no (Yes, code, ENTER_IMFT_REQUEST, explanation,
			"^[^/^2x^]^a" || question, ll_query () < 100, message);
		     if Yes then go to CONTINUE_SINGLE_REQUEST;
		end;
		go to PROCESS_NEXT_TRANSFER_SPEC;	/* cannot win here with any starname */

	     end;					/* if code ^= 0 */

	     code = 0;
	     do idx = 1 to hbound (general_acl.entries, 1);
		if general_acl (idx).status_code ^= 0 then do;
		     code = general_acl (idx).status_code;
		     call set_dir_sma_error_message (idx);
		     call com_err_ (code, ENTER_IMFT_REQUEST, message);
		end;
	     end;

	     if code ^= 0 then do;
		call command_query_$yes_no (Yes, NO_ERROR, ENTER_IMFT_REQUEST, explanation, "^a" || question,
		     "An access error occured.");
		if Yes then go to CONTINUE_SINGLE_REQUEST;
		go to PROCESS_NEXT_TRANSFER_SPEC;	/* cannot win here with any starname */
	     end;


	end;					/* if remote or delete_obj */
%page;
/* Submit the request */

CONTINUE_SINGLE_REQUEST:
	local_ft_request.header.msg_time = clock ();

	local_ft_request.header.dirname = local_dirname;
	local_ft_request.header.ename = local_ename;

	if local_ft_request.foreign_path_given then do;
	     local_ft_request.foreign_dirname = foreign_dirname;
	     local_ft_request.foreign_ename = foreign_ename;
	end;

	if ^remote & (entry_type = star_DIRECTORY) | remote & ^(extend_seg | update_seg) then
	     if merge_directories then		/* record the user's desire for treatment of namedups */
		local_ft_request.directory_creation_mode = MERGE_DIRECTORIES;
	     else local_ft_request.directory_creation_mode = REPLACE_DIRECTORIES;
	else local_ft_request.directory_creation_mode = "00"b;

	call message_segment_$add_index (queue_index, addr (local_ft_request), (36 * currentsize (local_ft_request)),
	     the_message_id, code);
	if code ^= 0 then do;			/* grumble */
	     call com_err_ (code, ENTER_IMFT_REQUEST, "Attempting to add request for ^a.", local_pathname);
	     go to RETURN_FROM_ENTER_IMFT_REQUEST;	/* this is fatal */
	end;

	if long_mode then do;			/* print a message about the success */
	     request_id = request_id_ (local_ft_request.header.msg_time);
	     call ioa_ ("^[^a^s^;^s^a^]; ID: ^[^a^;^s^a^]", absolute_pathname, local_pathname, local_ename, long_id,
		request_id, (substr (request_id, 7, 8)));
	end;

	n_requests_submitted = n_requests_submitted + 1;
	submitted_a_request = "1"b;			/* needed by starname processor */

	return;

/* An error occurred processing this request: proceed to the next one */

ABORT_SINGLE_REQUEST:
	printed_an_error_message = "1"b;		/* needed by starname processor */

SKIP_THIS_REQUEST:
	if have_starname then
	     go to PROCESS_NEXT_STAR_ENTRY;

	else go to PROCESS_NEXT_TRANSFER_SPEC;
%page;
/**** Support internal procedures to construct appropriate error messages. */

set_dir_s_error_message:
	proc (p_idx);

dcl  p_idx fixed binary;

	     if code = error_table_$moderr | code = error_table_$user_not_found then
		call ioa_$rsnnl (
		     "^[^/^2x^]^[Driver^;User^] (^a) must have an explicit ACL entry of S to parent directory of object to be ^[received^s^;^[deleted^;sent^]^].^/^2x(^a)",
		     message, ignore_fb21, ll_query () < 100, (p_idx = DRIVER_ACL_IDX),
		     general_acl (p_idx).access_name, remote, delete_obj, dirname_here);
	     else call ioa_$rsnnl (
		     "^[^/^2x^]Unable to determine S access of ^[driver^;user^] (^a) to the parent directory of object to be ^[received^s^;^[deleted^;sent^]^].^/^2x(^a)",
		     message, ignore_fb21, ll_query () < 100, (p_idx = DRIVER_ACL_IDX),
		     general_acl (p_idx).access_name, remote, delete_obj, dirname_here);

	end set_dir_s_error_message;
%skip (4);
set_dir_sma_error_message:
	proc (p_idx);

dcl  p_idx fixed binary;

	     if code = error_table_$moderr | code = error_table_$user_not_found then
		call ioa_$rsnnl (
		     "^[^/^2x^]^[Driver^;User^] (^a) must have an explicit ACL entry of SMA to parent directory of object to be ^[received^;deleted^].^/^2x(^a)",
		     message, ignore_fb21, ll_query () < 100, (p_idx = DRIVER_ACL_IDX),
		     general_acl (p_idx).access_name, remote, dirname_here);
	     else call ioa_$rsnnl (
		     "^[^/^2x^]Unable to determine SMA access of ^[driver^;user^] (^a) to the parent directory of object to be ^[received^;deleted^].^/^2x(^a)",
		     message, ignore_fb21, ll_query () < 100, (p_idx = DRIVER_ACL_IDX),
		     general_acl (p_idx).access_name, remote, dirname_here);

	end set_dir_sma_error_message;
%skip (4);
     end process_single_request;

	end MAIN_EIR_BLOCK;
%page;

/* Fetch the next argument */

get_next_argument:
     procedure (p_arg_description, p_argument);

dcl  p_arg_description character (*) parameter;
dcl  p_argument character (*) parameter;
dcl  control_argument character (32);

	control_argument = argument;			/* save control arg's name for error messages */

	if argument_idx = n_arguments then do;		/* there is no next argument */
	     call com_err_ (error_table_$noarg, ENTER_IMFT_REQUEST, "^a must follow ""^a"".", p_arg_description,
		control_argument);
	     go to ABORT_ARGUMENT_PARSE;
	end;

	argument_idx = argument_idx + 1;

	call cu_$arg_ptr_rel (argument_idx, argument_ptr, argument_lth, code, the_argument_list);
	if code ^= 0 then do;
	     call com_err_ (code, ENTER_IMFT_REQUEST, "Accessing argument #^d.", argument_idx);
	     go to ABORT_ARGUMENT_PARSE;
	end;

	if argument_lth > length (p_argument) then do;	/* it's too long */
	     call com_err_ (NO_ERROR, ENTER_IMFT_REQUEST,
		"Value after ""^a"" may not be longer than ^d characters.  ""^a""", control_argument,
		length (p_argument), argument);
	     go to ABORT_ARGUMENT_PARSE;
	end;

	p_argument = argument;			/* it's OK */

	return;

     end get_next_argument;

ABORT_ARGUMENT_PARSE:
	return;
%page;
/* Cleanup after an invocation of enter_imft_request */

cleanup_handler:
     procedure ();

	if acl_ptr ^= null () then do;
	     free general_acl in (system_area);
	     acl_ptr = null ();
	end;

	if star_names_ptr ^= null () then do;
	     free star_names in (system_area);
	     star_names_ptr = null ();
	end;

	if star_entry_ptr ^= null () then do;
	     free star_entries in (system_area);
	     star_entry_ptr = null ();
	end;

	if queue_index ^= 0 then do;
	     call message_segment_$close (queue_index, ignore_code);
	     queue_index = 0;
	end;

	return;

     end cleanup_handler;
%skip (4);
/* A little help from eor to help pretty up output. */

ll_query:
     procedure () returns (fixed bin) reducible;

	if line_length_query = 0 then line_length_query = get_line_length_$switch (iox_$user_io, 0);
	return (line_length_query);

     end ll_query;
%page;

/* Sets the directory pathname where the IMFT user commands (eir, lir, mir, cir) will find the request queues */

test_imft:
     entry () options (variable);

	call cu_$arg_count (n_arguments, code);
	if code ^= 0 then do;
	     call com_err_ (code, TEST_IMFT);
	     return;
	end;

	if n_arguments = 0 then			/* reset to the default */
	     imft_data_$queue_dirname = imft_data_$default_queue_dirname;

	else if n_arguments = 1 then do;
	     call cu_$arg_ptr (1, argument_ptr, argument_lth, code);
	     if code ^= 0 then do;
		call com_err_ (code, TEST_IMFT, "Accessing argument #1.");
		return;
	     end;
	     call absolute_pathname_ (argument, imft_data_$queue_dirname, code);
	     if code ^= 0 then do;
		call com_err_ (code, TEST_IMFT, "^a", argument);
		return;
	     end;
	end;

	else do;
	     call com_err_$suppress_name (NO_ERROR, TEST_IMFT, "Usage:  ^a {queue_dir_path}", TEST_IMFT);
	     return;
	end;

	call iod_info_$test (imft_data_$queue_dirname);	/* here if we changed it */

	return;
%page;

dcl  system_area area based (system_area_ptr);
dcl  system_area_ptr pointer;

dcl  the_argument_list pointer;

dcl  argument character (argument_lth) unaligned based (argument_ptr);
dcl  explain_array (2) char (159) int static options (constant) init ("yes, y
   the request will be submitted, in spite of the problem reported above.
   The caller can take corrective action after the request is submitted,
   or", " can do nothing in the hope that the IMFT daemon will not encounter
   an error.
no, n
   do not submit the request.

Do you still wish to submit the request?");
dcl  explanation char (317) based (addr (explain_array));
dcl  next_argument character (next_argument_lth) unaligned based (next_argument_ptr);
dcl  (argument_lth, next_argument_lth) fixed binary (21);
dcl  (argument_ptr, next_argument_ptr) pointer;
dcl  (n_arguments, argument_idx) fixed binary;

dcl  1 imft_chk_acl aligned like imft_check_acl;
dcl  1 local_ft_request aligned like ft_request;

dcl  foreign_system character (19);
dcl  request_type character (24);
dcl  (generic_type, driver_userid, queue_string, queue_ename) character (32);
dcl  (queue, queue_index, default_queue, max_queues) fixed binary;
dcl  queue_mode bit (36) aligned;
dcl  queue_picture picture "9";

dcl  (local_dirname, foreign_dirname, foreign_pathname) character (168);
dcl  (local_starname, foreign_equalname) character (32);

dcl  foreign_user character (32);
dcl  date_time_after_string character (32);
dcl  date_time_after fixed bin (71);
dcl  file_subtree_arg character (32);
dcl  found_transfer_spec bit (1) aligned;
dcl  remote bit (1) aligned;
dcl  list_skipped bit (1);				/* list dtaf skipped entries */
dcl  skipped_count fixed bin;
dcl  delete_obj bit (1) aligned;
dcl  extend_seg bit (1) aligned;
dcl  update_seg bit (1) aligned;
dcl  (include_files, include_subtrees) bit (1) aligned;
dcl  (long_mode, long_id, absolute_pathname, notify, merge_directories) bit (1) aligned;

dcl  chase_control bit (2) aligned;

dcl  entry_idx fixed binary;
dcl  Yes bit (1) aligned;
dcl  have_starname bit (1) aligned;

dcl  (n_requests_submitted, previous_queue_total) fixed binary;
dcl  (have_previous_queue_total, skipped_a_request, submitted_a_request, printed_an_error_message) bit (1) aligned;

dcl  code fixed binary (35);
dcl  ignore_code fixed binary (35);
dcl  ignore_fb21 fixed binary (21);
dcl  line_length_query fixed binary init (0);

dcl  BAD_CHK_OBJ_ACL_STR character (46) init ("Attempted to call imft_util_$check_object_acl.") static options (constant);
dcl  ENTER_IMFT_REQUEST character (32) static options (constant) initial ("enter_imft_request");
dcl  TEST_IMFT character (32) static options (constant) initial ("enter_imft_request$test_imft");
dcl  NO_ERROR fixed binary (35) static options (constant) initial (0);
dcl  HCS_DONT_CHASE fixed binary (1) static options (constant) initial (0);
dcl  AS_EXTENDED_ACCESS initial ("420000000000"b3) bit (36) aligned static options (constant);
dcl  A_EXTENDED_ACCESS initial ("400000000000"b3) bit (36) aligned static options (constant);
dcl  question char (41) int static options (constant) init ("
Do you still wish to submit the request?");

/* format: on */

dcl  error_table_$badopt fixed binary (35) external;
dcl  error_table_$id_not_found fixed binary (35) external;
dcl  error_table_$link fixed binary (35) external;
dcl  error_table_$moderr fixed binary (35) external;
dcl  error_table_$noarg fixed binary (35) external;
dcl  error_table_$nomatch fixed binary (35) external;
dcl  error_table_$unimplemented_version fixed bin (35) ext static;
dcl  error_table_$user_not_found fixed binary (35) external;

dcl  imft_data_$queue_dirname character (168) external;
dcl  imft_data_$default_queue_dirname character (168) external;

dcl  absolute_pathname_ entry (character (*), character (*), fixed binary (35));
dcl  check_star_name_$entry entry (character (*), fixed binary (35));
dcl  com_err_ entry () options (variable);
dcl  com_err_$suppress_name entry () options (variable);
dcl  command_query_$yes_no entry () options (variable);
dcl  convert_date_to_binary_ entry (char (*), fixed bin (71), fixed bin (35));
dcl  cu_$arg_count entry (fixed binary, fixed binary (35));
dcl  cu_$arg_list_ptr entry () returns (pointer);
dcl  cu_$arg_ptr entry (fixed binary, pointer, fixed binary (21), fixed binary (35));
dcl  cu_$arg_ptr_rel entry (fixed binary, pointer, fixed binary (21), fixed binary (35), pointer);
dcl  cv_dec_check_ entry (character (*), fixed binary (35)) returns (fixed binary (35));
dcl  cv_fstime_ entry (bit (36) aligned) returns (fixed bin (71));
dcl  expand_pathname_ entry (character (*), character (*), character (*), fixed binary (35));
dcl  get_equal_name_ entry (character (*), character (*), character (32), fixed binary (35));
dcl  get_equal_name_$check_equal_name_ entry (character (*), fixed binary (35));
dcl  get_group_id_$tag_star entry () returns (character (32));
dcl  get_line_length_$switch entry (ptr, fixed bin (35)) returns (fixed bin);
dcl  get_ring_ entry () returns (fixed bin (3));
dcl  get_system_free_area_ entry () returns (pointer);
dcl  hcs_$get_link_target entry (character (*), character (*), character (*), character (*), fixed binary (35));
dcl  hcs_$star_
	entry (character (*), character (*), fixed binary (2), pointer, fixed binary, pointer, pointer,
	fixed binary (35));
dcl  hcs_$status_long entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35));
dcl  imft_default_rqt_ entry returns (char (*));
dcl  imft_util_$check_object_acl entry (ptr, fixed bin (35));
dcl  ioa_ entry () options (variable);
dcl  ioa_$rsnnl entry () options (variable);
dcl  iod_info_$driver_access_name entry (character (*), character (32), fixed binary (35));
dcl  iod_info_$generic_type entry (character (*), character (32), fixed binary (35));
dcl  iod_info_$queue_data entry (character (*), fixed binary, fixed binary, fixed binary (35));
dcl  iod_info_$test entry (character (*));
dcl  iox_$user_io ptr ext static;
dcl  message_segment_$add_index entry (fixed binary, pointer, fixed binary (24), bit (72) aligned, fixed binary (35));
dcl  message_segment_$close entry (fixed binary, fixed binary (35));
dcl  message_segment_$get_message_count_index entry (fixed binary, fixed binary, fixed binary (35));
dcl  message_segment_$get_mode_index entry (fixed binary, bit (36) aligned, fixed binary (35));
dcl  message_segment_$open entry (character (*), character (*), fixed binary, fixed binary (35));
dcl  pathname_ entry (character (*), character (*)) returns (character (168));
dcl  request_id_ entry (fixed binary (71)) returns (character (19));

dcl  cleanup condition;

dcl  (addr, after, before, clock, convert, currentsize, hbound, index, length, null, rtrim, substr, sum, unspec) builtin;
%page;
%include queue_msg_hdr;
%page;
%include "_imft_check_acl";
%page;
%include "_imft_ft_request";
%page;
%include access_mode_values;
%page;
%include acl_structures;
%page;
%include fs_star_;
%page;
%include star_structures;
%include status_structures;
     end enter_imft_request;
