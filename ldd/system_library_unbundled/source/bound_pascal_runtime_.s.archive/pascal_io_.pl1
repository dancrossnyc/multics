/****^  *************************************************************************
        *                                                                       *
        * Copyright, (C) BULL HN Information Systems Inc., 1990                 *
        *                                                                       *
        * Copyright (c) 1980 by Centre Interuniversitaire de Calcul de Grenoble *
        * and Institut National de Recherche en Informatique et Automatique     *
        *                                                                       *
        ************************************************************************* */


/****^  HISTORY COMMENTS:
  1) change(86-10-05,JMAthane), approve(86-10-05,MCR7521),
     audit(86-10-09,JPFauche), install(86-11-12,MR12.0-1212):
     Pascal version for MR12.
  2) change(90-04-06,Zimmerman), approve(90-04-06,MCR8167),
     audit(90-05-03,Huen), install(90-05-30,MR12.4-1013):
     pas_11: Prevent rounding of real numbers from overwriting sign during
     formatting for output.  pas_10: Correct spelling error in $WRITE_test.
     pas_13: Correct inaccurate reporting of value of min_real.
                                                   END HISTORY COMMENTS */

/* format: style4,^linecom,^ifthendo,^indproc,^indblkcom,initcol1,declareind8,dclind4,struclvlind1 */
pascal_io_: proc;

/* PL/1 procedures performing pascal io */
/* TO BE BOUND IN pascal_bound_operators_ */

/* Created J-M Athane 1980 */
/* Cleaned up command interfaces and error messages 03/01/84 S. Herbst */
/* Modified 03/21/84 by J-M Athane to support the close_file command */

/*

   COMMANDS:

   pascal_file_status
   pascal_set_prompt

   SUBROUTINE ENTRIES:

   pascal_io_$RESET
   pascal_io_$REWRITE
   pascal_io_$close
   pascal_io_$fclose
   pascal_io_$READ_text
   pascal_io_$READ_sequential
   pascal_io_$READLN
   pascal_io_$WRITE_text
   pascal_io_$WRITE_sequential
   pascal_io_$WRITELN
   pascal_io_$PAGE
   pascal_io_$PUT_text
   pascal_io_$PUT_sequential
   pascal_io_$GET_text
   pascal_io_$GET_sequential
   pascal_io_$GET_direct
   pascal_io_$PUT_direct
   pascal_io_$open_update

   pascal_io_$close_level_files
   pascal_io_$close_subroutine

*/


/* parameter structure for the different entry_points */

dcl 1 io_parameters aligned,
     2 block_ptr ptr,				/* ptr to the file_status_block of the file */
     2 two_words_value bit (72),			/* depends on the entry point : ptr or value */
     2 type_ fixed bin (35),				/* type_ of the value (READ WRITE) */
     2 io_length fixed bin (21),			/* output length for the value (WRITE) */
     2 size_ fixed bin (21),				/* internal size_ of the value (WRITE string or record) */
						/* or nbr of digits after the point (WRITE real float dec) */
     2 dim fixed bin (35),				/* dimension (>1 if array of file) (for init_fsb op) */
     2 stack_frame_ptr ptr,				/* ptr to the stack_frame of the calling procedure */
     2 linkage_header_ptr ptr;			/* ptr to linkage of caller */




/* external references to the MULTICS System */

dcl stu_$get_block entry (ptr, ptr, ptr);
dcl com_err_ entry options (variable);
dcl com_err_$suppress_name entry options (variable);
dcl signal_ entry (char (*), ptr, ptr, ptr);
dcl cu_$arg_count entry (fixed bin);
dcl cu_$arg_ptr entry (fixed bin, ptr, fixed bin (17), fixed bin (35));
dcl cu_$evaluate_active_string entry (ptr, char (*), fixed bin, char (*) varying, fixed bin (35));
dcl iox_$look_iocb entry (char (*), ptr, fixed bin (35));
dcl iox_$modes entry (ptr, char (*), char (*), fixed bin (35));
dcl iox_$detach_iocb entry (ptr, fixed bin (35));
dcl iox_$user_io ext ptr;
dcl iox_$find_iocb entry (char (*), ptr, fixed bin (35));
dcl iox_$destroy_iocb entry (ptr, fixed bin (35));
dcl iox_$attach_ptr entry (ptr, char (*), ptr, fixed bin (35));
dcl iox_$open entry (ptr, fixed, bit (1) aligned, fixed (35));
						/* open (iocb_ptr, mode, not_used, status) */
dcl iox_$close entry (ptr, fixed (35));			/* close (iocb_ptr, status) */
dcl iox_$get_line entry (ptr, ptr, fixed (21), fixed (21), fixed (35));
						/* get_line (iocb_ptr, buf_ptr, buf_len, chars_read, status) */
dcl iox_$get_chars entry (ptr, ptr, fixed (21), fixed (21), fixed (35));
						/* get_chars (iocb_ptr, buf_ptr, buf_len, chars_read, status) */
dcl iox_$put_chars entry (ptr, ptr, fixed (21), fixed (35));
						/* put_chars (iocb_ptr, buf_ptr, buf_len, status) */
dcl iox_$read_record entry (ptr, ptr, fixed (21), fixed (21), fixed (35));
						/* read_record (iocb_ptr, buf_ptr, buf_len, chars_read, status) */
dcl iox_$write_record entry (ptr, ptr, fixed (21), fixed (35));
						/* write_record (iocb_ptr, buf_ptr, buf_len, status) */
dcl iox_$rewrite_record entry (ptr, ptr, fixed (21), fixed (35));
						/* rewrite_record (iocb_ptr, buf_ptr, buf_len, status) */
dcl iox_$seek_key entry (ptr, char (256) varying, fixed (21), fixed (35));
						/* seek_key (iocb_ptr, key, len, status) */
dcl ioa_$rsnnl entry options (variable);
dcl ioa_ entry options (variable);
dcl hcs_$fs_get_path_name entry (ptr, char (*), fixed bin, char (*), fixed bin (35));
dcl get_pdir_ entry returns (char (168));
dcl delete_$path entry (char (*), char (*), bit (6), char (*), fixed bin (35));
dcl unique_bits_ entry returns (bit (70));
dcl unique_chars_ entry (bit (*)) returns (char (15));

dcl error_table_$no_iocb ext fixed bin (35);
dcl error_table_$bad_mode ext fixed bin (35);
dcl error_table_$no_record ext fixed bin (35);
dcl error_table_$long_record ext fixed bin (35);
dcl error_table_$short_record ext fixed bin (35);
dcl error_table_$end_of_info ext fixed bin (35);
dcl error_table_$unbalanced_brackets ext fixed bin (35);


/* external references to other pascal_ entry points */

dcl pascal_error_table_$bad_fsb ext fixed bin (35);
dcl pascal_error_table_$not_interactive_mode ext fixed bin (35);
dcl pascal_error_table_$write_when_no_output ext fixed bin (35);
dcl pascal_error_table_$non_direct ext fixed bin (35);
dcl pascal_error_table_$read_when_not_open ext fixed bin (35);
dcl pascal_error_table_$read_when_no_input ext fixed bin (35);
dcl pascal_error_table_$read_when_eof ext fixed bin (35);
dcl pascal_error_table_$write_when_not_open ext fixed bin (35);
dcl pascal_error_table_$prompt_error ext fixed bin (35);
dcl pascal_error_table_$switch_not_attached ext fixed bin (35);
dcl pascal_error_table_$bad_integer_format ext fixed bin (35);
dcl pascal_error_table_$bad_real_format ext fixed bin (35);
dcl pascal_error_table_$bad_args ext fixed bin (35);
dcl pascal_error_table_$bad_boolean ext fixed bin (35);

dcl pascal_constants_$max_integer_72 fixed bin (71) ext;
dcl pascal_constants_$max_integer fixed bin (35) ext;
dcl pascal_constants_$min_integer fixed bin (35) ext;
dcl pascal_constants_$max_real float bin (63) ext;
dcl pascal_constants_$min_real float bin (63) ext;
dcl pascal_constants_$min_real_pos float bin (63) ext;
dcl pascal_constants_$max_real_neg float bin (63) ext;

dcl pascal_codes_$input_mode ext fixed bin (35);
dcl pascal_codes_$output_mode ext fixed bin (35);
dcl pascal_codes_$direct_mode ext fixed bin (35);

dcl pascal_operators_$cleanup_sequence entry;

dcl pascal_operators_statics_$INPUT fixed bin ext;
dcl pascal_operators_statics_$OUTPUT fixed bin ext;
dcl pascal_operators_statics_$ERROR fixed bin ext;
dcl pascal_operators_statics_$ENTREE fixed bin ext;
dcl pascal_operators_statics_$SORTIE fixed bin ext;
dcl pascal_operators_statics_$ERREUR fixed bin ext;

/* (operator return entry points) */

dcl pascal_operators_$init_fsb_return entry;
dcl pascal_operators_$init_fsb_alloc_return entry;
dcl pascal_operators_$connect_return entry;
dcl pascal_operators_$RESET_file_return entry;
dcl pascal_operators_$REWRITE_return entry;
dcl pascal_operators_$close_return entry;
dcl pascal_operators_$READ_text_return entry;
dcl pascal_operators_$READ_sequential_return entry;
dcl pascal_operators_$READLN_return entry;
dcl pascal_operators_$WRITE_text_return entry;
dcl pascal_operators_$WRITE_sequential_return entry;
dcl pascal_operators_$WRITELN_return entry;
dcl pascal_operators_$PAGE_return entry;
dcl pascal_operators_$PUT_text_return entry;
dcl pascal_operators_$PUT_sequential_return entry;
dcl pascal_operators_$GET_text_return entry;
dcl pascal_operators_$GET_sequential_return entry;
dcl pascal_operators_$GET_direct_return entry;
dcl pascal_operators_$PUT_direct_return entry;
dcl pascal_operators_$open_update_return entry;
dcl pascal_operators_$fclose_return entry;
dcl pascal_operators_$FLUSH_return entry;
dcl pascal_operators_$defered_GET_text_return entry;

/* internal static constants */

dcl tenpower_float (-38:38) float bin (63) static options (constant) init (
         0.00000000000000000000000000000000000001,
         0.0000000000000000000000000000000000001,
         0.000000000000000000000000000000000001,
         0.00000000000000000000000000000000001,
         0.0000000000000000000000000000000001,
         0.000000000000000000000000000000001,
         0.00000000000000000000000000000001,
         0.0000000000000000000000000000001,
         0.000000000000000000000000000001,
         0.00000000000000000000000000001,
         0.0000000000000000000000000001,
         0.000000000000000000000000001,
         0.00000000000000000000000001,
         0.0000000000000000000000001,
         0.000000000000000000000001,
         0.00000000000000000000001,
         0.0000000000000000000001,
         0.000000000000000000001,
         0.00000000000000000001,
         0.0000000000000000001,
         0.000000000000000001,
         0.00000000000000001,
         0.0000000000000001,
         0.000000000000001,
         0.00000000000001,
         0.0000000000001,
         0.000000000001,
         0.00000000001,
         0.0000000001,
         0.000000001,
         0.00000001,
         0.0000001,
         0.000001,
         0.00001,
         0.0001,
         0.001,
         0.01,
         0.1,
         1,
         10,
         100,
         1000,
         10000,
         100000,
         1000000,
         10000000,
         100000000,
         1000000000,
         10000000000,
         100000000000,
         1000000000000,
         10000000000000,
         100000000000000,
         1000000000000000,
         10000000000000000,
         100000000000000000,
         1000000000000000000,
         10000000000000000000,
         100000000000000000000,
         1000000000000000000000,
         10000000000000000000000,
         100000000000000000000000,
         1000000000000000000000000,
         10000000000000000000000000,
         100000000000000000000000000,
         1000000000000000000000000000,
         10000000000000000000000000000,
         100000000000000000000000000000,
         1000000000000000000000000000000,
         10000000000000000000000000000000,
         100000000000000000000000000000000,
         1000000000000000000000000000000000,
         10000000000000000000000000000000000,
         100000000000000000000000000000000000,
         1000000000000000000000000000000000000,
         10000000000000000000000000000000000000,
         100000000000000000000000000000000000000
         );
dcl tenpower_int (11) fixed bin (71) static options (constant) init (
         0,
         10,
         100,
         1000,
         10000,
         100000,
         1000000,
         10000000,
         100000000,
         1000000000,
         10000000000
         );
dcl tenpower_big (0:20) fixed bin (71) static options (constant) init (
         1,
         10,
         100,
         1000,
         10000,
         100000,
         1000000,
         10000000,
         100000000,
         1000000000,
         10000000000,
         100000000000,
         1000000000000,
         10000000000000,
         100000000000000,
         1000000000000000,
         10000000000000000,
         100000000000000000,
         1000000000000000000,
         10000000000000000000,
         100000000000000000000
         );
dcl DIGITS (0:9) char (1) int static options (constant)
         init ("0", "1", "2", "3", "4", "5", "6", "7", "8", "9");
dcl zero_real float bin (63) init (0.) static options (constant);
dcl cleanup_chain char (7) init ("cleanup") int static options (constant);
dcl NL char (1) int static options (constant) init ("
");

/* (character codes) */

dcl ascii_0_code fixed bin (35) init (48) static options (constant);
dcl ascii_9_code fixed bin (35) init (57) static options (constant);


/* internal static * PER_PROCESS STATIC */

dcl prompt_string char (256) var int static init ("?");
dcl last_file_ptr ptr int static init (null);
dcl prompt_wanted int static bit (1) init ("1"b);

/* internal automatic */

dcl my_atd char (500) varying;
dcl return_string char (500) varying;
dcl (i, i1, i2, i3) fixed bin;
dcl code fixed bin (35) init (0);
dcl nbchars fixed bin;
dcl switch_name char (32);
dcl iocb_ptr ptr;
dcl (ptr1, ptr2, head_ptr) ptr;
dcl (real_length, string_length) fixed bin (21);
dcl return_check bit (1);
dcl cleanup_switch bit (1);
dcl process_dir_name char (168);
dcl entryname char (32);
dcl dir_name char (168);
dcl atd_ptr ptr;
dcl on_unit_relp bit (18);
dcl nbr_of_chars fixed bin (35);
dcl digit_string char (24);
dcl int_value bit (72);
dcl value_ptr ptr;
dcl record_ptr ptr;
dcl record_length fixed bin;
dcl mode fixed bin (35);
dcl negative fixed bin (35);
dcl chiffre_ptr ptr;
dcl key char (256) varying;
dcl exponent fixed bin (21);
dcl big_integer fixed bin (71);
dcl exp fixed bin (21);
dcl exp_signe fixed bin (35);
dcl arg_len fixed bin (17);
dcl arg_count fixed bin;
dcl arg_ptr ptr;
dcl frame_length fixed bin (35);
dcl pascal_name char (32) varying;
dcl arg char (arg_len) based (arg_ptr);
dcl (ptr3, ptr6, ptr7) ptr;
dcl err_label label;
dcl any bit (1);


/* based */

dcl 1 char_var based,
     2 l fixed bin (35),
     2 s char (256);

dcl 1 acc based,
     2 length fixed bin (8) unal,
     2 string char (0 refer (acc.length)) unal;

dcl one_byte_data bit (9) based;
dcl two_byte_data bit (18) based;
dcl four_byte_data bit (36) based;
dcl eight_byte_data bit (72) based;

dcl 1 attach_description based aligned,
     2 length fixed bin (17),
     2 string char (0 refer (attach_description.length));

dcl p5 ptr based;
dcl atd_string char (size_) based;
dcl f_name_8 char (8) based;

dcl 1 type_1 based (value_ptr),
     2 pad bit (27) unal,
     2 charact char (1) unal;
dcl 1 type_2 based (value_ptr),
     2 boolean fixed bin (35);
dcl 1 type_4 based (value_ptr),
     2 integer fixed bin (35);
dcl 1 type_8_16 based (value_ptr),
     2 real float bin (63);
dcl 1 type_32 based (value_ptr),
     2 zone_ptr ptr;
dcl record char (record_length) unal based (record_ptr);
dcl 1 value_1 based (value_ptr),
     2 pad bit (27) unal,
     2 one_byte_value bit (9) unal;
dcl 1 value_2 based (value_ptr),
     2 pad bit (18) unal,
     2 two_byte_value bit (18) unal;
dcl four_byte_value bit (36) based (value_ptr);
dcl eight_byte_value bit (72) based (value_ptr);
dcl chiffre fixed bin (35) based (chiffre_ptr);
dcl fsb_frame (frame_length) fixed bin (35) based;

/* builtins */

dcl (abs, addr, addrel, baseno, char, convert) builtin;
dcl (index, length, mod, null, ptr, rel, rtrim, substr, unspec) builtin;

/* conditions */

dcl any_other condition;
%page;
init_fsb_alloc: entry (io_parameters) options (support);

/* uses :
   - block_ptr : addr of the pointer to the fsb ;
   - two_words_value : addr of the name of the Pascal file (8 chars)
   or addr of the names of the elements of the array of file (n * 32 chars)
   - type_ = type of the file :
   1 : record permanent
   2 : text permanent
   3 : record static
   4 : text static
   5 : record local
   6 : text local
   - io_length : record_length (record_file) or buffer_length (text_file)
   - dim : dimension of array (1 : single file, >1 : array of file)
   - stack_frame_ptr (is null if called by first ref trap, otherwise not)
   - linkage_header_ptr (always valid)
*/

	value_ptr = addr (two_words_value);
	sp = stack_frame_ptr;

	pascal_name = zone_ptr -> acc.string;
	if dim > 1 then do;
	     i1 = index (pascal_name, "[");
	     if i1 ^= 0 then pascal_name = substr (pascal_name, 1, i1 - 1);
	end;
	else if dim < 1 then go to error_while_init_fsb_alloc;

/* allocation of fsb */
	if (type_ >= 5) | (block_ptr -> p5 = null) then do;
allocate_fsb:
	     frame_length = 38 + (io_length + 3) / 4;	/* compute size of block to allocate */
	     if mod (type_, 2) = 0 then
		frame_length = frame_length + 1;
	     if mod (frame_length, 2) ^= 0 then
		frame_length = frame_length + 1;
	     if dim ^= 1 then
		frame_length = dim * frame_length;
	     if frame_length > 255 * 1024 then do;
		call ioa_$rsnnl ("
pascal_operators_$init_fsb_alloc : Size of control block for file ^a is more than one segment.",
		     pascal_operators_statics_$error_info.string, string_length, pascal_name);
		go to fatal_error;
	     end;
	     allocate fsb_frame set (fsb_ptr);
	     block_ptr -> p5 = fsb_ptr;
	     allocated_size = frame_length;
	     uid = unique_bits_ ();
	end;
	else do;
	     fsb_ptr = block_ptr -> p5;
	     call check_fsb_thread;
	     if return_check = "0"b then go to allocate_fsb;
	end;

/* initialize now */

	global_flags = "0"b;
	if type_ <= 0 then go to error_while_init_fsb_alloc;
	else if type_ <= 2 then permanent_file = "1"b;
	else if type_ <= 4 then static_file = "1"b;
	else if type_ <= 6 then local_file = "1"b;
	else go to error_while_init_fsb_alloc;

	if mod (type_, 2) = 0 then do;
	     file_is_text = 1;
	     buff_len = io_length;
	end;
	else do;
	     file_is_text = 0;
	     rec_length = io_length;
	end;

	file_name = zone_ptr -> acc.string;
	owner_stack = sp;
	system_ptr = null;
	owner_link = linkage_header_ptr;
	owner_symbol = owner_link -> header.symbol_ptr;
	SOL_fstatus, SOL_fpos, multics_error_code = 0;
	eof, eoln = 2;				/* undefined !! */

	if sp ^= null then do;
	     next_fsb_ptr = pascal_operators_statics_$first_file_ptr;
	     pascal_operators_statics_$first_file_ptr = fsb_ptr;
	     if last_file_ptr = null then
		last_file_ptr = fsb_ptr;
	end;
	else do;
	     next_fsb_ptr = null;
	     if last_file_ptr = null then
		pascal_operators_statics_$first_file_ptr = fsb_ptr;
	     else
		last_file_ptr -> next_fsb_ptr = fsb_ptr;
	     last_file_ptr = fsb_ptr;
	end;
	fsb_is_chained = "1"b;

/* if array of file .. */

	if dim > 1 then do;
	     array_of_file = "1"b;
	     ptr6 = fsb_ptr;
	     do i = 2 to dim;
		ptr7 = fsb_ptr;
		fsb_ptr = addrel (fsb_ptr, size_);
		pascal_fsb = ptr6 -> pascal_fsb;
		allocated_size = 0;
		zone_ptr = addrel (zone_ptr, 32 / 4);
		file_name = zone_ptr -> acc.string;
		ptr7 -> next_element = rel (fsb_ptr);
		next_element = "0"b;
	     end;
	end;
	else do;
	     next_element = "0"b;
	end;

	call pascal_operators_$init_fsb_alloc_return;

error_while_init_fsb_alloc:
	call ioa_$rsnnl ("^/pascal_operators_$init_fsb_alloc: Bad parameters were given to this procedure.",
	     pascal_operators_statics_$error_info.string, string_length);
	go to fatal_error;
%page;
connect: entry (io_parameters) options (support);

/* uses :
   - block_ptr : ptr to the fsb.
   - two_words_value : ptr to the string.
   - size : length of the string.
   - stack_frame_ptr : ptr to the stack_frame of the calling procedure.

   Attachs a Pascal file.
   The string is a standard Multics attach description string.
*/

	fsb_ptr = block_ptr;
	sp = stack_frame_ptr;

	value_ptr = addr (two_words_value);
	switch_name = get_switch_name (fsb_ptr);

	if owner_stack ^= null then
	     if standard_file = "0"b then
		if (baseno (owner_stack) ^= baseno (sp)) | (rel (owner_stack) > rel (sp)) then do;
		     code = pascal_error_table_$bad_fsb;
		     go to error_while_connect;
		end;

	call iox_$find_iocb (switch_name, iocb_ptr, code);
	if code ^= 0 then go to error_while_connect;

	if iocb_ptr -> attach_descrip_ptr ^= null then do;
	     call fclose_;
	     call iox_$detach_iocb (iocb_ptr, code);
	     if code ^= 0 then go to error_while_connect;
	end;

	my_atd = rtrim (addr (type_) -> p5 -> atd_string);
	i1 = index (my_atd, " ");			/* for SOL programs */
	if i1 ^= 0 then
	     my_atd = substr (my_atd, 1, i1 - 1);
	i1 = index (my_atd, "[");
	do while (i1 ^= 0);
scan:
	     i2 = index (substr (my_atd, i1 + 1), "[");
	     i3 = index (substr (my_atd, i1 + 1), "]");
	     if (i2 ^= 0) & (i2 < i3) then do;
		i1 = i1 + i2;
		go to scan;
	     end;
	     if i3 = 0 then do;
		code = error_table_$unbalanced_brackets;
		go to error_while_connect;
	     end;
	     call cu_$evaluate_active_string (null, substr (my_atd, i1 + 1, i3 - 1),
		NORMAL_ACTIVE_STRING, return_string, code);
	     if code ^= 0 then go to error_while_connect;
	     my_atd = substr (my_atd, 1, i1 - 1) || return_string || substr (my_atd, i1 + i3 + 1);
	     i1 = index (my_atd, "[");
	end;
	if index (my_atd, "]") ^= 0 then do;
	     code = error_table_$unbalanced_brackets;
	     go to error_while_connect;
	end;
	call iox_$attach_ptr (iocb_ptr, rtrim (my_atd), null, code);
	if code ^= 0 then go to error_while_connect;

	attached_by_fconnect = "1"b;

	call pascal_operators_$connect_return;

error_while_connect:
	call ioa_$rsnnl ("^/Error connecting Pascal ^[text^;sequential^] file through ^a (attach description: ^a).",
	     pascal_operators_statics_$error_info.string, string_length, file_is_text = 1,
	     switch_name, addr (type_) -> p5 -> atd_string);
	go to fatal_error;
%page;
breakall_on: entry (io_parameters);

/* uses :
   block_ptr : ptr to the fsb */

dcl old_modes char (512);

	fsb_ptr = addr (block_ptr);
	switch_name = get_switch_name (fsb_ptr);

	if break_all_mode then return;

	call iox_$find_iocb (switch_name, iocb_ptr, code);
	if code ^= 0 then go to error_while_break_all_on;

	break_all_mode = "1"b;

	call iox_$modes (iocb_ptr, "breakall", old_modes, code);
	if code ^= error_table_$bad_mode then do;
	     if code ^= 0 then go to error_while_break_all_on;
	     if ^reset_break_all then
		if index (old_modes, "^breakall") ^= 0 then
		     reset_break_all = "1"b;
	end;


	return;

error_while_break_all_on:
	call ioa_$rsnnl ("
pascal_io_$breakall_on : Error while trying to set file ^a in breakall mode.",
	     pascal_operators_statics_$error_info.string, string_length,
	     file_name);
	go to fatal_error;
%page;
breakall_off: entry (io_parameters);

/* uses :
   block_ptr : ptr to the fsb */

	fsb_ptr = addr (block_ptr);
	switch_name = get_switch_name (fsb_ptr);

	if ^break_all_mode then return;

	call iox_$find_iocb (switch_name, iocb_ptr, code);
	if code ^= 0 then go to error_while_break_all_off;

	if reset_break_all then
	     call iox_$modes (iocb_ptr, "^breakall", "", code);

	reset_break_all = "0"b;
	break_all_mode = "0"b;

	return;

error_while_break_all_off:
	call ioa_$rsnnl ("
pascal_io_$breakall_off : Error while trying to set file ^a in ^breakall mode.",
	     pascal_operators_statics_$error_info.string, string_length,
	     file_name);
	go to fatal_error;


%page;
RESET: entry (io_parameters) options (support);

/* uses :
   - block_ptr : ptr to the pascal fsb ("version","global_flags","file_name","file_is_text",
   "rec_length" for non text files, and "buff_len" for text files MUST be previously initialized)
   -stack_frame_ptr : ptr to the stack_frame of the calling procedure.

   /*
*/

	call check_on_open;
	if code ^= 0 then go to error_while_RESET;

	if file_is_text ^= 0 then do;
	     if ^on_process_io () then do;
		call iox_$open (iocb_ptr, 1, "0"b, code); /* 1 : stream_input */
		if code ^= 0 then go to error_while_RESET;
	     end;
	     file_is_open = "1"b;
	     file_status = pascal_codes_$input_mode;
	     eof = 0;
	     record_counter = 1;
	     buff_index = 0;
	     buff_max = 0;
	     eoln = 1;
	     line_is_complete = "1"b;
	     window_pad = "0"b;
	     interactive_file = (sp -> interactive_mode) & (^vfile_switch);
	     if interactive_file then
		get_next_char = "1"b;
	     else do;
		call next_char;
		if code ^= 0 then go to error_while_RESET;
	     end;
	end;
	else do;
	     call iox_$open (iocb_ptr, 4, "0"b, code);	/* 4 : sequential input */
	     if code ^= 0 then go to error_while_RESET;
	     file_is_open = "1"b;
	     file_status = pascal_codes_$input_mode;
	     record_counter = 0;
	     call iox_$read_record (iocb_ptr, addr (window), rec_length, real_length, code);
	     if code = error_table_$end_of_info then eof = 1;
	     else do;
		eof = 0;
		if (code ^= 0) & (code ^= error_table_$long_record) then go to error_while_RESET;
		if (real_length ^= rec_length) & (sp -> io_warnings = "1"b) then
		     call com_err_ (0, "pascal_io_$RESET",
			"Warning: Records declared for Pascal file ^a are ^d bytes long and record read is ^d bytes long.
^[End of record is undefined.^;Record has been truncated.^]",
			file_name, rec_length, real_length, rec_length > real_length);
	     end;
	end;
	SOL_fpos = 1;

	call pascal_operators_$RESET_file_return;

error_while_RESET:
	call ioa_$rsnnl ("^/pascal_io_$RESET: Error during RESET on Pascal ^[text^;sequential^] file ^a",
	     pascal_operators_statics_$error_info.string, string_length, file_is_text = 1, file_name);
	go to fatal_error;
%page;
REWRITE: entry (io_parameters) options (support);

/* uses :
   - block_ptr : ptr to the pascal fsb ("version","global_flags","file_name","file_is_text",
   "rec_length" for non text files, and "buff_len" for text files MUST be previously initialized)
   - stack_frame_ptr : ptr to the stack frame of the calling procedure

   /*
*/

	call check_on_open;
	if code ^= 0 then go to error_while_REWRITE;

	if file_is_text ^= 0 then do;
	     if ^on_process_io () then do;
		call iox_$open (iocb_ptr, 2, "0"b, code); /* 2 : stream_output */
		if code ^= 0 then go to error_while_REWRITE;
	     end;
	     buff_index = 0;
	     window_pad = "0"b;
	     interactive_file = (sp -> interactive_mode) & (^vfile_switch);
	end;
	else do;
	     call iox_$open (iocb_ptr, 5, "0"b, code);	/* 5 : sequential output */
	     if code ^= 0 then go to error_while_REWRITE;
	end;
	file_is_open = "1"b;
	file_status = pascal_codes_$output_mode;
	eof = 1;
	record_counter = 0;
	SOL_fpos = 0;
	call pascal_operators_$REWRITE_return;

error_while_REWRITE:
	call ioa_$rsnnl ("^/pascal_io_$REWRITE: Error during REWRITE on Pascal ^[text^;sequential^] file ^a",
	     pascal_operators_statics_$error_info.string, string_length, file_is_text = 1, file_name);
	go to fatal_error;
%page;
open_update: entry (io_parameters) options (support);

/* uses ;
   - block_ptr : ptr to the pascal file fsb
   - stack_frame_ptr : ptr to the stack_frame of the calling procedure.

   /*
*/

	call check_on_open;
	if code ^= 0 then go to error_while_open_update;

	call iox_$open (iocb_ptr, 13, "0"b, code);	/* 13 : direct_update */
	if code ^= 0 then go to error_while_open_update;
	file_is_open = "1"b;
	file_status = pascal_codes_$direct_mode;
	eof = 0;
	SOL_fpos = 0;
	record_counter = 0;

	call pascal_operators_$open_update_return;

error_while_open_update:
	call ioa_$rsnnl ("^/pascal_io_$open_update: Error during FUPDATE on Pascal direct file ^a",
	     pascal_operators_statics_$error_info.string, string_length, file_name);
	go to fatal_error;
%page;
close_subroutine: entry (io_parameters);

/* uses :
   - block_ptr : (input) ptr to the Pascal fsb
*/

	fsb_ptr = block_ptr;
	cleanup_switch = "0"b;

	call close_file;

	multics_error_code = code;

	return;

%page;
fclose: entry (io_parameters) options (support);

/* uses :
   - block_ptr : (input) ptr to the pascal fsb .
   - stack_frame_ptr : (input) ptr to the stack_frame of the calling procedure

   /*
   Closes the file opened by Pascal (activated by call to fclose procedure).
*/

	fsb_ptr = block_ptr;
	call fclose_;

	call pascal_operators_$fclose_return;

error_while_fclose:
	call ioa_$rsnnl ("^/pascal_io_$fclose: Error during FCLOSE on Pascal file ^a",
	     pascal_operators_statics_$error_info.string, string_length, file_name);
	go to fatal_error;
%page;
close: entry (io_parameters) options (support);

/* uses :
   - block_ptr : (input) ptr to the pascal fsb .
   - stack_frame_ptr : (input) ptr to the stack_frame of the calling procedure

   /*
   Closes the file open by Pascal (Implicit close when exit of the procedure).
*/

	fsb_ptr = block_ptr;

	cleanup_switch = "0"b;

	if standard_file = "0"b then do;
	     call check_fsb_thread;
	     if return_check then do;
		call close_file;
		if code ^= 0 then go to error_while_close;
		if array_of_file then do;
		     head_ptr = fsb_ptr;
		     do while (next_element ^= "0"b);
			fsb_ptr = ptr (fsb_ptr, next_element);
			call close_file;
			if code ^= 0 then go to error_while_close;
		     end;
		     fsb_ptr = head_ptr;
		end;
		if local_file then do;
		     frame_length = allocated_size;
		     if frame_length ^= 0 then free fsb_ptr -> fsb_frame;
		end;
		else do;				/* fsb becomes inactive. It is put at the end */
						/* of the list, and owner_ptr becomes null */
		     if last_file_ptr = null then
			last_file_ptr, pascal_operators_statics_$first_file_ptr = fsb_ptr;
		     else do;
			last_file_ptr -> next_fsb_ptr = fsb_ptr;
			last_file_ptr = fsb_ptr;
		     end;
		     fsb_ptr -> next_fsb_ptr = null;
		     owner_stack = null;
		     fsb_is_chained = "1"b;
		end;
	     end;
	end;
	else do;
	     call close_file;
	     if code ^= 0 then go to error_while_close;
	end;

	call pascal_operators_$close_return;

error_while_close:
	call ioa_$rsnnl ("^/pascal_io_$close: Error during CLOSE on Pascal file ^a",
	     pascal_operators_statics_$error_info.string, string_length, file_name);
	go to fatal_error;
%page;
READ_text: entry (io_parameters) options (support);

/* uses;
   - block_ptr : (input) ptr to the pascal fsb (TEXT file)
   - type_ : (input)  type of the value to read (1 = character, 4 = integer, 8 = real)
   - two_words_value : (output) value to return ( char : 000X.0000 , integ : XXX.000 , real : XXXX.XXXX)
   /*
   Performs the Pascal READ on text files .
*/

	fsb_ptr = block_ptr;
	value_ptr = addr (two_words_value);

	if file_is_open then do;
	     if file_status = pascal_codes_$input_mode then go to READ_text_join;
	     else do;
		code = pascal_error_table_$read_when_no_input;
		go to error_while_READ_text;
	     end;
	end;
	else do;
	     code = pascal_error_table_$read_when_not_open;
	     go to error_while_READ_text;
	end;

fast_READ_text: entry (io_parameters) options (support);

	fsb_ptr = block_ptr;
	value_ptr = addr (two_words_value);

READ_text_join:

	sp = stack_frame_ptr;

	if get_next_char then do;
	     if ^(sp -> interactive_mode) then do;
		code = pascal_error_table_$not_interactive_mode;
		go to error_while_READ_text;
	     end;
	     call next_char;
	     if code ^= 0 then go to error_while_READ_text;
	     get_next_char = "0"b;
	end;

	if eof ^= 0 then do;
	     code = pascal_error_table_$read_when_eof;
	     go to error_while_READ_text;
	end;
	if type_ = 1 then do;			/* character */
	     four_byte_value = "0"b;
	     charact = window_char;
	     call next_char;
	     if code ^= 0 then go to error_while_READ_text;
	end;
	else do;
	     chiffre_ptr = addr (text_window);
	     big_integer = 0;
	     negative = 0;
	     if type_ = 4 then do;			/* integer */
		do while (window_char = " ");		/* spaces */
		     call next_char;
		     if code ^= 0 then go to error_while_READ_text;
		end;
		if window_char = "-" then do;		/* "-" */
		     negative = 1;
		     call next_char;
		     if code ^= 0 then go to error_while_READ_text;
		end;
		else do;
		     if window_char = "+" then do;	/* "+" */
			call next_char;
			if code ^= 0 then go to error_while_READ_text;
		     end;
		end;
		if chiffre < ascii_0_code | chiffre > ascii_9_code then do;
read_error_1:
		     if eof ^= 0 then code = pascal_error_table_$read_when_eof;
		     else code = pascal_error_table_$bad_integer_format;
		     go to error_while_READ_text;
		end;
		else do;
read_1:
		     big_integer = big_integer * 10 + chiffre - ascii_0_code;
		     if big_integer > pascal_constants_$max_integer_72 then do;
			if negative = 1 then integer = pascal_constants_$min_integer;
			else integer = pascal_constants_$max_integer;
read_2:
			call next_char;
			if code ^= 0 then go to error_while_READ_text;
			if chiffre >= ascii_0_code & chiffre <= ascii_9_code then go to read_2;
			if sp -> io_warnings then call com_err_ (0, "pascal_io_$READ",
				"Warning at line ^d of Pascal input file ^a:
	Too large ^[negative number was given, min_integer value (-34359738368)^;^positive number was given, max_integer value (34359738367)^] assumed",
				record_counter, file_name, (negative = 1), (negative = 0));
		     end;
		     else do;
			call next_char;
			if code ^= 0 then go to error_while_READ_text;
			if chiffre >= ascii_0_code & chiffre <= ascii_9_code then
			     go to read_1;
			integer = big_integer;
			if negative = 1 then integer = -integer;
		     end;
		end;
	     end;
	     else do;
		if type_ = 8 then do;		/* real */
		     exponent = 0;
		     digit_string = "+0000000000000000000e+00";
		     nbr_of_chars = 1;
		     do while (window_char = " ");	/* spaces */
			call next_char;
			if code ^= 0 then go to error_while_READ_text;
		     end;
		     if window_char = "-" then do;	/* "-" */
			negative = 1;
			substr (digit_string, 1, 1) = "-";
			call next_char;
			if code ^= 0 then go to error_while_READ_text;
		     end;
		     else do;
			if window_char = "+" then do; /* "+" */
			     call next_char;
			     if code ^= 0 then go to error_while_READ_text;
			end;
		     end;
		     if chiffre < ascii_0_code | chiffre > ascii_9_code then do;
read_error_2:
			if eof ^= 0 then code = pascal_error_table_$read_when_eof;
			else code = pascal_error_table_$bad_real_format;
			go to error_while_READ_text;
		     end;
		     do while (chiffre = ascii_0_code);
			call next_char;
			if code ^= 0 then go to error_while_READ_text;
		     end;
		     do while (chiffre >= ascii_0_code & chiffre <= ascii_9_code);
			if nbr_of_chars ^= 20 then do;
			     nbr_of_chars = nbr_of_chars + 1;
			     substr (digit_string, nbr_of_chars, 1) = window_char;
			end;
			exponent = exponent + 1;
			call next_char;
			if code ^= 0 then go to error_while_READ_text;
		     end;
		     if window_char = "." then do;	/* "." */
			call next_char;
			if code ^= 0 then go to error_while_READ_text;
			if chiffre < ascii_0_code | chiffre > ascii_9_code then
			     go to read_error_2;
			if nbr_of_chars = 1 then do;
			     do while (chiffre = ascii_0_code);
				call next_char;
				if code ^= 0 then go to error_while_READ_text;
				exponent = exponent - 1;
			     end;
			end;
			do while (chiffre >= ascii_0_code & chiffre <= ascii_9_code);
			     if nbr_of_chars ^= 20 then do;
				nbr_of_chars = nbr_of_chars + 1;
				substr (digit_string, nbr_of_chars, 1) = window_char;
			     end;
			     call next_char;
			     if code ^= 0 then go to error_while_READ_text;
			end;
		     end;
		     if (window_char = "e") | (window_char = "E") then do;
			exp = exponent;
			exponent = 0;
			call next_char;
			if code ^= 0 then go to error_while_READ_text;
			if window_char = "-" then do; /* "-" */
			     exp_signe = -1;
			     call next_char;
			     if code ^= 0 then go to error_while_READ_text;
			end;
			else do;
			     exp_signe = 1;
			     if window_char = "+" then do; /* "+" */
				call next_char;
				if code ^= 0 then go to error_while_READ_text;
			     end;
			end;
			if chiffre < ascii_0_code | chiffre > ascii_9_code then go to read_error_2;
			do while (chiffre >= ascii_0_code & chiffre <= ascii_9_code);
			     if exponent <= 10000 then do;
				exponent = exponent * 10 + (chiffre - ascii_0_code);
			     end;
			     call next_char;
			     if code ^= 0 then go to error_while_READ_text;
			end;
			exponent = exp + (exponent * exp_signe);
		     end;
		     if nbr_of_chars = 1 then real = 0;
		     else do;
			exponent = exponent - 19;
			exp = abs (exponent);
			if exponent < 0 then substr (digit_string, 22, 1) = "-";
			substr (digit_string, 24, 1) = DIGITS (mod (exp, 10));
			substr (digit_string, 23, 1) = DIGITS (exp / 10);
			if negative = 1 then do;
			     if exponent < 0 then do;
				if (substr (digit_string, 2, 19) <
				     "1469367938527859387" & exponent = -57) |
				     (exponent < -57) then do;
				     real = pascal_constants_$max_real_neg;
				     if sp -> io_warnings then
					call com_err_ (0, "pascal_io_$READ_text", "Warning at line ^d of Pascal input file ^a :
	too small negative value was given, max_real_neg value (-1.469E-39) was assumed", record_counter, file_name);
				end;
				else real = convert (real, digit_string);
			     end;
			     else do;
				if (substr (digit_string, 2, 19) >
				     "1701411834604692318" & exponent = 20) |
				     (exponent > 20) then do;
				     real = pascal_constants_$min_real;
				     if sp -> io_warnings then
					call com_err_ (0, "pascal_io_$READ_text", "Warning at line ^d of Pascal input file ^a :
	too big negative value was given, min_real value (-1.701 E38) was assumed", record_counter, file_name);
				end;
				else real = convert (real, digit_string);
			     end;
			end;
			else do;
			     if exponent < 0 then do;
				if (substr (digit_string, 2, 19) <
				     "1469367938527859386" & exponent = -57) |
				     (exponent < -57) then do;
				     real = pascal_constants_$min_real_pos;
				     if sp -> io_warnings then
					call com_err_ (0, "pascal_io_$READ_text", "Warning at line ^d of Pascal input file ^a :
	too small positive value was given, min_real_pos value (1.469E-39) was assumed", record_counter, file_name);
				end;
				else real = convert (real, digit_string);
			     end;
			     else do;
				if (substr (digit_string, 2, 19) > "1701411834604692317" & exponent = 20) | (exponent > 20) then do;
				     real = pascal_constants_$max_real;
				     if sp -> io_warnings then call com_err_ (0, "pascal_io_$READ_text", "Warning at line ^d of Pascal input file ^a :
	too big positive value was given, max_real value (1.7014E38) was assumed", record_counter, file_name);
				end;
				else real = convert (real, digit_string);
			     end;
			end;
		     end;
		end;
		else if type_ = 16 then do;
dcl var_string char (size_) varying based (zone_ptr);
		     var_string = "";
		     do while ((length (var_string) < size_) & ^(eoln = 1) & ^(eof = 1));
			var_string = var_string || window_char; call next_char;
		     end;
		end;
		else do;
		     code = pascal_error_table_$bad_args;
		     go to error_while_READ_text;
		end;
	     end;
	end;

	call pascal_operators_$READ_text_return;

error_while_READ_text:
	call ioa_$rsnnl ("^/pascal_io_$READ_text: Error during READ at line ^d of Pascal file ^a",
	     pascal_operators_statics_$error_info.string, string_length,
	     record_counter, file_name);
	go to fatal_error;
%page;
READ_sequential: entry (io_parameters) options (support);

/* uses :
   - block_ptr : ptr to the pascal fsb (non text file)
   - stack_frame_ptr
   /*
   Performs the Pascal READ on non text files .
*/

	fsb_ptr = block_ptr;
	int_value = two_words_value;
	value_ptr = addr (int_value);

	if file_is_open then do;
	     if file_status = pascal_codes_$input_mode then do;
		if eof = 0 then go to READ_sequential_join;
		else do;
		     code = pascal_error_table_$read_when_eof;
		     go to error_while_READ_sequential;
		end;
	     end;
	     else do;
		code = pascal_error_table_$read_when_no_input;
		go to error_while_READ_sequential;
	     end;
	end;
	else do;
	     code = pascal_error_table_$read_when_not_open;
	     go to error_while_READ_sequential;
	end;

fast_READ_sequential: entry (io_parameters) options (support);

	fsb_ptr = block_ptr;
	int_value = two_words_value;
	value_ptr = addr (int_value);

READ_sequential_join:

	sp = stack_frame_ptr;

	record_ptr = zone_ptr;
	record_length = rec_length;
	record = window;
	call iox_$read_record (system_ptr, addr (window), rec_length, real_length, code);
	if code = error_table_$end_of_info then eof = 1;
	else
	     if (code ^= 0) & (code ^= error_table_$long_record) then go to error_while_READ_sequential;
	if (real_length ^= rec_length) & (sp -> io_warnings = "1"b) then
	     call com_err_ (0, "pascal_io_$READ_sequential",
		"Warning : Records declared for Pascal file ^a are ^d bytes long and record read is ^d bytes long.
^[End of record is undefined.^;Record has been truncated.^]",
		file_name, rec_length, real_length, rec_length > real_length);
	record_counter = record_counter + 1;

	call pascal_operators_$READ_sequential_return;

error_while_READ_sequential:
	call ioa_$rsnnl ("^/pascal_io_$READ_sequential: Error during READ record ^d from Pascal file ^a",
	     pascal_operators_statics_$error_info.string, string_length,
	     record_counter + 1, file_name);
	go to fatal_error;
%page;
READLN: entry (io_parameters) options (support);

/* uses :
   - block_ptr ptr to the pascal fsb (text file)
   - stack_frame_ptr
   /*
   Performs the Pascal READLN .
*/

	fsb_ptr = block_ptr;
	if file_is_open then do;
	     if file_status = pascal_codes_$input_mode then do;
		if eof = 0 then go to READLN_join;
		else do;
		     code = pascal_error_table_$read_when_eof;
		     go to error_while_READLN;
		end;
	     end;
	     else do;
		code = pascal_error_table_$read_when_no_input;
		go to error_while_READLN;
	     end;
	end;
	else do;
	     code = pascal_error_table_$read_when_not_open;
	     go to error_while_READLN;
	end;

fast_READLN: entry (io_parameters) options (support);

	fsb_ptr = block_ptr;

READLN_join:

	sp = stack_frame_ptr;

	if get_next_char then do;
	     if ^(sp -> interactive_mode) then do;
		code = pascal_error_table_$not_interactive_mode;
		go to error_while_READLN;
	     end;
	     call next_char;
	     if code ^= 0 then go to error_while_READLN;
	     get_next_char = "0"b;
	end;

	i1 = index (substr (buffer, buff_index, buff_max - buff_index + 1), NL);
	do while (i1 = 0);
	     buff_index = buff_max;
	     call next_char;			/* refill the buffer */
	     if code ^= 0 then go to error_while_READLN;
	     i1 = index (substr (buffer, 1, buff_max), NL);
	end;
	eoln = 1;
	buff_index = buff_index - 1 + i1;

	if interactive_file then do;
	     if ^(sp -> interactive_mode) then do;
		code = pascal_error_table_$not_interactive_mode;
		go to error_while_READLN;
	     end;
	     get_next_char = "1"b;
	end;
	else do;
	     call next_char;
	     if code ^= 0 then go to error_while_READLN;
	end;

	call pascal_operators_$READLN_return;

error_while_READLN:
	call ioa_$rsnnl ("^/pascal_io_$READLN: Error whileduring READLN at line ^d of Pascal file ^a",
	     pascal_operators_statics_$error_info.string, string_length,
	     record_counter + 1, file_name);
	go to fatal_error;
%page;
WRITE_text: entry (io_parameters) options (support);

/* uses :
   - block_ptr : ptr to the pascal fsb (text file)
   - type_ , two_words_value :
   .    1 , 000X.0000     write a character
   .    2 , XXXX,0000     write a boolean
   .    4 , XXXX,0000     write an integer
   .    8 , XXXX,XXXX     write a real ("E" format)
   .   16 , XXXX,XXXX     write a real (float dec format)
   .   32 , (ptr to the string)     write a string of characters
   - io_length : desired length of the final io string
   - size : if type_ = 16 is the nbr of digits after the point
   if type_ = 32 is the length of the string
   - stack_frame_ptr
   /*
   Performs the Pascal WRITE on text files .
*/

	fsb_ptr = block_ptr;
	int_value = two_words_value;
	value_ptr = addr (int_value);

	if file_is_open then do;
	     if file_status = pascal_codes_$output_mode then go to WRITE_text_join;
	     else do;
		code = pascal_error_table_$write_when_no_output;
		go to error_while_WRITE_text;
	     end;
	end;
	else do;
	     code = pascal_error_table_$write_when_not_open;
	     go to error_while_WRITE_text;
	end;

fast_WRITE_text: entry (io_parameters) options (support);

	fsb_ptr = block_ptr;
	int_value = two_words_value;
	value_ptr = addr (int_value);

WRITE_text_join:

	sp = stack_frame_ptr;

	if io_length = 0 then call pascal_operators_$WRITE_text_return;
	if io_length < 0 then do;
	     code = pascal_error_table_$bad_args;
	     go to error_while_WRITE_text;
	end;
	if type_ >= 16 then
	     mode = size_;
	else mode = 0;

	begin;
dcl string_ptr ptr;
dcl pascal_string char (mode) unal based (string_ptr);
dcl temp_ptr ptr;
dcl string char (262144) based (temp_ptr);
dcl codes (262144) fixed bin (8) unal based (temp_ptr);
dcl chars (262144) char (1) unal based (temp_ptr);

dcl total_width fixed bin (21);
dcl vrai_string char (4) init ("VRAI") int static options (constant);
dcl faux_string char (4) init ("FAUX") int static options (constant);
dcl true_string char (4) init ("TRUE") int static options (constant);
dcl false_string char (5) init ("FALSE") int static options (constant);
dcl bad_length bit (1);
dcl int_size fixed bin (21);
dcl real_size fixed bin (21);
dcl nbr_of_prec_digits fixed bin (21);
dcl (i, j, k, l, z) fixed bin (21);
dcl big_integer fixed bin (71);
dcl next_i fixed bin (71);
dcl 1 output_buffer,
     2 default char (28) unal,
     2 mod_width char (mode) unal,
     2 other char (io_length) unal;

	     temp_ptr = addr (output_buffer);

	     bad_length = "0"b;
	     total_width = io_length;

	     if type_ = 2 then do;
		type_ = 32;
		if boolean = 1 then
		     if sp -> french_bit then do;
			zone_ptr = addr (vrai_string); size_ = 4;
		     end;
		     else do;
			zone_ptr = addr (true_string); size_ = 4;
		     end;
		else if boolean = 0 then
		     if sp -> french_bit then do;
			zone_ptr = addr (faux_string); size_ = 4;
		     end;
		     else do;
			zone_ptr = addr (false_string); size_ = 5;
		     end;
		else do;
		     code = pascal_error_table_$bad_boolean;
		     go to error_while_WRITE_text;
		end;
		mode = size_;
	     end;
	     if type_ = 1 then do;			/* character */
		substr (string, 1, total_width) = " ";
		substr (string, total_width, 1) = charact;
	     end;
	     else
		if type_ = 2 then do;		/* boolean */
						/* DONE BEFORE .. */
	     end;
	     else do;
		negative = 0;
		if type_ = 4 then do;		/* integer */
		     big_integer = integer;
		     if integer < 0 then do;
			big_integer = -big_integer;
			negative = 1;
		     end;
		     do int_size = 11 by -1 to 1;
			if tenpower_int (int_size) <= big_integer then go to write_1;
		     end;
write_1:

		     int_size = int_size + negative;
		     if total_width < int_size then do;
			total_width = int_size;
			bad_length = "1"b;
		     end;
		     j = total_width - int_size;
		     substr (string, 1, j) = " ";
		     j = j + 1;
		     if negative = 1 then do;
			chars (j) = "-";
			j = j + 1;
		     end;
		     do i = total_width by -1 to j;
			next_i = big_integer / 10;
			codes (i) = big_integer - 10 * next_i + ascii_0_code;
			big_integer = next_i;
		     end;
		end;
		else
		     if type_ = 8 then do;		/* float "e" format */
		     if total_width < 8 then do;
			total_width = 8;
			bad_length = "1"b;
		     end;
		     if real = zero_real then do;
			chars (1) = " ";
			do i = 2 to total_width;
			     chars (i) = "0";
			end;
			chars (3) = ".";
			substr (string, total_width - 3, 2) = "E+";
		     end;
		     else do;
			if real < 0 then do;
			     if real = pascal_constants_$min_real then
				real = pascal_constants_$max_real;
			     else real = -real;
			     negative = 1;
			end;
			if total_width <= 25 then
			     nbr_of_prec_digits = total_width - 7;
			else nbr_of_prec_digits = 18;
			do exponent = 38 by -1 to -38;
			     if tenpower_float (exponent) <= real then do;
				real = real * tenpower_float (-exponent);
				go to write_2;
			     end;
			end;
			real = real * tenpower_float (38);
			real = real * 10;
			exponent = -39;
write_2:
			big_integer = real *
			     tenpower_float (nbr_of_prec_digits + 1);
			if total_width <= 24 then do;
			     big_integer = big_integer + 5;
			     if big_integer >
				tenpower_big (nbr_of_prec_digits + 2) then do;
				big_integer = big_integer / 10;
				exponent = exponent + 1;
			     end;
			end;
			big_integer = big_integer / 10;
			if negative = 1 then chars (1) = "-";
			else chars (1) = " ";
			chars (3) = ".";
			j = nbr_of_prec_digits + 4;
			k = total_width - 4;
			do i = j to k;
			     chars (i) = "0";
			end;
			do i = j - 1 by -1 to 4;
			     next_i = big_integer / 10;
			     codes (i) = big_integer -
				10 * next_i + ascii_0_code;
			     big_integer = next_i;
			end;
			codes (2) = big_integer + ascii_0_code;
			chars (total_width - 3) = "E";
			if exponent < 0 then do;
			     chars (total_width - 2) = "-";
			     exponent = -exponent;
			end;
			else chars (total_width - 2) = "+";
			j = exponent / 10;
			codes (total_width - 1) = j + ascii_0_code;
			codes (total_width) = exponent - 10 * j + ascii_0_code;
		     end;
		end;
		else
		     if type_ = 16 then do;		/* float dec format */
		     if mode < 1 then do;
			code = pascal_error_table_$bad_args;
			go to error_while_WRITE_text;

		     end;
		     if real < 0 then do;
			if real = pascal_constants_$min_real then
			     real = pascal_constants_$max_real;
			else real = -real;
			negative = 1;
		     end;
		     real = real + 0.5 / tenpower_float (mode);
		     if mode + 2 + negative > total_width then do;
			total_width = mode + 2 + negative;
			bad_length = "1"b;
		     end;
		     do real_size = 38 by -1 to -38;
			if tenpower_float (real_size) <= real then
			     go to write_3;
		     end;
write_3:
		     real_size = real_size + 1;
		     if real ^= 0 & -real_size < mode then do;
			if real_size + negative + mode + 1 >
			     total_width then do;
			     total_width = real_size + negative + mode + 1;
			     bad_length = "1"b;
			end;
			z = real_size - 19;
			if z >= 0 then do;
			     j = total_width - (real_size + mode + 1);
			     substr (string, 1, j) = " ";
			     if negative = 1 then chars (j) = "-";
			     big_integer = real * tenpower_float (-z);
			     k = j + 19;
			     j = j + 1;
			     do i = k by -1 to j;
				next_i = big_integer / 10;
				codes (i) = big_integer - 10 * next_i + ascii_0_code;
				big_integer = next_i;
			     end;
			     do i = k + 1 to total_width;
				chars (i) = "0";
			     end;
			     chars (total_width - mode) = ".";
			end;
			else do;
			     if -z > mode then do;
				k = total_width;
				big_integer = real * tenpower_float (mode);
			     end;
			     else do;
				k = total_width - (mode + z) + 1;
				do i = k to total_width;
				     chars (i) = "0";
				end;
				k = k - 1;
				if -z > 38 then do;
				     real = real * tenpower_float (38);
				     big_integer = real * tenpower_float (-z - 38);
				end;
				else big_integer = real * tenpower_float (-z);
			     end;
			     if real_size <= 0 then do;
				j = total_width - (mode + 2);
				substr (string, 1, j) = " ";
				if negative = 1 then chars (j) = "-";
				substr (string, j + 1, 2) = "0.";
				j = j + 3;
				do i = k by -1 to j;
				     next_i = big_integer / 10;
				     codes (i) = big_integer - 10 * next_i + ascii_0_code;
				     big_integer = next_i;
				end;
				if big_integer ^= 0 then substr (string, j - 2, 1) = "1";
			     end;
			     else do;
				j = total_width - (mode + 1 + real_size);
				substr (string, 1, j) = " ";
				if negative = 1 then chars (j) = "-";
				l = total_width - mode;
				chars (l) = ".";
				l = l + 1;
				do i = k by -1 to l;
				     next_i = big_integer / 10;
				     codes (i) = big_integer - 10 * next_i + ascii_0_code;
				     big_integer = next_i;
				end;
				j = j + 1;
				do i = (l - 2) by -1 to j;
				     next_i = big_integer / 10;
				     codes (i) = big_integer - 10 * next_i + ascii_0_code;
				     big_integer = next_i;
				end;
				if big_integer ^= 0 then do;
				     if j = 1 then do;
					bad_length = "1"b;
					total_width = total_width + 1;
					substr (string, l - 1, 2) = "0.";
					substr (string, 1, 1) = "1";
					substr (string, k + 1, 1) = "0";
				     end;
				     else substr (string, j - 1, 1) = "1";
				end;
			     end;
			end;
		     end;
		     else do;
			j = total_width - mode;
			substr (string, j - 1, 2) = "0.";
			substr (string, 1, j - 2) = " ";
			do i = j + 1 to total_width;
			     chars (i) = "0";
			end;
			if negative = 1 then chars (j - 2) = "-";
		     end;
		end;
		else
		     if type_ = 32 then do;		/*  character string */
		     string_ptr = zone_ptr;
		     if size_ < 0 then do;
			code = pascal_error_table_$bad_args;
			go to error_while_WRITE_text;
		     end;
		     if total_width > size_ then do;
			k = total_width - size_;
			substr (string, 1, k) = " ";
			substr (string, k + 1, size_) = pascal_string;
		     end;
		     else
			substr (string, 1, total_width) = substr (pascal_string, 1, total_width);
		end;
		else do;
		     code = pascal_error_table_$bad_args;
		     go to error_while_WRITE_text;
		end;
	     end;

	     SOL_fpos = SOL_fpos + total_width;
	     if total_width < buff_len - buff_index then do;
		substr (buffer, buff_index + 1, total_width) = substr (string, 1, total_width);
		buff_index = buff_index + total_width;
	     end;
	     else do;
		if buff_index ^= 0 then do;
		     call iox_$put_chars (system_ptr, addr (buffer), buff_index, code);
		     if code ^= 0 then return;
		     buff_index = 0;
		end;
		if total_width > buff_len then do;
		     call iox_$put_chars (system_ptr, addr (string), total_width, code);
		     if code ^= 0 then return;
		end;
		else do;
		     substr (buffer, 1, total_width) = substr (string, 1, total_width);
		     buff_index = total_width;
		end;
	     end;
						/* FLUSH if interactive */
	     if interactive_file then
		if buff_index ^= 0 then do;
		     call iox_$put_chars (system_ptr, addr (buffer), buff_index, code);
		     if code ^= 0 then go to error_while_WRITE_text;
		     buff_index = 0;
		end;
	     if bad_length then
		if sp -> io_warnings then call com_err_ (0, "pascal_io_$WRITE", "Warning at line ^d of PASCAL output file ^a :
	too small length (^d) was given for the string ""^a""", record_counter + 1, file_name, io_length, substr (string, 1, total_width));
	     window_char = chars (total_width);
	end;					/* of the begin block */

	call pascal_operators_$WRITE_text_return;

error_while_WRITE_text:
	if type_ = 1 then do;
	     call ioa_$rsnnl ("^/pascal_io_$WRITE_text: Error during WRITE(^[^a^s^;^s^a^],""^a"":^d)  [at line ^d]",
		pascal_operators_statics_$error_info.string, string_length,
		file_name, charact, io_length, record_counter + 1);
	end;
	else do;
	     if type_ = 2 then do;
		call ioa_$rsnnl ("^/pascal_io_$WRITE_text: Error during WRITE boolean ^[""^36b""b^s^;^[TRUE^;^FALSE^]^] on ^d chars at line ^d of Pascal file ^a",
		     pascal_operators_statics_$error_info.string, string_length,
		     (boolean ^= 0) & (boolean ^= 1), unspec (boolean), boolean = 1,
		     io_length, record_counter + 1, file_name);
	     end;
	     else do;
		if type_ = 4 then do;
		     call ioa_$rsnnl ("^/pascal_io_$WRITE_text: Error during WRITE integer ^d on ^d chars at line ^d of Pascal file ^a",
			pascal_operators_statics_$error_info.string, string_length,
			integer, io_length, record_counter + 1, file_name);
		end;
		else do;
		     if type_ = 8 then do;
			call ioa_$rsnnl ("^/pascal_io_$WRITE_text: Error during WRITE real ^f on ^d chars at line ^d of Pascal file ^a",
			     pascal_operators_statics_$error_info.string, string_length,
			     real, io_length, record_counter + 1, file_name);
		     end;
		     else do;
			if type_ = 16 then do;
			     call ioa_$rsnnl ("^/pascal_io_$WRITE_text: Error during WRITE real ^f (with ^d decimal numbers) on ^d chars at line ^d of Pascal file ^a",
				pascal_operators_statics_$error_info.string,
				string_length, real, size_, io_length,
				record_counter + 1, file_name);
			end;
			else do;
			     if type_ = 32 then do;
				call ioa_$rsnnl ("^/pascal_io_$WRITE_text: Error during WRITE character string (^d chars at ^p) on ^d chars at line ^d of Pascal file ^a",
				     pascal_operators_statics_$error_info.string,
				     string_length, size_, zone_ptr,
				     io_length, record_counter + 1, file_name);
			     end;
			     else do;
				call ioa_$rsnnl ("^/pascal_io_$WRITE_text: Error during WRITE at line ^d of Pascal file ^a: unknown type of value code (^d)",
				     pascal_operators_statics_$error_info.string,
				     string_length,
				     record_counter + 1, file_name, type_);
			     end;
			end;
		     end;
		end;
	     end;
	end;
	go to fatal_error;
%page;
WRITE_sequential: entry (io_parameters) options (support);

/* uses :
   - block_ptr : ptr to the pascal fsb (non text file)
   - type_ , two_words_value : different possibilities :
   .    rec_length :     1         2         4         8         n
   two_words_value : 000X,0000 00XX,0000 XXXX,0000 XXXX,XXXX   (ptr)
   -----------------------------------------------------------------
   type_ ; 1 char        yes                 yes
   .      2 boolean     yes                 yes
   .      4 integer     yes       yes       yes
   .      8 real                                      yes
   .      32 char str.                                           yes
   .      64 record                                              yes

   /*
   Performs the Pascal WRITE on non text files .
*/

	fsb_ptr = block_ptr;
	int_value = two_words_value;
	value_ptr = addr (int_value);

	if file_is_open then do;
	     if file_status = pascal_codes_$output_mode then go to WRITE_sequential_join;
	     else do;
		code = pascal_error_table_$write_when_no_output;
		go to error_while_WRITE_sequential;
	     end;
	end;
	else do;
	     code = pascal_error_table_$write_when_not_open;
	     go to error_while_WRITE_sequential;
	end;

fast_WRITE_sequential: entry (io_parameters) options (support);

	fsb_ptr = block_ptr;
	int_value = two_words_value;
	value_ptr = addr (int_value);

WRITE_sequential_join:

	if (type_ = 1 | type_ = 2 | type_ = 4) & (rec_length = 1) then
	     addr (window) -> one_byte_data = one_byte_value;
	else do;
	     if (type_ = 4) & (rec_length = 2) then
		addr (window) -> two_byte_data = two_byte_value;
	     else do;
		if (type_ = 1 | type_ = 2 | type_ = 4) & (rec_length = 4) then
		     addr (window) -> four_byte_data = four_byte_value;
		else do;
		     if (type_ = 8) & (rec_length = 8) then
			addr (window) -> eight_byte_data = eight_byte_value;
		     else do;
			if (type_ = 32 | type_ = 64) then do;
			     record_ptr = zone_ptr;
			     record_length = rec_length;
			     window = record;
			end;
			else do;
			     code = pascal_error_table_$bad_args;
			     go to error_while_WRITE_sequential;
			end;
		     end;
		end;
	     end;
	end;
	call iox_$write_record (system_ptr, addr (window), rec_length, code);
	if code ^= 0 then go to error_while_WRITE_sequential;
	record_counter = record_counter + 1;
	SOL_fpos = SOL_fpos + 1;

	call pascal_operators_$WRITE_sequential_return;

error_while_WRITE_sequential:
	call ioa_$rsnnl ("^/pascal_io_$WRITE_sequential: Error during WRITE record ^d on Pascal file ^a",
	     pascal_operators_statics_$error_info.string, string_length,
	     record_counter + 1, file_name);
	go to fatal_error;
%page;
WRITELN: entry (io_parameters) options (support);

/* uses :
   -block_ptr ptr to the pascal fsb
   /*
   Performs the Pascal WRITELN .
*/

	fsb_ptr = block_ptr;

	if file_is_open then do;
	     if file_status = pascal_codes_$output_mode then go to WRITELN_join;
	     else do;
		code = pascal_error_table_$write_when_no_output;
		go to error_while_WRITELN;
	     end;
	end;
	else do;
	     code = pascal_error_table_$write_when_not_open;
	     go to error_while_WRITELN;
	end;

fast_WRITELN: entry (io_parameters) options (support);

	fsb_ptr = block_ptr;

WRITELN_join:

	call writeln;
	if code ^= 0 then go to error_while_WRITELN;

	call pascal_operators_$WRITELN_return;

error_while_WRITELN:
	call ioa_$rsnnl ("^/pascal_io_$WRITELN: Error during WRITELN at line ^d of Pascal file ^a",
	     pascal_operators_statics_$error_info.string, string_length,
	     record_counter + 1, file_name);
	go to fatal_error;
%page;
FLUSH: entry (io_parameters) options (support);

/* uses :
   -block_ptr ptr to the pascal fsb
   /*
   Performs the Pascal FLUSH .
*/

	fsb_ptr = block_ptr;

	if file_is_open then do;
	     if file_status = pascal_codes_$output_mode then go to FLUSH_join;
	     else do;
		code = pascal_error_table_$write_when_no_output;
		go to error_while_FLUSH;
	     end;
	end;
	else do;
	     code = pascal_error_table_$write_when_not_open;
	     go to error_while_FLUSH;
	end;

fast_FLUSH: entry (io_parameters) options (support);

	fsb_ptr = block_ptr;

FLUSH_join:

	if buff_index ^= 0 then do;
	     call iox_$put_chars (system_ptr, addr (buffer), buff_index, code);
	     if code ^= 0 then go to error_while_FLUSH;
	     buff_index = 0;
	end;

	call pascal_operators_$FLUSH_return;

error_while_FLUSH:
	call ioa_$rsnnl ("^/pascal_io_$FLUSH: Error during FLUSH at line ^d of Pascal file ^a",
	     pascal_operators_statics_$error_info.string, string_length,
	     record_counter + 1, file_name);
	go to fatal_error;
%page;
PAGE: entry (io_parameters) options (support);

/* uses :
   - block_ptr : ptr to the pascal fsb (text file)
   /*
   Performs the Pascal PAGE .
*/

	fsb_ptr = block_ptr;

	if file_is_open then do;
	     if file_status = pascal_codes_$output_mode then go to PAGE_join;
	     else do;
		code = pascal_error_table_$write_when_no_output;
		go to error_while_PAGE;
	     end;
	end;
	else do;
	     code = pascal_error_table_$write_when_not_open;
	     go to error_while_PAGE;
	end;

fast_PAGE: entry (io_parameters) options (support);

	fsb_ptr = block_ptr;

PAGE_join:

	if buff_index ^= 0 then do;
	     call writeln;
	     if code ^= 0 then go to error_while_PAGE;
	end;
	buff_index = 1;
	SOL_fpos = SOL_fpos + 1;
	substr (buffer, buff_index, 1) = "";						/* ascii new_page */
	call iox_$put_chars (system_ptr, addr (buffer), 1, code);
	if code ^= 0 then go to error_while_PAGE;
	record_counter = record_counter + 1;
	buff_index = 0;

	call pascal_operators_$PAGE_return;

error_while_PAGE:
	call ioa_$rsnnl ("^/pascal_io_$PAGE: Error during PAGE at line ^d of Pascal text file ^a",
	     pascal_operators_statics_$error_info.string, string_length,
	     record_counter + 1, file_name);
	go to fatal_error;
%page;
PUT_text: entry (io_parameters) options (support);

/* uses :
   - block_ptr : ptr to the pascal fsb (text file)
   /*
   Performs the Pascal PUT on a text file .
*/

	fsb_ptr = block_ptr;

	if file_is_open then do;
	     if file_status = pascal_codes_$output_mode then go to PUT_text_join;
	     else do;
		code = pascal_error_table_$write_when_no_output;
		go to error_while_PUT_text;
	     end;
	end;
	else do;
	     code = pascal_error_table_$write_when_not_open;
	     go to error_while_PUT_text;
	end;

fast_PUT_text: entry (io_parameters) options (support);

	fsb_ptr = block_ptr;

PUT_text_join:

	buff_index = buff_index + 1;
	if buff_index > buff_len then do;
	     call iox_$put_chars (system_ptr, addr (buffer), buff_len, code);
	     if code ^= 0 then go to error_while_PUT_text;
	     buff_index = 1;
	end;
	substr (buffer, buff_index, 1) = window_char;
	SOL_fpos = SOL_fpos + 1;

/* FLUSH if interactive */
	if interactive_file then do;
	     call iox_$put_chars (system_ptr, addr (buffer), 1, code);
	     if code ^= 0 then go to error_while_PUT_text;
	     buff_index = 0;
	end;

	call pascal_operators_$PUT_text_return;

error_while_PUT_text:
	call ioa_$rsnnl ("^/pascal_io_$PUT_text: Error during PUT at line ^d of Pascal text file ^a",
	     pascal_operators_statics_$error_info.string, string_length,
	     record_counter + 1, file_name);
	go to fatal_error;
%page;
PUT_sequential: entry (io_parameters) options (support);

/* uses :
   - block_ptr : ptr to the pascal fsb (non text file)
   /*
   Performs the Pascal PUT on a non text file .
*/

	fsb_ptr = block_ptr;

	if file_is_open then do;
	     if file_status = pascal_codes_$output_mode then go to PUT_sequential_join;
	     else do;
		code = pascal_error_table_$write_when_no_output;
		go to error_while_PUT_sequential;
	     end;
	end;
	else do;
	     code = pascal_error_table_$write_when_not_open;
	     go to error_while_PUT_sequential;
	end;

fast_PUT_sequential: entry (io_parameters) options (support);

	fsb_ptr = block_ptr;

PUT_sequential_join:

	call iox_$write_record (system_ptr, addr (window), rec_length, code);
	if code ^= 0 then go to error_while_PUT_sequential;
	record_counter = record_counter + 1;
	SOL_fpos = SOL_fpos + 1;

	call pascal_operators_$PUT_sequential_return;

error_while_PUT_sequential:
	call ioa_$rsnnl ("^/pascal_io_$PUT_sequential: Error during PUT record ^d on Pascal file ^a",
	     pascal_operators_statics_$error_info.string, string_length,
	     record_counter + 1, file_name);
	go to fatal_error;
%page;
GET_text: entry (io_parameters) options (support);

/* uses :
   - block_ptr : ptr to the pascal fsb (text file)
   - stack_frame_ptr : ptr to caller's stack_frame
   /*
   Performs the Pascal GET on a text file .
*/

	fsb_ptr = block_ptr;

	if file_is_open then do;
	     if file_status = pascal_codes_$input_mode then go to GET_text_join;
	     else do;
		code = pascal_error_table_$read_when_no_input;
		go to error_while_GET_text;
	     end;
	end;
	else do;
	     code = pascal_error_table_$read_when_not_open;
	     go to error_while_GET_text;
	end;

fast_GET_text: entry (io_parameters) options (support);

	fsb_ptr = block_ptr;

GET_text_join:

	if get_next_char then do;
	     if ^(stack_frame_ptr -> interactive_mode) then do;
		code = pascal_error_table_$not_interactive_mode;
		go to error_while_GET_text;
	     end;
	     call next_char;
	     if code ^= 0 then go to error_while_GET_text;
	     get_next_char = "0"b;
	end;

	call next_char;
	if code ^= 0 then go to error_while_GET_text;

	call pascal_operators_$GET_text_return;

error_while_GET_text:
	call ioa_$rsnnl ("^/pascal_io_$GET_text: Error during GET at line ^d of Pascal file ^a",
	     pascal_operators_statics_$error_info.string, string_length,
	     record_counter + 1, file_name);
	go to fatal_error;
%page;
defered_GET_text: entry (io_parameters) options (support);

/* uses :
   - block_ptr : ptr to the pascal fsb (text file)
   /*
   Called by pascal_operators_.alm on text reference, if there
   is one error or if next char is previously to read.
*/

	fsb_ptr = block_ptr;

	if file_is_open then do;
	     if file_status = pascal_codes_$input_mode then go to defered_GET_text_join;
	     else do;
		code = pascal_error_table_$read_when_no_input;
		go to error_while_defered_GET_text;
	     end;
	end;
	else do;
	     code = pascal_error_table_$read_when_not_open;
	     go to error_while_defered_GET_text;
	end;

fast_defered_GET_text: entry (io_parameters) options (support);

	fsb_ptr = block_ptr;

defered_GET_text_join:
	call next_char;
	if code ^= 0 then go to error_while_defered_GET_text;
	get_next_char = "0"b;

	call pascal_operators_$defered_GET_text_return;

error_while_defered_GET_text:
	call ioa_$rsnnl ("^/pascal_io_$defered_GET_text: Error during GET on Pascal text file ^a",
	     pascal_operators_statics_$error_info.string, string_length, file_name);
	go to fatal_error;
%page;
GET_sequential: entry (io_parameters) options (support);

/* uses :
   - block_ptr : ptr to the pascal fsb (non text file)
   - stack_frame_ptr
   /*
   Performs the Pascal GET on non text files .
*/

	fsb_ptr = block_ptr;

	if file_is_open then do;
	     if file_status = pascal_codes_$input_mode then do;
		if eof = 0 then go to GET_sequential_join;
		else do;
		     code = pascal_error_table_$read_when_eof;
		     go to error_while_GET_sequential;
		end;
	     end;
	     else do;
		code = pascal_error_table_$read_when_no_input;
		go to error_while_GET_sequential;
	     end;
	end;
	else do;
	     code = pascal_error_table_$read_when_not_open;
	     go to error_while_GET_sequential;
	end;

fast_GET_sequential: entry (io_parameters) options (support);

	fsb_ptr = block_ptr;

GET_sequential_join:

	sp = stack_frame_ptr;

	call iox_$read_record (system_ptr, addr (window), rec_length, real_length, code);
	if code = error_table_$end_of_info then eof = 1;
	else
	     if (code ^= 0) & (code ^= error_table_$long_record) then go to error_while_GET_sequential;
	if (real_length ^= rec_length) & (sp -> io_warnings = "1"b) then
	     call com_err_ (0, "pascal_io_$GET_sequential",
		"Warning : Records declared for Pascal file ^a are ^d bytes long and record read is ^d bytes long.
^[End of record is undefined.^;Record has been truncated.^]",
		file_name, rec_length, real_length, rec_length > real_length);
	record_counter = record_counter + 1;
	SOL_fpos = SOL_fpos + 1;

	call pascal_operators_$GET_sequential_return;

error_while_GET_sequential:
	call ioa_$rsnnl ("^/pascal_io_$GET_sequential: Error during GET of record ^d from Pascal file ^a",
	     pascal_operators_statics_$error_info.string, string_length,
	     record_counter + 1, file_name);
	go to fatal_error;
%page;
GET_direct: entry (io_parameters) options (support);

/* uses :
   - block_ptr : ptr to the pascal fsb
   - two_words_value : (XXXX.0000) nbr of the record
   - stack_frame_ptr

   /*
   Performs the Pascal GET on direct files.
*/

	fsb_ptr = block_ptr;
	value_ptr = addr (two_words_value);

	if file_is_open then do;
	     if file_status = pascal_codes_$direct_mode then go to GET_direct_join;
	     else do;
		code = pascal_error_table_$non_direct;
		go to error_while_GET_direct;
	     end;
	end;
	else do;
	     code = pascal_error_table_$read_when_not_open;
	     go to error_while_GET_direct;
	end;

fast_GET_direct: entry (io_parameters) options (support);

	fsb_ptr = block_ptr;
	value_ptr = addr (two_words_value);

GET_direct_join:

	sp = stack_frame_ptr;

	SOL_fpos,
	     record_counter = integer;
	key = char (integer);
	call iox_$seek_key (system_ptr, key, real_length, code);
	if code ^= 0 then go to error_while_GET_direct;
	call iox_$read_record (system_ptr, addr (window), rec_length, real_length, code);
	if (code ^= 0) & (code ^= error_table_$long_record) then go to error_while_GET_direct;
	if (real_length ^= rec_length) & (sp -> io_warnings = "1"b) then
	     call com_err_ (0, "pascal_io_$GET_direct",
		"Warning : Records declared for Pascal file ^a are ^d bytes long and record read is ^d bytes long.
^[End of record is undefined.^;Record has been truncated.^]",
		file_name, rec_length, real_length, rec_length > real_length);

	call pascal_operators_$GET_direct_return;

error_while_GET_direct:
	call ioa_$rsnnl ("^/pascal_io_$GET_direct: Error during GET record ^d on direct Pascal file ^a",
	     pascal_operators_statics_$error_info.string, string_length, record_counter, file_name);
	go to fatal_error;
%page;
PUT_direct: entry (io_parameters) options (support);

/* uses :
   - block_ptr : ptr to the pascal file fsb
   - two_words_value : (XXXX.0000) nbr of the record

   /*
   Performs the Pascal PUT on direct files.
*/

	fsb_ptr = block_ptr;
	value_ptr = addr (two_words_value);

	if file_is_open then do;
	     if file_status = pascal_codes_$direct_mode then go to PUT_direct_join;
	     else do;
		code = pascal_error_table_$non_direct;
		go to error_while_PUT_direct;
	     end;
	end;
	else do;
	     code = pascal_error_table_$write_when_not_open;
	     go to error_while_PUT_direct;
	end;

fast_PUT_direct: entry (io_parameters) options (support);

	fsb_ptr = block_ptr;
	value_ptr = addr (two_words_value);

PUT_direct_join:

	SOL_fpos,
	     record_counter = integer;
	key = char (integer);
	call iox_$seek_key (system_ptr, key, real_length, code);
	if code = 0 then do;
	     call iox_$rewrite_record (system_ptr, addr (window), rec_length, code);
	     if code ^= 0 then go to error_while_PUT_direct;
	end;
	else do;
	     if code = error_table_$no_record then do;
		call iox_$write_record (system_ptr, addr (window), rec_length, code);
		if code ^= 0 then go to error_while_PUT_direct;
	     end;
	     else go to error_while_PUT_direct;
	end;

	call pascal_operators_$PUT_direct_return;

error_while_PUT_direct:
	call ioa_$rsnnl ("^/pascal_io_$PUT_direct: Error during PUT record ^d on direct Pascal file ^a",
	     pascal_operators_statics_$error_info.string, string_length, record_counter, file_name);
	go to fatal_error;
%page;
close_level_files: entry (io_parameters) options (support);

/* uses :
   -stack_frame_ptr : ptr to the stack frame  to clean

   /*
   Closes all the files opened by this procedure (if they are not).
   called by unwinder_ on CLEANUP of Pascal procedures.
*/

	sp = stack_frame_ptr;

	cleanup_switch = "1"b;

	if sp -> close_input then do;
	     fsb_ptr = addr (pascal_operators_statics_$INPUT);
	     call close_file;
	     if code ^= 0 then do;
		call com_err_ (code, "pascal_io_$close", "Error while closing Pascal file ""input""");
		code = 0;
	     end;
	end;

	if sp -> close_output then do;
	     fsb_ptr = addr (pascal_operators_statics_$OUTPUT);
	     call close_file;
	     if code ^= 0 then do;
		call com_err_ (code, "pascal_io_$close", "Error while closing Pascal file ""output""");
		code = 0;
	     end;
	end;

	if sp -> close_error then do;
	     fsb_ptr = addr (pascal_operators_statics_$ERROR);
	     call close_file;
	     if code ^= 0 then do;
		call com_err_ (code, "pascal_io_$close", "Error while closing Pascal file ""error""");
		code = 0;
	     end;
	end;

	if sp -> close_entree then do;
	     fsb_ptr = addr (pascal_operators_statics_$ENTREE);
	     call close_file;
	     if code ^= 0 then do;
		call com_err_ (code, "pascal_io_$close", "Error while closing Pascal file ""entree""");
		code = 0;
	     end;
	end;

	if sp -> close_sortie then do;
	     fsb_ptr = addr (pascal_operators_statics_$SORTIE);
	     call close_file;
	     if code ^= 0 then do;
		call com_err_ (code, "pascal_io_$close", "Error while closing Pascal file ""sortie""");
		code = 0;
	     end;
	end;

	if sp -> close_erreur then do;
	     fsb_ptr = addr (pascal_operators_statics_$ERREUR);
	     call close_file;
	     if code ^= 0 then do;
		call com_err_ (code, "pascal_io_$close", "Error while closing Pascal file ""erreur""");
		code = 0;
	     end;
	end;

	fsb_ptr = pascal_operators_statics_$first_file_ptr;

	do while (fsb_ptr ^= null);
	     ptr6 = next_fsb_ptr;
	     if owner_stack = sp then do;
		call check_fsb_thread;
		if return_check then do;
		     call close_file;
		     if code ^= 0 then do;
			call com_err_ (code, "pascal_io_$close",
			     "Error while closing Pascal file ""^a""", file_name);
			code = 0;
		     end;
		     if array_of_file then do;
			head_ptr = fsb_ptr;
			do while (next_element ^= "0"b);
			     fsb_ptr = ptr (fsb_ptr, next_element);
			     call close_file;
			     if code ^= 0 then do;
				call com_err_ (code, "pascal_io_$close",
				     "Error while closing Pascal file ""^a"".", file_name);
				code = 0;
			     end;
			end;
			fsb_ptr = head_ptr;
		     end;
		     if local_file then do;
			frame_length = allocated_size;
			if frame_length ^= 0 then free fsb_ptr -> fsb_frame;
		     end;
		     else do;			/* fsb becomes inactive. It is put at the end */
						/* of the list, and owner_ptr becomes null */
			if last_file_ptr = null then
			     last_file_ptr, pascal_operators_statics_$first_file_ptr = fsb_ptr;
			else do;
			     last_file_ptr -> next_fsb_ptr = fsb_ptr;
			     last_file_ptr = fsb_ptr;
			end;
			fsb_ptr -> next_fsb_ptr = null;
			owner_stack = null;
			fsb_is_chained = "1"b;
		     end;
		end;
	     end;
	     fsb_ptr = ptr6;
	end;

	return;
%page;
writeln: proc;
	buff_index = buff_index + 1;
	if buff_index > buff_len then do;
	     call iox_$put_chars (system_ptr, addr (buffer), buff_len, code);
	     if code ^= 0 then return;
	     buff_index = 1;
	end;
	substr (buffer, buff_index, 1) = "
";						/* ascii new_line */
	call iox_$put_chars (system_ptr, addr (buffer), buff_index, code);
	if code ^= 0 then return;
	record_counter = record_counter + 1;
	SOL_fpos = SOL_fpos + 1;
	buff_index = 0;
	window_char = " ";				/* space */

	return;

     end writeln;
%page;
next_char: proc;

dcl n_read fixed bin (21);
dcl on_tty bit (1);

	if eof = 0 then do;
	     if buff_index >= buff_max then do;
		if break_all_mode then do;
		     call iox_$get_chars (system_ptr, addr (buffer), 1, n_read, code);
		     if code ^= 0
			& (code ^= error_table_$end_of_info)
			& (code ^= error_table_$short_record) then return;
		     if code = error_table_$end_of_info then go to eof_found;
		end;
		else if vfile_switch then do;
		     call iox_$get_chars (system_ptr, addr (buffer), buff_len, n_read, code);
		     if (code ^= 0)
			& (code ^= error_table_$end_of_info)
			& (code ^= error_table_$short_record) then return;
		     if code = error_table_$end_of_info then go to eof_found;
		end;
		else do;
		     on_tty = "0"b;
		     if line_is_complete then do;
			iocb_ptr = system_ptr;
test_attach:
			if iocb_ptr -> syn_father = null then go to no_prompt;
			iocb_ptr = iocb_ptr -> syn_father;
			if iocb_ptr -> iocb.name ^= "user_i/o" then go to test_attach;
			on_tty = "1"b;
			if prompt_wanted then do;
			     call iox_$put_chars (iox_$user_io,
				addr (addr (prompt_string) -> char_var.s),
				length (prompt_string), code);
			     if code ^= 0 then do;
				code = pascal_error_table_$prompt_error;
				return;
			     end;
			end;
no_prompt:
		     end;
		     call iox_$get_line (system_ptr, addr (buffer), buff_len, n_read, code);
		     if code ^= 0
			& code ^= error_table_$long_record
			& code ^= error_table_$short_record
			& code ^= error_table_$end_of_info then return;
		     if code = error_table_$end_of_info then go to eof_found;
		     else do;
			if on_tty then do;
			     if (line_is_complete = "1"b) & (n_read >= 2) then do;
				if substr (buffer, 1, 2) = "\f" then
				     go to eof_found;
			     end;
			end;
			if code = error_table_$long_record
			     | code = error_table_$short_record then
			     line_is_complete = "0"b;
			else
			     line_is_complete = "1"b;
		     end;
		end;
		buff_max = n_read;
		buff_index = 1;
		code = 0;
	     end;
	     else
		buff_index = buff_index + 1;
	     window_char = substr (buffer, buff_index, 1);
	     SOL_fpos = SOL_fpos + 1;
	     if window_char = "
"	     then do;
		window_char = " ";
		eoln = 1;
		record_counter = record_counter + 1;
	     end;
	     else do;
		eoln = 0;
	     end;
	end;
	else code = pascal_error_table_$read_when_eof;
	return;

eof_found:
	if eoln = 0 then do;			/* ISO 6.6.5.2 */
	     eoln = 1; window_char = " ";
	     buff_index, buff_max = 1; substr (buffer, 1, 1) = "
";
	end;
	else do;
	     eof = 1; eoln = 0; window_char = " ";
	end;
	code = 0;
	return;

     end next_char;
%page;
check_fsb_thread: proc;

/* this procedure checks validity of pascal fsb thread.
   if fsb pointed by fsb_ptr is found in the list, and if it is valid, return check is set to "1"b and the fsb is
   put off the list. Otherwise return_check is set to "0"b.
   If the thread has been damaged, the list is shorted in order to remain valid.
   A warning may be edited on error_output.
*/

dcl (ptr1, ptr2, ptr3) ptr;

fsb_is_damaged: proc returns (bit (1));
	if (ptr1 -> fsb_is_chained = "0"b)
	     | (ptr1 -> standard_file = "1"b)
	     | (ptr1 -> uid = "0"b)
	     | (ptr1 -> global_flags.pad ^= "0"b) then return ("1"b);
	return ("0"b);
     end;

	return_check = "0"b;
	ptr1 = pascal_operators_statics_$first_file_ptr;
	ptr2 = null;
	err_label = bad_fsb;
	on any_other go to err_label;

	do while (ptr1 ^= null);
	     if fsb_is_damaged () then go to bad_fsb;
	     if ptr1 -> owner_link -> header.symbol_ptr ^= ptr1 -> owner_symbol then do; /* something goes wrong */
		if last_file_ptr = ptr1 then last_file_ptr = ptr2;
		if ptr2 = null then pascal_operators_statics_$first_file_ptr = ptr1 -> next_fsb_ptr;
		else ptr2 -> next_fsb_ptr = ptr1 -> next_fsb_ptr;
		ptr1 -> fsb_is_chained = "0"b;
		if (ptr1 -> local_file) | (ptr1 -> static_file) then
		     call delete_$path (get_pdir_ (), get_switch_name (ptr1), "100100"b, "", code);
		code = 0;				/* dont care */
		frame_length = ptr1 -> allocated_size;
		ptr3 = ptr1 -> next_fsb_ptr;
		if frame_length ^= 0 then free ptr1 -> fsb_frame;
		ptr1 = ptr3;
	     end;
	     else do;
		if ptr1 = fsb_ptr then do;
		     if ptr1 = last_file_ptr then last_file_ptr = ptr2;
		     if ptr2 = null then
			pascal_operators_statics_$first_file_ptr = ptr1 -> next_fsb_ptr;
		     else ptr2 -> next_fsb_ptr = ptr1 -> next_fsb_ptr;
		     ptr1 -> fsb_is_chained = "0"b;
		     return_check = "1"b;
		     return;
		end;
		else
		     ptr2 = ptr1;
		ptr1 = ptr1 -> next_fsb_ptr;
	     end;
	end;

	return;

bad_fsb:
						/* at this time : ptr1 -> damaged fsb,
						   ptr2 -> previous fsb (if any, else null) */
	revert any_other;

/*
   call com_err_ (0, "pascal_io_", "Warning: Pascal file status blocks thread was damaged.") ;
*/

	if ptr2 = null then do;
	     pascal_operators_statics_$first_file_ptr = null;

/*
   call com_err_ (0, "pascal_io_", "Status of currently active Pascal files is uncertain.") ;
*/

	     pascal_operators_statics_$first_file_ptr, last_file_ptr = null;
	end;
	else do;
	     ptr3 = ptr2 -> owner_stack;

/*
   if ptr3 ^= null then do ;
   call hcs_$fs_get_path_name (ptr3 -> owner_symbol, dir_name, nbchars, entryname, code) ;
   if code ^= 0 then do ;
   call com_err_ (0, "pascal_io_",
   "Status of all currently active Pascal files before file ^a (stack_frame at ^p of program ^a) is uncertain.",
   file_name, ptr2 -> owner, entryname) ;
   end ;
   end ;
   else call com_err_ (0, "pascal_io_", "Status of some Pascal files is uncertain.") ;
*/

	     last_file_ptr = ptr2;
	     ptr2 -> next_fsb_ptr = null;
	end;

	return;

     end check_fsb_thread;
%page;
establish_cleanup: proc (sfp);

dcl sfp ptr;					/* ptr to a pascal stack_frame */

	sfp -> close_on_cleanup = "1"b;
	if sfp -> condition = "0"b then do;
	     sfp -> condition = "1"b;
	     sfp -> on_unit_relp1 = close_on_unit_relp;
	end;
	else do;
	     if sfp -> on_unit_relp1 = close_on_unit_relp then return;
	     on_unit_relp = on_unit_relp1;
	     do while (on_unit_relp ^= "0"b);
		ptr1 = addrel (sfp, on_unit_relp);
		if ptr1 -> on_unit.next = close_on_unit_relp then return;
		on_unit_relp = ptr1 -> on_unit.next;
	     end;
	     ptr1 -> on_unit.next = close_on_unit_relp;
	end;

	sfp -> close_file_cleanup_on_unit.name = addr (cleanup_chain);
	sfp -> close_file_cleanup_on_unit.body = addr (pascal_operators_$cleanup_sequence);
	sfp -> close_file_cleanup_on_unit.size = 7;
	sfp -> close_file_cleanup_on_unit.next,
	     sfp -> close_file_cleanup_on_unit.flags = "0"b;

	return;

     end establish_cleanup;

establish_cleanup_for_caller: entry;

dcl stackframeptr builtin;

	call establish_cleanup (stackframeptr -> stack_frame.prev_sp);

	return;

%page;
check_on_open: proc;
	fsb_ptr = block_ptr;

	sp = stack_frame_ptr;
	value_ptr = addr (two_words_value);
	switch_name = get_switch_name (fsb_ptr);

	if standard_file = "0"b then do;
						/* check fsb validity */
	     if owner_stack ^= null then
		if (baseno (owner_stack) ^= baseno (sp)) | (rel (owner_stack) > rel (sp)) then do;
		     code = pascal_error_table_$bad_fsb;
		     return;
		end;
						/* close if necessary */
	     call fclose_;
						/* establish cleanup on unit to close file */
	     if owner_stack ^= null then
		if owner_stack -> close_on_cleanup = "0"b then call establish_cleanup (owner_stack);
	end;
	else do;
	     standard_file_used = "1"b;
	     call fclose_;				/* close if necessary */
	     if sp -> main then do;
		if file_name = "input" then sp -> close_input = "1"b;
		else if file_name = "output" then sp -> close_output = "1"b;
		else if file_name = "error" then sp -> close_error = "1"b;
		else if file_name = "entree" then sp -> close_entree = "1"b;
		else if file_name = "sortie" then sp -> close_sortie = "1"b;
		else if file_name = "erreur" then sp -> close_erreur = "1"b;
		else do;
		     code = pascal_error_table_$bad_fsb;
		     return;
		end;
		if sp -> close_on_cleanup = "0"b then call establish_cleanup (sp);
	     end;
	end;

/* control now attach description and multics switch */

	call iox_$find_iocb (switch_name, iocb_ptr, code);
	if code ^= 0 then return;
	atd_ptr = iocb_ptr -> attach_descrip_ptr;
	if local_file | static_file then do;
	     if atd_ptr = null then do;
		process_dir_name = get_pdir_ ();
		my_atd = "vfile_ " || rtrim (process_dir_name) || ">" || rtrim (switch_name);
		call iox_$attach_ptr (iocb_ptr, rtrim (my_atd), null, code);
		if code ^= 0 then return;
	     end;
	end;
	else do;					/* PERMANENT FILE */
	     if file_is_text = 0 then do;		/* non text */
		if atd_ptr = null then do;
		     code = pascal_error_table_$switch_not_attached;
		     return;
		end;
	     end;
	     else do;				/* text */
		if atd_ptr = null then do;
		     if switch_name = "pascal_input_" then do;
			call iox_$attach_ptr (iocb_ptr, "syn_ user_input", null, code);
			if code ^= 0 then return;
		     end;
		     else if switch_name = "pascal_output_" then do;
			call iox_$attach_ptr (iocb_ptr, "syn_ user_output", null, code);
			if code ^= 0 then return;
		     end;
		     else if switch_name = "pascal_error_" then do;
			call iox_$attach_ptr (iocb_ptr, "syn_ error_output", null, code);
			if code ^= 0 then return;
		     end;
		     else do;
			code = pascal_error_table_$switch_not_attached;
			return;
		     end;
		end;
	     end;
	end;

	atd_ptr = iocb_ptr -> attach_descrip_ptr;
	if atd_ptr -> attach_description.length > 7 then
	     vfile_switch = (substr (atd_ptr -> attach_description.string, 1, 7) = "vfile_ ");

	code = 0;
	get_next_char, interactive_file = "0"b;
	system_ptr = iocb_ptr;
	return;

     end check_on_open;
%page;
on_process_io: proc returns (bit (1));

/* called before close or open to avoid error.. */

dcl iocb_ptr ptr;

	iocb_ptr = system_ptr;
test_syn:
	if (iocb_ptr -> iocb.name = "user_input")
	     | (iocb_ptr -> iocb.name = "user_output")
	     | (iocb_ptr -> iocb.name = "error_output")
	     | (iocb_ptr -> iocb.name = "user_i/o") then return ("1"b);
	if iocb_ptr -> syn_father = null then return ("0"b);
	iocb_ptr = iocb_ptr -> syn_father;
	go to test_syn;

     end on_process_io;
%page;
close_file: proc;

	switch_name = get_switch_name (fsb_ptr);

	if local_file then do;
	     call iox_$find_iocb (switch_name, iocb_ptr, code);
	     if code = 0 then do;
		if iocb_ptr -> iocb.attach_descrip_ptr ^= null then do;
		     if iocb_ptr -> open_descrip_ptr ^= null then do;
			call iox_$close (iocb_ptr, code);
			if code ^= 0 then return;
			process_dir_name = get_pdir_ ();
			call delete_$path (process_dir_name, switch_name, "100100"b, "", code);
			if code ^= 0 then code = 0;
		     end;
		     call iox_$detach_iocb (iocb_ptr, code);
		     if code ^= 0 then return;
		end;
		call iox_$destroy_iocb (iocb_ptr, code);
		if code ^= 0 then return;
	     end;
	end;
	else do;
	     call iox_$find_iocb (switch_name, iocb_ptr, code);
	     if (code = 0) & (system_ptr = iocb_ptr) then do;
		if (system_ptr -> iocb.attach_descrip_ptr ^= null) then do;
		     if (system_ptr -> open_descrip_ptr ^= null) then do;
			if file_is_text ^= 0 then do;
			     if ^cleanup_switch &
				(file_status = pascal_codes_$output_mode) &
				(buff_index ^= 0) then do;
						/* Changed for 8.02. Previously was "writeln" */
				call iox_$put_chars
				     (system_ptr, addr (buffer), buff_index, code);
			     end;
			     if ^on_process_io () then do;
				call iox_$close (system_ptr, code);
			     end;
			     if break_all_mode then do;
				break_all_mode = "0"b;
				if reset_break_all then
				     call iox_$modes (system_ptr, "^breakall", "", code);
				code = 0;		/* don't care */
			     end;
			end;
			else do;
			     call iox_$close (system_ptr, code);
			     if code ^= 0 then return;
			end;
		     end;
		     if attached_by_fconnect then do;
			call iox_$detach_iocb (iocb_ptr, code);
			if code ^= 0 then return;
		     end;
		end;
	     end;
	end;
	file_is_open = "0"b;
	eof, eoln = 2;				/* undefined !! */

	return;

     end close_file;
%page;
get_switch_name: proc (fsbp) returns (char (32));

dcl fsbp ptr;

	if fsbp -> permanent_file then do;
	     if fsbp -> standard_file then do;
		if (fsbp -> file_name = "input") | (fsbp -> file_name = "entree") then return ("pascal_input_");
		else if (fsbp -> file_name = "output") | (fsbp -> file_name = "sortie") then return ("pascal_output_");
		else if (fsbp -> file_name = "error") | (fsbp -> file_name = "erreur") then return ("pascal_error_");
	     end;
	     return (fsbp -> file_name);
	end;
	else
	     return ("pascal_file_" || unique_chars_ ((fsbp -> uid)));

     end get_switch_name;







fclose_: proc;

	if file_is_open then do;
	     if system_ptr ^= null then do;
		if file_is_text ^= 0 then do;
		     if (file_status = pascal_codes_$output_mode) & (buff_index ^= 0) then do;
			call writeln;
			if code ^= 0 then go to error_while_fclose;
		     end;
		     if ^on_process_io () then do;
			call iox_$close (system_ptr, code);
			if code ^= 0 then go to error_while_fclose;
		     end;
		end;
		else do;
		     call iox_$close (system_ptr, code);
		     if code ^= 0 then go to error_while_fclose;
		end;
	     end;
	     file_is_open = "0"b;
	end;
	eof, eoln = 2;				/* undefined !! */

	return;
     end fclose_;
%page;
fatal_error:					/* fatal error is signalled */

	pascal_operators_statics_$error_info.status_code = code;

	call signal_ ("pascal_error", null, addr (pascal_operators_statics_$error_info), null);

fatal_loop:
	call signal_ ("illegal_return", null, addr (pascal_operators_statics_$error_info), null);
	go to fatal_loop;
%page;
/*

   STRING IO OPERATORS


*/

dcl 1 sio_parameters based (sio_parms_addr),
     2 io_string_addr ptr,
     2 io_string_length fixed bin (35),
     2 sio_index fixed bin (35),
     2 sio_value bit (72),
     2 sio_total_length fixed bin (35),
     2 sio_scale_or_size fixed bin (35),
     2 sio_sub_index fixed bin (35),
     2 sio_unused fixed bin (35),
     2 sio_stack_ptr ptr;


dcl sio_last_read bit (1);
dcl sio_parms_addr ptr;

dcl 1 current,
     2 pad bit (27) unal,
     2 char char (1) unal;

dcl pascal_operators_$SREAD_integer_return ext entry;
dcl pascal_operators_$SREAD_real_return ext entry;
dcl pascal_operators_$SWRITE_return ext entry;

dcl io_string char (io_string_length) based (io_string_addr);


SREAD_real: entry (io_parameters) options (support);


next_in_real: proc;

	if sio_index > io_string_length then
	     if sio_last_read then goto error_while_SREAD_real;
	     else do;
		sio_last_read = "1"b;
		current.char = " ";
	     end;
	else do;
	     current.char = substr (io_string, sio_index, 1);
	     sio_index = sio_index + 1;
	end;

     end next_in_real;

	sio_parms_addr = addr (io_parameters);
	if (sio_index <= 0)
	     | (sio_index > io_string_length) then go to error_while_SREAD_real;

	sp = sio_stack_ptr;
	sio_last_read = "0"b;
	current.pad = "0"b;
	call next_in_real;
	value_ptr = addr (sio_value);

	negative = 0;
	exponent = 0;
	chiffre_ptr = addr (current);
	digit_string = "+0000000000000000000e+00";
	nbr_of_chars = 1;
	do while (current.char = " ");		/* spaces */
	     call next_in_real;
	end;
	if current.char = "-" then do;		/* "-" */
	     negative = 1;
	     substr (digit_string, 1, 1) = "-";
	     call next_in_real;
	end;
	else do;
	     if current.char = "+" then /* "+" */
		call next_in_real;
	end;
	if chiffre < ascii_0_code | chiffre > ascii_9_code then do;
	     go to error_while_SREAD_real;
	end;
	do while (chiffre = ascii_0_code);
	     call next_in_real;
	end;
	do while (chiffre >= ascii_0_code & chiffre <= ascii_9_code);
	     if nbr_of_chars ^= 20 then do;
		nbr_of_chars = nbr_of_chars + 1;
		substr (digit_string, nbr_of_chars, 1) = current.char;
	     end;
	     exponent = exponent + 1;
	     call next_in_real;
	end;
	if current.char = "." then do;		/* "." */
	     call next_in_real;
	     if chiffre < ascii_0_code | chiffre > ascii_9_code then go to error_while_SREAD_real;
	     if nbr_of_chars = 1 then do;
		do while (chiffre = ascii_0_code);
		     call next_in_real;
		     exponent = exponent - 1;
		end;
	     end;
	     do while (chiffre >= ascii_0_code & chiffre <= ascii_9_code);
		if nbr_of_chars ^= 20 then do;
		     nbr_of_chars = nbr_of_chars + 1;
		     substr (digit_string, nbr_of_chars, 1) = current.char;
		end;
		call next_in_real;
	     end;
	end;
	if (current.char = "e") | (current.char = "E") then do;
	     exp = exponent;
	     exponent = 0;
	     call next_in_real;
	     if current.char = "-" then do;		/* "-" */
		exp_signe = -1;
		call next_in_real;
	     end;
	     else do;
		exp_signe = 1;
		if current.char = "+" then /* "+" */
		     call next_in_real;
	     end;
	     if chiffre < ascii_0_code | chiffre > ascii_9_code then go to error_while_SREAD_real;
	     do while (chiffre >= ascii_0_code & chiffre <= ascii_9_code);
		if exponent <= 10000 then
		     exponent = exponent * 10 + (chiffre - ascii_0_code);
		call next_in_real;
	     end;
	     exponent = exp + (exponent * exp_signe);
	end;
	if nbr_of_chars = 1 then real = 0;
	else do;
	     exponent = exponent - 19;
	     exp = abs (exponent);
	     if exponent < 0 then substr (digit_string, 22, 1) = "-";
	     substr (digit_string, 24, 1) = DIGITS (mod (exp, 10));
	     substr (digit_string, 23, 1) = DIGITS (exp / 10);
	     if negative = 1 then do;
		if exponent < 0 then do;
		     if (substr (digit_string, 2, 19) < "1469367938527859387" &
			exponent = -57) | (exponent < -57) then do;
			real = pascal_constants_$max_real_neg;
			if sp -> io_warnings then call com_err_ (0, "pascal_io_$SREAD_real",
				"Warning: Too large negative value was given, max_real_neg value (-1.469E-39) assumed.");
		     end;
		     else real = convert (real, digit_string);
		end;
		else do;
		     if (substr (digit_string, 2, 19) > "1701411834604692318" &
			exponent = 20) | (exponent > 20) then do;
			real = pascal_constants_$min_real;
			if sp -> io_warnings then call com_err_ (0, "pascal_io_$SREAD_real",
				"Warning: Too large negative value was given, min_real value (-1.701E-38) assumed.");
		     end;
		     else real = convert (real, digit_string);
		end;
	     end;
	     else do;
		if exponent < 0 then do;
		     if (substr (digit_string, 2, 19) < "1469367938527859386" &
			exponent = -57) | (exponent < -57) then do;
			real = pascal_constants_$min_real_pos;
			if sp -> io_warnings then call com_err_ (0, "pascal_io_$SREAD_real",
				"Warning: Too small positive value was given, min_real_pos value (1.469E-39) assumed.");
		     end;
		     else real = convert (real, digit_string);
		end;
		else do;
		     if (substr (digit_string, 2, 19) > "1701411834604692317" &
			exponent = 20) | (exponent > 20) then do;
			real = pascal_constants_$max_real;
			if sp -> io_warnings then call com_err_ (0, "pascal_io_$SREAD_real",
				"Warning: Too large positive value was given, max_real value (1.7014E38) assumed.");
		     end;
		     else real = convert (real, digit_string);
		end;
	     end;
	end;

	call pascal_operators_$SREAD_real_return;

error_while_SREAD_real:

	sio_index = -1;
	call pascal_operators_$SREAD_real_return;


SREAD_integer: entry (io_parameters) options (support);


next_in_integer: proc;

	if sio_index > io_string_length then
	     if sio_last_read then goto error_while_SREAD_integer;
	     else do;
		sio_last_read = "1"b;
		current.char = " ";
	     end;
	else do;
	     current.char = substr (io_string, sio_index, 1);
	     sio_index = sio_index + 1;
	end;

     end next_in_integer;

	sio_parms_addr = addr (io_parameters);
	if (sio_index <= 0)
	     | (sio_index > io_string_length) then go to error_while_SREAD_integer;

	sp = sio_stack_ptr;
	sio_last_read = "0"b;
	current.pad = "0"b;
	call next_in_integer;
	value_ptr = addr (sio_value);

	chiffre_ptr = addr (current);
	big_integer = 0;
	negative = 0;
	do while (current.char = " ");		/* spaces */
	     call next_in_integer;
	end;
	if current.char = "-" then do;		/* "-" */
	     negative = 1;
	     call next_in_integer;
	end;
	else do;
	     if current.char = "+" then do;		/* "+" */
		call next_in_integer;
	     end;
	end;
	if chiffre < ascii_0_code | chiffre > ascii_9_code then do;
	     go to error_while_SREAD_integer;
	end;
	else do;
sread_1:
	     big_integer = big_integer * 10 + chiffre - ascii_0_code;
	     if big_integer > pascal_constants_$max_integer_72 then do;
		if negative = 1 then integer = pascal_constants_$min_integer;
		else integer = pascal_constants_$max_integer;
sread_2:
		call next_in_integer;
		if chiffre >= ascii_0_code & chiffre <= ascii_9_code then go to sread_2;
		if sp -> io_warnings then call com_err_ (0, "pascal_io_$SREAD",
			"Warning: Too large ^[negative number was given, min_integer value (-34359738368)^;^positive number was given, max_integer value (34359738367)^] assumed.",
			(negative = 1), (negative = 0));
	     end;
	     else do;
		call next_in_integer;
		if chiffre >= ascii_0_code & chiffre <= ascii_9_code then go to sread_1;
		integer = big_integer;
		if negative = 1 then integer = -integer;
	     end;
	end;

	call pascal_operators_$SREAD_integer_return;

error_while_SREAD_integer:

	sio_index = -1;
	call pascal_operators_$SREAD_integer_return;


SWRITE_integer: entry (io_parameters) options (support);

	sio_parms_addr = addr (io_parameters);
	if (sio_index <= 0)
	     | (sio_total_length < 1)
	     | (sio_index + sio_total_length - 1 > io_string_length)
	then go to error_while_SWRITE;

	int_value = sio_value;
	value_ptr = addr (int_value);
	sp = sio_stack_ptr;

	begin;
dcl temp_ptr ptr;
dcl string char (262144) based (temp_ptr);
dcl codes (262144) fixed bin (8) unal based (temp_ptr);
dcl chars (262144) char (1) unal based (temp_ptr);

dcl total_width fixed bin (21);
dcl bad_length bit (1);
dcl int_size fixed bin (21);
dcl (i, j) fixed bin (21);
dcl big_integer fixed bin (71);
dcl next_i fixed bin (71);
dcl 1 output_buffer,
     2 default char (28) unal,
     2 other char (sio_total_length) unal;

	     temp_ptr = addr (output_buffer);

	     bad_length = "0"b;
	     total_width = sio_total_length;

	     negative = 0;
	     big_integer = integer;
	     if integer < 0 then do;
		big_integer = -big_integer;
		negative = 1;
	     end;
	     do int_size = 11 by -1 to 1;
		if tenpower_int (int_size) <= big_integer then go to swrite_1;
	     end;
swrite_1:

	     int_size = int_size + negative;
	     if total_width < int_size then do;
		total_width = int_size;
		bad_length = "1"b;
	     end;
	     j = total_width - int_size;
	     substr (string, 1, j) = " ";
	     j = j + 1;
	     if negative = 1 then do;
		chars (j) = "-";
		j = j + 1;
	     end;
	     do i = total_width by -1 to j;
		next_i = big_integer / 10;
		codes (i) = big_integer - 10 * next_i + ascii_0_code;
		big_integer = next_i;
	     end;

	     if bad_length then do;
		if sp -> io_warnings then call com_err_ (0, "pascal_io_$SWRITE",
			"Warning: Too small length (^d) was given for the string ""^a""",
			sio_total_length, substr (string, 1, total_width));
		if sio_index + total_width - 1 > io_string_length then
		     go to error_while_SWRITE;
		else sio_total_length = total_width;
	     end;
	     substr (io_string, sio_index, sio_total_length) = substr (string, 1, total_width);
	     sio_index = sio_index + sio_total_length;
	end;					/* of the begin block */

	call pascal_operators_$SWRITE_return;

error_while_SWRITE:

	sio_index = -1;
	call pascal_operators_$SWRITE_return;



SWRITE_real_e: entry (io_parameters) options (support);

	sio_parms_addr = addr (io_parameters);
	if (sio_index <= 0)
	     | (sio_total_length < 1)
	     | (sio_index + sio_total_length - 1 > io_string_length)
	then go to error_while_SWRITE;

	int_value = sio_value;
	value_ptr = addr (int_value);
	sp = sio_stack_ptr;

	begin;
dcl temp_ptr ptr;
dcl string char (262144) based (temp_ptr);
dcl codes (262144) fixed bin (8) unal based (temp_ptr);
dcl chars (262144) char (1) unal based (temp_ptr);

dcl total_width fixed bin (21);
dcl bad_length bit (1);
dcl nbr_of_prec_digits fixed bin (21);
dcl (i, j, k, l) fixed bin (21);
dcl big_integer fixed bin (71);
dcl next_i fixed bin (71);
dcl 1 output_buffer,
     2 default char (28) unal,
     2 other char (sio_total_length) unal;

	     temp_ptr = addr (output_buffer);

	     bad_length = "0"b;
	     total_width = sio_total_length;

	     negative = 0;
	     if total_width < 8 then do;
		total_width = 8;
		bad_length = "1"b;
	     end;
	     if real = zero_real then do;
		chars (1) = " ";
		do i = 2 to total_width;
		     chars (i) = "0";
		end;
		chars (3) = ".";
		substr (string, total_width - 3, 2) = "E+";
	     end;
	     else do;
		if real < 0 then do;
		     if real = pascal_constants_$min_real then real = pascal_constants_$max_real;
		     else real = -real;
		     negative = 1;
		end;
		if total_width <= 25 then nbr_of_prec_digits = total_width - 7;
		else nbr_of_prec_digits = 18;
		do exponent = 38 by -1 to -38;
		     if tenpower_float (exponent) <= real then do;
			real = real * tenpower_float (-exponent);
			go to swrite_2;
		     end;
		end;
		real = real * tenpower_float (38);
		real = real * 10;
		exponent = -39;
swrite_2:
		big_integer = real * tenpower_float (nbr_of_prec_digits + 1);
		if total_width <= 24 then do;
		     big_integer = big_integer + 5;
		     if big_integer > tenpower_big (nbr_of_prec_digits + 2) then do;
			big_integer = big_integer / 10;
			exponent = exponent + 1;
		     end;
		end;
		big_integer = big_integer / 10;
		if negative = 1 then chars (1) = "-";
		else chars (1) = " ";
		chars (3) = ".";
		j = nbr_of_prec_digits + 4;
		k = total_width - 4;
		do i = j to k;
		     chars (i) = "0";
		end;
		do i = j - 1 by -1 to 4;
		     next_i = big_integer / 10;
		     codes (i) = big_integer - 10 * next_i + ascii_0_code;
		     big_integer = next_i;
		end;
		codes (2) = big_integer + ascii_0_code;
		chars (total_width - 3) = "E";
		if exponent < 0 then do;
		     chars (total_width - 2) = "-";
		     exponent = -exponent;
		end;
		else chars (total_width - 2) = "+";
		j = exponent / 10;
		codes (total_width - 1) = j + ascii_0_code;
		codes (total_width) = exponent - 10 * j + ascii_0_code;
	     end;

	     if bad_length then do;
		if sp -> io_warnings then call com_err_ (0, "pascal_io_$SWRITE",
			"Warning: Too small length (^d) was given for the string ""^a""",
			sio_total_length, substr (string, 1, total_width));
		if sio_index + total_width - 1 > io_string_length then
		     go to error_while_SWRITE;
		else sio_total_length = total_width;
	     end;
	     substr (io_string, sio_index, sio_total_length) = substr (string, 1, total_width);
	     sio_index = sio_index + sio_total_length;
	end;					/* of the begin block */

	call pascal_operators_$SWRITE_return;



SWRITE_real_d: entry (io_parameters) options (support);

	sio_parms_addr = addr (io_parameters);
	if (sio_index <= 0)
	     | (sio_scale_or_size < 1)
	     | (sio_total_length < 1)
	     | (sio_index + sio_total_length - 1 > io_string_length)
	then go to error_while_SWRITE;

	int_value = sio_value;
	value_ptr = addr (int_value);
	sp = sio_stack_ptr;
	mode = sio_scale_or_size;

	begin;
dcl temp_ptr ptr;
dcl string char (262144) based (temp_ptr);
dcl codes (262144) fixed bin (8) unal based (temp_ptr);
dcl chars (262144) char (1) unal based (temp_ptr);

dcl total_width fixed bin (21);
dcl bad_length bit (1);
dcl real_size fixed bin (21);
dcl (i, j, k, l, z) fixed bin (21);
dcl big_integer fixed bin (71);
dcl next_i fixed bin (71);
dcl 1 output_buffer,
     2 default char (28) unal,
     2 mod_width char (mode) unal,
     2 other char (sio_total_length) unal;

	     temp_ptr = addr (output_buffer);

	     bad_length = "0"b;
	     total_width = sio_total_length;

	     negative = 0;
	     if real < 0 then do;
		if real = pascal_constants_$min_real then real = pascal_constants_$max_real;
		else real = -real;
		negative = 1;
	     end;
	     real = real + 0.5 / tenpower_float (mode);
	     if mode + 2 + negative > total_width then do;
		total_width = mode + 2 + negative;
		bad_length = "1"b;
	     end;
	     do real_size = 38 by -1 to -38;
		if tenpower_float (real_size) <= real then go to swrite_3;
	     end;
swrite_3:
	     real_size = real_size + 1;
	     if real ^= 0 & -real_size < mode then do;
		if real_size + negative + mode + 1 > total_width then do;
		     total_width = real_size + negative + mode + 1;
		     bad_length = "1"b;
		end;
		z = real_size - 19;
		if z >= 0 then do;
		     j = total_width - (real_size + mode + 1);
		     substr (string, 1, j) = " ";
		     if negative = 1 then chars (j) = "-";
		     big_integer = real * tenpower_float (-z);
		     k = j + 19;
		     j = j + 1;
		     do i = k by -1 to j;
			next_i = big_integer / 10;
			codes (i) = big_integer - 10 * next_i + ascii_0_code;
			big_integer = next_i;
		     end;
		     do i = k + 1 to total_width;
			chars (i) = "0";
		     end;
		     chars (total_width - mode) = ".";
		end;
		else do;
		     if -z > mode then do;
			k = total_width;
			big_integer = real * tenpower_float (mode);
		     end;
		     else do;
			k = total_width - (mode + z) + 1;
			do i = k to total_width;
			     chars (i) = "0";
			end;
			k = k - 1;
			if -z > 38 then do;
			     real = real * tenpower_float (38);
			     big_integer = real * tenpower_float (-z - 38);
			end;
			else big_integer = real * tenpower_float (-z);
		     end;
		     if real_size <= 0 then do;
			j = total_width - (mode + 2);
			substr (string, 1, j) = " ";
			if negative = 1 then chars (j) = "-";
			substr (string, j + 1, 2) = "0.";
			j = j + 3;
			do i = k by -1 to j;
			     next_i = big_integer / 10;
			     codes (i) = big_integer - 10 * next_i + ascii_0_code;
			     big_integer = next_i;
			end;
			if big_integer ^= 0 then substr (string, j - 2, 1) = "1";
		     end;
		     else do;
			j = total_width - (mode + 1 + real_size);
			substr (string, 1, j) = " ";
			if negative = 1 then chars (j) = "-";
			l = total_width - mode;
			chars (l) = ".";
			l = l + 1;
			do i = k by -1 to l;
			     next_i = big_integer / 10;
			     codes (i) = big_integer - 10 * next_i + ascii_0_code;
			     big_integer = next_i;
			end;
			j = j + 1;
			do i = (l - 2) by -1 to j;
			     next_i = big_integer / 10;
			     codes (i) = big_integer - 10 * next_i + ascii_0_code;
			     big_integer = next_i;
			end;
			if big_integer ^= 0 then do;
			     if j = 1 then do;
				bad_length = "1"b;
				total_width = total_width + 1;
				substr (string, l - 1, 2) = "0.";
				substr (string, 1, 1) = "1";
				substr (string, k + 1, 1) = "0";
			     end;
			     else substr (string, j - 1, 1) = "1";
			end;
		     end;
		end;
	     end;
	     else do;
		j = total_width - mode;
		substr (string, j - 1, 2) = "0.";
		substr (string, 1, j - 2) = " ";
		do i = j + 1 to total_width;
		     chars (i) = "0";
		end;
		if negative = 1 then chars (j - 2) = "-";
	     end;

	     if bad_length then do;
		if sp -> io_warnings then call com_err_ (0, "pascal_io_$SWRITE",
			"Warning: Too small length (^d) was given for the string ""^a""",
			sio_total_length, substr (string, 1, total_width));
		if sio_index + total_width - 1 > io_string_length then
		     go to error_while_SWRITE;
		else sio_total_length = total_width;
	     end;
	     substr (io_string, sio_index, sio_total_length) = substr (string, 1, total_width);
	     sio_index = sio_index + sio_total_length;
	end;					/* of the begin block */

	call pascal_operators_$SWRITE_return;



SWRITE_enumerated: entry (io_parameters) options (support);

	sio_parms_addr = addr (io_parameters);

	if (sio_index <= 0)
	     | (sio_total_length < 1)
	     | (sio_index + sio_total_length - 1 > io_string_length)
	then go to error_while_SWRITE;

	begin;
dcl k fixed bin;
dcl name_ptr ptr;
dcl 1 pascal_name like acc based (name_ptr);

	     int_value = sio_value;
	     value_ptr = addr (int_value);
	     sp = sio_stack_ptr;

	     name_ptr = get_enum_str_ptr (sio_scale_or_size, integer);
	     if name_ptr = null then do;
		call ioa_$rsnnl ("
pascal_io_$SWRITE_enumerated : Unable to get symbolic name of enumerated value (int value is : ^d).",
		     pascal_operators_statics_$error_info.string, string_length, integer);
		go to fatal_error;
	     end;
	     k = sio_total_length - pascal_name.length;

	     if k < 0 then do;
		if sp -> io_warnings then call com_err_ (0, "pascal_io_$SWRITE", "Warning :
too small length (^d) was given for the string ""^a""", sio_total_length, pascal_name.string);
		if sio_index + pascal_name.length - 1 > io_string_length then
		     go to error_while_SWRITE;
		else do;
		     k = 0;
		     sio_total_length = pascal_name.length;
		end;
	     end;
	     if k > 0 then
		substr (io_string, sio_index, k) = " ";
	     substr (io_string, sio_index + k, pascal_name.length) = pascal_name.string;
	     sio_index = sio_index + sio_total_length;
	end;					/* of the begin block */

	call pascal_operators_$SWRITE_return;





%page;
/*

   COMMANDS

*/

pascal_file_status: entry;

/*
   entry for the "pascal_file_status" command.

   Returns info about thecurrently active Pascal files .

*/

	any = "0"b;

	fsb_ptr = addr (pascal_operators_statics_$INPUT);
	call iox_$look_iocb ("pascal_input_", iocb_ptr, code);
	if standard_file_used then do;
	     call ioa_ ("^/     Standard file ""input""^/^-- Multics switch:");
	     call display_file;
	end;

	fsb_ptr = addr (pascal_operators_statics_$OUTPUT);
	call iox_$look_iocb ("pascal_output_", iocb_ptr, code);
	if standard_file_used then do;
	     call ioa_ ("^/     Standard file ""output""^/^-- Multics switch:");
	     call display_file;
	end;

	fsb_ptr = addr (pascal_operators_statics_$ERROR);
	call iox_$look_iocb ("pascal_error_", iocb_ptr, code);
	if standard_file_used then do;
	     call ioa_ ("^/     Standard file ""error""^/^-- Multics switch:");
	     call display_file;
	end;

	fsb_ptr = addr (pascal_operators_statics_$ENTREE);
	call iox_$look_iocb ("pascal_input_", iocb_ptr, code);
	if standard_file_used then do;
	     call ioa_ ("^/     Standard file ""entree""^/^-- Multics switch:");
	     call display_file;
	end;

	fsb_ptr = addr (pascal_operators_statics_$SORTIE);
	call iox_$look_iocb ("pascal_output_", iocb_ptr, code);
	if standard_file_used then do;
	     call ioa_ ("^/     Standard file ""sortie""^/^-- Multics switch:");
	     call display_file;
	end;

	fsb_ptr = addr (pascal_operators_statics_$ERREUR);
	call iox_$look_iocb ("pascal_error_", iocb_ptr, code);
	if standard_file_used then do;
	     call ioa_ ("^/     Standard file ""erreur""^/^-- Multics switch:");
	     call display_file;
	end;

	call check_fsb_thread;

	fsb_ptr = pascal_operators_statics_$first_file_ptr;
	do while (fsb_ptr ^= null);
	     if (owner_link = null) | (owner_symbol = null) then go to skip_fsb;
	     ptr1 = owner_link; ptr2 = owner_symbol;
	     ptr2 = ptr1 -> header.symbol_ptr;
	     call hcs_$fs_get_path_name (ptr2, dir_name, nbchars, entryname, code);
	     if code ^= 0 then go to skip_fsb;
	     call ioa_ ("
   ^[Local^;Global^]^[ array of^] file ""^a"" (program ^a) ^[ (permanent)^]^[ (static)^] ^/^-- Multics switch:",
		local_file = "1"b, array_of_file, file_name, entryname, permanent_file, static_file);
	     if array_of_file then do;
		head_ptr = fsb_ptr;
edit_element:
		call ioa_ ("      File ""^a"":", file_name);
		switch_name = get_switch_name (fsb_ptr);
		call iox_$look_iocb (switch_name, iocb_ptr, code);
		call display_file;
		if next_element ^= "0"b then do;
		     fsb_ptr = ptr (fsb_ptr, next_element);
		     go to edit_element;
		end;
		fsb_ptr = head_ptr;
	     end;
	     else do;
		switch_name = get_switch_name (fsb_ptr);
		call iox_$look_iocb (switch_name, iocb_ptr, code);
		call display_file;
	     end;
skip_fsb:
	     ptr2 = fsb_ptr;
	     fsb_ptr = ptr2 -> next_fsb_ptr;
	end;
pascal_file_status_return:
	if ^any then call ioa_ ("No Pascal file.");
	else call ioa_ ("");
	return;
%page;
display_file: proc;

	if code = error_table_$no_iocb then call ioa_ ("^-   (no iocb)");
	else do;
	     call ioa_ ("^-   name: ""^a""", iocb_ptr -> iocb.name);
	     ptr1 = iocb_ptr -> iocb.attach_descrip_ptr;
	     if ptr1 = null then do;
		call ioa_ ("^-   (not attached)^/^-   (not open)");
	     end;
	     else do;
		call ioa_ ("^-   attached: ^a", ptr1 -> attach_description.string);
		ptr2 = iocb_ptr -> open_descrip_ptr;
		if ptr2 = null then call ioa_ ("^-   (not open)");
		else call ioa_ ("^-   open: ^a", ptr2 -> attach_description.string);
	     end;
	end;
	call ioa_ ("^-- Pascal file status :^/^-   ^[text file^s^;non text^-record of ^d bytes^]^-^[(not open)^;^[^[input^]^[output^]^s^;^[sequential input^]^[sequential output^]^[direct update^]^]^[ interactive^]^[^-eoln^]^[ eof^]^]",
	     file_is_text = 1, rec_length, file_is_open = "0"b,
	     file_is_text = 1, file_status = 1, file_status = 2, file_status = 3,
	     interactive_file = "1"b, eoln = 1, eof = 1);
	any = "1"b;

	return;
     end display_file;
%page;
psp:
pascal_set_prompt: entry;

/*
   Entry for the pascal_set_prompt command
*/

	call cu_$arg_count (arg_count);
	if arg_count > 1 then do;
print_pspc_usage:
	     call com_err_$suppress_name (0, "pascal_set_prompt",
		"Usage:  pascal_set_prompt {character_string}^/or:     pascal_set_prompt -no_prompt");
	     return;
	end;

	if arg_count = 0 then do;
	     prompt_wanted = "1"b;
	     prompt_string = "?";
	end;
	else do;
	     call cu_$arg_ptr (1, arg_ptr, arg_len, code);
	     if code ^= 0 then do;
		call com_err_ (0, "pascal_set_prompt");
		return;
	     end;
	     if (arg = "-no_prompt") | (arg = "-npmt") then
		prompt_wanted = "0"b;
	     else do;
		prompt_wanted = "1"b;
		prompt_string = arg;
	     end;
	end;

	return;
%page;
get_enum_str_ptr: proc (symb_offset, int_value) returns (pointer);

dcl symb_offset fixed bin (35);			/* (input) offset of symbol table for enumrated type
						   relative to base of symbol tree */
dcl int_value fixed bin (35);				/* (input) internal value of enumerated type variable */

dcl (hp, p) ptr;
dcl i fixed bin;

	call stu_$get_block (sp, hp, p);
	if hp ^= null then do;
	     hp = addrel (hp, hp -> std_symbol_header.area_pointer);
	     p = addrel (hp, symb_offset);
	     p = runtime_symbol_info_$son (p);
	     i = 0;
	     do while ((i ^= int_value) & (p ^= null));
		p = runtime_symbol_info_$successor (p);
		i = i + 1;
	     end;
	     if p ^= null then p = runtime_symbol_info_$name (p);
	end;

	return (p);
     end get_enum_str_ptr;

%page;
/*


   FOLLOWING OPERATOR IS USED BY OBJECTS
   GENERATED BEFORE Pascal 7.00
   (To be removed in the future)

   ***************************************

*/


init_fsb: entry (io_parameters) options (support);

/* uses :
   - block_ptr : ptr to the fsb.
   - two_words_value : ptr to the name of the Pascal file (8 characters).
   - type_ = 1  ->text file, size_ = buffer_length
   - type_ = 0 -> non text, size_ = record_length
   - stack_frame_ptr : ptr to the stack_frame of the calling procedure (in which the file is declared)

   Initialisation of the fsb. (Done once, at the beginning of the procedure where it is declared)
*/


	sp = stack_frame_ptr;
	fsb_ptr = block_ptr;
	value_ptr = addr (two_words_value);

	file_name = zone_ptr -> f_name_8;

	call check_fsb_thread;

	global_flags = "0"b;
	next_element = "0"b;

	if baseno (fsb_ptr) = baseno (sp) then local_file = "1"b;
	else permanent_file = "1"b;

	if type_ = 1 then do;
	     file_is_text = 1;
	     buff_len = size_;
	end;
	else do;
	     if type_ = 0 then do;
		file_is_text = 0;
		rec_length = size_;
	     end;
	     else go to error_while_init_fsb;
	end;

	allocated_size = 0;				/* NOT allocated by runtime */
	system_ptr = null;
	uid = unique_bits_ ();
	if sp -> translator_id = "000006"b3 then
	     owner_link = sp -> old_pascal_stack_frame.linkage_ptr;
	else
	     owner_link = sp -> pascal_stack_frame.linkage_ptr;
	owner_symbol = owner_link -> header.symbol_ptr;
	SOL_fstatus, SOL_fpos = 0;
	owner_stack = sp;
						/* chain fsb */
	next_fsb_ptr = pascal_operators_statics_$first_file_ptr;
	pascal_operators_statics_$first_file_ptr = fsb_ptr;
	if last_file_ptr = null then last_file_ptr = fsb_ptr;
	fsb_is_chained = "1"b;

	call pascal_operators_$init_fsb_return;

error_while_init_fsb:
	call ioa_$rsnnl ("^/pascal_io_$init_fsb: Internal checking: Bad parameters were given to this operator.",
	     pascal_operators_statics_$error_info.string, string_length);
	go to fatal_error;
%page;
%include pascal_fsb;
%page;
%include pascal_ops_statics;
%page;
%include linkdcl;
%page;
%include pl1_symbol_block;
%page;
%include std_symbol_header;
%page;
%include stack_frame;
%page;
%include pascal_stack_frame;
%page;
%include on_unit;
%page;
%include iocbx;
%page;
%page;
%include runtime_symbol_info_;
%include cp_active_string_types;


     end pascal_io_;
